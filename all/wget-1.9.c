/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 213 "/usr/lib/gcc-lib/i486-linux/3.3.5/include/stddef.h"
typedef unsigned int size_t;
#line 136 "/usr/include/bits/types.h"
typedef unsigned long long __dev_t;
#line 137 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 138 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 141 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 142 "/usr/include/bits/types.h"
typedef unsigned int __nlink_t;
#line 143 "/usr/include/bits/types.h"
typedef long __off_t;
#line 144 "/usr/include/bits/types.h"
typedef long long __off64_t;
#line 145 "/usr/include/bits/types.h"
typedef int __pid_t;
#line 151 "/usr/include/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/bits/types.h"
typedef long __suseconds_t;
#line 166 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 171 "/usr/include/bits/types.h"
typedef long __blkcnt_t;
#line 182 "/usr/include/bits/types.h"
typedef int __ssize_t;
#line 46 "/usr/include/stdio.h"
struct _IO_FILE;
#line 46 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 173 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 179 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 264 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   int _mode ;
   char _unused2[15UL * sizeof(int ) - 2UL * sizeof(void *)] ;
};
#line 100 "/usr/include/sys/types.h"
typedef __pid_t pid_t;
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 76 "/usr/include/time.h"
typedef __time_t time_t;
#line 28 "/usr/include/bits/sigset.h"
struct __anonstruct___sigset_t_15 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 28 "/usr/include/bits/sigset.h"
typedef struct __anonstruct___sigset_t_15 __sigset_t;
#line 118 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 69 "/usr/include/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 38 "/usr/include/utime.h"
struct utimbuf {
   __time_t actime ;
   __time_t modtime ;
};
#line 36 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
#line 28 "/usr/include/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 73 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 38 "/usr/include/bits/setjmp.h"
typedef int __jmp_buf[6];
#line 36 "/usr/include/setjmp.h"
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
#line 98 "/usr/include/setjmp.h"
typedef struct __jmp_buf_tag sigjmp_buf[1];
#line 56 "/usr/include/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 62 "/usr/include/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 107 "/usr/include/sys/time.h"
struct itimerval {
   struct timeval it_interval ;
   struct timeval it_value ;
};
#line 120 "/usr/include/sys/time.h"
typedef int __itimer_which_t;
#line 131 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 147 "sysdep.h"
typedef long long LARGE_INT;
#line 33 "options.h"
enum __anonenum_restrict_files_os_46 {
    restrict_unix = 0,
    restrict_windows = 1
} ;
#line 33 "options.h"
struct options {
   int verbose ;
   int quiet ;
   int ntry ;
   int retry_connrefused ;
   int background ;
   int kill_longer ;
   int ignore_length ;
   int recursive ;
   int spanhost ;
   int relative_only ;
   int no_parent ;
   int reclevel ;
   int dirstruct ;
   int no_dirstruct ;
   int cut_dirs ;
   int add_hostdir ;
   int noclobber ;
   char *dir_prefix ;
   char *lfilename ;
   char *input_filename ;
   int force_html ;
   int spider ;
   char **accepts ;
   char **rejects ;
   char **excludes ;
   char **includes ;
   char **domains ;
   char **exclude_domains ;
   int dns_cache ;
   char **follow_tags ;
   char **ignore_tags ;
   int follow_ftp ;
   int retr_symlinks ;
   char *output_document ;
   int od_known_regular ;
   FILE *dfp ;
   int always_rest ;
   char *ftp_acc ;
   char *ftp_pass ;
   int netrc ;
   int ftp_glob ;
   int ftp_pasv ;
   char *http_user ;
   char *http_passwd ;
   char *user_header ;
   int http_keep_alive ;
   int use_proxy ;
   int allow_cache ;
   char *http_proxy ;
   char *ftp_proxy ;
   char *https_proxy ;
   char **no_proxy ;
   char *base_href ;
   char *progress_type ;
   char *proxy_user ;
   char *proxy_passwd ;
   double read_timeout ;
   double dns_timeout ;
   double connect_timeout ;
   int random_wait ;
   double wait ;
   double waitretry ;
   int use_robots ;
   long limit_rate ;
   LARGE_INT quota ;
   int numurls ;
   int server_response ;
   int save_headers ;
   int debug ;
   int timestamping ;
   int backup_converted ;
   int backups ;
   char *useragent ;
   char *referer ;
   int convert_links ;
   int remove_listing ;
   int htmlify ;
   char *dot_style ;
   long dot_bytes ;
   int dots_in_line ;
   int dot_spacing ;
   int delete_after ;
   int html_extension ;
   int page_requisites ;
   char *bind_address ;
   char *sslcadir ;
   char *sslcafile ;
   char *sslcertfile ;
   char *sslcertkey ;
   int sslcerttype ;
   int sslcheckcert ;
   char *sslegdsock ;
   int sslprotocol ;
   int cookies ;
   char *cookies_input ;
   char *cookies_output ;
   char *post_data ;
   char *post_file_name ;
   enum __anonenum_restrict_files_os_46 restrict_files_os ;
   int restrict_files_ctrl ;
   int strict_comments ;
};
#line 109 "wget.h"
enum log_options {
    LOG_VERBOSE = 0,
    LOG_NOTQUIET = 1,
    LOG_NONVERBOSE = 2,
    LOG_ALWAYS = 3
} ;
#line 33 "utils.h"
enum accd {
    ALLABS = 1
} ;
#line 38 "utils.h"
struct _slist {
   char *string ;
   struct _slist *next ;
};
#line 38 "utils.h"
typedef struct _slist slist;
#line 44
struct hash_table;
#line 46 "utils.h"
struct file_memory {
   char *content ;
   long length ;
   int mmap_p ;
};
#line 52
struct wget_timer;
#line 1544 "utils.c"
typedef struct timeval wget_sys_time;
#line 1555 "utils.c"
struct wget_timer {
   wget_sys_time start ;
   double elapsed_last ;
   double elapsed_pre_start ;
};
#line 41 "url.h"
enum url_scheme {
    SCHEME_HTTP = 0,
    SCHEME_HTTPS = 1,
    SCHEME_FTP = 2,
    SCHEME_INVALID = 3
} ;
#line 51 "url.h"
struct url {
   char *url ;
   enum url_scheme scheme ;
   char *host ;
   int port ;
   char *path ;
   char *params ;
   char *query ;
   char *fragment ;
   char *dir ;
   char *file ;
   char *user ;
   char *passwd ;
};
#line 55 "url.c"
struct scheme_data {
   char *leading_string ;
   int default_port ;
   int enabled ;
};
#line 231
enum copy_method {
    CM_DECODE = 0,
    CM_ENCODE = 1,
    CM_PASSTHROUGH = 2
} ;
#line 1306 "url.c"
struct growable {
   char *base ;
   int size ;
   int tail ;
};
#line 66 "/usr/include/openssl/stack.h"
struct stack_st {
   int num ;
   char **data ;
   int sorted ;
   int num_alloc ;
   int (*comp)(char const   * const  * , char const   * const  * ) ;
};
#line 66 "/usr/include/openssl/stack.h"
typedef struct stack_st STACK;
#line 192 "/usr/include/openssl/crypto.h"
struct bio_st;
#line 194 "/usr/include/openssl/crypto.h"
struct crypto_ex_data_st {
   STACK *sk ;
   int dummy ;
};
#line 194 "/usr/include/openssl/crypto.h"
typedef struct crypto_ex_data_st CRYPTO_EX_DATA;
#line 217 "/usr/include/openssl/bio.h"
typedef struct bio_st BIO;
#line 219 "/usr/include/openssl/bio.h"
typedef void bio_info_cb(struct bio_st * , int  , char const   * , int  , long  ,
                         long  );
#line 222 "/usr/include/openssl/bio.h"
struct bio_method_st {
   int type ;
   char const   *name ;
   int (*bwrite)(BIO * , char const   * , int  ) ;
   int (*bread)(BIO * , char * , int  ) ;
   int (*bputs)(BIO * , char const   * ) ;
   int (*bgets)(BIO * , char * , int  ) ;
   long (*ctrl)(BIO * , int  , long  , void * ) ;
   int (*create)(BIO * ) ;
   int (*destroy)(BIO * ) ;
   long (*callback_ctrl)(BIO * , int  , bio_info_cb * ) ;
};
#line 222 "/usr/include/openssl/bio.h"
typedef struct bio_method_st BIO_METHOD;
#line 251 "/usr/include/openssl/bio.h"
struct bio_st {
   BIO_METHOD *method ;
   long (*callback)(struct bio_st * , int  , char const   * , int  , long  , long  ) ;
   char *cb_arg ;
   int init ;
   int shutdown ;
   int flags ;
   int retry_reason ;
   int num ;
   void *ptr ;
   struct bio_st *next_bio ;
   struct bio_st *prev_bio ;
   int references ;
   unsigned long num_read ;
   unsigned long num_write ;
   CRYPTO_EX_DATA ex_data ;
};
#line 69 "/usr/include/openssl/buffer.h"
struct buf_mem_st {
   int length ;
   char *data ;
   int max ;
};
#line 69 "/usr/include/openssl/buffer.h"
typedef struct buf_mem_st BUF_MEM;
#line 79 "/usr/include/openssl/ossl_typ.h"
struct asn1_string_st;
#line 79 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_INTEGER;
#line 80 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_ENUMERATED;
#line 81 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_BIT_STRING;
#line 82 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_OCTET_STRING;
#line 83 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_PRINTABLESTRING;
#line 84 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_T61STRING;
#line 85 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_IA5STRING;
#line 86 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_GENERALSTRING;
#line 87 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_UNIVERSALSTRING;
#line 88 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_BMPSTRING;
#line 89 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_UTCTIME;
#line 90 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_TIME;
#line 91 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_GENERALIZEDTIME;
#line 92 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_VISIBLESTRING;
#line 93 "/usr/include/openssl/ossl_typ.h"
typedef struct asn1_string_st ASN1_UTF8STRING;
#line 94 "/usr/include/openssl/ossl_typ.h"
typedef int ASN1_BOOLEAN;
#line 103
struct evp_cipher_st;
#line 103 "/usr/include/openssl/ossl_typ.h"
typedef struct evp_cipher_st EVP_CIPHER;
#line 104
struct evp_cipher_ctx_st;
#line 104 "/usr/include/openssl/ossl_typ.h"
typedef struct evp_cipher_ctx_st EVP_CIPHER_CTX;
#line 105
struct env_md_st;
#line 105 "/usr/include/openssl/ossl_typ.h"
typedef struct env_md_st EVP_MD;
#line 106
struct env_md_ctx_st;
#line 106 "/usr/include/openssl/ossl_typ.h"
typedef struct env_md_ctx_st EVP_MD_CTX;
#line 107
struct evp_pkey_st;
#line 107 "/usr/include/openssl/ossl_typ.h"
typedef struct evp_pkey_st EVP_PKEY;
#line 109
struct x509_st;
#line 109 "/usr/include/openssl/ossl_typ.h"
typedef struct x509_st X509;
#line 110
struct X509_algor_st;
#line 110 "/usr/include/openssl/ossl_typ.h"
typedef struct X509_algor_st X509_ALGOR;
#line 111
struct X509_crl_st;
#line 111 "/usr/include/openssl/ossl_typ.h"
typedef struct X509_crl_st X509_CRL;
#line 112
struct X509_name_st;
#line 112 "/usr/include/openssl/ossl_typ.h"
typedef struct X509_name_st X509_NAME;
#line 113
struct x509_store_st;
#line 113 "/usr/include/openssl/ossl_typ.h"
typedef struct x509_store_st X509_STORE;
#line 114
struct x509_store_ctx_st;
#line 114 "/usr/include/openssl/ossl_typ.h"
typedef struct x509_store_ctx_st X509_STORE_CTX;
#line 116
struct engine_st;
#line 116 "/usr/include/openssl/ossl_typ.h"
typedef struct engine_st ENGINE;
#line 232 "/usr/include/openssl/bn.h"
struct bignum_st {
   unsigned long *d ;
   int top ;
   int dmax ;
   int neg ;
   int flags ;
};
#line 232 "/usr/include/openssl/bn.h"
typedef struct bignum_st BIGNUM;
#line 243
struct bignum_ctx;
#line 243 "/usr/include/openssl/bn.h"
typedef struct bignum_ctx BN_CTX;
#line 245 "/usr/include/openssl/bn.h"
struct bn_blinding_st {
   int init ;
   BIGNUM *A ;
   BIGNUM *Ai ;
   BIGNUM *mod ;
   unsigned long thread_id ;
};
#line 245 "/usr/include/openssl/bn.h"
typedef struct bn_blinding_st BN_BLINDING;
#line 256 "/usr/include/openssl/bn.h"
struct bn_mont_ctx_st {
   int ri ;
   BIGNUM RR ;
   BIGNUM N ;
   BIGNUM Ni ;
   unsigned long n0 ;
   int flags ;
};
#line 256 "/usr/include/openssl/bn.h"
typedef struct bn_mont_ctx_st BN_MONT_CTX;
#line 184 "/usr/include/openssl/asn1.h"
struct asn1_object_st {
   char const   *sn ;
   char const   *ln ;
   int nid ;
   int length ;
   unsigned char *data ;
   int flags ;
};
#line 184 "/usr/include/openssl/asn1.h"
typedef struct asn1_object_st ASN1_OBJECT;
#line 195 "/usr/include/openssl/asn1.h"
struct asn1_string_st {
   int length ;
   int type ;
   unsigned char *data ;
   long flags ;
};
#line 195 "/usr/include/openssl/asn1.h"
typedef struct asn1_string_st ASN1_STRING;
#line 212 "/usr/include/openssl/asn1.h"
struct ASN1_ENCODING_st {
   unsigned char *enc ;
   long len ;
   int modified ;
};
#line 212 "/usr/include/openssl/asn1.h"
typedef struct ASN1_ENCODING_st ASN1_ENCODING;
#line 444 "/usr/include/openssl/asn1.h"
union __anonunion_value_28 {
   char *ptr ;
   ASN1_BOOLEAN boolean ;
   ASN1_STRING *asn1_string ;
   ASN1_OBJECT *object ;
   ASN1_INTEGER *integer ;
   ASN1_ENUMERATED *enumerated ;
   ASN1_BIT_STRING *bit_string ;
   ASN1_OCTET_STRING *octet_string ;
   ASN1_PRINTABLESTRING *printablestring ;
   ASN1_T61STRING *t61string ;
   ASN1_IA5STRING *ia5string ;
   ASN1_GENERALSTRING *generalstring ;
   ASN1_BMPSTRING *bmpstring ;
   ASN1_UNIVERSALSTRING *universalstring ;
   ASN1_UTCTIME *utctime ;
   ASN1_GENERALIZEDTIME *generalizedtime ;
   ASN1_VISIBLESTRING *visiblestring ;
   ASN1_UTF8STRING *utf8string ;
   ASN1_STRING *set ;
   ASN1_STRING *sequence ;
};
#line 444 "/usr/include/openssl/asn1.h"
struct asn1_type_st {
   int type ;
   union __anonunion_value_28 value ;
};
#line 444 "/usr/include/openssl/asn1.h"
typedef struct asn1_type_st ASN1_TYPE;
#line 83 "/usr/include/openssl/rsa.h"
struct rsa_st;
#line 83 "/usr/include/openssl/rsa.h"
typedef struct rsa_st RSA;
#line 85 "/usr/include/openssl/rsa.h"
struct rsa_meth_st {
   char const   *name ;
   int (*rsa_pub_enc)(int flen , unsigned char const   *from , unsigned char *to ,
                      RSA *rsa , int padding ) ;
   int (*rsa_pub_dec)(int flen , unsigned char const   *from , unsigned char *to ,
                      RSA *rsa , int padding ) ;
   int (*rsa_priv_enc)(int flen , unsigned char const   *from , unsigned char *to ,
                       RSA *rsa , int padding ) ;
   int (*rsa_priv_dec)(int flen , unsigned char const   *from , unsigned char *to ,
                       RSA *rsa , int padding ) ;
   int (*rsa_mod_exp)(BIGNUM *r0 , BIGNUM const   *I , RSA *rsa ) ;
   int (*bn_mod_exp)(BIGNUM *r , BIGNUM const   *a , BIGNUM const   *p , BIGNUM const   *m ,
                     BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(RSA *rsa ) ;
   int (*finish)(RSA *rsa ) ;
   int flags ;
   char *app_data ;
   int (*rsa_sign)(int type , unsigned char const   *m , unsigned int m_length , unsigned char *sigret ,
                   unsigned int *siglen , RSA const   *rsa ) ;
   int (*rsa_verify)(int dtype , unsigned char const   *m , unsigned int m_length ,
                     unsigned char *sigbuf , unsigned int siglen , RSA const   *rsa ) ;
};
#line 85 "/usr/include/openssl/rsa.h"
typedef struct rsa_meth_st RSA_METHOD;
#line 124 "/usr/include/openssl/rsa.h"
struct rsa_st {
   int pad ;
   long version ;
   RSA_METHOD const   *meth ;
   ENGINE *engine ;
   BIGNUM *n ;
   BIGNUM *e ;
   BIGNUM *d ;
   BIGNUM *p ;
   BIGNUM *q ;
   BIGNUM *dmp1 ;
   BIGNUM *dmq1 ;
   BIGNUM *iqmp ;
   CRYPTO_EX_DATA ex_data ;
   int references ;
   int flags ;
   BN_MONT_CTX *_method_mod_n ;
   BN_MONT_CTX *_method_mod_p ;
   BN_MONT_CTX *_method_mod_q ;
   char *bignum_data ;
   BN_BLINDING *blinding ;
};
#line 83 "/usr/include/openssl/dh.h"
struct dh_st;
#line 83 "/usr/include/openssl/dh.h"
typedef struct dh_st DH;
#line 85 "/usr/include/openssl/dh.h"
struct dh_method {
   char const   *name ;
   int (*generate_key)(DH *dh ) ;
   int (*compute_key)(unsigned char *key , BIGNUM const   *pub_key , DH *dh ) ;
   int (*bn_mod_exp)(DH const   *dh , BIGNUM *r , BIGNUM const   *a , BIGNUM const   *p ,
                     BIGNUM const   *m , BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(DH *dh ) ;
   int (*finish)(DH *dh ) ;
   int flags ;
   char *app_data ;
};
#line 85 "/usr/include/openssl/dh.h"
typedef struct dh_method DH_METHOD;
#line 100 "/usr/include/openssl/dh.h"
struct dh_st {
   int pad ;
   int version ;
   BIGNUM *p ;
   BIGNUM *g ;
   long length ;
   BIGNUM *pub_key ;
   BIGNUM *priv_key ;
   int flags ;
   char *method_mont_p ;
   BIGNUM *q ;
   BIGNUM *j ;
   unsigned char *seed ;
   int seedlen ;
   BIGNUM *counter ;
   int references ;
   CRYPTO_EX_DATA ex_data ;
   DH_METHOD const   *meth ;
   ENGINE *engine ;
};
#line 96 "/usr/include/openssl/dsa.h"
struct dsa_st;
#line 96 "/usr/include/openssl/dsa.h"
typedef struct dsa_st DSA;
#line 98 "/usr/include/openssl/dsa.h"
struct DSA_SIG_st {
   BIGNUM *r ;
   BIGNUM *s ;
};
#line 98 "/usr/include/openssl/dsa.h"
typedef struct DSA_SIG_st DSA_SIG;
#line 104 "/usr/include/openssl/dsa.h"
struct dsa_method {
   char const   *name ;
   DSA_SIG *(*dsa_do_sign)(unsigned char const   *dgst , int dlen , DSA *dsa ) ;
   int (*dsa_sign_setup)(DSA *dsa , BN_CTX *ctx_in , BIGNUM **kinvp , BIGNUM **rp ) ;
   int (*dsa_do_verify)(unsigned char const   *dgst , int dgst_len , DSA_SIG *sig ,
                        DSA *dsa ) ;
   int (*dsa_mod_exp)(DSA *dsa , BIGNUM *rr , BIGNUM *a1 , BIGNUM *p1 , BIGNUM *a2 ,
                      BIGNUM *p2 , BIGNUM *m , BN_CTX *ctx , BN_MONT_CTX *in_mont ) ;
   int (*bn_mod_exp)(DSA *dsa , BIGNUM *r , BIGNUM *a , BIGNUM const   *p , BIGNUM const   *m ,
                     BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(DSA *dsa ) ;
   int (*finish)(DSA *dsa ) ;
   int flags ;
   char *app_data ;
};
#line 104 "/usr/include/openssl/dsa.h"
typedef struct dsa_method DSA_METHOD;
#line 123 "/usr/include/openssl/dsa.h"
struct dsa_st {
   int pad ;
   long version ;
   int write_params ;
   BIGNUM *p ;
   BIGNUM *q ;
   BIGNUM *g ;
   BIGNUM *pub_key ;
   BIGNUM *priv_key ;
   BIGNUM *kinv ;
   BIGNUM *r ;
   int flags ;
   char *method_mont_p ;
   int references ;
   CRYPTO_EX_DATA ex_data ;
   DSA_METHOD const   *meth ;
   ENGINE *engine ;
};
#line 177 "/usr/include/openssl/evp.h"
union __anonunion_pkey_29 {
   char *ptr ;
   struct rsa_st *rsa ;
   struct dsa_st *dsa ;
   struct dh_st *dh ;
};
#line 177 "/usr/include/openssl/evp.h"
struct evp_pkey_st {
   int type ;
   int save_type ;
   int references ;
   union __anonunion_pkey_29 pkey ;
   int save_parameters ;
   STACK *attributes ;
};
#line 271 "/usr/include/openssl/evp.h"
struct env_md_st {
   int type ;
   int pkey_type ;
   int md_size ;
   unsigned long flags ;
   int (*init)(EVP_MD_CTX *ctx ) ;
   int (*update)(EVP_MD_CTX *ctx , void const   *data , unsigned long count ) ;
   int (*final)(EVP_MD_CTX *ctx , unsigned char *md ) ;
   int (*copy)(EVP_MD_CTX *to , EVP_MD_CTX const   *from ) ;
   int (*cleanup)(EVP_MD_CTX *ctx ) ;
   int (*sign)() ;
   int (*verify)() ;
   int required_pkey_type[5] ;
   int block_size ;
   int ctx_size ;
};
#line 318 "/usr/include/openssl/evp.h"
struct env_md_ctx_st {
   EVP_MD const   *digest ;
   ENGINE *engine ;
   unsigned long flags ;
   void *md_data ;
};
#line 335 "/usr/include/openssl/evp.h"
struct evp_cipher_st {
   int nid ;
   int block_size ;
   int key_len ;
   int iv_len ;
   unsigned long flags ;
   int (*init)(EVP_CIPHER_CTX *ctx , unsigned char const   *key , unsigned char const   *iv ,
               int enc ) ;
   int (*do_cipher)(EVP_CIPHER_CTX *ctx , unsigned char *out , unsigned char const   *in ,
                    unsigned int inl ) ;
   int (*cleanup)(EVP_CIPHER_CTX * ) ;
   int ctx_size ;
   int (*set_asn1_parameters)(EVP_CIPHER_CTX * , ASN1_TYPE * ) ;
   int (*get_asn1_parameters)(EVP_CIPHER_CTX * , ASN1_TYPE * ) ;
   int (*ctrl)(EVP_CIPHER_CTX * , int type , int arg , void *ptr ) ;
   void *app_data ;
};
#line 392 "/usr/include/openssl/evp.h"
struct evp_cipher_ctx_st {
   EVP_CIPHER const   *cipher ;
   ENGINE *engine ;
   int encrypt ;
   int buf_len ;
   unsigned char oiv[16] ;
   unsigned char iv[16] ;
   unsigned char buf[32] ;
   int num ;
   void *app_data ;
   int key_len ;
   unsigned long flags ;
   void *cipher_data ;
   int final_used ;
   int block_mask ;
   unsigned char final[32] ;
};
#line 124 "/usr/include/openssl/x509.h"
struct X509_algor_st {
   ASN1_OBJECT *algorithm ;
   ASN1_TYPE *parameter ;
};
#line 133 "/usr/include/openssl/x509.h"
struct X509_val_st {
   ASN1_TIME *notBefore ;
   ASN1_TIME *notAfter ;
};
#line 133 "/usr/include/openssl/x509.h"
typedef struct X509_val_st X509_VAL;
#line 139 "/usr/include/openssl/x509.h"
struct X509_pubkey_st {
   X509_ALGOR *algor ;
   ASN1_BIT_STRING *public_key ;
   EVP_PKEY *pkey ;
};
#line 139 "/usr/include/openssl/x509.h"
typedef struct X509_pubkey_st X509_PUBKEY;
#line 164 "/usr/include/openssl/x509.h"
struct X509_name_st {
   STACK *entries ;
   int modified ;
   BUF_MEM *bytes ;
   unsigned long hash ;
};
#line 224 "/usr/include/openssl/x509.h"
struct x509_cinf_st {
   ASN1_INTEGER *version ;
   ASN1_INTEGER *serialNumber ;
   X509_ALGOR *signature ;
   X509_NAME *issuer ;
   X509_VAL *validity ;
   X509_NAME *subject ;
   X509_PUBKEY *key ;
   ASN1_BIT_STRING *issuerUID ;
   ASN1_BIT_STRING *subjectUID ;
   STACK *extensions ;
};
#line 224 "/usr/include/openssl/x509.h"
typedef struct x509_cinf_st X509_CINF;
#line 244 "/usr/include/openssl/x509.h"
struct x509_cert_aux_st {
   STACK *trust ;
   STACK *reject ;
   ASN1_UTF8STRING *alias ;
   ASN1_OCTET_STRING *keyid ;
   STACK *other ;
};
#line 244 "/usr/include/openssl/x509.h"
typedef struct x509_cert_aux_st X509_CERT_AUX;
#line 253
struct AUTHORITY_KEYID_st;
#line 253 "/usr/include/openssl/x509.h"
struct x509_st {
   X509_CINF *cert_info ;
   X509_ALGOR *sig_alg ;
   ASN1_BIT_STRING *signature ;
   int valid ;
   int references ;
   char *name ;
   CRYPTO_EX_DATA ex_data ;
   long ex_pathlen ;
   unsigned long ex_flags ;
   unsigned long ex_kusage ;
   unsigned long ex_xkusage ;
   unsigned long ex_nscert ;
   ASN1_OCTET_STRING *skid ;
   struct AUTHORITY_KEYID_st *akid ;
   unsigned char sha1_hash[20] ;
   X509_CERT_AUX *aux ;
};
#line 404 "/usr/include/openssl/x509.h"
struct X509_crl_info_st {
   ASN1_INTEGER *version ;
   X509_ALGOR *sig_alg ;
   X509_NAME *issuer ;
   ASN1_TIME *lastUpdate ;
   ASN1_TIME *nextUpdate ;
   STACK *revoked ;
   STACK *extensions ;
   ASN1_ENCODING enc ;
};
#line 404 "/usr/include/openssl/x509.h"
typedef struct X509_crl_info_st X509_CRL_INFO;
#line 416 "/usr/include/openssl/x509.h"
struct X509_crl_st {
   X509_CRL_INFO *crl ;
   X509_ALGOR *sig_alg ;
   ASN1_BIT_STRING *signature ;
   int references ;
};
#line 78 "/usr/include/openssl/lhash.h"
struct lhash_node_st {
   void const   *data ;
   struct lhash_node_st *next ;
   unsigned long hash ;
};
#line 78 "/usr/include/openssl/lhash.h"
typedef struct lhash_node_st LHASH_NODE;
#line 137 "/usr/include/openssl/lhash.h"
struct lhash_st {
   LHASH_NODE **b ;
   int (*comp)(void const   * , void const   * ) ;
   unsigned long (*hash)(void const   * ) ;
   unsigned int num_nodes ;
   unsigned int num_alloc_nodes ;
   unsigned int p ;
   unsigned int pmax ;
   unsigned long up_load ;
   unsigned long down_load ;
   unsigned long num_items ;
   unsigned long num_expands ;
   unsigned long num_expand_reallocs ;
   unsigned long num_contracts ;
   unsigned long num_contract_reallocs ;
   unsigned long num_hash_calls ;
   unsigned long num_comp_calls ;
   unsigned long num_insert ;
   unsigned long num_replace ;
   unsigned long num_delete ;
   unsigned long num_no_delete ;
   unsigned long num_retrieve ;
   unsigned long num_retrieve_miss ;
   unsigned long num_hash_comps ;
   int error ;
};
#line 161 "/usr/include/openssl/x509_vfy.h"
struct x509_store_st {
   int cache ;
   STACK *objs ;
   STACK *get_cert_methods ;
   unsigned long flags ;
   int purpose ;
   int trust ;
   int (*verify)(X509_STORE_CTX *ctx ) ;
   int (*verify_cb)(int ok , X509_STORE_CTX *ctx ) ;
   int (*get_issuer)(X509 **issuer , X509_STORE_CTX *ctx , X509 *x ) ;
   int (*check_issued)(X509_STORE_CTX *ctx , X509 *x , X509 *issuer ) ;
   int (*check_revocation)(X509_STORE_CTX *ctx ) ;
   int (*get_crl)(X509_STORE_CTX *ctx , X509_CRL **crl , X509 *x ) ;
   int (*check_crl)(X509_STORE_CTX *ctx , X509_CRL *crl ) ;
   int (*cert_crl)(X509_STORE_CTX *ctx , X509_CRL *crl , X509 *x ) ;
   int (*cleanup)(X509_STORE_CTX *ctx ) ;
   CRYPTO_EX_DATA ex_data ;
   int references ;
   int depth ;
};
#line 212 "/usr/include/openssl/x509_vfy.h"
struct x509_store_ctx_st {
   X509_STORE *ctx ;
   int current_method ;
   X509 *cert ;
   STACK *untrusted ;
   int purpose ;
   int trust ;
   time_t check_time ;
   unsigned long flags ;
   void *other_ctx ;
   int (*verify)(X509_STORE_CTX *ctx ) ;
   int (*verify_cb)(int ok , X509_STORE_CTX *ctx ) ;
   int (*get_issuer)(X509 **issuer , X509_STORE_CTX *ctx , X509 *x ) ;
   int (*check_issued)(X509_STORE_CTX *ctx , X509 *x , X509 *issuer ) ;
   int (*check_revocation)(X509_STORE_CTX *ctx ) ;
   int (*get_crl)(X509_STORE_CTX *ctx , X509_CRL **crl , X509 *x ) ;
   int (*check_crl)(X509_STORE_CTX *ctx , X509_CRL *crl ) ;
   int (*cert_crl)(X509_STORE_CTX *ctx , X509_CRL *crl , X509 *x ) ;
   int (*cleanup)(X509_STORE_CTX *ctx ) ;
   int depth ;
   int valid ;
   int last_untrusted ;
   STACK *chain ;
   int error_depth ;
   int error ;
   X509 *current_cert ;
   X509 *current_issuer ;
   X509_CRL *current_crl ;
   CRYPTO_EX_DATA ex_data ;
};
#line 11 "/usr/include/openssl/comp.h"
struct comp_method_st {
   int type ;
   char const   *name ;
   int (*init)() ;
   void (*finish)() ;
   int (*compress)() ;
   int (*expand)() ;
   long (*ctrl)() ;
   long (*callback_ctrl)() ;
};
#line 11 "/usr/include/openssl/comp.h"
typedef struct comp_method_st COMP_METHOD;
#line 23 "/usr/include/openssl/comp.h"
struct comp_ctx_st {
   COMP_METHOD *meth ;
   unsigned long compress_in ;
   unsigned long compress_out ;
   unsigned long expand_in ;
   unsigned long expand_out ;
   CRYPTO_EX_DATA ex_data ;
};
#line 23 "/usr/include/openssl/comp.h"
typedef struct comp_ctx_st COMP_CTX;
#line 480 "/usr/include/openssl/pem.h"
typedef int pem_password_cb(char *buf , int size , int rwflag , void *userdata );
#line 335 "/usr/include/openssl/ssl.h"
struct ssl_st;
#line 338 "/usr/include/openssl/ssl.h"
struct ssl_cipher_st {
   int valid ;
   char const   *name ;
   unsigned long id ;
   unsigned long algorithms ;
   unsigned long algo_strength ;
   unsigned long algorithm2 ;
   int strength_bits ;
   int alg_bits ;
   unsigned long mask ;
   unsigned long mask_strength ;
};
#line 338 "/usr/include/openssl/ssl.h"
typedef struct ssl_cipher_st SSL_CIPHER;
#line 354 "/usr/include/openssl/ssl.h"
typedef struct ssl_st SSL;
#line 355
struct ssl_ctx_st;
#line 355 "/usr/include/openssl/ssl.h"
typedef struct ssl_ctx_st SSL_CTX;
#line 358
struct ssl3_enc_method;
#line 358 "/usr/include/openssl/ssl.h"
struct ssl_method_st {
   int version ;
   int (*ssl_new)(SSL *s ) ;
   void (*ssl_clear)(SSL *s ) ;
   void (*ssl_free)(SSL *s ) ;
   int (*ssl_accept)(SSL *s ) ;
   int (*ssl_connect)(SSL *s ) ;
   int (*ssl_read)(SSL *s , void *buf , int len ) ;
   int (*ssl_peek)(SSL *s , void *buf , int len ) ;
   int (*ssl_write)(SSL *s , void const   *buf , int len ) ;
   int (*ssl_shutdown)(SSL *s ) ;
   int (*ssl_renegotiate)(SSL *s ) ;
   int (*ssl_renegotiate_check)(SSL *s ) ;
   long (*ssl_ctrl)(SSL *s , int cmd , long larg , void *parg ) ;
   long (*ssl_ctx_ctrl)(SSL_CTX *ctx , int cmd , long larg , void *parg ) ;
   SSL_CIPHER *(*get_cipher_by_char)(unsigned char const   *ptr ) ;
   int (*put_cipher_by_char)(SSL_CIPHER const   *cipher , unsigned char *ptr ) ;
   int (*ssl_pending)(SSL *s ) ;
   int (*num_ciphers)(void) ;
   SSL_CIPHER *(*get_cipher)(unsigned int ncipher ) ;
   struct ssl_method_st *(*get_ssl_method)(int version ) ;
   long (*get_timeout)(void) ;
   struct ssl3_enc_method *ssl3_enc ;
   int (*ssl_version)() ;
   long (*ssl_callback_ctrl)(SSL *s , int cb_id , void (*fp)() ) ;
   long (*ssl_ctx_callback_ctrl)(SSL_CTX *s , int cb_id , void (*fp)() ) ;
};
#line 358 "/usr/include/openssl/ssl.h"
typedef struct ssl_method_st SSL_METHOD;
#line 406
struct sess_cert_st;
#line 406 "/usr/include/openssl/ssl.h"
struct ssl_session_st {
   int ssl_version ;
   unsigned int key_arg_length ;
   unsigned char key_arg[8] ;
   int master_key_length ;
   unsigned char master_key[48] ;
   unsigned int session_id_length ;
   unsigned char session_id[32] ;
   unsigned int sid_ctx_length ;
   unsigned char sid_ctx[32] ;
   int not_resumable ;
   struct sess_cert_st *sess_cert ;
   X509 *peer ;
   long verify_result ;
   int references ;
   long timeout ;
   long time ;
   int compress_meth ;
   SSL_CIPHER *cipher ;
   unsigned long cipher_id ;
   STACK *ciphers ;
   CRYPTO_EX_DATA ex_data ;
   struct ssl_session_st *prev ;
   struct ssl_session_st *next ;
};
#line 406 "/usr/include/openssl/ssl.h"
typedef struct ssl_session_st SSL_SESSION;
#line 582 "/usr/include/openssl/ssl.h"
struct ssl_comp_st {
   int id ;
   char *name ;
   COMP_METHOD *method ;
};
#line 582 "/usr/include/openssl/ssl.h"
typedef struct ssl_comp_st SSL_COMP;
#line 595 "/usr/include/openssl/ssl.h"
struct __anonstruct_stats_35 {
   int sess_connect ;
   int sess_connect_renegotiate ;
   int sess_connect_good ;
   int sess_accept ;
   int sess_accept_renegotiate ;
   int sess_accept_good ;
   int sess_miss ;
   int sess_timeout ;
   int sess_cache_full ;
   int sess_hit ;
   int sess_cb_hit ;
};
#line 595
struct cert_st;
#line 595 "/usr/include/openssl/ssl.h"
struct ssl_ctx_st {
   SSL_METHOD *method ;
   STACK *cipher_list ;
   STACK *cipher_list_by_id ;
   struct x509_store_st *cert_store ;
   struct lhash_st *sessions ;
   unsigned long session_cache_size ;
   struct ssl_session_st *session_cache_head ;
   struct ssl_session_st *session_cache_tail ;
   int session_cache_mode ;
   long session_timeout ;
   int (*new_session_cb)(struct ssl_st *ssl , SSL_SESSION *sess ) ;
   void (*remove_session_cb)(struct ssl_ctx_st *ctx , SSL_SESSION *sess ) ;
   SSL_SESSION *(*get_session_cb)(struct ssl_st *ssl , unsigned char *data , int len ,
                                  int *copy ) ;
   struct __anonstruct_stats_35 stats ;
   int references ;
   int (*app_verify_callback)(X509_STORE_CTX * , void * ) ;
   void *app_verify_arg ;
   pem_password_cb *default_passwd_callback ;
   void *default_passwd_callback_userdata ;
   int (*client_cert_cb)(SSL *ssl , X509 **x509 , EVP_PKEY **pkey ) ;
   CRYPTO_EX_DATA ex_data ;
   EVP_MD const   *rsa_md5 ;
   EVP_MD const   *md5 ;
   EVP_MD const   *sha1 ;
   STACK *extra_certs ;
   STACK *comp_methods ;
   void (*info_callback)(SSL const   *ssl , int type , int val ) ;
   STACK *client_CA ;
   unsigned long options ;
   unsigned long mode ;
   long max_cert_list ;
   struct cert_st *cert ;
   int read_ahead ;
   void (*msg_callback)(int write_p , int version , int content_type , void const   *buf ,
                        size_t len , SSL *ssl , void *arg ) ;
   void *msg_callback_arg ;
   int verify_mode ;
   int verify_depth ;
   unsigned int sid_ctx_length ;
   unsigned char sid_ctx[32] ;
   int (*default_verify_callback)(int ok , X509_STORE_CTX *ctx ) ;
   int (*generate_session_id)(SSL const   *ssl , unsigned char *id , unsigned int *id_len ) ;
   int purpose ;
   int trust ;
   int quiet_shutdown ;
};
#line 778
struct ssl2_state_st;
#line 778
struct ssl3_state_st;
#line 778 "/usr/include/openssl/ssl.h"
struct ssl_st {
   int version ;
   int type ;
   SSL_METHOD *method ;
   BIO *rbio ;
   BIO *wbio ;
   BIO *bbio ;
   int rwstate ;
   int in_handshake ;
   int (*handshake_func)() ;
   int server ;
   int new_session ;
   int quiet_shutdown ;
   int shutdown ;
   int state ;
   int rstate ;
   BUF_MEM *init_buf ;
   void *init_msg ;
   int init_num ;
   int init_off ;
   unsigned char *packet ;
   unsigned int packet_length ;
   struct ssl2_state_st *s2 ;
   struct ssl3_state_st *s3 ;
   int read_ahead ;
   void (*msg_callback)(int write_p , int version , int content_type , void const   *buf ,
                        size_t len , SSL *ssl , void *arg ) ;
   void *msg_callback_arg ;
   int hit ;
   int purpose ;
   int trust ;
   STACK *cipher_list ;
   STACK *cipher_list_by_id ;
   EVP_CIPHER_CTX *enc_read_ctx ;
   EVP_MD const   *read_hash ;
   COMP_CTX *expand ;
   EVP_CIPHER_CTX *enc_write_ctx ;
   EVP_MD const   *write_hash ;
   COMP_CTX *compress ;
   struct cert_st *cert ;
   unsigned int sid_ctx_length ;
   unsigned char sid_ctx[32] ;
   SSL_SESSION *session ;
   int (*generate_session_id)(SSL const   *ssl , unsigned char *id , unsigned int *id_len ) ;
   int verify_mode ;
   int verify_depth ;
   int (*verify_callback)(int ok , X509_STORE_CTX *ctx ) ;
   void (*info_callback)(SSL const   *ssl , int type , int val ) ;
   int error ;
   int error_code ;
   SSL_CTX *ctx ;
   int debug ;
   long verify_result ;
   CRYPTO_EX_DATA ex_data ;
   STACK *client_CA ;
   int references ;
   unsigned long options ;
   unsigned long mode ;
   long max_cert_list ;
   int first_packet ;
   int client_version ;
};
#line 158 "/usr/include/openssl/ssl2.h"
struct __anonstruct_tmp_36 {
   unsigned int conn_id_length ;
   unsigned int cert_type ;
   unsigned int cert_length ;
   unsigned int csl ;
   unsigned int clear ;
   unsigned int enc ;
   unsigned char ccl[32] ;
   unsigned int cipher_spec_length ;
   unsigned int session_id_length ;
   unsigned int clen ;
   unsigned int rlen ;
};
#line 158 "/usr/include/openssl/ssl2.h"
struct ssl2_state_st {
   int three_byte_header ;
   int clear_text ;
   int escape ;
   int ssl2_rollback ;
   unsigned int wnum ;
   int wpend_tot ;
   unsigned char const   *wpend_buf ;
   int wpend_off ;
   int wpend_len ;
   int wpend_ret ;
   int rbuf_left ;
   int rbuf_offs ;
   unsigned char *rbuf ;
   unsigned char *wbuf ;
   unsigned char *write_ptr ;
   unsigned int padding ;
   unsigned int rlength ;
   int ract_data_length ;
   unsigned int wlength ;
   int wact_data_length ;
   unsigned char *ract_data ;
   unsigned char *wact_data ;
   unsigned char *mac_data ;
   unsigned char *read_key ;
   unsigned char *write_key ;
   unsigned int challenge_length ;
   unsigned char challenge[32] ;
   unsigned int conn_id_length ;
   unsigned char conn_id[16] ;
   unsigned int key_material_length ;
   unsigned char key_material[48] ;
   unsigned long read_sequence ;
   unsigned long write_sequence ;
   struct __anonstruct_tmp_36 tmp ;
};
#line 284 "/usr/include/openssl/ssl3.h"
struct ssl3_record_st {
   int type ;
   unsigned int length ;
   unsigned int off ;
   unsigned char *data ;
   unsigned char *input ;
   unsigned char *comp ;
};
#line 284 "/usr/include/openssl/ssl3.h"
typedef struct ssl3_record_st SSL3_RECORD;
#line 294 "/usr/include/openssl/ssl3.h"
struct ssl3_buffer_st {
   unsigned char *buf ;
   size_t len ;
   int offset ;
   int left ;
};
#line 294 "/usr/include/openssl/ssl3.h"
typedef struct ssl3_buffer_st SSL3_BUFFER;
#line 317 "/usr/include/openssl/ssl3.h"
struct __anonstruct_tmp_37 {
   unsigned char cert_verify_md[72] ;
   unsigned char finish_md[72] ;
   int finish_md_len ;
   unsigned char peer_finish_md[72] ;
   int peer_finish_md_len ;
   unsigned long message_size ;
   int message_type ;
   SSL_CIPHER *new_cipher ;
   DH *dh ;
   int next_state ;
   int reuse_message ;
   int cert_req ;
   int ctype_num ;
   char ctype[7] ;
   STACK *ca_names ;
   int use_rsa_tmp ;
   int key_block_length ;
   unsigned char *key_block ;
   EVP_CIPHER const   *new_sym_enc ;
   EVP_MD const   *new_hash ;
   SSL_COMP const   *new_compression ;
   int cert_request ;
};
#line 317 "/usr/include/openssl/ssl3.h"
struct ssl3_state_st {
   long flags ;
   int delay_buf_pop_ret ;
   unsigned char read_sequence[8] ;
   unsigned char read_mac_secret[36] ;
   unsigned char write_sequence[8] ;
   unsigned char write_mac_secret[36] ;
   unsigned char server_random[32] ;
   unsigned char client_random[32] ;
   int need_empty_fragments ;
   int empty_fragment_done ;
   SSL3_BUFFER rbuf ;
   SSL3_BUFFER wbuf ;
   SSL3_RECORD rrec ;
   SSL3_RECORD wrec ;
   unsigned char alert_fragment[2] ;
   unsigned int alert_fragment_len ;
   unsigned char handshake_fragment[4] ;
   unsigned int handshake_fragment_len ;
   unsigned int wnum ;
   int wpend_tot ;
   int wpend_type ;
   int wpend_ret ;
   unsigned char const   *wpend_buf ;
   EVP_MD_CTX finish_dgst1 ;
   EVP_MD_CTX finish_dgst2 ;
   int change_cipher_spec ;
   int warn_alert ;
   int fatal_alert ;
   int alert_dispatch ;
   unsigned char send_alert[2] ;
   int renegotiate ;
   int total_renegotiations ;
   int num_renegotiations ;
   int in_read_app_data ;
   struct __anonstruct_tmp_37 tmp ;
};
#line 276 "wget.h"
enum __anonenum_uerr_t_41 {
    NOCONERROR = 0,
    HOSTERR = 1,
    CONSOCKERR = 2,
    CONERROR = 3,
    CONSSLERR = 4,
    CONREFUSED = 5,
    NEWLOCATION = 6,
    NOTENOUGHMEM = 7,
    CONPORTERR = 8,
    BINDERR = 9,
    BINDOK = 10,
    LISTENERR = 11,
    ACCEPTERR = 12,
    ACCEPTOK = 13,
    CONCLOSED = 14,
    FTPOK = 15,
    FTPLOGINC = 16,
    FTPLOGREFUSED = 17,
    FTPPORTERR = 18,
    FTPNSFOD = 19,
    FTPRETROK = 20,
    FTPUNKNOWNTYPE = 21,
    FTPRERR = 22,
    FTPREXC = 23,
    FTPSRVERR = 24,
    FTPRETRINT = 25,
    FTPRESTFAIL = 26,
    URLERROR = 27,
    FOPENERR = 28,
    FWRITEERR = 29,
    HOK = 30,
    HLEXC = 31,
    HEOF = 32,
    HERR = 33,
    RETROK = 34,
    RECLEVELEXC = 35,
    FTPACCDENIED = 36,
    WRONGCODE = 37,
    FTPINVPASV = 38,
    FTPNOPASV = 39,
    CONTNOTSUPPORTED = 40,
    RETRUNNEEDED = 41,
    RETRFINISHED = 42,
    READERR = 43,
    TRYLIMEXC = 44,
    URLBADPATTERN = 45,
    FILEBADFILE = 46,
    RANGEERR = 47,
    RETRBADPATTERN = 48,
    RETNOTSUP = 49,
    ROBOTSOK = 50,
    NOROBOTS = 51,
    PROXERR = 52,
    AUTHFAILED = 53,
    QUOTEXC = 54,
    WRITEFAILED = 55,
    SSLERRCERTFILE = 56,
    SSLERRCERTKEY = 57,
    SSLERRCTXCREATE = 58
} ;
#line 276 "wget.h"
typedef enum __anonenum_uerr_t_41 uerr_t;
#line 152 "/usr/include/bits/types.h"
typedef unsigned int __useconds_t;
#line 38 "rbuf.h"
struct rbuf {
   int fd ;
   SSL *ssl ;
   char buffer[4096] ;
   char *buffer_pos ;
   size_t buffer_left ;
   int internal_dont_touch_this ;
};
#line 33 "recur.h"
struct urlpos;
#line 33 "convert.h"
enum convert_options {
    CO_NOCONVERT = 0,
    CO_CONVERT_TO_RELATIVE = 1,
    CO_CONVERT_TO_COMPLETE = 2,
    CO_NULLIFY_BASE = 3
} ;
#line 47 "convert.h"
struct urlpos {
   struct url *url ;
   char *local_name ;
   unsigned int ignore_when_downloading : 1 ;
   unsigned int link_relative_p : 1 ;
   unsigned int link_complete_p : 1 ;
   unsigned int link_base_p : 1 ;
   unsigned int link_inline_p : 1 ;
   unsigned int link_expect_html : 1 ;
   unsigned int link_refresh_p : 1 ;
   int refresh_timeout ;
   enum convert_options convert ;
   int pos ;
   int size ;
   struct urlpos *next ;
};
#line 73 "retr.c"
struct __anonstruct_limit_data_53 {
   long chunk_bytes ;
   double chunk_start ;
   double sleep_adjust ;
};
#line 33 "res.h"
struct robot_specs;
#line 91 "res.c"
struct path_info {
   char *path ;
   int allowedp ;
   int user_agent_exact_p ;
};
#line 97 "res.c"
struct robot_specs {
   int count ;
   int size ;
   struct path_info *paths ;
};
#line 294 "wget.h"
typedef unsigned char boolean;
#line 69 "recur.c"
struct queue_element {
   char const   *url ;
   char const   *referer ;
   int depth ;
   unsigned int html_allowed : 1 ;
   struct queue_element *next ;
};
#line 79 "recur.c"
struct url_queue {
   struct queue_element *head ;
   struct queue_element *tail ;
   int count ;
   int maxcount ;
};
#line 52 "progress.c"
struct progress_implementation {
   char *name ;
   void *(*create)(long  , long  ) ;
   void (*update)(void * , long  , double  ) ;
   void (*finish)(void * , double  ) ;
   void (*set_params)(char const   * ) ;
};
#line 191 "progress.c"
struct dot_progress {
   long initial_length ;
   long total_length ;
   int accumulated ;
   int rows ;
   int dots ;
   double last_timer_value ;
};
#line 425 "progress.c"
struct bar_progress_hist {
   int pos ;
   long times[20] ;
   long bytes[20] ;
   long total_time ;
   long total_bytes ;
};
#line 425 "progress.c"
struct bar_progress {
   long initial_length ;
   long total_length ;
   long count ;
   double last_screen_update ;
   int width ;
   char *buffer ;
   int tick ;
   struct bar_progress_hist hist ;
   double recent_start ;
   long recent_bytes ;
   double last_eta_time ;
   long last_eta_value ;
};
#line 33 "netrc.h"
struct _acc_t {
   char *host ;
   char *acc ;
   char *passwd ;
   struct _acc_t *next ;
};
#line 33 "netrc.h"
typedef struct _acc_t acc_t;
#line 266 "netrc.c"
enum __anonenum_last_token_26 {
    tok_nothing = 0,
    tok_account = 1,
    tok_login = 2,
    tok_macdef = 3,
    tok_machine = 4,
    tok_password = 5
} ;
#line 33 "gen-md5.h"
struct gen_md5_context;
#line 33 "gen-md5.h"
typedef struct gen_md5_context gen_md5_context;
#line 99 "/usr/include/openssl/md5.h"
struct MD5state_st {
   unsigned int A ;
   unsigned int B ;
   unsigned int C ;
   unsigned int D ;
   unsigned int Nl ;
   unsigned int Nh ;
   unsigned int data[16] ;
   int num ;
};
#line 99 "/usr/include/openssl/md5.h"
typedef struct MD5state_st MD5_CTX;
#line 47 "gen-md5.c"
typedef MD5_CTX gen_md5_context_imp;
#line 50 "gen-md5.c"
struct gen_md5_context {
   gen_md5_context_imp imp ;
};
#line 77 "getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 33 "cookies.h"
struct cookie_jar;
#line 43 "/usr/lib/gcc-lib/i486-linux/3.3.5/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 77 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 132 "log.c"
struct log_ln {
   char static_line[129] ;
   char *malloced_line ;
   char *content ;
};
#line 343 "log.c"
struct logvprintf_state {
   char *bigmsg ;
   int expected_size ;
   int allocated ;
};
#line 627
enum __anonenum_redirect_request_29 {
    RR_NONE = 0,
    RR_REQUESTED = 1,
    RR_DONE = 2
} ;
#line 50 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 113 "init.c"
struct __anonstruct_commands_38 {
   char *name ;
   void *closure ;
   int (*action)(char const   * , char const   * , void * ) ;
};
#line 45 "host.h"
struct address_list;
#line 37 "headers.h"
enum header_get_flags {
    HG_NONE = 0,
    HG_NO_CONTINUATIONS = 2
} ;
#line 79 "convert.h"
enum __anonenum_downloaded_file_t_52 {
    FILE_NOT_ALREADY_DOWNLOADED = 0,
    FILE_DOWNLOADED_NORMALLY = 1,
    FILE_DOWNLOADED_AND_HTML_EXTENSION_ADDED = 2,
    CHECK_FOR_FILE = 3
} ;
#line 79 "convert.h"
typedef enum __anonenum_downloaded_file_t_52 downloaded_file_t;
#line 248 "http.c"
struct http_process_range_closure {
   long first_byte_pos ;
   long last_byte_pos ;
   long entity_length ;
};
#line 565 "http.c"
struct http_stat {
   long len ;
   long contlen ;
   long restval ;
   int res ;
   char *newloc ;
   char *remote_time ;
   char *error ;
   int statcode ;
   double dltime ;
   int no_truncate ;
   char const   *referer ;
   char **local_file ;
};
#line 2364 "http.c"
struct __anonstruct_options_53 {
   char const   *name ;
   char **variable ;
};
#line 33 "html-parse.h"
struct attr_pair {
   char *name ;
   char *value ;
   char const   *value_raw_beginning ;
   int value_raw_size ;
   int name_pool_index ;
   int value_pool_index ;
};
#line 46 "html-parse.h"
struct taginfo {
   char *name ;
   int end_tag_p ;
   int nattrs ;
   struct attr_pair *attrs ;
   char const   *start_position ;
   char const   *end_position ;
};
#line 53 "html-url.c"
struct map_context;
#line 93 "html-url.c"
struct known_tag {
   int tagid ;
   char const   *name ;
   void (*handler)(int  , struct taginfo * , struct map_context * ) ;
};
#line 140 "html-url.c"
struct __anonstruct_tag_url_attributes_28 {
   int tagid ;
   char const   *attr_name ;
   int flags ;
};
#line 253 "html-url.c"
struct map_context {
   char *text ;
   char *base ;
   char const   *parent_base ;
   char const   *document_file ;
   int nofollow ;
   struct urlpos *head ;
   struct urlpos *tail ;
};
#line 156 "html-parse.c"
struct pool {
   char *contents ;
   int size ;
   int tail ;
   int resized ;
   char *orig_contents ;
   int orig_size ;
};
#line 452
enum __anonenum_state_26 {
    AC_S_DONE = 0,
    AC_S_BACKOUT = 1,
    AC_S_BANG = 2,
    AC_S_DEFAULT = 3,
    AC_S_DCLNAME = 4,
    AC_S_DASH1 = 5,
    AC_S_DASH2 = 6,
    AC_S_COMMENT = 7,
    AC_S_DASH3 = 8,
    AC_S_DASH4 = 9,
    AC_S_QUOTE1 = 10,
    AC_S_IN_QUOTE = 11,
    AC_S_QUOTE2 = 12
} ;
#line 50 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 52 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 194 "/usr/include/bits/types.h"
typedef unsigned int __socklen_t;
#line 199 "/usr/include/sys/types.h"
typedef unsigned int u_int32_t;
#line 36 "/usr/include/bits/socket.h"
typedef __socklen_t socklen_t;
#line 29 "/usr/include/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 145 "/usr/include/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 92 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 136 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 137 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 219 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 96 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 50 "host.h"
union __anonunion_wget_sockaddr_32 {
   struct sockaddr sa ;
   struct sockaddr_in sin ;
};
#line 50 "host.h"
typedef union __anonunion_wget_sockaddr_32 wget_sockaddr;
#line 58 "host.h"
struct __anonstruct_ip4_address_33 {
   unsigned char bytes[4] ;
};
#line 58 "host.h"
typedef struct __anonstruct_ip4_address_33 ip4_address;
#line 72 "host.h"
struct __anonstruct_ip_address_34 {
   unsigned char bytes[4] ;
};
#line 72 "host.h"
typedef struct __anonstruct_ip_address_34 ip_address;
#line 97 "host.c"
struct address_list {
   int count ;
   ip_address *addresses ;
   int faulty ;
   int refcount ;
};
#line 479 "host.c"
struct ghbnwt_context {
   char const   *host_name ;
   struct hostent *hptr ;
};
#line 156 "hash.c"
struct mapping {
   void *key ;
   void *value ;
};
#line 161 "hash.c"
struct hash_table {
   unsigned long (*hash_function)(void const   * ) ;
   int (*test_function)(void const   * , void const   * ) ;
   int size ;
   int count ;
   int resize_threshold ;
   int prime_offset ;
   struct mapping *mappings ;
};
#line 328 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 39 "ftp.h"
enum stype {
    ST_UNIX = 0,
    ST_VMS = 1,
    ST_WINNT = 2,
    ST_MACOS = 3,
    ST_OS400 = 4,
    ST_OTHER = 5
} ;
#line 69
enum ftype {
    FT_PLAINFILE = 0,
    FT_DIRECTORY = 1,
    FT_SYMLINK = 2,
    FT_UNKNOWN = 3
} ;
#line 85 "ftp.h"
struct fileinfo {
   enum ftype type ;
   char *name ;
   long size ;
   long tstamp ;
   int perms ;
   char *linkto ;
   struct fileinfo *prev ;
   struct fileinfo *next ;
};
#line 69 "ftp.c"
struct __anonstruct_ccon_53 {
   int st ;
   int cmd ;
   struct rbuf rbuf ;
   double dltime ;
   enum stype rs ;
   char *id ;
   char *target ;
   struct url *proxy ;
};
#line 69 "ftp.c"
typedef struct __anonstruct_ccon_53 ccon;
#line 79 "cookies.c"
struct cookie_jar {
   struct hash_table *chains ;
   int cookie_count ;
};
#line 99 "cookies.c"
struct cookie {
   char *domain ;
   int port ;
   char *path ;
   int secure ;
   int domain_exact ;
   int permanent ;
   time_t expiry_time ;
   int discard_requested ;
   char *attr ;
   char *value ;
   struct cookie *next ;
};
#line 474
enum __anonenum_state_26___0 {
    S_START = 0,
    S_NAME = 1,
    S_NAME_POST = 2,
    S_VALUE_PRE = 3,
    S_VALUE = 4,
    S_QUOTED_VALUE = 5,
    S_VALUE_TRAILSPACE = 6,
    S_ATTR_ACTION = 7,
    S_DONE = 8,
    S_ERROR = 9
} ;
#line 1011 "cookies.c"
struct weighed_cookie {
   struct cookie *cookie ;
   int domain_goodness ;
   int path_goodness ;
};
#line 55 "/usr/include/sys/select.h"
typedef long __fd_mask;
#line 67 "/usr/include/sys/select.h"
struct __anonstruct_fd_set_16 {
   __fd_mask fds_bits[1024UL / (8UL * sizeof(__fd_mask ))] ;
};
#line 67 "/usr/include/sys/select.h"
typedef struct __anonstruct_fd_set_16 fd_set;
#line 98 "connect.c"
struct cwt_context {
   int fd ;
   struct sockaddr  const  *addr ;
   socklen_t addrlen ;
   int result ;
};
#line 1 "version.c"
char *version_string  =    (char *)"1.9";
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 142 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 143
extern struct _IO_FILE *stdout ;
#line 144
extern struct _IO_FILE *stderr ;
#line 206
extern int fclose(FILE *__stream ) ;
#line 241
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 247
extern FILE *freopen(char const   * __restrict  __filename , char const   * __restrict  __modes ,
                     FILE * __restrict  __stream ) ;
#line 327
extern int printf(char const   * __restrict  __format  , ...) ;
#line 329
extern int sprintf(char * __restrict  __s , char const   * __restrict  __format  , ...) ;
#line 351
extern int ( /* format attribute */  snprintf)(char * __restrict  __s , size_t __maxlen ,
                                               char const   * __restrict  __format 
                                               , ...) ;
#line 526
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 643
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 648
extern long ftell(FILE *__stream ) ;
#line 724
extern int ferror(FILE *__stream ) ;
#line 740
extern void perror(char const   *__s ) ;
#line 752
extern int fileno(FILE *__stream ) ;
#line 473 "/usr/include/stdlib.h"
extern int rand(void) ;
#line 475
extern void srand(unsigned int __seed ) ;
#line 556
extern void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 567
extern void *realloc(void *__ptr , size_t __size )  __attribute__((__malloc__)) ;
#line 569
extern void free(void *__ptr ) ;
#line 612
extern  __attribute__((__noreturn__)) void exit(int __status ) ;
#line 38 "/usr/include/string.h"
extern void *memcpy(void * __restrict  __dest , void const   * __restrict  __src ,
                    size_t __n ) ;
#line 58
extern void *memset(void *__s , int __c , size_t __n ) ;
#line 82
extern char *strcpy(char * __restrict  __dest , char const   * __restrict  __src ) ;
#line 96
extern int strcmp(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__)) ;
#line 126
extern char *strdup(char const   *__s )  __attribute__((__malloc__)) ;
#line 164
extern char *strrchr(char const   *__s , int __c )  __attribute__((__pure__)) ;
#line 230
extern size_t strlen(char const   *__s )  __attribute__((__pure__)) ;
#line 243
extern char *strerror(int __errnum ) ;
#line 287
extern int strcasecmp(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__)) ;
#line 256 "/usr/include/unistd.h"
extern int access(char const   *__name , int __type ) ;
#line 305
extern int close(int __fd ) ;
#line 312
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 605
extern __pid_t setsid(void) ;
#line 690
extern __pid_t fork(void) ;
#line 736
extern int unlink(char const   *__name ) ;
#line 58 "/usr/include/sys/mman.h"
extern void *mmap(void *__addr , size_t __len , int __prot , int __flags , int __fd ,
                  __off_t __offset ) ;
#line 77
extern int munmap(void *__addr , size_t __len ) ;
#line 46 "/usr/include/utime.h"
extern int utime(char const   *__file , struct utimbuf  const  *__file_times ) ;
#line 38 "/usr/include/bits/errno.h"
extern int *__errno_location(void)  __attribute__((__const__)) ;
#line 207 "/usr/include/sys/stat.h"
__inline extern int stat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
#line 212
__inline extern int fstat(int __fd , struct stat *__statbuf ) ;
#line 235
__inline extern int lstat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
#line 281
extern int mkdir(char const   *__path , __mode_t __mode ) ;
#line 287
__inline extern int mknod(char const   *__path , __mode_t __mode , __dev_t __dev ) ;
#line 319
extern int __fxstat(int __ver , int __fildes , struct stat *__stat_buf ) ;
#line 320
extern int __xstat(int __ver , char const   *__filename , struct stat *__stat_buf ) ;
#line 322
extern int __lxstat(int __ver , char const   *__filename , struct stat *__stat_buf ) ;
#line 350
extern int __xmknod(int __ver , char const   *__path , __mode_t __mode , __dev_t *__dev ) ;
#line 356 "/usr/include/sys/stat.h"
__inline extern int stat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  {
#line 359
  tmp = __xstat(3, (char const   *)__path, (struct stat *)__statbuf);
  }
#line 359
  return (tmp);
}
}
#line 363 "/usr/include/sys/stat.h"
__inline extern int lstat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  {
#line 366
  tmp = __lxstat(3, (char const   *)__path, (struct stat *)__statbuf);
  }
#line 366
  return (tmp);
}
}
#line 370 "/usr/include/sys/stat.h"
__inline extern int fstat(int __fd , struct stat *__statbuf ) 
{ 
  int tmp ;

  {
  {
#line 372
  tmp = __fxstat(3, __fd, __statbuf);
  }
#line 372
  return (tmp);
}
}
#line 376 "/usr/include/sys/stat.h"
__inline extern int mknod(char const   *__path , __mode_t __mode , __dev_t __dev ) 
{ 
  int tmp ;

  {
  {
#line 379
  tmp = __xmknod(1, __path, __mode, & __dev);
  }
#line 379
  return (tmp);
}
}
#line 72 "/usr/include/fcntl.h"
extern int open(char const   *__file , int __oflag  , ...) ;
#line 70 "/usr/include/assert.h"
extern  __attribute__((__noreturn__)) void __assert_fail(char const   *__assertion ,
                                                         char const   *__file , unsigned int __line ,
                                                         char const   *__function ) ;
#line 42 "/usr/include/sys/ioctl.h"
extern int ioctl(int __fd , unsigned long __request  , ...) ;
#line 90 "/usr/include/signal.h"
extern __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
#line 58 "/usr/include/setjmp.h"
extern int __sigsetjmp(struct __jmp_buf_tag *__env , int __savemask ) ;
#line 108
extern  __attribute__((__noreturn__)) void siglongjmp(struct __jmp_buf_tag *__env ,
                                                      int __val ) ;
#line 40 "/usr/include/libintl.h"
extern char *gettext(char const   *__msgid ) ;
#line 72 "/usr/include/sys/time.h"
extern int gettimeofday(struct timeval * __restrict  __tv , __timezone_ptr_t __tz ) ;
#line 131
extern int setitimer(__itimer_which_t __which , struct itimerval  const  * __restrict  __new ,
                     struct itimerval * __restrict  __old ) ;
#line 184 "/usr/include/time.h"
extern time_t time(time_t *__timer ) ;
#line 233
extern struct tm *localtime(time_t const   *__timer ) ;
#line 78 "/usr/include/fnmatch.h"
extern int fnmatch(char const   *__pattern , char const   *__name , int __flags ) ;
#line 199 "options.h"
struct options opt ;
#line 101 "safe-ctype.h"
unsigned short const   _sch_istable[256] ;
#line 126
unsigned char const   _sch_tolower[256] ;
#line 112 "wget.h"
void ( /* format attribute */  logprintf)(enum log_options o , char const   *fmt 
                                          , ...) ;
#line 114
void ( /* format attribute */  debug_logprintf)(char const   *fmt  , ...) ;
#line 122
int log_set_save_context(int savep ) ;
#line 132
void *xmalloc_real(size_t size ) ;
#line 133
void *xrealloc_real(void *ptr , size_t newsize ) ;
#line 134
char *xstrdup_real(char const   *s ) ;
#line 259
char const   *exec_name ;
#line 54 "utils.h"
char *time_str(time_t *tm ) ;
#line 55
char *datetime_str(time_t *tm ) ;
#line 61
char *xstrdup_lower(char const   *s ) ;
#line 62
int count_char(char const   *string , char chr ) ;
#line 64
char *strdupdelim(char const   *beg , char const   *end ) ;
#line 65
char **sepstring(char const   *s ) ;
#line 66
int frontcmp(char const   *s1 , char const   *s2 ) ;
#line 68
void fork_to_background(void) ;
#line 70
void touch(char const   *file , time_t tm ) ;
#line 71
int remove_link(char const   *file ) ;
#line 72
int file_exists_p(char const   *filename ) ;
#line 73
int file_non_directory_p(char const   *path ) ;
#line 74
long file_size(char const   *filename ) ;
#line 75
int make_directory(char const   *directory ) ;
#line 76
char *unique_name(char const   *file , int allow_passthrough ) ;
#line 77
char *file_merge(char const   *base , char const   *file ) ;
#line 79
int acceptable(char const   *s ) ;
#line 80
int accdir(char const   *directory , enum accd flags ) ;
#line 81
char *suffix(char const   *str ) ;
#line 82
int match_tail(char const   *string , char const   *tail , int fold_case_p ) ;
#line 83
int has_wildcards_p(char const   *s ) ;
#line 85
int has_html_suffix_p(char const   *fname ) ;
#line 87
char *read_whole_line(FILE *fp ) ;
#line 88
struct file_memory *read_file(char const   *file ) ;
#line 89
void read_file_free(struct file_memory *fm ) ;
#line 91
void free_vec(char **vec ) ;
#line 92
char **merge_vecs(char **v1___0 , char **v2___0 ) ;
#line 93
slist *slist_append(slist *l , char const   *s ) ;
#line 94
slist *slist_prepend(slist *l , char const   *s ) ;
#line 95
slist *slist_nreverse(slist *l ) ;
#line 96
int slist_contains(slist *l , char const   *s ) ;
#line 97
void slist_free(slist *l ) ;
#line 99
void string_set_add(struct hash_table *ht , char const   *s ) ;
#line 100
int string_set_contains(struct hash_table *ht , char const   *s ) ;
#line 101
void string_set_free(struct hash_table *ht ) ;
#line 102
void free_keys_and_values(struct hash_table *ht ) ;
#line 104
char *legible(long l ) ;
#line 105
char *legible_large_int(LARGE_INT l ) ;
#line 106
int numdigit(long number ) ;
#line 107
char *number_to_string(char *buffer , long number ) ;
#line 109
struct wget_timer *wtimer_allocate(void) ;
#line 110
struct wget_timer *wtimer_new(void) ;
#line 111
void wtimer_delete(struct wget_timer *wt ) ;
#line 112
void wtimer_reset(struct wget_timer *wt ) ;
#line 113
double wtimer_elapsed(struct wget_timer *wt ) ;
#line 114
double wtimer_granularity(void) ;
#line 116
char *html_quote_string(char const   *s ) ;
#line 118
int determine_screen_width(void) ;
#line 119
int random_number(int max ) ;
#line 120
double random_float(void) ;
#line 122
int run_with_timeout(double timeout , void (*fun)(void * ) , void *arg ) ;
#line 51 "hash.h"
void hash_table_destroy(struct hash_table *ht ) ;
#line 56
int hash_table_contains(struct hash_table  const  *ht , void const   *key ) ;
#line 58
void hash_table_put(struct hash_table *ht , void const   *key , void *value ) ;
#line 62
void hash_table_map(struct hash_table *ht , int (*mapfun)(void * , void * , void * ) ,
                    void *maparg ) ;
#line 114 "utils.c"
static void memfatal(char const   *what ) 
{ 
  char *tmp ;

  {
  {
#line 119
  log_set_save_context(0);
#line 120
  tmp = gettext("%s: %s: Not enough memory.\n");
#line 120
  logprintf((enum log_options )3, (char const   *)tmp, exec_name, what);
#line 121
  exit(1);
  }
}
}
#line 154 "utils.c"
void *xmalloc_real(size_t size ) 
{ 
  void *ptr ;
  void *tmp ;

  {
  {
#line 157
  tmp = malloc(size);
#line 157
  ptr = tmp;
  }
#line 158
  if (! ptr) {
    {
#line 159
    memfatal("malloc");
    }
  }
#line 160
  return (ptr);
}
}
#line 163 "utils.c"
void *xrealloc_real(void *ptr , size_t newsize ) 
{ 
  void *newptr ;

  {
#line 171
  if (ptr) {
    {
#line 172
    newptr = realloc(ptr, newsize);
    }
  } else {
    {
#line 174
    newptr = malloc(newsize);
    }
  }
#line 175
  if (! newptr) {
    {
#line 176
    memfatal("realloc");
    }
  }
#line 177
  return (newptr);
}
}
#line 180 "utils.c"
char *xstrdup_real(char const   *s ) 
{ 
  char *copy ;

  {
  {
#line 192
  copy = strdup(s);
  }
#line 193
  if (! copy) {
    {
#line 194
    memfatal("strdup");
    }
  }
#line 197
  return (copy);
}
}
#line 335 "utils.c"
char *xstrdup_lower(char const   *s ) 
{ 
  char *copy ;
  char *tmp ;
  char *p ;

  {
  {
#line 338
  tmp = xstrdup_real(s);
#line 338
  copy = tmp;
#line 339
  p = copy;
  }
  {
#line 340
  while (1) {
    while_continue: /* CIL Label */ ;
#line 340
    if (! *p) {
#line 340
      goto while_break;
    }
#line 341
    *p = (char )_sch_tolower[(int )*p & 255];
#line 340
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 342
  return (copy);
}
}
#line 347 "utils.c"
int count_char(char const   *string , char chr ) 
{ 
  char const   *p ;
  int count ;

  {
#line 351
  count = 0;
#line 352
  p = string;
  {
#line 352
  while (1) {
    while_continue: /* CIL Label */ ;
#line 352
    if (! *p) {
#line 352
      goto while_break;
    }
#line 353
    if ((int const   )*p == (int const   )chr) {
#line 354
      count ++;
    }
#line 352
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 355
  return (count);
}
}
#line 361 "utils.c"
char *strdupdelim(char const   *beg , char const   *end ) 
{ 
  char *res___0 ;
  void *tmp ;

  {
  {
#line 364
  tmp = xmalloc_real((size_t )((end - beg) + 1L));
#line 364
  res___0 = (char *)tmp;
#line 365
  memcpy((void */* __restrict  */)res___0, (void const   */* __restrict  */)beg, (size_t )(end - beg));
#line 366
  *(res___0 + (end - beg)) = (char )'\000';
  }
#line 367
  return (res___0);
}
}
#line 373 "utils.c"
char **sepstring(char const   *s ) 
{ 
  char **res___0 ;
  char const   *p ;
  int i ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 378
  i = 0;
#line 380
  if (! s) {
#line 381
    return ((char **)((void *)0));
  } else
#line 380
  if (! *s) {
#line 381
    return ((char **)((void *)0));
  }
#line 382
  res___0 = (char **)((void *)0);
#line 383
  p = s;
  {
#line 384
  while (1) {
    while_continue: /* CIL Label */ ;
#line 384
    if (! *s) {
#line 384
      goto while_break;
    }
#line 386
    if ((int const   )*s == 44) {
      {
#line 388
      tmp = xrealloc_real((void *)res___0, (size_t )((unsigned long )(i + 2) * sizeof(char *)));
#line 388
      res___0 = (char **)tmp;
#line 389
      *(res___0 + i) = strdupdelim(p, s);
#line 390
      i ++;
#line 390
      *(res___0 + i) = (char *)((void *)0);
#line 391
      s ++;
      }
      {
#line 393
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 393
        if (! ((int const   )_sch_istable[(int const   )*s & 255] & 64)) {
#line 393
          goto while_break___0;
        }
#line 394
        s ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 395
      p = s;
    } else {
#line 398
      s ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 400
  tmp___0 = xrealloc_real((void *)res___0, (size_t )((unsigned long )(i + 2) * sizeof(char *)));
#line 400
  res___0 = (char **)tmp___0;
#line 401
  *(res___0 + i) = strdupdelim(p, s);
#line 402
  *(res___0 + (i + 1)) = (char *)((void *)0);
  }
#line 403
  return (res___0);
}
}
#line 420 "utils.c"
static char output[15]  ;
#line 417 "utils.c"
char *time_str(time_t *tm ) 
{ 
  struct tm *ptm ;
  time_t secs ;
  time_t tmp ;

  {
  {
#line 422
  tmp = time(tm);
#line 422
  secs = tmp;
  }
#line 424
  if (secs == -1L) {
#line 428
    output[0] = (char )'\000';
#line 429
    return (output);
  }
  {
#line 431
  ptm = localtime((time_t const   *)(& secs));
#line 432
  sprintf((char */* __restrict  */)(output), (char const   */* __restrict  */)"%02d:%02d:%02d",
          ptm->tm_hour, ptm->tm_min, ptm->tm_sec);
  }
#line 433
  return (output);
}
}
#line 441 "utils.c"
static char output___0[20]  ;
#line 438 "utils.c"
char *datetime_str(time_t *tm ) 
{ 
  struct tm *ptm ;
  time_t secs ;
  time_t tmp ;

  {
  {
#line 443
  tmp = time(tm);
#line 443
  secs = tmp;
  }
#line 445
  if (secs == -1L) {
#line 449
    output___0[0] = (char )'\000';
#line 450
    return (output___0);
  }
  {
#line 452
  ptm = localtime((time_t const   *)(& secs));
#line 453
  sprintf((char */* __restrict  */)(output___0), (char const   */* __restrict  */)"%04d-%02d-%02d %02d:%02d:%02d",
          ptm->tm_year + 1900, ptm->tm_mon + 1, ptm->tm_mday, ptm->tm_hour, ptm->tm_min,
          ptm->tm_sec);
  }
#line 456
  return (output___0);
}
}
#line 463 "utils.c"
void fork_to_background(void) 
{ 
  pid_t pid ;
  int changedp ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 468
  changedp = 0;
#line 470
  if (! opt.lfilename) {
    {
#line 472
    opt.lfilename = unique_name("wget-log", 0);
#line 473
    changedp = 1;
    }
  }
  {
#line 475
  pid = fork();
  }
#line 476
  if (pid < 0) {
    {
#line 479
    perror("fork");
#line 480
    exit(1);
    }
  } else
#line 482
  if (pid != 0) {
    {
#line 485
    tmp = gettext("Continuing in background, pid %d.\n");
#line 485
    printf((char const   */* __restrict  */)tmp, pid);
    }
#line 486
    if (changedp) {
      {
#line 487
      tmp___0 = gettext("Output will be written to `%s\'.\n");
#line 487
      printf((char const   */* __restrict  */)tmp___0, opt.lfilename);
      }
    }
    {
#line 488
    exit(0);
    }
  }
  {
#line 492
  setsid();
#line 493
  freopen((char const   */* __restrict  */)"/dev/null", (char const   */* __restrict  */)"r",
          (FILE */* __restrict  */)stdin);
#line 494
  freopen((char const   */* __restrict  */)"/dev/null", (char const   */* __restrict  */)"w",
          (FILE */* __restrict  */)stdout);
#line 495
  freopen((char const   */* __restrict  */)"/dev/null", (char const   */* __restrict  */)"w",
          (FILE */* __restrict  */)stderr);
  }
#line 496
  return;
}
}
#line 501 "utils.c"
void touch(char const   *file , time_t tm ) 
{ 
  struct utimbuf times ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 506
  times.modtime = tm;
#line 506
  times.actime = times.modtime;
#line 512
  tmp___1 = utime(file, (struct utimbuf  const  *)(& times));
  }
#line 512
  if (tmp___1 == -1) {
    {
#line 513
    tmp = __errno_location();
#line 513
    tmp___0 = strerror(*tmp);
#line 513
    logprintf((enum log_options )1, "utime(%s): %s\n", file, tmp___0);
    }
  }
#line 514
  return;
}
}
#line 518 "utils.c"
int remove_link(char const   *file ) 
{ 
  int err ;
  struct stat st ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 521
  err = 0;
#line 524
  tmp___2 = lstat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& st));
  }
#line 524
  if (tmp___2 == 0) {
#line 524
    if ((st.st_mode & 61440U) == 40960U) {
      {
#line 526
      while (1) {
        while_continue: /* CIL Label */ ;
#line 526
        if (opt.debug) {
          {
#line 526
          debug_logprintf("Unlinking %s (symlink).\n", file);
          }
        }
#line 526
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 527
      err = unlink(file);
      }
#line 528
      if (err != 0) {
        {
#line 529
        tmp = __errno_location();
#line 529
        tmp___0 = strerror(*tmp);
#line 529
        tmp___1 = gettext("Failed to unlink symlink `%s\': %s\n");
#line 529
        logprintf((enum log_options )0, (char const   *)tmp___1, file, tmp___0);
        }
      }
    }
  }
#line 532
  return (err);
}
}
#line 542 "utils.c"
int file_exists_p(char const   *filename ) 
{ 
  int tmp ;

  {
  {
#line 546
  tmp = access(filename, 0);
  }
#line 546
  return (tmp >= 0);
}
}
#line 555 "utils.c"
int file_non_directory_p(char const   *path ) 
{ 
  struct stat buf___0 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 561
  tmp = lstat((char const   */* __restrict  */)path, (struct stat */* __restrict  */)(& buf___0));
  }
#line 561
  if (tmp != 0) {
#line 562
    return (0);
  }
#line 563
  if ((buf___0.st_mode & 61440U) == 16384U) {
#line 563
    tmp___0 = 0;
  } else {
#line 563
    tmp___0 = 1;
  }
#line 563
  return (tmp___0);
}
}
#line 568 "utils.c"
long file_size(char const   *filename ) 
{ 
  long size ;
  FILE *fp ;
  FILE *tmp ;

  {
  {
#line 575
  tmp = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"rb");
#line 575
  fp = tmp;
  }
#line 576
  if (! fp) {
#line 577
    return (-1L);
  }
  {
#line 578
  fseek(fp, 0L, 2);
#line 579
  size = ftell(fp);
#line 580
  fclose(fp);
  }
#line 581
  return (size);
}
}
#line 588 "utils.c"
static char *unique_name_1(char const   *prefix ) 
{ 
  int count ;
  int plen ;
  size_t tmp ;
  char *template ;
  void *tmp___0 ;
  char *template_tail ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 591
  count = 1;
#line 592
  tmp = strlen(prefix);
#line 592
  plen = (int )tmp;
#line 593
  tmp___0 = __builtin_alloca((unsigned long )((plen + 1) + 24));
#line 593
  template = (char *)tmp___0;
#line 594
  template_tail = template + plen;
#line 596
  memcpy((void */* __restrict  */)template, (void const   */* __restrict  */)prefix,
         (size_t )plen);
#line 597
  tmp___1 = template_tail;
#line 597
  template_tail ++;
#line 597
  *tmp___1 = (char )'.';
  }
  {
#line 599
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 600
    tmp___2 = count;
#line 600
    count ++;
#line 600
    number_to_string(template_tail, (long )tmp___2);
#line 599
    tmp___3 = file_exists_p((char const   *)template);
    }
#line 599
    if (! tmp___3) {
#line 599
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 603
  tmp___4 = xstrdup_real((char const   *)template);
  }
#line 603
  return (tmp___4);
}
}
#line 622 "utils.c"
char *unique_name(char const   *file , int allow_passthrough ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 627
  tmp___1 = file_exists_p(file);
  }
#line 627
  if (! tmp___1) {
#line 628
    if (allow_passthrough) {
#line 628
      tmp___0 = (char *)file;
    } else {
      {
#line 628
      tmp = xstrdup_real(file);
#line 628
      tmp___0 = tmp;
      }
    }
#line 628
    return (tmp___0);
  }
  {
#line 632
  tmp___2 = unique_name_1(file);
  }
#line 632
  return (tmp___2);
}
}
#line 641 "utils.c"
int make_directory(char const   *directory ) 
{ 
  int quit ;
  int i ;
  int ret ;
  char *dir ;
  size_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 644
  quit = 0;
#line 646
  ret = 0;
  {
#line 651
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 651
    tmp = strlen(directory);
#line 651
    tmp___0 = __builtin_alloca((unsigned long )(tmp + 1U));
#line 651
    dir = (char *)tmp___0;
#line 651
    strcpy((char */* __restrict  */)dir, (char const   */* __restrict  */)directory);
    }
#line 651
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 655
  i = (int )*dir == 47;
  {
#line 655
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 657
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 657
      if (*(dir + i)) {
#line 657
        if (! ((int )*(dir + i) != 47)) {
#line 657
          goto while_break___1;
        }
      } else {
#line 657
        goto while_break___1;
      }
#line 657
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 659
    if (! *(dir + i)) {
#line 660
      quit = 1;
    }
    {
#line 661
    *(dir + i) = (char )'\000';
#line 665
    tmp___1 = file_exists_p((char const   *)dir);
    }
#line 665
    if (tmp___1) {
#line 668
      ret = 0;
    } else {
      {
#line 666
      ret = mkdir((char const   *)dir, (__mode_t )511);
      }
    }
#line 669
    if (quit) {
#line 670
      goto while_break___0;
    } else {
#line 672
      *(dir + i) = (char )'/';
    }
#line 655
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 674
  return (ret);
}
}
#line 686 "utils.c"
char *file_merge(char const   *base , char const   *file ) 
{ 
  char *result ;
  char const   *cut ;
  char *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 690
  tmp = strrchr(base, '/');
#line 690
  cut = (char const   *)tmp;
  }
#line 692
  if (! cut) {
    {
#line 693
    tmp___0 = xstrdup_real(file);
    }
#line 693
    return (tmp___0);
  }
  {
#line 695
  tmp___1 = strlen(file);
#line 695
  tmp___2 = xmalloc_real((size_t )((((cut - base) + 1L) + (long )tmp___1) + 1L));
#line 695
  result = (char *)tmp___2;
#line 696
  memcpy((void */* __restrict  */)result, (void const   */* __restrict  */)base, (size_t )(cut - base));
#line 697
  *(result + (cut - base)) = (char )'/';
#line 698
  strcpy((char */* __restrict  */)((result + (cut - base)) + 1), (char const   */* __restrict  */)file);
  }
#line 700
  return (result);
}
}
#line 703
static int in_acclist(char const   * const  *accepts , char const   *s , int backward ) ;
#line 707 "utils.c"
int acceptable(char const   *s ) 
{ 
  int l ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 710
  tmp = strlen(s);
#line 710
  l = (int )tmp;
  }
  {
#line 712
  while (1) {
    while_continue: /* CIL Label */ ;
#line 712
    if (l) {
#line 712
      if (! ((int const   )*(s + l) != 47)) {
#line 712
        goto while_break;
      }
    } else {
#line 712
      goto while_break;
    }
#line 713
    l --;
  }
  while_break: /* CIL Label */ ;
  }
#line 714
  if ((int const   )*(s + l) == 47) {
#line 715
    s += l + 1;
  }
#line 716
  if (opt.accepts) {
#line 718
    if (opt.rejects) {
      {
#line 719
      tmp___0 = in_acclist((char const   * const  *)opt.accepts, s, 1);
      }
#line 719
      if (tmp___0) {
        {
#line 719
        tmp___1 = in_acclist((char const   * const  *)opt.rejects, s, 1);
        }
#line 719
        if (tmp___1) {
#line 719
          tmp___2 = 0;
        } else {
#line 719
          tmp___2 = 1;
        }
      } else {
#line 719
        tmp___2 = 0;
      }
#line 719
      return (tmp___2);
    } else {
      {
#line 722
      tmp___3 = in_acclist((char const   * const  *)opt.accepts, s, 1);
      }
#line 722
      return (tmp___3);
    }
  } else
#line 724
  if (opt.rejects) {
    {
#line 725
    tmp___4 = in_acclist((char const   * const  *)opt.rejects, s, 1);
    }
#line 725
    if (tmp___4) {
#line 725
      tmp___5 = 0;
    } else {
#line 725
      tmp___5 = 1;
    }
#line 725
    return (tmp___5);
  }
#line 726
  return (1);
}
}
#line 732 "utils.c"
int frontcmp(char const   *s1 , char const   *s2 ) 
{ 


  {
  {
#line 735
  while (1) {
    while_continue: /* CIL Label */ ;
#line 735
    if (*s1) {
#line 735
      if (*s2) {
#line 735
        if (! ((int const   )*s1 == (int const   )*s2)) {
#line 735
          goto while_break;
        }
      } else {
#line 735
        goto while_break;
      }
    } else {
#line 735
      goto while_break;
    }
#line 735
    s1 ++;
#line 735
    s2 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 736
  return (! *s1);
}
}
#line 741 "utils.c"
static char *proclist(char **strlist , char const   *s , enum accd flags ) 
{ 
  char **x ;
  int tmp ;
  char *p ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 746
  x = strlist;
  {
#line 746
  while (1) {
    while_continue: /* CIL Label */ ;
#line 746
    if (! *x) {
#line 746
      goto while_break;
    }
    {
#line 747
    tmp___2 = has_wildcards_p((char const   *)*x);
    }
#line 747
    if (tmp___2) {
      {
#line 749
      tmp = fnmatch((char const   *)*x, s, 1);
      }
#line 749
      if (tmp == 0) {
#line 750
        goto while_break;
      }
    } else {
#line 754
      if ((unsigned int )flags & 1U) {
#line 754
        if ((int )*(*x) == 47) {
#line 754
          tmp___0 = 1;
        } else {
#line 754
          tmp___0 = 0;
        }
      } else {
#line 754
        tmp___0 = 0;
      }
      {
#line 754
      p = *x + tmp___0;
#line 755
      tmp___1 = frontcmp((char const   *)p, s);
      }
#line 755
      if (tmp___1) {
#line 756
        goto while_break;
      }
    }
#line 746
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 758
  return (*x);
}
}
#line 766 "utils.c"
int accdir(char const   *directory , enum accd flags ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 770
  if ((unsigned int )flags & 1U) {
#line 770
    if ((int const   )*directory == 47) {
#line 771
      directory ++;
    }
  }
#line 772
  if (opt.includes) {
    {
#line 774
    tmp = proclist(opt.includes, directory, flags);
    }
#line 774
    if (! tmp) {
#line 775
      return (0);
    }
  }
#line 777
  if (opt.excludes) {
    {
#line 779
    tmp___0 = proclist(opt.excludes, directory, flags);
    }
#line 779
    if (tmp___0) {
#line 780
      return (0);
    }
  }
#line 782
  return (1);
}
}
#line 794 "utils.c"
int match_tail(char const   *string , char const   *tail , int fold_case_p ) 
{ 
  int i ;
  int j ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 802
  if (! fold_case_p) {
    {
#line 804
    tmp = strlen(string);
#line 804
    i = (int )tmp;
#line 804
    tmp___0 = strlen(tail);
#line 804
    j = (int )tmp___0;
    }
    {
#line 804
    while (1) {
      while_continue: /* CIL Label */ ;
#line 804
      if (i >= 0) {
#line 804
        if (! (j >= 0)) {
#line 804
          goto while_break;
        }
      } else {
#line 804
        goto while_break;
      }
#line 805
      if ((int const   )*(string + i) != (int const   )*(tail + j)) {
#line 806
        goto while_break;
      }
#line 804
      i --;
#line 804
      j --;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 810
    tmp___1 = strlen(string);
#line 810
    i = (int )tmp___1;
#line 810
    tmp___2 = strlen(tail);
#line 810
    j = (int )tmp___2;
    }
    {
#line 810
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 810
      if (i >= 0) {
#line 810
        if (! (j >= 0)) {
#line 810
          goto while_break___0;
        }
      } else {
#line 810
        goto while_break___0;
      }
#line 811
      if ((int const   )_sch_tolower[(int const   )*(string + i) & 255] != (int const   )_sch_tolower[(int const   )*(tail + j) & 255]) {
#line 812
        goto while_break___0;
      }
#line 810
      i --;
#line 810
      j --;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 816
  if (j == -1) {
#line 817
    return (1);
  } else {
#line 819
    return (0);
  }
}
}
#line 828 "utils.c"
static int in_acclist(char const   * const  *accepts , char const   *s , int backward ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 831
  while (1) {
    while_continue: /* CIL Label */ ;
#line 831
    if (! *accepts) {
#line 831
      goto while_break;
    }
    {
#line 833
    tmp___2 = has_wildcards_p((char const   *)*accepts);
    }
#line 833
    if (tmp___2) {
      {
#line 837
      tmp = fnmatch((char const   *)*accepts, s, 0);
      }
#line 837
      if (tmp == 0) {
#line 838
        return (1);
      }
    } else
#line 842
    if (backward) {
      {
#line 844
      tmp___0 = match_tail(s, (char const   *)*accepts, 0);
      }
#line 844
      if (tmp___0) {
#line 845
        return (1);
      }
    } else {
      {
#line 849
      tmp___1 = strcmp(s, (char const   *)*accepts);
      }
#line 849
      if (! tmp___1) {
#line 850
        return (1);
      }
    }
#line 831
    accepts ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 854
  return (0);
}
}
#line 862 "utils.c"
char *suffix(char const   *str ) 
{ 
  int i ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 867
  tmp = strlen(str);
#line 867
  i = (int )tmp;
  }
  {
#line 867
  while (1) {
    while_continue: /* CIL Label */ ;
#line 867
    if (i) {
#line 867
      if ((int const   )*(str + i) != 47) {
#line 867
        if (! ((int const   )*(str + i) != 46)) {
#line 867
          goto while_break;
        }
      } else {
#line 867
        goto while_break;
      }
    } else {
#line 867
      goto while_break;
    }
#line 867
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 870
  tmp___0 = i;
#line 870
  i ++;
#line 870
  if ((int const   )*(str + tmp___0) == 46) {
#line 871
    return ((char *)str + i);
  } else {
#line 873
    return ((char *)((void *)0));
  }
}
}
#line 879 "utils.c"
int has_wildcards_p(char const   *s ) 
{ 


  {
  {
#line 882
  while (1) {
    while_continue: /* CIL Label */ ;
#line 882
    if (! *s) {
#line 882
      goto while_break;
    }
#line 883
    if ((int const   )*s == 42) {
#line 884
      return (1);
    } else
#line 883
    if ((int const   )*s == 63) {
#line 884
      return (1);
    } else
#line 883
    if ((int const   )*s == 91) {
#line 884
      return (1);
    } else
#line 883
    if ((int const   )*s == 93) {
#line 884
      return (1);
    }
#line 882
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 885
  return (0);
}
}
#line 897 "utils.c"
int has_html_suffix_p(char const   *fname ) 
{ 
  char *suf ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 902
  suf = suffix(fname);
  }
#line 902
  if ((unsigned long )suf == (unsigned long )((void *)0)) {
#line 903
    return (0);
  }
  {
#line 904
  tmp = strcasecmp((char const   *)suf, "html");
  }
#line 904
  if (! tmp) {
#line 905
    return (1);
  }
  {
#line 906
  tmp___0 = strcasecmp((char const   *)suf, "htm");
  }
#line 906
  if (! tmp___0) {
#line 907
    return (1);
  }
#line 908
  if (*(suf + 0)) {
    {
#line 908
    tmp___1 = strcasecmp((char const   *)(suf + 1), "html");
    }
#line 908
    if (! tmp___1) {
#line 909
      return (1);
    }
  }
#line 910
  return (0);
}
}
#line 925 "utils.c"
char *read_whole_line(FILE *fp ) 
{ 
  int length ;
  int bufsize ;
  char *line ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;

  {
  {
#line 928
  length = 0;
#line 929
  bufsize = 82;
#line 930
  tmp = xmalloc_real((size_t )bufsize);
#line 930
  line = (char *)tmp;
  }
  {
#line 932
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 932
    tmp___2 = fgets((char */* __restrict  */)(line + length), bufsize - length, (FILE */* __restrict  */)fp);
    }
#line 932
    if (! tmp___2) {
#line 932
      goto while_break;
    }
    {
#line 934
    tmp___0 = strlen((char const   *)(line + length));
#line 934
    length = (int )((size_t )length + tmp___0);
    }
#line 935
    if (length == 0) {
#line 938
      goto while_continue;
    }
#line 940
    if ((int )*(line + (length - 1)) == 10) {
#line 941
      goto while_break;
    }
    {
#line 946
    bufsize <<= 1;
#line 947
    tmp___1 = xrealloc_real((void *)line, (size_t )bufsize);
#line 947
    line = (char *)tmp___1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 949
  if (length == 0) {
    {
#line 951
    free((void *)line);
    }
#line 952
    return ((char *)((void *)0));
  } else {
    {
#line 949
    tmp___3 = ferror(fp);
    }
#line 949
    if (tmp___3) {
      {
#line 951
      free((void *)line);
      }
#line 952
      return ((char *)((void *)0));
    }
  }
#line 954
  if (length + 1 < bufsize) {
    {
#line 959
    tmp___4 = xrealloc_real((void *)line, (size_t )(length + 1));
#line 959
    line = (char *)tmp___4;
    }
  }
#line 960
  return (line);
}
}
#line 979 "utils.c"
struct file_memory *read_file(char const   *file ) 
{ 
  int fd ;
  struct file_memory *fm ;
  long size ;
  int inhibit_close ;
  void *tmp ;
  struct stat buf___0 ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  long nread ;
  void *tmp___3 ;
  ssize_t tmp___4 ;
  void *tmp___5 ;

  {
#line 985
  inhibit_close = 0;
#line 989
  if ((int const   )*file == 45) {
#line 989
    if (! *(file + 1)) {
      {
#line 991
      fd = fileno(stdin);
#line 992
      inhibit_close = 1;
      }
    } else {
      {
#line 997
      fd = open(file, 0);
      }
    }
  } else {
    {
#line 997
    fd = open(file, 0);
    }
  }
#line 998
  if (fd < 0) {
#line 999
    return ((struct file_memory *)((void *)0));
  }
  {
#line 1000
  tmp = xmalloc_real((size_t )sizeof(struct file_memory ));
#line 1000
  fm = (struct file_memory *)tmp;
#line 1005
  tmp___0 = fstat(fd, & buf___0);
  }
#line 1005
  if (tmp___0 < 0) {
#line 1006
    goto mmap_lose;
  }
  {
#line 1007
  fm->length = buf___0.st_size;
#line 1012
  tmp___1 = mmap((void *)0, (size_t )fm->length, 3, 2, fd, (__off_t )0);
#line 1012
  fm->content = (char *)tmp___1;
  }
#line 1014
  if ((unsigned long )fm->content == (unsigned long )((char *)((void *)-1))) {
#line 1015
    goto mmap_lose;
  }
#line 1016
  if (! inhibit_close) {
    {
#line 1017
    close(fd);
    }
  }
#line 1019
  fm->mmap_p = 1;
#line 1020
  return (fm);
  mmap_lose: 
  {
#line 1030
  fm->length = 0L;
#line 1031
  size = 512L;
#line 1033
  tmp___2 = xmalloc_real((size_t )size);
#line 1033
  fm->content = (char *)tmp___2;
  }
  {
#line 1034
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1037
    if (fm->length > size / 2L) {
      {
#line 1053
      size <<= 1;
#line 1054
      tmp___3 = xrealloc_real((void *)fm->content, (size_t )size);
#line 1054
      fm->content = (char *)tmp___3;
      }
    }
    {
#line 1056
    tmp___4 = read(fd, (void *)(fm->content + fm->length), (size_t )(size - fm->length));
#line 1056
    nread = (long )tmp___4;
    }
#line 1057
    if (nread > 0L) {
#line 1059
      fm->length += nread;
    } else
#line 1060
    if (nread < 0L) {
#line 1062
      goto lose;
    } else {
#line 1065
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1067
  if (! inhibit_close) {
    {
#line 1068
    close(fd);
    }
  }
#line 1069
  if (size > fm->length) {
#line 1069
    if (fm->length != 0L) {
      {
#line 1072
      tmp___5 = xrealloc_real((void *)fm->content, (size_t )fm->length);
#line 1072
      fm->content = (char *)tmp___5;
      }
    }
  }
#line 1073
  fm->mmap_p = 0;
#line 1074
  return (fm);
  lose: 
#line 1077
  if (! inhibit_close) {
    {
#line 1078
    close(fd);
    }
  }
  {
#line 1079
  free((void *)fm->content);
#line 1080
  free((void *)fm);
  }
#line 1081
  return ((struct file_memory *)((void *)0));
}
}
#line 1089 "utils.c"
void read_file_free(struct file_memory *fm ) 
{ 


  {
#line 1093
  if (fm->mmap_p) {
    {
#line 1095
    munmap((void *)fm->content, (size_t )fm->length);
    }
  } else {
    {
#line 1100
    free((void *)fm->content);
    }
  }
  {
#line 1102
  free((void *)fm);
  }
#line 1103
  return;
}
}
#line 1107 "utils.c"
void free_vec(char **vec ) 
{ 
  char **p ;
  char **tmp ;

  {
#line 1110
  if (vec) {
#line 1112
    p = vec;
    {
#line 1113
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1113
      if (! *p) {
#line 1113
        goto while_break;
      }
      {
#line 1114
      tmp = p;
#line 1114
      p ++;
#line 1114
      free((void *)*tmp);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1115
    free((void *)vec);
    }
  }
#line 1117
  return;
}
}
#line 1122 "utils.c"
char **merge_vecs(char **v1___0 , char **v2___0 ) 
{ 
  int i ;
  int j ;
  void *tmp ;

  {
#line 1127
  if (! v1___0) {
#line 1128
    return (v2___0);
  }
#line 1129
  if (! v2___0) {
#line 1130
    return (v1___0);
  }
#line 1131
  if (! *v2___0) {
    {
#line 1134
    free((void *)v2___0);
    }
#line 1135
    return (v1___0);
  }
#line 1138
  i = 0;
  {
#line 1138
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1138
    if (! *(v1___0 + i)) {
#line 1138
      goto while_break;
    }
#line 1138
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1140
  j = 0;
  {
#line 1140
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1140
    if (! *(v2___0 + j)) {
#line 1140
      goto while_break___0;
    }
#line 1140
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1142
  tmp = xrealloc_real((void *)v1___0, (size_t )((unsigned long )((i + j) + 1) * sizeof(char **)));
#line 1142
  v1___0 = (char **)tmp;
#line 1143
  memcpy((void */* __restrict  */)(v1___0 + i), (void const   */* __restrict  */)v2___0,
         (size_t )((unsigned long )(j + 1) * sizeof(char *)));
#line 1144
  free((void *)v2___0);
  }
#line 1145
  return (v1___0);
}
}
#line 1165 "utils.c"
slist *slist_append(slist *l , char const   *s ) 
{ 
  slist *newel ;
  void *tmp ;
  slist *beg ;

  {
  {
#line 1168
  tmp = xmalloc_real((size_t )sizeof(slist ));
#line 1168
  newel = (slist *)tmp;
#line 1169
  beg = l;
#line 1171
  newel->string = xstrdup_real(s);
#line 1172
  newel->next = (struct _slist *)((void *)0);
  }
#line 1174
  if (! l) {
#line 1175
    return (newel);
  }
  {
#line 1177
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1177
    if (! l->next) {
#line 1177
      goto while_break;
    }
#line 1178
    l = l->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1179
  l->next = newel;
#line 1180
  return (beg);
}
}
#line 1185 "utils.c"
slist *slist_prepend(slist *l , char const   *s ) 
{ 
  slist *newel ;
  void *tmp ;

  {
  {
#line 1188
  tmp = xmalloc_real((size_t )sizeof(slist ));
#line 1188
  newel = (slist *)tmp;
#line 1189
  newel->string = xstrdup_real(s);
#line 1190
  newel->next = l;
  }
#line 1191
  return (newel);
}
}
#line 1196 "utils.c"
slist *slist_nreverse(slist *l ) 
{ 
  slist *prev ;
  slist *next ;

  {
#line 1199
  prev = (slist *)((void *)0);
  {
#line 1200
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1200
    if (! l) {
#line 1200
      goto while_break;
    }
#line 1202
    next = l->next;
#line 1203
    l->next = prev;
#line 1204
    prev = l;
#line 1205
    l = next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1207
  return (prev);
}
}
#line 1211 "utils.c"
int slist_contains(slist *l , char const   *s ) 
{ 
  int tmp ;

  {
  {
#line 1214
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1214
    if (! l) {
#line 1214
      goto while_break;
    }
    {
#line 1215
    tmp = strcmp((char const   *)l->string, s);
    }
#line 1215
    if (! tmp) {
#line 1216
      return (1);
    }
#line 1214
    l = l->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1217
  return (0);
}
}
#line 1221 "utils.c"
void slist_free(slist *l ) 
{ 
  slist *n ;

  {
  {
#line 1224
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1224
    if (! l) {
#line 1224
      goto while_break;
    }
    {
#line 1226
    n = l->next;
#line 1227
    free((void *)l->string);
#line 1228
    free((void *)l);
#line 1229
    l = n;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1231
  return;
}
}
#line 1238 "utils.c"
void string_set_add(struct hash_table *ht , char const   *s ) 
{ 
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 1244
  tmp = hash_table_contains((struct hash_table  const  *)ht, (void const   *)s);
  }
#line 1244
  if (tmp) {
#line 1245
    return;
  }
  {
#line 1251
  tmp___0 = xstrdup_real(s);
#line 1251
  hash_table_put(ht, (void const   *)tmp___0, (void *)"1");
  }
#line 1252
  return;
}
}
#line 1256 "utils.c"
int string_set_contains(struct hash_table *ht , char const   *s ) 
{ 
  int tmp ;

  {
  {
#line 1259
  tmp = hash_table_contains((struct hash_table  const  *)ht, (void const   *)s);
  }
#line 1259
  return (tmp);
}
}
#line 1262 "utils.c"
static int string_set_free_mapper(void *key , void *value_ignored , void *arg_ignored ) 
{ 


  {
  {
#line 1265
  free(key);
  }
#line 1266
  return (0);
}
}
#line 1269 "utils.c"
void string_set_free(struct hash_table *ht ) 
{ 


  {
  {
#line 1272
  hash_table_map(ht, & string_set_free_mapper, (void *)0);
#line 1273
  hash_table_destroy(ht);
  }
#line 1274
  return;
}
}
#line 1276 "utils.c"
static int free_keys_and_values_mapper(void *key , void *value , void *arg_ignored ) 
{ 


  {
  {
#line 1279
  free(key);
#line 1280
  free(value);
  }
#line 1281
  return (0);
}
}
#line 1286 "utils.c"
void free_keys_and_values(struct hash_table *ht ) 
{ 


  {
  {
#line 1289
  hash_table_map(ht, & free_keys_and_values_mapper, (void *)0);
  }
#line 1290
  return;
}
}
#line 1299 "utils.c"
static char outbuf[48]  ;
#line 1296 "utils.c"
static char *legible_1(char const   *repr ) 
{ 
  int i ;
  int i1 ;
  int mod ;
  char *outptr ;
  char const   *inptr ;
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 1305
  outptr = outbuf;
#line 1306
  inptr = repr;
#line 1310
  if ((int const   )*inptr == 45) {
#line 1312
    tmp = outptr;
#line 1312
    outptr ++;
#line 1312
    *tmp = (char )'-';
#line 1313
    inptr ++;
  }
  {
#line 1316
  tmp___0 = strlen(inptr);
#line 1316
  mod = (int )(tmp___0 % 3U);
#line 1318
  i = 0;
  }
  {
#line 1318
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1318
    if (! (i < mod)) {
#line 1318
      goto while_break;
    }
#line 1319
    tmp___1 = outptr;
#line 1319
    outptr ++;
#line 1319
    *tmp___1 = (char )*(inptr + i);
#line 1318
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1322
  i1 = i;
#line 1322
  i = 0;
  {
#line 1322
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1322
    if (! *(inptr + i1)) {
#line 1322
      goto while_break___0;
    }
#line 1324
    if (i % 3 == 0) {
#line 1324
      if (i1 != 0) {
#line 1325
        tmp___2 = outptr;
#line 1325
        outptr ++;
#line 1325
        *tmp___2 = (char )',';
      }
    }
#line 1326
    tmp___3 = outptr;
#line 1326
    outptr ++;
#line 1326
    *tmp___3 = (char )*(inptr + i1);
#line 1322
    i ++;
#line 1322
    i1 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1329
  *outptr = (char )'\000';
#line 1330
  return (outbuf);
}
}
#line 1335 "utils.c"
char *legible(long l ) 
{ 
  char inbuf[24] ;
  char *tmp ;

  {
  {
#line 1340
  number_to_string(inbuf, l);
#line 1341
  tmp = legible_1((char const   *)(inbuf));
  }
#line 1341
  return (tmp);
}
}
#line 1354 "utils.c"
static void large_int_to_string(char *buffer , LARGE_INT number ) 
{ 


  {
  {
#line 1357
  snprintf((char */* __restrict  */)buffer, (size_t )24, (char const   */* __restrict  */)"%lld",
           number);
  }
#line 1358
  return;
}
}
#line 1362 "utils.c"
char *legible_large_int(LARGE_INT l ) 
{ 
  char inbuf[48] ;
  char *tmp ;

  {
  {
#line 1366
  large_int_to_string(inbuf, l);
#line 1367
  tmp = legible_1((char const   *)(inbuf));
  }
#line 1367
  return (tmp);
}
}
#line 1371 "utils.c"
int numdigit(long number ) 
{ 
  int cnt ;

  {
#line 1374
  cnt = 1;
#line 1375
  if (number < 0L) {
#line 1377
    number = - number;
#line 1378
    cnt ++;
  }
  {
#line 1380
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1380
    number /= 10L;
#line 1380
    if (! (number > 0L)) {
#line 1380
      goto while_break;
    }
#line 1381
    cnt ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1382
  return (cnt);
}
}
#line 1435 "utils.c"
char *number_to_string(char *buffer , long number ) 
{ 
  char *p ;
  long n ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  char *tmp___36 ;
  char *tmp___37 ;
  char *tmp___38 ;
  char *tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;
  char *tmp___42 ;
  char *tmp___43 ;
  char *tmp___44 ;
  char *tmp___45 ;
  char *tmp___46 ;
  char *tmp___47 ;
  char *tmp___48 ;
  char *tmp___49 ;
  char *tmp___50 ;
  char *tmp___51 ;
  char *tmp___52 ;
  char *tmp___53 ;
  char *tmp___54 ;
  char *tmp___55 ;

  {
#line 1438
  p = buffer;
#line 1439
  n = number;
#line 1448
  if (n < 0L) {
#line 1450
    if (n < -2147483647L) {
      {
#line 1454
      sprintf((char */* __restrict  */)buffer, (char const   */* __restrict  */)"%ld",
              n);
#line 1455
      tmp = strlen((char const   *)buffer);
#line 1455
      p += tmp;
      }
#line 1456
      return (p);
    }
#line 1459
    tmp___0 = p;
#line 1459
    p ++;
#line 1459
    *tmp___0 = (char )'-';
#line 1460
    n = - n;
  }
#line 1463
  if (n < 10L) {
#line 1463
    tmp___1 = p;
#line 1463
    p ++;
#line 1463
    *tmp___1 = (char )(n + 48L);
  } else
#line 1464
  if (n < 100L) {
#line 1464
    tmp___2 = p;
#line 1464
    p ++;
#line 1464
    *tmp___2 = (char )(n / 10L + 48L);
#line 1464
    n %= 10L;
#line 1464
    tmp___3 = p;
#line 1464
    p ++;
#line 1464
    *tmp___3 = (char )(n + 48L);
  } else
#line 1465
  if (n < 1000L) {
#line 1465
    tmp___4 = p;
#line 1465
    p ++;
#line 1465
    *tmp___4 = (char )(n / 100L + 48L);
#line 1465
    n %= 100L;
#line 1465
    tmp___5 = p;
#line 1465
    p ++;
#line 1465
    *tmp___5 = (char )(n / 10L + 48L);
#line 1465
    n %= 10L;
#line 1465
    tmp___6 = p;
#line 1465
    p ++;
#line 1465
    *tmp___6 = (char )(n + 48L);
  } else
#line 1466
  if (n < 10000L) {
#line 1466
    tmp___7 = p;
#line 1466
    p ++;
#line 1466
    *tmp___7 = (char )(n / 1000L + 48L);
#line 1466
    n %= 1000L;
#line 1466
    tmp___8 = p;
#line 1466
    p ++;
#line 1466
    *tmp___8 = (char )(n / 100L + 48L);
#line 1466
    n %= 100L;
#line 1466
    tmp___9 = p;
#line 1466
    p ++;
#line 1466
    *tmp___9 = (char )(n / 10L + 48L);
#line 1466
    n %= 10L;
#line 1466
    tmp___10 = p;
#line 1466
    p ++;
#line 1466
    *tmp___10 = (char )(n + 48L);
  } else
#line 1467
  if (n < 100000L) {
#line 1467
    tmp___11 = p;
#line 1467
    p ++;
#line 1467
    *tmp___11 = (char )(n / 10000L + 48L);
#line 1467
    n %= 10000L;
#line 1467
    tmp___12 = p;
#line 1467
    p ++;
#line 1467
    *tmp___12 = (char )(n / 1000L + 48L);
#line 1467
    n %= 1000L;
#line 1467
    tmp___13 = p;
#line 1467
    p ++;
#line 1467
    *tmp___13 = (char )(n / 100L + 48L);
#line 1467
    n %= 100L;
#line 1467
    tmp___14 = p;
#line 1467
    p ++;
#line 1467
    *tmp___14 = (char )(n / 10L + 48L);
#line 1467
    n %= 10L;
#line 1467
    tmp___15 = p;
#line 1467
    p ++;
#line 1467
    *tmp___15 = (char )(n + 48L);
  } else
#line 1468
  if (n < 1000000L) {
#line 1468
    tmp___16 = p;
#line 1468
    p ++;
#line 1468
    *tmp___16 = (char )(n / 100000L + 48L);
#line 1468
    n %= 100000L;
#line 1468
    tmp___17 = p;
#line 1468
    p ++;
#line 1468
    *tmp___17 = (char )(n / 10000L + 48L);
#line 1468
    n %= 10000L;
#line 1468
    tmp___18 = p;
#line 1468
    p ++;
#line 1468
    *tmp___18 = (char )(n / 1000L + 48L);
#line 1468
    n %= 1000L;
#line 1468
    tmp___19 = p;
#line 1468
    p ++;
#line 1468
    *tmp___19 = (char )(n / 100L + 48L);
#line 1468
    n %= 100L;
#line 1468
    tmp___20 = p;
#line 1468
    p ++;
#line 1468
    *tmp___20 = (char )(n / 10L + 48L);
#line 1468
    n %= 10L;
#line 1468
    tmp___21 = p;
#line 1468
    p ++;
#line 1468
    *tmp___21 = (char )(n + 48L);
  } else
#line 1469
  if (n < 10000000L) {
#line 1469
    tmp___22 = p;
#line 1469
    p ++;
#line 1469
    *tmp___22 = (char )(n / 1000000L + 48L);
#line 1469
    n %= 1000000L;
#line 1469
    tmp___23 = p;
#line 1469
    p ++;
#line 1469
    *tmp___23 = (char )(n / 100000L + 48L);
#line 1469
    n %= 100000L;
#line 1469
    tmp___24 = p;
#line 1469
    p ++;
#line 1469
    *tmp___24 = (char )(n / 10000L + 48L);
#line 1469
    n %= 10000L;
#line 1469
    tmp___25 = p;
#line 1469
    p ++;
#line 1469
    *tmp___25 = (char )(n / 1000L + 48L);
#line 1469
    n %= 1000L;
#line 1469
    tmp___26 = p;
#line 1469
    p ++;
#line 1469
    *tmp___26 = (char )(n / 100L + 48L);
#line 1469
    n %= 100L;
#line 1469
    tmp___27 = p;
#line 1469
    p ++;
#line 1469
    *tmp___27 = (char )(n / 10L + 48L);
#line 1469
    n %= 10L;
#line 1469
    tmp___28 = p;
#line 1469
    p ++;
#line 1469
    *tmp___28 = (char )(n + 48L);
  } else
#line 1470
  if (n < 100000000L) {
#line 1470
    tmp___29 = p;
#line 1470
    p ++;
#line 1470
    *tmp___29 = (char )(n / 10000000L + 48L);
#line 1470
    n %= 10000000L;
#line 1470
    tmp___30 = p;
#line 1470
    p ++;
#line 1470
    *tmp___30 = (char )(n / 1000000L + 48L);
#line 1470
    n %= 1000000L;
#line 1470
    tmp___31 = p;
#line 1470
    p ++;
#line 1470
    *tmp___31 = (char )(n / 100000L + 48L);
#line 1470
    n %= 100000L;
#line 1470
    tmp___32 = p;
#line 1470
    p ++;
#line 1470
    *tmp___32 = (char )(n / 10000L + 48L);
#line 1470
    n %= 10000L;
#line 1470
    tmp___33 = p;
#line 1470
    p ++;
#line 1470
    *tmp___33 = (char )(n / 1000L + 48L);
#line 1470
    n %= 1000L;
#line 1470
    tmp___34 = p;
#line 1470
    p ++;
#line 1470
    *tmp___34 = (char )(n / 100L + 48L);
#line 1470
    n %= 100L;
#line 1470
    tmp___35 = p;
#line 1470
    p ++;
#line 1470
    *tmp___35 = (char )(n / 10L + 48L);
#line 1470
    n %= 10L;
#line 1470
    tmp___36 = p;
#line 1470
    p ++;
#line 1470
    *tmp___36 = (char )(n + 48L);
  } else
#line 1471
  if (n < 1000000000L) {
#line 1471
    tmp___37 = p;
#line 1471
    p ++;
#line 1471
    *tmp___37 = (char )(n / 100000000L + 48L);
#line 1471
    n %= 100000000L;
#line 1471
    tmp___38 = p;
#line 1471
    p ++;
#line 1471
    *tmp___38 = (char )(n / 10000000L + 48L);
#line 1471
    n %= 10000000L;
#line 1471
    tmp___39 = p;
#line 1471
    p ++;
#line 1471
    *tmp___39 = (char )(n / 1000000L + 48L);
#line 1471
    n %= 1000000L;
#line 1471
    tmp___40 = p;
#line 1471
    p ++;
#line 1471
    *tmp___40 = (char )(n / 100000L + 48L);
#line 1471
    n %= 100000L;
#line 1471
    tmp___41 = p;
#line 1471
    p ++;
#line 1471
    *tmp___41 = (char )(n / 10000L + 48L);
#line 1471
    n %= 10000L;
#line 1471
    tmp___42 = p;
#line 1471
    p ++;
#line 1471
    *tmp___42 = (char )(n / 1000L + 48L);
#line 1471
    n %= 1000L;
#line 1471
    tmp___43 = p;
#line 1471
    p ++;
#line 1471
    *tmp___43 = (char )(n / 100L + 48L);
#line 1471
    n %= 100L;
#line 1471
    tmp___44 = p;
#line 1471
    p ++;
#line 1471
    *tmp___44 = (char )(n / 10L + 48L);
#line 1471
    n %= 10L;
#line 1471
    tmp___45 = p;
#line 1471
    p ++;
#line 1471
    *tmp___45 = (char )(n + 48L);
  } else {
#line 1474
    tmp___46 = p;
#line 1474
    p ++;
#line 1474
    *tmp___46 = (char )(n / 1000000000L + 48L);
#line 1474
    n %= 1000000000L;
#line 1474
    tmp___47 = p;
#line 1474
    p ++;
#line 1474
    *tmp___47 = (char )(n / 100000000L + 48L);
#line 1474
    n %= 100000000L;
#line 1474
    tmp___48 = p;
#line 1474
    p ++;
#line 1474
    *tmp___48 = (char )(n / 10000000L + 48L);
#line 1474
    n %= 10000000L;
#line 1474
    tmp___49 = p;
#line 1474
    p ++;
#line 1474
    *tmp___49 = (char )(n / 1000000L + 48L);
#line 1474
    n %= 1000000L;
#line 1474
    tmp___50 = p;
#line 1474
    p ++;
#line 1474
    *tmp___50 = (char )(n / 100000L + 48L);
#line 1474
    n %= 100000L;
#line 1474
    tmp___51 = p;
#line 1474
    p ++;
#line 1474
    *tmp___51 = (char )(n / 10000L + 48L);
#line 1474
    n %= 10000L;
#line 1474
    tmp___52 = p;
#line 1474
    p ++;
#line 1474
    *tmp___52 = (char )(n / 1000L + 48L);
#line 1474
    n %= 1000L;
#line 1474
    tmp___53 = p;
#line 1474
    p ++;
#line 1474
    *tmp___53 = (char )(n / 100L + 48L);
#line 1474
    n %= 100L;
#line 1474
    tmp___54 = p;
#line 1474
    p ++;
#line 1474
    *tmp___54 = (char )(n / 10L + 48L);
#line 1474
    n %= 10L;
#line 1474
    tmp___55 = p;
#line 1474
    p ++;
#line 1474
    *tmp___55 = (char )(n + 48L);
  }
#line 1488
  *p = (char )'\000';
#line 1491
  return (p);
}
}
#line 1572 "utils.c"
struct wget_timer *wtimer_allocate(void) 
{ 
  struct wget_timer *wt ;
  void *tmp ;

  {
  {
#line 1575
  tmp = xmalloc_real((size_t )sizeof(struct wget_timer ));
#line 1575
  wt = (struct wget_timer *)tmp;
  }
#line 1577
  return (wt);
}
}
#line 1582 "utils.c"
struct wget_timer *wtimer_new(void) 
{ 
  struct wget_timer *wt ;
  struct wget_timer *tmp ;

  {
  {
#line 1585
  tmp = wtimer_allocate();
#line 1585
  wt = tmp;
#line 1586
  wtimer_reset(wt);
  }
#line 1587
  return (wt);
}
}
#line 1593 "utils.c"
void wtimer_delete(struct wget_timer *wt ) 
{ 


  {
  {
#line 1596
  free((void *)wt);
  }
#line 1597
  return;
}
}
#line 1601 "utils.c"
static void wtimer_sys_set(wget_sys_time *wst ) 
{ 


  {
  {
#line 1605
  gettimeofday((struct timeval */* __restrict  */)wst, (__timezone_ptr_t )((void *)0));
  }
#line 1631
  return;
}
}
#line 1637 "utils.c"
void wtimer_reset(struct wget_timer *wt ) 
{ 


  {
  {
#line 1641
  wtimer_sys_set(& wt->start);
#line 1642
  wt->elapsed_last = (double )0;
#line 1643
  wt->elapsed_pre_start = (double )0;
  }
#line 1644
  return;
}
}
#line 1646 "utils.c"
static double wtimer_sys_diff(wget_sys_time *wst1 , wget_sys_time *wst2 ) 
{ 


  {
#line 1650
  return ((double )(wst1->tv_sec - wst2->tv_sec) * (double )1000 + (double )(wst1->tv_usec - wst2->tv_usec) / (double )1000);
}
}
#line 1671 "utils.c"
double wtimer_elapsed(struct wget_timer *wt ) 
{ 
  wget_sys_time now ;
  double elapsed ;
  double tmp ;

  {
  {
#line 1677
  wtimer_sys_set(& now);
#line 1678
  tmp = wtimer_sys_diff(& now, & wt->start);
#line 1678
  elapsed = wt->elapsed_pre_start + tmp;
  }
#line 1693
  if (elapsed < wt->elapsed_last) {
#line 1695
    wt->start = now;
#line 1696
    wt->elapsed_pre_start = wt->elapsed_last;
#line 1697
    elapsed = wt->elapsed_last;
  }
#line 1700
  wt->elapsed_last = elapsed;
#line 1701
  return (elapsed);
}
}
#line 1708 "utils.c"
double wtimer_granularity(void) 
{ 


  {
#line 1716
  return (0.1);
}
}
#line 1744 "utils.c"
char *html_quote_string(char const   *s ) 
{ 
  char const   *b ;
  char *p ;
  char *res___0 ;
  int i ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;

  {
#line 1747
  b = s;
#line 1752
  i = 0;
  {
#line 1752
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1752
    if (! *s) {
#line 1752
      goto while_break;
    }
#line 1754
    if ((int const   )*s == 38) {
#line 1755
      i += 4;
    } else
#line 1756
    if ((int const   )*s == 60) {
#line 1757
      i += 3;
    } else
#line 1756
    if ((int const   )*s == 62) {
#line 1757
      i += 3;
    } else
#line 1758
    if ((int const   )*s == 34) {
#line 1759
      i += 5;
    } else
#line 1760
    if ((int const   )*s == 32) {
#line 1761
      i += 4;
    }
#line 1752
    s ++;
#line 1752
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1763
  tmp = xmalloc_real((size_t )(i + 1));
#line 1763
  res___0 = (char *)tmp;
#line 1764
  s = b;
#line 1765
  p = res___0;
  }
  {
#line 1765
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1765
    if (! *s) {
#line 1765
      goto while_break___0;
    }
    {
#line 1769
    if ((int const   )*s == 38) {
#line 1769
      goto case_38;
    }
#line 1776
    if ((int const   )*s == 62) {
#line 1776
      goto case_62;
    }
#line 1776
    if ((int const   )*s == 60) {
#line 1776
      goto case_62;
    }
#line 1782
    if ((int const   )*s == 34) {
#line 1782
      goto case_34;
    }
#line 1790
    if ((int const   )*s == 32) {
#line 1790
      goto case_32;
    }
#line 1797
    goto switch_default;
    case_38: /* CIL Label */ 
#line 1770
    tmp___0 = p;
#line 1770
    p ++;
#line 1770
    *tmp___0 = (char )'&';
#line 1771
    tmp___1 = p;
#line 1771
    p ++;
#line 1771
    *tmp___1 = (char )'a';
#line 1772
    tmp___2 = p;
#line 1772
    p ++;
#line 1772
    *tmp___2 = (char )'m';
#line 1773
    tmp___3 = p;
#line 1773
    p ++;
#line 1773
    *tmp___3 = (char )'p';
#line 1774
    tmp___4 = p;
#line 1774
    p ++;
#line 1774
    *tmp___4 = (char )';';
#line 1775
    goto switch_break;
    case_62: /* CIL Label */ 
    case_60: /* CIL Label */ 
#line 1777
    tmp___5 = p;
#line 1777
    p ++;
#line 1777
    *tmp___5 = (char )'&';
#line 1778
    tmp___6 = p;
#line 1778
    p ++;
#line 1778
    if ((int const   )*s == 60) {
#line 1778
      *tmp___6 = (char )'l';
    } else {
#line 1778
      *tmp___6 = (char )'g';
    }
#line 1779
    tmp___7 = p;
#line 1779
    p ++;
#line 1779
    *tmp___7 = (char )'t';
#line 1780
    tmp___8 = p;
#line 1780
    p ++;
#line 1780
    *tmp___8 = (char )';';
#line 1781
    goto switch_break;
    case_34: /* CIL Label */ 
#line 1783
    tmp___9 = p;
#line 1783
    p ++;
#line 1783
    *tmp___9 = (char )'&';
#line 1784
    tmp___10 = p;
#line 1784
    p ++;
#line 1784
    *tmp___10 = (char )'q';
#line 1785
    tmp___11 = p;
#line 1785
    p ++;
#line 1785
    *tmp___11 = (char )'u';
#line 1786
    tmp___12 = p;
#line 1786
    p ++;
#line 1786
    *tmp___12 = (char )'o';
#line 1787
    tmp___13 = p;
#line 1787
    p ++;
#line 1787
    *tmp___13 = (char )'t';
#line 1788
    tmp___14 = p;
#line 1788
    p ++;
#line 1788
    *tmp___14 = (char )';';
#line 1789
    goto switch_break;
    case_32: /* CIL Label */ 
#line 1791
    tmp___15 = p;
#line 1791
    p ++;
#line 1791
    *tmp___15 = (char )'&';
#line 1792
    tmp___16 = p;
#line 1792
    p ++;
#line 1792
    *tmp___16 = (char )'#';
#line 1793
    tmp___17 = p;
#line 1793
    p ++;
#line 1793
    *tmp___17 = (char )'3';
#line 1794
    tmp___18 = p;
#line 1794
    p ++;
#line 1794
    *tmp___18 = (char )'2';
#line 1795
    tmp___19 = p;
#line 1795
    p ++;
#line 1795
    *tmp___19 = (char )';';
#line 1796
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1798
    tmp___20 = p;
#line 1798
    p ++;
#line 1798
    *tmp___20 = (char )*s;
    switch_break: /* CIL Label */ ;
    }
#line 1765
    s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1801
  *p = (char )'\000';
#line 1802
  return (res___0);
}
}
#line 1808 "utils.c"
int determine_screen_width(void) 
{ 
  int fd ;
  struct winsize wsz ;
  int tmp ;

  {
#line 1819
  if ((unsigned long )opt.lfilename != (unsigned long )((void *)0)) {
#line 1820
    return (0);
  }
  {
#line 1822
  fd = fileno(stderr);
#line 1823
  tmp = ioctl(fd, 21523UL, & wsz);
  }
#line 1823
  if (tmp < 0) {
#line 1824
    return (0);
  }
#line 1826
  return ((int )wsz.ws_col);
}
}
#line 1851 "utils.c"
static int seeded  ;
#line 1848 "utils.c"
int random_number(int max ) 
{ 
  double bounded ;
  int rnd ;
  time_t tmp ;

  {
#line 1855
  if (! seeded) {
    {
#line 1857
    tmp = time((time_t *)((void *)0));
#line 1857
    srand((unsigned int )tmp);
#line 1858
    seeded = 1;
    }
  }
  {
#line 1860
  rnd = rand();
#line 1873
  bounded = ((double )max * (double )rnd) / ((double )2147483647 + 1.0);
  }
#line 1874
  return ((int )bounded);
}
}
#line 1882 "utils.c"
double random_float(void) 
{ 
  int rnd1 ;
  int tmp ;
  int rnd2 ;
  int tmp___0 ;
  int rnd3 ;
  int tmp___1 ;

  {
  {
#line 1887
  tmp = random_number(1000);
#line 1887
  rnd1 = tmp;
#line 1888
  tmp___0 = random_number(1000);
#line 1888
  rnd2 = tmp___0;
#line 1889
  tmp___1 = random_number(1000);
#line 1889
  rnd3 = tmp___1;
  }
#line 1890
  return (((double )rnd1 / 1000.0 + (double )rnd2 / 1000000.0) + (double )rnd3 / 1000000000.0);
}
}
#line 1934 "utils.c"
static sigjmp_buf run_with_timeout_env  ;
#line 1936 "utils.c"
static void abort_run_with_timeout(int sig ) 
{ 
  long tmp ;

  {
  {
#line 1939
  tmp = __builtin_expect((long )(! (! (sig == 14))), 1L);
  }
#line 1939
  if (! tmp) {
    {
#line 1939
    __assert_fail("sig == 14", "utils.c", 1939U, "abort_run_with_timeout");
    }
  }
  {
#line 1940
  siglongjmp((struct __jmp_buf_tag *)(run_with_timeout_env), -1);
  }
}
}
#line 1971 "utils.c"
static void alarm_set(double timeout ) 
{ 
  struct itimerval itv ;

  {
  {
#line 1977
  memset((void *)(& itv), 0, (size_t )sizeof(itv));
#line 1978
  itv.it_value.tv_sec = (long )timeout;
#line 1979
  itv.it_value.tv_usec = (__suseconds_t )((double )1000000L * (timeout - (double )((long )timeout)));
  }
#line 1980
  if (itv.it_value.tv_sec == 0L) {
#line 1980
    if (itv.it_value.tv_usec == 0L) {
#line 1983
      itv.it_value.tv_usec = (__suseconds_t )1;
    }
  }
  {
#line 1984
  setitimer(0, (struct itimerval  const  */* __restrict  */)(& itv), (struct itimerval */* __restrict  */)((void *)0));
  }
#line 1996
  return;
}
}
#line 2000 "utils.c"
static void alarm_cancel(void) 
{ 
  struct itimerval disable ;

  {
  {
#line 2005
  memset((void *)(& disable), 0, (size_t )sizeof(disable));
#line 2006
  setitimer(0, (struct itimerval  const  */* __restrict  */)(& disable), (struct itimerval */* __restrict  */)((void *)0));
  }
#line 2010
  return;
}
}
#line 2039 "utils.c"
int run_with_timeout(double timeout , void (*fun)(void * ) , void *arg ) 
{ 
  int saved_errno ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 2044
  if (timeout == (double )0) {
    {
#line 2046
    (*fun)(arg);
    }
#line 2047
    return (0);
  }
  {
#line 2050
  signal(14, & abort_run_with_timeout);
#line 2051
  tmp = __sigsetjmp((struct __jmp_buf_tag *)(run_with_timeout_env), 1);
  }
#line 2051
  if (tmp != 0) {
    {
#line 2054
    signal(14, (void (*)(int  ))0);
    }
#line 2055
    return (1);
  }
  {
#line 2057
  alarm_set(timeout);
#line 2058
  (*fun)(arg);
#line 2061
  tmp___0 = __errno_location();
#line 2061
  saved_errno = *tmp___0;
#line 2062
  alarm_cancel();
#line 2063
  signal(14, (void (*)(int  ))0);
#line 2064
  tmp___1 = __errno_location();
#line 2064
  *tmp___1 = saved_errno;
  }
#line 2066
  return (0);
}
}
#line 65 "/usr/include/string.h"
extern void *memchr(void const   *__s , int __c , size_t __n )  __attribute__((__pure__)) ;
#line 162
extern char *strchr(char const   *__s , int __c )  __attribute__((__pure__)) ;
#line 183
extern char *strpbrk(char const   *__s , char const   *__accept )  __attribute__((__pure__)) ;
#line 291
extern int strncasecmp(char const   *__s1 , char const   *__s2 , size_t __n )  __attribute__((__pure__)) ;
#line 125 "safe-ctype.h"
unsigned char const   _sch_toupper[256] ;
#line 76 "url.h"
char *url_escape(char const   *s ) ;
#line 78
struct url *url_parse(char const   *url , int *error ) ;
#line 79
char const   *url_error(int error_code ) ;
#line 80
char *url_full_path(struct url  const  *url ) ;
#line 81
void url_set_dir(struct url *url , char const   *newdir ) ;
#line 82
void url_set_file(struct url *url , char const   *newfile ) ;
#line 83
void url_free(struct url *url ) ;
#line 85
enum url_scheme url_scheme(char const   *url ) ;
#line 86
int url_has_scheme(char const   *url ) ;
#line 87
int scheme_default_port(enum url_scheme scheme ) ;
#line 88
void scheme_disable(enum url_scheme scheme ) ;
#line 90
char *url_string(struct url  const  *url , int hide_password ) ;
#line 91
char *url_file_name(struct url  const  *u ) ;
#line 93
char *uri_merge(char const   *base , char const   *link___0 ) ;
#line 95
int mkalldirs(char const   *path ) ;
#line 97
char *rewrite_shorthand_url(char const   *url ) ;
#line 98
int schemes_are_similar_p(enum url_scheme a , enum url_scheme b ) ;
#line 63 "url.c"
static struct scheme_data supported_schemes[4]  = {      {(char *)"http://", 80, 1}, 
        {(char *)"https://", 443, 1}, 
        {(char *)"ftp://", 21, 1}, 
        {(char *)((void *)0), -1, 0}};
#line 77
static int path_simplify(char *path ) ;
#line 100 "url.c"
static unsigned char const   urlchr_table[256]  = 
#line 100
  {      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )3, 
        (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )1, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )1, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )3,      (unsigned char const   )1, 
        (unsigned char const   )2,      (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )1, 
        (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )3, 
        (unsigned char const   )2,      (unsigned char const   )3,      (unsigned char const   )2,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2};
#line 142 "url.c"
static void url_unescape(char *s ) 
{ 
  char *t ;
  char *h ;
  int tmp ;
  int tmp___0 ;

  {
#line 145
  t = s;
#line 146
  h = s;
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;
#line 148
    if (! *h) {
#line 148
      goto while_break;
    }
#line 150
    if ((int )*h != 37) {
      copychar: 
#line 153
      *t = *h;
    } else {
#line 158
      if (! *(h + 1)) {
#line 159
        goto copychar;
      } else
#line 158
      if (! *(h + 2)) {
#line 159
        goto copychar;
      } else
#line 158
      if ((int const   )_sch_istable[(int )*(h + 1) & 255] & 256) {
#line 158
        if (! ((int const   )_sch_istable[(int )*(h + 2) & 255] & 256)) {
#line 159
          goto copychar;
        }
      } else {
#line 159
        goto copychar;
      }
#line 160
      if ((int )*(h + 1) < 65) {
#line 160
        tmp = (int )*(h + 1) - 48;
      } else {
#line 160
        tmp = (int )(((int const   )_sch_toupper[(int )*(h + 1) & 255] - 65) + 10);
      }
#line 160
      if ((int )*(h + 2) < 65) {
#line 160
        tmp___0 = (int )*(h + 2) - 48;
      } else {
#line 160
        tmp___0 = (int )(((int const   )_sch_toupper[(int )*(h + 2) & 255] - 65) + 10);
      }
#line 160
      *t = (char )((tmp << 4) + tmp___0);
#line 161
      h += 2;
    }
#line 148
    h ++;
#line 148
    t ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 164
  *t = (char )'\000';
#line 165
  return;
}
}
#line 174 "url.c"
static char *url_escape_1(char const   *s , unsigned char mask , int allow_passthrough ) 
{ 
  char const   *p1 ;
  char *p2 ;
  char *newstr ;
  int newlen ;
  int addition ;
  char *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  unsigned char c ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char const   *tmp___7 ;
  long tmp___8 ;

  {
#line 180
  addition = 0;
#line 182
  p1 = s;
  {
#line 182
  while (1) {
    while_continue: /* CIL Label */ ;
#line 182
    if (! *p1) {
#line 182
      goto while_break;
    }
#line 183
    if ((int const   )urlchr_table[(unsigned char )*p1] & (int const   )mask) {
#line 184
      addition += 2;
    }
#line 182
    p1 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 186
  if (! addition) {
#line 187
    if (allow_passthrough) {
#line 187
      tmp___0 = (char *)s;
    } else {
      {
#line 187
      tmp = xstrdup_real(s);
#line 187
      tmp___0 = tmp;
      }
    }
#line 187
    return (tmp___0);
  }
  {
#line 189
  newlen = (int )((p1 - s) + (long )addition);
#line 190
  tmp___1 = xmalloc_real((size_t )(newlen + 1));
#line 190
  newstr = (char *)tmp___1;
#line 192
  p1 = s;
#line 193
  p2 = newstr;
  }
  {
#line 194
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 194
    if (! *p1) {
#line 194
      goto while_break___0;
    }
#line 197
    if ((int const   )urlchr_table[(unsigned char )*p1] & (int const   )mask) {
#line 199
      tmp___2 = p1;
#line 199
      p1 ++;
#line 199
      c = (unsigned char )*tmp___2;
#line 200
      tmp___3 = p2;
#line 200
      p2 ++;
#line 200
      *tmp___3 = (char )'%';
#line 201
      tmp___4 = p2;
#line 201
      p2 ++;
#line 201
      *tmp___4 = (char )*("0123456789ABCDEF" + ((int )c >> 4));
#line 202
      tmp___5 = p2;
#line 202
      p2 ++;
#line 202
      *tmp___5 = (char )*("0123456789ABCDEF" + ((int )c & 15));
    } else {
#line 205
      tmp___6 = p2;
#line 205
      p2 ++;
#line 205
      tmp___7 = p1;
#line 205
      p1 ++;
#line 205
      *tmp___6 = (char )*tmp___7;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 207
  tmp___8 = __builtin_expect((long )(! (! (p2 - newstr == (long )newlen))), 1L);
  }
#line 207
  if (! tmp___8) {
    {
#line 207
    __assert_fail("p2 - newstr == newlen", "url.c", 207U, "url_escape_1");
    }
  }
#line 208
  *p2 = (char )'\000';
#line 210
  return (newstr);
}
}
#line 216 "url.c"
char *url_escape(char const   *s ) 
{ 
  char *tmp ;

  {
  {
#line 219
  tmp = url_escape_1(s, (unsigned char)2, 0);
  }
#line 219
  return (tmp);
}
}
#line 225 "url.c"
static char *url_escape_allow_passthrough(char const   *s ) 
{ 
  char *tmp ;

  {
  {
#line 228
  tmp = url_escape_1(s, (unsigned char)2, 1);
  }
#line 228
  return (tmp);
}
}
#line 235 "url.c"
__inline static enum copy_method decide_copy_method(char const   *p ) 
{ 
  char preempt ;
  int tmp ;
  int tmp___0 ;

  {
#line 238
  if ((int const   )*p == 37) {
#line 240
    if ((int const   )_sch_istable[(int const   )*(p + 1) & 255] & 256) {
#line 240
      if ((int const   )_sch_istable[(int const   )*(p + 2) & 255] & 256) {
#line 245
        if ((int const   )*(p + 1) < 65) {
#line 245
          tmp = (int const   )*(p + 1) - 48;
        } else {
#line 245
          tmp = ((int const   )_sch_toupper[(int const   )*(p + 1) & 255] - 65) + 10;
        }
#line 245
        if ((int const   )*(p + 2) < 65) {
#line 245
          tmp___0 = (int const   )*(p + 2) - 48;
        } else {
#line 245
          tmp___0 = ((int const   )_sch_toupper[(int const   )*(p + 2) & 255] - 65) + 10;
        }
#line 245
        preempt = (char )((tmp << 4) + tmp___0);
#line 246
        if ((int const   )urlchr_table[(unsigned char )preempt] & 2) {
#line 247
          return ((enum copy_method )2);
        } else
#line 246
        if ((int const   )urlchr_table[(unsigned char )preempt] & 1) {
#line 247
          return ((enum copy_method )2);
        } else {
#line 249
          return ((enum copy_method )0);
        }
      } else {
#line 253
        return ((enum copy_method )1);
      }
    } else {
#line 253
      return ((enum copy_method )1);
    }
  } else
#line 255
  if ((int const   )urlchr_table[(unsigned char )*p] & 2) {
#line 255
    if (! ((int const   )urlchr_table[(unsigned char )*p] & 1)) {
#line 256
      return ((enum copy_method )1);
    } else {
#line 258
      return ((enum copy_method )2);
    }
  } else {
#line 258
    return ((enum copy_method )2);
  }
}
}
#line 340 "url.c"
static char *reencode_escapes(char const   *s ) 
{ 
  char const   *p1 ;
  char *newstr ;
  char *p2 ;
  int oldlen ;
  int newlen ;
  int encode_count ;
  int decode_count ;
  enum copy_method tmp ;
  void *tmp___0 ;
  enum copy_method tmp___1 ;
  unsigned char c ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  char const   *tmp___10 ;
  long tmp___11 ;

  {
#line 347
  encode_count = 0;
#line 348
  decode_count = 0;
#line 352
  p1 = s;
  {
#line 352
  while (1) {
    while_continue: /* CIL Label */ ;
#line 352
    if (! *p1) {
#line 352
      goto while_break;
    }
    {
#line 354
    tmp = decide_copy_method(p1);
    }
    {
#line 356
    if ((unsigned int )tmp == 1U) {
#line 356
      goto case_1;
    }
#line 359
    if ((unsigned int )tmp == 0U) {
#line 359
      goto case_0;
    }
#line 362
    if ((unsigned int )tmp == 2U) {
#line 362
      goto case_2;
    }
#line 354
    goto switch_break;
    case_1: /* CIL Label */ 
#line 357
    encode_count ++;
#line 358
    goto switch_break;
    case_0: /* CIL Label */ 
#line 360
    decode_count ++;
#line 361
    goto switch_break;
    case_2: /* CIL Label */ 
#line 363
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 352
    p1 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 367
  if (! encode_count) {
#line 367
    if (! decode_count) {
#line 369
      return ((char *)s);
    }
  }
  {
#line 371
  oldlen = (int )(p1 - s);
#line 374
  newlen = oldlen + 2 * (encode_count - decode_count);
#line 375
  tmp___0 = xmalloc_real((size_t )(newlen + 1));
#line 375
  newstr = (char *)tmp___0;
#line 377
  p1 = s;
#line 378
  p2 = newstr;
  }
  {
#line 380
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 380
    if (! *p1) {
#line 380
      goto while_break___0;
    }
    {
#line 382
    tmp___1 = decide_copy_method(p1);
    }
    {
#line 384
    if ((unsigned int )tmp___1 == 1U) {
#line 384
      goto case_1___0;
    }
#line 392
    if ((unsigned int )tmp___1 == 0U) {
#line 392
      goto case_0___0;
    }
#line 396
    if ((unsigned int )tmp___1 == 2U) {
#line 396
      goto case_2___0;
    }
#line 382
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
#line 386
    tmp___2 = p1;
#line 386
    p1 ++;
#line 386
    c = (unsigned char )*tmp___2;
#line 387
    tmp___3 = p2;
#line 387
    p2 ++;
#line 387
    *tmp___3 = (char )'%';
#line 388
    tmp___4 = p2;
#line 388
    p2 ++;
#line 388
    *tmp___4 = (char )*("0123456789ABCDEF" + ((int )c >> 4));
#line 389
    tmp___5 = p2;
#line 389
    p2 ++;
#line 389
    *tmp___5 = (char )*("0123456789ABCDEF" + ((int )c & 15));
#line 391
    goto switch_break___0;
    case_0___0: /* CIL Label */ 
#line 393
    tmp___6 = p2;
#line 393
    p2 ++;
#line 393
    if ((int const   )*(p1 + 1) < 65) {
#line 393
      tmp___7 = (int const   )*(p1 + 1) - 48;
    } else {
#line 393
      tmp___7 = ((int const   )_sch_toupper[(int const   )*(p1 + 1) & 255] - 65) + 10;
    }
#line 393
    if ((int const   )*(p1 + 2) < 65) {
#line 393
      tmp___8 = (int const   )*(p1 + 2) - 48;
    } else {
#line 393
      tmp___8 = ((int const   )_sch_toupper[(int const   )*(p1 + 2) & 255] - 65) + 10;
    }
#line 393
    *tmp___6 = (char )((tmp___7 << 4) + tmp___8);
#line 394
    p1 += 3;
#line 395
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
#line 397
    tmp___9 = p2;
#line 397
    p2 ++;
#line 397
    tmp___10 = p1;
#line 397
    p1 ++;
#line 397
    *tmp___9 = (char )*tmp___10;
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 400
  *p2 = (char )'\000';
#line 401
  tmp___11 = __builtin_expect((long )(! (! (p2 - newstr == (long )newlen))), 1L);
  }
#line 401
  if (! tmp___11) {
    {
#line 401
    __assert_fail("p2 - newstr == newlen", "url.c", 401U, "reencode_escapes");
    }
  }
#line 402
  return (newstr);
}
}
#line 408 "url.c"
enum url_scheme url_scheme(char const   *url ) 
{ 
  int i ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 413
  i = 0;
  {
#line 413
  while (1) {
    while_continue: /* CIL Label */ ;
#line 413
    if (! supported_schemes[i].leading_string) {
#line 413
      goto while_break;
    }
    {
#line 414
    tmp = strlen((char const   *)supported_schemes[i].leading_string);
#line 414
    tmp___0 = strncasecmp(url, (char const   *)supported_schemes[i].leading_string,
                          tmp);
    }
#line 414
    if (0 == tmp___0) {
#line 417
      if (supported_schemes[i].enabled) {
#line 418
        return ((enum url_scheme )i);
      } else {
#line 420
        return ((enum url_scheme )3);
      }
    }
#line 413
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 423
  return ((enum url_scheme )3);
}
}
#line 432 "url.c"
int url_has_scheme(char const   *url ) 
{ 
  char const   *p ;

  {
#line 435
  p = url;
#line 438
  if (! *p) {
#line 439
    return (0);
  } else
#line 438
  if (! ((int const   )_sch_istable[(int const   )*p & 255] & 140)) {
#line 438
    if (! ((int const   )*p == 45)) {
#line 438
      if (! ((int const   )*p == 43)) {
#line 439
        return (0);
      }
    }
  }
#line 440
  p ++;
  {
#line 442
  while (1) {
    while_continue: /* CIL Label */ ;
#line 442
    if (*p) {
#line 442
      if (! ((int const   )_sch_istable[(int const   )*p & 255] & 140)) {
#line 442
        if (! ((int const   )*p == 45)) {
#line 442
          if (! ((int const   )*p == 43)) {
#line 442
            goto while_break;
          }
        }
      }
    } else {
#line 442
      goto while_break;
    }
#line 443
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 445
  return ((int const   )*p == 58);
}
}
#line 448 "url.c"
int scheme_default_port(enum url_scheme scheme ) 
{ 


  {
#line 451
  return (supported_schemes[scheme].default_port);
}
}
#line 454 "url.c"
void scheme_disable(enum url_scheme scheme ) 
{ 


  {
#line 457
  supported_schemes[scheme].enabled = 0;
#line 458
  return;
}
}
#line 466 "url.c"
static int url_skip_credentials(char const   *url ) 
{ 
  char const   *p ;
  char *tmp ;

  {
  {
#line 471
  tmp = strpbrk(url, "@/?#;");
#line 471
  p = (char const   *)tmp;
  }
#line 472
  if (! p) {
#line 473
    return (0);
  } else
#line 472
  if ((int const   )*p != 64) {
#line 473
    return (0);
  }
#line 474
  return ((int )((p + 1) - url));
}
}
#line 480 "url.c"
static int parse_credentials(char const   *beg , char const   *end , char **user ,
                             char **passwd ) 
{ 
  char *colon ;
  char const   *userend ;
  void *tmp ;

  {
#line 486
  if ((unsigned long )beg == (unsigned long )end) {
#line 487
    return (0);
  }
  {
#line 489
  tmp = memchr((void const   *)beg, ':', (size_t )(end - beg));
#line 489
  colon = (char *)tmp;
  }
#line 490
  if ((unsigned long )colon == (unsigned long )beg) {
#line 491
    return (0);
  }
#line 493
  if (colon) {
    {
#line 495
    *passwd = strdupdelim((char const   *)(colon + 1), end);
#line 496
    userend = (char const   *)colon;
#line 497
    url_unescape(*passwd);
    }
  } else {
#line 501
    *passwd = (char *)((void *)0);
#line 502
    userend = end;
  }
  {
#line 504
  *user = strdupdelim(beg, userend);
#line 505
  url_unescape(*user);
  }
#line 506
  return (1);
}
}
#line 522 "url.c"
char *rewrite_shorthand_url(char const   *url ) 
{ 
  char const   *p ;
  int tmp ;
  char const   *pp ;
  char *res___0 ;
  int digits ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *res___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 527
  tmp = url_has_scheme(url);
  }
#line 527
  if (tmp) {
#line 528
    return ((char *)((void *)0));
  }
#line 532
  p = url;
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
#line 532
    if (*p) {
#line 532
      if ((int const   )*p != 58) {
#line 532
        if (! ((int const   )*p != 47)) {
#line 532
          goto while_break;
        }
      } else {
#line 532
        goto while_break;
      }
    } else {
#line 532
      goto while_break;
    }
#line 532
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 535
  if ((unsigned long )p == (unsigned long )url) {
#line 536
    return ((char *)((void *)0));
  }
#line 538
  if ((int const   )*p == 58) {
#line 544
    digits = 0;
#line 545
    pp = p + 1;
    {
#line 545
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 545
      if (! ((int const   )_sch_istable[(int const   )*pp & 255] & 4)) {
#line 545
        goto while_break___0;
      }
#line 546
      digits ++;
#line 545
      pp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 547
    if (digits > 0) {
#line 547
      if ((int const   )*pp == 47) {
#line 548
        goto http;
      } else
#line 547
      if ((int const   )*pp == 0) {
#line 548
        goto http;
      }
    }
    {
#line 551
    tmp___0 = strlen(url);
#line 551
    tmp___1 = xmalloc_real((6U + tmp___0) + 1U);
#line 551
    res___0 = (char *)tmp___1;
#line 552
    sprintf((char */* __restrict  */)res___0, (char const   */* __restrict  */)"ftp://%s",
            url);
#line 554
    *(res___0 + (6L + (p - url))) = (char )'/';
    }
#line 555
    return (res___0);
  } else {
    http: 
    {
#line 562
    tmp___2 = strlen(url);
#line 562
    tmp___3 = xmalloc_real((7U + tmp___2) + 1U);
#line 562
    res___1 = (char *)tmp___3;
#line 563
    sprintf((char */* __restrict  */)res___1, (char const   */* __restrict  */)"http://%s",
            url);
    }
#line 564
    return (res___1);
  }
}
}
#line 568
static void split_path(char const   *path , char **dir , char **file ) ;
#line 606 "url.c"
static int lowercase_str(char *str ) 
{ 
  int change ;

  {
#line 609
  change = 0;
  {
#line 610
  while (1) {
    while_continue: /* CIL Label */ ;
#line 610
    if (! *str) {
#line 610
      goto while_break;
    }
#line 611
    if ((int const   )_sch_istable[(int )*str & 255] & 128) {
#line 613
      change = 1;
#line 614
      *str = (char )_sch_tolower[(int )*str & 255];
    }
#line 610
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 616
  return (change);
}
}
#line 619 "url.c"
static char *parse_errors[8]  = 
#line 619
  {      (char *)"No error",      (char *)"Unsupported scheme",      (char *)"Empty host",      (char *)"Bad port number", 
        (char *)"Invalid user name",      (char *)"Unterminated IPv6 numeric address",      (char *)"IPv6 addresses not supported",      (char *)"Invalid IPv6 numeric address"};
#line 779 "url.c"
struct url *url_parse(char const   *url , int *error ) 
{ 
  struct url *u ;
  char const   *p ;
  int path_modified ;
  int host_modified ;
  enum url_scheme scheme ;
  char const   *uname_b ;
  char const   *uname_e ;
  char const   *host_b ;
  char const   *host_e ;
  char const   *path_b ;
  char const   *path_e ;
  char const   *params_b ;
  char const   *params_e ;
  char const   *query_b ;
  char const   *query_e ;
  char const   *fragment_b ;
  char const   *fragment_e ;
  int port ;
  char *user ;
  char *passwd ;
  char *url_encoded ;
  int error_code ;
  size_t tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *SOE_p ;
  char *tmp___2 ;
  size_t tmp___3 ;
  char const   *port_b ;
  char const   *port_e ;
  char const   *pp ;
  char *SOE_p___0 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  char *SOE_p___1 ;
  char *tmp___6 ;
  size_t tmp___7 ;
  char *SOE_p___2 ;
  char *tmp___8 ;
  size_t tmp___9 ;
  char *SOE_p___3 ;
  char *tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  long tmp___13 ;
  int tmp___14 ;
  void *tmp___15 ;

  {
  {
#line 796
  user = (char *)((void *)0);
#line 796
  passwd = (char *)((void *)0);
#line 798
  url_encoded = (char *)((void *)0);
#line 802
  scheme = url_scheme(url);
  }
#line 803
  if ((unsigned int )scheme == 3U) {
#line 805
    error_code = 1;
#line 806
    goto error;
  }
  {
#line 809
  url_encoded = reencode_escapes(url);
#line 810
  p = (char const   *)url_encoded;
#line 812
  tmp = strlen((char const   *)supported_schemes[scheme].leading_string);
#line 812
  p += tmp;
#line 813
  uname_b = p;
#line 814
  tmp___0 = url_skip_credentials(p);
#line 814
  p += tmp___0;
#line 815
  uname_e = p;
#line 825
  params_e = (char const   *)((void *)0);
#line 825
  params_b = params_e;
#line 826
  query_e = (char const   *)((void *)0);
#line 826
  query_b = query_e;
#line 827
  fragment_e = (char const   *)((void *)0);
#line 827
  fragment_b = fragment_e;
#line 829
  host_b = p;
  }
#line 831
  if ((int const   )*p == 91) {
    {
#line 838
    host_b = p + 1;
#line 839
    tmp___1 = strchr(host_b, ']');
#line 839
    host_e = (char const   *)tmp___1;
    }
#line 841
    if (! host_e) {
#line 843
      error_code = 5;
#line 844
      goto error;
    }
#line 858
    error_code = 6;
#line 859
    goto error;
  } else {
    {
#line 864
    tmp___2 = strpbrk(p, ":/;?#");
#line 864
    SOE_p = tmp___2;
    }
#line 864
    if (! SOE_p) {
      {
#line 864
      tmp___3 = strlen(p);
#line 864
      SOE_p = (char *)p + tmp___3;
      }
    }
#line 864
    p = (char const   *)SOE_p;
#line 865
    host_e = p;
  }
#line 868
  if ((unsigned long )host_b == (unsigned long )host_e) {
#line 870
    error_code = 2;
#line 871
    goto error;
  }
  {
#line 874
  port = scheme_default_port(scheme);
  }
#line 875
  if ((int const   )*p == 58) {
    {
#line 881
    p ++;
#line 882
    port_b = p;
#line 883
    tmp___4 = strpbrk(p, "/;?#");
#line 883
    SOE_p___0 = tmp___4;
    }
#line 883
    if (! SOE_p___0) {
      {
#line 883
      tmp___5 = strlen(p);
#line 883
      SOE_p___0 = (char *)p + tmp___5;
      }
    }
#line 883
    p = (char const   *)SOE_p___0;
#line 884
    port_e = p;
#line 886
    if ((unsigned long )port_b == (unsigned long )port_e) {
#line 890
      error_code = 3;
#line 891
      goto error;
    }
#line 894
    port = 0;
#line 894
    pp = port_b;
    {
#line 894
    while (1) {
      while_continue: /* CIL Label */ ;
#line 894
      if (! ((unsigned long )pp < (unsigned long )port_e)) {
#line 894
        goto while_break;
      }
#line 896
      if (! ((int const   )_sch_istable[(int const   )*pp & 255] & 4)) {
#line 900
        error_code = 3;
#line 901
        goto error;
      }
#line 904
      port = 10 * port + (int )((int const   )*pp - 48);
#line 894
      pp ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 908
  if ((int const   )*p == 47) {
    {
#line 910
    p ++;
#line 911
    path_b = p;
#line 912
    tmp___6 = strpbrk(p, ";?#");
#line 912
    SOE_p___1 = tmp___6;
    }
#line 912
    if (! SOE_p___1) {
      {
#line 912
      tmp___7 = strlen(p);
#line 912
      SOE_p___1 = (char *)p + tmp___7;
      }
    }
#line 912
    p = (char const   *)SOE_p___1;
#line 913
    path_e = p;
  } else {
#line 918
    path_e = p;
#line 918
    path_b = path_e;
  }
#line 921
  if ((int const   )*p == 59) {
    {
#line 923
    p ++;
#line 924
    params_b = p;
#line 925
    tmp___8 = strpbrk(p, "?#");
#line 925
    SOE_p___2 = tmp___8;
    }
#line 925
    if (! SOE_p___2) {
      {
#line 925
      tmp___9 = strlen(p);
#line 925
      SOE_p___2 = (char *)p + tmp___9;
      }
    }
#line 925
    p = (char const   *)SOE_p___2;
#line 926
    params_e = p;
  }
#line 928
  if ((int const   )*p == 63) {
    {
#line 930
    p ++;
#line 931
    query_b = p;
#line 932
    tmp___10 = strpbrk(p, "#");
#line 932
    SOE_p___3 = tmp___10;
    }
#line 932
    if (! SOE_p___3) {
      {
#line 932
      tmp___11 = strlen(p);
#line 932
      SOE_p___3 = (char *)p + tmp___11;
      }
    }
#line 932
    p = (char const   *)SOE_p___3;
#line 933
    query_e = p;
#line 938
    if ((unsigned int )scheme == 2U) {
#line 940
      query_e = (char const   *)((void *)0);
#line 940
      query_b = query_e;
#line 941
      path_e = p;
    }
  }
#line 944
  if ((int const   )*p == 35) {
    {
#line 946
    p ++;
#line 947
    fragment_b = p;
#line 948
    tmp___12 = strlen(p);
#line 948
    p += tmp___12;
#line 949
    fragment_e = p;
    }
  }
  {
#line 951
  tmp___13 = __builtin_expect((long )(! (! ((int const   )*p == 0))), 1L);
  }
#line 951
  if (! tmp___13) {
    {
#line 951
    __assert_fail("*p == 0", "url.c", 951U, "url_parse");
    }
  }
#line 953
  if ((unsigned long )uname_b != (unsigned long )uname_e) {
    {
#line 958
    tmp___14 = parse_credentials(uname_b, uname_e - 1, & user, & passwd);
    }
#line 958
    if (! tmp___14) {
#line 960
      error_code = 4;
#line 961
      goto error;
    }
  }
  {
#line 965
  tmp___15 = xmalloc_real((size_t )sizeof(struct url ));
#line 965
  u = (struct url *)tmp___15;
#line 966
  memset((void *)u, 0, (size_t )sizeof(*u));
#line 968
  u->scheme = scheme;
#line 969
  u->host = strdupdelim(host_b, host_e);
#line 970
  u->port = port;
#line 971
  u->user = user;
#line 972
  u->passwd = passwd;
#line 974
  u->path = strdupdelim(path_b, path_e);
#line 975
  path_modified = path_simplify(u->path);
#line 976
  split_path((char const   *)u->path, & u->dir, & u->file);
#line 978
  host_modified = lowercase_str(u->host);
  }
#line 980
  if (params_b) {
    {
#line 981
    u->params = strdupdelim(params_b, params_e);
    }
  }
#line 982
  if (query_b) {
    {
#line 983
    u->query = strdupdelim(query_b, query_e);
    }
  }
#line 984
  if (fragment_b) {
    {
#line 985
    u->fragment = strdupdelim(fragment_b, fragment_e);
    }
  }
#line 987
  if (path_modified) {
#line 987
    goto _L;
  } else
#line 987
  if (u->fragment) {
#line 987
    goto _L;
  } else
#line 987
  if (host_modified) {
#line 987
    goto _L;
  } else
#line 987
  if ((unsigned long )path_b == (unsigned long )path_e) {
    _L: /* CIL Label */ 
    {
#line 992
    u->url = url_string((struct url  const  *)u, 0);
    }
#line 994
    if ((unsigned long )url_encoded != (unsigned long )url) {
      {
#line 995
      free((void *)url_encoded);
      }
    }
  } else
#line 999
  if ((unsigned long )url_encoded == (unsigned long )url) {
    {
#line 1000
    u->url = xstrdup_real(url);
    }
  } else {
#line 1002
    u->url = url_encoded;
  }
#line 1004
  url_encoded = (char *)((void *)0);
#line 1006
  return (u);
  error: 
#line 1010
  if (url_encoded) {
#line 1010
    if ((unsigned long )url_encoded != (unsigned long )url) {
      {
#line 1011
      free((void *)url_encoded);
      }
    }
  }
#line 1015
  if (error) {
#line 1016
    *error = error_code;
  }
#line 1017
  return ((struct url *)((void *)0));
}
}
#line 1023 "url.c"
char const   *url_error(int error_code ) 
{ 
  int tmp ;
  long tmp___0 ;
  char *tmp___1 ;

  {
#line 1026
  if (error_code >= 0) {
#line 1026
    if ((unsigned long )error_code < sizeof(parse_errors) / sizeof(parse_errors[0])) {
#line 1026
      tmp = 1;
    } else {
#line 1026
      tmp = 0;
    }
  } else {
#line 1026
    tmp = 0;
  }
  {
#line 1026
  tmp___0 = __builtin_expect((long )tmp, 1L);
  }
#line 1026
  if (! tmp___0) {
    {
#line 1026
    __assert_fail("error_code >= 0 && error_code < (sizeof (parse_errors) / sizeof (*(parse_errors)))",
                  "url.c", 1026U, "url_error");
    }
  }
  {
#line 1027
  tmp___1 = gettext((char const   *)parse_errors[error_code]);
  }
#line 1027
  return ((char const   *)tmp___1);
}
}
#line 1045 "url.c"
static void split_path(char const   *path , char **dir , char **file ) 
{ 
  char *last_slash ;
  char *tmp ;

  {
  {
#line 1048
  tmp = strrchr(path, '/');
#line 1048
  last_slash = tmp;
  }
#line 1049
  if (! last_slash) {
    {
#line 1051
    *dir = xstrdup_real("");
#line 1052
    *file = xstrdup_real(path);
    }
  } else {
    {
#line 1056
    *dir = strdupdelim(path, (char const   *)last_slash);
#line 1057
    *file = xstrdup_real((char const   *)(last_slash + 1));
    }
  }
  {
#line 1059
  url_unescape(*dir);
#line 1060
  url_unescape(*file);
  }
#line 1061
  return;
}
}
#line 1072 "url.c"
static int full_path_length(struct url  const  *url ) 
{ 
  int len ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 1075
  len = 0;
#line 1079
  if (url->path) {
    {
#line 1079
    tmp = strlen((char const   *)url->path);
#line 1079
    len = (int )((size_t )len + (1U + tmp));
    }
  }
#line 1080
  if (url->params) {
    {
#line 1080
    tmp___0 = strlen((char const   *)url->params);
#line 1080
    len = (int )((size_t )len + (1U + tmp___0));
    }
  }
#line 1081
  if (url->query) {
    {
#line 1081
    tmp___1 = strlen((char const   *)url->query);
#line 1081
    len = (int )((size_t )len + (1U + tmp___1));
    }
  }
#line 1085
  return (len);
}
}
#line 1090 "url.c"
static void full_path_write(struct url  const  *url , char *where ) 
{ 
  char *f_el ;
  int l ;
  size_t tmp ;
  char *tmp___0 ;
  char *f_el___0 ;
  int l___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char *f_el___1 ;
  int l___1 ;
  size_t tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 1103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1103
    f_el = (char *)url->path;
#line 1103
    if (f_el) {
      {
#line 1103
      tmp = strlen((char const   *)f_el);
#line 1103
      l = (int )tmp;
#line 1103
      tmp___0 = where;
#line 1103
      where ++;
#line 1103
      *tmp___0 = (char )'/';
#line 1103
      memcpy((void */* __restrict  */)where, (void const   */* __restrict  */)f_el,
             (size_t )l);
#line 1103
      where += l;
      }
    }
#line 1103
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1104
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1104
    f_el___0 = (char *)url->params;
#line 1104
    if (f_el___0) {
      {
#line 1104
      tmp___1 = strlen((char const   *)f_el___0);
#line 1104
      l___0 = (int )tmp___1;
#line 1104
      tmp___2 = where;
#line 1104
      where ++;
#line 1104
      *tmp___2 = (char )';';
#line 1104
      memcpy((void */* __restrict  */)where, (void const   */* __restrict  */)f_el___0,
             (size_t )l___0);
#line 1104
      where += l___0;
      }
    }
#line 1104
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1105
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1105
    f_el___1 = (char *)url->query;
#line 1105
    if (f_el___1) {
      {
#line 1105
      tmp___3 = strlen((char const   *)f_el___1);
#line 1105
      l___1 = (int )tmp___3;
#line 1105
      tmp___4 = where;
#line 1105
      where ++;
#line 1105
      *tmp___4 = (char )'?';
#line 1105
      memcpy((void */* __restrict  */)where, (void const   */* __restrict  */)f_el___1,
             (size_t )l___1);
#line 1105
      where += l___1;
      }
    }
#line 1105
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1108
  return;
}
}
#line 1114 "url.c"
char *url_full_path(struct url  const  *url ) 
{ 
  int length ;
  int tmp ;
  char *full_path ;
  void *tmp___0 ;

  {
  {
#line 1117
  tmp = full_path_length(url);
#line 1117
  length = tmp;
#line 1118
  tmp___0 = xmalloc_real((size_t )(length + 1));
#line 1118
  full_path = (char *)tmp___0;
#line 1120
  full_path_write(url, full_path);
#line 1121
  *(full_path + length) = (char )'\000';
  }
#line 1123
  return (full_path);
}
}
#line 1129 "url.c"
static char *url_escape_dir(char const   *dir ) 
{ 
  char *newdir ;
  char *tmp ;
  char *h ;
  char *t ;

  {
  {
#line 1132
  tmp = url_escape_1(dir, (unsigned char)3, 1);
#line 1132
  newdir = tmp;
  }
#line 1134
  if ((unsigned long )newdir == (unsigned long )dir) {
#line 1135
    return ((char *)dir);
  }
#line 1139
  h = newdir;
#line 1140
  t = newdir;
  {
#line 1142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1142
    if (! *h) {
#line 1142
      goto while_break;
    }
#line 1145
    if ((int )*h == 37) {
#line 1145
      if ((int )*(h + 1) == 50) {
#line 1145
        if ((int )*(h + 2) == 70) {
#line 1147
          *t = (char )'/';
#line 1148
          h += 2;
        } else {
#line 1151
          *t = *h;
        }
      } else {
#line 1151
        *t = *h;
      }
    } else {
#line 1151
      *t = *h;
    }
#line 1142
    h ++;
#line 1142
    t ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1153
  *t = (char )'\000';
#line 1155
  return (newdir);
}
}
#line 1161 "url.c"
static void sync_path(struct url *u ) 
{ 
  char *newpath ;
  char *efile ;
  char *edir ;
  int dirlen ;
  size_t tmp ;
  int filelen ;
  size_t tmp___0 ;
  char *p ;
  void *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 1166
  free((void *)u->path);
#line 1174
  edir = url_escape_dir((char const   *)u->dir);
#line 1175
  efile = url_escape_1((char const   *)u->file, (unsigned char)3, 1);
  }
#line 1177
  if (! *edir) {
    {
#line 1178
    newpath = xstrdup_real((char const   *)efile);
    }
  } else {
    {
#line 1181
    tmp = strlen((char const   *)edir);
#line 1181
    dirlen = (int )tmp;
#line 1182
    tmp___0 = strlen((char const   *)efile);
#line 1182
    filelen = (int )tmp___0;
#line 1185
    tmp___1 = xmalloc_real((size_t )(((dirlen + 1) + filelen) + 1));
#line 1185
    newpath = (char *)tmp___1;
#line 1185
    p = newpath;
#line 1186
    memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)edir, (size_t )dirlen);
#line 1187
    p += dirlen;
#line 1188
    tmp___2 = p;
#line 1188
    p ++;
#line 1188
    *tmp___2 = (char )'/';
#line 1189
    memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)efile, (size_t )filelen);
#line 1190
    p += filelen;
#line 1191
    tmp___3 = p;
#line 1191
    p ++;
#line 1191
    *tmp___3 = (char )'\000';
    }
  }
#line 1194
  u->path = newpath;
#line 1196
  if ((unsigned long )edir != (unsigned long )u->dir) {
    {
#line 1197
    free((void *)edir);
    }
  }
#line 1198
  if ((unsigned long )efile != (unsigned long )u->file) {
    {
#line 1199
    free((void *)efile);
    }
  }
  {
#line 1202
  free((void *)u->url);
#line 1203
  u->url = url_string((struct url  const  *)u, 0);
  }
#line 1204
  return;
}
}
#line 1209 "url.c"
void url_set_dir(struct url *url , char const   *newdir ) 
{ 


  {
  {
#line 1212
  free((void *)url->dir);
#line 1213
  url->dir = xstrdup_real(newdir);
#line 1214
  sync_path(url);
  }
#line 1215
  return;
}
}
#line 1217 "url.c"
void url_set_file(struct url *url , char const   *newfile ) 
{ 


  {
  {
#line 1220
  free((void *)url->file);
#line 1221
  url->file = xstrdup_real(newfile);
#line 1222
  sync_path(url);
  }
#line 1223
  return;
}
}
#line 1225 "url.c"
void url_free(struct url *url ) 
{ 


  {
  {
#line 1228
  free((void *)url->host);
#line 1229
  free((void *)url->path);
#line 1230
  free((void *)url->url);
  }
  {
#line 1232
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1232
    if (url->params) {
      {
#line 1232
      free((void *)url->params);
      }
    }
#line 1232
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1233
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1233
    if (url->query) {
      {
#line 1233
      free((void *)url->query);
      }
    }
#line 1233
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1234
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1234
    if (url->fragment) {
      {
#line 1234
      free((void *)url->fragment);
      }
    }
#line 1234
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1235
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1235
    if (url->user) {
      {
#line 1235
      free((void *)url->user);
      }
    }
#line 1235
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1236
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1236
    if (url->passwd) {
      {
#line 1236
      free((void *)url->passwd);
      }
    }
#line 1236
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 1238
  free((void *)url->dir);
#line 1239
  free((void *)url->file);
#line 1241
  free((void *)url);
  }
#line 1242
  return;
}
}
#line 1246 "url.c"
int mkalldirs(char const   *path ) 
{ 
  char const   *p ;
  char *t ;
  struct stat st ;
  int res___0 ;
  size_t tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 1254
  tmp = strlen(path);
#line 1254
  p = path + tmp;
  }
  {
#line 1255
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1255
    if ((int const   )*p != 47) {
#line 1255
      if (! ((unsigned long )p != (unsigned long )path)) {
#line 1255
        goto while_break;
      }
    } else {
#line 1255
      goto while_break;
    }
#line 1255
    p --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1259
  if ((unsigned long )p == (unsigned long )path) {
#line 1259
    if ((int const   )*p != 47) {
#line 1260
      return (0);
    }
  }
  {
#line 1261
  t = strdupdelim(path, p);
#line 1264
  tmp___0 = stat((char const   */* __restrict  */)t, (struct stat */* __restrict  */)(& st));
  }
#line 1264
  if (tmp___0 == 0) {
#line 1266
    if ((st.st_mode & 61440U) == 16384U) {
      {
#line 1268
      free((void *)t);
      }
#line 1269
      return (0);
    } else {
      {
#line 1285
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1285
        if (opt.debug) {
          {
#line 1285
          debug_logprintf("Removing %s because of directory danger!\n", t);
          }
        }
#line 1285
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1286
      unlink((char const   *)t);
      }
    }
  }
  {
#line 1289
  res___0 = make_directory((char const   *)t);
  }
#line 1290
  if (res___0 != 0) {
    {
#line 1291
    tmp___1 = __errno_location();
#line 1291
    tmp___2 = strerror(*tmp___1);
#line 1291
    logprintf((enum log_options )1, "%s: %s", t, tmp___2);
    }
  }
  {
#line 1292
  free((void *)t);
  }
#line 1293
  return (res___0);
}
}
#line 1330 "url.c"
static void append_string(char const   *str , struct growable *dest ) 
{ 
  int l ;
  size_t tmp ;
  struct growable *G_ ;
  long do_realloc_needed_size ;
  long do_realloc_newsize ;
  void *tmp___0 ;

  {
  {
#line 1333
  tmp = strlen(str);
#line 1333
  l = (int )tmp;
  }
  {
#line 1334
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1334
    G_ = dest;
    {
#line 1334
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1334
      do_realloc_needed_size = (long )(G_->tail + l);
#line 1334
      do_realloc_newsize = 0L;
      {
#line 1334
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1334
        if (! ((long )G_->size < do_realloc_needed_size)) {
#line 1334
          goto while_break___1;
        }
#line 1334
        do_realloc_newsize = (long )(2 * G_->size);
#line 1334
        if (do_realloc_newsize < 32L) {
#line 1334
          do_realloc_newsize = 32L;
        }
#line 1334
        G_->size = (int )do_realloc_newsize;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1334
      if (do_realloc_newsize) {
        {
#line 1334
        tmp___0 = xrealloc_real((void *)G_->base, (size_t )((unsigned long )do_realloc_newsize * sizeof(char )));
#line 1334
        G_->base = (char *)tmp___0;
        }
      }
#line 1334
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1334
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1335
  memcpy((void */* __restrict  */)(dest->base + dest->tail), (void const   */* __restrict  */)str,
         (size_t )l);
#line 1336
  dest->tail += l;
  }
#line 1337
  return;
}
}
#line 1342 "url.c"
static void append_char(char ch , struct growable *dest ) 
{ 
  struct growable *G_ ;
  long do_realloc_needed_size ;
  long do_realloc_newsize ;
  void *tmp ;

  {
  {
#line 1345
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1345
    G_ = dest;
    {
#line 1345
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1345
      do_realloc_needed_size = (long )(G_->tail + 1);
#line 1345
      do_realloc_newsize = 0L;
      {
#line 1345
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1345
        if (! ((long )G_->size < do_realloc_needed_size)) {
#line 1345
          goto while_break___1;
        }
#line 1345
        do_realloc_newsize = (long )(2 * G_->size);
#line 1345
        if (do_realloc_newsize < 32L) {
#line 1345
          do_realloc_newsize = 32L;
        }
#line 1345
        G_->size = (int )do_realloc_newsize;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1345
      if (do_realloc_newsize) {
        {
#line 1345
        tmp = xrealloc_real((void *)G_->base, (size_t )((unsigned long )do_realloc_newsize * sizeof(char )));
#line 1345
        G_->base = (char *)tmp;
        }
      }
#line 1345
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1345
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1346
  *(dest->base + dest->tail) = ch;
#line 1347
  (dest->tail) ++;
#line 1348
  return;
}
}
#line 1373 "url.c"
static unsigned char const   filechr_table[256]  = 
#line 1373
  {      (unsigned char const   )7,      (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4, 
        (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4, 
        (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4, 
        (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4, 
        (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4, 
        (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4, 
        (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4, 
        (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )3, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4, 
        (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4, 
        (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4, 
        (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4, 
        (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4, 
        (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4, 
        (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4, 
        (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0};
#line 1423 "url.c"
static void append_uri_pathel(char const   *b , char const   *e , struct growable *dest ) 
{ 
  char *pathel ;
  int pathlen ;
  char const   *p ;
  int quoted ;
  int outlen ;
  int mask ;
  char const   *BTA_beg ;
  int BTA_len ;
  char **BTA_dest ;
  void *tmp ;
  size_t tmp___0 ;
  struct growable *G_ ;
  long do_realloc_needed_size ;
  long do_realloc_newsize ;
  void *tmp___1 ;
  char *q ;
  char *tmp___2 ;
  unsigned char ch ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  long tmp___6 ;

  {
#line 1433
  if ((unsigned int )opt.restrict_files_os == 0U) {
#line 1434
    mask = 1;
  } else {
#line 1436
    mask = 2;
  }
#line 1437
  if (opt.restrict_files_ctrl) {
#line 1438
    mask |= 4;
  }
  {
#line 1441
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1441
    BTA_beg = b;
#line 1441
    BTA_len = (int )(e - BTA_beg);
#line 1441
    BTA_dest = & pathel;
#line 1441
    tmp = __builtin_alloca((unsigned long )(BTA_len + 1));
#line 1441
    *BTA_dest = (char *)tmp;
#line 1441
    memcpy((void */* __restrict  */)*BTA_dest, (void const   */* __restrict  */)BTA_beg,
           (size_t )BTA_len);
#line 1441
    *(*BTA_dest + BTA_len) = (char )'\000';
    }
#line 1441
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1442
  url_unescape(pathel);
#line 1443
  tmp___0 = strlen((char const   *)pathel);
#line 1443
  pathlen = (int )tmp___0;
#line 1447
  quoted = 0;
#line 1448
  p = (char const   *)pathel;
  }
  {
#line 1448
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1448
    if (! *p) {
#line 1448
      goto while_break___0;
    }
#line 1449
    if ((int const   )filechr_table[(unsigned char )*p] & (int const   )mask) {
#line 1450
      quoted ++;
    }
#line 1448
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1454
  outlen = (int )((p - (char const   *)pathel) + (long )(2 * quoted));
  {
#line 1455
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1455
    G_ = dest;
    {
#line 1455
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1455
      do_realloc_needed_size = (long )(G_->tail + outlen);
#line 1455
      do_realloc_newsize = 0L;
      {
#line 1455
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1455
        if (! ((long )G_->size < do_realloc_needed_size)) {
#line 1455
          goto while_break___3;
        }
#line 1455
        do_realloc_newsize = (long )(2 * G_->size);
#line 1455
        if (do_realloc_newsize < 32L) {
#line 1455
          do_realloc_newsize = 32L;
        }
#line 1455
        G_->size = (int )do_realloc_newsize;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1455
      if (do_realloc_newsize) {
        {
#line 1455
        tmp___1 = xrealloc_real((void *)G_->base, (size_t )((unsigned long )do_realloc_newsize * sizeof(char )));
#line 1455
        G_->base = (char *)tmp___1;
        }
      }
#line 1455
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1455
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1457
  if (! quoted) {
    {
#line 1461
    memcpy((void */* __restrict  */)(dest->base + dest->tail), (void const   */* __restrict  */)pathel,
           (size_t )outlen);
    }
  } else {
#line 1465
    q = dest->base + dest->tail;
#line 1466
    p = (char const   *)pathel;
    {
#line 1466
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1466
      if (! *p) {
#line 1466
        goto while_break___4;
      }
#line 1468
      if (! ((int const   )filechr_table[(unsigned char )*p] & (int const   )mask)) {
#line 1469
        tmp___2 = q;
#line 1469
        q ++;
#line 1469
        *tmp___2 = (char )*p;
      } else {
#line 1472
        ch = (unsigned char )*p;
#line 1473
        tmp___3 = q;
#line 1473
        q ++;
#line 1473
        *tmp___3 = (char )'%';
#line 1474
        tmp___4 = q;
#line 1474
        q ++;
#line 1474
        *tmp___4 = (char )*("0123456789ABCDEF" + ((int )ch >> 4));
#line 1475
        tmp___5 = q;
#line 1475
        q ++;
#line 1475
        *tmp___5 = (char )*("0123456789ABCDEF" + ((int )ch & 15));
      }
#line 1466
      p ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 1478
    tmp___6 = __builtin_expect((long )(! (! (q - (dest->base + dest->tail) == (long )outlen))),
                               1L);
    }
#line 1478
    if (! tmp___6) {
      {
#line 1478
      __assert_fail("q - ((dest)->base + (dest)->tail) == outlen", "url.c", 1478U,
                    "append_uri_pathel");
      }
    }
  }
#line 1480
  dest->tail += outlen;
#line 1481
  return;
}
}
#line 1497 "url.c"
static void append_dir_structure(struct url  const  *u , struct growable *dest ) 
{ 
  char *pathel ;
  char *next ;
  int cut ;
  int tmp ;

  {
#line 1501
  cut = opt.cut_dirs;
#line 1506
  pathel = (char *)u->path;
  {
#line 1507
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1507
    next = strchr((char const   *)pathel, '/');
    }
#line 1507
    if (! ((unsigned long )next != (unsigned long )((void *)0))) {
#line 1507
      goto while_break;
    }
#line 1509
    tmp = cut;
#line 1509
    cut --;
#line 1509
    if (tmp > 0) {
#line 1510
      goto __Cont;
    }
#line 1511
    if ((unsigned long )pathel == (unsigned long )next) {
#line 1513
      goto __Cont;
    }
#line 1515
    if (dest->tail) {
      {
#line 1516
      append_char((char )'/', dest);
      }
    }
    {
#line 1517
    append_uri_pathel((char const   *)pathel, (char const   *)next, dest);
    }
    __Cont: /* CIL Label */ 
#line 1507
    pathel = next + 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 1519
  return;
}
}
#line 1524 "url.c"
char *url_file_name(struct url  const  *u ) 
{ 
  struct growable fnres ;
  char *u_file ;
  char *u_query ;
  char *fname ;
  char *unique ;
  char portstr[24] ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1532
  fnres.base = (char *)((void *)0);
#line 1533
  fnres.size = 0;
#line 1534
  fnres.tail = 0;
#line 1537
  if (opt.dir_prefix) {
    {
#line 1538
    append_string((char const   *)opt.dir_prefix, & fnres);
    }
  }
#line 1543
  if (opt.dirstruct) {
#line 1545
    if (opt.add_hostdir) {
#line 1547
      if (fnres.tail) {
        {
#line 1548
        append_char((char )'/', & fnres);
        }
      }
      {
#line 1549
      append_string((char const   *)u->host, & fnres);
#line 1550
      tmp___0 = scheme_default_port((enum url_scheme )u->scheme);
      }
#line 1550
      if (u->port != (int const   )tmp___0) {
        {
#line 1553
        number_to_string(portstr, (long )u->port);
        }
#line 1554
        if ((unsigned int )opt.restrict_files_os != 1U) {
#line 1554
          tmp = ':';
        } else {
#line 1554
          tmp = '+';
        }
        {
#line 1554
        append_char((char )tmp, & fnres);
#line 1555
        append_string((char const   *)(portstr), & fnres);
        }
      }
    }
    {
#line 1559
    append_dir_structure(u, & fnres);
    }
  }
#line 1563
  if (fnres.tail) {
    {
#line 1564
    append_char((char )'/', & fnres);
    }
  }
#line 1565
  if (*(u->file)) {
#line 1565
    u_file = (char *)u->file;
  } else {
#line 1565
    u_file = (char *)"index.html";
  }
  {
#line 1566
  tmp___1 = strlen((char const   *)u_file);
#line 1566
  append_uri_pathel((char const   *)u_file, (char const   *)(u_file + tmp___1), & fnres);
  }
#line 1569
  if (u->query) {
#line 1569
    if (*(u->query)) {
#line 1569
      u_query = (char *)u->query;
    } else {
#line 1569
      u_query = (char *)((void *)0);
    }
  } else {
#line 1569
    u_query = (char *)((void *)0);
  }
#line 1570
  if (u_query) {
#line 1572
    if ((unsigned int )opt.restrict_files_os != 1U) {
#line 1572
      tmp___2 = '?';
    } else {
#line 1572
      tmp___2 = '@';
    }
    {
#line 1572
    append_char((char )tmp___2, & fnres);
#line 1573
    tmp___3 = strlen((char const   *)u_query);
#line 1573
    append_uri_pathel((char const   *)u_query, (char const   *)(u_query + tmp___3),
                      & fnres);
    }
  }
  {
#line 1577
  append_char((char )'\000', & fnres);
#line 1579
  fname = fnres.base;
  }
#line 1590
  if (opt.noclobber) {
#line 1590
    goto _L;
  } else
#line 1590
  if (opt.always_rest) {
#line 1590
    goto _L;
  } else
#line 1590
  if (opt.timestamping) {
#line 1590
    goto _L;
  } else
#line 1590
  if (opt.dirstruct) {
    _L: /* CIL Label */ 
    {
#line 1590
    tmp___4 = file_exists_p((char const   *)fname);
    }
#line 1590
    if (tmp___4) {
      {
#line 1590
      tmp___5 = file_non_directory_p((char const   *)fname);
      }
#line 1590
      if (tmp___5) {
#line 1592
        return (fname);
      }
    } else {
#line 1592
      return (fname);
    }
  }
  {
#line 1594
  unique = unique_name((char const   *)fname, 1);
  }
#line 1595
  if ((unsigned long )unique != (unsigned long )fname) {
    {
#line 1596
    free((void *)fname);
    }
  }
#line 1597
  return (unique);
}
}
#line 1603 "url.c"
static int path_length(char const   *url ) 
{ 
  char const   *q ;
  char *SOE_p ;
  char *tmp ;
  size_t tmp___0 ;

  {
  {
#line 1606
  tmp = strpbrk(url, "?;#");
#line 1606
  SOE_p = tmp;
  }
#line 1606
  if (! SOE_p) {
    {
#line 1606
    tmp___0 = strlen(url);
#line 1606
    SOE_p = (char *)url + tmp___0;
    }
  }
#line 1606
  q = (char const   *)SOE_p;
#line 1607
  return ((int )(q - url));
}
}
#line 1614 "url.c"
static char const   *find_last_char(char const   *b , char const   *e , char c ) 
{ 


  {
  {
#line 1617
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1617
    if (! ((unsigned long )e > (unsigned long )b)) {
#line 1617
      goto while_break;
    }
#line 1618
    if ((int const   )*e == (int const   )c) {
#line 1619
      return (e);
    }
#line 1617
    e --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1620
  return ((char const   *)((void *)0));
}
}
#line 1642 "url.c"
static int path_simplify(char *path ) 
{ 
  char *h ;
  char *t ;
  char *end ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 1648
  if ((int )*(path + 0) == 47) {
#line 1649
    path ++;
  }
  {
#line 1651
  h = path;
#line 1652
  t = path;
#line 1653
  tmp = strlen((char const   *)path);
#line 1653
  end = path + tmp;
  }
  {
#line 1655
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1655
    if (! ((unsigned long )h < (unsigned long )end)) {
#line 1655
      goto while_break;
    }
#line 1659
    if ((int )*(h + 0) == 46) {
#line 1659
      if ((int )*(h + 1) == 47) {
#line 1662
        h += 2;
      } else
#line 1659
      if ((int )*(h + 1) == 0) {
#line 1662
        h += 2;
      } else {
#line 1659
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 1664
    if ((int )*(h + 0) == 46) {
#line 1664
      if ((int )*(h + 1) == 46) {
#line 1664
        if ((int )*(h + 2) == 47) {
#line 1664
          goto _L___0;
        } else
#line 1664
        if ((int )*(h + 2) == 0) {
          _L___0: /* CIL Label */ 
#line 1668
          if ((unsigned long )t > (unsigned long )path) {
#line 1672
            t --;
            {
#line 1672
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 1672
              if ((unsigned long )t > (unsigned long )path) {
#line 1672
                if (! ((int )*(t + -1) != 47)) {
#line 1672
                  goto while_break___0;
                }
              } else {
#line 1672
                goto while_break___0;
              }
#line 1672
              t --;
            }
            while_break___0: /* CIL Label */ ;
            }
          }
#line 1675
          h += 3;
        } else {
#line 1664
          goto _L___1;
        }
      } else {
#line 1664
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 1677
    if ((int )*h == 47) {
#line 1685
      h ++;
    } else
#line 1692
    if ((unsigned long )t == (unsigned long )h) {
      {
#line 1695
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1695
        if ((unsigned long )h < (unsigned long )end) {
#line 1695
          if (! ((int )*h != 47)) {
#line 1695
            goto while_break___1;
          }
        } else {
#line 1695
          goto while_break___1;
        }
#line 1696
        t ++;
#line 1696
        h ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1697
      if ((unsigned long )h < (unsigned long )end) {
#line 1698
        t ++;
#line 1698
        h ++;
      }
    } else {
      {
#line 1703
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1703
        if ((unsigned long )h < (unsigned long )end) {
#line 1703
          if (! ((int )*h != 47)) {
#line 1703
            goto while_break___2;
          }
        } else {
#line 1703
          goto while_break___2;
        }
#line 1704
        tmp___0 = t;
#line 1704
        t ++;
#line 1704
        tmp___1 = h;
#line 1704
        h ++;
#line 1704
        *tmp___0 = *tmp___1;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1705
      if ((unsigned long )h < (unsigned long )end) {
#line 1706
        tmp___2 = t;
#line 1706
        t ++;
#line 1706
        tmp___3 = h;
#line 1706
        h ++;
#line 1706
        *tmp___2 = *tmp___3;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1711
  if ((unsigned long )t != (unsigned long )h) {
#line 1712
    *t = (char )'\000';
  }
#line 1714
  return ((unsigned long )t != (unsigned long )h);
}
}
#line 1727 "url.c"
char *uri_merge(char const   *base , char const   *link___0 ) 
{ 
  int linklength ;
  char const   *end ;
  char *merge ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  int baselength ;
  void *tmp___4 ;
  int baselength___0 ;
  char const   *end1 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  int span ;
  char const   *slash ;
  char const   *start_insert ;
  void *tmp___8 ;
  void *tmp___9 ;
  int span___0 ;
  char const   *slash___0 ;
  char const   *start_insert___0 ;
  char const   *pos ;
  int seen_slash_slash ;
  void *tmp___10 ;
  void *tmp___11 ;
  int need_explicit_slash ;
  int span___1 ;
  char const   *start_insert___1 ;
  char const   *last_slash ;
  char const   *tmp___12 ;
  void *tmp___13 ;

  {
  {
#line 1734
  tmp___0 = url_has_scheme(link___0);
  }
#line 1734
  if (tmp___0) {
    {
#line 1735
    tmp = xstrdup_real(link___0);
    }
#line 1735
    return (tmp);
  }
  {
#line 1738
  tmp___1 = path_length(base);
#line 1738
  end = base + tmp___1;
#line 1739
  tmp___2 = strlen(link___0);
#line 1739
  linklength = (int )tmp___2;
  }
#line 1741
  if (! *link___0) {
    {
#line 1744
    tmp___3 = xstrdup_real(base);
    }
#line 1744
    return (tmp___3);
  } else
#line 1746
  if ((int const   )*link___0 == 63) {
    {
#line 1754
    baselength = (int )(end - base);
#line 1755
    tmp___4 = xmalloc_real((size_t )((baselength + linklength) + 1));
#line 1755
    merge = (char *)tmp___4;
#line 1756
    memcpy((void */* __restrict  */)merge, (void const   */* __restrict  */)base,
           (size_t )baselength);
#line 1757
    memcpy((void */* __restrict  */)(merge + baselength), (void const   */* __restrict  */)link___0,
           (size_t )linklength);
#line 1758
    *(merge + (baselength + linklength)) = (char )'\000';
    }
  } else
#line 1760
  if ((int const   )*link___0 == 35) {
    {
#line 1767
    tmp___5 = strchr(base, '#');
#line 1767
    end1 = (char const   *)tmp___5;
    }
#line 1768
    if (! end1) {
      {
#line 1769
      tmp___6 = strlen(base);
#line 1769
      end1 = base + tmp___6;
      }
    }
    {
#line 1770
    baselength___0 = (int )(end1 - base);
#line 1771
    tmp___7 = xmalloc_real((size_t )((baselength___0 + linklength) + 1));
#line 1771
    merge = (char *)tmp___7;
#line 1772
    memcpy((void */* __restrict  */)merge, (void const   */* __restrict  */)base,
           (size_t )baselength___0);
#line 1773
    memcpy((void */* __restrict  */)(merge + baselength___0), (void const   */* __restrict  */)link___0,
           (size_t )linklength);
#line 1774
    *(merge + (baselength___0 + linklength)) = (char )'\000';
    }
  } else
#line 1776
  if ((int const   )*link___0 == 47) {
#line 1776
    if ((int const   )*(link___0 + 1) == 47) {
      {
#line 1791
      tmp___8 = memchr((void const   *)base, '/', (size_t )(end - base));
#line 1791
      slash = (char const   *)tmp___8;
      }
#line 1795
      if (slash) {
#line 1795
        if ((int const   )*(slash + 1) == 47) {
#line 1796
          start_insert = slash;
        } else {
#line 1798
          start_insert = base;
        }
      } else {
#line 1798
        start_insert = base;
      }
      {
#line 1800
      span = (int )(start_insert - base);
#line 1801
      tmp___9 = xmalloc_real((size_t )((span + linklength) + 1));
#line 1801
      merge = (char *)tmp___9;
      }
#line 1802
      if (span) {
        {
#line 1803
        memcpy((void */* __restrict  */)merge, (void const   */* __restrict  */)base,
               (size_t )span);
        }
      }
      {
#line 1804
      memcpy((void */* __restrict  */)(merge + span), (void const   */* __restrict  */)link___0,
             (size_t )linklength);
#line 1805
      *(merge + (span + linklength)) = (char )'\000';
      }
    } else {
#line 1776
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 1807
  if ((int const   )*link___0 == 47) {
#line 1817
    start_insert___0 = (char const   *)((void *)0);
#line 1818
    pos = base;
#line 1819
    seen_slash_slash = 0;
    again: 
    {
#line 1823
    tmp___10 = memchr((void const   *)pos, '/', (size_t )(end - pos));
#line 1823
    slash___0 = (char const   *)tmp___10;
    }
#line 1824
    if (slash___0) {
#line 1824
      if (! seen_slash_slash) {
#line 1825
        if ((int const   )*(slash___0 + 1) == 47) {
#line 1827
          pos = slash___0 + 2;
#line 1828
          seen_slash_slash = 1;
#line 1829
          goto again;
        }
      }
    }
#line 1838
    if (! slash___0) {
#line 1838
      if (! seen_slash_slash) {
#line 1841
        start_insert___0 = base;
      } else {
#line 1838
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 1842
    if (! slash___0) {
#line 1842
      if (seen_slash_slash) {
#line 1845
        start_insert___0 = end;
      } else {
#line 1842
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1846
    if (slash___0) {
#line 1846
      if (! seen_slash_slash) {
#line 1849
        start_insert___0 = base;
      } else {
#line 1846
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1850
    if (slash___0) {
#line 1850
      if (seen_slash_slash) {
#line 1853
        start_insert___0 = slash___0;
      }
    }
    {
#line 1855
    span___0 = (int )(start_insert___0 - base);
#line 1856
    tmp___11 = xmalloc_real((size_t )((span___0 + linklength) + 1));
#line 1856
    merge = (char *)tmp___11;
    }
#line 1857
    if (span___0) {
      {
#line 1858
      memcpy((void */* __restrict  */)merge, (void const   */* __restrict  */)base,
             (size_t )span___0);
      }
    }
    {
#line 1859
    memcpy((void */* __restrict  */)(merge + span___0), (void const   */* __restrict  */)link___0,
           (size_t )linklength);
#line 1860
    *(merge + (span___0 + linklength)) = (char )'\000';
    }
  } else {
    {
#line 1869
    need_explicit_slash = 0;
#line 1872
    tmp___12 = find_last_char(base, end, (char )'/');
#line 1872
    last_slash = tmp___12;
    }
#line 1873
    if (! last_slash) {
#line 1891
      start_insert___1 = end + 1;
#line 1892
      need_explicit_slash = 1;
    } else
#line 1894
    if (last_slash) {
#line 1894
      if ((unsigned long )last_slash >= (unsigned long )(base + 2)) {
#line 1894
        if ((int const   )*(last_slash + -2) == 58) {
#line 1894
          if ((int const   )*(last_slash + -1) == 47) {
#line 1899
            start_insert___1 = end + 1;
#line 1900
            need_explicit_slash = 1;
          } else {
#line 1906
            start_insert___1 = last_slash + 1;
          }
        } else {
#line 1906
          start_insert___1 = last_slash + 1;
        }
      } else {
#line 1906
        start_insert___1 = last_slash + 1;
      }
    } else {
#line 1906
      start_insert___1 = last_slash + 1;
    }
    {
#line 1909
    span___1 = (int )(start_insert___1 - base);
#line 1910
    tmp___13 = xmalloc_real((size_t )((span___1 + linklength) + 1));
#line 1910
    merge = (char *)tmp___13;
    }
#line 1911
    if (span___1) {
      {
#line 1912
      memcpy((void */* __restrict  */)merge, (void const   */* __restrict  */)base,
             (size_t )span___1);
      }
    }
#line 1913
    if (need_explicit_slash) {
#line 1914
      *(merge + (span___1 - 1)) = (char )'/';
    }
    {
#line 1915
    memcpy((void */* __restrict  */)(merge + span___1), (void const   */* __restrict  */)link___0,
           (size_t )linklength);
#line 1916
    *(merge + (span___1 + linklength)) = (char )'\000';
    }
  }
#line 1919
  return (merge);
}
}
#line 1941 "url.c"
char *url_string(struct url  const  *url , int hide_password ) 
{ 
  int size ;
  char *result ;
  char *p ;
  char *quoted_user ;
  char *quoted_passwd ;
  int scheme_port ;
  char *scheme_str ;
  int fplen ;
  int tmp ;
  int brackets_around_host ;
  long tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  int len ;
  size_t tmp___9 ;
  int len___0 ;
  size_t tmp___10 ;
  char *tmp___11 ;
  int len___1 ;
  size_t tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  int len___2 ;
  size_t tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  long tmp___19 ;

  {
  {
#line 1946
  quoted_user = (char *)((void *)0);
#line 1946
  quoted_passwd = (char *)((void *)0);
#line 1948
  scheme_port = supported_schemes[url->scheme].default_port;
#line 1949
  scheme_str = supported_schemes[url->scheme].leading_string;
#line 1950
  tmp = full_path_length(url);
#line 1950
  fplen = tmp;
#line 1952
  brackets_around_host = 0;
#line 1954
  tmp___0 = __builtin_expect((long )(! (! ((unsigned long )scheme_str != (unsigned long )((void *)0)))),
                             1L);
  }
#line 1954
  if (! tmp___0) {
    {
#line 1954
    __assert_fail("scheme_str != ((void *)0)", "url.c", 1954U, "url_string");
    }
  }
#line 1957
  if (url->user) {
    {
#line 1959
    quoted_user = url_escape_allow_passthrough((char const   *)url->user);
    }
#line 1960
    if (url->passwd) {
#line 1962
      if (hide_password) {
#line 1963
        quoted_passwd = (char *)"*password*";
      } else {
        {
#line 1965
        quoted_passwd = url_escape_allow_passthrough((char const   *)url->passwd);
        }
      }
    }
  }
  {
#line 1969
  tmp___1 = strchr((char const   *)url->host, ':');
  }
#line 1969
  if (tmp___1) {
#line 1970
    brackets_around_host = 1;
  }
  {
#line 1972
  tmp___2 = strlen((char const   *)scheme_str);
#line 1972
  tmp___3 = strlen((char const   *)url->host);
  }
#line 1972
  if (brackets_around_host) {
#line 1972
    tmp___4 = 2;
  } else {
#line 1972
    tmp___4 = 0;
  }
#line 1972
  size = (int )((((tmp___2 + tmp___3) + (size_t )tmp___4) + (size_t )fplen) + 1U);
#line 1977
  if (url->port != (int const   )scheme_port) {
    {
#line 1978
    tmp___5 = numdigit((long )url->port);
#line 1978
    size += 1 + tmp___5;
    }
  }
#line 1979
  if (quoted_user) {
    {
#line 1981
    tmp___6 = strlen((char const   *)quoted_user);
#line 1981
    size = (int )((size_t )size + (1U + tmp___6));
    }
#line 1982
    if (quoted_passwd) {
      {
#line 1983
      tmp___7 = strlen((char const   *)quoted_passwd);
#line 1983
      size = (int )((size_t )size + (1U + tmp___7));
      }
    }
  }
  {
#line 1986
  tmp___8 = xmalloc_real((size_t )size);
#line 1986
  result = (char *)tmp___8;
#line 1986
  p = result;
  }
  {
#line 1988
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1988
    tmp___9 = strlen((char const   *)scheme_str);
#line 1988
    len = (int )tmp___9;
#line 1988
    memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)scheme_str,
           (size_t )len);
#line 1988
    p += len;
    }
#line 1988
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1989
  if (quoted_user) {
    {
#line 1991
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1991
      tmp___10 = strlen((char const   *)quoted_user);
#line 1991
      len___0 = (int )tmp___10;
#line 1991
      memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)quoted_user,
             (size_t )len___0);
#line 1991
      p += len___0;
      }
#line 1991
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1992
    if (quoted_passwd) {
#line 1994
      tmp___11 = p;
#line 1994
      p ++;
#line 1994
      *tmp___11 = (char )':';
      {
#line 1995
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 1995
        tmp___12 = strlen((char const   *)quoted_passwd);
#line 1995
        len___1 = (int )tmp___12;
#line 1995
        memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)quoted_passwd,
               (size_t )len___1);
#line 1995
        p += len___1;
        }
#line 1995
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 1997
    tmp___13 = p;
#line 1997
    p ++;
#line 1997
    *tmp___13 = (char )'@';
  }
#line 2000
  if (brackets_around_host) {
#line 2001
    tmp___14 = p;
#line 2001
    p ++;
#line 2001
    *tmp___14 = (char )'[';
  }
  {
#line 2002
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 2002
    tmp___15 = strlen((char const   *)url->host);
#line 2002
    len___2 = (int )tmp___15;
#line 2002
    memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)url->host,
           (size_t )len___2);
#line 2002
    p += len___2;
    }
#line 2002
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2003
  if (brackets_around_host) {
#line 2004
    tmp___16 = p;
#line 2004
    p ++;
#line 2004
    *tmp___16 = (char )']';
  }
#line 2005
  if (url->port != (int const   )scheme_port) {
    {
#line 2007
    tmp___17 = p;
#line 2007
    p ++;
#line 2007
    *tmp___17 = (char )':';
#line 2008
    p = number_to_string(p, (long )url->port);
    }
  }
  {
#line 2011
  full_path_write(url, p);
#line 2012
  p += fplen;
#line 2013
  tmp___18 = p;
#line 2013
  p ++;
#line 2013
  *tmp___18 = (char )'\000';
#line 2015
  tmp___19 = __builtin_expect((long )(! (! (p - result == (long )size))), 1L);
  }
#line 2015
  if (! tmp___19) {
    {
#line 2015
    __assert_fail("p - result == size", "url.c", 2015U, "url_string");
    }
  }
#line 2017
  if (quoted_user) {
#line 2017
    if ((unsigned long )quoted_user != (unsigned long )url->user) {
      {
#line 2018
      free((void *)quoted_user);
      }
    }
  }
#line 2019
  if (quoted_passwd) {
#line 2019
    if (! hide_password) {
#line 2019
      if ((unsigned long )quoted_passwd != (unsigned long )url->passwd) {
        {
#line 2021
        free((void *)quoted_passwd);
        }
      }
    }
  }
#line 2023
  return (result);
}
}
#line 2031 "url.c"
int schemes_are_similar_p(enum url_scheme a , enum url_scheme b ) 
{ 


  {
#line 2034
  if ((unsigned int )a == (unsigned int )b) {
#line 2035
    return (1);
  }
#line 2037
  if ((unsigned int )a == 0U) {
#line 2037
    if ((unsigned int )b == 1U) {
#line 2039
      return (1);
    } else {
#line 2037
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 2037
  if ((unsigned int )a == 1U) {
#line 2037
    if ((unsigned int )b == 0U) {
#line 2039
      return (1);
    }
  }
#line 2041
  return (0);
}
}
#line 527 "/usr/include/openssl/bio.h"
extern long BIO_ctrl(BIO *bp , int cmd , long larg , void *parg ) ;
#line 749 "/usr/include/openssl/evp.h"
extern void OPENSSL_add_all_algorithms_noconf(void) ;
#line 910 "/usr/include/openssl/x509.h"
extern char *X509_NAME_oneline(X509_NAME *a , char *buf , int size ) ;
#line 939
extern X509_NAME *X509_get_subject_name(X509 *a ) ;
#line 1172 "/usr/include/openssl/ssl.h"
extern SSL_CTX *SSL_CTX_new(SSL_METHOD *meth ) ;
#line 1173
extern void SSL_CTX_free(SSL_CTX * ) ;
#line 1194
extern int SSL_pending(SSL *s ) ;
#line 1196
extern int SSL_set_fd(SSL *s , int fd ) ;
#line 1227
extern int SSL_CTX_use_PrivateKey_file(SSL_CTX *ctx , char const   *file , int type ) ;
#line 1228
extern int SSL_CTX_use_certificate_file(SSL_CTX *ctx , char const   *file , int type ) ;
#line 1242
extern void SSL_load_error_strings(void) ;
#line 1282
extern void SSL_CTX_set_verify(SSL_CTX *ctx , int mode , int (*callback)(int  , X509_STORE_CTX * ) ) ;
#line 1305
extern SSL *SSL_new(SSL_CTX *ctx ) ;
#line 1314
extern void SSL_free(SSL *ssl ) ;
#line 1316
extern int SSL_connect(SSL *ssl ) ;
#line 1317
extern int SSL_read(SSL *ssl , void *buf , int num ) ;
#line 1319
extern int SSL_write(SSL *ssl , void const   *buf , int num ) ;
#line 1333
extern SSL_METHOD *SSLv2_client_method(void) ;
#line 1337
extern SSL_METHOD *SSLv3_client_method(void) ;
#line 1341
extern SSL_METHOD *SSLv23_client_method(void) ;
#line 1345
extern SSL_METHOD *TLSv1_client_method(void) ;
#line 1352
extern int SSL_shutdown(SSL *s ) ;
#line 1368
extern void SSL_set_connect_state(SSL *s ) ;
#line 1373
extern int SSL_library_init(void) ;
#line 1391
extern int SSL_CTX_load_verify_locations(SSL_CTX *ctx , char const   *CAfile , char const   *CApath ) ;
#line 244 "/usr/include/openssl/err.h"
extern unsigned long ERR_get_error(void) ;
#line 257
extern char *ERR_error_string(unsigned long e , char *buf ) ;
#line 101 "/usr/include/openssl/rand.h"
extern void RAND_seed(void const   *buf , int num ) ;
#line 103
extern int RAND_load_file(char const   *file , long max_bytes ) ;
#line 105
extern char const   *RAND_file_name(char *file , size_t num ) ;
#line 106
extern int RAND_status(void) ;
#line 108
extern int RAND_egd(char const   *path ) ;
#line 42 "connect.h"
int select_fd(int fd , double maxtime , int writep ) ;
#line 63 "gen_sslfunc.c"
void ssl_init_prng(void) 
{ 
  char rand_file[256] ;
  int maxrand ;
  int tmp ;
  int tmp___0 ;
  unsigned char rnd ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 72
  maxrand = 500;
#line 76
  RAND_file_name(rand_file, (size_t )sizeof(rand_file));
  }
#line 77
  if (rand_file) {
    {
#line 79
    RAND_load_file((char const   *)(rand_file), 16384L);
    }
  }
  {
#line 81
  tmp = RAND_status();
  }
#line 81
  if (tmp) {
#line 82
    return;
  }
#line 85
  if (opt.sslegdsock) {
#line 85
    if (*(opt.sslegdsock)) {
      {
#line 86
      RAND_egd((char const   *)opt.sslegdsock);
      }
    }
  }
  {
#line 88
  tmp___0 = RAND_status();
  }
#line 88
  if (tmp___0) {
#line 89
    return;
  }
  {
#line 108
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 108
    tmp___2 = RAND_status();
    }
#line 108
    if (tmp___2 == 0) {
#line 108
      tmp___3 = maxrand;
#line 108
      maxrand --;
#line 108
      if (! (tmp___3 > 0)) {
#line 108
        goto while_break;
      }
    } else {
#line 108
      goto while_break;
    }
    {
#line 110
    tmp___1 = random_number(256);
#line 110
    rnd = (unsigned char )tmp___1;
#line 111
    RAND_seed((void const   *)(& rnd), (int )sizeof(rnd));
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 114
  tmp___5 = RAND_status();
  }
#line 114
  if (tmp___5 == 0) {
    {
#line 116
    tmp___4 = gettext("Could not seed OpenSSL PRNG; disabling SSL.\n");
#line 116
    logprintf((enum log_options )1, (char const   *)tmp___4);
#line 118
    scheme_disable((enum url_scheme )1);
    }
  }
#line 121
  return;
}
}
#line 123 "gen_sslfunc.c"
int verify_callback(int ok , X509_STORE_CTX *ctx ) 
{ 
  char *s ;
  char buf___0[256] ;
  X509_NAME *tmp ;

  {
  {
#line 127
  tmp = X509_get_subject_name(ctx->current_cert);
#line 127
  s = X509_NAME_oneline(tmp, buf___0, 256);
  }
#line 128
  if (ok == 0) {
    {
#line 131
    if (ctx->error == 10) {
#line 131
      goto case_10;
    }
#line 131
    if (ctx->error == 9) {
#line 131
      goto case_10;
    }
#line 135
    if (ctx->error == 18) {
#line 135
      goto case_18;
    }
#line 129
    goto switch_break;
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
#line 133
    ok = 0;
#line 134
    goto switch_break;
    case_18: /* CIL Label */ 
#line 137
    ok = 1;
#line 138
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 141
  return (ok);
}
}
#line 146 "gen_sslfunc.c"
int ssl_printerrors(void) 
{ 
  int ocerr ;
  unsigned long curerr ;
  char errbuff[1024] ;
  char *tmp ;

  {
  {
#line 149
  ocerr = 0;
#line 150
  curerr = 0UL;
#line 152
  memset((void *)(errbuff), 0, (size_t )sizeof(errbuff));
  }
  {
#line 153
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 153
    curerr = ERR_get_error();
    }
#line 153
    if (! (0UL != curerr)) {
#line 153
      goto while_break;
    }
    {
#line 155
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 155
      if (opt.debug) {
        {
#line 155
        tmp = ERR_error_string(curerr, errbuff);
#line 155
        debug_logprintf("OpenSSL: %s\n", tmp);
        }
      }
#line 155
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 156
    ocerr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 158
  return (ocerr);
}
}
#line 162 "gen_sslfunc.c"
enum __anonenum_uerr_t_41 init_ssl(SSL_CTX **ctx ) 
{ 
  SSL_METHOD *meth ;
  int verify ;
  int can_validate ;
  int ssl_cert_type ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 165
  meth = (SSL_METHOD *)((void *)0);
#line 168
  SSL_library_init();
#line 169
  SSL_load_error_strings();
#line 170
  OPENSSL_add_all_algorithms_noconf();
#line 171
  SSL_library_init();
  }
  {
#line 177
  if (opt.sslprotocol == 1) {
#line 177
    goto case_1;
  }
#line 180
  if (opt.sslprotocol == 2) {
#line 180
    goto case_2;
  }
#line 183
  if (opt.sslprotocol == 3) {
#line 183
    goto case_3;
  }
#line 174
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 175
  meth = SSLv23_client_method();
  }
#line 176
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 178
  meth = SSLv2_client_method();
  }
#line 179
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 181
  meth = SSLv3_client_method();
  }
#line 182
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 184
  meth = TLSv1_client_method();
  }
#line 185
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 187
  if ((unsigned long )meth == (unsigned long )((void *)0)) {
    {
#line 189
    ssl_printerrors();
    }
#line 190
    return ((uerr_t )58);
  }
  {
#line 193
  *ctx = SSL_CTX_new(meth);
  }
#line 194
  if ((unsigned long )meth == (unsigned long )((void *)0)) {
    {
#line 196
    ssl_printerrors();
    }
#line 197
    return ((uerr_t )58);
  }
#line 200
  if ((unsigned long )opt.sslcadir != (unsigned long )((void *)0)) {
    {
#line 202
    SSL_CTX_load_verify_locations(*ctx, (char const   *)opt.sslcafile, (char const   *)opt.sslcadir);
#line 203
    can_validate = 1;
    }
  } else
#line 200
  if ((unsigned long )opt.sslcafile != (unsigned long )((void *)0)) {
    {
#line 202
    SSL_CTX_load_verify_locations(*ctx, (char const   *)opt.sslcafile, (char const   *)opt.sslcadir);
#line 203
    can_validate = 1;
    }
  } else {
#line 207
    can_validate = 0;
  }
#line 210
  if (! opt.sslcheckcert) {
#line 213
    verify = 0;
  } else
#line 217
  if (! can_validate) {
    {
#line 219
    logprintf((enum log_options )1, "Warrining validation of Server Cert not possible!\n");
#line 220
    verify = 0;
    }
  } else {
#line 225
    verify = 1;
  }
  {
#line 229
  SSL_CTX_set_verify(*ctx, verify, & verify_callback);
  }
#line 231
  if ((unsigned long )opt.sslcertfile != (unsigned long )((void *)0)) {
#line 231
    goto _L;
  } else
#line 231
  if ((unsigned long )opt.sslcertkey != (unsigned long )((void *)0)) {
    _L: /* CIL Label */ 
#line 234
    if (! opt.sslcerttype) {
#line 235
      ssl_cert_type = 1;
    } else {
#line 237
      ssl_cert_type = 2;
    }
#line 239
    if ((unsigned long )opt.sslcertkey == (unsigned long )((void *)0)) {
#line 240
      opt.sslcertkey = opt.sslcertfile;
    }
#line 241
    if ((unsigned long )opt.sslcertfile == (unsigned long )((void *)0)) {
#line 242
      opt.sslcertfile = opt.sslcertkey;
    }
    {
#line 244
    tmp = SSL_CTX_use_certificate_file(*ctx, (char const   *)opt.sslcertfile, ssl_cert_type);
    }
#line 244
    if (tmp <= 0) {
      {
#line 246
      ssl_printerrors();
      }
#line 247
      return ((uerr_t )56);
    }
    {
#line 249
    tmp___0 = SSL_CTX_use_PrivateKey_file(*ctx, (char const   *)opt.sslcertkey, ssl_cert_type);
    }
#line 249
    if (tmp___0 <= 0) {
      {
#line 251
      ssl_printerrors();
      }
#line 252
      return ((uerr_t )57);
    }
  }
#line 256
  return ((uerr_t )0);
}
}
#line 259 "gen_sslfunc.c"
void shutdown_ssl(SSL *con ) 
{ 
  int tmp ;

  {
#line 262
  if ((unsigned long )con == (unsigned long )((void *)0)) {
#line 263
    return;
  }
  {
#line 264
  tmp = SSL_shutdown(con);
  }
#line 264
  if (0 == tmp) {
    {
#line 265
    SSL_shutdown(con);
    }
  }
  {
#line 266
  SSL_free(con);
  }
#line 267
  return;
}
}
#line 273 "gen_sslfunc.c"
int connect_ssl(SSL **con , SSL_CTX *ctx , int fd ) 
{ 
  SSL *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 276
  tmp = SSL_new(ctx);
#line 276
  *con = tmp;
  }
#line 276
  if ((unsigned long )((void *)0) == (unsigned long )tmp) {
    {
#line 278
    ssl_printerrors();
    }
#line 279
    return (1);
  }
  {
#line 281
  tmp___0 = SSL_set_fd(*con, fd);
  }
#line 281
  if (! tmp___0) {
    {
#line 283
    ssl_printerrors();
    }
#line 284
    return (1);
  }
  {
#line 286
  SSL_set_connect_state(*con);
#line 287
  tmp___1 = SSL_connect(*con);
  }
  {
#line 289
  if (tmp___1 == 1) {
#line 289
    goto case_1;
  }
#line 296
  if (tmp___1 == 0) {
#line 296
    goto case_0;
  }
#line 291
  goto switch_default;
  case_1: /* CIL Label */ 
#line 290
  return ((*con)->state != 3);
  switch_default: /* CIL Label */ 
  {
#line 292
  ssl_printerrors();
#line 293
  shutdown_ssl(*con);
#line 294
  *con = (SSL *)((void *)0);
  }
#line 295
  return (1);
  case_0: /* CIL Label */ 
  {
#line 297
  ssl_printerrors();
#line 298
  SSL_free(*con);
#line 299
  *con = (SSL *)((void *)0);
  }
#line 300
  return (1);
  switch_break: /* CIL Label */ ;
  }
#line 302
  return (0);
}
}
#line 305 "gen_sslfunc.c"
void free_ssl_ctx(SSL_CTX *ctx ) 
{ 


  {
  {
#line 308
  SSL_CTX_free(ctx);
  }
#line 309
  return;
}
}
#line 314 "gen_sslfunc.c"
int ssl_iread(SSL *con , char *buf___0 , int len ) 
{ 
  int res___0 ;
  int fd ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 318
  BIO_ctrl(con->rbio, 105, 0L, (void *)((char *)(& fd)));
  }
#line 320
  if (opt.read_timeout) {
    {
#line 320
    tmp___0 = SSL_pending(con);
    }
#line 320
    if (! tmp___0) {
      {
#line 321
      tmp = select_fd(fd, opt.read_timeout, 0);
      }
#line 321
      if (tmp <= 0) {
#line 322
        return (-1);
      }
    }
  }
  {
#line 324
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 325
    res___0 = SSL_read(con, (void *)buf___0, len);
    }
#line 324
    if (res___0 == -1) {
      {
#line 324
      tmp___1 = __errno_location();
      }
#line 324
      if (! (*tmp___1 == 4)) {
#line 324
        goto while_break;
      }
    } else {
#line 324
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 328
  return (res___0);
}
}
#line 334 "gen_sslfunc.c"
int ssl_iwrite(SSL *con , char *buf___0 , int len ) 
{ 
  int res___0 ;
  int fd ;
  int tmp ;
  int *tmp___0 ;

  {
  {
#line 337
  res___0 = 0;
#line 338
  BIO_ctrl(con->rbio, 105, 0L, (void *)((char *)(& fd)));
  }
  {
#line 343
  while (1) {
    while_continue: /* CIL Label */ ;
#line 343
    if (! (len > 0)) {
#line 343
      goto while_break;
    }
#line 346
    if (opt.read_timeout) {
      {
#line 347
      tmp = select_fd(fd, opt.read_timeout, 1);
      }
#line 347
      if (tmp <= 0) {
#line 348
        return (-1);
      }
    }
    {
#line 350
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 351
      res___0 = SSL_write(con, (void const   *)buf___0, len);
      }
#line 350
      if (res___0 == -1) {
        {
#line 350
        tmp___0 = __errno_location();
        }
#line 350
        if (! (*tmp___0 == 4)) {
#line 350
          goto while_break___0;
        }
      } else {
#line 350
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 353
    if (res___0 <= 0) {
#line 354
      goto while_break;
    }
#line 355
    buf___0 += res___0;
#line 356
    len -= res___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 358
  return (res___0);
}
}
#line 81 "safe-ctype.c"
unsigned short const   _sch_istable[256]  = 
#line 81 "safe-ctype.c"
  {      (unsigned short const   )2050,      (unsigned short const   )2,      (unsigned short const   )2,      (unsigned short const   )2, 
        (unsigned short const   )2,      (unsigned short const   )2,      (unsigned short const   )2,      (unsigned short const   )2, 
        (unsigned short const   )2,      (unsigned short const   )2115,      (unsigned short const   )1090,      (unsigned short const   )2114, 
        (unsigned short const   )2114,      (unsigned short const   )1090,      (unsigned short const   )2,      (unsigned short const   )2, 
        (unsigned short const   )2,      (unsigned short const   )2,      (unsigned short const   )2,      (unsigned short const   )2, 
        (unsigned short const   )2,      (unsigned short const   )2,      (unsigned short const   )2,      (unsigned short const   )2, 
        (unsigned short const   )2,      (unsigned short const   )2,      (unsigned short const   )2,      (unsigned short const   )2, 
        (unsigned short const   )2,      (unsigned short const   )2,      (unsigned short const   )2,      (unsigned short const   )2, 
        (unsigned short const   )2129,      (unsigned short const   )48,      (unsigned short const   )48,      (unsigned short const   )48, 
        (unsigned short const   )48,      (unsigned short const   )48,      (unsigned short const   )48,      (unsigned short const   )48, 
        (unsigned short const   )48,      (unsigned short const   )48,      (unsigned short const   )48,      (unsigned short const   )48, 
        (unsigned short const   )48,      (unsigned short const   )48,      (unsigned short const   )48,      (unsigned short const   )48, 
        (unsigned short const   )276,      (unsigned short const   )276,      (unsigned short const   )276,      (unsigned short const   )276, 
        (unsigned short const   )276,      (unsigned short const   )276,      (unsigned short const   )276,      (unsigned short const   )276, 
        (unsigned short const   )276,      (unsigned short const   )276,      (unsigned short const   )48,      (unsigned short const   )48, 
        (unsigned short const   )48,      (unsigned short const   )48,      (unsigned short const   )48,      (unsigned short const   )48, 
        (unsigned short const   )48,      (unsigned short const   )912,      (unsigned short const   )912,      (unsigned short const   )912, 
        (unsigned short const   )912,      (unsigned short const   )912,      (unsigned short const   )912,      (unsigned short const   )656, 
        (unsigned short const   )656,      (unsigned short const   )656,      (unsigned short const   )656,      (unsigned short const   )656, 
        (unsigned short const   )656,      (unsigned short const   )656,      (unsigned short const   )656,      (unsigned short const   )656, 
        (unsigned short const   )656,      (unsigned short const   )656,      (unsigned short const   )656,      (unsigned short const   )656, 
        (unsigned short const   )656,      (unsigned short const   )656,      (unsigned short const   )656,      (unsigned short const   )656, 
        (unsigned short const   )656,      (unsigned short const   )656,      (unsigned short const   )656,      (unsigned short const   )48, 
        (unsigned short const   )48,      (unsigned short const   )48,      (unsigned short const   )48,      (unsigned short const   )560, 
        (unsigned short const   )48,      (unsigned short const   )792,      (unsigned short const   )792,      (unsigned short const   )792, 
        (unsigned short const   )792,      (unsigned short const   )792,      (unsigned short const   )792,      (unsigned short const   )536, 
        (unsigned short const   )536,      (unsigned short const   )536,      (unsigned short const   )536,      (unsigned short const   )536, 
        (unsigned short const   )536,      (unsigned short const   )536,      (unsigned short const   )536,      (unsigned short const   )536, 
        (unsigned short const   )536,      (unsigned short const   )536,      (unsigned short const   )536,      (unsigned short const   )536, 
        (unsigned short const   )536,      (unsigned short const   )536,      (unsigned short const   )536,      (unsigned short const   )536, 
        (unsigned short const   )536,      (unsigned short const   )536,      (unsigned short const   )536,      (unsigned short const   )48, 
        (unsigned short const   )48,      (unsigned short const   )48,      (unsigned short const   )48,      (unsigned short const   )2, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0};
#line 113 "safe-ctype.c"
unsigned char const   _sch_tolower[256]  = 
#line 113
  {      (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )3, 
        (unsigned char const   )4,      (unsigned char const   )5,      (unsigned char const   )6,      (unsigned char const   )7, 
        (unsigned char const   )8,      (unsigned char const   )9,      (unsigned char const   )10,      (unsigned char const   )11, 
        (unsigned char const   )12,      (unsigned char const   )13,      (unsigned char const   )14,      (unsigned char const   )15, 
        (unsigned char const   )16,      (unsigned char const   )17,      (unsigned char const   )18,      (unsigned char const   )19, 
        (unsigned char const   )20,      (unsigned char const   )21,      (unsigned char const   )22,      (unsigned char const   )23, 
        (unsigned char const   )24,      (unsigned char const   )25,      (unsigned char const   )26,      (unsigned char const   )27, 
        (unsigned char const   )28,      (unsigned char const   )29,      (unsigned char const   )30,      (unsigned char const   )31, 
        (unsigned char const   )32,      (unsigned char const   )33,      (unsigned char const   )34,      (unsigned char const   )35, 
        (unsigned char const   )36,      (unsigned char const   )37,      (unsigned char const   )38,      (unsigned char const   )39, 
        (unsigned char const   )40,      (unsigned char const   )41,      (unsigned char const   )42,      (unsigned char const   )43, 
        (unsigned char const   )44,      (unsigned char const   )45,      (unsigned char const   )46,      (unsigned char const   )47, 
        (unsigned char const   )48,      (unsigned char const   )49,      (unsigned char const   )50,      (unsigned char const   )51, 
        (unsigned char const   )52,      (unsigned char const   )53,      (unsigned char const   )54,      (unsigned char const   )55, 
        (unsigned char const   )56,      (unsigned char const   )57,      (unsigned char const   )58,      (unsigned char const   )59, 
        (unsigned char const   )60,      (unsigned char const   )61,      (unsigned char const   )62,      (unsigned char const   )63, 
        (unsigned char const   )64,      (unsigned char const   )'a',      (unsigned char const   )'b',      (unsigned char const   )'c', 
        (unsigned char const   )'d',      (unsigned char const   )'e',      (unsigned char const   )'f',      (unsigned char const   )'g', 
        (unsigned char const   )'h',      (unsigned char const   )'i',      (unsigned char const   )'j',      (unsigned char const   )'k', 
        (unsigned char const   )'l',      (unsigned char const   )'m',      (unsigned char const   )'n',      (unsigned char const   )'o', 
        (unsigned char const   )'p',      (unsigned char const   )'q',      (unsigned char const   )'r',      (unsigned char const   )'s', 
        (unsigned char const   )'t',      (unsigned char const   )'u',      (unsigned char const   )'v',      (unsigned char const   )'w', 
        (unsigned char const   )'x',      (unsigned char const   )'y',      (unsigned char const   )'z',      (unsigned char const   )91, 
        (unsigned char const   )92,      (unsigned char const   )93,      (unsigned char const   )94,      (unsigned char const   )95, 
        (unsigned char const   )96,      (unsigned char const   )'a',      (unsigned char const   )'b',      (unsigned char const   )'c', 
        (unsigned char const   )'d',      (unsigned char const   )'e',      (unsigned char const   )'f',      (unsigned char const   )'g', 
        (unsigned char const   )'h',      (unsigned char const   )'i',      (unsigned char const   )'j',      (unsigned char const   )'k', 
        (unsigned char const   )'l',      (unsigned char const   )'m',      (unsigned char const   )'n',      (unsigned char const   )'o', 
        (unsigned char const   )'p',      (unsigned char const   )'q',      (unsigned char const   )'r',      (unsigned char const   )'s', 
        (unsigned char const   )'t',      (unsigned char const   )'u',      (unsigned char const   )'v',      (unsigned char const   )'w', 
        (unsigned char const   )'x',      (unsigned char const   )'y',      (unsigned char const   )'z',      (unsigned char const   )123, 
        (unsigned char const   )124,      (unsigned char const   )125,      (unsigned char const   )126,      (unsigned char const   )127, 
        (unsigned char const   )128,      (unsigned char const   )129,      (unsigned char const   )130,      (unsigned char const   )131, 
        (unsigned char const   )132,      (unsigned char const   )133,      (unsigned char const   )134,      (unsigned char const   )135, 
        (unsigned char const   )136,      (unsigned char const   )137,      (unsigned char const   )138,      (unsigned char const   )139, 
        (unsigned char const   )140,      (unsigned char const   )141,      (unsigned char const   )142,      (unsigned char const   )143, 
        (unsigned char const   )144,      (unsigned char const   )145,      (unsigned char const   )146,      (unsigned char const   )147, 
        (unsigned char const   )148,      (unsigned char const   )149,      (unsigned char const   )150,      (unsigned char const   )151, 
        (unsigned char const   )152,      (unsigned char const   )153,      (unsigned char const   )154,      (unsigned char const   )155, 
        (unsigned char const   )156,      (unsigned char const   )157,      (unsigned char const   )158,      (unsigned char const   )159, 
        (unsigned char const   )160,      (unsigned char const   )161,      (unsigned char const   )162,      (unsigned char const   )163, 
        (unsigned char const   )164,      (unsigned char const   )165,      (unsigned char const   )166,      (unsigned char const   )167, 
        (unsigned char const   )168,      (unsigned char const   )169,      (unsigned char const   )170,      (unsigned char const   )171, 
        (unsigned char const   )172,      (unsigned char const   )173,      (unsigned char const   )174,      (unsigned char const   )175, 
        (unsigned char const   )176,      (unsigned char const   )177,      (unsigned char const   )178,      (unsigned char const   )179, 
        (unsigned char const   )180,      (unsigned char const   )181,      (unsigned char const   )182,      (unsigned char const   )183, 
        (unsigned char const   )184,      (unsigned char const   )185,      (unsigned char const   )186,      (unsigned char const   )187, 
        (unsigned char const   )188,      (unsigned char const   )189,      (unsigned char const   )190,      (unsigned char const   )191, 
        (unsigned char const   )192,      (unsigned char const   )193,      (unsigned char const   )194,      (unsigned char const   )195, 
        (unsigned char const   )196,      (unsigned char const   )197,      (unsigned char const   )198,      (unsigned char const   )199, 
        (unsigned char const   )200,      (unsigned char const   )201,      (unsigned char const   )202,      (unsigned char const   )203, 
        (unsigned char const   )204,      (unsigned char const   )205,      (unsigned char const   )206,      (unsigned char const   )207, 
        (unsigned char const   )208,      (unsigned char const   )209,      (unsigned char const   )210,      (unsigned char const   )211, 
        (unsigned char const   )212,      (unsigned char const   )213,      (unsigned char const   )214,      (unsigned char const   )215, 
        (unsigned char const   )216,      (unsigned char const   )217,      (unsigned char const   )218,      (unsigned char const   )219, 
        (unsigned char const   )220,      (unsigned char const   )221,      (unsigned char const   )222,      (unsigned char const   )223, 
        (unsigned char const   )224,      (unsigned char const   )225,      (unsigned char const   )226,      (unsigned char const   )227, 
        (unsigned char const   )228,      (unsigned char const   )229,      (unsigned char const   )230,      (unsigned char const   )231, 
        (unsigned char const   )232,      (unsigned char const   )233,      (unsigned char const   )234,      (unsigned char const   )235, 
        (unsigned char const   )236,      (unsigned char const   )237,      (unsigned char const   )238,      (unsigned char const   )239, 
        (unsigned char const   )240,      (unsigned char const   )241,      (unsigned char const   )242,      (unsigned char const   )243, 
        (unsigned char const   )244,      (unsigned char const   )245,      (unsigned char const   )246,      (unsigned char const   )247, 
        (unsigned char const   )248,      (unsigned char const   )249,      (unsigned char const   )250,      (unsigned char const   )251, 
        (unsigned char const   )252,      (unsigned char const   )253,      (unsigned char const   )254,      (unsigned char const   )255};
#line 142 "safe-ctype.c"
unsigned char const   _sch_toupper[256]  = 
#line 142
  {      (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )3, 
        (unsigned char const   )4,      (unsigned char const   )5,      (unsigned char const   )6,      (unsigned char const   )7, 
        (unsigned char const   )8,      (unsigned char const   )9,      (unsigned char const   )10,      (unsigned char const   )11, 
        (unsigned char const   )12,      (unsigned char const   )13,      (unsigned char const   )14,      (unsigned char const   )15, 
        (unsigned char const   )16,      (unsigned char const   )17,      (unsigned char const   )18,      (unsigned char const   )19, 
        (unsigned char const   )20,      (unsigned char const   )21,      (unsigned char const   )22,      (unsigned char const   )23, 
        (unsigned char const   )24,      (unsigned char const   )25,      (unsigned char const   )26,      (unsigned char const   )27, 
        (unsigned char const   )28,      (unsigned char const   )29,      (unsigned char const   )30,      (unsigned char const   )31, 
        (unsigned char const   )32,      (unsigned char const   )33,      (unsigned char const   )34,      (unsigned char const   )35, 
        (unsigned char const   )36,      (unsigned char const   )37,      (unsigned char const   )38,      (unsigned char const   )39, 
        (unsigned char const   )40,      (unsigned char const   )41,      (unsigned char const   )42,      (unsigned char const   )43, 
        (unsigned char const   )44,      (unsigned char const   )45,      (unsigned char const   )46,      (unsigned char const   )47, 
        (unsigned char const   )48,      (unsigned char const   )49,      (unsigned char const   )50,      (unsigned char const   )51, 
        (unsigned char const   )52,      (unsigned char const   )53,      (unsigned char const   )54,      (unsigned char const   )55, 
        (unsigned char const   )56,      (unsigned char const   )57,      (unsigned char const   )58,      (unsigned char const   )59, 
        (unsigned char const   )60,      (unsigned char const   )61,      (unsigned char const   )62,      (unsigned char const   )63, 
        (unsigned char const   )64,      (unsigned char const   )'A',      (unsigned char const   )'B',      (unsigned char const   )'C', 
        (unsigned char const   )'D',      (unsigned char const   )'E',      (unsigned char const   )'F',      (unsigned char const   )'G', 
        (unsigned char const   )'H',      (unsigned char const   )'I',      (unsigned char const   )'J',      (unsigned char const   )'K', 
        (unsigned char const   )'L',      (unsigned char const   )'M',      (unsigned char const   )'N',      (unsigned char const   )'O', 
        (unsigned char const   )'P',      (unsigned char const   )'Q',      (unsigned char const   )'R',      (unsigned char const   )'S', 
        (unsigned char const   )'T',      (unsigned char const   )'U',      (unsigned char const   )'V',      (unsigned char const   )'W', 
        (unsigned char const   )'X',      (unsigned char const   )'Y',      (unsigned char const   )'Z',      (unsigned char const   )91, 
        (unsigned char const   )92,      (unsigned char const   )93,      (unsigned char const   )94,      (unsigned char const   )95, 
        (unsigned char const   )96,      (unsigned char const   )'A',      (unsigned char const   )'B',      (unsigned char const   )'C', 
        (unsigned char const   )'D',      (unsigned char const   )'E',      (unsigned char const   )'F',      (unsigned char const   )'G', 
        (unsigned char const   )'H',      (unsigned char const   )'I',      (unsigned char const   )'J',      (unsigned char const   )'K', 
        (unsigned char const   )'L',      (unsigned char const   )'M',      (unsigned char const   )'N',      (unsigned char const   )'O', 
        (unsigned char const   )'P',      (unsigned char const   )'Q',      (unsigned char const   )'R',      (unsigned char const   )'S', 
        (unsigned char const   )'T',      (unsigned char const   )'U',      (unsigned char const   )'V',      (unsigned char const   )'W', 
        (unsigned char const   )'X',      (unsigned char const   )'Y',      (unsigned char const   )'Z',      (unsigned char const   )123, 
        (unsigned char const   )124,      (unsigned char const   )125,      (unsigned char const   )126,      (unsigned char const   )127, 
        (unsigned char const   )128,      (unsigned char const   )129,      (unsigned char const   )130,      (unsigned char const   )131, 
        (unsigned char const   )132,      (unsigned char const   )133,      (unsigned char const   )134,      (unsigned char const   )135, 
        (unsigned char const   )136,      (unsigned char const   )137,      (unsigned char const   )138,      (unsigned char const   )139, 
        (unsigned char const   )140,      (unsigned char const   )141,      (unsigned char const   )142,      (unsigned char const   )143, 
        (unsigned char const   )144,      (unsigned char const   )145,      (unsigned char const   )146,      (unsigned char const   )147, 
        (unsigned char const   )148,      (unsigned char const   )149,      (unsigned char const   )150,      (unsigned char const   )151, 
        (unsigned char const   )152,      (unsigned char const   )153,      (unsigned char const   )154,      (unsigned char const   )155, 
        (unsigned char const   )156,      (unsigned char const   )157,      (unsigned char const   )158,      (unsigned char const   )159, 
        (unsigned char const   )160,      (unsigned char const   )161,      (unsigned char const   )162,      (unsigned char const   )163, 
        (unsigned char const   )164,      (unsigned char const   )165,      (unsigned char const   )166,      (unsigned char const   )167, 
        (unsigned char const   )168,      (unsigned char const   )169,      (unsigned char const   )170,      (unsigned char const   )171, 
        (unsigned char const   )172,      (unsigned char const   )173,      (unsigned char const   )174,      (unsigned char const   )175, 
        (unsigned char const   )176,      (unsigned char const   )177,      (unsigned char const   )178,      (unsigned char const   )179, 
        (unsigned char const   )180,      (unsigned char const   )181,      (unsigned char const   )182,      (unsigned char const   )183, 
        (unsigned char const   )184,      (unsigned char const   )185,      (unsigned char const   )186,      (unsigned char const   )187, 
        (unsigned char const   )188,      (unsigned char const   )189,      (unsigned char const   )190,      (unsigned char const   )191, 
        (unsigned char const   )192,      (unsigned char const   )193,      (unsigned char const   )194,      (unsigned char const   )195, 
        (unsigned char const   )196,      (unsigned char const   )197,      (unsigned char const   )198,      (unsigned char const   )199, 
        (unsigned char const   )200,      (unsigned char const   )201,      (unsigned char const   )202,      (unsigned char const   )203, 
        (unsigned char const   )204,      (unsigned char const   )205,      (unsigned char const   )206,      (unsigned char const   )207, 
        (unsigned char const   )208,      (unsigned char const   )209,      (unsigned char const   )210,      (unsigned char const   )211, 
        (unsigned char const   )212,      (unsigned char const   )213,      (unsigned char const   )214,      (unsigned char const   )215, 
        (unsigned char const   )216,      (unsigned char const   )217,      (unsigned char const   )218,      (unsigned char const   )219, 
        (unsigned char const   )220,      (unsigned char const   )221,      (unsigned char const   )222,      (unsigned char const   )223, 
        (unsigned char const   )224,      (unsigned char const   )225,      (unsigned char const   )226,      (unsigned char const   )227, 
        (unsigned char const   )228,      (unsigned char const   )229,      (unsigned char const   )230,      (unsigned char const   )231, 
        (unsigned char const   )232,      (unsigned char const   )233,      (unsigned char const   )234,      (unsigned char const   )235, 
        (unsigned char const   )236,      (unsigned char const   )237,      (unsigned char const   )238,      (unsigned char const   )239, 
        (unsigned char const   )240,      (unsigned char const   )241,      (unsigned char const   )242,      (unsigned char const   )243, 
        (unsigned char const   )244,      (unsigned char const   )245,      (unsigned char const   )246,      (unsigned char const   )247, 
        (unsigned char const   )248,      (unsigned char const   )249,      (unsigned char const   )250,      (unsigned char const   )251, 
        (unsigned char const   )252,      (unsigned char const   )253,      (unsigned char const   )254,      (unsigned char const   )255};
#line 154 "/usr/include/stdio.h"
extern int rename(char const   *__old , char const   *__new ) ;
#line 211
extern int fflush(FILE *__stream ) ;
#line 609
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 626 "/usr/include/stdlib.h"
extern char *getenv(char const   *__name ) ;
#line 390 "/usr/include/unistd.h"
extern unsigned int sleep(unsigned int __seconds ) ;
#line 405
extern int usleep(__useconds_t __useconds ) ;
#line 85 "/usr/include/string.h"
extern char *strncpy(char * __restrict  __dest , char const   * __restrict  __src ,
                     size_t __n ) ;
#line 119 "wget.h"
void logputs(enum log_options o , char const   *s ) ;
#line 87 "rbuf.h"
int rbuf_flush(struct rbuf *rbuf , char *where , int maxsize ) ;
#line 35 "retr.h"
int get_contents(int fd , FILE *fp , long *len , long restval , long expected , struct rbuf *rbuf ,
                 int use_expected , double *elapsed ) ;
#line 38
uerr_t retrieve_url(char const   *origurl , char **file , char **newloc , char const   *refurl ,
                    int *dt ) ;
#line 40
uerr_t retrieve_from_file(char const   *file , int html , int *count ) ;
#line 42
char *retr_rate(long bytes , double msecs , int pad ) ;
#line 43
double calc_rate(long bytes , double msecs , int *units ) ;
#line 44
void printwhat(int n1 , int n2 ) ;
#line 46
void sleep_between_retrievals(int count ) ;
#line 48
void rotate_backups(char const   *fname ) ;
#line 54
uerr_t http_loop(struct url *u , char **newloc , char **local_file , char const   *referer ,
                 int *dt , struct url *proxy ) ;
#line 37 "progress.h"
void *progress_create(long initial , long total ) ;
#line 38
void progress_update(void *progress , long howmuch , double dltime ) ;
#line 39
void progress_finish(void *progress , double dltime ) ;
#line 36 "recur.h"
uerr_t retrieve_tree(char const   *start_url ) ;
#line 39
struct urlpos *get_urls_file(char const   *file ) ;
#line 40
struct urlpos *get_urls_html(char const   *file , char const   *url , int *meta_disallow_follow ) ;
#line 41
void free_urlpos(struct urlpos *l ) ;
#line 91 "host.h"
int sufmatch(char const   **list , char const   *what ) ;
#line 119 "ftp.h"
uerr_t ftp_loop(struct url *u , int *dt , struct url *proxy ) ;
#line 48 "connect.h"
int iread(int fd , char *buf___0 , int len ) ;
#line 94 "convert.h"
void register_download(char const   *url , char const   *file ) ;
#line 95
void register_redirection(char const   *from , char const   *to ) ;
#line 96
void register_html(char const   *url , char const   *file ) ;
#line 67 "retr.c"
int global_download_count  ;
#line 70 "retr.c"
LARGE_INT total_downloaded_bytes  ;
#line 73 "retr.c"
static struct __anonstruct_limit_data_53 limit_data  ;
#line 79 "retr.c"
static void limit_bandwidth_reset(void) 
{ 


  {
#line 82
  limit_data.chunk_bytes = 0L;
#line 83
  limit_data.chunk_start = (double )0;
#line 84
  return;
}
}
#line 90 "retr.c"
static void limit_bandwidth(long bytes , double *dltime , struct wget_timer *timer ) 
{ 
  double delta_t ;
  double expected ;
  double slp ;
  double t0 ;
  double t1 ;

  {
#line 93
  delta_t = *dltime - limit_data.chunk_start;
#line 96
  limit_data.chunk_bytes += bytes;
#line 101
  expected = (1000.0 * (double )limit_data.chunk_bytes) / (double )opt.limit_rate;
#line 103
  if (expected > delta_t) {
#line 105
    slp = (expected - delta_t) + limit_data.sleep_adjust;
#line 107
    if (slp < (double )200) {
      {
#line 109
      while (1) {
        while_continue: /* CIL Label */ ;
#line 109
        if (opt.debug) {
          {
#line 109
          debug_logprintf("deferring a %.2f ms sleep (%ld/%.2f).\n", slp, limit_data.chunk_bytes,
                          delta_t);
          }
        }
#line 109
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 111
      return;
    }
    {
#line 113
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 113
      if (opt.debug) {
        {
#line 113
        debug_logprintf("\nsleeping %.2f ms for %ld bytes, adjust %.2f ms\n", slp,
                        limit_data.chunk_bytes, limit_data.sleep_adjust);
        }
      }
#line 113
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 116
    t0 = *dltime;
#line 117
    usleep((__useconds_t )((unsigned long )((double )1000 * slp)));
#line 118
    t1 = wtimer_elapsed(timer);
#line 124
    limit_data.sleep_adjust = slp - (t1 - t0);
#line 128
    *dltime = t1;
    }
  }
#line 131
  limit_data.chunk_bytes = 0L;
#line 132
  limit_data.chunk_start = *dltime;
#line 133
  return;
}
}
#line 164 "retr.c"
static char dlbuf[16384]  ;
#line 158 "retr.c"
int get_contents(int fd , FILE *fp , long *len , long restval , long expected , struct rbuf *rbuf ,
                 int use_expected , double *elapsed ) 
{ 
  int res___0 ;
  int dlbufsize ;
  void *progress ;
  struct wget_timer *timer ;
  struct wget_timer *tmp ;
  double dltime ;
  int sz ;
  int tmp___0 ;
  int amount_to_read ;
  long tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;

  {
  {
#line 162
  res___0 = 0;
#line 165
  dlbufsize = (int )sizeof(dlbuf);
#line 167
  progress = (void *)0;
#line 168
  tmp = wtimer_allocate();
#line 168
  timer = tmp;
#line 169
  dltime = (double )0;
#line 171
  *len = restval;
  }
#line 173
  if (opt.verbose) {
    {
#line 174
    progress = progress_create(restval, expected);
    }
  }
#line 176
  if (rbuf) {
#line 176
    if (rbuf->fd == fd) {
#line 178
      sz = 0;
      {
#line 179
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 179
        res___0 = rbuf_flush(rbuf, dlbuf, (int )sizeof(dlbuf));
        }
#line 179
        if (! (res___0 != 0)) {
#line 179
          goto while_break;
        }
        {
#line 181
        fwrite((void const   */* __restrict  */)(dlbuf), (size_t )1, (size_t )res___0,
               (FILE */* __restrict  */)fp);
#line 182
        *len += (long )res___0;
#line 183
        sz += res___0;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 185
      if (sz) {
        {
#line 186
        fflush(fp);
        }
      }
      {
#line 187
      tmp___0 = ferror(fp);
      }
#line 187
      if (tmp___0) {
#line 189
        res___0 = -2;
#line 190
        goto out;
      }
#line 192
      if (progress) {
        {
#line 193
        progress_update(progress, (long )sz, (double )0);
        }
      }
    }
  }
#line 196
  if (opt.limit_rate) {
    {
#line 197
    limit_bandwidth_reset();
    }
  }
  {
#line 198
  wtimer_reset(timer);
  }
#line 204
  if (opt.limit_rate) {
#line 204
    if (opt.limit_rate < (long )dlbufsize) {
#line 205
      dlbufsize = (int )opt.limit_rate;
    }
  }
  {
#line 212
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 212
    if (! (! use_expected)) {
#line 212
      if (! (*len < expected)) {
#line 212
        goto while_break___0;
      }
    }
#line 214
    if (use_expected) {
#line 214
      if (expected - *len <= (long )dlbufsize) {
#line 214
        tmp___1 = expected - *len;
      } else {
#line 214
        tmp___1 = (long )dlbufsize;
      }
#line 214
      tmp___2 = tmp___1;
    } else {
#line 214
      tmp___2 = (long )dlbufsize;
    }
#line 214
    amount_to_read = (int )tmp___2;
#line 217
    if ((unsigned long )rbuf->ssl != (unsigned long )((void *)0)) {
      {
#line 218
      res___0 = ssl_iread(rbuf->ssl, dlbuf, amount_to_read);
      }
    } else {
      {
#line 221
      res___0 = iread(fd, dlbuf, amount_to_read);
      }
    }
#line 223
    if (res___0 <= 0) {
#line 224
      goto while_break___0;
    }
    {
#line 226
    fwrite((void const   */* __restrict  */)(dlbuf), (size_t )1, (size_t )res___0,
           (FILE */* __restrict  */)fp);
#line 231
    fflush(fp);
#line 232
    tmp___3 = ferror(fp);
    }
#line 232
    if (tmp___3) {
#line 234
      res___0 = -2;
#line 235
      goto out;
    }
    {
#line 238
    dltime = wtimer_elapsed(timer);
    }
#line 239
    if (opt.limit_rate) {
      {
#line 240
      limit_bandwidth((long )res___0, & dltime, timer);
      }
    }
#line 242
    *len += (long )res___0;
#line 243
    if (progress) {
      {
#line 244
      progress_update(progress, (long )res___0, dltime);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 250
  if (res___0 < -1) {
#line 251
    res___0 = -1;
  }
  out: 
#line 254
  if (progress) {
    {
#line 255
    progress_finish(progress, dltime);
    }
  }
#line 256
  if (elapsed) {
#line 257
    *elapsed = dltime;
  }
  {
#line 258
  wtimer_delete(timer);
  }
#line 260
  return (res___0);
}
}
#line 269 "retr.c"
static char res[20]  ;
#line 270 "retr.c"
static char *rate_names[4]  = {      (char *)"B/s",      (char *)"KB/s",      (char *)"MB/s",      (char *)"GB/s"};
#line 266 "retr.c"
char *retr_rate(long bytes , double msecs , int pad ) 
{ 
  int units ;
  double dlrate ;
  double tmp ;
  char const   *tmp___0 ;

  {
  {
#line 271
  units = 0;
#line 273
  tmp = calc_rate(bytes, msecs, & units);
#line 273
  dlrate = tmp;
  }
#line 274
  if (pad) {
#line 274
    tmp___0 = "%7.2f %s";
  } else {
#line 274
    tmp___0 = "%.2f %s";
  }
  {
#line 274
  sprintf((char */* __restrict  */)(res), (char const   */* __restrict  */)tmp___0,
          dlrate, rate_names[units]);
  }
#line 276
  return (res);
}
}
#line 286 "retr.c"
double calc_rate(long bytes , double msecs , int *units ) 
{ 
  double dlrate ;
  long tmp ;
  long tmp___0 ;

  {
  {
#line 291
  tmp = __builtin_expect((long )(! (! (msecs >= (double )0))), 1L);
  }
#line 291
  if (! tmp) {
    {
#line 291
    __assert_fail("msecs >= 0", "retr.c", 291U, "calc_rate");
    }
  }
  {
#line 292
  tmp___0 = __builtin_expect((long )(! (! (bytes >= 0L))), 1L);
  }
#line 292
  if (! tmp___0) {
    {
#line 292
    __assert_fail("bytes >= 0", "retr.c", 292U, "calc_rate");
    }
  }
#line 294
  if (msecs == (double )0) {
    {
#line 298
    msecs = wtimer_granularity();
    }
  }
#line 300
  dlrate = ((double )1000 * (double )bytes) / msecs;
#line 301
  if (dlrate < 1024.0) {
#line 302
    *units = 0;
  } else
#line 303
  if (dlrate < 1024.0 * 1024.0) {
#line 304
    *units = 1;
#line 304
    dlrate /= 1024.0;
  } else
#line 305
  if (dlrate < (1024.0 * 1024.0) * 1024.0) {
#line 306
    *units = 2;
#line 306
    dlrate /= 1024.0 * 1024.0;
  } else {
#line 309
    *units = 3;
#line 309
    dlrate /= (1024.0 * 1024.0) * 1024.0;
  }
#line 311
  return (dlrate);
}
}
#line 338
static char *getproxy(struct url *u ) ;
#line 346 "retr.c"
uerr_t retrieve_url(char const   *origurl , char **file , char **newloc , char const   *refurl ,
                    int *dt ) 
{ 
  uerr_t result ;
  char *url ;
  int location_changed ;
  int dummy ;
  char *mynewloc ;
  char *proxy ;
  struct url *u ;
  struct url *proxy_url ;
  int up_error_code ;
  char *local_file ;
  int redirection_count ;
  int post_data_suspended ;
  char *saved_post_data ;
  char *saved_post_file_name ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int oldrec ;
  int tmp___3 ;
  char *construced_newloc ;
  struct url *newloc_parsed ;
  long tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;

  {
#line 357
  redirection_count = 0;
#line 359
  post_data_suspended = 0;
#line 360
  saved_post_data = (char *)((void *)0);
#line 361
  saved_post_file_name = (char *)((void *)0);
#line 364
  if (! dt) {
#line 366
    dt = & dummy;
#line 367
    dummy = 0;
  }
  {
#line 369
  url = xstrdup_real(origurl);
  }
#line 370
  if (newloc) {
#line 371
    *newloc = (char *)((void *)0);
  }
#line 372
  if (file) {
#line 373
    *file = (char *)((void *)0);
  }
  {
#line 375
  u = url_parse((char const   *)url, & up_error_code);
  }
#line 376
  if (! u) {
    {
#line 378
    tmp = url_error(up_error_code);
#line 378
    logprintf((enum log_options )1, "%s: %s.\n", url, tmp);
#line 379
    free((void *)url);
    }
#line 380
    return ((uerr_t )27);
  }
#line 383
  if (! refurl) {
#line 384
    refurl = (char const   *)opt.referer;
  }
  redirected: 
  {
#line 388
  result = (uerr_t )0;
#line 389
  mynewloc = (char *)((void *)0);
#line 390
  local_file = (char *)((void *)0);
#line 391
  proxy_url = (struct url *)((void *)0);
#line 393
  proxy = getproxy(u);
  }
#line 394
  if (proxy) {
    {
#line 397
    proxy_url = url_parse((char const   *)proxy, & up_error_code);
    }
#line 398
    if (! proxy_url) {
      {
#line 400
      tmp___0 = url_error(up_error_code);
#line 400
      tmp___1 = gettext("Error parsing proxy URL %s: %s.\n");
#line 400
      logprintf((enum log_options )1, (char const   *)tmp___1, proxy, tmp___0);
#line 402
      free((void *)url);
      }
      {
#line 403
      while (1) {
        while_continue: /* CIL Label */ ;
#line 403
        if (post_data_suspended) {
#line 403
          opt.post_data = saved_post_data;
#line 403
          opt.post_file_name = saved_post_file_name;
#line 403
          post_data_suspended = 0;
        }
#line 403
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 404
      return ((uerr_t )52);
    }
#line 406
    if ((unsigned int )proxy_url->scheme != 0U) {
#line 406
      if ((unsigned int )proxy_url->scheme != (unsigned int )u->scheme) {
        {
#line 408
        tmp___2 = gettext("Error in proxy URL %s: Must be HTTP.\n");
#line 408
        logprintf((enum log_options )1, (char const   *)tmp___2, proxy);
#line 409
        url_free(proxy_url);
#line 410
        free((void *)url);
        }
        {
#line 411
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 411
          if (post_data_suspended) {
#line 411
            opt.post_data = saved_post_data;
#line 411
            opt.post_file_name = saved_post_file_name;
#line 411
            post_data_suspended = 0;
          }
#line 411
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 412
        return ((uerr_t )52);
      }
    }
  }
#line 416
  if ((unsigned int )u->scheme == 0U) {
    {
#line 422
    result = http_loop(u, & mynewloc, & local_file, refurl, dt, proxy_url);
    }
  } else
#line 416
  if ((unsigned int )u->scheme == 1U) {
    {
#line 422
    result = http_loop(u, & mynewloc, & local_file, refurl, dt, proxy_url);
    }
  } else
#line 416
  if (proxy_url) {
#line 416
    if ((unsigned int )proxy_url->scheme == 0U) {
      {
#line 422
      result = http_loop(u, & mynewloc, & local_file, refurl, dt, proxy_url);
      }
    } else {
#line 416
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 424
  if ((unsigned int )u->scheme == 2U) {
#line 429
    oldrec = opt.recursive;
#line 430
    if (redirection_count) {
#line 431
      opt.recursive = 0;
    }
    {
#line 432
    result = ftp_loop(u, dt, proxy_url);
#line 433
    opt.recursive = oldrec;
    }
#line 439
    if (redirection_count) {
#line 439
      if (local_file) {
#line 439
        if ((unsigned int )u->scheme == 2U) {
          {
#line 441
          tmp___3 = has_html_suffix_p((char const   *)local_file);
          }
#line 441
          if (tmp___3) {
#line 442
            *dt |= 1;
          }
        }
      }
    }
  }
#line 446
  if (proxy_url) {
    {
#line 448
    url_free(proxy_url);
#line 449
    proxy_url = (struct url *)((void *)0);
    }
  }
#line 452
  location_changed = (unsigned int )result == 6U;
#line 453
  if (location_changed) {
    {
#line 458
    tmp___4 = __builtin_expect((long )(! (! ((unsigned long )mynewloc != (unsigned long )((void *)0)))),
                               1L);
    }
#line 458
    if (! tmp___4) {
      {
#line 458
      __assert_fail("mynewloc != ((void *)0)", "retr.c", 458U, "retrieve_url");
      }
    }
#line 460
    if (local_file) {
      {
#line 461
      free((void *)local_file);
      }
    }
    {
#line 467
    construced_newloc = uri_merge((char const   *)url, (char const   *)mynewloc);
#line 468
    free((void *)mynewloc);
#line 469
    mynewloc = construced_newloc;
#line 472
    newloc_parsed = url_parse((char const   *)mynewloc, & up_error_code);
    }
#line 473
    if (! newloc_parsed) {
      {
#line 475
      tmp___5 = url_error(up_error_code);
#line 475
      logprintf((enum log_options )1, "%s: %s.\n", mynewloc, tmp___5);
#line 477
      url_free(u);
#line 478
      free((void *)url);
#line 479
      free((void *)mynewloc);
      }
      {
#line 480
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 480
        if (post_data_suspended) {
#line 480
          opt.post_data = saved_post_data;
#line 480
          opt.post_file_name = saved_post_file_name;
#line 480
          post_data_suspended = 0;
        }
#line 480
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 481
      return (result);
    }
    {
#line 487
    free((void *)mynewloc);
#line 488
    mynewloc = xstrdup_real((char const   *)newloc_parsed->url);
#line 491
    redirection_count ++;
    }
#line 491
    if (redirection_count > 20) {
      {
#line 493
      tmp___6 = gettext("%d redirections exceeded.\n");
#line 493
      logprintf((enum log_options )1, (char const   *)tmp___6, 20);
#line 495
      url_free(newloc_parsed);
#line 496
      url_free(u);
#line 497
      free((void *)url);
#line 498
      free((void *)mynewloc);
      }
      {
#line 499
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 499
        if (post_data_suspended) {
#line 499
          opt.post_data = saved_post_data;
#line 499
          opt.post_file_name = saved_post_file_name;
#line 499
          post_data_suspended = 0;
        }
#line 499
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 500
      return ((uerr_t )37);
    }
    {
#line 503
    free((void *)url);
#line 504
    url = mynewloc;
#line 505
    url_free(u);
#line 506
    u = newloc_parsed;
    }
#line 513
    if (! post_data_suspended) {
      {
#line 514
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 514
        post_data_suspended = 1;
#line 514
        saved_post_data = opt.post_data;
#line 514
        saved_post_file_name = opt.post_file_name;
#line 514
        opt.post_data = (char *)((void *)0);
#line 514
        opt.post_file_name = (char *)((void *)0);
#line 514
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 516
    goto redirected;
  }
#line 519
  if (local_file) {
#line 521
    if (*dt & 2) {
      {
#line 523
      register_download((char const   *)u->url, (char const   *)local_file);
      }
#line 524
      if (redirection_count) {
        {
#line 524
        tmp___7 = strcmp(origurl, (char const   *)u->url);
        }
#line 524
        if (0 != tmp___7) {
          {
#line 525
          register_redirection(origurl, (char const   *)u->url);
          }
        }
      }
#line 526
      if (*dt & 1) {
        {
#line 527
        register_html((char const   *)u->url, (char const   *)local_file);
        }
      }
    }
  }
#line 531
  if (file) {
#line 532
    if (local_file) {
#line 532
      *file = local_file;
    } else {
#line 532
      *file = (char *)((void *)0);
    }
  } else {
    {
#line 534
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 534
      if (local_file) {
        {
#line 534
        free((void *)local_file);
        }
      }
#line 534
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
  {
#line 536
  url_free(u);
  }
#line 538
  if (redirection_count) {
#line 540
    if (newloc) {
#line 541
      *newloc = url;
    } else {
      {
#line 543
      free((void *)url);
      }
    }
  } else {
#line 547
    if (newloc) {
#line 548
      *newloc = (char *)((void *)0);
    }
    {
#line 549
    free((void *)url);
    }
  }
#line 552
  global_download_count ++;
  {
#line 553
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 553
    if (post_data_suspended) {
#line 553
      opt.post_data = saved_post_data;
#line 553
      opt.post_file_name = saved_post_file_name;
#line 553
      post_data_suspended = 0;
    }
#line 553
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 555
  return (result);
}
}
#line 563 "retr.c"
uerr_t retrieve_from_file(char const   *file , int html , int *count ) 
{ 
  uerr_t status ;
  struct urlpos *url_list ;
  struct urlpos *cur_url ;
  struct urlpos *tmp ;
  struct urlpos *tmp___0 ;
  char *filename ;
  char *new_file ;
  int dt ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 569
  if (html) {
    {
#line 569
    tmp = get_urls_html(file, (char const   *)((void *)0), (int *)((void *)0));
#line 569
    url_list = tmp;
    }
  } else {
    {
#line 569
    tmp___0 = get_urls_file(file);
#line 569
    url_list = tmp___0;
    }
  }
#line 571
  status = (uerr_t )34;
#line 572
  *count = 0;
#line 574
  cur_url = url_list;
  {
#line 574
  while (1) {
    while_continue: /* CIL Label */ ;
#line 574
    if (! cur_url) {
#line 574
      goto while_break;
    }
#line 576
    filename = (char *)((void *)0);
#line 576
    new_file = (char *)((void *)0);
#line 579
    if (cur_url->ignore_when_downloading) {
#line 580
      goto __Cont;
    }
#line 582
    if (opt.quota) {
#line 582
      if (total_downloaded_bytes > opt.quota) {
#line 584
        status = (uerr_t )54;
#line 585
        goto while_break;
      }
    }
#line 587
    if (opt.recursive) {
#line 587
      if ((unsigned int )(cur_url->url)->scheme != 2U) {
        {
#line 588
        status = retrieve_tree((char const   *)(cur_url->url)->url);
        }
      } else {
        {
#line 590
        status = retrieve_url((char const   *)(cur_url->url)->url, & filename, & new_file,
                              (char const   *)((void *)0), & dt);
        }
      }
    } else {
      {
#line 590
      status = retrieve_url((char const   *)(cur_url->url)->url, & filename, & new_file,
                            (char const   *)((void *)0), & dt);
      }
    }
#line 592
    if (filename) {
#line 592
      if (opt.delete_after) {
        {
#line 592
        tmp___5 = file_exists_p((char const   *)filename);
        }
#line 592
        if (tmp___5) {
          {
#line 594
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 594
            if (opt.debug) {
              {
#line 594
              debug_logprintf("Removing file due to --delete-after in retrieve_from_file():\n");
              }
            }
#line 594
            goto while_break___0;
          }
          while_break___0: /* CIL Label */ ;
          }
          {
#line 596
          tmp___1 = gettext("Removing %s.\n");
#line 596
          logprintf((enum log_options )0, (char const   *)tmp___1, filename);
#line 597
          tmp___4 = unlink((char const   *)filename);
          }
#line 597
          if (tmp___4) {
            {
#line 598
            tmp___2 = __errno_location();
#line 598
            tmp___3 = strerror(*tmp___2);
#line 598
            logprintf((enum log_options )1, "unlink: %s\n", tmp___3);
            }
          }
#line 599
          dt &= -3;
        }
      }
    }
    {
#line 602
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 602
      if (new_file) {
        {
#line 602
        free((void *)new_file);
        }
      }
#line 602
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 603
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 603
      if (filename) {
        {
#line 603
        free((void *)filename);
        }
      }
#line 603
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 574
    cur_url = cur_url->next;
#line 574
    (*count) ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 607
  free_urlpos(url_list);
  }
#line 609
  return (status);
}
}
#line 614 "retr.c"
void printwhat(int n1 , int n2 ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 617
  if (n1 == n2) {
    {
#line 617
    tmp = gettext("Giving up.\n\n");
#line 617
    tmp___1 = tmp;
    }
  } else {
    {
#line 617
    tmp___0 = gettext("Retrying.\n\n");
#line 617
    tmp___1 = tmp___0;
    }
  }
  {
#line 617
  logputs((enum log_options )0, (char const   *)tmp___1);
  }
#line 618
  return;
}
}
#line 629 "retr.c"
static int first_retrieval  =    1;
#line 626 "retr.c"
void sleep_between_retrievals(int count ) 
{ 
  double waitsecs ;
  double tmp ;

  {
#line 631
  if (first_retrieval) {
#line 634
    first_retrieval = 0;
#line 635
    return;
  }
#line 638
  if (opt.waitretry) {
#line 638
    if (count > 1) {
#line 642
      if ((double )count <= opt.waitretry) {
        {
#line 643
        sleep((unsigned int )(count - 1));
        }
      } else {
        {
#line 645
        usleep((__useconds_t )((double )1000000L * opt.waitretry));
        }
      }
    } else {
#line 638
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 647
  if (opt.wait) {
#line 649
    if (! opt.random_wait) {
      {
#line 653
      usleep((__useconds_t )((double )1000000L * opt.wait));
      }
    } else
#line 649
    if (count > 1) {
      {
#line 653
      usleep((__useconds_t )((double )1000000L * opt.wait));
      }
    } else {
      {
#line 659
      tmp = random_float();
#line 659
      waitsecs = ((double )2 * opt.wait) * tmp;
      }
      {
#line 660
      while (1) {
        while_continue: /* CIL Label */ ;
#line 660
        if (opt.debug) {
          {
#line 660
          debug_logprintf("sleep_between_retrievals: avg=%f,sleep=%f\n", opt.wait,
                          waitsecs);
          }
        }
#line 660
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 662
      usleep((__useconds_t )((double )1000000L * waitsecs));
      }
    }
  }
#line 665
  return;
}
}
#line 668 "retr.c"
void free_urlpos(struct urlpos *l ) 
{ 
  struct urlpos *next ;

  {
  {
#line 671
  while (1) {
    while_continue: /* CIL Label */ ;
#line 671
    if (! l) {
#line 671
      goto while_break;
    }
#line 673
    next = l->next;
#line 674
    if (l->url) {
      {
#line 675
      url_free(l->url);
      }
    }
    {
#line 676
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 676
      if (l->local_name) {
        {
#line 676
        free((void *)l->local_name);
        }
      }
#line 676
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 677
    free((void *)l);
#line 678
    l = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 680
  return;
}
}
#line 683 "retr.c"
void rotate_backups(char const   *fname ) 
{ 
  int maxlen ;
  size_t tmp ;
  int tmp___0 ;
  char *from ;
  void *tmp___1 ;
  char *to ;
  void *tmp___2 ;
  struct stat sb ;
  int i ;
  int tmp___3 ;

  {
  {
#line 686
  tmp = strlen(fname);
#line 686
  tmp___0 = numdigit((long )opt.backups);
#line 686
  maxlen = (int )(((tmp + 1U) + (size_t )tmp___0) + 1U);
#line 687
  tmp___1 = __builtin_alloca((unsigned long )maxlen);
#line 687
  from = (char *)tmp___1;
#line 688
  tmp___2 = __builtin_alloca((unsigned long )maxlen);
#line 688
  to = (char *)tmp___2;
#line 692
  tmp___3 = stat((char const   */* __restrict  */)fname, (struct stat */* __restrict  */)(& sb));
  }
#line 692
  if (tmp___3 == 0) {
#line 693
    if (((sb.st_mode & 61440U) == 32768U) == 0) {
#line 694
      return;
    }
  }
#line 696
  i = opt.backups;
  {
#line 696
  while (1) {
    while_continue: /* CIL Label */ ;
#line 696
    if (! (i > 1)) {
#line 696
      goto while_break;
    }
    {
#line 698
    sprintf((char */* __restrict  */)from, (char const   */* __restrict  */)"%s.%d",
            fname, i - 1);
#line 699
    sprintf((char */* __restrict  */)to, (char const   */* __restrict  */)"%s.%d",
            fname, i);
#line 700
    rename((char const   *)from, (char const   *)to);
#line 696
    i --;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 703
  sprintf((char */* __restrict  */)to, (char const   */* __restrict  */)"%s.%d", fname,
          1);
#line 704
  rename(fname, (char const   *)to);
  }
#line 705
  return;
}
}
#line 707
static int no_proxy_match(char const   *host , char const   **no_proxy ) ;
#line 716 "retr.c"
static char rewritten_storage[1024]  ;
#line 711 "retr.c"
static char *getproxy(struct url *u ) 
{ 
  char *proxy ;
  char *rewritten_url ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 714
  proxy = (char *)((void *)0);
#line 718
  if (! opt.use_proxy) {
#line 719
    return ((char *)((void *)0));
  }
  {
#line 720
  tmp = no_proxy_match((char const   *)u->host, (char const   **)opt.no_proxy);
  }
#line 720
  if (! tmp) {
#line 721
    return ((char *)((void *)0));
  }
  {
#line 725
  if ((unsigned int )u->scheme == 0U) {
#line 725
    goto case_0;
  }
#line 729
  if ((unsigned int )u->scheme == 1U) {
#line 729
    goto case_1;
  }
#line 733
  if ((unsigned int )u->scheme == 2U) {
#line 733
    goto case_2;
  }
#line 736
  if ((unsigned int )u->scheme == 3U) {
#line 736
    goto case_3;
  }
#line 723
  goto switch_break;
  case_0: /* CIL Label */ 
#line 726
  if (opt.http_proxy) {
#line 726
    proxy = opt.http_proxy;
  } else {
    {
#line 726
    tmp___0 = getenv("http_proxy");
#line 726
    proxy = tmp___0;
    }
  }
#line 727
  goto switch_break;
  case_1: /* CIL Label */ 
#line 730
  if (opt.https_proxy) {
#line 730
    proxy = opt.https_proxy;
  } else {
    {
#line 730
    tmp___1 = getenv("https_proxy");
#line 730
    proxy = tmp___1;
    }
  }
#line 731
  goto switch_break;
  case_2: /* CIL Label */ 
#line 734
  if (opt.ftp_proxy) {
#line 734
    proxy = opt.ftp_proxy;
  } else {
    {
#line 734
    tmp___2 = getenv("ftp_proxy");
#line 734
    proxy = tmp___2;
    }
  }
#line 735
  goto switch_break;
  case_3: /* CIL Label */ 
#line 737
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 739
  if (! proxy) {
#line 740
    return ((char *)((void *)0));
  } else
#line 739
  if (! *proxy) {
#line 740
    return ((char *)((void *)0));
  }
  {
#line 744
  rewritten_url = rewrite_shorthand_url((char const   *)proxy);
  }
#line 745
  if (rewritten_url) {
    {
#line 747
    strncpy((char */* __restrict  */)(rewritten_storage), (char const   */* __restrict  */)rewritten_url,
            (size_t )sizeof(rewritten_storage));
#line 748
    rewritten_storage[sizeof(rewritten_storage) - 1UL] = (char )'\000';
#line 749
    proxy = rewritten_storage;
    }
  }
#line 752
  return (proxy);
}
}
#line 756 "retr.c"
static int no_proxy_match(char const   *host , char const   **no_proxy ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 759
  if (! no_proxy) {
#line 760
    return (1);
  } else {
    {
#line 762
    tmp = sufmatch(no_proxy, host);
    }
#line 762
    if (tmp) {
#line 762
      tmp___0 = 0;
    } else {
#line 762
      tmp___0 = 1;
    }
#line 762
    return (tmp___0);
  }
}
}
#line 53 "hash.h"
void *hash_table_get(struct hash_table  const  *ht , void const   *key ) ;
#line 54
int hash_table_get_pair(struct hash_table  const  *ht , void const   *lookup_key ,
                        void *orig_key , void *value ) ;
#line 70
struct hash_table *make_nocase_string_hash_table(int items ) ;
#line 35 "res.h"
struct robot_specs *res_parse(char const   *source , int length ) ;
#line 36
struct robot_specs *res_parse_from_file(char const   *filename ) ;
#line 38
int res_match_path(struct robot_specs  const  *specs , char const   *path ) ;
#line 40
void res_register_specs(char const   *host , int port , struct robot_specs *specs ) ;
#line 41
struct robot_specs *res_get_specs(char const   *host , int port ) ;
#line 43
int res_retrieve_file(char const   *url , char **file ) ;
#line 45
void res_cleanup(void) ;
#line 109 "res.c"
static void match_user_agent(char const   *agent , int length , int *matches___0 ,
                             int *exact_match ) 
{ 
  int tmp ;

  {
#line 113
  if (length == 1) {
#line 113
    if ((int const   )*agent == 42) {
#line 115
      *matches___0 = 1;
#line 116
      *exact_match = 0;
    } else {
#line 113
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 118
  if ((unsigned long )((agent + length) - agent) == sizeof("wget") - 1UL) {
    {
#line 118
    tmp = strncasecmp(agent, "wget", (size_t )(sizeof("wget") - 1UL));
    }
#line 118
    if (tmp) {
#line 125
      *matches___0 = 0;
#line 126
      *exact_match = 0;
    } else {
#line 120
      *matches___0 = 1;
#line 121
      *exact_match = 1;
    }
  } else {
#line 125
    *matches___0 = 0;
#line 126
    *exact_match = 0;
  }
#line 128
  return;
}
}
#line 133 "res.c"
static void add_path(struct robot_specs *specs , char const   *path_b , char const   *path_e ,
                     int allowedp , int exactp ) 
{ 
  struct path_info pp ;
  void *tmp ;

  {
#line 138
  if ((unsigned long )path_b < (unsigned long )path_e) {
#line 138
    if ((int const   )*path_b == 47) {
#line 141
      path_b ++;
    }
  }
  {
#line 142
  pp.path = strdupdelim(path_b, path_e);
#line 143
  pp.allowedp = allowedp;
#line 144
  pp.user_agent_exact_p = exactp;
#line 145
  (specs->count) ++;
  }
#line 146
  if (specs->count > specs->size) {
#line 148
    if (specs->size == 0) {
#line 149
      specs->size = 1;
    } else {
#line 151
      specs->size <<= 1;
    }
    {
#line 152
    tmp = xrealloc_real((void *)specs->paths, (size_t )((unsigned long )specs->size * sizeof(struct path_info )));
#line 152
    specs->paths = (struct path_info *)tmp;
    }
  }
#line 155
  *(specs->paths + (specs->count - 1)) = pp;
#line 156
  return;
}
}
#line 161 "res.c"
static void prune_non_exact(struct robot_specs *specs ) 
{ 
  struct path_info *newpaths ;
  int i ;
  int j ;
  int cnt ;
  void *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 166
  cnt = 0;
#line 167
  i = 0;
  {
#line 167
  while (1) {
    while_continue: /* CIL Label */ ;
#line 167
    if (! (i < specs->count)) {
#line 167
      goto while_break;
    }
#line 168
    if ((specs->paths + i)->user_agent_exact_p) {
#line 169
      cnt ++;
    }
#line 167
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 170
  tmp = xmalloc_real((size_t )((unsigned long )cnt * sizeof(struct path_info )));
#line 170
  newpaths = (struct path_info *)tmp;
#line 171
  i = 0;
#line 171
  j = 0;
  }
  {
#line 171
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 171
    if (! (i < specs->count)) {
#line 171
      goto while_break___0;
    }
#line 172
    if ((specs->paths + i)->user_agent_exact_p) {
#line 173
      tmp___0 = j;
#line 173
      j ++;
#line 173
      *(newpaths + tmp___0) = *(specs->paths + i);
    }
#line 171
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 174
  tmp___1 = __builtin_expect((long )(! (! (j == cnt))), 1L);
  }
#line 174
  if (! tmp___1) {
    {
#line 174
    __assert_fail("j == cnt", "res.c", 174U, "prune_non_exact");
    }
  }
  {
#line 175
  free((void *)specs->paths);
#line 176
  specs->paths = newpaths;
#line 177
  specs->count = cnt;
#line 178
  specs->size = cnt;
  }
#line 179
  return;
}
}
#line 221 "res.c"
struct robot_specs *res_parse(char const   *source , int length ) 
{ 
  int line_count ;
  char const   *p ;
  char const   *end ;
  int user_agent_applies ;
  int user_agent_exact ;
  int found_exact ;
  int record_count ;
  struct robot_specs *specs ;
  void *tmp ;
  char const   *lineend ;
  char const   *lineend_real ;
  char const   *field_b ;
  char const   *field_e ;
  char const   *value_b ;
  char const   *value_e ;
  void *tmp___0 ;
  long tmp___1 ;
  int allowed ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;

  {
  {
#line 224
  line_count = 1;
#line 226
  p = source;
#line 227
  end = source + length;
#line 230
  user_agent_applies = 0;
#line 234
  user_agent_exact = 0;
#line 237
  found_exact = 0;
#line 241
  record_count = 0;
#line 243
  tmp = xmalloc_real((size_t )sizeof(struct robot_specs ));
#line 243
  specs = (struct robot_specs *)tmp;
#line 244
  memset((void *)specs, '\000', (size_t )sizeof(struct robot_specs ));
  }
  {
#line 246
  while (1) {
    while_continue: /* CIL Label */ ;
#line 252
    if ((unsigned long )p == (unsigned long )end) {
#line 253
      goto while_break;
    }
    {
#line 254
    tmp___0 = memchr((void const   *)p, '\n', (size_t )(end - p));
#line 254
    lineend_real = (char const   *)tmp___0;
    }
#line 255
    if (lineend_real) {
#line 256
      lineend_real ++;
    } else {
#line 258
      lineend_real = end;
    }
#line 259
    lineend = lineend_real;
    {
#line 263
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 263
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 263
        if (! ((unsigned long )p >= (unsigned long )lineend)) {
#line 263
          if (! ((int const   )_sch_istable[(int const   )*p & 255] & 64)) {
#line 263
            goto while_break___1;
          }
        } else {
#line 263
          goto while_break___1;
        }
#line 263
        p ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 263
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 264
    if ((unsigned long )p >= (unsigned long )lineend) {
#line 265
      goto next;
    } else
#line 264
    if ((int const   )*p == 35) {
#line 265
      goto next;
    }
#line 270
    lineend = p;
    {
#line 270
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 270
      if (! ((unsigned long )lineend < (unsigned long )lineend_real)) {
#line 270
        goto while_break___2;
      }
#line 271
      if ((unsigned long )lineend == (unsigned long )p) {
#line 271
        goto _L;
      } else
#line 271
      if ((int const   )_sch_istable[(int const   )*(lineend - 1) & 255] & 64) {
        _L: /* CIL Label */ 
#line 271
        if ((int const   )*lineend == 35) {
#line 273
          goto while_break___2;
        }
      }
#line 270
      lineend ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 276
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 276
      if ((unsigned long )lineend > (unsigned long )p) {
#line 276
        if (! ((int const   )_sch_istable[(int const   )*(lineend - 1) & 255] & 64)) {
#line 276
          goto while_break___3;
        }
      } else {
#line 276
        goto while_break___3;
      }
#line 277
      lineend --;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 279
    tmp___1 = __builtin_expect((long )(! (! (! ((unsigned long )p >= (unsigned long )lineend)))),
                               1L);
    }
#line 279
    if (! tmp___1) {
      {
#line 279
      __assert_fail("!((p) >= lineend)", "res.c", 279U, "res_parse");
      }
    }
#line 281
    field_b = p;
    {
#line 282
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 282
      if (! ((unsigned long )p >= (unsigned long )lineend)) {
#line 282
        if (! ((int const   )_sch_istable[(int const   )*p & 255] & 140)) {
#line 282
          if (! ((int const   )*p == 45)) {
#line 282
            goto while_break___4;
          }
        }
      } else {
#line 282
        goto while_break___4;
      }
#line 283
      p ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 284
    field_e = p;
    {
#line 286
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 286
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 286
        if (! ((unsigned long )p >= (unsigned long )lineend)) {
#line 286
          if (! ((int const   )_sch_istable[(int const   )*p & 255] & 64)) {
#line 286
            goto while_break___6;
          }
        } else {
#line 286
          goto while_break___6;
        }
#line 286
        p ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 286
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 287
    if ((unsigned long )field_b == (unsigned long )field_e) {
#line 287
      goto _L___0;
    } else
#line 287
    if ((unsigned long )p >= (unsigned long )lineend) {
#line 287
      goto _L___0;
    } else
#line 287
    if ((int const   )*p != 58) {
      _L___0: /* CIL Label */ 
      {
#line 289
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 289
        if (opt.debug) {
          {
#line 289
          debug_logprintf("Ignoring malformed line %d", line_count);
          }
        }
#line 289
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 290
      goto next;
    }
#line 292
    p ++;
    {
#line 293
    while (1) {
      while_continue___8: /* CIL Label */ ;
      {
#line 293
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 293
        if (! ((unsigned long )p >= (unsigned long )lineend)) {
#line 293
          if (! ((int const   )_sch_istable[(int const   )*p & 255] & 64)) {
#line 293
            goto while_break___9;
          }
        } else {
#line 293
          goto while_break___9;
        }
#line 293
        p ++;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 293
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 295
    value_b = p;
    {
#line 296
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 296
      if (! (! ((unsigned long )p >= (unsigned long )lineend))) {
#line 296
        goto while_break___10;
      }
#line 297
      p ++;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 298
    value_e = p;
#line 301
    if ((unsigned long )(field_e - field_b) == sizeof("user-agent") - 1UL) {
      {
#line 301
      tmp___4 = strncasecmp(field_b, "user-agent", (size_t )(sizeof("user-agent") - 1UL));
      }
#line 301
      if (tmp___4) {
#line 301
        goto _L___3;
      } else {
#line 328
        if (record_count != 0) {
          {
#line 329
          match_user_agent(value_b, (int )(value_e - value_b), & user_agent_applies,
                           & user_agent_exact);
          }
        } else
#line 328
        if (user_agent_applies == 0) {
          {
#line 329
          match_user_agent(value_b, (int )(value_e - value_b), & user_agent_applies,
                           & user_agent_exact);
          }
        }
#line 331
        if (user_agent_exact) {
#line 332
          found_exact = 1;
        }
#line 333
        record_count = 0;
      }
    } else
    _L___3: /* CIL Label */ 
#line 335
    if ((unsigned long )(field_e - field_b) == sizeof("allow") - 1UL) {
      {
#line 335
      tmp___3 = strncasecmp(field_b, "allow", (size_t )(sizeof("allow") - 1UL));
      }
#line 335
      if (tmp___3) {
#line 335
        goto _L___2;
      } else {
#line 337
        if (user_agent_applies) {
          {
#line 339
          add_path(specs, value_b, value_e, 1, user_agent_exact);
          }
        }
#line 341
        record_count ++;
      }
    } else
    _L___2: /* CIL Label */ 
#line 343
    if ((unsigned long )(field_e - field_b) == sizeof("disallow") - 1UL) {
      {
#line 343
      tmp___2 = strncasecmp(field_b, "disallow", (size_t )(sizeof("disallow") - 1UL));
      }
#line 343
      if (tmp___2) {
#line 343
        goto _L___1;
      } else {
#line 345
        if (user_agent_applies) {
#line 347
          allowed = 0;
#line 348
          if ((unsigned long )value_b == (unsigned long )value_e) {
#line 351
            allowed = 1;
          }
          {
#line 352
          add_path(specs, value_b, value_e, allowed, user_agent_exact);
          }
        }
#line 354
        record_count ++;
      }
    } else {
      _L___1: /* CIL Label */ 
      {
#line 358
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 358
        if (opt.debug) {
          {
#line 358
          debug_logprintf("Ignoring unknown field at line %d", line_count);
          }
        }
#line 358
        goto while_break___11;
      }
      while_break___11: /* CIL Label */ ;
      }
#line 359
      goto next;
    }
    next: 
#line 363
    p = lineend_real;
#line 364
    line_count ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 367
  if (found_exact) {
    {
#line 371
    prune_non_exact(specs);
    }
  } else
#line 373
  if (specs->size > specs->count) {
    {
#line 377
    tmp___5 = xrealloc_real((void *)specs->paths, (size_t )((unsigned long )specs->count * sizeof(struct path_info )));
#line 377
    specs->paths = (struct path_info *)tmp___5;
#line 379
    specs->size = specs->count;
    }
  }
#line 382
  return (specs);
}
}
#line 388 "res.c"
struct robot_specs *res_parse_from_file(char const   *filename ) 
{ 
  struct robot_specs *specs ;
  struct file_memory *fm ;
  struct file_memory *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 392
  tmp = read_file(filename);
#line 392
  fm = tmp;
  }
#line 393
  if (! fm) {
    {
#line 395
    tmp___0 = __errno_location();
#line 395
    tmp___1 = strerror(*tmp___0);
#line 395
    logprintf((enum log_options )1, "Cannot open %s: %s", filename, tmp___1);
    }
#line 397
    return ((struct robot_specs *)((void *)0));
  }
  {
#line 399
  specs = res_parse((char const   *)fm->content, (int )fm->length);
#line 400
  read_file_free(fm);
  }
#line 401
  return (specs);
}
}
#line 404 "res.c"
static void free_specs(struct robot_specs *specs ) 
{ 
  int i ;

  {
#line 408
  i = 0;
  {
#line 408
  while (1) {
    while_continue: /* CIL Label */ ;
#line 408
    if (! (i < specs->count)) {
#line 408
      goto while_break;
    }
    {
#line 409
    free((void *)(specs->paths + i)->path);
#line 408
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 410
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 410
    if (specs->paths) {
      {
#line 410
      free((void *)specs->paths);
      }
    }
#line 410
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 411
  free((void *)specs);
  }
#line 412
  return;
}
}
#line 436 "res.c"
static int matches(char const   *record_path , char const   *url_path ) 
{ 
  char const   *rp ;
  char const   *up ;
  char rc ;
  char uc ;
  char decoded ;
  int tmp ;
  int tmp___0 ;
  char decoded___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 439
  rp = record_path;
#line 440
  up = url_path;
  {
#line 442
  while (1) {
    while_continue: /* CIL Label */ ;
#line 444
    rc = (char )*rp;
#line 445
    uc = (char )*up;
#line 446
    if (! rc) {
#line 447
      return (1);
    }
#line 448
    if (! uc) {
#line 449
      return (0);
    }
    {
#line 450
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 450
      if ((int )rc == 37) {
#line 450
        if ((int const   )_sch_istable[(int const   )*(rp + 1) & 255] & 256) {
#line 450
          if ((int const   )_sch_istable[(int const   )*(rp + 2) & 255] & 256) {
#line 450
            if ((int const   )*(rp + 1) < 65) {
#line 450
              tmp = (int const   )*(rp + 1) - 48;
            } else {
#line 450
              tmp = ((int const   )_sch_toupper[(int const   )*(rp + 1) & 255] - 65) + 10;
            }
#line 450
            if ((int const   )*(rp + 2) < 65) {
#line 450
              tmp___0 = (int const   )*(rp + 2) - 48;
            } else {
#line 450
              tmp___0 = ((int const   )_sch_toupper[(int const   )*(rp + 2) & 255] - 65) + 10;
            }
#line 450
            decoded = (char )((tmp << 4) + tmp___0);
#line 450
            if ((int )decoded != 47) {
#line 450
              rc = decoded;
#line 450
              rp += 2;
            }
          }
        }
      }
#line 450
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 451
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 451
      if ((int )uc == 37) {
#line 451
        if ((int const   )_sch_istable[(int const   )*(up + 1) & 255] & 256) {
#line 451
          if ((int const   )_sch_istable[(int const   )*(up + 2) & 255] & 256) {
#line 451
            if ((int const   )*(up + 1) < 65) {
#line 451
              tmp___1 = (int const   )*(up + 1) - 48;
            } else {
#line 451
              tmp___1 = ((int const   )_sch_toupper[(int const   )*(up + 1) & 255] - 65) + 10;
            }
#line 451
            if ((int const   )*(up + 2) < 65) {
#line 451
              tmp___2 = (int const   )*(up + 2) - 48;
            } else {
#line 451
              tmp___2 = ((int const   )_sch_toupper[(int const   )*(up + 2) & 255] - 65) + 10;
            }
#line 451
            decoded___0 = (char )((tmp___1 << 4) + tmp___2);
#line 451
            if ((int )decoded___0 != 47) {
#line 451
              uc = decoded___0;
#line 451
              up += 2;
            }
          }
        }
      }
#line 451
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 452
    if ((int )rc != (int )uc) {
#line 453
      return (0);
    }
#line 442
    rp ++;
#line 442
    up ++;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 461 "res.c"
int res_match_path(struct robot_specs  const  *specs , char const   *path ) 
{ 
  int i ;
  int allowedp ;
  char const   *tmp ;
  int tmp___0 ;

  {
#line 465
  if (! specs) {
#line 466
    return (1);
  }
#line 467
  i = 0;
  {
#line 467
  while (1) {
    while_continue: /* CIL Label */ ;
#line 467
    if (! (i < (int )specs->count)) {
#line 467
      goto while_break;
    }
    {
#line 468
    tmp___0 = matches((char const   *)(specs->paths + i)->path, path);
    }
#line 468
    if (tmp___0) {
#line 470
      allowedp = (specs->paths + i)->allowedp;
      {
#line 471
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 471
        if (opt.debug) {
#line 471
          if (allowedp) {
#line 471
            tmp = "Allowing";
          } else {
#line 471
            tmp = "Rejecting";
          }
          {
#line 471
          debug_logprintf("%s path %s because of rule `%s\'.\n", tmp, path, (specs->paths + i)->path);
          }
        }
#line 471
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 474
      return (allowedp);
    }
#line 467
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 476
  return (1);
}
}
#line 481 "res.c"
static struct hash_table *registered_specs  ;
#line 495 "res.c"
void res_register_specs(char const   *host , int port , struct robot_specs *specs ) 
{ 
  struct robot_specs *old ;
  char *hp ;
  char *hp_old ;
  int HP_len ;
  size_t tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 500
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 500
    tmp = strlen(host);
#line 500
    HP_len = (int )tmp;
#line 500
    tmp___0 = numdigit((long )port);
#line 500
    tmp___1 = __builtin_alloca((unsigned long )(((HP_len + 1) + tmp___0) + 1));
#line 500
    hp = (char *)tmp___1;
#line 500
    memcpy((void */* __restrict  */)hp, (void const   */* __restrict  */)host, (size_t )HP_len);
#line 500
    *(hp + HP_len) = (char )':';
#line 500
    number_to_string((hp + HP_len) + 1, (long )port);
    }
#line 500
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 502
  if (! registered_specs) {
    {
#line 503
    registered_specs = make_nocase_string_hash_table(0);
    }
  }
  {
#line 506
  old = (struct robot_specs *)((void *)0);
#line 507
  hp_old = (char *)((void *)0);
#line 509
  tmp___3 = hash_table_get_pair((struct hash_table  const  *)registered_specs, (void const   *)hp,
                                (void *)hp_old, (void *)old);
  }
#line 509
  if (tmp___3) {
#line 511
    if (old) {
      {
#line 512
      free_specs(old);
      }
    }
    {
#line 513
    hash_table_put(registered_specs, (void const   *)hp_old, (void *)specs);
    }
  } else {
    {
#line 517
    tmp___2 = xstrdup_real((char const   *)hp);
#line 517
    hash_table_put(registered_specs, (void const   *)tmp___2, (void *)specs);
    }
  }
#line 519
  return;
}
}
#line 523 "res.c"
struct robot_specs *res_get_specs(char const   *host , int port ) 
{ 
  char *hp ;
  int HP_len ;
  size_t tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 527
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 527
    tmp = strlen(host);
#line 527
    HP_len = (int )tmp;
#line 527
    tmp___0 = numdigit((long )port);
#line 527
    tmp___1 = __builtin_alloca((unsigned long )(((HP_len + 1) + tmp___0) + 1));
#line 527
    hp = (char *)tmp___1;
#line 527
    memcpy((void */* __restrict  */)hp, (void const   */* __restrict  */)host, (size_t )HP_len);
#line 527
    *(hp + HP_len) = (char )':';
#line 527
    number_to_string((hp + HP_len) + 1, (long )port);
    }
#line 527
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 528
  if (! registered_specs) {
#line 529
    return ((struct robot_specs *)((void *)0));
  }
  {
#line 530
  tmp___2 = hash_table_get((struct hash_table  const  *)registered_specs, (void const   *)hp);
  }
#line 530
  return ((struct robot_specs *)tmp___2);
}
}
#line 543 "res.c"
int res_retrieve_file(char const   *url , char **file ) 
{ 
  uerr_t err ;
  char *robots_url ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 547
  tmp = uri_merge(url, "/robots.txt");
#line 547
  robots_url = tmp;
#line 549
  tmp___0 = gettext("Loading robots.txt; please ignore errors.\n");
#line 549
  logputs((enum log_options )0, (char const   *)tmp___0);
#line 550
  *file = (char *)((void *)0);
#line 551
  err = retrieve_url((char const   *)robots_url, file, (char **)((void *)0), (char const   *)((void *)0),
                     (int *)((void *)0));
#line 552
  free((void *)robots_url);
  }
#line 554
  if ((unsigned int )err != 34U) {
#line 554
    if ((unsigned long )*file != (unsigned long )((void *)0)) {
      {
#line 559
      free((void *)*file);
#line 560
      *file = (char *)((void *)0);
      }
    }
  }
#line 562
  return ((unsigned int )err == 34U);
}
}
#line 565 "res.c"
static int cleanup_hash_table_mapper(void *key , void *value , void *arg_ignored ) 
{ 


  {
  {
#line 568
  free(key);
#line 569
  free_specs((struct robot_specs *)value);
  }
#line 570
  return (0);
}
}
#line 573 "res.c"
void res_cleanup(void) 
{ 


  {
#line 576
  if (registered_specs) {
    {
#line 578
    hash_table_map(registered_specs, & cleanup_hash_table_mapper, (void *)0);
#line 579
    hash_table_destroy(registered_specs);
#line 580
    registered_specs = (struct hash_table *)((void *)0);
    }
  }
#line 582
  return;
}
}
#line 90 "host.h"
int accept_domain(struct url *u ) ;
#line 69 "hash.h"
struct hash_table *make_string_hash_table(int items ) ;
#line 97 "convert.h"
void register_delete_file(char const   *file ) ;
#line 64 "recur.c"
struct hash_table *dl_url_file_map ;
#line 65
struct hash_table *downloaded_html_set ;
#line 87 "recur.c"
static struct url_queue *url_queue_new(void) 
{ 
  struct url_queue *queue ;
  void *tmp ;

  {
  {
#line 90
  tmp = xmalloc_real((size_t )sizeof(*queue));
#line 90
  queue = (struct url_queue *)tmp;
#line 91
  memset((void *)queue, '\000', (size_t )sizeof(*queue));
  }
#line 92
  return (queue);
}
}
#line 97 "recur.c"
static void url_queue_delete(struct url_queue *queue ) 
{ 


  {
  {
#line 100
  free((void *)queue);
  }
#line 101
  return;
}
}
#line 107 "recur.c"
static void url_enqueue(struct url_queue *queue , char const   *url , char const   *referer ,
                        int depth___0 , int html_allowed ) 
{ 
  struct queue_element *qel ;
  void *tmp ;

  {
  {
#line 111
  tmp = xmalloc_real((size_t )sizeof(*qel));
#line 111
  qel = (struct queue_element *)tmp;
#line 112
  qel->url = url;
#line 113
  qel->referer = referer;
#line 114
  qel->depth = depth___0;
#line 115
  qel->html_allowed = (unsigned int )html_allowed;
#line 116
  qel->next = (struct queue_element *)((void *)0);
#line 118
  (queue->count) ++;
  }
#line 119
  if (queue->count > queue->maxcount) {
#line 120
    queue->maxcount = queue->count;
  }
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;
#line 122
    if (opt.debug) {
      {
#line 122
      debug_logprintf("Enqueuing %s at depth %d\n", url, depth___0);
      }
    }
#line 122
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 123
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 123
    if (opt.debug) {
      {
#line 123
      debug_logprintf("Queue count %d, maxcount %d.\n", queue->count, queue->maxcount);
      }
    }
#line 123
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 125
  if (queue->tail) {
#line 126
    (queue->tail)->next = qel;
  }
#line 127
  queue->tail = qel;
#line 129
  if (! queue->head) {
#line 130
    queue->head = queue->tail;
  }
#line 131
  return;
}
}
#line 136 "recur.c"
static int url_dequeue(struct url_queue *queue , char const   **url , char const   **referer ,
                       int *depth___0 , int *html_allowed ) 
{ 
  struct queue_element *qel ;

  {
#line 141
  qel = queue->head;
#line 143
  if (! qel) {
#line 144
    return (0);
  }
#line 146
  queue->head = (queue->head)->next;
#line 147
  if (! queue->head) {
#line 148
    queue->tail = (struct queue_element *)((void *)0);
  }
#line 150
  *url = qel->url;
#line 151
  *referer = qel->referer;
#line 152
  *depth___0 = qel->depth;
#line 153
  *html_allowed = (int )qel->html_allowed;
#line 155
  (queue->count) --;
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;
#line 157
    if (opt.debug) {
      {
#line 157
      debug_logprintf("Dequeuing %s at depth %d\n", qel->url, qel->depth);
      }
    }
#line 157
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 158
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 158
    if (opt.debug) {
      {
#line 158
      debug_logprintf("Queue count %d, maxcount %d.\n", queue->count, queue->maxcount);
      }
    }
#line 158
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 160
  free((void *)qel);
  }
#line 161
  return (1);
}
}
#line 164
static int download_child_p(struct urlpos  const  *upos , struct url *parent , int depth___0 ,
                            struct url *start_url_parsed , struct hash_table *blacklist ) ;
#line 166
static int descend_redirect_p(char const   *redirected , char const   *original ,
                              int depth___0 , struct url *start_url_parsed , struct hash_table *blacklist ) ;
#line 191 "recur.c"
uerr_t retrieve_tree(char const   *start_url ) 
{ 
  uerr_t status ;
  struct url_queue *queue ;
  struct hash_table *blacklist ;
  int up_error_code ;
  struct url *start_url_parsed ;
  struct url *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  int descend ;
  char *url ;
  char *referer ;
  char *file ;
  int depth___0 ;
  int html_allowed ;
  boolean dash_p_leaf_HTML ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int dt ;
  char *redirected ;
  int oldrec ;
  int tmp___5 ;
  int tmp___6 ;
  int meta_disallow_follow ;
  struct urlpos *children ;
  struct urlpos *tmp___7 ;
  struct urlpos *child ;
  struct url *url_parsed ;
  long tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char const   *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  int *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  char *d1 ;
  char *d2 ;
  int d3 ;
  int d4 ;
  int tmp___20 ;

  {
  {
#line 194
  status = (uerr_t )34;
#line 204
  tmp = url_parse(start_url, & up_error_code);
#line 204
  start_url_parsed = tmp;
  }
#line 206
  if (! start_url_parsed) {
    {
#line 208
    tmp___0 = url_error(up_error_code);
#line 208
    logprintf((enum log_options )1, "%s: %s.\n", start_url, tmp___0);
    }
#line 210
    return ((uerr_t )27);
  }
  {
#line 213
  queue = url_queue_new();
#line 214
  blacklist = make_string_hash_table(0);
#line 218
  tmp___1 = xstrdup_real((char const   *)start_url_parsed->url);
#line 218
  url_enqueue(queue, (char const   *)tmp___1, (char const   *)((void *)0), 0, 1);
#line 219
  string_set_add(blacklist, (char const   *)start_url_parsed->url);
  }
  {
#line 221
  while (1) {
    while_continue: /* CIL Label */ ;
#line 223
    descend = 0;
#line 224
    file = (char *)((void *)0);
#line 226
    dash_p_leaf_HTML = (boolean )0;
#line 228
    if (opt.quota) {
#line 228
      if (total_downloaded_bytes > opt.quota) {
#line 229
        goto while_break;
      }
    }
#line 230
    if ((unsigned int )status == 29U) {
#line 231
      goto while_break;
    }
    {
#line 235
    tmp___2 = url_dequeue(queue, (char const   **)(& url), (char const   **)(& referer),
                          & depth___0, & html_allowed);
    }
#line 235
    if (! tmp___2) {
#line 238
      goto while_break;
    }
#line 248
    if (dl_url_file_map) {
      {
#line 248
      tmp___6 = hash_table_contains((struct hash_table  const  *)dl_url_file_map,
                                    (void const   *)url);
      }
#line 248
      if (tmp___6) {
        {
#line 250
        tmp___3 = hash_table_get((struct hash_table  const  *)dl_url_file_map, (void const   *)url);
#line 250
        file = xstrdup_real((char const   *)tmp___3);
        }
        {
#line 252
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 252
          if (opt.debug) {
            {
#line 252
            debug_logprintf("Already downloaded \"%s\", reusing it from \"%s\".\n",
                            url, file);
            }
          }
#line 252
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 255
        if (html_allowed) {
#line 255
          if (downloaded_html_set) {
            {
#line 255
            tmp___4 = string_set_contains(downloaded_html_set, (char const   *)file);
            }
#line 255
            if (tmp___4) {
#line 258
              descend = 1;
            }
          }
        }
      } else {
#line 248
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 262
      dt = 0;
#line 263
      redirected = (char *)((void *)0);
#line 264
      oldrec = opt.recursive;
#line 266
      opt.recursive = 0;
#line 267
      status = retrieve_url((char const   *)url, & file, & redirected, (char const   *)referer,
                            & dt);
#line 268
      opt.recursive = oldrec;
      }
#line 270
      if (html_allowed) {
#line 270
        if (file) {
#line 270
          if ((unsigned int )status == 34U) {
#line 270
            if (dt & 2) {
#line 270
              if (dt & 1) {
#line 272
                descend = 1;
              }
            }
          }
        }
      }
#line 274
      if (redirected) {
#line 279
        if (descend) {
          {
#line 281
          tmp___5 = descend_redirect_p((char const   *)redirected, (char const   *)url,
                                       depth___0, start_url_parsed, blacklist);
          }
#line 281
          if (tmp___5) {
            {
#line 287
            string_set_add(blacklist, (char const   *)url);
            }
          } else {
#line 283
            descend = 0;
          }
        }
        {
#line 290
        free((void *)url);
#line 291
        url = redirected;
        }
      }
    }
#line 295
    if (descend) {
#line 295
      if (depth___0 >= opt.reclevel) {
#line 295
        if (opt.reclevel != -1) {
#line 298
          if (opt.page_requisites) {
#line 298
            if (depth___0 == opt.reclevel) {
#line 308
              dash_p_leaf_HTML = (boolean )1;
            } else
#line 298
            if (depth___0 == opt.reclevel + 1) {
#line 308
              dash_p_leaf_HTML = (boolean )1;
            } else {
#line 298
              goto _L___0;
            }
          } else {
            _L___0: /* CIL Label */ 
            {
#line 315
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 315
              if (opt.debug) {
                {
#line 315
                debug_logprintf("Not descending further; at depth %d, max. %d.\n",
                                depth___0, opt.reclevel);
                }
              }
#line 315
              goto while_break___1;
            }
            while_break___1: /* CIL Label */ ;
            }
#line 317
            descend = 0;
          }
        }
      }
    }
#line 324
    if (descend) {
      {
#line 326
      meta_disallow_follow = 0;
#line 327
      tmp___7 = get_urls_html((char const   *)file, (char const   *)url, & meta_disallow_follow);
#line 327
      children = tmp___7;
      }
#line 330
      if (opt.use_robots) {
#line 330
        if (meta_disallow_follow) {
          {
#line 332
          free_urlpos(children);
#line 333
          children = (struct urlpos *)((void *)0);
          }
        }
      }
#line 336
      if (children) {
        {
#line 338
        child = children;
#line 339
        url_parsed = url_parse((char const   *)url, (int *)((void *)0));
#line 339
        url_parsed = url_parsed;
#line 340
        tmp___8 = __builtin_expect((long )(! (! ((unsigned long )url_parsed != (unsigned long )((void *)0)))),
                                   1L);
        }
#line 340
        if (! tmp___8) {
          {
#line 340
          __assert_fail("url_parsed != ((void *)0)", "recur.c", 340U, "retrieve_tree");
          }
        }
        {
#line 342
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 342
          if (! child) {
#line 342
            goto while_break___2;
          }
#line 344
          if (child->ignore_when_downloading) {
#line 345
            goto __Cont;
          }
#line 346
          if (dash_p_leaf_HTML) {
#line 346
            if (! child->link_inline_p) {
#line 347
              goto __Cont;
            }
          }
          {
#line 348
          tmp___11 = download_child_p((struct urlpos  const  *)child, url_parsed,
                                      depth___0, start_url_parsed, blacklist);
          }
#line 348
          if (tmp___11) {
            {
#line 351
            tmp___9 = xstrdup_real((char const   *)url);
#line 351
            tmp___10 = xstrdup_real((char const   *)(child->url)->url);
#line 351
            url_enqueue(queue, (char const   *)tmp___10, (char const   *)tmp___9,
                        depth___0 + 1, (int )child->link_expect_html);
#line 357
            string_set_add(blacklist, (char const   *)(child->url)->url);
            }
          }
          __Cont: /* CIL Label */ 
#line 342
          child = child->next;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 361
        url_free(url_parsed);
#line 362
        free_urlpos(children);
        }
      }
    }
#line 366
    if (opt.delete_after) {
#line 366
      goto _L___1;
    } else
#line 366
    if (file) {
      {
#line 366
      tmp___19 = acceptable((char const   *)file);
      }
#line 366
      if (! tmp___19) {
        _L___1: /* CIL Label */ 
        {
#line 372
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 372
          if (opt.debug) {
#line 372
            if (opt.delete_after) {
#line 372
              tmp___12 = "--delete-after";
            } else {
#line 372
              tmp___12 = "recursive rejection criteria";
            }
            {
#line 372
            debug_logprintf("Removing file due to %s in recursive_retrieve():\n",
                            tmp___12);
            }
          }
#line 372
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 375
        if (opt.delete_after) {
          {
#line 375
          tmp___13 = gettext("Removing %s.\n");
#line 375
          tmp___15 = tmp___13;
          }
        } else {
          {
#line 375
          tmp___14 = gettext("Removing %s since it should be rejected.\n");
#line 375
          tmp___15 = tmp___14;
          }
        }
        {
#line 375
        logprintf((enum log_options )0, (char const   *)tmp___15, file);
#line 380
        tmp___18 = unlink((char const   *)file);
        }
#line 380
        if (tmp___18) {
          {
#line 381
          tmp___16 = __errno_location();
#line 381
          tmp___17 = strerror(*tmp___16);
#line 381
          logprintf((enum log_options )1, "unlink: %s\n", tmp___17);
          }
        }
        {
#line 382
        register_delete_file((char const   *)file);
        }
      }
    }
    {
#line 385
    free((void *)url);
    }
    {
#line 386
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 386
      if (referer) {
        {
#line 386
        free((void *)referer);
        }
      }
#line 386
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 387
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 387
      if (file) {
        {
#line 387
        free((void *)file);
        }
      }
#line 387
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 395
  while (1) {
    while_continue___6: /* CIL Label */ ;
    {
#line 395
    tmp___20 = url_dequeue(queue, (char const   **)(& d1), (char const   **)(& d2),
                           & d3, & d4);
    }
#line 395
    if (! tmp___20) {
#line 395
      goto while_break___6;
    }
    {
#line 398
    free((void *)d1);
    }
    {
#line 399
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 399
      if (d2) {
        {
#line 399
        free((void *)d2);
        }
      }
#line 399
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 402
  url_queue_delete(queue);
  }
#line 404
  if (start_url_parsed) {
    {
#line 405
    url_free(start_url_parsed);
    }
  }
  {
#line 406
  string_set_free(blacklist);
  }
#line 408
  if (opt.quota) {
#line 408
    if (total_downloaded_bytes > opt.quota) {
#line 409
      return ((uerr_t )54);
    } else {
#line 408
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 410
  if ((unsigned int )status == 29U) {
#line 411
    return ((uerr_t )29);
  } else {
#line 413
    return ((uerr_t )34);
  }
}
}
#line 424 "recur.c"
static int download_child_p(struct urlpos  const  *upos , struct url *parent , int depth___0 ,
                            struct url *start_url_parsed , struct hash_table *blacklist ) 
{ 
  struct url *u ;
  char const   *url ;
  int u_scheme_like_http ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  struct robot_specs *specs ;
  struct robot_specs *tmp___9 ;
  char *rfile ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 428
  u = (struct url *)upos->url;
#line 429
  url = (char const   *)u->url;
  {
#line 432
  while (1) {
    while_continue: /* CIL Label */ ;
#line 432
    if (opt.debug) {
      {
#line 432
      debug_logprintf("Deciding whether to enqueue \"%s\".\n", url);
      }
    }
#line 432
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 434
  tmp = string_set_contains(blacklist, url);
  }
#line 434
  if (tmp) {
    {
#line 436
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 436
      if (opt.debug) {
        {
#line 436
        debug_logprintf("Already on the black list.\n");
        }
      }
#line 436
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 437
    goto out;
  }
  {
#line 462
  u_scheme_like_http = schemes_are_similar_p(u->scheme, (enum url_scheme )0);
  }
#line 465
  if (! u_scheme_like_http) {
#line 465
    if ((unsigned int )u->scheme == 2U) {
#line 465
      if (! opt.follow_ftp) {
#line 465
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 467
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 467
        if (opt.debug) {
          {
#line 467
          debug_logprintf("Not following non-HTTP schemes.\n");
          }
        }
#line 467
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 468
      goto out;
    }
  }
#line 473
  if (u_scheme_like_http) {
#line 474
    if (opt.relative_only) {
#line 474
      if (! upos->link_relative_p) {
        {
#line 476
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 476
          if (opt.debug) {
            {
#line 476
            debug_logprintf("It doesn\'t really look like a relative link.\n");
            }
          }
#line 476
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 477
        goto out;
      }
    }
  }
  {
#line 482
  tmp___0 = accept_domain(u);
  }
#line 482
  if (! tmp___0) {
    {
#line 484
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 484
      if (opt.debug) {
        {
#line 484
        debug_logprintf("The domain was not accepted.\n");
        }
      }
#line 484
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 485
    goto out;
  }
#line 493
  if (opt.no_parent) {
    {
#line 493
    tmp___2 = schemes_are_similar_p(u->scheme, start_url_parsed->scheme);
    }
#line 493
    if (tmp___2) {
      {
#line 493
      tmp___3 = strcasecmp((char const   *)u->host, (char const   *)start_url_parsed->host);
      }
#line 493
      if (0 == tmp___3) {
#line 493
        if (u->port == start_url_parsed->port) {
#line 493
          if (opt.page_requisites) {
#line 493
            if (! upos->link_inline_p) {
#line 493
              goto _L___0;
            }
          } else {
            _L___0: /* CIL Label */ 
            {
#line 499
            tmp___1 = frontcmp((char const   *)start_url_parsed->dir, (char const   *)u->dir);
            }
#line 499
            if (! tmp___1) {
              {
#line 501
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 501
                if (opt.debug) {
                  {
#line 501
                  debug_logprintf("Going to \"%s\" would escape \"%s\" with no_parent on.\n",
                                  u->dir, start_url_parsed->dir);
                  }
                }
#line 501
                goto while_break___4;
              }
              while_break___4: /* CIL Label */ ;
              }
#line 503
              goto out;
            }
          }
        }
      }
    }
  }
#line 510
  if (opt.includes) {
#line 510
    goto _L___1;
  } else
#line 510
  if (opt.excludes) {
    _L___1: /* CIL Label */ 
    {
#line 512
    tmp___4 = accdir((char const   *)u->dir, (enum accd )1);
    }
#line 512
    if (! tmp___4) {
      {
#line 514
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 514
        if (opt.debug) {
          {
#line 514
          debug_logprintf("%s (%s) is excluded/not-included.\n", url, u->dir);
          }
        }
#line 514
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 515
      goto out;
    }
  }
#line 523
  if ((int )*(u->file + 0) != 0) {
    {
#line 523
    tmp___6 = has_html_suffix_p((char const   *)u->file);
    }
#line 523
    if (tmp___6) {
#line 523
      if (depth___0 != -1) {
#line 523
        if (! (depth___0 < opt.reclevel - 1)) {
#line 523
          goto _L___3;
        }
      } else {
#line 523
        goto _L___3;
      }
    } else {
      _L___3: /* CIL Label */ 
      {
#line 528
      tmp___5 = acceptable((char const   *)u->file);
      }
#line 528
      if (! tmp___5) {
        {
#line 530
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 530
          if (opt.debug) {
            {
#line 530
            debug_logprintf("%s (%s) does not match acc/rej rules.\n", url, u->file);
            }
          }
#line 530
          goto while_break___6;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 532
        goto out;
      }
    }
  }
  {
#line 537
  tmp___8 = schemes_are_similar_p(u->scheme, parent->scheme);
  }
#line 537
  if (tmp___8) {
#line 538
    if (! opt.spanhost) {
      {
#line 538
      tmp___7 = strcasecmp((char const   *)parent->host, (char const   *)u->host);
      }
#line 538
      if (0 != tmp___7) {
        {
#line 540
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 540
          if (opt.debug) {
            {
#line 540
            debug_logprintf("This is not the same hostname as the parent\'s (%s and %s).\n",
                            u->host, parent->host);
            }
          }
#line 540
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 542
        goto out;
      }
    }
  }
#line 546
  if (opt.use_robots) {
#line 546
    if (u_scheme_like_http) {
      {
#line 548
      tmp___9 = res_get_specs((char const   *)u->host, u->port);
#line 548
      specs = tmp___9;
      }
#line 549
      if (! specs) {
        {
#line 552
        tmp___10 = res_retrieve_file(url, & rfile);
        }
#line 552
        if (tmp___10) {
          {
#line 554
          specs = res_parse_from_file((char const   *)rfile);
#line 555
          free((void *)rfile);
          }
        } else {
          {
#line 562
          specs = res_parse("", 0);
          }
        }
        {
#line 564
        res_register_specs((char const   *)u->host, u->port, specs);
        }
      }
      {
#line 569
      tmp___11 = res_match_path((struct robot_specs  const  *)specs, (char const   *)u->path);
      }
#line 569
      if (! tmp___11) {
        {
#line 571
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 571
          if (opt.debug) {
            {
#line 571
            debug_logprintf("Not following %s because robots.txt forbids it.\n", url);
            }
          }
#line 571
          goto while_break___8;
        }
        while_break___8: /* CIL Label */ ;
        }
        {
#line 572
        string_set_add(blacklist, url);
        }
#line 573
        goto out;
      }
    }
  }
  {
#line 579
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 579
    if (opt.debug) {
      {
#line 579
      debug_logprintf("Decided to load it.\n");
      }
    }
#line 579
    goto while_break___9;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 581
  return (1);
  out: 
  {
#line 584
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 584
    if (opt.debug) {
      {
#line 584
      debug_logprintf("Decided NOT to load it.\n");
      }
    }
#line 584
    goto while_break___10;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 586
  return (0);
}
}
#line 594 "recur.c"
static int descend_redirect_p(char const   *redirected , char const   *original ,
                              int depth___0 , struct url *start_url_parsed , struct hash_table *blacklist ) 
{ 
  struct url *orig_parsed ;
  struct url *new_parsed ;
  struct urlpos *upos ;
  int success ;
  long tmp ;
  long tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 602
  orig_parsed = url_parse(original, (int *)((void *)0));
#line 603
  tmp = __builtin_expect((long )(! (! ((unsigned long )orig_parsed != (unsigned long )((void *)0)))),
                         1L);
  }
#line 603
  if (! tmp) {
    {
#line 603
    __assert_fail("orig_parsed != ((void *)0)", "recur.c", 603U, "descend_redirect_p");
    }
  }
  {
#line 605
  new_parsed = url_parse(redirected, (int *)((void *)0));
#line 606
  tmp___0 = __builtin_expect((long )(! (! ((unsigned long )new_parsed != (unsigned long )((void *)0)))),
                             1L);
  }
#line 606
  if (! tmp___0) {
    {
#line 606
    __assert_fail("new_parsed != ((void *)0)", "recur.c", 606U, "descend_redirect_p");
    }
  }
  {
#line 608
  tmp___1 = xmalloc_real((size_t )sizeof(struct urlpos ));
#line 608
  upos = (struct urlpos *)tmp___1;
#line 609
  memset((void *)upos, 0, (size_t )sizeof(*upos));
#line 610
  upos->url = new_parsed;
#line 612
  success = download_child_p((struct urlpos  const  *)upos, orig_parsed, depth___0,
                             start_url_parsed, blacklist);
#line 615
  url_free(orig_parsed);
#line 616
  url_free(new_parsed);
#line 617
  free((void *)upos);
  }
#line 619
  if (! success) {
    {
#line 620
    while (1) {
      while_continue: /* CIL Label */ ;
#line 620
      if (opt.debug) {
        {
#line 620
        debug_logprintf("Redirection \"%s\" failed the test.\n", redirected);
        }
      }
#line 620
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 622
  return (success);
}
}
#line 82 "rbuf.h"
void rbuf_initialize(struct rbuf *rbuf , int fd ) ;
#line 83
int rbuf_initialized_p(struct rbuf *rbuf ) ;
#line 84
void rbuf_uninitialize(struct rbuf *rbuf ) ;
#line 86
int rbuf_peek(struct rbuf *rbuf , char *store ) ;
#line 88
void rbuf_discard(struct rbuf *rbuf ) ;
#line 91
int rbuf_read_bufferful(struct rbuf *rbuf ) ;
#line 55 "rbuf.c"
void rbuf_initialize(struct rbuf *rbuf , int fd ) 
{ 


  {
#line 58
  rbuf->fd = fd;
#line 61
  rbuf->ssl = (SSL *)((void *)0);
#line 63
  rbuf->buffer_pos = rbuf->buffer;
#line 64
  rbuf->buffer_left = (size_t )0;
#line 65
  return;
}
}
#line 67 "rbuf.c"
int rbuf_initialized_p(struct rbuf *rbuf ) 
{ 


  {
#line 70
  return (rbuf->fd != -1);
}
}
#line 73 "rbuf.c"
void rbuf_uninitialize(struct rbuf *rbuf ) 
{ 


  {
#line 76
  rbuf->fd = -1;
#line 77
  return;
}
}
#line 79 "rbuf.c"
int rbuf_read_bufferful(struct rbuf *rbuf ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 83
  if (rbuf->ssl) {
    {
#line 84
    tmp = ssl_iread(rbuf->ssl, rbuf->buffer, (int )sizeof(rbuf->buffer));
    }
#line 84
    return (tmp);
  } else {
    {
#line 87
    tmp___0 = iread(rbuf->fd, rbuf->buffer, (int )sizeof(rbuf->buffer));
    }
#line 87
    return (tmp___0);
  }
}
}
#line 101 "rbuf.c"
int rbuf_peek(struct rbuf *rbuf , char *store ) 
{ 
  int res___0 ;

  {
#line 104
  if (! rbuf->buffer_left) {
#line 107
    rbuf->buffer_pos = rbuf->buffer;
#line 108
    rbuf->buffer_left = (size_t )0;
#line 110
    if ((unsigned long )rbuf->ssl != (unsigned long )((void *)0)) {
      {
#line 111
      res___0 = ssl_iread(rbuf->ssl, rbuf->buffer, (int )sizeof(rbuf->buffer));
      }
    } else {
      {
#line 114
      res___0 = iread(rbuf->fd, rbuf->buffer, (int )sizeof(rbuf->buffer));
      }
    }
#line 118
    if (res___0 <= 0) {
#line 119
      return (res___0);
    }
#line 120
    rbuf->buffer_left = (size_t )res___0;
  }
#line 122
  *store = *(rbuf->buffer_pos);
#line 123
  return (1);
}
}
#line 129 "rbuf.c"
int rbuf_flush(struct rbuf *rbuf , char *where , int maxsize ) 
{ 
  int howmuch ;
  size_t tmp ;

  {
#line 132
  if (! rbuf->buffer_left) {
#line 133
    return (0);
  } else {
#line 136
    if (rbuf->buffer_left < (size_t )maxsize) {
#line 136
      tmp = rbuf->buffer_left;
    } else {
#line 136
      tmp = (size_t )maxsize;
    }
#line 136
    howmuch = (int )tmp;
#line 138
    if (where) {
      {
#line 139
      memcpy((void */* __restrict  */)where, (void const   */* __restrict  */)rbuf->buffer_pos,
             (size_t )howmuch);
      }
    }
#line 140
    rbuf->buffer_left -= (size_t )howmuch;
#line 141
    rbuf->buffer_pos += howmuch;
#line 142
    return (howmuch);
  }
}
}
#line 147 "rbuf.c"
void rbuf_discard(struct rbuf *rbuf ) 
{ 


  {
#line 150
  rbuf->buffer_left = (size_t )0;
#line 151
  rbuf->buffer_pos = rbuf->buffer;
#line 152
  return;
}
}
#line 321 "/usr/include/stdio.h"
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 594 "/usr/include/stdlib.h"
extern  __attribute__((__noreturn__)) void abort(void) ;
#line 99 "/usr/include/string.h"
extern int strncmp(char const   *__s1 , char const   *__s2 , size_t __n )  __attribute__((__pure__)) ;
#line 711 "/usr/include/unistd.h"
extern int isatty(int __fd ) ;
#line 121 "wget.h"
void log_set_flush(int flush ) ;
#line 33 "progress.h"
int valid_progress_implementation_p(char const   *name ) ;
#line 34
void set_progress_implementation(char const   *name ) ;
#line 35
void progress_schedule_redirect(void) ;
#line 41
void progress_handle_sigwinch(int sig ) ;
#line 62 "progress.c"
static void *dot_create(long initial , long total ) ;
#line 63
static void dot_update(void *progress , long howmuch , double dltime ) ;
#line 64
static void dot_finish(void *progress , double dltime ) ;
#line 65
static void dot_set_params(char const   *params ) ;
#line 67
static void *bar_create(long initial , long total ) ;
#line 68
static void bar_update(void *progress , long howmuch , double dltime ) ;
#line 69
static void bar_finish(void *progress , double dltime ) ;
#line 70
static void bar_set_params(char const   *params ) ;
#line 72 "progress.c"
static struct progress_implementation implementations[2]  = {      {(char *)"dot", & dot_create, & dot_update, & dot_finish, & dot_set_params}, 
        {(char *)"bar", & bar_create, & bar_update, & bar_finish, & bar_set_params}};
#line 76 "progress.c"
static struct progress_implementation *current_impl  ;
#line 77 "progress.c"
static int current_impl_locked  ;
#line 95 "progress.c"
int valid_progress_implementation_p(char const   *name ) 
{ 
  int i ;
  struct progress_implementation *pi ;
  char *colon ;
  char *tmp ;
  int namelen ;
  size_t tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;

  {
  {
#line 98
  i = 0;
#line 99
  pi = implementations;
#line 100
  tmp = strchr(name, ':');
#line 100
  colon = tmp;
  }
#line 101
  if (colon) {
#line 101
    tmp___1 = colon - (char *)name;
  } else {
    {
#line 101
    tmp___0 = strlen(name);
#line 101
    tmp___1 = (long )tmp___0;
    }
  }
#line 101
  namelen = (int )tmp___1;
#line 103
  i = 0;
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 103
    if (! ((unsigned long )i < sizeof(implementations) / sizeof(implementations[0]))) {
#line 103
      goto while_break;
    }
    {
#line 104
    tmp___2 = strncmp((char const   *)pi->name, name, (size_t )namelen);
    }
#line 104
    if (! tmp___2) {
#line 105
      return (1);
    }
#line 103
    i ++;
#line 103
    pi ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 106
  return (0);
}
}
#line 111 "progress.c"
void set_progress_implementation(char const   *name ) 
{ 
  int i ;
  int namelen ;
  struct progress_implementation *pi ;
  char *colon ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 115
  pi = implementations;
#line 118
  if (! name) {
#line 119
    name = "bar";
  }
  {
#line 121
  colon = strchr(name, ':');
  }
#line 122
  if (colon) {
#line 122
    namelen = (int )(colon - (char *)name);
  } else {
    {
#line 122
    tmp = strlen(name);
#line 122
    namelen = (int )tmp;
    }
  }
#line 124
  i = 0;
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    if (! ((unsigned long )i < sizeof(implementations) / sizeof(implementations[0]))) {
#line 124
      goto while_break;
    }
    {
#line 125
    tmp___0 = strncmp((char const   *)pi->name, name, (size_t )namelen);
    }
#line 125
    if (! tmp___0) {
#line 127
      current_impl = pi;
#line 128
      current_impl_locked = 0;
#line 130
      if (colon) {
#line 134
        colon ++;
      }
#line 136
      if (pi->set_params) {
        {
#line 137
        (*(pi->set_params))((char const   *)colon);
        }
      }
#line 138
      return;
    }
#line 124
    i ++;
#line 124
    pi ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 140
  abort();
  }
}
}
#line 143 "progress.c"
static int output_redirected  ;
#line 145 "progress.c"
void progress_schedule_redirect(void) 
{ 


  {
#line 148
  output_redirected = 1;
#line 149
  return;
}
}
#line 157 "progress.c"
void *progress_create(long initial , long total ) 
{ 
  void *tmp ;

  {
#line 161
  if (output_redirected) {
#line 163
    if (! current_impl_locked) {
      {
#line 164
      set_progress_implementation("dot");
      }
    }
#line 165
    output_redirected = 0;
  }
  {
#line 168
  tmp = (*(current_impl->create))(initial, total);
  }
#line 168
  return (tmp);
}
}
#line 174 "progress.c"
void progress_update(void *progress , long howmuch , double dltime ) 
{ 


  {
  {
#line 177
  (*(current_impl->update))(progress, howmuch, dltime);
  }
#line 178
  return;
}
}
#line 183 "progress.c"
void progress_finish(void *progress , double dltime ) 
{ 


  {
  {
#line 186
  (*(current_impl->finish))(progress, dltime);
  }
#line 187
  return;
}
}
#line 206 "progress.c"
static void *dot_create(long initial , long total ) 
{ 
  struct dot_progress *dp ;
  void *tmp ;
  int dot_bytes ;
  long row_bytes ;
  int remainder ;
  long skipped ;
  int skipped_k ;
  int skipped_k_len ;
  int tmp___0 ;
  char *tmp___1 ;
  long tmp___2 ;

  {
  {
#line 209
  tmp = xmalloc_real((size_t )sizeof(struct dot_progress ));
#line 209
  dp = (struct dot_progress *)tmp;
#line 211
  memset((void *)dp, 0, (size_t )sizeof(*dp));
#line 213
  dp->initial_length = initial;
#line 214
  dp->total_length = total;
  }
#line 216
  if (dp->initial_length) {
#line 218
    dot_bytes = (int )opt.dot_bytes;
#line 219
    row_bytes = opt.dot_bytes * (long )opt.dots_in_line;
#line 221
    remainder = (int )(dp->initial_length % row_bytes);
#line 222
    skipped = dp->initial_length - (long )remainder;
#line 224
    if (skipped) {
      {
#line 226
      skipped_k = (int )(skipped / 1024L);
#line 227
      tmp___0 = numdigit((long )skipped_k);
#line 227
      skipped_k_len = tmp___0;
      }
#line 228
      if (skipped_k_len < 5) {
#line 229
        skipped_k_len = 5;
      }
      {
#line 234
      tmp___1 = gettext("\n%*s[ skipping %dK ]");
#line 234
      logprintf((enum log_options )0, (char const   *)tmp___1, 2 + skipped_k_len,
                "", skipped_k);
      }
    }
    {
#line 238
    logprintf((enum log_options )0, "\n%5ldK", skipped / 1024L);
    }
    {
#line 239
    while (1) {
      while_continue: /* CIL Label */ ;
#line 239
      if (! (remainder >= dot_bytes)) {
#line 239
        goto while_break;
      }
#line 241
      if (dp->dots % opt.dot_spacing == 0) {
        {
#line 242
        logputs((enum log_options )0, " ");
        }
      }
      {
#line 243
      logputs((enum log_options )0, ",");
#line 244
      (dp->dots) ++;
#line 239
      remainder -= dot_bytes;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 246
    tmp___2 = __builtin_expect((long )(! (! (dp->dots < opt.dots_in_line))), 1L);
    }
#line 246
    if (! tmp___2) {
      {
#line 246
      __assert_fail("dp->dots < opt.dots_in_line", "progress.c", 246U, "dot_create");
      }
    }
#line 248
    dp->accumulated = remainder;
#line 249
    dp->rows = (int )(skipped / row_bytes);
  }
#line 252
  return ((void *)dp);
}
}
#line 255 "progress.c"
static void print_percentage(long bytes , long expected ) 
{ 
  int percentage ;

  {
  {
#line 258
  percentage = (int )((100.0 * (double )bytes) / (double )expected);
#line 259
  logprintf((enum log_options )0, "%3d%%", percentage);
  }
#line 260
  return;
}
}
#line 262 "progress.c"
static void print_download_speed(struct dot_progress *dp , long bytes , double dltime ) 
{ 
  char *tmp ;

  {
  {
#line 265
  tmp = retr_rate(bytes, dltime - dp->last_timer_value, 1);
#line 265
  logprintf((enum log_options )0, " %s", tmp);
#line 267
  dp->last_timer_value = dltime;
  }
#line 268
  return;
}
}
#line 272 "progress.c"
static void dot_update(void *progress , long howmuch , double dltime ) 
{ 
  struct dot_progress *dp ;
  int dot_bytes ;
  long row_bytes ;
  long row_qty ;

  {
  {
#line 275
  dp = (struct dot_progress *)progress;
#line 276
  dot_bytes = (int )opt.dot_bytes;
#line 277
  row_bytes = opt.dot_bytes * (long )opt.dots_in_line;
#line 279
  log_set_flush(0);
#line 281
  dp->accumulated = (int )((long )dp->accumulated + howmuch);
  }
  {
#line 282
  while (1) {
    while_continue: /* CIL Label */ ;
#line 282
    if (! (dp->accumulated >= dot_bytes)) {
#line 282
      goto while_break;
    }
#line 284
    if (dp->dots == 0) {
      {
#line 285
      logprintf((enum log_options )0, "\n%5ldK", ((long )dp->rows * row_bytes) / 1024L);
      }
    }
#line 287
    if (dp->dots % opt.dot_spacing == 0) {
      {
#line 288
      logputs((enum log_options )0, " ");
      }
    }
    {
#line 289
    logputs((enum log_options )0, ".");
#line 291
    (dp->dots) ++;
    }
#line 292
    if (dp->dots >= opt.dots_in_line) {
#line 294
      row_qty = row_bytes;
#line 295
      if ((long )dp->rows == dp->initial_length / row_bytes) {
#line 296
        row_qty -= dp->initial_length % row_bytes;
      }
#line 298
      (dp->rows) ++;
#line 299
      dp->dots = 0;
#line 301
      if (dp->total_length) {
        {
#line 302
        print_percentage((long )dp->rows * row_bytes, dp->total_length);
        }
      }
      {
#line 303
      print_download_speed(dp, row_qty, dltime);
      }
    }
#line 282
    dp->accumulated -= dot_bytes;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 307
  log_set_flush(1);
  }
#line 308
  return;
}
}
#line 312 "progress.c"
static void dot_finish(void *progress , double dltime ) 
{ 
  struct dot_progress *dp ;
  int dot_bytes ;
  long row_bytes ;
  int i ;
  long row_qty ;

  {
  {
#line 315
  dp = (struct dot_progress *)progress;
#line 316
  dot_bytes = (int )opt.dot_bytes;
#line 317
  row_bytes = opt.dot_bytes * (long )opt.dots_in_line;
#line 320
  log_set_flush(0);
  }
#line 322
  if (dp->dots == 0) {
    {
#line 323
    logprintf((enum log_options )0, "\n%5ldK", ((long )dp->rows * row_bytes) / 1024L);
    }
  }
#line 324
  i = dp->dots;
  {
#line 324
  while (1) {
    while_continue: /* CIL Label */ ;
#line 324
    if (! (i < opt.dots_in_line)) {
#line 324
      goto while_break;
    }
#line 326
    if (i % opt.dot_spacing == 0) {
      {
#line 327
      logputs((enum log_options )0, " ");
      }
    }
    {
#line 328
    logputs((enum log_options )0, " ");
#line 324
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 330
  if (dp->total_length) {
    {
#line 332
    print_percentage(((long )dp->rows * row_bytes + (long )(dp->dots * dot_bytes)) + (long )dp->accumulated,
                     dp->total_length);
    }
  }
#line 339
  row_qty = (long )(dp->dots * dot_bytes + dp->accumulated);
#line 340
  if ((long )dp->rows == dp->initial_length / row_bytes) {
#line 341
    row_qty -= dp->initial_length % row_bytes;
  }
  {
#line 342
  print_download_speed(dp, row_qty, dltime);
#line 345
  logputs((enum log_options )0, "\n\n");
#line 346
  log_set_flush(0);
#line 348
  free((void *)dp);
  }
#line 349
  return;
}
}
#line 356 "progress.c"
static void dot_set_params(char const   *params ) 
{ 
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 359
  if (! params) {
#line 360
    params = (char const   *)opt.dot_style;
  } else
#line 359
  if (! *params) {
#line 360
    params = (char const   *)opt.dot_style;
  }
#line 362
  if (! params) {
#line 363
    return;
  }
  {
#line 366
  tmp___3 = strcasecmp(params, "default");
  }
#line 366
  if (tmp___3) {
    {
#line 374
    tmp___2 = strcasecmp(params, "binary");
    }
#line 374
    if (tmp___2) {
      {
#line 382
      tmp___1 = strcasecmp(params, "mega");
      }
#line 382
      if (tmp___1) {
        {
#line 390
        tmp___0 = strcasecmp(params, "giga");
        }
#line 390
        if (tmp___0) {
          {
#line 400
          tmp = gettext("Invalid dot style specification `%s\'; leaving unchanged.\n");
#line 400
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
                  params);
          }
        } else {
#line 395
          opt.dot_bytes = 1L << 20;
#line 396
          opt.dot_spacing = 8;
#line 397
          opt.dots_in_line = 32;
        }
      } else {
#line 386
        opt.dot_bytes = 65536L;
#line 387
        opt.dot_spacing = 8;
#line 388
        opt.dots_in_line = 48;
      }
    } else {
#line 378
      opt.dot_bytes = 8192L;
#line 379
      opt.dot_spacing = 16;
#line 380
      opt.dots_in_line = 48;
    }
  } else {
#line 370
    opt.dot_bytes = 1024L;
#line 371
    opt.dot_spacing = 10;
#line 372
    opt.dots_in_line = 50;
  }
#line 403
  return;
}
}
#line 414 "progress.c"
static int screen_width  =    80;
#line 474
static void create_image(struct bar_progress *bp , double dl_total_time ) ;
#line 475
static void display_image(char *buf___0 ) ;
#line 477 "progress.c"
static void *bar_create(long initial , long total ) 
{ 
  struct bar_progress *bp ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 480
  tmp = xmalloc_real((size_t )sizeof(struct bar_progress ));
#line 480
  bp = (struct bar_progress *)tmp;
#line 482
  memset((void *)bp, 0, (size_t )sizeof(*bp));
  }
#line 486
  if (initial > total) {
#line 487
    total = initial;
  }
  {
#line 489
  bp->initial_length = initial;
#line 490
  bp->total_length = total;
#line 493
  bp->width = screen_width - 1;
#line 495
  tmp___0 = xmalloc_real((size_t )(bp->width + 1));
#line 495
  bp->buffer = (char *)tmp___0;
#line 497
  logputs((enum log_options )0, "\n");
#line 499
  create_image(bp, (double )0);
#line 500
  display_image(bp->buffer);
  }
#line 502
  return ((void *)bp);
}
}
#line 505
static void update_speed_ring(struct bar_progress *bp , long howmuch , double dltime ) ;
#line 507 "progress.c"
static void bar_update(void *progress , long howmuch , double dltime ) 
{ 
  struct bar_progress *bp ;
  int force_screen_update ;
  void *tmp ;

  {
#line 510
  bp = (struct bar_progress *)progress;
#line 511
  force_screen_update = 0;
#line 513
  bp->count += howmuch;
#line 514
  if (bp->total_length > 0L) {
#line 514
    if (bp->count + bp->initial_length > bp->total_length) {
#line 521
      bp->total_length = bp->initial_length + bp->count;
    }
  }
  {
#line 523
  update_speed_ring(bp, howmuch, dltime);
  }
#line 525
  if (screen_width - 1 != bp->width) {
    {
#line 527
    bp->width = screen_width - 1;
#line 528
    tmp = xrealloc_real((void *)bp->buffer, (size_t )(bp->width + 1));
#line 528
    bp->buffer = (char *)tmp;
#line 529
    force_screen_update = 1;
    }
  }
#line 532
  if (dltime - bp->last_screen_update < (double )200) {
#line 532
    if (! force_screen_update) {
#line 534
      return;
    }
  }
  {
#line 536
  create_image(bp, dltime);
#line 537
  display_image(bp->buffer);
#line 538
  bp->last_screen_update = dltime;
  }
#line 539
  return;
}
}
#line 541 "progress.c"
static void bar_finish(void *progress , double dltime ) 
{ 
  struct bar_progress *bp ;

  {
#line 544
  bp = (struct bar_progress *)progress;
#line 546
  if (bp->total_length > 0L) {
#line 546
    if (bp->count + bp->initial_length > bp->total_length) {
#line 549
      bp->total_length = bp->initial_length + bp->count;
    }
  }
  {
#line 551
  create_image(bp, dltime);
#line 552
  display_image(bp->buffer);
#line 554
  logputs((enum log_options )0, "\n\n");
#line 556
  free((void *)bp->buffer);
#line 557
  free((void *)bp);
  }
#line 558
  return;
}
}
#line 578 "progress.c"
static void update_speed_ring(struct bar_progress *bp , long howmuch , double dltime ) 
{ 
  struct bar_progress_hist *hist ;
  double recent_age ;

  {
#line 581
  hist = & bp->hist;
#line 582
  recent_age = dltime - bp->recent_start;
#line 585
  bp->recent_bytes += howmuch;
#line 590
  if (recent_age < (double )150) {
#line 591
    return;
  }
#line 598
  hist->total_time -= hist->times[hist->pos];
#line 599
  hist->total_bytes -= hist->bytes[hist->pos];
#line 602
  hist->times[hist->pos] = (long )recent_age;
#line 603
  hist->bytes[hist->pos] = bp->recent_bytes;
#line 604
  hist->total_time = (long )((double )hist->total_time + recent_age);
#line 605
  hist->total_bytes += bp->recent_bytes;
#line 608
  bp->recent_start = dltime;
#line 609
  bp->recent_bytes = 0L;
#line 612
  (hist->pos) ++;
#line 612
  if (hist->pos == 20) {
#line 613
    hist->pos = 0;
  }
#line 629
  return;
}
}
#line 759 "progress.c"
static char *short_units[4]  = {      (char *)"B/s",      (char *)"K/s",      (char *)"M/s",      (char *)"G/s"};
#line 640 "progress.c"
static void create_image(struct bar_progress *bp , double dl_total_time ) 
{ 
  char *p ;
  long size ;
  char *size_legible ;
  char *tmp ;
  int size_legible_len ;
  size_t tmp___0 ;
  struct bar_progress_hist *hist ;
  int dlbytes_size ;
  int tmp___1 ;
  int progress_size ;
  int percentage ;
  long tmp___2 ;
  int insz ;
  int dlsz ;
  char *begin ;
  int i ;
  long tmp___3 ;
  long tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int ind ;
  int i___0 ;
  int pos ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  size_t tmp___18 ;
  int units ;
  long dlquant ;
  double dltime ;
  double dlspeed ;
  double tmp___19 ;
  size_t tmp___20 ;
  long eta ;
  int eta_hrs ;
  int eta_min ;
  int eta_sec ;
  double time_sofar ;
  long bytes_remaining ;
  char *tmp___21 ;
  size_t tmp___22 ;
  long tmp___23 ;
  char *tmp___24 ;

  {
  {
#line 643
  p = bp->buffer;
#line 644
  size = bp->initial_length + bp->count;
#line 646
  tmp = legible(size);
#line 646
  size_legible = tmp;
#line 647
  tmp___0 = strlen((char const   *)size_legible);
#line 647
  size_legible_len = (int )tmp___0;
#line 649
  hist = & bp->hist;
  }
#line 669
  if (size_legible_len >= 11) {
#line 669
    tmp___1 = size_legible_len;
  } else {
#line 669
    tmp___1 = 11;
  }
#line 669
  dlbytes_size = 1 + tmp___1;
#line 670
  progress_size = bp->width - (((6 + dlbytes_size) + 11) + 13);
#line 672
  if (progress_size < 5) {
#line 673
    progress_size = 0;
  }
#line 676
  if (bp->total_length > 0L) {
    {
#line 678
    percentage = (int )((100.0 * (double )size) / (double )bp->total_length);
#line 680
    tmp___2 = __builtin_expect((long )(! (! (percentage <= 100))), 1L);
    }
#line 680
    if (! tmp___2) {
      {
#line 680
      __assert_fail("percentage <= 100", "progress.c", 680U, "create_image");
      }
    }
#line 682
    if (percentage < 100) {
      {
#line 683
      sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"%2d%% ",
              percentage);
      }
    } else {
      {
#line 685
      strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)"100%");
      }
    }
#line 686
    p += 4;
  } else {
    {
#line 689
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 689
      memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)"    ",
             (size_t )(sizeof("    ") - 1UL));
#line 689
      p += sizeof("    ") - 1UL;
      }
#line 689
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 692
  if (progress_size) {
#line 692
    if (bp->total_length > 0L) {
      {
#line 695
      insz = (int )(((double )bp->initial_length / (double )bp->total_length) * (double )progress_size);
#line 698
      dlsz = (int )(((double )size / (double )bp->total_length) * (double )progress_size);
#line 703
      tmp___3 = __builtin_expect((long )(! (! (dlsz <= progress_size))), 1L);
      }
#line 703
      if (! tmp___3) {
        {
#line 703
        __assert_fail("dlsz <= progress_size", "progress.c", 703U, "create_image");
        }
      }
      {
#line 704
      tmp___4 = __builtin_expect((long )(! (! (insz <= dlsz))), 1L);
      }
#line 704
      if (! tmp___4) {
        {
#line 704
        __assert_fail("insz <= dlsz", "progress.c", 704U, "create_image");
        }
      }
#line 706
      tmp___5 = p;
#line 706
      p ++;
#line 706
      *tmp___5 = (char )'[';
#line 707
      begin = p;
#line 711
      i = 0;
      {
#line 711
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 711
        if (! (i < insz)) {
#line 711
          goto while_break___0;
        }
#line 712
        tmp___6 = p;
#line 712
        p ++;
#line 712
        *tmp___6 = (char )'+';
#line 711
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 713
      dlsz -= insz;
#line 714
      if (dlsz > 0) {
#line 716
        i = 0;
        {
#line 716
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 716
          if (! (i < dlsz - 1)) {
#line 716
            goto while_break___1;
          }
#line 717
          tmp___7 = p;
#line 717
          p ++;
#line 717
          *tmp___7 = (char )'=';
#line 716
          i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 718
        tmp___8 = p;
#line 718
        p ++;
#line 718
        *tmp___8 = (char )'>';
      }
      {
#line 721
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 721
        if (! (p - begin < (long )progress_size)) {
#line 721
          goto while_break___2;
        }
#line 722
        tmp___9 = p;
#line 722
        p ++;
#line 722
        *tmp___9 = (char )' ';
      }
      while_break___2: /* CIL Label */ ;
      }
#line 723
      tmp___10 = p;
#line 723
      p ++;
#line 723
      *tmp___10 = (char )']';
    } else {
#line 692
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 725
  if (progress_size) {
#line 729
    ind = bp->tick % (progress_size * 2 - 6);
#line 733
    if (ind < progress_size - 2) {
#line 734
      pos = ind + 1;
    } else {
#line 736
      pos = progress_size - ((ind - progress_size) + 5);
    }
#line 738
    tmp___11 = p;
#line 738
    p ++;
#line 738
    *tmp___11 = (char )'[';
#line 739
    i___0 = 0;
    {
#line 739
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 739
      if (! (i___0 < progress_size)) {
#line 739
        goto while_break___3;
      }
#line 741
      if (i___0 == pos - 1) {
#line 741
        tmp___12 = p;
#line 741
        p ++;
#line 741
        *tmp___12 = (char )'<';
      } else
#line 742
      if (i___0 == pos) {
#line 742
        tmp___13 = p;
#line 742
        p ++;
#line 742
        *tmp___13 = (char )'=';
      } else
#line 743
      if (i___0 == pos + 1) {
#line 743
        tmp___14 = p;
#line 743
        p ++;
#line 743
        *tmp___14 = (char )'>';
      } else {
#line 745
        tmp___15 = p;
#line 745
        p ++;
#line 745
        *tmp___15 = (char )' ';
      }
#line 739
      i___0 ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 747
    tmp___16 = p;
#line 747
    p ++;
#line 747
    *tmp___16 = (char )']';
#line 749
    (bp->tick) ++;
  }
  {
#line 753
  tmp___17 = legible(size);
#line 753
  sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)" %-11s", tmp___17);
#line 754
  tmp___18 = strlen((char const   *)p);
#line 754
  p += tmp___18;
  }
#line 757
  if (hist->total_time) {
#line 757
    if (hist->total_bytes) {
      {
#line 760
      units = 0;
#line 763
      dlquant = hist->total_bytes + bp->recent_bytes;
#line 764
      dltime = (double )hist->total_time + (dl_total_time - bp->recent_start);
#line 765
      tmp___19 = calc_rate(dlquant, dltime, & units);
#line 765
      dlspeed = tmp___19;
#line 766
      sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)" %7.2f%s",
              dlspeed, short_units[units]);
#line 767
      tmp___20 = strlen((char const   *)p);
#line 767
      p += tmp___20;
      }
    } else {
#line 757
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    {
#line 770
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 770
      memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)"   --.--K/s",
             (size_t )(sizeof("   --.--K/s") - 1UL));
#line 770
      p += sizeof("   --.--K/s") - 1UL;
      }
#line 770
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 775
  if (bp->total_length > 0L) {
#line 775
    if (dl_total_time > (double )3000) {
#line 783
      if (bp->total_length != size) {
#line 783
        if (bp->last_eta_value != 0L) {
#line 783
          if (dl_total_time - bp->last_eta_time < (double )900) {
#line 786
            eta = bp->last_eta_value;
          } else {
#line 795
            time_sofar = dl_total_time / (double )1000;
#line 796
            bytes_remaining = bp->total_length - size;
#line 797
            eta = (long )((time_sofar * (double )bytes_remaining) / (double )bp->count);
#line 798
            bp->last_eta_value = eta;
#line 799
            bp->last_eta_time = dl_total_time;
          }
        } else {
#line 795
          time_sofar = dl_total_time / (double )1000;
#line 796
          bytes_remaining = bp->total_length - size;
#line 797
          eta = (long )((time_sofar * (double )bytes_remaining) / (double )bp->count);
#line 798
          bp->last_eta_value = eta;
#line 799
          bp->last_eta_time = dl_total_time;
        }
      } else {
#line 795
        time_sofar = dl_total_time / (double )1000;
#line 796
        bytes_remaining = bp->total_length - size;
#line 797
        eta = (long )((time_sofar * (double )bytes_remaining) / (double )bp->count);
#line 798
        bp->last_eta_value = eta;
#line 799
        bp->last_eta_time = dl_total_time;
      }
#line 802
      eta_hrs = (int )(eta / 3600L);
#line 802
      eta %= 3600L;
#line 803
      eta_min = (int )(eta / 60L);
#line 803
      eta %= 60L;
#line 804
      eta_sec = (int )eta;
#line 806
      if (eta_hrs > 99) {
#line 807
        goto no_eta;
      }
#line 809
      if (eta_hrs == 0) {
        {
#line 812
        while (1) {
          while_continue___5: /* CIL Label */ ;
          {
#line 812
          memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)"   ",
                 (size_t )(sizeof("   ") - 1UL));
#line 812
          p += sizeof("   ") - 1UL;
          }
#line 812
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
        {
#line 813
        sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)" ETA %02d:%02d",
                eta_min, eta_sec);
        }
      } else {
#line 817
        if (eta_hrs < 10) {
#line 819
          tmp___21 = p;
#line 819
          p ++;
#line 819
          *tmp___21 = (char )' ';
        }
        {
#line 820
        sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)" ETA %d:%02d:%02d",
                eta_hrs, eta_min, eta_sec);
        }
      }
      {
#line 822
      tmp___22 = strlen((char const   *)p);
#line 822
      p += tmp___22;
      }
    } else {
#line 775
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 824
  if (bp->total_length > 0L) {
    no_eta: 
    {
#line 827
    while (1) {
      while_continue___6: /* CIL Label */ ;
      {
#line 827
      memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)"             ",
             (size_t )(sizeof("             ") - 1UL));
#line 827
      p += sizeof("             ") - 1UL;
      }
#line 827
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
  }
  {
#line 830
  tmp___23 = __builtin_expect((long )(! (! (p - bp->buffer <= (long )bp->width))),
                              1L);
  }
#line 830
  if (! tmp___23) {
    {
#line 830
    __assert_fail("p - bp->buffer <= bp->width", "progress.c", 830U, "create_image");
    }
  }
  {
#line 832
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 832
    if (! ((unsigned long )p < (unsigned long )(bp->buffer + bp->width))) {
#line 832
      goto while_break___7;
    }
#line 833
    tmp___24 = p;
#line 833
    p ++;
#line 833
    *tmp___24 = (char )' ';
  }
  while_break___7: /* CIL Label */ ;
  }
#line 834
  *p = (char )'\000';
#line 835
  return;
}
}
#line 840 "progress.c"
static void display_image(char *buf___0 ) 
{ 
  int old ;
  int tmp ;

  {
  {
#line 843
  tmp = log_set_save_context(0);
#line 843
  old = tmp;
#line 844
  logputs((enum log_options )0, "\r");
#line 845
  logputs((enum log_options )0, (char const   *)buf___0);
#line 846
  log_set_save_context(old);
  }
#line 847
  return;
}
}
#line 849 "progress.c"
static void bar_set_params(char const   *params ) 
{ 
  int sw ;
  char *term ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 853
  tmp = getenv("TERM");
#line 853
  term = tmp;
  }
#line 855
  if (params) {
    {
#line 855
    tmp___0 = strcmp(params, "force");
    }
#line 855
    if (0 == tmp___0) {
#line 857
      current_impl_locked = 1;
    }
  }
#line 859
  if (opt.lfilename) {
#line 859
    goto _L;
  } else {
    {
#line 859
    tmp___1 = fileno(stderr);
#line 859
    tmp___2 = isatty(tmp___1);
    }
#line 859
    if (tmp___2) {
#line 859
      if (term) {
        {
#line 859
        tmp___3 = strcmp((char const   *)term, "emacs");
        }
#line 859
        if (0 == tmp___3) {
          _L: /* CIL Label */ 
#line 859
          if (! current_impl_locked) {
            {
#line 882
            set_progress_implementation("dot");
            }
#line 883
            return;
          }
        }
      }
    } else {
#line 859
      goto _L;
    }
  }
  {
#line 886
  sw = determine_screen_width();
  }
#line 887
  if (sw) {
#line 887
    if (sw >= 45) {
#line 888
      screen_width = sw;
    }
  }
#line 889
  return;
}
}
#line 892 "progress.c"
void progress_handle_sigwinch(int sig ) 
{ 
  int sw ;
  int tmp ;

  {
  {
#line 895
  tmp = determine_screen_width();
#line 895
  sw = tmp;
  }
#line 896
  if (sw) {
#line 896
    if (sw >= 45) {
#line 897
      screen_width = sw;
    }
  }
  {
#line 898
  signal(28, & progress_handle_sigwinch);
  }
#line 899
  return;
}
}
#line 42 "netrc.h"
void search_netrc(char const   *host , char const   **acc , char const   **passwd ,
                  int slack_default ) ;
#line 43
void free_netrc(acc_t *l ) ;
#line 36 "init.h"
char *home_dir(void) ;
#line 58 "netrc.c"
acc_t *netrc_list  ;
#line 60
static acc_t *parse_netrc(char const   *path ) ;
#line 73 "netrc.c"
static int processed_netrc  ;
#line 68 "netrc.c"
void search_netrc(char const   *host , char const   **acc , char const   **passwd ,
                  int slack_default ) 
{ 
  acc_t *l ;
  char *home ;
  char *tmp ;
  int err ;
  struct stat buf___0 ;
  char *path ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 75
  if (! opt.netrc) {
#line 76
    return;
  }
#line 78
  if (! processed_netrc) {
    {
#line 80
    tmp = home_dir();
#line 80
    home = tmp;
#line 82
    netrc_list = (acc_t *)((void *)0);
#line 83
    processed_netrc = 1;
    }
#line 84
    if (home) {
      {
#line 88
      tmp___0 = strlen((char const   *)home);
#line 88
      tmp___1 = strlen(".netrc");
#line 88
      tmp___2 = __builtin_alloca((unsigned long )(((tmp___0 + 1U) + tmp___1) + 1U));
#line 88
      path = (char *)tmp___2;
#line 90
      sprintf((char */* __restrict  */)path, (char const   */* __restrict  */)"%s/%s",
              home, ".netrc");
#line 91
      free((void *)home);
#line 92
      err = stat((char const   */* __restrict  */)path, (struct stat */* __restrict  */)(& buf___0));
      }
#line 93
      if (err == 0) {
        {
#line 94
        netrc_list = parse_netrc((char const   *)path);
        }
      }
    }
  }
#line 98
  if (! netrc_list) {
#line 99
    return;
  }
#line 101
  if (*acc) {
#line 101
    if (*passwd) {
#line 102
      return;
    }
  }
#line 104
  l = netrc_list;
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 104
    if (! l) {
#line 104
      goto while_break;
    }
#line 106
    if (! (! l->host)) {
      {
#line 108
      tmp___3 = strcasecmp((char const   *)l->host, host);
      }
#line 108
      if (! tmp___3) {
#line 109
        goto while_break;
      }
    }
#line 104
    l = l->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 111
  if (l) {
#line 113
    if (*acc) {
      {
#line 116
      tmp___4 = strcmp((char const   *)l->acc, *acc);
      }
#line 116
      if (tmp___4) {
#line 119
        *passwd = (char const   *)((void *)0);
      } else {
#line 117
        *passwd = (char const   *)l->passwd;
      }
    } else {
#line 124
      *acc = (char const   *)l->acc;
#line 125
      if (l->passwd) {
#line 126
        *passwd = (char const   *)l->passwd;
      }
    }
#line 128
    return;
  } else {
#line 132
    if (! slack_default) {
#line 133
      return;
    }
#line 134
    if (*acc) {
#line 135
      return;
    }
#line 137
    l = netrc_list;
    {
#line 137
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 137
      if (! l) {
#line 137
        goto while_break___0;
      }
#line 138
      if (! l->host) {
#line 139
        goto while_break___0;
      }
#line 137
      l = l->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 140
    if (! l) {
#line 141
      return;
    }
#line 142
    *acc = (char const   *)l->acc;
#line 143
    if (! *passwd) {
#line 144
      *passwd = (char const   *)l->passwd;
    }
#line 145
    return;
  }
}
}
#line 207 "netrc.c"
static void maybe_add_to_list(acc_t **newentry , acc_t **list ) 
{ 
  acc_t *a ;
  acc_t *l ;
  void *tmp ;

  {
#line 211
  a = *newentry;
#line 212
  l = *list;
#line 215
  if (a) {
#line 215
    if (! a->acc) {
      {
#line 218
      free((void *)a->host);
#line 219
      free((void *)a->acc);
#line 220
      free((void *)a->passwd);
      }
    } else {
#line 215
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 224
    if (a) {
#line 227
      a->next = l;
#line 228
      l = a;
    }
    {
#line 232
    tmp = xmalloc_real((size_t )sizeof(acc_t ));
#line 232
    a = (acc_t *)tmp;
    }
  }
  {
#line 236
  memset((void *)a, 0, (size_t )sizeof(*a));
#line 239
  *newentry = a;
#line 240
  *list = l;
  }
#line 241
  return;
}
}
#line 247 "netrc.c"
static void shift_left(char *string ) 
{ 
  char *p ;

  {
#line 252
  p = string;
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
#line 252
    if (! *p) {
#line 252
      goto while_break;
    }
#line 253
    *p = *(p + 1);
#line 252
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 254
  return;
}
}
#line 257 "netrc.c"
static acc_t *parse_netrc(char const   *path ) 
{ 
  FILE *fp ;
  char *line ;
  char *p ;
  char *tok ;
  char *premature_token ;
  acc_t *current ;
  acc_t *retval ;
  int ln ;
  int quote ;
  enum __anonenum_last_token_26 last_token ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  acc_t *saved_reference ;

  {
  {
#line 266
  last_token = (enum __anonenum_last_token_26 )0;
#line 271
  retval = (acc_t *)((void *)0);
#line 271
  current = retval;
#line 273
  fp = fopen((char const   */* __restrict  */)path, (char const   */* __restrict  */)"r");
  }
#line 274
  if (! fp) {
    {
#line 276
    tmp = __errno_location();
#line 276
    tmp___0 = strerror(*tmp);
#line 276
    tmp___1 = gettext("%s: Cannot read %s (%s).\n");
#line 276
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
            exec_name, path, tmp___0);
    }
#line 278
    return (retval);
  }
#line 282
  ln = 0;
#line 283
  premature_token = (char *)((void *)0);
  {
#line 286
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 286
    line = read_whole_line(fp);
    }
#line 286
    if (! line) {
#line 286
      goto while_break;
    }
#line 288
    ln ++;
#line 291
    p = line;
#line 292
    quote = 0;
    {
#line 295
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 295
      if (*p) {
#line 295
        if (! ((int const   )_sch_istable[(int )*p & 255] & 64)) {
#line 295
          goto while_break___0;
        }
      } else {
#line 295
        goto while_break___0;
      }
#line 296
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 299
    if ((unsigned int )last_token == 3U) {
#line 299
      if (! *p) {
#line 301
        last_token = (enum __anonenum_last_token_26 )0;
      }
    }
    {
#line 304
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 304
      if (*p) {
#line 304
        if (! ((unsigned int )last_token != 3U)) {
#line 304
          goto while_break___1;
        }
      } else {
#line 304
        goto while_break___1;
      }
      {
#line 307
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 307
        if (*p) {
#line 307
          if (! ((int const   )_sch_istable[(int )*p & 255] & 64)) {
#line 307
            goto while_break___2;
          }
        } else {
#line 307
          goto while_break___2;
        }
#line 308
        p ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 312
      if ((int )*p == 35) {
#line 313
        goto while_break___1;
      } else
#line 312
      if (! *p) {
#line 313
        goto while_break___1;
      }
#line 317
      if ((int )*p == 34) {
        {
#line 318
        quote = 1;
#line 319
        shift_left(p);
        }
      }
#line 322
      tok = p;
      {
#line 325
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 325
        if (*p) {
#line 325
          if (quote) {
#line 325
            tmp___2 = (int )*p != 34;
          } else {
#line 325
            tmp___2 = ! ((int const   )_sch_istable[(int )*p & 255] & 64);
          }
#line 325
          if (! tmp___2) {
#line 325
            goto while_break___3;
          }
        } else {
#line 325
          goto while_break___3;
        }
#line 326
        if ((int )*p == 92) {
          {
#line 327
          shift_left(p);
          }
        }
#line 328
        p ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 332
      if (quote) {
        {
#line 333
        shift_left(p);
        }
      }
#line 336
      if (*p) {
#line 337
        tmp___3 = p;
#line 337
        p ++;
#line 337
        *tmp___3 = (char )'\000';
      }
      {
#line 341
      if ((unsigned int )last_token == 2U) {
#line 341
        goto case_2;
      }
#line 348
      if ((unsigned int )last_token == 4U) {
#line 348
        goto case_4;
      }
#line 354
      if ((unsigned int )last_token == 5U) {
#line 354
        goto case_5;
      }
#line 362
      if ((unsigned int )last_token == 3U) {
#line 362
        goto case_3;
      }
#line 368
      if ((unsigned int )last_token == 1U) {
#line 368
        goto case_1;
      }
#line 374
      if ((unsigned int )last_token == 0U) {
#line 374
        goto case_0;
      }
#line 339
      goto switch_break;
      case_2: /* CIL Label */ 
#line 342
      if (current) {
        {
#line 343
        current->acc = xstrdup_real((char const   *)tok);
        }
      } else {
#line 345
        premature_token = (char *)"login";
      }
#line 346
      goto switch_break;
      case_4: /* CIL Label */ 
      {
#line 350
      maybe_add_to_list(& current, & retval);
#line 351
      current->host = xstrdup_real((char const   *)tok);
      }
#line 352
      goto switch_break;
      case_5: /* CIL Label */ 
#line 355
      if (current) {
        {
#line 356
        current->passwd = xstrdup_real((char const   *)tok);
        }
      } else {
#line 358
        premature_token = (char *)"password";
      }
#line 359
      goto switch_break;
      case_3: /* CIL Label */ 
#line 363
      if (! current) {
#line 364
        premature_token = (char *)"macdef";
      }
#line 365
      goto switch_break;
      case_1: /* CIL Label */ 
#line 369
      if (! current) {
#line 370
        premature_token = (char *)"account";
      }
#line 371
      goto switch_break;
      case_0: /* CIL Label */ 
#line 375
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 378
      if (premature_token) {
        {
#line 380
        tmp___4 = gettext("%s: %s:%d: warning: \"%s\" token appears before any machine name\n");
#line 380
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___4,
                exec_name, path, ln, premature_token);
#line 383
        premature_token = (char *)((void *)0);
        }
      }
#line 386
      if ((unsigned int )last_token != 0U) {
#line 388
        last_token = (enum __anonenum_last_token_26 )0;
      } else {
        {
#line 392
        tmp___11 = strcmp((char const   *)tok, "account");
        }
#line 392
        if (tmp___11) {
          {
#line 394
          tmp___10 = strcmp((char const   *)tok, "default");
          }
#line 394
          if (tmp___10) {
            {
#line 398
            tmp___9 = strcmp((char const   *)tok, "login");
            }
#line 398
            if (tmp___9) {
              {
#line 401
              tmp___8 = strcmp((char const   *)tok, "macdef");
              }
#line 401
              if (tmp___8) {
                {
#line 404
                tmp___7 = strcmp((char const   *)tok, "machine");
                }
#line 404
                if (tmp___7) {
                  {
#line 407
                  tmp___6 = strcmp((char const   *)tok, "password");
                  }
#line 407
                  if (tmp___6) {
                    {
#line 411
                    tmp___5 = gettext("%s: %s:%d: unknown token \"%s\"\n");
#line 411
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5,
                            exec_name, path, ln, tok);
                    }
                  } else {
#line 408
                    last_token = (enum __anonenum_last_token_26 )5;
                  }
                } else {
#line 405
                  last_token = (enum __anonenum_last_token_26 )4;
                }
              } else {
#line 402
                last_token = (enum __anonenum_last_token_26 )3;
              }
            } else {
#line 399
              last_token = (enum __anonenum_last_token_26 )2;
            }
          } else {
            {
#line 396
            maybe_add_to_list(& current, & retval);
            }
          }
        } else {
#line 393
          last_token = (enum __anonenum_last_token_26 )1;
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 416
    free((void *)line);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 419
  fclose(fp);
#line 422
  maybe_add_to_list(& current, & retval);
#line 423
  free((void *)current);
#line 426
  current = retval;
#line 427
  retval = (acc_t *)((void *)0);
  }
  {
#line 428
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 428
    if (! current) {
#line 428
      goto while_break___4;
    }
#line 433
    saved_reference = current->next;
#line 434
    current->next = retval;
#line 437
    retval = current;
#line 438
    current = saved_reference;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 441
  return (retval);
}
}
#line 446 "netrc.c"
void free_netrc(acc_t *l ) 
{ 
  acc_t *t ;

  {
  {
#line 451
  while (1) {
    while_continue: /* CIL Label */ ;
#line 451
    if (! l) {
#line 451
      goto while_break;
    }
#line 453
    t = l->next;
    {
#line 454
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 454
      if (l->acc) {
        {
#line 454
        free((void *)l->acc);
        }
      }
#line 454
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 455
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 455
      if (l->passwd) {
        {
#line 455
        free((void *)l->passwd);
        }
      }
#line 455
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 456
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 456
      if (l->host) {
        {
#line 456
        free((void *)l->host);
        }
      }
#line 456
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 457
    free((void *)l);
#line 458
    l = t;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 460
  return;
}
}
#line 43 "gen-md5.h"
int gen_md5_context_size(void) ;
#line 44
void gen_md5_init(gen_md5_context *ctx ) ;
#line 45
void gen_md5_update(unsigned char const   *buffer , int len , gen_md5_context *ctx ) ;
#line 46
void gen_md5_finish(gen_md5_context *ctx , unsigned char *result ) ;
#line 107 "/usr/include/openssl/md5.h"
extern int MD5_Init(MD5_CTX *c ) ;
#line 108
extern int MD5_Update(MD5_CTX *c , void const   *data , unsigned long len ) ;
#line 109
extern int MD5_Final(unsigned char *md , MD5_CTX *c ) ;
#line 60 "gen-md5.c"
int gen_md5_context_size(void) 
{ 


  {
#line 63
  return ((int )sizeof(struct gen_md5_context ));
}
}
#line 66 "gen-md5.c"
void gen_md5_init(gen_md5_context *ctx ) 
{ 
  gen_md5_context_imp *ctx_imp ;

  {
  {
#line 69
  ctx_imp = & ctx->imp;
#line 80
  MD5_Init(ctx_imp);
  }
#line 82
  return;
}
}
#line 84 "gen-md5.c"
void gen_md5_update(unsigned char const   *buffer , int len , gen_md5_context *ctx ) 
{ 
  gen_md5_context_imp *ctx_imp ;

  {
  {
#line 87
  ctx_imp = & ctx->imp;
#line 98
  MD5_Update(ctx_imp, (void const   *)buffer, (unsigned long )len);
  }
#line 100
  return;
}
}
#line 102 "gen-md5.c"
void gen_md5_finish(gen_md5_context *ctx , unsigned char *result ) 
{ 
  gen_md5_context_imp *ctx_imp ;

  {
  {
#line 105
  ctx_imp = & ctx->imp;
#line 116
  MD5_Final(result, ctx_imp);
  }
#line 118
  return;
}
}
#line 583 "/usr/include/stdio.h"
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 31 "getopt.h"
extern char *optarg ;
#line 45
extern int optind ;
#line 106
extern int getopt_long(int argc , char * const  *argv , char const   *shortopts ,
                       struct option  const  *longopts , int *longind ) ;
#line 125 "/usr/include/locale.h"
extern char *setlocale(int __category , char const   *__locale ) ;
#line 81 "/usr/include/libintl.h"
extern char *textdomain(char const   *__domainname ) ;
#line 85
extern char *bindtextdomain(char const   *__domainname , char const   *__dirname ) ;
#line 199 "options.h"
struct options opt  ;
#line 259 "wget.h"
char const   *exec_name  ;
#line 33 "init.h"
void initialize(void) ;
#line 34
void run_command(char const   *opt___0 ) ;
#line 35
void setoptval(char const   *com , char const   *val ) ;
#line 37
void cleanup(void) ;
#line 45 "cookies.h"
void cookie_jar_save(struct cookie_jar *jar , char const   *file ) ;
#line 98 "convert.h"
void convert_all_links(void) ;
#line 84 "main.c"
struct cookie_jar *wget_cookie_jar ;
#line 87
void log_init(char const   *file , int appendp ) ;
#line 88
void log_close(void) ;
#line 89
void log_request_redirect_output(char const   *signal_name ) ;
#line 91
static void redirect_output_signal(int sig ) ;
#line 98 "main.c"
static void i18n_initialize(void) 
{ 


  {
  {
#line 112
  setlocale(5, "");
#line 113
  setlocale(0, "");
#line 118
  bindtextdomain("wget", "/usr/local/share/locale");
#line 119
  textdomain("wget");
  }
#line 121
  return;
}
}
#line 124 "main.c"
static void print_usage(void) 
{ 
  char *tmp ;

  {
  {
#line 127
  tmp = gettext("Usage: %s [OPTION]... [URL]...\n");
#line 127
  printf((char const   */* __restrict  */)tmp, exec_name);
  }
#line 128
  return;
}
}
#line 132 "main.c"
static void print_help(void) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;

  {
  {
#line 135
  tmp = gettext("GNU Wget %s, a non-interactive network retriever.\n");
#line 135
  printf((char const   */* __restrict  */)tmp, version_string);
#line 137
  print_usage();
#line 140
  tmp___0 = gettext("\nMandatory arguments to long options are mandatory for short options too.\n\n");
#line 140
  fputs((char const   */* __restrict  */)tmp___0, (FILE */* __restrict  */)stdout);
#line 144
  tmp___1 = gettext("Startup:\n  -V,  --version           display the version of Wget and exit.\n  -h,  --help              print this help.\n  -b,  --background        go to background after startup.\n  -e,  --execute=COMMAND   execute a `.wgetrc\'-style command.\n\n");
#line 144
  fputs((char const   */* __restrict  */)tmp___1, (FILE */* __restrict  */)stdout);
#line 151
  tmp___2 = gettext("Logging and input file:\n  -o,  --output-file=FILE     log messages to FILE.\n  -a,  --append-output=FILE   append messages to FILE.\n  -d,  --debug                print debug output.\n  -q,  --quiet                quiet (no output).\n  -v,  --verbose              be verbose (this is the default).\n  -nv, --non-verbose          turn off verboseness, without being quiet.\n  -i,  --input-file=FILE      download URLs found in FILE.\n  -F,  --force-html           treat input file as HTML.\n  -B,  --base=URL             prepends URL to relative links in -F -i file.\n\n");
#line 151
  fputs((char const   */* __restrict  */)tmp___2, (FILE */* __restrict  */)stdout);
#line 163
  tmp___3 = gettext("Download:\n  -t,  --tries=NUMBER           set number of retries to NUMBER (0 unlimits).\n       --retry-connrefused      retry even if connection is refused.\n  -O   --output-document=FILE   write documents to FILE.\n  -nc, --no-clobber             don\'t clobber existing files or use .# suffixes.\n  -c,  --continue               resume getting a partially-downloaded file.\n       --progress=TYPE          select progress gauge type.\n  -N,  --timestamping           don\'t re-retrieve files unless newer than local.\n  -S,  --server-response        print server response.\n       --spider                 don\'t download anything.\n  -T,  --timeout=SECONDS        set all timeout values to SECONDS.\n       --dns-timeout=SECS       set the DNS lookup timeout to SECS.\n       --connect-timeout=SECS   set the connect timeout to SECS.\n       --read-timeout=SECS      set the read timeout to SECS.\n  -w,  --wait=SECONDS           wait SECONDS between retrievals.\n       --waitretry=SECONDS      wait 1...SECONDS between retries of a retrieval.\n       --random-wait            wait from 0...2*WAIT secs between retrievals.\n  -Y,  --proxy=on/off           turn proxy on or off.\n  -Q,  --quota=NUMBER           set retrieval quota to NUMBER.\n       --bind-address=ADDRESS   bind to ADDRESS (hostname or IP) on local host.\n       --limit-rate=RATE        limit download rate to RATE.\n       --dns-cache=off          disable caching DNS lookups.\n       --restrict-file-names=OS restrict chars in file names to ones OS allows.\n\n");
#line 163
  fputs((char const   */* __restrict  */)tmp___3, (FILE */* __restrict  */)stdout);
#line 188
  tmp___4 = gettext("Directories:\n  -nd, --no-directories            don\'t create directories.\n  -x,  --force-directories         force creation of directories.\n  -nH, --no-host-directories       don\'t create host directories.\n  -P,  --directory-prefix=PREFIX   save files to PREFIX/...\n       --cut-dirs=NUMBER           ignore NUMBER remote directory components.\n\n");
#line 188
  fputs((char const   */* __restrict  */)tmp___4, (FILE */* __restrict  */)stdout);
#line 196
  tmp___5 = gettext("HTTP options:\n       --http-user=USER      set http user to USER.\n       --http-passwd=PASS    set http password to PASS.\n  -C,  --cache=on/off        (dis)allow server-cached data (normally allowed).\n  -E,  --html-extension      save all text/html documents with .html extension.\n       --ignore-length       ignore `Content-Length\' header field.\n       --header=STRING       insert STRING among the headers.\n       --proxy-user=USER     set USER as proxy username.\n       --proxy-passwd=PASS   set PASS as proxy password.\n       --referer=URL         include `Referer: URL\' header in HTTP request.\n  -s,  --save-headers        save the HTTP headers to file.\n  -U,  --user-agent=AGENT    identify as AGENT instead of Wget/VERSION.\n       --no-http-keep-alive  disable HTTP keep-alive (persistent connections).\n       --cookies=off         don\'t use cookies.\n       --load-cookies=FILE   load cookies from FILE before session.\n       --save-cookies=FILE   save cookies to FILE after session.\n       --post-data=STRING    use the POST method; send STRING as the data.\n       --post-file=FILE      use the POST method; send contents of FILE.\n\n");
#line 196
  fputs((char const   */* __restrict  */)tmp___5, (FILE */* __restrict  */)stdout);
#line 217
  tmp___6 = gettext("HTTPS (SSL) options:\n       --sslcertfile=FILE     optional client certificate.\n       --sslcertkey=KEYFILE   optional keyfile for this certificate.\n       --egd-file=FILE        file name of the EGD socket.\n       --sslcadir=DIR         dir where hash list of CA\'s are stored.\n       --sslcafile=FILE       file with bundle of CA\'s\n       --sslcerttype=0/1      Client-Cert type 0=PEM (default) / 1=ASN1 (DER)\n       --sslcheckcert=0/1     Check the server cert agenst given CA\n       --sslprotocol=0-3      choose SSL protocol; 0=automatic,\n                              1=SSLv2 2=SSLv3 3=TLSv1\n\n");
#line 217
  fputs((char const   */* __restrict  */)tmp___6, (FILE */* __restrict  */)stdout);
#line 230
  tmp___7 = gettext("FTP options:\n  -nr, --dont-remove-listing   don\'t remove `.listing\' files.\n  -g,  --glob=on/off           turn file name globbing on or off.\n       --passive-ftp           use the \"passive\" transfer mode.\n       --retr-symlinks         when recursing, get linked-to files (not dirs).\n\n");
#line 230
  fputs((char const   */* __restrict  */)tmp___7, (FILE */* __restrict  */)stdout);
#line 237
  tmp___8 = gettext("Recursive retrieval:\n  -r,  --recursive          recursive download.\n  -l,  --level=NUMBER       maximum recursion depth (inf or 0 for infinite).\n       --delete-after       delete files locally after downloading them.\n  -k,  --convert-links      convert non-relative links to relative.\n  -K,  --backup-converted   before converting file X, back up as X.orig.\n  -m,  --mirror             shortcut option equivalent to -r -N -l inf -nr.\n  -p,  --page-requisites    get all images, etc. needed to display HTML page.\n       --strict-comments    turn on strict (SGML) handling of HTML comments.\n\n");
#line 237
  fputs((char const   */* __restrict  */)tmp___8, (FILE */* __restrict  */)stdout);
#line 248
  tmp___9 = gettext("Recursive accept/reject:\n  -A,  --accept=LIST                comma-separated list of accepted extensions.\n  -R,  --reject=LIST                comma-separated list of rejected extensions.\n  -D,  --domains=LIST               comma-separated list of accepted domains.\n       --exclude-domains=LIST       comma-separated list of rejected domains.\n       --follow-ftp                 follow FTP links from HTML documents.\n       --follow-tags=LIST           comma-separated list of followed HTML tags.\n  -G,  --ignore-tags=LIST           comma-separated list of ignored HTML tags.\n  -H,  --span-hosts                 go to foreign hosts when recursive.\n  -L,  --relative                   follow relative links only.\n  -I,  --include-directories=LIST   list of allowed directories.\n  -X,  --exclude-directories=LIST   list of excluded directories.\n  -np, --no-parent                  don\'t ascend to the parent directory.\n\n");
#line 248
  fputs((char const   */* __restrict  */)tmp___9, (FILE */* __restrict  */)stdout);
#line 263
  tmp___10 = gettext("Mail bug reports and suggestions to <bug-wget@gnu.org>.\n");
#line 263
  fputs((char const   */* __restrict  */)tmp___10, (FILE */* __restrict  */)stdout);
  }
#line 265
  return;
}
}
#line 273
int main(int argc , char * const  *argv ) ;
#line 273 "main.c"
static struct option long_options[97]  = 
#line 273
  {      {"background", 0, (int *)((void *)0), 'b'}, 
        {"backup-converted", 0, (int *)((void *)0), 'K'}, 
        {"continue", 0, (int *)((void *)0), 'c'}, 
        {"convert-links", 0, (int *)((void *)0), 'k'}, 
        {"debug", 0, (int *)((void *)0), 'd'}, 
        {"delete-after", 0, (int *)((void *)0), 136}, 
        {"dont-remove-listing", 0, (int *)((void *)0), 149}, 
        {"follow-ftp", 0, (int *)((void *)0), 142}, 
        {"force-directories", 0, (int *)((void *)0), 'x'}, 
        {"force-hier", 0, (int *)((void *)0), 'x'}, 
        {"force-html", 0, (int *)((void *)0), 'F'}, 
        {"help", 0, (int *)((void *)0), 'h'}, 
        {"html-extension", 0, (int *)((void *)0), 'E'}, 
        {"ignore-length", 0, (int *)((void *)0), 138}, 
        {"mirror", 0, (int *)((void *)0), 'm'}, 
        {"no-clobber", 0, (int *)((void *)0), 141}, 
        {"no-directories", 0, (int *)((void *)0), 147}, 
        {"no-host-directories", 0, (int *)((void *)0), 148}, 
        {"no-host-lookup", 0, (int *)((void *)0), 150}, 
        {"no-http-keep-alive", 0, (int *)((void *)0), 156}, 
        {"no-parent", 0, (int *)((void *)0), 133}, 
        {"non-verbose", 0, (int *)((void *)0), 146}, 
        {"passive-ftp", 0, (int *)((void *)0), 139}, 
        {"page-requisites", 0, (int *)((void *)0), 'p'}, 
        {"quiet", 0, (int *)((void *)0), 'q'}, 
        {"random-wait", 0, (int *)((void *)0), 165}, 
        {"recursive", 0, (int *)((void *)0), 'r'}, 
        {"relative", 0, (int *)((void *)0), 'L'}, 
        {"retr-symlinks", 0, (int *)((void *)0), 137}, 
        {"retry-connrefused", 0, (int *)((void *)0), 174}, 
        {"save-headers", 0, (int *)((void *)0), 's'}, 
        {"server-response", 0, (int *)((void *)0), 'S'}, 
        {"span-hosts", 0, (int *)((void *)0), 'H'}, 
        {"spider", 0, (int *)((void *)0), 132}, 
        {"strict-comments", 0, (int *)((void *)0), 177}, 
        {"timestamping", 0, (int *)((void *)0), 'N'}, 
        {"verbose", 0, (int *)((void *)0), 'v'}, 
        {"version", 0, (int *)((void *)0), 'V'}, 
        {"accept", 1, (int *)((void *)0), 'A'}, 
        {"append-output", 1, (int *)((void *)0), 'a'}, 
        {"backups", 1, (int *)((void *)0), 151}, 
        {"base", 1, (int *)((void *)0), 'B'}, 
        {"bind-address", 1, (int *)((void *)0), 155}, 
        {"cache", 1, (int *)((void *)0), 'C'}, 
        {"connect-timeout", 1, (int *)((void *)0), 180}, 
        {"cookies", 1, (int *)((void *)0), 160}, 
        {"cut-dirs", 1, (int *)((void *)0), 145}, 
        {"dns-timeout", 1, (int *)((void *)0), 178}, 
        {"directory-prefix", 1, (int *)((void *)0), 'P'}, 
        {"dns-cache", 1, (int *)((void *)0), 175}, 
        {"domains", 1, (int *)((void *)0), 'D'}, 
        {"dot-style", 1, (int *)((void *)0), 134}, 
        {"execute", 1, (int *)((void *)0), 'e'}, 
        {"exclude-directories", 1, (int *)((void *)0), 'X'}, 
        {"exclude-domains", 1, (int *)((void *)0), 140}, 
        {"follow-tags", 1, (int *)((void *)0), 153}, 
        {"glob", 1, (int *)((void *)0), 'g'}, 
        {"header", 1, (int *)((void *)0), 131}, 
        {"htmlify", 1, (int *)((void *)0), 135}, 
        {"http-passwd", 1, (int *)((void *)0), 130}, 
        {"http-user", 1, (int *)((void *)0), 129}, 
        {"ignore-tags", 1, (int *)((void *)0), 'G'}, 
        {"include-directories", 1, (int *)((void *)0), 'I'}, 
        {"input-file", 1, (int *)((void *)0), 'i'}, 
        {"level", 1, (int *)((void *)0), 'l'}, 
        {"limit-rate", 1, (int *)((void *)0), 164}, 
        {"load-cookies", 1, (int *)((void *)0), 161}, 
        {"no", 1, (int *)((void *)0), 'n'}, 
        {"output-document", 1, (int *)((void *)0), 'O'}, 
        {"output-file", 1, (int *)((void *)0), 'o'}, 
        {"post-data", 1, (int *)((void *)0), 167}, 
        {"post-file", 1, (int *)((void *)0), 168}, 
        {"progress", 1, (int *)((void *)0), 163}, 
        {"proxy", 1, (int *)((void *)0), 'Y'}, 
        {"proxy-passwd", 1, (int *)((void *)0), 144}, 
        {"proxy-user", 1, (int *)((void *)0), 143}, 
        {"quota", 1, (int *)((void *)0), 'Q'}, 
        {"read-timeout", 1, (int *)((void *)0), 179}, 
        {"reject", 1, (int *)((void *)0), 'R'}, 
        {"restrict-file-names", 1, (int *)((void *)0), 176}, 
        {"save-cookies", 1, (int *)((void *)0), 162}, 
        {"timeout", 1, (int *)((void *)0), 'T'}, 
        {"tries", 1, (int *)((void *)0), 't'}, 
        {"user-agent", 1, (int *)((void *)0), 'U'}, 
        {"referer", 1, (int *)((void *)0), 157}, 
        {"use-proxy", 1, (int *)((void *)0), 'Y'}, 
        {"sslcertfile", 1, (int *)((void *)0), 158}, 
        {"sslcertkey", 1, (int *)((void *)0), 159}, 
        {"egd-file", 1, (int *)((void *)0), 166}, 
        {"sslcadir", 1, (int *)((void *)0), 169}, 
        {"sslcafile", 1, (int *)((void *)0), 170}, 
        {"sslcerttype", 1, (int *)((void *)0), 171}, 
        {"sslcheckcert", 1, (int *)((void *)0), 172}, 
        {"sslprotocol", 1, (int *)((void *)0), 173}, 
        {"wait", 1, (int *)((void *)0), 'w'}, 
        {"waitretry", 1, (int *)((void *)0), 152}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 267 "main.c"
int main(int argc , char * const  *argv ) 
{ 
  char **url ;
  char **t ;
  int i ;
  int c ;
  int nurl ;
  int status ;
  int append_to_log ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *p ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  void *tmp___10 ;
  char *rewritten ;
  char *tmp___11 ;
  struct stat st ;
  char const   *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  __sighandler_t tmp___15 ;
  char *filename ;
  char *redirected_URL ;
  int dt ;
  uerr_t tmp___16 ;
  uerr_t tmp___17 ;
  enum url_scheme tmp___18 ;
  char *tmp___19 ;
  int *tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int count ;
  uerr_t tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;

  {
  {
#line 379
  i18n_initialize();
#line 381
  append_to_log = 0;
#line 384
  tmp = strrchr((char const   *)*(argv + 0), '/');
#line 384
  exec_name = (char const   *)tmp;
  }
#line 385
  if (! exec_name) {
#line 386
    exec_name = (char const   *)*(argv + 0);
  } else {
#line 388
    exec_name ++;
  }
  {
#line 394
  initialize();
  }
  {
#line 400
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 400
    c = getopt_long(argc, argv, "hpVqvdkKsxmNWrHSLcFbEY:G:g:T:U:O:l:n:i:o:a:t:D:A:R:P:B:e:Q:X:I:w:C:",
                    (struct option  const  *)(long_options), (int *)0);
    }
#line 400
    if (! (c != -1)) {
#line 400
      goto while_break;
    }
    {
#line 407
    if (c == 132) {
#line 407
      goto case_132;
    }
#line 410
    if (c == 133) {
#line 410
      goto case_133;
    }
#line 413
    if (c == 136) {
#line 413
      goto case_136;
    }
#line 416
    if (c == 137) {
#line 416
      goto case_137;
    }
#line 419
    if (c == 138) {
#line 419
      goto case_138;
    }
#line 422
    if (c == 139) {
#line 422
      goto case_139;
    }
#line 425
    if (c == 141) {
#line 425
      goto case_141;
    }
#line 428
    if (c == 142) {
#line 428
      goto case_142;
    }
#line 431
    if (c == 145) {
#line 431
      goto case_145;
    }
#line 434
    if (c == 146) {
#line 434
      goto case_146;
    }
#line 437
    if (c == 147) {
#line 437
      goto case_147;
    }
#line 440
    if (c == 148) {
#line 440
      goto case_148;
    }
#line 443
    if (c == 149) {
#line 443
      goto case_149;
    }
#line 446
    if (c == 155) {
#line 446
      goto case_155;
    }
#line 449
    if (c == 156) {
#line 449
      goto case_156;
    }
#line 452
    if (c == 165) {
#line 452
      goto case_165;
    }
#line 455
    if (c == 98) {
#line 455
      goto case_98;
    }
#line 458
    if (c == 99) {
#line 458
      goto case_99;
    }
#line 461
    if (c == 100) {
#line 461
      goto case_100;
    }
#line 469
    if (c == 69) {
#line 469
      goto case_69;
    }
#line 472
    if (c == 70) {
#line 472
      goto case_70;
    }
#line 475
    if (c == 72) {
#line 475
      goto case_72;
    }
#line 478
    if (c == 104) {
#line 478
      goto case_104;
    }
#line 485
    if (c == 75) {
#line 485
      goto case_75;
    }
#line 488
    if (c == 107) {
#line 488
      goto case_107;
    }
#line 491
    if (c == 76) {
#line 491
      goto case_76;
    }
#line 494
    if (c == 109) {
#line 494
      goto case_109;
    }
#line 497
    if (c == 78) {
#line 497
      goto case_78;
    }
#line 500
    if (c == 112) {
#line 500
      goto case_112;
    }
#line 503
    if (c == 83) {
#line 503
      goto case_83;
    }
#line 506
    if (c == 115) {
#line 506
      goto case_115;
    }
#line 509
    if (c == 113) {
#line 509
      goto case_113;
    }
#line 512
    if (c == 114) {
#line 512
      goto case_114;
    }
#line 515
    if (c == 86) {
#line 515
      goto case_86;
    }
#line 527
    if (c == 118) {
#line 527
      goto case_118;
    }
#line 530
    if (c == 120) {
#line 530
      goto case_120;
    }
#line 533
    if (c == 174) {
#line 533
      goto case_174;
    }
#line 536
    if (c == 177) {
#line 536
      goto case_177;
    }
#line 541
    if (c == 129) {
#line 541
      goto case_129;
    }
#line 544
    if (c == 130) {
#line 544
      goto case_130;
    }
#line 547
    if (c == 131) {
#line 547
      goto case_131;
    }
#line 550
    if (c == 134) {
#line 550
      goto case_134;
    }
#line 553
    if (c == 135) {
#line 553
      goto case_135;
    }
#line 556
    if (c == 140) {
#line 556
      goto case_140;
    }
#line 559
    if (c == 143) {
#line 559
      goto case_143;
    }
#line 562
    if (c == 144) {
#line 562
      goto case_144;
    }
#line 565
    if (c == 151) {
#line 565
      goto case_151;
    }
#line 568
    if (c == 152) {
#line 568
      goto case_152;
    }
#line 571
    if (c == 153) {
#line 571
      goto case_153;
    }
#line 574
    if (c == 160) {
#line 574
      goto case_160;
    }
#line 577
    if (c == 161) {
#line 577
      goto case_161;
    }
#line 580
    if (c == 162) {
#line 580
      goto case_162;
    }
#line 583
    if (c == 163) {
#line 583
      goto case_163;
    }
#line 586
    if (c == 164) {
#line 586
      goto case_164;
    }
#line 589
    if (c == 157) {
#line 589
      goto case_157;
    }
#line 593
    if (c == 158) {
#line 593
      goto case_158;
    }
#line 596
    if (c == 159) {
#line 596
      goto case_159;
    }
#line 599
    if (c == 166) {
#line 599
      goto case_166;
    }
#line 602
    if (c == 169) {
#line 602
      goto case_169;
    }
#line 605
    if (c == 170) {
#line 605
      goto case_170;
    }
#line 608
    if (c == 171) {
#line 608
      goto case_171;
    }
#line 611
    if (c == 172) {
#line 611
      goto case_172;
    }
#line 614
    if (c == 173) {
#line 614
      goto case_173;
    }
#line 618
    if (c == 167) {
#line 618
      goto case_167;
    }
#line 621
    if (c == 168) {
#line 621
      goto case_168;
    }
#line 624
    if (c == 175) {
#line 624
      goto case_175;
    }
#line 627
    if (c == 176) {
#line 627
      goto case_176;
    }
#line 630
    if (c == 178) {
#line 630
      goto case_178;
    }
#line 633
    if (c == 179) {
#line 633
      goto case_179;
    }
#line 636
    if (c == 180) {
#line 636
      goto case_180;
    }
#line 639
    if (c == 65) {
#line 639
      goto case_65;
    }
#line 642
    if (c == 97) {
#line 642
      goto case_97;
    }
#line 646
    if (c == 66) {
#line 646
      goto case_66;
    }
#line 649
    if (c == 67) {
#line 649
      goto case_67;
    }
#line 652
    if (c == 68) {
#line 652
      goto case_68;
    }
#line 655
    if (c == 101) {
#line 655
      goto case_101;
    }
#line 658
    if (c == 71) {
#line 658
      goto case_71;
    }
#line 661
    if (c == 103) {
#line 661
      goto case_103;
    }
#line 664
    if (c == 73) {
#line 664
      goto case_73;
    }
#line 667
    if (c == 105) {
#line 667
      goto case_105;
    }
#line 670
    if (c == 108) {
#line 670
      goto case_108;
    }
#line 673
    if (c == 110) {
#line 673
      goto case_110;
    }
#line 711
    if (c == 79) {
#line 711
      goto case_79;
    }
#line 714
    if (c == 111) {
#line 714
      goto case_111;
    }
#line 717
    if (c == 80) {
#line 717
      goto case_80;
    }
#line 720
    if (c == 81) {
#line 720
      goto case_81;
    }
#line 723
    if (c == 82) {
#line 723
      goto case_82;
    }
#line 726
    if (c == 84) {
#line 726
      goto case_84;
    }
#line 729
    if (c == 116) {
#line 729
      goto case_116;
    }
#line 732
    if (c == 85) {
#line 732
      goto case_85;
    }
#line 735
    if (c == 119) {
#line 735
      goto case_119;
    }
#line 738
    if (c == 88) {
#line 738
      goto case_88;
    }
#line 741
    if (c == 89) {
#line 741
      goto case_89;
    }
#line 745
    if (c == 63) {
#line 745
      goto case_63;
    }
#line 404
    goto switch_break;
    case_132: /* CIL Label */ 
    {
#line 408
    setoptval("spider", "on");
    }
#line 409
    goto switch_break;
    case_133: /* CIL Label */ 
    {
#line 411
    setoptval("noparent", "on");
    }
#line 412
    goto switch_break;
    case_136: /* CIL Label */ 
    {
#line 414
    setoptval("deleteafter", "on");
    }
#line 415
    goto switch_break;
    case_137: /* CIL Label */ 
    {
#line 417
    setoptval("retrsymlinks", "on");
    }
#line 418
    goto switch_break;
    case_138: /* CIL Label */ 
    {
#line 420
    setoptval("ignorelength", "on");
    }
#line 421
    goto switch_break;
    case_139: /* CIL Label */ 
    {
#line 423
    setoptval("passiveftp", "on");
    }
#line 424
    goto switch_break;
    case_141: /* CIL Label */ 
    {
#line 426
    setoptval("noclobber", "on");
    }
#line 427
    goto switch_break;
    case_142: /* CIL Label */ 
    {
#line 429
    setoptval("followftp", "on");
    }
#line 430
    goto switch_break;
    case_145: /* CIL Label */ 
    {
#line 432
    setoptval("cutdirs", (char const   *)optarg);
    }
#line 433
    goto switch_break;
    case_146: /* CIL Label */ 
    {
#line 435
    setoptval("verbose", "off");
    }
#line 436
    goto switch_break;
    case_147: /* CIL Label */ 
    {
#line 438
    setoptval("dirstruct", "off");
    }
#line 439
    goto switch_break;
    case_148: /* CIL Label */ 
    {
#line 441
    setoptval("addhostdir", "off");
    }
#line 442
    goto switch_break;
    case_149: /* CIL Label */ 
    {
#line 444
    setoptval("removelisting", "off");
    }
#line 445
    goto switch_break;
    case_155: /* CIL Label */ 
    {
#line 447
    setoptval("bindaddress", (char const   *)optarg);
    }
#line 448
    goto switch_break;
    case_156: /* CIL Label */ 
    {
#line 450
    setoptval("httpkeepalive", "off");
    }
#line 451
    goto switch_break;
    case_165: /* CIL Label */ 
    {
#line 453
    setoptval("randomwait", "on");
    }
#line 454
    goto switch_break;
    case_98: /* CIL Label */ 
    {
#line 456
    setoptval("background", "on");
    }
#line 457
    goto switch_break;
    case_99: /* CIL Label */ 
    {
#line 459
    setoptval("continue", "on");
    }
#line 460
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 463
    setoptval("debug", "on");
    }
#line 468
    goto switch_break;
    case_69: /* CIL Label */ 
    {
#line 470
    setoptval("htmlextension", "on");
    }
#line 471
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 473
    setoptval("forcehtml", "on");
    }
#line 474
    goto switch_break;
    case_72: /* CIL Label */ 
    {
#line 476
    setoptval("spanhosts", "on");
    }
#line 477
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 479
    print_help();
#line 483
    exit(0);
    }
#line 484
    goto switch_break;
    case_75: /* CIL Label */ 
    {
#line 486
    setoptval("backupconverted", "on");
    }
#line 487
    goto switch_break;
    case_107: /* CIL Label */ 
    {
#line 489
    setoptval("convertlinks", "on");
    }
#line 490
    goto switch_break;
    case_76: /* CIL Label */ 
    {
#line 492
    setoptval("relativeonly", "on");
    }
#line 493
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 495
    setoptval("mirror", "on");
    }
#line 496
    goto switch_break;
    case_78: /* CIL Label */ 
    {
#line 498
    setoptval("timestamping", "on");
    }
#line 499
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 501
    setoptval("pagerequisites", "on");
    }
#line 502
    goto switch_break;
    case_83: /* CIL Label */ 
    {
#line 504
    setoptval("serverresponse", "on");
    }
#line 505
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 507
    setoptval("saveheaders", "on");
    }
#line 508
    goto switch_break;
    case_113: /* CIL Label */ 
    {
#line 510
    setoptval("quiet", "on");
    }
#line 511
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 513
    setoptval("recursive", "on");
    }
#line 514
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 516
    printf((char const   */* __restrict  */)"GNU Wget %s\n\n", version_string);
#line 517
    tmp___0 = gettext("Copyright (C) 2003 Free Software Foundation, Inc.\n");
#line 517
    printf((char const   */* __restrict  */)"%s", tmp___0);
#line 519
    tmp___1 = gettext("This program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n");
#line 519
    printf((char const   */* __restrict  */)"%s", tmp___1);
#line 524
    tmp___2 = gettext("\nOriginally written by Hrvoje Niksic <hniksic@xemacs.org>.\n");
#line 524
    printf((char const   */* __restrict  */)tmp___2);
#line 525
    exit(0);
    }
#line 526
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 528
    setoptval("verbose", "on");
    }
#line 529
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 531
    setoptval("dirstruct", "on");
    }
#line 532
    goto switch_break;
    case_174: /* CIL Label */ 
    {
#line 534
    setoptval("retryconnrefused", "on");
    }
#line 535
    goto switch_break;
    case_177: /* CIL Label */ 
    {
#line 537
    setoptval("strictcomments", "on");
    }
#line 538
    goto switch_break;
    case_129: /* CIL Label */ 
    {
#line 542
    setoptval("httpuser", (char const   *)optarg);
    }
#line 543
    goto switch_break;
    case_130: /* CIL Label */ 
    {
#line 545
    setoptval("httppasswd", (char const   *)optarg);
    }
#line 546
    goto switch_break;
    case_131: /* CIL Label */ 
    {
#line 548
    setoptval("header", (char const   *)optarg);
    }
#line 549
    goto switch_break;
    case_134: /* CIL Label */ 
    {
#line 551
    setoptval("dotstyle", (char const   *)optarg);
    }
#line 552
    goto switch_break;
    case_135: /* CIL Label */ 
    {
#line 554
    setoptval("htmlify", (char const   *)optarg);
    }
#line 555
    goto switch_break;
    case_140: /* CIL Label */ 
    {
#line 557
    setoptval("excludedomains", (char const   *)optarg);
    }
#line 558
    goto switch_break;
    case_143: /* CIL Label */ 
    {
#line 560
    setoptval("proxyuser", (char const   *)optarg);
    }
#line 561
    goto switch_break;
    case_144: /* CIL Label */ 
    {
#line 563
    setoptval("proxypasswd", (char const   *)optarg);
    }
#line 564
    goto switch_break;
    case_151: /* CIL Label */ 
    {
#line 566
    setoptval("backups", (char const   *)optarg);
    }
#line 567
    goto switch_break;
    case_152: /* CIL Label */ 
    {
#line 569
    setoptval("waitretry", (char const   *)optarg);
    }
#line 570
    goto switch_break;
    case_153: /* CIL Label */ 
    {
#line 572
    setoptval("followtags", (char const   *)optarg);
    }
#line 573
    goto switch_break;
    case_160: /* CIL Label */ 
    {
#line 575
    setoptval("cookies", (char const   *)optarg);
    }
#line 576
    goto switch_break;
    case_161: /* CIL Label */ 
    {
#line 578
    setoptval("loadcookies", (char const   *)optarg);
    }
#line 579
    goto switch_break;
    case_162: /* CIL Label */ 
    {
#line 581
    setoptval("savecookies", (char const   *)optarg);
    }
#line 582
    goto switch_break;
    case_163: /* CIL Label */ 
    {
#line 584
    setoptval("progress", (char const   *)optarg);
    }
#line 585
    goto switch_break;
    case_164: /* CIL Label */ 
    {
#line 587
    setoptval("limitrate", (char const   *)optarg);
    }
#line 588
    goto switch_break;
    case_157: /* CIL Label */ 
    {
#line 590
    setoptval("referer", (char const   *)optarg);
    }
#line 591
    goto switch_break;
    case_158: /* CIL Label */ 
    {
#line 594
    setoptval("sslcertfile", (char const   *)optarg);
    }
#line 595
    goto switch_break;
    case_159: /* CIL Label */ 
    {
#line 597
    setoptval("sslcertkey", (char const   *)optarg);
    }
#line 598
    goto switch_break;
    case_166: /* CIL Label */ 
    {
#line 600
    setoptval("egdfile", (char const   *)optarg);
    }
#line 601
    goto switch_break;
    case_169: /* CIL Label */ 
    {
#line 603
    setoptval("sslcadir", (char const   *)optarg);
    }
#line 604
    goto switch_break;
    case_170: /* CIL Label */ 
    {
#line 606
    setoptval("sslcafile", (char const   *)optarg);
    }
#line 607
    goto switch_break;
    case_171: /* CIL Label */ 
    {
#line 609
    setoptval("sslcerttype", (char const   *)optarg);
    }
#line 610
    goto switch_break;
    case_172: /* CIL Label */ 
    {
#line 612
    setoptval("sslcheckcert", (char const   *)optarg);
    }
#line 613
    goto switch_break;
    case_173: /* CIL Label */ 
    {
#line 615
    setoptval("sslprotocol", (char const   *)optarg);
    }
#line 616
    goto switch_break;
    case_167: /* CIL Label */ 
    {
#line 619
    setoptval("postdata", (char const   *)optarg);
    }
#line 620
    goto switch_break;
    case_168: /* CIL Label */ 
    {
#line 622
    setoptval("postfile", (char const   *)optarg);
    }
#line 623
    goto switch_break;
    case_175: /* CIL Label */ 
    {
#line 625
    setoptval("dnscache", (char const   *)optarg);
    }
#line 626
    goto switch_break;
    case_176: /* CIL Label */ 
    {
#line 628
    setoptval("restrictfilenames", (char const   *)optarg);
    }
#line 629
    goto switch_break;
    case_178: /* CIL Label */ 
    {
#line 631
    setoptval("dnstimeout", (char const   *)optarg);
    }
#line 632
    goto switch_break;
    case_179: /* CIL Label */ 
    {
#line 634
    setoptval("readtimeout", (char const   *)optarg);
    }
#line 635
    goto switch_break;
    case_180: /* CIL Label */ 
    {
#line 637
    setoptval("connecttimeout", (char const   *)optarg);
    }
#line 638
    goto switch_break;
    case_65: /* CIL Label */ 
    {
#line 640
    setoptval("accept", (char const   *)optarg);
    }
#line 641
    goto switch_break;
    case_97: /* CIL Label */ 
    {
#line 643
    setoptval("logfile", (char const   *)optarg);
#line 644
    append_to_log = 1;
    }
#line 645
    goto switch_break;
    case_66: /* CIL Label */ 
    {
#line 647
    setoptval("base", (char const   *)optarg);
    }
#line 648
    goto switch_break;
    case_67: /* CIL Label */ 
    {
#line 650
    setoptval("cache", (char const   *)optarg);
    }
#line 651
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 653
    setoptval("domains", (char const   *)optarg);
    }
#line 654
    goto switch_break;
    case_101: /* CIL Label */ 
    {
#line 656
    run_command((char const   *)optarg);
    }
#line 657
    goto switch_break;
    case_71: /* CIL Label */ 
    {
#line 659
    setoptval("ignoretags", (char const   *)optarg);
    }
#line 660
    goto switch_break;
    case_103: /* CIL Label */ 
    {
#line 662
    setoptval("glob", (char const   *)optarg);
    }
#line 663
    goto switch_break;
    case_73: /* CIL Label */ 
    {
#line 665
    setoptval("includedirectories", (char const   *)optarg);
    }
#line 666
    goto switch_break;
    case_105: /* CIL Label */ 
    {
#line 668
    setoptval("input", (char const   *)optarg);
    }
#line 669
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 671
    setoptval("reclevel", (char const   *)optarg);
    }
#line 672
    goto switch_break;
    case_110: /* CIL Label */ 
#line 678
    p = optarg;
    {
#line 678
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 678
      if (! *p) {
#line 678
        goto while_break___0;
      }
      {
#line 681
      if ((int )*p == 118) {
#line 681
        goto case_118___0;
      }
#line 684
      if ((int )*p == 72) {
#line 684
        goto case_72___0;
      }
#line 687
      if ((int )*p == 100) {
#line 687
        goto case_100___0;
      }
#line 690
      if ((int )*p == 99) {
#line 690
        goto case_99___0;
      }
#line 693
      if ((int )*p == 114) {
#line 693
        goto case_114___0;
      }
#line 696
      if ((int )*p == 112) {
#line 696
        goto case_112___0;
      }
#line 699
      if ((int )*p == 107) {
#line 699
        goto case_107___0;
      }
#line 702
      goto switch_default;
      case_118___0: /* CIL Label */ 
      {
#line 682
      setoptval("verbose", "off");
      }
#line 683
      goto switch_break___0;
      case_72___0: /* CIL Label */ 
      {
#line 685
      setoptval("addhostdir", "off");
      }
#line 686
      goto switch_break___0;
      case_100___0: /* CIL Label */ 
      {
#line 688
      setoptval("dirstruct", "off");
      }
#line 689
      goto switch_break___0;
      case_99___0: /* CIL Label */ 
      {
#line 691
      setoptval("noclobber", "on");
      }
#line 692
      goto switch_break___0;
      case_114___0: /* CIL Label */ 
      {
#line 694
      setoptval("removelisting", "off");
      }
#line 695
      goto switch_break___0;
      case_112___0: /* CIL Label */ 
      {
#line 697
      setoptval("noparent", "on");
      }
#line 698
      goto switch_break___0;
      case_107___0: /* CIL Label */ 
      {
#line 700
      setoptval("httpkeepalive", "off");
      }
#line 701
      goto switch_break___0;
      switch_default: /* CIL Label */ 
      {
#line 703
      tmp___3 = gettext("%s: illegal option -- `-n%c\'\n");
#line 703
      printf((char const   */* __restrict  */)tmp___3, exec_name, (int )*p);
#line 704
      print_usage();
#line 705
      printf((char const   */* __restrict  */)"\n");
#line 706
      tmp___4 = gettext("Try `%s --help\' for more options.\n");
#line 706
      printf((char const   */* __restrict  */)tmp___4, exec_name);
#line 707
      exit(1);
      }
      switch_break___0: /* CIL Label */ ;
      }
#line 678
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 709
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 712
    setoptval("outputdocument", (char const   *)optarg);
    }
#line 713
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 715
    setoptval("logfile", (char const   *)optarg);
    }
#line 716
    goto switch_break;
    case_80: /* CIL Label */ 
    {
#line 718
    setoptval("dirprefix", (char const   *)optarg);
    }
#line 719
    goto switch_break;
    case_81: /* CIL Label */ 
    {
#line 721
    setoptval("quota", (char const   *)optarg);
    }
#line 722
    goto switch_break;
    case_82: /* CIL Label */ 
    {
#line 724
    setoptval("reject", (char const   *)optarg);
    }
#line 725
    goto switch_break;
    case_84: /* CIL Label */ 
    {
#line 727
    setoptval("timeout", (char const   *)optarg);
    }
#line 728
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 730
    setoptval("tries", (char const   *)optarg);
    }
#line 731
    goto switch_break;
    case_85: /* CIL Label */ 
    {
#line 733
    setoptval("useragent", (char const   *)optarg);
    }
#line 734
    goto switch_break;
    case_119: /* CIL Label */ 
    {
#line 736
    setoptval("wait", (char const   *)optarg);
    }
#line 737
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 739
    setoptval("excludedirectories", (char const   *)optarg);
    }
#line 740
    goto switch_break;
    case_89: /* CIL Label */ 
    {
#line 742
    setoptval("useproxy", (char const   *)optarg);
    }
#line 743
    goto switch_break;
    case_63: /* CIL Label */ 
    {
#line 746
    print_usage();
#line 747
    printf((char const   */* __restrict  */)"\n");
#line 748
    tmp___5 = gettext("Try `%s --help\' for more options.\n");
#line 748
    printf((char const   */* __restrict  */)tmp___5, exec_name);
#line 749
    exit(0);
    }
#line 750
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 757
  if (opt.reclevel == 0) {
#line 758
    opt.reclevel = -1;
  }
#line 760
  if (opt.page_requisites) {
#line 760
    if (! opt.recursive) {
#line 762
      opt.recursive = 1;
#line 763
      opt.reclevel = 0;
#line 764
      if (! opt.no_dirstruct) {
#line 765
        opt.dirstruct = 1;
      }
    }
  }
#line 768
  if (opt.verbose == -1) {
#line 769
    opt.verbose = ! opt.quiet;
  }
#line 772
  if (opt.verbose) {
#line 772
    if (opt.quiet) {
      {
#line 774
      tmp___6 = gettext("Can\'t be verbose and quiet at the same time.\n");
#line 774
      printf((char const   */* __restrict  */)tmp___6);
#line 775
      print_usage();
#line 776
      exit(1);
      }
    }
  }
#line 778
  if (opt.timestamping) {
#line 778
    if (opt.noclobber) {
      {
#line 780
      tmp___7 = gettext("Can\'t timestamp and not clobber old files at the same time.\n");
#line 780
      printf((char const   */* __restrict  */)tmp___7);
#line 782
      print_usage();
#line 783
      exit(1);
      }
    }
  }
#line 785
  nurl = argc - optind;
#line 786
  if (! nurl) {
#line 786
    if (! opt.input_filename) {
      {
#line 789
      tmp___8 = gettext("%s: missing URL\n");
#line 789
      printf((char const   */* __restrict  */)tmp___8, exec_name);
#line 790
      print_usage();
#line 791
      printf((char const   */* __restrict  */)"\n");
#line 794
      tmp___9 = gettext("Try `%s --help\' for more options.\n");
#line 794
      printf((char const   */* __restrict  */)tmp___9, exec_name);
#line 795
      exit(1);
      }
    }
  }
#line 798
  if (opt.background) {
    {
#line 799
    fork_to_background();
    }
  }
#line 803
  if (opt.verbose) {
    {
#line 804
    set_progress_implementation((char const   *)opt.progress_type);
    }
  }
  {
#line 807
  tmp___10 = __builtin_alloca((unsigned long )(nurl + 1) * sizeof(char *));
#line 807
  url = (char **)tmp___10;
#line 808
  i = 0;
  }
  {
#line 808
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 808
    if (! (i < nurl)) {
#line 808
      goto while_break___1;
    }
    {
#line 810
    tmp___11 = rewrite_shorthand_url((char const   *)*(argv + optind));
#line 810
    rewritten = tmp___11;
    }
#line 811
    if (rewritten) {
#line 812
      *(url + i) = rewritten;
    } else {
      {
#line 814
      *(url + i) = xstrdup_real((char const   *)*(argv + optind));
      }
    }
#line 808
    i ++;
#line 808
    optind ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 816
  *(url + i) = (char *)((void *)0);
#line 825
  log_init((char const   *)opt.lfilename, append_to_log);
  }
  {
#line 827
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 827
    if (opt.debug) {
      {
#line 827
      debug_logprintf("DEBUG output created by Wget %s on %s.\n\n", version_string,
                      "linux-gnu");
      }
    }
#line 827
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 831
  if (opt.output_document) {
#line 833
    if ((int )*(opt.output_document) == 45) {
#line 833
      if (! *(opt.output_document + 1)) {
#line 834
        opt.dfp = stdout;
      } else {
#line 833
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 838
      if (opt.always_rest) {
#line 838
        tmp___12 = "ab";
      } else {
#line 838
        tmp___12 = "wb";
      }
      {
#line 838
      opt.dfp = fopen((char const   */* __restrict  */)opt.output_document, (char const   */* __restrict  */)tmp___12);
      }
#line 839
      if ((unsigned long )opt.dfp == (unsigned long )((void *)0)) {
        {
#line 841
        perror((char const   *)opt.output_document);
#line 842
        exit(1);
        }
      }
      {
#line 844
      tmp___13 = fileno(opt.dfp);
#line 844
      tmp___14 = fstat(tmp___13, & st);
      }
#line 844
      if (tmp___14 == 0) {
#line 844
        if ((st.st_mode & 61440U) == 32768U) {
#line 845
          opt.od_known_regular = 1;
        }
      }
    }
  }
  {
#line 856
  tmp___15 = signal(1, (void (*)(int  ))1);
  }
#line 856
  if ((unsigned long )tmp___15 != (unsigned long )((void (*)(int  ))1)) {
    {
#line 857
    signal(1, & redirect_output_signal);
    }
  }
  {
#line 859
  signal(10, & redirect_output_signal);
#line 863
  signal(13, (void (*)(int  ))1);
#line 865
  signal(28, & progress_handle_sigwinch);
#line 872
  ssl_init_prng();
#line 875
  status = 34;
#line 877
  t = url;
  }
  {
#line 877
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 877
    if (! *t) {
#line 877
      goto while_break___3;
    }
#line 879
    filename = (char *)((void *)0);
#line 879
    redirected_URL = (char *)((void *)0);
#line 882
    if (opt.recursive) {
      {
#line 882
      tmp___18 = url_scheme((char const   *)*t);
      }
#line 882
      if ((unsigned int )tmp___18 != 2U) {
        {
#line 883
        tmp___16 = retrieve_tree((char const   *)*t);
#line 883
        status = (int )tmp___16;
        }
      } else {
        {
#line 885
        tmp___17 = retrieve_url((char const   *)*t, & filename, & redirected_URL,
                                (char const   *)((void *)0), & dt);
#line 885
        status = (int )tmp___17;
        }
      }
    } else {
      {
#line 885
      tmp___17 = retrieve_url((char const   *)*t, & filename, & redirected_URL, (char const   *)((void *)0),
                              & dt);
#line 885
      status = (int )tmp___17;
      }
    }
#line 887
    if (opt.delete_after) {
      {
#line 887
      tmp___23 = file_exists_p((char const   *)filename);
      }
#line 887
      if (tmp___23) {
        {
#line 889
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 889
          if (opt.debug) {
            {
#line 889
            debug_logprintf("Removing file due to --delete-after in main():\n");
            }
          }
#line 889
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 890
        tmp___19 = gettext("Removing %s.\n");
#line 890
        logprintf((enum log_options )0, (char const   *)tmp___19, filename);
#line 891
        tmp___22 = unlink((char const   *)filename);
        }
#line 891
        if (tmp___22) {
          {
#line 892
          tmp___20 = __errno_location();
#line 892
          tmp___21 = strerror(*tmp___20);
#line 892
          logprintf((enum log_options )1, "unlink: %s\n", tmp___21);
          }
        }
      }
    }
    {
#line 895
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 895
      if (redirected_URL) {
        {
#line 895
        free((void *)redirected_URL);
        }
      }
#line 895
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 896
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 896
      if (filename) {
        {
#line 896
        free((void *)filename);
        }
      }
#line 896
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 877
    t ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 900
  if (opt.input_filename) {
    {
#line 903
    tmp___24 = retrieve_from_file((char const   *)opt.input_filename, opt.force_html,
                                  & count);
#line 903
    status = (int )tmp___24;
    }
#line 904
    if (! count) {
      {
#line 905
      tmp___25 = gettext("No URLs found in %s.\n");
#line 905
      logprintf((enum log_options )1, (char const   *)tmp___25, opt.input_filename);
      }
    }
  }
#line 909
  if (opt.recursive) {
#line 909
    goto _L___0;
  } else
#line 909
  if (nurl > 1) {
#line 909
    goto _L___0;
  } else
#line 909
  if (opt.input_filename) {
#line 909
    if (total_downloaded_bytes != 0LL) {
      _L___0: /* CIL Label */ 
      {
#line 913
      tmp___26 = legible_large_int(total_downloaded_bytes);
#line 913
      tmp___27 = time_str((time_t *)((void *)0));
#line 913
      tmp___28 = gettext("\nFINISHED --%s--\nDownloaded: %s bytes in %d files\n");
#line 913
      logprintf((enum log_options )1, (char const   *)tmp___28, tmp___27, tmp___26,
                opt.numurls);
      }
#line 918
      if (opt.quota) {
#line 918
        if (total_downloaded_bytes > opt.quota) {
          {
#line 919
          tmp___29 = legible((long )opt.quota);
#line 919
          tmp___30 = gettext("Download quota (%s bytes) EXCEEDED!\n");
#line 919
          logprintf((enum log_options )1, (char const   *)tmp___30, tmp___29);
          }
        }
      }
    }
  }
#line 924
  if (opt.cookies_output) {
#line 924
    if (wget_cookie_jar) {
      {
#line 925
      cookie_jar_save(wget_cookie_jar, (char const   *)opt.cookies_output);
      }
    }
  }
#line 927
  if (opt.convert_links) {
#line 927
    if (! opt.delete_after) {
      {
#line 928
      convert_all_links();
      }
    }
  }
  {
#line 930
  log_close();
#line 931
  i = 0;
  }
  {
#line 931
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 931
    if (! (i < nurl)) {
#line 931
      goto while_break___7;
    }
    {
#line 932
    free((void *)*(url + i));
#line 931
    i ++;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 933
  cleanup();
  }
#line 938
  if (status == 34) {
#line 939
    return (0);
  } else {
#line 941
    return (1);
  }
}
}
#line 953 "main.c"
static void redirect_output_signal(int sig ) 
{ 
  char *signal_name ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 956
  if (sig == 1) {
#line 956
    tmp___0 = "SIGHUP";
  } else {
#line 956
    if (sig == 10) {
#line 956
      tmp = "SIGUSR1";
    } else {
#line 956
      tmp = "WTF?!";
    }
#line 956
    tmp___0 = tmp;
  }
  {
#line 956
  signal_name = (char *)tmp___0;
#line 959
  log_request_redirect_output((char const   *)signal_name);
#line 960
  progress_schedule_redirect();
#line 961
  signal(sig, & redirect_output_signal);
  }
#line 962
  return;
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 336 "/usr/include/stdio.h"
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 355
extern int ( /* format attribute */  vsnprintf)(char * __restrict  __s , size_t __maxlen ,
                                                char const   * __restrict  __format ,
                                                __gnuc_va_list __arg ) ;
#line 120 "wget.h"
void logflush(void) ;
#line 93 "log.c"
static FILE *logfp  ;
#line 97 "log.c"
static int inhibit_logging  ;
#line 100 "log.c"
static int save_context_p  ;
#line 103 "log.c"
static int flush_log_p  =    1;
#line 106 "log.c"
static int needs_flushing  ;
#line 132 "log.c"
static struct log_ln log_lines[24]  ;
#line 144 "log.c"
static int log_line_current  =    -1;
#line 150 "log.c"
static int trailing_line  ;
#line 152
static void check_redirect_output(void) ;
#line 163 "log.c"
static void free_log_line(int num ) 
{ 
  struct log_ln *ln ;

  {
#line 166
  ln = log_lines + num;
#line 167
  if (ln->malloced_line) {
    {
#line 169
    free((void *)ln->malloced_line);
#line 170
    ln->malloced_line = (char *)((void *)0);
    }
  }
#line 172
  ln->content = (char *)((void *)0);
#line 173
  return;
}
}
#line 179 "log.c"
static void saved_append_1(char const   *start , char const   *end ) 
{ 
  int len ;
  struct log_ln *ln ;
  struct log_ln *ln___0 ;
  int old_len ;
  size_t tmp ;
  void *tmp___0 ;
  int old_len___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
#line 182
  len = (int )(end - start);
#line 183
  if (! len) {
#line 184
    return;
  }
#line 188
  if (! trailing_line) {
#line 193
    if (log_line_current == -1) {
#line 194
      log_line_current = 0;
    } else {
      {
#line 196
      free_log_line(log_line_current);
      }
    }
#line 197
    ln = log_lines + log_line_current;
#line 198
    if (len > 128) {
      {
#line 200
      ln->malloced_line = strdupdelim(start, end);
#line 201
      ln->content = ln->malloced_line;
      }
    } else {
      {
#line 205
      memcpy((void */* __restrict  */)(ln->static_line), (void const   */* __restrict  */)start,
             (size_t )len);
#line 206
      ln->static_line[len] = (char )'\000';
#line 207
      ln->content = ln->static_line;
      }
    }
  } else {
#line 217
    ln___0 = log_lines + log_line_current;
#line 218
    if (ln___0->malloced_line) {
      {
#line 221
      tmp = strlen((char const   *)ln___0->malloced_line);
#line 221
      old_len = (int )tmp;
#line 222
      tmp___0 = xrealloc_real((void *)ln___0->malloced_line, (size_t )((old_len + len) + 1));
#line 222
      ln___0->malloced_line = (char *)tmp___0;
#line 223
      memcpy((void */* __restrict  */)(ln___0->malloced_line + old_len), (void const   */* __restrict  */)start,
             (size_t )len);
#line 224
      *(ln___0->malloced_line + (old_len + len)) = (char )'\000';
#line 226
      ln___0->content = ln___0->malloced_line;
      }
    } else {
      {
#line 230
      tmp___1 = strlen((char const   *)(ln___0->static_line));
#line 230
      old_len___0 = (int )tmp___1;
      }
#line 231
      if (old_len___0 + len > 128) {
        {
#line 235
        tmp___2 = xmalloc_real((size_t )((old_len___0 + len) + 1));
#line 235
        ln___0->malloced_line = (char *)tmp___2;
#line 236
        memcpy((void */* __restrict  */)ln___0->malloced_line, (void const   */* __restrict  */)(ln___0->static_line),
               (size_t )old_len___0);
#line 238
        memcpy((void */* __restrict  */)(ln___0->malloced_line + old_len___0), (void const   */* __restrict  */)start,
               (size_t )len);
#line 239
        *(ln___0->malloced_line + (old_len___0 + len)) = (char )'\000';
#line 240
        ln___0->content = ln___0->malloced_line;
        }
      } else {
        {
#line 246
        memcpy((void */* __restrict  */)(ln___0->static_line + old_len___0), (void const   */* __restrict  */)start,
               (size_t )len);
#line 247
        ln___0->static_line[old_len___0 + len] = (char )'\000';
#line 248
        ln___0->content = ln___0->static_line;
        }
      }
    }
  }
#line 252
  trailing_line = ! ((int const   )*(end + -1) == 10);
#line 253
  if (! trailing_line) {
    {
#line 254
    while (1) {
      while_continue: /* CIL Label */ ;
#line 254
      log_line_current ++;
#line 254
      if (log_line_current >= 24) {
#line 254
        log_line_current = 0;
      }
#line 254
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 255
  return;
}
}
#line 262 "log.c"
static void saved_append(char const   *s ) 
{ 
  char const   *end ;
  char *tmp ;
  size_t tmp___0 ;

  {
  {
#line 265
  while (1) {
    while_continue: /* CIL Label */ ;
#line 265
    if (! *s) {
#line 265
      goto while_break;
    }
    {
#line 267
    tmp = strchr(s, '\n');
#line 267
    end = (char const   *)tmp;
    }
#line 268
    if (! end) {
      {
#line 269
      tmp___0 = strlen(s);
#line 269
      end = s + tmp___0;
      }
    } else {
#line 271
      end ++;
    }
    {
#line 272
    saved_append_1(s, end);
#line 273
    s = end;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 275
  return;
}
}
#line 311 "log.c"
static FILE *get_log_fp(void) 
{ 


  {
#line 314
  if (inhibit_logging) {
#line 315
    return ((FILE *)((void *)0));
  }
#line 316
  if (logfp) {
#line 317
    return (logfp);
  }
#line 318
  return (stderr);
}
}
#line 324 "log.c"
void logputs(enum log_options o , char const   *s ) 
{ 
  FILE *fp ;

  {
  {
#line 329
  check_redirect_output();
#line 330
  fp = get_log_fp();
  }
#line 330
  if (! fp) {
#line 331
    return;
  }
  {
#line 332
  if ((unsigned int )o == 3U) {
#line 332
    goto case_3;
  }
#line 332
  if ((unsigned int )o == 1U) {
#line 332
    goto case_1;
  }
#line 332
  if ((unsigned int )o == 2U) {
#line 332
    goto case_2;
  }
#line 332
  if ((unsigned int )o == 0U) {
#line 332
    goto case_0;
  }
#line 332
  goto switch_break;
  case_3: /* CIL Label */ 
#line 332
  goto switch_break;
  case_1: /* CIL Label */ 
#line 332
  if (opt.quiet) {
#line 332
    return;
  }
#line 332
  goto switch_break;
  case_2: /* CIL Label */ 
#line 332
  if (opt.verbose) {
#line 332
    return;
  } else
#line 332
  if (opt.quiet) {
#line 332
    return;
  }
#line 332
  goto switch_break;
  case_0: /* CIL Label */ 
#line 332
  if (! opt.verbose) {
#line 332
    return;
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 334
  fputs((char const   */* __restrict  */)s, (FILE */* __restrict  */)fp);
  }
#line 335
  if (save_context_p) {
    {
#line 336
    saved_append(s);
    }
  }
#line 337
  if (flush_log_p) {
    {
#line 338
    logflush();
    }
  } else {
#line 340
    needs_flushing = 1;
  }
#line 341
  return;
}
}
#line 359 "log.c"
static int logvprintf(struct logvprintf_state *state , char const   *fmt , va_list args ) 
{ 
  char smallmsg[128] ;
  char *write_ptr ;
  int available_size ;
  int numwritten ;
  FILE *fp ;
  FILE *tmp ;
  int newsize ;
  void *tmp___0 ;
  int newsize___0 ;
  void *tmp___1 ;

  {
  {
#line 363
  write_ptr = smallmsg;
#line 364
  available_size = (int )sizeof(smallmsg);
#line 366
  tmp = get_log_fp();
#line 366
  fp = tmp;
  }
#line 368
  if (! save_context_p) {
    {
#line 372
    vfprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)fmt, args);
    }
#line 373
    goto flush;
  }
#line 376
  if (state->allocated != 0) {
#line 378
    write_ptr = state->bigmsg;
#line 379
    available_size = state->allocated;
  }
  {
#line 388
  numwritten = vsnprintf((char */* __restrict  */)write_ptr, (size_t )available_size,
                         (char const   */* __restrict  */)fmt, args);
  }
#line 398
  if (numwritten == -1) {
    {
#line 402
    newsize = available_size << 1;
#line 403
    tmp___0 = xrealloc_real((void *)state->bigmsg, (size_t )newsize);
#line 403
    state->bigmsg = (char *)tmp___0;
#line 404
    state->allocated = newsize;
    }
#line 405
    return (0);
  } else
#line 407
  if (numwritten >= available_size) {
    {
#line 411
    newsize___0 = numwritten + 1;
#line 412
    tmp___1 = xrealloc_real((void *)state->bigmsg, (size_t )newsize___0);
#line 412
    state->bigmsg = (char *)tmp___1;
#line 413
    state->allocated = newsize___0;
    }
#line 414
    return (0);
  }
  {
#line 418
  saved_append((char const   *)write_ptr);
#line 419
  fputs((char const   */* __restrict  */)write_ptr, (FILE */* __restrict  */)fp);
  }
#line 420
  if (state->bigmsg) {
    {
#line 421
    free((void *)state->bigmsg);
    }
  }
  flush: 
#line 424
  if (flush_log_p) {
    {
#line 425
    logflush();
    }
  } else {
#line 427
    needs_flushing = 1;
  }
#line 429
  return (1);
}
}
#line 433 "log.c"
void logflush(void) 
{ 
  FILE *fp ;
  FILE *tmp ;

  {
  {
#line 436
  tmp = get_log_fp();
#line 436
  fp = tmp;
  }
#line 437
  if (fp) {
    {
#line 438
    fflush(fp);
    }
  }
#line 439
  needs_flushing = 0;
#line 440
  return;
}
}
#line 443 "log.c"
void log_set_flush(int flush ) 
{ 


  {
#line 446
  if (flush == flush_log_p) {
#line 447
    return;
  }
#line 449
  if (flush == 0) {
#line 452
    flush_log_p = 0;
  } else {
#line 458
    if (needs_flushing) {
      {
#line 459
      logflush();
      }
    }
#line 460
    flush_log_p = 1;
  }
#line 462
  return;
}
}
#line 468 "log.c"
int log_set_save_context(int savep ) 
{ 
  int old ;

  {
#line 471
  old = save_context_p;
#line 472
  save_context_p = savep;
#line 473
  return (old);
}
}
#line 490 "log.c"
void ( /* format attribute */  logprintf)(enum log_options o , char const   *fmt 
                                          , ...) 
{ 
  va_list args ;
  struct logvprintf_state lpstate ;
  int done ;

  {
  {
#line 497
  check_redirect_output();
  }
#line 498
  if (inhibit_logging) {
#line 499
    return;
  }
  {
#line 500
  if ((unsigned int )o == 3U) {
#line 500
    goto case_3;
  }
#line 500
  if ((unsigned int )o == 1U) {
#line 500
    goto case_1;
  }
#line 500
  if ((unsigned int )o == 2U) {
#line 500
    goto case_2;
  }
#line 500
  if ((unsigned int )o == 0U) {
#line 500
    goto case_0;
  }
#line 500
  goto switch_break;
  case_3: /* CIL Label */ 
#line 500
  goto switch_break;
  case_1: /* CIL Label */ 
#line 500
  if (opt.quiet) {
#line 500
    return;
  }
#line 500
  goto switch_break;
  case_2: /* CIL Label */ 
#line 500
  if (opt.verbose) {
#line 500
    return;
  } else
#line 500
  if (opt.quiet) {
#line 500
    return;
  }
#line 500
  goto switch_break;
  case_0: /* CIL Label */ 
#line 500
  if (! opt.verbose) {
#line 500
    return;
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 502
  memset((void *)(& lpstate), '\000', (size_t )sizeof(lpstate));
  }
  {
#line 503
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 505
    __builtin_va_start(args, fmt);
#line 506
    done = logvprintf(& lpstate, fmt, args);
#line 507
    __builtin_va_end(args);
    }
#line 503
    if (! (! done)) {
#line 503
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 510
  return;
}
}
#line 515 "log.c"
void ( /* format attribute */  debug_logprintf)(char const   *fmt  , ...) 
{ 
  va_list args ;
  struct logvprintf_state lpstate ;
  int done ;

  {
#line 518
  if (opt.debug) {
    {
#line 524
    check_redirect_output();
    }
#line 525
    if (inhibit_logging) {
#line 526
      return;
    }
    {
#line 528
    memset((void *)(& lpstate), '\000', (size_t )sizeof(lpstate));
    }
    {
#line 529
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 531
      __builtin_va_start(args, fmt);
#line 532
      done = logvprintf(& lpstate, fmt, args);
#line 533
      __builtin_va_end(args);
      }
#line 529
      if (! (! done)) {
#line 529
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 537
  return;
}
}
#line 542 "log.c"
void log_init(char const   *file , int appendp ) 
{ 
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 545
  if (file) {
#line 547
    if (appendp) {
#line 547
      tmp = "a";
    } else {
#line 547
      tmp = "w";
    }
    {
#line 547
    logfp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)tmp);
    }
#line 548
    if (! logfp) {
      {
#line 550
      perror((char const   *)opt.lfilename);
#line 551
      exit(1);
      }
    }
  } else {
    {
#line 562
    logfp = stderr;
#line 568
    tmp___0 = fileno(logfp);
#line 568
    tmp___1 = isatty(tmp___0);
    }
#line 568
    if (tmp___1) {
#line 574
      save_context_p = 1;
    }
  }
#line 577
  return;
}
}
#line 581 "log.c"
void log_close(void) 
{ 
  int i ;

  {
#line 586
  if (logfp) {
    {
#line 587
    fclose(logfp);
    }
  }
#line 588
  logfp = (FILE *)((void *)0);
#line 589
  inhibit_logging = 1;
#line 590
  save_context_p = 0;
#line 592
  i = 0;
  {
#line 592
  while (1) {
    while_continue: /* CIL Label */ ;
#line 592
    if (! (i < 24)) {
#line 592
      goto while_break;
    }
    {
#line 593
    free_log_line(i);
#line 592
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 594
  log_line_current = -1;
#line 595
  trailing_line = 0;
#line 596
  return;
}
}
#line 599 "log.c"
static void log_dump_context(void) 
{ 
  int num ;
  FILE *fp ;
  FILE *tmp ;
  struct log_ln *ln ;

  {
  {
#line 602
  num = log_line_current;
#line 603
  tmp = get_log_fp();
#line 603
  fp = tmp;
  }
#line 604
  if (! fp) {
#line 605
    return;
  }
#line 607
  if (num == -1) {
#line 608
    return;
  }
#line 609
  if (trailing_line) {
    {
#line 610
    while (1) {
      while_continue: /* CIL Label */ ;
#line 610
      num ++;
#line 610
      if (num >= 24) {
#line 610
        num = 0;
      }
#line 610
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 611
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 613
    ln = log_lines + num;
#line 614
    if (ln->content) {
      {
#line 615
      fputs((char const   */* __restrict  */)ln->content, (FILE */* __restrict  */)fp);
      }
    }
    {
#line 616
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 616
      num ++;
#line 616
      if (num >= 24) {
#line 616
        num = 0;
      }
#line 616
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 611
    if (! (num != log_line_current)) {
#line 611
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 619
  if (trailing_line) {
#line 620
    if (log_lines[log_line_current].content) {
      {
#line 621
      fputs((char const   */* __restrict  */)log_lines[log_line_current].content,
            (FILE */* __restrict  */)fp);
      }
    }
  }
  {
#line 622
  fflush(fp);
  }
#line 623
  return;
}
}
#line 627 "log.c"
enum __anonenum_redirect_request_29 redirect_request  =    (enum __anonenum_redirect_request_29 )0;
#line 628 "log.c"
static char const   *redirect_request_signal_name  ;
#line 632 "log.c"
static void redirect_output(void) 
{ 
  char *logfile ;
  char *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 635
  tmp = unique_name("wget-log", 0);
#line 635
  logfile = tmp;
#line 636
  tmp___0 = gettext("\n%s received, redirecting output to `%s\'.\n");
#line 636
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
          redirect_request_signal_name, logfile);
#line 638
  logfp = fopen((char const   */* __restrict  */)logfile, (char const   */* __restrict  */)"w");
  }
#line 639
  if (! logfp) {
    {
#line 643
    tmp___1 = __errno_location();
#line 643
    tmp___2 = strerror(*tmp___1);
#line 643
    tmp___3 = gettext("%s: %s; disabling logging.\n");
#line 643
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___3,
            logfile, tmp___2);
#line 645
    inhibit_logging = 1;
    }
  } else {
    {
#line 650
    log_dump_context();
    }
  }
  {
#line 652
  free((void *)logfile);
#line 653
  save_context_p = 0;
  }
#line 654
  return;
}
}
#line 659 "log.c"
static void check_redirect_output(void) 
{ 


  {
#line 662
  if ((unsigned int )redirect_request == 1U) {
    {
#line 664
    redirect_request = (enum __anonenum_redirect_request_29 )2;
#line 665
    redirect_output();
    }
  }
#line 667
  return;
}
}
#line 672 "log.c"
void log_request_redirect_output(char const   *signal_name ) 
{ 


  {
#line 675
  if ((unsigned int )redirect_request == 0U) {
#line 675
    if (save_context_p) {
#line 679
      redirect_request = (enum __anonenum_redirect_request_29 )1;
    }
  }
#line 680
  redirect_request_signal_name = signal_name;
#line 681
  return;
}
}
#line 613 "/usr/include/unistd.h"
extern __uid_t getuid(void) ;
#line 61 "/usr/include/string.h"
extern int memcmp(void const   *__s1 , void const   *__s2 , size_t __n )  __attribute__((__pure__)) ;
#line 111 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 79 "init.c"
static int enable_tilde_expansion  ;
#line 85
static int cmd_boolean(char const   *com , char const   *val , void *closure ) ;
#line 86
static int cmd_bytes(char const   *com , char const   *val , void *closure ) ;
#line 87
static int cmd_bytes_large(char const   *com , char const   *val , void *closure ) ;
#line 88
static int cmd_directory_vector(char const   *com , char const   *val , void *closure ) ;
#line 89
static int cmd_lockable_boolean(char const   *com , char const   *val , void *closure ) ;
#line 90
static int cmd_number(char const   *com , char const   *val , void *closure ) ;
#line 91
static int cmd_number_inf(char const   *com , char const   *val , void *closure ) ;
#line 92
static int cmd_string(char const   *com , char const   *val , void *closure ) ;
#line 93
static int cmd_file(char const   *com , char const   *val , void *closure ) ;
#line 94
static int cmd_directory(char const   *com , char const   *val , void *closure ) ;
#line 95
static int cmd_time(char const   *com , char const   *val , void *closure ) ;
#line 96
static int cmd_vector(char const   *com , char const   *val , void *closure ) ;
#line 98
static int cmd_spec_dirstruct(char const   *com , char const   *val , void *closure ) ;
#line 99
static int cmd_spec_header(char const   *com , char const   *val , void *closure ) ;
#line 100
static int cmd_spec_htmlify(char const   *com , char const   *val , void *closure ) ;
#line 101
static int cmd_spec_mirror(char const   *com , char const   *val , void *closure ) ;
#line 102
static int cmd_spec_progress(char const   *com , char const   *val , void *closure ) ;
#line 103
static int cmd_spec_recursive(char const   *com , char const   *val , void *closure ) ;
#line 104
static int cmd_spec_restrict_file_names(char const   *com , char const   *val , void *closure ) ;
#line 105
static int cmd_spec_timeout(char const   *com , char const   *val , void *closure ) ;
#line 106
static int cmd_spec_useragent(char const   *com , char const   *val , void *closure ) ;
#line 113 "init.c"
static struct __anonstruct_commands_38 commands[100]  = 
#line 113
  {      {(char *)"accept", (void *)(& opt.accepts), & cmd_vector}, 
        {(char *)"addhostdir", (void *)(& opt.add_hostdir), & cmd_boolean}, 
        {(char *)"alwaysrest", (void *)(& opt.always_rest), & cmd_boolean}, 
        {(char *)"background", (void *)(& opt.background), & cmd_boolean}, 
        {(char *)"backupconverted", (void *)(& opt.backup_converted), & cmd_boolean}, 
        {(char *)"backups",
      (void *)(& opt.backups), & cmd_number}, 
        {(char *)"base", (void *)(& opt.base_href), & cmd_string}, 
        {(char *)"bindaddress", (void *)(& opt.bind_address), & cmd_string}, 
        {(char *)"cache", (void *)(& opt.allow_cache), & cmd_boolean}, 
        {(char *)"connecttimeout", (void *)(& opt.connect_timeout), & cmd_time}, 
        {(char *)"continue", (void *)(& opt.always_rest), & cmd_boolean}, 
        {(char *)"convertlinks", (void *)(& opt.convert_links), & cmd_boolean}, 
        {(char *)"cookies", (void *)(& opt.cookies), & cmd_boolean}, 
        {(char *)"cutdirs", (void *)(& opt.cut_dirs), & cmd_number}, 
        {(char *)"debug", (void *)(& opt.debug), & cmd_boolean}, 
        {(char *)"deleteafter", (void *)(& opt.delete_after), & cmd_boolean}, 
        {(char *)"dirprefix", (void *)(& opt.dir_prefix), & cmd_directory}, 
        {(char *)"dirstruct", (void *)0, & cmd_spec_dirstruct}, 
        {(char *)"dnscache", (void *)(& opt.dns_cache), & cmd_boolean}, 
        {(char *)"dnstimeout", (void *)(& opt.dns_timeout), & cmd_time}, 
        {(char *)"domains", (void *)(& opt.domains), & cmd_vector}, 
        {(char *)"dotbytes", (void *)(& opt.dot_bytes), & cmd_bytes}, 
        {(char *)"dotsinline", (void *)(& opt.dots_in_line), & cmd_number}, 
        {(char *)"dotspacing", (void *)(& opt.dot_spacing), & cmd_number}, 
        {(char *)"dotstyle", (void *)(& opt.dot_style), & cmd_string}, 
        {(char *)"egdfile", (void *)(& opt.sslegdsock), & cmd_file}, 
        {(char *)"excludedirectories", (void *)(& opt.excludes), & cmd_directory_vector}, 
        {(char *)"excludedomains",
      (void *)(& opt.exclude_domains), & cmd_vector}, 
        {(char *)"followftp", (void *)(& opt.follow_ftp), & cmd_boolean}, 
        {(char *)"followtags", (void *)(& opt.follow_tags), & cmd_vector}, 
        {(char *)"forcehtml", (void *)(& opt.force_html), & cmd_boolean}, 
        {(char *)"ftpproxy", (void *)(& opt.ftp_proxy), & cmd_string}, 
        {(char *)"glob", (void *)(& opt.ftp_glob), & cmd_boolean}, 
        {(char *)"header", (void *)0, & cmd_spec_header}, 
        {(char *)"htmlextension", (void *)(& opt.html_extension), & cmd_boolean}, 
        {(char *)"htmlify", (void *)0, & cmd_spec_htmlify}, 
        {(char *)"httpkeepalive", (void *)(& opt.http_keep_alive), & cmd_boolean}, 
        {(char *)"httppasswd", (void *)(& opt.http_passwd), & cmd_string}, 
        {(char *)"httpproxy", (void *)(& opt.http_proxy), & cmd_string}, 
        {(char *)"httpsproxy", (void *)(& opt.https_proxy), & cmd_string}, 
        {(char *)"httpuser", (void *)(& opt.http_user), & cmd_string}, 
        {(char *)"ignorelength", (void *)(& opt.ignore_length), & cmd_boolean}, 
        {(char *)"ignoretags", (void *)(& opt.ignore_tags), & cmd_vector}, 
        {(char *)"includedirectories", (void *)(& opt.includes), & cmd_directory_vector}, 
        {(char *)"input",
      (void *)(& opt.input_filename), & cmd_file}, 
        {(char *)"killlonger", (void *)(& opt.kill_longer), & cmd_boolean}, 
        {(char *)"limitrate", (void *)(& opt.limit_rate), & cmd_bytes}, 
        {(char *)"loadcookies", (void *)(& opt.cookies_input), & cmd_file}, 
        {(char *)"logfile", (void *)(& opt.lfilename), & cmd_file}, 
        {(char *)"login", (void *)(& opt.ftp_acc), & cmd_string}, 
        {(char *)"mirror", (void *)0, & cmd_spec_mirror}, 
        {(char *)"netrc", (void *)(& opt.netrc), & cmd_boolean}, 
        {(char *)"noclobber", (void *)(& opt.noclobber), & cmd_boolean}, 
        {(char *)"noparent", (void *)(& opt.no_parent), & cmd_boolean}, 
        {(char *)"noproxy", (void *)(& opt.no_proxy), & cmd_vector}, 
        {(char *)"numtries", (void *)(& opt.ntry), & cmd_number_inf}, 
        {(char *)"outputdocument", (void *)(& opt.output_document), & cmd_file}, 
        {(char *)"pagerequisites", (void *)(& opt.page_requisites), & cmd_boolean}, 
        {(char *)"passiveftp", (void *)(& opt.ftp_pasv), & cmd_lockable_boolean}, 
        {(char *)"passwd", (void *)(& opt.ftp_pass), & cmd_string}, 
        {(char *)"postdata", (void *)(& opt.post_data), & cmd_string}, 
        {(char *)"postfile", (void *)(& opt.post_file_name), & cmd_file}, 
        {(char *)"progress", (void *)(& opt.progress_type), & cmd_spec_progress}, 
        {(char *)"proxypasswd", (void *)(& opt.proxy_passwd), & cmd_string}, 
        {(char *)"proxyuser", (void *)(& opt.proxy_user), & cmd_string}, 
        {(char *)"quiet", (void *)(& opt.quiet), & cmd_boolean}, 
        {(char *)"quota", (void *)(& opt.quota), & cmd_bytes_large}, 
        {(char *)"randomwait", (void *)(& opt.random_wait), & cmd_boolean}, 
        {(char *)"readtimeout", (void *)(& opt.read_timeout), & cmd_time}, 
        {(char *)"reclevel", (void *)(& opt.reclevel), & cmd_number_inf}, 
        {(char *)"recursive", (void *)0, & cmd_spec_recursive}, 
        {(char *)"referer", (void *)(& opt.referer), & cmd_string}, 
        {(char *)"reject", (void *)(& opt.rejects), & cmd_vector}, 
        {(char *)"relativeonly", (void *)(& opt.relative_only), & cmd_boolean}, 
        {(char *)"removelisting", (void *)(& opt.remove_listing), & cmd_boolean}, 
        {(char *)"restrictfilenames", (void *)0, & cmd_spec_restrict_file_names}, 
        {(char *)"retrsymlinks", (void *)(& opt.retr_symlinks), & cmd_boolean}, 
        {(char *)"retryconnrefused", (void *)(& opt.retry_connrefused), & cmd_boolean}, 
        {(char *)"robots",
      (void *)(& opt.use_robots), & cmd_boolean}, 
        {(char *)"savecookies", (void *)(& opt.cookies_output), & cmd_file}, 
        {(char *)"saveheaders", (void *)(& opt.save_headers), & cmd_boolean}, 
        {(char *)"serverresponse", (void *)(& opt.server_response), & cmd_boolean}, 
        {(char *)"spanhosts", (void *)(& opt.spanhost), & cmd_boolean}, 
        {(char *)"spider", (void *)(& opt.spider), & cmd_boolean}, 
        {(char *)"sslcadir", (void *)(& opt.sslcadir), & cmd_directory}, 
        {(char *)"sslcafile", (void *)(& opt.sslcafile), & cmd_file}, 
        {(char *)"sslcertfile", (void *)(& opt.sslcertfile), & cmd_file}, 
        {(char *)"sslcertkey", (void *)(& opt.sslcertkey), & cmd_file}, 
        {(char *)"sslcerttype", (void *)(& opt.sslcerttype), & cmd_number}, 
        {(char *)"sslcheckcert", (void *)(& opt.sslcheckcert), & cmd_number}, 
        {(char *)"sslprotocol", (void *)(& opt.sslprotocol), & cmd_number}, 
        {(char *)"strictcomments", (void *)(& opt.strict_comments), & cmd_boolean}, 
        {(char *)"timeout", (void *)0, & cmd_spec_timeout}, 
        {(char *)"timestamping", (void *)(& opt.timestamping), & cmd_boolean}, 
        {(char *)"tries", (void *)(& opt.ntry), & cmd_number_inf}, 
        {(char *)"useproxy", (void *)(& opt.use_proxy), & cmd_boolean}, 
        {(char *)"useragent", (void *)0, & cmd_spec_useragent}, 
        {(char *)"verbose", (void *)(& opt.verbose), & cmd_boolean}, 
        {(char *)"wait", (void *)(& opt.wait), & cmd_time}, 
        {(char *)"waitretry", (void *)(& opt.waitretry), & cmd_time}};
#line 229 "init.c"
static int findcmd(char const   *com ) 
{ 
  int lo ;
  int hi ;
  int mid ;
  int cmp ;
  int tmp ;

  {
#line 232
  lo = 0;
#line 232
  hi = (int )(sizeof(commands) / sizeof(commands[0]) - 1UL);
  {
#line 234
  while (1) {
    while_continue: /* CIL Label */ ;
#line 234
    if (! (lo <= hi)) {
#line 234
      goto while_break;
    }
    {
#line 236
    mid = (lo + hi) >> 1;
#line 237
    tmp = strcasecmp(com, (char const   *)commands[mid].name);
#line 237
    cmp = tmp;
    }
#line 238
    if (cmp < 0) {
#line 239
      hi = mid - 1;
    } else
#line 240
    if (cmp > 0) {
#line 241
      lo = mid + 1;
    } else {
#line 243
      return (mid);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 245
  return (-1);
}
}
#line 249 "init.c"
static void defaults(void) 
{ 
  char *tmp ;

  {
  {
#line 259
  memset((void *)(& opt), 0, (size_t )sizeof(opt));
#line 261
  opt.cookies = 1;
#line 263
  opt.verbose = -1;
#line 264
  opt.ntry = 20;
#line 265
  opt.reclevel = 5;
#line 266
  opt.add_hostdir = 1;
#line 267
  opt.ftp_acc = xstrdup_real("anonymous");
#line 268
  opt.ftp_pass = xstrdup_real("-wget@");
#line 269
  opt.netrc = 1;
#line 270
  opt.ftp_glob = 1;
#line 271
  opt.htmlify = 1;
#line 272
  opt.http_keep_alive = 1;
#line 273
  opt.use_proxy = 1;
#line 274
  tmp = getenv("no_proxy");
  }
#line 275
  if (tmp) {
    {
#line 276
    opt.no_proxy = sepstring((char const   *)tmp);
    }
  }
#line 277
  opt.allow_cache = 1;
#line 279
  opt.read_timeout = (double )900;
#line 280
  opt.use_robots = 1;
#line 282
  opt.remove_listing = 1;
#line 284
  opt.dot_bytes = 1024L;
#line 285
  opt.dot_spacing = 10;
#line 286
  opt.dots_in_line = 50;
#line 288
  opt.dns_cache = 1;
#line 292
  opt.restrict_files_os = (enum __anonenum_restrict_files_os_46 )0;
#line 296
  opt.restrict_files_ctrl = 1;
#line 297
  return;
}
}
#line 301 "init.c"
char *home_dir(void) 
{ 
  char *home ;
  char *tmp ;
  struct passwd *pwd ;
  __uid_t tmp___0 ;
  struct passwd *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 304
  tmp = getenv("HOME");
#line 304
  home = tmp;
  }
#line 306
  if (! home) {
    {
#line 311
    tmp___0 = getuid();
#line 311
    tmp___1 = getpwuid(tmp___0);
#line 311
    pwd = tmp___1;
    }
#line 312
    if (! pwd) {
#line 313
      return ((char *)((void *)0));
    } else
#line 312
    if (! pwd->pw_dir) {
#line 313
      return ((char *)((void *)0));
    }
#line 314
    home = pwd->pw_dir;
  }
#line 322
  if (home) {
    {
#line 322
    tmp___2 = xstrdup_real((char const   *)home);
#line 322
    tmp___3 = tmp___2;
    }
  } else {
#line 322
    tmp___3 = (char *)((void *)0);
  }
#line 322
  return (tmp___3);
}
}
#line 330 "init.c"
static char *wgetrc_file_name(void) 
{ 
  char *env ;
  char *home ;
  char *file ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 334
  file = (char *)((void *)0);
#line 337
  env = getenv("WGETRC");
  }
#line 338
  if (env) {
#line 338
    if (*env) {
      {
#line 340
      tmp___0 = file_exists_p((char const   *)env);
      }
#line 340
      if (! tmp___0) {
        {
#line 342
        tmp = gettext("%s: WGETRC points to %s, which doesn\'t exist.\n");
#line 342
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
                exec_name, env);
#line 344
        exit(1);
        }
      }
      {
#line 346
      tmp___1 = xstrdup_real((char const   *)env);
      }
#line 346
      return (tmp___1);
    }
  }
  {
#line 351
  home = home_dir();
  }
#line 352
  if (home) {
    {
#line 354
    tmp___2 = strlen((char const   *)home);
#line 354
    tmp___3 = strlen(".wgetrc");
#line 354
    tmp___4 = xmalloc_real(((tmp___2 + 1U) + tmp___3) + 1U);
#line 354
    file = (char *)tmp___4;
#line 355
    sprintf((char */* __restrict  */)file, (char const   */* __restrict  */)"%s/.wgetrc",
            home);
    }
  }
  {
#line 357
  while (1) {
    while_continue: /* CIL Label */ ;
#line 357
    if (home) {
      {
#line 357
      free((void *)home);
      }
    }
#line 357
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 373
  if (! file) {
#line 374
    return ((char *)((void *)0));
  }
  {
#line 375
  tmp___5 = file_exists_p((char const   *)file);
  }
#line 375
  if (! tmp___5) {
    {
#line 377
    free((void *)file);
    }
#line 378
    return ((char *)((void *)0));
  }
#line 380
  return (file);
}
}
#line 383
static int parse_line(char const   *line , char **com , char **val , int *comind ) ;
#line 384
static int setval_internal(int comind , char const   *com , char const   *val ) ;
#line 388 "init.c"
static void run_wgetrc(char const   *file ) 
{ 
  FILE *fp ;
  char *line ;
  int ln ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *com ;
  char *val ;
  int comind ;
  int status ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 395
  fp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"rb");
  }
#line 396
  if (! fp) {
    {
#line 398
    tmp = __errno_location();
#line 398
    tmp___0 = strerror(*tmp);
#line 398
    tmp___1 = gettext("%s: Cannot read %s (%s).\n");
#line 398
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
            exec_name, file, tmp___0);
    }
#line 400
    return;
  }
#line 402
  enable_tilde_expansion = 1;
#line 403
  ln = 1;
  {
#line 404
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 404
    line = read_whole_line(fp);
    }
#line 404
    if (! line) {
#line 404
      goto while_break;
    }
    {
#line 410
    status = parse_line((char const   *)line, & com, & val, & comind);
#line 411
    free((void *)line);
    }
#line 413
    if (status == 1) {
      {
#line 415
      tmp___3 = setval_internal(comind, (char const   *)com, (char const   *)val);
      }
#line 415
      if (! tmp___3) {
        {
#line 416
        tmp___2 = gettext("%s: Error in %s at line %d.\n");
#line 416
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___2,
                exec_name, file, ln);
        }
      }
      {
#line 418
      free((void *)com);
#line 419
      free((void *)val);
      }
    } else
#line 421
    if (status == 0) {
      {
#line 422
      tmp___4 = gettext("%s: Error in %s at line %d.\n");
#line 422
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___4,
              exec_name, file, ln);
      }
    }
#line 424
    ln ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 426
  enable_tilde_expansion = 0;
#line 427
  fclose(fp);
  }
#line 428
  return;
}
}
#line 432 "init.c"
void initialize(void) 
{ 
  char *file ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 438
  defaults();
#line 442
  tmp = file_exists_p("/usr/local/etc/wgetrc");
  }
#line 442
  if (tmp) {
    {
#line 443
    run_wgetrc("/usr/local/etc/wgetrc");
    }
  }
  {
#line 446
  file = wgetrc_file_name();
  }
#line 447
  if (! file) {
#line 448
    return;
  }
  {
#line 452
  tmp___1 = strcmp((char const   *)file, "/usr/local/etc/wgetrc");
  }
#line 452
  if (tmp___1) {
    {
#line 460
    run_wgetrc((char const   *)file);
    }
  } else {
    {
#line 454
    tmp___0 = gettext("%s: Warning: Both system and user wgetrc point to `%s\'.\n");
#line 454
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            exec_name, file);
    }
  }
  {
#line 461
  free((void *)file);
  }
#line 462
  return;
}
}
#line 468 "init.c"
static void dehyphen(char *s ) 
{ 
  char *t ;
  char *h ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 471
  t = s;
#line 472
  h = s;
  {
#line 473
  while (1) {
    while_continue: /* CIL Label */ ;
#line 473
    if (! *h) {
#line 473
      goto while_break;
    }
#line 474
    if ((int )*h == 95) {
#line 475
      h ++;
    } else
#line 474
    if ((int )*h == 45) {
#line 475
      h ++;
    } else {
#line 477
      tmp = t;
#line 477
      t ++;
#line 477
      tmp___0 = h;
#line 477
      h ++;
#line 477
      *tmp = *tmp___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 478
  *t = (char )'\000';
#line 479
  return;
}
}
#line 495 "init.c"
static int parse_line(char const   *line , char **com , char **val , int *comind ) 
{ 
  char const   *p ;
  char const   *end ;
  size_t tmp ;
  char const   *cmdstart ;
  char const   *cmdend ;
  char const   *valstart ;
  char const   *valend ;
  char *cmdcopy ;
  int ind ;
  char const   *BTA_beg ;
  int BTA_len ;
  char **BTA_dest ;
  void *tmp___0 ;

  {
  {
#line 499
  tmp = strlen(line);
#line 499
  end = line + tmp;
  }
  {
#line 507
  while (1) {
    while_continue: /* CIL Label */ ;
#line 507
    if (*line) {
#line 507
      if (! ((int const   )_sch_istable[(int const   )*line & 255] & 64)) {
#line 507
        goto while_break;
      }
    } else {
#line 507
      goto while_break;
    }
#line 508
    line ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 509
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 509
    if ((unsigned long )end > (unsigned long )line) {
#line 509
      if (! ((int const   )_sch_istable[(int const   )*(end + -1) & 255] & 64)) {
#line 509
        goto while_break___0;
      }
    } else {
#line 509
      goto while_break___0;
    }
#line 510
    end --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 513
  if (! *line) {
#line 514
    return (-1);
  } else
#line 513
  if ((int const   )*line == 35) {
#line 514
    return (-1);
  }
#line 516
  p = line;
#line 518
  cmdstart = p;
  {
#line 519
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 519
    if ((unsigned long )p < (unsigned long )end) {
#line 519
      if (! ((int const   )_sch_istable[(int const   )*p & 255] & 136)) {
#line 519
        if (! ((int const   )*p == 95)) {
#line 519
          if (! ((int const   )*p == 45)) {
#line 519
            goto while_break___1;
          }
        }
      }
    } else {
#line 519
      goto while_break___1;
    }
#line 520
    p ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 521
  cmdend = p;
  {
#line 524
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 524
    if ((unsigned long )p < (unsigned long )end) {
#line 524
      if (! ((int const   )_sch_istable[(int const   )*p & 255] & 64)) {
#line 524
        goto while_break___2;
      }
    } else {
#line 524
      goto while_break___2;
    }
#line 525
    p ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 526
  if ((unsigned long )p == (unsigned long )end) {
#line 527
    return (0);
  } else
#line 526
  if ((int const   )*p != 61) {
#line 527
    return (0);
  }
#line 528
  p ++;
  {
#line 529
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 529
    if ((unsigned long )p < (unsigned long )end) {
#line 529
      if (! ((int const   )_sch_istable[(int const   )*p & 255] & 64)) {
#line 529
        goto while_break___3;
      }
    } else {
#line 529
      goto while_break___3;
    }
#line 530
    p ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 532
  valstart = p;
#line 533
  valend = end;
  {
#line 537
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 537
    BTA_beg = cmdstart;
#line 537
    BTA_len = (int )(cmdend - BTA_beg);
#line 537
    BTA_dest = & cmdcopy;
#line 537
    tmp___0 = __builtin_alloca((unsigned long )(BTA_len + 1));
#line 537
    *BTA_dest = (char *)tmp___0;
#line 537
    memcpy((void */* __restrict  */)*BTA_dest, (void const   */* __restrict  */)BTA_beg,
           (size_t )BTA_len);
#line 537
    *(*BTA_dest + BTA_len) = (char )'\000';
    }
#line 537
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 538
  dehyphen(cmdcopy);
#line 539
  ind = findcmd((char const   *)cmdcopy);
  }
#line 540
  if (ind == -1) {
#line 541
    return (0);
  }
  {
#line 545
  *comind = ind;
#line 546
  *com = strdupdelim(cmdstart, cmdend);
#line 547
  *val = strdupdelim(valstart, valend);
  }
#line 548
  return (1);
}
}
#line 553 "init.c"
static int setval_internal(int comind , char const   *com , char const   *val ) 
{ 
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
#line 556
  if (0 <= comind) {
#line 556
    if ((unsigned long )comind < sizeof(commands) / sizeof(commands[0])) {
#line 556
      tmp = 1;
    } else {
#line 556
      tmp = 0;
    }
  } else {
#line 556
    tmp = 0;
  }
  {
#line 556
  tmp___0 = __builtin_expect((long )tmp, 1L);
  }
#line 556
  if (! tmp___0) {
    {
#line 556
    __assert_fail("0 <= comind && comind < (sizeof (commands) / sizeof (*(commands)))",
                  "init.c", 556U, "setval_internal");
    }
  }
  {
#line 557
  tmp___1 = (*(commands[comind].action))(com, val, commands[comind].closure);
  }
#line 557
  return (tmp___1);
}
}
#line 568 "init.c"
void setoptval(char const   *com , char const   *val ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 571
  tmp = findcmd(com);
#line 571
  tmp___0 = setval_internal(tmp, com, val);
  }
#line 571
  if (! tmp___0) {
    {
#line 572
    exit(2);
    }
  }
#line 573
  return;
}
}
#line 579 "init.c"
void run_command(char const   *opt___0 ) 
{ 
  char *com ;
  char *val ;
  int comind ;
  int status ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 584
  tmp = parse_line(opt___0, & com, & val, & comind);
#line 584
  status = tmp;
  }
#line 585
  if (status == 1) {
    {
#line 587
    tmp___0 = setval_internal(comind, (char const   *)com, (char const   *)val);
    }
#line 587
    if (! tmp___0) {
      {
#line 588
      exit(2);
      }
    }
    {
#line 589
    free((void *)com);
#line 590
    free((void *)val);
    }
  } else
#line 592
  if (status == 0) {
    {
#line 594
    tmp___1 = gettext("%s: Invalid --execute command `%s\'\n");
#line 594
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
            exec_name, opt___0);
#line 596
    exit(2);
    }
  }
#line 598
  return;
}
}
#line 616 "init.c"
static int cmd_boolean(char const   *com , char const   *val , void *closure ) 
{ 
  int bool_value ;
  char *tmp ;

  {
#line 621
  if ((int const   )_sch_tolower[(int const   )*(val + 0) & 255] == 111) {
#line 621
    if ((int const   )_sch_tolower[(int const   )*(val + 1) & 255] == 110) {
#line 621
      if ((int const   )*(val + 2) == 0) {
#line 623
        bool_value = 1;
      } else {
#line 621
        goto _L___9;
      }
    } else {
#line 621
      goto _L___9;
    }
  } else
  _L___9: /* CIL Label */ 
#line 621
  if ((int const   )_sch_tolower[(int const   )*(val + 0) & 255] == 121) {
#line 621
    if ((int const   )_sch_tolower[(int const   )*(val + 1) & 255] == 101) {
#line 621
      if ((int const   )_sch_tolower[(int const   )*(val + 2) & 255] == 115) {
#line 621
        if ((int const   )*(val + 3) == 0) {
#line 623
          bool_value = 1;
        } else {
#line 621
          goto _L___7;
        }
      } else {
#line 621
        goto _L___7;
      }
    } else {
#line 621
      goto _L___7;
    }
  } else
  _L___7: /* CIL Label */ 
#line 621
  if ((int const   )_sch_tolower[(int const   )*(val + 0) & 255] == 49) {
#line 621
    if ((int const   )*(val + 1) == 0) {
#line 623
      bool_value = 1;
    } else {
#line 621
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
#line 624
  if ((int const   )_sch_tolower[(int const   )*(val + 0) & 255] == 111) {
#line 624
    if ((int const   )_sch_tolower[(int const   )*(val + 1) & 255] == 102) {
#line 624
      if ((int const   )_sch_tolower[(int const   )*(val + 2) & 255] == 102) {
#line 624
        if ((int const   )*(val + 3) == 0) {
#line 626
          bool_value = 0;
        } else {
#line 624
          goto _L___3;
        }
      } else {
#line 624
        goto _L___3;
      }
    } else {
#line 624
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 624
  if ((int const   )_sch_tolower[(int const   )*(val + 0) & 255] == 110) {
#line 624
    if ((int const   )_sch_tolower[(int const   )*(val + 1) & 255] == 111) {
#line 624
      if ((int const   )*(val + 2) == 0) {
#line 626
        bool_value = 0;
      } else {
#line 624
        goto _L___0;
      }
    } else {
#line 624
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 624
  if ((int const   )_sch_tolower[(int const   )*(val + 0) & 255] == 48) {
#line 624
    if ((int const   )*(val + 1) == 0) {
#line 626
      bool_value = 0;
    } else {
      {
#line 629
      tmp = gettext("%s: %s: Invalid boolean `%s\', use `on\' or `off\'.\n");
#line 629
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
              exec_name, com, val);
      }
#line 632
      return (0);
    }
  } else {
    {
#line 629
    tmp = gettext("%s: %s: Invalid boolean `%s\', use `on\' or `off\'.\n");
#line 629
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
            exec_name, com, val);
    }
#line 632
    return (0);
  }
#line 635
  *((int *)closure) = bool_value;
#line 636
  return (1);
}
}
#line 648 "init.c"
static int cmd_lockable_boolean(char const   *com , char const   *val , void *closure ) 
{ 
  int lockable_boolean_value ;
  int oldval ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 653
  oldval = *((int *)closure);
#line 659
  if (oldval == -1) {
#line 660
    return (1);
  } else
#line 659
  if (oldval == 2) {
#line 660
    return (1);
  }
  {
#line 662
  tmp___1 = strcasecmp(val, "always");
  }
#line 662
  if (0 == tmp___1) {
#line 663
    lockable_boolean_value = 2;
  } else
#line 662
  if ((int const   )_sch_tolower[(int const   )*(val + 0) & 255] == 50) {
#line 662
    if ((int const   )*(val + 1) == 0) {
#line 663
      lockable_boolean_value = 2;
    } else {
#line 662
      goto _L___11;
    }
  } else
  _L___11: /* CIL Label */ 
#line 664
  if ((int const   )_sch_tolower[(int const   )*(val + 0) & 255] == 111) {
#line 664
    if ((int const   )_sch_tolower[(int const   )*(val + 1) & 255] == 110) {
#line 664
      if ((int const   )*(val + 2) == 0) {
#line 665
        lockable_boolean_value = 1;
      } else {
#line 664
        goto _L___10;
      }
    } else {
#line 664
      goto _L___10;
    }
  } else
  _L___10: /* CIL Label */ 
#line 664
  if ((int const   )_sch_tolower[(int const   )*(val + 0) & 255] == 121) {
#line 664
    if ((int const   )_sch_tolower[(int const   )*(val + 1) & 255] == 101) {
#line 664
      if ((int const   )_sch_tolower[(int const   )*(val + 2) & 255] == 115) {
#line 664
        if ((int const   )*(val + 3) == 0) {
#line 665
          lockable_boolean_value = 1;
        } else {
#line 664
          goto _L___8;
        }
      } else {
#line 664
        goto _L___8;
      }
    } else {
#line 664
      goto _L___8;
    }
  } else
  _L___8: /* CIL Label */ 
#line 664
  if ((int const   )_sch_tolower[(int const   )*(val + 0) & 255] == 49) {
#line 664
    if ((int const   )*(val + 1) == 0) {
#line 665
      lockable_boolean_value = 1;
    } else {
#line 664
      goto _L___5;
    }
  } else
  _L___5: /* CIL Label */ 
#line 666
  if ((int const   )_sch_tolower[(int const   )*(val + 0) & 255] == 111) {
#line 666
    if ((int const   )_sch_tolower[(int const   )*(val + 1) & 255] == 102) {
#line 666
      if ((int const   )_sch_tolower[(int const   )*(val + 2) & 255] == 102) {
#line 666
        if ((int const   )*(val + 3) == 0) {
#line 667
          lockable_boolean_value = 0;
        } else {
#line 666
          goto _L___4;
        }
      } else {
#line 666
        goto _L___4;
      }
    } else {
#line 666
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
#line 666
  if ((int const   )_sch_tolower[(int const   )*(val + 0) & 255] == 110) {
#line 666
    if ((int const   )_sch_tolower[(int const   )*(val + 1) & 255] == 111) {
#line 666
      if ((int const   )*(val + 2) == 0) {
#line 667
        lockable_boolean_value = 0;
      } else {
#line 666
        goto _L___1;
      }
    } else {
#line 666
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 666
  if ((int const   )_sch_tolower[(int const   )*(val + 0) & 255] == 48) {
#line 666
    if ((int const   )*(val + 1) == 0) {
#line 667
      lockable_boolean_value = 0;
    } else {
#line 666
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 668
    tmp___0 = strcasecmp(val, "never");
    }
#line 668
    if (0 == tmp___0) {
#line 669
      lockable_boolean_value = -1;
    } else
#line 668
    if ((int const   )_sch_tolower[(int const   )*(val + 0) & 255] == 45) {
#line 668
      if ((int const   )_sch_tolower[(int const   )*(val + 1) & 255] == 49) {
#line 668
        if ((int const   )*(val + 2) == 0) {
#line 669
          lockable_boolean_value = -1;
        } else {
          {
#line 672
          tmp = gettext("%s: %s: Invalid boolean `%s\', use always, on, off, or never.\n");
#line 672
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
                  exec_name, com, val);
          }
#line 675
          return (0);
        }
      } else {
        {
#line 672
        tmp = gettext("%s: %s: Invalid boolean `%s\', use always, on, off, or never.\n");
#line 672
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
                exec_name, com, val);
        }
#line 675
        return (0);
      }
    } else {
      {
#line 672
      tmp = gettext("%s: %s: Invalid boolean `%s\', use always, on, off, or never.\n");
#line 672
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
              exec_name, com, val);
      }
#line 675
      return (0);
    }
  }
#line 678
  *((int *)closure) = lockable_boolean_value;
#line 679
  return (1);
}
}
#line 682
static int simple_atoi(char const   *beg , char const   *end , int *dest ) ;
#line 686 "init.c"
static int cmd_number(char const   *com , char const   *val , void *closure ) 
{ 
  char *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 689
  tmp___0 = strlen(val);
#line 689
  tmp___1 = simple_atoi(val, val + tmp___0, (int *)closure);
  }
#line 689
  if (! tmp___1) {
    {
#line 691
    tmp = gettext("%s: %s: Invalid number `%s\'.\n");
#line 691
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
            exec_name, com, val);
    }
#line 693
    return (0);
  }
#line 695
  return (1);
}
}
#line 699 "init.c"
static int cmd_number_inf(char const   *com , char const   *val , void *closure ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 702
  tmp = strcasecmp(val, "inf");
  }
#line 702
  if (! tmp) {
#line 704
    *((int *)closure) = 0;
#line 705
    return (1);
  }
  {
#line 707
  tmp___0 = cmd_number(com, val, closure);
  }
#line 707
  return (tmp___0);
}
}
#line 712 "init.c"
static int cmd_string(char const   *com , char const   *val , void *closure ) 
{ 
  char **pstring ;

  {
#line 715
  pstring = (char **)closure;
  {
#line 717
  while (1) {
    while_continue: /* CIL Label */ ;
#line 717
    if (*pstring) {
      {
#line 717
      free((void *)*pstring);
      }
    }
#line 717
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 718
  *pstring = xstrdup_real(val);
  }
#line 719
  return (1);
}
}
#line 731 "init.c"
static int cmd_file(char const   *com , char const   *val , void *closure ) 
{ 
  char **pstring ;
  char *result ;
  int homelen ;
  char *home ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
#line 734
  pstring = (char **)closure;
  {
#line 736
  while (1) {
    while_continue: /* CIL Label */ ;
#line 736
    if (*pstring) {
      {
#line 736
      free((void *)*pstring);
      }
    }
#line 736
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 740
  if (! enable_tilde_expansion) {
#line 740
    goto noexpand;
  } else
#line 740
  if ((int const   )*val == 126) {
#line 740
    if ((int const   )*(val + 1) == 47) {
      {
#line 749
      tmp = home_dir();
#line 749
      home = tmp;
      }
#line 750
      if (! home) {
#line 751
        goto noexpand;
      }
      {
#line 753
      tmp___0 = strlen((char const   *)home);
#line 753
      homelen = (int )tmp___0;
      }
      {
#line 754
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 754
        if (homelen) {
#line 754
          if (! ((int )*(home + (homelen - 1)) == 47)) {
#line 754
            goto while_break___0;
          }
        } else {
#line 754
          goto while_break___0;
        }
#line 755
        homelen --;
#line 755
        *(home + homelen) = (char )'\000';
      }
      while_break___0: /* CIL Label */ ;
      }
#line 758
      val ++;
      {
#line 758
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 758
        if (! ((int const   )*val == 47)) {
#line 758
          goto while_break___1;
        }
#line 758
        val ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 761
      tmp___1 = strlen(val);
#line 761
      tmp___2 = xmalloc_real(((size_t )(homelen + 1) + tmp___1) + 1U);
#line 761
      result = (char *)tmp___2;
#line 762
      memcpy((void */* __restrict  */)result, (void const   */* __restrict  */)home,
             (size_t )homelen);
#line 763
      *(result + homelen) = (char )'/';
#line 764
      strcpy((char */* __restrict  */)((result + homelen) + 1), (char const   */* __restrict  */)val);
#line 766
      *pstring = result;
      }
    } else {
#line 740
      goto noexpand;
    }
  } else {
    noexpand: 
    {
#line 743
    *pstring = xstrdup_real(val);
    }
  }
#line 778
  return (1);
}
}
#line 782 "init.c"
static int cmd_directory(char const   *com , char const   *val , void *closure ) 
{ 
  char *s ;
  char *t ;
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 790
  tmp = cmd_file(com, val, closure);
  }
#line 790
  if (! tmp) {
#line 791
    return (0);
  }
  {
#line 793
  s = *((char **)closure);
#line 794
  tmp___0 = strlen((char const   *)s);
#line 794
  t = s + tmp___0;
  }
  {
#line 795
  while (1) {
    while_continue: /* CIL Label */ ;
#line 795
    if ((unsigned long )t > (unsigned long )s) {
#line 795
      t --;
#line 795
      if (! ((int )*t == 47)) {
#line 795
        goto while_break;
      }
    } else {
#line 795
      goto while_break;
    }
#line 796
    *t = (char )'\000';
  }
  while_break: /* CIL Label */ ;
  }
#line 798
  return (1);
}
}
#line 805 "init.c"
static int cmd_vector(char const   *com , char const   *val , void *closure ) 
{ 
  char ***pvec ;
  char **tmp ;

  {
#line 808
  pvec = (char ***)closure;
#line 810
  if (*val) {
    {
#line 811
    tmp = sepstring(val);
#line 811
    *pvec = merge_vecs(*pvec, tmp);
    }
  } else {
    {
#line 814
    free_vec(*pvec);
#line 815
    *pvec = (char **)((void *)0);
    }
  }
#line 817
  return (1);
}
}
#line 820 "init.c"
static int cmd_directory_vector(char const   *com , char const   *val , void *closure ) 
{ 
  char ***pvec ;
  char **t ;
  char **seps ;
  int len ;
  size_t tmp ;

  {
#line 823
  pvec = (char ***)closure;
#line 825
  if (*val) {
    {
#line 830
    seps = sepstring(val);
#line 831
    t = seps;
    }
    {
#line 831
    while (1) {
      while_continue: /* CIL Label */ ;
#line 831
      if (t) {
#line 831
        if (! *t) {
#line 831
          goto while_break;
        }
      } else {
#line 831
        goto while_break;
      }
      {
#line 833
      tmp = strlen((char const   *)*t);
#line 833
      len = (int )tmp;
      }
#line 835
      if (len > 1) {
#line 837
        if ((int )*(*t + (len - 1)) == 47) {
#line 838
          *(*t + (len - 1)) = (char )'\000';
        }
      }
#line 831
      t ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 841
    *pvec = merge_vecs(*pvec, seps);
    }
  } else {
    {
#line 845
    free_vec(*pvec);
#line 846
    *pvec = (char **)((void *)0);
    }
  }
#line 848
  return (1);
}
}
#line 851
static int simple_atof(char const   *beg , char const   *end , double *dest ) ;
#line 856 "init.c"
static int parse_bytes_helper(char const   *val , double *result ) 
{ 
  double number ;
  double mult ;
  char const   *end ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 860
  tmp = strlen(val);
#line 860
  end = val + tmp;
#line 863
  tmp___0 = strcmp(val, "inf");
  }
#line 863
  if (0 == tmp___0) {
#line 865
    *result = (double )0;
#line 866
    return (1);
  }
  {
#line 870
  while (1) {
    while_continue: /* CIL Label */ ;
#line 870
    if ((unsigned long )val < (unsigned long )end) {
#line 870
      if (! ((int const   )_sch_istable[(int const   )*(end + -1) & 255] & 64)) {
#line 870
        goto while_break;
      }
    } else {
#line 870
      goto while_break;
    }
#line 871
    end --;
  }
  while_break: /* CIL Label */ ;
  }
#line 872
  if ((unsigned long )val == (unsigned long )end) {
#line 873
    return (0);
  }
  {
#line 877
  if ((int const   )_sch_tolower[(int const   )*(end + -1) & 255] == 107) {
#line 877
    goto case_107;
  }
#line 880
  if ((int const   )_sch_tolower[(int const   )*(end + -1) & 255] == 109) {
#line 880
    goto case_109;
  }
#line 883
  if ((int const   )_sch_tolower[(int const   )*(end + -1) & 255] == 103) {
#line 883
    goto case_103;
  }
#line 886
  if ((int const   )_sch_tolower[(int const   )*(end + -1) & 255] == 116) {
#line 886
    goto case_116;
  }
#line 889
  goto switch_default;
  case_107: /* CIL Label */ 
#line 878
  end --;
#line 878
  mult = 1024.0;
#line 879
  goto switch_break;
  case_109: /* CIL Label */ 
#line 881
  end --;
#line 881
  mult = 1048576.0;
#line 882
  goto switch_break;
  case_103: /* CIL Label */ 
#line 884
  end --;
#line 884
  mult = 1073741824.0;
#line 885
  goto switch_break;
  case_116: /* CIL Label */ 
#line 887
  end --;
#line 887
  mult = 1099511627776.0;
#line 888
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 892
  mult = (double )1;
  switch_break: /* CIL Label */ ;
  }
  {
#line 896
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 896
    if ((unsigned long )val < (unsigned long )end) {
#line 896
      if (! ((int const   )_sch_istable[(int const   )*val & 255] & 64)) {
#line 896
        goto while_break___0;
      }
    } else {
#line 896
      goto while_break___0;
    }
#line 897
    val ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 898
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 898
    if ((unsigned long )val < (unsigned long )end) {
#line 898
      if (! ((int const   )_sch_istable[(int const   )*(end + -1) & 255] & 64)) {
#line 898
        goto while_break___1;
      }
    } else {
#line 898
      goto while_break___1;
    }
#line 899
    end --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 900
  if ((unsigned long )val == (unsigned long )end) {
#line 901
    return (0);
  }
  {
#line 903
  tmp___1 = simple_atof(val, end, & number);
  }
#line 903
  if (! tmp___1) {
#line 904
    return (0);
  }
#line 906
  *result = number * mult;
#line 907
  return (1);
}
}
#line 924 "init.c"
static int cmd_bytes(char const   *com , char const   *val , void *closure ) 
{ 
  double byte_value ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 928
  tmp___0 = parse_bytes_helper(val, & byte_value);
  }
#line 928
  if (! tmp___0) {
    {
#line 930
    tmp = gettext("%s: %s: Invalid byte value `%s\'\n");
#line 930
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
            exec_name, com, val);
    }
#line 932
    return (0);
  }
#line 934
  *((long *)closure) = (long )byte_value;
#line 935
  return (1);
}
}
#line 943 "init.c"
static int cmd_bytes_large(char const   *com , char const   *val , void *closure ) 
{ 
  double byte_value ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 947
  tmp___0 = parse_bytes_helper(val, & byte_value);
  }
#line 947
  if (! tmp___0) {
    {
#line 949
    tmp = gettext("%s: %s: Invalid byte value `%s\'\n");
#line 949
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
            exec_name, com, val);
    }
#line 951
    return (0);
  }
#line 953
  *((LARGE_INT *)closure) = (LARGE_INT )byte_value;
#line 954
  return (1);
}
}
#line 961 "init.c"
static int cmd_time(char const   *com , char const   *val , void *closure ) 
{ 
  double number ;
  double mult ;
  char const   *end ;
  size_t tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 965
  tmp = strlen(val);
#line 965
  end = val + tmp;
  }
  {
#line 968
  while (1) {
    while_continue: /* CIL Label */ ;
#line 968
    if ((unsigned long )val < (unsigned long )end) {
#line 968
      if (! ((int const   )_sch_istable[(int const   )*(end + -1) & 255] & 64)) {
#line 968
        goto while_break;
      }
    } else {
#line 968
      goto while_break;
    }
#line 969
    end --;
  }
  while_break: /* CIL Label */ ;
  }
#line 971
  if ((unsigned long )val == (unsigned long )end) {
    err: 
    {
#line 974
    tmp___0 = gettext("%s: %s: Invalid time period `%s\'\n");
#line 974
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            exec_name, com, val);
    }
#line 976
    return (0);
  }
  {
#line 981
  if ((int const   )_sch_tolower[(int const   )*(end + -1) & 255] == 115) {
#line 981
    goto case_115;
  }
#line 984
  if ((int const   )_sch_tolower[(int const   )*(end + -1) & 255] == 109) {
#line 984
    goto case_109;
  }
#line 987
  if ((int const   )_sch_tolower[(int const   )*(end + -1) & 255] == 104) {
#line 987
    goto case_104;
  }
#line 990
  if ((int const   )_sch_tolower[(int const   )*(end + -1) & 255] == 100) {
#line 990
    goto case_100;
  }
#line 993
  if ((int const   )_sch_tolower[(int const   )*(end + -1) & 255] == 119) {
#line 993
    goto case_119;
  }
#line 996
  goto switch_default;
  case_115: /* CIL Label */ 
#line 982
  end --;
#line 982
  mult = (double )1;
#line 983
  goto switch_break;
  case_109: /* CIL Label */ 
#line 985
  end --;
#line 985
  mult = (double )60;
#line 986
  goto switch_break;
  case_104: /* CIL Label */ 
#line 988
  end --;
#line 988
  mult = (double )3600;
#line 989
  goto switch_break;
  case_100: /* CIL Label */ 
#line 991
  end --;
#line 991
  mult = 86400.0;
#line 992
  goto switch_break;
  case_119: /* CIL Label */ 
#line 994
  end --;
#line 994
  mult = 604800.0;
#line 995
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 999
  mult = (double )1;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1003
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1003
    if ((unsigned long )val < (unsigned long )end) {
#line 1003
      if (! ((int const   )_sch_istable[(int const   )*val & 255] & 64)) {
#line 1003
        goto while_break___0;
      }
    } else {
#line 1003
      goto while_break___0;
    }
#line 1004
    val ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1005
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1005
    if ((unsigned long )val < (unsigned long )end) {
#line 1005
      if (! ((int const   )_sch_istable[(int const   )*(end + -1) & 255] & 64)) {
#line 1005
        goto while_break___1;
      }
    } else {
#line 1005
      goto while_break___1;
    }
#line 1006
    end --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1007
  if ((unsigned long )val == (unsigned long )end) {
#line 1008
    goto err;
  }
  {
#line 1010
  tmp___1 = simple_atof(val, end, & number);
  }
#line 1010
  if (! tmp___1) {
#line 1011
    goto err;
  }
#line 1013
  *((double *)closure) = number * mult;
#line 1014
  return (1);
}
}
#line 1020
static int check_user_specified_header(char const   *s ) ;
#line 1022 "init.c"
static int cmd_spec_dirstruct(char const   *com , char const   *val , void *closure ) 
{ 
  int tmp ;

  {
  {
#line 1025
  tmp = cmd_boolean(com, val, (void *)(& opt.dirstruct));
  }
#line 1025
  if (! tmp) {
#line 1026
    return (0);
  }
#line 1029
  if (opt.dirstruct) {
#line 1030
    opt.no_dirstruct = 0;
  } else {
#line 1032
    opt.no_dirstruct = 1;
  }
#line 1033
  return (1);
}
}
#line 1036 "init.c"
static int cmd_spec_header(char const   *com , char const   *val , void *closure ) 
{ 
  int i ;
  char *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 1039
  if (! *val) {
    {
#line 1042
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1042
      if (opt.user_header) {
        {
#line 1042
        free((void *)opt.user_header);
        }
      }
#line 1042
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 1043
    opt.user_header = (char *)((void *)0);
  } else {
    {
#line 1049
    tmp___0 = check_user_specified_header(val);
    }
#line 1049
    if (! tmp___0) {
      {
#line 1051
      tmp = gettext("%s: %s: Invalid header `%s\'.\n");
#line 1051
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
              exec_name, com, val);
      }
#line 1053
      return (0);
    }
#line 1055
    if (opt.user_header) {
      {
#line 1055
      tmp___1 = strlen((char const   *)opt.user_header);
#line 1055
      i = (int )tmp___1;
      }
    } else {
#line 1055
      i = 0;
    }
    {
#line 1056
    tmp___2 = strlen(val);
#line 1056
    tmp___3 = xrealloc_real((void *)opt.user_header, (((size_t )i + tmp___2) + 2U) + 1U);
#line 1056
    opt.user_header = (char *)tmp___3;
#line 1058
    strcpy((char */* __restrict  */)(opt.user_header + i), (char const   */* __restrict  */)val);
#line 1059
    tmp___4 = strlen(val);
#line 1059
    i = (int )((size_t )i + tmp___4);
#line 1060
    tmp___5 = i;
#line 1060
    i ++;
#line 1060
    *(opt.user_header + tmp___5) = (char )'\r';
#line 1061
    tmp___6 = i;
#line 1061
    i ++;
#line 1061
    *(opt.user_header + tmp___6) = (char )'\n';
#line 1062
    *(opt.user_header + i) = (char )'\000';
    }
  }
#line 1064
  return (1);
}
}
#line 1067 "init.c"
static int cmd_spec_htmlify(char const   *com , char const   *val , void *closure ) 
{ 
  int flag ;
  int tmp ;

  {
  {
#line 1070
  tmp = cmd_boolean(com, val, (void *)(& opt.htmlify));
#line 1070
  flag = tmp;
  }
#line 1071
  if (flag) {
#line 1071
    if (! opt.htmlify) {
#line 1072
      opt.remove_listing = 0;
    }
  }
#line 1073
  return (flag);
}
}
#line 1079 "init.c"
static int cmd_spec_mirror(char const   *com , char const   *val , void *closure ) 
{ 
  int mirror ;
  int tmp ;

  {
  {
#line 1084
  tmp = cmd_boolean(com, val, (void *)(& mirror));
  }
#line 1084
  if (! tmp) {
#line 1085
    return (0);
  }
#line 1086
  if (mirror) {
#line 1088
    opt.recursive = 1;
#line 1089
    if (! opt.no_dirstruct) {
#line 1090
      opt.dirstruct = 1;
    }
#line 1091
    opt.timestamping = 1;
#line 1092
    opt.reclevel = -1;
#line 1093
    opt.remove_listing = 0;
  }
#line 1095
  return (1);
}
}
#line 1101 "init.c"
static int cmd_spec_progress(char const   *com , char const   *val , void *closure ) 
{ 
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 1104
  tmp___0 = valid_progress_implementation_p(val);
  }
#line 1104
  if (! tmp___0) {
    {
#line 1106
    tmp = gettext("%s: %s: Invalid progress type `%s\'.\n");
#line 1106
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
            exec_name, com, val);
    }
#line 1108
    return (0);
  }
  {
#line 1110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1110
    if (opt.progress_type) {
      {
#line 1110
      free((void *)opt.progress_type);
      }
    }
#line 1110
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1114
  opt.progress_type = xstrdup_real(val);
  }
#line 1115
  return (1);
}
}
#line 1122 "init.c"
static int cmd_spec_recursive(char const   *com , char const   *val , void *closure ) 
{ 
  int tmp ;

  {
  {
#line 1125
  tmp = cmd_boolean(com, val, (void *)(& opt.recursive));
  }
#line 1125
  if (tmp) {
#line 1129
    if (opt.recursive) {
#line 1129
      if (! opt.no_dirstruct) {
#line 1130
        opt.dirstruct = 1;
      }
    }
  } else {
#line 1126
    return (0);
  }
#line 1132
  return (1);
}
}
#line 1135 "init.c"
static int cmd_spec_restrict_file_names(char const   *com , char const   *val , void *closure ) 
{ 
  int restrict_os ;
  int restrict_ctrl ;
  char const   *end ;
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 1138
  restrict_os = (int )opt.restrict_files_os;
#line 1139
  restrict_ctrl = opt.restrict_files_ctrl;
#line 1141
  tmp = strchr(val, ',');
#line 1141
  end = (char const   *)tmp;
  }
#line 1142
  if (! end) {
    {
#line 1143
    tmp___0 = strlen(val);
#line 1143
    end = val + tmp___0;
    }
  }
#line 1147
  if ((unsigned long )(end - val) == sizeof("unix") - 1UL) {
    {
#line 1147
    tmp___4 = memcmp((void const   *)val, (void const   *)"unix", (size_t )(sizeof("unix") - 1UL));
    }
#line 1147
    if (tmp___4) {
#line 1147
      goto _L___1;
    } else {
#line 1148
      restrict_os = 0;
    }
  } else
  _L___1: /* CIL Label */ 
#line 1149
  if ((unsigned long )(end - val) == sizeof("windows") - 1UL) {
    {
#line 1149
    tmp___3 = memcmp((void const   *)val, (void const   *)"windows", (size_t )(sizeof("windows") - 1UL));
    }
#line 1149
    if (tmp___3) {
#line 1149
      goto _L___0;
    } else {
#line 1150
      restrict_os = 1;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1151
  if ((unsigned long )(end - val) == sizeof("nocontrol") - 1UL) {
    {
#line 1151
    tmp___2 = memcmp((void const   *)val, (void const   *)"nocontrol", (size_t )(sizeof("nocontrol") - 1UL));
    }
#line 1151
    if (tmp___2) {
#line 1151
      goto err;
    } else {
#line 1152
      restrict_ctrl = 0;
    }
  } else {
    err: 
    {
#line 1156
    tmp___1 = gettext("%s: %s: Invalid restriction `%s\', use `unix\' or `windows\'.\n");
#line 1156
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
            exec_name, com, val);
    }
#line 1159
    return (0);
  }
#line 1164
  if (*end) {
    {
#line 1166
    tmp___5 = strcmp(end + 1, "nocontrol");
    }
#line 1166
    if (tmp___5) {
#line 1169
      goto err;
    } else {
#line 1167
      restrict_ctrl = 0;
    }
  }
#line 1172
  opt.restrict_files_os = (enum __anonenum_restrict_files_os_46 )restrict_os;
#line 1173
  opt.restrict_files_ctrl = restrict_ctrl;
#line 1174
  return (1);
}
}
#line 1179 "init.c"
static int cmd_spec_timeout(char const   *com , char const   *val , void *closure ) 
{ 
  double value ;
  int tmp ;

  {
  {
#line 1183
  tmp = cmd_time(com, val, (void *)(& value));
  }
#line 1183
  if (! tmp) {
#line 1184
    return (0);
  }
#line 1185
  opt.read_timeout = value;
#line 1186
  opt.connect_timeout = value;
#line 1187
  opt.dns_timeout = value;
#line 1188
  return (1);
}
}
#line 1191 "init.c"
static int cmd_spec_useragent(char const   *com , char const   *val , void *closure ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 1196
  if (! *val) {
    {
#line 1198
    tmp = gettext("%s: %s: Invalid value `%s\'.\n");
#line 1198
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
            exec_name, com, val);
    }
#line 1200
    return (0);
  } else {
    {
#line 1196
    tmp___0 = strchr(val, '\n');
    }
#line 1196
    if (tmp___0) {
      {
#line 1198
      tmp = gettext("%s: %s: Invalid value `%s\'.\n");
#line 1198
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
              exec_name, com, val);
      }
#line 1200
      return (0);
    }
  }
  {
#line 1202
  opt.useragent = xstrdup_real(val);
  }
#line 1203
  return (1);
}
}
#line 1212 "init.c"
static int simple_atoi(char const   *beg , char const   *end , int *dest ) 
{ 
  int result ;
  char const   *p ;

  {
#line 1215
  result = 0;
#line 1218
  if ((unsigned long )beg == (unsigned long )end) {
#line 1219
    return (0);
  }
#line 1221
  p = beg;
  {
#line 1221
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1221
    if ((unsigned long )p < (unsigned long )end) {
#line 1221
      if (! ((int const   )_sch_istable[(int const   )*p & 255] & 4)) {
#line 1221
        goto while_break;
      }
    } else {
#line 1221
      goto while_break;
    }
#line 1222
    result = 10 * result + (int )((int const   )*p - 48);
#line 1221
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1224
  if ((unsigned long )p != (unsigned long )end) {
#line 1225
    return (0);
  }
#line 1227
  *dest = result;
#line 1228
  return (1);
}
}
#line 1235 "init.c"
static int simple_atof(char const   *beg , char const   *end , double *dest ) 
{ 
  double result ;
  int seen_dot ;
  int seen_digit ;
  double divider ;
  char const   *p ;
  char ch ;

  {
#line 1238
  result = (double )0;
#line 1240
  seen_dot = 0;
#line 1241
  seen_digit = 0;
#line 1242
  divider = (double )1;
#line 1246
  p = beg;
  {
#line 1246
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1246
    if (! ((unsigned long )p < (unsigned long )end)) {
#line 1246
      goto while_break;
    }
#line 1248
    ch = (char )*p;
#line 1249
    if ((int const   )_sch_istable[(int )ch & 255] & 4) {
#line 1251
      if (! seen_dot) {
#line 1252
        result = (double )10 * result + (double )((int )ch - 48);
      } else {
#line 1254
        divider *= (double )10;
#line 1254
        result += (double )((int )ch - 48) / divider;
      }
#line 1255
      seen_digit = 1;
    } else
#line 1257
    if ((int )ch == 46) {
#line 1259
      if (! seen_dot) {
#line 1260
        seen_dot = 1;
      } else {
#line 1262
        return (0);
      }
    } else {
#line 1265
      return (0);
    }
#line 1246
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1267
  if (! seen_digit) {
#line 1268
    return (0);
  }
#line 1270
  *dest = result;
#line 1271
  return (1);
}
}
#line 1274 "init.c"
static int check_user_specified_header(char const   *s ) 
{ 
  char const   *p ;
  char *tmp ;

  {
#line 1279
  p = s;
  {
#line 1279
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1279
    if (*p) {
#line 1279
      if ((int const   )*p != 58) {
#line 1279
        if (! (! ((int const   )_sch_istable[(int const   )*p & 255] & 64))) {
#line 1279
          goto while_break;
        }
      } else {
#line 1279
        goto while_break;
      }
    } else {
#line 1279
      goto while_break;
    }
#line 1279
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1282
  if ((int const   )*p != 58) {
#line 1283
    return (0);
  } else
#line 1282
  if ((unsigned long )p == (unsigned long )s) {
#line 1283
    return (0);
  }
  {
#line 1285
  tmp = strchr(s, '\n');
  }
#line 1285
  if (tmp) {
#line 1286
    return (0);
  }
#line 1287
  return (1);
}
}
#line 1297 "init.c"
void cleanup(void) 
{ 


  {
#line 1302
  if (opt.dfp) {
    {
#line 1303
    fclose(opt.dfp);
    }
  }
#line 1357
  return;
}
}
#line 603 "/usr/include/stdio.h"
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 653
extern void rewind(FILE *__stream ) ;
#line 720
extern void clearerr(FILE *__stream ) ;
#line 722
extern int feof(FILE *__stream ) ;
#line 89 "/usr/include/string.h"
extern char *strcat(char * __restrict  __dest , char const   * __restrict  __src ) ;
#line 186
extern char *strstr(char const   *__haystack , char const   *__needle )  __attribute__((__pure__)) ;
#line 893 "/usr/include/unistd.h"
extern int ftruncate(int __fd , __off_t __length ) ;
#line 191 "/usr/include/time.h"
extern time_t mktime(struct tm *__tp ) ;
#line 205
extern char *strptime(char const   * __restrict  __s , char const   * __restrict  __fmt ,
                      struct tm *__tp ) ;
#line 229
extern struct tm *gmtime(time_t const   *__timer ) ;
#line 77 "host.h"
struct address_list *lookup_host(char const   *host , int silent ) ;
#line 83
int address_list_match_all(struct address_list *al1 , struct address_list *al2 ) ;
#line 86
void address_list_release(struct address_list *al ) ;
#line 40 "headers.h"
int header_get(struct rbuf *rbuf , char **hdr , enum header_get_flags flags ) ;
#line 41
int header_process(char const   *header , char const   *name , int (*procfun)(char const   * ,
                                                                              void * ) ,
                   void *arg ) ;
#line 45
int header_extract_number(char const   *header , void *closure ) ;
#line 46
int header_strdup(char const   *header , void *closure ) ;
#line 47
int header_exists(char const   *header , void *closure ) ;
#line 49
int skip_lws(char const   *string ) ;
#line 38 "connect.h"
int connect_to_many(struct address_list *al , unsigned short port , int silent ) ;
#line 39
void set_connection_host_name(char const   *host ) ;
#line 41
int test_socket_open(int sock ) ;
#line 49
int iwrite(int fd , char *buf___0 , int len ) ;
#line 35 "cookies.h"
struct cookie_jar *cookie_jar_new(void) ;
#line 38
void cookie_jar_process_set_cookie(struct cookie_jar *jar , char const   *host , int port ,
                                   char const   *path , char const   *set_cookie ) ;
#line 40
char *cookie_jar_generate_cookie_header(struct cookie_jar *jar , char const   *host ,
                                        int port , char const   *path , int connection_secure_p ) ;
#line 44
void cookie_jar_load(struct cookie_jar *jar , char const   *file ) ;
#line 92 "convert.h"
downloaded_file_t downloaded_file(downloaded_file_t mode , char const   *file ) ;
#line 82 "http.c"
static int cookies_loaded_p  ;
#line 83 "http.c"
struct cookie_jar *wget_cookie_jar  ;
#line 130 "http.c"
static int parse_http_status_line(char const   *line , char const   **reason_phrase_ptr ) 
{ 
  int mjr ;
  int mnr ;
  int statcode ;
  char const   *p ;
  int tmp ;

  {
  {
#line 138
  *reason_phrase_ptr = (char const   *)((void *)0);
#line 142
  tmp = strncmp(line, "HTTP/", (size_t )5);
  }
#line 142
  if (tmp != 0) {
#line 143
    return (-1);
  }
#line 144
  line += 5;
#line 147
  p = line;
#line 148
  mjr = 0;
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;
#line 148
    if (! ((int const   )_sch_istable[(int const   )*line & 255] & 4)) {
#line 148
      goto while_break;
    }
#line 149
    mjr = 10 * mjr + (int )((int const   )*line - 48);
#line 148
    line ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 150
  if ((int const   )*line != 46) {
#line 151
    return (-1);
  } else
#line 150
  if ((unsigned long )p == (unsigned long )line) {
#line 151
    return (-1);
  }
#line 152
  line ++;
#line 155
  p = line;
#line 156
  mnr = 0;
  {
#line 156
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 156
    if (! ((int const   )_sch_istable[(int const   )*line & 255] & 4)) {
#line 156
      goto while_break___0;
    }
#line 157
    mnr = 10 * mnr + (int )((int const   )*line - 48);
#line 156
    line ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 158
  if ((int const   )*line != 32) {
#line 159
    return (-1);
  } else
#line 158
  if ((unsigned long )p == (unsigned long )line) {
#line 159
    return (-1);
  }
#line 162
  if (mjr < 1) {
#line 163
    return (-1);
  }
#line 164
  line ++;
#line 167
  if ((int const   )_sch_istable[(int const   )*line & 255] & 4) {
#line 167
    if ((int const   )_sch_istable[(int const   )*(line + 1) & 255] & 4) {
#line 167
      if (! ((int const   )_sch_istable[(int const   )*(line + 2) & 255] & 4)) {
#line 168
        return (-1);
      }
    } else {
#line 168
      return (-1);
    }
  } else {
#line 168
    return (-1);
  }
#line 169
  statcode = (100 * (int )((int const   )*line - 48) + 10 * (int )((int const   )*(line + 1) - 48)) + (int )((int const   )*(line + 2) - 48);
#line 172
  line += 3;
#line 175
  if ((int const   )*line != 32) {
#line 177
    if (! *line) {
#line 178
      *reason_phrase_ptr = line;
    } else {
#line 180
      return (-1);
    }
  } else {
#line 183
    *reason_phrase_ptr = line + 1;
  }
#line 185
  return (statcode);
}
}
#line 197 "http.c"
static char chunk[8192]  ;
#line 194 "http.c"
static int post_file(int sock , void *ssl , char const   *file_name , long promised_size ) 
{ 
  long written ;
  int write_error ;
  FILE *fp ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  int towrite ;
  int length ;
  size_t tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  long tmp___6 ;

  {
#line 198
  written = 0L;
#line 203
  if (sock > -1) {
#line 203
    tmp = 1;
  } else
#line 203
  if ((unsigned long )ssl != (unsigned long )((void *)0)) {
#line 203
    tmp = 1;
  } else {
#line 203
    tmp = 0;
  }
  {
#line 203
  tmp___0 = __builtin_expect((long )tmp, 1L);
  }
#line 203
  if (! tmp___0) {
    {
#line 203
    __assert_fail("sock > -1 || ssl != ((void *)0)", "http.c", 203U, "post_file");
    }
  }
#line 204
  if (sock == -1) {
#line 204
    tmp___1 = 1;
  } else
#line 204
  if ((unsigned long )ssl == (unsigned long )((void *)0)) {
#line 204
    tmp___1 = 1;
  } else {
#line 204
    tmp___1 = 0;
  }
  {
#line 204
  tmp___2 = __builtin_expect((long )tmp___1, 1L);
  }
#line 204
  if (! tmp___2) {
    {
#line 204
    __assert_fail("sock == -1 || ssl == ((void *)0)", "http.c", 204U, "post_file");
    }
  }
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 206
    if (opt.debug) {
      {
#line 206
      debug_logprintf("[writing POST file %s ... ", file_name);
      }
    }
#line 206
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 208
  fp = fopen((char const   */* __restrict  */)file_name, (char const   */* __restrict  */)"rb");
  }
#line 209
  if (! fp) {
#line 210
    return (-1);
  }
  {
#line 211
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 211
    tmp___4 = feof(fp);
    }
#line 211
    if (tmp___4) {
#line 211
      goto while_break___0;
    } else
#line 211
    if (! (written < promised_size)) {
#line 211
      goto while_break___0;
    }
    {
#line 214
    tmp___3 = fread((void */* __restrict  */)(chunk), (size_t )1, (size_t )sizeof(chunk),
                    (FILE */* __restrict  */)fp);
#line 214
    length = (int )tmp___3;
    }
#line 215
    if (length == 0) {
#line 216
      goto while_break___0;
    }
#line 217
    if (promised_size - written > (long )length) {
#line 217
      towrite = length;
    } else {
#line 217
      towrite = (int )(promised_size - written);
    }
#line 219
    if (ssl) {
      {
#line 220
      write_error = ssl_iwrite((SSL *)ssl, chunk, towrite);
      }
    } else {
      {
#line 223
      write_error = iwrite(sock, chunk, towrite);
      }
    }
#line 224
    if (write_error < 0) {
      {
#line 226
      fclose(fp);
      }
#line 227
      return (-1);
    }
#line 229
    written += (long )towrite;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 231
  fclose(fp);
  }
#line 235
  if (written < promised_size) {
    {
#line 237
    tmp___5 = __errno_location();
#line 237
    *tmp___5 = 22;
    }
#line 238
    return (-1);
  }
  {
#line 241
  tmp___6 = __builtin_expect((long )(! (! (written == promised_size))), 1L);
  }
#line 241
  if (! tmp___6) {
    {
#line 241
    __assert_fail("written == promised_size", "http.c", 241U, "post_file");
    }
  }
  {
#line 242
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 242
    if (opt.debug) {
      {
#line 242
      debug_logprintf("done]\n");
      }
    }
#line 242
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 243
  return (0);
}
}
#line 256 "http.c"
static int http_process_range(char const   *hdr , void *arg ) 
{ 
  struct http_process_range_closure *closure ;
  long num ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 259
  closure = (struct http_process_range_closure *)arg;
#line 267
  tmp___0 = strncasecmp(hdr, "bytes", (size_t )5);
  }
#line 267
  if (! tmp___0) {
#line 269
    hdr += 5;
#line 272
    if ((int const   )*hdr == 58) {
#line 273
      hdr ++;
    }
    {
#line 274
    tmp = skip_lws(hdr);
#line 274
    hdr += tmp;
    }
#line 275
    if (! *hdr) {
#line 276
      return (0);
    }
  }
#line 278
  if (! ((int const   )_sch_istable[(int const   )*hdr & 255] & 4)) {
#line 279
    return (0);
  }
#line 280
  num = 0L;
  {
#line 280
  while (1) {
    while_continue: /* CIL Label */ ;
#line 280
    if (! ((int const   )_sch_istable[(int const   )*hdr & 255] & 4)) {
#line 280
      goto while_break;
    }
#line 281
    num = 10L * num + (long )((int const   )*hdr - 48);
#line 280
    hdr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 282
  if ((int const   )*hdr != 45) {
#line 283
    return (0);
  } else
#line 282
  if (! ((int const   )_sch_istable[(int const   )*(hdr + 1) & 255] & 4)) {
#line 283
    return (0);
  }
#line 284
  closure->first_byte_pos = num;
#line 285
  hdr ++;
#line 286
  num = 0L;
  {
#line 286
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 286
    if (! ((int const   )_sch_istable[(int const   )*hdr & 255] & 4)) {
#line 286
      goto while_break___0;
    }
#line 287
    num = 10L * num + (long )((int const   )*hdr - 48);
#line 286
    hdr ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 288
  if ((int const   )*hdr != 47) {
#line 289
    return (0);
  } else
#line 288
  if (! ((int const   )_sch_istable[(int const   )*(hdr + 1) & 255] & 4)) {
#line 289
    return (0);
  }
#line 290
  closure->last_byte_pos = num;
#line 291
  hdr ++;
#line 292
  num = 0L;
  {
#line 292
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 292
    if (! ((int const   )_sch_istable[(int const   )*hdr & 255] & 4)) {
#line 292
      goto while_break___1;
    }
#line 293
    num = 10L * num + (long )((int const   )*hdr - 48);
#line 292
    hdr ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 294
  closure->entity_length = num;
#line 295
  return (1);
}
}
#line 300 "http.c"
static int http_process_none(char const   *hdr , void *arg ) 
{ 
  int *where ;
  char *tmp ;

  {
  {
#line 303
  where = (int *)arg;
#line 305
  tmp = strstr(hdr, "none");
  }
#line 305
  if (tmp) {
#line 306
    *where = 1;
  } else {
#line 308
    *where = 0;
  }
#line 309
  return (1);
}
}
#line 313 "http.c"
static int http_process_type(char const   *hdr , void *arg ) 
{ 
  char **result ;
  char const   *p ;
  char *tmp ;
  size_t tmp___0 ;

  {
  {
#line 316
  result = (char **)arg;
#line 318
  tmp = strchr(hdr, ';');
#line 318
  p = (char const   *)tmp;
  }
#line 319
  if (! p) {
    {
#line 320
    tmp___0 = strlen(hdr);
#line 320
    p = hdr + tmp___0;
    }
  }
  {
#line 321
  while (1) {
    while_continue: /* CIL Label */ ;
#line 321
    if ((unsigned long )p > (unsigned long )hdr) {
#line 321
      if (! ((int const   )_sch_istable[(int const   )*(p - 1) & 255] & 64)) {
#line 321
        goto while_break;
      }
    } else {
#line 321
      goto while_break;
    }
#line 322
    p --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 323
  *result = strdupdelim(hdr, p);
  }
#line 324
  return (1);
}
}
#line 328 "http.c"
static int http_process_connection(char const   *hdr , void *arg ) 
{ 
  int *flag ;
  int tmp ;

  {
  {
#line 331
  flag = (int *)arg;
#line 332
  tmp = strcasecmp(hdr, "Keep-Alive");
  }
#line 332
  if (! tmp) {
#line 333
    *flag = 1;
  }
#line 334
  return (1);
}
}
#line 339 "http.c"
int http_process_set_cookie(char const   *hdr , void *arg ) 
{ 
  struct url *u ;
  long tmp ;

  {
  {
#line 342
  u = (struct url *)arg;
#line 345
  tmp = __builtin_expect((long )(! (! ((unsigned long )wget_cookie_jar != (unsigned long )((void *)0)))),
                         1L);
  }
#line 345
  if (! tmp) {
    {
#line 345
    __assert_fail("wget_cookie_jar != ((void *)0)", "http.c", 345U, "http_process_set_cookie");
    }
  }
  {
#line 347
  cookie_jar_process_set_cookie(wget_cookie_jar, (char const   *)u->host, u->port,
                                (char const   *)u->path, hdr);
  }
#line 349
  return (1);
}
}
#line 362 "http.c"
static int pc_active_p  ;
#line 364 "http.c"
static struct address_list *pc_last_host_ip  ;
#line 365 "http.c"
static unsigned short pc_last_port  ;
#line 368 "http.c"
static int pc_last_fd  ;
#line 372 "http.c"
static int pc_active_ssl  ;
#line 374 "http.c"
static SSL *pc_last_ssl  ;
#line 382 "http.c"
static void invalidate_persistent(void) 
{ 


  {
#line 385
  pc_active_p = 0;
#line 387
  pc_active_ssl = 0;
#line 389
  if ((unsigned long )pc_last_host_ip != (unsigned long )((void *)0)) {
    {
#line 391
    address_list_release(pc_last_host_ip);
#line 392
    pc_last_host_ip = (struct address_list *)((void *)0);
    }
  }
  {
#line 394
  while (1) {
    while_continue: /* CIL Label */ ;
#line 394
    if (opt.debug) {
      {
#line 394
      debug_logprintf("Invalidating fd %d from further reuse.\n", pc_last_fd);
      }
    }
#line 394
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 395
  return;
}
}
#line 406 "http.c"
static void register_persistent(char const   *host , unsigned short port , int fd ,
                                SSL *ssl ) 
{ 
  long tmp ;
  long tmp___0 ;

  {
#line 414
  if (pc_active_p) {
#line 416
    if (pc_last_fd == fd) {
#line 420
      return;
    } else {
#line 432
      if (pc_last_ssl) {
        {
#line 433
        shutdown_ssl(pc_last_ssl);
        }
      }
      {
#line 435
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 435
        close(pc_last_fd);
        }
        {
#line 435
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 435
          if (opt.debug) {
            {
#line 435
            debug_logprintf("Closing fd %d\n", pc_last_fd);
            }
          }
#line 435
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 435
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 436
      invalidate_persistent();
      }
    }
  }
  {
#line 440
  tmp = __builtin_expect((long )(! (! ((unsigned long )pc_last_host_ip == (unsigned long )((void *)0)))),
                         1L);
  }
#line 440
  if (! tmp) {
    {
#line 440
    __assert_fail("pc_last_host_ip == ((void *)0)", "http.c", 440U, "register_persistent");
    }
  }
  {
#line 444
  pc_last_host_ip = lookup_host(host, 1);
#line 445
  tmp___0 = __builtin_expect((long )(! (! ((unsigned long )pc_last_host_ip != (unsigned long )((void *)0)))),
                             1L);
  }
#line 445
  if (! tmp___0) {
    {
#line 445
    __assert_fail("pc_last_host_ip != ((void *)0)", "http.c", 445U, "register_persistent");
    }
  }
#line 447
  pc_last_port = port;
#line 448
  pc_last_fd = fd;
#line 449
  pc_active_p = 1;
#line 451
  pc_last_ssl = ssl;
#line 452
  if (ssl) {
#line 452
    pc_active_ssl = 1;
  } else {
#line 452
    pc_active_ssl = 0;
  }
  {
#line 454
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 454
    if (opt.debug) {
      {
#line 454
      debug_logprintf("Registered fd %d for persistent reuse.\n", fd);
      }
    }
#line 454
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 455
  return;
}
}
#line 470 "http.c"
static int persistent_available_p(char const   *host , unsigned short port , int ssl ) 
{ 
  int success ;
  struct address_list *this_host_ip ;
  int tmp ;

  {
#line 482
  if (! pc_active_p) {
#line 483
    return (0);
  }
#line 486
  if ((int )port != (int )pc_last_port) {
#line 487
    return (0);
  }
#line 495
  if (ssl != pc_active_ssl) {
#line 496
    return (0);
  }
  {
#line 499
  this_host_ip = lookup_host(host, 1);
  }
#line 500
  if (! this_host_ip) {
#line 501
    return (0);
  }
  {
#line 506
  success = address_list_match_all(pc_last_host_ip, this_host_ip);
#line 507
  address_list_release(this_host_ip);
  }
#line 508
  if (! success) {
#line 509
    return (0);
  }
  {
#line 517
  tmp = test_socket_open(pc_last_fd);
  }
#line 517
  if (! tmp) {
    {
#line 522
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 522
      close(pc_last_fd);
      }
      {
#line 522
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 522
        if (opt.debug) {
          {
#line 522
          debug_logprintf("Closing fd %d\n", pc_last_fd);
          }
        }
#line 522
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 522
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 524
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 524
      if (pc_last_ssl) {
        {
#line 524
        shutdown_ssl(pc_last_ssl);
        }
      }
#line 524
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 525
    pc_last_ssl = (SSL *)((void *)0);
#line 527
    invalidate_persistent();
    }
#line 528
    return (0);
  }
#line 530
  return (1);
}
}
#line 582 "http.c"
static void free_hstat(struct http_stat *hs ) 
{ 


  {
  {
#line 585
  while (1) {
    while_continue: /* CIL Label */ ;
#line 585
    if (hs->newloc) {
      {
#line 585
      free((void *)hs->newloc);
      }
    }
#line 585
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 586
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 586
    if (hs->remote_time) {
      {
#line 586
      free((void *)hs->remote_time);
      }
    }
#line 586
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 587
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 587
    if (hs->error) {
      {
#line 587
      free((void *)hs->error);
      }
    }
#line 587
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 590
  hs->newloc = (char *)((void *)0);
#line 591
  hs->remote_time = (char *)((void *)0);
#line 592
  hs->error = (char *)((void *)0);
#line 593
  return;
}
}
#line 595
static char *create_authorization_line(char const   *au , char const   *user , char const   *passwd ,
                                       char const   *method , char const   *path ) ;
#line 598
static char *basic_authentication_encode(char const   *user , char const   *passwd ,
                                         char const   *header ) ;
#line 600
static int known_authentication_scheme_p(char const   *au ) ;
#line 602
time_t http_atotm(char const   *time_string ) ;
#line 640
static uerr_t gethttp(struct url *u , struct http_stat *hs , int *dt , struct url *proxy ) ;
#line 640 "http.c"
static SSL_CTX *ssl_ctx  =    (SSL_CTX *)((void *)0);
#line 621 "http.c"
static uerr_t gethttp(struct url *u , struct http_stat *hs , int *dt , struct url *proxy ) 
{ 
  char *request ;
  char *type ;
  char *command ;
  char *full_path ;
  char *user ;
  char *passwd ;
  char *pragma_h ;
  char *referer ;
  char *useragent ;
  char *range ;
  char *wwwauth ;
  char *authenticate_h ;
  char *proxyauth ;
  char *all_headers ;
  char *port_maybe ;
  char *request_keep_alive ;
  int sock ;
  int hcount ;
  int all_length ;
  int statcode ;
  int write_error ;
  long contlen ;
  long contrange ;
  struct url *conn ;
  FILE *fp ;
  int auth_tried_already ;
  struct rbuf rbuf ;
  SSL *ssl ;
  char *cookies ;
  int keep_alive ;
  int http_keep_alive_1 ;
  int http_keep_alive_2 ;
  int inhibit_keep_alive ;
  int squares_around_host ;
  char *post_content_type ;
  char *post_content_length ;
  long post_data_size ;
  uerr_t err ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  long tmp___5 ;
  int tmp___6 ;
  struct address_list *al ;
  struct address_list *tmp___7 ;
  int tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  size_t tmp___15 ;
  void *tmp___16 ;
  int tmp___17 ;
  void *tmp___18 ;
  size_t tmp___19 ;
  void *tmp___20 ;
  size_t tmp___21 ;
  void *tmp___22 ;
  char *pth ;
  char *tmp___23 ;
  char *proxy_user ;
  char *proxy_passwd ;
  int tmp___24 ;
  void *tmp___25 ;
  int tmp___26 ;
  size_t tmp___27 ;
  int tmp___28 ;
  void *tmp___29 ;
  char *tmp___30 ;
  size_t tmp___31 ;
  size_t tmp___32 ;
  size_t tmp___33 ;
  size_t tmp___34 ;
  size_t tmp___35 ;
  size_t tmp___36 ;
  size_t tmp___37 ;
  size_t tmp___38 ;
  size_t tmp___39 ;
  size_t tmp___40 ;
  size_t tmp___41 ;
  size_t tmp___42 ;
  size_t tmp___43 ;
  size_t tmp___44 ;
  size_t tmp___45 ;
  size_t tmp___46 ;
  size_t tmp___47 ;
  size_t tmp___48 ;
  size_t tmp___49 ;
  size_t tmp___50 ;
  size_t tmp___51 ;
  size_t tmp___52 ;
  size_t tmp___53 ;
  size_t tmp___54 ;
  size_t tmp___55 ;
  size_t tmp___56 ;
  void *tmp___57 ;
  char const   *tmp___58 ;
  char const   *tmp___59 ;
  char const   *tmp___60 ;
  char const   *tmp___61 ;
  char const   *tmp___62 ;
  char const   *tmp___63 ;
  char const   *tmp___64 ;
  char const   *tmp___65 ;
  char const   *tmp___66 ;
  char const   *tmp___67 ;
  char const   *tmp___68 ;
  char const   *tmp___69 ;
  size_t tmp___70 ;
  size_t tmp___71 ;
  int *tmp___72 ;
  char *tmp___73 ;
  char *tmp___74 ;
  char const   *tmp___75 ;
  char *tmp___76 ;
  char *hdr ;
  int status ;
  int tmp___77 ;
  char *tmp___78 ;
  int *tmp___79 ;
  char *tmp___80 ;
  char *tmp___81 ;
  int lh ;
  size_t tmp___82 ;
  void *tmp___83 ;
  int tmp___84 ;
  char const   *error ;
  char *tmp___85 ;
  char *tmp___86 ;
  char *tmp___87 ;
  int tmp___88 ;
  int tmp___89 ;
  int tmp___90 ;
  int tmp___91 ;
  int tmp___92 ;
  int tmp___93 ;
  int nonep ;
  int tmp___94 ;
  struct http_process_range_closure closure ;
  int tmp___95 ;
  int tmp___96 ;
  int tmp___97 ;
  long tmp___98 ;
  char *tmp___99 ;
  char *tmp___100 ;
  int tmp___101 ;
  int tmp___102 ;
  char *tmp___103 ;
  char const   *tmp___104 ;
  char *tmp___105 ;
  char *tmp___106 ;
  char *tmp___107 ;
  size_t tmp___108 ;
  int tmp___109 ;
  size_t tmp___110 ;
  int tmp___111 ;
  char *last_period_in_local_filename ;
  char *tmp___112 ;
  size_t local_filename_len ;
  size_t tmp___113 ;
  void *tmp___114 ;
  int tmp___115 ;
  int tmp___116 ;
  char *tmp___117 ;
  char *tmp___118 ;
  char *tmp___119 ;
  char *tmp___120 ;
  char *tmp___121 ;
  char *tmp___122 ;
  char *tmp___123 ;
  char *tmp___124 ;
  char *tmp___125 ;
  char const   *tmp___126 ;
  int *tmp___127 ;
  char *tmp___128 ;
  int tmp___129 ;
  long tmp___130 ;
  int flush_res ;

  {
#line 641
  ssl = (SSL *)((void *)0);
#line 643
  cookies = (char *)((void *)0);
#line 659
  squares_around_host = 0;
#line 663
  post_data_size = 0L;
#line 667
  if (! ssl_ctx) {
    {
#line 669
    tmp = (int )init_ssl(& ssl_ctx);
#line 669
    err = (uerr_t )tmp;
    }
#line 670
    if ((unsigned int )err != 0U) {
      {
#line 674
      if ((unsigned int )err == 58U) {
#line 674
        goto case_58;
      }
#line 679
      if ((unsigned int )err == 56U) {
#line 679
        goto case_56;
      }
#line 688
      if ((unsigned int )err == 57U) {
#line 688
        goto case_57;
      }
#line 696
      goto switch_default;
      case_58: /* CIL Label */ 
      {
#line 676
      tmp___0 = gettext("Failed to set up an SSL context\n");
#line 676
      logprintf((enum log_options )1, (char const   *)tmp___0);
#line 677
      ssl_printerrors();
      }
#line 678
      return (err);
      case_56: /* CIL Label */ 
      {
#line 681
      tmp___1 = gettext("Failed to load certificates from %s\n");
#line 681
      logprintf((enum log_options )1, (char const   *)tmp___1, opt.sslcertfile);
#line 684
      ssl_printerrors();
#line 685
      tmp___2 = gettext("Trying without the specified certificate\n");
#line 685
      logprintf((enum log_options )1, (char const   *)tmp___2);
      }
#line 687
      goto switch_break;
      case_57: /* CIL Label */ 
      {
#line 689
      tmp___3 = gettext("Failed to get certificate key from %s\n");
#line 689
      logprintf((enum log_options )1, (char const   *)tmp___3, opt.sslcertkey);
#line 692
      ssl_printerrors();
#line 693
      tmp___4 = gettext("Trying without the specified certificate\n");
#line 693
      logprintf((enum log_options )1, (char const   *)tmp___4);
      }
#line 695
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 697
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
#line 703
  if (! (*dt & 4)) {
    {
#line 706
    tmp___5 = __builtin_expect((long )(! (! ((unsigned long )*(hs->local_file) != (unsigned long )((void *)0)))),
                               1L);
    }
#line 706
    if (! tmp___5) {
      {
#line 706
      __assert_fail("*hs->local_file != ((void *)0)", "http.c", 706U, "gethttp");
      }
    }
  }
#line 708
  authenticate_h = (char *)0;
#line 709
  auth_tried_already = 0;
#line 711
  if (! opt.http_keep_alive) {
#line 711
    tmp___6 = 1;
  } else
#line 711
  if ((unsigned long )proxy != (unsigned long )((void *)0)) {
#line 711
    tmp___6 = 1;
  } else {
#line 711
    tmp___6 = 0;
  }
#line 711
  inhibit_keep_alive = tmp___6;
  again: 
#line 718
  keep_alive = 0;
#line 719
  http_keep_alive_2 = 0;
#line 719
  http_keep_alive_1 = http_keep_alive_2;
#line 721
  post_content_type = (char *)((void *)0);
#line 722
  post_content_length = (char *)((void *)0);
#line 725
  hs->len = 0L;
#line 726
  hs->contlen = -1L;
#line 727
  hs->res = -1;
#line 728
  hs->newloc = (char *)((void *)0);
#line 729
  hs->remote_time = (char *)((void *)0);
#line 730
  hs->error = (char *)((void *)0);
#line 734
  if (proxy) {
#line 734
    conn = proxy;
  } else {
#line 734
    conn = u;
  }
#line 737
  if (inhibit_keep_alive) {
#line 737
    goto _L;
  } else {
    {
#line 737
    tmp___14 = persistent_available_p((char const   *)conn->host, (unsigned short )conn->port,
                                      (unsigned int )u->scheme == 1U);
    }
#line 737
    if (tmp___14) {
      {
#line 772
      tmp___13 = gettext("Reusing connection to %s:%hu.\n");
#line 772
      logprintf((enum log_options )0, (char const   *)tmp___13, conn->host, conn->port);
#line 776
      sock = pc_last_fd;
#line 778
      ssl = pc_last_ssl;
      }
      {
#line 780
      while (1) {
        while_continue: /* CIL Label */ ;
#line 780
        if (opt.debug) {
          {
#line 780
          debug_logprintf("Reusing fd %d.\n", sock);
          }
        }
#line 780
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 747
      tmp___7 = lookup_host((char const   *)conn->host, 0);
#line 747
      al = tmp___7;
      }
#line 748
      if (! al) {
#line 749
        return ((uerr_t )1);
      }
      {
#line 750
      set_connection_host_name((char const   *)conn->host);
#line 751
      sock = connect_to_many(al, (unsigned short )conn->port, 0);
#line 752
      set_connection_host_name((char const   *)((void *)0));
#line 753
      address_list_release(al);
      }
#line 755
      if (sock < 0) {
        {
#line 756
        tmp___10 = __errno_location();
        }
#line 756
        if (*tmp___10 == 111) {
#line 756
          if (! opt.retry_connrefused) {
#line 756
            tmp___9 = 5;
          } else {
#line 756
            tmp___9 = 3;
          }
        } else {
#line 756
          tmp___9 = 3;
        }
#line 756
        return ((uerr_t )tmp___9);
      }
#line 759
      if ((unsigned int )conn->scheme == 1U) {
        {
#line 760
        tmp___12 = connect_ssl(& ssl, ssl_ctx, sock);
        }
#line 760
        if (tmp___12 != 0) {
          {
#line 762
          logputs((enum log_options )0, "\n");
#line 763
          tmp___11 = gettext("Unable to establish SSL connection.\n");
#line 763
          logprintf((enum log_options )1, (char const   *)tmp___11);
#line 764
          ssl_printerrors();
          }
          {
#line 765
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 765
            close(sock);
            }
            {
#line 765
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 765
              if (opt.debug) {
                {
#line 765
                debug_logprintf("Closing fd %d\n", sock);
                }
              }
#line 765
              goto while_break___1;
            }
            while_break___1: /* CIL Label */ ;
            }
#line 765
            goto while_break___0;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 766
          return ((uerr_t )4);
        }
      }
    }
  }
#line 783
  if (*dt & 4) {
#line 784
    command = (char *)"HEAD";
  } else
#line 785
  if (opt.post_file_name) {
#line 786
    command = (char *)"POST";
  } else
#line 785
  if (opt.post_data) {
#line 786
    command = (char *)"POST";
  } else {
#line 788
    command = (char *)"GET";
  }
#line 790
  referer = (char *)((void *)0);
#line 791
  if (hs->referer) {
    {
#line 793
    tmp___15 = strlen(hs->referer);
#line 793
    tmp___16 = __builtin_alloca((unsigned long )((9U + tmp___15) + 3U));
#line 793
    referer = (char *)tmp___16;
#line 794
    sprintf((char */* __restrict  */)referer, (char const   */* __restrict  */)"Referer: %s\r\n",
            hs->referer);
    }
  }
#line 797
  if (*dt & 8) {
#line 798
    pragma_h = (char *)"Pragma: no-cache\r\n";
  } else {
#line 800
    pragma_h = (char *)"";
  }
#line 802
  if (hs->restval) {
    {
#line 804
    tmp___17 = numdigit(hs->restval);
#line 804
    tmp___18 = __builtin_alloca((unsigned long )((13 + tmp___17) + 4));
#line 804
    range = (char *)tmp___18;
#line 812
    sprintf((char */* __restrict  */)range, (char const   */* __restrict  */)"Range: bytes=%ld-\r\n",
            hs->restval);
    }
  } else {
#line 815
    range = (char *)((void *)0);
  }
#line 816
  if (opt.useragent) {
    {
#line 817
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 817
      tmp___19 = strlen((char const   *)opt.useragent);
#line 817
      tmp___20 = __builtin_alloca((unsigned long )(tmp___19 + 1U));
#line 817
      useragent = (char *)tmp___20;
#line 817
      strcpy((char */* __restrict  */)useragent, (char const   */* __restrict  */)opt.useragent);
      }
#line 817
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
    {
#line 820
    tmp___21 = strlen((char const   *)version_string);
#line 820
    tmp___22 = __builtin_alloca((unsigned long )(10U + tmp___21));
#line 820
    useragent = (char *)tmp___22;
#line 821
    sprintf((char */* __restrict  */)useragent, (char const   */* __restrict  */)"Wget/%s",
            version_string);
    }
  }
  {
#line 824
  user = u->user;
#line 825
  passwd = u->passwd;
#line 826
  search_netrc((char const   *)u->host, (char const   **)(& user), (char const   **)(& passwd),
               0);
  }
#line 827
  if (user) {
#line 827
    user = user;
  } else {
#line 827
    user = opt.http_user;
  }
#line 828
  if (passwd) {
#line 828
    passwd = passwd;
  } else {
#line 828
    passwd = opt.http_passwd;
  }
#line 830
  wwwauth = (char *)((void *)0);
#line 831
  if (user) {
#line 831
    if (passwd) {
#line 833
      if (! authenticate_h) {
        {
#line 855
        wwwauth = basic_authentication_encode((char const   *)user, (char const   *)passwd,
                                              "Authorization");
        }
      } else {
        {
#line 862
        tmp___23 = url_full_path((struct url  const  *)u);
#line 862
        pth = tmp___23;
#line 863
        wwwauth = create_authorization_line((char const   *)authenticate_h, (char const   *)user,
                                            (char const   *)passwd, (char const   *)command,
                                            (char const   *)pth);
#line 865
        free((void *)pth);
        }
      }
    }
  }
#line 869
  proxyauth = (char *)((void *)0);
#line 870
  if (proxy) {
#line 878
    if (opt.proxy_user) {
#line 878
      if (opt.proxy_passwd) {
#line 880
        proxy_user = opt.proxy_user;
#line 881
        proxy_passwd = opt.proxy_passwd;
      } else {
#line 885
        proxy_user = proxy->user;
#line 886
        proxy_passwd = proxy->passwd;
      }
    } else {
#line 885
      proxy_user = proxy->user;
#line 886
      proxy_passwd = proxy->passwd;
    }
#line 890
    if (proxy_user) {
#line 890
      if (proxy_passwd) {
        {
#line 891
        proxyauth = basic_authentication_encode((char const   *)proxy_user, (char const   *)proxy_passwd,
                                                "Proxy-Authorization");
        }
      }
    }
  }
  {
#line 896
  port_maybe = (char *)((void *)0);
#line 897
  tmp___26 = scheme_default_port(u->scheme);
  }
#line 897
  if (u->port != tmp___26) {
    {
#line 899
    tmp___24 = numdigit((long )u->port);
#line 899
    tmp___25 = __builtin_alloca((unsigned long )(tmp___24 + 2));
#line 899
    port_maybe = (char *)tmp___25;
#line 900
    sprintf((char */* __restrict  */)port_maybe, (char const   */* __restrict  */)":%d",
            u->port);
    }
  }
#line 903
  if (! inhibit_keep_alive) {
#line 904
    request_keep_alive = (char *)"Connection: Keep-Alive\r\n";
  } else {
#line 906
    request_keep_alive = (char *)((void *)0);
  }
#line 908
  if (opt.cookies) {
    {
#line 909
    cookies = cookie_jar_generate_cookie_header(wget_cookie_jar, (char const   *)u->host,
                                                u->port, (char const   *)u->path,
                                                (unsigned int )u->scheme == 1U);
    }
  }
#line 918
  if (opt.post_data) {
#line 918
    goto _L___0;
  } else
#line 918
  if (opt.post_file_name) {
    _L___0: /* CIL Label */ 
#line 920
    post_content_type = (char *)"Content-Type: application/x-www-form-urlencoded\r\n";
#line 921
    if (opt.post_data) {
      {
#line 922
      tmp___27 = strlen((char const   *)opt.post_data);
#line 922
      post_data_size = (long )tmp___27;
      }
    } else {
      {
#line 925
      post_data_size = file_size((char const   *)opt.post_file_name);
      }
#line 926
      if (post_data_size == -1L) {
        {
#line 928
        logprintf((enum log_options )1, "POST data file missing: %s\n", opt.post_file_name);
#line 930
        post_data_size = 0L;
        }
      }
    }
    {
#line 933
    tmp___28 = numdigit(post_data_size);
#line 933
    tmp___29 = xmalloc_real((size_t )(((16 + tmp___28) + 2) + 1));
#line 933
    post_content_length = (char *)tmp___29;
#line 934
    sprintf((char */* __restrict  */)post_content_length, (char const   */* __restrict  */)"Content-Length: %ld\r\n",
            post_data_size);
    }
  }
#line 938
  if (proxy) {
    {
#line 939
    full_path = xstrdup_real((char const   *)u->url);
    }
  } else {
    {
#line 944
    full_path = url_full_path((struct url  const  *)u);
    }
  }
  {
#line 946
  tmp___30 = strchr((char const   *)u->host, ':');
  }
#line 946
  if (tmp___30) {
#line 947
    squares_around_host = 1;
  }
  {
#line 950
  tmp___31 = strlen((char const   *)command);
#line 950
  tmp___32 = strlen((char const   *)full_path);
#line 950
  tmp___33 = strlen((char const   *)useragent);
#line 950
  tmp___34 = strlen((char const   *)u->host);
  }
#line 950
  if (port_maybe) {
    {
#line 950
    tmp___35 = strlen((char const   *)port_maybe);
#line 950
    tmp___36 = tmp___35;
    }
  } else {
#line 950
    tmp___36 = (size_t )0;
  }
  {
#line 950
  tmp___37 = strlen("*/*");
  }
#line 950
  if (request_keep_alive) {
    {
#line 950
    tmp___38 = strlen((char const   *)request_keep_alive);
#line 950
    tmp___39 = tmp___38;
    }
  } else {
#line 950
    tmp___39 = (size_t )0;
  }
#line 950
  if (referer) {
    {
#line 950
    tmp___40 = strlen((char const   *)referer);
#line 950
    tmp___41 = tmp___40;
    }
  } else {
#line 950
    tmp___41 = (size_t )0;
  }
#line 950
  if (cookies) {
    {
#line 950
    tmp___42 = strlen((char const   *)cookies);
#line 950
    tmp___43 = tmp___42;
    }
  } else {
#line 950
    tmp___43 = (size_t )0;
  }
#line 950
  if (wwwauth) {
    {
#line 950
    tmp___44 = strlen((char const   *)wwwauth);
#line 950
    tmp___45 = tmp___44;
    }
  } else {
#line 950
    tmp___45 = (size_t )0;
  }
#line 950
  if (proxyauth) {
    {
#line 950
    tmp___46 = strlen((char const   *)proxyauth);
#line 950
    tmp___47 = tmp___46;
    }
  } else {
#line 950
    tmp___47 = (size_t )0;
  }
#line 950
  if (range) {
    {
#line 950
    tmp___48 = strlen((char const   *)range);
#line 950
    tmp___49 = tmp___48;
    }
  } else {
#line 950
    tmp___49 = (size_t )0;
  }
  {
#line 950
  tmp___50 = strlen((char const   *)pragma_h);
  }
#line 950
  if (post_content_type) {
    {
#line 950
    tmp___51 = strlen((char const   *)post_content_type);
#line 950
    tmp___52 = tmp___51;
    }
  } else {
#line 950
    tmp___52 = (size_t )0;
  }
#line 950
  if (post_content_length) {
    {
#line 950
    tmp___53 = strlen((char const   *)post_content_length);
#line 950
    tmp___54 = tmp___53;
    }
  } else {
#line 950
    tmp___54 = (size_t )0;
  }
#line 950
  if (opt.user_header) {
    {
#line 950
    tmp___55 = strlen((char const   *)opt.user_header);
#line 950
    tmp___56 = tmp___55;
    }
  } else {
#line 950
    tmp___56 = (size_t )0;
  }
  {
#line 950
  tmp___57 = __builtin_alloca((unsigned long )((((((((((((((((tmp___31 + tmp___32) + tmp___33) + tmp___34) + tmp___36) + tmp___37) + tmp___39) + tmp___41) + tmp___43) + tmp___45) + tmp___47) + tmp___49) + tmp___50) + tmp___52) + tmp___54) + tmp___56) + 64U));
#line 950
  request = (char *)tmp___57;
  }
#line 971
  if (opt.user_header) {
#line 971
    tmp___58 = (char const   *)opt.user_header;
  } else {
#line 971
    tmp___58 = "";
  }
#line 971
  if (post_content_length) {
#line 971
    tmp___59 = (char const   *)post_content_length;
  } else {
#line 971
    tmp___59 = "";
  }
#line 971
  if (post_content_type) {
#line 971
    tmp___60 = (char const   *)post_content_type;
  } else {
#line 971
    tmp___60 = "";
  }
#line 971
  if (range) {
#line 971
    tmp___61 = (char const   *)range;
  } else {
#line 971
    tmp___61 = "";
  }
#line 971
  if (proxyauth) {
#line 971
    tmp___62 = (char const   *)proxyauth;
  } else {
#line 971
    tmp___62 = "";
  }
#line 971
  if (wwwauth) {
#line 971
    tmp___63 = (char const   *)wwwauth;
  } else {
#line 971
    tmp___63 = "";
  }
#line 971
  if (cookies) {
#line 971
    tmp___64 = (char const   *)cookies;
  } else {
#line 971
    tmp___64 = "";
  }
#line 971
  if (referer) {
#line 971
    tmp___65 = (char const   *)referer;
  } else {
#line 971
    tmp___65 = "";
  }
#line 971
  if (request_keep_alive) {
#line 971
    tmp___66 = (char const   *)request_keep_alive;
  } else {
#line 971
    tmp___66 = "";
  }
#line 971
  if (port_maybe) {
#line 971
    tmp___67 = (char const   *)port_maybe;
  } else {
#line 971
    tmp___67 = "";
  }
#line 971
  if (squares_around_host) {
#line 971
    tmp___68 = "]";
  } else {
#line 971
    tmp___68 = "";
  }
#line 971
  if (squares_around_host) {
#line 971
    tmp___69 = "[";
  } else {
#line 971
    tmp___69 = "";
  }
  {
#line 971
  sprintf((char */* __restrict  */)request, (char const   */* __restrict  */)"%s %s HTTP/1.0\r\nUser-Agent: %s\r\nHost: %s%s%s%s\r\nAccept: %s\r\n%s%s%s%s%s%s%s%s%s%s\r\n",
          command, full_path, useragent, tmp___69, u->host, tmp___68, tmp___67, "*/*",
          tmp___66, tmp___65, tmp___64, tmp___63, tmp___62, tmp___61, pragma_h, tmp___60,
          tmp___59, tmp___58);
  }
  {
#line 992
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 992
    if (opt.debug) {
      {
#line 992
      debug_logprintf("---request begin---\n%s", request);
      }
    }
#line 992
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 995
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 995
    if (wwwauth) {
      {
#line 995
      free((void *)wwwauth);
      }
    }
#line 995
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 996
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 996
    if (proxyauth) {
      {
#line 996
      free((void *)proxyauth);
      }
    }
#line 996
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 997
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 997
    if (cookies) {
      {
#line 997
      free((void *)cookies);
      }
    }
#line 997
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 998
  free((void *)full_path);
  }
#line 1002
  if ((unsigned int )conn->scheme == 1U) {
    {
#line 1003
    tmp___70 = strlen((char const   *)request);
#line 1003
    write_error = ssl_iwrite(ssl, request, (int )tmp___70);
    }
  } else {
    {
#line 1006
    tmp___71 = strlen((char const   *)request);
#line 1006
    write_error = iwrite(sock, request, (int )tmp___71);
    }
  }
#line 1008
  if (write_error >= 0) {
#line 1010
    if (opt.post_data) {
      {
#line 1012
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 1012
        if (opt.debug) {
          {
#line 1012
          debug_logprintf("[POST data: %s]\n", opt.post_data);
          }
        }
#line 1012
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 1014
      if ((unsigned int )conn->scheme == 1U) {
        {
#line 1015
        write_error = ssl_iwrite(ssl, opt.post_data, (int )post_data_size);
        }
      } else {
        {
#line 1018
        write_error = iwrite(sock, opt.post_data, (int )post_data_size);
        }
      }
    } else
#line 1020
    if (opt.post_file_name) {
#line 1020
      if (post_data_size != 0L) {
#line 1023
        if ((unsigned int )conn->scheme == 1U) {
          {
#line 1024
          write_error = post_file(-1, (void *)ssl, (char const   *)opt.post_file_name,
                                  post_data_size);
          }
        } else {
          {
#line 1028
          write_error = post_file(sock, (void *)0, (char const   *)opt.post_file_name,
                                  post_data_size);
          }
        }
      }
    }
  }
  {
#line 1032
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 1032
    if (opt.debug) {
      {
#line 1032
      debug_logprintf("---request end---\n");
      }
    }
#line 1032
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 1034
  if (write_error < 0) {
    {
#line 1036
    tmp___72 = __errno_location();
#line 1036
    tmp___73 = strerror(*tmp___72);
#line 1036
    tmp___74 = gettext("Failed writing HTTP request: %s.\n");
#line 1036
    logprintf((enum log_options )0, (char const   *)tmp___74, tmp___73);
    }
    {
#line 1038
    while (1) {
      while_continue___9: /* CIL Label */ ;
      {
#line 1038
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 1038
        if (ssl) {
          {
#line 1038
          shutdown_ssl(ssl);
          }
        }
#line 1038
        goto while_break___10;
      }
      while_break___10: /* CIL Label */ ;
      }
      {
#line 1038
      while (1) {
        while_continue___11: /* CIL Label */ ;
        {
#line 1038
        close(sock);
        }
        {
#line 1038
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 1038
          if (opt.debug) {
            {
#line 1038
            debug_logprintf("Closing fd %d\n", sock);
            }
          }
#line 1038
          goto while_break___12;
        }
        while_break___12: /* CIL Label */ ;
        }
#line 1038
        goto while_break___11;
      }
      while_break___11: /* CIL Label */ ;
      }
#line 1038
      if (pc_active_p) {
#line 1038
        if (sock == pc_last_fd) {
          {
#line 1038
          invalidate_persistent();
          }
        }
      }
#line 1038
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 1039
    return ((uerr_t )55);
  }
#line 1041
  if (proxy) {
#line 1041
    tmp___75 = "Proxy";
  } else {
#line 1041
    tmp___75 = "HTTP";
  }
  {
#line 1041
  tmp___76 = gettext("%s request sent, awaiting response... ");
#line 1041
  logprintf((enum log_options )0, (char const   *)tmp___76, tmp___75);
#line 1043
  contrange = -1L;
#line 1043
  contlen = contrange;
#line 1044
  type = (char *)((void *)0);
#line 1045
  statcode = -1;
#line 1046
  *dt &= -3;
#line 1049
  rbuf_initialize(& rbuf, sock);
  }
#line 1051
  if ((unsigned int )conn->scheme == 1U) {
#line 1052
    rbuf.ssl = ssl;
  } else {
#line 1054
    rbuf.ssl = (SSL *)((void *)0);
  }
#line 1056
  all_headers = (char *)((void *)0);
#line 1057
  all_length = 0;
#line 1059
  hcount = 0;
  {
#line 1060
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 1065
    hcount ++;
#line 1067
    if (hcount == 1) {
#line 1067
      tmp___77 = 2;
    } else {
#line 1067
      tmp___77 = 0;
    }
    {
#line 1067
    status = header_get(& rbuf, & hdr, (enum header_get_flags )tmp___77);
    }
#line 1072
    if (status == 2) {
#line 1072
      if (*hdr) {
        {
#line 1084
        logputs((enum log_options )0, "\n");
#line 1085
        tmp___78 = gettext("End of file while parsing headers.\n");
#line 1085
        logputs((enum log_options )1, (char const   *)tmp___78);
#line 1086
        free((void *)hdr);
        }
        {
#line 1087
        while (1) {
          while_continue___14: /* CIL Label */ ;
#line 1087
          if (type) {
            {
#line 1087
            free((void *)type);
            }
          }
#line 1087
          goto while_break___14;
        }
        while_break___14: /* CIL Label */ ;
        }
        {
#line 1088
        while (1) {
          while_continue___15: /* CIL Label */ ;
#line 1088
          if (all_headers) {
            {
#line 1088
            free((void *)all_headers);
            }
          }
#line 1088
          goto while_break___15;
        }
        while_break___15: /* CIL Label */ ;
        }
        {
#line 1089
        while (1) {
          while_continue___16: /* CIL Label */ ;
          {
#line 1089
          while (1) {
            while_continue___17: /* CIL Label */ ;
#line 1089
            if (ssl) {
              {
#line 1089
              shutdown_ssl(ssl);
              }
            }
#line 1089
            goto while_break___17;
          }
          while_break___17: /* CIL Label */ ;
          }
          {
#line 1089
          while (1) {
            while_continue___18: /* CIL Label */ ;
            {
#line 1089
            close(sock);
            }
            {
#line 1089
            while (1) {
              while_continue___19: /* CIL Label */ ;
#line 1089
              if (opt.debug) {
                {
#line 1089
                debug_logprintf("Closing fd %d\n", sock);
                }
              }
#line 1089
              goto while_break___19;
            }
            while_break___19: /* CIL Label */ ;
            }
#line 1089
            goto while_break___18;
          }
          while_break___18: /* CIL Label */ ;
          }
#line 1089
          if (pc_active_p) {
#line 1089
            if (sock == pc_last_fd) {
              {
#line 1089
              invalidate_persistent();
              }
            }
          }
#line 1089
          goto while_break___16;
        }
        while_break___16: /* CIL Label */ ;
        }
#line 1090
        return ((uerr_t )32);
      } else {
#line 1072
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 1092
    if (status == 1) {
      {
#line 1094
      logputs((enum log_options )0, "\n");
#line 1095
      tmp___79 = __errno_location();
#line 1095
      tmp___80 = strerror(*tmp___79);
#line 1095
      tmp___81 = gettext("Read error (%s) in headers.\n");
#line 1095
      logprintf((enum log_options )1, (char const   *)tmp___81, tmp___80);
#line 1097
      free((void *)hdr);
      }
      {
#line 1098
      while (1) {
        while_continue___20: /* CIL Label */ ;
#line 1098
        if (type) {
          {
#line 1098
          free((void *)type);
          }
        }
#line 1098
        goto while_break___20;
      }
      while_break___20: /* CIL Label */ ;
      }
      {
#line 1099
      while (1) {
        while_continue___21: /* CIL Label */ ;
#line 1099
        if (all_headers) {
          {
#line 1099
          free((void *)all_headers);
          }
        }
#line 1099
        goto while_break___21;
      }
      while_break___21: /* CIL Label */ ;
      }
      {
#line 1100
      while (1) {
        while_continue___22: /* CIL Label */ ;
        {
#line 1100
        while (1) {
          while_continue___23: /* CIL Label */ ;
#line 1100
          if (ssl) {
            {
#line 1100
            shutdown_ssl(ssl);
            }
          }
#line 1100
          goto while_break___23;
        }
        while_break___23: /* CIL Label */ ;
        }
        {
#line 1100
        while (1) {
          while_continue___24: /* CIL Label */ ;
          {
#line 1100
          close(sock);
          }
          {
#line 1100
          while (1) {
            while_continue___25: /* CIL Label */ ;
#line 1100
            if (opt.debug) {
              {
#line 1100
              debug_logprintf("Closing fd %d\n", sock);
              }
            }
#line 1100
            goto while_break___25;
          }
          while_break___25: /* CIL Label */ ;
          }
#line 1100
          goto while_break___24;
        }
        while_break___24: /* CIL Label */ ;
        }
#line 1100
        if (pc_active_p) {
#line 1100
          if (sock == pc_last_fd) {
            {
#line 1100
            invalidate_persistent();
            }
          }
        }
#line 1100
        goto while_break___22;
      }
      while_break___22: /* CIL Label */ ;
      }
#line 1101
      return ((uerr_t )33);
    }
#line 1106
    if (opt.save_headers) {
      {
#line 1108
      tmp___82 = strlen((char const   *)hdr);
#line 1108
      lh = (int )tmp___82;
#line 1109
      tmp___83 = xrealloc_real((void *)all_headers, (size_t )((all_length + lh) + 2));
#line 1109
      all_headers = (char *)tmp___83;
#line 1110
      memcpy((void */* __restrict  */)(all_headers + all_length), (void const   */* __restrict  */)hdr,
             (size_t )lh);
#line 1111
      all_length += lh;
#line 1112
      tmp___84 = all_length;
#line 1112
      all_length ++;
#line 1112
      *(all_headers + tmp___84) = (char )'\n';
#line 1113
      *(all_headers + all_length) = (char )'\000';
      }
    }
#line 1117
    if (hcount == 1) {
      {
#line 1121
      statcode = parse_http_status_line((char const   *)hdr, & error);
#line 1122
      hs->statcode = statcode;
      }
#line 1124
      if (statcode == -1) {
#line 1129
        if (! *hdr) {
          {
#line 1130
          tmp___85 = gettext("No data received");
#line 1130
          hs->error = xstrdup_real((char const   *)tmp___85);
          }
        } else {
          {
#line 1132
          tmp___86 = gettext("Malformed status line");
#line 1132
          hs->error = xstrdup_real((char const   *)tmp___86);
          }
        }
        {
#line 1133
        free((void *)hdr);
        }
#line 1134
        goto while_break___13;
      } else
#line 1136
      if (! *error) {
        {
#line 1137
        tmp___87 = gettext("(no description)");
#line 1137
        hs->error = xstrdup_real((char const   *)tmp___87);
        }
      } else {
        {
#line 1139
        hs->error = xstrdup_real(error);
        }
      }
#line 1141
      if (statcode != -1) {
#line 1141
        if (! opt.debug) {
#line 1147
          if (opt.server_response) {
            {
#line 1148
            logprintf((enum log_options )0, "\n%2d %s", hcount, hdr);
            }
          } else {
            {
#line 1150
            logprintf((enum log_options )0, "%2d %s", statcode, error);
            }
          }
        }
      }
#line 1153
      goto done_header;
    }
#line 1157
    if (! *hdr) {
      {
#line 1159
      free((void *)hdr);
      }
#line 1160
      goto while_break___13;
    }
#line 1164
    if (opt.server_response) {
#line 1164
      if (hcount != 1) {
        {
#line 1165
        logprintf((enum log_options )0, "\n%2d %s", hcount, hdr);
        }
      }
    }
#line 1168
    if (contlen == -1L) {
#line 1168
      if (! opt.ignore_length) {
        {
#line 1169
        tmp___88 = header_process((char const   *)hdr, "Content-Length", & header_extract_number,
                                  (void *)(& contlen));
        }
#line 1169
        if (tmp___88) {
#line 1171
          goto done_header;
        }
      }
    }
#line 1173
    if (! type) {
      {
#line 1174
      tmp___89 = header_process((char const   *)hdr, "Content-Type", & http_process_type,
                                (void *)(& type));
      }
#line 1174
      if (tmp___89) {
#line 1175
        goto done_header;
      }
    }
#line 1177
    if (! hs->newloc) {
      {
#line 1178
      tmp___90 = header_process((char const   *)hdr, "Location", & header_strdup,
                                (void *)(& hs->newloc));
      }
#line 1178
      if (tmp___90) {
#line 1179
        goto done_header;
      }
    }
#line 1181
    if (! hs->remote_time) {
      {
#line 1182
      tmp___91 = header_process((char const   *)hdr, "Last-Modified", & header_strdup,
                                (void *)(& hs->remote_time));
      }
#line 1182
      if (tmp___91) {
#line 1184
        goto done_header;
      }
    }
#line 1186
    if (opt.cookies) {
      {
#line 1187
      tmp___92 = header_process((char const   *)hdr, "Set-Cookie", & http_process_set_cookie,
                                (void *)u);
      }
#line 1187
      if (tmp___92) {
#line 1188
        goto done_header;
      }
    }
#line 1190
    if (! authenticate_h) {
      {
#line 1191
      tmp___93 = header_process((char const   *)hdr, "WWW-Authenticate", & header_strdup,
                                (void *)(& authenticate_h));
      }
#line 1191
      if (tmp___93) {
#line 1193
        goto done_header;
      }
    }
#line 1196
    if (*dt & 16) {
      {
#line 1199
      tmp___94 = header_process((char const   *)hdr, "Accept-Ranges", & http_process_none,
                                (void *)(& nonep));
      }
#line 1199
      if (tmp___94) {
#line 1201
        if (nonep) {
#line 1202
          *dt &= -17;
        }
#line 1203
        goto done_header;
      }
    }
#line 1207
    if (contrange == -1L) {
      {
#line 1210
      tmp___95 = header_process((char const   *)hdr, "Content-Range", & http_process_range,
                                (void *)(& closure));
      }
#line 1210
      if (tmp___95) {
#line 1212
        contrange = closure.first_byte_pos;
#line 1213
        goto done_header;
      }
    }
#line 1217
    if (! inhibit_keep_alive) {
#line 1220
      if (! http_keep_alive_1) {
        {
#line 1222
        tmp___96 = header_process((char const   *)hdr, "Keep-Alive", & header_exists,
                                  (void *)(& http_keep_alive_1));
        }
#line 1222
        if (tmp___96) {
#line 1224
          goto done_header;
        }
      }
#line 1227
      if (! http_keep_alive_2) {
        {
#line 1229
        tmp___97 = header_process((char const   *)hdr, "Connection", & http_process_connection,
                                  (void *)(& http_keep_alive_2));
        }
#line 1229
        if (tmp___97) {
#line 1231
          goto done_header;
        }
      }
    }
    done_header: 
    {
#line 1235
    free((void *)hdr);
    }
  }
  while_break___13: /* CIL Label */ ;
  }
  {
#line 1238
  logputs((enum log_options )0, "\n");
  }
#line 1240
  if (contlen != -1L) {
#line 1240
    if (http_keep_alive_1) {
#line 1240
      goto _L___2;
    } else
#line 1240
    if (http_keep_alive_2) {
      _L___2: /* CIL Label */ 
      {
#line 1243
      tmp___98 = __builtin_expect((long )(! (! (inhibit_keep_alive == 0))), 1L);
      }
#line 1243
      if (! tmp___98) {
        {
#line 1243
        __assert_fail("inhibit_keep_alive == 0", "http.c", 1243U, "gethttp");
        }
      }
#line 1244
      keep_alive = 1;
    }
  }
#line 1246
  if (keep_alive) {
    {
#line 1252
    register_persistent((char const   *)conn->host, (unsigned short )conn->port, sock,
                        ssl);
    }
  }
#line 1255
  if (statcode == 401) {
#line 1255
    if (authenticate_h) {
      {
#line 1259
      while (1) {
        while_continue___26: /* CIL Label */ ;
#line 1259
        if (type) {
          {
#line 1259
          free((void *)type);
          }
        }
#line 1259
        goto while_break___26;
      }
      while_break___26: /* CIL Label */ ;
      }
      {
#line 1260
      type = (char *)((void *)0);
#line 1261
      free_hstat(hs);
      }
      {
#line 1262
      while (1) {
        while_continue___27: /* CIL Label */ ;
        {
#line 1262
        while (1) {
          while_continue___28: /* CIL Label */ ;
#line 1262
          if (ssl) {
            {
#line 1262
            shutdown_ssl(ssl);
            }
          }
#line 1262
          goto while_break___28;
        }
        while_break___28: /* CIL Label */ ;
        }
        {
#line 1262
        while (1) {
          while_continue___29: /* CIL Label */ ;
          {
#line 1262
          close(sock);
          }
          {
#line 1262
          while (1) {
            while_continue___30: /* CIL Label */ ;
#line 1262
            if (opt.debug) {
              {
#line 1262
              debug_logprintf("Closing fd %d\n", sock);
              }
            }
#line 1262
            goto while_break___30;
          }
          while_break___30: /* CIL Label */ ;
          }
#line 1262
          goto while_break___29;
        }
        while_break___29: /* CIL Label */ ;
        }
#line 1262
        if (pc_active_p) {
#line 1262
          if (sock == pc_last_fd) {
            {
#line 1262
            invalidate_persistent();
            }
          }
        }
#line 1262
        goto while_break___27;
      }
      while_break___27: /* CIL Label */ ;
      }
#line 1264
      if (auth_tried_already) {
        failed: 
        {
#line 1269
        tmp___99 = gettext("Authorization failed.\n");
#line 1269
        logputs((enum log_options )1, (char const   *)tmp___99);
#line 1270
        free((void *)authenticate_h);
        }
#line 1271
        return ((uerr_t )53);
      } else {
        {
#line 1273
        tmp___102 = known_authentication_scheme_p((char const   *)authenticate_h);
        }
#line 1273
        if (tmp___102) {
          {
#line 1279
          tmp___101 = strncasecmp((char const   *)authenticate_h, "Basic", (size_t )(sizeof("Basic") - 1UL));
          }
#line 1279
          if (tmp___101) {
#line 1288
            auth_tried_already = 1;
#line 1289
            goto again;
          } else
#line 1279
          if ((int const   )_sch_istable[(int )*(authenticate_h + (sizeof("Basic") - 1UL)) & 255] & 64) {
#line 1284
            goto failed;
          } else
#line 1279
          if (! *(authenticate_h + (sizeof("Basic") - 1UL))) {
#line 1284
            goto failed;
          } else {
#line 1288
            auth_tried_already = 1;
#line 1289
            goto again;
          }
        } else {
          {
#line 1275
          free((void *)authenticate_h);
#line 1276
          tmp___100 = gettext("Unknown authentication scheme.\n");
#line 1276
          logputs((enum log_options )1, (char const   *)tmp___100);
          }
#line 1277
          return ((uerr_t )53);
        }
      }
    }
  }
#line 1293
  if (authenticate_h) {
    {
#line 1295
    free((void *)authenticate_h);
#line 1296
    authenticate_h = (char *)((void *)0);
    }
  }
#line 1300
  if (statcode >= 200) {
#line 1300
    if (statcode < 300) {
#line 1301
      *dt |= 2;
    }
  }
#line 1304
  if (statcode == 301) {
#line 1304
    goto _L___4;
  } else
#line 1304
  if (statcode == 302) {
#line 1304
    goto _L___4;
  } else
#line 1304
  if (statcode == 307) {
#line 1304
    goto _L___4;
  } else
#line 1304
  if (statcode == 300) {
    _L___4: /* CIL Label */ 
#line 1311
    if (statcode == 300) {
#line 1311
      if (! hs->newloc) {
#line 1312
        *dt |= 2;
      } else {
#line 1311
        goto _L___3;
      }
    } else {
      _L___3: /* CIL Label */ 
#line 1315
      if (hs->newloc) {
        {
#line 1315
        tmp___103 = gettext(" [following]");
#line 1315
        tmp___104 = (char const   *)tmp___103;
        }
      } else {
#line 1315
        tmp___104 = "";
      }
#line 1315
      if (hs->newloc) {
#line 1315
        tmp___106 = hs->newloc;
      } else {
        {
#line 1315
        tmp___105 = gettext("unspecified");
#line 1315
        tmp___106 = tmp___105;
        }
      }
      {
#line 1315
      tmp___107 = gettext("Location: %s%s\n");
#line 1315
      logprintf((enum log_options )0, (char const   *)tmp___107, tmp___106, tmp___104);
      }
      {
#line 1319
      while (1) {
        while_continue___31: /* CIL Label */ ;
        {
#line 1319
        while (1) {
          while_continue___32: /* CIL Label */ ;
#line 1319
          if (ssl) {
            {
#line 1319
            shutdown_ssl(ssl);
            }
          }
#line 1319
          goto while_break___32;
        }
        while_break___32: /* CIL Label */ ;
        }
        {
#line 1319
        while (1) {
          while_continue___33: /* CIL Label */ ;
          {
#line 1319
          close(sock);
          }
          {
#line 1319
          while (1) {
            while_continue___34: /* CIL Label */ ;
#line 1319
            if (opt.debug) {
              {
#line 1319
              debug_logprintf("Closing fd %d\n", sock);
              }
            }
#line 1319
            goto while_break___34;
          }
          while_break___34: /* CIL Label */ ;
          }
#line 1319
          goto while_break___33;
        }
        while_break___33: /* CIL Label */ ;
        }
#line 1319
        if (pc_active_p) {
#line 1319
          if (sock == pc_last_fd) {
            {
#line 1319
            invalidate_persistent();
            }
          }
        }
#line 1319
        goto while_break___31;
      }
      while_break___31: /* CIL Label */ ;
      }
      {
#line 1321
      while (1) {
        while_continue___35: /* CIL Label */ ;
#line 1321
        if (type) {
          {
#line 1321
          free((void *)type);
          }
        }
#line 1321
        goto while_break___35;
      }
      while_break___35: /* CIL Label */ ;
      }
      {
#line 1322
      while (1) {
        while_continue___36: /* CIL Label */ ;
#line 1322
        if (all_headers) {
          {
#line 1322
          free((void *)all_headers);
          }
        }
#line 1322
        goto while_break___36;
      }
      while_break___36: /* CIL Label */ ;
      }
#line 1323
      return ((uerr_t )6);
    }
  }
#line 1330
  if (! type) {
#line 1333
    *dt |= 1;
  } else {
    {
#line 1330
    tmp___108 = strlen("text/html");
#line 1330
    tmp___109 = strncasecmp((char const   *)type, "text/html", tmp___108);
    }
#line 1330
    if (0 == tmp___109) {
#line 1333
      *dt |= 1;
    } else {
      {
#line 1330
      tmp___110 = strlen("application/xhtml+xml");
#line 1330
      tmp___111 = strncasecmp((char const   *)type, "application/xhtml+xml", tmp___110);
      }
#line 1330
      if (0 == tmp___111) {
#line 1333
        *dt |= 1;
      } else {
#line 1335
        *dt &= -2;
      }
    }
  }
#line 1337
  if (opt.html_extension) {
#line 1337
    if (*dt & 1) {
      {
#line 1342
      tmp___112 = strrchr((char const   *)*(hs->local_file), '.');
#line 1342
      last_period_in_local_filename = tmp___112;
      }
#line 1344
      if ((unsigned long )last_period_in_local_filename == (unsigned long )((void *)0)) {
#line 1344
        goto _L___5;
      } else {
        {
#line 1344
        tmp___115 = strcasecmp((char const   *)last_period_in_local_filename, ".htm");
        }
#line 1344
        if (! (tmp___115 == 0)) {
          {
#line 1344
          tmp___116 = strcasecmp((char const   *)last_period_in_local_filename, ".html");
          }
#line 1344
          if (! (tmp___116 == 0)) {
            _L___5: /* CIL Label */ 
            {
#line 1348
            tmp___113 = strlen((char const   *)*(hs->local_file));
#line 1348
            local_filename_len = tmp___113;
#line 1350
            tmp___114 = xrealloc_real((void *)*(hs->local_file), (size_t )((unsigned long )local_filename_len + sizeof(".html")));
#line 1350
            *(hs->local_file) = (char *)tmp___114;
#line 1352
            strcpy((char */* __restrict  */)(*(hs->local_file) + local_filename_len),
                   (char const   */* __restrict  */)".html");
#line 1354
            *dt |= 32;
            }
          }
        }
      }
    }
  }
#line 1358
  if (contrange == -1L) {
#line 1376
    if (opt.always_rest) {
#line 1379
      if (hs->restval > 0L) {
#line 1379
        if (contlen != -1L) {
#line 1379
          if (hs->restval >= contlen) {
            {
#line 1385
            tmp___117 = gettext("\n    The file is already fully retrieved; nothing to do.\n\n");
#line 1385
            logputs((enum log_options )0, (char const   *)tmp___117);
#line 1388
            hs->len = contlen;
#line 1389
            hs->res = 0;
#line 1391
            *dt |= 2;
            }
            {
#line 1392
            while (1) {
              while_continue___37: /* CIL Label */ ;
#line 1392
              if (type) {
                {
#line 1392
                free((void *)type);
                }
              }
#line 1392
              goto while_break___37;
            }
            while_break___37: /* CIL Label */ ;
            }
            {
#line 1393
            while (1) {
              while_continue___38: /* CIL Label */ ;
#line 1393
              if (all_headers) {
                {
#line 1393
                free((void *)all_headers);
                }
              }
#line 1393
              goto while_break___38;
            }
            while_break___38: /* CIL Label */ ;
            }
            {
#line 1394
            while (1) {
              while_continue___39: /* CIL Label */ ;
              {
#line 1394
              while (1) {
                while_continue___40: /* CIL Label */ ;
#line 1394
                if (ssl) {
                  {
#line 1394
                  shutdown_ssl(ssl);
                  }
                }
#line 1394
                goto while_break___40;
              }
              while_break___40: /* CIL Label */ ;
              }
              {
#line 1394
              while (1) {
                while_continue___41: /* CIL Label */ ;
                {
#line 1394
                close(sock);
                }
                {
#line 1394
                while (1) {
                  while_continue___42: /* CIL Label */ ;
#line 1394
                  if (opt.debug) {
                    {
#line 1394
                    debug_logprintf("Closing fd %d\n", sock);
                    }
                  }
#line 1394
                  goto while_break___42;
                }
                while_break___42: /* CIL Label */ ;
                }
#line 1394
                goto while_break___41;
              }
              while_break___41: /* CIL Label */ ;
              }
#line 1394
              if (pc_active_p) {
#line 1394
                if (sock == pc_last_fd) {
                  {
#line 1394
                  invalidate_persistent();
                  }
                }
              }
#line 1394
              goto while_break___39;
            }
            while_break___39: /* CIL Label */ ;
            }
#line 1396
            return ((uerr_t )41);
          }
        }
      }
#line 1400
      if (hs->no_truncate) {
        {
#line 1402
        tmp___118 = gettext("\nContinued download failed on this file, which conflicts with `-c\'.\nRefusing to truncate existing file `%s\'.\n\n");
#line 1402
        logprintf((enum log_options )1, (char const   *)tmp___118, *(hs->local_file));
        }
        {
#line 1407
        while (1) {
          while_continue___43: /* CIL Label */ ;
#line 1407
          if (type) {
            {
#line 1407
            free((void *)type);
            }
          }
#line 1407
          goto while_break___43;
        }
        while_break___43: /* CIL Label */ ;
        }
        {
#line 1408
        while (1) {
          while_continue___44: /* CIL Label */ ;
#line 1408
          if (all_headers) {
            {
#line 1408
            free((void *)all_headers);
            }
          }
#line 1408
          goto while_break___44;
        }
        while_break___44: /* CIL Label */ ;
        }
        {
#line 1409
        while (1) {
          while_continue___45: /* CIL Label */ ;
          {
#line 1409
          while (1) {
            while_continue___46: /* CIL Label */ ;
#line 1409
            if (ssl) {
              {
#line 1409
              shutdown_ssl(ssl);
              }
            }
#line 1409
            goto while_break___46;
          }
          while_break___46: /* CIL Label */ ;
          }
          {
#line 1409
          while (1) {
            while_continue___47: /* CIL Label */ ;
            {
#line 1409
            close(sock);
            }
            {
#line 1409
            while (1) {
              while_continue___48: /* CIL Label */ ;
#line 1409
              if (opt.debug) {
                {
#line 1409
                debug_logprintf("Closing fd %d\n", sock);
                }
              }
#line 1409
              goto while_break___48;
            }
            while_break___48: /* CIL Label */ ;
            }
#line 1409
            goto while_break___47;
          }
          while_break___47: /* CIL Label */ ;
          }
#line 1409
          if (pc_active_p) {
#line 1409
            if (sock == pc_last_fd) {
              {
#line 1409
              invalidate_persistent();
              }
            }
          }
#line 1409
          goto while_break___45;
        }
        while_break___45: /* CIL Label */ ;
        }
#line 1410
        return ((uerr_t )40);
      }
    }
#line 1416
    hs->restval = 0L;
  } else
#line 1418
  if (contrange != hs->restval) {
#line 1418
    goto _L___6;
  } else
#line 1418
  if (statcode == 206) {
#line 1418
    if (contrange == -1L) {
      _L___6: /* CIL Label */ 
      {
#line 1423
      while (1) {
        while_continue___49: /* CIL Label */ ;
#line 1423
        if (type) {
          {
#line 1423
          free((void *)type);
          }
        }
#line 1423
        goto while_break___49;
      }
      while_break___49: /* CIL Label */ ;
      }
      {
#line 1424
      while (1) {
        while_continue___50: /* CIL Label */ ;
#line 1424
        if (all_headers) {
          {
#line 1424
          free((void *)all_headers);
          }
        }
#line 1424
        goto while_break___50;
      }
      while_break___50: /* CIL Label */ ;
      }
      {
#line 1425
      while (1) {
        while_continue___51: /* CIL Label */ ;
        {
#line 1425
        while (1) {
          while_continue___52: /* CIL Label */ ;
#line 1425
          if (ssl) {
            {
#line 1425
            shutdown_ssl(ssl);
            }
          }
#line 1425
          goto while_break___52;
        }
        while_break___52: /* CIL Label */ ;
        }
        {
#line 1425
        while (1) {
          while_continue___53: /* CIL Label */ ;
          {
#line 1425
          close(sock);
          }
          {
#line 1425
          while (1) {
            while_continue___54: /* CIL Label */ ;
#line 1425
            if (opt.debug) {
              {
#line 1425
              debug_logprintf("Closing fd %d\n", sock);
              }
            }
#line 1425
            goto while_break___54;
          }
          while_break___54: /* CIL Label */ ;
          }
#line 1425
          goto while_break___53;
        }
        while_break___53: /* CIL Label */ ;
        }
#line 1425
        if (pc_active_p) {
#line 1425
          if (sock == pc_last_fd) {
            {
#line 1425
            invalidate_persistent();
            }
          }
        }
#line 1425
        goto while_break___51;
      }
      while_break___51: /* CIL Label */ ;
      }
#line 1426
      return ((uerr_t )47);
    }
  }
#line 1429
  if (hs->restval) {
#line 1431
    if (contlen != -1L) {
#line 1432
      contlen += contrange;
    } else {
#line 1434
      contrange = -1L;
    }
  }
#line 1437
  hs->contlen = contlen;
#line 1439
  if (opt.verbose) {
#line 1441
    if (*dt & 2) {
#line 1441
      if (! opt.server_response) {
        {
#line 1446
        tmp___119 = gettext("Length: ");
#line 1446
        logputs((enum log_options )0, (char const   *)tmp___119);
        }
#line 1447
        if (contlen != -1L) {
          {
#line 1449
          tmp___120 = legible(contlen);
#line 1449
          logputs((enum log_options )0, (char const   *)tmp___120);
          }
#line 1450
          if (contrange != -1L) {
            {
#line 1451
            tmp___121 = legible(contlen - contrange);
#line 1451
            tmp___122 = gettext(" (%s to go)");
#line 1451
            logprintf((enum log_options )0, (char const   *)tmp___122, tmp___121);
            }
          }
        } else {
#line 1455
          if (opt.ignore_length) {
            {
#line 1455
            tmp___123 = gettext("ignored");
#line 1455
            tmp___125 = tmp___123;
            }
          } else {
            {
#line 1455
            tmp___124 = gettext("unspecified");
#line 1455
            tmp___125 = tmp___124;
            }
          }
          {
#line 1455
          logputs((enum log_options )0, (char const   *)tmp___125);
          }
        }
#line 1457
        if (type) {
          {
#line 1458
          logprintf((enum log_options )0, " [%s]\n", type);
          }
        } else {
          {
#line 1460
          logputs((enum log_options )0, "\n");
          }
        }
      }
    }
  }
  {
#line 1463
  while (1) {
    while_continue___55: /* CIL Label */ ;
#line 1463
    if (type) {
      {
#line 1463
      free((void *)type);
      }
    }
#line 1463
    goto while_break___55;
  }
  while_break___55: /* CIL Label */ ;
  }
#line 1464
  type = (char *)((void *)0);
#line 1467
  if (! (*dt & 2)) {
#line 1467
    goto _L___7;
  } else
#line 1467
  if (*dt & 4) {
    _L___7: /* CIL Label */ 
#line 1470
    hs->len = 0L;
#line 1471
    hs->res = 0;
    {
#line 1472
    while (1) {
      while_continue___56: /* CIL Label */ ;
#line 1472
      if (type) {
        {
#line 1472
        free((void *)type);
        }
      }
#line 1472
      goto while_break___56;
    }
    while_break___56: /* CIL Label */ ;
    }
    {
#line 1473
    while (1) {
      while_continue___57: /* CIL Label */ ;
#line 1473
      if (all_headers) {
        {
#line 1473
        free((void *)all_headers);
        }
      }
#line 1473
      goto while_break___57;
    }
    while_break___57: /* CIL Label */ ;
    }
    {
#line 1474
    while (1) {
      while_continue___58: /* CIL Label */ ;
      {
#line 1474
      while (1) {
        while_continue___59: /* CIL Label */ ;
#line 1474
        if (ssl) {
          {
#line 1474
          shutdown_ssl(ssl);
          }
        }
#line 1474
        goto while_break___59;
      }
      while_break___59: /* CIL Label */ ;
      }
      {
#line 1474
      while (1) {
        while_continue___60: /* CIL Label */ ;
        {
#line 1474
        close(sock);
        }
        {
#line 1474
        while (1) {
          while_continue___61: /* CIL Label */ ;
#line 1474
          if (opt.debug) {
            {
#line 1474
            debug_logprintf("Closing fd %d\n", sock);
            }
          }
#line 1474
          goto while_break___61;
        }
        while_break___61: /* CIL Label */ ;
        }
#line 1474
        goto while_break___60;
      }
      while_break___60: /* CIL Label */ ;
      }
#line 1474
      if (pc_active_p) {
#line 1474
        if (sock == pc_last_fd) {
          {
#line 1474
          invalidate_persistent();
          }
        }
      }
#line 1474
      goto while_break___58;
    }
    while_break___58: /* CIL Label */ ;
    }
#line 1476
    return ((uerr_t )42);
  }
#line 1480
  if (! opt.dfp) {
    {
#line 1482
    mkalldirs((char const   *)*(hs->local_file));
    }
#line 1483
    if (opt.backups) {
      {
#line 1484
      rotate_backups((char const   *)*(hs->local_file));
      }
    }
#line 1485
    if (hs->restval) {
#line 1485
      tmp___126 = "ab";
    } else {
#line 1485
      tmp___126 = "wb";
    }
    {
#line 1485
    fp = fopen((char const   */* __restrict  */)*(hs->local_file), (char const   */* __restrict  */)tmp___126);
    }
#line 1486
    if (! fp) {
      {
#line 1488
      tmp___127 = __errno_location();
#line 1488
      tmp___128 = strerror(*tmp___127);
#line 1488
      logprintf((enum log_options )1, "%s: %s\n", *(hs->local_file), tmp___128);
      }
      {
#line 1489
      while (1) {
        while_continue___62: /* CIL Label */ ;
        {
#line 1489
        while (1) {
          while_continue___63: /* CIL Label */ ;
#line 1489
          if (ssl) {
            {
#line 1489
            shutdown_ssl(ssl);
            }
          }
#line 1489
          goto while_break___63;
        }
        while_break___63: /* CIL Label */ ;
        }
        {
#line 1489
        while (1) {
          while_continue___64: /* CIL Label */ ;
          {
#line 1489
          close(sock);
          }
          {
#line 1489
          while (1) {
            while_continue___65: /* CIL Label */ ;
#line 1489
            if (opt.debug) {
              {
#line 1489
              debug_logprintf("Closing fd %d\n", sock);
              }
            }
#line 1489
            goto while_break___65;
          }
          while_break___65: /* CIL Label */ ;
          }
#line 1489
          goto while_break___64;
        }
        while_break___64: /* CIL Label */ ;
        }
#line 1489
        if (pc_active_p) {
#line 1489
          if (sock == pc_last_fd) {
            {
#line 1489
            invalidate_persistent();
            }
          }
        }
#line 1489
        goto while_break___62;
      }
      while_break___62: /* CIL Label */ ;
      }
      {
#line 1491
      while (1) {
        while_continue___66: /* CIL Label */ ;
#line 1491
        if (all_headers) {
          {
#line 1491
          free((void *)all_headers);
          }
        }
#line 1491
        goto while_break___66;
      }
      while_break___66: /* CIL Label */ ;
      }
#line 1492
      return ((uerr_t )28);
    }
  } else {
#line 1498
    fp = opt.dfp;
#line 1516
    if (! hs->restval) {
#line 1516
      if (global_download_count == 0) {
#line 1516
        if ((unsigned long )opt.dfp != (unsigned long )stdout) {
          {
#line 1520
          rewind(fp);
#line 1523
          tmp___129 = fileno(fp);
#line 1523
          ftruncate(tmp___129, (__off_t )0);
#line 1524
          clearerr(fp);
          }
        }
      }
    }
  }
#line 1530
  if (opt.save_headers) {
    {
#line 1531
    fwrite((void const   */* __restrict  */)all_headers, (size_t )1, (size_t )all_length,
           (FILE */* __restrict  */)fp);
    }
  }
#line 1534
  if (contlen != -1L) {
#line 1534
    tmp___130 = contlen;
  } else {
#line 1534
    tmp___130 = 0L;
  }
  {
#line 1534
  hs->res = get_contents(sock, fp, & hs->len, hs->restval, tmp___130, & rbuf, keep_alive,
                         & hs->dltime);
  }
#line 1538
  if (hs->res >= 0) {
    {
#line 1539
    while (1) {
      while_continue___67: /* CIL Label */ ;
#line 1539
      if (! keep_alive) {
        {
#line 1539
        while (1) {
          while_continue___68: /* CIL Label */ ;
#line 1539
          if (ssl) {
            {
#line 1539
            shutdown_ssl(ssl);
            }
          }
#line 1539
          goto while_break___68;
        }
        while_break___68: /* CIL Label */ ;
        }
        {
#line 1539
        while (1) {
          while_continue___69: /* CIL Label */ ;
          {
#line 1539
          close(sock);
          }
          {
#line 1539
          while (1) {
            while_continue___70: /* CIL Label */ ;
#line 1539
            if (opt.debug) {
              {
#line 1539
              debug_logprintf("Closing fd %d\n", sock);
              }
            }
#line 1539
            goto while_break___70;
          }
          while_break___70: /* CIL Label */ ;
          }
#line 1539
          goto while_break___69;
        }
        while_break___69: /* CIL Label */ ;
        }
#line 1539
        if (pc_active_p) {
#line 1539
          if (sock == pc_last_fd) {
            {
#line 1539
            invalidate_persistent();
            }
          }
        }
      }
#line 1539
      goto while_break___67;
    }
    while_break___67: /* CIL Label */ ;
    }
  } else {
    {
#line 1541
    while (1) {
      while_continue___71: /* CIL Label */ ;
      {
#line 1541
      while (1) {
        while_continue___72: /* CIL Label */ ;
#line 1541
        if (ssl) {
          {
#line 1541
          shutdown_ssl(ssl);
          }
        }
#line 1541
        goto while_break___72;
      }
      while_break___72: /* CIL Label */ ;
      }
      {
#line 1541
      while (1) {
        while_continue___73: /* CIL Label */ ;
        {
#line 1541
        close(sock);
        }
        {
#line 1541
        while (1) {
          while_continue___74: /* CIL Label */ ;
#line 1541
          if (opt.debug) {
            {
#line 1541
            debug_logprintf("Closing fd %d\n", sock);
            }
          }
#line 1541
          goto while_break___74;
        }
        while_break___74: /* CIL Label */ ;
        }
#line 1541
        goto while_break___73;
      }
      while_break___73: /* CIL Label */ ;
      }
#line 1541
      if (pc_active_p) {
#line 1541
        if (sock == pc_last_fd) {
          {
#line 1541
          invalidate_persistent();
          }
        }
      }
#line 1541
      goto while_break___71;
    }
    while_break___71: /* CIL Label */ ;
    }
  }
#line 1548
  if (! opt.dfp) {
    {
#line 1549
    flush_res = fclose(fp);
    }
  } else {
    {
#line 1551
    flush_res = fflush(fp);
    }
  }
#line 1552
  if (flush_res == -1) {
#line 1553
    hs->res = -2;
  }
  {
#line 1555
  while (1) {
    while_continue___75: /* CIL Label */ ;
#line 1555
    if (all_headers) {
      {
#line 1555
      free((void *)all_headers);
      }
    }
#line 1555
    goto while_break___75;
  }
  while_break___75: /* CIL Label */ ;
  }
#line 1556
  if (hs->res == -2) {
#line 1557
    return ((uerr_t )29);
  }
#line 1558
  return ((uerr_t )42);
}
}
#line 1563 "http.c"
uerr_t http_loop(struct url *u , char **newloc , char **local_file , char const   *referer ,
                 int *dt , struct url *proxy ) 
{ 
  int count ;
  int use_ts ;
  int got_head ;
  char *filename_plus_orig_suffix ;
  char *local_filename ;
  char *tms ;
  char *locf ;
  char *tmrate ;
  uerr_t err ;
  time_t tml ;
  time_t tmr ;
  long local_size ;
  size_t filename_len ;
  struct http_stat hstat ;
  struct stat st ;
  char *dummy ;
  char *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  boolean local_dot_orig_file_exists ;
  int tmp___5 ;
  int tmp___6 ;
  char *hurl ;
  char *tmp___7 ;
  char tmp___8[15] ;
  char *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *hurl___0 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char const   *fl ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  int *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  int *tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;

  {
#line 1568
  got_head = 0;
#line 1570
  local_filename = (char *)((void *)0);
#line 1573
  tml = (time_t )-1;
#line 1573
  tmr = (time_t )-1;
#line 1574
  local_size = 0L;
#line 1578
  dummy = (char *)((void *)0);
#line 1583
  if (opt.cookies) {
#line 1585
    if (! wget_cookie_jar) {
      {
#line 1586
      wget_cookie_jar = cookie_jar_new();
      }
    }
#line 1587
    if (opt.cookies_input) {
#line 1587
      if (! cookies_loaded_p) {
        {
#line 1589
        cookie_jar_load(wget_cookie_jar, (char const   *)opt.cookies_input);
#line 1590
        cookies_loaded_p = 1;
        }
      }
    }
  }
  {
#line 1594
  *newloc = (char *)((void *)0);
#line 1599
  tmp___0 = strchr((char const   *)u->url, '*');
  }
#line 1599
  if (tmp___0) {
    {
#line 1600
    tmp = gettext("Warning: wildcards not supported in HTTP.\n");
#line 1600
    logputs((enum log_options )0, (char const   *)tmp);
    }
  }
#line 1603
  if (local_file) {
#line 1603
    if (*local_file) {
#line 1604
      hstat.local_file = local_file;
    } else {
#line 1603
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1605
  if (local_file) {
    {
#line 1607
    *local_file = url_file_name((struct url  const  *)u);
#line 1608
    hstat.local_file = local_file;
    }
  } else {
    {
#line 1612
    dummy = url_file_name((struct url  const  *)u);
#line 1613
    hstat.local_file = & dummy;
    }
  }
#line 1616
  if (! opt.output_document) {
#line 1617
    locf = *(hstat.local_file);
  } else {
#line 1619
    locf = opt.output_document;
  }
  {
#line 1621
  hstat.referer = referer;
#line 1623
  filename_len = strlen((char const   *)*(hstat.local_file));
#line 1624
  tmp___1 = __builtin_alloca((unsigned long )filename_len + sizeof(".orig"));
#line 1624
  filename_plus_orig_suffix = (char *)tmp___1;
  }
#line 1626
  if (opt.noclobber) {
    {
#line 1626
    tmp___4 = file_exists_p((char const   *)*(hstat.local_file));
    }
#line 1626
    if (tmp___4) {
      {
#line 1630
      tmp___2 = gettext("File `%s\' already there, will not retrieve.\n");
#line 1630
      logprintf((enum log_options )0, (char const   *)tmp___2, *(hstat.local_file));
#line 1633
      *dt |= 2;
#line 1637
      tmp___3 = has_html_suffix_p((char const   *)*(hstat.local_file));
      }
#line 1637
      if (tmp___3) {
#line 1638
        *dt |= 1;
      }
      {
#line 1640
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1640
        if (dummy) {
          {
#line 1640
          free((void *)dummy);
          }
        }
#line 1640
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 1641
      return ((uerr_t )34);
    }
  }
#line 1644
  use_ts = 0;
#line 1645
  if (opt.timestamping) {
#line 1647
    local_dot_orig_file_exists = (boolean )0;
#line 1649
    if (opt.backup_converted) {
      {
#line 1667
      memcpy((void */* __restrict  */)filename_plus_orig_suffix, (void const   */* __restrict  */)*(hstat.local_file),
             filename_len);
#line 1668
      memcpy((void */* __restrict  */)(filename_plus_orig_suffix + filename_len),
             (void const   */* __restrict  */)".orig", (size_t )sizeof(".orig"));
#line 1672
      tmp___5 = stat((char const   */* __restrict  */)filename_plus_orig_suffix, (struct stat */* __restrict  */)(& st));
      }
#line 1672
      if (tmp___5 == 0) {
#line 1674
        local_dot_orig_file_exists = (boolean )1;
#line 1675
        local_filename = filename_plus_orig_suffix;
      }
    }
#line 1679
    if (! local_dot_orig_file_exists) {
      {
#line 1681
      tmp___6 = stat((char const   */* __restrict  */)*(hstat.local_file), (struct stat */* __restrict  */)(& st));
      }
#line 1681
      if (tmp___6 == 0) {
#line 1682
        local_filename = *(hstat.local_file);
      }
    }
#line 1684
    if ((unsigned long )local_filename != (unsigned long )((void *)0)) {
#line 1689
      use_ts = 1;
#line 1690
      tml = st.st_mtim.tv_sec;
#line 1696
      local_size = st.st_size;
#line 1697
      got_head = 0;
    }
  }
#line 1701
  count = 0;
#line 1702
  *dt = 16;
  {
#line 1704
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1707
    count ++;
#line 1708
    sleep_between_retrievals(count);
#line 1710
    tms = time_str((time_t *)((void *)0));
    }
#line 1712
    if (opt.verbose) {
      {
#line 1714
      tmp___7 = url_string((struct url  const  *)u, 1);
#line 1714
      hurl = tmp___7;
#line 1716
      strcpy((char */* __restrict  */)(tmp___8), (char const   */* __restrict  */)"        ");
      }
#line 1717
      if (count > 1) {
        {
#line 1718
        tmp___9 = gettext("(try:%2d)");
#line 1718
        sprintf((char */* __restrict  */)(tmp___8), (char const   */* __restrict  */)tmp___9,
                count);
        }
      }
      {
#line 1719
      logprintf((enum log_options )0, "--%s--  %s\n  %s => `%s\'\n", tms, hurl, tmp___8,
                locf);
#line 1724
      free((void *)hurl);
      }
    }
#line 1730
    if (opt.spider) {
#line 1731
      *dt |= 4;
    } else
#line 1730
    if (use_ts) {
#line 1730
      if (! got_head) {
#line 1731
        *dt |= 4;
      } else {
#line 1733
        *dt &= -5;
      }
    } else {
#line 1733
      *dt &= -5;
    }
#line 1735
    hstat.restval = 0L;
#line 1737
    if (count > 1) {
#line 1737
      if (*dt & 16) {
#line 1737
        goto _L___0;
      } else {
#line 1737
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 1737
    if (opt.always_rest) {
      _L___0: /* CIL Label */ 
      {
#line 1737
      tmp___11 = file_exists_p((char const   *)locf);
      }
#line 1737
      if (tmp___11) {
        {
#line 1740
        tmp___10 = stat((char const   */* __restrict  */)locf, (struct stat */* __restrict  */)(& st));
        }
#line 1740
        if (tmp___10 == 0) {
#line 1740
          if ((st.st_mode & 61440U) == 32768U) {
#line 1741
            hstat.restval = st.st_size;
          }
        }
      }
    }
#line 1746
    hstat.no_truncate = 0;
#line 1747
    if (opt.always_rest) {
#line 1747
      if (hstat.restval) {
#line 1748
        hstat.no_truncate = 1;
      }
    }
#line 1756
    if (proxy) {
#line 1756
      if (count > 1) {
#line 1759
        *dt |= 8;
      } else {
#line 1756
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 1756
    if (! opt.allow_cache) {
#line 1759
      *dt |= 8;
    } else {
#line 1761
      *dt &= -9;
    }
    {
#line 1764
    err = gethttp(u, & hstat, dt, proxy);
    }
#line 1770
    if (! opt.output_document) {
#line 1771
      locf = *(hstat.local_file);
    } else {
#line 1773
      locf = opt.output_document;
    }
    {
#line 1776
    tms = time_str((time_t *)((void *)0));
    }
#line 1778
    if (hstat.newloc) {
      {
#line 1779
      *newloc = xstrdup_real((char const   *)hstat.newloc);
      }
    }
    {
#line 1784
    if ((unsigned int )err == 47U) {
#line 1784
      goto case_47;
    }
#line 1784
    if ((unsigned int )err == 55U) {
#line 1784
      goto case_47;
    }
#line 1784
    if ((unsigned int )err == 43U) {
#line 1784
      goto case_47;
    }
#line 1784
    if ((unsigned int )err == 3U) {
#line 1784
      goto case_47;
    }
#line 1784
    if ((unsigned int )err == 14U) {
#line 1784
      goto case_47;
    }
#line 1784
    if ((unsigned int )err == 2U) {
#line 1784
      goto case_47;
    }
#line 1784
    if ((unsigned int )err == 32U) {
#line 1784
      goto case_47;
    }
#line 1784
    if ((unsigned int )err == 33U) {
#line 1784
      goto case_47;
    }
#line 1793
    if ((unsigned int )err == 40U) {
#line 1793
      goto case_40;
    }
#line 1793
    if ((unsigned int )err == 58U) {
#line 1793
      goto case_40;
    }
#line 1793
    if ((unsigned int )err == 53U) {
#line 1793
      goto case_40;
    }
#line 1793
    if ((unsigned int )err == 52U) {
#line 1793
      goto case_40;
    }
#line 1793
    if ((unsigned int )err == 5U) {
#line 1793
      goto case_40;
    }
#line 1793
    if ((unsigned int )err == 1U) {
#line 1793
      goto case_40;
    }
#line 1799
    if ((unsigned int )err == 28U) {
#line 1799
      goto case_28;
    }
#line 1799
    if ((unsigned int )err == 29U) {
#line 1799
      goto case_28;
    }
#line 1808
    if ((unsigned int )err == 4U) {
#line 1808
      goto case_4;
    }
#line 1816
    if ((unsigned int )err == 6U) {
#line 1816
      goto case_6;
    }
#line 1831
    if ((unsigned int )err == 41U) {
#line 1831
      goto case_41;
    }
#line 1837
    if ((unsigned int )err == 42U) {
#line 1837
      goto case_42;
    }
#line 1840
    goto switch_default;
    case_47: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_43: /* CIL Label */ 
    case_3: /* CIL Label */ 
    case_14: /* CIL Label */ 
    case_2: /* CIL Label */ 
    case_32: /* CIL Label */ 
    case_33: /* CIL Label */ 
    {
#line 1788
    free_hstat(& hstat);
#line 1789
    printwhat(count, opt.ntry);
    }
#line 1790
    goto __Cont;
#line 1791
    goto switch_break;
    case_40: /* CIL Label */ 
    case_58: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_5: /* CIL Label */ 
    case_1: /* CIL Label */ 
    {
#line 1795
    free_hstat(& hstat);
    }
    {
#line 1796
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1796
      if (dummy) {
        {
#line 1796
        free((void *)dummy);
        }
      }
#line 1796
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1797
    return (err);
#line 1798
    goto switch_break;
    case_28: /* CIL Label */ 
    case_29: /* CIL Label */ 
    {
#line 1801
    logputs((enum log_options )0, "\n");
#line 1802
    tmp___12 = __errno_location();
#line 1802
    tmp___13 = strerror(*tmp___12);
#line 1802
    tmp___14 = gettext("Cannot write to `%s\' (%s).\n");
#line 1802
    logprintf((enum log_options )1, (char const   *)tmp___14, *(hstat.local_file),
              tmp___13);
#line 1804
    free_hstat(& hstat);
    }
    {
#line 1805
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1805
      if (dummy) {
        {
#line 1805
        free((void *)dummy);
        }
      }
#line 1805
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1806
    return (err);
#line 1807
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 1810
    logputs((enum log_options )0, "\n");
#line 1811
    tmp___15 = gettext("Unable to establish SSL connection.\n");
#line 1811
    logprintf((enum log_options )1, (char const   *)tmp___15);
#line 1812
    free_hstat(& hstat);
    }
    {
#line 1813
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1813
      if (dummy) {
        {
#line 1813
        free((void *)dummy);
        }
      }
#line 1813
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1814
    return (err);
#line 1815
    goto switch_break;
    case_6: /* CIL Label */ 
#line 1818
    if (! hstat.newloc) {
      {
#line 1820
      tmp___16 = gettext("ERROR: Redirection (%d) without location.\n");
#line 1820
      logprintf((enum log_options )1, (char const   *)tmp___16, hstat.statcode);
#line 1823
      free_hstat(& hstat);
      }
      {
#line 1824
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1824
        if (dummy) {
          {
#line 1824
          free((void *)dummy);
          }
        }
#line 1824
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1825
      return ((uerr_t )37);
    }
    {
#line 1827
    free_hstat(& hstat);
    }
    {
#line 1828
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1828
      if (dummy) {
        {
#line 1828
        free((void *)dummy);
        }
      }
#line 1828
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 1829
    return ((uerr_t )6);
#line 1830
    goto switch_break;
    case_41: /* CIL Label */ 
    {
#line 1833
    free_hstat(& hstat);
    }
    {
#line 1834
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 1834
      if (dummy) {
        {
#line 1834
        free((void *)dummy);
        }
      }
#line 1834
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 1835
    return ((uerr_t )34);
#line 1836
    goto switch_break;
    case_42: /* CIL Label */ 
#line 1839
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1842
    abort();
    }
    switch_break: /* CIL Label */ ;
    }
#line 1844
    if (! (*dt & 2)) {
#line 1846
      if (! opt.verbose) {
        {
#line 1849
        tmp___17 = url_string((struct url  const  *)u, 1);
#line 1849
        hurl___0 = tmp___17;
#line 1850
        logprintf((enum log_options )2, "%s:\n", hurl___0);
#line 1851
        free((void *)hurl___0);
        }
      }
      {
#line 1853
      tmp___18 = gettext("%s ERROR %d: %s.\n");
#line 1853
      logprintf((enum log_options )1, (char const   *)tmp___18, tms, hstat.statcode,
                hstat.error);
#line 1855
      logputs((enum log_options )0, "\n");
#line 1856
      free_hstat(& hstat);
      }
      {
#line 1857
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 1857
        if (dummy) {
          {
#line 1857
          free((void *)dummy);
          }
        }
#line 1857
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 1858
      return ((uerr_t )37);
    }
#line 1862
    if (! got_head) {
#line 1864
      if (opt.timestamping) {
#line 1864
        if (! hstat.remote_time) {
          {
#line 1866
          tmp___19 = gettext("Last-modified header missing -- time-stamps turned off.\n");
#line 1866
          logputs((enum log_options )1, (char const   *)tmp___19);
          }
        } else {
#line 1864
          goto _L___3;
        }
      } else
      _L___3: /* CIL Label */ 
#line 1869
      if (hstat.remote_time) {
        {
#line 1872
        tmr = http_atotm((char const   *)hstat.remote_time);
        }
#line 1873
        if (tmr == -1L) {
          {
#line 1874
          tmp___20 = gettext("Last-modified header invalid -- time-stamp ignored.\n");
#line 1874
          logputs((enum log_options )0, (char const   *)tmp___20);
          }
        }
      }
    }
#line 1880
    if (use_ts) {
#line 1882
      got_head = 1;
#line 1883
      *dt &= -5;
#line 1884
      use_ts = 0;
#line 1885
      count = 0;
#line 1887
      if (hstat.remote_time) {
#line 1887
        if (tmr != -1L) {
#line 1894
          if (tml >= tmr) {
#line 1894
            if (hstat.contlen == -1L) {
#line 1894
              goto _L___5;
            } else
#line 1894
            if (local_size == hstat.contlen) {
              _L___5: /* CIL Label */ 
              {
#line 1897
              tmp___21 = gettext("Server file no newer than local file `%s\' -- not retrieving.\n\n");
#line 1897
              logprintf((enum log_options )0, (char const   *)tmp___21, local_filename);
#line 1900
              free_hstat(& hstat);
              }
              {
#line 1901
              while (1) {
                while_continue___8: /* CIL Label */ ;
#line 1901
                if (dummy) {
                  {
#line 1901
                  free((void *)dummy);
                  }
                }
#line 1901
                goto while_break___8;
              }
              while_break___8: /* CIL Label */ ;
              }
#line 1902
              return ((uerr_t )34);
            } else {
#line 1894
              goto _L___4;
            }
          } else
          _L___4: /* CIL Label */ 
#line 1904
          if (tml >= tmr) {
            {
#line 1905
            tmp___22 = gettext("The sizes do not match (local %ld) -- retrieving.\n");
#line 1905
            logprintf((enum log_options )0, (char const   *)tmp___22, local_size);
            }
          } else {
            {
#line 1908
            tmp___23 = gettext("Remote file is newer, retrieving.\n");
#line 1908
            logputs((enum log_options )0, (char const   *)tmp___23);
            }
          }
        }
      }
      {
#line 1911
      free_hstat(& hstat);
      }
#line 1912
      goto __Cont;
    }
#line 1914
    if (tmr != -1L) {
#line 1914
      if (! opt.spider) {
#line 1914
        if (hstat.len == hstat.contlen) {
#line 1914
          goto _L___7;
        } else
#line 1914
        if (hstat.res == 0) {
#line 1914
          if (hstat.contlen == -1L) {
#line 1914
            goto _L___7;
          } else
#line 1914
          if (hstat.len >= hstat.contlen) {
#line 1914
            if (! opt.kill_longer) {
              _L___7: /* CIL Label */ 
#line 1923
              fl = (char const   *)((void *)0);
#line 1924
              if (opt.output_document) {
#line 1926
                if (opt.od_known_regular) {
#line 1927
                  fl = (char const   *)opt.output_document;
                }
              } else {
#line 1930
                fl = (char const   *)*(hstat.local_file);
              }
#line 1931
              if (fl) {
                {
#line 1932
                touch(fl, tmr);
                }
              }
            }
          }
        }
      }
    }
#line 1936
    if (opt.spider) {
      {
#line 1938
      logprintf((enum log_options )1, "%d %s\n\n", hstat.statcode, hstat.error);
      }
      {
#line 1939
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 1939
        if (dummy) {
          {
#line 1939
          free((void *)dummy);
          }
        }
#line 1939
        goto while_break___9;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 1940
      return ((uerr_t )34);
    }
    {
#line 1943
    tmrate = retr_rate(hstat.len - hstat.restval, hstat.dltime, 0);
    }
#line 1945
    if (hstat.len == hstat.contlen) {
#line 1947
      if (*dt & 2) {
        {
#line 1949
        tmp___24 = gettext("%s (%s) - `%s\' saved [%ld/%ld]\n\n");
#line 1949
        logprintf((enum log_options )0, (char const   *)tmp___24, tms, tmrate, locf,
                  hstat.len, hstat.contlen);
#line 1952
        logprintf((enum log_options )2, "%s URL:%s [%ld/%ld] -> \"%s\" [%d]\n", tms,
                  u->url, hstat.len, hstat.contlen, locf, count);
        }
      }
#line 1956
      (opt.numurls) ++;
#line 1957
      total_downloaded_bytes += (LARGE_INT )hstat.len;
#line 1960
      if (*dt & 32) {
        {
#line 1961
        downloaded_file((downloaded_file_t )2, (char const   *)locf);
        }
      } else {
        {
#line 1963
        downloaded_file((downloaded_file_t )1, (char const   *)locf);
        }
      }
      {
#line 1965
      free_hstat(& hstat);
      }
      {
#line 1966
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 1966
        if (dummy) {
          {
#line 1966
          free((void *)dummy);
          }
        }
#line 1966
        goto while_break___10;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 1967
      return ((uerr_t )34);
    } else
#line 1969
    if (hstat.res == 0) {
#line 1971
      if (hstat.contlen == -1L) {
#line 1974
        if (*dt & 2) {
          {
#line 1976
          tmp___25 = gettext("%s (%s) - `%s\' saved [%ld]\n\n");
#line 1976
          logprintf((enum log_options )0, (char const   *)tmp___25, tms, tmrate, locf,
                    hstat.len);
#line 1979
          logprintf((enum log_options )2, "%s URL:%s [%ld] -> \"%s\" [%d]\n", tms,
                    u->url, hstat.len, locf, count);
          }
        }
#line 1983
        (opt.numurls) ++;
#line 1984
        total_downloaded_bytes += (LARGE_INT )hstat.len;
#line 1987
        if (*dt & 32) {
          {
#line 1988
          downloaded_file((downloaded_file_t )2, (char const   *)locf);
          }
        } else {
          {
#line 1990
          downloaded_file((downloaded_file_t )1, (char const   *)locf);
          }
        }
        {
#line 1992
        free_hstat(& hstat);
        }
        {
#line 1993
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 1993
          if (dummy) {
            {
#line 1993
            free((void *)dummy);
            }
          }
#line 1993
          goto while_break___11;
        }
        while_break___11: /* CIL Label */ ;
        }
#line 1994
        return ((uerr_t )34);
      } else
#line 1996
      if (hstat.len < hstat.contlen) {
        {
#line 1999
        tmp___26 = gettext("%s (%s) - Connection closed at byte %ld. ");
#line 1999
        logprintf((enum log_options )0, (char const   *)tmp___26, tms, tmrate, hstat.len);
#line 2002
        printwhat(count, opt.ntry);
#line 2003
        free_hstat(& hstat);
        }
#line 2004
        goto __Cont;
      } else
#line 2006
      if (! opt.kill_longer) {
        {
#line 2008
        tmp___27 = gettext("%s (%s) - `%s\' saved [%ld/%ld])\n\n");
#line 2008
        logprintf((enum log_options )0, (char const   *)tmp___27, tms, tmrate, locf,
                  hstat.len, hstat.contlen);
#line 2011
        logprintf((enum log_options )2, "%s URL:%s [%ld/%ld] -> \"%s\" [%d]\n", tms,
                  u->url, hstat.len, hstat.contlen, locf, count);
#line 2014
        (opt.numurls) ++;
#line 2015
        total_downloaded_bytes += (LARGE_INT )hstat.len;
        }
#line 2018
        if (*dt & 32) {
          {
#line 2019
          downloaded_file((downloaded_file_t )2, (char const   *)locf);
          }
        } else {
          {
#line 2021
          downloaded_file((downloaded_file_t )1, (char const   *)locf);
          }
        }
        {
#line 2023
        free_hstat(& hstat);
        }
        {
#line 2024
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 2024
          if (dummy) {
            {
#line 2024
            free((void *)dummy);
            }
          }
#line 2024
          goto while_break___12;
        }
        while_break___12: /* CIL Label */ ;
        }
#line 2025
        return ((uerr_t )34);
      } else {
        {
#line 2029
        tmp___28 = gettext("%s (%s) - Connection closed at byte %ld/%ld. ");
#line 2029
        logprintf((enum log_options )0, (char const   *)tmp___28, tms, tmrate, hstat.len,
                  hstat.contlen);
#line 2032
        printwhat(count, opt.ntry);
#line 2033
        free_hstat(& hstat);
        }
#line 2034
        goto __Cont;
      }
    } else
#line 2039
    if (hstat.contlen == -1L) {
      {
#line 2041
      tmp___29 = __errno_location();
#line 2041
      tmp___30 = strerror(*tmp___29);
#line 2041
      tmp___31 = gettext("%s (%s) - Read error at byte %ld (%s).");
#line 2041
      logprintf((enum log_options )0, (char const   *)tmp___31, tms, tmrate, hstat.len,
                tmp___30);
#line 2044
      printwhat(count, opt.ntry);
#line 2045
      free_hstat(& hstat);
      }
#line 2046
      goto __Cont;
    } else {
      {
#line 2050
      tmp___32 = __errno_location();
#line 2050
      tmp___33 = strerror(*tmp___32);
#line 2050
      tmp___34 = gettext("%s (%s) - Read error at byte %ld/%ld (%s). ");
#line 2050
      logprintf((enum log_options )0, (char const   *)tmp___34, tms, tmrate, hstat.len,
                hstat.contlen, tmp___33);
#line 2054
      printwhat(count, opt.ntry);
#line 2055
      free_hstat(& hstat);
      }
#line 2056
      goto __Cont;
    }
#line 2060
    goto while_break___0;
    __Cont: /* CIL Label */ 
#line 1704
    if (! (! opt.ntry)) {
#line 1704
      if (! (count < opt.ntry)) {
#line 1704
        goto while_break___0;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2063
  return ((uerr_t )44);
}
}
#line 2105 "http.c"
static time_t mktime_from_utc(struct tm *t ) 
{ 
  time_t tl ;
  time_t tb ;
  struct tm *tg ;

  {
  {
#line 2111
  tl = mktime(t);
  }
#line 2112
  if (tl == -1L) {
    {
#line 2114
    (t->tm_hour) --;
#line 2115
    tl = mktime(t);
    }
#line 2116
    if (tl == -1L) {
#line 2117
      return ((time_t )-1);
    }
#line 2118
    tl += 3600L;
  }
  {
#line 2120
  tg = gmtime((time_t const   *)(& tl));
#line 2121
  tg->tm_isdst = 0;
#line 2122
  tb = mktime(tg);
  }
#line 2123
  if (tb == -1L) {
    {
#line 2125
    (tg->tm_hour) --;
#line 2126
    tb = mktime(tg);
    }
#line 2127
    if (tb == -1L) {
#line 2128
      return ((time_t )-1);
    }
#line 2129
    tb += 3600L;
  }
#line 2131
  return (tl - (tb - tl));
}
}
#line 2142 "http.c"
static int check_end(char const   *p ) 
{ 


  {
#line 2145
  if (! p) {
#line 2146
    return (0);
  }
  {
#line 2147
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2147
    if (! ((int const   )_sch_istable[(int const   )*p & 255] & 64)) {
#line 2147
      goto while_break;
    }
#line 2148
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2149
  if (! *p) {
#line 2152
    return (1);
  } else
#line 2149
  if ((int const   )*(p + 0) == 71) {
#line 2149
    if ((int const   )*(p + 1) == 77) {
#line 2149
      if ((int const   )*(p + 2) == 84) {
#line 2152
        return (1);
      } else {
#line 2149
        goto _L___1;
      }
    } else {
#line 2149
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 2149
  if ((int const   )*(p + 0) == 43) {
#line 2149
    goto _L;
  } else
#line 2149
  if ((int const   )*(p + 0) == 45) {
    _L: /* CIL Label */ 
#line 2149
    if ((int const   )_sch_istable[(int const   )*(p + 1) & 255] & 4) {
#line 2152
      return (1);
    } else {
#line 2154
      return (0);
    }
  } else {
#line 2154
    return (0);
  }
}
}
#line 2192 "http.c"
static char const   *time_formats[4]  = {      "%a, %d %b %Y %T",      "%A, %d-%b-%y %T",      "%a, %d-%b-%Y %T",      "%a %b %d %T %Y"};
#line 2184 "http.c"
time_t http_atotm(char const   *time_string ) 
{ 
  int i ;
  struct tm t ;
  time_t tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 2205
  t.tm_isdst = 0;
#line 2220
  i = 0;
  {
#line 2220
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2220
    if (! ((unsigned long )i < sizeof(time_formats) / sizeof(time_formats[0]))) {
#line 2220
      goto while_break;
    }
    {
#line 2221
    tmp___0 = strptime((char const   */* __restrict  */)time_string, (char const   */* __restrict  */)time_formats[i],
                       & t);
#line 2221
    tmp___1 = check_end((char const   *)tmp___0);
    }
#line 2221
    if (tmp___1) {
      {
#line 2222
      tmp = mktime_from_utc(& t);
      }
#line 2222
      return (tmp);
    }
#line 2220
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2225
  return ((time_t )-1);
}
}
#line 2246
static void base64_encode(char const   *s , char *store , int length ) ;
#line 2246 "http.c"
static char tbl[64]  = 
#line 2246
  {      (char )'A',      (char )'B',      (char )'C',      (char )'D', 
        (char )'E',      (char )'F',      (char )'G',      (char )'H', 
        (char )'I',      (char )'J',      (char )'K',      (char )'L', 
        (char )'M',      (char )'N',      (char )'O',      (char )'P', 
        (char )'Q',      (char )'R',      (char )'S',      (char )'T', 
        (char )'U',      (char )'V',      (char )'W',      (char )'X', 
        (char )'Y',      (char )'Z',      (char )'a',      (char )'b', 
        (char )'c',      (char )'d',      (char )'e',      (char )'f', 
        (char )'g',      (char )'h',      (char )'i',      (char )'j', 
        (char )'k',      (char )'l',      (char )'m',      (char )'n', 
        (char )'o',      (char )'p',      (char )'q',      (char )'r', 
        (char )'s',      (char )'t',      (char )'u',      (char )'v', 
        (char )'w',      (char )'x',      (char )'y',      (char )'z', 
        (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )'+',      (char )'/'};
#line 2242 "http.c"
static void base64_encode(char const   *s , char *store , int length ) 
{ 
  int i ;
  unsigned char *p ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char tmp___3 ;

  {
#line 2257
  p = (unsigned char *)store;
#line 2260
  i = 0;
  {
#line 2260
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2260
    if (! (i < length)) {
#line 2260
      goto while_break;
    }
#line 2262
    tmp = p;
#line 2262
    p ++;
#line 2262
    *tmp = (unsigned char )tbl[(int const   )*(s + 0) >> 2];
#line 2263
    tmp___0 = p;
#line 2263
    p ++;
#line 2263
    *tmp___0 = (unsigned char )tbl[(((int const   )*(s + 0) & 3) << 4) + ((int const   )*(s + 1) >> 4)];
#line 2264
    tmp___1 = p;
#line 2264
    p ++;
#line 2264
    *tmp___1 = (unsigned char )tbl[(((int const   )*(s + 1) & 15) << 2) + ((int const   )*(s + 2) >> 6)];
#line 2265
    tmp___2 = p;
#line 2265
    p ++;
#line 2265
    *tmp___2 = (unsigned char )tbl[(int const   )*(s + 2) & 63];
#line 2266
    s += 3;
#line 2260
    i += 3;
  }
  while_break: /* CIL Label */ ;
  }
#line 2269
  if (i == length + 1) {
#line 2270
    *(p - 1) = (unsigned char )'=';
  } else
#line 2271
  if (i == length + 2) {
#line 2272
    tmp___3 = (unsigned char )'=';
#line 2272
    *(p - 2) = tmp___3;
#line 2272
    *(p - 1) = tmp___3;
  }
#line 2274
  *p = (unsigned char )'\000';
#line 2275
  return;
}
}
#line 2280 "http.c"
static char *basic_authentication_encode(char const   *user , char const   *passwd ,
                                         char const   *header ) 
{ 
  char *t1 ;
  char *t2 ;
  char *res___0 ;
  int len1 ;
  size_t tmp ;
  size_t tmp___0 ;
  int len2 ;
  void *tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;

  {
  {
#line 2285
  tmp = strlen(user);
#line 2285
  tmp___0 = strlen(passwd);
#line 2285
  len1 = (int )((tmp + 1U) + tmp___0);
#line 2286
  len2 = 4 * ((len1 + 2) / 3);
#line 2288
  tmp___1 = __builtin_alloca((unsigned long )(len1 + 1));
#line 2288
  t1 = (char *)tmp___1;
#line 2289
  sprintf((char */* __restrict  */)t1, (char const   */* __restrict  */)"%s:%s", user,
          passwd);
#line 2290
  tmp___2 = __builtin_alloca((unsigned long )(1 + len2));
#line 2290
  t2 = (char *)tmp___2;
#line 2291
  base64_encode((char const   *)t1, t2, len1);
#line 2292
  tmp___3 = strlen(header);
#line 2292
  tmp___4 = xmalloc_real((size_t )(len2 + 11) + tmp___3);
#line 2292
  res___0 = (char *)tmp___4;
#line 2293
  sprintf((char */* __restrict  */)res___0, (char const   */* __restrict  */)"%s: Basic %s\r\n",
          header, t2);
  }
#line 2295
  return (res___0);
}
}
#line 2305 "http.c"
static int extract_header_attr(char const   *au , char const   *attr_name , char **ret ) 
{ 
  char const   *cp ;
  char const   *ep ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 2310
  cp = au;
#line 2310
  ep = cp;
#line 2312
  tmp___2 = strlen(attr_name);
#line 2312
  tmp___3 = strncmp(cp, attr_name, tmp___2);
  }
#line 2312
  if (tmp___3 == 0) {
    {
#line 2314
    tmp = strlen(attr_name);
#line 2314
    cp += tmp;
    }
#line 2315
    if (! *cp) {
#line 2316
      return (-1);
    }
    {
#line 2317
    tmp___0 = skip_lws(cp);
#line 2317
    cp += tmp___0;
    }
#line 2318
    if ((int const   )*cp != 61) {
#line 2319
      return (-1);
    }
#line 2320
    cp ++;
#line 2320
    if (! *cp) {
#line 2321
      return (-1);
    }
    {
#line 2322
    tmp___1 = skip_lws(cp);
#line 2322
    cp += tmp___1;
    }
#line 2323
    if ((int const   )*cp != 34) {
#line 2324
      return (-1);
    }
#line 2325
    cp ++;
#line 2325
    if (! *cp) {
#line 2326
      return (-1);
    }
#line 2327
    ep = cp;
    {
#line 2327
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2327
      if (*ep) {
#line 2327
        if (! ((int const   )*ep != 34)) {
#line 2327
          goto while_break;
        }
      } else {
#line 2327
        goto while_break;
      }
#line 2327
      ep ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 2329
    if (! *ep) {
#line 2330
      return (-1);
    }
    {
#line 2331
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2331
      if (*ret) {
        {
#line 2331
        free((void *)*ret);
        }
      }
#line 2331
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2332
    *ret = strdupdelim(cp, ep);
    }
#line 2333
    return ((int )((ep - au) + 1L));
  } else {
#line 2336
    return (0);
  }
}
}
#line 2343 "http.c"
static void dump_hash(unsigned char *buf___0 , unsigned char const   *hash ) 
{ 
  int i ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;

  {
#line 2348
  i = 0;
  {
#line 2348
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2348
    if (! (i < 16)) {
#line 2348
      goto while_break;
    }
#line 2350
    tmp = buf___0;
#line 2350
    buf___0 ++;
#line 2350
    *tmp = (unsigned char )*("0123456789abcdef" + ((int const   )*hash >> 4));
#line 2351
    tmp___0 = buf___0;
#line 2351
    buf___0 ++;
#line 2351
    *tmp___0 = (unsigned char )*("0123456789abcdef" + ((int const   )*hash & 15));
#line 2348
    i ++;
#line 2348
    hash ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2353
  *buf___0 = (unsigned char )'\000';
#line 2354
  return;
}
}
#line 2363 "http.c"
static char *realm  ;
#line 2363 "http.c"
static char *opaque  ;
#line 2363 "http.c"
static char *nonce  ;
#line 2364
static char *digest_authentication_encode(char const   *au , char const   *user ,
                                          char const   *passwd , char const   *method ,
                                          char const   *path ) ;
#line 2364 "http.c"
static struct __anonstruct_options_53 options[3]  = {      {"realm", & realm}, 
        {"opaque", & opaque}, 
        {"nonce", & nonce}};
#line 2358 "http.c"
static char *digest_authentication_encode(char const   *au , char const   *user ,
                                          char const   *passwd , char const   *method ,
                                          char const   *path ) 
{ 
  char *res___0 ;
  int i ;
  int tmp ;
  int skip ;
  int tmp___0 ;
  int tmp___1 ;
  gen_md5_context *ctx ;
  int tmp___2 ;
  void *tmp___3 ;
  unsigned char hash[16] ;
  unsigned char a1buf[33] ;
  unsigned char a2buf[33] ;
  unsigned char response_digest[33] ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  void *tmp___17 ;
  char *p ;
  size_t tmp___18 ;

  {
#line 2374
  nonce = (char *)((void *)0);
#line 2374
  opaque = nonce;
#line 2374
  realm = opaque;
#line 2376
  au += 6;
  {
#line 2377
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2377
    if (! *au) {
#line 2377
      goto while_break;
    }
    {
#line 2381
    tmp = skip_lws(au);
#line 2381
    au += tmp;
#line 2382
    i = 0;
    }
    {
#line 2382
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2382
      if (! ((unsigned long )i < sizeof(options) / sizeof(options[0]))) {
#line 2382
        goto while_break___0;
      }
      {
#line 2384
      tmp___0 = extract_header_attr(au, options[i].name, options[i].variable);
#line 2384
      skip = tmp___0;
      }
#line 2386
      if (skip < 0) {
        {
#line 2388
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 2388
          if (realm) {
            {
#line 2388
            free((void *)realm);
            }
          }
#line 2388
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 2389
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 2389
          if (opaque) {
            {
#line 2389
            free((void *)opaque);
            }
          }
#line 2389
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 2390
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 2390
          if (nonce) {
            {
#line 2390
            free((void *)nonce);
            }
          }
#line 2390
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 2391
        return ((char *)((void *)0));
      } else
#line 2393
      if (skip) {
#line 2395
        au += skip;
#line 2396
        goto while_break___0;
      }
#line 2382
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2399
    if ((unsigned long )i == sizeof(options) / sizeof(options[0])) {
      {
#line 2401
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 2401
        if (*au) {
#line 2401
          if (! ((int const   )*au != 61)) {
#line 2401
            goto while_break___4;
          }
        } else {
#line 2401
          goto while_break___4;
        }
#line 2402
        au ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 2403
      if (*au) {
#line 2403
        au ++;
#line 2403
        if (*au) {
          {
#line 2405
          tmp___1 = skip_lws(au);
#line 2405
          au += tmp___1;
          }
#line 2406
          if ((int const   )*au == 34) {
#line 2408
            au ++;
            {
#line 2409
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 2409
              if (*au) {
#line 2409
                if (! ((int const   )*au != 34)) {
#line 2409
                  goto while_break___5;
                }
              } else {
#line 2409
                goto while_break___5;
              }
#line 2410
              au ++;
            }
            while_break___5: /* CIL Label */ ;
            }
#line 2411
            if (*au) {
#line 2412
              au ++;
            }
          }
        }
      }
    }
    {
#line 2416
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 2416
      if (*au) {
#line 2416
        if (! ((int const   )*au != 44)) {
#line 2416
          goto while_break___6;
        }
      } else {
#line 2416
        goto while_break___6;
      }
#line 2417
      au ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 2418
    if (*au) {
#line 2419
      au ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2421
  if (! realm) {
#line 2421
    goto _L;
  } else
#line 2421
  if (! nonce) {
#line 2421
    goto _L;
  } else
#line 2421
  if (! user) {
#line 2421
    goto _L;
  } else
#line 2421
  if (! passwd) {
#line 2421
    goto _L;
  } else
#line 2421
  if (! path) {
#line 2421
    goto _L;
  } else
#line 2421
  if (! method) {
    _L: /* CIL Label */ 
    {
#line 2423
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 2423
      if (realm) {
        {
#line 2423
        free((void *)realm);
        }
      }
#line 2423
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 2424
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 2424
      if (opaque) {
        {
#line 2424
        free((void *)opaque);
        }
      }
#line 2424
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 2425
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 2425
      if (nonce) {
        {
#line 2425
        free((void *)nonce);
        }
      }
#line 2425
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 2426
    return ((char *)((void *)0));
  }
  {
#line 2431
  tmp___2 = gen_md5_context_size();
#line 2431
  tmp___3 = __builtin_alloca((unsigned long )tmp___2);
#line 2431
  ctx = (gen_md5_context *)tmp___3;
#line 2437
  gen_md5_init(ctx);
#line 2438
  tmp___4 = strlen(user);
#line 2438
  gen_md5_update((unsigned char const   *)((unsigned char *)user), (int )tmp___4,
                 ctx);
#line 2439
  gen_md5_update((unsigned char const   *)((unsigned char *)":"), 1, ctx);
#line 2440
  tmp___5 = strlen((char const   *)realm);
#line 2440
  gen_md5_update((unsigned char const   *)((unsigned char *)realm), (int )tmp___5,
                 ctx);
#line 2441
  gen_md5_update((unsigned char const   *)((unsigned char *)":"), 1, ctx);
#line 2442
  tmp___6 = strlen(passwd);
#line 2442
  gen_md5_update((unsigned char const   *)((unsigned char *)passwd), (int )tmp___6,
                 ctx);
#line 2443
  gen_md5_finish(ctx, hash);
#line 2444
  dump_hash(a1buf, (unsigned char const   *)(hash));
#line 2447
  gen_md5_init(ctx);
#line 2448
  tmp___7 = strlen(method);
#line 2448
  gen_md5_update((unsigned char const   *)((unsigned char *)method), (int )tmp___7,
                 ctx);
#line 2449
  gen_md5_update((unsigned char const   *)((unsigned char *)":"), 1, ctx);
#line 2450
  tmp___8 = strlen(path);
#line 2450
  gen_md5_update((unsigned char const   *)((unsigned char *)path), (int )tmp___8,
                 ctx);
#line 2451
  gen_md5_finish(ctx, hash);
#line 2452
  dump_hash(a2buf, (unsigned char const   *)(hash));
#line 2455
  gen_md5_init(ctx);
#line 2456
  gen_md5_update((unsigned char const   *)(a1buf), 32, ctx);
#line 2457
  gen_md5_update((unsigned char const   *)((unsigned char *)":"), 1, ctx);
#line 2458
  tmp___9 = strlen((char const   *)nonce);
#line 2458
  gen_md5_update((unsigned char const   *)((unsigned char *)nonce), (int )tmp___9,
                 ctx);
#line 2459
  gen_md5_update((unsigned char const   *)((unsigned char *)":"), 1, ctx);
#line 2460
  gen_md5_update((unsigned char const   *)(a2buf), 32, ctx);
#line 2461
  gen_md5_finish(ctx, hash);
#line 2462
  dump_hash(response_digest, (unsigned char const   *)(hash));
#line 2464
  tmp___10 = strlen(user);
#line 2464
  tmp___11 = strlen(user);
#line 2464
  tmp___12 = strlen((char const   *)realm);
#line 2464
  tmp___13 = strlen((char const   *)nonce);
#line 2464
  tmp___14 = strlen(path);
  }
#line 2464
  if (opaque) {
    {
#line 2464
    tmp___15 = strlen((char const   *)opaque);
#line 2464
    tmp___16 = tmp___15;
    }
  } else {
#line 2464
    tmp___16 = (size_t )0;
  }
  {
#line 2464
  tmp___17 = xmalloc_real(((((((tmp___10 + tmp___11) + tmp___12) + tmp___13) + tmp___14) + 32U) + tmp___16) + 128U);
#line 2464
  res___0 = (char *)tmp___17;
#line 2472
  sprintf((char */* __restrict  */)res___0, (char const   */* __restrict  */)"Authorization: Digest username=\"%s\", realm=\"%s\", nonce=\"%s\", uri=\"%s\", response=\"%s\"",
          user, realm, nonce, path, response_digest);
  }
#line 2475
  if (opaque) {
    {
#line 2477
    tmp___18 = strlen((char const   *)res___0);
#line 2477
    p = res___0 + tmp___18;
#line 2478
    strcat((char */* __restrict  */)p, (char const   */* __restrict  */)", opaque=\"");
#line 2479
    strcat((char */* __restrict  */)p, (char const   */* __restrict  */)opaque);
#line 2480
    strcat((char */* __restrict  */)p, (char const   */* __restrict  */)"\"");
    }
  }
  {
#line 2482
  strcat((char */* __restrict  */)res___0, (char const   */* __restrict  */)"\r\n");
  }
#line 2484
  return (res___0);
}
}
#line 2494 "http.c"
static int known_authentication_scheme_p(char const   *au ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 2497
  tmp = strncasecmp(au, "Basic", (size_t )(sizeof("Basic") - 1UL));
  }
#line 2497
  if (tmp) {
    _L___0: /* CIL Label */ 
    {
#line 2497
    tmp___0 = strncasecmp(au, "Digest", (size_t )(sizeof("Digest") - 1UL));
    }
#line 2497
    if (tmp___0) {
      _L: /* CIL Label */ 
      {
#line 2497
      tmp___1 = strncasecmp(au, "NTLM", (size_t )(sizeof("NTLM") - 1UL));
      }
#line 2497
      if (tmp___1) {
#line 2497
        tmp___2 = 0;
      } else
#line 2497
      if ((int const   )_sch_istable[(int const   )*(au + (sizeof("NTLM") - 1UL)) & 255] & 64) {
#line 2497
        tmp___2 = 1;
      } else
#line 2497
      if (! *(au + (sizeof("NTLM") - 1UL))) {
#line 2497
        tmp___2 = 1;
      } else {
#line 2497
        tmp___2 = 0;
      }
    } else
#line 2497
    if ((int const   )_sch_istable[(int const   )*(au + (sizeof("Digest") - 1UL)) & 255] & 64) {
#line 2497
      tmp___2 = 1;
    } else
#line 2497
    if (! *(au + (sizeof("Digest") - 1UL))) {
#line 2497
      tmp___2 = 1;
    } else {
#line 2497
      goto _L;
    }
  } else
#line 2497
  if ((int const   )_sch_istable[(int const   )*(au + (sizeof("Basic") - 1UL)) & 255] & 64) {
#line 2497
    tmp___2 = 1;
  } else
#line 2497
  if (! *(au + (sizeof("Basic") - 1UL))) {
#line 2497
    tmp___2 = 1;
  } else {
#line 2497
    goto _L___0;
  }
#line 2497
  return (tmp___2);
}
}
#line 2509 "http.c"
static char *create_authorization_line(char const   *au , char const   *user , char const   *passwd ,
                                       char const   *method , char const   *path ) 
{ 
  char *wwwauth ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 2514
  wwwauth = (char *)((void *)0);
#line 2516
  tmp = strncasecmp(au, "Basic", (size_t )5);
  }
#line 2516
  if (! tmp) {
    {
#line 2517
    wwwauth = basic_authentication_encode(user, passwd, "Authorization");
    }
  }
  {
#line 2518
  tmp___1 = strncasecmp(au, "NTLM", (size_t )4);
  }
#line 2518
  if (tmp___1) {
    {
#line 2521
    tmp___0 = strncasecmp(au, "Digest", (size_t )6);
    }
#line 2521
    if (! tmp___0) {
      {
#line 2522
      wwwauth = digest_authentication_encode(au, user, passwd, method, path);
      }
    }
  } else {
    {
#line 2519
    wwwauth = basic_authentication_encode(user, passwd, "Authorization");
    }
  }
#line 2524
  return (wwwauth);
}
}
#line 2527 "http.c"
void http_cleanup(void) 
{ 


  {
#line 2530
  if (pc_last_host_ip) {
    {
#line 2531
    address_list_release(pc_last_host_ip);
    }
  }
#line 2532
  return;
}
}
#line 63 "html-parse.h"
void map_html_tags(char const   *text , int size , void (*mapfun)(struct taginfo * ,
                                                                  void * ) , void *maparg ,
                   int flags , struct hash_table  const  *allowed_tags , struct hash_table  const  *allowed_attributes ) ;
#line 59 "hash.h"
int hash_table_remove(struct hash_table *ht , void const   *key ) ;
#line 61 "html-url.c"
static void tag_find_urls(int tagid , struct taginfo *tag , struct map_context *ctx ) ;
#line 62
static void tag_handle_base(int tagid , struct taginfo *tag , struct map_context *ctx ) ;
#line 63
static void tag_handle_form(int tagid , struct taginfo *tag , struct map_context *ctx ) ;
#line 64
static void tag_handle_link(int tagid , struct taginfo *tag , struct map_context *ctx ) ;
#line 65
static void tag_handle_meta(int tagid , struct taginfo *tag , struct map_context *ctx ) ;
#line 93 "html-url.c"
static struct known_tag known_tags[21]  = 
#line 93
  {      {0, "a", & tag_find_urls}, 
        {1, "applet", & tag_find_urls}, 
        {2, "area", & tag_find_urls}, 
        {3, "base", & tag_handle_base}, 
        {4, "bgsound", & tag_find_urls}, 
        {5, "body", & tag_find_urls}, 
        {6, "embed", & tag_find_urls}, 
        {7, "fig", & tag_find_urls}, 
        {8, "form", & tag_handle_form}, 
        {9, "frame", & tag_find_urls}, 
        {10, "iframe", & tag_find_urls}, 
        {11, "img", & tag_find_urls}, 
        {12, "input", & tag_find_urls}, 
        {13, "layer", & tag_find_urls}, 
        {14, "link", & tag_handle_link}, 
        {15, "meta", & tag_handle_meta}, 
        {16, "overlay", & tag_find_urls}, 
        {17, "script", & tag_find_urls}, 
        {18, "table", & tag_find_urls}, 
        {19, "td", & tag_find_urls}, 
        {20, "th", & tag_find_urls}};
#line 140 "html-url.c"
static struct __anonstruct_tag_url_attributes_28 tag_url_attributes[20]  = 
#line 140
  {      {0, "href", 2}, 
        {1, "code", 1}, 
        {2, "href", 2}, 
        {4, "src", 1}, 
        {5, "background", 1}, 
        {6, "href", 2}, 
        {6, "src", 3}, 
        {7, "src", 1}, 
        {9, "src", 3}, 
        {10, "src", 3}, 
        {11, "href", 1}, 
        {11, "lowsrc", 1}, 
        {11, "src", 1}, 
        {12, "src", 1}, 
        {13, "src", 3}, 
        {16, "src", 3}, 
        {17, "src", 1}, 
        {18, "background", 1}, 
        {19, "background", 1}, 
        {20, "background", 1}};
#line 170 "html-url.c"
static char const   *additional_attributes[5]  = {      "rel",      "http-equiv",      "name",      "content", 
        "action"};
#line 178 "html-url.c"
struct hash_table *interesting_tags  ;
#line 179 "html-url.c"
struct hash_table *interesting_attributes  ;
#line 181 "html-url.c"
static void init_interesting(void) 
{ 
  int i ;
  char **ignored ;
  struct hash_table *intersect ;
  struct hash_table *tmp ;
  char **followed ;
  struct known_tag *t ;
  void *tmp___0 ;

  {
  {
#line 194
  interesting_tags = make_nocase_string_hash_table((int )(sizeof(known_tags) / sizeof(known_tags[0])));
#line 198
  i = 0;
  }
  {
#line 198
  while (1) {
    while_continue: /* CIL Label */ ;
#line 198
    if (! ((unsigned long )i < sizeof(known_tags) / sizeof(known_tags[0]))) {
#line 198
      goto while_break;
    }
    {
#line 199
    hash_table_put(interesting_tags, (void const   *)known_tags[i].name, (void *)(known_tags + i));
#line 198
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 202
  if (opt.ignore_tags) {
#line 205
    ignored = opt.ignore_tags;
    {
#line 205
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 205
      if (! *ignored) {
#line 205
        goto while_break___0;
      }
      {
#line 206
      hash_table_remove(interesting_tags, (void const   *)*ignored);
#line 205
      ignored ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 210
  if (opt.follow_tags) {
    {
#line 214
    tmp = make_nocase_string_hash_table(0);
#line 214
    intersect = tmp;
#line 216
    followed = opt.follow_tags;
    }
    {
#line 216
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 216
      if (! *followed) {
#line 216
        goto while_break___1;
      }
      {
#line 218
      tmp___0 = hash_table_get((struct hash_table  const  *)interesting_tags, (void const   *)*followed);
#line 218
      t = (struct known_tag *)tmp___0;
      }
#line 219
      if (! t) {
#line 220
        goto __Cont;
      }
      {
#line 221
      hash_table_put(intersect, (void const   *)*followed, (void *)t);
      }
      __Cont: /* CIL Label */ 
#line 216
      followed ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 223
    hash_table_destroy(interesting_tags);
#line 224
    interesting_tags = intersect;
    }
  }
  {
#line 228
  interesting_attributes = make_nocase_string_hash_table(10);
#line 229
  i = 0;
  }
  {
#line 229
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 229
    if (! ((unsigned long )i < sizeof(additional_attributes) / sizeof(additional_attributes[0]))) {
#line 229
      goto while_break___2;
    }
    {
#line 230
    string_set_add(interesting_attributes, additional_attributes[i]);
#line 229
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 231
  i = 0;
  {
#line 231
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 231
    if (! ((unsigned long )i < sizeof(tag_url_attributes) / sizeof(tag_url_attributes[0]))) {
#line 231
      goto while_break___3;
    }
    {
#line 232
    string_set_add(interesting_attributes, tag_url_attributes[i].attr_name);
#line 231
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 233
  return;
}
}
#line 239 "html-url.c"
static char *find_attr(struct taginfo *tag , char const   *name , int *attrind ) 
{ 
  int i ;
  int tmp ;

  {
#line 243
  i = 0;
  {
#line 243
  while (1) {
    while_continue: /* CIL Label */ ;
#line 243
    if (! (i < tag->nattrs)) {
#line 243
      goto while_break;
    }
    {
#line 244
    tmp = strcasecmp((char const   *)(tag->attrs + i)->name, name);
    }
#line 244
    if (! tmp) {
#line 246
      if (attrind) {
#line 247
        *attrind = i;
      }
#line 248
      return ((tag->attrs + i)->value);
    }
#line 243
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 250
  return ((char *)((void *)0));
}
}
#line 272 "html-url.c"
static struct urlpos *append_url(char const   *link_uri , struct taginfo *tag , int attrind ,
                                 struct map_context *ctx ) 
{ 
  int link_has_scheme ;
  int tmp ;
  struct urlpos *newel ;
  char const   *base ;
  char const   *tmp___0 ;
  struct url *url ;
  char *tmp___1 ;
  char *complete_uri ;
  char *tmp___2 ;
  void *tmp___3 ;
  struct urlpos *tmp___4 ;

  {
  {
#line 276
  tmp = url_has_scheme(link_uri);
#line 276
  link_has_scheme = tmp;
  }
#line 278
  if (ctx->base) {
#line 278
    tmp___0 = (char const   *)ctx->base;
  } else {
#line 278
    tmp___0 = ctx->parent_base;
  }
#line 278
  base = tmp___0;
#line 281
  if (! base) {
    {
#line 283
    while (1) {
      while_continue: /* CIL Label */ ;
#line 283
      if (opt.debug) {
        {
#line 283
        debug_logprintf("%s: no base, merge will use \"%s\".\n", ctx->document_file,
                        link_uri);
        }
      }
#line 283
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 286
    if (! link_has_scheme) {
      {
#line 292
      tmp___1 = gettext("%s: Cannot resolve incomplete link %s.\n");
#line 292
      logprintf((enum log_options )1, (char const   *)tmp___1, ctx->document_file,
                link_uri);
      }
#line 295
      return ((struct urlpos *)((void *)0));
    }
    {
#line 298
    url = url_parse(link_uri, (int *)((void *)0));
    }
#line 299
    if (! url) {
      {
#line 301
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 301
        if (opt.debug) {
          {
#line 301
          debug_logprintf("%s: link \"%s\" doesn\'t parse.\n", ctx->document_file,
                          link_uri);
          }
        }
#line 301
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 303
      return ((struct urlpos *)((void *)0));
    }
  } else {
    {
#line 312
    tmp___2 = uri_merge(base, link_uri);
#line 312
    complete_uri = tmp___2;
    }
    {
#line 314
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 314
      if (opt.debug) {
        {
#line 314
        debug_logprintf("%s: merge(\"%s\", \"%s\") -> %s\n", ctx->document_file, base,
                        link_uri, complete_uri);
        }
      }
#line 314
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 317
    url = url_parse((char const   *)complete_uri, (int *)((void *)0));
    }
#line 318
    if (! url) {
      {
#line 320
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 320
        if (opt.debug) {
          {
#line 320
          debug_logprintf("%s: merged link \"%s\" doesn\'t parse.\n", ctx->document_file,
                          complete_uri);
          }
        }
#line 320
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 322
      free((void *)complete_uri);
      }
#line 323
      return ((struct urlpos *)((void *)0));
    }
    {
#line 325
    free((void *)complete_uri);
    }
  }
  {
#line 328
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 328
    if (opt.debug) {
      {
#line 328
      debug_logprintf("appending \"%s\" to urlpos.\n", url->url);
      }
    }
#line 328
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 330
  tmp___3 = xmalloc_real((size_t )sizeof(struct urlpos ));
#line 330
  newel = (struct urlpos *)tmp___3;
#line 331
  memset((void *)newel, 0, (size_t )sizeof(*newel));
#line 333
  newel->next = (struct urlpos *)((void *)0);
#line 334
  newel->url = url;
#line 335
  newel->pos = (int )((tag->attrs + attrind)->value_raw_beginning - (char const   *)ctx->text);
#line 336
  newel->size = (tag->attrs + attrind)->value_raw_size;
  }
#line 340
  if (! link_has_scheme) {
#line 340
    if ((int const   )*link_uri != 47) {
#line 341
      newel->link_relative_p = 1U;
    } else {
#line 340
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 342
  if (link_has_scheme) {
#line 343
    newel->link_complete_p = 1U;
  }
#line 345
  if (ctx->tail) {
#line 347
    (ctx->tail)->next = newel;
#line 348
    ctx->tail = newel;
  } else {
#line 351
    tmp___4 = newel;
#line 351
    ctx->head = tmp___4;
#line 351
    ctx->tail = tmp___4;
  }
#line 353
  return (newel);
}
}
#line 362 "html-url.c"
static void tag_find_urls(int tagid , struct taginfo *tag , struct map_context *ctx ) 
{ 
  int i ;
  int attrind ;
  int first ;
  long tmp ;
  char *link ;
  int size ;
  struct urlpos *up ;
  struct urlpos *tmp___0 ;
  int flags ;
  int tmp___1 ;

  {
#line 366
  first = -1;
#line 368
  i = 0;
  {
#line 368
  while (1) {
    while_continue: /* CIL Label */ ;
#line 368
    if (! ((unsigned long )i < sizeof(tag_url_attributes) / sizeof(tag_url_attributes[0]))) {
#line 368
      goto while_break;
    }
#line 369
    if (tag_url_attributes[i].tagid == tagid) {
#line 373
      first = i;
#line 374
      goto while_break;
    }
#line 368
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 376
  tmp = __builtin_expect((long )(! (! (first != -1))), 1L);
  }
#line 376
  if (! tmp) {
    {
#line 376
    __assert_fail("first != -1", "html-url.c", 376U, "tag_find_urls");
    }
  }
#line 387
  attrind = 0;
  {
#line 387
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 387
    if (! (attrind < tag->nattrs)) {
#line 387
      goto while_break___0;
    }
#line 391
    link = (tag->attrs + attrind)->value;
#line 392
    size = (int )(sizeof(tag_url_attributes) / sizeof(tag_url_attributes[0]));
#line 398
    i = first;
    {
#line 398
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 398
      if (i < size) {
#line 398
        if (! (tag_url_attributes[i].tagid == tagid)) {
#line 398
          goto while_break___1;
        }
      } else {
#line 398
        goto while_break___1;
      }
      {
#line 400
      tmp___1 = strcasecmp((char const   *)(tag->attrs + attrind)->name, tag_url_attributes[i].attr_name);
      }
#line 400
      if (0 == tmp___1) {
        {
#line 403
        tmp___0 = append_url((char const   *)link, tag, attrind, ctx);
#line 403
        up = tmp___0;
        }
#line 404
        if (up) {
#line 406
          flags = tag_url_attributes[i].flags;
#line 407
          if (flags & 1) {
#line 408
            up->link_inline_p = 1U;
          }
#line 409
          if (flags & 2) {
#line 410
            up->link_expect_html = 1U;
          }
        }
      }
#line 398
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 387
    attrind ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 415
  return;
}
}
#line 419 "html-url.c"
static void tag_handle_base(int tagid , struct taginfo *tag , struct map_context *ctx ) 
{ 
  struct urlpos *base_urlpos ;
  int attrind ;
  char *newbase ;
  char *tmp ;

  {
  {
#line 424
  tmp = find_attr(tag, "href", & attrind);
#line 424
  newbase = tmp;
  }
#line 425
  if (! newbase) {
#line 426
    return;
  }
  {
#line 428
  base_urlpos = append_url((char const   *)newbase, tag, attrind, ctx);
  }
#line 429
  if (! base_urlpos) {
#line 430
    return;
  }
#line 431
  base_urlpos->ignore_when_downloading = 1U;
#line 432
  base_urlpos->link_base_p = 1U;
#line 434
  if (ctx->base) {
    {
#line 435
    free((void *)ctx->base);
    }
  }
#line 436
  if (ctx->parent_base) {
    {
#line 437
    ctx->base = uri_merge(ctx->parent_base, (char const   *)newbase);
    }
  } else {
    {
#line 439
    ctx->base = xstrdup_real((char const   *)newbase);
    }
  }
#line 440
  return;
}
}
#line 444 "html-url.c"
static void tag_handle_form(int tagid , struct taginfo *tag , struct map_context *ctx ) 
{ 
  int attrind ;
  char *action ;
  char *tmp ;
  struct urlpos *up ;
  struct urlpos *tmp___0 ;

  {
  {
#line 448
  tmp = find_attr(tag, "action", & attrind);
#line 448
  action = tmp;
  }
#line 449
  if (action) {
    {
#line 451
    tmp___0 = append_url((char const   *)action, tag, attrind, ctx);
#line 451
    up = tmp___0;
    }
#line 452
    if (up) {
#line 453
      up->ignore_when_downloading = 1U;
    }
  }
#line 455
  return;
}
}
#line 460 "html-url.c"
static void tag_handle_link(int tagid , struct taginfo *tag , struct map_context *ctx ) 
{ 
  int attrind ;
  char *href ;
  char *tmp ;
  struct urlpos *up ;
  struct urlpos *tmp___0 ;
  char *rel ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 464
  tmp = find_attr(tag, "href", & attrind);
#line 464
  href = tmp;
  }
#line 472
  if (href) {
    {
#line 474
    tmp___0 = append_url((char const   *)href, tag, attrind, ctx);
#line 474
    up = tmp___0;
    }
#line 475
    if (up) {
      {
#line 477
      tmp___1 = find_attr(tag, "rel", (int *)((void *)0));
#line 477
      rel = tmp___1;
      }
#line 478
      if (rel) {
        {
#line 478
        tmp___2 = strcasecmp((char const   *)rel, "stylesheet");
        }
#line 478
        if (0 == tmp___2) {
#line 481
          up->link_inline_p = 1U;
        } else {
          {
#line 478
          tmp___3 = strcasecmp((char const   *)rel, "shortcut icon");
          }
#line 478
          if (0 == tmp___3) {
#line 481
            up->link_inline_p = 1U;
          }
        }
      }
    }
  }
#line 484
  return;
}
}
#line 489 "html-url.c"
static void tag_handle_meta(int tagid , struct taginfo *tag , struct map_context *ctx ) 
{ 
  char *name ;
  char *tmp ;
  char *http_equiv ;
  char *tmp___0 ;
  struct urlpos *entry ;
  int attrind ;
  int timeout ;
  char *p ;
  char *refresh ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *content ;
  char *tmp___3 ;
  char *end ;
  char *tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 492
  tmp = find_attr(tag, "name", (int *)((void *)0));
#line 492
  name = tmp;
#line 493
  tmp___0 = find_attr(tag, "http-equiv", (int *)((void *)0));
#line 493
  http_equiv = tmp___0;
  }
#line 495
  if (http_equiv) {
    {
#line 495
    tmp___9 = strcasecmp((char const   *)http_equiv, "refresh");
    }
#line 495
    if (0 == tmp___9) {
      {
#line 508
      timeout = 0;
#line 511
      tmp___1 = find_attr(tag, "content", & attrind);
#line 511
      refresh = tmp___1;
      }
#line 512
      if (! refresh) {
#line 513
        return;
      }
#line 515
      p = refresh;
      {
#line 515
      while (1) {
        while_continue: /* CIL Label */ ;
#line 515
        if (! ((int const   )_sch_istable[(int )*p & 255] & 4)) {
#line 515
          goto while_break;
        }
#line 516
        timeout = (10 * timeout + (int )*p) - 48;
#line 515
        p ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 517
      tmp___2 = p;
#line 517
      p ++;
#line 517
      if ((int )*tmp___2 != 59) {
#line 518
        return;
      }
      {
#line 520
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 520
        if (! ((int const   )_sch_istable[(int )*p & 255] & 64)) {
#line 520
          goto while_break___0;
        }
#line 521
        p ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 522
      if ((int const   )_sch_toupper[(int )*p & 255] == 85) {
#line 522
        if ((int const   )_sch_toupper[(int )*(p + 1) & 255] == 82) {
#line 522
          if ((int const   )_sch_toupper[(int )*(p + 2) & 255] == 76) {
#line 522
            if (! ((int )*(p + 3) == 61)) {
#line 526
              return;
            }
          } else {
#line 526
            return;
          }
        } else {
#line 526
          return;
        }
      } else {
#line 526
        return;
      }
#line 527
      p += 4;
      {
#line 528
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 528
        if (! ((int const   )_sch_istable[(int )*p & 255] & 64)) {
#line 528
          goto while_break___1;
        }
#line 529
        p ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 531
      entry = append_url((char const   *)p, tag, attrind, ctx);
      }
#line 532
      if (entry) {
#line 534
        entry->link_refresh_p = 1U;
#line 535
        entry->refresh_timeout = timeout;
#line 536
        entry->link_expect_html = 1U;
      }
    } else {
#line 495
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 539
  if (name) {
    {
#line 539
    tmp___8 = strcasecmp((char const   *)name, "robots");
    }
#line 539
    if (0 == tmp___8) {
      {
#line 543
      tmp___3 = find_attr(tag, "content", (int *)((void *)0));
#line 543
      content = tmp___3;
      }
#line 544
      if (! content) {
#line 545
        return;
      }
      {
#line 546
      tmp___7 = strcasecmp((char const   *)content, "none");
      }
#line 546
      if (tmp___7) {
        {
#line 550
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 550
          if (! *content) {
#line 550
            goto while_break___2;
          }
          {
#line 554
          tmp___4 = strchr((char const   *)content, ',');
#line 554
          end = tmp___4;
          }
#line 555
          if (end) {
#line 556
            end ++;
          } else {
            {
#line 558
            tmp___5 = strlen((char const   *)content);
#line 558
            end = content + tmp___5;
            }
          }
          {
#line 559
          tmp___6 = strncasecmp((char const   *)content, "nofollow", (size_t )(end - content));
          }
#line 559
          if (! tmp___6) {
#line 560
            ctx->nofollow = 1;
          }
#line 561
          content = end;
        }
        while_break___2: /* CIL Label */ ;
        }
      } else {
#line 547
        ctx->nofollow = 1;
      }
    }
  }
#line 565
  return;
}
}
#line 570 "html-url.c"
static void collect_tags_mapper(struct taginfo *tag , void *arg ) 
{ 
  struct map_context *ctx ;
  struct known_tag *t ;
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 573
  ctx = (struct map_context *)arg;
#line 577
  tmp = hash_table_get((struct hash_table  const  *)interesting_tags, (void const   *)tag->name);
#line 577
  t = (struct known_tag *)tmp;
#line 578
  tmp___0 = __builtin_expect((long )(! (! ((unsigned long )t != (unsigned long )((void *)0)))),
                             1L);
  }
#line 578
  if (! tmp___0) {
    {
#line 578
    __assert_fail("t != ((void *)0)", "html-url.c", 578U, "collect_tags_mapper");
    }
  }
  {
#line 580
  (*(t->handler))(t->tagid, tag, ctx);
  }
#line 581
  return;
}
}
#line 587 "html-url.c"
struct urlpos *get_urls_html(char const   *file , char const   *url , int *meta_disallow_follow ) 
{ 
  struct file_memory *fm ;
  struct map_context ctx ;
  int flags ;
  int *tmp ;
  char *tmp___0 ;

  {
  {
#line 595
  fm = read_file(file);
  }
#line 596
  if (! fm) {
    {
#line 598
    tmp = __errno_location();
#line 598
    tmp___0 = strerror(*tmp);
#line 598
    logprintf((enum log_options )1, "%s: %s\n", file, tmp___0);
    }
#line 599
    return ((struct urlpos *)((void *)0));
  }
  {
#line 601
  while (1) {
    while_continue: /* CIL Label */ ;
#line 601
    if (opt.debug) {
      {
#line 601
      debug_logprintf("Loaded %s (size %ld).\n", file, fm->length);
      }
    }
#line 601
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 603
  ctx.text = fm->content;
#line 604
  ctx.tail = (struct urlpos *)((void *)0);
#line 604
  ctx.head = ctx.tail;
#line 605
  ctx.base = (char *)((void *)0);
#line 606
  if (url) {
#line 606
    ctx.parent_base = url;
  } else {
#line 606
    ctx.parent_base = (char const   *)opt.base_href;
  }
#line 607
  ctx.document_file = file;
#line 608
  ctx.nofollow = 0;
#line 610
  if (! interesting_tags) {
    {
#line 611
    init_interesting();
    }
  }
#line 617
  flags = 2;
#line 618
  if (opt.strict_comments) {
#line 619
    flags |= 1;
  }
  {
#line 621
  map_html_tags((char const   *)fm->content, (int )fm->length, & collect_tags_mapper,
                (void *)(& ctx), flags, (struct hash_table  const  *)interesting_tags,
                (struct hash_table  const  *)interesting_attributes);
  }
  {
#line 624
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 624
    if (opt.debug) {
      {
#line 624
      debug_logprintf("no-follow in %s: %d\n", file, ctx.nofollow);
      }
    }
#line 624
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 625
  if (meta_disallow_follow) {
#line 626
    *meta_disallow_follow = ctx.nofollow;
  }
  {
#line 628
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 628
    if (ctx.base) {
      {
#line 628
      free((void *)ctx.base);
      }
    }
#line 628
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 629
  read_file_free(fm);
  }
#line 630
  return (ctx.head);
}
}
#line 636 "html-url.c"
struct urlpos *get_urls_file(char const   *file ) 
{ 
  struct file_memory *fm ;
  struct urlpos *head ;
  struct urlpos *tail ;
  char const   *text ;
  char const   *text_end ;
  int *tmp ;
  char *tmp___0 ;
  int up_error_code ;
  char *url_text ;
  struct urlpos *entry ;
  struct url *url ;
  char const   *line_beg ;
  char const   *line_end ;
  void *tmp___1 ;
  char *merged ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  void *tmp___4 ;

  {
  {
#line 644
  fm = read_file(file);
  }
#line 645
  if (! fm) {
    {
#line 647
    tmp = __errno_location();
#line 647
    tmp___0 = strerror(*tmp);
#line 647
    logprintf((enum log_options )1, "%s: %s\n", file, tmp___0);
    }
#line 648
    return ((struct urlpos *)((void *)0));
  }
  {
#line 650
  while (1) {
    while_continue: /* CIL Label */ ;
#line 650
    if (opt.debug) {
      {
#line 650
      debug_logprintf("Loaded %s (size %ld).\n", file, fm->length);
      }
    }
#line 650
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 652
  tail = (struct urlpos *)((void *)0);
#line 652
  head = tail;
#line 653
  text = (char const   *)fm->content;
#line 654
  text_end = (char const   *)(fm->content + fm->length);
  {
#line 655
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 655
    if (! ((unsigned long )text < (unsigned long )text_end)) {
#line 655
      goto while_break___0;
    }
    {
#line 662
    line_beg = text;
#line 663
    tmp___1 = memchr((void const   *)text, '\n', (size_t )(text_end - text));
#line 663
    line_end = (char const   *)tmp___1;
    }
#line 664
    if (! line_end) {
#line 665
      line_end = text_end;
    } else {
#line 667
      line_end ++;
    }
#line 668
    text = line_end;
    {
#line 671
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 671
      if ((unsigned long )line_beg < (unsigned long )line_end) {
#line 671
        if (! ((int const   )_sch_istable[(int const   )*line_beg & 255] & 64)) {
#line 671
          goto while_break___1;
        }
      } else {
#line 671
        goto while_break___1;
      }
#line 672
      line_beg ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 673
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 673
      if ((unsigned long )line_end > (unsigned long )line_beg) {
#line 673
        if (! ((int const   )_sch_istable[(int const   )*(line_end - 1) & 255] & 64)) {
#line 673
          goto while_break___2;
        }
      } else {
#line 673
        goto while_break___2;
      }
#line 674
      line_end --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 676
    if ((unsigned long )line_beg == (unsigned long )line_end) {
#line 677
      goto while_continue___0;
    }
    {
#line 683
    url_text = strdupdelim(line_beg, line_end);
    }
#line 685
    if (opt.base_href) {
      {
#line 688
      tmp___2 = uri_merge((char const   *)opt.base_href, (char const   *)url_text);
#line 688
      merged = tmp___2;
#line 689
      free((void *)url_text);
#line 690
      url_text = merged;
      }
    }
    {
#line 693
    url = url_parse((char const   *)url_text, & up_error_code);
    }
#line 694
    if (! url) {
      {
#line 696
      tmp___3 = url_error(up_error_code);
#line 696
      logprintf((enum log_options )1, "%s: Invalid URL %s: %s\n", file, url_text,
                tmp___3);
#line 698
      free((void *)url_text);
      }
#line 699
      goto while_continue___0;
    }
    {
#line 701
    free((void *)url_text);
#line 703
    tmp___4 = xmalloc_real((size_t )sizeof(struct urlpos ));
#line 703
    entry = (struct urlpos *)tmp___4;
#line 704
    memset((void *)entry, 0, (size_t )sizeof(*entry));
#line 705
    entry->next = (struct urlpos *)((void *)0);
#line 706
    entry->url = url;
    }
#line 708
    if (! head) {
#line 709
      head = entry;
    } else {
#line 711
      tail->next = entry;
    }
#line 712
    tail = entry;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 714
  read_file_free(fm);
  }
#line 715
  return (head);
}
}
#line 718 "html-url.c"
void cleanup_html_url(void) 
{ 


  {
  {
#line 721
  while (1) {
    while_continue: /* CIL Label */ ;
#line 721
    if (interesting_tags) {
      {
#line 721
      free((void *)interesting_tags);
      }
    }
#line 721
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 722
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 722
    if (interesting_attributes) {
      {
#line 722
      free((void *)interesting_attributes);
      }
    }
#line 722
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 723
  return;
}
}
#line 278 "html-parse.c"
static void convert_and_copy(struct pool *pool , char const   *beg , char const   *end ,
                             int flags ) 
{ 
  int old_tail ;
  int size ;
  char const   *from ;
  char *to ;
  long ga_needed_size ;
  long ga_newsize ;
  void *tmp ;
  void *ga_new ;
  void *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char const   *save ;
  int remain ;
  int numeric ;
  int digits ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;
  char const   *tmp___16 ;
  long tmp___17 ;
  char PAC_char ;
  long ga_needed_size___0 ;
  long ga_newsize___0 ;
  void *tmp___18 ;
  void *ga_new___0 ;
  void *tmp___19 ;
  int tmp___20 ;
  char const   *PA_beg ;
  int PA_size ;
  long ga_needed_size___1 ;
  long ga_newsize___1 ;
  void *tmp___21 ;
  void *ga_new___1 ;
  void *tmp___22 ;
  char PAC_char___0 ;
  long ga_needed_size___2 ;
  long ga_newsize___2 ;
  void *tmp___23 ;
  void *ga_new___2 ;
  void *tmp___24 ;
  int tmp___25 ;
  char *p ;

  {
#line 281
  old_tail = pool->tail;
#line 287
  if (flags & 4) {
    {
#line 289
    while (1) {
      while_continue: /* CIL Label */ ;
#line 289
      if ((unsigned long )beg < (unsigned long )end) {
#line 289
        if (! ((int const   )_sch_istable[(int const   )*beg & 255] & 64)) {
#line 289
          goto while_break;
        }
      } else {
#line 289
        goto while_break;
      }
#line 290
      beg ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 291
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 291
      if ((unsigned long )end > (unsigned long )beg) {
#line 291
        if (! ((int const   )_sch_istable[(int const   )*(end + -1) & 255] & 64)) {
#line 291
          goto while_break___0;
        }
      } else {
#line 291
        goto while_break___0;
      }
#line 292
      end --;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 294
  size = (int )(end - beg);
#line 296
  if (flags & 2) {
#line 305
    from = beg;
    {
#line 308
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 308
      ga_needed_size = (long )pool->tail + (end - beg);
#line 308
      ga_newsize = (long )pool->size;
      {
#line 308
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 308
        if (! (ga_newsize < ga_needed_size)) {
#line 308
          goto while_break___2;
        }
#line 308
        ga_newsize <<= 1;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 308
      if (ga_newsize != (long )pool->size) {
#line 308
        if (pool->resized) {
          {
#line 308
          tmp = xrealloc_real((void *)pool->contents, (size_t )((unsigned long )ga_newsize * sizeof(char )));
#line 308
          pool->contents = (char *)tmp;
          }
        } else {
          {
#line 308
          tmp___0 = xmalloc_real((size_t )((unsigned long )ga_newsize * sizeof(char )));
#line 308
          ga_new = tmp___0;
#line 308
          memcpy((void */* __restrict  */)ga_new, (void const   */* __restrict  */)pool->contents,
                 (size_t )((unsigned long )pool->size * sizeof(char )));
#line 308
          pool->contents = (char *)ga_new;
#line 308
          pool->resized = 1;
          }
        }
#line 308
        pool->size = (int )ga_newsize;
      }
#line 308
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 309
    to = pool->contents + pool->tail;
    {
#line 311
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 311
      if (! ((unsigned long )from < (unsigned long )end)) {
#line 311
        goto while_break___3;
      }
#line 313
      if ((int const   )*from != 38) {
#line 314
        tmp___1 = to;
#line 314
        to ++;
#line 314
        tmp___2 = from;
#line 314
        from ++;
#line 314
        *tmp___1 = (char )*tmp___2;
      } else {
#line 317
        save = from;
#line 320
        from ++;
#line 320
        if ((unsigned long )from == (unsigned long )end) {
#line 321
          goto lose;
        }
#line 322
        remain = (int )(end - from);
#line 325
        if ((int const   )*from == 35) {
#line 327
          numeric = 0;
#line 327
          digits = 0;
#line 328
          from ++;
#line 329
          if ((int const   )*from == 120) {
#line 331
            from ++;
            {
#line 332
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 332
              if ((unsigned long )from < (unsigned long )end) {
#line 332
                if (! ((int const   )_sch_istable[(int const   )*from & 255] & 256)) {
#line 332
                  goto while_break___4;
                }
              } else {
#line 332
                goto while_break___4;
              }
#line 333
              if ((int const   )*from < 65) {
#line 333
                tmp___3 = (int const   )*from - 48;
              } else {
#line 333
                tmp___3 = ((int const   )_sch_toupper[(int const   )*from & 255] - 65) + 10;
              }
#line 333
              numeric = (numeric << 4) + (int )tmp___3;
#line 332
              from ++;
#line 332
              digits ++;
            }
            while_break___4: /* CIL Label */ ;
            }
          } else {
            {
#line 337
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 337
              if ((unsigned long )from < (unsigned long )end) {
#line 337
                if (! ((int const   )_sch_istable[(int const   )*from & 255] & 4)) {
#line 337
                  goto while_break___5;
                }
              } else {
#line 337
                goto while_break___5;
              }
#line 338
              numeric = numeric * 10 + (int )((int const   )*from - 48);
#line 337
              from ++;
#line 337
              digits ++;
            }
            while_break___5: /* CIL Label */ ;
            }
          }
#line 340
          if (! digits) {
#line 341
            goto lose;
          }
#line 342
          numeric &= 255;
#line 343
          tmp___4 = to;
#line 343
          to ++;
#line 343
          *tmp___4 = (char )numeric;
        } else
#line 350
        if ((unsigned long )remain >= sizeof("lt") - 1UL) {
          {
#line 350
          tmp___14 = memcmp((void const   *)from, (void const   *)"lt", (size_t )(sizeof("lt") - 1UL));
          }
#line 350
          if (0 == tmp___14) {
#line 350
            if ((int const   )*((from + sizeof("lt")) - 1) == 59) {
#line 351
              tmp___5 = to;
#line 351
              to ++;
#line 351
              *tmp___5 = (char )'<';
#line 351
              from += 2;
            } else
#line 350
            if ((unsigned long )remain == sizeof("lt") - 1UL) {
#line 351
              tmp___5 = to;
#line 351
              to ++;
#line 351
              *tmp___5 = (char )'<';
#line 351
              from += 2;
            } else
#line 350
            if (! ((int const   )_sch_istable[(int const   )*((from + sizeof("lt")) - 1) & 255] & 140)) {
#line 351
              tmp___5 = to;
#line 351
              to ++;
#line 351
              *tmp___5 = (char )'<';
#line 351
              from += 2;
            } else {
#line 350
              goto _L___6;
            }
          } else {
#line 350
            goto _L___6;
          }
        } else
        _L___6: /* CIL Label */ 
#line 352
        if ((unsigned long )remain >= sizeof("gt") - 1UL) {
          {
#line 352
          tmp___13 = memcmp((void const   *)from, (void const   *)"gt", (size_t )(sizeof("gt") - 1UL));
          }
#line 352
          if (0 == tmp___13) {
#line 352
            if ((int const   )*((from + sizeof("gt")) - 1) == 59) {
#line 353
              tmp___6 = to;
#line 353
              to ++;
#line 353
              *tmp___6 = (char )'>';
#line 353
              from += 2;
            } else
#line 352
            if ((unsigned long )remain == sizeof("gt") - 1UL) {
#line 353
              tmp___6 = to;
#line 353
              to ++;
#line 353
              *tmp___6 = (char )'>';
#line 353
              from += 2;
            } else
#line 352
            if (! ((int const   )_sch_istable[(int const   )*((from + sizeof("gt")) - 1) & 255] & 140)) {
#line 353
              tmp___6 = to;
#line 353
              to ++;
#line 353
              *tmp___6 = (char )'>';
#line 353
              from += 2;
            } else {
#line 352
              goto _L___4;
            }
          } else {
#line 352
            goto _L___4;
          }
        } else
        _L___4: /* CIL Label */ 
#line 354
        if ((unsigned long )remain >= sizeof("amp") - 1UL) {
          {
#line 354
          tmp___12 = memcmp((void const   *)from, (void const   *)"amp", (size_t )(sizeof("amp") - 1UL));
          }
#line 354
          if (0 == tmp___12) {
#line 354
            if ((int const   )*((from + sizeof("amp")) - 1) == 59) {
#line 355
              tmp___7 = to;
#line 355
              to ++;
#line 355
              *tmp___7 = (char )'&';
#line 355
              from += 3;
            } else
#line 354
            if ((unsigned long )remain == sizeof("amp") - 1UL) {
#line 355
              tmp___7 = to;
#line 355
              to ++;
#line 355
              *tmp___7 = (char )'&';
#line 355
              from += 3;
            } else
#line 354
            if (! ((int const   )_sch_istable[(int const   )*((from + sizeof("amp")) - 1) & 255] & 140)) {
#line 355
              tmp___7 = to;
#line 355
              to ++;
#line 355
              *tmp___7 = (char )'&';
#line 355
              from += 3;
            } else {
#line 354
              goto _L___2;
            }
          } else {
#line 354
            goto _L___2;
          }
        } else
        _L___2: /* CIL Label */ 
#line 356
        if ((unsigned long )remain >= sizeof("quot") - 1UL) {
          {
#line 356
          tmp___11 = memcmp((void const   *)from, (void const   *)"quot", (size_t )(sizeof("quot") - 1UL));
          }
#line 356
          if (0 == tmp___11) {
#line 356
            if ((int const   )*((from + sizeof("quot")) - 1) == 59) {
#line 357
              tmp___8 = to;
#line 357
              to ++;
#line 357
              *tmp___8 = (char )'\"';
#line 357
              from += 4;
            } else
#line 356
            if ((unsigned long )remain == sizeof("quot") - 1UL) {
#line 357
              tmp___8 = to;
#line 357
              to ++;
#line 357
              *tmp___8 = (char )'\"';
#line 357
              from += 4;
            } else
#line 356
            if (! ((int const   )_sch_istable[(int const   )*((from + sizeof("quot")) - 1) & 255] & 140)) {
#line 357
              tmp___8 = to;
#line 357
              to ++;
#line 357
              *tmp___8 = (char )'\"';
#line 357
              from += 4;
            } else {
#line 356
              goto _L___0;
            }
          } else {
#line 356
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 362
        if ((unsigned long )remain >= sizeof("nbsp") - 1UL) {
          {
#line 362
          tmp___10 = memcmp((void const   *)from, (void const   *)"nbsp", (size_t )(sizeof("nbsp") - 1UL));
          }
#line 362
          if (0 == tmp___10) {
#line 362
            if ((int const   )*((from + sizeof("nbsp")) - 1) == 59) {
#line 363
              tmp___9 = to;
#line 363
              to ++;
#line 363
              *tmp___9 = (char)-96;
#line 363
              from += 4;
            } else
#line 362
            if ((unsigned long )remain == sizeof("nbsp") - 1UL) {
#line 363
              tmp___9 = to;
#line 363
              to ++;
#line 363
              *tmp___9 = (char)-96;
#line 363
              from += 4;
            } else
#line 362
            if (! ((int const   )_sch_istable[(int const   )*((from + sizeof("nbsp")) - 1) & 255] & 140)) {
#line 363
              tmp___9 = to;
#line 363
              to ++;
#line 363
              *tmp___9 = (char)-96;
#line 363
              from += 4;
            } else {
#line 365
              goto lose;
            }
          } else {
#line 365
            goto lose;
          }
        } else {
#line 365
          goto lose;
        }
#line 370
        if ((unsigned long )from < (unsigned long )end) {
#line 370
          if ((int const   )*from == 59) {
#line 371
            from ++;
          }
        }
#line 372
        goto while_continue___3;
        lose: 
#line 376
        from = save;
#line 377
        tmp___15 = to;
#line 377
        to ++;
#line 377
        tmp___16 = from;
#line 377
        from ++;
#line 377
        *tmp___15 = (char )*tmp___16;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 382
    tmp___17 = __builtin_expect((long )(! (! (to - (pool->contents + pool->tail) <= end - beg))),
                                1L);
    }
#line 382
    if (! tmp___17) {
      {
#line 382
      __assert_fail("to - (pool->contents + pool->tail) <= end - beg", "html-parse.c",
                    382U, "convert_and_copy");
      }
    }
#line 386
    pool->tail = (int )(to - pool->contents);
    {
#line 387
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 387
      PAC_char = (char )'\000';
      {
#line 387
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 387
        ga_needed_size___0 = (long )(pool->tail + 1);
#line 387
        ga_newsize___0 = (long )pool->size;
        {
#line 387
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 387
          if (! (ga_newsize___0 < ga_needed_size___0)) {
#line 387
            goto while_break___8;
          }
#line 387
          ga_newsize___0 <<= 1;
        }
        while_break___8: /* CIL Label */ ;
        }
#line 387
        if (ga_newsize___0 != (long )pool->size) {
#line 387
          if (pool->resized) {
            {
#line 387
            tmp___18 = xrealloc_real((void *)pool->contents, (size_t )((unsigned long )ga_newsize___0 * sizeof(char )));
#line 387
            pool->contents = (char *)tmp___18;
            }
          } else {
            {
#line 387
            tmp___19 = xmalloc_real((size_t )((unsigned long )ga_newsize___0 * sizeof(char )));
#line 387
            ga_new___0 = tmp___19;
#line 387
            memcpy((void */* __restrict  */)ga_new___0, (void const   */* __restrict  */)pool->contents,
                   (size_t )((unsigned long )pool->size * sizeof(char )));
#line 387
            pool->contents = (char *)ga_new___0;
#line 387
            pool->resized = 1;
            }
          }
#line 387
          pool->size = (int )ga_newsize___0;
        }
#line 387
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 387
      tmp___20 = pool->tail;
#line 387
      (pool->tail) ++;
#line 387
      *(pool->contents + tmp___20) = PAC_char;
#line 387
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
  } else {
    {
#line 392
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 392
      PA_beg = beg;
#line 392
      PA_size = (int )(end - PA_beg);
      {
#line 392
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 392
        ga_needed_size___1 = (long )(pool->tail + PA_size);
#line 392
        ga_newsize___1 = (long )pool->size;
        {
#line 392
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 392
          if (! (ga_newsize___1 < ga_needed_size___1)) {
#line 392
            goto while_break___11;
          }
#line 392
          ga_newsize___1 <<= 1;
        }
        while_break___11: /* CIL Label */ ;
        }
#line 392
        if (ga_newsize___1 != (long )pool->size) {
#line 392
          if (pool->resized) {
            {
#line 392
            tmp___21 = xrealloc_real((void *)pool->contents, (size_t )((unsigned long )ga_newsize___1 * sizeof(char )));
#line 392
            pool->contents = (char *)tmp___21;
            }
          } else {
            {
#line 392
            tmp___22 = xmalloc_real((size_t )((unsigned long )ga_newsize___1 * sizeof(char )));
#line 392
            ga_new___1 = tmp___22;
#line 392
            memcpy((void */* __restrict  */)ga_new___1, (void const   */* __restrict  */)pool->contents,
                   (size_t )((unsigned long )pool->size * sizeof(char )));
#line 392
            pool->contents = (char *)ga_new___1;
#line 392
            pool->resized = 1;
            }
          }
#line 392
          pool->size = (int )ga_newsize___1;
        }
#line 392
        goto while_break___10;
      }
      while_break___10: /* CIL Label */ ;
      }
      {
#line 392
      memcpy((void */* __restrict  */)(pool->contents + pool->tail), (void const   */* __restrict  */)PA_beg,
             (size_t )PA_size);
#line 392
      pool->tail += PA_size;
      }
#line 392
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
    {
#line 393
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 393
      PAC_char___0 = (char )'\000';
      {
#line 393
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 393
        ga_needed_size___2 = (long )(pool->tail + 1);
#line 393
        ga_newsize___2 = (long )pool->size;
        {
#line 393
        while (1) {
          while_continue___14: /* CIL Label */ ;
#line 393
          if (! (ga_newsize___2 < ga_needed_size___2)) {
#line 393
            goto while_break___14;
          }
#line 393
          ga_newsize___2 <<= 1;
        }
        while_break___14: /* CIL Label */ ;
        }
#line 393
        if (ga_newsize___2 != (long )pool->size) {
#line 393
          if (pool->resized) {
            {
#line 393
            tmp___23 = xrealloc_real((void *)pool->contents, (size_t )((unsigned long )ga_newsize___2 * sizeof(char )));
#line 393
            pool->contents = (char *)tmp___23;
            }
          } else {
            {
#line 393
            tmp___24 = xmalloc_real((size_t )((unsigned long )ga_newsize___2 * sizeof(char )));
#line 393
            ga_new___2 = tmp___24;
#line 393
            memcpy((void */* __restrict  */)ga_new___2, (void const   */* __restrict  */)pool->contents,
                   (size_t )((unsigned long )pool->size * sizeof(char )));
#line 393
            pool->contents = (char *)ga_new___2;
#line 393
            pool->resized = 1;
            }
          }
#line 393
          pool->size = (int )ga_newsize___2;
        }
#line 393
        goto while_break___13;
      }
      while_break___13: /* CIL Label */ ;
      }
#line 393
      tmp___25 = pool->tail;
#line 393
      (pool->tail) ++;
#line 393
      *(pool->contents + tmp___25) = PAC_char___0;
#line 393
      goto while_break___12;
    }
    while_break___12: /* CIL Label */ ;
    }
  }
#line 396
  if (flags & 1) {
#line 398
    p = pool->contents + old_tail;
    {
#line 399
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 399
      if (! *p) {
#line 399
        goto while_break___15;
      }
#line 400
      *p = (char )_sch_tolower[(int )*p & 255];
#line 399
      p ++;
    }
    while_break___15: /* CIL Label */ ;
    }
  }
#line 402
  return;
}
}
#line 445 "html-parse.c"
static char const   *advance_declaration(char const   *beg , char const   *end ) 
{ 
  char const   *p ;
  char quote_char ;
  char ch ;
  enum __anonenum_state_26 state ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  long tmp___7 ;
  char const   *tmp___8 ;
  long tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  long tmp___13 ;
  char const   *tmp___14 ;
  char const   *tmp___15 ;

  {
#line 448
  p = beg;
#line 449
  quote_char = (char )'\000';
#line 452
  state = (enum __anonenum_state_26 )2;
#line 468
  if ((unsigned long )beg == (unsigned long )end) {
#line 469
    return (beg);
  }
#line 470
  tmp = p;
#line 470
  p ++;
#line 470
  ch = (char )*tmp;
  {
#line 475
  while (1) {
    while_continue: /* CIL Label */ ;
#line 475
    if ((unsigned int )state != 0U) {
#line 475
      if (! ((unsigned int )state != 1U)) {
#line 475
        goto while_break;
      }
    } else {
#line 475
      goto while_break;
    }
#line 477
    if ((unsigned long )p == (unsigned long )end) {
#line 478
      state = (enum __anonenum_state_26 )1;
    }
    {
#line 482
    if ((unsigned int )state == 1U) {
#line 482
      goto case_1;
    }
#line 482
    if ((unsigned int )state == 0U) {
#line 482
      goto case_1;
    }
#line 484
    if ((unsigned int )state == 2U) {
#line 484
      goto case_2;
    }
#line 493
    if ((unsigned int )state == 3U) {
#line 493
      goto case_3;
    }
#line 520
    if ((unsigned int )state == 4U) {
#line 520
      goto case_4;
    }
#line 528
    if ((unsigned int )state == 10U) {
#line 528
      goto case_10___0;
    }
#line 538
    if ((unsigned int )state == 11U) {
#line 538
      goto case_11;
    }
#line 544
    if ((unsigned int )state == 12U) {
#line 544
      goto case_12;
    }
#line 549
    if ((unsigned int )state == 5U) {
#line 549
      goto case_5;
    }
#line 554
    if ((unsigned int )state == 6U) {
#line 554
      goto case_6;
    }
#line 565
    if ((unsigned int )state == 7U) {
#line 565
      goto case_7;
    }
#line 576
    if ((unsigned int )state == 8U) {
#line 576
      goto case_8;
    }
#line 581
    if ((unsigned int )state == 9U) {
#line 581
      goto case_9___0;
    }
#line 479
    goto switch_break;
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 483
    goto switch_break;
    case_2: /* CIL Label */ 
#line 485
    if ((int )ch == 33) {
#line 487
      tmp___0 = p;
#line 487
      p ++;
#line 487
      ch = (char )*tmp___0;
#line 488
      state = (enum __anonenum_state_26 )3;
    } else {
#line 491
      state = (enum __anonenum_state_26 )1;
    }
#line 492
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 496
    if ((int )ch == 45) {
#line 496
      goto case_45;
    }
#line 502
    if ((int )ch == 10) {
#line 502
      goto case_10;
    }
#line 502
    if ((int )ch == 13) {
#line 502
      goto case_10;
    }
#line 502
    if ((int )ch == 9) {
#line 502
      goto case_10;
    }
#line 502
    if ((int )ch == 32) {
#line 502
      goto case_10;
    }
#line 505
    if ((int )ch == 62) {
#line 505
      goto case_62;
    }
#line 509
    if ((int )ch == 34) {
#line 509
      goto case_34;
    }
#line 509
    if ((int )ch == 39) {
#line 509
      goto case_34;
    }
#line 512
    goto switch_default;
    case_45: /* CIL Label */ 
#line 497
    state = (enum __anonenum_state_26 )5;
#line 498
    goto switch_break___0;
    case_10: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 503
    tmp___1 = p;
#line 503
    p ++;
#line 503
    ch = (char )*tmp___1;
#line 504
    goto switch_break___0;
    case_62: /* CIL Label */ 
#line 506
    state = (enum __anonenum_state_26 )0;
#line 507
    goto switch_break___0;
    case_34: /* CIL Label */ 
    case_39: /* CIL Label */ 
#line 510
    state = (enum __anonenum_state_26 )10;
#line 511
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 513
    if ((int )ch > 32) {
#line 513
      if ((int )ch < 127) {
#line 513
        if ((int )ch != 61) {
#line 513
          if ((int )ch != 62) {
#line 513
            if ((int )ch != 47) {
#line 514
              state = (enum __anonenum_state_26 )4;
            } else {
#line 516
              state = (enum __anonenum_state_26 )1;
            }
          } else {
#line 516
            state = (enum __anonenum_state_26 )1;
          }
        } else {
#line 516
          state = (enum __anonenum_state_26 )1;
        }
      } else {
#line 516
        state = (enum __anonenum_state_26 )1;
      }
    } else {
#line 516
      state = (enum __anonenum_state_26 )1;
    }
#line 517
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 519
    goto switch_break;
    case_4: /* CIL Label */ 
#line 521
    if ((int )ch == 45) {
#line 522
      state = (enum __anonenum_state_26 )5;
    } else
#line 523
    if ((int )ch > 32) {
#line 523
      if ((int )ch < 127) {
#line 523
        if ((int )ch != 61) {
#line 523
          if ((int )ch != 62) {
#line 523
            if ((int )ch != 47) {
#line 524
              tmp___2 = p;
#line 524
              p ++;
#line 524
              ch = (char )*tmp___2;
            } else {
#line 526
              state = (enum __anonenum_state_26 )3;
            }
          } else {
#line 526
            state = (enum __anonenum_state_26 )3;
          }
        } else {
#line 526
          state = (enum __anonenum_state_26 )3;
        }
      } else {
#line 526
        state = (enum __anonenum_state_26 )3;
      }
    } else {
#line 526
      state = (enum __anonenum_state_26 )3;
    }
#line 527
    goto switch_break;
    case_10___0: /* CIL Label */ 
#line 531
    if ((int )ch == 39) {
#line 531
      tmp___3 = 1;
    } else
#line 531
    if ((int )ch == 34) {
#line 531
      tmp___3 = 1;
    } else {
#line 531
      tmp___3 = 0;
    }
    {
#line 531
    tmp___4 = __builtin_expect((long )tmp___3, 1L);
    }
#line 531
    if (! tmp___4) {
      {
#line 531
      __assert_fail("ch == \'\\\'\' || ch == 0x22", "html-parse.c", 531U, "advance_declaration");
      }
    }
#line 532
    quote_char = ch;
#line 535
    tmp___5 = p;
#line 535
    p ++;
#line 535
    ch = (char )*tmp___5;
#line 536
    state = (enum __anonenum_state_26 )11;
#line 537
    goto switch_break;
    case_11: /* CIL Label */ 
#line 539
    if ((int )ch == (int )quote_char) {
#line 540
      state = (enum __anonenum_state_26 )12;
    } else {
#line 542
      tmp___6 = p;
#line 542
      p ++;
#line 542
      ch = (char )*tmp___6;
    }
#line 543
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 545
    tmp___7 = __builtin_expect((long )(! (! ((int )ch == (int )quote_char))), 1L);
    }
#line 545
    if (! tmp___7) {
      {
#line 545
      __assert_fail("ch == quote_char", "html-parse.c", 545U, "advance_declaration");
      }
    }
#line 546
    tmp___8 = p;
#line 546
    p ++;
#line 546
    ch = (char )*tmp___8;
#line 547
    state = (enum __anonenum_state_26 )3;
#line 548
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 550
    tmp___9 = __builtin_expect((long )(! (! ((int )ch == 45))), 1L);
    }
#line 550
    if (! tmp___9) {
      {
#line 550
      __assert_fail("ch == \'-\'", "html-parse.c", 550U, "advance_declaration");
      }
    }
#line 551
    tmp___10 = p;
#line 551
    p ++;
#line 551
    ch = (char )*tmp___10;
#line 552
    state = (enum __anonenum_state_26 )6;
#line 553
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 557
    if ((int )ch == 45) {
#line 557
      goto case_45___0;
    }
#line 561
    goto switch_default___0;
    case_45___0: /* CIL Label */ 
#line 558
    tmp___11 = p;
#line 558
    p ++;
#line 558
    ch = (char )*tmp___11;
#line 559
    state = (enum __anonenum_state_26 )7;
#line 560
    goto switch_break___1;
    switch_default___0: /* CIL Label */ 
#line 562
    state = (enum __anonenum_state_26 )1;
    switch_break___1: /* CIL Label */ ;
    }
#line 564
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 568
    if ((int )ch == 45) {
#line 568
      goto case_45___1;
    }
#line 571
    goto switch_default___1;
    case_45___1: /* CIL Label */ 
#line 569
    state = (enum __anonenum_state_26 )8;
#line 570
    goto switch_break___2;
    switch_default___1: /* CIL Label */ 
#line 572
    tmp___12 = p;
#line 572
    p ++;
#line 572
    ch = (char )*tmp___12;
#line 573
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
#line 575
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 577
    tmp___13 = __builtin_expect((long )(! (! ((int )ch == 45))), 1L);
    }
#line 577
    if (! tmp___13) {
      {
#line 577
      __assert_fail("ch == \'-\'", "html-parse.c", 577U, "advance_declaration");
      }
    }
#line 578
    tmp___14 = p;
#line 578
    p ++;
#line 578
    ch = (char )*tmp___14;
#line 579
    state = (enum __anonenum_state_26 )9;
#line 580
    goto switch_break;
    case_9___0: /* CIL Label */ 
    {
#line 584
    if ((int )ch == 45) {
#line 584
      goto case_45___2;
    }
#line 588
    goto switch_default___2;
    case_45___2: /* CIL Label */ 
#line 585
    tmp___15 = p;
#line 585
    p ++;
#line 585
    ch = (char )*tmp___15;
#line 586
    state = (enum __anonenum_state_26 )3;
#line 587
    goto switch_break___3;
    switch_default___2: /* CIL Label */ 
#line 589
    state = (enum __anonenum_state_26 )7;
#line 590
    goto switch_break___3;
    switch_break___3: /* CIL Label */ ;
    }
#line 592
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 596
  if ((unsigned int )state == 1U) {
#line 601
    return (beg + 1);
  }
#line 603
  return (p);
}
}
#line 610 "html-parse.c"
static char const   *find_comment_end(char const   *beg , char const   *end ) 
{ 
  char const   *p ;

  {
#line 617
  p = beg - 1;
  {
#line 619
  while (1) {
    while_continue: /* CIL Label */ ;
#line 619
    p += 3;
#line 619
    if (! ((unsigned long )p < (unsigned long )end)) {
#line 619
      goto while_break;
    }
    {
#line 622
    if ((int const   )*(p + 0) == 62) {
#line 622
      goto case_62;
    }
#line 626
    if ((int const   )*(p + 0) == 45) {
#line 626
      goto at_dash;
    }
#line 620
    goto switch_break;
    case_62: /* CIL Label */ 
#line 623
    if ((int const   )*(p + -1) == 45) {
#line 623
      if ((int const   )*(p + -2) == 45) {
#line 624
        return (p + 1);
      }
    }
#line 625
    goto switch_break;
    at_dash: 
    case_45: /* CIL Label */ 
#line 628
    if ((int const   )*(p + -1) == 45) {
      at_dash_dash: 
#line 631
      p ++;
#line 631
      if ((unsigned long )p == (unsigned long )end) {
#line 631
        return ((char const   *)((void *)0));
      }
      {
#line 634
      if ((int const   )*(p + 0) == 62) {
#line 634
        goto case_62___0;
      }
#line 635
      if ((int const   )*(p + 0) == 45) {
#line 635
        goto case_45___0;
      }
#line 632
      goto switch_break___0;
      case_62___0: /* CIL Label */ 
#line 634
      return (p + 1);
      case_45___0: /* CIL Label */ 
#line 635
      goto at_dash_dash;
      switch_break___0: /* CIL Label */ ;
      }
    } else {
#line 640
      p += 2;
#line 640
      if ((unsigned long )p >= (unsigned long )end) {
#line 640
        return ((char const   *)((void *)0));
      }
      {
#line 643
      if ((int const   )*(p + 0) == 62) {
#line 643
        goto case_62___1;
      }
#line 647
      if ((int const   )*(p + 0) == 45) {
#line 647
        goto case_45___1;
      }
#line 641
      goto switch_break___1;
      case_62___1: /* CIL Label */ 
#line 644
      if ((int const   )*(p + -1) == 45) {
#line 645
        return (p + 1);
      }
#line 646
      goto switch_break___1;
      case_45___1: /* CIL Label */ 
#line 648
      goto at_dash;
      switch_break___1: /* CIL Label */ ;
      }
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 652
  return ((char const   *)((void *)0));
}
}
#line 658 "html-parse.c"
static int name_allowed(struct hash_table  const  *ht , char const   *b , char const   *e ) 
{ 
  char *copy ;
  char const   *BTA_beg ;
  int BTA_len ;
  char **BTA_dest ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 662
  if (! ht) {
#line 663
    return (1);
  }
  {
#line 664
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 664
    BTA_beg = b;
#line 664
    BTA_len = (int )(e - BTA_beg);
#line 664
    BTA_dest = & copy;
#line 664
    tmp = __builtin_alloca((unsigned long )(BTA_len + 1));
#line 664
    *BTA_dest = (char *)tmp;
#line 664
    memcpy((void */* __restrict  */)*BTA_dest, (void const   */* __restrict  */)BTA_beg,
           (size_t )BTA_len);
#line 664
    *(*BTA_dest + BTA_len) = (char )'\000';
    }
#line 664
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 665
  tmp___0 = hash_table_get(ht, (void const   *)copy);
  }
#line 665
  return ((unsigned long )tmp___0 != (unsigned long )((void *)0));
}
}
#line 713 "html-parse.c"
void map_html_tags(char const   *text , int size , void (*mapfun)(struct taginfo * ,
                                                                  void * ) , void *maparg ,
                   int flags , struct hash_table  const  *allowed_tags , struct hash_table  const  *allowed_attributes ) 
{ 
  char pool_initial_storage[256] ;
  struct pool pool ;
  char const   *p ;
  char const   *end ;
  struct attr_pair attr_pair_initial_storage[8] ;
  int attr_pair_size ;
  int attr_pair_resized ;
  struct attr_pair *pairs ;
  struct pool *P ;
  int nattrs ;
  int end_tag ;
  char const   *tag_name_begin ;
  char const   *tag_name_end ;
  char const   *tag_start_position ;
  int uninteresting_tag ;
  void *tmp ;
  char const   *comment_end ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char const   *attr_name_begin ;
  char const   *attr_name_end ;
  char const   *attr_value_begin ;
  char const   *attr_value_end ;
  char const   *attr_raw_value_begin ;
  char const   *attr_raw_value_end ;
  int operation ;
  int newline_seen ;
  char quote_char ;
  int tmp___2 ;
  long ga_needed_size ;
  long ga_newsize ;
  void *tmp___3 ;
  void *ga_new ;
  void *tmp___4 ;
  int i ;
  struct taginfo taginfo ;
  struct pool *P___0 ;

  {
#line 725
  p = text;
#line 726
  end = text + size;
#line 729
  attr_pair_size = (int )(sizeof(attr_pair_initial_storage) / sizeof(attr_pair_initial_storage[0]));
#line 730
  attr_pair_resized = 0;
#line 731
  pairs = attr_pair_initial_storage;
#line 733
  if (! size) {
#line 734
    return;
  }
  {
#line 736
  while (1) {
    while_continue: /* CIL Label */ ;
#line 736
    P = & pool;
#line 736
    P->contents = pool_initial_storage;
#line 736
    P->size = (int )(sizeof(pool_initial_storage) / sizeof(pool_initial_storage[0]));
#line 736
    P->tail = 0;
#line 736
    P->resized = 0;
#line 736
    P->orig_contents = P->contents;
#line 736
    P->orig_size = P->size;
#line 736
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  look_for_tag: 
  {
#line 745
  pool.tail = 0;
#line 747
  nattrs = 0;
#line 748
  end_tag = 0;
#line 752
  tmp = memchr((void const   *)p, '<', (size_t )(end - p));
#line 752
  p = (char const   *)tmp;
  }
#line 753
  if (! p) {
#line 754
    goto finish;
  }
#line 756
  tag_start_position = p;
  {
#line 757
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 757
    p ++;
#line 757
    if ((unsigned long )p >= (unsigned long )end) {
#line 757
      goto finish;
    }
#line 757
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 761
  if ((int const   )*p == 33) {
#line 763
    if (! (flags & 1)) {
#line 763
      if ((unsigned long )p < (unsigned long )(end + 3)) {
#line 763
        if ((int const   )*(p + 1) == 45) {
#line 763
          if ((int const   )*(p + 2) == 45) {
            {
#line 771
            tmp___0 = find_comment_end(p + 3, end);
#line 771
            comment_end = tmp___0;
            }
#line 772
            if (comment_end) {
#line 773
              p = comment_end;
            }
          } else {
            {
#line 781
            p = advance_declaration(p, end);
            }
          }
        } else {
          {
#line 781
          p = advance_declaration(p, end);
          }
        }
      } else {
        {
#line 781
        p = advance_declaration(p, end);
        }
      }
    } else {
      {
#line 781
      p = advance_declaration(p, end);
      }
    }
#line 783
    if ((unsigned long )p == (unsigned long )end) {
#line 784
      goto finish;
    }
#line 785
    goto look_for_tag;
  } else
#line 787
  if ((int const   )*p == 47) {
#line 789
    end_tag = 1;
    {
#line 790
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 790
      p ++;
#line 790
      if ((unsigned long )p >= (unsigned long )end) {
#line 790
        goto finish;
      }
#line 790
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 792
  tag_name_begin = p;
  {
#line 793
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 793
    if ((int const   )*p > 32) {
#line 793
      if ((int const   )*p < 127) {
#line 793
        if ((int const   )*p != 61) {
#line 793
          if ((int const   )*p != 62) {
#line 793
            if (! ((int const   )*p != 47)) {
#line 793
              goto while_break___2;
            }
          } else {
#line 793
            goto while_break___2;
          }
        } else {
#line 793
          goto while_break___2;
        }
      } else {
#line 793
        goto while_break___2;
      }
    } else {
#line 793
      goto while_break___2;
    }
    {
#line 794
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 794
      p ++;
#line 794
      if ((unsigned long )p >= (unsigned long )end) {
#line 794
        goto finish;
      }
#line 794
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 795
  if ((unsigned long )p == (unsigned long )tag_name_begin) {
#line 796
    goto look_for_tag;
  }
#line 797
  tag_name_end = p;
  {
#line 798
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 798
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 798
      if (! ((int const   )_sch_istable[(int const   )*p & 255] & 64)) {
#line 798
        goto while_break___5;
      }
      {
#line 798
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 798
        p ++;
#line 798
        if ((unsigned long )p >= (unsigned long )end) {
#line 798
          goto finish;
        }
#line 798
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
#line 798
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 799
  if (end_tag) {
#line 799
    if ((int const   )*p != 62) {
#line 800
      goto backout_tag;
    }
  }
  {
#line 802
  tmp___1 = name_allowed(allowed_tags, tag_name_begin, tag_name_end);
  }
#line 802
  if (tmp___1) {
    {
#line 808
    uninteresting_tag = 0;
#line 809
    convert_and_copy(& pool, tag_name_begin, tag_name_end, 1);
    }
  } else {
#line 805
    uninteresting_tag = 1;
  }
  {
#line 813
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 818
    operation = 1;
    {
#line 820
    while (1) {
      while_continue___8: /* CIL Label */ ;
      {
#line 820
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 820
        if (! ((int const   )_sch_istable[(int const   )*p & 255] & 64)) {
#line 820
          goto while_break___9;
        }
        {
#line 820
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 820
          p ++;
#line 820
          if ((unsigned long )p >= (unsigned long )end) {
#line 820
            goto finish;
          }
#line 820
          goto while_break___10;
        }
        while_break___10: /* CIL Label */ ;
        }
      }
      while_break___9: /* CIL Label */ ;
      }
#line 820
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 822
    if ((int const   )*p == 47) {
      {
#line 829
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 829
        p ++;
#line 829
        if ((unsigned long )p >= (unsigned long )end) {
#line 829
          goto finish;
        }
#line 829
        goto while_break___11;
      }
      while_break___11: /* CIL Label */ ;
      }
      {
#line 830
      while (1) {
        while_continue___12: /* CIL Label */ ;
        {
#line 830
        while (1) {
          while_continue___13: /* CIL Label */ ;
#line 830
          if (! ((int const   )_sch_istable[(int const   )*p & 255] & 64)) {
#line 830
            goto while_break___13;
          }
          {
#line 830
          while (1) {
            while_continue___14: /* CIL Label */ ;
#line 830
            p ++;
#line 830
            if ((unsigned long )p >= (unsigned long )end) {
#line 830
              goto finish;
            }
#line 830
            goto while_break___14;
          }
          while_break___14: /* CIL Label */ ;
          }
        }
        while_break___13: /* CIL Label */ ;
        }
#line 830
        goto while_break___12;
      }
      while_break___12: /* CIL Label */ ;
      }
#line 831
      if ((int const   )*p != 62) {
#line 832
        goto backout_tag;
      }
    }
#line 836
    if ((int const   )*p == 62) {
#line 837
      goto while_break___7;
    }
#line 840
    attr_name_begin = p;
    {
#line 842
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 842
      if ((int const   )*p > 32) {
#line 842
        if ((int const   )*p < 127) {
#line 842
          if ((int const   )*p != 61) {
#line 842
            if ((int const   )*p != 62) {
#line 842
              if (! ((int const   )*p != 47)) {
#line 842
                goto while_break___15;
              }
            } else {
#line 842
              goto while_break___15;
            }
          } else {
#line 842
            goto while_break___15;
          }
        } else {
#line 842
          goto while_break___15;
        }
      } else {
#line 842
        goto while_break___15;
      }
      {
#line 843
      while (1) {
        while_continue___16: /* CIL Label */ ;
#line 843
        p ++;
#line 843
        if ((unsigned long )p >= (unsigned long )end) {
#line 843
          goto finish;
        }
#line 843
        goto while_break___16;
      }
      while_break___16: /* CIL Label */ ;
      }
    }
    while_break___15: /* CIL Label */ ;
    }
#line 844
    attr_name_end = p;
#line 846
    if ((unsigned long )attr_name_begin == (unsigned long )attr_name_end) {
#line 847
      goto backout_tag;
    }
    {
#line 850
    while (1) {
      while_continue___17: /* CIL Label */ ;
      {
#line 850
      while (1) {
        while_continue___18: /* CIL Label */ ;
#line 850
        if (! ((int const   )_sch_istable[(int const   )*p & 255] & 64)) {
#line 850
          goto while_break___18;
        }
        {
#line 850
        while (1) {
          while_continue___19: /* CIL Label */ ;
#line 850
          p ++;
#line 850
          if ((unsigned long )p >= (unsigned long )end) {
#line 850
            goto finish;
          }
#line 850
          goto while_break___19;
        }
        while_break___19: /* CIL Label */ ;
        }
      }
      while_break___18: /* CIL Label */ ;
      }
#line 850
      goto while_break___17;
    }
    while_break___17: /* CIL Label */ ;
    }
#line 851
    if ((int const   )*p > 32) {
#line 851
      if ((int const   )*p < 127) {
#line 851
        if ((int const   )*p != 61) {
#line 851
          if ((int const   )*p != 62) {
#line 851
            if ((int const   )*p != 47) {
#line 858
              attr_value_begin = attr_name_begin;
#line 858
              attr_raw_value_begin = attr_value_begin;
#line 859
              attr_value_end = attr_name_end;
#line 859
              attr_raw_value_end = attr_value_end;
            } else {
#line 851
              goto _L___4;
            }
          } else {
#line 851
            goto _L___4;
          }
        } else {
#line 851
          goto _L___4;
        }
      } else {
#line 851
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 851
    if ((int const   )*p == 47) {
#line 858
      attr_value_begin = attr_name_begin;
#line 858
      attr_raw_value_begin = attr_value_begin;
#line 859
      attr_value_end = attr_name_end;
#line 859
      attr_raw_value_end = attr_value_end;
    } else
#line 851
    if ((int const   )*p == 62) {
#line 858
      attr_value_begin = attr_name_begin;
#line 858
      attr_raw_value_begin = attr_value_begin;
#line 859
      attr_value_end = attr_name_end;
#line 859
      attr_raw_value_end = attr_value_end;
    } else
#line 861
    if ((int const   )*p == 61) {
      {
#line 863
      while (1) {
        while_continue___20: /* CIL Label */ ;
#line 863
        p ++;
#line 863
        if ((unsigned long )p >= (unsigned long )end) {
#line 863
          goto finish;
        }
#line 863
        goto while_break___20;
      }
      while_break___20: /* CIL Label */ ;
      }
      {
#line 864
      while (1) {
        while_continue___21: /* CIL Label */ ;
        {
#line 864
        while (1) {
          while_continue___22: /* CIL Label */ ;
#line 864
          if (! ((int const   )_sch_istable[(int const   )*p & 255] & 64)) {
#line 864
            goto while_break___22;
          }
          {
#line 864
          while (1) {
            while_continue___23: /* CIL Label */ ;
#line 864
            p ++;
#line 864
            if ((unsigned long )p >= (unsigned long )end) {
#line 864
              goto finish;
            }
#line 864
            goto while_break___23;
          }
          while_break___23: /* CIL Label */ ;
          }
        }
        while_break___22: /* CIL Label */ ;
        }
#line 864
        goto while_break___21;
      }
      while_break___21: /* CIL Label */ ;
      }
#line 865
      if ((int const   )*p == 34) {
#line 865
        goto _L___0;
      } else
#line 865
      if ((int const   )*p == 39) {
        _L___0: /* CIL Label */ 
#line 867
        newline_seen = 0;
#line 868
        quote_char = (char )*p;
#line 869
        attr_raw_value_begin = p;
        {
#line 870
        while (1) {
          while_continue___24: /* CIL Label */ ;
#line 870
          p ++;
#line 870
          if ((unsigned long )p >= (unsigned long )end) {
#line 870
            goto finish;
          }
#line 870
          goto while_break___24;
        }
        while_break___24: /* CIL Label */ ;
        }
#line 871
        attr_value_begin = p;
        {
#line 873
        while (1) {
          while_continue___25: /* CIL Label */ ;
#line 873
          if (! ((int const   )*p != (int const   )quote_char)) {
#line 873
            goto while_break___25;
          }
#line 875
          if (! newline_seen) {
#line 875
            if ((int const   )*p == 10) {
#line 884
              p = attr_value_begin;
#line 885
              newline_seen = 1;
#line 886
              goto while_continue___25;
            } else {
#line 875
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 888
          if (newline_seen) {
#line 888
            if ((int const   )*p == 62) {
#line 889
              goto while_break___25;
            }
          }
          {
#line 890
          while (1) {
            while_continue___26: /* CIL Label */ ;
#line 890
            p ++;
#line 890
            if ((unsigned long )p >= (unsigned long )end) {
#line 890
              goto finish;
            }
#line 890
            goto while_break___26;
          }
          while_break___26: /* CIL Label */ ;
          }
        }
        while_break___25: /* CIL Label */ ;
        }
#line 892
        attr_value_end = p;
#line 894
        if ((int const   )*p == (int const   )quote_char) {
          {
#line 895
          while (1) {
            while_continue___27: /* CIL Label */ ;
#line 895
            p ++;
#line 895
            if ((unsigned long )p >= (unsigned long )end) {
#line 895
              goto finish;
            }
#line 895
            goto while_break___27;
          }
          while_break___27: /* CIL Label */ ;
          }
        } else {
#line 897
          goto look_for_tag;
        }
#line 898
        attr_raw_value_end = p;
#line 900
        operation = 2;
#line 901
        if (flags & 2) {
#line 902
          operation |= 4;
        }
      } else {
#line 906
        attr_value_begin = p;
        {
#line 913
        while (1) {
          while_continue___28: /* CIL Label */ ;
#line 913
          if (! ((int const   )_sch_istable[(int const   )*p & 255] & 64)) {
#line 913
            if (! ((int const   )*p != 62)) {
#line 913
              goto while_break___28;
            }
          } else {
#line 913
            goto while_break___28;
          }
          {
#line 914
          while (1) {
            while_continue___29: /* CIL Label */ ;
#line 914
            p ++;
#line 914
            if ((unsigned long )p >= (unsigned long )end) {
#line 914
              goto finish;
            }
#line 914
            goto while_break___29;
          }
          while_break___29: /* CIL Label */ ;
          }
        }
        while_break___28: /* CIL Label */ ;
        }
#line 915
        attr_value_end = p;
#line 917
        if ((unsigned long )attr_value_begin == (unsigned long )attr_value_end) {
#line 920
          goto backout_tag;
        }
#line 921
        attr_raw_value_begin = attr_value_begin;
#line 922
        attr_raw_value_end = attr_value_end;
#line 923
        operation = 2;
      }
    } else {
#line 931
      goto backout_tag;
    }
#line 937
    if (uninteresting_tag) {
#line 938
      goto while_continue___7;
    }
    {
#line 943
    tmp___2 = name_allowed(allowed_attributes, attr_name_begin, attr_name_end);
    }
#line 943
    if (! tmp___2) {
#line 944
      goto while_continue___7;
    }
    {
#line 946
    while (1) {
      while_continue___30: /* CIL Label */ ;
#line 946
      ga_needed_size = (long )(nattrs + 1);
#line 946
      ga_newsize = (long )attr_pair_size;
      {
#line 946
      while (1) {
        while_continue___31: /* CIL Label */ ;
#line 946
        if (! (ga_newsize < ga_needed_size)) {
#line 946
          goto while_break___31;
        }
#line 946
        ga_newsize <<= 1;
      }
      while_break___31: /* CIL Label */ ;
      }
#line 946
      if (ga_newsize != (long )attr_pair_size) {
#line 946
        if (attr_pair_resized) {
          {
#line 946
          tmp___3 = xrealloc_real((void *)pairs, (size_t )((unsigned long )ga_newsize * sizeof(struct attr_pair )));
#line 946
          pairs = (struct attr_pair *)tmp___3;
          }
        } else {
          {
#line 946
          tmp___4 = xmalloc_real((size_t )((unsigned long )ga_newsize * sizeof(struct attr_pair )));
#line 946
          ga_new = tmp___4;
#line 946
          memcpy((void */* __restrict  */)ga_new, (void const   */* __restrict  */)pairs,
                 (size_t )((unsigned long )attr_pair_size * sizeof(struct attr_pair )));
#line 946
          pairs = (struct attr_pair *)ga_new;
#line 946
          attr_pair_resized = 1;
          }
        }
#line 946
        attr_pair_size = (int )ga_newsize;
      }
#line 946
      goto while_break___30;
    }
    while_break___30: /* CIL Label */ ;
    }
    {
#line 949
    (pairs + nattrs)->name_pool_index = pool.tail;
#line 950
    convert_and_copy(& pool, attr_name_begin, attr_name_end, 1);
#line 952
    (pairs + nattrs)->value_pool_index = pool.tail;
#line 953
    convert_and_copy(& pool, attr_value_begin, attr_value_end, operation);
#line 954
    (pairs + nattrs)->value_raw_beginning = attr_raw_value_begin;
#line 955
    (pairs + nattrs)->value_raw_size = (int )(attr_raw_value_end - attr_raw_value_begin);
#line 957
    nattrs ++;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
#line 960
  if (uninteresting_tag) {
    {
#line 962
    while (1) {
      while_continue___32: /* CIL Label */ ;
#line 962
      p ++;
#line 962
      if ((unsigned long )p >= (unsigned long )end) {
#line 962
        goto finish;
      }
#line 962
      goto while_break___32;
    }
    while_break___32: /* CIL Label */ ;
    }
#line 963
    goto look_for_tag;
  }
#line 972
  taginfo.name = pool.contents;
#line 973
  taginfo.end_tag_p = end_tag;
#line 974
  taginfo.nattrs = nattrs;
#line 979
  i = 0;
  {
#line 979
  while (1) {
    while_continue___33: /* CIL Label */ ;
#line 979
    if (! (i < nattrs)) {
#line 979
      goto while_break___33;
    }
#line 981
    (pairs + i)->name = pool.contents + (pairs + i)->name_pool_index;
#line 982
    (pairs + i)->value = pool.contents + (pairs + i)->value_pool_index;
#line 979
    i ++;
  }
  while_break___33: /* CIL Label */ ;
  }
  {
#line 984
  taginfo.attrs = pairs;
#line 985
  taginfo.start_position = tag_start_position;
#line 986
  taginfo.end_position = p + 1;
#line 988
  (*mapfun)(& taginfo, maparg);
  }
  {
#line 989
  while (1) {
    while_continue___34: /* CIL Label */ ;
#line 989
    p ++;
#line 989
    if ((unsigned long )p >= (unsigned long )end) {
#line 989
      goto finish;
    }
#line 989
    goto while_break___34;
  }
  while_break___34: /* CIL Label */ ;
  }
#line 991
  goto look_for_tag;
  backout_tag: 
#line 999
  p = tag_start_position + 1;
#line 1000
  goto look_for_tag;
  finish: 
  {
#line 1004
  while (1) {
    while_continue___35: /* CIL Label */ ;
#line 1004
    P___0 = & pool;
#line 1004
    if (P___0->resized) {
      {
#line 1004
      free((void *)P___0->contents);
      }
    }
#line 1004
    P___0->contents = P___0->orig_contents;
#line 1004
    P___0->size = P___0->orig_size;
#line 1004
    P___0->tail = 0;
#line 1004
    P___0->resized = 0;
#line 1004
    goto while_break___35;
  }
  while_break___35: /* CIL Label */ ;
  }
#line 1005
  if (attr_pair_resized) {
    {
#line 1006
    free((void *)pairs);
    }
  }
#line 1007
  return;
}
}
#line 267 "/usr/include/netinet/in.h"
extern uint16_t htons(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 61 "/usr/include/netdb.h"
extern int *__h_errno_location(void)  __attribute__((__const__)) ;
#line 138
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 35 "/usr/include/arpa/inet.h"
extern in_addr_t inet_addr(char const   *__cp ) ;
#line 54
extern char *inet_ntoa(struct in_addr __in ) ;
#line 78 "host.h"
char *herrmsg(int error ) ;
#line 80
void address_list_get_bounds(struct address_list *al , int *start , int *end ) ;
#line 81
void address_list_copy_one(struct address_list *al , int index___0 , ip_address *ip_store ) ;
#line 85
void address_list_set_faulty(struct address_list *al , int index___0 ) ;
#line 88
char *pretty_print_address(ip_address *addr___0 ) ;
#line 93
void host_cleanup(void) ;
#line 95
void wget_sockaddr_set_address(wget_sockaddr *sa , int ip_family , unsigned short port ,
                               ip_address *addr___0 ) ;
#line 97
void wget_sockaddr_set_port(wget_sockaddr *sa , unsigned short port ) ;
#line 98
void *wget_sockaddr_get_addr(wget_sockaddr *sa ) ;
#line 99
unsigned short wget_sockaddr_get_port(wget_sockaddr const   *sa ) ;
#line 100
socklen_t sockaddr_len(void) ;
#line 101
void map_ipv4_to_ip(ip4_address *ipv4 , ip_address *ip ) ;
#line 102
int map_ip_to_ipv4(ip_address *ip , ip4_address *ipv4 ) ;
#line 104
int ip_default_family ;
#line 87 "host.c"
int ip_default_family  =    2;
#line 92 "host.c"
static struct hash_table *host_name_addresses_map  ;
#line 107 "host.c"
void address_list_get_bounds(struct address_list *al , int *start , int *end ) 
{ 


  {
#line 110
  *start = al->faulty;
#line 111
  *end = al->count;
#line 112
  return;
}
}
#line 116 "host.c"
void address_list_copy_one(struct address_list *al , int index___0 , ip_address *ip_store ) 
{ 
  int tmp ;
  long tmp___0 ;

  {
#line 119
  if (index___0 >= al->faulty) {
#line 119
    if (index___0 < al->count) {
#line 119
      tmp = 1;
    } else {
#line 119
      tmp = 0;
    }
  } else {
#line 119
    tmp = 0;
  }
  {
#line 119
  tmp___0 = __builtin_expect((long )tmp, 1L);
  }
#line 119
  if (! tmp___0) {
    {
#line 119
    __assert_fail("index >= al->faulty && index < al->count", "host.c", 119U, "address_list_copy_one");
    }
  }
  {
#line 120
  memcpy((void */* __restrict  */)ip_store, (void const   */* __restrict  */)(al->addresses + index___0),
         (size_t )sizeof(ip_address ));
  }
#line 121
  return;
}
}
#line 125 "host.c"
int address_list_match_all(struct address_list *al1 , struct address_list *al2 ) 
{ 
  int tmp ;

  {
#line 128
  if ((unsigned long )al1 == (unsigned long )al2) {
#line 129
    return (1);
  }
#line 130
  if (al1->count != al2->count) {
#line 131
    return (0);
  }
  {
#line 132
  tmp = memcmp((void const   *)al1->addresses, (void const   *)al2->addresses, (size_t )((unsigned long )al1->count * sizeof(ip_address )));
  }
#line 132
  return (0 == tmp);
}
}
#line 139 "host.c"
void address_list_set_faulty(struct address_list *al , int index___0 ) 
{ 
  long tmp ;

  {
  {
#line 145
  tmp = __builtin_expect((long )(! (! (index___0 == al->faulty))), 1L);
  }
#line 145
  if (! tmp) {
    {
#line 145
    __assert_fail("index == al->faulty", "host.c", 145U, "address_list_set_faulty");
    }
  }
#line 147
  (al->faulty) ++;
#line 148
  if (al->faulty >= al->count) {
#line 153
    al->faulty = 0;
  }
#line 154
  return;
}
}
#line 207 "host.c"
static struct address_list *address_list_from_vector(char **h_addr_list ) 
{ 
  int count ;
  int i ;
  struct address_list *al ;
  void *tmp ;
  long tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 210
  count = 0;
#line 212
  tmp = xmalloc_real((size_t )sizeof(struct address_list ));
#line 212
  al = (struct address_list *)tmp;
  }
  {
#line 214
  while (1) {
    while_continue: /* CIL Label */ ;
#line 214
    if (! *(h_addr_list + count)) {
#line 214
      goto while_break;
    }
#line 215
    count ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 216
  tmp___0 = __builtin_expect((long )(! (! (count > 0))), 1L);
  }
#line 216
  if (! tmp___0) {
    {
#line 216
    __assert_fail("count > 0", "host.c", 216U, "address_list_from_vector");
    }
  }
  {
#line 217
  al->count = count;
#line 218
  al->faulty = 0;
#line 219
  tmp___1 = xmalloc_real((size_t )((unsigned long )count * sizeof(ip_address )));
#line 219
  al->addresses = (ip_address *)tmp___1;
#line 220
  al->refcount = 1;
#line 222
  i = 0;
  }
  {
#line 222
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 222
    if (! (i < count)) {
#line 222
      goto while_break___0;
    }
    {
#line 223
    map_ipv4_to_ip((ip4_address *)*(h_addr_list + i), al->addresses + i);
#line 222
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 225
  return (al);
}
}
#line 232 "host.c"
static struct address_list *address_list_from_single(ip_address *addr___0 ) 
{ 
  struct address_list *al ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 235
  tmp = xmalloc_real((size_t )sizeof(struct address_list ));
#line 235
  al = (struct address_list *)tmp;
#line 236
  al->count = 1;
#line 237
  al->faulty = 0;
#line 238
  tmp___0 = xmalloc_real((size_t )sizeof(ip_address ));
#line 238
  al->addresses = (ip_address *)tmp___0;
#line 239
  al->refcount = 1;
#line 240
  memcpy((void */* __restrict  */)al->addresses, (void const   */* __restrict  */)addr___0,
         (size_t )sizeof(ip_address ));
  }
#line 242
  return (al);
}
}
#line 245 "host.c"
static void address_list_delete(struct address_list *al ) 
{ 


  {
  {
#line 248
  free((void *)al->addresses);
#line 249
  free((void *)al);
  }
#line 250
  return;
}
}
#line 252 "host.c"
void address_list_release(struct address_list *al ) 
{ 


  {
#line 255
  (al->refcount) --;
  {
#line 256
  while (1) {
    while_continue: /* CIL Label */ ;
#line 256
    if (opt.debug) {
      {
#line 256
      debug_logprintf("Releasing %p (new refcount %d).\n", al, al->refcount);
      }
    }
#line 256
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 257
  if (al->refcount <= 0) {
    {
#line 259
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 259
      if (opt.debug) {
        {
#line 259
        debug_logprintf("Deleting unused %p.\n", al);
        }
      }
#line 259
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 260
    address_list_delete(al);
    }
  }
#line 262
  return;
}
}
#line 280 "host.c"
void wget_sockaddr_set_address(wget_sockaddr *sa , int ip_family , unsigned short port ,
                               ip_address *addr___0 ) 
{ 
  ip4_address addr4 ;
  int tmp ;

  {
#line 284
  if (ip_family == 2) {
    {
#line 286
    sa->sin.sin_family = (sa_family_t )ip_family;
#line 287
    sa->sin.sin_port = htons(port);
    }
#line 288
    if ((unsigned long )addr___0 == (unsigned long )((void *)0)) {
      {
#line 289
      memset((void *)(& sa->sin.sin_addr), 0, (size_t )sizeof(ip4_address ));
      }
    } else {
      {
#line 293
      tmp = map_ip_to_ipv4(addr___0, & addr4);
      }
#line 293
      if (! tmp) {
        {
#line 295
        abort();
        }
      }
      {
#line 296
      memcpy((void */* __restrict  */)(& sa->sin.sin_addr), (void const   */* __restrict  */)(& addr4),
             (size_t )sizeof(ip4_address ));
      }
    }
#line 298
    return;
  }
  {
#line 312
  abort();
  }
}
}
#line 332 "host.c"
void wget_sockaddr_set_port(wget_sockaddr *sa , unsigned short port ) 
{ 


  {
#line 335
  if ((int )sa->sa.sa_family == 2) {
    {
#line 337
    sa->sin.sin_port = htons(port);
    }
#line 338
    return;
  }
  {
#line 347
  abort();
  }
}
}
#line 365 "host.c"
void *wget_sockaddr_get_addr(wget_sockaddr *sa ) 
{ 


  {
#line 368
  if ((int )sa->sa.sa_family == 2) {
#line 369
    return ((void *)(& sa->sin.sin_addr));
  }
  {
#line 374
  abort();
  }
#line 376
  return ((void *)0);
}
}
#line 394 "host.c"
unsigned short wget_sockaddr_get_port(wget_sockaddr const   *sa ) 
{ 
  uint16_t tmp ;

  {
#line 397
  if ((int const   )sa->sa.sa_family == 2) {
    {
#line 398
    tmp = htons((uint16_t )sa->sin.sin_port);
    }
#line 398
    return (tmp);
  }
  {
#line 403
  abort();
  }
#line 405
  return ((unsigned short)65535);
}
}
#line 424 "host.c"
socklen_t sockaddr_len(void) 
{ 


  {
#line 427
  if (ip_default_family == 2) {
#line 428
    return ((socklen_t )sizeof(struct sockaddr_in ));
  }
  {
#line 433
  abort();
  }
#line 435
  return ((socklen_t )0);
}
}
#line 441 "host.c"
void map_ipv4_to_ip(ip4_address *ipv4 , ip_address *ip ) 
{ 


  {
#line 449
  if ((unsigned long )((char *)ip) != (unsigned long )((char *)ipv4)) {
    {
#line 450
    memcpy((void */* __restrict  */)ip, (void const   */* __restrict  */)ipv4, (size_t )4);
    }
  }
#line 452
  return;
}
}
#line 459 "host.c"
int map_ip_to_ipv4(ip_address *ip , ip4_address *ipv4 ) 
{ 


  {
#line 469
  if (ipv4) {
    {
#line 470
    memcpy((void */* __restrict  */)ipv4, (void const   */* __restrict  */)((char *)ip),
           (size_t )4);
    }
  }
#line 472
  return (1);
}
}
#line 484 "host.c"
static void gethostbyname_with_timeout_callback(void *arg ) 
{ 
  struct ghbnwt_context *ctx ;

  {
  {
#line 487
  ctx = (struct ghbnwt_context *)arg;
#line 488
  ctx->hptr = gethostbyname(ctx->host_name);
  }
#line 489
  return;
}
}
#line 496 "host.c"
static struct hostent *gethostbyname_with_timeout(char const   *host_name , double timeout ) 
{ 
  struct ghbnwt_context ctx ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 500
  ctx.host_name = host_name;
#line 501
  tmp___1 = run_with_timeout(timeout, & gethostbyname_with_timeout_callback, (void *)(& ctx));
  }
#line 501
  if (tmp___1) {
    {
#line 503
    tmp = __h_errno_location();
#line 503
    *tmp = 1;
#line 504
    tmp___0 = __errno_location();
#line 504
    *tmp___0 = 110;
    }
#line 505
    return ((struct hostent *)((void *)0));
  }
#line 507
  if (! ctx.hptr) {
    {
#line 508
    tmp___2 = __errno_location();
#line 508
    *tmp___2 = 0;
    }
  }
#line 509
  return (ctx.hptr);
}
}
#line 558 "host.c"
char *pretty_print_address(ip_address *addr___0 ) 
{ 
  char *tmp ;

  {
  {
#line 572
  tmp = inet_ntoa(*((struct in_addr *)addr___0));
  }
#line 572
  return (tmp);
}
}
#line 579 "host.c"
static void cache_host_lookup(char const   *host , struct address_list *al ) 
{ 
  char *tmp ;
  int i ;
  char *tmp___0 ;

  {
#line 582
  if (! host_name_addresses_map) {
    {
#line 583
    host_name_addresses_map = make_nocase_string_hash_table(0);
    }
  }
  {
#line 585
  (al->refcount) ++;
#line 586
  tmp = xstrdup_lower(host);
#line 586
  hash_table_put(host_name_addresses_map, (void const   *)tmp, (void *)al);
  }
#line 589
  if (opt.debug) {
    {
#line 592
    debug_logprintf("Caching %s =>", host);
#line 593
    i = 0;
    }
    {
#line 593
    while (1) {
      while_continue: /* CIL Label */ ;
#line 593
      if (! (i < al->count)) {
#line 593
        goto while_break;
      }
      {
#line 594
      tmp___0 = pretty_print_address(al->addresses + i);
#line 594
      debug_logprintf(" %s", tmp___0);
#line 593
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 595
    debug_logprintf("\n");
    }
  }
#line 598
  return;
}
}
#line 600 "host.c"
struct address_list *lookup_host(char const   *host , int silent ) 
{ 
  struct address_list *al ;
  u_int32_t addr_ipv4 ;
  ip_address addr___0 ;
  in_addr_t tmp ;
  struct address_list *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  struct hostent *hptr ;
  int *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;
  int i ;
  int printmax ;
  int tmp___8 ;
  char *tmp___9 ;

  {
  {
#line 603
  al = (struct address_list *)((void *)0);
#line 615
  tmp = inet_addr(host);
#line 615
  addr_ipv4 = tmp;
  }
#line 616
  if (addr_ipv4 != 4294967295U) {
    {
#line 620
    map_ipv4_to_ip((ip4_address *)(& addr_ipv4), & addr___0);
#line 621
    tmp___0 = address_list_from_single(& addr___0);
    }
#line 621
    return (tmp___0);
  }
#line 624
  if (host_name_addresses_map) {
    {
#line 626
    tmp___1 = hash_table_get((struct hash_table  const  *)host_name_addresses_map,
                             (void const   *)host);
#line 626
    al = (struct address_list *)tmp___1;
    }
#line 627
    if (al) {
      {
#line 629
      while (1) {
        while_continue: /* CIL Label */ ;
#line 629
        if (opt.debug) {
          {
#line 629
          debug_logprintf("Found %s in host_name_addresses_map (%p)\n", host, al);
          }
        }
#line 629
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 630
      (al->refcount) ++;
#line 631
      return (al);
    }
  }
#line 635
  if (! silent) {
    {
#line 636
    tmp___2 = gettext("Resolving %s... ");
#line 636
    logprintf((enum log_options )0, (char const   *)tmp___2, host);
    }
  }
  {
#line 666
  hptr = gethostbyname_with_timeout(host, opt.dns_timeout);
  }
#line 667
  if (! hptr) {
#line 669
    if (! silent) {
      {
#line 671
      tmp___7 = __errno_location();
      }
#line 671
      if (*tmp___7 != 110) {
        {
#line 672
        tmp___3 = __h_errno_location();
#line 672
        tmp___4 = herrmsg(*tmp___3);
#line 672
        tmp___5 = gettext("failed: %s.\n");
#line 672
        logprintf((enum log_options )0, (char const   *)tmp___5, tmp___4);
        }
      } else {
        {
#line 674
        tmp___6 = gettext("failed: timed out.\n");
#line 674
        logputs((enum log_options )0, (char const   *)tmp___6);
        }
      }
    }
#line 676
    return ((struct address_list *)((void *)0));
  }
  {
#line 680
  al = address_list_from_vector(hptr->h_addr_list);
  }
#line 686
  if (! silent) {
#line 689
    if (al->count <= 3) {
#line 689
      tmp___8 = al->count;
    } else {
#line 689
      tmp___8 = 3;
    }
#line 689
    printmax = tmp___8;
#line 690
    i = 0;
    {
#line 690
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 690
      if (! (i < printmax)) {
#line 690
        goto while_break___0;
      }
      {
#line 692
      tmp___9 = pretty_print_address(al->addresses + i);
#line 692
      logprintf((enum log_options )0, "%s", tmp___9);
      }
#line 694
      if (i < printmax - 1) {
        {
#line 695
        logputs((enum log_options )0, ", ");
        }
      }
#line 690
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 697
    if (printmax != al->count) {
      {
#line 698
      logputs((enum log_options )0, ", ...");
      }
    }
    {
#line 699
    logputs((enum log_options )0, "\n");
    }
  }
#line 703
  if (opt.dns_cache) {
    {
#line 704
    cache_host_lookup(host, al);
    }
  }
#line 706
  return (al);
}
}
#line 711 "host.c"
int accept_domain(struct url *u ) 
{ 
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 714
  tmp = __builtin_expect((long )(! (! ((unsigned long )u->host != (unsigned long )((void *)0)))),
                         1L);
  }
#line 714
  if (! tmp) {
    {
#line 714
    __assert_fail("u->host != ((void *)0)", "host.c", 714U, "accept_domain");
    }
  }
#line 715
  if (opt.domains) {
    {
#line 717
    tmp___0 = sufmatch((char const   **)opt.domains, (char const   *)u->host);
    }
#line 717
    if (! tmp___0) {
#line 718
      return (0);
    }
  }
#line 720
  if (opt.exclude_domains) {
    {
#line 722
    tmp___1 = sufmatch((char const   **)opt.exclude_domains, (char const   *)u->host);
    }
#line 722
    if (tmp___1) {
#line 723
      return (0);
    }
  }
#line 725
  return (1);
}
}
#line 733 "host.c"
int sufmatch(char const   **list , char const   *what ) 
{ 
  int i ;
  int j ;
  int k ;
  int lw ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 738
  tmp = strlen(what);
#line 738
  lw = (int )tmp;
#line 739
  i = 0;
  }
  {
#line 739
  while (1) {
    while_continue: /* CIL Label */ ;
#line 739
    if (! *(list + i)) {
#line 739
      goto while_break;
    }
    {
#line 741
    tmp___0 = strlen(*(list + i));
#line 741
    j = (int )tmp___0;
#line 741
    k = lw;
    }
    {
#line 741
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 741
      if (j >= 0) {
#line 741
        if (! (k >= 0)) {
#line 741
          goto while_break___0;
        }
      } else {
#line 741
        goto while_break___0;
      }
#line 742
      if ((int const   )_sch_tolower[(int const   )*(*(list + i) + j) & 255] != (int const   )_sch_tolower[(int const   )*(what + k) & 255]) {
#line 743
        goto while_break___0;
      }
#line 741
      j --;
#line 741
      k --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 745
    if (j == -1) {
#line 746
      return (1);
    }
#line 739
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 748
  return (0);
}
}
#line 752 "host.c"
char *herrmsg(int error ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 757
  if (error == 1) {
    {
#line 762
    tmp = gettext("Host not found");
    }
#line 762
    return (tmp);
  } else
#line 757
  if (error == 3) {
    {
#line 762
    tmp = gettext("Host not found");
    }
#line 762
    return (tmp);
  } else
#line 757
  if (error == 4) {
    {
#line 762
    tmp = gettext("Host not found");
    }
#line 762
    return (tmp);
  } else
#line 757
  if (error == 4) {
    {
#line 762
    tmp = gettext("Host not found");
    }
#line 762
    return (tmp);
  } else
#line 757
  if (error == 2) {
    {
#line 762
    tmp = gettext("Host not found");
    }
#line 762
    return (tmp);
  } else {
    {
#line 764
    tmp___0 = gettext("Unknown error");
    }
#line 764
    return (tmp___0);
  }
}
}
#line 767 "host.c"
static int host_cleanup_mapper(void *key , void *value , void *arg_ignored ) 
{ 
  struct address_list *al ;
  long tmp ;

  {
  {
#line 772
  free(key);
#line 774
  al = (struct address_list *)value;
#line 775
  tmp = __builtin_expect((long )(! (! (al->refcount == 1))), 1L);
  }
#line 775
  if (! tmp) {
    {
#line 775
    __assert_fail("al->refcount == 1", "host.c", 775U, "host_cleanup_mapper");
    }
  }
  {
#line 776
  address_list_delete(al);
  }
#line 778
  return (0);
}
}
#line 781 "host.c"
void host_cleanup(void) 
{ 


  {
#line 784
  if (host_name_addresses_map) {
    {
#line 786
    hash_table_map(host_name_addresses_map, & host_cleanup_mapper, (void *)0);
#line 787
    hash_table_destroy(host_name_addresses_map);
#line 788
    host_name_addresses_map = (struct hash_table *)((void *)0);
    }
  }
#line 790
  return;
}
}
#line 79 "headers.c"
int header_get(struct rbuf *rbuf , char **hdr , enum header_get_flags flags ) 
{ 
  int i ;
  int bufsize ;
  void *tmp ;
  int res___0 ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char next ;

  {
  {
#line 83
  bufsize = 80;
#line 85
  tmp = xmalloc_real((size_t )bufsize);
#line 85
  *hdr = (char *)tmp;
#line 86
  i = 0;
  }
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
#line 90
    if (i > bufsize - 1) {
      {
#line 91
      bufsize <<= 1;
#line 91
      tmp___0 = xrealloc_real((void *)*hdr, (size_t )bufsize);
#line 91
      *hdr = (char *)tmp___0;
      }
    }
#line 92
    if (rbuf->buffer_left) {
#line 92
      (rbuf->buffer_left) --;
#line 92
      tmp___1 = rbuf->buffer_pos;
#line 92
      (rbuf->buffer_pos) ++;
#line 92
      *(*hdr + i) = *tmp___1;
#line 92
      res___0 = 1;
    } else {
      {
#line 92
      rbuf->buffer_pos = rbuf->buffer;
#line 92
      tmp___5 = rbuf_read_bufferful(rbuf);
#line 92
      rbuf->internal_dont_touch_this = tmp___5;
      }
#line 92
      if (tmp___5 <= 0) {
#line 92
        tmp___4 = rbuf->internal_dont_touch_this;
      } else {
#line 92
        rbuf->buffer_left = (size_t )(rbuf->internal_dont_touch_this - 1);
#line 92
        tmp___3 = rbuf->buffer_pos;
#line 92
        (rbuf->buffer_pos) ++;
#line 92
        *(*hdr + i) = *tmp___3;
#line 92
        tmp___4 = 1;
      }
#line 92
      res___0 = tmp___4;
    }
#line 93
    if (res___0 == 1) {
#line 95
      if ((int )*(*hdr + i) == 10) {
#line 97
        if (! ((unsigned int )flags & 2U)) {
#line 97
          if (! (i == 0)) {
#line 97
            if (i == 1) {
#line 97
              if (! ((int )*(*hdr + 0) == 13)) {
#line 97
                goto _L;
              }
            } else {
              _L: /* CIL Label */ 
              {
#line 105
              res___0 = rbuf_peek(rbuf, & next);
              }
#line 106
              if (res___0 == 0) {
#line 107
                return (2);
              } else
#line 108
              if (res___0 == -1) {
#line 109
                return (1);
              }
#line 111
              if ((int )next == 9) {
#line 112
                goto __Cont;
              } else
#line 111
              if ((int )next == 32) {
#line 112
                goto __Cont;
              }
            }
          }
        }
        {
#line 118
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 118
          if (i > 0) {
#line 118
            if (! ((int const   )_sch_istable[(int )*(*hdr + (i - 1)) & 255] & 64)) {
#line 118
              goto while_break___0;
            }
          } else {
#line 118
            goto while_break___0;
          }
#line 119
          i --;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 120
        *(*hdr + i) = (char )'\000';
#line 121
        goto while_break;
      }
    } else
#line 124
    if (res___0 == 0) {
#line 125
      return (2);
    } else {
#line 127
      return (1);
    }
    __Cont: /* CIL Label */ 
#line 86
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 129
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 129
    if (opt.debug) {
      {
#line 129
      debug_logprintf("%s\n", *hdr);
      }
    }
#line 129
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 130
  return (0);
}
}
#line 136 "headers.c"
int header_process(char const   *header , char const   *name , int (*procfun)(char const   * ,
                                                                              void * ) ,
                   void *arg ) 
{ 
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 142
    if (*name) {
#line 142
      if (! ((int const   )_sch_tolower[(int const   )*name & 255] == (int const   )_sch_tolower[(int const   )*header & 255])) {
#line 142
        goto while_break;
      }
    } else {
#line 142
      goto while_break;
    }
#line 143
    name ++;
#line 143
    header ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 144
  if (*name) {
#line 145
    return (0);
  } else {
#line 144
    tmp = header;
#line 144
    header ++;
#line 144
    if ((int const   )*tmp != 58) {
#line 145
      return (0);
    }
  }
  {
#line 147
  tmp___0 = skip_lws(header);
#line 147
  header += tmp___0;
#line 149
  tmp___1 = (*procfun)(header, arg);
  }
#line 149
  return (tmp___1);
}
}
#line 156 "headers.c"
int header_extract_number(char const   *header , void *closure ) 
{ 
  char const   *p ;
  long result ;
  int tmp ;

  {
#line 159
  p = header;
#line 162
  result = 0L;
  {
#line 162
  while (1) {
    while_continue: /* CIL Label */ ;
#line 162
    if (! ((int const   )_sch_istable[(int const   )*p & 255] & 4)) {
#line 162
      goto while_break;
    }
#line 163
    result = 10L * result + (long )((int const   )*p - 48);
#line 162
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 166
  if ((unsigned long )p == (unsigned long )header) {
#line 167
    return (0);
  }
  {
#line 170
  tmp = skip_lws(p);
#line 170
  p += tmp;
  }
#line 173
  if (*p) {
#line 174
    return (0);
  }
#line 176
  *((long *)closure) = result;
#line 177
  return (1);
}
}
#line 181 "headers.c"
int header_strdup(char const   *header , void *closure ) 
{ 


  {
  {
#line 184
  *((char **)closure) = xstrdup_real(header);
  }
#line 185
  return (1);
}
}
#line 189 "headers.c"
int header_exists(char const   *header , void *closure ) 
{ 


  {
#line 192
  *((int *)closure) = 1;
#line 193
  return (1);
}
}
#line 198 "headers.c"
int skip_lws(char const   *string ) 
{ 
  char const   *p ;

  {
#line 201
  p = string;
  {
#line 203
  while (1) {
    while_continue: /* CIL Label */ ;
#line 203
    if (! ((int const   )*p == 32)) {
#line 203
      if (! ((int const   )*p == 9)) {
#line 203
        if (! ((int const   )*p == 13)) {
#line 203
          if (! ((int const   )*p == 10)) {
#line 203
            goto while_break;
          }
        }
      }
    }
#line 204
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 205
  return ((int )(p - string));
}
}
#line 47 "hash.h"
struct hash_table *hash_table_new(int items , unsigned long (*hash_function)(void const   * ) ,
                                  int (*test_function)(void const   * , void const   * ) ) ;
#line 60
void hash_table_clear(struct hash_table *ht ) ;
#line 65
int hash_table_count(struct hash_table  const  *ht ) ;
#line 67
unsigned long string_hash(void const   *key ) ;
#line 68
int string_cmp(void const   *s1 , void const   *s2 ) ;
#line 72
unsigned long ptrhash(void const   *ptr ) ;
#line 73
int ptrcmp(void const   *ptr1 , void const   *ptr2 ) ;
#line 210 "hash.c"
static int prime_size(int size , int *prime_offset ) ;
#line 210 "hash.c"
static unsigned long const   primes[72]  = 
#line 210
  {      (unsigned long const   )13,      (unsigned long const   )19,      (unsigned long const   )29,      (unsigned long const   )41, 
        (unsigned long const   )59,      (unsigned long const   )79,      (unsigned long const   )107,      (unsigned long const   )149, 
        (unsigned long const   )197,      (unsigned long const   )263,      (unsigned long const   )347,      (unsigned long const   )457, 
        (unsigned long const   )599,      (unsigned long const   )787,      (unsigned long const   )1031,      (unsigned long const   )1361, 
        (unsigned long const   )1777,      (unsigned long const   )2333,      (unsigned long const   )3037,      (unsigned long const   )3967, 
        (unsigned long const   )5167,      (unsigned long const   )6719,      (unsigned long const   )8737,      (unsigned long const   )11369, 
        (unsigned long const   )14783,      (unsigned long const   )19219,      (unsigned long const   )24989,      (unsigned long const   )32491, 
        (unsigned long const   )42257,      (unsigned long const   )54941,      (unsigned long const   )71429,      (unsigned long const   )92861, 
        (unsigned long const   )120721,      (unsigned long const   )156941,      (unsigned long const   )204047,      (unsigned long const   )265271, 
        (unsigned long const   )344857,      (unsigned long const   )448321,      (unsigned long const   )582821,      (unsigned long const   )757693, 
        (unsigned long const   )985003,      (unsigned long const   )1280519,      (unsigned long const   )1664681,      (unsigned long const   )2164111, 
        (unsigned long const   )2813353,      (unsigned long const   )3657361,      (unsigned long const   )4754591,      (unsigned long const   )6180989, 
        (unsigned long const   )8035301,      (unsigned long const   )10445899,      (unsigned long const   )13579681,      (unsigned long const   )17653589, 
        (unsigned long const   )22949669,      (unsigned long const   )29834603,      (unsigned long const   )38784989,      (unsigned long const   )50420551, 
        (unsigned long const   )65546729,      (unsigned long const   )85210757,      (unsigned long const   )110774011,      (unsigned long const   )144006217, 
        (unsigned long const   )187208107,      (unsigned long const   )243370577,      (unsigned long const   )316381771,      (unsigned long const   )411296309, 
        (unsigned long const   )534685237,      (unsigned long const   )695090819,      (unsigned long const   )903618083,      (unsigned long const   )1174703521, 
        (unsigned long const   )1527114613,      (unsigned long const   )1985248999,      (unsigned long const   )2580823717UL,      (unsigned long const   )3355070839UL};
#line 207 "hash.c"
static int prime_size(int size , int *prime_offset ) 
{ 
  int i ;

  {
#line 222
  i = *prime_offset;
  {
#line 224
  while (1) {
    while_continue: /* CIL Label */ ;
#line 224
    if (! ((unsigned long )i < sizeof(primes) / sizeof(primes[0]))) {
#line 224
      goto while_break;
    }
#line 225
    if (primes[i] >= (unsigned long const   )size) {
#line 232
      *prime_offset = i + 1;
#line 233
      return ((int )primes[i]);
    }
#line 224
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 236
  abort();
  }
#line 237
  return (0);
}
}
#line 260 "hash.c"
struct hash_table *hash_table_new(int items , unsigned long (*hash_function)(void const   * ) ,
                                  int (*test_function)(void const   * , void const   * ) ) 
{ 
  int size ;
  struct hash_table *ht ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 266
  tmp = xmalloc_real((size_t )sizeof(struct hash_table ));
#line 266
  ht = (struct hash_table *)tmp;
  }
#line 269
  if (hash_function) {
#line 269
    ht->hash_function = hash_function;
  } else {
#line 269
    ht->hash_function = & ptrhash;
  }
#line 270
  if (test_function) {
#line 270
    ht->test_function = test_function;
  } else {
#line 270
    ht->test_function = & ptrcmp;
  }
  {
#line 272
  ht->prime_offset = 0;
#line 276
  size = (int )((double )1 + (double )items / 0.75);
#line 277
  size = prime_size(size, & ht->prime_offset);
#line 278
  ht->size = size;
#line 279
  ht->resize_threshold = (int )((double )size * 0.75);
#line 282
  tmp___0 = xmalloc_real((size_t )((unsigned long )ht->size * sizeof(struct mapping )));
#line 282
  ht->mappings = (struct mapping *)tmp___0;
#line 283
  memset((void *)ht->mappings, '\000', (size_t )((unsigned long )ht->size * sizeof(struct mapping )));
#line 285
  ht->count = 0;
  }
#line 287
  return (ht);
}
}
#line 292 "hash.c"
void hash_table_destroy(struct hash_table *ht ) 
{ 


  {
  {
#line 295
  free((void *)ht->mappings);
#line 296
  free((void *)ht);
  }
#line 297
  return;
}
}
#line 303 "hash.c"
__inline static struct mapping *find_mapping(struct hash_table  const  *ht , void const   *key ) 
{ 
  struct mapping *mappings ;
  int size ;
  struct mapping *mp ;
  unsigned long tmp ;
  int (*equals)(void const   * , void const   * ) ;
  int tmp___0 ;

  {
  {
#line 306
  mappings = (struct mapping *)ht->mappings;
#line 307
  size = (int )ht->size;
#line 308
  tmp = (*(ht->hash_function))(key);
#line 308
  mp = mappings + tmp % (unsigned long )ht->size;
#line 309
  equals = (int (*)(void const   * , void const   * ))ht->test_function;
  }
  {
#line 311
  while (1) {
    while_continue: /* CIL Label */ ;
#line 311
    if (! ((unsigned long )mp->key != (unsigned long )((void *)0))) {
#line 311
      goto while_break;
    }
    {
#line 312
    tmp___0 = (*equals)(key, (void const   *)mp->key);
    }
#line 312
    if (tmp___0) {
#line 313
      goto while_break;
    }
#line 311
    if ((unsigned long )mp != (unsigned long )(mappings + (size - 1))) {
#line 311
      mp ++;
    } else {
#line 311
      mp = mappings;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 314
  return (mp);
}
}
#line 324 "hash.c"
void *hash_table_get(struct hash_table  const  *ht , void const   *key ) 
{ 
  struct mapping *mp ;
  struct mapping *tmp ;

  {
  {
#line 327
  tmp = find_mapping(ht, key);
#line 327
  mp = tmp;
  }
#line 328
  if ((unsigned long )mp->key != (unsigned long )((void *)0)) {
#line 329
    return (mp->value);
  } else {
#line 331
    return ((void *)0);
  }
}
}
#line 337 "hash.c"
int hash_table_get_pair(struct hash_table  const  *ht , void const   *lookup_key ,
                        void *orig_key , void *value ) 
{ 
  struct mapping *mp ;
  struct mapping *tmp ;

  {
  {
#line 341
  tmp = find_mapping(ht, lookup_key);
#line 341
  mp = tmp;
  }
#line 342
  if ((unsigned long )mp->key != (unsigned long )((void *)0)) {
#line 344
    if (orig_key) {
#line 345
      *((void **)orig_key) = mp->key;
    }
#line 346
    if (value) {
#line 347
      *((void **)value) = mp->value;
    }
#line 348
    return (1);
  } else {
#line 351
    return (0);
  }
}
}
#line 356 "hash.c"
int hash_table_contains(struct hash_table  const  *ht , void const   *key ) 
{ 
  struct mapping *mp ;
  struct mapping *tmp ;

  {
  {
#line 359
  tmp = find_mapping(ht, key);
#line 359
  mp = tmp;
  }
#line 360
  return ((unsigned long )mp->key != (unsigned long )((void *)0));
}
}
#line 366 "hash.c"
static void grow_hash_table(struct hash_table *ht ) 
{ 
  struct mapping *old_mappings ;
  struct mapping *old_end ;
  struct mapping *mp ;
  struct mapping *mappings ;
  int newsize ;
  void *tmp ;
  struct mapping *new_mp ;
  unsigned long tmp___0 ;

  {
  {
#line 369
  old_mappings = ht->mappings;
#line 370
  old_end = ht->mappings + ht->size;
#line 374
  newsize = prime_size(ht->size * 2, & ht->prime_offset);
#line 382
  ht->size = newsize;
#line 383
  ht->resize_threshold = (int )((double )newsize * 0.75);
#line 385
  tmp = xmalloc_real((size_t )((unsigned long )ht->size * sizeof(struct mapping )));
#line 385
  mappings = (struct mapping *)tmp;
#line 386
  memset((void *)mappings, '\000', (size_t )((unsigned long )ht->size * sizeof(struct mapping )));
#line 387
  ht->mappings = mappings;
#line 389
  mp = old_mappings;
  }
  {
#line 389
  while (1) {
    while_continue: /* CIL Label */ ;
#line 389
    if (! ((unsigned long )mp < (unsigned long )old_end)) {
#line 389
      goto while_break;
    }
#line 390
    if ((unsigned long )mp->key != (unsigned long )((void *)0)) {
      {
#line 392
      tmp___0 = (*(ht->hash_function))((void const   *)mp->key);
#line 392
      new_mp = mappings + tmp___0 % (unsigned long )ht->size;
      }
      {
#line 396
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 396
        if (! ((unsigned long )new_mp->key != (unsigned long )((void *)0))) {
#line 396
          goto while_break___0;
        }
#line 396
        if ((unsigned long )new_mp != (unsigned long )(mappings + (newsize - 1))) {
#line 396
          new_mp ++;
        } else {
#line 396
          new_mp = mappings;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 398
      *new_mp = *mp;
    }
#line 389
    mp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 401
  free((void *)old_mappings);
  }
#line 402
  return;
}
}
#line 407 "hash.c"
void hash_table_put(struct hash_table *ht , void const   *key , void *value ) 
{ 
  struct mapping *mp ;
  struct mapping *tmp ;

  {
  {
#line 410
  tmp = find_mapping((struct hash_table  const  *)ht, key);
#line 410
  mp = tmp;
  }
#line 411
  if ((unsigned long )mp->key != (unsigned long )((void *)0)) {
#line 414
    mp->key = (void *)key;
#line 415
    mp->value = value;
#line 416
    return;
  }
#line 421
  if (ht->count >= ht->resize_threshold) {
    {
#line 423
    grow_hash_table(ht);
#line 424
    mp = find_mapping((struct hash_table  const  *)ht, key);
    }
  }
#line 428
  (ht->count) ++;
#line 429
  mp->key = (void *)key;
#line 430
  mp->value = value;
#line 431
  return;
}
}
#line 436 "hash.c"
int hash_table_remove(struct hash_table *ht , void const   *key ) 
{ 
  struct mapping *mp ;
  struct mapping *tmp ;
  int size ;
  struct mapping *mappings ;
  void const   *key2 ;
  struct mapping *mp_new ;
  unsigned long tmp___0 ;

  {
  {
#line 439
  tmp = find_mapping((struct hash_table  const  *)ht, key);
#line 439
  mp = tmp;
  }
#line 440
  if (! ((unsigned long )mp->key != (unsigned long )((void *)0))) {
#line 441
    return (0);
  } else {
#line 444
    size = ht->size;
#line 445
    mappings = ht->mappings;
#line 447
    mp->key = (void *)0;
#line 448
    (ht->count) --;
#line 455
    if ((unsigned long )mp != (unsigned long )(mappings + (size - 1))) {
#line 455
      mp ++;
    } else {
#line 455
      mp = mappings;
    }
    {
#line 456
    while (1) {
      while_continue: /* CIL Label */ ;
#line 456
      if (! ((unsigned long )mp->key != (unsigned long )((void *)0))) {
#line 456
        goto while_break;
      }
      {
#line 458
      key2 = (void const   *)mp->key;
#line 459
      tmp___0 = (*(ht->hash_function))(key2);
#line 459
      mp_new = mappings + tmp___0 % (unsigned long )ht->size;
      }
      {
#line 463
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 463
        if (! ((unsigned long )mp_new->key != (unsigned long )((void *)0))) {
#line 463
          goto while_break___0;
        }
#line 464
        if ((unsigned long )key2 == (unsigned long )mp_new->key) {
#line 467
          goto next_rehash;
        }
#line 463
        if ((unsigned long )mp_new != (unsigned long )(mappings + (size - 1))) {
#line 463
          mp_new ++;
        } else {
#line 463
          mp_new = mappings;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 469
      *mp_new = *mp;
#line 470
      mp->key = (void *)0;
      next_rehash: ;
#line 456
      if ((unsigned long )mp != (unsigned long )(mappings + (size - 1))) {
#line 456
        mp ++;
      } else {
#line 456
        mp = mappings;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 475
    return (1);
  }
}
}
#line 483 "hash.c"
void hash_table_clear(struct hash_table *ht ) 
{ 


  {
  {
#line 486
  memset((void *)ht->mappings, '\000', (size_t )((unsigned long )ht->size * sizeof(struct mapping )));
#line 487
  ht->count = 0;
  }
#line 488
  return;
}
}
#line 498 "hash.c"
void hash_table_map(struct hash_table *ht , int (*mapfun)(void * , void * , void * ) ,
                    void *maparg ) 
{ 
  struct mapping *mp ;
  struct mapping *end ;
  void *key ;
  int tmp ;

  {
#line 503
  mp = ht->mappings;
#line 504
  end = ht->mappings + ht->size;
  {
#line 506
  while (1) {
    while_continue: /* CIL Label */ ;
#line 506
    if (! ((unsigned long )mp < (unsigned long )end)) {
#line 506
      goto while_break;
    }
#line 507
    if ((unsigned long )mp->key != (unsigned long )((void *)0)) {
      repeat: 
      {
#line 511
      key = mp->key;
#line 512
      tmp = (*mapfun)(key, mp->value, maparg);
      }
#line 512
      if (tmp) {
#line 513
        return;
      }
#line 516
      if ((unsigned long )mp->key != (unsigned long )key) {
#line 516
        if ((unsigned long )mp->key != (unsigned long )((void *)0)) {
#line 517
          goto repeat;
        }
      }
    }
#line 506
    mp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 519
  return;
}
}
#line 525 "hash.c"
int hash_table_count(struct hash_table  const  *ht ) 
{ 


  {
#line 528
  return ((int )ht->count);
}
}
#line 546 "hash.c"
unsigned long string_hash(void const   *key ) 
{ 
  char const   *p ;
  unsigned int h ;

  {
#line 549
  p = (char const   *)key;
#line 550
  h = (unsigned int )*p;
#line 552
  if (h) {
#line 553
    p ++;
    {
#line 553
    while (1) {
      while_continue: /* CIL Label */ ;
#line 553
      if (! ((int const   )*p != 0)) {
#line 553
        goto while_break;
      }
#line 554
      h = ((h << 5) - h) + (unsigned int )*p;
#line 553
      p ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 556
  return ((unsigned long )h);
}
}
#line 561 "hash.c"
int string_cmp(void const   *s1 , void const   *s2 ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 564
  tmp = strcmp((char const   *)s1, (char const   *)s2);
  }
#line 564
  if (tmp) {
#line 564
    tmp___0 = 0;
  } else {
#line 564
    tmp___0 = 1;
  }
#line 564
  return (tmp___0);
}
}
#line 570 "hash.c"
struct hash_table *make_string_hash_table(int items ) 
{ 
  struct hash_table *tmp ;

  {
  {
#line 573
  tmp = hash_table_new(items, & string_hash, & string_cmp);
  }
#line 573
  return (tmp);
}
}
#line 584 "hash.c"
static unsigned long string_hash_nocase(void const   *key ) 
{ 
  char const   *p ;
  unsigned int h ;

  {
#line 587
  p = (char const   *)key;
#line 588
  h = (unsigned int )_sch_tolower[(int const   )*p & 255];
#line 590
  if (h) {
#line 591
    p ++;
    {
#line 591
    while (1) {
      while_continue: /* CIL Label */ ;
#line 591
      if (! ((int const   )*p != 0)) {
#line 591
        goto while_break;
      }
#line 592
      h = ((h << 5) - h) + (unsigned int )_sch_tolower[(int const   )*p & 255];
#line 591
      p ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 594
  return ((unsigned long )h);
}
}
#line 599 "hash.c"
static int string_cmp_nocase(void const   *s1 , void const   *s2 ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 602
  tmp = strcasecmp((char const   *)s1, (char const   *)s2);
  }
#line 602
  if (tmp) {
#line 602
    tmp___0 = 0;
  } else {
#line 602
    tmp___0 = 1;
  }
#line 602
  return (tmp___0);
}
}
#line 608 "hash.c"
struct hash_table *make_nocase_string_hash_table(int items ) 
{ 
  struct hash_table *tmp ;

  {
  {
#line 611
  tmp = hash_table_new(items, & string_hash_nocase, & string_cmp_nocase);
  }
#line 611
  return (tmp);
}
}
#line 618 "hash.c"
unsigned long ptrhash(void const   *ptr ) 
{ 
  unsigned long key ;

  {
#line 621
  key = (unsigned long )ptr;
#line 622
  key += key << 12;
#line 623
  key ^= key >> 22;
#line 624
  key += key << 4;
#line 625
  key ^= key >> 9;
#line 626
  key += key << 10;
#line 627
  key ^= key >> 2;
#line 628
  key += key << 7;
#line 629
  key ^= key >> 12;
#line 640
  return (key);
}
}
#line 643 "hash.c"
int ptrcmp(void const   *ptr1 , void const   *ptr2 ) 
{ 


  {
#line 646
  return ((unsigned long )ptr1 == (unsigned long )ptr2);
}
}
#line 44 "ftp-opie.c"
static char Wp[2048][4]  = 
#line 44 "ftp-opie.c"
  { {        (char )'A',        (char )'\000',        (char )'\000',        (char )'\000'}, 
   {        (char )'A',        (char )'B',        (char )'E',        (char )'\000'}, 
   {        (char )'A',        (char )'C',        (char )'E',        (char )'\000'}, 
   {        (char )'A',        (char )'C',        (char )'T',        (char )'\000'}, 
   {        (char )'A',        (char )'D',        (char )'\000',        (char )'\000'}, 
   {        (char )'A',        (char )'D',        (char )'A',        (char )'\000'}, 
   {        (char )'A',        (char )'D',        (char )'D',        (char )'\000'}, 
   {        (char )'A',        (char )'G',        (char )'O',        (char )'\000'}, 
   {        (char )'A',        (char )'I',        (char )'D',        (char )'\000'}, 
   {        (char )'A',        (char )'I',        (char )'M',        (char )'\000'}, 
   {        (char )'A',        (char )'I',        (char )'R',        (char )'\000'}, 
   {        (char )'A',        (char )'L',        (char )'L',        (char )'\000'}, 
   {        (char )'A',        (char )'L',        (char )'P',        (char )'\000'}, 
   {        (char )'A',        (char )'M',        (char )'\000',        (char )'\000'}, 
   {        (char )'A',        (char )'M',        (char )'Y',        (char )'\000'}, 
   {        (char )'A',        (char )'N',        (char )'\000',        (char )'\000'}, 
   {        (char )'A',        (char )'N',        (char )'A',        (char )'\000'}, 
   {        (char )'A',        (char )'N',        (char )'D',        (char )'\000'}, 
   {        (char )'A',        (char )'N',        (char )'N',        (char )'\000'}, 
   {        (char )'A',        (char )'N',        (char )'T',        (char )'\000'}, 
   {        (char )'A',        (char )'N',        (char )'Y',        (char )'\000'}, 
   {        (char )'A',        (char )'P',        (char )'E',        (char )'\000'}, 
   {        (char )'A',        (char )'P',        (char )'S',        (char )'\000'}, 
   {        (char )'A',        (char )'P',        (char )'T',        (char )'\000'}, 
   {        (char )'A',        (char )'R',        (char )'C',        (char )'\000'}, 
   {        (char )'A',        (char )'R',        (char )'E',        (char )'\000'}, 
   {        (char )'A',        (char )'R',        (char )'K',        (char )'\000'}, 
   {        (char )'A',        (char )'R',        (char )'M',        (char )'\000'}, 
   {        (char )'A',        (char )'R',        (char )'T',        (char )'\000'}, 
   {        (char )'A',        (char )'S',        (char )'\000',        (char )'\000'}, 
   {        (char )'A',        (char )'S',        (char )'H',        (char )'\000'}, 
   {        (char )'A',        (char )'S',        (char )'K',        (char )'\000'}, 
   {        (char )'A',        (char )'T',        (char )'\000',        (char )'\000'}, 
   {        (char )'A',        (char )'T',        (char )'E',        (char )'\000'}, 
   {        (char )'A',        (char )'U',        (char )'G',        (char )'\000'}, 
   {        (char )'A',        (char )'U',        (char )'K',        (char )'\000'}, 
   {        (char )'A',        (char )'V',        (char )'E',        (char )'\000'}, 
   {        (char )'A',        (char )'W',        (char )'E',        (char )'\000'}, 
   {        (char )'A',        (char )'W',        (char )'K',        (char )'\000'}, 
   {        (char )'A',        (char )'W',        (char )'L',        (char )'\000'}, 
   {        (char )'A',        (char )'W',        (char )'N',        (char )'\000'}, 
   {        (char )'A',        (char )'X',        (char )'\000',        (char )'\000'}, 
   {        (char )'A',        (char )'Y',        (char )'E',        (char )'\000'}, 
   {        (char )'B',        (char )'A',        (char )'D',        (char )'\000'}, 
   {        (char )'B',        (char )'A',        (char )'G',        (char )'\000'}, 
   {        (char )'B',        (char )'A',        (char )'H',        (char )'\000'}, 
   {        (char )'B',        (char )'A',        (char )'M',        (char )'\000'}, 
   {        (char )'B',        (char )'A',        (char )'N',        (char )'\000'}, 
   {        (char )'B',        (char )'A',        (char )'R',        (char )'\000'}, 
   {        (char )'B',        (char )'A',        (char )'T',        (char )'\000'}, 
   {        (char )'B',        (char )'A',        (char )'Y',        (char )'\000'}, 
   {        (char )'B',        (char )'E',        (char )'\000',        (char )'\000'}, 
   {        (char )'B',        (char )'E',        (char )'D',        (char )'\000'}, 
   {        (char )'B',        (char )'E',        (char )'E',        (char )'\000'}, 
   {        (char )'B',        (char )'E',        (char )'G',        (char )'\000'}, 
   {        (char )'B',        (char )'E',        (char )'N',        (char )'\000'}, 
   {        (char )'B',        (char )'E',        (char )'T',        (char )'\000'}, 
   {        (char )'B',        (char )'E',        (char )'Y',        (char )'\000'}, 
   {        (char )'B',        (char )'I',        (char )'B',        (char )'\000'}, 
   {        (char )'B',        (char )'I',        (char )'D',        (char )'\000'}, 
   {        (char )'B',        (char )'I',        (char )'G',        (char )'\000'}, 
   {        (char )'B',        (char )'I',        (char )'N',        (char )'\000'}, 
   {        (char )'B',        (char )'I',        (char )'T',        (char )'\000'}, 
   {        (char )'B',        (char )'O',        (char )'B',        (char )'\000'}, 
   {        (char )'B',        (char )'O',        (char )'G',        (char )'\000'}, 
   {        (char )'B',        (char )'O',        (char )'N',        (char )'\000'}, 
   {        (char )'B',        (char )'O',        (char )'O',        (char )'\000'}, 
   {        (char )'B',        (char )'O',        (char )'P',        (char )'\000'}, 
   {        (char )'B',        (char )'O',        (char )'W',        (char )'\000'}, 
   {        (char )'B',        (char )'O',        (char )'Y',        (char )'\000'}, 
   {        (char )'B',        (char )'U',        (char )'B',        (char )'\000'}, 
   {        (char )'B',        (char )'U',        (char )'D',        (char )'\000'}, 
   {        (char )'B',        (char )'U',        (char )'G',        (char )'\000'}, 
   {        (char )'B',        (char )'U',        (char )'M',        (char )'\000'}, 
   {        (char )'B',        (char )'U',        (char )'N',        (char )'\000'}, 
   {        (char )'B',        (char )'U',        (char )'S',        (char )'\000'}, 
   {        (char )'B',        (char )'U',        (char )'T',        (char )'\000'}, 
   {        (char )'B',        (char )'U',        (char )'Y',        (char )'\000'}, 
   {        (char )'B',        (char )'Y',        (char )'\000',        (char )'\000'}, 
   {        (char )'B',        (char )'Y',        (char )'E',        (char )'\000'}, 
   {        (char )'C',        (char )'A',        (char )'B',        (char )'\000'}, 
   {        (char )'C',        (char )'A',        (char )'L',        (char )'\000'}, 
   {        (char )'C',        (char )'A',        (char )'M',        (char )'\000'}, 
   {        (char )'C',        (char )'A',        (char )'N',        (char )'\000'}, 
   {        (char )'C',        (char )'A',        (char )'P',        (char )'\000'}, 
   {        (char )'C',        (char )'A',        (char )'R',        (char )'\000'}, 
   {        (char )'C',        (char )'A',        (char )'T',        (char )'\000'}, 
   {        (char )'C',        (char )'A',        (char )'W',        (char )'\000'}, 
   {        (char )'C',        (char )'O',        (char )'D',        (char )'\000'}, 
   {        (char )'C',        (char )'O',        (char )'G',        (char )'\000'}, 
   {        (char )'C',        (char )'O',        (char )'L',        (char )'\000'}, 
   {        (char )'C',        (char )'O',        (char )'N',        (char )'\000'}, 
   {        (char )'C',        (char )'O',        (char )'O',        (char )'\000'}, 
   {        (char )'C',        (char )'O',        (char )'P',        (char )'\000'}, 
   {        (char )'C',        (char )'O',        (char )'T',        (char )'\000'}, 
   {        (char )'C',        (char )'O',        (char )'W',        (char )'\000'}, 
   {        (char )'C',        (char )'O',        (char )'Y',        (char )'\000'}, 
   {        (char )'C',        (char )'R',        (char )'Y',        (char )'\000'}, 
   {        (char )'C',        (char )'U',        (char )'B',        (char )'\000'}, 
   {        (char )'C',        (char )'U',        (char )'E',        (char )'\000'}, 
   {        (char )'C',        (char )'U',        (char )'P',        (char )'\000'}, 
   {        (char )'C',        (char )'U',        (char )'R',        (char )'\000'}, 
   {        (char )'C',        (char )'U',        (char )'T',        (char )'\000'}, 
   {        (char )'D',        (char )'A',        (char )'B',        (char )'\000'}, 
   {        (char )'D',        (char )'A',        (char )'D',        (char )'\000'}, 
   {        (char )'D',        (char )'A',        (char )'M',        (char )'\000'}, 
   {        (char )'D',        (char )'A',        (char )'N',        (char )'\000'}, 
   {        (char )'D',        (char )'A',        (char )'R',        (char )'\000'}, 
   {        (char )'D',        (char )'A',        (char )'Y',        (char )'\000'}, 
   {        (char )'D',        (char )'E',        (char )'E',        (char )'\000'}, 
   {        (char )'D',        (char )'E',        (char )'L',        (char )'\000'}, 
   {        (char )'D',        (char )'E',        (char )'N',        (char )'\000'}, 
   {        (char )'D',        (char )'E',        (char )'S',        (char )'\000'}, 
   {        (char )'D',        (char )'E',        (char )'W',        (char )'\000'}, 
   {        (char )'D',        (char )'I',        (char )'D',        (char )'\000'}, 
   {        (char )'D',        (char )'I',        (char )'E',        (char )'\000'}, 
   {        (char )'D',        (char )'I',        (char )'G',        (char )'\000'}, 
   {        (char )'D',        (char )'I',        (char )'N',        (char )'\000'}, 
   {        (char )'D',        (char )'I',        (char )'P',        (char )'\000'}, 
   {        (char )'D',        (char )'O',        (char )'\000',        (char )'\000'}, 
   {        (char )'D',        (char )'O',        (char )'E',        (char )'\000'}, 
   {        (char )'D',        (char )'O',        (char )'G',        (char )'\000'}, 
   {        (char )'D',        (char )'O',        (char )'N',        (char )'\000'}, 
   {        (char )'D',        (char )'O',        (char )'T',        (char )'\000'}, 
   {        (char )'D',        (char )'O',        (char )'W',        (char )'\000'}, 
   {        (char )'D',        (char )'R',        (char )'Y',        (char )'\000'}, 
   {        (char )'D',        (char )'U',        (char )'B',        (char )'\000'}, 
   {        (char )'D',        (char )'U',        (char )'D',        (char )'\000'}, 
   {        (char )'D',        (char )'U',        (char )'E',        (char )'\000'}, 
   {        (char )'D',        (char )'U',        (char )'G',        (char )'\000'}, 
   {        (char )'D',        (char )'U',        (char )'N',        (char )'\000'}, 
   {        (char )'E',        (char )'A',        (char )'R',        (char )'\000'}, 
   {        (char )'E',        (char )'A',        (char )'T',        (char )'\000'}, 
   {        (char )'E',        (char )'D',        (char )'\000',        (char )'\000'}, 
   {        (char )'E',        (char )'E',        (char )'L',        (char )'\000'}, 
   {        (char )'E',        (char )'G',        (char )'G',        (char )'\000'}, 
   {        (char )'E',        (char )'G',        (char )'O',        (char )'\000'}, 
   {        (char )'E',        (char )'L',        (char )'I',        (char )'\000'}, 
   {        (char )'E',        (char )'L',        (char )'K',        (char )'\000'}, 
   {        (char )'E',        (char )'L',        (char )'M',        (char )'\000'}, 
   {        (char )'E',        (char )'L',        (char )'Y',        (char )'\000'}, 
   {        (char )'E',        (char )'M',        (char )'\000',        (char )'\000'}, 
   {        (char )'E',        (char )'N',        (char )'D',        (char )'\000'}, 
   {        (char )'E',        (char )'S',        (char )'T',        (char )'\000'}, 
   {        (char )'E',        (char )'T',        (char )'C',        (char )'\000'}, 
   {        (char )'E',        (char )'V',        (char )'A',        (char )'\000'}, 
   {        (char )'E',        (char )'V',        (char )'E',        (char )'\000'}, 
   {        (char )'E',        (char )'W',        (char )'E',        (char )'\000'}, 
   {        (char )'E',        (char )'Y',        (char )'E',        (char )'\000'}, 
   {        (char )'F',        (char )'A',        (char )'D',        (char )'\000'}, 
   {        (char )'F',        (char )'A',        (char )'N',        (char )'\000'}, 
   {        (char )'F',        (char )'A',        (char )'R',        (char )'\000'}, 
   {        (char )'F',        (char )'A',        (char )'T',        (char )'\000'}, 
   {        (char )'F',        (char )'A',        (char )'Y',        (char )'\000'}, 
   {        (char )'F',        (char )'E',        (char )'D',        (char )'\000'}, 
   {        (char )'F',        (char )'E',        (char )'E',        (char )'\000'}, 
   {        (char )'F',        (char )'E',        (char )'W',        (char )'\000'}, 
   {        (char )'F',        (char )'I',        (char )'B',        (char )'\000'}, 
   {        (char )'F',        (char )'I',        (char )'G',        (char )'\000'}, 
   {        (char )'F',        (char )'I',        (char )'N',        (char )'\000'}, 
   {        (char )'F',        (char )'I',        (char )'R',        (char )'\000'}, 
   {        (char )'F',        (char )'I',        (char )'T',        (char )'\000'}, 
   {        (char )'F',        (char )'L',        (char )'O',        (char )'\000'}, 
   {        (char )'F',        (char )'L',        (char )'Y',        (char )'\000'}, 
   {        (char )'F',        (char )'O',        (char )'E',        (char )'\000'}, 
   {        (char )'F',        (char )'O',        (char )'G',        (char )'\000'}, 
   {        (char )'F',        (char )'O',        (char )'R',        (char )'\000'}, 
   {        (char )'F',        (char )'R',        (char )'Y',        (char )'\000'}, 
   {        (char )'F',        (char )'U',        (char )'M',        (char )'\000'}, 
   {        (char )'F',        (char )'U',        (char )'N',        (char )'\000'}, 
   {        (char )'F',        (char )'U',        (char )'R',        (char )'\000'}, 
   {        (char )'G',        (char )'A',        (char )'B',        (char )'\000'}, 
   {        (char )'G',        (char )'A',        (char )'D',        (char )'\000'}, 
   {        (char )'G',        (char )'A',        (char )'G',        (char )'\000'}, 
   {        (char )'G',        (char )'A',        (char )'L',        (char )'\000'}, 
   {        (char )'G',        (char )'A',        (char )'M',        (char )'\000'}, 
   {        (char )'G',        (char )'A',        (char )'P',        (char )'\000'}, 
   {        (char )'G',        (char )'A',        (char )'S',        (char )'\000'}, 
   {        (char )'G',        (char )'A',        (char )'Y',        (char )'\000'}, 
   {        (char )'G',        (char )'E',        (char )'E',        (char )'\000'}, 
   {        (char )'G',        (char )'E',        (char )'L',        (char )'\000'}, 
   {        (char )'G',        (char )'E',        (char )'M',        (char )'\000'}, 
   {        (char )'G',        (char )'E',        (char )'T',        (char )'\000'}, 
   {        (char )'G',        (char )'I',        (char )'G',        (char )'\000'}, 
   {        (char )'G',        (char )'I',        (char )'L',        (char )'\000'}, 
   {        (char )'G',        (char )'I',        (char )'N',        (char )'\000'}, 
   {        (char )'G',        (char )'O',        (char )'\000',        (char )'\000'}, 
   {        (char )'G',        (char )'O',        (char )'T',        (char )'\000'}, 
   {        (char )'G',        (char )'U',        (char )'M',        (char )'\000'}, 
   {        (char )'G',        (char )'U',        (char )'N',        (char )'\000'}, 
   {        (char )'G',        (char )'U',        (char )'S',        (char )'\000'}, 
   {        (char )'G',        (char )'U',        (char )'T',        (char )'\000'}, 
   {        (char )'G',        (char )'U',        (char )'Y',        (char )'\000'}, 
   {        (char )'G',        (char )'Y',        (char )'M',        (char )'\000'}, 
   {        (char )'G',        (char )'Y',        (char )'P',        (char )'\000'}, 
   {        (char )'H',        (char )'A',        (char )'\000',        (char )'\000'}, 
   {        (char )'H',        (char )'A',        (char )'D',        (char )'\000'}, 
   {        (char )'H',        (char )'A',        (char )'L',        (char )'\000'}, 
   {        (char )'H',        (char )'A',        (char )'M',        (char )'\000'}, 
   {        (char )'H',        (char )'A',        (char )'N',        (char )'\000'}, 
   {        (char )'H',        (char )'A',        (char )'P',        (char )'\000'}, 
   {        (char )'H',        (char )'A',        (char )'S',        (char )'\000'}, 
   {        (char )'H',        (char )'A',        (char )'T',        (char )'\000'}, 
   {        (char )'H',        (char )'A',        (char )'W',        (char )'\000'}, 
   {        (char )'H',        (char )'A',        (char )'Y',        (char )'\000'}, 
   {        (char )'H',        (char )'E',        (char )'\000',        (char )'\000'}, 
   {        (char )'H',        (char )'E',        (char )'M',        (char )'\000'}, 
   {        (char )'H',        (char )'E',        (char )'N',        (char )'\000'}, 
   {        (char )'H',        (char )'E',        (char )'R',        (char )'\000'}, 
   {        (char )'H',        (char )'E',        (char )'W',        (char )'\000'}, 
   {        (char )'H',        (char )'E',        (char )'Y',        (char )'\000'}, 
   {        (char )'H',        (char )'I',        (char )'\000',        (char )'\000'}, 
   {        (char )'H',        (char )'I',        (char )'D',        (char )'\000'}, 
   {        (char )'H',        (char )'I',        (char )'M',        (char )'\000'}, 
   {        (char )'H',        (char )'I',        (char )'P',        (char )'\000'}, 
   {        (char )'H',        (char )'I',        (char )'S',        (char )'\000'}, 
   {        (char )'H',        (char )'I',        (char )'T',        (char )'\000'}, 
   {        (char )'H',        (char )'O',        (char )'\000',        (char )'\000'}, 
   {        (char )'H',        (char )'O',        (char )'B',        (char )'\000'}, 
   {        (char )'H',        (char )'O',        (char )'C',        (char )'\000'}, 
   {        (char )'H',        (char )'O',        (char )'E',        (char )'\000'}, 
   {        (char )'H',        (char )'O',        (char )'G',        (char )'\000'}, 
   {        (char )'H',        (char )'O',        (char )'P',        (char )'\000'}, 
   {        (char )'H',        (char )'O',        (char )'T',        (char )'\000'}, 
   {        (char )'H',        (char )'O',        (char )'W',        (char )'\000'}, 
   {        (char )'H',        (char )'U',        (char )'B',        (char )'\000'}, 
   {        (char )'H',        (char )'U',        (char )'E',        (char )'\000'}, 
   {        (char )'H',        (char )'U',        (char )'G',        (char )'\000'}, 
   {        (char )'H',        (char )'U',        (char )'H',        (char )'\000'}, 
   {        (char )'H',        (char )'U',        (char )'M',        (char )'\000'}, 
   {        (char )'H',        (char )'U',        (char )'T',        (char )'\000'}, 
   {        (char )'I',        (char )'\000',        (char )'\000',        (char )'\000'}, 
   {        (char )'I',        (char )'C',        (char )'Y',        (char )'\000'}, 
   {        (char )'I',        (char )'D',        (char )'A',        (char )'\000'}, 
   {        (char )'I',        (char )'F',        (char )'\000',        (char )'\000'}, 
   {        (char )'I',        (char )'K',        (char )'E',        (char )'\000'}, 
   {        (char )'I',        (char )'L',        (char )'L',        (char )'\000'}, 
   {        (char )'I',        (char )'N',        (char )'K',        (char )'\000'}, 
   {        (char )'I',        (char )'N',        (char )'N',        (char )'\000'}, 
   {        (char )'I',        (char )'O',        (char )'\000',        (char )'\000'}, 
   {        (char )'I',        (char )'O',        (char )'N',        (char )'\000'}, 
   {        (char )'I',        (char )'Q',        (char )'\000',        (char )'\000'}, 
   {        (char )'I',        (char )'R',        (char )'A',        (char )'\000'}, 
   {        (char )'I',        (char )'R',        (char )'E',        (char )'\000'}, 
   {        (char )'I',        (char )'R',        (char )'K',        (char )'\000'}, 
   {        (char )'I',        (char )'S',        (char )'\000',        (char )'\000'}, 
   {        (char )'I',        (char )'T',        (char )'\000',        (char )'\000'}, 
   {        (char )'I',        (char )'T',        (char )'S',        (char )'\000'}, 
   {        (char )'I',        (char )'V',        (char )'Y',        (char )'\000'}, 
   {        (char )'J',        (char )'A',        (char )'B',        (char )'\000'}, 
   {        (char )'J',        (char )'A',        (char )'G',        (char )'\000'}, 
   {        (char )'J',        (char )'A',        (char )'M',        (char )'\000'}, 
   {        (char )'J',        (char )'A',        (char )'N',        (char )'\000'}, 
   {        (char )'J',        (char )'A',        (char )'R',        (char )'\000'}, 
   {        (char )'J',        (char )'A',        (char )'W',        (char )'\000'}, 
   {        (char )'J',        (char )'A',        (char )'Y',        (char )'\000'}, 
   {        (char )'J',        (char )'E',        (char )'T',        (char )'\000'}, 
   {        (char )'J',        (char )'I',        (char )'G',        (char )'\000'}, 
   {        (char )'J',        (char )'I',        (char )'M',        (char )'\000'}, 
   {        (char )'J',        (char )'O',        (char )'\000',        (char )'\000'}, 
   {        (char )'J',        (char )'O',        (char )'B',        (char )'\000'}, 
   {        (char )'J',        (char )'O',        (char )'E',        (char )'\000'}, 
   {        (char )'J',        (char )'O',        (char )'G',        (char )'\000'}, 
   {        (char )'J',        (char )'O',        (char )'T',        (char )'\000'}, 
   {        (char )'J',        (char )'O',        (char )'Y',        (char )'\000'}, 
   {        (char )'J',        (char )'U',        (char )'G',        (char )'\000'}, 
   {        (char )'J',        (char )'U',        (char )'T',        (char )'\000'}, 
   {        (char )'K',        (char )'A',        (char )'Y',        (char )'\000'}, 
   {        (char )'K',        (char )'E',        (char )'G',        (char )'\000'}, 
   {        (char )'K',        (char )'E',        (char )'N',        (char )'\000'}, 
   {        (char )'K',        (char )'E',        (char )'Y',        (char )'\000'}, 
   {        (char )'K',        (char )'I',        (char )'D',        (char )'\000'}, 
   {        (char )'K',        (char )'I',        (char )'M',        (char )'\000'}, 
   {        (char )'K',        (char )'I',        (char )'N',        (char )'\000'}, 
   {        (char )'K',        (char )'I',        (char )'T',        (char )'\000'}, 
   {        (char )'L',        (char )'A',        (char )'\000',        (char )'\000'}, 
   {        (char )'L',        (char )'A',        (char )'B',        (char )'\000'}, 
   {        (char )'L',        (char )'A',        (char )'C',        (char )'\000'}, 
   {        (char )'L',        (char )'A',        (char )'D',        (char )'\000'}, 
   {        (char )'L',        (char )'A',        (char )'G',        (char )'\000'}, 
   {        (char )'L',        (char )'A',        (char )'M',        (char )'\000'}, 
   {        (char )'L',        (char )'A',        (char )'P',        (char )'\000'}, 
   {        (char )'L',        (char )'A',        (char )'W',        (char )'\000'}, 
   {        (char )'L',        (char )'A',        (char )'Y',        (char )'\000'}, 
   {        (char )'L',        (char )'E',        (char )'A',        (char )'\000'}, 
   {        (char )'L',        (char )'E',        (char )'D',        (char )'\000'}, 
   {        (char )'L',        (char )'E',        (char )'E',        (char )'\000'}, 
   {        (char )'L',        (char )'E',        (char )'G',        (char )'\000'}, 
   {        (char )'L',        (char )'E',        (char )'N',        (char )'\000'}, 
   {        (char )'L',        (char )'E',        (char )'O',        (char )'\000'}, 
   {        (char )'L',        (char )'E',        (char )'T',        (char )'\000'}, 
   {        (char )'L',        (char )'E',        (char )'W',        (char )'\000'}, 
   {        (char )'L',        (char )'I',        (char )'D',        (char )'\000'}, 
   {        (char )'L',        (char )'I',        (char )'E',        (char )'\000'}, 
   {        (char )'L',        (char )'I',        (char )'N',        (char )'\000'}, 
   {        (char )'L',        (char )'I',        (char )'P',        (char )'\000'}, 
   {        (char )'L',        (char )'I',        (char )'T',        (char )'\000'}, 
   {        (char )'L',        (char )'O',        (char )'\000',        (char )'\000'}, 
   {        (char )'L',        (char )'O',        (char )'B',        (char )'\000'}, 
   {        (char )'L',        (char )'O',        (char )'G',        (char )'\000'}, 
   {        (char )'L',        (char )'O',        (char )'P',        (char )'\000'}, 
   {        (char )'L',        (char )'O',        (char )'S',        (char )'\000'}, 
   {        (char )'L',        (char )'O',        (char )'T',        (char )'\000'}, 
   {        (char )'L',        (char )'O',        (char )'U',        (char )'\000'}, 
   {        (char )'L',        (char )'O',        (char )'W',        (char )'\000'}, 
   {        (char )'L',        (char )'O',        (char )'Y',        (char )'\000'}, 
   {        (char )'L',        (char )'U',        (char )'G',        (char )'\000'}, 
   {        (char )'L',        (char )'Y',        (char )'E',        (char )'\000'}, 
   {        (char )'M',        (char )'A',        (char )'\000',        (char )'\000'}, 
   {        (char )'M',        (char )'A',        (char )'C',        (char )'\000'}, 
   {        (char )'M',        (char )'A',        (char )'D',        (char )'\000'}, 
   {        (char )'M',        (char )'A',        (char )'E',        (char )'\000'}, 
   {        (char )'M',        (char )'A',        (char )'N',        (char )'\000'}, 
   {        (char )'M',        (char )'A',        (char )'O',        (char )'\000'}, 
   {        (char )'M',        (char )'A',        (char )'P',        (char )'\000'}, 
   {        (char )'M',        (char )'A',        (char )'T',        (char )'\000'}, 
   {        (char )'M',        (char )'A',        (char )'W',        (char )'\000'}, 
   {        (char )'M',        (char )'A',        (char )'Y',        (char )'\000'}, 
   {        (char )'M',        (char )'E',        (char )'\000',        (char )'\000'}, 
   {        (char )'M',        (char )'E',        (char )'G',        (char )'\000'}, 
   {        (char )'M',        (char )'E',        (char )'L',        (char )'\000'}, 
   {        (char )'M',        (char )'E',        (char )'N',        (char )'\000'}, 
   {        (char )'M',        (char )'E',        (char )'T',        (char )'\000'}, 
   {        (char )'M',        (char )'E',        (char )'W',        (char )'\000'}, 
   {        (char )'M',        (char )'I',        (char )'D',        (char )'\000'}, 
   {        (char )'M',        (char )'I',        (char )'N',        (char )'\000'}, 
   {        (char )'M',        (char )'I',        (char )'T',        (char )'\000'}, 
   {        (char )'M',        (char )'O',        (char )'B',        (char )'\000'}, 
   {        (char )'M',        (char )'O',        (char )'D',        (char )'\000'}, 
   {        (char )'M',        (char )'O',        (char )'E',        (char )'\000'}, 
   {        (char )'M',        (char )'O',        (char )'O',        (char )'\000'}, 
   {        (char )'M',        (char )'O',        (char )'P',        (char )'\000'}, 
   {        (char )'M',        (char )'O',        (char )'S',        (char )'\000'}, 
   {        (char )'M',        (char )'O',        (char )'T',        (char )'\000'}, 
   {        (char )'M',        (char )'O',        (char )'W',        (char )'\000'}, 
   {        (char )'M',        (char )'U',        (char )'D',        (char )'\000'}, 
   {        (char )'M',        (char )'U',        (char )'G',        (char )'\000'}, 
   {        (char )'M',        (char )'U',        (char )'M',        (char )'\000'}, 
   {        (char )'M',        (char )'Y',        (char )'\000',        (char )'\000'}, 
   {        (char )'N',        (char )'A',        (char )'B',        (char )'\000'}, 
   {        (char )'N',        (char )'A',        (char )'G',        (char )'\000'}, 
   {        (char )'N',        (char )'A',        (char )'N',        (char )'\000'}, 
   {        (char )'N',        (char )'A',        (char )'P',        (char )'\000'}, 
   {        (char )'N',        (char )'A',        (char )'T',        (char )'\000'}, 
   {        (char )'N',        (char )'A',        (char )'Y',        (char )'\000'}, 
   {        (char )'N',        (char )'E',        (char )'\000',        (char )'\000'}, 
   {        (char )'N',        (char )'E',        (char )'D',        (char )'\000'}, 
   {        (char )'N',        (char )'E',        (char )'E',        (char )'\000'}, 
   {        (char )'N',        (char )'E',        (char )'T',        (char )'\000'}, 
   {        (char )'N',        (char )'E',        (char )'W',        (char )'\000'}, 
   {        (char )'N',        (char )'I',        (char )'B',        (char )'\000'}, 
   {        (char )'N',        (char )'I',        (char )'L',        (char )'\000'}, 
   {        (char )'N',        (char )'I',        (char )'P',        (char )'\000'}, 
   {        (char )'N',        (char )'I',        (char )'T',        (char )'\000'}, 
   {        (char )'N',        (char )'O',        (char )'\000',        (char )'\000'}, 
   {        (char )'N',        (char )'O',        (char )'B',        (char )'\000'}, 
   {        (char )'N',        (char )'O',        (char )'D',        (char )'\000'}, 
   {        (char )'N',        (char )'O',        (char )'N',        (char )'\000'}, 
   {        (char )'N',        (char )'O',        (char )'R',        (char )'\000'}, 
   {        (char )'N',        (char )'O',        (char )'T',        (char )'\000'}, 
   {        (char )'N',        (char )'O',        (char )'V',        (char )'\000'}, 
   {        (char )'N',        (char )'O',        (char )'W',        (char )'\000'}, 
   {        (char )'N',        (char )'U',        (char )'\000',        (char )'\000'}, 
   {        (char )'N',        (char )'U',        (char )'N',        (char )'\000'}, 
   {        (char )'N',        (char )'U',        (char )'T',        (char )'\000'}, 
   {        (char )'O',        (char )'\000',        (char )'\000',        (char )'\000'}, 
   {        (char )'O',        (char )'A',        (char )'F',        (char )'\000'}, 
   {        (char )'O',        (char )'A',        (char )'K',        (char )'\000'}, 
   {        (char )'O',        (char )'A',        (char )'R',        (char )'\000'}, 
   {        (char )'O',        (char )'A',        (char )'T',        (char )'\000'}, 
   {        (char )'O',        (char )'D',        (char )'D',        (char )'\000'}, 
   {        (char )'O',        (char )'D',        (char )'E',        (char )'\000'}, 
   {        (char )'O',        (char )'F',        (char )'\000',        (char )'\000'}, 
   {        (char )'O',        (char )'F',        (char )'F',        (char )'\000'}, 
   {        (char )'O',        (char )'F',        (char )'T',        (char )'\000'}, 
   {        (char )'O',        (char )'H',        (char )'\000',        (char )'\000'}, 
   {        (char )'O',        (char )'I',        (char )'L',        (char )'\000'}, 
   {        (char )'O',        (char )'K',        (char )'\000',        (char )'\000'}, 
   {        (char )'O',        (char )'L',        (char )'D',        (char )'\000'}, 
   {        (char )'O',        (char )'N',        (char )'\000',        (char )'\000'}, 
   {        (char )'O',        (char )'N',        (char )'E',        (char )'\000'}, 
   {        (char )'O',        (char )'R',        (char )'\000',        (char )'\000'}, 
   {        (char )'O',        (char )'R',        (char )'B',        (char )'\000'}, 
   {        (char )'O',        (char )'R',        (char )'E',        (char )'\000'}, 
   {        (char )'O',        (char )'R',        (char )'R',        (char )'\000'}, 
   {        (char )'O',        (char )'S',        (char )'\000',        (char )'\000'}, 
   {        (char )'O',        (char )'T',        (char )'T',        (char )'\000'}, 
   {        (char )'O',        (char )'U',        (char )'R',        (char )'\000'}, 
   {        (char )'O',        (char )'U',        (char )'T',        (char )'\000'}, 
   {        (char )'O',        (char )'V',        (char )'A',        (char )'\000'}, 
   {        (char )'O',        (char )'W',        (char )'\000',        (char )'\000'}, 
   {        (char )'O',        (char )'W',        (char )'E',        (char )'\000'}, 
   {        (char )'O',        (char )'W',        (char )'L',        (char )'\000'}, 
   {        (char )'O',        (char )'W',        (char )'N',        (char )'\000'}, 
   {        (char )'O',        (char )'X',        (char )'\000',        (char )'\000'}, 
   {        (char )'P',        (char )'A',        (char )'\000',        (char )'\000'}, 
   {        (char )'P',        (char )'A',        (char )'D',        (char )'\000'}, 
   {        (char )'P',        (char )'A',        (char )'L',        (char )'\000'}, 
   {        (char )'P',        (char )'A',        (char )'M',        (char )'\000'}, 
   {        (char )'P',        (char )'A',        (char )'N',        (char )'\000'}, 
   {        (char )'P',        (char )'A',        (char )'P',        (char )'\000'}, 
   {        (char )'P',        (char )'A',        (char )'R',        (char )'\000'}, 
   {        (char )'P',        (char )'A',        (char )'T',        (char )'\000'}, 
   {        (char )'P',        (char )'A',        (char )'W',        (char )'\000'}, 
   {        (char )'P',        (char )'A',        (char )'Y',        (char )'\000'}, 
   {        (char )'P',        (char )'E',        (char )'A',        (char )'\000'}, 
   {        (char )'P',        (char )'E',        (char )'G',        (char )'\000'}, 
   {        (char )'P',        (char )'E',        (char )'N',        (char )'\000'}, 
   {        (char )'P',        (char )'E',        (char )'P',        (char )'\000'}, 
   {        (char )'P',        (char )'E',        (char )'R',        (char )'\000'}, 
   {        (char )'P',        (char )'E',        (char )'T',        (char )'\000'}, 
   {        (char )'P',        (char )'E',        (char )'W',        (char )'\000'}, 
   {        (char )'P',        (char )'H',        (char )'I',        (char )'\000'}, 
   {        (char )'P',        (char )'I',        (char )'\000',        (char )'\000'}, 
   {        (char )'P',        (char )'I',        (char )'E',        (char )'\000'}, 
   {        (char )'P',        (char )'I',        (char )'N',        (char )'\000'}, 
   {        (char )'P',        (char )'I',        (char )'T',        (char )'\000'}, 
   {        (char )'P',        (char )'L',        (char )'Y',        (char )'\000'}, 
   {        (char )'P',        (char )'O',        (char )'\000',        (char )'\000'}, 
   {        (char )'P',        (char )'O',        (char )'D',        (char )'\000'}, 
   {        (char )'P',        (char )'O',        (char )'E',        (char )'\000'}, 
   {        (char )'P',        (char )'O',        (char )'P',        (char )'\000'}, 
   {        (char )'P',        (char )'O',        (char )'T',        (char )'\000'}, 
   {        (char )'P',        (char )'O',        (char )'W',        (char )'\000'}, 
   {        (char )'P',        (char )'R',        (char )'O',        (char )'\000'}, 
   {        (char )'P',        (char )'R',        (char )'Y',        (char )'\000'}, 
   {        (char )'P',        (char )'U',        (char )'B',        (char )'\000'}, 
   {        (char )'P',        (char )'U',        (char )'G',        (char )'\000'}, 
   {        (char )'P',        (char )'U',        (char )'N',        (char )'\000'}, 
   {        (char )'P',        (char )'U',        (char )'P',        (char )'\000'}, 
   {        (char )'P',        (char )'U',        (char )'T',        (char )'\000'}, 
   {        (char )'Q',        (char )'U',        (char )'O',        (char )'\000'}, 
   {        (char )'R',        (char )'A',        (char )'G',        (char )'\000'}, 
   {        (char )'R',        (char )'A',        (char )'M',        (char )'\000'}, 
   {        (char )'R',        (char )'A',        (char )'N',        (char )'\000'}, 
   {        (char )'R',        (char )'A',        (char )'P',        (char )'\000'}, 
   {        (char )'R',        (char )'A',        (char )'T',        (char )'\000'}, 
   {        (char )'R',        (char )'A',        (char )'W',        (char )'\000'}, 
   {        (char )'R',        (char )'A',        (char )'Y',        (char )'\000'}, 
   {        (char )'R',        (char )'E',        (char )'B',        (char )'\000'}, 
   {        (char )'R',        (char )'E',        (char )'D',        (char )'\000'}, 
   {        (char )'R',        (char )'E',        (char )'P',        (char )'\000'}, 
   {        (char )'R',        (char )'E',        (char )'T',        (char )'\000'}, 
   {        (char )'R',        (char )'I',        (char )'B',        (char )'\000'}, 
   {        (char )'R',        (char )'I',        (char )'D',        (char )'\000'}, 
   {        (char )'R',        (char )'I',        (char )'G',        (char )'\000'}, 
   {        (char )'R',        (char )'I',        (char )'M',        (char )'\000'}, 
   {        (char )'R',        (char )'I',        (char )'O',        (char )'\000'}, 
   {        (char )'R',        (char )'I',        (char )'P',        (char )'\000'}, 
   {        (char )'R',        (char )'O',        (char )'B',        (char )'\000'}, 
   {        (char )'R',        (char )'O',        (char )'D',        (char )'\000'}, 
   {        (char )'R',        (char )'O',        (char )'E',        (char )'\000'}, 
   {        (char )'R',        (char )'O',        (char )'N',        (char )'\000'}, 
   {        (char )'R',        (char )'O',        (char )'T',        (char )'\000'}, 
   {        (char )'R',        (char )'O',        (char )'W',        (char )'\000'}, 
   {        (char )'R',        (char )'O',        (char )'Y',        (char )'\000'}, 
   {        (char )'R',        (char )'U',        (char )'B',        (char )'\000'}, 
   {        (char )'R',        (char )'U',        (char )'E',        (char )'\000'}, 
   {        (char )'R',        (char )'U',        (char )'G',        (char )'\000'}, 
   {        (char )'R',        (char )'U',        (char )'M',        (char )'\000'}, 
   {        (char )'R',        (char )'U',        (char )'N',        (char )'\000'}, 
   {        (char )'R',        (char )'Y',        (char )'E',        (char )'\000'}, 
   {        (char )'S',        (char )'A',        (char )'C',        (char )'\000'}, 
   {        (char )'S',        (char )'A',        (char )'D',        (char )'\000'}, 
   {        (char )'S',        (char )'A',        (char )'G',        (char )'\000'}, 
   {        (char )'S',        (char )'A',        (char )'L',        (char )'\000'}, 
   {        (char )'S',        (char )'A',        (char )'M',        (char )'\000'}, 
   {        (char )'S',        (char )'A',        (char )'N',        (char )'\000'}, 
   {        (char )'S',        (char )'A',        (char )'P',        (char )'\000'}, 
   {        (char )'S',        (char )'A',        (char )'T',        (char )'\000'}, 
   {        (char )'S',        (char )'A',        (char )'W',        (char )'\000'}, 
   {        (char )'S',        (char )'A',        (char )'Y',        (char )'\000'}, 
   {        (char )'S',        (char )'E',        (char )'A',        (char )'\000'}, 
   {        (char )'S',        (char )'E',        (char )'C',        (char )'\000'}, 
   {        (char )'S',        (char )'E',        (char )'E',        (char )'\000'}, 
   {        (char )'S',        (char )'E',        (char )'N',        (char )'\000'}, 
   {        (char )'S',        (char )'E',        (char )'T',        (char )'\000'}, 
   {        (char )'S',        (char )'E',        (char )'W',        (char )'\000'}, 
   {        (char )'S',        (char )'H',        (char )'E',        (char )'\000'}, 
   {        (char )'S',        (char )'H',        (char )'Y',        (char )'\000'}, 
   {        (char )'S',        (char )'I',        (char )'N',        (char )'\000'}, 
   {        (char )'S',        (char )'I',        (char )'P',        (char )'\000'}, 
   {        (char )'S',        (char )'I',        (char )'R',        (char )'\000'}, 
   {        (char )'S',        (char )'I',        (char )'S',        (char )'\000'}, 
   {        (char )'S',        (char )'I',        (char )'T',        (char )'\000'}, 
   {        (char )'S',        (char )'K',        (char )'I',        (char )'\000'}, 
   {        (char )'S',        (char )'K',        (char )'Y',        (char )'\000'}, 
   {        (char )'S',        (char )'L',        (char )'Y',        (char )'\000'}, 
   {        (char )'S',        (char )'O',        (char )'\000',        (char )'\000'}, 
   {        (char )'S',        (char )'O',        (char )'B',        (char )'\000'}, 
   {        (char )'S',        (char )'O',        (char )'D',        (char )'\000'}, 
   {        (char )'S',        (char )'O',        (char )'N',        (char )'\000'}, 
   {        (char )'S',        (char )'O',        (char )'P',        (char )'\000'}, 
   {        (char )'S',        (char )'O',        (char )'W',        (char )'\000'}, 
   {        (char )'S',        (char )'O',        (char )'Y',        (char )'\000'}, 
   {        (char )'S',        (char )'P',        (char )'A',        (char )'\000'}, 
   {        (char )'S',        (char )'P',        (char )'Y',        (char )'\000'}, 
   {        (char )'S',        (char )'U',        (char )'B',        (char )'\000'}, 
   {        (char )'S',        (char )'U',        (char )'D',        (char )'\000'}, 
   {        (char )'S',        (char )'U',        (char )'E',        (char )'\000'}, 
   {        (char )'S',        (char )'U',        (char )'M',        (char )'\000'}, 
   {        (char )'S',        (char )'U',        (char )'N',        (char )'\000'}, 
   {        (char )'S',        (char )'U',        (char )'P',        (char )'\000'}, 
   {        (char )'T',        (char )'A',        (char )'B',        (char )'\000'}, 
   {        (char )'T',        (char )'A',        (char )'D',        (char )'\000'}, 
   {        (char )'T',        (char )'A',        (char )'G',        (char )'\000'}, 
   {        (char )'T',        (char )'A',        (char )'N',        (char )'\000'}, 
   {        (char )'T',        (char )'A',        (char )'P',        (char )'\000'}, 
   {        (char )'T',        (char )'A',        (char )'R',        (char )'\000'}, 
   {        (char )'T',        (char )'E',        (char )'A',        (char )'\000'}, 
   {        (char )'T',        (char )'E',        (char )'D',        (char )'\000'}, 
   {        (char )'T',        (char )'E',        (char )'E',        (char )'\000'}, 
   {        (char )'T',        (char )'E',        (char )'N',        (char )'\000'}, 
   {        (char )'T',        (char )'H',        (char )'E',        (char )'\000'}, 
   {        (char )'T',        (char )'H',        (char )'Y',        (char )'\000'}, 
   {        (char )'T',        (char )'I',        (char )'C',        (char )'\000'}, 
   {        (char )'T',        (char )'I',        (char )'E',        (char )'\000'}, 
   {        (char )'T',        (char )'I',        (char )'M',        (char )'\000'}, 
   {        (char )'T',        (char )'I',        (char )'N',        (char )'\000'}, 
   {        (char )'T',        (char )'I',        (char )'P',        (char )'\000'}, 
   {        (char )'T',        (char )'O',        (char )'\000',        (char )'\000'}, 
   {        (char )'T',        (char )'O',        (char )'E',        (char )'\000'}, 
   {        (char )'T',        (char )'O',        (char )'G',        (char )'\000'}, 
   {        (char )'T',        (char )'O',        (char )'M',        (char )'\000'}, 
   {        (char )'T',        (char )'O',        (char )'N',        (char )'\000'}, 
   {        (char )'T',        (char )'O',        (char )'O',        (char )'\000'}, 
   {        (char )'T',        (char )'O',        (char )'P',        (char )'\000'}, 
   {        (char )'T',        (char )'O',        (char )'W',        (char )'\000'}, 
   {        (char )'T',        (char )'O',        (char )'Y',        (char )'\000'}, 
   {        (char )'T',        (char )'R',        (char )'Y',        (char )'\000'}, 
   {        (char )'T',        (char )'U',        (char )'B',        (char )'\000'}, 
   {        (char )'T',        (char )'U',        (char )'G',        (char )'\000'}, 
   {        (char )'T',        (char )'U',        (char )'M',        (char )'\000'}, 
   {        (char )'T',        (char )'U',        (char )'N',        (char )'\000'}, 
   {        (char )'T',        (char )'W',        (char )'O',        (char )'\000'}, 
   {        (char )'U',        (char )'N',        (char )'\000',        (char )'\000'}, 
   {        (char )'U',        (char )'P',        (char )'\000',        (char )'\000'}, 
   {        (char )'U',        (char )'S',        (char )'\000',        (char )'\000'}, 
   {        (char )'U',        (char )'S',        (char )'E',        (char )'\000'}, 
   {        (char )'V',        (char )'A',        (char )'N',        (char )'\000'}, 
   {        (char )'V',        (char )'A',        (char )'T',        (char )'\000'}, 
   {        (char )'V',        (char )'E',        (char )'T',        (char )'\000'}, 
   {        (char )'V',        (char )'I',        (char )'E',        (char )'\000'}, 
   {        (char )'W',        (char )'A',        (char )'D',        (char )'\000'}, 
   {        (char )'W',        (char )'A',        (char )'G',        (char )'\000'}, 
   {        (char )'W',        (char )'A',        (char )'R',        (char )'\000'}, 
   {        (char )'W',        (char )'A',        (char )'S',        (char )'\000'}, 
   {        (char )'W',        (char )'A',        (char )'Y',        (char )'\000'}, 
   {        (char )'W',        (char )'E',        (char )'\000',        (char )'\000'}, 
   {        (char )'W',        (char )'E',        (char )'B',        (char )'\000'}, 
   {        (char )'W',        (char )'E',        (char )'D',        (char )'\000'}, 
   {        (char )'W',        (char )'E',        (char )'E',        (char )'\000'}, 
   {        (char )'W',        (char )'E',        (char )'T',        (char )'\000'}, 
   {        (char )'W',        (char )'H',        (char )'O',        (char )'\000'}, 
   {        (char )'W',        (char )'H',        (char )'Y',        (char )'\000'}, 
   {        (char )'W',        (char )'I',        (char )'N',        (char )'\000'}, 
   {        (char )'W',        (char )'I',        (char )'T',        (char )'\000'}, 
   {        (char )'W',        (char )'O',        (char )'K',        (char )'\000'}, 
   {        (char )'W',        (char )'O',        (char )'N',        (char )'\000'}, 
   {        (char )'W',        (char )'O',        (char )'O',        (char )'\000'}, 
   {        (char )'W',        (char )'O',        (char )'W',        (char )'\000'}, 
   {        (char )'W',        (char )'R',        (char )'Y',        (char )'\000'}, 
   {        (char )'W',        (char )'U',        (char )'\000',        (char )'\000'}, 
   {        (char )'Y',        (char )'A',        (char )'M',        (char )'\000'}, 
   {        (char )'Y',        (char )'A',        (char )'P',        (char )'\000'}, 
   {        (char )'Y',        (char )'A',        (char )'W',        (char )'\000'}, 
   {        (char )'Y',        (char )'E',        (char )'\000',        (char )'\000'}, 
   {        (char )'Y',        (char )'E',        (char )'A',        (char )'\000'}, 
   {        (char )'Y',        (char )'E',        (char )'S',        (char )'\000'}, 
   {        (char )'Y',        (char )'E',        (char )'T',        (char )'\000'}, 
   {        (char )'Y',        (char )'O',        (char )'U',        (char )'\000'}, 
   {        (char )'A',        (char )'B',        (char )'E',        (char )'D'}, 
   {        (char )'A',        (char )'B',        (char )'E',        (char )'L'}, 
   {        (char )'A',        (char )'B',        (char )'E',        (char )'T'}, 
   {        (char )'A',        (char )'B',        (char )'L',        (char )'E'}, 
   {        (char )'A',        (char )'B',        (char )'U',        (char )'T'}, 
   {        (char )'A',        (char )'C',        (char )'H',        (char )'E'}, 
   {        (char )'A',        (char )'C',        (char )'I',        (char )'D'}, 
   {        (char )'A',        (char )'C',        (char )'M',        (char )'E'}, 
   {        (char )'A',        (char )'C',        (char )'R',        (char )'E'}, 
   {        (char )'A',        (char )'C',        (char )'T',        (char )'A'}, 
   {        (char )'A',        (char )'C',        (char )'T',        (char )'S'}, 
   {        (char )'A',        (char )'D',        (char )'A',        (char )'M'}, 
   {        (char )'A',        (char )'D',        (char )'D',        (char )'S'}, 
   {        (char )'A',        (char )'D',        (char )'E',        (char )'N'}, 
   {        (char )'A',        (char )'F',        (char )'A',        (char )'R'}, 
   {        (char )'A',        (char )'F',        (char )'R',        (char )'O'}, 
   {        (char )'A',        (char )'G',        (char )'E',        (char )'E'}, 
   {        (char )'A',        (char )'H',        (char )'E',        (char )'M'}, 
   {        (char )'A',        (char )'H',        (char )'O',        (char )'Y'}, 
   {        (char )'A',        (char )'I',        (char )'D',        (char )'A'}, 
   {        (char )'A',        (char )'I',        (char )'D',        (char )'E'}, 
   {        (char )'A',        (char )'I',        (char )'D',        (char )'S'}, 
   {        (char )'A',        (char )'I',        (char )'R',        (char )'Y'}, 
   {        (char )'A',        (char )'J',        (char )'A',        (char )'R'}, 
   {        (char )'A',        (char )'K',        (char )'I',        (char )'N'}, 
   {        (char )'A',        (char )'L',        (char )'A',        (char )'N'}, 
   {        (char )'A',        (char )'L',        (char )'E',        (char )'C'}, 
   {        (char )'A',        (char )'L',        (char )'G',        (char )'A'}, 
   {        (char )'A',        (char )'L',        (char )'I',        (char )'A'}, 
   {        (char )'A',        (char )'L',        (char )'L',        (char )'Y'}, 
   {        (char )'A',        (char )'L',        (char )'M',        (char )'A'}, 
   {        (char )'A',        (char )'L',        (char )'O',        (char )'E'}, 
   {        (char )'A',        (char )'L',        (char )'S',        (char )'O'}, 
   {        (char )'A',        (char )'L',        (char )'T',        (char )'O'}, 
   {        (char )'A',        (char )'L',        (char )'U',        (char )'M'}, 
   {        (char )'A',        (char )'L',        (char )'V',        (char )'A'}, 
   {        (char )'A',        (char )'M',        (char )'E',        (char )'N'}, 
   {        (char )'A',        (char )'M',        (char )'E',        (char )'S'}, 
   {        (char )'A',        (char )'M',        (char )'I',        (char )'D'}, 
   {        (char )'A',        (char )'M',        (char )'M',        (char )'O'}, 
   {        (char )'A',        (char )'M',        (char )'O',        (char )'K'}, 
   {        (char )'A',        (char )'M',        (char )'O',        (char )'S'}, 
   {        (char )'A',        (char )'M',        (char )'R',        (char )'A'}, 
   {        (char )'A',        (char )'N',        (char )'D',        (char )'Y'}, 
   {        (char )'A',        (char )'N',        (char )'E',        (char )'W'}, 
   {        (char )'A',        (char )'N',        (char )'N',        (char )'A'}, 
   {        (char )'A',        (char )'N',        (char )'N',        (char )'E'}, 
   {        (char )'A',        (char )'N',        (char )'T',        (char )'E'}, 
   {        (char )'A',        (char )'N',        (char )'T',        (char )'I'}, 
   {        (char )'A',        (char )'Q',        (char )'U',        (char )'A'}, 
   {        (char )'A',        (char )'R',        (char )'A',        (char )'B'}, 
   {        (char )'A',        (char )'R',        (char )'C',        (char )'H'}, 
   {        (char )'A',        (char )'R',        (char )'E',        (char )'A'}, 
   {        (char )'A',        (char )'R',        (char )'G',        (char )'O'}, 
   {        (char )'A',        (char )'R',        (char )'I',        (char )'D'}, 
   {        (char )'A',        (char )'R',        (char )'M',        (char )'Y'}, 
   {        (char )'A',        (char )'R',        (char )'T',        (char )'S'}, 
   {        (char )'A',        (char )'R',        (char )'T',        (char )'Y'}, 
   {        (char )'A',        (char )'S',        (char )'I',        (char )'A'}, 
   {        (char )'A',        (char )'S',        (char )'K',        (char )'S'}, 
   {        (char )'A',        (char )'T',        (char )'O',        (char )'M'}, 
   {        (char )'A',        (char )'U',        (char )'N',        (char )'T'}, 
   {        (char )'A',        (char )'U',        (char )'R',        (char )'A'}, 
   {        (char )'A',        (char )'U',        (char )'T',        (char )'O'}, 
   {        (char )'A',        (char )'V',        (char )'E',        (char )'R'}, 
   {        (char )'A',        (char )'V',        (char )'I',        (char )'D'}, 
   {        (char )'A',        (char )'V',        (char )'I',        (char )'S'}, 
   {        (char )'A',        (char )'V',        (char )'O',        (char )'N'}, 
   {        (char )'A',        (char )'V',        (char )'O',        (char )'W'}, 
   {        (char )'A',        (char )'W',        (char )'A',        (char )'Y'}, 
   {        (char )'A',        (char )'W',        (char )'R',        (char )'Y'}, 
   {        (char )'B',        (char )'A',        (char )'B',        (char )'E'}, 
   {        (char )'B',        (char )'A',        (char )'B',        (char )'Y'}, 
   {        (char )'B',        (char )'A',        (char )'C',        (char )'H'}, 
   {        (char )'B',        (char )'A',        (char )'C',        (char )'K'}, 
   {        (char )'B',        (char )'A',        (char )'D',        (char )'E'}, 
   {        (char )'B',        (char )'A',        (char )'I',        (char )'L'}, 
   {        (char )'B',        (char )'A',        (char )'I',        (char )'T'}, 
   {        (char )'B',        (char )'A',        (char )'K',        (char )'E'}, 
   {        (char )'B',        (char )'A',        (char )'L',        (char )'D'}, 
   {        (char )'B',        (char )'A',        (char )'L',        (char )'E'}, 
   {        (char )'B',        (char )'A',        (char )'L',        (char )'I'}, 
   {        (char )'B',        (char )'A',        (char )'L',        (char )'K'}, 
   {        (char )'B',        (char )'A',        (char )'L',        (char )'L'}, 
   {        (char )'B',        (char )'A',        (char )'L',        (char )'M'}, 
   {        (char )'B',        (char )'A',        (char )'N',        (char )'D'}, 
   {        (char )'B',        (char )'A',        (char )'N',        (char )'E'}, 
   {        (char )'B',        (char )'A',        (char )'N',        (char )'G'}, 
   {        (char )'B',        (char )'A',        (char )'N',        (char )'K'}, 
   {        (char )'B',        (char )'A',        (char )'R',        (char )'B'}, 
   {        (char )'B',        (char )'A',        (char )'R',        (char )'D'}, 
   {        (char )'B',        (char )'A',        (char )'R',        (char )'E'}, 
   {        (char )'B',        (char )'A',        (char )'R',        (char )'K'}, 
   {        (char )'B',        (char )'A',        (char )'R',        (char )'N'}, 
   {        (char )'B',        (char )'A',        (char )'R',        (char )'R'}, 
   {        (char )'B',        (char )'A',        (char )'S',        (char )'E'}, 
   {        (char )'B',        (char )'A',        (char )'S',        (char )'H'}, 
   {        (char )'B',        (char )'A',        (char )'S',        (char )'K'}, 
   {        (char )'B',        (char )'A',        (char )'S',        (char )'S'}, 
   {        (char )'B',        (char )'A',        (char )'T',        (char )'E'}, 
   {        (char )'B',        (char )'A',        (char )'T',        (char )'H'}, 
   {        (char )'B',        (char )'A',        (char )'W',        (char )'D'}, 
   {        (char )'B',        (char )'A',        (char )'W',        (char )'L'}, 
   {        (char )'B',        (char )'E',        (char )'A',        (char )'D'}, 
   {        (char )'B',        (char )'E',        (char )'A',        (char )'K'}, 
   {        (char )'B',        (char )'E',        (char )'A',        (char )'M'}, 
   {        (char )'B',        (char )'E',        (char )'A',        (char )'N'}, 
   {        (char )'B',        (char )'E',        (char )'A',        (char )'R'}, 
   {        (char )'B',        (char )'E',        (char )'A',        (char )'T'}, 
   {        (char )'B',        (char )'E',        (char )'A',        (char )'U'}, 
   {        (char )'B',        (char )'E',        (char )'C',        (char )'K'}, 
   {        (char )'B',        (char )'E',        (char )'E',        (char )'F'}, 
   {        (char )'B',        (char )'E',        (char )'E',        (char )'N'}, 
   {        (char )'B',        (char )'E',        (char )'E',        (char )'R'}, 
   {        (char )'B',        (char )'E',        (char )'E',        (char )'T'}, 
   {        (char )'B',        (char )'E',        (char )'L',        (char )'A'}, 
   {        (char )'B',        (char )'E',        (char )'L',        (char )'L'}, 
   {        (char )'B',        (char )'E',        (char )'L',        (char )'T'}, 
   {        (char )'B',        (char )'E',        (char )'N',        (char )'D'}, 
   {        (char )'B',        (char )'E',        (char )'N',        (char )'T'}, 
   {        (char )'B',        (char )'E',        (char )'R',        (char )'G'}, 
   {        (char )'B',        (char )'E',        (char )'R',        (char )'N'}, 
   {        (char )'B',        (char )'E',        (char )'R',        (char )'T'}, 
   {        (char )'B',        (char )'E',        (char )'S',        (char )'S'}, 
   {        (char )'B',        (char )'E',        (char )'S',        (char )'T'}, 
   {        (char )'B',        (char )'E',        (char )'T',        (char )'A'}, 
   {        (char )'B',        (char )'E',        (char )'T',        (char )'H'}, 
   {        (char )'B',        (char )'H',        (char )'O',        (char )'Y'}, 
   {        (char )'B',        (char )'I',        (char )'A',        (char )'S'}, 
   {        (char )'B',        (char )'I',        (char )'D',        (char )'E'}, 
   {        (char )'B',        (char )'I',        (char )'E',        (char )'N'}, 
   {        (char )'B',        (char )'I',        (char )'L',        (char )'E'}, 
   {        (char )'B',        (char )'I',        (char )'L',        (char )'K'}, 
   {        (char )'B',        (char )'I',        (char )'L',        (char )'L'}, 
   {        (char )'B',        (char )'I',        (char )'N',        (char )'D'}, 
   {        (char )'B',        (char )'I',        (char )'N',        (char )'G'}, 
   {        (char )'B',        (char )'I',        (char )'R',        (char )'D'}, 
   {        (char )'B',        (char )'I',        (char )'T',        (char )'E'}, 
   {        (char )'B',        (char )'I',        (char )'T',        (char )'S'}, 
   {        (char )'B',        (char )'L',        (char )'A',        (char )'B'}, 
   {        (char )'B',        (char )'L',        (char )'A',        (char )'T'}, 
   {        (char )'B',        (char )'L',        (char )'E',        (char )'D'}, 
   {        (char )'B',        (char )'L',        (char )'E',        (char )'W'}, 
   {        (char )'B',        (char )'L',        (char )'O',        (char )'B'}, 
   {        (char )'B',        (char )'L',        (char )'O',        (char )'C'}, 
   {        (char )'B',        (char )'L',        (char )'O',        (char )'T'}, 
   {        (char )'B',        (char )'L',        (char )'O',        (char )'W'}, 
   {        (char )'B',        (char )'L',        (char )'U',        (char )'E'}, 
   {        (char )'B',        (char )'L',        (char )'U',        (char )'M'}, 
   {        (char )'B',        (char )'L',        (char )'U',        (char )'R'}, 
   {        (char )'B',        (char )'O',        (char )'A',        (char )'R'}, 
   {        (char )'B',        (char )'O',        (char )'A',        (char )'T'}, 
   {        (char )'B',        (char )'O',        (char )'C',        (char )'A'}, 
   {        (char )'B',        (char )'O',        (char )'C',        (char )'K'}, 
   {        (char )'B',        (char )'O',        (char )'D',        (char )'E'}, 
   {        (char )'B',        (char )'O',        (char )'D',        (char )'Y'}, 
   {        (char )'B',        (char )'O',        (char )'G',        (char )'Y'}, 
   {        (char )'B',        (char )'O',        (char )'H',        (char )'R'}, 
   {        (char )'B',        (char )'O',        (char )'I',        (char )'L'}, 
   {        (char )'B',        (char )'O',        (char )'L',        (char )'D'}, 
   {        (char )'B',        (char )'O',        (char )'L',        (char )'O'}, 
   {        (char )'B',        (char )'O',        (char )'L',        (char )'T'}, 
   {        (char )'B',        (char )'O',        (char )'M',        (char )'B'}, 
   {        (char )'B',        (char )'O',        (char )'N',        (char )'A'}, 
   {        (char )'B',        (char )'O',        (char )'N',        (char )'D'}, 
   {        (char )'B',        (char )'O',        (char )'N',        (char )'E'}, 
   {        (char )'B',        (char )'O',        (char )'N',        (char )'G'}, 
   {        (char )'B',        (char )'O',        (char )'N',        (char )'N'}, 
   {        (char )'B',        (char )'O',        (char )'N',        (char )'Y'}, 
   {        (char )'B',        (char )'O',        (char )'O',        (char )'K'}, 
   {        (char )'B',        (char )'O',        (char )'O',        (char )'M'}, 
   {        (char )'B',        (char )'O',        (char )'O',        (char )'N'}, 
   {        (char )'B',        (char )'O',        (char )'O',        (char )'T'}, 
   {        (char )'B',        (char )'O',        (char )'R',        (char )'E'}, 
   {        (char )'B',        (char )'O',        (char )'R',        (char )'G'}, 
   {        (char )'B',        (char )'O',        (char )'R',        (char )'N'}, 
   {        (char )'B',        (char )'O',        (char )'S',        (char )'E'}, 
   {        (char )'B',        (char )'O',        (char )'S',        (char )'S'}, 
   {        (char )'B',        (char )'O',        (char )'T',        (char )'H'}, 
   {        (char )'B',        (char )'O',        (char )'U',        (char )'T'}, 
   {        (char )'B',        (char )'O',        (char )'W',        (char )'L'}, 
   {        (char )'B',        (char )'O',        (char )'Y',        (char )'D'}, 
   {        (char )'B',        (char )'R',        (char )'A',        (char )'D'}, 
   {        (char )'B',        (char )'R',        (char )'A',        (char )'E'}, 
   {        (char )'B',        (char )'R',        (char )'A',        (char )'G'}, 
   {        (char )'B',        (char )'R',        (char )'A',        (char )'N'}, 
   {        (char )'B',        (char )'R',        (char )'A',        (char )'Y'}, 
   {        (char )'B',        (char )'R',        (char )'E',        (char )'D'}, 
   {        (char )'B',        (char )'R',        (char )'E',        (char )'W'}, 
   {        (char )'B',        (char )'R',        (char )'I',        (char )'G'}, 
   {        (char )'B',        (char )'R',        (char )'I',        (char )'M'}, 
   {        (char )'B',        (char )'R',        (char )'O',        (char )'W'}, 
   {        (char )'B',        (char )'U',        (char )'C',        (char )'K'}, 
   {        (char )'B',        (char )'U',        (char )'D',        (char )'D'}, 
   {        (char )'B',        (char )'U',        (char )'F',        (char )'F'}, 
   {        (char )'B',        (char )'U',        (char )'L',        (char )'B'}, 
   {        (char )'B',        (char )'U',        (char )'L',        (char )'K'}, 
   {        (char )'B',        (char )'U',        (char )'L',        (char )'L'}, 
   {        (char )'B',        (char )'U',        (char )'N',        (char )'K'}, 
   {        (char )'B',        (char )'U',        (char )'N',        (char )'T'}, 
   {        (char )'B',        (char )'U',        (char )'O',        (char )'Y'}, 
   {        (char )'B',        (char )'U',        (char )'R',        (char )'G'}, 
   {        (char )'B',        (char )'U',        (char )'R',        (char )'L'}, 
   {        (char )'B',        (char )'U',        (char )'R',        (char )'N'}, 
   {        (char )'B',        (char )'U',        (char )'R',        (char )'R'}, 
   {        (char )'B',        (char )'U',        (char )'R',        (char )'T'}, 
   {        (char )'B',        (char )'U',        (char )'R',        (char )'Y'}, 
   {        (char )'B',        (char )'U',        (char )'S',        (char )'H'}, 
   {        (char )'B',        (char )'U',        (char )'S',        (char )'S'}, 
   {        (char )'B',        (char )'U',        (char )'S',        (char )'T'}, 
   {        (char )'B',        (char )'U',        (char )'S',        (char )'Y'}, 
   {        (char )'B',        (char )'Y',        (char )'T',        (char )'E'}, 
   {        (char )'C',        (char )'A',        (char )'D',        (char )'Y'}, 
   {        (char )'C',        (char )'A',        (char )'F',        (char )'E'}, 
   {        (char )'C',        (char )'A',        (char )'G',        (char )'E'}, 
   {        (char )'C',        (char )'A',        (char )'I',        (char )'N'}, 
   {        (char )'C',        (char )'A',        (char )'K',        (char )'E'}, 
   {        (char )'C',        (char )'A',        (char )'L',        (char )'F'}, 
   {        (char )'C',        (char )'A',        (char )'L',        (char )'L'}, 
   {        (char )'C',        (char )'A',        (char )'L',        (char )'M'}, 
   {        (char )'C',        (char )'A',        (char )'M',        (char )'E'}, 
   {        (char )'C',        (char )'A',        (char )'N',        (char )'E'}, 
   {        (char )'C',        (char )'A',        (char )'N',        (char )'T'}, 
   {        (char )'C',        (char )'A',        (char )'R',        (char )'D'}, 
   {        (char )'C',        (char )'A',        (char )'R',        (char )'E'}, 
   {        (char )'C',        (char )'A',        (char )'R',        (char )'L'}, 
   {        (char )'C',        (char )'A',        (char )'R',        (char )'R'}, 
   {        (char )'C',        (char )'A',        (char )'R',        (char )'T'}, 
   {        (char )'C',        (char )'A',        (char )'S',        (char )'E'}, 
   {        (char )'C',        (char )'A',        (char )'S',        (char )'H'}, 
   {        (char )'C',        (char )'A',        (char )'S',        (char )'K'}, 
   {        (char )'C',        (char )'A',        (char )'S',        (char )'T'}, 
   {        (char )'C',        (char )'A',        (char )'V',        (char )'E'}, 
   {        (char )'C',        (char )'E',        (char )'I',        (char )'L'}, 
   {        (char )'C',        (char )'E',        (char )'L',        (char )'L'}, 
   {        (char )'C',        (char )'E',        (char )'N',        (char )'T'}, 
   {        (char )'C',        (char )'E',        (char )'R',        (char )'N'}, 
   {        (char )'C',        (char )'H',        (char )'A',        (char )'D'}, 
   {        (char )'C',        (char )'H',        (char )'A',        (char )'R'}, 
   {        (char )'C',        (char )'H',        (char )'A',        (char )'T'}, 
   {        (char )'C',        (char )'H',        (char )'A',        (char )'W'}, 
   {        (char )'C',        (char )'H',        (char )'E',        (char )'F'}, 
   {        (char )'C',        (char )'H',        (char )'E',        (char )'N'}, 
   {        (char )'C',        (char )'H',        (char )'E',        (char )'W'}, 
   {        (char )'C',        (char )'H',        (char )'I',        (char )'C'}, 
   {        (char )'C',        (char )'H',        (char )'I',        (char )'N'}, 
   {        (char )'C',        (char )'H',        (char )'O',        (char )'U'}, 
   {        (char )'C',        (char )'H',        (char )'O',        (char )'W'}, 
   {        (char )'C',        (char )'H',        (char )'U',        (char )'B'}, 
   {        (char )'C',        (char )'H',        (char )'U',        (char )'G'}, 
   {        (char )'C',        (char )'H',        (char )'U',        (char )'M'}, 
   {        (char )'C',        (char )'I',        (char )'T',        (char )'E'}, 
   {        (char )'C',        (char )'I',        (char )'T',        (char )'Y'}, 
   {        (char )'C',        (char )'L',        (char )'A',        (char )'D'}, 
   {        (char )'C',        (char )'L',        (char )'A',        (char )'M'}, 
   {        (char )'C',        (char )'L',        (char )'A',        (char )'N'}, 
   {        (char )'C',        (char )'L',        (char )'A',        (char )'W'}, 
   {        (char )'C',        (char )'L',        (char )'A',        (char )'Y'}, 
   {        (char )'C',        (char )'L',        (char )'O',        (char )'D'}, 
   {        (char )'C',        (char )'L',        (char )'O',        (char )'G'}, 
   {        (char )'C',        (char )'L',        (char )'O',        (char )'T'}, 
   {        (char )'C',        (char )'L',        (char )'U',        (char )'B'}, 
   {        (char )'C',        (char )'L',        (char )'U',        (char )'E'}, 
   {        (char )'C',        (char )'O',        (char )'A',        (char )'L'}, 
   {        (char )'C',        (char )'O',        (char )'A',        (char )'T'}, 
   {        (char )'C',        (char )'O',        (char )'C',        (char )'A'}, 
   {        (char )'C',        (char )'O',        (char )'C',        (char )'K'}, 
   {        (char )'C',        (char )'O',        (char )'C',        (char )'O'}, 
   {        (char )'C',        (char )'O',        (char )'D',        (char )'A'}, 
   {        (char )'C',        (char )'O',        (char )'D',        (char )'E'}, 
   {        (char )'C',        (char )'O',        (char )'D',        (char )'Y'}, 
   {        (char )'C',        (char )'O',        (char )'E',        (char )'D'}, 
   {        (char )'C',        (char )'O',        (char )'I',        (char )'L'}, 
   {        (char )'C',        (char )'O',        (char )'I',        (char )'N'}, 
   {        (char )'C',        (char )'O',        (char )'K',        (char )'E'}, 
   {        (char )'C',        (char )'O',        (char )'L',        (char )'A'}, 
   {        (char )'C',        (char )'O',        (char )'L',        (char )'D'}, 
   {        (char )'C',        (char )'O',        (char )'L',        (char )'T'}, 
   {        (char )'C',        (char )'O',        (char )'M',        (char )'A'}, 
   {        (char )'C',        (char )'O',        (char )'M',        (char )'B'}, 
   {        (char )'C',        (char )'O',        (char )'M',        (char )'E'}, 
   {        (char )'C',        (char )'O',        (char )'O',        (char )'K'}, 
   {        (char )'C',        (char )'O',        (char )'O',        (char )'L'}, 
   {        (char )'C',        (char )'O',        (char )'O',        (char )'N'}, 
   {        (char )'C',        (char )'O',        (char )'O',        (char )'T'}, 
   {        (char )'C',        (char )'O',        (char )'R',        (char )'D'}, 
   {        (char )'C',        (char )'O',        (char )'R',        (char )'E'}, 
   {        (char )'C',        (char )'O',        (char )'R',        (char )'K'}, 
   {        (char )'C',        (char )'O',        (char )'R',        (char )'N'}, 
   {        (char )'C',        (char )'O',        (char )'S',        (char )'T'}, 
   {        (char )'C',        (char )'O',        (char )'V',        (char )'E'}, 
   {        (char )'C',        (char )'O',        (char )'W',        (char )'L'}, 
   {        (char )'C',        (char )'R',        (char )'A',        (char )'B'}, 
   {        (char )'C',        (char )'R',        (char )'A',        (char )'G'}, 
   {        (char )'C',        (char )'R',        (char )'A',        (char )'M'}, 
   {        (char )'C',        (char )'R',        (char )'A',        (char )'Y'}, 
   {        (char )'C',        (char )'R',        (char )'E',        (char )'W'}, 
   {        (char )'C',        (char )'R',        (char )'I',        (char )'B'}, 
   {        (char )'C',        (char )'R',        (char )'O',        (char )'W'}, 
   {        (char )'C',        (char )'R',        (char )'U',        (char )'D'}, 
   {        (char )'C',        (char )'U',        (char )'B',        (char )'A'}, 
   {        (char )'C',        (char )'U',        (char )'B',        (char )'E'}, 
   {        (char )'C',        (char )'U',        (char )'F',        (char )'F'}, 
   {        (char )'C',        (char )'U',        (char )'L',        (char )'L'}, 
   {        (char )'C',        (char )'U',        (char )'L',        (char )'T'}, 
   {        (char )'C',        (char )'U',        (char )'N',        (char )'Y'}, 
   {        (char )'C',        (char )'U',        (char )'R',        (char )'B'}, 
   {        (char )'C',        (char )'U',        (char )'R',        (char )'D'}, 
   {        (char )'C',        (char )'U',        (char )'R',        (char )'E'}, 
   {        (char )'C',        (char )'U',        (char )'R',        (char )'L'}, 
   {        (char )'C',        (char )'U',        (char )'R',        (char )'T'}, 
   {        (char )'C',        (char )'U',        (char )'T',        (char )'S'}, 
   {        (char )'D',        (char )'A',        (char )'D',        (char )'E'}, 
   {        (char )'D',        (char )'A',        (char )'L',        (char )'E'}, 
   {        (char )'D',        (char )'A',        (char )'M',        (char )'E'}, 
   {        (char )'D',        (char )'A',        (char )'N',        (char )'A'}, 
   {        (char )'D',        (char )'A',        (char )'N',        (char )'E'}, 
   {        (char )'D',        (char )'A',        (char )'N',        (char )'G'}, 
   {        (char )'D',        (char )'A',        (char )'N',        (char )'K'}, 
   {        (char )'D',        (char )'A',        (char )'R',        (char )'E'}, 
   {        (char )'D',        (char )'A',        (char )'R',        (char )'K'}, 
   {        (char )'D',        (char )'A',        (char )'R',        (char )'N'}, 
   {        (char )'D',        (char )'A',        (char )'R',        (char )'T'}, 
   {        (char )'D',        (char )'A',        (char )'S',        (char )'H'}, 
   {        (char )'D',        (char )'A',        (char )'T',        (char )'A'}, 
   {        (char )'D',        (char )'A',        (char )'T',        (char )'E'}, 
   {        (char )'D',        (char )'A',        (char )'V',        (char )'E'}, 
   {        (char )'D',        (char )'A',        (char )'V',        (char )'Y'}, 
   {        (char )'D',        (char )'A',        (char )'W',        (char )'N'}, 
   {        (char )'D',        (char )'A',        (char )'Y',        (char )'S'}, 
   {        (char )'D',        (char )'E',        (char )'A',        (char )'D'}, 
   {        (char )'D',        (char )'E',        (char )'A',        (char )'F'}, 
   {        (char )'D',        (char )'E',        (char )'A',        (char )'L'}, 
   {        (char )'D',        (char )'E',        (char )'A',        (char )'N'}, 
   {        (char )'D',        (char )'E',        (char )'A',        (char )'R'}, 
   {        (char )'D',        (char )'E',        (char )'B',        (char )'T'}, 
   {        (char )'D',        (char )'E',        (char )'C',        (char )'K'}, 
   {        (char )'D',        (char )'E',        (char )'E',        (char )'D'}, 
   {        (char )'D',        (char )'E',        (char )'E',        (char )'M'}, 
   {        (char )'D',        (char )'E',        (char )'E',        (char )'R'}, 
   {        (char )'D',        (char )'E',        (char )'F',        (char )'T'}, 
   {        (char )'D',        (char )'E',        (char )'F',        (char )'Y'}, 
   {        (char )'D',        (char )'E',        (char )'L',        (char )'L'}, 
   {        (char )'D',        (char )'E',        (char )'N',        (char )'T'}, 
   {        (char )'D',        (char )'E',        (char )'N',        (char )'Y'}, 
   {        (char )'D',        (char )'E',        (char )'S',        (char )'K'}, 
   {        (char )'D',        (char )'I',        (char )'A',        (char )'L'}, 
   {        (char )'D',        (char )'I',        (char )'C',        (char )'E'}, 
   {        (char )'D',        (char )'I',        (char )'E',        (char )'D'}, 
   {        (char )'D',        (char )'I',        (char )'E',        (char )'T'}, 
   {        (char )'D',        (char )'I',        (char )'M',        (char )'E'}, 
   {        (char )'D',        (char )'I',        (char )'N',        (char )'E'}, 
   {        (char )'D',        (char )'I',        (char )'N',        (char )'G'}, 
   {        (char )'D',        (char )'I',        (char )'N',        (char )'T'}, 
   {        (char )'D',        (char )'I',        (char )'R',        (char )'E'}, 
   {        (char )'D',        (char )'I',        (char )'R',        (char )'T'}, 
   {        (char )'D',        (char )'I',        (char )'S',        (char )'C'}, 
   {        (char )'D',        (char )'I',        (char )'S',        (char )'H'}, 
   {        (char )'D',        (char )'I',        (char )'S',        (char )'K'}, 
   {        (char )'D',        (char )'I',        (char )'V',        (char )'E'}, 
   {        (char )'D',        (char )'O',        (char )'C',        (char )'K'}, 
   {        (char )'D',        (char )'O',        (char )'E',        (char )'S'}, 
   {        (char )'D',        (char )'O',        (char )'L',        (char )'E'}, 
   {        (char )'D',        (char )'O',        (char )'L',        (char )'L'}, 
   {        (char )'D',        (char )'O',        (char )'L',        (char )'T'}, 
   {        (char )'D',        (char )'O',        (char )'M',        (char )'E'}, 
   {        (char )'D',        (char )'O',        (char )'N',        (char )'E'}, 
   {        (char )'D',        (char )'O',        (char )'O',        (char )'M'}, 
   {        (char )'D',        (char )'O',        (char )'O',        (char )'R'}, 
   {        (char )'D',        (char )'O',        (char )'R',        (char )'A'}, 
   {        (char )'D',        (char )'O',        (char )'S',        (char )'E'}, 
   {        (char )'D',        (char )'O',        (char )'T',        (char )'E'}, 
   {        (char )'D',        (char )'O',        (char )'U',        (char )'G'}, 
   {        (char )'D',        (char )'O',        (char )'U',        (char )'R'}, 
   {        (char )'D',        (char )'O',        (char )'V',        (char )'E'}, 
   {        (char )'D',        (char )'O',        (char )'W',        (char )'N'}, 
   {        (char )'D',        (char )'R',        (char )'A',        (char )'B'}, 
   {        (char )'D',        (char )'R',        (char )'A',        (char )'G'}, 
   {        (char )'D',        (char )'R',        (char )'A',        (char )'M'}, 
   {        (char )'D',        (char )'R',        (char )'A',        (char )'W'}, 
   {        (char )'D',        (char )'R',        (char )'E',        (char )'W'}, 
   {        (char )'D',        (char )'R',        (char )'U',        (char )'B'}, 
   {        (char )'D',        (char )'R',        (char )'U',        (char )'G'}, 
   {        (char )'D',        (char )'R',        (char )'U',        (char )'M'}, 
   {        (char )'D',        (char )'U',        (char )'A',        (char )'L'}, 
   {        (char )'D',        (char )'U',        (char )'C',        (char )'K'}, 
   {        (char )'D',        (char )'U',        (char )'C',        (char )'T'}, 
   {        (char )'D',        (char )'U',        (char )'E',        (char )'L'}, 
   {        (char )'D',        (char )'U',        (char )'E',        (char )'T'}, 
   {        (char )'D',        (char )'U',        (char )'K',        (char )'E'}, 
   {        (char )'D',        (char )'U',        (char )'L',        (char )'L'}, 
   {        (char )'D',        (char )'U',        (char )'M',        (char )'B'}, 
   {        (char )'D',        (char )'U',        (char )'N',        (char )'E'}, 
   {        (char )'D',        (char )'U',        (char )'N',        (char )'K'}, 
   {        (char )'D',        (char )'U',        (char )'S',        (char )'K'}, 
   {        (char )'D',        (char )'U',        (char )'S',        (char )'T'}, 
   {        (char )'D',        (char )'U',        (char )'T',        (char )'Y'}, 
   {        (char )'E',        (char )'A',        (char )'C',        (char )'H'}, 
   {        (char )'E',        (char )'A',        (char )'R',        (char )'L'}, 
   {        (char )'E',        (char )'A',        (char )'R',        (char )'N'}, 
   {        (char )'E',        (char )'A',        (char )'S',        (char )'E'}, 
   {        (char )'E',        (char )'A',        (char )'S',        (char )'T'}, 
   {        (char )'E',        (char )'A',        (char )'S',        (char )'Y'}, 
   {        (char )'E',        (char )'B',        (char )'E',        (char )'N'}, 
   {        (char )'E',        (char )'C',        (char )'H',        (char )'O'}, 
   {        (char )'E',        (char )'D',        (char )'D',        (char )'Y'}, 
   {        (char )'E',        (char )'D',        (char )'E',        (char )'N'}, 
   {        (char )'E',        (char )'D',        (char )'G',        (char )'E'}, 
   {        (char )'E',        (char )'D',        (char )'G',        (char )'Y'}, 
   {        (char )'E',        (char )'D',        (char )'I',        (char )'T'}, 
   {        (char )'E',        (char )'D',        (char )'N',        (char )'A'}, 
   {        (char )'E',        (char )'G',        (char )'A',        (char )'N'}, 
   {        (char )'E',        (char )'L',        (char )'A',        (char )'N'}, 
   {        (char )'E',        (char )'L',        (char )'B',        (char )'A'}, 
   {        (char )'E',        (char )'L',        (char )'L',        (char )'A'}, 
   {        (char )'E',        (char )'L',        (char )'S',        (char )'E'}, 
   {        (char )'E',        (char )'M',        (char )'I',        (char )'L'}, 
   {        (char )'E',        (char )'M',        (char )'I',        (char )'T'}, 
   {        (char )'E',        (char )'M',        (char )'M',        (char )'A'}, 
   {        (char )'E',        (char )'N',        (char )'D',        (char )'S'}, 
   {        (char )'E',        (char )'R',        (char )'I',        (char )'C'}, 
   {        (char )'E',        (char )'R',        (char )'O',        (char )'S'}, 
   {        (char )'E',        (char )'V',        (char )'E',        (char )'N'}, 
   {        (char )'E',        (char )'V',        (char )'E',        (char )'R'}, 
   {        (char )'E',        (char )'V',        (char )'I',        (char )'L'}, 
   {        (char )'E',        (char )'Y',        (char )'E',        (char )'D'}, 
   {        (char )'F',        (char )'A',        (char )'C',        (char )'E'}, 
   {        (char )'F',        (char )'A',        (char )'C',        (char )'T'}, 
   {        (char )'F',        (char )'A',        (char )'D',        (char )'E'}, 
   {        (char )'F',        (char )'A',        (char )'I',        (char )'L'}, 
   {        (char )'F',        (char )'A',        (char )'I',        (char )'N'}, 
   {        (char )'F',        (char )'A',        (char )'I',        (char )'R'}, 
   {        (char )'F',        (char )'A',        (char )'K',        (char )'E'}, 
   {        (char )'F',        (char )'A',        (char )'L',        (char )'L'}, 
   {        (char )'F',        (char )'A',        (char )'M',        (char )'E'}, 
   {        (char )'F',        (char )'A',        (char )'N',        (char )'G'}, 
   {        (char )'F',        (char )'A',        (char )'R',        (char )'M'}, 
   {        (char )'F',        (char )'A',        (char )'S',        (char )'T'}, 
   {        (char )'F',        (char )'A',        (char )'T',        (char )'E'}, 
   {        (char )'F',        (char )'A',        (char )'W',        (char )'N'}, 
   {        (char )'F',        (char )'E',        (char )'A',        (char )'R'}, 
   {        (char )'F',        (char )'E',        (char )'A',        (char )'T'}, 
   {        (char )'F',        (char )'E',        (char )'E',        (char )'D'}, 
   {        (char )'F',        (char )'E',        (char )'E',        (char )'L'}, 
   {        (char )'F',        (char )'E',        (char )'E',        (char )'T'}, 
   {        (char )'F',        (char )'E',        (char )'L',        (char )'L'}, 
   {        (char )'F',        (char )'E',        (char )'L',        (char )'T'}, 
   {        (char )'F',        (char )'E',        (char )'N',        (char )'D'}, 
   {        (char )'F',        (char )'E',        (char )'R',        (char )'N'}, 
   {        (char )'F',        (char )'E',        (char )'S',        (char )'T'}, 
   {        (char )'F',        (char )'E',        (char )'U',        (char )'D'}, 
   {        (char )'F',        (char )'I',        (char )'E',        (char )'F'}, 
   {        (char )'F',        (char )'I',        (char )'G',        (char )'S'}, 
   {        (char )'F',        (char )'I',        (char )'L',        (char )'E'}, 
   {        (char )'F',        (char )'I',        (char )'L',        (char )'L'}, 
   {        (char )'F',        (char )'I',        (char )'L',        (char )'M'}, 
   {        (char )'F',        (char )'I',        (char )'N',        (char )'D'}, 
   {        (char )'F',        (char )'I',        (char )'N',        (char )'E'}, 
   {        (char )'F',        (char )'I',        (char )'N',        (char )'K'}, 
   {        (char )'F',        (char )'I',        (char )'R',        (char )'E'}, 
   {        (char )'F',        (char )'I',        (char )'R',        (char )'M'}, 
   {        (char )'F',        (char )'I',        (char )'S',        (char )'H'}, 
   {        (char )'F',        (char )'I',        (char )'S',        (char )'K'}, 
   {        (char )'F',        (char )'I',        (char )'S',        (char )'T'}, 
   {        (char )'F',        (char )'I',        (char )'T',        (char )'S'}, 
   {        (char )'F',        (char )'I',        (char )'V',        (char )'E'}, 
   {        (char )'F',        (char )'L',        (char )'A',        (char )'G'}, 
   {        (char )'F',        (char )'L',        (char )'A',        (char )'K'}, 
   {        (char )'F',        (char )'L',        (char )'A',        (char )'M'}, 
   {        (char )'F',        (char )'L',        (char )'A',        (char )'T'}, 
   {        (char )'F',        (char )'L',        (char )'A',        (char )'W'}, 
   {        (char )'F',        (char )'L',        (char )'E',        (char )'A'}, 
   {        (char )'F',        (char )'L',        (char )'E',        (char )'D'}, 
   {        (char )'F',        (char )'L',        (char )'E',        (char )'W'}, 
   {        (char )'F',        (char )'L',        (char )'I',        (char )'T'}, 
   {        (char )'F',        (char )'L',        (char )'O',        (char )'C'}, 
   {        (char )'F',        (char )'L',        (char )'O',        (char )'G'}, 
   {        (char )'F',        (char )'L',        (char )'O',        (char )'W'}, 
   {        (char )'F',        (char )'L',        (char )'U',        (char )'B'}, 
   {        (char )'F',        (char )'L',        (char )'U',        (char )'E'}, 
   {        (char )'F',        (char )'O',        (char )'A',        (char )'L'}, 
   {        (char )'F',        (char )'O',        (char )'A',        (char )'M'}, 
   {        (char )'F',        (char )'O',        (char )'G',        (char )'Y'}, 
   {        (char )'F',        (char )'O',        (char )'I',        (char )'L'}, 
   {        (char )'F',        (char )'O',        (char )'L',        (char )'D'}, 
   {        (char )'F',        (char )'O',        (char )'L',        (char )'K'}, 
   {        (char )'F',        (char )'O',        (char )'N',        (char )'D'}, 
   {        (char )'F',        (char )'O',        (char )'N',        (char )'T'}, 
   {        (char )'F',        (char )'O',        (char )'O',        (char )'D'}, 
   {        (char )'F',        (char )'O',        (char )'O',        (char )'L'}, 
   {        (char )'F',        (char )'O',        (char )'O',        (char )'T'}, 
   {        (char )'F',        (char )'O',        (char )'R',        (char )'D'}, 
   {        (char )'F',        (char )'O',        (char )'R',        (char )'E'}, 
   {        (char )'F',        (char )'O',        (char )'R',        (char )'K'}, 
   {        (char )'F',        (char )'O',        (char )'R',        (char )'M'}, 
   {        (char )'F',        (char )'O',        (char )'R',        (char )'T'}, 
   {        (char )'F',        (char )'O',        (char )'S',        (char )'S'}, 
   {        (char )'F',        (char )'O',        (char )'U',        (char )'L'}, 
   {        (char )'F',        (char )'O',        (char )'U',        (char )'R'}, 
   {        (char )'F',        (char )'O',        (char )'W',        (char )'L'}, 
   {        (char )'F',        (char )'R',        (char )'A',        (char )'U'}, 
   {        (char )'F',        (char )'R',        (char )'A',        (char )'Y'}, 
   {        (char )'F',        (char )'R',        (char )'E',        (char )'D'}, 
   {        (char )'F',        (char )'R',        (char )'E',        (char )'E'}, 
   {        (char )'F',        (char )'R',        (char )'E',        (char )'T'}, 
   {        (char )'F',        (char )'R',        (char )'E',        (char )'Y'}, 
   {        (char )'F',        (char )'R',        (char )'O',        (char )'G'}, 
   {        (char )'F',        (char )'R',        (char )'O',        (char )'M'}, 
   {        (char )'F',        (char )'U',        (char )'E',        (char )'L'}, 
   {        (char )'F',        (char )'U',        (char )'L',        (char )'L'}, 
   {        (char )'F',        (char )'U',        (char )'M',        (char )'E'}, 
   {        (char )'F',        (char )'U',        (char )'N',        (char )'D'}, 
   {        (char )'F',        (char )'U',        (char )'N',        (char )'K'}, 
   {        (char )'F',        (char )'U',        (char )'R',        (char )'Y'}, 
   {        (char )'F',        (char )'U',        (char )'S',        (char )'E'}, 
   {        (char )'F',        (char )'U',        (char )'S',        (char )'S'}, 
   {        (char )'G',        (char )'A',        (char )'F',        (char )'F'}, 
   {        (char )'G',        (char )'A',        (char )'G',        (char )'E'}, 
   {        (char )'G',        (char )'A',        (char )'I',        (char )'L'}, 
   {        (char )'G',        (char )'A',        (char )'I',        (char )'N'}, 
   {        (char )'G',        (char )'A',        (char )'I',        (char )'T'}, 
   {        (char )'G',        (char )'A',        (char )'L',        (char )'A'}, 
   {        (char )'G',        (char )'A',        (char )'L',        (char )'E'}, 
   {        (char )'G',        (char )'A',        (char )'L',        (char )'L'}, 
   {        (char )'G',        (char )'A',        (char )'L',        (char )'T'}, 
   {        (char )'G',        (char )'A',        (char )'M',        (char )'E'}, 
   {        (char )'G',        (char )'A',        (char )'N',        (char )'G'}, 
   {        (char )'G',        (char )'A',        (char )'R',        (char )'B'}, 
   {        (char )'G',        (char )'A',        (char )'R',        (char )'Y'}, 
   {        (char )'G',        (char )'A',        (char )'S',        (char )'H'}, 
   {        (char )'G',        (char )'A',        (char )'T',        (char )'E'}, 
   {        (char )'G',        (char )'A',        (char )'U',        (char )'L'}, 
   {        (char )'G',        (char )'A',        (char )'U',        (char )'R'}, 
   {        (char )'G',        (char )'A',        (char )'V',        (char )'E'}, 
   {        (char )'G',        (char )'A',        (char )'W',        (char )'K'}, 
   {        (char )'G',        (char )'E',        (char )'A',        (char )'R'}, 
   {        (char )'G',        (char )'E',        (char )'L',        (char )'D'}, 
   {        (char )'G',        (char )'E',        (char )'N',        (char )'E'}, 
   {        (char )'G',        (char )'E',        (char )'N',        (char )'T'}, 
   {        (char )'G',        (char )'E',        (char )'R',        (char )'M'}, 
   {        (char )'G',        (char )'E',        (char )'T',        (char )'S'}, 
   {        (char )'G',        (char )'I',        (char )'B',        (char )'E'}, 
   {        (char )'G',        (char )'I',        (char )'F',        (char )'T'}, 
   {        (char )'G',        (char )'I',        (char )'L',        (char )'D'}, 
   {        (char )'G',        (char )'I',        (char )'L',        (char )'L'}, 
   {        (char )'G',        (char )'I',        (char )'L',        (char )'T'}, 
   {        (char )'G',        (char )'I',        (char )'N',        (char )'A'}, 
   {        (char )'G',        (char )'I',        (char )'R',        (char )'D'}, 
   {        (char )'G',        (char )'I',        (char )'R',        (char )'L'}, 
   {        (char )'G',        (char )'I',        (char )'S',        (char )'T'}, 
   {        (char )'G',        (char )'I',        (char )'V',        (char )'E'}, 
   {        (char )'G',        (char )'L',        (char )'A',        (char )'D'}, 
   {        (char )'G',        (char )'L',        (char )'E',        (char )'E'}, 
   {        (char )'G',        (char )'L',        (char )'E',        (char )'N'}, 
   {        (char )'G',        (char )'L',        (char )'I',        (char )'B'}, 
   {        (char )'G',        (char )'L',        (char )'O',        (char )'B'}, 
   {        (char )'G',        (char )'L',        (char )'O',        (char )'M'}, 
   {        (char )'G',        (char )'L',        (char )'O',        (char )'W'}, 
   {        (char )'G',        (char )'L',        (char )'U',        (char )'E'}, 
   {        (char )'G',        (char )'L',        (char )'U',        (char )'M'}, 
   {        (char )'G',        (char )'L',        (char )'U',        (char )'T'}, 
   {        (char )'G',        (char )'O',        (char )'A',        (char )'D'}, 
   {        (char )'G',        (char )'O',        (char )'A',        (char )'L'}, 
   {        (char )'G',        (char )'O',        (char )'A',        (char )'T'}, 
   {        (char )'G',        (char )'O',        (char )'E',        (char )'R'}, 
   {        (char )'G',        (char )'O',        (char )'E',        (char )'S'}, 
   {        (char )'G',        (char )'O',        (char )'L',        (char )'D'}, 
   {        (char )'G',        (char )'O',        (char )'L',        (char )'F'}, 
   {        (char )'G',        (char )'O',        (char )'N',        (char )'E'}, 
   {        (char )'G',        (char )'O',        (char )'N',        (char )'G'}, 
   {        (char )'G',        (char )'O',        (char )'O',        (char )'D'}, 
   {        (char )'G',        (char )'O',        (char )'O',        (char )'F'}, 
   {        (char )'G',        (char )'O',        (char )'R',        (char )'E'}, 
   {        (char )'G',        (char )'O',        (char )'R',        (char )'Y'}, 
   {        (char )'G',        (char )'O',        (char )'S',        (char )'H'}, 
   {        (char )'G',        (char )'O',        (char )'U',        (char )'T'}, 
   {        (char )'G',        (char )'O',        (char )'W',        (char )'N'}, 
   {        (char )'G',        (char )'R',        (char )'A',        (char )'B'}, 
   {        (char )'G',        (char )'R',        (char )'A',        (char )'D'}, 
   {        (char )'G',        (char )'R',        (char )'A',        (char )'Y'}, 
   {        (char )'G',        (char )'R',        (char )'E',        (char )'G'}, 
   {        (char )'G',        (char )'R',        (char )'E',        (char )'W'}, 
   {        (char )'G',        (char )'R',        (char )'E',        (char )'Y'}, 
   {        (char )'G',        (char )'R',        (char )'I',        (char )'D'}, 
   {        (char )'G',        (char )'R',        (char )'I',        (char )'M'}, 
   {        (char )'G',        (char )'R',        (char )'I',        (char )'N'}, 
   {        (char )'G',        (char )'R',        (char )'I',        (char )'T'}, 
   {        (char )'G',        (char )'R',        (char )'O',        (char )'W'}, 
   {        (char )'G',        (char )'R',        (char )'U',        (char )'B'}, 
   {        (char )'G',        (char )'U',        (char )'L',        (char )'F'}, 
   {        (char )'G',        (char )'U',        (char )'L',        (char )'L'}, 
   {        (char )'G',        (char )'U',        (char )'N',        (char )'K'}, 
   {        (char )'G',        (char )'U',        (char )'R',        (char )'U'}, 
   {        (char )'G',        (char )'U',        (char )'S',        (char )'H'}, 
   {        (char )'G',        (char )'U',        (char )'S',        (char )'T'}, 
   {        (char )'G',        (char )'W',        (char )'E',        (char )'N'}, 
   {        (char )'G',        (char )'W',        (char )'Y',        (char )'N'}, 
   {        (char )'H',        (char )'A',        (char )'A',        (char )'G'}, 
   {        (char )'H',        (char )'A',        (char )'A',        (char )'S'}, 
   {        (char )'H',        (char )'A',        (char )'C',        (char )'K'}, 
   {        (char )'H',        (char )'A',        (char )'I',        (char )'L'}, 
   {        (char )'H',        (char )'A',        (char )'I',        (char )'R'}, 
   {        (char )'H',        (char )'A',        (char )'L',        (char )'E'}, 
   {        (char )'H',        (char )'A',        (char )'L',        (char )'F'}, 
   {        (char )'H',        (char )'A',        (char )'L',        (char )'L'}, 
   {        (char )'H',        (char )'A',        (char )'L',        (char )'O'}, 
   {        (char )'H',        (char )'A',        (char )'L',        (char )'T'}, 
   {        (char )'H',        (char )'A',        (char )'N',        (char )'D'}, 
   {        (char )'H',        (char )'A',        (char )'N',        (char )'G'}, 
   {        (char )'H',        (char )'A',        (char )'N',        (char )'K'}, 
   {        (char )'H',        (char )'A',        (char )'N',        (char )'S'}, 
   {        (char )'H',        (char )'A',        (char )'R',        (char )'D'}, 
   {        (char )'H',        (char )'A',        (char )'R',        (char )'K'}, 
   {        (char )'H',        (char )'A',        (char )'R',        (char )'M'}, 
   {        (char )'H',        (char )'A',        (char )'R',        (char )'T'}, 
   {        (char )'H',        (char )'A',        (char )'S',        (char )'H'}, 
   {        (char )'H',        (char )'A',        (char )'S',        (char )'T'}, 
   {        (char )'H',        (char )'A',        (char )'T',        (char )'E'}, 
   {        (char )'H',        (char )'A',        (char )'T',        (char )'H'}, 
   {        (char )'H',        (char )'A',        (char )'U',        (char )'L'}, 
   {        (char )'H',        (char )'A',        (char )'V',        (char )'E'}, 
   {        (char )'H',        (char )'A',        (char )'W',        (char )'K'}, 
   {        (char )'H',        (char )'A',        (char )'Y',        (char )'S'}, 
   {        (char )'H',        (char )'E',        (char )'A',        (char )'D'}, 
   {        (char )'H',        (char )'E',        (char )'A',        (char )'L'}, 
   {        (char )'H',        (char )'E',        (char )'A',        (char )'R'}, 
   {        (char )'H',        (char )'E',        (char )'A',        (char )'T'}, 
   {        (char )'H',        (char )'E',        (char )'B',        (char )'E'}, 
   {        (char )'H',        (char )'E',        (char )'C',        (char )'K'}, 
   {        (char )'H',        (char )'E',        (char )'E',        (char )'D'}, 
   {        (char )'H',        (char )'E',        (char )'E',        (char )'L'}, 
   {        (char )'H',        (char )'E',        (char )'F',        (char )'T'}, 
   {        (char )'H',        (char )'E',        (char )'L',        (char )'D'}, 
   {        (char )'H',        (char )'E',        (char )'L',        (char )'L'}, 
   {        (char )'H',        (char )'E',        (char )'L',        (char )'M'}, 
   {        (char )'H',        (char )'E',        (char )'R',        (char )'B'}, 
   {        (char )'H',        (char )'E',        (char )'R',        (char )'D'}, 
   {        (char )'H',        (char )'E',        (char )'R',        (char )'E'}, 
   {        (char )'H',        (char )'E',        (char )'R',        (char )'O'}, 
   {        (char )'H',        (char )'E',        (char )'R',        (char )'S'}, 
   {        (char )'H',        (char )'E',        (char )'S',        (char )'S'}, 
   {        (char )'H',        (char )'E',        (char )'W',        (char )'N'}, 
   {        (char )'H',        (char )'I',        (char )'C',        (char )'K'}, 
   {        (char )'H',        (char )'I',        (char )'D',        (char )'E'}, 
   {        (char )'H',        (char )'I',        (char )'G',        (char )'H'}, 
   {        (char )'H',        (char )'I',        (char )'K',        (char )'E'}, 
   {        (char )'H',        (char )'I',        (char )'L',        (char )'L'}, 
   {        (char )'H',        (char )'I',        (char )'L',        (char )'T'}, 
   {        (char )'H',        (char )'I',        (char )'N',        (char )'D'}, 
   {        (char )'H',        (char )'I',        (char )'N',        (char )'T'}, 
   {        (char )'H',        (char )'I',        (char )'R',        (char )'E'}, 
   {        (char )'H',        (char )'I',        (char )'S',        (char )'S'}, 
   {        (char )'H',        (char )'I',        (char )'V',        (char )'E'}, 
   {        (char )'H',        (char )'O',        (char )'B',        (char )'O'}, 
   {        (char )'H',        (char )'O',        (char )'C',        (char )'K'}, 
   {        (char )'H',        (char )'O',        (char )'F',        (char )'F'}, 
   {        (char )'H',        (char )'O',        (char )'L',        (char )'D'}, 
   {        (char )'H',        (char )'O',        (char )'L',        (char )'E'}, 
   {        (char )'H',        (char )'O',        (char )'L',        (char )'M'}, 
   {        (char )'H',        (char )'O',        (char )'L',        (char )'T'}, 
   {        (char )'H',        (char )'O',        (char )'M',        (char )'E'}, 
   {        (char )'H',        (char )'O',        (char )'N',        (char )'E'}, 
   {        (char )'H',        (char )'O',        (char )'N',        (char )'K'}, 
   {        (char )'H',        (char )'O',        (char )'O',        (char )'D'}, 
   {        (char )'H',        (char )'O',        (char )'O',        (char )'F'}, 
   {        (char )'H',        (char )'O',        (char )'O',        (char )'K'}, 
   {        (char )'H',        (char )'O',        (char )'O',        (char )'T'}, 
   {        (char )'H',        (char )'O',        (char )'R',        (char )'N'}, 
   {        (char )'H',        (char )'O',        (char )'S',        (char )'E'}, 
   {        (char )'H',        (char )'O',        (char )'S',        (char )'T'}, 
   {        (char )'H',        (char )'O',        (char )'U',        (char )'R'}, 
   {        (char )'H',        (char )'O',        (char )'V',        (char )'E'}, 
   {        (char )'H',        (char )'O',        (char )'W',        (char )'E'}, 
   {        (char )'H',        (char )'O',        (char )'W',        (char )'L'}, 
   {        (char )'H',        (char )'O',        (char )'Y',        (char )'T'}, 
   {        (char )'H',        (char )'U',        (char )'C',        (char )'K'}, 
   {        (char )'H',        (char )'U',        (char )'E',        (char )'D'}, 
   {        (char )'H',        (char )'U',        (char )'F',        (char )'F'}, 
   {        (char )'H',        (char )'U',        (char )'G',        (char )'E'}, 
   {        (char )'H',        (char )'U',        (char )'G',        (char )'H'}, 
   {        (char )'H',        (char )'U',        (char )'G',        (char )'O'}, 
   {        (char )'H',        (char )'U',        (char )'L',        (char )'K'}, 
   {        (char )'H',        (char )'U',        (char )'L',        (char )'L'}, 
   {        (char )'H',        (char )'U',        (char )'N',        (char )'K'}, 
   {        (char )'H',        (char )'U',        (char )'N',        (char )'T'}, 
   {        (char )'H',        (char )'U',        (char )'R',        (char )'D'}, 
   {        (char )'H',        (char )'U',        (char )'R',        (char )'L'}, 
   {        (char )'H',        (char )'U',        (char )'R',        (char )'T'}, 
   {        (char )'H',        (char )'U',        (char )'S',        (char )'H'}, 
   {        (char )'H',        (char )'Y',        (char )'D',        (char )'E'}, 
   {        (char )'H',        (char )'Y',        (char )'M',        (char )'N'}, 
   {        (char )'I',        (char )'B',        (char )'I',        (char )'S'}, 
   {        (char )'I',        (char )'C',        (char )'O',        (char )'N'}, 
   {        (char )'I',        (char )'D',        (char )'E',        (char )'A'}, 
   {        (char )'I',        (char )'D',        (char )'L',        (char )'E'}, 
   {        (char )'I',        (char )'F',        (char )'F',        (char )'Y'}, 
   {        (char )'I',        (char )'N',        (char )'C',        (char )'A'}, 
   {        (char )'I',        (char )'N',        (char )'C',        (char )'H'}, 
   {        (char )'I',        (char )'N',        (char )'T',        (char )'O'}, 
   {        (char )'I',        (char )'O',        (char )'N',        (char )'S'}, 
   {        (char )'I',        (char )'O',        (char )'T',        (char )'A'}, 
   {        (char )'I',        (char )'O',        (char )'W',        (char )'A'}, 
   {        (char )'I',        (char )'R',        (char )'I',        (char )'S'}, 
   {        (char )'I',        (char )'R',        (char )'M',        (char )'A'}, 
   {        (char )'I',        (char )'R',        (char )'O',        (char )'N'}, 
   {        (char )'I',        (char )'S',        (char )'L',        (char )'E'}, 
   {        (char )'I',        (char )'T',        (char )'C',        (char )'H'}, 
   {        (char )'I',        (char )'T',        (char )'E',        (char )'M'}, 
   {        (char )'I',        (char )'V',        (char )'A',        (char )'N'}, 
   {        (char )'J',        (char )'A',        (char )'C',        (char )'K'}, 
   {        (char )'J',        (char )'A',        (char )'D',        (char )'E'}, 
   {        (char )'J',        (char )'A',        (char )'I',        (char )'L'}, 
   {        (char )'J',        (char )'A',        (char )'K',        (char )'E'}, 
   {        (char )'J',        (char )'A',        (char )'N',        (char )'E'}, 
   {        (char )'J',        (char )'A',        (char )'V',        (char )'A'}, 
   {        (char )'J',        (char )'E',        (char )'A',        (char )'N'}, 
   {        (char )'J',        (char )'E',        (char )'F',        (char )'F'}, 
   {        (char )'J',        (char )'E',        (char )'R',        (char )'K'}, 
   {        (char )'J',        (char )'E',        (char )'S',        (char )'S'}, 
   {        (char )'J',        (char )'E',        (char )'S',        (char )'T'}, 
   {        (char )'J',        (char )'I',        (char )'B',        (char )'E'}, 
   {        (char )'J',        (char )'I',        (char )'L',        (char )'L'}, 
   {        (char )'J',        (char )'I',        (char )'L',        (char )'T'}, 
   {        (char )'J',        (char )'I',        (char )'V',        (char )'E'}, 
   {        (char )'J',        (char )'O',        (char )'A',        (char )'N'}, 
   {        (char )'J',        (char )'O',        (char )'B',        (char )'S'}, 
   {        (char )'J',        (char )'O',        (char )'C',        (char )'K'}, 
   {        (char )'J',        (char )'O',        (char )'E',        (char )'L'}, 
   {        (char )'J',        (char )'O',        (char )'E',        (char )'Y'}, 
   {        (char )'J',        (char )'O',        (char )'H',        (char )'N'}, 
   {        (char )'J',        (char )'O',        (char )'I',        (char )'N'}, 
   {        (char )'J',        (char )'O',        (char )'K',        (char )'E'}, 
   {        (char )'J',        (char )'O',        (char )'L',        (char )'T'}, 
   {        (char )'J',        (char )'O',        (char )'V',        (char )'E'}, 
   {        (char )'J',        (char )'U',        (char )'D',        (char )'D'}, 
   {        (char )'J',        (char )'U',        (char )'D',        (char )'E'}, 
   {        (char )'J',        (char )'U',        (char )'D',        (char )'O'}, 
   {        (char )'J',        (char )'U',        (char )'D',        (char )'Y'}, 
   {        (char )'J',        (char )'U',        (char )'J',        (char )'U'}, 
   {        (char )'J',        (char )'U',        (char )'K',        (char )'E'}, 
   {        (char )'J',        (char )'U',        (char )'L',        (char )'Y'}, 
   {        (char )'J',        (char )'U',        (char )'N',        (char )'E'}, 
   {        (char )'J',        (char )'U',        (char )'N',        (char )'K'}, 
   {        (char )'J',        (char )'U',        (char )'N',        (char )'O'}, 
   {        (char )'J',        (char )'U',        (char )'R',        (char )'Y'}, 
   {        (char )'J',        (char )'U',        (char )'S',        (char )'T'}, 
   {        (char )'J',        (char )'U',        (char )'T',        (char )'E'}, 
   {        (char )'K',        (char )'A',        (char )'H',        (char )'N'}, 
   {        (char )'K',        (char )'A',        (char )'L',        (char )'E'}, 
   {        (char )'K',        (char )'A',        (char )'N',        (char )'E'}, 
   {        (char )'K',        (char )'A',        (char )'N',        (char )'T'}, 
   {        (char )'K',        (char )'A',        (char )'R',        (char )'L'}, 
   {        (char )'K',        (char )'A',        (char )'T',        (char )'E'}, 
   {        (char )'K',        (char )'E',        (char )'E',        (char )'L'}, 
   {        (char )'K',        (char )'E',        (char )'E',        (char )'N'}, 
   {        (char )'K',        (char )'E',        (char )'N',        (char )'O'}, 
   {        (char )'K',        (char )'E',        (char )'N',        (char )'T'}, 
   {        (char )'K',        (char )'E',        (char )'R',        (char )'N'}, 
   {        (char )'K',        (char )'E',        (char )'R',        (char )'R'}, 
   {        (char )'K',        (char )'E',        (char )'Y',        (char )'S'}, 
   {        (char )'K',        (char )'I',        (char )'C',        (char )'K'}, 
   {        (char )'K',        (char )'I',        (char )'L',        (char )'L'}, 
   {        (char )'K',        (char )'I',        (char )'N',        (char )'D'}, 
   {        (char )'K',        (char )'I',        (char )'N',        (char )'G'}, 
   {        (char )'K',        (char )'I',        (char )'R',        (char )'K'}, 
   {        (char )'K',        (char )'I',        (char )'S',        (char )'S'}, 
   {        (char )'K',        (char )'I',        (char )'T',        (char )'E'}, 
   {        (char )'K',        (char )'L',        (char )'A',        (char )'N'}, 
   {        (char )'K',        (char )'N',        (char )'E',        (char )'E'}, 
   {        (char )'K',        (char )'N',        (char )'E',        (char )'W'}, 
   {        (char )'K',        (char )'N',        (char )'I',        (char )'T'}, 
   {        (char )'K',        (char )'N',        (char )'O',        (char )'B'}, 
   {        (char )'K',        (char )'N',        (char )'O',        (char )'T'}, 
   {        (char )'K',        (char )'N',        (char )'O',        (char )'W'}, 
   {        (char )'K',        (char )'O',        (char )'C',        (char )'H'}, 
   {        (char )'K',        (char )'O',        (char )'N',        (char )'G'}, 
   {        (char )'K',        (char )'U',        (char )'D',        (char )'O'}, 
   {        (char )'K',        (char )'U',        (char )'R',        (char )'D'}, 
   {        (char )'K',        (char )'U',        (char )'R',        (char )'T'}, 
   {        (char )'K',        (char )'Y',        (char )'L',        (char )'E'}, 
   {        (char )'L',        (char )'A',        (char )'C',        (char )'E'}, 
   {        (char )'L',        (char )'A',        (char )'C',        (char )'K'}, 
   {        (char )'L',        (char )'A',        (char )'C',        (char )'Y'}, 
   {        (char )'L',        (char )'A',        (char )'D',        (char )'Y'}, 
   {        (char )'L',        (char )'A',        (char )'I',        (char )'D'}, 
   {        (char )'L',        (char )'A',        (char )'I',        (char )'N'}, 
   {        (char )'L',        (char )'A',        (char )'I',        (char )'R'}, 
   {        (char )'L',        (char )'A',        (char )'K',        (char )'E'}, 
   {        (char )'L',        (char )'A',        (char )'M',        (char )'B'}, 
   {        (char )'L',        (char )'A',        (char )'M',        (char )'E'}, 
   {        (char )'L',        (char )'A',        (char )'N',        (char )'D'}, 
   {        (char )'L',        (char )'A',        (char )'N',        (char )'E'}, 
   {        (char )'L',        (char )'A',        (char )'N',        (char )'G'}, 
   {        (char )'L',        (char )'A',        (char )'R',        (char )'D'}, 
   {        (char )'L',        (char )'A',        (char )'R',        (char )'K'}, 
   {        (char )'L',        (char )'A',        (char )'S',        (char )'S'}, 
   {        (char )'L',        (char )'A',        (char )'S',        (char )'T'}, 
   {        (char )'L',        (char )'A',        (char )'T',        (char )'E'}, 
   {        (char )'L',        (char )'A',        (char )'U',        (char )'D'}, 
   {        (char )'L',        (char )'A',        (char )'V',        (char )'A'}, 
   {        (char )'L',        (char )'A',        (char )'W',        (char )'N'}, 
   {        (char )'L',        (char )'A',        (char )'W',        (char )'S'}, 
   {        (char )'L',        (char )'A',        (char )'Y',        (char )'S'}, 
   {        (char )'L',        (char )'E',        (char )'A',        (char )'D'}, 
   {        (char )'L',        (char )'E',        (char )'A',        (char )'F'}, 
   {        (char )'L',        (char )'E',        (char )'A',        (char )'K'}, 
   {        (char )'L',        (char )'E',        (char )'A',        (char )'N'}, 
   {        (char )'L',        (char )'E',        (char )'A',        (char )'R'}, 
   {        (char )'L',        (char )'E',        (char )'E',        (char )'K'}, 
   {        (char )'L',        (char )'E',        (char )'E',        (char )'R'}, 
   {        (char )'L',        (char )'E',        (char )'F',        (char )'T'}, 
   {        (char )'L',        (char )'E',        (char )'N',        (char )'D'}, 
   {        (char )'L',        (char )'E',        (char )'N',        (char )'S'}, 
   {        (char )'L',        (char )'E',        (char )'N',        (char )'T'}, 
   {        (char )'L',        (char )'E',        (char )'O',        (char )'N'}, 
   {        (char )'L',        (char )'E',        (char )'S',        (char )'K'}, 
   {        (char )'L',        (char )'E',        (char )'S',        (char )'S'}, 
   {        (char )'L',        (char )'E',        (char )'S',        (char )'T'}, 
   {        (char )'L',        (char )'E',        (char )'T',        (char )'S'}, 
   {        (char )'L',        (char )'I',        (char )'A',        (char )'R'}, 
   {        (char )'L',        (char )'I',        (char )'C',        (char )'E'}, 
   {        (char )'L',        (char )'I',        (char )'C',        (char )'K'}, 
   {        (char )'L',        (char )'I',        (char )'E',        (char )'D'}, 
   {        (char )'L',        (char )'I',        (char )'E',        (char )'N'}, 
   {        (char )'L',        (char )'I',        (char )'E',        (char )'S'}, 
   {        (char )'L',        (char )'I',        (char )'E',        (char )'U'}, 
   {        (char )'L',        (char )'I',        (char )'F',        (char )'E'}, 
   {        (char )'L',        (char )'I',        (char )'F',        (char )'T'}, 
   {        (char )'L',        (char )'I',        (char )'K',        (char )'E'}, 
   {        (char )'L',        (char )'I',        (char )'L',        (char )'A'}, 
   {        (char )'L',        (char )'I',        (char )'L',        (char )'T'}, 
   {        (char )'L',        (char )'I',        (char )'L',        (char )'Y'}, 
   {        (char )'L',        (char )'I',        (char )'M',        (char )'A'}, 
   {        (char )'L',        (char )'I',        (char )'M',        (char )'B'}, 
   {        (char )'L',        (char )'I',        (char )'M',        (char )'E'}, 
   {        (char )'L',        (char )'I',        (char )'N',        (char )'D'}, 
   {        (char )'L',        (char )'I',        (char )'N',        (char )'E'}, 
   {        (char )'L',        (char )'I',        (char )'N',        (char )'K'}, 
   {        (char )'L',        (char )'I',        (char )'N',        (char )'T'}, 
   {        (char )'L',        (char )'I',        (char )'O',        (char )'N'}, 
   {        (char )'L',        (char )'I',        (char )'S',        (char )'A'}, 
   {        (char )'L',        (char )'I',        (char )'S',        (char )'T'}, 
   {        (char )'L',        (char )'I',        (char )'V',        (char )'E'}, 
   {        (char )'L',        (char )'O',        (char )'A',        (char )'D'}, 
   {        (char )'L',        (char )'O',        (char )'A',        (char )'F'}, 
   {        (char )'L',        (char )'O',        (char )'A',        (char )'M'}, 
   {        (char )'L',        (char )'O',        (char )'A',        (char )'N'}, 
   {        (char )'L',        (char )'O',        (char )'C',        (char )'K'}, 
   {        (char )'L',        (char )'O',        (char )'F',        (char )'T'}, 
   {        (char )'L',        (char )'O',        (char )'G',        (char )'E'}, 
   {        (char )'L',        (char )'O',        (char )'I',        (char )'S'}, 
   {        (char )'L',        (char )'O',        (char )'L',        (char )'A'}, 
   {        (char )'L',        (char )'O',        (char )'N',        (char )'E'}, 
   {        (char )'L',        (char )'O',        (char )'N',        (char )'G'}, 
   {        (char )'L',        (char )'O',        (char )'O',        (char )'K'}, 
   {        (char )'L',        (char )'O',        (char )'O',        (char )'N'}, 
   {        (char )'L',        (char )'O',        (char )'O',        (char )'T'}, 
   {        (char )'L',        (char )'O',        (char )'R',        (char )'D'}, 
   {        (char )'L',        (char )'O',        (char )'R',        (char )'E'}, 
   {        (char )'L',        (char )'O',        (char )'S',        (char )'E'}, 
   {        (char )'L',        (char )'O',        (char )'S',        (char )'S'}, 
   {        (char )'L',        (char )'O',        (char )'S',        (char )'T'}, 
   {        (char )'L',        (char )'O',        (char )'U',        (char )'D'}, 
   {        (char )'L',        (char )'O',        (char )'V',        (char )'E'}, 
   {        (char )'L',        (char )'O',        (char )'W',        (char )'E'}, 
   {        (char )'L',        (char )'U',        (char )'C',        (char )'K'}, 
   {        (char )'L',        (char )'U',        (char )'C',        (char )'Y'}, 
   {        (char )'L',        (char )'U',        (char )'G',        (char )'E'}, 
   {        (char )'L',        (char )'U',        (char )'K',        (char )'E'}, 
   {        (char )'L',        (char )'U',        (char )'L',        (char )'U'}, 
   {        (char )'L',        (char )'U',        (char )'N',        (char )'D'}, 
   {        (char )'L',        (char )'U',        (char )'N',        (char )'G'}, 
   {        (char )'L',        (char )'U',        (char )'R',        (char )'A'}, 
   {        (char )'L',        (char )'U',        (char )'R',        (char )'E'}, 
   {        (char )'L',        (char )'U',        (char )'R',        (char )'K'}, 
   {        (char )'L',        (char )'U',        (char )'S',        (char )'H'}, 
   {        (char )'L',        (char )'U',        (char )'S',        (char )'T'}, 
   {        (char )'L',        (char )'Y',        (char )'L',        (char )'E'}, 
   {        (char )'L',        (char )'Y',        (char )'N',        (char )'N'}, 
   {        (char )'L',        (char )'Y',        (char )'O',        (char )'N'}, 
   {        (char )'L',        (char )'Y',        (char )'R',        (char )'A'}, 
   {        (char )'M',        (char )'A',        (char )'C',        (char )'E'}, 
   {        (char )'M',        (char )'A',        (char )'D',        (char )'E'}, 
   {        (char )'M',        (char )'A',        (char )'G',        (char )'I'}, 
   {        (char )'M',        (char )'A',        (char )'I',        (char )'D'}, 
   {        (char )'M',        (char )'A',        (char )'I',        (char )'L'}, 
   {        (char )'M',        (char )'A',        (char )'I',        (char )'N'}, 
   {        (char )'M',        (char )'A',        (char )'K',        (char )'E'}, 
   {        (char )'M',        (char )'A',        (char )'L',        (char )'E'}, 
   {        (char )'M',        (char )'A',        (char )'L',        (char )'I'}, 
   {        (char )'M',        (char )'A',        (char )'L',        (char )'L'}, 
   {        (char )'M',        (char )'A',        (char )'L',        (char )'T'}, 
   {        (char )'M',        (char )'A',        (char )'N',        (char )'A'}, 
   {        (char )'M',        (char )'A',        (char )'N',        (char )'N'}, 
   {        (char )'M',        (char )'A',        (char )'N',        (char )'Y'}, 
   {        (char )'M',        (char )'A',        (char )'R',        (char )'C'}, 
   {        (char )'M',        (char )'A',        (char )'R',        (char )'E'}, 
   {        (char )'M',        (char )'A',        (char )'R',        (char )'K'}, 
   {        (char )'M',        (char )'A',        (char )'R',        (char )'S'}, 
   {        (char )'M',        (char )'A',        (char )'R',        (char )'T'}, 
   {        (char )'M',        (char )'A',        (char )'R',        (char )'Y'}, 
   {        (char )'M',        (char )'A',        (char )'S',        (char )'H'}, 
   {        (char )'M',        (char )'A',        (char )'S',        (char )'K'}, 
   {        (char )'M',        (char )'A',        (char )'S',        (char )'S'}, 
   {        (char )'M',        (char )'A',        (char )'S',        (char )'T'}, 
   {        (char )'M',        (char )'A',        (char )'T',        (char )'E'}, 
   {        (char )'M',        (char )'A',        (char )'T',        (char )'H'}, 
   {        (char )'M',        (char )'A',        (char )'U',        (char )'L'}, 
   {        (char )'M',        (char )'A',        (char )'Y',        (char )'O'}, 
   {        (char )'M',        (char )'E',        (char )'A',        (char )'D'}, 
   {        (char )'M',        (char )'E',        (char )'A',        (char )'L'}, 
   {        (char )'M',        (char )'E',        (char )'A',        (char )'N'}, 
   {        (char )'M',        (char )'E',        (char )'A',        (char )'T'}, 
   {        (char )'M',        (char )'E',        (char )'E',        (char )'K'}, 
   {        (char )'M',        (char )'E',        (char )'E',        (char )'T'}, 
   {        (char )'M',        (char )'E',        (char )'L',        (char )'D'}, 
   {        (char )'M',        (char )'E',        (char )'L',        (char )'T'}, 
   {        (char )'M',        (char )'E',        (char )'M',        (char )'O'}, 
   {        (char )'M',        (char )'E',        (char )'N',        (char )'D'}, 
   {        (char )'M',        (char )'E',        (char )'N',        (char )'U'}, 
   {        (char )'M',        (char )'E',        (char )'R',        (char )'T'}, 
   {        (char )'M',        (char )'E',        (char )'S',        (char )'H'}, 
   {        (char )'M',        (char )'E',        (char )'S',        (char )'S'}, 
   {        (char )'M',        (char )'I',        (char )'C',        (char )'E'}, 
   {        (char )'M',        (char )'I',        (char )'K',        (char )'E'}, 
   {        (char )'M',        (char )'I',        (char )'L',        (char )'D'}, 
   {        (char )'M',        (char )'I',        (char )'L',        (char )'E'}, 
   {        (char )'M',        (char )'I',        (char )'L',        (char )'K'}, 
   {        (char )'M',        (char )'I',        (char )'L',        (char )'L'}, 
   {        (char )'M',        (char )'I',        (char )'L',        (char )'T'}, 
   {        (char )'M',        (char )'I',        (char )'M',        (char )'I'}, 
   {        (char )'M',        (char )'I',        (char )'N',        (char )'D'}, 
   {        (char )'M',        (char )'I',        (char )'N',        (char )'E'}, 
   {        (char )'M',        (char )'I',        (char )'N',        (char )'I'}, 
   {        (char )'M',        (char )'I',        (char )'N',        (char )'K'}, 
   {        (char )'M',        (char )'I',        (char )'N',        (char )'T'}, 
   {        (char )'M',        (char )'I',        (char )'R',        (char )'E'}, 
   {        (char )'M',        (char )'I',        (char )'S',        (char )'S'}, 
   {        (char )'M',        (char )'I',        (char )'S',        (char )'T'}, 
   {        (char )'M',        (char )'I',        (char )'T',        (char )'E'}, 
   {        (char )'M',        (char )'I',        (char )'T',        (char )'T'}, 
   {        (char )'M',        (char )'O',        (char )'A',        (char )'N'}, 
   {        (char )'M',        (char )'O',        (char )'A',        (char )'T'}, 
   {        (char )'M',        (char )'O',        (char )'C',        (char )'K'}, 
   {        (char )'M',        (char )'O',        (char )'D',        (char )'E'}, 
   {        (char )'M',        (char )'O',        (char )'L',        (char )'D'}, 
   {        (char )'M',        (char )'O',        (char )'L',        (char )'E'}, 
   {        (char )'M',        (char )'O',        (char )'L',        (char )'L'}, 
   {        (char )'M',        (char )'O',        (char )'L',        (char )'T'}, 
   {        (char )'M',        (char )'O',        (char )'N',        (char )'A'}, 
   {        (char )'M',        (char )'O',        (char )'N',        (char )'K'}, 
   {        (char )'M',        (char )'O',        (char )'N',        (char )'T'}, 
   {        (char )'M',        (char )'O',        (char )'O',        (char )'D'}, 
   {        (char )'M',        (char )'O',        (char )'O',        (char )'N'}, 
   {        (char )'M',        (char )'O',        (char )'O',        (char )'R'}, 
   {        (char )'M',        (char )'O',        (char )'O',        (char )'T'}, 
   {        (char )'M',        (char )'O',        (char )'R',        (char )'E'}, 
   {        (char )'M',        (char )'O',        (char )'R',        (char )'N'}, 
   {        (char )'M',        (char )'O',        (char )'R',        (char )'T'}, 
   {        (char )'M',        (char )'O',        (char )'S',        (char )'S'}, 
   {        (char )'M',        (char )'O',        (char )'S',        (char )'T'}, 
   {        (char )'M',        (char )'O',        (char )'T',        (char )'H'}, 
   {        (char )'M',        (char )'O',        (char )'V',        (char )'E'}, 
   {        (char )'M',        (char )'U',        (char )'C',        (char )'H'}, 
   {        (char )'M',        (char )'U',        (char )'C',        (char )'K'}, 
   {        (char )'M',        (char )'U',        (char )'D',        (char )'D'}, 
   {        (char )'M',        (char )'U',        (char )'F',        (char )'F'}, 
   {        (char )'M',        (char )'U',        (char )'L',        (char )'E'}, 
   {        (char )'M',        (char )'U',        (char )'L',        (char )'L'}, 
   {        (char )'M',        (char )'U',        (char )'R',        (char )'K'}, 
   {        (char )'M',        (char )'U',        (char )'S',        (char )'H'}, 
   {        (char )'M',        (char )'U',        (char )'S',        (char )'T'}, 
   {        (char )'M',        (char )'U',        (char )'T',        (char )'E'}, 
   {        (char )'M',        (char )'U',        (char )'T',        (char )'T'}, 
   {        (char )'M',        (char )'Y',        (char )'R',        (char )'A'}, 
   {        (char )'M',        (char )'Y',        (char )'T',        (char )'H'}, 
   {        (char )'N',        (char )'A',        (char )'G',        (char )'Y'}, 
   {        (char )'N',        (char )'A',        (char )'I',        (char )'L'}, 
   {        (char )'N',        (char )'A',        (char )'I',        (char )'R'}, 
   {        (char )'N',        (char )'A',        (char )'M',        (char )'E'}, 
   {        (char )'N',        (char )'A',        (char )'R',        (char )'Y'}, 
   {        (char )'N',        (char )'A',        (char )'S',        (char )'H'}, 
   {        (char )'N',        (char )'A',        (char )'V',        (char )'E'}, 
   {        (char )'N',        (char )'A',        (char )'V',        (char )'Y'}, 
   {        (char )'N',        (char )'E',        (char )'A',        (char )'L'}, 
   {        (char )'N',        (char )'E',        (char )'A',        (char )'R'}, 
   {        (char )'N',        (char )'E',        (char )'A',        (char )'T'}, 
   {        (char )'N',        (char )'E',        (char )'C',        (char )'K'}, 
   {        (char )'N',        (char )'E',        (char )'E',        (char )'D'}, 
   {        (char )'N',        (char )'E',        (char )'I',        (char )'L'}, 
   {        (char )'N',        (char )'E',        (char )'L',        (char )'L'}, 
   {        (char )'N',        (char )'E',        (char )'O',        (char )'N'}, 
   {        (char )'N',        (char )'E',        (char )'R',        (char )'O'}, 
   {        (char )'N',        (char )'E',        (char )'S',        (char )'S'}, 
   {        (char )'N',        (char )'E',        (char )'S',        (char )'T'}, 
   {        (char )'N',        (char )'E',        (char )'W',        (char )'S'}, 
   {        (char )'N',        (char )'E',        (char )'W',        (char )'T'}, 
   {        (char )'N',        (char )'I',        (char )'B',        (char )'S'}, 
   {        (char )'N',        (char )'I',        (char )'C',        (char )'E'}, 
   {        (char )'N',        (char )'I',        (char )'C',        (char )'K'}, 
   {        (char )'N',        (char )'I',        (char )'L',        (char )'E'}, 
   {        (char )'N',        (char )'I',        (char )'N',        (char )'A'}, 
   {        (char )'N',        (char )'I',        (char )'N',        (char )'E'}, 
   {        (char )'N',        (char )'O',        (char )'A',        (char )'H'}, 
   {        (char )'N',        (char )'O',        (char )'D',        (char )'E'}, 
   {        (char )'N',        (char )'O',        (char )'E',        (char )'L'}, 
   {        (char )'N',        (char )'O',        (char )'L',        (char )'L'}, 
   {        (char )'N',        (char )'O',        (char )'N',        (char )'E'}, 
   {        (char )'N',        (char )'O',        (char )'O',        (char )'K'}, 
   {        (char )'N',        (char )'O',        (char )'O',        (char )'N'}, 
   {        (char )'N',        (char )'O',        (char )'R',        (char )'M'}, 
   {        (char )'N',        (char )'O',        (char )'S',        (char )'E'}, 
   {        (char )'N',        (char )'O',        (char )'T',        (char )'E'}, 
   {        (char )'N',        (char )'O',        (char )'U',        (char )'N'}, 
   {        (char )'N',        (char )'O',        (char )'V',        (char )'A'}, 
   {        (char )'N',        (char )'U',        (char )'D',        (char )'E'}, 
   {        (char )'N',        (char )'U',        (char )'L',        (char )'L'}, 
   {        (char )'N',        (char )'U',        (char )'M',        (char )'B'}, 
   {        (char )'O',        (char )'A',        (char )'T',        (char )'H'}, 
   {        (char )'O',        (char )'B',        (char )'E',        (char )'Y'}, 
   {        (char )'O',        (char )'B',        (char )'O',        (char )'E'}, 
   {        (char )'O',        (char )'D',        (char )'I',        (char )'N'}, 
   {        (char )'O',        (char )'H',        (char )'I',        (char )'O'}, 
   {        (char )'O',        (char )'I',        (char )'L',        (char )'Y'}, 
   {        (char )'O',        (char )'I',        (char )'N',        (char )'T'}, 
   {        (char )'O',        (char )'K',        (char )'A',        (char )'Y'}, 
   {        (char )'O',        (char )'L',        (char )'A',        (char )'F'}, 
   {        (char )'O',        (char )'L',        (char )'D',        (char )'Y'}, 
   {        (char )'O',        (char )'L',        (char )'G',        (char )'A'}, 
   {        (char )'O',        (char )'L',        (char )'I',        (char )'N'}, 
   {        (char )'O',        (char )'M',        (char )'A',        (char )'N'}, 
   {        (char )'O',        (char )'M',        (char )'E',        (char )'N'}, 
   {        (char )'O',        (char )'M',        (char )'I',        (char )'T'}, 
   {        (char )'O',        (char )'N',        (char )'C',        (char )'E'}, 
   {        (char )'O',        (char )'N',        (char )'E',        (char )'S'}, 
   {        (char )'O',        (char )'N',        (char )'L',        (char )'Y'}, 
   {        (char )'O',        (char )'N',        (char )'T',        (char )'O'}, 
   {        (char )'O',        (char )'N',        (char )'U',        (char )'S'}, 
   {        (char )'O',        (char )'R',        (char )'A',        (char )'L'}, 
   {        (char )'O',        (char )'R',        (char )'G',        (char )'Y'}, 
   {        (char )'O',        (char )'S',        (char )'L',        (char )'O'}, 
   {        (char )'O',        (char )'T',        (char )'I',        (char )'S'}, 
   {        (char )'O',        (char )'T',        (char )'T',        (char )'O'}, 
   {        (char )'O',        (char )'U',        (char )'C',        (char )'H'}, 
   {        (char )'O',        (char )'U',        (char )'S',        (char )'T'}, 
   {        (char )'O',        (char )'U',        (char )'T',        (char )'S'}, 
   {        (char )'O',        (char )'V',        (char )'A',        (char )'L'}, 
   {        (char )'O',        (char )'V',        (char )'E',        (char )'N'}, 
   {        (char )'O',        (char )'V',        (char )'E',        (char )'R'}, 
   {        (char )'O',        (char )'W',        (char )'L',        (char )'Y'}, 
   {        (char )'O',        (char )'W',        (char )'N',        (char )'S'}, 
   {        (char )'Q',        (char )'U',        (char )'A',        (char )'D'}, 
   {        (char )'Q',        (char )'U',        (char )'I',        (char )'T'}, 
   {        (char )'Q',        (char )'U',        (char )'O',        (char )'D'}, 
   {        (char )'R',        (char )'A',        (char )'C',        (char )'E'}, 
   {        (char )'R',        (char )'A',        (char )'C',        (char )'K'}, 
   {        (char )'R',        (char )'A',        (char )'C',        (char )'Y'}, 
   {        (char )'R',        (char )'A',        (char )'F',        (char )'T'}, 
   {        (char )'R',        (char )'A',        (char )'G',        (char )'E'}, 
   {        (char )'R',        (char )'A',        (char )'I',        (char )'D'}, 
   {        (char )'R',        (char )'A',        (char )'I',        (char )'L'}, 
   {        (char )'R',        (char )'A',        (char )'I',        (char )'N'}, 
   {        (char )'R',        (char )'A',        (char )'K',        (char )'E'}, 
   {        (char )'R',        (char )'A',        (char )'N',        (char )'K'}, 
   {        (char )'R',        (char )'A',        (char )'N',        (char )'T'}, 
   {        (char )'R',        (char )'A',        (char )'R',        (char )'E'}, 
   {        (char )'R',        (char )'A',        (char )'S',        (char )'H'}, 
   {        (char )'R',        (char )'A',        (char )'T',        (char )'E'}, 
   {        (char )'R',        (char )'A',        (char )'V',        (char )'E'}, 
   {        (char )'R',        (char )'A',        (char )'Y',        (char )'S'}, 
   {        (char )'R',        (char )'E',        (char )'A',        (char )'D'}, 
   {        (char )'R',        (char )'E',        (char )'A',        (char )'L'}, 
   {        (char )'R',        (char )'E',        (char )'A',        (char )'M'}, 
   {        (char )'R',        (char )'E',        (char )'A',        (char )'R'}, 
   {        (char )'R',        (char )'E',        (char )'C',        (char )'K'}, 
   {        (char )'R',        (char )'E',        (char )'E',        (char )'D'}, 
   {        (char )'R',        (char )'E',        (char )'E',        (char )'F'}, 
   {        (char )'R',        (char )'E',        (char )'E',        (char )'K'}, 
   {        (char )'R',        (char )'E',        (char )'E',        (char )'L'}, 
   {        (char )'R',        (char )'E',        (char )'I',        (char )'D'}, 
   {        (char )'R',        (char )'E',        (char )'I',        (char )'N'}, 
   {        (char )'R',        (char )'E',        (char )'N',        (char )'A'}, 
   {        (char )'R',        (char )'E',        (char )'N',        (char )'D'}, 
   {        (char )'R',        (char )'E',        (char )'N',        (char )'T'}, 
   {        (char )'R',        (char )'E',        (char )'S',        (char )'T'}, 
   {        (char )'R',        (char )'I',        (char )'C',        (char )'E'}, 
   {        (char )'R',        (char )'I',        (char )'C',        (char )'H'}, 
   {        (char )'R',        (char )'I',        (char )'C',        (char )'K'}, 
   {        (char )'R',        (char )'I',        (char )'D',        (char )'E'}, 
   {        (char )'R',        (char )'I',        (char )'F',        (char )'T'}, 
   {        (char )'R',        (char )'I',        (char )'L',        (char )'L'}, 
   {        (char )'R',        (char )'I',        (char )'M',        (char )'E'}, 
   {        (char )'R',        (char )'I',        (char )'N',        (char )'G'}, 
   {        (char )'R',        (char )'I',        (char )'N',        (char )'K'}, 
   {        (char )'R',        (char )'I',        (char )'S',        (char )'E'}, 
   {        (char )'R',        (char )'I',        (char )'S',        (char )'K'}, 
   {        (char )'R',        (char )'I',        (char )'T',        (char )'E'}, 
   {        (char )'R',        (char )'O',        (char )'A',        (char )'D'}, 
   {        (char )'R',        (char )'O',        (char )'A',        (char )'M'}, 
   {        (char )'R',        (char )'O',        (char )'A',        (char )'R'}, 
   {        (char )'R',        (char )'O',        (char )'B',        (char )'E'}, 
   {        (char )'R',        (char )'O',        (char )'C',        (char )'K'}, 
   {        (char )'R',        (char )'O',        (char )'D',        (char )'E'}, 
   {        (char )'R',        (char )'O',        (char )'I',        (char )'L'}, 
   {        (char )'R',        (char )'O',        (char )'L',        (char )'L'}, 
   {        (char )'R',        (char )'O',        (char )'M',        (char )'E'}, 
   {        (char )'R',        (char )'O',        (char )'O',        (char )'D'}, 
   {        (char )'R',        (char )'O',        (char )'O',        (char )'F'}, 
   {        (char )'R',        (char )'O',        (char )'O',        (char )'K'}, 
   {        (char )'R',        (char )'O',        (char )'O',        (char )'M'}, 
   {        (char )'R',        (char )'O',        (char )'O',        (char )'T'}, 
   {        (char )'R',        (char )'O',        (char )'S',        (char )'A'}, 
   {        (char )'R',        (char )'O',        (char )'S',        (char )'E'}, 
   {        (char )'R',        (char )'O',        (char )'S',        (char )'S'}, 
   {        (char )'R',        (char )'O',        (char )'S',        (char )'Y'}, 
   {        (char )'R',        (char )'O',        (char )'T',        (char )'H'}, 
   {        (char )'R',        (char )'O',        (char )'U',        (char )'T'}, 
   {        (char )'R',        (char )'O',        (char )'V',        (char )'E'}, 
   {        (char )'R',        (char )'O',        (char )'W',        (char )'E'}, 
   {        (char )'R',        (char )'O',        (char )'W',        (char )'S'}, 
   {        (char )'R',        (char )'U',        (char )'B',        (char )'E'}, 
   {        (char )'R',        (char )'U',        (char )'B',        (char )'Y'}, 
   {        (char )'R',        (char )'U',        (char )'D',        (char )'E'}, 
   {        (char )'R',        (char )'U',        (char )'D',        (char )'Y'}, 
   {        (char )'R',        (char )'U',        (char )'I',        (char )'N'}, 
   {        (char )'R',        (char )'U',        (char )'L',        (char )'E'}, 
   {        (char )'R',        (char )'U',        (char )'N',        (char )'G'}, 
   {        (char )'R',        (char )'U',        (char )'N',        (char )'S'}, 
   {        (char )'R',        (char )'U',        (char )'N',        (char )'T'}, 
   {        (char )'R',        (char )'U',        (char )'S',        (char )'E'}, 
   {        (char )'R',        (char )'U',        (char )'S',        (char )'H'}, 
   {        (char )'R',        (char )'U',        (char )'S',        (char )'K'}, 
   {        (char )'R',        (char )'U',        (char )'S',        (char )'S'}, 
   {        (char )'R',        (char )'U',        (char )'S',        (char )'T'}, 
   {        (char )'R',        (char )'U',        (char )'T',        (char )'H'}, 
   {        (char )'S',        (char )'A',        (char )'C',        (char )'K'}, 
   {        (char )'S',        (char )'A',        (char )'F',        (char )'E'}, 
   {        (char )'S',        (char )'A',        (char )'G',        (char )'E'}, 
   {        (char )'S',        (char )'A',        (char )'I',        (char )'D'}, 
   {        (char )'S',        (char )'A',        (char )'I',        (char )'L'}, 
   {        (char )'S',        (char )'A',        (char )'L',        (char )'E'}, 
   {        (char )'S',        (char )'A',        (char )'L',        (char )'K'}, 
   {        (char )'S',        (char )'A',        (char )'L',        (char )'T'}, 
   {        (char )'S',        (char )'A',        (char )'M',        (char )'E'}, 
   {        (char )'S',        (char )'A',        (char )'N',        (char )'D'}, 
   {        (char )'S',        (char )'A',        (char )'N',        (char )'E'}, 
   {        (char )'S',        (char )'A',        (char )'N',        (char )'G'}, 
   {        (char )'S',        (char )'A',        (char )'N',        (char )'K'}, 
   {        (char )'S',        (char )'A',        (char )'R',        (char )'A'}, 
   {        (char )'S',        (char )'A',        (char )'U',        (char )'L'}, 
   {        (char )'S',        (char )'A',        (char )'V',        (char )'E'}, 
   {        (char )'S',        (char )'A',        (char )'Y',        (char )'S'}, 
   {        (char )'S',        (char )'C',        (char )'A',        (char )'N'}, 
   {        (char )'S',        (char )'C',        (char )'A',        (char )'R'}, 
   {        (char )'S',        (char )'C',        (char )'A',        (char )'T'}, 
   {        (char )'S',        (char )'C',        (char )'O',        (char )'T'}, 
   {        (char )'S',        (char )'E',        (char )'A',        (char )'L'}, 
   {        (char )'S',        (char )'E',        (char )'A',        (char )'M'}, 
   {        (char )'S',        (char )'E',        (char )'A',        (char )'R'}, 
   {        (char )'S',        (char )'E',        (char )'A',        (char )'T'}, 
   {        (char )'S',        (char )'E',        (char )'E',        (char )'D'}, 
   {        (char )'S',        (char )'E',        (char )'E',        (char )'K'}, 
   {        (char )'S',        (char )'E',        (char )'E',        (char )'M'}, 
   {        (char )'S',        (char )'E',        (char )'E',        (char )'N'}, 
   {        (char )'S',        (char )'E',        (char )'E',        (char )'S'}, 
   {        (char )'S',        (char )'E',        (char )'L',        (char )'F'}, 
   {        (char )'S',        (char )'E',        (char )'L',        (char )'L'}, 
   {        (char )'S',        (char )'E',        (char )'N',        (char )'D'}, 
   {        (char )'S',        (char )'E',        (char )'N',        (char )'T'}, 
   {        (char )'S',        (char )'E',        (char )'T',        (char )'S'}, 
   {        (char )'S',        (char )'E',        (char )'W',        (char )'N'}, 
   {        (char )'S',        (char )'H',        (char )'A',        (char )'G'}, 
   {        (char )'S',        (char )'H',        (char )'A',        (char )'M'}, 
   {        (char )'S',        (char )'H',        (char )'A',        (char )'W'}, 
   {        (char )'S',        (char )'H',        (char )'A',        (char )'Y'}, 
   {        (char )'S',        (char )'H',        (char )'E',        (char )'D'}, 
   {        (char )'S',        (char )'H',        (char )'I',        (char )'M'}, 
   {        (char )'S',        (char )'H',        (char )'I',        (char )'N'}, 
   {        (char )'S',        (char )'H',        (char )'O',        (char )'D'}, 
   {        (char )'S',        (char )'H',        (char )'O',        (char )'E'}, 
   {        (char )'S',        (char )'H',        (char )'O',        (char )'T'}, 
   {        (char )'S',        (char )'H',        (char )'O',        (char )'W'}, 
   {        (char )'S',        (char )'H',        (char )'U',        (char )'N'}, 
   {        (char )'S',        (char )'H',        (char )'U',        (char )'T'}, 
   {        (char )'S',        (char )'I',        (char )'C',        (char )'K'}, 
   {        (char )'S',        (char )'I',        (char )'D',        (char )'E'}, 
   {        (char )'S',        (char )'I',        (char )'F',        (char )'T'}, 
   {        (char )'S',        (char )'I',        (char )'G',        (char )'H'}, 
   {        (char )'S',        (char )'I',        (char )'G',        (char )'N'}, 
   {        (char )'S',        (char )'I',        (char )'L',        (char )'K'}, 
   {        (char )'S',        (char )'I',        (char )'L',        (char )'L'}, 
   {        (char )'S',        (char )'I',        (char )'L',        (char )'O'}, 
   {        (char )'S',        (char )'I',        (char )'L',        (char )'T'}, 
   {        (char )'S',        (char )'I',        (char )'N',        (char )'E'}, 
   {        (char )'S',        (char )'I',        (char )'N',        (char )'G'}, 
   {        (char )'S',        (char )'I',        (char )'N',        (char )'K'}, 
   {        (char )'S',        (char )'I',        (char )'R',        (char )'E'}, 
   {        (char )'S',        (char )'I',        (char )'T',        (char )'E'}, 
   {        (char )'S',        (char )'I',        (char )'T',        (char )'S'}, 
   {        (char )'S',        (char )'I',        (char )'T',        (char )'U'}, 
   {        (char )'S',        (char )'K',        (char )'A',        (char )'T'}, 
   {        (char )'S',        (char )'K',        (char )'E',        (char )'W'}, 
   {        (char )'S',        (char )'K',        (char )'I',        (char )'D'}, 
   {        (char )'S',        (char )'K',        (char )'I',        (char )'M'}, 
   {        (char )'S',        (char )'K',        (char )'I',        (char )'N'}, 
   {        (char )'S',        (char )'K',        (char )'I',        (char )'T'}, 
   {        (char )'S',        (char )'L',        (char )'A',        (char )'B'}, 
   {        (char )'S',        (char )'L',        (char )'A',        (char )'M'}, 
   {        (char )'S',        (char )'L',        (char )'A',        (char )'T'}, 
   {        (char )'S',        (char )'L',        (char )'A',        (char )'Y'}, 
   {        (char )'S',        (char )'L',        (char )'E',        (char )'D'}, 
   {        (char )'S',        (char )'L',        (char )'E',        (char )'W'}, 
   {        (char )'S',        (char )'L',        (char )'I',        (char )'D'}, 
   {        (char )'S',        (char )'L',        (char )'I',        (char )'M'}, 
   {        (char )'S',        (char )'L',        (char )'I',        (char )'T'}, 
   {        (char )'S',        (char )'L',        (char )'O',        (char )'B'}, 
   {        (char )'S',        (char )'L',        (char )'O',        (char )'G'}, 
   {        (char )'S',        (char )'L',        (char )'O',        (char )'T'}, 
   {        (char )'S',        (char )'L',        (char )'O',        (char )'W'}, 
   {        (char )'S',        (char )'L',        (char )'U',        (char )'G'}, 
   {        (char )'S',        (char )'L',        (char )'U',        (char )'M'}, 
   {        (char )'S',        (char )'L',        (char )'U',        (char )'R'}, 
   {        (char )'S',        (char )'M',        (char )'O',        (char )'G'}, 
   {        (char )'S',        (char )'M',        (char )'U',        (char )'G'}, 
   {        (char )'S',        (char )'N',        (char )'A',        (char )'G'}, 
   {        (char )'S',        (char )'N',        (char )'O',        (char )'B'}, 
   {        (char )'S',        (char )'N',        (char )'O',        (char )'W'}, 
   {        (char )'S',        (char )'N',        (char )'U',        (char )'B'}, 
   {        (char )'S',        (char )'N',        (char )'U',        (char )'G'}, 
   {        (char )'S',        (char )'O',        (char )'A',        (char )'K'}, 
   {        (char )'S',        (char )'O',        (char )'A',        (char )'R'}, 
   {        (char )'S',        (char )'O',        (char )'C',        (char )'K'}, 
   {        (char )'S',        (char )'O',        (char )'D',        (char )'A'}, 
   {        (char )'S',        (char )'O',        (char )'F',        (char )'A'}, 
   {        (char )'S',        (char )'O',        (char )'F',        (char )'T'}, 
   {        (char )'S',        (char )'O',        (char )'I',        (char )'L'}, 
   {        (char )'S',        (char )'O',        (char )'L',        (char )'D'}, 
   {        (char )'S',        (char )'O',        (char )'M',        (char )'E'}, 
   {        (char )'S',        (char )'O',        (char )'N',        (char )'G'}, 
   {        (char )'S',        (char )'O',        (char )'O',        (char )'N'}, 
   {        (char )'S',        (char )'O',        (char )'O',        (char )'T'}, 
   {        (char )'S',        (char )'O',        (char )'R',        (char )'E'}, 
   {        (char )'S',        (char )'O',        (char )'R',        (char )'T'}, 
   {        (char )'S',        (char )'O',        (char )'U',        (char )'L'}, 
   {        (char )'S',        (char )'O',        (char )'U',        (char )'R'}, 
   {        (char )'S',        (char )'O',        (char )'W',        (char )'N'}, 
   {        (char )'S',        (char )'T',        (char )'A',        (char )'B'}, 
   {        (char )'S',        (char )'T',        (char )'A',        (char )'G'}, 
   {        (char )'S',        (char )'T',        (char )'A',        (char )'N'}, 
   {        (char )'S',        (char )'T',        (char )'A',        (char )'R'}, 
   {        (char )'S',        (char )'T',        (char )'A',        (char )'Y'}, 
   {        (char )'S',        (char )'T',        (char )'E',        (char )'M'}, 
   {        (char )'S',        (char )'T',        (char )'E',        (char )'W'}, 
   {        (char )'S',        (char )'T',        (char )'I',        (char )'R'}, 
   {        (char )'S',        (char )'T',        (char )'O',        (char )'W'}, 
   {        (char )'S',        (char )'T',        (char )'U',        (char )'B'}, 
   {        (char )'S',        (char )'T',        (char )'U',        (char )'N'}, 
   {        (char )'S',        (char )'U',        (char )'C',        (char )'H'}, 
   {        (char )'S',        (char )'U',        (char )'D',        (char )'S'}, 
   {        (char )'S',        (char )'U',        (char )'I',        (char )'T'}, 
   {        (char )'S',        (char )'U',        (char )'L',        (char )'K'}, 
   {        (char )'S',        (char )'U',        (char )'M',        (char )'S'}, 
   {        (char )'S',        (char )'U',        (char )'N',        (char )'G'}, 
   {        (char )'S',        (char )'U',        (char )'N',        (char )'K'}, 
   {        (char )'S',        (char )'U',        (char )'R',        (char )'E'}, 
   {        (char )'S',        (char )'U',        (char )'R',        (char )'F'}, 
   {        (char )'S',        (char )'W',        (char )'A',        (char )'B'}, 
   {        (char )'S',        (char )'W',        (char )'A',        (char )'G'}, 
   {        (char )'S',        (char )'W',        (char )'A',        (char )'M'}, 
   {        (char )'S',        (char )'W',        (char )'A',        (char )'N'}, 
   {        (char )'S',        (char )'W',        (char )'A',        (char )'T'}, 
   {        (char )'S',        (char )'W',        (char )'A',        (char )'Y'}, 
   {        (char )'S',        (char )'W',        (char )'I',        (char )'M'}, 
   {        (char )'S',        (char )'W',        (char )'U',        (char )'M'}, 
   {        (char )'T',        (char )'A',        (char )'C',        (char )'K'}, 
   {        (char )'T',        (char )'A',        (char )'C',        (char )'T'}, 
   {        (char )'T',        (char )'A',        (char )'I',        (char )'L'}, 
   {        (char )'T',        (char )'A',        (char )'K',        (char )'E'}, 
   {        (char )'T',        (char )'A',        (char )'L',        (char )'E'}, 
   {        (char )'T',        (char )'A',        (char )'L',        (char )'K'}, 
   {        (char )'T',        (char )'A',        (char )'L',        (char )'L'}, 
   {        (char )'T',        (char )'A',        (char )'N',        (char )'K'}, 
   {        (char )'T',        (char )'A',        (char )'S',        (char )'K'}, 
   {        (char )'T',        (char )'A',        (char )'T',        (char )'E'}, 
   {        (char )'T',        (char )'A',        (char )'U',        (char )'T'}, 
   {        (char )'T',        (char )'E',        (char )'A',        (char )'L'}, 
   {        (char )'T',        (char )'E',        (char )'A',        (char )'M'}, 
   {        (char )'T',        (char )'E',        (char )'A',        (char )'R'}, 
   {        (char )'T',        (char )'E',        (char )'C',        (char )'H'}, 
   {        (char )'T',        (char )'E',        (char )'E',        (char )'M'}, 
   {        (char )'T',        (char )'E',        (char )'E',        (char )'N'}, 
   {        (char )'T',        (char )'E',        (char )'E',        (char )'T'}, 
   {        (char )'T',        (char )'E',        (char )'L',        (char )'L'}, 
   {        (char )'T',        (char )'E',        (char )'N',        (char )'D'}, 
   {        (char )'T',        (char )'E',        (char )'N',        (char )'T'}, 
   {        (char )'T',        (char )'E',        (char )'R',        (char )'M'}, 
   {        (char )'T',        (char )'E',        (char )'R',        (char )'N'}, 
   {        (char )'T',        (char )'E',        (char )'S',        (char )'S'}, 
   {        (char )'T',        (char )'E',        (char )'S',        (char )'T'}, 
   {        (char )'T',        (char )'H',        (char )'A',        (char )'N'}, 
   {        (char )'T',        (char )'H',        (char )'A',        (char )'T'}, 
   {        (char )'T',        (char )'H',        (char )'E',        (char )'E'}, 
   {        (char )'T',        (char )'H',        (char )'E',        (char )'M'}, 
   {        (char )'T',        (char )'H',        (char )'E',        (char )'N'}, 
   {        (char )'T',        (char )'H',        (char )'E',        (char )'Y'}, 
   {        (char )'T',        (char )'H',        (char )'I',        (char )'N'}, 
   {        (char )'T',        (char )'H',        (char )'I',        (char )'S'}, 
   {        (char )'T',        (char )'H',        (char )'U',        (char )'D'}, 
   {        (char )'T',        (char )'H',        (char )'U',        (char )'G'}, 
   {        (char )'T',        (char )'I',        (char )'C',        (char )'K'}, 
   {        (char )'T',        (char )'I',        (char )'D',        (char )'E'}, 
   {        (char )'T',        (char )'I',        (char )'D',        (char )'Y'}, 
   {        (char )'T',        (char )'I',        (char )'E',        (char )'D'}, 
   {        (char )'T',        (char )'I',        (char )'E',        (char )'R'}, 
   {        (char )'T',        (char )'I',        (char )'L',        (char )'E'}, 
   {        (char )'T',        (char )'I',        (char )'L',        (char )'L'}, 
   {        (char )'T',        (char )'I',        (char )'L',        (char )'T'}, 
   {        (char )'T',        (char )'I',        (char )'M',        (char )'E'}, 
   {        (char )'T',        (char )'I',        (char )'N',        (char )'A'}, 
   {        (char )'T',        (char )'I',        (char )'N',        (char )'E'}, 
   {        (char )'T',        (char )'I',        (char )'N',        (char )'T'}, 
   {        (char )'T',        (char )'I',        (char )'N',        (char )'Y'}, 
   {        (char )'T',        (char )'I',        (char )'R',        (char )'E'}, 
   {        (char )'T',        (char )'O',        (char )'A',        (char )'D'}, 
   {        (char )'T',        (char )'O',        (char )'G',        (char )'O'}, 
   {        (char )'T',        (char )'O',        (char )'I',        (char )'L'}, 
   {        (char )'T',        (char )'O',        (char )'L',        (char )'D'}, 
   {        (char )'T',        (char )'O',        (char )'L',        (char )'L'}, 
   {        (char )'T',        (char )'O',        (char )'N',        (char )'E'}, 
   {        (char )'T',        (char )'O',        (char )'N',        (char )'G'}, 
   {        (char )'T',        (char )'O',        (char )'N',        (char )'Y'}, 
   {        (char )'T',        (char )'O',        (char )'O',        (char )'K'}, 
   {        (char )'T',        (char )'O',        (char )'O',        (char )'L'}, 
   {        (char )'T',        (char )'O',        (char )'O',        (char )'T'}, 
   {        (char )'T',        (char )'O',        (char )'R',        (char )'E'}, 
   {        (char )'T',        (char )'O',        (char )'R',        (char )'N'}, 
   {        (char )'T',        (char )'O',        (char )'T',        (char )'E'}, 
   {        (char )'T',        (char )'O',        (char )'U',        (char )'R'}, 
   {        (char )'T',        (char )'O',        (char )'U',        (char )'T'}, 
   {        (char )'T',        (char )'O',        (char )'W',        (char )'N'}, 
   {        (char )'T',        (char )'R',        (char )'A',        (char )'G'}, 
   {        (char )'T',        (char )'R',        (char )'A',        (char )'M'}, 
   {        (char )'T',        (char )'R',        (char )'A',        (char )'Y'}, 
   {        (char )'T',        (char )'R',        (char )'E',        (char )'E'}, 
   {        (char )'T',        (char )'R',        (char )'E',        (char )'K'}, 
   {        (char )'T',        (char )'R',        (char )'I',        (char )'G'}, 
   {        (char )'T',        (char )'R',        (char )'I',        (char )'M'}, 
   {        (char )'T',        (char )'R',        (char )'I',        (char )'O'}, 
   {        (char )'T',        (char )'R',        (char )'O',        (char )'D'}, 
   {        (char )'T',        (char )'R',        (char )'O',        (char )'T'}, 
   {        (char )'T',        (char )'R',        (char )'O',        (char )'Y'}, 
   {        (char )'T',        (char )'R',        (char )'U',        (char )'E'}, 
   {        (char )'T',        (char )'U',        (char )'B',        (char )'A'}, 
   {        (char )'T',        (char )'U',        (char )'B',        (char )'E'}, 
   {        (char )'T',        (char )'U',        (char )'C',        (char )'K'}, 
   {        (char )'T',        (char )'U',        (char )'F',        (char )'T'}, 
   {        (char )'T',        (char )'U',        (char )'N',        (char )'A'}, 
   {        (char )'T',        (char )'U',        (char )'N',        (char )'E'}, 
   {        (char )'T',        (char )'U',        (char )'N',        (char )'G'}, 
   {        (char )'T',        (char )'U',        (char )'R',        (char )'F'}, 
   {        (char )'T',        (char )'U',        (char )'R',        (char )'N'}, 
   {        (char )'T',        (char )'U',        (char )'S',        (char )'K'}, 
   {        (char )'T',        (char )'W',        (char )'I',        (char )'G'}, 
   {        (char )'T',        (char )'W',        (char )'I',        (char )'N'}, 
   {        (char )'T',        (char )'W',        (char )'I',        (char )'T'}, 
   {        (char )'U',        (char )'L',        (char )'A',        (char )'N'}, 
   {        (char )'U',        (char )'N',        (char )'I',        (char )'T'}, 
   {        (char )'U',        (char )'R',        (char )'G',        (char )'E'}, 
   {        (char )'U',        (char )'S',        (char )'E',        (char )'D'}, 
   {        (char )'U',        (char )'S',        (char )'E',        (char )'R'}, 
   {        (char )'U',        (char )'S',        (char )'E',        (char )'S'}, 
   {        (char )'U',        (char )'T',        (char )'A',        (char )'H'}, 
   {        (char )'V',        (char )'A',        (char )'I',        (char )'L'}, 
   {        (char )'V',        (char )'A',        (char )'I',        (char )'N'}, 
   {        (char )'V',        (char )'A',        (char )'L',        (char )'E'}, 
   {        (char )'V',        (char )'A',        (char )'R',        (char )'Y'}, 
   {        (char )'V',        (char )'A',        (char )'S',        (char )'E'}, 
   {        (char )'V',        (char )'A',        (char )'S',        (char )'T'}, 
   {        (char )'V',        (char )'E',        (char )'A',        (char )'L'}, 
   {        (char )'V',        (char )'E',        (char )'D',        (char )'A'}, 
   {        (char )'V',        (char )'E',        (char )'I',        (char )'L'}, 
   {        (char )'V',        (char )'E',        (char )'I',        (char )'N'}, 
   {        (char )'V',        (char )'E',        (char )'N',        (char )'D'}, 
   {        (char )'V',        (char )'E',        (char )'N',        (char )'T'}, 
   {        (char )'V',        (char )'E',        (char )'R',        (char )'B'}, 
   {        (char )'V',        (char )'E',        (char )'R',        (char )'Y'}, 
   {        (char )'V',        (char )'E',        (char )'T',        (char )'O'}, 
   {        (char )'V',        (char )'I',        (char )'C',        (char )'E'}, 
   {        (char )'V',        (char )'I',        (char )'E',        (char )'W'}, 
   {        (char )'V',        (char )'I',        (char )'N',        (char )'E'}, 
   {        (char )'V',        (char )'I',        (char )'S',        (char )'E'}, 
   {        (char )'V',        (char )'O',        (char )'I',        (char )'D'}, 
   {        (char )'V',        (char )'O',        (char )'L',        (char )'T'}, 
   {        (char )'V',        (char )'O',        (char )'T',        (char )'E'}, 
   {        (char )'W',        (char )'A',        (char )'C',        (char )'K'}, 
   {        (char )'W',        (char )'A',        (char )'D',        (char )'E'}, 
   {        (char )'W',        (char )'A',        (char )'G',        (char )'E'}, 
   {        (char )'W',        (char )'A',        (char )'I',        (char )'L'}, 
   {        (char )'W',        (char )'A',        (char )'I',        (char )'T'}, 
   {        (char )'W',        (char )'A',        (char )'K',        (char )'E'}, 
   {        (char )'W',        (char )'A',        (char )'L',        (char )'E'}, 
   {        (char )'W',        (char )'A',        (char )'L',        (char )'K'}, 
   {        (char )'W',        (char )'A',        (char )'L',        (char )'L'}, 
   {        (char )'W',        (char )'A',        (char )'L',        (char )'T'}, 
   {        (char )'W',        (char )'A',        (char )'N',        (char )'D'}, 
   {        (char )'W',        (char )'A',        (char )'N',        (char )'E'}, 
   {        (char )'W',        (char )'A',        (char )'N',        (char )'G'}, 
   {        (char )'W',        (char )'A',        (char )'N',        (char )'T'}, 
   {        (char )'W',        (char )'A',        (char )'R',        (char )'D'}, 
   {        (char )'W',        (char )'A',        (char )'R',        (char )'M'}, 
   {        (char )'W',        (char )'A',        (char )'R',        (char )'N'}, 
   {        (char )'W',        (char )'A',        (char )'R',        (char )'T'}, 
   {        (char )'W',        (char )'A',        (char )'S',        (char )'H'}, 
   {        (char )'W',        (char )'A',        (char )'S',        (char )'T'}, 
   {        (char )'W',        (char )'A',        (char )'T',        (char )'S'}, 
   {        (char )'W',        (char )'A',        (char )'T',        (char )'T'}, 
   {        (char )'W',        (char )'A',        (char )'V',        (char )'E'}, 
   {        (char )'W',        (char )'A',        (char )'V',        (char )'Y'}, 
   {        (char )'W',        (char )'A',        (char )'Y',        (char )'S'}, 
   {        (char )'W',        (char )'E',        (char )'A',        (char )'K'}, 
   {        (char )'W',        (char )'E',        (char )'A',        (char )'L'}, 
   {        (char )'W',        (char )'E',        (char )'A',        (char )'N'}, 
   {        (char )'W',        (char )'E',        (char )'A',        (char )'R'}, 
   {        (char )'W',        (char )'E',        (char )'E',        (char )'D'}, 
   {        (char )'W',        (char )'E',        (char )'E',        (char )'K'}, 
   {        (char )'W',        (char )'E',        (char )'I',        (char )'R'}, 
   {        (char )'W',        (char )'E',        (char )'L',        (char )'D'}, 
   {        (char )'W',        (char )'E',        (char )'L',        (char )'L'}, 
   {        (char )'W',        (char )'E',        (char )'L',        (char )'T'}, 
   {        (char )'W',        (char )'E',        (char )'N',        (char )'T'}, 
   {        (char )'W',        (char )'E',        (char )'R',        (char )'E'}, 
   {        (char )'W',        (char )'E',        (char )'R',        (char )'T'}, 
   {        (char )'W',        (char )'E',        (char )'S',        (char )'T'}, 
   {        (char )'W',        (char )'H',        (char )'A',        (char )'M'}, 
   {        (char )'W',        (char )'H',        (char )'A',        (char )'T'}, 
   {        (char )'W',        (char )'H',        (char )'E',        (char )'E'}, 
   {        (char )'W',        (char )'H',        (char )'E',        (char )'N'}, 
   {        (char )'W',        (char )'H',        (char )'E',        (char )'T'}, 
   {        (char )'W',        (char )'H',        (char )'O',        (char )'A'}, 
   {        (char )'W',        (char )'H',        (char )'O',        (char )'M'}, 
   {        (char )'W',        (char )'I',        (char )'C',        (char )'K'}, 
   {        (char )'W',        (char )'I',        (char )'F',        (char )'E'}, 
   {        (char )'W',        (char )'I',        (char )'L',        (char )'D'}, 
   {        (char )'W',        (char )'I',        (char )'L',        (char )'L'}, 
   {        (char )'W',        (char )'I',        (char )'N',        (char )'D'}, 
   {        (char )'W',        (char )'I',        (char )'N',        (char )'E'}, 
   {        (char )'W',        (char )'I',        (char )'N',        (char )'G'}, 
   {        (char )'W',        (char )'I',        (char )'N',        (char )'K'}, 
   {        (char )'W',        (char )'I',        (char )'N',        (char )'O'}, 
   {        (char )'W',        (char )'I',        (char )'R',        (char )'E'}, 
   {        (char )'W',        (char )'I',        (char )'S',        (char )'E'}, 
   {        (char )'W',        (char )'I',        (char )'S',        (char )'H'}, 
   {        (char )'W',        (char )'I',        (char )'T',        (char )'H'}, 
   {        (char )'W',        (char )'O',        (char )'L',        (char )'F'}, 
   {        (char )'W',        (char )'O',        (char )'N',        (char )'T'}, 
   {        (char )'W',        (char )'O',        (char )'O',        (char )'D'}, 
   {        (char )'W',        (char )'O',        (char )'O',        (char )'L'}, 
   {        (char )'W',        (char )'O',        (char )'R',        (char )'D'}, 
   {        (char )'W',        (char )'O',        (char )'R',        (char )'E'}, 
   {        (char )'W',        (char )'O',        (char )'R',        (char )'K'}, 
   {        (char )'W',        (char )'O',        (char )'R',        (char )'M'}, 
   {        (char )'W',        (char )'O',        (char )'R',        (char )'N'}, 
   {        (char )'W',        (char )'O',        (char )'V',        (char )'E'}, 
   {        (char )'W',        (char )'R',        (char )'I',        (char )'T'}, 
   {        (char )'W',        (char )'Y',        (char )'N',        (char )'N'}, 
   {        (char )'Y',        (char )'A',        (char )'L',        (char )'E'}, 
   {        (char )'Y',        (char )'A',        (char )'N',        (char )'G'}, 
   {        (char )'Y',        (char )'A',        (char )'N',        (char )'K'}, 
   {        (char )'Y',        (char )'A',        (char )'R',        (char )'D'}, 
   {        (char )'Y',        (char )'A',        (char )'R',        (char )'N'}, 
   {        (char )'Y',        (char )'A',        (char )'W',        (char )'L'}, 
   {        (char )'Y',        (char )'A',        (char )'W',        (char )'N'}, 
   {        (char )'Y',        (char )'E',        (char )'A',        (char )'H'}, 
   {        (char )'Y',        (char )'E',        (char )'A',        (char )'R'}, 
   {        (char )'Y',        (char )'E',        (char )'L',        (char )'L'}, 
   {        (char )'Y',        (char )'O',        (char )'G',        (char )'A'}, 
   {        (char )'Y',        (char )'O',        (char )'K',        (char )'E'}};
#line 2097 "ftp-opie.c"
static unsigned long extract(char const   *s , int start , int length ) 
{ 
  unsigned char cl ;
  unsigned char cc ;
  unsigned char cr ;
  unsigned long x ;

  {
#line 2100
  cl = (unsigned char )*(s + start / 8);
#line 2101
  cc = (unsigned char )*(s + (start / 8 + 1));
#line 2102
  cr = (unsigned char )*(s + (start / 8 + 2));
#line 2103
  x = (unsigned long )(((long )(((int )cl << 8) | (int )cc) << 8) | (long )cr);
#line 2105
  x >>= 24 - (length + start % 8);
#line 2106
  x &= (unsigned long )(65535 >> (16 - length));
#line 2107
  return (x);
}
}
#line 2117 "ftp-opie.c"
static char *btoe(char *store , char const   *c ) 
{ 
  char cp[10] ;
  int p ;
  int i ;
  char *ostore ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  unsigned long tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  unsigned long tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;
  unsigned long tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  char *tmp___23 ;
  unsigned long tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  char *tmp___29 ;
  unsigned long tmp___30 ;

  {
  {
#line 2123
  ostore = store;
#line 2125
  *store = (char )'\000';
#line 2127
  memset((void *)(cp), 0, (size_t )sizeof(cp));
#line 2128
  memcpy((void */* __restrict  */)(cp), (void const   */* __restrict  */)c, (size_t )8);
#line 2130
  p = 0;
#line 2130
  i = 0;
  }
  {
#line 2130
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2130
    if (! (i < 64)) {
#line 2130
      goto while_break;
    }
    {
#line 2131
    tmp = extract((char const   *)(cp), i, 2);
#line 2131
    p = (int )((unsigned long )p + tmp);
#line 2130
    i += 2;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2133
  cp[8] = (char )((int )((char )p) << 6);
#line 2134
  tmp___0 = extract((char const   *)(cp), 0, 11);
#line 2134
  memcpy((void */* __restrict  */)store, (void const   */* __restrict  */)(& Wp[tmp___0][0]),
         (size_t )4);
  }
#line 2135
  if (! *store) {
#line 2135
    tmp___4 = 0;
  } else {
#line 2135
    if (! *(store + 1)) {
#line 2135
      tmp___3 = 1;
    } else {
#line 2135
      if (! *(store + 2)) {
#line 2135
        tmp___2 = 2;
      } else {
#line 2135
        if (! *(store + 3)) {
#line 2135
          tmp___1 = 3;
        } else {
#line 2135
          tmp___1 = 4;
        }
#line 2135
        tmp___2 = tmp___1;
      }
#line 2135
      tmp___3 = tmp___2;
    }
#line 2135
    tmp___4 = tmp___3;
  }
  {
#line 2135
  store += tmp___4;
#line 2136
  tmp___5 = store;
#line 2136
  store ++;
#line 2136
  *tmp___5 = (char )' ';
#line 2137
  tmp___6 = extract((char const   *)(cp), 11, 11);
#line 2137
  memcpy((void */* __restrict  */)store, (void const   */* __restrict  */)(& Wp[tmp___6][0]),
         (size_t )4);
  }
#line 2138
  if (! *store) {
#line 2138
    tmp___10 = 0;
  } else {
#line 2138
    if (! *(store + 1)) {
#line 2138
      tmp___9 = 1;
    } else {
#line 2138
      if (! *(store + 2)) {
#line 2138
        tmp___8 = 2;
      } else {
#line 2138
        if (! *(store + 3)) {
#line 2138
          tmp___7 = 3;
        } else {
#line 2138
          tmp___7 = 4;
        }
#line 2138
        tmp___8 = tmp___7;
      }
#line 2138
      tmp___9 = tmp___8;
    }
#line 2138
    tmp___10 = tmp___9;
  }
  {
#line 2138
  store += tmp___10;
#line 2139
  tmp___11 = store;
#line 2139
  store ++;
#line 2139
  *tmp___11 = (char )' ';
#line 2140
  tmp___12 = extract((char const   *)(cp), 22, 11);
#line 2140
  memcpy((void */* __restrict  */)store, (void const   */* __restrict  */)(& Wp[tmp___12][0]),
         (size_t )4);
  }
#line 2141
  if (! *store) {
#line 2141
    tmp___16 = 0;
  } else {
#line 2141
    if (! *(store + 1)) {
#line 2141
      tmp___15 = 1;
    } else {
#line 2141
      if (! *(store + 2)) {
#line 2141
        tmp___14 = 2;
      } else {
#line 2141
        if (! *(store + 3)) {
#line 2141
          tmp___13 = 3;
        } else {
#line 2141
          tmp___13 = 4;
        }
#line 2141
        tmp___14 = tmp___13;
      }
#line 2141
      tmp___15 = tmp___14;
    }
#line 2141
    tmp___16 = tmp___15;
  }
  {
#line 2141
  store += tmp___16;
#line 2142
  tmp___17 = store;
#line 2142
  store ++;
#line 2142
  *tmp___17 = (char )' ';
#line 2143
  tmp___18 = extract((char const   *)(cp), 33, 11);
#line 2143
  memcpy((void */* __restrict  */)store, (void const   */* __restrict  */)(& Wp[tmp___18][0]),
         (size_t )4);
  }
#line 2144
  if (! *store) {
#line 2144
    tmp___22 = 0;
  } else {
#line 2144
    if (! *(store + 1)) {
#line 2144
      tmp___21 = 1;
    } else {
#line 2144
      if (! *(store + 2)) {
#line 2144
        tmp___20 = 2;
      } else {
#line 2144
        if (! *(store + 3)) {
#line 2144
          tmp___19 = 3;
        } else {
#line 2144
          tmp___19 = 4;
        }
#line 2144
        tmp___20 = tmp___19;
      }
#line 2144
      tmp___21 = tmp___20;
    }
#line 2144
    tmp___22 = tmp___21;
  }
  {
#line 2144
  store += tmp___22;
#line 2145
  tmp___23 = store;
#line 2145
  store ++;
#line 2145
  *tmp___23 = (char )' ';
#line 2146
  tmp___24 = extract((char const   *)(cp), 44, 11);
#line 2146
  memcpy((void */* __restrict  */)store, (void const   */* __restrict  */)(& Wp[tmp___24][0]),
         (size_t )4);
  }
#line 2147
  if (! *store) {
#line 2147
    tmp___28 = 0;
  } else {
#line 2147
    if (! *(store + 1)) {
#line 2147
      tmp___27 = 1;
    } else {
#line 2147
      if (! *(store + 2)) {
#line 2147
        tmp___26 = 2;
      } else {
#line 2147
        if (! *(store + 3)) {
#line 2147
          tmp___25 = 3;
        } else {
#line 2147
          tmp___25 = 4;
        }
#line 2147
        tmp___26 = tmp___25;
      }
#line 2147
      tmp___27 = tmp___26;
    }
#line 2147
    tmp___28 = tmp___27;
  }
  {
#line 2147
  store += tmp___28;
#line 2148
  tmp___29 = store;
#line 2148
  store ++;
#line 2148
  *tmp___29 = (char )' ';
#line 2149
  tmp___30 = extract((char const   *)(cp), 55, 11);
#line 2149
  memcpy((void */* __restrict  */)store, (void const   */* __restrict  */)(& Wp[tmp___30][0]),
         (size_t )4);
#line 2151
  *(store + 4) = (char )'\000';
  }
  {
#line 2153
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2153
    if (opt.debug) {
      {
#line 2153
      debug_logprintf("store is `%s\'\n", ostore);
      }
    }
#line 2153
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2155
  return (ostore);
}
}
#line 2163 "ftp-opie.c"
static char buf[33]  ;
#line 2159 "ftp-opie.c"
char const   *calculate_skey_response(int sequence , char const   *seed , char const   *pass ) 
{ 
  char key[8] ;
  gen_md5_context *ctx ;
  int tmp ;
  void *tmp___0 ;
  unsigned long results[4] ;
  char *feed ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;

  {
  {
#line 2165
  tmp = gen_md5_context_size();
#line 2165
  tmp___0 = __builtin_alloca((unsigned long )tmp);
#line 2165
  ctx = (gen_md5_context *)tmp___0;
#line 2167
  tmp___1 = strlen(seed);
#line 2167
  tmp___2 = strlen(pass);
#line 2167
  tmp___3 = __builtin_alloca((unsigned long )((tmp___1 + tmp___2) + 1U));
#line 2167
  feed = (char *)tmp___3;
#line 2169
  strcpy((char */* __restrict  */)feed, (char const   */* __restrict  */)seed);
#line 2170
  strcat((char */* __restrict  */)feed, (char const   */* __restrict  */)pass);
#line 2172
  gen_md5_init(ctx);
#line 2173
  tmp___4 = strlen((char const   *)feed);
#line 2173
  gen_md5_update((unsigned char const   *)((unsigned char *)feed), (int )tmp___4,
                 ctx);
#line 2174
  gen_md5_finish(ctx, (unsigned char *)(results));
#line 2176
  results[0] ^= results[2];
#line 2177
  results[1] ^= results[3];
#line 2178
  memcpy((void */* __restrict  */)(key), (void const   */* __restrict  */)((char *)(results)),
         (size_t )8);
  }
  {
#line 2180
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2180
    tmp___5 = sequence;
#line 2180
    sequence --;
#line 2180
    if (! (0 < tmp___5)) {
#line 2180
      goto while_break;
    }
    {
#line 2182
    gen_md5_init(ctx);
#line 2183
    gen_md5_update((unsigned char const   *)((unsigned char *)(key)), 8, ctx);
#line 2184
    gen_md5_finish(ctx, (unsigned char *)(results));
#line 2185
    results[0] ^= results[2];
#line 2186
    results[1] ^= results[3];
#line 2187
    memcpy((void */* __restrict  */)(key), (void const   */* __restrict  */)((char *)(results)),
           (size_t )8);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2189
  btoe(buf, (char const   *)(key));
  }
#line 2190
  return ((char const   *)(buf));
}
}
#line 434 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 435 "/usr/include/stdio.h"
extern int fgetc(FILE *__stream ) ;
#line 144 "/usr/include/stdlib.h"
extern int atoi(char const   *__nptr )  __attribute__((__pure__)) ;
#line 191 "/usr/include/string.h"
extern char *strtok(char * __restrict  __s , char const   * __restrict  __delim ) ;
#line 118 "ftp.h"
struct fileinfo *ftp_parse_ls(char const   *file , enum stype  const  system_type ) ;
#line 121
uerr_t ftp_index(char const   *file , struct url *u , struct fileinfo *f ) ;
#line 54 "ftp-ls.c"
static int symperms(char const   *s ) 
{ 
  int perms ;
  int i ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 57
  perms = 0;
#line 59
  tmp = strlen(s);
  }
#line 59
  if (tmp < 9U) {
#line 60
    return (0);
  }
#line 61
  i = 0;
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
#line 61
    if (! (i < 3)) {
#line 61
      goto while_break;
    }
#line 63
    perms <<= 3;
#line 64
    if ((int const   )*(s + 2) == 120) {
#line 64
      tmp___0 = 1;
    } else
#line 64
    if ((int const   )*(s + 2) == 115) {
#line 64
      tmp___0 = 1;
    } else {
#line 64
      tmp___0 = 0;
    }
#line 64
    perms += ((((int const   )*(s + 0) == 114) << 2) + (((int const   )*(s + 1) == 119) << 1)) + tmp___0;
#line 61
    i ++;
#line 61
    s += 3;
  }
  while_break: /* CIL Label */ ;
  }
#line 67
  return (perms);
}
}
#line 75 "ftp-ls.c"
static int clean_line(char *line ) 
{ 
  int len ;
  size_t tmp ;

  {
  {
#line 78
  tmp = strlen((char const   *)line);
#line 78
  len = (int )tmp;
  }
#line 79
  if (! len) {
#line 79
    return (0);
  }
#line 80
  if ((int )*(line + (len - 1)) == 10) {
#line 81
    len --;
#line 81
    *(line + len) = (char )'\000';
  }
#line 82
  if ((int )*(line + (len - 1)) == 13) {
#line 83
    len --;
#line 83
    *(line + len) = (char )'\000';
  }
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
#line 84
    if (! *line) {
#line 84
      goto while_break;
    }
#line 84
    if ((int )*line == 9) {
#line 84
      *line = (char )' ';
    }
#line 84
    line ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  return (len);
}
}
#line 100
static struct fileinfo *ftp_parse_unix_ls(char const   *file , int ignore_perms ) ;
#line 100 "ftp-ls.c"
static char const   *months[12]  = 
#line 100
  {      "Jan",      "Feb",      "Mar",      "Apr", 
        "May",      "Jun",      "Jul",      "Aug", 
        "Sep",      "Oct",      "Nov",      "Dec"};
#line 96 "ftp-ls.c"
static struct fileinfo *ftp_parse_unix_ls(char const   *file , int ignore_perms ) 
{ 
  FILE *fp ;
  int next ;
  int len ;
  int i ;
  int error ;
  int ignore ;
  int year ;
  int month ;
  int day ;
  int hour ;
  int min ;
  int sec ;
  struct tm timestruct ;
  struct tm *tnow ;
  time_t timenow ;
  char *line ;
  char *tok ;
  struct fileinfo *dir ;
  struct fileinfo *l ;
  struct fileinfo cur ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *t ;
  long mul ;
  int fnlen ;
  char *p ;
  size_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  struct fileinfo *tmp___9 ;
  void *tmp___10 ;

  {
  {
#line 113
  fp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"rb");
  }
#line 114
  if (! fp) {
    {
#line 116
    tmp = __errno_location();
#line 116
    tmp___0 = strerror(*tmp);
#line 116
    logprintf((enum log_options )1, "%s: %s\n", file, tmp___0);
    }
#line 117
    return ((struct fileinfo *)((void *)0));
  }
#line 119
  l = (struct fileinfo *)((void *)0);
#line 119
  dir = l;
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 122
    line = read_whole_line(fp);
    }
#line 122
    if (! line) {
#line 122
      goto while_break;
    }
    {
#line 124
    len = clean_line(line);
#line 126
    tmp___1 = strncasecmp((char const   *)line, "total", (size_t )5);
    }
#line 126
    if (! tmp___1) {
      {
#line 128
      free((void *)line);
      }
#line 129
      goto while_continue;
    }
    {
#line 132
    tok = strtok((char */* __restrict  */)line, (char const   */* __restrict  */)" ");
    }
#line 133
    if (! tok) {
      {
#line 135
      free((void *)line);
      }
#line 136
      goto while_continue;
    }
#line 139
    cur.name = (char *)((void *)0);
#line 140
    cur.linkto = (char *)((void *)0);
    {
#line 145
    if ((int )*tok == 45) {
#line 145
      goto case_45;
    }
#line 149
    if ((int )*tok == 100) {
#line 149
      goto case_100;
    }
#line 153
    if ((int )*tok == 108) {
#line 153
      goto case_108;
    }
#line 157
    goto switch_default;
    case_45: /* CIL Label */ 
#line 146
    cur.type = (enum ftype )0;
    {
#line 147
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 147
      if (opt.debug) {
        {
#line 147
        debug_logprintf("PLAINFILE; ");
        }
      }
#line 147
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 148
    goto switch_break;
    case_100: /* CIL Label */ 
#line 150
    cur.type = (enum ftype )1;
    {
#line 151
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 151
      if (opt.debug) {
        {
#line 151
        debug_logprintf("DIRECTORY; ");
        }
      }
#line 151
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 152
    goto switch_break;
    case_108: /* CIL Label */ 
#line 154
    cur.type = (enum ftype )2;
    {
#line 155
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 155
      if (opt.debug) {
        {
#line 155
        debug_logprintf("SYMLINK; ");
        }
      }
#line 155
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 156
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 158
    cur.type = (enum ftype )3;
    {
#line 159
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 159
      if (opt.debug) {
        {
#line 159
        debug_logprintf("UNKNOWN; ");
        }
      }
#line 159
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 160
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 163
    if (ignore_perms) {
      {
#line 167
      if ((unsigned int )cur.type == 0U) {
#line 167
        goto case_0;
      }
#line 170
      if ((unsigned int )cur.type == 1U) {
#line 170
        goto case_1;
      }
#line 173
      goto switch_default___0;
      case_0: /* CIL Label */ 
#line 168
      cur.perms = 420;
#line 169
      goto switch_break___0;
      case_1: /* CIL Label */ 
#line 171
      cur.perms = 493;
#line 172
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
#line 175
      cur.perms = 420;
      switch_break___0: /* CIL Label */ ;
      }
      {
#line 177
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 177
        if (opt.debug) {
          {
#line 177
          debug_logprintf("implicit perms %0o; ", cur.perms);
          }
        }
#line 177
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    } else {
      {
#line 181
      cur.perms = symperms((char const   *)(tok + 1));
      }
      {
#line 182
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 182
        if (opt.debug) {
          {
#line 182
          debug_logprintf("perms %0o; ", cur.perms);
          }
        }
#line 182
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
#line 185
    ignore = 0;
#line 185
    error = ignore;
#line 187
    sec = 0;
#line 187
    min = sec;
#line 187
    hour = min;
#line 187
    year = hour;
#line 188
    day = 0;
#line 188
    month = day;
#line 189
    next = -1;
    {
#line 201
    while (1) {
      while_continue___6: /* CIL Label */ ;
      {
#line 201
      tok = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ");
      }
#line 201
      if (! tok) {
#line 201
        goto while_break___6;
      }
#line 203
      next --;
#line 204
      if (next < 0) {
#line 206
        i = 0;
        {
#line 206
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 206
          if (! (i < 12)) {
#line 206
            goto while_break___7;
          }
          {
#line 207
          tmp___2 = strcmp((char const   *)tok, months[i]);
          }
#line 207
          if (! tmp___2) {
#line 208
            goto while_break___7;
          }
#line 206
          i ++;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 211
        if (i != 12) {
#line 213
          t = tok - 2;
#line 214
          mul = 1L;
#line 216
          cur.size = 0L;
          {
#line 216
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 216
            if ((unsigned long )t > (unsigned long )line) {
#line 216
              if (! ((int const   )_sch_istable[(int )*t & 255] & 4)) {
#line 216
                goto while_break___8;
              }
            } else {
#line 216
              goto while_break___8;
            }
#line 217
            cur.size += mul * (long )((int )*t - 48);
#line 216
            mul *= 10L;
#line 216
            t --;
          }
          while_break___8: /* CIL Label */ ;
          }
#line 218
          if ((unsigned long )t == (unsigned long )line) {
#line 221
            error = 1;
#line 222
            goto while_break___6;
          }
#line 224
          month = i;
#line 225
          next = 5;
          {
#line 226
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 226
            if (opt.debug) {
              {
#line 226
              debug_logprintf("month: %s; ", months[month]);
              }
            }
#line 226
            goto while_break___9;
          }
          while_break___9: /* CIL Label */ ;
          }
        }
      } else
#line 229
      if (next == 4) {
#line 231
        if (*(tok + 1)) {
#line 232
          day = (10 * ((int )*tok - 48) + (int )*(tok + 1)) - 48;
        } else {
#line 234
          day = (int )*tok - 48;
        }
        {
#line 235
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 235
          if (opt.debug) {
            {
#line 235
            debug_logprintf("day: %d; ", day);
            }
          }
#line 235
          goto while_break___10;
        }
        while_break___10: /* CIL Label */ ;
        }
      } else
#line 237
      if (next == 3) {
#line 245
        year = 0;
#line 246
        sec = 0;
#line 246
        hour = sec;
#line 246
        min = hour;
#line 248
        if ((int const   )_sch_istable[(int )*tok & 255] & 4) {
          {
#line 251
          while (1) {
            while_continue___11: /* CIL Label */ ;
#line 251
            if (! ((int const   )_sch_istable[(int )*tok & 255] & 4)) {
#line 251
              goto while_break___11;
            }
#line 252
            year = ((int )*tok - 48) + 10 * year;
#line 251
            tok ++;
          }
          while_break___11: /* CIL Label */ ;
          }
#line 253
          if ((int )*tok == 58) {
#line 256
            hour = year;
#line 257
            year = 0;
#line 258
            tok ++;
            {
#line 260
            while (1) {
              while_continue___12: /* CIL Label */ ;
#line 260
              if (! ((int const   )_sch_istable[(int )*tok & 255] & 4)) {
#line 260
                goto while_break___12;
              }
#line 261
              min = ((int )*tok - 48) + 10 * min;
#line 260
              tok ++;
            }
            while_break___12: /* CIL Label */ ;
            }
#line 262
            if ((int )*tok == 58) {
#line 265
              tok ++;
              {
#line 266
              while (1) {
                while_continue___13: /* CIL Label */ ;
#line 266
                if (! ((int const   )_sch_istable[(int )*tok & 255] & 4)) {
#line 266
                  goto while_break___13;
                }
#line 267
                sec = ((int )*tok - 48) + 10 * sec;
#line 266
                tok ++;
              }
              while_break___13: /* CIL Label */ ;
              }
            }
          }
        }
#line 271
        if (year) {
          {
#line 272
          while (1) {
            while_continue___14: /* CIL Label */ ;
#line 272
            if (opt.debug) {
              {
#line 272
              debug_logprintf("year: %d (no tm); ", year);
              }
            }
#line 272
            goto while_break___14;
          }
          while_break___14: /* CIL Label */ ;
          }
        } else {
          {
#line 274
          while (1) {
            while_continue___15: /* CIL Label */ ;
#line 274
            if (opt.debug) {
              {
#line 274
              debug_logprintf("time: %02d:%02d:%02d (no yr); ", hour, min, sec);
              }
            }
#line 274
            goto while_break___15;
          }
          while_break___15: /* CIL Label */ ;
          }
        }
      } else
#line 276
      if (next == 2) {
        {
#line 283
        tmp___3 = strlen((char const   *)tok);
#line 283
        fnlen = (int )tmp___3;
        }
#line 284
        if ((long )fnlen < (long )len - (tok - line)) {
#line 288
          *(tok + fnlen) = (char )' ';
#line 291
          if ((unsigned int )cur.type == 2U) {
            {
#line 293
            p = strstr((char const   *)tok, " -> ");
            }
#line 294
            if (! p) {
#line 296
              error = 1;
#line 297
              goto while_break___6;
            }
            {
#line 299
            cur.linkto = xstrdup_real((char const   *)(p + 4));
            }
            {
#line 300
            while (1) {
              while_continue___16: /* CIL Label */ ;
#line 300
              if (opt.debug) {
                {
#line 300
                debug_logprintf("link to: %s\n", cur.linkto);
                }
              }
#line 300
              goto while_break___16;
            }
            while_break___16: /* CIL Label */ ;
            }
#line 302
            *p = (char )'\000';
          }
        }
        {
#line 308
        tmp___4 = strcmp((char const   *)tok, ".");
        }
#line 308
        if (tmp___4) {
          {
#line 308
          tmp___5 = strcmp((char const   *)tok, "..");
          }
#line 308
          if (! tmp___5) {
            _L: /* CIL Label */ 
            {
#line 310
            while (1) {
              while_continue___17: /* CIL Label */ ;
#line 310
              if (opt.debug) {
                {
#line 310
                debug_logprintf("\nIgnoring `.\' and `..\'; ");
                }
              }
#line 310
              goto while_break___17;
            }
            while_break___17: /* CIL Label */ ;
            }
#line 311
            ignore = 1;
#line 312
            goto while_break___6;
          }
        } else {
#line 308
          goto _L;
        }
        {
#line 322
        tmp___6 = strlen((char const   *)tok);
#line 322
        fnlen = (int )tmp___6;
#line 323
        tmp___7 = xmalloc_real((size_t )(fnlen + 1));
#line 323
        cur.name = (char *)tmp___7;
#line 324
        memcpy((void */* __restrict  */)cur.name, (void const   */* __restrict  */)tok,
               (size_t )(fnlen + 1));
        }
#line 325
        if (fnlen) {
#line 327
          if ((unsigned int )cur.type == 1U) {
#line 327
            if ((int )*(cur.name + (fnlen - 1)) == 47) {
#line 329
              *(cur.name + (fnlen - 1)) = (char )'\000';
              {
#line 330
              while (1) {
                while_continue___18: /* CIL Label */ ;
#line 330
                if (opt.debug) {
                  {
#line 330
                  debug_logprintf("trailing `/\' on dir.\n");
                  }
                }
#line 330
                goto while_break___18;
              }
              while_break___18: /* CIL Label */ ;
              }
            } else {
#line 327
              goto _L___1;
            }
          } else
          _L___1: /* CIL Label */ 
#line 332
          if ((unsigned int )cur.type == 2U) {
#line 332
            if ((int )*(cur.name + (fnlen - 1)) == 64) {
#line 334
              *(cur.name + (fnlen - 1)) = (char )'\000';
              {
#line 335
              while (1) {
                while_continue___19: /* CIL Label */ ;
#line 335
                if (opt.debug) {
                  {
#line 335
                  debug_logprintf("trailing `@\' on link.\n");
                  }
                }
#line 335
                goto while_break___19;
              }
              while_break___19: /* CIL Label */ ;
              }
            } else {
#line 332
              goto _L___0;
            }
          } else
          _L___0: /* CIL Label */ 
#line 337
          if ((unsigned int )cur.type == 0U) {
#line 337
            if (cur.perms & 73) {
#line 337
              if ((int )*(cur.name + (fnlen - 1)) == 42) {
#line 341
                *(cur.name + (fnlen - 1)) = (char )'\000';
                {
#line 342
                while (1) {
                  while_continue___20: /* CIL Label */ ;
#line 342
                  if (opt.debug) {
                    {
#line 342
                    debug_logprintf("trailing `*\' on exec.\n");
                    }
                  }
#line 342
                  goto while_break___20;
                }
                while_break___20: /* CIL Label */ ;
                }
              }
            }
          }
        } else {
#line 346
          error = 1;
        }
#line 347
        goto while_break___6;
      } else {
        {
#line 350
        abort();
        }
      }
    }
    while_break___6: /* CIL Label */ ;
    }
#line 353
    if (! cur.name) {
#line 354
      error = 1;
    } else
#line 353
    if ((unsigned int )cur.type == 2U) {
#line 353
      if (! cur.linkto) {
#line 354
        error = 1;
      }
    }
    {
#line 356
    while (1) {
      while_continue___21: /* CIL Label */ ;
#line 356
      if (opt.debug) {
        {
#line 356
        debug_logprintf("\n");
        }
      }
#line 356
      goto while_break___21;
    }
    while_break___21: /* CIL Label */ ;
    }
#line 358
    if (error) {
#line 358
      goto _L___2;
    } else
#line 358
    if (ignore) {
      _L___2: /* CIL Label */ 
      {
#line 360
      while (1) {
        while_continue___22: /* CIL Label */ ;
#line 360
        if (opt.debug) {
          {
#line 360
          debug_logprintf("Skipping.\n");
          }
        }
#line 360
        goto while_break___22;
      }
      while_break___22: /* CIL Label */ ;
      }
      {
#line 361
      while (1) {
        while_continue___23: /* CIL Label */ ;
#line 361
        if (cur.name) {
          {
#line 361
          free((void *)cur.name);
          }
        }
#line 361
        goto while_break___23;
      }
      while_break___23: /* CIL Label */ ;
      }
      {
#line 362
      while (1) {
        while_continue___24: /* CIL Label */ ;
#line 362
        if (cur.linkto) {
          {
#line 362
          free((void *)cur.linkto);
          }
        }
#line 362
        goto while_break___24;
      }
      while_break___24: /* CIL Label */ ;
      }
      {
#line 363
      free((void *)line);
      }
#line 364
      goto while_continue;
    }
#line 367
    if (! dir) {
      {
#line 369
      tmp___8 = xmalloc_real((size_t )sizeof(struct fileinfo ));
#line 369
      dir = (struct fileinfo *)tmp___8;
#line 369
      l = dir;
#line 370
      memcpy((void */* __restrict  */)l, (void const   */* __restrict  */)(& cur),
             (size_t )sizeof(cur));
#line 371
      tmp___9 = (struct fileinfo *)((void *)0);
#line 371
      l->next = tmp___9;
#line 371
      l->prev = tmp___9;
      }
    } else {
      {
#line 375
      cur.prev = l;
#line 376
      tmp___10 = xmalloc_real((size_t )sizeof(struct fileinfo ));
#line 376
      l->next = (struct fileinfo *)tmp___10;
#line 377
      l = l->next;
#line 378
      memcpy((void */* __restrict  */)l, (void const   */* __restrict  */)(& cur),
             (size_t )sizeof(cur));
#line 379
      l->next = (struct fileinfo *)((void *)0);
      }
    }
    {
#line 382
    timenow = time((time_t *)((void *)0));
#line 383
    tnow = localtime((time_t const   *)(& timenow));
#line 385
    timestruct.tm_sec = sec;
#line 386
    timestruct.tm_min = min;
#line 387
    timestruct.tm_hour = hour;
#line 388
    timestruct.tm_mday = day;
#line 389
    timestruct.tm_mon = month;
    }
#line 390
    if (year == 0) {
#line 397
      if (month > tnow->tm_mon) {
#line 398
        timestruct.tm_year = tnow->tm_year - 1;
      } else {
#line 400
        timestruct.tm_year = tnow->tm_year;
      }
    } else {
#line 403
      timestruct.tm_year = year;
    }
#line 404
    if (timestruct.tm_year >= 1900) {
#line 405
      timestruct.tm_year -= 1900;
    }
    {
#line 406
    timestruct.tm_wday = 0;
#line 407
    timestruct.tm_yday = 0;
#line 408
    timestruct.tm_isdst = -1;
#line 409
    l->tstamp = mktime(& timestruct);
#line 411
    free((void *)line);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 414
  fclose(fp);
  }
#line 415
  return (dir);
}
}
#line 418 "ftp-ls.c"
static struct fileinfo *ftp_parse_winnt_ls(char const   *file ) 
{ 
  FILE *fp ;
  int len ;
  int year ;
  int month ;
  int day ;
  int hour ;
  int min ;
  struct tm timestruct ;
  char *line ;
  char *tok ;
  struct fileinfo *dir ;
  struct fileinfo *l ;
  struct fileinfo cur ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  struct fileinfo *tmp___4 ;
  void *tmp___5 ;

  {
  {
#line 430
  fp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"rb");
  }
#line 431
  if (! fp) {
    {
#line 433
    tmp = __errno_location();
#line 433
    tmp___0 = strerror(*tmp);
#line 433
    logprintf((enum log_options )1, "%s: %s\n", file, tmp___0);
    }
#line 434
    return ((struct fileinfo *)((void *)0));
  }
#line 436
  l = (struct fileinfo *)((void *)0);
#line 436
  dir = l;
  {
#line 439
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 439
    line = read_whole_line(fp);
    }
#line 439
    if (! line) {
#line 439
      goto while_break;
    }
    {
#line 441
    len = clean_line(line);
    }
#line 449
    if (len < 40) {
#line 449
      goto while_continue;
    }
    {
#line 450
    tok = line + 39;
#line 451
    cur.name = xstrdup_real((char const   *)tok);
    }
    {
#line 452
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 452
      if (opt.debug) {
        {
#line 452
        debug_logprintf("Name: \'%s\'\n", cur.name);
        }
      }
#line 452
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 456
    tok = strtok((char */* __restrict  */)line, (char const   */* __restrict  */)"-");
#line 457
    tmp___1 = atoi((char const   *)tok);
#line 457
    month = tmp___1 - 1;
    }
#line 458
    if (month < 0) {
#line 458
      month = 0;
    }
    {
#line 459
    tok = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"-");
#line 460
    day = atoi((char const   *)tok);
#line 461
    tok = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ");
#line 462
    year = atoi((char const   *)tok);
    }
#line 464
    if (year <= 70) {
#line 464
      year += 100;
    }
    {
#line 468
    tok = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)":");
#line 469
    hour = atoi((char const   *)tok);
#line 470
    tok = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"M");
#line 471
    min = atoi((char const   *)tok);
#line 474
    tok += 2;
    }
#line 475
    if (hour == 12) {
#line 475
      hour = 0;
    }
#line 476
    if ((int )*tok == 80) {
#line 476
      hour += 12;
    }
    {
#line 478
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 478
      if (opt.debug) {
        {
#line 478
        debug_logprintf("YYYY/MM/DD HH:MM - %d/%02d/%02d %02d:%02d\n", year + 1900,
                        month, day, hour, min);
        }
      }
#line 478
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 482
    timestruct.tm_sec = 0;
#line 483
    timestruct.tm_min = min;
#line 484
    timestruct.tm_hour = hour;
#line 485
    timestruct.tm_mday = day;
#line 486
    timestruct.tm_mon = month;
#line 487
    timestruct.tm_year = year;
#line 488
    timestruct.tm_wday = 0;
#line 489
    timestruct.tm_yday = 0;
#line 490
    timestruct.tm_isdst = -1;
#line 491
    cur.tstamp = mktime(& timestruct);
    }
    {
#line 493
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 493
      if (opt.debug) {
        {
#line 493
        debug_logprintf("Timestamp: %ld\n", cur.tstamp);
        }
      }
#line 493
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 499
    tok = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ");
    }
    {
#line 500
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 500
      if (! ((int )*tok == 0)) {
#line 500
        goto while_break___3;
      }
      {
#line 500
      tok = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ");
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 501
    if ((int )*tok == 60) {
#line 503
      cur.type = (enum ftype )1;
#line 504
      cur.size = 0L;
#line 505
      cur.perms = 493;
      {
#line 506
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 506
        if (opt.debug) {
          {
#line 506
          debug_logprintf("Directory\n");
          }
        }
#line 506
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    } else {
      {
#line 510
      cur.type = (enum ftype )0;
#line 511
      tmp___2 = atoi((char const   *)tok);
#line 511
      cur.size = (long )tmp___2;
#line 512
      cur.perms = 420;
      }
      {
#line 513
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 513
        if (opt.debug) {
          {
#line 513
          debug_logprintf("File, size %ld bytes\n", cur.size);
          }
        }
#line 513
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
#line 516
    cur.linkto = (char *)((void *)0);
#line 519
    if (! dir) {
      {
#line 521
      tmp___3 = xmalloc_real((size_t )sizeof(struct fileinfo ));
#line 521
      dir = (struct fileinfo *)tmp___3;
#line 521
      l = dir;
#line 522
      memcpy((void */* __restrict  */)l, (void const   */* __restrict  */)(& cur),
             (size_t )sizeof(cur));
#line 523
      tmp___4 = (struct fileinfo *)((void *)0);
#line 523
      l->next = tmp___4;
#line 523
      l->prev = tmp___4;
      }
    } else {
      {
#line 527
      cur.prev = l;
#line 528
      tmp___5 = xmalloc_real((size_t )sizeof(struct fileinfo ));
#line 528
      l->next = (struct fileinfo *)tmp___5;
#line 529
      l = l->next;
#line 530
      memcpy((void */* __restrict  */)l, (void const   */* __restrict  */)(& cur),
             (size_t )sizeof(cur));
#line 531
      l->next = (struct fileinfo *)((void *)0);
      }
    }
    {
#line 534
    free((void *)line);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 537
  fclose(fp);
  }
#line 538
  return (dir);
}
}
#line 544 "ftp-ls.c"
static int vmsperms(char const   *s ) 
{ 
  int perms ;

  {
#line 547
  perms = 0;
  {
#line 549
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 552
    if ((int const   )*s == 44) {
#line 552
      goto case_44;
    }
#line 553
    if ((int const   )*s == 82) {
#line 553
      goto case_82;
    }
#line 554
    if ((int const   )*s == 87) {
#line 554
      goto case_87;
    }
#line 555
    if ((int const   )*s == 68) {
#line 555
      goto case_68;
    }
#line 556
    if ((int const   )*s == 69) {
#line 556
      goto case_69;
    }
#line 557
    goto switch_default;
    case_44: /* CIL Label */ 
#line 552
    perms <<= 3;
#line 552
    goto switch_break;
    case_82: /* CIL Label */ 
#line 553
    perms |= 4;
#line 553
    goto switch_break;
    case_87: /* CIL Label */ 
#line 554
    perms |= 2;
#line 554
    goto switch_break;
    case_68: /* CIL Label */ 
#line 555
    perms |= 2;
#line 555
    goto switch_break;
    case_69: /* CIL Label */ 
#line 556
    perms |= 1;
#line 556
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 557
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 557
      if (opt.debug) {
        {
#line 557
        debug_logprintf("wrong VMS permissons!\n");
        }
      }
#line 557
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    switch_break: /* CIL Label */ ;
    }
#line 549
    s ++;
#line 549
    if (! *s) {
#line 549
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 561
  return (perms);
}
}
#line 570
static struct fileinfo *ftp_parse_vms_ls(char const   *file ) ;
#line 570 "ftp-ls.c"
static char const   *months___0[12]  = 
#line 570
  {      "JAN",      "FEB",      "MAR",      "APR", 
        "MAY",      "JUN",      "JUL",      "AUG", 
        "SEP",      "OCT",      "NOV",      "DEC"};
#line 565 "ftp-ls.c"
static struct fileinfo *ftp_parse_vms_ls(char const   *file ) 
{ 
  FILE *fp ;
  int i ;
  int year ;
  int month ;
  int day ;
  int hour ;
  int min ;
  int sec ;
  struct tm timestruct ;
  char *line ;
  char *tok ;
  struct fileinfo *dir ;
  struct fileinfo *l ;
  struct fileinfo cur ;
  int *tmp ;
  char *tmp___0 ;
  char *p ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  struct fileinfo *tmp___6 ;
  void *tmp___7 ;

  {
  {
#line 582
  fp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"rb");
  }
#line 583
  if (! fp) {
    {
#line 585
    tmp = __errno_location();
#line 585
    tmp___0 = strerror(*tmp);
#line 585
    logprintf((enum log_options )1, "%s: %s\n", file, tmp___0);
    }
#line 586
    return ((struct fileinfo *)((void *)0));
  }
  {
#line 588
  l = (struct fileinfo *)((void *)0);
#line 588
  dir = l;
#line 591
  line = read_whole_line(fp);
  }
#line 592
  if (line) {
    {
#line 593
    free((void *)line);
    }
  }
  {
#line 596
  line = read_whole_line(fp);
  }
#line 597
  if (line) {
    {
#line 598
    free((void *)line);
    }
  }
  {
#line 601
  line = read_whole_line(fp);
  }
#line 602
  if (line) {
    {
#line 603
    free((void *)line);
    }
  }
  {
#line 606
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 606
    line = read_whole_line(fp);
    }
#line 606
    if (! line) {
#line 606
      goto while_break;
    }
    {
#line 609
    i = clean_line(line);
    }
#line 610
    if (! i) {
      {
#line 612
      free((void *)line);
      }
#line 613
      goto while_break;
    }
    {
#line 624
    tok = strtok((char */* __restrict  */)line, (char const   */* __restrict  */)" ");
    }
#line 625
    if ((unsigned long )tok == (unsigned long )((void *)0)) {
#line 625
      tok = line;
    }
    {
#line 626
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 626
      if (opt.debug) {
        {
#line 626
        debug_logprintf("file name: \'%s\'\n", tok);
        }
      }
#line 626
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 627
    p = tok;
    {
#line 627
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 627
      if (*p) {
#line 627
        if (! ((int )*p != 59)) {
#line 627
          goto while_break___1;
        }
      } else {
#line 627
        goto while_break___1;
      }
#line 627
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 628
    if ((int )*p == 59) {
#line 628
      *p = (char )'\000';
    }
    {
#line 629
    tmp___1 = strlen((char const   *)tok);
#line 629
    p = (tok + tmp___1) - 4;
#line 630
    tmp___2 = strcmp((char const   *)p, ".DIR");
    }
#line 630
    if (! tmp___2) {
#line 630
      *p = (char )'\000';
    }
    {
#line 631
    cur.name = xstrdup_real((char const   *)tok);
    }
    {
#line 632
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 632
      if (opt.debug) {
        {
#line 632
        debug_logprintf("Name: \'%s\'\n", cur.name);
        }
      }
#line 632
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 639
    if (! *p) {
#line 641
      cur.type = (enum ftype )1;
#line 642
      cur.size = 0L;
      {
#line 643
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 643
        if (opt.debug) {
          {
#line 643
          debug_logprintf("Directory\n");
          }
        }
#line 643
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    } else {
#line 647
      cur.type = (enum ftype )0;
      {
#line 648
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 648
        if (opt.debug) {
          {
#line 648
          debug_logprintf("File\n");
          }
        }
#line 648
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
    {
#line 651
    cur.size = 0L;
#line 656
    tok = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ");
    }
#line 657
    if ((unsigned long )tok == (unsigned long )((void *)0)) {
      {
#line 659
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 659
        if (opt.debug) {
          {
#line 659
          debug_logprintf("Getting additional line\n");
          }
        }
#line 659
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 660
      free((void *)line);
#line 661
      line = read_whole_line(fp);
      }
#line 662
      if (! line) {
        {
#line 664
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 664
          if (opt.debug) {
            {
#line 664
            debug_logprintf("empty line read, leaving listing parser\n");
            }
          }
#line 664
          goto while_break___6;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 665
        goto while_break;
      }
      {
#line 667
      i = clean_line(line);
      }
#line 668
      if (! i) {
        {
#line 670
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 670
          if (opt.debug) {
            {
#line 670
            debug_logprintf("confusing VMS listing item, leaving listing parser\n");
            }
          }
#line 670
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
        {
#line 671
        free((void *)line);
        }
#line 672
        goto while_break;
      }
      {
#line 674
      tok = strtok((char */* __restrict  */)line, (char const   */* __restrict  */)" ");
      }
    }
    {
#line 676
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 676
      if (opt.debug) {
        {
#line 676
        debug_logprintf("second token: \'%s\'\n", tok);
        }
      }
#line 676
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 680
    tok = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"-");
    }
    {
#line 681
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 681
      if (opt.debug) {
        {
#line 681
        debug_logprintf("day: \'%s\'\n", tok);
        }
      }
#line 681
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
    {
#line 682
    day = atoi((char const   *)tok);
#line 683
    tok = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"-");
    }
#line 684
    if (! tok) {
      {
#line 690
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 690
        if (opt.debug) {
          {
#line 690
          debug_logprintf("nonsense in VMS listing, skipping this line\n");
          }
        }
#line 690
        goto while_break___10;
      }
      while_break___10: /* CIL Label */ ;
      }
      {
#line 691
      free((void *)line);
      }
#line 692
      goto while_break;
    }
#line 694
    i = 0;
    {
#line 694
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 694
      if (! (i < 12)) {
#line 694
        goto while_break___11;
      }
      {
#line 694
      tmp___3 = strcmp((char const   *)tok, months___0[i]);
      }
#line 694
      if (! tmp___3) {
#line 694
        goto while_break___11;
      }
#line 694
      i ++;
    }
    while_break___11: /* CIL Label */ ;
    }
    {
#line 696
    month = i % 12;
#line 697
    tok = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ");
#line 698
    tmp___4 = atoi((char const   *)tok);
#line 698
    year = tmp___4 - 1900;
    }
    {
#line 699
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 699
      if (opt.debug) {
        {
#line 699
        debug_logprintf("date parsed\n");
        }
      }
#line 699
      goto while_break___12;
    }
    while_break___12: /* CIL Label */ ;
    }
    {
#line 702
    tok = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ");
#line 703
    sec = 0;
#line 703
    min = sec;
#line 703
    hour = min;
#line 704
    p = tok;
#line 705
    hour = atoi((char const   *)p);
    }
    {
#line 706
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 706
      if (*p) {
#line 706
        if (! ((int )*p != 58)) {
#line 706
          goto while_break___13;
        }
      } else {
#line 706
        goto while_break___13;
      }
#line 706
      p ++;
    }
    while_break___13: /* CIL Label */ ;
    }
#line 707
    if (*p) {
      {
#line 708
      p ++;
#line 708
      min = atoi((char const   *)p);
      }
    }
    {
#line 709
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 709
      if (*p) {
#line 709
        if (! ((int )*p != 58)) {
#line 709
          goto while_break___14;
        }
      } else {
#line 709
        goto while_break___14;
      }
#line 709
      p ++;
    }
    while_break___14: /* CIL Label */ ;
    }
#line 710
    if (*p) {
      {
#line 711
      p ++;
#line 711
      sec = atoi((char const   *)p);
      }
    }
    {
#line 713
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 713
      if (opt.debug) {
        {
#line 713
        debug_logprintf("YYYY/MM/DD HH:MM:SS - %d/%02d/%02d %02d:%02d:%02d\n", year + 1900,
                        month, day, hour, min, sec);
        }
      }
#line 713
      goto while_break___15;
    }
    while_break___15: /* CIL Label */ ;
    }
    {
#line 717
    timestruct.tm_sec = sec;
#line 718
    timestruct.tm_min = min;
#line 719
    timestruct.tm_hour = hour;
#line 720
    timestruct.tm_mday = day;
#line 721
    timestruct.tm_mon = month;
#line 722
    timestruct.tm_year = year;
#line 723
    timestruct.tm_wday = 0;
#line 724
    timestruct.tm_yday = 0;
#line 725
    timestruct.tm_isdst = -1;
#line 726
    cur.tstamp = mktime(& timestruct);
    }
    {
#line 728
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 728
      if (opt.debug) {
        {
#line 728
        debug_logprintf("Timestamp: %ld\n", cur.tstamp);
        }
      }
#line 728
      goto while_break___16;
    }
    while_break___16: /* CIL Label */ ;
    }
    {
#line 732
    tok = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ");
#line 736
    tok = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)",");
#line 737
    tok = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)")");
    }
#line 738
    if ((unsigned long )tok == (unsigned long )((void *)0)) {
      {
#line 740
      while (1) {
        while_continue___17: /* CIL Label */ ;
#line 740
        if (opt.debug) {
          {
#line 740
          debug_logprintf("confusing VMS permissions, skipping line\n");
          }
        }
#line 740
        goto while_break___17;
      }
      while_break___17: /* CIL Label */ ;
      }
      {
#line 741
      free((void *)line);
      }
#line 742
      goto while_continue;
    }
    {
#line 745
    cur.perms = vmsperms((char const   *)tok);
    }
    {
#line 746
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 746
      if (opt.debug) {
        {
#line 746
        debug_logprintf("permissions: %s -> 0%o\n", tok, cur.perms);
        }
      }
#line 746
      goto while_break___18;
    }
    while_break___18: /* CIL Label */ ;
    }
#line 748
    cur.linkto = (char *)((void *)0);
#line 751
    if (! dir) {
      {
#line 753
      tmp___5 = xmalloc_real((size_t )sizeof(struct fileinfo ));
#line 753
      dir = (struct fileinfo *)tmp___5;
#line 753
      l = dir;
#line 754
      memcpy((void */* __restrict  */)l, (void const   */* __restrict  */)(& cur),
             (size_t )sizeof(cur));
#line 755
      tmp___6 = (struct fileinfo *)((void *)0);
#line 755
      l->next = tmp___6;
#line 755
      l->prev = tmp___6;
      }
    } else {
      {
#line 759
      cur.prev = l;
#line 760
      tmp___7 = xmalloc_real((size_t )sizeof(struct fileinfo ));
#line 760
      l->next = (struct fileinfo *)tmp___7;
#line 761
      l = l->next;
#line 762
      memcpy((void */* __restrict  */)l, (void const   */* __restrict  */)(& cur),
             (size_t )sizeof(cur));
#line 763
      l->next = (struct fileinfo *)((void *)0);
      }
    }
    {
#line 766
    free((void *)line);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 769
  fclose(fp);
  }
#line 770
  return (dir);
}
}
#line 780 "ftp-ls.c"
struct fileinfo *ftp_parse_ls(char const   *file , enum stype  const  system_type ) 
{ 
  struct fileinfo *tmp ;
  FILE *fp ;
  int c ;
  int *tmp___0 ;
  char *tmp___1 ;
  struct fileinfo *tmp___2 ;
  struct fileinfo *tmp___3 ;
  struct fileinfo *tmp___4 ;
  struct fileinfo *tmp___5 ;
  char *tmp___6 ;
  struct fileinfo *tmp___7 ;

  {
  {
#line 785
  if ((unsigned int const   )system_type == 0U) {
#line 785
    goto case_0;
  }
#line 787
  if ((unsigned int const   )system_type == 2U) {
#line 787
    goto case_2;
  }
#line 807
  if ((unsigned int const   )system_type == 1U) {
#line 807
    goto case_1;
  }
#line 809
  if ((unsigned int const   )system_type == 3U) {
#line 809
    goto case_3;
  }
#line 811
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 786
  tmp = ftp_parse_unix_ls(file, 0);
  }
#line 786
  return (tmp);
  case_2: /* CIL Label */ 
  {
#line 792
  fp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"rb");
  }
#line 793
  if (! fp) {
    {
#line 795
    tmp___0 = __errno_location();
#line 795
    tmp___1 = strerror(*tmp___0);
#line 795
    logprintf((enum log_options )1, "%s: %s\n", file, tmp___1);
    }
#line 796
    return ((struct fileinfo *)((void *)0));
  }
  {
#line 798
  c = fgetc(fp);
#line 799
  fclose(fp);
  }
#line 802
  if (c >= 48) {
#line 802
    if (c <= 57) {
      {
#line 803
      tmp___2 = ftp_parse_winnt_ls(file);
      }
#line 803
      return (tmp___2);
    } else {
      {
#line 805
      tmp___3 = ftp_parse_unix_ls(file, 1);
      }
#line 805
      return (tmp___3);
    }
  } else {
    {
#line 805
    tmp___3 = ftp_parse_unix_ls(file, 1);
    }
#line 805
    return (tmp___3);
  }
  case_1: /* CIL Label */ 
  {
#line 808
  tmp___4 = ftp_parse_vms_ls(file);
  }
#line 808
  return (tmp___4);
  case_3: /* CIL Label */ 
  {
#line 810
  tmp___5 = ftp_parse_unix_ls(file, 1);
  }
#line 810
  return (tmp___5);
  switch_default: /* CIL Label */ 
  {
#line 812
  tmp___6 = gettext("Unsupported listing type, trying Unix listing parser.\n");
#line 812
  logprintf((enum log_options )1, (char const   *)tmp___6);
#line 814
  tmp___7 = ftp_parse_unix_ls(file, 0);
  }
#line 814
  return (tmp___7);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 868 "ftp-ls.c"
static char *months___1[12]  = 
#line 868
  {      (char *)"Jan",      (char *)"Feb",      (char *)"Mar",      (char *)"Apr", 
        (char *)"May",      (char *)"Jun",      (char *)"Jul",      (char *)"Aug", 
        (char *)"Sep",      (char *)"Oct",      (char *)"Nov",      (char *)"Dec"};
#line 823 "ftp-ls.c"
uerr_t ftp_index(char const   *file , struct url *u , struct fileinfo *f ) 
{ 
  FILE *fp ;
  char *upwd ;
  char *htclfile ;
  int *tmp ;
  char *tmp___0 ;
  char *tmpu ;
  char *tmpp ;
  char *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  struct tm *ptm ;
  struct tm *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char const   *tmp___18 ;

  {
#line 830
  if (! opt.dfp) {
    {
#line 832
    fp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"wb");
    }
#line 833
    if (! fp) {
      {
#line 835
      tmp = __errno_location();
#line 835
      tmp___0 = strerror(*tmp);
#line 835
      logprintf((enum log_options )1, "%s: %s\n", file, tmp___0);
      }
#line 836
      return ((uerr_t )28);
    }
  } else {
#line 840
    fp = opt.dfp;
  }
#line 841
  if (u->user) {
    {
#line 845
    tmpu = url_escape((char const   *)u->user);
    }
#line 846
    if (u->passwd) {
      {
#line 846
      tmp___1 = url_escape((char const   *)u->passwd);
#line 846
      tmpp = tmp___1;
      }
    } else {
#line 846
      tmpp = (char *)((void *)0);
    }
    {
#line 847
    tmp___2 = strlen((char const   *)tmpu);
    }
#line 847
    if (tmpp) {
      {
#line 847
      tmp___3 = strlen((char const   *)tmpp);
#line 847
      tmp___4 = 1U + tmp___3;
      }
    } else {
#line 847
      tmp___4 = (size_t )0;
    }
    {
#line 847
    tmp___5 = xmalloc_real((tmp___2 + tmp___4) + 2U);
#line 847
    upwd = (char *)tmp___5;
    }
#line 849
    if (tmpp) {
#line 849
      tmp___6 = (char const   *)tmpp;
    } else {
#line 849
      tmp___6 = "";
    }
#line 849
    if (tmpp) {
#line 849
      tmp___7 = ":";
    } else {
#line 849
      tmp___7 = "";
    }
    {
#line 849
    sprintf((char */* __restrict  */)upwd, (char const   */* __restrict  */)"%s%s%s@",
            tmpu, tmp___7, tmp___6);
#line 850
    free((void *)tmpu);
    }
    {
#line 851
    while (1) {
      while_continue: /* CIL Label */ ;
#line 851
      if (tmpp) {
        {
#line 851
        free((void *)tmpp);
        }
      }
#line 851
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 854
    upwd = xstrdup_real("");
    }
  }
  {
#line 855
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\n");
#line 856
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"<html>\n<head>\n<title>");
#line 857
  tmp___8 = gettext("Index of /%s on %s:%d");
#line 857
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)tmp___8, u->dir,
          u->host, u->port);
#line 858
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"</title>\n</head>\n<body>\n<h1>");
#line 859
  tmp___9 = gettext("Index of /%s on %s:%d");
#line 859
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)tmp___9, u->dir,
          u->host, u->port);
#line 860
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"</h1>\n<hr>\n<pre>\n");
  }
  {
#line 861
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 861
    if (! f) {
#line 861
      goto while_break___0;
    }
    {
#line 863
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"  ");
    }
#line 864
    if (f->tstamp != -1L) {
      {
#line 872
      tmp___10 = localtime((time_t const   *)(& f->tstamp));
#line 872
      ptm = tmp___10;
#line 874
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%d %s %02d ",
              ptm->tm_year + 1900, months___1[ptm->tm_mon], ptm->tm_mday);
      }
#line 876
      if (ptm->tm_hour) {
        {
#line 877
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%02d:%02d  ",
                ptm->tm_hour, ptm->tm_min);
        }
      } else {
        {
#line 879
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"       ");
        }
      }
    } else {
      {
#line 882
      tmp___11 = gettext("time unknown       ");
#line 882
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)tmp___11);
      }
    }
    {
#line 885
    if ((unsigned int )f->type == 0U) {
#line 885
      goto case_0;
    }
#line 888
    if ((unsigned int )f->type == 1U) {
#line 888
      goto case_1;
    }
#line 891
    if ((unsigned int )f->type == 2U) {
#line 891
      goto case_2;
    }
#line 894
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 886
    tmp___12 = gettext("File        ");
#line 886
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)tmp___12);
    }
#line 887
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 889
    tmp___13 = gettext("Directory   ");
#line 889
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)tmp___13);
    }
#line 890
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 892
    tmp___14 = gettext("Link        ");
#line 892
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)tmp___14);
    }
#line 893
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 895
    tmp___15 = gettext("Not sure    ");
#line 895
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)tmp___15);
    }
#line 896
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 898
    htclfile = html_quote_string((char const   *)f->name);
#line 899
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"<a href=\"ftp://%s%s:%hu",
            upwd, u->host, u->port);
    }
#line 900
    if ((int )*(u->dir) != 47) {
      {
#line 901
      _IO_putc('/', fp);
      }
    }
    {
#line 902
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s", u->dir);
    }
#line 903
    if (*(u->dir)) {
      {
#line 904
      _IO_putc('/', fp);
      }
    }
    {
#line 905
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s", htclfile);
    }
#line 906
    if ((unsigned int )f->type == 1U) {
      {
#line 907
      _IO_putc('/', fp);
      }
    }
    {
#line 908
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\">%s",
            htclfile);
    }
#line 909
    if ((unsigned int )f->type == 1U) {
      {
#line 910
      _IO_putc('/', fp);
      }
    }
    {
#line 911
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"</a> ");
    }
#line 912
    if ((unsigned int )f->type == 0U) {
      {
#line 913
      tmp___16 = legible(f->size);
#line 913
      tmp___17 = gettext(" (%s bytes)");
#line 913
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)tmp___17,
              tmp___16);
      }
    } else
#line 914
    if ((unsigned int )f->type == 2U) {
#line 915
      if (f->linkto) {
#line 915
        tmp___18 = (char const   *)f->linkto;
      } else {
#line 915
        tmp___18 = "(nil)";
      }
      {
#line 915
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"-> %s",
              tmp___18);
      }
    }
    {
#line 916
    _IO_putc('\n', fp);
#line 917
    free((void *)htclfile);
#line 918
    f = f->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 920
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"</pre>\n</body>\n</html>\n");
#line 921
  free((void *)upwd);
  }
#line 922
  if (! opt.dfp) {
    {
#line 923
    fclose(fp);
    }
  } else {
    {
#line 925
    fflush(fp);
    }
  }
#line 926
  return ((uerr_t )15);
}
}
#line 176 "/usr/include/stdlib.h"
extern long strtol(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                   int __base ) ;
#line 43 "connect.h"
uerr_t bindport(unsigned short *port , int family ) ;
#line 46
int conaddr(int fd , ip_address *ip ) ;
#line 49 "ftp.h"
uerr_t ftp_response(struct rbuf *rbuf , char **line ) ;
#line 50
uerr_t ftp_login(struct rbuf *rbuf , char const   *acc , char const   *pass ) ;
#line 51
uerr_t ftp_port(struct rbuf *rbuf ) ;
#line 52
uerr_t ftp_pasv(struct rbuf *rbuf , ip_address *addr___0 , unsigned short *port ) ;
#line 57
uerr_t ftp_type(struct rbuf *rbuf , int type ) ;
#line 58
uerr_t ftp_cwd(struct rbuf *rbuf , char const   *dir ) ;
#line 59
uerr_t ftp_retr(struct rbuf *rbuf , char const   *file ) ;
#line 60
uerr_t ftp_rest(struct rbuf *rbuf , long offset ) ;
#line 61
uerr_t ftp_list(struct rbuf *rbuf , char const   *file ) ;
#line 62
uerr_t ftp_syst(struct rbuf *rbuf , enum stype *server_type ) ;
#line 63
uerr_t ftp_pwd(struct rbuf *rbuf , char **pwd ) ;
#line 64
uerr_t ftp_size(struct rbuf *rbuf , char const   *file , long *size ) ;
#line 123
char ftp_process_type(char const   *params ) ;
#line 64 "ftp-basic.c"
char ftp_last_respline[128]  ;
#line 71 "ftp-basic.c"
uerr_t ftp_response(struct rbuf *rbuf , char **line ) 
{ 
  int i ;
  int bufsize ;
  void *tmp ;
  int res___0 ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 75
  bufsize = 40;
#line 77
  tmp = xmalloc_real((size_t )bufsize);
#line 77
  *line = (char *)tmp;
  }
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    i = 0;
    {
#line 80
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 83
      if (i > bufsize - 1) {
        {
#line 84
        bufsize <<= 1;
#line 84
        tmp___0 = xrealloc_real((void *)*line, (size_t )bufsize);
#line 84
        *line = (char *)tmp___0;
        }
      }
#line 85
      if (rbuf->buffer_left) {
#line 85
        (rbuf->buffer_left) --;
#line 85
        tmp___1 = rbuf->buffer_pos;
#line 85
        (rbuf->buffer_pos) ++;
#line 85
        *(*line + i) = *tmp___1;
#line 85
        res___0 = 1;
      } else {
        {
#line 85
        rbuf->buffer_pos = rbuf->buffer;
#line 85
        tmp___5 = rbuf_read_bufferful(rbuf);
#line 85
        rbuf->internal_dont_touch_this = tmp___5;
        }
#line 85
        if (tmp___5 <= 0) {
#line 85
          tmp___4 = rbuf->internal_dont_touch_this;
        } else {
#line 85
          rbuf->buffer_left = (size_t )(rbuf->internal_dont_touch_this - 1);
#line 85
          tmp___3 = rbuf->buffer_pos;
#line 85
          (rbuf->buffer_pos) ++;
#line 85
          *(*line + i) = *tmp___3;
#line 85
          tmp___4 = 1;
        }
#line 85
        res___0 = tmp___4;
      }
#line 87
      if (res___0 == 1) {
#line 89
        if ((int )*(*line + i) == 10) {
#line 91
          *(*line + i) = (char )'\000';
#line 93
          if (i > 0) {
#line 93
            if ((int )*(*line + (i - 1)) == 13) {
#line 94
              *(*line + (i - 1)) = (char )'\000';
            }
          }
#line 95
          goto while_break___0;
        }
      } else {
#line 99
        return ((uerr_t )22);
      }
#line 80
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 101
    if (opt.server_response) {
      {
#line 102
      logprintf((enum log_options )3, "%s\n", *line);
      }
    } else {
      {
#line 104
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 104
        if (opt.debug) {
          {
#line 104
          debug_logprintf("%s\n", *line);
          }
        }
#line 104
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 78
    if (i >= 3) {
#line 78
      if ((int const   )_sch_istable[(int )*(*line) & 255] & 4) {
#line 78
        if ((int const   )_sch_istable[(int )*(*line + 1) & 255] & 4) {
#line 78
          if ((int const   )_sch_istable[(int )*(*line + 2) & 255] & 4) {
#line 78
            if ((int )*(*line + 3) == 32) {
#line 78
              goto while_break;
            }
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 108
  strncpy((char */* __restrict  */)(ftp_last_respline), (char const   */* __restrict  */)*line,
          (size_t )sizeof(ftp_last_respline));
#line 109
  ftp_last_respline[sizeof(ftp_last_respline) - 1UL] = (char )'\000';
  }
#line 110
  return ((uerr_t )15);
}
}
#line 116 "ftp-basic.c"
static char *ftp_request(char const   *command , char const   *value ) 
{ 
  char *res___0 ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 119
  tmp = strlen(command);
  }
#line 119
  if (value) {
    {
#line 119
    tmp___0 = strlen(value);
#line 119
    tmp___1 = 1U + tmp___0;
    }
  } else {
#line 119
    tmp___1 = (size_t )0;
  }
  {
#line 119
  tmp___2 = xmalloc_real(((tmp + tmp___1) + 2U) + 1U);
#line 119
  res___0 = (char *)tmp___2;
  }
#line 122
  if (value) {
#line 122
    tmp___3 = value;
  } else {
#line 122
    tmp___3 = "";
  }
#line 122
  if (value) {
#line 122
    tmp___4 = " ";
  } else {
#line 122
    tmp___4 = "";
  }
  {
#line 122
  sprintf((char */* __restrict  */)res___0, (char const   */* __restrict  */)"%s%s%s\r\n",
          command, tmp___4, tmp___3);
  }
#line 123
  if (opt.server_response) {
    {
#line 126
    tmp___5 = strncmp((char const   *)res___0, "PASS", (size_t )4);
    }
#line 126
    if (tmp___5 != 0) {
      {
#line 127
      logprintf((enum log_options )3, "--> %s\n", res___0);
      }
    } else {
      {
#line 129
      logputs((enum log_options )3, "--> PASS Turtle Power!\n");
      }
    }
  } else {
    {
#line 132
    while (1) {
      while_continue: /* CIL Label */ ;
#line 132
      if (opt.debug) {
        {
#line 132
        debug_logprintf("\n--> %s\n", res___0);
        }
      }
#line 132
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 133
  return (res___0);
}
}
#line 192 "ftp-basic.c"
static char const   *skey_head[2]  = {      "331 s/key ",      "331 opiekey "};
#line 142 "ftp-basic.c"
uerr_t ftp_login(struct rbuf *rbuf , char const   *acc , char const   *pass ) 
{ 
  uerr_t err ;
  char *request ;
  char *respline ;
  int nwritten ;
  size_t tmp ;
  int i ;
  size_t tmp___0 ;
  int tmp___1 ;
  char const   *cp ;
  int skey_sequence ;
  size_t tmp___2 ;
  size_t tmp___3 ;

  {
  {
#line 150
  err = ftp_response(rbuf, & respline);
  }
#line 151
  if ((unsigned int )err != 15U) {
    {
#line 153
    free((void *)respline);
    }
#line 154
    return (err);
  }
#line 156
  if ((int )*respline != 50) {
    {
#line 158
    free((void *)respline);
    }
#line 159
    return ((uerr_t )24);
  }
  {
#line 161
  free((void *)respline);
#line 163
  request = ftp_request("USER", acc);
#line 164
  tmp = strlen((char const   *)request);
#line 164
  nwritten = iwrite(rbuf->fd, request, (int )tmp);
  }
#line 165
  if (nwritten < 0) {
    {
#line 167
    free((void *)request);
    }
#line 168
    return ((uerr_t )55);
  }
  {
#line 170
  free((void *)request);
#line 172
  err = ftp_response(rbuf, & respline);
  }
#line 173
  if ((unsigned int )err != 15U) {
    {
#line 175
    free((void *)respline);
    }
#line 176
    return (err);
  }
#line 179
  if ((int )*respline == 50) {
    {
#line 181
    free((void *)respline);
    }
#line 182
    return ((uerr_t )15);
  }
#line 185
  if ((int )*respline != 51) {
    {
#line 187
    free((void *)respline);
    }
#line 188
    return ((uerr_t )17);
  }
#line 198
  i = 0;
  {
#line 198
  while (1) {
    while_continue: /* CIL Label */ ;
#line 198
    if (! ((unsigned long )i < sizeof(skey_head) / sizeof(skey_head[0]))) {
#line 198
      goto while_break;
    }
    {
#line 200
    tmp___0 = strlen(skey_head[i]);
#line 200
    tmp___1 = strncasecmp(skey_head[i], (char const   *)respline, tmp___0);
    }
#line 200
    if (tmp___1 == 0) {
#line 201
      goto while_break;
    }
#line 198
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 203
  if ((unsigned long )i < sizeof(skey_head) / sizeof(skey_head[0])) {
    {
#line 206
    skey_sequence = 0;
#line 208
    tmp___2 = strlen(skey_head[i]);
#line 208
    cp = (char const   *)(respline + tmp___2);
    }
    {
#line 208
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 208
      if (48 <= (int )*cp) {
#line 208
        if (! ((int const   )*cp <= 57)) {
#line 208
          goto while_break___0;
        }
      } else {
#line 208
        goto while_break___0;
      }
#line 212
      skey_sequence = (skey_sequence * 10 + (int )*cp) - 48;
#line 208
      cp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 214
    if ((int const   )*cp == 32) {
#line 215
      cp ++;
    } else {
      bad: 
      {
#line 219
      free((void *)respline);
      }
#line 220
      return ((uerr_t )17);
    }
    {
#line 222
    cp = calculate_skey_response(skey_sequence, cp, pass);
    }
#line 222
    if ((unsigned long )cp == (unsigned long )((char const   *)0)) {
#line 223
      goto bad;
    }
#line 224
    pass = cp;
  }
  {
#line 228
  free((void *)respline);
#line 230
  request = ftp_request("PASS", pass);
#line 231
  tmp___3 = strlen((char const   *)request);
#line 231
  nwritten = iwrite(rbuf->fd, request, (int )tmp___3);
  }
#line 232
  if (nwritten < 0) {
    {
#line 234
    free((void *)request);
    }
#line 235
    return ((uerr_t )55);
  }
  {
#line 237
  free((void *)request);
#line 239
  err = ftp_response(rbuf, & respline);
  }
#line 240
  if ((unsigned int )err != 15U) {
    {
#line 242
    free((void *)respline);
    }
#line 243
    return (err);
  }
#line 245
  if ((int )*respline != 50) {
    {
#line 247
    free((void *)respline);
    }
#line 248
    return ((uerr_t )16);
  }
  {
#line 250
  free((void *)respline);
  }
#line 252
  return ((uerr_t )15);
}
}
#line 314 "ftp-basic.c"
uerr_t ftp_port(struct rbuf *rbuf ) 
{ 
  uerr_t err ;
  char *request ;
  char *respline ;
  char bytes[25] ;
  ip_address in_addr ;
  ip4_address in_addr_4 ;
  unsigned char *in_addr4_ptr ;
  int nwritten ;
  unsigned short port ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 323
  in_addr4_ptr = (unsigned char *)(& in_addr_4);
#line 339
  port = (unsigned short)0;
#line 341
  err = bindport(& port, 2);
  }
#line 342
  if ((unsigned int )err != 10U) {
#line 343
    return (err);
  }
  {
#line 347
  tmp = conaddr(rbuf->fd, & in_addr);
  }
#line 347
  if (! tmp) {
#line 349
    return ((uerr_t )9);
  }
  {
#line 350
  tmp___0 = map_ip_to_ipv4(& in_addr, & in_addr_4);
  }
#line 350
  if (! tmp___0) {
#line 351
    return ((uerr_t )9);
  }
  {
#line 357
  sprintf((char */* __restrict  */)(bytes), (char const   */* __restrict  */)"%d,%d,%d,%d,%d,%d",
          (int )*(in_addr4_ptr + 0), (int )*(in_addr4_ptr + 1), (int )*(in_addr4_ptr + 2),
          (int )*(in_addr4_ptr + 3), (int )port >> 8, (int )port & 255);
#line 361
  request = ftp_request("PORT", (char const   *)(bytes));
#line 362
  tmp___1 = strlen((char const   *)request);
#line 362
  nwritten = iwrite(rbuf->fd, request, (int )tmp___1);
  }
#line 363
  if (nwritten < 0) {
    {
#line 365
    free((void *)request);
    }
#line 366
    return ((uerr_t )55);
  }
  {
#line 368
  free((void *)request);
#line 370
  err = ftp_response(rbuf, & respline);
  }
#line 371
  if ((unsigned int )err != 15U) {
    {
#line 373
    free((void *)respline);
    }
#line 374
    return (err);
  }
#line 376
  if ((int )*respline != 50) {
    {
#line 378
    free((void *)respline);
    }
#line 379
    return ((uerr_t )18);
  }
  {
#line 381
  free((void *)respline);
  }
#line 382
  return ((uerr_t )15);
}
}
#line 448 "ftp-basic.c"
uerr_t ftp_pasv(struct rbuf *rbuf , ip_address *addr___0 , unsigned short *port ) 
{ 
  char *request ;
  char *respline ;
  char *s ;
  int nwritten ;
  int i ;
  uerr_t err ;
  unsigned char addr4[4] ;
  size_t tmp ;
  unsigned short port2 ;

  {
  {
#line 468
  request = ftp_request("PASV", (char const   *)((void *)0));
#line 470
  tmp = strlen((char const   *)request);
#line 470
  nwritten = iwrite(rbuf->fd, request, (int )tmp);
  }
#line 471
  if (nwritten < 0) {
    {
#line 473
    free((void *)request);
    }
#line 474
    return ((uerr_t )55);
  }
  {
#line 476
  free((void *)request);
#line 478
  err = ftp_response(rbuf, & respline);
  }
#line 479
  if ((unsigned int )err != 15U) {
    {
#line 481
    free((void *)respline);
    }
#line 482
    return (err);
  }
#line 484
  if ((int )*respline != 50) {
    {
#line 486
    free((void *)respline);
    }
#line 487
    return ((uerr_t )39);
  }
#line 491
  s = respline;
#line 492
  s += 4;
  {
#line 492
  while (1) {
    while_continue: /* CIL Label */ ;
#line 492
    if (*s) {
#line 492
      if (! (! ((int const   )_sch_istable[(int )*s & 255] & 4))) {
#line 492
        goto while_break;
      }
    } else {
#line 492
      goto while_break;
    }
#line 492
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 493
  if (! *s) {
#line 494
    return ((uerr_t )38);
  }
#line 495
  i = 0;
  {
#line 495
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 495
    if (! (i < 4)) {
#line 495
      goto while_break___0;
    }
#line 497
    addr4[i] = (unsigned char)0;
    {
#line 498
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 498
      if (! ((int const   )_sch_istable[(int )*s & 255] & 4)) {
#line 498
        goto while_break___1;
      }
#line 499
      addr4[i] = (unsigned char )(((int )*s - 48) + 10 * (int )addr4[i]);
#line 498
      s ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 500
    if ((int )*s == 44) {
#line 501
      s ++;
    } else {
      {
#line 504
      free((void *)respline);
      }
#line 505
      return ((uerr_t )38);
    }
#line 495
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 510
  map_ipv4_to_ip((ip4_address *)(addr4), addr___0);
#line 512
  *port = (unsigned short)0;
  }
  {
#line 513
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 513
    if (! ((int const   )_sch_istable[(int )*s & 255] & 4)) {
#line 513
      goto while_break___2;
    }
#line 514
    *port = (unsigned short )(((int )*s - 48) + 10 * (int )*port);
#line 513
    s ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 515
  if ((int )*s == 44) {
#line 516
    s ++;
  } else {
    {
#line 519
    free((void *)respline);
    }
#line 520
    return ((uerr_t )38);
  }
#line 524
  port2 = (unsigned short)0;
  {
#line 525
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 525
    if (! ((int const   )_sch_istable[(int )*s & 255] & 4)) {
#line 525
      goto while_break___3;
    }
#line 526
    port2 = (unsigned short )(((int )*s - 48) + 10 * (int )port2);
#line 525
    s ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 527
  *port = (unsigned short )((int )*port * 256 + (int )port2);
#line 529
  free((void *)respline);
  }
#line 530
  return ((uerr_t )15);
}
}
#line 534 "ftp-basic.c"
uerr_t ftp_type(struct rbuf *rbuf , int type ) 
{ 
  char *request ;
  char *respline ;
  int nwritten ;
  uerr_t err ;
  char stype[2] ;
  size_t tmp ;

  {
  {
#line 543
  stype[0] = (char )type;
#line 544
  stype[1] = (char)0;
#line 546
  request = ftp_request("TYPE", (char const   *)(stype));
#line 547
  tmp = strlen((char const   *)request);
#line 547
  nwritten = iwrite(rbuf->fd, request, (int )tmp);
  }
#line 548
  if (nwritten < 0) {
    {
#line 550
    free((void *)request);
    }
#line 551
    return ((uerr_t )55);
  }
  {
#line 553
  free((void *)request);
#line 555
  err = ftp_response(rbuf, & respline);
  }
#line 556
  if ((unsigned int )err != 15U) {
    {
#line 558
    free((void *)respline);
    }
#line 559
    return (err);
  }
#line 561
  if ((int )*respline != 50) {
    {
#line 563
    free((void *)respline);
    }
#line 564
    return ((uerr_t )21);
  }
  {
#line 566
  free((void *)respline);
  }
#line 568
  return ((uerr_t )15);
}
}
#line 573 "ftp-basic.c"
uerr_t ftp_cwd(struct rbuf *rbuf , char const   *dir ) 
{ 
  char *request ;
  char *respline ;
  int nwritten ;
  uerr_t err ;
  size_t tmp ;

  {
  {
#line 581
  request = ftp_request("CWD", dir);
#line 582
  tmp = strlen((char const   *)request);
#line 582
  nwritten = iwrite(rbuf->fd, request, (int )tmp);
  }
#line 583
  if (nwritten < 0) {
    {
#line 585
    free((void *)request);
    }
#line 586
    return ((uerr_t )55);
  }
  {
#line 588
  free((void *)request);
#line 590
  err = ftp_response(rbuf, & respline);
  }
#line 591
  if ((unsigned int )err != 15U) {
    {
#line 593
    free((void *)respline);
    }
#line 594
    return (err);
  }
#line 596
  if ((int )*respline == 53) {
    {
#line 598
    free((void *)respline);
    }
#line 599
    return ((uerr_t )19);
  }
#line 601
  if ((int )*respline != 50) {
    {
#line 603
    free((void *)respline);
    }
#line 604
    return ((uerr_t )22);
  }
  {
#line 606
  free((void *)respline);
  }
#line 608
  return ((uerr_t )15);
}
}
#line 618 "ftp-basic.c"
static char numbuf[24]  ;
#line 612 "ftp-basic.c"
uerr_t ftp_rest(struct rbuf *rbuf , long offset ) 
{ 
  char *request ;
  char *respline ;
  int nwritten ;
  uerr_t err ;
  size_t tmp ;

  {
  {
#line 620
  number_to_string(numbuf, offset);
#line 621
  request = ftp_request("REST", (char const   *)(numbuf));
#line 622
  tmp = strlen((char const   *)request);
#line 622
  nwritten = iwrite(rbuf->fd, request, (int )tmp);
  }
#line 623
  if (nwritten < 0) {
    {
#line 625
    free((void *)request);
    }
#line 626
    return ((uerr_t )55);
  }
  {
#line 628
  free((void *)request);
#line 630
  err = ftp_response(rbuf, & respline);
  }
#line 631
  if ((unsigned int )err != 15U) {
    {
#line 633
    free((void *)respline);
    }
#line 634
    return (err);
  }
#line 636
  if ((int )*respline != 51) {
    {
#line 638
    free((void *)respline);
    }
#line 639
    return ((uerr_t )26);
  }
  {
#line 641
  free((void *)respline);
  }
#line 643
  return ((uerr_t )15);
}
}
#line 647 "ftp-basic.c"
uerr_t ftp_retr(struct rbuf *rbuf , char const   *file ) 
{ 
  char *request ;
  char *respline ;
  int nwritten ;
  uerr_t err ;
  size_t tmp ;

  {
  {
#line 655
  request = ftp_request("RETR", file);
#line 656
  tmp = strlen((char const   *)request);
#line 656
  nwritten = iwrite(rbuf->fd, request, (int )tmp);
  }
#line 657
  if (nwritten < 0) {
    {
#line 659
    free((void *)request);
    }
#line 660
    return ((uerr_t )55);
  }
  {
#line 662
  free((void *)request);
#line 664
  err = ftp_response(rbuf, & respline);
  }
#line 665
  if ((unsigned int )err != 15U) {
    {
#line 667
    free((void *)respline);
    }
#line 668
    return (err);
  }
#line 670
  if ((int )*respline == 53) {
    {
#line 672
    free((void *)respline);
    }
#line 673
    return ((uerr_t )19);
  }
#line 675
  if ((int )*respline != 49) {
    {
#line 677
    free((void *)respline);
    }
#line 678
    return ((uerr_t )22);
  }
  {
#line 680
  free((void *)respline);
  }
#line 682
  return ((uerr_t )15);
}
}
#line 687 "ftp-basic.c"
uerr_t ftp_list(struct rbuf *rbuf , char const   *file ) 
{ 
  char *request ;
  char *respline ;
  int nwritten ;
  uerr_t err ;
  size_t tmp ;

  {
  {
#line 695
  request = ftp_request("LIST", file);
#line 696
  tmp = strlen((char const   *)request);
#line 696
  nwritten = iwrite(rbuf->fd, request, (int )tmp);
  }
#line 697
  if (nwritten < 0) {
    {
#line 699
    free((void *)request);
    }
#line 700
    return ((uerr_t )55);
  }
  {
#line 702
  free((void *)request);
#line 704
  err = ftp_response(rbuf, & respline);
  }
#line 705
  if ((unsigned int )err != 15U) {
    {
#line 707
    free((void *)respline);
    }
#line 708
    return (err);
  }
#line 710
  if ((int )*respline == 53) {
    {
#line 712
    free((void *)respline);
    }
#line 713
    return ((uerr_t )19);
  }
#line 715
  if ((int )*respline != 49) {
    {
#line 717
    free((void *)respline);
    }
#line 718
    return ((uerr_t )22);
  }
  {
#line 720
  free((void *)respline);
  }
#line 722
  return ((uerr_t )15);
}
}
#line 726 "ftp-basic.c"
uerr_t ftp_syst(struct rbuf *rbuf , enum stype *server_type ) 
{ 
  char *request ;
  char *respline ;
  int nwritten ;
  uerr_t err ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 734
  request = ftp_request("SYST", (char const   *)((void *)0));
#line 735
  tmp = strlen((char const   *)request);
#line 735
  nwritten = iwrite(rbuf->fd, request, (int )tmp);
  }
#line 736
  if (nwritten < 0) {
    {
#line 738
    free((void *)request);
    }
#line 739
    return ((uerr_t )55);
  }
  {
#line 741
  free((void *)request);
#line 744
  err = ftp_response(rbuf, & respline);
  }
#line 745
  if ((unsigned int )err != 15U) {
    {
#line 747
    free((void *)respline);
    }
#line 748
    return (err);
  }
#line 750
  if ((int )*respline == 53) {
    {
#line 752
    free((void *)respline);
    }
#line 753
    return ((uerr_t )24);
  }
  {
#line 757
  strtok((char */* __restrict  */)respline, (char const   */* __restrict  */)" ");
#line 761
  request = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ");
#line 763
  tmp___4 = strcasecmp((char const   *)request, "VMS");
  }
#line 763
  if (tmp___4) {
    {
#line 765
    tmp___3 = strcasecmp((char const   *)request, "UNIX");
    }
#line 765
    if (tmp___3) {
      {
#line 767
      tmp___2 = strcasecmp((char const   *)request, "WINDOWS_NT");
      }
#line 767
      if (tmp___2) {
        {
#line 769
        tmp___1 = strcasecmp((char const   *)request, "MACOS");
        }
#line 769
        if (tmp___1) {
          {
#line 771
          tmp___0 = strcasecmp((char const   *)request, "OS/400");
          }
#line 771
          if (tmp___0) {
#line 774
            *server_type = (enum stype )5;
          } else {
#line 772
            *server_type = (enum stype )4;
          }
        } else {
#line 770
          *server_type = (enum stype )3;
        }
      } else {
#line 768
        *server_type = (enum stype )2;
      }
    } else {
#line 766
      *server_type = (enum stype )0;
    }
  } else {
#line 764
    *server_type = (enum stype )1;
  }
  {
#line 776
  free((void *)respline);
  }
#line 778
  return ((uerr_t )15);
}
}
#line 782 "ftp-basic.c"
uerr_t ftp_pwd(struct rbuf *rbuf , char **pwd ) 
{ 
  char *request ;
  char *respline ;
  int nwritten ;
  uerr_t err ;
  size_t tmp ;

  {
  {
#line 790
  request = ftp_request("PWD", (char const   *)((void *)0));
#line 791
  tmp = strlen((char const   *)request);
#line 791
  nwritten = iwrite(rbuf->fd, request, (int )tmp);
  }
#line 792
  if (nwritten < 0) {
    {
#line 794
    free((void *)request);
    }
#line 795
    return ((uerr_t )55);
  }
  {
#line 797
  free((void *)request);
#line 799
  err = ftp_response(rbuf, & respline);
  }
#line 800
  if ((unsigned int )err != 15U) {
    {
#line 802
    free((void *)respline);
    }
#line 803
    return (err);
  }
#line 805
  if ((int )*respline == 53) {
    {
#line 807
    free((void *)respline);
    }
#line 808
    return ((uerr_t )24);
  }
  {
#line 813
  strtok((char */* __restrict  */)respline, (char const   */* __restrict  */)"\"");
#line 814
  request = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)"\"");
  }
  {
#line 817
  while (1) {
    while_continue: /* CIL Label */ ;
#line 817
    if (*pwd) {
      {
#line 817
      free((void *)*pwd);
      }
    }
#line 817
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 819
  *pwd = xstrdup_real((char const   *)request);
#line 821
  free((void *)respline);
  }
#line 823
  return ((uerr_t )15);
}
}
#line 828 "ftp-basic.c"
uerr_t ftp_size(struct rbuf *rbuf , char const   *file , long *size ) 
{ 
  char *request ;
  char *respline ;
  int nwritten ;
  uerr_t err ;
  size_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 836
  request = ftp_request("SIZE", file);
#line 837
  tmp = strlen((char const   *)request);
#line 837
  nwritten = iwrite(rbuf->fd, request, (int )tmp);
  }
#line 838
  if (nwritten < 0) {
    {
#line 840
    free((void *)request);
#line 841
    *size = 0L;
    }
#line 842
    return ((uerr_t )55);
  }
  {
#line 844
  free((void *)request);
#line 846
  err = ftp_response(rbuf, & respline);
  }
#line 847
  if ((unsigned int )err != 15U) {
    {
#line 849
    free((void *)respline);
#line 850
    *size = 0L;
    }
#line 851
    return (err);
  }
#line 853
  if ((int )*respline == 53) {
    {
#line 859
    free((void *)respline);
#line 860
    *size = 0L;
    }
#line 861
    return ((uerr_t )15);
  }
  {
#line 864
  tmp___0 = __errno_location();
#line 864
  *tmp___0 = 0;
#line 865
  *size = strtol((char const   */* __restrict  */)(respline + 4), (char **/* __restrict  */)((void *)0),
                 0);
#line 866
  tmp___1 = __errno_location();
  }
#line 866
  if (*tmp___1) {
    {
#line 874
    free((void *)respline);
#line 875
    *size = 0L;
    }
#line 876
    return ((uerr_t )15);
  }
  {
#line 879
  free((void *)respline);
  }
#line 881
  return ((uerr_t )15);
}
}
#line 886 "ftp-basic.c"
char ftp_process_type(char const   *params ) 
{ 
  int tmp ;

  {
#line 889
  if (params) {
    {
#line 889
    tmp = strncasecmp(params, "type=", (size_t )5);
    }
#line 889
    if (0 == tmp) {
#line 889
      if ((int const   )*(params + 5) != 0) {
#line 892
        return ((char )_sch_toupper[(int const   )*(params + 5) & 255]);
      } else {
#line 894
        return ((char )'I');
      }
    } else {
#line 894
      return ((char )'I');
    }
  } else {
#line 894
    return ((char )'I');
  }
}
}
#line 726 "/usr/include/unistd.h"
extern int symlink(char const   *__from , char const   *__to ) ;
#line 731
extern int readlink(char const   * __restrict  __path , char * __restrict  __buf ,
                    size_t __len ) ;
#line 255 "/usr/include/sys/stat.h"
extern int chmod(char const   *__file , __mode_t __mode ) ;
#line 37 "connect.h"
int connect_to_one(ip_address *addr___0 , unsigned short port , int silent ) ;
#line 44
uerr_t acceptport(int *sock ) ;
#line 45
void closeport(int sock ) ;
#line 85 "ftp.c"
static long ftp_expected_bytes(char const   *s ) 
{ 
  long res___0 ;
  int tmp ;

  {
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 92
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 92
      if (*s) {
#line 92
        if (! ((int const   )*s != 40)) {
#line 92
          goto while_break___0;
        }
      } else {
#line 92
        goto while_break___0;
      }
#line 93
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 94
    if (! *s) {
#line 95
      return (0L);
    }
#line 96
    s ++;
    {
#line 96
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 96
      if (*s) {
#line 96
        if (! ((int const   )_sch_istable[(int const   )*s & 255] & 64)) {
#line 96
          goto while_break___1;
        }
      } else {
#line 96
        goto while_break___1;
      }
#line 96
      s ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 97
    if (! *s) {
#line 98
      return (0L);
    }
#line 99
    if (! ((int const   )_sch_istable[(int const   )*s & 255] & 4)) {
#line 100
      goto while_continue;
    }
#line 101
    res___0 = 0L;
    {
#line 102
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 104
      res___0 = (long )((int const   )*s - 48) + 10L * res___0;
#line 105
      s ++;
#line 102
      if (*s) {
#line 102
        if (! ((int const   )_sch_istable[(int const   )*s & 255] & 4)) {
#line 102
          goto while_break___2;
        }
      } else {
#line 102
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 108
    if (! *s) {
#line 109
      return (0L);
    }
    {
#line 110
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 110
      if (*s) {
#line 110
        if (! ((int const   )_sch_istable[(int const   )*s & 255] & 64)) {
#line 110
          goto while_break___3;
        }
      } else {
#line 110
        goto while_break___3;
      }
#line 111
      s ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 112
    if (! *s) {
#line 113
      return (0L);
    }
#line 114
    if ((int const   )_sch_tolower[(int const   )*s & 255] != 98) {
#line 115
      goto while_continue;
    }
    {
#line 116
    tmp = strncasecmp(s, "byte", (size_t )4);
    }
#line 116
    if (tmp) {
#line 117
      goto while_continue;
    } else {
#line 119
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 121
  return (res___0);
}
}
#line 127 "ftp.c"
static uerr_t getftp(struct url *u , long *len , long restval , ccon *con ) 
{ 
  int csock ;
  int dtsock ;
  int res___0 ;
  uerr_t err ;
  FILE *fp ;
  char *user ;
  char *passwd ;
  char *respline ;
  char *tms ;
  char *tmrate ;
  int cmd ;
  int pasv_mode_open ;
  long expected_bytes ;
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;
  char type_char ;
  struct address_list *al ;
  char *host ;
  char *tmp___6 ;
  int port ;
  int tmp___7 ;
  char *logname ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  void *tmp___10 ;
  int tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *path ;
  char *tmp___25 ;
  char *pathend ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *idir ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  char *target ;
  int idlen ;
  size_t tmp___35 ;
  char *ntarget ;
  char *p ;
  size_t tmp___36 ;
  void *tmp___37 ;
  char *tmp___38 ;
  char *tmpp ;
  char *ntarget___0 ;
  size_t tmp___39 ;
  void *tmp___40 ;
  long tmp___41 ;
  char *tmp___42 ;
  char *tmp___43 ;
  char *tmp___44 ;
  char *tmp___45 ;
  char *tmp___46 ;
  char *tmp___47 ;
  char *tmp___48 ;
  char *tmp___49 ;
  ip_address passive_addr ;
  unsigned short passive_port ;
  char *tmp___50 ;
  char *tmp___51 ;
  char *tmp___52 ;
  char *tmp___53 ;
  int save_errno ;
  int *tmp___54 ;
  char *tmp___55 ;
  char *tmp___56 ;
  char *tmp___57 ;
  int tmp___58 ;
  char *tmp___59 ;
  char *tmp___60 ;
  char *tmp___61 ;
  int *tmp___62 ;
  char *tmp___63 ;
  int *tmp___64 ;
  char *tmp___65 ;
  char *tmp___66 ;
  char *tmp___67 ;
  char *tmp___68 ;
  char *tmp___69 ;
  char *tmp___70 ;
  char *tmp___71 ;
  char *tmp___72 ;
  char *tmp___73 ;
  char *tmp___74 ;
  char *tmp___75 ;
  char *tmp___76 ;
  char *tmp___77 ;
  char *tmp___78 ;
  char *tmp___79 ;
  char *tmp___80 ;
  char *tmp___81 ;
  int *tmp___82 ;
  char *tmp___83 ;
  char const   *tmp___84 ;
  int *tmp___85 ;
  char *tmp___86 ;
  int tmp___87 ;
  char *tmp___88 ;
  char *tmp___89 ;
  char *tmp___90 ;
  char *tmp___91 ;
  char *tmp___92 ;
  char *tmp___93 ;
  char *tmp___94 ;
  char *tmp___95 ;
  char *tmp___96 ;
  int flush_res ;
  int *tmp___97 ;
  char *tmp___98 ;
  char *tmp___99 ;
  int *tmp___100 ;
  char *tmp___101 ;
  char *tmp___102 ;
  char *tmp___103 ;
  char *tmp___104 ;
  int *tmp___105 ;
  char *tmp___106 ;
  char *line ;

  {
  {
#line 135
  cmd = con->cmd;
#line 136
  pasv_mode_open = 0;
#line 137
  expected_bytes = 0L;
#line 139
  tmp = __builtin_expect((long )(! (! ((unsigned long )con != (unsigned long )((void *)0)))),
                         1L);
  }
#line 139
  if (! tmp) {
    {
#line 139
    __assert_fail("con != ((void *)0)", "ftp.c", 139U, "getftp");
    }
  }
  {
#line 140
  tmp___0 = __builtin_expect((long )(! (! ((unsigned long )con->target != (unsigned long )((void *)0)))),
                             1L);
  }
#line 140
  if (! tmp___0) {
    {
#line 140
    __assert_fail("con->target != ((void *)0)", "ftp.c", 140U, "getftp");
    }
  }
#line 145
  if (cmd & 8) {
#line 145
    if (cmd & 4) {
#line 145
      tmp___1 = 0;
    } else {
#line 145
      tmp___1 = 1;
    }
  } else {
#line 145
    tmp___1 = 1;
  }
  {
#line 145
  tmp___2 = __builtin_expect((long )tmp___1, 1L);
  }
#line 145
  if (! tmp___2) {
    {
#line 145
    __assert_fail("!((cmd & DO_LIST) && (cmd & DO_RETR))", "ftp.c", 145U, "getftp");
    }
  }
  {
#line 147
  tmp___3 = __builtin_expect((long )(! (! ((cmd & 15) != 0))), 1L);
  }
#line 147
  if (! tmp___3) {
    {
#line 147
    __assert_fail("(cmd & (DO_LIST | DO_CWD | DO_RETR | DO_LOGIN)) != 0", "ftp.c",
                  147U, "getftp");
    }
  }
  {
#line 149
  user = u->user;
#line 150
  passwd = u->passwd;
#line 151
  search_netrc((char const   *)u->host, (char const   **)(& user), (char const   **)(& passwd),
               1);
  }
#line 152
  if (user) {
#line 152
    user = user;
  } else {
#line 152
    user = opt.ftp_acc;
  }
#line 153
  if (passwd) {
#line 153
    passwd = passwd;
  } else {
#line 153
    passwd = opt.ftp_pass;
  }
#line 154
  if (user) {
#line 154
    if (passwd) {
#line 154
      tmp___4 = 1;
    } else {
#line 154
      tmp___4 = 0;
    }
  } else {
#line 154
    tmp___4 = 0;
  }
  {
#line 154
  tmp___5 = __builtin_expect((long )tmp___4, 1L);
  }
#line 154
  if (! tmp___5) {
    {
#line 154
    __assert_fail("user && passwd", "ftp.c", 154U, "getftp");
    }
  }
#line 156
  dtsock = -1;
#line 157
  con->dltime = (double )0;
#line 159
  if (! (cmd & 1)) {
#line 160
    csock = con->rbuf.fd;
  } else {
#line 166
    if (con->proxy) {
#line 166
      tmp___6 = (con->proxy)->host;
    } else {
#line 166
      tmp___6 = u->host;
    }
#line 166
    host = tmp___6;
#line 167
    if (con->proxy) {
#line 167
      tmp___7 = (con->proxy)->port;
    } else {
#line 167
      tmp___7 = u->port;
    }
#line 167
    port = tmp___7;
#line 168
    logname = user;
#line 170
    if (con->proxy) {
      {
#line 173
      tmp___8 = strlen((char const   *)user);
#line 173
      tmp___9 = strlen((char const   *)u->host);
#line 173
      tmp___10 = xmalloc_real(((tmp___8 + 1U) + tmp___9) + 1U);
#line 173
      logname = (char *)tmp___10;
#line 174
      sprintf((char */* __restrict  */)logname, (char const   */* __restrict  */)"%s@%s",
              user, u->host);
      }
    }
    {
#line 181
    al = lookup_host((char const   *)host, 0);
    }
#line 182
    if (! al) {
#line 183
      return ((uerr_t )1);
    }
    {
#line 184
    set_connection_host_name((char const   *)host);
#line 185
    csock = connect_to_many(al, (unsigned short )port, 0);
#line 186
    set_connection_host_name((char const   *)((void *)0));
#line 187
    address_list_release(al);
    }
#line 189
    if (csock < 0) {
      {
#line 190
      tmp___13 = __errno_location();
      }
#line 190
      if (*tmp___13 == 111) {
#line 190
        if (! opt.retry_connrefused) {
#line 190
          tmp___12 = 5;
        } else {
#line 190
          tmp___12 = 3;
        }
      } else {
#line 190
        tmp___12 = 3;
      }
#line 190
      return ((uerr_t )tmp___12);
    }
#line 192
    if (cmd & 16) {
      {
#line 193
      rbuf_initialize(& con->rbuf, csock);
      }
    } else {
      {
#line 195
      rbuf_uninitialize(& con->rbuf);
      }
    }
    {
#line 199
    rbuf_discard(& con->rbuf);
#line 202
    tmp___14 = gettext("Logging in as %s ... ");
#line 202
    logprintf((enum log_options )0, (char const   *)tmp___14, user);
    }
#line 203
    if (opt.server_response) {
      {
#line 204
      logputs((enum log_options )3, "\n");
      }
    }
    {
#line 205
    err = ftp_login(& con->rbuf, (char const   *)logname, (char const   *)passwd);
    }
#line 207
    if (con->proxy) {
      {
#line 208
      free((void *)logname);
      }
    }
    {
#line 213
    if ((unsigned int )err == 22U) {
#line 213
      goto case_22;
    }
#line 221
    if ((unsigned int )err == 24U) {
#line 221
      goto case_24;
    }
#line 228
    if ((unsigned int )err == 55U) {
#line 228
      goto case_55;
    }
#line 236
    if ((unsigned int )err == 17U) {
#line 236
      goto case_17;
    }
#line 243
    if ((unsigned int )err == 16U) {
#line 243
      goto case_16;
    }
#line 250
    if ((unsigned int )err == 15U) {
#line 250
      goto case_15;
    }
#line 254
    goto switch_default;
    case_22: /* CIL Label */ 
    {
#line 214
    logputs((enum log_options )0, "\n");
#line 215
    tmp___15 = gettext("Error in server response, closing control connection.\n");
#line 215
    logputs((enum log_options )1, (char const   *)tmp___15);
    }
    {
#line 217
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 217
      close(csock);
      }
      {
#line 217
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 217
        if (opt.debug) {
          {
#line 217
          debug_logprintf("Closing fd %d\n", csock);
          }
        }
#line 217
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 217
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 218
    rbuf_uninitialize(& con->rbuf);
    }
#line 219
    return (err);
#line 220
    goto switch_break;
    case_24: /* CIL Label */ 
    {
#line 222
    logputs((enum log_options )0, "\n");
#line 223
    tmp___16 = gettext("Error in server greeting.\n");
#line 223
    logputs((enum log_options )1, (char const   *)tmp___16);
    }
    {
#line 224
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 224
      close(csock);
      }
      {
#line 224
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 224
        if (opt.debug) {
          {
#line 224
          debug_logprintf("Closing fd %d\n", csock);
          }
        }
#line 224
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 224
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 225
    rbuf_uninitialize(& con->rbuf);
    }
#line 226
    return (err);
#line 227
    goto switch_break;
    case_55: /* CIL Label */ 
    {
#line 229
    logputs((enum log_options )0, "\n");
#line 230
    tmp___17 = gettext("Write failed, closing control connection.\n");
#line 230
    logputs((enum log_options )1, (char const   *)tmp___17);
    }
    {
#line 232
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 232
      close(csock);
      }
      {
#line 232
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 232
        if (opt.debug) {
          {
#line 232
          debug_logprintf("Closing fd %d\n", csock);
          }
        }
#line 232
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 232
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 233
    rbuf_uninitialize(& con->rbuf);
    }
#line 234
    return (err);
#line 235
    goto switch_break;
    case_17: /* CIL Label */ 
    {
#line 237
    logputs((enum log_options )0, "\n");
#line 238
    tmp___18 = gettext("The server refuses login.\n");
#line 238
    logputs((enum log_options )1, (char const   *)tmp___18);
    }
    {
#line 239
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 239
      close(csock);
      }
      {
#line 239
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 239
        if (opt.debug) {
          {
#line 239
          debug_logprintf("Closing fd %d\n", csock);
          }
        }
#line 239
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 239
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 240
    rbuf_uninitialize(& con->rbuf);
    }
#line 241
    return ((uerr_t )17);
#line 242
    goto switch_break;
    case_16: /* CIL Label */ 
    {
#line 244
    logputs((enum log_options )0, "\n");
#line 245
    tmp___19 = gettext("Login incorrect.\n");
#line 245
    logputs((enum log_options )1, (char const   *)tmp___19);
    }
    {
#line 246
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 246
      close(csock);
      }
      {
#line 246
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 246
        if (opt.debug) {
          {
#line 246
          debug_logprintf("Closing fd %d\n", csock);
          }
        }
#line 246
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 246
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 247
    rbuf_uninitialize(& con->rbuf);
    }
#line 248
    return ((uerr_t )16);
#line 249
    goto switch_break;
    case_15: /* CIL Label */ 
#line 251
    if (! opt.server_response) {
      {
#line 252
      tmp___20 = gettext("Logged in!\n");
#line 252
      logputs((enum log_options )0, (char const   *)tmp___20);
      }
    }
#line 253
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 255
    abort();
#line 256
    exit(1);
    }
#line 257
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 260
    if (! opt.server_response) {
      {
#line 261
      logprintf((enum log_options )0, "==> SYST ... ");
      }
    }
    {
#line 262
    err = ftp_syst(& con->rbuf, & con->rs);
    }
    {
#line 266
    if ((unsigned int )err == 22U) {
#line 266
      goto case_22___0;
    }
#line 274
    if ((unsigned int )err == 24U) {
#line 274
      goto case_24___0;
    }
#line 279
    if ((unsigned int )err == 15U) {
#line 279
      goto case_15___0;
    }
#line 282
    goto switch_default___0;
    case_22___0: /* CIL Label */ 
    {
#line 267
    logputs((enum log_options )0, "\n");
#line 268
    tmp___21 = gettext("Error in server response, closing control connection.\n");
#line 268
    logputs((enum log_options )1, (char const   *)tmp___21);
    }
    {
#line 270
    while (1) {
      while_continue___9: /* CIL Label */ ;
      {
#line 270
      close(csock);
      }
      {
#line 270
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 270
        if (opt.debug) {
          {
#line 270
          debug_logprintf("Closing fd %d\n", csock);
          }
        }
#line 270
        goto while_break___10;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 270
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
    {
#line 271
    rbuf_uninitialize(& con->rbuf);
    }
#line 272
    return (err);
#line 273
    goto switch_break___0;
    case_24___0: /* CIL Label */ 
    {
#line 275
    logputs((enum log_options )0, "\n");
#line 276
    tmp___22 = gettext("Server error, can\'t determine system type.\n");
#line 276
    logputs((enum log_options )1, (char const   *)tmp___22);
    }
#line 278
    goto switch_break___0;
    case_15___0: /* CIL Label */ 
#line 281
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 283
    abort();
    }
#line 284
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 286
    if (! opt.server_response) {
#line 286
      if ((unsigned int )err != 24U) {
        {
#line 287
        tmp___23 = gettext("done.    ");
#line 287
        logputs((enum log_options )0, (char const   *)tmp___23);
        }
      }
    }
#line 291
    if (! opt.server_response) {
      {
#line 292
      logprintf((enum log_options )0, "==> PWD ... ");
      }
    }
    {
#line 293
    err = ftp_pwd(& con->rbuf, & con->id);
    }
    {
#line 297
    if ((unsigned int )err == 22U) {
#line 297
      goto case_22___1;
    }
#line 305
    if ((unsigned int )err == 24U) {
#line 305
      goto case_24___1;
    }
#line 310
    if ((unsigned int )err == 15U) {
#line 310
      goto case_15___1;
    }
#line 313
    goto switch_default___1;
    case_22___1: /* CIL Label */ 
    {
#line 298
    logputs((enum log_options )0, "\n");
#line 299
    tmp___24 = gettext("Error in server response, closing control connection.\n");
#line 299
    logputs((enum log_options )1, (char const   *)tmp___24);
    }
    {
#line 301
    while (1) {
      while_continue___11: /* CIL Label */ ;
      {
#line 301
      close(csock);
      }
      {
#line 301
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 301
        if (opt.debug) {
          {
#line 301
          debug_logprintf("Closing fd %d\n", csock);
          }
        }
#line 301
        goto while_break___12;
      }
      while_break___12: /* CIL Label */ ;
      }
#line 301
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
    {
#line 302
    rbuf_uninitialize(& con->rbuf);
    }
#line 303
    return (err);
#line 304
    goto switch_break___1;
    case_24___1: /* CIL Label */ 
    {
#line 307
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 307
      if (con->id) {
        {
#line 307
        free((void *)con->id);
        }
      }
#line 307
      goto while_break___13;
    }
    while_break___13: /* CIL Label */ ;
    }
    {
#line 308
    con->id = xstrdup_real("/");
    }
#line 309
    goto switch_break___1;
    case_15___1: /* CIL Label */ 
#line 312
    goto switch_break___1;
    switch_default___1: /* CIL Label */ 
    {
#line 314
    abort();
    }
#line 315
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 319
    if ((unsigned int )con->rs == 1U) {
      {
#line 321
      tmp___25 = strchr((char const   *)con->id, '[');
#line 321
      path = tmp___25;
      }
#line 322
      if (path) {
        {
#line 322
        tmp___26 = strchr((char const   *)(path + 1), ']');
#line 322
        tmp___27 = tmp___26;
        }
      } else {
#line 322
        tmp___27 = (char *)((void *)0);
      }
#line 322
      pathend = tmp___27;
#line 323
      if (! path) {
#line 323
        goto _L;
      } else
#line 323
      if (! pathend) {
        _L: /* CIL Label */ 
        {
#line 324
        while (1) {
          while_continue___14: /* CIL Label */ ;
#line 324
          if (opt.debug) {
            {
#line 324
            debug_logprintf("Initial VMS directory not in the form [...]!\n");
            }
          }
#line 324
          goto while_break___14;
        }
        while_break___14: /* CIL Label */ ;
        }
      } else {
#line 327
        idir = con->id;
        {
#line 328
        while (1) {
          while_continue___15: /* CIL Label */ ;
#line 328
          if (opt.debug) {
            {
#line 328
            debug_logprintf("Preprocessing the initial VMS directory\n");
            }
          }
#line 328
          goto while_break___15;
        }
        while_break___15: /* CIL Label */ ;
        }
        {
#line 329
        while (1) {
          while_continue___16: /* CIL Label */ ;
#line 329
          if (opt.debug) {
            {
#line 329
            debug_logprintf("  old = \'%s\'\n", con->id);
            }
          }
#line 329
          goto while_break___16;
        }
        while_break___16: /* CIL Label */ ;
        }
#line 333
        tmp___28 = idir;
#line 333
        idir ++;
#line 333
        *tmp___28 = (char )'/';
#line 334
        path ++;
        {
#line 334
        while (1) {
          while_continue___17: /* CIL Label */ ;
#line 334
          if (! ((unsigned long )path < (unsigned long )pathend)) {
#line 334
            goto while_break___17;
          }
#line 335
          if ((int )*path == 46) {
#line 335
            *idir = (char )'/';
          } else {
#line 335
            *idir = *path;
          }
#line 334
          path ++;
#line 334
          idir ++;
        }
        while_break___17: /* CIL Label */ ;
        }
#line 336
        *idir = (char )'\000';
        {
#line 337
        while (1) {
          while_continue___18: /* CIL Label */ ;
#line 337
          if (opt.debug) {
            {
#line 337
            debug_logprintf("  new = \'%s\'\n\n", con->id);
            }
          }
#line 337
          goto while_break___18;
        }
        while_break___18: /* CIL Label */ ;
        }
      }
    }
#line 340
    if (! opt.server_response) {
      {
#line 341
      tmp___29 = gettext("done.\n");
#line 341
      logputs((enum log_options )0, (char const   *)tmp___29);
      }
    }
    {
#line 344
    type_char = ftp_process_type((char const   *)u->params);
    }
#line 345
    if (! opt.server_response) {
      {
#line 346
      logprintf((enum log_options )0, "==> TYPE %c ... ", (int )type_char);
      }
    }
    {
#line 347
    err = ftp_type(& con->rbuf, (int )type_char);
    }
    {
#line 351
    if ((unsigned int )err == 22U) {
#line 351
      goto case_22___2;
    }
#line 359
    if ((unsigned int )err == 55U) {
#line 359
      goto case_55___0;
    }
#line 367
    if ((unsigned int )err == 21U) {
#line 367
      goto case_21;
    }
#line 375
    if ((unsigned int )err == 15U) {
#line 375
      goto case_15___2;
    }
#line 378
    goto switch_default___2;
    case_22___2: /* CIL Label */ 
    {
#line 352
    logputs((enum log_options )0, "\n");
#line 353
    tmp___30 = gettext("Error in server response, closing control connection.\n");
#line 353
    logputs((enum log_options )1, (char const   *)tmp___30);
    }
    {
#line 355
    while (1) {
      while_continue___19: /* CIL Label */ ;
      {
#line 355
      close(csock);
      }
      {
#line 355
      while (1) {
        while_continue___20: /* CIL Label */ ;
#line 355
        if (opt.debug) {
          {
#line 355
          debug_logprintf("Closing fd %d\n", csock);
          }
        }
#line 355
        goto while_break___20;
      }
      while_break___20: /* CIL Label */ ;
      }
#line 355
      goto while_break___19;
    }
    while_break___19: /* CIL Label */ ;
    }
    {
#line 356
    rbuf_uninitialize(& con->rbuf);
    }
#line 357
    return (err);
#line 358
    goto switch_break___2;
    case_55___0: /* CIL Label */ 
    {
#line 360
    logputs((enum log_options )0, "\n");
#line 361
    tmp___31 = gettext("Write failed, closing control connection.\n");
#line 361
    logputs((enum log_options )1, (char const   *)tmp___31);
    }
    {
#line 363
    while (1) {
      while_continue___21: /* CIL Label */ ;
      {
#line 363
      close(csock);
      }
      {
#line 363
      while (1) {
        while_continue___22: /* CIL Label */ ;
#line 363
        if (opt.debug) {
          {
#line 363
          debug_logprintf("Closing fd %d\n", csock);
          }
        }
#line 363
        goto while_break___22;
      }
      while_break___22: /* CIL Label */ ;
      }
#line 363
      goto while_break___21;
    }
    while_break___21: /* CIL Label */ ;
    }
    {
#line 364
    rbuf_uninitialize(& con->rbuf);
    }
#line 365
    return (err);
#line 366
    goto switch_break___2;
    case_21: /* CIL Label */ 
    {
#line 368
    logputs((enum log_options )0, "\n");
#line 369
    tmp___32 = gettext("Unknown type `%c\', closing control connection.\n");
#line 369
    logprintf((enum log_options )1, (char const   *)tmp___32, (int )type_char);
    }
    {
#line 372
    while (1) {
      while_continue___23: /* CIL Label */ ;
      {
#line 372
      close(csock);
      }
      {
#line 372
      while (1) {
        while_continue___24: /* CIL Label */ ;
#line 372
        if (opt.debug) {
          {
#line 372
          debug_logprintf("Closing fd %d\n", csock);
          }
        }
#line 372
        goto while_break___24;
      }
      while_break___24: /* CIL Label */ ;
      }
#line 372
      goto while_break___23;
    }
    while_break___23: /* CIL Label */ ;
    }
    {
#line 373
    rbuf_uninitialize(& con->rbuf);
    }
#line 374
    return (err);
    case_15___2: /* CIL Label */ 
#line 377
    goto switch_break___2;
    switch_default___2: /* CIL Label */ 
    {
#line 379
    abort();
    }
#line 380
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
#line 382
    if (! opt.server_response) {
      {
#line 383
      tmp___33 = gettext("done.  ");
#line 383
      logputs((enum log_options )0, (char const   *)tmp___33);
      }
    }
  }
#line 386
  if (cmd & 2) {
#line 388
    if (! *(u->dir)) {
      {
#line 389
      tmp___34 = gettext("==> CWD not needed.\n");
#line 389
      logputs((enum log_options )0, (char const   *)tmp___34);
      }
    } else {
#line 392
      target = u->dir;
      {
#line 394
      while (1) {
        while_continue___25: /* CIL Label */ ;
#line 394
        if (opt.debug) {
          {
#line 394
          debug_logprintf("changing working directory\n");
          }
        }
#line 394
        goto while_break___25;
      }
      while_break___25: /* CIL Label */ ;
      }
#line 410
      if ((int )*(target + 0) != 47) {
#line 410
        if ((unsigned int )con->rs != 0U) {
#line 410
          if ((int const   )_sch_istable[(int )*(target + 0) & 255] & 136) {
#line 410
            if (! ((int )*(target + 1) == 58)) {
#line 410
              goto _L___1;
            }
          } else {
#line 410
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 410
        if ((unsigned int )con->rs != 4U) {
          {
#line 416
          tmp___35 = strlen((char const   *)con->id);
#line 416
          idlen = (int )tmp___35;
          }
          {
#line 420
          while (1) {
            while_continue___26: /* CIL Label */ ;
#line 420
            if (idlen > 0) {
#line 420
              if (! ((int )*(con->id + (idlen - 1)) == 47)) {
#line 420
                goto while_break___26;
              }
            } else {
#line 420
              goto while_break___26;
            }
#line 421
            idlen --;
          }
          while_break___26: /* CIL Label */ ;
          }
          {
#line 422
          tmp___36 = strlen((char const   *)u->dir);
#line 422
          tmp___37 = __builtin_alloca((unsigned long )(((size_t )(idlen + 1) + tmp___36) + 1U));
#line 422
          ntarget = (char *)tmp___37;
#line 422
          p = ntarget;
#line 423
          memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)con->id,
                 (size_t )idlen);
#line 424
          p += idlen;
#line 425
          tmp___38 = p;
#line 425
          p ++;
#line 425
          *tmp___38 = (char )'/';
#line 426
          strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)target);
          }
          {
#line 428
          while (1) {
            while_continue___27: /* CIL Label */ ;
#line 428
            if (opt.debug) {
              {
#line 428
              debug_logprintf("Prepended initial PWD to relative path:\n");
              }
            }
#line 428
            goto while_break___27;
          }
          while_break___27: /* CIL Label */ ;
          }
          {
#line 429
          while (1) {
            while_continue___28: /* CIL Label */ ;
#line 429
            if (opt.debug) {
              {
#line 429
              debug_logprintf("   pwd: \'%s\'\n   old: \'%s\'\n  new: \'%s\'\n", con->id,
                              target, ntarget);
              }
            }
#line 429
            goto while_break___28;
          }
          while_break___28: /* CIL Label */ ;
          }
#line 431
          target = ntarget;
        }
      }
#line 439
      if ((unsigned int )con->rs == 1U) {
        {
#line 442
        tmp___39 = strlen((char const   *)target);
#line 442
        tmp___40 = __builtin_alloca((unsigned long )(tmp___39 + 2U));
#line 442
        ntarget___0 = (char *)tmp___40;
#line 447
        strcpy((char */* __restrict  */)ntarget___0, (char const   */* __restrict  */)target);
#line 448
        tmp___41 = __builtin_expect((long )(! (! ((int )*ntarget___0 == 47))), 1L);
        }
#line 448
        if (! tmp___41) {
          {
#line 448
          __assert_fail("*ntarget == \'/\'", "ftp.c", 448U, "getftp");
          }
        }
#line 449
        *ntarget___0 = (char )'[';
#line 450
        tmpp = ntarget___0 + 1;
        {
#line 450
        while (1) {
          while_continue___29: /* CIL Label */ ;
#line 450
          if (! *tmpp) {
#line 450
            goto while_break___29;
          }
#line 451
          if ((int )*tmpp == 47) {
#line 452
            *tmpp = (char )'.';
          }
#line 450
          tmpp ++;
        }
        while_break___29: /* CIL Label */ ;
        }
#line 453
        tmp___42 = tmpp;
#line 453
        tmpp ++;
#line 453
        *tmp___42 = (char )']';
#line 454
        *tmpp = (char )'\000';
        {
#line 455
        while (1) {
          while_continue___30: /* CIL Label */ ;
#line 455
          if (opt.debug) {
            {
#line 455
            debug_logprintf("Changed file name to VMS syntax:\n");
            }
          }
#line 455
          goto while_break___30;
        }
        while_break___30: /* CIL Label */ ;
        }
        {
#line 456
        while (1) {
          while_continue___31: /* CIL Label */ ;
#line 456
          if (opt.debug) {
            {
#line 456
            debug_logprintf("  Unix: \'%s\'\n  VMS: \'%s\'\n", target, ntarget___0);
            }
          }
#line 456
          goto while_break___31;
        }
        while_break___31: /* CIL Label */ ;
        }
#line 457
        target = ntarget___0;
      }
#line 460
      if (! opt.server_response) {
        {
#line 461
        logprintf((enum log_options )0, "==> CWD %s ... ", target);
        }
      }
      {
#line 462
      err = ftp_cwd(& con->rbuf, (char const   *)target);
      }
      {
#line 466
      if ((unsigned int )err == 22U) {
#line 466
        goto case_22___3;
      }
#line 474
      if ((unsigned int )err == 55U) {
#line 474
        goto case_55___1;
      }
#line 482
      if ((unsigned int )err == 19U) {
#line 482
        goto case_19;
      }
#line 490
      if ((unsigned int )err == 15U) {
#line 490
        goto case_15___3;
      }
#line 493
      goto switch_default___3;
      case_22___3: /* CIL Label */ 
      {
#line 467
      logputs((enum log_options )0, "\n");
#line 468
      tmp___43 = gettext("Error in server response, closing control connection.\n");
#line 468
      logputs((enum log_options )1, (char const   *)tmp___43);
      }
      {
#line 470
      while (1) {
        while_continue___32: /* CIL Label */ ;
        {
#line 470
        close(csock);
        }
        {
#line 470
        while (1) {
          while_continue___33: /* CIL Label */ ;
#line 470
          if (opt.debug) {
            {
#line 470
            debug_logprintf("Closing fd %d\n", csock);
            }
          }
#line 470
          goto while_break___33;
        }
        while_break___33: /* CIL Label */ ;
        }
#line 470
        goto while_break___32;
      }
      while_break___32: /* CIL Label */ ;
      }
      {
#line 471
      rbuf_uninitialize(& con->rbuf);
      }
#line 472
      return (err);
#line 473
      goto switch_break___3;
      case_55___1: /* CIL Label */ 
      {
#line 475
      logputs((enum log_options )0, "\n");
#line 476
      tmp___44 = gettext("Write failed, closing control connection.\n");
#line 476
      logputs((enum log_options )1, (char const   *)tmp___44);
      }
      {
#line 478
      while (1) {
        while_continue___34: /* CIL Label */ ;
        {
#line 478
        close(csock);
        }
        {
#line 478
        while (1) {
          while_continue___35: /* CIL Label */ ;
#line 478
          if (opt.debug) {
            {
#line 478
            debug_logprintf("Closing fd %d\n", csock);
            }
          }
#line 478
          goto while_break___35;
        }
        while_break___35: /* CIL Label */ ;
        }
#line 478
        goto while_break___34;
      }
      while_break___34: /* CIL Label */ ;
      }
      {
#line 479
      rbuf_uninitialize(& con->rbuf);
      }
#line 480
      return (err);
#line 481
      goto switch_break___3;
      case_19: /* CIL Label */ 
      {
#line 483
      logputs((enum log_options )0, "\n");
#line 484
      tmp___45 = gettext("No such directory `%s\'.\n\n");
#line 484
      logprintf((enum log_options )1, (char const   *)tmp___45, u->dir);
      }
      {
#line 486
      while (1) {
        while_continue___36: /* CIL Label */ ;
        {
#line 486
        close(csock);
        }
        {
#line 486
        while (1) {
          while_continue___37: /* CIL Label */ ;
#line 486
          if (opt.debug) {
            {
#line 486
            debug_logprintf("Closing fd %d\n", csock);
            }
          }
#line 486
          goto while_break___37;
        }
        while_break___37: /* CIL Label */ ;
        }
#line 486
        goto while_break___36;
      }
      while_break___36: /* CIL Label */ ;
      }
      {
#line 487
      rbuf_uninitialize(& con->rbuf);
      }
#line 488
      return (err);
#line 489
      goto switch_break___3;
      case_15___3: /* CIL Label */ 
#line 492
      goto switch_break___3;
      switch_default___3: /* CIL Label */ 
      {
#line 494
      abort();
      }
#line 495
      goto switch_break___3;
      switch_break___3: /* CIL Label */ ;
      }
#line 497
      if (! opt.server_response) {
        {
#line 498
        tmp___46 = gettext("done.\n");
#line 498
        logputs((enum log_options )0, (char const   *)tmp___46);
        }
      }
    }
  } else {
    {
#line 502
    tmp___47 = gettext("==> CWD not required.\n");
#line 502
    logputs((enum log_options )0, (char const   *)tmp___47);
    }
  }
#line 504
  if (cmd & 4) {
#line 504
    if (restval) {
#line 504
      if (*len == 0L) {
#line 506
        if (opt.verbose) {
#line 508
          if (! opt.server_response) {
            {
#line 509
            logprintf((enum log_options )0, "==> SIZE %s ... ", u->file);
            }
          }
        }
        {
#line 512
        err = ftp_size(& con->rbuf, (char const   *)u->file, len);
        }
        {
#line 517
        if ((unsigned int )err == 24U) {
#line 517
          goto case_24___2;
        }
#line 517
        if ((unsigned int )err == 22U) {
#line 517
          goto case_24___2;
        }
#line 525
        if ((unsigned int )err == 15U) {
#line 525
          goto case_15___4;
        }
#line 528
        goto switch_default___4;
        case_24___2: /* CIL Label */ 
        case_22___4: /* CIL Label */ 
        {
#line 518
        logputs((enum log_options )0, "\n");
#line 519
        tmp___48 = gettext("Error in server response, closing control connection.\n");
#line 519
        logputs((enum log_options )1, (char const   *)tmp___48);
        }
        {
#line 521
        while (1) {
          while_continue___38: /* CIL Label */ ;
          {
#line 521
          close(csock);
          }
          {
#line 521
          while (1) {
            while_continue___39: /* CIL Label */ ;
#line 521
            if (opt.debug) {
              {
#line 521
              debug_logprintf("Closing fd %d\n", csock);
              }
            }
#line 521
            goto while_break___39;
          }
          while_break___39: /* CIL Label */ ;
          }
#line 521
          goto while_break___38;
        }
        while_break___38: /* CIL Label */ ;
        }
        {
#line 522
        rbuf_uninitialize(& con->rbuf);
        }
#line 523
        return (err);
#line 524
        goto switch_break___4;
        case_15___4: /* CIL Label */ 
#line 527
        goto switch_break___4;
        switch_default___4: /* CIL Label */ 
        {
#line 529
        abort();
        }
#line 530
        goto switch_break___4;
        switch_break___4: /* CIL Label */ ;
        }
#line 532
        if (! opt.server_response) {
          {
#line 533
          tmp___49 = gettext("done.\n");
#line 533
          logputs((enum log_options )0, (char const   *)tmp___49);
          }
        }
      }
    }
  }
#line 537
  if (cmd & 12) {
#line 539
    if (opt.ftp_pasv > 0) {
#line 543
      if (! opt.server_response) {
        {
#line 544
        logputs((enum log_options )0, "==> PASV ... ");
        }
      }
      {
#line 545
      err = ftp_pasv(& con->rbuf, & passive_addr, & passive_port);
      }
      {
#line 549
      if ((unsigned int )err == 22U) {
#line 549
        goto case_22___5;
      }
#line 557
      if ((unsigned int )err == 55U) {
#line 557
        goto case_55___2;
      }
#line 565
      if ((unsigned int )err == 39U) {
#line 565
        goto case_39;
      }
#line 569
      if ((unsigned int )err == 38U) {
#line 569
        goto case_38;
      }
#line 573
      if ((unsigned int )err == 15U) {
#line 573
        goto case_15___5;
      }
#line 576
      goto switch_default___5;
      case_22___5: /* CIL Label */ 
      {
#line 550
      logputs((enum log_options )0, "\n");
#line 551
      tmp___50 = gettext("Error in server response, closing control connection.\n");
#line 551
      logputs((enum log_options )1, (char const   *)tmp___50);
      }
      {
#line 553
      while (1) {
        while_continue___40: /* CIL Label */ ;
        {
#line 553
        close(csock);
        }
        {
#line 553
        while (1) {
          while_continue___41: /* CIL Label */ ;
#line 553
          if (opt.debug) {
            {
#line 553
            debug_logprintf("Closing fd %d\n", csock);
            }
          }
#line 553
          goto while_break___41;
        }
        while_break___41: /* CIL Label */ ;
        }
#line 553
        goto while_break___40;
      }
      while_break___40: /* CIL Label */ ;
      }
      {
#line 554
      rbuf_uninitialize(& con->rbuf);
      }
#line 555
      return (err);
#line 556
      goto switch_break___5;
      case_55___2: /* CIL Label */ 
      {
#line 558
      logputs((enum log_options )0, "\n");
#line 559
      tmp___51 = gettext("Write failed, closing control connection.\n");
#line 559
      logputs((enum log_options )1, (char const   *)tmp___51);
      }
      {
#line 561
      while (1) {
        while_continue___42: /* CIL Label */ ;
        {
#line 561
        close(csock);
        }
        {
#line 561
        while (1) {
          while_continue___43: /* CIL Label */ ;
#line 561
          if (opt.debug) {
            {
#line 561
            debug_logprintf("Closing fd %d\n", csock);
            }
          }
#line 561
          goto while_break___43;
        }
        while_break___43: /* CIL Label */ ;
        }
#line 561
        goto while_break___42;
      }
      while_break___42: /* CIL Label */ ;
      }
      {
#line 562
      rbuf_uninitialize(& con->rbuf);
      }
#line 563
      return (err);
#line 564
      goto switch_break___5;
      case_39: /* CIL Label */ 
      {
#line 566
      logputs((enum log_options )0, "\n");
#line 567
      tmp___52 = gettext("Cannot initiate PASV transfer.\n");
#line 567
      logputs((enum log_options )1, (char const   *)tmp___52);
      }
#line 568
      goto switch_break___5;
      case_38: /* CIL Label */ 
      {
#line 570
      logputs((enum log_options )0, "\n");
#line 571
      tmp___53 = gettext("Cannot parse PASV response.\n");
#line 571
      logputs((enum log_options )1, (char const   *)tmp___53);
      }
#line 572
      goto switch_break___5;
      case_15___5: /* CIL Label */ 
#line 575
      goto switch_break___5;
      switch_default___5: /* CIL Label */ 
      {
#line 577
      abort();
      }
#line 578
      goto switch_break___5;
      switch_break___5: /* CIL Label */ ;
      }
#line 580
      if ((unsigned int )err == 15U) {
        {
#line 582
        dtsock = connect_to_one(& passive_addr, passive_port, 1);
        }
#line 583
        if (dtsock < 0) {
          {
#line 585
          tmp___54 = __errno_location();
#line 585
          save_errno = *tmp___54;
          }
          {
#line 586
          while (1) {
            while_continue___44: /* CIL Label */ ;
            {
#line 586
            close(csock);
            }
            {
#line 586
            while (1) {
              while_continue___45: /* CIL Label */ ;
#line 586
              if (opt.debug) {
                {
#line 586
                debug_logprintf("Closing fd %d\n", csock);
                }
              }
#line 586
              goto while_break___45;
            }
            while_break___45: /* CIL Label */ ;
            }
#line 586
            goto while_break___44;
          }
          while_break___44: /* CIL Label */ ;
          }
          {
#line 587
          rbuf_uninitialize(& con->rbuf);
#line 588
          tmp___55 = strerror(save_errno);
#line 588
          tmp___56 = pretty_print_address(& passive_addr);
#line 588
          tmp___57 = gettext("couldn\'t connect to %s:%hu: %s\n");
#line 588
          logprintf((enum log_options )0, (char const   *)tmp___57, tmp___56, (int )passive_port,
                    tmp___55);
          }
#line 591
          if (save_errno == 111) {
#line 591
            if (! opt.retry_connrefused) {
#line 591
              tmp___58 = 5;
            } else {
#line 591
              tmp___58 = 3;
            }
          } else {
#line 591
            tmp___58 = 3;
          }
#line 591
          return ((uerr_t )tmp___58);
        }
#line 594
        pasv_mode_open = 1;
#line 595
        if (! opt.server_response) {
          {
#line 596
          tmp___59 = gettext("done.    ");
#line 596
          logputs((enum log_options )0, (char const   *)tmp___59);
          }
        }
      }
    }
#line 600
    if (! pasv_mode_open) {
#line 602
      if (! opt.server_response) {
        {
#line 603
        logputs((enum log_options )0, "==> PORT ... ");
        }
      }
      {
#line 604
      err = ftp_port(& con->rbuf);
      }
      {
#line 609
      if ((unsigned int )err == 22U) {
#line 609
        goto case_22___6;
      }
#line 618
      if ((unsigned int )err == 55U) {
#line 618
        goto case_55___3;
      }
#line 627
      if ((unsigned int )err == 2U) {
#line 627
        goto case_2;
      }
#line 635
      if ((unsigned int )err == 11U) {
#line 635
        goto case_11;
      }
#line 635
      if ((unsigned int )err == 9U) {
#line 635
        goto case_11;
      }
#line 635
      if ((unsigned int )err == 8U) {
#line 635
        goto case_11;
      }
#line 643
      if ((unsigned int )err == 18U) {
#line 643
        goto case_18;
      }
#line 651
      if ((unsigned int )err == 15U) {
#line 651
        goto case_15___6;
      }
#line 654
      goto switch_default___6;
      case_22___6: /* CIL Label */ 
      {
#line 610
      logputs((enum log_options )0, "\n");
#line 611
      tmp___60 = gettext("Error in server response, closing control connection.\n");
#line 611
      logputs((enum log_options )1, (char const   *)tmp___60);
      }
      {
#line 613
      while (1) {
        while_continue___46: /* CIL Label */ ;
        {
#line 613
        close(csock);
        }
        {
#line 613
        while (1) {
          while_continue___47: /* CIL Label */ ;
#line 613
          if (opt.debug) {
            {
#line 613
            debug_logprintf("Closing fd %d\n", csock);
            }
          }
#line 613
          goto while_break___47;
        }
        while_break___47: /* CIL Label */ ;
        }
#line 613
        goto while_break___46;
      }
      while_break___46: /* CIL Label */ ;
      }
      {
#line 614
      closeport(dtsock);
#line 615
      rbuf_uninitialize(& con->rbuf);
      }
#line 616
      return (err);
#line 617
      goto switch_break___6;
      case_55___3: /* CIL Label */ 
      {
#line 619
      logputs((enum log_options )0, "\n");
#line 620
      tmp___61 = gettext("Write failed, closing control connection.\n");
#line 620
      logputs((enum log_options )1, (char const   *)tmp___61);
      }
      {
#line 622
      while (1) {
        while_continue___48: /* CIL Label */ ;
        {
#line 622
        close(csock);
        }
        {
#line 622
        while (1) {
          while_continue___49: /* CIL Label */ ;
#line 622
          if (opt.debug) {
            {
#line 622
            debug_logprintf("Closing fd %d\n", csock);
            }
          }
#line 622
          goto while_break___49;
        }
        while_break___49: /* CIL Label */ ;
        }
#line 622
        goto while_break___48;
      }
      while_break___48: /* CIL Label */ ;
      }
      {
#line 623
      closeport(dtsock);
#line 624
      rbuf_uninitialize(& con->rbuf);
      }
#line 625
      return (err);
#line 626
      goto switch_break___6;
      case_2: /* CIL Label */ 
      {
#line 628
      logputs((enum log_options )0, "\n");
#line 629
      tmp___62 = __errno_location();
#line 629
      tmp___63 = strerror(*tmp___62);
#line 629
      logprintf((enum log_options )1, "socket: %s\n", tmp___63);
      }
      {
#line 630
      while (1) {
        while_continue___50: /* CIL Label */ ;
        {
#line 630
        close(csock);
        }
        {
#line 630
        while (1) {
          while_continue___51: /* CIL Label */ ;
#line 630
          if (opt.debug) {
            {
#line 630
            debug_logprintf("Closing fd %d\n", csock);
            }
          }
#line 630
          goto while_break___51;
        }
        while_break___51: /* CIL Label */ ;
        }
#line 630
        goto while_break___50;
      }
      while_break___50: /* CIL Label */ ;
      }
      {
#line 631
      closeport(dtsock);
#line 632
      rbuf_uninitialize(& con->rbuf);
      }
#line 633
      return (err);
#line 634
      goto switch_break___6;
      case_11: /* CIL Label */ 
      case_9: /* CIL Label */ 
      case_8: /* CIL Label */ 
      {
#line 637
      logputs((enum log_options )0, "\n");
#line 638
      tmp___64 = __errno_location();
#line 638
      tmp___65 = strerror(*tmp___64);
#line 638
      tmp___66 = gettext("Bind error (%s).\n");
#line 638
      logprintf((enum log_options )1, (char const   *)tmp___66, tmp___65);
#line 640
      closeport(dtsock);
      }
#line 641
      return (err);
#line 642
      goto switch_break___6;
      case_18: /* CIL Label */ 
      {
#line 644
      logputs((enum log_options )0, "\n");
#line 645
      tmp___67 = gettext("Invalid PORT.\n");
#line 645
      logputs((enum log_options )1, (char const   *)tmp___67);
      }
      {
#line 646
      while (1) {
        while_continue___52: /* CIL Label */ ;
        {
#line 646
        close(csock);
        }
        {
#line 646
        while (1) {
          while_continue___53: /* CIL Label */ ;
#line 646
          if (opt.debug) {
            {
#line 646
            debug_logprintf("Closing fd %d\n", csock);
            }
          }
#line 646
          goto while_break___53;
        }
        while_break___53: /* CIL Label */ ;
        }
#line 646
        goto while_break___52;
      }
      while_break___52: /* CIL Label */ ;
      }
      {
#line 647
      closeport(dtsock);
#line 648
      rbuf_uninitialize(& con->rbuf);
      }
#line 649
      return (err);
#line 650
      goto switch_break___6;
      case_15___6: /* CIL Label */ 
#line 653
      goto switch_break___6;
      switch_default___6: /* CIL Label */ 
      {
#line 655
      abort();
      }
#line 656
      goto switch_break___6;
      switch_break___6: /* CIL Label */ ;
      }
#line 658
      if (! opt.server_response) {
        {
#line 659
        tmp___68 = gettext("done.    ");
#line 659
        logputs((enum log_options )0, (char const   *)tmp___68);
        }
      }
    }
  }
#line 664
  if (restval) {
#line 664
    if (cmd & 4) {
#line 666
      if (! opt.server_response) {
        {
#line 667
        logprintf((enum log_options )0, "==> REST %ld ... ", restval);
        }
      }
      {
#line 668
      err = ftp_rest(& con->rbuf, restval);
      }
      {
#line 673
      if ((unsigned int )err == 22U) {
#line 673
        goto case_22___7;
      }
#line 682
      if ((unsigned int )err == 55U) {
#line 682
        goto case_55___4;
      }
#line 691
      if ((unsigned int )err == 26U) {
#line 691
        goto case_26;
      }
#line 708
      if ((unsigned int )err == 15U) {
#line 708
        goto case_15___7;
      }
#line 711
      goto switch_default___7;
      case_22___7: /* CIL Label */ 
      {
#line 674
      logputs((enum log_options )0, "\n");
#line 675
      tmp___69 = gettext("Error in server response, closing control connection.\n");
#line 675
      logputs((enum log_options )1, (char const   *)tmp___69);
      }
      {
#line 677
      while (1) {
        while_continue___54: /* CIL Label */ ;
        {
#line 677
        close(csock);
        }
        {
#line 677
        while (1) {
          while_continue___55: /* CIL Label */ ;
#line 677
          if (opt.debug) {
            {
#line 677
            debug_logprintf("Closing fd %d\n", csock);
            }
          }
#line 677
          goto while_break___55;
        }
        while_break___55: /* CIL Label */ ;
        }
#line 677
        goto while_break___54;
      }
      while_break___54: /* CIL Label */ ;
      }
      {
#line 678
      closeport(dtsock);
#line 679
      rbuf_uninitialize(& con->rbuf);
      }
#line 680
      return (err);
#line 681
      goto switch_break___7;
      case_55___4: /* CIL Label */ 
      {
#line 683
      logputs((enum log_options )0, "\n");
#line 684
      tmp___70 = gettext("Write failed, closing control connection.\n");
#line 684
      logputs((enum log_options )1, (char const   *)tmp___70);
      }
      {
#line 686
      while (1) {
        while_continue___56: /* CIL Label */ ;
        {
#line 686
        close(csock);
        }
        {
#line 686
        while (1) {
          while_continue___57: /* CIL Label */ ;
#line 686
          if (opt.debug) {
            {
#line 686
            debug_logprintf("Closing fd %d\n", csock);
            }
          }
#line 686
          goto while_break___57;
        }
        while_break___57: /* CIL Label */ ;
        }
#line 686
        goto while_break___56;
      }
      while_break___56: /* CIL Label */ ;
      }
      {
#line 687
      closeport(dtsock);
#line 688
      rbuf_uninitialize(& con->rbuf);
      }
#line 689
      return (err);
#line 690
      goto switch_break___7;
      case_26: /* CIL Label */ 
#line 695
      if (opt.always_rest) {
#line 695
        if (cmd & 32) {
          {
#line 697
          tmp___71 = gettext("\nREST failed; will not truncate `%s\'.\n");
#line 697
          logprintf((enum log_options )1, (char const   *)tmp___71, con->target);
          }
          {
#line 700
          while (1) {
            while_continue___58: /* CIL Label */ ;
            {
#line 700
            close(csock);
            }
            {
#line 700
            while (1) {
              while_continue___59: /* CIL Label */ ;
#line 700
              if (opt.debug) {
                {
#line 700
                debug_logprintf("Closing fd %d\n", csock);
                }
              }
#line 700
              goto while_break___59;
            }
            while_break___59: /* CIL Label */ ;
            }
#line 700
            goto while_break___58;
          }
          while_break___58: /* CIL Label */ ;
          }
          {
#line 701
          closeport(dtsock);
#line 702
          rbuf_uninitialize(& con->rbuf);
          }
#line 703
          return ((uerr_t )40);
        }
      }
      {
#line 705
      tmp___72 = gettext("\nREST failed, starting from scratch.\n");
#line 705
      logputs((enum log_options )0, (char const   *)tmp___72);
#line 706
      restval = 0L;
      }
#line 707
      goto switch_break___7;
      case_15___7: /* CIL Label */ 
#line 710
      goto switch_break___7;
      switch_default___7: /* CIL Label */ 
      {
#line 712
      abort();
      }
#line 713
      goto switch_break___7;
      switch_break___7: /* CIL Label */ ;
      }
#line 715
      if ((unsigned int )err != 26U) {
#line 715
        if (! opt.server_response) {
          {
#line 716
          tmp___73 = gettext("done.    ");
#line 716
          logputs((enum log_options )0, (char const   *)tmp___73);
          }
        }
      }
    }
  }
#line 719
  if (cmd & 4) {
#line 725
    if (opt.spider) {
      {
#line 727
      while (1) {
        while_continue___60: /* CIL Label */ ;
        {
#line 727
        close(csock);
        }
        {
#line 727
        while (1) {
          while_continue___61: /* CIL Label */ ;
#line 727
          if (opt.debug) {
            {
#line 727
            debug_logprintf("Closing fd %d\n", csock);
            }
          }
#line 727
          goto while_break___61;
        }
        while_break___61: /* CIL Label */ ;
        }
#line 727
        goto while_break___60;
      }
      while_break___60: /* CIL Label */ ;
      }
      {
#line 728
      closeport(dtsock);
#line 729
      rbuf_uninitialize(& con->rbuf);
      }
#line 730
      return ((uerr_t )42);
    }
#line 733
    if (opt.verbose) {
#line 735
      if (! opt.server_response) {
#line 737
        if (restval) {
          {
#line 738
          logputs((enum log_options )0, "\n");
          }
        }
        {
#line 739
        logprintf((enum log_options )0, "==> RETR %s ... ", u->file);
        }
      }
    }
    {
#line 742
    err = ftp_retr(& con->rbuf, (char const   *)u->file);
    }
    {
#line 746
    if ((unsigned int )err == 22U) {
#line 746
      goto case_22___8;
    }
#line 755
    if ((unsigned int )err == 55U) {
#line 755
      goto case_55___5;
    }
#line 764
    if ((unsigned int )err == 19U) {
#line 764
      goto case_19___0;
    }
#line 770
    if ((unsigned int )err == 15U) {
#line 770
      goto case_15___8;
    }
#line 773
    goto switch_default___8;
    case_22___8: /* CIL Label */ 
    {
#line 747
    logputs((enum log_options )0, "\n");
#line 748
    tmp___74 = gettext("Error in server response, closing control connection.\n");
#line 748
    logputs((enum log_options )1, (char const   *)tmp___74);
    }
    {
#line 750
    while (1) {
      while_continue___62: /* CIL Label */ ;
      {
#line 750
      close(csock);
      }
      {
#line 750
      while (1) {
        while_continue___63: /* CIL Label */ ;
#line 750
        if (opt.debug) {
          {
#line 750
          debug_logprintf("Closing fd %d\n", csock);
          }
        }
#line 750
        goto while_break___63;
      }
      while_break___63: /* CIL Label */ ;
      }
#line 750
      goto while_break___62;
    }
    while_break___62: /* CIL Label */ ;
    }
    {
#line 751
    closeport(dtsock);
#line 752
    rbuf_uninitialize(& con->rbuf);
    }
#line 753
    return (err);
#line 754
    goto switch_break___8;
    case_55___5: /* CIL Label */ 
    {
#line 756
    logputs((enum log_options )0, "\n");
#line 757
    tmp___75 = gettext("Write failed, closing control connection.\n");
#line 757
    logputs((enum log_options )1, (char const   *)tmp___75);
    }
    {
#line 759
    while (1) {
      while_continue___64: /* CIL Label */ ;
      {
#line 759
      close(csock);
      }
      {
#line 759
      while (1) {
        while_continue___65: /* CIL Label */ ;
#line 759
        if (opt.debug) {
          {
#line 759
          debug_logprintf("Closing fd %d\n", csock);
          }
        }
#line 759
        goto while_break___65;
      }
      while_break___65: /* CIL Label */ ;
      }
#line 759
      goto while_break___64;
    }
    while_break___64: /* CIL Label */ ;
    }
    {
#line 760
    closeport(dtsock);
#line 761
    rbuf_uninitialize(& con->rbuf);
    }
#line 762
    return (err);
#line 763
    goto switch_break___8;
    case_19___0: /* CIL Label */ 
    {
#line 765
    logputs((enum log_options )0, "\n");
#line 766
    tmp___76 = gettext("No such file `%s\'.\n\n");
#line 766
    logprintf((enum log_options )1, (char const   *)tmp___76, u->file);
#line 767
    closeport(dtsock);
    }
#line 768
    return (err);
#line 769
    goto switch_break___8;
    case_15___8: /* CIL Label */ 
#line 772
    goto switch_break___8;
    switch_default___8: /* CIL Label */ 
    {
#line 774
    abort();
    }
#line 775
    goto switch_break___8;
    switch_break___8: /* CIL Label */ ;
    }
#line 778
    if (! opt.server_response) {
      {
#line 779
      tmp___77 = gettext("done.\n");
#line 779
      logputs((enum log_options )0, (char const   *)tmp___77);
      }
    }
    {
#line 780
    expected_bytes = ftp_expected_bytes((char const   *)(ftp_last_respline));
    }
  }
#line 783
  if (cmd & 8) {
#line 785
    if (! opt.server_response) {
      {
#line 786
      logputs((enum log_options )0, "==> LIST ... ");
      }
    }
    {
#line 790
    err = ftp_list(& con->rbuf, (char const   *)((void *)0));
    }
    {
#line 794
    if ((unsigned int )err == 22U) {
#line 794
      goto case_22___9;
    }
#line 803
    if ((unsigned int )err == 55U) {
#line 803
      goto case_55___6;
    }
#line 812
    if ((unsigned int )err == 19U) {
#line 812
      goto case_19___1;
    }
#line 819
    if ((unsigned int )err == 15U) {
#line 819
      goto case_15___9;
    }
#line 822
    goto switch_default___9;
    case_22___9: /* CIL Label */ 
    {
#line 795
    logputs((enum log_options )0, "\n");
#line 796
    tmp___78 = gettext("Error in server response, closing control connection.\n");
#line 796
    logputs((enum log_options )1, (char const   *)tmp___78);
    }
    {
#line 798
    while (1) {
      while_continue___66: /* CIL Label */ ;
      {
#line 798
      close(csock);
      }
      {
#line 798
      while (1) {
        while_continue___67: /* CIL Label */ ;
#line 798
        if (opt.debug) {
          {
#line 798
          debug_logprintf("Closing fd %d\n", csock);
          }
        }
#line 798
        goto while_break___67;
      }
      while_break___67: /* CIL Label */ ;
      }
#line 798
      goto while_break___66;
    }
    while_break___66: /* CIL Label */ ;
    }
    {
#line 799
    closeport(dtsock);
#line 800
    rbuf_uninitialize(& con->rbuf);
    }
#line 801
    return (err);
#line 802
    goto switch_break___9;
    case_55___6: /* CIL Label */ 
    {
#line 804
    logputs((enum log_options )0, "\n");
#line 805
    tmp___79 = gettext("Write failed, closing control connection.\n");
#line 805
    logputs((enum log_options )1, (char const   *)tmp___79);
    }
    {
#line 807
    while (1) {
      while_continue___68: /* CIL Label */ ;
      {
#line 807
      close(csock);
      }
      {
#line 807
      while (1) {
        while_continue___69: /* CIL Label */ ;
#line 807
        if (opt.debug) {
          {
#line 807
          debug_logprintf("Closing fd %d\n", csock);
          }
        }
#line 807
        goto while_break___69;
      }
      while_break___69: /* CIL Label */ ;
      }
#line 807
      goto while_break___68;
    }
    while_break___68: /* CIL Label */ ;
    }
    {
#line 808
    closeport(dtsock);
#line 809
    rbuf_uninitialize(& con->rbuf);
    }
#line 810
    return (err);
#line 811
    goto switch_break___9;
    case_19___1: /* CIL Label */ 
    {
#line 813
    logputs((enum log_options )0, "\n");
#line 814
    tmp___80 = gettext("No such file or directory `%s\'.\n\n");
#line 814
    logprintf((enum log_options )1, (char const   *)tmp___80, ".");
#line 816
    closeport(dtsock);
    }
#line 817
    return (err);
#line 818
    goto switch_break___9;
    case_15___9: /* CIL Label */ 
#line 821
    goto switch_break___9;
    switch_default___9: /* CIL Label */ 
    {
#line 823
    abort();
    }
#line 824
    goto switch_break___9;
    switch_break___9: /* CIL Label */ ;
    }
#line 826
    if (! opt.server_response) {
      {
#line 827
      tmp___81 = gettext("done.\n");
#line 827
      logputs((enum log_options )0, (char const   *)tmp___81);
      }
    }
    {
#line 828
    expected_bytes = ftp_expected_bytes((char const   *)(ftp_last_respline));
    }
  }
#line 831
  if (! (cmd & 12)) {
#line 832
    return ((uerr_t )42);
  } else
#line 831
  if (opt.spider) {
#line 831
    if (! (cmd & 8)) {
#line 832
      return ((uerr_t )42);
    }
  }
#line 836
  if (*len) {
#line 836
    if (restval) {
#line 836
      if (expected_bytes) {
#line 836
        if (expected_bytes == *len - restval) {
          {
#line 839
          while (1) {
            while_continue___70: /* CIL Label */ ;
#line 839
            if (opt.debug) {
              {
#line 839
              debug_logprintf("Lying FTP server found, adjusting.\n");
              }
            }
#line 839
            goto while_break___70;
          }
          while_break___70: /* CIL Label */ ;
          }
#line 840
          expected_bytes = *len;
        }
      }
    }
  }
#line 844
  if (! pasv_mode_open) {
    {
#line 848
    err = acceptport(& dtsock);
    }
#line 850
    if ((unsigned int )err == 12U) {
      {
#line 852
      tmp___82 = __errno_location();
#line 852
      tmp___83 = strerror(*tmp___82);
#line 852
      logprintf((enum log_options )1, "accept: %s\n", tmp___83);
      }
#line 853
      return (err);
    }
  }
#line 858
  if (! opt.dfp) {
#line 858
    goto _L___2;
  } else
#line 858
  if (con->cmd & 8) {
    _L___2: /* CIL Label */ 
    {
#line 860
    mkalldirs((char const   *)con->target);
    }
#line 861
    if (opt.backups) {
      {
#line 862
      rotate_backups((char const   *)con->target);
      }
    }
    {
#line 864
    chmod((char const   *)con->target, (__mode_t )384);
    }
#line 866
    if (restval) {
#line 866
      tmp___84 = "ab";
    } else {
#line 866
      tmp___84 = "wb";
    }
    {
#line 866
    fp = fopen((char const   */* __restrict  */)con->target, (char const   */* __restrict  */)tmp___84);
    }
#line 867
    if (! fp) {
      {
#line 869
      tmp___85 = __errno_location();
#line 869
      tmp___86 = strerror(*tmp___85);
#line 869
      logprintf((enum log_options )1, "%s: %s\n", con->target, tmp___86);
      }
      {
#line 870
      while (1) {
        while_continue___71: /* CIL Label */ ;
        {
#line 870
        close(csock);
        }
        {
#line 870
        while (1) {
          while_continue___72: /* CIL Label */ ;
#line 870
          if (opt.debug) {
            {
#line 870
            debug_logprintf("Closing fd %d\n", csock);
            }
          }
#line 870
          goto while_break___72;
        }
        while_break___72: /* CIL Label */ ;
        }
#line 870
        goto while_break___71;
      }
      while_break___71: /* CIL Label */ ;
      }
      {
#line 871
      rbuf_uninitialize(& con->rbuf);
#line 872
      closeport(dtsock);
      }
#line 873
      return ((uerr_t )28);
    }
  } else {
#line 879
    fp = opt.dfp;
#line 884
    if (! restval) {
#line 884
      if (global_download_count == 0) {
#line 884
        if ((unsigned long )opt.dfp != (unsigned long )stdout) {
          {
#line 888
          rewind(fp);
#line 891
          tmp___87 = fileno(fp);
#line 891
          ftruncate(tmp___87, (__off_t )0);
#line 892
          clearerr(fp);
          }
        }
      }
    }
  }
#line 896
  if (*len) {
    {
#line 898
    tmp___88 = legible(*len);
#line 898
    tmp___89 = gettext("Length: %s");
#line 898
    logprintf((enum log_options )0, (char const   *)tmp___89, tmp___88);
    }
#line 899
    if (restval) {
      {
#line 900
      tmp___90 = legible(*len - restval);
#line 900
      tmp___91 = gettext(" [%s to go]");
#line 900
      logprintf((enum log_options )0, (char const   *)tmp___91, tmp___90);
      }
    }
    {
#line 901
    logputs((enum log_options )0, "\n");
#line 902
    expected_bytes = *len;
    }
  } else
#line 904
  if (expected_bytes) {
    {
#line 906
    tmp___92 = legible(expected_bytes);
#line 906
    tmp___93 = gettext("Length: %s");
#line 906
    logprintf((enum log_options )0, (char const   *)tmp___93, tmp___92);
    }
#line 907
    if (restval) {
      {
#line 908
      tmp___94 = legible(expected_bytes - restval);
#line 908
      tmp___95 = gettext(" [%s to go]");
#line 908
      logprintf((enum log_options )0, (char const   *)tmp___95, tmp___94);
      }
    }
    {
#line 910
    tmp___96 = gettext(" (unauthoritative)\n");
#line 910
    logputs((enum log_options )0, (char const   *)tmp___96);
    }
  }
  {
#line 914
  res___0 = get_contents(dtsock, fp, len, restval, expected_bytes, & con->rbuf, 0,
                         & con->dltime);
#line 916
  tms = time_str((time_t *)((void *)0));
#line 917
  tmrate = retr_rate(*len - restval, con->dltime, 0);
#line 919
  closeport(dtsock);
  }
#line 926
  if (! opt.dfp) {
    {
#line 927
    flush_res = fclose(fp);
    }
  } else
#line 926
  if (con->cmd & 8) {
    {
#line 927
    flush_res = fclose(fp);
    }
  } else {
    {
#line 929
    flush_res = fflush(fp);
    }
  }
#line 930
  if (flush_res == -1) {
#line 931
    res___0 = -2;
  }
#line 934
  if (res___0 == -2) {
    {
#line 936
    tmp___97 = __errno_location();
#line 936
    tmp___98 = strerror(*tmp___97);
#line 936
    tmp___99 = gettext("%s: %s, closing control connection.\n");
#line 936
    logprintf((enum log_options )1, (char const   *)tmp___99, con->target, tmp___98);
    }
    {
#line 938
    while (1) {
      while_continue___73: /* CIL Label */ ;
      {
#line 938
      close(csock);
      }
      {
#line 938
      while (1) {
        while_continue___74: /* CIL Label */ ;
#line 938
        if (opt.debug) {
          {
#line 938
          debug_logprintf("Closing fd %d\n", csock);
          }
        }
#line 938
        goto while_break___74;
      }
      while_break___74: /* CIL Label */ ;
      }
#line 938
      goto while_break___73;
    }
    while_break___73: /* CIL Label */ ;
    }
    {
#line 939
    rbuf_uninitialize(& con->rbuf);
    }
#line 940
    return ((uerr_t )29);
  } else
#line 942
  if (res___0 == -1) {
    {
#line 944
    tmp___100 = __errno_location();
#line 944
    tmp___101 = strerror(*tmp___100);
#line 944
    tmp___102 = gettext("%s (%s) - Data connection: %s; ");
#line 944
    logprintf((enum log_options )1, (char const   *)tmp___102, tms, tmrate, tmp___101);
    }
#line 946
    if (opt.server_response) {
      {
#line 947
      logputs((enum log_options )3, "\n");
      }
    }
  }
  {
#line 951
  err = ftp_response(& con->rbuf, & respline);
#line 953
  rbuf_discard(& con->rbuf);
  }
#line 954
  if ((unsigned int )err != 15U) {
    {
#line 956
    free((void *)respline);
    }
#line 959
    if (res___0 != -1) {
      {
#line 960
      logprintf((enum log_options )1, "%s (%s) - ", tms, tmrate);
      }
    }
    {
#line 961
    tmp___103 = gettext("Control connection closed.\n");
#line 961
    logputs((enum log_options )1, (char const   *)tmp___103);
    }
    {
#line 966
    while (1) {
      while_continue___75: /* CIL Label */ ;
      {
#line 966
      close(csock);
      }
      {
#line 966
      while (1) {
        while_continue___76: /* CIL Label */ ;
#line 966
        if (opt.debug) {
          {
#line 966
          debug_logprintf("Closing fd %d\n", csock);
          }
        }
#line 966
        goto while_break___76;
      }
      while_break___76: /* CIL Label */ ;
      }
#line 966
      goto while_break___75;
    }
    while_break___75: /* CIL Label */ ;
    }
    {
#line 967
    rbuf_uninitialize(& con->rbuf);
    }
#line 968
    return ((uerr_t )25);
  }
#line 974
  if ((int )*respline != 50) {
    {
#line 976
    free((void *)respline);
    }
#line 977
    if (res___0 != -1) {
      {
#line 978
      logprintf((enum log_options )1, "%s (%s) - ", tms, tmrate);
      }
    }
    {
#line 979
    tmp___104 = gettext("Data transfer aborted.\n");
#line 979
    logputs((enum log_options )1, (char const   *)tmp___104);
    }
#line 980
    return ((uerr_t )25);
  }
  {
#line 982
  free((void *)respline);
  }
#line 984
  if (res___0 == -1) {
#line 988
    return ((uerr_t )25);
  }
#line 991
  if (! (cmd & 16)) {
    {
#line 995
    while (1) {
      while_continue___77: /* CIL Label */ ;
      {
#line 995
      close(csock);
      }
      {
#line 995
      while (1) {
        while_continue___78: /* CIL Label */ ;
#line 995
        if (opt.debug) {
          {
#line 995
          debug_logprintf("Closing fd %d\n", csock);
          }
        }
#line 995
        goto while_break___78;
      }
      while_break___78: /* CIL Label */ ;
      }
#line 995
      goto while_break___77;
    }
    while_break___77: /* CIL Label */ ;
    }
    {
#line 996
    rbuf_uninitialize(& con->rbuf);
    }
  }
#line 1000
  if (opt.server_response) {
#line 1000
    if (con->cmd & 8) {
      {
#line 1002
      mkalldirs((char const   *)con->target);
#line 1003
      fp = fopen((char const   */* __restrict  */)con->target, (char const   */* __restrict  */)"r");
      }
#line 1004
      if (! fp) {
        {
#line 1005
        tmp___105 = __errno_location();
#line 1005
        tmp___106 = strerror(*tmp___105);
#line 1005
        logprintf((enum log_options )3, "%s: %s\n", con->target, tmp___106);
        }
      } else {
        {
#line 1011
        while (1) {
          while_continue___79: /* CIL Label */ ;
          {
#line 1011
          line = read_whole_line(fp);
          }
#line 1011
          if (! line) {
#line 1011
            goto while_break___79;
          }
          {
#line 1013
          logprintf((enum log_options )3, "%s\n", line);
#line 1014
          free((void *)line);
          }
        }
        while_break___79: /* CIL Label */ ;
        }
        {
#line 1016
        fclose(fp);
        }
      }
    }
  }
#line 1020
  return ((uerr_t )42);
}
}
#line 1028 "ftp.c"
static uerr_t ftp_loop_internal(struct url *u , struct fileinfo *f , ccon *con ) 
{ 
  int count ;
  int orig_lp ;
  long restval ;
  long len ;
  char *tms ;
  char *locf ;
  char *tmrate ;
  uerr_t err ;
  struct stat st ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *hurl ;
  char *tmp___5 ;
  char tmp___6[15] ;
  char *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  char *hurl___0 ;
  char *tmp___10 ;
  char *tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;

  {
#line 1034
  tmrate = (char *)((void *)0);
#line 1038
  if (! con->target) {
    {
#line 1039
    con->target = url_file_name((struct url  const  *)u);
    }
  }
#line 1041
  if (opt.noclobber) {
    {
#line 1041
    tmp___0 = file_exists_p((char const   *)con->target);
    }
#line 1041
    if (tmp___0) {
      {
#line 1043
      tmp = gettext("File `%s\' already there, not retrieving.\n");
#line 1043
      logprintf((enum log_options )0, (char const   *)tmp, con->target);
      }
#line 1046
      return ((uerr_t )34);
    }
  }
  {
#line 1050
  remove_link((char const   *)con->target);
  }
#line 1051
  if (! opt.output_document) {
#line 1052
    locf = con->target;
  } else {
#line 1054
    locf = opt.output_document;
  }
#line 1056
  count = 0;
#line 1058
  if (con->st & 1) {
#line 1059
    con->st = 1;
  }
#line 1061
  if (con->cmd & 16) {
#line 1061
    orig_lp = 1;
  } else {
#line 1061
    orig_lp = 0;
  }
  {
#line 1064
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1067
    count ++;
#line 1068
    sleep_between_retrievals(count);
    }
#line 1069
    if (con->st & 1) {
      {
#line 1071
      con->cmd = 0;
#line 1072
      con->cmd |= 20;
#line 1073
      tmp___1 = rbuf_initialized_p(& con->rbuf);
      }
#line 1073
      if (tmp___1) {
#line 1074
        con->cmd &= -4;
      } else {
#line 1076
        con->cmd |= 3;
      }
    } else {
      {
#line 1080
      tmp___2 = rbuf_initialized_p(& con->rbuf);
      }
#line 1080
      if (tmp___2) {
#line 1081
        con->cmd &= -2;
      } else {
#line 1083
        con->cmd |= 1;
      }
#line 1084
      if (con->st & 2) {
#line 1085
        con->cmd &= -3;
      } else {
#line 1087
        con->cmd |= 2;
      }
    }
#line 1091
    restval = 0L;
#line 1092
    if (count > 1) {
#line 1092
      goto _L;
    } else
#line 1092
    if (opt.always_rest) {
      _L: /* CIL Label */ 
#line 1092
      if (! (con->cmd & 8)) {
        {
#line 1092
        tmp___4 = file_exists_p((char const   *)locf);
        }
#line 1092
        if (tmp___4) {
          {
#line 1095
          tmp___3 = stat((char const   */* __restrict  */)locf, (struct stat */* __restrict  */)(& st));
          }
#line 1095
          if (tmp___3 == 0) {
#line 1095
            if ((st.st_mode & 61440U) == 32768U) {
#line 1096
              restval = st.st_size;
            }
          }
        }
      }
    }
#line 1102
    if (opt.always_rest) {
#line 1102
      if (restval > 0L) {
#line 1103
        con->cmd |= 32;
      }
    }
    {
#line 1106
    tms = time_str((time_t *)((void *)0));
    }
#line 1108
    if (opt.verbose) {
      {
#line 1110
      tmp___5 = url_string((struct url  const  *)u, 1);
#line 1110
      hurl = tmp___5;
#line 1112
      strcpy((char */* __restrict  */)(tmp___6), (char const   */* __restrict  */)"        ");
      }
#line 1113
      if (count > 1) {
        {
#line 1114
        tmp___7 = gettext("(try:%2d)");
#line 1114
        sprintf((char */* __restrict  */)(tmp___6), (char const   */* __restrict  */)tmp___7,
                count);
        }
      }
      {
#line 1115
      logprintf((enum log_options )0, "--%s--  %s\n  %s => `%s\'\n", tms, hurl, tmp___6,
                locf);
#line 1120
      free((void *)hurl);
      }
    }
#line 1123
    if (f) {
#line 1124
      len = f->size;
    } else {
#line 1126
      len = 0L;
    }
    {
#line 1127
    err = getftp(u, & len, restval, con);
#line 1129
    tmp___8 = rbuf_initialized_p(& con->rbuf);
    }
#line 1129
    if (tmp___8) {
#line 1132
      con->st |= 2;
    } else {
#line 1130
      con->st &= -3;
    }
    {
#line 1137
    if ((unsigned int )err == 40U) {
#line 1137
      goto case_40;
    }
#line 1137
    if ((unsigned int )err == 39U) {
#line 1137
      goto case_40;
    }
#line 1137
    if ((unsigned int )err == 16U) {
#line 1137
      goto case_40;
    }
#line 1137
    if ((unsigned int )err == 19U) {
#line 1137
      goto case_40;
    }
#line 1137
    if ((unsigned int )err == 28U) {
#line 1137
      goto case_40;
    }
#line 1137
    if ((unsigned int )err == 29U) {
#line 1137
      goto case_40;
    }
#line 1137
    if ((unsigned int )err == 5U) {
#line 1137
      goto case_40;
    }
#line 1137
    if ((unsigned int )err == 1U) {
#line 1137
      goto case_40;
    }
#line 1144
    if ((unsigned int )err == 38U) {
#line 1144
      goto case_38;
    }
#line 1144
    if ((unsigned int )err == 17U) {
#line 1144
      goto case_38;
    }
#line 1144
    if ((unsigned int )err == 18U) {
#line 1144
      goto case_38;
    }
#line 1144
    if ((unsigned int )err == 12U) {
#line 1144
      goto case_38;
    }
#line 1144
    if ((unsigned int )err == 11U) {
#line 1144
      goto case_38;
    }
#line 1144
    if ((unsigned int )err == 9U) {
#line 1144
      goto case_38;
    }
#line 1144
    if ((unsigned int )err == 8U) {
#line 1144
      goto case_38;
    }
#line 1144
    if ((unsigned int )err == 21U) {
#line 1144
      goto case_38;
    }
#line 1144
    if ((unsigned int )err == 55U) {
#line 1144
      goto case_38;
    }
#line 1144
    if ((unsigned int )err == 22U) {
#line 1144
      goto case_38;
    }
#line 1144
    if ((unsigned int )err == 24U) {
#line 1144
      goto case_38;
    }
#line 1144
    if ((unsigned int )err == 3U) {
#line 1144
      goto case_38;
    }
#line 1144
    if ((unsigned int )err == 2U) {
#line 1144
      goto case_38;
    }
#line 1149
    if ((unsigned int )err == 25U) {
#line 1149
      goto case_25;
    }
#line 1158
    if ((unsigned int )err == 42U) {
#line 1158
      goto case_42;
    }
#line 1161
    goto switch_default;
    case_40: /* CIL Label */ 
    case_39: /* CIL Label */ 
    case_16: /* CIL Label */ 
    case_19: /* CIL Label */ 
    case_28: /* CIL Label */ 
    case_29: /* CIL Label */ 
    case_5: /* CIL Label */ 
    case_1: /* CIL Label */ 
#line 1139
    return (err);
#line 1140
    goto switch_break;
    case_38: /* CIL Label */ 
    case_17: /* CIL Label */ 
    case_18: /* CIL Label */ 
    case_12: /* CIL Label */ 
    case_11: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_8: /* CIL Label */ 
    case_21: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_22: /* CIL Label */ 
    case_24: /* CIL Label */ 
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
    {
#line 1145
    printwhat(count, opt.ntry);
    }
#line 1147
    goto __Cont;
#line 1148
    goto switch_break;
    case_25: /* CIL Label */ 
#line 1152
    if (! f) {
      {
#line 1154
      printwhat(count, opt.ntry);
      }
#line 1155
      goto __Cont;
    } else
#line 1152
    if (len != f->size) {
      {
#line 1154
      printwhat(count, opt.ntry);
      }
#line 1155
      goto __Cont;
    }
#line 1157
    goto switch_break;
    case_42: /* CIL Label */ 
#line 1160
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1163
    abort();
    }
    switch_break: /* CIL Label */ ;
    }
    {
#line 1166
    tms = time_str((time_t *)((void *)0));
    }
#line 1167
    if (! opt.spider) {
      {
#line 1168
      tmrate = retr_rate(len - restval, con->dltime, 0);
      }
    }
    {
#line 1172
    downloaded_file((downloaded_file_t )1, (char const   *)locf);
    }
#line 1174
    if (con->st & 1) {
      {
#line 1176
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 1176
        close(con->rbuf.fd);
        }
        {
#line 1176
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1176
          if (opt.debug) {
            {
#line 1176
            debug_logprintf("Closing fd %d\n", con->rbuf.fd);
            }
          }
#line 1176
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1176
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1177
      rbuf_uninitialize(& con->rbuf);
      }
    }
#line 1179
    if (! opt.spider) {
      {
#line 1180
      tmp___9 = gettext("%s (%s) - `%s\' saved [%ld]\n\n");
#line 1180
      logprintf((enum log_options )0, (char const   *)tmp___9, tms, tmrate, locf,
                len);
      }
    }
#line 1182
    if (! opt.verbose) {
#line 1182
      if (! opt.quiet) {
        {
#line 1187
        tmp___10 = url_string((struct url  const  *)u, 1);
#line 1187
        hurl___0 = tmp___10;
#line 1188
        logprintf((enum log_options )2, "%s URL: %s [%ld] -> \"%s\" [%d]\n", tms,
                  hurl___0, len, locf, count);
#line 1190
        free((void *)hurl___0);
        }
      }
    }
#line 1193
    if (con->cmd & 8) {
#line 1196
      if (! opt.remove_listing) {
#line 1200
        total_downloaded_bytes += (LARGE_INT )len;
#line 1201
        (opt.numurls) ++;
      }
    } else
#line 1208
    if (! opt.spider) {
#line 1215
      total_downloaded_bytes += (LARGE_INT )len;
#line 1216
      (opt.numurls) ++;
#line 1218
      if (opt.delete_after) {
        {
#line 1220
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1220
          if (opt.debug) {
            {
#line 1220
            debug_logprintf("Removing file due to --delete-after in ftp_loop_internal():\n");
            }
          }
#line 1220
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 1222
        tmp___11 = gettext("Removing %s.\n");
#line 1222
        logprintf((enum log_options )0, (char const   *)tmp___11, locf);
#line 1223
        tmp___14 = unlink((char const   *)locf);
        }
#line 1223
        if (tmp___14) {
          {
#line 1224
          tmp___12 = __errno_location();
#line 1224
          tmp___13 = strerror(*tmp___12);
#line 1224
          logprintf((enum log_options )1, "unlink: %s\n", tmp___13);
          }
        }
      }
    }
#line 1229
    if (orig_lp) {
#line 1230
      con->cmd |= 16;
    } else {
#line 1232
      con->cmd &= -17;
    }
#line 1233
    return ((uerr_t )34);
    __Cont: /* CIL Label */ 
#line 1064
    if (! (! opt.ntry)) {
#line 1064
      if (! (count < opt.ntry)) {
#line 1064
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1236
  tmp___15 = rbuf_initialized_p(& con->rbuf);
  }
#line 1236
  if (tmp___15) {
#line 1236
    if (con->st & 1) {
      {
#line 1238
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 1238
        close(con->rbuf.fd);
        }
        {
#line 1238
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 1238
          if (opt.debug) {
            {
#line 1238
            debug_logprintf("Closing fd %d\n", con->rbuf.fd);
            }
          }
#line 1238
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 1238
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 1239
      rbuf_uninitialize(& con->rbuf);
      }
    }
  }
#line 1241
  return ((uerr_t )44);
}
}
#line 1246 "ftp.c"
uerr_t ftp_get_listing(struct url *u , ccon *con , struct fileinfo **f ) 
{ 
  uerr_t err ;
  char *uf ;
  char *lf ;
  char *old_target ;
  char *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 1252
  old_target = con->target;
#line 1254
  con->st &= -2;
#line 1255
  con->cmd |= 24;
#line 1256
  con->cmd &= -5;
#line 1261
  uf = url_file_name((struct url  const  *)u);
#line 1262
  lf = file_merge((char const   *)uf, ".listing");
#line 1263
  free((void *)uf);
  }
  {
#line 1264
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1264
    if (opt.debug) {
      {
#line 1264
      tmp = gettext("Using `%s\' as listing tmp file.\n");
#line 1264
      debug_logprintf((char const   *)tmp, lf);
      }
    }
#line 1264
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1266
  con->target = lf;
#line 1267
  err = ftp_loop_internal(u, (struct fileinfo *)((void *)0), con);
#line 1268
  con->target = old_target;
  }
#line 1270
  if ((unsigned int )err == 34U) {
    {
#line 1271
    *f = ftp_parse_ls((char const   *)lf, (enum stype  const  )con->rs);
    }
  } else {
#line 1273
    *f = (struct fileinfo *)((void *)0);
  }
#line 1274
  if (opt.remove_listing) {
    {
#line 1276
    tmp___3 = unlink((char const   *)lf);
    }
#line 1276
    if (tmp___3) {
      {
#line 1277
      tmp___0 = __errno_location();
#line 1277
      tmp___1 = strerror(*tmp___0);
#line 1277
      logprintf((enum log_options )1, "unlink: %s\n", tmp___1);
      }
    } else {
      {
#line 1279
      tmp___2 = gettext("Removed `%s\'.\n");
#line 1279
      logprintf((enum log_options )0, (char const   *)tmp___2, lf);
      }
    }
  }
  {
#line 1281
  free((void *)lf);
#line 1282
  con->cmd &= -9;
  }
#line 1283
  return (err);
}
}
#line 1286
static uerr_t ftp_retrieve_dirs(struct url *u , struct fileinfo *f , ccon *con ) ;
#line 1288
static uerr_t ftp_retrieve_glob(struct url *u , ccon *con , int action ) ;
#line 1289
static struct fileinfo *delelement(struct fileinfo *f , struct fileinfo **start ) ;
#line 1291
static void freefileinfo(struct fileinfo *f ) ;
#line 1303
static uerr_t ftp_retrieve_list(struct url *u , struct fileinfo *f , ccon *con ) ;
#line 1303 "ftp.c"
static int depth  =    0;
#line 1300 "ftp.c"
static uerr_t ftp_retrieve_list(struct url *u , struct fileinfo *f , ccon *con ) 
{ 
  uerr_t err ;
  struct fileinfo *orig ;
  long local_size ;
  time_t tml ;
  int dlthis ;
  char *tmp ;
  long tmp___0 ;
  int tmp___1 ;
  char *old_target ;
  char *ofile ;
  struct stat st ;
  int eq_size ;
  int cor_val ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  struct stat st___0 ;
  int rc ;
  int tmp___8 ;
  size_t len ;
  size_t tmp___9 ;
  char *link_target ;
  void *tmp___10 ;
  size_t n ;
  int tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  char *tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char const   *fl ;
  char *tmp___20 ;
  int tmp___21 ;
  char *tmp___22 ;

  {
#line 1311
  depth ++;
#line 1312
  if (opt.reclevel != -1) {
#line 1312
    if (depth > opt.reclevel) {
      {
#line 1314
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1314
        if (opt.debug) {
          {
#line 1314
          tmp = gettext("Recursion depth %d exceeded max. depth %d.\n");
#line 1314
          debug_logprintf((char const   *)tmp, depth, opt.reclevel);
          }
        }
#line 1314
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 1316
      depth --;
#line 1317
      return ((uerr_t )35);
    }
  }
  {
#line 1320
  tmp___0 = __builtin_expect((long )(! (! ((unsigned long )f != (unsigned long )((void *)0)))),
                             1L);
  }
#line 1320
  if (! tmp___0) {
    {
#line 1320
    __assert_fail("f != ((void *)0)", "ftp.c", 1320U, "ftp_retrieve_list");
    }
  }
#line 1321
  orig = f;
#line 1323
  con->st &= -2;
#line 1324
  if (! (con->st & 2)) {
#line 1325
    con->cmd |= 2;
  } else {
#line 1327
    con->cmd &= -3;
  }
  {
#line 1328
  con->cmd |= 20;
#line 1330
  tmp___1 = rbuf_initialized_p(& con->rbuf);
  }
#line 1330
  if (tmp___1) {
#line 1333
    con->cmd &= -2;
  } else {
#line 1331
    con->cmd |= 1;
  }
#line 1335
  err = (uerr_t )34;
  {
#line 1337
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1337
    if (! f) {
#line 1337
      goto while_break___0;
    }
#line 1341
    if (opt.quota) {
#line 1341
      if (total_downloaded_bytes > opt.quota) {
#line 1343
        depth --;
#line 1344
        return ((uerr_t )54);
      }
    }
    {
#line 1346
    old_target = con->target;
#line 1348
    ofile = xstrdup_real((char const   *)u->file);
#line 1349
    url_set_file(u, (char const   *)f->name);
#line 1351
    con->target = url_file_name((struct url  const  *)u);
#line 1352
    err = (uerr_t )34;
#line 1354
    dlthis = 1;
    }
#line 1355
    if (opt.timestamping) {
#line 1355
      if ((unsigned int )f->type == 0U) {
        {
#line 1363
        tmp___6 = stat((char const   */* __restrict  */)con->target, (struct stat */* __restrict  */)(& st));
        }
#line 1363
        if (! tmp___6) {
#line 1368
          local_size = st.st_size;
#line 1369
          tml = st.st_mtim.tv_sec;
#line 1378
          if ((unsigned int )con->rs == 0U) {
#line 1378
            tmp___2 = 1;
          } else
#line 1378
          if ((unsigned int )con->rs == 2U) {
#line 1378
            tmp___2 = 1;
          } else {
#line 1378
            tmp___2 = 0;
          }
#line 1378
          cor_val = tmp___2;
#line 1379
          if (cor_val) {
#line 1379
            eq_size = local_size == f->size;
          } else {
#line 1379
            eq_size = 1;
          }
#line 1380
          if (f->tstamp <= tml) {
#line 1380
            if (eq_size) {
              {
#line 1384
              tmp___3 = gettext("Remote file no newer than local file `%s\' -- not retrieving.\n");
#line 1384
              logprintf((enum log_options )0, (char const   *)tmp___3, con->target);
#line 1386
              dlthis = 0;
              }
            } else {
#line 1380
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 1388
          if (eq_size) {
            {
#line 1391
            tmp___4 = gettext("Remote file is newer than local file `%s\' -- retrieving.\n\n");
#line 1391
            logprintf((enum log_options )0, (char const   *)tmp___4, con->target);
            }
          } else {
            {
#line 1398
            tmp___5 = gettext("The sizes do not match (local %ld) -- retrieving.\n\n");
#line 1398
            logprintf((enum log_options )0, (char const   *)tmp___5, local_size);
            }
          }
        }
      }
    }
    {
#line 1405
    if ((unsigned int )f->type == 2U) {
#line 1405
      goto case_2;
    }
#line 1461
    if ((unsigned int )f->type == 1U) {
#line 1461
      goto case_1;
    }
#line 1466
    if ((unsigned int )f->type == 0U) {
#line 1466
      goto case_0;
    }
#line 1471
    if ((unsigned int )f->type == 3U) {
#line 1471
      goto case_3;
    }
#line 1403
    goto switch_break;
    case_2: /* CIL Label */ 
#line 1410
    if (! opt.retr_symlinks) {
#line 1413
      if (! f->linkto) {
        {
#line 1414
        tmp___7 = gettext("Invalid name of the symlink, skipping.\n");
#line 1414
        logputs((enum log_options )1, (char const   *)tmp___7);
        }
      } else {
        {
#line 1421
        tmp___8 = lstat((char const   */* __restrict  */)con->target, (struct stat */* __restrict  */)(& st___0));
#line 1421
        rc = tmp___8;
        }
#line 1422
        if (rc == 0) {
          {
#line 1424
          tmp___9 = strlen((char const   *)f->linkto);
#line 1424
          len = tmp___9 + 1U;
          }
#line 1425
          if ((st___0.st_mode & 61440U) == 40960U) {
            {
#line 1427
            tmp___10 = __builtin_alloca((unsigned long )len);
#line 1427
            link_target = (char *)tmp___10;
#line 1428
            tmp___11 = readlink((char const   */* __restrict  */)con->target, (char */* __restrict  */)link_target,
                                len);
#line 1428
            n = (size_t )tmp___11;
            }
#line 1429
            if (n == len - 1U) {
              {
#line 1429
              tmp___13 = memcmp((void const   *)link_target, (void const   *)f->linkto,
                                n);
              }
#line 1429
              if (tmp___13 == 0) {
                {
#line 1432
                tmp___12 = gettext("Already have correct symlink %s -> %s\n\n");
#line 1432
                logprintf((enum log_options )0, (char const   *)tmp___12, con->target,
                          f->linkto);
#line 1435
                dlthis = 0;
                }
#line 1436
                goto switch_break;
              }
            }
          }
        }
        {
#line 1440
        tmp___14 = gettext("Creating symlink %s -> %s\n");
#line 1440
        logprintf((enum log_options )0, (char const   *)tmp___14, con->target, f->linkto);
#line 1443
        unlink((char const   *)con->target);
#line 1444
        tmp___17 = symlink((char const   *)f->linkto, (char const   *)con->target);
        }
#line 1444
        if (tmp___17 == -1) {
          {
#line 1445
          tmp___15 = __errno_location();
#line 1445
          tmp___16 = strerror(*tmp___15);
#line 1445
          logprintf((enum log_options )1, "symlink: %s\n", tmp___16);
          }
        }
        {
#line 1447
        logputs((enum log_options )0, "\n");
        }
      }
    } else
#line 1457
    if (dlthis) {
      {
#line 1458
      err = ftp_loop_internal(u, f, con);
      }
    }
#line 1460
    goto switch_break;
    case_1: /* CIL Label */ 
#line 1462
    if (! opt.recursive) {
      {
#line 1463
      tmp___18 = gettext("Skipping directory `%s\'.\n");
#line 1463
      logprintf((enum log_options )1, (char const   *)tmp___18, f->name);
      }
    }
#line 1465
    goto switch_break;
    case_0: /* CIL Label */ 
#line 1468
    if (dlthis) {
      {
#line 1469
      err = ftp_loop_internal(u, f, con);
      }
    }
#line 1470
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 1472
    tmp___19 = gettext("%s: unknown/unsupported file type.\n");
#line 1472
    logprintf((enum log_options )1, (char const   *)tmp___19, f->name);
    }
#line 1474
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1480
    if ((unsigned int )f->type == 2U) {
#line 1480
      if (! opt.retr_symlinks) {
        _L___2: /* CIL Label */ 
#line 1498
        if (f->tstamp == -1L) {
          {
#line 1499
          tmp___20 = gettext("%s: corrupt time-stamp.\n");
#line 1499
          logprintf((enum log_options )1, (char const   *)tmp___20, con->target);
          }
        }
      } else {
#line 1480
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 1480
    if (f->tstamp != -1L) {
#line 1480
      if (dlthis) {
        {
#line 1480
        tmp___21 = file_exists_p((char const   *)con->target);
        }
#line 1480
        if (tmp___21) {
#line 1487
          fl = (char const   *)((void *)0);
#line 1488
          if (opt.output_document) {
#line 1490
            if (opt.od_known_regular) {
#line 1491
              fl = (char const   *)opt.output_document;
            }
          } else {
#line 1494
            fl = (char const   *)con->target;
          }
#line 1495
          if (fl) {
            {
#line 1496
            touch(fl, f->tstamp);
            }
          }
        } else {
#line 1480
          goto _L___2;
        }
      } else {
#line 1480
        goto _L___2;
      }
    } else {
#line 1480
      goto _L___2;
    }
#line 1501
    if (f->perms) {
#line 1501
      if ((unsigned int )f->type == 0U) {
#line 1501
        if (dlthis) {
          {
#line 1502
          chmod((char const   *)con->target, (__mode_t )f->perms);
          }
        } else {
#line 1501
          goto _L___5;
        }
      } else {
#line 1501
        goto _L___5;
      }
    } else {
      _L___5: /* CIL Label */ 
      {
#line 1504
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1504
        if (opt.debug) {
          {
#line 1504
          debug_logprintf("Unrecognized permissions for %s.\n", con->target);
          }
        }
#line 1504
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
#line 1506
    free((void *)con->target);
#line 1507
    con->target = old_target;
#line 1509
    url_set_file(u, (char const   *)ofile);
#line 1510
    free((void *)ofile);
    }
#line 1513
    if ((unsigned int )err == 54U) {
#line 1514
      goto while_break___0;
    } else
#line 1513
    if ((unsigned int )err == 1U) {
#line 1514
      goto while_break___0;
    } else
#line 1513
    if ((unsigned int )err == 29U) {
#line 1514
      goto while_break___0;
    }
#line 1515
    con->cmd &= -4;
#line 1516
    f = f->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1520
  if (opt.recursive) {
#line 1520
    if (opt.reclevel != -1) {
#line 1520
      if (depth >= opt.reclevel) {
#line 1520
        goto _L___6;
      } else {
        {
#line 1522
        err = ftp_retrieve_dirs(u, orig, con);
        }
      }
    } else {
      {
#line 1522
      err = ftp_retrieve_dirs(u, orig, con);
      }
    }
  } else
  _L___6: /* CIL Label */ 
#line 1523
  if (opt.recursive) {
    {
#line 1524
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1524
      if (opt.debug) {
        {
#line 1524
        tmp___22 = gettext("Will not retrieve dirs since depth is %d (max %d).\n");
#line 1524
        debug_logprintf((char const   *)tmp___22, depth, opt.reclevel);
        }
      }
#line 1524
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 1526
  depth --;
#line 1527
  return (err);
}
}
#line 1534 "ftp.c"
static uerr_t ftp_retrieve_dirs(struct url *u , struct fileinfo *f , ccon *con ) 
{ 
  char *container ;
  int container_size ;
  int size ;
  char *odir ;
  char *newdir ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
#line 1537
  container = (char *)((void *)0);
#line 1538
  container_size = 0;
  {
#line 1540
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1540
    if (! f) {
#line 1540
      goto while_break;
    }
#line 1545
    if (opt.quota) {
#line 1545
      if (total_downloaded_bytes > opt.quota) {
#line 1546
        goto while_break;
      }
    }
#line 1547
    if ((unsigned int )f->type != 1U) {
#line 1548
      goto __Cont;
    }
    {
#line 1553
    tmp = strlen((char const   *)u->dir);
#line 1553
    tmp___0 = strlen((char const   *)f->name);
#line 1553
    size = (int )(((tmp + 1U) + tmp___0) + 1U);
    }
#line 1554
    if (size > container_size) {
      {
#line 1555
      tmp___1 = __builtin_alloca((unsigned long )size);
#line 1555
      container = (char *)tmp___1;
      }
    }
#line 1556
    newdir = container;
#line 1558
    odir = u->dir;
#line 1559
    if ((int )*odir == 0) {
      {
#line 1564
      sprintf((char */* __restrict  */)newdir, (char const   */* __restrict  */)"%s%s",
              odir, f->name);
      }
    } else
#line 1559
    if ((int )*odir == 47) {
#line 1559
      if ((int )*(odir + 1) == 0) {
        {
#line 1564
        sprintf((char */* __restrict  */)newdir, (char const   */* __restrict  */)"%s%s",
                odir, f->name);
        }
      } else {
        {
#line 1567
        sprintf((char */* __restrict  */)newdir, (char const   */* __restrict  */)"%s/%s",
                odir, f->name);
        }
      }
    } else {
      {
#line 1567
      sprintf((char */* __restrict  */)newdir, (char const   */* __restrict  */)"%s/%s",
              odir, f->name);
      }
    }
    {
#line 1569
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1569
      if (opt.debug) {
        {
#line 1569
        debug_logprintf("Composing new CWD relative to the initial directory.\n");
        }
      }
#line 1569
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1570
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1570
      if (opt.debug) {
        {
#line 1570
        debug_logprintf("  odir = \'%s\'\n  f->name = \'%s\'\n  newdir = \'%s\'\n\n",
                        odir, f->name, newdir);
        }
      }
#line 1570
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1572
    tmp___3 = accdir((char const   *)newdir, (enum accd )1);
    }
#line 1572
    if (! tmp___3) {
      {
#line 1574
      tmp___2 = gettext("Not descending to `%s\' as it is excluded/not-included.\n");
#line 1574
      logprintf((enum log_options )0, (char const   *)tmp___2, newdir);
      }
#line 1576
      goto __Cont;
    }
    {
#line 1579
    con->st &= -3;
#line 1581
    odir = xstrdup_real((char const   *)u->dir);
#line 1583
    url_set_dir(u, (char const   *)newdir);
#line 1584
    ftp_retrieve_glob(u, con, 1);
#line 1585
    url_set_dir(u, (char const   *)odir);
#line 1586
    free((void *)odir);
    }
    __Cont: /* CIL Label */ 
#line 1540
    f = f->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1591
  if (opt.quota) {
#line 1591
    if (total_downloaded_bytes > opt.quota) {
#line 1592
      return ((uerr_t )54);
    } else {
#line 1594
      return ((uerr_t )34);
    }
  } else {
#line 1594
    return ((uerr_t )34);
  }
}
}
#line 1598 "ftp.c"
static int has_insecure_name_p(char const   *s ) 
{ 
  char *tmp ;

  {
#line 1601
  if ((int const   )*s == 47) {
#line 1602
    return (1);
  }
  {
#line 1604
  tmp = strstr(s, "../");
  }
#line 1604
  if ((unsigned long )tmp != (unsigned long )((char *)0)) {
#line 1605
    return (1);
  }
#line 1607
  return (0);
}
}
#line 1618 "ftp.c"
static uerr_t ftp_retrieve_glob(struct url *u , ccon *con , int action ) 
{ 
  struct fileinfo *f ;
  struct fileinfo *start ;
  uerr_t res___0 ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int matchres ;
  int *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 1624
  con->cmd |= 16;
#line 1626
  res___0 = ftp_get_listing(u, con, & start);
  }
#line 1627
  if ((unsigned int )res___0 != 34U) {
#line 1628
    return (res___0);
  }
#line 1631
  if (opt.accepts) {
#line 1631
    goto _L;
  } else
#line 1631
  if (opt.rejects) {
    _L: /* CIL Label */ 
#line 1633
    f = start;
    {
#line 1634
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1634
      if (! f) {
#line 1634
        goto while_break;
      }
#line 1636
      if ((unsigned int )f->type != 1U) {
        {
#line 1636
        tmp___0 = acceptable((char const   *)f->name);
        }
#line 1636
        if (tmp___0) {
#line 1642
          f = f->next;
        } else {
          {
#line 1638
          tmp = gettext("Rejecting `%s\'.\n");
#line 1638
          logprintf((enum log_options )0, (char const   *)tmp, f->name);
#line 1639
          f = delelement(f, & start);
          }
        }
      } else {
#line 1642
        f = f->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1646
  f = start;
  {
#line 1647
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1647
    if (! f) {
#line 1647
      goto while_break___0;
    }
    {
#line 1649
    tmp___2 = has_insecure_name_p((char const   *)f->name);
    }
#line 1649
    if (tmp___2) {
      {
#line 1651
      tmp___1 = gettext("Rejecting `%s\'.\n");
#line 1651
      logprintf((enum log_options )0, (char const   *)tmp___1, f->name);
#line 1652
      f = delelement(f, & start);
      }
    } else {
#line 1655
      f = f->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1659
  if (*(u->file)) {
#line 1659
    if (action == 0) {
#line 1659
      goto _L___0;
    } else
#line 1659
    if (action == 2) {
      _L___0: /* CIL Label */ 
#line 1661
      matchres = 0;
#line 1663
      f = start;
      {
#line 1664
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1664
        if (! f) {
#line 1664
          goto while_break___1;
        }
        {
#line 1666
        matchres = fnmatch((char const   *)u->file, (char const   *)f->name, 0);
        }
#line 1667
        if (matchres == -1) {
          {
#line 1669
          tmp___3 = __errno_location();
#line 1669
          tmp___4 = strerror(*tmp___3);
#line 1669
          logprintf((enum log_options )1, "%s: %s\n", con->target, tmp___4);
          }
#line 1671
          goto while_break___1;
        }
#line 1673
        if (matchres == 1) {
          {
#line 1674
          f = delelement(f, & start);
          }
        } else {
#line 1676
          f = f->next;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1678
      if (matchres == -1) {
        {
#line 1680
        freefileinfo(start);
        }
#line 1681
        return ((uerr_t )48);
      }
    }
  }
#line 1684
  res___0 = (uerr_t )34;
#line 1685
  if (start) {
    {
#line 1688
    ftp_retrieve_list(u, start, con);
    }
  } else
#line 1690
  if (! start) {
#line 1692
    if (action == 0) {
      {
#line 1697
      tmp___5 = gettext("No matches on pattern `%s\'.\n");
#line 1697
      logprintf((enum log_options )0, (char const   *)tmp___5, u->file);
      }
    } else {
      {
#line 1702
      con->st |= 1;
#line 1703
      res___0 = ftp_loop_internal(u, (struct fileinfo *)((void *)0), con);
      }
#line 1704
      return (res___0);
    }
  }
  {
#line 1707
  freefileinfo(start);
  }
#line 1708
  if (opt.quota) {
#line 1708
    if (total_downloaded_bytes > opt.quota) {
#line 1709
      return ((uerr_t )54);
    } else {
#line 1712
      return ((uerr_t )34);
    }
  } else {
#line 1712
    return ((uerr_t )34);
  }
}
}
#line 1718 "ftp.c"
uerr_t ftp_loop(struct url *u , int *dt , struct url *proxy ) 
{ 
  ccon con ;
  uerr_t res___0 ;
  struct fileinfo *f ;
  char *filename ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  struct stat st ;
  long sz ;
  int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int wild ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 1724
  *dt = 0;
#line 1726
  memset((void *)(& con), 0, (size_t )sizeof(con));
#line 1728
  rbuf_uninitialize(& con.rbuf);
#line 1729
  con.st = 1;
#line 1730
  con.rs = (enum stype )0;
#line 1731
  con.id = (char *)((void *)0);
#line 1732
  con.proxy = proxy;
#line 1733
  res___0 = (uerr_t )34;
  }
#line 1738
  if (! *(u->file)) {
#line 1738
    if (! opt.recursive) {
      {
#line 1741
      res___0 = ftp_get_listing(u, & con, & f);
      }
#line 1743
      if ((unsigned int )res___0 == 34U) {
#line 1745
        if (opt.htmlify) {
#line 1745
          if (! opt.spider) {
#line 1747
            if (opt.output_document) {
              {
#line 1747
              tmp = xstrdup_real((char const   *)opt.output_document);
#line 1747
              tmp___3 = tmp;
              }
            } else {
#line 1747
              if (con.target) {
                {
#line 1747
                tmp___0 = xstrdup_real((char const   *)con.target);
#line 1747
                tmp___2 = tmp___0;
                }
              } else {
                {
#line 1747
                tmp___1 = url_file_name((struct url  const  *)u);
#line 1747
                tmp___2 = tmp___1;
                }
              }
#line 1747
              tmp___3 = tmp___2;
            }
            {
#line 1747
            filename = tmp___3;
#line 1751
            res___0 = ftp_index((char const   *)filename, u, f);
            }
#line 1752
            if ((unsigned int )res___0 == 15U) {
#line 1752
              if (opt.verbose) {
#line 1754
                if (! opt.output_document) {
                  {
#line 1758
                  tmp___4 = stat((char const   */* __restrict  */)filename, (struct stat */* __restrict  */)(& st));
                  }
#line 1758
                  if (tmp___4 == 0) {
#line 1759
                    sz = st.st_size;
                  } else {
#line 1761
                    sz = -1L;
                  }
                  {
#line 1762
                  tmp___5 = gettext("Wrote HTML-ized index to `%s\' [%ld].\n");
#line 1762
                  logprintf((enum log_options )1, (char const   *)tmp___5, filename,
                            sz);
                  }
                } else {
                  {
#line 1767
                  tmp___6 = gettext("Wrote HTML-ized index to `%s\'.\n");
#line 1767
                  logprintf((enum log_options )1, (char const   *)tmp___6, filename);
                  }
                }
              }
            }
            {
#line 1771
            free((void *)filename);
            }
          }
        }
        {
#line 1773
        freefileinfo(f);
        }
      }
    } else {
#line 1738
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
    {
#line 1778
    tmp___7 = has_wildcards_p((char const   *)u->file);
#line 1778
    wild = tmp___7;
    }
#line 1779
    if (opt.ftp_glob) {
#line 1779
      if (wild) {
#line 1779
        goto _L;
      } else {
#line 1779
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1779
    if (opt.recursive) {
#line 1779
      goto _L;
    } else
#line 1779
    if (opt.timestamping) {
      _L: /* CIL Label */ 
#line 1784
      if (opt.ftp_glob) {
#line 1784
        if (wild) {
#line 1784
          tmp___8 = 0;
        } else {
#line 1784
          tmp___8 = 2;
        }
      } else {
#line 1784
        tmp___8 = 2;
      }
      {
#line 1784
      res___0 = ftp_retrieve_glob(u, & con, tmp___8);
      }
    } else {
      {
#line 1788
      res___0 = ftp_loop_internal(u, (struct fileinfo *)((void *)0), & con);
      }
    }
  }
#line 1790
  if ((unsigned int )res___0 == 15U) {
#line 1791
    res___0 = (uerr_t )34;
  }
#line 1792
  if ((unsigned int )res___0 == 34U) {
#line 1793
    *dt |= 2;
  }
  {
#line 1795
  tmp___9 = rbuf_initialized_p(& con.rbuf);
  }
#line 1795
  if (tmp___9) {
    {
#line 1796
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1796
      close(con.rbuf.fd);
      }
      {
#line 1796
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1796
        if (opt.debug) {
          {
#line 1796
          debug_logprintf("Closing fd %d\n", con.rbuf.fd);
          }
        }
#line 1796
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1796
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1797
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1797
    if (con.id) {
      {
#line 1797
      free((void *)con.id);
      }
    }
#line 1797
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1798
  con.id = (char *)((void *)0);
  {
#line 1799
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1799
    if (con.target) {
      {
#line 1799
      free((void *)con.target);
      }
    }
#line 1799
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1800
  con.target = (char *)((void *)0);
#line 1801
  return (res___0);
}
}
#line 1807 "ftp.c"
static struct fileinfo *delelement(struct fileinfo *f , struct fileinfo **start ) 
{ 
  struct fileinfo *prev ;
  struct fileinfo *next ;

  {
  {
#line 1810
  prev = f->prev;
#line 1811
  next = f->next;
#line 1813
  free((void *)f->name);
  }
  {
#line 1814
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1814
    if (f->linkto) {
      {
#line 1814
      free((void *)f->linkto);
      }
    }
#line 1814
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1815
  free((void *)f);
  }
#line 1817
  if (next) {
#line 1818
    next->prev = prev;
  }
#line 1819
  if (prev) {
#line 1820
    prev->next = next;
  } else {
#line 1822
    *start = next;
  }
#line 1823
  return (next);
}
}
#line 1827 "ftp.c"
static void freefileinfo(struct fileinfo *f ) 
{ 
  struct fileinfo *next ;

  {
  {
#line 1830
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1830
    if (! f) {
#line 1830
      goto while_break;
    }
    {
#line 1832
    next = f->next;
#line 1833
    free((void *)f->name);
    }
#line 1834
    if (f->linkto) {
      {
#line 1835
      free((void *)f->linkto);
      }
    }
    {
#line 1836
    free((void *)f);
#line 1837
    f = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1839
  return;
}
}
#line 401 "/usr/include/stdio.h"
extern int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                  , ...) ;
#line 477
extern int fputc(int __c , FILE *__stream ) ;
#line 743 "/usr/include/stdlib.h"
extern void qsort(void *__base , size_t __nmemb , size_t __size , int (*__compar)(void const   * ,
                                                                                  void const   * ) ) ;
#line 251 "/usr/include/time.h"
extern char *asctime(struct tm  const  *__tp ) ;
#line 36 "cookies.h"
void cookie_jar_delete(struct cookie_jar *jar ) ;
#line 88 "cookies.c"
time_t cookies_now  ;
#line 90 "cookies.c"
struct cookie_jar *cookie_jar_new(void) 
{ 
  struct cookie_jar *jar ;
  void *tmp ;

  {
  {
#line 93
  tmp = xmalloc_real((size_t )sizeof(struct cookie_jar ));
#line 93
  jar = (struct cookie_jar *)tmp;
#line 94
  jar->chains = make_nocase_string_hash_table(0);
#line 95
  jar->cookie_count = 0;
  }
#line 96
  return (jar);
}
}
#line 130 "cookies.c"
static struct cookie *cookie_new(void) 
{ 
  struct cookie *cookie ;
  void *tmp ;

  {
  {
#line 133
  tmp = xmalloc_real((size_t )sizeof(struct cookie ));
#line 133
  cookie = (struct cookie *)tmp;
#line 134
  memset((void *)cookie, '\000', (size_t )sizeof(struct cookie ));
#line 140
  cookie->port = -1;
  }
#line 141
  return (cookie);
}
}
#line 146 "cookies.c"
static void delete_cookie(struct cookie *cookie ) 
{ 


  {
  {
#line 149
  while (1) {
    while_continue: /* CIL Label */ ;
#line 149
    if (cookie->domain) {
      {
#line 149
      free((void *)cookie->domain);
      }
    }
#line 149
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 150
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 150
    if (cookie->path) {
      {
#line 150
      free((void *)cookie->path);
      }
    }
#line 150
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 151
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 151
    if (cookie->attr) {
      {
#line 151
      free((void *)cookie->attr);
      }
    }
#line 151
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 152
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 152
    if (cookie->value) {
      {
#line 152
      free((void *)cookie->value);
      }
    }
#line 152
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 153
  free((void *)cookie);
  }
#line 154
  return;
}
}
#line 170 "cookies.c"
static struct cookie *find_matching_cookie(struct cookie_jar *jar , struct cookie *cookie ,
                                           struct cookie **prevptr ) 
{ 
  struct cookie *chain ;
  struct cookie *prev ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 176
  tmp = hash_table_get((struct hash_table  const  *)jar->chains, (void const   *)cookie->domain);
#line 176
  chain = (struct cookie *)tmp;
  }
#line 177
  if (! chain) {
#line 178
    goto nomatch;
  }
#line 180
  prev = (struct cookie *)((void *)0);
  {
#line 181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 181
    if (! chain) {
#line 181
      goto while_break;
    }
    {
#line 182
    tmp___0 = strcmp((char const   *)cookie->path, (char const   *)chain->path);
    }
#line 182
    if (0 == tmp___0) {
      {
#line 182
      tmp___1 = strcmp((char const   *)cookie->attr, (char const   *)chain->attr);
      }
#line 182
      if (0 == tmp___1) {
#line 182
        if (cookie->port == chain->port) {
#line 186
          *prevptr = prev;
#line 187
          return (chain);
        }
      }
    }
#line 181
    prev = chain;
#line 181
    chain = chain->next;
  }
  while_break: /* CIL Label */ ;
  }
  nomatch: 
#line 191
  *prevptr = (struct cookie *)((void *)0);
#line 192
  return ((struct cookie *)((void *)0));
}
}
#line 204 "cookies.c"
static void store_cookie(struct cookie_jar *jar , struct cookie *cookie ) 
{ 
  struct cookie *chain_head ;
  char *chain_key ;
  struct cookie *prev ;
  struct cookie *victim ;
  struct cookie *tmp ;
  int tmp___0 ;
  struct tm *tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;

  {
  {
#line 210
  tmp___0 = hash_table_get_pair((struct hash_table  const  *)jar->chains, (void const   *)cookie->domain,
                                (void *)(& chain_key), (void *)(& chain_head));
  }
#line 210
  if (tmp___0) {
    {
#line 217
    tmp = find_matching_cookie(jar, cookie, & prev);
#line 217
    victim = tmp;
    }
#line 219
    if (victim) {
#line 223
      if (prev) {
#line 225
        prev->next = victim->next;
#line 226
        cookie->next = chain_head;
      } else {
#line 233
        cookie->next = victim->next;
      }
      {
#line 235
      delete_cookie(victim);
#line 236
      (jar->cookie_count) --;
      }
      {
#line 237
      while (1) {
        while_continue: /* CIL Label */ ;
#line 237
        if (opt.debug) {
          {
#line 237
          debug_logprintf("Deleted old cookie (to be replaced.)\n");
          }
        }
#line 237
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 240
      cookie->next = chain_head;
    }
  } else {
    {
#line 249
    cookie->next = (struct cookie *)((void *)0);
#line 250
    chain_key = xstrdup_real((char const   *)cookie->domain);
    }
  }
  {
#line 253
  hash_table_put(jar->chains, (void const   *)chain_key, (void *)cookie);
#line 254
  (jar->cookie_count) ++;
  }
  {
#line 256
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 256
    if (opt.debug) {
#line 256
      if (cookie->expiry_time) {
        {
#line 256
        tmp___1 = localtime((time_t const   *)(& cookie->expiry_time));
#line 256
        tmp___2 = asctime((struct tm  const  *)tmp___1);
#line 256
        tmp___3 = (char const   *)tmp___2;
        }
      } else {
#line 256
        tmp___3 = "<undefined>";
      }
#line 256
      if (cookie->permanent) {
#line 256
        tmp___4 = "permanent";
      } else {
#line 256
        tmp___4 = "nonpermanent";
      }
#line 256
      if (cookie->port == -1) {
#line 256
        tmp___5 = " (ANY)";
      } else {
#line 256
        tmp___5 = "";
      }
      {
#line 256
      debug_logprintf("\nStored cookie %s %d%s %s %s %d %s %s %s\n", cookie->domain,
                      cookie->port, tmp___5, cookie->path, tmp___4, cookie->secure,
                      tmp___3, cookie->attr, cookie->value);
      }
    }
#line 256
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 265
  return;
}
}
#line 273 "cookies.c"
static void discard_matching_cookie(struct cookie_jar *jar , struct cookie *cookie ) 
{ 
  struct cookie *prev ;
  struct cookie *victim ;
  int tmp ;
  char *chain_key ;
  int res___0 ;
  long tmp___0 ;

  {
  {
#line 278
  tmp = hash_table_count((struct hash_table  const  *)jar->chains);
  }
#line 278
  if (! tmp) {
#line 280
    return;
  }
  {
#line 282
  victim = find_matching_cookie(jar, cookie, & prev);
  }
#line 283
  if (victim) {
#line 285
    if (prev) {
#line 287
      prev->next = victim->next;
    } else {
      {
#line 292
      chain_key = (char *)((void *)0);
#line 295
      res___0 = hash_table_get_pair((struct hash_table  const  *)jar->chains, (void const   *)victim->domain,
                                    (void *)(& chain_key), (void *)0);
#line 297
      tmp___0 = __builtin_expect((long )(! (! (res___0 != 0))), 1L);
      }
#line 297
      if (! tmp___0) {
        {
#line 297
        __assert_fail("res != 0", "cookies.c", 297U, "discard_matching_cookie");
        }
      }
#line 298
      if (! victim->next) {
        {
#line 302
        hash_table_remove(jar->chains, (void const   *)victim->domain);
#line 303
        free((void *)chain_key);
        }
      } else {
        {
#line 306
        hash_table_put(jar->chains, (void const   *)chain_key, (void *)victim->next);
        }
      }
    }
    {
#line 308
    delete_cookie(victim);
    }
    {
#line 309
    while (1) {
      while_continue: /* CIL Label */ ;
#line 309
      if (opt.debug) {
        {
#line 309
        debug_logprintf("Discarded old cookie.\n");
        }
      }
#line 309
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 311
  return;
}
}
#line 336 "cookies.c"
static int update_cookie_field(struct cookie *cookie , char const   *name_b , char const   *name_e ,
                               char const   *value_b , char const   *value_e ) 
{ 
  int tmp ;
  long tmp___0 ;
  char *value_copy ;
  time_t expires ;
  char const   *BTA_beg ;
  int BTA_len ;
  char **BTA_dest ;
  void *tmp___1 ;
  double maxage ;
  char *value_copy___0 ;
  char const   *BTA_beg___0 ;
  int BTA_len___0 ;
  char **BTA_dest___0 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 341
  if ((unsigned long )name_b != (unsigned long )((void *)0)) {
#line 341
    if ((unsigned long )name_e != (unsigned long )((void *)0)) {
#line 341
      tmp = 1;
    } else {
#line 341
      tmp = 0;
    }
  } else {
#line 341
    tmp = 0;
  }
  {
#line 341
  tmp___0 = __builtin_expect((long )tmp, 1L);
  }
#line 341
  if (! tmp___0) {
    {
#line 341
    __assert_fail("name_b != ((void *)0) && name_e != ((void *)0)", "cookies.c", 341U,
                  "update_cookie_field");
    }
  }
#line 343
  if (! cookie->attr) {
#line 345
    if (value_b) {
#line 345
      if (! value_e) {
#line 346
        return (0);
      }
    } else {
#line 346
      return (0);
    }
    {
#line 347
    cookie->attr = strdupdelim(name_b, name_e);
#line 348
    cookie->value = strdupdelim(value_b, value_e);
    }
#line 349
    return (1);
  }
#line 352
  if ((unsigned long )(name_e - name_b) == sizeof("domain") - 1UL) {
    {
#line 352
    tmp___7 = strncasecmp(name_b, "domain", (size_t )(sizeof("domain") - 1UL));
    }
#line 352
    if (tmp___7) {
#line 352
      goto _L___2;
    } else {
#line 354
      if (value_b) {
#line 354
        if (value_e) {
#line 354
          if (! ((unsigned long )value_b != (unsigned long )value_e)) {
#line 355
            return (0);
          }
        } else {
#line 355
          return (0);
        }
      } else {
#line 355
        return (0);
      }
      {
#line 356
      while (1) {
        while_continue: /* CIL Label */ ;
#line 356
        if (cookie->domain) {
          {
#line 356
          free((void *)cookie->domain);
          }
        }
#line 356
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 361
      if ((int const   )*value_b == 46) {
#line 362
        value_b ++;
      }
      {
#line 363
      cookie->domain = strdupdelim(value_b, value_e);
      }
#line 364
      return (1);
    }
  } else
  _L___2: /* CIL Label */ 
#line 366
  if ((unsigned long )(name_e - name_b) == sizeof("path") - 1UL) {
    {
#line 366
    tmp___6 = strncasecmp(name_b, "path", (size_t )(sizeof("path") - 1UL));
    }
#line 366
    if (tmp___6) {
#line 366
      goto _L___1;
    } else {
#line 368
      if (value_b) {
#line 368
        if (value_e) {
#line 368
          if (! ((unsigned long )value_b != (unsigned long )value_e)) {
#line 369
            return (0);
          }
        } else {
#line 369
          return (0);
        }
      } else {
#line 369
        return (0);
      }
      {
#line 370
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 370
        if (cookie->path) {
          {
#line 370
          free((void *)cookie->path);
          }
        }
#line 370
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 371
      cookie->path = strdupdelim(value_b, value_e);
      }
#line 372
      return (1);
    }
  } else
  _L___1: /* CIL Label */ 
#line 374
  if ((unsigned long )(name_e - name_b) == sizeof("expires") - 1UL) {
    {
#line 374
    tmp___5 = strncasecmp(name_b, "expires", (size_t )(sizeof("expires") - 1UL));
    }
#line 374
    if (tmp___5) {
#line 374
      goto _L___0;
    } else {
#line 379
      if (value_b) {
#line 379
        if (value_e) {
#line 379
          if (! ((unsigned long )value_b != (unsigned long )value_e)) {
#line 380
            return (0);
          }
        } else {
#line 380
          return (0);
        }
      } else {
#line 380
        return (0);
      }
      {
#line 381
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 381
        BTA_beg = value_b;
#line 381
        BTA_len = (int )(value_e - BTA_beg);
#line 381
        BTA_dest = & value_copy;
#line 381
        tmp___1 = __builtin_alloca((unsigned long )(BTA_len + 1));
#line 381
        *BTA_dest = (char *)tmp___1;
#line 381
        memcpy((void */* __restrict  */)*BTA_dest, (void const   */* __restrict  */)BTA_beg,
               (size_t )BTA_len);
#line 381
        *(*BTA_dest + BTA_len) = (char )'\000';
        }
#line 381
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 383
      expires = http_atotm((char const   *)value_copy);
      }
#line 384
      if (expires != -1L) {
#line 386
        cookie->permanent = 1;
#line 387
        cookie->expiry_time = expires;
      }
#line 397
      if (cookie->expiry_time < cookies_now) {
#line 398
        cookie->discard_requested = 1;
      }
#line 400
      return (1);
    }
  } else
  _L___0: /* CIL Label */ 
#line 402
  if ((unsigned long )(name_e - name_b) == sizeof("max-age") - 1UL) {
    {
#line 402
    tmp___4 = strncasecmp(name_b, "max-age", (size_t )(sizeof("max-age") - 1UL));
    }
#line 402
    if (tmp___4) {
#line 402
      goto _L;
    } else {
#line 404
      maxage = (double )-1;
#line 407
      if (value_b) {
#line 407
        if (value_e) {
#line 407
          if (! ((unsigned long )value_b != (unsigned long )value_e)) {
#line 408
            return (0);
          }
        } else {
#line 408
          return (0);
        }
      } else {
#line 408
        return (0);
      }
      {
#line 409
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 409
        BTA_beg___0 = value_b;
#line 409
        BTA_len___0 = (int )(value_e - BTA_beg___0);
#line 409
        BTA_dest___0 = & value_copy___0;
#line 409
        tmp___2 = __builtin_alloca((unsigned long )(BTA_len___0 + 1));
#line 409
        *BTA_dest___0 = (char *)tmp___2;
#line 409
        memcpy((void */* __restrict  */)*BTA_dest___0, (void const   */* __restrict  */)BTA_beg___0,
               (size_t )BTA_len___0);
#line 409
        *(*BTA_dest___0 + BTA_len___0) = (char )'\000';
        }
#line 409
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 411
      sscanf((char const   */* __restrict  */)value_copy___0, (char const   */* __restrict  */)"%lf",
             & maxage);
      }
#line 412
      if (maxage == (double )-1) {
#line 414
        return (0);
      }
#line 415
      cookie->permanent = 1;
#line 416
      cookie->expiry_time = (time_t )((double )cookies_now + maxage);
#line 420
      if (maxage == (double )0) {
#line 421
        cookie->discard_requested = 1;
      }
#line 423
      return (1);
    }
  } else
  _L: /* CIL Label */ 
#line 425
  if ((unsigned long )(name_e - name_b) == sizeof("secure") - 1UL) {
    {
#line 425
    tmp___3 = strncasecmp(name_b, "secure", (size_t )(sizeof("secure") - 1UL));
    }
#line 425
    if (tmp___3) {
#line 433
      return (1);
    } else {
#line 428
      cookie->secure = 1;
#line 429
      return (1);
    }
  } else {
#line 433
    return (1);
  }
}
}
#line 462 "cookies.c"
static struct cookie *parse_set_cookies(char const   *sc , int (*callback)(struct cookie * ,
                                                                           char const   * ,
                                                                           char const   * ,
                                                                           char const   * ,
                                                                           char const   * ) ,
                                        int silent ) 
{ 
  struct cookie *cookie ;
  struct cookie *tmp ;
  enum __anonenum_state_26___0 state ;
  char const   *p ;
  char c ;
  char const   *name_b ;
  char const   *name_e ;
  char const   *value_b ;
  char const   *value_e ;
  int legal ;
  int tmp___0 ;
  char *name ;
  char const   *BTA_beg ;
  int BTA_len ;
  char **BTA_dest ;
  void *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 469
  tmp = cookie_new();
#line 469
  cookie = tmp;
#line 474
  state = (enum __anonenum_state_26___0 )0;
#line 479
  p = sc;
#line 482
  name_b = (char const   *)((void *)0);
#line 482
  name_e = (char const   *)((void *)0);
#line 483
  value_b = (char const   *)((void *)0);
#line 483
  value_e = (char const   *)((void *)0);
#line 485
  c = (char )*p;
  }
  {
#line 487
  while (1) {
    while_continue: /* CIL Label */ ;
#line 487
    if ((unsigned int )state != 8U) {
#line 487
      if (! ((unsigned int )state != 9U)) {
#line 487
        goto while_break;
      }
    } else {
#line 487
      goto while_break;
    }
    {
#line 491
    if ((unsigned int )state == 0U) {
#line 491
      goto case_0;
    }
#line 506
    if ((unsigned int )state == 1U) {
#line 506
      goto case_1;
    }
#line 517
    if ((unsigned int )state == 2U) {
#line 517
      goto case_2;
    }
#line 536
    if ((unsigned int )state == 3U) {
#line 536
      goto case_3;
    }
#line 559
    if ((unsigned int )state == 4U) {
#line 559
      goto case_4;
    }
#line 571
    if ((unsigned int )state == 5U) {
#line 571
      goto case_5;
    }
#line 583
    if ((unsigned int )state == 6U) {
#line 583
      goto case_6;
    }
#line 596
    if ((unsigned int )state == 7U) {
#line 596
      goto case_7;
    }
#line 615
    if ((unsigned int )state == 9U) {
#line 615
      goto case_9;
    }
#line 615
    if ((unsigned int )state == 8U) {
#line 615
      goto case_9;
    }
#line 489
    goto switch_break;
    case_0: /* CIL Label */ 
#line 492
    if (! c) {
#line 493
      state = (enum __anonenum_state_26___0 )8;
    } else
#line 494
    if ((int const   )_sch_istable[(int )c & 255] & 64) {
#line 496
      p ++;
#line 496
      c = (char )*p;
    } else
#line 497
    if ((int )c > 32) {
#line 497
      if ((int )c < 127) {
#line 497
        if ((int )c != 34) {
#line 497
          if ((int )c != 61) {
#line 497
            if ((int )c != 59) {
#line 497
              if ((int )c != 44) {
#line 499
                name_b = p;
#line 500
                state = (enum __anonenum_state_26___0 )1;
              } else {
#line 504
                state = (enum __anonenum_state_26___0 )9;
              }
            } else {
#line 504
              state = (enum __anonenum_state_26___0 )9;
            }
          } else {
#line 504
            state = (enum __anonenum_state_26___0 )9;
          }
        } else {
#line 504
          state = (enum __anonenum_state_26___0 )9;
        }
      } else {
#line 504
        state = (enum __anonenum_state_26___0 )9;
      }
    } else {
#line 504
      state = (enum __anonenum_state_26___0 )9;
    }
#line 505
    goto switch_break;
    case_1: /* CIL Label */ 
#line 507
    if (! c) {
#line 509
      name_e = p;
#line 510
      state = (enum __anonenum_state_26___0 )2;
    } else
#line 507
    if ((int )c == 59) {
#line 509
      name_e = p;
#line 510
      state = (enum __anonenum_state_26___0 )2;
    } else
#line 507
    if ((int )c == 61) {
#line 509
      name_e = p;
#line 510
      state = (enum __anonenum_state_26___0 )2;
    } else
#line 507
    if ((int const   )_sch_istable[(int )c & 255] & 64) {
#line 509
      name_e = p;
#line 510
      state = (enum __anonenum_state_26___0 )2;
    } else
#line 512
    if ((int )c > 32) {
#line 512
      if ((int )c < 127) {
#line 512
        if ((int )c != 34) {
#line 512
          if ((int )c != 61) {
#line 512
            if ((int )c != 59) {
#line 512
              if ((int )c != 44) {
#line 513
                p ++;
#line 513
                c = (char )*p;
              } else {
#line 515
                state = (enum __anonenum_state_26___0 )9;
              }
            } else {
#line 515
              state = (enum __anonenum_state_26___0 )9;
            }
          } else {
#line 515
            state = (enum __anonenum_state_26___0 )9;
          }
        } else {
#line 515
          state = (enum __anonenum_state_26___0 )9;
        }
      } else {
#line 515
        state = (enum __anonenum_state_26___0 )9;
      }
    } else {
#line 515
      state = (enum __anonenum_state_26___0 )9;
    }
#line 516
    goto switch_break;
    case_2: /* CIL Label */ 
#line 518
    if (! c) {
#line 518
      goto _L;
    } else
#line 518
    if ((int )c == 59) {
      _L: /* CIL Label */ 
#line 520
      value_e = (char const   *)((void *)0);
#line 520
      value_b = value_e;
#line 521
      if ((int )c == 59) {
#line 522
        p ++;
#line 522
        c = (char )*p;
      }
#line 523
      state = (enum __anonenum_state_26___0 )7;
    } else
#line 525
    if ((int )c == 61) {
#line 527
      p ++;
#line 527
      c = (char )*p;
#line 528
      state = (enum __anonenum_state_26___0 )3;
    } else
#line 530
    if ((int const   )_sch_istable[(int )c & 255] & 64) {
#line 532
      p ++;
#line 532
      c = (char )*p;
    } else {
#line 534
      state = (enum __anonenum_state_26___0 )9;
    }
#line 535
    goto switch_break;
    case_3: /* CIL Label */ 
#line 537
    if (! c) {
#line 537
      goto _L___0;
    } else
#line 537
    if ((int )c == 59) {
      _L___0: /* CIL Label */ 
#line 539
      value_e = p;
#line 539
      value_b = value_e;
#line 540
      if ((int )c == 59) {
#line 541
        p ++;
#line 541
        c = (char )*p;
      }
#line 542
      state = (enum __anonenum_state_26___0 )7;
    } else
#line 544
    if ((int )c == 34) {
#line 546
      p ++;
#line 546
      c = (char )*p;
#line 547
      value_b = p;
#line 548
      state = (enum __anonenum_state_26___0 )5;
    } else
#line 550
    if ((int const   )_sch_istable[(int )c & 255] & 64) {
#line 551
      p ++;
#line 551
      c = (char )*p;
    } else {
#line 554
      value_b = p;
#line 555
      value_e = (char const   *)((void *)0);
#line 556
      state = (enum __anonenum_state_26___0 )4;
    }
#line 558
    goto switch_break;
    case_4: /* CIL Label */ 
#line 560
    if (! c) {
#line 562
      value_e = p;
#line 563
      state = (enum __anonenum_state_26___0 )6;
    } else
#line 560
    if ((int )c == 59) {
#line 562
      value_e = p;
#line 563
      state = (enum __anonenum_state_26___0 )6;
    } else
#line 560
    if ((int const   )_sch_istable[(int )c & 255] & 64) {
#line 562
      value_e = p;
#line 563
      state = (enum __anonenum_state_26___0 )6;
    } else {
#line 567
      value_e = (char const   *)((void *)0);
#line 568
      p ++;
#line 568
      c = (char )*p;
    }
#line 570
    goto switch_break;
    case_5: /* CIL Label */ 
#line 572
    if ((int )c == 34) {
#line 574
      value_e = p;
#line 575
      p ++;
#line 575
      c = (char )*p;
#line 576
      state = (enum __anonenum_state_26___0 )6;
    } else
#line 578
    if (! c) {
#line 579
      state = (enum __anonenum_state_26___0 )9;
    } else {
#line 581
      p ++;
#line 581
      c = (char )*p;
    }
#line 582
    goto switch_break;
    case_6: /* CIL Label */ 
#line 584
    if ((int )c == 59) {
#line 586
      p ++;
#line 586
      c = (char )*p;
#line 587
      state = (enum __anonenum_state_26___0 )7;
    } else
#line 589
    if (! c) {
#line 590
      state = (enum __anonenum_state_26___0 )7;
    } else
#line 591
    if ((int const   )_sch_istable[(int )c & 255] & 64) {
#line 592
      p ++;
#line 592
      c = (char )*p;
    } else {
#line 594
      state = (enum __anonenum_state_26___0 )4;
    }
#line 595
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 598
    tmp___0 = (*callback)(cookie, name_b, name_e, value_b, value_e);
#line 598
    legal = tmp___0;
    }
#line 599
    if (! legal) {
#line 601
      if (! silent) {
        {
#line 604
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 604
          BTA_beg = name_b;
#line 604
          BTA_len = (int )(name_e - BTA_beg);
#line 604
          BTA_dest = & name;
#line 604
          tmp___1 = __builtin_alloca((unsigned long )(BTA_len + 1));
#line 604
          *BTA_dest = (char *)tmp___1;
#line 604
          memcpy((void */* __restrict  */)*BTA_dest, (void const   */* __restrict  */)BTA_beg,
                 (size_t )BTA_len);
#line 604
          *(*BTA_dest + BTA_len) = (char )'\000';
          }
#line 604
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 605
        tmp___2 = gettext("Error in Set-Cookie, field `%s\'");
#line 605
        logprintf((enum log_options )1, (char const   *)tmp___2, name);
        }
      }
#line 608
      state = (enum __anonenum_state_26___0 )9;
#line 609
      goto switch_break;
    }
#line 611
    state = (enum __anonenum_state_26___0 )0;
#line 613
    goto switch_break;
    case_9: /* CIL Label */ 
    case_8: /* CIL Label */ 
#line 617
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 620
  if ((unsigned int )state == 8U) {
#line 621
    return (cookie);
  }
  {
#line 623
  delete_cookie(cookie);
  }
#line 624
  if ((unsigned int )state != 9U) {
    {
#line 625
    abort();
    }
  }
#line 627
  if (! silent) {
    {
#line 628
    tmp___3 = gettext("Syntax error in Set-Cookie: %s at position %d.\n");
#line 628
    logprintf((enum log_options )1, (char const   *)tmp___3, sc, p - sc);
    }
  }
#line 631
  return ((struct cookie *)((void *)0));
}
}
#line 657 "cookies.c"
static int numeric_address_p(char const   *addr___0 ) 
{ 
  char const   *p ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 660
  p = addr___0;
  {
#line 662
  while (1) {
    while_continue: /* CIL Label */ ;
#line 662
    if (! ((int const   )_sch_istable[(int const   )*p & 255] & 4)) {
#line 662
      return (0);
    }
#line 662
    p ++;
    {
#line 662
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 662
      if (! ((int const   )_sch_istable[(int const   )*p & 255] & 4)) {
#line 662
        goto while_break___0;
      }
#line 662
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 662
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 663
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 663
    tmp = p;
#line 663
    p ++;
#line 663
    if ((int const   )*tmp != 46) {
#line 663
      return (0);
    }
#line 663
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 664
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 664
    if (! ((int const   )_sch_istable[(int const   )*p & 255] & 4)) {
#line 664
      return (0);
    }
#line 664
    p ++;
    {
#line 664
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 664
      if (! ((int const   )_sch_istable[(int const   )*p & 255] & 4)) {
#line 664
        goto while_break___3;
      }
#line 664
      p ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 664
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 665
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 665
    tmp___0 = p;
#line 665
    p ++;
#line 665
    if ((int const   )*tmp___0 != 46) {
#line 665
      return (0);
    }
#line 665
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 666
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 666
    if (! ((int const   )_sch_istable[(int const   )*p & 255] & 4)) {
#line 666
      return (0);
    }
#line 666
    p ++;
    {
#line 666
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 666
      if (! ((int const   )_sch_istable[(int const   )*p & 255] & 4)) {
#line 666
        goto while_break___6;
      }
#line 666
      p ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 666
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 667
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 667
    tmp___1 = p;
#line 667
    p ++;
#line 667
    if ((int const   )*tmp___1 != 46) {
#line 667
      return (0);
    }
#line 667
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 668
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 668
    if (! ((int const   )_sch_istable[(int const   )*p & 255] & 4)) {
#line 668
      return (0);
    }
#line 668
    p ++;
    {
#line 668
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 668
      if (! ((int const   )_sch_istable[(int const   )*p & 255] & 4)) {
#line 668
        goto while_break___9;
      }
#line 668
      p ++;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 668
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 670
  if ((int const   )*p != 0) {
#line 671
    return (0);
  }
#line 672
  return (1);
}
}
#line 773
static int check_domain_match(char const   *cookie_domain , char const   *host ) ;
#line 773 "cookies.c"
static char *known_toplevel_domains[7]  = {      (char *)".com",      (char *)".edu",      (char *)".net",      (char *)".org", 
        (char *)".gov",      (char *)".mil",      (char *)".int"};
#line 680 "cookies.c"
static int check_domain_match(char const   *cookie_domain , char const   *host ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *p ;
  int dccount ;
  int ldcl ;
  int nldcl ;
  int out ;
  int i ;
  int known_toplevel ;
  int tmp___3 ;
  int dlen ;
  size_t tmp___4 ;
  int hlen ;
  size_t tmp___5 ;

  {
  {
#line 683
  while (1) {
    while_continue: /* CIL Label */ ;
#line 683
    if (opt.debug) {
      {
#line 683
      debug_logprintf("cdm: 1");
      }
    }
#line 683
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 687
  tmp___0 = numeric_address_p(cookie_domain);
  }
#line 687
  if (tmp___0) {
    {
#line 688
    tmp = strcmp(cookie_domain, host);
    }
#line 688
    return (0 == tmp);
  }
  {
#line 690
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 690
    if (opt.debug) {
      {
#line 690
      debug_logprintf(" 2");
      }
    }
#line 690
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 693
  tmp___1 = strcasecmp(cookie_domain, host);
  }
#line 693
  if (0 == tmp___1) {
#line 694
    return (1);
  }
  {
#line 696
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 696
    if (opt.debug) {
      {
#line 696
      debug_logprintf(" 3");
      }
    }
#line 696
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 699
  tmp___2 = match_tail(host, cookie_domain, 1);
  }
#line 699
  if (! tmp___2) {
#line 700
    return (0);
  }
#line 728
  p = cookie_domain;
#line 729
  dccount = 1;
#line 730
  ldcl = 0;
#line 731
  nldcl = 0;
#line 733
  if ((int const   )*p == 46) {
#line 735
    p ++;
  }
  {
#line 736
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 736
    if (opt.debug) {
      {
#line 736
      debug_logprintf(" 4");
      }
    }
#line 736
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 737
  out = 0;
  {
#line 737
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 737
    if (! (! out)) {
#line 737
      goto while_break___3;
    }
    {
#line 740
    if ((int const   )*p == 0) {
#line 740
      goto case_0;
    }
#line 743
    if ((int const   )*p == 46) {
#line 743
      goto case_46;
    }
#line 758
    goto switch_default;
    case_0: /* CIL Label */ 
#line 741
    out = 1;
#line 742
    goto switch_break;
    case_46: /* CIL Label */ 
#line 744
    if (ldcl == 0) {
#line 746
      return (0);
    }
#line 747
    if ((int const   )*(p + 1) == 0) {
#line 751
      out = 1;
#line 752
      goto switch_break;
    }
#line 754
    nldcl = ldcl;
#line 755
    ldcl = 0;
#line 756
    dccount ++;
#line 757
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 759
    ldcl ++;
    switch_break: /* CIL Label */ ;
    }
#line 737
    p ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 762
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 762
    if (opt.debug) {
      {
#line 762
      debug_logprintf(" 5");
      }
    }
#line 762
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 764
  if (dccount < 2) {
#line 765
    return (0);
  }
  {
#line 767
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 767
    if (opt.debug) {
      {
#line 767
      debug_logprintf(" 6");
      }
    }
#line 767
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 769
  if (dccount == 2) {
#line 772
    known_toplevel = 0;
#line 776
    i = 0;
    {
#line 776
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 776
      if (! ((unsigned long )i < sizeof(known_toplevel_domains) / sizeof(known_toplevel_domains[0]))) {
#line 776
        goto while_break___6;
      }
      {
#line 777
      tmp___3 = match_tail(cookie_domain, (char const   *)known_toplevel_domains[i],
                           1);
      }
#line 777
      if (tmp___3) {
#line 779
        known_toplevel = 1;
#line 780
        goto while_break___6;
      }
#line 776
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 782
    if (! known_toplevel) {
#line 782
      if (nldcl <= 3) {
#line 783
        return (0);
      }
    }
  }
  {
#line 787
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 787
    if (opt.debug) {
      {
#line 787
      debug_logprintf(" 7");
      }
    }
#line 787
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 791
  if ((int const   )*cookie_domain != 46) {
    {
#line 793
    tmp___4 = strlen(cookie_domain);
#line 793
    dlen = (int )tmp___4;
#line 794
    tmp___5 = strlen(host);
#line 794
    hlen = (int )tmp___5;
    }
#line 798
    if (hlen > dlen) {
#line 798
      if ((int const   )*(host + ((hlen - dlen) - 1)) != 46) {
#line 799
        return (0);
      }
    }
  }
  {
#line 802
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 802
    if (opt.debug) {
      {
#line 802
      debug_logprintf(" 8");
      }
    }
#line 802
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 804
  return (1);
}
}
#line 807
static int path_matches(char const   *full_path , char const   *prefix ) ;
#line 811 "cookies.c"
static int check_path_match(char const   *cookie_path , char const   *path ) 
{ 
  int tmp ;

  {
  {
#line 814
  tmp = path_matches(path, cookie_path);
  }
#line 814
  return (tmp);
}
}
#line 821 "cookies.c"
void cookie_jar_process_set_cookie(struct cookie_jar *jar , char const   *host , int port ,
                                   char const   *path , char const   *set_cookie ) 
{ 
  struct cookie *cookie ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 827
  cookies_now = time((time_t *)((void *)0));
#line 829
  cookie = parse_set_cookies(set_cookie, & update_cookie_field, 0);
  }
#line 830
  if (! cookie) {
#line 831
    goto out;
  }
#line 835
  if (! cookie->domain) {
    copy_domain: 
    {
#line 838
    cookie->domain = xstrdup_real(host);
#line 839
    cookie->port = port;
    }
  } else {
    {
#line 843
    tmp = check_domain_match((char const   *)cookie->domain, host);
    }
#line 843
    if (! tmp) {
      {
#line 845
      logprintf((enum log_options )1, "Cookie coming from %s attempted to set domain to %s\n",
                host, cookie->domain);
#line 848
      free((void *)cookie->domain);
      }
#line 849
      goto copy_domain;
    }
  }
#line 853
  if (! cookie->path) {
    {
#line 854
    cookie->path = xstrdup_real(path);
    }
  } else {
    {
#line 857
    tmp___0 = check_path_match((char const   *)cookie->path, path);
    }
#line 857
    if (! tmp___0) {
      {
#line 859
      while (1) {
        while_continue: /* CIL Label */ ;
#line 859
        if (opt.debug) {
          {
#line 859
          debug_logprintf("Attempt to fake the path: %s, %s\n", cookie->path, path);
          }
        }
#line 859
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 861
      goto out;
    }
  }
#line 865
  if (cookie->discard_requested) {
    {
#line 867
    discard_matching_cookie(jar, cookie);
    }
#line 868
    goto out;
  }
  {
#line 871
  store_cookie(jar, cookie);
  }
#line 872
  return;
  out: 
#line 875
  if (cookie) {
    {
#line 876
    delete_cookie(cookie);
    }
  }
#line 877
  return;
}
}
#line 895 "cookies.c"
static int find_chains_of_host(struct cookie_jar *jar , char const   *host , struct cookie **dest ) 
{ 
  int dest_count ;
  int passes ;
  int passcnt ;
  int tmp ;
  int tmp___0 ;
  struct cookie *chain ;
  void *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 899
  dest_count = 0;
#line 903
  tmp = hash_table_count((struct hash_table  const  *)jar->chains);
  }
#line 903
  if (! tmp) {
#line 904
    return (0);
  }
  {
#line 906
  tmp___0 = numeric_address_p(host);
  }
#line 906
  if (tmp___0) {
#line 908
    passes = 1;
  } else {
    {
#line 913
    passes = count_char(host, (char )'.');
    }
  }
#line 915
  passcnt = 0;
  {
#line 921
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 923
    tmp___1 = hash_table_get((struct hash_table  const  *)jar->chains, (void const   *)host);
#line 923
    chain = (struct cookie *)tmp___1;
    }
#line 924
    if (chain) {
#line 925
      tmp___2 = dest_count;
#line 925
      dest_count ++;
#line 925
      *(dest + tmp___2) = chain;
    }
#line 926
    passcnt ++;
#line 926
    if (passcnt >= passes) {
#line 927
      goto while_break;
    }
    {
#line 928
    tmp___3 = strchr(host, '.');
#line 928
    host = (char const   *)(tmp___3 + 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 931
  return (dest_count);
}
}
#line 937 "cookies.c"
static int path_matches(char const   *full_path , char const   *prefix ) 
{ 
  int len ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 942
  if ((int const   )*prefix != 47) {
#line 946
    return (0);
  }
  {
#line 948
  prefix ++;
#line 949
  tmp = strlen(prefix);
#line 949
  len = (int )tmp;
#line 951
  tmp___0 = strncmp(full_path, prefix, (size_t )len);
  }
#line 951
  if (0 != tmp___0) {
#line 953
    return (0);
  }
#line 956
  return (len + 1);
}
}
#line 966 "cookies.c"
static int cookie_matches_url(struct cookie  const  *cookie , char const   *host ,
                              int port , char const   *path , int secflag , int *path_goodness ) 
{ 
  int pg ;
  int tmp ;

  {
#line 973
  if (cookie->expiry_time != 0L) {
#line 973
    if (cookie->expiry_time < (time_t const   )cookies_now) {
#line 979
      return (0);
    }
  }
#line 981
  if (cookie->secure) {
#line 981
    if (! secflag) {
#line 983
      return (0);
    }
  }
#line 984
  if (cookie->port != -1) {
#line 984
    if (cookie->port != (int const   )port) {
#line 985
      return (0);
    }
  }
#line 990
  if (cookie->domain_exact) {
    {
#line 990
    tmp = strcasecmp(host, (char const   *)cookie->domain);
    }
#line 990
    if (0 != tmp) {
#line 992
      return (0);
    }
  }
  {
#line 994
  pg = path_matches(path, (char const   *)cookie->path);
  }
#line 995
  if (! pg) {
#line 996
    return (0);
  }
#line 998
  if (path_goodness) {
#line 1002
    *path_goodness = pg;
  }
#line 1003
  return (1);
}
}
#line 1019 "cookies.c"
static int equality_comparator(void const   *p1 , void const   *p2 ) 
{ 
  struct weighed_cookie *wc1 ;
  struct weighed_cookie *wc2 ;
  int namecmp ;
  int tmp ;
  int valuecmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1022
  wc1 = (struct weighed_cookie *)p1;
#line 1023
  wc2 = (struct weighed_cookie *)p2;
#line 1025
  tmp = strcmp((char const   *)(wc1->cookie)->attr, (char const   *)(wc2->cookie)->attr);
#line 1025
  namecmp = tmp;
#line 1026
  tmp___0 = strcmp((char const   *)(wc1->cookie)->value, (char const   *)(wc2->cookie)->value);
#line 1026
  valuecmp = tmp___0;
  }
#line 1030
  if (namecmp) {
#line 1030
    tmp___1 = namecmp;
  } else {
#line 1030
    tmp___1 = valuecmp;
  }
#line 1030
  return (tmp___1);
}
}
#line 1037 "cookies.c"
static int eliminate_dups(struct weighed_cookie *outgoing , int count ) 
{ 
  struct weighed_cookie *h ;
  struct weighed_cookie *t ;
  struct weighed_cookie *end ;
  struct cookie *c0 ;
  struct cookie *c1 ;
  int tmp ;
  int tmp___0 ;
  struct weighed_cookie *tmp___1 ;

  {
  {
#line 1042
  end = outgoing + count;
#line 1048
  qsort((void *)outgoing, (size_t )count, (size_t )sizeof(struct weighed_cookie ),
        & equality_comparator);
#line 1054
  t = outgoing;
#line 1054
  h = t;
  }
  {
#line 1054
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1054
    if (! ((unsigned long )h < (unsigned long )end)) {
#line 1054
      goto while_break;
    }
#line 1056
    if ((unsigned long )h != (unsigned long )(end - 1)) {
      {
#line 1058
      c0 = (h + 0)->cookie;
#line 1059
      c1 = (h + 1)->cookie;
#line 1060
      tmp = strcmp((char const   *)c0->attr, (char const   *)c1->attr);
      }
#line 1060
      if (! tmp) {
        {
#line 1060
        tmp___0 = strcmp((char const   *)c0->value, (char const   *)c1->value);
        }
#line 1060
        if (! tmp___0) {
#line 1061
          goto __Cont;
        }
      }
    }
#line 1067
    if ((unsigned long )h != (unsigned long )t) {
#line 1068
      tmp___1 = t;
#line 1068
      t ++;
#line 1068
      *tmp___1 = *h;
    } else {
#line 1070
      t ++;
    }
    __Cont: /* CIL Label */ 
#line 1054
    h ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1072
  return ((int )(t - outgoing));
}
}
#line 1077 "cookies.c"
static int goodness_comparator(void const   *p1 , void const   *p2 ) 
{ 
  struct weighed_cookie *wc1 ;
  struct weighed_cookie *wc2 ;
  int dgdiff ;
  int pgdiff ;
  int tmp ;

  {
#line 1080
  wc1 = (struct weighed_cookie *)p1;
#line 1081
  wc2 = (struct weighed_cookie *)p2;
#line 1085
  dgdiff = wc2->domain_goodness - wc1->domain_goodness;
#line 1086
  pgdiff = wc2->path_goodness - wc1->path_goodness;
#line 1091
  if (dgdiff) {
#line 1091
    tmp = dgdiff;
  } else {
#line 1091
    tmp = pgdiff;
  }
#line 1091
  return (tmp);
}
}
#line 1100 "cookies.c"
char *cookie_jar_generate_cookie_header(struct cookie_jar *jar , char const   *host ,
                                        int port , char const   *path , int connection_secure_p ) 
{ 
  struct cookie **chains ;
  int chain_count ;
  struct cookie *cookie ;
  struct weighed_cookie *outgoing ;
  int count ;
  int i ;
  int ocnt ;
  char *result ;
  int result_size ;
  int pos ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int pg ;
  int tmp___3 ;
  size_t tmp___4 ;
  long tmp___5 ;
  struct cookie *c ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  struct cookie *c___0 ;
  int namlen ;
  size_t tmp___9 ;
  int vallen ;
  size_t tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  long tmp___17 ;

  {
  {
#line 1119
  tmp = count_char(host, (char )'.');
#line 1119
  tmp___0 = __builtin_alloca((unsigned long )(1 + tmp) * sizeof(struct cookie *));
#line 1119
  chains = (struct cookie **)tmp___0;
#line 1120
  chain_count = find_chains_of_host(jar, host, chains);
  }
#line 1123
  if (! chain_count) {
#line 1124
    return ((char *)((void *)0));
  }
  {
#line 1126
  cookies_now = time((time_t *)((void *)0));
#line 1133
  count = 0;
#line 1134
  i = 0;
  }
  {
#line 1134
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1134
    if (! (i < chain_count)) {
#line 1134
      goto while_break;
    }
#line 1135
    cookie = *(chains + i);
    {
#line 1135
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1135
      if (! cookie) {
#line 1135
        goto while_break___0;
      }
      {
#line 1136
      tmp___1 = cookie_matches_url((struct cookie  const  *)cookie, host, port, path,
                                   connection_secure_p, (int *)((void *)0));
      }
#line 1136
      if (tmp___1) {
#line 1138
        count ++;
      }
#line 1135
      cookie = cookie->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1134
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1139
  if (! count) {
#line 1140
    return ((char *)((void *)0));
  }
  {
#line 1143
  tmp___2 = __builtin_alloca((unsigned long )count * sizeof(struct weighed_cookie ));
#line 1143
  outgoing = (struct weighed_cookie *)tmp___2;
#line 1147
  ocnt = 0;
#line 1148
  i = 0;
  }
  {
#line 1148
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1148
    if (! (i < chain_count)) {
#line 1148
      goto while_break___1;
    }
#line 1149
    cookie = *(chains + i);
    {
#line 1149
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1149
      if (! cookie) {
#line 1149
        goto while_break___2;
      }
      {
#line 1152
      tmp___3 = cookie_matches_url((struct cookie  const  *)cookie, host, port, path,
                                   connection_secure_p, & pg);
      }
#line 1152
      if (! tmp___3) {
#line 1154
        goto __Cont;
      }
      {
#line 1155
      (outgoing + ocnt)->cookie = cookie;
#line 1156
      tmp___4 = strlen((char const   *)cookie->domain);
#line 1156
      (outgoing + ocnt)->domain_goodness = (int )tmp___4;
#line 1157
      (outgoing + ocnt)->path_goodness = pg;
#line 1158
      ocnt ++;
      }
      __Cont: /* CIL Label */ 
#line 1149
      cookie = cookie->next;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1148
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1160
  tmp___5 = __builtin_expect((long )(! (! (ocnt == count))), 1L);
  }
#line 1160
  if (! tmp___5) {
    {
#line 1160
    __assert_fail("ocnt == count", "cookies.c", 1160U, "cookie_jar_generate_cookie_header");
    }
  }
  {
#line 1164
  count = eliminate_dups(outgoing, count);
#line 1168
  qsort((void *)outgoing, (size_t )count, (size_t )sizeof(struct weighed_cookie ),
        & goodness_comparator);
#line 1171
  result_size = 0;
#line 1172
  i = 0;
  }
  {
#line 1172
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1172
    if (! (i < count)) {
#line 1172
      goto while_break___3;
    }
    {
#line 1174
    c = (outgoing + i)->cookie;
#line 1176
    tmp___6 = strlen((char const   *)c->attr);
#line 1176
    tmp___7 = strlen((char const   *)c->value);
#line 1176
    result_size = (int )((size_t )result_size + ((tmp___6 + 1U) + tmp___7));
#line 1172
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 1185
  result_size = (((8 + result_size) + (count - 1) * 2) + 2) + 1;
#line 1186
  tmp___8 = xmalloc_real((size_t )result_size);
#line 1186
  result = (char *)tmp___8;
#line 1187
  pos = 0;
#line 1188
  strcpy((char */* __restrict  */)result, (char const   */* __restrict  */)"Cookie: ");
#line 1189
  pos += 8;
#line 1190
  i = 0;
  }
  {
#line 1190
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1190
    if (! (i < count)) {
#line 1190
      goto while_break___4;
    }
    {
#line 1192
    c___0 = (outgoing + i)->cookie;
#line 1193
    tmp___9 = strlen((char const   *)c___0->attr);
#line 1193
    namlen = (int )tmp___9;
#line 1194
    tmp___10 = strlen((char const   *)c___0->value);
#line 1194
    vallen = (int )tmp___10;
#line 1196
    memcpy((void */* __restrict  */)(result + pos), (void const   */* __restrict  */)c___0->attr,
           (size_t )namlen);
#line 1197
    pos += namlen;
#line 1198
    tmp___11 = pos;
#line 1198
    pos ++;
#line 1198
    *(result + tmp___11) = (char )'=';
#line 1199
    memcpy((void */* __restrict  */)(result + pos), (void const   */* __restrict  */)c___0->value,
           (size_t )vallen);
#line 1200
    pos += vallen;
    }
#line 1201
    if (i < count - 1) {
#line 1203
      tmp___12 = pos;
#line 1203
      pos ++;
#line 1203
      *(result + tmp___12) = (char )';';
#line 1204
      tmp___13 = pos;
#line 1204
      pos ++;
#line 1204
      *(result + tmp___13) = (char )' ';
    }
#line 1190
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 1207
  tmp___14 = pos;
#line 1207
  pos ++;
#line 1207
  *(result + tmp___14) = (char )'\r';
#line 1208
  tmp___15 = pos;
#line 1208
  pos ++;
#line 1208
  *(result + tmp___15) = (char )'\n';
#line 1209
  tmp___16 = pos;
#line 1209
  pos ++;
#line 1209
  *(result + tmp___16) = (char )'\000';
#line 1210
  tmp___17 = __builtin_expect((long )(! (! (pos == result_size))), 1L);
  }
#line 1210
  if (! tmp___17) {
    {
#line 1210
    __assert_fail("pos == result_size", "cookies.c", 1210U, "cookie_jar_generate_cookie_header");
    }
  }
#line 1211
  return (result);
}
}
#line 1247 "cookies.c"
static int domain_port(char const   *domain_b , char const   *domain_e , char const   **domain_e_ptr ) 
{ 
  int port ;
  char const   *p ;
  char const   *colon ;
  void *tmp ;

  {
  {
#line 1251
  port = 0;
#line 1253
  tmp = memchr((void const   *)domain_b, ':', (size_t )(domain_e - domain_b));
#line 1253
  colon = (char const   *)tmp;
  }
#line 1254
  if (! colon) {
#line 1255
    return (0);
  }
#line 1256
  p = colon + 1;
  {
#line 1256
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1256
    if ((unsigned long )p < (unsigned long )domain_e) {
#line 1256
      if (! ((int const   )_sch_istable[(int const   )*p & 255] & 4)) {
#line 1256
        goto while_break;
      }
    } else {
#line 1256
      goto while_break;
    }
#line 1257
    port = 10 * port + (int )((int const   )*p - 48);
#line 1256
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1258
  if ((unsigned long )p < (unsigned long )domain_e) {
#line 1260
    return (0);
  }
#line 1261
  *domain_e_ptr = colon;
#line 1262
  return (port);
}
}
#line 1277 "cookies.c"
void cookie_jar_load(struct cookie_jar *jar , char const   *file ) 
{ 
  char *line ;
  FILE *fp ;
  FILE *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  struct cookie *cookie ;
  char *p ;
  double expiry ;
  int port ;
  char *domain_b ;
  char *domain_e ;
  char *domflag_b ;
  char *domflag_e ;
  char *path_b ;
  char *path_e ;
  char *secure_b ;
  char *secure_e ;
  char *expires_b ;
  char *expires_e ;
  char *name_b ;
  char *name_e ;
  char *value_b ;
  char *value_e ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 1281
  tmp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"r");
#line 1281
  fp = tmp;
  }
#line 1282
  if (! fp) {
    {
#line 1284
    tmp___0 = __errno_location();
#line 1284
    tmp___1 = strerror(*tmp___0);
#line 1284
    logprintf((enum log_options )1, "Cannot open cookies file `%s\': %s\n", file,
              tmp___1);
    }
#line 1286
    return;
  }
  {
#line 1288
  cookies_now = time((time_t *)((void *)0));
  }
  {
#line 1290
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1290
    line = read_whole_line(fp);
    }
#line 1290
    if (! ((unsigned long )line != (unsigned long )((void *)0))) {
#line 1290
      goto while_break;
    }
#line 1293
    p = line;
#line 1298
    domain_b = (char *)((void *)0);
#line 1298
    domain_e = (char *)((void *)0);
#line 1299
    domflag_b = (char *)((void *)0);
#line 1299
    domflag_e = (char *)((void *)0);
#line 1300
    path_b = (char *)((void *)0);
#line 1300
    path_e = (char *)((void *)0);
#line 1301
    secure_b = (char *)((void *)0);
#line 1301
    secure_e = (char *)((void *)0);
#line 1302
    expires_b = (char *)((void *)0);
#line 1302
    expires_e = (char *)((void *)0);
#line 1303
    name_b = (char *)((void *)0);
#line 1303
    name_e = (char *)((void *)0);
#line 1304
    value_b = (char *)((void *)0);
#line 1304
    value_e = (char *)((void *)0);
    {
#line 1307
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1307
      if (*p) {
#line 1307
        if (! ((int const   )_sch_istable[(int )*p & 255] & 64)) {
#line 1307
          goto while_break___0;
        }
      } else {
#line 1307
        goto while_break___0;
      }
#line 1308
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1310
    if (! *p) {
#line 1311
      goto __Cont;
    } else
#line 1310
    if ((int )*p == 35) {
#line 1311
      goto __Cont;
    }
    {
#line 1313
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1313
      domain_b = p;
      {
#line 1313
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1313
        if (*p) {
#line 1313
          if (! ((int )*p != 9)) {
#line 1313
            goto while_break___2;
          }
        } else {
#line 1313
          goto while_break___2;
        }
#line 1313
        p ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1313
      domain_e = p;
#line 1313
      if ((unsigned long )domain_b == (unsigned long )domain_e) {
#line 1313
        goto next;
      } else
#line 1313
      if (! *p) {
#line 1313
        goto next;
      }
#line 1313
      p ++;
#line 1313
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1314
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1314
      domflag_b = p;
      {
#line 1314
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1314
        if (*p) {
#line 1314
          if (! ((int )*p != 9)) {
#line 1314
            goto while_break___4;
          }
        } else {
#line 1314
          goto while_break___4;
        }
#line 1314
        p ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1314
      domflag_e = p;
#line 1314
      if ((unsigned long )domflag_b == (unsigned long )domflag_e) {
#line 1314
        goto next;
      } else
#line 1314
      if (! *p) {
#line 1314
        goto next;
      }
#line 1314
      p ++;
#line 1314
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 1315
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1315
      path_b = p;
      {
#line 1315
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1315
        if (*p) {
#line 1315
          if (! ((int )*p != 9)) {
#line 1315
            goto while_break___6;
          }
        } else {
#line 1315
          goto while_break___6;
        }
#line 1315
        p ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 1315
      path_e = p;
#line 1315
      if ((unsigned long )path_b == (unsigned long )path_e) {
#line 1315
        goto next;
      } else
#line 1315
      if (! *p) {
#line 1315
        goto next;
      }
#line 1315
      p ++;
#line 1315
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 1316
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 1316
      secure_b = p;
      {
#line 1316
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 1316
        if (*p) {
#line 1316
          if (! ((int )*p != 9)) {
#line 1316
            goto while_break___8;
          }
        } else {
#line 1316
          goto while_break___8;
        }
#line 1316
        p ++;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 1316
      secure_e = p;
#line 1316
      if ((unsigned long )secure_b == (unsigned long )secure_e) {
#line 1316
        goto next;
      } else
#line 1316
      if (! *p) {
#line 1316
        goto next;
      }
#line 1316
      p ++;
#line 1316
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 1317
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 1317
      expires_b = p;
      {
#line 1317
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 1317
        if (*p) {
#line 1317
          if (! ((int )*p != 9)) {
#line 1317
            goto while_break___10;
          }
        } else {
#line 1317
          goto while_break___10;
        }
#line 1317
        p ++;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 1317
      expires_e = p;
#line 1317
      if ((unsigned long )expires_b == (unsigned long )expires_e) {
#line 1317
        goto next;
      } else
#line 1317
      if (! *p) {
#line 1317
        goto next;
      }
#line 1317
      p ++;
#line 1317
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
    {
#line 1318
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 1318
      name_b = p;
      {
#line 1318
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 1318
        if (*p) {
#line 1318
          if (! ((int )*p != 9)) {
#line 1318
            goto while_break___12;
          }
        } else {
#line 1318
          goto while_break___12;
        }
#line 1318
        p ++;
      }
      while_break___12: /* CIL Label */ ;
      }
#line 1318
      name_e = p;
#line 1318
      if ((unsigned long )name_b == (unsigned long )name_e) {
#line 1318
        goto next;
      } else
#line 1318
      if (! *p) {
#line 1318
        goto next;
      }
#line 1318
      p ++;
#line 1318
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
    {
#line 1322
    value_b = p;
#line 1323
    tmp___2 = strlen((char const   *)p);
#line 1323
    value_e = p + tmp___2;
    }
#line 1324
    if ((unsigned long )value_e > (unsigned long )value_b) {
#line 1324
      if ((int )*(value_e + -1) == 10) {
#line 1325
        value_e --;
      }
    }
#line 1326
    if ((unsigned long )value_e > (unsigned long )value_b) {
#line 1326
      if ((int )*(value_e + -1) == 13) {
#line 1327
        value_e --;
      }
    }
    {
#line 1330
    cookie = cookie_new();
#line 1332
    cookie->attr = strdupdelim((char const   *)name_b, (char const   *)name_e);
#line 1333
    cookie->value = strdupdelim((char const   *)value_b, (char const   *)value_e);
#line 1334
    cookie->path = strdupdelim((char const   *)path_b, (char const   *)path_e);
    }
#line 1335
    if ((unsigned long )(secure_e - secure_b) == sizeof("TRUE") - 1UL) {
      {
#line 1335
      tmp___3 = memcmp((void const   *)secure_b, (void const   *)"TRUE", (size_t )(sizeof("TRUE") - 1UL));
      }
#line 1335
      if (tmp___3) {
#line 1335
        tmp___4 = 0;
      } else {
#line 1335
        tmp___4 = 1;
      }
    } else {
#line 1335
      tmp___4 = 0;
    }
#line 1335
    cookie->secure = tmp___4;
#line 1341
    if ((unsigned long )(domflag_e - domflag_b) == sizeof("TRUE") - 1UL) {
      {
#line 1341
      tmp___5 = memcmp((void const   *)domflag_b, (void const   *)"TRUE", (size_t )(sizeof("TRUE") - 1UL));
      }
#line 1341
      if (tmp___5) {
#line 1341
        tmp___6 = 1;
      } else {
#line 1341
        tmp___6 = 0;
      }
    } else {
#line 1341
      tmp___6 = 1;
    }
    {
#line 1341
    cookie->domain_exact = tmp___6;
#line 1345
    port = domain_port((char const   *)domain_b, (char const   *)domain_e, (char const   **)(& domain_e));
    }
#line 1346
    if (port) {
#line 1347
      cookie->port = port;
    }
#line 1349
    if ((int )*domain_b == 46) {
#line 1350
      domain_b ++;
    }
    {
#line 1351
    cookie->domain = strdupdelim((char const   *)domain_b, (char const   *)domain_e);
#line 1354
    expiry = (double )cookies_now - (double )1;
#line 1358
    *expires_e = (char )'\000';
#line 1359
    sscanf((char const   */* __restrict  */)expires_b, (char const   */* __restrict  */)"%lf",
           & expiry);
    }
#line 1360
    if (expiry < (double )cookies_now) {
#line 1362
      goto abort;
    }
    {
#line 1363
    cookie->expiry_time = (time_t )expiry;
#line 1367
    cookie->permanent = 1;
#line 1369
    store_cookie(jar, cookie);
    }
    next: 
#line 1372
    goto __Cont;
    abort: 
    {
#line 1375
    delete_cookie(cookie);
    }
    __Cont: /* CIL Label */ 
    {
#line 1290
    free((void *)line);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1377
  fclose(fp);
  }
#line 1378
  return;
}
}
#line 1384 "cookies.c"
static int save_cookies_mapper(void *key , void *value , void *arg ) 
{ 
  FILE *fp ;
  char *domain ;
  struct cookie *cookie ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
#line 1387
  fp = (FILE *)arg;
#line 1388
  domain = (char *)key;
#line 1389
  cookie = (struct cookie *)value;
  {
#line 1390
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1390
    if (! cookie) {
#line 1390
      goto while_break;
    }
#line 1392
    if (! cookie->permanent) {
#line 1393
      goto __Cont;
    }
#line 1394
    if (cookie->expiry_time != 0L) {
#line 1394
      if (cookie->expiry_time < cookies_now) {
#line 1395
        goto __Cont;
      }
    }
#line 1396
    if (! cookie->domain_exact) {
      {
#line 1397
      fputc('.', fp);
      }
    }
    {
#line 1398
    fputs((char const   */* __restrict  */)domain, (FILE */* __restrict  */)fp);
    }
#line 1399
    if (cookie->port != -1) {
      {
#line 1400
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)":%d",
              cookie->port);
      }
    }
#line 1401
    if (cookie->secure) {
#line 1401
      tmp = "TRUE";
    } else {
#line 1401
      tmp = "FALSE";
    }
#line 1401
    if (cookie->domain_exact) {
#line 1401
      tmp___0 = "FALSE";
    } else {
#line 1401
      tmp___0 = "TRUE";
    }
    {
#line 1401
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\t%s\t%s\t%s\t%.0f\t%s\t%s\n",
            tmp___0, cookie->path, tmp, (double )cookie->expiry_time, cookie->attr,
            cookie->value);
#line 1406
    tmp___1 = ferror(fp);
    }
#line 1406
    if (tmp___1) {
#line 1407
      return (1);
    }
    __Cont: /* CIL Label */ 
#line 1390
    cookie = cookie->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1409
  return (0);
}
}
#line 1414 "cookies.c"
void cookie_jar_save(struct cookie_jar *jar , char const   *file ) 
{ 
  FILE *fp ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;

  {
  {
#line 1419
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1419
    if (opt.debug) {
      {
#line 1419
      debug_logprintf("Saving cookies to %s.\n", file);
      }
    }
#line 1419
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1421
  cookies_now = time((time_t *)((void *)0));
#line 1423
  fp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"w");
  }
#line 1424
  if (! fp) {
    {
#line 1426
    tmp = __errno_location();
#line 1426
    tmp___0 = strerror(*tmp);
#line 1426
    tmp___1 = gettext("Cannot open cookies file `%s\': %s\n");
#line 1426
    logprintf((enum log_options )1, (char const   *)tmp___1, file, tmp___0);
    }
#line 1428
    return;
  }
  {
#line 1431
  fputs((char const   */* __restrict  */)"# HTTP cookie file.\n", (FILE */* __restrict  */)fp);
#line 1432
  tmp___2 = datetime_str((time_t *)((void *)0));
#line 1432
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"# Generated by Wget on %s.\n",
          tmp___2);
#line 1433
  fputs((char const   */* __restrict  */)"# Edit at your own risk.\n\n", (FILE */* __restrict  */)fp);
#line 1435
  hash_table_map(jar->chains, & save_cookies_mapper, (void *)fp);
#line 1437
  tmp___6 = ferror(fp);
  }
#line 1437
  if (tmp___6) {
    {
#line 1438
    tmp___3 = __errno_location();
#line 1438
    tmp___4 = strerror(*tmp___3);
#line 1438
    tmp___5 = gettext("Error writing to `%s\': %s\n");
#line 1438
    logprintf((enum log_options )1, (char const   *)tmp___5, file, tmp___4);
    }
  }
  {
#line 1441
  tmp___10 = fclose(fp);
  }
#line 1441
  if (tmp___10 < 0) {
    {
#line 1442
    tmp___7 = __errno_location();
#line 1442
    tmp___8 = strerror(*tmp___7);
#line 1442
    tmp___9 = gettext("Error closing `%s\': %s\n");
#line 1442
    logprintf((enum log_options )1, (char const   *)tmp___9, file, tmp___8);
    }
  }
  {
#line 1445
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1445
    if (opt.debug) {
      {
#line 1445
      debug_logprintf("Done saving cookies.\n");
      }
    }
#line 1445
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1446
  return;
}
}
#line 1453 "cookies.c"
static int nuke_cookie_chain(void *value , void *key , void *arg ) 
{ 
  char *chain_key ;
  struct cookie *chain ;
  struct cookie_jar *jar ;
  struct cookie *next ;

  {
  {
#line 1456
  chain_key = (char *)value;
#line 1457
  chain = (struct cookie *)key;
#line 1458
  jar = (struct cookie_jar *)arg;
#line 1461
  hash_table_remove(jar->chains, (void const   *)chain_key);
#line 1462
  free((void *)chain_key);
  }
  {
#line 1465
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1465
    if (! chain) {
#line 1465
      goto while_break;
    }
    {
#line 1467
    next = chain->next;
#line 1468
    delete_cookie(chain);
#line 1469
    chain = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1473
  return (0);
}
}
#line 1478 "cookies.c"
void cookie_jar_delete(struct cookie_jar *jar ) 
{ 


  {
  {
#line 1481
  hash_table_map(jar->chains, & nuke_cookie_chain, (void *)jar);
#line 1482
  hash_table_destroy(jar->chains);
#line 1483
  free((void *)jar);
  }
#line 1484
  return;
}
}
#line 53 "convert.c"
static struct hash_table *dl_file_url_map  ;
#line 54 "convert.c"
struct hash_table *dl_url_file_map  ;
#line 60 "convert.c"
static slist *downloaded_html_list  ;
#line 61 "convert.c"
struct hash_table *downloaded_html_set  ;
#line 63
static void convert_links(char const   *file , struct urlpos *links ) ;
#line 80 "convert.c"
void convert_all_links(void) 
{ 
  slist *html ;
  long msecs ;
  int file_count ;
  struct wget_timer *timer ;
  struct wget_timer *tmp ;
  struct urlpos *urls ;
  struct urlpos *cur_url ;
  char *url ;
  char *file ;
  void *tmp___0 ;
  char *local_name ;
  struct url *u ;
  void *tmp___1 ;
  double tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 85
  file_count = 0;
#line 87
  tmp = wtimer_new();
#line 87
  timer = tmp;
#line 91
  downloaded_html_list = slist_nreverse(downloaded_html_list);
#line 93
  html = downloaded_html_list;
  }
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
#line 93
    if (! html) {
#line 93
      goto while_break;
    }
    {
#line 97
    file = html->string;
#line 101
    tmp___0 = hash_table_get((struct hash_table  const  *)dl_file_url_map, (void const   *)file);
#line 101
    url = (char *)tmp___0;
    }
#line 102
    if (! url) {
      {
#line 104
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 104
        if (opt.debug) {
          {
#line 104
          debug_logprintf("Apparently %s has been removed.\n", file);
          }
        }
#line 104
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 105
      goto __Cont;
    }
    {
#line 108
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 108
      if (opt.debug) {
        {
#line 108
        debug_logprintf("Scanning %s (from %s)\n", file, url);
        }
      }
#line 108
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 111
    urls = get_urls_html((char const   *)file, (char const   *)url, (int *)((void *)0));
#line 117
    cur_url = urls;
    }
    {
#line 117
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 117
      if (! cur_url) {
#line 117
        goto while_break___2;
      }
#line 120
      u = cur_url->url;
#line 122
      if (cur_url->link_base_p) {
#line 127
        cur_url->convert = (enum convert_options )3;
#line 128
        goto __Cont___0;
      }
      {
#line 134
      tmp___1 = hash_table_get((struct hash_table  const  *)dl_url_file_map, (void const   *)u->url);
#line 134
      local_name = (char *)tmp___1;
      }
#line 137
      if (local_name) {
        {
#line 144
        cur_url->convert = (enum convert_options )1;
#line 145
        cur_url->local_name = xstrdup_real((char const   *)local_name);
        }
        {
#line 146
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 146
          if (opt.debug) {
            {
#line 146
            debug_logprintf("will convert url %s to local %s\n", u->url, local_name);
            }
          }
#line 146
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
      } else {
#line 154
        if (! cur_url->link_complete_p) {
#line 155
          cur_url->convert = (enum convert_options )2;
        }
#line 156
        cur_url->local_name = (char *)((void *)0);
        {
#line 157
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 157
          if (opt.debug) {
            {
#line 157
            debug_logprintf("will convert url %s to complete\n", u->url);
            }
          }
#line 157
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
      __Cont___0: /* CIL Label */ 
#line 117
      cur_url = cur_url->next;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 162
    convert_links((char const   *)file, urls);
#line 163
    file_count ++;
#line 166
    free_urlpos(urls);
    }
    __Cont: /* CIL Label */ 
#line 93
    html = html->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 169
  tmp___2 = wtimer_elapsed(timer);
#line 169
  msecs = (long )tmp___2;
#line 170
  wtimer_delete(timer);
#line 171
  tmp___3 = gettext("Converted %d files in %.2f seconds.\n");
#line 171
  logprintf((enum log_options )0, (char const   *)tmp___3, file_count, (double )msecs / (double )1000);
  }
#line 173
  return;
}
}
#line 175
static void write_backup_file(char const   *file , downloaded_file_t downloaded_file_return ) ;
#line 176
static char const   *replace_attr(char const   *p , int size , FILE *fp , char const   *new_text ) ;
#line 178
static char const   *replace_attr_refresh_hack(char const   *p , int size , FILE *fp ,
                                               char const   *new_text , int timeout ) ;
#line 180
static char *local_quote_string(char const   *file ) ;
#line 181
static char *construct_relative(char const   *s1 , char const   *s2 ) ;
#line 186 "convert.c"
static void convert_links(char const   *file , struct urlpos *links ) 
{ 
  struct file_memory *fm ;
  FILE *fp ;
  char const   *p ;
  downloaded_file_t downloaded_file_return ;
  struct urlpos *link___0 ;
  int to_url_count ;
  int to_file_count ;
  char *tmp ;
  int dry_count ;
  struct urlpos *dry ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *url_start ;
  char *newname ;
  char *tmp___12 ;
  char *quoted_newname ;
  char *tmp___13 ;
  char *newlink ;
  char *quoted_newlink ;
  char *tmp___14 ;

  {
  {
#line 195
  to_url_count = 0;
#line 195
  to_file_count = 0;
#line 197
  tmp = gettext("Converting %s... ");
#line 197
  logprintf((enum log_options )0, (char const   *)tmp, file);
#line 203
  dry_count = 0;
#line 204
  dry = links;
#line 205
  dry = links;
  }
  {
#line 205
  while (1) {
    while_continue: /* CIL Label */ ;
#line 205
    if (! dry) {
#line 205
      goto while_break;
    }
#line 206
    if ((unsigned int )dry->convert != 0U) {
#line 207
      dry_count ++;
    }
#line 205
    dry = dry->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 208
  if (! dry_count) {
    {
#line 210
    tmp___0 = gettext("nothing to do.\n");
#line 210
    logputs((enum log_options )0, (char const   *)tmp___0);
    }
#line 211
    return;
  }
  {
#line 215
  fm = read_file(file);
  }
#line 216
  if (! fm) {
    {
#line 218
    tmp___1 = __errno_location();
#line 218
    tmp___2 = strerror(*tmp___1);
#line 218
    tmp___3 = gettext("Cannot convert links in %s: %s\n");
#line 218
    logprintf((enum log_options )1, (char const   *)tmp___3, file, tmp___2);
    }
#line 220
    return;
  }
  {
#line 223
  downloaded_file_return = downloaded_file((downloaded_file_t )3, file);
  }
#line 224
  if (opt.backup_converted) {
#line 224
    if (downloaded_file_return) {
      {
#line 225
      write_backup_file(file, downloaded_file_return);
      }
    }
  }
  {
#line 231
  tmp___7 = unlink(file);
  }
#line 231
  if (tmp___7 < 0) {
    {
#line 231
    tmp___8 = __errno_location();
    }
#line 231
    if (*tmp___8 != 2) {
      {
#line 233
      tmp___4 = __errno_location();
#line 233
      tmp___5 = strerror(*tmp___4);
#line 233
      tmp___6 = gettext("Unable to delete `%s\': %s\n");
#line 233
      logprintf((enum log_options )1, (char const   *)tmp___6, file, tmp___5);
#line 235
      read_file_free(fm);
      }
#line 236
      return;
    }
  }
  {
#line 239
  fp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"wb");
  }
#line 240
  if (! fp) {
    {
#line 242
    tmp___9 = __errno_location();
#line 242
    tmp___10 = strerror(*tmp___9);
#line 242
    tmp___11 = gettext("Cannot convert links in %s: %s\n");
#line 242
    logprintf((enum log_options )1, (char const   *)tmp___11, file, tmp___10);
#line 244
    read_file_free(fm);
    }
#line 245
    return;
  }
#line 250
  p = (char const   *)fm->content;
#line 251
  link___0 = links;
  {
#line 251
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 251
    if (! link___0) {
#line 251
      goto while_break___0;
    }
#line 253
    url_start = fm->content + link___0->pos;
#line 255
    if ((long )link___0->pos >= fm->length) {
      {
#line 257
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 257
        if (opt.debug) {
          {
#line 257
          debug_logprintf("Something strange is going on.  Please investigate.");
          }
        }
#line 257
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 258
      goto while_break___0;
    }
#line 261
    if ((unsigned int )link___0->convert == 0U) {
      {
#line 263
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 263
        if (opt.debug) {
          {
#line 263
          debug_logprintf("Skipping %s at position %d.\n", (link___0->url)->url, link___0->pos);
          }
        }
#line 263
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 264
      goto __Cont;
    }
    {
#line 269
    fwrite((void const   */* __restrict  */)p, (size_t )1, (size_t )(url_start - (char *)p),
           (FILE */* __restrict  */)fp);
#line 270
    p = (char const   *)url_start;
    }
    {
#line 274
    if ((unsigned int )link___0->convert == 1U) {
#line 274
      goto case_1;
    }
#line 293
    if ((unsigned int )link___0->convert == 2U) {
#line 293
      goto case_2;
    }
#line 311
    if ((unsigned int )link___0->convert == 3U) {
#line 311
      goto case_3;
    }
#line 315
    if ((unsigned int )link___0->convert == 0U) {
#line 315
      goto case_0;
    }
#line 272
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 277
    tmp___12 = construct_relative(file, (char const   *)link___0->local_name);
#line 277
    newname = tmp___12;
#line 278
    tmp___13 = local_quote_string((char const   *)newname);
#line 278
    quoted_newname = tmp___13;
    }
#line 280
    if (! link___0->link_refresh_p) {
      {
#line 281
      p = replace_attr(p, link___0->size, fp, (char const   *)quoted_newname);
      }
    } else {
      {
#line 283
      p = replace_attr_refresh_hack(p, link___0->size, fp, (char const   *)quoted_newname,
                                    link___0->refresh_timeout);
      }
    }
    {
#line 286
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 286
      if (opt.debug) {
        {
#line 286
        debug_logprintf("TO_RELATIVE: %s to %s at position %d in %s.\n", (link___0->url)->url,
                        newname, link___0->pos, file);
        }
      }
#line 286
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 288
    free((void *)newname);
#line 289
    free((void *)quoted_newname);
#line 290
    to_file_count ++;
    }
#line 291
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 296
    newlink = (link___0->url)->url;
#line 297
    tmp___14 = html_quote_string((char const   *)newlink);
#line 297
    quoted_newlink = tmp___14;
    }
#line 299
    if (! link___0->link_refresh_p) {
      {
#line 300
      p = replace_attr(p, link___0->size, fp, (char const   *)quoted_newlink);
      }
    } else {
      {
#line 302
      p = replace_attr_refresh_hack(p, link___0->size, fp, (char const   *)quoted_newlink,
                                    link___0->refresh_timeout);
      }
    }
    {
#line 305
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 305
      if (opt.debug) {
        {
#line 305
        debug_logprintf("TO_COMPLETE: <something> to %s at position %d in %s.\n",
                        newlink, link___0->pos, file);
        }
      }
#line 305
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 307
    free((void *)quoted_newlink);
#line 308
    to_url_count ++;
    }
#line 309
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 313
    p = replace_attr(p, link___0->size, fp, "");
    }
#line 314
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 316
    abort();
    }
#line 317
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 251
    link___0 = link___0->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 322
  if (p - (char const   *)fm->content < fm->length) {
    {
#line 323
    fwrite((void const   */* __restrict  */)p, (size_t )1, (size_t )(fm->length - (p - (char const   *)fm->content)),
           (FILE */* __restrict  */)fp);
    }
  }
  {
#line 324
  fclose(fp);
#line 325
  read_file_free(fm);
#line 327
  logprintf((enum log_options )0, "%d-%d\n", to_file_count, to_url_count);
  }
#line 328
  return;
}
}
#line 347 "convert.c"
static char *construct_relative(char const   *s1 , char const   *s2 ) 
{ 
  int i ;
  int cnt ;
  int sepdirs1 ;
  char *res___0 ;
  char *tmp ;
  long tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
#line 353
  if ((int const   )*s2 == 47) {
    {
#line 354
    tmp = xstrdup_real(s2);
    }
#line 354
    return (tmp);
  }
  {
#line 356
  tmp___0 = __builtin_expect((long )(! (! ((int const   )*s1 != 47))), 1L);
  }
#line 356
  if (! tmp___0) {
    {
#line 356
    __assert_fail("*s1 != \'/\'", "convert.c", 356U, "construct_relative");
    }
  }
#line 357
  cnt = 0;
#line 357
  i = cnt;
  {
#line 359
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 361
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 361
      if (*(s1 + i)) {
#line 361
        if (*(s2 + i)) {
#line 361
          if ((int const   )*(s1 + i) == (int const   )*(s2 + i)) {
#line 361
            if ((int const   )*(s1 + i) != 47) {
#line 361
              if (! ((int const   )*(s2 + i) != 47)) {
#line 361
                goto while_break___0;
              }
            } else {
#line 361
              goto while_break___0;
            }
          } else {
#line 361
            goto while_break___0;
          }
        } else {
#line 361
          goto while_break___0;
        }
      } else {
#line 361
        goto while_break___0;
      }
#line 365
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 366
    if ((int const   )*(s1 + i) == 47) {
#line 366
      if ((int const   )*(s2 + i) == 47) {
#line 367
        i ++;
#line 367
        cnt = i;
      } else {
#line 369
        goto while_break;
      }
    } else {
#line 369
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 371
  sepdirs1 = 0;
  {
#line 371
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 371
    if (! *(s1 + i)) {
#line 371
      goto while_break___1;
    }
#line 372
    if ((int const   )*(s1 + i) == 47) {
#line 373
      sepdirs1 ++;
    }
#line 371
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 377
  tmp___1 = strlen(s2 + cnt);
#line 377
  tmp___2 = xmalloc_real(((size_t )(3 * sepdirs1) + tmp___1) + 1U);
#line 377
  res___0 = (char *)tmp___2;
#line 378
  i = 0;
  }
  {
#line 378
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 378
    if (! (i < sepdirs1)) {
#line 378
      goto while_break___2;
    }
    {
#line 379
    memcpy((void */* __restrict  */)(res___0 + 3 * i), (void const   */* __restrict  */)"../",
           (size_t )3);
#line 378
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 380
  strcpy((char */* __restrict  */)(res___0 + 3 * i), (char const   */* __restrict  */)(s2 + cnt));
  }
#line 381
  return (res___0);
}
}
#line 397 "convert.c"
static slist *converted_files  =    (slist *)((void *)0);
#line 384 "convert.c"
static void write_backup_file(char const   *file , downloaded_file_t downloaded_file_return ) 
{ 
  size_t filename_len ;
  size_t tmp ;
  char *filename_plus_orig_suffix ;
  boolean already_wrote_backup_file ;
  slist *converted_file_ptr ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;

  {
  {
#line 393
  tmp = strlen(file);
#line 393
  filename_len = tmp;
#line 395
  already_wrote_backup_file = (boolean )0;
  }
#line 399
  if ((unsigned int )downloaded_file_return == 2U) {
    {
#line 408
    tmp___0 = __builtin_alloca((unsigned long )(filename_len + 1U));
#line 408
    filename_plus_orig_suffix = (char *)tmp___0;
#line 409
    strcpy((char */* __restrict  */)filename_plus_orig_suffix, (char const   */* __restrict  */)file);
#line 410
    strcpy((char */* __restrict  */)((filename_plus_orig_suffix + filename_len) - 4),
           (char const   */* __restrict  */)"orig");
    }
  } else {
    {
#line 415
    tmp___1 = __builtin_alloca((unsigned long )filename_len + sizeof(".orig"));
#line 415
    filename_plus_orig_suffix = (char *)tmp___1;
#line 416
    strcpy((char */* __restrict  */)filename_plus_orig_suffix, (char const   */* __restrict  */)file);
#line 417
    strcpy((char */* __restrict  */)(filename_plus_orig_suffix + filename_len), (char const   */* __restrict  */)".orig");
    }
  }
#line 425
  converted_file_ptr = converted_files;
  {
#line 426
  while (1) {
    while_continue: /* CIL Label */ ;
#line 426
    if (! ((unsigned long )converted_file_ptr != (unsigned long )((void *)0))) {
#line 426
      goto while_break;
    }
    {
#line 427
    tmp___2 = strcmp((char const   *)converted_file_ptr->string, file);
    }
#line 427
    if (tmp___2 == 0) {
#line 429
      already_wrote_backup_file = (boolean )1;
#line 430
      goto while_break;
    } else {
#line 433
      converted_file_ptr = converted_file_ptr->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 435
  if (! already_wrote_backup_file) {
    {
#line 438
    tmp___6 = rename(file, (char const   *)filename_plus_orig_suffix);
    }
#line 438
    if (tmp___6 != 0) {
      {
#line 439
      tmp___3 = __errno_location();
#line 439
      tmp___4 = strerror(*tmp___3);
#line 439
      tmp___5 = gettext("Cannot back up %s as %s: %s\n");
#line 439
      logprintf((enum log_options )1, (char const   *)tmp___5, file, filename_plus_orig_suffix,
                tmp___4);
      }
    }
    {
#line 459
    tmp___7 = xmalloc_real((size_t )sizeof(*converted_file_ptr));
#line 459
    converted_file_ptr = (slist *)tmp___7;
#line 460
    converted_file_ptr->string = xstrdup_real(file);
#line 461
    converted_file_ptr->next = converted_files;
#line 462
    converted_files = converted_file_ptr;
    }
  }
#line 464
  return;
}
}
#line 466
static int find_fragment(char const   *beg , int size , char const   **bp , char const   **ep ) ;
#line 471 "convert.c"
static char const   *replace_attr(char const   *p , int size , FILE *fp , char const   *new_text ) 
{ 
  int quote_flag ;
  char quote_char ;
  char const   *frag_beg ;
  char const   *frag_end ;
  int tmp ;

  {
#line 474
  quote_flag = 0;
#line 475
  quote_char = (char )'\"';
#line 487
  if ((int const   )*p == 34) {
#line 489
    quote_char = (char )*p;
#line 490
    quote_flag = 1;
#line 491
    p ++;
#line 492
    size -= 2;
  } else
#line 487
  if ((int const   )*p == 39) {
#line 489
    quote_char = (char )*p;
#line 490
    quote_flag = 1;
#line 491
    p ++;
#line 492
    size -= 2;
  }
  {
#line 494
  _IO_putc((int )quote_char, fp);
#line 495
  fputs((char const   */* __restrict  */)new_text, (FILE */* __restrict  */)fp);
#line 498
  tmp = find_fragment(p, size, & frag_beg, & frag_end);
  }
#line 498
  if (tmp) {
    {
#line 499
    fwrite((void const   */* __restrict  */)frag_beg, (size_t )1, (size_t )(frag_end - frag_beg),
           (FILE */* __restrict  */)fp);
    }
  }
#line 500
  p += size;
#line 501
  if (quote_flag) {
#line 502
    p ++;
  }
  {
#line 503
  _IO_putc((int )quote_char, fp);
  }
#line 505
  return (p);
}
}
#line 512 "convert.c"
static char const   *replace_attr_refresh_hack(char const   *p , int size , FILE *fp ,
                                               char const   *new_text , int timeout ) 
{ 
  char *new_with_timeout ;
  int tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char const   *tmp___2 ;

  {
  {
#line 517
  tmp = numdigit((long )timeout);
#line 517
  tmp___0 = strlen(new_text);
#line 517
  tmp___1 = __builtin_alloca((unsigned long )(((size_t )(tmp + 6) + tmp___0) + 1U));
#line 517
  new_with_timeout = (char *)tmp___1;
#line 521
  sprintf((char */* __restrict  */)new_with_timeout, (char const   */* __restrict  */)"%d; URL=%s",
          timeout, new_text);
#line 523
  tmp___2 = replace_attr(p, size, fp, (char const   *)new_with_timeout);
  }
#line 523
  return (tmp___2);
}
}
#line 533 "convert.c"
static int find_fragment(char const   *beg , int size , char const   **bp , char const   **ep ) 
{ 
  char const   *end ;
  int saw_amp ;

  {
#line 536
  end = beg + size;
#line 537
  saw_amp = 0;
  {
#line 538
  while (1) {
    while_continue: /* CIL Label */ ;
#line 538
    if (! ((unsigned long )beg < (unsigned long )end)) {
#line 538
      goto while_break;
    }
    {
#line 542
    if ((int const   )*beg == 38) {
#line 542
      goto case_38;
    }
#line 545
    if ((int const   )*beg == 35) {
#line 545
      goto case_35;
    }
#line 553
    goto switch_default;
    case_38: /* CIL Label */ 
#line 543
    saw_amp = 1;
#line 544
    goto switch_break;
    case_35: /* CIL Label */ 
#line 546
    if (! saw_amp) {
#line 548
      *bp = beg;
#line 549
      *ep = end;
#line 550
      return (1);
    }
    switch_default: /* CIL Label */ 
#line 554
    saw_amp = 0;
    switch_break: /* CIL Label */ ;
    }
#line 538
    beg ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 557
  return (0);
}
}
#line 571 "convert.c"
static char *local_quote_string(char const   *file ) 
{ 
  char const   *file_sans_qmark ;
  int qm ;
  char *tmp ;
  char const   *from ;
  char *to ;
  char *newname ;
  int fsqlen ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  long tmp___6 ;
  char *tmp___7 ;

  {
#line 577
  if (! opt.html_extension) {
    {
#line 578
    tmp = html_quote_string(file);
    }
#line 578
    return (tmp);
  }
  {
#line 580
  qm = count_char(file, (char )'?');
  }
#line 582
  if (qm) {
    {
#line 584
    from = file;
#line 589
    tmp___0 = strlen(file);
#line 589
    fsqlen = (int )(tmp___0 + (size_t )(qm * 2));
#line 591
    tmp___1 = __builtin_alloca((unsigned long )(fsqlen + 1));
#line 591
    newname = (char *)tmp___1;
#line 591
    to = newname;
    }
    {
#line 592
    while (1) {
      while_continue: /* CIL Label */ ;
#line 592
      if (! *from) {
#line 592
        goto while_break;
      }
#line 594
      if ((int const   )*from != 63) {
#line 595
        tmp___2 = to;
#line 595
        to ++;
#line 595
        *tmp___2 = (char )*from;
      } else {
#line 598
        tmp___3 = to;
#line 598
        to ++;
#line 598
        *tmp___3 = (char )'%';
#line 599
        tmp___4 = to;
#line 599
        to ++;
#line 599
        *tmp___4 = (char )'3';
#line 600
        tmp___5 = to;
#line 600
        to ++;
#line 600
        *tmp___5 = (char )'F';
      }
#line 592
      from ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 603
    tmp___6 = __builtin_expect((long )(! (! (to - newname == (long )fsqlen))), 1L);
    }
#line 603
    if (! tmp___6) {
      {
#line 603
      __assert_fail("to - newname == fsqlen", "convert.c", 603U, "local_quote_string");
      }
    }
#line 604
    *to = (char )'\000';
#line 606
    file_sans_qmark = (char const   *)newname;
  } else {
#line 609
    file_sans_qmark = file;
  }
  {
#line 611
  tmp___7 = html_quote_string(file_sans_qmark);
  }
#line 611
  return (tmp___7);
}
}
#line 635 "convert.c"
static int match_except_index(char const   *s1 , char const   *s2 ) 
{ 
  int i ;
  char const   *lng ;
  int tmp ;

  {
#line 642
  i = 0;
  {
#line 642
  while (1) {
    while_continue: /* CIL Label */ ;
#line 642
    if (*s1) {
#line 642
      if (*s2) {
#line 642
        if (! ((int const   )*s1 == (int const   )*s2)) {
#line 642
          goto while_break;
        }
      } else {
#line 642
        goto while_break;
      }
    } else {
#line 642
      goto while_break;
    }
#line 642
    s1 ++;
#line 642
    s2 ++;
#line 642
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 644
  if (i == 0) {
#line 648
    return (0);
  }
#line 650
  if (! *s1) {
#line 650
    if (! *s2) {
#line 652
      return (1);
    } else {
#line 650
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 653
  if (*s1) {
#line 653
    if (*s2) {
#line 655
      return (0);
    } else {
#line 653
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 656
  if (*s1) {
#line 658
    lng = s1;
  } else {
#line 661
    lng = s2;
  }
#line 667
  if ((int const   )*lng != 47) {
#line 669
    lng --;
  }
#line 671
  if ((int const   )*lng == 47) {
#line 671
    if ((int const   )*(lng + 1) == 0) {
#line 674
      return (1);
    }
  }
  {
#line 676
  tmp = strcmp(lng, "/index.html");
  }
#line 676
  return (0 == tmp);
}
}
#line 679 "convert.c"
static int dissociate_urls_from_file_mapper(void *key , void *value , void *arg ) 
{ 
  char *mapping_url ;
  char *mapping_file ;
  char *file ;
  int tmp ;

  {
  {
#line 682
  mapping_url = (char *)key;
#line 683
  mapping_file = (char *)value;
#line 684
  file = (char *)arg;
#line 686
  tmp = strcmp((char const   *)mapping_file, (char const   *)file);
  }
#line 686
  if (0 == tmp) {
    {
#line 688
    hash_table_remove(dl_url_file_map, (void const   *)mapping_url);
#line 689
    free((void *)mapping_url);
#line 690
    free((void *)mapping_file);
    }
  }
#line 694
  return (0);
}
}
#line 699 "convert.c"
static void dissociate_urls_from_file(char const   *file ) 
{ 


  {
  {
#line 702
  hash_table_map(dl_url_file_map, & dissociate_urls_from_file_mapper, (void *)((char *)file));
  }
#line 704
  return;
}
}
#line 711 "convert.c"
void register_download(char const   *url , char const   *file ) 
{ 
  char *old_file ;
  char *old_url ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
  {
#line 716
  while (1) {
    while_continue: /* CIL Label */ ;
#line 716
    if (! dl_file_url_map) {
      {
#line 716
      dl_file_url_map = make_string_hash_table(0);
      }
    }
#line 716
    if (! dl_url_file_map) {
      {
#line 716
      dl_url_file_map = make_string_hash_table(0);
      }
    }
#line 716
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 723
  tmp___2 = hash_table_get_pair((struct hash_table  const  *)dl_file_url_map, (void const   *)file,
                                (void *)(& old_file), (void *)(& old_url));
  }
#line 723
  if (tmp___2) {
    {
#line 725
    tmp = strcmp(url, (char const   *)old_url);
    }
#line 725
    if (0 == tmp) {
#line 728
      return;
    }
    {
#line 730
    tmp___0 = match_except_index(url, (char const   *)old_url);
    }
#line 730
    if (tmp___0) {
      {
#line 730
      tmp___1 = hash_table_contains((struct hash_table  const  *)dl_url_file_map,
                                    (void const   *)url);
      }
#line 730
      if (! tmp___1) {
#line 736
        goto url_only;
      }
    }
    {
#line 738
    hash_table_remove(dl_file_url_map, (void const   *)file);
#line 739
    free((void *)old_file);
#line 740
    free((void *)old_url);
#line 755
    dissociate_urls_from_file(file);
    }
  }
  {
#line 758
  tmp___3 = xstrdup_real(url);
#line 758
  tmp___4 = xstrdup_real(file);
#line 758
  hash_table_put(dl_file_url_map, (void const   *)tmp___4, (void *)tmp___3);
  }
  url_only: 
  {
#line 777
  tmp___5 = hash_table_get_pair((struct hash_table  const  *)dl_url_file_map, (void const   *)url,
                                (void *)(& old_url), (void *)(& old_file));
  }
#line 777
  if (tmp___5) {
    {
#line 779
    hash_table_remove(dl_url_file_map, (void const   *)url);
#line 780
    free((void *)old_url);
#line 781
    free((void *)old_file);
    }
  }
  {
#line 784
  tmp___6 = xstrdup_real(file);
#line 784
  tmp___7 = xstrdup_real(url);
#line 784
  hash_table_put(dl_url_file_map, (void const   *)tmp___7, (void *)tmp___6);
  }
#line 785
  return;
}
}
#line 791 "convert.c"
void register_redirection(char const   *from , char const   *to ) 
{ 
  char *file ;
  void *tmp ;
  long tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 796
  while (1) {
    while_continue: /* CIL Label */ ;
#line 796
    if (! dl_file_url_map) {
      {
#line 796
      dl_file_url_map = make_string_hash_table(0);
      }
    }
#line 796
    if (! dl_url_file_map) {
      {
#line 796
      dl_url_file_map = make_string_hash_table(0);
      }
    }
#line 796
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 798
  tmp = hash_table_get((struct hash_table  const  *)dl_url_file_map, (void const   *)to);
#line 798
  file = (char *)tmp;
#line 799
  tmp___0 = __builtin_expect((long )(! (! ((unsigned long )file != (unsigned long )((void *)0)))),
                             1L);
  }
#line 799
  if (! tmp___0) {
    {
#line 799
    __assert_fail("file != ((void *)0)", "convert.c", 799U, "register_redirection");
    }
  }
  {
#line 800
  tmp___3 = hash_table_contains((struct hash_table  const  *)dl_url_file_map, (void const   *)from);
  }
#line 800
  if (! tmp___3) {
    {
#line 801
    tmp___1 = xstrdup_real((char const   *)file);
#line 801
    tmp___2 = xstrdup_real(from);
#line 801
    hash_table_put(dl_url_file_map, (void const   *)tmp___2, (void *)tmp___1);
    }
  }
#line 802
  return;
}
}
#line 806 "convert.c"
void register_delete_file(char const   *file ) 
{ 
  char *old_url ;
  char *old_file ;
  int tmp ;

  {
  {
#line 811
  while (1) {
    while_continue: /* CIL Label */ ;
#line 811
    if (! dl_file_url_map) {
      {
#line 811
      dl_file_url_map = make_string_hash_table(0);
      }
    }
#line 811
    if (! dl_url_file_map) {
      {
#line 811
      dl_url_file_map = make_string_hash_table(0);
      }
    }
#line 811
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 813
  tmp = hash_table_get_pair((struct hash_table  const  *)dl_file_url_map, (void const   *)file,
                            (void *)(& old_file), (void *)(& old_url));
  }
#line 813
  if (! tmp) {
#line 814
    return;
  }
  {
#line 816
  hash_table_remove(dl_file_url_map, (void const   *)file);
#line 817
  free((void *)old_file);
#line 818
  free((void *)old_url);
#line 819
  dissociate_urls_from_file(file);
  }
#line 820
  return;
}
}
#line 824 "convert.c"
void register_html(char const   *url , char const   *file ) 
{ 
  int tmp ;

  {
#line 827
  if (! downloaded_html_set) {
    {
#line 828
    downloaded_html_set = make_string_hash_table(0);
    }
  } else {
    {
#line 829
    tmp = hash_table_contains((struct hash_table  const  *)downloaded_html_set, (void const   *)file);
    }
#line 829
    if (tmp) {
#line 830
      return;
    }
  }
  {
#line 835
  string_set_add(downloaded_html_set, file);
#line 836
  downloaded_html_list = slist_prepend(downloaded_html_list, file);
  }
#line 837
  return;
}
}
#line 841 "convert.c"
void convert_cleanup(void) 
{ 


  {
#line 844
  if (dl_file_url_map) {
    {
#line 846
    free_keys_and_values(dl_file_url_map);
#line 847
    hash_table_destroy(dl_file_url_map);
#line 848
    dl_file_url_map = (struct hash_table *)((void *)0);
    }
  }
#line 850
  if (dl_url_file_map) {
    {
#line 852
    free_keys_and_values(dl_url_file_map);
#line 853
    hash_table_destroy(dl_url_file_map);
#line 854
    dl_url_file_map = (struct hash_table *)((void *)0);
    }
  }
#line 856
  if (downloaded_html_set) {
    {
#line 857
    string_set_free(downloaded_html_set);
    }
  }
  {
#line 858
  slist_free(downloaded_html_list);
#line 859
  downloaded_html_list = (slist *)((void *)0);
  }
#line 860
  return;
}
}
#line 870 "convert.c"
static struct hash_table *downloaded_files_hash  ;
#line 880
static downloaded_file_t *downloaded_mode_to_ptr(downloaded_file_t mode ) ;
#line 880 "convert.c"
static downloaded_file_t v1  =    (downloaded_file_t )0;
#line 880 "convert.c"
static downloaded_file_t v2  =    (downloaded_file_t )1;
#line 880 "convert.c"
static downloaded_file_t v3  =    (downloaded_file_t )2;
#line 880 "convert.c"
static downloaded_file_t v4  =    (downloaded_file_t )3;
#line 877 "convert.c"
static downloaded_file_t *downloaded_mode_to_ptr(downloaded_file_t mode ) 
{ 


  {
  {
#line 888
  if ((unsigned int )mode == 0U) {
#line 888
    goto case_0;
  }
#line 890
  if ((unsigned int )mode == 1U) {
#line 890
    goto case_1;
  }
#line 892
  if ((unsigned int )mode == 2U) {
#line 892
    goto case_2;
  }
#line 894
  if ((unsigned int )mode == 3U) {
#line 894
    goto case_3;
  }
#line 886
  goto switch_break;
  case_0: /* CIL Label */ 
#line 889
  return (& v1);
  case_1: /* CIL Label */ 
#line 891
  return (& v2);
  case_2: /* CIL Label */ 
#line 893
  return (& v3);
  case_3: /* CIL Label */ 
#line 895
  return (& v4);
  switch_break: /* CIL Label */ ;
  }
#line 897
  return ((downloaded_file_t *)((void *)0));
}
}
#line 915 "convert.c"
downloaded_file_t downloaded_file(downloaded_file_t mode , char const   *file ) 
{ 
  downloaded_file_t *ptr ;
  void *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;

  {
#line 920
  if ((unsigned int )mode == 3U) {
#line 922
    if (! downloaded_files_hash) {
#line 923
      return ((downloaded_file_t )0);
    }
    {
#line 924
    tmp = hash_table_get((struct hash_table  const  *)downloaded_files_hash, (void const   *)file);
#line 924
    ptr = (downloaded_file_t *)tmp;
    }
#line 925
    if (! ptr) {
#line 926
      return ((downloaded_file_t )0);
    }
#line 927
    return (*ptr);
  }
#line 930
  if (! downloaded_files_hash) {
    {
#line 931
    downloaded_files_hash = make_string_hash_table(0);
    }
  }
  {
#line 933
  tmp___0 = hash_table_get((struct hash_table  const  *)downloaded_files_hash, (void const   *)file);
#line 933
  ptr = (downloaded_file_t *)tmp___0;
  }
#line 934
  if (ptr) {
#line 935
    return (*ptr);
  }
  {
#line 937
  ptr = downloaded_mode_to_ptr(mode);
#line 938
  tmp___1 = xstrdup_real(file);
#line 938
  hash_table_put(downloaded_files_hash, (void const   *)tmp___1, (void *)(& ptr));
  }
#line 940
  return ((downloaded_file_t )0);
}
}
#line 943 "convert.c"
static int df_free_mapper(void *key , void *value , void *ignored ) 
{ 


  {
  {
#line 946
  free(key);
  }
#line 947
  return (0);
}
}
#line 950 "convert.c"
void downloaded_files_free(void) 
{ 


  {
#line 953
  if (downloaded_files_hash) {
    {
#line 955
    hash_table_map(downloaded_files_hash, & df_free_mapper, (void *)0);
#line 956
    hash_table_destroy(downloaded_files_hash);
#line 957
    downloaded_files_hash = (struct hash_table *)((void *)0);
    }
  }
#line 959
  return;
}
}
#line 109 "/usr/include/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 318 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 100 "/usr/include/sys/socket.h"
extern int socket(int __domain , int __type , int __protocol ) ;
#line 110
extern int bind(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 114
extern int getsockname(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __len ) ;
#line 124
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 192
extern int setsockopt(int __fd , int __level , int __optname , void const   *__optval ,
                      socklen_t __optlen ) ;
#line 199
extern int listen(int __fd , int __n ) ;
#line 209
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 69 "connect.c"
static int msock  =    -1;
#line 70 "connect.c"
static struct sockaddr *addr  ;
#line 72 "connect.c"
static ip_address bind_address  ;
#line 73 "connect.c"
static int bind_address_resolved  ;
#line 75 "connect.c"
static void resolve_bind_address(void) 
{ 
  struct address_list *al ;
  char *tmp ;

  {
#line 80
  if (bind_address_resolved) {
#line 82
    return;
  } else
#line 80
  if ((unsigned long )opt.bind_address == (unsigned long )((void *)0)) {
#line 82
    return;
  }
  {
#line 84
  al = lookup_host((char const   *)opt.bind_address, 1);
  }
#line 85
  if (! al) {
    {
#line 87
    tmp = gettext("Unable to convert `%s\' to a bind address.  Reverting to ANY.\n");
#line 87
    logprintf((enum log_options )1, (char const   *)tmp, opt.bind_address);
    }
#line 90
    return;
  }
  {
#line 93
  address_list_copy_one(al, 0, & bind_address);
#line 94
  address_list_release(al);
#line 95
  bind_address_resolved = 1;
  }
#line 96
  return;
}
}
#line 105 "connect.c"
static void connect_with_timeout_callback(void *arg ) 
{ 
  struct cwt_context *ctx ;

  {
  {
#line 108
  ctx = (struct cwt_context *)arg;
#line 109
  ctx->result = connect(ctx->fd, ctx->addr, ctx->addrlen);
  }
#line 110
  return;
}
}
#line 116 "connect.c"
static int connect_with_timeout(int fd , struct sockaddr  const  *addr___0 , socklen_t addrlen ,
                                double timeout ) 
{ 
  struct cwt_context ctx ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 121
  ctx.fd = fd;
#line 122
  ctx.addr = addr___0;
#line 123
  ctx.addrlen = addrlen;
#line 125
  tmp___0 = run_with_timeout(timeout, & connect_with_timeout_callback, (void *)(& ctx));
  }
#line 125
  if (tmp___0) {
    {
#line 127
    tmp = __errno_location();
#line 127
    *tmp = 110;
    }
#line 128
    return (-1);
  }
#line 130
  if (ctx.result == -1) {
    {
#line 130
    tmp___2 = __errno_location();
    }
#line 130
    if (*tmp___2 == 4) {
      {
#line 131
      tmp___1 = __errno_location();
#line 131
      *tmp___1 = 110;
      }
    }
  }
#line 132
  return (ctx.result);
}
}
#line 137 "connect.c"
static char const   *connection_host_name  ;
#line 139 "connect.c"
void set_connection_host_name(char const   *host ) 
{ 
  long tmp ;
  long tmp___0 ;

  {
#line 142
  if (host) {
    {
#line 143
    tmp = __builtin_expect((long )(! (! ((unsigned long )connection_host_name == (unsigned long )((void *)0)))),
                           1L);
    }
#line 143
    if (! tmp) {
      {
#line 143
      __assert_fail("connection_host_name == ((void *)0)", "connect.c", 143U, "set_connection_host_name");
      }
    }
  } else {
    {
#line 145
    tmp___0 = __builtin_expect((long )(! (! ((unsigned long )connection_host_name != (unsigned long )((void *)0)))),
                               1L);
    }
#line 145
    if (! tmp___0) {
      {
#line 145
      __assert_fail("connection_host_name != ((void *)0)", "connect.c", 145U, "set_connection_host_name");
      }
    }
  }
#line 147
  connection_host_name = host;
#line 148
  return;
}
}
#line 151 "connect.c"
int connect_to_one(ip_address *addr___0 , unsigned short port , int silent ) 
{ 
  wget_sockaddr sa ;
  int sock ;
  int save_errno ;
  char *pretty_addr ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int bufsize ;
  wget_sockaddr bsa ;
  socklen_t tmp___3 ;
  int tmp___4 ;
  socklen_t tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;

  {
  {
#line 158
  wget_sockaddr_set_address(& sa, ip_default_family, port, addr___0);
  }
#line 160
  if (! silent) {
    {
#line 162
    tmp = pretty_print_address(addr___0);
#line 162
    pretty_addr = tmp;
    }
#line 163
    if (connection_host_name) {
      {
#line 163
      tmp___2 = strcmp(connection_host_name, (char const   *)pretty_addr);
      }
#line 163
      if (0 != tmp___2) {
        {
#line 165
        tmp___0 = gettext("Connecting to %s[%s]:%hu... ");
#line 165
        logprintf((enum log_options )0, (char const   *)tmp___0, connection_host_name,
                  pretty_addr, (int )port);
        }
      } else {
        {
#line 168
        tmp___1 = gettext("Connecting to %s:%hu... ");
#line 168
        logprintf((enum log_options )0, (char const   *)tmp___1, pretty_addr, (int )port);
        }
      }
    } else {
      {
#line 168
      tmp___1 = gettext("Connecting to %s:%hu... ");
#line 168
      logprintf((enum log_options )0, (char const   *)tmp___1, pretty_addr, (int )port);
      }
    }
  }
  {
#line 173
  sock = socket(ip_default_family, 1, 0);
  }
#line 174
  if (sock < 0) {
#line 175
    goto out;
  }
#line 181
  if (opt.limit_rate) {
#line 181
    if (opt.limit_rate < 8192L) {
#line 183
      bufsize = (int )opt.limit_rate;
#line 184
      if (bufsize < 512) {
#line 185
        bufsize = 512;
      }
      {
#line 187
      setsockopt(sock, 1, 8, (void const   *)((char *)(& bufsize)), (socklen_t )sizeof(bufsize));
      }
    }
  }
  {
#line 194
  resolve_bind_address();
  }
#line 195
  if (bind_address_resolved) {
    {
#line 199
    wget_sockaddr_set_address(& bsa, ip_default_family, (unsigned short)0, & bind_address);
#line 200
    tmp___3 = sockaddr_len();
#line 200
    tmp___4 = bind(sock, (struct sockaddr  const  *)(& bsa.sa), tmp___3);
    }
#line 200
    if (tmp___4) {
      {
#line 202
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 202
        close(sock);
        }
        {
#line 202
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 202
          if (opt.debug) {
            {
#line 202
            debug_logprintf("Closing fd %d\n", sock);
            }
          }
#line 202
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 202
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
#line 203
      sock = -1;
#line 204
      goto out;
    }
  }
  {
#line 209
  tmp___5 = sockaddr_len();
#line 209
  tmp___6 = connect_with_timeout(sock, (struct sockaddr  const  *)(& sa.sa), tmp___5,
                                 opt.connect_timeout);
  }
#line 209
  if (tmp___6 < 0) {
    {
#line 212
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 212
      close(sock);
      }
      {
#line 212
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 212
        if (opt.debug) {
          {
#line 212
          debug_logprintf("Closing fd %d\n", sock);
          }
        }
#line 212
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 212
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 213
    sock = -1;
#line 214
    goto out;
  }
  out: 
#line 218
  if (sock >= 0) {
#line 221
    if (! silent) {
      {
#line 222
      tmp___7 = gettext("connected.\n");
#line 222
      logprintf((enum log_options )0, (char const   *)tmp___7);
      }
    }
    {
#line 223
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 223
      if (opt.debug) {
        {
#line 223
        debug_logprintf("Created socket %d.\n", sock);
        }
      }
#line 223
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
  } else {
    {
#line 227
    tmp___8 = __errno_location();
#line 227
    save_errno = *tmp___8;
    }
#line 228
    if (! silent) {
      {
#line 229
      tmp___9 = __errno_location();
#line 229
      tmp___10 = strerror(*tmp___9);
#line 229
      logprintf((enum log_options )0, "failed: %s.\n", tmp___10);
      }
    }
    {
#line 230
    tmp___11 = __errno_location();
#line 230
    *tmp___11 = save_errno;
    }
  }
#line 233
  return (sock);
}
}
#line 237 "connect.c"
int connect_to_many(struct address_list *al , unsigned short port , int silent ) 
{ 
  int i ;
  int start ;
  int end ;
  ip_address addr___0 ;
  int sock ;

  {
  {
#line 242
  address_list_get_bounds(al, & start, & end);
#line 243
  i = start;
  }
  {
#line 243
  while (1) {
    while_continue: /* CIL Label */ ;
#line 243
    if (! (i < end)) {
#line 243
      goto while_break;
    }
    {
#line 247
    address_list_copy_one(al, i, & addr___0);
#line 249
    sock = connect_to_one(& addr___0, port, silent);
    }
#line 250
    if (sock >= 0) {
#line 252
      return (sock);
    }
    {
#line 254
    address_list_set_faulty(al, i);
#line 243
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 260
  return (-1);
}
}
#line 263 "connect.c"
int test_socket_open(int sock ) 
{ 
  fd_set check_set ;
  struct timeval to ;
  int __d0 ;
  int __d1 ;
  int tmp ;

  {
  {
#line 273
  while (1) {
    while_continue: /* CIL Label */ ;
#line 273
    __asm__  volatile   ("cld; rep; stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& check_set.fds_bits[0]): "memory");
#line 273
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 274
  __asm__  volatile   ("btsl %1,%0": "=m" (check_set.fds_bits[(unsigned long )sock / (8UL * sizeof(__fd_mask ))]): "r" ((unsigned long )sock % (8UL * sizeof(__fd_mask ))): "cc",
                       "memory");
#line 277
  to.tv_sec = (__time_t )0;
#line 278
  to.tv_usec = (__suseconds_t )1;
#line 281
  tmp = select(sock + 1, (fd_set */* __restrict  */)(& check_set), (fd_set */* __restrict  */)((void *)0),
               (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& to));
  }
#line 281
  if (tmp == 0) {
#line 284
    return (1);
  } else {
#line 287
    return (0);
  }
}
}
#line 300 "connect.c"
uerr_t bindport(unsigned short *port , int family ) 
{ 
  int optval ;
  wget_sockaddr srv ;
  int tmp ;
  ip_address *tmp___0 ;
  uint16_t tmp___1 ;
  socklen_t tmp___2 ;
  int tmp___3 ;
  socklen_t sa_len ;
  socklen_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 303
  optval = 1;
#line 305
  memset((void *)(& srv), 0, (size_t )sizeof(wget_sockaddr ));
#line 307
  msock = -1;
#line 309
  msock = socket(family, 1, 0);
  }
#line 309
  if (msock < 0) {
#line 310
    return ((uerr_t )2);
  }
  {
#line 313
  tmp = setsockopt(msock, 1, 2, (void const   *)((char *)(& optval)), (socklen_t )sizeof(optval));
  }
#line 313
  if (tmp < 0) {
#line 315
    return ((uerr_t )2);
  }
  {
#line 318
  resolve_bind_address();
  }
#line 319
  if (bind_address_resolved) {
#line 319
    tmp___0 = & bind_address;
  } else {
#line 319
    tmp___0 = (ip_address *)((void *)0);
  }
  {
#line 319
  tmp___1 = htons(*port);
#line 319
  wget_sockaddr_set_address(& srv, ip_default_family, tmp___1, tmp___0);
#line 321
  tmp___2 = sockaddr_len();
#line 321
  tmp___3 = bind(msock, (struct sockaddr  const  *)(& srv.sa), tmp___2);
  }
#line 321
  if (tmp___3 < 0) {
    {
#line 323
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 323
      close(msock);
      }
      {
#line 323
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 323
        if (opt.debug) {
          {
#line 323
          debug_logprintf("Closing fd %d\n", msock);
          }
        }
#line 323
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 323
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 324
    msock = -1;
#line 325
    return ((uerr_t )9);
  }
  {
#line 327
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 327
    if (opt.debug) {
      {
#line 327
      debug_logprintf("Master socket fd %d bound.\n", msock);
      }
    }
#line 327
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 328
  if (! *port) {
    {
#line 330
    tmp___4 = sockaddr_len();
#line 330
    sa_len = tmp___4;
#line 331
    tmp___5 = getsockname(msock, (struct sockaddr */* __restrict  */)(& srv.sa), (socklen_t */* __restrict  */)(& sa_len));
    }
#line 331
    if (tmp___5 < 0) {
      {
#line 333
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 333
        close(msock);
        }
        {
#line 333
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 333
          if (opt.debug) {
            {
#line 333
            debug_logprintf("Closing fd %d\n", msock);
            }
          }
#line 333
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 333
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 334
      msock = -1;
#line 335
      return ((uerr_t )8);
    }
    {
#line 337
    *port = wget_sockaddr_get_port((wget_sockaddr const   *)(& srv));
    }
    {
#line 338
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 338
      if (opt.debug) {
        {
#line 338
        debug_logprintf("using port %i.\n", (int )*port);
        }
      }
#line 338
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
  {
#line 340
  tmp___6 = listen(msock, 1);
  }
#line 340
  if (tmp___6 < 0) {
    {
#line 342
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 342
      close(msock);
      }
      {
#line 342
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 342
        if (opt.debug) {
          {
#line 342
          debug_logprintf("Closing fd %d\n", msock);
          }
        }
#line 342
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 342
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 343
    msock = -1;
#line 344
    return ((uerr_t )11);
  }
#line 346
  return ((uerr_t )10);
}
}
#line 356 "connect.c"
int select_fd(int fd , double maxtime , int writep ) 
{ 
  fd_set fds ;
  fd_set *rd ;
  fd_set *wrt ;
  struct timeval tmout ;
  int result ;
  int __d0 ;
  int __d1 ;
  fd_set **tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 360
  rd = (fd_set *)((void *)0);
#line 360
  wrt = (fd_set *)((void *)0);
  {
#line 364
  while (1) {
    while_continue: /* CIL Label */ ;
#line 364
    __asm__  volatile   ("cld; rep; stosl": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& fds.fds_bits[0]): "memory");
#line 364
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 365
  __asm__  volatile   ("btsl %1,%0": "=m" (fds.fds_bits[(unsigned long )fd / (8UL * sizeof(__fd_mask ))]): "r" ((unsigned long )fd % (8UL * sizeof(__fd_mask ))): "cc",
                       "memory");
#line 366
  if (writep) {
#line 366
    tmp = & wrt;
  } else {
#line 366
    tmp = & rd;
  }
#line 366
  *tmp = & fds;
#line 368
  tmout.tv_sec = (long )maxtime;
#line 369
  tmout.tv_usec = (__suseconds_t )((double )1000000L * (maxtime - (double )((long )maxtime)));
  {
#line 371
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 372
    result = select(fd + 1, (fd_set */* __restrict  */)rd, (fd_set */* __restrict  */)wrt,
                    (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tmout));
    }
#line 371
    if (result < 0) {
      {
#line 371
      tmp___0 = __errno_location();
      }
#line 371
      if (! (*tmp___0 == 4)) {
#line 371
        goto while_break___0;
      }
    } else {
#line 371
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 377
  if (result == 0) {
    {
#line 378
    tmp___1 = __errno_location();
#line 378
    *tmp___1 = 110;
    }
  }
#line 380
  return (result);
}
}
#line 389 "connect.c"
uerr_t acceptport(int *sock ) 
{ 
  socklen_t addrlen ;
  socklen_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 392
  tmp = sockaddr_len();
#line 392
  addrlen = tmp;
#line 395
  tmp___0 = select_fd(msock, opt.connect_timeout, 0);
  }
#line 395
  if (tmp___0 <= 0) {
#line 396
    return ((uerr_t )12);
  }
  {
#line 398
  tmp___1 = accept(msock, (struct sockaddr */* __restrict  */)addr, (socklen_t */* __restrict  */)(& addrlen));
#line 398
  *sock = tmp___1;
  }
#line 398
  if (tmp___1 < 0) {
#line 399
    return ((uerr_t )12);
  }
  {
#line 400
  while (1) {
    while_continue: /* CIL Label */ ;
#line 400
    if (opt.debug) {
      {
#line 400
      debug_logprintf("Created socket fd %d.\n", *sock);
      }
    }
#line 400
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 401
  return ((uerr_t )13);
}
}
#line 406 "connect.c"
void closeport(int sock ) 
{ 


  {
#line 410
  if (sock != -1) {
    {
#line 411
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 411
      close(sock);
      }
      {
#line 411
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 411
        if (opt.debug) {
          {
#line 411
          debug_logprintf("Closing fd %d\n", sock);
          }
        }
#line 411
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 411
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 412
  if (msock != -1) {
    {
#line 413
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 413
      close(msock);
      }
      {
#line 413
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 413
        if (opt.debug) {
          {
#line 413
          debug_logprintf("Closing fd %d\n", msock);
          }
        }
#line 413
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 413
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 414
  msock = -1;
#line 415
  return;
}
}
#line 419 "connect.c"
int conaddr(int fd , ip_address *ip ) 
{ 
  wget_sockaddr mysrv ;
  socklen_t addrlen ;
  int tmp ;

  {
  {
#line 423
  addrlen = (socklen_t )sizeof(mysrv);
#line 424
  tmp = getsockname(fd, (struct sockaddr */* __restrict  */)(& mysrv.sa), (socklen_t */* __restrict  */)(& addrlen));
  }
#line 424
  if (tmp < 0) {
#line 425
    return (0);
  }
  {
#line 434
  if ((int )mysrv.sa.sa_family == 2) {
#line 434
    goto case_2;
  }
#line 437
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 435
  map_ipv4_to_ip((ip4_address *)(& mysrv.sin.sin_addr), ip);
  }
#line 436
  return (1);
  switch_default: /* CIL Label */ 
  {
#line 438
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 440
  return (0);
}
}
#line 449 "connect.c"
int iread(int fd , char *buf___0 , int len ) 
{ 
  int res___0 ;
  int tmp ;
  int *tmp___0 ;

  {
#line 455
  if (opt.read_timeout) {
    {
#line 456
    tmp = select_fd(fd, opt.read_timeout, 0);
    }
#line 456
    if (tmp <= 0) {
#line 457
      return (-1);
    }
  }
  {
#line 459
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 460
    res___0 = read(fd, (void *)buf___0, (size_t )len);
    }
#line 459
    if (res___0 == -1) {
      {
#line 459
      tmp___0 = __errno_location();
      }
#line 459
      if (! (*tmp___0 == 4)) {
#line 459
        goto while_break;
      }
    } else {
#line 459
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 463
  return (res___0);
}
}
#line 471 "connect.c"
int iwrite(int fd , char *buf___0 , int len ) 
{ 
  int res___0 ;
  int tmp ;
  int *tmp___0 ;

  {
#line 474
  res___0 = 0;
  {
#line 480
  while (1) {
    while_continue: /* CIL Label */ ;
#line 480
    if (! (len > 0)) {
#line 480
      goto while_break;
    }
#line 483
    if (opt.read_timeout) {
      {
#line 484
      tmp = select_fd(fd, opt.read_timeout, 1);
      }
#line 484
      if (tmp <= 0) {
#line 485
        return (-1);
      }
    }
    {
#line 487
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 488
      res___0 = write(fd, (void const   *)buf___0, (size_t )len);
      }
#line 487
      if (res___0 == -1) {
        {
#line 487
        tmp___0 = __errno_location();
        }
#line 487
        if (! (*tmp___0 == 4)) {
#line 487
          goto while_break___0;
        }
      } else {
#line 487
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 490
    if (res___0 <= 0) {
#line 491
      goto while_break;
    }
#line 492
    buf___0 += res___0;
#line 493
    len -= res___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 495
  return (res___0);
}
}
