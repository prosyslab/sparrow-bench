/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 55 "/usr/include/stdint.h"
typedef unsigned long uint64_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 254 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/ccan/hash/hash.c"
union __anonunion_u_22 {
   void const   *ptr ;
   size_t i ;
};
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 135 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/wiggle.h"
struct plist {
   char *file ;
   unsigned int start ;
   unsigned int end ;
   int parent ;
   int next ;
   int prev ;
   int last ;
   int open ;
   int chunks ;
   int wiggles ;
   int conflicts ;
   int calced ;
   int is_merge ;
   char *before ;
   char *after ;
};
#line 51 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/wiggle.h"
struct elmnt {
   char *start ;
   int hash ;
   int len ;
};
#line 82 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/wiggle.h"
struct csl {
   int a ;
   int b ;
   int len ;
};
#line 87 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/wiggle.h"
struct file {
   struct elmnt *list ;
   int elcnt ;
};
#line 134 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/diff.c"
struct v {
   int x ;
   int md ;
   int l ;
};
#line 111 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/wiggle.h"
enum mergetype {
    End = 0,
    Unmatched = 1,
    Unchanged = 2,
    Extraneous = 3,
    Changed = 4,
    Conflict = 5,
    AlreadyApplied = 6
} ;
#line 111 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/wiggle.h"
struct merge {
   enum mergetype type ;
   int a ;
   int b ;
   int c ;
   int al ;
   int bl ;
   int cl ;
   int c1 ;
   int c2 ;
   int in_conflict ;
   int lo ;
   int hi ;
};
#line 164 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/wiggle.h"
struct ci {
   int conflicts ;
   int wiggles ;
   int ignored ;
   struct merge *merger ;
};
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 37 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/wiggle.h"
struct stream {
   char *body ;
   int len ;
};
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 150 "/usr/include/curses.h"
typedef unsigned long chtype;
#line 151 "/usr/include/curses.h"
typedef unsigned long mmask_t;
#line 358
struct _win_st;
#line 358 "/usr/include/curses.h"
typedef struct _win_st WINDOW;
#line 360 "/usr/include/curses.h"
typedef chtype attr_t;
#line 405
struct ldat;
#line 407 "/usr/include/curses.h"
struct pdat {
   short _pad_y ;
   short _pad_x ;
   short _pad_top ;
   short _pad_left ;
   short _pad_bottom ;
   short _pad_right ;
};
#line 407 "/usr/include/curses.h"
struct _win_st {
   short _cury ;
   short _curx ;
   short _maxy ;
   short _maxx ;
   short _begy ;
   short _begx ;
   short _flags ;
   attr_t _attrs ;
   chtype _bkgd ;
   _Bool _notimeout ;
   _Bool _clear ;
   _Bool _leaveok ;
   _Bool _scroll ;
   _Bool _idlok ;
   _Bool _idcok ;
   _Bool _immed ;
   _Bool _sync ;
   _Bool _use_keypad ;
   int _delay ;
   struct ldat *_line ;
   short _regtop ;
   short _regbottom ;
   int _parx ;
   int _pary ;
   WINDOW *_parent ;
   struct pdat _pad ;
   short _yoffset ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 310 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/vpatch.c"
struct mp {
   int m ;
   int s ;
   int o ;
   int lineno ;
};
#line 319 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/vpatch.c"
struct mpos {
   struct mp p ;
   struct mp lo ;
   struct mp hi ;
   int state ;
};
#line 330 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/vpatch.c"
struct cursor {
   struct mp pos ;
   int offset ;
   int target ;
   int col ;
   int width ;
   int alt ;
};
#line 1211 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/vpatch.c"
struct search_anchor {
   struct search_anchor *next ;
   struct mpos pos ;
   struct cursor curs ;
   int notfound ;
   int row ;
   int start ;
   unsigned int searchlen ;
};
#line 74 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/bestmatch.c"
struct v___0 {
   int x ;
   int y ;
   int val ;
   int k ;
   int inmatch ;
   int c ;
};
#line 161 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/bestmatch.c"
struct best {
   int xlo ;
   int ylo ;
   int xhi ;
   int yhi ;
   int val ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 115 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/ccan/hash/hash.h"
uint32_t hash_u32(uint32_t const   *k , size_t length , uint32_t initval ) ;
#line 246
uint32_t hash_any(void const   *key , size_t length , uint32_t base ) ;
#line 247
uint32_t hash_stable_64(void const   *key , size_t n , uint32_t base ) ;
#line 248
uint32_t hash_stable_32(void const   *key , size_t n , uint32_t base ) ;
#line 249
uint32_t hash_stable_16(void const   *key , size_t n , uint32_t base ) ;
#line 250
uint32_t hash_stable_8(void const   *key , size_t n , uint32_t base ) ;
#line 251
uint64_t hash64_any(void const   *key , size_t length , uint64_t base ) ;
#line 252
uint64_t hash64_stable_64(void const   *key , size_t n , uint64_t base ) ;
#line 253
uint64_t hash64_stable_32(void const   *key , size_t n , uint64_t base ) ;
#line 254
uint64_t hash64_stable_16(void const   *key , size_t n , uint64_t base ) ;
#line 255
uint64_t hash64_stable_8(void const   *key , size_t n , uint64_t base ) ;
#line 188 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/ccan/hash/hash.c"
uint32_t hash_u32(uint32_t const   *k , size_t length , uint32_t initval ) 
{ 
  uint32_t a ;
  uint32_t b ;
  uint32_t c ;

  {
#line 196
  c = (3735928559U + ((uint32_t )length << 2)) + initval;
#line 196
  b = c;
#line 196
  a = b;
  {
#line 199
  while (1) {
    while_continue: /* CIL Label */ ;
#line 199
    if (! (length > 3UL)) {
#line 199
      goto while_break;
    }
#line 201
    a += (uint32_t )*(k + 0);
#line 202
    b += (uint32_t )*(k + 1);
#line 203
    c += (uint32_t )*(k + 2);
#line 204
    a -= c;
#line 204
    a ^= (c << 4) | (c >> 28);
#line 204
    c += b;
#line 204
    b -= a;
#line 204
    b ^= (a << 6) | (a >> 26);
#line 204
    a += c;
#line 204
    c -= b;
#line 204
    c ^= (b << 8) | (b >> 24);
#line 204
    b += a;
#line 204
    a -= c;
#line 204
    a ^= (c << 16) | (c >> 16);
#line 204
    c += b;
#line 204
    b -= a;
#line 204
    b ^= (a << 19) | (a >> 13);
#line 204
    a += c;
#line 204
    c -= b;
#line 204
    c ^= (b << 4) | (b >> 28);
#line 204
    b += a;
#line 205
    length -= 3UL;
#line 206
    k += 3;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 212
  if (length == 3UL) {
#line 212
    goto case_3;
  }
#line 213
  if (length == 2UL) {
#line 213
    goto case_2;
  }
#line 214
  if (length == 1UL) {
#line 214
    goto case_1;
  }
#line 216
  if (length == 0UL) {
#line 216
    goto case_0;
  }
#line 210
  goto switch_break;
  case_3: /* CIL Label */ 
#line 212
  c += (uint32_t )*(k + 2);
  case_2: /* CIL Label */ 
#line 213
  b += (uint32_t )*(k + 1);
  case_1: /* CIL Label */ 
#line 214
  a += (uint32_t )*(k + 0);
#line 215
  c ^= b;
#line 215
  c -= (b << 14) | (b >> 18);
#line 215
  a ^= c;
#line 215
  a -= (c << 11) | (c >> 21);
#line 215
  b ^= a;
#line 215
  b -= (a << 25) | (a >> 7);
#line 215
  c ^= b;
#line 215
  c -= (b << 16) | (b >> 16);
#line 215
  a ^= c;
#line 215
  a -= (c << 4) | (c >> 28);
#line 215
  b ^= a;
#line 215
  b -= (a << 14) | (a >> 18);
#line 215
  c ^= b;
#line 215
  c -= (b << 24) | (b >> 8);
  case_0: /* CIL Label */ 
#line 217
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 220
  return (c);
}
}
#line 251 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/ccan/hash/hash.c"
static uint32_t hashlittle(void const   *key , size_t length , uint32_t *val2 ) 
{ 
  uint32_t a ;
  uint32_t b ;
  uint32_t c ;
  union __anonunion_u_22 u ;
  uint32_t const   *k ;
  uint8_t const   *k8 ;
  uint16_t const   *k___0 ;
  uint8_t const   *k8___0 ;
  uint8_t const   *k___1 ;

  {
#line 257
  c = (3735928559U + (uint32_t )length) + *val2;
#line 257
  b = c;
#line 257
  a = b;
#line 259
  u.ptr = key;
#line 260
  if ((u.i & 3UL) == 0UL) {
#line 261
    k = (uint32_t const   *)key;
    {
#line 265
    while (1) {
      while_continue: /* CIL Label */ ;
#line 265
      if (! (length > 12UL)) {
#line 265
        goto while_break;
      }
#line 267
      a += (uint32_t )*(k + 0);
#line 268
      b += (uint32_t )*(k + 1);
#line 269
      c += (uint32_t )*(k + 2);
#line 270
      a -= c;
#line 270
      a ^= (c << 4) | (c >> 28);
#line 270
      c += b;
#line 270
      b -= a;
#line 270
      b ^= (a << 6) | (a >> 26);
#line 270
      a += c;
#line 270
      c -= b;
#line 270
      c ^= (b << 8) | (b >> 24);
#line 270
      b += a;
#line 270
      a -= c;
#line 270
      a ^= (c << 16) | (c >> 16);
#line 270
      c += b;
#line 270
      b -= a;
#line 270
      b ^= (a << 19) | (a >> 13);
#line 270
      a += c;
#line 270
      c -= b;
#line 270
      c ^= (b << 4) | (b >> 28);
#line 270
      b += a;
#line 271
      length -= 12UL;
#line 272
      k += 3;
    }
    while_break: /* CIL Label */ ;
    }
#line 307
    k8 = (uint8_t const   *)k;
    {
#line 310
    if (length == 12UL) {
#line 310
      goto case_12;
    }
#line 311
    if (length == 11UL) {
#line 311
      goto case_11;
    }
#line 312
    if (length == 10UL) {
#line 312
      goto case_10;
    }
#line 313
    if (length == 9UL) {
#line 313
      goto case_9;
    }
#line 314
    if (length == 8UL) {
#line 314
      goto case_8;
    }
#line 315
    if (length == 7UL) {
#line 315
      goto case_7;
    }
#line 316
    if (length == 6UL) {
#line 316
      goto case_6;
    }
#line 317
    if (length == 5UL) {
#line 317
      goto case_5;
    }
#line 318
    if (length == 4UL) {
#line 318
      goto case_4;
    }
#line 319
    if (length == 3UL) {
#line 319
      goto case_3;
    }
#line 320
    if (length == 2UL) {
#line 320
      goto case_2;
    }
#line 321
    if (length == 1UL) {
#line 321
      goto case_1;
    }
#line 322
    if (length == 0UL) {
#line 322
      goto case_0;
    }
#line 308
    goto switch_break;
    case_12: /* CIL Label */ 
#line 310
    c += (uint32_t )*(k + 2);
#line 310
    b += (uint32_t )*(k + 1);
#line 310
    a += (uint32_t )*(k + 0);
#line 310
    goto switch_break;
    case_11: /* CIL Label */ 
#line 311
    c += (uint32_t )*(k8 + 10) << 16;
    case_10: /* CIL Label */ 
#line 312
    c += (uint32_t )*(k8 + 9) << 8;
    case_9: /* CIL Label */ 
#line 313
    c += (uint32_t )*(k8 + 8);
    case_8: /* CIL Label */ 
#line 314
    b += (uint32_t )*(k + 1);
#line 314
    a += (uint32_t )*(k + 0);
#line 314
    goto switch_break;
    case_7: /* CIL Label */ 
#line 315
    b += (uint32_t )*(k8 + 6) << 16;
    case_6: /* CIL Label */ 
#line 316
    b += (uint32_t )*(k8 + 5) << 8;
    case_5: /* CIL Label */ 
#line 317
    b += (uint32_t )*(k8 + 4);
    case_4: /* CIL Label */ 
#line 318
    a += (uint32_t )*(k + 0);
#line 318
    goto switch_break;
    case_3: /* CIL Label */ 
#line 319
    a += (uint32_t )*(k8 + 2) << 16;
    case_2: /* CIL Label */ 
#line 320
    a += (uint32_t )*(k8 + 1) << 8;
    case_1: /* CIL Label */ 
#line 321
    a += (uint32_t )*(k8 + 0);
#line 321
    goto switch_break;
    case_0: /* CIL Label */ 
#line 322
    return (c);
    switch_break: /* CIL Label */ ;
    }
  } else
#line 327
  if ((u.i & 1UL) == 0UL) {
#line 328
    k___0 = (uint16_t const   *)key;
    {
#line 332
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 332
      if (! (length > 12UL)) {
#line 332
        goto while_break___0;
      }
#line 334
      a += (uint32_t )*(k___0 + 0) + ((uint32_t )*(k___0 + 1) << 16);
#line 335
      b += (uint32_t )*(k___0 + 2) + ((uint32_t )*(k___0 + 3) << 16);
#line 336
      c += (uint32_t )*(k___0 + 4) + ((uint32_t )*(k___0 + 5) << 16);
#line 337
      a -= c;
#line 337
      a ^= (c << 4) | (c >> 28);
#line 337
      c += b;
#line 337
      b -= a;
#line 337
      b ^= (a << 6) | (a >> 26);
#line 337
      a += c;
#line 337
      c -= b;
#line 337
      c ^= (b << 8) | (b >> 24);
#line 337
      b += a;
#line 337
      a -= c;
#line 337
      a ^= (c << 16) | (c >> 16);
#line 337
      c += b;
#line 337
      b -= a;
#line 337
      b ^= (a << 19) | (a >> 13);
#line 337
      a += c;
#line 337
      c -= b;
#line 337
      c ^= (b << 4) | (b >> 28);
#line 337
      b += a;
#line 338
      length -= 12UL;
#line 339
      k___0 += 6;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 343
    k8___0 = (uint8_t const   *)k___0;
    {
#line 346
    if (length == 12UL) {
#line 346
      goto case_12___0;
    }
#line 350
    if (length == 11UL) {
#line 350
      goto case_11___0;
    }
#line 351
    if (length == 10UL) {
#line 351
      goto case_10___0;
    }
#line 355
    if (length == 9UL) {
#line 355
      goto case_9___0;
    }
#line 356
    if (length == 8UL) {
#line 356
      goto case_8___0;
    }
#line 359
    if (length == 7UL) {
#line 359
      goto case_7___0;
    }
#line 360
    if (length == 6UL) {
#line 360
      goto case_6___0;
    }
#line 363
    if (length == 5UL) {
#line 363
      goto case_5___0;
    }
#line 364
    if (length == 4UL) {
#line 364
      goto case_4___0;
    }
#line 366
    if (length == 3UL) {
#line 366
      goto case_3___0;
    }
#line 367
    if (length == 2UL) {
#line 367
      goto case_2___0;
    }
#line 369
    if (length == 1UL) {
#line 369
      goto case_1___0;
    }
#line 371
    if (length == 0UL) {
#line 371
      goto case_0___0;
    }
#line 344
    goto switch_break___0;
    case_12___0: /* CIL Label */ 
#line 346
    c += (uint32_t )*(k___0 + 4) + ((uint32_t )*(k___0 + 5) << 16);
#line 347
    b += (uint32_t )*(k___0 + 2) + ((uint32_t )*(k___0 + 3) << 16);
#line 348
    a += (uint32_t )*(k___0 + 0) + ((uint32_t )*(k___0 + 1) << 16);
#line 349
    goto switch_break___0;
    case_11___0: /* CIL Label */ 
#line 350
    c += (uint32_t )*(k8___0 + 10) << 16;
    case_10___0: /* CIL Label */ 
#line 351
    c += (uint32_t )*(k___0 + 4);
#line 352
    b += (uint32_t )*(k___0 + 2) + ((uint32_t )*(k___0 + 3) << 16);
#line 353
    a += (uint32_t )*(k___0 + 0) + ((uint32_t )*(k___0 + 1) << 16);
#line 354
    goto switch_break___0;
    case_9___0: /* CIL Label */ 
#line 355
    c += (uint32_t )*(k8___0 + 8);
    case_8___0: /* CIL Label */ 
#line 356
    b += (uint32_t )*(k___0 + 2) + ((uint32_t )*(k___0 + 3) << 16);
#line 357
    a += (uint32_t )*(k___0 + 0) + ((uint32_t )*(k___0 + 1) << 16);
#line 358
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 359
    b += (uint32_t )*(k8___0 + 6) << 16;
    case_6___0: /* CIL Label */ 
#line 360
    b += (uint32_t )*(k___0 + 2);
#line 361
    a += (uint32_t )*(k___0 + 0) + ((uint32_t )*(k___0 + 1) << 16);
#line 362
    goto switch_break___0;
    case_5___0: /* CIL Label */ 
#line 363
    b += (uint32_t )*(k8___0 + 4);
    case_4___0: /* CIL Label */ 
#line 364
    a += (uint32_t )*(k___0 + 0) + ((uint32_t )*(k___0 + 1) << 16);
#line 365
    goto switch_break___0;
    case_3___0: /* CIL Label */ 
#line 366
    a += (uint32_t )*(k8___0 + 2) << 16;
    case_2___0: /* CIL Label */ 
#line 367
    a += (uint32_t )*(k___0 + 0);
#line 368
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
#line 369
    a += (uint32_t )*(k8___0 + 0);
#line 370
    goto switch_break___0;
    case_0___0: /* CIL Label */ 
#line 371
    return (c);
    switch_break___0: /* CIL Label */ ;
    }
  } else {
#line 375
    k___1 = (uint8_t const   *)key;
    {
#line 378
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 378
      if (! (length > 12UL)) {
#line 378
        goto while_break___1;
      }
#line 380
      a += (uint32_t )*(k___1 + 0);
#line 381
      a += (uint32_t )*(k___1 + 1) << 8;
#line 382
      a += (uint32_t )*(k___1 + 2) << 16;
#line 383
      a += (uint32_t )*(k___1 + 3) << 24;
#line 384
      b += (uint32_t )*(k___1 + 4);
#line 385
      b += (uint32_t )*(k___1 + 5) << 8;
#line 386
      b += (uint32_t )*(k___1 + 6) << 16;
#line 387
      b += (uint32_t )*(k___1 + 7) << 24;
#line 388
      c += (uint32_t )*(k___1 + 8);
#line 389
      c += (uint32_t )*(k___1 + 9) << 8;
#line 390
      c += (uint32_t )*(k___1 + 10) << 16;
#line 391
      c += (uint32_t )*(k___1 + 11) << 24;
#line 392
      a -= c;
#line 392
      a ^= (c << 4) | (c >> 28);
#line 392
      c += b;
#line 392
      b -= a;
#line 392
      b ^= (a << 6) | (a >> 26);
#line 392
      a += c;
#line 392
      c -= b;
#line 392
      c ^= (b << 8) | (b >> 24);
#line 392
      b += a;
#line 392
      a -= c;
#line 392
      a ^= (c << 16) | (c >> 16);
#line 392
      c += b;
#line 392
      b -= a;
#line 392
      b ^= (a << 19) | (a >> 13);
#line 392
      a += c;
#line 392
      c -= b;
#line 392
      c ^= (b << 4) | (b >> 28);
#line 392
      b += a;
#line 393
      length -= 12UL;
#line 394
      k___1 += 12;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 400
    if (length == 12UL) {
#line 400
      goto case_12___1;
    }
#line 401
    if (length == 11UL) {
#line 401
      goto case_11___1;
    }
#line 402
    if (length == 10UL) {
#line 402
      goto case_10___1;
    }
#line 403
    if (length == 9UL) {
#line 403
      goto case_9___1;
    }
#line 404
    if (length == 8UL) {
#line 404
      goto case_8___1;
    }
#line 405
    if (length == 7UL) {
#line 405
      goto case_7___1;
    }
#line 406
    if (length == 6UL) {
#line 406
      goto case_6___1;
    }
#line 407
    if (length == 5UL) {
#line 407
      goto case_5___1;
    }
#line 408
    if (length == 4UL) {
#line 408
      goto case_4___1;
    }
#line 409
    if (length == 3UL) {
#line 409
      goto case_3___1;
    }
#line 410
    if (length == 2UL) {
#line 410
      goto case_2___1;
    }
#line 411
    if (length == 1UL) {
#line 411
      goto case_1___1;
    }
#line 413
    if (length == 0UL) {
#line 413
      goto case_0___1;
    }
#line 398
    goto switch_break___1;
    case_12___1: /* CIL Label */ 
#line 400
    c += (uint32_t )*(k___1 + 11) << 24;
    case_11___1: /* CIL Label */ 
#line 401
    c += (uint32_t )*(k___1 + 10) << 16;
    case_10___1: /* CIL Label */ 
#line 402
    c += (uint32_t )*(k___1 + 9) << 8;
    case_9___1: /* CIL Label */ 
#line 403
    c += (uint32_t )*(k___1 + 8);
    case_8___1: /* CIL Label */ 
#line 404
    b += (uint32_t )*(k___1 + 7) << 24;
    case_7___1: /* CIL Label */ 
#line 405
    b += (uint32_t )*(k___1 + 6) << 16;
    case_6___1: /* CIL Label */ 
#line 406
    b += (uint32_t )*(k___1 + 5) << 8;
    case_5___1: /* CIL Label */ 
#line 407
    b += (uint32_t )*(k___1 + 4);
    case_4___1: /* CIL Label */ 
#line 408
    a += (uint32_t )*(k___1 + 3) << 24;
    case_3___1: /* CIL Label */ 
#line 409
    a += (uint32_t )*(k___1 + 2) << 16;
    case_2___1: /* CIL Label */ 
#line 410
    a += (uint32_t )*(k___1 + 1) << 8;
    case_1___1: /* CIL Label */ 
#line 411
    a += (uint32_t )*(k___1 + 0);
#line 412
    goto switch_break___1;
    case_0___1: /* CIL Label */ 
#line 413
    return (c);
    switch_break___1: /* CIL Label */ ;
    }
  }
#line 417
  c ^= b;
#line 417
  c -= (b << 14) | (b >> 18);
#line 417
  a ^= c;
#line 417
  a -= (c << 11) | (c >> 21);
#line 417
  b ^= a;
#line 417
  b -= (a << 25) | (a >> 7);
#line 417
  c ^= b;
#line 417
  c -= (b << 16) | (b >> 16);
#line 417
  a ^= c;
#line 417
  a -= (c << 4) | (c >> 28);
#line 417
  b ^= a;
#line 417
  b -= (a << 14) | (a >> 18);
#line 417
  c ^= b;
#line 417
  c -= (b << 24) | (b >> 8);
#line 418
  *val2 = b;
#line 419
  return (c);
}
}
#line 556 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/ccan/hash/hash.c"
uint64_t hash64_stable_64(void const   *key , size_t n , uint64_t base ) 
{ 
  uint64_t const   *k ;
  uint32_t a ;
  uint32_t b ;
  uint32_t c ;

  {
#line 558
  k = (uint64_t const   *)key;
#line 562
  c = (uint32_t )(((uint64_t )(3735928559U + (uint32_t )n * 8U) + (base >> 32)) + base);
#line 562
  b = c;
#line 562
  a = b;
  {
#line 564
  while (1) {
    while_continue: /* CIL Label */ ;
#line 564
    if (! (n > 3UL)) {
#line 564
      goto while_break;
    }
#line 565
    a += (uint32_t )*(k + 0);
#line 566
    b += (uint32_t )(*(k + 0) >> 32);
#line 567
    c += (uint32_t )*(k + 1);
#line 568
    a -= c;
#line 568
    a ^= (c << 4) | (c >> 28);
#line 568
    c += b;
#line 568
    b -= a;
#line 568
    b ^= (a << 6) | (a >> 26);
#line 568
    a += c;
#line 568
    c -= b;
#line 568
    c ^= (b << 8) | (b >> 24);
#line 568
    b += a;
#line 568
    a -= c;
#line 568
    a ^= (c << 16) | (c >> 16);
#line 568
    c += b;
#line 568
    b -= a;
#line 568
    b ^= (a << 19) | (a >> 13);
#line 568
    a += c;
#line 568
    c -= b;
#line 568
    c ^= (b << 4) | (b >> 28);
#line 568
    b += a;
#line 569
    a += (uint32_t )(*(k + 1) >> 32);
#line 570
    b += (uint32_t )*(k + 2);
#line 571
    c += (uint32_t )(*(k + 2) >> 32);
#line 572
    a -= c;
#line 572
    a ^= (c << 4) | (c >> 28);
#line 572
    c += b;
#line 572
    b -= a;
#line 572
    b ^= (a << 6) | (a >> 26);
#line 572
    a += c;
#line 572
    c -= b;
#line 572
    c ^= (b << 8) | (b >> 24);
#line 572
    b += a;
#line 572
    a -= c;
#line 572
    a ^= (c << 16) | (c >> 16);
#line 572
    c += b;
#line 572
    b -= a;
#line 572
    b ^= (a << 19) | (a >> 13);
#line 572
    a += c;
#line 572
    c -= b;
#line 572
    c ^= (b << 4) | (b >> 28);
#line 572
    b += a;
#line 573
    n -= 3UL;
#line 574
    k += 3;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 577
  if (n == 2UL) {
#line 577
    goto case_2;
  }
#line 584
  if (n == 1UL) {
#line 584
    goto case_1;
  }
#line 588
  if (n == 0UL) {
#line 588
    goto case_0;
  }
#line 576
  goto switch_break;
  case_2: /* CIL Label */ 
#line 578
  a += (uint32_t )*(k + 0);
#line 579
  b += (uint32_t )(*(k + 0) >> 32);
#line 580
  c += (uint32_t )*(k + 1);
#line 581
  a -= c;
#line 581
  a ^= (c << 4) | (c >> 28);
#line 581
  c += b;
#line 581
  b -= a;
#line 581
  b ^= (a << 6) | (a >> 26);
#line 581
  a += c;
#line 581
  c -= b;
#line 581
  c ^= (b << 8) | (b >> 24);
#line 581
  b += a;
#line 581
  a -= c;
#line 581
  a ^= (c << 16) | (c >> 16);
#line 581
  c += b;
#line 581
  b -= a;
#line 581
  b ^= (a << 19) | (a >> 13);
#line 581
  a += c;
#line 581
  c -= b;
#line 581
  c ^= (b << 4) | (b >> 28);
#line 581
  b += a;
#line 582
  a += (uint32_t )(*(k + 1) >> 32);
#line 583
  goto switch_break;
  case_1: /* CIL Label */ 
#line 585
  a += (uint32_t )*(k + 0);
#line 586
  b += (uint32_t )(*(k + 0) >> 32);
#line 587
  goto switch_break;
  case_0: /* CIL Label */ 
#line 589
  return ((uint64_t )c);
  switch_break: /* CIL Label */ ;
  }
#line 591
  c ^= b;
#line 591
  c -= (b << 14) | (b >> 18);
#line 591
  a ^= c;
#line 591
  a -= (c << 11) | (c >> 21);
#line 591
  b ^= a;
#line 591
  b -= (a << 25) | (a >> 7);
#line 591
  c ^= b;
#line 591
  c -= (b << 16) | (b >> 16);
#line 591
  a ^= c;
#line 591
  a -= (c << 4) | (c >> 28);
#line 591
  b ^= a;
#line 591
  b -= (a << 14) | (a >> 18);
#line 591
  c ^= b;
#line 591
  c -= (b << 24) | (b >> 8);
#line 592
  return (((uint64_t )b << 32) | (unsigned long )c);
}
}
#line 595 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/ccan/hash/hash.c"
uint64_t hash64_stable_32(void const   *key , size_t n , uint64_t base ) 
{ 
  uint32_t const   *k ;
  uint32_t a ;
  uint32_t b ;
  uint32_t c ;

  {
#line 597
  k = (uint32_t const   *)key;
#line 601
  c = (uint32_t )(((uint64_t )(3735928559U + (uint32_t )n * 4U) + (base >> 32)) + base);
#line 601
  b = c;
#line 601
  a = b;
  {
#line 603
  while (1) {
    while_continue: /* CIL Label */ ;
#line 603
    if (! (n > 3UL)) {
#line 603
      goto while_break;
    }
#line 604
    a += (uint32_t )*(k + 0);
#line 605
    b += (uint32_t )*(k + 1);
#line 606
    c += (uint32_t )*(k + 2);
#line 607
    a -= c;
#line 607
    a ^= (c << 4) | (c >> 28);
#line 607
    c += b;
#line 607
    b -= a;
#line 607
    b ^= (a << 6) | (a >> 26);
#line 607
    a += c;
#line 607
    c -= b;
#line 607
    c ^= (b << 8) | (b >> 24);
#line 607
    b += a;
#line 607
    a -= c;
#line 607
    a ^= (c << 16) | (c >> 16);
#line 607
    c += b;
#line 607
    b -= a;
#line 607
    b ^= (a << 19) | (a >> 13);
#line 607
    a += c;
#line 607
    c -= b;
#line 607
    c ^= (b << 4) | (b >> 28);
#line 607
    b += a;
#line 609
    n -= 3UL;
#line 610
    k += 3;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 613
  if (n == 2UL) {
#line 613
    goto case_2;
  }
#line 615
  if (n == 1UL) {
#line 615
    goto case_1;
  }
#line 618
  if (n == 0UL) {
#line 618
    goto case_0;
  }
#line 612
  goto switch_break;
  case_2: /* CIL Label */ 
#line 614
  b += (uint32_t )*(k + 1);
  case_1: /* CIL Label */ 
#line 616
  a += (uint32_t )*(k + 0);
#line 617
  goto switch_break;
  case_0: /* CIL Label */ 
#line 619
  return ((uint64_t )c);
  switch_break: /* CIL Label */ ;
  }
#line 621
  c ^= b;
#line 621
  c -= (b << 14) | (b >> 18);
#line 621
  a ^= c;
#line 621
  a -= (c << 11) | (c >> 21);
#line 621
  b ^= a;
#line 621
  b -= (a << 25) | (a >> 7);
#line 621
  c ^= b;
#line 621
  c -= (b << 16) | (b >> 16);
#line 621
  a ^= c;
#line 621
  a -= (c << 4) | (c >> 28);
#line 621
  b ^= a;
#line 621
  b -= (a << 14) | (a >> 18);
#line 621
  c ^= b;
#line 621
  c -= (b << 24) | (b >> 8);
#line 622
  return (((uint64_t )b << 32) | (unsigned long )c);
}
}
#line 625 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/ccan/hash/hash.c"
uint64_t hash64_stable_16(void const   *key , size_t n , uint64_t base ) 
{ 
  uint16_t const   *k ;
  uint32_t a ;
  uint32_t b ;
  uint32_t c ;

  {
#line 627
  k = (uint16_t const   *)key;
#line 631
  c = (uint32_t )(((uint64_t )(3735928559U + (uint32_t )n * 2U) + (base >> 32)) + base);
#line 631
  b = c;
#line 631
  a = b;
  {
#line 633
  while (1) {
    while_continue: /* CIL Label */ ;
#line 633
    if (! (n > 6UL)) {
#line 633
      goto while_break;
    }
#line 634
    a += (uint32_t )*(k + 0) + ((uint32_t )*(k + 1) << 16);
#line 635
    b += (uint32_t )*(k + 2) + ((uint32_t )*(k + 3) << 16);
#line 636
    c += (uint32_t )*(k + 4) + ((uint32_t )*(k + 5) << 16);
#line 637
    a -= c;
#line 637
    a ^= (c << 4) | (c >> 28);
#line 637
    c += b;
#line 637
    b -= a;
#line 637
    b ^= (a << 6) | (a >> 26);
#line 637
    a += c;
#line 637
    c -= b;
#line 637
    c ^= (b << 8) | (b >> 24);
#line 637
    b += a;
#line 637
    a -= c;
#line 637
    a ^= (c << 16) | (c >> 16);
#line 637
    c += b;
#line 637
    b -= a;
#line 637
    b ^= (a << 19) | (a >> 13);
#line 637
    a += c;
#line 637
    c -= b;
#line 637
    c ^= (b << 4) | (b >> 28);
#line 637
    b += a;
#line 639
    n -= 6UL;
#line 640
    k += 6;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 644
  if (n == 5UL) {
#line 644
    goto case_5;
  }
#line 646
  if (n == 4UL) {
#line 646
    goto case_4;
  }
#line 648
  if (n == 3UL) {
#line 648
    goto case_3;
  }
#line 650
  if (n == 2UL) {
#line 650
    goto case_2;
  }
#line 652
  if (n == 1UL) {
#line 652
    goto case_1;
  }
#line 655
  if (n == 0UL) {
#line 655
    goto case_0;
  }
#line 643
  goto switch_break;
  case_5: /* CIL Label */ 
#line 645
  c += (uint32_t )*(k + 4);
  case_4: /* CIL Label */ 
#line 647
  b += (uint32_t )*(k + 3) << 16;
  case_3: /* CIL Label */ 
#line 649
  b += (uint32_t )*(k + 2);
  case_2: /* CIL Label */ 
#line 651
  a += (uint32_t )*(k + 1) << 16;
  case_1: /* CIL Label */ 
#line 653
  a += (uint32_t )*(k + 0);
#line 654
  goto switch_break;
  case_0: /* CIL Label */ 
#line 656
  return ((uint64_t )c);
  switch_break: /* CIL Label */ ;
  }
#line 658
  c ^= b;
#line 658
  c -= (b << 14) | (b >> 18);
#line 658
  a ^= c;
#line 658
  a -= (c << 11) | (c >> 21);
#line 658
  b ^= a;
#line 658
  b -= (a << 25) | (a >> 7);
#line 658
  c ^= b;
#line 658
  c -= (b << 16) | (b >> 16);
#line 658
  a ^= c;
#line 658
  a -= (c << 4) | (c >> 28);
#line 658
  b ^= a;
#line 658
  b -= (a << 14) | (a >> 18);
#line 658
  c ^= b;
#line 658
  c -= (b << 24) | (b >> 8);
#line 659
  return (((uint64_t )b << 32) | (unsigned long )c);
}
}
#line 662 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/ccan/hash/hash.c"
uint64_t hash64_stable_8(void const   *key , size_t n , uint64_t base ) 
{ 
  uint32_t b32 ;
  uint32_t lower ;
  uint32_t tmp ;

  {
  {
#line 664
  b32 = (uint32_t )(base + (base >> 32));
#line 665
  tmp = hashlittle(key, n, & b32);
#line 665
  lower = tmp;
  }
#line 667
  return (((uint64_t )b32 << 32) | (unsigned long )lower);
}
}
#line 670 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/ccan/hash/hash.c"
uint32_t hash_any(void const   *key , size_t length , uint32_t base ) 
{ 
  uint32_t tmp___0 ;

  {
  {
#line 675
  tmp___0 = hashlittle(key, length, & base);
  }
#line 675
  return (tmp___0);
}
}
#line 678 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/ccan/hash/hash.c"
uint32_t hash_stable_64(void const   *key , size_t n , uint32_t base ) 
{ 
  uint64_t tmp ;

  {
  {
#line 680
  tmp = hash64_stable_64(key, n, (uint64_t )base);
  }
#line 680
  return ((uint32_t )tmp);
}
}
#line 683 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/ccan/hash/hash.c"
uint32_t hash_stable_32(void const   *key , size_t n , uint32_t base ) 
{ 
  uint64_t tmp ;

  {
  {
#line 685
  tmp = hash64_stable_32(key, n, (uint64_t )base);
  }
#line 685
  return ((uint32_t )tmp);
}
}
#line 688 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/ccan/hash/hash.c"
uint32_t hash_stable_16(void const   *key , size_t n , uint32_t base ) 
{ 
  uint64_t tmp ;

  {
  {
#line 690
  tmp = hash64_stable_16(key, n, (uint64_t )base);
  }
#line 690
  return ((uint32_t )tmp);
}
}
#line 693 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/ccan/hash/hash.c"
uint32_t hash_stable_8(void const   *key , size_t n , uint32_t base ) 
{ 
  uint32_t tmp ;

  {
  {
#line 695
  tmp = hashlittle(key, n, & base);
  }
#line 695
  return (tmp);
}
}
#line 700 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/ccan/hash/hash.c"
uint64_t hash64_any(void const   *key , size_t length , uint64_t base ) 
{ 
  uint32_t b32 ;
  uint32_t lower ;

  {
  {
#line 702
  b32 = (uint32_t )(base + (base >> 32));
#line 708
  lower = hashlittle(key, length, & b32);
  }
#line 710
  return (((uint64_t )b32 << 32) | (unsigned long )lower);
}
}
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 531
extern int fgetc(FILE *__stream ) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 754
extern long ftell(FILE *__stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 515
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 765
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 31 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/wiggle.h"
__inline static void assert(int a ) 
{ 


  {
#line 33
  if (! a) {
    {
#line 34
    abort();
    }
  }
#line 35
  return;
}
}
#line 147
struct plist *sort_patches(struct plist *pl , int *np ) ;
#line 148
struct plist *parse_patch(FILE *f , FILE *of , int *np ) ;
#line 151
int set_prefix(struct plist *pl , int n , int strip ) ;
#line 185
char *Cmd ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 39 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/parse.c"
static int get_strip(char *file ) 
{ 
  int fd ;
  int strip ;

  {
#line 42
  strip = 0;
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    if (file) {
#line 44
      if (! *file) {
#line 44
        goto while_break;
      }
    } else {
#line 44
      goto while_break;
    }
    {
#line 45
    fd = open((char const   *)file, 0);
    }
#line 46
    if (fd >= 0) {
      {
#line 47
      close(fd);
      }
#line 48
      return (strip);
    }
    {
#line 50
    strip ++;
#line 51
    file = strchr((char const   *)file, '/');
    }
#line 52
    if (file) {
      {
#line 53
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 53
        if (! ((int )*file == 47)) {
#line 53
          goto while_break___0;
        }
#line 54
        file ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 56
  return (-1);
}
}
#line 60 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/parse.c"
int set_prefix(struct plist *pl , int n , int strip ) 
{ 
  int i ;
  char *p ;
  int j ;

  {
#line 63
  i = 0;
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    if (i < 4) {
#line 63
      if (i < n) {
#line 63
        if (! (strip < 0)) {
#line 63
          goto while_break;
        }
      } else {
#line 63
        goto while_break;
      }
    } else {
#line 63
      goto while_break;
    }
    {
#line 64
    strip = get_strip((pl + i)->file);
#line 63
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 66
  if (strip < 0) {
    {
#line 67
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Cannot find files to patch: please specify --strip\n",
            Cmd);
    }
#line 69
    return (0);
  }
#line 71
  i = 0;
  {
#line 71
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 71
    if (! (i < n)) {
#line 71
      goto while_break___0;
    }
#line 72
    p = (pl + i)->file;
#line 74
    j = 0;
    {
#line 74
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 74
      if (! (j < strip)) {
#line 74
        goto while_break___1;
      }
#line 75
      if (p) {
        {
#line 76
        p = strchr((char const   *)p, '/');
        }
      }
      {
#line 77
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 77
        if (p) {
#line 77
          if (! ((int )*p == 47)) {
#line 77
            goto while_break___2;
          }
        } else {
#line 77
          goto while_break___2;
        }
#line 78
        p ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 74
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 80
    if ((unsigned long )p == (unsigned long )((void *)0)) {
      {
#line 81
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: cannot strip %d segments from %s\n",
              Cmd, strip, (pl + i)->file);
      }
#line 83
      return (0);
    }
#line 85
    (pl + i)->file = p;
#line 71
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 87
  return (1);
}
}
#line 90 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/parse.c"
static int pl_cmp(void const   *av , void const   *bv ) 
{ 
  struct plist  const  *a ;
  struct plist  const  *b ;
  int tmp ;

  {
  {
#line 92
  a = (struct plist  const  *)av;
#line 93
  b = (struct plist  const  *)bv;
#line 94
  tmp = strcmp((char const   *)a->file, (char const   *)b->file);
  }
#line 94
  return (tmp);
}
}
#line 97 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/parse.c"
static int common_depth(char *a , char *b ) 
{ 
  int depth ;
  char *c ;
  int al ;
  int bl ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
#line 102
  depth = 0;
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 106
    c = strchr((char const   *)a, '/');
    }
#line 107
    if (c) {
#line 108
      al = (int )(c - a);
    } else {
      {
#line 110
      tmp = strlen((char const   *)a);
#line 110
      al = (int )tmp;
      }
    }
    {
#line 111
    c = strchr((char const   *)b, '/');
    }
#line 112
    if (c) {
#line 113
      bl = (int )(c - b);
    } else {
      {
#line 115
      tmp___0 = strlen((char const   *)b);
#line 115
      bl = (int )tmp___0;
      }
    }
#line 116
    if (al == 0) {
#line 117
      return (depth);
    } else
#line 116
    if (al != bl) {
#line 117
      return (depth);
    } else {
      {
#line 116
      tmp___1 = strncmp((char const   *)a, (char const   *)b, (size_t )al);
      }
#line 116
      if (tmp___1 != 0) {
#line 117
        return (depth);
      }
    }
#line 118
    a += al;
    {
#line 119
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 119
      if (! ((int )*a == 47)) {
#line 119
        goto while_break___0;
      }
#line 120
      a ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 121
    b += bl;
    {
#line 122
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 122
      if (! ((int )*b == 47)) {
#line 122
        goto while_break___1;
      }
#line 123
      b ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 125
    depth ++;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 129 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/parse.c"
static struct plist *patch_add_file(struct plist *pl , int *np , char *file , unsigned int start ,
                                    unsigned int end ) 
{ 
  int n ;
  int asize ;
  struct plist *npl ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 133
  n = *np;
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    if (! ((int )*file == 47)) {
#line 136
      goto while_break;
    }
#line 138
    file ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 140
  if (n == 0) {
#line 141
    asize = 0;
  } else
#line 142
  if (n <= 16) {
#line 143
    asize = 16;
  } else
#line 144
  if ((n & (n - 1)) == 0) {
#line 145
    asize = n;
  } else {
#line 147
    asize = n + 1;
  }
#line 148
  if (asize <= n) {
#line 151
    if (asize < 16) {
#line 152
      asize = 16;
    } else {
#line 154
      asize += asize;
    }
    {
#line 155
    tmp = realloc((void *)pl, (unsigned long )asize * sizeof(struct plist ));
#line 155
    npl = (struct plist *)tmp;
    }
#line 156
    if (! npl) {
      {
#line 157
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"realloc failed - skipping %s\n",
              file);
      }
#line 158
      return (pl);
    }
#line 160
    pl = npl;
  }
#line 162
  (pl + n)->file = file;
#line 163
  (pl + n)->start = start;
#line 164
  (pl + n)->end = end;
#line 165
  tmp___2 = -1;
#line 165
  (pl + n)->parent = tmp___2;
#line 165
  tmp___1 = tmp___2;
#line 165
  (pl + n)->prev = tmp___1;
#line 165
  tmp___0 = tmp___1;
#line 165
  (pl + n)->next = tmp___0;
#line 165
  (pl + n)->last = tmp___0;
#line 166
  tmp___3 = 0;
#line 166
  (pl + n)->wiggles = tmp___3;
#line 166
  (pl + n)->chunks = tmp___3;
#line 166
  (pl + n)->conflicts = 100;
#line 167
  (pl + n)->open = 1;
#line 168
  (pl + n)->calced = 0;
#line 169
  (pl + n)->is_merge = 0;
#line 170
  *np = n + 1;
#line 171
  return (pl);
}
}
#line 174 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/parse.c"
static struct plist *add_dir(struct plist *pl , int *np , char *file , char *curr ) 
{ 
  int d ;
  int tmp ;
  char *buf ;
  char *c ;
  char *tmp___0 ;
  int l ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 179
  tmp = common_depth(file, curr);
#line 179
  d = tmp;
#line 180
  buf = curr;
  }
  {
#line 181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 181
    if (! d) {
#line 181
      goto while_break;
    }
    {
#line 182
    tmp___0 = strchr((char const   *)file, '/');
#line 182
    c = tmp___0;
    }
#line 184
    if (c) {
#line 185
      l = (int )(c - file);
    } else {
      {
#line 187
      tmp___1 = strlen((char const   *)file);
#line 187
      l = (int )tmp___1;
      }
    }
#line 188
    file += l;
#line 189
    curr += l;
    {
#line 190
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 190
      if (! ((int )*file == 47)) {
#line 190
        goto while_break___0;
      }
#line 191
      file ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 192
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 192
      if (! ((int )*curr == 47)) {
#line 192
        goto while_break___1;
      }
#line 193
      curr ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 194
    d --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 196
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 196
    if (! *file) {
#line 196
      goto while_break___2;
    }
#line 197
    if ((unsigned long )curr > (unsigned long )buf) {
#line 197
      if ((int )*(curr + -1) != 47) {
#line 198
        tmp___2 = curr;
#line 198
        curr ++;
#line 198
        *tmp___2 = (char )'/';
      }
    }
    {
#line 199
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 199
      if (*file) {
#line 199
        if (! ((int )*file != 47)) {
#line 199
          goto while_break___3;
        }
      } else {
#line 199
        goto while_break___3;
      }
#line 200
      tmp___3 = curr;
#line 200
      curr ++;
#line 200
      tmp___4 = file;
#line 200
      file ++;
#line 200
      *tmp___3 = *tmp___4;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 201
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 201
      if (! ((int )*file == 47)) {
#line 201
        goto while_break___4;
      }
#line 202
      file ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 203
    *curr = (char )'\000';
#line 204
    if (*file) {
      {
#line 205
      tmp___5 = strdup((char const   *)buf);
#line 205
      pl = patch_add_file(pl, np, tmp___5, 0U, 0U);
      }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 208
  return (pl);
}
}
#line 211 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/parse.c"
struct plist *sort_patches(struct plist *pl , int *np ) 
{ 
  char curr[1024] ;
  char *prev ;
  int parents[100] ;
  int prevnode[100] ;
  int i ;
  int n ;
  int d ;
  int tmp ;

  {
  {
#line 219
  qsort((void *)pl, (size_t )*np, sizeof(struct plist ), & pl_cmp);
#line 220
  curr[0] = (char)0;
#line 221
  n = *np;
#line 222
  i = 0;
  }
  {
#line 222
  while (1) {
    while_continue: /* CIL Label */ ;
#line 222
    if (! (i < n)) {
#line 222
      goto while_break;
    }
    {
#line 223
    pl = add_dir(pl, np, (pl + i)->file, curr);
#line 222
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 225
  qsort((void *)pl, (size_t )*np, sizeof(struct plist ), & pl_cmp);
#line 228
  n = *np;
#line 229
  curr[0] = (char)0;
#line 230
  prevnode[0] = -1;
#line 231
  prev = (char *)"";
#line 232
  i = 0;
  }
  {
#line 232
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 232
    if (! (i < n)) {
#line 232
      goto while_break___0;
    }
    {
#line 233
    tmp = common_depth(prev, (pl + i)->file);
#line 233
    d = tmp;
    }
#line 234
    if (d == 0) {
#line 235
      (pl + i)->parent = -1;
    } else {
#line 237
      (pl + i)->parent = parents[d - 1];
#line 238
      (pl + (pl + i)->parent)->last = i;
    }
#line 240
    (pl + i)->prev = prevnode[d];
#line 241
    if ((pl + i)->prev > -1) {
#line 242
      (pl + (pl + i)->prev)->next = i;
    }
#line 243
    prev = (pl + i)->file;
#line 244
    parents[d] = i;
#line 245
    prevnode[d] = i;
#line 246
    prevnode[d + 1] = -1;
#line 232
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 248
  return (pl);
}
}
#line 251 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/parse.c"
struct plist *parse_patch(FILE *f , FILE *of , int *np ) 
{ 
  struct plist *plist ;
  char *target ;
  char *target2 ;
  char *pos ;
  int c ;
  char name[1024] ;
  unsigned int start ;
  unsigned int end ;
  char *tmp ;
  FILE *tmp___0 ;
  long tmp___1 ;
  FILE *tmp___2 ;
  long tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
#line 258
  plist = (struct plist *)((void *)0);
#line 260
  *np = 0;
  {
#line 261
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 261
    tmp___5 = feof(f);
    }
#line 261
    if (tmp___5) {
#line 261
      goto while_break;
    }
#line 265
    target = (char *)"\n+++ ";
#line 266
    target2 = (char *)"\n--- ";
#line 267
    pos = target;
    {
#line 272
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 272
      if (*pos) {
        {
#line 272
        c = fgetc(f);
        }
#line 272
        if (! (c != -1)) {
#line 272
          goto while_break___0;
        }
      } else {
#line 272
        goto while_break___0;
      }
#line 273
      if (of) {
        {
#line 274
        fputc(c, of);
        }
      }
#line 275
      if (c == (int )*pos) {
#line 276
        pos ++;
      } else {
#line 278
        pos = target;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 280
    if (c == -1) {
#line 281
      goto while_break;
    }
    {
#line 282
    assert(c == 32);
#line 284
    pos = name;
    }
    {
#line 285
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 285
      c = fgetc(f);
      }
#line 285
      if (c != -1) {
#line 285
        if (c != 9) {
#line 285
          if (c != 10) {
#line 285
            if (c != 32) {
#line 285
              if (! (pos - name < 1023L)) {
#line 285
                goto while_break___1;
              }
            } else {
#line 285
              goto while_break___1;
            }
          } else {
#line 285
            goto while_break___1;
          }
        } else {
#line 285
          goto while_break___1;
        }
      } else {
#line 285
        goto while_break___1;
      }
#line 288
      tmp = pos;
#line 288
      pos ++;
#line 288
      *tmp = (char )c;
#line 289
      if (of) {
        {
#line 290
        fputc(c, of);
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 292
    *pos = (char)0;
#line 293
    if (c == -1) {
#line 294
      goto while_break;
    }
#line 295
    if (of) {
      {
#line 296
      fputc(c, of);
      }
    }
    {
#line 297
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 297
      if (c != 10) {
        {
#line 297
        c = fgetc(f);
        }
#line 297
        if (! (c != -1)) {
#line 297
          goto while_break___2;
        }
      } else {
#line 297
        goto while_break___2;
      }
#line 298
      if (of) {
        {
#line 299
        fputc(c, of);
        }
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 301
    tmp___0 = of;
#line 301
    if (! tmp___0) {
#line 301
      tmp___0 = f;
    }
    {
#line 301
    tmp___1 = ftell(tmp___0);
#line 301
    start = (unsigned int )tmp___1;
    }
#line 303
    if (c == -1) {
#line 304
      goto while_break;
    }
#line 307
    pos = target2 + 1;
    {
#line 309
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 309
      if (*pos) {
        {
#line 309
        c = fgetc(f);
        }
#line 309
        if (! (c != -1)) {
#line 309
          goto while_break___3;
        }
      } else {
#line 309
        goto while_break___3;
      }
#line 310
      if (of) {
        {
#line 311
        fputc(c, of);
        }
      }
#line 312
      if (c == (int )*pos) {
#line 313
        pos ++;
      } else {
#line 315
        pos = target2;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 317
    tmp___2 = of;
#line 317
    if (! tmp___2) {
#line 317
      tmp___2 = f;
    }
    {
#line 317
    tmp___3 = ftell(tmp___2);
#line 317
    end = (unsigned int )tmp___3;
    }
#line 318
    if ((unsigned long )pos > (unsigned long )target2) {
#line 319
      end = (unsigned int )((long )end - ((pos - target2) - 1L));
    }
    {
#line 320
    tmp___4 = strdup((char const   *)(name));
#line 320
    plist = patch_add_file(plist, np, tmp___4, start, end);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 323
  return (plist);
}
}
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 775
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) abs)(int __x )  __attribute__((__const__)) ;
#line 57 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/wiggle.h"
__inline static int match(struct elmnt *a , struct elmnt *b ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 59
  if (a->hash == b->hash) {
#line 59
    if (a->len == b->len) {
      {
#line 59
      tmp = strncmp((char const   *)a->start, (char const   *)b->start, (size_t )a->len);
      }
#line 59
      if (tmp == 0) {
#line 59
        tmp___0 = 1;
      } else {
#line 59
        tmp___0 = 0;
      }
    } else {
#line 59
      tmp___0 = 0;
    }
  } else {
#line 59
    tmp___0 = 0;
  }
#line 59
  return (tmp___0);
}
}
#line 70 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/wiggle.h"
__inline static int ends_line(struct elmnt e ) 
{ 
  int tmp ;

  {
#line 72
  if (e.len == 20) {
#line 72
    if ((int )*(e.start + 0) == 0) {
#line 73
      return (1);
    }
  }
#line 74
  if (e.len) {
#line 74
    if ((int )*(e.start + (e.len - 1)) == 10) {
#line 74
      tmp = 1;
    } else {
#line 74
      tmp = 0;
    }
  } else {
#line 74
    tmp = 0;
  }
#line 74
  return (tmp);
}
}
#line 158
struct csl *diff(struct file a , struct file b ) ;
#line 159
struct csl *diff_partial(struct file a , struct file b , int alo , int ahi , int blo ,
                         int bhi ) ;
#line 179
void *xmalloc(int size ) ;
#line 140 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/diff.c"
static int find_common(struct file *a , struct file *b , int *alop , int *ahip , int *blop ,
                       int *bhip , struct v *v ) 
{ 
  int klo ;
  int khi ;
  int alo ;
  int ahi ;
  int blo ;
  int bhi ;
  int mid ;
  int worst ;
  int x ;
  int y ;
  int cost ;
  int k ;
  int snake ;
  int tmp ;
  int tmp___0 ;

  {
#line 164
  alo = *alop;
#line 165
  ahi = *ahip;
#line 166
  blo = *blop;
#line 167
  bhi = *bhip;
#line 169
  mid = (((ahi + bhi) + alo) + blo) / 2;
#line 178
  worst = (ahi - alo) + (bhi - blo);
#line 180
  khi = alo - blo;
#line 180
  klo = khi;
#line 181
  (v + klo)->x = alo;
#line 182
  (v + klo)->l = 0;
  {
#line 184
  while (1) {
    while_continue: /* CIL Label */ ;
#line 193
    k = klo;
    {
#line 193
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 193
      if (! (k <= khi)) {
#line 193
        goto while_break___0;
      }
#line 194
      snake = 0;
#line 196
      x = (v + k)->x;
#line 197
      y = x - k;
#line 198
      if (y > bhi) {
        {
#line 199
        abort();
        }
      }
      {
#line 202
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 202
        if (x < ahi) {
#line 202
          if (y < bhi) {
            {
#line 202
            tmp = match(a->list + x, b->list + y);
            }
#line 202
            if (! tmp) {
#line 202
              goto while_break___1;
            }
          } else {
#line 202
            goto while_break___1;
          }
        } else {
#line 202
          goto while_break___1;
        }
#line 205
        x ++;
#line 206
        y ++;
#line 207
        snake = 1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 211
      cost = (ahi - x) + (bhi - y);
#line 212
      if (cost < worst) {
#line 213
        worst = cost;
      }
#line 216
      if (x + y >= mid) {
#line 216
        if (((v + k)->x + (v + k)->x) - k <= mid) {
#line 218
          (v + k)->md = k;
        }
      }
#line 220
      (v + k)->x = x;
#line 221
      (v + k)->l += snake;
#line 223
      if (cost == 0) {
#line 227
        if (x != ahi) {
          {
#line 228
          abort();
          }
        }
#line 239
        x = ((v + k)->md + mid) / 2;
#line 240
        y = x - (v + k)->md;
#line 242
        *alop = x;
#line 243
        *blop = y;
        {
#line 249
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 249
          if (x < ahi) {
#line 249
            if (y < bhi) {
              {
#line 249
              tmp___0 = match(a->list + x, b->list + y);
              }
#line 249
              if (! tmp___0) {
#line 249
                goto while_break___2;
              }
            } else {
#line 249
              goto while_break___2;
            }
          } else {
#line 249
            goto while_break___2;
          }
#line 252
          x ++;
#line 253
          y ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 255
        *ahip = x;
#line 256
        *bhip = y;
#line 258
        return ((v + k)->l);
      }
#line 193
      k += 2;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 266
    k = klo + 1;
    {
#line 266
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 266
      if (! (k <= khi - 1)) {
#line 266
        goto while_break___3;
      }
#line 267
      if ((v + (k - 1))->x + 1 > ahi) {
#line 272
        *(v + k) = *(v + (k + 1));
      } else
#line 273
      if ((v + (k + 1))->x - k > bhi) {
#line 279
        *(v + k) = *(v + (k - 1));
#line 280
        ((v + k)->x) ++;
      } else
#line 273
      if ((v + (k - 1))->x + 1 >= (v + (k + 1))->x) {
#line 279
        *(v + k) = *(v + (k - 1));
#line 280
        ((v + k)->x) ++;
      } else {
#line 286
        *(v + k) = *(v + (k + 1));
      }
#line 266
      k += 2;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 303
    x = (v + klo)->x;
#line 303
    y = x - (klo - 1);
#line 304
    cost = abs((ahi - x) - (bhi - y));
    }
#line 305
    if (y <= bhi) {
#line 305
      if (cost <= worst) {
#line 307
        *(v + (klo - 1)) = *(v + klo);
#line 308
        klo --;
      } else {
#line 310
        klo ++;
      }
    } else {
#line 310
      klo ++;
    }
    {
#line 313
    x = (v + khi)->x + 1;
#line 313
    y = x - (khi + 1);
#line 314
    cost = abs((ahi - x) - (bhi - y));
    }
#line 315
    if (x <= ahi) {
#line 315
      if (cost <= worst) {
#line 317
        *(v + (khi + 1)) = *(v + khi);
#line 318
        ((v + (khi + 1))->x) ++;
#line 319
        khi ++;
      } else {
#line 321
        khi --;
      }
    } else {
#line 321
      khi --;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 325 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/diff.c"
static struct csl *lcsl(struct file *a , int alo , int ahi , struct file *b , int blo ,
                        int bhi , struct csl *csl , struct v *v ) 
{ 
  int len ;
  int alo1 ;
  int ahi1 ;
  int blo1 ;
  int bhi1 ;
  struct csl *rv ;
  void *tmp ;

  {
#line 340
  alo1 = alo;
#line 341
  ahi1 = ahi;
#line 342
  blo1 = blo;
#line 343
  bhi1 = bhi;
#line 344
  rv = (struct csl *)((void *)0);
#line 346
  if (ahi <= alo) {
#line 347
    return (csl);
  } else
#line 346
  if (bhi <= blo) {
#line 347
    return (csl);
  }
  {
#line 349
  len = find_common(a, b, & alo1, & ahi1, & blo1, & bhi1, v);
  }
#line 354
  if ((unsigned long )csl == (unsigned long )((void *)0)) {
    {
#line 356
    tmp = xmalloc((int )((unsigned long )(len + 1) * sizeof(*csl)));
#line 356
    csl = (struct csl *)tmp;
#line 356
    rv = csl;
#line 357
    csl->len = 0;
    }
  }
#line 359
  if (len) {
    {
#line 365
    csl = lcsl(a, alo, alo1, b, blo, blo1, csl, v);
    }
#line 369
    if (ahi1 > alo1) {
#line 373
      if (csl->len) {
#line 373
        if (csl->a + csl->len == alo1) {
#line 373
          if (csl->b + csl->len == blo1) {
#line 376
            csl->len += ahi1 - alo1;
          } else {
#line 373
            goto _L___0;
          }
        } else {
#line 373
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 378
        if (csl->len) {
#line 379
          csl ++;
        }
#line 380
        csl->len = ahi1 - alo1;
#line 381
        csl->a = alo1;
#line 382
        csl->b = blo1;
#line 383
        (csl + 1)->len = 0;
      }
    }
    {
#line 387
    csl = lcsl(a, ahi1, ahi, b, bhi1, bhi, csl, v);
    }
  }
#line 391
  if (rv) {
#line 396
    if (csl->len) {
#line 397
      csl ++;
    }
#line 398
    csl->a = ahi;
#line 399
    csl->b = bhi;
#line 401
    if ((unsigned long )(rv + len) != (unsigned long )csl) {
      {
#line 402
      abort();
      }
    } else
#line 401
    if (csl->len != 0) {
      {
#line 402
      abort();
      }
    }
#line 404
    return (rv);
  } else {
#line 407
    return (csl);
  }
}
}
#line 429 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/diff.c"
static void fixup(struct file *a , struct file *b , struct csl *list ) 
{ 
  struct csl *list1 ;
  struct csl *orig ;
  int lasteol ;
  int found_end ;
  int tmp ;
  struct csl *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 432
  lasteol = -1;
#line 433
  found_end = 0;
#line 435
  if (! list) {
#line 436
    return;
  }
#line 444
  orig = list;
#line 445
  list1 = list + 1;
  {
#line 446
  while (1) {
    while_continue: /* CIL Label */ ;
#line 446
    if (! list->len) {
#line 446
      goto while_break;
    }
#line 447
    if (list1->len == 0) {
#line 448
      found_end = 1;
    }
#line 453
    if (list->a + list->len == list1->a) {
#line 453
      if (list->b + list->len != list1->b) {
        {
#line 453
        tmp___1 = match(b->list + ((list->b + list->len) - 1), b->list + (list1->b - 1));
        }
#line 453
        if (tmp___1) {
#line 453
          goto _L;
        } else {
#line 453
          goto _L___3;
        }
      } else {
#line 453
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 453
    if (list->b + list->len == list1->b) {
#line 453
      if (list->a + list->len != list1->a) {
        {
#line 453
        tmp___2 = match(a->list + ((list->a + list->len) - 1), a->list + (list1->a - 1));
        }
#line 453
        if (tmp___2) {
          _L: /* CIL Label */ 
          {
#line 473
          tmp = ends_line(*(a->list + ((list->a + list->len) - 1)));
          }
#line 473
          if (tmp) {
#line 473
            if ((a->list + ((list->a + list->len) - 1))->len == 1) {
#line 473
              if (lasteol == -1) {
#line 477
                lasteol = list1->a - 1;
              }
            }
          }
#line 480
          (list1->a) --;
#line 481
          (list1->b) --;
#line 482
          (list1->len) ++;
#line 483
          (list->len) --;
#line 488
          if (list->len == 0) {
#line 489
            lasteol = -1;
#line 490
            if (found_end) {
#line 493
              *list = *list1;
#line 494
              list1->a += list1->len;
#line 495
              list1->b += list1->len;
#line 496
              list1->len = 0;
            } else
#line 497
            if ((unsigned long )list > (unsigned long )orig) {
#line 499
              list --;
            } else {
#line 502
              tmp___0 = list1;
#line 502
              list1 ++;
#line 502
              *list = *tmp___0;
            }
          }
        } else {
#line 453
          goto _L___1;
        }
      } else {
#line 453
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 512
      if (lasteol >= 0) {
        {
#line 513
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 513
          if (list1->a <= lasteol) {
#line 513
            if (! (list1->len > 1)) {
#line 513
              if (found_end) {
#line 513
                if (! (list1->len > 0)) {
#line 513
                  goto while_break___0;
                }
              } else {
#line 513
                goto while_break___0;
              }
            }
          } else {
#line 513
            goto while_break___0;
          }
#line 516
          (list1->a) ++;
#line 517
          (list1->b) ++;
#line 518
          (list1->len) --;
#line 519
          (list->len) ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 521
        lasteol = -1;
      }
#line 523
      list ++;
#line 523
      *list = *list1;
#line 524
      if (found_end) {
#line 525
        list1->a += list1->len;
#line 526
        list1->b += list1->len;
#line 527
        list1->len = 0;
      } else {
#line 529
        list1 ++;
      }
    }
#line 531
    if (list->len) {
#line 531
      if ((unsigned long )list1 == (unsigned long )list) {
        {
#line 532
        abort();
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 534
  return;
}
}
#line 540 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/diff.c"
struct csl *diff(struct file a , struct file b ) 
{ 
  struct v *v ;
  struct csl *csl ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 544
  tmp = xmalloc((int )(sizeof(struct v ) * (unsigned long )((a.elcnt + b.elcnt) + 2)));
#line 544
  v = (struct v *)tmp;
#line 545
  v += b.elcnt + 1;
#line 547
  csl = lcsl(& a, 0, a.elcnt, & b, 0, b.elcnt, (struct csl *)((void *)0), v);
#line 550
  free((void *)(v - (b.elcnt + 1)));
#line 551
  fixup(& a, & b, csl);
  }
#line 552
  if (! csl) {
    {
#line 553
    tmp___0 = xmalloc((int )sizeof(*csl));
#line 553
    csl = (struct csl *)tmp___0;
#line 554
    csl->len = 0;
#line 555
    csl->a = a.elcnt;
#line 556
    csl->b = b.elcnt;
    }
  }
#line 558
  return (csl);
}
}
#line 564 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/diff.c"
struct csl *diff_partial(struct file a , struct file b , int alo , int ahi , int blo ,
                         int bhi ) 
{ 
  struct v *v ;
  struct csl *csl ;
  void *tmp ;

  {
  {
#line 569
  tmp = xmalloc((int )(sizeof(struct v ) * (unsigned long )((((ahi - alo) + bhi) - blo) + 2)));
#line 569
  v = (struct v *)tmp;
#line 570
  v += (bhi - alo) + 1;
#line 572
  csl = lcsl(& a, alo, ahi, & b, blo, bhi, (struct csl *)((void *)0), v);
#line 575
  free((void *)(v - ((bhi - alo) + 1)));
#line 576
  fixup(& a, & b, csl);
  }
#line 577
  return (csl);
}
}
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 168 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/wiggle.h"
struct ci print_merge2(FILE *out , struct file *a , struct file *b , struct file *c ,
                       struct csl *c1 , struct csl *c2 , int words , int ignore_already ,
                       int show_wiggles ) ;
#line 172
void printword(FILE *f , struct elmnt e ) ;
#line 174
struct ci make_merger(struct file af , struct file bf , struct file cf , struct csl *csl1 ,
                      struct csl *csl2 , int words , int ignore_already , int show_wiggles ) ;
#line 180
int do_trace ;
#line 47 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/merge2.c"
__inline static int min(int a , int b ) 
{ 
  int tmp ;

  {
#line 49
  if (a < b) {
#line 49
    tmp = a;
  } else {
#line 49
    tmp = b;
  }
#line 49
  return (tmp);
}
}
#line 52 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/merge2.c"
static int check_alreadyapplied(struct file af , struct file cf , struct merge *m ) 
{ 
  int i ;
  int tmp ;

  {
#line 56
  if (m->al != m->cl) {
#line 57
    return (0);
  }
#line 58
  i = 0;
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;
#line 58
    if (! (i < m->al)) {
#line 58
      goto while_break;
    }
#line 59
    if ((af.list + (m->a + i))->len != (cf.list + (m->c + i))->len) {
#line 60
      return (0);
    }
    {
#line 61
    tmp = strncmp((char const   *)(af.list + (m->a + i))->start, (char const   *)(cf.list + (m->c + i))->start,
                  (size_t )(af.list + (m->a + i))->len);
    }
#line 61
    if (tmp != 0) {
#line 64
      return (0);
    }
#line 58
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 66
  if (do_trace) {
    {
#line 67
    printf((char const   */* __restrict  */)"already applied %d,%d,%d - %d,%d,%d\n",
           m->a, m->b, m->c, m->al, m->bl, m->cl);
#line 69
    printf((char const   */* __restrict  */)" %.10s - %.10s\n", (af.list + m->a)->start,
           (cf.list + m->c)->start);
    }
  }
#line 72
  m->type = (enum mergetype )6;
#line 73
  return (1);
}
}
#line 84 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/merge2.c"
static int is_cutpoint(struct merge m , struct file af , struct file bf , struct file cf ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 87
  if (m.a == 0) {
#line 87
    goto _L___0;
  } else {
    {
#line 87
    tmp = ends_line(*(af.list + (m.a - 1)));
    }
#line 87
    if (tmp) {
      _L___0: /* CIL Label */ 
#line 87
      if (m.b == 0) {
#line 87
        goto _L;
      } else {
        {
#line 87
        tmp___0 = ends_line(*(bf.list + (m.b - 1)));
        }
#line 87
        if (tmp___0) {
          _L: /* CIL Label */ 
#line 87
          if (m.c == 0) {
#line 87
            tmp___2 = 1;
          } else {
            {
#line 87
            tmp___1 = ends_line(*(cf.list + (m.c - 1)));
            }
#line 87
            if (tmp___1) {
#line 87
              tmp___2 = 1;
            } else {
#line 87
              tmp___2 = 0;
            }
          }
        } else {
#line 87
          tmp___2 = 0;
        }
      }
    } else {
#line 87
      tmp___2 = 0;
    }
  }
#line 87
  return (tmp___2);
}
}
#line 92 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/merge2.c"
static int isolate_conflicts(struct file af , struct file bf , struct file cf , struct csl *csl1 ,
                             struct csl *csl2 , int words , struct merge *m , int show_wiggles ) 
{ 
  int i ;
  int j ;
  int k ;
  int cnt ;
  int changed ;
  int unmatched ;
  int newlines ;
  int tmp ;
  int firstk ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int firstk___0 ;
  int tmp___4 ;
  int p ;
  int nl___0 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 127
  cnt = 0;
#line 128
  changed = 0;
#line 129
  unmatched = 0;
#line 131
  i = 0;
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    if (! ((unsigned int )(m + i)->type != 0U)) {
#line 131
      goto while_break;
    }
#line 132
    if ((unsigned int )(m + i)->type == 4U) {
#line 133
      changed = 1;
    }
#line 134
    if ((unsigned int )(m + i)->type == 1U) {
#line 135
      unmatched = 1;
    }
#line 136
    if ((unsigned int )(m + i)->type == 5U) {
#line 136
      goto _L___2;
    } else
#line 136
    if (show_wiggles) {
#line 136
      if (changed) {
#line 136
        if (unmatched) {
#line 136
          goto _L___2;
        } else {
#line 136
          goto _L___3;
        }
      } else
      _L___3: /* CIL Label */ 
#line 136
      if ((unsigned int )(m + i)->type == 3U) {
        _L___2: /* CIL Label */ 
#line 147
        newlines = 0;
#line 148
        cnt ++;
#line 149
        (m + i)->in_conflict = 1;
#line 150
        j = i;
        {
#line 151
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 151
          j --;
#line 151
          if (! (j >= 0)) {
#line 151
            goto while_break___0;
          }
#line 152
          if ((unsigned int )(m + j)->type == 3U) {
#line 152
            if ((int )*((bf.list + (m + j)->b)->start + 0) == 0) {
#line 155
              goto while_break___0;
            }
          }
#line 156
          if (! (m + j)->in_conflict) {
#line 157
            (m + j)->in_conflict = 1;
#line 158
            (m + j)->lo = 0;
          } else
#line 159
          if ((unsigned int )(m + j)->type == 4U) {
#line 161
            (m + j)->hi = -1;
#line 163
            cnt --;
#line 164
            goto while_break___0;
          }
#line 166
          if ((unsigned int )(m + j)->type == 3U) {
#line 167
            k = (m + j)->bl;
            {
#line 167
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 167
              if (! (k > 0)) {
#line 167
                goto while_break___1;
              }
              {
#line 168
              tmp = ends_line(*(bf.list + (((m + j)->b + k) - 1)));
              }
#line 168
              if (tmp) {
#line 169
                newlines ++;
              }
#line 167
              k --;
            }
            while_break___1: /* CIL Label */ ;
            }
          }
#line 172
          if ((unsigned int )(m + j)->type == 2U) {
#line 172
            goto _L;
          } else
#line 172
          if ((unsigned int )(m + j)->type == 4U) {
            _L: /* CIL Label */ 
#line 178
            firstk = (m + j)->al + 1;
#line 179
            if (words) {
#line 180
              (m + j)->hi = (m + j)->al;
#line 181
              goto while_break___0;
            }
#line 187
            k = (m + j)->al;
            {
#line 187
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 187
              if (! (k > 0)) {
#line 187
                goto while_break___2;
              }
              {
#line 188
              tmp___0 = ends_line(*(af.list + (((m + j)->a + k) - 1)));
              }
#line 188
              if (tmp___0) {
#line 189
                if (firstk >= (m + j)->al) {
#line 190
                  firstk = k;
                }
#line 191
                newlines ++;
#line 192
                if (newlines >= 3) {
#line 193
                  k = firstk;
#line 194
                  goto while_break___2;
                }
              }
#line 187
              k --;
            }
            while_break___2: /* CIL Label */ ;
            }
#line 197
            if (k > 0) {
#line 198
              (m + j)->hi = k;
            } else {
              {
#line 199
              tmp___1 = is_cutpoint(*(m + j), af, bf, cf);
              }
#line 199
              if (tmp___1) {
#line 200
                (m + j)->hi = 0;
              } else {
#line 203
                (m + j)->hi = -1;
              }
            }
#line 204
            if ((m + j)->hi > 0) {
#line 204
              if ((unsigned int )(m + j)->type == 4U) {
                {
#line 207
                tmp___2 = is_cutpoint(*(m + j), af, bf, cf);
                }
#line 207
                if (! tmp___2) {
#line 210
                  (m + j)->hi = -1;
                }
              }
            }
#line 212
            if ((m + j)->hi >= 0) {
#line 213
              goto while_break___0;
            }
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 218
        newlines = 0;
#line 219
        j = i + 1;
        {
#line 219
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 219
          if (! ((unsigned int )(m + j)->type != 0U)) {
#line 219
            goto while_break___3;
          }
#line 220
          if ((unsigned int )(m + j)->type == 3U) {
#line 220
            if ((int )*((bf.list + (m + j)->b)->start + 0) == 0) {
#line 223
              goto while_break___3;
            }
          }
#line 224
          (m + j)->in_conflict = 1;
#line 225
          if ((unsigned int )(m + j)->type == 3U) {
#line 226
            k = 0;
            {
#line 226
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 226
              if (! (k < (m + j)->bl)) {
#line 226
                goto while_break___4;
              }
              {
#line 227
              tmp___3 = ends_line(*(bf.list + ((m + j)->b + k)));
              }
#line 227
              if (tmp___3) {
#line 228
                newlines ++;
              }
#line 226
              k ++;
            }
            while_break___4: /* CIL Label */ ;
            }
          }
#line 230
          if ((unsigned int )(m + j)->type == 2U) {
#line 230
            goto _L___0;
          } else
#line 230
          if ((unsigned int )(m + j)->type == 4U) {
            _L___0: /* CIL Label */ 
#line 231
            (m + j)->hi = (m + j)->al;
#line 232
            if (words) {
#line 233
              (m + j)->lo = 0;
#line 234
              goto while_break___3;
            }
            {
#line 240
            tmp___6 = is_cutpoint(*(m + j), af, bf, cf);
            }
#line 240
            if (tmp___6) {
#line 241
              (m + j)->lo = 0;
            } else {
#line 248
              firstk___0 = -1;
#line 249
              k = 0;
              {
#line 249
              while (1) {
                while_continue___5: /* CIL Label */ ;
#line 249
                if (! (k < (m + j)->al)) {
#line 249
                  goto while_break___5;
                }
                {
#line 250
                tmp___4 = ends_line(*(af.list + ((m + j)->a + k)));
                }
#line 250
                if (tmp___4) {
#line 251
                  if (firstk___0 <= 0) {
#line 252
                    firstk___0 = k;
                  }
#line 253
                  newlines ++;
#line 254
                  if (newlines >= 3) {
#line 255
                    k = firstk___0;
#line 256
                    goto while_break___5;
                  }
                }
#line 249
                k ++;
              }
              while_break___5: /* CIL Label */ ;
              }
#line 259
              if (firstk___0 >= 0) {
#line 259
                if ((unsigned int )(m + (j + 1))->type == 1U) {
#line 263
                  nl___0 = 0;
#line 264
                  p = 0;
                  {
#line 264
                  while (1) {
                    while_continue___6: /* CIL Label */ ;
#line 264
                    if (! (p < (m + (j + 1))->al)) {
#line 264
                      goto while_break___6;
                    }
                    {
#line 265
                    tmp___5 = ends_line(*(af.list + ((m + (j + 1))->a + p)));
                    }
#line 265
                    if (tmp___5) {
#line 266
                      nl___0 ++;
#line 267
                      if (nl___0 > 3) {
#line 268
                        goto while_break___6;
                      }
                    }
#line 264
                    p ++;
                  }
                  while_break___6: /* CIL Label */ ;
                  }
#line 270
                  if (nl___0 > 3) {
#line 271
                    k = firstk___0;
                  }
                }
              }
#line 273
              if (k < (m + j)->al) {
#line 274
                (m + j)->lo = k + 1;
              } else {
#line 277
                (m + j)->lo = (m + j)->al + 1;
              }
            }
#line 279
            if ((m + j)->lo <= (m + j)->al + 1) {
#line 279
              if ((unsigned int )(m + j)->type == 4U) {
                {
#line 281
                tmp___7 = is_cutpoint(*(m + (j + 1)), af, bf, cf);
                }
#line 281
                if (! tmp___7) {
#line 284
                  (m + j)->lo = (m + j)->al + 1;
                }
              }
            }
#line 286
            if ((m + j)->lo < (m + j)->al + 1) {
#line 287
              goto while_break___3;
            }
          }
#line 219
          j ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 290
        i = j - 1;
      }
    }
#line 292
    if ((m + i)->al > 0) {
      {
#line 292
      tmp___8 = ends_line(*(af.list + (((m + i)->a + (m + i)->al) - 1)));
      }
#line 292
      if (tmp___8) {
#line 293
        unmatched = 0;
#line 294
        changed = 0;
      }
    }
#line 131
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 297
  return (cnt);
}
}
#line 300 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/merge2.c"
struct ci make_merger(struct file af , struct file bf , struct file cf , struct csl *csl1 ,
                      struct csl *csl2 , int words , int ignore_already , int show_wiggles ) 
{ 
  struct ci rv ;
  int i ;
  int l ;
  int a ;
  int b ;
  int c ;
  int c1 ;
  int c2 ;
  int wiggle_found ;
  void *tmp ;
  int match1 ;
  int match2 ;
  int tmp___0 ;
  int tmp___1 ;
  int newa ;
  int tmp___2 ;
  int tmp___3 ;
  int newb ;
  int j ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 309
  wiggle_found = 0;
#line 311
  rv.ignored = 0;
#line 311
  rv.wiggles = rv.ignored;
#line 311
  rv.conflicts = rv.wiggles;
#line 313
  i = 0;
  {
#line 313
  while (1) {
    while_continue: /* CIL Label */ ;
#line 313
    if (! (csl1 + i)->len) {
#line 313
      goto while_break;
    }
#line 313
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 315
  l = i;
#line 316
  i = 0;
  {
#line 316
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 316
    if (! (csl2 + i)->len) {
#line 316
      goto while_break___0;
    }
#line 316
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 318
  l += i;
#line 320
  l = l * 4 + 10;
#line 322
  tmp = xmalloc((int )(sizeof(struct merge ) * (unsigned long )l));
#line 322
  rv.merger = (struct merge *)tmp;
#line 324
  c2 = 0;
#line 324
  c1 = c2;
#line 324
  c = c1;
#line 324
  b = c;
#line 324
  a = b;
#line 325
  i = 0;
  }
  {
#line 326
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 328
    if (a >= (csl1 + c1)->a) {
#line 328
      if (b >= (csl1 + c1)->b) {
#line 328
        tmp___0 = 1;
      } else {
#line 328
        tmp___0 = 0;
      }
    } else {
#line 328
      tmp___0 = 0;
    }
#line 328
    match1 = tmp___0;
#line 329
    if (b >= (csl2 + c2)->a) {
#line 329
      if (c >= (csl2 + c2)->b) {
#line 329
        tmp___1 = 1;
      } else {
#line 329
        tmp___1 = 0;
      }
    } else {
#line 329
      tmp___1 = 0;
    }
#line 329
    match2 = tmp___1;
#line 331
    (rv.merger + i)->a = a;
#line 332
    (rv.merger + i)->b = b;
#line 333
    (rv.merger + i)->c = c;
#line 334
    (rv.merger + i)->c1 = c1;
#line 335
    (rv.merger + i)->c2 = c2;
#line 336
    (rv.merger + i)->in_conflict = 0;
#line 338
    if (! match1) {
#line 338
      if (match2) {
#line 343
        newa = (csl1 + c1)->a;
#line 344
        if (b < bf.elcnt) {
#line 344
          if ((bf.list + b)->start) {
#line 344
            if ((int )*((bf.list + b)->start + 0) == 0) {
              {
#line 346
              while (1) {
                while_continue___2: /* CIL Label */ ;
#line 346
                if (newa > a) {
                  {
#line 346
                  tmp___2 = ends_line(*(af.list + (newa - 1)));
                  }
#line 346
                  if (tmp___2) {
#line 346
                    goto while_break___2;
                  }
                } else {
#line 346
                  goto while_break___2;
                }
#line 348
                newa --;
              }
              while_break___2: /* CIL Label */ ;
              }
              {
#line 349
              while (1) {
                while_continue___3: /* CIL Label */ ;
#line 349
                if (newa < af.elcnt) {
#line 349
                  if (newa == 0) {
#line 349
                    goto while_break___3;
                  } else {
                    {
#line 349
                    tmp___3 = ends_line(*(af.list + (newa - 1)));
                    }
#line 349
                    if (tmp___3) {
#line 349
                      goto while_break___3;
                    }
                  }
                } else {
#line 349
                  goto while_break___3;
                }
#line 350
                newa ++;
              }
              while_break___3: /* CIL Label */ ;
              }
            }
          }
        }
#line 352
        if (a < newa) {
#line 354
          (rv.merger + i)->type = (enum mergetype )1;
#line 355
          (rv.merger + i)->al = newa - a;
#line 356
          (rv.merger + i)->bl = 0;
#line 357
          (rv.merger + i)->cl = 0;
#line 358
          wiggle_found ++;
        } else {
          {
#line 362
          assert(b < (csl1 + c1)->b);
#line 372
          (rv.merger + i)->type = (enum mergetype )3;
#line 373
          (rv.merger + i)->al = 0;
#line 374
          tmp___4 = min((csl1 + c1)->b - b, (csl2 + c2)->len - (b - (csl2 + c2)->a));
#line 374
          newb = b + tmp___4;
          }
#line 377
          if ((int )*((bf.list + b)->start + 0) == 0) {
#line 378
            newb = b + 1;
          }
#line 379
          j = b;
          {
#line 379
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 379
            if (! (j < newb)) {
#line 379
              goto while_break___4;
            }
#line 380
            if ((int )*((bf.list + j)->start + 0) == 0) {
#line 381
              if (wiggle_found > 1) {
#line 382
                (rv.wiggles) ++;
              }
#line 383
              wiggle_found = 0;
#line 384
              if (j > b) {
#line 385
                newb = j;
              }
            } else {
#line 387
              wiggle_found ++;
            }
#line 379
            j ++;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 389
          tmp___5 = newb - b;
#line 389
          (rv.merger + i)->bl = tmp___5;
#line 389
          (rv.merger + i)->cl = tmp___5;
        }
      } else {
#line 338
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 392
    if (match1) {
#line 392
      if (! match2) {
        {
#line 401
        (rv.merger + i)->type = (enum mergetype )4;
#line 402
        tmp___6 = min((csl1 + c1)->b + (csl1 + c1)->len, (csl2 + c2)->a);
#line 402
        (rv.merger + i)->bl = tmp___6 - b;
#line 403
        (rv.merger + i)->al = (rv.merger + i)->bl;
#line 404
        (rv.merger + i)->cl = (csl2 + c2)->b - c;
        }
      } else {
#line 392
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 405
    if (match1) {
#line 405
      if (match2) {
        {
#line 408
        (rv.merger + i)->type = (enum mergetype )2;
#line 409
        (rv.merger + i)->bl = min((csl1 + c1)->len - (b - (csl1 + c1)->b), (csl2 + c2)->len - (b - (csl2 + c2)->a));
#line 412
        tmp___7 = (rv.merger + i)->bl;
#line 412
        (rv.merger + i)->cl = tmp___7;
#line 412
        (rv.merger + i)->al = tmp___7;
        }
      } else {
#line 405
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 418
      (rv.merger + i)->type = (enum mergetype )5;
#line 419
      (rv.merger + i)->al = (csl1 + c1)->a - a;
#line 420
      (rv.merger + i)->cl = (csl2 + c2)->b - c;
#line 421
      tmp___8 = min((csl1 + c1)->b, (csl2 + c2)->a);
#line 421
      (rv.merger + i)->bl = tmp___8 - b;
      }
#line 422
      if (ignore_already) {
        {
#line 422
        tmp___9 = check_alreadyapplied(af, cf, rv.merger + i);
        }
#line 422
        if (tmp___9) {
#line 424
          (rv.ignored) ++;
        }
      }
    }
#line 426
    a += (rv.merger + i)->al;
#line 427
    b += (rv.merger + i)->bl;
#line 428
    c += (rv.merger + i)->cl;
#line 429
    i ++;
    {
#line 431
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 431
      if ((csl1 + c1)->a + (csl1 + c1)->len <= a) {
#line 431
        if (! (csl1 + c1)->len) {
#line 431
          goto while_break___5;
        }
      } else {
#line 431
        goto while_break___5;
      }
#line 432
      c1 ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 433
    assert((csl1 + c1)->b + (csl1 + c1)->len >= b);
    }
    {
#line 434
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 434
      if ((csl2 + c2)->b + (csl2 + c2)->len <= c) {
#line 434
        if (! (csl2 + c2)->len) {
#line 434
          goto while_break___6;
        }
      } else {
#line 434
        goto while_break___6;
      }
#line 435
      c2 ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 436
    assert((csl2 + c2)->a + (csl2 + c2)->len >= b);
    }
#line 437
    if ((csl1 + c1)->len == 0) {
#line 437
      if ((csl2 + c2)->len == 0) {
#line 437
        if (a == (csl1 + c1)->a) {
#line 437
          if (b == (csl1 + c1)->b) {
#line 437
            if (b == (csl2 + c2)->a) {
#line 437
              if (c == (csl2 + c2)->b) {
#line 440
                goto while_break___1;
              }
            }
          }
        }
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 442
  (rv.merger + i)->type = (enum mergetype )0;
#line 443
  (rv.merger + i)->a = a;
#line 444
  (rv.merger + i)->b = b;
#line 445
  (rv.merger + i)->c = c;
#line 446
  (rv.merger + i)->c1 = c1;
#line 447
  (rv.merger + i)->c2 = c2;
#line 448
  (rv.merger + i)->in_conflict = 0;
#line 449
  assert(i < l);
#line 450
  rv.conflicts = isolate_conflicts(af, bf, cf, csl1, csl2, words, rv.merger, show_wiggles);
  }
#line 452
  if (wiggle_found) {
#line 453
    (rv.wiggles) ++;
  }
#line 454
  return (rv);
}
}
#line 457 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/merge2.c"
static void printrange(FILE *out , struct file *f , int start , int len ) 
{ 


  {
  {
#line 459
  while (1) {
    while_continue: /* CIL Label */ ;
#line 459
    if (! (len > 0)) {
#line 459
      goto while_break;
    }
    {
#line 460
    printword(out, *(f->list + start));
#line 461
    start ++;
#line 462
    len --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 464
  return;
}
}
#line 466 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/merge2.c"
struct ci print_merge2(FILE *out , struct file *a , struct file *b , struct file *c ,
                       struct csl *c1 , struct csl *c2 , int words , int ignore_already ,
                       int show_wiggles ) 
{ 
  struct ci rv ;
  struct ci tmp ;
  struct merge *m ;
  struct merge *cm ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  int found_conflict ;
  int st ;
  int st1 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  char const   *tmp___15 ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;
  int last ;
  int tmp___18 ;
  int tmp___19 ;
  char const   *tmp___20 ;
  char const   *tmp___21 ;
  char const   *tmp___22 ;
  char const   *tmp___23 ;
  char const   *tmp___24 ;
  char const   *tmp___25 ;
  char const   *tmp___26 ;
  char const   *tmp___27 ;

  {
  {
#line 470
  tmp = make_merger(*a, *b, *c, c1, c2, words, ignore_already, show_wiggles);
#line 470
  rv = tmp;
#line 474
  m = rv.merger;
  }
  {
#line 474
  while (1) {
    while_continue: /* CIL Label */ ;
#line 474
    if (! ((unsigned int )m->type != 0U)) {
#line 474
      goto while_break;
    }
#line 476
    if (do_trace) {
#line 477
      if (m->in_conflict) {
#line 477
        tmp___0 = " in_conflict";
      } else {
#line 477
        tmp___0 = "";
      }
#line 477
      if ((unsigned int )m->type == 1U) {
#line 477
        tmp___6 = "Unmatched";
      } else {
#line 477
        if ((unsigned int )m->type == 2U) {
#line 477
          tmp___5 = "Unchanged";
        } else {
#line 477
          if ((unsigned int )m->type == 3U) {
#line 477
            tmp___4 = "Extraneous";
          } else {
#line 477
            if ((unsigned int )m->type == 4U) {
#line 477
              tmp___3 = "Changed";
            } else {
#line 477
              if ((unsigned int )m->type == 6U) {
#line 477
                tmp___2 = "AlreadyApplied";
              } else {
#line 477
                if ((unsigned int )m->type == 5U) {
#line 477
                  tmp___1 = "Conflict";
                } else {
#line 477
                  tmp___1 = "unknown";
                }
#line 477
                tmp___2 = tmp___1;
              }
#line 477
              tmp___3 = tmp___2;
            }
#line 477
            tmp___4 = tmp___3;
          }
#line 477
          tmp___5 = tmp___4;
        }
#line 477
        tmp___6 = tmp___5;
      }
      {
#line 477
      printf((char const   */* __restrict  */)"[%s: %d-%d,%d-%d,%d-%d%s(%d,%d)]\n",
             tmp___6, m->a, (m->a + m->al) - 1, m->b, (m->b + m->bl) - 1, m->c, (m->c + m->cl) - 1,
             tmp___0, m->lo, m->hi);
      }
    }
    {
#line 490
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 490
      if (! m->in_conflict) {
#line 490
        goto while_break___0;
      }
#line 494
      found_conflict = 0;
#line 495
      st = 0;
#line 496
      if ((unsigned int )m->type == 2U) {
#line 496
        goto _L;
      } else
#line 496
      if ((unsigned int )m->type == 4U) {
        _L: /* CIL Label */ 
#line 497
        if (m->hi >= m->lo) {
#line 498
          st = m->hi;
        }
      }
#line 499
      st1 = st;
#line 501
      if ((unsigned int )m->type == 2U) {
        {
#line 502
        printrange(out, a, m->a + m->lo, m->hi - m->lo);
        }
      }
#line 504
      if (do_trace) {
#line 505
        cm = m;
        {
#line 505
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 505
          if (! cm->in_conflict) {
#line 505
            goto while_break___1;
          }
#line 506
          if (cm->in_conflict) {
#line 506
            tmp___7 = " in_conflict";
          } else {
#line 506
            tmp___7 = "";
          }
#line 506
          if ((unsigned int )cm->type == 1U) {
#line 506
            tmp___13 = "Unmatched";
          } else {
#line 506
            if ((unsigned int )cm->type == 2U) {
#line 506
              tmp___12 = "Unchanged";
            } else {
#line 506
              if ((unsigned int )cm->type == 3U) {
#line 506
                tmp___11 = "Extraneous";
              } else {
#line 506
                if ((unsigned int )cm->type == 4U) {
#line 506
                  tmp___10 = "Changed";
                } else {
#line 506
                  if ((unsigned int )cm->type == 6U) {
#line 506
                    tmp___9 = "AlreadyApplied";
                  } else {
#line 506
                    if ((unsigned int )cm->type == 5U) {
#line 506
                      tmp___8 = "Conflict";
                    } else {
#line 506
                      tmp___8 = "unknown";
                    }
#line 506
                    tmp___9 = tmp___8;
                  }
#line 506
                  tmp___10 = tmp___9;
                }
#line 506
                tmp___11 = tmp___10;
              }
#line 506
              tmp___12 = tmp___11;
            }
#line 506
            tmp___13 = tmp___12;
          }
          {
#line 506
          printf((char const   */* __restrict  */)"{%s: %d-%d,%d-%d,%d-%d%s(%d,%d)}\n",
                 tmp___13, cm->a, (cm->a + cm->al) - 1, cm->b, (cm->b + cm->bl) - 1,
                 cm->c, (cm->c + cm->cl) - 1, tmp___7, cm->lo, cm->hi);
          }
#line 518
          if ((unsigned int )cm->type == 2U) {
#line 518
            goto _L___0;
          } else
#line 518
          if ((unsigned int )cm->type == 4U) {
            _L___0: /* CIL Label */ 
#line 518
            if ((unsigned long )cm != (unsigned long )m) {
#line 518
              if (cm->lo < cm->hi) {
#line 520
                goto while_break___1;
              }
            }
          }
#line 505
          cm ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 523
      if (words) {
#line 523
        tmp___14 = "<<<---";
      } else {
#line 523
        tmp___14 = "<<<<<<<\n";
      }
      {
#line 523
      fputs((char const   */* __restrict  */)tmp___14, (FILE */* __restrict  */)out);
#line 524
      cm = m;
      }
      {
#line 524
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 524
        if (! cm->in_conflict) {
#line 524
          goto while_break___2;
        }
#line 525
        if ((unsigned int )cm->type == 5U) {
#line 526
          found_conflict = 1;
        }
#line 527
        if ((unsigned int )cm->type == 2U) {
#line 527
          goto _L___1;
        } else
#line 527
        if ((unsigned int )cm->type == 4U) {
          _L___1: /* CIL Label */ 
#line 527
          if ((unsigned long )cm != (unsigned long )m) {
#line 527
            if (cm->lo < cm->hi) {
              {
#line 529
              printrange(out, a, cm->a, cm->lo);
              }
#line 530
              goto while_break___2;
            }
          }
        }
        {
#line 532
        printrange(out, a, cm->a + st1, cm->al - st1);
#line 533
        st1 = 0;
#line 524
        cm ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 535
      if (words) {
#line 535
        tmp___15 = "|||";
      } else {
#line 535
        tmp___15 = "|||||||\n";
      }
      {
#line 535
      fputs((char const   */* __restrict  */)tmp___15, (FILE */* __restrict  */)out);
#line 536
      st1 = st;
#line 537
      cm = m;
      }
      {
#line 537
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 537
        if (! cm->in_conflict) {
#line 537
          goto while_break___3;
        }
#line 538
        if ((unsigned int )cm->type == 2U) {
#line 538
          goto _L___2;
        } else
#line 538
        if ((unsigned int )cm->type == 4U) {
          _L___2: /* CIL Label */ 
#line 538
          if ((unsigned long )cm != (unsigned long )m) {
#line 538
            if (cm->lo < cm->hi) {
              {
#line 540
              printrange(out, b, cm->b, cm->lo);
              }
#line 541
              goto while_break___3;
            }
          }
        }
        {
#line 543
        printrange(out, b, cm->b + st1, cm->bl - st1);
#line 544
        st1 = 0;
#line 537
        cm ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 546
      if (words) {
#line 546
        tmp___16 = "===";
      } else {
#line 546
        tmp___16 = "=======\n";
      }
      {
#line 546
      fputs((char const   */* __restrict  */)tmp___16, (FILE */* __restrict  */)out);
#line 547
      st1 = st;
#line 548
      cm = m;
      }
      {
#line 548
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 548
        if (! cm->in_conflict) {
#line 548
          goto while_break___4;
        }
#line 549
        if ((unsigned int )cm->type == 2U) {
#line 549
          if ((unsigned long )cm != (unsigned long )m) {
#line 549
            if (cm->lo < cm->hi) {
              {
#line 551
              printrange(out, c, cm->c, cm->lo);
              }
#line 552
              goto while_break___4;
            }
          }
        }
#line 554
        if ((unsigned int )cm->type == 4U) {
#line 555
          st1 = 0;
        }
        {
#line 556
        printrange(out, c, cm->c + st1, cm->cl - st1);
#line 557
        st1 = 0;
#line 548
        cm ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
#line 559
      if (! found_conflict) {
#line 564
        if (words) {
#line 564
          tmp___17 = "&&&";
        } else {
#line 564
          tmp___17 = "&&&&&&&\n";
        }
        {
#line 564
        fputs((char const   */* __restrict  */)tmp___17, (FILE */* __restrict  */)out);
#line 565
        st1 = st;
#line 566
        cm = m;
        }
        {
#line 566
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 566
          if (! cm->in_conflict) {
#line 566
            goto while_break___5;
          }
#line 567
          last = 0;
#line 568
          if ((unsigned int )cm->type == 2U) {
#line 568
            goto _L___3;
          } else
#line 568
          if ((unsigned int )cm->type == 4U) {
            _L___3: /* CIL Label */ 
#line 568
            if ((unsigned long )cm != (unsigned long )m) {
#line 568
              if (cm->lo < cm->hi) {
#line 570
                last = 1;
              }
            }
          }
          {
#line 574
          if ((unsigned int )cm->type == 1U) {
#line 574
            goto case_1;
          }
#line 574
          if ((unsigned int )cm->type == 6U) {
#line 574
            goto case_1;
          }
#line 574
          if ((unsigned int )cm->type == 2U) {
#line 574
            goto case_1;
          }
#line 578
          if ((unsigned int )cm->type == 3U) {
#line 578
            goto case_3;
          }
#line 580
          if ((unsigned int )cm->type == 4U) {
#line 580
            goto case_4;
          }
#line 585
          if ((unsigned int )cm->type == 0U) {
#line 585
            goto case_0;
          }
#line 585
          if ((unsigned int )cm->type == 5U) {
#line 585
            goto case_0;
          }
#line 571
          goto switch_break;
          case_1: /* CIL Label */ 
          case_6: /* CIL Label */ 
          case_2: /* CIL Label */ 
#line 575
          if (last) {
#line 575
            tmp___18 = cm->lo;
          } else {
#line 575
            tmp___18 = cm->al - st1;
          }
          {
#line 575
          printrange(out, a, cm->a + st1, tmp___18);
          }
#line 577
          goto switch_break;
          case_3: /* CIL Label */ 
#line 579
          goto switch_break;
          case_4: /* CIL Label */ 
#line 581
          if (last) {
#line 581
            tmp___19 = cm->lo;
          } else {
#line 581
            tmp___19 = cm->cl - st1;
          }
          {
#line 581
          printrange(out, c, cm->c + st1, tmp___19);
          }
#line 583
          goto switch_break;
          case_0: /* CIL Label */ 
          case_5: /* CIL Label */ 
          {
#line 586
          assert(0);
          }
          switch_break: /* CIL Label */ ;
          }
#line 588
          if (last) {
#line 589
            goto while_break___5;
          }
#line 590
          st1 = 0;
#line 566
          cm ++;
        }
        while_break___5: /* CIL Label */ ;
        }
      }
#line 593
      if (words) {
#line 593
        tmp___20 = "--->>>";
      } else {
#line 593
        tmp___20 = ">>>>>>>\n";
      }
      {
#line 593
      fputs((char const   */* __restrict  */)tmp___20, (FILE */* __restrict  */)out);
#line 594
      m = cm;
      }
#line 595
      if (m->in_conflict) {
#line 595
        if ((unsigned int )m->type == 2U) {
#line 595
          if (m->hi >= m->al) {
            {
#line 597
            printrange(out, a, m->a + m->lo, m->hi - m->lo);
#line 598
            m ++;
            }
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 605
    if ((unsigned int )m->type == 0U) {
#line 606
      goto while_break;
    }
#line 608
    if (do_trace) {
#line 609
      if (m->in_conflict) {
#line 609
        tmp___21 = " in_conflict";
      } else {
#line 609
        tmp___21 = "";
      }
#line 609
      if ((unsigned int )m->type == 1U) {
#line 609
        tmp___27 = "Unmatched";
      } else {
#line 609
        if ((unsigned int )m->type == 2U) {
#line 609
          tmp___26 = "Unchanged";
        } else {
#line 609
          if ((unsigned int )m->type == 3U) {
#line 609
            tmp___25 = "Extraneous";
          } else {
#line 609
            if ((unsigned int )m->type == 4U) {
#line 609
              tmp___24 = "Changed";
            } else {
#line 609
              if ((unsigned int )m->type == 6U) {
#line 609
                tmp___23 = "AlreadyApplied";
              } else {
#line 609
                if ((unsigned int )m->type == 5U) {
#line 609
                  tmp___22 = "Conflict";
                } else {
#line 609
                  tmp___22 = "unknown";
                }
#line 609
                tmp___23 = tmp___22;
              }
#line 609
              tmp___24 = tmp___23;
            }
#line 609
            tmp___25 = tmp___24;
          }
#line 609
          tmp___26 = tmp___25;
        }
#line 609
        tmp___27 = tmp___26;
      }
      {
#line 609
      printf((char const   */* __restrict  */)"<<%s: %d-%d,%d-%d,%d-%d%s(%d,%d)>>\n",
             tmp___27, m->a, (m->a + m->al) - 1, m->b, (m->b + m->bl) - 1, m->c, (m->c + m->cl) - 1,
             tmp___21, m->lo, m->hi);
      }
    }
    {
#line 626
    if ((unsigned int )m->type == 1U) {
#line 626
      goto case_1___0;
    }
#line 626
    if ((unsigned int )m->type == 6U) {
#line 626
      goto case_1___0;
    }
#line 626
    if ((unsigned int )m->type == 2U) {
#line 626
      goto case_1___0;
    }
#line 629
    if ((unsigned int )m->type == 3U) {
#line 629
      goto case_3___0;
    }
#line 631
    if ((unsigned int )m->type == 4U) {
#line 631
      goto case_4___0;
    }
#line 635
    if ((unsigned int )m->type == 0U) {
#line 635
      goto case_0___0;
    }
#line 635
    if ((unsigned int )m->type == 5U) {
#line 635
      goto case_0___0;
    }
#line 623
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
    case_6___0: /* CIL Label */ 
    case_2___0: /* CIL Label */ 
    {
#line 627
    printrange(out, a, m->a, m->al);
    }
#line 628
    goto switch_break___0;
    case_3___0: /* CIL Label */ 
#line 630
    goto switch_break___0;
    case_4___0: /* CIL Label */ 
    {
#line 632
    printrange(out, c, m->c, m->cl);
    }
#line 633
    goto switch_break___0;
    case_0___0: /* CIL Label */ 
    case_5___0: /* CIL Label */ 
    {
#line 636
    assert(0);
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 474
    m ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 639
  return (rv);
}
}
#line 186 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/wiggle.h"
char Version[63] ;
#line 187
char short_options[21] ;
#line 188
struct option long_options[17] ;
#line 189
char Usage[86] ;
#line 190
char Help[1341] ;
#line 191
char HelpExtract[416] ;
#line 192
char HelpDiff[813] ;
#line 193
char HelpMerge[1039] ;
#line 194
char HelpBrowse[808] ;
#line 32 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/ReadMe.c"
char Version[63]  = 
#line 32 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/ReadMe.c"
  {      (char )'w',      (char )'i',      (char )'g',      (char )'g', 
        (char )'l',      (char )'e',      (char )' ',      (char )'0', 
        (char )'.',      (char )'9',      (char )'.',      (char )'1', 
        (char )' ',      (char )'2',      (char )'0',      (char )'1', 
        (char )'3',      (char )'-',      (char )'0',      (char )'2', 
        (char )'-',      (char )'0',      (char )'5',      (char )' ', 
        (char )'G',      (char )'P',      (char )'L',      (char )'-', 
        (char )'2',      (char )'+',      (char )' ',      (char )'h', 
        (char )'t',      (char )'t',      (char )'p',      (char )':', 
        (char )'/',      (char )'/',      (char )'n',      (char )'e', 
        (char )'i',      (char )'l',      (char )'.',      (char )'b', 
        (char )'r',      (char )'o',      (char )'w',      (char )'n', 
        (char )'.',      (char )'n',      (char )'a',      (char )'m', 
        (char )'e',      (char )'/',      (char )'w',      (char )'i', 
        (char )'g',      (char )'g',      (char )'l',      (char )'e', 
        (char )'/',      (char )'\n',      (char )'\000'};
#line 34 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/ReadMe.c"
char short_options[21]  = 
#line 34
  {      (char )'x',      (char )'d',      (char )'m',      (char )'w', 
        (char )'l',      (char )'r',      (char )'h',      (char )'i', 
        (char )'W',      (char )'1',      (char )'2',      (char )'3', 
        (char )'p',      (char )':',      (char )':',      (char )'V', 
        (char )'R',      (char )'v',      (char )'q',      (char )'B', 
        (char )'\000'};
#line 36 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/ReadMe.c"
struct option long_options[17]  = 
#line 36
  {      {"browse", 0, (int *)0, 'B'}, 
        {"extract", 0, (int *)0, 'x'}, 
        {"diff", 0, (int *)0, 'd'}, 
        {"merge", 0, (int *)0, 'm'}, 
        {"words", 0, (int *)0, 'w'}, 
        {"lines", 0, (int *)0, 'l'}, 
        {"patch", 0, (int *)0, 'p'}, 
        {"replace", 0, (int *)0, 'r'}, 
        {"help", 0, (int *)0, 'h'}, 
        {"version", 0, (int *)0, 'V'}, 
        {"reverse", 0, (int *)0, 'R'}, 
        {"verbose", 0, (int *)0, 'v'}, 
        {"quiet", 0, (int *)0, 'q'}, 
        {"strip", 1, (int *)0, 'p'}, 
        {"no-ignore", 0, (int *)0, 'i'}, 
        {"show-wiggle", 0, (int *)0, 'W'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 56 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/ReadMe.c"
char Usage[86]  = 
#line 56
  {      (char )'U',      (char )'s',      (char )'a',      (char )'g', 
        (char )'e',      (char )':',      (char )' ',      (char )'w', 
        (char )'i',      (char )'g',      (char )'g',      (char )'l', 
        (char )'e',      (char )' ',      (char )'-',      (char )'-', 
        (char )'d',      (char )'i',      (char )'f',      (char )'f', 
        (char )'|',      (char )'-',      (char )'-',      (char )'e', 
        (char )'x',      (char )'t',      (char )'r',      (char )'a', 
        (char )'c',      (char )'t',      (char )'|',      (char )'-', 
        (char )'-',      (char )'m',      (char )'e',      (char )'r', 
        (char )'g',      (char )'e',      (char )'|',      (char )'-', 
        (char )'-',      (char )'b',      (char )'r',      (char )'o', 
        (char )'w',      (char )'s',      (char )'e',      (char )' ', 
        (char )'-',      (char )'-',      (char )'l',      (char )'i', 
        (char )'n',      (char )'e',      (char )'s',      (char )'|', 
        (char )'-',      (char )'-',      (char )'w',      (char )'o', 
        (char )'r',      (char )'d',      (char )'s',      (char )' ', 
        (char )'[',      (char )'-',      (char )'-',      (char )'r', 
        (char )'e',      (char )'p',      (char )'l',      (char )'a', 
        (char )'c',      (char )'e',      (char )']',      (char )' ', 
        (char )'f',      (char )'i',      (char )'l',      (char )'e', 
        (char )'s',      (char )'.',      (char )'.',      (char )'.', 
        (char )'\n',      (char )'\000'};
#line 59 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/ReadMe.c"
char Help[1341]  = 
#line 59
  {      (char )'\n',      (char )'W',      (char )'i',      (char )'g', 
        (char )'g',      (char )'l',      (char )'e',      (char )' ', 
        (char )'-',      (char )' ',      (char )'a',      (char )'p', 
        (char )'p',      (char )'l',      (char )'y',      (char )' ', 
        (char )'p',      (char )'a',      (char )'t',      (char )'c', 
        (char )'h',      (char )'e',      (char )'s',      (char )' ', 
        (char )'t',      (char )'h',      (char )'a',      (char )'t', 
        (char )' ',      (char )'\'',      (char )'p',      (char )'a', 
        (char )'t',      (char )'c',      (char )'h',      (char )'\'', 
        (char )' ',      (char )'r',      (char )'e',      (char )'j', 
        (char )'e',      (char )'c',      (char )'t',      (char )'s', 
        (char )'.',      (char )'\n',      (char )'\n',      (char )'W', 
        (char )'i',      (char )'g',      (char )'g',      (char )'l', 
        (char )'e',      (char )' ',      (char )'p',      (char )'r', 
        (char )'o',      (char )'v',      (char )'i',      (char )'d', 
        (char )'e',      (char )'s',      (char )' ',      (char )'f', 
        (char )'o',      (char )'u',      (char )'r',      (char )' ', 
        (char )'d',      (char )'i',      (char )'s',      (char )'t', 
        (char )'i',      (char )'n',      (char )'c',      (char )'t', 
        (char )' ',      (char )'b',      (char )'u',      (char )'t', 
        (char )' ',      (char )'r',      (char )'e',      (char )'l', 
        (char )'a',      (char )'t',      (char )'e',      (char )'d', 
        (char )' ',      (char )'f',      (char )'u',      (char )'n', 
        (char )'c',      (char )'t',      (char )'i',      (char )'o', 
        (char )'n',      (char )'s',      (char )':',      (char )'\n', 
        (char )'m',      (char )'e',      (char )'r',      (char )'g', 
        (char )'e',      (char )',',      (char )' ',      (char )'d', 
        (char )'i',      (char )'f',      (char )'f',      (char )',', 
        (char )' ',      (char )'e',      (char )'x',      (char )'t', 
        (char )'r',      (char )'a',      (char )'c',      (char )'t', 
        (char )',',      (char )' ',      (char )'a',      (char )'n', 
        (char )'d',      (char )' ',      (char )'b',      (char )'r', 
        (char )'o',      (char )'w',      (char )'s',      (char )'e', 
        (char )'.',      (char )'\n',      (char )'T',      (char )'o', 
        (char )' ',      (char )'g',      (char )'e',      (char )'t', 
        (char )' ',      (char )'m',      (char )'o',      (char )'r', 
        (char )'e',      (char )' ',      (char )'d',      (char )'e', 
        (char )'t',      (char )'a',      (char )'i',      (char )'l', 
        (char )'e',      (char )'d',      (char )' ',      (char )'h', 
        (char )'e',      (char )'l',      (char )'p',      (char )' ', 
        (char )'o',      (char )'n',      (char )' ',      (char )'a', 
        (char )' ',      (char )'f',      (char )'u',      (char )'n', 
        (char )'c',      (char )'t',      (char )'i',      (char )'o', 
        (char )'n',      (char )',',      (char )' ',      (char )'s', 
        (char )'e',      (char )'l',      (char )'e',      (char )'c', 
        (char )'t',      (char )' ',      (char )'t',      (char )'h', 
        (char )'e',      (char )' ',      (char )'f',      (char )'u', 
        (char )'n',      (char )'c',      (char )'t',      (char )'i', 
        (char )'o',      (char )'n',      (char )'\n',      (char )'b', 
        (char )'e',      (char )'f',      (char )'o',      (char )'r', 
        (char )'e',      (char )' ',      (char )'r',      (char )'e', 
        (char )'q',      (char )'u',      (char )'e',      (char )'s', 
        (char )'t',      (char )'i',      (char )'n',      (char )'g', 
        (char )' ',      (char )'h',      (char )'e',      (char )'l', 
        (char )'p',      (char )'.',      (char )' ',      (char )' ', 
        (char )'e',      (char )'.',      (char )'g',      (char )'.', 
        (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'w',      (char )'i',      (char )'g', 
        (char )'g',      (char )'l',      (char )'e',      (char )' ', 
        (char )'-',      (char )'-',      (char )'d',      (char )'i', 
        (char )'f',      (char )'f',      (char )' ',      (char )'-', 
        (char )'-',      (char )'h',      (char )'e',      (char )'l', 
        (char )'p',      (char )'\n',      (char )'\n',      (char )'O', 
        (char )'p',      (char )'t',      (char )'i',      (char )'o', 
        (char )'n',      (char )'s',      (char )':',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )'-', 
        (char )'-',      (char )'e',      (char )'x',      (char )'t', 
        (char )'r',      (char )'a',      (char )'c',      (char )'t', 
        (char )' ',      (char )' ',      (char )' ',      (char )'-', 
        (char )'x',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )':',      (char )' ',      (char )'s', 
        (char )'e',      (char )'l',      (char )'e',      (char )'c', 
        (char )'t',      (char )' ',      (char )'\'',      (char )'e', 
        (char )'x',      (char )'t',      (char )'r',      (char )'a', 
        (char )'c',      (char )'t',      (char )'\'',      (char )' ', 
        (char )'f',      (char )'u',      (char )'n',      (char )'c', 
        (char )'t',      (char )'i',      (char )'o',      (char )'n', 
        (char )'.',      (char )'\n',      (char )' ',      (char )' ', 
        (char )' ',      (char )'-',      (char )'-',      (char )'d', 
        (char )'i',      (char )'f',      (char )'f',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'-',      (char )'d',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )':', 
        (char )' ',      (char )'s',      (char )'e',      (char )'l', 
        (char )'e',      (char )'c',      (char )'t',      (char )' ', 
        (char )'\'',      (char )'d',      (char )'i',      (char )'f', 
        (char )'f',      (char )'\'',      (char )' ',      (char )'f', 
        (char )'u',      (char )'n',      (char )'c',      (char )'t', 
        (char )'i',      (char )'o',      (char )'n',      (char )'.', 
        (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )'-',      (char )'-',      (char )'m',      (char )'e', 
        (char )'r',      (char )'g',      (char )'e',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'-',      (char )'m',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )':',      (char )' ', 
        (char )'s',      (char )'e',      (char )'l',      (char )'e', 
        (char )'c',      (char )'t',      (char )' ',      (char )'\'', 
        (char )'m',      (char )'e',      (char )'r',      (char )'g', 
        (char )'e',      (char )'\'',      (char )' ',      (char )'f', 
        (char )'u',      (char )'n',      (char )'c',      (char )'t', 
        (char )'i',      (char )'o',      (char )'n',      (char )' ', 
        (char )'(',      (char )'d',      (char )'e',      (char )'f', 
        (char )'a',      (char )'u',      (char )'l',      (char )'t', 
        (char )')',      (char )'.',      (char )'\n',      (char )' ', 
        (char )' ',      (char )' ',      (char )'-',      (char )'-', 
        (char )'b',      (char )'r',      (char )'o',      (char )'w', 
        (char )'s',      (char )'e',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'-',      (char )'B', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )':',      (char )' ',      (char )'s',      (char )'e', 
        (char )'l',      (char )'e',      (char )'c',      (char )'t', 
        (char )' ',      (char )'\'',      (char )'b',      (char )'r', 
        (char )'o',      (char )'w',      (char )'s',      (char )'e', 
        (char )'\'',      (char )' ',      (char )'f',      (char )'u', 
        (char )'n',      (char )'c',      (char )'t',      (char )'i', 
        (char )'o',      (char )'n',      (char )'.',      (char )'\n', 
        (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )'-',      (char )'-',      (char )'w',      (char )'o', 
        (char )'r',      (char )'d',      (char )'s',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'-',      (char )'w',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )':',      (char )' ', 
        (char )'w',      (char )'o',      (char )'r',      (char )'d', 
        (char )'-',      (char )'w',      (char )'i',      (char )'s', 
        (char )'e',      (char )' ',      (char )'d',      (char )'i', 
        (char )'f',      (char )'f',      (char )' ',      (char )'a', 
        (char )'n',      (char )'d',      (char )' ',      (char )'m', 
        (char )'e',      (char )'r',      (char )'g',      (char )'e', 
        (char )'.',      (char )'\n',      (char )' ',      (char )' ', 
        (char )' ',      (char )'-',      (char )'-',      (char )'l', 
        (char )'i',      (char )'n',      (char )'e',      (char )'s', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'-',      (char )'l',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )':', 
        (char )' ',      (char )'l',      (char )'i',      (char )'n', 
        (char )'e',      (char )'-',      (char )'w',      (char )'i', 
        (char )'s',      (char )'e',      (char )' ',      (char )'d', 
        (char )'i',      (char )'f',      (char )'f',      (char )' ', 
        (char )'a',      (char )'n',      (char )'d',      (char )' ', 
        (char )'m',      (char )'e',      (char )'r',      (char )'g', 
        (char )'e',      (char )'.',      (char )'\n',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )'-', 
        (char )'-',      (char )'p',      (char )'a',      (char )'t', 
        (char )'c',      (char )'h',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'-', 
        (char )'p',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )':',      (char )' ',      (char )'t', 
        (char )'r',      (char )'e',      (char )'a',      (char )'t', 
        (char )' ',      (char )'l',      (char )'a',      (char )'s', 
        (char )'t',      (char )' ',      (char )'f',      (char )'i', 
        (char )'l',      (char )'e',      (char )' ',      (char )'a', 
        (char )'s',      (char )' ',      (char )'a',      (char )' ', 
        (char )'p',      (char )'a',      (char )'t',      (char )'c', 
        (char )'h',      (char )' ',      (char )'f',      (char )'i', 
        (char )'l',      (char )'e',      (char )'.',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )'-', 
        (char )'1',      (char )' ',      (char )' ',      (char )'-', 
        (char )'2',      (char )' ',      (char )' ',      (char )'-', 
        (char )'3',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )':',      (char )' ',      (char )'s', 
        (char )'e',      (char )'l',      (char )'e',      (char )'c', 
        (char )'t',      (char )' ',      (char )'w',      (char )'h', 
        (char )'i',      (char )'c',      (char )'h',      (char )' ', 
        (char )'c',      (char )'o',      (char )'m',      (char )'p', 
        (char )'o',      (char )'n',      (char )'e',      (char )'n', 
        (char )'t',      (char )' ',      (char )'o',      (char )'f', 
        (char )' ',      (char )'p',      (char )'a',      (char )'t', 
        (char )'c',      (char )'h',      (char )' ',      (char )'o', 
        (char )'r',      (char )' ',      (char )'m',      (char )'e', 
        (char )'r',      (char )'g',      (char )'e',      (char )' ', 
        (char )'t',      (char )'o',      (char )' ',      (char )'u', 
        (char )'s',      (char )'e',      (char )'.',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )'-', 
        (char )'-',      (char )'r',      (char )'e',      (char )'v', 
        (char )'e',      (char )'r',      (char )'s',      (char )'e', 
        (char )' ',      (char )' ',      (char )' ',      (char )'-', 
        (char )'R',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )':',      (char )' ',      (char )'s', 
        (char )'w',      (char )'a',      (char )'p',      (char )' ', 
        (char )'\'',      (char )'b',      (char )'e',      (char )'f', 
        (char )'o',      (char )'r',      (char )'e',      (char )'\'', 
        (char )' ',      (char )'a',      (char )'n',      (char )'d', 
        (char )' ',      (char )'\'',      (char )'a',      (char )'f', 
        (char )'t',      (char )'e',      (char )'r',      (char )'\'', 
        (char )' ',      (char )'f',      (char )'o',      (char )'r', 
        (char )' ',      (char )'d',      (char )'i',      (char )'f', 
        (char )'f',      (char )' ',      (char )'f',      (char )'u', 
        (char )'n',      (char )'c',      (char )'t',      (char )'i', 
        (char )'o',      (char )'n',      (char )'.',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )'-', 
        (char )'-',      (char )'n',      (char )'o',      (char )'-', 
        (char )'i',      (char )'g',      (char )'n',      (char )'o', 
        (char )'r',      (char )'e',      (char )' ',      (char )'-', 
        (char )'i',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )':',      (char )' ',      (char )'D', 
        (char )'o',      (char )'n',      (char )'\'',      (char )'t', 
        (char )' ',      (char )'i',      (char )'g',      (char )'n', 
        (char )'o',      (char )'r',      (char )'e',      (char )' ', 
        (char )'a',      (char )'l',      (char )'r',      (char )'e', 
        (char )'a',      (char )'d',      (char )'y',      (char )'-', 
        (char )'a',      (char )'p',      (char )'p',      (char )'l', 
        (char )'i',      (char )'e',      (char )'d',      (char )' ', 
        (char )'c',      (char )'h',      (char )'a',      (char )'n', 
        (char )'g',      (char )'e',      (char )'s',      (char )'.', 
        (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )'-',      (char )'-',      (char )'s',      (char )'h', 
        (char )'o',      (char )'w',      (char )'-',      (char )'w', 
        (char )'i',      (char )'g',      (char )'g',      (char )'l', 
        (char )'e',      (char )' ',      (char )'-',      (char )'W', 
        (char )' ',      (char )' ',      (char )':',      (char )' ', 
        (char )'R',      (char )'e',      (char )'p',      (char )'o', 
        (char )'r',      (char )'t',      (char )' ',      (char )'w', 
        (char )'i',      (char )'g',      (char )'g',      (char )'l', 
        (char )'e',      (char )'s',      (char )' ',      (char )'l', 
        (char )'i',      (char )'k',      (char )'e',      (char )' ', 
        (char )'c',      (char )'o',      (char )'n',      (char )'f', 
        (char )'l',      (char )'i',      (char )'c',      (char )'t', 
        (char )'s',      (char )' ',      (char )'w',      (char )'i', 
        (char )'t',      (char )'h',      (char )' ',      (char )'a', 
        (char )'n',      (char )' ',      (char )'e',      (char )'x', 
        (char )'t',      (char )'r',      (char )'a',      (char )' ', 
        (char )'s',      (char )'t',      (char )'a',      (char )'n', 
        (char )'z',      (char )'a',      (char )'.',      (char )'\n', 
        (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )'-',      (char )'-',      (char )'h',      (char )'e', 
        (char )'l',      (char )'p',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'-',      (char )'h',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )':',      (char )' ', 
        (char )'g',      (char )'e',      (char )'t',      (char )' ', 
        (char )'h',      (char )'e',      (char )'l',      (char )'p', 
        (char )'.',      (char )'\n',      (char )' ',      (char )' ', 
        (char )' ',      (char )'-',      (char )'-',      (char )'v', 
        (char )'e',      (char )'r',      (char )'s',      (char )'i', 
        (char )'o',      (char )'n',      (char )' ',      (char )' ', 
        (char )' ',      (char )'-',      (char )'V',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )':', 
        (char )' ',      (char )'g',      (char )'e',      (char )'t', 
        (char )' ',      (char )'v',      (char )'e',      (char )'r', 
        (char )'s',      (char )'i',      (char )'o',      (char )'n', 
        (char )' ',      (char )'o',      (char )'f',      (char )' ', 
        (char )'w',      (char )'i',      (char )'g',      (char )'g', 
        (char )'l',      (char )'e',      (char )'.',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )'-', 
        (char )'-',      (char )'v',      (char )'e',      (char )'r', 
        (char )'b',      (char )'o',      (char )'s',      (char )'e', 
        (char )' ',      (char )' ',      (char )' ',      (char )'-', 
        (char )'v',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )':',      (char )' ',      (char )'(', 
        (char )'p',      (char )'o',      (char )'t',      (char )'e', 
        (char )'n',      (char )'t',      (char )'i',      (char )'a', 
        (char )'l',      (char )'l',      (char )'y',      (char )')', 
        (char )' ',      (char )'b',      (char )'e',      (char )' ', 
        (char )'m',      (char )'o',      (char )'r',      (char )'e', 
        (char )' ',      (char )'v',      (char )'e',      (char )'r', 
        (char )'b',      (char )'o',      (char )'s',      (char )'e', 
        (char )'.',      (char )'\n',      (char )' ',      (char )' ', 
        (char )' ',      (char )'-',      (char )'-',      (char )'q', 
        (char )'u',      (char )'i',      (char )'e',      (char )'t', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'-',      (char )'q',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )':', 
        (char )' ',      (char )'d',      (char )'o',      (char )'n', 
        (char )'\'',      (char )'t',      (char )' ',      (char )'p', 
        (char )'r',      (char )'i',      (char )'n',      (char )'t', 
        (char )' ',      (char )'u',      (char )'n',      (char )'-', 
        (char )'n',      (char )'e',      (char )'c',      (char )'e', 
        (char )'s',      (char )'s',      (char )'a',      (char )'r', 
        (char )'y',      (char )' ',      (char )'m',      (char )'e', 
        (char )'s',      (char )'s',      (char )'a',      (char )'g', 
        (char )'e',      (char )'s',      (char )'.',      (char )'\n', 
        (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )'-',      (char )'-',      (char )'r',      (char )'e', 
        (char )'p',      (char )'l',      (char )'a',      (char )'c', 
        (char )'e',      (char )' ',      (char )' ',      (char )' ', 
        (char )'-',      (char )'r',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )':',      (char )' ', 
        (char )'r',      (char )'e',      (char )'p',      (char )'l', 
        (char )'a',      (char )'c',      (char )'e',      (char )' ', 
        (char )'f',      (char )'i',      (char )'r',      (char )'s', 
        (char )'t',      (char )' ',      (char )'f',      (char )'i', 
        (char )'l',      (char )'e',      (char )' ',      (char )'w', 
        (char )'i',      (char )'t',      (char )'h',      (char )' ', 
        (char )'r',      (char )'e',      (char )'s',      (char )'u', 
        (char )'l',      (char )'t',      (char )' ',      (char )'o', 
        (char )'f',      (char )' ',      (char )'m',      (char )'e', 
        (char )'r',      (char )'g',      (char )'e',      (char )'r', 
        (char )'.',      (char )'\n',      (char )'\n',      (char )' ', 
        (char )' ',      (char )' ',      (char )'-',      (char )'-', 
        (char )'s',      (char )'t',      (char )'r',      (char )'i', 
        (char )'p',      (char )'=',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'-',      (char )'p', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )':',      (char )' ',      (char )'n',      (char )'u', 
        (char )'m',      (char )'b',      (char )'e',      (char )'r', 
        (char )' ',      (char )'o',      (char )'f',      (char )' ', 
        (char )'p',      (char )'a',      (char )'t',      (char )'h', 
        (char )' ',      (char )'c',      (char )'o',      (char )'m', 
        (char )'p',      (char )'o',      (char )'n',      (char )'e', 
        (char )'n',      (char )'t',      (char )'s',      (char )' ', 
        (char )'t',      (char )'o',      (char )' ',      (char )'s', 
        (char )'t',      (char )'r',      (char )'i',      (char )'p', 
        (char )' ',      (char )'f',      (char )'r',      (char )'o', 
        (char )'m',      (char )' ',      (char )'f',      (char )'i', 
        (char )'l',      (char )'e',      (char )' ',      (char )'n', 
        (char )'a',      (char )'m',      (char )'e',      (char )'s', 
        (char )'.',      (char )'\n',      (char )'\n',      (char )'W', 
        (char )'i',      (char )'g',      (char )'g',      (char )'l', 
        (char )'e',      (char )' ',      (char )'n',      (char )'e', 
        (char )'e',      (char )'d',      (char )'s',      (char )' ', 
        (char )'t',      (char )'o',      (char )' ',      (char )'b', 
        (char )'e',      (char )' ',      (char )'g',      (char )'i', 
        (char )'v',      (char )'e',      (char )'n',      (char )' ', 
        (char )'1',      (char )',',      (char )' ',      (char )'2', 
        (char )',',      (char )' ',      (char )'o',      (char )'r', 
        (char )' ',      (char )'3',      (char )' ',      (char )'f', 
        (char )'i',      (char )'l',      (char )'e',      (char )'s', 
        (char )'.',      (char )' ',      (char )' ',      (char )'A', 
        (char )'n',      (char )'y',      (char )' ',      (char )'o', 
        (char )'n',      (char )'e',      (char )' ',      (char )'o', 
        (char )'f',      (char )' ',      (char )'t',      (char )'h', 
        (char )'e',      (char )'s',      (char )'e',      (char )' ', 
        (char )'c',      (char )'a',      (char )'n',      (char )'\n', 
        (char )'b',      (char )'e',      (char )' ',      (char )'g', 
        (char )'i',      (char )'v',      (char )'e',      (char )'n', 
        (char )' ',      (char )'a',      (char )'s',      (char )' ', 
        (char )'\'',      (char )'-',      (char )'\'',      (char )' ', 
        (char )'t',      (char )'o',      (char )' ',      (char )'s', 
        (char )'i',      (char )'g',      (char )'n',      (char )'i', 
        (char )'f',      (char )'y',      (char )' ',      (char )'s', 
        (char )'t',      (char )'a',      (char )'n',      (char )'d', 
        (char )'a',      (char )'r',      (char )'d',      (char )' ', 
        (char )'i',      (char )'n',      (char )'p',      (char )'u', 
        (char )'t',      (char )'.',      (char )'\n',      (char )'\n', 
        (char )'\000'};
#line 96 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/ReadMe.c"
char HelpExtract[416]  = 
#line 96
  {      (char )'\n',      (char )'w',      (char )'i',      (char )'g', 
        (char )'g',      (char )'l',      (char )'e',      (char )' ', 
        (char )'-',      (char )'-',      (char )'e',      (char )'x', 
        (char )'t',      (char )'r',      (char )'a',      (char )'c', 
        (char )'t',      (char )' ',      (char )'-',      (char )'[', 
        (char )'1',      (char )'2',      (char )'3',      (char )']', 
        (char )' ',      (char )'[',      (char )'-',      (char )'-', 
        (char )'p',      (char )'a',      (char )'t',      (char )'c', 
        (char )'h',      (char )']',      (char )' ',      (char )' ', 
        (char )'m',      (char )'e',      (char )'r',      (char )'g', 
        (char )'e',      (char )'-',      (char )'o',      (char )'r', 
        (char )'-',      (char )'p',      (char )'a',      (char )'t', 
        (char )'c',      (char )'h',      (char )'\n',      (char )'\n', 
        (char )'T',      (char )'h',      (char )'e',      (char )' ', 
        (char )'e',      (char )'x',      (char )'t',      (char )'r', 
        (char )'a',      (char )'c',      (char )'t',      (char )' ', 
        (char )'f',      (char )'u',      (char )'n',      (char )'c', 
        (char )'t',      (char )'i',      (char )'o',      (char )'n', 
        (char )' ',      (char )'a',      (char )'l',      (char )'l', 
        (char )'o',      (char )'w',      (char )'s',      (char )' ', 
        (char )'o',      (char )'n',      (char )'e',      (char )' ', 
        (char )'b',      (char )'r',      (char )'a',      (char )'n', 
        (char )'c',      (char )'h',      (char )' ',      (char )'o', 
        (char )'f',      (char )' ',      (char )'a',      (char )' ', 
        (char )'p',      (char )'a',      (char )'t',      (char )'c', 
        (char )'h',      (char )' ',      (char )'o',      (char )'r', 
        (char )' ',      (char )'m',      (char )'e',      (char )'r', 
        (char )'g',      (char )'e',      (char )' ',      (char )'f', 
        (char )'i',      (char )'l',      (char )'e',      (char )'\n', 
        (char )'t',      (char )'o',      (char )' ',      (char )'b', 
        (char )'e',      (char )' ',      (char )'e',      (char )'x', 
        (char )'t',      (char )'r',      (char )'a',      (char )'c', 
        (char )'t',      (char )'e',      (char )'d',      (char )'.', 
        (char )' ',      (char )' ',      (char )'A',      (char )' ', 
        (char )'\'',      (char )'p',      (char )'a',      (char )'t', 
        (char )'c',      (char )'h',      (char )'\'',      (char )' ', 
        (char )'i',      (char )'s',      (char )' ',      (char )'t', 
        (char )'h',      (char )'e',      (char )' ',      (char )'o', 
        (char )'u',      (char )'t',      (char )'p',      (char )'u', 
        (char )'t',      (char )' ',      (char )'o',      (char )'f', 
        (char )' ',      (char )'\'',      (char )'d',      (char )'i', 
        (char )'f',      (char )'f',      (char )' ',      (char )'-', 
        (char )'c',      (char )'\'',      (char )' ',      (char )'o', 
        (char )'r',      (char )' ',      (char )'\'',      (char )'d', 
        (char )'i',      (char )'f',      (char )'f',      (char )' ', 
        (char )'-',      (char )'u',      (char )'\'',      (char )'.', 
        (char )'\n',      (char )'E',      (char )'i',      (char )'t', 
        (char )'h',      (char )'e',      (char )'r',      (char )' ', 
        (char )'t',      (char )'h',      (char )'e',      (char )' ', 
        (char )'b',      (char )'e',      (char )'f',      (char )'o', 
        (char )'r',      (char )'e',      (char )' ',      (char )'(', 
        (char )'-',      (char )'1',      (char )')',      (char )' ', 
        (char )'o',      (char )'r',      (char )' ',      (char )'a', 
        (char )'f',      (char )'t',      (char )'e',      (char )'r', 
        (char )' ',      (char )'(',      (char )'-',      (char )'2', 
        (char )')',      (char )' ',      (char )'b',      (char )'r', 
        (char )'a',      (char )'n',      (char )'c',      (char )'h', 
        (char )' ',      (char )'c',      (char )'a',      (char )'n', 
        (char )' ',      (char )'b',      (char )'e',      (char )' ', 
        (char )'e',      (char )'x',      (char )'t',      (char )'r', 
        (char )'a',      (char )'c',      (char )'t',      (char )'e', 
        (char )'d',      (char )'.',      (char )'\n',      (char )'\n', 
        (char )'A',      (char )' ',      (char )'\'',      (char )'m', 
        (char )'e',      (char )'r',      (char )'g',      (char )'e', 
        (char )'\'',      (char )' ',      (char )'i',      (char )'s', 
        (char )' ',      (char )'t',      (char )'h',      (char )'e', 
        (char )' ',      (char )'o',      (char )'u',      (char )'t', 
        (char )'p',      (char )'u',      (char )'t',      (char )' ', 
        (char )'o',      (char )'f',      (char )' ',      (char )'\'', 
        (char )'d',      (char )'i',      (char )'f',      (char )'f', 
        (char )'3',      (char )' ',      (char )'-',      (char )'m', 
        (char )'\'',      (char )' ',      (char )'o',      (char )'r', 
        (char )' ',      (char )'\'',      (char )'m',      (char )'e', 
        (char )'r',      (char )'g',      (char )'e',      (char )' ', 
        (char )'-',      (char )'A',      (char )'\'',      (char )'.', 
        (char )' ',      (char )' ',      (char )'E',      (char )'i', 
        (char )'t',      (char )'h',      (char )'e',      (char )'r', 
        (char )' ',      (char )'t',      (char )'h',      (char )'e', 
        (char )'\n',      (char )'f',      (char )'i',      (char )'r', 
        (char )'s',      (char )'t',      (char )',',      (char )' ', 
        (char )'s',      (char )'e',      (char )'c',      (char )'o', 
        (char )'n',      (char )'d',      (char )',',      (char )' ', 
        (char )'o',      (char )'r',      (char )' ',      (char )'t', 
        (char )'h',      (char )'i',      (char )'r',      (char )'d', 
        (char )' ',      (char )'b',      (char )'r',      (char )'a', 
        (char )'n',      (char )'c',      (char )'h',      (char )' ', 
        (char )'c',      (char )'a',      (char )'n',      (char )' ', 
        (char )'b',      (char )'e',      (char )' ',      (char )'e', 
        (char )'x',      (char )'t',      (char )'r',      (char )'a', 
        (char )'c',      (char )'t',      (char )'e',      (char )'d', 
        (char )'.',      (char )'\n',      (char )'\n',      (char )'A', 
        (char )' ',      (char )'\'',      (char )'m',      (char )'e', 
        (char )'r',      (char )'g',      (char )'e',      (char )'\'', 
        (char )' ',      (char )'f',      (char )'i',      (char )'l', 
        (char )'e',      (char )' ',      (char )'i',      (char )'s', 
        (char )' ',      (char )'a',      (char )'s',      (char )'s', 
        (char )'u',      (char )'m',      (char )'e',      (char )'d', 
        (char )' ',      (char )'u',      (char )'n',      (char )'l', 
        (char )'e',      (char )'s',      (char )'s',      (char )' ', 
        (char )'-',      (char )'-',      (char )'p',      (char )'a', 
        (char )'t',      (char )'c',      (char )'h',      (char )' ', 
        (char )'i',      (char )'s',      (char )' ',      (char )'g', 
        (char )'i',      (char )'v',      (char )'e',      (char )'n', 
        (char )'.',      (char )'\n',      (char )'\n',      (char )'\000'};
#line 109 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/ReadMe.c"
char HelpDiff[813]  = 
#line 109
  {      (char )'\n',      (char )'w',      (char )'i',      (char )'g', 
        (char )'g',      (char )'l',      (char )'e',      (char )' ', 
        (char )'-',      (char )'-',      (char )'d',      (char )'i', 
        (char )'f',      (char )'f',      (char )' ',      (char )'[', 
        (char )'-',      (char )'w',      (char )'l',      (char )']', 
        (char )' ',      (char )'[',      (char )'-',      (char )'p', 
        (char )'1',      (char )'2',      (char )']',      (char )' ', 
        (char )'[',      (char )'-',      (char )'R',      (char )']', 
        (char )' ',      (char )' ',      (char )'f',      (char )'i', 
        (char )'l',      (char )'e',      (char )'-',      (char )'o', 
        (char )'r',      (char )'-',      (char )'p',      (char )'a', 
        (char )'t',      (char )'c',      (char )'h',      (char )' ', 
        (char )'[',      (char )'f',      (char )'i',      (char )'l', 
        (char )'e',      (char )'-',      (char )'o',      (char )'r', 
        (char )'-',      (char )'p',      (char )'a',      (char )'t', 
        (char )'c',      (char )'h',      (char )']',      (char )'\n', 
        (char )'\n',      (char )'T',      (char )'h',      (char )'e', 
        (char )' ',      (char )'d',      (char )'i',      (char )'f', 
        (char )'f',      (char )' ',      (char )'f',      (char )'u', 
        (char )'n',      (char )'c',      (char )'t',      (char )'i', 
        (char )'o',      (char )'n',      (char )' ',      (char )'w', 
        (char )'i',      (char )'l',      (char )'l',      (char )' ', 
        (char )'r',      (char )'e',      (char )'p',      (char )'o', 
        (char )'r',      (char )'t',      (char )' ',      (char )'t', 
        (char )'h',      (char )'e',      (char )' ',      (char )'d', 
        (char )'i',      (char )'f',      (char )'f',      (char )'e', 
        (char )'r',      (char )'e',      (char )'n',      (char )'c', 
        (char )'s',      (char )' ',      (char )'a',      (char )'n', 
        (char )'d',      (char )' ',      (char )'s',      (char )'i', 
        (char )'m',      (char )'i',      (char )'l',      (char )'a', 
        (char )'r',      (char )'i',      (char )'t',      (char )'i', 
        (char )'e',      (char )'s',      (char )' ',      (char )'b', 
        (char )'e',      (char )'t',      (char )'w',      (char )'e', 
        (char )'e',      (char )'n',      (char )'\n',      (char )'t', 
        (char )'w',      (char )'o',      (char )' ',      (char )'f', 
        (char )'i',      (char )'l',      (char )'e',      (char )'s', 
        (char )' ',      (char )'i',      (char )'n',      (char )' ', 
        (char )'a',      (char )' ',      (char )'f',      (char )'o', 
        (char )'r',      (char )'m',      (char )'a',      (char )'t', 
        (char )' ',      (char )'s',      (char )'i',      (char )'m', 
        (char )'i',      (char )'l',      (char )'a',      (char )'r', 
        (char )' ',      (char )'t',      (char )'o',      (char )' ', 
        (char )'\'',      (char )'d',      (char )'i',      (char )'f', 
        (char )'f',      (char )' ',      (char )'-',      (char )'u', 
        (char )'\'',      (char )'.',      (char )' ',      (char )' ', 
        (char )'W',      (char )'i',      (char )'t',      (char )'h', 
        (char )' ',      (char )'-',      (char )'-',      (char )'w', 
        (char )'o',      (char )'r',      (char )'d',      (char )' ', 
        (char )'m',      (char )'o',      (char )'d',      (char )'e', 
        (char )'\n',      (char )'(',      (char )'t',      (char )'h', 
        (char )'e',      (char )' ',      (char )'d',      (char )'e', 
        (char )'f',      (char )'a',      (char )'u',      (char )'l', 
        (char )'t',      (char )')',      (char )' ',      (char )'w', 
        (char )'o',      (char )'r',      (char )'d',      (char )'-', 
        (char )'w',      (char )'i',      (char )'s',      (char )'e', 
        (char )' ',      (char )'d',      (char )'i',      (char )'f', 
        (char )'f',      (char )'e',      (char )'r',      (char )'e', 
        (char )'n',      (char )'c',      (char )'e',      (char )'s', 
        (char )' ',      (char )'a',      (char )'r',      (char )'e', 
        (char )' ',      (char )'d',      (char )'i',      (char )'s', 
        (char )'p',      (char )'l',      (char )'a',      (char )'y', 
        (char )'e',      (char )'d',      (char )' ',      (char )'o', 
        (char )'n',      (char )' ',      (char )'l',      (char )'i', 
        (char )'n',      (char )'e',      (char )'s',      (char )' ', 
        (char )'s',      (char )'t',      (char )'a',      (char )'r', 
        (char )'t',      (char )'i',      (char )'n',      (char )'g', 
        (char )'\n',      (char )'w',      (char )'i',      (char )'t', 
        (char )'h',      (char )' ',      (char )'a',      (char )' ', 
        (char )'\'',      (char )'|',      (char )'\'',      (char )'.', 
        (char )' ',      (char )' ',      (char )'W',      (char )'i', 
        (char )'t',      (char )'h',      (char )' ',      (char )'-', 
        (char )'-',      (char )'l',      (char )'i',      (char )'n', 
        (char )'e',      (char )' ',      (char )'m',      (char )'o', 
        (char )'d',      (char )'e',      (char )',',      (char )' ', 
        (char )'o',      (char )'n',      (char )'l',      (char )'y', 
        (char )' ',      (char )'w',      (char )'h',      (char )'o', 
        (char )'l',      (char )'e',      (char )' ',      (char )'l', 
        (char )'i',      (char )'n',      (char )'e',      (char )'s', 
        (char )' ',      (char )'a',      (char )'r',      (char )'e', 
        (char )' ',      (char )'c',      (char )'o',      (char )'n', 
        (char )'s',      (char )'i',      (char )'d',      (char )'e', 
        (char )'r',      (char )'e',      (char )'d',      (char )'\n', 
        (char )'m',      (char )'u',      (char )'c',      (char )'h', 
        (char )' ',      (char )'l',      (char )'i',      (char )'k', 
        (char )'e',      (char )' ',      (char )'n',      (char )'o', 
        (char )'r',      (char )'m',      (char )'a',      (char )'l', 
        (char )' ',      (char )'d',      (char )'i',      (char )'f', 
        (char )'f',      (char )'.',      (char )'\n',      (char )'\n', 
        (char )'I',      (char )'f',      (char )' ',      (char )'o', 
        (char )'n',      (char )'e',      (char )' ',      (char )'f', 
        (char )'i',      (char )'l',      (char )'e',      (char )' ', 
        (char )'i',      (char )'s',      (char )' ',      (char )'g', 
        (char )'i',      (char )'v',      (char )'e',      (char )'n', 
        (char )' ',      (char )'i',      (char )'s',      (char )' ', 
        (char )'i',      (char )'t',      (char )' ',      (char )'a', 
        (char )'s',      (char )'s',      (char )'u',      (char )'m', 
        (char )'e',      (char )'d',      (char )' ',      (char )'t', 
        (char )'o',      (char )' ',      (char )'b',      (char )'e', 
        (char )' ',      (char )'a',      (char )' ',      (char )'p', 
        (char )'a',      (char )'t',      (char )'c',      (char )'h', 
        (char )',',      (char )' ',      (char )'a',      (char )'n', 
        (char )'d',      (char )' ',      (char )'t',      (char )'h', 
        (char )'e',      (char )' ',      (char )'t',      (char )'w', 
        (char )'o',      (char )'\n',      (char )'b',      (char )'r', 
        (char )'a',      (char )'n',      (char )'c',      (char )'h', 
        (char )'e',      (char )'s',      (char )' ',      (char )'o', 
        (char )'f',      (char )' ',      (char )'t',      (char )'h', 
        (char )'e',      (char )' ',      (char )'p',      (char )'a', 
        (char )'t',      (char )'c',      (char )'h',      (char )' ', 
        (char )'a',      (char )'r',      (char )'e',      (char )' ', 
        (char )'e',      (char )'x',      (char )'t',      (char )'r', 
        (char )'a',      (char )'c',      (char )'t',      (char )'e', 
        (char )'d',      (char )' ',      (char )'a',      (char )'n', 
        (char )'d',      (char )' ',      (char )'c',      (char )'o', 
        (char )'m',      (char )'p',      (char )'a',      (char )'r', 
        (char )'e',      (char )'d',      (char )'.',      (char )' ', 
        (char )' ',      (char )'I',      (char )'f',      (char )' ', 
        (char )'t',      (char )'w',      (char )'o',      (char )' ', 
        (char )'f',      (char )'i',      (char )'l',      (char )'e', 
        (char )'s',      (char )'\n',      (char )'a',      (char )'r', 
        (char )'e',      (char )' ',      (char )'g',      (char )'i', 
        (char )'v',      (char )'e',      (char )'n',      (char )' ', 
        (char )'t',      (char )'h',      (char )'e',      (char )'y', 
        (char )' ',      (char )'a',      (char )'r',      (char )'e', 
        (char )' ',      (char )'n',      (char )'o',      (char )'r', 
        (char )'m',      (char )'a',      (char )'l',      (char )'l', 
        (char )'y',      (char )' ',      (char )'a',      (char )'s', 
        (char )'s',      (char )'u',      (char )'m',      (char )'e', 
        (char )'d',      (char )' ',      (char )'t',      (char )'o', 
        (char )' ',      (char )'b',      (char )'e',      (char )' ', 
        (char )'w',      (char )'h',      (char )'o',      (char )'l', 
        (char )'e',      (char )' ',      (char )'f',      (char )'i', 
        (char )'l',      (char )'e',      (char )'s',      (char )' ', 
        (char )'a',      (char )'n',      (char )'d',      (char )' ', 
        (char )'a',      (char )'r',      (char )'e',      (char )' ', 
        (char )'c',      (char )'o',      (char )'m',      (char )'p', 
        (char )'a',      (char )'r',      (char )'e',      (char )'d', 
        (char )'.',      (char )'\n',      (char )'H',      (char )'o', 
        (char )'w',      (char )'e',      (char )'v',      (char )'e', 
        (char )'r',      (char )' ',      (char )'i',      (char )'f', 
        (char )' ',      (char )'t',      (char )'h',      (char )'e', 
        (char )' ',      (char )'-',      (char )'-',      (char )'p', 
        (char )'a',      (char )'t',      (char )'c',      (char )'h', 
        (char )' ',      (char )'o',      (char )'p',      (char )'t', 
        (char )'i',      (char )'o',      (char )'n',      (char )' ', 
        (char )'i',      (char )'s',      (char )' ',      (char )'g', 
        (char )'i',      (char )'v',      (char )'e',      (char )'n', 
        (char )' ',      (char )'w',      (char )'i',      (char )'t', 
        (char )'h',      (char )' ',      (char )'t',      (char )'w', 
        (char )'o',      (char )' ',      (char )'f',      (char )'i', 
        (char )'l',      (char )'e',      (char )'s',      (char )',', 
        (char )' ',      (char )'t',      (char )'h',      (char )'e', 
        (char )'n',      (char )' ',      (char )'t',      (char )'h', 
        (char )'e',      (char )'\n',      (char )'s',      (char )'e', 
        (char )'c',      (char )'o',      (char )'n',      (char )'d', 
        (char )' ',      (char )'i',      (char )'s',      (char )' ', 
        (char )'t',      (char )'r',      (char )'e',      (char )'a', 
        (char )'t',      (char )'e',      (char )'d',      (char )' ', 
        (char )'a',      (char )'s',      (char )' ',      (char )'a', 
        (char )' ',      (char )'p',      (char )'a',      (char )'t', 
        (char )'c',      (char )'h',      (char )' ',      (char )'a', 
        (char )'n',      (char )'d',      (char )' ',      (char )'t', 
        (char )'h',      (char )'e',      (char )' ',      (char )'f', 
        (char )'i',      (char )'r',      (char )'s',      (char )'t', 
        (char )' ',      (char )'o',      (char )'r',      (char )' ', 
        (char )'(',      (char )'w',      (char )'i',      (char )'t', 
        (char )'h',      (char )' ',      (char )'-',      (char )'2', 
        (char )')',      (char )' ',      (char )'s',      (char )'e', 
        (char )'c',      (char )'o',      (char )'n',      (char )'d', 
        (char )' ',      (char )'b',      (char )'r',      (char )'a', 
        (char )'n',      (char )'c',      (char )'h',      (char )'\n', 
        (char )'i',      (char )'s',      (char )' ',      (char )'e', 
        (char )'x',      (char )'t',      (char )'r',      (char )'a', 
        (char )'c',      (char )'t',      (char )'e',      (char )'d', 
        (char )' ',      (char )'a',      (char )'n',      (char )'d', 
        (char )' ',      (char )'c',      (char )'o',      (char )'m', 
        (char )'p',      (char )'a',      (char )'r',      (char )'e', 
        (char )'d',      (char )' ',      (char )'a',      (char )'g', 
        (char )'a',      (char )'i',      (char )'n',      (char )'s', 
        (char )'t',      (char )' ',      (char )'t',      (char )'h', 
        (char )'e',      (char )' ',      (char )'f',      (char )'i', 
        (char )'r',      (char )'s',      (char )'t',      (char )' ', 
        (char )'f',      (char )'i',      (char )'l',      (char )'e', 
        (char )'.',      (char )'\n',      (char )'\n',      (char )'-', 
        (char )'-',      (char )'r',      (char )'e',      (char )'v', 
        (char )'e',      (char )'r',      (char )'s',      (char )'e', 
        (char )' ',      (char )'(',      (char )'-',      (char )'R', 
        (char )')',      (char )' ',      (char )'w',      (char )'i', 
        (char )'t',      (char )'h',      (char )' ',      (char )'c', 
        (char )'a',      (char )'u',      (char )'s',      (char )'e', 
        (char )' ',      (char )'d',      (char )'i',      (char )'f', 
        (char )'f',      (char )' ',      (char )'t',      (char )'o', 
        (char )' ',      (char )'s',      (char )'w',      (char )'a', 
        (char )'p',      (char )' ',      (char )'t',      (char )'h', 
        (char )'e',      (char )' ',      (char )'t',      (char )'w', 
        (char )'o',      (char )' ',      (char )'f',      (char )'i', 
        (char )'l',      (char )'e',      (char )'s',      (char )' ', 
        (char )'b',      (char )'e',      (char )'f',      (char )'o', 
        (char )'r',      (char )'e',      (char )' ',      (char )'c', 
        (char )'o',      (char )'m',      (char )'p',      (char )'a', 
        (char )'r',      (char )'i',      (char )'n',      (char )'g', 
        (char )'\n',      (char )'t',      (char )'h',      (char )'e', 
        (char )'m',      (char )'.',      (char )'\n',      (char )'\n', 
        (char )'\000'};
#line 129 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/ReadMe.c"
char HelpMerge[1039]  = 
#line 129
  {      (char )'\n',      (char )'w',      (char )'i',      (char )'g', 
        (char )'g',      (char )'l',      (char )'e',      (char )' ', 
        (char )'-',      (char )'-',      (char )'m',      (char )'e', 
        (char )'r',      (char )'g',      (char )'e',      (char )' ', 
        (char )'[',      (char )'-',      (char )'w',      (char )'l', 
        (char )']',      (char )' ',      (char )'[',      (char )'-', 
        (char )'-',      (char )'r',      (char )'e',      (char )'p', 
        (char )'l',      (char )'a',      (char )'c',      (char )'e', 
        (char )']',      (char )' ',      (char )' ',      (char )'f', 
        (char )'i',      (char )'l',      (char )'e',      (char )'-', 
        (char )'o',      (char )'r',      (char )'-',      (char )'m', 
        (char )'e',      (char )'r',      (char )'g',      (char )'e', 
        (char )' ',      (char )'[',      (char )'f',      (char )'i', 
        (char )'l',      (char )'e',      (char )'-',      (char )'o', 
        (char )'r',      (char )'-',      (char )'p',      (char )'a', 
        (char )'t',      (char )'c',      (char )'h',      (char )' ', 
        (char )'[',      (char )'f',      (char )'i',      (char )'l', 
        (char )'e',      (char )']',      (char )']',      (char )'\n', 
        (char )'\n',      (char )'T',      (char )'h',      (char )'e', 
        (char )' ',      (char )'m',      (char )'e',      (char )'r', 
        (char )'g',      (char )'e',      (char )' ',      (char )'f', 
        (char )'u',      (char )'n',      (char )'c',      (char )'t', 
        (char )'i',      (char )'o',      (char )'n',      (char )' ', 
        (char )'i',      (char )'s',      (char )' ',      (char )'t', 
        (char )'h',      (char )'e',      (char )' ',      (char )'p', 
        (char )'r',      (char )'i',      (char )'m',      (char )'a', 
        (char )'r',      (char )'y',      (char )' ',      (char )'f', 
        (char )'u',      (char )'n',      (char )'c',      (char )'t', 
        (char )'i',      (char )'o',      (char )'n',      (char )' ', 
        (char )'o',      (char )'f',      (char )' ',      (char )'w', 
        (char )'i',      (char )'g',      (char )'g',      (char )'l', 
        (char )'e',      (char )' ',      (char )'a',      (char )'n', 
        (char )'d',      (char )' ',      (char )'i',      (char )'s', 
        (char )' ',      (char )'a',      (char )'s',      (char )'s', 
        (char )'u',      (char )'m',      (char )'e',      (char )'d', 
        (char )'\n',      (char )'i',      (char )'f',      (char )' ', 
        (char )'n',      (char )'o',      (char )' ',      (char )'f', 
        (char )'u',      (char )'n',      (char )'c',      (char )'t', 
        (char )'i',      (char )'o',      (char )'n',      (char )' ', 
        (char )'i',      (char )'s',      (char )' ',      (char )'e', 
        (char )'x',      (char )'p',      (char )'l',      (char )'i', 
        (char )'c',      (char )'i',      (char )'t',      (char )'l', 
        (char )'y',      (char )' ',      (char )'c',      (char )'h', 
        (char )'o',      (char )'s',      (char )'e',      (char )'n', 
        (char )'.',      (char )'\n',      (char )'\n',      (char )'N', 
        (char )'o',      (char )'r',      (char )'m',      (char )'a', 
        (char )'l',      (char )'l',      (char )'y',      (char )' ', 
        (char )'w',      (char )'i',      (char )'g',      (char )'g', 
        (char )'l',      (char )'e',      (char )' ',      (char )'w', 
        (char )'i',      (char )'l',      (char )'l',      (char )' ', 
        (char )'c',      (char )'o',      (char )'m',      (char )'p', 
        (char )'a',      (char )'r',      (char )'e',      (char )' ', 
        (char )'t',      (char )'h',      (char )'r',      (char )'e', 
        (char )'e',      (char )' ',      (char )'f',      (char )'i', 
        (char )'l',      (char )'e',      (char )'s',      (char )' ', 
        (char )'o',      (char )'n',      (char )' ',      (char )'a', 
        (char )' ',      (char )'w',      (char )'o',      (char )'r', 
        (char )'d',      (char )'-',      (char )'b',      (char )'y', 
        (char )'-',      (char )'w',      (char )'o',      (char )'r', 
        (char )'d',      (char )' ',      (char )'b',      (char )'a', 
        (char )'s',      (char )'i',      (char )'s',      (char )' ', 
        (char )'a',      (char )'n',      (char )'d',      (char )'\n', 
        (char )'o',      (char )'u',      (char )'t',      (char )'p', 
        (char )'u',      (char )'t',      (char )' ',      (char )'u', 
        (char )'n',      (char )'r',      (char )'e',      (char )'s', 
        (char )'o',      (char )'l',      (char )'v',      (char )'a', 
        (char )'b',      (char )'l',      (char )'e',      (char )' ', 
        (char )'c',      (char )'o',      (char )'n',      (char )'f', 
        (char )'l',      (char )'i',      (char )'c',      (char )'t', 
        (char )'s',      (char )' ',      (char )'i',      (char )'n', 
        (char )' ',      (char )'t',      (char )'h',      (char )'e', 
        (char )' ',      (char )'r',      (char )'e',      (char )'s', 
        (char )'u',      (char )'l',      (char )'t',      (char )'i', 
        (char )'n',      (char )'g',      (char )' ',      (char )'m', 
        (char )'e',      (char )'r',      (char )'g',      (char )'e', 
        (char )' ',      (char )'b',      (char )'y',      (char )' ', 
        (char )'s',      (char )'h',      (char )'o',      (char )'w', 
        (char )'i',      (char )'n',      (char )'g',      (char )'\n', 
        (char )'w',      (char )'h',      (char )'o',      (char )'l', 
        (char )'e',      (char )'-',      (char )'l',      (char )'i', 
        (char )'n',      (char )'e',      (char )' ',      (char )'d', 
        (char )'i',      (char )'f',      (char )'f',      (char )'e', 
        (char )'r',      (char )'e',      (char )'n',      (char )'c', 
        (char )'e',      (char )'s',      (char )'.',      (char )'\n', 
        (char )'W',      (char )'i',      (char )'t',      (char )'h', 
        (char )' ',      (char )'t',      (char )'h',      (char )'e', 
        (char )' ',      (char )'-',      (char )'-',      (char )'l', 
        (char )'i',      (char )'n',      (char )'e',      (char )'s', 
        (char )' ',      (char )'o',      (char )'p',      (char )'t', 
        (char )'i',      (char )'o',      (char )'n',      (char )',', 
        (char )' ',      (char )'t',      (char )'h',      (char )'e', 
        (char )' ',      (char )'f',      (char )'i',      (char )'l', 
        (char )'e',      (char )'s',      (char )' ',      (char )'a', 
        (char )'r',      (char )'e',      (char )' ',      (char )'c', 
        (char )'o',      (char )'m',      (char )'p',      (char )'a', 
        (char )'r',      (char )'e',      (char )'d',      (char )' ', 
        (char )'l',      (char )'i',      (char )'n',      (char )'e', 
        (char )'-',      (char )'w',      (char )'i',      (char )'s', 
        (char )'e',      (char )' ',      (char )'m',      (char )'u', 
        (char )'c',      (char )'h',      (char )'\n',      (char )'l', 
        (char )'i',      (char )'k',      (char )'e',      (char )' ', 
        (char )'\'',      (char )'m',      (char )'e',      (char )'r', 
        (char )'g',      (char )'e',      (char )'\'',      (char )'.', 
        (char )' ',      (char )' ',      (char )'W',      (char )'i', 
        (char )'t',      (char )'h',      (char )' ',      (char )'t', 
        (char )'h',      (char )'e',      (char )' ',      (char )'(', 
        (char )'d',      (char )'e',      (char )'f',      (char )'a', 
        (char )'u',      (char )'l',      (char )'t',      (char )')', 
        (char )' ',      (char )'-',      (char )'-',      (char )'w', 
        (char )'o',      (char )'r',      (char )'d',      (char )'s', 
        (char )' ',      (char )'o',      (char )'p',      (char )'t', 
        (char )'i',      (char )'o',      (char )'n',      (char )',', 
        (char )' ',      (char )'f',      (char )'i',      (char )'l', 
        (char )'e',      (char )'s',      (char )' ',      (char )'a', 
        (char )'r',      (char )'e',      (char )' ',      (char )'c', 
        (char )'o',      (char )'m',      (char )'p',      (char )'a', 
        (char )'r',      (char )'e',      (char )'d',      (char )'\n', 
        (char )'w',      (char )'o',      (char )'r',      (char )'d', 
        (char )'-',      (char )'w',      (char )'i',      (char )'s', 
        (char )'e',      (char )' ',      (char )'a',      (char )'n', 
        (char )'d',      (char )' ',      (char )'u',      (char )'n', 
        (char )'r',      (char )'e',      (char )'s',      (char )'o', 
        (char )'l',      (char )'v',      (char )'a',      (char )'b', 
        (char )'l',      (char )'e',      (char )' ',      (char )'c', 
        (char )'o',      (char )'n',      (char )'f',      (char )'l', 
        (char )'i',      (char )'c',      (char )'t',      (char )'s', 
        (char )' ',      (char )'a',      (char )'r',      (char )'e', 
        (char )' ',      (char )'r',      (char )'e',      (char )'p', 
        (char )'o',      (char )'r',      (char )'t',      (char )'e', 
        (char )'d',      (char )' ',      (char )'w',      (char )'o', 
        (char )'r',      (char )'d',      (char )'-',      (char )'w', 
        (char )'i',      (char )'s',      (char )'e',      (char )'.', 
        (char )'\n',      (char )'\n',      (char )'I',      (char )'f', 
        (char )' ',      (char )'-',      (char )'-',      (char )'m', 
        (char )'e',      (char )'r',      (char )'g',      (char )'e', 
        (char )' ',      (char )'i',      (char )'s',      (char )' ', 
        (char )'g',      (char )'i',      (char )'v',      (char )'e', 
        (char )'n',      (char )' ',      (char )'o',      (char )'n', 
        (char )'e',      (char )' ',      (char )'f',      (char )'i', 
        (char )'l',      (char )'e',      (char )',',      (char )' ', 
        (char )'i',      (char )'t',      (char )' ',      (char )'i', 
        (char )'s',      (char )' ',      (char )'t',      (char )'r', 
        (char )'e',      (char )'a',      (char )'t',      (char )'e', 
        (char )'d',      (char )' ',      (char )'a',      (char )'s', 
        (char )' ',      (char )'a',      (char )' ',      (char )'m', 
        (char )'e',      (char )'r',      (char )'g',      (char )'e', 
        (char )' ',      (char )'(',      (char )'m',      (char )'e', 
        (char )'r',      (char )'g',      (char )'e',      (char )' ', 
        (char )'-',      (char )'A',      (char )'\n',      (char )'o', 
        (char )'u',      (char )'t',      (char )'p',      (char )'u', 
        (char )'t',      (char )')',      (char )' ',      (char )'a', 
        (char )'n',      (char )'d',      (char )' ',      (char )'t', 
        (char )'h',      (char )'e',      (char )' ',      (char )'t', 
        (char )'h',      (char )'r',      (char )'e',      (char )'e', 
        (char )' ',      (char )'n',      (char )'e',      (char )'e', 
        (char )'d',      (char )'e',      (char )'d',      (char )' ', 
        (char )'s',      (char )'t',      (char )'r',      (char )'e', 
        (char )'a',      (char )'m',      (char )'s',      (char )' ', 
        (char )'a',      (char )'r',      (char )'e',      (char )' ', 
        (char )'e',      (char )'x',      (char )'t',      (char )'r', 
        (char )'a',      (char )'c',      (char )'t',      (char )'e', 
        (char )'d',      (char )' ',      (char )'f',      (char )'r', 
        (char )'o',      (char )'m',      (char )' ',      (char )'i', 
        (char )'t',      (char )'.',      (char )'\n',      (char )'I', 
        (char )'f',      (char )' ',      (char )'-',      (char )'-', 
        (char )'m',      (char )'e',      (char )'r',      (char )'g', 
        (char )'e',      (char )' ',      (char )'i',      (char )'s', 
        (char )' ',      (char )'g',      (char )'i',      (char )'v', 
        (char )'e',      (char )'n',      (char )' ',      (char )'o', 
        (char )'n',      (char )'e',      (char )' ',      (char )'f', 
        (char )'i',      (char )'l',      (char )'e',      (char )' ', 
        (char )'a',      (char )'n',      (char )'d',      (char )' ', 
        (char )'-',      (char )'p',      (char )',',      (char )' ', 
        (char )'i',      (char )'t',      (char )' ',      (char )'i', 
        (char )'s',      (char )' ',      (char )'a',      (char )' ', 
        (char )'p',      (char )'a',      (char )'t',      (char )'c', 
        (char )'h',      (char )' ',      (char )'w',      (char )'h', 
        (char )'i',      (char )'c',      (char )'h',      (char )' ', 
        (char )'i',      (char )'d',      (char )'e',      (char )'n', 
        (char )'t',      (char )'i',      (char )'f',      (char )'i', 
        (char )'e',      (char )'s',      (char )'\n',      (char )'t', 
        (char )'h',      (char )'e',      (char )' ',      (char )'f', 
        (char )'i',      (char )'l',      (char )'e',      (char )'s', 
        (char )' ',      (char )'t',      (char )'h',      (char )'a', 
        (char )'t',      (char )' ',      (char )'s',      (char )'h', 
        (char )'o',      (char )'u',      (char )'l',      (char )'d', 
        (char )' ',      (char )'b',      (char )'e',      (char )' ', 
        (char )'p',      (char )'a',      (char )'t',      (char )'c', 
        (char )'h',      (char )'e',      (char )'d',      (char )'.', 
        (char )'\n',      (char )'I',      (char )'f',      (char )' ', 
        (char )'-',      (char )'-',      (char )'m',      (char )'e', 
        (char )'r',      (char )'g',      (char )'e',      (char )' ', 
        (char )'i',      (char )'s',      (char )' ',      (char )'g', 
        (char )'i',      (char )'v',      (char )'e',      (char )'n', 
        (char )' ',      (char )'t',      (char )'w',      (char )'o', 
        (char )' ',      (char )'f',      (char )'i',      (char )'l', 
        (char )'e',      (char )'s',      (char )',',      (char )' ', 
        (char )'t',      (char )'h',      (char )'e',      (char )' ', 
        (char )'s',      (char )'e',      (char )'c',      (char )'o', 
        (char )'n',      (char )'d',      (char )' ',      (char )'i', 
        (char )'s',      (char )' ',      (char )'t',      (char )'r', 
        (char )'e',      (char )'a',      (char )'t',      (char )'e', 
        (char )'d',      (char )' ',      (char )'a',      (char )'s', 
        (char )' ',      (char )'a',      (char )' ',      (char )'p', 
        (char )'a',      (char )'t',      (char )'c',      (char )'h', 
        (char )'\n',      (char )'f',      (char )'i',      (char )'l', 
        (char )'e',      (char )' ',      (char )'a',      (char )'n', 
        (char )'d',      (char )' ',      (char )'t',      (char )'h', 
        (char )'e',      (char )' ',      (char )'f',      (char )'i', 
        (char )'r',      (char )'s',      (char )'t',      (char )' ', 
        (char )'i',      (char )'s',      (char )' ',      (char )'t', 
        (char )'h',      (char )'e',      (char )' ',      (char )'o', 
        (char )'r',      (char )'i',      (char )'g',      (char )'i', 
        (char )'n',      (char )'a',      (char )'l',      (char )' ', 
        (char )'f',      (char )'i',      (char )'l',      (char )'e', 
        (char )'.',      (char )'\n',      (char )'I',      (char )'f', 
        (char )' ',      (char )'-',      (char )'-',      (char )'m', 
        (char )'e',      (char )'r',      (char )'g',      (char )'e', 
        (char )' ',      (char )'i',      (char )'s',      (char )' ', 
        (char )'g',      (char )'i',      (char )'v',      (char )'e', 
        (char )'n',      (char )' ',      (char )'t',      (char )'h', 
        (char )'r',      (char )'e',      (char )'e',      (char )' ', 
        (char )'f',      (char )'i',      (char )'l',      (char )'e', 
        (char )'s',      (char )',',      (char )' ',      (char )'t', 
        (char )'h',      (char )'e',      (char )'y',      (char )' ', 
        (char )'a',      (char )'r',      (char )'e',      (char )' ', 
        (char )'e',      (char )'a',      (char )'c',      (char )'h', 
        (char )' ',      (char )'t',      (char )'r',      (char )'e', 
        (char )'a',      (char )'t',      (char )'e',      (char )'d', 
        (char )' ',      (char )'a',      (char )'s',      (char )' ', 
        (char )'w',      (char )'h',      (char )'o',      (char )'l', 
        (char )'e',      (char )' ',      (char )'f',      (char )'i', 
        (char )'l',      (char )'e',      (char )'s',      (char )'\n', 
        (char )'a',      (char )'n',      (char )'d',      (char )' ', 
        (char )'d',      (char )'i',      (char )'f',      (char )'f', 
        (char )'e',      (char )'r',      (char )'e',      (char )'n', 
        (char )'c',      (char )'e',      (char )'s',      (char )' ', 
        (char )'b',      (char )'e',      (char )'t',      (char )'w', 
        (char )'e',      (char )'e',      (char )'n',      (char )' ', 
        (char )'t',      (char )'h',      (char )'e',      (char )' ', 
        (char )'s',      (char )'e',      (char )'c',      (char )'o', 
        (char )'n',      (char )'d',      (char )' ',      (char )'a', 
        (char )'n',      (char )'d',      (char )' ',      (char )'t', 
        (char )'h',      (char )'i',      (char )'r',      (char )'d', 
        (char )' ',      (char )'a',      (char )'r',      (char )'e', 
        (char )' ',      (char )'m',      (char )'e',      (char )'r', 
        (char )'g',      (char )'e',      (char )'d',      (char )' ', 
        (char )'i',      (char )'n',      (char )'t',      (char )'o', 
        (char )' ',      (char )'t',      (char )'h',      (char )'e', 
        (char )' ',      (char )'f',      (char )'i',      (char )'r', 
        (char )'s',      (char )'t',      (char )'.',      (char )'\n', 
        (char )'T',      (char )'h',      (char )'i',      (char )'s', 
        (char )' ',      (char )'u',      (char )'s',      (char )'a', 
        (char )'g',      (char )'e',      (char )' ',      (char )'i', 
        (char )'s',      (char )' ',      (char )'m',      (char )'u', 
        (char )'c',      (char )'h',      (char )' ',      (char )'l', 
        (char )'i',      (char )'k',      (char )'e',      (char )' ', 
        (char )'\'',      (char )'m',      (char )'e',      (char )'r', 
        (char )'g',      (char )'e',      (char )'\'',      (char )'.', 
        (char )'\n',      (char )'\n',      (char )'\000'};
#line 153 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/ReadMe.c"
char HelpBrowse[808]  = 
#line 153
  {      (char )'\n',      (char )'w',      (char )'i',      (char )'g', 
        (char )'g',      (char )'l',      (char )'e',      (char )' ', 
        (char )'-',      (char )'-',      (char )'b',      (char )'r', 
        (char )'o',      (char )'w',      (char )'s',      (char )'e', 
        (char )' ',      (char )'[',      (char )'-',      (char )'R', 
        (char )']',      (char )' ',      (char )'[',      (char )'-', 
        (char )'-',      (char )'s',      (char )'t',      (char )'r', 
        (char )'i',      (char )'p',      (char )'=',      (char )'n', 
        (char )']',      (char )' ',      (char )'[',      (char )'-', 
        (char )'p',      (char )']',      (char )' ',      (char )'[', 
        (char )'f',      (char )'i',      (char )'l',      (char )'e', 
        (char )'s',      (char )']',      (char )'\n',      (char )'\n', 
        (char )'T',      (char )'h',      (char )'e',      (char )' ', 
        (char )'\'',      (char )'b',      (char )'r',      (char )'o', 
        (char )'w',      (char )'s',      (char )'e',      (char )'\'', 
        (char )' ',      (char )'f',      (char )'u',      (char )'n', 
        (char )'c',      (char )'t',      (char )'i',      (char )'o', 
        (char )'n',      (char )' ',      (char )'p',      (char )'r', 
        (char )'o',      (char )'v',      (char )'i',      (char )'d', 
        (char )'e',      (char )'s',      (char )' ',      (char )'a', 
        (char )'n',      (char )' ',      (char )'i',      (char )'n', 
        (char )'t',      (char )'e',      (char )'r',      (char )'a', 
        (char )'c',      (char )'t',      (char )'i',      (char )'v', 
        (char )'e',      (char )' ',      (char )'m',      (char )'o', 
        (char )'d',      (char )'e',      (char )' ',      (char )'f', 
        (char )'o',      (char )'r',      (char )' ',      (char )'b', 
        (char )'r',      (char )'o',      (char )'w',      (char )'s', 
        (char )'i',      (char )'n',      (char )'g',      (char )' ', 
        (char )'a',      (char )'\n',      (char )'p',      (char )'a', 
        (char )'t',      (char )'c',      (char )'h',      (char )' ', 
        (char )'o',      (char )'r',      (char )' ',      (char )'s', 
        (char )'e',      (char )'t',      (char )' ',      (char )'o', 
        (char )'f',      (char )' ',      (char )'p',      (char )'a', 
        (char )'t',      (char )'c',      (char )'h',      (char )'e', 
        (char )'s',      (char )'.',      (char )' ',      (char )' ', 
        (char )'I',      (char )'t',      (char )' ',      (char )'a', 
        (char )'l',      (char )'l',      (char )'o',      (char )'w', 
        (char )'s',      (char )' ',      (char )'t',      (char )'h', 
        (char )'e',      (char )' ',      (char )'a',      (char )'p', 
        (char )'p',      (char )'l',      (char )'i',      (char )'c', 
        (char )'a',      (char )'t',      (char )'i',      (char )'o', 
        (char )'n',      (char )' ',      (char )'o',      (char )'f', 
        (char )' ',      (char )'a',      (char )' ',      (char )'p', 
        (char )'a',      (char )'t',      (char )'c',      (char )'h', 
        (char )' ',      (char )'t',      (char )'o',      (char )' ', 
        (char )'e',      (char )'a',      (char )'c',      (char )'h', 
        (char )'\n',      (char )'f',      (char )'i',      (char )'l', 
        (char )'e',      (char )' ',      (char )'t',      (char )'o', 
        (char )' ',      (char )'b',      (char )'e',      (char )' ', 
        (char )'i',      (char )'n',      (char )'s',      (char )'p', 
        (char )'e',      (char )'c',      (char )'t',      (char )'e', 
        (char )'d',      (char )' ',      (char )'a',      (char )'n', 
        (char )'d',      (char )' ',      (char )'w',      (char )'i', 
        (char )'l',      (char )'l',      (char )' ',      (char )'e', 
        (char )'v',      (char )'e',      (char )'n',      (char )'t', 
        (char )'u',      (char )'a',      (char )'l',      (char )'l', 
        (char )'y',      (char )' ',      (char )'a',      (char )'l', 
        (char )'l',      (char )'o',      (char )'w',      (char )' ', 
        (char )'l',      (char )'i',      (char )'m',      (char )'i', 
        (char )'t',      (char )'e',      (char )'d',      (char )' ', 
        (char )'e',      (char )'d',      (char )'i',      (char )'t', 
        (char )'i',      (char )'n',      (char )'g',      (char )' ', 
        (char )'t',      (char )'o',      (char )' ',      (char )'c', 
        (char )'o',      (char )'r',      (char )'r',      (char )'e', 
        (char )'c',      (char )'t',      (char )'\n',      (char )'m', 
        (char )'i',      (char )'s',      (char )'-',      (char )'a', 
        (char )'p',      (char )'p',      (char )'l',      (char )'i', 
        (char )'c',      (char )'a',      (char )'t',      (char )'i', 
        (char )'o',      (char )'n',      (char )' ',      (char )'o', 
        (char )'f',      (char )' ',      (char )'p',      (char )'a', 
        (char )'t',      (char )'c',      (char )'h',      (char )'e', 
        (char )'s',      (char )' ',      (char )'w',      (char )'h', 
        (char )'e',      (char )'r',      (char )'e',      (char )' ', 
        (char )'w',      (char )'i',      (char )'g',      (char )'g', 
        (char )'l',      (char )'i',      (char )'n',      (char )'g', 
        (char )' ',      (char )'w',      (char )'a',      (char )'s', 
        (char )' ',      (char )'r',      (char )'e',      (char )'q', 
        (char )'u',      (char )'i',      (char )'r',      (char )'e', 
        (char )'d',      (char )',',      (char )' ',      (char )'a', 
        (char )'n',      (char )'d',      (char )' ',      (char )'w', 
        (char )'h',      (char )'e',      (char )'r',      (char )'e', 
        (char )' ',      (char )'c',      (char )'o',      (char )'n', 
        (char )'f',      (char )'l',      (char )'i',      (char )'c', 
        (char )'t',      (char )'s',      (char )'\n',      (char )'o', 
        (char )'c',      (char )'c',      (char )'u',      (char )'r', 
        (char )'r',      (char )'e',      (char )'d',      (char )'.', 
        (char )'\n',      (char )'I',      (char )'f',      (char )' ', 
        (char )'n',      (char )'o',      (char )' ',      (char )'f', 
        (char )'i',      (char )'l',      (char )'e',      (char )'s', 
        (char )' ',      (char )'a',      (char )'r',      (char )'e', 
        (char )' ',      (char )'g',      (char )'i',      (char )'v', 
        (char )'e',      (char )'n',      (char )',',      (char )' ', 
        (char )'a',      (char )' ',      (char )'p',      (char )'a', 
        (char )'t',      (char )'c',      (char )'h',      (char )' ', 
        (char )'f',      (char )'i',      (char )'l',      (char )'e', 
        (char )' ',      (char )'i',      (char )'s',      (char )' ', 
        (char )'r',      (char )'e',      (char )'a',      (char )'d', 
        (char )' ',      (char )'f',      (char )'r',      (char )'o', 
        (char )'m',      (char )' ',      (char )'s',      (char )'t', 
        (char )'d',      (char )'i',      (char )'n',      (char )'\n', 
        (char )'I',      (char )'f',      (char )' ',      (char )'o', 
        (char )'n',      (char )'e',      (char )' ',      (char )'f', 
        (char )'i',      (char )'l',      (char )'e',      (char )' ', 
        (char )'i',      (char )'s',      (char )' ',      (char )'g', 
        (char )'i',      (char )'v',      (char )'e',      (char )'n', 
        (char )' ',      (char )'w',      (char )'i',      (char )'t', 
        (char )'h',      (char )' ',      (char )'-',      (char )'p', 
        (char )',',      (char )' ',      (char )'i',      (char )'t', 
        (char )' ',      (char )'i',      (char )'s',      (char )' ', 
        (char )'t',      (char )'r',      (char )'e',      (char )'a', 
        (char )'t',      (char )'e',      (char )'d',      (char )' ', 
        (char )'a',      (char )'s',      (char )' ',      (char )'a', 
        (char )' ',      (char )'p',      (char )'a',      (char )'t', 
        (char )'c',      (char )'h',      (char )' ',      (char )'f', 
        (char )'i',      (char )'l',      (char )'e',      (char )'\n', 
        (char )'I',      (char )'f',      (char )' ',      (char )'o', 
        (char )'n',      (char )'e',      (char )' ',      (char )'f', 
        (char )'i',      (char )'l',      (char )'e',      (char )' ', 
        (char )'i',      (char )'s',      (char )' ',      (char )'g', 
        (char )'i',      (char )'v',      (char )'e',      (char )'n', 
        (char )' ',      (char )'w',      (char )'i',      (char )'t', 
        (char )'h',      (char )' ',      (char )'a',      (char )' ', 
        (char )'n',      (char )'a',      (char )'m',      (char )'e', 
        (char )' ',      (char )'e',      (char )'n',      (char )'d', 
        (char )'i',      (char )'n',      (char )'g',      (char )' ', 
        (char )'.',      (char )'r',      (char )'e',      (char )'j', 
        (char )',',      (char )' ',      (char )'i',      (char )'t', 
        (char )' ',      (char )'i',      (char )'s',      (char )' ', 
        (char )'t',      (char )'r',      (char )'e',      (char )'a', 
        (char )'t',      (char )'e',      (char )'d',      (char )' ', 
        (char )'a',      (char )'s',      (char )' ',      (char )'a', 
        (char )' ',      (char )'r',      (char )'e',      (char )'j', 
        (char )'e',      (char )'c',      (char )'t',      (char )' ', 
        (char )'f',      (char )'o',      (char )'r',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'a',      (char )' ',      (char )'f', 
        (char )'i',      (char )'l',      (char )'e',      (char )' ', 
        (char )'w',      (char )'i',      (char )'t',      (char )'h', 
        (char )' ',      (char )'m',      (char )'a',      (char )'t', 
        (char )'c',      (char )'h',      (char )'i',      (char )'n', 
        (char )'g',      (char )' ',      (char )'b',      (char )'a', 
        (char )'s',      (char )'e',      (char )'n',      (char )'a', 
        (char )'m',      (char )'e',      (char )'\n',      (char )'O', 
        (char )'t',      (char )'h',      (char )'e',      (char )'r', 
        (char )'w',      (char )'i',      (char )'s',      (char )'e', 
        (char )' ',      (char )'a',      (char )' ',      (char )'s', 
        (char )'i',      (char )'n',      (char )'g',      (char )'l', 
        (char )'e',      (char )' ',      (char )'f',      (char )'i', 
        (char )'l',      (char )'e',      (char )' ',      (char )'i', 
        (char )'s',      (char )' ',      (char )'a',      (char )'s', 
        (char )'s',      (char )'u',      (char )'m',      (char )'e', 
        (char )'d',      (char )' ',      (char )'t',      (char )'o', 
        (char )' ',      (char )'b',      (char )'e',      (char )' ', 
        (char )'a',      (char )' ',      (char )'m',      (char )'e', 
        (char )'r',      (char )'g',      (char )'e',      (char )' ', 
        (char )'o',      (char )'u',      (char )'t',      (char )'p', 
        (char )'u',      (char )'t',      (char )' ',      (char )'w', 
        (char )'i',      (char )'t',      (char )'h',      (char )' ', 
        (char )'c',      (char )'o',      (char )'n',      (char )'f', 
        (char )'l',      (char )'i',      (char )'c',      (char )'t', 
        (char )'s',      (char )'.',      (char )'\n',      (char )'I', 
        (char )'f',      (char )' ',      (char )'t',      (char )'w', 
        (char )'o',      (char )' ',      (char )'f',      (char )'i', 
        (char )'l',      (char )'e',      (char )'s',      (char )' ', 
        (char )'a',      (char )'r',      (char )'e',      (char )' ', 
        (char )'g',      (char )'i',      (char )'v',      (char )'e', 
        (char )'n',      (char )',',      (char )' ',      (char )'t', 
        (char )'h',      (char )'e',      (char )' ',      (char )'s', 
        (char )'e',      (char )'c',      (char )'o',      (char )'n', 
        (char )'d',      (char )' ',      (char )'i',      (char )'s', 
        (char )' ',      (char )'a',      (char )' ',      (char )'p', 
        (char )'a',      (char )'t',      (char )'c',      (char )'h', 
        (char )' ',      (char )'t',      (char )'o',      (char )' ', 
        (char )'a',      (char )'p',      (char )'p',      (char )'l', 
        (char )'y',      (char )' ',      (char )'t',      (char )'o', 
        (char )' ',      (char )'t',      (char )'h',      (char )'e', 
        (char )' ',      (char )'f',      (char )'i',      (char )'r', 
        (char )'s',      (char )'t',      (char )'.',      (char )'\n', 
        (char )'I',      (char )'f',      (char )' ',      (char )'t', 
        (char )'h',      (char )'r',      (char )'e',      (char )'e', 
        (char )' ',      (char )'f',      (char )'i',      (char )'l', 
        (char )'e',      (char )'s',      (char )' ',      (char )'a', 
        (char )'r',      (char )'e',      (char )' ',      (char )'g', 
        (char )'i',      (char )'v',      (char )'e',      (char )'n', 
        (char )' ',      (char )'t',      (char )'h',      (char )'e', 
        (char )'n',      (char )' ',      (char )'t',      (char )'h', 
        (char )'e',      (char )' ',      (char )'d',      (char )'i', 
        (char )'f',      (char )'f',      (char )'e',      (char )'r', 
        (char )'e',      (char )'n',      (char )'c',      (char )'e', 
        (char )' ',      (char )'b',      (char )'e',      (char )'t', 
        (char )'w',      (char )'e',      (char )'e',      (char )'n', 
        (char )' ',      (char )'2',      (char )'n',      (char )'d', 
        (char )' ',      (char )'a',      (char )'n',      (char )'d', 
        (char )' ',      (char )'3',      (char )'r',      (char )'d', 
        (char )' ',      (char )'i',      (char )'s',      (char )' ', 
        (char )'a',      (char )'p',      (char )'p',      (char )'l', 
        (char )'i',      (char )'e',      (char )'d',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'t',      (char )'o',      (char )' ', 
        (char )'t',      (char )'h',      (char )'e',      (char )' ', 
        (char )'f',      (char )'i',      (char )'r',      (char )'s', 
        (char )'t',      (char )'\n',      (char )'\n',      (char )'\000'};
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 156 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/wiggle.h"
struct file split_stream(struct stream s , int type ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 52 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/split.c"
static int split_internal(char *start , char *end , int type , struct elmnt *list ) 
{ 
  int cnt ;
  char *cp ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  uint32_t tmp___1 ;

  {
#line 55
  cnt = 0;
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    if (! ((unsigned long )start < (unsigned long )end)) {
#line 57
      goto while_break;
    }
#line 58
    cp = start;
#line 60
    if ((int )*cp == 0) {
#line 60
      if ((unsigned long )(cp + 19) < (unsigned long )end) {
#line 60
        if ((int )*(cp + 18) == 10) {
#line 62
          cp += 20;
        } else {
#line 60
          goto _L___2;
        }
      } else {
#line 60
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
      {
#line 65
      if (type == 0) {
#line 65
        goto case_0;
      }
#line 71
      if (type == 1) {
#line 71
        goto case_1;
      }
#line 64
      goto switch_break;
      case_0: /* CIL Label */ 
      {
#line 66
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 66
        if ((unsigned long )cp < (unsigned long )end) {
#line 66
          if (! ((int )*cp != 10)) {
#line 66
            goto while_break___0;
          }
        } else {
#line 66
          goto while_break___0;
        }
#line 67
        cp ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 68
      if ((unsigned long )cp < (unsigned long )end) {
#line 69
        cp ++;
      }
#line 70
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 72
      tmp___0 = __ctype_b_loc();
      }
#line 72
      if ((int const   )*(*tmp___0 + (int )*cp) & 8) {
#line 72
        goto _L___0;
      } else
#line 72
      if ((int )*cp == 95) {
        _L___0: /* CIL Label */ 
        {
#line 73
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 74
          cp ++;
#line 73
          if ((unsigned long )cp < (unsigned long )end) {
            {
#line 73
            tmp = __ctype_b_loc();
            }
#line 73
            if (! ((int const   )*(*tmp + (int )*cp) & 8)) {
#line 73
              if (! ((int )*cp == 95)) {
#line 73
                goto while_break___1;
              }
            }
          } else {
#line 73
            goto while_break___1;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      } else
#line 78
      if ((int )*cp == 32) {
#line 78
        goto _L;
      } else
#line 78
      if ((int )*cp == 9) {
        _L: /* CIL Label */ 
        {
#line 79
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 80
          cp ++;
#line 79
          if ((unsigned long )cp < (unsigned long )end) {
#line 79
            if (! ((int )*cp == 32)) {
#line 79
              if (! ((int )*cp == 9)) {
#line 79
                goto while_break___2;
              }
            }
          } else {
#line 79
            goto while_break___2;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
      } else {
#line 85
        cp ++;
      }
#line 86
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 88
    if (list) {
#line 89
      list->start = start;
#line 90
      list->len = (int )(cp - start);
#line 91
      if (*start) {
        {
#line 92
        tmp___1 = hash_any((void const   *)start, (unsigned long )list->len * sizeof(*start),
                           (uint32_t )0);
#line 92
        list->hash = (int )tmp___1;
        }
      } else {
        {
#line 94
        list->hash = atoi((char const   *)(start + 1));
        }
      }
#line 95
      list ++;
    }
#line 97
    cnt ++;
#line 98
    start = cp;
  }
  while_break: /* CIL Label */ ;
  }
#line 100
  return (cnt);
}
}
#line 103 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/split.c"
struct file split_stream(struct stream s , int type ) 
{ 
  int cnt ;
  struct file f ;
  char *c ;
  char *end ;
  void *tmp ;

  {
  {
#line 110
  end = s.body + s.len;
#line 111
  c = s.body;
#line 113
  cnt = split_internal(c, end, type, (struct elmnt *)((void *)0));
#line 114
  tmp = xmalloc((int )((unsigned long )cnt * sizeof(struct elmnt )));
#line 114
  f.list = (struct elmnt *)tmp;
#line 116
  f.elcnt = split_internal(c, end, type, f.list);
  }
#line 117
  return (f);
}
}
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 180
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *__old ,
                                                                             char const   *__new ) ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 306
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 405
extern  __attribute__((__nothrow__)) int ( /* format attribute */  asprintf)(char ** __restrict  __ptr ,
                                                                             char const   * __restrict  __fmt 
                                                                             , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 173
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 150 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 620
extern int ( __attribute__((__nonnull__(1))) mkstemp)(char *__template ) ;
#line 152 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/wiggle.h"
struct stream load_file(char *name ) ;
#line 153
int split_patch(struct stream f , struct stream *f1 , struct stream *f2 ) ;
#line 154
int split_merge(struct stream f , struct stream *f1 , struct stream *f2 , struct stream *f3 ) ;
#line 157
struct csl *pdiff(struct file a , struct file b , int chunks ) ;
#line 178
void die(void) ;
#line 182
int vpatch(int argc , char **argv , int patch , int strip , int reverse , int replace ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 366 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 93 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/wiggle.c"
char *Cmd  =    (char *)"wiggle";
#line 94 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/wiggle.c"
int do_trace  =    0;
#line 96 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/wiggle.c"
void die(void) 
{ 


  {
  {
#line 98
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: fatal error\n",
          Cmd);
#line 99
  abort();
#line 100
  exit(3);
  }
}
}
#line 103 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/wiggle.c"
void *xmalloc(int size ) 
{ 
  void *rv ;
  void *tmp ;
  char *msg ;
  size_t tmp___0 ;

  {
  {
#line 105
  tmp = malloc((size_t )size);
#line 105
  rv = tmp;
  }
#line 106
  if (size) {
#line 106
    if (! rv) {
      {
#line 107
      msg = (char *)"Failed to allocate memory - aborting\n";
#line 108
      tmp___0 = strlen((char const   *)msg);
#line 108
      write(2, (void const   *)msg, tmp___0);
#line 109
      exit(3);
      }
    }
  }
#line 111
  return (rv);
}
}
#line 114 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/wiggle.c"
void printword(FILE *f , struct elmnt e ) 
{ 
  int a ;
  int b ;
  int c ;

  {
#line 116
  if (*(e.start + 0)) {
    {
#line 117
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%.*s", e.len,
            e.start);
    }
  } else {
    {
#line 120
    sscanf((char const   */* __restrict  */)(e.start + 1), (char const   */* __restrict  */)"%d %d %d",
           & a, & b, & c);
#line 121
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"*** %d,%d **** %d\n",
            b, c, a);
    }
  }
#line 123
  return;
}
}
#line 125 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/wiggle.c"
static void printsep(struct elmnt e1 , struct elmnt e2 ) 
{ 
  int a ;
  int b ;
  int c ;
  int d ;
  int e ;
  int f ;

  {
  {
#line 128
  sscanf((char const   */* __restrict  */)(e1.start + 1), (char const   */* __restrict  */)"%d %d %d",
         & a, & b, & c);
#line 129
  sscanf((char const   */* __restrict  */)(e2.start + 1), (char const   */* __restrict  */)"%d %d %d",
         & d, & e, & f);
#line 130
  printf((char const   */* __restrict  */)"@@ -%d,%d +%d,%d @@\n", b, c, e, f);
  }
#line 131
  return;
}
}
#line 133 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/wiggle.c"
static int extract(int argc , char **argv , int ispatch , int which ) 
{ 
  struct stream f ;
  struct stream flist[3] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  ssize_t tmp___3 ;

  {
#line 140
  if (argc == 0) {
    {
#line 141
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: no file given for --extract\n",
            Cmd);
    }
#line 143
    return (2);
  }
#line 145
  if (argc > 1) {
    {
#line 146
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: only give one file for --extract\n",
            Cmd);
    }
#line 148
    return (2);
  }
  {
#line 150
  f = load_file(*(argv + 0));
  }
#line 151
  if ((unsigned long )f.body == (unsigned long )((void *)0)) {
    {
#line 152
    tmp = __errno_location();
#line 152
    tmp___0 = strerror(*tmp);
#line 152
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: cannot load file \'%s\' - %s\n",
            Cmd, *(argv + 0), tmp___0);
    }
#line 155
    return (2);
  }
#line 157
  if (ispatch) {
    {
#line 158
    tmp___1 = split_patch(f, & flist[0], & flist[1]);
    }
#line 158
    if (tmp___1 == 0) {
      {
#line 159
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: No chunk found in patch: %s\n",
              Cmd, *(argv + 0));
      }
#line 162
      return (0);
    }
  } else {
    {
#line 165
    tmp___2 = split_merge(f, & flist[0], & flist[1], & flist[2]);
    }
#line 165
    if (! tmp___2) {
      {
#line 166
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: merge file %s looks bad.\n",
              Cmd, *(argv + 0));
      }
#line 169
      return (2);
    }
  }
#line 172
  if ((unsigned long )flist[which - 49].body == (unsigned long )((void *)0)) {
    {
#line 173
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s has no -%c component.\n",
            Cmd, *(argv + 0), which);
    }
#line 176
    return (2);
  } else {
    {
#line 178
    tmp___3 = write(1, (void const   *)flist[which - 49].body, (size_t )flist[which - 49].len);
    }
#line 178
    if (tmp___3 != (ssize_t )flist[which - 49].len) {
#line 181
      return (2);
    }
  }
#line 183
  return (0);
}
}
#line 186 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/wiggle.c"
static int do_diff_lines(struct file *fl , struct csl *csl ) 
{ 
  int a ;
  int b ;
  int exit_status ;

  {
#line 189
  exit_status = 0;
#line 190
  b = 0;
#line 190
  a = b;
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 191
    if (! (a < (fl + 0)->elcnt)) {
#line 191
      if (! (b < (fl + 1)->elcnt)) {
#line 191
        goto while_break;
      }
    }
#line 192
    if (a < csl->a) {
#line 193
      if (*(((fl + 0)->list + a)->start + 0)) {
        {
#line 194
        printf((char const   */* __restrict  */)"-");
#line 195
        printword(stdout, *((fl + 0)->list + a));
        }
      }
#line 198
      a ++;
#line 199
      exit_status ++;
    } else
#line 200
    if (b < csl->b) {
#line 201
      if (*(((fl + 1)->list + b)->start + 0)) {
        {
#line 202
        printf((char const   */* __restrict  */)"+");
#line 203
        printword(stdout, *((fl + 1)->list + b));
        }
      }
#line 206
      b ++;
#line 207
      exit_status ++;
    } else {
#line 209
      if ((int )*(((fl + 0)->list + a)->start + 0) == 0) {
        {
#line 210
        printsep(*((fl + 0)->list + a), *((fl + 1)->list + b));
        }
      } else {
        {
#line 213
        printf((char const   */* __restrict  */)" ");
#line 214
        printword(stdout, *((fl + 0)->list + a));
        }
      }
#line 217
      a ++;
#line 218
      b ++;
#line 219
      if (a >= csl->a + csl->len) {
#line 220
        csl ++;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 223
  return (exit_status);
}
}
#line 226 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/wiggle.c"
static int do_diff_words(struct file *fl , struct csl *csl ) 
{ 
  int a ;
  int b ;
  int exit_status ;
  int sol ;
  int a1 ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int b1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  int a1___0 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 229
  exit_status = 0;
#line 230
  sol = 1;
#line 231
  b = 0;
#line 231
  a = b;
  {
#line 232
  while (1) {
    while_continue: /* CIL Label */ ;
#line 232
    if (! (a < (fl + 0)->elcnt)) {
#line 232
      if (! (b < (fl + 1)->elcnt)) {
#line 232
        goto while_break;
      }
    }
#line 233
    if (a < csl->a) {
#line 234
      exit_status ++;
#line 235
      if (sol) {
#line 241
        sol = 0;
#line 242
        a1 = a;
        {
#line 242
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 242
          if (! (a1 < csl->a)) {
#line 242
            goto while_break___0;
          }
          {
#line 243
          tmp = ends_line(*((fl + 0)->list + a1));
          }
#line 243
          if (tmp) {
#line 244
            sol = 1;
#line 245
            goto while_break___0;
          }
#line 242
          a1 ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 247
        if (sol) {
          {
#line 248
          printf((char const   */* __restrict  */)"-");
          }
          {
#line 249
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 249
            if (! (a < csl->a)) {
#line 249
              goto while_break___1;
            }
            {
#line 250
            printword(stdout, *((fl + 0)->list + a));
#line 251
            tmp___0 = ends_line(*((fl + 0)->list + a));
            }
#line 251
            if (tmp___0) {
#line 252
              a ++;
#line 253
              goto while_break___1;
            }
#line 249
            a ++;
          }
          while_break___1: /* CIL Label */ ;
          }
        } else {
          {
#line 257
          printf((char const   */* __restrict  */)"|");
          }
        }
      }
#line 259
      if (! sol) {
        {
#line 260
        printf((char const   */* __restrict  */)"<<<--");
        }
        {
#line 261
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 262
          if (sol) {
            {
#line 263
            printf((char const   */* __restrict  */)"|");
            }
          }
          {
#line 264
          printword(stdout, *((fl + 0)->list + a));
#line 265
          sol = ends_line(*((fl + 0)->list + a));
#line 266
          a ++;
          }
#line 261
          if (! (a < csl->a)) {
#line 261
            goto while_break___2;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
#line 268
        if (sol) {
#line 268
          tmp___1 = "|";
        } else {
#line 268
          tmp___1 = "";
        }
        {
#line 268
        printf((char const   */* __restrict  */)"%s-->>>", tmp___1);
#line 269
        sol = 0;
        }
      }
    } else
#line 271
    if (b < csl->b) {
#line 272
      exit_status ++;
#line 273
      if (sol) {
#line 275
        sol = 0;
#line 276
        b1 = b;
        {
#line 276
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 276
          if (! (b1 < csl->b)) {
#line 276
            goto while_break___3;
          }
          {
#line 277
          tmp___2 = ends_line(*((fl + 1)->list + b1));
          }
#line 277
          if (tmp___2) {
#line 278
            sol = 1;
#line 279
            goto while_break___3;
          }
#line 276
          b1 ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 281
        if (sol) {
          {
#line 282
          printf((char const   */* __restrict  */)"+");
          }
          {
#line 283
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 283
            if (! (b < csl->b)) {
#line 283
              goto while_break___4;
            }
            {
#line 284
            printword(stdout, *((fl + 1)->list + b));
#line 285
            tmp___3 = ends_line(*((fl + 1)->list + b));
            }
#line 285
            if (tmp___3) {
#line 286
              b ++;
#line 287
              goto while_break___4;
            }
#line 283
            b ++;
          }
          while_break___4: /* CIL Label */ ;
          }
        } else {
          {
#line 291
          printf((char const   */* __restrict  */)"|");
          }
        }
      }
#line 293
      if (! sol) {
        {
#line 294
        printf((char const   */* __restrict  */)"<<<++");
        }
        {
#line 295
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 296
          if (sol) {
            {
#line 297
            printf((char const   */* __restrict  */)"|");
            }
          }
          {
#line 298
          printword(stdout, *((fl + 1)->list + b));
#line 299
          sol = ends_line(*((fl + 1)->list + b));
#line 300
          b ++;
          }
#line 295
          if (! (b < csl->b)) {
#line 295
            goto while_break___5;
          }
        }
        while_break___5: /* CIL Label */ ;
        }
#line 302
        if (sol) {
#line 302
          tmp___4 = "|";
        } else {
#line 302
          tmp___4 = "";
        }
        {
#line 302
        printf((char const   */* __restrict  */)"%s++>>>", tmp___4);
#line 303
        sol = 0;
        }
      }
    } else {
#line 306
      if (sol) {
#line 308
        sol = 0;
#line 309
        a1___0 = a;
        {
#line 309
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 309
          if (! (a1___0 < csl->a + csl->len)) {
#line 309
            goto while_break___6;
          }
          {
#line 310
          tmp___5 = ends_line(*((fl + 0)->list + a1___0));
          }
#line 310
          if (tmp___5) {
#line 311
            sol = 1;
          }
#line 309
          a1___0 ++;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 312
        if (sol) {
#line 313
          if (*(((fl + 0)->list + a)->start + 0)) {
            {
#line 314
            printf((char const   */* __restrict  */)" ");
            }
            {
#line 315
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 315
              if (! (a < csl->a + csl->len)) {
#line 315
                goto while_break___7;
              }
              {
#line 316
              printword(stdout, *((fl + 0)->list + a));
#line 317
              tmp___6 = ends_line(*((fl + 0)->list + a));
              }
#line 317
              if (tmp___6) {
#line 318
                a ++;
#line 318
                b ++;
#line 319
                goto while_break___7;
              }
#line 315
              a ++;
#line 315
              b ++;
            }
            while_break___7: /* CIL Label */ ;
            }
          } else {
            {
#line 323
            printsep(*((fl + 0)->list + a), *((fl + 1)->list + b));
#line 324
            a ++;
#line 324
            b ++;
            }
          }
        } else {
          {
#line 327
          printf((char const   */* __restrict  */)"|");
          }
        }
      }
#line 329
      if (! sol) {
        {
#line 330
        printword(stdout, *((fl + 0)->list + a));
#line 331
        tmp___7 = ends_line(*((fl + 0)->list + a));
        }
#line 331
        if (tmp___7) {
#line 332
          sol = 1;
        }
#line 333
        a ++;
#line 334
        b ++;
      }
#line 336
      if (a >= csl->a + csl->len) {
#line 337
        csl ++;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 340
  return (exit_status);
}
}
#line 343 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/wiggle.c"
static int do_diff(int argc , char **argv , int obj , int ispatch , int which , int reverse ) 
{ 
  struct stream f ;
  struct stream flist[3] ;
  int chunks1 ;
  int chunks2 ;
  int chunks3 ;
  int exit_status ;
  struct file fl[2] ;
  struct csl *csl ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int l1 ;
  int l2 ;
  int i ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 348
  chunks1 = 0;
#line 348
  chunks2 = 0;
#line 348
  chunks3 = 0;
#line 349
  exit_status = 0;
  {
#line 354
  if (argc == 0) {
#line 354
    goto case_0;
  }
#line 357
  if (argc == 1) {
#line 357
    goto case_1;
  }
#line 374
  if (argc == 2) {
#line 374
    goto case_2;
  }
#line 410
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 355
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: no file given for --diff\n",
          Cmd);
  }
#line 356
  return (2);
  case_1: /* CIL Label */ 
  {
#line 358
  f = load_file(*(argv + 0));
  }
#line 359
  if ((unsigned long )f.body == (unsigned long )((void *)0)) {
    {
#line 360
    tmp = __errno_location();
#line 360
    tmp___0 = strerror(*tmp);
#line 360
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: cannot load file \'%s\' - %s\n",
            Cmd, *(argv + 0), tmp___0);
    }
#line 363
    return (2);
  }
  {
#line 365
  chunks2 = split_patch(f, & flist[0], & flist[1]);
#line 365
  chunks1 = chunks2;
  }
#line 367
  if (! flist[0].body) {
    {
#line 368
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: couldn\'t parse patch %s\n",
            Cmd, *(argv + 0));
    }
#line 371
    return (2);
  } else
#line 367
  if (! flist[1].body) {
    {
#line 368
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: couldn\'t parse patch %s\n",
            Cmd, *(argv + 0));
    }
#line 371
    return (2);
  }
#line 373
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 375
  flist[0] = load_file(*(argv + 0));
  }
#line 376
  if ((unsigned long )flist[0].body == (unsigned long )((void *)0)) {
    {
#line 377
    tmp___1 = __errno_location();
#line 377
    tmp___2 = strerror(*tmp___1);
#line 377
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: cannot load file \'%s\' - %s\n",
            Cmd, *(argv + 0), tmp___2);
    }
#line 380
    return (2);
  }
#line 382
  if (ispatch) {
    {
#line 383
    f = load_file(*(argv + 1));
    }
#line 384
    if ((unsigned long )f.body == (unsigned long )((void *)0)) {
      {
#line 385
      tmp___3 = __errno_location();
#line 385
      tmp___4 = strerror(*tmp___3);
#line 385
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: cannot load patch \'%s\' - %s\n",
              Cmd, *(argv + 1), tmp___4);
      }
#line 389
      return (2);
    }
#line 391
    if (which == 50) {
      {
#line 392
      chunks3 = split_patch(f, & flist[2], & flist[1]);
#line 392
      chunks2 = chunks3;
      }
    } else {
      {
#line 396
      chunks3 = split_patch(f, & flist[1], & flist[2]);
#line 396
      chunks2 = chunks3;
      }
    }
  } else {
    {
#line 401
    flist[1] = load_file(*(argv + 1));
    }
  }
#line 402
  if ((unsigned long )flist[1].body == (unsigned long )((void *)0)) {
    {
#line 403
    tmp___5 = __errno_location();
#line 403
    tmp___6 = strerror(*tmp___5);
#line 403
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: cannot load file \'%s\' - %s\n",
            Cmd, *(argv + 1), tmp___6);
    }
#line 407
    return (2);
  }
#line 409
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 411
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: too many files given for --diff\n",
          Cmd);
  }
#line 413
  return (2);
  switch_break: /* CIL Label */ ;
  }
#line 415
  if (reverse) {
#line 416
    f = flist[1];
#line 417
    flist[1] = flist[2];
#line 418
    flist[2] = f;
  }
#line 420
  if (obj == 108) {
#line 420
    tmp___7 = 0;
  } else {
#line 420
    tmp___7 = 1;
  }
  {
#line 420
  fl[0] = split_stream(flist[0], tmp___7);
  }
#line 421
  if (obj == 108) {
#line 421
    tmp___8 = 0;
  } else {
#line 421
    tmp___8 = 1;
  }
  {
#line 421
  fl[1] = split_stream(flist[1], tmp___8);
  }
#line 422
  if (chunks2) {
#line 422
    if (! chunks1) {
      {
#line 423
      csl = pdiff(fl[0], fl[1], chunks2);
      }
    } else {
      {
#line 425
      csl = diff(fl[0], fl[1]);
      }
    }
  } else {
    {
#line 425
    csl = diff(fl[0], fl[1]);
    }
  }
#line 426
  if (obj == 108) {
#line 427
    if (! chunks1) {
      {
#line 428
      printf((char const   */* __restrict  */)"@@ -1,%d +1,%d @@\n", fl[0].elcnt,
             fl[1].elcnt);
      }
    }
    {
#line 430
    exit_status = do_diff_lines((struct file *)(fl), csl);
    }
  } else {
#line 432
    if (! chunks1) {
#line 435
      l2 = 0;
#line 435
      l1 = l2;
#line 436
      i = 0;
      {
#line 436
      while (1) {
        while_continue: /* CIL Label */ ;
#line 436
        if (! (i < fl[0].elcnt)) {
#line 436
          goto while_break;
        }
        {
#line 437
        tmp___9 = ends_line(*(fl[0].list + i));
        }
#line 437
        if (tmp___9) {
#line 438
          l1 ++;
        }
#line 436
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 439
      i = 0;
      {
#line 439
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 439
        if (! (i < fl[1].elcnt)) {
#line 439
          goto while_break___0;
        }
        {
#line 440
        tmp___10 = ends_line(*(fl[1].list + i));
        }
#line 440
        if (tmp___10) {
#line 441
          l2 ++;
        }
#line 439
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 442
      printf((char const   */* __restrict  */)"@@ -1,%d +1,%d @@\n", l1, l2);
      }
    }
    {
#line 444
    exit_status = do_diff_words((struct file *)(fl), csl);
    }
  }
#line 446
  return (exit_status);
}
}
#line 449 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/wiggle.c"
static int do_merge(int argc , char **argv , int obj , int reverse , int replace ,
                    int ignore , int show_wiggles , int quiet ) 
{ 
  struct stream f ;
  struct stream flist[3] ;
  struct file fl[3] ;
  int i ;
  int chunks1 ;
  int chunks2 ;
  int chunks3 ;
  char *replacename ;
  char *orignew ;
  struct csl *csl1 ;
  struct csl *csl2 ;
  struct ci ci ;
  FILE *outfile ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int fd ;
  size_t tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 458
  chunks1 = 0;
#line 458
  chunks2 = 0;
#line 458
  chunks3 = 0;
#line 459
  replacename = (char *)((void *)0);
#line 459
  orignew = (char *)((void *)0);
#line 462
  outfile = stdout;
  {
#line 465
  if (argc == 0) {
#line 465
    goto case_0;
  }
#line 470
  if (argc == 1) {
#line 470
    goto case_1;
  }
#line 470
  if (argc == 2) {
#line 470
    goto case_1;
  }
#line 470
  if (argc == 3) {
#line 470
    goto case_1;
  }
#line 481
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 466
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: no files given for --merge\n",
          Cmd);
  }
#line 467
  return (2);
  case_1: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 471
  i = 0;
  {
#line 471
  while (1) {
    while_continue: /* CIL Label */ ;
#line 471
    if (! (i < argc)) {
#line 471
      goto while_break;
    }
    {
#line 472
    flist[i] = load_file(*(argv + i));
    }
#line 473
    if ((unsigned long )flist[i].body == (unsigned long )((void *)0)) {
      {
#line 474
      tmp = __errno_location();
#line 474
      tmp___0 = strerror(*tmp);
#line 474
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: cannot load file \'%s\' - %s\n",
              Cmd, *(argv + i), tmp___0);
      }
#line 477
      return (2);
    }
#line 471
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 480
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 482
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: too many files given for --merge\n",
          Cmd);
  }
#line 484
  return (2);
  switch_break: /* CIL Label */ ;
  }
  {
#line 487
  if (argc == 1) {
#line 487
    goto case_1___0;
  }
#line 496
  if (argc == 2) {
#line 496
    goto case_2___0;
  }
#line 500
  if (argc == 3) {
#line 500
    goto case_3___0;
  }
#line 486
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
  {
#line 488
  f = flist[0];
#line 489
  tmp___1 = split_merge(f, & flist[0], & flist[1], & flist[2]);
  }
#line 489
  if (! tmp___1) {
    {
#line 490
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: merge file %s looks bad.\n",
            Cmd, *(argv + 0));
    }
#line 493
    return (2);
  }
#line 495
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
  {
#line 497
  f = flist[1];
#line 498
  chunks3 = split_patch(f, & flist[1], & flist[2]);
#line 498
  chunks2 = chunks3;
  }
#line 499
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
#line 501
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 503
  if (reverse) {
#line 504
    f = flist[1];
#line 505
    flist[1] = flist[2];
#line 506
    flist[2] = f;
  }
#line 509
  i = 0;
  {
#line 509
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 509
    if (! (i < 3)) {
#line 509
      goto while_break___0;
    }
#line 510
    if ((unsigned long )flist[i].body == (unsigned long )((void *)0)) {
      {
#line 511
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: file %d missing\n",
              Cmd, i);
      }
#line 512
      return (2);
    }
#line 509
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 515
  if (replace) {
    {
#line 517
    tmp___2 = strlen((char const   *)*(argv + 0));
#line 517
    tmp___3 = xmalloc((int )(tmp___2 + 20UL));
#line 517
    replacename = (char *)tmp___3;
#line 518
    tmp___4 = strlen((char const   *)*(argv + 0));
#line 518
    tmp___5 = xmalloc((int )(tmp___4 + 20UL));
#line 518
    orignew = (char *)tmp___5;
#line 519
    strcpy((char */* __restrict  */)replacename, (char const   */* __restrict  */)*(argv + 0));
#line 520
    strcpy((char */* __restrict  */)orignew, (char const   */* __restrict  */)*(argv + 0));
#line 521
    strcat((char */* __restrict  */)orignew, (char const   */* __restrict  */)".porig");
#line 522
    tmp___6 = open((char const   *)orignew, 0);
    }
#line 522
    if (tmp___6 >= 0) {
      {
#line 524
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s already exists\n",
              Cmd, orignew);
      }
#line 527
      return (2);
    } else {
      {
#line 522
      tmp___7 = __errno_location();
      }
#line 522
      if (*tmp___7 != 2) {
        {
#line 524
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s already exists\n",
                Cmd, orignew);
        }
#line 527
        return (2);
      }
    }
    {
#line 529
    strcat((char */* __restrict  */)replacename, (char const   */* __restrict  */)"XXXXXX");
#line 530
    fd = mkstemp(replacename);
    }
#line 531
    if (fd == -1) {
      {
#line 532
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: could not create temporary file for %s\n",
              Cmd, replacename);
      }
#line 536
      return (2);
    }
    {
#line 538
    outfile = fdopen(fd, "w");
    }
  }
#line 541
  if (obj == 108) {
    {
#line 542
    fl[0] = split_stream(flist[0], 0);
#line 543
    fl[1] = split_stream(flist[1], 0);
#line 544
    fl[2] = split_stream(flist[2], 0);
    }
  } else {
    {
#line 546
    fl[0] = split_stream(flist[0], 1);
#line 547
    fl[1] = split_stream(flist[1], 1);
#line 548
    fl[2] = split_stream(flist[2], 1);
    }
  }
#line 550
  if (chunks2) {
#line 550
    if (! chunks1) {
      {
#line 551
      csl1 = pdiff(fl[0], fl[1], chunks2);
      }
    } else {
      {
#line 553
      csl1 = diff(fl[0], fl[1]);
      }
    }
  } else {
    {
#line 553
    csl1 = diff(fl[0], fl[1]);
    }
  }
  {
#line 554
  csl2 = diff(fl[1], fl[2]);
#line 556
  ci = print_merge2(outfile, & fl[0], & fl[1], & fl[2], csl1, csl2, obj == 119, ignore,
                    show_wiggles);
  }
#line 559
  if (! quiet) {
#line 559
    if (ci.conflicts) {
#line 560
      if (ci.conflicts == 1) {
#line 560
        tmp___8 = "";
      } else {
#line 560
        tmp___8 = "s";
      }
      {
#line 560
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d unresolved conflict%s found\n",
              ci.conflicts, tmp___8);
      }
    }
  }
#line 564
  if (! quiet) {
#line 564
    if (ci.ignored) {
#line 565
      if (ci.ignored == 1) {
#line 565
        tmp___9 = "";
      } else {
#line 565
        tmp___9 = "s";
      }
      {
#line 565
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d already-applied change%s ignored\n",
              ci.ignored, tmp___9);
      }
    }
  }
#line 570
  if (replace) {
    {
#line 571
    fclose(outfile);
#line 572
    tmp___10 = rename((char const   *)*(argv + 0), (char const   *)orignew);
    }
#line 572
    if (tmp___10 == 0) {
      {
#line 572
      tmp___11 = rename((char const   *)replacename, (char const   *)*(argv + 0));
      }
#line 572
      if (! (tmp___11 == 0)) {
        {
#line 576
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: failed to move new file into place.\n",
                Cmd);
        }
#line 579
        return (2);
      }
    } else {
      {
#line 576
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: failed to move new file into place.\n",
              Cmd);
      }
#line 579
      return (2);
    }
  }
#line 582
  return (ci.conflicts > 0);
}
}
#line 585 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/wiggle.c"
static int multi_merge(int argc , char **argv , int obj , int reverse , int ignore ,
                       int show_wiggles , int replace , int strip , int quiet ) 
{ 
  FILE *f ;
  char *filename ;
  struct plist *pl ;
  int num_patches ;
  int rv ;
  int i ;
  int tmp ;
  char *name ;
  char *av[2] ;
  int tmp___0 ;

  {
#line 594
  rv = 0;
#line 597
  if (! replace) {
    {
#line 598
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: -p in merge mode requires -r\n",
            Cmd);
    }
#line 601
    return (2);
  }
#line 603
  if (argc != 1) {
    {
#line 604
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: -p in merge mode requires exactly one file\n",
            Cmd);
    }
#line 607
    return (2);
  }
  {
#line 609
  filename = *(argv + 0);
#line 610
  f = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 611
  if (! f) {
    {
#line 612
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: cannot open %s\n",
            Cmd, filename);
    }
#line 614
    return (2);
  }
  {
#line 616
  pl = parse_patch(f, (FILE *)((void *)0), & num_patches);
#line 617
  fclose(f);
#line 618
  tmp = set_prefix(pl, num_patches, strip);
  }
#line 618
  if (tmp == 0) {
    {
#line 619
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: aborting\n",
            Cmd);
    }
#line 620
    return (2);
  }
#line 622
  i = 0;
  {
#line 622
  while (1) {
    while_continue: /* CIL Label */ ;
#line 622
    if (! (i < num_patches)) {
#line 622
      goto while_break;
    }
    {
#line 625
    asprintf((char **/* __restrict  */)(& name), (char const   */* __restrict  */)"_wiggle_:%d:%d:%s",
             (pl + i)->start, (pl + i)->end, filename);
#line 627
    av[0] = (pl + i)->file;
#line 628
    av[1] = name;
#line 629
    tmp___0 = do_merge(2, av, obj, reverse, 1, ignore, show_wiggles, quiet);
#line 629
    rv |= tmp___0;
#line 622
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 632
  return (rv);
}
}
#line 635 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/wiggle.c"
int main(int argc , char **argv ) 
{ 
  int opt ;
  int option_index ;
  int mode ;
  int obj ;
  int replace ;
  int which ;
  int ispatch ;
  int reverse ;
  int verbose ;
  int quiet ;
  int strip ;
  int exit_status ;
  int ignore ;
  int show_wiggles ;
  char *helpmsg ;
  char *trace ;
  long tmp ;

  {
  {
#line 639
  mode = 0;
#line 640
  obj = 0;
#line 641
  replace = 0;
#line 642
  which = 0;
#line 643
  ispatch = 0;
#line 644
  reverse = 0;
#line 645
  verbose = 0;
#line 645
  quiet = 0;
#line 646
  strip = -1;
#line 647
  exit_status = 0;
#line 648
  ignore = 1;
#line 649
  show_wiggles = 0;
#line 653
  trace = getenv("WIGGLE_TRACE");
  }
#line 654
  if (trace) {
#line 654
    if (*trace) {
#line 655
      do_trace = 1;
    }
  }
  {
#line 657
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 657
    opt = getopt_long(argc, (char * const  *)argv, (char const   *)(short_options),
                      (struct option  const  *)(long_options), & option_index);
    }
#line 657
    if (! (opt != -1)) {
#line 657
      goto while_break;
    }
    {
#line 661
    if (opt == 104) {
#line 661
      goto case_104;
    }
#line 680
    if (opt == 86) {
#line 680
      goto case_86;
    }
#line 692
    if (opt == 109) {
#line 692
      goto case_109___0;
    }
#line 692
    if (opt == 100) {
#line 692
      goto case_109___0;
    }
#line 692
    if (opt == 120) {
#line 692
      goto case_109___0;
    }
#line 692
    if (opt == 66) {
#line 692
      goto case_109___0;
    }
#line 703
    if (opt == 108) {
#line 703
      goto case_108;
    }
#line 703
    if (opt == 119) {
#line 703
      goto case_108;
    }
#line 712
    if (opt == 114) {
#line 712
      goto case_114;
    }
#line 715
    if (opt == 82) {
#line 715
      goto case_82;
    }
#line 719
    if (opt == 105) {
#line 719
      goto case_105;
    }
#line 722
    if (opt == 87) {
#line 722
      goto case_87;
    }
#line 729
    if (opt == 51) {
#line 729
      goto case_51;
    }
#line 729
    if (opt == 50) {
#line 729
      goto case_51;
    }
#line 729
    if (opt == 49) {
#line 729
      goto case_51;
    }
#line 738
    if (opt == 112) {
#line 738
      goto case_112;
    }
#line 744
    if (opt == 118) {
#line 744
      goto case_118;
    }
#line 747
    if (opt == 113) {
#line 747
      goto case_113;
    }
#line 685
    goto switch_default;
    case_104: /* CIL Label */ 
#line 662
    helpmsg = Help;
    {
#line 664
    if (mode == 120) {
#line 664
      goto case_120;
    }
#line 667
    if (mode == 100) {
#line 667
      goto case_100;
    }
#line 670
    if (mode == 109) {
#line 670
      goto case_109;
    }
#line 673
    if (mode == 66) {
#line 673
      goto case_66;
    }
#line 663
    goto switch_break___0;
    case_120: /* CIL Label */ 
#line 665
    helpmsg = HelpExtract;
#line 666
    goto switch_break___0;
    case_100: /* CIL Label */ 
#line 668
    helpmsg = HelpDiff;
#line 669
    goto switch_break___0;
    case_109: /* CIL Label */ 
#line 671
    helpmsg = HelpMerge;
#line 672
    goto switch_break___0;
    case_66: /* CIL Label */ 
#line 674
    helpmsg = HelpBrowse;
#line 675
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 677
    fputs((char const   */* __restrict  */)helpmsg, (FILE */* __restrict  */)stderr);
#line 678
    exit(0);
    }
    case_86: /* CIL Label */ 
    {
#line 681
    fputs((char const   */* __restrict  */)(Version), (FILE */* __restrict  */)stderr);
#line 682
    exit(0);
    }
    switch_default: /* CIL Label */ 
    {
#line 686
    fputs((char const   */* __restrict  */)(Usage), (FILE */* __restrict  */)stderr);
#line 687
    exit(2);
    }
    case_109___0: /* CIL Label */ 
    case_100___0: /* CIL Label */ 
    case_120___0: /* CIL Label */ 
    case_66___0: /* CIL Label */ 
#line 693
    if (mode == 0) {
#line 694
      mode = opt;
#line 695
      goto while_continue;
    }
    {
#line 697
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: mode is \'%c\' - cannot set to \'%c\'\n",
            Cmd, mode, opt);
#line 700
    exit(2);
    }
    case_108: /* CIL Label */ 
    case_119: /* CIL Label */ 
#line 704
    if (obj == 0) {
#line 705
      obj = opt;
#line 706
      goto while_continue;
    } else
#line 704
    if (obj == opt) {
#line 705
      obj = opt;
#line 706
      goto while_continue;
    }
    {
#line 708
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: cannot select both words and lines.\n",
            Cmd);
#line 710
    exit(2);
    }
    case_114: /* CIL Label */ 
#line 713
    replace = 1;
#line 714
    goto while_continue;
    case_82: /* CIL Label */ 
#line 716
    reverse = 1;
#line 717
    goto while_continue;
    case_105: /* CIL Label */ 
#line 720
    ignore = 0;
#line 721
    goto while_continue;
    case_87: /* CIL Label */ 
#line 723
    show_wiggles = 1;
#line 724
    ignore = 0;
#line 725
    goto while_continue;
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
#line 730
    if (which == 0) {
#line 731
      which = opt;
#line 732
      goto while_continue;
    } else
#line 730
    if (which == opt) {
#line 731
      which = opt;
#line 732
      goto while_continue;
    }
    {
#line 734
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: can only select one of -1, -2, -3\n",
            Cmd);
#line 736
    exit(2);
    }
    case_112: /* CIL Label */ 
#line 739
    if (optarg) {
      {
#line 740
      tmp = atol((char const   *)optarg);
#line 740
      strip = (int )tmp;
      }
    }
#line 741
    ispatch = 1;
#line 742
    goto while_continue;
    case_118: /* CIL Label */ 
#line 745
    verbose ++;
#line 746
    goto while_continue;
    case_113: /* CIL Label */ 
#line 748
    quiet = 1;
#line 749
    goto while_continue;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 751
  if (! mode) {
#line 752
    mode = 'm';
  }
#line 754
  if (mode == 66) {
    {
#line 755
    vpatch(argc - optind, argv + optind, ispatch, strip, reverse, replace);
#line 758
    exit(1);
    }
  }
#line 761
  if (obj) {
#line 761
    if (mode == 120) {
      {
#line 762
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: cannot specify --line or --word with --extract\n",
              Cmd);
#line 765
      exit(2);
      }
    }
  }
#line 767
  if (mode != 109) {
#line 767
    if (! obj) {
#line 768
      obj = 'w';
    }
  }
#line 769
  if (replace) {
#line 769
    if (mode != 109) {
      {
#line 770
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: --replace only allowed with --merge\n",
              Cmd);
#line 772
      exit(2);
      }
    }
  }
#line 774
  if (mode == 120) {
#line 774
    if (! which) {
      {
#line 775
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: must specify -1, -2 or -3 with --extract\n",
              Cmd);
#line 777
      exit(2);
      }
    }
  }
#line 779
  if (mode != 120) {
#line 779
    if (mode != 100) {
#line 779
      if (which) {
        {
#line 780
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: -1, -2 or -3 only allowed with --extract or --diff\n",
                Cmd);
#line 783
        exit(2);
        }
      }
    }
  }
#line 786
  if (ispatch) {
#line 786
    if (which == 51) {
      {
#line 787
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: cannot extract -3 from a patch.\n",
              Cmd);
#line 789
      exit(2);
      }
    }
  }
  {
#line 793
  if (mode == 120) {
#line 793
    goto case_120___1;
  }
#line 796
  if (mode == 100) {
#line 796
    goto case_100___1;
  }
#line 799
  if (mode == 109) {
#line 799
    goto case_109___1;
  }
#line 792
  goto switch_break___1;
  case_120___1: /* CIL Label */ 
  {
#line 794
  exit_status = extract(argc - optind, argv + optind, ispatch, which);
  }
#line 795
  goto switch_break___1;
  case_100___1: /* CIL Label */ 
  {
#line 797
  exit_status = do_diff(argc - optind, argv + optind, obj, ispatch, which, reverse);
  }
#line 798
  goto switch_break___1;
  case_109___1: /* CIL Label */ 
#line 800
  if (ispatch) {
    {
#line 801
    exit_status = multi_merge(argc - optind, argv + optind, obj, reverse, ignore,
                              show_wiggles, replace, strip, quiet);
    }
  } else {
    {
#line 808
    exit_status = do_merge(argc - optind, argv + optind, obj, reverse, replace, ignore,
                           show_wiggles, quiet);
    }
  }
#line 810
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
  {
#line 812
  exit(exit_status);
  }
}
}
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 195
extern FILE *tmpfile(void) ;
#line 278
extern FILE *freopen(char const   * __restrict  __filename , char const   * __restrict  __modes ,
                     FILE * __restrict  __stream ) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 538
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 77 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/wiggle.h"
__inline static int ends_mline(struct elmnt e ) 
{ 
  int tmp ;

  {
#line 79
  if (e.len) {
#line 79
    if ((int )*(e.start + 0) == 10) {
#line 79
      tmp = 1;
    } else
#line 79
    if ((int )*(e.start + 0) == 0) {
#line 79
      tmp = 1;
    } else {
#line 79
      tmp = 0;
    }
  } else {
#line 79
    tmp = 0;
  }
#line 79
  return (tmp);
}
}
#line 149
struct stream load_segment(FILE *f , unsigned int start , unsigned int end ) ;
#line 587 "/usr/include/curses.h"
extern int cbreak(void) ;
#line 611
extern int endwin(void) ;
#line 622
extern _Bool has_colors(void) ;
#line 632
extern WINDOW *initscr(void) ;
#line 634
extern int init_pair(short  , short  , short  ) ;
#line 642
extern int intrflush(WINDOW * , _Bool  ) ;
#line 647
extern int keypad(WINDOW * , _Bool  ) ;
#line 708
extern int nl(void) ;
#line 709
extern int nocbreak(void) ;
#line 711
extern int noecho(void) ;
#line 712
extern int nonl(void) ;
#line 764
extern int start_color(void) ;
#line 785
extern int waddch(WINDOW * , chtype const    ) ;
#line 788
extern int waddnstr(WINDOW * , char const   * , int  ) ;
#line 794
extern int wattr_on(WINDOW * , attr_t  , void * ) ;
#line 795
extern int wattr_off(WINDOW * , attr_t  , void * ) ;
#line 801
extern int wclear(WINDOW * ) ;
#line 803
extern int wclrtoeol(WINDOW * ) ;
#line 810
extern int wgetch(WINDOW * ) ;
#line 824
extern int wmove(WINDOW * , int  , int  ) ;
#line 899
extern int use_default_colors(void) ;
#line 1386
extern WINDOW *stdscr ;
#line 1608
extern mmask_t mousemask(mmask_t  , mmask_t * ) ;
#line 334 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 531
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup)(int __fd ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 48 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/vpatch.c"
static void term_init(void) ;
#line 51 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/vpatch.c"
unsigned int a_delete  ;
#line 51 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/vpatch.c"
unsigned int a_added  ;
#line 51 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/vpatch.c"
unsigned int a_common  ;
#line 51 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/vpatch.c"
unsigned int a_sep  ;
#line 51 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/vpatch.c"
unsigned int a_void  ;
#line 51 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/vpatch.c"
unsigned int a_unmatched  ;
#line 51 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/vpatch.c"
unsigned int a_extra  ;
#line 51 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/vpatch.c"
unsigned int a_already  ;
#line 53 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/vpatch.c"
unsigned int a_has_conflicts  ;
#line 53 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/vpatch.c"
unsigned int a_has_wiggles  ;
#line 53 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/vpatch.c"
unsigned int a_no_wiggles  ;
#line 69 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/vpatch.c"
char *help_help[12]  = 
#line 69
  {      (char *)"   You are viewing the help page for the help viewer.",      (char *)"You normally get here by typing \'?\'",      (char *)"",      (char *)"The following keystrokes work in the help viewer:", 
        (char *)"  ?     display this help message",      (char *)"  q     return to previous view",      (char *)"  SPC   move forward through help document",      (char *)"  RTN   same as SPC", 
        (char *)"  BKSP  move backward through help document",      (char *)"  RIGHT scroll help window so text on the right appears",      (char *)"  LEFT  scroll help window so text on the left appears",      (char *)((void *)0)};
#line 84 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/vpatch.c"
char *help_missing[4]  = {      (char *)"The file that this patch applies to appears",      (char *)"to be missing.",      (char *)"Please type \'q\' to continue",      (char *)((void *)0)};
#line 91 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/vpatch.c"
char *help_corrupt[3]  = {      (char *)"This patch appears to be corrupt",      (char *)"Please type \'q\' to continue",      (char *)((void *)0)};
#line 101 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/vpatch.c"
static void help_window(char **page1 , char **page2 ) 
{ 
  int rows ;
  int cols ;
  int top ;
  int left ;
  int r ;
  int c ;
  int ch ;
  char **page ;
  int line ;
  int shift ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char **lnp ;
  char *ln ;
  int sh ;
  int chr ;
  int tmp___9 ;

  {
#line 107
  page = page1;
#line 108
  line = 0;
#line 109
  shift = 0;
#line 111
  if (stdscr) {
#line 111
    rows = (int )stdscr->_maxy + 1;
  } else {
#line 111
    rows = -1;
  }
#line 111
  if (stdscr) {
#line 111
    cols = (int )stdscr->_maxx + 1;
  } else {
#line 111
    cols = -1;
  }
#line 113
  if (cols < 70) {
#line 114
    left = 6;
#line 115
    cols -= 12;
  } else {
#line 117
    left = (cols - 58) / 2 - 1;
#line 118
    cols = 58;
  }
#line 121
  if (rows < 21) {
#line 122
    top = 3;
#line 123
    rows -= 6;
  } else {
#line 125
    top = (rows - 15) / 2 - 1;
#line 126
    rows = 15;
  }
#line 130
  if (stdscr) {
#line 130
    stdscr->_attrs = 1UL << 16;
  }
#line 131
  c = left;
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    if (! (c < left + cols)) {
#line 131
      goto while_break;
    }
    {
#line 132
    tmp = wmove(stdscr, top - 1, c);
    }
#line 132
    if (! (tmp == -1)) {
      {
#line 132
      waddch(stdscr, (chtype const   )'-');
      }
    }
    {
#line 133
    tmp___0 = wmove(stdscr, top + rows, c);
    }
#line 133
    if (! (tmp___0 == -1)) {
      {
#line 133
      waddch(stdscr, (chtype const   )'-');
      }
    }
#line 131
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 135
  r = top;
  {
#line 135
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 135
    if (! (r < top + rows)) {
#line 135
      goto while_break___0;
    }
    {
#line 136
    tmp___1 = wmove(stdscr, r, left - 1);
    }
#line 136
    if (! (tmp___1 == -1)) {
      {
#line 136
      waddch(stdscr, (chtype const   )'|');
      }
    }
    {
#line 137
    tmp___2 = wmove(stdscr, r, left + cols);
    }
#line 137
    if (! (tmp___2 == -1)) {
      {
#line 137
      waddch(stdscr, (chtype const   )'|');
      }
    }
#line 135
    r ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 139
  tmp___3 = wmove(stdscr, top - 1, left - 1);
  }
#line 139
  if (! (tmp___3 == -1)) {
    {
#line 139
    waddch(stdscr, (chtype const   )'/');
    }
  }
  {
#line 140
  tmp___4 = wmove(stdscr, top - 1, left + cols);
  }
#line 140
  if (! (tmp___4 == -1)) {
    {
#line 140
    waddch(stdscr, (chtype const   )'\\');
    }
  }
  {
#line 141
  tmp___5 = wmove(stdscr, top + rows, left - 1);
  }
#line 141
  if (! (tmp___5 == -1)) {
    {
#line 141
    waddch(stdscr, (chtype const   )'\\');
    }
  }
  {
#line 142
  tmp___6 = wmove(stdscr, top + rows, left + cols);
  }
#line 142
  if (! (tmp___6 == -1)) {
    {
#line 142
    waddch(stdscr, (chtype const   )'/');
    }
  }
  {
#line 143
  tmp___7 = wmove(stdscr, top - 1, (left + cols / 2) - 9);
  }
#line 143
  if (! (tmp___7 == -1)) {
    {
#line 143
    waddnstr(stdscr, "HELP - \'q\' to exit", -1);
    }
  }
  {
#line 144
  tmp___8 = wmove(stdscr, top + rows, (left + cols / 2) - 17);
  }
#line 144
  if (! (tmp___8 == -1)) {
    {
#line 144
    waddnstr(stdscr, "Press SPACE for more, \'?\' for help", -1);
    }
  }
#line 145
  if (stdscr) {
#line 145
    stdscr->_attrs = 0UL;
  }
  {
#line 147
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 148
    lnp = page + line;
#line 153
    r = 0;
    {
#line 153
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 153
      if (! (r < rows)) {
#line 153
        goto while_break___2;
      }
#line 154
      ln = *lnp;
#line 155
      sh = shift;
#line 156
      if (ln) {
#line 157
        lnp ++;
      } else {
#line 159
        ln = (char *)"";
      }
      {
#line 161
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 161
        if (*ln) {
#line 161
          if (! (sh > 0)) {
#line 161
            goto while_break___3;
          }
        } else {
#line 161
          goto while_break___3;
        }
#line 162
        ln ++;
#line 163
        sh --;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 165
      c = 0;
      {
#line 165
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 165
        if (! (c < cols)) {
#line 165
          goto while_break___4;
        }
#line 166
        chr = (int )*ln;
#line 167
        if (chr) {
#line 168
          ln ++;
        } else {
#line 170
          chr = ' ';
        }
        {
#line 171
        tmp___9 = wmove(stdscr, top + r, left + c);
        }
#line 171
        if (! (tmp___9 == -1)) {
          {
#line 171
          waddch(stdscr, (chtype const   )chr);
          }
        }
#line 165
        c ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 153
      r ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 174
    wmove(stdscr, (top + rows) - 1, left);
#line 175
    ch = wgetch(stdscr);
    }
    {
#line 178
    if (ch == 113) {
#line 178
      goto case_113;
    }
#line 180
    if (ch == 63) {
#line 180
      goto case_63;
    }
#line 185
    if (ch == 13) {
#line 185
      goto case_13;
    }
#line 185
    if (ch == 32) {
#line 185
      goto case_13;
    }
#line 200
    if (ch == 8) {
#line 200
      goto case_8;
    }
#line 216
    if (ch == 260) {
#line 216
      goto case_260;
    }
#line 220
    if (ch == 261) {
#line 220
      goto case_261;
    }
#line 224
    if (ch == 259) {
#line 224
      goto case_259;
    }
#line 228
    if (ch == 258) {
#line 228
      goto case_258;
    }
#line 177
    goto switch_break;
    case_113: /* CIL Label */ 
#line 179
    return;
    case_63: /* CIL Label */ 
#line 181
    if ((unsigned long )page1 != (unsigned long )(help_help)) {
      {
#line 182
      help_window(help_help, (char **)((void *)0));
      }
    }
#line 183
    goto switch_break;
    case_13: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 186
    r = 0;
    {
#line 186
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 186
      if (! (r < rows - 2)) {
#line 186
        goto while_break___5;
      }
#line 187
      if (*(page + line)) {
#line 188
        line ++;
      }
#line 186
      r ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 189
    if (! *(page + line)) {
#line 190
      line = 0;
#line 191
      if ((unsigned long )page == (unsigned long )page1) {
#line 192
        page = page2;
      } else {
#line 194
        page = (char **)((void *)0);
      }
#line 195
      if ((unsigned long )page == (unsigned long )((void *)0)) {
#line 196
        return;
      }
    }
#line 198
    goto switch_break;
    case_8: /* CIL Label */ 
#line 201
    if (line > 0) {
#line 202
      line -= rows - 2;
#line 203
      if (line < 0) {
#line 204
        line = 0;
      }
    } else {
#line 206
      if ((unsigned long )page == (unsigned long )page2) {
#line 207
        page = page1;
      } else {
#line 209
        page = page2;
      }
#line 210
      if ((unsigned long )page == (unsigned long )((void *)0)) {
#line 211
        page = page1;
      }
#line 212
      line = 0;
    }
#line 214
    goto switch_break;
    case_260: /* CIL Label */ 
#line 217
    if (shift > 0) {
#line 218
      shift --;
    }
#line 219
    goto switch_break;
    case_261: /* CIL Label */ 
#line 221
    shift ++;
#line 222
    goto switch_break;
    case_259: /* CIL Label */ 
#line 225
    if (line > 0) {
#line 226
      line --;
    }
#line 227
    goto switch_break;
    case_258: /* CIL Label */ 
#line 229
    if (*(page + line)) {
#line 230
      line ++;
    }
#line 231
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
}
}
#line 236 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/vpatch.c"
static char *typenames[7]  = {      (char *)"End",      (char *)"Unmatched",      (char *)"Unchanged",      (char *)"Extraneous", 
        (char *)"Changed",      (char *)"Conflict",      (char *)"AlreadyApplied"};
#line 340 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/vpatch.c"
static int same_mp(struct mp a , struct mp b ) 
{ 
  int tmp ;

  {
#line 342
  if (a.m == b.m) {
#line 342
    if (a.s == b.s) {
#line 342
      if (a.o == b.o) {
#line 342
        tmp = 1;
      } else {
#line 342
        tmp = 0;
      }
    } else {
#line 342
      tmp = 0;
    }
  } else {
#line 342
    tmp = 0;
  }
#line 342
  return (tmp);
}
}
#line 346 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/vpatch.c"
static int same_mpos(struct mpos a , struct mpos b ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 348
  tmp = same_mp(a.p, b.p);
  }
#line 348
  if (tmp) {
#line 348
    if (a.state == b.state) {
#line 348
      tmp___0 = 1;
    } else
#line 348
    if (a.state == 0) {
#line 348
      tmp___0 = 1;
    } else
#line 348
    if (b.state == 0) {
#line 348
      tmp___0 = 1;
    } else {
#line 348
      tmp___0 = 0;
    }
  } else {
#line 348
    tmp___0 = 0;
  }
#line 348
  return (tmp___0);
}
}
#line 357 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/vpatch.c"
static int stream_valid(int s , enum mergetype type ) 
{ 


  {
  {
#line 360
  if ((unsigned int )type == 0U) {
#line 360
    goto case_0;
  }
#line 362
  if ((unsigned int )type == 1U) {
#line 362
    goto case_1;
  }
#line 364
  if ((unsigned int )type == 2U) {
#line 364
    goto case_2;
  }
#line 366
  if ((unsigned int )type == 3U) {
#line 366
    goto case_3;
  }
#line 368
  if ((unsigned int )type == 4U) {
#line 368
    goto case_4;
  }
#line 370
  if ((unsigned int )type == 5U) {
#line 370
    goto case_5;
  }
#line 372
  if ((unsigned int )type == 6U) {
#line 372
    goto case_6;
  }
#line 359
  goto switch_break;
  case_0: /* CIL Label */ 
#line 361
  return (1);
  case_1: /* CIL Label */ 
#line 363
  return (s == 0);
  case_2: /* CIL Label */ 
#line 365
  return (s == 0);
  case_3: /* CIL Label */ 
#line 367
  return (s == 2);
  case_4: /* CIL Label */ 
#line 369
  return (s != 1);
  case_5: /* CIL Label */ 
#line 371
  return (1);
  case_6: /* CIL Label */ 
#line 373
  return (1);
  switch_break: /* CIL Label */ ;
  }
#line 375
  return (0);
}
}
#line 384 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/vpatch.c"
static struct elmnt next_melmnt(struct mp *pos , struct file fm , struct file fb ,
                                struct file fa , struct merge *m ) 
{ 
  int l ;
  int tmp ;
  struct elmnt e ;
  int tmp___0 ;

  {
#line 388
  (pos->o) ++;
  {
#line 389
  while (1) {
    while_continue: /* CIL Label */ ;
#line 390
    l = 0;
#line 391
    if (pos->m >= 0) {
      {
#line 393
      if (pos->s == 0) {
#line 393
        goto case_0;
      }
#line 396
      if (pos->s == 1) {
#line 396
        goto case_1;
      }
#line 399
      if (pos->s == 2) {
#line 399
        goto case_2;
      }
#line 392
      goto switch_break;
      case_0: /* CIL Label */ 
#line 394
      l = (m + pos->m)->al;
#line 395
      goto switch_break;
      case_1: /* CIL Label */ 
#line 397
      l = (m + pos->m)->bl;
#line 398
      goto switch_break;
      case_2: /* CIL Label */ 
#line 400
      l = (m + pos->m)->cl;
#line 401
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 403
    if (pos->o >= l) {
#line 406
      pos->o = 0;
      {
#line 407
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 408
        (pos->s) ++;
#line 409
        if (pos->s > 2) {
#line 410
          pos->s = 0;
#line 411
          (pos->m) ++;
        }
        {
#line 407
        tmp = stream_valid(pos->s, (m + pos->m)->type);
        }
#line 407
        if (tmp) {
#line 407
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 415
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 417
  if (pos->m == -1) {
#line 419
    e.start = (char *)((void *)0);
#line 419
    e.len = 0;
#line 420
    return (e);
  } else
#line 417
  if ((unsigned int )(m + pos->m)->type == 0U) {
#line 419
    e.start = (char *)((void *)0);
#line 419
    e.len = 0;
#line 420
    return (e);
  }
  {
#line 430
  if (pos->s == 1) {
#line 430
    goto case_1___0;
  }
#line 431
  if (pos->s == 2) {
#line 431
    goto case_2___0;
  }
#line 423
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 425
  if (pos->lineno & 1) {
#line 426
    (pos->lineno) ++;
  }
  {
#line 427
  tmp___0 = ends_mline(*(fm.list + ((m + pos->m)->a + pos->o)));
  }
#line 427
  if (tmp___0) {
#line 428
    (pos->lineno) ++;
  }
#line 429
  return (*(fm.list + ((m + pos->m)->a + pos->o)));
  case_1___0: /* CIL Label */ 
#line 430
  return (*(fb.list + ((m + pos->m)->b + pos->o)));
  case_2___0: /* CIL Label */ 
#line 431
  return (*(fa.list + ((m + pos->m)->c + pos->o)));
  switch_break___0: /* CIL Label */ ;
  }
}
}
#line 436 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/vpatch.c"
static struct elmnt prev_melmnt(struct mp *pos , struct file fm , struct file fb ,
                                struct file fa , struct merge *m ) 
{ 
  int tmp ;
  int tmp___0 ;
  struct elmnt e ;

  {
#line 440
  if (pos->s == 0) {
    {
#line 441
    tmp = ends_mline(*(fm.list + ((m + pos->m)->a + pos->o)));
    }
#line 441
    if (tmp) {
#line 442
      (pos->lineno) --;
    }
#line 443
    if (pos->lineno & 1) {
#line 444
      (pos->lineno) --;
    }
  }
#line 447
  (pos->o) --;
  {
#line 448
  while (1) {
    while_continue: /* CIL Label */ ;
#line 448
    if (pos->m >= 0) {
#line 448
      if (! (pos->o < 0)) {
#line 448
        goto while_break;
      }
    } else {
#line 448
      goto while_break;
    }
    {
#line 449
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 450
      (pos->s) --;
#line 451
      if (pos->s < 0) {
#line 452
        pos->s = 2;
#line 453
        (pos->m) --;
      }
#line 449
      if (pos->m >= 0) {
        {
#line 449
        tmp___0 = stream_valid(pos->s, (m + pos->m)->type);
        }
#line 449
        if (tmp___0) {
#line 449
          goto while_break___0;
        }
      } else {
#line 449
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 457
    if (pos->m >= 0) {
      {
#line 459
      if (pos->s == 0) {
#line 459
        goto case_0;
      }
#line 462
      if (pos->s == 1) {
#line 462
        goto case_1;
      }
#line 465
      if (pos->s == 2) {
#line 465
        goto case_2;
      }
#line 458
      goto switch_break;
      case_0: /* CIL Label */ 
#line 460
      pos->o = (m + pos->m)->al - 1;
#line 461
      goto switch_break;
      case_1: /* CIL Label */ 
#line 463
      pos->o = (m + pos->m)->bl - 1;
#line 464
      goto switch_break;
      case_2: /* CIL Label */ 
#line 466
      pos->o = (m + pos->m)->cl - 1;
#line 467
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 471
  if (pos->m < 0) {
#line 473
    e.start = (char *)((void *)0);
#line 473
    e.len = 0;
#line 474
    return (e);
  }
  {
#line 479
  if (pos->s == 1) {
#line 479
    goto case_1___0;
  }
#line 480
  if (pos->s == 2) {
#line 480
    goto case_2___0;
  }
#line 477
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 478
  return (*(fm.list + ((m + pos->m)->a + pos->o)));
  case_1___0: /* CIL Label */ 
#line 479
  return (*(fb.list + ((m + pos->m)->b + pos->o)));
  case_2___0: /* CIL Label */ 
#line 480
  return (*(fa.list + ((m + pos->m)->c + pos->o)));
  switch_break___0: /* CIL Label */ ;
  }
}
}
#line 488 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/vpatch.c"
static int visible(int mode , enum mergetype type , int stream ) 
{ 


  {
#line 490
  if (mode == 0) {
#line 491
    return (-1);
  }
  {
#line 494
  if ((unsigned int )type == 0U) {
#line 494
    goto case_0;
  }
#line 496
  if ((unsigned int )type == 1U) {
#line 496
    goto case_1;
  }
#line 500
  if ((unsigned int )type == 2U) {
#line 500
    goto case_2;
  }
#line 504
  if ((unsigned int )type == 3U) {
#line 504
    goto case_3;
  }
#line 509
  if ((unsigned int )type == 4U) {
#line 509
    goto case_4;
  }
#line 517
  if ((unsigned int )type == 5U) {
#line 517
    goto case_5;
  }
#line 533
  if ((unsigned int )type == 6U) {
#line 533
    goto case_6;
  }
#line 493
  goto switch_break;
  case_0: /* CIL Label */ 
#line 495
  return (0);
  case_1: /* CIL Label */ 
#line 497
  if (mode & 12) {
#line 498
    return ((int )a_unmatched);
  }
#line 499
  goto switch_break;
  case_2: /* CIL Label */ 
#line 501
  if (stream == 0) {
#line 502
    return ((int )a_common);
  }
#line 503
  goto switch_break;
  case_3: /* CIL Label */ 
#line 505
  if (mode & 3) {
#line 505
    if (stream == 2) {
#line 507
      return ((int )a_extra);
    }
  }
#line 508
  goto switch_break;
  case_4: /* CIL Label */ 
#line 510
  if (stream == 0) {
#line 510
    if (mode & 5) {
#line 512
      return ((int )a_delete);
    }
  }
#line 513
  if (stream == 2) {
#line 513
    if (mode & 10) {
#line 515
      return ((int )a_added);
    }
  }
#line 516
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 519
  if (stream == 0) {
#line 519
    goto case_0___0;
  }
#line 523
  if (stream == 1) {
#line 523
    goto case_1___0;
  }
#line 527
  if (stream == 2) {
#line 527
    goto case_2___0;
  }
#line 518
  goto switch_break___0;
  case_0___0: /* CIL Label */ 
#line 520
  if (mode & 4) {
#line 521
    return ((int )((unsigned long )a_unmatched | (1UL << 18)));
  }
#line 522
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
#line 524
  if (mode & 1) {
#line 525
    return ((int )((unsigned long )a_extra | (1UL << 17)));
  }
#line 526
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 528
  if (mode & 10) {
#line 529
    return ((int )((unsigned long )a_added | (1UL << 17)));
  }
#line 530
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 532
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 535
  if (stream == 0) {
#line 535
    goto case_0___1;
  }
#line 539
  if (stream == 1) {
#line 539
    goto case_1___1;
  }
#line 543
  if (stream == 2) {
#line 543
    goto case_2___1;
  }
#line 534
  goto switch_break___1;
  case_0___1: /* CIL Label */ 
#line 536
  if (mode & 12) {
#line 537
    return ((int )a_already);
  }
#line 538
  goto switch_break___1;
  case_1___1: /* CIL Label */ 
#line 540
  if (mode & 1) {
#line 541
    return ((int )((unsigned long )a_delete | (1UL << 17)));
  }
#line 542
  goto switch_break___1;
  case_2___1: /* CIL Label */ 
#line 544
  if (mode & 2) {
#line 545
    return ((int )((unsigned long )a_added | (1UL << 17)));
  }
#line 546
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 548
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 550
  return (-1);
}
}
#line 560 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/vpatch.c"
static int check_line(struct mpos pos , struct file fm , struct file fb , struct file fa ,
                      struct merge *m , int mode ) 
{ 
  int rv ;
  struct elmnt e ;
  int unmatched ;
  int tmp ;
  int tmp___0 ;

  {
#line 564
  rv = 0;
#line 566
  unmatched = 0;
  {
#line 568
  while (1) {
    while_continue: /* CIL Label */ ;
#line 569
    if ((unsigned int )(m + pos.p.m)->type == 4U) {
#line 570
      rv |= 48;
    } else
#line 571
    if ((unsigned int )(m + pos.p.m)->type == 6U) {
#line 573
      rv |= 160;
    } else
#line 571
    if ((unsigned int )(m + pos.p.m)->type == 5U) {
#line 573
      rv |= 160;
    } else
#line 574
    if ((unsigned int )(m + pos.p.m)->type == 3U) {
#line 574
      if ((int )*((fb.list + (m + pos.p.m)->b)->start + 0) != 0) {
#line 577
        rv |= 64;
      } else {
#line 574
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 578
    if ((unsigned int )(m + pos.p.m)->type == 1U) {
#line 579
      unmatched = 1;
    }
#line 580
    if ((m + pos.p.m)->in_conflict) {
#line 581
      rv |= 160;
    }
    {
#line 582
    e = prev_melmnt(& pos.p, fm, fb, fa, m);
    }
#line 568
    if ((unsigned long )e.start != (unsigned long )((void *)0)) {
      {
#line 568
      tmp = ends_mline(e);
      }
#line 568
      if (tmp) {
        {
#line 568
        tmp___0 = visible(mode, (m + pos.p.m)->type, pos.p.s);
        }
#line 568
        if (! (tmp___0 == -1)) {
#line 568
          goto while_break;
        }
      }
    } else {
#line 568
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 587
  if (unmatched) {
#line 587
    if (rv & 32) {
#line 588
      rv |= 64;
    }
  }
#line 589
  return (rv);
}
}
#line 599 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/vpatch.c"
static void next_mline(struct mpos *pos , struct file fm , struct file fb , struct file fa ,
                       struct merge *m , int mode ) 
{ 
  int mask ;
  struct mp prv ;
  int mode2 ;
  struct elmnt e ;
  struct elmnt tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 604
  while (1) {
    while_continue: /* CIL Label */ ;
#line 608
    prv = pos->p;
    {
#line 609
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 610
      tmp = next_melmnt(& pos->p, fm, fb, fa, m);
#line 610
      e = tmp;
      }
#line 611
      if ((unsigned long )e.start == (unsigned long )((void *)0)) {
#line 612
        goto while_break___0;
      }
      {
#line 613
      tmp___0 = ends_mline(e);
      }
#line 613
      if (tmp___0) {
        {
#line 613
        tmp___1 = visible(mode, (m + pos->p.m)->type, pos->p.s);
        }
#line 613
        if (tmp___1 >= 0) {
#line 615
          goto while_break___0;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 617
    mode2 = check_line(*pos, fm, fb, fa, m, mode);
    }
#line 619
    if (mode2 & 32) {
#line 619
      if (pos->state == 0) {
#line 621
        pos->lo = pos->p;
#line 622
        pos->state = 1;
      } else {
#line 619
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 623
    if (! (mode2 & 32)) {
#line 623
      if (pos->state) {
        {
#line 626
        if (pos->state == 1) {
#line 626
          goto case_1;
        }
#line 633
        if (pos->state == 2) {
#line 633
          goto case_2;
        }
#line 625
        goto switch_break;
        case_1: /* CIL Label */ 
#line 628
        pos->hi = prv;
#line 630
        pos->p = pos->lo;
#line 631
        (pos->state) ++;
#line 632
        goto switch_break;
        case_2: /* CIL Label */ 
#line 635
        pos->state = 0;
#line 636
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
    }
#line 639
    mask = 63;
    {
#line 641
    if (pos->state == 1) {
#line 641
      goto case_1___0;
    }
#line 644
    if (pos->state == 2) {
#line 644
      goto case_2___0;
    }
#line 640
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
#line 642
    mask &= -11;
#line 643
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
#line 645
    mask &= -6;
#line 646
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 604
    tmp___2 = visible(mode & mask, (m + pos->p.m)->type, pos->p.s);
    }
#line 604
    if (! (tmp___2 < 0)) {
#line 604
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 650
  return;
}
}
#line 653 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/vpatch.c"
static void prev_mline(struct mpos *pos , struct file fm , struct file fb , struct file fa ,
                       struct merge *m , int mode ) 
{ 
  int mask ;
  struct mp prv ;
  int mode2 ;
  struct elmnt e ;
  struct elmnt tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 658
  while (1) {
    while_continue: /* CIL Label */ ;
#line 662
    prv = pos->p;
#line 663
    if (pos->p.m < 0) {
#line 664
      return;
    }
    {
#line 665
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 666
      tmp = prev_melmnt(& pos->p, fm, fb, fa, m);
#line 666
      e = tmp;
      }
#line 667
      if ((unsigned long )e.start == (unsigned long )((void *)0)) {
#line 668
        goto while_break___0;
      }
      {
#line 669
      tmp___0 = ends_mline(e);
      }
#line 669
      if (tmp___0) {
        {
#line 669
        tmp___1 = visible(mode, (m + pos->p.m)->type, pos->p.s);
        }
#line 669
        if (tmp___1 >= 0) {
#line 671
          goto while_break___0;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 673
    mode2 = check_line(*pos, fm, fb, fa, m, mode);
    }
#line 675
    if (mode2 & 32) {
#line 675
      if (pos->state == 0) {
#line 677
        pos->hi = pos->p;
#line 678
        pos->state = 2;
      } else {
#line 675
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 679
    if (! (mode2 & 32)) {
#line 679
      if (pos->state) {
        {
#line 682
        if (pos->state == 1) {
#line 682
          goto case_1;
        }
#line 686
        if (pos->state == 2) {
#line 686
          goto case_2;
        }
#line 681
        goto switch_break;
        case_1: /* CIL Label */ 
#line 684
        pos->state = 0;
#line 685
        goto switch_break;
        case_2: /* CIL Label */ 
#line 688
        pos->lo = prv;
#line 690
        pos->p = pos->hi;
#line 691
        (pos->state) --;
#line 692
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
    }
#line 695
    mask = 63;
    {
#line 697
    if (pos->state == 1) {
#line 697
      goto case_1___0;
    }
#line 700
    if (pos->state == 2) {
#line 700
      goto case_2___0;
    }
#line 696
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
#line 698
    mask &= -11;
#line 699
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
#line 701
    mask &= -6;
#line 702
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 658
    tmp___2 = visible(mode & mask, (m + pos->p.m)->type, pos->p.s);
    }
#line 658
    if (! (tmp___2 < 0)) {
#line 658
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 705
  return;
}
}
#line 708 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/vpatch.c"
static void blank(int row , int start , int cols , unsigned int attr ) 
{ 
  int tmp ;

  {
#line 710
  if (stdscr) {
#line 710
    stdscr->_attrs = (attr_t )attr;
  }
  {
#line 711
  wmove(stdscr, row, start);
  }
  {
#line 712
  while (1) {
    while_continue: /* CIL Label */ ;
#line 712
    tmp = cols;
#line 712
    cols --;
#line 712
    if (! (tmp > 0)) {
#line 712
      goto while_break;
    }
    {
#line 713
    waddch(stdscr, (chtype const   )' ');
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 714
  return;
}
}
#line 720 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/vpatch.c"
static int mcontains(struct mpos pos , struct file fm , struct file fb , struct file fa ,
                     struct merge *m , int mode , char *search , struct cursor *curs ,
                     int dir , int ignore_case ) 
{ 
  struct elmnt e ;
  int found ;
  struct mp mp ;
  int o ;
  int len ;
  size_t tmp ;
  int i ;
  int curs_i ;
  int tmp___0 ;
  int ( __attribute__((__nonnull__(1,2), __leaf__)) (*tmp___1))(char const   *__s1 ,
                                                                char const   *__s2 ,
                                                                size_t __n ) ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 742
  found = 0;
#line 745
  tmp = strlen((char const   *)search);
#line 745
  len = (int )tmp;
  }
  {
#line 747
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 748
    e = prev_melmnt(& pos.p, fm, fb, fa, m);
    }
#line 749
    if (e.start) {
#line 749
      if (*(e.start + 0)) {
        {
#line 752
        tmp___0 = same_mp(pos.p, curs->pos);
        }
#line 752
        if (tmp___0) {
#line 753
          curs_i = curs->offset;
        } else {
#line 755
          curs_i = -1;
        }
#line 756
        i = e.len - 1;
        {
#line 756
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 756
          if (! (i >= 0)) {
#line 756
            goto while_break___0;
          }
#line 757
          if (i == curs_i) {
#line 757
            if (dir == -1) {
#line 759
              found = 0;
            }
          }
#line 760
          if (i == curs_i) {
#line 760
            if (dir == 2) {
#line 762
              goto break_while;
            }
          }
#line 763
          if (! found) {
#line 763
            goto _L;
          } else
#line 763
          if (dir > 0) {
            _L: /* CIL Label */ 
#line 763
            if (ignore_case) {
#line 763
              tmp___1 = & strncasecmp;
            } else {
#line 763
              tmp___1 = & strncmp;
            }
            {
#line 763
            tmp___2 = (*tmp___1)((char const   *)(e.start + i), (char const   *)search,
                                 (size_t )len);
            }
#line 763
            if (tmp___2 == 0) {
#line 766
              mp = pos.p;
#line 767
              o = i;
#line 768
              found = 1;
            }
          }
#line 770
          if (i == curs_i) {
#line 770
            if (dir == -2) {
#line 772
              found = 0;
            }
          }
#line 773
          if (i == curs_i) {
#line 773
            if (dir == 1) {
#line 775
              goto break_while;
            }
          }
#line 756
          i --;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
#line 747
    if ((unsigned long )e.start != (unsigned long )((void *)0)) {
      {
#line 747
      tmp___3 = ends_mline(e);
      }
#line 747
      if (tmp___3) {
        {
#line 747
        tmp___4 = visible(mode, (m + pos.p.m)->type, pos.p.s);
        }
#line 747
        if (! (tmp___4 == -1)) {
#line 747
          goto while_break;
        }
      }
    } else {
#line 747
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  break_while: 
#line 782
  if (found) {
#line 783
    curs->pos = mp;
#line 784
    curs->offset = o;
  }
#line 786
  return (found);
}
}
#line 827 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/vpatch.c"
static void draw_mside(int mode , int row , int offset , int start , int cols , struct file fm ,
                       struct file fb , struct file fa , struct merge *m , struct mpos pos ,
                       struct cursor *curs ) 
{ 
  struct elmnt e ;
  int col ;
  char tag ;
  unsigned int tag_attr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned char *c ;
  int l ;
  int tmp___3 ;
  char b[40] ;
  struct elmnt e1 ;
  int A ;
  int B ;
  int C ;
  int D ;
  int E ;
  int F ;
  int tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  unsigned long tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int scol ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
#line 834
  col = 0;
  {
#line 839
  if (pos.state == 0) {
#line 839
    goto case_0;
  }
#line 843
  if (pos.state == 1) {
#line 843
    goto case_1;
  }
#line 852
  if (pos.state == 2) {
#line 852
    goto case_2;
  }
#line 838
  goto switch_break;
  case_0: /* CIL Label */ 
#line 840
  tag = (char )' ';
#line 841
  tag_attr = 0U;
#line 842
  goto switch_break;
  case_1: /* CIL Label */ 
#line 844
  tag = (char )'-';
#line 845
  tag_attr = a_delete;
#line 846
  if (mode & 4) {
#line 846
    if (mode & 128) {
#line 847
      tag = (char )'|';
#line 848
      tag_attr = a_delete;
    }
  }
#line 850
  mode &= 5;
#line 851
  goto switch_break;
  case_2: /* CIL Label */ 
#line 853
  tag = (char )'+';
#line 854
  tag_attr = a_added;
#line 855
  mode &= 10;
#line 856
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 859
  tmp = visible(mode, (m + pos.p.m)->type, pos.p.s);
  }
#line 859
  if (tmp < 0) {
    {
#line 861
    blank(row, offset, cols, a_void);
    }
#line 862
    if (curs) {
#line 863
      curs->width = -1;
#line 864
      curs->col = 0;
#line 865
      curs->pos = pos.p;
#line 866
      curs->offset = 0;
    }
#line 868
    return;
  }
#line 871
  if (stdscr) {
#line 871
    stdscr->_attrs = (attr_t )tag_attr;
  }
  {
#line 872
  tmp___0 = wmove(stdscr, row, offset);
  }
#line 872
  if (! (tmp___0 == -1)) {
    {
#line 872
    waddch(stdscr, (chtype const   )tag);
    }
  }
#line 873
  offset ++;
#line 874
  cols --;
#line 875
  if (stdscr) {
#line 875
    stdscr->_attrs = 0UL;
  }
  {
#line 878
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 879
    e = prev_melmnt(& pos.p, fm, fb, fa, m);
    }
#line 878
    if ((unsigned long )e.start != (unsigned long )((void *)0)) {
      {
#line 878
      tmp___1 = ends_mline(e);
      }
#line 878
      if (tmp___1) {
        {
#line 878
        tmp___2 = visible(mode, (m + pos.p.m)->type, pos.p.s);
        }
#line 878
        if (! (tmp___2 == -1)) {
#line 878
          goto while_break;
        }
      }
    } else {
#line 878
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 884
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 887
    e = next_melmnt(& pos.p, fm, fb, fa, m);
    }
#line 888
    if ((unsigned long )e.start == (unsigned long )((void *)0)) {
#line 888
      goto _L___0;
    } else {
      {
#line 888
      tmp___9 = ends_mline(e);
      }
#line 888
      if (tmp___9) {
        {
#line 888
        tmp___10 = visible(mode, (m + pos.p.m)->type, pos.p.s);
        }
#line 888
        if (tmp___10 != -1) {
          _L___0: /* CIL Label */ 
#line 892
          if (curs) {
#line 893
            curs->col = col;
#line 894
            if (col >= start + cols) {
#line 895
              curs->width = 0;
            } else {
#line 897
              curs->width = -1;
            }
#line 898
            if (curs->target >= 0) {
#line 899
              curs->pos = pos.p;
#line 900
              curs->offset = 0;
            } else {
              {
#line 901
              tmp___3 = same_mp(pos.p, curs->pos);
              }
#line 901
              if (tmp___3) {
#line 902
                curs->target = col;
              }
            }
          }
#line 904
          if (col < start) {
#line 905
            col = start;
          }
#line 906
          if (e.start) {
#line 906
            if ((int )*(e.start + 0) == 0) {
#line 909
              if (pos.p.s == 2) {
#line 909
                if ((unsigned int )(m + pos.p.m)->type == 3U) {
                  {
#line 911
                  e1 = *(fb.list + ((m + pos.p.m)->b + pos.p.o));
#line 912
                  sscanf((char const   */* __restrict  */)(e1.start + 1), (char const   */* __restrict  */)"%d %d %d",
                         & A, & B, & C);
#line 913
                  sscanf((char const   */* __restrict  */)(e.start + 1), (char const   */* __restrict  */)"%d %d %d",
                         & D, & E, & F);
#line 914
                  sprintf((char */* __restrict  */)(b), (char const   */* __restrict  */)"@@ -%d,%d +%d,%d @@\n",
                          B, C, E, F);
                  }
#line 915
                  if (stdscr) {
#line 915
                    stdscr->_attrs = (attr_t )a_sep;
                  }
                } else {
#line 909
                  goto _L;
                }
              } else {
                _L: /* CIL Label */ 
#line 917
                if (stdscr) {
                  {
#line 917
                  tmp___4 = visible(mode, (m + pos.p.m)->type, pos.p.s);
#line 917
                  stdscr->_attrs = (attr_t )tmp___4;
                  }
                }
                {
#line 918
                sprintf((char */* __restrict  */)(b), (char const   */* __restrict  */)"<%.17s>",
                        e.start + 1);
                }
              }
              {
#line 920
              tmp___5 = wmove(stdscr, row, (col - start) + offset);
              }
#line 920
              if (! (tmp___5 == -1)) {
                {
#line 920
                waddnstr(stdscr, (char const   *)(b), -1);
                }
              }
              {
#line 921
              tmp___6 = strlen((char const   *)(b));
#line 921
              col = (int )((size_t )col + tmp___6);
              }
            }
          }
#line 923
          if (e.start) {
            {
#line 923
            tmp___7 = visible(mode, (m + pos.p.m)->type, pos.p.s);
#line 923
            tmp___8 = (unsigned long )((unsigned int )tmp___7);
            }
          } else {
#line 923
            tmp___8 = 0UL;
          }
          {
#line 923
          blank(row, (col - start) + offset, (start + cols) - col, (unsigned int )tmp___8);
          }
#line 927
          return;
        }
      }
    }
    {
#line 929
    tmp___11 = visible(mode, (m + pos.p.m)->type, pos.p.s);
    }
#line 929
    if (tmp___11 == -1) {
#line 930
      goto while_continue___0;
    }
#line 931
    if ((int )*(e.start + 0) == 0) {
#line 932
      goto while_continue___0;
    }
#line 933
    if (stdscr) {
      {
#line 933
      tmp___12 = visible(mode, (m + pos.p.m)->type, pos.p.s);
#line 933
      stdscr->_attrs = (attr_t )tmp___12;
      }
    }
#line 934
    c = (unsigned char *)e.start;
#line 935
    l = 0;
    {
#line 935
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 935
      if (! (l < e.len)) {
#line 935
        goto while_break___1;
      }
#line 936
      scol = col;
#line 937
      if ((int )*c >= 32) {
#line 937
        if ((int )*c != 127) {
#line 938
          if (col >= start) {
#line 938
            if (col < start + cols) {
              {
#line 939
              tmp___13 = wmove(stdscr, row, (col - start) + offset);
              }
#line 939
              if (! (tmp___13 == -1)) {
                {
#line 939
                waddch(stdscr, (chtype const   )*c);
                }
              }
            }
          }
#line 940
          col ++;
        } else {
#line 937
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 941
      if ((int )*c == 9) {
        {
#line 942
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 943
          if (col >= start) {
#line 943
            if (col < start + cols) {
              {
#line 944
              tmp___14 = wmove(stdscr, row, (col - start) + offset);
              }
#line 944
              if (! (tmp___14 == -1)) {
                {
#line 944
                waddch(stdscr, (chtype const   )' ');
                }
              }
            }
          }
#line 945
          col ++;
#line 942
          if (! ((col & 7) != 0)) {
#line 942
            goto while_break___2;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
      } else {
#line 948
        if (col >= start) {
#line 948
          if (col < start + cols) {
            {
#line 949
            tmp___15 = wmove(stdscr, row, (col - start) + offset);
            }
#line 949
            if (! (tmp___15 == -1)) {
              {
#line 949
              waddch(stdscr, (chtype const   )'?');
              }
            }
          }
        }
#line 950
        col ++;
      }
#line 952
      if (curs) {
#line 953
        if (curs->target >= 0) {
#line 954
          if (curs->target < col) {
#line 956
            curs->pos = pos.p;
#line 957
            curs->offset = l;
#line 958
            curs->col = scol;
#line 959
            if (scol >= start + cols) {
#line 961
              curs->width = 0;
            } else {
#line 963
              curs->width = col - scol;
            }
#line 964
            curs = (struct cursor *)((void *)0);
          }
        } else
#line 966
        if (l == curs->offset) {
          {
#line 966
          tmp___16 = same_mp(pos.p, curs->pos);
          }
#line 966
          if (tmp___16) {
#line 969
            curs->target = scol;
#line 970
            curs->col = scol;
#line 971
            if (scol >= start + cols) {
#line 973
              curs->width = 0;
            } else {
#line 975
              curs->width = col - scol;
            }
#line 976
            curs = (struct cursor *)((void *)0);
          }
        }
      }
#line 979
      c ++;
#line 935
      l ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 986 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/vpatch.c"
static void draw_mline(int mode , int row , int start , int cols , struct file fm ,
                       struct file fb , struct file fa , struct merge *m , struct mpos pos ,
                       struct cursor *curs ) 
{ 
  int lcols ;
  int rcols ;
  int tmp ;
  int tmp___0 ;
  struct cursor *tmp___1 ;
  struct cursor *tmp___2 ;

  {
  {
#line 999
  tmp = check_line(pos, fm, fb, fa, m, mode);
#line 999
  mode |= tmp;
  }
#line 1001
  if (mode & 3) {
#line 1001
    if (mode & 12) {
#line 1004
      lcols = (cols - 1) / 2;
#line 1005
      rcols = (cols - lcols) - 1;
#line 1007
      if (stdscr) {
#line 1007
        stdscr->_attrs = 1UL << 16;
      }
      {
#line 1008
      tmp___0 = wmove(stdscr, row, lcols);
      }
#line 1008
      if (! (tmp___0 == -1)) {
        {
#line 1008
        waddch(stdscr, (chtype const   )'|');
        }
      }
#line 1010
      if (curs) {
#line 1010
        if (! curs->alt) {
#line 1010
          tmp___1 = curs;
        } else {
#line 1010
          tmp___1 = (struct cursor *)((void *)0);
        }
      } else {
#line 1010
        tmp___1 = (struct cursor *)((void *)0);
      }
      {
#line 1010
      draw_mside(mode & -4, row, 0, start, lcols, fm, fb, fa, m, pos, tmp___1);
      }
#line 1013
      if (curs) {
#line 1013
        if (curs->alt) {
#line 1013
          tmp___2 = curs;
        } else {
#line 1013
          tmp___2 = (struct cursor *)((void *)0);
        }
      } else {
#line 1013
        tmp___2 = (struct cursor *)((void *)0);
      }
      {
#line 1013
      draw_mside(mode & -13, row, lcols + 1, start, rcols, fm, fb, fa, m, pos, tmp___2);
      }
    } else {
      {
#line 1016
      draw_mside(mode, row, 0, start, cols, fm, fb, fa, m, pos, curs);
      }
    }
  } else {
    {
#line 1016
    draw_mside(mode, row, 0, start, cols, fm, fb, fa, m, pos, curs);
    }
  }
#line 1018
  return;
}
}
#line 1020 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/vpatch.c"
static char *merge_help[17]  = 
#line 1020
  {      (char *)"This view shows the merge of the patch with the",      (char *)"original file.  It is like a full-context diff showing",      (char *)"removed lines with a \'-\' prefix and added lines with a",      (char *)"\'+\' prefix.", 
        (char *)"In cases where a patch chunk could not be successfully",      (char *)"applied, the original text is prefixed with a \'|\', and",      (char *)"the text that the patch wanted to add is prefixed with",      (char *)"a \'+\'.", 
        (char *)"When the cursor is over such a conflict, or over a chunk",      (char *)"which required wiggling to apply (i.e. there was unmatched",      (char *)"text in the original, or extraneous unchanged text in",      (char *)"the patch), the terminal is split and the bottom pane is", 
        (char *)"use to display the part of the patch that applied to",      (char *)"this section of the original.  This allows you to confirm",      (char *)"that a wiggled patch applied correctly, and to see",      (char *)"why there was a conflict", 
        (char *)((void *)0)};
#line 1039 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/vpatch.c"
static char *diff_help[7]  = {      (char *)"This is the \'diff\' or \'patch\' view.  It shows",      (char *)"only the patch that is being applied without the",      (char *)"original to which it is being applied.",      (char *)"Underlined text indicates parts of the patch which", 
        (char *)"resulted in a conflict when applied to the",      (char *)"original.",      (char *)((void *)0)};
#line 1048 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/vpatch.c"
static char *orig_help[5]  = {      (char *)"This is the \'original\' view which simply shows",      (char *)"the original file before applying the patch.",      (char *)"Sections of code that would be changed by the patch",      (char *)"are highlighted in red.", 
        (char *)((void *)0)};
#line 1055 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/vpatch.c"
static char *result_help[7]  = {      (char *)"This is the \'result\' view which shows just the",      (char *)"result of applying the patch.  When a conflict",      (char *)"occurred this view does not show the full conflict",      (char *)"but only the \'after\' part of the patch.  To see", 
        (char *)"the full conflict, use the \'merge\' or \'sidebyside\'",      (char *)"views.",      (char *)((void *)0)};
#line 1064 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/vpatch.c"
static char *before_help[4]  = {      (char *)"This view shows the \'before\' section of a patch.",      (char *)"It allows the expected match text to be seen uncluttered",      (char *)"by text that is meant to replaced it.Red text is text that will be removed by the patch",      (char *)((void *)0)};
#line 1071 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/vpatch.c"
static char *after_help[5]  = {      (char *)"This view shows the \'after\' section of a patch.",      (char *)"It allows the intended result to be seen uncluttered",      (char *)"by text that was meant to be matched and replaced.Green text is text that was added by the patch - it",      (char *)"was not present in the \'before\' part of the patch", 
        (char *)((void *)0)};
#line 1079 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/vpatch.c"
static char *sidebyside_help[10]  = 
#line 1079
  {      (char *)"This is the Side By Side view of a patched file.",      (char *)"The left side shows the original and the result.",      (char *)"The right side shows the patch which was applied",      (char *)"and lines up with the original/result as much as", 
        (char *)"possible.",      (char *)"",      (char *)"Where one side has no line which matches the",      (char *)"other side it is displayed as a solid colour in the", 
        (char *)"yellow family (depending on your terminal window).",      (char *)((void *)0)};
#line 1091 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/vpatch.c"
static char *merge_window_help[55]  = 
#line 1091
  {      (char *)"  Highlight Colours and Keystroke commands",      (char *)"",      (char *)"In all different views of a merge, highlight colours",      (char *)"are used to show which parts of lines were added,", 
        (char *)"removed, already changed, unchanged or in conflict.",      (char *)"Colours and their use are:",      (char *)" normal              unchanged text",      (char *)" red                 text that was removed or changed", 
        (char *)" green               text that was added or the result",      (char *)"                     of a change",      (char *)" yellow background   used in side-by-side for a line",      (char *)"                     which has no match on the other", 
        (char *)"                     side",      (char *)" blue                text in the original which did not",      (char *)"                     match anything in the patch",      (char *)" cyan                text in the patch which did not", 
        (char *)"                     match anything in the original",      (char *)" cyan background     already changed text: the result",      (char *)"                     of the patch matches the original",      (char *)" underline           remove or added text can also be", 
        (char *)"                     underlined indicating that it",      (char *)"                     was involved in a conflict",      (char *)"While viewing a merge various keystroke commands can",      (char *)"be used to move around and change the view.  Basic", 
        (char *)"movement commands from both \'vi\' and \'emacs\' are",      (char *)"available:",      (char *)"",      (char *)" p control-p k UP    Move to previous line", 
        (char *)" n control-n j DOWN  Move to next line",      (char *)" l LEFT              Move one char to right",      (char *)" h RIGHT             Move one char to left",      (char *)" / control-s         Enter incremental search mode", 
        (char *)" control-r           Enter reverse-search mode",      (char *)" control-g           Search again",      (char *)" ?                   Display help message",      (char *)" ESC-<  0-G          Go to start of file", 
        (char *)" ESC->  G            Go to end of file",      (char *)" q                   Return to list of files or exit",      (char *)" control-L           recenter current line",      (char *)" control-V           page down", 
        (char *)" ESC-v\t              page up",      (char *)" N                   go to next patch chunk",      (char *)" P                   go to previous patch chunk",      (char *)" O                   move cursor to alternate pane", 
        (char *)" ^ control-A         go to start of line",      (char *)" $ control-E         go to end of line",      (char *)"",      (char *)" a                   display \'after\' view", 
        (char *)" b                   display \'before\' view",      (char *)" o                   display \'original\' view",      (char *)" r                   display \'result\' view",      (char *)" d                   display \'diff\' or \'patch\' view", 
        (char *)" m                   display \'merge\' view",      (char *)" |                   display side-by-side view",      (char *)((void *)0)};
#line 1150 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/vpatch.c"
static void merge_window(struct plist *p , FILE *f , int reverse ) 
{ 
  struct stream sm ;
  struct stream sb ;
  struct stream sa ;
  struct stream sp ;
  struct file fm ;
  struct file fb ;
  struct file fa ;
  struct csl *csl1 ;
  struct csl *csl2 ;
  struct ci ci ;
  int ch ;
  int refresh___0 ;
  int rows ;
  int cols ;
  int splitrow ;
  int lastrow ;
  int i ;
  int c ;
  int cswitch ;
  int mode ;
  int mmode ;
  char *modename ;
  char **modehelp ;
  int row ;
  int start ;
  int trow ;
  struct cursor curs ;
  struct mpos pos ;
  struct mpos tpos ;
  struct mpos toppos ;
  struct mpos botpos ;
  struct mpos vpos ;
  struct mpos tvpos ;
  int botrow ;
  int meta___0 ;
  int tmeta ;
  int num ;
  int tnum ;
  char search[80] ;
  unsigned int searchlen ;
  int search_notfound ;
  int searchdir ;
  int ignore_case ;
  struct search_anchor *anchor ;
  char buf[100] ;
  char const   *tmp ;
  int tmp___0 ;
  int cmode ;
  int tmp___1 ;
  char b[100] ;
  char *e ;
  char e2[7] ;
  int i___0 ;
  int tmp___2 ;
  char *tmp___3 ;
  struct cursor *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  struct mpos spos ;
  int smode ;
  int srow ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  struct cursor *tmp___13 ;
  int tmp___14 ;
  char lbuf[30] ;
  size_t tmp___15 ;
  int tmp___16 ;
  size_t tmp___17 ;
  int tmp___18 ;
  char buf___0[10] ;
  struct search_anchor *a ;
  struct search_anchor *a___0 ;
  unsigned int tmp___19 ;
  unsigned int i___1 ;
  unsigned short const   **tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  struct search_anchor *a___1 ;
  void *tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  struct search_anchor *a___2 ;

  {
#line 1173
  refresh___0 = 2;
#line 1174
  rows = 0;
#line 1174
  cols = 0;
#line 1175
  splitrow = -1;
#line 1176
  lastrow = 0;
#line 1178
  mode = 12;
#line 1179
  mmode = mode;
#line 1180
  modename = (char *)"merge";
#line 1181
  modehelp = merge_help;
#line 1183
  start = 0;
#line 1192
  botrow = 0;
#line 1193
  meta___0 = 0;
#line 1195
  num = -1;
#line 1198
  searchlen = 0U;
#line 1199
  search_notfound = 0;
#line 1200
  searchdir = 0;
#line 1207
  ignore_case = 2;
#line 1211
  anchor = (struct search_anchor *)((void *)0);
#line 1220
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 1222
    sm = load_file(p->file);
#line 1223
    sb = load_file(p->before);
#line 1224
    sa = load_file(p->after);
#line 1225
    ch = 0;
    }
  } else {
    {
#line 1227
    sp = load_segment(f, p->start, p->end);
    }
#line 1228
    if (p->is_merge) {
#line 1229
      if (reverse) {
        {
#line 1230
        split_merge(sp, & sm, & sa, & sb);
        }
      } else {
        {
#line 1232
        split_merge(sp, & sm, & sb, & sa);
        }
      }
#line 1233
      ch = 0;
    } else {
#line 1235
      if (reverse) {
        {
#line 1236
        ch = split_patch(sp, & sa, & sb);
        }
      } else {
        {
#line 1238
        ch = split_patch(sp, & sb, & sa);
        }
      }
      {
#line 1240
      sm = load_file(p->file);
      }
    }
  }
#line 1243
  if (! sm.body) {
#line 1243
    goto _L;
  } else
#line 1243
  if (! sb.body) {
#line 1243
    goto _L;
  } else
#line 1243
  if (! sa.body) {
    _L: /* CIL Label */ 
    {
#line 1244
    term_init();
    }
#line 1245
    if (! sm.body) {
      {
#line 1246
      help_window(help_missing, (char **)((void *)0));
      }
    } else {
      {
#line 1248
      help_window(help_corrupt, (char **)((void *)0));
      }
    }
#line 1249
    return;
  }
  {
#line 1252
  fm = split_stream(sm, 1);
#line 1253
  fb = split_stream(sb, 1);
#line 1254
  fa = split_stream(sa, 1);
  }
#line 1256
  if (ch) {
    {
#line 1257
    csl1 = pdiff(fm, fb, ch);
    }
  } else {
    {
#line 1259
    csl1 = diff(fm, fb);
    }
  }
  {
#line 1260
  csl2 = diff(fb, fa);
#line 1262
  ci = make_merger(fm, fb, fa, csl1, csl2, 0, 1, 0);
#line 1264
  term_init();
#line 1266
  row = 1;
#line 1267
  pos.p.m = 0;
#line 1268
  pos.p.s = 0;
#line 1269
  pos.p.o = -1;
#line 1270
  pos.p.lineno = 1;
#line 1271
  pos.state = 0;
#line 1272
  next_mline(& pos, fm, fb, fa, ci.merger, mode);
#line 1273
  memset((void *)(& curs), 0, sizeof(curs));
#line 1274
  vpos = pos;
  }
  {
#line 1275
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1276
    if (refresh___0 >= 2) {
      {
#line 1278
      wclear(stdscr);
      }
#line 1279
      if (reverse) {
#line 1279
        tmp = " - reversed";
      } else {
#line 1279
        tmp = "";
      }
      {
#line 1279
      snprintf((char */* __restrict  */)(buf), (size_t )100, (char const   */* __restrict  */)"File: %s%s Mode: %s\n",
               p->file, tmp, modename);
      }
#line 1281
      if (stdscr) {
#line 1281
        stdscr->_attrs = 1UL << 21;
      }
      {
#line 1282
      tmp___0 = wmove(stdscr, 0, 0);
      }
#line 1282
      if (! (tmp___0 == -1)) {
        {
#line 1282
        waddnstr(stdscr, (char const   *)(buf), -1);
        }
      }
      {
#line 1283
      wclrtoeol(stdscr);
      }
#line 1284
      if (stdscr) {
#line 1284
        stdscr->_attrs = 0UL;
      }
#line 1285
      refresh___0 = 1;
    }
#line 1287
    if (row < 1) {
#line 1288
      refresh___0 = 1;
    } else
#line 1287
    if (row >= lastrow) {
#line 1288
      refresh___0 = 1;
    }
#line 1289
    if (curs.alt) {
#line 1290
      refresh___0 = 1;
    }
#line 1292
    if (mode == 12) {
      {
#line 1293
      tmp___1 = check_line(pos, fm, fb, fa, ci.merger, mode);
#line 1293
      cmode = tmp___1;
      }
#line 1294
      if (cmode & 192) {
#line 1295
        if (splitrow < 0) {
#line 1296
          splitrow = (rows + 1) / 2;
#line 1297
          lastrow = splitrow - 1;
#line 1298
          refresh___0 = 1;
        }
      } else
#line 1300
      if (! curs.alt) {
#line 1300
        if (splitrow >= 0) {
#line 1301
          splitrow = -1;
#line 1302
          lastrow = rows - 1;
#line 1303
          refresh___0 = 1;
        }
      }
    } else
#line 1305
    if (splitrow >= 0) {
#line 1306
      splitrow = -1;
#line 1307
      lastrow = rows - 1;
#line 1308
      refresh___0 = 1;
    }
#line 1311
    if (refresh___0) {
#line 1312
      if (stdscr) {
#line 1312
        rows = (int )stdscr->_maxy + 1;
      } else {
#line 1312
        rows = -1;
      }
#line 1312
      if (stdscr) {
#line 1312
        cols = (int )stdscr->_maxx + 1;
      } else {
#line 1312
        cols = -1;
      }
#line 1313
      rows --;
#line 1314
      if (splitrow >= 0) {
#line 1315
        splitrow = (rows + 1) / 2;
#line 1316
        lastrow = splitrow - 1;
      } else {
#line 1318
        lastrow = rows - 1;
      }
#line 1320
      if (row < -3) {
#line 1321
        row = lastrow / 2 + 1;
      }
#line 1322
      if (row < 1) {
#line 1323
        row = 1;
      }
#line 1324
      if (row > lastrow + 3) {
#line 1325
        row = lastrow / 2 + 1;
      }
#line 1326
      if (row >= lastrow) {
#line 1327
        row = lastrow - 1;
      }
    }
    {
#line 1329
    tmp___3 = getenv("WIGGLE_VTRACE");
    }
#line 1329
    if (tmp___3) {
      {
#line 1334
      if (vpos.p.s == 0) {
#line 1334
        goto case_0;
      }
#line 1337
      if (vpos.p.s == 1) {
#line 1337
        goto case_1;
      }
#line 1340
      if (vpos.p.s == 2) {
#line 1340
        goto case_2;
      }
#line 1333
      goto switch_break;
      case_0: /* CIL Label */ 
#line 1335
      e = (fm.list + ((ci.merger + vpos.p.m)->a + vpos.p.o))->start;
#line 1336
      goto switch_break;
      case_1: /* CIL Label */ 
#line 1338
      e = (fb.list + ((ci.merger + vpos.p.m)->b + vpos.p.o))->start;
#line 1339
      goto switch_break;
      case_2: /* CIL Label */ 
#line 1341
      e = (fa.list + ((ci.merger + vpos.p.m)->c + vpos.p.o))->start;
#line 1342
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 1344
      i___0 = 0;
      {
#line 1344
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1344
        if (! (i___0 < 6)) {
#line 1344
          goto while_break___0;
        }
#line 1345
        e2[i___0] = *(e + i___0);
#line 1346
        if ((int )e2[i___0] < 32) {
#line 1347
          e2[i___0] = (char )'?';
        } else
#line 1346
        if ((int )e2[i___0] >= 127) {
#line 1347
          e2[i___0] = (char )'?';
        }
#line 1344
        i___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1349
      sprintf((char */* __restrict  */)(b), (char const   */* __restrict  */)"st=%d str=%d o=%d m=%d mt=%s(%d,%d,%d) ic=%d  <%.3s>",
              vpos.state, vpos.p.s, vpos.p.o, vpos.p.m, typenames[(ci.merger + vpos.p.m)->type],
              (ci.merger + vpos.p.m)->al, (ci.merger + vpos.p.m)->bl, (ci.merger + vpos.p.m)->cl,
              (ci.merger + vpos.p.m)->in_conflict, e2);
      }
#line 1358
      if (stdscr) {
#line 1358
        stdscr->_attrs = 0UL;
      }
      {
#line 1359
      tmp___2 = wmove(stdscr, 0, 50);
      }
#line 1359
      if (! (tmp___2 == -1)) {
        {
#line 1359
        waddnstr(stdscr, (char const   *)(b), -1);
        }
      }
      {
#line 1360
      wclrtoeol(stdscr);
      }
    }
    {
#line 1364
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1364
      if (! (start > curs.target)) {
#line 1364
        goto while_break___1;
      }
#line 1365
      start -= 8;
#line 1366
      refresh___0 = 1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1368
    if (start < 0) {
#line 1369
      start = 0;
    }
    retry: 
#line 1371
    if (splitrow >= 0) {
#line 1371
      if (curs.alt) {
#line 1371
        tmp___4 = (struct cursor *)((void *)0);
      } else {
#line 1371
        tmp___4 = & curs;
      }
    } else {
#line 1371
      tmp___4 = & curs;
    }
    {
#line 1371
    draw_mline(mode, row, start, cols, fm, fb, fa, ci.merger, pos, tmp___4);
    }
#line 1373
    if (curs.width == 0) {
#line 1373
      if (start < curs.col) {
#line 1375
        start += 8;
#line 1376
        refresh___0 = 1;
#line 1377
        goto retry;
      }
    }
#line 1379
    if (curs.col < start) {
#line 1380
      start -= 8;
#line 1381
      refresh___0 = 1;
#line 1382
      if (start < 0) {
#line 1383
        start = 0;
      }
#line 1384
      goto retry;
    }
#line 1386
    if (refresh___0) {
#line 1387
      refresh___0 = 0;
#line 1388
      tpos = pos;
#line 1390
      i = row - 1;
      {
#line 1390
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1390
        if (i >= 1) {
#line 1390
          if (! (tpos.p.m >= 0)) {
#line 1390
            goto while_break___2;
          }
        } else {
#line 1390
          goto while_break___2;
        }
        {
#line 1391
        prev_mline(& tpos, fm, fb, fa, ci.merger, mode);
#line 1392
        tmp___5 = i;
#line 1392
        i --;
#line 1392
        draw_mline(mode, tmp___5, start, cols, fm, fb, fa, ci.merger, tpos, (struct cursor *)((void *)0));
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1397
      if (i) {
#line 1398
        row -= i + 1;
#line 1399
        refresh___0 = 1;
#line 1400
        goto retry;
      }
#line 1402
      toppos = tpos;
      {
#line 1403
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1403
        if (! (i >= 1)) {
#line 1403
          goto while_break___3;
        }
        {
#line 1404
        tmp___6 = i;
#line 1404
        i --;
#line 1404
        blank(tmp___6, 0, cols, a_void);
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1405
      tpos = pos;
#line 1406
      i = row;
      {
#line 1406
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1406
        if (i <= lastrow) {
#line 1406
          if (! ((unsigned int )(ci.merger + tpos.p.m)->type != 0U)) {
#line 1406
            goto while_break___4;
          }
        } else {
#line 1406
          goto while_break___4;
        }
        {
#line 1407
        tmp___7 = i;
#line 1407
        i ++;
#line 1407
        draw_mline(mode, tmp___7, start, cols, fm, fb, fa, ci.merger, tpos, (struct cursor *)((void *)0));
#line 1410
        next_mline(& tpos, fm, fb, fa, ci.merger, mode);
        }
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1412
      botpos = tpos;
#line 1412
      botrow = i;
      {
#line 1413
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1413
        if (! (i <= lastrow)) {
#line 1413
          goto while_break___5;
        }
        {
#line 1414
        tmp___8 = i;
#line 1414
        i ++;
#line 1414
        blank(tmp___8, 0, cols, a_void);
        }
      }
      while_break___5: /* CIL Label */ ;
      }
    }
#line 1417
    if (splitrow >= 0) {
      {
#line 1418
      spos = pos;
#line 1419
      smode = 3;
#line 1420
      srow = (rows + splitrow) / 2;
#line 1421
      tmp___9 = visible(smode, (ci.merger + spos.p.m)->type, spos.p.s);
      }
#line 1421
      if (tmp___9 < 0) {
        {
#line 1423
        prev_mline(& spos, fm, fb, fa, ci.merger, smode);
        }
      }
#line 1425
      tpos = spos;
      {
#line 1426
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1426
        if (spos.p.m >= 0) {
#line 1426
          if (! (spos.state != 0)) {
#line 1426
            goto while_break___6;
          }
        } else {
#line 1426
          goto while_break___6;
        }
        {
#line 1427
        prev_mline(& spos, fm, fb, fa, ci.merger, smode);
        }
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 1428
      while (1) {
        while_continue___7: /* CIL Label */ ;
        {
#line 1428
        tmp___10 = same_mpos(spos, tpos);
        }
#line 1428
        if (tmp___10) {
#line 1428
          goto while_break___7;
        }
        {
#line 1429
        next_mline(& spos, fm, fb, fa, ci.merger, smode);
        }
      }
      while_break___7: /* CIL Label */ ;
      }
#line 1431
      if (stdscr) {
#line 1431
        stdscr->_attrs = (attr_t )a_sep;
      }
#line 1432
      i = 0;
      {
#line 1432
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 1432
        if (! (i < cols)) {
#line 1432
          goto while_break___8;
        }
        {
#line 1433
        tmp___11 = wmove(stdscr, splitrow, i);
        }
#line 1433
        if (! (tmp___11 == -1)) {
          {
#line 1433
          waddnstr(stdscr, "-", -1);
          }
        }
#line 1432
        i ++;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 1435
      tpos = spos;
#line 1436
      i = srow - 1;
      {
#line 1436
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 1436
        if (! (i > splitrow)) {
#line 1436
          goto while_break___9;
        }
        {
#line 1437
        prev_mline(& tpos, fm, fb, fa, ci.merger, smode);
#line 1438
        draw_mline(smode, i, start, cols, fm, fb, fa, ci.merger, tpos, (struct cursor *)((void *)0));
#line 1436
        i --;
        }
      }
      while_break___9: /* CIL Label */ ;
      }
      {
#line 1441
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 1441
        if (! (i > splitrow)) {
#line 1441
          goto while_break___10;
        }
        {
#line 1442
        tmp___12 = i;
#line 1442
        i --;
#line 1442
        blank(tmp___12, 0, cols, a_void);
        }
      }
      while_break___10: /* CIL Label */ ;
      }
#line 1443
      tpos = spos;
#line 1444
      i = srow;
      {
#line 1444
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 1444
        if (i < rows) {
#line 1444
          if (! ((unsigned int )(ci.merger + tpos.p.m)->type != 0U)) {
#line 1444
            goto while_break___11;
          }
        } else {
#line 1444
          goto while_break___11;
        }
#line 1447
        if (i == srow) {
#line 1447
          if (curs.alt) {
#line 1447
            tmp___13 = & curs;
          } else {
#line 1447
            tmp___13 = (struct cursor *)((void *)0);
          }
        } else {
#line 1447
          tmp___13 = (struct cursor *)((void *)0);
        }
        {
#line 1447
        draw_mline(smode, i, start, cols, fm, fb, fa, ci.merger, tpos, tmp___13);
#line 1450
        next_mline(& tpos, fm, fb, fa, ci.merger, smode);
#line 1444
        i ++;
        }
      }
      while_break___11: /* CIL Label */ ;
      }
      {
#line 1452
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 1452
        if (! (i < rows)) {
#line 1452
          goto while_break___12;
        }
        {
#line 1453
        tmp___14 = i;
#line 1453
        i ++;
#line 1453
        blank(tmp___14, 0, cols, a_void);
        }
      }
      while_break___12: /* CIL Label */ ;
      }
    }
#line 1458
    if (stdscr) {
#line 1458
      stdscr->_attrs = 1UL << 21;
    }
    {
#line 1459
    snprintf((char */* __restrict  */)(lbuf), (size_t )29, (char const   */* __restrict  */)"%s ln:%d",
             typenames[(ci.merger + curs.pos.m)->type], (pos.p.lineno - 1) / 2);
#line 1462
    tmp___15 = strlen((char const   *)(lbuf));
#line 1462
    tmp___16 = wmove(stdscr, 0, (int )(((size_t )cols - tmp___15) - 4UL));
    }
#line 1462
    if (! (tmp___16 == -1)) {
      {
#line 1462
      waddnstr(stdscr, "       ", -1);
      }
    }
    {
#line 1463
    tmp___17 = strlen((char const   *)(lbuf));
#line 1463
    tmp___18 = wmove(stdscr, 0, (int )(((size_t )cols - tmp___17) - 1UL));
    }
#line 1463
    if (! (tmp___18 == -1)) {
      {
#line 1463
      waddnstr(stdscr, (char const   *)(lbuf), -1);
      }
    }
    {
#line 1467
    wmove(stdscr, rows, 0);
    }
#line 1468
    if (stdscr) {
#line 1468
      stdscr->_attrs = 0UL;
    }
#line 1469
    if (num >= 0) {
      {
#line 1471
      snprintf((char */* __restrict  */)(buf___0), (size_t )10, (char const   */* __restrict  */)"%d ",
               num);
#line 1472
      waddnstr(stdscr, (char const   *)(buf___0), -1);
      }
    }
#line 1474
    if (meta___0 & 4096) {
      {
#line 1475
      waddnstr(stdscr, "ESC...", -1);
      }
    }
#line 1476
    if (meta___0 & 8192) {
#line 1477
      if (searchdir < 0) {
        {
#line 1478
        waddnstr(stdscr, "Backwards ", -1);
        }
      }
      {
#line 1479
      waddnstr(stdscr, "Search: ", -1);
#line 1480
      waddnstr(stdscr, (char const   *)(search), -1);
      }
#line 1481
      if (search_notfound) {
        {
#line 1482
        waddnstr(stdscr, " - Not Found.", -1);
        }
      }
#line 1483
      search_notfound = 0;
    }
    {
#line 1485
    wclrtoeol(stdscr);
    }
#line 1487
    if (curs.alt) {
#line 1487
      if (splitrow > 0) {
        {
#line 1488
        wmove(stdscr, (rows + splitrow) / 2, (curs.col - start) + 1);
        }
      } else {
#line 1487
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1489
    if (curs.alt) {
#line 1489
      if (mode & 3) {
#line 1489
        if (mode & 12) {
          {
#line 1491
          wmove(stdscr, row, ((curs.col - start) + (cols - 1) / 2) + 2);
          }
        } else {
          {
#line 1493
          wmove(stdscr, row, (curs.col - start) + 1);
          }
        }
      } else {
        {
#line 1493
        wmove(stdscr, row, (curs.col - start) + 1);
        }
      }
    } else {
      {
#line 1493
      wmove(stdscr, row, (curs.col - start) + 1);
      }
    }
    {
#line 1494
    c = wgetch(stdscr);
#line 1495
    tmeta = meta___0;
#line 1495
    meta___0 = 0;
#line 1496
    tnum = num;
#line 1496
    num = -1;
#line 1497
    tvpos = vpos;
#line 1497
    vpos = pos;
#line 1498
    cswitch = c | tmeta;
    }
#line 1501
    if (cswitch >= 48) {
#line 1501
      if (cswitch <= 57) {
#line 1502
        cswitch = '0';
      }
    }
#line 1504
    if (cswitch >= 8224) {
#line 1504
      if (cswitch <= 8318) {
#line 1505
        cswitch = 8224;
      }
    }
    {
#line 1509
    if (cswitch == 4123) {
#line 1509
      goto case_4123;
    }
#line 1509
    if (cswitch == 27) {
#line 1509
      goto case_4123;
    }
#line 1512
    if (cswitch == 4156) {
#line 1512
      goto start;
    }
#line 1523
    if (cswitch == 71) {
#line 1523
      goto case_71;
    }
#line 1523
    if (cswitch == 4158) {
#line 1523
      goto case_71;
    }
#line 1534
    if (cswitch == 48) {
#line 1534
      goto case_48;
    }
#line 1539
    if (cswitch == 113) {
#line 1539
      goto case_113;
    }
#line 1543
    if (cswitch == 19) {
#line 1543
      goto case_19;
    }
#line 1543
    if (cswitch == 47) {
#line 1543
      goto case_19;
    }
#line 1551
    if (cswitch == 18) {
#line 1551
      goto case_18;
    }
#line 1551
    if (cswitch == 92) {
#line 1551
      goto case_18;
    }
#line 1560
    if (cswitch == 8210) {
#line 1560
      goto case_8210;
    }
#line 1560
    if (cswitch == 8211) {
#line 1560
      goto case_8210;
    }
#line 1560
    if (cswitch == 8199) {
#line 1560
      goto case_8210;
    }
#line 1573
    if (cswitch == 8455) {
#line 1573
      goto case_8455;
    }
#line 1573
    if (cswitch == 8200) {
#line 1573
      goto case_8455;
    }
#line 1598
    if (cswitch == 8201) {
#line 1598
      goto case_8201;
    }
#line 1598
    if (cswitch == 8224) {
#line 1598
      goto case_8201;
    }
#line 1636
    if (cswitch == 12) {
#line 1636
      goto case_12;
    }
#line 1641
    if (cswitch == 22) {
#line 1641
      goto case_22;
    }
#line 1649
    if (cswitch == 4214) {
#line 1649
      goto case_4214;
    }
#line 1658
    if (cswitch == 258) {
#line 1658
      goto case_258;
    }
#line 1658
    if (cswitch == 14) {
#line 1658
      goto case_258;
    }
#line 1658
    if (cswitch == 110) {
#line 1658
      goto case_258;
    }
#line 1658
    if (cswitch == 106) {
#line 1658
      goto case_258;
    }
#line 1670
    if (cswitch == 78) {
#line 1670
      goto case_78;
    }
#line 1684
    if (cswitch == 80) {
#line 1684
      goto case_80;
    }
#line 1701
    if (cswitch == 259) {
#line 1701
      goto case_259;
    }
#line 1701
    if (cswitch == 16) {
#line 1701
      goto case_259;
    }
#line 1701
    if (cswitch == 112) {
#line 1701
      goto case_259;
    }
#line 1701
    if (cswitch == 107) {
#line 1701
      goto case_259;
    }
#line 1715
    if (cswitch == 104) {
#line 1715
      goto case_104;
    }
#line 1715
    if (cswitch == 260) {
#line 1715
      goto case_104;
    }
#line 1732
    if (cswitch == 108) {
#line 1732
      goto case_108;
    }
#line 1732
    if (cswitch == 261) {
#line 1732
      goto case_108;
    }
#line 1750
    if (cswitch == 1) {
#line 1750
      goto case_1___0;
    }
#line 1750
    if (cswitch == 94) {
#line 1750
      goto case_1___0;
    }
#line 1755
    if (cswitch == 5) {
#line 1755
      goto case_5;
    }
#line 1755
    if (cswitch == 36) {
#line 1755
      goto case_5;
    }
#line 1760
    if (cswitch == 79) {
#line 1760
      goto case_79;
    }
#line 1768
    if (cswitch == 97) {
#line 1768
      goto case_97;
    }
#line 1773
    if (cswitch == 98) {
#line 1773
      goto case_98;
    }
#line 1778
    if (cswitch == 111) {
#line 1778
      goto case_111;
    }
#line 1783
    if (cswitch == 114) {
#line 1783
      goto case_114;
    }
#line 1788
    if (cswitch == 100) {
#line 1788
      goto case_100;
    }
#line 1793
    if (cswitch == 109) {
#line 1793
      goto case_109;
    }
#line 1799
    if (cswitch == 124) {
#line 1799
      goto case_124;
    }
#line 1805
    if (cswitch == 72) {
#line 1805
      goto case_72;
    }
#line 1811
    if (cswitch == 76) {
#line 1811
      goto case_76;
    }
#line 1818
    if (cswitch == 60) {
#line 1818
      goto case_60;
    }
#line 1823
    if (cswitch == 62) {
#line 1823
      goto case_62;
    }
#line 1829
    if (cswitch == 63) {
#line 1829
      goto case_63;
    }
#line 1834
    if (cswitch == 410) {
#line 1834
      goto case_410;
    }
#line 1507
    goto switch_break___0;
    case_4123: /* CIL Label */ 
    case_27: /* CIL Label */ 
#line 1510
    meta___0 = 4096;
#line 1511
    goto switch_break___0;
    start: 
    case_4156: /* CIL Label */ 
#line 1514
    tpos = pos;
#line 1514
    row ++;
    {
#line 1515
    while (1) {
      while_continue___13: /* CIL Label */ ;
      {
#line 1516
      pos = tpos;
#line 1516
      row --;
#line 1517
      prev_mline(& tpos, fm, fb, fa, ci.merger, mmode);
      }
#line 1515
      if (! (tpos.p.m >= 0)) {
#line 1515
        goto while_break___13;
      }
    }
    while_break___13: /* CIL Label */ ;
    }
#line 1519
    if (row <= 0) {
#line 1520
      row = 0;
    }
#line 1521
    goto switch_break___0;
    case_71: /* CIL Label */ 
    case_4158: /* CIL Label */ 
#line 1524
    if (tnum >= 0) {
#line 1525
      goto start;
    }
#line 1526
    tpos = pos;
#line 1526
    row --;
    {
#line 1527
    while (1) {
      while_continue___14: /* CIL Label */ ;
      {
#line 1528
      pos = tpos;
#line 1528
      row ++;
#line 1529
      next_mline(& tpos, fm, fb, fa, ci.merger, mmode);
      }
#line 1527
      if (! ((unsigned int )(ci.merger + tpos.p.m)->type != 0U)) {
#line 1527
        goto while_break___14;
      }
    }
    while_break___14: /* CIL Label */ ;
    }
#line 1531
    if (row >= lastrow) {
#line 1532
      row = lastrow;
    }
#line 1533
    goto switch_break___0;
    case_48: /* CIL Label */ 
#line 1535
    if (tnum < 0) {
#line 1536
      tnum = 0;
    }
#line 1537
    num = tnum * 10 + (c - 48);
#line 1538
    goto switch_break___0;
    case_113: /* CIL Label */ 
#line 1540
    return;
    case_19: /* CIL Label */ 
    case_47: /* CIL Label */ 
#line 1545
    meta___0 = 8192;
#line 1546
    searchlen = 0U;
#line 1547
    search[searchlen] = (char)0;
#line 1548
    searchdir = 1;
#line 1549
    goto switch_break___0;
    case_18: /* CIL Label */ 
    case_92: /* CIL Label */ 
#line 1553
    meta___0 = 8192;
#line 1554
    searchlen = 0U;
#line 1555
    search[searchlen] = (char)0;
#line 1556
    searchdir = -1;
#line 1557
    goto switch_break___0;
    case_8210: /* CIL Label */ 
    case_8211: /* CIL Label */ 
    case_8199: /* CIL Label */ 
#line 1562
    if ((c | tmeta) == 8210) {
#line 1563
      searchdir = -2;
    } else
#line 1564
    if ((c | tmeta) == 8211) {
#line 1565
      searchdir = 2;
    } else {
#line 1567
      searchdir *= 2;
    }
#line 1568
    meta___0 = 8192;
#line 1569
    tpos = pos;
#line 1569
    trow = row;
#line 1570
    goto search_again;
    case_8455: /* CIL Label */ 
    case_8200: /* CIL Label */ 
#line 1574
    meta___0 = 8192;
#line 1575
    if (anchor) {
      {
#line 1577
      a = anchor;
#line 1578
      anchor = a->next;
#line 1579
      free((void *)a);
      }
    }
#line 1581
    if (anchor) {
      {
#line 1583
      a___0 = anchor;
#line 1584
      anchor = a___0->next;
#line 1585
      pos = a___0->pos;
#line 1586
      row = a___0->row;
#line 1587
      start = a___0->start;
#line 1588
      curs = a___0->curs;
#line 1589
      curs.target = -1;
#line 1590
      search_notfound = a___0->notfound;
#line 1591
      searchlen = a___0->searchlen;
#line 1592
      search[searchlen] = (char)0;
#line 1593
      free((void *)a___0);
#line 1594
      refresh___0 = 1;
      }
    }
#line 1596
    goto switch_break___0;
    case_8201: /* CIL Label */ 
    case_8224: /* CIL Label */ 
#line 1599
    meta___0 = 8192;
#line 1600
    if ((unsigned long )searchlen < sizeof(search) - 1UL) {
#line 1601
      tmp___19 = searchlen;
#line 1601
      searchlen ++;
#line 1601
      search[tmp___19] = (char )(c & 127);
    }
#line 1602
    search[searchlen] = (char)0;
#line 1603
    tpos = pos;
#line 1603
    trow = row;
    search_again: 
#line 1605
    search_notfound = 1;
#line 1606
    if (ignore_case == 1) {
#line 1606
      goto _L___1;
    } else
#line 1606
    if (ignore_case == 2) {
      _L___1: /* CIL Label */ 
#line 1608
      ignore_case = 2;
#line 1609
      i___1 = 0U;
      {
#line 1609
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 1609
        if (! (i___1 < searchlen)) {
#line 1609
          goto while_break___15;
        }
        {
#line 1610
        tmp___20 = __ctype_b_loc();
        }
#line 1610
        if ((int const   )*(*tmp___20 + (int )search[i___1]) & 256) {
#line 1611
          ignore_case = 1;
#line 1612
          goto while_break___15;
        }
#line 1609
        i___1 ++;
      }
      while_break___15: /* CIL Label */ ;
      }
    }
    {
#line 1615
    while (1) {
      while_continue___16: /* CIL Label */ ;
      {
#line 1616
      tmp___21 = mcontains(tpos, fm, fb, fa, ci.merger, mmode, search, & curs, searchdir,
                           ignore_case >= 2);
      }
#line 1616
      if (tmp___21) {
#line 1619
        curs.target = -1;
#line 1620
        pos = tpos;
#line 1621
        row = trow;
#line 1622
        search_notfound = 0;
#line 1623
        goto while_break___16;
      }
#line 1625
      if (searchdir < 0) {
        {
#line 1626
        trow --;
#line 1627
        prev_mline(& tpos, fm, fb, fa, ci.merger, mmode);
        }
      } else {
        {
#line 1629
        trow ++;
#line 1630
        next_mline(& tpos, fm, fb, fa, ci.merger, mmode);
        }
      }
#line 1615
      if (tpos.p.m >= 0) {
#line 1615
        if (! ((unsigned int )(ci.merger + tpos.p.m)->type != 0U)) {
#line 1615
          goto while_break___16;
        }
      } else {
#line 1615
        goto while_break___16;
      }
    }
    while_break___16: /* CIL Label */ ;
    }
    {
#line 1633
    tmp___22 = abs(searchdir);
#line 1633
    searchdir /= tmp___22;
    }
#line 1635
    goto switch_break___0;
    case_12: /* CIL Label */ 
#line 1637
    refresh___0 = 2;
#line 1638
    row = lastrow / 2;
#line 1639
    goto switch_break___0;
    case_22: /* CIL Label */ 
#line 1642
    pos = botpos;
#line 1643
    if (botrow <= lastrow) {
#line 1644
      row = botrow;
    } else {
#line 1646
      row = 2;
    }
#line 1647
    refresh___0 = 1;
#line 1648
    goto switch_break___0;
    case_4214: /* CIL Label */ 
#line 1650
    pos = toppos;
#line 1651
    row = lastrow - 1;
#line 1652
    refresh___0 = 1;
#line 1653
    goto switch_break___0;
    case_258: /* CIL Label */ 
    case_14: /* CIL Label */ 
    case_110: /* CIL Label */ 
    case_106: /* CIL Label */ 
#line 1659
    if (tnum < 0) {
#line 1660
      tnum = 1;
    }
    {
#line 1661
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 1661
      if (! (tnum > 0)) {
#line 1661
        goto while_break___17;
      }
      {
#line 1662
      tpos = pos;
#line 1663
      next_mline(& tpos, fm, fb, fa, ci.merger, mmode);
      }
#line 1664
      if ((unsigned int )(ci.merger + tpos.p.m)->type != 0U) {
#line 1665
        pos = tpos;
#line 1666
        row ++;
      }
#line 1661
      tnum --;
    }
    while_break___17: /* CIL Label */ ;
    }
#line 1669
    goto switch_break___0;
    case_78: /* CIL Label */ 
#line 1672
    tpos = pos;
#line 1672
    row --;
    {
#line 1673
    while (1) {
      while_continue___18: /* CIL Label */ ;
      {
#line 1674
      pos = tpos;
#line 1674
      row ++;
#line 1675
      next_mline(& tpos, fm, fb, fa, ci.merger, mmode);
      }
#line 1673
      if (pos.state != 0) {
#line 1673
        if (! ((unsigned int )(ci.merger + tpos.p.m)->type != 0U)) {
#line 1673
          goto while_break___18;
        }
      } else {
#line 1673
        goto while_break___18;
      }
    }
    while_break___18: /* CIL Label */ ;
    }
#line 1677
    tpos = pos;
#line 1677
    row --;
    {
#line 1678
    while (1) {
      while_continue___19: /* CIL Label */ ;
      {
#line 1679
      pos = tpos;
#line 1679
      row ++;
#line 1680
      next_mline(& tpos, fm, fb, fa, ci.merger, mmode);
      }
#line 1678
      if (pos.state == 0) {
#line 1678
        if (! ((unsigned int )(ci.merger + tpos.p.m)->type != 0U)) {
#line 1678
          goto while_break___19;
        }
      } else {
#line 1678
        goto while_break___19;
      }
    }
    while_break___19: /* CIL Label */ ;
    }
#line 1683
    goto switch_break___0;
    case_80: /* CIL Label */ 
#line 1686
    tpos = pos;
#line 1686
    row ++;
    {
#line 1687
    while (1) {
      while_continue___20: /* CIL Label */ ;
      {
#line 1688
      pos = tpos;
#line 1688
      row --;
#line 1689
      prev_mline(& tpos, fm, fb, fa, ci.merger, mmode);
      }
#line 1687
      if (tpos.state == 0) {
#line 1687
        if (! (tpos.p.m >= 0)) {
#line 1687
          goto while_break___20;
        }
      } else {
#line 1687
        goto while_break___20;
      }
    }
    while_break___20: /* CIL Label */ ;
    }
#line 1691
    tpos = pos;
#line 1691
    row ++;
    {
#line 1692
    while (1) {
      while_continue___21: /* CIL Label */ ;
      {
#line 1693
      pos = tpos;
#line 1693
      row --;
#line 1694
      prev_mline(& tpos, fm, fb, fa, ci.merger, mmode);
      }
#line 1692
      if (tpos.state != 0) {
#line 1692
        if (! (tpos.p.m >= 0)) {
#line 1692
          goto while_break___21;
        }
      } else {
#line 1692
        goto while_break___21;
      }
    }
    while_break___21: /* CIL Label */ ;
    }
#line 1696
    goto switch_break___0;
    case_259: /* CIL Label */ 
    case_16: /* CIL Label */ 
    case_112: /* CIL Label */ 
    case_107: /* CIL Label */ 
#line 1702
    if (tnum < 0) {
#line 1703
      tnum = 1;
    }
    {
#line 1704
    while (1) {
      while_continue___22: /* CIL Label */ ;
#line 1704
      if (! (tnum > 0)) {
#line 1704
        goto while_break___22;
      }
      {
#line 1705
      tpos = pos;
#line 1706
      prev_mline(& tpos, fm, fb, fa, ci.merger, mmode);
      }
#line 1707
      if (tpos.p.m >= 0) {
#line 1708
        pos = tpos;
#line 1709
        row --;
      }
#line 1704
      tnum --;
    }
    while_break___22: /* CIL Label */ ;
    }
#line 1712
    goto switch_break___0;
    case_104: /* CIL Label */ 
    case_260: /* CIL Label */ 
#line 1717
    curs.target = curs.col - 1;
#line 1718
    if (curs.target < 0) {
      {
#line 1720
      tpos = pos;
#line 1721
      prev_mline(& tpos, fm, fb, fa, ci.merger, mmode);
      }
#line 1722
      if (tpos.p.m >= 0) {
#line 1723
        pos = tpos;
#line 1724
        row --;
#line 1725
        curs.pos = pos.p;
#line 1726
        curs.target = -1;
      } else {
#line 1728
        curs.target = 0;
      }
    }
#line 1730
    goto switch_break___0;
    case_108: /* CIL Label */ 
    case_261: /* CIL Label */ 
#line 1734
    if (curs.width >= 0) {
#line 1735
      curs.target = curs.col + curs.width;
    } else {
      {
#line 1738
      tpos = pos;
#line 1739
      next_mline(& tpos, fm, fb, fa, ci.merger, mmode);
      }
#line 1740
      if ((unsigned int )(ci.merger + tpos.p.m)->type != 0U) {
#line 1741
        pos = tpos;
#line 1742
        curs.pos = pos.p;
#line 1743
        row ++;
#line 1744
        curs.target = 0;
      }
    }
#line 1747
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
    case_94: /* CIL Label */ 
#line 1752
    curs.target = 0;
#line 1753
    goto switch_break___0;
    case_5: /* CIL Label */ 
    case_36: /* CIL Label */ 
#line 1757
    curs.target = 1000;
#line 1758
    goto switch_break___0;
    case_79: /* CIL Label */ 
#line 1761
    curs.alt = ! curs.alt;
#line 1762
    if (curs.alt) {
#line 1762
      if (mode == 12) {
#line 1763
        mmode = 3;
      } else {
#line 1765
        mmode = mode;
      }
    } else {
#line 1765
      mmode = mode;
    }
#line 1766
    goto switch_break___0;
    case_97: /* CIL Label */ 
#line 1769
    mode = 2;
#line 1769
    modename = (char *)"after";
#line 1769
    modehelp = after_help;
#line 1770
    mmode = mode;
#line 1770
    curs.alt = 0;
#line 1771
    refresh___0 = 3;
#line 1772
    goto switch_break___0;
    case_98: /* CIL Label */ 
#line 1774
    mode = 1;
#line 1774
    modename = (char *)"before";
#line 1774
    modehelp = before_help;
#line 1775
    mmode = mode;
#line 1775
    curs.alt = 0;
#line 1776
    refresh___0 = 3;
#line 1777
    goto switch_break___0;
    case_111: /* CIL Label */ 
#line 1779
    mode = 4;
#line 1779
    modename = (char *)"original";
#line 1779
    modehelp = orig_help;
#line 1780
    mmode = mode;
#line 1780
    curs.alt = 0;
#line 1781
    refresh___0 = 3;
#line 1782
    goto switch_break___0;
    case_114: /* CIL Label */ 
#line 1784
    mode = 8;
#line 1784
    modename = (char *)"result";
#line 1784
    modehelp = result_help;
#line 1785
    mmode = mode;
#line 1785
    curs.alt = 0;
#line 1786
    refresh___0 = 3;
#line 1787
    goto switch_break___0;
    case_100: /* CIL Label */ 
#line 1789
    mode = 3;
#line 1789
    modename = (char *)"diff";
#line 1789
    modehelp = diff_help;
#line 1790
    mmode = mode;
#line 1790
    curs.alt = 0;
#line 1791
    refresh___0 = 3;
#line 1792
    goto switch_break___0;
    case_109: /* CIL Label */ 
#line 1794
    mode = 12;
#line 1794
    modename = (char *)"merge";
#line 1794
    modehelp = merge_help;
#line 1795
    mmode = mode;
#line 1795
    curs.alt = 0;
#line 1796
    refresh___0 = 3;
#line 1797
    goto switch_break___0;
    case_124: /* CIL Label */ 
#line 1800
    mode = 15;
#line 1800
    modename = (char *)"sidebyside";
#line 1800
    modehelp = sidebyside_help;
#line 1801
    mmode = mode;
#line 1801
    curs.alt = 0;
#line 1802
    refresh___0 = 3;
#line 1803
    goto switch_break___0;
    case_72: /* CIL Label */ 
#line 1806
    if (start > 0) {
#line 1807
      start --;
    }
#line 1808
    curs.target = start + 1;
#line 1809
    refresh___0 = 1;
#line 1810
    goto switch_break___0;
    case_76: /* CIL Label */ 
#line 1812
    if (start < cols) {
#line 1813
      start ++;
    }
#line 1814
    curs.target = start + 1;
#line 1815
    refresh___0 = 1;
#line 1816
    goto switch_break___0;
    case_60: /* CIL Label */ 
    {
#line 1819
    prev_melmnt(& tvpos.p, fm, fb, fa, ci.merger);
    }
#line 1820
    if (tvpos.p.m >= 0) {
#line 1821
      vpos = tvpos;
    }
#line 1822
    goto switch_break___0;
    case_62: /* CIL Label */ 
    {
#line 1824
    next_melmnt(& tvpos.p, fm, fb, fa, ci.merger);
    }
#line 1825
    if ((unsigned int )(ci.merger + tvpos.p.m)->type != 0U) {
#line 1826
      vpos = tvpos;
    }
#line 1827
    goto switch_break___0;
    case_63: /* CIL Label */ 
    {
#line 1830
    help_window(modehelp, merge_window_help);
#line 1831
    refresh___0 = 2;
    }
#line 1832
    goto switch_break___0;
    case_410: /* CIL Label */ 
#line 1835
    refresh___0 = 2;
#line 1836
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 1839
    if (meta___0 == 8192) {
#line 1840
      if ((unsigned long )anchor == (unsigned long )((void *)0)) {
#line 1840
        goto _L___2;
      } else {
        {
#line 1840
        tmp___24 = same_mpos(anchor->pos, pos);
        }
#line 1840
        if (tmp___24) {
#line 1840
          if (anchor->searchlen != searchlen) {
#line 1840
            goto _L___2;
          } else {
            {
#line 1840
            tmp___25 = same_mp(anchor->curs.pos, curs.pos);
            }
#line 1840
            if (! tmp___25) {
              _L___2: /* CIL Label */ 
              {
#line 1844
              tmp___23 = xmalloc((int )sizeof(*a___1));
#line 1844
              a___1 = (struct search_anchor *)tmp___23;
#line 1845
              a___1->pos = pos;
#line 1846
              a___1->row = row;
#line 1847
              a___1->start = start;
#line 1848
              a___1->curs = curs;
#line 1849
              a___1->searchlen = searchlen;
#line 1850
              a___1->notfound = search_notfound;
#line 1851
              a___1->next = anchor;
#line 1852
              anchor = a___1;
              }
            }
          }
        } else {
#line 1840
          goto _L___2;
        }
      }
    } else {
      {
#line 1855
      while (1) {
        while_continue___23: /* CIL Label */ ;
#line 1855
        if (! anchor) {
#line 1855
          goto while_break___23;
        }
        {
#line 1856
        a___2 = anchor;
#line 1857
        anchor = a___2->next;
#line 1858
        free((void *)a___2);
        }
      }
      while_break___23: /* CIL Label */ ;
      }
    }
#line 1861
    if (refresh___0 == 3) {
      {
#line 1865
      tpos = pos;
#line 1866
      prev_mline(& tpos, fm, fb, fa, ci.merger, mmode);
      }
#line 1867
      if (tpos.p.m >= 0) {
#line 1868
        pos = tpos;
      }
      {
#line 1869
      tpos = pos;
#line 1870
      next_mline(& tpos, fm, fb, fa, ci.merger, mmode);
      }
#line 1871
      if ((unsigned int )(ci.merger + tpos.p.m)->type != 0U) {
#line 1872
        pos = tpos;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1877 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/vpatch.c"
static void show_merge(char *origname , FILE *patch , int reverse , int is_merge ,
                       char *before , char *after ) 
{ 
  struct plist p ;
  long tmp ;

  {
#line 1882
  p.file = origname;
#line 1883
  if (patch) {
    {
#line 1884
    p.start = 0U;
#line 1885
    fseek(patch, 0L, 2);
#line 1886
    tmp = ftell(patch);
#line 1886
    p.end = (unsigned int )tmp;
#line 1887
    fseek(patch, 0L, 0);
    }
  }
  {
#line 1889
  p.calced = 0;
#line 1890
  p.is_merge = is_merge;
#line 1891
  p.before = before;
#line 1892
  p.after = after;
#line 1894
  freopen((char const   */* __restrict  */)"/dev/null", (char const   */* __restrict  */)"w",
          (FILE */* __restrict  */)stderr);
#line 1895
  merge_window(& p, patch, reverse);
  }
#line 1896
  return;
}
}
#line 1898 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/vpatch.c"
static void calc_one(struct plist *pl , FILE *f , int reverse ) 
{ 
  struct stream s1 ;
  struct stream s2 ;
  struct stream s ;
  struct stream tmp ;
  struct stream sf ;
  int tmp___0 ;
  struct file ff ;
  struct file fp1 ;
  struct file fp2 ;
  struct csl *csl1 ;
  struct csl *csl2 ;
  struct ci ci ;

  {
  {
#line 1901
  tmp = load_segment(f, pl->start, pl->end);
#line 1901
  s = tmp;
  }
#line 1903
  if (pl->is_merge) {
#line 1904
    if (reverse) {
      {
#line 1905
      split_merge(s, & sf, & s2, & s1);
      }
    } else {
      {
#line 1907
      split_merge(s, & sf, & s1, & s2);
      }
    }
#line 1908
    pl->chunks = 0;
  } else {
    {
#line 1910
    sf = load_file(pl->file);
    }
#line 1911
    if (reverse) {
      {
#line 1912
      pl->chunks = split_patch(s, & s2, & s1);
      }
    } else {
      {
#line 1914
      pl->chunks = split_patch(s, & s1, & s2);
      }
    }
  }
#line 1916
  if ((unsigned long )sf.body == (unsigned long )((void *)0)) {
#line 1917
    tmp___0 = -1;
#line 1917
    pl->conflicts = tmp___0;
#line 1917
    pl->wiggles = tmp___0;
  } else
#line 1916
  if ((unsigned long )s1.body == (unsigned long )((void *)0)) {
#line 1917
    tmp___0 = -1;
#line 1917
    pl->conflicts = tmp___0;
#line 1917
    pl->wiggles = tmp___0;
  } else
#line 1916
  if ((unsigned long )s1.body == (unsigned long )((void *)0)) {
#line 1917
    tmp___0 = -1;
#line 1917
    pl->conflicts = tmp___0;
#line 1917
    pl->wiggles = tmp___0;
  } else {
    {
#line 1922
    ff = split_stream(sf, 1);
#line 1923
    fp1 = split_stream(s1, 1);
#line 1924
    fp2 = split_stream(s2, 1);
    }
#line 1925
    if (pl->chunks) {
      {
#line 1926
      csl1 = pdiff(ff, fp1, pl->chunks);
      }
    } else {
      {
#line 1928
      csl1 = diff(ff, fp1);
      }
    }
    {
#line 1929
    csl2 = diff(fp1, fp2);
#line 1930
    ci = make_merger(ff, fp1, fp2, csl1, csl2, 0, 1, 0);
#line 1931
    pl->wiggles = ci.wiggles;
#line 1932
    pl->conflicts = ci.conflicts;
#line 1933
    free((void *)csl1);
#line 1934
    free((void *)csl2);
#line 1935
    free((void *)ff.list);
#line 1936
    free((void *)fp1.list);
#line 1937
    free((void *)fp2.list);
    }
  }
  {
#line 1940
  free((void *)s1.body);
#line 1941
  free((void *)s2.body);
#line 1942
  free((void *)s.body);
#line 1943
  free((void *)sf.body);
#line 1944
  pl->calced = 1;
  }
#line 1945
  return;
}
}
#line 1947 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/vpatch.c"
static int get_prev(int pos , struct plist *pl , int n , int mode ) 
{ 
  int found ;

  {
#line 1949
  found = 0;
#line 1950
  if (pos == -1) {
#line 1951
    return (pos);
  }
  {
#line 1952
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1953
    if ((pl + pos)->prev == -1) {
#line 1954
      return ((pl + pos)->parent);
    }
#line 1955
    pos = (pl + pos)->prev;
    {
#line 1956
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1956
      if ((pl + pos)->open) {
#line 1956
        if (! ((pl + pos)->last >= 0)) {
#line 1956
          goto while_break___0;
        }
      } else {
#line 1956
        goto while_break___0;
      }
#line 1958
      pos = (pl + pos)->last;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1959
    if ((pl + pos)->last >= 0) {
#line 1961
      found = 1;
    } else
#line 1962
    if (mode == 0) {
#line 1963
      found = 1;
    } else
#line 1964
    if (mode <= 1) {
#line 1964
      if ((pl + pos)->wiggles > 0) {
#line 1965
        found = 1;
      } else {
#line 1964
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1966
    if (mode <= 2) {
#line 1966
      if ((pl + pos)->conflicts > 0) {
#line 1967
        found = 1;
      }
    }
#line 1952
    if (pos >= 0) {
#line 1952
      if (! (! found)) {
#line 1952
        goto while_break;
      }
    } else {
#line 1952
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1969
  return (pos);
}
}
#line 1972 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/vpatch.c"
static int get_next(int pos , struct plist *pl , int n , int mode , FILE *f , int reverse ) 
{ 
  int found ;

  {
#line 1975
  found = 0;
#line 1976
  if (pos == -1) {
#line 1977
    return (pos);
  }
  {
#line 1978
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1979
    if ((pl + pos)->open) {
#line 1980
      if (pos + 1 < n) {
#line 1981
        pos ++;
      } else {
#line 1983
        return (-1);
      }
    } else {
      {
#line 1985
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1985
        if (pos >= 0) {
#line 1985
          if (! ((pl + pos)->next == -1)) {
#line 1985
            goto while_break___0;
          }
        } else {
#line 1985
          goto while_break___0;
        }
#line 1986
        pos = (pl + pos)->parent;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1987
      if (pos >= 0) {
#line 1988
        pos = (pl + pos)->next;
      }
    }
#line 1990
    if (pos < 0) {
#line 1991
      return (-1);
    }
#line 1992
    if ((pl + pos)->calced == 0) {
#line 1992
      if ((pl + pos)->end) {
        {
#line 1993
        calc_one(pl + pos, f, reverse);
        }
      }
    }
#line 1994
    if ((pl + pos)->last >= 0) {
#line 1996
      found = 1;
    } else
#line 1997
    if (mode == 0) {
#line 1998
      found = 1;
    } else
#line 1999
    if (mode <= 1) {
#line 1999
      if ((pl + pos)->wiggles > 0) {
#line 2000
        found = 1;
      } else {
#line 1999
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 2001
    if (mode <= 2) {
#line 2001
      if ((pl + pos)->conflicts > 0) {
#line 2002
        found = 1;
      }
    }
#line 1978
    if (pos >= 0) {
#line 1978
      if (! (! found)) {
#line 1978
        goto while_break;
      }
    } else {
#line 1978
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2004
  return (pos);
}
}
#line 2007 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/vpatch.c"
static void draw_one(int row , struct plist *pl , FILE *f , int reverse ) 
{ 
  char hdr[12] ;
  int tmp ;
  int tmp___0 ;

  {
#line 2010
  hdr[0] = (char)0;
#line 2012
  if ((unsigned long )pl == (unsigned long )((void *)0)) {
    {
#line 2013
    wmove(stdscr, row, 0);
#line 2014
    wclrtoeol(stdscr);
    }
#line 2015
    return;
  }
#line 2017
  if (pl->calced == 0) {
#line 2017
    if (pl->end) {
      {
#line 2019
      calc_one(pl, f, reverse);
      }
    }
  }
#line 2020
  if (pl->end == 0U) {
    {
#line 2021
    strcpy((char */* __restrict  */)(hdr), (char const   */* __restrict  */)"         ");
    }
  } else {
#line 2023
    if (pl->chunks > 99) {
      {
#line 2024
      strcpy((char */* __restrict  */)(hdr), (char const   */* __restrict  */)"XX");
      }
    } else {
      {
#line 2026
      sprintf((char */* __restrict  */)(hdr), (char const   */* __restrict  */)"%2d",
              pl->chunks);
      }
    }
#line 2027
    if (pl->wiggles > 99) {
      {
#line 2028
      strcpy((char */* __restrict  */)(hdr + 2), (char const   */* __restrict  */)" XX");
      }
    } else {
      {
#line 2030
      sprintf((char */* __restrict  */)(hdr + 2), (char const   */* __restrict  */)" %2d",
              pl->wiggles);
      }
    }
#line 2031
    if (pl->conflicts > 99) {
      {
#line 2032
      strcpy((char */* __restrict  */)(hdr + 5), (char const   */* __restrict  */)" XX ");
      }
    } else {
      {
#line 2034
      sprintf((char */* __restrict  */)(hdr + 5), (char const   */* __restrict  */)" %2d ",
              pl->conflicts);
      }
    }
  }
#line 2036
  if (pl->end) {
    {
#line 2037
    strcpy((char */* __restrict  */)(hdr + 9), (char const   */* __restrict  */)"= ");
    }
  } else
#line 2038
  if (pl->open) {
    {
#line 2039
    strcpy((char */* __restrict  */)(hdr + 9), (char const   */* __restrict  */)"+ ");
    }
  } else {
    {
#line 2041
    strcpy((char */* __restrict  */)(hdr + 9), (char const   */* __restrict  */)"- ");
    }
  }
#line 2043
  if (! pl->end) {
#line 2044
    if (stdscr) {
#line 2044
      stdscr->_attrs = (attr_t )0;
    }
  } else
#line 2045
  if (pl->conflicts) {
#line 2046
    if (stdscr) {
#line 2046
      stdscr->_attrs = (attr_t )a_has_conflicts;
    }
  } else
#line 2047
  if (pl->wiggles) {
#line 2048
    if (stdscr) {
#line 2048
      stdscr->_attrs = (attr_t )a_has_wiggles;
    }
  } else
#line 2050
  if (stdscr) {
#line 2050
    stdscr->_attrs = (attr_t )a_no_wiggles;
  }
  {
#line 2052
  tmp = wmove(stdscr, row, 0);
  }
#line 2052
  if (! (tmp == -1)) {
    {
#line 2052
    waddnstr(stdscr, (char const   *)(hdr), -1);
    }
  }
  {
#line 2053
  tmp___0 = wmove(stdscr, row, 11);
  }
#line 2053
  if (! (tmp___0 == -1)) {
    {
#line 2053
    waddnstr(stdscr, (char const   *)pl->file, -1);
    }
  }
  {
#line 2054
  wclrtoeol(stdscr);
  }
#line 2055
  return;
}
}
#line 2057 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/vpatch.c"
static char *main_help[28]  = 
#line 2057
  {      (char *)"   You are using the \"browse\" mode of wiggle.",      (char *)"This page shows a list of files in a patch together with",      (char *)"the directories that contain them.",      (char *)"A directory is indicated by a \'+\' if the contents are", 
        (char *)"listed or a \'-\' if the contents are hidden.  A file is",      (char *)"indicated by an \'=\'.  Typing <space> or <return> will",      (char *)"expose or hide a directory, and will visit a file.",      (char *)"", 
        (char *)"The three columns of numbers are:",      (char *)"  Ch   The number of patch chunks which applied to",      (char *)"       this file",      (char *)"  Wi   The number of chunks that needed to be wiggled", 
        (char *)"       in to place",      (char *)"  Co   The number of chunks that created an unresolvable",      (char *)"       conflict",      (char *)"Keystrokes recognised in this page are:", 
        (char *)"  ?          Display this help",      (char *)"  SPC        On a directory, toggle hiding of contents",      (char *)"             On file, visit the file",      (char *)"  RTN        Same as SPC", 
        (char *)"  q          Quit program",      (char *)"  n,j,DOWN   Go to next line",      (char *)"  p,k,UP     Go to previous line",      (char *)"", 
        (char *)"  A          list All files",      (char *)"  W          only list files with a wiggle or a conflict",      (char *)"  C          only list files with a conflict",      (char *)((void *)0)};
#line 2089 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/vpatch.c"
static void main_window(struct plist *pl , int n , FILE *f , int reverse ) 
{ 
  int pos ;
  int row ;
  int rows ;
  int cols ;
  int tpos ;
  int i ;
  int refresh___0 ;
  int c ;
  int mode ;
  int tmp ;
  char bb[20] ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 2122
  pos = 0;
#line 2123
  row = 1;
#line 2124
  rows = 0;
#line 2125
  cols = 0;
#line 2127
  refresh___0 = 2;
#line 2128
  c = 0;
#line 2129
  mode = 0;
#line 2131
  freopen((char const   */* __restrict  */)"/dev/null", (char const   */* __restrict  */)"w",
          (FILE */* __restrict  */)stderr);
#line 2132
  term_init();
#line 2133
  pl = sort_patches(pl, & n);
  }
  {
#line 2135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2136
    if (refresh___0 == 2) {
      {
#line 2137
      wclear(stdscr);
      }
#line 2137
      if (stdscr) {
#line 2137
        stdscr->_attrs = (attr_t )0;
      }
      {
#line 2138
      wattr_on(stdscr, 1UL << 21, (void *)0);
#line 2139
      tmp = wmove(stdscr, 0, 0);
      }
#line 2139
      if (! (tmp == -1)) {
        {
#line 2139
        waddnstr(stdscr, "Ch Wi Co Patched Files", -1);
        }
      }
      {
#line 2140
      wmove(stdscr, 2, 0);
#line 2141
      wattr_off(stdscr, 1UL << 21, (void *)0);
#line 2142
      refresh___0 = 1;
      }
    }
#line 2144
    if (row < 1) {
#line 2145
      refresh___0 = 1;
    } else
#line 2144
    if (row >= rows) {
#line 2145
      refresh___0 = 1;
    }
#line 2146
    if (refresh___0) {
#line 2147
      refresh___0 = 0;
#line 2148
      if (stdscr) {
#line 2148
        rows = (int )stdscr->_maxy + 1;
      } else {
#line 2148
        rows = -1;
      }
#line 2148
      if (stdscr) {
#line 2148
        cols = (int )stdscr->_maxx + 1;
      } else {
#line 2148
        cols = -1;
      }
#line 2149
      cols = cols;
#line 2150
      if (row >= rows + 3) {
#line 2151
        row = (rows + 1) / 2;
      }
#line 2152
      if (row >= rows) {
#line 2153
        row = rows - 1;
      }
#line 2154
      tpos = pos;
#line 2155
      i = row;
      {
#line 2155
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2155
        if (! (i > 1)) {
#line 2155
          goto while_break___0;
        }
        {
#line 2156
        tpos = get_prev(tpos, pl, n, mode);
        }
#line 2157
        if (tpos == -1) {
#line 2158
          row = (row - i) + 1;
#line 2159
          goto while_break___0;
        }
#line 2155
        i --;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2163
      tpos = pos;
#line 2164
      i = row;
      {
#line 2164
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2164
        if (! (i >= 1)) {
#line 2164
          goto while_break___1;
        }
        {
#line 2165
        draw_one(i, pl + tpos, f, reverse);
#line 2166
        tpos = get_prev(tpos, pl, n, mode);
#line 2164
        i --;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 2168
      tpos = pos;
#line 2169
      i = row + 1;
      {
#line 2169
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 2169
        if (! (i < rows)) {
#line 2169
          goto while_break___2;
        }
        {
#line 2170
        tpos = get_next(tpos, pl, n, mode, f, reverse);
        }
#line 2171
        if (tpos >= 0) {
          {
#line 2172
          draw_one(i, pl + tpos, f, reverse);
          }
        } else {
          {
#line 2174
          draw_one(i, (struct plist *)((void *)0), f, reverse);
          }
        }
#line 2169
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    {
#line 2178
    sprintf((char */* __restrict  */)(bb), (char const   */* __restrict  */)"%d",
            c);
#line 2179
    tmp___0 = wmove(stdscr, 0, 70);
    }
#line 2179
    if (! (tmp___0 == -1)) {
      {
#line 2179
      waddnstr(stdscr, (char const   *)(bb), -1);
      }
    }
    {
#line 2180
    wclrtoeol(stdscr);
#line 2182
    wmove(stdscr, row, 9);
#line 2183
    c = wgetch(stdscr);
    }
    {
#line 2189
    if (c == 258) {
#line 2189
      goto case_258;
    }
#line 2189
    if (c == 14) {
#line 2189
      goto case_258;
    }
#line 2189
    if (c == 78) {
#line 2189
      goto case_258;
    }
#line 2189
    if (c == 110) {
#line 2189
      goto case_258;
    }
#line 2189
    if (c == 106) {
#line 2189
      goto case_258;
    }
#line 2200
    if (c == 259) {
#line 2200
      goto case_259;
    }
#line 2200
    if (c == 16) {
#line 2200
      goto case_259;
    }
#line 2200
    if (c == 80) {
#line 2200
      goto case_259;
    }
#line 2200
    if (c == 112) {
#line 2200
      goto case_259;
    }
#line 2200
    if (c == 107) {
#line 2200
      goto case_259;
    }
#line 2209
    if (c == 13) {
#line 2209
      goto case_13;
    }
#line 2209
    if (c == 32) {
#line 2209
      goto case_13;
    }
#line 2219
    if (c == 27) {
#line 2219
      goto case_27;
    }
#line 2225
    if (c == 113) {
#line 2225
      goto case_113;
    }
#line 2228
    if (c == 65) {
#line 2228
      goto case_65;
    }
#line 2231
    if (c == 87) {
#line 2231
      goto case_87;
    }
#line 2234
    if (c == 67) {
#line 2234
      goto case_67;
    }
#line 2238
    if (c == 63) {
#line 2238
      goto case_63;
    }
#line 2243
    if (c == 410) {
#line 2243
      goto case_410;
    }
#line 2184
    goto switch_break;
    case_258: /* CIL Label */ 
    case_14: /* CIL Label */ 
    case_78: /* CIL Label */ 
    case_110: /* CIL Label */ 
    case_106: /* CIL Label */ 
    {
#line 2190
    tpos = get_next(pos, pl, n, mode, f, reverse);
    }
#line 2191
    if (tpos >= 0) {
#line 2192
      pos = tpos;
#line 2193
      row ++;
    }
#line 2195
    goto switch_break;
    case_259: /* CIL Label */ 
    case_16: /* CIL Label */ 
    case_80: /* CIL Label */ 
    case_112: /* CIL Label */ 
    case_107: /* CIL Label */ 
    {
#line 2201
    tpos = get_prev(pos, pl, n, mode);
    }
#line 2202
    if (tpos >= 0) {
#line 2203
      pos = tpos;
#line 2204
      row --;
    }
#line 2206
    goto switch_break;
    case_13: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 2210
    if ((pl + pos)->end == 0U) {
#line 2211
      (pl + pos)->open = ! (pl + pos)->open;
#line 2212
      refresh___0 = 1;
    } else {
      {
#line 2215
      merge_window(pl + pos, f, reverse);
#line 2216
      refresh___0 = 2;
      }
    }
#line 2218
    goto switch_break;
    case_27: /* CIL Label */ 
    {
#line 2220
    tmp___1 = wmove(stdscr, 0, 70);
    }
#line 2220
    if (! (tmp___1 == -1)) {
      {
#line 2220
      waddnstr(stdscr, "ESC...", -1);
      }
    }
    {
#line 2220
    wclrtoeol(stdscr);
#line 2221
    c = wgetch(stdscr);
    }
    {
#line 2222
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 2224
    goto switch_break;
    case_113: /* CIL Label */ 
#line 2226
    return;
    case_65: /* CIL Label */ 
#line 2229
    mode = 0;
#line 2229
    refresh___0 = 1;
#line 2230
    goto switch_break;
    case_87: /* CIL Label */ 
#line 2232
    mode = 1;
#line 2232
    refresh___0 = 1;
#line 2233
    goto switch_break;
    case_67: /* CIL Label */ 
#line 2235
    mode = 2;
#line 2235
    refresh___0 = 1;
#line 2236
    goto switch_break;
    case_63: /* CIL Label */ 
    {
#line 2239
    help_window(main_help, (char **)((void *)0));
#line 2240
    refresh___0 = 2;
    }
#line 2241
    goto switch_break;
    case_410: /* CIL Label */ 
#line 2244
    refresh___0 = 2;
#line 2245
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 2250 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/vpatch.c"
static void catch(int sig ) 
{ 


  {
#line 2252
  if (sig == 2) {
    {
#line 2253
    signal(sig, & catch);
    }
#line 2254
    return;
  }
  {
#line 2256
  nocbreak();
#line 2257
  nl();
#line 2258
  endwin();
#line 2259
  printf((char const   */* __restrict  */)"Died on signal %d\n", sig);
#line 2260
  exit(2);
  }
}
}
#line 2266 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/vpatch.c"
static int init_done  =    0;
#line 2263 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/vpatch.c"
static void term_init(void) 
{ 
  _Bool tmp ;

  {
#line 2268
  if (init_done) {
#line 2269
    return;
  }
  {
#line 2270
  init_done = 1;
#line 2272
  signal(2, & catch);
#line 2273
  signal(3, & catch);
#line 2274
  signal(15, & catch);
#line 2275
  signal(7, & catch);
#line 2276
  signal(11, & catch);
#line 2278
  initscr();
#line 2278
  cbreak();
#line 2278
  noecho();
#line 2279
  start_color();
#line 2280
  use_default_colors();
#line 2281
  tmp = has_colors();
  }
#line 2281
  if (tmp) {
    {
#line 2291
    init_pair((short)1, (short)1, (short)-1);
#line 2292
    a_delete = (unsigned int )(1UL << 8);
#line 2293
    init_pair((short)2, (short)2, (short)-1);
#line 2294
    a_added = (unsigned int )(2UL << 8);
#line 2295
    a_common = 0U;
#line 2296
    init_pair((short)3, (short)7, (short)2);
#line 2297
    a_sep = (unsigned int )(3UL << 8);
#line 2297
    a_sep = (unsigned int )(1UL << 16);
#line 2298
    init_pair((short)4, (short)-1, (short)3);
#line 2299
    a_void = (unsigned int )(4UL << 8);
#line 2300
    init_pair((short)5, (short)4, (short)-1);
#line 2301
    a_unmatched = (unsigned int )(5UL << 8);
#line 2302
    init_pair((short)6, (short)6, (short)-1);
#line 2303
    a_extra = (unsigned int )(6UL << 8);
#line 2305
    init_pair((short)7, (short)0, (short)6);
#line 2306
    a_already = (unsigned int )(7UL << 8);
#line 2308
    a_has_conflicts = a_delete;
#line 2309
    a_has_wiggles = a_added;
#line 2310
    a_no_wiggles = a_unmatched;
    }
  } else {
#line 2282
    a_delete = (unsigned int )(1UL << 17);
#line 2283
    a_added = (unsigned int )(1UL << 21);
#line 2284
    a_common = 0U;
#line 2285
    a_sep = (unsigned int )(1UL << 16);
#line 2286
    a_already = (unsigned int )(1UL << 16);
#line 2287
    a_has_conflicts = (unsigned int )(1UL << 17);
#line 2288
    a_has_wiggles = (unsigned int )(1UL << 21);
#line 2289
    a_no_wiggles = 0U;
  }
  {
#line 2312
  nonl();
#line 2312
  intrflush(stdscr, (_Bool)0);
#line 2312
  keypad(stdscr, (_Bool)1);
#line 2313
  mousemask((mmask_t )((8L << 24) - 1L), (mmask_t *)((void *)0));
  }
#line 2314
  return;
}
}
#line 2316 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/vpatch.c"
int vpatch(int argc , char **argv , int patch , int strip , int reverse , int replace ) 
{ 
  FILE *in ;
  FILE *f ;
  struct plist *pl ;
  int num_patches ;
  int tmp ;
  int tmp___0 ;
  __off_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *origname ;
  char *tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;

  {
  {
#line 2347
  if (argc == 0) {
#line 2347
    goto case_0;
  }
#line 2370
  if (argc == 1) {
#line 2370
    goto case_1;
  }
#line 2392
  if (argc == 2) {
#line 2392
    goto case_2;
  }
#line 2400
  if (argc == 3) {
#line 2400
    goto case_3;
  }
#line 2343
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 2344
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: too many file names given.\n",
          Cmd);
#line 2345
  exit(1);
  }
  case_0: /* CIL Label */ 
  {
#line 2348
  tmp___0 = fileno(stdin);
#line 2348
  tmp___1 = lseek(tmp___0, 0L, 1);
  }
#line 2348
  if (tmp___1 == -1L) {
    {
#line 2350
    f = tmpfile();
    }
#line 2351
    if (! f) {
      {
#line 2352
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Cannot create temp file\n",
              Cmd);
#line 2353
      exit(1);
      }
    }
    {
#line 2355
    pl = parse_patch(stdin, f, & num_patches);
#line 2356
    in = f;
    }
  } else {
    {
#line 2358
    pl = parse_patch(stdin, (FILE *)((void *)0), & num_patches);
#line 2359
    tmp = dup(0);
#line 2359
    in = fdopen(tmp, "r");
    }
  }
  {
#line 2362
  dup2(2, 0);
#line 2363
  tmp___2 = set_prefix(pl, num_patches, strip);
  }
#line 2363
  if (tmp___2 == 0) {
    {
#line 2364
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: aborting\n",
            Cmd);
#line 2365
    exit(2);
    }
  }
  {
#line 2367
  main_window(pl, num_patches, in, reverse);
  }
#line 2368
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 2371
  f = fopen((char const   */* __restrict  */)*(argv + 0), (char const   */* __restrict  */)"r");
  }
#line 2372
  if (! f) {
    {
#line 2373
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: cannot open %s\n",
            Cmd, *(argv + 0));
#line 2374
    exit(1);
    }
  }
#line 2376
  if (patch) {
    {
#line 2377
    pl = parse_patch(f, (FILE *)((void *)0), & num_patches);
#line 2378
    tmp___3 = set_prefix(pl, num_patches, strip);
    }
#line 2378
    if (tmp___3 == 0) {
      {
#line 2379
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: aborting\n",
              Cmd);
#line 2380
      exit(2);
      }
    }
    {
#line 2382
    main_window(pl, num_patches, f, reverse);
    }
  } else {
    {
#line 2383
    tmp___6 = strlen((char const   *)*(argv + 0));
    }
#line 2383
    if (tmp___6 > 4UL) {
      {
#line 2383
      tmp___7 = strlen((char const   *)*(argv + 0));
#line 2383
      tmp___8 = strcmp((char const   *)((*(argv + 0) + tmp___7) - 4), ".rej");
      }
#line 2383
      if (tmp___8 == 0) {
        {
#line 2385
        tmp___4 = strdup((char const   *)*(argv + 0));
#line 2385
        origname = tmp___4;
#line 2386
        tmp___5 = strlen((char const   *)origname);
#line 2386
        *(origname + (tmp___5 - 4UL)) = (char )'\000';
#line 2387
        show_merge(origname, f, reverse, 0, (char *)((void *)0), (char *)((void *)0));
        }
      } else {
        {
#line 2389
        show_merge(*(argv + 0), f, reverse, 1, (char *)((void *)0), (char *)((void *)0));
        }
      }
    } else {
      {
#line 2389
      show_merge(*(argv + 0), f, reverse, 1, (char *)((void *)0), (char *)((void *)0));
      }
    }
  }
#line 2391
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 2393
  f = fopen((char const   */* __restrict  */)*(argv + 1), (char const   */* __restrict  */)"r");
  }
#line 2394
  if (! f) {
    {
#line 2395
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: cannot open %s\n",
            Cmd, *(argv + 0));
#line 2396
    exit(1);
    }
  }
  {
#line 2398
  show_merge(*(argv + 0), f, reverse, 0, (char *)((void *)0), (char *)((void *)0));
  }
#line 2399
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 2401
  show_merge(*(argv + 0), (FILE *)((void *)0), reverse, 1, *(argv + 1), *(argv + 2));
  }
#line 2402
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 2405
  nocbreak();
#line 2406
  nl();
#line 2407
  endwin();
#line 2408
  exit(0);
  }
}
}
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 34 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/extract.c"
static void skip_eol(char **cp , char *end ) 
{ 
  char *c ;

  {
#line 36
  c = *cp;
  {
#line 37
  while (1) {
    while_continue: /* CIL Label */ ;
#line 37
    if ((unsigned long )c < (unsigned long )end) {
#line 37
      if (! ((int )*c != 10)) {
#line 37
        goto while_break;
      }
    } else {
#line 37
      goto while_break;
    }
#line 38
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 39
  if ((unsigned long )c < (unsigned long )end) {
#line 40
    c ++;
  }
#line 41
  *cp = c;
#line 42
  return;
}
}
#line 47 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/extract.c"
static void copyline(struct stream *s , char **cp , char *end ) 
{ 
  char *from ;
  char *to ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 49
  from = *cp;
#line 50
  to = s->body + s->len;
  {
#line 52
  while (1) {
    while_continue: /* CIL Label */ ;
#line 52
    if ((unsigned long )from < (unsigned long )end) {
#line 52
      if (! ((int )*from != 10)) {
#line 52
        goto while_break;
      }
    } else {
#line 52
      goto while_break;
    }
#line 53
    tmp = to;
#line 53
    to ++;
#line 53
    tmp___0 = from;
#line 53
    from ++;
#line 53
    *tmp = *tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 54
  if ((unsigned long )from < (unsigned long )end) {
#line 55
    tmp___1 = to;
#line 55
    to ++;
#line 55
    tmp___2 = from;
#line 55
    from ++;
#line 55
    *tmp___1 = *tmp___2;
  }
#line 56
  s->len = (int )(to - s->body);
#line 57
  *cp = from;
#line 58
  return;
}
}
#line 60 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/extract.c"
int split_patch(struct stream f , struct stream *f1 , struct stream *f2 ) 
{ 
  struct stream r1 ;
  struct stream r2 ;
  int chunks ;
  char *cp ;
  char *end ;
  int state ;
  int acnt ;
  int bcnt ;
  int a ;
  int b ;
  int c ;
  int d ;
  int lineno ;
  char before[100] ;
  char after[100] ;
  char *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int ok ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char buf[20] ;
  char buf___0[20] ;
  char *cp2 ;

  {
  {
#line 63
  chunks = 0;
#line 65
  state = 0;
#line 66
  acnt = 0;
#line 66
  bcnt = 0;
#line 68
  lineno = 0;
#line 71
  tmp = (char *)((void *)0);
#line 71
  f2->body = tmp;
#line 71
  f1->body = tmp;
#line 73
  tmp___0 = xmalloc(f.len);
#line 73
  r1.body = (char *)tmp___0;
#line 74
  tmp___1 = xmalloc(f.len);
#line 74
  r2.body = (char *)tmp___1;
#line 75
  r2.len = 0;
#line 75
  r1.len = r2.len;
#line 77
  cp = f.body;
#line 78
  end = f.body + f.len;
  }
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (! ((unsigned long )cp < (unsigned long )end)) {
#line 79
      goto while_break;
    }
#line 86
    lineno ++;
    {
#line 88
    if (state == 0) {
#line 88
      goto case_0;
    }
#line 132
    if (state == 1) {
#line 132
      goto case_1;
    }
#line 146
    if (state == 2) {
#line 146
      goto case_2;
    }
#line 160
    if (state == 3) {
#line 160
      goto case_3;
    }
#line 87
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 89
    tmp___8 = sscanf((char const   */* __restrict  */)cp, (char const   */* __restrict  */)"@@ -%s +%s @@",
                     before, after);
    }
#line 89
    if (tmp___8 == 2) {
      {
#line 90
      ok = 1;
#line 91
      tmp___3 = sscanf((char const   */* __restrict  */)(before), (char const   */* __restrict  */)"%d,%d",
                       & a, & b);
      }
#line 91
      if (tmp___3 == 2) {
#line 92
        acnt = b;
      } else {
        {
#line 93
        tmp___2 = sscanf((char const   */* __restrict  */)(before), (char const   */* __restrict  */)"%d",
                         & a);
        }
#line 93
        if (tmp___2 == 1) {
#line 94
          acnt = 1;
        } else {
#line 96
          ok = 0;
        }
      }
      {
#line 98
      tmp___5 = sscanf((char const   */* __restrict  */)(after), (char const   */* __restrict  */)"%d,%d",
                       & c, & d);
      }
#line 98
      if (tmp___5 == 2) {
#line 99
        bcnt = d;
      } else {
        {
#line 100
        tmp___4 = sscanf((char const   */* __restrict  */)(after), (char const   */* __restrict  */)"%d",
                         & c);
        }
#line 100
        if (tmp___4 == 1) {
#line 101
          bcnt = 1;
        } else {
#line 103
          ok = 0;
        }
      }
#line 104
      if (ok) {
#line 105
        state = 3;
      } else {
#line 107
        state = 0;
      }
    } else {
      {
#line 108
      tmp___7 = sscanf((char const   */* __restrict  */)cp, (char const   */* __restrict  */)"*** %d,%d ****",
                       & a, & b);
      }
#line 108
      if (tmp___7 == 2) {
#line 109
        acnt = (b - a) + 1;
#line 110
        state = 1;
      } else {
        {
#line 111
        tmp___6 = sscanf((char const   */* __restrict  */)cp, (char const   */* __restrict  */)"--- %d,%d ----",
                         & c, & d);
        }
#line 111
        if (tmp___6 == 2) {
#line 112
          bcnt = (d - c) + 1;
#line 113
          state = 2;
        }
      }
    }
    {
#line 115
    skip_eol(& cp, end);
    }
#line 116
    if (state == 1) {
      {
#line 118
      buf[0] = (char)0;
#line 119
      chunks ++;
#line 120
      sprintf((char */* __restrict  */)(buf + 1), (char const   */* __restrict  */)"%5d %5d %5d\n",
              chunks, a, acnt);
#line 121
      memcpy((void */* __restrict  */)(r1.body + r1.len), (void const   */* __restrict  */)(buf),
             (size_t )20);
#line 122
      r1.len += 20;
      }
    } else
#line 116
    if (state == 3) {
      {
#line 118
      buf[0] = (char)0;
#line 119
      chunks ++;
#line 120
      sprintf((char */* __restrict  */)(buf + 1), (char const   */* __restrict  */)"%5d %5d %5d\n",
              chunks, a, acnt);
#line 121
      memcpy((void */* __restrict  */)(r1.body + r1.len), (void const   */* __restrict  */)(buf),
             (size_t )20);
#line 122
      r1.len += 20;
      }
    }
#line 124
    if (state == 2) {
      {
#line 126
      buf___0[0] = (char)0;
#line 127
      sprintf((char */* __restrict  */)(buf___0 + 1), (char const   */* __restrict  */)"%5d %5d %5d\n",
              chunks, c, bcnt);
#line 128
      memcpy((void */* __restrict  */)(r2.body + r2.len), (void const   */* __restrict  */)(buf___0),
             (size_t )20);
#line 129
      r2.len += 20;
      }
    } else
#line 124
    if (state == 3) {
      {
#line 126
      buf___0[0] = (char)0;
#line 127
      sprintf((char */* __restrict  */)(buf___0 + 1), (char const   */* __restrict  */)"%5d %5d %5d\n",
              chunks, c, bcnt);
#line 128
      memcpy((void */* __restrict  */)(r2.body + r2.len), (void const   */* __restrict  */)(buf___0),
             (size_t )20);
#line 129
      r2.len += 20;
      }
    }
#line 131
    goto switch_break;
    case_1: /* CIL Label */ 
#line 133
    if ((int )*cp == 32) {
#line 133
      goto _L;
    } else
#line 133
    if ((int )*cp == 33) {
#line 133
      goto _L;
    } else
#line 133
    if ((int )*cp == 45) {
#line 133
      goto _L;
    } else
#line 133
    if ((int )*cp == 43) {
      _L: /* CIL Label */ 
#line 133
      if ((int )*(cp + 1) == 32) {
        {
#line 135
        cp += 2;
#line 136
        copyline(& r1, & cp, end);
#line 137
        acnt --;
        }
#line 138
        if (acnt == 0) {
#line 139
          state = 0;
        }
      } else {
        {
#line 141
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: bad context patch at line %d\n",
                Cmd, lineno);
        }
#line 143
        return (0);
      }
    } else {
      {
#line 141
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: bad context patch at line %d\n",
              Cmd, lineno);
      }
#line 143
      return (0);
    }
#line 145
    goto switch_break;
    case_2: /* CIL Label */ 
#line 147
    if ((int )*cp == 32) {
#line 147
      goto _L___0;
    } else
#line 147
    if ((int )*cp == 33) {
#line 147
      goto _L___0;
    } else
#line 147
    if ((int )*cp == 45) {
#line 147
      goto _L___0;
    } else
#line 147
    if ((int )*cp == 43) {
      _L___0: /* CIL Label */ 
#line 147
      if ((int )*(cp + 1) == 32) {
        {
#line 149
        cp += 2;
#line 150
        copyline(& r2, & cp, end);
#line 151
        bcnt --;
        }
#line 152
        if (bcnt == 0) {
#line 153
          state = 0;
        }
      } else {
        {
#line 155
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: bad context patch/2 at line %d\n",
                Cmd, lineno);
        }
#line 157
        return (0);
      }
    } else {
      {
#line 155
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: bad context patch/2 at line %d\n",
              Cmd, lineno);
      }
#line 157
      return (0);
    }
#line 159
    goto switch_break;
    case_3: /* CIL Label */ 
#line 161
    if ((int )*cp == 32) {
      {
#line 163
      cp ++;
#line 164
      cp2 = cp;
#line 165
      copyline(& r1, & cp, end);
#line 166
      copyline(& r2, & cp2, end);
#line 167
      acnt --;
#line 167
      bcnt --;
      }
    } else
#line 168
    if ((int )*cp == 45) {
      {
#line 169
      cp ++;
#line 170
      copyline(& r1, & cp, end);
#line 171
      acnt --;
      }
    } else
#line 172
    if ((int )*cp == 43) {
      {
#line 173
      cp ++;
#line 174
      copyline(& r2, & cp, end);
#line 175
      bcnt --;
      }
    } else {
      {
#line 177
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: bad unified patch at line %d\n",
              Cmd, lineno);
      }
#line 179
      return (0);
    }
#line 181
    if (acnt <= 0) {
#line 181
      if (bcnt <= 0) {
#line 182
        state = 0;
      }
    }
#line 183
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 186
  if (r1.len > f.len) {
    {
#line 187
    abort();
    }
  } else
#line 186
  if (r2.len > f.len) {
    {
#line 187
    abort();
    }
  }
#line 188
  *f1 = r1;
#line 189
  *f2 = r2;
#line 190
  return (chunks);
}
}
#line 196 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/extract.c"
int split_merge(struct stream f , struct stream *f1 , struct stream *f2 , struct stream *f3 ) 
{ 
  int lineno ;
  int state ;
  char *cp ;
  char *end ;
  struct stream r1 ;
  struct stream r2 ;
  struct stream r3 ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int len ;
  char *peek ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *cp2 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *t ;
  int tmp___10 ;

  {
  {
#line 199
  state = 0;
#line 202
  f1->body = (char *)((void *)0);
#line 203
  f2->body = (char *)((void *)0);
#line 205
  tmp = xmalloc(f.len);
#line 205
  r1.body = (char *)tmp;
#line 206
  tmp___0 = xmalloc(f.len);
#line 206
  r2.body = (char *)tmp___0;
#line 207
  tmp___1 = xmalloc(f.len);
#line 207
  r3.body = (char *)tmp___1;
#line 208
  r3.len = 0;
#line 208
  r2.len = r3.len;
#line 208
  r1.len = r2.len;
#line 210
  cp = f.body;
#line 211
  end = f.body + f.len;
  }
  {
#line 212
  while (1) {
    while_continue: /* CIL Label */ ;
#line 212
    if (! ((unsigned long )cp < (unsigned long )end)) {
#line 212
      goto while_break;
    }
#line 221
    len = (int )(end - cp);
#line 222
    lineno ++;
    {
#line 224
    if (state == 0) {
#line 224
      goto case_0;
    }
#line 266
    if (state == 1) {
#line 266
      goto case_1;
    }
#line 276
    if (state == 2) {
#line 276
      goto case_2;
    }
#line 286
    if (state == 3) {
#line 286
      goto case_3;
    }
#line 296
    if (state == 4) {
#line 296
      goto case_4;
    }
#line 306
    if (state == 5) {
#line 306
      goto case_5;
    }
#line 223
    goto switch_break;
    case_0: /* CIL Label */ 
#line 225
    if (len >= 8) {
      {
#line 225
      tmp___5 = strncmp((char const   *)cp, "<<<<<<<", (size_t )7);
      }
#line 225
      if (tmp___5 == 0) {
#line 225
        if ((int )*(cp + 7) == 32) {
#line 225
          goto _L___0;
        } else
#line 225
        if ((int )*(cp + 7) == 10) {
          _L___0: /* CIL Label */ 
          {
#line 230
          state = 1;
#line 231
          skip_eol(& cp, end);
#line 244
          peek = cp;
          }
          {
#line 245
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 245
            if (! ((unsigned long )peek < (unsigned long )end)) {
#line 245
              goto while_break___0;
            }
#line 246
            if (end - peek >= 8L) {
#line 246
              if ((int )*(peek + 7) == 32) {
#line 246
                goto _L;
              } else
#line 246
              if ((int )*(peek + 7) == 10) {
                _L: /* CIL Label */ 
                {
#line 248
                tmp___3 = strncmp((char const   *)peek, "|||||||", (size_t )7);
                }
#line 248
                if (tmp___3 == 0) {
#line 250
                  goto while_break___0;
                } else {
                  {
#line 248
                  tmp___4 = strncmp((char const   *)peek, ">>>>>>>", (size_t )7);
                  }
#line 248
                  if (tmp___4 == 0) {
#line 250
                    goto while_break___0;
                  } else {
                    {
#line 251
                    tmp___2 = strncmp((char const   *)peek, "=======", (size_t )7);
                    }
#line 251
                    if (tmp___2 == 0) {
#line 252
                      state = 4;
#line 253
                      goto while_break___0;
                    }
                  }
                }
              }
            }
            {
#line 256
            skip_eol(& peek, end);
            }
          }
          while_break___0: /* CIL Label */ ;
          }
        } else {
          {
#line 259
          cp2 = cp;
#line 260
          copyline(& r1, & cp2, end);
#line 261
          cp2 = cp;
#line 262
          copyline(& r2, & cp2, end);
#line 263
          copyline(& r3, & cp, end);
          }
        }
      } else {
        {
#line 259
        cp2 = cp;
#line 260
        copyline(& r1, & cp2, end);
#line 261
        cp2 = cp;
#line 262
        copyline(& r2, & cp2, end);
#line 263
        copyline(& r3, & cp, end);
        }
      }
    } else {
      {
#line 259
      cp2 = cp;
#line 260
      copyline(& r1, & cp2, end);
#line 261
      cp2 = cp;
#line 262
      copyline(& r2, & cp2, end);
#line 263
      copyline(& r3, & cp, end);
      }
    }
#line 265
    goto switch_break;
    case_1: /* CIL Label */ 
#line 267
    if (len >= 8) {
      {
#line 267
      tmp___6 = strncmp((char const   *)cp, "|||||||", (size_t )7);
      }
#line 267
      if (tmp___6 == 0) {
#line 267
        if ((int )*(cp + 7) == 32) {
          {
#line 271
          state = 2;
#line 272
          skip_eol(& cp, end);
          }
        } else
#line 267
        if ((int )*(cp + 7) == 10) {
          {
#line 271
          state = 2;
#line 272
          skip_eol(& cp, end);
          }
        } else {
          {
#line 274
          copyline(& r1, & cp, end);
          }
        }
      } else {
        {
#line 274
        copyline(& r1, & cp, end);
        }
      }
    } else {
      {
#line 274
      copyline(& r1, & cp, end);
      }
    }
#line 275
    goto switch_break;
    case_2: /* CIL Label */ 
#line 277
    if (len >= 8) {
      {
#line 277
      tmp___7 = strncmp((char const   *)cp, "=======", (size_t )7);
      }
#line 277
      if (tmp___7 == 0) {
#line 277
        if ((int )*(cp + 7) == 32) {
          {
#line 281
          state = 3;
#line 282
          skip_eol(& cp, end);
          }
        } else
#line 277
        if ((int )*(cp + 7) == 10) {
          {
#line 281
          state = 3;
#line 282
          skip_eol(& cp, end);
          }
        } else {
          {
#line 284
          copyline(& r2, & cp, end);
          }
        }
      } else {
        {
#line 284
        copyline(& r2, & cp, end);
        }
      }
    } else {
      {
#line 284
      copyline(& r2, & cp, end);
      }
    }
#line 285
    goto switch_break;
    case_3: /* CIL Label */ 
#line 287
    if (len >= 8) {
      {
#line 287
      tmp___8 = strncmp((char const   *)cp, ">>>>>>>", (size_t )7);
      }
#line 287
      if (tmp___8 == 0) {
#line 287
        if ((int )*(cp + 7) == 32) {
          {
#line 291
          state = 0;
#line 292
          skip_eol(& cp, end);
          }
        } else
#line 287
        if ((int )*(cp + 7) == 10) {
          {
#line 291
          state = 0;
#line 292
          skip_eol(& cp, end);
          }
        } else {
          {
#line 294
          copyline(& r3, & cp, end);
          }
        }
      } else {
        {
#line 294
        copyline(& r3, & cp, end);
        }
      }
    } else {
      {
#line 294
      copyline(& r3, & cp, end);
      }
    }
#line 295
    goto switch_break;
    case_4: /* CIL Label */ 
#line 297
    if (len >= 8) {
      {
#line 297
      tmp___9 = strncmp((char const   *)cp, "=======", (size_t )7);
      }
#line 297
      if (tmp___9 == 0) {
#line 297
        if ((int )*(cp + 7) == 32) {
          {
#line 301
          state = 5;
#line 302
          skip_eol(& cp, end);
          }
        } else
#line 297
        if ((int )*(cp + 7) == 10) {
          {
#line 301
          state = 5;
#line 302
          skip_eol(& cp, end);
          }
        } else {
          {
#line 304
          copyline(& r2, & cp, end);
          }
        }
      } else {
        {
#line 304
        copyline(& r2, & cp, end);
        }
      }
    } else {
      {
#line 304
      copyline(& r2, & cp, end);
      }
    }
#line 305
    goto switch_break;
    case_5: /* CIL Label */ 
#line 307
    if (len >= 8) {
      {
#line 307
      tmp___10 = strncmp((char const   *)cp, ">>>>>>>", (size_t )7);
      }
#line 307
      if (tmp___10 == 0) {
#line 307
        if ((int )*(cp + 7) == 32) {
          {
#line 311
          state = 0;
#line 312
          skip_eol(& cp, end);
          }
        } else
#line 307
        if ((int )*(cp + 7) == 10) {
          {
#line 311
          state = 0;
#line 312
          skip_eol(& cp, end);
          }
        } else {
          {
#line 314
          t = cp;
#line 315
          copyline(& r1, & t, end);
#line 316
          copyline(& r3, & cp, end);
          }
        }
      } else {
        {
#line 314
        t = cp;
#line 315
        copyline(& r1, & t, end);
#line 316
        copyline(& r3, & cp, end);
        }
      }
    } else {
      {
#line 314
      t = cp;
#line 315
      copyline(& r1, & t, end);
#line 316
      copyline(& r3, & cp, end);
      }
    }
#line 318
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 321
  *f1 = r1;
#line 322
  *f2 = r2;
#line 323
  *f3 = r3;
#line 324
  return (state == 0);
}
}
#line 127 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/bestmatch.c"
__inline static void update_value(struct v___0 *v , int dir , int k , int x ) 
{ 


  {
#line 129
  if (dir == 0) {
#line 130
    if (v->val <= 0) {
#line 131
      v->x = x - 1;
#line 132
      v->y = (x - k) - 1;
#line 133
      v->inmatch = 0;
#line 134
      v->val = 4;
    }
#line 136
    v->val += 2 + v->inmatch;
#line 137
    v->inmatch = 1;
#line 138
    v->k = k;
  } else
#line 139
  if (v->val > 0) {
#line 140
    v->inmatch = 0;
#line 141
    if (! (dir * (v->k - k) > 0)) {
#line 144
      (v->val) --;
    }
  }
#line 147
  return;
}
}
#line 153 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/bestmatch.c"
__inline static int best_val(struct v___0 *v , int max ) 
{ 


  {
#line 155
  if (v->val <= 0) {
#line 156
    return ((4 + max * 3) - 1);
  } else {
#line 158
    return (((max * 3 - 1) + v->inmatch) + v->val);
  }
}
}
#line 172 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/bestmatch.c"
static void find_best(struct file *a , struct file *b , int alo , int ahi , int blo ,
                      int bhi , struct best *best ) 
{ 
  int klo ;
  int khi ;
  int k ;
  int f ;
  struct v___0 *valloc___0 ;
  void *tmp ;
  struct v___0 *v ;
  int x ;
  int y ;
  struct v___0 vnew ;
  struct v___0 vnew2 ;
  int chunk ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 179
  tmp = xmalloc((int )(sizeof(struct v___0 ) * (unsigned long )(((ahi - alo) + (bhi - blo)) + 5)));
#line 179
  valloc___0 = (struct v___0 *)tmp;
#line 180
  v = valloc___0 + ((bhi - alo) + 2);
#line 182
  khi = alo - blo;
#line 182
  klo = khi;
#line 182
  k = klo;
#line 183
  f = alo + blo;
#line 184
  (v + k)->val = 0;
#line 185
  (v + k)->c = -1;
  }
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! (f < ahi + bhi)) {
#line 187
      goto while_break;
    }
#line 190
    f ++;
#line 191
    k = klo + 1;
    {
#line 191
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 191
      if (! (k <= khi - 1)) {
#line 191
        goto while_break___0;
      }
      {
#line 193
      x = (k + f) / 2;
#line 194
      y = x - k;
#line 198
      tmp___0 = match(a->list + (x - 1), b->list + (y - 1));
      }
#line 198
      if (tmp___0) {
        {
#line 199
        vnew = *(v + k);
#line 200
        update_value(v + k, 0, k, x);
        }
#line 201
        if ((v + k)->c < 0) {
          {
#line 202
          abort();
          }
        }
#line 203
        if ((v + k)->val > (best + (v + k)->c)->val) {
#line 204
          chunk = (v + k)->c;
#line 205
          (best + chunk)->xlo = (v + k)->x;
#line 206
          (best + chunk)->ylo = (v + k)->y;
#line 207
          (best + chunk)->xhi = x;
#line 208
          (best + chunk)->yhi = y;
#line 209
          (best + chunk)->val = (v + k)->val;
        }
      } else {
        {
#line 214
        vnew = *(v + (k + 1));
#line 215
        update_value(& vnew, -1, k, x);
        }
#line 217
        if ((b->list + (y - 1))->len) {
#line 217
          if ((int )*((b->list + (y - 1))->start + 0) == 0) {
            {
#line 218
            vnew.c = atoi((char const   *)((b->list + (y - 1))->start + 1));
#line 219
            vnew.val = 0;
            }
          }
        }
        {
#line 226
        vnew2 = *(v + (k - 1));
#line 227
        update_value(& vnew2, 1, k, x);
        }
#line 230
        if (vnew2.val > vnew.val) {
#line 231
          *(v + k) = vnew2;
        } else {
#line 233
          *(v + k) = vnew;
        }
      }
#line 191
      k += 2;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 237
    klo --;
#line 238
    *(v + klo) = *(v + (klo + 1));
#line 239
    x = (klo + f) / 2;
#line 239
    y = x - klo;
#line 240
    update_value(v + klo, -1, klo, x);
    }
#line 241
    if (y <= bhi) {
#line 241
      if ((b->list + (y - 1))->len) {
#line 241
        if ((int )*((b->list + (y - 1))->start + 0) == 0) {
          {
#line 242
          (v + klo)->c = atoi((char const   *)((b->list + (y - 1))->start + 1));
#line 243
          (v + klo)->val = 0;
          }
        }
      }
    }
    {
#line 245
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 245
      if (klo + 2 < ahi - bhi) {
#line 245
        if (! (y > bhi)) {
          {
#line 245
          tmp___1 = min(ahi - x, bhi - y);
#line 245
          tmp___2 = best_val(v + klo, tmp___1);
          }
#line 245
          if (tmp___2 < (best + (v + klo)->c)->val) {
            {
#line 245
            tmp___3 = min(ahi - x, (bhi - y) + 1);
#line 245
            tmp___4 = best_val(v + (klo + 1), tmp___3);
            }
#line 245
            if (! (tmp___4 < (best + (v + (klo + 1))->c)->val)) {
#line 245
              goto while_break___1;
            }
          } else {
#line 245
            goto while_break___1;
          }
        }
      } else {
#line 245
        goto while_break___1;
      }
#line 251
      klo += 2;
#line 252
      x = (klo + f) / 2;
#line 252
      y = x - klo;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 255
    khi ++;
#line 256
    *(v + khi) = *(v + (khi - 1));
#line 257
    x = (khi + f) / 2;
#line 257
    y = x - khi;
#line 258
    update_value(v + khi, -1, khi, x);
    }
    {
#line 259
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 259
      if (khi - 2 > ahi - bhi) {
#line 259
        if (! (x > ahi)) {
#line 259
          if ((v + khi)->c >= 0) {
            {
#line 259
            tmp___5 = min(ahi - x, bhi - y);
#line 259
            tmp___6 = best_val(v + khi, tmp___5);
            }
#line 259
            if (tmp___6 < (best + (v + khi)->c)->val) {
              {
#line 259
              tmp___7 = min((ahi - x) + 1, bhi - y);
#line 259
              tmp___8 = best_val(v + (khi - 1), tmp___7);
              }
#line 259
              if (! (tmp___8 < (best + (v + khi)->c)->val)) {
#line 259
                goto while_break___2;
              }
            } else {
#line 259
              goto while_break___2;
            }
          } else {
#line 259
            goto while_break___2;
          }
        }
      } else {
#line 259
        goto while_break___2;
      }
#line 266
      khi -= 2;
#line 267
      x = (khi + f) / 2;
#line 267
      y = x - khi;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 271
  free((void *)valloc___0);
  }
#line 272
  return;
}
}
#line 277 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/bestmatch.c"
static struct csl *csl_join(struct csl *c1 , struct csl *c2 ) 
{ 
  struct csl *c ;
  struct csl *cd ;
  struct csl *rv ;
  int cnt ;
  void *tmp ;
  struct csl *tmp___0 ;
  struct csl *tmp___1 ;

  {
#line 282
  if ((unsigned long )c1 == (unsigned long )((void *)0)) {
#line 283
    return (c2);
  }
#line 284
  if ((unsigned long )c2 == (unsigned long )((void *)0)) {
#line 285
    return (c1);
  }
#line 287
  cnt = 1;
#line 288
  c = c1;
  {
#line 288
  while (1) {
    while_continue: /* CIL Label */ ;
#line 288
    if (! c->len) {
#line 288
      goto while_break;
    }
#line 289
    cnt ++;
#line 288
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 290
  c = c2;
  {
#line 290
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 290
    if (! c->len) {
#line 290
      goto while_break___0;
    }
#line 291
    cnt ++;
#line 290
    c ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 292
  tmp = xmalloc((int )(sizeof(*rv) * (unsigned long )cnt));
#line 292
  rv = (struct csl *)tmp;
#line 292
  cd = rv;
#line 293
  c = c1;
  }
  {
#line 293
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 293
    if (! c->len) {
#line 293
      goto while_break___1;
    }
#line 294
    tmp___0 = cd;
#line 294
    cd ++;
#line 294
    *tmp___0 = *c;
#line 293
    c ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 295
  c = c2;
  {
#line 295
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 295
    if (! c->len) {
#line 295
      goto while_break___2;
    }
#line 296
    tmp___1 = cd;
#line 296
    cd ++;
#line 296
    *tmp___1 = *c;
#line 295
    c ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 297
  cd->len = 0;
#line 298
  free((void *)c1);
#line 299
  free((void *)c2);
  }
#line 300
  return (rv);
}
}
#line 313 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/bestmatch.c"
__inline static int is_skipped(struct elmnt e ) 
{ 
  int tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;

  {
  {
#line 315
  tmp = ends_line(e);
  }
#line 315
  if (tmp) {
#line 315
    tmp___1 = 0;
  } else {
    {
#line 315
    tmp___0 = __ctype_b_loc();
    }
#line 315
    if ((int const   )*(*tmp___0 + (int )*(e.start + 0)) & 8) {
#line 315
      tmp___1 = 0;
    } else
#line 315
    if ((int )*(e.start + 0) == 95) {
#line 315
      tmp___1 = 0;
    } else {
#line 315
      tmp___1 = 1;
    }
  }
#line 315
  return (tmp___1);
}
}
#line 320 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/bestmatch.c"
static struct file reduce(struct file orig ) 
{ 
  int cnt ;
  int i ;
  struct file rv ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 322
  cnt = 0;
#line 326
  i = 0;
  {
#line 326
  while (1) {
    while_continue: /* CIL Label */ ;
#line 326
    if (! (i < orig.elcnt)) {
#line 326
      goto while_break;
    }
    {
#line 327
    tmp = is_skipped(*(orig.list + i));
    }
#line 327
    if (! tmp) {
#line 328
      cnt ++;
    }
#line 326
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 330
  if (cnt == orig.elcnt) {
#line 331
    return (orig);
  }
  {
#line 333
  rv.elcnt = cnt;
#line 334
  tmp___0 = xmalloc((int )((unsigned long )cnt * sizeof(struct elmnt )));
#line 334
  rv.list = (struct elmnt *)tmp___0;
#line 335
  cnt = 0;
#line 336
  i = 0;
  }
  {
#line 336
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 336
    if (! (i < orig.elcnt)) {
#line 336
      goto while_break___0;
    }
    {
#line 337
    tmp___2 = is_skipped(*(orig.list + i));
    }
#line 337
    if (! tmp___2) {
#line 338
      tmp___1 = cnt;
#line 338
      cnt ++;
#line 338
      *(rv.list + tmp___1) = *(orig.list + i);
    }
#line 336
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 339
  return (rv);
}
}
#line 348 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/bestmatch.c"
static void remap(struct best *best , int cnt , struct file a1 , struct file b1 ,
                  struct file a2 , struct file b2 ) 
{ 
  int b ;
  int pa ;
  int pb ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 355
  pb = 0;
#line 355
  pa = pb;
#line 357
  if (a1.elcnt == 0) {
#line 357
    if (a2.elcnt == 0) {
#line 358
      return;
    }
  }
#line 360
  b = 1;
  {
#line 360
  while (1) {
    while_continue: /* CIL Label */ ;
#line 360
    if (! (b < cnt)) {
#line 360
      goto while_break;
    }
#line 361
    if ((best + b)->val > 0) {
      {
#line 362
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 362
        if (pa < a2.elcnt) {
#line 362
          if (! ((unsigned long )(a2.list + pa)->start != (unsigned long )(a1.list + (best + b)->xlo)->start)) {
#line 362
            goto while_break___0;
          }
        } else {
#line 362
          goto while_break___0;
        }
#line 364
        pa ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 365
      if (pa == a2.elcnt) {
        {
#line 366
        abort();
        }
      }
      {
#line 367
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 367
        if (pb < b2.elcnt) {
#line 367
          if (! ((unsigned long )(b2.list + pb)->start != (unsigned long )(b1.list + (best + b)->ylo)->start)) {
#line 367
            goto while_break___1;
          }
        } else {
#line 367
          goto while_break___1;
        }
#line 369
        pb ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 370
      if (pb == b2.elcnt) {
        {
#line 371
        abort();
        }
      }
      {
#line 376
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 376
        if (pa > 0) {
          {
#line 376
          tmp = is_skipped(*(a2.list + (pa - 1)));
          }
#line 376
          if (! tmp) {
#line 376
            goto while_break___2;
          }
        } else {
#line 376
          goto while_break___2;
        }
#line 377
        pa --;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 378
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 378
        if (pb > 0) {
          {
#line 378
          tmp___0 = is_skipped(*(b2.list + (pb - 1)));
          }
#line 378
          if (! tmp___0) {
#line 378
            goto while_break___3;
          }
        } else {
#line 378
          goto while_break___3;
        }
#line 379
        pb --;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 381
      if (pa <= 0) {
#line 382
        pa = 1;
      }
#line 383
      if (pb <= 0) {
#line 384
        pb = 1;
      }
#line 386
      (best + b)->xlo = pa;
#line 387
      (best + b)->ylo = pb;
      {
#line 389
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 389
        if (pa < a2.elcnt) {
#line 389
          if (! (pa == 0)) {
#line 389
            if (! ((unsigned long )(a2.list + (pa - 1))->start != (unsigned long )(a1.list + ((best + b)->xhi - 1))->start)) {
#line 389
              goto while_break___4;
            }
          }
        } else {
#line 389
          goto while_break___4;
        }
#line 392
        pa ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 393
      if (pa == a2.elcnt) {
#line 393
        if ((best + b)->xhi != a1.elcnt) {
          {
#line 394
          abort();
          }
        }
      }
      {
#line 395
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 395
        if (pb < b2.elcnt) {
#line 395
          if (! (pb == 0)) {
#line 395
            if (! ((unsigned long )(b2.list + (pb - 1))->start != (unsigned long )(b1.list + ((best + b)->yhi - 1))->start)) {
#line 395
              goto while_break___5;
            }
          }
        } else {
#line 395
          goto while_break___5;
        }
#line 398
        pb ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 399
      if (pb == b2.elcnt) {
#line 399
        if ((best + b)->yhi != b1.elcnt) {
          {
#line 400
          abort();
          }
        }
      }
      {
#line 405
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 405
        if (pa < a2.elcnt) {
          {
#line 405
          tmp___1 = is_skipped(*(a2.list + pa));
          }
#line 405
          if (! tmp___1) {
#line 405
            goto while_break___6;
          }
        } else {
#line 405
          goto while_break___6;
        }
#line 406
        pa ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 407
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 407
        if (pb < b2.elcnt) {
          {
#line 407
          tmp___2 = is_skipped(*(b2.list + pb));
          }
#line 407
          if (! tmp___2) {
#line 407
            goto while_break___7;
          }
        } else {
#line 407
          goto while_break___7;
        }
#line 408
        pb ++;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 409
      (best + b)->xhi = pa;
#line 410
      (best + b)->yhi = pb;
    }
#line 360
    b ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 412
  return;
}
}
#line 414 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/bestmatch.c"
static void find_best_inorder(struct file *a , struct file *b , int alo , int ahi ,
                              int blo , int bhi , struct best *best , int bestlo ,
                              int besthi ) 
{ 
  int i ;
  int bad ;
  int bestval ;
  int bestpos ;
  int y ;
  int y___0 ;

  {
#line 423
  bad = 0;
#line 424
  bestpos = 0;
#line 426
  i = bestlo;
  {
#line 426
  while (1) {
    while_continue: /* CIL Label */ ;
#line 426
    if (! (i < besthi)) {
#line 426
      goto while_break;
    }
#line 427
    (best + i)->val = 0;
#line 426
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 428
  find_best(a, b, alo, ahi, blo, bhi, best);
#line 429
  i = bestlo + 1;
  }
  {
#line 429
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 429
    if (! (i < besthi)) {
#line 429
      goto while_break___0;
    }
#line 430
    if ((best + (i - 1))->val > 0) {
#line 430
      if ((best + i)->val > 0) {
#line 430
        if ((best + (i - 1))->xhi >= (best + i)->xlo) {
#line 433
          bad = 1;
        }
      }
    }
#line 429
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 435
  if (! bad) {
#line 436
    return;
  }
#line 437
  bestval = 0;
#line 438
  i = bestlo;
  {
#line 438
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 438
    if (! (i < besthi)) {
#line 438
      goto while_break___1;
    }
#line 439
    if ((best + i)->val > bestval) {
#line 440
      bestval = (best + i)->val;
#line 441
      bestpos = i;
    }
#line 438
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 443
  if (bestpos > bestlo) {
#line 445
    y = (best + bestpos)->ylo;
    {
#line 446
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 446
      if (! *((b->list + y)->start + 0)) {
#line 446
        goto while_break___2;
      }
#line 447
      y --;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 448
    find_best_inorder(a, b, alo, (best + bestpos)->xlo, blo, y, best, bestlo, bestpos);
    }
  }
#line 453
  if (bestpos < besthi - 1) {
#line 455
    y___0 = (best + bestpos)->yhi;
    {
#line 456
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 456
      if (! *((b->list + y___0)->start + 0)) {
#line 456
        goto while_break___3;
      }
#line 457
      y___0 ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 458
    find_best_inorder(a, b, (best + bestpos)->xhi, ahi, y___0, bhi, best, bestpos + 1,
                      besthi);
    }
  }
#line 463
  return;
}
}
#line 465 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/bestmatch.c"
struct csl *pdiff(struct file a , struct file b , int chunks ) 
{ 
  struct csl *csl1 ;
  struct csl *csl2 ;
  struct best *best ;
  void *tmp ;
  int i ;
  struct file asmall ;
  struct file bsmall ;
  void *tmp___0 ;

  {
  {
#line 468
  tmp = xmalloc((int )(sizeof(struct best ) * (unsigned long )(chunks + 1)));
#line 468
  best = (struct best *)tmp;
#line 472
  asmall = reduce(a);
#line 473
  bsmall = reduce(b);
#line 475
  i = 0;
  }
  {
#line 475
  while (1) {
    while_continue: /* CIL Label */ ;
#line 475
    if (! (i < chunks + 1)) {
#line 475
      goto while_break;
    }
#line 476
    (best + i)->val = 0;
#line 475
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 477
  find_best_inorder(& asmall, & bsmall, 0, asmall.elcnt, 0, bsmall.elcnt, best, 1,
                    chunks + 1);
#line 480
  remap(best, chunks + 1, asmall, bsmall, a, b);
#line 482
  csl1 = (struct csl *)((void *)0);
#line 483
  i = 1;
  }
  {
#line 483
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 483
    if (! (i <= chunks)) {
#line 483
      goto while_break___0;
    }
#line 484
    if ((best + i)->val > 0) {
      {
#line 485
      csl2 = diff_partial(a, b, (best + i)->xlo, (best + i)->xhi, (best + i)->ylo,
                          (best + i)->yhi);
#line 488
      csl1 = csl_join(csl1, csl2);
      }
    }
#line 483
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 490
  if (csl1) {
#line 491
    csl2 = csl1;
    {
#line 491
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 491
      if (! csl2->len) {
#line 491
        goto while_break___1;
      }
#line 491
      csl2 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 493
    csl2->a = a.elcnt;
#line 494
    csl2->b = b.elcnt;
  } else {
    {
#line 496
    tmp___0 = xmalloc((int )sizeof(*csl1));
#line 496
    csl1 = (struct csl *)tmp___0;
#line 497
    csl1->len = 0;
#line 498
    csl1->a = a.elcnt;
#line 499
    csl1->b = b.elcnt;
    }
  }
  {
#line 501
  free((void *)best);
  }
#line 502
  return (csl1);
}
}
#line 709 "/usr/include/stdio.h"
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 43 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/load.c"
static void join_streams(struct stream *list , int cnt ) 
{ 
  int len ;
  int i ;
  char *c ;
  void *tmp ;

  {
#line 48
  len = 0;
#line 52
  i = 0;
  {
#line 52
  while (1) {
    while_continue: /* CIL Label */ ;
#line 52
    if (! (i < cnt)) {
#line 52
      goto while_break;
    }
#line 53
    len += (list + i)->len;
#line 52
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 55
  tmp = realloc((void *)(list + 0)->body, (size_t )(len + 1));
#line 55
  c = (char *)tmp;
  }
#line 56
  if ((unsigned long )c == (unsigned long )((void *)0)) {
    {
#line 57
    die();
    }
  }
#line 59
  (list + 0)->body = c;
#line 60
  c += (list + 0)->len;
#line 61
  (list + 0)->len = len;
#line 62
  i = 1;
  {
#line 62
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 62
    if (! (i < cnt)) {
#line 62
      goto while_break___0;
    }
    {
#line 63
    memcpy((void */* __restrict  */)c, (void const   */* __restrict  */)(list + i)->body,
           (size_t )(list + i)->len);
#line 64
    c += (list + i)->len;
#line 65
    (list + i)->len = 0;
#line 66
    free((void *)(list + i)->body);
#line 62
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 68
  *(c + 0) = (char)0;
#line 69
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/load.c"
static struct stream load_regular(int fd ) 
{ 
  struct stat stb ;
  struct stream s ;
  void *tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 75
  fstat(fd, & stb);
#line 77
  s.len = (int )stb.st_size;
#line 78
  tmp = xmalloc(s.len + 1);
#line 78
  s.body = (char *)tmp;
#line 79
  tmp___0 = read(fd, (void *)s.body, (size_t )s.len);
  }
#line 79
  if (tmp___0 != (ssize_t )s.len) {
    {
#line 80
    die();
    }
  }
#line 82
  *(s.body + s.len) = (char)0;
#line 83
  return (s);
}
}
#line 86 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/load.c"
static struct stream load_other(int fd ) 
{ 
  struct stream list[10] ;
  int i ;
  void *tmp ;
  ssize_t tmp___0 ;

  {
#line 90
  i = 0;
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 93
    tmp = xmalloc(8192);
#line 93
    list[i].body = (char *)tmp;
#line 94
    tmp___0 = read(fd, (void *)list[i].body, (size_t )8192);
#line 94
    list[i].len = (int )tmp___0;
    }
#line 95
    if (list[i].len < 0) {
      {
#line 96
      die();
      }
    }
#line 97
    if (list[i].len == 0) {
#line 98
      goto while_break;
    }
#line 99
    i ++;
#line 100
    if (i == 10) {
      {
#line 101
      join_streams(list, i);
#line 102
      i = 1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 105
  join_streams(list, i);
  }
#line 106
  return (list[0]);
}
}
#line 109 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/load.c"
struct stream load_segment(FILE *f , unsigned int start , unsigned int end ) 
{ 
  struct stream s ;
  void *tmp ;
  size_t tmp___0 ;

  {
  {
#line 113
  s.len = (int )(end - start);
#line 114
  tmp = xmalloc(s.len);
#line 114
  s.body = (char *)tmp;
#line 115
  fseek(f, (long )start, 0);
#line 116
  tmp___0 = fread((void */* __restrict  */)s.body, (size_t )1, (size_t )s.len, (FILE */* __restrict  */)f);
  }
#line 116
  if (tmp___0 != (size_t )s.len) {
    {
#line 117
    die();
    }
  }
#line 118
  return (s);
}
}
#line 121 "/home/june/repo/benchmarks/collector2/temp/wiggle-0.9.1/load.c"
struct stream load_file(char *name ) 
{ 
  struct stream s ;
  struct stat stb ;
  int fd ;
  int start ;
  int end ;
  int prefix_len ;
  FILE *f ;
  FILE *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 127
  prefix_len = 0;
#line 129
  s.body = (char *)((void *)0);
#line 130
  s.len = 0;
#line 131
  tmp___2 = sscanf((char const   */* __restrict  */)name, (char const   */* __restrict  */)"_wiggle_:%d:%d:%n",
                   & start, & end, & prefix_len);
  }
#line 131
  if (tmp___2 >= 2) {
#line 131
    if (prefix_len > 0) {
      {
#line 133
      tmp = fopen((char const   */* __restrict  */)(name + prefix_len), (char const   */* __restrict  */)"r");
#line 133
      f = tmp;
      }
#line 134
      if (f) {
        {
#line 135
        s = load_segment(f, (unsigned int )start, (unsigned int )end);
#line 136
        fclose(f);
        }
      } else {
#line 138
        s.body = (char *)((void *)0);
#line 139
        s.len = 0;
      }
    } else {
#line 131
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 142
    tmp___0 = strcmp((char const   *)name, "-");
    }
#line 142
    if (tmp___0 == 0) {
#line 143
      fd = 0;
    } else {
      {
#line 145
      fd = open((char const   *)name, 0);
      }
#line 146
      if (fd < 0) {
#line 147
        return (s);
      }
    }
    {
#line 150
    tmp___1 = fstat(fd, & stb);
    }
#line 150
    if (tmp___1 == 0) {
#line 152
      if ((stb.st_mode & 61440U) == 32768U) {
        {
#line 153
        s = load_regular(fd);
        }
      } else {
        {
#line 155
        s = load_other(fd);
        }
      }
    }
    {
#line 157
    close(fd);
    }
  }
#line 159
  return (s);
}
}
