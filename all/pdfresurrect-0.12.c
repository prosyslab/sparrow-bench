/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 31 "/home/wheatley/newnew/temp/pdfresurrect-0.12/pdf.h"
typedef unsigned short pdf_flag_t;
#line 40 "/home/wheatley/newnew/temp/pdfresurrect-0.12/pdf.h"
struct _kv_t {
   char key[32] ;
   char value[128] ;
};
#line 40 "/home/wheatley/newnew/temp/pdfresurrect-0.12/pdf.h"
typedef struct _kv_t kv_t;
#line 50 "/home/wheatley/newnew/temp/pdfresurrect-0.12/pdf.h"
typedef kv_t pdf_creator_t;
#line 53 "/home/wheatley/newnew/temp/pdfresurrect-0.12/pdf.h"
struct _xref_entry {
   int obj_id ;
   long offset ;
   int gen_num ;
   char f_or_n ;
};
#line 53 "/home/wheatley/newnew/temp/pdfresurrect-0.12/pdf.h"
typedef struct _xref_entry xref_entry_t;
#line 64 "/home/wheatley/newnew/temp/pdfresurrect-0.12/pdf.h"
struct _xref_t {
   long start ;
   long end ;
   pdf_creator_t *creator ;
   int n_creator_entries ;
   int n_entries ;
   xref_entry_t *entries ;
   int n_kids ;
   int *kids ;
   int n_kids_allocs ;
   int is_stream ;
   int is_linear ;
   int version ;
};
#line 64 "/home/wheatley/newnew/temp/pdfresurrect-0.12/pdf.h"
typedef struct _xref_t xref_t;
#line 91 "/home/wheatley/newnew/temp/pdfresurrect-0.12/pdf.h"
struct _pdf_t {
   char *name ;
   short pdf_major_version ;
   short pdf_minor_version ;
   int n_xrefs ;
   xref_t *xrefs ;
   int has_xref_streams ;
};
#line 91 "/home/wheatley/newnew/temp/pdfresurrect-0.12/pdf.h"
typedef struct _pdf_t pdf_t;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 531
extern int fgetc(FILE *__stream ) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 754
extern long ftell(FILE *__stream ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 321 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
#line 105 "/home/wheatley/newnew/temp/pdfresurrect-0.12/pdf.h"
pdf_t *pdf_new(char const   *name ) ;
#line 106
void pdf_delete(pdf_t *pdf ) ;
#line 108
int pdf_is_pdf(FILE *fp ) ;
#line 109
void pdf_get_version(FILE *fp , pdf_t *pdf ) ;
#line 111
int pdf_load_xrefs(FILE *fp , pdf_t *pdf ) ;
#line 112
void pdf_load_pages_kids(FILE *fp , pdf_t *pdf ) ;
#line 114
char pdf_get_object_status(pdf_t const   *pdf , int xref_idx , int entry_idx ) ;
#line 119
void pdf_zero_object(FILE *fp , pdf_t const   *pdf , int xref_idx , int entry_idx ) ;
#line 125
void pdf_summarize(FILE *fp , pdf_t const   *pdf , char const   *name , pdf_flag_t flags ) ;
#line 132
int pdf_display_creator(pdf_t const   *pdf , int xref_idx ) ;
#line 34 "/home/wheatley/newnew/temp/pdfresurrect-0.12/main.c"
static void usage(void) 
{ 


  {
  {
#line 36
  printf((char const   */* __restrict  */)"pdfresurrect Copyright (C) 2008, 2009, 2010, 2012 Matt Davis (enferex)\nof 757labs (www.757labs.org)\nThis program comes with ABSOLUTELY NO WARRANTY\nThis is free software, and you are welcome to redistribute it\nunder certain conditions.  For details see the file \'LICENSE\'\nthat came with this software or visit:\n<http://www.gnu.org/licenses/gpl-3.0.txt>\n\n");
#line 45
  printf((char const   */* __restrict  */)"-- pdfresurrect v0.12 --\nUsage: ./pdfresurrect <file.pdf> [-i] [-w] [-q] [-s]\n\t -i Display PDF creator information\n\t -w Write the PDF versions and summary to disk\n\t -q Display only the number of versions contained in the PDF\n\t -s Scrub the previous history data from the specified PDF\n");
#line 52
  exit(0);
  }
}
}
#line 56 "/home/wheatley/newnew/temp/pdfresurrect-0.12/main.c"
static void write_version(FILE *fp , char const   *fname , char const   *dirname ,
                          xref_t *xref ) 
{ 
  long start ;
  long end ;
  long startxref ;
  long pos ;
  long pos_count ;
  char *c ;
  char *xref_buf ;
  char *new_fname ;
  char data ;
  char peek ;
  FILE *new_fp ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;

  {
  {
#line 66
  start = ftell(fp);
#line 69
  c = strstr(fname, ".pdf");
  }
#line 69
  if (c) {
#line 70
    *c = (char )'\000';
  }
  {
#line 71
  tmp = strlen(fname);
#line 71
  tmp___0 = strlen(dirname);
#line 71
  tmp___1 = malloc((tmp + tmp___0) + 16UL);
#line 71
  new_fname = (char *)tmp___1;
#line 72
  tmp___2 = strlen(fname);
#line 72
  tmp___3 = strlen(dirname);
#line 72
  snprintf((char */* __restrict  */)new_fname, (tmp___2 + tmp___3) + 16UL, (char const   */* __restrict  */)"%s/%s-version-%d.pdf",
           dirname, fname, xref->version);
#line 75
  new_fp = fopen((char const   */* __restrict  */)new_fname, (char const   */* __restrict  */)"w");
  }
#line 75
  if (! new_fp) {
    {
#line 77
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[pdfresurrect] -- Error -- Could not create file \'%s\'\n",
            new_fname);
#line 78
    fseek(fp, start, 0);
#line 79
    free((void *)new_fname);
    }
#line 80
    return;
  }
  {
#line 84
  fseek(fp, 0L, 0);
  }
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 85
    tmp___4 = fread((void */* __restrict  */)(& data), (size_t )1, (size_t )1, (FILE */* __restrict  */)fp);
    }
#line 85
    if (! tmp___4) {
#line 85
      goto while_break;
    }
    {
#line 86
    fwrite((void const   */* __restrict  */)(& data), (size_t )1, (size_t )1, (FILE */* __restrict  */)new_fp);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 87
  fprintf((FILE */* __restrict  */)new_fp, (char const   */* __restrict  */)"\r\n");
#line 90
  fseek(fp, xref->end, 0);
#line 91
  pos = xref->end;
#line 92
  pos_count = 0L;
  }
  {
#line 93
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 93
    tmp___5 = fgetc(fp);
#line 93
    peek = (char )(tmp___5 != 102);
    }
#line 93
    if (! peek) {
#line 93
      goto while_break___0;
    }
    {
#line 94
    pos_count ++;
#line 94
    fseek(fp, pos - pos_count, 0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 95
  end = ftell(fp);
#line 98
  fseek(fp, xref->start, 0);
#line 99
  tmp___6 = malloc((size_t )(end - xref->start));
#line 99
  xref_buf = (char *)tmp___6;
#line 100
  tmp___7 = fread((void */* __restrict  */)xref_buf, (size_t )(end - xref->start),
                  (size_t )1, (FILE */* __restrict  */)fp);
  }
#line 100
  if (! tmp___7) {
    {
#line 102
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[pdfresurrect] -- Error -- Could not read %d bytes from document\n",
            (int )(xref->end - xref->start));
#line 105
    fclose(new_fp);
#line 106
    free((void *)new_fname);
#line 107
    fseek(fp, start, 0);
    }
#line 108
    return;
  }
  {
#line 112
  startxref = ftell(new_fp);
#line 113
  tmp___8 = fwrite((void const   */* __restrict  */)xref_buf, (size_t )(end - xref->start),
                   (size_t )1, (FILE */* __restrict  */)new_fp);
  }
#line 113
  if (! tmp___8) {
    {
#line 115
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[pdfresurrect] -- Error -- Could not write %d bytes to document\n",
            (int )(end - xref->start));
    }
  }
  {
#line 119
  fprintf((FILE */* __restrict  */)new_fp, (char const   */* __restrict  */)"\r\n%ld\r\n%%%%EOF",
          startxref);
#line 122
  fclose(new_fp);
#line 123
  free((void *)new_fname);
#line 124
  free((void *)xref_buf);
#line 125
  fseek(fp, start, 0);
  }
#line 126
  return;
}
}
#line 129 "/home/wheatley/newnew/temp/pdfresurrect-0.12/main.c"
static void scrub_document(FILE *fp , pdf_t const   *pdf ) 
{ 
  FILE *new_fp ;
  int ch ;
  int i ;
  int j ;
  int last_version ;
  char *new_name ;
  char *c ;
  char const   *suffix ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char tmp___2 ;

  {
  {
#line 134
  suffix = "-scrubbed.pdf";
#line 137
  tmp = strlen((char const   *)pdf->name);
#line 137
  tmp___0 = strlen(suffix);
#line 137
  tmp___1 = malloc((tmp + tmp___0) + 1UL);
#line 137
  new_name = (char *)tmp___1;
  }
#line 137
  if (! new_name) {
    {
#line 139
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[pdfresurrect] -- Error -- Insufficient memory to create scrubbed file name\n");
    }
#line 140
    return;
  }
  {
#line 143
  strcpy((char */* __restrict  */)new_name, (char const   */* __restrict  */)pdf->name);
#line 144
  c = strrchr((char const   *)new_name, '.');
  }
#line 144
  if (c) {
#line 145
    *c = (char )'\000';
  }
  {
#line 146
  strcat((char */* __restrict  */)new_name, (char const   */* __restrict  */)suffix);
#line 148
  new_fp = fopen((char const   */* __restrict  */)new_name, (char const   */* __restrict  */)"r");
  }
#line 148
  if (new_fp) {
    {
#line 150
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[pdfresurrect] -- Error -- File name already exists for saving scrubbed document\n");
#line 151
    free((void *)new_name);
#line 152
    fclose(new_fp);
    }
#line 153
    return;
  }
  {
#line 156
  new_fp = fopen((char const   */* __restrict  */)new_name, (char const   */* __restrict  */)"w+");
  }
#line 156
  if (! new_fp) {
    {
#line 158
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[pdfresurrect] -- Error -- Could not create file for saving scrubbed document\n");
#line 159
    free((void *)new_name);
#line 160
    fclose(new_fp);
    }
#line 161
    return;
  }
  {
#line 165
  fseek(fp, 0L, 0);
  }
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 166
    ch = fgetc(fp);
    }
#line 166
    if (! (ch != -1)) {
#line 166
      goto while_break;
    }
    {
#line 167
    fputc(ch, new_fp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 170
  last_version = 0;
#line 171
  i = 0;
  {
#line 171
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 171
    if (! (i < (int )pdf->n_xrefs)) {
#line 171
      goto while_break___0;
    }
#line 172
    if ((pdf->xrefs + i)->version) {
#line 173
      last_version = (pdf->xrefs + i)->version;
    }
#line 171
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 178
  fseek(new_fp, 0L, 0);
#line 179
  i = 0;
  }
  {
#line 179
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 179
    if (! (i < (int )pdf->n_xrefs)) {
#line 179
      goto while_break___1;
    }
#line 181
    j = 0;
    {
#line 181
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 181
      if (! (j < (pdf->xrefs + i)->n_entries)) {
#line 181
        goto while_break___2;
      }
#line 182
      if (! (! ((pdf->xrefs + i)->entries + j)->obj_id)) {
        {
#line 186
        tmp___2 = pdf_get_object_status(pdf, i, j);
        }
        {
#line 188
        if ((int )tmp___2 == 77) {
#line 188
          goto case_77;
        }
#line 193
        if ((int )tmp___2 == 68) {
#line 193
          goto case_68;
        }
#line 197
        goto switch_default;
        case_77: /* CIL Label */ 
#line 189
        if ((pdf->xrefs + i)->version != last_version) {
          {
#line 190
          pdf_zero_object(new_fp, pdf, i, j);
          }
        }
#line 191
        goto switch_break;
        case_68: /* CIL Label */ 
        {
#line 194
        pdf_zero_object(new_fp, pdf, i, j);
        }
#line 195
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 198
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
#line 181
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 179
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 204
  free((void *)new_name);
#line 205
  fclose(new_fp);
  }
#line 206
  return;
}
}
#line 209 "/home/wheatley/newnew/temp/pdfresurrect-0.12/main.c"
static void display_creator(FILE *fp , pdf_t const   *pdf ) 
{ 
  int i ;
  int tmp ;

  {
  {
#line 213
  printf((char const   */* __restrict  */)"PDF Version: %d.%d\n", (int const   )pdf->pdf_major_version,
         (int const   )pdf->pdf_minor_version);
#line 216
  i = 0;
  }
  {
#line 216
  while (1) {
    while_continue: /* CIL Label */ ;
#line 216
    if (! (i < (int )pdf->n_xrefs)) {
#line 216
      goto while_break;
    }
#line 218
    if (! (pdf->xrefs + i)->version) {
#line 219
      goto __Cont;
    }
    {
#line 221
    tmp = pdf_display_creator(pdf, i);
    }
#line 221
    if (tmp) {
      {
#line 222
      printf((char const   */* __restrict  */)"\n");
      }
    }
    __Cont: /* CIL Label */ 
#line 216
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 224
  return;
}
}
#line 227 "/home/wheatley/newnew/temp/pdfresurrect-0.12/main.c"
static pdf_t *init_pdf(FILE *fp , char const   *name ) 
{ 
  pdf_t *pdf ;

  {
  {
#line 231
  pdf = pdf_new(name);
#line 232
  pdf_get_version(fp, pdf);
#line 233
  pdf_load_xrefs(fp, pdf);
#line 234
  pdf_load_pages_kids(fp, pdf);
  }
#line 236
  return (pdf);
}
}
#line 240 "/home/wheatley/newnew/temp/pdfresurrect-0.12/main.c"
int main(int argc , char **argv ) 
{ 
  int i ;
  int n_valid ;
  int do_write ;
  int do_scrub ;
  char *c ;
  char *dname ;
  char *name ;
  DIR *dir ;
  FILE *fp ;
  pdf_t *pdf ;
  pdf_flag_t flags ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;

  {
#line 249
  if (argc < 2) {
    {
#line 250
    usage();
    }
  }
#line 253
  flags = (pdf_flag_t )0;
#line 253
  do_scrub = (int )flags;
#line 253
  do_write = do_scrub;
#line 254
  name = (char *)((void *)0);
#line 255
  i = 1;
  {
#line 255
  while (1) {
    while_continue: /* CIL Label */ ;
#line 255
    if (! (i < argc)) {
#line 255
      goto while_break;
    }
    {
#line 257
    tmp___2 = strncmp((char const   *)*(argv + i), "-w", (size_t )2);
    }
#line 257
    if (tmp___2 == 0) {
#line 258
      do_write = 1;
    } else {
      {
#line 259
      tmp___1 = strncmp((char const   *)*(argv + i), "-i", (size_t )2);
      }
#line 259
      if (tmp___1 == 0) {
#line 260
        flags = (pdf_flag_t )((int )flags | 2);
      } else {
        {
#line 261
        tmp___0 = strncmp((char const   *)*(argv + i), "-q", (size_t )2);
        }
#line 261
        if (tmp___0 == 0) {
#line 262
          flags = (pdf_flag_t )((int )flags | 1);
        } else {
          {
#line 263
          tmp = strncmp((char const   *)*(argv + i), "-s", (size_t )2);
          }
#line 263
          if (tmp == 0) {
#line 264
            do_scrub = 1;
          } else
#line 265
          if ((int )*(*(argv + i) + 0) != 45) {
#line 266
            name = *(argv + i);
          } else
#line 267
          if ((int )*(*(argv + i) + 0) == 45) {
            {
#line 268
            usage();
            }
          }
        }
      }
    }
#line 255
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 271
  if (! name) {
    {
#line 272
    usage();
    }
  }
  {
#line 274
  fp = fopen((char const   */* __restrict  */)name, (char const   */* __restrict  */)"r");
  }
#line 274
  if (fp) {
    {
#line 279
    tmp___3 = pdf_is_pdf(fp);
    }
#line 279
    if (! tmp___3) {
      {
#line 281
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[pdfresurrect] -- Error -- \'%s\' specified is not a valid PDF\n",
              name);
#line 282
      fclose(fp);
      }
#line 283
      return (-1);
    }
  } else {
    {
#line 276
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[pdfresurrect] -- Error -- Could not open file \'%s\'\n",
            *(argv + 1));
    }
#line 277
    return (-1);
  }
  {
#line 287
  pdf = init_pdf(fp, (char const   *)name);
  }
#line 287
  if (! pdf) {
    {
#line 289
    fclose(fp);
    }
#line 290
    return (-1);
  }
#line 294
  i = 0;
#line 294
  n_valid = 0;
  {
#line 294
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 294
    if (! (i < pdf->n_xrefs)) {
#line 294
      goto while_break___0;
    }
#line 295
    if ((pdf->xrefs + i)->version) {
#line 296
      n_valid ++;
    }
#line 294
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 299
  if (n_valid < 2) {
#line 301
    if (! ((int )flags & 3)) {
      {
#line 302
      printf((char const   */* __restrict  */)"%s: There is only one version of this PDF\n",
             pdf->name);
      }
    }
#line 304
    if (do_write) {
      {
#line 306
      fclose(fp);
#line 307
      pdf_delete(pdf);
      }
#line 308
      return (0);
    }
  }
#line 312
  dname = (char *)((void *)0);
#line 313
  if (do_write) {
    {
#line 316
    c = strrchr((char const   *)name, '/');
    }
#line 316
    if (c) {
#line 317
      name = c + 1;
    }
    {
#line 319
    c = strrchr((char const   *)name, '.');
    }
#line 319
    if (c) {
#line 320
      *c = (char )'\000';
    }
    {
#line 322
    tmp___4 = strlen((char const   *)name);
#line 322
    tmp___5 = malloc(tmp___4 + 16UL);
#line 322
    dname = (char *)tmp___5;
#line 323
    sprintf((char */* __restrict  */)dname, (char const   */* __restrict  */)"%s-versions",
            name);
#line 324
    dir = opendir((char const   *)dname);
    }
#line 324
    if (dir) {
      {
#line 328
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[pdfresurrect] -- Error -- This directory already exists, PDF version extraction will not occur\n");
#line 330
      fclose(fp);
#line 331
      closedir(dir);
#line 332
      free((void *)dname);
#line 333
      pdf_delete(pdf);
      }
#line 334
      return (-1);
    } else {
      {
#line 325
      mkdir((char const   *)dname, (__mode_t )448);
      }
    }
#line 338
    i = 0;
    {
#line 338
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 338
      if (! (i < pdf->n_xrefs)) {
#line 338
        goto while_break___1;
      }
#line 339
      if ((pdf->xrefs + i)->version) {
        {
#line 340
        write_version(fp, (char const   *)name, (char const   *)dname, pdf->xrefs + i);
        }
      }
#line 338
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 344
  pdf_summarize(fp, (pdf_t const   *)pdf, (char const   *)dname, flags);
  }
#line 347
  if (do_scrub) {
    {
#line 348
    scrub_document(fp, (pdf_t const   *)pdf);
    }
  }
#line 351
  if ((int )flags & 2) {
    {
#line 352
    display_creator(fp, (pdf_t const   *)pdf);
    }
  }
  {
#line 354
  fclose(fp);
#line 355
  free((void *)dname);
#line 356
  pdf_delete(pdf);
  }
#line 358
  return (0);
}
}
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 150
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 157
extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1), __leaf__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 183
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 348
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 759
extern void rewind(FILE *__stream ) ;
#line 826
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) clearerr)(FILE *__stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 57 "/home/wheatley/newnew/temp/pdfresurrect-0.12/pdf.c"
static int is_valid_xref(FILE *fp , pdf_t *pdf , xref_t *xref ) ;
#line 58
static void load_xref_entries(FILE *fp , xref_t *xref ) ;
#line 59
static void load_xref_from_plaintext(FILE *fp , xref_t *xref ) ;
#line 60
static void load_xref_from_stream(FILE *fp , xref_t *xref ) ;
#line 61
static void get_xref_linear_skipped(FILE *fp , xref_t *xref ) ;
#line 62
static void resolve_linearized_pdf(pdf_t *pdf ) ;
#line 64
static pdf_creator_t *new_creator(int *n_elements ) ;
#line 65
static void load_creator(FILE *fp , pdf_t *pdf ) ;
#line 66
static void load_creator_from_buf(FILE *fp , xref_t *xref , char const   *buf___0 ) ;
#line 67
static void load_creator_from_xml(xref_t *xref , char const   *buf___0 ) ;
#line 68
static void load_creator_from_old_format(FILE *fp , xref_t *xref , char const   *buf___0 ) ;
#line 73
static char *get_object_from_here(FILE *fp , size_t *size , int *is_stream ) ;
#line 75
static char *get_object(FILE *fp , int obj_id , xref_t const   *xref , size_t *size ,
                        int *is_stream ) ;
#line 82
static void add_kid(int id , xref_t *xref ) ;
#line 83
static void load_kids(FILE *fp , int pages_id , xref_t *xref ) ;
#line 85
static char const   *get_type(FILE *fp , int obj_id , xref_t const   *xref ) ;
#line 87
static char *get_header(FILE *fp ) ;
#line 89
static char *decode_text_string(char const   *str , size_t str_len ) ;
#line 90
static int get_next_eof(FILE *fp ) ;
#line 97 "/home/wheatley/newnew/temp/pdfresurrect-0.12/pdf.c"
pdf_t *pdf_new(char const   *name ) 
{ 
  char const   *n ;
  pdf_t *pdf ;
  void *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;

  {
  {
#line 102
  tmp = calloc((size_t )1, sizeof(pdf_t ));
#line 102
  pdf = (pdf_t *)tmp;
  }
#line 104
  if (name) {
    {
#line 107
    tmp___0 = strrchr(name, '/');
#line 107
    n = (char const   *)tmp___0;
    }
#line 107
    if (n) {
#line 108
      n ++;
    } else {
#line 110
      n = name;
    }
    {
#line 112
    tmp___1 = strlen(n);
#line 112
    tmp___2 = malloc(tmp___1 + 1UL);
#line 112
    pdf->name = (char *)tmp___2;
#line 113
    strcpy((char */* __restrict  */)pdf->name, (char const   */* __restrict  */)n);
    }
  } else {
    {
#line 117
    tmp___3 = strlen("Unknown");
#line 117
    tmp___4 = malloc(tmp___3 + 1UL);
#line 117
    pdf->name = (char *)tmp___4;
#line 118
    strcpy((char */* __restrict  */)pdf->name, (char const   */* __restrict  */)"Unknown");
    }
  }
#line 121
  return (pdf);
}
}
#line 125 "/home/wheatley/newnew/temp/pdfresurrect-0.12/pdf.c"
void pdf_delete(pdf_t *pdf ) 
{ 
  int i ;

  {
#line 129
  i = 0;
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
#line 129
    if (! (i < pdf->n_xrefs)) {
#line 129
      goto while_break;
    }
    {
#line 131
    free((void *)(pdf->xrefs + i)->creator);
#line 132
    free((void *)(pdf->xrefs + i)->entries);
#line 133
    free((void *)(pdf->xrefs + i)->kids);
#line 129
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 136
  free((void *)pdf->name);
#line 137
  free((void *)pdf->xrefs);
#line 138
  free((void *)pdf);
  }
#line 139
  return;
}
}
#line 142 "/home/wheatley/newnew/temp/pdfresurrect-0.12/pdf.c"
int pdf_is_pdf(FILE *fp ) 
{ 
  int is_pdf ;
  char *header ;
  char *tmp ;

  {
  {
#line 147
  header = get_header(fp);
  }
#line 149
  if (header) {
    {
#line 149
    tmp = strstr((char const   *)header, "%PDF-");
    }
#line 149
    if (tmp) {
#line 150
      is_pdf = 1;
    } else {
#line 152
      is_pdf = 0;
    }
  } else {
#line 152
    is_pdf = 0;
  }
  {
#line 154
  free((void *)header);
  }
#line 155
  return (is_pdf);
}
}
#line 159 "/home/wheatley/newnew/temp/pdfresurrect-0.12/pdf.c"
void pdf_get_version(FILE *fp , pdf_t *pdf ) 
{ 
  char *header ;
  char *c ;
  size_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;

  {
  {
#line 163
  header = get_header(fp);
#line 166
  c = strstr((char const   *)header, "%PDF-");
  }
#line 166
  if (c) {
    {
#line 166
    tmp___3 = strlen("%PDF-M.m");
    }
#line 166
    if ((c + tmp___3) + 2) {
      {
#line 169
      tmp = strlen("%PDF-");
#line 169
      tmp___0 = atoi((char const   *)(c + tmp));
#line 169
      pdf->pdf_major_version = (short )tmp___0;
#line 170
      tmp___1 = strlen("%PDF-M.");
#line 170
      tmp___2 = atoi((char const   *)(c + tmp___1));
#line 170
      pdf->pdf_minor_version = (short )tmp___2;
      }
    }
  }
  {
#line 173
  free((void *)header);
  }
#line 174
  return;
}
}
#line 177 "/home/wheatley/newnew/temp/pdfresurrect-0.12/pdf.c"
int pdf_load_xrefs(FILE *fp , pdf_t *pdf ) 
{ 
  int i ;
  int ver ;
  int is_linear ;
  long pos ;
  long pos_count ;
  char x ;
  char *c ;
  char buf___0[256] ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 183
  c = (char *)((void *)0);
#line 186
  pdf->n_xrefs = 0;
#line 187
  fseek(fp, 0L, 0);
  }
  {
#line 188
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 188
    tmp = get_next_eof(fp);
    }
#line 188
    if (! (tmp >= 0)) {
#line 188
      goto while_break;
    }
#line 189
    (pdf->n_xrefs) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 191
  if (! pdf->n_xrefs) {
#line 192
    return (0);
  }
  {
#line 195
  fseek(fp, 0L, 0);
#line 196
  tmp___0 = calloc((size_t )1, sizeof(xref_t ) * (unsigned long )pdf->n_xrefs);
#line 196
  pdf->xrefs = (xref_t *)tmp___0;
#line 197
  ver = 1;
#line 198
  i = 0;
  }
  {
#line 198
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 198
    if (! (i < pdf->n_xrefs)) {
#line 198
      goto while_break___0;
    }
    {
#line 201
    tmp___1 = get_next_eof(fp);
#line 201
    pos = (long )tmp___1;
    }
#line 201
    if (pos < 0L) {
#line 202
      goto while_break___0;
    }
#line 205
    tmp___2 = ver;
#line 205
    ver ++;
#line 205
    (pdf->xrefs + i)->version = tmp___2;
#line 208
    pos_count = 0L;
    {
#line 209
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 209
      tmp___3 = ferror(fp);
      }
#line 209
      if (tmp___3) {
#line 209
        goto while_break___1;
      } else {
        {
#line 209
        tmp___4 = feof(fp);
        }
#line 209
        if (tmp___4) {
#line 209
          goto while_break___1;
        } else {
          {
#line 209
          tmp___5 = fgetc(fp);
#line 209
          x = (char )tmp___5;
          }
#line 209
          if (! ((int )x != 102)) {
#line 209
            goto while_break___1;
          }
        }
      }
      {
#line 210
      pos_count ++;
#line 210
      fseek(fp, pos - pos_count, 0);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 213
    memset((void *)(buf___0), 0, sizeof(buf___0));
#line 214
    fread((void */* __restrict  */)(buf___0), (size_t )1, (size_t )pos_count, (FILE */* __restrict  */)fp);
#line 215
    c = buf___0;
    }
    {
#line 216
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 216
      if (! ((int )*c == 32)) {
#line 216
        if (! ((int )*c == 10)) {
#line 216
          if (! ((int )*c == 13)) {
#line 216
            goto while_break___2;
          }
        }
      }
#line 217
      c ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 220
    (pdf->xrefs + i)->start = atol((char const   *)c);
    }
#line 223
    if ((pdf->xrefs + i)->start == 0L) {
      {
#line 224
      get_xref_linear_skipped(fp, pdf->xrefs + i);
      }
    } else {
      {
#line 230
      pos = ftell(fp);
#line 231
      fseek(fp, (pdf->xrefs + i)->start, 0);
#line 232
      tmp___6 = get_next_eof(fp);
#line 232
      (pdf->xrefs + i)->end = (long )tmp___6;
#line 235
      fseek(fp, pos, 0);
      }
    }
    {
#line 239
    tmp___7 = is_valid_xref(fp, pdf, pdf->xrefs + i);
    }
#line 239
    if (! tmp___7) {
      {
#line 241
      is_linear = (pdf->xrefs + i)->is_linear;
#line 242
      memset((void *)(pdf->xrefs + i), 0, sizeof(xref_t ));
#line 243
      (pdf->xrefs + i)->is_linear = is_linear;
#line 244
      rewind(fp);
#line 245
      get_next_eof(fp);
      }
#line 246
      goto __Cont;
    }
    {
#line 250
    load_xref_entries(fp, pdf->xrefs + i);
    }
    __Cont: /* CIL Label */ 
#line 198
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 256
  if ((pdf->xrefs + 0)->is_linear) {
    {
#line 257
    resolve_linearized_pdf(pdf);
    }
  }
  {
#line 262
  load_creator(fp, pdf);
  }
#line 264
  return (pdf->n_xrefs);
}
}
#line 269 "/home/wheatley/newnew/temp/pdfresurrect-0.12/pdf.c"
void pdf_load_pages_kids(FILE *fp , pdf_t *pdf ) 
{ 
  int i ;
  int id ;
  int dummy ;
  char *buf___0 ;
  char *c ;
  long start ;
  long sz ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;

  {
  {
#line 275
  start = ftell(fp);
#line 278
  i = 0;
  }
  {
#line 278
  while (1) {
    while_continue: /* CIL Label */ ;
#line 278
    if (! (i < pdf->n_xrefs)) {
#line 278
      goto while_break;
    }
#line 280
    if ((pdf->xrefs + i)->version) {
#line 280
      if ((pdf->xrefs + i)->end != 0L) {
        {
#line 282
        fseek(fp, (pdf->xrefs + i)->start, 0);
        }
        {
#line 283
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 283
          tmp = ferror(fp);
          }
#line 283
          if (tmp) {
#line 283
            goto while_break___0;
          } else {
            {
#line 283
            tmp___0 = feof(fp);
            }
#line 283
            if (tmp___0) {
#line 283
              goto while_break___0;
            } else {
              {
#line 283
              tmp___1 = fgetc(fp);
              }
#line 283
              if (! (tmp___1 != 116)) {
#line 283
                goto while_break___0;
              }
            }
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 287
        tmp___2 = ftell(fp);
#line 287
        sz = (pdf->xrefs + i)->end - tmp___2;
#line 288
        tmp___3 = malloc((size_t )(sz + 1L));
#line 288
        buf___0 = (char *)tmp___3;
#line 289
        fread((void */* __restrict  */)buf___0, (size_t )1, (size_t )sz, (FILE */* __restrict  */)fp);
#line 290
        *(buf___0 + sz) = (char )'\000';
#line 291
        c = strstr((char const   *)buf___0, "/Root");
        }
#line 291
        if (! c) {
          {
#line 293
          free((void *)buf___0);
          }
#line 294
          goto __Cont;
        }
        {
#line 298
        tmp___4 = strlen("/Root");
#line 298
        id = atoi((char const   *)((c + tmp___4) + 1));
#line 299
        free((void *)buf___0);
#line 300
        buf___0 = get_object(fp, id, (xref_t const   *)(pdf->xrefs + i), (size_t *)((void *)0),
                             & dummy);
        }
#line 301
        if (! buf___0) {
          {
#line 303
          free((void *)buf___0);
          }
#line 304
          goto __Cont;
        } else {
          {
#line 301
          c = strstr((char const   *)buf___0, "/Pages");
          }
#line 301
          if (! c) {
            {
#line 303
            free((void *)buf___0);
            }
#line 304
            goto __Cont;
          }
        }
        {
#line 308
        tmp___5 = strlen("/Pages");
#line 308
        id = atoi((char const   *)((c + tmp___5) + 1));
#line 309
        load_kids(fp, id, pdf->xrefs + i);
#line 310
        free((void *)buf___0);
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 278
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 314
  fseek(fp, start, 0);
  }
#line 315
  return;
}
}
#line 318 "/home/wheatley/newnew/temp/pdfresurrect-0.12/pdf.c"
char pdf_get_object_status(pdf_t const   *pdf , int xref_idx , int entry_idx ) 
{ 
  int i ;
  int curr_ver ;
  xref_t const   *prev_xref ;
  xref_entry_t const   *prev ;
  xref_entry_t const   *curr ;

  {
#line 327
  curr = (xref_entry_t const   *)((pdf->xrefs + xref_idx)->entries + entry_idx);
#line 328
  curr_ver = (pdf->xrefs + xref_idx)->version;
#line 330
  if (curr_ver == 1) {
#line 331
    return ((char )'A');
  }
#line 334
  if ((int const   )curr->f_or_n == 102) {
#line 335
    return ((char )'D');
  }
#line 338
  prev_xref = (xref_t const   *)((void *)0);
#line 339
  i = xref_idx;
  {
#line 339
  while (1) {
    while_continue: /* CIL Label */ ;
#line 339
    if (! (i > -1)) {
#line 339
      goto while_break;
    }
#line 340
    if ((pdf->xrefs + i)->version < curr_ver) {
#line 342
      prev_xref = (xref_t const   *)(pdf->xrefs + i);
#line 343
      goto while_break;
    }
#line 339
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 346
  if (! prev_xref) {
#line 347
    return ((char )'?');
  }
#line 350
  prev = (xref_entry_t const   *)((void *)0);
#line 351
  i = 0;
  {
#line 351
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 351
    if (! (i < (int )prev_xref->n_entries)) {
#line 351
      goto while_break___0;
    }
#line 352
    if ((prev_xref->entries + i)->obj_id == (int )curr->obj_id) {
#line 354
      prev = (xref_entry_t const   *)(prev_xref->entries + i);
#line 355
      goto while_break___0;
    }
#line 351
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 359
  if (! prev) {
#line 360
    return ((char )'A');
  } else
#line 359
  if ((int const   )prev->f_or_n == 102) {
#line 359
    if ((int const   )curr->f_or_n == 110) {
#line 360
      return ((char )'A');
    } else {
#line 359
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 363
  if (prev->offset != curr->offset) {
#line 364
    return ((char )'M');
  }
#line 366
  return ((char )'?');
}
}
#line 370 "/home/wheatley/newnew/temp/pdfresurrect-0.12/pdf.c"
void pdf_zero_object(FILE *fp , pdf_t const   *pdf , int xref_idx , int entry_idx ) 
{ 
  int i ;
  char *obj ;
  size_t obj_sz ;
  xref_entry_t *entry ;
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 381
  entry = (pdf->xrefs + xref_idx)->entries + entry_idx;
#line 382
  fseek(fp, entry->offset, 0);
#line 385
  obj = get_object(fp, entry->obj_id, (xref_t const   *)(pdf->xrefs + xref_idx), (size_t *)((void *)0),
                   (int *)((void *)0));
#line 386
  obj_sz = (size_t )0;
#line 386
  i = (int )obj_sz;
  }
  {
#line 387
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 387
    i ++;
#line 387
    tmp = strncmp((char const   *)(obj + i), "endobj", (size_t )6);
    }
#line 387
    if (! tmp) {
#line 387
      goto while_break;
    }
#line 388
    obj_sz ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 390
  if (obj_sz) {
    {
#line 391
    tmp___0 = strlen("endobj");
#line 391
    obj_sz += tmp___0 + 1UL;
    }
  }
#line 394
  i = 0;
  {
#line 394
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 394
    if (! ((size_t )i < obj_sz)) {
#line 394
      goto while_break___0;
    }
    {
#line 395
    fputc('0', fp);
#line 394
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 397
  printf((char const   */* __restrict  */)"Zeroed object %d\n", entry->obj_id);
#line 398
  free((void *)obj);
  }
#line 399
  return;
}
}
#line 403 "/home/wheatley/newnew/temp/pdfresurrect-0.12/pdf.c"
void pdf_summarize(FILE *fp , pdf_t const   *pdf , char const   *name , pdf_flag_t flags ) 
{ 
  int i ;
  int j ;
  int n_versions ;
  int n_entries ;
  FILE *dst ;
  FILE *out ;
  char *dst_name ;
  char *c ;
  size_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char tmp___3 ;

  {
#line 413
  dst = (FILE *)((void *)0);
#line 414
  dst_name = (char *)((void *)0);
#line 416
  if (name) {
    {
#line 418
    tmp = strlen(name);
#line 418
    tmp___0 = malloc(tmp * 2UL + 16UL);
#line 418
    dst_name = (char *)tmp___0;
#line 419
    sprintf((char */* __restrict  */)dst_name, (char const   */* __restrict  */)"%s/%s",
            name, name);
#line 421
    c = strrchr((char const   *)dst_name, '.');
    }
#line 421
    if (c) {
      {
#line 421
      tmp___1 = strncmp((char const   *)c, ".pdf", (size_t )4);
      }
#line 421
      if (tmp___1 == 0) {
#line 422
        *c = (char )'\000';
      }
    }
    {
#line 424
    strcat((char */* __restrict  */)dst_name, (char const   */* __restrict  */)".summary");
#line 425
    dst = fopen((char const   */* __restrict  */)dst_name, (char const   */* __restrict  */)"w");
    }
#line 425
    if (! dst) {
      {
#line 427
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[pdfresurrect] -- Error -- Could not open file \'%s\' for writing\n",
              dst_name);
      }
#line 428
      return;
    }
  }
#line 433
  if (dst) {
#line 433
    out = dst;
  } else {
#line 433
    out = stdout;
  }
#line 436
  n_versions = (int )pdf->n_xrefs;
#line 437
  if (n_versions) {
#line 437
    if ((pdf->xrefs + 0)->is_linear) {
#line 438
      n_versions --;
    }
  }
#line 441
  i = 1;
  {
#line 441
  while (1) {
    while_continue: /* CIL Label */ ;
#line 441
    if (! (i < (int )pdf->n_xrefs)) {
#line 441
      goto while_break;
    }
#line 442
    if ((pdf->xrefs + i)->end == 0L) {
#line 443
      n_versions --;
    }
#line 441
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 446
  if (! pdf->n_xrefs) {
#line 447
    n_versions = 1;
  } else
#line 446
  if (! n_versions) {
#line 446
    if ((pdf->xrefs + 0)->is_linear) {
#line 447
      n_versions = 1;
    }
  }
#line 450
  n_entries = 0;
#line 451
  i = 0;
  {
#line 451
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 451
    if (! pdf->has_xref_streams) {
#line 451
      if (! (i < (int )pdf->n_xrefs)) {
#line 451
        goto while_break___0;
      }
    } else {
#line 451
      goto while_break___0;
    }
#line 453
    if ((int )flags & 1) {
#line 454
      goto __Cont;
    }
#line 456
    j = 0;
    {
#line 456
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 456
      if (! (j < (pdf->xrefs + i)->n_entries)) {
#line 456
        goto while_break___1;
      }
      {
#line 458
      n_entries ++;
#line 459
      tmp___2 = get_type(fp, ((pdf->xrefs + i)->entries + j)->obj_id, (xref_t const   *)(pdf->xrefs + i));
#line 459
      tmp___3 = pdf_get_object_status(pdf, i, j);
#line 459
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%s: --%c-- Version %d -- Object %d (%s)",
              pdf->name, (int )tmp___3, (pdf->xrefs + i)->version, ((pdf->xrefs + i)->entries + j)->obj_id,
              tmp___2);
#line 475
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\n");
#line 456
      j ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 451
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 480
  if (! ((int )flags & 1)) {
#line 486
    if (pdf->has_xref_streams) {
      {
#line 487
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%s: This PDF contains potential cross reference streams.\n%s: An object summary is not available.\n",
              pdf->name, pdf->name);
      }
    } else
#line 486
    if (! n_entries) {
      {
#line 487
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%s: This PDF contains potential cross reference streams.\n%s: An object summary is not available.\n",
              pdf->name, pdf->name);
      }
    }
    {
#line 493
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"---------- %s ----------\nVersions: %d\n",
            pdf->name, n_versions);
    }
#line 500
    if (! pdf->has_xref_streams) {
#line 501
      i = 0;
      {
#line 501
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 501
        if (! (i < (int )pdf->n_xrefs)) {
#line 501
          goto while_break___2;
        }
#line 503
        if ((pdf->xrefs + i)->is_linear) {
#line 504
          goto __Cont___0;
        }
#line 506
        n_entries = (pdf->xrefs + i)->n_entries;
#line 511
        if ((pdf->xrefs + 0)->is_linear) {
#line 512
          n_entries += (pdf->xrefs + 0)->n_entries;
        }
#line 514
        if ((pdf->xrefs + i)->version) {
#line 514
          if (n_entries) {
            {
#line 515
            fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"Version %d -- %d objects\n",
                    (pdf->xrefs + i)->version, n_entries);
            }
          }
        }
        __Cont___0: /* CIL Label */ 
#line 501
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 522
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%s: %d\n",
            pdf->name, n_versions);
    }
  }
#line 524
  if (dst) {
    {
#line 526
    fclose(dst);
#line 527
    free((void *)dst_name);
    }
  }
#line 529
  return;
}
}
#line 533 "/home/wheatley/newnew/temp/pdfresurrect-0.12/pdf.c"
int pdf_display_creator(pdf_t const   *pdf , int xref_idx ) 
{ 
  int i ;

  {
#line 537
  if (! (pdf->xrefs + xref_idx)->creator) {
#line 538
    return (0);
  }
#line 540
  i = 0;
  {
#line 540
  while (1) {
    while_continue: /* CIL Label */ ;
#line 540
    if (! (i < (pdf->xrefs + xref_idx)->n_creator_entries)) {
#line 540
      goto while_break;
    }
    {
#line 541
    printf((char const   */* __restrict  */)"%s: %s\n", ((pdf->xrefs + xref_idx)->creator + i)->key,
           ((pdf->xrefs + xref_idx)->creator + i)->value);
#line 540
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 545
  return (i > 0);
}
}
#line 552 "/home/wheatley/newnew/temp/pdfresurrect-0.12/pdf.c"
static int is_valid_xref(FILE *fp , pdf_t *pdf , xref_t *xref ) 
{ 
  int is_valid ;
  long start ;
  char *c ;
  char buf___0[16] ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 558
  memset((void *)(buf___0), 0, sizeof(buf___0));
#line 559
  is_valid = 0;
#line 560
  start = ftell(fp);
#line 561
  fseek(fp, xref->start, 0);
#line 563
  fgets((char */* __restrict  */)(buf___0), 16, (FILE */* __restrict  */)fp);
#line 564
  tmp = strlen("xref");
#line 564
  tmp___0 = strncmp((char const   *)(buf___0), "xref", tmp);
  }
#line 564
  if (tmp___0 == 0) {
#line 565
    is_valid = 1;
  } else {
    {
#line 570
    fseek(fp, xref->start, 0);
#line 571
    c = get_object_from_here(fp, (size_t *)((void *)0), & xref->is_stream);
    }
#line 573
    if (c) {
#line 573
      if (xref->is_stream) {
        {
#line 575
        free((void *)c);
#line 576
        pdf->has_xref_streams = 1;
#line 577
        is_valid = 1;
        }
      }
    }
  }
  {
#line 581
  fseek(fp, start, 0);
  }
#line 582
  return (is_valid);
}
}
#line 586 "/home/wheatley/newnew/temp/pdfresurrect-0.12/pdf.c"
static void load_xref_entries(FILE *fp , xref_t *xref ) 
{ 


  {
#line 588
  if (xref->is_stream) {
    {
#line 589
    load_xref_from_stream(fp, xref);
    }
  } else {
    {
#line 591
    load_xref_from_plaintext(fp, xref);
    }
  }
#line 592
  return;
}
}
#line 595 "/home/wheatley/newnew/temp/pdfresurrect-0.12/pdf.c"
static void load_xref_from_plaintext(FILE *fp , xref_t *xref ) 
{ 
  int i ;
  int buf_idx ;
  int obj_id ;
  int added_entries ;
  char c ;
  char buf___0[21] ;
  long start ;
  long pos ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  size_t tmp___15 ;

  {
  {
#line 601
  start = ftell(fp);
#line 604
  pos = xref->end;
#line 605
  fseek(fp, pos, 0);
  }
  {
#line 606
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 606
    tmp___3 = ftell(fp);
    }
#line 606
    if (! (tmp___3 != 0L)) {
#line 606
      goto while_break;
    }
    {
#line 607
    tmp = ferror(fp);
    }
#line 607
    if (tmp) {
      {
#line 610
      pos --;
#line 610
      fseek(fp, pos, 0);
      }
    } else {
      {
#line 607
      tmp___0 = feof(fp);
      }
#line 607
      if (tmp___0) {
        {
#line 610
        pos --;
#line 610
        fseek(fp, pos, 0);
        }
      } else {
        {
#line 607
        tmp___1 = fgetc(fp);
        }
#line 607
        if (tmp___1 == 47) {
          {
#line 607
          tmp___2 = fgetc(fp);
          }
#line 607
          if (tmp___2 == 83) {
#line 608
            goto while_break;
          } else {
            {
#line 610
            pos --;
#line 610
            fseek(fp, pos, 0);
            }
          }
        } else {
          {
#line 610
          pos --;
#line 610
          fseek(fp, pos, 0);
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 612
  fread((void */* __restrict  */)(buf___0), (size_t )1, (size_t )21, (FILE */* __restrict  */)fp);
#line 613
  tmp___4 = strlen("ize ");
#line 613
  xref->n_entries = atoi((char const   *)(buf___0 + tmp___4));
#line 614
  tmp___5 = calloc((size_t )1, (unsigned long )xref->n_entries * sizeof(struct _xref_entry ));
#line 614
  xref->entries = (xref_entry_t *)tmp___5;
#line 617
  obj_id = 0;
#line 618
  tmp___6 = strlen("xref");
#line 618
  fseek(fp, (long )((size_t )xref->start + tmp___6), 0);
#line 619
  added_entries = 0;
#line 620
  i = 0;
  }
  {
#line 620
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 620
    if (! (i < xref->n_entries)) {
#line 620
      goto while_break___0;
    }
    {
#line 623
    tmp___7 = fgetc(fp);
#line 623
    c = (char )tmp___7;
    }
    {
#line 624
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 624
      if (! ((int )c == 10)) {
#line 624
        if (! ((int )c == 13)) {
#line 624
          goto while_break___1;
        }
      }
      {
#line 625
      tmp___8 = fgetc(fp);
#line 625
      c = (char )tmp___8;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 627
    buf_idx = 0;
    {
#line 628
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 628
      if ((int )c != 10) {
#line 628
        if (! ((int )c != 13)) {
#line 628
          goto while_break___2;
        }
      } else {
#line 628
        goto while_break___2;
      }
      {
#line 630
      tmp___9 = buf_idx;
#line 630
      buf_idx ++;
#line 630
      buf___0[tmp___9] = c;
#line 631
      tmp___10 = fgetc(fp);
#line 631
      c = (char )tmp___10;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 633
    buf___0[buf_idx] = (char )'\000';
#line 636
    tmp___11 = strchr((char const   *)(buf___0), 't');
    }
#line 636
    if (tmp___11) {
#line 637
      goto while_break___0;
    }
    {
#line 640
    tmp___15 = strlen((char const   *)(buf___0));
    }
#line 640
    if (tmp___15 > 17UL) {
      {
#line 642
      tmp___12 = obj_id;
#line 642
      obj_id ++;
#line 642
      (xref->entries + i)->obj_id = tmp___12;
#line 643
      tmp___13 = strtok((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)" ");
#line 643
      (xref->entries + i)->offset = atol((char const   *)tmp___13);
#line 644
      tmp___14 = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" ");
#line 644
      (xref->entries + i)->gen_num = atoi((char const   *)tmp___14);
#line 645
      (xref->entries + i)->f_or_n = buf___0[17];
#line 646
      added_entries ++;
      }
    } else {
      {
#line 650
      obj_id = atoi((char const   *)(buf___0));
#line 651
      i --;
      }
    }
#line 620
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 655
  xref->n_entries = added_entries;
#line 656
  fseek(fp, start, 0);
  }
#line 657
  return;
}
}
#line 661 "/home/wheatley/newnew/temp/pdfresurrect-0.12/pdf.c"
static void load_xref_from_stream(FILE *fp , xref_t *xref ) 
{ 
  long start ;
  int is_stream ;
  char *stream ;
  size_t size ;

  {
  {
#line 668
  start = ftell(fp);
#line 669
  fseek(fp, xref->start, 0);
#line 671
  stream = (char *)((void *)0);
#line 672
  stream = get_object_from_here(fp, & size, & is_stream);
#line 673
  fseek(fp, start, 0);
#line 676
  free((void *)stream);
  }
#line 677
  return;
}
}
#line 681 "/home/wheatley/newnew/temp/pdfresurrect-0.12/pdf.c"
static void get_xref_linear_skipped(FILE *fp , xref_t *xref ) 
{ 
  int err ;
  char ch ;
  char buf___0[256] ;
  long tmp ;
  int tmp___0 ;
  long tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  long tmp___8 ;

  {
#line 686
  if (xref->start != 0L) {
#line 687
    return;
  }
  {
#line 690
  xref->is_linear = 1;
#line 693
  tmp___0 = get_next_eof(fp);
#line 693
  tmp = (long )tmp___0;
#line 693
  xref->end = tmp;
  }
#line 693
  if (tmp < 0L) {
#line 694
    return;
  }
#line 697
  err = 0;
  {
#line 698
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 698
    err = ferror(fp);
    }
#line 698
    if (err) {
#line 698
      goto while_break;
    } else {
      {
#line 698
      tmp___4 = fread((void */* __restrict  */)(buf___0), (size_t )1, (size_t )8,
                      (FILE */* __restrict  */)fp);
      }
#line 698
      if (! tmp___4) {
#line 698
        goto while_break;
      }
    }
    {
#line 700
    tmp___2 = strlen("trailer");
#line 700
    tmp___3 = strncmp((char const   *)(buf___0), "trailer", tmp___2);
    }
#line 700
    if (tmp___3 == 0) {
#line 701
      goto while_break;
    } else {
      {
#line 702
      tmp___1 = ftell(fp);
      }
#line 702
      if (tmp___1 - 9L < 0L) {
#line 703
        return;
      }
    }
    {
#line 705
    fseek(fp, -9L, 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 708
  if (err) {
#line 709
    return;
  }
#line 712
  ch = (char)0;
  {
#line 713
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 713
    tmp___5 = ferror(fp);
    }
#line 713
    if (tmp___5) {
#line 713
      goto while_break___0;
    } else {
      {
#line 713
      tmp___6 = feof(fp);
      }
#line 713
      if (tmp___6) {
#line 713
        goto while_break___0;
      } else {
        {
#line 713
        tmp___7 = fgetc(fp);
#line 713
        ch = (char )tmp___7;
        }
#line 713
        if (! ((int )ch != 120)) {
#line 713
          goto while_break___0;
        }
      }
    }
    {
#line 714
    fseek(fp, -2L, 1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 716
  if ((int )ch == 120) {
    {
#line 718
    tmp___8 = ftell(fp);
#line 718
    xref->start = tmp___8 - 1L;
#line 719
    fseek(fp, -1L, 1);
    }
  }
  {
#line 723
  fseek(fp, xref->start, 0);
  }
#line 724
  return;
}
}
#line 728 "/home/wheatley/newnew/temp/pdfresurrect-0.12/pdf.c"
static void resolve_linearized_pdf(pdf_t *pdf ) 
{ 
  int i ;
  xref_t buf___0 ;

  {
#line 733
  if (! (pdf->xrefs + 0)->is_linear) {
#line 734
    return;
  }
#line 737
  buf___0 = *(pdf->xrefs + 0);
#line 738
  *(pdf->xrefs + 0) = *(pdf->xrefs + 1);
#line 739
  *(pdf->xrefs + 1) = buf___0;
#line 742
  (pdf->xrefs + 0)->is_linear = 1;
#line 743
  (pdf->xrefs + 0)->version = 1;
#line 744
  (pdf->xrefs + 1)->is_linear = 0;
#line 745
  (pdf->xrefs + 1)->version = 1;
#line 748
  i = 2;
  {
#line 748
  while (1) {
    while_continue: /* CIL Label */ ;
#line 748
    if (! (i < pdf->n_xrefs)) {
#line 748
      goto while_break;
    }
#line 749
    ((pdf->xrefs + i)->version) --;
#line 748
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 750
  return;
}
}
#line 757 "/home/wheatley/newnew/temp/pdfresurrect-0.12/pdf.c"
static pdf_creator_t const   creator_template[9]  = 
#line 757
  {      {{(char )'T', (char )'i', (char )'t', (char )'l', (char )'e', (char )'\000'},
      {(char )'\000'}}, 
        {{(char )'A', (char )'u', (char )'t', (char )'h', (char )'o', (char )'r', (char )'\000'},
      {(char )'\000'}}, 
        {{(char )'S', (char )'u', (char )'b', (char )'j', (char )'e', (char )'c', (char )'t',
       (char )'\000'}, {(char )'\000'}}, 
        {{(char )'K', (char )'e', (char )'y', (char )'w', (char )'o', (char )'r', (char )'d',
       (char )'s', (char )'\000'}, {(char )'\000'}}, 
        {{(char )'C', (char )'r', (char )'e', (char )'a', (char )'t', (char )'o', (char )'r',
       (char )'\000'}, {(char )'\000'}}, 
        {{(char )'P', (char )'r', (char )'o', (char )'d', (char )'u', (char )'c', (char )'e',
       (char )'r', (char )'\000'}, {(char )'\000'}}, 
        {{(char )'C', (char )'r', (char )'e', (char )'a', (char )'t', (char )'i', (char )'o',
       (char )'n', (char )'D', (char )'a', (char )'t', (char )'e', (char )'\000'},
      {(char )'\000'}}, 
        {{(char )'M', (char )'o', (char )'d', (char )'D', (char )'a', (char )'t', (char )'e',
       (char )'\000'}, {(char )'\000'}}, 
        {{(char )'T', (char )'r', (char )'a', (char )'p', (char )'p', (char )'e', (char )'d',
       (char )'\000'}, {(char )'\000'}}};
#line 753 "/home/wheatley/newnew/temp/pdfresurrect-0.12/pdf.c"
static pdf_creator_t *new_creator(int *n_elements ) 
{ 
  pdf_creator_t *daddy ;
  void *tmp ;

  {
  {
#line 770
  tmp = malloc(sizeof(creator_template));
#line 770
  daddy = (pdf_creator_t *)tmp;
#line 771
  memcpy((void */* __restrict  */)daddy, (void const   */* __restrict  */)(creator_template),
         sizeof(creator_template));
  }
#line 773
  if (n_elements) {
#line 774
    *n_elements = (int )(sizeof(creator_template) / sizeof(creator_template[0]));
  }
#line 776
  return (daddy);
}
}
#line 788 "/home/wheatley/newnew/temp/pdfresurrect-0.12/pdf.c"
static void load_creator(FILE *fp , pdf_t *pdf ) 
{ 
  int i ;
  int buf_idx ;
  char c ;
  char *buf___0 ;
  char obj_id_buf[32] ;
  long start ;
  size_t sz ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  unsigned short const   **tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  unsigned short const   **tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  unsigned short const   **tmp___21 ;
  int tmp___22 ;
  long long tmp___23 ;
  long long tmp___24 ;

  {
  {
#line 795
  start = ftell(fp);
#line 798
  i = 0;
  }
  {
#line 798
  while (1) {
    while_continue: /* CIL Label */ ;
#line 798
    if (! (i < pdf->n_xrefs)) {
#line 798
      goto while_break;
    }
#line 800
    if (! (pdf->xrefs + i)->version) {
#line 801
      goto __Cont;
    }
    {
#line 804
    fseek(fp, (pdf->xrefs + i)->start, 0);
    }
    {
#line 805
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 805
      tmp = ferror(fp);
      }
#line 805
      if (tmp) {
#line 805
        goto while_break___0;
      } else {
        {
#line 805
        tmp___0 = feof(fp);
        }
#line 805
        if (tmp___0) {
#line 805
          goto while_break___0;
        } else {
          {
#line 805
          tmp___1 = fgetc(fp);
          }
#line 805
          if (! (tmp___1 != 116)) {
#line 805
            goto while_break___0;
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 809
    c = (char )'\000';
    {
#line 810
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 810
      tmp___6 = ferror(fp);
      }
#line 810
      if (tmp___6) {
#line 810
        goto while_break___1;
      } else {
        {
#line 810
        tmp___7 = feof(fp);
        }
#line 810
        if (tmp___7) {
#line 810
          goto while_break___1;
        } else {
          {
#line 810
          tmp___8 = fgetc(fp);
#line 810
          c = (char )tmp___8;
          }
#line 810
          if (! ((int )c != 62)) {
#line 810
            goto while_break___1;
          }
        }
      }
      {
#line 811
      tmp___2 = ferror(fp);
      }
#line 811
      if (! tmp___2) {
        {
#line 811
        tmp___3 = feof(fp);
        }
#line 811
        if (! tmp___3) {
#line 811
          if ((int )c == 47) {
            {
#line 811
            tmp___4 = fgetc(fp);
            }
#line 811
            if (tmp___4 == 73) {
              {
#line 811
              tmp___5 = fgetc(fp);
              }
#line 811
              if (tmp___5 == 110) {
#line 813
                goto while_break___1;
              }
            }
          }
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 816
    if ((int )c == 62) {
      {
#line 816
      fseek(fp, start, 0);
      }
#line 816
      goto __Cont;
    }
    {
#line 818
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 818
      tmp___9 = ferror(fp);
      }
#line 818
      if (tmp___9) {
#line 818
        goto while_break___2;
      } else {
        {
#line 818
        tmp___10 = feof(fp);
        }
#line 818
        if (tmp___10) {
#line 818
          goto while_break___2;
        } else {
          {
#line 818
          tmp___11 = __ctype_b_loc();
#line 818
          tmp___12 = fgetc(fp);
#line 818
          c = (char )tmp___12;
          }
#line 818
          if ((int const   )*(*tmp___11 + (int )c) & 8192) {
#line 818
            goto while_break___2;
          } else
#line 818
          if (! ((int )c != 62)) {
#line 818
            goto while_break___2;
          }
        }
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 822
    if ((int )c == 62) {
      {
#line 822
      fseek(fp, start, 0);
      }
#line 822
      goto __Cont;
    }
    {
#line 824
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 824
      tmp___13 = ferror(fp);
      }
#line 824
      if (tmp___13) {
#line 824
        goto while_break___3;
      } else {
        {
#line 824
        tmp___14 = feof(fp);
        }
#line 824
        if (tmp___14) {
#line 824
          goto while_break___3;
        } else {
          {
#line 824
          tmp___15 = __ctype_b_loc();
#line 824
          tmp___16 = fgetc(fp);
#line 824
          c = (char )tmp___16;
          }
#line 824
          if ((int const   )*(*tmp___15 + (int )c) & 8192) {
#line 824
            if (! ((int )c != 62)) {
#line 824
              goto while_break___3;
            }
          } else {
#line 824
            goto while_break___3;
          }
        }
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 828
    if ((int )c == 62) {
      {
#line 828
      fseek(fp, start, 0);
      }
#line 828
      goto __Cont;
    }
#line 831
    buf_idx = 0;
#line 832
    tmp___17 = buf_idx;
#line 832
    buf_idx ++;
#line 832
    obj_id_buf[tmp___17] = c;
    {
#line 833
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 833
      tmp___19 = ferror(fp);
      }
#line 833
      if (tmp___19) {
#line 833
        goto while_break___4;
      } else {
        {
#line 833
        tmp___20 = feof(fp);
        }
#line 833
        if (tmp___20) {
#line 833
          goto while_break___4;
        } else {
          {
#line 833
          tmp___21 = __ctype_b_loc();
#line 833
          tmp___22 = fgetc(fp);
#line 833
          c = (char )tmp___22;
          }
#line 833
          if ((int const   )*(*tmp___21 + (int )c) & 8192) {
#line 833
            goto while_break___4;
          } else
#line 833
          if (! ((int )c != 62)) {
#line 833
            goto while_break___4;
          }
        }
      }
#line 834
      tmp___18 = buf_idx;
#line 834
      buf_idx ++;
#line 834
      obj_id_buf[tmp___18] = c;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 836
    if ((int )c == 62) {
      {
#line 836
      fseek(fp, start, 0);
      }
#line 836
      goto __Cont;
    }
    {
#line 838
    obj_id_buf[buf_idx] = (char )'\000';
#line 841
    tmp___23 = atoll((char const   *)(obj_id_buf));
#line 841
    buf___0 = get_object(fp, (int )tmp___23, (xref_t const   *)(pdf->xrefs + i), & sz,
                         (int *)((void *)0));
    }
#line 842
    if (! buf___0) {
#line 842
      if ((pdf->xrefs + i)->is_linear) {
#line 842
        if (i + 1 < pdf->n_xrefs) {
          {
#line 843
          tmp___24 = atoll((char const   *)(obj_id_buf));
#line 843
          buf___0 = get_object(fp, (int )tmp___24, (xref_t const   *)(pdf->xrefs + (i + 1)),
                               & sz, (int *)((void *)0));
          }
        }
      }
    }
    {
#line 845
    load_creator_from_buf(fp, pdf->xrefs + i, (char const   *)buf___0);
#line 846
    free((void *)buf___0);
    }
    __Cont: /* CIL Label */ 
#line 798
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 849
  fseek(fp, start, 0);
  }
#line 850
  return;
}
}
#line 853 "/home/wheatley/newnew/temp/pdfresurrect-0.12/pdf.c"
static void load_creator_from_buf(FILE *fp , xref_t *xref , char const   *buf___0 ) 
{ 
  int is_xml ;
  char *c ;
  unsigned short const   **tmp ;

  {
#line 858
  if (! buf___0) {
#line 859
    return;
  }
  {
#line 862
  c = strstr(buf___0, "/Type");
  }
#line 862
  if (c) {
    {
#line 863
    while (1) {
      while_continue: /* CIL Label */ ;
#line 863
      if (*c) {
        {
#line 863
        tmp = __ctype_b_loc();
        }
#line 863
        if ((int const   )*(*tmp + (int )*c) & 8192) {
#line 863
          goto while_break;
        }
      } else {
#line 863
        goto while_break;
      }
#line 864
      c ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 867
  is_xml = 0;
#line 868
  if (c) {
#line 868
    if ((int )*c == 77) {
#line 869
      is_xml = 1;
    }
  }
#line 872
  if (is_xml) {
    {
#line 873
    load_creator_from_xml(xref, buf___0);
    }
  } else {
    {
#line 875
    load_creator_from_old_format(fp, xref, buf___0);
    }
  }
#line 876
  return;
}
}
#line 879 "/home/wheatley/newnew/temp/pdfresurrect-0.12/pdf.c"
static void load_creator_from_xml(xref_t *xref , char const   *buf___0 ) 
{ 


  {
#line 882
  return;
}
}
#line 885 "/home/wheatley/newnew/temp/pdfresurrect-0.12/pdf.c"
static void load_creator_from_old_format(FILE *fp , xref_t *xref , char const   *buf___0 ) 
{ 
  int i ;
  int n_eles ;
  int length ;
  int is_escaped ;
  int obj_id ;
  char *c ;
  char *ascii ;
  char *start ;
  char *s ;
  char *saved_buf_search ;
  char *obj ;
  pdf_creator_t *info ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;

  {
  {
#line 894
  info = new_creator(& n_eles);
#line 896
  i = 0;
  }
  {
#line 896
  while (1) {
    while_continue: /* CIL Label */ ;
#line 896
    if (! (i < n_eles)) {
#line 896
      goto while_break;
    }
    {
#line 898
    c = strstr(buf___0, (char const   *)((info + i)->key));
    }
#line 898
    if (! c) {
#line 899
      goto __Cont;
    }
    {
#line 902
    tmp = strlen((char const   *)((info + i)->key));
#line 902
    c += tmp;
    }
    {
#line 903
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 903
      tmp___0 = __ctype_b_loc();
      }
#line 903
      if (! ((int const   )*(*tmp___0 + (int )*c) & 8192)) {
#line 903
        goto while_break___0;
      }
#line 904
      c ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 907
    if ((int )*c == 47) {
#line 908
      goto __Cont;
    }
    {
#line 913
    saved_buf_search = (char *)((void *)0);
#line 913
    obj = saved_buf_search;
#line 914
    tmp___1 = __ctype_b_loc();
    }
#line 914
    if ((int const   )*(*tmp___1 + (int )*c) & 2048) {
      {
#line 916
      obj_id = atoi((char const   *)c);
#line 917
      saved_buf_search = c;
#line 918
      s = saved_buf_search;
#line 920
      obj = get_object(fp, obj_id, (xref_t const   *)xref, (size_t *)((void *)0),
                       (int *)((void *)0));
#line 921
      c = obj;
      }
      {
#line 924
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 924
        if (c) {
#line 924
          if (! ((int )*c != 40)) {
#line 924
            goto while_break___1;
          }
        } else {
#line 924
          goto while_break___1;
        }
#line 925
        c ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 928
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 928
        if (s) {
#line 928
          if ((int )*s != 13) {
#line 928
            goto _L;
          } else
#line 928
          if ((int )*s != 10) {
            _L: /* CIL Label */ 
#line 928
            if (! ((int )*s == 47)) {
#line 928
              goto while_break___2;
            }
          } else {
#line 928
            goto while_break___2;
          }
        } else {
#line 928
          goto while_break___2;
        }
#line 929
        s ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 930
      saved_buf_search = s;
    }
#line 934
    start = c;
#line 935
    is_escaped = 0;
#line 935
    length = is_escaped;
    {
#line 936
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 936
      if (c) {
#line 936
        if ((int )*c != 13) {
#line 936
          if ((int )*c != 10) {
#line 936
            if (! ((int )*c != 60)) {
#line 936
              goto while_break___3;
            }
          } else {
#line 936
            goto while_break___3;
          }
        } else {
#line 936
          goto while_break___3;
        }
      } else {
#line 936
        goto while_break___3;
      }
#line 939
      if (! is_escaped) {
#line 939
        if ((int )*c == 41) {
#line 940
          goto while_break___3;
        } else {
#line 939
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 941
      if ((int )*c == 92) {
#line 942
        is_escaped = 1;
      } else {
#line 944
        is_escaped = 0;
      }
#line 946
      c ++;
#line 947
      length ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 950
    if (length == 0) {
#line 951
      goto __Cont;
    }
#line 954
    if (length) {
#line 955
      length ++;
    }
#line 956
    if (length > 128) {
#line 956
      length = 128;
    } else {
#line 956
      length = length;
    }
    {
#line 957
    strncpy((char */* __restrict  */)((info + i)->value), (char const   */* __restrict  */)start,
            (size_t )length);
#line 958
    (info + i)->value[127] = (char )'\000';
    }
#line 961
    if (saved_buf_search) {
      {
#line 964
      free((void *)obj);
#line 965
      c = saved_buf_search;
      }
    }
    __Cont: /* CIL Label */ 
#line 896
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 970
  i = 0;
  {
#line 970
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 970
    if (! (i < n_eles)) {
#line 970
      goto while_break___4;
    }
    {
#line 971
    tmp___3 = strlen((char const   *)((info + i)->value));
#line 971
    ascii = decode_text_string((char const   *)((info + i)->value), tmp___3);
    }
#line 971
    if (ascii) {
      {
#line 973
      tmp___2 = strlen((char const   *)((info + i)->value));
#line 973
      strncpy((char */* __restrict  */)((info + i)->value), (char const   */* __restrict  */)ascii,
              tmp___2);
#line 974
      free((void *)ascii);
      }
    }
#line 970
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 977
  xref->creator = info;
#line 978
  xref->n_creator_entries = n_eles;
#line 979
  return;
}
}
#line 985 "/home/wheatley/newnew/temp/pdfresurrect-0.12/pdf.c"
static char *get_object_from_here(FILE *fp , size_t *size , int *is_stream ) 
{ 
  long start ;
  char buf___0[256] ;
  int obj_id ;
  xref_t xref ;
  xref_entry_t entry ;
  char *tmp ;

  {
  {
#line 993
  start = ftell(fp);
#line 996
  memset((void *)(buf___0), 0, (size_t )256);
#line 997
  fread((void */* __restrict  */)(buf___0), (size_t )255, (size_t )1, (FILE */* __restrict  */)fp);
#line 998
  obj_id = atoi((char const   *)(buf___0));
  }
#line 998
  if (! obj_id) {
    {
#line 1000
    fseek(fp, start, 0);
    }
#line 1001
    return ((char *)((void *)0));
  }
  {
#line 1005
  memset((void *)(& entry), 0, sizeof(xref_entry_t ));
#line 1006
  entry.obj_id = obj_id;
#line 1007
  entry.offset = start;
#line 1010
  memset((void *)(& xref), 0, sizeof(xref_t ));
#line 1011
  xref.n_entries = 1;
#line 1012
  xref.entries = & entry;
#line 1014
  fseek(fp, start, 0);
#line 1015
  tmp = get_object(fp, obj_id, (xref_t const   *)(& xref), size, is_stream);
  }
#line 1015
  return (tmp);
}
}
#line 1026 "/home/wheatley/newnew/temp/pdfresurrect-0.12/pdf.c"
static int const   blk_sz  =    (int const   )256;
#line 1019 "/home/wheatley/newnew/temp/pdfresurrect-0.12/pdf.c"
static char *get_object(FILE *fp , int obj_id , xref_t const   *xref , size_t *size ,
                        int *is_stream ) 
{ 
  int i ;
  int total_sz ;
  int read_sz ;
  int n_blks ;
  int search ;
  int stream ;
  size_t obj_sz ;
  char *c ;
  char *data ;
  long start ;
  xref_entry_t const   *entry ;
  void *tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;

  {
#line 1033
  if (size) {
#line 1034
    *size = (size_t )0;
  }
#line 1036
  if (is_stream) {
#line 1037
    *is_stream = 0;
  }
  {
#line 1039
  start = ftell(fp);
#line 1042
  entry = (xref_entry_t const   *)((void *)0);
#line 1043
  i = 0;
  }
  {
#line 1043
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1043
    if (! (i < (int )xref->n_entries)) {
#line 1043
      goto while_break;
    }
#line 1044
    if ((xref->entries + i)->obj_id == obj_id) {
#line 1046
      entry = (xref_entry_t const   *)(xref->entries + i);
#line 1047
      goto while_break;
    }
#line 1043
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1050
  if (! entry) {
#line 1051
    return ((char *)((void *)0));
  }
  {
#line 1054
  fseek(fp, (long )entry->offset, 0);
#line 1057
  obj_sz = (size_t )0;
#line 1058
  total_sz = 0;
#line 1059
  n_blks = 1;
#line 1060
  tmp = malloc((size_t )(blk_sz * (int const   )n_blks));
#line 1060
  data = (char *)tmp;
#line 1061
  memset((void *)data, 0, (size_t )(blk_sz * (int const   )n_blks));
#line 1064
  stream = 0;
  }
  {
#line 1065
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1065
    tmp___5 = fread((void */* __restrict  */)(data + total_sz), (size_t )1, (size_t )(blk_sz - 1),
                    (FILE */* __restrict  */)fp);
#line 1065
    read_sz = (int )tmp___5;
    }
#line 1065
    if (read_sz) {
      {
#line 1065
      tmp___6 = ferror(fp);
      }
#line 1065
      if (tmp___6) {
#line 1065
        goto while_break___0;
      }
    } else {
#line 1065
      goto while_break___0;
    }
#line 1067
    total_sz += read_sz;
#line 1069
    *(data + total_sz) = (char )'\000';
#line 1071
    if (total_sz + (int )blk_sz >= (int )(blk_sz * (int const   )n_blks)) {
      {
#line 1072
      n_blks ++;
#line 1072
      tmp___0 = realloc((void *)data, (size_t )(blk_sz * (int const   )n_blks));
#line 1072
      data = (char *)tmp___0;
      }
    }
#line 1074
    search = total_sz - read_sz;
#line 1075
    if (search < 0) {
#line 1076
      search = 0;
    }
    {
#line 1078
    c = strstr((char const   *)(data + search), "endobj");
    }
#line 1078
    if (c) {
      {
#line 1080
      tmp___1 = strlen("endobj");
#line 1080
      *((c + tmp___1) + 1) = (char )'\000';
#line 1081
      tmp___2 = strstr((char const   *)(data + search), "endobj");
#line 1081
      obj_sz = (size_t )((void *)tmp___2 - (void *)data);
#line 1082
      tmp___3 = strlen("endobj");
#line 1082
      obj_sz += tmp___3 + 1UL;
      }
#line 1083
      goto while_break___0;
    } else {
      {
#line 1085
      tmp___4 = strstr((char const   *)data, "stream");
      }
#line 1085
      if (tmp___4) {
#line 1086
        stream = 1;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1089
  clearerr(fp);
#line 1090
  fseek(fp, start, 0);
  }
#line 1092
  if (size) {
#line 1093
    *size = obj_sz;
  }
#line 1095
  if (is_stream) {
#line 1096
    *is_stream = stream;
  }
#line 1098
  return (data);
}
}
#line 1102 "/home/wheatley/newnew/temp/pdfresurrect-0.12/pdf.c"
static void add_kid(int id , xref_t *xref ) 
{ 
  void *tmp ;
  int tmp___0 ;

  {
#line 1105
  if ((unsigned long )(xref->n_kids + 1) * sizeof(int ) > (unsigned long )(xref->n_kids_allocs * 64)) {
    {
#line 1106
    (xref->n_kids_allocs) ++;
#line 1106
    tmp = realloc((void *)xref->kids, (unsigned long )xref->n_kids_allocs * (64UL * sizeof(int )));
#line 1106
    xref->kids = (int *)tmp;
    }
  }
#line 1109
  tmp___0 = xref->n_kids;
#line 1109
  (xref->n_kids) ++;
#line 1109
  *(xref->kids + tmp___0) = id;
#line 1110
  return;
}
}
#line 1114 "/home/wheatley/newnew/temp/pdfresurrect-0.12/pdf.c"
static void load_kids(FILE *fp , int pages_id , xref_t *xref ) 
{ 
  int dummy ;
  int buf_idx ;
  int kid_id ;
  char *data ;
  char *c ;
  char buf___0[32] ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
  {
#line 1120
  data = get_object(fp, pages_id, (xref_t const   *)xref, (size_t *)((void *)0), & dummy);
  }
#line 1121
  if (! data) {
    {
#line 1123
    free((void *)data);
    }
#line 1124
    return;
  } else {
    {
#line 1121
    c = strstr((char const   *)data, "/Kids");
    }
#line 1121
    if (! c) {
      {
#line 1123
      free((void *)data);
      }
#line 1124
      return;
    }
  }
  {
#line 1127
  c = strchr((char const   *)c, '[');
#line 1128
  buf_idx = 0;
#line 1129
  memset((void *)(buf___0), 0, sizeof(buf___0));
  }
  {
#line 1130
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1130
    c ++;
#line 1130
    if (! ((int )*c != 93)) {
#line 1130
      goto while_break;
    }
    {
#line 1132
    tmp___1 = __ctype_b_loc();
    }
#line 1132
    if ((int const   )*(*tmp___1 + (int )*c) & 2048) {
#line 1133
      tmp = buf_idx;
#line 1133
      buf_idx ++;
#line 1133
      buf___0[tmp] = *c;
    } else
#line 1132
    if ((int )*c == 32) {
#line 1133
      tmp = buf_idx;
#line 1133
      buf_idx ++;
#line 1133
      buf___0[tmp] = *c;
    } else {
      {
#line 1134
      tmp___0 = __ctype_b_loc();
      }
#line 1134
      if ((int const   )*(*tmp___0 + (int )*c) & 1024) {
        {
#line 1136
        kid_id = atoi((char const   *)(buf___0));
#line 1137
        add_kid(kid_id, xref);
#line 1138
        buf_idx = 0;
#line 1139
        memset((void *)(buf___0), 0, sizeof(buf___0));
#line 1142
        load_kids(fp, kid_id, xref);
        }
      } else
#line 1144
      if ((int )*c == 93) {
#line 1145
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1148
  free((void *)data);
  }
#line 1149
  return;
}
}
#line 1156 "/home/wheatley/newnew/temp/pdfresurrect-0.12/pdf.c"
static char buf[32]  ;
#line 1152 "/home/wheatley/newnew/temp/pdfresurrect-0.12/pdf.c"
static char const   *get_type(FILE *fp , int obj_id , xref_t const   *xref ) 
{ 
  int is_stream ;
  char *c ;
  char *obj ;
  char *endobj ;
  long start ;
  unsigned short const   **tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned long tmp___3 ;
  unsigned short const   **tmp___4 ;

  {
  {
#line 1159
  start = ftell(fp);
#line 1161
  obj = get_object(fp, obj_id, xref, (size_t *)((void *)0), & is_stream);
  }
#line 1161
  if (obj) {
#line 1161
    if (is_stream) {
#line 1161
      goto _L;
    } else {
      {
#line 1161
      endobj = strstr((char const   *)obj, "endobj");
      }
#line 1161
      if (! endobj) {
        _L: /* CIL Label */ 
        {
#line 1165
        free((void *)obj);
#line 1166
        fseek(fp, start, 0);
        }
#line 1168
        if (is_stream) {
#line 1169
          return ("Stream");
        } else {
#line 1171
          return ("Unknown");
        }
      }
    }
  } else {
#line 1161
    goto _L;
  }
#line 1175
  c = obj;
  {
#line 1176
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1176
    c = strstr((char const   *)c, "/Type");
    }
#line 1176
    if (c) {
#line 1176
      if (! ((unsigned long )c < (unsigned long )endobj)) {
#line 1176
        goto while_break;
      }
    } else {
#line 1176
      goto while_break;
    }
    {
#line 1177
    tmp = __ctype_b_loc();
#line 1177
    tmp___0 = strlen("/Type");
    }
#line 1177
    if ((int const   )*(*tmp + (int )*(c + tmp___0)) & 2048) {
#line 1179
      c ++;
#line 1180
      goto while_continue;
    } else {
#line 1183
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1185
  if (! c) {
    {
#line 1187
    free((void *)obj);
#line 1188
    fseek(fp, start, 0);
    }
#line 1189
    return ("Unknown");
  } else
#line 1185
  if (c) {
#line 1185
    if ((unsigned long )c > (unsigned long )endobj) {
      {
#line 1187
      free((void *)obj);
#line 1188
      fseek(fp, start, 0);
      }
#line 1189
      return ("Unknown");
    }
  }
  {
#line 1193
  tmp___1 = strlen("/Type");
#line 1193
  c += tmp___1;
  }
  {
#line 1194
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1194
    tmp___2 = __ctype_b_loc();
    }
#line 1194
    if (! ((int const   )*(*tmp___2 + (int )*c) & 8192)) {
#line 1194
      if (! ((int )*c == 47)) {
#line 1194
        goto while_break___0;
      }
    }
#line 1195
    c ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1198
  if ((unsigned long )(c - obj) < sizeof(buf)) {
#line 1198
    tmp___3 = (unsigned long )(c - obj);
  } else {
#line 1198
    tmp___3 = sizeof(buf);
  }
  {
#line 1198
  memcpy((void */* __restrict  */)(buf), (void const   */* __restrict  */)c, tmp___3);
#line 1199
  c = buf;
  }
  {
#line 1200
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 1200
    tmp___4 = __ctype_b_loc();
    }
#line 1200
    if ((int const   )*(*tmp___4 + (int )*c) & 8192) {
#line 1200
      goto while_break___1;
    } else
#line 1200
    if ((int )*c == 47) {
#line 1200
      goto while_break___1;
    } else
#line 1200
    if ((int )*c == 62) {
#line 1200
      goto while_break___1;
    }
#line 1201
    c ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1202
  *c = (char )'\000';
#line 1204
  free((void *)obj);
#line 1205
  fseek(fp, start, 0);
  }
#line 1207
  return ((char const   *)(buf));
}
}
#line 1225 "/home/wheatley/newnew/temp/pdfresurrect-0.12/pdf.c"
static char *get_header(FILE *fp ) 
{ 
  long start ;
  char *header ;
  void *tmp ;

  {
  {
#line 1232
  tmp = calloc((size_t )1, (size_t )1024);
#line 1232
  header = (char *)tmp;
#line 1234
  start = ftell(fp);
#line 1235
  fseek(fp, 0L, 0);
#line 1236
  fread((void */* __restrict  */)header, (size_t )1023, (size_t )1, (FILE */* __restrict  */)fp);
#line 1237
  fseek(fp, start, 0);
  }
#line 1239
  return (header);
}
}
#line 1243 "/home/wheatley/newnew/temp/pdfresurrect-0.12/pdf.c"
static char *decode_text_string(char const   *str , size_t str_len ) 
{ 
  int idx ;
  int is_hex ;
  int is_utf16be ;
  int ascii_idx ;
  char *ascii ;
  char hex_buf[5] ;
  unsigned int tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  long tmp___8 ;

  {
#line 1246
  hex_buf[0] = (char)0;
#line 1246
  tmp = 1U;
  {
#line 1246
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1246
    if (tmp >= 5U) {
#line 1246
      goto while_break;
    }
#line 1246
    hex_buf[tmp] = (char)0;
#line 1246
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1248
  ascii_idx = 0;
#line 1248
  idx = ascii_idx;
#line 1248
  is_utf16be = idx;
#line 1248
  is_hex = is_utf16be;
#line 1251
  if ((int const   )*(str + 0) == 40) {
    {
#line 1253
    tmp___0 = strlen(str);
#line 1253
    tmp___1 = malloc(tmp___0 + 1UL);
#line 1253
    ascii = (char *)tmp___1;
#line 1254
    tmp___2 = strlen(str);
#line 1254
    strncpy((char */* __restrict  */)ascii, (char const   */* __restrict  */)str,
            tmp___2 + 1UL);
    }
#line 1255
    return (ascii);
  } else
#line 1257
  if ((int const   )*(str + 0) == 60) {
#line 1259
    is_hex = 1;
#line 1260
    idx ++;
  }
#line 1264
  if (is_hex) {
#line 1264
    if (str_len > 5UL) {
#line 1264
      if ((int const   )*(str + idx) == 70) {
#line 1264
        if ((int const   )*(str + (idx + 1)) == 69) {
#line 1264
          if ((int const   )*(str + (idx + 2)) == 70) {
#line 1264
            if ((int const   )*(str + (idx + 3)) == 70) {
#line 1268
              is_utf16be = 1;
#line 1269
              idx += 4;
            } else {
#line 1272
              return ((char *)((void *)0));
            }
          } else {
#line 1272
            return ((char *)((void *)0));
          }
        } else {
#line 1272
          return ((char *)((void *)0));
        }
      } else {
#line 1272
        return ((char *)((void *)0));
      }
    } else {
#line 1272
      return ((char *)((void *)0));
    }
  } else {
#line 1272
    return ((char *)((void *)0));
  }
  {
#line 1275
  tmp___3 = malloc(str_len);
#line 1275
  ascii = (char *)tmp___3;
  }
  {
#line 1276
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1276
    if (! ((size_t )idx < str_len)) {
#line 1276
      goto while_break___0;
    }
    {
#line 1278
    tmp___4 = idx;
#line 1278
    idx ++;
#line 1278
    hex_buf[0] = (char )*(str + tmp___4);
#line 1279
    tmp___5 = idx;
#line 1279
    idx ++;
#line 1279
    hex_buf[1] = (char )*(str + tmp___5);
#line 1280
    tmp___6 = idx;
#line 1280
    idx ++;
#line 1280
    hex_buf[2] = (char )*(str + tmp___6);
#line 1281
    hex_buf[3] = (char )*(str + idx);
#line 1282
    tmp___7 = ascii_idx;
#line 1282
    ascii_idx ++;
#line 1282
    tmp___8 = strtol((char const   */* __restrict  */)(hex_buf), (char **/* __restrict  */)((void *)0),
                     16);
#line 1282
    *(ascii + tmp___7) = (char )tmp___8;
#line 1276
    idx ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1285
  return (ascii);
}
}
#line 1292 "/home/wheatley/newnew/temp/pdfresurrect-0.12/pdf.c"
static int get_next_eof(FILE *fp ) 
{ 
  int match ;
  int c ;
  char buf___0[6] ;
  long tmp ;

  {
#line 1295
  buf___0[0] = (char )'%';
#line 1295
  buf___0[1] = (char )'%';
#line 1295
  buf___0[2] = (char )'E';
#line 1295
  buf___0[3] = (char )'O';
#line 1295
  buf___0[4] = (char )'F';
#line 1295
  buf___0[5] = (char )'\000';
#line 1297
  match = 0;
  {
#line 1298
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1298
    c = fgetc(fp);
    }
#line 1298
    if (! (c != -1)) {
#line 1298
      goto while_break;
    }
#line 1300
    if (c == (int )buf___0[match]) {
#line 1301
      match ++;
    } else {
#line 1303
      match = 0;
    }
#line 1305
    if (match == 5) {
      {
#line 1306
      tmp = ftell(fp);
      }
#line 1306
      return ((int )(tmp - 5L));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1309
  return (-1);
}
}
