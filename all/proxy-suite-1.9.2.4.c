/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 65 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __gid_t gid_t;
#line 80 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 201 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned short u_int16_t;
#line 202 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int u_int32_t;
#line 78 "../common/com-socket.h"
struct buf_t {
   struct buf_t *next ;
   size_t len ;
   size_t cur ;
   int flg ;
   char dat[8] ;
};
#line 78 "../common/com-socket.h"
typedef struct buf_t BUF;
#line 86 "../common/com-socket.h"
struct hls_t {
   struct hls_t *next ;
   int sock ;
   int kill ;
   int ernr ;
   int retr ;
   int flag ;
   int more ;
   u_int32_t addr ;
   u_int16_t port ;
   char peer[32] ;
   char *ctyp ;
   BUF *wbuf ;
   BUF *rbuf ;
   size_t wcnt ;
   size_t rcnt ;
};
#line 86 "../common/com-socket.h"
typedef struct hls_t HLS;
#line 92 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-client.h"
struct __anonstruct_CONTEXT_42 {
   HLS *cli_ctrl ;
   HLS *cli_data ;
   HLS *srv_ctrl ;
   HLS *srv_data ;
   char *username ;
   char *userpass ;
   char *userauth ;
   int auth_mode ;
   char *magic_auth ;
   u_int32_t magic_addr ;
   u_int16_t magic_port ;
   int cli_mode ;
   u_int32_t cli_addr ;
   u_int16_t cli_port ;
   u_int16_t act_lrng ;
   u_int16_t act_urng ;
   u_int16_t pas_lrng ;
   u_int16_t pas_urng ;
   int same_adr ;
   int srv_mode ;
   u_int32_t srv_addr ;
   u_int16_t srv_port ;
   u_int16_t srv_lrng ;
   u_int16_t srv_urng ;
   char *curr_cmd ;
   int expect ;
   int timeout ;
   time_t sess_beg ;
   char xfer_cmd[16] ;
   char xfer_arg[1024] ;
   char xfer_rep[1024] ;
   time_t xfer_beg ;
   size_t xfer_rcnt ;
   size_t xfer_rsec ;
   size_t xfer_wcnt ;
   size_t xfer_wsec ;
};
#line 92 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-client.h"
typedef struct __anonstruct_CONTEXT_42 CONTEXT;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 37 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-cmds.h"
struct __anonstruct_CMD_61 {
   char *name ;
   void (*func)(CONTEXT * , char * ) ;
   void *regex ;
   int legal ;
   int len ;
};
#line 37 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-cmds.h"
typedef struct __anonstruct_CMD_61 CMD;
#line 43 "/usr/include/regex.h"
typedef unsigned long reg_syntax_t;
#line 368 "/usr/include/regex.h"
struct re_pattern_buffer {
   unsigned char *__buffer ;
   unsigned long __allocated ;
   unsigned long __used ;
   reg_syntax_t __syntax ;
   char *__fastmap ;
   unsigned char *__translate ;
   size_t re_nsub ;
   unsigned int __can_be_null : 1 ;
   unsigned int __regs_allocated : 2 ;
   unsigned int __fastmap_accurate : 1 ;
   unsigned int __no_sub : 1 ;
   unsigned int __not_bol : 1 ;
   unsigned int __not_eol : 1 ;
   unsigned int __newline_anchor : 1 ;
};
#line 434 "/usr/include/regex.h"
typedef struct re_pattern_buffer regex_t;
#line 437 "/usr/include/regex.h"
typedef int regoff_t;
#line 463 "/usr/include/regex.h"
struct __anonstruct_regmatch_t_37 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 463 "/usr/include/regex.h"
typedef struct __anonstruct_regmatch_t_37 regmatch_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 111 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-daemon.c"
struct __anonstruct_CLIENT_60 {
   pid_t pid ;
   char peer[32] ;
};
#line 111 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-daemon.c"
typedef struct __anonstruct_CLIENT_60 CLIENT;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 534 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 43 "../common/com-config.h"
extern void config_read(char *file , int dflg ) ;
#line 48
extern int config_bool(char *snam , char *name , int dflt ) ;
#line 49
extern char *config_str(char *snam , char *name , char *dflt ) ;
#line 66 "../common/com-misc.h"
extern char *misc_setprog(char *prog_str , char **usage_arr ) ;
#line 68
extern void misc_setvers(char *vers_str ) ;
#line 70
extern void misc_setdate(char *date_str ) ;
#line 72
extern char *misc_getvsdt(void) ;
#line 78
extern void misc_usage(char *fmt  , ...) ;
#line 83
extern char *misc_strtrim(char *s ) ;
#line 90
extern int misc_chroot(char *dir ) ;
#line 91
extern void misc_uidgid(uid_t uid , gid_t gid ) ;
#line 119 "../common/com-socket.h"
extern int socket_exec(int timeout , int *close_flag ) ;
#line 52 "../common/com-syslog.h"
extern void syslog_stderr(void) ;
#line 53
extern void syslog_open(char *name , char *level ) ;
#line 55
extern void syslog_error(char *fmt  , ...) ;
#line 57
extern void syslog_rotate(void) ;
#line 58
extern void syslog_close(void) ;
#line 145 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-client.h"
void client_run(void) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-daemon.h"
void daemon_init(int detach ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-main.h"
char const   *config_filename(void) ;
#line 7 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-vers.c"
static char prog_vers[8]  = 
#line 7 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-vers.c"
  {      (char )'1',      (char )'.',      (char )'9',      (char )'.', 
        (char )'2',      (char )'.',      (char )'4',      (char )'\000'};
#line 8 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-vers.c"
static char prog_date[20]  = 
#line 8
  {      (char )'2',      (char )'0',      (char )'0',      (char )'5', 
        (char )'/',      (char )'0',      (char )'1',      (char )'/', 
        (char )'1',      (char )'1',      (char )' ',      (char )'1', 
        (char )'3',      (char )':',      (char )'0',      (char )'3', 
        (char )':',      (char )'2',      (char )'8',      (char )'\000'};
#line 89 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-main.c"
static char progname[1024]  ;
#line 91 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-main.c"
static char *usage_arr[13]  = 
#line 91
  {      progname,      (char *)"    -c          Dump Config-File contents and exit",      (char *)"    -d          Forced to run in standalone mode",      (char *)"    -i          Forced to run in inetd mode", 
        (char *)"    -n          Do not detach from controlling terminal",      (char *)"    -f file     Name of the configuration file",      (char *)"                  (Default: /usr/local/etc/proxy-suite/ftp-proxy.conf)",      (char *)"    -v level    Send debuging output to /tmp/ftp-proxy.debug", 
        (char *)"                  (Level: 0 = silence, 4 = chatterbox)",      (char *)"                  !!! DISABLED AT COMPILE TIME FOR PRODUCTION USE !!!",      (char *)"    -V          Display program version and exit",      (char *)"", 
        (char *)((void *)0)};
#line 114
static void main_signal(int signo ) ;
#line 116 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-main.c"
static char *cfg_file  =    (char *)0;
#line 117 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-main.c"
static int close_flag  =    0;
#line 118 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-main.c"
static int config_flag  =    0;
#line 119 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-main.c"
static int rotate_flag  =    0;
#line 128 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-main.c"
static int srv_type  ;
#line 143 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-main.c"
char const   *config_filename(void) 
{ 


  {
#line 145
  return ((char const   *)cfg_file);
}
}
#line 161 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-main.c"
static void main_signal(int signo ) 
{ 


  {
  {
#line 168
  if (signo == 1) {
#line 168
    goto case_1;
  }
#line 171
  if (signo == 10) {
#line 171
    goto case_10;
  }
#line 174
  goto switch_default;
  case_1: /* CIL Label */ 
#line 169
  config_flag = 1;
#line 170
  goto switch_break;
  case_10: /* CIL Label */ 
#line 172
  rotate_flag = 1;
#line 173
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 175
  close_flag = 1;
  switch_break: /* CIL Label */ ;
  }
  {
#line 178
  signal(signo, & main_signal);
  }
#line 182
  return;
}
}
#line 197 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-main.c"
int main(int argc , char **argv ) 
{ 
  int c ;
  int detach ;
  int cfg_dump ;
  char *p ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
  {
#line 206
  signal(28, (void (*)(int  ))1);
#line 212
  p = misc_setprog(*(argv + 0), usage_arr);
#line 214
  snprintf((char */* __restrict  */)(progname), sizeof(progname), (char const   */* __restrict  */)"Usage: %s [option ...]",
           p);
#line 219
  misc_setvers(prog_vers);
#line 220
  misc_setdate(prog_date);
#line 225
  cfg_file = (char *)"/usr/local/etc/proxy-suite/ftp-proxy.conf";
#line 226
  cfg_dump = 0;
#line 227
  srv_type = 0;
#line 228
  detach = 1;
  }
  {
#line 233
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 233
    c = getopt(argc, (char * const  *)argv, "cdinf:V?");
    }
#line 233
    if (! (c != -1)) {
#line 233
      goto while_break;
    }
    {
#line 235
    if (c == 99) {
#line 235
      goto case_99;
    }
#line 238
    if (c == 100) {
#line 238
      goto case_100;
    }
#line 241
    if (c == 105) {
#line 241
      goto case_105;
    }
#line 244
    if (c == 110) {
#line 244
      goto case_110;
    }
#line 247
    if (c == 102) {
#line 247
      goto case_102;
    }
#line 255
    if (c == 86) {
#line 255
      goto case_86;
    }
#line 260
    goto switch_default;
    case_99: /* CIL Label */ 
#line 236
    cfg_dump = 1;
#line 237
    goto switch_break;
    case_100: /* CIL Label */ 
#line 239
    srv_type = 2;
#line 240
    goto switch_break;
    case_105: /* CIL Label */ 
#line 242
    srv_type = 1;
#line 243
    goto switch_break;
    case_110: /* CIL Label */ 
#line 245
    detach = 0;
#line 246
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 248
    cfg_file = misc_strtrim(optarg);
    }
#line 249
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 256
    tmp = misc_getvsdt();
#line 256
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
            tmp);
#line 257
    exit(0);
    }
#line 258
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 261
    misc_usage((char *)((void *)0));
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 271
  syslog_stderr();
#line 276
  config_read(cfg_file, cfg_dump);
#line 284
  tmp___0 = config_str((char *)((void *)0), (char *)"DestinationAddress", (char *)((void *)0));
  }
#line 284
  if ((unsigned long )((void *)0) == (unsigned long )tmp___0) {
    {
#line 284
    tmp___1 = config_bool((char *)((void *)0), (char *)"AllowTransProxy", 0);
    }
#line 284
    if (0 == tmp___1) {
      {
#line 284
      tmp___2 = config_bool((char *)((void *)0), (char *)"AllowMagicUser", 0);
      }
#line 284
      if (0 == tmp___2) {
        {
#line 288
        syslog_error((char *)"can\'t run without an destination address");
#line 289
        exit(1);
        }
      }
    }
  }
#line 295
  if (srv_type == 0) {
    {
#line 296
    p = config_str((char *)((void *)0), (char *)"ServerType", (char *)"inetd");
#line 297
    tmp___3 = strcasecmp((char const   *)p, "standalone");
    }
#line 297
    if (tmp___3 == 0) {
#line 298
      srv_type = 2;
    } else {
#line 300
      srv_type = 1;
    }
  }
#line 303
  if (srv_type == 1) {
    {
#line 310
    tmp___4 = config_str((char *)((void *)0), (char *)"ServerRoot", (char *)((void *)0));
#line 310
    misc_chroot(tmp___4);
#line 315
    misc_uidgid((uid_t )-1, (gid_t )-1);
#line 320
    p = config_str((char *)((void *)0), (char *)"LogDestination", (char *)((void *)0));
    }
#line 320
    if ((unsigned long )p != (unsigned long )((void *)0)) {
      {
#line 321
      tmp___5 = config_str((char *)((void *)0), (char *)"LogLevel", (char *)((void *)0));
#line 321
      syslog_open(p, tmp___5);
      }
    } else {
      {
#line 322
      syslog_close();
      }
    }
    {
#line 324
    client_run();
#line 325
    exit(0);
    }
  }
  {
#line 335
  daemon_init(detach);
#line 340
  signal(2, & main_signal);
#line 341
  signal(15, & main_signal);
#line 342
  signal(3, & main_signal);
#line 343
  signal(1, & main_signal);
#line 344
  signal(10, & main_signal);
  }
  {
#line 349
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 349
    if (! (close_flag == 0)) {
#line 349
      goto while_break___0;
    }
#line 353
    if (config_flag) {
      {
#line 358
      config_flag = 0;
#line 359
      config_read(cfg_file, 0);
#line 364
      tmp___6 = config_str((char *)((void *)0), (char *)"LogLevel", (char *)((void *)0));
#line 364
      tmp___7 = config_str((char *)((void *)0), (char *)"LogDestination", (char *)((void *)0));
#line 364
      syslog_open(tmp___7, tmp___6);
      }
    }
#line 372
    if (rotate_flag) {
      {
#line 373
      rotate_flag = 0;
#line 374
      syslog_rotate();
      }
    }
    {
#line 380
    socket_exec(60, & close_flag);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 386
  exit(0);
  }
}
}
#line 79 "../common/com-misc.h"
extern void misc_die(char *file , int line , char *fmt  , ...) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-ldap.h"
int ldap_setup_user(CONTEXT *ctx___0 , char *who , char *pwd ) ;
#line 148 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-ldap.c"
int ldap_setup_user(CONTEXT *ctx___0 , char *who , char *pwd ) 
{ 
  char *ptr ;
  int ver ;

  {
#line 150
  ptr = (char *)0;
#line 151
  ver = 0;
#line 156
  ver = ver;
#line 157
  ptr = ptr;
#line 158
  pwd = pwd;
#line 163
  if (ctx___0) {
#line 163
    if (who) {
#line 163
      if (! *who) {
        {
#line 164
        misc_die((char *)"/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-ldap.c",
                 164, (char *)"ldap_setup_user: ?ctx? ?who?");
        }
      }
    } else {
      {
#line 164
      misc_die((char *)"/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-ldap.c",
               164, (char *)"ldap_setup_user: ?ctx? ?who?");
      }
    }
  } else {
    {
#line 164
    misc_die((char *)"/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-ldap.c",
             164, (char *)"ldap_setup_user: ?ctx? ?who?");
    }
  }
#line 237
  return (0);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 390
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 675
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 149
extern ssize_t send(int __fd , void const   *__buf , size_t __n , int __flags ) ;
#line 377 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 47 "../common/com-config.h"
extern int config_int(char *snam , char *name , int dflt ) ;
#line 51
extern u_int32_t config_addr(char *snam , char *name , u_int32_t dflt ) ;
#line 52
extern u_int16_t config_port(char *snam , char *name , u_int16_t dflt ) ;
#line 76 "../common/com-misc.h"
extern void misc_free(char *file , int line , void *ptr ) ;
#line 88
extern char *misc_strncpy(char *s1 , char const   *s2 , size_t len ) ;
#line 110 "../common/com-socket.h"
extern HLS *socket_init(int sock ) ;
#line 111
extern void socket_opts(int sock , int kind ) ;
#line 112
extern void socket_kill(HLS *hls ) ;
#line 113
extern char *socket_gets(HLS *hls , char *ptr , int len ) ;
#line 116
extern int socket_printf(HLS *hls , char *fmt  , ...) ;
#line 121
extern char *socket_msgline(char *fmt ) ;
#line 123
extern u_int16_t socket_d_bind(int sock , u_int32_t addr , u_int16_t lrng , u_int16_t urng ,
                               int incr ) ;
#line 132
extern u_int16_t socket_d_connect(u_int32_t addr , u_int16_t port , u_int32_t ladr ,
                                  u_int16_t lrng , u_int16_t urng , HLS **phls , char *ctyp ,
                                  int incr ) ;
#line 140
extern char *socket_addr2str(u_int32_t addr ) ;
#line 141
extern u_int32_t socket_sck2addr(int sock , int peer , u_int16_t *port ) ;
#line 54 "../common/com-syslog.h"
extern void syslog_write(int level , char *fmt  , ...) ;
#line 146 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-client.h"
void client_reinit(void) ;
#line 147
void client_respond(int code , char *file , char *fmt  , ...) ;
#line 148
void client_data_reset(int mode ) ;
#line 150
int client_setup(char *pwd ) ;
#line 151
void client_srv_open(void) ;
#line 53 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-cmds.h"
CMD *cmds_get_list(void) ;
#line 55
void cmds_set_allow(char *allow ) ;
#line 58
char *cmds_reg_comp(void **ppre , char *ptr ) ;
#line 59
char *cmds_reg_exec(void *regex , char *str___0 ) ;
#line 81 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-client.c"
static void client_cli_ctrl_read(char *str___0 ) ;
#line 82
static void client_srv_ctrl_read(char *str___0 ) ;
#line 83
static void client_srv_passive(char *arg ) ;
#line 84
static void client_xfer_fireup(void) ;
#line 85
static int client_setup_file(CONTEXT *ctx___0 , char *who ) ;
#line 90 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-client.c"
static int close_flag___0  =    0;
#line 92 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-client.c"
static CONTEXT ctx  ;
#line 107 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-client.c"
static void client_signal(int signo ) 
{ 


  {
  {
#line 113
  close_flag___0 = 1;
#line 115
  signal(signo, & client_signal);
  }
#line 119
  return;
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-client.c"
void client_run(void) 
{ 
  int sock ;
  int need ;
  int diff ;
  char str___0[8192] ;
  char *p ;
  char *q ;
  FILE *fp ;
  BUF *buf ;
  size_t tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  u_int32_t tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  time_t tmp___6 ;
  size_t tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  time_t tmp___13 ;
  char const   *tmp___14 ;

  {
  {
#line 145
  signal(2, & client_signal);
#line 146
  signal(15, & client_signal);
#line 147
  signal(3, & client_signal);
#line 148
  signal(1, & client_signal);
#line 149
  signal(17, (void (*)(int  ))1);
#line 150
  signal(10, (void (*)(int  ))1);
#line 155
  memset((void *)(& ctx), 0, sizeof(ctx));
#line 156
  ctx.sess_beg = time((time_t *)((void *)0));
#line 157
  ctx.cli_mode = 1;
#line 158
  ctx.expect = 0;
#line 159
  ctx.timeout = config_int((char *)((void *)0), (char *)"TimeOut", 900);
#line 161
  sock = fileno(stdin);
#line 168
  p = config_str((char *)((void *)0), (char *)"DenyMessage", (char *)((void *)0));
  }
#line 169
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
#line 169
    fp = fopen((char const   */* __restrict  */)p, (char const   */* __restrict  */)"r");
    }
#line 169
    if ((unsigned long )fp != (unsigned long )((void *)0)) {
      {
#line 170
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 170
        tmp___0 = fgets((char */* __restrict  */)(str___0), (int )(sizeof(str___0) - 4UL),
                        (FILE */* __restrict  */)fp);
        }
#line 170
        if (! ((unsigned long )tmp___0 != (unsigned long )((void *)0))) {
#line 170
          goto while_break;
        }
        {
#line 171
        p = socket_msgline(str___0);
#line 172
        q = strchr((char const   *)p, '\n');
        }
#line 172
        if ((unsigned long )q != (unsigned long )((void *)0)) {
          {
#line 173
          strcpy((char */* __restrict  */)q, (char const   */* __restrict  */)"\r\n");
          }
        } else {
          {
#line 175
          strcat((char */* __restrict  */)p, (char const   */* __restrict  */)"\r\n");
          }
        }
        {
#line 176
        send(sock, (void const   *)"421-", (size_t )4, 0);
#line 177
        tmp = strlen((char const   *)p);
#line 177
        send(sock, (void const   *)p, tmp, 0);
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 179
      fclose(fp);
#line 180
      p = config_str((char *)((void *)0), (char *)"DenyString", (char *)((void *)0));
      }
#line 180
      if ((unsigned long )p != (unsigned long )((void *)0)) {
        {
#line 181
        p = socket_msgline(p);
        }
      } else {
#line 183
        p = (char *)"Service not available";
      }
      {
#line 184
      send(sock, (void const   *)"421 ", (size_t )4, 0);
#line 185
      tmp___1 = strlen((char const   *)p);
#line 185
      send(sock, (void const   *)p, tmp___1, 0);
#line 186
      send(sock, (void const   *)".\r\n", (size_t )3, 0);
#line 187
      tmp___2 = socket_sck2addr(sock, 2, (u_int16_t *)((void *)0));
#line 187
      p = socket_addr2str(tmp___2);
#line 188
      close(sock);
#line 189
      syslog_write(14, (char *)"reject: \'%s\' (DenyMessage)", p);
#line 190
      exit(0);
      }
    }
  }
  {
#line 196
  ctx.cli_ctrl = socket_init(sock);
  }
#line 196
  if ((unsigned long )ctx.cli_ctrl == (unsigned long )((void *)0)) {
    {
#line 197
    misc_die((char *)"/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-client.c",
             197, (char *)"client_run: ?cli_ctrl?");
    }
  }
  {
#line 198
  (ctx.cli_ctrl)->ctyp = (char *)"Cli-Ctrl";
#line 203
  syslog_write(12, (char *)"connect from %s", (ctx.cli_ctrl)->peer);
#line 208
  p = config_str((char *)((void *)0), (char *)"WelcomeString", (char *)((void *)0));
  }
#line 208
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 209
    p = (char *)"%h FTP server (Version %v - %b) ready";
  }
  {
#line 210
  tmp___3 = socket_msgline(p);
#line 210
  misc_strncpy(str___0, (char const   *)tmp___3, sizeof(str___0));
#line 211
  tmp___4 = config_str((char *)((void *)0), (char *)"WelcomeMessage", (char *)((void *)0));
#line 211
  client_respond(220, tmp___4, str___0);
  }
  {
#line 217
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 217
    if (! (close_flag___0 == 0)) {
#line 217
      goto while_break___0;
    }
#line 227
    need = 1;
#line 228
    if (ctx.cli_ctrl) {
#line 228
      if ((ctx.cli_ctrl)->rbuf) {
#line 229
        need = 0;
      }
    }
#line 230
    if (ctx.srv_ctrl) {
#line 230
      if ((ctx.srv_ctrl)->rbuf) {
#line 231
        need = 0;
      }
    }
#line 232
    if (ctx.cli_ctrl) {
#line 232
      if ((ctx.cli_ctrl)->more > 0) {
#line 234
        need = 1;
      } else {
#line 232
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 232
    if (ctx.srv_ctrl) {
#line 232
      if ((ctx.srv_ctrl)->more > 0) {
#line 234
        need = 1;
      }
    }
#line 240
    if (ctx.srv_data) {
#line 240
      if (ctx.cli_data) {
#line 241
        if ((ctx.srv_data)->wbuf) {
#line 242
          (ctx.cli_data)->more = -1;
        } else {
#line 244
          (ctx.cli_data)->more = 0;
        }
#line 246
        if ((ctx.cli_data)->wbuf) {
#line 247
          (ctx.srv_data)->more = -1;
        } else {
#line 249
          (ctx.srv_data)->more = 0;
        }
      }
    }
#line 253
    if (need != 0) {
      {
#line 254
      tmp___5 = socket_exec(ctx.timeout, & close_flag___0);
      }
#line 254
      if (tmp___5 <= 0) {
#line 255
        goto while_break___0;
      }
    }
#line 264
    if ((unsigned long )ctx.cli_ctrl != (unsigned long )((void *)0)) {
#line 264
      if ((ctx.cli_ctrl)->sock == -1) {
#line 265
        close_flag___0 = 1;
      }
    }
#line 267
    if ((unsigned long )ctx.srv_ctrl != (unsigned long )((void *)0)) {
#line 267
      if ((ctx.srv_ctrl)->sock == -1) {
#line 275
        if ((unsigned long )ctx.cli_data != (unsigned long )((void *)0)) {
#line 276
          (ctx.cli_data)->kill = 1;
        }
#line 277
        if ((unsigned long )ctx.srv_data != (unsigned long )((void *)0)) {
#line 278
          (ctx.srv_data)->kill = 1;
        }
#line 283
        if ((ctx.cli_ctrl)->kill == 0) {
          {
#line 284
          client_respond(421, (char *)((void *)0), (char *)"Service not available, closing control connection");
          }
        }
        {
#line 292
        socket_kill(ctx.srv_ctrl);
#line 293
        ctx.srv_ctrl = (HLS *)((void *)0);
        }
      }
    }
#line 296
    if ((unsigned long )ctx.cli_data != (unsigned long )((void *)0)) {
#line 296
      if ((ctx.cli_data)->sock == -1) {
#line 304
        if ((int )ctx.xfer_rep[0] != 0) {
          {
#line 305
          socket_printf(ctx.cli_ctrl, (char *)"%s\r\n", ctx.xfer_rep);
#line 307
          memset((void *)(ctx.xfer_rep), 0, sizeof(ctx.xfer_rep));
          }
        } else
#line 310
        if (ctx.expect == 6) {
#line 311
          ctx.expect = 7;
        }
#line 317
        if (ctx.xfer_beg == 0L) {
          {
#line 318
          ctx.xfer_beg = time((time_t *)((void *)0));
          }
        }
        {
#line 319
        tmp___6 = time((time_t *)((void *)0));
#line 319
        diff = (int )(tmp___6 - ctx.xfer_beg);
        }
#line 320
        if (diff < 1) {
#line 321
          diff = 1;
        }
#line 326
        if ((ctx.cli_data)->rcnt) {
#line 326
          tmp___7 = (ctx.cli_data)->rcnt;
        } else {
#line 326
          tmp___7 = (ctx.cli_data)->wcnt;
        }
#line 326
        if ((ctx.cli_data)->rcnt) {
#line 326
          tmp___8 = "sent";
        } else {
#line 326
          tmp___8 = "read";
        }
#line 326
        if ((ctx.cli_data)->ernr) {
#line 326
          tmp___9 = "failed";
        } else {
#line 326
          tmp___9 = "completed";
        }
        {
#line 326
        syslog_write(12, (char *)"Transfer for %s %s: %s \'%s\' %s %u/%d byte/sec",
                     (ctx.cli_ctrl)->peer, tmp___9, ctx.xfer_cmd, ctx.xfer_arg, tmp___8,
                     tmp___7, diff);
        }
#line 339
        if ((ctx.cli_data)->rcnt) {
#line 340
          ctx.xfer_rsec += (size_t )diff;
        }
#line 341
        ctx.xfer_rcnt += (ctx.cli_data)->rcnt;
#line 342
        if ((ctx.cli_data)->wcnt) {
#line 343
          ctx.xfer_wsec += (size_t )diff;
        }
        {
#line 344
        ctx.xfer_wcnt += (ctx.cli_data)->wcnt;
#line 349
        client_data_reset(0);
        }
#line 354
        if ((unsigned long )ctx.srv_data != (unsigned long )((void *)0)) {
#line 355
          (ctx.srv_data)->kill = 1;
        }
        {
#line 360
        socket_kill(ctx.cli_data);
#line 361
        ctx.cli_data = (HLS *)((void *)0);
        }
      }
    }
#line 364
    if ((unsigned long )ctx.srv_data != (unsigned long )((void *)0)) {
#line 364
      if ((ctx.srv_data)->sock == -1) {
#line 374
        if ((unsigned long )ctx.cli_data != (unsigned long )((void *)0)) {
#line 375
          if (0 != (ctx.srv_data)->ernr) {
#line 376
            (ctx.cli_data)->ernr = -1;
#line 377
            (ctx.cli_data)->kill = 1;
          }
          {
#line 379
          tmp___10 = config_bool((char *)((void *)0), (char *)"FailResetsPasv", 0);
          }
#line 379
          if (tmp___10) {
#line 380
            (ctx.cli_data)->kill = 1;
          } else
#line 381
          if (ctx.expect != 4) {
#line 382
            (ctx.cli_data)->kill = 1;
          }
        }
        {
#line 389
        socket_kill(ctx.srv_data);
#line 390
        ctx.srv_data = (HLS *)((void *)0);
        }
      }
    }
#line 396
    if ((unsigned long )ctx.cli_ctrl != (unsigned long )((void *)0)) {
#line 396
      if ((unsigned long )(ctx.cli_ctrl)->rbuf != (unsigned long )((void *)0)) {
        {
#line 397
        tmp___11 = socket_gets(ctx.cli_ctrl, str___0, (int )sizeof(str___0));
        }
#line 397
        if ((unsigned long )tmp___11 != (unsigned long )((void *)0)) {
          {
#line 399
          client_cli_ctrl_read(str___0);
          }
        }
      }
    }
#line 401
    if ((unsigned long )ctx.srv_ctrl != (unsigned long )((void *)0)) {
#line 401
      if ((unsigned long )(ctx.srv_ctrl)->rbuf != (unsigned long )((void *)0)) {
        {
#line 402
        tmp___12 = socket_gets(ctx.srv_ctrl, str___0, (int )sizeof(str___0));
        }
#line 402
        if ((unsigned long )tmp___12 != (unsigned long )((void *)0)) {
          {
#line 404
          client_srv_ctrl_read(str___0);
          }
        }
      }
    }
#line 411
    if ((unsigned long )ctx.cli_data != (unsigned long )((void *)0)) {
#line 411
      if ((unsigned long )ctx.srv_data != (unsigned long )((void *)0)) {
#line 412
        if ((unsigned long )(ctx.cli_data)->rbuf != (unsigned long )((void *)0)) {
#line 416
          if ((unsigned long )(ctx.srv_data)->wbuf == (unsigned long )((void *)0)) {
#line 417
            (ctx.srv_data)->wbuf = (ctx.cli_data)->rbuf;
          } else {
#line 420
            buf = (ctx.srv_data)->wbuf;
            {
#line 420
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 420
              if (buf) {
#line 420
                if (! buf->next) {
#line 420
                  goto while_break___1;
                }
              } else {
#line 420
                goto while_break___1;
              }
#line 420
              buf = buf->next;
            }
            while_break___1: /* CIL Label */ ;
            }
#line 424
            buf->next = (ctx.cli_data)->rbuf;
          }
#line 426
          (ctx.cli_data)->rbuf = (BUF *)((void *)0);
        }
#line 428
        if ((unsigned long )(ctx.srv_data)->rbuf != (unsigned long )((void *)0)) {
#line 432
          if ((unsigned long )(ctx.cli_data)->wbuf == (unsigned long )((void *)0)) {
#line 433
            (ctx.cli_data)->wbuf = (ctx.srv_data)->rbuf;
          } else {
#line 436
            buf = (ctx.cli_data)->wbuf;
            {
#line 436
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 436
              if (buf) {
#line 436
                if (! buf->next) {
#line 436
                  goto while_break___2;
                }
              } else {
#line 436
                goto while_break___2;
              }
#line 436
              buf = buf->next;
            }
            while_break___2: /* CIL Label */ ;
            }
#line 440
            buf->next = (ctx.srv_data)->rbuf;
          }
#line 442
          (ctx.srv_data)->rbuf = (BUF *)((void *)0);
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 454
  tmp___13 = time((time_t *)((void *)0));
  }
#line 454
  if (ctx.cli_ctrl) {
#line 454
    tmp___14 = (char const   *)((ctx.cli_ctrl)->peer);
  } else {
#line 454
    tmp___14 = "unknown peer";
  }
  {
#line 454
  syslog_write(12, (char *)"closing connect from %s after %d secs - read %d/%d, sent %d/%d byte/sec",
               tmp___14, tmp___13 - ctx.sess_beg, ctx.xfer_wcnt, ctx.xfer_wsec, ctx.xfer_rcnt,
               ctx.xfer_rsec);
#line 464
  ctx.magic_auth = (char *)((void *)0);
  }
#line 465
  if ((unsigned long )ctx.userauth != (unsigned long )((void *)0)) {
    {
#line 466
    misc_free((char *)"/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-client.c",
              466, (void *)ctx.userauth);
#line 467
    ctx.userauth = (char *)((void *)0);
    }
  }
#line 469
  if ((unsigned long )ctx.username != (unsigned long )((void *)0)) {
    {
#line 470
    misc_free((char *)"/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-client.c",
              470, (void *)ctx.username);
#line 471
    ctx.username = (char *)((void *)0);
    }
  }
#line 473
  if ((unsigned long )ctx.userpass != (unsigned long )((void *)0)) {
    {
#line 474
    misc_free((char *)"/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-client.c",
              474, (void *)ctx.userpass);
#line 475
    ctx.userpass = (char *)((void *)0);
    }
  }
  {
#line 481
  exit(0);
  }
}
}
#line 497 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-client.c"
static void client_cli_ctrl_read(char *str___0 ) 
{ 
  char *arg ;
  CMD *cmd ;
  int c ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  char const   *tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *p ;
  char const   *tmp___12 ;
  size_t tmp___13 ;

  {
#line 503
  if ((unsigned long )str___0 == (unsigned long )((void *)0)) {
#line 507
    return;
  }
  {
#line 513
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 513
    arg = strchr((char const   *)str___0, 255);
    }
#line 513
    if (! ((unsigned long )arg != (unsigned long )((void *)0))) {
#line 513
      goto while_break;
    }
#line 514
    c = (int )*(arg + 1) & 255;
    {
#line 517
    if (c == 252) {
#line 517
      goto case_252;
    }
#line 517
    if (c == 251) {
#line 517
      goto case_252;
    }
#line 533
    if (c == 254) {
#line 533
      goto case_254;
    }
#line 533
    if (c == 253) {
#line 533
      goto case_254;
    }
#line 548
    if (c == 255) {
#line 548
      goto case_255;
    }
#line 553
    if (c == 242) {
#line 553
      goto case_242;
    }
#line 553
    if (c == 244) {
#line 553
      goto case_242;
    }
#line 560
    goto switch_default;
    case_252: /* CIL Label */ 
    case_251: /* CIL Label */ 
    {
#line 521
    syslog_write(13, (char *)"WILL/WONT refused for %s", (ctx.cli_ctrl)->peer);
#line 524
    socket_printf(ctx.cli_ctrl, (char *)"%c%c%c", 255, 254, (int )*(arg + 2));
    }
#line 526
    if (*(arg + 2)) {
      {
#line 527
      tmp = strlen((char const   *)arg);
#line 527
      memmove((void *)arg, (void const   *)(arg + 3), tmp - 2UL);
      }
    } else {
      {
#line 529
      tmp___0 = strlen((char const   *)arg);
#line 529
      memmove((void *)arg, (void const   *)(arg + 1), tmp___0);
      }
    }
#line 530
    goto switch_break;
    case_254: /* CIL Label */ 
    case_253: /* CIL Label */ 
    {
#line 537
    syslog_write(13, (char *)"DO/DONT refused for %s", (ctx.cli_ctrl)->peer);
#line 540
    socket_printf(ctx.cli_ctrl, (char *)"%c%c%c", 255, 252, (int )*(arg + 2));
    }
#line 542
    if (*(arg + 2)) {
      {
#line 543
      tmp___1 = strlen((char const   *)arg);
#line 543
      memmove((void *)arg, (void const   *)(arg + 3), tmp___1 - 2UL);
      }
    } else {
      {
#line 545
      tmp___2 = strlen((char const   *)arg);
#line 545
      memmove((void *)arg, (void const   *)(arg + 1), tmp___2);
      }
    }
#line 546
    goto switch_break;
    case_255: /* CIL Label */ 
    {
#line 549
    tmp___3 = strlen((char const   *)arg);
#line 549
    memmove((void *)arg, (void const   *)(arg + 1), tmp___3);
    }
#line 550
    goto switch_break;
    case_242: /* CIL Label */ 
    case_244: /* CIL Label */ 
#line 554
    if (c == 244) {
#line 554
      tmp___4 = "IP";
    } else {
#line 554
      tmp___4 = "DM";
    }
    {
#line 554
    syslog_write(12, (char *)"IAC-%s from %s", tmp___4, (ctx.cli_ctrl)->peer);
#line 557
    tmp___5 = strlen((char const   *)arg);
#line 557
    memmove((void *)arg, (void const   *)(arg + 2), tmp___5 - 1UL);
    }
#line 558
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 561
    tmp___6 = strlen((char const   *)arg);
#line 561
    memmove((void *)arg, (void const   *)(arg + 1), tmp___6);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 568
  if ((int )*(str___0 + 0) == 0) {
#line 572
    return;
  }
  {
#line 578
  arg = strchr((char const   *)str___0, ' ');
  }
#line 578
  if ((unsigned long )arg == (unsigned long )((void *)0)) {
    {
#line 579
    arg = strchr((char const   *)str___0, '\t');
    }
  }
#line 580
  if ((unsigned long )arg == (unsigned long )((void *)0)) {
#line 581
    arg = (char *)"";
  } else {
    {
#line 583
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 583
      if (! ((int )*arg == 32)) {
#line 583
        if (! ((int )*arg == 9)) {
#line 583
          goto while_break___0;
        }
      }
#line 584
      tmp___7 = arg;
#line 584
      arg ++;
#line 584
      *tmp___7 = (char )'\000';
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 597
  cmd = cmds_get_list();
  }
  {
#line 597
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 597
    if (! ((unsigned long )cmd->name != (unsigned long )((void *)0))) {
#line 597
      goto while_break___1;
    }
    {
#line 598
    tmp___8 = strcasecmp("USER", (char const   *)cmd->name);
    }
#line 598
    if (tmp___8 == 0) {
#line 599
      cmd->legal = 1;
    }
    {
#line 600
    tmp___9 = strcasecmp((char const   *)str___0, (char const   *)cmd->name);
    }
#line 600
    if (tmp___9 != 0) {
#line 601
      goto __Cont;
    }
#line 602
    if (cmd->legal == 0) {
      {
#line 602
      tmp___10 = strcasecmp("QUIT", (char const   *)cmd->name);
      }
#line 602
      if (tmp___10) {
        {
#line 603
        client_respond(502, (char *)((void *)0), (char *)"\'%.32s\': command not implemented",
                       str___0);
#line 605
        syslog_write(13, (char *)"\'%.32s\' from %s not allowed", str___0, (ctx.cli_ctrl)->peer);
        }
#line 608
        return;
      }
    }
#line 611
    if ((unsigned long )cmd->regex != (unsigned long )((void *)0)) {
      {
#line 613
      p = cmds_reg_exec(cmd->regex, arg);
      }
#line 614
      if ((unsigned long )p != (unsigned long )((void *)0)) {
        {
#line 615
        client_respond(501, (char *)((void *)0), (char *)"\'%.32s\': syntax error in arguments",
                       str___0);
#line 618
        tmp___13 = strlen((char const   *)arg);
        }
#line 618
        if (tmp___13 > 128UL) {
#line 618
          tmp___12 = "...";
        } else {
#line 618
          tmp___12 = "";
        }
        {
#line 618
        syslog_write(13, (char *)"bad arg \'%.128s\'%s for \'%s\' from %s: %s", arg,
                     tmp___12, cmd->name, (ctx.cli_ctrl)->peer, p);
        }
#line 624
        return;
      }
    }
    {
#line 628
    ctx.curr_cmd = str___0;
#line 629
    (*(cmd->func))(& ctx, arg);
    }
#line 630
    return;
    __Cont: /* CIL Label */ 
#line 597
    cmd ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 636
  client_respond(500, (char *)((void *)0), (char *)"\'%.32s\': command unrecognized",
                 str___0);
#line 637
  syslog_write(13, (char *)"unknown \'%.32s\' from %s", str___0, (ctx.cli_ctrl)->peer);
  }
#line 639
  return;
}
}
#line 654 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-client.c"
static void client_srv_ctrl_read(char *str___0 ) 
{ 
  int code ;
  int c1 ;
  int c2 ;
  int c3 ;
  char *arg ;
  int tmp ;

  {
#line 659
  if ((unsigned long )str___0 == (unsigned long )((void *)0)) {
#line 660
    return;
  }
  {
#line 662
  syslog_write(1, (char *)"from Server-PI (%d): \'%.512s\'", (ctx.srv_ctrl)->sock,
               str___0);
  }
#line 672
  if ((int )*str___0 < 50) {
#line 672
    goto _L;
  } else
#line 672
  if ((int )*str___0 > 53) {
#line 672
    goto _L;
  } else
#line 672
  if ((int )*(str___0 + 3) != 32) {
    _L: /* CIL Label */ 
#line 677
    if (ctx.expect == 1) {
#line 678
      return;
    }
#line 679
    if (ctx.expect == 2) {
#line 679
      if (0 != ctx.auth_mode) {
#line 680
        return;
      }
    }
    {
#line 687
    socket_printf(ctx.cli_ctrl, (char *)"%s\r\n", str___0);
    }
#line 688
    return;
  }
  {
#line 694
  code = atoi((char const   *)str___0);
  }
#line 694
  if (code < 200) {
    {
#line 695
    syslog_error((char *)"bad response %d from server for %s", code, (ctx.srv_ctrl)->peer);
    }
#line 697
    return;
  } else
#line 694
  if (code > 599) {
    {
#line 695
    syslog_error((char *)"bad response %d from server for %s", code, (ctx.srv_ctrl)->peer);
    }
#line 697
    return;
  }
#line 699
  c1 = code / 100;
#line 700
  c2 = (code % 100) / 10;
#line 701
  c3 = code % 10;
#line 702
  arg = str___0 + 3;
  {
#line 702
  while (1) {
    while_continue: /* CIL Label */ ;
#line 702
    if (! ((int )*arg == 32)) {
#line 702
      goto while_break;
    }
#line 702
    arg ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 709
  if (ctx.expect == 1) {
#line 709
    goto case_1;
  }
#line 731
  if (ctx.expect == 2) {
#line 731
    goto case_2;
  }
#line 776
  if (ctx.expect == 3) {
#line 776
    goto case_3;
  }
#line 783
  if (ctx.expect == 4) {
#line 783
    goto case_4;
  }
#line 794
  if (ctx.expect == 5) {
#line 794
    goto case_5;
  }
#line 805
  if (ctx.expect == 6) {
#line 805
    goto case_6;
  }
#line 824
  if (ctx.expect == 7) {
#line 824
    goto case_7;
  }
#line 829
  if (ctx.expect == 0) {
#line 829
    goto case_0;
  }
#line 708
  goto switch_break;
  case_1: /* CIL Label */ 
#line 713
  if (c1 == 2) {
    {
#line 714
    socket_printf(ctx.srv_ctrl, (char *)"USER %s\r\n", ctx.username);
#line 717
    ctx.expect = 2;
    }
  } else {
#line 719
    if (0 != ctx.auth_mode) {
      {
#line 720
      client_respond(530, (char *)((void *)0), (char *)"Login incorrect");
      }
    } else {
      {
#line 723
      socket_printf(ctx.cli_ctrl, (char *)"%s\r\n", str___0);
      }
    }
#line 726
    ctx.expect = 0;
#line 727
    (ctx.cli_ctrl)->kill = 1;
  }
#line 729
  goto switch_break;
  case_2: /* CIL Label */ 
#line 738
  if (0 != ctx.auth_mode) {
#line 742
    if (c1 == 2) {
#line 742
      if (c2 == 3) {
        {
#line 743
        client_respond(230, (char *)((void *)0), (char *)"User logged in, proceed.");
#line 745
        ctx.expect = 0;
        }
#line 746
        goto switch_break;
      } else {
#line 742
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 751
    if (c1 == 3) {
#line 751
      if (c2 == 3) {
#line 752
        if (ctx.userpass) {
          {
#line 753
          socket_printf(ctx.srv_ctrl, (char *)"PASS %s\r\n", ctx.userpass);
#line 756
          misc_free((char *)"/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-client.c",
                    756, (void *)ctx.userpass);
#line 757
          ctx.userpass = (char *)((void *)0);
          }
        } else {
          {
#line 759
          socket_printf(ctx.srv_ctrl, (char *)"PASS \r\n");
          }
        }
#line 762
        ctx.expect = 7;
#line 763
        goto switch_break;
      }
    }
  }
  {
#line 769
  socket_printf(ctx.cli_ctrl, (char *)"%s\r\n", str___0);
  }
#line 770
  if (c1 != 2) {
#line 770
    if (c1 != 3) {
#line 771
      (ctx.cli_ctrl)->kill = 1;
    }
  }
#line 773
  ctx.expect = 0;
#line 774
  goto switch_break;
  case_3: /* CIL Label */ 
#line 777
  if (c1 == 2) {
    {
#line 778
    client_data_reset(0);
#line 779
    ctx.expect = 0;
    }
  }
#line 781
  goto switch_break;
  case_4: /* CIL Label */ 
#line 784
  if (code == 227) {
#line 784
    if ((int )*arg != 0) {
      {
#line 785
      client_srv_passive(arg);
      }
    } else {
      {
#line 787
      socket_printf(ctx.cli_ctrl, (char *)"%s\r\n", str___0);
#line 789
      client_data_reset(0);
#line 790
      ctx.expect = 0;
      }
    }
  } else {
    {
#line 787
    socket_printf(ctx.cli_ctrl, (char *)"%s\r\n", str___0);
#line 789
    client_data_reset(0);
#line 790
    ctx.expect = 0;
    }
  }
#line 792
  goto switch_break;
  case_5: /* CIL Label */ 
#line 795
  if (code == 200) {
    {
#line 796
    client_xfer_fireup();
    }
  } else {
    {
#line 798
    socket_printf(ctx.cli_ctrl, (char *)"%s\r\n", str___0);
#line 800
    client_data_reset(0);
#line 801
    ctx.expect = 0;
    }
  }
#line 803
  goto switch_break;
  case_6: /* CIL Label */ 
#line 809
  if (c1 == 2) {
    {
#line 810
    misc_strncpy(ctx.xfer_rep, (char const   *)str___0, sizeof(ctx.xfer_rep));
    }
  } else {
    {
#line 813
    socket_printf(ctx.cli_ctrl, (char *)"%s\r\n", str___0);
#line 815
    tmp = config_bool((char *)((void *)0), (char *)"FailResetsPasv", 0);
    }
#line 815
    if (tmp) {
      {
#line 816
      client_data_reset(0);
      }
    } else {
      {
#line 818
      client_data_reset(ctx.cli_mode);
      }
    }
  }
#line 821
  ctx.expect = 0;
#line 822
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 825
  socket_printf(ctx.cli_ctrl, (char *)"%s\r\n", str___0);
#line 826
  ctx.expect = 0;
  }
#line 827
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 830
  socket_printf(ctx.cli_ctrl, (char *)"%s\r\n", str___0);
  }
#line 831
  if (code == 421) {
    {
#line 832
    syslog_write(3, (char *)"server closed connection for %s", (ctx.cli_ctrl)->peer);
#line 835
    (ctx.cli_ctrl)->kill = 1;
    }
  } else {
    {
#line 837
    syslog_write(3, (char *)"bogus \'%.512s\' from Server-PI for %s", (ctx.cli_ctrl)->peer,
                 str___0);
    }
  }
#line 842
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 844
  return;
}
}
#line 859 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-client.c"
static void client_srv_passive(char *arg ) 
{ 
  int h1 ;
  int h2 ;
  int h3 ;
  int h4 ;
  int p1 ;
  int p2 ;
  u_int32_t addr ;
  u_int32_t ladr ;
  u_int16_t port ;
  int incr ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  u_int16_t tmp___3 ;

  {
#line 866
  if ((unsigned long )arg == (unsigned long )((void *)0)) {
#line 867
    return;
  }
  {
#line 873
  while (1) {
    while_continue: /* CIL Label */ ;
#line 873
    if (! ((int )*arg < 48)) {
#line 873
      if (! ((int )*arg > 57)) {
#line 873
        goto while_break;
      }
    }
#line 874
    arg ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 875
  tmp = sscanf((char const   */* __restrict  */)arg, (char const   */* __restrict  */)"%d,%d,%d,%d,%d,%d",
               & h1, & h2, & h3, & h4, & p1, & p2);
  }
#line 875
  if (tmp != 6) {
    {
#line 877
    syslog_error((char *)"bad PASV 277 response from server for %s", (ctx.cli_ctrl)->peer);
#line 879
    client_respond(425, (char *)((void *)0), (char *)"Can\'t open data connection");
#line 880
    client_data_reset(0);
#line 881
    ctx.expect = 0;
    }
#line 882
    return;
  }
  {
#line 884
  addr = (u_int32_t )((((h1 << 24) + (h2 << 16)) + (h3 << 8)) + h4);
#line 885
  port = (u_int16_t )((p1 << 8) + p2);
#line 886
  tmp___0 = socket_addr2str(addr);
#line 886
  syslog_write(1, (char *)"got SRV-PASV %s:%d for %s:%d", tmp___0, (int )port, (ctx.cli_ctrl)->peer,
               (int )(ctx.cli_ctrl)->port);
#line 893
  tmp___1 = config_bool((char *)((void *)0), (char *)"SockBindRand", 0);
  }
#line 893
  if (tmp___1) {
#line 893
    tmp___2 = 0;
  } else {
#line 893
    tmp___2 = 1;
  }
  {
#line 893
  incr = tmp___2;
#line 898
  ladr = socket_sck2addr((ctx.srv_ctrl)->sock, 1, (u_int16_t *)((void *)0));
#line 899
  tmp___3 = socket_d_connect(addr, port, ladr, ctx.srv_lrng, ctx.srv_urng, & ctx.srv_data,
                             (char *)"Srv-Data", incr);
  }
#line 899
  if ((int )tmp___3 == 0) {
    {
#line 903
    syslog_error((char *)"can\'t connect Srv-Data for %s", (ctx.cli_ctrl)->peer);
#line 905
    client_respond(425, (char *)((void *)0), (char *)"Can\'t open data connection");
#line 906
    client_data_reset(0);
#line 907
    ctx.expect = 0;
    }
#line 908
    return;
  }
  {
#line 914
  client_xfer_fireup();
  }
#line 915
  return;
}
}
#line 933 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-client.c"
static void client_xfer_fireup(void) 
{ 
  u_int32_t ladr ;
  int incr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  u_int16_t tmp___2 ;

  {
  {
#line 935
  ladr = (in_addr_t )0;
#line 941
  tmp = config_bool((char *)((void *)0), (char *)"SockBindRand", 0);
  }
#line 941
  if (tmp) {
#line 941
    tmp___0 = 0;
  } else {
#line 941
    tmp___0 = 1;
  }
#line 941
  incr = tmp___0;
#line 946
  if (ctx.cli_mode == 1) {
    {
#line 952
    tmp___1 = config_bool((char *)((void *)0), (char *)"AllowTransProxy", 0);
    }
#line 952
    if (tmp___1) {
      {
#line 953
      ladr = config_addr((char *)((void *)0), (char *)"Listen", (in_addr_t )0);
      }
    }
#line 956
    if (0U == ladr) {
      {
#line 957
      ladr = socket_sck2addr((ctx.cli_ctrl)->sock, 1, (u_int16_t *)((void *)0));
      }
    }
    {
#line 960
    tmp___2 = socket_d_connect(ctx.cli_addr, ctx.cli_port, ladr, ctx.act_lrng, ctx.act_urng,
                               & ctx.cli_data, (char *)"Cli-Data", incr);
    }
#line 960
    if ((int )tmp___2 == 0) {
      {
#line 964
      syslog_error((char *)"can\'t connect Cli-Data for %s", (ctx.cli_ctrl)->peer);
#line 966
      client_respond(425, (char *)((void *)0), (char *)"Can\'t open data connection");
#line 968
      client_data_reset(0);
#line 969
      ctx.expect = 0;
      }
#line 970
      return;
    }
  }
#line 977
  if ((int )ctx.xfer_arg[0] != 0) {
    {
#line 978
    socket_printf(ctx.srv_ctrl, (char *)"%s %s\r\n", ctx.xfer_cmd, ctx.xfer_arg);
#line 980
    syslog_write(2, (char *)"\'%s %s\' sent for %s", ctx.xfer_cmd, ctx.xfer_arg, (ctx.cli_ctrl)->peer);
    }
  } else {
    {
#line 983
    socket_printf(ctx.srv_ctrl, (char *)"%s\r\n", ctx.xfer_cmd);
#line 984
    syslog_write(2, (char *)"\'%s\' sent for %s", ctx.xfer_cmd, (ctx.cli_ctrl)->peer);
    }
  }
  {
#line 991
  memset((void *)(ctx.xfer_rep), 0, sizeof(ctx.xfer_rep));
#line 992
  ctx.xfer_beg = time((time_t *)((void *)0));
#line 994
  ctx.expect = 6;
  }
#line 995
  return;
}
}
#line 1012 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-client.c"
void client_respond(int code , char *file , char *fmt  , ...) 
{ 
  va_list aptr ;
  char str___0[8192] ;
  char *p ;
  char *q ;
  FILE *fp ;
  char *tmp ;

  {
#line 1021
  if ((unsigned long )file != (unsigned long )((void *)0)) {
    {
#line 1021
    fp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"r");
    }
#line 1021
    if ((unsigned long )fp != (unsigned long )((void *)0)) {
      {
#line 1022
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 1022
        tmp = fgets((char */* __restrict  */)(str___0), (int )sizeof(str___0), (FILE */* __restrict  */)fp);
        }
#line 1022
        if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 1022
          goto while_break;
        }
        {
#line 1023
        p = socket_msgline(str___0);
#line 1024
        q = strchr((char const   *)p, '\n');
        }
#line 1024
        if ((unsigned long )q != (unsigned long )((void *)0)) {
#line 1025
          *q = (char )'\000';
        }
        {
#line 1026
        socket_printf(ctx.cli_ctrl, (char *)"%03d-%s\r\n", code, p);
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 1029
      fclose(fp);
      }
    }
  }
  {
#line 1035
  __builtin_va_start(aptr, fmt);
#line 1037
  vsnprintf((char */* __restrict  */)(str___0), sizeof(str___0), (char const   */* __restrict  */)fmt,
            aptr);
#line 1041
  __builtin_va_end(aptr);
#line 1042
  socket_printf(ctx.cli_ctrl, (char *)"%03d %s.\r\n", code, str___0);
  }
#line 1043
  return;
}
}
#line 1058 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-client.c"
void client_reinit(void) 
{ 


  {
#line 1063
  if ((unsigned long )ctx.srv_data != (unsigned long )((void *)0)) {
    {
#line 1064
    socket_kill(ctx.srv_data);
#line 1065
    ctx.srv_data = (HLS *)((void *)0);
    }
  }
#line 1067
  if ((unsigned long )ctx.cli_data != (unsigned long )((void *)0)) {
    {
#line 1068
    socket_kill(ctx.cli_data);
#line 1069
    ctx.cli_data = (HLS *)((void *)0);
    }
  }
#line 1071
  if ((unsigned long )ctx.srv_ctrl != (unsigned long )((void *)0)) {
    {
#line 1072
    socket_kill(ctx.srv_ctrl);
#line 1073
    ctx.srv_ctrl = (HLS *)((void *)0);
    }
  }
  {
#line 1075
  client_data_reset(0);
#line 1080
  ctx.auth_mode = 0;
#line 1081
  ctx.magic_auth = (char *)0;
  }
#line 1082
  if ((unsigned long )ctx.userauth != (unsigned long )((void *)0)) {
    {
#line 1083
    misc_free((char *)"/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-client.c",
              1083, (void *)ctx.userauth);
#line 1084
    ctx.userauth = (char *)((void *)0);
    }
  }
#line 1086
  if ((unsigned long )ctx.username != (unsigned long )((void *)0)) {
    {
#line 1087
    misc_free((char *)"/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-client.c",
              1087, (void *)ctx.username);
#line 1088
    ctx.username = (char *)((void *)0);
    }
  }
#line 1090
  if ((unsigned long )ctx.userpass != (unsigned long )((void *)0)) {
    {
#line 1091
    misc_free((char *)"/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-client.c",
              1091, (void *)ctx.userpass);
#line 1092
    ctx.userpass = (char *)((void *)0);
    }
  }
#line 1094
  ctx.expect = 0;
#line 1095
  return;
}
}
#line 1111 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-client.c"
void client_data_reset(int mode ) 
{ 


  {
  {
#line 1113
  memset((void *)(ctx.xfer_cmd), 0, sizeof(ctx.xfer_cmd));
#line 1114
  memset((void *)(ctx.xfer_arg), 0, sizeof(ctx.xfer_arg));
#line 1115
  ctx.xfer_beg = (time_t )0;
  }
#line 1123
  if (mode) {
#line 1123
    ctx.cli_mode = mode;
  } else {
#line 1123
    ctx.cli_mode = 1;
  }
#line 1125
  if ((unsigned long )ctx.cli_ctrl != (unsigned long )((void *)0)) {
#line 1126
    ctx.cli_addr = (ctx.cli_ctrl)->addr;
#line 1127
    ctx.cli_port = (ctx.cli_ctrl)->port;
  }
#line 1129
  return;
}
}
#line 1144 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-client.c"
void client_srv_open(void) 
{ 
  struct sockaddr_in saddr ;
  u_int16_t lprt ;
  u_int16_t lowrng ;
  u_int16_t res ;
  int sock ;
  int incr ;
  int retry ;
  int tmp ;
  int tmp___0 ;
  u_int32_t ladr ;
  char *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;

  {
  {
#line 1153
  tmp = config_bool((char *)((void *)0), (char *)"SockBindRand", 0);
  }
#line 1153
  if (tmp) {
#line 1153
    tmp___0 = 0;
  } else {
#line 1153
    tmp___0 = 1;
  }
#line 1153
  incr = tmp___0;
#line 1158
  sock = -1;
#line 1163
  retry = 6;
#line 1164
  lprt = ctx.srv_lrng;
  {
#line 1165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1165
    tmp___9 = retry;
#line 1165
    retry --;
#line 1165
    if (! (0 <= tmp___9)) {
#line 1165
      goto while_break;
    }
    {
#line 1169
    sock = socket(2, 1, 0);
    }
#line 1169
    if (sock < 0) {
      {
#line 1170
      syslog_error((char *)"Srv-Ctrl: can\'t create socket for %s", (ctx.cli_ctrl)->peer);
#line 1172
      exit(1);
      }
    }
    {
#line 1174
    socket_opts(sock, 2);
    }
#line 1179
    if (0 == (int )ctx.srv_lrng) {
#line 1179
      if (0 == (int )ctx.srv_urng) {
#line 1220
        lprt = (u_int16_t )0;
      } else {
#line 1179
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 1182
      ladr = (in_addr_t )0;
#line 1187
      if (incr) {
        {
#line 1188
        lowrng = lprt;
#line 1195
        res = socket_d_bind(sock, ladr, lowrng, ctx.srv_urng, incr);
        }
      } else {
        {
#line 1198
        lowrng = ctx.srv_lrng;
#line 1205
        res = socket_d_bind(sock, ladr, lowrng, ctx.srv_urng, incr);
        }
      }
#line 1209
      if (0 == (int )res) {
        {
#line 1211
        close(sock);
#line 1212
        tmp___1 = socket_addr2str(ladr);
#line 1212
        syslog_error((char *)"Srv-Ctrl: can\'t bind to %s:%d for %s", tmp___1, (int )lprt,
                     (ctx.cli_ctrl)->peer);
#line 1216
        exit(1);
        }
      } else {
#line 1218
        lprt = res;
      }
    }
    {
#line 1225
    memset((void *)(& saddr), 0, sizeof(saddr));
#line 1226
    saddr.sin_addr.s_addr = htonl(ctx.srv_addr);
#line 1227
    saddr.sin_family = (sa_family_t )2;
#line 1228
    saddr.sin_port = htons(ctx.srv_port);
#line 1230
    tmp___8 = connect(sock, (struct sockaddr  const  *)((struct sockaddr *)(& saddr)),
                      (socklen_t )sizeof(saddr));
    }
#line 1230
    if (tmp___8 < 0) {
      {
#line 1237
      close(sock);
#line 1238
      sock = -1;
#line 1244
      tmp___3 = __errno_location();
      }
#line 1244
      if (! (4 == *tmp___3)) {
        {
#line 1244
        tmp___4 = __errno_location();
        }
#line 1244
        if (! (11 == *tmp___4)) {
          {
#line 1244
          tmp___5 = __errno_location();
          }
#line 1244
          if (! (98 == *tmp___5)) {
            {
#line 1244
            tmp___6 = __errno_location();
            }
#line 1244
            if (! (99 == *tmp___6)) {
              {
#line 1252
              tmp___2 = socket_addr2str(ctx.srv_addr);
#line 1252
              syslog_error((char *)"Srv-Ctrl: can\'t connect %s:%d for %s", tmp___2,
                           (int )ctx.srv_port, (ctx.cli_ctrl)->peer);
#line 1257
              exit(1);
              }
            }
          }
        }
      }
#line 1259
      if (incr) {
#line 1259
        if (0 != (int )lprt) {
#line 1263
          if ((int )lprt < (int )ctx.srv_urng) {
#line 1264
            lprt = (u_int16_t )((int )lprt + 1);
          } else {
            {
#line 1269
            tmp___7 = socket_addr2str(ctx.srv_addr);
#line 1269
            syslog_error((char *)"Srv-Ctrl: can\'t connect %s:%d for %s", tmp___7,
                         (int )ctx.srv_port, (ctx.cli_ctrl)->peer);
#line 1274
            exit(1);
            }
          }
        }
      }
    } else {
#line 1277
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1283
  if (-1 == sock) {
    {
#line 1284
    tmp___10 = socket_addr2str(ctx.srv_addr);
#line 1284
    syslog_error((char *)"Srv-Ctrl: can\'t connect %s:%d for %s", tmp___10, (int )ctx.srv_port,
                 (ctx.cli_ctrl)->peer);
#line 1288
    exit(1);
    }
  }
  {
#line 1291
  ctx.srv_ctrl = socket_init(sock);
  }
#line 1291
  if ((unsigned long )ctx.srv_ctrl == (unsigned long )((void *)0)) {
    {
#line 1292
    misc_die((char *)"/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-client.c",
             1292, (char *)"cmds_user: ?srv_ctrl?");
    }
  }
#line 1293
  (ctx.srv_ctrl)->ctyp = (char *)"Srv-Ctrl";
#line 1300
  ctx.expect = 1;
#line 1301
  return;
}
}
#line 1317 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-client.c"
int client_setup(char *pwd ) 
{ 
  char *type ;
  char *who ;
  char *ptr ;
  char *rule ;
  void *preg ;
  char const   *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;

  {
#line 1325
  ctx.cli_mode = 1;
#line 1326
  ctx.cli_addr = (ctx.cli_ctrl)->addr;
#line 1327
  ctx.cli_port = (ctx.cli_ctrl)->port;
#line 1328
  ctx.srv_addr = (in_addr_t )0;
#line 1329
  ctx.srv_port = (u_int16_t )0;
#line 1334
  if ((unsigned long )((void *)0) != (unsigned long )ctx.userauth) {
#line 1335
    who = ctx.userauth;
  } else {
#line 1337
    who = ctx.username;
  }
#line 1343
  if ((unsigned long )((void *)0) != (unsigned long )who) {
#line 1343
    if (0 != (int )*(who + 0)) {
      {
#line 1347
      preg = (void *)0;
#line 1349
      rule = config_str((char *)((void *)0), (char *)"UserNameRule", (char *)"^[[:alnum:]]+([%20@/\\._-][[:alnum:]]+)*$");
#line 1352
      syslog_write(1, (char *)"compiling UserNameRule: \'%.1024s\'", rule);
#line 1353
      ptr = cmds_reg_comp(& preg, rule);
      }
#line 1353
      if ((unsigned long )((void *)0) == (unsigned long )ptr) {
#line 1354
        return (-1);
      }
      {
#line 1356
      syslog_write(1, (char *)"DeHTMLized UserNameRule: \'%.1024s\'", ptr);
#line 1358
      ptr = cmds_reg_exec(preg, who);
      }
#line 1359
      if ((unsigned long )((void *)0) != (unsigned long )ptr) {
        {
#line 1360
        tmp___1 = strlen((char const   *)who);
        }
#line 1360
        if (tmp___1 > 128UL) {
#line 1360
          tmp___0 = "...";
        } else {
#line 1360
          tmp___0 = "";
        }
        {
#line 1360
        syslog_write(13, (char *)"invalid user name \'%.128s\'%s: %s", who, tmp___0,
                     ptr);
#line 1362
        cmds_reg_comp(& preg, (char *)((void *)0));
        }
#line 1363
        return (-1);
      } else {
        {
#line 1365
        cmds_reg_comp(& preg, (char *)((void *)0));
        }
      }
    } else {
      {
#line 1389
      syslog_write(14, (char *)"empty user name");
      }
#line 1390
      return (-1);
    }
  } else {
    {
#line 1389
    syslog_write(14, (char *)"empty user name");
    }
#line 1390
    return (-1);
  }
  {
#line 1397
  tmp___2 = client_setup_file(& ctx, who);
  }
#line 1397
  if (0 != tmp___2) {
#line 1398
    return (-1);
  }
  {
#line 1407
  type = config_str((char *)((void *)0), (char *)"UserAuthType", (char *)((void *)0));
  }
#line 1408
  if ((unsigned long )((void *)0) != (unsigned long )type) {
    {
#line 1410
    tmp___6 = strcasecmp((char const   *)type, "ldap");
    }
#line 1410
    if (0 == tmp___6) {
      {
#line 1414
      tmp___3 = config_str((char *)((void *)0), (char *)"LDAPServer", (char *)((void *)0));
      }
#line 1414
      if ((unsigned long )((void *)0) == (unsigned long )tmp___3) {
        {
#line 1415
        misc_die((char *)"/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-client.c",
                 1415, (char *)"client_setup: ?LDAPServer?");
        }
      }
#line 1421
      if (pwd) {
#line 1421
        tmp___4 = (char const   *)pwd;
      } else {
#line 1421
        tmp___4 = "";
      }
      {
#line 1421
      tmp___5 = ldap_setup_user(& ctx, who, (char *)tmp___4);
      }
#line 1421
      if (0 != tmp___5) {
#line 1422
        return (-1);
      }
    } else {
      {
#line 1424
      misc_die((char *)"/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-client.c",
               1424, (char *)"client_setup: unknown ?UserAuthType?");
      }
    }
  } else {
    {
#line 1431
    ldap_setup_user(& ctx, who, (char *)((void *)0));
    }
  }
  {
#line 1437
  tmp___7 = __errno_location();
#line 1437
  *tmp___7 = 0;
  }
#line 1438
  if (0U == ctx.srv_addr) {
    {
#line 1439
    syslog_error((char *)"can\'t eval DestAddr for %s", (ctx.cli_ctrl)->peer);
    }
#line 1440
    return (-1);
  } else
#line 1438
  if (4294967295U == ctx.srv_addr) {
    {
#line 1439
    syslog_error((char *)"can\'t eval DestAddr for %s", (ctx.cli_ctrl)->peer);
    }
#line 1440
    return (-1);
  }
#line 1442
  if (0 == (int )ctx.srv_port) {
    {
#line 1443
    syslog_error((char *)"can\'t eval DestPort for %s", (ctx.cli_ctrl)->peer);
    }
#line 1444
    return (-1);
  }
#line 1447
  return (0);
}
}
#line 1464 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-client.c"
static int client_setup_file(CONTEXT *ctx___0 , char *who ) 
{ 
  char *p ;
  u_int16_t l ;
  u_int16_t u ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  __uid_t tmp___2 ;

  {
#line 1472
  if (ctx___0) {
#line 1472
    if (who) {
#line 1472
      if (! *who) {
#line 1473
        return (-1);
      }
    } else {
#line 1473
      return (-1);
    }
  } else {
#line 1473
    return (-1);
  }
  {
#line 1479
  syslog_write(12, (char *)"reading data for \'%s\' from cfg-file", who);
  }
#line 1484
  if (0U != ctx___0->magic_addr) {
#line 1485
    ctx___0->srv_addr = ctx___0->magic_addr;
  } else {
    {
#line 1487
    ctx___0->srv_addr = config_addr(who, (char *)"DestinationAddress", (in_addr_t )0);
    }
  }
#line 1498
  if (0 != (int )ctx___0->magic_port) {
#line 1499
    ctx___0->srv_port = ctx___0->magic_port;
  } else {
    {
#line 1501
    ctx___0->srv_port = config_port(who, (char *)"DestinationPort", (u_int16_t )21);
    }
  }
  {
#line 1512
  p = config_str(who, (char *)"DestinationTransferMode", (char *)"client");
#line 1513
  tmp___1 = strcasecmp((char const   *)p, "active");
  }
#line 1513
  if (0 == tmp___1) {
#line 1514
    ctx___0->srv_mode = 1;
  } else {
    {
#line 1516
    tmp___0 = strcasecmp((char const   *)p, "passive");
    }
#line 1516
    if (0 == tmp___0) {
#line 1517
      ctx___0->srv_mode = 2;
    } else {
      {
#line 1519
      tmp = strcasecmp((char const   *)p, "client");
      }
#line 1519
      if (0 == tmp) {
#line 1520
        ctx___0->srv_mode = 3;
      } else {
        {
#line 1522
        syslog_error((char *)"can\'t eval DestMode for %s", (ctx___0->cli_ctrl)->peer);
        }
#line 1524
        return (-1);
      }
    }
  }
  {
#line 1533
  l = config_port(who, (char *)"DestinationMinPort", (u_int16_t )0);
#line 1534
  u = config_port(who, (char *)"DestinationMaxPort", (u_int16_t )0);
  }
#line 1535
  if ((int )l > 0) {
#line 1535
    if ((int )u > 0) {
#line 1535
      if ((int )u >= (int )l) {
#line 1536
        ctx___0->srv_lrng = l;
#line 1537
        ctx___0->srv_urng = u;
      } else {
#line 1539
        ctx___0->srv_lrng = (u_int16_t )0;
#line 1540
        ctx___0->srv_urng = (u_int16_t )0;
      }
    } else {
#line 1539
      ctx___0->srv_lrng = (u_int16_t )0;
#line 1540
      ctx___0->srv_urng = (u_int16_t )0;
    }
  } else {
#line 1539
    ctx___0->srv_lrng = (u_int16_t )0;
#line 1540
    ctx___0->srv_urng = (u_int16_t )0;
  }
  {
#line 1550
  l = config_port(who, (char *)"ActiveMinDataPort", (u_int16_t )0);
#line 1551
  u = config_port(who, (char *)"ActiveMaxDataPort", (u_int16_t )0);
  }
#line 1552
  if ((int )l > 0) {
#line 1552
    if ((int )u > 0) {
#line 1552
      if ((int )u >= (int )l) {
#line 1553
        ctx___0->act_lrng = l;
#line 1554
        ctx___0->act_urng = u;
      } else {
#line 1552
        goto _L___0;
      }
    } else {
#line 1552
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    {
#line 1557
    tmp___2 = getuid();
    }
#line 1557
    if (0U == tmp___2) {
#line 1558
      ctx___0->act_lrng = (u_int16_t )20;
#line 1559
      ctx___0->act_urng = (u_int16_t )20;
    } else {
#line 1561
      ctx___0->act_lrng = (u_int16_t )0;
#line 1562
      ctx___0->act_urng = (u_int16_t )0;
    }
  }
  {
#line 1573
  l = config_port(who, (char *)"PassiveMinDataPort", (u_int16_t )0);
#line 1574
  u = config_port(who, (char *)"PassiveMaxDataPort", (u_int16_t )0);
  }
#line 1575
  if ((int )l > 0) {
#line 1575
    if ((int )u > 0) {
#line 1575
      if ((int )u >= (int )l) {
#line 1576
        ctx___0->pas_lrng = l;
#line 1577
        ctx___0->pas_urng = u;
      } else {
#line 1579
        ctx___0->pas_lrng = (u_int16_t )0;
#line 1580
        ctx___0->pas_urng = (u_int16_t )0;
      }
    } else {
#line 1579
      ctx___0->pas_lrng = (u_int16_t )0;
#line 1580
      ctx___0->pas_urng = (u_int16_t )0;
    }
  } else {
#line 1579
    ctx___0->pas_lrng = (u_int16_t )0;
#line 1580
    ctx___0->pas_urng = (u_int16_t )0;
  }
  {
#line 1590
  ctx___0->same_adr = config_bool(who, (char *)"SameAddress", 1);
#line 1591
  ctx___0->timeout = config_int(who, (char *)"TimeOut", 900);
#line 1601
  p = config_str(who, (char *)"ValidCommands", (char *)((void *)0));
#line 1602
  cmds_set_allow(p);
  }
#line 1604
  return (0);
}
}
#line 263 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 538
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 374 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) ntohl)(uint32_t __netlong )  __attribute__((__const__)) ;
#line 375
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 573 "/usr/include/regex.h"
extern int regcomp(regex_t * __restrict  __preg , char const   * __restrict  __pattern ,
                   int __cflags ) ;
#line 577
extern int regexec(regex_t const   * __restrict  __preg , char const   * __restrict  __string ,
                   size_t __nmatch , regmatch_t * __restrict  __pmatch , int __eflags ) ;
#line 582
extern size_t regerror(int __errcode , regex_t const   * __restrict  __preg , char * __restrict  __errbuf ,
                       size_t __errbuf_size ) ;
#line 585
extern void regfree(regex_t *__preg ) ;
#line 74 "../common/com-misc.h"
extern void *misc_alloc(char *file , int line , size_t len ) ;
#line 75
extern char *misc_strdup(char *file , int line , char *str ) ;
#line 114 "../common/com-socket.h"
extern void socket_flag(HLS *hls , int flag ) ;
#line 115
extern int socket_write(HLS *hls , char *ptr , int len ) ;
#line 127
extern u_int16_t socket_d_listen(u_int32_t addr , u_int16_t lrng , u_int16_t urng ,
                                 HLS **phls , char *ctyp , int incr ) ;
#line 138
extern u_int32_t socket_str2addr(char *name , u_int32_t dflt ) ;
#line 139
extern u_int16_t socket_str2port(char *name , u_int16_t dflt ) ;
#line 143
extern int socket_chkladdr(u_int32_t addr ) ;
#line 144
extern int socket_orgdst(HLS *phls , u_int32_t *addr , u_int16_t *port ) ;
#line 83 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-cmds.c"
static void cmds_pthr(CONTEXT *ctx___0 , char *arg ) ;
#line 84
static void cmds_user(CONTEXT *ctx___0 , char *arg ) ;
#line 85
static void cmds_pass(CONTEXT *ctx___0 , char *arg ) ;
#line 86
static void cmds_quit(CONTEXT *ctx___0 , char *arg ) ;
#line 87
static void cmds_rein(CONTEXT *ctx___0 , char *arg ) ;
#line 88
static void cmds_port(CONTEXT *ctx___0 , char *arg ) ;
#line 89
static void cmds_pasv(CONTEXT *ctx___0 , char *arg ) ;
#line 90
static void cmds_xfer(CONTEXT *ctx___0 , char *arg ) ;
#line 91
static void cmds_abor(CONTEXT *ctx___0 , char *arg ) ;
#line 106
static int parse_magic_dest(CONTEXT *ctx___0 , char *dest ) ;
#line 107
static int parse_magic_user(CONTEXT *ctx___0 , char *uarg , char a_sep , int a_first ,
                            char u_sep , int u_force ) ;
#line 119 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-cmds.c"
static CMD cmdlist[49]  = 
#line 119
  {      {(char *)"USER", & cmds_user, (void *)0, 0, 0}, 
        {(char *)"PASS", & cmds_pass, (void *)0, 0, 0}, 
        {(char *)"ACCT", & cmds_pthr, (void *)0, 0, 0}, 
        {(char *)"CWD", & cmds_pthr, (void *)0, 0, 0}, 
        {(char *)"CDUP", & cmds_pthr, (void *)0, 0, 0}, 
        {(char *)"SMNT", & cmds_pthr, (void *)0, 0, 0}, 
        {(char *)"QUIT", & cmds_quit, (void *)0, 0, 0}, 
        {(char *)"REIN", & cmds_rein, (void *)0, 0, 0}, 
        {(char *)"PORT", & cmds_port, (void *)0, 0, 0}, 
        {(char *)"PASV", & cmds_pasv, (void *)0, 0, 0}, 
        {(char *)"TYPE", & cmds_pthr, (void *)0, 0, 0}, 
        {(char *)"STRU", & cmds_pthr, (void *)0, 0, 0}, 
        {(char *)"MODE", & cmds_pthr, (void *)0, 0, 0}, 
        {(char *)"RETR", & cmds_xfer, (void *)0, 0, 0}, 
        {(char *)"STOR", & cmds_xfer, (void *)0, 0, 0}, 
        {(char *)"STOU", & cmds_xfer, (void *)0, 0, 0}, 
        {(char *)"APPE", & cmds_xfer, (void *)0, 0, 0}, 
        {(char *)"ALLO", & cmds_pthr, (void *)0, 0, 0}, 
        {(char *)"REST", & cmds_pthr, (void *)0, 0, 0}, 
        {(char *)"RNFR", & cmds_pthr, (void *)0, 0, 0}, 
        {(char *)"RNTO", & cmds_pthr, (void *)0, 0, 0}, 
        {(char *)"ABOR", & cmds_abor, (void *)0, 0, 0}, 
        {(char *)"DELE", & cmds_pthr, (void *)0, 0, 0}, 
        {(char *)"RMD", & cmds_pthr, (void *)0, 0, 0}, 
        {(char *)"MKD", & cmds_pthr, (void *)0, 0, 0}, 
        {(char *)"PWD", & cmds_pthr, (void *)0, 0, 0}, 
        {(char *)"LIST", & cmds_xfer, (void *)0, 0, 0}, 
        {(char *)"NLST", & cmds_xfer, (void *)0, 0, 0}, 
        {(char *)"SITE", & cmds_pthr, (void *)0, 0, 0}, 
        {(char *)"SYST", & cmds_pthr, (void *)0, 0, 0}, 
        {(char *)"STAT", & cmds_pthr, (void *)0, 0, 0}, 
        {(char *)"HELP", & cmds_pthr, (void *)0, 0, 0}, 
        {(char *)"NOOP", & cmds_pthr, (void *)0, 0, 0}, 
        {(char *)"SIZE", & cmds_pthr, (void *)0, 0, 0}, 
        {(char *)"MDTM", & cmds_pthr, (void *)0, 0, 0}, 
        {(char *)"MLFL", & cmds_pthr, (void *)0, 0, 0}, 
        {(char *)"MAIL", & cmds_pthr, (void *)0, 0, 0}, 
        {(char *)"MSND", & cmds_pthr, (void *)0, 0, 0}, 
        {(char *)"MSOM", & cmds_pthr, (void *)0, 0, 0}, 
        {(char *)"MSAM", & cmds_pthr, (void *)0, 0, 0}, 
        {(char *)"MRSQ", & cmds_pthr, (void *)0, 0, 0}, 
        {(char *)"MRCP", & cmds_pthr, (void *)0, 0, 0}, 
        {(char *)"XCWD", & cmds_pthr, (void *)0, 0, 0}, 
        {(char *)"XMKD", & cmds_pthr, (void *)0, 0, 0}, 
        {(char *)"XRMD", & cmds_pthr, (void *)0, 0, 0}, 
        {(char *)"XPWD", & cmds_pthr, (void *)0, 0, 0}, 
        {(char *)"XCUP", & cmds_pthr, (void *)0, 0, 0}, 
        {(char *)"RCMD", & cmds_pthr, (void *)0, 0, 0}, 
        {(char *)((void *)0), (void (*)(CONTEXT * , char * ))((void *)0), (void *)0,
      0, 0}};
#line 194 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-cmds.c"
CMD *cmds_get_list(void) 
{ 


  {
#line 196
  return (cmdlist);
}
}
#line 215 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-cmds.c"
void cmds_set_allow(char *allow ) 
{ 
  CMD *cmd ;
  char *p ;
  char *q ;
  int i ;
  size_t tmp ;
  size_t tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  char *r ;

  {
#line 226
  if ((unsigned long )allow == (unsigned long )((void *)0)) {
#line 227
    cmd = cmdlist;
    {
#line 227
    while (1) {
      while_continue: /* CIL Label */ ;
#line 227
      if (! ((unsigned long )cmd->name != (unsigned long )((void *)0))) {
#line 227
        goto while_break;
      }
#line 229
      if ((unsigned long )cmd->regex != (unsigned long )((void *)0)) {
        {
#line 230
        regfree((regex_t *)cmd->regex);
#line 231
        misc_free((char *)"/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-cmds.c",
                  231, cmd->regex);
#line 232
        cmd->regex = (void *)0;
        }
      }
      {
#line 235
      cmd->legal = 1;
#line 236
      tmp = strlen((char const   *)cmd->name);
#line 236
      cmd->len = (int )tmp;
#line 227
      cmd ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 241
    return;
  }
#line 247
  cmd = cmdlist;
  {
#line 247
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 247
    if (! ((unsigned long )cmd->name != (unsigned long )((void *)0))) {
#line 247
      goto while_break___0;
    }
#line 249
    if ((unsigned long )cmd->regex != (unsigned long )((void *)0)) {
      {
#line 250
      regfree((regex_t *)cmd->regex);
#line 251
      misc_free((char *)"/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-cmds.c",
                251, cmd->regex);
#line 252
      cmd->regex = (void *)0;
      }
    }
    {
#line 255
    cmd->legal = 0;
#line 256
    tmp___0 = strlen((char const   *)cmd->name);
#line 256
    cmd->len = (int )tmp___0;
#line 247
    cmd ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 262
  p = allow;
  {
#line 262
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 262
    if (! ((int )*p != 0)) {
#line 262
      goto while_break___1;
    }
    {
#line 263
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 263
      if ((int )*p != 0) {
        {
#line 263
        tmp___1 = __ctype_b_loc();
        }
#line 263
        if (! (((int const   )*(*tmp___1 + (int )*p) & 1024) == 0)) {
#line 263
          goto while_break___2;
        }
      } else {
#line 263
        goto while_break___2;
      }
#line 264
      p ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 265
    if ((int )*p == 0) {
#line 266
      goto while_break___1;
    }
#line 267
    q = p;
#line 267
    i = 0;
    {
#line 267
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 267
      tmp___2 = __ctype_b_loc();
      }
#line 267
      if (! ((int const   )*(*tmp___2 + (int )*q) & 1024)) {
#line 267
        goto while_break___3;
      }
#line 267
      q ++;
#line 267
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 269
    cmd = cmdlist;
    {
#line 269
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 269
      if (! cmd->name) {
#line 269
        goto while_break___4;
      }
#line 270
      if (cmd->len != i) {
#line 271
        goto __Cont;
      }
      {
#line 272
      tmp___3 = strncasecmp((char const   *)cmd->name, (char const   *)p, (size_t )i);
      }
#line 272
      if (tmp___3 != 0) {
#line 273
        goto __Cont;
      }
#line 274
      cmd->legal = 1;
#line 276
      if ((int )*q == 61) {
        {
#line 278
        q ++;
#line 278
        r = cmds_reg_comp(& cmd->regex, q);
        }
        {
#line 283
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 283
          if (*q) {
#line 283
            if ((int )*q != 32) {
#line 283
              if (! ((int )*q != 9)) {
#line 283
                goto while_break___5;
              }
            } else {
#line 283
              goto while_break___5;
            }
          } else {
#line 283
            goto while_break___5;
          }
#line 284
          q ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 285
        goto while_break___4;
      }
#line 291
      goto while_break___4;
      __Cont: /* CIL Label */ 
#line 269
      cmd ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 293
    p = q;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 295
  return;
}
}
#line 311 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-cmds.c"
static void cmds_pthr(CONTEXT *ctx___0 , char *arg ) 
{ 
  char *cmd ;

  {
#line 315
  if ((unsigned long )ctx___0 == (unsigned long )((void *)0)) {
    {
#line 316
    misc_die((char *)"/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-cmds.c",
             316, (char *)"cmds_pthr: ?ctx?");
    }
  }
#line 317
  cmd = ctx___0->curr_cmd;
#line 317
  if ((unsigned long )cmd == (unsigned long )((void *)0)) {
    {
#line 318
    misc_die((char *)"/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-cmds.c",
             318, (char *)"cmds_pthr: ?curr_cmd?");
    }
  }
#line 320
  if ((unsigned long )ctx___0->srv_ctrl == (unsigned long )((void *)0)) {
    {
#line 321
    client_respond(530, (char *)((void *)0), (char *)"Not logged in");
#line 322
    syslog_write(13, (char *)"\'%s\' without login from %s", cmd, (ctx___0->cli_ctrl)->peer);
    }
#line 324
    return;
  }
#line 327
  if ((unsigned long )arg == (unsigned long )((void *)0)) {
    {
#line 328
    socket_printf(ctx___0->srv_ctrl, (char *)"%s\r\n", cmd);
#line 329
    syslog_write(12, (char *)"\'%s\' from %s", cmd, (ctx___0->cli_ctrl)->peer);
    }
  } else
#line 327
  if ((int )*arg == 0) {
    {
#line 328
    socket_printf(ctx___0->srv_ctrl, (char *)"%s\r\n", cmd);
#line 329
    syslog_write(12, (char *)"\'%s\' from %s", cmd, (ctx___0->cli_ctrl)->peer);
    }
  } else {
    {
#line 332
    socket_printf(ctx___0->srv_ctrl, (char *)"%s %.1024s\r\n", cmd, arg);
#line 333
    syslog_write(12, (char *)"\'%s %.1024s\' from %s", cmd, arg, (ctx___0->cli_ctrl)->peer);
    }
  }
#line 337
  ctx___0->expect = 7;
#line 338
  return;
}
}
#line 354 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-cmds.c"
static void cmds_user(CONTEXT *ctx___0 , char *arg ) 
{ 
  CMD *cmd ;
  char *tmp ;
  char *p ;
  int tmp___0 ;
  char const   *tmp___2 ;
  size_t tmp___3 ;
  u_int32_t addr ;
  u_int16_t port ;
  int rc ;
  int tmp___4 ;
  char *tmp___5 ;
  uint32_t tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  int is_ok ;
  char a_sep ;
  int tmp___13 ;
  char *u_sep ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *u_sep___0 ;
  char *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  char *p___0 ;
  char *u_sep___1 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  int tmp___23 ;
  char *p___1 ;
  char *u_sep___2 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  int tmp___32 ;

  {
#line 358
  if ((unsigned long )ctx___0 == (unsigned long )((void *)0)) {
    {
#line 359
    misc_die((char *)"/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-cmds.c",
             359, (char *)"cmds_user: ?ctx?");
    }
  }
#line 364
  if ((unsigned long )arg == (unsigned long )((void *)0)) {
    {
#line 365
    client_respond(501, (char *)((void *)0), (char *)"Missing user name");
#line 366
    syslog_write(13, (char *)"\'USER\' without name from %s", (ctx___0->cli_ctrl)->peer);
    }
#line 368
    return;
  } else
#line 364
  if ((int )*arg == 0) {
    {
#line 365
    client_respond(501, (char *)((void *)0), (char *)"Missing user name");
#line 366
    syslog_write(13, (char *)"\'USER\' without name from %s", (ctx___0->cli_ctrl)->peer);
    }
#line 368
    return;
  }
  {
#line 374
  client_reinit();
#line 380
  tmp = config_str((char *)((void *)0), (char *)"ValidCommands", (char *)((void *)0));
#line 380
  cmds_set_allow(tmp);
#line 381
  cmd = cmdlist;
  }
  {
#line 381
  while (1) {
    while_continue: /* CIL Label */ ;
#line 381
    if (! ((unsigned long )cmd->name != (unsigned long )((void *)0))) {
#line 381
      goto while_break;
    }
    {
#line 383
    tmp___0 = strcasecmp("USER", (char const   *)cmd->name);
    }
#line 383
    if (tmp___0 != 0) {
#line 384
      goto __Cont;
    }
#line 385
    if ((unsigned long )cmd->regex == (unsigned long )((void *)0)) {
#line 386
      goto while_break;
    }
    {
#line 387
    p = cmds_reg_exec(cmd->regex, arg);
    }
#line 387
    if ((unsigned long )p != (unsigned long )((void *)0)) {
      {
#line 388
      client_respond(501, (char *)((void *)0), (char *)"\'USER\': syntax error in arguments");
#line 390
      tmp___3 = strlen((char const   *)arg);
      }
#line 390
      if (tmp___3 > 128UL) {
#line 390
        tmp___2 = "...";
      } else {
#line 390
        tmp___2 = "";
      }
      {
#line 390
      syslog_write(13, (char *)"bad arg \'%.128s\'%s for \'USER\' from %s: %s", arg,
                   tmp___2, (ctx___0->cli_ctrl)->peer, p);
      }
#line 395
      return;
    }
#line 397
    goto while_break;
    __Cont: /* CIL Label */ 
#line 381
    cmd ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 409
  ctx___0->magic_addr = (in_addr_t )0;
#line 410
  ctx___0->magic_port = (u_int16_t )0;
#line 412
  tmp___9 = config_bool((char *)((void *)0), (char *)"AllowTransProxy", 0);
  }
#line 412
  if (tmp___9) {
    {
#line 413
    addr = (in_addr_t )0;
#line 414
    port = (u_int16_t )0;
#line 416
    tmp___8 = socket_orgdst(ctx___0->cli_ctrl, & addr, & port);
    }
#line 416
    if (tmp___8) {
      {
#line 446
      syslog_write(1, (char *)"no transparent proxy destination found");
      }
    } else
#line 416
    if (0U != addr) {
#line 416
      if (4294967295U != addr) {
#line 416
        if (0 != (int )port) {
          {
#line 424
          tmp___4 = socket_chkladdr(addr);
#line 424
          rc = tmp___4;
          }
          {
#line 427
          if (rc == -1) {
#line 427
            goto case_neg_1;
          }
#line 431
          if (rc == 0) {
#line 431
            goto case_0;
          }
#line 439
          goto switch_default;
          case_neg_1: /* CIL Label */ 
          {
#line 428
          syslog_write(4, (char *)"check of transparent destination failed");
          }
#line 430
          goto switch_break;
          case_0: /* CIL Label */ 
          {
#line 432
          ctx___0->magic_addr = ntohl(addr);
#line 433
          ctx___0->magic_port = ntohs(port);
#line 434
          tmp___5 = socket_addr2str(ctx___0->magic_addr);
#line 434
          syslog_write(2, (char *)"transparent proxy request to %s:%d from %s", tmp___5,
                       (int )ctx___0->magic_port, (ctx___0->cli_ctrl)->peer);
          }
#line 438
          goto switch_break;
          switch_default: /* CIL Label */ 
          {
#line 440
          tmp___6 = ntohl(addr);
#line 440
          tmp___7 = socket_addr2str(tmp___6);
#line 440
          syslog_write(1, (char *)"requested transparent destination %s is local",
                       tmp___7);
          }
#line 443
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
        } else {
          {
#line 446
          syslog_write(1, (char *)"no transparent proxy destination found");
          }
        }
      } else {
        {
#line 446
        syslog_write(1, (char *)"no transparent proxy destination found");
        }
      }
    } else {
      {
#line 446
      syslog_write(1, (char *)"no transparent proxy destination found");
      }
    }
  }
  {
#line 454
  tmp___12 = config_str((char *)((void *)0), (char *)"UserAuthType", (char *)((void *)0));
  }
#line 454
  if ((unsigned long )((void *)0) != (unsigned long )tmp___12) {
    {
#line 455
    ctx___0->auth_mode = 1;
#line 456
    ctx___0->magic_auth = config_str((char *)((void *)0), (char *)"UserAuthMagic",
                                     (char *)((void *)0));
    }
#line 457
    if ((unsigned long )((void *)0) != (unsigned long )ctx___0->magic_auth) {
      {
#line 458
      tmp___10 = strlen((char const   *)ctx___0->magic_auth);
      }
#line 458
      if (sizeof("auth") != tmp___10) {
        {
#line 459
        syslog_write(4, (char *)"invalid UserAuthMagic");
#line 460
        client_respond(530, (char *)((void *)0), (char *)"Not logged in");
#line 461
        client_reinit();
        }
#line 462
        return;
      }
      {
#line 464
      tmp___11 = strncasecmp((char const   *)ctx___0->magic_auth, "auth", sizeof("auth") - 1UL);
      }
#line 464
      if (tmp___11) {
#line 465
        ctx___0->auth_mode = 3;
      } else {
#line 467
        ctx___0->auth_mode = 2;
      }
    }
  }
#line 474
  if ((unsigned long )((void *)0) != (unsigned long )ctx___0->magic_auth) {
#line 475
    is_ok = 1;
#line 476
    if (ctx___0->auth_mode == 2) {
#line 476
      tmp___13 = (int )*(ctx___0->magic_auth + (sizeof("auth") - 1UL));
    } else {
#line 476
      tmp___13 = (int )*(ctx___0->magic_auth + 0);
    }
    {
#line 476
    a_sep = (char )tmp___13;
#line 484
    tmp___19 = config_bool((char *)((void *)0), (char *)"ForceMagicUser", 0);
    }
#line 484
    if (tmp___19 != 0) {
      {
#line 485
      tmp___14 = config_str((char *)((void *)0), (char *)"UseMagicChar", (char *)"@");
#line 485
      tmp___15 = config_str((char *)((void *)0), (char *)"UserMagicChar", tmp___14);
#line 485
      u_sep = tmp___15;
#line 487
      is_ok = parse_magic_user(ctx___0, arg, a_sep, ctx___0->auth_mode == 2, *(u_sep + 0),
                               1);
      }
    } else {
      {
#line 491
      tmp___18 = config_bool((char *)((void *)0), (char *)"AllowMagicUser", 0);
      }
#line 491
      if (tmp___18 != 0) {
        {
#line 492
        tmp___16 = config_str((char *)((void *)0), (char *)"UseMagicChar", (char *)"@");
#line 492
        tmp___17 = config_str((char *)((void *)0), (char *)"UserMagicChar", tmp___16);
#line 492
        u_sep___0 = tmp___17;
#line 494
        is_ok = parse_magic_user(ctx___0, arg, a_sep, ctx___0->auth_mode == 2, *(u_sep___0 + 0),
                                 0);
        }
      } else {
        {
#line 498
        is_ok = parse_magic_user(ctx___0, arg, a_sep, ctx___0->auth_mode == 2, (char)0,
                                 0);
        }
      }
    }
#line 503
    if (is_ok) {
#line 503
      goto _L;
    } else
#line 503
    if ((unsigned long )((void *)0) == (unsigned long )ctx___0->userauth) {
#line 503
      goto _L;
    } else
#line 503
    if ((unsigned long )((void *)0) == (unsigned long )ctx___0->username) {
#line 503
      goto _L;
    } else
#line 503
    if ((unsigned long )((char *)0) == (unsigned long )ctx___0->userauth) {
#line 503
      goto _L;
    } else
#line 503
    if ((unsigned long )((char *)0) == (unsigned long )ctx___0->username) {
      _L: /* CIL Label */ 
#line 505
      if (1 == is_ok) {
        {
#line 506
        syslog_write(14, (char *)"missed magic dest in \'USER\' from %s", (ctx___0->cli_ctrl)->peer);
        }
      } else {
        {
#line 510
        syslog_write(14, (char *)"invalid magic in \'USER\' from %s", (ctx___0->cli_ctrl)->peer);
        }
      }
      {
#line 514
      client_respond(530, (char *)((void *)0), (char *)"Not logged in");
#line 515
      client_reinit();
      }
#line 516
      return;
    }
  } else {
    {
#line 522
    tmp___29 = config_bool((char *)((void *)0), (char *)"ForceMagicUser", 0);
    }
#line 522
    if (tmp___29 != 0) {
      {
#line 523
      tmp___20 = config_str((char *)((void *)0), (char *)"UseMagicChar", (char *)"@");
#line 523
      tmp___21 = config_str((char *)((void *)0), (char *)"UserMagicChar", tmp___20);
#line 523
      u_sep___1 = tmp___21;
#line 525
      p___0 = strrchr((char const   *)arg, (int )*(u_sep___1 + 0));
      }
#line 525
      if (p___0) {
        {
#line 526
        tmp___22 = p___0;
#line 526
        p___0 ++;
#line 526
        *tmp___22 = (char )'\000';
#line 527
        tmp___23 = parse_magic_dest(ctx___0, p___0);
        }
#line 527
        if (-1 == tmp___23) {
          {
#line 528
          syslog_write(14, (char *)"invalid magic in \'USER\' from %s", (ctx___0->cli_ctrl)->peer);
#line 531
          client_respond(530, (char *)((void *)0), (char *)"Not logged in");
#line 533
          client_reinit();
          }
#line 534
          return;
        }
      } else {
        {
#line 537
        syslog_write(14, (char *)"magic dest missed in \'USER\' from %s", (ctx___0->cli_ctrl)->peer);
#line 540
        client_respond(530, (char *)((void *)0), (char *)"Not logged in");
#line 541
        client_reinit();
        }
#line 542
        return;
      }
    } else {
      {
#line 545
      tmp___28 = config_bool((char *)((void *)0), (char *)"AllowMagicUser", 0);
      }
#line 545
      if (tmp___28 != 0) {
        {
#line 546
        tmp___24 = config_str((char *)((void *)0), (char *)"UseMagicChar", (char *)"@");
#line 546
        tmp___25 = config_str((char *)((void *)0), (char *)"UserMagicChar", tmp___24);
#line 546
        u_sep___2 = tmp___25;
#line 548
        p___1 = strrchr((char const   *)arg, (int )*(u_sep___2 + 0));
        }
#line 548
        if (p___1) {
          {
#line 549
          tmp___26 = p___1;
#line 549
          p___1 ++;
#line 549
          *tmp___26 = (char )'\000';
#line 550
          tmp___27 = parse_magic_dest(ctx___0, p___1);
          }
#line 550
          if (-1 == tmp___27) {
            {
#line 551
            syslog_write(14, (char *)"invalid magic in \'USER\' from %s", (ctx___0->cli_ctrl)->peer);
#line 554
            client_respond(530, (char *)((void *)0), (char *)"Not logged in");
#line 556
            client_reinit();
            }
#line 557
            return;
          }
        }
      }
    }
    {
#line 561
    ctx___0->username = misc_strdup((char *)"/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-cmds.c",
                                    561, arg);
    }
#line 562
    if ((unsigned long )((void *)0) == (unsigned long )ctx___0->username) {
      {
#line 563
      client_respond(501, (char *)((void *)0), (char *)"Missing user name");
#line 564
      syslog_write(13, (char *)"\'USER\' without name from %s", (ctx___0->cli_ctrl)->peer);
      }
#line 566
      return;
    } else
#line 562
    if ((unsigned long )((char *)0) == (unsigned long )ctx___0->username) {
      {
#line 563
      client_respond(501, (char *)((void *)0), (char *)"Missing user name");
#line 564
      syslog_write(13, (char *)"\'USER\' without name from %s", (ctx___0->cli_ctrl)->peer);
      }
#line 566
      return;
    }
  }
#line 573
  if (ctx___0->magic_addr != 0U) {
#line 573
    if (ctx___0->magic_addr != 4294967295U) {
      {
#line 576
      tmp___30 = socket_addr2str(ctx___0->magic_addr);
#line 576
      syslog_write(12, (char *)"\'USER %s\' dest %s:%d from %s", arg, tmp___30, (int )ctx___0->magic_port,
                   (ctx___0->cli_ctrl)->peer);
      }
    } else {
#line 573
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    {
#line 580
    tmp___31 = config_str((char *)((void *)0), (char *)"DestinationAddress", (char *)((void *)0));
    }
#line 580
    if ((unsigned long )tmp___31 == (unsigned long )((void *)0)) {
      {
#line 581
      syslog_write(14, (char *)"unknown destination address");
#line 582
      client_respond(501, (char *)((void *)0), (char *)"Unknown destination address");
#line 583
      client_reinit();
      }
#line 584
      return;
    } else {
      {
#line 586
      syslog_write(12, (char *)"\'USER %s\' from %s", arg, (ctx___0->cli_ctrl)->peer);
      }
    }
  }
#line 590
  if (0 != ctx___0->auth_mode) {
    {
#line 594
    cmds_set_allow((char *)"PASS");
#line 601
    client_respond(331, (char *)((void *)0), (char *)"User name okay, need password.");
    }
  } else {
    {
#line 606
    tmp___32 = client_setup((char *)((void *)0));
    }
#line 606
    if (0 == tmp___32) {
      {
#line 607
      client_srv_open();
      }
    } else {
      {
#line 612
      client_respond(530, (char *)((void *)0), (char *)"Not logged in");
#line 613
      client_reinit();
      }
    }
  }
#line 616
  return;
}
}
#line 632 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-cmds.c"
static void cmds_pass(CONTEXT *ctx___0 , char *arg ) 
{ 
  char *pass ;
  char *q ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 634
  pass = (char *)((void *)0);
#line 634
  q = (char *)((void *)0);
#line 636
  if ((unsigned long )ctx___0 == (unsigned long )((void *)0)) {
    {
#line 637
    misc_die((char *)"/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-cmds.c",
             637, (char *)"cmds_pass: ?ctx?");
    }
  }
  {
#line 642
  syslog_write(12, (char *)"\'PASS XXXX\' from %s", (ctx___0->cli_ctrl)->peer);
  }
#line 648
  if ((unsigned long )((void *)0) == (unsigned long )arg) {
#line 649
    pass = (char *)"";
  } else {
#line 651
    pass = arg;
  }
#line 656
  if (0 != ctx___0->auth_mode) {
#line 661
    if (1 == ctx___0->auth_mode) {
      {
#line 662
      ctx___0->userpass = misc_strdup((char *)"/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-cmds.c",
                                      662, pass);
      }
    } else
#line 668
    if ((unsigned long )((void *)0) != (unsigned long )ctx___0->magic_auth) {
#line 668
      if ((int )*(pass + 0) != 0) {
#line 669
        if (ctx___0->auth_mode == 2) {
          {
#line 670
          q = strchr((char const   *)pass, (int )*(ctx___0->magic_auth + (sizeof("auth") - 1UL)));
          }
#line 671
          if ((unsigned long )((void *)0) != (unsigned long )q) {
            {
#line 672
            tmp = q;
#line 672
            q ++;
#line 672
            *tmp = (char )'\000';
#line 673
            ctx___0->userpass = misc_strdup((char *)"/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-cmds.c",
                                            673, q);
            }
          }
        } else {
          {
#line 676
          q = strrchr((char const   *)pass, (int )*(ctx___0->magic_auth + 0));
          }
#line 677
          if ((unsigned long )((void *)0) != (unsigned long )q) {
            {
#line 678
            tmp___0 = q;
#line 678
            q ++;
#line 678
            *tmp___0 = (char )'\000';
#line 679
            ctx___0->userpass = misc_strdup((char *)"/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-cmds.c",
                                            679, pass);
#line 680
            pass = q;
            }
          }
        }
#line 683
        if ((unsigned long )((void *)0) == (unsigned long )q) {
          {
#line 684
          syslog_write(14, (char *)"invalid magic in \'PASS\' from %s", (ctx___0->cli_ctrl)->peer);
#line 687
          client_respond(530, (char *)((void *)0), (char *)"Not logged in");
#line 688
          client_reinit();
          }
#line 689
          return;
        }
      }
    }
    {
#line 697
    tmp___1 = client_setup(pass);
    }
#line 697
    if (0 == tmp___1) {
      {
#line 698
      client_srv_open();
      }
    } else {
      {
#line 700
      client_respond(530, (char *)((void *)0), (char *)"Not logged in");
#line 701
      client_reinit();
      }
    }
  } else {
#line 707
    if ((unsigned long )ctx___0->srv_ctrl == (unsigned long )((void *)0)) {
      {
#line 708
      client_respond(530, (char *)((void *)0), (char *)"Not logged in");
#line 709
      syslog_write(13, (char *)"\'PASS\' without login from %s", (ctx___0->cli_ctrl)->peer);
      }
#line 711
      return;
    }
    {
#line 717
    socket_printf(ctx___0->srv_ctrl, (char *)"PASS %.1024s\r\n", pass);
#line 718
    syslog_write(12, (char *)"\'PASS XXXX\' from %s", (ctx___0->cli_ctrl)->peer);
#line 722
    ctx___0->expect = 7;
    }
  }
#line 724
  return;
}
}
#line 740 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-cmds.c"
static void cmds_rein(CONTEXT *ctx___0 , char *arg ) 
{ 


  {
#line 742
  if ((unsigned long )ctx___0 == (unsigned long )((void *)0)) {
    {
#line 743
    misc_die((char *)"/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-cmds.c",
             743, (char *)"cmds_rein: ?ctx?");
    }
  }
  {
#line 744
  arg = arg;
#line 746
  syslog_write(12, (char *)"\'REIN\' from %s", (ctx___0->cli_ctrl)->peer);
#line 751
  client_reinit();
  }
#line 752
  return;
}
}
#line 768 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-cmds.c"
static void cmds_quit(CONTEXT *ctx___0 , char *arg ) 
{ 


  {
#line 770
  if ((unsigned long )ctx___0 == (unsigned long )((void *)0)) {
    {
#line 771
    misc_die((char *)"/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-cmds.c",
             771, (char *)"cmds_quit: ?ctx?");
    }
  }
#line 772
  arg = arg;
#line 777
  if ((unsigned long )ctx___0->srv_data != (unsigned long )((void *)0)) {
    {
#line 778
    socket_kill(ctx___0->srv_data);
#line 779
    ctx___0->srv_data = (HLS *)((void *)0);
    }
  }
#line 781
  if ((unsigned long )ctx___0->cli_data != (unsigned long )((void *)0)) {
    {
#line 782
    socket_kill(ctx___0->cli_data);
#line 783
    ctx___0->cli_data = (HLS *)((void *)0);
    }
  }
#line 785
  if ((unsigned long )ctx___0->srv_ctrl != (unsigned long )((void *)0)) {
    {
#line 786
    socket_printf(ctx___0->srv_ctrl, (char *)"QUIT\r\n");
#line 787
    (ctx___0->srv_ctrl)->kill = 1;
    }
  }
  {
#line 793
  client_respond(221, (char *)((void *)0), (char *)"Goodbye");
#line 794
  syslog_write(12, (char *)"\'QUIT\' from %s", (ctx___0->cli_ctrl)->peer);
#line 795
  ctx___0->expect = 0;
#line 796
  (ctx___0->cli_ctrl)->kill = 1;
  }
#line 797
  return;
}
}
#line 813 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-cmds.c"
static void cmds_port(CONTEXT *ctx___0 , char *arg ) 
{ 
  int h1 ;
  int h2 ;
  int h3 ;
  int h4 ;
  int p1 ;
  int p2 ;
  u_int32_t addr ;
  u_int16_t port ;
  char *peer ;
  int tmp ;
  int tmp___0 ;

  {
#line 820
  if ((unsigned long )ctx___0 == (unsigned long )((void *)0)) {
    {
#line 821
    misc_die((char *)"/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-cmds.c",
             821, (char *)"cmds_port: ?ctx?");
    }
  }
#line 826
  if ((unsigned long )arg == (unsigned long )((void *)0)) {
    {
#line 831
    client_respond(501, (char *)((void *)0), (char *)"Syntax error in arguments");
#line 832
    syslog_write(13, (char *)"syntax error in \'PORT\' from %s", (ctx___0->cli_ctrl)->peer);
#line 835
    client_data_reset(0);
    }
#line 836
    return;
  } else {
    {
#line 826
    tmp = sscanf((char const   */* __restrict  */)arg, (char const   */* __restrict  */)"%d,%d,%d,%d,%d,%d",
                 & h1, & h2, & h3, & h4, & p1, & p2);
    }
#line 826
    if (tmp != 6) {
      {
#line 831
      client_respond(501, (char *)((void *)0), (char *)"Syntax error in arguments");
#line 832
      syslog_write(13, (char *)"syntax error in \'PORT\' from %s", (ctx___0->cli_ctrl)->peer);
#line 835
      client_data_reset(0);
      }
#line 836
      return;
    } else
#line 826
    if (h1 < 0) {
      {
#line 831
      client_respond(501, (char *)((void *)0), (char *)"Syntax error in arguments");
#line 832
      syslog_write(13, (char *)"syntax error in \'PORT\' from %s", (ctx___0->cli_ctrl)->peer);
#line 835
      client_data_reset(0);
      }
#line 836
      return;
    } else
#line 826
    if (h1 > 255) {
      {
#line 831
      client_respond(501, (char *)((void *)0), (char *)"Syntax error in arguments");
#line 832
      syslog_write(13, (char *)"syntax error in \'PORT\' from %s", (ctx___0->cli_ctrl)->peer);
#line 835
      client_data_reset(0);
      }
#line 836
      return;
    } else
#line 826
    if (h2 < 0) {
      {
#line 831
      client_respond(501, (char *)((void *)0), (char *)"Syntax error in arguments");
#line 832
      syslog_write(13, (char *)"syntax error in \'PORT\' from %s", (ctx___0->cli_ctrl)->peer);
#line 835
      client_data_reset(0);
      }
#line 836
      return;
    } else
#line 826
    if (h2 > 255) {
      {
#line 831
      client_respond(501, (char *)((void *)0), (char *)"Syntax error in arguments");
#line 832
      syslog_write(13, (char *)"syntax error in \'PORT\' from %s", (ctx___0->cli_ctrl)->peer);
#line 835
      client_data_reset(0);
      }
#line 836
      return;
    } else
#line 826
    if (h3 < 0) {
      {
#line 831
      client_respond(501, (char *)((void *)0), (char *)"Syntax error in arguments");
#line 832
      syslog_write(13, (char *)"syntax error in \'PORT\' from %s", (ctx___0->cli_ctrl)->peer);
#line 835
      client_data_reset(0);
      }
#line 836
      return;
    } else
#line 826
    if (h3 > 255) {
      {
#line 831
      client_respond(501, (char *)((void *)0), (char *)"Syntax error in arguments");
#line 832
      syslog_write(13, (char *)"syntax error in \'PORT\' from %s", (ctx___0->cli_ctrl)->peer);
#line 835
      client_data_reset(0);
      }
#line 836
      return;
    } else
#line 826
    if (h4 < 0) {
      {
#line 831
      client_respond(501, (char *)((void *)0), (char *)"Syntax error in arguments");
#line 832
      syslog_write(13, (char *)"syntax error in \'PORT\' from %s", (ctx___0->cli_ctrl)->peer);
#line 835
      client_data_reset(0);
      }
#line 836
      return;
    } else
#line 826
    if (h4 > 255) {
      {
#line 831
      client_respond(501, (char *)((void *)0), (char *)"Syntax error in arguments");
#line 832
      syslog_write(13, (char *)"syntax error in \'PORT\' from %s", (ctx___0->cli_ctrl)->peer);
#line 835
      client_data_reset(0);
      }
#line 836
      return;
    } else
#line 826
    if (p1 < 0) {
      {
#line 831
      client_respond(501, (char *)((void *)0), (char *)"Syntax error in arguments");
#line 832
      syslog_write(13, (char *)"syntax error in \'PORT\' from %s", (ctx___0->cli_ctrl)->peer);
#line 835
      client_data_reset(0);
      }
#line 836
      return;
    } else
#line 826
    if (p1 > 255) {
      {
#line 831
      client_respond(501, (char *)((void *)0), (char *)"Syntax error in arguments");
#line 832
      syslog_write(13, (char *)"syntax error in \'PORT\' from %s", (ctx___0->cli_ctrl)->peer);
#line 835
      client_data_reset(0);
      }
#line 836
      return;
    } else
#line 826
    if (p2 < 0) {
      {
#line 831
      client_respond(501, (char *)((void *)0), (char *)"Syntax error in arguments");
#line 832
      syslog_write(13, (char *)"syntax error in \'PORT\' from %s", (ctx___0->cli_ctrl)->peer);
#line 835
      client_data_reset(0);
      }
#line 836
      return;
    } else
#line 826
    if (p2 > 255) {
      {
#line 831
      client_respond(501, (char *)((void *)0), (char *)"Syntax error in arguments");
#line 832
      syslog_write(13, (char *)"syntax error in \'PORT\' from %s", (ctx___0->cli_ctrl)->peer);
#line 835
      client_data_reset(0);
      }
#line 836
      return;
    }
  }
  {
#line 838
  addr = (u_int32_t )((((h1 << 24) + (h2 << 16)) + (h3 << 8)) + h4);
#line 839
  port = (u_int16_t )((p1 << 8) + p2);
#line 840
  peer = socket_addr2str(addr);
  }
#line 845
  if (ctx___0->same_adr != 0) {
#line 845
    if (addr != (ctx___0->cli_ctrl)->addr) {
      {
#line 846
      client_respond(501, (char *)((void *)0), (char *)"PORT address does not match originator");
#line 848
      syslog_write(13, (char *)"different address in \'PORT\' from %s", (ctx___0->cli_ctrl)->peer);
#line 851
      client_data_reset(0);
      }
#line 852
      return;
    }
  }
  {
#line 859
  tmp___0 = config_bool((char *)((void *)0), (char *)"PortResetsPasv", 1);
  }
#line 859
  if (tmp___0) {
#line 860
    if ((unsigned long )ctx___0->cli_data != (unsigned long )((void *)0)) {
      {
#line 861
      syslog_write(13, (char *)"killing old PASV socket for %s", (ctx___0->cli_ctrl)->peer);
#line 864
      socket_kill(ctx___0->cli_data);
#line 865
      ctx___0->cli_data = (HLS *)((void *)0);
      }
    }
#line 867
    ctx___0->cli_mode = 1;
  }
  {
#line 873
  ctx___0->cli_addr = addr;
#line 874
  ctx___0->cli_port = port;
#line 876
  client_respond(200, (char *)((void *)0), (char *)"PORT command successful");
#line 877
  syslog_write(12, (char *)"\'PORT %s:%d\' from %s", peer, (int )port, (ctx___0->cli_ctrl)->peer);
  }
#line 879
  return;
}
}
#line 897 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-cmds.c"
static void cmds_pasv(CONTEXT *ctx___0 , char *arg ) 
{ 
  u_int32_t addr ;
  u_int16_t port ;
  char str___0[1024] ;
  char *p ;
  char *q ;
  FILE *fp ;
  int incr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 905
  if ((unsigned long )ctx___0 == (unsigned long )((void *)0)) {
    {
#line 906
    misc_die((char *)"/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-cmds.c",
             906, (char *)"cmds_pasv: ?ctx?");
    }
  }
#line 907
  arg = arg;
#line 912
  if ((unsigned long )ctx___0->cli_data != (unsigned long )((void *)0)) {
    {
#line 913
    syslog_write(13, (char *)"killing old PASV socket for %s", (ctx___0->cli_ctrl)->peer);
#line 915
    socket_kill(ctx___0->cli_data);
#line 916
    ctx___0->cli_data = (HLS *)((void *)0);
    }
  }
  {
#line 922
  tmp = config_bool((char *)((void *)0), (char *)"SockBindRand", 0);
  }
#line 922
  if (tmp) {
#line 922
    tmp___0 = 0;
  } else {
#line 922
    tmp___0 = 1;
  }
  {
#line 922
  incr = tmp___0;
#line 931
  addr = (in_addr_t )0;
#line 932
  tmp___1 = config_bool((char *)((void *)0), (char *)"AllowTransProxy", 0);
  }
#line 932
  if (tmp___1) {
    {
#line 933
    addr = config_addr((char *)((void *)0), (char *)"Listen", (in_addr_t )0);
    }
  }
#line 935
  if (0U == addr) {
    {
#line 936
    addr = socket_sck2addr((ctx___0->cli_ctrl)->sock, 1, (u_int16_t *)((void *)0));
    }
  }
  {
#line 938
  port = socket_d_listen(addr, ctx___0->pas_lrng, ctx___0->pas_urng, & ctx___0->cli_data,
                         (char *)"Cli-Data", incr);
  }
#line 938
  if ((int )port == 0) {
    {
#line 941
    tmp___2 = socket_addr2str(addr);
#line 941
    syslog_error((char *)"Cli-Data: can\'t bind to %s:%d-%d for %s", tmp___2, (int )ctx___0->pas_lrng,
                 (int )ctx___0->pas_urng, (ctx___0->cli_ctrl)->peer);
#line 944
    client_respond(425, (char *)((void *)0), (char *)"Can\'t open data connection");
    }
#line 945
    return;
  }
  {
#line 954
  p = config_str((char *)((void *)0), (char *)"TranslatedAddress", (char *)((void *)0));
  }
#line 955
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 956
    if ((int )*p == 47) {
      {
#line 957
      fp = fopen((char const   */* __restrict  */)p, (char const   */* __restrict  */)"r");
      }
#line 957
      if ((unsigned long )fp != (unsigned long )((void *)0)) {
        {
#line 958
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 958
          tmp___3 = fgets((char */* __restrict  */)(str___0), (int )sizeof(str___0),
                          (FILE */* __restrict  */)fp);
          }
#line 958
          if (! ((unsigned long )tmp___3 != (unsigned long )((void *)0))) {
#line 958
            goto while_break;
          }
          {
#line 960
          q = misc_strtrim(str___0);
          }
#line 961
          if ((unsigned long )q == (unsigned long )((void *)0)) {
#line 963
            goto while_continue;
          } else
#line 961
          if ((int )*q == 35) {
#line 963
            goto while_continue;
          } else
#line 961
          if ((int )*q == 0) {
#line 963
            goto while_continue;
          }
          {
#line 964
          addr = socket_str2addr(q, addr);
          }
#line 965
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 967
        fclose(fp);
        }
      } else {
        {
#line 969
        syslog_write(13, (char *)"can\'t open NAT file \'%*s\'", 4096, p);
        }
      }
    } else {
      {
#line 974
      addr = socket_str2addr(p, addr);
      }
    }
  }
  {
#line 980
  client_respond(227, (char *)((void *)0), (char *)"Entering Passive Mode (%d,%d,%d,%d,%d,%d)",
                 (int )((addr >> 24) & 255U), (int )((addr >> 16) & 255U), (int )((addr >> 8) & 255U),
                 (int )(addr & 255U), ((int )port >> 8) & 255, (int )port & 255);
#line 988
  tmp___4 = socket_addr2str(addr);
#line 988
  syslog_write(12, (char *)"PASV set to %s:%d for %s", tmp___4, (int )port, (ctx___0->cli_ctrl)->peer);
#line 992
  ctx___0->cli_mode = 2;
  }
#line 993
  return;
}
}
#line 1009 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-cmds.c"
static void cmds_xfer(CONTEXT *ctx___0 , char *arg ) 
{ 
  int mode ;
  char *cmd ;
  u_int32_t addr ;
  u_int16_t port ;
  int incr ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 1011
  mode = 1;
#line 1016
  if ((unsigned long )ctx___0 == (unsigned long )((void *)0)) {
    {
#line 1017
    misc_die((char *)"/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-cmds.c",
             1017, (char *)"cmds_xfer: ?ctx?");
    }
  }
#line 1018
  cmd = ctx___0->curr_cmd;
#line 1018
  if ((unsigned long )cmd == (unsigned long )((void *)0)) {
    {
#line 1019
    misc_die((char *)"/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-cmds.c",
             1019, (char *)"cmds_xfer: ?curr_cmd?");
    }
  }
#line 1020
  if ((unsigned long )arg == (unsigned long )((void *)0)) {
#line 1021
    arg = (char *)"";
  }
#line 1028
  if ((int )*arg == 0) {
    {
#line 1029
    syslog_write(12, (char *)"\'%s\' from %s", cmd, (ctx___0->cli_ctrl)->peer);
    }
  } else {
    {
#line 1032
    syslog_write(12, (char *)"\'%s %.*s\' from %s", cmd, 4096, arg, (ctx___0->cli_ctrl)->peer);
    }
  }
  {
#line 1035
  misc_strncpy(ctx___0->xfer_cmd, (char const   *)cmd, sizeof(ctx___0->xfer_cmd));
#line 1036
  misc_strncpy(ctx___0->xfer_arg, (char const   *)arg, sizeof(ctx___0->xfer_arg));
#line 1041
  mode = ctx___0->srv_mode;
  }
#line 1041
  if (mode == 3) {
#line 1042
    mode = ctx___0->cli_mode;
  }
#line 1047
  if (mode == 2) {
    {
#line 1048
    socket_printf(ctx___0->srv_ctrl, (char *)"PASV\r\n");
#line 1049
    ctx___0->expect = 4;
    }
#line 1050
    return;
  }
#line 1056
  if (mode == 1) {
    {
#line 1060
    tmp = config_bool((char *)((void *)0), (char *)"SockBindRand", 0);
    }
#line 1060
    if (tmp) {
#line 1060
      tmp___0 = 0;
    } else {
#line 1060
      tmp___0 = 1;
    }
    {
#line 1060
    incr = tmp___0;
#line 1062
    addr = socket_sck2addr((ctx___0->srv_ctrl)->sock, 1, (u_int16_t *)((void *)0));
#line 1065
    port = socket_d_listen(addr, ctx___0->srv_lrng, ctx___0->srv_urng, & ctx___0->srv_data,
                           (char *)"Srv-Data", incr);
    }
#line 1065
    if ((int )port == 0) {
      {
#line 1068
      tmp___1 = socket_addr2str(addr);
#line 1068
      syslog_error((char *)"Srv-Data: can\'t bind to %s:%d-%d for %s", tmp___1, (int )ctx___0->srv_lrng,
                   (int )ctx___0->srv_urng, (ctx___0->cli_ctrl)->peer);
#line 1074
      client_respond(425, (char *)((void *)0), (char *)"Can\'t open data connection");
#line 1076
      client_data_reset(0);
      }
#line 1077
      return;
    }
    {
#line 1083
    socket_printf(ctx___0->srv_ctrl, (char *)"PORT %d,%d,%d,%d,%d,%d\r\n", (int )((addr >> 24) & 255U),
                  (int )((addr >> 16) & 255U), (int )((addr >> 8) & 255U), (int )(addr & 255U),
                  ((int )port >> 8) & 255, (int )port & 255);
#line 1091
    tmp___2 = socket_addr2str(addr);
#line 1091
    syslog_write(2, (char *)"\'PORT %s:%d\' for %s", tmp___2, (int )port, (ctx___0->cli_ctrl)->peer);
#line 1094
    ctx___0->expect = 5;
    }
#line 1095
    return;
  }
  {
#line 1101
  misc_die((char *)"/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-cmds.c",
           1101, (char *)"cmds_xfer: ?mode %d?", mode);
  }
#line 1102
  return;
}
}
#line 1118 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-cmds.c"
static void cmds_abor(CONTEXT *ctx___0 , char *arg ) 
{ 
  char str___0[4] ;

  {
#line 1120
  if ((unsigned long )ctx___0 == (unsigned long )((void *)0)) {
    {
#line 1121
    misc_die((char *)"/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-cmds.c",
             1121, (char *)"cmds_abor: ?ctx?");
    }
  }
  {
#line 1122
  arg = arg;
#line 1127
  syslog_write(13, (char *)"\'ABOR\' from %s", (ctx___0->cli_ctrl)->peer);
#line 1132
  client_data_reset(0);
  }
#line 1137
  if ((unsigned long )ctx___0->cli_data == (unsigned long )((void *)0)) {
#line 1137
    if ((unsigned long )ctx___0->srv_data == (unsigned long )((void *)0)) {
      {
#line 1138
      client_respond(225, (char *)((void *)0), (char *)"ABOR command successful");
      }
#line 1139
      return;
    }
  }
#line 1145
  if ((unsigned long )ctx___0->cli_data != (unsigned long )((void *)0)) {
    {
#line 1146
    socket_kill(ctx___0->cli_data);
#line 1147
    ctx___0->cli_data = (HLS *)((void *)0);
#line 1148
    client_respond(426, (char *)((void *)0), (char *)"Connection closed; transfer aborted");
#line 1150
    client_respond(226, (char *)((void *)0), (char *)"ABOR command successful");
    }
  }
#line 1157
  if ((unsigned long )ctx___0->srv_ctrl != (unsigned long )((void *)0)) {
    {
#line 1160
    socket_flag(ctx___0->srv_ctrl, 1);
#line 1161
    str___0[0] = (char)-1;
#line 1162
    str___0[1] = (char)-12;
#line 1163
    str___0[2] = (char)-1;
#line 1164
    socket_write(ctx___0->srv_ctrl, str___0, 3);
#line 1165
    socket_flag(ctx___0->srv_ctrl, 0);
#line 1166
    str___0[0] = (char)-14;
#line 1167
    socket_write(ctx___0->srv_ctrl, str___0, 1);
#line 1169
    socket_printf(ctx___0->srv_ctrl, (char *)"ABOR\r\n");
#line 1170
    ctx___0->expect = 3;
    }
  }
#line 1172
  return;
}
}
#line 1294 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-cmds.c"
static char str[1024]  ;
#line 1292 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-cmds.c"
char *cmds_reg_comp(void **ppre , char *ptr ) 
{ 
  char tmp[1024] ;
  int c ;
  size_t i ;
  regex_t *re ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;

  {
#line 1300
  if ((unsigned long )ppre == (unsigned long )((void *)0)) {
    {
#line 1301
    misc_die((char *)"/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-cmds.c",
             1301, (char *)"cmds_reg_comp: ?ppre?");
    }
  }
#line 1306
  if ((unsigned long )*ppre != (unsigned long )((void *)0)) {
    {
#line 1307
    regfree((regex_t *)*ppre);
#line 1308
    misc_free((char *)"/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-cmds.c",
              1308, *ppre);
#line 1309
    *ppre = (void *)0;
    }
  }
#line 1315
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 1316
    return ((char *)((void *)0));
  }
  {
#line 1321
  memset((void *)(str), 0, sizeof(str));
#line 1322
  i = (size_t )0;
  }
  {
#line 1322
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1322
    if ((int )*ptr != 0) {
#line 1322
      if (! (i < sizeof(str) - 64UL)) {
#line 1322
        goto while_break;
      }
    } else {
#line 1322
      goto while_break;
    }
#line 1323
    if ((int )*ptr == 32) {
#line 1324
      goto while_break;
    } else
#line 1323
    if ((int )*ptr == 9) {
#line 1324
      goto while_break;
    }
#line 1325
    if ((int )*ptr != 37) {
#line 1326
      tmp___0 = i;
#line 1326
      i ++;
#line 1326
      str[tmp___0] = *ptr;
#line 1327
      goto __Cont;
    }
    {
#line 1329
    tmp___2 = __ctype_b_loc();
    }
#line 1329
    if ((int const   )*(*tmp___2 + (int )*(ptr + 1)) & 4096) {
      {
#line 1329
      tmp___3 = __ctype_b_loc();
      }
#line 1329
      if ((int const   )*(*tmp___3 + (int )*(ptr + 2)) & 4096) {
        {
#line 1331
        snprintf((char */* __restrict  */)(tmp), sizeof(tmp), (char const   */* __restrict  */)"%.2s",
                 ptr + 1);
#line 1335
        sscanf((char const   */* __restrict  */)(tmp), (char const   */* __restrict  */)"%x",
               & c);
#line 1336
        tmp___1 = i;
#line 1336
        i ++;
#line 1336
        str[tmp___1] = (char )c;
#line 1337
        ptr += 2;
        }
#line 1338
        goto __Cont;
      }
    }
#line 1340
    tmp___4 = i;
#line 1340
    i ++;
#line 1340
    str[tmp___4] = (char )'%';
    __Cont: /* CIL Label */ 
#line 1322
    ptr ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1346
  tmp___5 = misc_alloc((char *)"/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-cmds.c",
                       1346, sizeof(regex_t ));
#line 1346
  re = (regex_t *)tmp___5;
#line 1347
  tmp___6 = regcomp((regex_t */* __restrict  */)re, (char const   */* __restrict  */)(str),
                    (1 | ((1 << 1) << 1)) | (((1 << 1) << 1) << 1));
#line 1347
  i = (size_t )tmp___6;
  }
#line 1347
  if (i != 0UL) {
    {
#line 1349
    regerror((int )i, (regex_t const   */* __restrict  */)re, (char */* __restrict  */)(tmp),
             sizeof(tmp));
#line 1350
    syslog_error((char *)"can\'t eval RegEx \'%s\': %s", str, tmp);
#line 1351
    regfree(re);
#line 1352
    misc_free((char *)"/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-cmds.c",
              1352, (void *)re);
    }
#line 1353
    return ((char *)((void *)0));
  }
#line 1359
  *ppre = (void *)re;
#line 1360
  return (str);
}
}
#line 1379 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-cmds.c"
static char err[1024]  ;
#line 1377 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-cmds.c"
char *cmds_reg_exec(void *regex , char *str___0 ) 
{ 
  int i ;

  {
#line 1382
  if ((unsigned long )regex == (unsigned long )((void *)0)) {
    {
#line 1383
    misc_die((char *)"/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-cmds.c",
             1383, (char *)"cmds_reg_exec: ?regex? ?str?");
    }
  } else
#line 1382
  if ((unsigned long )str___0 == (unsigned long )((void *)0)) {
    {
#line 1383
    misc_die((char *)"/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-cmds.c",
             1383, (char *)"cmds_reg_exec: ?regex? ?str?");
    }
  }
  {
#line 1388
  i = regexec((regex_t const   */* __restrict  */)((regex_t *)regex), (char const   */* __restrict  */)str___0,
              (size_t )0, (regmatch_t */* __restrict  */)((void *)0), 0);
  }
#line 1388
  if (i != 0) {
    {
#line 1389
    regerror(i, (regex_t const   */* __restrict  */)((regex_t *)regex), (char */* __restrict  */)(err),
             sizeof(err));
    }
#line 1390
    return (err);
  }
#line 1396
  return ((char *)((void *)0));
}
}
#line 1400 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-cmds.c"
static int parse_magic_user(CONTEXT *ctx___0 , char *uarg , char a_sep , int a_first ,
                            char u_sep , int u_force ) 
{ 
  char *p ;
  char *q ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;

  {
#line 1406
  if ((unsigned long )((void *)0) == (unsigned long )uarg) {
    {
#line 1407
    misc_die((char *)"/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-cmds.c",
             1407, (char *)"parse_magic_user: ?uarg? ?a_sep?");
    }
  } else
#line 1406
  if ((unsigned long )((char *)0) == (unsigned long )uarg) {
    {
#line 1407
    misc_die((char *)"/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-cmds.c",
             1407, (char *)"parse_magic_user: ?uarg? ?a_sep?");
    }
  } else
#line 1406
  if (0 == (int )a_sep) {
    {
#line 1407
    misc_die((char *)"/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-cmds.c",
             1407, (char *)"parse_magic_user: ?uarg? ?a_sep?");
    }
  }
#line 1415
  if (0 == (int )u_sep) {
#line 1416
    if (a_first) {
      {
#line 1420
      p = strchr((char const   *)uarg, (int )a_sep);
      }
#line 1421
      if ((unsigned long )((void *)0) == (unsigned long )p) {
#line 1425
        return (-1);
      }
#line 1427
      tmp = p;
#line 1427
      p ++;
#line 1427
      *tmp = (char )'\000';
#line 1428
      if (0 == (int )*(p + 0)) {
#line 1432
        return (-1);
      } else
#line 1428
      if ((unsigned long )((char *)0) == (unsigned long )uarg) {
#line 1432
        return (-1);
      }
      {
#line 1434
      ctx___0->userauth = misc_strdup((char *)"/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-cmds.c",
                                      1434, uarg);
#line 1435
      ctx___0->username = misc_strdup((char *)"/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-cmds.c",
                                      1435, p);
      }
    } else {
      {
#line 1440
      p = strrchr((char const   *)uarg, (int )a_sep);
      }
#line 1441
      if ((unsigned long )((void *)0) == (unsigned long )p) {
#line 1445
        return (-1);
      }
#line 1447
      tmp___0 = p;
#line 1447
      p ++;
#line 1447
      *tmp___0 = (char )'\000';
#line 1448
      if (0 == (int )*(p + 0)) {
#line 1452
        return (-1);
      } else
#line 1448
      if ((unsigned long )((char *)0) == (unsigned long )uarg) {
#line 1452
        return (-1);
      }
      {
#line 1454
      ctx___0->username = misc_strdup((char *)"/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-cmds.c",
                                      1454, uarg);
#line 1455
      ctx___0->userauth = misc_strdup((char *)"/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-cmds.c",
                                      1455, p);
      }
    }
#line 1461
    return (0);
  }
#line 1464
  if (a_first) {
    {
#line 1468
    p = strchr((char const   *)uarg, (int )a_sep);
    }
#line 1469
    if ((unsigned long )((void *)0) == (unsigned long )p) {
#line 1473
      return (-1);
    }
#line 1475
    tmp___1 = p;
#line 1475
    p ++;
#line 1475
    *tmp___1 = (char )'\000';
#line 1476
    if (0 == (int )*(p + 0)) {
#line 1480
      return (-1);
    } else
#line 1476
    if ((unsigned long )((char *)0) == (unsigned long )uarg) {
#line 1480
      return (-1);
    }
    {
#line 1482
    q = strrchr((char const   *)p, (int )u_sep);
    }
#line 1483
    if ((unsigned long )((void *)0) == (unsigned long )q) {
#line 1487
      if (u_force) {
#line 1488
        return (1);
      }
    } else {
#line 1490
      tmp___2 = q;
#line 1490
      q ++;
#line 1490
      *tmp___2 = (char )'\000';
#line 1491
      if (0 == (int )*(p + 0)) {
#line 1495
        return (-1);
      } else
#line 1491
      if (0 == (int )*(q + 0)) {
#line 1495
        return (-1);
      }
      {
#line 1497
      tmp___3 = parse_magic_dest(ctx___0, q);
      }
#line 1497
      if (-1 == tmp___3) {
#line 1498
        return (-1);
      }
    }
    {
#line 1500
    ctx___0->userauth = misc_strdup((char *)"/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-cmds.c",
                                    1500, uarg);
#line 1501
    ctx___0->username = misc_strdup((char *)"/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-cmds.c",
                                    1501, p);
    }
#line 1506
    return (0);
  }
  {
#line 1512
  p = strrchr((char const   *)uarg, (int )a_sep);
  }
#line 1513
  if ((unsigned long )((void *)0) == (unsigned long )p) {
#line 1517
    return (-1);
  }
#line 1519
  tmp___4 = p;
#line 1519
  p ++;
#line 1519
  *tmp___4 = (char )'\000';
#line 1520
  if (0 == (int )*(p + 0)) {
#line 1524
    return (-1);
  } else
#line 1520
  if ((unsigned long )((char *)0) == (unsigned long )uarg) {
#line 1524
    return (-1);
  }
#line 1526
  if ((int )a_sep == (int )u_sep) {
    {
#line 1527
    q = strrchr((char const   *)uarg, (int )u_sep);
    }
#line 1528
    if ((unsigned long )((void *)0) == (unsigned long )q) {
#line 1532
      if (u_force) {
#line 1533
        return (1);
      }
      {
#line 1534
      ctx___0->username = misc_strdup((char *)"/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-cmds.c",
                                      1534, uarg);
#line 1535
      ctx___0->userauth = misc_strdup((char *)"/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-cmds.c",
                                      1535, p);
      }
    } else {
#line 1537
      tmp___5 = q;
#line 1537
      q ++;
#line 1537
      *tmp___5 = (char )'\000';
#line 1538
      if (0 == (int )*(uarg + 0)) {
#line 1542
        return (-1);
      } else
#line 1538
      if (0 == (int )*(q + 0)) {
#line 1542
        return (-1);
      }
      {
#line 1544
      tmp___6 = parse_magic_dest(ctx___0, p);
      }
#line 1544
      if (-1 == tmp___6) {
#line 1545
        return (-1);
      }
      {
#line 1546
      ctx___0->username = misc_strdup((char *)"/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-cmds.c",
                                      1546, uarg);
#line 1547
      ctx___0->userauth = misc_strdup((char *)"/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-cmds.c",
                                      1547, q);
      }
    }
  } else {
    {
#line 1550
    q = strchr((char const   *)p, (int )u_sep);
    }
#line 1551
    if ((unsigned long )((void *)0) == (unsigned long )q) {
#line 1555
      if (u_force) {
#line 1556
        return (1);
      }
    } else {
#line 1558
      tmp___7 = q;
#line 1558
      q ++;
#line 1558
      *tmp___7 = (char )'\000';
#line 1559
      if (0 == (int )*(p + 0)) {
#line 1563
        return (-1);
      } else
#line 1559
      if (0 == (int )*(q + 0)) {
#line 1563
        return (-1);
      }
      {
#line 1565
      tmp___8 = parse_magic_dest(ctx___0, q);
      }
#line 1565
      if (-1 == tmp___8) {
#line 1566
        return (-1);
      }
    }
    {
#line 1568
    ctx___0->username = misc_strdup((char *)"/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-cmds.c",
                                    1568, uarg);
#line 1569
    ctx___0->userauth = misc_strdup((char *)"/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-cmds.c",
                                    1569, p);
    }
  }
#line 1575
  return (0);
}
}
#line 1578 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-cmds.c"
static int parse_magic_dest(CONTEXT *ctx___0 , char *dest ) 
{ 
  char *ptr ;
  char *tmp ;

  {
#line 1582
  if (dest) {
#line 1582
    if (*(dest + 0)) {
      {
#line 1583
      ptr = strrchr((char const   *)dest, ':');
      }
#line 1583
      if (ptr) {
        {
#line 1584
        tmp = ptr;
#line 1584
        ptr ++;
#line 1584
        *tmp = (char )'\000';
#line 1585
        ctx___0->magic_port = socket_str2port(ptr, (u_int16_t )21);
        }
      } else {
#line 1587
        ctx___0->magic_port = (u_int16_t )21;
      }
      {
#line 1589
      ctx___0->magic_addr = socket_str2addr(dest, (in_addr_t )0);
      }
#line 1595
      if (ctx___0->magic_addr != 0U) {
#line 1595
        if (ctx___0->magic_addr != 4294967295U) {
#line 1597
          return (0);
        }
      }
    }
  }
#line 1604
  return (-1);
}
}
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 278
extern FILE *freopen(char const   * __restrict  __filename , char const   * __restrict  __modes ,
                     FILE * __restrict  __stream ) ;
#line 306
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 519 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atexit)(void (*__func)(void) ) ;
#line 444 "/usr/include/unistd.h"
extern unsigned int sleep(unsigned int __seconds ) ;
#line 497
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 667
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) setsid)(void) ;
#line 681
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getgid)(void) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 127 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 44 "../common/com-config.h"
extern void config_dump(FILE *fd ) ;
#line 64 "../common/com-misc.h"
extern void misc_forget(void) ;
#line 81
extern void misc_pidfile(char *name ) ;
#line 107 "../common/com-socket.h"
extern int socket_listen(u_int32_t addr , u_int16_t port , void (*func)(int  ) ) ;
#line 108
extern void socket_lclose(int shut ) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-daemon.h"
void daemon_accept(int sock ) ;
#line 118 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-daemon.c"
static void daemon_signal(int signo ) ;
#line 120
static void daemon_cleanup(void) ;
#line 125 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-daemon.c"
static int initflag  =    0;
#line 126 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-daemon.c"
static pid_t daemon_pid  =    0;
#line 127 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-daemon.c"
static time_t last_slice  =    (time_t )0;
#line 128 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-daemon.c"
static int last_count  =    0;
#line 130 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-daemon.c"
static CLIENT clients[512]  ;
#line 145 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-daemon.c"
static void daemon_signal(int signo ) 
{ 
  int tmperr ;
  int *tmp ;
  pid_t pid ;
  int i ;
  int status ;
  CLIENT *clp ;
  int *tmp___0 ;

  {
  {
#line 147
  tmp = __errno_location();
#line 147
  tmperr = *tmp;
  }
  {
#line 153
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 153
    pid = waitpid(-1, & status, 1);
    }
#line 153
    if (! (pid > 0)) {
#line 153
      goto while_break;
    }
#line 160
    i = 0;
#line 160
    clp = clients;
    {
#line 160
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 160
      if (! (i < 512)) {
#line 160
        goto while_break___0;
      }
#line 161
      if (clp->pid == pid) {
        {
#line 162
        clp->pid = 0;
#line 167
        memset((void *)(clp->peer), 0, (size_t )32);
        }
#line 168
        goto while_break___0;
      }
#line 160
      i ++;
#line 160
      clp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 173
  signal(signo, & daemon_signal);
#line 174
  tmp___0 = __errno_location();
#line 174
  *tmp___0 = tmperr;
  }
#line 179
  return;
}
}
#line 196 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-daemon.c"
static void detach_signal(int signo ) 
{ 


  {
  {
#line 199
  if (signo == 1) {
#line 199
    goto case_1;
  }
#line 206
  if (signo == 17) {
#line 206
    goto case_17;
  }
#line 198
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 203
  exit(0);
  }
#line 204
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 210
  exit(1);
  }
#line 211
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 216
  return;
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-daemon.c"
void daemon_init(int detach ) 
{ 
  u_int32_t laddr ;
  u_int16_t lport ;
  pid_t oldpid ;
  char *p ;
  int i ;
  pid_t pid ;
  int tmp ;
  char *tmp___0 ;
  struct stat st ;
  FILE *out ;
  int fd ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  __gid_t tmp___7 ;
  __uid_t tmp___8 ;
  char *tmp___9 ;

  {
#line 242
  i = 0;
  {
#line 242
  while (1) {
    while_continue: /* CIL Label */ ;
#line 242
    if (! (i < 512)) {
#line 242
      goto while_break;
    }
    {
#line 243
    clients[i].pid = 0;
#line 244
    memset((void *)(clients[i].peer), 0, (size_t )32);
#line 242
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 250
  oldpid = getpid();
  }
#line 251
  if (detach) {
    {
#line 257
    signal(1, & detach_signal);
#line 258
    signal(17, & detach_signal);
#line 260
    pid = fork();
    }
    {
#line 262
    if (pid == -1) {
#line 262
      goto case_neg_1;
    }
#line 267
    if (pid == 0) {
#line 267
      goto case_0;
    }
#line 275
    goto switch_default;
    case_neg_1: /* CIL Label */ 
    {
#line 263
    syslog_error((char *)"can\'t fork daemon");
#line 264
    exit(1);
    }
#line 265
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 272
    signal(1, (void (*)(int  ))0);
    }
#line 273
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 284
    sleep(10U);
#line 287
    kill(pid, 15);
#line 289
    syslog_error((char *)"can\'t detach daemon");
#line 290
    exit(1);
    }
#line 291
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 303
  daemon_pid = getpid();
  }
#line 304
  if (initflag == 0) {
    {
#line 305
    atexit(& daemon_cleanup);
#line 306
    initflag = 1;
    }
  }
  {
#line 312
  laddr = config_addr((char *)((void *)0), (char *)"Listen", (in_addr_t )0);
#line 313
  lport = config_port((char *)((void *)0), (char *)"Port", (u_int16_t )21);
#line 314
  i = 0;
  }
  {
#line 314
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 314
    if (! (i < 6)) {
#line 314
      goto while_break___0;
    }
    {
#line 315
    tmp = socket_listen(laddr, lport, & daemon_accept);
    }
#line 315
    if (tmp == 0) {
#line 316
      goto while_break___0;
    }
    {
#line 317
    sleep(30U);
#line 314
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 319
  if (i >= 6) {
    {
#line 320
    syslog_error((char *)"can\'t bind daemon to %d", (int )lport);
#line 321
    exit(1);
    }
  }
  {
#line 327
  signal(17, & daemon_signal);
#line 332
  tmp___0 = config_str((char *)((void *)0), (char *)"PidFile", (char *)((void *)0));
#line 332
  misc_pidfile(tmp___0);
#line 337
  tmp___4 = config_str((char *)((void *)0), (char *)"ServerRoot", (char *)((void *)0));
#line 337
  tmp___5 = misc_chroot(tmp___4);
  }
#line 337
  if (0 == tmp___5) {
    {
#line 344
    tmp___2 = config_filename();
#line 344
    tmp___3 = stat((char const   */* __restrict  */)tmp___2, (struct stat */* __restrict  */)(& st));
    }
#line 344
    if (tmp___3) {
      {
#line 348
      tmp___1 = config_filename();
#line 348
      fd = open(tmp___1, 65, 420);
      }
#line 351
      if (-1 != fd) {
        {
#line 351
        out = fdopen(fd, "w");
        }
#line 351
        if (out) {
          {
#line 352
          config_dump(out);
#line 353
          fflush(out);
#line 354
          fclose(out);
          }
        } else {
#line 351
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 356
        syslog_error((char *)"can\'t write config file into chroot");
        }
#line 358
        if (-1 != fd) {
          {
#line 359
          close(fd);
          }
        }
        {
#line 360
        exit(1);
        }
      }
    }
  }
#line 372
  if (detach) {
    {
#line 373
    kill(oldpid, 1);
    }
  }
  {
#line 379
  misc_uidgid((uid_t )-1, (gid_t )-1);
#line 384
  p = config_str((char *)((void *)0), (char *)"LogDestination", (char *)((void *)0));
  }
#line 384
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
#line 385
    tmp___6 = config_str((char *)((void *)0), (char *)"LogLevel", (char *)((void *)0));
#line 385
    syslog_open(p, tmp___6);
    }
  } else {
    {
#line 386
    syslog_close();
    }
  }
#line 392
  if (detach) {
    {
#line 393
    freopen((char const   */* __restrict  */)"/dev/null", (char const   */* __restrict  */)"r",
            (FILE */* __restrict  */)stdin);
#line 394
    freopen((char const   */* __restrict  */)"/dev/null", (char const   */* __restrict  */)"w",
            (FILE */* __restrict  */)stdout);
#line 395
    freopen((char const   */* __restrict  */)"/dev/null", (char const   */* __restrict  */)"w",
            (FILE */* __restrict  */)stderr);
#line 397
    chdir("/");
#line 399
    setsid();
    }
  }
  {
#line 402
  tmp___7 = getgid();
#line 402
  tmp___8 = getuid();
#line 402
  tmp___9 = config_str((char *)((void *)0), (char *)"ServerRoot", (char *)"/");
#line 402
  syslog_write(1, (char *)"daemon runs in \'%.1024s\' with uid=%d gid=%d", tmp___9,
               (int )tmp___8, (int )tmp___7);
  }
#line 406
  return;
}
}
#line 421 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-daemon.c"
void daemon_accept(int sock ) 
{ 
  time_t slice ;
  int cnt ;
  int i ;
  CLIENT *clp ;
  char str___0[1024] ;
  char *p ;
  char *q ;
  char *peer ;
  FILE *fp ;
  u_int32_t tmp ;
  time_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  pid_t tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 432
  tmp = socket_sck2addr(sock, 2, (u_int16_t *)((void *)0));
#line 432
  peer = socket_addr2str(tmp);
#line 440
  cnt = config_int((char *)((void *)0), (char *)"ForkLimit", 40);
  }
#line 440
  if (cnt > 0) {
    {
#line 441
    tmp___0 = time((time_t *)((void *)0));
#line 441
    slice = tmp___0 / 30L;
    }
#line 442
    if (slice != last_slice) {
#line 443
      last_slice = slice;
#line 444
      last_count = 0;
    }
#line 446
    last_count ++;
#line 446
    if (last_count >= cnt / 2) {
      {
#line 447
      close(sock);
#line 448
      syslog_write(14, (char *)"reject: \'%s\' (ForkLimit %d)", peer, cnt);
      }
#line 451
      return;
    }
  }
  {
#line 458
  cnt = config_int((char *)((void *)0), (char *)"MaxClients", 512);
  }
#line 458
  if (cnt < 1) {
#line 459
    cnt = 1;
  } else
#line 460
  if (cnt > 512) {
#line 461
    cnt = 512;
  }
#line 462
  i = 0;
#line 462
  clp = clients;
  {
#line 462
  while (1) {
    while_continue: /* CIL Label */ ;
#line 462
    if (! (i < cnt)) {
#line 462
      goto while_break;
    }
#line 467
    if (clp->pid != 0) {
      {
#line 467
      tmp___1 = kill(clp->pid, 0);
      }
#line 467
      if (tmp___1 != 0) {
        {
#line 468
        syslog_write(3, (char *)"child with PID %d went away (removing it)", clp->pid);
#line 471
        clp->pid = 0;
        }
#line 472
        goto while_break;
      }
    }
#line 474
    if (clp->pid == 0) {
#line 475
      goto while_break;
    }
#line 462
    i ++;
#line 462
    clp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 477
  if (i >= cnt) {
    {
#line 478
    p = config_str((char *)((void *)0), (char *)"MaxClientsMessage", (char *)((void *)0));
    }
#line 479
    if ((unsigned long )p != (unsigned long )((void *)0)) {
      {
#line 479
      fp = fopen((char const   */* __restrict  */)p, (char const   */* __restrict  */)"r");
      }
#line 479
      if ((unsigned long )fp != (unsigned long )((void *)0)) {
        {
#line 480
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 480
          tmp___3 = fgets((char */* __restrict  */)(str___0), (int )(sizeof(str___0) - 4UL),
                          (FILE */* __restrict  */)fp);
          }
#line 480
          if (! ((unsigned long )tmp___3 != (unsigned long )((void *)0))) {
#line 480
            goto while_break___0;
          }
          {
#line 481
          p = socket_msgline(str___0);
#line 482
          q = strchr((char const   *)p, '\n');
          }
#line 482
          if ((unsigned long )q != (unsigned long )((void *)0)) {
            {
#line 483
            strcpy((char */* __restrict  */)q, (char const   */* __restrict  */)"\r\n");
            }
          } else {
            {
#line 485
            strcat((char */* __restrict  */)p, (char const   */* __restrict  */)"\r\n");
            }
          }
          {
#line 486
          send(sock, (void const   *)"421-", (size_t )4, 0);
#line 487
          tmp___2 = strlen((char const   *)p);
#line 487
          send(sock, (void const   *)p, tmp___2, 0);
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 489
        fclose(fp);
        }
      }
    }
    {
#line 491
    p = config_str((char *)((void *)0), (char *)"MaxClientsString", (char *)((void *)0));
    }
#line 491
    if ((unsigned long )p != (unsigned long )((void *)0)) {
      {
#line 493
      p = socket_msgline(p);
      }
    } else {
#line 495
      p = (char *)"Service not available";
    }
    {
#line 496
    send(sock, (void const   *)"421 ", (size_t )4, 0);
#line 497
    tmp___4 = strlen((char const   *)p);
#line 497
    send(sock, (void const   *)p, tmp___4, 0);
#line 498
    send(sock, (void const   *)".\r\n", (size_t )3, 0);
#line 499
    close(sock);
#line 500
    syslog_write(14, (char *)"reject: \'%s\' (MaxClients %d)", peer, cnt);
    }
#line 502
    return;
  }
  {
#line 508
  tmp___5 = fork();
#line 508
  clp->pid = tmp___5;
  }
  {
#line 509
  if (tmp___5 == -1) {
#line 509
    goto case_neg_1;
  }
#line 517
  if (tmp___5 == 0) {
#line 517
    goto case_0;
  }
#line 520
  goto switch_default;
  case_neg_1: /* CIL Label */ 
  {
#line 510
  clp->pid = 0;
#line 511
  tmp___6 = __errno_location();
  }
#line 511
  if (*tmp___6 != 11) {
    {
#line 512
    syslog_error((char *)"can\'t fork client");
    }
  }
  {
#line 514
  close(sock);
#line 515
  syslog_write(3, (char *)"can\'t fork client now");
  }
#line 516
  return;
  case_0: /* CIL Label */ 
#line 519
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 522
  close(sock);
#line 523
  strcpy((char */* __restrict  */)(clp->peer), (char const   */* __restrict  */)peer);
  }
#line 528
  return;
  switch_break: /* CIL Label */ ;
  }
  {
#line 534
  misc_setprog((char *)"ftp-child", (char **)((void *)0));
#line 543
  tmp___7 = fileno(stdin);
#line 543
  dup2(sock, tmp___7);
#line 544
  tmp___8 = fileno(stdout);
#line 544
  dup2(sock, tmp___8);
#line 545
  close(sock);
#line 550
  misc_forget();
#line 551
  socket_lclose(0);
#line 556
  client_run();
  }
#line 557
  return;
}
}
#line 572 "/home/june/repo/benchmarks/collector/temp/proxy-suite-1.9.2.4/ftp-proxy/ftp-daemon.c"
static void daemon_cleanup(void) 
{ 
  int i ;
  CLIENT *clp ;
  __pid_t tmp ;

  {
  {
#line 577
  tmp = getpid();
  }
#line 577
  if (tmp == daemon_pid) {
#line 578
    i = 0;
#line 578
    clp = clients;
    {
#line 578
    while (1) {
      while_continue: /* CIL Label */ ;
#line 578
      if (! (i < 512)) {
#line 578
        goto while_break;
      }
#line 579
      if (clp->pid == 0) {
#line 580
        goto __Cont;
      }
      {
#line 590
      kill(clp->pid, 15);
      }
      __Cont: /* CIL Label */ 
#line 578
      i ++;
#line 578
      clp ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 592
  return;
}
}
