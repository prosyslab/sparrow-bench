/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 70 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 42 "/home/june/collector/temp/btyacc-3.0/defs.h"
typedef int Yshort;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 147 "/home/june/collector/temp/btyacc-3.0/defs.h"
struct core;
#line 147 "/home/june/collector/temp/btyacc-3.0/defs.h"
typedef struct core core;
#line 148 "/home/june/collector/temp/btyacc-3.0/defs.h"
struct core {
   struct core *next ;
   struct core *link ;
   Yshort number ;
   Yshort accessing_symbol ;
   Yshort nitems ;
   Yshort items[1] ;
};
#line 161
struct shifts;
#line 161 "/home/june/collector/temp/btyacc-3.0/defs.h"
typedef struct shifts shifts;
#line 162 "/home/june/collector/temp/btyacc-3.0/defs.h"
struct shifts {
   struct shifts *next ;
   Yshort number ;
   Yshort nshifts ;
   Yshort shift[1] ;
};
#line 173
struct reductions;
#line 173 "/home/june/collector/temp/btyacc-3.0/defs.h"
typedef struct reductions reductions;
#line 174 "/home/june/collector/temp/btyacc-3.0/defs.h"
struct reductions {
   struct reductions *next ;
   Yshort number ;
   Yshort nreds ;
   Yshort rules[1] ;
};
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 127 "/home/june/collector/temp/btyacc-3.0/defs.h"
struct bucket;
#line 127 "/home/june/collector/temp/btyacc-3.0/defs.h"
typedef struct bucket bucket;
#line 128 "/home/june/collector/temp/btyacc-3.0/defs.h"
struct bucket {
   struct bucket *link ;
   struct bucket *next ;
   char *name ;
   char *tag ;
   char **argnames ;
   char **argtags ;
   Yshort args ;
   Yshort value ;
   Yshort index ;
   Yshort prec ;
   char class ;
   char assoc ;
};
#line 4 "/home/june/collector/temp/btyacc-3.0/mstring.h"
struct mstring {
   char *base ;
   char *ptr ;
   char *end ;
};
#line 265 "/home/june/collector/temp/btyacc-3.0/reader.c"
struct keyword {
   char name[12] ;
   int token ;
};
#line 1141 "/home/june/collector/temp/btyacc-3.0/reader.c"
struct arg_cache {
   struct arg_cache *next ;
   char *code ;
   int rule ;
};
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 197 "/home/june/collector/temp/btyacc-3.0/defs.h"
struct section {
   char *name ;
   char **ptr ;
};
#line 185
struct action;
#line 185 "/home/june/collector/temp/btyacc-3.0/defs.h"
typedef struct action action;
#line 186 "/home/june/collector/temp/btyacc-3.0/defs.h"
struct action {
   struct action *next ;
   Yshort symbol ;
   Yshort number ;
   Yshort prec ;
   char action_code ;
   char assoc ;
   char suppressed ;
};
#line 3 "/home/june/collector/temp/btyacc-3.0/lalr.c"
struct shorts {
   struct shorts *next ;
   Yshort value ;
};
#line 3 "/home/june/collector/temp/btyacc-3.0/lalr.c"
typedef struct shorts shorts;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 620
extern int ( __attribute__((__nonnull__(1))) mkstemp)(char *__template ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 306
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 695
extern int puts(char const   *__s ) ;
#line 207 "/home/june/collector/temp/btyacc-3.0/defs.h"
char dflag  ;
#line 208 "/home/june/collector/temp/btyacc-3.0/defs.h"
char lflag  ;
#line 209 "/home/june/collector/temp/btyacc-3.0/defs.h"
char rflag  ;
#line 210 "/home/june/collector/temp/btyacc-3.0/defs.h"
char tflag  ;
#line 211 "/home/june/collector/temp/btyacc-3.0/defs.h"
char vflag  ;
#line 213
char *myname ;
#line 216 "/home/june/collector/temp/btyacc-3.0/defs.h"
int lineno  ;
#line 217 "/home/june/collector/temp/btyacc-3.0/defs.h"
int outline  ;
#line 225 "/home/june/collector/temp/btyacc-3.0/defs.h"
char *action_file_name  ;
#line 226 "/home/june/collector/temp/btyacc-3.0/defs.h"
char *code_file_name  ;
#line 227 "/home/june/collector/temp/btyacc-3.0/defs.h"
char *defines_file_name  ;
#line 228
char *input_file_name ;
#line 229 "/home/june/collector/temp/btyacc-3.0/defs.h"
char *output_file_name  ;
#line 230 "/home/june/collector/temp/btyacc-3.0/defs.h"
char *text_file_name  ;
#line 231 "/home/june/collector/temp/btyacc-3.0/defs.h"
char *union_file_name  ;
#line 232 "/home/june/collector/temp/btyacc-3.0/defs.h"
char *verbose_file_name  ;
#line 237 "/home/june/collector/temp/btyacc-3.0/defs.h"
FILE *action_file  ;
#line 238 "/home/june/collector/temp/btyacc-3.0/defs.h"
FILE *code_file  ;
#line 239 "/home/june/collector/temp/btyacc-3.0/defs.h"
FILE *defines_file  ;
#line 240 "/home/june/collector/temp/btyacc-3.0/defs.h"
FILE *input_file  ;
#line 241 "/home/june/collector/temp/btyacc-3.0/defs.h"
FILE *output_file  ;
#line 242 "/home/june/collector/temp/btyacc-3.0/defs.h"
FILE *text_file  ;
#line 243 "/home/june/collector/temp/btyacc-3.0/defs.h"
FILE *union_file  ;
#line 244 "/home/june/collector/temp/btyacc-3.0/defs.h"
FILE *verbose_file  ;
#line 246 "/home/june/collector/temp/btyacc-3.0/defs.h"
int nitems  ;
#line 247 "/home/june/collector/temp/btyacc-3.0/defs.h"
int nrules  ;
#line 248 "/home/june/collector/temp/btyacc-3.0/defs.h"
int nsyms  ;
#line 249 "/home/june/collector/temp/btyacc-3.0/defs.h"
int ntokens  ;
#line 250 "/home/june/collector/temp/btyacc-3.0/defs.h"
int nvars  ;
#line 256 "/home/june/collector/temp/btyacc-3.0/defs.h"
int start_symbol  ;
#line 257 "/home/june/collector/temp/btyacc-3.0/defs.h"
char **symbol_name  ;
#line 258 "/home/june/collector/temp/btyacc-3.0/defs.h"
Yshort *symbol_value  ;
#line 259 "/home/june/collector/temp/btyacc-3.0/defs.h"
Yshort *symbol_prec  ;
#line 260 "/home/june/collector/temp/btyacc-3.0/defs.h"
char *symbol_assoc  ;
#line 262 "/home/june/collector/temp/btyacc-3.0/defs.h"
Yshort *ritem  ;
#line 263 "/home/june/collector/temp/btyacc-3.0/defs.h"
Yshort *rlhs  ;
#line 264 "/home/june/collector/temp/btyacc-3.0/defs.h"
Yshort *rrhs  ;
#line 265 "/home/june/collector/temp/btyacc-3.0/defs.h"
Yshort *rprec  ;
#line 266 "/home/june/collector/temp/btyacc-3.0/defs.h"
char *rassoc  ;
#line 268 "/home/june/collector/temp/btyacc-3.0/defs.h"
Yshort **derives  ;
#line 269 "/home/june/collector/temp/btyacc-3.0/defs.h"
char *nullable  ;
#line 315
void no_space(void) ;
#line 316
void open_error(char *filename ) ;
#line 319
void error(int lineno___0 , char *line___0 , char *cptr___0 , char *msg  , ...) ;
#line 351
void lalr(void) ;
#line 390
void lr0(void) ;
#line 393
void done(int k ) ;
#line 394
void onintr(int ignored ) ;
#line 395
void set_signals(void) ;
#line 396
void usage(void) ;
#line 397
void getargs(int argc , char **argv ) ;
#line 398
char *allocate(unsigned int n ) ;
#line 399
void create_file_names(void) ;
#line 400
void open_files(void) ;
#line 401
int main(int argc , char **argv ) ;
#line 404
void make_parser(void) ;
#line 419
void output(void) ;
#line 488
void reader(void) ;
#line 491
void read_skel(char *name ) ;
#line 502
void verbose(void) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 826 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 312 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask ) ;
#line 14 "/home/june/collector/temp/btyacc-3.0/main.c"
int Eflag  =    0;
#line 16 "/home/june/collector/temp/btyacc-3.0/main.c"
char *file_prefix  =    (char *)"y";
#line 17 "/home/june/collector/temp/btyacc-3.0/main.c"
char *myname  =    (char *)"yacc";
#line 25 "/home/june/collector/temp/btyacc-3.0/main.c"
char *temp_form  =    (char *)"yacc_t_XXXXXX";
#line 33 "/home/june/collector/temp/btyacc-3.0/main.c"
char *input_file_name  =    (char *)"";
#line 73 "/home/june/collector/temp/btyacc-3.0/main.c"
void done(int k ) 
{ 


  {
  {
#line 75
  exit(k);
  }
}
}
#line 79 "/home/june/collector/temp/btyacc-3.0/main.c"
void onintr(int ignored ) 
{ 


  {
  {
#line 81
  done(1);
  }
#line 82
  return;
}
}
#line 85 "/home/june/collector/temp/btyacc-3.0/main.c"
void set_signals(void) 
{ 
  __sighandler_t tmp ;
  __sighandler_t tmp___0 ;
  __sighandler_t tmp___1 ;

  {
  {
#line 88
  tmp = signal(2, (void (*)(int  ))1);
  }
#line 88
  if ((unsigned long )tmp != (unsigned long )((void (*)(int  ))1)) {
    {
#line 89
    signal(2, & onintr);
    }
  }
  {
#line 92
  tmp___0 = signal(15, (void (*)(int  ))1);
  }
#line 92
  if ((unsigned long )tmp___0 != (unsigned long )((void (*)(int  ))1)) {
    {
#line 93
    signal(15, & onintr);
    }
  }
  {
#line 96
  tmp___1 = signal(1, (void (*)(int  ))1);
  }
#line 96
  if ((unsigned long )tmp___1 != (unsigned long )((void (*)(int  ))1)) {
    {
#line 97
    signal(1, & onintr);
    }
  }
#line 99
  return;
}
}
#line 102 "/home/june/collector/temp/btyacc-3.0/main.c"
void usage(void) 
{ 


  {
  {
#line 103
  printf((char const   */* __restrict  */)"usage: %s [OPTIONS] file\n", myname);
#line 104
  puts("  -b prefix    Change `y\' into `prefix\' in all output filenames\n  -d           Generate header file `y.tab.h\'\n  -DNAME       Define btyacc preprocessor variable NAME\n  -E           Print preprocessed grammar to stdout\n  -l           Do not insert #line directives into generated code\n  -r           Write tables to `y.tab.c\', code to `y.code.c\'\n  -S x.skel    Select parser skeleton\n  -t           Include debugging code in generated parser\n  -v           Write description of parser to `y.output\'");
#line 114
  exit(1);
  }
}
}
#line 156
char *defd_vars[1000] ;
#line 118 "/home/june/collector/temp/btyacc-3.0/main.c"
void getargs(int argc , char **argv ) 
{ 
  register int i ;
  register char *s ;
  char **ps ;
  char *var_name ;
  int tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 123
  if (argc > 0) {
#line 123
    myname = *(argv + 0);
  }
#line 124
  i = 1;
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    if (! (i < argc)) {
#line 124
      goto while_break;
    }
#line 126
    s = *(argv + i);
#line 127
    if ((int )*s != 45) {
#line 127
      goto while_break;
    }
#line 128
    s ++;
    {
#line 130
    if ((int )*s == 0) {
#line 130
      goto case_0;
    }
#line 135
    if ((int )*s == 45) {
#line 135
      goto case_45;
    }
#line 139
    if ((int )*s == 98) {
#line 139
      goto case_98;
    }
#line 148
    if ((int )*s == 100) {
#line 148
      goto case_100;
    }
#line 152
    if ((int )*s == 68) {
#line 152
      goto case_68;
    }
#line 168
    if ((int )*s == 69) {
#line 168
      goto case_69;
    }
#line 172
    if ((int )*s == 108) {
#line 172
      goto case_108;
    }
#line 176
    if ((int )*s == 114) {
#line 176
      goto case_114;
    }
#line 180
    if ((int )*s == 116) {
#line 180
      goto case_116;
    }
#line 184
    if ((int )*s == 118) {
#line 184
      goto case_118;
    }
#line 188
    if ((int )*s == 83) {
#line 188
      goto case_83;
    }
#line 197
    goto switch_default;
    case_0: /* CIL Label */ 
#line 131
    input_file = stdin;
#line 132
    if (i + 1 < argc) {
      {
#line 132
      usage();
      }
    }
#line 133
    return;
    case_45: /* CIL Label */ 
#line 136
    i ++;
#line 137
    goto no_more_options;
    case_98: /* CIL Label */ 
#line 140
    s ++;
#line 140
    if (*s) {
#line 141
      file_prefix = s;
    } else {
#line 142
      i ++;
#line 142
      if (i < argc) {
#line 143
        file_prefix = *(argv + i);
      } else {
        {
#line 145
        usage();
        }
      }
    }
#line 146
    goto __Cont;
    case_100: /* CIL Label */ 
#line 149
    dflag = (char)1;
#line 150
    goto switch_break;
    case_68: /* CIL Label */ 
#line 155
    var_name = s + 1;
#line 157
    ps = & defd_vars[0];
    {
#line 157
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 157
      if (! *ps) {
#line 157
        goto while_break___0;
      }
      {
#line 158
      tmp = strcmp((char const   *)*ps, (char const   *)var_name);
      }
#line 158
      if (tmp == 0) {
        {
#line 159
        error(lineno, (char *)0, (char *)0, (char *)"Preprocessor variable %s already defined",
              var_name);
        }
      }
#line 157
      ps ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 162
    tmp___0 = strlen((char const   *)var_name);
#line 162
    tmp___1 = malloc((size_t )((unsigned int )(tmp___0 + 1UL)));
#line 162
    *ps = (char *)tmp___1;
#line 163
    strcpy((char */* __restrict  */)*ps, (char const   */* __restrict  */)var_name);
#line 164
    ps ++;
#line 164
    *ps = (char *)((void *)0);
    }
#line 166
    goto __Cont;
    case_69: /* CIL Label */ 
#line 169
    Eflag = 1;
#line 170
    goto switch_break;
    case_108: /* CIL Label */ 
#line 173
    lflag = (char)1;
#line 174
    goto switch_break;
    case_114: /* CIL Label */ 
#line 177
    rflag = (char)1;
#line 178
    goto switch_break;
    case_116: /* CIL Label */ 
#line 181
    tflag = (char)1;
#line 182
    goto switch_break;
    case_118: /* CIL Label */ 
#line 185
    vflag = (char)1;
#line 186
    goto switch_break;
    case_83: /* CIL Label */ 
#line 189
    s ++;
#line 189
    if (*s) {
      {
#line 190
      read_skel(s);
      }
    } else {
#line 191
      i ++;
#line 191
      if (i < argc) {
        {
#line 192
        read_skel(*(argv + i));
        }
      } else {
        {
#line 194
        usage();
        }
      }
    }
#line 195
    goto __Cont;
    switch_default: /* CIL Label */ 
    {
#line 198
    usage();
    }
    switch_break: /* CIL Label */ ;
    }
    {
#line 201
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 203
      s ++;
      {
#line 205
      if ((int )*s == 0) {
#line 205
        goto case_0___0;
      }
#line 208
      if ((int )*s == 100) {
#line 208
        goto case_100___0;
      }
#line 212
      if ((int )*s == 108) {
#line 212
        goto case_108___0;
      }
#line 216
      if ((int )*s == 114) {
#line 216
        goto case_114___0;
      }
#line 220
      if ((int )*s == 116) {
#line 220
        goto case_116___0;
      }
#line 224
      if ((int )*s == 118) {
#line 224
        goto case_118___0;
      }
#line 228
      goto switch_default___0;
      case_0___0: /* CIL Label */ 
#line 206
      goto end_of_option;
      case_100___0: /* CIL Label */ 
#line 209
      dflag = (char)1;
#line 210
      goto switch_break___0;
      case_108___0: /* CIL Label */ 
#line 213
      lflag = (char)1;
#line 214
      goto switch_break___0;
      case_114___0: /* CIL Label */ 
#line 217
      rflag = (char)1;
#line 218
      goto switch_break___0;
      case_116___0: /* CIL Label */ 
#line 221
      tflag = (char)1;
#line 222
      goto switch_break___0;
      case_118___0: /* CIL Label */ 
#line 225
      vflag = (char)1;
#line 226
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
      {
#line 229
      usage();
      }
      switch_break___0: /* CIL Label */ ;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    end_of_option: ;
    __Cont: /* CIL Label */ 
#line 124
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  no_more_options: ;
#line 236
  if (i + 1 != argc) {
    {
#line 236
    usage();
    }
  }
#line 237
  input_file_name = *(argv + i);
#line 239
  if (! file_prefix) {
#line 240
    if (input_file_name) {
      {
#line 241
      file_prefix = strdup((char const   *)input_file_name);
#line 242
      s = strrchr((char const   *)file_prefix, '.');
      }
#line 242
      if (s) {
#line 243
        *s = (char)0;
      }
    } else {
#line 245
      file_prefix = (char *)"y";
    }
  }
#line 248
  return;
}
}
#line 250 "/home/june/collector/temp/btyacc-3.0/main.c"
char *allocate(unsigned int n ) 
{ 
  register char *p ;
  void *tmp ;

  {
#line 254
  p = (char *)((void *)0);
#line 255
  if (n) {
    {
#line 259
    tmp = calloc((size_t )1U, (size_t )(n + 10U));
#line 259
    p = (char *)tmp;
    }
#line 260
    if (! p) {
      {
#line 260
      no_space();
      }
    }
  }
#line 262
  return (p);
}
}
#line 266 "/home/june/collector/temp/btyacc-3.0/main.c"
void create_file_names(void) 
{ 
  int i ;
  int len ;
  char *tmpdir ;
  size_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;

  {
  {
#line 271
  tmpdir = getenv("TMPDIR");
  }
#line 272
  if ((unsigned long )tmpdir == (unsigned long )((char *)0)) {
#line 272
    tmpdir = (char *)"/tmp";
  }
  {
#line 274
  tmp = strlen((char const   *)tmpdir);
#line 274
  len = (int )tmp;
#line 275
  i = len + 13;
  }
#line 276
  if (len) {
#line 276
    if ((int )*(tmpdir + (len - 1)) != 47) {
#line 277
      i ++;
    }
  }
  {
#line 279
  tmp___0 = malloc((size_t )((unsigned int )i));
#line 279
  action_file_name = (char *)tmp___0;
  }
#line 280
  if ((unsigned long )action_file_name == (unsigned long )((char *)0)) {
    {
#line 280
    no_space();
    }
  }
  {
#line 281
  tmp___1 = malloc((size_t )((unsigned int )i));
#line 281
  text_file_name = (char *)tmp___1;
  }
#line 282
  if ((unsigned long )text_file_name == (unsigned long )((char *)0)) {
    {
#line 282
    no_space();
    }
  }
  {
#line 283
  tmp___2 = malloc((size_t )((unsigned int )i));
#line 283
  union_file_name = (char *)tmp___2;
  }
#line 284
  if ((unsigned long )union_file_name == (unsigned long )((char *)0)) {
    {
#line 284
    no_space();
    }
  }
  {
#line 286
  strcpy((char */* __restrict  */)action_file_name, (char const   */* __restrict  */)tmpdir);
#line 287
  strcpy((char */* __restrict  */)text_file_name, (char const   */* __restrict  */)tmpdir);
#line 288
  strcpy((char */* __restrict  */)union_file_name, (char const   */* __restrict  */)tmpdir);
  }
#line 290
  if (len) {
#line 290
    if ((int )*(tmpdir + (len - 1)) != 47) {
#line 292
      *(action_file_name + len) = (char )'/';
#line 293
      *(text_file_name + len) = (char )'/';
#line 294
      *(union_file_name + len) = (char )'/';
#line 295
      len ++;
    }
  }
  {
#line 298
  strcpy((char */* __restrict  */)(action_file_name + len), (char const   */* __restrict  */)temp_form);
#line 299
  strcpy((char */* __restrict  */)(text_file_name + len), (char const   */* __restrict  */)temp_form);
#line 300
  strcpy((char */* __restrict  */)(union_file_name + len), (char const   */* __restrict  */)temp_form);
#line 302
  *(action_file_name + (len + 5)) = (char )'a';
#line 303
  *(text_file_name + (len + 5)) = (char )'t';
#line 304
  *(union_file_name + (len + 5)) = (char )'u';
#line 306
  tmp___3 = strlen((char const   *)file_prefix);
#line 306
  len = (int )tmp___3;
#line 308
  tmp___4 = malloc((size_t )((unsigned int )(len + 7)));
#line 308
  output_file_name = (char *)tmp___4;
  }
#line 309
  if ((unsigned long )output_file_name == (unsigned long )((char *)0)) {
    {
#line 310
    no_space();
    }
  }
  {
#line 311
  strcpy((char */* __restrict  */)output_file_name, (char const   */* __restrict  */)file_prefix);
#line 312
  strcpy((char */* __restrict  */)(output_file_name + len), (char const   */* __restrict  */)".tab.c");
  }
#line 314
  if (rflag) {
    {
#line 316
    tmp___5 = malloc((size_t )((unsigned int )(len + 8)));
#line 316
    code_file_name = (char *)tmp___5;
    }
#line 317
    if ((unsigned long )code_file_name == (unsigned long )((char *)0)) {
      {
#line 318
      no_space();
      }
    }
    {
#line 319
    strcpy((char */* __restrict  */)code_file_name, (char const   */* __restrict  */)file_prefix);
#line 320
    strcpy((char */* __restrict  */)(code_file_name + len), (char const   */* __restrict  */)".code.c");
    }
  } else {
#line 323
    code_file_name = output_file_name;
  }
#line 325
  if (dflag) {
    {
#line 327
    tmp___6 = malloc((size_t )((unsigned int )(len + 7)));
#line 327
    defines_file_name = (char *)tmp___6;
    }
#line 328
    if ((unsigned long )defines_file_name == (unsigned long )((char *)0)) {
      {
#line 329
      no_space();
      }
    }
    {
#line 330
    strcpy((char */* __restrict  */)defines_file_name, (char const   */* __restrict  */)file_prefix);
#line 331
    strcpy((char */* __restrict  */)(defines_file_name + len), (char const   */* __restrict  */)".tab.h");
    }
  }
#line 334
  if (vflag) {
    {
#line 336
    tmp___7 = malloc((size_t )((unsigned int )(len + 8)));
#line 336
    verbose_file_name = (char *)tmp___7;
    }
#line 337
    if ((unsigned long )verbose_file_name == (unsigned long )((char *)0)) {
      {
#line 338
      no_space();
      }
    }
    {
#line 339
    strcpy((char */* __restrict  */)verbose_file_name, (char const   */* __restrict  */)file_prefix);
#line 340
    strcpy((char */* __restrict  */)(verbose_file_name + len), (char const   */* __restrict  */)".output");
    }
  }
#line 342
  return;
}
}
#line 345 "/home/june/collector/temp/btyacc-3.0/main.c"
static FILE *my_mkstemp(char *template ) 
{ 
  mode_t old_mode ;
  int fd ;
  FILE *result ;

  {
  {
#line 352
  old_mode = umask((__mode_t )63);
#line 353
  fd = mkstemp(template);
#line 354
  umask(old_mode);
  }
#line 355
  if (fd == -1) {
#line 355
    return ((FILE *)0);
  }
  {
#line 356
  result = fdopen(fd, "w+b");
#line 357
  unlink((char const   *)template);
  }
#line 358
  return (result);
}
}
#line 362 "/home/june/collector/temp/btyacc-3.0/main.c"
void open_files(void) 
{ 


  {
  {
#line 364
  create_file_names();
  }
#line 366
  if ((unsigned long )input_file == (unsigned long )((FILE *)0)) {
    {
#line 368
    input_file = fopen((char const   */* __restrict  */)input_file_name, (char const   */* __restrict  */)"r");
    }
#line 369
    if ((unsigned long )input_file == (unsigned long )((FILE *)0)) {
      {
#line 370
      open_error(input_file_name);
      }
    }
  }
  {
#line 373
  action_file = my_mkstemp(action_file_name);
  }
#line 374
  if ((unsigned long )action_file == (unsigned long )((FILE *)0)) {
    {
#line 375
    open_error(action_file_name);
    }
  }
  {
#line 377
  text_file = my_mkstemp(text_file_name);
  }
#line 378
  if ((unsigned long )text_file == (unsigned long )((FILE *)0)) {
    {
#line 379
    open_error(text_file_name);
    }
  }
#line 381
  if (vflag) {
    {
#line 383
    verbose_file = fopen((char const   */* __restrict  */)verbose_file_name, (char const   */* __restrict  */)"w");
    }
#line 384
    if ((unsigned long )verbose_file == (unsigned long )((FILE *)0)) {
      {
#line 385
      open_error(verbose_file_name);
      }
    }
  }
#line 388
  if (dflag) {
    {
#line 390
    defines_file = fopen((char const   */* __restrict  */)defines_file_name, (char const   */* __restrict  */)"w");
    }
#line 391
    if ((unsigned long )defines_file == (unsigned long )((FILE *)0)) {
      {
#line 392
      open_error(defines_file_name);
      }
    }
    {
#line 393
    union_file = my_mkstemp(union_file_name);
    }
#line 394
    if ((unsigned long )union_file == (unsigned long )((FILE *)0)) {
      {
#line 395
      open_error(union_file_name);
      }
    }
  }
  {
#line 398
  output_file = fopen((char const   */* __restrict  */)output_file_name, (char const   */* __restrict  */)"w");
  }
#line 399
  if ((unsigned long )output_file == (unsigned long )((FILE *)0)) {
    {
#line 400
    open_error(output_file_name);
    }
  }
#line 402
  if (rflag) {
    {
#line 404
    code_file = fopen((char const   */* __restrict  */)code_file_name, (char const   */* __restrict  */)"w");
    }
#line 405
    if ((unsigned long )code_file == (unsigned long )((FILE *)0)) {
      {
#line 406
      open_error(code_file_name);
      }
    }
  } else {
#line 409
    code_file = output_file;
  }
#line 410
  return;
}
}
#line 413 "/home/june/collector/temp/btyacc-3.0/main.c"
int main(int argc , char **argv ) 
{ 


  {
  {
#line 415
  set_signals();
#line 416
  getargs(argc, argv);
#line 417
  open_files();
#line 418
  reader();
#line 419
  lr0();
#line 420
  lalr();
#line 421
  make_parser();
#line 422
  verbose();
#line 423
  output();
#line 424
  done(0);
  }
#line 425
  return (0);
}
}
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 274 "/home/june/collector/temp/btyacc-3.0/defs.h"
int nstates  ;
#line 275 "/home/june/collector/temp/btyacc-3.0/defs.h"
core *first_state  ;
#line 276 "/home/june/collector/temp/btyacc-3.0/defs.h"
shifts *first_shift  ;
#line 277 "/home/june/collector/temp/btyacc-3.0/defs.h"
reductions *first_reduction  ;
#line 306
void set_first_derives(void) ;
#line 307
void closure(Yshort *nucleus , int n ) ;
#line 308
void finalize_closure(void) ;
#line 314
void fatal(char *msg ) ;
#line 370
void allocate_itemsets(void) ;
#line 371
void allocate_storage(void) ;
#line 372
void append_states(void) ;
#line 373
void free_storage(void) ;
#line 374
void generate_states(void) ;
#line 375
int get_state(int symbol ) ;
#line 376
void initialize_states(void) ;
#line 377
void new_itemsets(void) ;
#line 378
core *new_state(int symbol ) ;
#line 379
void show_cores(void) ;
#line 380
void show_ritems(void) ;
#line 381
void show_rrhs(void) ;
#line 382
void show_shifts(void) ;
#line 383
void save_shifts(void) ;
#line 384
void save_reductions(void) ;
#line 385
void set_derives(void) ;
#line 386
void free_derives(void) ;
#line 388
void set_nullable(void) ;
#line 389
void free_nullable(void) ;
#line 4 "/home/june/collector/temp/btyacc-3.0/lr0.c"
Yshort *itemset ;
#line 5
Yshort *itemsetend ;
#line 6
unsigned int *ruleset ;
#line 13 "/home/june/collector/temp/btyacc-3.0/lr0.c"
static core **state_set  ;
#line 14 "/home/june/collector/temp/btyacc-3.0/lr0.c"
static core *this_state  ;
#line 15 "/home/june/collector/temp/btyacc-3.0/lr0.c"
static core *last_state  ;
#line 16 "/home/june/collector/temp/btyacc-3.0/lr0.c"
static shifts *last_shift  ;
#line 17 "/home/june/collector/temp/btyacc-3.0/lr0.c"
static reductions *last_reduction  ;
#line 19 "/home/june/collector/temp/btyacc-3.0/lr0.c"
static int nshifts  ;
#line 20 "/home/june/collector/temp/btyacc-3.0/lr0.c"
static Yshort *shift_symbol  ;
#line 22 "/home/june/collector/temp/btyacc-3.0/lr0.c"
static Yshort *redset  ;
#line 23 "/home/june/collector/temp/btyacc-3.0/lr0.c"
static Yshort *shiftset  ;
#line 25 "/home/june/collector/temp/btyacc-3.0/lr0.c"
static Yshort **kernel_base  ;
#line 26 "/home/june/collector/temp/btyacc-3.0/lr0.c"
static Yshort **kernel_end  ;
#line 27 "/home/june/collector/temp/btyacc-3.0/lr0.c"
static Yshort *kernel_items  ;
#line 30 "/home/june/collector/temp/btyacc-3.0/lr0.c"
void allocate_itemsets(void) 
{ 
  register Yshort *itemp ;
  register Yshort *item_end ;
  register int symbol ;
  register int i ;
  register int count ;
  register int max ;
  register Yshort *symbol_count ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 40
  count = 0;
#line 41
  tmp = allocate((unsigned int )((unsigned long )nsyms * sizeof(Yshort )));
#line 41
  symbol_count = (Yshort *)tmp;
#line 43
  item_end = ritem + nitems;
#line 44
  itemp = ritem;
  }
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    if (! ((unsigned long )itemp < (unsigned long )item_end)) {
#line 44
      goto while_break;
    }
#line 46
    symbol = *itemp;
#line 47
    if (symbol >= 0) {
#line 49
      count ++;
#line 50
      (*(symbol_count + symbol)) ++;
    }
#line 44
    itemp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 54
  tmp___0 = allocate((unsigned int )((unsigned long )nsyms * sizeof(Yshort *)));
#line 54
  kernel_base = (Yshort **)tmp___0;
#line 55
  tmp___1 = allocate((unsigned int )((unsigned long )count * sizeof(Yshort )));
#line 55
  kernel_items = (Yshort *)tmp___1;
#line 57
  count = 0;
#line 58
  max = 0;
#line 59
  i = 0;
  }
  {
#line 59
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 59
    if (! (i < nsyms)) {
#line 59
      goto while_break___0;
    }
#line 61
    *(kernel_base + i) = kernel_items + count;
#line 62
    count += *(symbol_count + i);
#line 63
    if (max < *(symbol_count + i)) {
#line 64
      max = *(symbol_count + i);
    }
#line 59
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 67
  shift_symbol = symbol_count;
#line 68
  tmp___2 = allocate((unsigned int )((unsigned long )nsyms * sizeof(Yshort *)));
#line 68
  kernel_end = (Yshort **)tmp___2;
  }
#line 69
  return;
}
}
#line 72 "/home/june/collector/temp/btyacc-3.0/lr0.c"
void allocate_storage(void) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 74
  allocate_itemsets();
#line 75
  tmp = allocate((unsigned int )((unsigned long )nsyms * sizeof(Yshort )));
#line 75
  shiftset = (Yshort *)tmp;
#line 76
  tmp___0 = allocate((unsigned int )((unsigned long )(nrules + 1) * sizeof(Yshort )));
#line 76
  redset = (Yshort *)tmp___0;
#line 77
  tmp___1 = allocate((unsigned int )((unsigned long )nitems * sizeof(core *)));
#line 77
  state_set = (core **)tmp___1;
  }
#line 78
  return;
}
}
#line 81 "/home/june/collector/temp/btyacc-3.0/lr0.c"
void append_states(void) 
{ 
  register int i ;
  register int j ;
  register int symbol ;

  {
#line 90
  i = 1;
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
#line 90
    if (! (i < nshifts)) {
#line 90
      goto while_break;
    }
#line 92
    symbol = *(shift_symbol + i);
#line 93
    j = i;
    {
#line 94
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 94
      if (j > 0) {
#line 94
        if (! (*(shift_symbol + (j - 1)) > symbol)) {
#line 94
          goto while_break___0;
        }
      } else {
#line 94
        goto while_break___0;
      }
#line 96
      *(shift_symbol + j) = *(shift_symbol + (j - 1));
#line 97
      j --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 99
    *(shift_symbol + j) = symbol;
#line 90
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  i = 0;
  {
#line 102
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 102
    if (! (i < nshifts)) {
#line 102
      goto while_break___1;
    }
    {
#line 104
    symbol = *(shift_symbol + i);
#line 105
    *(shiftset + i) = get_state(symbol);
#line 102
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 107
  return;
}
}
#line 110 "/home/june/collector/temp/btyacc-3.0/lr0.c"
void free_storage(void) 
{ 


  {
  {
#line 112
  free((void *)((char *)shift_symbol));
#line 113
  free((void *)((char *)redset));
#line 114
  free((void *)((char *)shiftset));
#line 115
  free((void *)((char *)kernel_base));
#line 116
  free((void *)((char *)kernel_end));
#line 117
  free((void *)((char *)kernel_items));
#line 118
  free((void *)((char *)state_set));
  }
#line 119
  return;
}
}
#line 123 "/home/june/collector/temp/btyacc-3.0/lr0.c"
void generate_states(void) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 125
  allocate_storage();
#line 126
  tmp = allocate((unsigned int )((unsigned long )nitems * sizeof(Yshort )));
#line 126
  itemset = (Yshort *)tmp;
#line 127
  tmp___0 = allocate((unsigned int )((unsigned long )((nrules + 31) / 32) * sizeof(unsigned int )));
#line 127
  ruleset = (unsigned int *)tmp___0;
#line 128
  set_first_derives();
#line 129
  initialize_states();
  }
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    if (! this_state) {
#line 131
      goto while_break;
    }
    {
#line 133
    closure(this_state->items, this_state->nitems);
#line 134
    save_reductions();
#line 135
    new_itemsets();
#line 136
    append_states();
    }
#line 138
    if (nshifts > 0) {
      {
#line 139
      save_shifts();
      }
    }
#line 141
    this_state = this_state->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 144
  finalize_closure();
#line 145
  free_storage();
  }
#line 146
  return;
}
}
#line 150 "/home/june/collector/temp/btyacc-3.0/lr0.c"
int get_state(int symbol ) 
{ 
  register int key ;
  register Yshort *isp1 ;
  register Yshort *isp2 ;
  register Yshort *iend ;
  register core *sp ;
  register int found ;
  register int n ;
  Yshort *tmp ;
  Yshort *tmp___0 ;
  struct core *tmp___1 ;

  {
#line 164
  isp1 = *(kernel_base + symbol);
#line 165
  iend = *(kernel_end + symbol);
#line 166
  n = (int )(iend - isp1);
#line 168
  key = *isp1;
#line 169
  if (0 <= key) {
#line 169
    if (! (key < nitems)) {
      {
#line 169
      __assert_fail("0 <= key && key < nitems", "/home/june/collector/temp/btyacc-3.0/lr0.c",
                    169U, "get_state");
      }
    }
  } else {
    {
#line 169
    __assert_fail("0 <= key && key < nitems", "/home/june/collector/temp/btyacc-3.0/lr0.c",
                  169U, "get_state");
    }
  }
#line 170
  sp = *(state_set + key);
#line 171
  if (sp) {
#line 173
    found = 0;
    {
#line 174
    while (1) {
      while_continue: /* CIL Label */ ;
#line 174
      if (! (! found)) {
#line 174
        goto while_break;
      }
#line 176
      if (sp->nitems == n) {
#line 178
        found = 1;
#line 179
        isp1 = *(kernel_base + symbol);
#line 180
        isp2 = sp->items;
        {
#line 182
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 182
          if (found) {
#line 182
            if (! ((unsigned long )isp1 < (unsigned long )iend)) {
#line 182
              goto while_break___0;
            }
          } else {
#line 182
            goto while_break___0;
          }
#line 184
          tmp = isp1;
#line 184
          isp1 ++;
#line 184
          tmp___0 = isp2;
#line 184
          isp2 ++;
#line 184
          if (*tmp != *tmp___0) {
#line 185
            found = 0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 189
      if (! found) {
#line 191
        if (sp->link) {
#line 193
          sp = sp->link;
        } else {
          {
#line 197
          tmp___1 = new_state(symbol);
#line 197
          sp->link = tmp___1;
#line 197
          sp = tmp___1;
#line 198
          found = 1;
          }
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 205
    sp = new_state(symbol);
#line 205
    *(state_set + key) = sp;
    }
  }
#line 208
  return (sp->number);
}
}
#line 213 "/home/june/collector/temp/btyacc-3.0/lr0.c"
void initialize_states(void) 
{ 
  register int i ;
  register Yshort *start_derives ;
  register core *p ;
  void *tmp ;

  {
#line 219
  start_derives = *(derives + start_symbol);
#line 220
  i = 0;
  {
#line 220
  while (1) {
    while_continue: /* CIL Label */ ;
#line 220
    if (! (*(start_derives + i) >= 0)) {
#line 220
      goto while_break;
    }
#line 221
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 220
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 223
  tmp = malloc((size_t )((unsigned int )(sizeof(core ) + (unsigned long )i * sizeof(Yshort ))));
#line 223
  p = (core *)tmp;
  }
#line 224
  if ((unsigned long )p == (unsigned long )((core *)0)) {
    {
#line 224
    no_space();
    }
  }
#line 226
  p->next = (struct core *)0;
#line 227
  p->link = (struct core *)0;
#line 228
  p->number = 0;
#line 229
  p->accessing_symbol = 0;
#line 230
  p->nitems = i;
#line 232
  i = 0;
  {
#line 232
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 232
    if (! (*(start_derives + i) >= 0)) {
#line 232
      goto while_break___0;
    }
#line 233
    p->items[i] = *(rrhs + *(start_derives + i));
#line 232
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 235
  this_state = p;
#line 235
  last_state = this_state;
#line 235
  first_state = last_state;
#line 236
  nstates = 1;
#line 237
  return;
}
}
#line 240 "/home/june/collector/temp/btyacc-3.0/lr0.c"
void new_itemsets(void) 
{ 
  register int i ;
  register int shiftcount ;
  register Yshort *isp ;
  register Yshort *ksp ;
  register int symbol ;
  Yshort *tmp ;
  int tmp___0 ;
  Yshort *tmp___1 ;

  {
#line 248
  i = 0;
  {
#line 248
  while (1) {
    while_continue: /* CIL Label */ ;
#line 248
    if (! (i < nsyms)) {
#line 248
      goto while_break;
    }
#line 249
    *(kernel_end + i) = (Yshort *)0;
#line 248
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 251
  shiftcount = 0;
#line 252
  isp = itemset;
  {
#line 253
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 253
    if (! ((unsigned long )isp < (unsigned long )itemsetend)) {
#line 253
      goto while_break___0;
    }
#line 255
    tmp = isp;
#line 255
    isp ++;
#line 255
    i = *tmp;
#line 256
    symbol = *(ritem + i);
#line 257
    if (symbol > 0) {
#line 259
      ksp = *(kernel_end + symbol);
#line 260
      if (! ksp) {
#line 262
        tmp___0 = shiftcount;
#line 262
        shiftcount ++;
#line 262
        *(shift_symbol + tmp___0) = symbol;
#line 263
        ksp = *(kernel_base + symbol);
      }
#line 266
      tmp___1 = ksp;
#line 266
      ksp ++;
#line 266
      *tmp___1 = i + 1;
#line 267
      *(kernel_end + symbol) = ksp;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 271
  nshifts = shiftcount;
#line 272
  return;
}
}
#line 276 "/home/june/collector/temp/btyacc-3.0/lr0.c"
core *new_state(int symbol ) 
{ 
  register int n ;
  register core *p ;
  register Yshort *isp1 ;
  register Yshort *isp2 ;
  register Yshort *iend ;
  char *tmp ;
  Yshort *tmp___0 ;
  Yshort *tmp___1 ;

  {
#line 288
  if (nstates >= 2147483647) {
    {
#line 289
    fatal((char *)"too many states");
    }
  }
  {
#line 291
  isp1 = *(kernel_base + symbol);
#line 292
  iend = *(kernel_end + symbol);
#line 293
  n = (int )(iend - isp1);
#line 295
  tmp = allocate((unsigned int )(sizeof(core ) + (unsigned long )(n - 1) * sizeof(Yshort )));
#line 295
  p = (core *)tmp;
#line 296
  p->accessing_symbol = symbol;
#line 297
  p->number = nstates;
#line 298
  p->nitems = n;
#line 300
  isp2 = p->items;
  }
  {
#line 301
  while (1) {
    while_continue: /* CIL Label */ ;
#line 301
    if (! ((unsigned long )isp1 < (unsigned long )iend)) {
#line 301
      goto while_break;
    }
#line 302
    tmp___0 = isp2;
#line 302
    isp2 ++;
#line 302
    tmp___1 = isp1;
#line 302
    isp1 ++;
#line 302
    *tmp___0 = *tmp___1;
  }
  while_break: /* CIL Label */ ;
  }
#line 304
  last_state->next = p;
#line 305
  last_state = p;
#line 307
  nstates ++;
#line 309
  return (p);
}
}
#line 315 "/home/june/collector/temp/btyacc-3.0/lr0.c"
void show_cores(void) 
{ 
  core *p ;
  int i ;
  int j ;
  int k ;
  int n ;
  int itemno ;
  int tmp ;
  int tmp___0 ;

  {
#line 321
  k = 0;
#line 322
  p = first_state;
  {
#line 322
  while (1) {
    while_continue: /* CIL Label */ ;
#line 322
    if (! p) {
#line 322
      goto while_break;
    }
#line 324
    if (k) {
      {
#line 324
      printf((char const   */* __restrict  */)"\n");
      }
    }
    {
#line 325
    printf((char const   */* __restrict  */)"state %d, number = %d, accessing symbol = %s\n",
           k, p->number, *(symbol_name + p->accessing_symbol));
#line 327
    n = p->nitems;
#line 328
    i = 0;
    }
    {
#line 328
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 328
      if (! (i < n)) {
#line 328
        goto while_break___0;
      }
      {
#line 330
      itemno = p->items[i];
#line 331
      printf((char const   */* __restrict  */)"%4d  ", itemno);
#line 332
      j = itemno;
      }
      {
#line 333
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 333
        if (! (*(ritem + j) >= 0)) {
#line 333
          goto while_break___1;
        }
#line 333
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 334
      printf((char const   */* __restrict  */)"%s :", *(symbol_name + *(rlhs + - *(ritem + j))));
#line 335
      j = *(rrhs + - *(ritem + j));
      }
      {
#line 336
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 336
        if (! (j < itemno)) {
#line 336
          goto while_break___2;
        }
        {
#line 337
        tmp = j;
#line 337
        j ++;
#line 337
        printf((char const   */* __restrict  */)" %s", *(symbol_name + *(ritem + tmp)));
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 338
      printf((char const   */* __restrict  */)" .");
      }
      {
#line 339
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 339
        if (! (*(ritem + j) >= 0)) {
#line 339
          goto while_break___3;
        }
        {
#line 340
        tmp___0 = j;
#line 340
        j ++;
#line 340
        printf((char const   */* __restrict  */)" %s", *(symbol_name + *(ritem + tmp___0)));
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 341
      printf((char const   */* __restrict  */)"\n");
#line 342
      fflush(stdout);
#line 328
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 322
    k ++;
#line 322
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 345
  return;
}
}
#line 350 "/home/june/collector/temp/btyacc-3.0/lr0.c"
void show_ritems(void) 
{ 
  int i ;

  {
#line 354
  i = 0;
  {
#line 354
  while (1) {
    while_continue: /* CIL Label */ ;
#line 354
    if (! (i < nitems)) {
#line 354
      goto while_break;
    }
    {
#line 355
    printf((char const   */* __restrict  */)"ritem[%d] = %d\n", i, *(ritem + i));
#line 354
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 356
  return;
}
}
#line 360 "/home/june/collector/temp/btyacc-3.0/lr0.c"
void show_rrhs(void) 
{ 
  int i ;

  {
#line 364
  i = 0;
  {
#line 364
  while (1) {
    while_continue: /* CIL Label */ ;
#line 364
    if (! (i < nrules)) {
#line 364
      goto while_break;
    }
    {
#line 365
    printf((char const   */* __restrict  */)"rrhs[%d] = %d\n", i, *(rrhs + i));
#line 364
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 366
  return;
}
}
#line 371 "/home/june/collector/temp/btyacc-3.0/lr0.c"
void show_shifts(void) 
{ 
  shifts *p ;
  int i ;
  int j ;
  int k ;

  {
#line 376
  k = 0;
#line 377
  p = first_shift;
  {
#line 377
  while (1) {
    while_continue: /* CIL Label */ ;
#line 377
    if (! p) {
#line 377
      goto while_break;
    }
#line 379
    if (k) {
      {
#line 379
      printf((char const   */* __restrict  */)"\n");
      }
    }
    {
#line 380
    printf((char const   */* __restrict  */)"shift %d, number = %d, nshifts = %d\n",
           k, p->number, p->nshifts);
#line 382
    j = p->nshifts;
#line 383
    i = 0;
    }
    {
#line 383
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 383
      if (! (i < j)) {
#line 383
        goto while_break___0;
      }
      {
#line 384
      printf((char const   */* __restrict  */)"\t%d\n", p->shift[i]);
#line 383
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 377
    k ++;
#line 377
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 386
  return;
}
}
#line 389 "/home/june/collector/temp/btyacc-3.0/lr0.c"
void save_shifts(void) 
{ 
  register shifts *p ;
  register Yshort *sp1 ;
  register Yshort *sp2 ;
  register Yshort *send ;
  char *tmp ;
  Yshort *tmp___0 ;
  Yshort *tmp___1 ;

  {
  {
#line 396
  tmp = allocate((unsigned int )(sizeof(shifts ) + (unsigned long )(nshifts - 1) * sizeof(Yshort )));
#line 396
  p = (shifts *)tmp;
#line 399
  p->number = this_state->number;
#line 400
  p->nshifts = nshifts;
#line 402
  sp1 = shiftset;
#line 403
  sp2 = p->shift;
#line 404
  send = shiftset + nshifts;
  }
  {
#line 406
  while (1) {
    while_continue: /* CIL Label */ ;
#line 406
    if (! ((unsigned long )sp1 < (unsigned long )send)) {
#line 406
      goto while_break;
    }
#line 407
    tmp___0 = sp2;
#line 407
    sp2 ++;
#line 407
    tmp___1 = sp1;
#line 407
    sp1 ++;
#line 407
    *tmp___0 = *tmp___1;
  }
  while_break: /* CIL Label */ ;
  }
#line 409
  if (last_shift) {
#line 411
    last_shift->next = p;
#line 412
    last_shift = p;
  } else {
#line 416
    first_shift = p;
#line 417
    last_shift = p;
  }
#line 419
  return;
}
}
#line 423 "/home/june/collector/temp/btyacc-3.0/lr0.c"
void save_reductions(void) 
{ 
  register Yshort *isp ;
  register Yshort *rp1 ;
  register Yshort *rp2 ;
  register int item ;
  register int count ;
  register reductions *p ;
  register Yshort *rend ;
  int tmp ;
  char *tmp___0 ;
  Yshort *tmp___1 ;
  Yshort *tmp___2 ;

  {
#line 433
  count = 0;
#line 434
  isp = itemset;
  {
#line 434
  while (1) {
    while_continue: /* CIL Label */ ;
#line 434
    if (! ((unsigned long )isp < (unsigned long )itemsetend)) {
#line 434
      goto while_break;
    }
#line 436
    item = *(ritem + *isp);
#line 437
    if (item < 0) {
#line 439
      tmp = count;
#line 439
      count ++;
#line 439
      *(redset + tmp) = - item;
    }
#line 434
    isp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 443
  if (count) {
    {
#line 445
    tmp___0 = allocate((unsigned int )(sizeof(reductions ) + (unsigned long )(count - 1) * sizeof(Yshort )));
#line 445
    p = (reductions *)tmp___0;
#line 448
    p->number = this_state->number;
#line 449
    p->nreds = count;
#line 451
    rp1 = redset;
#line 452
    rp2 = p->rules;
#line 453
    rend = rp1 + count;
    }
    {
#line 455
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 455
      if (! ((unsigned long )rp1 < (unsigned long )rend)) {
#line 455
        goto while_break___0;
      }
#line 456
      tmp___1 = rp2;
#line 456
      rp2 ++;
#line 456
      tmp___2 = rp1;
#line 456
      rp1 ++;
#line 456
      *tmp___1 = *tmp___2;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 458
    if (last_reduction) {
#line 460
      last_reduction->next = p;
#line 461
      last_reduction = p;
    } else {
#line 465
      first_reduction = p;
#line 466
      last_reduction = p;
    }
  }
#line 469
  return;
}
}
#line 472 "/home/june/collector/temp/btyacc-3.0/lr0.c"
void set_derives(void) 
{ 
  register int i ;
  register int k ;
  register int lhs ;
  register Yshort *rules ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 478
  tmp = allocate((unsigned int )((unsigned long )nsyms * sizeof(Yshort *)));
#line 478
  derives = (Yshort **)tmp;
#line 479
  tmp___0 = allocate((unsigned int )((unsigned long )(nvars + nrules) * sizeof(Yshort )));
#line 479
  rules = (Yshort *)tmp___0;
#line 481
  k = 0;
#line 482
  lhs = start_symbol;
  }
  {
#line 482
  while (1) {
    while_continue: /* CIL Label */ ;
#line 482
    if (! (lhs < nsyms)) {
#line 482
      goto while_break;
    }
#line 484
    *(derives + lhs) = rules + k;
#line 485
    i = 0;
    {
#line 485
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 485
      if (! (i < nrules)) {
#line 485
        goto while_break___0;
      }
#line 487
      if (*(rlhs + i) == lhs) {
#line 489
        *(rules + k) = i;
#line 490
        k ++;
      }
#line 485
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 493
    *(rules + k) = -1;
#line 494
    k ++;
#line 482
    lhs ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 500
  return;
}
}
#line 502 "/home/june/collector/temp/btyacc-3.0/lr0.c"
void free_derives(void) 
{ 


  {
  {
#line 504
  free((void *)((char *)*(derives + start_symbol)));
#line 505
  free((void *)((char *)derives));
  }
#line 506
  return;
}
}
#line 531 "/home/june/collector/temp/btyacc-3.0/lr0.c"
void set_nullable(void) 
{ 
  register int i ;
  register int j ;
  register int empty ;
  int done___0 ;
  void *tmp ;

  {
  {
#line 537
  tmp = malloc((size_t )((unsigned int )nsyms));
#line 537
  nullable = (char *)tmp;
  }
#line 538
  if ((unsigned long )nullable == (unsigned long )((char *)0)) {
    {
#line 538
    no_space();
    }
  }
#line 540
  i = 0;
  {
#line 540
  while (1) {
    while_continue: /* CIL Label */ ;
#line 540
    if (! (i < nsyms)) {
#line 540
      goto while_break;
    }
#line 541
    *(nullable + i) = (char)0;
#line 540
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 543
  done___0 = 0;
  {
#line 544
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 544
    if (! (! done___0)) {
#line 544
      goto while_break___0;
    }
#line 546
    done___0 = 1;
#line 547
    i = 1;
    {
#line 547
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 547
      if (! (i < nitems)) {
#line 547
        goto while_break___1;
      }
#line 549
      empty = 1;
      {
#line 550
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 550
        j = *(ritem + i);
#line 550
        if (! (j >= 0)) {
#line 550
          goto while_break___2;
        }
#line 552
        if (! *(nullable + j)) {
#line 553
          empty = 0;
        }
#line 554
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 556
      if (empty) {
#line 558
        j = *(rlhs + - j);
#line 559
        if (! *(nullable + j)) {
#line 561
          *(nullable + j) = (char)1;
#line 562
          done___0 = 0;
        }
      }
#line 547
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 577
  return;
}
}
#line 580 "/home/june/collector/temp/btyacc-3.0/lr0.c"
void free_nullable(void) 
{ 


  {
  {
#line 582
  free((void *)nullable);
  }
#line 583
  return;
}
}
#line 586 "/home/june/collector/temp/btyacc-3.0/lr0.c"
void lr0(void) 
{ 


  {
  {
#line 588
  set_derives();
#line 589
  set_nullable();
#line 590
  generate_states();
  }
#line 591
  return;
}
}
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 755
extern void *( __attribute__((__nonnull__(1,2,5))) bsearch)(void const   *__key ,
                                                            void const   *__base ,
                                                            size_t __nmemb , size_t __size ,
                                                            int (*__compar)(void const   * ,
                                                                            void const   * ) ) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 124
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 435
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 214 "/home/june/collector/temp/btyacc-3.0/defs.h"
char *cptr  ;
#line 215 "/home/june/collector/temp/btyacc-3.0/defs.h"
char *line  ;
#line 234
FILE *inc_file ;
#line 235 "/home/june/collector/temp/btyacc-3.0/defs.h"
char inc_file_name[100]  ;
#line 251 "/home/june/collector/temp/btyacc-3.0/defs.h"
int ntags  ;
#line 253 "/home/june/collector/temp/btyacc-3.0/defs.h"
char unionized  ;
#line 254
char line_format[15] ;
#line 271
bucket *first_symbol ;
#line 272
bucket *last_symbol ;
#line 317
void unexpected_EOF(void) ;
#line 320
void syntax_error(int lineno___0 , char *line___0 , char *cptr___0 ) ;
#line 321
void unterminated_comment(int lineno___0 , char *line___0 , char *cptr___0 ) ;
#line 322
void unterminated_string(int lineno___0 , char *line___0 , char *cptr___0 ) ;
#line 323
void unterminated_text(int lineno___0 , char *line___0 , char *cptr___0 ) ;
#line 324
void unterminated_union(int lineno___0 , char *line___0 , char *cptr___0 ) ;
#line 325
void over_unionized(char *cptr___0 ) ;
#line 326
void illegal_tag(int lineno___0 , char *line___0 , char *cptr___0 ) ;
#line 327
void illegal_character(char *cptr___0 ) ;
#line 328
void used_reserved(char *s ) ;
#line 329
void tokenized_start(char *s ) ;
#line 330
void retyped_warning(char *s ) ;
#line 331
void reprec_warning(char *s ) ;
#line 332
void revalued_warning(char *s ) ;
#line 333
void terminal_start(char *s ) ;
#line 334
void restarted_warning(void) ;
#line 335
void no_grammar(void) ;
#line 336
void terminal_lhs(int lineno___0 ) ;
#line 337
void prec_redeclared(void) ;
#line 338
void unterminated_action(int lineno___0 , char *line___0 , char *cptr___0 ) ;
#line 339
void unterminated_arglist(int lineno___0 , char *line___0 , char *cptr___0 ) ;
#line 340
void bad_formals(void) ;
#line 341
void dollar_warning(int a_lineno , int i ) ;
#line 342
void dollar_error(int lineno___0 , char *line___0 , char *cptr___0 ) ;
#line 343
void untyped_lhs(void) ;
#line 344
void untyped_rhs(int i , char *s ) ;
#line 345
void unknown_rhs(int i ) ;
#line 346
void default_action_warning(void) ;
#line 347
void undefined_goal(char *s ) ;
#line 348
void undefined_symbol_warning(char *s ) ;
#line 446
void write_section(char *section_name ) ;
#line 450
int cachec(int c ) ;
#line 451
char *get_line(void) ;
#line 452
char *dup_line(void) ;
#line 453
char *skip_comment(void) ;
#line 454
int nextc(void) ;
#line 455
int keyword(void) ;
#line 456
void copy_ident(void) ;
#line 457
void copy_string(int quote , FILE *f1 , FILE *f2 ) ;
#line 458
void copy_comment(FILE *f1 , FILE *f2 ) ;
#line 459
void copy_text(void) ;
#line 460
void copy_union(void) ;
#line 461
int hexval(int c ) ;
#line 462
bucket *get_literal(void) ;
#line 463
int is_reserved(char *name ) ;
#line 464
bucket *get_name(void) ;
#line 465
int get_number(void) ;
#line 466
char *get_tag(void) ;
#line 467
void declare_tokens(int assoc ) ;
#line 468
void declare_types(void) ;
#line 469
void declare_start(void) ;
#line 470
void read_declarations(void) ;
#line 471
void initialize_grammar(void) ;
#line 472
void expand_items(void) ;
#line 473
void expand_rules(void) ;
#line 474
void advance_to_start(void) ;
#line 475
void start_rule(bucket *bp , int s_lineno ) ;
#line 476
void end_rule(void) ;
#line 477
void insert_empty_rule(void) ;
#line 478
void add_symbol(void) ;
#line 479
void copy_action(void) ;
#line 480
int mark_symbol(void) ;
#line 481
void read_grammar(void) ;
#line 482
void free_tags(void) ;
#line 483
void pack_names(void) ;
#line 484
void check_symbols(void) ;
#line 485
void pack_symbols(void) ;
#line 486
void pack_grammar(void) ;
#line 487
void print_grammar(void) ;
#line 495
bucket *make_bucket(char *name ) ;
#line 496
bucket *lookup(char *name ) ;
#line 497
void create_symbol_table(void) ;
#line 498
void free_symbol_table(void) ;
#line 499
void free_symbols(void) ;
#line 8 "/home/june/collector/temp/btyacc-3.0/mstring.h"
void msprintf(struct mstring *s , char const   *fmt  , ...) ;
#line 9
int mputchar(struct mstring *s , int ch ) ;
#line 10
struct mstring *msnew(void) ;
#line 11
char *msdone(struct mstring *s ) ;
#line 15
int strnscmp(char const   *a , char const   *b ) ;
#line 17
unsigned int strnshash(char const   *s ) ;
#line 15 "/home/june/collector/temp/btyacc-3.0/reader.c"
char *cache  ;
#line 16 "/home/june/collector/temp/btyacc-3.0/reader.c"
int cinc  ;
#line 16 "/home/june/collector/temp/btyacc-3.0/reader.c"
int cache_size  ;
#line 18 "/home/june/collector/temp/btyacc-3.0/reader.c"
int tagmax  ;
#line 18 "/home/june/collector/temp/btyacc-3.0/reader.c"
int havetags  =    0;
#line 19 "/home/june/collector/temp/btyacc-3.0/reader.c"
char **tag_table  ;
#line 21 "/home/june/collector/temp/btyacc-3.0/reader.c"
char saw_eof  ;
#line 23 "/home/june/collector/temp/btyacc-3.0/reader.c"
int linesize  ;
#line 25 "/home/june/collector/temp/btyacc-3.0/reader.c"
FILE *inc_file  =    (FILE *)((void *)0);
#line 27 "/home/june/collector/temp/btyacc-3.0/reader.c"
int inc_save_lineno  ;
#line 29 "/home/june/collector/temp/btyacc-3.0/reader.c"
int in_ifdef  =    0;
#line 30 "/home/june/collector/temp/btyacc-3.0/reader.c"
int ifdef_skip  ;
#line 33 "/home/june/collector/temp/btyacc-3.0/reader.c"
char *defd_vars[1000]  = {      (char *)((void *)0)};
#line 35 "/home/june/collector/temp/btyacc-3.0/reader.c"
bucket *goal  ;
#line 36 "/home/june/collector/temp/btyacc-3.0/reader.c"
int prec  ;
#line 37 "/home/june/collector/temp/btyacc-3.0/reader.c"
int gensym  ;
#line 38 "/home/june/collector/temp/btyacc-3.0/reader.c"
char last_was_action  ;
#line 40 "/home/june/collector/temp/btyacc-3.0/reader.c"
int maxitems  ;
#line 41 "/home/june/collector/temp/btyacc-3.0/reader.c"
bucket **pitem  ;
#line 43 "/home/june/collector/temp/btyacc-3.0/reader.c"
int maxrules  ;
#line 44 "/home/june/collector/temp/btyacc-3.0/reader.c"
bucket **plhs  ;
#line 46 "/home/june/collector/temp/btyacc-3.0/reader.c"
int name_pool_size  ;
#line 47 "/home/june/collector/temp/btyacc-3.0/reader.c"
char *name_pool  ;
#line 49 "/home/june/collector/temp/btyacc-3.0/reader.c"
char line_format[15]  = 
#line 49
  {      (char )'#',      (char )'l',      (char )'i',      (char )'n', 
        (char )'e',      (char )' ',      (char )'%',      (char )'d', 
        (char )' ',      (char )'\"',      (char )'%',      (char )'s', 
        (char )'\"',      (char )'\n',      (char )'\000'};
#line 51 "/home/june/collector/temp/btyacc-3.0/reader.c"
int cachec(int c ) 
{ 
  void *tmp ;
  int tmp___0 ;
  char tmp___1 ;

  {
#line 53
  if (! (cinc >= 0)) {
    {
#line 53
    __assert_fail("cinc >= 0", "/home/june/collector/temp/btyacc-3.0/reader.c", 53U,
                  "cachec");
    }
  }
#line 54
  if (cinc >= cache_size) {
    {
#line 55
    cache_size += 256;
#line 55
    tmp = realloc((void *)cache, (size_t )((unsigned int )cache_size));
#line 55
    cache = (char *)tmp;
    }
#line 55
    if (! cache) {
      {
#line 55
      no_space();
      }
    }
  }
#line 56
  tmp___0 = cinc;
#line 56
  cinc ++;
#line 56
  tmp___1 = (char )c;
#line 56
  *(cache + tmp___0) = tmp___1;
#line 56
  return ((int )tmp___1);
}
}
#line 64 "/home/june/collector/temp/btyacc-3.0/reader.c"
char *get_line(void) 
{ 
  FILE *f ;
  int c ;
  int i ;
  void *tmp ;
  void *tmp___0 ;
  char tmp___1 ;
  char var_name[80] ;
  int ii ;
  char **ps ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int ii___0 ;
  int tmp___5 ;
  char var_name___0[80] ;
  int ii___1 ;
  char **ps___0 ;
  int tmp___6 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;

  {
  NextLine: ;
#line 72
  if (inc_file) {
#line 72
    f = inc_file;
  } else {
#line 72
    f = input_file;
  }
#line 73
  i = 0;
#line 75
  if (saw_eof) {
#line 75
    goto _L;
  } else {
    {
#line 75
    c = _IO_getc(f);
    }
#line 75
    if (c == -1) {
      _L: /* CIL Label */ 
#line 78
      if (inc_file) {
        {
#line 79
        fclose(inc_file);
#line 80
        inc_file = (FILE *)((void *)0);
#line 81
        lineno = inc_save_lineno;
        }
#line 82
        goto NextLine;
      }
#line 85
      if (line) {
        {
#line 85
        free((void *)line);
        }
      }
#line 86
      saw_eof = (char)1;
#line 87
      cptr = (char *)0;
#line 87
      line = cptr;
#line 87
      return (line);
    }
  }
#line 89
  if ((unsigned long )line == (unsigned long )((char *)0)) {
#line 89
    goto _L___0;
  } else
#line 89
  if (linesize != 101) {
    _L___0: /* CIL Label */ 
#line 90
    if (line) {
      {
#line 90
      free((void *)line);
      }
    }
    {
#line 91
    linesize = 101;
#line 92
    tmp = malloc((size_t )((unsigned int )linesize));
#line 92
    line = (char *)tmp;
    }
#line 92
    if (! line) {
      {
#line 92
      no_space();
      }
    }
  }
#line 94
  lineno ++;
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    tmp___1 = (char )c;
#line 95
    *(line + i) = tmp___1;
#line 95
    if (! ((int )tmp___1 != 10)) {
#line 95
      goto while_break;
    }
#line 96
    i ++;
#line 96
    if (i + 1 >= linesize) {
      {
#line 97
      linesize += 100;
#line 97
      tmp___0 = realloc((void *)line, (size_t )((unsigned int )linesize));
#line 97
      line = (char *)tmp___0;
      }
#line 97
      if (! line) {
        {
#line 98
        no_space();
        }
      }
    }
    {
#line 99
    c = _IO_getc(f);
    }
#line 99
    if (c == -1) {
#line 100
      c = '\n';
#line 101
      saw_eof = (char)1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 104
  *(line + (i + 1)) = (char)0;
#line 107
  tmp___3 = strncmp((char const   *)(line + 0), "%ifdef ", (size_t )7);
  }
#line 107
  if (tmp___3 == 0) {
#line 109
    ii = 0;
#line 111
    i = 7;
    {
#line 111
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 111
      if ((int )*(line + i) != 10) {
#line 111
        if (! ((int )*(line + i) != 32)) {
#line 111
          goto while_break___0;
        }
      } else {
#line 111
        goto while_break___0;
      }
#line 112
      var_name[ii] = *(line + i);
#line 111
      i ++;
#line 111
      ii ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 114
    var_name[ii] = (char)0;
#line 115
    if (in_ifdef) {
      {
#line 116
      error(lineno, (char *)0, (char *)0, (char *)"Cannot have nested %%ifdef");
      }
    }
#line 119
    ps = & defd_vars[0];
    {
#line 119
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 119
      if (! *ps) {
#line 119
        goto while_break___1;
      }
      {
#line 120
      tmp___2 = strcmp((char const   *)*ps, (char const   *)(var_name));
      }
#line 120
      if (tmp___2 == 0) {
#line 121
        goto while_break___1;
      }
#line 119
      ps ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 124
    in_ifdef = 1;
#line 125
    if (*ps) {
#line 126
      ifdef_skip = 0;
    } else {
#line 128
      ifdef_skip = 1;
    }
#line 130
    goto NextLine;
  }
  {
#line 134
  tmp___4 = strncmp((char const   *)(line + 0), "%endif", (size_t )6);
  }
#line 134
  if (tmp___4 == 0) {
#line 135
    if (! in_ifdef) {
      {
#line 136
      error(lineno, (char *)0, (char *)0, (char *)"There is no corresponding %%ifdef for %%endif");
      }
    }
#line 138
    in_ifdef = 0;
#line 139
    goto NextLine;
  }
#line 143
  if (in_ifdef) {
#line 143
    if (ifdef_skip) {
#line 144
      goto NextLine;
    }
  }
  {
#line 148
  tmp___5 = strncmp((char const   *)(line + 0), "%include ", (size_t )9);
  }
#line 148
  if (tmp___5 == 0) {
#line 149
    ii___0 = 0;
#line 150
    i = 9;
    {
#line 150
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 150
      if ((int )*(line + i) != 10) {
#line 150
        if (! ((int )*(line + i) != 32)) {
#line 150
          goto while_break___2;
        }
      } else {
#line 150
        goto while_break___2;
      }
#line 151
      inc_file_name[ii___0] = *(line + i);
#line 150
      i ++;
#line 150
      ii___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 153
    inc_file_name[ii___0] = (char)0;
#line 154
    if (inc_file) {
      {
#line 155
      error(lineno, (char *)0, (char *)0, (char *)"Nested include lines are not allowed");
      }
    }
    {
#line 157
    inc_file = fopen((char const   */* __restrict  */)(inc_file_name), (char const   */* __restrict  */)"r");
    }
#line 158
    if ((unsigned long )inc_file == (unsigned long )((void *)0)) {
      {
#line 159
      error(lineno, (char *)0, (char *)0, (char *)"Cannot open include file %s", inc_file_name);
      }
    }
#line 161
    inc_save_lineno = lineno;
#line 162
    lineno = 0;
#line 163
    goto NextLine;
  }
  {
#line 167
  tmp___9 = strncmp((char const   *)(line + 0), "%define ", (size_t )8);
  }
#line 167
  if (tmp___9 == 0) {
#line 169
    ii___1 = 0;
#line 171
    i = 8;
    {
#line 171
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 171
      if ((int )*(line + i) != 10) {
#line 171
        if (! ((int )*(line + i) != 32)) {
#line 171
          goto while_break___3;
        }
      } else {
#line 171
        goto while_break___3;
      }
#line 172
      var_name___0[ii___1] = *(line + i);
#line 171
      i ++;
#line 171
      ii___1 ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 174
    var_name___0[ii___1] = (char)0;
#line 176
    ps___0 = & defd_vars[0];
    {
#line 176
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 176
      if (! *ps___0) {
#line 176
        goto while_break___4;
      }
      {
#line 177
      tmp___6 = strcmp((char const   *)*ps___0, (char const   *)(var_name___0));
      }
#line 177
      if (tmp___6 == 0) {
        {
#line 178
        error(lineno, (char *)0, (char *)0, (char *)"Preprocessor variable %s already defined",
              var_name___0);
        }
      }
#line 176
      ps___0 ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 181
    tmp___7 = strlen((char const   *)(var_name___0));
#line 181
    tmp___8 = malloc((size_t )((unsigned int )(tmp___7 + 1UL)));
#line 181
    *ps___0 = (char *)tmp___8;
#line 182
    strcpy((char */* __restrict  */)*ps___0, (char const   */* __restrict  */)(var_name___0));
#line 183
    ps___0 ++;
#line 183
    *ps___0 = (char *)((void *)0);
    }
#line 184
    goto NextLine;
  }
#line 187
  if (Eflag) {
    {
#line 188
    printf((char const   */* __restrict  */)"YPP: %s", line);
    }
  }
#line 191
  cptr = line;
#line 191
  return (cptr);
}
}
#line 194 "/home/june/collector/temp/btyacc-3.0/reader.c"
char *dup_line(void) 
{ 
  register char *p ;
  register char *s ;
  register char *t ;
  void *tmp ;
  char *tmp___0 ;
  char tmp___1 ;
  char *tmp___2 ;

  {
#line 198
  if ((unsigned long )line == (unsigned long )((char *)0)) {
#line 198
    return ((char *)0);
  }
#line 199
  s = line;
  {
#line 200
  while (1) {
    while_continue: /* CIL Label */ ;
#line 200
    if (! ((int )*s != 10)) {
#line 200
      goto while_break;
    }
#line 200
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 201
  tmp = malloc((size_t )((unsigned int )((s - line) + 1L)));
#line 201
  p = (char *)tmp;
  }
#line 201
  if (! p) {
    {
#line 201
    no_space();
    }
  }
#line 202
  s = line;
#line 203
  t = p;
  {
#line 204
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 204
    tmp___0 = t;
#line 204
    t ++;
#line 204
    tmp___2 = s;
#line 204
    s ++;
#line 204
    tmp___1 = *tmp___2;
#line 204
    *tmp___0 = tmp___1;
#line 204
    if (! ((int )tmp___1 != 10)) {
#line 204
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 205
  return (p);
}
}
#line 208 "/home/june/collector/temp/btyacc-3.0/reader.c"
char *skip_comment(void) 
{ 
  register char *s ;
  int st_lineno ;
  char *st_line ;
  char *tmp ;
  char *st_cptr ;

  {
  {
#line 212
  st_lineno = lineno;
#line 213
  tmp = dup_line();
#line 213
  st_line = tmp;
#line 214
  st_cptr = st_line + (cptr - line);
#line 216
  s = cptr + 2;
  }
  {
#line 217
  while (1) {
    while_continue: /* CIL Label */ ;
#line 217
    if (! ((int )*(s + 0) != 42)) {
#line 217
      if (! ((int )*(s + 1) != 47)) {
#line 217
        goto while_break;
      }
    }
#line 218
    if ((int )*s == 10) {
      {
#line 219
      s = get_line();
      }
#line 219
      if ((unsigned long )s == (unsigned long )((char *)0)) {
        {
#line 220
        unterminated_comment(st_lineno, st_line, st_cptr);
        }
      }
    } else {
#line 222
      s ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 223
  free((void *)st_line);
#line 224
  cptr = s + 2;
  }
#line 224
  return (cptr);
}
}
#line 227 "/home/june/collector/temp/btyacc-3.0/reader.c"
int nextc(void) 
{ 
  register char *s ;
  char *tmp ;

  {
#line 231
  if ((unsigned long )line == (unsigned long )((char *)0)) {
    {
#line 231
    tmp = get_line();
    }
#line 231
    if ((unsigned long )tmp == (unsigned long )((char *)0)) {
#line 232
      return (-1);
    }
  }
#line 233
  s = cptr;
  {
#line 234
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 236
    if ((int )*s == 10) {
#line 236
      goto case_10;
    }
#line 245
    if ((int )*s == 59) {
#line 245
      goto case_59;
    }
#line 245
    if ((int )*s == 44) {
#line 245
      goto case_59;
    }
#line 245
    if ((int )*s == 11) {
#line 245
      goto case_59;
    }
#line 245
    if ((int )*s == 13) {
#line 245
      goto case_59;
    }
#line 245
    if ((int )*s == 12) {
#line 245
      goto case_59;
    }
#line 245
    if ((int )*s == 9) {
#line 245
      goto case_59;
    }
#line 245
    if ((int )*s == 32) {
#line 245
      goto case_59;
    }
#line 248
    if ((int )*s == 92) {
#line 248
      goto case_92;
    }
#line 251
    if ((int )*s == 47) {
#line 251
      goto case_47;
    }
#line 260
    goto switch_default;
    case_10: /* CIL Label */ 
    {
#line 237
    s = get_line();
    }
#line 237
    if ((unsigned long )s == (unsigned long )((char *)0)) {
#line 237
      return (-1);
    }
#line 238
    goto switch_break;
    case_59: /* CIL Label */ 
    case_44: /* CIL Label */ 
    case_11: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_12: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 246
    s ++;
#line 247
    goto switch_break;
    case_92: /* CIL Label */ 
#line 249
    cptr = s;
#line 250
    return ('%');
    case_47: /* CIL Label */ 
#line 252
    if ((int )*(s + 1) == 42) {
      {
#line 253
      cptr = s;
#line 254
      s = skip_comment();
      }
#line 255
      goto switch_break;
    } else
#line 256
    if ((int )*(s + 1) == 47) {
      {
#line 257
      s = get_line();
      }
#line 257
      if ((unsigned long )s == (unsigned long )((char *)0)) {
#line 257
        return (-1);
      }
#line 258
      goto switch_break;
    }
    switch_default: /* CIL Label */ 
#line 261
    cptr = s;
#line 262
    return ((int )*s);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 265 "/home/june/collector/temp/btyacc-3.0/reader.c"
static struct keyword keywords[10]  = 
#line 265
  {      {{(char )'b', (char )'i', (char )'n', (char )'a', (char )'r', (char )'y', (char )'\000'},
      3}, 
        {{(char )'i', (char )'d', (char )'e', (char )'n', (char )'t', (char )'\000'},
      9}, 
        {{(char )'l', (char )'e', (char )'f', (char )'t', (char )'\000'}, 1}, 
        {{(char )'n', (char )'o', (char )'n', (char )'a', (char )'s', (char )'s', (char )'o',
       (char )'c', (char )'\000'}, 3}, 
        {{(char )'r', (char )'i', (char )'g', (char )'h', (char )'t', (char )'\000'},
      2}, 
        {{(char )'s', (char )'t', (char )'a', (char )'r', (char )'t', (char )'\000'},
      7}, 
        {{(char )'t', (char )'e', (char )'r', (char )'m', (char )'\000'}, 0}, 
        {{(char )'t', (char )'o', (char )'k', (char )'e', (char )'n', (char )'\000'},
      0}, 
        {{(char )'t', (char )'y', (char )'p', (char )'e', (char )'\000'}, 6}, 
        {{(char )'u', (char )'n', (char )'i', (char )'o', (char )'n', (char )'\000'},
      8}};
#line 278 "/home/june/collector/temp/btyacc-3.0/reader.c"
int keyword(void) 
{ 
  register int c ;
  char *t_cptr ;
  struct keyword *key ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  void *tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
  {
#line 281
  t_cptr = cptr;
#line 284
  cptr ++;
#line 284
  c = (int )*cptr;
#line 285
  tmp___2 = __ctype_b_loc();
  }
#line 285
  if ((int const   )*(*tmp___2 + c) & 1024) {
#line 286
    cinc = 0;
    {
#line 287
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 287
      tmp___0 = __ctype_b_loc();
      }
#line 287
      if (! ((int const   )*(*tmp___0 + c) & 8)) {
#line 287
        if (! (c == 95)) {
#line 287
          if (! (c == 46)) {
#line 287
            if (! (c == 36)) {
#line 287
              goto while_break;
            }
          }
        }
      }
      {
#line 288
      tmp = tolower(c);
#line 288
      cachec(tmp);
#line 289
      cptr ++;
#line 289
      c = (int )*cptr;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 291
    cachec('\000');
#line 293
    tmp___1 = bsearch((void const   *)cache, (void const   *)(keywords), sizeof(keywords) / sizeof(*key),
                      sizeof(*key), (int (*)(void const   * , void const   * ))(& strcmp));
#line 293
    key = (struct keyword *)tmp___1;
    }
#line 293
    if (key) {
#line 295
      return (key->token);
    }
  } else {
#line 297
    cptr ++;
#line 298
    if (c == 123) {
#line 298
      return (5);
    }
#line 299
    if (c == 37) {
#line 299
      return (4);
    } else
#line 299
    if (c == 92) {
#line 299
      return (4);
    }
#line 300
    if (c == 60) {
#line 300
      return (1);
    }
#line 301
    if (c == 62) {
#line 301
      return (2);
    }
#line 302
    if (c == 48) {
#line 302
      return (0);
    }
#line 303
    if (c == 50) {
#line 303
      return (3);
    }
  }
  {
#line 305
  syntax_error(lineno, line, t_cptr);
  }
#line 307
  return (0);
}
}
#line 310 "/home/june/collector/temp/btyacc-3.0/reader.c"
void copy_ident(void) 
{ 
  register int c ;
  register FILE *f ;

  {
  {
#line 313
  f = output_file;
#line 315
  c = nextc();
  }
#line 315
  if (c == -1) {
    {
#line 315
    unexpected_EOF();
    }
  }
#line 316
  if (c != 34) {
    {
#line 316
    syntax_error(lineno, line, cptr);
    }
  }
  {
#line 317
  outline ++;
#line 318
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"#ident \"");
  }
  {
#line 319
  while (1) {
    while_continue: /* CIL Label */ ;
#line 320
    cptr ++;
#line 320
    c = (int )*cptr;
#line 321
    if (c == 10) {
      {
#line 322
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\"\n");
      }
#line 323
      return;
    }
    {
#line 324
    _IO_putc(c, f);
    }
#line 325
    if (c == 34) {
      {
#line 326
      _IO_putc('\n', f);
#line 327
      cptr ++;
      }
#line 328
      return;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 337 "/home/june/collector/temp/btyacc-3.0/reader.c"
void copy_string(int quote , FILE *f1 , FILE *f2 ) 
{ 
  register int c ;
  int s_lineno ;
  char *s_line ;
  char *tmp ;
  char *s_cptr ;
  int _c ;
  char *tmp___0 ;
  int _c___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 340
  s_lineno = lineno;
#line 341
  tmp = dup_line();
#line 341
  s_line = tmp;
#line 342
  s_cptr = s_line + ((cptr - line) - 1L);
  }
  {
#line 344
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 345
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 345
      tmp___0 = cptr;
#line 345
      cptr ++;
#line 345
      c = (int )*tmp___0;
#line 345
      _c = c;
#line 345
      _IO_putc(_c, f1);
      }
#line 345
      if (f2) {
        {
#line 345
        _IO_putc(_c, f2);
        }
      }
#line 345
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 346
    if (c == quote) {
      {
#line 347
      free((void *)s_line);
      }
#line 348
      return;
    }
#line 349
    if (c == 10) {
      {
#line 350
      unterminated_string(s_lineno, s_line, s_cptr);
      }
    }
#line 351
    if (c == 92) {
      {
#line 352
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 352
        tmp___1 = cptr;
#line 352
        cptr ++;
#line 352
        c = (int )*tmp___1;
#line 352
        _c___0 = c;
#line 352
        _IO_putc(_c___0, f1);
        }
#line 352
        if (f2) {
          {
#line 352
          _IO_putc(_c___0, f2);
          }
        }
#line 352
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 353
      if (c == 10) {
        {
#line 354
        tmp___2 = get_line();
        }
#line 354
        if ((unsigned long )tmp___2 == (unsigned long )((char *)0)) {
          {
#line 355
          unterminated_string(s_lineno, s_line, s_cptr);
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 358 "/home/june/collector/temp/btyacc-3.0/reader.c"
void copy_comment(FILE *f1 , FILE *f2 ) 
{ 
  register int c ;
  int _c ;
  int _c___0 ;
  int _c___1 ;
  int _c___2 ;
  int _c___3 ;
  int c_lineno ;
  char *c_line ;
  char *tmp ;
  char *c_cptr ;
  int _c___4 ;
  int _c___5 ;
  char *tmp___0 ;
  int _c___6 ;
  int _c___7 ;

  {
#line 362
  c = (int )*cptr;
#line 362
  if (c == 47) {
    {
#line 363
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 363
      _c = '*';
#line 363
      _IO_putc(_c, f1);
      }
#line 363
      if (f2) {
        {
#line 363
        _IO_putc(_c, f2);
        }
      }
#line 363
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 364
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 364
      cptr ++;
#line 364
      c = (int )*cptr;
#line 364
      if (! (c != 10)) {
#line 364
        goto while_break___0;
      }
      {
#line 365
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 365
        _c___0 = c;
#line 365
        _IO_putc(_c___0, f1);
        }
#line 365
        if (f2) {
          {
#line 365
          _IO_putc(_c___0, f2);
          }
        }
#line 365
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 366
      if (c == 42) {
#line 366
        if ((int )*(cptr + 1) == 47) {
          {
#line 367
          while (1) {
            while_continue___2: /* CIL Label */ ;
            {
#line 367
            _c___1 = ' ';
#line 367
            _IO_putc(_c___1, f1);
            }
#line 367
            if (f2) {
              {
#line 367
              _IO_putc(_c___1, f2);
              }
            }
#line 367
            goto while_break___2;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 368
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 368
      _c___2 = '*';
#line 368
      _IO_putc(_c___2, f1);
      }
#line 368
      if (f2) {
        {
#line 368
        _IO_putc(_c___2, f2);
        }
      }
#line 368
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 368
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 368
      _c___3 = '/';
#line 368
      _IO_putc(_c___3, f1);
      }
#line 368
      if (f2) {
        {
#line 368
        _IO_putc(_c___3, f2);
        }
      }
#line 368
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
  } else
#line 369
  if (c == 42) {
    {
#line 370
    c_lineno = lineno;
#line 371
    tmp = dup_line();
#line 371
    c_line = tmp;
#line 372
    c_cptr = c_line + ((cptr - line) - 1L);
    }
    {
#line 373
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 373
      _c___4 = c;
#line 373
      _IO_putc(_c___4, f1);
      }
#line 373
      if (f2) {
        {
#line 373
        _IO_putc(_c___4, f2);
        }
      }
#line 373
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 374
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 374
      cptr ++;
#line 374
      c = (int )*cptr;
#line 374
      if (! (c != 42)) {
#line 374
        if (! ((int )*(cptr + 1) != 47)) {
#line 374
          goto while_break___6;
        }
      }
      {
#line 375
      while (1) {
        while_continue___7: /* CIL Label */ ;
        {
#line 375
        _c___5 = c;
#line 375
        _IO_putc(_c___5, f1);
        }
#line 375
        if (f2) {
          {
#line 375
          _IO_putc(_c___5, f2);
          }
        }
#line 375
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 376
      if (c == 10) {
        {
#line 377
        tmp___0 = get_line();
        }
#line 377
        if ((unsigned long )tmp___0 == (unsigned long )((char *)0)) {
          {
#line 378
          unterminated_comment(c_lineno, c_line, c_cptr);
          }
        }
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 379
    while (1) {
      while_continue___8: /* CIL Label */ ;
      {
#line 379
      _c___6 = c;
#line 379
      _IO_putc(_c___6, f1);
      }
#line 379
      if (f2) {
        {
#line 379
        _IO_putc(_c___6, f2);
        }
      }
#line 379
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 380
    while (1) {
      while_continue___9: /* CIL Label */ ;
      {
#line 380
      _c___7 = '/';
#line 380
      _IO_putc(_c___7, f1);
      }
#line 380
      if (f2) {
        {
#line 380
        _IO_putc(_c___7, f2);
        }
      }
#line 380
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
    {
#line 381
    free((void *)c_line);
#line 382
    cptr += 2;
    }
  }
#line 383
  return;
}
}
#line 387 "/home/june/collector/temp/btyacc-3.0/reader.c"
void copy_text(void) 
{ 
  register int c ;
  register FILE *f ;
  int need_newline ;
  int t_lineno ;
  char *t_line ;
  char *tmp ;
  char *t_cptr ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 390
  f = text_file;
#line 391
  need_newline = 0;
#line 392
  t_lineno = lineno;
#line 393
  tmp = dup_line();
#line 393
  t_line = tmp;
#line 394
  t_cptr = t_line + ((cptr - line) - 2L);
  }
#line 396
  if ((int )*cptr == 10) {
    {
#line 397
    tmp___0 = get_line();
    }
#line 397
    if ((unsigned long )tmp___0 == (unsigned long )((char *)0)) {
      {
#line 398
      unterminated_text(t_lineno, t_line, t_cptr);
      }
    }
  }
#line 399
  if (! lflag) {
#line 399
    if (inc_file) {
#line 399
      tmp___1 = inc_file_name;
    } else {
#line 399
      tmp___1 = input_file_name;
    }
    {
#line 399
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)(line_format),
            lineno, tmp___1);
    }
  }
  loop: 
#line 401
  tmp___2 = cptr;
#line 401
  cptr ++;
#line 401
  c = (int )*tmp___2;
  {
#line 402
  if (c == 10) {
#line 402
    goto case_10;
  }
#line 408
  if (c == 34) {
#line 408
    goto case_34;
  }
#line 408
  if (c == 39) {
#line 408
    goto case_34;
  }
#line 413
  if (c == 47) {
#line 413
    goto case_47;
  }
#line 419
  if (c == 92) {
#line 419
    goto case_92;
  }
#line 419
  if (c == 37) {
#line 419
    goto case_92;
  }
#line 426
  goto switch_default;
  case_10: /* CIL Label */ 
  {
#line 403
  _IO_putc('\n', f);
#line 404
  need_newline = 0;
#line 405
  tmp___3 = get_line();
  }
#line 405
  if (tmp___3) {
#line 405
    goto loop;
  }
  {
#line 406
  unterminated_text(t_lineno, t_line, t_cptr);
  }
  case_34: /* CIL Label */ 
  case_39: /* CIL Label */ 
  {
#line 409
  _IO_putc(c, f);
#line 410
  copy_string(c, f, (FILE *)0);
#line 411
  need_newline = 1;
  }
#line 412
  goto loop;
  case_47: /* CIL Label */ 
  {
#line 414
  _IO_putc(c, f);
#line 415
  copy_comment(f, (FILE *)0);
#line 416
  need_newline = 1;
  }
#line 417
  goto loop;
  case_92: /* CIL Label */ 
  case_37: /* CIL Label */ 
#line 420
  if ((int )*cptr == 125) {
#line 421
    if (need_newline) {
      {
#line 421
      _IO_putc('\n', f);
      }
    }
    {
#line 422
    cptr ++;
#line 423
    free((void *)t_line);
    }
#line 424
    return;
  }
  switch_default: /* CIL Label */ 
  {
#line 427
  _IO_putc(c, f);
#line 428
  need_newline = 1;
  }
#line 429
  goto loop;
  switch_break: /* CIL Label */ ;
  }
}
}
#line 432 "/home/june/collector/temp/btyacc-3.0/reader.c"
void copy_union(void) 
{ 
  FILE *dc_file ;
  register int c ;
  int depth ;
  int u_lineno ;
  char *u_line ;
  char *tmp ;
  char *u_cptr ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 437
  u_lineno = lineno;
#line 438
  tmp = dup_line();
#line 438
  u_line = tmp;
#line 439
  u_cptr = u_line + ((cptr - line) - 6L);
  }
#line 441
  if (unionized) {
    {
#line 441
    over_unionized(cptr - 6);
    }
  }
#line 442
  unionized = (char)1;
#line 444
  if (! lflag) {
#line 445
    if (inc_file) {
#line 445
      tmp___0 = inc_file_name;
    } else {
#line 445
      tmp___0 = input_file_name;
    }
    {
#line 445
    fprintf((FILE */* __restrict  */)text_file, (char const   */* __restrict  */)(line_format),
            lineno, tmp___0);
    }
  }
#line 448
  if (dflag) {
#line 448
    dc_file = union_file;
  } else {
#line 448
    dc_file = text_file;
  }
  {
#line 450
  fprintf((FILE */* __restrict  */)dc_file, (char const   */* __restrict  */)"\ntypedef union");
#line 452
  depth = 0;
  }
  loop: 
  {
#line 454
  tmp___1 = cptr;
#line 454
  cptr ++;
#line 454
  c = (int )*tmp___1;
#line 455
  _IO_putc(c, dc_file);
  }
  {
#line 457
  if (c == 10) {
#line 457
    goto case_10;
  }
#line 461
  if (c == 123) {
#line 461
    goto case_123;
  }
#line 464
  if (c == 125) {
#line 464
    goto case_125;
  }
#line 471
  if (c == 34) {
#line 471
    goto case_34;
  }
#line 471
  if (c == 39) {
#line 471
    goto case_34;
  }
#line 474
  if (c == 47) {
#line 474
    goto case_47;
  }
#line 477
  goto switch_default;
  case_10: /* CIL Label */ 
  {
#line 458
  get_line();
  }
#line 459
  if ((unsigned long )line == (unsigned long )((char *)0)) {
    {
#line 459
    unterminated_union(u_lineno, u_line, u_cptr);
    }
  }
#line 460
  goto loop;
  case_123: /* CIL Label */ 
#line 462
  depth ++;
#line 463
  goto loop;
  case_125: /* CIL Label */ 
#line 465
  depth --;
#line 465
  if (depth == 0) {
    {
#line 466
    fprintf((FILE */* __restrict  */)dc_file, (char const   */* __restrict  */)" YYSTYPE;\n");
#line 467
    free((void *)u_line);
    }
#line 468
    return;
  }
#line 469
  goto loop;
  case_34: /* CIL Label */ 
  case_39: /* CIL Label */ 
  {
#line 472
  copy_string(c, dc_file, (FILE *)0);
  }
#line 473
  goto loop;
  case_47: /* CIL Label */ 
  {
#line 475
  copy_comment(dc_file, (FILE *)0);
  }
#line 476
  goto loop;
  switch_default: /* CIL Label */ 
#line 478
  goto loop;
  switch_break: /* CIL Label */ ;
  }
}
}
#line 482 "/home/june/collector/temp/btyacc-3.0/reader.c"
int hexval(int c ) 
{ 


  {
#line 484
  if (c >= 48) {
#line 484
    if (c <= 57) {
#line 485
      return (c - 48);
    }
  }
#line 486
  if (c >= 65) {
#line 486
    if (c <= 70) {
#line 487
      return ((c - 65) + 10);
    }
  }
#line 488
  if (c >= 97) {
#line 488
    if (c <= 102) {
#line 489
      return ((c - 97) + 10);
    }
  }
#line 490
  return (-1);
}
}
#line 493 "/home/june/collector/temp/btyacc-3.0/reader.c"
bucket *get_literal(void) 
{ 
  register int c ;
  register int quote ;
  register int i ;
  register int n ;
  register char *s ;
  register bucket *bp ;
  int s_lineno ;
  char *s_line ;
  char *tmp ;
  char *s_cptr ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *c_cptr ;
  char *tmp___2 ;
  char *tmp___3 ;
  void *tmp___4 ;
  unsigned short const   **tmp___5 ;

  {
  {
#line 500
  s_lineno = lineno;
#line 501
  tmp = dup_line();
#line 501
  s_line = tmp;
#line 502
  s_cptr = s_line + (cptr - line);
#line 504
  tmp___0 = cptr;
#line 504
  cptr ++;
#line 504
  quote = (int )*tmp___0;
#line 505
  cinc = 0;
  }
  {
#line 506
  while (1) {
    while_continue: /* CIL Label */ ;
#line 507
    tmp___1 = cptr;
#line 507
    cptr ++;
#line 507
    c = (int )*tmp___1;
#line 508
    if (c == quote) {
#line 508
      goto while_break;
    }
#line 509
    if (c == 10) {
      {
#line 509
      unterminated_string(s_lineno, s_line, s_cptr);
      }
    }
#line 510
    if (c == 92) {
#line 511
      c_cptr = cptr - 1;
#line 512
      tmp___2 = cptr;
#line 512
      cptr ++;
#line 512
      c = (int )*tmp___2;
      {
#line 514
      if (c == 10) {
#line 514
        goto case_10;
      }
#line 519
      if (c == 55) {
#line 519
        goto case_55;
      }
#line 519
      if (c == 54) {
#line 519
        goto case_55;
      }
#line 519
      if (c == 53) {
#line 519
        goto case_55;
      }
#line 519
      if (c == 52) {
#line 519
        goto case_55;
      }
#line 519
      if (c == 51) {
#line 519
        goto case_55;
      }
#line 519
      if (c == 50) {
#line 519
        goto case_55;
      }
#line 519
      if (c == 49) {
#line 519
        goto case_55;
      }
#line 519
      if (c == 48) {
#line 519
        goto case_55;
      }
#line 531
      if (c == 120) {
#line 531
        goto case_120;
      }
#line 545
      if (c == 97) {
#line 545
        goto case_97;
      }
#line 546
      if (c == 98) {
#line 546
        goto case_98;
      }
#line 547
      if (c == 102) {
#line 547
        goto case_102;
      }
#line 548
      if (c == 110) {
#line 548
        goto case_110;
      }
#line 549
      if (c == 114) {
#line 549
        goto case_114;
      }
#line 550
      if (c == 116) {
#line 550
        goto case_116;
      }
#line 551
      if (c == 118) {
#line 551
        goto case_118;
      }
#line 513
      goto switch_break;
      case_10: /* CIL Label */ 
      {
#line 515
      get_line();
      }
#line 516
      if ((unsigned long )line == (unsigned long )((char *)0)) {
        {
#line 516
        unterminated_string(s_lineno, s_line, s_cptr);
        }
      }
#line 517
      goto __Cont;
      case_55: /* CIL Label */ 
      case_54: /* CIL Label */ 
      case_53: /* CIL Label */ 
      case_52: /* CIL Label */ 
      case_51: /* CIL Label */ 
      case_50: /* CIL Label */ 
      case_49: /* CIL Label */ 
      case_48: /* CIL Label */ 
#line 520
      n = c - 48;
#line 521
      c = (int )*cptr;
#line 522
      if (c >= 48) {
#line 522
        if (c <= 55) {
#line 523
          n = (n << 3) + (c - 48);
#line 524
          cptr ++;
#line 524
          c = (int )*cptr;
#line 525
          if (c >= 48) {
#line 525
            if (c <= 55) {
#line 526
              n = (n << 3) + (c - 48);
#line 527
              cptr ++;
            }
          }
        }
      }
#line 528
      if (n > 255) {
        {
#line 528
        illegal_character(c_cptr);
        }
      }
#line 529
      c = n;
#line 530
      goto switch_break;
      case_120: /* CIL Label */ 
      {
#line 532
      tmp___3 = cptr;
#line 532
      cptr ++;
#line 532
      c = (int )*tmp___3;
#line 533
      n = hexval(c);
      }
#line 534
      if (n < 0) {
        {
#line 535
        illegal_character(c_cptr);
        }
      } else
#line 534
      if (n >= 16) {
        {
#line 535
        illegal_character(c_cptr);
        }
      }
      {
#line 536
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 537
        c = (int )*cptr;
#line 538
        i = hexval(c);
        }
#line 539
        if (i < 0) {
#line 539
          goto while_break___0;
        } else
#line 539
        if (i >= 16) {
#line 539
          goto while_break___0;
        }
#line 540
        cptr ++;
#line 541
        n = (n << 4) + i;
#line 542
        if (n > 255) {
          {
#line 542
          illegal_character(c_cptr);
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 543
      c = n;
#line 544
      goto switch_break;
      case_97: /* CIL Label */ 
#line 545
      c = 7;
#line 545
      goto switch_break;
      case_98: /* CIL Label */ 
#line 546
      c = '\b';
#line 546
      goto switch_break;
      case_102: /* CIL Label */ 
#line 547
      c = '\f';
#line 547
      goto switch_break;
      case_110: /* CIL Label */ 
#line 548
      c = '\n';
#line 548
      goto switch_break;
      case_114: /* CIL Label */ 
#line 549
      c = '\r';
#line 549
      goto switch_break;
      case_116: /* CIL Label */ 
#line 550
      c = '\t';
#line 550
      goto switch_break;
      case_118: /* CIL Label */ 
#line 551
      c = '\v';
#line 551
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    {
#line 552
    cachec(c);
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 553
  free((void *)s_line);
#line 555
  n = cinc;
#line 556
  tmp___4 = malloc((size_t )((unsigned int )n));
#line 556
  s = (char *)tmp___4;
  }
#line 557
  if ((unsigned long )s == (unsigned long )((char *)0)) {
    {
#line 557
    no_space();
    }
  }
#line 559
  i = 0;
  {
#line 559
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 559
    if (! (i < n)) {
#line 559
      goto while_break___1;
    }
#line 560
    *(s + i) = *(cache + i);
#line 559
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 562
  cinc = 0;
#line 563
  if (n == 1) {
    {
#line 564
    cachec('\'');
    }
  } else {
    {
#line 566
    cachec('\"');
    }
  }
#line 568
  i = 0;
  {
#line 568
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 568
    if (! (i < n)) {
#line 568
      goto while_break___2;
    }
#line 569
    c = (int )*((unsigned char *)s + i);
#line 570
    if (c == 92) {
      {
#line 571
      cachec('\\');
#line 572
      cachec(c);
      }
    } else
#line 570
    if (c == (int )*(cache + 0)) {
      {
#line 571
      cachec('\\');
#line 572
      cachec(c);
      }
    } else {
      {
#line 573
      tmp___5 = __ctype_b_loc();
      }
#line 573
      if ((int const   )*(*tmp___5 + c) & 16384) {
        {
#line 574
        cachec(c);
        }
      } else {
        {
#line 576
        cachec('\\');
        }
        {
#line 578
        if (c == 7) {
#line 578
          goto case_7;
        }
#line 579
        if (c == 8) {
#line 579
          goto case_8;
        }
#line 580
        if (c == 12) {
#line 580
          goto case_12;
        }
#line 581
        if (c == 10) {
#line 581
          goto case_10___0;
        }
#line 582
        if (c == 13) {
#line 582
          goto case_13;
        }
#line 583
        if (c == 9) {
#line 583
          goto case_9;
        }
#line 584
        if (c == 11) {
#line 584
          goto case_11;
        }
#line 585
        goto switch_default;
        case_7: /* CIL Label */ 
        {
#line 578
        cachec('a');
        }
#line 578
        goto switch_break___0;
        case_8: /* CIL Label */ 
        {
#line 579
        cachec('b');
        }
#line 579
        goto switch_break___0;
        case_12: /* CIL Label */ 
        {
#line 580
        cachec('f');
        }
#line 580
        goto switch_break___0;
        case_10___0: /* CIL Label */ 
        {
#line 581
        cachec('n');
        }
#line 581
        goto switch_break___0;
        case_13: /* CIL Label */ 
        {
#line 582
        cachec('r');
        }
#line 582
        goto switch_break___0;
        case_9: /* CIL Label */ 
        {
#line 583
        cachec('t');
        }
#line 583
        goto switch_break___0;
        case_11: /* CIL Label */ 
        {
#line 584
        cachec('v');
        }
#line 584
        goto switch_break___0;
        switch_default: /* CIL Label */ 
        {
#line 586
        cachec(((c >> 6) & 7) + 48);
#line 587
        cachec(((c >> 3) & 7) + 48);
#line 588
        cachec((c & 7) + 48);
        }
#line 589
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
      }
    }
#line 568
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 590
  if (n == 1) {
    {
#line 591
    cachec('\'');
    }
  } else {
    {
#line 593
    cachec('\"');
    }
  }
  {
#line 595
  cachec('\000');
#line 596
  bp = lookup(cache);
#line 597
  bp->class = (char)1;
  }
#line 598
  if (n == 1) {
#line 598
    if (bp->value == -1) {
#line 599
      bp->value = (Yshort )*((unsigned char *)s);
    }
  }
  {
#line 600
  free((void *)s);
  }
#line 602
  return (bp);
}
}
#line 605 "/home/june/collector/temp/btyacc-3.0/reader.c"
int is_reserved(char *name ) 
{ 
  char *s ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;

  {
  {
#line 609
  tmp = strcmp((char const   *)name, ".");
  }
#line 609
  if (tmp == 0) {
#line 612
    return (1);
  } else {
    {
#line 609
    tmp___0 = strcmp((char const   *)name, "$accept");
    }
#line 609
    if (tmp___0 == 0) {
#line 612
      return (1);
    } else {
      {
#line 609
      tmp___1 = strcmp((char const   *)name, "$end");
      }
#line 609
      if (tmp___1 == 0) {
#line 612
        return (1);
      }
    }
  }
#line 614
  if ((int )*(name + 0) == 36) {
#line 614
    if ((int )*(name + 1) == 36) {
      {
#line 614
      tmp___3 = __ctype_b_loc();
      }
#line 614
      if ((int const   )*(*tmp___3 + (int )*(name + 2)) & 2048) {
#line 615
        s = name + 3;
        {
#line 616
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 616
          tmp___2 = __ctype_b_loc();
          }
#line 616
          if (! ((int const   )*(*tmp___2 + (int )*s) & 2048)) {
#line 616
            goto while_break;
          }
#line 616
          s ++;
        }
        while_break: /* CIL Label */ ;
        }
#line 617
        if ((int )*s == 0) {
#line 617
          return (1);
        }
      }
    }
  }
#line 619
  return (0);
}
}
#line 622 "/home/june/collector/temp/btyacc-3.0/reader.c"
bucket *get_name(void) 
{ 
  register int c ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  bucket *tmp___1 ;

  {
#line 626
  cinc = 0;
#line 627
  c = (int )*cptr;
  {
#line 627
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 627
    tmp = __ctype_b_loc();
    }
#line 627
    if (! ((int const   )*(*tmp + c) & 8)) {
#line 627
      if (! (c == 95)) {
#line 627
        if (! (c == 46)) {
#line 627
          if (! (c == 36)) {
#line 627
            goto while_break;
          }
        }
      }
    }
    {
#line 628
    cachec(c);
#line 627
    cptr ++;
#line 627
    c = (int )*cptr;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 629
  cachec('\000');
#line 630
  tmp___0 = is_reserved(cache);
  }
#line 630
  if (tmp___0) {
    {
#line 630
    used_reserved(cache);
    }
  }
  {
#line 631
  tmp___1 = lookup(cache);
  }
#line 631
  return (tmp___1);
}
}
#line 636 "/home/june/collector/temp/btyacc-3.0/reader.c"
int get_number(void) 
{ 
  int n ;
  char c ;
  char first ;
  unsigned short const   **tmp ;

  {
#line 637
  n = 0;
#line 638
  first = *cptr;
#line 640
  if ((int )first == 45) {
#line 641
    cptr ++;
  }
#line 642
  c = *cptr;
  {
#line 642
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 642
    tmp = __ctype_b_loc();
    }
#line 642
    if (! ((int const   )*(*tmp + (int )c) & 2048)) {
#line 642
      goto while_break;
    }
#line 643
    n = 10 * n + ((int )c - 48);
#line 642
    cptr ++;
#line 642
    c = *cptr;
  }
  while_break: /* CIL Label */ ;
  }
#line 644
  if ((int )first == 45) {
#line 645
    n = - n;
  }
#line 647
  return (n);
}
}
#line 690 "/home/june/collector/temp/btyacc-3.0/reader.c"
static char *cache_tag(char *tag , int len ) 
{ 
  int i ;
  char *s ;
  int tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 695
  i = 0;
  {
#line 695
  while (1) {
    while_continue: /* CIL Label */ ;
#line 695
    if (! (i < ntags)) {
#line 695
      goto while_break;
    }
    {
#line 696
    tmp = strncmp((char const   *)tag, (char const   *)*(tag_table + i), (size_t )len);
    }
#line 696
    if (tmp == 0) {
#line 696
      if ((int )*(*(tag_table + i) + len) == 0) {
#line 699
        return (*(tag_table + i));
      }
    }
#line 695
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 700
  if (ntags >= tagmax) {
#line 701
    tagmax += 16;
#line 702
    if (tag_table) {
      {
#line 702
      tmp___0 = realloc((void *)((char *)tag_table), (size_t )((unsigned int )((unsigned long )tagmax * sizeof(char *))));
#line 702
      tag_table = (char **)tmp___0;
      }
    } else {
      {
#line 702
      tmp___1 = allocate((unsigned int )((unsigned long )tagmax * sizeof(char *)));
#line 702
      tag_table = (char **)tmp___1;
      }
    }
#line 704
    if ((unsigned long )tag_table == (unsigned long )((char **)0)) {
      {
#line 704
      no_space();
      }
    }
  }
  {
#line 705
  tmp___2 = malloc((size_t )((unsigned int )(len + 1)));
#line 705
  s = (char *)tmp___2;
  }
#line 706
  if ((unsigned long )s == (unsigned long )((char *)0)) {
    {
#line 706
    no_space();
    }
  }
  {
#line 707
  strncpy((char */* __restrict  */)s, (char const   */* __restrict  */)tag, (size_t )len);
#line 708
  *(s + len) = (char)0;
#line 709
  tmp___3 = ntags;
#line 709
  ntags ++;
#line 709
  *(tag_table + tmp___3) = s;
  }
#line 710
  return (s);
}
}
#line 713 "/home/june/collector/temp/btyacc-3.0/reader.c"
char *get_tag(void) 
{ 
  register int c ;
  int t_lineno ;
  char *t_line ;
  char *tmp ;
  char *t_cptr ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 716
  t_lineno = lineno;
#line 717
  tmp = dup_line();
#line 717
  t_line = tmp;
#line 718
  t_cptr = t_line + (cptr - line);
#line 720
  cptr ++;
#line 721
  c = nextc();
  }
#line 722
  if (c == -1) {
    {
#line 722
    unexpected_EOF();
    }
  }
  {
#line 723
  tmp___0 = __ctype_b_loc();
  }
#line 723
  if (! ((int const   )*(*tmp___0 + c) & 1024)) {
#line 723
    if (c != 95) {
#line 723
      if (c != 36) {
        {
#line 724
        illegal_tag(t_lineno, t_line, t_cptr);
        }
      }
    }
  }
#line 726
  cinc = 0;
  {
#line 727
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 727
    cachec(c);
#line 727
    cptr ++;
#line 727
    c = (int )*cptr;
#line 727
    tmp___1 = __ctype_b_loc();
    }
#line 727
    if (! ((int const   )*(*tmp___1 + c) & 8)) {
#line 727
      if (! (c == 95)) {
#line 727
        if (! (c == 46)) {
#line 727
          if (! (c == 36)) {
#line 727
            goto while_break;
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 729
  c = nextc();
  }
#line 730
  if (c == -1) {
    {
#line 730
    unexpected_EOF();
    }
  }
#line 731
  if (c != 62) {
    {
#line 732
    illegal_tag(t_lineno, t_line, t_cptr);
    }
  }
  {
#line 733
  cptr ++;
#line 735
  free((void *)t_line);
#line 736
  havetags = 1;
#line 737
  tmp___2 = cache_tag(cache, cinc);
  }
#line 737
  return (tmp___2);
}
}
#line 740 "/home/june/collector/temp/btyacc-3.0/reader.c"
static char *scan_id(void) 
{ 
  char *b ;
  unsigned short const   **tmp ;
  char *tmp___0 ;

  {
#line 742
  b = cptr;
  {
#line 744
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 744
    tmp = __ctype_b_loc();
    }
#line 744
    if (! ((int const   )*(*tmp + (int )*cptr) & 8)) {
#line 744
      if (! ((int )*cptr == 95)) {
#line 744
        if (! ((int )*cptr == 36)) {
#line 744
          goto while_break;
        }
      }
    }
#line 744
    cptr ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 745
  tmp___0 = cache_tag(b, (int )(cptr - b));
  }
#line 745
  return (tmp___0);
}
}
#line 748 "/home/june/collector/temp/btyacc-3.0/reader.c"
void declare_tokens(int assoc ) 
{ 
  register int c ;
  register bucket *bp ;
  int value ;
  char *tag ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 753
  tag = (char *)0;
#line 755
  if (assoc != 0) {
#line 755
    prec ++;
  }
  {
#line 757
  c = nextc();
  }
#line 758
  if (c == -1) {
    {
#line 758
    unexpected_EOF();
    }
  }
#line 759
  if (c == 60) {
    {
#line 760
    tag = get_tag();
#line 761
    c = nextc();
    }
#line 762
    if (c == -1) {
      {
#line 762
      unexpected_EOF();
      }
    }
  }
  {
#line 764
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 765
    tmp = __ctype_b_loc();
    }
#line 765
    if ((int const   )*(*tmp + c) & 1024) {
      {
#line 766
      bp = get_name();
      }
    } else
#line 765
    if (c == 95) {
      {
#line 766
      bp = get_name();
      }
    } else
#line 765
    if (c == 46) {
      {
#line 766
      bp = get_name();
      }
    } else
#line 765
    if (c == 36) {
      {
#line 766
      bp = get_name();
      }
    } else
#line 767
    if (c == 39) {
      {
#line 768
      bp = get_literal();
      }
    } else
#line 767
    if (c == 34) {
      {
#line 768
      bp = get_literal();
      }
    } else {
#line 770
      return;
    }
#line 772
    if ((unsigned long )bp == (unsigned long )goal) {
      {
#line 772
      tokenized_start(bp->name);
      }
    }
#line 773
    bp->class = (char)1;
#line 775
    if (tag) {
#line 776
      if (bp->tag) {
#line 776
        if ((unsigned long )tag != (unsigned long )bp->tag) {
          {
#line 777
          retyped_warning(bp->name);
          }
        }
      }
#line 778
      bp->tag = tag;
    }
#line 780
    if (assoc != 0) {
#line 781
      if (bp->prec) {
#line 781
        if (prec != bp->prec) {
          {
#line 782
          reprec_warning(bp->name);
          }
        }
      }
#line 783
      bp->assoc = (char )assoc;
#line 784
      bp->prec = prec;
    }
    {
#line 786
    c = nextc();
    }
#line 787
    if (c == -1) {
      {
#line 787
      unexpected_EOF();
      }
    }
    {
#line 788
    value = -1;
#line 789
    tmp___0 = __ctype_b_loc();
    }
#line 789
    if ((int const   )*(*tmp___0 + c) & 2048) {
      {
#line 790
      value = get_number();
      }
#line 791
      if (bp->value != -1) {
#line 791
        if (value != bp->value) {
          {
#line 792
          revalued_warning(bp->name);
          }
        }
      }
      {
#line 793
      bp->value = value;
#line 794
      c = nextc();
      }
#line 795
      if (c == -1) {
        {
#line 795
        unexpected_EOF();
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 798 "/home/june/collector/temp/btyacc-3.0/reader.c"
static void declare_argtypes(bucket *bp ) 
{ 
  char *tags[20] ;
  int args ;
  int c ;
  int tmp ;
  char **tmp___0 ;
  char *tmp___1 ;
  char **tmp___2 ;
  char *tmp___3 ;

  {
#line 801
  args = 0;
#line 803
  if (bp->args >= 0) {
    {
#line 803
    retyped_warning(bp->name);
    }
  }
#line 804
  cptr ++;
  {
#line 805
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 806
    c = nextc();
    }
#line 807
    if (c == -1) {
      {
#line 807
      unexpected_EOF();
      }
    }
#line 808
    if (c != 60) {
      {
#line 808
      syntax_error(lineno, line, cptr);
      }
    }
    {
#line 809
    tmp = args;
#line 809
    args ++;
#line 809
    tags[tmp] = get_tag();
#line 810
    c = nextc();
    }
#line 811
    if (c == 41) {
#line 811
      goto while_break;
    }
#line 812
    if (c == -1) {
      {
#line 812
      unexpected_EOF();
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 813
  cptr ++;
#line 814
  bp->args = args;
#line 815
  tmp___1 = allocate((unsigned int )((unsigned long )args * sizeof(char *)));
#line 815
  tmp___0 = (char **)tmp___1;
#line 815
  bp->argnames = tmp___0;
  }
#line 815
  if (! tmp___0) {
    {
#line 815
    no_space();
    }
  }
  {
#line 816
  tmp___3 = allocate((unsigned int )((unsigned long )args * sizeof(char *)));
#line 816
  tmp___2 = (char **)tmp___3;
#line 816
  bp->argtags = tmp___2;
  }
#line 816
  if (! tmp___2) {
    {
#line 816
    no_space();
    }
  }
  {
#line 817
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 817
    args --;
#line 817
    if (! (args >= 0)) {
#line 817
      goto while_break___0;
    }
#line 818
    *(bp->argtags + args) = tags[args];
#line 819
    *(bp->argnames + args) = (char *)0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 820
  return;
}
}
#line 822 "/home/june/collector/temp/btyacc-3.0/reader.c"
void declare_types(void) 
{ 
  register int c ;
  register bucket *bp ;
  char *tag ;
  int tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 825
  bp = (bucket *)0;
#line 826
  tag = (char *)0;
#line 828
  c = nextc();
  }
#line 829
  if (c == 60) {
    {
#line 830
    tag = get_tag();
#line 831
    c = nextc();
    }
  }
#line 832
  if (c == -1) {
    {
#line 832
    unexpected_EOF();
    }
  }
  {
#line 834
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 835
    c = nextc();
#line 836
    tmp___0 = __ctype_b_loc();
    }
#line 836
    if ((int const   )*(*tmp___0 + c) & 1024) {
#line 836
      goto _L;
    } else
#line 836
    if (c == 95) {
#line 836
      goto _L;
    } else
#line 836
    if (c == 46) {
#line 836
      goto _L;
    } else
#line 836
    if (c == 36) {
      _L: /* CIL Label */ 
      {
#line 837
      bp = get_name();
#line 838
      tmp = nextc();
      }
#line 838
      if (tmp == 40) {
        {
#line 839
        declare_argtypes(bp);
        }
      } else {
#line 841
        bp->args = 0;
      }
    } else
#line 842
    if (c == 39) {
      {
#line 843
      bp = get_literal();
#line 844
      bp->args = 0;
      }
    } else
#line 842
    if (c == 34) {
      {
#line 843
      bp = get_literal();
#line 844
      bp->args = 0;
      }
    } else {
#line 846
      return;
    }
#line 848
    if (tag) {
#line 849
      if (bp->tag) {
#line 849
        if ((unsigned long )tag != (unsigned long )bp->tag) {
          {
#line 850
          retyped_warning(bp->name);
          }
        }
      }
#line 851
      bp->tag = tag;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 854 "/home/june/collector/temp/btyacc-3.0/reader.c"
void declare_start(void) 
{ 
  register int c ;
  register bucket *bp ;
  unsigned short const   **tmp ;

  {
  {
#line 859
  c = nextc();
  }
#line 860
  if (c == -1) {
    {
#line 860
    unexpected_EOF();
    }
  }
  {
#line 861
  tmp = __ctype_b_loc();
  }
#line 861
  if (! ((int const   )*(*tmp + c) & 1024)) {
#line 861
    if (c != 95) {
#line 861
      if (c != 46) {
#line 861
        if (c != 36) {
          {
#line 862
          syntax_error(lineno, line, cptr);
          }
        }
      }
    }
  }
  {
#line 863
  bp = get_name();
  }
#line 864
  if ((int )bp->class == 1) {
    {
#line 865
    terminal_start(bp->name);
    }
  }
#line 866
  if (goal) {
#line 866
    if ((unsigned long )goal != (unsigned long )bp) {
      {
#line 867
      restarted_warning();
      }
    }
  }
#line 868
  goal = bp;
#line 869
  return;
}
}
#line 871 "/home/june/collector/temp/btyacc-3.0/reader.c"
void read_declarations(void) 
{ 
  register int c ;
  register int k ;
  void *tmp ;

  {
  {
#line 875
  cache_size = 256;
#line 876
  tmp = malloc((size_t )((unsigned int )cache_size));
#line 876
  cache = (char *)tmp;
  }
#line 877
  if ((unsigned long )cache == (unsigned long )((char *)0)) {
    {
#line 877
    no_space();
    }
  }
  {
#line 879
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 880
    c = nextc();
    }
#line 881
    if (c == -1) {
      {
#line 881
      unexpected_EOF();
      }
    }
#line 882
    if (c != 37) {
      {
#line 882
      syntax_error(lineno, line, cptr);
      }
    }
    {
#line 883
    k = keyword();
    }
    {
#line 884
    if (k == 4) {
#line 884
      goto case_4;
    }
#line 886
    if (k == 9) {
#line 886
      goto case_9;
    }
#line 889
    if (k == 5) {
#line 889
      goto case_5;
    }
#line 892
    if (k == 8) {
#line 892
      goto case_8;
    }
#line 898
    if (k == 3) {
#line 898
      goto case_3;
    }
#line 898
    if (k == 2) {
#line 898
      goto case_3;
    }
#line 898
    if (k == 1) {
#line 898
      goto case_3;
    }
#line 898
    if (k == 0) {
#line 898
      goto case_3;
    }
#line 901
    if (k == 6) {
#line 901
      goto case_6;
    }
#line 904
    if (k == 7) {
#line 904
      goto case_7;
    }
#line 883
    goto switch_break;
    case_4: /* CIL Label */ 
#line 885
    return;
    case_9: /* CIL Label */ 
    {
#line 887
    copy_ident();
    }
#line 888
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 890
    copy_text();
    }
#line 891
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 893
    copy_union();
    }
#line 894
    goto switch_break;
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
    {
#line 899
    declare_tokens(k);
    }
#line 900
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 902
    declare_types();
    }
#line 903
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 905
    declare_start();
    }
#line 906
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 909 "/home/june/collector/temp/btyacc-3.0/reader.c"
void initialize_grammar(void) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 911
  nitems = 4;
#line 912
  maxitems = 300;
#line 913
  tmp = allocate((unsigned int )((unsigned long )maxitems * sizeof(bucket *)));
#line 913
  pitem = (bucket **)tmp;
  }
#line 914
  if ((unsigned long )pitem == (unsigned long )((bucket **)0)) {
    {
#line 914
    no_space();
    }
  }
  {
#line 915
  *(pitem + 0) = (bucket *)0;
#line 916
  *(pitem + 1) = (bucket *)0;
#line 917
  *(pitem + 2) = (bucket *)0;
#line 918
  *(pitem + 3) = (bucket *)0;
#line 920
  nrules = 3;
#line 921
  maxrules = 100;
#line 922
  tmp___0 = allocate((unsigned int )((unsigned long )maxrules * sizeof(bucket *)));
#line 922
  plhs = (bucket **)tmp___0;
  }
#line 923
  if ((unsigned long )plhs == (unsigned long )((bucket **)0)) {
    {
#line 923
    no_space();
    }
  }
  {
#line 924
  *(plhs + 0) = (bucket *)0;
#line 925
  *(plhs + 1) = (bucket *)0;
#line 926
  *(plhs + 2) = (bucket *)0;
#line 927
  tmp___1 = allocate((unsigned int )((unsigned long )maxrules * sizeof(Yshort )));
#line 927
  rprec = (Yshort *)tmp___1;
  }
#line 928
  if ((unsigned long )rprec == (unsigned long )((Yshort *)0)) {
    {
#line 928
    no_space();
    }
  }
  {
#line 929
  *(rprec + 0) = 0;
#line 930
  *(rprec + 1) = 0;
#line 931
  *(rprec + 2) = 0;
#line 932
  tmp___2 = allocate((unsigned int )((unsigned long )maxrules * sizeof(char )));
#line 932
  rassoc = tmp___2;
  }
#line 933
  if ((unsigned long )rassoc == (unsigned long )((char *)0)) {
    {
#line 933
    no_space();
    }
  }
#line 934
  *(rassoc + 0) = (char)0;
#line 935
  *(rassoc + 1) = (char)0;
#line 936
  *(rassoc + 2) = (char)0;
#line 937
  return;
}
}
#line 939 "/home/june/collector/temp/btyacc-3.0/reader.c"
void expand_items(void) 
{ 
  void *tmp ;

  {
  {
#line 941
  maxitems += 300;
#line 942
  tmp = realloc((void *)((char *)pitem), (size_t )((unsigned int )((unsigned long )maxitems * sizeof(bucket *))));
#line 942
  pitem = (bucket **)tmp;
  }
#line 943
  if ((unsigned long )pitem == (unsigned long )((bucket **)0)) {
    {
#line 943
    no_space();
    }
  }
#line 944
  return;
}
}
#line 946 "/home/june/collector/temp/btyacc-3.0/reader.c"
void expand_rules(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 948
  maxrules += 100;
#line 949
  tmp = realloc((void *)((char *)plhs), (size_t )((unsigned int )((unsigned long )maxrules * sizeof(bucket *))));
#line 949
  plhs = (bucket **)tmp;
  }
#line 950
  if ((unsigned long )plhs == (unsigned long )((bucket **)0)) {
    {
#line 950
    no_space();
    }
  }
  {
#line 951
  tmp___0 = realloc((void *)((char *)rprec), (size_t )((unsigned int )((unsigned long )maxrules * sizeof(Yshort ))));
#line 951
  rprec = (Yshort *)tmp___0;
  }
#line 952
  if ((unsigned long )rprec == (unsigned long )((Yshort *)0)) {
    {
#line 952
    no_space();
    }
  }
  {
#line 953
  tmp___1 = realloc((void *)rassoc, (size_t )((unsigned int )((unsigned long )maxrules * sizeof(char ))));
#line 953
  rassoc = (char *)tmp___1;
  }
#line 954
  if ((unsigned long )rassoc == (unsigned long )((char *)0)) {
    {
#line 954
    no_space();
    }
  }
#line 955
  return;
}
}
#line 959 "/home/june/collector/temp/btyacc-3.0/reader.c"
static int rescan_lineno  ;
#line 961 "/home/june/collector/temp/btyacc-3.0/reader.c"
static char *copy_args(int *alen ) 
{ 
  struct mstring *s ;
  struct mstring *tmp ;
  int depth ;
  int len ;
  int c ;
  char quote ;
  int a_lineno ;
  char *a_line ;
  char *tmp___0 ;
  char *a_cptr ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
  {
#line 963
  tmp = msnew();
#line 963
  s = tmp;
#line 964
  depth = 0;
#line 964
  len = 1;
#line 965
  quote = (char)0;
#line 966
  a_lineno = lineno;
#line 967
  tmp___0 = dup_line();
#line 967
  a_line = tmp___0;
#line 968
  a_cptr = a_line + ((cptr - line) - 1L);
#line 970
  rescan_lineno = lineno;
  }
  {
#line 971
  while (1) {
    while_continue: /* CIL Label */ ;
#line 971
    tmp___6 = cptr;
#line 971
    cptr ++;
#line 971
    c = (int )*tmp___6;
#line 971
    if (! (c != 41)) {
#line 971
      if (! depth) {
#line 971
        if (! quote) {
#line 971
          goto while_break;
        }
      }
    }
#line 972
    if (c == 44) {
#line 972
      if (! quote) {
#line 972
        if (! depth) {
#line 973
          len ++;
#line 974
          if ((unsigned long )s->ptr == (unsigned long )s->end) {
            {
#line 974
            mputchar(s, 0);
            }
          } else {
#line 974
            tmp___1 = s->ptr;
#line 974
            (s->ptr) ++;
#line 974
            *tmp___1 = (char)0;
          }
#line 975
          goto while_continue;
        }
      }
    }
#line 976
    if ((unsigned long )s->ptr == (unsigned long )s->end) {
      {
#line 976
      mputchar(s, c);
      }
    } else {
#line 976
      tmp___2 = s->ptr;
#line 976
      (s->ptr) ++;
#line 976
      *tmp___2 = (char )c;
    }
#line 977
    if (c == 10) {
      {
#line 978
      get_line();
      }
#line 979
      if (! line) {
#line 980
        if (quote) {
          {
#line 981
          unterminated_string(a_lineno, a_line, a_cptr);
          }
        } else {
          {
#line 983
          unterminated_arglist(a_lineno, a_line, a_cptr);
          }
        }
      }
    } else
#line 984
    if (quote) {
#line 985
      if (c == (int )quote) {
#line 985
        quote = (char)0;
      } else
#line 986
      if (c == 92) {
#line 987
        if ((int )*cptr != 10) {
#line 987
          if ((unsigned long )s->ptr == (unsigned long )s->end) {
            {
#line 987
            tmp___5 = cptr;
#line 987
            cptr ++;
#line 987
            mputchar(s, (int )*tmp___5);
            }
          } else {
#line 987
            tmp___3 = s->ptr;
#line 987
            (s->ptr) ++;
#line 987
            tmp___4 = cptr;
#line 987
            cptr ++;
#line 987
            *tmp___3 = *tmp___4;
          }
        }
      }
    } else
#line 989
    if (c == 40) {
#line 989
      depth ++;
    } else
#line 990
    if (c == 41) {
#line 990
      depth --;
    } else
#line 991
    if (c == 34) {
#line 991
      quote = (char )c;
    } else
#line 991
    if (c == 39) {
#line 991
      quote = (char )c;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 992
  if (alen) {
#line 992
    *alen = len;
  }
  {
#line 993
  free((void *)a_line);
#line 994
  tmp___7 = msdone(s);
  }
#line 994
  return (tmp___7);
}
}
#line 997 "/home/june/collector/temp/btyacc-3.0/reader.c"
static char *parse_id(char *p , char **save ) 
{ 
  char *b ;
  char *tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
  {
#line 1001
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1001
    tmp___0 = __ctype_b_loc();
    }
#line 1001
    if (! ((int const   )*(*tmp___0 + (int )*p) & 8192)) {
#line 1001
      goto while_break;
    }
#line 1001
    tmp = p;
#line 1001
    p ++;
#line 1001
    if ((int )*tmp == 10) {
#line 1001
      rescan_lineno ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1002
  tmp___1 = __ctype_b_loc();
  }
#line 1002
  if (! ((int const   )*(*tmp___1 + (int )*p) & 1024)) {
#line 1002
    if ((int )*p != 95) {
#line 1002
      return ((char *)0);
    }
  }
#line 1003
  b = p;
  {
#line 1004
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1004
    tmp___2 = __ctype_b_loc();
    }
#line 1004
    if (! ((int const   )*(*tmp___2 + (int )*p) & 8)) {
#line 1004
      if (! ((int )*p == 95)) {
#line 1004
        if (! ((int )*p == 36)) {
#line 1004
          goto while_break___0;
        }
      }
    }
#line 1004
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1005
  if (save) {
    {
#line 1006
    *save = cache_tag(b, (int )(p - b));
    }
  }
#line 1007
  return (p);
}
}
#line 1010 "/home/june/collector/temp/btyacc-3.0/reader.c"
static char *parse_int(char *p , int *save ) 
{ 
  int neg ;
  int val ;
  char *tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *tmp___2 ;
  unsigned short const   **tmp___3 ;

  {
#line 1012
  neg = 0;
#line 1012
  val = 0;
  {
#line 1014
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1014
    tmp___0 = __ctype_b_loc();
    }
#line 1014
    if (! ((int const   )*(*tmp___0 + (int )*p) & 8192)) {
#line 1014
      goto while_break;
    }
#line 1014
    tmp = p;
#line 1014
    p ++;
#line 1014
    if ((int )*tmp == 10) {
#line 1014
      rescan_lineno ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1015
  if ((int )*p == 45) {
#line 1016
    neg = 1;
#line 1017
    p ++;
  }
  {
#line 1018
  tmp___1 = __ctype_b_loc();
  }
#line 1018
  if (! ((int const   )*(*tmp___1 + (int )*p) & 2048)) {
#line 1018
    return ((char *)0);
  }
  {
#line 1019
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1019
    tmp___3 = __ctype_b_loc();
    }
#line 1019
    if (! ((int const   )*(*tmp___3 + (int )*p) & 2048)) {
#line 1019
      goto while_break___0;
    }
#line 1020
    tmp___2 = p;
#line 1020
    p ++;
#line 1020
    val = (val * 10 + (int )*tmp___2) - 48;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1021
  if (neg) {
#line 1021
    val = - val;
  }
#line 1022
  if (save) {
#line 1022
    *save = val;
  }
#line 1023
  return (p);
}
}
#line 1026 "/home/june/collector/temp/btyacc-3.0/reader.c"
static void parse_arginfo(bucket *a , char *args , int argslen ) 
{ 
  char *p ;
  char *tmp ;
  int i ;
  int redec ;
  Yshort tmp___0 ;
  char **tmp___1 ;
  char *tmp___2 ;
  char **tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  unsigned short const   **tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  unsigned short const   **tmp___9 ;
  char *tmp___10 ;
  unsigned short const   **tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  unsigned short const   **tmp___14 ;
  char *tmp___15 ;

  {
#line 1028
  p = args;
#line 1029
  redec = 0;
#line 1031
  if (a->args >= 0) {
#line 1032
    if (a->args != argslen) {
      {
#line 1033
      error(rescan_lineno, (char *)0, (char *)0, (char *)"number of arguments of %s does\'t agree with previous declaration",
            a->name);
      }
    }
#line 1035
    redec = 1;
  } else {
#line 1037
    tmp___0 = argslen;
#line 1037
    a->args = tmp___0;
#line 1037
    if (! tmp___0) {
#line 1037
      return;
    }
    {
#line 1038
    tmp___2 = allocate((unsigned int )((unsigned long )argslen * sizeof(char *)));
#line 1038
    tmp___1 = (char **)tmp___2;
#line 1038
    a->argnames = tmp___1;
    }
#line 1038
    if (tmp___1) {
      {
#line 1038
      tmp___4 = allocate((unsigned int )((unsigned long )argslen * sizeof(char *)));
#line 1038
      tmp___3 = (char **)tmp___4;
#line 1038
      a->argtags = tmp___3;
      }
#line 1038
      if (! tmp___3) {
        {
#line 1040
        no_space();
        }
      }
    } else {
      {
#line 1040
      no_space();
      }
    }
  }
#line 1041
  if (! args) {
#line 1041
    return;
  }
#line 1042
  i = 0;
  {
#line 1042
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1042
    if (! (i < argslen)) {
#line 1042
      goto while_break;
    }
    {
#line 1043
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1043
      tmp___6 = __ctype_b_loc();
      }
#line 1043
      if (! ((int const   )*(*tmp___6 + (int )*p) & 8192)) {
#line 1043
        goto while_break___0;
      }
#line 1043
      tmp___5 = p;
#line 1043
      p ++;
#line 1043
      if ((int )*tmp___5 == 10) {
#line 1043
        rescan_lineno ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1044
    tmp___7 = p;
#line 1044
    p ++;
#line 1044
    if ((int )*tmp___7 != 36) {
      {
#line 1044
      bad_formals();
      }
    }
    {
#line 1045
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1045
      tmp___9 = __ctype_b_loc();
      }
#line 1045
      if (! ((int const   )*(*tmp___9 + (int )*p) & 8192)) {
#line 1045
        goto while_break___1;
      }
#line 1045
      tmp___8 = p;
#line 1045
      p ++;
#line 1045
      if ((int )*tmp___8 == 10) {
#line 1045
        rescan_lineno ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1046
    if ((int )*p == 60) {
      {
#line 1047
      havetags = 1;
#line 1048
      p = parse_id(p + 1, & tmp);
      }
#line 1048
      if (! p) {
        {
#line 1048
        bad_formals();
        }
      }
      {
#line 1049
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 1049
        tmp___11 = __ctype_b_loc();
        }
#line 1049
        if (! ((int const   )*(*tmp___11 + (int )*p) & 8192)) {
#line 1049
          goto while_break___2;
        }
#line 1049
        tmp___10 = p;
#line 1049
        p ++;
#line 1049
        if ((int )*tmp___10 == 10) {
#line 1049
          rescan_lineno ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1050
      tmp___12 = p;
#line 1050
      p ++;
#line 1050
      if ((int )*tmp___12 != 62) {
        {
#line 1050
        bad_formals();
        }
      }
#line 1051
      if (redec) {
#line 1052
        if ((unsigned long )*(a->argtags + i) != (unsigned long )tmp) {
          {
#line 1053
          error(rescan_lineno, (char *)0, (char *)0, (char *)"type of argument %d to %s doesn\'t agree with previous declaration",
                i + 1, a->name);
          }
        }
      } else {
#line 1057
        *(a->argtags + i) = tmp;
      }
    } else
#line 1058
    if (! redec) {
#line 1059
      *(a->argtags + i) = (char *)0;
    }
    {
#line 1060
    p = parse_id(p, a->argnames + i);
    }
#line 1060
    if (! p) {
      {
#line 1060
      bad_formals();
      }
    }
    {
#line 1061
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 1061
      tmp___14 = __ctype_b_loc();
      }
#line 1061
      if (! ((int const   )*(*tmp___14 + (int )*p) & 8192)) {
#line 1061
        goto while_break___3;
      }
#line 1061
      tmp___13 = p;
#line 1061
      p ++;
#line 1061
      if ((int )*tmp___13 == 10) {
#line 1061
        rescan_lineno ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1062
    tmp___15 = p;
#line 1062
    p ++;
#line 1062
    if (*tmp___15) {
      {
#line 1062
      bad_formals();
      }
    }
#line 1042
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1063
  free((void *)args);
  }
#line 1064
  return;
}
}
#line 1066 "/home/june/collector/temp/btyacc-3.0/reader.c"
static char *compile_arg(char **theptr , char *yyvaltag ) 
{ 
  char *p ;
  struct mstring *c ;
  struct mstring *tmp ;
  int i ;
  int j ;
  int n ;
  Yshort *offsets ;
  Yshort maxoffset ;
  bucket **rhs ;
  char *tmp___0 ;
  char *tag ;
  char *tmp___1 ;
  int val ;
  char *arg ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
  {
#line 1068
  p = *theptr;
#line 1069
  tmp = msnew();
#line 1069
  c = tmp;
#line 1071
  offsets = (Yshort *)0;
#line 1074
  n = 0;
#line 1074
  maxoffset = n;
#line 1075
  i = nitems - 1;
  }
  {
#line 1075
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1075
    if (! *(pitem + i)) {
#line 1075
      goto while_break;
    }
#line 1076
    n ++;
#line 1077
    if ((int )(*(pitem + i))->class != 4) {
#line 1078
      maxoffset ++;
    }
#line 1075
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1079
  if (maxoffset > 0) {
    {
#line 1080
    tmp___0 = allocate((unsigned int )((unsigned long )(maxoffset + 1) * sizeof(Yshort )));
#line 1080
    offsets = (Yshort *)tmp___0;
    }
#line 1081
    if ((unsigned long )offsets == (unsigned long )((Yshort *)0)) {
      {
#line 1081
      no_space();
      }
    }
  }
#line 1082
  j = 0;
#line 1082
  i ++;
  {
#line 1082
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1082
    if (! (i < nitems)) {
#line 1082
      goto while_break___0;
    }
#line 1083
    if ((int )(*(pitem + i))->class != 4) {
#line 1084
      j ++;
#line 1084
      *(offsets + j) = (i - nitems) + 1;
    }
#line 1082
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1085
  rhs = (pitem + nitems) - 1;
#line 1087
  if (yyvaltag) {
    {
#line 1088
    msprintf(c, "yyval.%s = ", yyvaltag);
    }
  } else {
    {
#line 1090
    msprintf(c, "yyval = ");
    }
  }
  {
#line 1091
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1091
    if (! *p) {
#line 1091
      goto while_break___1;
    }
#line 1092
    if ((int )*p == 36) {
#line 1093
      tag = (char *)0;
#line 1094
      p ++;
#line 1094
      if ((int )*p == 60) {
        {
#line 1095
        p ++;
#line 1095
        p = parse_id(p, & tag);
        }
#line 1095
        if (p) {
#line 1095
          tmp___1 = p;
#line 1095
          p ++;
#line 1095
          if ((int )*tmp___1 != 62) {
            {
#line 1096
            illegal_tag(rescan_lineno, (char *)0, (char *)0);
            }
          }
        } else {
          {
#line 1096
          illegal_tag(rescan_lineno, (char *)0, (char *)0);
          }
        }
      }
      {
#line 1097
      tmp___3 = __ctype_b_loc();
      }
#line 1097
      if ((int const   )*(*tmp___3 + (int )*p) & 2048) {
#line 1097
        goto _L___0;
      } else
#line 1097
      if ((int )*p == 45) {
        _L___0: /* CIL Label */ 
        {
#line 1099
        p = parse_int(p, & val);
        }
#line 1099
        if (! p) {
          {
#line 1100
          dollar_error(rescan_lineno, (char *)0, (char *)0);
          }
        }
#line 1101
        if (val <= 0) {
#line 1101
          i = val - n;
        } else
#line 1102
        if (val > maxoffset) {
          {
#line 1103
          dollar_warning(rescan_lineno, val);
#line 1104
          i = val - maxoffset;
          }
        } else {
#line 1106
          i = *(offsets + val);
#line 1107
          if (! tag) {
#line 1107
            tag = (*(rhs + i))->tag;
#line 1107
            if (! tag) {
#line 1107
              if (havetags) {
                {
#line 1108
                untyped_rhs(val, (*(rhs + i))->name);
                }
              }
            }
          }
        }
        {
#line 1110
        msprintf(c, "yyvsp[%d]", i);
        }
#line 1111
        if (tag) {
          {
#line 1111
          msprintf(c, ".%s", tag);
          }
        } else
#line 1112
        if (havetags) {
          {
#line 1113
          unknown_rhs(val);
          }
        }
      } else {
        {
#line 1114
        tmp___2 = __ctype_b_loc();
        }
#line 1114
        if ((int const   )*(*tmp___2 + (int )*p) & 1024) {
#line 1114
          goto _L;
        } else
#line 1114
        if ((int )*p == 95) {
          _L: /* CIL Label */ 
          {
#line 1116
          p = parse_id(p, & arg);
          }
#line 1116
          if (! p) {
            {
#line 1117
            dollar_error(rescan_lineno, (char *)0, (char *)0);
            }
          }
#line 1118
          i = (*(plhs + nrules))->args - 1;
          {
#line 1118
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 1118
            if (! (i >= 0)) {
#line 1118
              goto while_break___2;
            }
#line 1119
            if ((unsigned long )arg == (unsigned long )*((*(plhs + nrules))->argnames + i)) {
#line 1119
              goto while_break___2;
            }
#line 1118
            i --;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 1120
          if (i < 0) {
            {
#line 1121
            error(rescan_lineno, (char *)0, (char *)0, (char *)"unknown argument $%s",
                  arg);
            }
          }
#line 1122
          if (! tag) {
#line 1123
            tag = *((*(plhs + nrules))->argtags + i);
          }
          {
#line 1124
          msprintf(c, "yyvsp[%d]", ((i - (*(plhs + nrules))->args) + 1) - n);
          }
#line 1125
          if (tag) {
            {
#line 1125
            msprintf(c, ".%s", tag);
            }
          } else
#line 1126
          if (havetags) {
            {
#line 1127
            error(rescan_lineno, (char *)0, (char *)0, (char *)"untyped argument $%s",
                  arg);
            }
          }
        } else {
          {
#line 1129
          dollar_error(rescan_lineno, (char *)0, (char *)0);
          }
        }
      }
    } else {
#line 1131
      if ((int )*p == 10) {
#line 1131
        rescan_lineno ++;
      }
#line 1132
      if ((unsigned long )c->ptr == (unsigned long )c->end) {
        {
#line 1132
        tmp___6 = p;
#line 1132
        p ++;
#line 1132
        mputchar(c, (int )*tmp___6);
        }
      } else {
#line 1132
        tmp___4 = c->ptr;
#line 1132
        (c->ptr) ++;
#line 1132
        tmp___5 = p;
#line 1132
        p ++;
#line 1132
        *tmp___4 = *tmp___5;
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1135
  *theptr = p;
#line 1136
  if (maxoffset > 0) {
    {
#line 1136
    free((void *)((char *)offsets));
    }
  }
  {
#line 1137
  tmp___7 = msdone(c);
  }
#line 1137
  return (tmp___7);
}
}
#line 1141 "/home/june/collector/temp/btyacc-3.0/reader.c"
static struct arg_cache *arg_cache[1024]  ;
#line 1147 "/home/june/collector/temp/btyacc-3.0/reader.c"
static int lookup_arg_cache(char *code ) 
{ 
  struct arg_cache *entry ;
  unsigned int tmp ;
  int tmp___0 ;

  {
  {
#line 1151
  tmp = strnshash((char const   *)code);
#line 1151
  entry = arg_cache[tmp % 1024U];
  }
  {
#line 1152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1152
    if (! entry) {
#line 1152
      goto while_break;
    }
    {
#line 1153
    tmp___0 = strnscmp((char const   *)entry->code, (char const   *)code);
    }
#line 1153
    if (! tmp___0) {
#line 1153
      return (entry->rule);
    }
#line 1154
    entry = entry->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1155
  return (-1);
}
}
#line 1158 "/home/june/collector/temp/btyacc-3.0/reader.c"
static void insert_arg_cache(char *code , int rule ) 
{ 
  struct arg_cache *entry ;
  char *tmp ;
  int i ;
  unsigned int tmp___0 ;

  {
  {
#line 1160
  tmp = allocate((unsigned int )sizeof(struct arg_cache ));
#line 1160
  entry = (struct arg_cache *)tmp;
  }
#line 1163
  if (! entry) {
    {
#line 1163
    no_space();
    }
  }
  {
#line 1164
  tmp___0 = strnshash((char const   *)code);
#line 1164
  i = (int )(tmp___0 % 1024U);
#line 1165
  entry->code = code;
#line 1166
  entry->rule = rule;
#line 1167
  entry->next = arg_cache[i];
#line 1168
  arg_cache[i] = entry;
  }
#line 1169
  return;
}
}
#line 1171 "/home/june/collector/temp/btyacc-3.0/reader.c"
static void clean_arg_cache(void) 
{ 
  struct arg_cache *e ;
  struct arg_cache *t ;
  int i ;

  {
#line 1176
  i = 0;
  {
#line 1176
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1176
    if (! (i < 1024)) {
#line 1176
      goto while_break;
    }
#line 1177
    e = arg_cache[i];
    {
#line 1177
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1177
      t = e;
#line 1177
      if (! t) {
#line 1177
        goto while_break___0;
      }
      {
#line 1178
      free((void *)e->code);
#line 1177
      e = e->next;
#line 1177
      free((void *)((char *)t));
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1179
    arg_cache[i] = (struct arg_cache *)0;
#line 1176
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1180
  return;
}
}
#line 1182 "/home/june/collector/temp/btyacc-3.0/reader.c"
void advance_to_start(void) 
{ 
  register int c ;
  register bucket *bp ;
  char *s_cptr ;
  int s_lineno ;
  char *args ;
  int argslen ;
  int tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 1188
  args = (char *)0;
#line 1189
  argslen = 0;
  {
#line 1191
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1192
    c = nextc();
    }
#line 1193
    if (c != 37) {
#line 1193
      goto while_break;
    }
    {
#line 1194
    s_cptr = cptr;
#line 1195
    tmp = keyword();
    }
    {
#line 1196
    if (tmp == 4) {
#line 1196
      goto case_4;
    }
#line 1198
    if (tmp == 5) {
#line 1198
      goto case_5;
    }
#line 1201
    if (tmp == 7) {
#line 1201
      goto case_7;
    }
#line 1204
    goto switch_default;
    case_4: /* CIL Label */ 
    {
#line 1197
    no_grammar();
    }
    case_5: /* CIL Label */ 
    {
#line 1199
    copy_text();
    }
#line 1200
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 1202
    declare_start();
    }
#line 1203
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1205
    syntax_error(lineno, line, s_cptr);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1207
  c = nextc();
#line 1208
  tmp___0 = __ctype_b_loc();
  }
#line 1208
  if (! ((int const   )*(*tmp___0 + c) & 1024)) {
#line 1208
    if (c != 95) {
#line 1208
      if (c != 46) {
#line 1208
        if (c != 95) {
          {
#line 1209
          syntax_error(lineno, line, cptr);
          }
        }
      }
    }
  }
  {
#line 1210
  bp = get_name();
  }
#line 1211
  if ((unsigned long )goal == (unsigned long )((bucket *)0)) {
#line 1212
    if ((int )bp->class == 1) {
      {
#line 1213
      terminal_start(bp->name);
      }
    }
#line 1214
    goal = bp;
  }
  {
#line 1216
  s_lineno = lineno;
#line 1217
  c = nextc();
  }
#line 1218
  if (c == -1) {
    {
#line 1218
    unexpected_EOF();
    }
  }
#line 1219
  if (c == 40) {
    {
#line 1220
    cptr ++;
#line 1221
    args = copy_args(& argslen);
    }
#line 1222
    if ((unsigned long )args == (unsigned long )((char *)0)) {
      {
#line 1222
      no_space();
      }
    }
    {
#line 1223
    c = nextc();
    }
  }
#line 1224
  if (c != 58) {
    {
#line 1224
    syntax_error(lineno, line, cptr);
    }
  }
  {
#line 1225
  start_rule(bp, s_lineno);
#line 1226
  parse_arginfo(bp, args, argslen);
#line 1227
  cptr ++;
  }
#line 1228
  return;
}
}
#line 1230 "/home/june/collector/temp/btyacc-3.0/reader.c"
void start_rule(bucket *bp , int s_lineno ) 
{ 


  {
#line 1232
  if ((int )bp->class == 1) {
    {
#line 1233
    terminal_lhs(s_lineno);
    }
  }
#line 1234
  bp->class = (char)2;
#line 1235
  if (! bp->index) {
#line 1235
    bp->index = nrules;
  }
#line 1236
  if (nrules >= maxrules) {
    {
#line 1237
    expand_rules();
    }
  }
#line 1238
  *(plhs + nrules) = bp;
#line 1239
  *(rprec + nrules) = -1;
#line 1240
  *(rassoc + nrules) = (char)0;
#line 1241
  return;
}
}
#line 1243 "/home/june/collector/temp/btyacc-3.0/reader.c"
void end_rule(void) 
{ 
  register int i ;

  {
#line 1247
  if (! last_was_action) {
#line 1247
    if ((*(plhs + nrules))->tag) {
#line 1248
      i = nitems - 1;
      {
#line 1248
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1248
        if (! *(pitem + i)) {
#line 1248
          goto while_break;
        }
#line 1248
        goto __Cont;
        __Cont: /* CIL Label */ 
#line 1248
        i --;
      }
      while_break: /* CIL Label */ ;
      }
#line 1249
      if ((unsigned long )*(pitem + (i + 1)) == (unsigned long )((bucket *)0)) {
        {
#line 1250
        default_action_warning();
        }
      } else
#line 1249
      if ((unsigned long )(*(pitem + (i + 1)))->tag != (unsigned long )(*(plhs + nrules))->tag) {
        {
#line 1250
        default_action_warning();
        }
      }
    }
  }
#line 1252
  last_was_action = (char)0;
#line 1253
  if (nitems >= maxitems) {
    {
#line 1253
    expand_items();
    }
  }
#line 1254
  *(pitem + nitems) = (bucket *)0;
#line 1255
  nitems ++;
#line 1256
  nrules ++;
#line 1257
  return;
}
}
#line 1259 "/home/june/collector/temp/btyacc-3.0/reader.c"
void insert_empty_rule(void) 
{ 
  register bucket *bp ;
  register bucket **bpp ;
  bucket **tmp ;
  bucket *tmp___0 ;

  {
#line 1263
  if (! cache) {
    {
#line 1263
    __assert_fail("cache", "/home/june/collector/temp/btyacc-3.0/reader.c", 1263U,
                  "insert_empty_rule");
    }
  }
  {
#line 1264
  gensym ++;
#line 1264
  sprintf((char */* __restrict  */)cache, (char const   */* __restrict  */)"$$%d",
          gensym);
#line 1265
  bp = make_bucket(cache);
#line 1266
  last_symbol->next = bp;
#line 1267
  last_symbol = bp;
#line 1268
  bp->tag = (*(plhs + nrules))->tag;
#line 1269
  bp->class = (char)3;
#line 1270
  bp->args = 0;
#line 1272
  nitems += 2;
  }
#line 1272
  if (nitems > maxitems) {
    {
#line 1273
    expand_items();
    }
  }
#line 1274
  bpp = (pitem + nitems) - 1;
#line 1275
  tmp = bpp;
#line 1275
  bpp --;
#line 1275
  *tmp = bp;
  {
#line 1276
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1276
    tmp___0 = *(bpp + -1);
#line 1276
    *(bpp + 0) = tmp___0;
#line 1276
    if (! tmp___0) {
#line 1276
      goto while_break;
    }
#line 1276
    bpp --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1278
  nrules ++;
#line 1278
  if (nrules >= maxrules) {
    {
#line 1279
    expand_rules();
    }
  }
#line 1280
  *(plhs + nrules) = *(plhs + (nrules - 1));
#line 1281
  *(plhs + (nrules - 1)) = bp;
#line 1282
  *(rprec + nrules) = *(rprec + (nrules - 1));
#line 1283
  *(rprec + (nrules - 1)) = 0;
#line 1284
  *(rassoc + nrules) = *(rassoc + (nrules - 1));
#line 1285
  *(rassoc + (nrules - 1)) = (char)0;
#line 1286
  return;
}
}
#line 1288 "/home/june/collector/temp/btyacc-3.0/reader.c"
static char *insert_arg_rule(char *arg , char *tag ) 
{ 
  int lineno___0 ;
  char *code ;
  char *tmp ;
  int rule ;
  int tmp___0 ;
  FILE *f ;
  char *tmp___1 ;

  {
  {
#line 1290
  lineno___0 = rescan_lineno;
#line 1291
  tmp = compile_arg(& arg, tag);
#line 1291
  code = tmp;
#line 1292
  tmp___0 = lookup_arg_cache(code);
#line 1292
  rule = tmp___0;
#line 1293
  f = action_file;
  }
#line 1295
  if (rule < 0) {
    {
#line 1296
    rule = nrules;
#line 1297
    insert_arg_cache(code, rule);
#line 1298
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"case %d:\n",
            rule - 2);
    }
#line 1299
    if (! lflag) {
#line 1300
      if (inc_file) {
#line 1300
        tmp___1 = inc_file_name;
      } else {
#line 1300
        tmp___1 = input_file_name;
      }
      {
#line 1300
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)(line_format),
              lineno___0, tmp___1);
      }
    }
    {
#line 1301
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%s;\n",
            code);
#line 1302
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"break;\n");
#line 1303
    insert_empty_rule();
#line 1304
    (*(plhs + rule))->tag = tag;
#line 1305
    (*(plhs + rule))->class = (char)4;
    }
  } else {
#line 1307
    nitems ++;
#line 1307
    if (nitems > maxitems) {
      {
#line 1308
      expand_items();
      }
    }
    {
#line 1309
    *(pitem + (nitems - 1)) = *(plhs + rule);
#line 1310
    free((void *)code);
    }
  }
#line 1311
  return (arg + 1);
}
}
#line 1314 "/home/june/collector/temp/btyacc-3.0/reader.c"
void add_symbol(void) 
{ 
  register int c ;
  register bucket *bp ;
  int s_lineno ;
  char *args ;
  int argslen ;
  int i ;
  char *ap___0 ;
  int i___0 ;

  {
#line 1318
  s_lineno = lineno;
#line 1319
  args = (char *)0;
#line 1320
  argslen = 0;
#line 1322
  c = (int )*cptr;
#line 1323
  if (c == 39) {
    {
#line 1324
    bp = get_literal();
    }
  } else
#line 1323
  if (c == 34) {
    {
#line 1324
    bp = get_literal();
    }
  } else {
    {
#line 1326
    bp = get_name();
    }
  }
  {
#line 1328
  c = nextc();
  }
#line 1329
  if (c == 40) {
    {
#line 1330
    cptr ++;
#line 1331
    args = copy_args(& argslen);
    }
#line 1332
    if ((unsigned long )args == (unsigned long )((char *)0)) {
      {
#line 1332
      no_space();
      }
    }
    {
#line 1333
    c = nextc();
    }
  }
#line 1334
  if (c == 58) {
    {
#line 1335
    end_rule();
#line 1336
    start_rule(bp, s_lineno);
#line 1337
    parse_arginfo(bp, args, argslen);
#line 1338
    cptr ++;
    }
#line 1339
    return;
  }
#line 1341
  if (last_was_action) {
    {
#line 1342
    insert_empty_rule();
    }
  }
#line 1343
  last_was_action = (char)0;
#line 1345
  if (bp->args < 0) {
#line 1346
    bp->args = argslen;
  }
#line 1347
  if (argslen == 0) {
#line 1347
    if (bp->args > 0) {
#line 1347
      if ((unsigned long )*(pitem + (nitems - 1)) == (unsigned long )((bucket *)0)) {
#line 1349
        if ((*(plhs + nrules))->args != bp->args) {
          {
#line 1350
          error(lineno, line, cptr, (char *)"Wrong number of default arguments for %s",
                bp->name);
          }
        }
#line 1352
        i = bp->args - 1;
        {
#line 1352
        while (1) {
          while_continue: /* CIL Label */ ;
#line 1352
          if (! (i >= 0)) {
#line 1352
            goto while_break;
          }
#line 1353
          if ((unsigned long )*((*(plhs + nrules))->argtags + i) != (unsigned long )*(bp->argtags + i)) {
            {
#line 1354
            error(lineno, line, cptr, (char *)"Wrong type for default argument %d to %s",
                  i + 1, bp->name);
            }
          }
#line 1352
          i --;
        }
        while_break: /* CIL Label */ ;
        }
      } else {
#line 1347
        goto _L___0;
      }
    } else {
#line 1347
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1356
  if (bp->args != argslen) {
    {
#line 1357
    error(lineno, line, cptr, (char *)"wrong number of arguments for %s", bp->name);
    }
  }
#line 1359
  if ((unsigned long )args != (unsigned long )((char *)0)) {
#line 1362
    ap___0 = args;
#line 1362
    i___0 = 0;
    {
#line 1362
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1362
      if (! (i___0 < argslen)) {
#line 1362
        goto while_break___0;
      }
      {
#line 1363
      ap___0 = insert_arg_rule(ap___0, *(bp->argtags + i___0));
#line 1362
      i___0 ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1364
    free((void *)args);
    }
  }
#line 1366
  nitems ++;
#line 1366
  if (nitems > maxitems) {
    {
#line 1367
    expand_items();
    }
  }
#line 1368
  *(pitem + (nitems - 1)) = bp;
#line 1369
  return;
}
}
#line 1371 "/home/june/collector/temp/btyacc-3.0/reader.c"
void copy_action(void) 
{ 
  register int c ;
  register int i ;
  register int j ;
  register int n ;
  int depth ;
  int trialaction ;
  int haveyyval ;
  char *tag ;
  register FILE *f ;
  int a_lineno ;
  char *a_line ;
  char *tmp ;
  char *a_cptr ;
  Yshort *offsets ;
  Yshort maxoffset ;
  bucket **rhs ;
  char *tmp___0 ;
  char *tmp___1 ;
  int d_lineno ;
  char *d_line ;
  char *tmp___2 ;
  char *d_cptr ;
  char *arg ;
  char *tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  char *arg___0 ;
  unsigned short const   **tmp___7 ;
  unsigned short const   **tmp___8 ;
  unsigned short const   **tmp___9 ;
  unsigned short const   **tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;

  {
  {
#line 1376
  trialaction = 0;
#line 1377
  haveyyval = 0;
#line 1379
  f = action_file;
#line 1380
  a_lineno = lineno;
#line 1381
  tmp = dup_line();
#line 1381
  a_line = tmp;
#line 1382
  a_cptr = a_line + (cptr - line);
#line 1383
  offsets = (Yshort *)0;
  }
#line 1386
  if (last_was_action) {
    {
#line 1387
    insert_empty_rule();
    }
  }
  {
#line 1388
  last_was_action = (char)1;
#line 1390
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"case %d:\n",
          nrules - 2);
  }
#line 1391
  if ((int )*cptr != 91) {
    {
#line 1392
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  if (!yytrial)\n");
    }
  } else {
#line 1394
    trialaction = 1;
  }
#line 1395
  if (! lflag) {
#line 1396
    if (inc_file) {
#line 1396
      tmp___0 = inc_file_name;
    } else {
#line 1396
      tmp___0 = input_file_name;
    }
    {
#line 1396
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)(line_format),
            lineno, tmp___0);
    }
  }
#line 1397
  if ((int )*cptr == 61) {
#line 1397
    cptr ++;
  }
#line 1399
  n = 0;
#line 1399
  maxoffset = n;
#line 1400
  i = nitems - 1;
  {
#line 1400
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1400
    if (! *(pitem + i)) {
#line 1400
      goto while_break;
    }
#line 1401
    n ++;
#line 1402
    if ((int )(*(pitem + i))->class != 4) {
#line 1403
      maxoffset ++;
    }
#line 1400
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1404
  if (maxoffset > 0) {
    {
#line 1405
    tmp___1 = allocate((unsigned int )((unsigned long )(maxoffset + 1) * sizeof(Yshort )));
#line 1405
    offsets = (Yshort *)tmp___1;
    }
#line 1406
    if ((unsigned long )offsets == (unsigned long )((Yshort *)0)) {
      {
#line 1406
      no_space();
      }
    }
  }
#line 1407
  j = 0;
#line 1407
  i ++;
  {
#line 1407
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1407
    if (! (i < nitems)) {
#line 1407
      goto while_break___0;
    }
#line 1408
    if ((int )(*(pitem + i))->class != 4) {
#line 1409
      j ++;
#line 1409
      *(offsets + j) = (i - nitems) + 1;
    }
#line 1407
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1410
  rhs = (pitem + nitems) - 1;
#line 1412
  depth = 0;
  loop: 
#line 1414
  c = (int )*cptr;
#line 1415
  if (c == 36) {
#line 1416
    if ((int )*(cptr + 1) == 60) {
      {
#line 1417
      d_lineno = lineno;
#line 1418
      tmp___2 = dup_line();
#line 1418
      d_line = tmp___2;
#line 1419
      d_cptr = d_line + (cptr - line);
#line 1421
      cptr ++;
#line 1422
      tag = get_tag();
#line 1423
      c = (int )*cptr;
      }
#line 1424
      if (c == 36) {
        {
#line 1425
        fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"yyval.%s",
                tag);
#line 1426
        cptr ++;
#line 1427
        free((void *)d_line);
        }
#line 1428
        goto loop;
      } else {
        {
#line 1429
        tmp___5 = __ctype_b_loc();
        }
#line 1429
        if ((int const   )*(*tmp___5 + c) & 2048) {
#line 1429
          goto _L___0;
        } else
#line 1429
        if (c == 45) {
          {
#line 1429
          tmp___6 = __ctype_b_loc();
          }
#line 1429
          if ((int const   )*(*tmp___6 + (int )*(cptr + 1)) & 2048) {
            _L___0: /* CIL Label */ 
            {
#line 1430
            i = get_number();
            }
#line 1431
            if (i <= 0) {
              {
#line 1432
              fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"yyvsp[%d].%s",
                      i - n, tag);
              }
            } else
#line 1433
            if (i > maxoffset) {
              {
#line 1434
              dollar_warning(d_lineno, i);
#line 1435
              fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"yyvsp[%d].%s",
                      i - maxoffset, tag);
              }
            } else {
              {
#line 1437
              fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"yyvsp[%d].%s",
                      *(offsets + i), tag);
              }
            }
            {
#line 1438
            free((void *)d_line);
            }
#line 1439
            goto loop;
          } else {
#line 1429
            goto _L___1;
          }
        } else {
          _L___1: /* CIL Label */ 
          {
#line 1440
          tmp___4 = __ctype_b_loc();
          }
#line 1440
          if ((int const   )*(*tmp___4 + c) & 1024) {
#line 1440
            goto _L;
          } else
#line 1440
          if (c == 95) {
            _L: /* CIL Label */ 
            {
#line 1441
            tmp___3 = scan_id();
#line 1441
            arg = tmp___3;
#line 1442
            i = (*(plhs + nrules))->args - 1;
            }
            {
#line 1442
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 1442
              if (! (i >= 0)) {
#line 1442
                goto while_break___1;
              }
#line 1443
              if ((unsigned long )arg == (unsigned long )*((*(plhs + nrules))->argnames + i)) {
#line 1443
                goto while_break___1;
              }
#line 1442
              i --;
            }
            while_break___1: /* CIL Label */ ;
            }
#line 1444
            if (i < 0) {
              {
#line 1445
              error(d_lineno, d_line, d_cptr, (char *)"unknown argument %s", arg);
              }
            }
            {
#line 1446
            fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"yyvsp[%d].%s",
                    ((i - (*(plhs + nrules))->args) + 1) - n, tag);
#line 1447
            free((void *)d_line);
            }
#line 1448
            goto loop;
          } else {
            {
#line 1450
            dollar_error(d_lineno, d_line, d_cptr);
            }
          }
        }
      }
    } else
#line 1451
    if ((int )*(cptr + 1) == 36) {
#line 1452
      if (havetags) {
#line 1453
        tag = (*(plhs + nrules))->tag;
#line 1454
        if ((unsigned long )tag == (unsigned long )((char *)0)) {
          {
#line 1454
          untyped_lhs();
          }
        }
        {
#line 1455
        fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"yyval.%s",
                tag);
        }
      } else {
        {
#line 1457
        fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"yyval");
        }
      }
#line 1458
      cptr += 2;
#line 1459
      haveyyval = 1;
#line 1460
      goto loop;
    } else {
      {
#line 1461
      tmp___8 = __ctype_b_loc();
      }
#line 1461
      if ((int const   )*(*tmp___8 + (int )*(cptr + 1)) & 2048) {
        {
#line 1462
        cptr ++;
#line 1463
        i = get_number();
        }
#line 1464
        if (havetags) {
#line 1465
          if (i <= 0) {
            {
#line 1466
            unknown_rhs(i);
            }
          } else
#line 1465
          if (i > maxoffset) {
            {
#line 1466
            unknown_rhs(i);
            }
          }
#line 1467
          tag = (*(rhs + *(offsets + i)))->tag;
#line 1468
          if ((unsigned long )tag == (unsigned long )((char *)0)) {
            {
#line 1469
            untyped_rhs(i, (*(rhs + *(offsets + i)))->name);
            }
          }
          {
#line 1470
          fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"yyvsp[%d].%s",
                  *(offsets + i), tag);
          }
        } else
#line 1472
        if (i > n) {
          {
#line 1473
          dollar_warning(lineno, i);
#line 1474
          fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"yyvsp[%d]",
                  i - maxoffset);
          }
        } else {
          {
#line 1476
          fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"yyvsp[%d]",
                  *(offsets + i));
          }
        }
#line 1477
        goto loop;
      } else
#line 1478
      if ((int )*(cptr + 1) == 45) {
        {
#line 1479
        cptr += 2;
#line 1480
        i = get_number();
        }
#line 1481
        if (havetags) {
          {
#line 1482
          unknown_rhs(- i);
          }
        }
        {
#line 1483
        fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"yyvsp[%d]",
                - i - n);
        }
#line 1484
        goto loop;
      } else {
        {
#line 1485
        tmp___7 = __ctype_b_loc();
        }
#line 1485
        if ((int const   )*(*tmp___7 + (int )*(cptr + 1)) & 1024) {
#line 1485
          goto _L___2;
        } else
#line 1485
        if ((int )*(cptr + 1) == 95) {
          _L___2: /* CIL Label */ 
          {
#line 1487
          cptr ++;
#line 1488
          arg___0 = scan_id();
#line 1489
          i = (*(plhs + nrules))->args - 1;
          }
          {
#line 1489
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 1489
            if (! (i >= 0)) {
#line 1489
              goto while_break___2;
            }
#line 1490
            if ((unsigned long )arg___0 == (unsigned long )*((*(plhs + nrules))->argnames + i)) {
#line 1490
              goto while_break___2;
            }
#line 1489
            i --;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 1491
          if (i < 0) {
            {
#line 1492
            error(lineno, line, cptr, (char *)"unknown argument %s", arg___0);
            }
          }
          {
#line 1493
          tag = *((*(plhs + nrules))->argtags + i);
#line 1494
          fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"yyvsp[%d]",
                  ((i - (*(plhs + nrules))->args) + 1) - n);
          }
#line 1495
          if (tag) {
            {
#line 1495
            fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)".%s",
                    tag);
            }
          } else
#line 1496
          if (havetags) {
            {
#line 1497
            error(lineno, (char *)0, (char *)0, (char *)"untyped argument $%s", arg___0);
            }
          }
#line 1498
          goto loop;
        }
      }
    }
  }
  {
#line 1499
  tmp___10 = __ctype_b_loc();
  }
#line 1499
  if ((int const   )*(*tmp___10 + c) & 1024) {
#line 1499
    goto _L___3;
  } else
#line 1499
  if (c == 95) {
#line 1499
    goto _L___3;
  } else
#line 1499
  if (c == 36) {
    _L___3: /* CIL Label */ 
    {
#line 1500
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 1501
      _IO_putc(c, f);
#line 1502
      cptr ++;
#line 1502
      c = (int )*cptr;
#line 1500
      tmp___9 = __ctype_b_loc();
      }
#line 1500
      if (! ((int const   )*(*tmp___9 + c) & 8)) {
#line 1500
        if (! (c == 95)) {
#line 1500
          if (! (c == 36)) {
#line 1500
            goto while_break___3;
          }
        }
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1504
    goto loop;
  }
#line 1505
  cptr ++;
#line 1506
  if (trialaction) {
#line 1506
    if (c == 91) {
#line 1506
      if (depth == 0) {
        {
#line 1507
        depth ++;
#line 1508
        _IO_putc('{', f);
        }
#line 1509
        goto loop;
      }
    }
  }
#line 1510
  if (trialaction) {
#line 1510
    if (c == 93) {
#line 1510
      if (depth == 1) {
        {
#line 1511
        depth --;
#line 1512
        _IO_putc('}', f);
#line 1513
        c = nextc();
        }
#line 1514
        if (c == 91) {
#line 1514
          if (! haveyyval) {
#line 1515
            goto loop;
          } else {
#line 1514
            goto _L___5;
          }
        } else
        _L___5: /* CIL Label */ 
#line 1516
        if (c == 123) {
#line 1516
          if (! haveyyval) {
            {
#line 1517
            fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n");
            }
#line 1518
            if (! lflag) {
              {
#line 1518
              fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"#\n");
              }
            }
            {
#line 1519
            fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  if (!yytrial)\n");
            }
#line 1520
            if (! lflag) {
#line 1521
              if (inc_file) {
#line 1521
                tmp___11 = inc_file_name;
              } else {
#line 1521
                tmp___11 = input_file_name;
              }
              {
#line 1521
              fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)(line_format),
                      lineno, tmp___11);
              }
            }
#line 1522
            trialaction = 0;
#line 1523
            goto loop;
          } else {
#line 1516
            goto _L___4;
          }
        } else {
          _L___4: /* CIL Label */ 
          {
#line 1525
          fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n");
          }
#line 1526
          if (! lflag) {
            {
#line 1526
            fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"#\n");
            }
          }
          {
#line 1527
          fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"break;\n");
#line 1528
          free((void *)a_line);
          }
#line 1529
          if (maxoffset > 0) {
            {
#line 1529
            free((void *)((char *)offsets));
            }
          }
#line 1530
          return;
        }
      }
    }
  }
  {
#line 1531
  _IO_putc(c, f);
  }
  {
#line 1533
  if (c == 10) {
#line 1533
    goto case_10;
  }
#line 1537
  if (c == 59) {
#line 1537
    goto case_59;
  }
#line 1545
  if (c == 91) {
#line 1545
    goto case_91;
  }
#line 1548
  if (c == 93) {
#line 1548
    goto case_93;
  }
#line 1551
  if (c == 123) {
#line 1551
    goto case_123;
  }
#line 1554
  if (c == 125) {
#line 1554
    goto case_125;
  }
#line 1575
  if (c == 34) {
#line 1575
    goto case_34;
  }
#line 1575
  if (c == 39) {
#line 1575
    goto case_34;
  }
#line 1578
  if (c == 47) {
#line 1578
    goto case_47;
  }
#line 1581
  goto switch_default;
  case_10: /* CIL Label */ 
  {
#line 1534
  get_line();
  }
#line 1535
  if (line) {
#line 1535
    goto loop;
  }
  {
#line 1536
  unterminated_action(a_lineno, a_line, a_cptr);
  }
  case_59: /* CIL Label */ 
#line 1538
  if (depth > 0) {
#line 1538
    goto loop;
  }
  {
#line 1539
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n");
  }
#line 1540
  if (! lflag) {
    {
#line 1540
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"#\n");
    }
  }
  {
#line 1541
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"break;\n");
#line 1542
  free((void *)a_line);
  }
#line 1543
  if (maxoffset > 0) {
    {
#line 1543
    free((void *)((char *)offsets));
    }
  }
#line 1544
  return;
  case_91: /* CIL Label */ 
#line 1546
  depth ++;
#line 1547
  goto loop;
  case_93: /* CIL Label */ 
#line 1549
  depth --;
#line 1550
  goto loop;
  case_123: /* CIL Label */ 
#line 1552
  depth ++;
#line 1553
  goto loop;
  case_125: /* CIL Label */ 
#line 1555
  depth --;
#line 1555
  if (depth > 0) {
#line 1555
    goto loop;
  }
  {
#line 1556
  c = nextc();
  }
#line 1557
  if (c == 91) {
#line 1557
    if (! haveyyval) {
#line 1558
      trialaction = 1;
#line 1559
      goto loop;
    } else {
#line 1557
      goto _L___7;
    }
  } else
  _L___7: /* CIL Label */ 
#line 1560
  if (c == 123) {
#line 1560
    if (! haveyyval) {
      {
#line 1561
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n");
      }
#line 1562
      if (! lflag) {
        {
#line 1562
        fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"#\n");
        }
      }
      {
#line 1563
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"  if (!yytrial)\n");
      }
#line 1564
      if (! lflag) {
#line 1565
        if (inc_file) {
#line 1565
          tmp___12 = inc_file_name;
        } else {
#line 1565
          tmp___12 = input_file_name;
        }
        {
#line 1565
        fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)(line_format),
                lineno, tmp___12);
        }
      }
#line 1566
      goto loop;
    } else {
#line 1560
      goto _L___6;
    }
  } else {
    _L___6: /* CIL Label */ 
    {
#line 1568
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n");
    }
#line 1569
    if (! lflag) {
      {
#line 1569
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"#\n");
      }
    }
    {
#line 1570
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"break;\n");
#line 1571
    free((void *)a_line);
    }
#line 1572
    if (maxoffset > 0) {
      {
#line 1572
      free((void *)((char *)offsets));
      }
    }
#line 1573
    return;
  }
  case_34: /* CIL Label */ 
  case_39: /* CIL Label */ 
  {
#line 1576
  copy_string(c, f, (FILE *)0);
  }
#line 1577
  goto loop;
  case_47: /* CIL Label */ 
  {
#line 1579
  copy_comment(f, (FILE *)0);
  }
#line 1580
  goto loop;
  switch_default: /* CIL Label */ 
#line 1582
  goto loop;
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1585 "/home/june/collector/temp/btyacc-3.0/reader.c"
int mark_symbol(void) 
{ 
  register int c ;
  register bucket *bp ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
#line 1590
  c = (int )*(cptr + 1);
#line 1591
  if (c == 37) {
#line 1592
    cptr += 2;
#line 1593
    return (1);
  } else
#line 1591
  if (c == 92) {
#line 1592
    cptr += 2;
#line 1593
    return (1);
  }
#line 1595
  if (c == 61) {
#line 1596
    cptr += 2;
  } else
#line 1597
  if (c == 112) {
#line 1597
    goto _L___2;
  } else
#line 1597
  if (c == 80) {
    _L___2: /* CIL Label */ 
#line 1597
    c = (int )*(cptr + 2);
#line 1597
    if (c == 114) {
#line 1597
      goto _L___1;
    } else
#line 1597
    if (c == 82) {
      _L___1: /* CIL Label */ 
#line 1597
      c = (int )*(cptr + 3);
#line 1597
      if (c == 101) {
#line 1597
        goto _L___0;
      } else
#line 1597
      if (c == 69) {
        _L___0: /* CIL Label */ 
#line 1597
        c = (int )*(cptr + 4);
#line 1597
        if (c == 99) {
#line 1597
          goto _L;
        } else
#line 1597
        if (c == 67) {
          _L: /* CIL Label */ 
          {
#line 1597
          c = (int )*(cptr + 5);
#line 1597
          tmp = __ctype_b_loc();
          }
#line 1597
          if ((int const   )*(*tmp + c) & 8) {
#line 1597
            tmp___0 = 0;
          } else
#line 1597
          if (c == 95) {
#line 1597
            tmp___0 = 0;
          } else
#line 1597
          if (c == 46) {
#line 1597
            tmp___0 = 0;
          } else
#line 1597
          if (c == 36) {
#line 1597
            tmp___0 = 0;
          } else {
#line 1597
            tmp___0 = 1;
          }
#line 1597
          if (tmp___0) {
#line 1602
            cptr += 5;
          } else {
            {
#line 1604
            syntax_error(lineno, line, cptr);
            }
          }
        } else {
          {
#line 1604
          syntax_error(lineno, line, cptr);
          }
        }
      } else {
        {
#line 1604
        syntax_error(lineno, line, cptr);
        }
      }
    } else {
      {
#line 1604
      syntax_error(lineno, line, cptr);
      }
    }
  } else {
    {
#line 1604
    syntax_error(lineno, line, cptr);
    }
  }
  {
#line 1606
  c = nextc();
#line 1607
  tmp___1 = __ctype_b_loc();
  }
#line 1607
  if ((int const   )*(*tmp___1 + c) & 1024) {
    {
#line 1608
    bp = get_name();
    }
  } else
#line 1607
  if (c == 95) {
    {
#line 1608
    bp = get_name();
    }
  } else
#line 1607
  if (c == 46) {
    {
#line 1608
    bp = get_name();
    }
  } else
#line 1607
  if (c == 36) {
    {
#line 1608
    bp = get_name();
    }
  } else
#line 1609
  if (c == 39) {
    {
#line 1610
    bp = get_literal();
    }
  } else
#line 1609
  if (c == 34) {
    {
#line 1610
    bp = get_literal();
    }
  } else {
    {
#line 1612
    syntax_error(lineno, line, cptr);
    }
#line 1614
    return (0);
  }
#line 1616
  if (*(rprec + nrules) != -1) {
#line 1616
    if (bp->prec != *(rprec + nrules)) {
      {
#line 1617
      prec_redeclared();
      }
    }
  }
#line 1619
  *(rprec + nrules) = bp->prec;
#line 1620
  *(rassoc + nrules) = bp->assoc;
#line 1621
  return (0);
}
}
#line 1624 "/home/june/collector/temp/btyacc-3.0/reader.c"
void read_grammar(void) 
{ 
  register int c ;
  int tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 1628
  initialize_grammar();
#line 1629
  advance_to_start();
  }
  {
#line 1631
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1632
    c = nextc();
    }
#line 1633
    if (c == -1) {
#line 1633
      goto while_break;
    }
    {
#line 1634
    tmp___0 = __ctype_b_loc();
    }
#line 1634
    if ((int const   )*(*tmp___0 + c) & 1024) {
      {
#line 1636
      add_symbol();
      }
    } else
#line 1634
    if (c == 95) {
      {
#line 1636
      add_symbol();
      }
    } else
#line 1634
    if (c == 46) {
      {
#line 1636
      add_symbol();
      }
    } else
#line 1634
    if (c == 36) {
      {
#line 1636
      add_symbol();
      }
    } else
#line 1634
    if (c == 39) {
      {
#line 1636
      add_symbol();
      }
    } else
#line 1634
    if (c == 34) {
      {
#line 1636
      add_symbol();
      }
    } else
#line 1637
    if (c == 123) {
      {
#line 1638
      copy_action();
      }
    } else
#line 1637
    if (c == 61) {
      {
#line 1638
      copy_action();
      }
    } else
#line 1637
    if (c == 91) {
      {
#line 1638
      copy_action();
      }
    } else
#line 1639
    if (c == 124) {
      {
#line 1640
      end_rule();
#line 1641
      start_rule(*(plhs + (nrules - 1)), 0);
#line 1642
      cptr ++;
      }
    } else
#line 1643
    if (c == 37) {
      {
#line 1644
      tmp = mark_symbol();
      }
#line 1644
      if (tmp) {
#line 1644
        goto while_break;
      }
    } else {
      {
#line 1646
      syntax_error(lineno, line, cptr);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1647
  end_rule();
  }
#line 1648
  if (goal->args > 0) {
    {
#line 1649
    error(0, (char *)0, (char *)0, (char *)"start symbol %s requires arguments", goal->name);
    }
  }
#line 1650
  return;
}
}
#line 1652 "/home/june/collector/temp/btyacc-3.0/reader.c"
void free_tags(void) 
{ 
  register int i ;

  {
#line 1656
  if ((unsigned long )tag_table == (unsigned long )((char **)0)) {
#line 1656
    return;
  }
#line 1658
  i = 0;
  {
#line 1658
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1658
    if (! (i < ntags)) {
#line 1658
      goto while_break;
    }
#line 1659
    if (! *(tag_table + i)) {
      {
#line 1659
      __assert_fail("tag_table[i]", "/home/june/collector/temp/btyacc-3.0/reader.c",
                    1659U, "free_tags");
      }
    }
    {
#line 1660
    free((void *)*(tag_table + i));
#line 1658
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1661
  free((void *)((char *)tag_table));
  }
#line 1662
  return;
}
}
#line 1664 "/home/june/collector/temp/btyacc-3.0/reader.c"
void pack_names(void) 
{ 
  register bucket *bp ;
  register char *p ;
  register char *s ;
  register char *t ;
  size_t tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  char *tmp___3 ;

  {
#line 1669
  name_pool_size = 13;
#line 1670
  bp = first_symbol;
  {
#line 1670
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1670
    if (! bp) {
#line 1670
      goto while_break;
    }
    {
#line 1671
    tmp = strlen((char const   *)bp->name);
#line 1671
    name_pool_size = (int )((size_t )name_pool_size + (tmp + 1UL));
#line 1670
    bp = bp->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1672
  tmp___0 = malloc((size_t )((unsigned int )name_pool_size));
#line 1672
  name_pool = (char *)tmp___0;
  }
#line 1673
  if ((unsigned long )name_pool == (unsigned long )((char *)0)) {
    {
#line 1673
    no_space();
    }
  }
  {
#line 1675
  strcpy((char */* __restrict  */)name_pool, (char const   */* __restrict  */)"$accept");
#line 1676
  strcpy((char */* __restrict  */)(name_pool + 8), (char const   */* __restrict  */)"$end");
#line 1677
  t = name_pool + 13;
#line 1678
  bp = first_symbol;
  }
  {
#line 1678
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1678
    if (! bp) {
#line 1678
      goto while_break___0;
    }
#line 1679
    p = t;
#line 1680
    s = bp->name;
    {
#line 1681
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1681
      tmp___1 = t;
#line 1681
      t ++;
#line 1681
      tmp___3 = s;
#line 1681
      s ++;
#line 1681
      tmp___2 = *tmp___3;
#line 1681
      *tmp___1 = tmp___2;
#line 1681
      if (! tmp___2) {
#line 1681
        goto while_break___1;
      }
#line 1681
      goto while_continue___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1682
    free((void *)bp->name);
#line 1683
    bp->name = p;
#line 1678
    bp = bp->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1684
  return;
}
}
#line 1686 "/home/june/collector/temp/btyacc-3.0/reader.c"
void check_symbols(void) 
{ 
  register bucket *bp ;

  {
#line 1690
  if ((int )goal->class == 0) {
    {
#line 1691
    undefined_goal(goal->name);
    }
  }
#line 1693
  bp = first_symbol;
  {
#line 1693
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1693
    if (! bp) {
#line 1693
      goto while_break;
    }
#line 1694
    if ((int )bp->class == 0) {
      {
#line 1695
      undefined_symbol_warning(bp->name);
#line 1696
      bp->class = (char)1;
      }
    }
#line 1693
    bp = bp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1697
  return;
}
}
#line 1699 "/home/june/collector/temp/btyacc-3.0/reader.c"
void pack_symbols(void) 
{ 
  register bucket *bp ;
  register bucket **v ;
  register int i ;
  register int j ;
  register int k ;
  register int n ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 1705
  nsyms = 2;
#line 1706
  ntokens = 1;
#line 1707
  bp = first_symbol;
  {
#line 1707
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1707
    if (! bp) {
#line 1707
      goto while_break;
    }
#line 1708
    nsyms ++;
#line 1709
    if ((int )bp->class == 1) {
#line 1709
      ntokens ++;
    }
#line 1707
    bp = bp->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1710
  start_symbol = ntokens;
#line 1711
  nvars = nsyms - ntokens;
#line 1713
  tmp = allocate((unsigned int )((unsigned long )nsyms * sizeof(char *)));
#line 1713
  symbol_name = (char **)tmp;
  }
#line 1714
  if ((unsigned long )symbol_name == (unsigned long )((char **)0)) {
    {
#line 1714
    no_space();
    }
  }
  {
#line 1715
  tmp___0 = allocate((unsigned int )((unsigned long )nsyms * sizeof(Yshort )));
#line 1715
  symbol_value = (Yshort *)tmp___0;
  }
#line 1716
  if ((unsigned long )symbol_value == (unsigned long )((Yshort *)0)) {
    {
#line 1716
    no_space();
    }
  }
  {
#line 1717
  tmp___1 = allocate((unsigned int )((unsigned long )nsyms * sizeof(Yshort )));
#line 1717
  symbol_prec = (Yshort *)tmp___1;
  }
#line 1718
  if ((unsigned long )symbol_prec == (unsigned long )((Yshort *)0)) {
    {
#line 1718
    no_space();
    }
  }
  {
#line 1719
  tmp___2 = malloc((size_t )((unsigned int )nsyms));
#line 1719
  symbol_assoc = (char *)tmp___2;
  }
#line 1720
  if ((unsigned long )symbol_assoc == (unsigned long )((char *)0)) {
    {
#line 1720
    no_space();
    }
  }
  {
#line 1722
  tmp___3 = allocate((unsigned int )((unsigned long )nsyms * sizeof(bucket *)));
#line 1722
  v = (bucket **)tmp___3;
  }
#line 1723
  if ((unsigned long )v == (unsigned long )((bucket **)0)) {
    {
#line 1723
    no_space();
    }
  }
#line 1725
  *(v + 0) = (bucket *)0;
#line 1726
  *(v + start_symbol) = (bucket *)0;
#line 1728
  i = 1;
#line 1729
  j = start_symbol + 1;
#line 1730
  bp = first_symbol;
  {
#line 1730
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1730
    if (! bp) {
#line 1730
      goto while_break___0;
    }
#line 1732
    if ((int )bp->class == 1) {
#line 1733
      tmp___4 = i;
#line 1733
      i ++;
#line 1733
      *(v + tmp___4) = bp;
    } else {
#line 1735
      tmp___5 = j;
#line 1735
      j ++;
#line 1735
      *(v + tmp___5) = bp;
    }
#line 1730
    bp = bp->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1737
  if (i == ntokens) {
#line 1737
    if (! (j == nsyms)) {
      {
#line 1737
      __assert_fail("i == ntokens && j == nsyms", "/home/june/collector/temp/btyacc-3.0/reader.c",
                    1737U, "pack_symbols");
      }
    }
  } else {
    {
#line 1737
    __assert_fail("i == ntokens && j == nsyms", "/home/june/collector/temp/btyacc-3.0/reader.c",
                  1737U, "pack_symbols");
    }
  }
#line 1739
  i = 1;
  {
#line 1739
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1739
    if (! (i < ntokens)) {
#line 1739
      goto while_break___1;
    }
#line 1740
    (*(v + i))->index = i;
#line 1739
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1742
  goal->index = start_symbol + 1;
#line 1743
  k = start_symbol + 2;
  {
#line 1744
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1744
    i ++;
#line 1744
    if (! (i < nsyms)) {
#line 1744
      goto while_break___2;
    }
#line 1745
    if ((unsigned long )*(v + i) != (unsigned long )goal) {
#line 1746
      (*(v + i))->index = k;
#line 1747
      k ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1748
  goal->value = 0;
#line 1749
  k = 1;
#line 1750
  i = start_symbol + 1;
  {
#line 1750
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1750
    if (! (i < nsyms)) {
#line 1750
      goto while_break___3;
    }
#line 1751
    if ((unsigned long )*(v + i) != (unsigned long )goal) {
#line 1752
      (*(v + i))->value = k;
#line 1753
      k ++;
    }
#line 1750
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1754
  k = 0;
#line 1755
  i = 1;
  {
#line 1755
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1755
    if (! (i < ntokens)) {
#line 1755
      goto while_break___4;
    }
#line 1756
    n = (*(v + i))->value;
#line 1757
    if (n > 256) {
#line 1758
      tmp___6 = k;
#line 1758
      k ++;
#line 1758
      j = tmp___6;
      {
#line 1758
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1758
        if (j > 0) {
#line 1758
          if (! (*(symbol_value + (j - 1)) > n)) {
#line 1758
            goto while_break___5;
          }
        } else {
#line 1758
          goto while_break___5;
        }
#line 1759
        *(symbol_value + j) = *(symbol_value + (j - 1));
#line 1758
        j --;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 1760
      *(symbol_value + j) = n;
    }
#line 1755
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 1761
  if ((*(v + 1))->value == -1) {
#line 1762
    (*(v + 1))->value = 256;
  }
#line 1763
  j = 0;
#line 1764
  n = 257;
#line 1765
  i = 2;
  {
#line 1765
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 1765
    if (! (i < ntokens)) {
#line 1765
      goto while_break___6;
    }
#line 1766
    if ((*(v + i))->value == -1) {
      {
#line 1767
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 1767
        if (j < k) {
#line 1767
          if (! (n == *(symbol_value + j))) {
#line 1767
            goto while_break___7;
          }
        } else {
#line 1767
          goto while_break___7;
        }
        {
#line 1768
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 1768
          j ++;
#line 1768
          if (j < k) {
#line 1768
            if (! (n == *(symbol_value + j))) {
#line 1768
              goto while_break___8;
            }
          } else {
#line 1768
            goto while_break___8;
          }
#line 1768
          goto while_continue___8;
        }
        while_break___8: /* CIL Label */ ;
        }
#line 1769
        n ++;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 1770
      (*(v + i))->value = n;
#line 1771
      n ++;
    }
#line 1765
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 1772
  *(symbol_name + 0) = name_pool + 8;
#line 1773
  *(symbol_value + 0) = 0;
#line 1774
  *(symbol_prec + 0) = 0;
#line 1775
  *(symbol_assoc + 0) = (char)0;
#line 1776
  i = 1;
  {
#line 1776
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 1776
    if (! (i < ntokens)) {
#line 1776
      goto while_break___9;
    }
#line 1777
    *(symbol_name + i) = (*(v + i))->name;
#line 1778
    *(symbol_value + i) = (*(v + i))->value;
#line 1779
    *(symbol_prec + i) = (*(v + i))->prec;
#line 1780
    *(symbol_assoc + i) = (*(v + i))->assoc;
#line 1776
    i ++;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 1781
  *(symbol_name + start_symbol) = name_pool;
#line 1782
  *(symbol_value + start_symbol) = -1;
#line 1783
  *(symbol_prec + start_symbol) = 0;
#line 1784
  *(symbol_assoc + start_symbol) = (char)0;
#line 1785
  i ++;
  {
#line 1785
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 1785
    if (! (i < nsyms)) {
#line 1785
      goto while_break___10;
    }
#line 1786
    k = (*(v + i))->index;
#line 1787
    *(symbol_name + k) = (*(v + i))->name;
#line 1788
    *(symbol_value + k) = (*(v + i))->value;
#line 1789
    *(symbol_prec + k) = (*(v + i))->prec;
#line 1790
    *(symbol_assoc + k) = (*(v + i))->assoc;
#line 1785
    i ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 1791
  free((void *)((char *)v));
  }
#line 1792
  return;
}
}
#line 1794 "/home/june/collector/temp/btyacc-3.0/reader.c"
void pack_grammar(void) 
{ 
  register int i ;
  register int j ;
  int assoc ;
  int prec___0 ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 1799
  tmp = allocate((unsigned int )((unsigned long )nitems * sizeof(Yshort )));
#line 1799
  ritem = (Yshort *)tmp;
  }
#line 1800
  if ((unsigned long )ritem == (unsigned long )((Yshort *)0)) {
    {
#line 1800
    no_space();
    }
  }
  {
#line 1801
  tmp___0 = allocate((unsigned int )((unsigned long )nrules * sizeof(Yshort )));
#line 1801
  rlhs = (Yshort *)tmp___0;
  }
#line 1802
  if ((unsigned long )rlhs == (unsigned long )((Yshort *)0)) {
    {
#line 1802
    no_space();
    }
  }
  {
#line 1803
  tmp___1 = allocate((unsigned int )((unsigned long )(nrules + 1) * sizeof(Yshort )));
#line 1803
  rrhs = (Yshort *)tmp___1;
  }
#line 1804
  if ((unsigned long )rrhs == (unsigned long )((Yshort *)0)) {
    {
#line 1804
    no_space();
    }
  }
  {
#line 1805
  tmp___2 = realloc((void *)((char *)rprec), (size_t )((unsigned int )((unsigned long )nrules * sizeof(Yshort ))));
#line 1805
  rprec = (Yshort *)tmp___2;
  }
#line 1806
  if ((unsigned long )rprec == (unsigned long )((Yshort *)0)) {
    {
#line 1806
    no_space();
    }
  }
  {
#line 1807
  tmp___3 = realloc((void *)rassoc, (size_t )((unsigned int )((unsigned long )nrules * sizeof(char ))));
#line 1807
  rassoc = (char *)tmp___3;
  }
#line 1808
  if ((unsigned long )rassoc == (unsigned long )((char *)0)) {
    {
#line 1808
    no_space();
    }
  }
#line 1810
  *(ritem + 0) = -1;
#line 1811
  *(ritem + 1) = goal->index;
#line 1812
  *(ritem + 2) = 0;
#line 1813
  *(ritem + 3) = -2;
#line 1814
  *(rlhs + 0) = 0;
#line 1815
  *(rlhs + 1) = 0;
#line 1816
  *(rlhs + 2) = start_symbol;
#line 1817
  *(rrhs + 0) = 0;
#line 1818
  *(rrhs + 1) = 0;
#line 1819
  *(rrhs + 2) = 1;
#line 1821
  j = 4;
#line 1822
  i = 3;
  {
#line 1822
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1822
    if (! (i < nrules)) {
#line 1822
      goto while_break;
    }
#line 1823
    if ((*(plhs + i))->args > 0) {
#line 1824
      if ((*(plhs + i))->argnames) {
        {
#line 1825
        free((void *)((char *)(*(plhs + i))->argnames));
#line 1826
        (*(plhs + i))->argnames = (char **)0;
        }
      }
#line 1828
      if ((*(plhs + i))->argtags) {
        {
#line 1829
        free((void *)((char *)(*(plhs + i))->argtags));
#line 1830
        (*(plhs + i))->argtags = (char **)0;
        }
      }
    }
#line 1833
    *(rlhs + i) = (*(plhs + i))->index;
#line 1834
    *(rrhs + i) = j;
#line 1835
    assoc = 0;
#line 1836
    prec___0 = 0;
    {
#line 1837
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1837
      if (! *(pitem + j)) {
#line 1837
        goto while_break___0;
      }
#line 1838
      *(ritem + j) = (*(pitem + j))->index;
#line 1839
      if ((int )(*(pitem + j))->class == 1) {
#line 1840
        prec___0 = (*(pitem + j))->prec;
#line 1841
        assoc = (int )(*(pitem + j))->assoc;
      }
#line 1842
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1843
    *(ritem + j) = - i;
#line 1844
    j ++;
#line 1845
    if (*(rprec + i) == -1) {
#line 1846
      *(rprec + i) = prec___0;
#line 1847
      *(rassoc + i) = (char )assoc;
    }
#line 1822
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1848
  *(rrhs + i) = j;
#line 1849
  free((void *)((char *)plhs));
#line 1850
  free((void *)((char *)pitem));
#line 1851
  clean_arg_cache();
  }
#line 1852
  return;
}
}
#line 1854 "/home/june/collector/temp/btyacc-3.0/reader.c"
void print_grammar(void) 
{ 
  register int i ;
  register int j ;
  register int k ;
  int spacing ;
  register FILE *f ;
  size_t tmp ;

  {
#line 1857
  spacing = 0;
#line 1858
  f = verbose_file;
#line 1860
  if (! vflag) {
#line 1860
    return;
  }
#line 1862
  k = 1;
#line 1863
  i = 2;
  {
#line 1863
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1863
    if (! (i < nrules)) {
#line 1863
      goto while_break;
    }
#line 1864
    if (*(rlhs + i) != *(rlhs + (i - 1))) {
#line 1865
      if (i != 2) {
        {
#line 1865
        fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n");
        }
      }
      {
#line 1866
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%4d  %s :",
              i - 2, *(symbol_name + *(rlhs + i)));
#line 1867
      tmp = strlen((char const   *)*(symbol_name + *(rlhs + i)));
#line 1867
      spacing = (int )(tmp + 1UL);
      }
    } else {
      {
#line 1869
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%4d  ",
              i - 2);
#line 1870
      j = spacing;
      }
      {
#line 1871
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1871
        j --;
#line 1871
        if (! (j >= 0)) {
#line 1871
          goto while_break___0;
        }
        {
#line 1871
        _IO_putc(' ', f);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1872
      _IO_putc('|', f);
      }
    }
    {
#line 1873
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1873
      if (! (*(ritem + k) >= 0)) {
#line 1873
        goto while_break___1;
      }
      {
#line 1874
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)" %s",
              *(symbol_name + *(ritem + k)));
#line 1875
      k ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1876
    k ++;
#line 1877
    _IO_putc('\n', f);
#line 1863
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1878
  return;
}
}
#line 1880
int read_errs ;
#line 1882 "/home/june/collector/temp/btyacc-3.0/reader.c"
void reader(void) 
{ 


  {
  {
#line 1883
  write_section((char *)"banner");
#line 1884
  create_symbol_table();
#line 1885
  read_declarations();
#line 1886
  read_grammar();
  }
#line 1887
  if (read_errs) {
    {
#line 1887
    done(1);
    }
  }
  {
#line 1888
  free_symbol_table();
#line 1889
  free_tags();
#line 1890
  pack_names();
#line 1891
  check_symbols();
#line 1892
  pack_symbols();
#line 1893
  pack_grammar();
#line 1894
  free_symbols();
#line 1895
  print_grammar();
  }
#line 1896
  return;
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 379
extern  __attribute__((__nothrow__)) int vsprintf(char * __restrict  __s , char const   * __restrict  __format ,
                                                  __gnuc_va_list __arg ) ;
#line 318 "/home/june/collector/temp/btyacc-3.0/defs.h"
void print_pos(char *st_line , char *st_cptr ) ;
#line 10 "/home/june/collector/temp/btyacc-3.0/error.c"
void FileError(char *fmt  , ...) ;
#line 16 "/home/june/collector/temp/btyacc-3.0/error.c"
void FileError(char *fmt  , ...) 
{ 
  va_list args ;
  char *tmp ;

  {
#line 19
  if (inc_file) {
#line 19
    tmp = inc_file_name;
  } else {
#line 19
    tmp = input_file_name;
  }
  {
#line 19
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: ",
          tmp, lineno);
#line 20
  __builtin_va_start(args, fmt);
#line 21
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
           args);
#line 22
  __builtin_va_end(args);
#line 23
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 24
  return;
}
}
#line 26 "/home/june/collector/temp/btyacc-3.0/error.c"
void fatal(char *msg ) 
{ 


  {
  {
#line 28
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fatal - %s\n",
          msg);
#line 29
  done(2);
  }
#line 30
  return;
}
}
#line 33 "/home/june/collector/temp/btyacc-3.0/error.c"
void no_space(void) 
{ 


  {
  {
#line 35
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fatal - out of space\n");
#line 36
  done(2);
  }
#line 37
  return;
}
}
#line 40 "/home/june/collector/temp/btyacc-3.0/error.c"
void open_error(char *filename ) 
{ 


  {
  {
#line 42
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fatal - cannot open \"%s\"\n",
          filename);
#line 43
  done(2);
  }
#line 44
  return;
}
}
#line 47 "/home/june/collector/temp/btyacc-3.0/error.c"
void unexpected_EOF(void) 
{ 


  {
  {
#line 49
  FileError((char *)"unexpected end-of-file");
#line 50
  done(1);
  }
#line 51
  return;
}
}
#line 54 "/home/june/collector/temp/btyacc-3.0/error.c"
void print_pos(char *st_line , char *st_cptr ) 
{ 
  register char *s ;
  unsigned short const   **tmp ;

  {
#line 58
  if ((unsigned long )st_line == (unsigned long )((char *)0)) {
#line 58
    return;
  }
#line 59
  s = st_line;
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    if (! ((int )*s != 10)) {
#line 59
      goto while_break;
    }
    {
#line 61
    tmp = __ctype_b_loc();
    }
#line 61
    if ((int const   )*(*tmp + (int )*s) & 16384) {
      {
#line 62
      _IO_putc((int )*s, stderr);
      }
    } else
#line 61
    if ((int )*s == 9) {
      {
#line 62
      _IO_putc((int )*s, stderr);
      }
    } else {
      {
#line 64
      _IO_putc('?', stderr);
      }
    }
#line 59
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 66
  _IO_putc('\n', stderr);
#line 67
  s = st_line;
  }
  {
#line 67
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 67
    if (! ((unsigned long )s < (unsigned long )st_cptr)) {
#line 67
      goto while_break___0;
    }
#line 69
    if ((int )*s == 9) {
      {
#line 70
      _IO_putc('\t', stderr);
      }
    } else {
      {
#line 72
      _IO_putc(' ', stderr);
      }
    }
#line 67
    s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 74
  _IO_putc('^', stderr);
#line 75
  _IO_putc('\n', stderr);
  }
#line 76
  return;
}
}
#line 78 "/home/june/collector/temp/btyacc-3.0/error.c"
int read_errs  =    0;
#line 80 "/home/june/collector/temp/btyacc-3.0/error.c"
void error(int lineno___0 , char *line___0 , char *cptr___0 , char *msg  , ...) 
{ 
  char sbuf[512] ;
  va_list args ;

  {
  {
#line 85
  __builtin_va_start(args, msg);
#line 86
  vsprintf((char */* __restrict  */)(sbuf), (char const   */* __restrict  */)msg,
           args);
#line 87
  __builtin_va_end(args);
#line 88
  FileError((char *)"%s", sbuf);
#line 89
  read_errs ++;
  }
#line 90
  return;
}
}
#line 92 "/home/june/collector/temp/btyacc-3.0/error.c"
void syntax_error(int lineno___0 , char *line___0 , char *cptr___0 ) 
{ 


  {
  {
#line 93
  error(lineno___0, line___0, cptr___0, (char *)"syntax error");
#line 94
  exit(1);
  }
}
}
#line 97 "/home/june/collector/temp/btyacc-3.0/error.c"
void unterminated_comment(int lineno___0 , char *line___0 , char *cptr___0 ) 
{ 


  {
  {
#line 98
  error(lineno___0, line___0, cptr___0, (char *)"unmatched /*");
#line 99
  exit(1);
  }
}
}
#line 102 "/home/june/collector/temp/btyacc-3.0/error.c"
void unterminated_string(int lineno___0 , char *line___0 , char *cptr___0 ) 
{ 


  {
  {
#line 103
  error(lineno___0, line___0, cptr___0, (char *)"unterminated string");
#line 104
  exit(1);
  }
}
}
#line 107 "/home/june/collector/temp/btyacc-3.0/error.c"
void unterminated_text(int lineno___0 , char *line___0 , char *cptr___0 ) 
{ 


  {
  {
#line 108
  error(lineno___0, line___0, cptr___0, (char *)"unmatched %%{");
#line 109
  exit(1);
  }
}
}
#line 112 "/home/june/collector/temp/btyacc-3.0/error.c"
void unterminated_union(int lineno___0 , char *line___0 , char *cptr___0 ) 
{ 


  {
  {
#line 113
  error(lineno___0, line___0, cptr___0, (char *)"unterminated %%union");
#line 114
  exit(1);
  }
}
}
#line 117 "/home/june/collector/temp/btyacc-3.0/error.c"
void over_unionized(char *cptr___0 ) 
{ 


  {
  {
#line 118
  error(lineno, line, cptr___0, (char *)"too many %%union declarations");
#line 119
  exit(1);
  }
}
}
#line 122 "/home/june/collector/temp/btyacc-3.0/error.c"
void illegal_tag(int lineno___0 , char *line___0 , char *cptr___0 ) 
{ 


  {
  {
#line 123
  error(lineno___0, line___0, cptr___0, (char *)"illegal tag");
  }
#line 124
  return;
}
}
#line 126 "/home/june/collector/temp/btyacc-3.0/error.c"
void illegal_character(char *cptr___0 ) 
{ 


  {
  {
#line 127
  error(lineno, line, cptr___0, (char *)"illegal character");
  }
#line 128
  return;
}
}
#line 130 "/home/june/collector/temp/btyacc-3.0/error.c"
void used_reserved(char *s ) 
{ 


  {
  {
#line 131
  error(lineno, (char *)0, (char *)0, (char *)"illegal use of reserved symbol %s",
        s);
  }
#line 132
  return;
}
}
#line 134 "/home/june/collector/temp/btyacc-3.0/error.c"
void tokenized_start(char *s ) 
{ 


  {
  {
#line 135
  error(lineno, (char *)0, (char *)0, (char *)"the start symbol %s cannot be declared to be a token",
        s);
  }
#line 136
  return;
}
}
#line 138 "/home/june/collector/temp/btyacc-3.0/error.c"
void retyped_warning(char *s ) 
{ 


  {
  {
#line 139
  FileError((char *)"the type of %s has been redeclared", s);
  }
#line 140
  return;
}
}
#line 143 "/home/june/collector/temp/btyacc-3.0/error.c"
void reprec_warning(char *s ) 
{ 


  {
  {
#line 144
  FileError((char *)"the precedence of %s has been redeclared", s);
  }
#line 145
  return;
}
}
#line 148 "/home/june/collector/temp/btyacc-3.0/error.c"
void revalued_warning(char *s ) 
{ 


  {
  {
#line 149
  FileError((char *)"the value of %s has been redeclared", s);
  }
#line 150
  return;
}
}
#line 153 "/home/june/collector/temp/btyacc-3.0/error.c"
void terminal_start(char *s ) 
{ 


  {
  {
#line 154
  error(lineno, (char *)0, (char *)0, (char *)"the start symbol %s is a token", s);
  }
#line 155
  return;
}
}
#line 157 "/home/june/collector/temp/btyacc-3.0/error.c"
void restarted_warning(void) 
{ 


  {
  {
#line 158
  FileError((char *)"the start symbol has been redeclared");
  }
#line 159
  return;
}
}
#line 161 "/home/june/collector/temp/btyacc-3.0/error.c"
void no_grammar(void) 
{ 


  {
  {
#line 162
  error(lineno, (char *)0, (char *)0, (char *)"no grammar has been specified");
  }
#line 163
  return;
}
}
#line 165 "/home/june/collector/temp/btyacc-3.0/error.c"
void terminal_lhs(int lineno___0 ) 
{ 


  {
  {
#line 166
  error(lineno___0, (char *)0, (char *)0, (char *)"a token appears on the lhs of a production");
  }
#line 167
  return;
}
}
#line 169 "/home/june/collector/temp/btyacc-3.0/error.c"
void prec_redeclared(void) 
{ 


  {
  {
#line 170
  error(lineno, (char *)0, (char *)0, (char *)"conflicting %%prec specifiers");
  }
#line 171
  return;
}
}
#line 173 "/home/june/collector/temp/btyacc-3.0/error.c"
void unterminated_action(int lineno___0 , char *line___0 , char *cptr___0 ) 
{ 


  {
  {
#line 174
  error(lineno___0, line___0, cptr___0, (char *)"unterminated action");
  }
#line 175
  return;
}
}
#line 177 "/home/june/collector/temp/btyacc-3.0/error.c"
void unterminated_arglist(int lineno___0 , char *line___0 , char *cptr___0 ) 
{ 


  {
  {
#line 178
  error(lineno___0, line___0, cptr___0, (char *)"unterminated argument list");
  }
#line 179
  return;
}
}
#line 181 "/home/june/collector/temp/btyacc-3.0/error.c"
void bad_formals(void) 
{ 


  {
  {
#line 182
  error(lineno, (char *)0, (char *)0, (char *)"bad formal argument list");
  }
#line 183
  return;
}
}
#line 185 "/home/june/collector/temp/btyacc-3.0/error.c"
void dollar_warning(int a_lineno , int i ) 
{ 
  int slineno ;

  {
  {
#line 186
  slineno = lineno;
#line 187
  lineno = a_lineno;
#line 188
  FileError((char *)"$%d references beyond the end of the current rule", i);
#line 189
  lineno = slineno;
  }
#line 190
  return;
}
}
#line 192 "/home/june/collector/temp/btyacc-3.0/error.c"
void dollar_error(int lineno___0 , char *line___0 , char *cptr___0 ) 
{ 


  {
  {
#line 193
  error(lineno___0, line___0, cptr___0, (char *)"illegal $-name");
  }
#line 194
  return;
}
}
#line 196 "/home/june/collector/temp/btyacc-3.0/error.c"
void untyped_lhs(void) 
{ 


  {
  {
#line 197
  error(lineno, (char *)0, (char *)0, (char *)"$$ is untyped");
  }
#line 198
  return;
}
}
#line 200 "/home/june/collector/temp/btyacc-3.0/error.c"
void untyped_rhs(int i , char *s ) 
{ 


  {
  {
#line 201
  error(lineno, (char *)0, (char *)0, (char *)"$%d (%s) is untyped", i, s);
  }
#line 202
  return;
}
}
#line 204 "/home/june/collector/temp/btyacc-3.0/error.c"
void unknown_rhs(int i ) 
{ 


  {
  {
#line 205
  error(lineno, (char *)0, (char *)0, (char *)"$%d is untyped (out of range)", i);
  }
#line 206
  return;
}
}
#line 208 "/home/june/collector/temp/btyacc-3.0/error.c"
void default_action_warning(void) 
{ 


  {
  {
#line 209
  FileError((char *)"the default action assigns an undefined value to $$");
  }
#line 210
  return;
}
}
#line 212 "/home/june/collector/temp/btyacc-3.0/error.c"
void undefined_goal(char *s ) 
{ 


  {
  {
#line 213
  error(lineno, (char *)0, (char *)0, (char *)"the start symbol %s is undefined",
        s);
  }
#line 214
  return;
}
}
#line 216 "/home/june/collector/temp/btyacc-3.0/error.c"
void undefined_symbol_warning(char *s ) 
{ 


  {
  {
#line 217
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"warning - the symbol %s is undefined\n",
          s);
  }
#line 218
  return;
}
}
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 622 "/usr/include/stdio.h"
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 202 "/home/june/collector/temp/btyacc-3.0/defs.h"
struct section section_list[6] ;
#line 7 "/home/june/collector/temp/btyacc-3.0/readskel.c"
static char *cp  ;
#line 7 "/home/june/collector/temp/btyacc-3.0/readskel.c"
static char *cp_end  ;
#line 8 "/home/june/collector/temp/btyacc-3.0/readskel.c"
static char **ap  ;
#line 8 "/home/june/collector/temp/btyacc-3.0/readskel.c"
static char **ap_end  ;
#line 8 "/home/june/collector/temp/btyacc-3.0/readskel.c"
static char **ap_start  ;
#line 10 "/home/june/collector/temp/btyacc-3.0/readskel.c"
static void add_ptr(char *p ) 
{ 
  int size ;
  char **nap ;
  void *tmp ;
  char **tmp___0 ;

  {
#line 12
  if ((unsigned long )ap == (unsigned long )ap_end) {
#line 13
    size = 8192;
    {
#line 15
    while (1) {
      while_continue: /* CIL Label */ ;
#line 15
      if (! ((unsigned long )(ap - ap_start) * sizeof(char *) >= (unsigned long )size)) {
#line 15
        goto while_break;
      }
#line 16
      size *= 2;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 17
    tmp = malloc((size_t )size);
#line 17
    nap = (char **)tmp;
    }
#line 17
    if (! nap) {
      {
#line 18
      no_space();
      }
    }
#line 19
    if ((unsigned long )ap > (unsigned long )ap_start) {
      {
#line 20
      memcpy((void */* __restrict  */)nap, (void const   */* __restrict  */)ap_start,
             (unsigned long )(ap - ap_start) * sizeof(char *));
      }
    }
#line 21
    ap = nap + (ap - ap_start);
#line 22
    ap_start = nap;
#line 23
    ap_end = nap + (unsigned long )size / sizeof(char *);
  }
#line 24
  tmp___0 = ap;
#line 24
  ap ++;
#line 24
  *tmp___0 = p;
#line 25
  return;
}
}
#line 27 "/home/june/collector/temp/btyacc-3.0/readskel.c"
static void add_string(char *s ) 
{ 
  int len ;
  size_t tmp ;
  int size ;
  int tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 29
  tmp = strlen((char const   *)s);
#line 29
  len = (int )(tmp + 1UL);
  }
#line 31
  if ((long )len > cp_end - cp) {
#line 32
    if (len > 8192) {
#line 32
      tmp___0 = len;
    } else {
#line 32
      tmp___0 = 8192;
    }
    {
#line 32
    size = tmp___0;
#line 33
    tmp___1 = malloc((size_t )size);
#line 33
    cp = (char *)tmp___1;
    }
#line 33
    if (! cp) {
      {
#line 34
      no_space();
      }
    }
#line 35
    cp_end = cp + size;
  }
  {
#line 36
  memcpy((void */* __restrict  */)cp, (void const   */* __restrict  */)s, (size_t )len);
#line 37
  add_ptr(cp);
#line 38
  cp += len;
  }
#line 39
  return;
}
}
#line 41 "/home/june/collector/temp/btyacc-3.0/readskel.c"
static void add_fmt(char *fmt  , ...) 
{ 
  va_list args ;
  char buf___0[256] ;

  {
  {
#line 46
  __builtin_va_start(args, fmt);
#line 47
  vsprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)fmt,
           args);
#line 48
  __builtin_va_end(args);
#line 49
  add_string(buf___0);
  }
#line 50
  return;
}
}
#line 52 "/home/june/collector/temp/btyacc-3.0/readskel.c"
static char **fin_section(void) 
{ 
  char **rv ;

  {
  {
#line 56
  add_ptr((char *)0);
#line 57
  rv = ap_start;
#line 58
  ap_start = ap;
  }
#line 59
  return (rv);
}
}
#line 62 "/home/june/collector/temp/btyacc-3.0/readskel.c"
void read_skel(char *name ) 
{ 
  char buf___0[256] ;
  int section ;
  int line___0 ;
  int sline ;
  int eline ;
  int i ;
  FILE *fp ;
  size_t tmp ;
  int tmp___0 ;
  char *p ;
  unsigned short const   **tmp___1 ;
  char *e ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 65
  section = -2;
#line 66
  line___0 = 0;
#line 66
  sline = 1;
#line 66
  eline = 1;
#line 70
  fp = fopen((char const   */* __restrict  */)name, (char const   */* __restrict  */)"r");
  }
#line 70
  if (! fp) {
    {
#line 71
    open_error(name);
    }
  }
  {
#line 72
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 72
    tmp___5 = fgets((char */* __restrict  */)(buf___0), 255, (FILE */* __restrict  */)fp);
    }
#line 72
    if (! tmp___5) {
#line 72
      goto while_break;
    }
#line 73
    sline = eline;
#line 73
    if (sline) {
#line 74
      line___0 ++;
    }
    {
#line 75
    tmp = strlen((char const   *)(buf___0));
#line 75
    i = (int )tmp;
    }
#line 75
    if (i == 0) {
#line 76
      goto while_continue;
    }
#line 77
    if ((int )buf___0[i - 1] == 10) {
#line 78
      i --;
#line 78
      buf___0[i] = (char)0;
#line 79
      eline = 1;
    } else {
#line 81
      tmp___0 = i;
#line 81
      i ++;
#line 81
      buf___0[tmp___0] = (char )'\\';
#line 82
      buf___0[i] = (char)0;
#line 83
      eline = 0;
    }
#line 85
    if (sline) {
#line 85
      if ((int )buf___0[0] == 37) {
#line 85
        if ((int )buf___0[1] == 37) {
#line 86
          p = buf___0 + 2;
#line 87
          if (section >= 0) {
            {
#line 88
            section_list[section].ptr = fin_section();
            }
          }
#line 90
          section = -1;
          {
#line 91
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 91
            if (*p) {
              {
#line 91
              tmp___1 = __ctype_b_loc();
              }
#line 91
              if (! ((int const   )*(*tmp___1 + (int )*p) & 8192)) {
#line 91
                goto while_break___0;
              }
            } else {
#line 91
              goto while_break___0;
            }
#line 91
            p ++;
          }
          while_break___0: /* CIL Label */ ;
          }
          {
#line 92
          tmp___4 = __ctype_b_loc();
          }
#line 92
          if ((int const   )*(*tmp___4 + (int )*p) & 1024) {
#line 93
            e = p;
            {
#line 94
            while (1) {
              while_continue___1: /* CIL Label */ ;
              {
#line 94
              tmp___2 = __ctype_b_loc();
#line 94
              e ++;
              }
#line 94
              if (! ((int const   )*(*tmp___2 + (int )*e) & 8)) {
#line 94
                goto while_break___1;
              }
            }
            while_break___1: /* CIL Label */ ;
            }
#line 95
            *e = (char)0;
#line 96
            i = 0;
            {
#line 96
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 96
              if (! section_list[i].name) {
#line 96
                goto while_break___2;
              }
              {
#line 97
              tmp___3 = strcmp((char const   *)section_list[i].name, (char const   *)p);
              }
#line 97
              if (! tmp___3) {
#line 98
                section = i;
              }
#line 96
              i ++;
            }
            while_break___2: /* CIL Label */ ;
            }
          }
#line 100
          if (section >= 0) {
            {
#line 101
            add_fmt((char *)"#line %d \"%s\"", line___0 + 1, name);
            }
          } else
#line 102
          if (*p) {
            {
#line 103
            error(0, buf___0, p, (char *)"line %d of \"%s\", bad section name", line___0,
                  name);
            }
          }
        } else {
#line 85
          goto _L___0;
        }
      } else {
#line 85
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 105
    if (section >= 0) {
      {
#line 106
      add_string(buf___0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 109
  if (section >= 0) {
    {
#line 110
    section_list[section].ptr = fin_section();
    }
  }
#line 111
  if (section == -2) {
    {
#line 112
    error(0, (char *)0, (char *)0, (char *)"No sections found in skeleton file \"%s\"",
          name);
    }
  }
#line 113
  return;
}
}
#line 278 "/home/june/collector/temp/btyacc-3.0/defs.h"
Yshort *accessing_symbol ;
#line 279
core **state_table ;
#line 280
shifts **shift_table ;
#line 289
action **parser ;
#line 290
int SRtotal ;
#line 291
int RRtotal ;
#line 292
Yshort *SRconflicts ;
#line 293
Yshort *RRconflicts ;
#line 294
Yshort *defred ;
#line 295
Yshort *rules_used ;
#line 296
Yshort nunused ;
#line 297
Yshort final_state ;
#line 503
void log_unused(void) ;
#line 504
void log_conflicts(void) ;
#line 505
void print_state(int state ) ;
#line 506
void print_conflicts(int state ) ;
#line 507
void print_core(int state ) ;
#line 508
void print_nulls(int state ) ;
#line 509
void print_actions(int stateno ) ;
#line 510
void print_shifts(action *p ) ;
#line 511
void print_reductions(action *p , int defred___0 ) ;
#line 512
void print_gotos(int stateno ) ;
#line 5 "/home/june/collector/temp/btyacc-3.0/verbose.c"
static Yshort *null_rules  ;
#line 7 "/home/june/collector/temp/btyacc-3.0/verbose.c"
void verbose(void) 
{ 
  register int i ;
  void *tmp ;

  {
#line 11
  if (! vflag) {
#line 11
    return;
  }
  {
#line 13
  tmp = malloc((size_t )((unsigned int )((unsigned long )nrules * sizeof(Yshort ))));
#line 13
  null_rules = (Yshort *)tmp;
  }
#line 14
  if ((unsigned long )null_rules == (unsigned long )((Yshort *)0)) {
    {
#line 14
    no_space();
    }
  }
  {
#line 15
  fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"\f\n");
#line 16
  i = 0;
  }
  {
#line 16
  while (1) {
    while_continue: /* CIL Label */ ;
#line 16
    if (! (i < nstates)) {
#line 16
      goto while_break;
    }
    {
#line 17
    print_state(i);
#line 16
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 18
  free((void *)((char *)null_rules));
  }
#line 20
  if (nunused) {
    {
#line 21
    log_unused();
    }
  }
#line 22
  if (SRtotal) {
    {
#line 23
    log_conflicts();
    }
  } else
#line 22
  if (RRtotal) {
    {
#line 23
    log_conflicts();
    }
  }
  {
#line 25
  fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"\n\n%d terminals, %d nonterminals\n",
          ntokens, nvars);
#line 27
  fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"%d grammar rules, %d states\n",
          nrules - 2, nstates);
  }
#line 28
  return;
}
}
#line 31 "/home/june/collector/temp/btyacc-3.0/verbose.c"
void log_unused(void) 
{ 
  register int i ;
  register Yshort *p ;

  {
  {
#line 36
  fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"\n\nRules never reduced:\n");
#line 37
  i = 3;
  }
  {
#line 37
  while (1) {
    while_continue: /* CIL Label */ ;
#line 37
    if (! (i < nrules)) {
#line 37
      goto while_break;
    }
#line 39
    if (! *(rules_used + i)) {
      {
#line 41
      fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"\t%s :",
              *(symbol_name + *(rlhs + i)));
#line 42
      p = ritem + *(rrhs + i);
      }
      {
#line 42
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 42
        if (! (*p >= 0)) {
#line 42
          goto while_break___0;
        }
        {
#line 43
        fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)" %s",
                *(symbol_name + *p));
#line 42
        p ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 44
      fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"  (%d)\n",
              i - 2);
      }
    }
#line 37
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 47
  return;
}
}
#line 50 "/home/june/collector/temp/btyacc-3.0/verbose.c"
void log_conflicts(void) 
{ 
  register int i ;

  {
  {
#line 54
  fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"\n\n");
#line 55
  i = 0;
  }
  {
#line 55
  while (1) {
    while_continue: /* CIL Label */ ;
#line 55
    if (! (i < nstates)) {
#line 55
      goto while_break;
    }
#line 57
    if (*(SRconflicts + i)) {
#line 57
      goto _L;
    } else
#line 57
    if (*(RRconflicts + i)) {
      _L: /* CIL Label */ 
      {
#line 59
      fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"State %d contains ",
              i);
      }
#line 60
      if (*(SRconflicts + i) == 1) {
        {
#line 61
        fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"1 shift/reduce conflict");
        }
      } else
#line 62
      if (*(SRconflicts + i) > 1) {
        {
#line 63
        fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"%d shift/reduce conflicts",
                *(SRconflicts + i));
        }
      }
#line 65
      if (*(SRconflicts + i)) {
#line 65
        if (*(RRconflicts + i)) {
          {
#line 66
          fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)", ");
          }
        }
      }
#line 67
      if (*(RRconflicts + i) == 1) {
        {
#line 68
        fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"1 reduce/reduce conflict");
        }
      } else
#line 69
      if (*(RRconflicts + i) > 1) {
        {
#line 70
        fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"%d reduce/reduce conflicts",
                *(RRconflicts + i));
        }
      }
      {
#line 72
      fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)".\n");
      }
    }
#line 55
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 75
  return;
}
}
#line 78 "/home/june/collector/temp/btyacc-3.0/verbose.c"
void print_state(int state ) 
{ 


  {
#line 80
  if (state) {
    {
#line 81
    fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"\n\n");
    }
  }
#line 82
  if (*(SRconflicts + state)) {
    {
#line 83
    print_conflicts(state);
    }
  } else
#line 82
  if (*(RRconflicts + state)) {
    {
#line 83
    print_conflicts(state);
    }
  }
  {
#line 84
  fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"state %d\n",
          state);
#line 85
  print_core(state);
#line 86
  print_nulls(state);
#line 87
  print_actions(state);
  }
#line 88
  return;
}
}
#line 91 "/home/june/collector/temp/btyacc-3.0/verbose.c"
void print_conflicts(int state ) 
{ 
  register int symbol ;
  register int act ;
  register int number ;
  register action *p ;

  {
#line 96
  number = -1;
#line 96
  act = number;
#line 96
  symbol = act;
#line 97
  p = *(parser + state);
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
#line 97
    if (! p) {
#line 97
      goto while_break;
    }
#line 99
    if ((int )p->suppressed == 2) {
#line 100
      goto __Cont;
    }
#line 102
    if (p->symbol != symbol) {
#line 104
      symbol = p->symbol;
#line 105
      number = p->number;
#line 106
      if ((int )p->action_code == 1) {
#line 107
        act = 1;
      } else {
#line 109
        act = 2;
      }
    } else
#line 111
    if ((int )p->suppressed == 1) {
#line 113
      if (state == final_state) {
#line 113
        if (symbol == 0) {
          {
#line 115
          fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"%d: shift/reduce conflict (accept, reduce %d) on $end\n",
                  state, p->number - 2);
          }
        } else {
#line 113
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 120
      if (act == 1) {
        {
#line 122
        fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"%d: shift/reduce conflict (shift %d, reduce %d) on %s\n",
                state, number, p->number - 2, *(symbol_name + symbol));
        }
      } else {
        {
#line 128
        fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"%d: reduce/reduce conflict (reduce %d, reduce %d) on %s\n",
                state, number - 2, p->number - 2, *(symbol_name + symbol));
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 97
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 135
  return;
}
}
#line 138 "/home/june/collector/temp/btyacc-3.0/verbose.c"
void print_core(int state ) 
{ 
  register int i ;
  register int k ;
  register int rule ;
  register core *statep ;
  register Yshort *sp ;
  register Yshort *sp1 ;

  {
#line 147
  statep = *(state_table + state);
#line 148
  k = statep->nitems;
#line 150
  i = 0;
  {
#line 150
  while (1) {
    while_continue: /* CIL Label */ ;
#line 150
    if (! (i < k)) {
#line 150
      goto while_break;
    }
#line 152
    sp = ritem + statep->items[i];
#line 152
    sp1 = sp;
    {
#line 154
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 154
      if (! (*sp >= 0)) {
#line 154
        goto while_break___0;
      }
#line 154
      sp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 155
    rule = - *sp;
#line 156
    fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"\t%s : ",
            *(symbol_name + *(rlhs + rule)));
#line 158
    sp = ritem + *(rrhs + rule);
    }
    {
#line 158
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 158
      if (! ((unsigned long )sp < (unsigned long )sp1)) {
#line 158
        goto while_break___1;
      }
      {
#line 159
      fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"%s ",
              *(symbol_name + *sp));
#line 158
      sp ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 161
    _IO_putc('.', verbose_file);
    }
    {
#line 163
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 163
      if (! (*sp >= 0)) {
#line 163
        goto while_break___2;
      }
      {
#line 165
      fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)" %s",
              *(symbol_name + *sp));
#line 166
      sp ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 168
    fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"  (%d)\n",
            -2 - *sp);
#line 150
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 170
  return;
}
}
#line 173 "/home/june/collector/temp/btyacc-3.0/verbose.c"
void print_nulls(int state ) 
{ 
  register action *p ;
  register int i ;
  register int j ;
  register int k ;
  register int nnulls ;

  {
#line 178
  nnulls = 0;
#line 179
  p = *(parser + state);
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 179
    if (! p) {
#line 179
      goto while_break;
    }
#line 181
    if ((int )p->action_code == 2) {
#line 181
      if ((int )p->suppressed == 0) {
#line 181
        goto _L;
      } else
#line 181
      if ((int )p->suppressed == 1) {
        _L: /* CIL Label */ 
#line 184
        i = p->number;
#line 185
        if (*(rrhs + i) + 1 == *(rrhs + (i + 1))) {
#line 187
          j = 0;
          {
#line 187
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 187
            if (j < nnulls) {
#line 187
              if (! (i > *(null_rules + j))) {
#line 187
                goto while_break___0;
              }
            } else {
#line 187
              goto while_break___0;
            }
#line 188
            goto __Cont;
            __Cont: /* CIL Label */ 
#line 187
            j ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 190
          if (j == nnulls) {
#line 192
            nnulls ++;
#line 193
            *(null_rules + j) = i;
          } else
#line 195
          if (i != *(null_rules + j)) {
#line 197
            nnulls ++;
#line 198
            k = nnulls - 1;
            {
#line 198
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 198
              if (! (k > j)) {
#line 198
                goto while_break___1;
              }
#line 199
              *(null_rules + k) = *(null_rules + (k - 1));
#line 198
              k --;
            }
            while_break___1: /* CIL Label */ ;
            }
#line 200
            *(null_rules + j) = i;
          }
        }
      }
    }
#line 179
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 206
  i = 0;
  {
#line 206
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 206
    if (! (i < nnulls)) {
#line 206
      goto while_break___2;
    }
    {
#line 208
    j = *(null_rules + i);
#line 209
    fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"\t%s : .  (%d)\n",
            *(symbol_name + *(rlhs + j)), j - 2);
#line 206
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 212
  fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"\n");
  }
#line 213
  return;
}
}
#line 216 "/home/june/collector/temp/btyacc-3.0/verbose.c"
void print_actions(int stateno ) 
{ 
  register action *p ;
  register shifts *sp ;
  register int as ;

  {
#line 222
  if (stateno == final_state) {
    {
#line 223
    fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"\t$end  accept\n");
    }
  }
#line 225
  p = *(parser + stateno);
#line 226
  if (p) {
    {
#line 228
    print_shifts(p);
#line 229
    print_reductions(p, *(defred + stateno));
    }
  }
#line 232
  sp = *(shift_table + stateno);
#line 233
  if (sp) {
#line 233
    if (sp->nshifts > 0) {
#line 235
      as = *(accessing_symbol + sp->shift[sp->nshifts - 1]);
#line 236
      if (as >= start_symbol) {
        {
#line 237
        print_gotos(stateno);
        }
      }
    }
  }
#line 239
  return;
}
}
#line 242 "/home/june/collector/temp/btyacc-3.0/verbose.c"
void print_shifts(action *p ) 
{ 
  register int count ;
  register action *q ;

  {
#line 247
  count = 0;
#line 248
  q = p;
  {
#line 248
  while (1) {
    while_continue: /* CIL Label */ ;
#line 248
    if (! q) {
#line 248
      goto while_break;
    }
#line 250
    if ((int )q->suppressed < 2) {
#line 250
      if ((int )q->action_code == 1) {
#line 251
        count ++;
      }
    }
#line 248
    q = q->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 254
  if (count > 0) {
    {
#line 256
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 256
      if (! p) {
#line 256
        goto while_break___0;
      }
#line 258
      if ((int )p->action_code == 1) {
#line 258
        if ((int )p->suppressed == 0) {
          {
#line 259
          fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"\t%s  shift %d\n",
                  *(symbol_name + p->symbol), p->number);
          }
        }
      }
#line 256
      p = p->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 263
  return;
}
}
#line 266 "/home/june/collector/temp/btyacc-3.0/verbose.c"
void print_reductions(action *p , int defred___0 ) 
{ 
  register int k ;
  register int anyreds ;
  register action *q ;

  {
#line 271
  anyreds = 0;
#line 272
  q = p;
  {
#line 272
  while (1) {
    while_continue: /* CIL Label */ ;
#line 272
    if (! q) {
#line 272
      goto while_break;
    }
#line 274
    if ((int )q->action_code == 2) {
#line 274
      if ((int )q->suppressed < 2) {
#line 276
        anyreds = 1;
#line 277
        goto while_break;
      }
    }
#line 272
    q = q->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 281
  if (anyreds == 0) {
    {
#line 282
    fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"\t.  error\n");
    }
  } else {
    {
#line 285
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 285
      if (! p) {
#line 285
        goto while_break___0;
      }
#line 287
      if ((int )p->action_code == 2) {
#line 287
        if (p->number != defred___0) {
#line 289
          k = p->number - 2;
#line 290
          if ((int )p->suppressed == 0) {
            {
#line 291
            fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"\t%s  reduce %d\n",
                    *(symbol_name + p->symbol), k);
            }
          }
        }
      }
#line 285
      p = p->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 296
    if (defred___0 > 0) {
      {
#line 297
      fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"\t.  reduce %d\n",
              defred___0 - 2);
      }
    }
  }
#line 299
  return;
}
}
#line 302 "/home/june/collector/temp/btyacc-3.0/verbose.c"
void print_gotos(int stateno ) 
{ 
  register int i ;
  register int k ;
  register int as ;
  register Yshort *to_state___0 ;
  register shifts *sp ;

  {
  {
#line 309
  _IO_putc('\n', verbose_file);
#line 310
  sp = *(shift_table + stateno);
#line 311
  to_state___0 = sp->shift;
#line 312
  i = 0;
  }
  {
#line 312
  while (1) {
    while_continue: /* CIL Label */ ;
#line 312
    if (! (i < sp->nshifts)) {
#line 312
      goto while_break;
    }
#line 314
    k = *(to_state___0 + i);
#line 315
    as = *(accessing_symbol + k);
#line 316
    if (as >= start_symbol) {
      {
#line 317
      fprintf((FILE */* __restrict  */)verbose_file, (char const   */* __restrict  */)"\t%s  goto %d\n",
              *(symbol_name + as), k);
      }
    }
#line 312
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 319
  return;
}
}
#line 515 "/home/june/collector/temp/btyacc-3.0/defs.h"
void transitive_closure(unsigned int *R___0 , int n ) ;
#line 516
void reflexive_transitive_closure(unsigned int *R___0 , int n ) ;
#line 3 "/home/june/collector/temp/btyacc-3.0/warshall.c"
void transitive_closure(unsigned int *R___0 , int n ) 
{ 
  register int rowsize ;
  register unsigned int mask ;
  register unsigned int *rowj ;
  register unsigned int *rp ;
  register unsigned int *rend ;
  register unsigned int *ccol ;
  register unsigned int *relend ;
  register unsigned int *cword ;
  register unsigned int *rowi ;
  unsigned int *tmp ;
  unsigned int *tmp___0 ;

  {
#line 15
  rowsize = (n + 31) / 32;
#line 16
  relend = R___0 + n * rowsize;
#line 18
  cword = R___0;
#line 19
  mask = 1U;
#line 20
  rowi = R___0;
  {
#line 21
  while (1) {
    while_continue: /* CIL Label */ ;
#line 21
    if (! ((unsigned long )rowi < (unsigned long )relend)) {
#line 21
      goto while_break;
    }
#line 23
    ccol = cword;
#line 24
    rowj = R___0;
    {
#line 26
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 26
      if (! ((unsigned long )rowj < (unsigned long )relend)) {
#line 26
        goto while_break___0;
      }
#line 28
      if (*ccol & mask) {
#line 30
        rp = rowi;
#line 31
        rend = rowj + rowsize;
        {
#line 32
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 32
          if (! ((unsigned long )rowj < (unsigned long )rend)) {
#line 32
            goto while_break___1;
          }
#line 33
          tmp = rowj;
#line 33
          rowj ++;
#line 33
          tmp___0 = rp;
#line 33
          rp ++;
#line 33
          *tmp |= *tmp___0;
        }
        while_break___1: /* CIL Label */ ;
        }
      } else {
#line 37
        rowj += rowsize;
      }
#line 40
      ccol += rowsize;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 43
    mask <<= 1;
#line 44
    if (mask == 0U) {
#line 46
      mask = 1U;
#line 47
      cword ++;
    }
#line 50
    rowi += rowsize;
  }
  while_break: /* CIL Label */ ;
  }
#line 52
  return;
}
}
#line 54 "/home/june/collector/temp/btyacc-3.0/warshall.c"
void reflexive_transitive_closure(unsigned int *R___0 , int n ) 
{ 
  register int rowsize ;
  register unsigned int mask ;
  register unsigned int *rp ;
  register unsigned int *relend ;

  {
  {
#line 61
  transitive_closure(R___0, n);
#line 63
  rowsize = (n + 31) / 32;
#line 64
  relend = R___0 + n * rowsize;
#line 66
  mask = 1U;
#line 67
  rp = R___0;
  }
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
#line 68
    if (! ((unsigned long )rp < (unsigned long )relend)) {
#line 68
      goto while_break;
    }
#line 70
    *rp |= mask;
#line 71
    mask <<= 1;
#line 72
    if (mask == 0U) {
#line 74
      mask = 1U;
#line 75
      rp ++;
    }
#line 78
    rp += rowsize;
  }
  while_break: /* CIL Label */ ;
  }
#line 80
  return;
}
}
#line 219 "/home/june/collector/temp/btyacc-3.0/defs.h"
char *banner[14] ;
#line 220
char *tables[22] ;
#line 221
char *header[145] ;
#line 222
char *body[388] ;
#line 223
char *trailer[260] ;
#line 12 "/home/june/collector/temp/btyacc-3.0/skeleton.c"
char *banner[14]  = 
#line 12 "/home/june/collector/temp/btyacc-3.0/skeleton.c"
  {      (char *)"#line 8 \"btyaccpa.ske\"",      (char *)"",      (char *)"//",      (char *)"// @(#)btyaccpar, based on byacc 1.8 (Berkeley)", 
        (char *)"//",      (char *)"#define YYBTYACC 1",      (char *)"",      (char *)"#include <stdio.h>", 
        (char *)"#include <stdlib.h>",      (char *)"#include <string.h>",      (char *)"",      (char *)"typedef int Yshort;", 
        (char *)"",      (char *)0};
#line 30 "/home/june/collector/temp/btyacc-3.0/skeleton.c"
char *tables[22]  = 
#line 30
  {      (char *)"#line 21 \"btyaccpa.ske\"",      (char *)"",      (char *)"#define _C_ \"C\"",      (char *)"", 
        (char *)"extern _C_ Yshort yylhs[];",      (char *)"extern _C_ Yshort yylen[];",      (char *)"extern _C_ Yshort yydefred[];",      (char *)"extern _C_ Yshort yydgoto[];", 
        (char *)"extern _C_ Yshort yysindex[];",      (char *)"extern _C_ Yshort yyrindex[];",      (char *)"extern _C_ Yshort yycindex[];",      (char *)"extern _C_ Yshort yygindex[];", 
        (char *)"extern _C_ Yshort yytable[];",      (char *)"extern _C_ Yshort yycheck[];",      (char *)"extern _C_ Yshort yyctable[];",      (char *)"", 
        (char *)"#if YYDEBUG",      (char *)"extern _C_ char *yyname[];",      (char *)"extern _C_ char *yyrule[];",      (char *)"#endif", 
        (char *)"",      (char *)0};
#line 56 "/home/june/collector/temp/btyacc-3.0/skeleton.c"
char *header[145]  = 
#line 56
  {      (char *)"#line 42 \"btyaccpa.ske\"",      (char *)"",      (char *)"//",      (char *)"// YYPOSN is user-defined text position type.", 
        (char *)"//",      (char *)"#ifndef YYPOSN",      (char *)"#define YYPOSN int",      (char *)"#endif", 
        (char *)"",      (char *)"#ifdef YYREDUCEPOSNFUNC",      (char *)"#define YYCALLREDUCEPOSN(e)   \\",      (char *)"\tif(reduce_posn) {     \\", 
        (char *)"\t  YYREDUCEPOSNFUNC(yyps->pos, &(yyps->psp)[1-yym], &(yyps->vsp)[1-yym], \\",      (char *)"\t\t\t   yym, yyps->psp - yyps->ps, yychar, yyposn, e);       \\",      (char *)"\t  reduce_posn = 0;    \\",      (char *)"\t}", 
        (char *)"",      (char *)"#ifndef YYCALLREDUCEPOSNARG",      (char *)"#define YYCALLREDUCEPOSNARG yyps->val",      (char *)"#endif", 
        (char *)"",      (char *)"",      (char *)"#define YYPOSNARG(n) ((yyps->psp)[1-yym+(n)-1])",      (char *)"#define YYPOSNOUT    (yyps->pos)", 
        (char *)"#endif",      (char *)"",      (char *)"/* If delete function is not defined by the user, do not delete. */",      (char *)"#ifndef YYDELETEVAL", 
        (char *)"#  define YYDELETEVAL(v, t) ",      (char *)"#endif",      (char *)"",      (char *)"/* If delete function is not defined by the user, do not delete. */", 
        (char *)"#ifndef YYDELETEPOSN",      (char *)"#  define YYDELETEPOSN(v, t) ",      (char *)"#endif",      (char *)"", 
        (char *)"#define yyclearin (yychar=(-1))",      (char *)"",      (char *)"#define yyerrok (yyps->errflag=0)",      (char *)"", 
        (char *)"#ifndef YYSTACKGROWTH",      (char *)"#define YYSTACKGROWTH 16",      (char *)"#endif",      (char *)"", 
        (char *)"#ifndef YYDEFSTACKSIZE",      (char *)"#define YYDEFSTACKSIZE 12",      (char *)"#endif",      (char *)"", 
        (char *)"#ifdef YYDEBUG",      (char *)"int yydebug;",      (char *)"#endif",      (char *)"", 
        (char *)"int yynerrs;",      (char *)"",      (char *)"/* These value/posn are taken from the lexer */",      (char *)"YYSTYPE yylval;", 
        (char *)"YYPOSN  yyposn;",      (char *)"",      (char *)"/* These value/posn of the root non-terminal are returned to the caller */",      (char *)"YYSTYPE yyretlval;", 
        (char *)"YYPOSN  yyretposn;",      (char *)"",      (char *)"#define YYABORT  goto yyabort",      (char *)"#define YYACCEPT goto yyaccept", 
        (char *)"#define YYERROR  goto yyerrlab",      (char *)"#define YYVALID         do { if (yyps->save)          goto yyvalid; } while(0)",      (char *)"#define YYVALID_NESTED  do { if (yyps->save && \\",      (char *)"                                 yyps->save->save==0) goto yyvalid; } while(0)", 
        (char *)"",      (char *)"struct yyparsestate {",      (char *)"  yyparsestate *save;        // Previously saved parser state",      (char *)"  int           state;", 
        (char *)"  int           errflag;",      (char *)"  Yshort       *ssp;         // state stack pointer",      (char *)"  YYSTYPE      *vsp;         // value stack pointer",      (char *)"  YYPOSN       *psp;         // position stack pointer", 
        (char *)"  YYSTYPE       val;         // value as returned by actions",      (char *)"  YYPOSN        pos;         // position as returned by universal action",      (char *)"  Yshort       *ss;          // state stack base",      (char *)"  YYSTYPE      *vs;          // values stack base", 
        (char *)"  YYPOSN       *ps;          // position stack base",      (char *)"  int           lexeme;      // index of the conflict lexeme in the lexical queue",      (char *)"  unsigned int  stacksize;   // current maximum stack size",      (char *)"  Yshort        ctry;        // index in yyctable[] for this conflict", 
        (char *)"};",      (char *)"",      (char *)"// Current parser state",      (char *)"static yyparsestate *yyps=0;", 
        (char *)"",      (char *)"// yypath!=NULL: do the full parse, starting at *yypath parser state.",      (char *)"static yyparsestate *yypath=0;",      (char *)"", 
        (char *)"// Base of the lexical value queue",      (char *)"static YYSTYPE *yylvals=0;",      (char *)"",      (char *)"// Current posistion at lexical value queue", 
        (char *)"static YYSTYPE *yylvp=0;",      (char *)"",      (char *)"// End position of lexical value queue",      (char *)"static YYSTYPE *yylve=0;", 
        (char *)"",      (char *)"// The last allocated position at the lexical value queue",      (char *)"static YYSTYPE *yylvlim=0;",      (char *)"", 
        (char *)"// Base of the lexical position queue",      (char *)"static YYPOSN *yylpsns=0;",      (char *)"",      (char *)"// Current posistion at lexical position queue", 
        (char *)"static YYPOSN *yylpp=0;",      (char *)"",      (char *)"// End position of lexical position queue",      (char *)"static YYPOSN *yylpe=0;", 
        (char *)"",      (char *)"// The last allocated position at the lexical position queue",      (char *)"static YYPOSN *yylplim=0;",      (char *)"", 
        (char *)"// Current position at lexical token queue",      (char *)"static Yshort *yylexp=0;",      (char *)"",      (char *)"static Yshort *yylexemes=0;", 
        (char *)"",      (char *)"//",      (char *)"// For use in generated program",      (char *)"//", 
        (char *)"#define yytrial (yyps->save)",      (char *)"#define yyvsp   (yyps->vsp)",      (char *)"#define yyval   (yyps->val)",      (char *)"#define yydepth (yyps->ssp - yyps->ss)", 
        (char *)"",      (char *)"",      (char *)"//",      (char *)"// Local prototypes.", 
        (char *)"//",      (char *)"int yyparse(void);",      (char *)"",      (char *)"int  YYLex1();", 
        (char *)"int  yyexpand();",      (char *)"void YYSCopy(YYSTYPE *to, YYSTYPE *from, int size);",      (char *)"void YYPCopy(YYPOSN  *to, YYPOSN  *from, int size);",      (char *)"void YYMoreStack(yyparsestate *yyps);", 
        (char *)"yyparsestate *YYNewState(int size);",      (char *)"void YYFreeState(yyparsestate *p);",      (char *)"",      (char *)"", 
        (char *)0};
#line 205 "/home/june/collector/temp/btyacc-3.0/skeleton.c"
char *body[388]  = 
#line 205
  {      (char *)"#line 186 \"btyaccpa.ske\"",      (char *)"",      (char *)"",      (char *)"//", 
        (char *)"// Parser function",      (char *)"//",      (char *)"int yyparse() {",      (char *)"  int yym, yyn, yystate, yychar, yynewerrflag;", 
        (char *)"  yyparsestate *yyerrctx = NULL;",      (char *)"  int reduce_posn;",      (char *)"",      (char *)"#if YYDEBUG", 
        (char *)"  char *yys;",      (char *)"  ",      (char *)"  if ((yys = getenv(\"YYDEBUG\"))) {",      (char *)"    yyn = *yys;", 
        (char *)"    if (yyn >= \'0\' && yyn <= \'9\')",      (char *)"      yydebug = yyn - \'0\'; ",      (char *)"  }",      (char *)"#endif", 
        (char *)"  ",      (char *)"  yyps = YYNewState(YYDEFSTACKSIZE);",      (char *)"  yyps->save = 0;",      (char *)"  yynerrs = 0;", 
        (char *)"  yyps->errflag = 0;",      (char *)"  yychar = (-1);",      (char *)"  ",      (char *)"  yyps->ssp = yyps->ss;", 
        (char *)"  yyps->vsp = yyps->vs;",      (char *)"  yyps->psp = yyps->ps;",      (char *)"  *(yyps->ssp) = yystate = 0;",      (char *)"  ", 
        (char *)"",      (char *)"  //",      (char *)"  // Main parsing loop",      (char *)"  //", 
        (char *)" yyloop:",      (char *)"  if ((yyn = yydefred[yystate])) {",      (char *)"    goto yyreduce;",      (char *)"  }", 
        (char *)"",      (char *)"  //",      (char *)"  // Read one token",      (char *)"  //", 
        (char *)"  if (yychar < 0) {",      (char *)"    if ((yychar = YYLex1()) < 0) yychar = 0;",      (char *)"#if YYDEBUG",      (char *)"    if (yydebug) {", 
        (char *)"      yys = 0;",      (char *)"      if (yychar <= YYMAXTOKEN) yys = yyname[yychar];",      (char *)"      if (!yys) yys = \"illegal-symbol\";",      (char *)"      printf(\"yydebug[%d,%d]: state %d, reading %d (%s)\", ", 
        (char *)"\t     yydepth, (int)yytrial, yystate, yychar, yys);",      (char *)"#ifdef YYDBPR",      (char *)"      printf(\"<\");",      (char *)"      YYDBPR(yylval);", 
        (char *)"      printf(\">\");",      (char *)"#endif",      (char *)"      printf(\"\\n\"); ",      (char *)"    }", 
        (char *)"#endif",      (char *)"  }",      (char *)"",      (char *)"  //", 
        (char *)"  // Do we have a conflict?",      (char *)"  //",      (char *)"  if ((yyn = yycindex[yystate]) &&",      (char *)"      (yyn += yychar) >= 0 &&", 
        (char *)"      yyn <= YYTABLESIZE &&",      (char *)"      yycheck[yyn] == yychar) {",      (char *)"    int ctry;",      (char *)"", 
        (char *)"    if (yypath) {",      (char *)"#if YYDEBUG",      (char *)"      if (yydebug) {",      (char *)"        printf(\"yydebug[%d,%d]: CONFLICT in state %d: following successful trial parse\\n\", ", 
        (char *)"\t       yydepth, (int)yytrial, yystate);",      (char *)"      }",      (char *)"#endif",      (char *)"      // Switch to the next conflict context", 
        (char *)"      yyparsestate *save = yypath;",      (char *)"      yypath = save->save;",      (char *)"      ctry = save->ctry;",      (char *)"      if (save->state != yystate) ", 
        (char *)"        goto yyabort;",      (char *)"      YYFreeState(save); ",      (char *)"",      (char *)"    } else {", 
        (char *)"",      (char *)"#if YYDEBUG",      (char *)"      if (yydebug) {",      (char *)"        printf(\"yydebug[%d,%d]: CONFLICT in state %d. \", ", 
        (char *)"\t       yydepth, (int)yytrial, yystate);",      (char *)"        if(yyps->save) {",      (char *)"          printf(\"ALREADY in conflict. Continue trial parse.\");",      (char *)"        } else {", 
        (char *)"          printf(\"Start trial parse.\");",      (char *)"        }",      (char *)"        printf(\"\\n\");",      (char *)"      }", 
        (char *)"#endif",      (char *)"      yyparsestate *save = YYNewState(yyps->ssp - yyps->ss);",      (char *)"      save->save    = yyps->save;",      (char *)"      save->state   = yystate;", 
        (char *)"      save->errflag = yyps->errflag;",      (char *)"      save->ssp     = save->ss + (yyps->ssp - yyps->ss);",      (char *)"      save->vsp     = save->vs + (yyps->vsp - yyps->vs);",      (char *)"      save->psp     = save->ps + (yyps->psp - yyps->ps);", 
        (char *)"      memcpy (save->ss, yyps->ss, (yyps->ssp - yyps->ss + 1)*sizeof(Yshort));",      (char *)"      YYSCopy(save->vs, yyps->vs, (yyps->ssp - yyps->ss + 1));",      (char *)"      YYPCopy(save->ps, yyps->ps, (yyps->ssp - yyps->ss + 1));",      (char *)"      ctry = yytable[yyn];", 
        (char *)"      if (yyctable[ctry] == -1) {",      (char *)"#if YYDEBUG",      (char *)"        if (yydebug && yychar >= 0)",      (char *)"          printf(\"yydebug[%d]: backtracking 1 token\\n\", ", 
        (char *)"\t\t (int)yytrial);",      (char *)"#endif",      (char *)"        ctry++; ",      (char *)"      }", 
        (char *)"      save->ctry = ctry;",      (char *)"      if (!yyps->save) {",      (char *)"        // If this is a first conflict in the stack, start saving lexemes",      (char *)"        if (!yylexemes) {", 
        (char *)"          yylexemes = new Yshort[YYSTACKGROWTH];",      (char *)"          yylvals = new YYSTYPE[YYSTACKGROWTH];",      (char *)"          yylvlim = yylvals + YYSTACKGROWTH; ",      (char *)"          yylpsns = new YYPOSN[YYSTACKGROWTH];", 
        (char *)"          yylplim = yylpsns + YYSTACKGROWTH; ",      (char *)"        }",      (char *)"        if (yylvp == yylve) {",      (char *)"          yylvp = yylve = yylvals;", 
        (char *)"\t  yylpp = yylpe = yylpsns;",      (char *)"          yylexp = yylexemes;",      (char *)"          if (yychar >= 0) {",      (char *)"            *yylve++ = yylval;", 
        (char *)"            *yylpe++ = yyposn;",      (char *)"            *yylexp = yychar;",      (char *)"            yychar = -1; ",      (char *)"          } ", 
        (char *)"        } ",      (char *)"      }",      (char *)"      if (yychar >= 0) {",      (char *)"        yylvp--, yylpp--, yylexp--;", 
        (char *)"        yychar = -1; ",      (char *)"      }",      (char *)"      save->lexeme = yylvp - yylvals;",      (char *)"      yyps->save = save; ", 
        (char *)"    }",      (char *)"    if (yytable[yyn] == ctry) {",      (char *)"#if YYDEBUG",      (char *)"      if (yydebug)", 
        (char *)"        printf(\"yydebug[%d,%d]: state %d, shifting to state %d\\n\",",      (char *)"               yydepth, (int)yytrial, yystate, yyctable[ctry]);",      (char *)"#endif",      (char *)"      if (yychar < 0)", 
        (char *)"        yylvp++, yylpp++, yylexp++;",      (char *)"      yychar = -1;",      (char *)"      if (yyps->errflag > 0) --yyps->errflag;",      (char *)"      yystate = yyctable[ctry];", 
        (char *)"      goto yyshift; ",      (char *)"    } else {",      (char *)"      yyn = yyctable[ctry];",      (char *)"      goto yyreduce; ", 
        (char *)"    } ",      (char *)"  }",      (char *)"",      (char *)"  //", 
        (char *)"  // Is action a shift?",      (char *)"  //",      (char *)"  if ((yyn = yysindex[yystate]) &&",      (char *)"      (yyn += yychar) >= 0 &&", 
        (char *)"      yyn <= YYTABLESIZE &&",      (char *)"      yycheck[yyn] == yychar) {",      (char *)"#if YYDEBUG",      (char *)"    if (yydebug)", 
        (char *)"      printf(\"yydebug[%d,%d]: state %d, shifting to state %d\\n\",",      (char *)"             yydepth, (int)yytrial, yystate, yytable[yyn]);",      (char *)"#endif",      (char *)"    yychar = (-1);", 
        (char *)"    if (yyps->errflag > 0)  --yyps->errflag;",      (char *)"    yystate = yytable[yyn];",      (char *)"  yyshift:",      (char *)"    if (yyps->ssp >= yyps->ss + yyps->stacksize - 1) {", 
        (char *)"      YYMoreStack(yyps);",      (char *)"    }",      (char *)"    *++(yyps->ssp) = yystate;",      (char *)"    *++(yyps->vsp) = yylval;", 
        (char *)"    *++(yyps->psp) = yyposn;",      (char *)"    goto yyloop;",      (char *)"  }",      (char *)"  if ((yyn = yyrindex[yystate]) &&", 
        (char *)"      (yyn += yychar) >= 0 &&",      (char *)"      yyn <= YYTABLESIZE &&",      (char *)"      yycheck[yyn] == yychar) {",      (char *)"    yyn = yytable[yyn];", 
        (char *)"    goto yyreduce;",      (char *)"  }",      (char *)"",      (char *)"  //", 
        (char *)"  // Action: error",      (char *)"  //",      (char *)"  if (yyps->errflag) goto yyinrecovery;",      (char *)"  yynewerrflag = 1;", 
        (char *)"  goto yyerrhandler;",      (char *)"yyerrlab:",      (char *)"  yynewerrflag = 0;",      (char *)"yyerrhandler:", 
        (char *)"  while (yyps->save) { ",      (char *)"    int ctry; ",      (char *)"    yyparsestate *save = yyps->save;",      (char *)"#if YYDEBUG", 
        (char *)"    if (yydebug)",      (char *)"      printf(\"yydebug[%d,%d]: ERROR in state %d, CONFLICT BACKTRACKING to state %d, %d tokens\\n\",",      (char *)"             yydepth, (int)yytrial, yystate, yyps->save->state, yylvp - yylvals - yyps->save->lexeme);",      (char *)"#endif", 
        (char *)"    // Memorize most forward-looking error state in case",      (char *)"    // it\'s really an error.",      (char *)"    if(yyerrctx==NULL || yyerrctx->lexeme<yylvp-yylvals) {",      (char *)"      // Free old saved error context state", 
        (char *)"      if(yyerrctx) YYFreeState(yyerrctx);",      (char *)"      // Create and fill out new saved error context state",      (char *)"      yyerrctx = YYNewState(yyps->ssp - yyps->ss);",      (char *)"      yyerrctx->save = yyps->save;", 
        (char *)"      yyerrctx->state = yystate;",      (char *)"      yyerrctx->errflag = yyps->errflag;",      (char *)"      yyerrctx->ssp = yyerrctx->ss + (yyps->ssp - yyps->ss);",      (char *)"      yyerrctx->vsp = yyerrctx->vs + (yyps->vsp - yyps->vs);", 
        (char *)"      yyerrctx->psp = yyerrctx->ps + (yyps->psp - yyps->ps);",      (char *)"      memcpy (yyerrctx->ss, yyps->ss, (yyps->ssp - yyps->ss + 1)*sizeof(Yshort));",      (char *)"      YYSCopy(yyerrctx->vs, yyps->vs, (yyps->ssp - yyps->ss + 1));",      (char *)"      YYPCopy(yyerrctx->ps, yyps->ps, (yyps->ssp - yyps->ss + 1));", 
        (char *)"      yyerrctx->lexeme = yylvp - yylvals;",      (char *)"    }",      (char *)"    yylvp  = yylvals   + save->lexeme;",      (char *)"    yylpp  = yylpsns   + save->lexeme;", 
        (char *)"    yylexp = yylexemes + save->lexeme;",      (char *)"    yychar = -1;",      (char *)"    yyps->ssp = yyps->ss + (save->ssp - save->ss);",      (char *)"    yyps->vsp = yyps->vs + (save->vsp - save->vs);", 
        (char *)"    yyps->psp = yyps->ps + (save->psp - save->ps);",      (char *)"    memcpy (yyps->ss, save->ss, (yyps->ssp - yyps->ss + 1) * sizeof(Yshort));",      (char *)"    YYSCopy(yyps->vs, save->vs,  yyps->vsp - yyps->vs + 1);",      (char *)"    YYPCopy(yyps->ps, save->ps,  yyps->psp - yyps->ps + 1);", 
        (char *)"    ctry = ++save->ctry;",      (char *)"    yystate = save->state;",      (char *)"    // We tried shift, try reduce now",      (char *)"    if ((yyn = yyctable[ctry]) >= 0) {", 
        (char *)"      goto yyreduce;",      (char *)"    }",      (char *)"    yyps->save = save->save;",      (char *)"    YYFreeState(save);", 
        (char *)"    //",      (char *)"    // Nothing left on the stack -- error",      (char *)"    //",      (char *)"    if (!yyps->save) {", 
        (char *)"#if YYDEBUG",      (char *)"      if (yydebug) {",      (char *)"        printf(\"yydebug[%d]: trial parse FAILED, entering ERROR mode\\n\", ",      (char *)"\t       (int)yytrial);", 
        (char *)"      }",      (char *)"#endif",      (char *)"      // Restore state as it was in the most forward-advanced error",      (char *)"      yylvp  = yylvals   + yyerrctx->lexeme;", 
        (char *)"      yylpp  = yylpsns   + yyerrctx->lexeme;",      (char *)"      yylexp = yylexemes + yyerrctx->lexeme;",      (char *)"      yychar = yylexp[-1];",      (char *)"      yylval = yylvp[-1];", 
        (char *)"      yyposn = yylpp[-1];",      (char *)"      yyps->ssp = yyps->ss + (yyerrctx->ssp - yyerrctx->ss);",      (char *)"      yyps->vsp = yyps->vs + (yyerrctx->vsp - yyerrctx->vs);",      (char *)"      yyps->psp = yyps->ps + (yyerrctx->psp - yyerrctx->ps);", 
        (char *)"      memcpy (yyps->ss, yyerrctx->ss, (yyps->ssp - yyps->ss + 1) * sizeof(Yshort));",      (char *)"      YYSCopy(yyps->vs, yyerrctx->vs,  yyps->vsp - yyps->vs + 1);",      (char *)"      YYPCopy(yyps->ps, yyerrctx->ps,  yyps->psp - yyps->ps + 1);",      (char *)"      yystate = yyerrctx->state;", 
        (char *)"      YYFreeState(yyerrctx);",      (char *)"      yyerrctx = NULL;",      (char *)"    }",      (char *)"    yynewerrflag = 1; ", 
        (char *)"  }",      (char *)"  if (yynewerrflag) {",      (char *)"#ifdef YYERROR_DETAILED",      (char *)"    yyerror_detailed(\"syntax error\", yychar, yylval, yyposn);", 
        (char *)"#else",      (char *)"    yyerror(\"syntax error\");",      (char *)"#endif",      (char *)"  }", 
        (char *)"  ++yynerrs;",      (char *)" yyinrecovery:",      (char *)"  if (yyps->errflag < 3) {",      (char *)"    yyps->errflag = 3;", 
        (char *)"    for (;;) {",      (char *)"      if ((yyn = yysindex[*(yyps->ssp)]) && ",      (char *)"\t  (yyn += YYERRCODE) >= 0 &&",      (char *)"          yyn <= YYTABLESIZE && ", 
        (char *)"\t  yycheck[yyn] == YYERRCODE) {",      (char *)"#if YYDEBUG",      (char *)"        if (yydebug)",      (char *)"          printf(\"yydebug[%d,%d]: state %d, ERROR recovery shifts to state %d\\n\",", 
        (char *)"                 yydepth, (int)yytrial, *(yyps->ssp), yytable[yyn]);",      (char *)"#endif",      (char *)"        /* Use label yyerrlab, so that compiler does not warn */",      (char *)"        if(yyps->errflag != yyps->errflag) goto yyerrlab;", 
        (char *)"        yystate = yytable[yyn];",      (char *)"        goto yyshift; ",      (char *)"      } else {",      (char *)"#if YYDEBUG", 
        (char *)"        if (yydebug)",      (char *)"          printf(\"yydebug[%d,%d]: ERROR recovery discards state %d\\n\",",      (char *)"                 yydepth, (int)yytrial, *(yyps->ssp));",      (char *)"#endif", 
        (char *)"        if (yyps->ssp <= yyps->ss) {",      (char *)"\t  goto yyabort;",      (char *)"\t}",      (char *)"\tif(!yytrial) {", 
        (char *)"\t  YYDELETEVAL(yyps->vsp[0],1);",      (char *)"\t  YYDELETEPOSN(yyps->psp[0],1);",      (char *)"\t}",      (char *)"        --(yyps->ssp);", 
        (char *)"        --(yyps->vsp);",      (char *)"        --(yyps->psp);",      (char *)"      }",      (char *)"    }", 
        (char *)"  } else {",      (char *)"    if (yychar == 0) goto yyabort;",      (char *)"#if YYDEBUG",      (char *)"    if (yydebug) {", 
        (char *)"      yys = 0;",      (char *)"      if (yychar <= YYMAXTOKEN) yys = yyname[yychar];",      (char *)"      if (!yys) yys = \"illegal-symbol\";",      (char *)"      printf(\"yydebug[%d,%d]: state %d, ERROR recovery discards token %d (%s)\\n\",", 
        (char *)"             yydepth, (int)yytrial, yystate, yychar, yys); ",      (char *)"    }",      (char *)"#endif",      (char *)"    if(!yytrial) {", 
        (char *)"      YYDELETEVAL(yylval,0);",      (char *)"      YYDELETEPOSN(yyposn,0);",      (char *)"    }",      (char *)"    yychar = (-1);", 
        (char *)"    goto yyloop;",      (char *)"  }",      (char *)"",      (char *)"  //", 
        (char *)"  // Reduce the rule",      (char *)"  //",      (char *)"yyreduce:",      (char *)"  yym = yylen[yyn];", 
        (char *)"#if YYDEBUG",      (char *)"  if (yydebug) {",      (char *)"    printf(\"yydebug[%d,%d]: state %d, reducing by rule %d (%s)\",",      (char *)"           yydepth, (int)yytrial, yystate, yyn, yyrule[yyn]);", 
        (char *)"#ifdef YYDBPR",      (char *)"    if (yym) {",      (char *)"      int i;",      (char *)"      printf(\"<\");", 
        (char *)"      for (i=yym; i>0; i--) {",      (char *)"        if (i!=yym) printf(\", \");",      (char *)"        YYDBPR((yyps->vsp)[1-i]);",      (char *)"      }", 
        (char *)"      printf(\">\");",      (char *)"    }",      (char *)"#endif",      (char *)"    printf(\"\\n\");", 
        (char *)"  }",      (char *)"#endif",      (char *)"  if (yyps->ssp + 1 - yym >= yyps->ss + yyps->stacksize) {",      (char *)"    YYMoreStack(yyps);", 
        (char *)"  }",      (char *)"",      (char *)"# ifdef _YACC_DEFAULT_ACTION_",      (char *)"  /* \"$$ = NULL\" default action */", 
        (char *)"  memset(&yyps->val, 0, sizeof(yyps->val));",      (char *)"# else",      (char *)"  /* RA: bison compatibility: default action is \'$$ = $1;\' */",      (char *)"  if (yym > 0) yyps->val = (yyps->vsp)[1 - yym];", 
        (char *)"# endif",      (char *)"",      (char *)"  /* Default reduced position is NULL -- no position at all. No",      (char *)"     position will be assigned at trial time and if no position", 
        (char *)"     handling is present */",      (char *)"  memset(&yyps->pos, 0, sizeof(yyps->pos));",      (char *)"",      (char *)"  reduce_posn = 1;", 
        (char *)"",      (char *)"  switch (yyn) {",      (char *)"",      (char *)0};
#line 597 "/home/june/collector/temp/btyacc-3.0/skeleton.c"
char *trailer[260]  = 
#line 597
  {      (char *)"#line 573 \"btyaccpa.ske\"",      (char *)"",      (char *)"  default:",      (char *)"    break;", 
        (char *)"  }",      (char *)"",      (char *)"#if YYDEBUG && defined(YYDBPR)",      (char *)"  if (yydebug) {", 
        (char *)"    printf(\"yydebug[%d]: after reduction, result is \", yytrial);",      (char *)"    YYDBPR(yyps->val);",      (char *)"    printf(\"\\n\");",      (char *)"  }", 
        (char *)"#endif",      (char *)"",      (char *)"  // Perform user-defined position reduction",      (char *)"#ifdef YYREDUCEPOSNFUNC", 
        (char *)"  if(!yytrial) {",      (char *)"    YYCALLREDUCEPOSN(YYREDUCEPOSNFUNCARG);",      (char *)"  }",      (char *)"#endif", 
        (char *)"",      (char *)"  yyps->ssp -= yym;",      (char *)"  yystate = *(yyps->ssp);",      (char *)"  yyps->vsp -= yym;", 
        (char *)"  yyps->psp -= yym;",      (char *)"",      (char *)"  yym = yylhs[yyn];",      (char *)"  if (yystate == 0 && yym == 0) {", 
        (char *)"#if YYDEBUG",      (char *)"    if (yydebug) {",      (char *)"      printf(\"yydebug[%d,%d]: after reduction, shifting from state 0 to state %d\\n\", ",      (char *)"\t     yydepth, (int)yytrial, YYFINAL);", 
        (char *)"    }",      (char *)"#endif",      (char *)"    yystate = YYFINAL;",      (char *)"    *++(yyps->ssp) = YYFINAL;", 
        (char *)"    *++(yyps->vsp) = yyps->val;",      (char *)"    yyretlval = yyps->val;\t// return value of root non-terminal to yylval",      (char *)"    *++(yyps->psp) = yyps->pos;",      (char *)"    yyretposn = yyps->pos;\t// return value of root position to yyposn", 
        (char *)"    if (yychar < 0) {",      (char *)"      if ((yychar = YYLex1()) < 0) {",      (char *)"        yychar = 0;",      (char *)"      }", 
        (char *)"#if YYDEBUG",      (char *)"      if (yydebug) {",      (char *)"        yys = 0;",      (char *)"        if (yychar <= YYMAXTOKEN) yys = yyname[yychar];", 
        (char *)"        if (!yys) yys = \"illegal-symbol\";",      (char *)"        printf(\"yydebug[%d,%d]: state %d, reading %d (%s)\\n\", ",      (char *)"\t       yydepth, (int)yytrial, YYFINAL, yychar, yys); ",      (char *)"      }", 
        (char *)"#endif",      (char *)"    }",      (char *)"    if (yychar == 0) goto yyaccept;",      (char *)"    goto yyloop;", 
        (char *)"  }",      (char *)"",      (char *)"  if ((yyn = yygindex[yym]) && (yyn += yystate) >= 0 &&",      (char *)"      yyn <= YYTABLESIZE && yycheck[yyn] == yystate) {", 
        (char *)"    yystate = yytable[yyn];",      (char *)"  } else {",      (char *)"    yystate = yydgoto[yym];",      (char *)"  }", 
        (char *)"#if YYDEBUG",      (char *)"  if (yydebug)",      (char *)"    printf(\"yydebug[%d,%d]: after reduction, shifting from state %d to state %d\\n\",",      (char *)"           yydepth, (int)yytrial, *(yyps->ssp), yystate);", 
        (char *)"#endif",      (char *)"  if (yyps->ssp >= yyps->ss + yyps->stacksize - 1) {",      (char *)"    YYMoreStack(yyps);",      (char *)"  }", 
        (char *)"  *++(yyps->ssp) = yystate;",      (char *)"  *++(yyps->vsp) = yyps->val;",      (char *)"  *++(yyps->psp) = yyps->pos;",      (char *)"  goto yyloop;", 
        (char *)"",      (char *)"",      (char *)"  //",      (char *)"  // Reduction declares that this path is valid.", 
        (char *)"  // Set yypath and do a full parse",      (char *)"  //",      (char *)"yyvalid:",      (char *)"  if (yypath) {", 
        (char *)"    goto yyabort;",      (char *)"  }",      (char *)"  while (yyps->save) {",      (char *)"    yyparsestate *save = yyps->save;", 
        (char *)"    yyps->save = save->save;",      (char *)"    save->save = yypath;",      (char *)"    yypath = save;",      (char *)"  }", 
        (char *)"#if YYDEBUG",      (char *)"  if (yydebug)",      (char *)"    printf(\"yydebug[%d,%d]: CONFLICT trial successful, backtracking to state %d, %d tokens\\n\",",      (char *)"           yydepth, (int)yytrial, yypath->state, yylvp - yylvals - yypath->lexeme);", 
        (char *)"#endif",      (char *)"  if(yyerrctx) {",      (char *)"    YYFreeState(yyerrctx); yyerrctx = NULL;",      (char *)"  }", 
        (char *)"  yychar = -1;",      (char *)"  yyps->ssp = yyps->ss + (yypath->ssp - yypath->ss);",      (char *)"  yyps->vsp = yyps->vs + (yypath->vsp - yypath->vs);",      (char *)"  yyps->psp = yyps->ps + (yypath->psp - yypath->ps);", 
        (char *)"  memcpy (yyps->ss, yypath->ss, (yyps->ssp - yyps->ss + 1) * sizeof(Yshort));",      (char *)"  YYSCopy(yyps->vs, yypath->vs,  yyps->vsp - yyps->vs + 1);",      (char *)"  YYPCopy(yyps->ps, yypath->ps,  yyps->psp - yyps->ps + 1);",      (char *)"  yylvp = yylvals + yypath->lexeme;", 
        (char *)"  yylpp = yylpsns + yypath->lexeme;",      (char *)"  yylexp = yylexemes + yypath->lexeme;",      (char *)"  yystate = yypath->state;",      (char *)"  goto yyloop;", 
        (char *)"",      (char *)"",      (char *)"yyabort:",      (char *)"  if(yyerrctx) {", 
        (char *)"    YYFreeState(yyerrctx); yyerrctx = NULL;",      (char *)"  }",      (char *)"",      (char *)"  YYSTYPE *pv;", 
        (char *)"  for(pv=yyps->vs; pv<yyps->vsp; pv++) {",      (char *)"    YYDELETEVAL(*pv,2);",      (char *)"  }",      (char *)"", 
        (char *)"  YYPOSN *pp;",      (char *)"  for(pp=yyps->ps; pp<yyps->psp; pp++) {",      (char *)"    YYDELETEPOSN(*pp,2);",      (char *)"  }", 
        (char *)"",      (char *)"  while (yyps) {",      (char *)"    yyparsestate *save = yyps;",      (char *)"    yyps = save->save;", 
        (char *)"    YYFreeState(save);",      (char *)"  }",      (char *)"  while (yypath) {",      (char *)"    yyparsestate *save = yypath;", 
        (char *)"    yypath = save->save;",      (char *)"    YYFreeState(save); ",      (char *)"  }",      (char *)"  return (1);", 
        (char *)"",      (char *)"",      (char *)"yyaccept:",      (char *)"  if (yyps->save) goto yyvalid;", 
        (char *)"  if(yyerrctx) {",      (char *)"    YYFreeState(yyerrctx); yyerrctx = NULL;",      (char *)"  }",      (char *)"  while (yyps) {", 
        (char *)"    yyparsestate *save = yyps;",      (char *)"    yyps = save->save;",      (char *)"    YYFreeState(save);",      (char *)"  }", 
        (char *)"  while (yypath) {",      (char *)"    yyparsestate *save = yypath;",      (char *)"    yypath = save->save;",      (char *)"    YYFreeState(save); ", 
        (char *)"  }",      (char *)"  return (0);",      (char *)"}",      (char *)"", 
        (char *)"",      (char *)"int YYLex1() {",      (char *)"  if(yylvp<yylve) {",      (char *)"    yylval = *yylvp++;", 
        (char *)"    yyposn = *yylpp++;",      (char *)"    return *yylexp++;",      (char *)"  } else {",      (char *)"    if(yyps->save) {", 
        (char *)"      if(yylvp==yylvlim) {",      (char *)"\tyyexpand();",      (char *)"      }",      (char *)"      *yylexp = yylex();", 
        (char *)"      *yylvp++ = yylval;",      (char *)"      yylve++;",      (char *)"      *yylpp++ = yyposn;",      (char *)"      yylpe++;", 
        (char *)"      return *yylexp++;",      (char *)"    } else {",      (char *)"      return yylex();",      (char *)"    }", 
        (char *)"  }",      (char *)"}",      (char *)"",      (char *)"int yyexpand() {", 
        (char *)"  int p = yylvp-yylvals;",      (char *)"  int s = yylvlim-yylvals;",      (char *)"  s += YYSTACKGROWTH;",      (char *)"  { Yshort  *tl = yylexemes; ", 
        (char *)"    YYSTYPE *tv = yylvals;",      (char *)"    YYPOSN  *tp = yylpsns;",      (char *)"    yylvals = new YYSTYPE[s];",      (char *)"    yylpsns = new YYPOSN[s];", 
        (char *)"    yylexemes = new Yshort[s];",      (char *)"    memcpy(yylexemes, tl, (s-YYSTACKGROWTH)*sizeof(Yshort));",      (char *)"    YYSCopy(yylvals, tv, s-YYSTACKGROWTH);",      (char *)"    YYPCopy(yylpsns, tp, s-YYSTACKGROWTH);", 
        (char *)"    delete[] tl;",      (char *)"    delete[] tv;",      (char *)"    delete[] tp;",      (char *)"  }", 
        (char *)"  yylvp = yylve = yylvals + p;",      (char *)"  yylvlim = yylvals + s;",      (char *)"  yylpp = yylpe = yylpsns + p;",      (char *)"  yylplim = yylpsns + s;", 
        (char *)"  yylexp = yylexemes + p;",      (char *)"  return 0;",      (char *)"}",      (char *)"", 
        (char *)"void YYSCopy(YYSTYPE *to, YYSTYPE *from, int size) {",      (char *)"  int i;                             ",      (char *)"  for (i = size-1; i >= 0; i--) {",      (char *)"    to[i] = from[i];", 
        (char *)"  }",      (char *)"}",      (char *)"",      (char *)"void YYPCopy(YYPOSN *to, YYPOSN *from, int size) {", 
        (char *)"  int i;                             ",      (char *)"  for (i = size-1; i >= 0; i--) {",      (char *)"    to[i] = from[i];",      (char *)"  }", 
        (char *)"}",      (char *)"",      (char *)"void YYMoreStack(yyparsestate *yyps) {",      (char *)"  int p = yyps->ssp - yyps->ss;                               ", 
        (char *)"  Yshort  *tss = yyps->ss;",      (char *)"  YYSTYPE *tvs = yyps->vs;",      (char *)"  YYPOSN  *tps = yyps->ps;",      (char *)"  yyps->ss = new Yshort [yyps->stacksize + YYSTACKGROWTH];   ", 
        (char *)"  yyps->vs = new YYSTYPE[yyps->stacksize + YYSTACKGROWTH];  ",      (char *)"  yyps->ps = new YYPOSN [yyps->stacksize + YYSTACKGROWTH];  ",      (char *)"  memcpy(yyps->ss, tss, yyps->stacksize * sizeof(Yshort));  ",      (char *)"  YYSCopy(yyps->vs, tvs, yyps->stacksize);                  ", 
        (char *)"  YYPCopy(yyps->ps, tps, yyps->stacksize);                  ",      (char *)"  yyps->stacksize += YYSTACKGROWTH;                           ",      (char *)"  delete[] tss;",      (char *)"  delete[] tvs;", 
        (char *)"  delete[] tps;",      (char *)"  yyps->ssp = yyps->ss + p;                                   ",      (char *)"  yyps->vsp = yyps->vs + p;                                   ",      (char *)"  yyps->psp = yyps->ps + p;                                   ", 
        (char *)"}",      (char *)"",      (char *)"yyparsestate *YYNewState(int size) {",      (char *)"  yyparsestate *p = new yyparsestate;", 
        (char *)"  p->stacksize = size+4;",      (char *)"  p->ss = new Yshort [size + 4];",      (char *)"  p->vs = new YYSTYPE[size + 4];",      (char *)"  p->ps = new YYPOSN [size + 4];", 
        (char *)"  memset(&p->vs[0], 0, (size+4)*sizeof(YYSTYPE));",      (char *)"  memset(&p->ps[0], 0, (size+4)*sizeof(YYPOSN));",      (char *)"  return p;",      (char *)"}", 
        (char *)"",      (char *)"void YYFreeState(yyparsestate *p) {",      (char *)"  delete[] p->ss;",      (char *)"  delete[] p->vs;", 
        (char *)"  delete[] p->ps;",      (char *)"  delete p;",      (char *)"}",      (char *)0};
#line 861 "/home/june/collector/temp/btyacc-3.0/skeleton.c"
struct section section_list[6]  = {      {(char *)"banner", & banner[0]}, 
        {(char *)"tables", & tables[0]}, 
        {(char *)"header", & header[0]}, 
        {(char *)"body", & body[0]}, 
        {(char *)"trailer", & trailer[0]}, 
        {(char *)0, (char **)0}};
#line 759 "/usr/include/stdio.h"
extern void rewind(FILE *__stream ) ;
#line 281 "/home/june/collector/temp/btyacc-3.0/defs.h"
reductions **reduction_table ;
#line 282
unsigned int *LA ;
#line 283
Yshort *LAruleno ;
#line 284
Yshort *lookaheads ;
#line 285
Yshort *goto_map ;
#line 286
Yshort *from_state ;
#line 287
Yshort *to_state ;
#line 416
void free_parser(void) ;
#line 420
void output_rule_data(void) ;
#line 421
void output_yydefred(void) ;
#line 422
void output_actions(void) ;
#line 423
int find_conflict_base(int cbase ) ;
#line 424
void token_actions(void) ;
#line 425
void goto_actions(void) ;
#line 426
int default_goto(int symbol ) ;
#line 427
void save_column(int symbol , int default_state ) ;
#line 428
void sort_actions(void) ;
#line 429
void pack_table(void) ;
#line 430
int matching_vector(int vector ) ;
#line 431
int pack_vector(int vector ) ;
#line 432
void output_base(void) ;
#line 433
void output_table(void) ;
#line 434
void output_check(void) ;
#line 435
void output_ctable(void) ;
#line 436
int is_C_identifier(char *name ) ;
#line 437
void output_defines(void) ;
#line 438
void output_stored_text(void) ;
#line 439
void output_debug(void) ;
#line 440
void output_stype(void) ;
#line 441
void output_trailing_text(void) ;
#line 442
void output_semantic_actions(void) ;
#line 443
void free_itemsets(void) ;
#line 444
void free_shifts(void) ;
#line 445
void free_reductions(void) ;
#line 3 "/home/june/collector/temp/btyacc-3.0/output.c"
static int nvectors  ;
#line 4 "/home/june/collector/temp/btyacc-3.0/output.c"
static int nentries  ;
#line 5 "/home/june/collector/temp/btyacc-3.0/output.c"
static Yshort **froms  ;
#line 6 "/home/june/collector/temp/btyacc-3.0/output.c"
static Yshort **tos  ;
#line 7 "/home/june/collector/temp/btyacc-3.0/output.c"
static Yshort *conflicts  ;
#line 7 "/home/june/collector/temp/btyacc-3.0/output.c"
static Yshort nconflicts  ;
#line 8 "/home/june/collector/temp/btyacc-3.0/output.c"
static Yshort *tally  ;
#line 9 "/home/june/collector/temp/btyacc-3.0/output.c"
static Yshort *width  ;
#line 10 "/home/june/collector/temp/btyacc-3.0/output.c"
static Yshort *state_count  ;
#line 11 "/home/june/collector/temp/btyacc-3.0/output.c"
static Yshort *order  ;
#line 12 "/home/june/collector/temp/btyacc-3.0/output.c"
static Yshort *base  ;
#line 13 "/home/june/collector/temp/btyacc-3.0/output.c"
static Yshort *pos  ;
#line 14 "/home/june/collector/temp/btyacc-3.0/output.c"
static int maxtable  ;
#line 15 "/home/june/collector/temp/btyacc-3.0/output.c"
static Yshort *table  ;
#line 16 "/home/june/collector/temp/btyacc-3.0/output.c"
static Yshort *check  ;
#line 17 "/home/june/collector/temp/btyacc-3.0/output.c"
static int lowzero  ;
#line 18 "/home/june/collector/temp/btyacc-3.0/output.c"
static int high  ;
#line 21 "/home/june/collector/temp/btyacc-3.0/output.c"
void output(void) 
{ 


  {
  {
#line 23
  free_itemsets();
#line 24
  free_shifts();
#line 25
  free_reductions();
#line 26
  output_stored_text();
#line 27
  output_defines();
#line 28
  output_rule_data();
#line 29
  output_yydefred();
#line 30
  output_actions();
#line 31
  free_parser();
#line 32
  output_debug();
#line 33
  output_stype();
  }
#line 34
  if (rflag) {
    {
#line 34
    write_section((char *)"tables");
    }
  }
  {
#line 35
  write_section((char *)"header");
#line 36
  output_trailing_text();
#line 37
  write_section((char *)"body");
#line 38
  output_semantic_actions();
#line 39
  write_section((char *)"trailer");
  }
#line 40
  return;
}
}
#line 43 "/home/june/collector/temp/btyacc-3.0/output.c"
void output_rule_data(void) 
{ 
  register int i ;
  register int j ;

  {
#line 48
  if (! rflag) {
    {
#line 49
    fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"static ");
    }
  }
  {
#line 50
  fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"int yylhs[] = {%42d,",
          *(symbol_value + start_symbol));
#line 53
  j = 10;
#line 54
  i = 3;
  }
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
#line 54
    if (! (i < nrules)) {
#line 54
      goto while_break;
    }
#line 56
    if (j >= 10) {
#line 58
      if (! rflag) {
#line 58
        outline ++;
      }
      {
#line 59
      _IO_putc('\n', output_file);
#line 60
      j = 1;
      }
    } else {
#line 63
      j ++;
    }
    {
#line 65
    fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"%5d,",
            *(symbol_value + *(rlhs + i)));
#line 54
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 67
  if (! rflag) {
#line 67
    outline += 2;
  }
  {
#line 68
  fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"\n};\n");
  }
#line 70
  if (! rflag) {
    {
#line 71
    fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"static ");
    }
  }
  {
#line 72
  fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"int yylen[] = {%42d,",
          2);
#line 74
  j = 10;
#line 75
  i = 3;
  }
  {
#line 75
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 75
    if (! (i < nrules)) {
#line 75
      goto while_break___0;
    }
#line 77
    if (j >= 10) {
#line 79
      if (! rflag) {
#line 79
        outline ++;
      }
      {
#line 80
      _IO_putc('\n', output_file);
#line 81
      j = 1;
      }
    } else {
#line 84
      j ++;
    }
    {
#line 86
    fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"%5d,",
            (*(rrhs + (i + 1)) - *(rrhs + i)) - 1);
#line 75
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 88
  if (! rflag) {
#line 88
    outline += 2;
  }
  {
#line 89
  fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"\n};\n");
  }
#line 90
  return;
}
}
#line 93 "/home/june/collector/temp/btyacc-3.0/output.c"
void output_yydefred(void) 
{ 
  register int i ;
  register int j ;
  Yshort tmp ;
  Yshort tmp___0 ;

  {
#line 97
  if (! rflag) {
    {
#line 98
    fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"static ");
    }
  }
#line 99
  if (*(defred + 0)) {
#line 99
    tmp = *(defred + 0) - 2;
  } else {
#line 99
    tmp = 0;
  }
  {
#line 99
  fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"int yydefred[] = {%39d,",
          tmp);
#line 102
  j = 10;
#line 103
  i = 1;
  }
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 103
    if (! (i < nstates)) {
#line 103
      goto while_break;
    }
#line 105
    if (j < 10) {
#line 106
      j ++;
    } else {
#line 109
      if (! rflag) {
#line 109
        outline ++;
      }
      {
#line 110
      _IO_putc('\n', output_file);
#line 111
      j = 1;
      }
    }
#line 114
    if (*(defred + i)) {
#line 114
      tmp___0 = *(defred + i) - 2;
    } else {
#line 114
      tmp___0 = 0;
    }
    {
#line 114
    fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"%5d,",
            tmp___0);
#line 103
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 117
  if (! rflag) {
#line 117
    outline += 2;
  }
  {
#line 118
  fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"\n};\n");
  }
#line 119
  return;
}
}
#line 122 "/home/june/collector/temp/btyacc-3.0/output.c"
void output_actions(void) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 124
  nvectors = 3 * nstates + nvars;
#line 126
  tmp = allocate((unsigned int )((unsigned long )nvectors * sizeof(Yshort *)));
#line 126
  froms = (Yshort **)tmp;
#line 127
  tmp___0 = allocate((unsigned int )((unsigned long )nvectors * sizeof(Yshort *)));
#line 127
  tos = (Yshort **)tmp___0;
#line 128
  tmp___1 = allocate((unsigned int )((unsigned long )nvectors * sizeof(Yshort )));
#line 128
  tally = (Yshort *)tmp___1;
#line 129
  tmp___2 = allocate((unsigned int )((unsigned long )nvectors * sizeof(Yshort )));
#line 129
  width = (Yshort *)tmp___2;
  }
#line 130
  if (SRtotal + RRtotal) {
    {
#line 131
    tmp___3 = allocate((unsigned int )((unsigned long )(4 * (SRtotal + RRtotal)) * sizeof(Yshort )));
#line 131
    conflicts = (Yshort *)tmp___3;
    }
  } else {
#line 133
    conflicts = (Yshort *)0;
  }
  {
#line 134
  nconflicts = 0;
#line 136
  token_actions();
#line 137
  free((void *)((char *)lookaheads));
#line 138
  free((void *)((char *)LA));
#line 139
  free((void *)((char *)LAruleno));
#line 140
  free((void *)((char *)accessing_symbol));
#line 142
  goto_actions();
#line 143
  free((void *)((char *)(goto_map + ntokens)));
#line 144
  free((void *)((char *)from_state));
#line 145
  free((void *)((char *)to_state));
#line 147
  sort_actions();
#line 148
  pack_table();
#line 149
  output_base();
#line 150
  output_table();
#line 151
  output_check();
#line 152
  output_ctable();
  }
#line 153
  return;
}
}
#line 155 "/home/june/collector/temp/btyacc-3.0/output.c"
int find_conflict_base(int cbase ) 
{ 
  int i ;
  int j ;

  {
#line 159
  i = 0;
  {
#line 159
  while (1) {
    while_continue: /* CIL Label */ ;
#line 159
    if (! (i < cbase)) {
#line 159
      goto while_break;
    }
#line 160
    j = 0;
    {
#line 160
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 160
      if (! (j + cbase < nconflicts)) {
#line 160
        goto while_break___0;
      }
#line 161
      if (*(conflicts + (i + j)) != *(conflicts + (cbase + j))) {
#line 162
        goto while_break___0;
      }
#line 160
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 163
    if (j + cbase >= nconflicts) {
#line 164
      return (i);
    }
#line 159
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 165
  return (cbase);
}
}
#line 168 "/home/june/collector/temp/btyacc-3.0/output.c"
void token_actions(void) 
{ 
  register int i ;
  register int j ;
  register int shiftcount ;
  register int reducecount ;
  register int conflictcount ;
  register int csym ;
  register int cbase ;
  register int max ;
  register int min ;
  register Yshort *actionrow ;
  register Yshort *r ;
  register Yshort *s ;
  register action *p ;
  char *tmp ;
  Yshort tmp___0 ;
  Yshort tmp___1 ;
  Yshort tmp___2 ;
  Yshort tmp___3 ;
  Yshort tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  Yshort *tmp___7 ;
  Yshort *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  Yshort *tmp___11 ;
  Yshort *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  Yshort *tmp___15 ;
  Yshort *tmp___16 ;

  {
  {
#line 176
  tmp = allocate((unsigned int )((unsigned long )(3 * ntokens) * sizeof(Yshort )));
#line 176
  actionrow = (Yshort *)tmp;
#line 177
  i = 0;
  }
  {
#line 177
  while (1) {
    while_continue: /* CIL Label */ ;
#line 177
    if (! (i < nstates)) {
#line 177
      goto while_break;
    }
#line 178
    if (*(parser + i)) {
#line 179
      j = 0;
      {
#line 179
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 179
        if (! (j < 3 * ntokens)) {
#line 179
          goto while_break___0;
        }
#line 180
        *(actionrow + j) = 0;
#line 179
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 182
      shiftcount = 0;
#line 183
      reducecount = 0;
#line 184
      conflictcount = 0;
#line 185
      csym = -1;
#line 186
      cbase = nconflicts;
#line 187
      p = *(parser + i);
      {
#line 187
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 187
        if (! p) {
#line 187
          goto while_break___1;
        }
#line 188
        if (csym != -1) {
#line 188
          if (csym != p->symbol) {
            {
#line 189
            conflictcount ++;
#line 190
            tmp___0 = nconflicts;
#line 190
            nconflicts ++;
#line 190
            *(conflicts + tmp___0) = -1;
#line 191
            j = find_conflict_base(cbase);
#line 192
            *(actionrow + (csym + 2 * ntokens)) = j + 1;
            }
#line 193
            if (j == cbase) {
#line 194
              cbase = nconflicts;
            } else {
#line 196
              if (*(conflicts + cbase) == -1) {
#line 196
                cbase ++;
              }
#line 197
              nconflicts = cbase;
            }
#line 198
            csym = -1;
          }
        }
#line 199
        if ((int )p->suppressed == 0) {
#line 200
          if ((int )p->action_code == 1) {
#line 201
            shiftcount ++;
#line 202
            *(actionrow + p->symbol) = p->number;
          } else
#line 203
          if ((int )p->action_code == 2) {
#line 203
            if (p->number != *(defred + i)) {
#line 205
              reducecount ++;
#line 206
              *(actionrow + (p->symbol + ntokens)) = p->number;
            }
          }
        } else
#line 207
        if ((int )p->suppressed == 1) {
#line 208
          csym = p->symbol;
#line 209
          if ((int )p->action_code == 1) {
#line 210
            tmp___1 = nconflicts;
#line 210
            nconflicts ++;
#line 210
            *(conflicts + tmp___1) = p->number;
          } else
#line 211
          if ((int )p->action_code == 2) {
#line 211
            if (p->number != *(defred + i)) {
#line 213
              if (cbase == nconflicts) {
#line 214
                if (cbase) {
#line 214
                  cbase --;
                } else {
#line 215
                  tmp___2 = nconflicts;
#line 215
                  nconflicts ++;
#line 215
                  *(conflicts + tmp___2) = -1;
                }
              }
#line 216
              tmp___3 = nconflicts;
#line 216
              nconflicts ++;
#line 216
              *(conflicts + tmp___3) = p->number - 2;
            }
          }
        }
#line 187
        p = p->next;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 217
      if (csym != -1) {
        {
#line 218
        conflictcount ++;
#line 219
        tmp___4 = nconflicts;
#line 219
        nconflicts ++;
#line 219
        *(conflicts + tmp___4) = -1;
#line 220
        j = find_conflict_base(cbase);
#line 221
        *(actionrow + (csym + 2 * ntokens)) = j + 1;
        }
#line 222
        if (j == cbase) {
#line 223
          cbase = nconflicts;
        } else {
#line 225
          if (*(conflicts + cbase) == -1) {
#line 225
            cbase ++;
          }
#line 226
          nconflicts = cbase;
        }
      }
#line 228
      *(tally + i) = shiftcount;
#line 229
      *(tally + (nstates + i)) = reducecount;
#line 230
      *(tally + (2 * nstates + i)) = conflictcount;
#line 231
      *(width + i) = 0;
#line 232
      *(width + (nstates + i)) = 0;
#line 233
      *(width + (2 * nstates + i)) = 0;
#line 234
      if (shiftcount > 0) {
        {
#line 235
        tmp___5 = allocate((unsigned int )((unsigned long )shiftcount * sizeof(Yshort )));
#line 235
        r = (Yshort *)tmp___5;
#line 235
        *(froms + i) = r;
#line 236
        tmp___6 = allocate((unsigned int )((unsigned long )shiftcount * sizeof(Yshort )));
#line 236
        s = (Yshort *)tmp___6;
#line 236
        *(tos + i) = s;
#line 237
        min = 2147483647;
#line 238
        max = 0;
#line 239
        j = 0;
        }
        {
#line 239
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 239
          if (! (j < ntokens)) {
#line 239
            goto while_break___2;
          }
#line 240
          if (*(actionrow + j)) {
#line 241
            if (min > *(symbol_value + j)) {
#line 242
              min = *(symbol_value + j);
            }
#line 243
            if (max < *(symbol_value + j)) {
#line 244
              max = *(symbol_value + j);
            }
#line 245
            tmp___7 = r;
#line 245
            r ++;
#line 245
            *tmp___7 = *(symbol_value + j);
#line 246
            tmp___8 = s;
#line 246
            s ++;
#line 246
            *tmp___8 = *(actionrow + j);
          }
#line 239
          j ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 247
        *(width + i) = (max - min) + 1;
      }
#line 248
      if (reducecount > 0) {
        {
#line 249
        tmp___9 = allocate((unsigned int )((unsigned long )reducecount * sizeof(Yshort )));
#line 249
        r = (Yshort *)tmp___9;
#line 249
        *(froms + (nstates + i)) = r;
#line 250
        tmp___10 = allocate((unsigned int )((unsigned long )reducecount * sizeof(Yshort )));
#line 250
        s = (Yshort *)tmp___10;
#line 250
        *(tos + (nstates + i)) = s;
#line 251
        min = 2147483647;
#line 252
        max = 0;
#line 253
        j = 0;
        }
        {
#line 253
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 253
          if (! (j < ntokens)) {
#line 253
            goto while_break___3;
          }
#line 254
          if (*(actionrow + (ntokens + j))) {
#line 255
            if (min > *(symbol_value + j)) {
#line 256
              min = *(symbol_value + j);
            }
#line 257
            if (max < *(symbol_value + j)) {
#line 258
              max = *(symbol_value + j);
            }
#line 259
            tmp___11 = r;
#line 259
            r ++;
#line 259
            *tmp___11 = *(symbol_value + j);
#line 260
            tmp___12 = s;
#line 260
            s ++;
#line 260
            *tmp___12 = *(actionrow + (ntokens + j)) - 2;
          }
#line 253
          j ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 261
        *(width + (nstates + i)) = (max - min) + 1;
      }
#line 262
      if (conflictcount > 0) {
        {
#line 263
        tmp___13 = allocate((unsigned int )((unsigned long )conflictcount * sizeof(Yshort )));
#line 263
        r = (Yshort *)tmp___13;
#line 263
        *(froms + (2 * nstates + i)) = r;
#line 264
        tmp___14 = allocate((unsigned int )((unsigned long )conflictcount * sizeof(Yshort )));
#line 264
        s = (Yshort *)tmp___14;
#line 264
        *(tos + (2 * nstates + i)) = s;
#line 265
        min = 2147483647;
#line 266
        max = 0;
#line 267
        j = 0;
        }
        {
#line 267
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 267
          if (! (j < ntokens)) {
#line 267
            goto while_break___4;
          }
#line 268
          if (*(actionrow + (2 * ntokens + j))) {
#line 269
            if (min > *(symbol_value + j)) {
#line 270
              min = *(symbol_value + j);
            }
#line 271
            if (max < *(symbol_value + j)) {
#line 272
              max = *(symbol_value + j);
            }
#line 273
            tmp___15 = r;
#line 273
            r ++;
#line 273
            *tmp___15 = *(symbol_value + j);
#line 274
            tmp___16 = s;
#line 274
            s ++;
#line 274
            *tmp___16 = *(actionrow + (2 * ntokens + j)) - 1;
          }
#line 267
          j ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 275
        *(width + (2 * nstates + i)) = (max - min) + 1;
      }
    }
#line 177
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 276
  free((void *)((char *)actionrow));
  }
#line 277
  return;
}
}
#line 279 "/home/june/collector/temp/btyacc-3.0/output.c"
void goto_actions(void) 
{ 
  register int i ;
  register int j ;
  register int k ;
  char *tmp ;

  {
  {
#line 283
  tmp = allocate((unsigned int )((unsigned long )nstates * sizeof(Yshort )));
#line 283
  state_count = (Yshort *)tmp;
#line 285
  k = default_goto(start_symbol + 1);
  }
#line 286
  if (! rflag) {
    {
#line 287
    fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"static ");
    }
  }
  {
#line 288
  fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"int yydgoto[] = {%40d,",
          k);
#line 289
  save_column(start_symbol + 1, k);
#line 291
  j = 10;
#line 292
  i = start_symbol + 2;
  }
  {
#line 292
  while (1) {
    while_continue: /* CIL Label */ ;
#line 292
    if (! (i < nsyms)) {
#line 292
      goto while_break;
    }
#line 294
    if (j >= 10) {
#line 296
      if (! rflag) {
#line 296
        outline ++;
      }
      {
#line 297
      _IO_putc('\n', output_file);
#line 298
      j = 1;
      }
    } else {
#line 301
      j ++;
    }
    {
#line 303
    k = default_goto(i);
#line 304
    fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"%5d,",
            k);
#line 305
    save_column(i, k);
#line 292
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 308
  if (! rflag) {
#line 308
    outline += 2;
  }
  {
#line 309
  fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"\n};\n");
#line 310
  free((void *)((char *)state_count));
  }
#line 311
  return;
}
}
#line 313 "/home/june/collector/temp/btyacc-3.0/output.c"
int default_goto(int symbol ) 
{ 
  register int i ;
  register int m ;
  register int n ;
  register int default_state ;
  register int max ;

  {
#line 321
  m = *(goto_map + symbol);
#line 322
  n = *(goto_map + (symbol + 1));
#line 324
  if (m == n) {
#line 324
    return (0);
  }
#line 326
  i = 0;
  {
#line 326
  while (1) {
    while_continue: /* CIL Label */ ;
#line 326
    if (! (i < nstates)) {
#line 326
      goto while_break;
    }
#line 327
    *(state_count + i) = 0;
#line 326
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 329
  i = m;
  {
#line 329
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 329
    if (! (i < n)) {
#line 329
      goto while_break___0;
    }
#line 330
    (*(state_count + *(to_state + i))) ++;
#line 329
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 332
  max = 0;
#line 333
  default_state = 0;
#line 334
  i = 0;
  {
#line 334
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 334
    if (! (i < nstates)) {
#line 334
      goto while_break___1;
    }
#line 336
    if (*(state_count + i) > max) {
#line 338
      max = *(state_count + i);
#line 339
      default_state = i;
    }
#line 334
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 343
  return (default_state);
}
}
#line 348 "/home/june/collector/temp/btyacc-3.0/output.c"
void save_column(int symbol , int default_state ) 
{ 
  register int i ;
  register int m ;
  register int n ;
  register Yshort *sp ;
  register Yshort *sp1 ;
  register Yshort *sp2 ;
  register int count ;
  register int symno ;
  char *tmp ;
  char *tmp___0 ;
  Yshort *tmp___1 ;
  Yshort *tmp___2 ;

  {
#line 359
  m = *(goto_map + symbol);
#line 360
  n = *(goto_map + (symbol + 1));
#line 362
  count = 0;
#line 363
  i = m;
  {
#line 363
  while (1) {
    while_continue: /* CIL Label */ ;
#line 363
    if (! (i < n)) {
#line 363
      goto while_break;
    }
#line 365
    if (*(to_state + i) != default_state) {
#line 366
      count ++;
    }
#line 363
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 368
  if (count == 0) {
#line 368
    return;
  }
  {
#line 370
  symno = *(symbol_value + symbol) + 3 * nstates;
#line 372
  tmp = allocate((unsigned int )((unsigned long )count * sizeof(Yshort )));
#line 372
  sp = (Yshort *)tmp;
#line 372
  sp1 = sp;
#line 372
  *(froms + symno) = sp1;
#line 373
  tmp___0 = allocate((unsigned int )((unsigned long )count * sizeof(Yshort )));
#line 373
  sp2 = (Yshort *)tmp___0;
#line 373
  *(tos + symno) = sp2;
#line 375
  i = m;
  }
  {
#line 375
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 375
    if (! (i < n)) {
#line 375
      goto while_break___0;
    }
#line 377
    if (*(to_state + i) != default_state) {
#line 379
      tmp___1 = sp1;
#line 379
      sp1 ++;
#line 379
      *tmp___1 = *(from_state + i);
#line 380
      tmp___2 = sp2;
#line 380
      sp2 ++;
#line 380
      *tmp___2 = *(to_state + i);
    }
#line 375
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 384
  *(tally + symno) = count;
#line 385
  *(width + symno) = (*(sp1 + -1) - *(sp + 0)) + 1;
#line 386
  return;
}
}
#line 388 "/home/june/collector/temp/btyacc-3.0/output.c"
void sort_actions(void) 
{ 
  register int i ;
  register int j ;
  register int k ;
  register int t ;
  register int w ;
  char *tmp ;

  {
  {
#line 396
  tmp = allocate((unsigned int )((unsigned long )nvectors * sizeof(Yshort )));
#line 396
  order = (Yshort *)tmp;
#line 397
  nentries = 0;
#line 399
  i = 0;
  }
  {
#line 399
  while (1) {
    while_continue: /* CIL Label */ ;
#line 399
    if (! (i < nvectors)) {
#line 399
      goto while_break;
    }
#line 401
    if (*(tally + i) > 0) {
#line 403
      t = *(tally + i);
#line 404
      w = *(width + i);
#line 405
      j = nentries - 1;
      {
#line 407
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 407
        if (j >= 0) {
#line 407
          if (! (*(width + *(order + j)) < w)) {
#line 407
            goto while_break___0;
          }
        } else {
#line 407
          goto while_break___0;
        }
#line 408
        j --;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 410
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 410
        if (j >= 0) {
#line 410
          if (*(width + *(order + j)) == w) {
#line 410
            if (! (*(tally + *(order + j)) < t)) {
#line 410
              goto while_break___1;
            }
          } else {
#line 410
            goto while_break___1;
          }
        } else {
#line 410
          goto while_break___1;
        }
#line 411
        j --;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 413
      k = nentries - 1;
      {
#line 413
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 413
        if (! (k > j)) {
#line 413
          goto while_break___2;
        }
#line 414
        *(order + (k + 1)) = *(order + k);
#line 413
        k --;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 416
      *(order + (j + 1)) = i;
#line 417
      nentries ++;
    }
#line 399
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 420
  return;
}
}
#line 423 "/home/june/collector/temp/btyacc-3.0/output.c"
void pack_table(void) 
{ 
  register int i ;
  register int place ;
  register int state ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 429
  tmp = allocate((unsigned int )((unsigned long )nvectors * sizeof(Yshort )));
#line 429
  base = (Yshort *)tmp;
#line 430
  tmp___0 = allocate((unsigned int )((unsigned long )nentries * sizeof(Yshort )));
#line 430
  pos = (Yshort *)tmp___0;
#line 432
  maxtable = 1000;
#line 433
  tmp___1 = allocate((unsigned int )((unsigned long )maxtable * sizeof(Yshort )));
#line 433
  table = (Yshort *)tmp___1;
#line 434
  tmp___2 = allocate((unsigned int )((unsigned long )maxtable * sizeof(Yshort )));
#line 434
  check = (Yshort *)tmp___2;
#line 436
  lowzero = 0;
#line 437
  high = 0;
#line 439
  i = 0;
  }
  {
#line 439
  while (1) {
    while_continue: /* CIL Label */ ;
#line 439
    if (! (i < maxtable)) {
#line 439
      goto while_break;
    }
#line 440
    *(check + i) = -1;
#line 439
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 442
  i = 0;
  {
#line 442
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 442
    if (! (i < nentries)) {
#line 442
      goto while_break___0;
    }
    {
#line 444
    state = matching_vector(i);
    }
#line 446
    if (state < 0) {
      {
#line 447
      place = pack_vector(i);
      }
    } else {
#line 449
      place = *(base + state);
    }
#line 451
    *(pos + i) = place;
#line 452
    *(base + *(order + i)) = place;
#line 442
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 455
  i = 0;
  {
#line 455
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 455
    if (! (i < nvectors)) {
#line 455
      goto while_break___1;
    }
#line 457
    if (*(froms + i)) {
      {
#line 458
      free((void *)((char *)*(froms + i)));
      }
    }
#line 459
    if (*(tos + i)) {
      {
#line 460
      free((void *)((char *)*(tos + i)));
      }
    }
#line 455
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 463
  free((void *)((char *)froms));
#line 464
  free((void *)((char *)tos));
#line 465
  free((void *)((char *)tally));
#line 466
  free((void *)((char *)width));
#line 467
  free((void *)((char *)pos));
  }
#line 468
  return;
}
}
#line 489 "/home/june/collector/temp/btyacc-3.0/output.c"
int matching_vector(int vector ) 
{ 
  register int i ;
  register int j ;
  register int k ;
  register int t ;
  register int w ;
  register int match ;
  register int prev ;

  {
#line 499
  i = *(order + vector);
#line 500
  if (i >= 2 * nstates) {
#line 501
    return (-1);
  }
#line 503
  t = *(tally + i);
#line 504
  w = *(width + i);
#line 506
  prev = vector - 1;
  {
#line 506
  while (1) {
    while_continue: /* CIL Label */ ;
#line 506
    if (! (prev >= 0)) {
#line 506
      goto while_break;
    }
#line 508
    j = *(order + prev);
#line 509
    if (*(width + j) != w) {
#line 510
      return (-1);
    } else
#line 509
    if (*(tally + j) != t) {
#line 510
      return (-1);
    }
#line 512
    match = 1;
#line 513
    k = 0;
    {
#line 513
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 513
      if (match) {
#line 513
        if (! (k < t)) {
#line 513
          goto while_break___0;
        }
      } else {
#line 513
        goto while_break___0;
      }
#line 515
      if (*(*(tos + j) + k) != *(*(tos + i) + k)) {
#line 516
        match = 0;
      } else
#line 515
      if (*(*(froms + j) + k) != *(*(froms + i) + k)) {
#line 516
        match = 0;
      }
#line 513
      k ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 519
    if (match) {
#line 520
      return (j);
    }
#line 506
    prev --;
  }
  while_break: /* CIL Label */ ;
  }
#line 523
  return (-1);
}
}
#line 528 "/home/june/collector/temp/btyacc-3.0/output.c"
int pack_vector(int vector ) 
{ 
  register int i ;
  register int j ;
  register int k ;
  register int l ;
  register int t ;
  register int loc ;
  register int ok ;
  register Yshort *from ;
  register Yshort *to ;
  int newmax ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 538
  i = *(order + vector);
#line 539
  t = *(tally + i);
#line 540
  if (! t) {
    {
#line 540
    __assert_fail("t", "/home/june/collector/temp/btyacc-3.0/output.c", 540U, "pack_vector");
    }
  }
#line 542
  from = *(froms + i);
#line 543
  to = *(tos + i);
#line 545
  j = lowzero - *(from + 0);
#line 546
  k = 1;
  {
#line 546
  while (1) {
    while_continue: /* CIL Label */ ;
#line 546
    if (! (k < t)) {
#line 546
      goto while_break;
    }
#line 547
    if (lowzero - *(from + k) > j) {
#line 548
      j = lowzero - *(from + k);
    }
#line 546
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 549
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 551
    if (j == 0) {
#line 552
      goto __Cont;
    }
#line 553
    ok = 1;
#line 554
    k = 0;
    {
#line 554
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 554
      if (ok) {
#line 554
        if (! (k < t)) {
#line 554
          goto while_break___1;
        }
      } else {
#line 554
        goto while_break___1;
      }
#line 556
      loc = j + *(from + k);
#line 557
      if (loc >= maxtable) {
#line 559
        if (loc >= 120000) {
          {
#line 560
          fatal((char *)"maximum table size exceeded");
          }
        }
#line 562
        newmax = maxtable;
        {
#line 563
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 563
          newmax += 200;
#line 563
          if (! (newmax <= loc)) {
#line 563
            goto while_break___2;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 564
        tmp = realloc((void *)((char *)table), (size_t )((unsigned int )((unsigned long )newmax * sizeof(Yshort ))));
#line 564
        table = (Yshort *)tmp;
        }
#line 565
        if ((unsigned long )table == (unsigned long )((Yshort *)0)) {
          {
#line 565
          no_space();
          }
        }
        {
#line 566
        tmp___0 = realloc((void *)((char *)check), (size_t )((unsigned int )((unsigned long )newmax * sizeof(Yshort ))));
#line 566
        check = (Yshort *)tmp___0;
        }
#line 567
        if ((unsigned long )check == (unsigned long )((Yshort *)0)) {
          {
#line 567
          no_space();
          }
        }
#line 568
        l = maxtable;
        {
#line 568
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 568
          if (! (l < newmax)) {
#line 568
            goto while_break___3;
          }
#line 570
          *(table + l) = 0;
#line 571
          *(check + l) = -1;
#line 568
          l ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 573
        maxtable = newmax;
      }
#line 576
      if (*(check + loc) != -1) {
#line 577
        ok = 0;
      }
#line 554
      k ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 579
    k = 0;
    {
#line 579
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 579
      if (ok) {
#line 579
        if (! (k < vector)) {
#line 579
          goto while_break___4;
        }
      } else {
#line 579
        goto while_break___4;
      }
#line 581
      if (*(pos + k) == j) {
#line 582
        ok = 0;
      }
#line 579
      k ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 584
    if (ok) {
#line 586
      k = 0;
      {
#line 586
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 586
        if (! (k < t)) {
#line 586
          goto while_break___5;
        }
#line 588
        loc = j + *(from + k);
#line 589
        *(table + loc) = *(to + k);
#line 590
        *(check + loc) = *(from + k);
#line 591
        if (loc > high) {
#line 591
          high = loc;
        }
#line 586
        k ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 594
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 594
        if (! (*(check + lowzero) != -1)) {
#line 594
          goto while_break___6;
        }
#line 595
        lowzero ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 597
      return (j);
    }
    __Cont: /* CIL Label */ 
#line 549
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 604 "/home/june/collector/temp/btyacc-3.0/output.c"
void output_base(void) 
{ 
  register int i ;
  register int j ;

  {
#line 608
  if (! rflag) {
    {
#line 609
    fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"static ");
    }
  }
  {
#line 610
  fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"int yysindex[] = {%39d,",
          *(base + 0));
#line 611
  j = 10;
#line 612
  i = 1;
  }
  {
#line 612
  while (1) {
    while_continue: /* CIL Label */ ;
#line 612
    if (! (i < nstates)) {
#line 612
      goto while_break;
    }
#line 613
    if (j >= 10) {
#line 614
      if (! rflag) {
#line 614
        outline ++;
      }
      {
#line 615
      _IO_putc('\n', output_file);
#line 616
      j = 1;
      }
    } else {
#line 618
      j ++;
    }
    {
#line 619
    fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"%5d,",
            *(base + i));
#line 612
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 621
  if (! rflag) {
#line 621
    outline += 2;
  }
  {
#line 622
  fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"\n};\n");
  }
#line 623
  if (! rflag) {
    {
#line 624
    fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"static ");
    }
  }
  {
#line 625
  fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"int yyrindex[] = {%39d,",
          *(base + nstates));
#line 626
  j = 10;
#line 627
  i = nstates + 1;
  }
  {
#line 627
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 627
    if (! (i < 2 * nstates)) {
#line 627
      goto while_break___0;
    }
#line 628
    if (j >= 10) {
#line 629
      if (! rflag) {
#line 629
        outline ++;
      }
      {
#line 630
      _IO_putc('\n', output_file);
#line 631
      j = 1;
      }
    } else {
#line 633
      j ++;
    }
    {
#line 634
    fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"%5d,",
            *(base + i));
#line 627
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 636
  if (! rflag) {
#line 636
    outline += 2;
  }
  {
#line 637
  fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"\n};\n");
  }
#line 638
  if (! rflag) {
    {
#line 639
    fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"static ");
    }
  }
  {
#line 640
  fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"int yycindex[] = {%39d,",
          *(base + 2 * nstates));
#line 641
  j = 10;
#line 642
  i = 2 * nstates + 1;
  }
  {
#line 642
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 642
    if (! (i < 3 * nstates)) {
#line 642
      goto while_break___1;
    }
#line 643
    if (j >= 10) {
#line 644
      if (! rflag) {
#line 644
        outline ++;
      }
      {
#line 645
      _IO_putc('\n', output_file);
#line 646
      j = 1;
      }
    } else {
#line 648
      j ++;
    }
    {
#line 649
    fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"%5d,",
            *(base + i));
#line 642
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 652
  if (! rflag) {
#line 652
    outline += 2;
  }
  {
#line 653
  fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"\n};\n");
  }
#line 654
  if (! rflag) {
    {
#line 655
    fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"static ");
    }
  }
  {
#line 656
  fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"int yygindex[] = {%39d,",
          *(base + 3 * nstates));
#line 658
  j = 10;
#line 659
  i = 3 * nstates + 1;
  }
  {
#line 659
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 659
    if (! (i < nvectors - 1)) {
#line 659
      goto while_break___2;
    }
#line 660
    if (j >= 10) {
#line 661
      if (! rflag) {
#line 661
        outline ++;
      }
      {
#line 662
      _IO_putc('\n', output_file);
#line 663
      j = 1;
      }
    } else {
#line 665
      j ++;
    }
    {
#line 666
    fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"%5d,",
            *(base + i));
#line 659
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 668
  if (! rflag) {
#line 668
    outline += 2;
  }
  {
#line 669
  fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"\n};\n");
#line 670
  free((void *)((char *)base));
  }
#line 671
  return;
}
}
#line 675 "/home/june/collector/temp/btyacc-3.0/output.c"
void output_table(void) 
{ 
  register int i ;
  register int j ;

  {
  {
#line 680
  outline ++;
#line 682
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"YYTABLESIZE: %d\n",
          high);
  }
#line 683
  if (high >= 2147483647) {
    {
#line 684
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Table is longer than %d elements. It\'s not gonna fly.\n",
            2147483647);
#line 685
    exit(1);
    }
  }
  {
#line 688
  fprintf((FILE */* __restrict  */)code_file, (char const   */* __restrict  */)"#define YYTABLESIZE %d\n",
          high);
  }
#line 689
  if (! rflag) {
    {
#line 690
    fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"static ");
    }
  }
  {
#line 691
  fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"int yytable[] = {%40d,",
          *(table + 0));
#line 693
  j = 10;
#line 694
  i = 1;
  }
  {
#line 694
  while (1) {
    while_continue: /* CIL Label */ ;
#line 694
    if (! (i <= high)) {
#line 694
      goto while_break;
    }
#line 696
    if (j >= 10) {
#line 698
      if (! rflag) {
#line 698
        outline ++;
      }
      {
#line 699
      _IO_putc('\n', output_file);
#line 700
      j = 1;
      }
    } else {
#line 703
      j ++;
    }
    {
#line 705
    fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"%5d,",
            *(table + i));
#line 694
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 708
  if (! rflag) {
#line 708
    outline += 2;
  }
  {
#line 709
  fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"\n};\n");
#line 710
  free((void *)((char *)table));
  }
#line 711
  return;
}
}
#line 715 "/home/june/collector/temp/btyacc-3.0/output.c"
void output_check(void) 
{ 
  register int i ;
  register int j ;

  {
#line 720
  if (! rflag) {
    {
#line 721
    fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"static ");
    }
  }
  {
#line 722
  fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"int yycheck[] = {%40d,",
          *(check + 0));
#line 724
  j = 10;
#line 725
  i = 1;
  }
  {
#line 725
  while (1) {
    while_continue: /* CIL Label */ ;
#line 725
    if (! (i <= high)) {
#line 725
      goto while_break;
    }
#line 727
    if (j >= 10) {
#line 729
      if (! rflag) {
#line 729
        outline ++;
      }
      {
#line 730
      _IO_putc('\n', output_file);
#line 731
      j = 1;
      }
    } else {
#line 734
      j ++;
    }
    {
#line 736
    fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"%5d,",
            *(check + i));
#line 725
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 739
  if (! rflag) {
#line 739
    outline += 2;
  }
  {
#line 740
  fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"\n};\n");
#line 741
  free((void *)((char *)check));
  }
#line 742
  return;
}
}
#line 744 "/home/june/collector/temp/btyacc-3.0/output.c"
void output_ctable(void) 
{ 
  register int i ;
  register int j ;
  Yshort tmp ;

  {
#line 749
  if (! rflag) {
    {
#line 750
    fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"static ");
    }
  }
#line 751
  if (conflicts) {
#line 751
    tmp = *(conflicts + 0);
  } else {
#line 751
    tmp = 0;
  }
  {
#line 751
  fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"int yyctable[] = {%39d,",
          tmp);
#line 754
  j = 10;
#line 755
  i = 1;
  }
  {
#line 755
  while (1) {
    while_continue: /* CIL Label */ ;
#line 755
    if (! (i < nconflicts)) {
#line 755
      goto while_break;
    }
#line 757
    if (j >= 10) {
#line 759
      if (! rflag) {
#line 759
        outline ++;
      }
      {
#line 760
      _IO_putc('\n', output_file);
#line 761
      j = 1;
      }
    } else {
#line 764
      j ++;
    }
    {
#line 766
    fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"%5d,",
            *(conflicts + i));
#line 755
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 768
  if (! rflag) {
#line 768
    outline += 2;
  }
  {
#line 769
  fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"\n};\n");
  }
#line 770
  if (conflicts) {
    {
#line 771
    free((void *)((char *)conflicts));
    }
  }
#line 772
  return;
}
}
#line 775 "/home/june/collector/temp/btyacc-3.0/output.c"
int is_C_identifier(char *name ) 
{ 
  register char *s ;
  register int c ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
#line 780
  s = name;
#line 781
  c = (int )*s;
#line 782
  if (c == 34) {
    {
#line 784
    s ++;
#line 784
    c = (int )*s;
#line 785
    tmp = __ctype_b_loc();
    }
#line 785
    if (! ((int const   )*(*tmp + c) & 1024)) {
#line 785
      if (c != 95) {
#line 785
        if (c != 36) {
#line 786
          return (0);
        }
      }
    }
    {
#line 787
    while (1) {
      while_continue: /* CIL Label */ ;
#line 787
      s ++;
#line 787
      c = (int )*s;
#line 787
      if (! (c != 34)) {
#line 787
        goto while_break;
      }
      {
#line 789
      tmp___0 = __ctype_b_loc();
      }
#line 789
      if (! ((int const   )*(*tmp___0 + c) & 8)) {
#line 789
        if (c != 95) {
#line 789
          if (c != 36) {
#line 790
            return (0);
          }
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 792
    return (1);
  }
  {
#line 795
  tmp___1 = __ctype_b_loc();
  }
#line 795
  if (! ((int const   )*(*tmp___1 + c) & 1024)) {
#line 795
    if (c != 95) {
#line 795
      if (c != 36) {
#line 796
        return (0);
      }
    }
  }
  {
#line 797
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 797
    s ++;
#line 797
    c = (int )*s;
#line 797
    if (! c) {
#line 797
      goto while_break___0;
    }
    {
#line 799
    tmp___2 = __ctype_b_loc();
    }
#line 799
    if (! ((int const   )*(*tmp___2 + c) & 8)) {
#line 799
      if (c != 95) {
#line 799
        if (c != 36) {
#line 800
          return (0);
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 802
  return (1);
}
}
#line 806 "/home/june/collector/temp/btyacc-3.0/output.c"
void output_defines(void) 
{ 
  register int c ;
  register int i ;
  register char *s ;
  FILE *dc_file ;
  int tmp ;

  {
#line 812
  if (dflag) {
    {
#line 813
    fprintf((FILE */* __restrict  */)defines_file, (char const   */* __restrict  */)"#ifndef _yacc_defines_h_\n");
#line 814
    fprintf((FILE */* __restrict  */)defines_file, (char const   */* __restrict  */)"#define _yacc_defines_h_\n\n");
    }
  }
#line 818
  if (dflag) {
#line 818
    dc_file = defines_file;
  } else {
#line 818
    dc_file = code_file;
  }
#line 820
  i = 2;
  {
#line 820
  while (1) {
    while_continue: /* CIL Label */ ;
#line 820
    if (! (i < ntokens)) {
#line 820
      goto while_break;
    }
    {
#line 822
    s = *(symbol_name + i);
#line 823
    tmp = is_C_identifier(s);
    }
#line 823
    if (tmp) {
      {
#line 825
      fprintf((FILE */* __restrict  */)dc_file, (char const   */* __restrict  */)"#define ");
#line 826
      c = (int )*s;
      }
#line 827
      if (c == 34) {
        {
#line 829
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 829
          s ++;
#line 829
          c = (int )*s;
#line 829
          if (! (c != 34)) {
#line 829
            goto while_break___0;
          }
          {
#line 831
          _IO_putc(c, dc_file);
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      } else {
        {
#line 836
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 838
          _IO_putc(c, dc_file);
#line 836
          s ++;
#line 836
          c = (int )*s;
          }
#line 836
          if (! c) {
#line 836
            goto while_break___1;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      }
      {
#line 842
      outline ++;
#line 843
      fprintf((FILE */* __restrict  */)dc_file, (char const   */* __restrict  */)" %d\n",
              *(symbol_value + i));
      }
    }
#line 820
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 847
  outline ++;
#line 848
  fprintf((FILE */* __restrict  */)dc_file, (char const   */* __restrict  */)"#define YYERRCODE %d\n",
          *(symbol_value + 1));
  }
#line 850
  if (dflag) {
#line 850
    if (unionized) {
      {
#line 852
      rewind(union_file);
      }
      {
#line 853
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 853
        c = _IO_getc(union_file);
        }
#line 853
        if (! (c != -1)) {
#line 853
          goto while_break___2;
        }
        {
#line 854
        _IO_putc(c, defines_file);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 856
      fprintf((FILE */* __restrict  */)defines_file, (char const   */* __restrict  */)"extern YYSTYPE yylval;\n");
      }
    }
  }
#line 859
  if (dflag) {
    {
#line 860
    fprintf((FILE */* __restrict  */)defines_file, (char const   */* __restrict  */)"\n#endif\n");
    }
  }
#line 862
  return;
}
}
#line 865 "/home/june/collector/temp/btyacc-3.0/output.c"
void output_stored_text(void) 
{ 
  register int c ;
  register FILE *in ;
  register FILE *out ;
  register int state ;

  {
  {
#line 871
  state = 1;
#line 872
  rewind(text_file);
#line 873
  in = text_file;
#line 874
  c = _IO_getc(in);
  }
#line 874
  if (c == -1) {
#line 875
    return;
  }
#line 876
  out = code_file;
  {
#line 877
  while (1) {
    while_continue: /* CIL Label */ ;
#line 878
    if (c == 10) {
#line 879
      outline ++;
#line 880
      if (state == 2) {
        {
#line 881
        fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)(line_format + 1),
                outline + 1, code_file_name);
#line 882
        state = 1;
        }
#line 883
        goto __Cont;
      }
#line 884
      state = 1;
    } else
#line 885
    if (state == 1) {
#line 885
      if (c == 35) {
#line 886
        state = 2;
      } else {
#line 888
        state = 0;
      }
    } else {
#line 888
      state = 0;
    }
    {
#line 889
    _IO_putc(c, out);
    }
    __Cont: /* CIL Label */ 
    {
#line 877
    c = _IO_getc(in);
    }
#line 877
    if (! (c != -1)) {
#line 877
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 891
  if (! lflag) {
    {
#line 892
    outline ++;
#line 892
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)(line_format),
            outline + 1, code_file_name);
    }
  }
#line 893
  return;
}
}
#line 896 "/home/june/collector/temp/btyacc-3.0/output.c"
void output_debug(void) 
{ 
  register int i ;
  register int j ;
  register int k ;
  register int max ;
  char **symnam ;
  char *s ;
  void *tmp ;
  size_t tmp___0 ;

  {
  {
#line 901
  outline ++;
#line 902
  fprintf((FILE */* __restrict  */)code_file, (char const   */* __restrict  */)"#define YYFINAL %d\n",
          final_state);
#line 903
  outline += 3;
#line 904
  fprintf((FILE */* __restrict  */)code_file, (char const   */* __restrict  */)"#ifndef YYDEBUG\n#define YYDEBUG %d\n#endif\n",
          (int )tflag);
  }
#line 906
  if (rflag) {
    {
#line 907
    fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"#ifndef YYDEBUG\n#define YYDEBUG %d\n#endif\n",
            (int )tflag);
    }
  }
#line 910
  max = 0;
#line 911
  i = 2;
  {
#line 911
  while (1) {
    while_continue: /* CIL Label */ ;
#line 911
    if (! (i < ntokens)) {
#line 911
      goto while_break;
    }
#line 912
    if (*(symbol_value + i) > max) {
#line 913
      max = *(symbol_value + i);
    }
#line 911
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 914
  outline ++;
#line 915
  fprintf((FILE */* __restrict  */)code_file, (char const   */* __restrict  */)"#define YYMAXTOKEN %d\n",
          max);
#line 917
  tmp = malloc((size_t )((unsigned int )((unsigned long )(max + 1) * sizeof(char *))));
#line 917
  symnam = (char **)tmp;
  }
#line 918
  if ((unsigned long )symnam == (unsigned long )((char **)0)) {
    {
#line 918
    no_space();
    }
  }
#line 922
  i = 0;
  {
#line 922
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 922
    if (! (i < max)) {
#line 922
      goto while_break___0;
    }
#line 923
    *(symnam + i) = (char *)0;
#line 922
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 924
  i = ntokens - 1;
  {
#line 924
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 924
    if (! (i >= 2)) {
#line 924
      goto while_break___1;
    }
#line 925
    *(symnam + *(symbol_value + i)) = *(symbol_name + i);
#line 924
    i --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 926
  *(symnam + 0) = (char *)"end-of-file";
#line 928
  if (! rflag) {
#line 928
    outline ++;
  }
  {
#line 929
  fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"#if YYDEBUG\n");
  }
#line 930
  if (! rflag) {
    {
#line 931
    fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"static ");
    }
  }
  {
#line 932
  fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"char *yyname[] = {");
#line 933
  j = 80;
#line 934
  i = 0;
  }
  {
#line 934
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 934
    if (! (i <= max)) {
#line 934
      goto while_break___2;
    }
#line 936
    s = *(symnam + i);
#line 936
    if (s) {
#line 938
      if ((int )*(s + 0) == 34) {
#line 940
        k = 7;
        {
#line 941
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 941
          s ++;
#line 941
          if (! ((int )*s != 34)) {
#line 941
            goto while_break___3;
          }
#line 943
          k ++;
#line 944
          if ((int )*s == 92) {
#line 946
            k += 2;
#line 947
            s ++;
#line 947
            if ((int )*s == 92) {
#line 948
              k ++;
            }
          }
        }
        while_break___3: /* CIL Label */ ;
        }
#line 951
        j += k;
#line 952
        if (j > 80) {
#line 954
          if (! rflag) {
#line 954
            outline ++;
          }
          {
#line 955
          _IO_putc('\n', output_file);
#line 956
          j = k;
          }
        }
        {
#line 958
        fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"\"\\\"");
#line 959
        s = *(symnam + i);
        }
        {
#line 960
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 960
          s ++;
#line 960
          if (! ((int )*s != 34)) {
#line 960
            goto while_break___4;
          }
#line 962
          if ((int )*s == 92) {
            {
#line 964
            fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"\\\\");
#line 965
            s ++;
            }
#line 965
            if ((int )*s == 92) {
              {
#line 966
              fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"\\\\");
              }
            } else {
              {
#line 968
              _IO_putc((int )*s, output_file);
              }
            }
          } else {
            {
#line 971
            _IO_putc((int )*s, output_file);
            }
          }
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 973
        fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"\\\"\",");
        }
      } else
#line 975
      if ((int )*(s + 0) == 39) {
#line 977
        if ((int )*(s + 1) == 34) {
#line 979
          j += 7;
#line 980
          if (j > 80) {
#line 982
            if (! rflag) {
#line 982
              outline ++;
            }
            {
#line 983
            _IO_putc('\n', output_file);
#line 984
            j = 7;
            }
          }
          {
#line 986
          fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"\"\'\\\"\'\",");
          }
        } else {
#line 990
          k = 5;
          {
#line 991
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 991
            s ++;
#line 991
            if (! ((int )*s != 39)) {
#line 991
              goto while_break___5;
            }
#line 993
            k ++;
#line 994
            if ((int )*s == 92) {
#line 996
              k += 2;
#line 997
              s ++;
#line 997
              if ((int )*s == 92) {
#line 998
                k ++;
              }
            }
          }
          while_break___5: /* CIL Label */ ;
          }
#line 1001
          j += k;
#line 1002
          if (j > 80) {
#line 1004
            if (! rflag) {
#line 1004
              outline ++;
            }
            {
#line 1005
            _IO_putc('\n', output_file);
#line 1006
            j = k;
            }
          }
          {
#line 1008
          fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"\"\'");
#line 1009
          s = *(symnam + i);
          }
          {
#line 1010
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 1010
            s ++;
#line 1010
            if (! ((int )*s != 39)) {
#line 1010
              goto while_break___6;
            }
#line 1012
            if ((int )*s == 92) {
              {
#line 1014
              fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"\\\\");
#line 1015
              s ++;
              }
#line 1015
              if ((int )*s == 92) {
                {
#line 1016
                fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"\\\\");
                }
              } else {
                {
#line 1018
                _IO_putc((int )*s, output_file);
                }
              }
            } else {
              {
#line 1021
              _IO_putc((int )*s, output_file);
              }
            }
          }
          while_break___6: /* CIL Label */ ;
          }
          {
#line 1023
          fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"\'\",");
          }
        }
      } else {
        {
#line 1028
        tmp___0 = strlen((char const   *)s);
#line 1028
        k = (int )(tmp___0 + 3UL);
#line 1029
        j += k;
        }
#line 1030
        if (j > 80) {
#line 1032
          if (! rflag) {
#line 1032
            outline ++;
          }
          {
#line 1033
          _IO_putc('\n', output_file);
#line 1034
          j = k;
          }
        }
        {
#line 1036
        _IO_putc('\"', output_file);
        }
        {
#line 1037
        while (1) {
          while_continue___7: /* CIL Label */ ;
          {
#line 1037
          _IO_putc((int )*s, output_file);
#line 1037
          s ++;
          }
#line 1037
          if (! *s) {
#line 1037
            goto while_break___7;
          }
        }
        while_break___7: /* CIL Label */ ;
        }
        {
#line 1038
        fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"\",");
        }
      }
    } else {
#line 1043
      j += 2;
#line 1044
      if (j > 80) {
#line 1046
        if (! rflag) {
#line 1046
          outline ++;
        }
        {
#line 1047
        _IO_putc('\n', output_file);
#line 1048
        j = 2;
        }
      }
      {
#line 1050
      fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"0,");
      }
    }
#line 934
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1053
  if (! rflag) {
#line 1053
    outline += 2;
  }
  {
#line 1054
  fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"\n};\n");
#line 1055
  free((void *)((char *)symnam));
  }
#line 1057
  if (! rflag) {
#line 1057
    outline ++;
  }
#line 1058
  if (! rflag) {
    {
#line 1059
    fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"static ");
    }
  }
  {
#line 1060
  fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"char *yyrule[] = {\n");
#line 1061
  i = 2;
  }
  {
#line 1061
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 1061
    if (! (i < nrules)) {
#line 1061
      goto while_break___8;
    }
    {
#line 1063
    fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"\"%s :",
            *(symbol_name + *(rlhs + i)));
#line 1064
    j = *(rrhs + i);
    }
    {
#line 1064
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 1064
      if (! (*(ritem + j) > 0)) {
#line 1064
        goto while_break___9;
      }
#line 1066
      s = *(symbol_name + *(ritem + j));
#line 1067
      if ((int )*(s + 0) == 34) {
        {
#line 1069
        fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)" \\\"");
        }
        {
#line 1070
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 1070
          s ++;
#line 1070
          if (! ((int )*s != 34)) {
#line 1070
            goto while_break___10;
          }
#line 1072
          if ((int )*s == 92) {
#line 1074
            if ((int )*(s + 1) == 92) {
              {
#line 1075
              fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"\\\\\\\\");
              }
            } else {
              {
#line 1077
              fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"\\\\%c",
                      (int )*(s + 1));
              }
            }
#line 1078
            s ++;
          } else {
            {
#line 1081
            _IO_putc((int )*s, output_file);
            }
          }
        }
        while_break___10: /* CIL Label */ ;
        }
        {
#line 1083
        fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"\\\"");
        }
      } else
#line 1085
      if ((int )*(s + 0) == 39) {
#line 1087
        if ((int )*(s + 1) == 34) {
          {
#line 1088
          fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)" \'\\\"\'");
          }
        } else
#line 1089
        if ((int )*(s + 1) == 92) {
#line 1091
          if ((int )*(s + 2) == 92) {
            {
#line 1092
            fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)" \'\\\\\\\\");
            }
          } else {
            {
#line 1094
            fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)" \'\\\\%c",
                    (int )*(s + 2));
            }
          }
#line 1095
          s += 2;
          {
#line 1096
          while (1) {
            while_continue___11: /* CIL Label */ ;
#line 1096
            s ++;
#line 1096
            if (! ((int )*s != 39)) {
#line 1096
              goto while_break___11;
            }
            {
#line 1097
            _IO_putc((int )*s, output_file);
            }
          }
          while_break___11: /* CIL Label */ ;
          }
          {
#line 1098
          _IO_putc('\'', output_file);
          }
        } else {
          {
#line 1101
          fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)" \'%c\'",
                  (int )*(s + 1));
          }
        }
      } else {
        {
#line 1104
        fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)" %s",
                s);
        }
      }
#line 1064
      j ++;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 1106
    if (! rflag) {
#line 1106
      outline ++;
    }
    {
#line 1107
    fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"\",\n");
#line 1061
    i ++;
    }
  }
  while_break___8: /* CIL Label */ ;
  }
#line 1110
  if (! rflag) {
#line 1110
    outline += 2;
  }
  {
#line 1111
  fprintf((FILE */* __restrict  */)output_file, (char const   */* __restrict  */)"};\n#endif\n");
  }
#line 1112
  return;
}
}
#line 1115 "/home/june/collector/temp/btyacc-3.0/output.c"
void output_stype(void) 
{ 


  {
#line 1117
  if (! unionized) {
#line 1117
    if (ntags == 0) {
      {
#line 1119
      outline += 3;
#line 1120
      fprintf((FILE */* __restrict  */)code_file, (char const   */* __restrict  */)"#ifndef YYSTYPE\ntypedef int YYSTYPE;\n#endif\n");
      }
    }
  }
#line 1122
  return;
}
}
#line 1125 "/home/june/collector/temp/btyacc-3.0/output.c"
void output_trailing_text(void) 
{ 
  register int c ;
  register int last ;
  register FILE *in ;
  register FILE *out ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 1130
  if ((unsigned long )line == (unsigned long )((char *)0)) {
#line 1131
    return;
  }
#line 1133
  in = input_file;
#line 1134
  out = code_file;
#line 1135
  c = (int )*cptr;
#line 1136
  if (c == 10) {
    {
#line 1138
    lineno ++;
#line 1139
    c = _IO_getc(in);
    }
#line 1139
    if (c == -1) {
#line 1140
      return;
    }
#line 1141
    if (! lflag) {
#line 1143
      outline ++;
#line 1144
      if (inc_file) {
#line 1144
        tmp = inc_file_name;
      } else {
#line 1144
        tmp = input_file_name;
      }
      {
#line 1144
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)(line_format),
              lineno, tmp);
      }
    }
#line 1146
    if (c == 10) {
#line 1147
      outline ++;
    }
    {
#line 1148
    _IO_putc(c, out);
#line 1149
    last = c;
    }
  } else {
#line 1153
    if (! lflag) {
#line 1155
      outline ++;
#line 1156
      if (inc_file) {
#line 1156
        tmp___0 = inc_file_name;
      } else {
#line 1156
        tmp___0 = input_file_name;
      }
      {
#line 1156
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)(line_format),
              lineno, tmp___0);
      }
    }
    {
#line 1158
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1158
      _IO_putc(c, out);
#line 1158
      cptr ++;
#line 1158
      c = (int )*cptr;
      }
#line 1158
      if (! (c != 10)) {
#line 1158
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1159
    outline ++;
#line 1160
    _IO_putc('\n', out);
#line 1161
    last = '\n';
    }
  }
  {
#line 1164
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1164
    c = _IO_getc(in);
    }
#line 1164
    if (! (c != -1)) {
#line 1164
      goto while_break___0;
    }
#line 1166
    if (c == 10) {
#line 1167
      outline ++;
    }
    {
#line 1168
    _IO_putc(c, out);
#line 1169
    last = c;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1172
  if (last != 10) {
    {
#line 1174
    outline ++;
#line 1175
    _IO_putc('\n', out);
    }
  }
#line 1177
  if (! lflag) {
    {
#line 1178
    outline ++;
#line 1178
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)(line_format),
            outline + 1, code_file_name);
    }
  }
#line 1179
  return;
}
}
#line 1182 "/home/june/collector/temp/btyacc-3.0/output.c"
void output_semantic_actions(void) 
{ 
  register int c ;
  register int last ;
  register FILE *out ;
  register int state ;

  {
  {
#line 1188
  state = 1;
#line 1189
  rewind(action_file);
#line 1190
  c = _IO_getc(action_file);
  }
#line 1190
  if (c == -1) {
#line 1191
    return;
  }
#line 1193
  out = code_file;
  {
#line 1194
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1195
    last = c;
#line 1196
    if (c == 10) {
#line 1197
      outline ++;
#line 1198
      if (state == 2) {
        {
#line 1199
        fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)(line_format + 1),
                outline + 1, code_file_name);
#line 1200
        state = 1;
        }
#line 1201
        goto __Cont;
      }
#line 1202
      state = 1;
    } else
#line 1203
    if (state == 1) {
#line 1203
      if (c == 35) {
#line 1204
        state = 2;
      } else {
#line 1206
        state = 0;
      }
    } else {
#line 1206
      state = 0;
    }
    {
#line 1207
    _IO_putc(c, out);
    }
    __Cont: /* CIL Label */ 
    {
#line 1194
    c = _IO_getc(action_file);
    }
#line 1194
    if (! (c != -1)) {
#line 1194
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1210
  if (last != 10) {
    {
#line 1212
    outline ++;
#line 1213
    _IO_putc('\n', out);
    }
  }
#line 1216
  if (! lflag) {
    {
#line 1217
    outline ++;
#line 1217
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)(line_format),
            outline + 1, code_file_name);
    }
  }
#line 1218
  return;
}
}
#line 1221 "/home/june/collector/temp/btyacc-3.0/output.c"
void free_itemsets(void) 
{ 
  register core *cp___0 ;
  register core *next ;

  {
  {
#line 1225
  free((void *)((char *)state_table));
#line 1226
  cp___0 = first_state;
  }
  {
#line 1226
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1226
    if (! cp___0) {
#line 1226
      goto while_break;
    }
    {
#line 1228
    next = cp___0->next;
#line 1229
    free((void *)((char *)cp___0));
#line 1226
    cp___0 = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1231
  return;
}
}
#line 1234 "/home/june/collector/temp/btyacc-3.0/output.c"
void free_shifts(void) 
{ 
  register shifts *sp ;
  register shifts *next ;

  {
  {
#line 1238
  free((void *)((char *)shift_table));
#line 1239
  sp = first_shift;
  }
  {
#line 1239
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1239
    if (! sp) {
#line 1239
      goto while_break;
    }
    {
#line 1241
    next = sp->next;
#line 1242
    free((void *)((char *)sp));
#line 1239
    sp = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1244
  return;
}
}
#line 1248 "/home/june/collector/temp/btyacc-3.0/output.c"
void free_reductions(void) 
{ 
  register reductions *rp ;
  register reductions *next ;

  {
  {
#line 1252
  free((void *)((char *)reduction_table));
#line 1253
  rp = first_reduction;
  }
  {
#line 1253
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1253
    if (! rp) {
#line 1253
      goto while_break;
    }
    {
#line 1255
    next = rp->next;
#line 1256
    free((void *)((char *)rp));
#line 1253
    rp = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1258
  return;
}
}
#line 1262 "/home/june/collector/temp/btyacc-3.0/output.c"
void write_section(char *section_name ) 
{ 
  char **section ;
  FILE *fp ;
  int i ;
  struct section *sl ;
  int tmp ;

  {
#line 1269
  sl = & section_list[0];
  {
#line 1269
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1269
    if (! sl->name) {
#line 1269
      goto while_break;
    }
    {
#line 1270
    tmp = strcmp((char const   *)sl->name, (char const   *)section_name);
    }
#line 1270
    if (tmp == 0) {
#line 1271
      goto while_break;
    }
#line 1269
    sl ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1274
  if ((unsigned long )sl->name == (unsigned long )((char *)0)) {
    {
#line 1275
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot find section \'%s\' in your skeleton file\n",
            section_name);
#line 1276
    exit(1);
    }
  }
#line 1279
  section = sl->ptr;
#line 1280
  fp = code_file;
#line 1281
  if (lflag) {
#line 1281
    i = 1;
  } else {
#line 1281
    i = 0;
  }
  {
#line 1281
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1281
    if (! *(section + i)) {
#line 1281
      goto while_break___0;
    }
    {
#line 1283
    outline ++;
#line 1284
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s\n",
            *(section + i));
#line 1281
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1286
  return;
}
}
#line 15 "/home/june/collector/temp/btyacc-3.0/mstring.c"
static char buf[4096]  ;
#line 13 "/home/june/collector/temp/btyacc-3.0/mstring.c"
void msprintf(struct mstring *s , char const   *fmt  , ...) 
{ 
  va_list args ;
  int len ;
  size_t tmp ;
  int cp___0 ;
  int cl ;
  int nl ;
  char *tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;

  {
#line 19
  if (! s) {
#line 19
    return;
  } else
#line 19
  if (! s->base) {
#line 19
    return;
  }
  {
#line 20
  __builtin_va_start(args, fmt);
#line 21
  vsprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)fmt, args);
#line 22
  __builtin_va_end(args);
#line 24
  tmp = strlen((char const   *)(buf));
#line 24
  len = (int )tmp;
  }
#line 25
  if ((long )len > s->end - s->ptr) {
#line 26
    cp___0 = (int )(s->ptr - s->base);
#line 26
    cl = (int )(s->end - s->base);
#line 26
    nl = cl;
    {
#line 27
    while (1) {
      while_continue: /* CIL Label */ ;
#line 27
      if (! (len > nl - cp___0)) {
#line 27
        goto while_break;
      }
#line 28
      nl = (nl + nl) + 8;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 29
    tmp___2 = realloc((void *)s->base, (size_t )nl);
#line 29
    tmp___1 = (char *)tmp___2;
#line 29
    s->base = tmp___1;
    }
#line 29
    if (tmp___1) {
#line 30
      s->ptr = s->base + cp___0;
#line 31
      s->end = s->base + nl;
    } else {
#line 33
      tmp___0 = (char *)0;
#line 33
      s->end = tmp___0;
#line 33
      s->ptr = tmp___0;
#line 34
      return;
    }
  }
  {
#line 35
  memcpy((void */* __restrict  */)s->ptr, (void const   */* __restrict  */)(buf),
         (size_t )len);
#line 36
  s->ptr += len;
  }
#line 37
  return;
}
}
#line 39 "/home/june/collector/temp/btyacc-3.0/mstring.c"
int mputchar(struct mstring *s , int ch ) 
{ 
  int len ;
  char *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;

  {
#line 41
  if (! s) {
#line 41
    return (ch);
  } else
#line 41
  if (! s->base) {
#line 41
    return (ch);
  }
#line 42
  if ((unsigned long )s->ptr == (unsigned long )s->end) {
    {
#line 43
    len = (int )(s->end - s->base);
#line 44
    tmp___1 = realloc((void *)s->base, (size_t )((len + len) + 8));
#line 44
    tmp___0 = (char *)tmp___1;
#line 44
    s->base = tmp___0;
    }
#line 44
    if (tmp___0) {
#line 45
      s->ptr = s->base + len;
#line 46
      s->end = ((s->base + len) + len) + 8;
    } else {
#line 48
      tmp = (char *)0;
#line 48
      s->end = tmp;
#line 48
      s->ptr = tmp;
#line 49
      return (ch);
    }
  }
#line 50
  tmp___2 = s->ptr;
#line 50
  (s->ptr) ++;
#line 50
  *tmp___2 = (char )ch;
#line 51
  return (ch);
}
}
#line 54 "/home/june/collector/temp/btyacc-3.0/mstring.c"
struct mstring *msnew(void) 
{ 
  struct mstring *n ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 55
  tmp = malloc(sizeof(struct mstring ));
#line 55
  n = (struct mstring *)tmp;
  }
#line 57
  if (n) {
    {
#line 57
    tmp___2 = malloc((size_t )24);
#line 57
    tmp___1 = (char *)tmp___2;
#line 57
    n->ptr = tmp___1;
#line 57
    tmp___0 = tmp___1;
#line 57
    n->base = tmp___0;
    }
#line 57
    if (tmp___0) {
#line 58
      n->end = n->base + 24;
    } else {
#line 57
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 59
  if (n) {
    {
#line 60
    free((void *)n);
#line 61
    n = (struct mstring *)0;
    }
  }
#line 62
  return (n);
}
}
#line 65 "/home/june/collector/temp/btyacc-3.0/mstring.c"
char *msdone(struct mstring *s ) 
{ 
  char *r ;
  char *tmp ;

  {
#line 67
  r = (char *)0;
#line 68
  if (s) {
#line 69
    if ((unsigned long )s->ptr == (unsigned long )s->end) {
      {
#line 69
      mputchar(s, 0);
      }
    } else {
#line 69
      tmp = s->ptr;
#line 69
      (s->ptr) ++;
#line 69
      *tmp = (char)0;
    }
    {
#line 70
    r = s->base;
#line 71
    free((void *)s);
    }
  }
#line 72
  return (r);
}
}
#line 77 "/home/june/collector/temp/btyacc-3.0/mstring.c"
int strnscmp(char const   *a , char const   *b ) 
{ 
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;

  {
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 80
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 80
      tmp = __ctype_b_loc();
      }
#line 80
      if (! ((int const   )*(*tmp + (int )*a) & 8192)) {
#line 80
        goto while_break___0;
      }
#line 80
      a ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 81
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 81
      tmp___0 = __ctype_b_loc();
      }
#line 81
      if (! ((int const   )*(*tmp___0 + (int )*b) & 8192)) {
#line 81
        goto while_break___1;
      }
#line 81
      b ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 82
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 82
      if (*a) {
#line 82
        if (! ((int const   )*a == (int const   )*b)) {
#line 82
          goto while_break___2;
        }
      } else {
#line 82
        goto while_break___2;
      }
#line 82
      a ++;
#line 82
      b ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 83
    tmp___6 = __ctype_b_loc();
    }
#line 83
    if ((int const   )*(*tmp___6 + (int )*a) & 8192) {
      {
#line 84
      tmp___1 = __ctype_b_loc();
      }
#line 84
      if ((int const   )*(*tmp___1 + (int )*(a + -1)) & 8) {
        {
#line 84
        tmp___2 = __ctype_b_loc();
        }
#line 84
        if ((int const   )*(*tmp___2 + (int )*b) & 8) {
#line 85
          goto while_break;
        }
      }
    } else {
      {
#line 86
      tmp___5 = __ctype_b_loc();
      }
#line 86
      if ((int const   )*(*tmp___5 + (int )*b) & 8192) {
        {
#line 87
        tmp___3 = __ctype_b_loc();
        }
#line 87
        if ((int const   )*(*tmp___3 + (int )*(b + -1)) & 8) {
          {
#line 87
          tmp___4 = __ctype_b_loc();
          }
#line 87
          if ((int const   )*(*tmp___4 + (int )*a) & 8) {
#line 88
            goto while_break;
          }
        }
      } else {
#line 90
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 91
  return ((int )((int const   )*a - (int const   )*b));
}
}
#line 94 "/home/june/collector/temp/btyacc-3.0/mstring.c"
unsigned int strnshash(char const   *s ) 
{ 
  unsigned int h ;
  unsigned short const   **tmp ;

  {
#line 96
  h = 0U;
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! *s) {
#line 98
      goto while_break;
    }
    {
#line 99
    tmp = __ctype_b_loc();
    }
#line 99
    if (! ((int const   )*(*tmp + (int )*s) & 8192)) {
#line 100
      h = ((h << 5) - h) + (unsigned int )*s;
    }
#line 101
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  return (h);
}
}
#line 271 "/home/june/collector/temp/btyacc-3.0/defs.h"
bucket *first_symbol  ;
#line 272 "/home/june/collector/temp/btyacc-3.0/defs.h"
bucket *last_symbol  ;
#line 494
int hash(char *name ) ;
#line 10 "/home/june/collector/temp/btyacc-3.0/symtab.c"
bucket **symbol_table  ;
#line 15 "/home/june/collector/temp/btyacc-3.0/symtab.c"
int hash(char *name ) 
{ 
  register char *s ;
  register int c ;
  register int k ;

  {
#line 20
  if (name) {
#line 20
    if (! *name) {
      {
#line 20
      __assert_fail("name && *name", "/home/june/collector/temp/btyacc-3.0/symtab.c",
                    20U, "hash");
      }
    }
  } else {
    {
#line 20
    __assert_fail("name && *name", "/home/june/collector/temp/btyacc-3.0/symtab.c",
                  20U, "hash");
    }
  }
#line 21
  s = name;
#line 22
  k = (int )*s;
  {
#line 23
  while (1) {
    while_continue: /* CIL Label */ ;
#line 23
    s ++;
#line 23
    c = (int )*s;
#line 23
    if (! c) {
#line 23
      goto while_break;
    }
#line 24
    k = (31 * k + c) & 1023;
  }
  while_break: /* CIL Label */ ;
  }
#line 26
  return (k);
}
}
#line 30 "/home/june/collector/temp/btyacc-3.0/symtab.c"
bucket *make_bucket(char *name ) 
{ 
  register bucket *bp ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 34
  if (! name) {
    {
#line 34
    __assert_fail("name", "/home/june/collector/temp/btyacc-3.0/symtab.c", 34U, "make_bucket");
    }
  }
  {
#line 35
  tmp = malloc((size_t )((unsigned int )sizeof(bucket )));
#line 35
  bp = (bucket *)tmp;
  }
#line 36
  if ((unsigned long )bp == (unsigned long )((bucket *)0)) {
    {
#line 36
    no_space();
    }
  }
  {
#line 37
  bp->link = (struct bucket *)0;
#line 38
  bp->next = (struct bucket *)0;
#line 39
  tmp___0 = strlen((char const   *)name);
#line 39
  tmp___1 = malloc((size_t )((unsigned int )(tmp___0 + 1UL)));
#line 39
  bp->name = (char *)tmp___1;
  }
#line 40
  if ((unsigned long )bp->name == (unsigned long )((char *)0)) {
    {
#line 40
    no_space();
    }
  }
#line 41
  bp->tag = (char *)0;
#line 42
  bp->value = -1;
#line 43
  bp->index = 0;
#line 44
  bp->prec = 0;
#line 45
  bp->class = (char)0;
#line 46
  bp->assoc = (char)0;
#line 47
  bp->args = -1;
#line 48
  bp->argnames = (char **)0;
#line 49
  bp->argtags = (char **)0;
#line 51
  if ((unsigned long )bp->name == (unsigned long )((char *)0)) {
    {
#line 51
    no_space();
    }
  }
  {
#line 52
  strcpy((char */* __restrict  */)bp->name, (char const   */* __restrict  */)name);
  }
#line 54
  return (bp);
}
}
#line 58 "/home/june/collector/temp/btyacc-3.0/symtab.c"
bucket *lookup(char *name ) 
{ 
  register bucket *bp ;
  register bucket **bpp ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 62
  tmp = hash(name);
#line 62
  bpp = symbol_table + tmp;
#line 63
  bp = *bpp;
  }
  {
#line 65
  while (1) {
    while_continue: /* CIL Label */ ;
#line 65
    if (! bp) {
#line 65
      goto while_break;
    }
    {
#line 67
    tmp___0 = strcmp((char const   *)name, (char const   *)bp->name);
    }
#line 67
    if (tmp___0 == 0) {
#line 67
      return (bp);
    }
#line 68
    bpp = & bp->link;
#line 69
    bp = *bpp;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 72
  bp = make_bucket(name);
#line 72
  *bpp = bp;
#line 73
  last_symbol->next = bp;
#line 74
  last_symbol = bp;
  }
#line 76
  return (bp);
}
}
#line 80 "/home/june/collector/temp/btyacc-3.0/symtab.c"
void create_symbol_table(void) 
{ 
  register int i ;
  register bucket *bp ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 85
  tmp = malloc((size_t )((unsigned int )(1024UL * sizeof(bucket *))));
#line 85
  symbol_table = (bucket **)tmp;
  }
#line 86
  if ((unsigned long )symbol_table == (unsigned long )((bucket **)0)) {
    {
#line 86
    no_space();
    }
  }
#line 87
  i = 0;
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
#line 87
    if (! (i < 1024)) {
#line 87
      goto while_break;
    }
#line 88
    *(symbol_table + i) = (bucket *)0;
#line 87
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 90
  bp = make_bucket((char *)"error");
#line 91
  bp->index = 1;
#line 92
  bp->class = (char)1;
#line 94
  first_symbol = bp;
#line 95
  last_symbol = bp;
#line 96
  tmp___0 = hash((char *)"error");
#line 96
  *(symbol_table + tmp___0) = bp;
  }
#line 97
  return;
}
}
#line 100 "/home/june/collector/temp/btyacc-3.0/symtab.c"
void free_symbol_table(void) 
{ 


  {
  {
#line 102
  free((void *)((char *)symbol_table));
#line 103
  symbol_table = (bucket **)0;
  }
#line 104
  return;
}
}
#line 107 "/home/june/collector/temp/btyacc-3.0/symtab.c"
void free_symbols(void) 
{ 
  register bucket *p ;
  register bucket *q ;

  {
#line 111
  p = first_symbol;
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    if (! p) {
#line 111
      goto while_break;
    }
    {
#line 113
    q = p->next;
#line 114
    free((void *)((char *)p));
#line 111
    p = q;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 116
  return;
}
}
#line 305 "/home/june/collector/temp/btyacc-3.0/defs.h"
void set_EFF(void) ;
#line 3 "/home/june/collector/temp/btyacc-3.0/closure.c"
Yshort *itemset  ;
#line 4 "/home/june/collector/temp/btyacc-3.0/closure.c"
Yshort *itemsetend  ;
#line 5 "/home/june/collector/temp/btyacc-3.0/closure.c"
unsigned int *ruleset  ;
#line 7 "/home/june/collector/temp/btyacc-3.0/closure.c"
static unsigned int *first_derives  ;
#line 8 "/home/june/collector/temp/btyacc-3.0/closure.c"
static unsigned int *EFF  ;
#line 11 "/home/june/collector/temp/btyacc-3.0/closure.c"
void set_EFF(void) 
{ 
  register unsigned int *row ;
  register int symbol ;
  register Yshort *sp ;
  register int rowsize ;
  register int i ;
  register int rule ;
  char *tmp ;

  {
  {
#line 20
  rowsize = (nvars + 31) / 32;
#line 21
  tmp = allocate((unsigned int )((unsigned long )(nvars * rowsize) * sizeof(unsigned int )));
#line 21
  EFF = (unsigned int *)tmp;
#line 23
  row = EFF;
#line 24
  i = start_symbol;
  }
  {
#line 24
  while (1) {
    while_continue: /* CIL Label */ ;
#line 24
    if (! (i < nsyms)) {
#line 24
      goto while_break;
    }
#line 26
    sp = *(derives + i);
#line 27
    rule = *sp;
    {
#line 27
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 27
      if (! (rule > 0)) {
#line 27
        goto while_break___0;
      }
#line 29
      symbol = *(ritem + *(rrhs + rule));
#line 30
      if (symbol >= start_symbol) {
#line 32
        symbol -= start_symbol;
#line 33
        *(row + (symbol >> 5)) |= 1U << (symbol & 31);
      }
#line 27
      sp ++;
#line 27
      rule = *sp;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 36
    row += rowsize;
#line 24
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 39
  reflexive_transitive_closure(EFF, nvars);
  }
#line 44
  return;
}
}
#line 47 "/home/june/collector/temp/btyacc-3.0/closure.c"
void set_first_derives(void) 
{ 
  register unsigned int *rrow ;
  register unsigned int *vrow ;
  register int j ;
  register unsigned int mask ;
  register unsigned int cword ;
  register Yshort *rp ;
  int rule ;
  int i ;
  int rulesetsize ;
  int varsetsize ;
  char *tmp ;
  unsigned int *tmp___0 ;
  Yshort *tmp___1 ;
  unsigned int *tmp___2 ;

  {
  {
#line 61
  rulesetsize = (nrules + 31) / 32;
#line 62
  varsetsize = (nvars + 31) / 32;
#line 63
  tmp = allocate((unsigned int )((unsigned long )(nvars * rulesetsize) * sizeof(unsigned int )));
#line 63
  first_derives = (unsigned int *)tmp - ntokens * rulesetsize;
#line 65
  set_EFF();
#line 67
  rrow = first_derives + ntokens * rulesetsize;
#line 68
  i = start_symbol;
  }
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
#line 68
    if (! (i < nsyms)) {
#line 68
      goto while_break;
    }
#line 70
    vrow = EFF + (i - ntokens) * varsetsize;
#line 71
    tmp___0 = vrow;
#line 71
    vrow ++;
#line 71
    cword = *tmp___0;
#line 72
    mask = 1U;
#line 73
    j = start_symbol;
    {
#line 73
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 73
      if (! (j < nsyms)) {
#line 73
        goto while_break___0;
      }
#line 75
      if (cword & mask) {
#line 77
        rp = *(derives + j);
        {
#line 78
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 78
          tmp___1 = rp;
#line 78
          rp ++;
#line 78
          rule = *tmp___1;
#line 78
          if (! (rule >= 0)) {
#line 78
            goto while_break___1;
          }
#line 80
          *(rrow + (rule >> 5)) |= 1U << (rule & 31);
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 84
      mask <<= 1;
#line 85
      if (mask == 0U) {
#line 87
        tmp___2 = vrow;
#line 87
        vrow ++;
#line 87
        cword = *tmp___2;
#line 88
        mask = 1U;
      }
#line 73
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 92
    vrow += varsetsize;
#line 93
    rrow += rulesetsize;
#line 68
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 100
  free((void *)((char *)EFF));
  }
#line 101
  return;
}
}
#line 104 "/home/june/collector/temp/btyacc-3.0/closure.c"
void closure(Yshort *nucleus , int n ) 
{ 
  register int ruleno ;
  register unsigned int word ;
  register unsigned int mask ;
  register Yshort *csp ;
  register unsigned int *dsp ;
  register unsigned int *rsp ;
  register int rulesetsize ;
  Yshort *csend ;
  unsigned int *rsend ;
  int symbol ;
  int itemno ;
  unsigned int *tmp ;
  unsigned int *tmp___0 ;
  Yshort *tmp___1 ;
  Yshort *tmp___2 ;
  Yshort *tmp___3 ;
  Yshort *tmp___4 ;
  Yshort *tmp___5 ;

  {
#line 119
  rulesetsize = (nrules + 31) / 32;
#line 120
  rsp = ruleset;
#line 121
  rsend = ruleset + rulesetsize;
#line 122
  rsp = ruleset;
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;
#line 122
    if (! ((unsigned long )rsp < (unsigned long )rsend)) {
#line 122
      goto while_break;
    }
#line 123
    *rsp = 0U;
#line 122
    rsp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 125
  csend = nucleus + n;
#line 126
  csp = nucleus;
  {
#line 126
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 126
    if (! ((unsigned long )csp < (unsigned long )csend)) {
#line 126
      goto while_break___0;
    }
#line 128
    symbol = *(ritem + *csp);
#line 129
    if (symbol >= start_symbol) {
#line 131
      dsp = first_derives + symbol * rulesetsize;
#line 132
      rsp = ruleset;
      {
#line 133
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 133
        if (! ((unsigned long )rsp < (unsigned long )rsend)) {
#line 133
          goto while_break___1;
        }
#line 134
        tmp = rsp;
#line 134
        rsp ++;
#line 134
        tmp___0 = dsp;
#line 134
        dsp ++;
#line 134
        *tmp |= *tmp___0;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 126
    csp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 138
  ruleno = 0;
#line 139
  itemsetend = itemset;
#line 140
  csp = nucleus;
#line 141
  rsp = ruleset;
  {
#line 141
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 141
    if (! ((unsigned long )rsp < (unsigned long )rsend)) {
#line 141
      goto while_break___2;
    }
#line 143
    word = *rsp;
#line 144
    if (word == 0U) {
#line 145
      ruleno += 32;
    } else {
#line 148
      mask = 1U;
      {
#line 149
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 149
        if (! mask) {
#line 149
          goto while_break___3;
        }
#line 151
        if (word & mask) {
#line 153
          itemno = *(rrhs + ruleno);
          {
#line 154
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 154
            if ((unsigned long )csp < (unsigned long )csend) {
#line 154
              if (! (*csp < itemno)) {
#line 154
                goto while_break___4;
              }
            } else {
#line 154
              goto while_break___4;
            }
#line 155
            tmp___1 = itemsetend;
#line 155
            itemsetend ++;
#line 155
            tmp___2 = csp;
#line 155
            csp ++;
#line 155
            *tmp___1 = *tmp___2;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 156
          tmp___3 = itemsetend;
#line 156
          itemsetend ++;
#line 156
          *tmp___3 = itemno;
          {
#line 157
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 157
            if ((unsigned long )csp < (unsigned long )csend) {
#line 157
              if (! (*csp == itemno)) {
#line 157
                goto while_break___5;
              }
            } else {
#line 157
              goto while_break___5;
            }
#line 158
            csp ++;
          }
          while_break___5: /* CIL Label */ ;
          }
        }
#line 161
        mask <<= 1;
#line 162
        ruleno ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 141
    rsp ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 167
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 167
    if (! ((unsigned long )csp < (unsigned long )csend)) {
#line 167
      goto while_break___6;
    }
#line 168
    tmp___4 = itemsetend;
#line 168
    itemsetend ++;
#line 168
    tmp___5 = csp;
#line 168
    csp ++;
#line 168
    *tmp___4 = *tmp___5;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 173
  return;
}
}
#line 177 "/home/june/collector/temp/btyacc-3.0/closure.c"
void finalize_closure(void) 
{ 


  {
  {
#line 179
  free((void *)((char *)itemset));
#line 180
  free((void *)((char *)ruleset));
#line 181
  free((void *)((char *)(first_derives + ntokens * ((nrules + 31) / 32))));
  }
#line 182
  return;
}
}
#line 289 "/home/june/collector/temp/btyacc-3.0/defs.h"
action **parser  ;
#line 290 "/home/june/collector/temp/btyacc-3.0/defs.h"
int SRtotal  ;
#line 291 "/home/june/collector/temp/btyacc-3.0/defs.h"
int RRtotal  ;
#line 292 "/home/june/collector/temp/btyacc-3.0/defs.h"
Yshort *SRconflicts  ;
#line 293 "/home/june/collector/temp/btyacc-3.0/defs.h"
Yshort *RRconflicts  ;
#line 294 "/home/june/collector/temp/btyacc-3.0/defs.h"
Yshort *defred  ;
#line 295 "/home/june/collector/temp/btyacc-3.0/defs.h"
Yshort *rules_used  ;
#line 296 "/home/june/collector/temp/btyacc-3.0/defs.h"
Yshort nunused  ;
#line 297 "/home/june/collector/temp/btyacc-3.0/defs.h"
Yshort final_state  ;
#line 405
action *parse_actions(int stateno ) ;
#line 406
action *get_shifts(int stateno ) ;
#line 407
action *add_reductions(int stateno , action *actions ) ;
#line 408
action *add_reduce(action *actions , int ruleno , int symbol ) ;
#line 409
void find_final_state(void) ;
#line 410
void unused_rules(void) ;
#line 411
void remove_conflicts(void) ;
#line 412
void total_conflicts(void) ;
#line 413
int sole_reduction(int stateno ) ;
#line 414
void defreds(void) ;
#line 415
void free_action_row(action *p ) ;
#line 14 "/home/june/collector/temp/btyacc-3.0/mkpar.c"
static int SRcount  ;
#line 15 "/home/june/collector/temp/btyacc-3.0/mkpar.c"
static int RRcount  ;
#line 23 "/home/june/collector/temp/btyacc-3.0/mkpar.c"
void make_parser(void) 
{ 
  register int i ;
  char *tmp ;

  {
  {
#line 27
  tmp = allocate((unsigned int )((unsigned long )nstates * sizeof(action *)));
#line 27
  parser = (action **)tmp;
#line 28
  i = 0;
  }
  {
#line 28
  while (1) {
    while_continue: /* CIL Label */ ;
#line 28
    if (! (i < nstates)) {
#line 28
      goto while_break;
    }
    {
#line 29
    *(parser + i) = parse_actions(i);
#line 28
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 31
  find_final_state();
#line 32
  remove_conflicts();
#line 33
  unused_rules();
  }
#line 34
  if (SRtotal + RRtotal > 0) {
    {
#line 34
    total_conflicts();
    }
  }
  {
#line 35
  defreds();
  }
#line 36
  return;
}
}
#line 38 "/home/june/collector/temp/btyacc-3.0/mkpar.c"
action *parse_actions(int stateno ) 
{ 
  register action *actions ;

  {
  {
#line 42
  actions = get_shifts(stateno);
#line 43
  actions = add_reductions(stateno, actions);
  }
#line 44
  return (actions);
}
}
#line 47 "/home/june/collector/temp/btyacc-3.0/mkpar.c"
action *get_shifts(int stateno ) 
{ 
  register action *actions ;
  register action *temp ;
  register shifts *sp ;
  register Yshort *to_state___0 ;
  register int i ;
  register int k ;
  register int symbol ;
  char *tmp ;

  {
#line 55
  actions = (action *)0;
#line 56
  sp = *(shift_table + stateno);
#line 57
  if (sp) {
#line 59
    to_state___0 = sp->shift;
#line 60
    i = sp->nshifts - 1;
    {
#line 60
    while (1) {
      while_continue: /* CIL Label */ ;
#line 60
      if (! (i >= 0)) {
#line 60
        goto while_break;
      }
#line 62
      k = *(to_state___0 + i);
#line 63
      symbol = *(accessing_symbol + k);
#line 64
      if (symbol < start_symbol) {
        {
#line 66
        tmp = allocate((unsigned int )sizeof(action ));
#line 66
        temp = (action *)tmp;
#line 67
        temp->next = actions;
#line 68
        temp->symbol = symbol;
#line 69
        temp->number = k;
#line 70
        temp->prec = *(symbol_prec + symbol);
#line 71
        temp->action_code = (char)1;
#line 72
        temp->assoc = *(symbol_assoc + symbol);
#line 73
        actions = temp;
        }
      }
#line 60
      i --;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 77
  return (actions);
}
}
#line 80 "/home/june/collector/temp/btyacc-3.0/mkpar.c"
action *add_reductions(int stateno , action *actions ) 
{ 
  register int i ;
  register int j ;
  register int m ;
  register int n ;
  register int ruleno ;
  register int tokensetsize___0 ;
  register unsigned int *rowp ;

  {
#line 86
  tokensetsize___0 = (ntokens + 31) / 32;
#line 87
  m = *(lookaheads + stateno);
#line 88
  n = *(lookaheads + (stateno + 1));
#line 89
  i = m;
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if (! (i < n)) {
#line 89
      goto while_break;
    }
#line 91
    ruleno = *(LAruleno + i);
#line 92
    rowp = LA + i * tokensetsize___0;
#line 93
    j = ntokens - 1;
    {
#line 93
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 93
      if (! (j >= 0)) {
#line 93
        goto while_break___0;
      }
#line 95
      if ((*(rowp + (j >> 5)) >> (j & 31)) & 1U) {
        {
#line 96
        actions = add_reduce(actions, ruleno, j);
        }
      }
#line 93
      j --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 89
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 99
  return (actions);
}
}
#line 102 "/home/june/collector/temp/btyacc-3.0/mkpar.c"
action *add_reduce(action *actions , int ruleno , int symbol ) 
{ 
  register action *temp ;
  register action *prev ;
  register action *next ;
  char *tmp ;

  {
#line 106
  prev = (action *)0;
#line 107
  next = actions;
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 107
    if (next) {
#line 107
      if (! (next->symbol < symbol)) {
#line 107
        goto while_break;
      }
    } else {
#line 107
      goto while_break;
    }
#line 108
    prev = next;
#line 107
    next = next->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 110
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 110
    if (next) {
#line 110
      if (next->symbol == symbol) {
#line 110
        if (! ((int )next->action_code == 1)) {
#line 110
          goto while_break___0;
        }
      } else {
#line 110
        goto while_break___0;
      }
    } else {
#line 110
      goto while_break___0;
    }
#line 112
    prev = next;
#line 113
    next = next->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 116
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 116
    if (next) {
#line 116
      if (next->symbol == symbol) {
#line 116
        if ((int )next->action_code == 2) {
#line 116
          if (! (next->number < ruleno)) {
#line 116
            goto while_break___1;
          }
        } else {
#line 116
          goto while_break___1;
        }
      } else {
#line 116
        goto while_break___1;
      }
    } else {
#line 116
      goto while_break___1;
    }
#line 119
    prev = next;
#line 120
    next = next->next;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 123
  tmp = allocate((unsigned int )sizeof(action ));
#line 123
  temp = (action *)tmp;
#line 124
  temp->next = next;
#line 125
  temp->symbol = symbol;
#line 126
  temp->number = ruleno;
#line 127
  temp->prec = *(rprec + ruleno);
#line 128
  temp->action_code = (char)2;
#line 129
  temp->assoc = *(rassoc + ruleno);
  }
#line 131
  if (prev) {
#line 132
    prev->next = temp;
  } else {
#line 134
    actions = temp;
  }
#line 136
  return (actions);
}
}
#line 139 "/home/june/collector/temp/btyacc-3.0/mkpar.c"
void find_final_state(void) 
{ 
  register int goal___0 ;
  register int i ;
  register Yshort *to_state___0 ;
  register shifts *p ;

  {
#line 145
  p = *(shift_table + 0);
#line 146
  to_state___0 = p->shift;
#line 147
  goal___0 = *(ritem + 1);
#line 148
  i = p->nshifts - 1;
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;
#line 148
    if (! (i >= 0)) {
#line 148
      goto while_break;
    }
#line 150
    final_state = *(to_state___0 + i);
#line 151
    if (*(accessing_symbol + final_state) == goal___0) {
#line 151
      goto while_break;
    }
#line 148
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 153
  return;
}
}
#line 155 "/home/june/collector/temp/btyacc-3.0/mkpar.c"
void unused_rules(void) 
{ 
  register int i ;
  register action *p ;
  void *tmp ;

  {
  {
#line 160
  tmp = malloc((size_t )((unsigned int )((unsigned long )nrules * sizeof(Yshort ))));
#line 160
  rules_used = (Yshort *)tmp;
  }
#line 161
  if ((unsigned long )rules_used == (unsigned long )((Yshort *)0)) {
    {
#line 161
    no_space();
    }
  }
#line 163
  i = 0;
  {
#line 163
  while (1) {
    while_continue: /* CIL Label */ ;
#line 163
    if (! (i < nrules)) {
#line 163
      goto while_break;
    }
#line 164
    *(rules_used + i) = 0;
#line 163
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 166
  i = 0;
  {
#line 166
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 166
    if (! (i < nstates)) {
#line 166
      goto while_break___0;
    }
#line 168
    p = *(parser + i);
    {
#line 168
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 168
      if (! p) {
#line 168
        goto while_break___1;
      }
#line 170
      if ((int )p->action_code == 2) {
#line 170
        if ((int )p->suppressed <= 1) {
#line 171
          *(rules_used + p->number) = 1;
        }
      }
#line 168
      p = p->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 166
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 175
  nunused = 0;
#line 176
  i = 3;
  {
#line 176
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 176
    if (! (i < nrules)) {
#line 176
      goto while_break___2;
    }
#line 177
    if (! *(rules_used + i)) {
#line 177
      nunused ++;
    }
#line 176
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 179
  if (nunused) {
#line 180
    if (nunused == 1) {
      {
#line 181
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: 1 rule never reduced\n",
              myname);
      }
    } else {
      {
#line 183
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %d rules never reduced\n",
              myname, nunused);
      }
    }
  }
#line 185
  return;
}
}
#line 188 "/home/june/collector/temp/btyacc-3.0/mkpar.c"
void remove_conflicts(void) 
{ 
  register int i ;
  register int symbol ;
  register action *p ;
  register action *pref ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 194
  SRtotal = 0;
#line 195
  RRtotal = 0;
#line 196
  tmp = allocate((unsigned int )((unsigned long )nstates * sizeof(Yshort )));
#line 196
  SRconflicts = (Yshort *)tmp;
#line 197
  tmp___0 = allocate((unsigned int )((unsigned long )nstates * sizeof(Yshort )));
#line 197
  RRconflicts = (Yshort *)tmp___0;
#line 198
  i = 0;
  }
  {
#line 198
  while (1) {
    while_continue: /* CIL Label */ ;
#line 198
    if (! (i < nstates)) {
#line 198
      goto while_break;
    }
#line 199
    SRcount = 0;
#line 200
    RRcount = 0;
#line 201
    symbol = -1;
#line 202
    pref = (action *)0;
#line 203
    p = *(parser + i);
    {
#line 203
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 203
      if (! p) {
#line 203
        goto while_break___0;
      }
#line 204
      if (p->symbol != symbol) {
#line 205
        pref = p;
#line 206
        symbol = p->symbol;
      } else
#line 207
      if (i == final_state) {
#line 207
        if (symbol == 0) {
#line 208
          SRcount ++;
#line 209
          p->suppressed = (char)1;
#line 210
          if (! pref->suppressed) {
#line 211
            pref->suppressed = (char)1;
          }
        } else {
#line 207
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 212
      if ((int )pref->action_code == 1) {
#line 213
        if (pref->prec > 0) {
#line 213
          if (p->prec > 0) {
#line 214
            if (pref->prec < p->prec) {
#line 215
              pref->suppressed = (char)2;
#line 216
              pref = p;
            } else
#line 217
            if (pref->prec > p->prec) {
#line 218
              p->suppressed = (char)2;
            } else
#line 219
            if ((int )pref->assoc == 1) {
#line 220
              pref->suppressed = (char)2;
#line 221
              pref = p;
            } else
#line 222
            if ((int )pref->assoc == 2) {
#line 223
              p->suppressed = (char)2;
            } else {
#line 225
              pref->suppressed = (char)2;
#line 226
              p->suppressed = (char)2;
            }
          } else {
#line 213
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
#line 228
          SRcount ++;
#line 229
          p->suppressed = (char)1;
#line 230
          if (! pref->suppressed) {
#line 231
            pref->suppressed = (char)1;
          }
        }
      } else {
#line 233
        RRcount ++;
#line 234
        p->suppressed = (char)1;
#line 235
        if (! pref->suppressed) {
#line 236
          pref->suppressed = (char)1;
        }
      }
#line 203
      p = p->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 237
    SRtotal += SRcount;
#line 238
    RRtotal += RRcount;
#line 239
    *(SRconflicts + i) = SRcount;
#line 240
    *(RRconflicts + i) = RRcount;
#line 198
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 241
  return;
}
}
#line 244 "/home/june/collector/temp/btyacc-3.0/mkpar.c"
void total_conflicts(void) 
{ 


  {
  {
#line 246
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
          myname);
  }
#line 247
  if (SRtotal == 1) {
    {
#line 248
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"1 shift/reduce conflict");
    }
  } else
#line 249
  if (SRtotal > 1) {
    {
#line 250
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d shift/reduce conflicts",
            SRtotal);
    }
  }
#line 252
  if (SRtotal) {
#line 252
    if (RRtotal) {
      {
#line 253
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)", ");
      }
    }
  }
#line 255
  if (RRtotal == 1) {
    {
#line 256
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"1 reduce/reduce conflict");
    }
  } else
#line 257
  if (RRtotal > 1) {
    {
#line 258
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d reduce/reduce conflicts",
            RRtotal);
    }
  }
  {
#line 260
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)".\n");
  }
#line 261
  return;
}
}
#line 264 "/home/june/collector/temp/btyacc-3.0/mkpar.c"
int sole_reduction(int stateno ) 
{ 
  register int count ;
  register int ruleno ;
  register action *p ;

  {
#line 269
  count = 0;
#line 270
  ruleno = 0;
#line 271
  p = *(parser + stateno);
  {
#line 271
  while (1) {
    while_continue: /* CIL Label */ ;
#line 271
    if (! p) {
#line 271
      goto while_break;
    }
#line 273
    if ((int )p->action_code == 1) {
#line 273
      if ((int )p->suppressed <= 1) {
#line 274
        return (0);
      } else {
#line 273
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 275
    if ((int )p->action_code == 2) {
#line 275
      if ((int )p->suppressed <= 1) {
#line 277
        if (ruleno > 0) {
#line 277
          if (p->number != ruleno) {
#line 278
            return (0);
          }
        }
#line 279
        if (p->symbol != 1) {
#line 280
          count ++;
        }
#line 281
        ruleno = p->number;
      }
    }
#line 271
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 285
  if (count == 0) {
#line 286
    return (0);
  }
#line 287
  return (ruleno);
}
}
#line 291 "/home/june/collector/temp/btyacc-3.0/mkpar.c"
void defreds(void) 
{ 
  register int i ;
  char *tmp ;

  {
  {
#line 295
  tmp = allocate((unsigned int )((unsigned long )nstates * sizeof(Yshort )));
#line 295
  defred = (Yshort *)tmp;
#line 296
  i = 0;
  }
  {
#line 296
  while (1) {
    while_continue: /* CIL Label */ ;
#line 296
    if (! (i < nstates)) {
#line 296
      goto while_break;
    }
    {
#line 297
    *(defred + i) = sole_reduction(i);
#line 296
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 298
  return;
}
}
#line 300 "/home/june/collector/temp/btyacc-3.0/mkpar.c"
void free_action_row(action *p ) 
{ 
  register action *q ;

  {
  {
#line 304
  while (1) {
    while_continue: /* CIL Label */ ;
#line 304
    if (! p) {
#line 304
      goto while_break;
    }
    {
#line 306
    q = p->next;
#line 307
    free((void *)((char *)p));
#line 308
    p = q;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 310
  return;
}
}
#line 312 "/home/june/collector/temp/btyacc-3.0/mkpar.c"
void free_parser(void) 
{ 
  register int i ;

  {
#line 316
  i = 0;
  {
#line 316
  while (1) {
    while_continue: /* CIL Label */ ;
#line 316
    if (! (i < nstates)) {
#line 316
      goto while_break;
    }
    {
#line 317
    free_action_row(*(parser + i));
#line 316
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 319
  free((void *)((char *)parser));
  }
#line 320
  return;
}
}
#line 278 "/home/june/collector/temp/btyacc-3.0/defs.h"
Yshort *accessing_symbol  ;
#line 279 "/home/june/collector/temp/btyacc-3.0/defs.h"
core **state_table  ;
#line 280 "/home/june/collector/temp/btyacc-3.0/defs.h"
shifts **shift_table  ;
#line 281 "/home/june/collector/temp/btyacc-3.0/defs.h"
reductions **reduction_table  ;
#line 282 "/home/june/collector/temp/btyacc-3.0/defs.h"
unsigned int *LA  ;
#line 283 "/home/june/collector/temp/btyacc-3.0/defs.h"
Yshort *LAruleno  ;
#line 284 "/home/june/collector/temp/btyacc-3.0/defs.h"
Yshort *lookaheads  ;
#line 285 "/home/june/collector/temp/btyacc-3.0/defs.h"
Yshort *goto_map  ;
#line 286 "/home/june/collector/temp/btyacc-3.0/defs.h"
Yshort *from_state  ;
#line 287 "/home/june/collector/temp/btyacc-3.0/defs.h"
Yshort *to_state  ;
#line 352
void set_state_table(void) ;
#line 353
void set_accessing_symbol(void) ;
#line 354
void set_shift_table(void) ;
#line 355
void set_reduction_table(void) ;
#line 356
void set_maxrhs(void) ;
#line 357
void initialize_LA(void) ;
#line 358
void set_goto_map(void) ;
#line 359
int map_goto(int state , int symbol ) ;
#line 360
void initialize_F(void) ;
#line 361
void build_relations(void) ;
#line 362
void add_lookback_edge(int stateno , int ruleno , int gotono ) ;
#line 363
Yshort **transpose(Yshort **R___0 , int n ) ;
#line 364
void compute_FOLLOWS(void) ;
#line 365
void compute_lookaheads(void) ;
#line 366
void digraph(Yshort **relation ) ;
#line 367
void traverse(int i ) ;
#line 11 "/home/june/collector/temp/btyacc-3.0/lalr.c"
int tokensetsize  ;
#line 23 "/home/june/collector/temp/btyacc-3.0/lalr.c"
static int infinity  ;
#line 24 "/home/june/collector/temp/btyacc-3.0/lalr.c"
static int maxrhs  ;
#line 25 "/home/june/collector/temp/btyacc-3.0/lalr.c"
static int ngotos  ;
#line 26 "/home/june/collector/temp/btyacc-3.0/lalr.c"
static unsigned int *F  ;
#line 27 "/home/june/collector/temp/btyacc-3.0/lalr.c"
static Yshort **includes  ;
#line 28 "/home/june/collector/temp/btyacc-3.0/lalr.c"
static shorts **lookback  ;
#line 29 "/home/june/collector/temp/btyacc-3.0/lalr.c"
static Yshort **R  ;
#line 30 "/home/june/collector/temp/btyacc-3.0/lalr.c"
static Yshort *INDEX  ;
#line 31 "/home/june/collector/temp/btyacc-3.0/lalr.c"
static Yshort *VERTICES  ;
#line 32 "/home/june/collector/temp/btyacc-3.0/lalr.c"
static int top  ;
#line 35 "/home/june/collector/temp/btyacc-3.0/lalr.c"
void lalr(void) 
{ 


  {
  {
#line 37
  tokensetsize = (ntokens + 31) / 32;
#line 39
  set_state_table();
#line 40
  set_accessing_symbol();
#line 41
  set_shift_table();
#line 42
  set_reduction_table();
#line 43
  set_maxrhs();
#line 44
  initialize_LA();
#line 45
  set_goto_map();
#line 46
  initialize_F();
#line 47
  build_relations();
#line 48
  compute_FOLLOWS();
#line 49
  compute_lookaheads();
  }
#line 50
  return;
}
}
#line 54 "/home/june/collector/temp/btyacc-3.0/lalr.c"
void set_state_table(void) 
{ 
  register core *sp ;
  char *tmp ;

  {
  {
#line 58
  tmp = allocate((unsigned int )((unsigned long )nstates * sizeof(core *)));
#line 58
  state_table = (core **)tmp;
#line 59
  sp = first_state;
  }
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    if (! sp) {
#line 59
      goto while_break;
    }
#line 60
    *(state_table + sp->number) = sp;
#line 59
    sp = sp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 61
  return;
}
}
#line 65 "/home/june/collector/temp/btyacc-3.0/lalr.c"
void set_accessing_symbol(void) 
{ 
  register core *sp ;
  char *tmp ;

  {
  {
#line 69
  tmp = allocate((unsigned int )((unsigned long )nstates * sizeof(Yshort )));
#line 69
  accessing_symbol = (Yshort *)tmp;
#line 70
  sp = first_state;
  }
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;
#line 70
    if (! sp) {
#line 70
      goto while_break;
    }
#line 71
    *(accessing_symbol + sp->number) = sp->accessing_symbol;
#line 70
    sp = sp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 72
  return;
}
}
#line 76 "/home/june/collector/temp/btyacc-3.0/lalr.c"
void set_shift_table(void) 
{ 
  register shifts *sp ;
  char *tmp ;

  {
  {
#line 80
  tmp = allocate((unsigned int )((unsigned long )nstates * sizeof(shifts *)));
#line 80
  shift_table = (shifts **)tmp;
#line 81
  sp = first_shift;
  }
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    if (! sp) {
#line 81
      goto while_break;
    }
#line 82
    *(shift_table + sp->number) = sp;
#line 81
    sp = sp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 83
  return;
}
}
#line 87 "/home/june/collector/temp/btyacc-3.0/lalr.c"
void set_reduction_table(void) 
{ 
  register reductions *rp ;
  char *tmp ;

  {
  {
#line 91
  tmp = allocate((unsigned int )((unsigned long )nstates * sizeof(reductions *)));
#line 91
  reduction_table = (reductions **)tmp;
#line 92
  rp = first_reduction;
  }
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    if (! rp) {
#line 92
      goto while_break;
    }
#line 93
    *(reduction_table + rp->number) = rp;
#line 92
    rp = rp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 94
  return;
}
}
#line 98 "/home/june/collector/temp/btyacc-3.0/lalr.c"
void set_maxrhs(void) 
{ 
  register Yshort *itemp ;
  register Yshort *item_end ;
  register int length ;
  register int max ;

  {
#line 105
  length = 0;
#line 106
  max = 0;
#line 107
  item_end = ritem + nitems;
#line 108
  itemp = ritem;
  {
#line 108
  while (1) {
    while_continue: /* CIL Label */ ;
#line 108
    if (! ((unsigned long )itemp < (unsigned long )item_end)) {
#line 108
      goto while_break;
    }
#line 110
    if (*itemp >= 0) {
#line 112
      length ++;
    } else {
#line 116
      if (length > max) {
#line 116
        max = length;
      }
#line 117
      length = 0;
    }
#line 108
    itemp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 121
  maxrhs = max;
#line 122
  return;
}
}
#line 126 "/home/june/collector/temp/btyacc-3.0/lalr.c"
void initialize_LA(void) 
{ 
  register int i ;
  register int j ;
  register int k ;
  register reductions *rp ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 131
  tmp = allocate((unsigned int )((unsigned long )(nstates + 1) * sizeof(Yshort )));
#line 131
  lookaheads = (Yshort *)tmp;
#line 133
  k = 0;
#line 134
  i = 0;
  }
  {
#line 134
  while (1) {
    while_continue: /* CIL Label */ ;
#line 134
    if (! (i < nstates)) {
#line 134
      goto while_break;
    }
#line 136
    *(lookaheads + i) = k;
#line 137
    rp = *(reduction_table + i);
#line 138
    if (rp) {
#line 139
      k += rp->nreds;
    }
#line 134
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 141
  *(lookaheads + nstates) = k;
#line 143
  tmp___0 = allocate((unsigned int )((unsigned long )(k * tokensetsize) * sizeof(unsigned int )));
#line 143
  LA = (unsigned int *)tmp___0;
#line 144
  tmp___1 = allocate((unsigned int )((unsigned long )k * sizeof(Yshort )));
#line 144
  LAruleno = (Yshort *)tmp___1;
#line 145
  tmp___2 = allocate((unsigned int )((unsigned long )k * sizeof(shorts *)));
#line 145
  lookback = (shorts **)tmp___2;
#line 147
  k = 0;
#line 148
  i = 0;
  }
  {
#line 148
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 148
    if (! (i < nstates)) {
#line 148
      goto while_break___0;
    }
#line 150
    rp = *(reduction_table + i);
#line 151
    if (rp) {
#line 153
      j = 0;
      {
#line 153
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 153
        if (! (j < rp->nreds)) {
#line 153
          goto while_break___1;
        }
#line 155
        *(LAruleno + k) = rp->rules[j];
#line 156
        k ++;
#line 153
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 148
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 160
  return;
}
}
#line 163 "/home/june/collector/temp/btyacc-3.0/lalr.c"
void set_goto_map(void) 
{ 
  register shifts *sp ;
  register int i ;
  register int symbol ;
  register int k ;
  register Yshort *temp_map ;
  register int state2 ;
  register int state1 ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  Yshort tmp___3 ;

  {
  {
#line 173
  tmp = allocate((unsigned int )((unsigned long )(nvars + 1) * sizeof(Yshort )));
#line 173
  goto_map = (Yshort *)tmp - ntokens;
#line 174
  tmp___0 = allocate((unsigned int )((unsigned long )(nvars + 1) * sizeof(Yshort )));
#line 174
  temp_map = (Yshort *)tmp___0 - ntokens;
#line 176
  ngotos = 0;
#line 177
  sp = first_shift;
  }
  {
#line 177
  while (1) {
    while_continue: /* CIL Label */ ;
#line 177
    if (! sp) {
#line 177
      goto while_break;
    }
#line 179
    i = sp->nshifts - 1;
    {
#line 179
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 179
      if (! (i >= 0)) {
#line 179
        goto while_break___0;
      }
#line 181
      symbol = *(accessing_symbol + sp->shift[i]);
#line 183
      if (symbol < start_symbol) {
#line 183
        goto while_break___0;
      }
#line 185
      if (ngotos == 2147483647) {
        {
#line 186
        fatal((char *)"too many gotos");
        }
      }
#line 188
      ngotos ++;
#line 189
      (*(goto_map + symbol)) ++;
#line 179
      i --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 177
    sp = sp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 193
  k = 0;
#line 194
  i = ntokens;
  {
#line 194
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 194
    if (! (i < nsyms)) {
#line 194
      goto while_break___1;
    }
#line 196
    *(temp_map + i) = k;
#line 197
    k += *(goto_map + i);
#line 194
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 200
  i = ntokens;
  {
#line 200
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 200
    if (! (i < nsyms)) {
#line 200
      goto while_break___2;
    }
#line 201
    *(goto_map + i) = *(temp_map + i);
#line 200
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 203
  *(goto_map + nsyms) = ngotos;
#line 204
  *(temp_map + nsyms) = ngotos;
#line 206
  tmp___1 = allocate((unsigned int )((unsigned long )ngotos * sizeof(Yshort )));
#line 206
  from_state = (Yshort *)tmp___1;
#line 207
  tmp___2 = allocate((unsigned int )((unsigned long )ngotos * sizeof(Yshort )));
#line 207
  to_state = (Yshort *)tmp___2;
#line 209
  sp = first_shift;
  }
  {
#line 209
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 209
    if (! sp) {
#line 209
      goto while_break___3;
    }
#line 211
    state1 = sp->number;
#line 212
    i = sp->nshifts - 1;
    {
#line 212
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 212
      if (! (i >= 0)) {
#line 212
        goto while_break___4;
      }
#line 214
      state2 = sp->shift[i];
#line 215
      symbol = *(accessing_symbol + state2);
#line 217
      if (symbol < start_symbol) {
#line 217
        goto while_break___4;
      }
#line 219
      tmp___3 = *(temp_map + symbol);
#line 219
      (*(temp_map + symbol)) ++;
#line 219
      k = tmp___3;
#line 220
      *(from_state + k) = state1;
#line 221
      *(to_state + k) = state2;
#line 212
      i --;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 209
    sp = sp->next;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 225
  free((void *)((char *)(temp_map + ntokens)));
  }
#line 226
  return;
}
}
#line 232 "/home/june/collector/temp/btyacc-3.0/lalr.c"
int map_goto(int state , int symbol ) 
{ 
  register int high___0 ;
  register int low ;
  register int middle ;
  register int s ;

  {
#line 239
  low = *(goto_map + symbol);
#line 240
  high___0 = *(goto_map + (symbol + 1));
  {
#line 242
  while (1) {
    while_continue: /* CIL Label */ ;
#line 244
    if (! (low <= high___0)) {
      {
#line 244
      __assert_fail("low <= high", "/home/june/collector/temp/btyacc-3.0/lalr.c",
                    244U, "map_goto");
      }
    }
#line 245
    middle = (low + high___0) >> 1;
#line 246
    s = *(from_state + middle);
#line 247
    if (s == state) {
#line 248
      return (middle);
    } else
#line 249
    if (s < state) {
#line 250
      low = middle + 1;
    } else {
#line 252
      high___0 = middle - 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 258 "/home/june/collector/temp/btyacc-3.0/lalr.c"
void initialize_F(void) 
{ 
  register int i ;
  register int j ;
  register int k ;
  register shifts *sp ;
  register Yshort *edge ;
  register unsigned int *rowp ;
  register Yshort *rp ;
  register Yshort **reads ;
  register int nedges ;
  register int stateno ;
  register int symbol ;
  register int nwords ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 273
  nwords = ngotos * tokensetsize;
#line 274
  tmp = allocate((unsigned int )((unsigned long )nwords * sizeof(unsigned int )));
#line 274
  F = (unsigned int *)tmp;
#line 276
  tmp___0 = allocate((unsigned int )((unsigned long )ngotos * sizeof(Yshort *)));
#line 276
  reads = (Yshort **)tmp___0;
#line 277
  tmp___1 = allocate((unsigned int )((unsigned long )(ngotos + 1) * sizeof(Yshort )));
#line 277
  edge = (Yshort *)tmp___1;
#line 278
  nedges = 0;
#line 280
  rowp = F;
#line 281
  i = 0;
  }
  {
#line 281
  while (1) {
    while_continue: /* CIL Label */ ;
#line 281
    if (! (i < ngotos)) {
#line 281
      goto while_break;
    }
#line 283
    stateno = *(to_state + i);
#line 284
    sp = *(shift_table + stateno);
#line 286
    if (sp) {
#line 288
      k = sp->nshifts;
#line 290
      j = 0;
      {
#line 290
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 290
        if (! (j < k)) {
#line 290
          goto while_break___0;
        }
#line 292
        symbol = *(accessing_symbol + sp->shift[j]);
#line 293
        if (symbol >= start_symbol) {
#line 294
          goto while_break___0;
        }
#line 295
        *(rowp + (symbol >> 5)) |= 1U << (symbol & 31);
#line 290
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 298
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 298
        if (! (j < k)) {
#line 298
          goto while_break___1;
        }
#line 300
        symbol = *(accessing_symbol + sp->shift[j]);
#line 301
        if (*(nullable + symbol)) {
          {
#line 302
          tmp___2 = nedges;
#line 302
          nedges ++;
#line 302
          *(edge + tmp___2) = map_goto(stateno, symbol);
          }
        }
#line 298
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 305
      if (nedges) {
        {
#line 307
        tmp___3 = allocate((unsigned int )((unsigned long )(nedges + 1) * sizeof(Yshort )));
#line 307
        rp = (Yshort *)tmp___3;
#line 307
        *(reads + i) = rp;
#line 309
        j = 0;
        }
        {
#line 309
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 309
          if (! (j < nedges)) {
#line 309
            goto while_break___2;
          }
#line 310
          *(rp + j) = *(edge + j);
#line 309
          j ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 312
        *(rp + nedges) = -1;
#line 313
        nedges = 0;
      }
    }
#line 317
    rowp += tokensetsize;
#line 281
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 320
  *(F + 0) |= 1U;
#line 321
  digraph(reads);
#line 323
  i = 0;
  }
  {
#line 323
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 323
    if (! (i < ngotos)) {
#line 323
      goto while_break___3;
    }
#line 325
    if (*(reads + i)) {
      {
#line 326
      free((void *)((char *)*(reads + i)));
      }
    }
#line 323
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 329
  free((void *)((char *)reads));
#line 330
  free((void *)((char *)edge));
  }
#line 331
  return;
}
}
#line 335 "/home/june/collector/temp/btyacc-3.0/lalr.c"
void build_relations(void) 
{ 
  register int i ;
  register int j ;
  register int k ;
  register Yshort *rulep ;
  register Yshort *rp ;
  register shifts *sp ;
  register int length ;
  register int nedges ;
  register int done___0 ;
  register int state1 ;
  register int stateno ;
  register int symbol1 ;
  register int symbol2 ;
  register Yshort *shortp ;
  register Yshort *edge ;
  register Yshort *states ;
  register Yshort **new_includes ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 355
  tmp = allocate((unsigned int )((unsigned long )ngotos * sizeof(Yshort *)));
#line 355
  includes = (Yshort **)tmp;
#line 356
  tmp___0 = allocate((unsigned int )((unsigned long )(ngotos + 1) * sizeof(Yshort )));
#line 356
  edge = (Yshort *)tmp___0;
#line 357
  tmp___1 = allocate((unsigned int )((unsigned long )(maxrhs + 1) * sizeof(Yshort )));
#line 357
  states = (Yshort *)tmp___1;
#line 359
  i = 0;
  }
  {
#line 359
  while (1) {
    while_continue: /* CIL Label */ ;
#line 359
    if (! (i < ngotos)) {
#line 359
      goto while_break;
    }
#line 361
    nedges = 0;
#line 362
    state1 = *(from_state + i);
#line 363
    symbol1 = *(accessing_symbol + *(to_state + i));
#line 365
    rulep = *(derives + symbol1);
    {
#line 365
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 365
      if (! (*rulep >= 0)) {
#line 365
        goto while_break___0;
      }
#line 367
      length = 1;
#line 368
      *(states + 0) = state1;
#line 369
      stateno = state1;
#line 371
      rp = ritem + *(rrhs + *rulep);
      {
#line 371
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 371
        if (! (*rp >= 0)) {
#line 371
          goto while_break___1;
        }
#line 373
        symbol2 = *rp;
#line 374
        sp = *(shift_table + stateno);
#line 375
        k = sp->nshifts;
#line 377
        j = 0;
        {
#line 377
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 377
          if (! (j < k)) {
#line 377
            goto while_break___2;
          }
#line 379
          stateno = sp->shift[j];
#line 380
          if (*(accessing_symbol + stateno) == symbol2) {
#line 380
            goto while_break___2;
          }
#line 377
          j ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 383
        tmp___2 = length;
#line 383
        length ++;
#line 383
        *(states + tmp___2) = stateno;
#line 371
        rp ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 386
      add_lookback_edge(stateno, *rulep, i);
#line 388
      length --;
#line 389
      done___0 = 0;
      }
      {
#line 390
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 390
        if (! (! done___0)) {
#line 390
          goto while_break___3;
        }
#line 392
        done___0 = 1;
#line 393
        rp --;
#line 394
        if (*rp >= start_symbol) {
          {
#line 396
          length --;
#line 396
          stateno = *(states + length);
#line 397
          tmp___3 = nedges;
#line 397
          nedges ++;
#line 397
          *(edge + tmp___3) = map_goto(stateno, *rp);
          }
#line 398
          if (*(nullable + *rp)) {
#line 398
            if (length > 0) {
#line 398
              done___0 = 0;
            }
          }
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 365
      rulep ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 403
    if (nedges) {
      {
#line 405
      tmp___4 = allocate((unsigned int )((unsigned long )(nedges + 1) * sizeof(Yshort )));
#line 405
      shortp = (Yshort *)tmp___4;
#line 405
      *(includes + i) = shortp;
#line 406
      j = 0;
      }
      {
#line 406
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 406
        if (! (j < nedges)) {
#line 406
          goto while_break___4;
        }
#line 407
        *(shortp + j) = *(edge + j);
#line 406
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 408
      *(shortp + nedges) = -1;
    }
#line 359
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 412
  new_includes = transpose(includes, ngotos);
#line 414
  i = 0;
  }
  {
#line 414
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 414
    if (! (i < ngotos)) {
#line 414
      goto while_break___5;
    }
#line 415
    if (*(includes + i)) {
      {
#line 416
      free((void *)((char *)*(includes + i)));
      }
    }
#line 414
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 418
  free((void *)((char *)includes));
#line 420
  includes = new_includes;
#line 422
  free((void *)((char *)edge));
#line 423
  free((void *)((char *)states));
  }
#line 424
  return;
}
}
#line 427 "/home/june/collector/temp/btyacc-3.0/lalr.c"
void add_lookback_edge(int stateno , int ruleno , int gotono ) 
{ 
  register int i ;
  register int k ;
  register int found ;
  register shorts *sp ;
  char *tmp ;

  {
#line 433
  i = *(lookaheads + stateno);
#line 434
  k = *(lookaheads + (stateno + 1));
#line 435
  found = 0;
  {
#line 436
  while (1) {
    while_continue: /* CIL Label */ ;
#line 436
    if (! found) {
#line 436
      if (! (i < k)) {
#line 436
        goto while_break;
      }
    } else {
#line 436
      goto while_break;
    }
#line 438
    if (*(LAruleno + i) == ruleno) {
#line 439
      found = 1;
    } else {
#line 441
      i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 443
  if (! found) {
    {
#line 443
    __assert_fail("found", "/home/june/collector/temp/btyacc-3.0/lalr.c", 443U, "add_lookback_edge");
    }
  }
  {
#line 445
  tmp = allocate((unsigned int )sizeof(shorts ));
#line 445
  sp = (shorts *)tmp;
#line 446
  sp->next = *(lookback + i);
#line 447
  sp->value = gotono;
#line 448
  *(lookback + i) = sp;
  }
#line 449
  return;
}
}
#line 453 "/home/june/collector/temp/btyacc-3.0/lalr.c"
Yshort **transpose(Yshort **R___0 , int n ) 
{ 
  register Yshort **new_R ;
  register Yshort **temp_R ;
  register Yshort *nedges ;
  register Yshort *sp ;
  register int i ;
  register int k ;
  char *tmp ;
  Yshort *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  Yshort *tmp___4 ;
  Yshort *tmp___5 ;

  {
  {
#line 462
  tmp = allocate((unsigned int )((unsigned long )n * sizeof(Yshort )));
#line 462
  nedges = (Yshort *)tmp;
#line 464
  i = 0;
  }
  {
#line 464
  while (1) {
    while_continue: /* CIL Label */ ;
#line 464
    if (! (i < n)) {
#line 464
      goto while_break;
    }
#line 466
    sp = *(R___0 + i);
#line 467
    if (sp) {
      {
#line 469
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 469
        if (! (*sp >= 0)) {
#line 469
          goto while_break___0;
        }
#line 470
        tmp___0 = sp;
#line 470
        sp ++;
#line 470
        (*(nedges + *tmp___0)) ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 464
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 474
  tmp___1 = allocate((unsigned int )((unsigned long )n * sizeof(Yshort *)));
#line 474
  new_R = (Yshort **)tmp___1;
#line 475
  tmp___2 = allocate((unsigned int )((unsigned long )n * sizeof(Yshort *)));
#line 475
  temp_R = (Yshort **)tmp___2;
#line 477
  i = 0;
  }
  {
#line 477
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 477
    if (! (i < n)) {
#line 477
      goto while_break___1;
    }
#line 479
    k = *(nedges + i);
#line 480
    if (k > 0) {
      {
#line 482
      tmp___3 = allocate((unsigned int )((unsigned long )(k + 1) * sizeof(Yshort )));
#line 482
      sp = (Yshort *)tmp___3;
#line 483
      *(new_R + i) = sp;
#line 484
      *(temp_R + i) = sp;
#line 485
      *(sp + k) = -1;
      }
    }
#line 477
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 489
  free((void *)((char *)nedges));
#line 491
  i = 0;
  }
  {
#line 491
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 491
    if (! (i < n)) {
#line 491
      goto while_break___2;
    }
#line 493
    sp = *(R___0 + i);
#line 494
    if (sp) {
      {
#line 496
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 496
        if (! (*sp >= 0)) {
#line 496
          goto while_break___3;
        }
#line 497
        tmp___4 = sp;
#line 497
        sp ++;
#line 497
        tmp___5 = *(temp_R + *tmp___4);
#line 497
        (*(temp_R + *tmp___4)) ++;
#line 497
        *tmp___5 = i;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 491
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 501
  free((void *)((char *)temp_R));
  }
#line 503
  return (new_R);
}
}
#line 508 "/home/june/collector/temp/btyacc-3.0/lalr.c"
void compute_FOLLOWS(void) 
{ 


  {
  {
#line 510
  digraph(includes);
  }
#line 511
  return;
}
}
#line 514 "/home/june/collector/temp/btyacc-3.0/lalr.c"
void compute_lookaheads(void) 
{ 
  register int i ;
  register int n ;
  register unsigned int *fp1 ;
  register unsigned int *fp2 ;
  register unsigned int *fp3 ;
  register shorts *sp ;
  register shorts *next ;
  register unsigned int *rowp ;
  unsigned int *tmp ;
  unsigned int *tmp___0 ;

  {
#line 521
  rowp = LA;
#line 522
  n = *(lookaheads + nstates);
#line 523
  i = 0;
  {
#line 523
  while (1) {
    while_continue: /* CIL Label */ ;
#line 523
    if (! (i < n)) {
#line 523
      goto while_break;
    }
#line 525
    fp3 = rowp + tokensetsize;
#line 526
    sp = *(lookback + i);
    {
#line 526
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 526
      if (! sp) {
#line 526
        goto while_break___0;
      }
#line 528
      fp1 = rowp;
#line 529
      fp2 = F + tokensetsize * sp->value;
      {
#line 530
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 530
        if (! ((unsigned long )fp1 < (unsigned long )fp3)) {
#line 530
          goto while_break___1;
        }
#line 531
        tmp = fp1;
#line 531
        fp1 ++;
#line 531
        tmp___0 = fp2;
#line 531
        fp2 ++;
#line 531
        *tmp |= *tmp___0;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 526
      sp = sp->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 533
    rowp = fp3;
#line 523
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 536
  i = 0;
  {
#line 536
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 536
    if (! (i < n)) {
#line 536
      goto while_break___2;
    }
#line 537
    sp = *(lookback + i);
    {
#line 537
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 537
      if (! sp) {
#line 537
        goto while_break___3;
      }
      {
#line 539
      next = sp->next;
#line 540
      free((void *)((char *)sp));
#line 537
      sp = next;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 536
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 543
  free((void *)((char *)lookback));
#line 544
  free((void *)((char *)F));
  }
#line 545
  return;
}
}
#line 548 "/home/june/collector/temp/btyacc-3.0/lalr.c"
void digraph(Yshort **relation ) 
{ 
  register int i ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 552
  infinity = ngotos + 2;
#line 553
  tmp = allocate((unsigned int )((unsigned long )(ngotos + 1) * sizeof(Yshort )));
#line 553
  INDEX = (Yshort *)tmp;
#line 554
  tmp___0 = allocate((unsigned int )((unsigned long )(ngotos + 1) * sizeof(Yshort )));
#line 554
  VERTICES = (Yshort *)tmp___0;
#line 555
  top = 0;
#line 557
  R = relation;
#line 559
  i = 0;
  }
  {
#line 559
  while (1) {
    while_continue: /* CIL Label */ ;
#line 559
    if (! (i < ngotos)) {
#line 559
      goto while_break;
    }
#line 560
    *(INDEX + i) = 0;
#line 559
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 562
  i = 0;
  {
#line 562
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 562
    if (! (i < ngotos)) {
#line 562
      goto while_break___0;
    }
#line 564
    if (*(INDEX + i) == 0) {
#line 564
      if (*(R + i)) {
        {
#line 565
        traverse(i);
        }
      }
    }
#line 562
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 568
  free((void *)((char *)INDEX));
#line 569
  free((void *)((char *)VERTICES));
  }
#line 570
  return;
}
}
#line 572 "/home/june/collector/temp/btyacc-3.0/lalr.c"
void traverse(int i ) 
{ 
  register unsigned int *fp1 ;
  register unsigned int *fp2 ;
  register unsigned int *fp3 ;
  register int j ;
  register Yshort *rp ;
  int height ;
  unsigned int *base___0 ;
  unsigned int *tmp ;
  unsigned int *tmp___0 ;
  Yshort *tmp___1 ;
  int tmp___2 ;
  unsigned int *tmp___3 ;
  unsigned int *tmp___4 ;

  {
#line 583
  top ++;
#line 583
  *(VERTICES + top) = i;
#line 584
  height = top;
#line 584
  *(INDEX + i) = height;
#line 586
  base___0 = F + i * tokensetsize;
#line 587
  fp3 = base___0 + tokensetsize;
#line 589
  rp = *(R + i);
#line 590
  if (rp) {
    {
#line 592
    while (1) {
      while_continue: /* CIL Label */ ;
#line 592
      tmp___1 = rp;
#line 592
      rp ++;
#line 592
      j = *tmp___1;
#line 592
      if (! (j >= 0)) {
#line 592
        goto while_break;
      }
#line 594
      if (*(INDEX + j) == 0) {
        {
#line 595
        traverse(j);
        }
      }
#line 597
      if (*(INDEX + i) > *(INDEX + j)) {
#line 598
        *(INDEX + i) = *(INDEX + j);
      }
#line 600
      fp1 = base___0;
#line 601
      fp2 = F + j * tokensetsize;
      {
#line 603
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 603
        if (! ((unsigned long )fp1 < (unsigned long )fp3)) {
#line 603
          goto while_break___0;
        }
#line 604
        tmp = fp1;
#line 604
        fp1 ++;
#line 604
        tmp___0 = fp2;
#line 604
        fp2 ++;
#line 604
        *tmp |= *tmp___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 608
  if (*(INDEX + i) == height) {
    {
#line 610
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 612
      tmp___2 = top;
#line 612
      top --;
#line 612
      j = *(VERTICES + tmp___2);
#line 613
      *(INDEX + j) = infinity;
#line 615
      if (i == j) {
#line 616
        goto while_break___1;
      }
#line 618
      fp1 = base___0;
#line 619
      fp2 = F + j * tokensetsize;
      {
#line 621
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 621
        if (! ((unsigned long )fp1 < (unsigned long )fp3)) {
#line 621
          goto while_break___2;
        }
#line 622
        tmp___3 = fp2;
#line 622
        fp2 ++;
#line 622
        tmp___4 = fp1;
#line 622
        fp1 ++;
#line 622
        *tmp___3 = *tmp___4;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 625
  return;
}
}
#line 13 "/home/june/collector/temp/btyacc-3.0/lr0.c"
static core **state_set___0  ;
#line 14 "/home/june/collector/temp/btyacc-3.0/lr0.c"
static core *this_state___0  ;
#line 15 "/home/june/collector/temp/btyacc-3.0/lr0.c"
static core *last_state___0  ;
#line 16 "/home/june/collector/temp/btyacc-3.0/lr0.c"
static shifts *last_shift___0  ;
#line 17 "/home/june/collector/temp/btyacc-3.0/lr0.c"
static reductions *last_reduction___0  ;
#line 19 "/home/june/collector/temp/btyacc-3.0/lr0.c"
static int nshifts___0  ;
#line 20 "/home/june/collector/temp/btyacc-3.0/lr0.c"
static Yshort *shift_symbol___0  ;
#line 22 "/home/june/collector/temp/btyacc-3.0/lr0.c"
static Yshort *redset___0  ;
#line 23 "/home/june/collector/temp/btyacc-3.0/lr0.c"
static Yshort *shiftset___0  ;
#line 25 "/home/june/collector/temp/btyacc-3.0/lr0.c"
static Yshort **kernel_base___0  ;
#line 26 "/home/june/collector/temp/btyacc-3.0/lr0.c"
static Yshort **kernel_end___0  ;
#line 27 "/home/june/collector/temp/btyacc-3.0/lr0.c"
static Yshort *kernel_items___0  ;
