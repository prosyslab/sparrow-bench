/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 136 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_3 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_3 fd_set;
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/resource.h"
typedef __rlim_t rlim_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/resource.h"
struct rlimit {
   rlim_t rlim_cur ;
   rlim_t rlim_max ;
};
#line 42 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef int __rlimit_resource_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __u_char;
#line 32 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __u_int;
#line 33 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_long;
#line 33 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_char u_char;
#line 35 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_int u_int;
#line 36 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_long u_long;
#line 44 "./httperf.h"
typedef double Time;
#line 49 "./httperf.h"
union __anonunion_Any_Type_39 {
   char c ;
   int i ;
   long l ;
   u_char uc ;
   u_int ui ;
   u_long ul ;
   float f ;
   double d ;
   void *vp ;
   void const   *cvp ;
};
#line 49 "./httperf.h"
typedef union __anonunion_Any_Type_39 Any_Type;
#line 43 "/usr/include/x86_64-linux-gnu/bits/uio.h"
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
#line 47 "./object.h"
enum Object_Type {
    OBJ_CONN = 0,
    OBJ_CALL = 1,
    OBJ_SESS = 2,
    OBJ_NUM_TYPES = 3
} ;
#line 47 "./object.h"
typedef enum Object_Type Object_Type;
#line 56 "./object.h"
struct Object {
   Object_Type type ;
   u_int ref_count ;
};
#line 56 "./object.h"
typedef struct Object Object;
#line 44 "./timer.h"
struct Timer;
#line 47 "./timer.h"
struct Timer_Queue {
   struct Timer *next ;
   struct Timer *prev ;
};
#line 47 "./timer.h"
typedef struct Timer_Queue Timer_Queue;
#line 54 "./timer.h"
struct Timer {
   Timer_Queue q ;
   u_long delta ;
   void (*func)(struct Timer *t , Any_Type arg ) ;
   Any_Type arg ;
};
#line 54 "./timer.h"
typedef struct Timer Timer;
#line 55 "./conn.h"
struct Call;
#line 57
enum Conn_State {
    S_INITIAL = 0,
    S_CONNECTING = 1,
    S_CONNECTED = 2,
    S_REPLY_STATUS = 3,
    S_REPLY_HEADER = 4,
    S_REPLY_CONTINUE = 5,
    S_REPLY_DATA = 6,
    S_REPLY_CHUNKED = 7,
    S_REPLY_FOOTER = 8,
    S_REPLY_DONE = 9,
    S_CLOSING = 10,
    S_FREE = 11
} ;
#line 57 "./conn.h"
typedef enum Conn_State Conn_State;
#line 74 "./conn.h"
struct __anonstruct_basic_46 {
   Time time_connect_start ;
   u_int num_calls_completed ;
};
#line 74 "./conn.h"
struct Conn {
   Object obj ;
   Conn_State state ;
   struct Conn *next ;
   struct Call *sendq ;
   struct Call *sendq_tail ;
   struct Call *recvq ;
   struct Call *recvq_tail ;
   Timer *watchdog ;
   struct __anonstruct_basic_46 basic ;
   size_t hostname_len ;
   char const   *hostname ;
   size_t fqdname_len ;
   char const   *fqdname ;
   int port ;
   int sd ;
   int myport ;
   struct iovec line ;
   size_t content_length ;
   u_int has_body : 1 ;
   u_int is_chunked : 1 ;
   char line_buf[1024] ;
};
#line 74 "./conn.h"
typedef struct Conn Conn;
#line 67 "./call.h"
struct __anonstruct_basic_47 {
   Time time_send_start ;
   Time time_recv_start ;
};
#line 67 "./call.h"
struct __anonstruct_req_48 {
   int version ;
   u_int num_extra_hdrs ;
   int iov_index ;
   size_t size ;
   struct iovec iov_saved ;
   struct iovec iov[13] ;
};
#line 67 "./call.h"
struct __anonstruct_reply_49 {
   int status ;
   int version ;
   size_t header_bytes ;
   size_t content_bytes ;
   size_t footer_bytes ;
};
#line 67 "./call.h"
struct Call {
   Object obj ;
   u_long id ;
   struct Conn *conn ;
   struct Call *sendq_next ;
   struct Call *recvq_next ;
   Time timeout ;
   struct __anonstruct_basic_47 basic ;
   struct __anonstruct_req_48 req ;
   struct __anonstruct_reply_49 reply ;
};
#line 67 "./call.h"
typedef struct Call Call;
#line 41 "./event.h"
enum Event_Type {
    EV_PERF_SAMPLE = 0,
    EV_HOSTNAME_LOOKUP_START = 1,
    EV_HOSTNAME_LOOKUP_STOP = 2,
    EV_SESS_NEW = 3,
    EV_SESS_FAILED = 4,
    EV_SESS_DESTROYED = 5,
    EV_CONN_NEW = 6,
    EV_CONN_CONNECTING = 7,
    EV_CONN_CONNECTED = 8,
    EV_CONN_CLOSE = 9,
    EV_CONN_DESTROYED = 10,
    EV_CONN_FAILED = 11,
    EV_CONN_TIMEOUT = 12,
    EV_CALL_NEW = 13,
    EV_CALL_ISSUE = 14,
    EV_CALL_SEND_START = 15,
    EV_CALL_SEND_RAW_DATA = 16,
    EV_CALL_SEND_STOP = 17,
    EV_CALL_RECV_START = 18,
    EV_CALL_RECV_HDR = 19,
    EV_CALL_RECV_RAW_DATA = 20,
    EV_CALL_RECV_DATA = 21,
    EV_CALL_RECV_FOOTER = 22,
    EV_CALL_RECV_STOP = 23,
    EV_CALL_DESTROYED = 24,
    EV_NUM_EVENT_TYPES = 25
} ;
#line 41 "./event.h"
typedef enum Event_Type Event_Type;
#line 50 "./sess.h"
struct Sess {
   Object obj ;
   u_int failed : 1 ;
};
#line 50 "./sess.h"
typedef struct Sess Sess;
#line 57 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/object.c"
struct free_list_el {
   struct free_list_el *next ;
};
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 183 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 116 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __caddr_t caddr_t;
#line 82 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __fd_mask fd_mask;
#line 379 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct linger {
   int l_onoff ;
   int l_linger ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/resource.h"
enum __rlimit_resource {
    RLIMIT_CPU = 0,
    RLIMIT_FSIZE = 1,
    RLIMIT_DATA = 2,
    RLIMIT_STACK = 3,
    RLIMIT_CORE = 4,
    __RLIMIT_RSS = 5,
    RLIMIT_NOFILE = 7,
    __RLIMIT_OFILE = 7,
    RLIMIT_AS = 9,
    __RLIMIT_NPROC = 6,
    __RLIMIT_MEMLOCK = 8,
    __RLIMIT_LOCKS = 10,
    __RLIMIT_SIGPENDING = 11,
    __RLIMIT_MSGQUEUE = 12,
    __RLIMIT_NICE = 13,
    __RLIMIT_RTPRIO = 14,
    __RLIMIT_RTTIME = 15,
    __RLIMIT_NLIMITS = 16,
    __RLIM_NLIMITS = 16
} ;
#line 64 "./httperf.h"
enum Dist_Type {
    DETERMINISTIC = 0,
    UNIFORM = 1,
    EXPONENTIAL = 2
} ;
#line 64 "./httperf.h"
typedef enum Dist_Type Dist_Type;
#line 94 "./httperf.h"
struct Rate_Info {
   Dist_Type dist ;
   double rate_param ;
   Time mean_iat ;
   Time min_iat ;
   Time max_iat ;
};
#line 94 "./httperf.h"
typedef struct Rate_Info Rate_Info;
#line 107 "./httperf.h"
struct __anonstruct_client_84 {
   u_int id ;
   u_int num_clients ;
};
#line 107 "./httperf.h"
struct __anonstruct_wlog_85 {
   char *file ;
   char do_loop ;
};
#line 107 "./httperf.h"
struct __anonstruct_wsess_86 {
   u_int num_sessions ;
   u_int num_calls ;
   Time think_time ;
};
#line 107 "./httperf.h"
struct __anonstruct_wsesspage_87 {
   u_int num_sessions ;
   u_int num_reqs ;
   Time think_time ;
};
#line 107 "./httperf.h"
struct __anonstruct_wsesslog_88 {
   u_int num_sessions ;
   Time think_time ;
   char *file ;
};
#line 107 "./httperf.h"
struct __anonstruct_wset_89 {
   u_int num_files ;
   double target_miss_rate ;
};
#line 107 "./httperf.h"
struct Cmdline_Params {
   int http_version ;
   char const   *server ;
   char const   *server_name ;
   int port ;
   char const   *uri ;
   Rate_Info rate ;
   Time timeout ;
   Time think_timeout ;
   int num_conns ;
   int num_calls ;
   int burst_len ;
   int max_piped ;
   int max_conns ;
   int hog ;
   int send_buffer_size ;
   int recv_buffer_size ;
   int failure_status ;
   int retry_on_failure ;
   int close_with_reset ;
   int print_request ;
   int print_reply ;
   int session_cookies ;
   int no_host_hdr ;
   char const   *additional_header ;
   char const   *method ;
   struct __anonstruct_client_84 client ;
   struct __anonstruct_wlog_85 wlog ;
   struct __anonstruct_wsess_86 wsess ;
   struct __anonstruct_wsesspage_87 wsesspage ;
   struct __anonstruct_wsesslog_88 wsesslog ;
   struct __anonstruct_wset_89 wset ;
};
#line 107 "./httperf.h"
typedef struct Cmdline_Params Cmdline_Params;
#line 167 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/core.c"
struct hash_entry {
   char const   *hostname ;
   int port ;
   struct sockaddr_in sin ;
};
#line 72 "./../httperf.h"
struct Load_Generator {
   char const   *name ;
   void (*init)(void) ;
   void (*start)(void) ;
   void (*stop)(void) ;
};
#line 72 "./../httperf.h"
typedef struct Load_Generator Load_Generator;
#line 65 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/sess_cookie.c"
struct Sess_Private_Data {
   size_t cookie_len ;
   char cookie[256] ;
};
#line 65 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/sess_cookie.c"
typedef struct Sess_Private_Data Sess_Private_Data;
#line 85 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/sess_cookie.c"
struct Call_Private_Data {
   u_int cookie_present ;
   char cookie[256] ;
};
#line 85 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/sess_cookie.c"
typedef struct Call_Private_Data Call_Private_Data;
#line 31 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __u_short;
#line 34 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_short u_short;
#line 41 "./rate.h"
struct Rate_Generator {
   u_short xsubi[3] ;
   Rate_Info *rate ;
   Time start ;
   Time next_time ;
   Any_Type arg ;
   Timer *timer ;
   int (*tick)(Any_Type arg ) ;
   int done ;
   Time (*next_interarrival_time)(struct Rate_Generator *rg ) ;
};
#line 41 "./rate.h"
typedef struct Rate_Generator Rate_Generator;
#line 88 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/session.c"
struct Conn_Info {
   Conn *conn ;
   u_int is_connected : 1 ;
   u_int is_successful : 1 ;
   u_int num_pending ;
   u_int num_sent ;
   u_int rd ;
   u_int wr ;
   Call *call[32] ;
};
#line 88 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/session.c"
struct Sess_Private_Data___0 {
   struct Conn_Info conn_info[4] ;
};
#line 88 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/session.c"
typedef struct Sess_Private_Data___0 Sess_Private_Data___0;
#line 107 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/session.c"
struct Conn_Private_Data {
   Sess *sess ;
   struct Conn_Info *ci ;
};
#line 107 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/session.c"
typedef struct Conn_Private_Data Conn_Private_Data;
#line 114 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/session.c"
struct Call_Private_Data___0 {
   Sess *sess ;
};
#line 114 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/session.c"
typedef struct Call_Private_Data___0 Call_Private_Data___0;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 81 "./lib/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 158 "/usr/include/x86_64-linux-gnu/bits/resource.h"
enum __rusage_who {
    RUSAGE_SELF = 0,
    RUSAGE_CHILDREN = -1,
    RUSAGE_THREAD = 1
} ;
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_55 {
   long ru_maxrss ;
   __syscall_slong_t __ru_maxrss_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_56 {
   long ru_ixrss ;
   __syscall_slong_t __ru_ixrss_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_57 {
   long ru_idrss ;
   __syscall_slong_t __ru_idrss_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_58 {
   long ru_isrss ;
   __syscall_slong_t __ru_isrss_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_59 {
   long ru_minflt ;
   __syscall_slong_t __ru_minflt_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_60 {
   long ru_majflt ;
   __syscall_slong_t __ru_majflt_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_61 {
   long ru_nswap ;
   __syscall_slong_t __ru_nswap_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_62 {
   long ru_inblock ;
   __syscall_slong_t __ru_inblock_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_63 {
   long ru_oublock ;
   __syscall_slong_t __ru_oublock_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_64 {
   long ru_msgsnd ;
   __syscall_slong_t __ru_msgsnd_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_65 {
   long ru_msgrcv ;
   __syscall_slong_t __ru_msgrcv_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_66 {
   long ru_nsignals ;
   __syscall_slong_t __ru_nsignals_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_67 {
   long ru_nvcsw ;
   __syscall_slong_t __ru_nvcsw_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_68 {
   long ru_nivcsw ;
   __syscall_slong_t __ru_nivcsw_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
struct rusage {
   struct timeval ru_utime ;
   struct timeval ru_stime ;
   union __anonunion____missing_field_name_55 __annonCompField2 ;
   union __anonunion____missing_field_name_56 __annonCompField3 ;
   union __anonunion____missing_field_name_57 __annonCompField4 ;
   union __anonunion____missing_field_name_58 __annonCompField5 ;
   union __anonunion____missing_field_name_59 __annonCompField6 ;
   union __anonunion____missing_field_name_60 __annonCompField7 ;
   union __anonunion____missing_field_name_61 __annonCompField8 ;
   union __anonunion____missing_field_name_62 __annonCompField9 ;
   union __anonunion____missing_field_name_63 __annonCompField10 ;
   union __anonunion____missing_field_name_64 __annonCompField11 ;
   union __anonunion____missing_field_name_65 __annonCompField12 ;
   union __anonunion____missing_field_name_66 __annonCompField13 ;
   union __anonunion____missing_field_name_67 __annonCompField14 ;
   union __anonunion____missing_field_name_68 __annonCompField15 ;
};
#line 39 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef enum __rusage_who __rusage_who_t;
#line 81 "./httperf.h"
struct Stat_Collector {
   char const   *name ;
   void (*init)(void) ;
   void (*start)(void) ;
   void (*stop)(void) ;
   void (*dump)(void) ;
};
#line 81 "./httperf.h"
typedef struct Stat_Collector Stat_Collector;
#line 50 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/call_seq.c"
struct Conn_Private_Data___0 {
   int num_calls ;
   int num_completed ;
   int num_destroyed ;
};
#line 50 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/call_seq.c"
typedef struct Conn_Private_Data___0 Conn_Private_Data___0;
#line 72 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/event.c"
struct closure {
   void (*op)(Event_Type type , Object *obj , Any_Type registration_time_arg , Any_Type signal_time_arg ) ;
   Any_Type arg ;
};
#line 72 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/event.c"
struct Event_Action {
   int num_ops ;
   struct closure closure[4] ;
};
#line 72 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/event.c"
typedef struct Event_Action Event_Action;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  * __restrict  __addr , socklen_t __len ) ;
#line 379 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 144 "/usr/include/netdb.h"
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 846
extern void perror(char const   *__s ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 460
extern int usleep(__useconds_t __useconds ) ;
#line 73 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) inet_aton)(char const   *__cp ,
                                                                                struct in_addr *__inp ) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 50 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getrlimit)(__rlimit_resource_t __resource ,
                                                                                struct rlimit *__rlimits ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setrlimit)(__rlimit_resource_t __resource ,
                                                                                struct rlimit  const  *__rlimits ) ;
#line 51 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/idleconn.c"
char const   *prog_name  ;
#line 52 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/idleconn.c"
unsigned long num_conn  ;
#line 52 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/idleconn.c"
unsigned long num_closed  ;
#line 53 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/idleconn.c"
struct timeval start_time  ;
#line 55 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/idleconn.c"
void sigint_handler(int signal___0 ) 
{ 
  struct timeval stop_time ;
  double delta_t ;

  {
  {
#line 61
  gettimeofday((struct timeval */* __restrict  */)(& stop_time), (__timezone_ptr_t )((void *)0));
#line 63
  delta_t = (double )(stop_time.tv_sec - start_time.tv_sec) + 1e-6 * (double )(stop_time.tv_usec - start_time.tv_usec);
#line 66
  printf((char const   */* __restrict  */)"%s: total # conn. created = %lu, close() rate = %g conn/sec\n",
         prog_name, num_conn, (double )num_closed / delta_t);
#line 68
  exit(0);
  }
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/idleconn.c"
int main(int argc , char **argv ) 
{ 
  int desired ;
  int current ;
  int port ;
  int sd ;
  int max_sd___0 ;
  int n ;
  int i ;
  struct sockaddr_in sin ;
  struct sockaddr_in server_addr ;
  fd_set readable ;
  fd_set rdfds___0 ;
  struct rlimit rlimit ;
  struct hostent *he ;
  char *server ;
  char *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;

  {
  {
#line 74
  current = 0;
#line 74
  max_sd___0 = 0;
#line 81
  signal(2, & sigint_handler);
#line 83
  tmp = strrchr((char const   *)*(argv + 0), '/');
#line 83
  prog_name = (char const   *)tmp;
  }
#line 84
  if (prog_name) {
#line 85
    prog_name ++;
  } else {
#line 87
    prog_name = (char const   *)*(argv + 0);
  }
  {
#line 89
  memset((void *)(& rdfds___0), 0, sizeof(rdfds___0));
  }
#line 91
  if (argc != 4) {
    {
#line 93
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s server port numidle\n",
            prog_name);
#line 94
    exit(-1);
    }
  }
  {
#line 97
  server = *(argv + 1);
#line 98
  port = atoi((char const   *)*(argv + 2));
#line 99
  desired = atoi((char const   *)*(argv + 3));
#line 102
  tmp___2 = getrlimit(7, & rlimit);
  }
#line 102
  if (tmp___2 < 0) {
    {
#line 104
    tmp___0 = __errno_location();
#line 104
    tmp___1 = strerror(*tmp___0);
#line 104
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: failed to get number of open file limit: %s",
            prog_name, tmp___1);
#line 106
    exit(1);
    }
  }
#line 109
  if (rlimit.rlim_max > 1024UL) {
    {
#line 111
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: warning: open file limit > FD_SETSIZE; limiting max. # of open files to FD_SETSIZE\n",
            prog_name);
#line 113
    rlimit.rlim_max = (rlim_t )1024;
    }
  }
  {
#line 116
  rlimit.rlim_cur = rlimit.rlim_max;
#line 117
  tmp___5 = setrlimit(7, (struct rlimit  const  *)(& rlimit));
  }
#line 117
  if (tmp___5 < 0) {
    {
#line 119
    tmp___3 = __errno_location();
#line 119
    tmp___4 = strerror(*tmp___3);
#line 119
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: failed to increase number of open file limit: %s",
            prog_name, tmp___4);
#line 121
    exit(1);
    }
  }
  {
#line 124
  printf((char const   */* __restrict  */)"%s: creating and maintaining %d idle connections\n",
         prog_name, desired);
#line 127
  memset((void *)(& server_addr), 0, sizeof(server_addr));
#line 128
  server_addr.sin_family = (sa_family_t )2;
#line 129
  server_addr.sin_port = htons((uint16_t )port);
#line 131
  he = gethostbyname((char const   *)server);
  }
#line 132
  if (he) {
#line 134
    if (he->h_addrtype != 2) {
      {
#line 136
      perror((char const   *)server);
#line 137
      exit(-1);
      }
    } else
#line 134
    if ((unsigned long )he->h_length != sizeof(sin.sin_addr)) {
      {
#line 136
      perror((char const   *)server);
#line 137
      exit(-1);
      }
    }
    {
#line 139
    memcpy((void */* __restrict  */)(& server_addr.sin_addr), (void const   */* __restrict  */)*(he->h_addr_list + 0),
           sizeof(server_addr.sin_addr));
    }
  } else {
    {
#line 143
    tmp___6 = inet_aton((char const   *)server, & server_addr.sin_addr);
    }
#line 143
    if (! tmp___6) {
      {
#line 145
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: invalid server address %s\n",
              prog_name, server);
#line 146
      exit(-1);
      }
    }
  }
  {
#line 149
  gettimeofday((struct timeval */* __restrict  */)(& start_time), (__timezone_ptr_t )((void *)0));
  }
  {
#line 151
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 153
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 153
      if (! (current < desired)) {
#line 153
        goto while_break___0;
      }
      {
#line 156
      sd = socket(2, 1, 0);
      }
#line 157
      if (sd < 0) {
        {
#line 159
        perror("socket");
#line 160
        exit(-1);
        }
      }
      {
#line 163
      sin = server_addr;
#line 164
      tmp___10 = connect(sd, (struct sockaddr  const  *)(& sin), (socklen_t )sizeof(sin));
      }
#line 164
      if (tmp___10 < 0) {
        {
#line 166
        tmp___7 = __errno_location();
#line 166
        tmp___8 = strerror(*tmp___7);
#line 166
        printf((char const   */* __restrict  */)"connect: %s\n", tmp___8);
#line 167
        tmp___9 = __errno_location();
        }
        {
#line 169
        if (*tmp___9 == 111) {
#line 169
          goto case_111;
        }
#line 172
        if (*tmp___9 == 110) {
#line 172
          goto case_110;
        }
#line 176
        goto switch_default;
        case_111: /* CIL Label */ 
        {
#line 171
        usleep((__useconds_t )1000000);
        }
        case_110: /* CIL Label */ 
        {
#line 173
        close(sd);
        }
#line 174
        goto while_continue___0;
        switch_default: /* CIL Label */ 
        {
#line 177
        perror("connect");
#line 178
        exit(-1);
        }
        switch_break: /* CIL Label */ ;
        }
      }
#line 182
      if (sd > max_sd___0) {
#line 183
        max_sd___0 = sd;
      }
#line 188
      num_conn ++;
#line 189
      current ++;
#line 190
      rdfds___0.__fds_bits[sd / (8 * (int )sizeof(__fd_mask ))] |= 1L << sd % (8 * (int )sizeof(__fd_mask ));
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 193
    readable = rdfds___0;
#line 194
    n = select(max_sd___0 + 1, (fd_set */* __restrict  */)(& readable), (fd_set */* __restrict  */)((void *)0),
               (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)((void *)0));
#line 195
    i = 0;
    }
    {
#line 195
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 195
      if (! (i <= max_sd___0)) {
#line 195
        goto while_break___1;
      }
#line 197
      if ((readable.__fds_bits[i / (8 * (int )sizeof(__fd_mask ))] & (1L << i % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 202
        close(i);
#line 203
        current --;
#line 204
        n --;
#line 205
        num_closed ++;
#line 206
        rdfds___0.__fds_bits[i / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << i % (8 * (int )sizeof(__fd_mask )));
        }
      }
#line 208
      if (n <= 0) {
#line 209
        goto while_break___1;
      }
#line 195
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 201 "./httperf.h"
void panic(char const   *msg  , ...) ;
#line 67 "./object.h"
size_t object_expand(Object_Type type , size_t size ) ;
#line 70
Object *object_new(Object_Type type ) ;
#line 77
void object_dec_ref(Object *obj ) ;
#line 119 "./conn.h"
void conn_init(Conn *conn___0 ) ;
#line 122
void conn_deinit(Conn *conn___0 ) ;
#line 114 "./call.h"
void call_init(Call *c ) ;
#line 117
void call_deinit(Call *call ) ;
#line 91 "./event.h"
void event_signal(Event_Type type , Object *obj , Any_Type arg ) ;
#line 61 "./sess.h"
void sess_init(Sess *sess ) ;
#line 64
void sess_deinit(Sess *sess ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/object.c"
static size_t type_size[3]  = {      ((sizeof(Conn ) + sizeof(double )) - 1UL) & ~ (sizeof(double ) - 1UL),      ((sizeof(Call ) + sizeof(double )) - 1UL) & ~ (sizeof(double ) - 1UL),      ((sizeof(Sess ) + sizeof(double )) - 1UL) & ~ (sizeof(double ) - 1UL)};
#line 62 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/object.c"
static struct free_list_el *free_list[3]  ;
#line 64 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/object.c"
static void object_destroy(Object *obj ) 
{ 
  Object_Type type ;
  struct free_list_el *el ;
  Event_Type event ;
  Any_Type arg ;

  {
#line 67
  type = obj->type;
#line 69
  event = (Event_Type )0;
  {
#line 74
  if ((unsigned int )type == 1U) {
#line 74
    goto case_1;
  }
#line 79
  if ((unsigned int )type == 0U) {
#line 79
    goto case_0;
  }
#line 84
  if ((unsigned int )type == 2U) {
#line 84
    goto case_2;
  }
#line 89
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 75
  call_deinit((Call *)obj);
#line 76
  event = (Event_Type )24;
  }
#line 77
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 80
  conn_deinit((Conn *)obj);
#line 81
  event = (Event_Type )10;
  }
#line 82
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 85
  sess_deinit((Sess *)obj);
#line 86
  event = (Event_Type )5;
  }
#line 87
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 90
  __assert_fail("0", "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/object.c",
                90U, "object_destroy");
  }
#line 91
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 93
  arg.l = 0L;
#line 94
  event_signal(event, obj, arg);
#line 99
  el = (struct free_list_el *)obj;
#line 100
  el->next = free_list[type];
#line 101
  free_list[type] = el;
  }
#line 102
  return;
}
}
#line 104 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/object.c"
size_t object_expand(Object_Type type , size_t size ) 
{ 
  size_t offset ;

  {
#line 107
  offset = type_size[type];
#line 108
  type_size[type] += ((size + sizeof(double )) - 1UL) & ~ (sizeof(double ) - 1UL);
#line 109
  return (offset);
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/object.c"
Object *object_new(Object_Type type ) 
{ 
  struct free_list_el *el ;
  Event_Type event ;
  size_t obj_size ;
  Any_Type arg ;
  Object *obj ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
#line 116
  event = (Event_Type )0;
#line 121
  obj_size = type_size[type];
#line 123
  if (free_list[type]) {
#line 125
    el = free_list[type];
#line 126
    free_list[type] = el->next;
#line 127
    obj = (Object *)el;
  } else {
    {
#line 131
    tmp = malloc(obj_size);
#line 131
    obj = (Object *)tmp;
    }
#line 132
    if (! obj) {
      {
#line 134
      tmp___0 = __errno_location();
#line 134
      tmp___1 = strerror(*tmp___0);
#line 134
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s.object_new: %s\n",
              prog_name, tmp___1);
      }
#line 135
      return ((Object *)0);
    }
  }
  {
#line 138
  memset((void *)obj, 0, obj_size);
#line 139
  obj->ref_count = (u_int )1;
#line 140
  obj->type = type;
  }
  {
#line 143
  if ((unsigned int )type == 1U) {
#line 143
    goto case_1;
  }
#line 148
  if ((unsigned int )type == 0U) {
#line 148
    goto case_0;
  }
#line 153
  if ((unsigned int )type == 2U) {
#line 153
    goto case_2;
  }
#line 158
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 144
  call_init((Call *)obj);
#line 145
  event = (Event_Type )13;
  }
#line 146
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 149
  conn_init((Conn *)obj);
#line 150
  event = (Event_Type )6;
  }
#line 151
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 154
  sess_init((Sess *)obj);
#line 155
  event = (Event_Type )3;
  }
#line 156
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 159
  panic("object_new: bad object type %d\n", (unsigned int )type);
  }
#line 160
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 162
  arg.l = 0L;
#line 163
  event_signal(event, obj, arg);
  }
#line 164
  return (obj);
}
}
#line 167 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/object.c"
void object_dec_ref(Object *obj ) 
{ 


  {
#line 170
  if (! (obj->ref_count > 0U)) {
    {
#line 170
    __assert_fail("obj->ref_count > 0", "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/object.c",
                  170U, "object_dec_ref");
    }
  }
#line 172
  (obj->ref_count) --;
#line 172
  if (obj->ref_count == 0U) {
    {
#line 173
    object_destroy(obj);
    }
  }
#line 174
  return;
}
}
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 50 "/usr/include/x86_64-linux-gnu/sys/uio.h"
extern ssize_t writev(int __fd , struct iovec  const  *__iovec , int __count ) ;
#line 123 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  * __restrict  __addr ,
                                                                           socklen_t __len ) ;
#line 219
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void * __restrict  __optval ,
                                                                                 socklen_t * __restrict  __optlen ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 523
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ffs)(int __i )  __attribute__((__const__)) ;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 182 "./httperf.h"
int verbose ;
#line 183
Cmdline_Params param ;
#line 64 "./timer.h"
Time timer_now(void) ;
#line 68
void timer_tick(void) ;
#line 70
Timer *timer_schedule(void (*timeout)(struct Timer *t , Any_Type arg ) , Any_Type arg ,
                      Time delay ) ;
#line 72
void timer_cancel(Timer *t ) ;
#line 42 "./core.h"
void core_init(void) ;
#line 45
int core_connect(Conn *s ) ;
#line 46
int core_send(Conn *conn___0 , Call *call ) ;
#line 47
void core_close(Conn *conn___0 ) ;
#line 49
void core_loop(void) ;
#line 50
void core_exit(void) ;
#line 43 "./http.h"
void http_process_reply_bytes(Call *c , char **bufp , size_t *buf_lenp ) ;
#line 99 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/core.c"
static int running  =    1;
#line 100 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/core.c"
static int iteration  ;
#line 101 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/core.c"
static u_long max_burst_len  ;
#line 102 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/core.c"
static fd_set rdfds  ;
#line 102 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/core.c"
static fd_set wrfds  ;
#line 103 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/core.c"
static int min_sd  =    2147483647;
#line 103 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/core.c"
static int max_sd  =    0;
#line 103 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/core.c"
static int alloced_sd_to_conn  =    0;
#line 104 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/core.c"
static struct timeval select_timeout  ;
#line 105 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/core.c"
static struct sockaddr_in myaddr  ;
#line 106 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/core.c"
Conn **sd_to_conn  ;
#line 107 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/core.c"
static u_long port_free_map[(64511UL + 8UL * sizeof(u_long )) / (8UL * sizeof(u_long ))]  ;
#line 109 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/core.c"
static char http10req[69]  = 
#line 109
  {      (char )' ',      (char )'H',      (char )'T',      (char )'T', 
        (char )'P',      (char )'/',      (char )'1',      (char )'.', 
        (char )'0',      (char )'\r',      (char )'\n',      (char )'U', 
        (char )'s',      (char )'e',      (char )'r',      (char )'-', 
        (char )'A',      (char )'g',      (char )'e',      (char )'n', 
        (char )'t',      (char )':',      (char )' ',      (char )'h', 
        (char )'t',      (char )'t',      (char )'p',      (char )'e', 
        (char )'r',      (char )'f',      (char )'/',      (char )'0', 
        (char )'.',      (char )'9',      (char )'.',      (char )'0', 
        (char )'\r',      (char )'\n',      (char )'C',      (char )'o', 
        (char )'n',      (char )'n',      (char )'e',      (char )'c', 
        (char )'t',      (char )'i',      (char )'o',      (char )'n', 
        (char )':',      (char )' ',      (char )'k',      (char )'e', 
        (char )'e',      (char )'p',      (char )'-',      (char )'a', 
        (char )'l',      (char )'i',      (char )'v',      (char )'e', 
        (char )'\r',      (char )'\n',      (char )'H',      (char )'o', 
        (char )'s',      (char )'t',      (char )':',      (char )' ', 
        (char )'\000'};
#line 112 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/core.c"
static char http11req[45]  = 
#line 112
  {      (char )' ',      (char )'H',      (char )'T',      (char )'T', 
        (char )'P',      (char )'/',      (char )'1',      (char )'.', 
        (char )'1',      (char )'\r',      (char )'\n',      (char )'U', 
        (char )'s',      (char )'e',      (char )'r',      (char )'-', 
        (char )'A',      (char )'g',      (char )'e',      (char )'n', 
        (char )'t',      (char )':',      (char )' ',      (char )'h', 
        (char )'t',      (char )'t',      (char )'p',      (char )'e', 
        (char )'r',      (char )'f',      (char )'/',      (char )'0', 
        (char )'.',      (char )'9',      (char )'.',      (char )'0', 
        (char )'\r',      (char )'\n',      (char )'H',      (char )'o', 
        (char )'s',      (char )'t',      (char )':',      (char )' ', 
        (char )'\000'};
#line 115 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/core.c"
static char http10req_nohost[63]  = 
#line 115
  {      (char )' ',      (char )'H',      (char )'T',      (char )'T', 
        (char )'P',      (char )'/',      (char )'1',      (char )'.', 
        (char )'0',      (char )'\r',      (char )'\n',      (char )'U', 
        (char )'s',      (char )'e',      (char )'r',      (char )'-', 
        (char )'A',      (char )'g',      (char )'e',      (char )'n', 
        (char )'t',      (char )':',      (char )' ',      (char )'h', 
        (char )'t',      (char )'t',      (char )'p',      (char )'e', 
        (char )'r',      (char )'f',      (char )'/',      (char )'0', 
        (char )'.',      (char )'9',      (char )'.',      (char )'0', 
        (char )'\r',      (char )'\n',      (char )'C',      (char )'o', 
        (char )'n',      (char )'n',      (char )'e',      (char )'c', 
        (char )'t',      (char )'i',      (char )'o',      (char )'n', 
        (char )':',      (char )' ',      (char )'k',      (char )'e', 
        (char )'e',      (char )'p',      (char )'-',      (char )'a', 
        (char )'l',      (char )'i',      (char )'v',      (char )'e', 
        (char )'\r',      (char )'\n',      (char )'\000'};
#line 118 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/core.c"
static char http11req_nohost[39]  = 
#line 118
  {      (char )' ',      (char )'H',      (char )'T',      (char )'T', 
        (char )'P',      (char )'/',      (char )'1',      (char )'.', 
        (char )'1',      (char )'\r',      (char )'\n',      (char )'U', 
        (char )'s',      (char )'e',      (char )'r',      (char )'-', 
        (char )'A',      (char )'g',      (char )'e',      (char )'n', 
        (char )'t',      (char )':',      (char )' ',      (char )'h', 
        (char )'t',      (char )'t',      (char )'p',      (char )'e', 
        (char )'r',      (char )'f',      (char )'/',      (char )'0', 
        (char )'.',      (char )'9',      (char )'.',      (char )'0', 
        (char )'\r',      (char )'\n',      (char )'\000'};
#line 167 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/core.c"
struct hash_entry hash_table[1024]  ;
#line 175 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/core.c"
static int hash_code(char const   *server , size_t server_len , int port ) 
{ 
  u_char *cp ;
  u_long h ;
  u_long g ;
  int ch ;
  u_char *tmp ;

  {
#line 178
  cp = (u_char *)server;
#line 179
  h = (u_long )port;
  {
#line 185
  while (1) {
    while_continue: /* CIL Label */ ;
#line 185
    tmp = cp;
#line 185
    cp ++;
#line 185
    ch = (int )*tmp;
#line 185
    if (! (ch != 0)) {
#line 185
      goto while_break;
    }
#line 187
    h = (h << 4) + (u_long )ch;
#line 188
    g = h & 4026531840UL;
#line 188
    if (g != 0UL) {
#line 190
      h ^= g >> 24;
#line 191
      h &= ~ g;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 194
  return ((int )h);
}
}
#line 197 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/core.c"
static struct hash_entry *hash_enter(char const   *server , size_t server_len , int port ,
                                     struct sockaddr_in *sin ) 
{ 
  struct hash_entry *he ;
  int index___0 ;
  int tmp ;

  {
  {
#line 203
  tmp = hash_code(server, server_len, port);
#line 203
  index___0 = tmp % 1024;
  }
  {
#line 205
  while (1) {
    while_continue: /* CIL Label */ ;
#line 205
    if (! hash_table[index___0].hostname) {
#line 205
      goto while_break;
    }
#line 207
    index___0 ++;
#line 208
    if (index___0 >= 1024) {
#line 209
      index___0 = 0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 211
  he = hash_table + index___0;
#line 212
  he->hostname = server;
#line 213
  he->port = port;
#line 214
  he->sin = *sin;
#line 215
  return (he);
}
}
#line 218 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/core.c"
static struct sockaddr_in *hash_lookup(char const   *server , size_t server_len ,
                                       int port ) 
{ 
  int index___0 ;
  int start_index ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 223
  tmp = hash_code(server, server_len, port);
#line 223
  start_index = tmp % 1024;
#line 223
  index___0 = start_index;
  }
  {
#line 224
  while (1) {
    while_continue: /* CIL Label */ ;
#line 224
    if (! hash_table[index___0].hostname) {
#line 224
      goto while_break;
    }
#line 226
    if (hash_table[index___0].port == port) {
      {
#line 226
      tmp___0 = strcmp(hash_table[index___0].hostname, server);
      }
#line 226
      if (tmp___0 == 0) {
#line 228
        return (& hash_table[index___0].sin);
      }
    }
#line 230
    index___0 ++;
#line 231
    if (index___0 >= 1024) {
#line 232
      index___0 = 0;
    }
#line 233
    if (index___0 == start_index) {
#line 234
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 236
  return ((struct sockaddr_in *)0);
}
}
#line 239 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/core.c"
static int lffs(long w ) 
{ 
  int r ;

  {
#line 244
  if (sizeof(w) == sizeof(int )) {
    {
#line 245
    r = ffs((int )w);
    }
  } else {
    {
#line 248
    r = ffs((int )w);
    }
  }
#line 258
  return (r);
}
}
#line 261 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/core.c"
static void port_put(int port ) 
{ 
  int i ;
  int bit ;

  {
#line 266
  port -= 1024;
#line 267
  i = (int )((unsigned long )port / (8UL * sizeof(u_long )));
#line 268
  bit = (int )((unsigned long )port % (8UL * sizeof(u_long )));
#line 269
  port_free_map[i] |= 1UL << bit;
#line 270
  return;
}
}
#line 275
static int port_get(void) ;
#line 275 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/core.c"
static u_long mask  =    ~ 0UL;
#line 276 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/core.c"
static int previous  =    0;
#line 272 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/core.c"
static int port_get(void) 
{ 
  int port ;
  int bit ;
  int i ;
  int tmp ;

  {
#line 279
  i = previous;
#line 280
  if ((port_free_map[i] & mask) == 0UL) {
    {
#line 282
    while (1) {
      while_continue: /* CIL Label */ ;
#line 284
      i ++;
#line 285
      if ((unsigned long )i >= sizeof(port_free_map) / sizeof(port_free_map[0])) {
#line 286
        i = 0;
      }
#line 287
      if (i == previous) {
#line 293
        return (-1);
      }
#line 282
      if (! (port_free_map[i] == 0UL)) {
#line 282
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 297
    mask = ~ 0UL;
  }
  {
#line 299
  previous = i;
#line 301
  tmp = lffs((long )(port_free_map[i] & mask));
#line 301
  bit = tmp - 1;
  }
#line 302
  if ((unsigned long )bit >= 8UL * sizeof(u_long ) - 1UL) {
#line 303
    mask = (u_long )0;
  } else {
#line 305
    mask = ~ ((1UL << (bit + 1)) - 1UL);
  }
#line 306
  port_free_map[i] &= ~ (1UL << bit);
#line 307
  port = (int )(((unsigned long )bit + (unsigned long )i * (8UL * sizeof(u_long ))) + 1024UL);
#line 308
  return (port);
}
}
#line 311 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/core.c"
static void conn_failure(Conn *s , int err ) 
{ 
  Any_Type arg ;

  {
  {
#line 316
  arg.l = (long )err;
#line 317
  event_signal((Event_Type )11, (Object *)s, arg);
#line 319
  core_close(s);
  }
#line 320
  return;
}
}
#line 322 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/core.c"
static void conn_timeout(Timer *t , Any_Type arg ) 
{ 
  Conn *s ;
  Time now___0 ;
  Call *c ;

  {
#line 325
  s = (Conn *)arg.vp;
#line 330
  s->watchdog = (Timer *)0;
#line 332
  if (0) {
#line 334
    c = (Call *)0;
#line 335
    if (s->sd >= 0) {
      {
#line 337
      now___0 = timer_now();
      }
#line 338
      if ((rdfds.__fds_bits[s->sd / (8 * (int )sizeof(__fd_mask ))] & (1L << s->sd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 338
        if (s->recvq) {
#line 338
          if (now___0 >= (s->recvq)->timeout) {
#line 340
            c = s->recvq;
          } else {
#line 338
            goto _L___0;
          }
        } else {
#line 338
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 341
      if ((wrfds.__fds_bits[s->sd / (8 * (int )sizeof(__fd_mask ))] & (1L << s->sd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 341
        if (s->sendq) {
#line 341
          if (now___0 >= (s->sendq)->timeout) {
#line 343
            c = s->sendq;
          }
        }
      }
    }
  }
  {
#line 354
  arg.l = 0L;
#line 355
  event_signal((Event_Type )12, (Object *)s, arg);
#line 357
  core_close(s);
  }
#line 358
  return;
}
}
#line 360 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/core.c"
static void set_active(Conn *s , fd_set *fdset ) 
{ 
  int sd ;
  Any_Type arg ;
  Time timeout ;
  Time tmp ;

  {
#line 363
  sd = s->sd;
#line 367
  fdset->__fds_bits[sd / (8 * (int )sizeof(__fd_mask ))] |= 1L << sd % (8 * (int )sizeof(__fd_mask ));
#line 368
  if (sd < min_sd) {
#line 369
    min_sd = sd;
  }
#line 370
  if (sd >= max_sd) {
#line 371
    max_sd = sd;
  }
#line 373
  if (s->watchdog) {
#line 374
    return;
  }
#line 376
  timeout = 0.0;
#line 377
  if (s->sendq) {
#line 378
    timeout = (s->sendq)->timeout;
  }
#line 379
  if (s->recvq) {
#line 379
    if (timeout == 0.0) {
#line 380
      timeout = (s->recvq)->timeout;
    } else
#line 379
    if (timeout > (s->recvq)->timeout) {
#line 380
      timeout = (s->recvq)->timeout;
    }
  }
#line 382
  if (timeout > 0.0) {
    {
#line 384
    arg.vp = (void *)s;
#line 385
    tmp = timer_now();
#line 385
    s->watchdog = timer_schedule(& conn_timeout, arg, timeout - tmp);
    }
  }
#line 388
  return;
}
}
#line 390 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/core.c"
static void do_send(Conn *conn___0 ) 
{ 
  int async_errno ;
  socklen_t len ;
  struct iovec *iovp ;
  int sd ;
  ssize_t nsent ;
  Any_Type arg ;
  Call *call ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___6 ;
  Time tmp___7 ;
  struct Call *tmp___8 ;
  Time tmp___9 ;

  {
#line 396
  sd = conn___0->sd;
#line 397
  nsent = (ssize_t )0;
  {
#line 401
  while (1) {
    while_continue: /* CIL Label */ ;
#line 403
    call = conn___0->sendq;
#line 404
    if (! call) {
      {
#line 404
      __assert_fail("call", "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/core.c",
                    404U, "do_send");
      }
    }
    {
#line 406
    arg.l = 0L;
#line 407
    event_signal((Event_Type )16, (Object *)call, arg);
    }
    {
#line 422
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 422
      tmp = __errno_location();
#line 422
      *tmp = 0;
#line 422
      nsent = writev(sd, (struct iovec  const  *)(call->req.iov + call->req.iov_index),
                     (int )(sizeof(call->req.iov) / sizeof(call->req.iov[0]) - (unsigned long )call->req.iov_index));
#line 422
      tmp___0 = __errno_location();
      }
#line 422
      if (! (*tmp___0 == 4)) {
#line 422
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 432
    if (nsent < 0L) {
      {
#line 434
      tmp___1 = __errno_location();
      }
#line 434
      if (*tmp___1 == 11) {
#line 435
        return;
      }
      {
#line 437
      len = (socklen_t )sizeof(async_errno);
#line 438
      tmp___3 = getsockopt(sd, 1, 4, (void */* __restrict  */)(& async_errno), (socklen_t */* __restrict  */)(& len));
      }
#line 438
      if (tmp___3 == 0) {
#line 438
        if (async_errno != 0) {
          {
#line 440
          tmp___2 = __errno_location();
#line 440
          *tmp___2 = async_errno;
          }
        }
      }
      {
#line 446
      tmp___6 = __errno_location();
#line 446
      conn_failure(conn___0, *tmp___6);
      }
#line 447
      return;
    }
#line 450
    call->req.size += (size_t )nsent;
#line 452
    iovp = call->req.iov + call->req.iov_index;
    {
#line 453
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 453
      if (! ((unsigned long )iovp < (unsigned long )(call->req.iov + sizeof(call->req.iov) / sizeof(call->req.iov[0])))) {
#line 453
        goto while_break___1;
      }
#line 455
      if ((size_t )nsent < iovp->iov_len) {
#line 457
        iovp->iov_len -= (size_t )nsent;
#line 458
        iovp->iov_base = (void *)((char *)iovp->iov_base + nsent);
#line 459
        goto while_break___1;
      } else {
#line 464
        nsent = (ssize_t )((size_t )nsent - iovp->iov_len);
#line 465
        *iovp = call->req.iov_saved;
#line 466
        iovp ++;
#line 467
        call->req.iov_saved = *iovp;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 470
    call->req.iov_index = (int )(iovp - call->req.iov);
#line 471
    if ((unsigned long )call->req.iov_index < sizeof(call->req.iov) / sizeof(call->req.iov[0])) {
#line 474
      if (param.timeout) {
        {
#line 474
        tmp___7 = timer_now();
#line 474
        call->timeout = tmp___7 + param.timeout;
        }
      } else {
#line 474
        call->timeout = 0.0;
      }
      {
#line 475
      set_active(conn___0, & wrfds);
      }
#line 476
      return;
    }
#line 480
    conn___0->sendq = call->sendq_next;
#line 481
    if (! conn___0->sendq) {
#line 483
      conn___0->sendq_tail = (struct Call *)0;
#line 484
      wrfds.__fds_bits[sd / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << sd % (8 * (int )sizeof(__fd_mask )));
    }
    {
#line 486
    arg.l = 0L;
#line 487
    event_signal((Event_Type )17, (Object *)call, arg);
    }
#line 488
    if ((unsigned int )conn___0->state >= 10U) {
      {
#line 490
      object_dec_ref((Object *)call);
      }
#line 491
      return;
    }
#line 497
    call->recvq_next = (struct Call *)0;
#line 498
    if (! conn___0->recvq) {
#line 499
      tmp___8 = call;
#line 499
      conn___0->recvq_tail = tmp___8;
#line 499
      conn___0->recvq = tmp___8;
    } else {
#line 502
      (conn___0->recvq_tail)->recvq_next = call;
#line 503
      conn___0->recvq_tail = call;
    }
#line 505
    call->timeout = param.timeout + param.think_timeout;
#line 506
    if (call->timeout > 0.0) {
      {
#line 507
      tmp___9 = timer_now();
#line 507
      call->timeout += tmp___9;
      }
    }
    {
#line 508
    set_active(conn___0, & rdfds);
    }
#line 509
    if ((unsigned int )conn___0->state < 3U) {
#line 510
      conn___0->state = (Conn_State )3;
    }
#line 512
    if (! conn___0->sendq) {
#line 513
      return;
    }
    {
#line 515
    arg.l = 0L;
#line 516
    event_signal((Event_Type )15, (Object *)conn___0->sendq, arg);
    }
#line 517
    if ((unsigned int )conn___0->state >= 10U) {
#line 518
      return;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 522 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/core.c"
static void recv_done(Call *call ) 
{ 
  Conn *conn___0 ;
  Any_Type arg ;

  {
#line 525
  conn___0 = call->conn;
#line 528
  conn___0->recvq = call->recvq_next;
#line 529
  if (! conn___0->recvq) {
#line 531
    rdfds.__fds_bits[conn___0->sd / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << conn___0->sd % (8 * (int )sizeof(__fd_mask )));
#line 532
    conn___0->recvq_tail = (struct Call *)0;
  }
  {
#line 535
  arg.l = 0L;
#line 536
  event_signal((Event_Type )23, (Object *)call, arg);
#line 538
  object_dec_ref((Object *)call);
  }
#line 539
  return;
}
}
#line 541 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/core.c"
static void do_recv(Conn *s ) 
{ 
  char *cp ;
  char buf[8193] ;
  Call *c ;
  int saved_errno ;
  ssize_t nread ;
  size_t buf_len ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  Time tmp___7 ;

  {
#line 545
  c = s->recvq;
#line 547
  nread = (ssize_t )0;
#line 550
  if (! c) {
    {
#line 550
    __assert_fail("c", "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/core.c",
                  550U, "do_recv");
    }
  }
  {
#line 561
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 561
    tmp = __errno_location();
#line 561
    *tmp = 0;
#line 561
    nread = read(s->sd, (void *)(buf), sizeof(buf) - 1UL);
#line 561
    tmp___0 = __errno_location();
    }
#line 561
    if (! (*tmp___0 == 4)) {
#line 561
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 564
  tmp___1 = __errno_location();
#line 564
  saved_errno = *tmp___1;
  }
#line 565
  if (nread <= 0L) {
#line 577
    if (nread < 0L) {
#line 579
      if (saved_errno != 11) {
        {
#line 580
        conn_failure(s, saved_errno);
        }
      }
    } else
#line 582
    if ((unsigned int )s->state != 6U) {
      {
#line 583
      conn_failure(s, 104);
      }
    } else {
#line 586
      if ((unsigned int )s->state < 10U) {
#line 587
        s->state = (Conn_State )9;
      }
      {
#line 588
      recv_done(c);
      }
    }
#line 590
    return;
  }
#line 592
  buf[nread] = (char )'\000';
#line 617
  buf_len = (size_t )nread;
#line 618
  cp = buf;
  {
#line 619
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 621
    c = s->recvq;
#line 622
    if (! c) {
      {
#line 622
      __assert_fail("c", "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/core.c",
                    622U, "do_recv");
      }
    }
#line 624
    if ((unsigned int )s->state == 3U) {
#line 626
      c->timeout = param.timeout + param.think_timeout;
#line 627
      if (c->timeout > 0.0) {
        {
#line 628
        tmp___7 = timer_now();
#line 628
        c->timeout += tmp___7;
        }
      }
    }
    {
#line 631
    http_process_reply_bytes(c, & cp, & buf_len);
    }
#line 632
    if ((unsigned int )s->state == 9U) {
      {
#line 634
      recv_done(c);
      }
#line 635
      if ((unsigned int )s->state >= 10U) {
#line 636
        return;
      }
#line 638
      s->state = (Conn_State )3;
    }
#line 619
    if (! (buf_len > 0UL)) {
#line 619
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 643
  if (s->recvq) {
    {
#line 644
    set_active(c->conn, & rdfds);
    }
  }
#line 645
  return;
}
}
#line 647 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/core.c"
struct sockaddr_in *core_addr_intern(char const   *server , size_t server_len , int port ) 
{ 
  struct sockaddr_in sin ;
  struct hash_entry *h ;
  struct hostent *he ;
  Any_Type arg ;
  int tmp ;

  {
  {
#line 655
  memset((void *)(& sin), 0, sizeof(sin));
#line 656
  sin.sin_family = (sa_family_t )2;
#line 657
  sin.sin_port = htons((uint16_t )port);
#line 659
  arg.cvp = (void const   *)server;
#line 660
  event_signal((Event_Type )1, (Object *)0, arg);
#line 661
  he = gethostbyname(server);
#line 662
  event_signal((Event_Type )2, (Object *)0, arg);
  }
#line 663
  if (he) {
#line 665
    if (he->h_addrtype != 2) {
      {
#line 668
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: can\'t deal with addr family %d or size %d\n",
              prog_name, he->h_addrtype, he->h_length);
#line 670
      exit(1);
      }
    } else
#line 665
    if ((unsigned long )he->h_length != sizeof(sin.sin_addr)) {
      {
#line 668
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: can\'t deal with addr family %d or size %d\n",
              prog_name, he->h_addrtype, he->h_length);
#line 670
      exit(1);
      }
    }
    {
#line 672
    memcpy((void */* __restrict  */)(& sin.sin_addr), (void const   */* __restrict  */)*(he->h_addr_list + 0),
           sizeof(sin.sin_addr));
    }
  } else {
    {
#line 676
    tmp = inet_aton(server, & sin.sin_addr);
    }
#line 676
    if (! tmp) {
      {
#line 678
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s.core_addr_intern: invalid server address %s\n",
              prog_name, server);
#line 680
      exit(1);
      }
    }
  }
  {
#line 683
  h = hash_enter(server, server_len, port, & sin);
  }
#line 684
  if (! h) {
#line 685
    return ((struct sockaddr_in *)0);
  }
#line 686
  return (& h->sin);
}
}
#line 689 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/core.c"
void core_init(void) 
{ 
  struct rlimit rlimit ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;

  {
  {
#line 694
  memset((void *)(& hash_table), 0, sizeof(hash_table));
#line 695
  memset((void *)(& rdfds), 0, sizeof(rdfds));
#line 696
  memset((void *)(& wrfds), 0, sizeof(wrfds));
#line 697
  memset((void *)(& myaddr), 0, sizeof(myaddr));
#line 698
  memset((void *)(& port_free_map), 255, sizeof(port_free_map));
#line 701
  signal(13, (void (*)(int  ))1);
#line 713
  select_timeout.tv_sec = (__time_t )0;
#line 714
  select_timeout.tv_usec = (__suseconds_t )0;
#line 718
  tmp___1 = getrlimit((__rlimit_resource_t )7, & rlimit);
  }
#line 718
  if (tmp___1 < 0) {
    {
#line 720
    tmp = __errno_location();
#line 720
    tmp___0 = strerror(*tmp);
#line 720
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: failed to get number of open file limit: %s",
            prog_name, tmp___0);
#line 722
    exit(1);
    }
  }
#line 725
  if (rlimit.rlim_max > 1024UL) {
    {
#line 727
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: warning: open file limit > FD_SETSIZE; limiting max. # of open files to FD_SETSIZE\n",
            prog_name);
#line 729
    rlimit.rlim_max = (rlim_t )1024;
    }
  }
  {
#line 732
  rlimit.rlim_cur = rlimit.rlim_max;
#line 733
  tmp___4 = setrlimit((__rlimit_resource_t )7, (struct rlimit  const  *)(& rlimit));
  }
#line 733
  if (tmp___4 < 0) {
    {
#line 735
    tmp___2 = __errno_location();
#line 735
    tmp___3 = strerror(*tmp___2);
#line 735
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: failed to increase number of open file limit: %s",
            prog_name, tmp___3);
#line 737
    exit(1);
    }
  }
#line 740
  if (verbose) {
    {
#line 741
    printf((char const   */* __restrict  */)"%s: maximum number of open descriptors = %ld\n",
           prog_name, rlimit.rlim_max);
    }
  }
#line 744
  if (param.server) {
    {
#line 745
    tmp___5 = strlen(param.server);
#line 745
    core_addr_intern(param.server, tmp___5, param.port);
    }
  }
#line 746
  return;
}
}
#line 827 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/core.c"
static int prev_iteration  =    -1;
#line 828 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/core.c"
static u_long burst_len  ;
#line 818 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/core.c"
int core_connect(Conn *s ) 
{ 
  int sd ;
  int result ;
  int async_errno ;
  socklen_t len ;
  struct sockaddr_in *sin ;
  struct linger linger ;
  int myport ;
  int optval ;
  Any_Type arg ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  size_t size ;
  size_t old_size ;
  void *tmp___18 ;
  void *tmp___19 ;
  int *tmp___22 ;
  int *tmp___23 ;
  int *tmp___26 ;
  int *tmp___27 ;
  int *tmp___28 ;
  int *tmp___29 ;
  int *tmp___30 ;
  int tmp___31 ;
  int *tmp___34 ;
  int *tmp___35 ;

  {
#line 830
  if (iteration == prev_iteration) {
#line 831
    burst_len ++;
  } else {
#line 834
    if (burst_len > max_burst_len) {
#line 835
      max_burst_len = burst_len;
    }
#line 836
    burst_len = (u_long )1;
#line 837
    prev_iteration = iteration;
  }
  {
#line 840
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 840
    tmp = __errno_location();
#line 840
    *tmp = 0;
#line 840
    sd = socket(2, 1, 0);
#line 840
    tmp___0 = __errno_location();
    }
#line 840
    if (! (*tmp___0 == 4)) {
#line 840
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 842
  if (sd < 0) {
#line 847
    goto failure;
  }
  {
#line 850
  tmp___5 = fcntl(sd, 4, 2048);
  }
#line 850
  if (tmp___5 < 0) {
    {
#line 852
    tmp___3 = __errno_location();
#line 852
    tmp___4 = strerror(*tmp___3);
#line 852
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s.core_connect.fcntl: %s\n",
            prog_name, tmp___4);
    }
#line 854
    goto failure;
  }
#line 857
  if (param.close_with_reset) {
    {
#line 859
    linger.l_onoff = 1;
#line 860
    linger.l_linger = 0;
#line 861
    tmp___8 = setsockopt(sd, 1, 13, (void const   *)(& linger), (socklen_t )sizeof(linger));
    }
#line 861
    if (tmp___8 < 0) {
      {
#line 863
      tmp___6 = __errno_location();
#line 863
      tmp___7 = strerror(*tmp___6);
#line 863
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s.core_connect.setsockopt(SO_LINGER): %s\n",
              prog_name, tmp___7);
      }
#line 865
      goto failure;
    }
  }
  {
#line 871
  optval = 1;
#line 872
  tmp___11 = setsockopt(sd, 6, 1, (void const   *)(& optval), (socklen_t )sizeof(optval));
  }
#line 872
  if (tmp___11 < 0) {
    {
#line 874
    tmp___9 = __errno_location();
#line 874
    tmp___10 = strerror(*tmp___9);
#line 874
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s.core_connect.setsockopt(SO_SNDBUF): %s\n",
            prog_name, tmp___10);
    }
#line 876
    goto failure;
  }
  {
#line 879
  optval = param.send_buffer_size;
#line 880
  tmp___14 = setsockopt(sd, 1, 7, (void const   *)(& optval), (socklen_t )sizeof(optval));
  }
#line 880
  if (tmp___14 < 0) {
    {
#line 882
    tmp___12 = __errno_location();
#line 882
    tmp___13 = strerror(*tmp___12);
#line 882
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s.core_connect.setsockopt(SO_SNDBUF): %s\n",
            prog_name, tmp___13);
    }
#line 884
    goto failure;
  }
  {
#line 887
  optval = param.recv_buffer_size;
#line 888
  tmp___17 = setsockopt(sd, 1, 8, (void const   *)(& optval), (socklen_t )sizeof(optval));
  }
#line 888
  if (tmp___17 < 0) {
    {
#line 890
    tmp___15 = __errno_location();
#line 890
    tmp___16 = strerror(*tmp___15);
#line 890
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s.core_connect.setsockopt(SO_SNDBUF): %s\n",
            prog_name, tmp___16);
    }
#line 892
    goto failure;
  }
#line 895
  s->sd = sd;
#line 896
  if (sd >= alloced_sd_to_conn) {
#line 900
    old_size = (unsigned long )alloced_sd_to_conn * sizeof(*(sd_to_conn + 0));
#line 901
    alloced_sd_to_conn += 2048;
#line 902
    size = (unsigned long )alloced_sd_to_conn * sizeof(*(sd_to_conn + 0));
#line 903
    if (sd_to_conn) {
      {
#line 904
      tmp___18 = realloc((void *)sd_to_conn, size);
#line 904
      sd_to_conn = (Conn **)tmp___18;
      }
    } else {
      {
#line 906
      tmp___19 = malloc(size);
#line 906
      sd_to_conn = (Conn **)tmp___19;
      }
    }
#line 907
    if (! sd_to_conn) {
#line 912
      goto failure;
    }
    {
#line 914
    memset((void *)((char *)sd_to_conn + old_size), 0, size - old_size);
    }
  }
#line 916
  if (! (! *(sd_to_conn + sd))) {
    {
#line 916
    __assert_fail("!sd_to_conn[sd]", "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/core.c",
                  916U, "core_connect");
    }
  }
  {
#line 917
  *(sd_to_conn + sd) = s;
#line 919
  sin = hash_lookup(s->hostname, s->hostname_len, s->port);
  }
#line 920
  if (! sin) {
#line 925
    goto failure;
  }
  {
#line 928
  arg.l = 0L;
#line 929
  event_signal((Event_Type )7, (Object *)s, arg);
  }
#line 930
  if ((unsigned int )s->state >= 10U) {
#line 931
    goto failure;
  }
#line 933
  if (param.hog) {
    {
#line 935
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 937
      myport = port_get();
      }
#line 938
      if (myport < 0) {
#line 939
        goto failure;
      }
      {
#line 941
      myaddr.sin_port = htons((uint16_t )myport);
      }
      {
#line 942
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 942
        tmp___22 = __errno_location();
#line 942
        *tmp___22 = 0;
#line 942
        result = bind(sd, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)(& myaddr)),
                      (socklen_t )sizeof(myaddr));
#line 942
        tmp___23 = __errno_location();
        }
#line 942
        if (! (*tmp___23 == 4)) {
#line 942
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 945
      if (result == 0) {
#line 946
        goto while_break___0;
      }
      {
#line 948
      tmp___26 = __errno_location();
      }
#line 948
      if (*tmp___26 != 98) {
        {
#line 948
        tmp___27 = __errno_location();
        }
#line 948
        if (*tmp___27 == 99) {
#line 953
          goto failure;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 956
    s->myport = myport;
  }
  {
#line 959
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 959
    tmp___28 = __errno_location();
#line 959
    *tmp___28 = 0;
#line 959
    result = connect(sd, (struct sockaddr  const  */* __restrict  */)((struct sockaddr *)sin),
                     (socklen_t )sizeof(*sin));
#line 959
    tmp___29 = __errno_location();
    }
#line 959
    if (! (*tmp___29 == 4)) {
#line 959
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 961
  if (result == 0) {
    {
#line 969
    s->state = (Conn_State )2;
#line 970
    arg.l = 0L;
#line 971
    event_signal((Event_Type )8, (Object *)s, arg);
    }
  } else {
    {
#line 974
    tmp___34 = __errno_location();
    }
#line 974
    if (*tmp___34 == 115) {
      {
#line 979
      s->state = (Conn_State )1;
#line 980
      set_active(s, & wrfds);
      }
#line 981
      if (param.timeout > 0.0) {
#line 983
        arg.vp = (void *)s;
#line 984
        if (! (! s->watchdog)) {
          {
#line 984
          __assert_fail("!s->watchdog", "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/core.c",
                        984U, "core_connect");
          }
        }
        {
#line 985
        s->watchdog = timer_schedule(& conn_timeout, arg, param.timeout);
        }
      }
    } else {
      {
#line 990
      len = (socklen_t )sizeof(async_errno);
#line 991
      tmp___31 = getsockopt(sd, 1, 4, (void */* __restrict  */)(& async_errno), (socklen_t */* __restrict  */)(& len));
      }
#line 991
      if (tmp___31 == 0) {
#line 991
        if (async_errno != 0) {
          {
#line 993
          tmp___30 = __errno_location();
#line 993
          *tmp___30 = async_errno;
          }
        }
      }
#line 998
      goto failure;
    }
  }
#line 1000
  return (0);
  failure: 
  {
#line 1003
  tmp___35 = __errno_location();
#line 1003
  conn_failure(s, *tmp___35);
  }
#line 1004
  return (-1);
}
}
#line 1007 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/core.c"
int core_send(Conn *conn___0 , Call *call ) 
{ 
  Any_Type arg ;
  struct Call *tmp ;
  Time tmp___0 ;

  {
  {
#line 1012
  arg.l = 0L;
#line 1013
  event_signal((Event_Type )14, (Object *)call, arg);
#line 1015
  call->conn = conn___0;
  }
#line 1017
  if (param.no_host_hdr) {
#line 1019
    call->req.iov[5].iov_base = (void *)((caddr_t )"");
#line 1020
    call->req.iov[5].iov_len = (size_t )0;
  } else
#line 1022
  if (! call->req.iov[5].iov_base) {
#line 1025
    call->req.iov[5].iov_base = (void *)((caddr_t )conn___0->fqdname);
#line 1026
    call->req.iov[5].iov_len = conn___0->fqdname_len;
  }
  {
#line 1036
  if (call->req.version == 65536) {
#line 1036
    goto case_65536;
  }
#line 1049
  if (call->req.version == 65537) {
#line 1049
    goto case_65537;
  }
#line 1062
  goto switch_default;
  case_65536: /* CIL Label */ 
#line 1037
  if (param.no_host_hdr) {
#line 1039
    call->req.iov[4].iov_base = (void *)(http10req_nohost);
#line 1040
    call->req.iov[4].iov_len = sizeof(http10req_nohost) - 1UL;
  } else {
#line 1044
    call->req.iov[4].iov_base = (void *)(http10req);
#line 1045
    call->req.iov[4].iov_len = sizeof(http10req) - 1UL;
  }
#line 1047
  goto switch_break;
  case_65537: /* CIL Label */ 
#line 1050
  if (param.no_host_hdr) {
#line 1052
    call->req.iov[4].iov_base = (void *)(http11req_nohost);
#line 1053
    call->req.iov[4].iov_len = sizeof(http11req_nohost) - 1UL;
  } else {
#line 1057
    call->req.iov[4].iov_base = (void *)(http11req);
#line 1058
    call->req.iov[4].iov_len = sizeof(http11req) - 1UL;
  }
#line 1060
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1063
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: unexpected version code %x\n",
          prog_name, call->req.version);
#line 1065
  exit(1);
  }
  switch_break: /* CIL Label */ ;
  }
#line 1067
  call->req.iov_index = 0;
#line 1068
  call->req.iov_saved = call->req.iov[0];
#line 1071
  (((Object *)call)->ref_count) ++;
#line 1072
  call->sendq_next = (struct Call *)0;
#line 1073
  if (! conn___0->sendq) {
    {
#line 1075
    tmp = call;
#line 1075
    conn___0->sendq_tail = tmp;
#line 1075
    conn___0->sendq = tmp;
#line 1076
    arg.l = 0L;
#line 1077
    event_signal((Event_Type )15, (Object *)call, arg);
    }
#line 1078
    if ((unsigned int )conn___0->state >= 10U) {
#line 1079
      return (-1);
    }
#line 1080
    if (param.timeout) {
      {
#line 1080
      tmp___0 = timer_now();
#line 1080
      call->timeout = tmp___0 + param.timeout;
      }
    } else {
#line 1080
      call->timeout = 0.0;
    }
    {
#line 1081
    set_active(conn___0, & wrfds);
    }
  } else {
#line 1085
    (conn___0->sendq_tail)->sendq_next = call;
#line 1086
    conn___0->sendq_tail = call;
  }
#line 1088
  return (0);
}
}
#line 1091 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/core.c"
void core_close(Conn *conn___0 ) 
{ 
  Call *call ;
  Call *call_next ;
  Any_Type arg ;
  int sd ;

  {
#line 1098
  if ((unsigned int )conn___0->state >= 10U) {
#line 1099
    return;
  }
#line 1100
  conn___0->state = (Conn_State )10;
#line 1105
  if (conn___0->watchdog) {
    {
#line 1107
    timer_cancel(conn___0->watchdog);
#line 1108
    conn___0->watchdog = (Timer *)0;
    }
  }
#line 1112
  call = conn___0->sendq;
  {
#line 1112
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1112
    if (! call) {
#line 1112
      goto while_break;
    }
    {
#line 1114
    call_next = call->sendq_next;
#line 1115
    object_dec_ref((Object *)call);
#line 1112
    call = call_next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1117
  conn___0->sendq = (struct Call *)0;
#line 1119
  call = conn___0->recvq;
  {
#line 1119
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1119
    if (! call) {
#line 1119
      goto while_break___0;
    }
    {
#line 1121
    call_next = call->recvq_next;
#line 1122
    object_dec_ref((Object *)call);
#line 1119
    call = call_next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1124
  conn___0->recvq = (struct Call *)0;
#line 1126
  sd = conn___0->sd;
#line 1127
  conn___0->sd = -1;
#line 1129
  arg.l = 0L;
#line 1130
  event_signal((Event_Type )9, (Object *)conn___0, arg);
  }
#line 1131
  if (! ((unsigned int )conn___0->state == 10U)) {
    {
#line 1131
    __assert_fail("conn->state == S_CLOSING", "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/core.c",
                  1131U, "core_close");
    }
  }
#line 1138
  if (sd >= 0) {
    {
#line 1140
    close(sd);
#line 1141
    *(sd_to_conn + sd) = (Conn *)0;
#line 1142
    wrfds.__fds_bits[sd / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << sd % (8 * (int )sizeof(__fd_mask )));
#line 1143
    rdfds.__fds_bits[sd / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << sd % (8 * (int )sizeof(__fd_mask )));
    }
  }
#line 1145
  if (conn___0->myport > 0) {
    {
#line 1146
    port_put(conn___0->myport);
    }
  }
  {
#line 1151
  object_dec_ref((Object *)conn___0);
  }
#line 1152
  return;
}
}
#line 1154 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/core.c"
void core_loop(void) 
{ 
  int is_readable ;
  int is_writable ;
  int n ;
  int sd ;
  int bit ;
  int min_i ;
  int max_i ;
  int i ;
  fd_set readable ;
  fd_set writable ;
  fd_mask mask___0 ;
  Any_Type arg ;
  Conn *conn___0 ;
  struct timeval tv ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 1157
  i = 0;
  {
#line 1163
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1163
    if (! running) {
#line 1163
      goto while_break;
    }
    {
#line 1165
    tv = select_timeout;
#line 1167
    timer_tick();
#line 1169
    readable = rdfds;
#line 1170
    writable = wrfds;
#line 1171
    min_i = min_sd / (8 * (int )sizeof(__fd_mask ));
#line 1172
    max_i = max_sd / (8 * (int )sizeof(__fd_mask ));
    }
    {
#line 1174
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1174
      tmp = __errno_location();
#line 1174
      *tmp = 0;
#line 1174
      n = select(max_sd + 1, (fd_set */* __restrict  */)(& readable), (fd_set */* __restrict  */)(& writable),
                 (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)(& tv));
#line 1174
      tmp___0 = __errno_location();
      }
#line 1174
      if (! (*tmp___0 == 4)) {
#line 1174
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1177
    iteration ++;
#line 1179
    if (n <= 0) {
#line 1181
      if (n < 0) {
        {
#line 1183
        tmp___1 = __errno_location();
#line 1183
        tmp___2 = strerror(*tmp___1);
#line 1183
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s.core_loop: select failed: %s\n",
                prog_name, tmp___2);
#line 1185
        exit(1);
        }
      }
#line 1187
      goto while_continue;
    }
    {
#line 1190
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1190
      if (! (n > 0)) {
#line 1190
        goto while_break___1;
      }
      {
#line 1193
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1195
        i ++;
#line 1196
        if (i > max_i) {
#line 1197
          i = min_i;
        }
#line 1199
        if (! (i <= max_i)) {
          {
#line 1199
          __assert_fail("i <= max_i", "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/core.c",
                        1199U, "core_loop");
          }
        }
#line 1200
        mask___0 = readable.__fds_bits[i] | writable.__fds_bits[i];
#line 1193
        if (! (! mask___0)) {
#line 1193
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1203
      bit = 0;
#line 1204
      sd = i * (8 * (int )sizeof(__fd_mask )) + bit;
      {
#line 1205
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1207
        if (mask___0 & 1L) {
#line 1209
          n --;
#line 1211
          if ((readable.__fds_bits[sd / (8 * (int )sizeof(__fd_mask ))] & (1L << sd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 1211
            if ((rdfds.__fds_bits[sd / (8 * (int )sizeof(__fd_mask ))] & (1L << sd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 1211
              tmp___3 = 1;
            } else {
#line 1211
              tmp___3 = 0;
            }
          } else {
#line 1211
            tmp___3 = 0;
          }
#line 1211
          is_readable = tmp___3;
#line 1213
          if ((writable.__fds_bits[sd / (8 * (int )sizeof(__fd_mask ))] & (1L << sd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 1213
            if ((wrfds.__fds_bits[sd / (8 * (int )sizeof(__fd_mask ))] & (1L << sd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 1213
              tmp___4 = 1;
            } else {
#line 1213
              tmp___4 = 0;
            }
          } else {
#line 1213
            tmp___4 = 0;
          }
#line 1213
          is_writable = tmp___4;
#line 1216
          if (is_readable) {
#line 1216
            goto _L;
          } else
#line 1216
          if (is_writable) {
            _L: /* CIL Label */ 
#line 1219
            conn___0 = *(sd_to_conn + sd);
#line 1221
            (((Object *)conn___0)->ref_count) ++;
#line 1223
            if (conn___0->watchdog) {
              {
#line 1225
              timer_cancel(conn___0->watchdog);
#line 1226
              conn___0->watchdog = (Timer *)0;
              }
            }
#line 1228
            if ((unsigned int )conn___0->state == 1U) {
#line 1235
              if (is_writable) {
                {
#line 1237
                wrfds.__fds_bits[sd / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << sd % (8 * (int )sizeof(__fd_mask )));
#line 1238
                conn___0->state = (Conn_State )2;
#line 1239
                arg.l = 0L;
#line 1240
                event_signal((Event_Type )8, (Object *)conn___0, arg);
                }
              }
            } else {
#line 1246
              if (is_writable) {
#line 1246
                if (conn___0->sendq) {
                  {
#line 1247
                  do_send(conn___0);
                  }
                }
              }
#line 1248
              if (is_readable) {
#line 1248
                if (conn___0->recvq) {
                  {
#line 1249
                  do_recv(conn___0);
                  }
                }
              }
            }
            {
#line 1252
            object_dec_ref((Object *)conn___0);
            }
#line 1254
            if (n > 0) {
              {
#line 1255
              timer_tick();
              }
            }
          }
        }
#line 1258
        mask___0 = (fd_mask )((u_long )mask___0 >> 1);
#line 1259
        sd ++;
#line 1205
        if (! mask___0) {
#line 1205
          goto while_break___3;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1264
  return;
}
}
#line 1266 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/core.c"
void core_exit(void) 
{ 


  {
  {
#line 1269
  running = 0;
#line 1271
  printf((char const   */* __restrict  */)"Maximum connect burst length: %lu\n", max_burst_len);
  }
#line 1291
  return;
}
}
#line 63 "./timer.h"
Time timer_now_forced(void) ;
#line 66
void timer_init(void) ;
#line 49 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/timer.c"
static Time now  ;
#line 51 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/timer.c"
static Time next_tick  ;
#line 52 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/timer.c"
static Timer *timer_free_list  =    (Timer *)0;
#line 53 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/timer.c"
static Timer *t_curr  =    (Timer *)0;
#line 56 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/timer.c"
static Timer_Queue wheel[4096]  ;
#line 56 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/timer.c"
static Timer_Queue *curr  =    (Timer_Queue *)0;
#line 58 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/timer.c"
static void done(Timer *t ) 
{ 


  {
#line 61
  t->q.next = timer_free_list;
#line 62
  t->q.prev = (struct Timer *)0;
#line 63
  timer_free_list = t;
#line 64
  return;
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/timer.c"
Time timer_now_forced(void) 
{ 
  struct timeval tv ;

  {
  {
#line 71
  gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )0);
  }
#line 72
  return ((double )tv.tv_sec + (double )tv.tv_usec * 1e-6);
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/timer.c"
Time timer_now(void) 
{ 


  {
#line 78
  return (now);
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/timer.c"
void timer_init(void) 
{ 
  Time tmp ;

  {
  {
#line 84
  now = timer_now_forced();
#line 85
  memset((void *)(wheel), 0, sizeof(wheel));
#line 86
  tmp = timer_now();
#line 86
  next_tick = tmp + 1.0 / (double )1000;
#line 87
  curr = wheel;
  }
#line 88
  return;
}
}
#line 90 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/timer.c"
void timer_tick(void) 
{ 
  Timer *t ;
  Timer *t_next ;
  Time tmp ;

  {
#line 95
  if (! (! t_curr)) {
    {
#line 95
    __assert_fail("!t_curr", "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/timer.c",
                  95U, "timer_tick");
    }
  }
  {
#line 97
  now = timer_now_forced();
  }
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 99
    tmp = timer_now();
    }
#line 99
    if (! (tmp >= next_tick)) {
#line 99
      goto while_break;
    }
#line 101
    t = curr->next;
    {
#line 101
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 101
      if (t) {
#line 101
        if (! (t->delta == 0UL)) {
#line 101
          goto while_break___0;
        }
      } else {
#line 101
        goto while_break___0;
      }
      {
#line 103
      t_curr = t;
#line 104
      (*(t->func))(t, t->arg);
#line 105
      t_next = t->q.next;
#line 106
      done(t);
#line 101
      t = t_next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 108
    t_curr = (Timer *)0;
#line 109
    curr->next = t;
#line 110
    if (t) {
#line 112
      t->q.prev = (Timer *)curr;
#line 113
      (t->delta) --;
    }
#line 115
    next_tick += 1.0 / (double )1000;
#line 116
    curr ++;
#line 116
    if ((unsigned long )curr >= (unsigned long )(wheel + 4096)) {
#line 117
      curr = wheel;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 119
  return;
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/timer.c"
Timer *timer_schedule(void (*timeout)(struct Timer *t , Any_Type arg ) , Any_Type arg ,
                      Time delay ) 
{ 
  Timer_Queue *spoke ;
  Timer *t ;
  Timer *p ;
  u_long ticks ;
  u_long delta ;
  Time behind ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  Time tmp___2 ;

  {
#line 130
  if (timer_free_list) {
#line 132
    t = timer_free_list;
#line 133
    timer_free_list = t->q.next;
  } else {
    {
#line 137
    tmp = malloc(sizeof(*t));
#line 137
    t = (Timer *)tmp;
    }
#line 138
    if (! t) {
      {
#line 140
      tmp___0 = __errno_location();
#line 140
      tmp___1 = strerror(*tmp___0);
#line 140
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s.timer_schedule: %s\n",
              prog_name, tmp___1);
      }
#line 142
      return ((Timer *)0);
    }
  }
  {
#line 145
  memset((void *)t, 0, sizeof(*t));
#line 146
  t->func = timeout;
#line 147
  t->arg = arg;
#line 149
  tmp___2 = timer_now();
#line 149
  behind = tmp___2 - next_tick;
  }
#line 150
  if (behind > 0.0) {
#line 151
    delay += behind;
  }
#line 153
  if (delay < 0.0) {
#line 154
    ticks = (u_long )1;
  } else {
#line 157
    ticks = (u_long )((delay + (1.0 / (double )1000) / 2.0) * (1.0 / (1.0 / (double )1000)));
#line 158
    if (! ticks) {
#line 159
      ticks = (u_long )1;
    }
  }
#line 162
  spoke = curr + ticks % 4096UL;
#line 163
  if ((unsigned long )spoke >= (unsigned long )(wheel + 4096)) {
#line 164
    spoke -= 4096;
  }
#line 166
  delta = ticks / 4096UL;
#line 167
  p = (Timer *)spoke;
  {
#line 168
  while (1) {
    while_continue: /* CIL Label */ ;
#line 168
    if (p->q.next) {
#line 168
      if (! (delta > (p->q.next)->delta)) {
#line 168
        goto while_break;
      }
    } else {
#line 168
      goto while_break;
    }
#line 170
    delta -= (p->q.next)->delta;
#line 171
    p = p->q.next;
  }
  while_break: /* CIL Label */ ;
  }
#line 173
  t->q.next = p->q.next;
#line 174
  t->q.prev = p;
#line 175
  p->q.next = t;
#line 176
  t->delta = delta;
#line 177
  if (t->q.next) {
#line 179
    (t->q.next)->q.prev = t;
#line 180
    (t->q.next)->delta -= delta;
  }
#line 187
  return (t);
}
}
#line 190 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/timer.c"
void timer_cancel(Timer *t ) 
{ 


  {
#line 196
  if (! t->q.prev) {
    {
#line 196
    __assert_fail("t->q.prev", "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/timer.c",
                  196U, "timer_cancel");
    }
  }
#line 200
  if ((unsigned long )t_curr == (unsigned long )t) {
    {
#line 202
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"timer_cancel() called on currently active timer!\n");
    }
#line 203
    return;
  }
#line 206
  if (t->q.next) {
#line 208
    (t->q.next)->delta += t->delta;
#line 209
    (t->q.next)->q.prev = t->q.prev;
  }
  {
#line 211
  (t->q.prev)->q.next = t->q.next;
#line 212
  done(t);
  }
#line 213
  return;
}
}
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 236 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 538
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 202 "./../httperf.h"
void no_op(void) ;
#line 127 "./../call.h"
int call_append_request_header(Call *c , char const   *hdr , size_t len ) ;
#line 89 "./../event.h"
void event_register_handler(Event_Type et , void (*handler)(Event_Type type , Object *obj ,
                                                            Any_Type registration_time_arg ,
                                                            Any_Type signal_time_arg ) ,
                            Any_Type arg ) ;
#line 58 "./session.h"
Sess *session_get_sess_from_call(Call *call ) ;
#line 92 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/sess_cookie.c"
static size_t sess_private_data_offset  =    (size_t )-1;
#line 93 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/sess_cookie.c"
static size_t call_private_data_offset  =    (size_t )-1;
#line 98 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/sess_cookie.c"
static void call_issue(Event_Type et , Object *obj , Any_Type regarg , Any_Type callarg ) 
{ 
  Call_Private_Data *cpriv ;
  Sess_Private_Data *priv ;
  Sess *sess ;
  Call *call ;

  {
#line 106
  if (! ((unsigned int )et == 14U)) {
    {
#line 106
    __assert_fail("et == EV_CALL_ISSUE && 1", "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/sess_cookie.c",
                  106U, "call_issue");
    }
  }
#line 107
  call = (Call *)obj;
#line 108
  cpriv = (Call_Private_Data *)((char *)call + call_private_data_offset);
#line 110
  if (cpriv->cookie_present) {
#line 112
    return;
  }
  {
#line 114
  sess = session_get_sess_from_call(call);
#line 115
  priv = (Sess_Private_Data *)((char *)sess + sess_private_data_offset);
  }
#line 117
  if (priv->cookie_len > 0UL) {
    {
#line 122
    cpriv->cookie_present = (u_int )1;
#line 123
    memcpy((void */* __restrict  */)(cpriv->cookie), (void const   */* __restrict  */)(priv->cookie),
           priv->cookie_len + 1UL);
#line 124
    call_append_request_header(call, (char const   *)(cpriv->cookie), priv->cookie_len);
    }
  }
#line 126
  return;
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/sess_cookie.c"
static void call_recv_hdr(Event_Type et , Object *obj , Any_Type regarg , Any_Type callarg ) 
{ 
  char *hdr ;
  char *start___0 ;
  char *end ;
  Sess_Private_Data *priv ;
  size_t len ;
  struct iovec *line ;
  Sess *sess ;
  Call *call ;
  int tmp ;
  int tmp___0 ;

  {
#line 138
  if (! ((unsigned int )et == 19U)) {
    {
#line 138
    __assert_fail("et == EV_CALL_RECV_HDR && 1", "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/sess_cookie.c",
                  138U, "call_recv_hdr");
    }
  }
  {
#line 139
  call = (Call *)obj;
#line 140
  sess = session_get_sess_from_call(call);
#line 141
  priv = (Sess_Private_Data *)((char *)sess + sess_private_data_offset);
#line 143
  line = (struct iovec *)callarg.vp;
#line 144
  hdr = (char *)line->iov_base;
#line 145
  tmp = tolower((int )*(hdr + 0));
  }
#line 145
  if (tmp == 115) {
#line 145
    if (line->iov_len > 12UL) {
      {
#line 145
      tmp___0 = strncasecmp((char const   *)(hdr + 1), "et-cookie: ", (size_t )11);
      }
#line 145
      if (tmp___0 == 0) {
        {
#line 149
        start___0 = hdr + 12;
#line 150
        end = strchr((char const   *)start___0, ';');
        }
#line 151
        if (! end) {
#line 152
          end = hdr + line->iov_len;
        }
#line 153
        len = (size_t )(end - start___0);
#line 157
        if (len + 10UL >= 256UL) {
          {
#line 159
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s.sess_cookie: truncating cookie to %d bytes\n",
                  prog_name, 245);
#line 161
          len = (size_t )245;
          }
        }
        {
#line 163
        memcpy((void */* __restrict  */)(priv->cookie), (void const   */* __restrict  */)"Cookie: ",
               (size_t )8);
#line 164
        memcpy((void */* __restrict  */)(priv->cookie + 8), (void const   */* __restrict  */)start___0,
               len);
#line 165
        memcpy((void */* __restrict  */)((priv->cookie + 8) + len), (void const   */* __restrict  */)"\r\n",
               (size_t )2);
#line 166
        priv->cookie[10UL + len] = (char )'\000';
#line 167
        priv->cookie_len = len + 10UL;
        }
      }
    }
  }
#line 172
  return;
}
}
#line 174 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/sess_cookie.c"
static void init(void) 
{ 
  Any_Type arg ;

  {
  {
#line 179
  sess_private_data_offset = object_expand((Object_Type )2, sizeof(Sess_Private_Data ));
#line 181
  call_private_data_offset = object_expand((Object_Type )1, sizeof(Call_Private_Data ));
#line 183
  arg.l = 0L;
#line 184
  event_register_handler((Event_Type )14, & call_issue, arg);
#line 185
  event_register_handler((Event_Type )19, & call_recv_hdr, arg);
  }
#line 186
  return;
}
}
#line 188 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/sess_cookie.c"
Load_Generator sess_cookie  =    {"per-session cookie manager", & init, & no_op, & no_op};
#line 46 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/uri_fixed.c"
static size_t uri_len  ;
#line 48 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/uri_fixed.c"
static void set_uri(Event_Type et , Call *call ) 
{ 


  {
#line 51
  if (! ((unsigned int )et == 13U)) {
    {
#line 51
    __assert_fail("et == EV_CALL_NEW && 1", "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/uri_fixed.c",
                  51U, "set_uri");
    }
  }
  {
#line 52
  while (1) {
    while_continue: /* CIL Label */ ;
#line 52
    call->req.iov[3].iov_base = (void *)((caddr_t )param.uri);
#line 52
    call->req.iov[3].iov_len = uri_len;
#line 52
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 53
  return;
}
}
#line 55 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/uri_fixed.c"
static void init___0(void) 
{ 
  Any_Type arg ;

  {
  {
#line 60
  uri_len = strlen(param.uri);
#line 62
  arg.l = 0L;
#line 63
  event_register_handler((Event_Type )13, (void (*)(Event_Type type , Object *obj ,
                                                    Any_Type registration_time_arg ,
                                                    Any_Type signal_time_arg ))(& set_uri),
                         arg);
  }
#line 64
  return;
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/uri_fixed.c"
Load_Generator uri_fixed  =    {"fixed url", & init___0, & no_op, & no_op};
#line 109 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) log)(double __x ) ;
#line 390 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) erand48)(unsigned short *__xsubi ) ;
#line 55 "./rate.h"
void rate_generator_start(Rate_Generator *rg___0 , Event_Type completion_event ) ;
#line 57
void rate_generator_stop(Rate_Generator *rg___0 ) ;
#line 53 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/rate.c"
static Time next_arrival_time_det(Rate_Generator *rg___0 ) 
{ 


  {
#line 56
  return ((rg___0->rate)->mean_iat);
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/rate.c"
static Time next_arrival_time_uniform(Rate_Generator *rg___0 ) 
{ 
  Time lower ;
  Time upper ;
  double tmp ;

  {
  {
#line 64
  lower = (rg___0->rate)->min_iat;
#line 65
  upper = (rg___0->rate)->max_iat;
#line 67
  tmp = erand48((unsigned short *)(rg___0->xsubi));
  }
#line 67
  return (lower + (upper - lower) * tmp);
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/rate.c"
static Time next_arrival_time_exp(Rate_Generator *rg___0 ) 
{ 
  Time mean ;
  double tmp ;
  double tmp___0 ;

  {
  {
#line 73
  mean = (rg___0->rate)->mean_iat;
#line 75
  tmp = erand48((unsigned short *)(rg___0->xsubi));
#line 75
  tmp___0 = log(1.0 - tmp);
  }
#line 75
  return (- mean * tmp___0);
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/rate.c"
static void tick(Timer *t , Any_Type arg ) 
{ 
  Time delay ;
  Time now___0 ;
  Time tmp ;
  Rate_Generator *rg___0 ;
  int tmp___0 ;

  {
  {
#line 81
  tmp = timer_now();
#line 81
  now___0 = tmp;
#line 82
  rg___0 = (Rate_Generator *)arg.vp;
#line 84
  rg___0->timer = (Timer *)0;
  }
#line 85
  if (rg___0->done) {
#line 86
    return;
  }
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;
#line 88
    if (! (now___0 > rg___0->next_time)) {
#line 88
      goto while_break;
    }
    {
#line 90
    delay = (*(rg___0->next_interarrival_time))(rg___0);
    }
#line 91
    if (verbose > 2) {
      {
#line 92
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"next arrival delay = %.4f\n",
              delay);
      }
    }
    {
#line 93
    rg___0->next_time += delay;
#line 94
    tmp___0 = (*(rg___0->tick))(rg___0->arg);
#line 94
    rg___0->done = tmp___0 < 0;
    }
#line 95
    if (rg___0->done) {
#line 96
      return;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 98
  rg___0->timer = timer_schedule(& tick, arg, rg___0->next_time - now___0);
  }
#line 99
  return;
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/rate.c"
static void done___0(Event_Type type , Object *obj , Any_Type reg_arg , Any_Type call_arg ) 
{ 
  Rate_Generator *rg___0 ;
  int tmp ;

  {
#line 104
  rg___0 = (Rate_Generator *)reg_arg.vp;
#line 106
  if (rg___0->done) {
#line 107
    return;
  }
  {
#line 108
  tmp = (*(rg___0->tick))(rg___0->arg);
#line 108
  rg___0->done = tmp < 0;
  }
#line 109
  return;
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/rate.c"
void rate_generator_start(Rate_Generator *rg___0 , Event_Type completion_event ) 
{ 
  Time (*func)(struct Rate_Generator *rg ) ;
  Any_Type arg ;
  Time delay ;
  Time tmp ;
  int tmp___0 ;

  {
#line 124
  rg___0->xsubi[0] = (u_short )(4660U ^ param.client.id);
#line 125
  rg___0->xsubi[1] = (u_short )(22136U ^ (param.client.id << 8));
#line 126
  rg___0->xsubi[2] = (u_short )(39612U ^ ~ param.client.id);
#line 128
  arg.vp = (void *)rg___0;
#line 129
  if ((rg___0->rate)->rate_param > 0.0) {
    {
#line 133
    if ((unsigned int )(rg___0->rate)->dist == 0U) {
#line 133
      goto case_0;
    }
#line 134
    if ((unsigned int )(rg___0->rate)->dist == 1U) {
#line 134
      goto case_1;
    }
#line 135
    if ((unsigned int )(rg___0->rate)->dist == 2U) {
#line 135
      goto case_2;
    }
#line 136
    goto switch_default;
    case_0: /* CIL Label */ 
#line 133
    func = & next_arrival_time_det;
#line 133
    goto switch_break;
    case_1: /* CIL Label */ 
#line 134
    func = & next_arrival_time_uniform;
#line 134
    goto switch_break;
    case_2: /* CIL Label */ 
#line 135
    func = & next_arrival_time_exp;
#line 135
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 137
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: unrecognized interarrival distribution %d\n",
            prog_name, (unsigned int )(rg___0->rate)->dist);
#line 139
    exit(-1);
    }
    switch_break: /* CIL Label */ ;
    }
    {
#line 141
    rg___0->next_interarrival_time = func;
#line 142
    delay = (*func)(rg___0);
#line 145
    tmp = timer_now();
#line 145
    rg___0->next_time = tmp + delay;
#line 146
    rg___0->timer = timer_schedule(& tick, arg, delay);
    }
  } else {
    {
#line 150
    event_register_handler(completion_event, & done___0, arg);
    }
  }
  {
#line 152
  rg___0->start = timer_now();
#line 153
  tmp___0 = (*(rg___0->tick))(rg___0->arg);
#line 153
  rg___0->done = tmp___0 < 0;
  }
#line 154
  return;
}
}
#line 156 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/rate.c"
void rate_generator_stop(Rate_Generator *rg___0 ) 
{ 


  {
#line 159
  if (rg___0->timer) {
    {
#line 161
    timer_cancel(rg___0->timer);
#line 162
    rg___0->timer = (Timer *)0;
    }
  }
#line 164
  rg___0->done = 1;
#line 165
  return;
}
}
#line 68 "./../sess.h"
void sess_failure(Sess *sess ) ;
#line 40 "./session.h"
void session_init(void) ;
#line 43
size_t session_max_qlen(Sess *sess ) ;
#line 46
size_t session_current_qlen(Sess *sess ) ;
#line 50
int session_issue_call(Sess *sess , Call *call ) ;
#line 54
Sess *session_get_sess_from_conn(Conn *conn___0 ) ;
#line 120 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/session.c"
static size_t sess_private_data_offset___0  =    (size_t )-1;
#line 121 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/session.c"
static size_t conn_private_data_offset  =    (size_t )-1;
#line 122 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/session.c"
static size_t call_private_data_offset___0  =    (size_t )-1;
#line 123 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/session.c"
static size_t max_qlen  ;
#line 125 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/session.c"
static void create_conn(Sess *sess , struct Conn_Info *ci ) 
{ 
  Conn_Private_Data *cpriv ;
  Object *tmp ;
  int tmp___0 ;

  {
  {
#line 134
  tmp = object_new((Object_Type )0);
#line 134
  ci->conn = (Conn *)tmp;
  }
#line 135
  if (! ci->conn) {
    {
#line 137
    sess_failure(sess);
    }
#line 138
    return;
  }
  {
#line 140
  cpriv = (Conn_Private_Data *)((char *)ci->conn + conn_private_data_offset);
#line 141
  cpriv->sess = sess;
#line 142
  cpriv->ci = ci;
#line 144
  ci->is_connected = (u_int )0;
#line 145
  ci->is_successful = (u_int )0;
#line 146
  ci->num_sent = (u_int )0;
#line 158
  tmp___0 = core_connect(ci->conn);
  }
#line 158
  if (tmp___0 < 0) {
    {
#line 159
    sess_failure(sess);
    }
  }
#line 160
  return;
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/session.c"
static void send_calls(Sess *sess , struct Conn_Info *ci ) 
{ 
  u_int rd ;
  int i ;

  {
#line 168
  if (! ci->conn) {
    {
#line 170
    create_conn(sess, ci);
    }
#line 171
    return;
  }
#line 174
  if (! ci->is_connected) {
#line 176
    return;
  }
#line 178
  rd = (ci->rd + ci->num_sent) % 32U;
#line 180
  i = (int )ci->num_sent;
  {
#line 180
  while (1) {
    while_continue: /* CIL Label */ ;
#line 180
    if (! ((u_int )i < ci->num_pending)) {
#line 180
      goto while_break;
    }
    {
#line 182
    core_send(ci->conn, ci->call[rd]);
#line 183
    (ci->num_sent) ++;
#line 184
    rd = (rd + 1U) % 32U;
#line 180
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 186
  return;
}
}
#line 188 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/session.c"
static void sess_destroyed(Event_Type et , Object *obj , Any_Type regarg , Any_Type callarg ) 
{ 
  Sess_Private_Data___0 *priv ;
  struct Conn_Info *ci ;
  Sess *sess ;
  int i ;
  int j ;
  int rd ;

  {
#line 196
  if (! ((unsigned int )et == 5U)) {
    {
#line 196
    __assert_fail("et == EV_SESS_DESTROYED && 1", "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/session.c",
                  196U, "sess_destroyed");
    }
  }
#line 197
  sess = (Sess *)obj;
#line 198
  priv = (Sess_Private_Data___0 *)((char *)sess + sess_private_data_offset___0);
#line 200
  i = 0;
  {
#line 200
  while (1) {
    while_continue: /* CIL Label */ ;
#line 200
    if (! (i < param.max_conns)) {
#line 200
      goto while_break;
    }
#line 202
    ci = priv->conn_info + i;
#line 204
    if (ci->conn) {
      {
#line 205
      core_close(ci->conn);
      }
    }
#line 207
    rd = (int )ci->rd;
#line 208
    j = 0;
    {
#line 208
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 208
      if (! ((u_int )j < ci->num_pending)) {
#line 208
        goto while_break___0;
      }
      {
#line 210
      object_dec_ref((Object *)ci->call[rd]);
#line 211
      rd = (rd + 1) % 32;
#line 208
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 200
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 214
  return;
}
}
#line 216 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/session.c"
static void conn_connected(Event_Type et , Object *obj , Any_Type regarg , Any_Type callarg ) 
{ 
  Conn_Private_Data *cpriv ;
  struct Conn_Info *ci ;
  Sess *sess ;
  Conn *conn___0 ;

  {
#line 224
  if (! ((unsigned int )et == 8U)) {
    {
#line 224
    __assert_fail("et == EV_CONN_CONNECTED && 1", "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/session.c",
                  224U, "conn_connected");
    }
  }
  {
#line 226
  conn___0 = (Conn *)obj;
#line 227
  cpriv = (Conn_Private_Data *)((char *)conn___0 + conn_private_data_offset);
#line 228
  sess = cpriv->sess;
#line 229
  ci = cpriv->ci;
#line 231
  ci->is_connected = (u_int )1;
#line 243
  send_calls(sess, ci);
  }
#line 244
  return;
}
}
#line 246 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/session.c"
static void conn_failed(Event_Type et , Object *obj , Any_Type regarg , Any_Type callarg ) 
{ 
  Conn_Private_Data *cpriv ;
  struct Conn_Info *ci ;
  Conn *conn___0 ;
  Sess *sess ;

  {
#line 254
  if (! ((unsigned int )et == 11U)) {
    {
#line 254
    __assert_fail("et == EV_CONN_FAILED && 1", "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/session.c",
                  254U, "conn_failed");
    }
  }
#line 255
  conn___0 = (Conn *)obj;
#line 256
  cpriv = (Conn_Private_Data *)((char *)conn___0 + conn_private_data_offset);
#line 257
  sess = cpriv->sess;
#line 258
  ci = cpriv->ci;
#line 260
  if (ci->is_successful) {
    {
#line 263
    create_conn(sess, ci);
    }
  } else
#line 260
  if (param.retry_on_failure) {
    {
#line 263
    create_conn(sess, ci);
    }
  } else {
    {
#line 267
    sess_failure(cpriv->sess);
    }
  }
#line 268
  return;
}
}
#line 270 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/session.c"
static void conn_timeout___0(Event_Type et , Object *obj , Any_Type regarg , Any_Type callarg ) 
{ 
  Conn_Private_Data *cpriv ;
  Conn *conn___0 ;

  {
#line 278
  if (! ((unsigned int )et == 12U)) {
    {
#line 278
    __assert_fail("et == EV_CONN_TIMEOUT && 1", "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/session.c",
                  278U, "conn_timeout");
    }
  }
  {
#line 279
  conn___0 = (Conn *)obj;
#line 280
  cpriv = (Conn_Private_Data *)((char *)conn___0 + conn_private_data_offset);
#line 282
  sess_failure(cpriv->sess);
  }
#line 283
  return;
}
}
#line 285 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/session.c"
static void call_done(Event_Type et , Object *obj , Any_Type regarg , Any_Type callarg ) 
{ 
  Conn_Private_Data *cpriv ;
  struct Conn_Info *ci ;
  Sess *sess ;
  Conn *conn___0 ;
  Call *call ;

  {
#line 294
  if (! ((unsigned int )et == 23U)) {
    {
#line 294
    __assert_fail("et == EV_CALL_RECV_STOP && 1", "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/session.c",
                  294U, "call_done");
    }
  }
#line 295
  call = (Call *)obj;
#line 296
  conn___0 = call->conn;
#line 297
  cpriv = (Conn_Private_Data *)((char *)conn___0 + conn_private_data_offset);
#line 298
  sess = cpriv->sess;
#line 299
  ci = cpriv->ci;
#line 301
  ci->is_successful = (u_int )1;
#line 304
  if ((unsigned long )ci->call[ci->rd] == (unsigned long )call) {
#line 304
    if (ci->num_pending > 0U) {
#line 304
      if (! (ci->num_sent > 0U)) {
        {
#line 304
        __assert_fail("ci->call[ci->rd] == call && ci->num_pending > 0 && ci->num_sent > 0",
                      "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/session.c",
                      304U, "call_done");
        }
      }
    } else {
      {
#line 304
      __assert_fail("ci->call[ci->rd] == call && ci->num_pending > 0 && ci->num_sent > 0",
                    "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/session.c",
                    304U, "call_done");
      }
    }
  } else {
    {
#line 304
    __assert_fail("ci->call[ci->rd] == call && ci->num_pending > 0 && ci->num_sent > 0",
                  "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/session.c",
                  304U, "call_done");
    }
  }
#line 305
  ci->call[ci->rd] = (Call *)0;
#line 306
  ci->rd = (ci->rd + 1U) % 32U;
#line 307
  (ci->num_pending) --;
#line 308
  (ci->num_sent) --;
#line 312
  if (param.failure_status) {
#line 312
    if (call->reply.status == param.failure_status) {
#line 314
      if (param.retry_on_failure) {
        {
#line 315
        session_issue_call(sess, call);
        }
      } else {
        {
#line 317
        sess_failure(sess);
        }
      }
    }
  }
  {
#line 320
  object_dec_ref((Object *)call);
  }
#line 322
  if (param.http_version < 65537) {
    {
#line 327
    core_close(ci->conn);
#line 328
    ci->conn = (Conn *)0;
    }
  }
#line 330
  return;
}
}
#line 332 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/session.c"
void session_init(void) 
{ 
  Any_Type arg ;

  {
#line 337
  if (! param.max_conns) {
#line 338
    param.max_conns = 4;
  }
#line 340
  if (! param.max_piped) {
#line 342
    if (param.http_version >= 65537) {
#line 343
      param.max_piped = 32;
    } else {
#line 346
      param.max_piped = 1;
    }
  }
#line 349
  if (param.max_conns > 4) {
    {
#line 351
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s.session_init: --max-conns must be <= %u\n",
            prog_name, 4);
#line 353
    exit(1);
    }
  }
#line 355
  if (param.max_piped > 32) {
    {
#line 357
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s.session_init: --max-piped-calls must be <= %u\n",
            prog_name, 32);
#line 359
    exit(1);
    }
  }
  {
#line 362
  max_qlen = (size_t )(param.max_conns * param.max_piped);
#line 364
  sess_private_data_offset___0 = object_expand((Object_Type )2, sizeof(Sess_Private_Data___0 ));
#line 366
  conn_private_data_offset = object_expand((Object_Type )0, sizeof(Conn_Private_Data ));
#line 368
  call_private_data_offset___0 = object_expand((Object_Type )1, sizeof(Call_Private_Data___0 ));
#line 371
  arg.l = 0L;
#line 372
  event_register_handler((Event_Type )5, & sess_destroyed, arg);
#line 374
  event_register_handler((Event_Type )8, & conn_connected, arg);
#line 375
  event_register_handler((Event_Type )11, & conn_failed, arg);
#line 376
  event_register_handler((Event_Type )12, & conn_timeout___0, arg);
#line 378
  event_register_handler((Event_Type )23, & call_done, arg);
  }
#line 379
  return;
}
}
#line 381 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/session.c"
size_t session_max_qlen(Sess *sess ) 
{ 


  {
#line 384
  return (max_qlen);
}
}
#line 387 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/session.c"
size_t session_current_qlen(Sess *sess ) 
{ 
  Sess_Private_Data___0 *priv ;
  size_t num_pending ;
  int i ;

  {
#line 391
  num_pending = (size_t )0;
#line 394
  priv = (Sess_Private_Data___0 *)((char *)sess + sess_private_data_offset___0);
#line 396
  i = 0;
  {
#line 396
  while (1) {
    while_continue: /* CIL Label */ ;
#line 396
    if (! (i < param.max_conns)) {
#line 396
      goto while_break;
    }
#line 397
    num_pending += (size_t )priv->conn_info[i].num_pending;
#line 396
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 399
  return (num_pending);
}
}
#line 402 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/session.c"
int session_issue_call(Sess *sess , Call *call ) 
{ 
  Call_Private_Data___0 *cpriv ;
  Sess_Private_Data___0 *priv ;
  struct Conn_Info *ci ;
  int i ;

  {
#line 410
  priv = (Sess_Private_Data___0 *)((char *)sess + sess_private_data_offset___0);
#line 412
  cpriv = (Call_Private_Data___0 *)((char *)call + call_private_data_offset___0);
#line 413
  cpriv->sess = sess;
#line 415
  i = 0;
  {
#line 415
  while (1) {
    while_continue: /* CIL Label */ ;
#line 415
    if (! (i < param.max_conns)) {
#line 415
      goto while_break;
    }
#line 417
    ci = priv->conn_info + i;
#line 418
    if (ci->num_pending < (u_int )param.max_piped) {
      {
#line 420
      (ci->num_pending) ++;
#line 421
      ci->call[ci->wr] = call;
#line 422
      (((Object *)call)->ref_count) ++;
#line 423
      ci->wr = (ci->wr + 1U) % 32U;
#line 424
      send_calls(sess, ci);
      }
#line 425
      return (0);
    }
#line 415
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 428
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s.session_issue_call: too many calls pending!\n\tIncrease --max-connections and/or --max-piped-calls.\n",
          prog_name);
#line 431
  exit(1);
  }
}
}
#line 434 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/session.c"
Sess *session_get_sess_from_conn(Conn *conn___0 ) 
{ 


  {
#line 438
  return (((Conn_Private_Data *)((char *)conn___0 + conn_private_data_offset))->sess);
}
}
#line 441 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/session.c"
Sess *session_get_sess_from_call(Call *call ) 
{ 


  {
#line 445
  return (((Call_Private_Data___0 *)((char *)call + call_private_data_offset___0))->sess);
}
}
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 57 "/usr/include/x86_64-linux-gnu/sys/mman.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) mmap)(void *__addr ,
                                                                             size_t __len ,
                                                                             int __prot ,
                                                                             int __flags ,
                                                                             int __fd ,
                                                                             __off_t __offset ) ;
#line 76
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) munmap)(void *__addr ,
                                                                             size_t __len ) ;
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 85 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/uri_wlog.c"
static char *fbase  ;
#line 85 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/uri_wlog.c"
static char *fend  ;
#line 85 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/uri_wlog.c"
static char *fcurrent  ;
#line 87 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/uri_wlog.c"
static void set_uri___0(Event_Type et , Call *c ) 
{ 
  int len ;
  int did_wrap ;
  char const   *uri ;
  size_t tmp ;

  {
#line 90
  did_wrap = 0;
#line 93
  if (! ((unsigned int )et == 13U)) {
    {
#line 93
    __assert_fail("et == EV_CALL_NEW && 1", "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/uri_wlog.c",
                  93U, "set_uri");
    }
  }
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 97
    if ((unsigned long )fcurrent >= (unsigned long )fend) {
#line 99
      if (did_wrap) {
        {
#line 100
        panic("%s: %s does not contain any valid URIs\n", prog_name, param.wlog.file);
        }
      }
#line 102
      did_wrap = 1;
#line 108
      fcurrent = fbase;
#line 109
      if (! param.wlog.do_loop) {
        {
#line 110
        core_exit();
        }
      }
    }
    {
#line 112
    uri = (char const   *)fcurrent;
#line 113
    tmp = strlen((char const   *)fcurrent);
#line 113
    len = (int )tmp;
    }
    {
#line 114
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 114
      c->req.iov[3].iov_base = (void *)((caddr_t )uri);
#line 114
      c->req.iov[3].iov_len = (size_t )len;
#line 114
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 115
    fcurrent += len + 1;
#line 95
    if (! (len == 0)) {
#line 95
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 119
  if (verbose) {
    {
#line 120
    printf((char const   */* __restrict  */)"%s: accessing URI `%s\'\n", prog_name,
           uri);
    }
  }
#line 121
  return;
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/uri_wlog.c"
void init_wlog(void) 
{ 
  struct stat st ;
  Any_Type arg ;
  int fd ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 130
  fd = open((char const   *)param.wlog.file, 0, 0);
  }
#line 131
  if (fd == -1) {
    {
#line 132
    panic("%s: can\'t open %s\n", prog_name, param.wlog.file);
    }
  }
  {
#line 134
  fstat(fd, & st);
  }
#line 135
  if (st.st_size == 0L) {
    {
#line 136
    panic("%s: file %s is empty\n", prog_name, param.wlog.file);
    }
  }
  {
#line 139
  tmp = mmap((void *)0, (size_t )st.st_size, 1, 2, fd, (__off_t )0);
#line 139
  fbase = (char *)tmp;
  }
#line 140
  if ((unsigned long )fbase == (unsigned long )((char *)0 - 1)) {
    {
#line 141
    tmp___0 = __errno_location();
#line 141
    tmp___1 = strerror(*tmp___0);
#line 141
    panic("%s: can\'t mmap the file: %s\n", prog_name, tmp___1);
    }
  }
  {
#line 143
  close(fd);
#line 146
  fend = fbase + st.st_size;
#line 148
  fcurrent = fbase;
#line 150
  arg.l = 0L;
#line 151
  event_register_handler((Event_Type )13, (void (*)(Event_Type type , Object *obj ,
                                                    Any_Type registration_time_arg ,
                                                    Any_Type signal_time_arg ))(& set_uri___0),
                         arg);
  }
#line 152
  return;
}
}
#line 154 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/uri_wlog.c"
static void stop_wlog(void) 
{ 


  {
  {
#line 157
  munmap((void *)fbase, (size_t )(fend - fbase));
  }
#line 158
  return;
}
}
#line 160 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/uri_wlog.c"
Load_Generator uri_wlog  =    {"Generates URIs based on a predetermined list", & init_wlog, & no_op, & stop_wlog};
#line 43 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/call.c"
static u_long next_id  =    (u_long )0;
#line 45 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/call.c"
void call_init(Call *c ) 
{ 
  u_long tmp ;

  {
#line 50
  tmp = next_id;
#line 50
  next_id ++;
#line 50
  c->id = tmp;
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
#line 51
    c->req.iov[0].iov_base = (void *)((caddr_t )"GET");
#line 51
    c->req.iov[0].iov_len = sizeof("GET") - 1UL;
#line 51
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 52
  c->req.version = param.http_version;
#line 53
  c->req.iov[1].iov_base = (void *)((caddr_t )" ");
#line 54
  c->req.iov[1].iov_len = (size_t )1;
#line 55
  c->req.iov[6].iov_base = (void *)((caddr_t )"\r\n");
#line 56
  c->req.iov[6].iov_len = (size_t )2;
#line 57
  c->req.iov[11].iov_base = (void *)((caddr_t )"\r\n");
#line 58
  c->req.iov[11].iov_len = (size_t )2;
#line 59
  return;
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/call.c"
void call_deinit(Call *call ) 
{ 


  {
#line 64
  return;
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/call.c"
int call_append_request_header(Call *c , char const   *hdr , size_t len ) 
{ 
  u_int num_hdrs ;

  {
#line 69
  num_hdrs = c->req.num_extra_hdrs;
#line 71
  if (num_hdrs >= 4U) {
    {
#line 73
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s.call_append_request_header: max headers (%d) exceeded.\n",
            prog_name, 4);
    }
#line 75
    return (-1);
  }
#line 77
  c->req.iov[7U + num_hdrs].iov_base = (void *)((caddr_t )hdr);
#line 78
  c->req.iov[7U + num_hdrs].iov_len = len;
#line 79
  c->req.num_extra_hdrs = num_hdrs + 1U;
#line 80
  return (0);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 35 "./lib/getopt.h"
extern char *optarg ;
#line 110
extern int getopt_long(int argc , char * const  *argv , char const   *shortopts ,
                       struct option  const  *longopts , int *longind ) ;
#line 371 "/usr/include/stdio.h"
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 164 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) strtod)(char const   * __restrict  __nptr ,
                                                                                                char ** __restrict  __endptr ) ;
#line 187
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 87 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getrusage)(__rusage_who_t __who ,
                                                                                struct rusage *__usage ) ;
#line 182 "./httperf.h"
int verbose  ;
#line 183 "./httperf.h"
Cmdline_Params param  ;
#line 184 "./httperf.h"
Time test_time_start  ;
#line 185 "./httperf.h"
Time test_time_stop  ;
#line 186 "./httperf.h"
struct rusage test_rusage_start  ;
#line 187 "./httperf.h"
struct rusage test_rusage_stop  ;
#line 94 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/httperf.c"
size_t object_type_size[3]  ;
#line 104 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/httperf.c"
static Time perf_sample_start  ;
#line 106 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/httperf.c"
static struct option longopts[37]  = 
#line 106
  {      {"add-header", 1, (int *)(& param.additional_header), 0}, 
        {"burst-length", 1, & param.burst_len, 0}, 
        {"client", 1, (int *)(& param.client), 0}, 
        {"close-with-reset", 0, & param.close_with_reset, 1}, 
        {"debug", 1, (int *)0, 'd'}, 
        {"failure-status", 1, & param.failure_status, 0}, 
        {"help", 0, (int *)0, 'h'}, 
        {"hog", 0, & param.hog, 1}, 
        {"http-version", 1, & param.http_version, 0}, 
        {"max-connections", 1, & param.max_conns, 0}, 
        {"max-piped-calls", 1, & param.max_piped, 0}, 
        {"method", 1, (int *)(& param.method), 0}, 
        {"no-host-hdr", 0, & param.no_host_hdr, 1}, 
        {"num-calls", 1, & param.num_calls, 0}, 
        {"num-conns", 1, & param.num_conns, 0}, 
        {"period", 1, (int *)(& param.rate.mean_iat), 0}, 
        {"port", 1, & param.port, 0}, 
        {"print-reply", 2, & param.print_reply, 0}, 
        {"print-request", 2, & param.print_request, 0}, 
        {"rate", 1, (int *)(& param.rate), 0}, 
        {"recv-buffer", 1, & param.recv_buffer_size, 0}, 
        {"retry-on-failure", 0, & param.retry_on_failure, 1}, 
        {"send-buffer", 1, & param.send_buffer_size, 0}, 
        {"server", 1, (int *)(& param.server), 0}, 
        {"server-name", 1, (int *)(& param.server_name), 0}, 
        {"session-cookies", 0, & param.session_cookies, 1}, 
        {"think-timeout", 1, (int *)(& param.think_timeout), 0}, 
        {"timeout", 1, (int *)(& param.timeout), 0}, 
        {"uri", 1, (int *)(& param.uri), 0}, 
        {"verbose", 0, (int *)0, 'v'}, 
        {"version", 0, (int *)0, 'V'}, 
        {"wlog", 1, (int *)(& param.wlog), 0}, 
        {"wsess", 1, (int *)(& param.wsess), 0}, 
        {"wsesslog", 1, (int *)(& param.wsesslog), 0}, 
        {"wsesspage", 1, (int *)(& param.wsesspage), 0}, 
        {"wset", 1, (int *)(& param.wset), 0}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 152 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/httperf.c"
static void usage(void) 
{ 


  {
  {
#line 155
  printf((char const   */* __restrict  */)"Usage: %s [-hdvV] [--add-header S] [--burst-length N] [--client N/N]\n\t[--close-with-reset] [--debug N] [--failure-status N]\n\t[--help] [--hog] [--http-version S] [--max-connections N]\n\t[--max-piped-calls N] [--method S] [--no-host-hdr]\n\t[--num-calls N] [--num-conns N] [--period [d|u|e]T1[,T2]]\n\t[--port N] [--print-reply [header|body]] [--print-request [header|body]]\n\t[--rate X] [--recv-buffer N] [--retry-on-failure] [--send-buffer N]\n\t[--server S] [--server-name S] [--session-cookies]\n\t[--think-timeout X] [--timeout X] [--uri S] [--verbose] [--version]\n\t[--wlog y|n,file] [--wsess N,N,X] [--wsesslog N,X,file]\n\t[--wset N,X]\n",
         prog_name);
  }
#line 174
  return;
}
}
#line 176 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/httperf.c"
void panic(char const   *msg  , ...) 
{ 
  va_list va ;

  {
  {
#line 181
  __builtin_va_start(va, msg);
#line 182
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)msg,
           va);
#line 183
  __builtin_va_end(va);
#line 184
  exit(1);
  }
}
}
#line 187 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/httperf.c"
void no_op(void) 
{ 


  {
#line 190
  return;
}
}
#line 192 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/httperf.c"
static void perf_sample(Timer *t , Any_Type regarg ) 
{ 
  Any_Type callarg ;
  Time tmp ;

  {
  {
#line 197
  tmp = timer_now();
#line 197
  callarg.d = 1.0 / (tmp - perf_sample_start);
#line 198
  event_signal((Event_Type )0, (Object *)0, callarg);
#line 201
  perf_sample_start = timer_now();
#line 202
  timer_schedule(& perf_sample, regarg, 5.0);
  }
#line 203
  return;
}
}
#line 208
extern Load_Generator uri_wset ;
#line 208
Load_Generator conn_rate ;
#line 208
Load_Generator call_seq ;
#line 209
extern Load_Generator wsess ;
#line 209
extern Load_Generator wsesslog ;
#line 209
extern Load_Generator wsesspage ;
#line 209
Load_Generator misc ;
#line 210
extern Stat_Collector stats_basic ;
#line 210
extern Stat_Collector session_stat ;
#line 211
extern Stat_Collector stats_print_reply ;
#line 58 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/call_seq.c"
static size_t conn_private_data_offset___0  ;
#line 60 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/call_seq.c"
static void issue_calls(Conn *conn___0 ) 
{ 
  Conn_Private_Data___0 *priv ;
  Call *call ;
  int i ;
  Object *tmp ;
  int tmp___0 ;

  {
#line 67
  priv = (Conn_Private_Data___0 *)((char *)conn___0 + conn_private_data_offset___0);
#line 68
  priv->num_completed = 0;
#line 69
  priv->num_destroyed = 0;
#line 71
  i = 0;
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
#line 71
    if (! (i < param.burst_len)) {
#line 71
      goto while_break;
    }
#line 72
    tmp___0 = priv->num_calls;
#line 72
    (priv->num_calls) ++;
#line 72
    if (tmp___0 < param.num_calls) {
      {
#line 74
      tmp = object_new((Object_Type )1);
#line 74
      call = (Call *)tmp;
      }
#line 75
      if (call) {
        {
#line 77
        core_send(conn___0, call);
#line 78
        object_dec_ref((Object *)call);
        }
      }
    }
#line 71
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 81
  return;
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/call_seq.c"
static void conn_connected___0(Event_Type et , Conn *conn___0 ) 
{ 


  {
#line 86
  if (! ((unsigned int )et == 8U)) {
    {
#line 86
    __assert_fail("et == EV_CONN_CONNECTED && 1", "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/call_seq.c",
                  86U, "conn_connected");
    }
  }
  {
#line 88
  issue_calls(conn___0);
  }
#line 89
  return;
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/call_seq.c"
static void call_done___0(Event_Type et , Call *call ) 
{ 
  Conn *conn___0 ;
  Conn_Private_Data___0 *priv ;

  {
#line 94
  conn___0 = call->conn;
#line 97
  if ((unsigned int )et == 23U) {
#line 97
    if (! conn___0) {
      {
#line 97
      __assert_fail("et == EV_CALL_RECV_STOP && conn && 1", "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/call_seq.c",
                    97U, "call_done");
      }
    }
  } else {
    {
#line 97
    __assert_fail("et == EV_CALL_RECV_STOP && conn && 1", "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/call_seq.c",
                  97U, "call_done");
    }
  }
#line 99
  priv = (Conn_Private_Data___0 *)((char *)conn___0 + conn_private_data_offset___0);
#line 100
  (priv->num_completed) ++;
#line 101
  return;
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/call_seq.c"
static void call_destroyed(Event_Type et , Call *call ) 
{ 
  Conn_Private_Data___0 *priv ;
  Conn *conn___0 ;
  int tmp ;

  {
#line 109
  if (! ((unsigned int )et == 24U)) {
    {
#line 109
    __assert_fail("et == EV_CALL_DESTROYED && 1", "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/call_seq.c",
                  109U, "call_destroyed");
    }
  }
#line 111
  conn___0 = call->conn;
#line 112
  priv = (Conn_Private_Data___0 *)((char *)conn___0 + conn_private_data_offset___0);
#line 114
  (priv->num_destroyed) ++;
#line 114
  if (param.burst_len < param.num_calls) {
#line 114
    tmp = param.burst_len;
  } else {
#line 114
    tmp = param.num_calls;
  }
#line 114
  if (priv->num_destroyed >= tmp) {
#line 116
    if (priv->num_completed == priv->num_destroyed) {
#line 116
      if (priv->num_calls < param.num_calls) {
        {
#line 118
        issue_calls(conn___0);
        }
      } else {
        {
#line 120
        core_close(conn___0);
        }
      }
    } else {
      {
#line 120
      core_close(conn___0);
      }
    }
  }
#line 122
  return;
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/call_seq.c"
static void init___1(void) 
{ 
  Any_Type arg ;

  {
  {
#line 129
  conn_private_data_offset___0 = object_expand((Object_Type )0, sizeof(Conn_Private_Data___0 ));
#line 132
  arg.l = 0L;
#line 133
  event_register_handler((Event_Type )8, (void (*)(Event_Type type , Object *obj ,
                                                   Any_Type registration_time_arg ,
                                                   Any_Type signal_time_arg ))(& conn_connected___0),
                         arg);
#line 135
  event_register_handler((Event_Type )23, (void (*)(Event_Type type , Object *obj ,
                                                    Any_Type registration_time_arg ,
                                                    Any_Type signal_time_arg ))(& call_done___0),
                         arg);
#line 136
  event_register_handler((Event_Type )24, (void (*)(Event_Type type , Object *obj ,
                                                    Any_Type registration_time_arg ,
                                                    Any_Type signal_time_arg ))(& call_destroyed),
                         arg);
  }
#line 138
  return;
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/call_seq.c"
Load_Generator call_seq  =    {"performs a sequence of calls on a connection", & init___1, & no_op, & no_op};
#line 534 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 53 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/http.c"
static int get_line(Call *c , char **bufp , size_t *buf_lenp ) 
{ 
  size_t to_copy ;
  size_t buf_len ;
  Conn *s ;
  char *buf ;
  char const   *eol ;
  int has_lf ;
  char *tmp ;

  {
#line 56
  buf_len = *buf_lenp;
#line 57
  s = c->conn;
#line 58
  buf = *bufp;
#line 62
  if (buf_len <= 0UL) {
#line 63
    return (0);
  }
  {
#line 66
  tmp = strchr((char const   *)buf, '\n');
#line 66
  eol = (char const   *)tmp;
  }
#line 67
  if (eol) {
#line 68
    eol ++;
  } else {
#line 70
    eol = (char const   *)(buf + buf_len);
  }
#line 72
  to_copy = (size_t )(eol - (char const   *)buf);
#line 73
  buf_len -= to_copy;
#line 74
  if (s->line.iov_len + to_copy >= sizeof(s->line_buf)) {
    {
#line 76
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s.get_line: truncating header from %lu to %lu bytes\n",
            prog_name, s->line.iov_len + to_copy, sizeof(s->line_buf));
#line 80
    to_copy = (sizeof(s->line_buf) - 1UL) - s->line.iov_len;
    }
  }
  {
#line 82
  memcpy((void */* __restrict  */)((char *)s->line.iov_base + s->line.iov_len), (void const   */* __restrict  */)buf,
         to_copy);
#line 83
  s->line.iov_len += to_copy;
#line 85
  has_lf = (int )*((char *)s->line.iov_base + (s->line.iov_len - 1UL)) == 10;
#line 87
  *bufp = (char *)eol;
#line 88
  *buf_lenp = buf_len;
  }
#line 90
  if (has_lf) {
#line 90
    goto _L;
  } else
#line 90
  if (s->line.iov_len == sizeof(s->line_buf) - 1UL) {
    _L: /* CIL Label */ 
#line 94
    if ((int )*((char *)s->line.iov_base + (s->line.iov_len - 1UL)) == 10) {
#line 96
      (s->line.iov_len) --;
#line 97
      if ((int )*((char *)s->line.iov_base + (s->line.iov_len - 1UL)) == 13) {
#line 98
        (s->line.iov_len) --;
      }
    }
#line 100
    *((char *)s->line.iov_base + s->line.iov_len) = (char )'\000';
#line 101
    return (1);
  }
#line 103
  return (0);
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/http.c"
static void parse_status_line(Call *c , char **bufp , size_t *buf_lenp ) 
{ 
  char *buf ;
  char *buf_start ;
  u_int major ;
  u_int minor ;
  u_int status ;
  Conn *s ;
  Any_Type arg ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 109
  buf_start = *bufp;
#line 111
  s = c->conn;
#line 114
  s->is_chunked = (u_int )0;
#line 117
  s->content_length = ~ ((size_t )0);
#line 119
  tmp = get_line(c, bufp, buf_lenp);
  }
#line 119
  if (! tmp) {
#line 120
    return;
  }
  {
#line 122
  buf = (char *)(c->conn)->line.iov_base;
#line 123
  tmp___0 = sscanf((char const   */* __restrict  */)buf, (char const   */* __restrict  */)"HTTP/%u.%u %u ",
                   & major, & minor, & status);
  }
#line 123
  if (tmp___0 == 3) {
#line 125
    c->reply.version = (int )(65536U * major + minor);
#line 126
    c->reply.status = (int )status;
  } else {
#line 130
    c->reply.version = 65536;
#line 131
    c->reply.status = 599;
#line 132
    if (c->reply.status == 599) {
      {
#line 133
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s.parse_status_line: invalid status line `%s\'!!\n",
              prog_name, buf);
      }
    }
  }
  {
#line 146
  tmp___1 = strcmp((char const   *)((char *)c->req.iov[0].iov_base), "HEAD");
  }
#line 146
  if (tmp___1 == 0) {
#line 147
    s->has_body = (u_int )0;
  } else {
#line 150
    s->has_body = (u_int )1;
    {
#line 153
    if (status / 100U == 1U) {
#line 153
      goto case_1;
    }
#line 165
    if (status / 100U == 3U) {
#line 165
      goto case_3;
    }
#line 165
    if (status / 100U == 2U) {
#line 165
      goto case_3;
    }
#line 177
    if (status / 100U == 5U) {
#line 177
      goto case_5;
    }
#line 177
    if (status / 100U == 4U) {
#line 177
      goto case_5;
    }
#line 180
    goto switch_default;
    case_1: /* CIL Label */ 
#line 154
    s->has_body = (u_int )0;
#line 155
    if (status == 100U) {
      {
#line 157
      arg.l = (long )c->reply.status;
#line 158
      event_signal((Event_Type )18, (Object *)c, arg);
#line 159
      s->state = (Conn_State )5;
      }
#line 160
      goto done;
    }
#line 162
    goto switch_break;
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
    {
#line 170
    if (status == 304U) {
#line 170
      goto case_304;
    }
#line 170
    if (status == 205U) {
#line 170
      goto case_304;
    }
#line 170
    if (status == 204U) {
#line 170
      goto case_304;
    }
#line 166
    goto switch_break___0;
    case_304: /* CIL Label */ 
    case_205: /* CIL Label */ 
    case_204: /* CIL Label */ 
#line 171
    s->has_body = (u_int )0;
#line 172
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 174
    goto switch_break;
    case_5: /* CIL Label */ 
    case_4: /* CIL Label */ 
#line 178
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 181
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s.parse_status_line: bad status %u\n",
            prog_name, status);
    }
#line 183
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 186
  arg.l = (long )c->reply.status;
#line 187
  event_signal((Event_Type )18, (Object *)c, arg);
  }
#line 188
  if ((unsigned int )s->state >= 10U) {
#line 189
    return;
  }
#line 190
  s->state = (Conn_State )4;
  done: 
#line 193
  c->reply.header_bytes += (size_t )(*bufp - buf_start);
#line 194
  s->line.iov_len = (size_t )0;
#line 195
  return;
}
}
#line 197 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/http.c"
static void parse_headers(Call *c , char **bufp , size_t *buf_lenp ) 
{ 
  char *hdr ;
  char *buf_start ;
  Conn *s ;
  size_t hdr_len ;
  Any_Type arg ;
  int tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 200
  buf_start = *bufp;
#line 201
  s = c->conn;
  {
#line 205
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 205
    tmp___4 = get_line(c, bufp, buf_lenp);
    }
#line 205
    if (! (tmp___4 > 0)) {
#line 205
      goto while_break;
    }
#line 207
    hdr = (char *)s->line.iov_base;
#line 208
    hdr_len = s->line.iov_len;
#line 210
    if (! hdr_len) {
#line 213
      if (s->has_body) {
#line 214
        if (s->is_chunked) {
#line 216
          s->content_length = (size_t )0;
#line 217
          s->state = (Conn_State )7;
        } else {
#line 220
          s->state = (Conn_State )6;
        }
      } else
#line 221
      if ((unsigned int )s->state == 5U) {
#line 222
        s->state = (Conn_State )4;
      } else {
#line 224
        s->state = (Conn_State )9;
      }
#line 225
      goto while_break;
    }
    {
#line 229
    tmp = tolower((int )*hdr);
    }
    {
#line 231
    if (tmp == 99) {
#line 231
      goto case_99;
    }
#line 241
    if (tmp == 116) {
#line 241
      goto case_116;
    }
#line 229
    goto switch_break;
    case_99: /* CIL Label */ 
    {
#line 232
    tmp___0 = strncasecmp((char const   *)hdr, "content-length:", (size_t )15);
    }
#line 232
    if (tmp___0 == 0) {
      {
#line 234
      hdr += 15;
#line 235
      s->content_length = strtoul((char const   */* __restrict  */)hdr, (char **/* __restrict  */)0,
                                  10);
      }
#line 236
      if (! s->content_length) {
#line 237
        s->has_body = (u_int )0;
      }
    }
#line 239
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 242
    tmp___3 = strncasecmp((char const   *)hdr, "transfer-encoding:", (size_t )18);
    }
#line 242
    if (tmp___3 == 0) {
#line 244
      hdr += 18;
      {
#line 245
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 245
        tmp___1 = __ctype_b_loc();
        }
#line 245
        if (! ((int const   )*(*tmp___1 + (int )*hdr) & 8192)) {
#line 245
          goto while_break___0;
        }
#line 246
        hdr ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 247
      tmp___2 = strcasecmp((char const   *)hdr, "chunked");
      }
#line 247
      if (tmp___2 == 0) {
#line 248
        s->is_chunked = (u_int )1;
      } else {
        {
#line 250
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s.parse_headers: unknown transfer encoding `%s\'\n",
                prog_name, hdr);
        }
      }
    }
#line 253
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 255
    arg.vp = (void *)(& s->line);
#line 256
    event_signal((Event_Type )19, (Object *)c, arg);
    }
#line 257
    if ((unsigned int )s->state >= 10U) {
#line 258
      return;
    }
#line 259
    s->line.iov_len = (size_t )0;
  }
  while_break: /* CIL Label */ ;
  }
#line 261
  c->reply.header_bytes += (size_t )(*bufp - buf_start);
#line 262
  return;
}
}
#line 264 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/http.c"
static void parse_footers(Call *c , char **bufp , size_t *buf_lenp ) 
{ 
  char *hdr ;
  char *buf_start ;
  Conn *s ;
  size_t hdr_len ;
  Any_Type arg ;
  int tmp ;

  {
#line 267
  buf_start = *bufp;
#line 268
  s = c->conn;
  {
#line 272
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 272
    tmp = get_line(c, bufp, buf_lenp);
    }
#line 272
    if (! (tmp > 0)) {
#line 272
      goto while_break;
    }
#line 274
    hdr = (char *)s->line.iov_base;
#line 275
    hdr_len = s->line.iov_len;
#line 277
    if (! hdr_len) {
#line 280
      s->state = (Conn_State )9;
#line 281
      goto while_break;
    }
    {
#line 284
    arg.vp = (void *)(& s->line);
#line 285
    event_signal((Event_Type )22, (Object *)c, arg);
    }
#line 286
    if ((unsigned int )s->state >= 10U) {
#line 287
      return;
    }
#line 288
    s->line.iov_len = (size_t )0;
  }
  while_break: /* CIL Label */ ;
  }
#line 290
  c->reply.footer_bytes += (size_t )(*bufp - buf_start);
#line 291
  return;
}
}
#line 293 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/http.c"
static int parse_data(Call *c , char **bufp , size_t *buf_lenp ) 
{ 
  size_t bytes_needed ;
  size_t buf_len ;
  Conn *s ;
  char *buf ;
  struct iovec iov ;
  Any_Type arg ;

  {
#line 296
  buf_len = *buf_lenp;
#line 297
  s = c->conn;
#line 298
  buf = *bufp;
#line 302
  bytes_needed = s->content_length - c->reply.content_bytes;
#line 304
  if (buf_len > bytes_needed) {
#line 305
    buf_len = bytes_needed;
  }
  {
#line 307
  iov.iov_base = (void *)buf;
#line 308
  iov.iov_len = buf_len;
#line 309
  arg.vp = (void *)(& iov);
#line 310
  event_signal((Event_Type )21, (Object *)c, arg);
#line 312
  c->reply.content_bytes += buf_len;
#line 313
  *bufp = buf + buf_len;
#line 314
  *buf_lenp -= buf_len;
  }
#line 316
  return (buf_len == bytes_needed);
}
}
#line 319 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/http.c"
static void xfer_chunked(Call *c , char **bufp , size_t *buf_lenp ) 
{ 
  Conn *s ;
  size_t chunk_length ;
  char *end ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 322
  s = c->conn;
  {
#line 326
  while (1) {
    while_continue: /* CIL Label */ ;
#line 326
    if (*buf_lenp > 0UL) {
#line 326
      if (! ((unsigned int )s->state < 10U)) {
#line 326
        goto while_break;
      }
    } else {
#line 326
      goto while_break;
    }
#line 328
    if (c->reply.content_bytes >= s->content_length) {
      {
#line 331
      tmp = get_line(c, bufp, buf_lenp);
      }
#line 331
      if (! tmp) {
#line 332
        return;
      }
#line 333
      if (s->line.iov_len == 0UL) {
#line 334
        goto while_continue;
      }
      {
#line 336
      tmp___0 = __errno_location();
#line 336
      *tmp___0 = 0;
#line 337
      chunk_length = strtoul((char const   */* __restrict  */)s->line.iov_base, (char **/* __restrict  */)(& end),
                             16);
#line 338
      s->line.iov_len = (size_t )0;
#line 339
      tmp___1 = __errno_location();
      }
#line 339
      if (*tmp___1 == 34) {
        {
#line 341
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s.xfer_chunked: bad chunk line `%s\'\n",
                prog_name, (char *)s->line.iov_base);
        }
#line 343
        goto while_continue;
      } else
#line 339
      if ((unsigned long )end == (unsigned long )s->line.iov_base) {
        {
#line 341
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s.xfer_chunked: bad chunk line `%s\'\n",
                prog_name, (char *)s->line.iov_base);
        }
#line 343
        goto while_continue;
      }
#line 346
      if (chunk_length == 0UL) {
#line 349
        s->state = (Conn_State )8;
#line 350
        return;
      }
#line 352
      s->content_length += chunk_length;
    }
    {
#line 354
    parse_data(c, bufp, buf_lenp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 356
  return;
}
}
#line 358 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/http.c"
void http_process_reply_bytes(Call *c , char **bufp , size_t *buf_lenp ) 
{ 
  Conn *s ;
  struct iovec iov ;
  Any_Type arg ;
  int tmp ;

  {
  {
#line 361
  s = c->conn;
#line 365
  iov.iov_base = (void *)*bufp;
#line 366
  iov.iov_len = *buf_lenp;
#line 367
  arg.vp = (void *)(& iov);
#line 368
  event_signal((Event_Type )20, (Object *)c, arg);
  }
  {
#line 370
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 374
    if ((unsigned int )s->state == 3U) {
#line 374
      goto case_3;
    }
#line 378
    if ((unsigned int )s->state == 4U) {
#line 378
      goto case_4;
    }
#line 382
    if ((unsigned int )s->state == 8U) {
#line 382
      goto case_8;
    }
#line 386
    if ((unsigned int )s->state == 6U) {
#line 386
      goto case_6;
    }
#line 391
    if ((unsigned int )s->state == 5U) {
#line 391
      goto case_5;
    }
#line 395
    if ((unsigned int )s->state == 7U) {
#line 395
      goto case_7;
    }
#line 399
    if ((unsigned int )s->state == 9U) {
#line 399
      goto case_9;
    }
#line 402
    goto switch_default;
    case_3: /* CIL Label */ 
    {
#line 375
    parse_status_line(c, bufp, buf_lenp);
    }
#line 376
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 379
    parse_headers(c, bufp, buf_lenp);
    }
#line 380
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 383
    parse_footers(c, bufp, buf_lenp);
    }
#line 384
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 387
    tmp = parse_data(c, bufp, buf_lenp);
    }
#line 387
    if (tmp) {
#line 387
      if ((unsigned int )s->state < 10U) {
#line 388
        s->state = (Conn_State )9;
      }
    }
#line 389
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 392
    parse_headers(c, bufp, buf_lenp);
    }
#line 393
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 396
    xfer_chunked(c, bufp, buf_lenp);
    }
#line 397
    goto switch_break;
    case_9: /* CIL Label */ 
#line 400
    return;
    switch_default: /* CIL Label */ 
    {
#line 403
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s.http_process_reply_bytes: bad state %d\n",
            prog_name, (unsigned int )s->state);
#line 405
    exit(1);
    }
    switch_break: /* CIL Label */ ;
    }
#line 370
    if (*buf_lenp > 0UL) {
#line 370
      if (! ((unsigned int )s->state < 10U)) {
#line 370
        goto while_break;
      }
    } else {
#line 370
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 409
  return;
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/event.c"
static Event_Action action[25]  = {      {0, {{(void (*)(Event_Type type , Object *obj , Any_Type registration_time_arg ,
                     Any_Type signal_time_arg ))0, {.l = 0L}}, {(void (*)(Event_Type type ,
                                                                          Object *obj ,
                                                                          Any_Type registration_time_arg ,
                                                                          Any_Type signal_time_arg ))0,
                                                                {.l = 0L}}, {(void (*)(Event_Type type ,
                                                                                       Object *obj ,
                                                                                       Any_Type registration_time_arg ,
                                                                                       Any_Type signal_time_arg ))0,
                                                                             {.l = 0L}},
          {(void (*)(Event_Type type , Object *obj , Any_Type registration_time_arg ,
                     Any_Type signal_time_arg ))0, {.l = 0L}}}}};
#line 86 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/event.c"
void event_register_handler(Event_Type et , void (*handler)(Event_Type type , Object *obj ,
                                                            Any_Type registration_time_arg ,
                                                            Any_Type signal_time_arg ) ,
                            Any_Type arg ) 
{ 
  struct closure *c ;
  int n ;

  {
#line 92
  n = action[et].num_ops;
#line 93
  if (n >= 4) {
    {
#line 95
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"event_register_handler: sorry, attempted to register more than %d handlers\n",
            4);
#line 97
    exit(1);
    }
  }
#line 99
  c = action[et].closure + n;
#line 100
  c->op = handler;
#line 101
  c->arg = arg;
#line 102
  action[et].num_ops = n + 1;
#line 103
  return;
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/event.c"
void event_signal(Event_Type type , Object *obj , Any_Type arg ) 
{ 
  Event_Action *act ;
  struct closure *c ;
  struct closure *end ;

  {
#line 108
  act = action + (unsigned int )type;
#line 118
  end = & act->closure[act->num_ops];
#line 119
  c = & act->closure[0];
  {
#line 119
  while (1) {
    while_continue: /* CIL Label */ ;
#line 119
    if (! ((unsigned long )c < (unsigned long )end)) {
#line 119
      goto while_break;
    }
    {
#line 120
    (*(c->op))(type, obj, c->arg, arg);
#line 119
    c ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 121
  return;
}
}
#line 45 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/conn.c"
void conn_init(Conn *conn___0 ) 
{ 


  {
  {
#line 48
  conn___0->hostname = param.server;
#line 49
  conn___0->hostname_len = strlen(param.server);
#line 50
  conn___0->port = param.port;
#line 51
  conn___0->sd = -1;
#line 52
  conn___0->myport = -1;
#line 53
  conn___0->line.iov_base = (void *)(conn___0->line_buf);
  }
#line 54
  if (param.server_name) {
    {
#line 56
    conn___0->fqdname = param.server_name;
#line 57
    conn___0->fqdname_len = strlen(param.server_name);
    }
  } else {
#line 61
    conn___0->fqdname = conn___0->hostname;
#line 62
    conn___0->fqdname_len = conn___0->hostname_len;
  }
#line 86
  return;
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/conn.c"
void conn_deinit(Conn *conn___0 ) 
{ 


  {
#line 91
  if (conn___0->sd < 0) {
#line 91
    if (! ((unsigned int )conn___0->state != 11U)) {
      {
#line 91
      __assert_fail("conn->sd < 0 && conn->state != S_FREE", "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/conn.c",
                    91U, "conn_deinit");
      }
    }
  } else {
    {
#line 91
    __assert_fail("conn->sd < 0 && conn->state != S_FREE", "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/conn.c",
                  91U, "conn_deinit");
    }
  }
#line 92
  if (! (! conn___0->sendq)) {
    {
#line 92
    __assert_fail("!conn->sendq", "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/conn.c",
                  92U, "conn_deinit");
    }
  }
#line 93
  if (! (! conn___0->recvq)) {
    {
#line 93
    __assert_fail("!conn->recvq", "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/conn.c",
                  93U, "conn_deinit");
    }
  }
#line 94
  if (! (! conn___0->watchdog)) {
    {
#line 94
    __assert_fail("!conn->watchdog", "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/conn.c",
                  94U, "conn_deinit");
    }
  }
#line 95
  conn___0->state = (Conn_State )11;
#line 101
  return;
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/conn_rate.c"
static int num_conns_generated  ;
#line 49 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/conn_rate.c"
static int num_conns_destroyed  ;
#line 50 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/conn_rate.c"
static Rate_Generator rg  ;
#line 52 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/conn_rate.c"
static int make_conn(Any_Type arg ) 
{ 
  Conn *s ;
  int tmp ;
  Object *tmp___0 ;

  {
#line 57
  tmp = num_conns_generated;
#line 57
  num_conns_generated ++;
#line 57
  if (tmp >= param.num_conns) {
#line 58
    return (-1);
  }
  {
#line 60
  tmp___0 = object_new((Object_Type )0);
#line 60
  s = (Conn *)tmp___0;
  }
#line 61
  if (! s) {
#line 62
    return (-1);
  }
  {
#line 64
  core_connect(s);
  }
#line 65
  return (0);
}
}
#line 68 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/conn_rate.c"
static void destroyed(void) 
{ 


  {
#line 71
  num_conns_destroyed ++;
#line 71
  if (num_conns_destroyed >= param.num_conns) {
    {
#line 72
    core_exit();
    }
  }
#line 73
  return;
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/conn_rate.c"
static void init___2(void) 
{ 
  Any_Type arg ;

  {
  {
#line 80
  rg.arg.l = 0L;
#line 81
  rg.tick = & make_conn;
#line 83
  arg.l = 0L;
#line 84
  event_register_handler((Event_Type )10, (void (*)(Event_Type type , Object *obj ,
                                                    Any_Type registration_time_arg ,
                                                    Any_Type signal_time_arg ))(& destroyed),
                         arg);
  }
#line 85
  return;
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/conn_rate.c"
static void start(void) 
{ 


  {
  {
#line 90
  rg.rate = & param.rate;
#line 91
  rate_generator_start(& rg, (Event_Type )10);
  }
#line 92
  return;
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/conn_rate.c"
Load_Generator conn_rate  =    {"creates connections at a fixed rate", & init___2, & start, & no_op};
#line 38 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/sess.c"
void sess_init(Sess *sess ) 
{ 


  {
#line 41
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/sess.c"
void sess_deinit(Sess *sess ) 
{ 


  {
#line 50
  return;
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/sess.c"
void sess_failure(Sess *sess ) 
{ 
  Any_Type arg ;

  {
#line 57
  if (sess->failed) {
#line 58
    return;
  }
  {
#line 59
  sess->failed = (u_int )1;
#line 61
  arg.l = 0L;
#line 62
  event_signal((Event_Type )4, (Object *)sess, arg);
#line 64
  object_dec_ref((Object *)sess);
  }
#line 65
  return;
}
}
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 176 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 55 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/misc.c"
static char const   *extra  ;
#line 56 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/misc.c"
static size_t extra_len  ;
#line 58 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/misc.c"
static size_t method_len  ;
#line 63 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/misc.c"
static char const   *unescape(char const   *str , size_t *len ) 
{ 
  char *dp ;
  char *dst ;
  char *tmp ;
  char const   *cp ;
  int ch ;
  int *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  long tmp___4 ;
  char *tmp___5 ;
  char const   *tmp___6 ;

  {
  {
#line 66
  tmp = strdup(str);
#line 66
  dst = tmp;
  }
#line 70
  if (! dst) {
    {
#line 71
    tmp___0 = __errno_location();
#line 71
    tmp___1 = strerror(*tmp___0);
#line 71
    panic("%s: strdup() failed: %s\n", prog_name, tmp___1);
    }
  }
#line 73
  cp = str;
#line 73
  dp = dst;
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 73
    tmp___6 = cp;
#line 73
    cp ++;
#line 73
    ch = (int )*tmp___6;
#line 73
    if (! ch) {
#line 73
      goto while_break;
    }
#line 75
    if (ch == 92) {
#line 77
      tmp___2 = cp;
#line 77
      cp ++;
#line 77
      ch = (int )*tmp___2;
      {
#line 80
      if (ch == 92) {
#line 80
        goto case_92;
      }
#line 83
      if (ch == 97) {
#line 83
        goto case_97;
      }
#line 87
      if (ch == 114) {
#line 87
        goto case_114;
      }
#line 91
      if (ch == 110) {
#line 91
        goto case_110;
      }
#line 97
      if (ch == 57) {
#line 97
        goto case_57;
      }
#line 97
      if (ch == 56) {
#line 97
        goto case_57;
      }
#line 97
      if (ch == 55) {
#line 97
        goto case_57;
      }
#line 97
      if (ch == 54) {
#line 97
        goto case_57;
      }
#line 97
      if (ch == 53) {
#line 97
        goto case_57;
      }
#line 97
      if (ch == 52) {
#line 97
        goto case_57;
      }
#line 97
      if (ch == 51) {
#line 97
        goto case_57;
      }
#line 97
      if (ch == 50) {
#line 97
        goto case_57;
      }
#line 97
      if (ch == 49) {
#line 97
        goto case_57;
      }
#line 97
      if (ch == 48) {
#line 97
        goto case_57;
      }
#line 101
      goto switch_default;
      case_92: /* CIL Label */ 
#line 81
      goto switch_break;
      case_97: /* CIL Label */ 
#line 84
      ch = 10;
#line 85
      goto switch_break;
      case_114: /* CIL Label */ 
#line 88
      ch = 13;
#line 89
      goto switch_break;
      case_110: /* CIL Label */ 
#line 92
      tmp___3 = dp;
#line 92
      dp ++;
#line 92
      *tmp___3 = (char)13;
#line 93
      ch = 10;
#line 94
      goto switch_break;
      case_57: /* CIL Label */ 
      case_56: /* CIL Label */ 
      case_55: /* CIL Label */ 
      case_54: /* CIL Label */ 
      case_53: /* CIL Label */ 
      case_52: /* CIL Label */ 
      case_51: /* CIL Label */ 
      case_50: /* CIL Label */ 
      case_49: /* CIL Label */ 
      case_48: /* CIL Label */ 
      {
#line 98
      tmp___4 = strtol((char const   */* __restrict  */)(cp - 1), (char **/* __restrict  */)((char **)(& cp)),
                       8);
#line 98
      ch = (int )tmp___4;
      }
#line 99
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 102
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ignoring unknown escape sequence `\\%c\' in --add-header\n",
              prog_name, ch);
      }
#line 104
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 107
    tmp___5 = dp;
#line 107
    dp ++;
#line 107
    *tmp___5 = (char )ch;
  }
  while_break: /* CIL Label */ ;
  }
#line 109
  *len = (size_t )(dp - dst);
#line 110
  return ((char const   *)dst);
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/misc.c"
static void call_created(Event_Type et , Object *obj , Any_Type reg_arg , Any_Type arg ) 
{ 
  Call *c ;

  {
#line 116
  c = (Call *)obj;
#line 118
  if (! ((unsigned int )et == 13U)) {
    {
#line 118
    __assert_fail("et == EV_CALL_NEW && 1", "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/misc.c",
                  118U, "call_created");
    }
  }
#line 120
  if (method_len > 0UL) {
    {
#line 121
    while (1) {
      while_continue: /* CIL Label */ ;
#line 121
      c->req.iov[0].iov_base = (void *)((caddr_t )param.method);
#line 121
      c->req.iov[0].iov_len = method_len;
#line 121
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 123
  if (extra_len > 0UL) {
    {
#line 124
    call_append_request_header(c, extra, extra_len);
    }
  }
#line 125
  return;
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/misc.c"
static void init___3(void) 
{ 
  Any_Type arg ;

  {
#line 133
  if (param.additional_header) {
    {
#line 134
    extra = unescape(param.additional_header, & extra_len);
    }
  }
#line 136
  if (param.method) {
    {
#line 137
    method_len = strlen(param.method);
    }
  }
  {
#line 139
  arg.l = 0L;
#line 140
  event_register_handler((Event_Type )13, & call_created, arg);
  }
#line 141
  return;
}
}
#line 143 "/home/june/repo/benchmarks/collector/temp/httperf-0.9.0/src/gen/misc.c"
Load_Generator misc  =    {"Miscellaneous command line options", & init___3, & no_op, & no_op};
