/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 69 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libfastmint.h"
typedef unsigned int uInt32;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 43 "/usr/include/regex.h"
typedef unsigned long reg_syntax_t;
#line 368 "/usr/include/regex.h"
struct re_pattern_buffer {
   unsigned char *__buffer ;
   unsigned long __allocated ;
   unsigned long __used ;
   reg_syntax_t __syntax ;
   char *__fastmap ;
   unsigned char *__translate ;
   size_t re_nsub ;
   unsigned int __can_be_null : 1 ;
   unsigned int __regs_allocated : 2 ;
   unsigned int __fastmap_accurate : 1 ;
   unsigned int __no_sub : 1 ;
   unsigned int __not_bol : 1 ;
   unsigned int __not_eol : 1 ;
   unsigned int __newline_anchor : 1 ;
};
#line 434 "/usr/include/regex.h"
typedef struct re_pattern_buffer regex_t;
#line 437 "/usr/include/regex.h"
typedef int regoff_t;
#line 463 "/usr/include/regex.h"
struct __anonstruct_regmatch_t_26 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 463 "/usr/include/regex.h"
typedef struct __anonstruct_regmatch_t_26 regmatch_t;
#line 43 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/sha1.h"
struct __anonstruct_SHA1_ctx_29 {
   unsigned int H[5] ;
   unsigned long bits ;
   unsigned char M[64] ;
};
#line 43 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/sha1.h"
typedef struct __anonstruct_SHA1_ctx_29 SHA1_ctx;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 59 "/usr/include/time.h"
typedef __clock_t clock_t;
#line 26 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/sdb.h"
struct __anonstruct_DB_31 {
   FILE *file ;
   char filename[4097] ;
   long read_pos ;
   long write_pos ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/sdb.h"
typedef struct __anonstruct_DB_31 DB;
#line 104 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/hashcash.c"
struct __anonstruct_ELEMENT_35 {
   char *str ;
   void *regexp ;
   int type ;
   int case_flag ;
   long validity ;
   long grace ;
   long anon ;
   int width ;
   int bits ;
   int over ;
};
#line 104 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/hashcash.c"
typedef struct __anonstruct_ELEMENT_35 ELEMENT;
#line 117 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/hashcash.c"
struct __anonstruct_ARRAY_36 {
   int num ;
   int max ;
   ELEMENT *elt ;
};
#line 117 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/hashcash.c"
typedef struct __anonstruct_ARRAY_36 ARRAY;
#line 1065 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/hashcash.c"
struct __anonstruct_db_arg_37 {
   time_t expires_before ;
   char now_utime[14] ;
   int all ;
   long validity ;
   long grace ;
   ARRAY *resource ;
};
#line 1065 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/hashcash.c"
typedef struct __anonstruct_db_arg_37 db_arg;
#line 70 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libfastmint.h"
typedef unsigned long (*HC_Mint_Routine)(int bits , int *best , unsigned char *block ,
                                         uInt32 const   *IV , int tailIndex , unsigned long maxIter ,
                                         int (*cb)(int percent , int largest , int target ,
                                                   double count , double expected ,
                                                   void *user ) , void *user_args ,
                                         double counter , double expected );
#line 71 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libfastmint.h"
typedef int (*HC_Mint_Capable_Routine)(void);
#line 73
enum __anonenum_EncodeAlphabet_50 {
    EncodeHexUpper = 0,
    EncodeHexLower = 1,
    EncodeAlpha16Upper = 2,
    EncodeAlpha16Lower = 3,
    EncodeBase64 = 4
} ;
#line 73 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libfastmint.h"
typedef enum __anonenum_EncodeAlphabet_50 EncodeAlphabet;
#line 82 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libfastmint.h"
struct __anonstruct_HC_Minter_51 {
   char const   *name ;
   EncodeAlphabet encoding ;
   unsigned long (*func)(int bits , int *best , unsigned char *block , uInt32 const   *IV ,
                         int tailIndex , unsigned long maxIter , int (*cb)(int percent ,
                                                                           int largest ,
                                                                           int target ,
                                                                           double count ,
                                                                           double expected ,
                                                                           void *user ) ,
                         void *user_args , double counter , double expected ) ;
   int (*test)(void) ;
};
#line 82 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libfastmint.h"
typedef struct __anonstruct_HC_Minter_51 HC_Minter;
#line 858 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 50 "/usr/include/x86_64-linux-gnu/sys/file.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) flock)(int __fd ,
                                                                            int __operation ) ;
#line 9 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/lock.h"
int lock_write(FILE *f ) ;
#line 10
int lock_read(FILE *f ) ;
#line 11
int lock_unlock(FILE *f ) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/lock.c"
int lock_write(FILE *f ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 15
  tmp = fileno(f);
#line 15
  tmp___0 = flock(tmp, 2);
  }
#line 15
  return (tmp___0 == 0);
}
}
#line 18 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/lock.c"
int lock_read(FILE *f ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 20
  tmp = fileno(f);
#line 20
  tmp___0 = flock(tmp, 1);
  }
#line 20
  return (tmp___0 == 0);
}
}
#line 23 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/lock.c"
int lock_unlock(FILE *f ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 25
  tmp = fileno(f);
#line 25
  tmp___0 = flock(tmp, 8);
  }
#line 25
  return (tmp___0 == 0);
}
}
#line 172 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libfastmint.h"
unsigned long minter_altivec_standard_1(int bits , int *best , unsigned char *block ,
                                        uInt32 const   *IV , int tailIndex , unsigned long maxIter ,
                                        int (*cb)(int percent , int largest , int target ,
                                                  double count , double expected ,
                                                  void *user ) , void *user_args ,
                                        double counter , double expected ) ;
#line 173
int minter_altivec_standard_1_test(void) ;
#line 8 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/fastmint_altivec_standard_1.c"
int minter_altivec_standard_1_test(void) 
{ 


  {
#line 16
  return (0);
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/fastmint_altivec_standard_1.c"
unsigned long minter_altivec_standard_1(int bits , int *best , unsigned char *block ,
                                        uInt32 const   *IV , int tailIndex , unsigned long maxIter ,
                                        int (*cb)(int percent , int largest , int target ,
                                                  double count , double expected ,
                                                  void *user ) , void *user_args ,
                                        double counter , double expected ) 
{ 


  {
#line 385
  return (0UL);
}
}
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 93 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libfastmint.h"
char const   *encodeAlphabets[5] ;
#line 162
unsigned long minter_ansi_compact_2(int bits , int *best , unsigned char *block ,
                                    uInt32 const   *IV , int tailIndex , unsigned long maxIter ,
                                    int (*cb)(int percent , int largest , int target ,
                                              double count , double expected , void *user ) ,
                                    void *user_args , double counter , double expected ) ;
#line 163
int minter_ansi_compact_2_test(void) ;
#line 4 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/fastmint_ansi_compact_2.c"
int minter_ansi_compact_2_test(void) 
{ 


  {
#line 7
  return (1);
}
}
#line 104 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/fastmint_ansi_compact_2.c"
static int const   endTest  =    (int const   )3;
#line 88 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/fastmint_ansi_compact_2.c"
unsigned long minter_ansi_compact_2(int bits , int *best , unsigned char *block ,
                                    uInt32 const   *IV , int tailIndex , unsigned long maxIter ,
                                    int (*cb)(int percent , int largest , int target ,
                                              double count , double expected , void *user ) ,
                                    void *user_args , double counter , double expected ) 
{ 
  double percent ;
  struct timeval prev ;
  struct timeval curr ;
  int lastBits ;
  unsigned long iters ;
  int n ;
  int t ;
  int gotBits ;
  int maxBits ;
  int tmp ;
  uInt32 bitMask1Low ;
  uInt32 bitMask1High ;
  uInt32 s ;
  uInt32 A ;
  uInt32 B ;
  uInt32 *W ;
  uInt32 A1 ;
  uInt32 B1 ;
  uInt32 C1 ;
  uInt32 D1 ;
  uInt32 E1 ;
  uInt32 A2 ;
  uInt32 B2 ;
  uInt32 C2 ;
  uInt32 D2 ;
  uInt32 E2 ;
  uInt32 W1[80] ;
  unsigned int tmp___0 ;
  uInt32 W2[80] ;
  unsigned int tmp___1 ;
  uInt32 H[5] ;
  unsigned int tmp___2 ;
  uInt32 pH[5] ;
  unsigned int tmp___3 ;
  char const   *p ;
  unsigned char *X1 ;
  unsigned char *X2 ;
  int addressMask ;
  unsigned char *output ;
  int W32[9] ;
  int W52[7] ;
  char wordUpdate[80] ;
  unsigned int tmp___4 ;
  uInt32 tmp___5 ;
  uInt32 tmp___6 ;
  unsigned char tmp___7 ;
  unsigned char tmp___8 ;
  unsigned char tmp___9 ;
  unsigned char tmp___10 ;
  unsigned char tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 90
  prev.tv_sec = (__time_t )0;
#line 90
  prev.tv_usec = (__suseconds_t )0;
#line 90
  lastBits = 0;
#line 91
  iters = 0UL;
#line 92
  n = 0;
#line 92
  t = 0;
#line 92
  gotBits = 0;
#line 92
  if (bits > 16) {
#line 92
    tmp = 16;
  } else {
#line 92
    tmp = bits;
  }
#line 92
  maxBits = tmp;
#line 93
  bitMask1Low = (uInt32 )0;
#line 93
  bitMask1High = (uInt32 )0;
#line 93
  s = (uInt32 )0;
#line 94
  A = (uInt32 )0;
#line 94
  B = (uInt32 )0;
#line 94
  W = (uInt32 *)0;
#line 95
  A1 = (uInt32 )0;
#line 95
  B1 = (uInt32 )0;
#line 95
  C1 = (uInt32 )0;
#line 95
  D1 = (uInt32 )0;
#line 95
  E1 = (uInt32 )0;
#line 96
  A2 = (uInt32 )0;
#line 96
  B2 = (uInt32 )0;
#line 96
  C2 = (uInt32 )0;
#line 96
  D2 = (uInt32 )0;
#line 96
  E2 = (uInt32 )0;
#line 97
  W1[0] = (uInt32 )0;
#line 97
  tmp___0 = 1U;
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
#line 97
    if (tmp___0 >= 80U) {
#line 97
      goto while_break;
    }
#line 97
    W1[tmp___0] = 0U;
#line 97
    tmp___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  W2[0] = (uInt32 )0;
#line 98
  tmp___1 = 1U;
  {
#line 98
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 98
    if (tmp___1 >= 80U) {
#line 98
      goto while_break___0;
    }
#line 98
    W2[tmp___1] = 0U;
#line 98
    tmp___1 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 99
  H[0] = (uInt32 )0;
#line 99
  tmp___2 = 1U;
  {
#line 99
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 99
    if (tmp___2 >= 5U) {
#line 99
      goto while_break___1;
    }
#line 99
    H[tmp___2] = 0U;
#line 99
    tmp___2 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 99
  pH[0] = (uInt32 )0;
#line 99
  tmp___3 = 1U;
  {
#line 99
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 99
    if (tmp___3 >= 5U) {
#line 99
      goto while_break___2;
    }
#line 99
    pH[tmp___3] = 0U;
#line 99
    tmp___3 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 100
  p = encodeAlphabets[4];
#line 101
  X1 = (unsigned char *)(W1);
#line 102
  X2 = (unsigned char *)(W2);
#line 103
  addressMask = 0;
#line 105
  output = block;
#line 106
  W32[0] = 21;
#line 106
  W32[1] = 23;
#line 106
  W32[2] = 24;
#line 106
  W32[3] = 26;
#line 106
  W32[4] = 27;
#line 106
  W32[5] = 29;
#line 106
  W32[6] = 30;
#line 106
  W32[7] = 31;
#line 106
  W32[8] = 0;
#line 106
  W52[0] = 20;
#line 106
  W52[1] = 23;
#line 106
  W52[2] = 26;
#line 106
  W52[3] = 28;
#line 106
  W52[4] = 29;
#line 106
  W52[5] = 31;
#line 106
  W52[6] = 0;
#line 107
  wordUpdate[0] = (char)0;
#line 107
  tmp___4 = 1U;
  {
#line 107
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 107
    if (tmp___4 >= 80U) {
#line 107
      goto while_break___3;
    }
#line 107
    wordUpdate[tmp___4] = (char)0;
#line 107
    tmp___4 ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 109
  *best = 0;
#line 112
  addressMask = (int )*((char *)(& endTest));
#line 115
  if (maxBits < 32) {
#line 116
    if (bits == 0) {
#line 116
      bitMask1Low = (uInt32 )0;
    } else {
#line 117
      bitMask1Low = ~ ((1U << (32 - maxBits)) - 1U);
    }
#line 119
    bitMask1High = (uInt32 )0;
  } else {
#line 121
    bitMask1Low = (uInt32 )(~ 0);
#line 122
    bitMask1High = ~ ((1U << (64 - maxBits)) - 1U);
  }
#line 124
  maxBits = 0;
#line 127
  t = 0;
  {
#line 127
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 127
    if (! (t < 16)) {
#line 127
      goto while_break___4;
    }
#line 128
    tmp___5 = (uInt32 )(((((int )*((output + t * 4) + 0) << 24) | ((int )*((output + t * 4) + 1) << 16)) | ((int )*((output + t * 4) + 2) << 8)) | (int )*((output + t * 4) + 3));
#line 128
    W2[t] = tmp___5;
#line 128
    W1[t] = tmp___5;
#line 127
    t ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 129
  t = 0;
  {
#line 129
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 129
    if (! (t < 5)) {
#line 129
      goto while_break___5;
    }
#line 130
    tmp___6 = (uInt32 )*(IV + t);
#line 130
    H[t] = tmp___6;
#line 130
    pH[t] = tmp___6;
#line 129
    t ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 139
  if (tailIndex == 32) {
#line 139
    goto case_32;
  }
#line 144
  if (tailIndex == 52) {
#line 144
    goto case_52;
  }
#line 134
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 135
  t = 16;
  {
#line 135
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 135
    if (! (t < 32)) {
#line 135
      goto while_break___6;
    }
#line 136
    wordUpdate[t] = (char)1;
#line 135
    t ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 137
  goto switch_break;
  case_32: /* CIL Label */ 
#line 140
  t = 0;
  {
#line 140
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 140
    if (! W32[t]) {
#line 140
      goto while_break___7;
    }
#line 141
    wordUpdate[W32[t]] = (char)1;
#line 140
    t ++;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 142
  goto switch_break;
  case_52: /* CIL Label */ 
#line 145
  t = 0;
  {
#line 145
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 145
    if (! W52[t]) {
#line 145
      goto while_break___8;
    }
#line 146
    wordUpdate[W52[t]] = (char)1;
#line 145
    t ++;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 147
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 149
  t = 32;
  {
#line 149
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 149
    if (! (t < 80)) {
#line 149
      goto while_break___9;
    }
#line 150
    wordUpdate[t] = (char)1;
#line 149
    t ++;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 153
  iters = 0UL;
  {
#line 153
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 153
    if (! (iters < maxIter - 2UL)) {
#line 153
      goto while_break___10;
    }
#line 156
    *(X1 + ((tailIndex - 1) ^ addressMask)) = (unsigned char )*(p + (iters & 63UL));
#line 157
    *(X2 + ((tailIndex - 1) ^ addressMask)) = (unsigned char )*(p + ((iters + 1UL) & 63UL));
#line 158
    if (! (iters & 63UL)) {
#line 159
      tmp___7 = (unsigned char )*(p + ((iters >> 6) & 63UL));
#line 159
      *(X2 + ((tailIndex - 2) ^ addressMask)) = tmp___7;
#line 159
      *(X1 + ((tailIndex - 2) ^ addressMask)) = tmp___7;
#line 160
      tmp___8 = (unsigned char )*(p + ((iters >> 12) & 63UL));
#line 160
      *(X2 + ((tailIndex - 3) ^ addressMask)) = tmp___8;
#line 160
      *(X1 + ((tailIndex - 3) ^ addressMask)) = tmp___8;
#line 161
      tmp___9 = (unsigned char )*(p + ((iters >> 18) & 63UL));
#line 161
      *(X2 + ((tailIndex - 4) ^ addressMask)) = tmp___9;
#line 161
      *(X1 + ((tailIndex - 4) ^ addressMask)) = tmp___9;
#line 162
      tmp___10 = (unsigned char )*(p + ((iters >> 24) & 63UL));
#line 162
      *(X2 + ((tailIndex - 5) ^ addressMask)) = tmp___10;
#line 162
      *(X1 + ((tailIndex - 5) ^ addressMask)) = tmp___10;
#line 163
      tmp___11 = (unsigned char )*(p + ((iters >> 30) & 63UL));
#line 163
      *(X2 + ((tailIndex - 6) ^ addressMask)) = tmp___11;
#line 163
      *(X1 + ((tailIndex - 6) ^ addressMask)) = tmp___11;
    }
#line 167
    if (! (iters & 16777215UL)) {
#line 167
      if (tailIndex == 52) {
#line 167
        goto _L;
      } else
#line 167
      if (tailIndex == 32) {
        _L: /* CIL Label */ 
#line 168
        A1 = H[0];
#line 169
        B1 = H[1];
#line 170
        C1 = H[2];
#line 171
        D1 = H[3];
#line 172
        E1 = H[4];
#line 174
        t = 16;
        {
#line 174
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 174
          if (! (t < 32)) {
#line 174
            goto while_break___11;
          }
#line 175
          W1[t] = ((((W1[t - 16] ^ W1[t - 14]) ^ W1[t - 8]) ^ W1[t - 3]) << 1) | ((((W1[t - 16] ^ W1[t - 14]) ^ W1[t - 8]) ^ W1[t - 3]) >> 31);
#line 176
          W2[t] = ((((W2[t - 16] ^ W2[t - 14]) ^ W2[t - 8]) ^ W2[t - 3]) << 1) | ((((W2[t - 16] ^ W2[t - 14]) ^ W2[t - 8]) ^ W2[t - 3]) >> 31);
#line 174
          t ++;
        }
        while_break___11: /* CIL Label */ ;
        }
#line 179
        E1 += ((((A1 << 5) | (A1 >> 27)) + ((B1 & C1) | (~ B1 & D1))) + W1[0]) + 1518500249U;
#line 179
        B1 = (B1 << 30) | (B1 >> 2);
#line 180
        D1 += ((((E1 << 5) | (E1 >> 27)) + ((A1 & B1) | (~ A1 & C1))) + W1[1]) + 1518500249U;
#line 180
        A1 = (A1 << 30) | (A1 >> 2);
#line 181
        C1 += ((((D1 << 5) | (D1 >> 27)) + ((E1 & A1) | (~ E1 & B1))) + W1[2]) + 1518500249U;
#line 181
        E1 = (E1 << 30) | (E1 >> 2);
#line 182
        B1 += ((((C1 << 5) | (C1 >> 27)) + ((D1 & E1) | (~ D1 & A1))) + W1[3]) + 1518500249U;
#line 182
        D1 = (D1 << 30) | (D1 >> 2);
#line 183
        A1 += ((((B1 << 5) | (B1 >> 27)) + ((C1 & D1) | (~ C1 & E1))) + W1[4]) + 1518500249U;
#line 183
        C1 = (C1 << 30) | (C1 >> 2);
#line 184
        E1 += ((((A1 << 5) | (A1 >> 27)) + ((B1 & C1) | (~ B1 & D1))) + W1[5]) + 1518500249U;
#line 184
        B1 = (B1 << 30) | (B1 >> 2);
#line 185
        D1 += ((((E1 << 5) | (E1 >> 27)) + ((A1 & B1) | (~ A1 & C1))) + W1[6]) + 1518500249U;
#line 185
        A1 = (A1 << 30) | (A1 >> 2);
#line 187
        if (tailIndex == 52) {
#line 188
          C1 += ((((D1 << 5) | (D1 >> 27)) + ((E1 & A1) | (~ E1 & B1))) + W1[7]) + 1518500249U;
#line 188
          E1 = (E1 << 30) | (E1 >> 2);
#line 189
          B1 += ((((C1 << 5) | (C1 >> 27)) + ((D1 & E1) | (~ D1 & A1))) + W1[8]) + 1518500249U;
#line 189
          D1 = (D1 << 30) | (D1 >> 2);
#line 190
          A1 += ((((B1 << 5) | (B1 >> 27)) + ((C1 & D1) | (~ C1 & E1))) + W1[9]) + 1518500249U;
#line 190
          C1 = (C1 << 30) | (C1 >> 2);
#line 191
          E1 += ((((A1 << 5) | (A1 >> 27)) + ((B1 & C1) | (~ B1 & D1))) + W1[10]) + 1518500249U;
#line 191
          B1 = (B1 << 30) | (B1 >> 2);
#line 192
          D1 += ((((E1 << 5) | (E1 >> 27)) + ((A1 & B1) | (~ A1 & C1))) + W1[11]) + 1518500249U;
#line 192
          A1 = (A1 << 30) | (A1 >> 2);
        }
#line 195
        pH[0] = A1;
#line 196
        pH[1] = B1;
#line 197
        pH[2] = C1;
#line 198
        pH[3] = D1;
#line 199
        pH[4] = E1;
      }
    }
#line 203
    t = 16;
    {
#line 203
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 203
      if (! (t < 80)) {
#line 203
        goto while_break___12;
      }
#line 204
      if (wordUpdate[t]) {
#line 205
        W1[t] = ((((W1[t - 16] ^ W1[t - 14]) ^ W1[t - 8]) ^ W1[t - 3]) << 1) | ((((W1[t - 16] ^ W1[t - 14]) ^ W1[t - 8]) ^ W1[t - 3]) >> 31);
#line 206
        W2[t] = ((((W2[t - 16] ^ W2[t - 14]) ^ W2[t - 8]) ^ W2[t - 3]) << 1) | ((((W2[t - 16] ^ W2[t - 14]) ^ W2[t - 8]) ^ W2[t - 3]) >> 31);
      }
#line 203
      t ++;
    }
    while_break___12: /* CIL Label */ ;
    }
#line 211
    A2 = pH[0];
#line 211
    A1 = A2;
#line 212
    B2 = pH[1];
#line 212
    B1 = B2;
#line 213
    C2 = pH[2];
#line 213
    C1 = C2;
#line 214
    D2 = pH[3];
#line 214
    D1 = D2;
#line 215
    E2 = pH[4];
#line 215
    E1 = E2;
    {
#line 227
    if (tailIndex == 32) {
#line 227
      goto case_32___0;
    }
#line 233
    if (tailIndex == 52) {
#line 233
      goto case_52___0;
    }
#line 219
    goto switch_default___0;
    switch_default___0: /* CIL Label */ 
#line 220
    E1 += ((((A1 << 5) | (A1 >> 27)) + ((B1 & C1) | (~ B1 & D1))) + W1[0]) + 1518500249U;
#line 220
    B1 = (B1 << 30) | (B1 >> 2);
#line 220
    E2 += ((((A2 << 5) | (A2 >> 27)) + ((B2 & C2) | (~ B2 & D2))) + W2[0]) + 1518500249U;
#line 220
    B2 = (B2 << 30) | (B2 >> 2);
#line 221
    D1 += ((((E1 << 5) | (E1 >> 27)) + ((A1 & B1) | (~ A1 & C1))) + W1[1]) + 1518500249U;
#line 221
    A1 = (A1 << 30) | (A1 >> 2);
#line 221
    D2 += ((((E2 << 5) | (E2 >> 27)) + ((A2 & B2) | (~ A2 & C2))) + W2[1]) + 1518500249U;
#line 221
    A2 = (A2 << 30) | (A2 >> 2);
#line 222
    C1 += ((((D1 << 5) | (D1 >> 27)) + ((E1 & A1) | (~ E1 & B1))) + W1[2]) + 1518500249U;
#line 222
    E1 = (E1 << 30) | (E1 >> 2);
#line 222
    C2 += ((((D2 << 5) | (D2 >> 27)) + ((E2 & A2) | (~ E2 & B2))) + W2[2]) + 1518500249U;
#line 222
    E2 = (E2 << 30) | (E2 >> 2);
#line 223
    B1 += ((((C1 << 5) | (C1 >> 27)) + ((D1 & E1) | (~ D1 & A1))) + W1[3]) + 1518500249U;
#line 223
    D1 = (D1 << 30) | (D1 >> 2);
#line 223
    B2 += ((((C2 << 5) | (C2 >> 27)) + ((D2 & E2) | (~ D2 & A2))) + W2[3]) + 1518500249U;
#line 223
    D2 = (D2 << 30) | (D2 >> 2);
#line 224
    A1 += ((((B1 << 5) | (B1 >> 27)) + ((C1 & D1) | (~ C1 & E1))) + W1[4]) + 1518500249U;
#line 224
    C1 = (C1 << 30) | (C1 >> 2);
#line 224
    A2 += ((((B2 << 5) | (B2 >> 27)) + ((C2 & D2) | (~ C2 & E2))) + W2[4]) + 1518500249U;
#line 224
    C2 = (C2 << 30) | (C2 >> 2);
#line 225
    E1 += ((((A1 << 5) | (A1 >> 27)) + ((B1 & C1) | (~ B1 & D1))) + W1[5]) + 1518500249U;
#line 225
    B1 = (B1 << 30) | (B1 >> 2);
#line 225
    E2 += ((((A2 << 5) | (A2 >> 27)) + ((B2 & C2) | (~ B2 & D2))) + W2[5]) + 1518500249U;
#line 225
    B2 = (B2 << 30) | (B2 >> 2);
#line 226
    D1 += ((((E1 << 5) | (E1 >> 27)) + ((A1 & B1) | (~ A1 & C1))) + W1[6]) + 1518500249U;
#line 226
    A1 = (A1 << 30) | (A1 >> 2);
#line 226
    D2 += ((((E2 << 5) | (E2 >> 27)) + ((A2 & B2) | (~ A2 & C2))) + W2[6]) + 1518500249U;
#line 226
    A2 = (A2 << 30) | (A2 >> 2);
    case_32___0: /* CIL Label */ 
#line 228
    C1 += ((((D1 << 5) | (D1 >> 27)) + ((E1 & A1) | (~ E1 & B1))) + W1[7]) + 1518500249U;
#line 228
    E1 = (E1 << 30) | (E1 >> 2);
#line 228
    C2 += ((((D2 << 5) | (D2 >> 27)) + ((E2 & A2) | (~ E2 & B2))) + W2[7]) + 1518500249U;
#line 228
    E2 = (E2 << 30) | (E2 >> 2);
#line 229
    B1 += ((((C1 << 5) | (C1 >> 27)) + ((D1 & E1) | (~ D1 & A1))) + W1[8]) + 1518500249U;
#line 229
    D1 = (D1 << 30) | (D1 >> 2);
#line 229
    B2 += ((((C2 << 5) | (C2 >> 27)) + ((D2 & E2) | (~ D2 & A2))) + W2[8]) + 1518500249U;
#line 229
    D2 = (D2 << 30) | (D2 >> 2);
#line 230
    A1 += ((((B1 << 5) | (B1 >> 27)) + ((C1 & D1) | (~ C1 & E1))) + W1[9]) + 1518500249U;
#line 230
    C1 = (C1 << 30) | (C1 >> 2);
#line 230
    A2 += ((((B2 << 5) | (B2 >> 27)) + ((C2 & D2) | (~ C2 & E2))) + W2[9]) + 1518500249U;
#line 230
    C2 = (C2 << 30) | (C2 >> 2);
#line 231
    E1 += ((((A1 << 5) | (A1 >> 27)) + ((B1 & C1) | (~ B1 & D1))) + W1[10]) + 1518500249U;
#line 231
    B1 = (B1 << 30) | (B1 >> 2);
#line 231
    E2 += ((((A2 << 5) | (A2 >> 27)) + ((B2 & C2) | (~ B2 & D2))) + W2[10]) + 1518500249U;
#line 231
    B2 = (B2 << 30) | (B2 >> 2);
#line 232
    D1 += ((((E1 << 5) | (E1 >> 27)) + ((A1 & B1) | (~ A1 & C1))) + W1[11]) + 1518500249U;
#line 232
    A1 = (A1 << 30) | (A1 >> 2);
#line 232
    D2 += ((((E2 << 5) | (E2 >> 27)) + ((A2 & B2) | (~ A2 & C2))) + W2[11]) + 1518500249U;
#line 232
    A2 = (A2 << 30) | (A2 >> 2);
    case_52___0: /* CIL Label */ 
#line 234
    C1 += ((((D1 << 5) | (D1 >> 27)) + ((E1 & A1) | (~ E1 & B1))) + W1[12]) + 1518500249U;
#line 234
    E1 = (E1 << 30) | (E1 >> 2);
#line 234
    C2 += ((((D2 << 5) | (D2 >> 27)) + ((E2 & A2) | (~ E2 & B2))) + W2[12]) + 1518500249U;
#line 234
    E2 = (E2 << 30) | (E2 >> 2);
#line 235
    B1 += ((((C1 << 5) | (C1 >> 27)) + ((D1 & E1) | (~ D1 & A1))) + W1[13]) + 1518500249U;
#line 235
    D1 = (D1 << 30) | (D1 >> 2);
#line 235
    B2 += ((((C2 << 5) | (C2 >> 27)) + ((D2 & E2) | (~ D2 & A2))) + W2[13]) + 1518500249U;
#line 235
    D2 = (D2 << 30) | (D2 >> 2);
#line 236
    A1 += ((((B1 << 5) | (B1 >> 27)) + ((C1 & D1) | (~ C1 & E1))) + W1[14]) + 1518500249U;
#line 236
    C1 = (C1 << 30) | (C1 >> 2);
#line 236
    A2 += ((((B2 << 5) | (B2 >> 27)) + ((C2 & D2) | (~ C2 & E2))) + W2[14]) + 1518500249U;
#line 236
    C2 = (C2 << 30) | (C2 >> 2);
    switch_break___0: /* CIL Label */ ;
    }
#line 239
    E1 += ((((A1 << 5) | (A1 >> 27)) + ((B1 & C1) | (~ B1 & D1))) + W1[15]) + 1518500249U;
#line 239
    B1 = (B1 << 30) | (B1 >> 2);
#line 239
    E2 += ((((A2 << 5) | (A2 >> 27)) + ((B2 & C2) | (~ B2 & D2))) + W2[15]) + 1518500249U;
#line 239
    B2 = (B2 << 30) | (B2 >> 2);
#line 239
    D1 += ((((E1 << 5) | (E1 >> 27)) + ((A1 & B1) | (~ A1 & C1))) + W1[16]) + 1518500249U;
#line 239
    A1 = (A1 << 30) | (A1 >> 2);
#line 239
    D2 += ((((E2 << 5) | (E2 >> 27)) + ((A2 & B2) | (~ A2 & C2))) + W2[16]) + 1518500249U;
#line 239
    A2 = (A2 << 30) | (A2 >> 2);
#line 239
    C1 += ((((D1 << 5) | (D1 >> 27)) + ((E1 & A1) | (~ E1 & B1))) + W1[17]) + 1518500249U;
#line 239
    E1 = (E1 << 30) | (E1 >> 2);
#line 239
    C2 += ((((D2 << 5) | (D2 >> 27)) + ((E2 & A2) | (~ E2 & B2))) + W2[17]) + 1518500249U;
#line 239
    E2 = (E2 << 30) | (E2 >> 2);
#line 239
    B1 += ((((C1 << 5) | (C1 >> 27)) + ((D1 & E1) | (~ D1 & A1))) + W1[18]) + 1518500249U;
#line 239
    D1 = (D1 << 30) | (D1 >> 2);
#line 239
    B2 += ((((C2 << 5) | (C2 >> 27)) + ((D2 & E2) | (~ D2 & A2))) + W2[18]) + 1518500249U;
#line 239
    D2 = (D2 << 30) | (D2 >> 2);
#line 239
    A1 += ((((B1 << 5) | (B1 >> 27)) + ((C1 & D1) | (~ C1 & E1))) + W1[19]) + 1518500249U;
#line 239
    C1 = (C1 << 30) | (C1 >> 2);
#line 239
    A2 += ((((B2 << 5) | (B2 >> 27)) + ((C2 & D2) | (~ C2 & E2))) + W2[19]) + 1518500249U;
#line 239
    C2 = (C2 << 30) | (C2 >> 2);
#line 241
    E1 += ((((A1 << 5) | (A1 >> 27)) + ((B1 ^ C1) ^ D1)) + W1[20]) + 1859775393U;
#line 241
    B1 = (B1 << 30) | (B1 >> 2);
#line 241
    E2 += ((((A2 << 5) | (A2 >> 27)) + ((B2 ^ C2) ^ D2)) + W2[20]) + 1859775393U;
#line 241
    B2 = (B2 << 30) | (B2 >> 2);
#line 241
    D1 += ((((E1 << 5) | (E1 >> 27)) + ((A1 ^ B1) ^ C1)) + W1[21]) + 1859775393U;
#line 241
    A1 = (A1 << 30) | (A1 >> 2);
#line 241
    D2 += ((((E2 << 5) | (E2 >> 27)) + ((A2 ^ B2) ^ C2)) + W2[21]) + 1859775393U;
#line 241
    A2 = (A2 << 30) | (A2 >> 2);
#line 241
    C1 += ((((D1 << 5) | (D1 >> 27)) + ((E1 ^ A1) ^ B1)) + W1[22]) + 1859775393U;
#line 241
    E1 = (E1 << 30) | (E1 >> 2);
#line 241
    C2 += ((((D2 << 5) | (D2 >> 27)) + ((E2 ^ A2) ^ B2)) + W2[22]) + 1859775393U;
#line 241
    E2 = (E2 << 30) | (E2 >> 2);
#line 241
    B1 += ((((C1 << 5) | (C1 >> 27)) + ((D1 ^ E1) ^ A1)) + W1[23]) + 1859775393U;
#line 241
    D1 = (D1 << 30) | (D1 >> 2);
#line 241
    B2 += ((((C2 << 5) | (C2 >> 27)) + ((D2 ^ E2) ^ A2)) + W2[23]) + 1859775393U;
#line 241
    D2 = (D2 << 30) | (D2 >> 2);
#line 241
    A1 += ((((B1 << 5) | (B1 >> 27)) + ((C1 ^ D1) ^ E1)) + W1[24]) + 1859775393U;
#line 241
    C1 = (C1 << 30) | (C1 >> 2);
#line 241
    A2 += ((((B2 << 5) | (B2 >> 27)) + ((C2 ^ D2) ^ E2)) + W2[24]) + 1859775393U;
#line 241
    C2 = (C2 << 30) | (C2 >> 2);
#line 242
    E1 += ((((A1 << 5) | (A1 >> 27)) + ((B1 ^ C1) ^ D1)) + W1[25]) + 1859775393U;
#line 242
    B1 = (B1 << 30) | (B1 >> 2);
#line 242
    E2 += ((((A2 << 5) | (A2 >> 27)) + ((B2 ^ C2) ^ D2)) + W2[25]) + 1859775393U;
#line 242
    B2 = (B2 << 30) | (B2 >> 2);
#line 242
    D1 += ((((E1 << 5) | (E1 >> 27)) + ((A1 ^ B1) ^ C1)) + W1[26]) + 1859775393U;
#line 242
    A1 = (A1 << 30) | (A1 >> 2);
#line 242
    D2 += ((((E2 << 5) | (E2 >> 27)) + ((A2 ^ B2) ^ C2)) + W2[26]) + 1859775393U;
#line 242
    A2 = (A2 << 30) | (A2 >> 2);
#line 242
    C1 += ((((D1 << 5) | (D1 >> 27)) + ((E1 ^ A1) ^ B1)) + W1[27]) + 1859775393U;
#line 242
    E1 = (E1 << 30) | (E1 >> 2);
#line 242
    C2 += ((((D2 << 5) | (D2 >> 27)) + ((E2 ^ A2) ^ B2)) + W2[27]) + 1859775393U;
#line 242
    E2 = (E2 << 30) | (E2 >> 2);
#line 242
    B1 += ((((C1 << 5) | (C1 >> 27)) + ((D1 ^ E1) ^ A1)) + W1[28]) + 1859775393U;
#line 242
    D1 = (D1 << 30) | (D1 >> 2);
#line 242
    B2 += ((((C2 << 5) | (C2 >> 27)) + ((D2 ^ E2) ^ A2)) + W2[28]) + 1859775393U;
#line 242
    D2 = (D2 << 30) | (D2 >> 2);
#line 242
    A1 += ((((B1 << 5) | (B1 >> 27)) + ((C1 ^ D1) ^ E1)) + W1[29]) + 1859775393U;
#line 242
    C1 = (C1 << 30) | (C1 >> 2);
#line 242
    A2 += ((((B2 << 5) | (B2 >> 27)) + ((C2 ^ D2) ^ E2)) + W2[29]) + 1859775393U;
#line 242
    C2 = (C2 << 30) | (C2 >> 2);
#line 243
    E1 += ((((A1 << 5) | (A1 >> 27)) + ((B1 ^ C1) ^ D1)) + W1[30]) + 1859775393U;
#line 243
    B1 = (B1 << 30) | (B1 >> 2);
#line 243
    E2 += ((((A2 << 5) | (A2 >> 27)) + ((B2 ^ C2) ^ D2)) + W2[30]) + 1859775393U;
#line 243
    B2 = (B2 << 30) | (B2 >> 2);
#line 243
    D1 += ((((E1 << 5) | (E1 >> 27)) + ((A1 ^ B1) ^ C1)) + W1[31]) + 1859775393U;
#line 243
    A1 = (A1 << 30) | (A1 >> 2);
#line 243
    D2 += ((((E2 << 5) | (E2 >> 27)) + ((A2 ^ B2) ^ C2)) + W2[31]) + 1859775393U;
#line 243
    A2 = (A2 << 30) | (A2 >> 2);
#line 243
    C1 += ((((D1 << 5) | (D1 >> 27)) + ((E1 ^ A1) ^ B1)) + W1[32]) + 1859775393U;
#line 243
    E1 = (E1 << 30) | (E1 >> 2);
#line 243
    C2 += ((((D2 << 5) | (D2 >> 27)) + ((E2 ^ A2) ^ B2)) + W2[32]) + 1859775393U;
#line 243
    E2 = (E2 << 30) | (E2 >> 2);
#line 243
    B1 += ((((C1 << 5) | (C1 >> 27)) + ((D1 ^ E1) ^ A1)) + W1[33]) + 1859775393U;
#line 243
    D1 = (D1 << 30) | (D1 >> 2);
#line 243
    B2 += ((((C2 << 5) | (C2 >> 27)) + ((D2 ^ E2) ^ A2)) + W2[33]) + 1859775393U;
#line 243
    D2 = (D2 << 30) | (D2 >> 2);
#line 243
    A1 += ((((B1 << 5) | (B1 >> 27)) + ((C1 ^ D1) ^ E1)) + W1[34]) + 1859775393U;
#line 243
    C1 = (C1 << 30) | (C1 >> 2);
#line 243
    A2 += ((((B2 << 5) | (B2 >> 27)) + ((C2 ^ D2) ^ E2)) + W2[34]) + 1859775393U;
#line 243
    C2 = (C2 << 30) | (C2 >> 2);
#line 244
    E1 += ((((A1 << 5) | (A1 >> 27)) + ((B1 ^ C1) ^ D1)) + W1[35]) + 1859775393U;
#line 244
    B1 = (B1 << 30) | (B1 >> 2);
#line 244
    E2 += ((((A2 << 5) | (A2 >> 27)) + ((B2 ^ C2) ^ D2)) + W2[35]) + 1859775393U;
#line 244
    B2 = (B2 << 30) | (B2 >> 2);
#line 244
    D1 += ((((E1 << 5) | (E1 >> 27)) + ((A1 ^ B1) ^ C1)) + W1[36]) + 1859775393U;
#line 244
    A1 = (A1 << 30) | (A1 >> 2);
#line 244
    D2 += ((((E2 << 5) | (E2 >> 27)) + ((A2 ^ B2) ^ C2)) + W2[36]) + 1859775393U;
#line 244
    A2 = (A2 << 30) | (A2 >> 2);
#line 244
    C1 += ((((D1 << 5) | (D1 >> 27)) + ((E1 ^ A1) ^ B1)) + W1[37]) + 1859775393U;
#line 244
    E1 = (E1 << 30) | (E1 >> 2);
#line 244
    C2 += ((((D2 << 5) | (D2 >> 27)) + ((E2 ^ A2) ^ B2)) + W2[37]) + 1859775393U;
#line 244
    E2 = (E2 << 30) | (E2 >> 2);
#line 244
    B1 += ((((C1 << 5) | (C1 >> 27)) + ((D1 ^ E1) ^ A1)) + W1[38]) + 1859775393U;
#line 244
    D1 = (D1 << 30) | (D1 >> 2);
#line 244
    B2 += ((((C2 << 5) | (C2 >> 27)) + ((D2 ^ E2) ^ A2)) + W2[38]) + 1859775393U;
#line 244
    D2 = (D2 << 30) | (D2 >> 2);
#line 244
    A1 += ((((B1 << 5) | (B1 >> 27)) + ((C1 ^ D1) ^ E1)) + W1[39]) + 1859775393U;
#line 244
    C1 = (C1 << 30) | (C1 >> 2);
#line 244
    A2 += ((((B2 << 5) | (B2 >> 27)) + ((C2 ^ D2) ^ E2)) + W2[39]) + 1859775393U;
#line 244
    C2 = (C2 << 30) | (C2 >> 2);
#line 246
    E1 += ((((A1 << 5) | (A1 >> 27)) + ((B1 & (C1 | D1)) | (C1 & D1))) + W1[40]) + 2400959708U;
#line 246
    B1 = (B1 << 30) | (B1 >> 2);
#line 246
    E2 += ((((A2 << 5) | (A2 >> 27)) + ((B2 & (C2 | D2)) | (C2 & D2))) + W2[40]) + 2400959708U;
#line 246
    B2 = (B2 << 30) | (B2 >> 2);
#line 246
    D1 += ((((E1 << 5) | (E1 >> 27)) + ((A1 & (B1 | C1)) | (B1 & C1))) + W1[41]) + 2400959708U;
#line 246
    A1 = (A1 << 30) | (A1 >> 2);
#line 246
    D2 += ((((E2 << 5) | (E2 >> 27)) + ((A2 & (B2 | C2)) | (B2 & C2))) + W2[41]) + 2400959708U;
#line 246
    A2 = (A2 << 30) | (A2 >> 2);
#line 246
    C1 += ((((D1 << 5) | (D1 >> 27)) + ((E1 & (A1 | B1)) | (A1 & B1))) + W1[42]) + 2400959708U;
#line 246
    E1 = (E1 << 30) | (E1 >> 2);
#line 246
    C2 += ((((D2 << 5) | (D2 >> 27)) + ((E2 & (A2 | B2)) | (A2 & B2))) + W2[42]) + 2400959708U;
#line 246
    E2 = (E2 << 30) | (E2 >> 2);
#line 246
    B1 += ((((C1 << 5) | (C1 >> 27)) + ((D1 & (E1 | A1)) | (E1 & A1))) + W1[43]) + 2400959708U;
#line 246
    D1 = (D1 << 30) | (D1 >> 2);
#line 246
    B2 += ((((C2 << 5) | (C2 >> 27)) + ((D2 & (E2 | A2)) | (E2 & A2))) + W2[43]) + 2400959708U;
#line 246
    D2 = (D2 << 30) | (D2 >> 2);
#line 246
    A1 += ((((B1 << 5) | (B1 >> 27)) + ((C1 & (D1 | E1)) | (D1 & E1))) + W1[44]) + 2400959708U;
#line 246
    C1 = (C1 << 30) | (C1 >> 2);
#line 246
    A2 += ((((B2 << 5) | (B2 >> 27)) + ((C2 & (D2 | E2)) | (D2 & E2))) + W2[44]) + 2400959708U;
#line 246
    C2 = (C2 << 30) | (C2 >> 2);
#line 247
    E1 += ((((A1 << 5) | (A1 >> 27)) + ((B1 & (C1 | D1)) | (C1 & D1))) + W1[45]) + 2400959708U;
#line 247
    B1 = (B1 << 30) | (B1 >> 2);
#line 247
    E2 += ((((A2 << 5) | (A2 >> 27)) + ((B2 & (C2 | D2)) | (C2 & D2))) + W2[45]) + 2400959708U;
#line 247
    B2 = (B2 << 30) | (B2 >> 2);
#line 247
    D1 += ((((E1 << 5) | (E1 >> 27)) + ((A1 & (B1 | C1)) | (B1 & C1))) + W1[46]) + 2400959708U;
#line 247
    A1 = (A1 << 30) | (A1 >> 2);
#line 247
    D2 += ((((E2 << 5) | (E2 >> 27)) + ((A2 & (B2 | C2)) | (B2 & C2))) + W2[46]) + 2400959708U;
#line 247
    A2 = (A2 << 30) | (A2 >> 2);
#line 247
    C1 += ((((D1 << 5) | (D1 >> 27)) + ((E1 & (A1 | B1)) | (A1 & B1))) + W1[47]) + 2400959708U;
#line 247
    E1 = (E1 << 30) | (E1 >> 2);
#line 247
    C2 += ((((D2 << 5) | (D2 >> 27)) + ((E2 & (A2 | B2)) | (A2 & B2))) + W2[47]) + 2400959708U;
#line 247
    E2 = (E2 << 30) | (E2 >> 2);
#line 247
    B1 += ((((C1 << 5) | (C1 >> 27)) + ((D1 & (E1 | A1)) | (E1 & A1))) + W1[48]) + 2400959708U;
#line 247
    D1 = (D1 << 30) | (D1 >> 2);
#line 247
    B2 += ((((C2 << 5) | (C2 >> 27)) + ((D2 & (E2 | A2)) | (E2 & A2))) + W2[48]) + 2400959708U;
#line 247
    D2 = (D2 << 30) | (D2 >> 2);
#line 247
    A1 += ((((B1 << 5) | (B1 >> 27)) + ((C1 & (D1 | E1)) | (D1 & E1))) + W1[49]) + 2400959708U;
#line 247
    C1 = (C1 << 30) | (C1 >> 2);
#line 247
    A2 += ((((B2 << 5) | (B2 >> 27)) + ((C2 & (D2 | E2)) | (D2 & E2))) + W2[49]) + 2400959708U;
#line 247
    C2 = (C2 << 30) | (C2 >> 2);
#line 248
    E1 += ((((A1 << 5) | (A1 >> 27)) + ((B1 & (C1 | D1)) | (C1 & D1))) + W1[50]) + 2400959708U;
#line 248
    B1 = (B1 << 30) | (B1 >> 2);
#line 248
    E2 += ((((A2 << 5) | (A2 >> 27)) + ((B2 & (C2 | D2)) | (C2 & D2))) + W2[50]) + 2400959708U;
#line 248
    B2 = (B2 << 30) | (B2 >> 2);
#line 248
    D1 += ((((E1 << 5) | (E1 >> 27)) + ((A1 & (B1 | C1)) | (B1 & C1))) + W1[51]) + 2400959708U;
#line 248
    A1 = (A1 << 30) | (A1 >> 2);
#line 248
    D2 += ((((E2 << 5) | (E2 >> 27)) + ((A2 & (B2 | C2)) | (B2 & C2))) + W2[51]) + 2400959708U;
#line 248
    A2 = (A2 << 30) | (A2 >> 2);
#line 248
    C1 += ((((D1 << 5) | (D1 >> 27)) + ((E1 & (A1 | B1)) | (A1 & B1))) + W1[52]) + 2400959708U;
#line 248
    E1 = (E1 << 30) | (E1 >> 2);
#line 248
    C2 += ((((D2 << 5) | (D2 >> 27)) + ((E2 & (A2 | B2)) | (A2 & B2))) + W2[52]) + 2400959708U;
#line 248
    E2 = (E2 << 30) | (E2 >> 2);
#line 248
    B1 += ((((C1 << 5) | (C1 >> 27)) + ((D1 & (E1 | A1)) | (E1 & A1))) + W1[53]) + 2400959708U;
#line 248
    D1 = (D1 << 30) | (D1 >> 2);
#line 248
    B2 += ((((C2 << 5) | (C2 >> 27)) + ((D2 & (E2 | A2)) | (E2 & A2))) + W2[53]) + 2400959708U;
#line 248
    D2 = (D2 << 30) | (D2 >> 2);
#line 248
    A1 += ((((B1 << 5) | (B1 >> 27)) + ((C1 & (D1 | E1)) | (D1 & E1))) + W1[54]) + 2400959708U;
#line 248
    C1 = (C1 << 30) | (C1 >> 2);
#line 248
    A2 += ((((B2 << 5) | (B2 >> 27)) + ((C2 & (D2 | E2)) | (D2 & E2))) + W2[54]) + 2400959708U;
#line 248
    C2 = (C2 << 30) | (C2 >> 2);
#line 249
    E1 += ((((A1 << 5) | (A1 >> 27)) + ((B1 & (C1 | D1)) | (C1 & D1))) + W1[55]) + 2400959708U;
#line 249
    B1 = (B1 << 30) | (B1 >> 2);
#line 249
    E2 += ((((A2 << 5) | (A2 >> 27)) + ((B2 & (C2 | D2)) | (C2 & D2))) + W2[55]) + 2400959708U;
#line 249
    B2 = (B2 << 30) | (B2 >> 2);
#line 249
    D1 += ((((E1 << 5) | (E1 >> 27)) + ((A1 & (B1 | C1)) | (B1 & C1))) + W1[56]) + 2400959708U;
#line 249
    A1 = (A1 << 30) | (A1 >> 2);
#line 249
    D2 += ((((E2 << 5) | (E2 >> 27)) + ((A2 & (B2 | C2)) | (B2 & C2))) + W2[56]) + 2400959708U;
#line 249
    A2 = (A2 << 30) | (A2 >> 2);
#line 249
    C1 += ((((D1 << 5) | (D1 >> 27)) + ((E1 & (A1 | B1)) | (A1 & B1))) + W1[57]) + 2400959708U;
#line 249
    E1 = (E1 << 30) | (E1 >> 2);
#line 249
    C2 += ((((D2 << 5) | (D2 >> 27)) + ((E2 & (A2 | B2)) | (A2 & B2))) + W2[57]) + 2400959708U;
#line 249
    E2 = (E2 << 30) | (E2 >> 2);
#line 249
    B1 += ((((C1 << 5) | (C1 >> 27)) + ((D1 & (E1 | A1)) | (E1 & A1))) + W1[58]) + 2400959708U;
#line 249
    D1 = (D1 << 30) | (D1 >> 2);
#line 249
    B2 += ((((C2 << 5) | (C2 >> 27)) + ((D2 & (E2 | A2)) | (E2 & A2))) + W2[58]) + 2400959708U;
#line 249
    D2 = (D2 << 30) | (D2 >> 2);
#line 249
    A1 += ((((B1 << 5) | (B1 >> 27)) + ((C1 & (D1 | E1)) | (D1 & E1))) + W1[59]) + 2400959708U;
#line 249
    C1 = (C1 << 30) | (C1 >> 2);
#line 249
    A2 += ((((B2 << 5) | (B2 >> 27)) + ((C2 & (D2 | E2)) | (D2 & E2))) + W2[59]) + 2400959708U;
#line 249
    C2 = (C2 << 30) | (C2 >> 2);
#line 251
    E1 += ((((A1 << 5) | (A1 >> 27)) + ((B1 ^ C1) ^ D1)) + W1[60]) + 3395469782U;
#line 251
    B1 = (B1 << 30) | (B1 >> 2);
#line 251
    E2 += ((((A2 << 5) | (A2 >> 27)) + ((B2 ^ C2) ^ D2)) + W2[60]) + 3395469782U;
#line 251
    B2 = (B2 << 30) | (B2 >> 2);
#line 251
    D1 += ((((E1 << 5) | (E1 >> 27)) + ((A1 ^ B1) ^ C1)) + W1[61]) + 3395469782U;
#line 251
    A1 = (A1 << 30) | (A1 >> 2);
#line 251
    D2 += ((((E2 << 5) | (E2 >> 27)) + ((A2 ^ B2) ^ C2)) + W2[61]) + 3395469782U;
#line 251
    A2 = (A2 << 30) | (A2 >> 2);
#line 251
    C1 += ((((D1 << 5) | (D1 >> 27)) + ((E1 ^ A1) ^ B1)) + W1[62]) + 3395469782U;
#line 251
    E1 = (E1 << 30) | (E1 >> 2);
#line 251
    C2 += ((((D2 << 5) | (D2 >> 27)) + ((E2 ^ A2) ^ B2)) + W2[62]) + 3395469782U;
#line 251
    E2 = (E2 << 30) | (E2 >> 2);
#line 251
    B1 += ((((C1 << 5) | (C1 >> 27)) + ((D1 ^ E1) ^ A1)) + W1[63]) + 3395469782U;
#line 251
    D1 = (D1 << 30) | (D1 >> 2);
#line 251
    B2 += ((((C2 << 5) | (C2 >> 27)) + ((D2 ^ E2) ^ A2)) + W2[63]) + 3395469782U;
#line 251
    D2 = (D2 << 30) | (D2 >> 2);
#line 251
    A1 += ((((B1 << 5) | (B1 >> 27)) + ((C1 ^ D1) ^ E1)) + W1[64]) + 3395469782U;
#line 251
    C1 = (C1 << 30) | (C1 >> 2);
#line 251
    A2 += ((((B2 << 5) | (B2 >> 27)) + ((C2 ^ D2) ^ E2)) + W2[64]) + 3395469782U;
#line 251
    C2 = (C2 << 30) | (C2 >> 2);
#line 252
    E1 += ((((A1 << 5) | (A1 >> 27)) + ((B1 ^ C1) ^ D1)) + W1[65]) + 3395469782U;
#line 252
    B1 = (B1 << 30) | (B1 >> 2);
#line 252
    E2 += ((((A2 << 5) | (A2 >> 27)) + ((B2 ^ C2) ^ D2)) + W2[65]) + 3395469782U;
#line 252
    B2 = (B2 << 30) | (B2 >> 2);
#line 252
    D1 += ((((E1 << 5) | (E1 >> 27)) + ((A1 ^ B1) ^ C1)) + W1[66]) + 3395469782U;
#line 252
    A1 = (A1 << 30) | (A1 >> 2);
#line 252
    D2 += ((((E2 << 5) | (E2 >> 27)) + ((A2 ^ B2) ^ C2)) + W2[66]) + 3395469782U;
#line 252
    A2 = (A2 << 30) | (A2 >> 2);
#line 252
    C1 += ((((D1 << 5) | (D1 >> 27)) + ((E1 ^ A1) ^ B1)) + W1[67]) + 3395469782U;
#line 252
    E1 = (E1 << 30) | (E1 >> 2);
#line 252
    C2 += ((((D2 << 5) | (D2 >> 27)) + ((E2 ^ A2) ^ B2)) + W2[67]) + 3395469782U;
#line 252
    E2 = (E2 << 30) | (E2 >> 2);
#line 252
    B1 += ((((C1 << 5) | (C1 >> 27)) + ((D1 ^ E1) ^ A1)) + W1[68]) + 3395469782U;
#line 252
    D1 = (D1 << 30) | (D1 >> 2);
#line 252
    B2 += ((((C2 << 5) | (C2 >> 27)) + ((D2 ^ E2) ^ A2)) + W2[68]) + 3395469782U;
#line 252
    D2 = (D2 << 30) | (D2 >> 2);
#line 252
    A1 += ((((B1 << 5) | (B1 >> 27)) + ((C1 ^ D1) ^ E1)) + W1[69]) + 3395469782U;
#line 252
    C1 = (C1 << 30) | (C1 >> 2);
#line 252
    A2 += ((((B2 << 5) | (B2 >> 27)) + ((C2 ^ D2) ^ E2)) + W2[69]) + 3395469782U;
#line 252
    C2 = (C2 << 30) | (C2 >> 2);
#line 253
    E1 += ((((A1 << 5) | (A1 >> 27)) + ((B1 ^ C1) ^ D1)) + W1[70]) + 3395469782U;
#line 253
    B1 = (B1 << 30) | (B1 >> 2);
#line 253
    E2 += ((((A2 << 5) | (A2 >> 27)) + ((B2 ^ C2) ^ D2)) + W2[70]) + 3395469782U;
#line 253
    B2 = (B2 << 30) | (B2 >> 2);
#line 253
    D1 += ((((E1 << 5) | (E1 >> 27)) + ((A1 ^ B1) ^ C1)) + W1[71]) + 3395469782U;
#line 253
    A1 = (A1 << 30) | (A1 >> 2);
#line 253
    D2 += ((((E2 << 5) | (E2 >> 27)) + ((A2 ^ B2) ^ C2)) + W2[71]) + 3395469782U;
#line 253
    A2 = (A2 << 30) | (A2 >> 2);
#line 253
    C1 += ((((D1 << 5) | (D1 >> 27)) + ((E1 ^ A1) ^ B1)) + W1[72]) + 3395469782U;
#line 253
    E1 = (E1 << 30) | (E1 >> 2);
#line 253
    C2 += ((((D2 << 5) | (D2 >> 27)) + ((E2 ^ A2) ^ B2)) + W2[72]) + 3395469782U;
#line 253
    E2 = (E2 << 30) | (E2 >> 2);
#line 253
    B1 += ((((C1 << 5) | (C1 >> 27)) + ((D1 ^ E1) ^ A1)) + W1[73]) + 3395469782U;
#line 253
    D1 = (D1 << 30) | (D1 >> 2);
#line 253
    B2 += ((((C2 << 5) | (C2 >> 27)) + ((D2 ^ E2) ^ A2)) + W2[73]) + 3395469782U;
#line 253
    D2 = (D2 << 30) | (D2 >> 2);
#line 253
    A1 += ((((B1 << 5) | (B1 >> 27)) + ((C1 ^ D1) ^ E1)) + W1[74]) + 3395469782U;
#line 253
    C1 = (C1 << 30) | (C1 >> 2);
#line 253
    A2 += ((((B2 << 5) | (B2 >> 27)) + ((C2 ^ D2) ^ E2)) + W2[74]) + 3395469782U;
#line 253
    C2 = (C2 << 30) | (C2 >> 2);
#line 254
    E1 += ((((A1 << 5) | (A1 >> 27)) + ((B1 ^ C1) ^ D1)) + W1[75]) + 3395469782U;
#line 254
    B1 = (B1 << 30) | (B1 >> 2);
#line 254
    E2 += ((((A2 << 5) | (A2 >> 27)) + ((B2 ^ C2) ^ D2)) + W2[75]) + 3395469782U;
#line 254
    B2 = (B2 << 30) | (B2 >> 2);
#line 254
    D1 += ((((E1 << 5) | (E1 >> 27)) + ((A1 ^ B1) ^ C1)) + W1[76]) + 3395469782U;
#line 254
    A1 = (A1 << 30) | (A1 >> 2);
#line 254
    D2 += ((((E2 << 5) | (E2 >> 27)) + ((A2 ^ B2) ^ C2)) + W2[76]) + 3395469782U;
#line 254
    A2 = (A2 << 30) | (A2 >> 2);
#line 254
    C1 += ((((D1 << 5) | (D1 >> 27)) + ((E1 ^ A1) ^ B1)) + W1[77]) + 3395469782U;
#line 254
    E1 = (E1 << 30) | (E1 >> 2);
#line 254
    C2 += ((((D2 << 5) | (D2 >> 27)) + ((E2 ^ A2) ^ B2)) + W2[77]) + 3395469782U;
#line 254
    E2 = (E2 << 30) | (E2 >> 2);
#line 254
    B1 += ((((C1 << 5) | (C1 >> 27)) + ((D1 ^ E1) ^ A1)) + W1[78]) + 3395469782U;
#line 254
    D1 = (D1 << 30) | (D1 >> 2);
#line 254
    B2 += ((((C2 << 5) | (C2 >> 27)) + ((D2 ^ E2) ^ A2)) + W2[78]) + 3395469782U;
#line 254
    D2 = (D2 << 30) | (D2 >> 2);
#line 254
    A1 += ((((B1 << 5) | (B1 >> 27)) + ((C1 ^ D1) ^ E1)) + W1[79]) + 3395469782U;
#line 254
    C1 = (C1 << 30) | (C1 >> 2);
#line 254
    A2 += ((((B2 << 5) | (B2 >> 27)) + ((C2 ^ D2) ^ E2)) + W2[79]) + 3395469782U;
#line 254
    C2 = (C2 << 30) | (C2 >> 2);
#line 257
    A1 += H[0];
#line 258
    B1 += H[1];
#line 260
    A2 += H[0];
#line 261
    B2 += H[1];
#line 278
    if (A1 < A2) {
#line 279
      n = 0;
    } else
#line 280
    if (A1 > A2) {
#line 281
      n = 1;
    } else
#line 282
    if (B1 < B2) {
#line 283
      n = 0;
    } else {
#line 285
      n = 1;
    }
    {
#line 288
    if (n == 0) {
#line 288
      goto case_0;
    }
#line 294
    if (n == 1) {
#line 294
      goto case_1;
    }
#line 287
    goto switch_break___1;
    case_0: /* CIL Label */ 
#line 289
    A = A1;
#line 290
    B = B1;
#line 291
    W = W1;
#line 292
    goto switch_break___1;
    case_1: /* CIL Label */ 
#line 295
    A = A2;
#line 296
    B = B2;
#line 297
    W = W2;
#line 298
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 302
    if (! (A & bitMask1Low)) {
#line 302
      if (! (B & bitMask1High)) {
#line 304
        gotBits = 0;
#line 305
        if (A) {
#line 306
          s = A;
          {
#line 307
          while (1) {
            while_continue___13: /* CIL Label */ ;
#line 307
            if (! (! (s & 2147483648U))) {
#line 307
              goto while_break___13;
            }
#line 308
            s <<= 1;
#line 309
            gotBits ++;
          }
          while_break___13: /* CIL Label */ ;
          }
        } else {
#line 312
          gotBits = 32;
#line 313
          if (B) {
#line 314
            s = B;
            {
#line 315
            while (1) {
              while_continue___14: /* CIL Label */ ;
#line 315
              if (! (! (s & 2147483648U))) {
#line 315
                goto while_break___14;
              }
#line 316
              s <<= 1;
#line 317
              gotBits ++;
            }
            while_break___14: /* CIL Label */ ;
            }
          } else {
#line 320
            gotBits = 64;
          }
        }
#line 324
        *best = gotBits;
#line 326
        maxBits = gotBits + 1;
#line 327
        if (maxBits < 32) {
#line 328
          bitMask1Low = ~ ((1U << (32 - maxBits)) - 1U);
#line 329
          bitMask1High = (uInt32 )0;
        } else {
#line 331
          bitMask1Low = (uInt32 )(~ 0);
#line 332
          bitMask1High = ~ ((1U << (64 - maxBits)) - 1U);
        }
#line 336
        t = 0;
        {
#line 336
        while (1) {
          while_continue___15: /* CIL Label */ ;
#line 336
          if (! (t < 16)) {
#line 336
            goto while_break___15;
          }
#line 337
          *((output + t * 4) + 0) = (unsigned char )((*(W + t) >> 24) & 255U);
#line 337
          *((output + t * 4) + 1) = (unsigned char )((*(W + t) >> 16) & 255U);
#line 337
          *((output + t * 4) + 2) = (unsigned char )((*(W + t) >> 8) & 255U);
#line 337
          *((output + t * 4) + 3) = (unsigned char )(*(W + t) & 255U);
#line 336
          t ++;
        }
        while_break___15: /* CIL Label */ ;
        }
#line 340
        if (gotBits >= bits) {
#line 341
          return (iters + 2UL);
        }
      }
    }
    {
#line 346
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 346
      if ((unsigned long )cb != (unsigned long )((void *)0)) {
#line 346
        if ((iters & 65535UL) == 0UL) {
          {
#line 346
          gettimeofday((struct timeval */* __restrict  */)(& curr), (__timezone_ptr_t )((void *)0));
          }
#line 346
          if (gotBits > lastBits) {
#line 346
            goto _L___1;
          } else
#line 346
          if (curr.tv_sec - prev.tv_sec > 1L) {
#line 346
            goto _L___1;
          } else {
#line 346
            if (curr.tv_sec - prev.tv_sec) {
#line 346
              tmp___13 = 1000000;
            } else {
#line 346
              tmp___13 = 0;
            }
#line 346
            if ((curr.tv_usec + (__suseconds_t )tmp___13) - prev.tv_usec > 100000L) {
              _L___1: /* CIL Label */ 
              {
#line 346
              percent = (double )((int )(((counter + (double )iters) / expected) * (double )100 + 0.5));
#line 346
              tmp___12 = (*cb)((int )percent, *best, bits, counter + (double )iters,
                               expected, user_args);
              }
#line 346
              if (! tmp___12) {
#line 346
                *best = -1;
#line 346
                return (0UL);
              }
#line 346
              prev = curr;
#line 346
              lastBits = gotBits;
            }
          }
        }
      }
#line 346
      goto while_break___16;
    }
    while_break___16: /* CIL Label */ ;
    }
#line 153
    iters += 2UL;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 349
  return (iters + 2UL);
}
}
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 200 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libfastmint.h"
int minter_library_test(void) ;
#line 202
unsigned long minter_library(int bits , int *best , unsigned char *block , uInt32 const   *IV ,
                             int tailIndex , unsigned long maxIter , int (*cb)(int percent ,
                                                                               int largest ,
                                                                               int target ,
                                                                               double count ,
                                                                               double expected ,
                                                                               void *user ) ,
                             void *user_args , double counter , double expected ) ;
#line 4 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/fastmint_library.c"
int minter_library_test(void) 
{ 


  {
#line 7
  return (1);
}
}
#line 19 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/fastmint_library.c"
static int const   endTest___0  =    (int const   )3;
#line 69
void SHA1_Transform(unsigned int *H , unsigned char const   *M ) ;
#line 10 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/fastmint_library.c"
unsigned long minter_library(int bits , int *best , unsigned char *block , uInt32 const   *IV ,
                             int tailIndex , unsigned long maxIter , int (*cb)(int percent ,
                                                                               int largest ,
                                                                               int target ,
                                                                               double count ,
                                                                               double expected ,
                                                                               void *user ) ,
                             void *user_args , double counter , double expected ) 
{ 
  double percent ;
  struct timeval prev ;
  struct timeval curr ;
  int lastBits ;
  unsigned long iters ;
  int t ;
  int gotBits ;
  int maxBits ;
  int tmp ;
  uInt32 bitMask1Low ;
  uInt32 bitMask1High ;
  uInt32 s ;
  char const   *p ;
  uInt32 A ;
  uInt32 B ;
  int addressMask ;
  unsigned char *output ;
  unsigned char Xa[128] ;
  unsigned char *X ;
  uInt32 *W ;
  uInt32 H[5] ;
  int blocks ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 12
  prev.tv_sec = (__time_t )0;
#line 12
  prev.tv_usec = (__suseconds_t )0;
#line 12
  lastBits = 0;
#line 13
  iters = 0UL;
#line 14
  t = 0;
#line 14
  gotBits = 0;
#line 14
  if (bits > 16) {
#line 14
    tmp = 16;
  } else {
#line 14
    tmp = bits;
  }
#line 14
  maxBits = tmp;
#line 15
  bitMask1Low = (uInt32 )0;
#line 15
  bitMask1High = (uInt32 )0;
#line 15
  s = (uInt32 )0;
#line 16
  p = encodeAlphabets[4];
#line 17
  A = (uInt32 )0;
#line 17
  B = (uInt32 )0;
#line 18
  addressMask = 0;
#line 20
  output = block;
#line 22
  X = Xa;
#line 23
  W = (uInt32 *)(Xa);
#line 25
  if ((tailIndex + 1) + 8 > 64) {
#line 25
    tmp___0 = 2;
  } else {
#line 25
    tmp___0 = 1;
  }
#line 25
  blocks = tmp___0;
#line 27
  *best = 0;
#line 30
  addressMask = (int )*((char *)(& endTest___0));
#line 32
  t = 0;
  {
#line 32
  while (1) {
    while_continue: /* CIL Label */ ;
#line 32
    if (! (t < 16 * blocks)) {
#line 32
      goto while_break;
    }
#line 32
    *(W + t) = (uInt32 )(((((int )*((output + t * 4) + 0) << 24) | ((int )*((output + t * 4) + 1) << 16)) | ((int )*((output + t * 4) + 2) << 8)) | (int )*((output + t * 4) + 3));
#line 32
    t ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 35
  if (maxBits < 32) {
#line 36
    if (bits == 0) {
#line 36
      bitMask1Low = (uInt32 )0;
    } else {
#line 37
      bitMask1Low = ~ ((1U << (32 - maxBits)) - 1U);
    }
#line 39
    bitMask1High = (uInt32 )0;
  } else {
#line 41
    bitMask1Low = (uInt32 )(~ 0);
#line 42
    bitMask1High = ~ ((1U << (64 - maxBits)) - 1U);
  }
#line 44
  maxBits = 0;
#line 47
  iters = 0UL;
  {
#line 47
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 47
    if (! (iters < maxIter)) {
#line 47
      goto while_break___0;
    }
#line 49
    *(X + ((tailIndex - 1) ^ addressMask)) = (unsigned char )*(p + (iters & 63UL));
#line 50
    if (! (iters & 63UL)) {
#line 51
      if (iters >> 6) {
#line 52
        *(X + ((tailIndex - 2) ^ addressMask)) = (unsigned char )*(p + ((iters >> 6) & 63UL));
      }
#line 54
      if (iters >> 12) {
#line 55
        *(X + ((tailIndex - 3) ^ addressMask)) = (unsigned char )*(p + ((iters >> 12) & 63UL));
      }
#line 57
      if (iters >> 18) {
#line 58
        *(X + ((tailIndex - 4) ^ addressMask)) = (unsigned char )*(p + ((iters >> 18) & 63UL));
      }
#line 60
      if (iters >> 24) {
#line 61
        *(X + ((tailIndex - 5) ^ addressMask)) = (unsigned char )*(p + ((iters >> 24) & 63UL));
      }
#line 63
      if (iters >> 30) {
#line 64
        *(X + ((tailIndex - 6) ^ addressMask)) = (unsigned char )*(p + ((iters >> 30) & 63UL));
      }
    }
    {
#line 68
    memcpy((void */* __restrict  */)(H), (void const   */* __restrict  */)IV, (size_t )20);
#line 69
    SHA1_Transform(H, X);
    }
#line 70
    if (blocks == 2) {
      {
#line 71
      SHA1_Transform(H, X + 64);
      }
    }
#line 74
    A = H[0];
#line 75
    B = H[1];
#line 78
    if (! (A & bitMask1Low)) {
#line 78
      if (! (B & bitMask1High)) {
#line 80
        gotBits = 0;
#line 81
        if (A) {
#line 82
          s = A;
          {
#line 83
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 83
            if (! (! (s & 2147483648U))) {
#line 83
              goto while_break___1;
            }
#line 84
            s <<= 1;
#line 85
            gotBits ++;
          }
          while_break___1: /* CIL Label */ ;
          }
        } else {
#line 88
          gotBits = 32;
#line 89
          if (B) {
#line 90
            s = B;
            {
#line 91
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 91
              if (! (! (s & 2147483648U))) {
#line 91
                goto while_break___2;
              }
#line 92
              s <<= 1;
#line 93
              gotBits ++;
            }
            while_break___2: /* CIL Label */ ;
            }
          } else {
#line 96
            gotBits = 64;
          }
        }
#line 100
        *best = gotBits;
#line 102
        maxBits = gotBits + 1;
#line 103
        if (maxBits < 32) {
#line 104
          bitMask1Low = ~ ((1U << (32 - maxBits)) - 1U);
#line 105
          bitMask1High = (uInt32 )0;
        } else {
#line 107
          bitMask1Low = (uInt32 )(~ 0);
#line 108
          bitMask1High = ~ ((1U << (64 - maxBits)) - 1U);
        }
#line 112
        t = 0;
        {
#line 112
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 112
          if (! (t < 16 * blocks)) {
#line 112
            goto while_break___3;
          }
#line 113
          *((output + t * 4) + 0) = (unsigned char )((*(W + t) >> 24) & 255U);
#line 113
          *((output + t * 4) + 1) = (unsigned char )((*(W + t) >> 16) & 255U);
#line 113
          *((output + t * 4) + 2) = (unsigned char )((*(W + t) >> 8) & 255U);
#line 113
          *((output + t * 4) + 3) = (unsigned char )(*(W + t) & 255U);
#line 112
          t ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 117
        if (gotBits >= bits) {
#line 118
          return (iters + 1UL);
        }
      }
    }
    {
#line 121
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 121
      if ((unsigned long )cb != (unsigned long )((void *)0)) {
#line 121
        if ((iters & 65535UL) == 0UL) {
          {
#line 121
          gettimeofday((struct timeval */* __restrict  */)(& curr), (__timezone_ptr_t )((void *)0));
          }
#line 121
          if (gotBits > lastBits) {
#line 121
            goto _L___0;
          } else
#line 121
          if (curr.tv_sec - prev.tv_sec > 1L) {
#line 121
            goto _L___0;
          } else {
#line 121
            if (curr.tv_sec - prev.tv_sec) {
#line 121
              tmp___2 = 1000000;
            } else {
#line 121
              tmp___2 = 0;
            }
#line 121
            if ((curr.tv_usec + (__suseconds_t )tmp___2) - prev.tv_usec > 100000L) {
              _L___0: /* CIL Label */ 
              {
#line 121
              percent = (double )((int )(((counter + (double )iters) / expected) * (double )100 + 0.5));
#line 121
              tmp___1 = (*cb)((int )percent, *best, bits, counter + (double )iters,
                              expected, user_args);
              }
#line 121
              if (! tmp___1) {
#line 121
                *best = -1;
#line 121
                return (0UL);
              }
#line 121
              prev = curr;
#line 121
              lastBits = gotBits;
            }
          }
        }
      }
#line 121
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 47
    iters ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 124
  return (iters + 1UL);
}
}
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 140
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 289
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strspn)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 239
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) gmtime)(time_t const   *__timer ) ;
#line 573 "/usr/include/regex.h"
extern int regcomp(regex_t * __restrict  __preg , char const   * __restrict  __pattern ,
                   int __cflags ) ;
#line 577
extern int regexec(regex_t const   * __restrict  __preg , char const   * __restrict  __string ,
                   size_t __nmatch , regmatch_t * __restrict  __pmatch , int __eflags ) ;
#line 582
extern size_t regerror(int __errcode , regex_t const   * __restrict  __preg , char * __restrict  __errbuf ,
                       size_t __errbuf_size ) ;
#line 83 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/hashcash.h"
char const   *hashcash_version(void) ;
#line 143
int hashcash_mint(time_t now_time , int time_width , char const   *resource , unsigned int bits ,
                  long anon_period , char **new_token , long *anon_random , double *tries_taken ,
                  char *ext , int compress , int (*cb)(int percent , int largest ,
                                                       int target , double count ,
                                                       double expected , void *user ) ,
                  void *user_arg ) ;
#line 151
char *hashcash_simple_mint(char const   *resource , unsigned int bits , long anon_period ,
                           char *ext , int compress ) ;
#line 169
char *hashcash_make_header(char const   *stamp , int line_len , char const   *header ,
                           char cont , char const   *lf ) ;
#line 180
int hashcash_validity_to_width(long validity_period ) ;
#line 185
unsigned int hashcash_count(char const   *token ) ;
#line 210
int hashcash_parse(char const   *token , int *vers , int *bits , char *utct , int utct_max ,
                   char *token_resource , int res_max , char **ext , int ext_max ) ;
#line 229
long hashcash_valid_for(time_t token_time , long validity_period , long grace_period ,
                        time_t now_time ) ;
#line 271
int hashcash_check(char const   *token , int case_flag , char const   *resource ,
                   void **compile , char **re_err___0 , int type , time_t now_time ,
                   long validity_period , long grace_period , int required_bits ,
                   time_t *token_time ) ;
#line 279
unsigned long hashcash_per_sec(void) ;
#line 284
double hashcash_estimate_time(int b ) ;
#line 290
double hashcash_expected_tries(int b ) ;
#line 319
int hashcash_resource_match(int type , char const   *token_res , char const   *res ,
                            void **compile , char **err ) ;
#line 332
void hashcash_free(void *ptr ) ;
#line 353
extern time_t hashcash_from_utctimestr(char const   *utct , int utc ) ;
#line 368
extern int hashcash_to_utctimestr(char *utct , int len , time_t t ) ;
#line 23 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/utct.h"
extern time_t mk_utctime(struct tm *tms ) ;
#line 119 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libfastmint.h"
double hashcash_fastmint(int const   bits , char const   *token , int compress , char **result ,
                         int (*cb)(int percent , int largest , int target , double count ,
                                   double expected , void *user ) , void *user_args ) ;
#line 53 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/sha1.h"
void SHA1_Init(SHA1_ctx *ctx ) ;
#line 54
void SHA1_Update(SHA1_ctx *ctx , void const   *pdata , size_t data_len ) ;
#line 55
void SHA1_Final(SHA1_ctx *ctx , unsigned char *digest ) ;
#line 17 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/random.h"
extern int random_rectangular(long top , long *resp ) ;
#line 5 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/sstring.h"
extern char *sstrtok(char const   *str , char const   *delim , char **tok , int tok_max ,
                     int *tok_len , char **s ) ;
#line 8
extern void stolower(char *str ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libhc.c"
time_t round_off(time_t now_time , int digits ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libhc.c"
long per_sec  =    0L;
#line 44 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libhc.c"
char *strrstr(char *s1 , char *s2 ) 
{ 
  char *sc2 ;
  char *psc1 ;
  char *ps1 ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 46
  sc2 = (char *)((void *)0);
#line 46
  psc1 = (char *)((void *)0);
#line 46
  ps1 = (char *)((void *)0);
#line 48
  if ((int )*s2 == 0) {
#line 48
    return (s1);
  }
  {
#line 49
  tmp = strlen((char const   *)s1);
#line 49
  ps1 = s1 + tmp;
  }
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
#line 51
    if (! ((unsigned long )ps1 != (unsigned long )s1)) {
#line 51
      goto while_break;
    }
#line 52
    ps1 --;
#line 53
    psc1 = ps1;
#line 53
    sc2 = s2;
    {
#line 53
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 54
      tmp___0 = psc1;
#line 54
      psc1 ++;
#line 54
      tmp___1 = sc2;
#line 54
      sc2 ++;
#line 54
      if ((int )*tmp___0 != (int )*tmp___1) {
#line 54
        goto while_break___0;
      } else
#line 55
      if ((int )*sc2 == 0) {
#line 55
        return (ps1);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 58
  return ((char *)((void *)0));
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libhc.c"
int wild_match(char *pat , char *str ) 
{ 
  int num ;
  int last ;
  int first ;
  char *term ;
  char *ptr ;
  char *pos ;
  size_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 63
  num = 1;
#line 63
  last = 0;
#line 63
  first = 1;
#line 64
  term = (char *)((void *)0);
#line 64
  ptr = pat;
#line 64
  pos = str;
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 67
    term = ptr;
#line 67
    ptr = strchr((char const   *)ptr, '*');
    }
#line 68
    if (ptr) {
#line 68
      *ptr = (char )'\000';
#line 68
      ptr ++;
    } else {
#line 69
      last = 1;
    }
#line 71
    if ((int )*term != 0) {
#line 72
      if (first) {
        {
#line 73
        tmp = strlen((char const   *)term);
#line 73
        tmp___0 = strncmp((char const   *)pos, (char const   *)term, tmp);
        }
#line 73
        if (tmp___0 != 0) {
#line 74
          return (0);
        }
        {
#line 76
        tmp___1 = strlen((char const   *)term);
#line 76
        pos += tmp___1;
        }
      } else
#line 77
      if (! first) {
#line 78
        if (last) {
          {
#line 79
          pos = strrstr(pos, term);
          }
        } else {
          {
#line 81
          pos = strstr((char const   *)pos, (char const   *)term);
          }
        }
#line 83
        if ((unsigned long )pos == (unsigned long )((char *)0)) {
#line 83
          return (0);
        }
        {
#line 84
        tmp___2 = strlen((char const   *)term);
#line 84
        pos += tmp___2;
        }
      }
#line 86
      if (last) {
#line 86
        if ((int )*pos != 0) {
#line 87
          return (0);
        }
      }
    }
#line 91
    num ++;
#line 91
    first = 0;
#line 66
    if (term) {
#line 66
      if (! (! last)) {
#line 66
        goto while_break;
      }
    } else {
#line 66
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 94
  return (1);
}
}
#line 97 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libhc.c"
int email_match(char const   *email , char const   *pattern ) 
{ 
  int len ;
  int ret ;
  char *pat_user ;
  char *pat_dom ;
  char *em_user ;
  char *em_dom ;
  char *pat_sub ;
  char *em_sub ;
  char *pat_next ;
  char *em_next ;
  char *state ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 99
  len = 0;
#line 99
  ret = 0;
#line 100
  pat_user = (char *)((void *)0);
#line 100
  pat_dom = (char *)((void *)0);
#line 101
  em_user = (char *)((void *)0);
#line 101
  em_dom = (char *)((void *)0);
#line 102
  pat_sub = (char *)((void *)0);
#line 102
  em_sub = (char *)((void *)0);
#line 102
  pat_next = (char *)((void *)0);
#line 102
  em_next = (char *)((void *)0);
#line 102
  state = (char *)((void *)0);
#line 104
  sstrtok(pattern, "@", & pat_user, 0, & len, & state);
#line 105
  sstrtok((char const   *)((void *)0), "@", & pat_dom, 0, & len, & state);
#line 107
  sstrtok(email, "@", & em_user, 0, & len, & state);
#line 108
  sstrtok((char const   *)((void *)0), "@", & em_dom, 0, & len, & state);
  }
#line 111
  if (pat_dom) {
#line 111
    if ((unsigned long )em_dom == (unsigned long )((void *)0)) {
#line 111
      goto done;
    }
  }
  {
#line 113
  tmp = wild_match(pat_user, em_user);
  }
#line 113
  if (! tmp) {
#line 113
    goto done;
  }
#line 115
  if (! pat_dom) {
#line 115
    if (! em_dom) {
#line 115
      ret = 1;
#line 115
      goto done;
    }
  }
#line 117
  pat_next = pat_dom;
#line 117
  em_next = em_dom;
  {
#line 118
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 119
    pat_sub = pat_next;
#line 119
    em_sub = em_next;
#line 120
    pat_next = strchr((char const   *)pat_next, '.');
    }
#line 121
    if (pat_next) {
#line 121
      *pat_next = (char )'\000';
#line 121
      pat_next ++;
    }
    {
#line 122
    em_next = strchr((char const   *)em_next, '.');
    }
#line 123
    if (em_next) {
#line 123
      *em_next = (char )'\000';
#line 123
      em_next ++;
    }
    {
#line 125
    tmp___0 = wild_match(pat_sub, em_sub);
    }
#line 125
    if (! tmp___0) {
#line 125
      goto done;
    }
#line 118
    if (pat_next) {
#line 118
      if (! em_next) {
#line 118
        goto while_break;
      }
    } else {
#line 118
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 130
  if ((unsigned long )pat_next == (unsigned long )((void *)0)) {
#line 130
    if ((unsigned long )em_next != (unsigned long )((void *)0)) {
#line 131
      goto done;
    } else {
#line 130
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 130
  if ((unsigned long )pat_next != (unsigned long )((void *)0)) {
#line 130
    if ((unsigned long )em_next == (unsigned long )((void *)0)) {
#line 131
      goto done;
    }
  }
#line 133
  ret = 1;
  done: 
#line 135
  if (pat_user) {
    {
#line 135
    free((void *)pat_user);
    }
  }
#line 136
  if (pat_dom) {
    {
#line 136
    free((void *)pat_dom);
    }
  }
#line 137
  if (em_user) {
    {
#line 137
    free((void *)em_user);
    }
  }
#line 138
  if (em_dom) {
    {
#line 138
    free((void *)em_dom);
    }
  }
#line 139
  return (ret);
}
}
#line 142 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libhc.c"
char const   *hashcash_version(void) 
{ 


  {
#line 142
  return ("1.21");
}
}
#line 144 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libhc.c"
char *hashcash_simple_mint(char const   *resource , unsigned int bits , long anon_period ,
                           char *ext , int compress ) 
{ 
  time_t now_time ;
  time_t tmp ;
  char *stamp ;
  int ret ;
  int tmp___0 ;

  {
  {
#line 146
  tmp = time((time_t *)0);
#line 146
  now_time = tmp;
#line 147
  stamp = (char *)((void *)0);
#line 148
  tmp___0 = hashcash_mint(now_time, 6, resource, bits, anon_period, & stamp, (long *)((void *)0),
                          (double *)((void *)0), ext, compress, (int (*)(int percent ,
                                                                         int largest ,
                                                                         int target ,
                                                                         double count ,
                                                                         double expected ,
                                                                         void *user ))((void *)0),
                          (void *)0);
#line 148
  ret = tmp___0;
  }
#line 150
  if (ret != 1) {
#line 151
    return ((char *)((void *)0));
  }
#line 153
  return (stamp);
}
}
#line 156 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libhc.c"
int hashcash_mint(time_t now_time , int time_width , char const   *resource , unsigned int bits ,
                  long anon_period , char **new_token , long *anon_random , double *tries_taken ,
                  char *ext , int compress , int (*cb)(int percent , int largest ,
                                                       int target , double count ,
                                                       double expected , void *user ) ,
                  void *user_arg ) 
{ 
  long rnd ;
  char now_utime[14] ;
  unsigned int tmp ;
  char *token ;
  double taken ;
  int tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
#line 161
  rnd = 0L;
#line 162
  now_utime[0] = (char)0;
#line 162
  tmp = 1U;
  {
#line 162
  while (1) {
    while_continue: /* CIL Label */ ;
#line 162
    if (tmp >= 14U) {
#line 162
      goto while_break;
    }
#line 162
    now_utime[tmp] = (char)0;
#line 162
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 163
  token = (char *)0;
#line 166
  if ((unsigned long )resource == (unsigned long )((void *)0)) {
#line 167
    return (-7);
  }
#line 170
  if ((unsigned long )anon_random == (unsigned long )((void *)0)) {
#line 170
    anon_random = & rnd;
  }
#line 172
  *anon_random = 0L;
#line 174
  if (bits > 160U) {
#line 175
    return (-1);
  }
#line 178
  if (time_width == 0) {
#line 178
    time_width = 6;
  }
#line 180
  if (now_time < 0L) {
#line 181
    return (-3);
  }
#line 184
  if (anon_period != 0L) {
    {
#line 185
    tmp___0 = random_rectangular(anon_period, anon_random);
    }
#line 185
    if (! tmp___0) {
#line 186
      return (-2);
    }
  }
#line 190
  now_time += *anon_random;
#line 192
  if (time_width != 12) {
#line 192
    if (time_width != 10) {
#line 192
      if (time_width != 6) {
#line 193
        return (-8);
      }
    }
  }
  {
#line 196
  now_time = round_off(now_time, 12 - time_width);
#line 197
  hashcash_to_utctimestr((char *)(now_utime), time_width, now_time);
  }
#line 199
  if (! ext) {
#line 199
    ext = (char *)"";
  }
  {
#line 200
  tmp___1 = strlen((char const   *)ext);
#line 200
  tmp___2 = malloc((10771UL + tmp___1) + 1UL);
#line 200
  token = (char *)tmp___2;
  }
#line 201
  if ((unsigned long )token == (unsigned long )((void *)0)) {
#line 201
    return (-18);
  }
  {
#line 202
  sprintf((char */* __restrict  */)token, (char const   */* __restrict  */)"%d:%d:%s:%s:%s:",
          1, bits, now_utime, resource, ext);
#line 205
  taken = hashcash_fastmint((int const   )bits, (char const   *)token, compress, new_token,
                            cb, user_arg);
  }
#line 206
  if (taken < (double )0) {
    {
#line 207
    free((void *)token);
    }
#line 208
    return (-19);
  }
  {
#line 210
  free((void *)token);
  }
#line 212
  if (tries_taken) {
#line 212
    *tries_taken = taken;
  }
#line 214
  return (1);
}
}
#line 221 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libhc.c"
char *hashcash_make_header(char const   *stamp , int line_len , char const   *header ,
                           char cont , char const   *lf ) 
{ 
  int stamp_len ;
  size_t tmp ;
  int i ;
  int fstep ;
  int step ;
  int tstep ;
  int lf_len ;
  int stamp_left ;
  int lines ;
  int header_len ;
  int cont_len ;
  int max_res ;
  char *res ;
  char *resp ;
  char conts[2] ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 225
  tmp = strlen(stamp);
#line 225
  stamp_len = (int )tmp;
#line 226
  stamp_left = stamp_len;
  }
#line 231
  if ((unsigned long )header == (unsigned long )((void *)0)) {
#line 231
    header = "X-Hashcash";
  }
#line 232
  if ((int )cont == 0) {
#line 232
    cont = (char )'\t';
  }
#line 233
  if ((unsigned long )lf == (unsigned long )((void *)0)) {
#line 233
    lf = "\r\n";
  }
  {
#line 235
  tmp___0 = strlen(header);
#line 235
  header_len = (int )tmp___0;
  }
#line 236
  if ((int )cont == 9) {
#line 236
    cont_len = 8;
  } else {
#line 236
    cont_len = 1;
  }
  {
#line 237
  conts[0] = cont;
#line 238
  conts[1] = (char )'\000';
#line 240
  lines = ((stamp_len + header_len) + 2) / (line_len - cont_len) + 1;
#line 242
  tmp___1 = strlen(lf);
#line 242
  lf_len = (int )tmp___1;
#line 243
  max_res = lines * ((line_len + lf_len) + 1);
#line 244
  tmp___2 = malloc((size_t )(max_res + 1));
#line 244
  res = (char *)tmp___2;
#line 245
  *(res + 0) = (char )'\000';
#line 246
  resp = res;
#line 247
  strncat((char */* __restrict  */)resp, (char const   */* __restrict  */)header,
          (size_t )max_res);
#line 248
  resp += header_len;
#line 250
  fstep = line_len - header_len;
#line 251
  step = line_len - cont_len;
#line 253
  i = 0;
  }
  {
#line 253
  while (1) {
    while_continue: /* CIL Label */ ;
#line 253
    if (! (i < stamp_len)) {
#line 253
      goto while_break;
    }
#line 254
    if (i) {
#line 254
      tstep = step;
    } else {
#line 254
      tstep = fstep;
    }
#line 255
    if (tstep > stamp_left) {
#line 255
      tstep = stamp_left;
    }
#line 256
    if (i) {
      {
#line 256
      strncat((char */* __restrict  */)resp, (char const   */* __restrict  */)(conts),
              (size_t )1);
#line 256
      resp ++;
      }
    }
    {
#line 257
    strncat((char */* __restrict  */)resp, (char const   */* __restrict  */)stamp,
            (size_t )tstep);
#line 258
    resp += tstep;
#line 259
    strncat((char */* __restrict  */)resp, (char const   */* __restrict  */)lf, (size_t )lf_len);
#line 260
    resp += lf_len;
#line 261
    stamp_left -= tstep;
#line 253
    stamp += tstep;
#line 253
    i += tstep;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 263
  return (res);
}
}
#line 266 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libhc.c"
time_t round_off(time_t now_time , int digits ) 
{ 
  struct tm *now ;
  time_t tmp ;

  {
#line 268
  now = (struct tm *)((void *)0);
#line 270
  if (digits != 2) {
#line 270
    if (digits != 4) {
#line 270
      if (digits != 6) {
#line 270
        if (digits != 8) {
#line 270
          if (digits != 10) {
#line 272
            return (now_time);
          }
        }
      }
    }
  }
  {
#line 274
  now = gmtime((time_t const   *)(& now_time));
  }
  {
#line 277
  if (digits == 10) {
#line 277
    goto case_10;
  }
#line 278
  if (digits == 8) {
#line 278
    goto case_8;
  }
#line 279
  if (digits == 6) {
#line 279
    goto case_6;
  }
#line 280
  if (digits == 4) {
#line 280
    goto case_4;
  }
#line 281
  if (digits == 2) {
#line 281
    goto case_2;
  }
#line 276
  goto switch_break;
  case_10: /* CIL Label */ 
#line 277
  now->tm_mon = 0;
  case_8: /* CIL Label */ 
#line 278
  now->tm_mday = 1;
  case_6: /* CIL Label */ 
#line 279
  now->tm_hour = 0;
  case_4: /* CIL Label */ 
#line 280
  now->tm_min = 0;
  case_2: /* CIL Label */ 
#line 281
  now->tm_sec = 0;
  switch_break: /* CIL Label */ ;
  }
  {
#line 283
  tmp = mk_utctime(now);
  }
#line 283
  return (tmp);
}
}
#line 286 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libhc.c"
int hashcash_validity_to_width(long validity_period ) 
{ 
  int time_width ;

  {
#line 288
  time_width = 6;
#line 289
  if (validity_period < 0L) {
#line 289
    return (0);
  }
#line 290
  if (validity_period != 0L) {
#line 292
    if (validity_period < 120L) {
#line 292
      time_width = 12;
    } else
#line 293
    if (validity_period < 7200L) {
#line 293
      time_width = 10;
    } else {
#line 294
      time_width = 6;
    }
  }
#line 296
  return (time_width);
}
}
#line 310 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libhc.c"
int hashcash_parse(char const   *token , int *vers , int *bits , char *utct , int utct_max ,
                   char *token_resource , int res_max , char **ext , int ext_max ) 
{ 
  char ver_arr[3] ;
  unsigned int tmp ;
  char bits_arr[4] ;
  unsigned int tmp___0 ;
  char *bits_str ;
  char *ver ;
  char *rnd ;
  char *cnt ;
  char *state ;
  int ver_len ;
  int utct_len ;
  int res_len ;
  int bit_len ;
  int rnd_len ;
  int cnt_len ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;

  {
#line 314
  ver_arr[0] = (char)0;
#line 314
  tmp = 1U;
  {
#line 314
  while (1) {
    while_continue: /* CIL Label */ ;
#line 314
    if (tmp >= 3U) {
#line 314
      goto while_break;
    }
#line 314
    ver_arr[tmp] = (char)0;
#line 314
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 315
  bits_arr[0] = (char)0;
#line 315
  tmp___0 = 1U;
  {
#line 315
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 315
    if (tmp___0 >= 4U) {
#line 315
      goto while_break___0;
    }
#line 315
    bits_arr[tmp___0] = (char)0;
#line 315
    tmp___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 316
  bits_str = bits_arr;
#line 316
  ver = ver_arr;
#line 317
  rnd = (char *)((void *)0);
#line 317
  cnt = (char *)((void *)0);
#line 318
  state = (char *)((void *)0);
#line 319
  ver_len = 0;
#line 319
  utct_len = 0;
#line 319
  res_len = 0;
#line 319
  bit_len = 0;
#line 319
  rnd_len = 0;
#line 319
  cnt_len = 0;
#line 331
  if ((unsigned long )ext != (unsigned long )((void *)0)) {
#line 331
    *ext = (char *)((void *)0);
  }
  {
#line 332
  tmp___1 = sstrtok(token, ":", & ver, 2, & ver_len, & state);
  }
#line 332
  if (! tmp___1) {
#line 333
    return (0);
  }
  {
#line 335
  *vers = atoi((char const   *)ver);
  }
#line 335
  if (*vers < 0) {
#line 335
    return (0);
  }
#line 336
  if (*vers == 0) {
    {
#line 337
    *bits = -1;
#line 338
    tmp___2 = sstrtok((char const   *)((void *)0), ":", & utct, utct_max, & utct_len,
                      & state);
    }
#line 338
    if (tmp___2) {
      {
#line 338
      tmp___3 = sstrtok((char const   *)((void *)0), ":", & token_resource, res_max,
                        & res_len, & state);
      }
#line 338
      if (tmp___3) {
        {
#line 338
        tmp___4 = sstrtok((char const   *)((void *)0), ":", & rnd, 0, & rnd_len, & state);
        }
#line 338
        if (! tmp___4) {
#line 341
          return (0);
        }
      } else {
#line 341
        return (0);
      }
    } else {
#line 341
      return (0);
    }
  } else
#line 343
  if (*vers == 1) {
    {
#line 344
    tmp___5 = sstrtok((char const   *)((void *)0), ":", & bits_str, 3, & bit_len,
                      & state);
    }
#line 344
    if (tmp___5) {
      {
#line 344
      tmp___6 = sstrtok((char const   *)((void *)0), ":", & utct, utct_max, & utct_len,
                        & state);
      }
#line 344
      if (tmp___6) {
        {
#line 344
        tmp___7 = sstrtok((char const   *)((void *)0), ":", & token_resource, res_max,
                          & res_len, & state);
        }
#line 344
        if (tmp___7) {
          {
#line 344
          tmp___8 = sstrtok((char const   *)((void *)0), ":", ext, 0, & ext_max, & state);
          }
#line 344
          if (tmp___8) {
            {
#line 344
            tmp___9 = sstrtok((char const   *)((void *)0), ":", & rnd, 0, & rnd_len,
                              & state);
            }
#line 344
            if (tmp___9) {
              {
#line 344
              tmp___10 = sstrtok((char const   *)((void *)0), ":", & cnt, 0, & cnt_len,
                                 & state);
              }
#line 344
              if (! tmp___10) {
#line 350
                return (0);
              }
            } else {
#line 350
              return (0);
            }
          } else {
#line 350
            return (0);
          }
        } else {
#line 350
          return (0);
        }
      } else {
#line 350
        return (0);
      }
    } else {
#line 350
      return (0);
    }
    {
#line 352
    *bits = atoi((char const   *)bits_str);
    }
#line 352
    if (*bits < 0) {
#line 352
      return (0);
    }
    {
#line 353
    tmp___11 = strspn((char const   *)cnt, "/+0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz=");
    }
#line 353
    if (tmp___11 != (size_t )cnt_len) {
#line 353
      return (0);
    }
  }
#line 355
  if ((unsigned long )rnd == (unsigned long )((void *)0)) {
#line 355
    return (0);
  } else {
    {
#line 355
    tmp___12 = strspn((char const   *)rnd, "/+0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz=");
    }
#line 355
    if (tmp___12 != (size_t )rnd_len) {
#line 355
      return (0);
    }
  }
#line 356
  return (1);
}
}
#line 359 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libhc.c"
unsigned int hashcash_count(char const   *token ) 
{ 
  SHA1_ctx ctx ;
  unsigned char target_digest[20] ;
  unsigned int tmp ;
  unsigned char token_digest[20] ;
  unsigned int tmp___0 ;
  char ver[3] ;
  unsigned int tmp___1 ;
  int vers ;
  char *first_colon ;
  char *second_colon ;
  int ver_len ;
  int i ;
  int last ;
  int collision_bits ;
  size_t tmp___2 ;

  {
#line 362
  target_digest[0] = (unsigned char)0;
#line 362
  tmp = 1U;
  {
#line 362
  while (1) {
    while_continue: /* CIL Label */ ;
#line 362
    if (tmp >= 20U) {
#line 362
      goto while_break;
    }
#line 362
    target_digest[tmp] = (unsigned char)0;
#line 362
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 363
  token_digest[0] = (unsigned char)0;
#line 363
  tmp___0 = 1U;
  {
#line 363
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 363
    if (tmp___0 >= 20U) {
#line 363
      goto while_break___0;
    }
#line 363
    token_digest[tmp___0] = (unsigned char)0;
#line 363
    tmp___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 364
  ver[0] = (char)0;
#line 364
  tmp___1 = 1U;
  {
#line 364
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 364
    if (tmp___1 >= 3U) {
#line 364
      goto while_break___1;
    }
#line 364
    ver[tmp___1] = (char)0;
#line 364
    tmp___1 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 365
  vers = 0;
#line 366
  first_colon = (char *)((void *)0);
#line 367
  second_colon = (char *)((void *)0);
#line 368
  ver_len = 0;
#line 369
  i = 0;
#line 370
  last = 0;
#line 371
  collision_bits = 0;
#line 373
  first_colon = strchr(token, ':');
  }
#line 374
  if ((unsigned long )first_colon == (unsigned long )((void *)0)) {
#line 374
    return (0U);
  }
#line 375
  ver_len = (int )(first_colon - (char *)token);
#line 376
  if (ver_len > 2) {
#line 376
    return (0U);
  }
  {
#line 377
  ver[ver_len] = (char )'\000';
#line 377
  strncpy((char */* __restrict  */)(ver), (char const   */* __restrict  */)token,
          (size_t )ver_len);
#line 378
  vers = atoi((char const   *)(ver));
  }
#line 379
  if (vers < 0) {
#line 379
    return (0U);
  }
#line 380
  if (vers > 1) {
#line 380
    return (0U);
  }
  {
#line 381
  second_colon = strchr((char const   *)(first_colon + 1), ':');
  }
#line 382
  if ((unsigned long )second_colon == (unsigned long )((void *)0)) {
#line 382
    return (0U);
  }
  {
#line 384
  memset((void *)(target_digest), 0, (size_t )20);
#line 386
  SHA1_Init(& ctx);
#line 387
  tmp___2 = strlen(token);
#line 387
  SHA1_Update(& ctx, (void const   *)token, tmp___2);
#line 388
  SHA1_Final(& ctx, (unsigned char *)(token_digest));
#line 390
  i = 0;
  }
  {
#line 390
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 390
    if (i < 20) {
#line 390
      if (! ((int )token_digest[i] == (int )target_digest[i])) {
#line 390
        goto while_break___2;
      }
    } else {
#line 390
      goto while_break___2;
    }
#line 390
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 395
  last = i;
#line 396
  collision_bits = 8 * i;
#line 400
  i = 0;
  {
#line 400
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 400
    if (! (i < 8)) {
#line 400
      goto while_break___3;
    }
#line 402
    if ((((int )token_digest[last] >> (7 - i)) & 1) == (((int )target_digest[last] >> (7 - i)) & 1)) {
#line 404
      collision_bits ++;
    } else {
#line 406
      goto while_break___3;
    }
#line 400
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 409
  return ((unsigned int )collision_bits);
}
}
#line 412 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libhc.c"
long hashcash_valid_for(time_t token_time , long validity_period , long grace_period ,
                        time_t now_time ) 
{ 
  long expiry_time ;

  {
#line 415
  expiry_time = 0L;
#line 418
  if (validity_period == 0L) {
#line 418
    return (0L);
  }
#line 421
  if (token_time > now_time + grace_period) {
#line 422
    return (-9L);
  }
#line 425
  expiry_time = token_time + validity_period;
#line 426
  if (expiry_time + grace_period > now_time) {
#line 428
    return ((expiry_time + grace_period) - now_time);
  }
#line 430
  return (-10L);
}
}
#line 483
int regexp_match(char const   *str , char const   *regexp , void **compile , char **err ) ;
#line 483 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libhc.c"
static char re_err[257]  = {      (char)0};
#line 439 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libhc.c"
int regexp_match(char const   *str , char const   *regexp , void **compile , char **err ) 
{ 
  regex_t **comp ;
  int re_code ;
  char *bound_regexp ;
  int re_len ;
  int bre_len ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 479
  comp = (regex_t **)compile;
#line 480
  re_code = 0;
#line 481
  bound_regexp = (char *)((void *)0);
#line 482
  re_len = 0;
#line 482
  bre_len = 0;
#line 484
  re_err[0] = (char )'\000';
#line 485
  *err = (char *)((void *)0);
#line 487
  if ((unsigned long )*comp == (unsigned long )((void *)0)) {
    {
#line 488
    tmp = malloc(sizeof(regex_t ));
#line 488
    *comp = (regex_t *)tmp;
    }
#line 489
    if ((unsigned long )*comp == (unsigned long )((void *)0)) {
#line 489
      *err = (char *)"out of memory";
#line 489
      return (0);
    }
    {
#line 490
    tmp___0 = strlen(regexp);
#line 490
    re_len = (int )tmp___0;
#line 490
    bre_len = re_len;
    }
#line 491
    if ((int const   )*(regexp + 0) != 94) {
#line 491
      goto _L;
    } else
#line 491
    if ((int const   )*(regexp + (re_len - 1)) != 36) {
      _L: /* CIL Label */ 
      {
#line 492
      tmp___1 = malloc((size_t )(re_len + 3));
#line 492
      bound_regexp = (char *)tmp___1;
      }
#line 493
      if ((int const   )*(regexp + 0) != 94) {
        {
#line 494
        *(bound_regexp + 0) = (char )'^';
#line 495
        *((bound_regexp + 1) + re_len) = (char )'\000';
#line 495
        strncpy((char */* __restrict  */)(bound_regexp + 1), (char const   */* __restrict  */)regexp,
                (size_t )re_len);
#line 496
        bre_len ++;
        }
      } else {
        {
#line 498
        *(bound_regexp + re_len) = (char )'\000';
#line 498
        strncpy((char */* __restrict  */)bound_regexp, (char const   */* __restrict  */)regexp,
                (size_t )re_len);
        }
      }
#line 500
      if ((int const   )*(regexp + (re_len - 1)) != 36) {
#line 501
        *(bound_regexp + bre_len) = (char )'$';
#line 502
        *(bound_regexp + (bre_len + 1)) = (char )'\000';
      }
    } else {
#line 505
      bound_regexp = (char *)regexp;
    }
    {
#line 508
    re_code = regcomp((regex_t */* __restrict  */)*comp, (char const   */* __restrict  */)bound_regexp,
                      1 | (((1 << 1) << 1) << 1));
    }
#line 508
    if (re_code != 0) {
      {
#line 510
      regerror(re_code, (regex_t const   */* __restrict  */)*comp, (char */* __restrict  */)(re_err),
               (size_t )256);
#line 511
      *err = re_err;
      }
#line 512
      if ((unsigned long )bound_regexp != (unsigned long )regexp) {
        {
#line 512
        free((void *)bound_regexp);
        }
      }
#line 513
      return (0);
    }
#line 515
    if ((unsigned long )bound_regexp != (unsigned long )regexp) {
      {
#line 515
      free((void *)bound_regexp);
      }
    }
  }
  {
#line 517
  tmp___2 = regexec((regex_t const   */* __restrict  */)*comp, (char const   */* __restrict  */)str,
                    (size_t )0, (regmatch_t */* __restrict  */)((void *)0), 0);
  }
#line 517
  return (tmp___2 == 0);
}
}
#line 524 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libhc.c"
int hashcash_resource_match(int type , char const   *token_res , char const   *res ,
                            void **compile , char **err ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 528
  if (type == 0) {
#line 528
    goto case_0;
  }
#line 531
  if (type == 1) {
#line 531
    goto case_1;
  }
#line 534
  if (type == 2) {
#line 534
    goto case_2;
  }
#line 537
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 529
  tmp = strcmp(token_res, res);
  }
#line 529
  if (tmp != 0) {
#line 529
    return (0);
  }
#line 530
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 532
  tmp___0 = email_match(token_res, res);
  }
#line 532
  if (! tmp___0) {
#line 532
    return (0);
  }
#line 533
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 535
  tmp___1 = regexp_match(token_res, res, compile, err);
  }
#line 535
  if (! tmp___1) {
#line 535
    return (0);
  }
#line 536
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 538
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 540
  return (1);
}
}
#line 543 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libhc.c"
int hashcash_check(char const   *token , int case_flag , char const   *resource ,
                   void **compile , char **re_err___0 , int type , time_t now_time ,
                   long validity_period , long grace_period , int required_bits ,
                   time_t *token_time ) 
{ 
  time_t token_t ;
  char token_utime[14] ;
  unsigned int tmp ;
  char token_res[257] ;
  unsigned int tmp___0 ;
  int bits ;
  int claimed_bits ;
  int vers ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned int tmp___3 ;
  long tmp___4 ;

  {
#line 547
  token_t = (time_t )0;
#line 548
  token_utime[0] = (char)0;
#line 548
  tmp = 1U;
  {
#line 548
  while (1) {
    while_continue: /* CIL Label */ ;
#line 548
    if (tmp >= 14U) {
#line 548
      goto while_break;
    }
#line 548
    token_utime[tmp] = (char)0;
#line 548
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 549
  token_res[0] = (char)0;
#line 549
  tmp___0 = 1U;
  {
#line 549
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 549
    if (tmp___0 >= 257U) {
#line 549
      goto while_break___0;
    }
#line 549
    token_res[tmp___0] = (char)0;
#line 549
    tmp___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 550
  bits = 0;
#line 550
  claimed_bits = 0;
#line 550
  vers = 0;
#line 552
  if ((unsigned long )token_time == (unsigned long )((void *)0)) {
#line 552
    token_time = & token_t;
  }
  {
#line 554
  tmp___1 = hashcash_parse(token, & vers, & claimed_bits, token_utime, 13, token_res,
                           256, (char **)((void *)0), 0);
  }
#line 554
  if (! tmp___1) {
#line 556
    return (-11);
  }
#line 559
  if (vers < 0) {
#line 560
    return (-14);
  } else
#line 559
  if (vers > 1) {
#line 560
    return (-14);
  }
  {
#line 563
  *token_time = hashcash_from_utctimestr((char const   *)(token_utime), 1);
  }
#line 564
  if (*token_time == -1L) {
#line 565
    return (-11);
  }
#line 568
  if (! case_flag) {
    {
#line 569
    stolower(token_res);
    }
  }
#line 572
  if (resource) {
    {
#line 572
    tmp___2 = hashcash_resource_match(type, (char const   *)(token_res), resource,
                                      compile, re_err___0);
    }
#line 572
    if (! tmp___2) {
#line 575
      if ((unsigned long )*re_err___0 != (unsigned long )((void *)0)) {
#line 576
        return (-17);
      } else {
#line 578
        return (-12);
      }
    }
  }
  {
#line 581
  tmp___3 = hashcash_count(token);
#line 581
  bits = (int )tmp___3;
  }
#line 582
  if (vers == 1) {
#line 583
    if (bits < claimed_bits) {
#line 583
      bits = 0;
    } else {
#line 583
      bits = claimed_bits;
    }
  }
#line 586
  if (bits < required_bits) {
#line 587
    return (-13);
  }
  {
#line 589
  tmp___4 = hashcash_valid_for(*token_time, validity_period, grace_period, now_time);
  }
#line 589
  return ((int )tmp___4);
}
}
#line 593 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libhc.c"
double hashcash_estimate_time(int b ) 
{ 
  double tmp ;
  unsigned long tmp___0 ;

  {
  {
#line 595
  tmp = hashcash_expected_tries(b);
#line 595
  tmp___0 = hashcash_per_sec();
  }
#line 595
  return (tmp / (double )tmp___0);
}
}
#line 598 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libhc.c"
double hashcash_expected_tries(int b ) 
{ 
  double expected_tests ;

  {
#line 600
  expected_tests = (double )1;
  {
#line 602
  while (1) {
    while_continue: /* CIL Label */ ;
#line 602
    if (! ((unsigned long )b > sizeof(unsigned long ) * 8UL - 1UL)) {
#line 602
      goto while_break;
    }
#line 603
    expected_tests *= (double )(1UL << (sizeof(unsigned long ) * 8UL - 1UL));
#line 602
    b = (int )((unsigned long )b - (sizeof(unsigned long ) * 8UL - 1UL));
  }
  while_break: /* CIL Label */ ;
  }
#line 605
  expected_tests *= (double )(1UL << b);
#line 606
  return (expected_tests);
}
}
#line 609 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libhc.c"
void hashcash_free(void *ptr ) 
{ 


  {
#line 611
  if ((unsigned long )ptr != (unsigned long )((void *)0)) {
    {
#line 611
    free(ptr);
    }
  }
#line 612
  return;
}
}
#line 779 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 76
extern int opterr ;
#line 80
extern int optopt ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int argc ,
                                                                             char * const  *argv ,
                                                                             char const   *shortopts ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 765
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 538
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 124
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 189 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) clock_t ( __attribute__((__leaf__)) clock)(void) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/sdb.h"
extern int hashcash_db_open(DB *db , char const   *db_filename , int *err ) ;
#line 47
extern int hashcash_db_in(DB *db , char *token , char *period , int *err ) ;
#line 50
extern int hashcash_db_add(DB *db , char *token , char *period , int *err ) ;
#line 53
extern int hashcash_db_close(DB *db , int *err ) ;
#line 74
extern int sdb_updateiterate(DB * , int (*cb)(char const   *key , char *val , void *arg ,
                                              int *err ) , void *arg , int *err ) ;
#line 82
extern int sdb_lookup(DB * , char const   *key , char *val , int vlen , int *err ) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/hashcash.h"
int verbose_flag  ;
#line 382
unsigned long hashcash_benchtest(int verbose , int core ) ;
#line 387
int hashcash_core(void) ;
#line 392
int hashcash_use_core(int core ) ;
#line 397
char const   *hashcash_core_name(int core ) ;
#line 81 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/hashcash.c"
int read_append(char **s , int *smax , int *alloc , char *append ) ;
#line 82
char *read_header(FILE *f , char **s , int *smax , int *alloc , char *a , int amax ) ;
#line 84
int read_eof(FILE *fp , char *a ) ;
#line 85
void chomplf(char *token ) ;
#line 86
void trimspace(char *token ) ;
#line 87
void die(int err ) ;
#line 88
void die_msg(char const   *str ) ;
#line 89
void usage(char const   *msg ) ;
#line 90
int parse_period(char const   *aperiod , long *resp ) ;
#line 91
double report_speed(int bits , double *time_est , int display ) ;
#line 101
void mystolower(char *str ) ;
#line 123
void db_open(DB *db , char const   *db_filename ) ;
#line 124
void db_purge_arr(DB *db , ARRAY *purge_resource , int purge_all , long purge_period ,
                  time_t now_time , long validity_period , long grace_period ) ;
#line 127
int db_purge(DB *db , ARRAY *purge_resource , int purge_all , long purge_period ,
             time_t now_time , long validity_period , long grace_period , int verbose ,
             int *err ) ;
#line 130
int db_in(DB *db , char *token , char *period ) ;
#line 131
void db_add(DB *db , char *token , char *period ) ;
#line 132
void db_close(DB *db ) ;
#line 134
void array_alloc(ARRAY *array , int num ) ;
#line 135
void array_push(ARRAY *array , char const   *str , int type , int case_flag , long validity ,
                long grace , long anon , int width , int bits , int over ) ;
#line 139
int bit_cmp(void const   *ap , void const   *bp ) ;
#line 140
void array_sort(ARRAY *array , int (*cmp)(void const   * , void const   * ) ) ;
#line 145 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/hashcash.c"
int quiet_flag  ;
#line 147 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/hashcash.c"
int out_is_tty  ;
#line 148 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/hashcash.c"
int in_is_tty  ;
#line 150
int progress_callback(int percent , int largest , int target , double counter , double expected ,
                      void *user ) ;
#line 155 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/hashcash.c"
int main(int argc , char **argv ) 
{ 
  long validity_period ;
  long purge_validity_period ;
  long grace_period ;
  char period[12] ;
  char utcttime[14] ;
  char const   *db_filename ;
  int boundary ;
  int err ;
  int anon_flag ;
  int over_flag ;
  int grace_flag ;
  long anon_period ;
  long anon_random ;
  int default_bits ;
  int count_bits ;
  int claimed_bits ;
  int bits ;
  int check_flag ;
  int case_flag ;
  int hdr_flag ;
  int width_flag ;
  int left_flag ;
  int speed_flag ;
  int utc_flag ;
  int bits_flag ;
  int str_type ;
  int validity_flag ;
  int db_flag ;
  int yes_flag ;
  int purge_flag ;
  int mint_flag ;
  int ignore_boundary_flag ;
  int name_flag ;
  int res_flag ;
  int auto_version ;
  int version_flag ;
  int checked ;
  int comma ;
  char header[257] ;
  unsigned int tmp ;
  char header2[257] ;
  unsigned int tmp___0 ;
  char *header_wrapped ;
  int hdr_len ;
  int hdr2_len ;
  int token_found ;
  int token2_found ;
  int hdrs_found ;
  char token[10772] ;
  unsigned int tmp___1 ;
  char token_resource[257] ;
  unsigned int tmp___2 ;
  char *new_token ;
  char line_arr[11266] ;
  unsigned int tmp___3 ;
  char *line ;
  int line_max ;
  int line_alloc ;
  char ahead[11266] ;
  unsigned int tmp___4 ;
  char *ext ;
  char *junk ;
  ARRAY purge_resource ;
  ARRAY resource ;
  ARRAY tokens ;
  ARRAY args ;
  clock_t start ;
  clock_t end ;
  clock_t tmp___5 ;
  long purge_period ;
  long valid_for ;
  long time_period ;
  int purge_all ;
  int multiple_validity ;
  int multiple_bits ;
  int multiple_resources ;
  int multiple_grace ;
  int accept ;
  int parsed ;
  char token_utime[14] ;
  unsigned int tmp___6 ;
  time_t real_time ;
  time_t tmp___7 ;
  time_t now_time ;
  time_t token_time ;
  time_t expiry_time ;
  int time_width_flag ;
  int compress ;
  int inferred_time_width ;
  int time_width ;
  int core ;
  int res ;
  int core_flag ;
  double tries_taken ;
  double taken ;
  double tries_expected ;
  double time_est ;
  int opt ;
  int vers ;
  int db_opened ;
  int i ;
  int t ;
  int tty_info ;
  int in_headers ;
  int skip ;
  int over ;
  char *re_err___0 ;
  ELEMENT *ent ;
  DB db ;
  int (*callback)(int percent , int largest , int target , double count , double expected ,
                  void *user ) ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  char const   *tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  long tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  char const   *tmp___25 ;
  unsigned long tmp___26 ;
  unsigned long tmp___27 ;
  int tmp___28 ;
  char const   *tmp___29 ;
  unsigned long tmp___30 ;
  unsigned long tmp___31 ;
  double *tmp___32 ;
  int tmp___33 ;
  char const   *tmp___34 ;
  size_t tmp___35 ;
  size_t tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  unsigned int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  char const   *tmp___47 ;
  char const   *tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;

  {
#line 157
  validity_period = 2419200L;
#line 158
  purge_validity_period = 2419200L;
#line 159
  grace_period = 172800L;
#line 162
  db_filename = "hashcash.sdb";
#line 163
  anon_flag = 0;
#line 163
  over_flag = 0;
#line 163
  grace_flag = 0;
#line 164
  anon_period = 0L;
#line 164
  anon_random = 0L;
#line 165
  default_bits = 20;
#line 166
  claimed_bits = 0;
#line 166
  bits = 0;
#line 167
  check_flag = 0;
#line 167
  case_flag = 0;
#line 167
  hdr_flag = 0;
#line 168
  width_flag = 0;
#line 168
  left_flag = 0;
#line 168
  speed_flag = 0;
#line 168
  utc_flag = 0;
#line 169
  bits_flag = 0;
#line 169
  str_type = 1;
#line 170
  validity_flag = 0;
#line 170
  db_flag = 0;
#line 170
  yes_flag = 0;
#line 170
  purge_flag = 0;
#line 171
  mint_flag = 0;
#line 171
  ignore_boundary_flag = 0;
#line 171
  name_flag = 0;
#line 171
  res_flag = 0;
#line 172
  auto_version = 0;
#line 172
  version_flag = 0;
#line 172
  checked = 0;
#line 172
  comma = 0;
#line 173
  header[0] = (char)0;
#line 173
  tmp = 1U;
  {
#line 173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 173
    if (tmp >= 257U) {
#line 173
      goto while_break;
    }
#line 173
    header[tmp] = (char)0;
#line 173
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 174
  header2[0] = (char)0;
#line 174
  tmp___0 = 1U;
  {
#line 174
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 174
    if (tmp___0 >= 257U) {
#line 174
      goto while_break___0;
    }
#line 174
    header2[tmp___0] = (char)0;
#line 174
    tmp___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 175
  header_wrapped = (char *)((void *)0);
#line 176
  token_found = 0;
#line 176
  token2_found = 0;
#line 176
  hdrs_found = 0;
#line 177
  token[0] = (char)0;
#line 177
  tmp___1 = 1U;
  {
#line 177
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 177
    if (tmp___1 >= 10772U) {
#line 177
      goto while_break___1;
    }
#line 177
    token[tmp___1] = (char)0;
#line 177
    tmp___1 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 177
  token_resource[0] = (char)0;
#line 177
  tmp___2 = 1U;
  {
#line 177
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 177
    if (tmp___2 >= 257U) {
#line 177
      goto while_break___2;
    }
#line 177
    token_resource[tmp___2] = (char)0;
#line 177
    tmp___2 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 178
  new_token = (char *)((void *)0);
#line 179
  line_arr[0] = (char)0;
#line 179
  tmp___3 = 1U;
  {
#line 179
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 179
    if (tmp___3 >= 11266U) {
#line 179
      goto while_break___3;
    }
#line 179
    line_arr[tmp___3] = (char)0;
#line 179
    tmp___3 ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 179
  line = line_arr;
#line 180
  line_max = 11265;
#line 180
  line_alloc = 0;
#line 181
  ahead[0] = (char)0;
#line 181
  tmp___4 = 1U;
  {
#line 181
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 181
    if (tmp___4 >= 11266U) {
#line 181
      goto while_break___4;
    }
#line 181
    ahead[tmp___4] = (char)0;
#line 181
    tmp___4 ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 181
  ext = (char *)((void *)0);
#line 181
  junk = (char *)((void *)0);
#line 184
  start = (clock_t )0;
#line 184
  end = (clock_t )0;
#line 184
  tmp___5 = (clock_t )0;
#line 186
  purge_period = 0L;
#line 186
  valid_for = -11L;
#line 186
  time_period = 0L;
#line 187
  purge_all = 0;
#line 188
  multiple_validity = 0;
#line 188
  multiple_bits = 0;
#line 188
  multiple_resources = 0;
#line 189
  multiple_grace = 0;
#line 189
  accept = 0;
#line 189
  parsed = 0;
#line 191
  token_utime[0] = (char)0;
#line 191
  tmp___6 = 1U;
  {
#line 191
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 191
    if (tmp___6 >= 14U) {
#line 191
      goto while_break___5;
    }
#line 191
    token_utime[tmp___6] = (char)0;
#line 191
    tmp___6 ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 192
  tmp___7 = time((time_t *)0);
#line 192
  real_time = tmp___7;
#line 193
  now_time = real_time;
#line 194
  token_time = (time_t )0;
#line 194
  expiry_time = (time_t )0;
#line 195
  time_width_flag = 0;
#line 196
  compress = 0;
#line 197
  inferred_time_width = 0;
#line 197
  time_width = 6;
#line 198
  core = 0;
#line 198
  res = 0;
#line 198
  core_flag = 0;
#line 200
  tries_taken = (double )0;
#line 200
  taken = (double )0;
#line 200
  tries_expected = (double )0;
#line 200
  time_est = (double )0;
#line 201
  opt = 0;
#line 201
  vers = 0;
#line 201
  db_opened = 0;
#line 201
  i = 0;
#line 201
  t = 0;
#line 201
  tty_info = 0;
#line 202
  in_headers = 0;
#line 202
  skip = 0;
#line 202
  over = 0;
#line 203
  re_err___0 = (char *)((void *)0);
#line 204
  ent = (ELEMENT *)((void *)0);
#line 206
  callback = (int (*)(int percent , int largest , int target , double count , double expected ,
                      void *user ))((void *)0);
#line 212
  tmp___8 = fileno(stdout);
#line 212
  out_is_tty = isatty(tmp___8);
#line 213
  tmp___9 = fileno(stdin);
#line 213
  tmp___10 = isatty(tmp___9);
  }
#line 213
  if (tmp___10) {
    {
#line 213
    tmp___11 = feof(stdin);
    }
#line 213
    if (tmp___11) {
#line 213
      tmp___12 = 0;
    } else {
#line 213
      tmp___12 = 1;
    }
  } else {
#line 213
    tmp___12 = 0;
  }
  {
#line 213
  in_is_tty = tmp___12;
#line 214
  quiet_flag = 0;
#line 215
  verbose_flag = 0;
#line 217
  token_resource[0] = (char )'\000';
#line 218
  token[0] = (char )'\000';
#line 219
  opterr = 0;
#line 221
  array_alloc(& resource, 32);
#line 222
  array_alloc(& purge_resource, 32);
#line 223
  array_alloc(& tokens, 32);
#line 224
  array_alloc(& args, 32);
  }
  {
#line 226
  while (1) {
    while_continue___6: /* CIL Label */ ;
    {
#line 226
    opt = getopt(argc, (char * const  *)argv, "-a:b:cde:f:g:hij:klmnop:qr:st:uvwx:yz:CEMO:PSVXZ:");
    }
#line 226
    if (! (opt > 0)) {
#line 226
      goto while_break___6;
    }
    {
#line 229
    if (opt == 97) {
#line 229
      goto case_97;
    }
#line 234
    if (opt == 98) {
#line 234
      goto case_98;
    }
#line 254
    if (opt == 67) {
#line 254
      goto case_67;
    }
#line 255
    if (opt == 99) {
#line 255
      goto case_99;
    }
#line 256
    if (opt == 100) {
#line 256
      goto case_100;
    }
#line 257
    if (opt == 101) {
#line 257
      goto case_101;
    }
#line 265
    if (opt == 69) {
#line 265
      goto case_69;
    }
#line 266
    if (opt == 102) {
#line 266
      goto case_102;
    }
#line 267
    if (opt == 103) {
#line 267
      goto case_103;
    }
#line 277
    if (opt == 104) {
#line 277
      goto case_104;
    }
#line 278
    if (opt == 105) {
#line 278
      goto case_105;
    }
#line 279
    if (opt == 106) {
#line 279
      goto case_106;
    }
#line 284
    if (opt == 107) {
#line 284
      goto case_107;
    }
#line 285
    if (opt == 108) {
#line 285
      goto case_108;
    }
#line 286
    if (opt == 110) {
#line 286
      goto case_110;
    }
#line 287
    if (opt == 111) {
#line 287
      goto case_111;
    }
#line 288
    if (opt == 79) {
#line 288
      goto case_79;
    }
#line 297
    if (opt == 109) {
#line 297
      goto case_109;
    }
#line 303
    if (opt == 77) {
#line 303
      goto case_77;
    }
#line 304
    if (opt == 112) {
#line 304
      goto case_112;
    }
#line 314
    if (opt == 80) {
#line 314
      goto case_80;
    }
#line 315
    if (opt == 113) {
#line 315
      goto case_113;
    }
#line 317
    if (opt == 114) {
#line 317
      goto case_114;
    }
#line 317
    if (opt == 1) {
#line 317
      goto case_114;
    }
#line 347
    if (opt == 115) {
#line 347
      goto case_115;
    }
#line 348
    if (opt == 83) {
#line 348
      goto case_83;
    }
#line 349
    if (opt == 116) {
#line 349
      goto case_116;
    }
#line 362
    if (opt == 117) {
#line 362
      goto case_117;
    }
#line 363
    if (opt == 118) {
#line 363
      goto case_118;
    }
#line 364
    if (opt == 86) {
#line 364
      goto case_86;
    }
#line 365
    if (opt == 119) {
#line 365
      goto case_119;
    }
#line 366
    if (opt == 120) {
#line 366
      goto case_120;
    }
#line 372
    if (opt == 88) {
#line 372
      goto case_88;
    }
#line 377
    if (opt == 121) {
#line 377
      goto case_121;
    }
#line 378
    if (opt == 122) {
#line 378
      goto case_122;
    }
#line 385
    if (opt == 90) {
#line 385
      goto case_90;
    }
#line 389
    if (opt == 63) {
#line 389
      goto case_63;
    }
#line 393
    if (opt == 58) {
#line 393
      goto case_58;
    }
#line 397
    goto switch_default;
    case_97: /* CIL Label */ 
    {
#line 229
    anon_flag = 1;
#line 230
    tmp___13 = parse_period((char const   *)optarg, & anon_period);
    }
#line 230
    if (! tmp___13) {
      {
#line 231
      usage("error: -a invalid period arg");
      }
    }
#line 233
    goto switch_break;
    case_98: /* CIL Label */ 
#line 235
    if (bits_flag) {
#line 235
      multiple_bits = 1;
    }
    {
#line 236
    bits_flag = 1;
#line 238
    tmp___14 = strcmp((char const   *)optarg, "default");
    }
#line 238
    if (tmp___14 == 0) {
#line 239
      bits = default_bits;
    } else
#line 240
    if ((int )*(optarg + 0) == 45) {
#line 240
      goto _L;
    } else
#line 240
    if ((int )*(optarg + 0) == 43) {
      _L: /* CIL Label */ 
      {
#line 241
      bits = atoi((char const   *)(optarg + 1));
      }
#line 242
      if (bits < 0) {
        {
#line 242
        usage("error: -b invalid bits arg");
        }
      }
#line 243
      if ((int )*(optarg + 0) == 45) {
#line 243
        bits = - bits;
      }
#line 244
      bits = default_bits + bits;
#line 245
      if (bits < 0) {
#line 245
        bits = 0;
      }
    } else {
      {
#line 247
      bits = atoi((char const   *)optarg);
      }
#line 248
      if (bits < 0) {
        {
#line 248
        usage("error: -b invalid bits arg");
        }
      }
    }
#line 250
    if (bits > 160) {
      {
#line 251
      usage("error: max collision with sha1 is 160 bits");
      }
    }
#line 253
    goto switch_break;
    case_67: /* CIL Label */ 
#line 254
    case_flag = 1;
#line 254
    goto switch_break;
    case_99: /* CIL Label */ 
#line 255
    check_flag = 1;
#line 255
    goto switch_break;
    case_100: /* CIL Label */ 
#line 256
    db_flag = 1;
#line 256
    goto switch_break;
    case_101: /* CIL Label */ 
#line 258
    if (validity_flag) {
#line 258
      multiple_validity = 1;
    }
    {
#line 259
    validity_flag = 1;
#line 260
    tmp___15 = parse_period((char const   *)optarg, & validity_period);
    }
#line 260
    if (tmp___15) {
#line 260
      if (validity_period < 0L) {
        {
#line 262
        usage("error: -e invalid validity period");
        }
      }
    } else {
      {
#line 262
      usage("error: -e invalid validity period");
      }
    }
#line 264
    goto switch_break;
    case_69: /* CIL Label */ 
#line 265
    str_type = 2;
#line 265
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 266
    tmp___16 = strdup((char const   *)optarg);
#line 266
    db_filename = (char const   *)tmp___16;
    }
#line 266
    goto switch_break;
    case_103: /* CIL Label */ 
#line 268
    if (grace_flag) {
#line 268
      multiple_grace = 1;
    }
#line 269
    grace_flag = 1;
#line 270
    if ((int )*(optarg + 0) == 45) {
      {
#line 271
      usage("error: -g -ve grace period not valid");
      }
    }
    {
#line 273
    tmp___17 = parse_period((char const   *)optarg, & grace_period);
    }
#line 273
    if (! tmp___17) {
      {
#line 274
      usage("error: -g invalid grace period format");
      }
    }
#line 276
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 277
    usage("");
    }
#line 277
    goto switch_break;
    case_105: /* CIL Label */ 
#line 278
    ignore_boundary_flag = 1;
#line 278
    goto switch_break;
    case_106: /* CIL Label */ 
    {
#line 280
    array_push(& purge_resource, (char const   *)optarg, str_type, case_flag, 0L,
               0L, 0L, 0, 0, 0);
#line 282
    over_flag = 0;
    }
#line 283
    goto switch_break;
    case_107: /* CIL Label */ 
#line 284
    purge_all = 1;
#line 284
    goto switch_break;
    case_108: /* CIL Label */ 
#line 285
    left_flag = 1;
#line 285
    goto switch_break;
    case_110: /* CIL Label */ 
#line 286
    name_flag = 1;
#line 286
    goto switch_break;
    case_111: /* CIL Label */ 
#line 287
    over_flag = 1;
#line 287
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 289
    core_flag = 1;
#line 290
    core = atoi((char const   *)optarg);
#line 291
    res = hashcash_use_core(core);
    }
#line 292
    if (res < 1) {
#line 293
      if (res == -1) {
#line 293
        tmp___18 = "error: -O no such core\n";
      } else {
#line 293
        tmp___18 = "error: -O core does not work on this platform";
      }
      {
#line 293
      usage(tmp___18);
      }
    }
#line 296
    goto switch_break;
    case_109: /* CIL Label */ 
#line 297
    mint_flag = 1;
#line 298
    if (! bits_flag) {
#line 299
      bits_flag = 1;
#line 300
      bits = default_bits;
    }
#line 302
    goto switch_break;
    case_77: /* CIL Label */ 
#line 303
    str_type = 1;
#line 303
    goto switch_break;
    case_112: /* CIL Label */ 
#line 305
    if (purge_flag) {
      {
#line 305
      usage("error: only one -p flag per call");
      }
    }
    {
#line 306
    purge_flag = 1;
#line 307
    tmp___20 = strcmp((char const   *)optarg, "now");
    }
#line 307
    if (tmp___20 == 0) {
#line 307
      purge_period = 0L;
    } else {
      {
#line 308
      tmp___19 = parse_period((char const   *)optarg, & purge_period);
      }
#line 308
      if (tmp___19) {
#line 308
        if (purge_period < 0L) {
          {
#line 310
          usage("error: -p invalid purge interval");
          }
        }
      } else {
        {
#line 310
        usage("error: -p invalid purge interval");
        }
      }
    }
#line 312
    purge_validity_period = validity_period;
#line 313
    goto switch_break;
    case_80: /* CIL Label */ 
#line 314
    callback = & progress_callback;
#line 314
    goto switch_break;
    case_113: /* CIL Label */ 
#line 315
    quiet_flag = 1;
#line 315
    goto switch_break;
    case_114: /* CIL Label */ 
    case_1: /* CIL Label */ 
#line 318
    if (opt == 114) {
#line 319
      if (res_flag) {
#line 319
        multiple_resources = 1;
      }
#line 320
      res_flag = 1;
    }
#line 324
    if (validity_flag) {
#line 324
      if (! time_width_flag) {
#line 324
        if (! inferred_time_width) {
          {
#line 325
          time_width = hashcash_validity_to_width(validity_period);
          }
#line 326
          if (! time_width) {
            {
#line 327
            die_msg("error: -ve validity period");
            }
          }
#line 329
          inferred_time_width = time_width;
        }
      }
    }
    {
#line 332
    array_push(& args, (char const   *)optarg, str_type, case_flag, validity_period,
               grace_period, anon_period, time_width, bits, 0);
    }
#line 335
    if (opt == 114) {
      {
#line 336
      array_push(& resource, (char const   *)optarg, str_type, case_flag, validity_period,
                 grace_period, anon_period, time_width, bits, over_flag);
      }
    } else
#line 339
    if (opt == 1) {
      {
#line 340
      array_push(& tokens, (char const   *)optarg, str_type, case_flag, validity_period,
                 grace_period, anon_period, time_width, bits, 0);
      }
    }
#line 344
    over_flag = 0;
#line 346
    goto switch_break;
    case_115: /* CIL Label */ 
#line 347
    speed_flag = 1;
#line 347
    goto switch_break;
    case_83: /* CIL Label */ 
#line 348
    str_type = 0;
#line 348
    goto switch_break;
    case_116: /* CIL Label */ 
#line 350
    if ((int )*(optarg + 0) == 45) {
#line 350
      goto _L___0;
    } else
#line 350
    if ((int )*(optarg + 0) == 43) {
      _L___0: /* CIL Label */ 
      {
#line 351
      tmp___21 = parse_period((char const   *)optarg, & time_period);
      }
#line 351
      if (! tmp___21) {
        {
#line 352
        usage("error: -t invalid relative time format");
        }
      }
#line 354
      now_time += time_period;
    } else {
      {
#line 356
      now_time = hashcash_from_utctimestr((char const   *)optarg, utc_flag);
      }
#line 357
      if (now_time == -1L) {
        {
#line 358
        usage("error: -t invalid time format");
        }
      }
    }
#line 361
    goto switch_break;
    case_117: /* CIL Label */ 
#line 362
    utc_flag = 1;
#line 362
    goto switch_break;
    case_118: /* CIL Label */ 
#line 363
    verbose_flag = 1;
#line 363
    goto switch_break;
    case_86: /* CIL Label */ 
#line 364
    version_flag = 1;
#line 364
    goto switch_break;
    case_119: /* CIL Label */ 
#line 365
    width_flag = 1;
#line 365
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 367
    ext = strdup((char const   *)optarg);
    }
#line 371
    goto switch_break;
    case_88: /* CIL Label */ 
    {
#line 373
    hdr_flag = 1;
#line 374
    header[256] = (char )'\000';
#line 374
    strncpy((char */* __restrict  */)(header), (char const   */* __restrict  */)"X-Hashcash: ",
            (size_t )256);
#line 375
    header2[256] = (char )'\000';
#line 375
    strncpy((char */* __restrict  */)(header2), (char const   */* __restrict  */)"Hashcash: ",
            (size_t )256);
    }
#line 376
    goto switch_break;
    case_121: /* CIL Label */ 
#line 377
    yes_flag = 1;
#line 377
    goto switch_break;
    case_122: /* CIL Label */ 
    {
#line 379
    time_width_flag = 1;
#line 380
    time_width = atoi((char const   *)optarg);
    }
#line 381
    if (time_width != 6) {
#line 381
      if (time_width != 10) {
#line 381
        if (time_width != 12) {
          {
#line 382
          usage("error: -z invalid time width: must be 6, 10 or 12");
          }
        }
      }
    }
#line 384
    goto switch_break;
    case_90: /* CIL Label */ 
    {
#line 385
    compress = atoi((char const   *)optarg);
    }
#line 388
    goto switch_break;
    case_63: /* CIL Label */ 
    {
#line 390
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error: unrecognized option -%c",
            optopt);
#line 391
    usage("");
    }
#line 392
    goto switch_break;
    case_58: /* CIL Label */ 
    {
#line 394
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error: option -%c missing argument",
            optopt);
#line 395
    usage("");
    }
#line 396
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 398
    usage("error with argument processing");
    }
#line 399
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
#line 403
  if (validity_flag) {
#line 403
    if (! time_width_flag) {
#line 403
      if (! inferred_time_width) {
        {
#line 404
        time_width = hashcash_validity_to_width((resource.elt + 0)->validity);
        }
#line 405
        if (! time_width) {
          {
#line 406
          die_msg("error: -ve validity period");
          }
        }
#line 408
        inferred_time_width = time_width;
      }
    }
  }
#line 411
  if (args.num == 0) {
#line 411
    if (verbose_flag) {
#line 411
      if ((((((name_flag + left_flag) + width_flag) + check_flag) + mint_flag) + purge_flag) + speed_flag < 1) {
#line 414
        auto_version = 1;
#line 415
        version_flag = 1;
#line 415
        verbose_flag = 0;
      }
    }
  }
#line 418
  if (version_flag) {
#line 419
    if (! quiet_flag) {
      {
#line 419
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Version: hashcash-%s\n",
              "1.21");
      }
    }
#line 421
    if (! out_is_tty) {
      {
#line 421
      fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%s\n",
              "1.21");
      }
    } else
#line 421
    if (quiet_flag) {
      {
#line 421
      fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%s\n",
              "1.21");
      }
    }
#line 422
    if (auto_version) {
      {
#line 422
      exit(1);
      }
    }
  }
#line 425
  if (mint_flag + check_flag > 1) {
    {
#line 426
    usage("can only specify one of -m, -c");
    }
  }
#line 429
  if (mint_flag) {
#line 429
    if (name_flag) {
      {
#line 430
      usage("can not use -n, -w or -l with -m");
      }
    } else
#line 429
    if (width_flag) {
      {
#line 430
      usage("can not use -n, -w or -l with -m");
      }
    } else
#line 429
    if (left_flag) {
      {
#line 430
      usage("can not use -n, -w or -l with -m");
      }
    }
  }
#line 433
  if ((((((((((mint_flag + check_flag) + name_flag) + left_flag) + width_flag) + db_flag) + bits_flag) + res_flag) + purge_flag) + speed_flag) + version_flag == 0) {
    {
#line 435
    usage("must specify at least one of -m, -c, -d, -n, -l-, -w, -b, -r, -p or -s");
    }
  }
#line 438
  if (quiet_flag) {
#line 438
    verbose_flag = 0;
  }
#line 439
  if (speed_flag) {
#line 439
    if (check_flag) {
#line 439
      speed_flag = 0;
    }
  }
#line 441
  if (purge_flag) {
    {
#line 442
    db_open(& db, db_filename);
#line 443
    db_opened = 1;
    }
#line 445
    if (validity_flag) {
#line 445
      tmp___22 = purge_validity_period;
    } else {
#line 445
      tmp___22 = 0L;
    }
    {
#line 445
    db_purge_arr(& db, & purge_resource, purge_all, purge_period, now_time, tmp___22,
                 grace_period);
    }
#line 449
    if (((((((mint_flag + check_flag) + name_flag) + left_flag) + width_flag) + bits_flag) + res_flag) + speed_flag == 0) {
      {
#line 451
      db_close(& db);
#line 452
      exit(0);
      }
    }
  }
#line 456
  if (mint_flag) {
#line 456
    goto _L___15;
  } else
#line 456
  if (speed_flag) {
    _L___15: /* CIL Label */ 
#line 458
    if (mint_flag) {
#line 461
      if (args.num == 0) {
#line 462
        if (in_is_tty) {
          {
#line 463
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"enter resources to mint stamps for one per line:\n");
          }
        }
        {
#line 465
        while (1) {
          while_continue___7: /* CIL Label */ ;
          {
#line 465
          tmp___23 = feof(stdin);
          }
#line 465
          if (tmp___23) {
#line 465
            goto while_break___7;
          }
          {
#line 466
          *(line + 0) = (char )'\000';
#line 467
          junk = fgets((char */* __restrict  */)line, 11265, (FILE */* __restrict  */)stdin);
#line 468
          chomplf(line);
#line 469
          trimspace(line);
          }
#line 470
          if ((int )*(line + 0) != 0) {
            {
#line 471
            array_push(& args, (char const   *)line, 0, 0, validity_period, grace_period,
                       anon_period, time_width, bits, 0);
            }
          }
        }
        while_break___7: /* CIL Label */ ;
        }
      }
    }
#line 481
    if (verbose_flag) {
#line 481
      if (speed_flag) {
#line 481
        if (! mint_flag) {
#line 482
          if (core_flag) {
            {
#line 483
            hashcash_benchtest(3, core);
            }
          } else {
            {
#line 485
            hashcash_benchtest(3, -1);
            }
          }
          {
#line 487
          exit(0);
          }
        }
      }
    }
#line 490
    if (! verbose_flag) {
#line 490
      if (speed_flag) {
#line 490
        if (mint_flag) {
#line 491
          if (! quiet_flag) {
            {
#line 491
            tmp___24 = hashcash_core();
#line 491
            tmp___25 = hashcash_core_name(tmp___24);
#line 491
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"core: %s\n",
                    tmp___25);
            }
          }
#line 493
          if (! quiet_flag) {
            {
#line 493
            tmp___26 = hashcash_per_sec();
#line 493
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"speed: %ld collision tests per second\n",
                    tmp___26);
            }
          }
#line 495
          if (! out_is_tty) {
            {
#line 495
            tmp___27 = hashcash_per_sec();
#line 495
            fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%ld\n",
                    tmp___27);
            }
          } else
#line 495
          if (quiet_flag) {
            {
#line 495
            tmp___27 = hashcash_per_sec();
#line 495
            fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%ld\n",
                    tmp___27);
            }
          }
#line 496
          if (! quiet_flag) {
            {
#line 496
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"compression: %d\n",
                    compress);
            }
          }
        }
      }
    }
#line 499
    if (verbose_flag) {
#line 499
      goto _L___1;
    } else
#line 499
    if (speed_flag) {
#line 499
      if (! bits_flag) {
        _L___1: /* CIL Label */ 
#line 500
        if (! quiet_flag) {
          {
#line 500
          tmp___28 = hashcash_core();
#line 500
          tmp___29 = hashcash_core_name(tmp___28);
#line 500
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"core: %s\n",
                  tmp___29);
          }
        }
#line 502
        if (! quiet_flag) {
          {
#line 502
          tmp___30 = hashcash_per_sec();
#line 502
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"speed: %ld collision tests per second\n",
                  tmp___30);
          }
        }
#line 504
        if (speed_flag) {
#line 504
          if (! bits_flag) {
#line 504
            if (! mint_flag) {
#line 505
              if (! out_is_tty) {
                {
#line 505
                tmp___31 = hashcash_per_sec();
#line 505
                fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%ld\n",
                        tmp___31);
                }
              } else
#line 505
              if (quiet_flag) {
                {
#line 505
                tmp___31 = hashcash_per_sec();
#line 505
                fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%ld\n",
                        tmp___31);
                }
              }
            }
          }
        }
#line 507
        if (! quiet_flag) {
          {
#line 507
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"compression: %d\n",
                  compress);
          }
        }
#line 508
        if (speed_flag) {
#line 508
          if (! bits_flag) {
#line 508
            if (! mint_flag) {
              {
#line 509
              exit(0);
              }
            }
          }
        }
      }
    }
#line 513
    if (speed_flag) {
#line 513
      if (bits_flag) {
#line 513
        if (! mint_flag) {
#line 514
          if (! out_is_tty) {
#line 514
            tmp___32 = & time_est;
          } else
#line 514
          if (quiet_flag) {
#line 514
            tmp___32 = & time_est;
          } else {
#line 514
            tmp___32 = (double *)0;
          }
          {
#line 514
          tries_expected = report_speed(bits, tmp___32, ! quiet_flag);
          }
#line 516
          if (! out_is_tty) {
            {
#line 516
            fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%.0f\n",
                    time_est);
            }
          } else
#line 516
          if (quiet_flag) {
            {
#line 516
            fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%.0f\n",
                    time_est);
            }
          }
          {
#line 517
          exit(0);
          }
        }
      }
    }
#line 520
    i = 0;
    {
#line 520
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 520
      if (! (i < args.num)) {
#line 520
        goto while_break___8;
      }
      {
#line 522
      start = clock();
#line 524
      ent = args.elt + i;
      }
#line 526
      if (verbose_flag) {
#line 526
        tmp___33 = 1;
      } else
#line 526
      if (speed_flag) {
#line 526
        tmp___33 = 1;
      } else {
#line 526
        tmp___33 = 0;
      }
      {
#line 526
      tries_expected = report_speed(ent->bits, (double *)((void *)0), tmp___33);
      }
#line 529
      if (! ent->case_flag) {
        {
#line 529
        mystolower(ent->str);
        }
      }
      {
#line 531
      err = hashcash_mint(now_time, ent->width, (char const   *)ent->str, (unsigned int )ent->bits,
                          ent->anon, & new_token, & anon_random, & tries_taken, ext,
                          compress, callback, (void *)0);
#line 535
      end = clock();
      }
      {
#line 538
      if (err == -1) {
#line 538
        goto case_neg_1;
      }
#line 540
      if (err == -2) {
#line 540
        goto case_neg_2;
      }
#line 542
      if (err == -3) {
#line 542
        goto case_neg_3;
      }
#line 544
      if (err == -4) {
#line 544
        goto case_neg_4;
      }
#line 546
      if (err == -5) {
#line 546
        goto case_neg_5;
      }
#line 548
      if (err == -6) {
#line 548
        goto case_neg_6;
      }
#line 550
      if (err == -8) {
#line 550
        goto case_neg_8;
      }
#line 552
      if (err == -7) {
#line 552
        goto case_neg_7;
      }
#line 554
      if (err == 1) {
#line 554
        goto case_1___0;
      }
#line 556
      goto switch_default___0;
      case_neg_1: /* CIL Label */ 
      {
#line 539
      die_msg("error: maximum collision with sha1 is 160 bits");
      }
      case_neg_2: /* CIL Label */ 
      {
#line 541
      die_msg("error: random number generator failed");
      }
      case_neg_3: /* CIL Label */ 
      {
#line 543
      die_msg("error: outside unix time Epoch");
      }
      case_neg_4: /* CIL Label */ 
      {
#line 545
      die_msg("error: failed to find collision in 2^96 tries!");
      }
      case_neg_5: /* CIL Label */ 
      {
#line 547
      die_msg("error: -a token may expire on creation");
      }
      case_neg_6: /* CIL Label */ 
      {
#line 549
      die_msg("error: negative validity period");
      }
      case_neg_8: /* CIL Label */ 
      {
#line 551
      die_msg("error: invalid time width");
      }
      case_neg_7: /* CIL Label */ 
      {
#line 553
      die_msg("error: internal error");
      }
      case_1___0: /* CIL Label */ 
#line 555
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
      {
#line 557
      die_msg("error: unknown failure");
      }
      switch_break___0: /* CIL Label */ ;
      }
#line 560
      if (anon_flag) {
#line 561
        if (verbose_flag) {
          {
#line 561
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"anon period: %ld seconds\n",
                  anon_period);
          }
        }
#line 563
        if (verbose_flag) {
          {
#line 563
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"adding: %ld seconds\n",
                  anon_random);
          }
        }
      }
#line 566
      if (verbose_flag) {
        {
#line 566
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"tries: %.0f",
                tries_taken);
        }
      }
#line 567
      if (verbose_flag) {
        {
#line 567
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %.0f%% of expected                         \n",
                (tries_taken / tries_expected) * (double )100);
        }
      }
#line 570
      if (end < start) {
#line 570
        tmp___5 = end;
#line 570
        end = start;
#line 570
        start = tmp___5;
      }
#line 571
      taken = (double )(end - start) / (double )1000000L;
#line 572
      if (verbose_flag) {
        {
#line 572
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"time: %.0f seconds\n",
                taken);
        }
      }
#line 574
      if (hdr_flag) {
        {
#line 575
        header_wrapped = hashcash_make_header((char const   *)new_token, 80, (char const   *)(header),
                                              (char )'\t', "\n");
        }
#line 578
        if ((unsigned long )header_wrapped == (unsigned long )((void *)0)) {
          {
#line 580
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"out of memory\n");
#line 581
          exit(1);
          }
        }
        {
#line 583
        fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%s",
                header_wrapped);
#line 584
        free((void *)header_wrapped);
        }
      } else {
#line 586
        if (quiet_flag) {
#line 586
          tmp___34 = "";
        } else
#line 586
        if (! out_is_tty) {
#line 586
          tmp___34 = "";
        } else {
#line 586
          tmp___34 = "hashcash token: ";
        }
        {
#line 586
        fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%s%s\n",
                tmp___34, new_token);
        }
      }
      {
#line 590
      free((void *)new_token);
#line 520
      i ++;
      }
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 592
    exit(0);
    }
  } else
#line 594
  if (check_flag) {
#line 594
    goto _L___14;
  } else
#line 594
  if (name_flag) {
#line 594
    goto _L___14;
  } else
#line 594
  if (width_flag) {
#line 594
    goto _L___14;
  } else
#line 594
  if (left_flag) {
#line 594
    goto _L___14;
  } else
#line 594
  if (bits_flag) {
#line 594
    goto _L___14;
  } else
#line 594
  if (res_flag) {
#line 594
    goto _L___14;
  } else
#line 594
  if (db_flag) {
    _L___14: /* CIL Label */ 
    {
#line 598
    trimspace(header);
#line 599
    tmp___35 = strlen((char const   *)(header));
#line 599
    hdr_len = (int )tmp___35;
    }
#line 601
    if (header2[0]) {
      {
#line 602
      trimspace(header2);
#line 603
      tmp___36 = strlen((char const   *)(header2));
#line 603
      hdr2_len = (int )tmp___36;
      }
    }
#line 610
    if (resource.num == 0) {
      {
#line 611
      array_push(& resource, (char const   *)((void *)0), str_type, case_flag, validity_period,
                 grace_period, anon_period, time_width, bits, 0);
      }
    }
#line 615
    hdrs_found = 0;
#line 616
    tty_info = 0;
#line 617
    in_headers = 0;
#line 619
    ahead[0] = (char )'\000';
#line 620
    t = 0;
#line 620
    token_found = 0;
#line 620
    boundary = 0;
    {
#line 620
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 620
      if (! (! boundary)) {
#line 620
        goto while_break___9;
      }
#line 622
      if (t < tokens.num) {
        {
#line 623
        token[10771] = (char )'\000';
#line 623
        strncpy((char */* __restrict  */)(token), (char const   */* __restrict  */)(tokens.elt + t)->str,
                (size_t )10771);
#line 624
        t ++;
#line 625
        token_found = 1;
        }
      } else
#line 628
      if (! hdr_flag) {
#line 628
        if (tokens.num > 0) {
#line 628
          goto while_break___9;
        } else {
#line 628
          goto _L___2;
        }
      } else {
        _L___2: /* CIL Label */ 
#line 630
        if (! in_headers) {
#line 630
          in_headers = 1;
        }
#line 631
        if (in_is_tty) {
#line 631
          if (! tty_info) {
#line 632
            if (hdr_flag) {
#line 633
              if (ignore_boundary_flag) {
#line 634
                if (! quiet_flag) {
                  {
#line 634
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"enter email headers followed by mail body:\n");
                  }
                }
              } else
#line 636
              if (! quiet_flag) {
                {
#line 636
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"enter email headers:\n");
                }
              }
            } else
#line 639
            if (! quiet_flag) {
              {
#line 639
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"enter stamps to check one per line:\n");
              }
            }
#line 642
            tty_info = 1;
          }
        }
        {
#line 644
        tmp___37 = read_eof(stdin, ahead);
        }
#line 644
        if (tmp___37) {
#line 644
          goto while_break___9;
        }
        {
#line 645
        read_header(stdin, & line, & line_max, & line_alloc, ahead, 11265);
        }
#line 647
        if ((int )*(line + 0) == 0) {
#line 647
          goto __Cont;
        }
#line 648
        if (hdr_flag) {
          {
#line 649
          tmp___38 = strncasecmp((char const   *)line, (char const   *)(header), (size_t )hdr_len);
#line 649
          token_found = tmp___38 == 0;
          }
#line 651
          if (header2[0]) {
            {
#line 651
            tmp___39 = strncasecmp((char const   *)line, (char const   *)(header2),
                                   (size_t )hdr2_len);
            }
#line 651
            if (tmp___39 == 0) {
#line 651
              tmp___40 = 1;
            } else {
#line 651
              tmp___40 = 0;
            }
          } else {
#line 651
            tmp___40 = 0;
          }
#line 651
          token2_found = tmp___40;
#line 653
          if (token_found) {
            {
#line 654
            token[10771] = (char )'\000';
#line 654
            strncpy((char */* __restrict  */)(token), (char const   */* __restrict  */)(line + hdr_len),
                    (size_t )10771);
#line 655
            hdrs_found = 1;
            }
          } else
#line 656
          if (token2_found) {
            {
#line 657
            token[10771] = (char )'\000';
#line 657
            strncpy((char */* __restrict  */)(token), (char const   */* __restrict  */)(line + hdr2_len),
                    (size_t )10771);
#line 658
            hdrs_found = 1;
#line 659
            token_found = 1;
            }
          }
        } else {
          {
#line 662
          token_found = 1;
#line 663
          token[10771] = (char )'\000';
#line 663
          strncpy((char */* __restrict  */)(token), (char const   */* __restrict  */)line,
                  (size_t )10771);
          }
        }
        {
#line 665
        trimspace(token);
        }
      }
#line 670
      if (token_found) {
#line 671
        if (verbose_flag) {
          {
#line 671
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"examining token: %s\n",
                  token);
          }
        }
#line 673
        skip = 0;
#line 674
        over = 0;
#line 675
        accept = 0;
#line 676
        i = 0;
        {
#line 676
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 676
          if (i < resource.num) {
#line 676
            if (! (! skip)) {
#line 676
              goto while_break___10;
            }
          } else {
#line 676
            goto while_break___10;
          }
#line 677
          ent = resource.elt + i;
#line 681
          if (over) {
#line 681
            if (ent->over) {
#line 682
              if (multiple_resources) {
#line 683
                if (verbose_flag) {
                  {
#line 683
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"checking against resource: %s\n",
                          ent->str);
                  }
                }
              }
#line 686
              if (! quiet_flag) {
                {
#line 686
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"no match: overridden resource\n");
                }
              }
#line 687
              goto __Cont___0;
            }
          }
#line 690
          over = 0;
#line 692
          if (! ent->case_flag) {
            {
#line 692
            mystolower(ent->str);
            }
          }
#line 693
          if (bits_flag) {
#line 693
            tmp___41 = ent->bits;
          } else {
#line 693
            tmp___41 = 0;
          }
          {
#line 693
          tmp___42 = hashcash_check((char const   *)(token), ent->case_flag, (char const   *)ent->str,
                                    & ent->regexp, & re_err___0, ent->type, now_time,
                                    ent->validity, ent->grace, tmp___41, & token_time);
#line 693
          valid_for = (long )tmp___42;
          }
#line 701
          if (valid_for < 0L) {
            {
#line 705
            if (valid_for == -11L) {
#line 705
              goto case_neg_11;
            }
#line 709
            if (valid_for == -14L) {
#line 709
              goto case_neg_14;
            }
#line 718
            if (valid_for == -12L) {
#line 718
              goto case_neg_12;
            }
#line 725
            if (valid_for == -13L) {
#line 725
              goto case_neg_13;
            }
#line 733
            if (valid_for == -10L) {
#line 733
              goto case_neg_10;
            }
#line 740
            if (valid_for == -9L) {
#line 740
              goto case_neg_9;
            }
#line 702
            goto switch_break___1;
            case_neg_11: /* CIL Label */ 
#line 706
            if (! quiet_flag) {
              {
#line 706
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"skipped: token invalid\n");
              }
            }
#line 707
            skip = 1;
#line 707
            goto __Cont___0;
            case_neg_14: /* CIL Label */ 
#line 710
            if (! quiet_flag) {
              {
#line 710
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"skipped: unsupported version\n");
              }
            }
#line 711
            skip = 1;
#line 711
            goto __Cont___0;
            case_neg_12: /* CIL Label */ 
#line 719
            if (! multiple_resources) {
#line 720
              if (! quiet_flag) {
                {
#line 720
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"skipped: token with wrong resource\n");
                }
              }
#line 721
              skip = 1;
#line 721
              goto __Cont___0;
            }
#line 723
            goto switch_break___1;
            case_neg_13: /* CIL Label */ 
#line 726
            if (! multiple_bits) {
#line 726
              if (bits_flag) {
#line 727
                if (! quiet_flag) {
                  {
#line 727
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"skipped: token has insufficient bits\n");
                  }
                }
#line 729
                skip = 1;
#line 729
                goto __Cont___0;
              }
            }
#line 731
            goto switch_break___1;
            case_neg_10: /* CIL Label */ 
#line 734
            if (! multiple_validity) {
#line 734
              if (check_flag) {
#line 735
                if (! quiet_flag) {
                  {
#line 735
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"skipped: token expired\n");
                  }
                }
#line 736
                skip = 1;
#line 736
                goto __Cont___0;
              }
            }
#line 738
            goto switch_break___1;
            case_neg_9: /* CIL Label */ 
#line 741
            if (! multiple_grace) {
#line 741
              if (check_flag) {
#line 742
                if (! quiet_flag) {
                  {
#line 742
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"skipped: valid in future\n");
                  }
                }
#line 743
                skip = 1;
#line 743
                goto __Cont___0;
              }
            }
#line 745
            goto switch_break___1;
            switch_break___1: /* CIL Label */ ;
            }
          }
#line 749
          if (multiple_resources) {
#line 750
            if (verbose_flag) {
              {
#line 750
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"checking against resource: %s\n",
                      ent->str);
              }
            }
          }
#line 754
          if (valid_for >= 0L) {
#line 754
            goto while_break___10;
          }
#line 756
          if (width_flag) {
#line 757
            accept = 1;
          } else
#line 756
          if (left_flag) {
#line 757
            accept = 1;
          } else
#line 756
          if (name_flag) {
#line 757
            accept = 1;
          }
          {
#line 768
          if (valid_for == -13L) {
#line 768
            goto case_neg_13___0;
          }
#line 774
          if (valid_for == -9L) {
#line 774
            goto case_neg_9___0;
          }
#line 780
          if (valid_for == -10L) {
#line 780
            goto case_neg_10___0;
          }
#line 786
          if (valid_for == -12L) {
#line 786
            goto case_neg_12___0;
          }
#line 793
          if (valid_for == -17L) {
#line 793
            goto case_neg_17;
          }
#line 798
          goto switch_default___1;
          case_neg_13___0: /* CIL Label */ 
#line 769
          if (bits_flag) {
#line 770
            if (! quiet_flag) {
              {
#line 770
              fputs((char const   */* __restrict  */)"no match: token has insufficient bits\n",
                    (FILE */* __restrict  */)stderr);
              }
            }
#line 771
            over = 1;
#line 771
            accept = 0;
#line 771
            goto __Cont___0;
          }
#line 773
          goto switch_break___2;
          case_neg_9___0: /* CIL Label */ 
#line 775
          if (check_flag) {
#line 776
            if (! quiet_flag) {
              {
#line 776
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"no match: valid in future\n");
              }
            }
#line 777
            over = 1;
#line 777
            accept = 0;
#line 777
            goto __Cont___0;
          }
#line 779
          goto switch_break___2;
          case_neg_10___0: /* CIL Label */ 
#line 781
          if (check_flag) {
#line 782
            if (! quiet_flag) {
              {
#line 782
              fputs((char const   */* __restrict  */)"no match: token expired\n",
                    (FILE */* __restrict  */)stderr);
              }
            }
#line 783
            over = 1;
#line 783
            accept = 0;
#line 783
            goto __Cont___0;
          }
#line 785
          goto switch_break___2;
          case_neg_12___0: /* CIL Label */ 
#line 787
          if (! quiet_flag) {
            {
#line 787
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"no match: wrong resource\n");
            }
          }
#line 788
          accept = 0;
#line 789
          goto __Cont___0;
          case_neg_17: /* CIL Label */ 
          {
#line 794
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"regexp error: ");
#line 795
          die_msg((char const   *)re_err___0);
          }
#line 796
          goto switch_break___2;
          switch_default___1: /* CIL Label */ 
          {
#line 799
          die_msg("internal error");
          }
#line 800
          goto switch_break___2;
          switch_break___2: /* CIL Label */ ;
          }
          __Cont___0: /* CIL Label */ 
#line 676
          i ++;
        }
        while_break___10: /* CIL Label */ ;
        }
#line 804
        if (valid_for >= 0L) {
#line 804
          goto _L___12;
        } else
#line 804
        if (accept) {
          _L___12: /* CIL Label */ 
#line 805
          if (db_flag) {
#line 806
            if (! db_opened) {
              {
#line 807
              db_open(& db, db_filename);
#line 808
              db_opened = 1;
              }
            }
            {
#line 810
            tmp___43 = db_in(& db, token, token_utime);
            }
#line 810
            if (tmp___43) {
#line 811
              if (! quiet_flag) {
                {
#line 811
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"skipped: spent token\n");
                }
              }
#line 812
              valid_for = -15L;
#line 813
              goto __Cont;
            }
          }
#line 817
          if (! quiet_flag) {
            {
#line 817
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"matched token: %s\n",
                    token);
            }
          }
#line 819
          if (name_flag) {
#line 819
            goto _L___3;
          } else
#line 819
          if (verbose_flag) {
            _L___3: /* CIL Label */ 
#line 820
            if (ext) {
              {
#line 820
              free((void *)ext);
#line 820
              ext = (char *)((void *)0);
              }
            }
            {
#line 821
            hashcash_parse((char const   *)(token), & vers, & claimed_bits, utcttime,
                           13, token_resource, 256, & ext, 0);
#line 824
            parsed = 1;
            }
#line 825
            if (! quiet_flag) {
              {
#line 825
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"token resource name: %s\n",
                      token_resource);
              }
            }
#line 827
            if (! out_is_tty) {
              {
#line 827
              fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%s",
                      token_resource);
              }
            } else
#line 827
            if (quiet_flag) {
              {
#line 827
              fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%s",
                      token_resource);
              }
            }
          }
#line 830
          if (width_flag) {
#line 830
            goto _L___5;
          } else
#line 830
          if (verbose_flag) {
            _L___5: /* CIL Label */ 
            {
#line 831
            tmp___44 = hashcash_count((char const   *)(token));
#line 831
            count_bits = (int )tmp___44;
            }
#line 832
            if (! parsed) {
              {
#line 833
              hashcash_parse((char const   *)(token), & vers, & claimed_bits, utcttime,
                             13, token_resource, 256, & ext, 0);
#line 836
              parsed = 1;
              }
            }
#line 838
            if (vers == 1) {
#line 839
              if (count_bits < claimed_bits) {
#line 839
                count_bits = 0;
              } else {
#line 839
                count_bits = claimed_bits;
              }
            }
#line 842
            if (! quiet_flag) {
              {
#line 842
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"token value: %d\n",
                      count_bits);
              }
            }
#line 843
            if (name_flag) {
#line 843
              goto _L___4;
            } else
#line 843
            if (verbose_flag) {
              _L___4: /* CIL Label */ 
#line 844
              if (! out_is_tty) {
                {
#line 844
                fputs((char const   */* __restrict  */)" ", (FILE */* __restrict  */)stdout);
                }
              } else
#line 844
              if (quiet_flag) {
                {
#line 844
                fputs((char const   */* __restrict  */)" ", (FILE */* __restrict  */)stdout);
                }
              }
            }
#line 846
            if (! out_is_tty) {
              {
#line 846
              fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%d",
                      count_bits);
              }
            } else
#line 846
            if (quiet_flag) {
              {
#line 846
              fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%d",
                      count_bits);
              }
            }
          }
#line 849
          if (left_flag) {
#line 849
            goto _L___10;
          } else
#line 849
          if (verbose_flag) {
            _L___10: /* CIL Label */ 
#line 850
            if (! quiet_flag) {
              {
#line 850
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"valid: ");
              }
            }
#line 851
            if (valid_for > 0L) {
#line 852
              if (! quiet_flag) {
                {
#line 852
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"for %ld seconds\n",
                        valid_for);
                }
              }
#line 854
              if (name_flag) {
#line 854
                goto _L___6;
              } else
#line 854
              if (width_flag) {
                _L___6: /* CIL Label */ 
#line 855
                if (! out_is_tty) {
                  {
#line 855
                  fputs((char const   */* __restrict  */)" ", (FILE */* __restrict  */)stdout);
                  }
                } else
#line 855
                if (quiet_flag) {
                  {
#line 855
                  fputs((char const   */* __restrict  */)" ", (FILE */* __restrict  */)stdout);
                  }
                }
              }
#line 857
              if (! out_is_tty) {
                {
#line 857
                fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%ld",
                        valid_for);
                }
              } else
#line 857
              if (quiet_flag) {
                {
#line 857
                fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%ld",
                        valid_for);
                }
              }
            } else {
#line 859
              expiry_time = token_time + validity_period;
              {
#line 861
              if (valid_for == 0L) {
#line 861
                goto case_0;
              }
#line 868
              if (valid_for == -9L) {
#line 868
                goto case_neg_9___1;
              }
#line 877
              if (valid_for == -10L) {
#line 877
                goto case_neg_10___1;
              }
#line 886
              goto switch_default___2;
              case_0: /* CIL Label */ 
#line 862
              if (! quiet_flag) {
                {
#line 862
                fputs((char const   */* __restrict  */)"forever\n", (FILE */* __restrict  */)stderr);
                }
              }
#line 863
              if (name_flag) {
#line 863
                goto _L___7;
              } else
#line 863
              if (width_flag) {
                _L___7: /* CIL Label */ 
#line 864
                if (! out_is_tty) {
                  {
#line 864
                  fputs((char const   */* __restrict  */)" ", (FILE */* __restrict  */)stdout);
                  }
                } else
#line 864
                if (quiet_flag) {
                  {
#line 864
                  fputs((char const   */* __restrict  */)" ", (FILE */* __restrict  */)stdout);
                  }
                }
              }
#line 866
              if (! out_is_tty) {
                {
#line 866
                fputs((char const   */* __restrict  */)"0", (FILE */* __restrict  */)stdout);
                }
              } else
#line 866
              if (quiet_flag) {
                {
#line 866
                fputs((char const   */* __restrict  */)"0", (FILE */* __restrict  */)stdout);
                }
              }
#line 867
              goto switch_break___3;
              case_neg_9___1: /* CIL Label */ 
#line 869
              if (! quiet_flag) {
                {
#line 869
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"in %ld seconds\n",
                        token_time - (now_time + grace_period));
                }
              }
#line 871
              if (name_flag) {
#line 871
                goto _L___8;
              } else
#line 871
              if (width_flag) {
                _L___8: /* CIL Label */ 
#line 872
                if (! out_is_tty) {
                  {
#line 872
                  fputs((char const   */* __restrict  */)" ", (FILE */* __restrict  */)stdout);
                  }
                } else
#line 872
                if (quiet_flag) {
                  {
#line 872
                  fputs((char const   */* __restrict  */)" ", (FILE */* __restrict  */)stdout);
                  }
                }
              }
#line 874
              if (! out_is_tty) {
                {
#line 874
                fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"+%ld",
                        token_time - (now_time + grace_period));
                }
              } else
#line 874
              if (quiet_flag) {
                {
#line 874
                fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"+%ld",
                        token_time - (now_time + grace_period));
                }
              }
#line 876
              goto switch_break___3;
              case_neg_10___1: /* CIL Label */ 
#line 878
              if (! quiet_flag) {
                {
#line 878
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"expired %ld seconds ago\n",
                        now_time - (expiry_time + grace_period));
                }
              }
#line 880
              if (name_flag) {
#line 880
                goto _L___9;
              } else
#line 880
              if (width_flag) {
                _L___9: /* CIL Label */ 
#line 881
                if (! out_is_tty) {
                  {
#line 881
                  fputs((char const   */* __restrict  */)" ", (FILE */* __restrict  */)stdout);
                  }
                } else
#line 881
                if (quiet_flag) {
                  {
#line 881
                  fputs((char const   */* __restrict  */)" ", (FILE */* __restrict  */)stdout);
                  }
                }
              }
#line 883
              if (! out_is_tty) {
                {
#line 883
                fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"-%ld",
                        now_time - (expiry_time + grace_period));
                }
              } else
#line 883
              if (quiet_flag) {
                {
#line 883
                fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"-%ld",
                        now_time - (expiry_time + grace_period));
                }
              }
#line 885
              goto switch_break___3;
              switch_default___2: /* CIL Label */ 
#line 887
              if (! quiet_flag) {
                {
#line 887
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"not valid\n");
                }
              }
              switch_break___3: /* CIL Label */ ;
              }
            }
          }
#line 892
          if (name_flag) {
#line 892
            goto _L___11;
          } else
#line 892
          if (width_flag) {
#line 892
            goto _L___11;
          } else
#line 892
          if (left_flag) {
            _L___11: /* CIL Label */ 
#line 893
            if (! out_is_tty) {
              {
#line 893
              fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)stdout);
              }
            } else
#line 893
            if (quiet_flag) {
              {
#line 893
              fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)stdout);
              }
            }
#line 894
            goto __Cont;
          }
#line 897
          if (db_flag) {
#line 898
            if (verbose_flag) {
              {
#line 898
              fputs((char const   */* __restrict  */)"database: not double spent\n",
                    (FILE */* __restrict  */)stderr);
              }
            }
#line 900
            if (yes_flag) {
#line 900
              tmp___45 = 1;
            } else
#line 900
            if (res_flag) {
#line 900
              if (bits_flag) {
#line 900
                tmp___45 = 1;
              } else {
#line 900
                tmp___45 = 0;
              }
            } else {
#line 900
              tmp___45 = 0;
            }
#line 900
            checked = tmp___45;
#line 901
            if (checked) {
              {
#line 902
              sprintf((char */* __restrict  */)(period), (char const   */* __restrict  */)"%ld",
                      validity_period);
#line 903
              db_add(& db, token, period);
              }
            }
          } else {
#line 906
            checked = yes_flag;
          }
#line 908
          goto leave;
        }
      } else
#line 910
      if (hdr_flag) {
#line 910
        if (in_headers) {
#line 910
          if (! ignore_boundary_flag) {
#line 911
            if ((int )*(line + 0) == 0) {
#line 911
              boundary = 1;
            }
          }
        }
      }
      __Cont: /* CIL Label */ ;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 914
    if (! width_flag) {
#line 914
      if (! left_flag) {
#line 914
        if (! name_flag) {
#line 915
          if (hdr_flag) {
#line 915
            if (! hdrs_found) {
#line 916
              if (! quiet_flag) {
                {
#line 916
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"warning: no line matching %s found in input\n",
                        header);
                }
              }
            }
          }
#line 919
          if (! quiet_flag) {
            {
#line 919
            fputs((char const   */* __restrict  */)"rejected: no valid tokens found\n",
                  (FILE */* __restrict  */)stderr);
            }
          }
#line 920
          valid_for = -16L;
        }
      }
    }
    leave: 
#line 924
    if (width_flag) {
#line 924
      goto _L___13;
    } else
#line 924
    if (left_flag) {
#line 924
      goto _L___13;
    } else
#line 924
    if (name_flag) {
      _L___13: /* CIL Label */ 
#line 925
      if (yes_flag) {
#line 925
        tmp___46 = 0;
      } else {
#line 925
        tmp___46 = 2;
      }
      {
#line 925
      exit(tmp___46);
      }
    }
#line 927
    if (! quiet_flag) {
#line 927
      if (valid_for >= 0L) {
#line 927
        if (checked) {
#line 927
          tmp___47 = "ok";
        } else {
#line 927
          tmp___47 = "ok but not fully checked as";
        }
#line 927
        tmp___48 = tmp___47;
      } else {
#line 927
        tmp___48 = "failed";
      }
      {
#line 927
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"check: %s",
              tmp___48);
      }
    }
#line 931
    if (valid_for >= 0L) {
#line 932
      if (! checked) {
#line 933
        if (! bits_flag) {
#line 934
          comma = 1;
#line 934
          if (! quiet_flag) {
            {
#line 934
            fputs((char const   */* __restrict  */)" bits", (FILE */* __restrict  */)stderr);
            }
          }
        }
#line 936
        if (! check_flag) {
#line 937
          if (comma) {
#line 937
            if (! quiet_flag) {
              {
#line 937
              fputs((char const   */* __restrict  */)",", (FILE */* __restrict  */)stderr);
              }
            }
          }
#line 938
          comma = 1;
#line 938
          if (! quiet_flag) {
            {
#line 938
            fputs((char const   */* __restrict  */)" expiry", (FILE */* __restrict  */)stderr);
            }
          }
        }
#line 940
        if (! res_flag) {
#line 941
          if (comma) {
#line 941
            if (! quiet_flag) {
              {
#line 941
              fputs((char const   */* __restrict  */)",", (FILE */* __restrict  */)stderr);
              }
            }
          }
#line 942
          comma = 1;
#line 942
          if (! quiet_flag) {
            {
#line 942
            fputs((char const   */* __restrict  */)" resource", (FILE */* __restrict  */)stderr);
            }
          }
        }
#line 944
        if (! db_flag) {
#line 945
          if (comma) {
#line 945
            if (! quiet_flag) {
              {
#line 945
              fputs((char const   */* __restrict  */)",", (FILE */* __restrict  */)stderr);
              }
            }
          }
#line 946
          comma = 1;
#line 946
          if (! quiet_flag) {
            {
#line 946
            fputs((char const   */* __restrict  */)" database", (FILE */* __restrict  */)stderr);
            }
          }
        }
#line 948
        if (comma) {
#line 948
          if (! quiet_flag) {
            {
#line 948
            fputs((char const   */* __restrict  */)" not specified", (FILE */* __restrict  */)stderr);
            }
          }
        }
      }
    }
#line 951
    if (! quiet_flag) {
      {
#line 951
      fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)stderr);
      }
    }
#line 952
    if (valid_for < 0L) {
      {
#line 952
      exit(1);
      }
    }
#line 953
    if (checked) {
#line 953
      tmp___50 = 0;
    } else {
#line 953
      if (yes_flag) {
#line 953
        tmp___49 = 0;
      } else {
#line 953
        tmp___49 = 2;
      }
#line 953
      tmp___50 = tmp___49;
    }
    {
#line 953
    exit(tmp___50);
    }
  }
  {
#line 956
  exit(3);
  }
#line 957
  return (0);
}
}
#line 963 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/hashcash.c"
static int previous_percent  =    -1;
#line 964 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/hashcash.c"
static int previous_largest  ;
#line 960 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/hashcash.c"
int progress_callback(int percent , int largest , int target , double counter , double expected ,
                      void *user ) 
{ 
  double previous_counter ;

  {
#line 965
  previous_counter = (double )-1;
#line 966
  if (previous_counter != counter) {
    {
#line 968
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"percent: %.0lf/%.0lf = %d%% [%d/%d bits]\r",
            counter, expected, percent, largest, target);
#line 970
    previous_percent = percent;
#line 971
    previous_largest = largest;
#line 972
    previous_counter = counter;
    }
  } else
#line 966
  if (previous_percent != percent) {
    {
#line 968
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"percent: %.0lf/%.0lf = %d%% [%d/%d bits]\r",
            counter, expected, percent, largest, target);
#line 970
    previous_percent = percent;
#line 971
    previous_largest = largest;
#line 972
    previous_counter = counter;
    }
  } else
#line 966
  if (previous_largest != largest) {
    {
#line 968
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"percent: %.0lf/%.0lf = %d%% [%d/%d bits]\r",
            counter, expected, percent, largest, target);
#line 970
    previous_percent = percent;
#line 971
    previous_largest = largest;
#line 972
    previous_counter = counter;
    }
  }
#line 974
  return (1);
}
}
#line 977 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/hashcash.c"
int parse_period(char const   *aperiod , long *resp ) 
{ 
  int period_len ;
  char last_char ;
  long res ;
  char period_array[12] ;
  char *period ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  char *tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;

  {
#line 981
  res = 1L;
#line 983
  period = period_array;
#line 985
  if ((unsigned long )period == (unsigned long )((void *)0)) {
#line 985
    return (0);
  }
  {
#line 986
  tmp = strlen(aperiod);
#line 986
  period_len = (int )tmp;
  }
#line 987
  if (period_len == 0) {
#line 987
    return (0);
  }
  {
#line 988
  last_char = (char )*(aperiod + (period_len - 1));
#line 989
  tmp___0 = __ctype_b_loc();
  }
#line 989
  if (! ((int const   )*(*tmp___0 + (int )last_char) & 2048)) {
    {
#line 989
    tmp___1 = strchr("YyMdhmsw", (int )last_char);
    }
#line 989
    if (! tmp___1) {
#line 990
      return (0);
    }
  }
  {
#line 993
  *(period + 11) = (char )'\000';
#line 993
  strncpy((char */* __restrict  */)period, (char const   */* __restrict  */)aperiod,
          (size_t )11);
#line 995
  tmp___2 = __ctype_b_loc();
  }
#line 995
  if (! ((int const   )*(*tmp___2 + (int )last_char) & 2048)) {
#line 995
    period_len --;
#line 995
    *(period + period_len) = (char )'\000';
  }
#line 996
  if ((int )*(period + 0) == 43) {
#line 996
    goto _L;
  } else
#line 996
  if ((int )*(period + 0) == 45) {
    _L: /* CIL Label */ 
#line 997
    if ((int )*(period + 0) == 45) {
#line 997
      res = -1L;
    }
#line 998
    period ++;
#line 998
    period_len --;
  }
#line 1000
  if (period_len > 0) {
    {
#line 1000
    tmp___3 = atoi((char const   *)period);
#line 1000
    res *= (long )tmp___3;
    }
  }
  {
#line 1003
  if ((int )last_char == 115) {
#line 1003
    goto case_115;
  }
#line 1004
  if ((int )last_char == 109) {
#line 1004
    goto case_109;
  }
#line 1005
  if ((int )last_char == 104) {
#line 1005
    goto case_104;
  }
#line 1006
  if ((int )last_char == 100) {
#line 1006
    goto case_100;
  }
#line 1007
  if ((int )last_char == 119) {
#line 1007
    goto case_119;
  }
#line 1008
  if ((int )last_char == 77) {
#line 1008
    goto case_77;
  }
#line 1009
  if ((int )last_char == 89) {
#line 1009
    goto case_89;
  }
#line 1009
  if ((int )last_char == 121) {
#line 1009
    goto case_89;
  }
#line 1011
  if ((int )last_char == 57) {
#line 1011
    goto case_57;
  }
#line 1011
  if ((int )last_char == 56) {
#line 1011
    goto case_57;
  }
#line 1011
  if ((int )last_char == 55) {
#line 1011
    goto case_57;
  }
#line 1011
  if ((int )last_char == 54) {
#line 1011
    goto case_57;
  }
#line 1011
  if ((int )last_char == 53) {
#line 1011
    goto case_57;
  }
#line 1011
  if ((int )last_char == 52) {
#line 1011
    goto case_57;
  }
#line 1011
  if ((int )last_char == 51) {
#line 1011
    goto case_57;
  }
#line 1011
  if ((int )last_char == 50) {
#line 1011
    goto case_57;
  }
#line 1011
  if ((int )last_char == 49) {
#line 1011
    goto case_57;
  }
#line 1011
  if ((int )last_char == 48) {
#line 1011
    goto case_57;
  }
#line 1012
  goto switch_default;
  case_115: /* CIL Label */ 
#line 1003
  goto switch_break;
  case_109: /* CIL Label */ 
#line 1004
  res *= 60L;
#line 1004
  goto switch_break;
  case_104: /* CIL Label */ 
#line 1005
  res *= 3600L;
#line 1005
  goto switch_break;
  case_100: /* CIL Label */ 
#line 1006
  res *= 86400L;
#line 1006
  goto switch_break;
  case_119: /* CIL Label */ 
#line 1007
  res *= 604800L;
#line 1007
  goto switch_break;
  case_77: /* CIL Label */ 
#line 1008
  res *= 2628000L;
#line 1008
  goto switch_break;
  case_89: /* CIL Label */ 
  case_121: /* CIL Label */ 
#line 1009
  res *= 31536000L;
#line 1009
  goto switch_break;
  case_57: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_48: /* CIL Label */ 
#line 1011
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1012
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 1014
  *resp = res;
#line 1015
  return (1);
}
}
#line 1018 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/hashcash.c"
void usage(char const   *msg ) 
{ 


  {
#line 1020
  if (msg) {
    {
#line 1020
    fputs((char const   */* __restrict  */)msg, (FILE */* __restrict  */)stderr);
#line 1020
    fputs((char const   */* __restrict  */)"\n\n", (FILE */* __restrict  */)stderr);
    }
  }
  {
#line 1021
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mint:\t\thashcash [-m] [opts] resource\n");
#line 1022
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"measure speed:\thashcash -s [-b bits]\n");
#line 1023
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"check:\t\thashcash -c [opts] -d -r resource [-e period] [token]\n");
#line 1024
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"purge expired:\thashcash -p now [-k] [-j resource] [-t time] [-u]\n");
#line 1025
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"count bits:\thashcash -w [opts] [token]\n");
#line 1026
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"get resource:\thashcash -n [opts] [token]\n");
#line 1027
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"time remaining:\thashcash -l [opts] -e period [token]\n");
#line 1028
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 1029
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-b bits\t\tfind or check partial hash collision of length bits\n");
#line 1030
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-d\t\tuse database (for double spending detection)\n");
#line 1031
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-r resource\tresource name for minting or checking token\n");
#line 1032
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-o\t\tprevious resource overrides this resource\n");
#line 1033
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-e period\ttime until token expires\n");
#line 1034
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-g\t\tgrace period for clock skew\n");
#line 1035
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-t time\t\tmodify current time token created at\n");
#line 1036
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-a time\t\tmodify time by random amount in range given\n");
#line 1037
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-u\t\tgive time in UTC instead of local time\n");
#line 1038
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-q\t\tquiet -- suppress all informational output\n");
#line 1039
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-v\t\tprint verbose informational output\n");
#line 1040
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-h\t\tprint this usage info\n");
#line 1041
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-f dbfile\tuse filename dbfile for database\n");
#line 1042
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-j resource\twith -p delete just tokens matching the given resource\n");
#line 1043
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-k\t\twith -p delete all not just expired\n");
#line 1044
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-x ext\t\tput in extension field\n");
#line 1045
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-X\t\toutput with header format \'X-Hashcash: \'\n");
#line 1046
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-i\t\twith -X and -c, check msg body as well\n");
#line 1047
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-y\t\treturn success if token is valid but not fully checked\n");
#line 1048
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-z width\twidth of time field 6,10 or 12 chars (default 6)\n");
#line 1049
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-C\t\tmatch resources as case sensitive (default insensitive)\n");
#line 1050
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-S\t\tmatch following resources as text strings\n");
#line 1051
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-W\t\tmatch following resources with wildcards (default)\n");
#line 1052
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-E\t\tmatch following resources as regular expression\n");
#line 1053
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-P\t\tshow progress while searching\n");
#line 1054
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-O core\t\tuse specified minting core\n");
#line 1055
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t-Z n\t\t0 = fast (default), 1 = medium, 2 = small/slow\n");
#line 1056
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"examples:\n");
#line 1057
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\thashcash -mb20 foo                               # mint 20 bit collision\n");
#line 1058
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\thashcash -cdb20 -r foo 1:20:040806:foo::831d0c6f22eb81ff:15eae4 # check collision\n");
#line 1059
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 1060
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"see hashcash (1) man page or http://www.hashcash.org/ for more details.\n");
#line 1061
  fflush(stderr);
#line 1062
  exit(3);
  }
}
}
#line 1080 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/hashcash.c"
static int sdb_cb_token_matcher(char const   *key , char *val , void *argp , int *err ) 
{ 
  db_arg *arg ;
  char token_utime[14] ;
  unsigned int tmp ;
  char token_res[257] ;
  unsigned int tmp___0 ;
  char lower_token_res[257] ;
  unsigned int tmp___1 ;
  char *res ;
  time_t expires ;
  time_t expiry_period ;
  time_t created ;
  int vers ;
  int i ;
  int bits ;
  int matched ;
  int type ;
  int case_flag ;
  int lowered ;
  void **compile ;
  char *re_err___0 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  long tmp___8 ;

  {
#line 1082
  arg = (db_arg *)argp;
#line 1083
  token_utime[0] = (char)0;
#line 1083
  tmp = 1U;
  {
#line 1083
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1083
    if (tmp >= 14U) {
#line 1083
      goto while_break;
    }
#line 1083
    token_utime[tmp] = (char)0;
#line 1083
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1084
  token_res[0] = (char)0;
#line 1084
  tmp___0 = 1U;
  {
#line 1084
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1084
    if (tmp___0 >= 257U) {
#line 1084
      goto while_break___0;
    }
#line 1084
    token_res[tmp___0] = (char)0;
#line 1084
    tmp___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1084
  lower_token_res[0] = (char)0;
#line 1084
  tmp___1 = 1U;
  {
#line 1084
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1084
    if (tmp___1 >= 257U) {
#line 1084
      goto while_break___1;
    }
#line 1084
    lower_token_res[tmp___1] = (char)0;
#line 1084
    tmp___1 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1085
  res = (char *)((void *)0);
#line 1086
  expires = (time_t )0;
#line 1087
  expiry_period = (time_t )0;
#line 1088
  created = (time_t )0;
#line 1089
  vers = 0;
#line 1089
  i = 0;
#line 1089
  bits = 0;
#line 1089
  matched = 0;
#line 1089
  type = 0;
#line 1089
  case_flag = 0;
#line 1090
  lowered = 0;
#line 1091
  compile = (void **)((void *)0);
#line 1092
  re_err___0 = (char *)((void *)0);
#line 1094
  *err = 0;
#line 1095
  tmp___2 = strcmp(key, "last_purged");
  }
#line 1095
  if (tmp___2 == 0) {
    {
#line 1096
    *(val + 13) = (char )'\000';
#line 1096
    strncpy((char */* __restrict  */)val, (char const   */* __restrict  */)(arg->now_utime),
            (size_t )13);
    }
#line 1097
    return (1);
  }
  {
#line 1100
  tmp___3 = hashcash_parse(key, & vers, & bits, token_utime, 13, token_res, 256, (char **)((void *)0),
                           0);
  }
#line 1100
  if (! tmp___3) {
#line 1102
    *err = -1;
#line 1103
    return (0);
  }
#line 1105
  if (vers != 0) {
#line 1105
    if (vers != 1) {
#line 1106
      *err = -1;
#line 1107
      return (0);
    }
  }
#line 1110
  if ((arg->resource)->num > 0) {
#line 1111
    matched = 0;
#line 1112
    i = 0;
    {
#line 1112
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1112
      if (! matched) {
#line 1112
        if (! (i < (arg->resource)->num)) {
#line 1112
          goto while_break___2;
        }
      } else {
#line 1112
        goto while_break___2;
      }
#line 1113
      res = ((arg->resource)->elt + i)->str;
#line 1114
      type = ((arg->resource)->elt + i)->type;
#line 1115
      case_flag = ((arg->resource)->elt + i)->case_flag;
#line 1116
      compile = & ((arg->resource)->elt + i)->regexp;
#line 1117
      if (! case_flag) {
#line 1117
        if (! lowered) {
          {
#line 1118
          strncpy((char */* __restrict  */)(lower_token_res), (char const   */* __restrict  */)(token_res),
                  (size_t )256);
#line 1119
          mystolower(lower_token_res);
#line 1120
          lowered = 1;
          }
        }
      }
#line 1122
      if (case_flag) {
#line 1122
        tmp___4 = token_res;
      } else {
#line 1122
        tmp___4 = lower_token_res;
      }
      {
#line 1122
      matched = hashcash_resource_match(type, (char const   *)tmp___4, (char const   *)res,
                                        compile, & re_err___0);
      }
#line 1125
      if ((unsigned long )re_err___0 != (unsigned long )((void *)0)) {
        {
#line 1126
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"regexp error: ");
#line 1127
        die_msg((char const   *)re_err___0);
        }
      }
#line 1112
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1130
    if (! matched) {
#line 1130
      return (1);
    }
  }
#line 1132
  if (arg->all) {
#line 1132
    return (0);
  }
#line 1133
  if ((int )*(val + 0) == 48) {
#line 1133
    if ((int )*(val + 1) == 0) {
#line 1133
      return (1);
    }
  }
  {
#line 1134
  tmp___5 = strlen((char const   *)val);
#line 1134
  tmp___6 = strspn((char const   *)val, "0123456789");
  }
#line 1134
  if (tmp___5 != tmp___6) {
#line 1135
    *err = -1;
#line 1135
    return (0);
  }
  {
#line 1137
  tmp___7 = atoi((char const   *)val);
#line 1137
  expiry_period = (time_t )tmp___7;
  }
#line 1138
  if (expiry_period < 0L) {
#line 1138
    *err = -1;
#line 1138
    return (0);
  }
  {
#line 1139
  created = hashcash_from_utctimestr((char const   *)(token_utime), 1);
  }
#line 1140
  if (created < 0L) {
#line 1140
    *err = -1;
#line 1140
    return (0);
  }
#line 1141
  if (arg->validity) {
#line 1141
    tmp___8 = arg->validity;
  } else {
#line 1141
    tmp___8 = expiry_period;
  }
#line 1141
  expires = (created + tmp___8) + arg->grace;
#line 1143
  if (expires <= arg->expires_before) {
#line 1143
    return (0);
  }
#line 1144
  return (1);
}
}
#line 1147 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/hashcash.c"
int hashcash_db_purge(DB *db , char const   *purge_resource , int type , int case_flag ,
                      long validity_period , long grace_period , int purge_all , long purge_period ,
                      time_t now_time , int *err ) 
{ 
  ARRAY *purge_resource_arr ;
  int tmp ;

  {
  {
#line 1151
  purge_resource_arr = (ARRAY *)((void *)0);
#line 1152
  array_alloc(purge_resource_arr, 1);
#line 1153
  array_push(purge_resource_arr, purge_resource, type, case_flag, validity_period,
             grace_period, 0L, 0, 0, 0);
#line 1155
  tmp = db_purge(db, purge_resource_arr, purge_all, purge_period, now_time, validity_period,
                 grace_period, 0, err);
  }
#line 1155
  return (tmp);
}
}
#line 1159 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/hashcash.c"
void db_purge_arr(DB *db , ARRAY *purge_resource , int purge_all , long purge_period ,
                  time_t now_time , long validity_period , long grace_period ) 
{ 
  int res ;
  int err ;

  {
  {
#line 1162
  err = 0;
#line 1163
  res = db_purge(db, purge_resource, purge_all, purge_period, now_time, validity_period,
                 grace_period, verbose_flag, & err);
  }
  {
#line 1166
  if (res == -3) {
#line 1166
    goto case_neg_3;
  }
#line 1168
  if (res == 0) {
#line 1168
    goto case_0;
  }
#line 1169
  if (res == 1) {
#line 1169
    goto case_1;
  }
#line 1170
  goto switch_default;
  case_neg_3: /* CIL Label */ 
  {
#line 1167
  die_msg("error: invalid time argument");
  }
#line 1167
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 1168
  die(err);
  }
#line 1168
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1169
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1170
  die(err);
  }
  switch_break: /* CIL Label */ ;
  }
#line 1172
  return;
}
}
#line 1174 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/hashcash.c"
int db_purge(DB *db , ARRAY *purge_resource , int purge_all , long purge_period ,
             time_t now_time , long validity_period , long grace_period , int verbose ,
             int *err ) 
{ 
  time_t last_time ;
  char purge_utime[14] ;
  unsigned int tmp ;
  int ret ;
  db_arg arg ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;

  {
#line 1177
  last_time = (time_t )0;
#line 1178
  purge_utime[0] = (char)0;
#line 1178
  tmp = 1U;
  {
#line 1178
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1178
    if (tmp >= 14U) {
#line 1178
      goto while_break;
    }
#line 1178
    purge_utime[tmp] = (char)0;
#line 1178
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1179
  ret = 0;
#line 1182
  if (now_time < 0L) {
#line 1182
    return (-3);
  }
  {
#line 1184
  tmp___0 = sdb_lookup(db, "last_purged", purge_utime, 13, err);
  }
#line 1184
  if (! tmp___0) {
#line 1185
    return (0);
  }
  {
#line 1188
  last_time = hashcash_from_utctimestr((char const   *)(purge_utime), 1);
  }
#line 1189
  if (last_time < 0L) {
#line 1190
    purge_period = 0L;
  }
  {
#line 1193
  tmp___1 = hashcash_to_utctimestr((char *)(arg.now_utime), 13, now_time);
  }
#line 1193
  if (! tmp___1) {
#line 1194
    return (-3);
  }
#line 1197
  arg.expires_before = now_time;
#line 1198
  arg.resource = purge_resource;
#line 1199
  arg.all = purge_all;
#line 1200
  arg.validity = validity_period;
#line 1201
  arg.grace = grace_period;
#line 1203
  if (purge_period == 0L) {
#line 1203
    goto _L;
  } else
#line 1203
  if (now_time >= last_time + purge_period) {
    _L: /* CIL Label */ 
#line 1204
    if (verbose_flag) {
      {
#line 1204
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"purging database: ...");
      }
    }
    {
#line 1205
    ret = sdb_updateiterate(db, & sdb_cb_token_matcher, (void *)(& arg), err);
    }
#line 1206
    if (verbose_flag) {
#line 1206
      if (ret) {
#line 1206
        tmp___2 = "done\n";
      } else {
#line 1206
        tmp___2 = "failed\n";
      }
      {
#line 1206
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___2);
      }
    }
  } else {
#line 1208
    ret = 1;
  }
#line 1210
  return (ret);
}
}
#line 1213 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/hashcash.c"
void db_open(DB *db , char const   *db_filename ) 
{ 
  int err ;
  int tmp ;

  {
  {
#line 1215
  tmp = hashcash_db_open(db, db_filename, & err);
  }
#line 1215
  if (! tmp) {
    {
#line 1215
    die(err);
    }
  }
#line 1216
  return;
}
}
#line 1218 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/hashcash.c"
int db_in(DB *db , char *token , char *period ) 
{ 
  int err ;
  int res ;

  {
  {
#line 1219
  err = 0;
#line 1222
  res = hashcash_db_in(db, token, period, & err);
  }
#line 1223
  if (err) {
    {
#line 1223
    die(err);
    }
  }
#line 1224
  return (res);
}
}
#line 1227 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/hashcash.c"
void db_add(DB *db , char *token , char *period ) 
{ 
  int err ;
  int tmp ;

  {
  {
#line 1228
  err = 0;
#line 1229
  tmp = hashcash_db_add(db, token, period, & err);
  }
#line 1229
  if (! tmp) {
    {
#line 1230
    die(err);
    }
  }
#line 1232
  return;
}
}
#line 1234 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/hashcash.c"
void db_close(DB *db ) 
{ 
  int err ;
  int tmp ;

  {
  {
#line 1235
  err = 0;
#line 1236
  tmp = hashcash_db_close(db, & err);
  }
#line 1236
  if (! tmp) {
    {
#line 1237
    die(err);
    }
  }
#line 1239
  return;
}
}
#line 1243 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/hashcash.c"
void array_alloc(ARRAY *array , int num ) 
{ 
  void *tmp ;

  {
  {
#line 1244
  array->num = 0;
#line 1245
  array->max = num;
#line 1246
  tmp = malloc(sizeof(ELEMENT ) * (unsigned long )num);
#line 1246
  array->elt = (ELEMENT *)tmp;
  }
#line 1247
  if ((unsigned long )array->elt == (unsigned long )((void *)0)) {
    {
#line 1247
    die_msg("out of memory");
    }
  }
#line 1248
  return;
}
}
#line 1252 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/hashcash.c"
void array_push(ARRAY *array , char const   *str , int type , int case_flag , long validity ,
                long grace , long anon , int width , int bits , int over ) 
{ 
  void *tmp ;

  {
#line 1256
  if (array->num >= array->max) {
    {
#line 1257
    tmp = realloc((void *)array->elt, (sizeof(ELEMENT ) * (unsigned long )array->max) * 2UL);
#line 1257
    array->elt = (ELEMENT *)tmp;
    }
#line 1258
    if ((unsigned long )array->elt == (unsigned long )((void *)0)) {
      {
#line 1258
      die_msg("out of memory");
      }
    }
#line 1259
    array->max *= 2;
  }
#line 1261
  (array->elt + array->num)->regexp = (void *)0;
#line 1262
  (array->elt + array->num)->type = type;
#line 1263
  (array->elt + array->num)->case_flag = case_flag;
#line 1264
  (array->elt + array->num)->validity = validity;
#line 1265
  (array->elt + array->num)->grace = grace;
#line 1266
  (array->elt + array->num)->anon = anon;
#line 1267
  (array->elt + array->num)->width = width;
#line 1268
  (array->elt + array->num)->bits = bits;
#line 1269
  (array->elt + array->num)->over = over;
#line 1270
  if (str) {
    {
#line 1271
    (array->elt + array->num)->str = strdup(str);
    }
#line 1272
    if ((unsigned long )(array->elt + array->num)->str == (unsigned long )((void *)0)) {
      {
#line 1273
      die_msg("out of memory");
      }
    }
  } else {
#line 1276
    (array->elt + array->num)->str = (char *)((void *)0);
  }
#line 1278
  (array->num) ++;
#line 1279
  return;
}
}
#line 1281 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/hashcash.c"
int bit_cmp(void const   *ap , void const   *bp ) 
{ 
  ELEMENT *a ;
  ELEMENT *b ;
  int tmp ;
  int tmp___0 ;

  {
#line 1283
  a = (ELEMENT *)ap;
#line 1284
  b = (ELEMENT *)bp;
#line 1286
  if (a->bits == b->bits) {
#line 1286
    tmp___0 = 0;
  } else {
#line 1286
    if (a->bits < b->bits) {
#line 1286
      tmp = 1;
    } else {
#line 1286
      tmp = -1;
    }
#line 1286
    tmp___0 = tmp;
  }
#line 1286
  return (tmp___0);
}
}
#line 1289 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/hashcash.c"
void array_sort(ARRAY *array , int (*cmp)(void const   * , void const   * ) ) 
{ 


  {
  {
#line 1291
  qsort((void *)array->elt, (size_t )array->num, sizeof(ELEMENT ), cmp);
  }
#line 1292
  return;
}
}
#line 1294 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/hashcash.c"
void die(int err ) 
{ 
  char const   *str ;
  char *tmp ;

  {
#line 1296
  str = "";
  {
#line 1299
  if (err == 0) {
#line 1299
    goto case_0;
  }
#line 1302
  if (err == -1) {
#line 1302
    goto case_neg_1;
  }
#line 1305
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1300
  exit(0);
  }
#line 1301
  goto switch_break;
  case_neg_1: /* CIL Label */ 
#line 1303
  str = "invalid inputs";
#line 1304
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1306
  tmp = strerror(err);
#line 1306
  str = (char const   *)tmp;
  }
#line 1307
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1309
  if (! quiet_flag) {
    {
#line 1309
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error: %s\n",
            str);
    }
  }
  {
#line 1310
  exit(3);
  }
}
}
#line 1313 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/hashcash.c"
void die_msg(char const   *str ) 
{ 


  {
#line 1315
  if (! quiet_flag) {
    {
#line 1315
    fputs((char const   */* __restrict  */)str, (FILE */* __restrict  */)stderr);
    }
  }
#line 1316
  if (! quiet_flag) {
    {
#line 1316
    fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)stderr);
    }
  }
  {
#line 1317
  exit(3);
  }
}
}
#line 1322 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/hashcash.c"
void chomplf(char *token ) 
{ 
  int tok_len ;
  size_t tmp ;

  {
  {
#line 1323
  tmp = strlen((char const   *)token);
#line 1323
  tok_len = (int )tmp;
  }
#line 1324
  if ((int )*(token + (tok_len - 1)) == 10) {
#line 1324
    tok_len --;
#line 1324
    *(token + tok_len) = (char )'\000';
  }
#line 1325
  if ((int )*(token + (tok_len - 1)) == 13) {
#line 1325
    tok_len --;
#line 1325
    *(token + tok_len) = (char )'\000';
  }
#line 1326
  if ((int )*(token + (tok_len - 1)) == 10) {
#line 1326
    tok_len --;
#line 1326
    *(token + tok_len) = (char )'\000';
  }
#line 1327
  return;
}
}
#line 1329 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/hashcash.c"
void trimspace(char *token ) 
{ 
  int tok_len ;
  size_t tmp ;
  int tok_begin ;
  unsigned short const   **tmp___0 ;
  size_t tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
  {
#line 1330
  tmp = strlen((char const   *)token);
#line 1330
  tok_len = (int )tmp;
#line 1331
  tok_begin = 0;
  }
  {
#line 1332
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1332
    if (tok_begin < tok_len) {
      {
#line 1332
      tmp___0 = __ctype_b_loc();
      }
#line 1332
      if (! ((int const   )*(*tmp___0 + (int )*(token + tok_begin)) & 8192)) {
#line 1332
        goto while_break;
      }
    } else {
#line 1332
      goto while_break;
    }
#line 1333
    tok_begin ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1335
  if (tok_begin > 0) {
    {
#line 1336
    tok_len -= tok_begin;
#line 1337
    tmp___1 = strlen((char const   *)(token + tok_begin));
#line 1337
    memmove((void *)token, (void const   *)(token + tok_begin), tmp___1 + 1UL);
    }
  }
  {
#line 1339
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1339
    if (tok_len > 0) {
      {
#line 1339
      tmp___2 = __ctype_b_loc();
      }
#line 1339
      if (! ((int const   )*(*tmp___2 + (int )*(token + (tok_len - 1))) & 8192)) {
#line 1339
        goto while_break___0;
      }
    } else {
#line 1339
      goto while_break___0;
    }
#line 1340
    tok_len --;
#line 1340
    *(token + tok_len) = (char )'\000';
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1342
  return;
}
}
#line 1344 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/hashcash.c"
double report_speed(int bits , double *time_est , int display ) 
{ 
  double te ;
  double tries_expected ;
  double tmp ;
  double tmp___0 ;
  unsigned long tmp___1 ;
  double tmp___2 ;
  unsigned long tmp___3 ;

  {
  {
#line 1346
  te = (double )0;
#line 1347
  tmp = hashcash_expected_tries(bits);
#line 1347
  tries_expected = tmp;
  }
#line 1349
  if (verbose_flag) {
    {
#line 1349
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mint: %d bit partial hash collision\n",
            bits);
    }
  }
#line 1350
  if (verbose_flag) {
    {
#line 1350
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"expected: %.0f tries (= 2^%d tries)\n",
            tries_expected, bits);
    }
  }
#line 1353
  if (time_est) {
    {
#line 1353
    tmp___0 = hashcash_expected_tries(bits);
#line 1353
    tmp___1 = hashcash_per_sec();
#line 1353
    *time_est = tmp___0 / (double )tmp___1;
    }
  }
#line 1355
  if (display) {
    {
#line 1356
    tmp___2 = hashcash_expected_tries(bits);
#line 1356
    tmp___3 = hashcash_per_sec();
#line 1356
    te = tmp___2 / (double )tmp___3;
    }
#line 1357
    if (! quiet_flag) {
      {
#line 1357
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"time estimate: %.0f seconds",
              te);
      }
    }
#line 1358
    if (te > (double )31536000 * 1000000000.0) {
#line 1359
      if (! quiet_flag) {
        {
#line 1359
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" (%.0f aeons)",
                te / ((double )31536000 * 1000000000.0));
        }
      }
    } else
#line 1360
    if (te > (double )315360000) {
#line 1361
      if (! quiet_flag) {
        {
#line 1361
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" (%.0f years)",
                te / (double )31536000);
        }
      }
    } else
#line 1362
    if (te > (double )31536000) {
#line 1363
      if (! quiet_flag) {
        {
#line 1363
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" (%.1f years)",
                te / (double )31536000);
        }
      }
    } else
#line 1364
    if (te > (double )2628000) {
#line 1365
      if (! quiet_flag) {
        {
#line 1365
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" (%.1f months)",
                te / (double )2628000);
        }
      }
    } else
#line 1366
    if (te > (double )864000) {
#line 1367
      if (! quiet_flag) {
        {
#line 1367
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" (%.0f days)",
                te / (double )86400);
        }
      }
    } else
#line 1368
    if (te > (double )86400) {
#line 1369
      if (! quiet_flag) {
        {
#line 1369
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" (%.1f days)",
                te / (double )86400);
        }
      }
    } else
#line 1370
    if (te > (double )3600) {
#line 1371
      if (! quiet_flag) {
        {
#line 1371
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" (%.0f hours)",
                te / (double )3600);
        }
      }
    } else
#line 1372
    if (te > (double )60) {
#line 1373
      if (! quiet_flag) {
        {
#line 1373
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" (%.0f minutes)",
                te / (double )60);
        }
      }
    } else
#line 1374
    if (! (te > (double )1)) {
#line 1376
      if (te > 1.0 / (double )1000) {
#line 1377
        if (! quiet_flag) {
          {
#line 1377
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" (%.0f milli-seconds)",
                  te / (1.0 / (double )1000));
          }
        }
      } else
#line 1379
      if (te > (1.0 / (double )1000) / (double )1000) {
#line 1380
        if (! quiet_flag) {
          {
#line 1380
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" (%.0f micro-seconds)",
                  te / ((1.0 / (double )1000) / (double )1000));
          }
        }
      } else
#line 1382
      if (te > ((1.0 / (double )1000) / (double )1000) / (double )1000) {
#line 1383
        if (! quiet_flag) {
          {
#line 1383
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" (%.0f nano-seconds)",
                  te / (((1.0 / (double )1000) / (double )1000) / (double )1000));
          }
        }
      }
    }
#line 1386
    if (! quiet_flag) {
      {
#line 1386
      fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)stderr);
      }
    }
  }
#line 1388
  return (tries_expected);
}
}
#line 1391 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/hashcash.c"
int read_append(char **s , int *smax , int *alloc , char *append ) 
{ 
  int slen ;
  size_t tmp ;
  int alen ;
  size_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 1393
  tmp = strlen((char const   *)*s);
#line 1393
  slen = (int )tmp;
#line 1394
  tmp___0 = strlen((char const   *)append);
#line 1394
  alen = (int )tmp___0;
  }
#line 1396
  if (slen + alen > *smax) {
#line 1397
    if (*alloc) {
      {
#line 1398
      tmp___1 = realloc((void *)*s, (size_t )((slen + alen) + 1));
#line 1398
      *s = (char *)tmp___1;
      }
    } else {
      {
#line 1400
      tmp___2 = malloc((size_t )((slen + alen) + 1));
#line 1400
      *s = (char *)tmp___2;
#line 1401
      *alloc = 1;
      }
    }
#line 1403
    if ((unsigned long )*s == (unsigned long )((void *)0)) {
#line 1403
      return (0);
    }
  }
  {
#line 1405
  *((*s + slen) + alen) = (char )'\000';
#line 1405
  strncpy((char */* __restrict  */)(*s + slen), (char const   */* __restrict  */)append,
          (size_t )alen);
  }
#line 1406
  return (1);
}
}
#line 1409 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/hashcash.c"
char *read_header(FILE *f , char **s , int *smax , int *alloc , char *a , int amax ) 
{ 
  char *junk ;

  {
#line 1414
  *(*s + 0) = (char )'\000';
#line 1415
  if (*(a + 0)) {
    {
#line 1416
    *(*s + *smax) = (char )'\000';
#line 1416
    strncpy((char */* __restrict  */)*s, (char const   */* __restrict  */)a, (size_t )*smax);
    }
  } else {
    {
#line 1418
    junk = fgets((char */* __restrict  */)*s, *smax, (FILE */* __restrict  */)f);
#line 1419
    chomplf(*s);
    }
  }
  {
#line 1422
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1423
    *(a + 0) = (char )'\000';
#line 1424
    junk = fgets((char */* __restrict  */)a, amax, (FILE */* __restrict  */)f);
#line 1425
    chomplf(a);
    }
#line 1426
    if ((int )*(a + 0) == 9) {
      {
#line 1427
      read_append(s, smax, alloc, a + 1);
      }
    } else
#line 1426
    if ((int )*(a + 0) == 32) {
      {
#line 1427
      read_append(s, smax, alloc, a + 1);
      }
    }
#line 1422
    if (! ((int )*(a + 0) == 9)) {
#line 1422
      if (! ((int )*(a + 0) == 32)) {
#line 1422
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1431
  return (*s);
}
}
#line 1434 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/hashcash.c"
int read_eof(FILE *fp , char *a ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1436
  tmp = feof(fp);
  }
#line 1436
  if (tmp) {
#line 1436
    if ((int )*(a + 0) == 0) {
#line 1436
      tmp___0 = 1;
    } else {
#line 1436
      tmp___0 = 0;
    }
  } else {
#line 1436
    tmp___0 = 0;
  }
#line 1436
  return (tmp___0);
}
}
#line 1439 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/hashcash.c"
void mystolower(char *str ) 
{ 
  int tmp ;

  {
#line 1440
  if (! str) {
#line 1440
    return;
  }
  {
#line 1441
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1441
    if (! *str) {
#line 1441
      goto while_break;
    }
    {
#line 1442
    tmp = tolower((int )*str);
#line 1442
    *str = (char )tmp;
#line 1441
    str ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1444
  return;
}
}
#line 146 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libfastmint.h"
unsigned long minter_ansi_compact_1(int bits , int *best , unsigned char *block ,
                                    uInt32 const   *IV , int tailIndex , unsigned long maxIter ,
                                    int (*cb)(int percent , int largest , int target ,
                                              double count , double expected , void *user ) ,
                                    void *user_args , double counter , double expected ) ;
#line 147
int minter_ansi_compact_1_test(void) ;
#line 6 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/fastmint_ansi_compact_1.c"
int minter_ansi_compact_1_test(void) 
{ 


  {
#line 9
  return (1);
}
}
#line 56 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/fastmint_ansi_compact_1.c"
static int const   endTest___1  =    (int const   )3;
#line 44 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/fastmint_ansi_compact_1.c"
unsigned long minter_ansi_compact_1(int bits , int *best , unsigned char *block ,
                                    uInt32 const   *IV , int tailIndex , unsigned long maxIter ,
                                    int (*cb)(int percent , int largest , int target ,
                                              double count , double expected , void *user ) ,
                                    void *user_args , double counter , double expected ) 
{ 
  double percent ;
  struct timeval prev ;
  struct timeval curr ;
  int lastBits ;
  unsigned long iters ;
  int t ;
  int gotBits ;
  int maxBits ;
  int tmp ;
  uInt32 bitMask1Low ;
  uInt32 bitMask1High ;
  uInt32 s ;
  uInt32 A ;
  uInt32 B ;
  uInt32 C ;
  uInt32 D ;
  uInt32 E ;
  uInt32 W[80] ;
  unsigned int tmp___0 ;
  uInt32 H[5] ;
  unsigned int tmp___1 ;
  uInt32 pH[5] ;
  unsigned int tmp___2 ;
  char const   *p ;
  unsigned char *X ;
  int addressMask ;
  unsigned char *output ;
  uInt32 tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 46
  prev.tv_sec = (__time_t )0;
#line 46
  prev.tv_usec = (__suseconds_t )0;
#line 46
  lastBits = 0;
#line 47
  iters = 0UL;
#line 48
  t = 0;
#line 48
  gotBits = 0;
#line 48
  if (bits > 16) {
#line 48
    tmp = 16;
  } else {
#line 48
    tmp = bits;
  }
#line 48
  maxBits = tmp;
#line 49
  bitMask1Low = (uInt32 )0;
#line 49
  bitMask1High = (uInt32 )0;
#line 49
  s = (uInt32 )0;
#line 50
  A = (uInt32 )0;
#line 50
  B = (uInt32 )0;
#line 50
  C = (uInt32 )0;
#line 50
  D = (uInt32 )0;
#line 50
  E = (uInt32 )0;
#line 51
  W[0] = (uInt32 )0;
#line 51
  tmp___0 = 1U;
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
#line 51
    if (tmp___0 >= 80U) {
#line 51
      goto while_break;
    }
#line 51
    W[tmp___0] = 0U;
#line 51
    tmp___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 52
  H[0] = (uInt32 )0;
#line 52
  tmp___1 = 1U;
  {
#line 52
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 52
    if (tmp___1 >= 5U) {
#line 52
      goto while_break___0;
    }
#line 52
    H[tmp___1] = 0U;
#line 52
    tmp___1 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 52
  pH[0] = (uInt32 )0;
#line 52
  tmp___2 = 1U;
  {
#line 52
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 52
    if (tmp___2 >= 5U) {
#line 52
      goto while_break___1;
    }
#line 52
    pH[tmp___2] = 0U;
#line 52
    tmp___2 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 53
  p = encodeAlphabets[4];
#line 54
  X = (unsigned char *)(W);
#line 55
  addressMask = 0;
#line 57
  output = block;
#line 59
  *best = 0;
#line 62
  addressMask = (int )*((char *)(& endTest___1));
#line 65
  if (maxBits < 32) {
#line 66
    if (bits == 0) {
#line 66
      bitMask1Low = (uInt32 )0;
    } else {
#line 67
      bitMask1Low = ~ ((1U << (32 - maxBits)) - 1U);
    }
#line 69
    bitMask1High = (uInt32 )0;
  } else {
#line 71
    bitMask1Low = (uInt32 )(~ 0);
#line 72
    bitMask1High = ~ ((1U << (64 - maxBits)) - 1U);
  }
#line 74
  maxBits = 0;
#line 77
  t = 0;
  {
#line 77
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 77
    if (! (t < 16)) {
#line 77
      goto while_break___2;
    }
#line 78
    W[t] = (uInt32 )(((((int )*((output + t * 4) + 0) << 24) | ((int )*((output + t * 4) + 1) << 16)) | ((int )*((output + t * 4) + 2) << 8)) | (int )*((output + t * 4) + 3));
#line 77
    t ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 79
  t = 0;
  {
#line 79
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 79
    if (! (t < 5)) {
#line 79
      goto while_break___3;
    }
#line 80
    tmp___3 = (uInt32 )*(IV + t);
#line 80
    H[t] = tmp___3;
#line 80
    pH[t] = tmp___3;
#line 79
    t ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 83
  iters = 0UL;
  {
#line 83
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 83
    if (! (iters < maxIter)) {
#line 83
      goto while_break___4;
    }
#line 86
    *(X + ((tailIndex - 1) ^ addressMask)) = (unsigned char )*(p + (iters & 63UL));
#line 87
    if (! (iters & 63UL)) {
#line 88
      if (iters >> 6) {
#line 89
        *(X + ((tailIndex - 2) ^ addressMask)) = (unsigned char )*(p + ((iters >> 6) & 63UL));
      }
#line 91
      if (iters >> 12) {
#line 92
        *(X + ((tailIndex - 3) ^ addressMask)) = (unsigned char )*(p + ((iters >> 12) & 63UL));
      }
#line 94
      if (iters >> 18) {
#line 95
        *(X + ((tailIndex - 4) ^ addressMask)) = (unsigned char )*(p + ((iters >> 18) & 63UL));
      }
#line 97
      if (iters >> 24) {
#line 98
        *(X + ((tailIndex - 5) ^ addressMask)) = (unsigned char )*(p + ((iters >> 24) & 63UL));
      }
#line 100
      if (iters >> 30) {
#line 101
        *(X + ((tailIndex - 6) ^ addressMask)) = (unsigned char )*(p + ((iters >> 30) & 63UL));
      }
    }
#line 106
    if (! (iters & 16777215UL)) {
#line 106
      if (tailIndex == 52) {
#line 106
        goto _L;
      } else
#line 106
      if (tailIndex == 32) {
        _L: /* CIL Label */ 
#line 107
        A = H[0];
#line 108
        B = H[1];
#line 109
        C = H[2];
#line 110
        D = H[3];
#line 111
        E = H[4];
#line 113
        t = 16;
        {
#line 113
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 113
          if (! (t < 32)) {
#line 113
            goto while_break___5;
          }
#line 114
          W[t] = ((((W[t - 16] ^ W[t - 14]) ^ W[t - 8]) ^ W[t - 3]) << 1) | ((((W[t - 16] ^ W[t - 14]) ^ W[t - 8]) ^ W[t - 3]) >> 31);
#line 113
          t ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 116
        E += ((((A << 5) | (A >> 27)) + (D ^ (B & (C ^ D)))) + W[0]) + 1518500249U;
#line 116
        B = (B << 30) | (B >> 2);
#line 117
        D += ((((E << 5) | (E >> 27)) + (C ^ (A & (B ^ C)))) + W[1]) + 1518500249U;
#line 117
        A = (A << 30) | (A >> 2);
#line 118
        C += ((((D << 5) | (D >> 27)) + (B ^ (E & (A ^ B)))) + W[2]) + 1518500249U;
#line 118
        E = (E << 30) | (E >> 2);
#line 119
        B += ((((C << 5) | (C >> 27)) + (A ^ (D & (E ^ A)))) + W[3]) + 1518500249U;
#line 119
        D = (D << 30) | (D >> 2);
#line 120
        A += ((((B << 5) | (B >> 27)) + (E ^ (C & (D ^ E)))) + W[4]) + 1518500249U;
#line 120
        C = (C << 30) | (C >> 2);
#line 121
        E += ((((A << 5) | (A >> 27)) + (D ^ (B & (C ^ D)))) + W[5]) + 1518500249U;
#line 121
        B = (B << 30) | (B >> 2);
#line 122
        D += ((((E << 5) | (E >> 27)) + (C ^ (A & (B ^ C)))) + W[6]) + 1518500249U;
#line 122
        A = (A << 30) | (A >> 2);
#line 124
        if (tailIndex == 52) {
#line 125
          C += ((((D << 5) | (D >> 27)) + (B ^ (E & (A ^ B)))) + W[7]) + 1518500249U;
#line 125
          E = (E << 30) | (E >> 2);
#line 126
          B += ((((C << 5) | (C >> 27)) + (A ^ (D & (E ^ A)))) + W[8]) + 1518500249U;
#line 126
          D = (D << 30) | (D >> 2);
#line 127
          A += ((((B << 5) | (B >> 27)) + (E ^ (C & (D ^ E)))) + W[9]) + 1518500249U;
#line 127
          C = (C << 30) | (C >> 2);
#line 128
          E += ((((A << 5) | (A >> 27)) + (D ^ (B & (C ^ D)))) + W[10]) + 1518500249U;
#line 128
          B = (B << 30) | (B >> 2);
#line 129
          D += ((((E << 5) | (E >> 27)) + (C ^ (A & (B ^ C)))) + W[11]) + 1518500249U;
#line 129
          A = (A << 30) | (A >> 2);
        }
#line 132
        pH[0] = A;
#line 133
        pH[1] = B;
#line 134
        pH[2] = C;
#line 135
        pH[3] = D;
#line 136
        pH[4] = E;
      }
    }
    {
#line 148
    if (tailIndex == 32) {
#line 148
      goto case_32;
    }
#line 153
    if (tailIndex == 52) {
#line 153
      goto case_52;
    }
#line 141
    goto switch_default;
    switch_default: /* CIL Label */ 
#line 142
    W[16] = ((((W[0] ^ W[2]) ^ W[8]) ^ W[13]) << 1) | ((((W[0] ^ W[2]) ^ W[8]) ^ W[13]) >> 31);
#line 143
    W[17] = ((((W[1] ^ W[3]) ^ W[9]) ^ W[14]) << 1) | ((((W[1] ^ W[3]) ^ W[9]) ^ W[14]) >> 31);
#line 144
    W[18] = ((((W[2] ^ W[4]) ^ W[10]) ^ W[15]) << 1) | ((((W[2] ^ W[4]) ^ W[10]) ^ W[15]) >> 31);
#line 145
    W[19] = ((((W[3] ^ W[5]) ^ W[11]) ^ W[16]) << 1) | ((((W[3] ^ W[5]) ^ W[11]) ^ W[16]) >> 31);
#line 146
    W[22] = ((((W[6] ^ W[8]) ^ W[14]) ^ W[19]) << 1) | ((((W[6] ^ W[8]) ^ W[14]) ^ W[19]) >> 31);
#line 147
    W[25] = ((((W[9] ^ W[11]) ^ W[17]) ^ W[22]) << 1) | ((((W[9] ^ W[11]) ^ W[17]) ^ W[22]) >> 31);
    case_32: /* CIL Label */ 
#line 149
    W[21] = ((((W[5] ^ W[7]) ^ W[13]) ^ W[18]) << 1) | ((((W[5] ^ W[7]) ^ W[13]) ^ W[18]) >> 31);
#line 150
    W[24] = ((((W[8] ^ W[10]) ^ W[16]) ^ W[21]) << 1) | ((((W[8] ^ W[10]) ^ W[16]) ^ W[21]) >> 31);
#line 151
    W[27] = ((((W[11] ^ W[13]) ^ W[19]) ^ W[24]) << 1) | ((((W[11] ^ W[13]) ^ W[19]) ^ W[24]) >> 31);
#line 152
    W[30] = ((((W[14] ^ W[16]) ^ W[22]) ^ W[27]) << 1) | ((((W[14] ^ W[16]) ^ W[22]) ^ W[27]) >> 31);
    case_52: /* CIL Label */ 
#line 154
    W[20] = ((((W[4] ^ W[6]) ^ W[12]) ^ W[17]) << 1) | ((((W[4] ^ W[6]) ^ W[12]) ^ W[17]) >> 31);
#line 155
    W[23] = ((((W[7] ^ W[9]) ^ W[15]) ^ W[20]) << 1) | ((((W[7] ^ W[9]) ^ W[15]) ^ W[20]) >> 31);
#line 156
    W[26] = ((((W[10] ^ W[12]) ^ W[18]) ^ W[23]) << 1) | ((((W[10] ^ W[12]) ^ W[18]) ^ W[23]) >> 31);
#line 157
    W[28] = ((((W[12] ^ W[14]) ^ W[20]) ^ W[25]) << 1) | ((((W[12] ^ W[14]) ^ W[20]) ^ W[25]) >> 31);
#line 158
    W[29] = ((((W[13] ^ W[15]) ^ W[21]) ^ W[26]) << 1) | ((((W[13] ^ W[15]) ^ W[21]) ^ W[26]) >> 31);
#line 159
    W[31] = ((((W[15] ^ W[17]) ^ W[23]) ^ W[28]) << 1) | ((((W[15] ^ W[17]) ^ W[23]) ^ W[28]) >> 31);
    switch_break: /* CIL Label */ ;
    }
#line 161
    t = 32;
    {
#line 161
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 161
      if (! (t < 80)) {
#line 161
        goto while_break___6;
      }
#line 162
      W[t] = ((((W[t - 16] ^ W[t - 14]) ^ W[t - 8]) ^ W[t - 3]) << 1) | ((((W[t - 16] ^ W[t - 14]) ^ W[t - 8]) ^ W[t - 3]) >> 31);
#line 161
      t ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 165
    A = pH[0];
#line 166
    B = pH[1];
#line 167
    C = pH[2];
#line 168
    D = pH[3];
#line 169
    E = pH[4];
    {
#line 181
    if (tailIndex == 32) {
#line 181
      goto case_32___0;
    }
#line 187
    if (tailIndex == 52) {
#line 187
      goto case_52___0;
    }
#line 173
    goto switch_default___0;
    switch_default___0: /* CIL Label */ 
#line 174
    E += ((((A << 5) | (A >> 27)) + (D ^ (B & (C ^ D)))) + W[0]) + 1518500249U;
#line 174
    B = (B << 30) | (B >> 2);
#line 175
    D += ((((E << 5) | (E >> 27)) + (C ^ (A & (B ^ C)))) + W[1]) + 1518500249U;
#line 175
    A = (A << 30) | (A >> 2);
#line 176
    C += ((((D << 5) | (D >> 27)) + (B ^ (E & (A ^ B)))) + W[2]) + 1518500249U;
#line 176
    E = (E << 30) | (E >> 2);
#line 177
    B += ((((C << 5) | (C >> 27)) + (A ^ (D & (E ^ A)))) + W[3]) + 1518500249U;
#line 177
    D = (D << 30) | (D >> 2);
#line 178
    A += ((((B << 5) | (B >> 27)) + (E ^ (C & (D ^ E)))) + W[4]) + 1518500249U;
#line 178
    C = (C << 30) | (C >> 2);
#line 179
    E += ((((A << 5) | (A >> 27)) + (D ^ (B & (C ^ D)))) + W[5]) + 1518500249U;
#line 179
    B = (B << 30) | (B >> 2);
#line 180
    D += ((((E << 5) | (E >> 27)) + (C ^ (A & (B ^ C)))) + W[6]) + 1518500249U;
#line 180
    A = (A << 30) | (A >> 2);
    case_32___0: /* CIL Label */ 
#line 182
    C += ((((D << 5) | (D >> 27)) + (B ^ (E & (A ^ B)))) + W[7]) + 1518500249U;
#line 182
    E = (E << 30) | (E >> 2);
#line 183
    B += ((((C << 5) | (C >> 27)) + (A ^ (D & (E ^ A)))) + W[8]) + 1518500249U;
#line 183
    D = (D << 30) | (D >> 2);
#line 184
    A += ((((B << 5) | (B >> 27)) + (E ^ (C & (D ^ E)))) + W[9]) + 1518500249U;
#line 184
    C = (C << 30) | (C >> 2);
#line 185
    E += ((((A << 5) | (A >> 27)) + (D ^ (B & (C ^ D)))) + W[10]) + 1518500249U;
#line 185
    B = (B << 30) | (B >> 2);
#line 186
    D += ((((E << 5) | (E >> 27)) + (C ^ (A & (B ^ C)))) + W[11]) + 1518500249U;
#line 186
    A = (A << 30) | (A >> 2);
    case_52___0: /* CIL Label */ 
#line 188
    C += ((((D << 5) | (D >> 27)) + (B ^ (E & (A ^ B)))) + W[12]) + 1518500249U;
#line 188
    E = (E << 30) | (E >> 2);
#line 189
    B += ((((C << 5) | (C >> 27)) + (A ^ (D & (E ^ A)))) + W[13]) + 1518500249U;
#line 189
    D = (D << 30) | (D >> 2);
#line 190
    A += ((((B << 5) | (B >> 27)) + (E ^ (C & (D ^ E)))) + W[14]) + 1518500249U;
#line 190
    C = (C << 30) | (C >> 2);
#line 191
    E += ((((A << 5) | (A >> 27)) + (D ^ (B & (C ^ D)))) + W[15]) + 1518500249U;
#line 191
    B = (B << 30) | (B >> 2);
#line 192
    D += ((((E << 5) | (E >> 27)) + (C ^ (A & (B ^ C)))) + W[16]) + 1518500249U;
#line 192
    A = (A << 30) | (A >> 2);
#line 193
    C += ((((D << 5) | (D >> 27)) + (B ^ (E & (A ^ B)))) + W[17]) + 1518500249U;
#line 193
    E = (E << 30) | (E >> 2);
#line 194
    B += ((((C << 5) | (C >> 27)) + (A ^ (D & (E ^ A)))) + W[18]) + 1518500249U;
#line 194
    D = (D << 30) | (D >> 2);
#line 195
    A += ((((B << 5) | (B >> 27)) + (E ^ (C & (D ^ E)))) + W[19]) + 1518500249U;
#line 195
    C = (C << 30) | (C >> 2);
    switch_break___0: /* CIL Label */ ;
    }
#line 198
    E += ((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) + W[20]) + 1859775393U;
#line 198
    B = (B << 30) | (B >> 2);
#line 198
    D += ((((E << 5) | (E >> 27)) + ((A ^ B) ^ C)) + W[21]) + 1859775393U;
#line 198
    A = (A << 30) | (A >> 2);
#line 198
    C += ((((D << 5) | (D >> 27)) + ((E ^ A) ^ B)) + W[22]) + 1859775393U;
#line 198
    E = (E << 30) | (E >> 2);
#line 198
    B += ((((C << 5) | (C >> 27)) + ((D ^ E) ^ A)) + W[23]) + 1859775393U;
#line 198
    D = (D << 30) | (D >> 2);
#line 198
    A += ((((B << 5) | (B >> 27)) + ((C ^ D) ^ E)) + W[24]) + 1859775393U;
#line 198
    C = (C << 30) | (C >> 2);
#line 198
    E += ((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) + W[25]) + 1859775393U;
#line 198
    B = (B << 30) | (B >> 2);
#line 198
    D += ((((E << 5) | (E >> 27)) + ((A ^ B) ^ C)) + W[26]) + 1859775393U;
#line 198
    A = (A << 30) | (A >> 2);
#line 198
    C += ((((D << 5) | (D >> 27)) + ((E ^ A) ^ B)) + W[27]) + 1859775393U;
#line 198
    E = (E << 30) | (E >> 2);
#line 198
    B += ((((C << 5) | (C >> 27)) + ((D ^ E) ^ A)) + W[28]) + 1859775393U;
#line 198
    D = (D << 30) | (D >> 2);
#line 198
    A += ((((B << 5) | (B >> 27)) + ((C ^ D) ^ E)) + W[29]) + 1859775393U;
#line 198
    C = (C << 30) | (C >> 2);
#line 198
    E += ((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) + W[30]) + 1859775393U;
#line 198
    B = (B << 30) | (B >> 2);
#line 198
    D += ((((E << 5) | (E >> 27)) + ((A ^ B) ^ C)) + W[31]) + 1859775393U;
#line 198
    A = (A << 30) | (A >> 2);
#line 198
    C += ((((D << 5) | (D >> 27)) + ((E ^ A) ^ B)) + W[32]) + 1859775393U;
#line 198
    E = (E << 30) | (E >> 2);
#line 198
    B += ((((C << 5) | (C >> 27)) + ((D ^ E) ^ A)) + W[33]) + 1859775393U;
#line 198
    D = (D << 30) | (D >> 2);
#line 198
    A += ((((B << 5) | (B >> 27)) + ((C ^ D) ^ E)) + W[34]) + 1859775393U;
#line 198
    C = (C << 30) | (C >> 2);
#line 198
    E += ((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) + W[35]) + 1859775393U;
#line 198
    B = (B << 30) | (B >> 2);
#line 198
    D += ((((E << 5) | (E >> 27)) + ((A ^ B) ^ C)) + W[36]) + 1859775393U;
#line 198
    A = (A << 30) | (A >> 2);
#line 198
    C += ((((D << 5) | (D >> 27)) + ((E ^ A) ^ B)) + W[37]) + 1859775393U;
#line 198
    E = (E << 30) | (E >> 2);
#line 198
    B += ((((C << 5) | (C >> 27)) + ((D ^ E) ^ A)) + W[38]) + 1859775393U;
#line 198
    D = (D << 30) | (D >> 2);
#line 198
    A += ((((B << 5) | (B >> 27)) + ((C ^ D) ^ E)) + W[39]) + 1859775393U;
#line 198
    C = (C << 30) | (C >> 2);
#line 199
    E += ((((A << 5) | (A >> 27)) + ((B & (C | D)) | (C & D))) + W[40]) + 2400959708U;
#line 199
    B = (B << 30) | (B >> 2);
#line 199
    D += ((((E << 5) | (E >> 27)) + ((A & (B | C)) | (B & C))) + W[41]) + 2400959708U;
#line 199
    A = (A << 30) | (A >> 2);
#line 199
    C += ((((D << 5) | (D >> 27)) + ((E & (A | B)) | (A & B))) + W[42]) + 2400959708U;
#line 199
    E = (E << 30) | (E >> 2);
#line 199
    B += ((((C << 5) | (C >> 27)) + ((D & (E | A)) | (E & A))) + W[43]) + 2400959708U;
#line 199
    D = (D << 30) | (D >> 2);
#line 199
    A += ((((B << 5) | (B >> 27)) + ((C & (D | E)) | (D & E))) + W[44]) + 2400959708U;
#line 199
    C = (C << 30) | (C >> 2);
#line 199
    E += ((((A << 5) | (A >> 27)) + ((B & (C | D)) | (C & D))) + W[45]) + 2400959708U;
#line 199
    B = (B << 30) | (B >> 2);
#line 199
    D += ((((E << 5) | (E >> 27)) + ((A & (B | C)) | (B & C))) + W[46]) + 2400959708U;
#line 199
    A = (A << 30) | (A >> 2);
#line 199
    C += ((((D << 5) | (D >> 27)) + ((E & (A | B)) | (A & B))) + W[47]) + 2400959708U;
#line 199
    E = (E << 30) | (E >> 2);
#line 199
    B += ((((C << 5) | (C >> 27)) + ((D & (E | A)) | (E & A))) + W[48]) + 2400959708U;
#line 199
    D = (D << 30) | (D >> 2);
#line 199
    A += ((((B << 5) | (B >> 27)) + ((C & (D | E)) | (D & E))) + W[49]) + 2400959708U;
#line 199
    C = (C << 30) | (C >> 2);
#line 199
    E += ((((A << 5) | (A >> 27)) + ((B & (C | D)) | (C & D))) + W[50]) + 2400959708U;
#line 199
    B = (B << 30) | (B >> 2);
#line 199
    D += ((((E << 5) | (E >> 27)) + ((A & (B | C)) | (B & C))) + W[51]) + 2400959708U;
#line 199
    A = (A << 30) | (A >> 2);
#line 199
    C += ((((D << 5) | (D >> 27)) + ((E & (A | B)) | (A & B))) + W[52]) + 2400959708U;
#line 199
    E = (E << 30) | (E >> 2);
#line 199
    B += ((((C << 5) | (C >> 27)) + ((D & (E | A)) | (E & A))) + W[53]) + 2400959708U;
#line 199
    D = (D << 30) | (D >> 2);
#line 199
    A += ((((B << 5) | (B >> 27)) + ((C & (D | E)) | (D & E))) + W[54]) + 2400959708U;
#line 199
    C = (C << 30) | (C >> 2);
#line 199
    E += ((((A << 5) | (A >> 27)) + ((B & (C | D)) | (C & D))) + W[55]) + 2400959708U;
#line 199
    B = (B << 30) | (B >> 2);
#line 199
    D += ((((E << 5) | (E >> 27)) + ((A & (B | C)) | (B & C))) + W[56]) + 2400959708U;
#line 199
    A = (A << 30) | (A >> 2);
#line 199
    C += ((((D << 5) | (D >> 27)) + ((E & (A | B)) | (A & B))) + W[57]) + 2400959708U;
#line 199
    E = (E << 30) | (E >> 2);
#line 199
    B += ((((C << 5) | (C >> 27)) + ((D & (E | A)) | (E & A))) + W[58]) + 2400959708U;
#line 199
    D = (D << 30) | (D >> 2);
#line 199
    A += ((((B << 5) | (B >> 27)) + ((C & (D | E)) | (D & E))) + W[59]) + 2400959708U;
#line 199
    C = (C << 30) | (C >> 2);
#line 200
    E += ((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) + W[60]) + 3395469782U;
#line 200
    B = (B << 30) | (B >> 2);
#line 200
    D += ((((E << 5) | (E >> 27)) + ((A ^ B) ^ C)) + W[61]) + 3395469782U;
#line 200
    A = (A << 30) | (A >> 2);
#line 200
    C += ((((D << 5) | (D >> 27)) + ((E ^ A) ^ B)) + W[62]) + 3395469782U;
#line 200
    E = (E << 30) | (E >> 2);
#line 200
    B += ((((C << 5) | (C >> 27)) + ((D ^ E) ^ A)) + W[63]) + 3395469782U;
#line 200
    D = (D << 30) | (D >> 2);
#line 200
    A += ((((B << 5) | (B >> 27)) + ((C ^ D) ^ E)) + W[64]) + 3395469782U;
#line 200
    C = (C << 30) | (C >> 2);
#line 200
    E += ((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) + W[65]) + 3395469782U;
#line 200
    B = (B << 30) | (B >> 2);
#line 200
    D += ((((E << 5) | (E >> 27)) + ((A ^ B) ^ C)) + W[66]) + 3395469782U;
#line 200
    A = (A << 30) | (A >> 2);
#line 200
    C += ((((D << 5) | (D >> 27)) + ((E ^ A) ^ B)) + W[67]) + 3395469782U;
#line 200
    E = (E << 30) | (E >> 2);
#line 200
    B += ((((C << 5) | (C >> 27)) + ((D ^ E) ^ A)) + W[68]) + 3395469782U;
#line 200
    D = (D << 30) | (D >> 2);
#line 200
    A += ((((B << 5) | (B >> 27)) + ((C ^ D) ^ E)) + W[69]) + 3395469782U;
#line 200
    C = (C << 30) | (C >> 2);
#line 200
    E += ((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) + W[70]) + 3395469782U;
#line 200
    B = (B << 30) | (B >> 2);
#line 200
    D += ((((E << 5) | (E >> 27)) + ((A ^ B) ^ C)) + W[71]) + 3395469782U;
#line 200
    A = (A << 30) | (A >> 2);
#line 200
    C += ((((D << 5) | (D >> 27)) + ((E ^ A) ^ B)) + W[72]) + 3395469782U;
#line 200
    E = (E << 30) | (E >> 2);
#line 200
    B += ((((C << 5) | (C >> 27)) + ((D ^ E) ^ A)) + W[73]) + 3395469782U;
#line 200
    D = (D << 30) | (D >> 2);
#line 200
    A += ((((B << 5) | (B >> 27)) + ((C ^ D) ^ E)) + W[74]) + 3395469782U;
#line 200
    C = (C << 30) | (C >> 2);
#line 200
    E += ((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) + W[75]) + 3395469782U;
#line 200
    B = (B << 30) | (B >> 2);
#line 200
    D += ((((E << 5) | (E >> 27)) + ((A ^ B) ^ C)) + W[76]) + 3395469782U;
#line 200
    A = (A << 30) | (A >> 2);
#line 200
    C += ((((D << 5) | (D >> 27)) + ((E ^ A) ^ B)) + W[77]) + 3395469782U;
#line 200
    E = (E << 30) | (E >> 2);
#line 200
    B += ((((C << 5) | (C >> 27)) + ((D ^ E) ^ A)) + W[78]) + 3395469782U;
#line 200
    D = (D << 30) | (D >> 2);
#line 200
    A += ((((B << 5) | (B >> 27)) + ((C ^ D) ^ E)) + W[79]) + 3395469782U;
#line 200
    C = (C << 30) | (C >> 2);
#line 203
    A += H[0];
#line 204
    B += H[1];
#line 205
    C += H[2];
#line 206
    D += H[3];
#line 207
    E += H[4];
#line 210
    if (! (A & bitMask1Low)) {
#line 210
      if (! (B & bitMask1High)) {
#line 212
        gotBits = 0;
#line 213
        if (A) {
#line 214
          s = A;
          {
#line 215
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 215
            if (! (! (s & 2147483648U))) {
#line 215
              goto while_break___7;
            }
#line 216
            s <<= 1;
#line 217
            gotBits ++;
          }
          while_break___7: /* CIL Label */ ;
          }
        } else {
#line 220
          gotBits = 32;
#line 221
          if (B) {
#line 222
            s = B;
            {
#line 223
            while (1) {
              while_continue___8: /* CIL Label */ ;
#line 223
              if (! (! (s & 2147483648U))) {
#line 223
                goto while_break___8;
              }
#line 224
              s <<= 1;
#line 225
              gotBits ++;
            }
            while_break___8: /* CIL Label */ ;
            }
          } else {
#line 228
            gotBits = 64;
          }
        }
#line 232
        *best = gotBits;
#line 234
        maxBits = gotBits + 1;
#line 235
        if (maxBits < 32) {
#line 236
          bitMask1Low = ~ ((1U << (32 - maxBits)) - 1U);
#line 237
          bitMask1High = (uInt32 )0;
        } else {
#line 239
          bitMask1Low = (uInt32 )(~ 0);
#line 240
          bitMask1High = ~ ((1U << (64 - maxBits)) - 1U);
        }
#line 244
        t = 0;
        {
#line 244
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 244
          if (! (t < 16)) {
#line 244
            goto while_break___9;
          }
#line 245
          *((output + t * 4) + 0) = (unsigned char )((W[t] >> 24) & 255U);
#line 245
          *((output + t * 4) + 1) = (unsigned char )((W[t] >> 16) & 255U);
#line 245
          *((output + t * 4) + 2) = (unsigned char )((W[t] >> 8) & 255U);
#line 245
          *((output + t * 4) + 3) = (unsigned char )(W[t] & 255U);
#line 244
          t ++;
        }
        while_break___9: /* CIL Label */ ;
        }
#line 248
        if (gotBits >= bits) {
#line 249
          return (iters + 1UL);
        }
      }
    }
    {
#line 252
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 252
      if ((unsigned long )cb != (unsigned long )((void *)0)) {
#line 252
        if ((iters & 65535UL) == 0UL) {
          {
#line 252
          gettimeofday((struct timeval */* __restrict  */)(& curr), (__timezone_ptr_t )((void *)0));
          }
#line 252
          if (gotBits > lastBits) {
#line 252
            goto _L___1;
          } else
#line 252
          if (curr.tv_sec - prev.tv_sec > 1L) {
#line 252
            goto _L___1;
          } else {
#line 252
            if (curr.tv_sec - prev.tv_sec) {
#line 252
              tmp___5 = 1000000;
            } else {
#line 252
              tmp___5 = 0;
            }
#line 252
            if ((curr.tv_usec + (__suseconds_t )tmp___5) - prev.tv_usec > 100000L) {
              _L___1: /* CIL Label */ 
              {
#line 252
              percent = (double )((int )(((counter + (double )iters) / expected) * (double )100 + 0.5));
#line 252
              tmp___4 = (*cb)((int )percent, *best, bits, counter + (double )iters,
                              expected, user_args);
              }
#line 252
              if (! tmp___4) {
#line 252
                *best = -1;
#line 252
                return (0UL);
              }
#line 252
              prev = curr;
#line 252
              lastBits = gotBits;
            }
          }
        }
      }
#line 252
      goto while_break___10;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 83
    iters ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 255
  return (iters + 1UL);
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libfastmint.h"
unsigned long minter_ansi_standard_1(int bits , int *best , unsigned char *block ,
                                     uInt32 const   *IV , int tailIndex , unsigned long maxIter ,
                                     int (*cb)(int percent , int largest , int target ,
                                               double count , double expected , void *user ) ,
                                     void *user_args , double counter , double expected ) ;
#line 152
int minter_ansi_standard_1_test(void) ;
#line 3 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/fastmint_ansi_standard_1.c"
int minter_ansi_standard_1_test(void) 
{ 


  {
#line 6
  return (1);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/fastmint_ansi_standard_1.c"
static int const   endTest___2  =    (int const   )3;
#line 48 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/fastmint_ansi_standard_1.c"
unsigned long minter_ansi_standard_1(int bits , int *best , unsigned char *block ,
                                     uInt32 const   *IV , int tailIndex , unsigned long maxIter ,
                                     int (*cb)(int percent , int largest , int target ,
                                               double count , double expected , void *user ) ,
                                     void *user_args , double counter , double expected ) 
{ 
  double percent ;
  struct timeval prev ;
  struct timeval curr ;
  int lastBits ;
  unsigned long iters ;
  int t ;
  int gotBits ;
  int maxBits ;
  int tmp ;
  uInt32 bitMask1Low ;
  uInt32 bitMask1High ;
  uInt32 s ;
  uInt32 A ;
  uInt32 B ;
  uInt32 C ;
  uInt32 D ;
  uInt32 E ;
  uInt32 W[80] ;
  unsigned int tmp___0 ;
  uInt32 H[5] ;
  unsigned int tmp___1 ;
  uInt32 pH[5] ;
  unsigned int tmp___2 ;
  char const   *p ;
  unsigned char *X ;
  int addressMask ;
  unsigned char *output ;
  uInt32 tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 50
  prev.tv_sec = (__time_t )0;
#line 50
  prev.tv_usec = (__suseconds_t )0;
#line 50
  lastBits = 0;
#line 51
  iters = 0UL;
#line 52
  t = 0;
#line 52
  gotBits = 0;
#line 52
  if (bits > 16) {
#line 52
    tmp = 16;
  } else {
#line 52
    tmp = bits;
  }
#line 52
  maxBits = tmp;
#line 53
  bitMask1Low = (uInt32 )0;
#line 53
  bitMask1High = (uInt32 )0;
#line 53
  s = (uInt32 )0;
#line 54
  A = (uInt32 )0;
#line 54
  B = (uInt32 )0;
#line 54
  C = (uInt32 )0;
#line 54
  D = (uInt32 )0;
#line 54
  E = (uInt32 )0;
#line 55
  W[0] = (uInt32 )0;
#line 55
  tmp___0 = 1U;
  {
#line 55
  while (1) {
    while_continue: /* CIL Label */ ;
#line 55
    if (tmp___0 >= 80U) {
#line 55
      goto while_break;
    }
#line 55
    W[tmp___0] = 0U;
#line 55
    tmp___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 56
  H[0] = (uInt32 )0;
#line 56
  tmp___1 = 1U;
  {
#line 56
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 56
    if (tmp___1 >= 5U) {
#line 56
      goto while_break___0;
    }
#line 56
    H[tmp___1] = 0U;
#line 56
    tmp___1 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 56
  pH[0] = (uInt32 )0;
#line 56
  tmp___2 = 1U;
  {
#line 56
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 56
    if (tmp___2 >= 5U) {
#line 56
      goto while_break___1;
    }
#line 56
    pH[tmp___2] = 0U;
#line 56
    tmp___2 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 57
  p = encodeAlphabets[4];
#line 58
  X = (unsigned char *)(W);
#line 59
  addressMask = 0;
#line 61
  output = block;
#line 63
  *best = 0;
#line 66
  addressMask = (int )*((char *)(& endTest___2));
#line 69
  if (maxBits < 32) {
#line 70
    if (bits == 0) {
#line 70
      bitMask1Low = (uInt32 )0;
    } else {
#line 71
      bitMask1Low = ~ ((1U << (32 - maxBits)) - 1U);
    }
#line 73
    bitMask1High = (uInt32 )0;
  } else {
#line 75
    bitMask1Low = (uInt32 )(~ 0);
#line 76
    bitMask1High = ~ ((1U << (64 - maxBits)) - 1U);
  }
#line 78
  maxBits = 0;
#line 81
  t = 0;
  {
#line 81
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 81
    if (! (t < 16)) {
#line 81
      goto while_break___2;
    }
#line 82
    W[t] = (uInt32 )(((((int )*((output + t * 4) + 0) << 24) | ((int )*((output + t * 4) + 1) << 16)) | ((int )*((output + t * 4) + 2) << 8)) | (int )*((output + t * 4) + 3));
#line 81
    t ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 83
  t = 0;
  {
#line 83
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 83
    if (! (t < 5)) {
#line 83
      goto while_break___3;
    }
#line 84
    tmp___3 = (uInt32 )*(IV + t);
#line 84
    H[t] = tmp___3;
#line 84
    pH[t] = tmp___3;
#line 83
    t ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 87
  iters = 0UL;
  {
#line 87
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 87
    if (! (iters < maxIter)) {
#line 87
      goto while_break___4;
    }
#line 89
    *(X + ((tailIndex - 1) ^ addressMask)) = (unsigned char )*(p + (iters & 63UL));
#line 90
    if (! (iters & 63UL)) {
#line 91
      if (iters >> 6) {
#line 92
        *(X + ((tailIndex - 2) ^ addressMask)) = (unsigned char )*(p + ((iters >> 6) & 63UL));
      }
#line 94
      if (iters >> 12) {
#line 95
        *(X + ((tailIndex - 3) ^ addressMask)) = (unsigned char )*(p + ((iters >> 12) & 63UL));
      }
#line 97
      if (iters >> 18) {
#line 98
        *(X + ((tailIndex - 4) ^ addressMask)) = (unsigned char )*(p + ((iters >> 18) & 63UL));
      }
#line 100
      if (iters >> 24) {
#line 101
        *(X + ((tailIndex - 5) ^ addressMask)) = (unsigned char )*(p + ((iters >> 24) & 63UL));
      }
#line 103
      if (iters >> 30) {
#line 104
        *(X + ((tailIndex - 6) ^ addressMask)) = (unsigned char )*(p + ((iters >> 30) & 63UL));
      }
    }
#line 109
    if (! (iters & 16777215UL)) {
#line 109
      if (tailIndex == 52) {
#line 109
        goto _L;
      } else
#line 109
      if (tailIndex == 32) {
        _L: /* CIL Label */ 
#line 110
        A = H[0];
#line 111
        B = H[1];
#line 112
        C = H[2];
#line 113
        D = H[3];
#line 114
        E = H[4];
#line 116
        t = 16;
        {
#line 116
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 116
          if (! (t < 32)) {
#line 116
            goto while_break___5;
          }
#line 117
          W[t] = ((((W[t - 16] ^ W[t - 14]) ^ W[t - 8]) ^ W[t - 3]) << 1) | ((((W[t - 16] ^ W[t - 14]) ^ W[t - 8]) ^ W[t - 3]) >> 31);
#line 116
          t ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 119
        E += ((((A << 5) | (A >> 27)) + ((B & C) | (~ B & D))) + W[0]) + 1518500249U;
#line 119
        B = (B << 30) | (B >> 2);
#line 120
        D += ((((E << 5) | (E >> 27)) + ((A & B) | (~ A & C))) + W[1]) + 1518500249U;
#line 120
        A = (A << 30) | (A >> 2);
#line 121
        C += ((((D << 5) | (D >> 27)) + ((E & A) | (~ E & B))) + W[2]) + 1518500249U;
#line 121
        E = (E << 30) | (E >> 2);
#line 122
        B += ((((C << 5) | (C >> 27)) + ((D & E) | (~ D & A))) + W[3]) + 1518500249U;
#line 122
        D = (D << 30) | (D >> 2);
#line 123
        A += ((((B << 5) | (B >> 27)) + ((C & D) | (~ C & E))) + W[4]) + 1518500249U;
#line 123
        C = (C << 30) | (C >> 2);
#line 124
        E += ((((A << 5) | (A >> 27)) + ((B & C) | (~ B & D))) + W[5]) + 1518500249U;
#line 124
        B = (B << 30) | (B >> 2);
#line 125
        D += ((((E << 5) | (E >> 27)) + ((A & B) | (~ A & C))) + W[6]) + 1518500249U;
#line 125
        A = (A << 30) | (A >> 2);
#line 127
        if (tailIndex == 52) {
#line 128
          C += ((((D << 5) | (D >> 27)) + ((E & A) | (~ E & B))) + W[7]) + 1518500249U;
#line 128
          E = (E << 30) | (E >> 2);
#line 129
          B += ((((C << 5) | (C >> 27)) + ((D & E) | (~ D & A))) + W[8]) + 1518500249U;
#line 129
          D = (D << 30) | (D >> 2);
#line 130
          A += ((((B << 5) | (B >> 27)) + ((C & D) | (~ C & E))) + W[9]) + 1518500249U;
#line 130
          C = (C << 30) | (C >> 2);
#line 131
          E += ((((A << 5) | (A >> 27)) + ((B & C) | (~ B & D))) + W[10]) + 1518500249U;
#line 131
          B = (B << 30) | (B >> 2);
#line 132
          D += ((((E << 5) | (E >> 27)) + ((A & B) | (~ A & C))) + W[11]) + 1518500249U;
#line 132
          A = (A << 30) | (A >> 2);
        }
#line 135
        pH[0] = A;
#line 136
        pH[1] = B;
#line 137
        pH[2] = C;
#line 138
        pH[3] = D;
#line 139
        pH[4] = E;
      }
    }
#line 143
    A = pH[0];
#line 144
    B = pH[1];
#line 145
    C = pH[2];
#line 146
    D = pH[3];
#line 147
    E = pH[4];
    {
#line 159
    if (tailIndex == 32) {
#line 159
      goto case_32;
    }
#line 165
    if (tailIndex == 52) {
#line 165
      goto case_52;
    }
#line 151
    goto switch_default;
    switch_default: /* CIL Label */ 
#line 152
    E += ((((A << 5) | (A >> 27)) + ((B & C) | (~ B & D))) + W[0]) + 1518500249U;
#line 152
    B = (B << 30) | (B >> 2);
#line 153
    D += ((((E << 5) | (E >> 27)) + ((A & B) | (~ A & C))) + W[1]) + 1518500249U;
#line 153
    A = (A << 30) | (A >> 2);
#line 154
    C += ((((D << 5) | (D >> 27)) + ((E & A) | (~ E & B))) + W[2]) + 1518500249U;
#line 154
    E = (E << 30) | (E >> 2);
#line 155
    B += ((((C << 5) | (C >> 27)) + ((D & E) | (~ D & A))) + W[3]) + 1518500249U;
#line 155
    D = (D << 30) | (D >> 2);
#line 156
    A += ((((B << 5) | (B >> 27)) + ((C & D) | (~ C & E))) + W[4]) + 1518500249U;
#line 156
    C = (C << 30) | (C >> 2);
#line 157
    E += ((((A << 5) | (A >> 27)) + ((B & C) | (~ B & D))) + W[5]) + 1518500249U;
#line 157
    B = (B << 30) | (B >> 2);
#line 158
    D += ((((E << 5) | (E >> 27)) + ((A & B) | (~ A & C))) + W[6]) + 1518500249U;
#line 158
    A = (A << 30) | (A >> 2);
    case_32: /* CIL Label */ 
#line 160
    C += ((((D << 5) | (D >> 27)) + ((E & A) | (~ E & B))) + W[7]) + 1518500249U;
#line 160
    E = (E << 30) | (E >> 2);
#line 161
    B += ((((C << 5) | (C >> 27)) + ((D & E) | (~ D & A))) + W[8]) + 1518500249U;
#line 161
    D = (D << 30) | (D >> 2);
#line 162
    A += ((((B << 5) | (B >> 27)) + ((C & D) | (~ C & E))) + W[9]) + 1518500249U;
#line 162
    C = (C << 30) | (C >> 2);
#line 163
    E += ((((A << 5) | (A >> 27)) + ((B & C) | (~ B & D))) + W[10]) + 1518500249U;
#line 163
    B = (B << 30) | (B >> 2);
#line 164
    D += ((((E << 5) | (E >> 27)) + ((A & B) | (~ A & C))) + W[11]) + 1518500249U;
#line 164
    A = (A << 30) | (A >> 2);
    case_52: /* CIL Label */ 
#line 166
    C += ((((D << 5) | (D >> 27)) + ((E & A) | (~ E & B))) + W[12]) + 1518500249U;
#line 166
    E = (E << 30) | (E >> 2);
#line 167
    B += ((((C << 5) | (C >> 27)) + ((D & E) | (~ D & A))) + W[13]) + 1518500249U;
#line 167
    D = (D << 30) | (D >> 2);
#line 168
    A += ((((B << 5) | (B >> 27)) + ((C & D) | (~ C & E))) + W[14]) + 1518500249U;
#line 168
    C = (C << 30) | (C >> 2);
#line 169
    E += ((((A << 5) | (A >> 27)) + ((B & C) | (~ B & D))) + W[15]) + 1518500249U;
#line 169
    B = (B << 30) | (B >> 2);
    switch_break: /* CIL Label */ ;
    }
#line 172
    if (tailIndex == 52) {
#line 173
      D += ((((E << 5) | (E >> 27)) + ((A & B) | (~ A & C))) + W[16]) + 1518500249U;
#line 173
      A = (A << 30) | (A >> 2);
#line 174
      C += ((((D << 5) | (D >> 27)) + ((E & A) | (~ E & B))) + W[17]) + 1518500249U;
#line 174
      E = (E << 30) | (E >> 2);
#line 175
      B += ((((C << 5) | (C >> 27)) + ((D & E) | (~ D & A))) + W[18]) + 1518500249U;
#line 175
      D = (D << 30) | (D >> 2);
#line 176
      A += ((((B << 5) | (B >> 27)) + ((C & D) | (~ C & E))) + W[19]) + 1518500249U;
#line 176
      C = (C << 30) | (C >> 2);
#line 177
      W[20] = ((((W[4] ^ W[6]) ^ W[12]) ^ W[17]) << 1) | ((((W[4] ^ W[6]) ^ W[12]) ^ W[17]) >> 31);
#line 177
      E += ((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) + W[20]) + 1859775393U;
#line 177
      B = (B << 30) | (B >> 2);
#line 178
      D += ((((E << 5) | (E >> 27)) + ((A ^ B) ^ C)) + W[21]) + 1859775393U;
#line 178
      A = (A << 30) | (A >> 2);
#line 179
      C += ((((D << 5) | (D >> 27)) + ((E ^ A) ^ B)) + W[22]) + 1859775393U;
#line 179
      E = (E << 30) | (E >> 2);
#line 180
      W[23] = ((((W[7] ^ W[9]) ^ W[15]) ^ W[20]) << 1) | ((((W[7] ^ W[9]) ^ W[15]) ^ W[20]) >> 31);
#line 180
      B += ((((C << 5) | (C >> 27)) + ((D ^ E) ^ A)) + W[23]) + 1859775393U;
#line 180
      D = (D << 30) | (D >> 2);
#line 181
      A += ((((B << 5) | (B >> 27)) + ((C ^ D) ^ E)) + W[24]) + 1859775393U;
#line 181
      C = (C << 30) | (C >> 2);
#line 182
      E += ((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) + W[25]) + 1859775393U;
#line 182
      B = (B << 30) | (B >> 2);
#line 183
      W[26] = ((((W[10] ^ W[12]) ^ W[18]) ^ W[23]) << 1) | ((((W[10] ^ W[12]) ^ W[18]) ^ W[23]) >> 31);
#line 183
      D += ((((E << 5) | (E >> 27)) + ((A ^ B) ^ C)) + W[26]) + 1859775393U;
#line 183
      A = (A << 30) | (A >> 2);
#line 184
      C += ((((D << 5) | (D >> 27)) + ((E ^ A) ^ B)) + W[27]) + 1859775393U;
#line 184
      E = (E << 30) | (E >> 2);
#line 185
      W[28] = ((((W[12] ^ W[14]) ^ W[20]) ^ W[25]) << 1) | ((((W[12] ^ W[14]) ^ W[20]) ^ W[25]) >> 31);
#line 185
      B += ((((C << 5) | (C >> 27)) + ((D ^ E) ^ A)) + W[28]) + 1859775393U;
#line 185
      D = (D << 30) | (D >> 2);
#line 186
      W[29] = ((((W[13] ^ W[15]) ^ W[21]) ^ W[26]) << 1) | ((((W[13] ^ W[15]) ^ W[21]) ^ W[26]) >> 31);
#line 186
      A += ((((B << 5) | (B >> 27)) + ((C ^ D) ^ E)) + W[29]) + 1859775393U;
#line 186
      C = (C << 30) | (C >> 2);
#line 187
      E += ((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) + W[30]) + 1859775393U;
#line 187
      B = (B << 30) | (B >> 2);
    } else
#line 188
    if (tailIndex == 32) {
#line 189
      D += ((((E << 5) | (E >> 27)) + ((A & B) | (~ A & C))) + W[16]) + 1518500249U;
#line 189
      A = (A << 30) | (A >> 2);
#line 190
      C += ((((D << 5) | (D >> 27)) + ((E & A) | (~ E & B))) + W[17]) + 1518500249U;
#line 190
      E = (E << 30) | (E >> 2);
#line 191
      B += ((((C << 5) | (C >> 27)) + ((D & E) | (~ D & A))) + W[18]) + 1518500249U;
#line 191
      D = (D << 30) | (D >> 2);
#line 192
      A += ((((B << 5) | (B >> 27)) + ((C & D) | (~ C & E))) + W[19]) + 1518500249U;
#line 192
      C = (C << 30) | (C >> 2);
#line 193
      E += ((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) + W[20]) + 1859775393U;
#line 193
      B = (B << 30) | (B >> 2);
#line 194
      W[21] = ((((W[5] ^ W[7]) ^ W[13]) ^ W[18]) << 1) | ((((W[5] ^ W[7]) ^ W[13]) ^ W[18]) >> 31);
#line 194
      D += ((((E << 5) | (E >> 27)) + ((A ^ B) ^ C)) + W[21]) + 1859775393U;
#line 194
      A = (A << 30) | (A >> 2);
#line 195
      C += ((((D << 5) | (D >> 27)) + ((E ^ A) ^ B)) + W[22]) + 1859775393U;
#line 195
      E = (E << 30) | (E >> 2);
#line 196
      W[23] = ((((W[7] ^ W[9]) ^ W[15]) ^ W[20]) << 1) | ((((W[7] ^ W[9]) ^ W[15]) ^ W[20]) >> 31);
#line 196
      B += ((((C << 5) | (C >> 27)) + ((D ^ E) ^ A)) + W[23]) + 1859775393U;
#line 196
      D = (D << 30) | (D >> 2);
#line 197
      W[24] = ((((W[8] ^ W[10]) ^ W[16]) ^ W[21]) << 1) | ((((W[8] ^ W[10]) ^ W[16]) ^ W[21]) >> 31);
#line 197
      A += ((((B << 5) | (B >> 27)) + ((C ^ D) ^ E)) + W[24]) + 1859775393U;
#line 197
      C = (C << 30) | (C >> 2);
#line 198
      E += ((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) + W[25]) + 1859775393U;
#line 198
      B = (B << 30) | (B >> 2);
#line 199
      W[26] = ((((W[10] ^ W[12]) ^ W[18]) ^ W[23]) << 1) | ((((W[10] ^ W[12]) ^ W[18]) ^ W[23]) >> 31);
#line 199
      D += ((((E << 5) | (E >> 27)) + ((A ^ B) ^ C)) + W[26]) + 1859775393U;
#line 199
      A = (A << 30) | (A >> 2);
#line 200
      W[27] = ((((W[11] ^ W[13]) ^ W[19]) ^ W[24]) << 1) | ((((W[11] ^ W[13]) ^ W[19]) ^ W[24]) >> 31);
#line 200
      C += ((((D << 5) | (D >> 27)) + ((E ^ A) ^ B)) + W[27]) + 1859775393U;
#line 200
      E = (E << 30) | (E >> 2);
#line 201
      B += ((((C << 5) | (C >> 27)) + ((D ^ E) ^ A)) + W[28]) + 1859775393U;
#line 201
      D = (D << 30) | (D >> 2);
#line 202
      W[29] = ((((W[13] ^ W[15]) ^ W[21]) ^ W[26]) << 1) | ((((W[13] ^ W[15]) ^ W[21]) ^ W[26]) >> 31);
#line 202
      A += ((((B << 5) | (B >> 27)) + ((C ^ D) ^ E)) + W[29]) + 1859775393U;
#line 202
      C = (C << 30) | (C >> 2);
#line 203
      W[30] = ((((W[14] ^ W[16]) ^ W[22]) ^ W[27]) << 1) | ((((W[14] ^ W[16]) ^ W[22]) ^ W[27]) >> 31);
#line 203
      E += ((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) + W[30]) + 1859775393U;
#line 203
      B = (B << 30) | (B >> 2);
    } else {
#line 205
      W[16] = ((((W[0] ^ W[2]) ^ W[8]) ^ W[13]) << 1) | ((((W[0] ^ W[2]) ^ W[8]) ^ W[13]) >> 31);
#line 205
      D += ((((E << 5) | (E >> 27)) + ((A & B) | (~ A & C))) + W[16]) + 1518500249U;
#line 205
      A = (A << 30) | (A >> 2);
#line 206
      W[17] = ((((W[1] ^ W[3]) ^ W[9]) ^ W[14]) << 1) | ((((W[1] ^ W[3]) ^ W[9]) ^ W[14]) >> 31);
#line 206
      C += ((((D << 5) | (D >> 27)) + ((E & A) | (~ E & B))) + W[17]) + 1518500249U;
#line 206
      E = (E << 30) | (E >> 2);
#line 207
      W[18] = ((((W[2] ^ W[4]) ^ W[10]) ^ W[15]) << 1) | ((((W[2] ^ W[4]) ^ W[10]) ^ W[15]) >> 31);
#line 207
      B += ((((C << 5) | (C >> 27)) + ((D & E) | (~ D & A))) + W[18]) + 1518500249U;
#line 207
      D = (D << 30) | (D >> 2);
#line 208
      W[19] = ((((W[3] ^ W[5]) ^ W[11]) ^ W[16]) << 1) | ((((W[3] ^ W[5]) ^ W[11]) ^ W[16]) >> 31);
#line 208
      A += ((((B << 5) | (B >> 27)) + ((C & D) | (~ C & E))) + W[19]) + 1518500249U;
#line 208
      C = (C << 30) | (C >> 2);
#line 209
      W[20] = ((((W[4] ^ W[6]) ^ W[12]) ^ W[17]) << 1) | ((((W[4] ^ W[6]) ^ W[12]) ^ W[17]) >> 31);
#line 209
      E += ((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) + W[20]) + 1859775393U;
#line 209
      B = (B << 30) | (B >> 2);
#line 210
      W[21] = ((((W[5] ^ W[7]) ^ W[13]) ^ W[18]) << 1) | ((((W[5] ^ W[7]) ^ W[13]) ^ W[18]) >> 31);
#line 210
      D += ((((E << 5) | (E >> 27)) + ((A ^ B) ^ C)) + W[21]) + 1859775393U;
#line 210
      A = (A << 30) | (A >> 2);
#line 211
      W[22] = ((((W[6] ^ W[8]) ^ W[14]) ^ W[19]) << 1) | ((((W[6] ^ W[8]) ^ W[14]) ^ W[19]) >> 31);
#line 211
      C += ((((D << 5) | (D >> 27)) + ((E ^ A) ^ B)) + W[22]) + 1859775393U;
#line 211
      E = (E << 30) | (E >> 2);
#line 212
      W[23] = ((((W[7] ^ W[9]) ^ W[15]) ^ W[20]) << 1) | ((((W[7] ^ W[9]) ^ W[15]) ^ W[20]) >> 31);
#line 212
      B += ((((C << 5) | (C >> 27)) + ((D ^ E) ^ A)) + W[23]) + 1859775393U;
#line 212
      D = (D << 30) | (D >> 2);
#line 213
      W[24] = ((((W[8] ^ W[10]) ^ W[16]) ^ W[21]) << 1) | ((((W[8] ^ W[10]) ^ W[16]) ^ W[21]) >> 31);
#line 213
      A += ((((B << 5) | (B >> 27)) + ((C ^ D) ^ E)) + W[24]) + 1859775393U;
#line 213
      C = (C << 30) | (C >> 2);
#line 214
      W[25] = ((((W[9] ^ W[11]) ^ W[17]) ^ W[22]) << 1) | ((((W[9] ^ W[11]) ^ W[17]) ^ W[22]) >> 31);
#line 214
      E += ((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) + W[25]) + 1859775393U;
#line 214
      B = (B << 30) | (B >> 2);
#line 215
      W[26] = ((((W[10] ^ W[12]) ^ W[18]) ^ W[23]) << 1) | ((((W[10] ^ W[12]) ^ W[18]) ^ W[23]) >> 31);
#line 215
      D += ((((E << 5) | (E >> 27)) + ((A ^ B) ^ C)) + W[26]) + 1859775393U;
#line 215
      A = (A << 30) | (A >> 2);
#line 216
      W[27] = ((((W[11] ^ W[13]) ^ W[19]) ^ W[24]) << 1) | ((((W[11] ^ W[13]) ^ W[19]) ^ W[24]) >> 31);
#line 216
      C += ((((D << 5) | (D >> 27)) + ((E ^ A) ^ B)) + W[27]) + 1859775393U;
#line 216
      E = (E << 30) | (E >> 2);
#line 217
      W[28] = ((((W[12] ^ W[14]) ^ W[20]) ^ W[25]) << 1) | ((((W[12] ^ W[14]) ^ W[20]) ^ W[25]) >> 31);
#line 217
      B += ((((C << 5) | (C >> 27)) + ((D ^ E) ^ A)) + W[28]) + 1859775393U;
#line 217
      D = (D << 30) | (D >> 2);
#line 218
      W[29] = ((((W[13] ^ W[15]) ^ W[21]) ^ W[26]) << 1) | ((((W[13] ^ W[15]) ^ W[21]) ^ W[26]) >> 31);
#line 218
      A += ((((B << 5) | (B >> 27)) + ((C ^ D) ^ E)) + W[29]) + 1859775393U;
#line 218
      C = (C << 30) | (C >> 2);
#line 219
      W[30] = ((((W[14] ^ W[16]) ^ W[22]) ^ W[27]) << 1) | ((((W[14] ^ W[16]) ^ W[22]) ^ W[27]) >> 31);
#line 219
      E += ((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) + W[30]) + 1859775393U;
#line 219
      B = (B << 30) | (B >> 2);
    }
#line 222
    W[31] = ((((W[15] ^ W[17]) ^ W[23]) ^ W[28]) << 1) | ((((W[15] ^ W[17]) ^ W[23]) ^ W[28]) >> 31);
#line 222
    D += ((((E << 5) | (E >> 27)) + ((A ^ B) ^ C)) + W[31]) + 1859775393U;
#line 222
    A = (A << 30) | (A >> 2);
#line 223
    W[32] = ((((W[16] ^ W[18]) ^ W[24]) ^ W[29]) << 1) | ((((W[16] ^ W[18]) ^ W[24]) ^ W[29]) >> 31);
#line 223
    C += ((((D << 5) | (D >> 27)) + ((E ^ A) ^ B)) + W[32]) + 1859775393U;
#line 223
    E = (E << 30) | (E >> 2);
#line 224
    W[33] = ((((W[17] ^ W[19]) ^ W[25]) ^ W[30]) << 1) | ((((W[17] ^ W[19]) ^ W[25]) ^ W[30]) >> 31);
#line 224
    B += ((((C << 5) | (C >> 27)) + ((D ^ E) ^ A)) + W[33]) + 1859775393U;
#line 224
    D = (D << 30) | (D >> 2);
#line 225
    W[34] = ((((W[18] ^ W[20]) ^ W[26]) ^ W[31]) << 1) | ((((W[18] ^ W[20]) ^ W[26]) ^ W[31]) >> 31);
#line 225
    A += ((((B << 5) | (B >> 27)) + ((C ^ D) ^ E)) + W[34]) + 1859775393U;
#line 225
    C = (C << 30) | (C >> 2);
#line 226
    W[35] = ((((W[19] ^ W[21]) ^ W[27]) ^ W[32]) << 1) | ((((W[19] ^ W[21]) ^ W[27]) ^ W[32]) >> 31);
#line 226
    E += ((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) + W[35]) + 1859775393U;
#line 226
    B = (B << 30) | (B >> 2);
#line 227
    W[36] = ((((W[20] ^ W[22]) ^ W[28]) ^ W[33]) << 1) | ((((W[20] ^ W[22]) ^ W[28]) ^ W[33]) >> 31);
#line 227
    D += ((((E << 5) | (E >> 27)) + ((A ^ B) ^ C)) + W[36]) + 1859775393U;
#line 227
    A = (A << 30) | (A >> 2);
#line 228
    W[37] = ((((W[21] ^ W[23]) ^ W[29]) ^ W[34]) << 1) | ((((W[21] ^ W[23]) ^ W[29]) ^ W[34]) >> 31);
#line 228
    C += ((((D << 5) | (D >> 27)) + ((E ^ A) ^ B)) + W[37]) + 1859775393U;
#line 228
    E = (E << 30) | (E >> 2);
#line 229
    W[38] = ((((W[22] ^ W[24]) ^ W[30]) ^ W[35]) << 1) | ((((W[22] ^ W[24]) ^ W[30]) ^ W[35]) >> 31);
#line 229
    B += ((((C << 5) | (C >> 27)) + ((D ^ E) ^ A)) + W[38]) + 1859775393U;
#line 229
    D = (D << 30) | (D >> 2);
#line 230
    W[39] = ((((W[23] ^ W[25]) ^ W[31]) ^ W[36]) << 1) | ((((W[23] ^ W[25]) ^ W[31]) ^ W[36]) >> 31);
#line 230
    A += ((((B << 5) | (B >> 27)) + ((C ^ D) ^ E)) + W[39]) + 1859775393U;
#line 230
    C = (C << 30) | (C >> 2);
#line 232
    W[40] = ((((W[24] ^ W[26]) ^ W[32]) ^ W[37]) << 1) | ((((W[24] ^ W[26]) ^ W[32]) ^ W[37]) >> 31);
#line 232
    E += ((((A << 5) | (A >> 27)) + ((B & (C | D)) | (C & D))) + W[40]) + 2400959708U;
#line 232
    B = (B << 30) | (B >> 2);
#line 232
    W[41] = ((((W[25] ^ W[27]) ^ W[33]) ^ W[38]) << 1) | ((((W[25] ^ W[27]) ^ W[33]) ^ W[38]) >> 31);
#line 232
    D += ((((E << 5) | (E >> 27)) + ((A & (B | C)) | (B & C))) + W[41]) + 2400959708U;
#line 232
    A = (A << 30) | (A >> 2);
#line 232
    W[42] = ((((W[26] ^ W[28]) ^ W[34]) ^ W[39]) << 1) | ((((W[26] ^ W[28]) ^ W[34]) ^ W[39]) >> 31);
#line 232
    C += ((((D << 5) | (D >> 27)) + ((E & (A | B)) | (A & B))) + W[42]) + 2400959708U;
#line 232
    E = (E << 30) | (E >> 2);
#line 232
    W[43] = ((((W[27] ^ W[29]) ^ W[35]) ^ W[40]) << 1) | ((((W[27] ^ W[29]) ^ W[35]) ^ W[40]) >> 31);
#line 232
    B += ((((C << 5) | (C >> 27)) + ((D & (E | A)) | (E & A))) + W[43]) + 2400959708U;
#line 232
    D = (D << 30) | (D >> 2);
#line 232
    W[44] = ((((W[28] ^ W[30]) ^ W[36]) ^ W[41]) << 1) | ((((W[28] ^ W[30]) ^ W[36]) ^ W[41]) >> 31);
#line 232
    A += ((((B << 5) | (B >> 27)) + ((C & (D | E)) | (D & E))) + W[44]) + 2400959708U;
#line 232
    C = (C << 30) | (C >> 2);
#line 232
    W[45] = ((((W[29] ^ W[31]) ^ W[37]) ^ W[42]) << 1) | ((((W[29] ^ W[31]) ^ W[37]) ^ W[42]) >> 31);
#line 232
    E += ((((A << 5) | (A >> 27)) + ((B & (C | D)) | (C & D))) + W[45]) + 2400959708U;
#line 232
    B = (B << 30) | (B >> 2);
#line 232
    W[46] = ((((W[30] ^ W[32]) ^ W[38]) ^ W[43]) << 1) | ((((W[30] ^ W[32]) ^ W[38]) ^ W[43]) >> 31);
#line 232
    D += ((((E << 5) | (E >> 27)) + ((A & (B | C)) | (B & C))) + W[46]) + 2400959708U;
#line 232
    A = (A << 30) | (A >> 2);
#line 232
    W[47] = ((((W[31] ^ W[33]) ^ W[39]) ^ W[44]) << 1) | ((((W[31] ^ W[33]) ^ W[39]) ^ W[44]) >> 31);
#line 232
    C += ((((D << 5) | (D >> 27)) + ((E & (A | B)) | (A & B))) + W[47]) + 2400959708U;
#line 232
    E = (E << 30) | (E >> 2);
#line 232
    W[48] = ((((W[32] ^ W[34]) ^ W[40]) ^ W[45]) << 1) | ((((W[32] ^ W[34]) ^ W[40]) ^ W[45]) >> 31);
#line 232
    B += ((((C << 5) | (C >> 27)) + ((D & (E | A)) | (E & A))) + W[48]) + 2400959708U;
#line 232
    D = (D << 30) | (D >> 2);
#line 232
    W[49] = ((((W[33] ^ W[35]) ^ W[41]) ^ W[46]) << 1) | ((((W[33] ^ W[35]) ^ W[41]) ^ W[46]) >> 31);
#line 232
    A += ((((B << 5) | (B >> 27)) + ((C & (D | E)) | (D & E))) + W[49]) + 2400959708U;
#line 232
    C = (C << 30) | (C >> 2);
#line 232
    W[50] = ((((W[34] ^ W[36]) ^ W[42]) ^ W[47]) << 1) | ((((W[34] ^ W[36]) ^ W[42]) ^ W[47]) >> 31);
#line 232
    E += ((((A << 5) | (A >> 27)) + ((B & (C | D)) | (C & D))) + W[50]) + 2400959708U;
#line 232
    B = (B << 30) | (B >> 2);
#line 232
    W[51] = ((((W[35] ^ W[37]) ^ W[43]) ^ W[48]) << 1) | ((((W[35] ^ W[37]) ^ W[43]) ^ W[48]) >> 31);
#line 232
    D += ((((E << 5) | (E >> 27)) + ((A & (B | C)) | (B & C))) + W[51]) + 2400959708U;
#line 232
    A = (A << 30) | (A >> 2);
#line 232
    W[52] = ((((W[36] ^ W[38]) ^ W[44]) ^ W[49]) << 1) | ((((W[36] ^ W[38]) ^ W[44]) ^ W[49]) >> 31);
#line 232
    C += ((((D << 5) | (D >> 27)) + ((E & (A | B)) | (A & B))) + W[52]) + 2400959708U;
#line 232
    E = (E << 30) | (E >> 2);
#line 232
    W[53] = ((((W[37] ^ W[39]) ^ W[45]) ^ W[50]) << 1) | ((((W[37] ^ W[39]) ^ W[45]) ^ W[50]) >> 31);
#line 232
    B += ((((C << 5) | (C >> 27)) + ((D & (E | A)) | (E & A))) + W[53]) + 2400959708U;
#line 232
    D = (D << 30) | (D >> 2);
#line 232
    W[54] = ((((W[38] ^ W[40]) ^ W[46]) ^ W[51]) << 1) | ((((W[38] ^ W[40]) ^ W[46]) ^ W[51]) >> 31);
#line 232
    A += ((((B << 5) | (B >> 27)) + ((C & (D | E)) | (D & E))) + W[54]) + 2400959708U;
#line 232
    C = (C << 30) | (C >> 2);
#line 232
    W[55] = ((((W[39] ^ W[41]) ^ W[47]) ^ W[52]) << 1) | ((((W[39] ^ W[41]) ^ W[47]) ^ W[52]) >> 31);
#line 232
    E += ((((A << 5) | (A >> 27)) + ((B & (C | D)) | (C & D))) + W[55]) + 2400959708U;
#line 232
    B = (B << 30) | (B >> 2);
#line 232
    W[56] = ((((W[40] ^ W[42]) ^ W[48]) ^ W[53]) << 1) | ((((W[40] ^ W[42]) ^ W[48]) ^ W[53]) >> 31);
#line 232
    D += ((((E << 5) | (E >> 27)) + ((A & (B | C)) | (B & C))) + W[56]) + 2400959708U;
#line 232
    A = (A << 30) | (A >> 2);
#line 232
    W[57] = ((((W[41] ^ W[43]) ^ W[49]) ^ W[54]) << 1) | ((((W[41] ^ W[43]) ^ W[49]) ^ W[54]) >> 31);
#line 232
    C += ((((D << 5) | (D >> 27)) + ((E & (A | B)) | (A & B))) + W[57]) + 2400959708U;
#line 232
    E = (E << 30) | (E >> 2);
#line 232
    W[58] = ((((W[42] ^ W[44]) ^ W[50]) ^ W[55]) << 1) | ((((W[42] ^ W[44]) ^ W[50]) ^ W[55]) >> 31);
#line 232
    B += ((((C << 5) | (C >> 27)) + ((D & (E | A)) | (E & A))) + W[58]) + 2400959708U;
#line 232
    D = (D << 30) | (D >> 2);
#line 232
    W[59] = ((((W[43] ^ W[45]) ^ W[51]) ^ W[56]) << 1) | ((((W[43] ^ W[45]) ^ W[51]) ^ W[56]) >> 31);
#line 232
    A += ((((B << 5) | (B >> 27)) + ((C & (D | E)) | (D & E))) + W[59]) + 2400959708U;
#line 232
    C = (C << 30) | (C >> 2);
#line 233
    W[60] = ((((W[44] ^ W[46]) ^ W[52]) ^ W[57]) << 1) | ((((W[44] ^ W[46]) ^ W[52]) ^ W[57]) >> 31);
#line 233
    E += ((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) + W[60]) + 3395469782U;
#line 233
    B = (B << 30) | (B >> 2);
#line 233
    W[61] = ((((W[45] ^ W[47]) ^ W[53]) ^ W[58]) << 1) | ((((W[45] ^ W[47]) ^ W[53]) ^ W[58]) >> 31);
#line 233
    D += ((((E << 5) | (E >> 27)) + ((A ^ B) ^ C)) + W[61]) + 3395469782U;
#line 233
    A = (A << 30) | (A >> 2);
#line 233
    W[62] = ((((W[46] ^ W[48]) ^ W[54]) ^ W[59]) << 1) | ((((W[46] ^ W[48]) ^ W[54]) ^ W[59]) >> 31);
#line 233
    C += ((((D << 5) | (D >> 27)) + ((E ^ A) ^ B)) + W[62]) + 3395469782U;
#line 233
    E = (E << 30) | (E >> 2);
#line 233
    W[63] = ((((W[47] ^ W[49]) ^ W[55]) ^ W[60]) << 1) | ((((W[47] ^ W[49]) ^ W[55]) ^ W[60]) >> 31);
#line 233
    B += ((((C << 5) | (C >> 27)) + ((D ^ E) ^ A)) + W[63]) + 3395469782U;
#line 233
    D = (D << 30) | (D >> 2);
#line 233
    W[64] = ((((W[48] ^ W[50]) ^ W[56]) ^ W[61]) << 1) | ((((W[48] ^ W[50]) ^ W[56]) ^ W[61]) >> 31);
#line 233
    A += ((((B << 5) | (B >> 27)) + ((C ^ D) ^ E)) + W[64]) + 3395469782U;
#line 233
    C = (C << 30) | (C >> 2);
#line 233
    W[65] = ((((W[49] ^ W[51]) ^ W[57]) ^ W[62]) << 1) | ((((W[49] ^ W[51]) ^ W[57]) ^ W[62]) >> 31);
#line 233
    E += ((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) + W[65]) + 3395469782U;
#line 233
    B = (B << 30) | (B >> 2);
#line 233
    W[66] = ((((W[50] ^ W[52]) ^ W[58]) ^ W[63]) << 1) | ((((W[50] ^ W[52]) ^ W[58]) ^ W[63]) >> 31);
#line 233
    D += ((((E << 5) | (E >> 27)) + ((A ^ B) ^ C)) + W[66]) + 3395469782U;
#line 233
    A = (A << 30) | (A >> 2);
#line 233
    W[67] = ((((W[51] ^ W[53]) ^ W[59]) ^ W[64]) << 1) | ((((W[51] ^ W[53]) ^ W[59]) ^ W[64]) >> 31);
#line 233
    C += ((((D << 5) | (D >> 27)) + ((E ^ A) ^ B)) + W[67]) + 3395469782U;
#line 233
    E = (E << 30) | (E >> 2);
#line 233
    W[68] = ((((W[52] ^ W[54]) ^ W[60]) ^ W[65]) << 1) | ((((W[52] ^ W[54]) ^ W[60]) ^ W[65]) >> 31);
#line 233
    B += ((((C << 5) | (C >> 27)) + ((D ^ E) ^ A)) + W[68]) + 3395469782U;
#line 233
    D = (D << 30) | (D >> 2);
#line 233
    W[69] = ((((W[53] ^ W[55]) ^ W[61]) ^ W[66]) << 1) | ((((W[53] ^ W[55]) ^ W[61]) ^ W[66]) >> 31);
#line 233
    A += ((((B << 5) | (B >> 27)) + ((C ^ D) ^ E)) + W[69]) + 3395469782U;
#line 233
    C = (C << 30) | (C >> 2);
#line 233
    W[70] = ((((W[54] ^ W[56]) ^ W[62]) ^ W[67]) << 1) | ((((W[54] ^ W[56]) ^ W[62]) ^ W[67]) >> 31);
#line 233
    E += ((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) + W[70]) + 3395469782U;
#line 233
    B = (B << 30) | (B >> 2);
#line 233
    W[71] = ((((W[55] ^ W[57]) ^ W[63]) ^ W[68]) << 1) | ((((W[55] ^ W[57]) ^ W[63]) ^ W[68]) >> 31);
#line 233
    D += ((((E << 5) | (E >> 27)) + ((A ^ B) ^ C)) + W[71]) + 3395469782U;
#line 233
    A = (A << 30) | (A >> 2);
#line 233
    W[72] = ((((W[56] ^ W[58]) ^ W[64]) ^ W[69]) << 1) | ((((W[56] ^ W[58]) ^ W[64]) ^ W[69]) >> 31);
#line 233
    C += ((((D << 5) | (D >> 27)) + ((E ^ A) ^ B)) + W[72]) + 3395469782U;
#line 233
    E = (E << 30) | (E >> 2);
#line 233
    W[73] = ((((W[57] ^ W[59]) ^ W[65]) ^ W[70]) << 1) | ((((W[57] ^ W[59]) ^ W[65]) ^ W[70]) >> 31);
#line 233
    B += ((((C << 5) | (C >> 27)) + ((D ^ E) ^ A)) + W[73]) + 3395469782U;
#line 233
    D = (D << 30) | (D >> 2);
#line 233
    W[74] = ((((W[58] ^ W[60]) ^ W[66]) ^ W[71]) << 1) | ((((W[58] ^ W[60]) ^ W[66]) ^ W[71]) >> 31);
#line 233
    A += ((((B << 5) | (B >> 27)) + ((C ^ D) ^ E)) + W[74]) + 3395469782U;
#line 233
    C = (C << 30) | (C >> 2);
#line 233
    W[75] = ((((W[59] ^ W[61]) ^ W[67]) ^ W[72]) << 1) | ((((W[59] ^ W[61]) ^ W[67]) ^ W[72]) >> 31);
#line 233
    E += ((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) + W[75]) + 3395469782U;
#line 233
    B = (B << 30) | (B >> 2);
#line 233
    W[76] = ((((W[60] ^ W[62]) ^ W[68]) ^ W[73]) << 1) | ((((W[60] ^ W[62]) ^ W[68]) ^ W[73]) >> 31);
#line 233
    D += ((((E << 5) | (E >> 27)) + ((A ^ B) ^ C)) + W[76]) + 3395469782U;
#line 233
    A = (A << 30) | (A >> 2);
#line 233
    W[77] = ((((W[61] ^ W[63]) ^ W[69]) ^ W[74]) << 1) | ((((W[61] ^ W[63]) ^ W[69]) ^ W[74]) >> 31);
#line 233
    C += ((((D << 5) | (D >> 27)) + ((E ^ A) ^ B)) + W[77]) + 3395469782U;
#line 233
    E = (E << 30) | (E >> 2);
#line 233
    W[78] = ((((W[62] ^ W[64]) ^ W[70]) ^ W[75]) << 1) | ((((W[62] ^ W[64]) ^ W[70]) ^ W[75]) >> 31);
#line 233
    B += ((((C << 5) | (C >> 27)) + ((D ^ E) ^ A)) + W[78]) + 3395469782U;
#line 233
    D = (D << 30) | (D >> 2);
#line 233
    W[79] = ((((W[63] ^ W[65]) ^ W[71]) ^ W[76]) << 1) | ((((W[63] ^ W[65]) ^ W[71]) ^ W[76]) >> 31);
#line 233
    A += ((((B << 5) | (B >> 27)) + ((C ^ D) ^ E)) + W[79]) + 3395469782U;
#line 233
    C = (C << 30) | (C >> 2);
#line 236
    A += H[0];
#line 237
    B += H[1];
#line 238
    C += H[2];
#line 239
    D += H[3];
#line 240
    E += H[4];
#line 243
    if (! (A & bitMask1Low)) {
#line 243
      if (! (B & bitMask1High)) {
#line 245
        gotBits = 0;
#line 246
        if (A) {
#line 247
          s = A;
          {
#line 248
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 248
            if (! (! (s & 2147483648U))) {
#line 248
              goto while_break___6;
            }
#line 249
            s <<= 1;
#line 250
            gotBits ++;
          }
          while_break___6: /* CIL Label */ ;
          }
        } else {
#line 253
          gotBits = 32;
#line 254
          if (B) {
#line 255
            s = B;
            {
#line 256
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 256
              if (! (! (s & 2147483648U))) {
#line 256
                goto while_break___7;
              }
#line 257
              s <<= 1;
#line 258
              gotBits ++;
            }
            while_break___7: /* CIL Label */ ;
            }
          } else {
#line 261
            gotBits = 64;
          }
        }
#line 265
        *best = gotBits;
#line 267
        maxBits = gotBits + 1;
#line 268
        if (maxBits < 32) {
#line 269
          bitMask1Low = ~ ((1U << (32 - maxBits)) - 1U);
#line 270
          bitMask1High = (uInt32 )0;
        } else {
#line 272
          bitMask1Low = (uInt32 )(~ 0);
#line 273
          bitMask1High = ~ ((1U << (64 - maxBits)) - 1U);
        }
#line 277
        t = 0;
        {
#line 277
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 277
          if (! (t < 16)) {
#line 277
            goto while_break___8;
          }
#line 278
          *((output + t * 4) + 0) = (unsigned char )((W[t] >> 24) & 255U);
#line 278
          *((output + t * 4) + 1) = (unsigned char )((W[t] >> 16) & 255U);
#line 278
          *((output + t * 4) + 2) = (unsigned char )((W[t] >> 8) & 255U);
#line 278
          *((output + t * 4) + 3) = (unsigned char )(W[t] & 255U);
#line 277
          t ++;
        }
        while_break___8: /* CIL Label */ ;
        }
#line 281
        if (gotBits >= bits) {
#line 282
          return (iters + 1UL);
        }
      }
    }
    {
#line 285
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 285
      if ((unsigned long )cb != (unsigned long )((void *)0)) {
#line 285
        if ((iters & 65535UL) == 0UL) {
          {
#line 285
          gettimeofday((struct timeval */* __restrict  */)(& curr), (__timezone_ptr_t )((void *)0));
          }
#line 285
          if (gotBits > lastBits) {
#line 285
            goto _L___1;
          } else
#line 285
          if (curr.tv_sec - prev.tv_sec > 1L) {
#line 285
            goto _L___1;
          } else {
#line 285
            if (curr.tv_sec - prev.tv_sec) {
#line 285
              tmp___5 = 1000000;
            } else {
#line 285
              tmp___5 = 0;
            }
#line 285
            if ((curr.tv_usec + (__suseconds_t )tmp___5) - prev.tv_usec > 100000L) {
              _L___1: /* CIL Label */ 
              {
#line 285
              percent = (double )((int )(((counter + (double )iters) / expected) * (double )100 + 0.5));
#line 285
              tmp___4 = (*cb)((int )percent, *best, bits, counter + (double )iters,
                              expected, user_args);
              }
#line 285
              if (! tmp___4) {
#line 285
                *best = -1;
#line 285
                return (0UL);
              }
#line 285
              prev = curr;
#line 285
              lastBits = gotBits;
            }
          }
        }
      }
#line 285
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 87
    iters ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 288
  return (iters + 1UL);
}
}
#line 167 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libfastmint.h"
unsigned long minter_ansi_standard_2(int bits , int *best , unsigned char *block ,
                                     uInt32 const   *IV , int tailIndex , unsigned long maxIter ,
                                     int (*cb)(int percent , int largest , int target ,
                                               double count , double expected , void *user ) ,
                                     void *user_args , double counter , double expected ) ;
#line 168
int minter_ansi_standard_2_test(void) ;
#line 4 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/fastmint_ansi_standard_2.c"
int minter_ansi_standard_2_test(void) 
{ 


  {
#line 7
  return (1);
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/fastmint_ansi_standard_2.c"
static int const   endTest___3  =    (int const   )3;
#line 90 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/fastmint_ansi_standard_2.c"
unsigned long minter_ansi_standard_2(int bits , int *best , unsigned char *block ,
                                     uInt32 const   *IV , int tailIndex , unsigned long maxIter ,
                                     int (*cb)(int percent , int largest , int target ,
                                               double count , double expected , void *user ) ,
                                     void *user_args , double counter , double expected ) 
{ 
  double percent ;
  struct timeval prev ;
  struct timeval curr ;
  int lastBits ;
  unsigned long iters ;
  int n ;
  int t ;
  int gotBits ;
  int maxBits ;
  int tmp ;
  uInt32 bitMask1Low ;
  uInt32 bitMask1High ;
  uInt32 s ;
  uInt32 A ;
  uInt32 B ;
  uInt32 *W ;
  uInt32 A1 ;
  uInt32 B1 ;
  uInt32 C1 ;
  uInt32 D1 ;
  uInt32 E1 ;
  uInt32 A2 ;
  uInt32 B2 ;
  uInt32 C2 ;
  uInt32 D2 ;
  uInt32 E2 ;
  uInt32 W1[80] ;
  unsigned int tmp___0 ;
  uInt32 W2[80] ;
  unsigned int tmp___1 ;
  uInt32 H[5] ;
  unsigned int tmp___2 ;
  uInt32 pH[5] ;
  unsigned int tmp___3 ;
  char const   *p ;
  unsigned char *X1 ;
  unsigned char *X2 ;
  int addressMask ;
  unsigned char *output ;
  uInt32 tmp___4 ;
  uInt32 tmp___5 ;
  unsigned char tmp___6 ;
  unsigned char tmp___7 ;
  unsigned char tmp___8 ;
  unsigned char tmp___9 ;
  unsigned char tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 92
  prev.tv_sec = (__time_t )0;
#line 92
  prev.tv_usec = (__suseconds_t )0;
#line 92
  lastBits = 0;
#line 93
  iters = 0UL;
#line 94
  n = 0;
#line 94
  t = 0;
#line 94
  gotBits = 0;
#line 94
  if (bits > 16) {
#line 94
    tmp = 16;
  } else {
#line 94
    tmp = bits;
  }
#line 94
  maxBits = tmp;
#line 95
  bitMask1Low = (uInt32 )0;
#line 95
  bitMask1High = (uInt32 )0;
#line 95
  s = (uInt32 )0;
#line 96
  A = (uInt32 )0;
#line 96
  B = (uInt32 )0;
#line 96
  W = (uInt32 *)((void *)0);
#line 97
  A1 = (uInt32 )0;
#line 97
  B1 = (uInt32 )0;
#line 97
  C1 = (uInt32 )0;
#line 97
  D1 = (uInt32 )0;
#line 97
  E1 = (uInt32 )0;
#line 98
  A2 = (uInt32 )0;
#line 98
  B2 = (uInt32 )0;
#line 98
  C2 = (uInt32 )0;
#line 98
  D2 = (uInt32 )0;
#line 98
  E2 = (uInt32 )0;
#line 99
  W1[0] = (uInt32 )0;
#line 99
  tmp___0 = 1U;
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (tmp___0 >= 80U) {
#line 99
      goto while_break;
    }
#line 99
    W1[tmp___0] = 0U;
#line 99
    tmp___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 100
  W2[0] = (uInt32 )0;
#line 100
  tmp___1 = 1U;
  {
#line 100
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 100
    if (tmp___1 >= 80U) {
#line 100
      goto while_break___0;
    }
#line 100
    W2[tmp___1] = 0U;
#line 100
    tmp___1 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 101
  H[0] = (uInt32 )0;
#line 101
  tmp___2 = 1U;
  {
#line 101
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 101
    if (tmp___2 >= 5U) {
#line 101
      goto while_break___1;
    }
#line 101
    H[tmp___2] = 0U;
#line 101
    tmp___2 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 101
  pH[0] = (uInt32 )0;
#line 101
  tmp___3 = 1U;
  {
#line 101
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 101
    if (tmp___3 >= 5U) {
#line 101
      goto while_break___2;
    }
#line 101
    pH[tmp___3] = 0U;
#line 101
    tmp___3 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 102
  p = encodeAlphabets[4];
#line 103
  X1 = (unsigned char *)(W1);
#line 104
  X2 = (unsigned char *)(W2);
#line 105
  addressMask = 0;
#line 107
  output = block;
#line 109
  *best = 0;
#line 112
  addressMask = (int )*((char *)(& endTest___3));
#line 115
  if (maxBits < 32) {
#line 116
    if (bits == 0) {
#line 116
      bitMask1Low = (uInt32 )0;
    } else {
#line 117
      bitMask1Low = ~ ((1U << (32 - maxBits)) - 1U);
    }
#line 119
    bitMask1High = (uInt32 )0;
  } else {
#line 121
    bitMask1Low = (uInt32 )(~ 0);
#line 122
    bitMask1High = ~ ((1U << (64 - maxBits)) - 1U);
  }
#line 124
  maxBits = 0;
#line 127
  t = 0;
  {
#line 127
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 127
    if (! (t < 16)) {
#line 127
      goto while_break___3;
    }
#line 128
    tmp___4 = (uInt32 )(((((int )*((output + t * 4) + 0) << 24) | ((int )*((output + t * 4) + 1) << 16)) | ((int )*((output + t * 4) + 2) << 8)) | (int )*((output + t * 4) + 3));
#line 128
    W2[t] = tmp___4;
#line 128
    W1[t] = tmp___4;
#line 127
    t ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 129
  t = 0;
  {
#line 129
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 129
    if (! (t < 5)) {
#line 129
      goto while_break___4;
    }
#line 130
    tmp___5 = (uInt32 )*(IV + t);
#line 130
    H[t] = tmp___5;
#line 130
    pH[t] = tmp___5;
#line 129
    t ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 133
  iters = 0UL;
  {
#line 133
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 133
    if (! (iters < maxIter - 2UL)) {
#line 133
      goto while_break___5;
    }
#line 136
    *(X1 + ((tailIndex - 1) ^ addressMask)) = (unsigned char )*(p + (iters & 63UL));
#line 137
    *(X2 + ((tailIndex - 1) ^ addressMask)) = (unsigned char )*(p + ((iters + 1UL) & 63UL));
#line 138
    if (! (iters & 63UL)) {
#line 139
      if (iters >> 6) {
#line 140
        tmp___6 = (unsigned char )*(p + ((iters >> 6) & 63UL));
#line 140
        *(X2 + ((tailIndex - 2) ^ addressMask)) = tmp___6;
#line 140
        *(X1 + ((tailIndex - 2) ^ addressMask)) = tmp___6;
      }
#line 142
      if (iters >> 12) {
#line 143
        tmp___7 = (unsigned char )*(p + ((iters >> 12) & 63UL));
#line 143
        *(X2 + ((tailIndex - 3) ^ addressMask)) = tmp___7;
#line 143
        *(X1 + ((tailIndex - 3) ^ addressMask)) = tmp___7;
      }
#line 145
      if (iters >> 18) {
#line 146
        tmp___8 = (unsigned char )*(p + ((iters >> 18) & 63UL));
#line 146
        *(X2 + ((tailIndex - 4) ^ addressMask)) = tmp___8;
#line 146
        *(X1 + ((tailIndex - 4) ^ addressMask)) = tmp___8;
      }
#line 148
      if (iters >> 24) {
#line 149
        tmp___9 = (unsigned char )*(p + ((iters >> 24) & 63UL));
#line 149
        *(X2 + ((tailIndex - 5) ^ addressMask)) = tmp___9;
#line 149
        *(X1 + ((tailIndex - 5) ^ addressMask)) = tmp___9;
      }
#line 151
      if (iters >> 30) {
#line 152
        tmp___10 = (unsigned char )*(p + ((iters >> 30) & 63UL));
#line 152
        *(X2 + ((tailIndex - 6) ^ addressMask)) = tmp___10;
#line 152
        *(X1 + ((tailIndex - 6) ^ addressMask)) = tmp___10;
      }
    }
#line 157
    if (! (iters & 16777215UL)) {
#line 157
      if (tailIndex == 52) {
#line 157
        goto _L;
      } else
#line 157
      if (tailIndex == 32) {
        _L: /* CIL Label */ 
#line 158
        A1 = H[0];
#line 159
        B1 = H[1];
#line 160
        C1 = H[2];
#line 161
        D1 = H[3];
#line 162
        E1 = H[4];
#line 164
        t = 16;
        {
#line 164
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 164
          if (! (t < 32)) {
#line 164
            goto while_break___6;
          }
#line 165
          W1[t] = ((((W1[t - 16] ^ W1[t - 14]) ^ W1[t - 8]) ^ W1[t - 3]) << 1) | ((((W1[t - 16] ^ W1[t - 14]) ^ W1[t - 8]) ^ W1[t - 3]) >> 31);
#line 166
          W2[t] = ((((W2[t - 16] ^ W2[t - 14]) ^ W2[t - 8]) ^ W2[t - 3]) << 1) | ((((W2[t - 16] ^ W2[t - 14]) ^ W2[t - 8]) ^ W2[t - 3]) >> 31);
#line 164
          t ++;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 169
        E1 += ((((A1 << 5) | (A1 >> 27)) + ((B1 & C1) | (~ B1 & D1))) + W1[0]) + 1518500249U;
#line 169
        B1 = (B1 << 30) | (B1 >> 2);
#line 170
        D1 += ((((E1 << 5) | (E1 >> 27)) + ((A1 & B1) | (~ A1 & C1))) + W1[1]) + 1518500249U;
#line 170
        A1 = (A1 << 30) | (A1 >> 2);
#line 171
        C1 += ((((D1 << 5) | (D1 >> 27)) + ((E1 & A1) | (~ E1 & B1))) + W1[2]) + 1518500249U;
#line 171
        E1 = (E1 << 30) | (E1 >> 2);
#line 172
        B1 += ((((C1 << 5) | (C1 >> 27)) + ((D1 & E1) | (~ D1 & A1))) + W1[3]) + 1518500249U;
#line 172
        D1 = (D1 << 30) | (D1 >> 2);
#line 173
        A1 += ((((B1 << 5) | (B1 >> 27)) + ((C1 & D1) | (~ C1 & E1))) + W1[4]) + 1518500249U;
#line 173
        C1 = (C1 << 30) | (C1 >> 2);
#line 174
        E1 += ((((A1 << 5) | (A1 >> 27)) + ((B1 & C1) | (~ B1 & D1))) + W1[5]) + 1518500249U;
#line 174
        B1 = (B1 << 30) | (B1 >> 2);
#line 175
        D1 += ((((E1 << 5) | (E1 >> 27)) + ((A1 & B1) | (~ A1 & C1))) + W1[6]) + 1518500249U;
#line 175
        A1 = (A1 << 30) | (A1 >> 2);
#line 177
        if (tailIndex == 52) {
#line 178
          C1 += ((((D1 << 5) | (D1 >> 27)) + ((E1 & A1) | (~ E1 & B1))) + W1[7]) + 1518500249U;
#line 178
          E1 = (E1 << 30) | (E1 >> 2);
#line 179
          B1 += ((((C1 << 5) | (C1 >> 27)) + ((D1 & E1) | (~ D1 & A1))) + W1[8]) + 1518500249U;
#line 179
          D1 = (D1 << 30) | (D1 >> 2);
#line 180
          A1 += ((((B1 << 5) | (B1 >> 27)) + ((C1 & D1) | (~ C1 & E1))) + W1[9]) + 1518500249U;
#line 180
          C1 = (C1 << 30) | (C1 >> 2);
#line 181
          E1 += ((((A1 << 5) | (A1 >> 27)) + ((B1 & C1) | (~ B1 & D1))) + W1[10]) + 1518500249U;
#line 181
          B1 = (B1 << 30) | (B1 >> 2);
#line 182
          D1 += ((((E1 << 5) | (E1 >> 27)) + ((A1 & B1) | (~ A1 & C1))) + W1[11]) + 1518500249U;
#line 182
          A1 = (A1 << 30) | (A1 >> 2);
        }
#line 185
        pH[0] = A1;
#line 186
        pH[1] = B1;
#line 187
        pH[2] = C1;
#line 188
        pH[3] = D1;
#line 189
        pH[4] = E1;
      }
    }
#line 193
    A2 = pH[0];
#line 193
    A1 = A2;
#line 194
    B2 = pH[1];
#line 194
    B1 = B2;
#line 195
    C2 = pH[2];
#line 195
    C1 = C2;
#line 196
    D2 = pH[3];
#line 196
    D1 = D2;
#line 197
    E2 = pH[4];
#line 197
    E1 = E2;
    {
#line 209
    if (tailIndex == 32) {
#line 209
      goto case_32;
    }
#line 215
    if (tailIndex == 52) {
#line 215
      goto case_52;
    }
#line 201
    goto switch_default;
    switch_default: /* CIL Label */ 
#line 202
    E1 += ((((A1 << 5) | (A1 >> 27)) + ((B1 & C1) | (~ B1 & D1))) + W1[0]) + 1518500249U;
#line 202
    B1 = (B1 << 30) | (B1 >> 2);
#line 202
    E2 += ((((A2 << 5) | (A2 >> 27)) + ((B2 & C2) | (~ B2 & D2))) + W2[0]) + 1518500249U;
#line 202
    B2 = (B2 << 30) | (B2 >> 2);
#line 203
    D1 += ((((E1 << 5) | (E1 >> 27)) + ((A1 & B1) | (~ A1 & C1))) + W1[1]) + 1518500249U;
#line 203
    A1 = (A1 << 30) | (A1 >> 2);
#line 203
    D2 += ((((E2 << 5) | (E2 >> 27)) + ((A2 & B2) | (~ A2 & C2))) + W2[1]) + 1518500249U;
#line 203
    A2 = (A2 << 30) | (A2 >> 2);
#line 204
    C1 += ((((D1 << 5) | (D1 >> 27)) + ((E1 & A1) | (~ E1 & B1))) + W1[2]) + 1518500249U;
#line 204
    E1 = (E1 << 30) | (E1 >> 2);
#line 204
    C2 += ((((D2 << 5) | (D2 >> 27)) + ((E2 & A2) | (~ E2 & B2))) + W2[2]) + 1518500249U;
#line 204
    E2 = (E2 << 30) | (E2 >> 2);
#line 205
    B1 += ((((C1 << 5) | (C1 >> 27)) + ((D1 & E1) | (~ D1 & A1))) + W1[3]) + 1518500249U;
#line 205
    D1 = (D1 << 30) | (D1 >> 2);
#line 205
    B2 += ((((C2 << 5) | (C2 >> 27)) + ((D2 & E2) | (~ D2 & A2))) + W2[3]) + 1518500249U;
#line 205
    D2 = (D2 << 30) | (D2 >> 2);
#line 206
    A1 += ((((B1 << 5) | (B1 >> 27)) + ((C1 & D1) | (~ C1 & E1))) + W1[4]) + 1518500249U;
#line 206
    C1 = (C1 << 30) | (C1 >> 2);
#line 206
    A2 += ((((B2 << 5) | (B2 >> 27)) + ((C2 & D2) | (~ C2 & E2))) + W2[4]) + 1518500249U;
#line 206
    C2 = (C2 << 30) | (C2 >> 2);
#line 207
    E1 += ((((A1 << 5) | (A1 >> 27)) + ((B1 & C1) | (~ B1 & D1))) + W1[5]) + 1518500249U;
#line 207
    B1 = (B1 << 30) | (B1 >> 2);
#line 207
    E2 += ((((A2 << 5) | (A2 >> 27)) + ((B2 & C2) | (~ B2 & D2))) + W2[5]) + 1518500249U;
#line 207
    B2 = (B2 << 30) | (B2 >> 2);
#line 208
    D1 += ((((E1 << 5) | (E1 >> 27)) + ((A1 & B1) | (~ A1 & C1))) + W1[6]) + 1518500249U;
#line 208
    A1 = (A1 << 30) | (A1 >> 2);
#line 208
    D2 += ((((E2 << 5) | (E2 >> 27)) + ((A2 & B2) | (~ A2 & C2))) + W2[6]) + 1518500249U;
#line 208
    A2 = (A2 << 30) | (A2 >> 2);
    case_32: /* CIL Label */ 
#line 210
    C1 += ((((D1 << 5) | (D1 >> 27)) + ((E1 & A1) | (~ E1 & B1))) + W1[7]) + 1518500249U;
#line 210
    E1 = (E1 << 30) | (E1 >> 2);
#line 210
    C2 += ((((D2 << 5) | (D2 >> 27)) + ((E2 & A2) | (~ E2 & B2))) + W2[7]) + 1518500249U;
#line 210
    E2 = (E2 << 30) | (E2 >> 2);
#line 211
    B1 += ((((C1 << 5) | (C1 >> 27)) + ((D1 & E1) | (~ D1 & A1))) + W1[8]) + 1518500249U;
#line 211
    D1 = (D1 << 30) | (D1 >> 2);
#line 211
    B2 += ((((C2 << 5) | (C2 >> 27)) + ((D2 & E2) | (~ D2 & A2))) + W2[8]) + 1518500249U;
#line 211
    D2 = (D2 << 30) | (D2 >> 2);
#line 212
    A1 += ((((B1 << 5) | (B1 >> 27)) + ((C1 & D1) | (~ C1 & E1))) + W1[9]) + 1518500249U;
#line 212
    C1 = (C1 << 30) | (C1 >> 2);
#line 212
    A2 += ((((B2 << 5) | (B2 >> 27)) + ((C2 & D2) | (~ C2 & E2))) + W2[9]) + 1518500249U;
#line 212
    C2 = (C2 << 30) | (C2 >> 2);
#line 213
    E1 += ((((A1 << 5) | (A1 >> 27)) + ((B1 & C1) | (~ B1 & D1))) + W1[10]) + 1518500249U;
#line 213
    B1 = (B1 << 30) | (B1 >> 2);
#line 213
    E2 += ((((A2 << 5) | (A2 >> 27)) + ((B2 & C2) | (~ B2 & D2))) + W2[10]) + 1518500249U;
#line 213
    B2 = (B2 << 30) | (B2 >> 2);
#line 214
    D1 += ((((E1 << 5) | (E1 >> 27)) + ((A1 & B1) | (~ A1 & C1))) + W1[11]) + 1518500249U;
#line 214
    A1 = (A1 << 30) | (A1 >> 2);
#line 214
    D2 += ((((E2 << 5) | (E2 >> 27)) + ((A2 & B2) | (~ A2 & C2))) + W2[11]) + 1518500249U;
#line 214
    A2 = (A2 << 30) | (A2 >> 2);
    case_52: /* CIL Label */ 
#line 216
    C1 += ((((D1 << 5) | (D1 >> 27)) + ((E1 & A1) | (~ E1 & B1))) + W1[12]) + 1518500249U;
#line 216
    E1 = (E1 << 30) | (E1 >> 2);
#line 216
    C2 += ((((D2 << 5) | (D2 >> 27)) + ((E2 & A2) | (~ E2 & B2))) + W2[12]) + 1518500249U;
#line 216
    E2 = (E2 << 30) | (E2 >> 2);
#line 217
    B1 += ((((C1 << 5) | (C1 >> 27)) + ((D1 & E1) | (~ D1 & A1))) + W1[13]) + 1518500249U;
#line 217
    D1 = (D1 << 30) | (D1 >> 2);
#line 217
    B2 += ((((C2 << 5) | (C2 >> 27)) + ((D2 & E2) | (~ D2 & A2))) + W2[13]) + 1518500249U;
#line 217
    D2 = (D2 << 30) | (D2 >> 2);
#line 218
    A1 += ((((B1 << 5) | (B1 >> 27)) + ((C1 & D1) | (~ C1 & E1))) + W1[14]) + 1518500249U;
#line 218
    C1 = (C1 << 30) | (C1 >> 2);
#line 218
    A2 += ((((B2 << 5) | (B2 >> 27)) + ((C2 & D2) | (~ C2 & E2))) + W2[14]) + 1518500249U;
#line 218
    C2 = (C2 << 30) | (C2 >> 2);
#line 219
    E1 += ((((A1 << 5) | (A1 >> 27)) + ((B1 & C1) | (~ B1 & D1))) + W1[15]) + 1518500249U;
#line 219
    B1 = (B1 << 30) | (B1 >> 2);
#line 219
    E2 += ((((A2 << 5) | (A2 >> 27)) + ((B2 & C2) | (~ B2 & D2))) + W2[15]) + 1518500249U;
#line 219
    B2 = (B2 << 30) | (B2 >> 2);
    switch_break: /* CIL Label */ ;
    }
#line 222
    if (tailIndex == 52) {
#line 223
      D1 += ((((E1 << 5) | (E1 >> 27)) + ((A1 & B1) | (~ A1 & C1))) + W1[16]) + 1518500249U;
#line 223
      A1 = (A1 << 30) | (A1 >> 2);
#line 223
      D2 += ((((E2 << 5) | (E2 >> 27)) + ((A2 & B2) | (~ A2 & C2))) + W2[16]) + 1518500249U;
#line 223
      A2 = (A2 << 30) | (A2 >> 2);
#line 224
      C1 += ((((D1 << 5) | (D1 >> 27)) + ((E1 & A1) | (~ E1 & B1))) + W1[17]) + 1518500249U;
#line 224
      E1 = (E1 << 30) | (E1 >> 2);
#line 224
      C2 += ((((D2 << 5) | (D2 >> 27)) + ((E2 & A2) | (~ E2 & B2))) + W2[17]) + 1518500249U;
#line 224
      E2 = (E2 << 30) | (E2 >> 2);
#line 225
      B1 += ((((C1 << 5) | (C1 >> 27)) + ((D1 & E1) | (~ D1 & A1))) + W1[18]) + 1518500249U;
#line 225
      D1 = (D1 << 30) | (D1 >> 2);
#line 225
      B2 += ((((C2 << 5) | (C2 >> 27)) + ((D2 & E2) | (~ D2 & A2))) + W2[18]) + 1518500249U;
#line 225
      D2 = (D2 << 30) | (D2 >> 2);
#line 226
      A1 += ((((B1 << 5) | (B1 >> 27)) + ((C1 & D1) | (~ C1 & E1))) + W1[19]) + 1518500249U;
#line 226
      C1 = (C1 << 30) | (C1 >> 2);
#line 226
      A2 += ((((B2 << 5) | (B2 >> 27)) + ((C2 & D2) | (~ C2 & E2))) + W2[19]) + 1518500249U;
#line 226
      C2 = (C2 << 30) | (C2 >> 2);
#line 227
      W1[20] = ((((W1[4] ^ W1[6]) ^ W1[12]) ^ W1[17]) << 1) | ((((W1[4] ^ W1[6]) ^ W1[12]) ^ W1[17]) >> 31);
#line 227
      E1 += ((((A1 << 5) | (A1 >> 27)) + ((B1 ^ C1) ^ D1)) + W1[20]) + 1859775393U;
#line 227
      B1 = (B1 << 30) | (B1 >> 2);
#line 227
      W2[20] = ((((W2[4] ^ W2[6]) ^ W2[12]) ^ W2[17]) << 1) | ((((W2[4] ^ W2[6]) ^ W2[12]) ^ W2[17]) >> 31);
#line 227
      E2 += ((((A2 << 5) | (A2 >> 27)) + ((B2 ^ C2) ^ D2)) + W2[20]) + 1859775393U;
#line 227
      B2 = (B2 << 30) | (B2 >> 2);
#line 228
      D1 += ((((E1 << 5) | (E1 >> 27)) + ((A1 ^ B1) ^ C1)) + W1[21]) + 1859775393U;
#line 228
      A1 = (A1 << 30) | (A1 >> 2);
#line 228
      D2 += ((((E2 << 5) | (E2 >> 27)) + ((A2 ^ B2) ^ C2)) + W2[21]) + 1859775393U;
#line 228
      A2 = (A2 << 30) | (A2 >> 2);
#line 229
      C1 += ((((D1 << 5) | (D1 >> 27)) + ((E1 ^ A1) ^ B1)) + W1[22]) + 1859775393U;
#line 229
      E1 = (E1 << 30) | (E1 >> 2);
#line 229
      C2 += ((((D2 << 5) | (D2 >> 27)) + ((E2 ^ A2) ^ B2)) + W2[22]) + 1859775393U;
#line 229
      E2 = (E2 << 30) | (E2 >> 2);
#line 230
      W1[23] = ((((W1[7] ^ W1[9]) ^ W1[15]) ^ W1[20]) << 1) | ((((W1[7] ^ W1[9]) ^ W1[15]) ^ W1[20]) >> 31);
#line 230
      B1 += ((((C1 << 5) | (C1 >> 27)) + ((D1 ^ E1) ^ A1)) + W1[23]) + 1859775393U;
#line 230
      D1 = (D1 << 30) | (D1 >> 2);
#line 230
      W2[23] = ((((W2[7] ^ W2[9]) ^ W2[15]) ^ W2[20]) << 1) | ((((W2[7] ^ W2[9]) ^ W2[15]) ^ W2[20]) >> 31);
#line 230
      B2 += ((((C2 << 5) | (C2 >> 27)) + ((D2 ^ E2) ^ A2)) + W2[23]) + 1859775393U;
#line 230
      D2 = (D2 << 30) | (D2 >> 2);
#line 231
      A1 += ((((B1 << 5) | (B1 >> 27)) + ((C1 ^ D1) ^ E1)) + W1[24]) + 1859775393U;
#line 231
      C1 = (C1 << 30) | (C1 >> 2);
#line 231
      A2 += ((((B2 << 5) | (B2 >> 27)) + ((C2 ^ D2) ^ E2)) + W2[24]) + 1859775393U;
#line 231
      C2 = (C2 << 30) | (C2 >> 2);
#line 232
      E1 += ((((A1 << 5) | (A1 >> 27)) + ((B1 ^ C1) ^ D1)) + W1[25]) + 1859775393U;
#line 232
      B1 = (B1 << 30) | (B1 >> 2);
#line 232
      E2 += ((((A2 << 5) | (A2 >> 27)) + ((B2 ^ C2) ^ D2)) + W2[25]) + 1859775393U;
#line 232
      B2 = (B2 << 30) | (B2 >> 2);
#line 233
      W1[26] = ((((W1[10] ^ W1[12]) ^ W1[18]) ^ W1[23]) << 1) | ((((W1[10] ^ W1[12]) ^ W1[18]) ^ W1[23]) >> 31);
#line 233
      D1 += ((((E1 << 5) | (E1 >> 27)) + ((A1 ^ B1) ^ C1)) + W1[26]) + 1859775393U;
#line 233
      A1 = (A1 << 30) | (A1 >> 2);
#line 233
      W2[26] = ((((W2[10] ^ W2[12]) ^ W2[18]) ^ W2[23]) << 1) | ((((W2[10] ^ W2[12]) ^ W2[18]) ^ W2[23]) >> 31);
#line 233
      D2 += ((((E2 << 5) | (E2 >> 27)) + ((A2 ^ B2) ^ C2)) + W2[26]) + 1859775393U;
#line 233
      A2 = (A2 << 30) | (A2 >> 2);
#line 234
      C1 += ((((D1 << 5) | (D1 >> 27)) + ((E1 ^ A1) ^ B1)) + W1[27]) + 1859775393U;
#line 234
      E1 = (E1 << 30) | (E1 >> 2);
#line 234
      C2 += ((((D2 << 5) | (D2 >> 27)) + ((E2 ^ A2) ^ B2)) + W2[27]) + 1859775393U;
#line 234
      E2 = (E2 << 30) | (E2 >> 2);
#line 235
      W1[28] = ((((W1[12] ^ W1[14]) ^ W1[20]) ^ W1[25]) << 1) | ((((W1[12] ^ W1[14]) ^ W1[20]) ^ W1[25]) >> 31);
#line 235
      B1 += ((((C1 << 5) | (C1 >> 27)) + ((D1 ^ E1) ^ A1)) + W1[28]) + 1859775393U;
#line 235
      D1 = (D1 << 30) | (D1 >> 2);
#line 235
      W2[28] = ((((W2[12] ^ W2[14]) ^ W2[20]) ^ W2[25]) << 1) | ((((W2[12] ^ W2[14]) ^ W2[20]) ^ W2[25]) >> 31);
#line 235
      B2 += ((((C2 << 5) | (C2 >> 27)) + ((D2 ^ E2) ^ A2)) + W2[28]) + 1859775393U;
#line 235
      D2 = (D2 << 30) | (D2 >> 2);
#line 236
      W1[29] = ((((W1[13] ^ W1[15]) ^ W1[21]) ^ W1[26]) << 1) | ((((W1[13] ^ W1[15]) ^ W1[21]) ^ W1[26]) >> 31);
#line 236
      A1 += ((((B1 << 5) | (B1 >> 27)) + ((C1 ^ D1) ^ E1)) + W1[29]) + 1859775393U;
#line 236
      C1 = (C1 << 30) | (C1 >> 2);
#line 236
      W2[29] = ((((W2[13] ^ W2[15]) ^ W2[21]) ^ W2[26]) << 1) | ((((W2[13] ^ W2[15]) ^ W2[21]) ^ W2[26]) >> 31);
#line 236
      A2 += ((((B2 << 5) | (B2 >> 27)) + ((C2 ^ D2) ^ E2)) + W2[29]) + 1859775393U;
#line 236
      C2 = (C2 << 30) | (C2 >> 2);
#line 237
      E1 += ((((A1 << 5) | (A1 >> 27)) + ((B1 ^ C1) ^ D1)) + W1[30]) + 1859775393U;
#line 237
      B1 = (B1 << 30) | (B1 >> 2);
#line 237
      E2 += ((((A2 << 5) | (A2 >> 27)) + ((B2 ^ C2) ^ D2)) + W2[30]) + 1859775393U;
#line 237
      B2 = (B2 << 30) | (B2 >> 2);
    } else
#line 238
    if (tailIndex == 32) {
#line 239
      D1 += ((((E1 << 5) | (E1 >> 27)) + ((A1 & B1) | (~ A1 & C1))) + W1[16]) + 1518500249U;
#line 239
      A1 = (A1 << 30) | (A1 >> 2);
#line 239
      D2 += ((((E2 << 5) | (E2 >> 27)) + ((A2 & B2) | (~ A2 & C2))) + W2[16]) + 1518500249U;
#line 239
      A2 = (A2 << 30) | (A2 >> 2);
#line 240
      C1 += ((((D1 << 5) | (D1 >> 27)) + ((E1 & A1) | (~ E1 & B1))) + W1[17]) + 1518500249U;
#line 240
      E1 = (E1 << 30) | (E1 >> 2);
#line 240
      C2 += ((((D2 << 5) | (D2 >> 27)) + ((E2 & A2) | (~ E2 & B2))) + W2[17]) + 1518500249U;
#line 240
      E2 = (E2 << 30) | (E2 >> 2);
#line 241
      B1 += ((((C1 << 5) | (C1 >> 27)) + ((D1 & E1) | (~ D1 & A1))) + W1[18]) + 1518500249U;
#line 241
      D1 = (D1 << 30) | (D1 >> 2);
#line 241
      B2 += ((((C2 << 5) | (C2 >> 27)) + ((D2 & E2) | (~ D2 & A2))) + W2[18]) + 1518500249U;
#line 241
      D2 = (D2 << 30) | (D2 >> 2);
#line 242
      A1 += ((((B1 << 5) | (B1 >> 27)) + ((C1 & D1) | (~ C1 & E1))) + W1[19]) + 1518500249U;
#line 242
      C1 = (C1 << 30) | (C1 >> 2);
#line 242
      A2 += ((((B2 << 5) | (B2 >> 27)) + ((C2 & D2) | (~ C2 & E2))) + W2[19]) + 1518500249U;
#line 242
      C2 = (C2 << 30) | (C2 >> 2);
#line 243
      E1 += ((((A1 << 5) | (A1 >> 27)) + ((B1 ^ C1) ^ D1)) + W1[20]) + 1859775393U;
#line 243
      B1 = (B1 << 30) | (B1 >> 2);
#line 243
      E2 += ((((A2 << 5) | (A2 >> 27)) + ((B2 ^ C2) ^ D2)) + W2[20]) + 1859775393U;
#line 243
      B2 = (B2 << 30) | (B2 >> 2);
#line 244
      W1[21] = ((((W1[5] ^ W1[7]) ^ W1[13]) ^ W1[18]) << 1) | ((((W1[5] ^ W1[7]) ^ W1[13]) ^ W1[18]) >> 31);
#line 244
      D1 += ((((E1 << 5) | (E1 >> 27)) + ((A1 ^ B1) ^ C1)) + W1[21]) + 1859775393U;
#line 244
      A1 = (A1 << 30) | (A1 >> 2);
#line 244
      W2[21] = ((((W2[5] ^ W2[7]) ^ W2[13]) ^ W2[18]) << 1) | ((((W2[5] ^ W2[7]) ^ W2[13]) ^ W2[18]) >> 31);
#line 244
      D2 += ((((E2 << 5) | (E2 >> 27)) + ((A2 ^ B2) ^ C2)) + W2[21]) + 1859775393U;
#line 244
      A2 = (A2 << 30) | (A2 >> 2);
#line 245
      C1 += ((((D1 << 5) | (D1 >> 27)) + ((E1 ^ A1) ^ B1)) + W1[22]) + 1859775393U;
#line 245
      E1 = (E1 << 30) | (E1 >> 2);
#line 245
      C2 += ((((D2 << 5) | (D2 >> 27)) + ((E2 ^ A2) ^ B2)) + W2[22]) + 1859775393U;
#line 245
      E2 = (E2 << 30) | (E2 >> 2);
#line 246
      W1[23] = ((((W1[7] ^ W1[9]) ^ W1[15]) ^ W1[20]) << 1) | ((((W1[7] ^ W1[9]) ^ W1[15]) ^ W1[20]) >> 31);
#line 246
      B1 += ((((C1 << 5) | (C1 >> 27)) + ((D1 ^ E1) ^ A1)) + W1[23]) + 1859775393U;
#line 246
      D1 = (D1 << 30) | (D1 >> 2);
#line 246
      W2[23] = ((((W2[7] ^ W2[9]) ^ W2[15]) ^ W2[20]) << 1) | ((((W2[7] ^ W2[9]) ^ W2[15]) ^ W2[20]) >> 31);
#line 246
      B2 += ((((C2 << 5) | (C2 >> 27)) + ((D2 ^ E2) ^ A2)) + W2[23]) + 1859775393U;
#line 246
      D2 = (D2 << 30) | (D2 >> 2);
#line 247
      W1[24] = ((((W1[8] ^ W1[10]) ^ W1[16]) ^ W1[21]) << 1) | ((((W1[8] ^ W1[10]) ^ W1[16]) ^ W1[21]) >> 31);
#line 247
      A1 += ((((B1 << 5) | (B1 >> 27)) + ((C1 ^ D1) ^ E1)) + W1[24]) + 1859775393U;
#line 247
      C1 = (C1 << 30) | (C1 >> 2);
#line 247
      W2[24] = ((((W2[8] ^ W2[10]) ^ W2[16]) ^ W2[21]) << 1) | ((((W2[8] ^ W2[10]) ^ W2[16]) ^ W2[21]) >> 31);
#line 247
      A2 += ((((B2 << 5) | (B2 >> 27)) + ((C2 ^ D2) ^ E2)) + W2[24]) + 1859775393U;
#line 247
      C2 = (C2 << 30) | (C2 >> 2);
#line 248
      E1 += ((((A1 << 5) | (A1 >> 27)) + ((B1 ^ C1) ^ D1)) + W1[25]) + 1859775393U;
#line 248
      B1 = (B1 << 30) | (B1 >> 2);
#line 248
      E2 += ((((A2 << 5) | (A2 >> 27)) + ((B2 ^ C2) ^ D2)) + W2[25]) + 1859775393U;
#line 248
      B2 = (B2 << 30) | (B2 >> 2);
#line 249
      W1[26] = ((((W1[10] ^ W1[12]) ^ W1[18]) ^ W1[23]) << 1) | ((((W1[10] ^ W1[12]) ^ W1[18]) ^ W1[23]) >> 31);
#line 249
      D1 += ((((E1 << 5) | (E1 >> 27)) + ((A1 ^ B1) ^ C1)) + W1[26]) + 1859775393U;
#line 249
      A1 = (A1 << 30) | (A1 >> 2);
#line 249
      W2[26] = ((((W2[10] ^ W2[12]) ^ W2[18]) ^ W2[23]) << 1) | ((((W2[10] ^ W2[12]) ^ W2[18]) ^ W2[23]) >> 31);
#line 249
      D2 += ((((E2 << 5) | (E2 >> 27)) + ((A2 ^ B2) ^ C2)) + W2[26]) + 1859775393U;
#line 249
      A2 = (A2 << 30) | (A2 >> 2);
#line 250
      W1[27] = ((((W1[11] ^ W1[13]) ^ W1[19]) ^ W1[24]) << 1) | ((((W1[11] ^ W1[13]) ^ W1[19]) ^ W1[24]) >> 31);
#line 250
      C1 += ((((D1 << 5) | (D1 >> 27)) + ((E1 ^ A1) ^ B1)) + W1[27]) + 1859775393U;
#line 250
      E1 = (E1 << 30) | (E1 >> 2);
#line 250
      W2[27] = ((((W2[11] ^ W2[13]) ^ W2[19]) ^ W2[24]) << 1) | ((((W2[11] ^ W2[13]) ^ W2[19]) ^ W2[24]) >> 31);
#line 250
      C2 += ((((D2 << 5) | (D2 >> 27)) + ((E2 ^ A2) ^ B2)) + W2[27]) + 1859775393U;
#line 250
      E2 = (E2 << 30) | (E2 >> 2);
#line 251
      B1 += ((((C1 << 5) | (C1 >> 27)) + ((D1 ^ E1) ^ A1)) + W1[28]) + 1859775393U;
#line 251
      D1 = (D1 << 30) | (D1 >> 2);
#line 251
      B2 += ((((C2 << 5) | (C2 >> 27)) + ((D2 ^ E2) ^ A2)) + W2[28]) + 1859775393U;
#line 251
      D2 = (D2 << 30) | (D2 >> 2);
#line 252
      W1[29] = ((((W1[13] ^ W1[15]) ^ W1[21]) ^ W1[26]) << 1) | ((((W1[13] ^ W1[15]) ^ W1[21]) ^ W1[26]) >> 31);
#line 252
      A1 += ((((B1 << 5) | (B1 >> 27)) + ((C1 ^ D1) ^ E1)) + W1[29]) + 1859775393U;
#line 252
      C1 = (C1 << 30) | (C1 >> 2);
#line 252
      W2[29] = ((((W2[13] ^ W2[15]) ^ W2[21]) ^ W2[26]) << 1) | ((((W2[13] ^ W2[15]) ^ W2[21]) ^ W2[26]) >> 31);
#line 252
      A2 += ((((B2 << 5) | (B2 >> 27)) + ((C2 ^ D2) ^ E2)) + W2[29]) + 1859775393U;
#line 252
      C2 = (C2 << 30) | (C2 >> 2);
#line 253
      W1[30] = ((((W1[14] ^ W1[16]) ^ W1[22]) ^ W1[27]) << 1) | ((((W1[14] ^ W1[16]) ^ W1[22]) ^ W1[27]) >> 31);
#line 253
      E1 += ((((A1 << 5) | (A1 >> 27)) + ((B1 ^ C1) ^ D1)) + W1[30]) + 1859775393U;
#line 253
      B1 = (B1 << 30) | (B1 >> 2);
#line 253
      W2[30] = ((((W2[14] ^ W2[16]) ^ W2[22]) ^ W2[27]) << 1) | ((((W2[14] ^ W2[16]) ^ W2[22]) ^ W2[27]) >> 31);
#line 253
      E2 += ((((A2 << 5) | (A2 >> 27)) + ((B2 ^ C2) ^ D2)) + W2[30]) + 1859775393U;
#line 253
      B2 = (B2 << 30) | (B2 >> 2);
    } else {
#line 255
      W1[16] = ((((W1[0] ^ W1[2]) ^ W1[8]) ^ W1[13]) << 1) | ((((W1[0] ^ W1[2]) ^ W1[8]) ^ W1[13]) >> 31);
#line 255
      D1 += ((((E1 << 5) | (E1 >> 27)) + ((A1 & B1) | (~ A1 & C1))) + W1[16]) + 1518500249U;
#line 255
      A1 = (A1 << 30) | (A1 >> 2);
#line 255
      W2[16] = ((((W2[0] ^ W2[2]) ^ W2[8]) ^ W2[13]) << 1) | ((((W2[0] ^ W2[2]) ^ W2[8]) ^ W2[13]) >> 31);
#line 255
      D2 += ((((E2 << 5) | (E2 >> 27)) + ((A2 & B2) | (~ A2 & C2))) + W2[16]) + 1518500249U;
#line 255
      A2 = (A2 << 30) | (A2 >> 2);
#line 256
      W1[17] = ((((W1[1] ^ W1[3]) ^ W1[9]) ^ W1[14]) << 1) | ((((W1[1] ^ W1[3]) ^ W1[9]) ^ W1[14]) >> 31);
#line 256
      C1 += ((((D1 << 5) | (D1 >> 27)) + ((E1 & A1) | (~ E1 & B1))) + W1[17]) + 1518500249U;
#line 256
      E1 = (E1 << 30) | (E1 >> 2);
#line 256
      W2[17] = ((((W2[1] ^ W2[3]) ^ W2[9]) ^ W2[14]) << 1) | ((((W2[1] ^ W2[3]) ^ W2[9]) ^ W2[14]) >> 31);
#line 256
      C2 += ((((D2 << 5) | (D2 >> 27)) + ((E2 & A2) | (~ E2 & B2))) + W2[17]) + 1518500249U;
#line 256
      E2 = (E2 << 30) | (E2 >> 2);
#line 257
      W1[18] = ((((W1[2] ^ W1[4]) ^ W1[10]) ^ W1[15]) << 1) | ((((W1[2] ^ W1[4]) ^ W1[10]) ^ W1[15]) >> 31);
#line 257
      B1 += ((((C1 << 5) | (C1 >> 27)) + ((D1 & E1) | (~ D1 & A1))) + W1[18]) + 1518500249U;
#line 257
      D1 = (D1 << 30) | (D1 >> 2);
#line 257
      W2[18] = ((((W2[2] ^ W2[4]) ^ W2[10]) ^ W2[15]) << 1) | ((((W2[2] ^ W2[4]) ^ W2[10]) ^ W2[15]) >> 31);
#line 257
      B2 += ((((C2 << 5) | (C2 >> 27)) + ((D2 & E2) | (~ D2 & A2))) + W2[18]) + 1518500249U;
#line 257
      D2 = (D2 << 30) | (D2 >> 2);
#line 258
      W1[19] = ((((W1[3] ^ W1[5]) ^ W1[11]) ^ W1[16]) << 1) | ((((W1[3] ^ W1[5]) ^ W1[11]) ^ W1[16]) >> 31);
#line 258
      A1 += ((((B1 << 5) | (B1 >> 27)) + ((C1 & D1) | (~ C1 & E1))) + W1[19]) + 1518500249U;
#line 258
      C1 = (C1 << 30) | (C1 >> 2);
#line 258
      W2[19] = ((((W2[3] ^ W2[5]) ^ W2[11]) ^ W2[16]) << 1) | ((((W2[3] ^ W2[5]) ^ W2[11]) ^ W2[16]) >> 31);
#line 258
      A2 += ((((B2 << 5) | (B2 >> 27)) + ((C2 & D2) | (~ C2 & E2))) + W2[19]) + 1518500249U;
#line 258
      C2 = (C2 << 30) | (C2 >> 2);
#line 259
      W1[20] = ((((W1[4] ^ W1[6]) ^ W1[12]) ^ W1[17]) << 1) | ((((W1[4] ^ W1[6]) ^ W1[12]) ^ W1[17]) >> 31);
#line 259
      E1 += ((((A1 << 5) | (A1 >> 27)) + ((B1 ^ C1) ^ D1)) + W1[20]) + 1859775393U;
#line 259
      B1 = (B1 << 30) | (B1 >> 2);
#line 259
      W2[20] = ((((W2[4] ^ W2[6]) ^ W2[12]) ^ W2[17]) << 1) | ((((W2[4] ^ W2[6]) ^ W2[12]) ^ W2[17]) >> 31);
#line 259
      E2 += ((((A2 << 5) | (A2 >> 27)) + ((B2 ^ C2) ^ D2)) + W2[20]) + 1859775393U;
#line 259
      B2 = (B2 << 30) | (B2 >> 2);
#line 260
      W1[21] = ((((W1[5] ^ W1[7]) ^ W1[13]) ^ W1[18]) << 1) | ((((W1[5] ^ W1[7]) ^ W1[13]) ^ W1[18]) >> 31);
#line 260
      D1 += ((((E1 << 5) | (E1 >> 27)) + ((A1 ^ B1) ^ C1)) + W1[21]) + 1859775393U;
#line 260
      A1 = (A1 << 30) | (A1 >> 2);
#line 260
      W2[21] = ((((W2[5] ^ W2[7]) ^ W2[13]) ^ W2[18]) << 1) | ((((W2[5] ^ W2[7]) ^ W2[13]) ^ W2[18]) >> 31);
#line 260
      D2 += ((((E2 << 5) | (E2 >> 27)) + ((A2 ^ B2) ^ C2)) + W2[21]) + 1859775393U;
#line 260
      A2 = (A2 << 30) | (A2 >> 2);
#line 261
      W1[22] = ((((W1[6] ^ W1[8]) ^ W1[14]) ^ W1[19]) << 1) | ((((W1[6] ^ W1[8]) ^ W1[14]) ^ W1[19]) >> 31);
#line 261
      C1 += ((((D1 << 5) | (D1 >> 27)) + ((E1 ^ A1) ^ B1)) + W1[22]) + 1859775393U;
#line 261
      E1 = (E1 << 30) | (E1 >> 2);
#line 261
      W2[22] = ((((W2[6] ^ W2[8]) ^ W2[14]) ^ W2[19]) << 1) | ((((W2[6] ^ W2[8]) ^ W2[14]) ^ W2[19]) >> 31);
#line 261
      C2 += ((((D2 << 5) | (D2 >> 27)) + ((E2 ^ A2) ^ B2)) + W2[22]) + 1859775393U;
#line 261
      E2 = (E2 << 30) | (E2 >> 2);
#line 262
      W1[23] = ((((W1[7] ^ W1[9]) ^ W1[15]) ^ W1[20]) << 1) | ((((W1[7] ^ W1[9]) ^ W1[15]) ^ W1[20]) >> 31);
#line 262
      B1 += ((((C1 << 5) | (C1 >> 27)) + ((D1 ^ E1) ^ A1)) + W1[23]) + 1859775393U;
#line 262
      D1 = (D1 << 30) | (D1 >> 2);
#line 262
      W2[23] = ((((W2[7] ^ W2[9]) ^ W2[15]) ^ W2[20]) << 1) | ((((W2[7] ^ W2[9]) ^ W2[15]) ^ W2[20]) >> 31);
#line 262
      B2 += ((((C2 << 5) | (C2 >> 27)) + ((D2 ^ E2) ^ A2)) + W2[23]) + 1859775393U;
#line 262
      D2 = (D2 << 30) | (D2 >> 2);
#line 263
      W1[24] = ((((W1[8] ^ W1[10]) ^ W1[16]) ^ W1[21]) << 1) | ((((W1[8] ^ W1[10]) ^ W1[16]) ^ W1[21]) >> 31);
#line 263
      A1 += ((((B1 << 5) | (B1 >> 27)) + ((C1 ^ D1) ^ E1)) + W1[24]) + 1859775393U;
#line 263
      C1 = (C1 << 30) | (C1 >> 2);
#line 263
      W2[24] = ((((W2[8] ^ W2[10]) ^ W2[16]) ^ W2[21]) << 1) | ((((W2[8] ^ W2[10]) ^ W2[16]) ^ W2[21]) >> 31);
#line 263
      A2 += ((((B2 << 5) | (B2 >> 27)) + ((C2 ^ D2) ^ E2)) + W2[24]) + 1859775393U;
#line 263
      C2 = (C2 << 30) | (C2 >> 2);
#line 264
      W1[25] = ((((W1[9] ^ W1[11]) ^ W1[17]) ^ W1[22]) << 1) | ((((W1[9] ^ W1[11]) ^ W1[17]) ^ W1[22]) >> 31);
#line 264
      E1 += ((((A1 << 5) | (A1 >> 27)) + ((B1 ^ C1) ^ D1)) + W1[25]) + 1859775393U;
#line 264
      B1 = (B1 << 30) | (B1 >> 2);
#line 264
      W2[25] = ((((W2[9] ^ W2[11]) ^ W2[17]) ^ W2[22]) << 1) | ((((W2[9] ^ W2[11]) ^ W2[17]) ^ W2[22]) >> 31);
#line 264
      E2 += ((((A2 << 5) | (A2 >> 27)) + ((B2 ^ C2) ^ D2)) + W2[25]) + 1859775393U;
#line 264
      B2 = (B2 << 30) | (B2 >> 2);
#line 265
      W1[26] = ((((W1[10] ^ W1[12]) ^ W1[18]) ^ W1[23]) << 1) | ((((W1[10] ^ W1[12]) ^ W1[18]) ^ W1[23]) >> 31);
#line 265
      D1 += ((((E1 << 5) | (E1 >> 27)) + ((A1 ^ B1) ^ C1)) + W1[26]) + 1859775393U;
#line 265
      A1 = (A1 << 30) | (A1 >> 2);
#line 265
      W2[26] = ((((W2[10] ^ W2[12]) ^ W2[18]) ^ W2[23]) << 1) | ((((W2[10] ^ W2[12]) ^ W2[18]) ^ W2[23]) >> 31);
#line 265
      D2 += ((((E2 << 5) | (E2 >> 27)) + ((A2 ^ B2) ^ C2)) + W2[26]) + 1859775393U;
#line 265
      A2 = (A2 << 30) | (A2 >> 2);
#line 266
      W1[27] = ((((W1[11] ^ W1[13]) ^ W1[19]) ^ W1[24]) << 1) | ((((W1[11] ^ W1[13]) ^ W1[19]) ^ W1[24]) >> 31);
#line 266
      C1 += ((((D1 << 5) | (D1 >> 27)) + ((E1 ^ A1) ^ B1)) + W1[27]) + 1859775393U;
#line 266
      E1 = (E1 << 30) | (E1 >> 2);
#line 266
      W2[27] = ((((W2[11] ^ W2[13]) ^ W2[19]) ^ W2[24]) << 1) | ((((W2[11] ^ W2[13]) ^ W2[19]) ^ W2[24]) >> 31);
#line 266
      C2 += ((((D2 << 5) | (D2 >> 27)) + ((E2 ^ A2) ^ B2)) + W2[27]) + 1859775393U;
#line 266
      E2 = (E2 << 30) | (E2 >> 2);
#line 267
      W1[28] = ((((W1[12] ^ W1[14]) ^ W1[20]) ^ W1[25]) << 1) | ((((W1[12] ^ W1[14]) ^ W1[20]) ^ W1[25]) >> 31);
#line 267
      B1 += ((((C1 << 5) | (C1 >> 27)) + ((D1 ^ E1) ^ A1)) + W1[28]) + 1859775393U;
#line 267
      D1 = (D1 << 30) | (D1 >> 2);
#line 267
      W2[28] = ((((W2[12] ^ W2[14]) ^ W2[20]) ^ W2[25]) << 1) | ((((W2[12] ^ W2[14]) ^ W2[20]) ^ W2[25]) >> 31);
#line 267
      B2 += ((((C2 << 5) | (C2 >> 27)) + ((D2 ^ E2) ^ A2)) + W2[28]) + 1859775393U;
#line 267
      D2 = (D2 << 30) | (D2 >> 2);
#line 268
      W1[29] = ((((W1[13] ^ W1[15]) ^ W1[21]) ^ W1[26]) << 1) | ((((W1[13] ^ W1[15]) ^ W1[21]) ^ W1[26]) >> 31);
#line 268
      A1 += ((((B1 << 5) | (B1 >> 27)) + ((C1 ^ D1) ^ E1)) + W1[29]) + 1859775393U;
#line 268
      C1 = (C1 << 30) | (C1 >> 2);
#line 268
      W2[29] = ((((W2[13] ^ W2[15]) ^ W2[21]) ^ W2[26]) << 1) | ((((W2[13] ^ W2[15]) ^ W2[21]) ^ W2[26]) >> 31);
#line 268
      A2 += ((((B2 << 5) | (B2 >> 27)) + ((C2 ^ D2) ^ E2)) + W2[29]) + 1859775393U;
#line 268
      C2 = (C2 << 30) | (C2 >> 2);
#line 269
      W1[30] = ((((W1[14] ^ W1[16]) ^ W1[22]) ^ W1[27]) << 1) | ((((W1[14] ^ W1[16]) ^ W1[22]) ^ W1[27]) >> 31);
#line 269
      E1 += ((((A1 << 5) | (A1 >> 27)) + ((B1 ^ C1) ^ D1)) + W1[30]) + 1859775393U;
#line 269
      B1 = (B1 << 30) | (B1 >> 2);
#line 269
      W2[30] = ((((W2[14] ^ W2[16]) ^ W2[22]) ^ W2[27]) << 1) | ((((W2[14] ^ W2[16]) ^ W2[22]) ^ W2[27]) >> 31);
#line 269
      E2 += ((((A2 << 5) | (A2 >> 27)) + ((B2 ^ C2) ^ D2)) + W2[30]) + 1859775393U;
#line 269
      B2 = (B2 << 30) | (B2 >> 2);
    }
#line 272
    W1[31] = ((((W1[15] ^ W1[17]) ^ W1[23]) ^ W1[28]) << 1) | ((((W1[15] ^ W1[17]) ^ W1[23]) ^ W1[28]) >> 31);
#line 272
    D1 += ((((E1 << 5) | (E1 >> 27)) + ((A1 ^ B1) ^ C1)) + W1[31]) + 1859775393U;
#line 272
    A1 = (A1 << 30) | (A1 >> 2);
#line 272
    W2[31] = ((((W2[15] ^ W2[17]) ^ W2[23]) ^ W2[28]) << 1) | ((((W2[15] ^ W2[17]) ^ W2[23]) ^ W2[28]) >> 31);
#line 272
    D2 += ((((E2 << 5) | (E2 >> 27)) + ((A2 ^ B2) ^ C2)) + W2[31]) + 1859775393U;
#line 272
    A2 = (A2 << 30) | (A2 >> 2);
#line 273
    W1[32] = ((((W1[16] ^ W1[18]) ^ W1[24]) ^ W1[29]) << 1) | ((((W1[16] ^ W1[18]) ^ W1[24]) ^ W1[29]) >> 31);
#line 273
    C1 += ((((D1 << 5) | (D1 >> 27)) + ((E1 ^ A1) ^ B1)) + W1[32]) + 1859775393U;
#line 273
    E1 = (E1 << 30) | (E1 >> 2);
#line 273
    W2[32] = ((((W2[16] ^ W2[18]) ^ W2[24]) ^ W2[29]) << 1) | ((((W2[16] ^ W2[18]) ^ W2[24]) ^ W2[29]) >> 31);
#line 273
    C2 += ((((D2 << 5) | (D2 >> 27)) + ((E2 ^ A2) ^ B2)) + W2[32]) + 1859775393U;
#line 273
    E2 = (E2 << 30) | (E2 >> 2);
#line 274
    W1[33] = ((((W1[17] ^ W1[19]) ^ W1[25]) ^ W1[30]) << 1) | ((((W1[17] ^ W1[19]) ^ W1[25]) ^ W1[30]) >> 31);
#line 274
    B1 += ((((C1 << 5) | (C1 >> 27)) + ((D1 ^ E1) ^ A1)) + W1[33]) + 1859775393U;
#line 274
    D1 = (D1 << 30) | (D1 >> 2);
#line 274
    W2[33] = ((((W2[17] ^ W2[19]) ^ W2[25]) ^ W2[30]) << 1) | ((((W2[17] ^ W2[19]) ^ W2[25]) ^ W2[30]) >> 31);
#line 274
    B2 += ((((C2 << 5) | (C2 >> 27)) + ((D2 ^ E2) ^ A2)) + W2[33]) + 1859775393U;
#line 274
    D2 = (D2 << 30) | (D2 >> 2);
#line 275
    W1[34] = ((((W1[18] ^ W1[20]) ^ W1[26]) ^ W1[31]) << 1) | ((((W1[18] ^ W1[20]) ^ W1[26]) ^ W1[31]) >> 31);
#line 275
    A1 += ((((B1 << 5) | (B1 >> 27)) + ((C1 ^ D1) ^ E1)) + W1[34]) + 1859775393U;
#line 275
    C1 = (C1 << 30) | (C1 >> 2);
#line 275
    W2[34] = ((((W2[18] ^ W2[20]) ^ W2[26]) ^ W2[31]) << 1) | ((((W2[18] ^ W2[20]) ^ W2[26]) ^ W2[31]) >> 31);
#line 275
    A2 += ((((B2 << 5) | (B2 >> 27)) + ((C2 ^ D2) ^ E2)) + W2[34]) + 1859775393U;
#line 275
    C2 = (C2 << 30) | (C2 >> 2);
#line 276
    W1[35] = ((((W1[19] ^ W1[21]) ^ W1[27]) ^ W1[32]) << 1) | ((((W1[19] ^ W1[21]) ^ W1[27]) ^ W1[32]) >> 31);
#line 276
    E1 += ((((A1 << 5) | (A1 >> 27)) + ((B1 ^ C1) ^ D1)) + W1[35]) + 1859775393U;
#line 276
    B1 = (B1 << 30) | (B1 >> 2);
#line 276
    W2[35] = ((((W2[19] ^ W2[21]) ^ W2[27]) ^ W2[32]) << 1) | ((((W2[19] ^ W2[21]) ^ W2[27]) ^ W2[32]) >> 31);
#line 276
    E2 += ((((A2 << 5) | (A2 >> 27)) + ((B2 ^ C2) ^ D2)) + W2[35]) + 1859775393U;
#line 276
    B2 = (B2 << 30) | (B2 >> 2);
#line 277
    W1[36] = ((((W1[20] ^ W1[22]) ^ W1[28]) ^ W1[33]) << 1) | ((((W1[20] ^ W1[22]) ^ W1[28]) ^ W1[33]) >> 31);
#line 277
    D1 += ((((E1 << 5) | (E1 >> 27)) + ((A1 ^ B1) ^ C1)) + W1[36]) + 1859775393U;
#line 277
    A1 = (A1 << 30) | (A1 >> 2);
#line 277
    W2[36] = ((((W2[20] ^ W2[22]) ^ W2[28]) ^ W2[33]) << 1) | ((((W2[20] ^ W2[22]) ^ W2[28]) ^ W2[33]) >> 31);
#line 277
    D2 += ((((E2 << 5) | (E2 >> 27)) + ((A2 ^ B2) ^ C2)) + W2[36]) + 1859775393U;
#line 277
    A2 = (A2 << 30) | (A2 >> 2);
#line 278
    W1[37] = ((((W1[21] ^ W1[23]) ^ W1[29]) ^ W1[34]) << 1) | ((((W1[21] ^ W1[23]) ^ W1[29]) ^ W1[34]) >> 31);
#line 278
    C1 += ((((D1 << 5) | (D1 >> 27)) + ((E1 ^ A1) ^ B1)) + W1[37]) + 1859775393U;
#line 278
    E1 = (E1 << 30) | (E1 >> 2);
#line 278
    W2[37] = ((((W2[21] ^ W2[23]) ^ W2[29]) ^ W2[34]) << 1) | ((((W2[21] ^ W2[23]) ^ W2[29]) ^ W2[34]) >> 31);
#line 278
    C2 += ((((D2 << 5) | (D2 >> 27)) + ((E2 ^ A2) ^ B2)) + W2[37]) + 1859775393U;
#line 278
    E2 = (E2 << 30) | (E2 >> 2);
#line 279
    W1[38] = ((((W1[22] ^ W1[24]) ^ W1[30]) ^ W1[35]) << 1) | ((((W1[22] ^ W1[24]) ^ W1[30]) ^ W1[35]) >> 31);
#line 279
    B1 += ((((C1 << 5) | (C1 >> 27)) + ((D1 ^ E1) ^ A1)) + W1[38]) + 1859775393U;
#line 279
    D1 = (D1 << 30) | (D1 >> 2);
#line 279
    W2[38] = ((((W2[22] ^ W2[24]) ^ W2[30]) ^ W2[35]) << 1) | ((((W2[22] ^ W2[24]) ^ W2[30]) ^ W2[35]) >> 31);
#line 279
    B2 += ((((C2 << 5) | (C2 >> 27)) + ((D2 ^ E2) ^ A2)) + W2[38]) + 1859775393U;
#line 279
    D2 = (D2 << 30) | (D2 >> 2);
#line 280
    W1[39] = ((((W1[23] ^ W1[25]) ^ W1[31]) ^ W1[36]) << 1) | ((((W1[23] ^ W1[25]) ^ W1[31]) ^ W1[36]) >> 31);
#line 280
    A1 += ((((B1 << 5) | (B1 >> 27)) + ((C1 ^ D1) ^ E1)) + W1[39]) + 1859775393U;
#line 280
    C1 = (C1 << 30) | (C1 >> 2);
#line 280
    W2[39] = ((((W2[23] ^ W2[25]) ^ W2[31]) ^ W2[36]) << 1) | ((((W2[23] ^ W2[25]) ^ W2[31]) ^ W2[36]) >> 31);
#line 280
    A2 += ((((B2 << 5) | (B2 >> 27)) + ((C2 ^ D2) ^ E2)) + W2[39]) + 1859775393U;
#line 280
    C2 = (C2 << 30) | (C2 >> 2);
#line 282
    W1[40] = ((((W1[24] ^ W1[26]) ^ W1[32]) ^ W1[37]) << 1) | ((((W1[24] ^ W1[26]) ^ W1[32]) ^ W1[37]) >> 31);
#line 282
    E1 += ((((A1 << 5) | (A1 >> 27)) + ((B1 & (C1 | D1)) | (C1 & D1))) + W1[40]) + 2400959708U;
#line 282
    B1 = (B1 << 30) | (B1 >> 2);
#line 282
    W2[40] = ((((W2[24] ^ W2[26]) ^ W2[32]) ^ W2[37]) << 1) | ((((W2[24] ^ W2[26]) ^ W2[32]) ^ W2[37]) >> 31);
#line 282
    E2 += ((((A2 << 5) | (A2 >> 27)) + ((B2 & (C2 | D2)) | (C2 & D2))) + W2[40]) + 2400959708U;
#line 282
    B2 = (B2 << 30) | (B2 >> 2);
#line 282
    W1[41] = ((((W1[25] ^ W1[27]) ^ W1[33]) ^ W1[38]) << 1) | ((((W1[25] ^ W1[27]) ^ W1[33]) ^ W1[38]) >> 31);
#line 282
    D1 += ((((E1 << 5) | (E1 >> 27)) + ((A1 & (B1 | C1)) | (B1 & C1))) + W1[41]) + 2400959708U;
#line 282
    A1 = (A1 << 30) | (A1 >> 2);
#line 282
    W2[41] = ((((W2[25] ^ W2[27]) ^ W2[33]) ^ W2[38]) << 1) | ((((W2[25] ^ W2[27]) ^ W2[33]) ^ W2[38]) >> 31);
#line 282
    D2 += ((((E2 << 5) | (E2 >> 27)) + ((A2 & (B2 | C2)) | (B2 & C2))) + W2[41]) + 2400959708U;
#line 282
    A2 = (A2 << 30) | (A2 >> 2);
#line 282
    W1[42] = ((((W1[26] ^ W1[28]) ^ W1[34]) ^ W1[39]) << 1) | ((((W1[26] ^ W1[28]) ^ W1[34]) ^ W1[39]) >> 31);
#line 282
    C1 += ((((D1 << 5) | (D1 >> 27)) + ((E1 & (A1 | B1)) | (A1 & B1))) + W1[42]) + 2400959708U;
#line 282
    E1 = (E1 << 30) | (E1 >> 2);
#line 282
    W2[42] = ((((W2[26] ^ W2[28]) ^ W2[34]) ^ W2[39]) << 1) | ((((W2[26] ^ W2[28]) ^ W2[34]) ^ W2[39]) >> 31);
#line 282
    C2 += ((((D2 << 5) | (D2 >> 27)) + ((E2 & (A2 | B2)) | (A2 & B2))) + W2[42]) + 2400959708U;
#line 282
    E2 = (E2 << 30) | (E2 >> 2);
#line 282
    W1[43] = ((((W1[27] ^ W1[29]) ^ W1[35]) ^ W1[40]) << 1) | ((((W1[27] ^ W1[29]) ^ W1[35]) ^ W1[40]) >> 31);
#line 282
    B1 += ((((C1 << 5) | (C1 >> 27)) + ((D1 & (E1 | A1)) | (E1 & A1))) + W1[43]) + 2400959708U;
#line 282
    D1 = (D1 << 30) | (D1 >> 2);
#line 282
    W2[43] = ((((W2[27] ^ W2[29]) ^ W2[35]) ^ W2[40]) << 1) | ((((W2[27] ^ W2[29]) ^ W2[35]) ^ W2[40]) >> 31);
#line 282
    B2 += ((((C2 << 5) | (C2 >> 27)) + ((D2 & (E2 | A2)) | (E2 & A2))) + W2[43]) + 2400959708U;
#line 282
    D2 = (D2 << 30) | (D2 >> 2);
#line 282
    W1[44] = ((((W1[28] ^ W1[30]) ^ W1[36]) ^ W1[41]) << 1) | ((((W1[28] ^ W1[30]) ^ W1[36]) ^ W1[41]) >> 31);
#line 282
    A1 += ((((B1 << 5) | (B1 >> 27)) + ((C1 & (D1 | E1)) | (D1 & E1))) + W1[44]) + 2400959708U;
#line 282
    C1 = (C1 << 30) | (C1 >> 2);
#line 282
    W2[44] = ((((W2[28] ^ W2[30]) ^ W2[36]) ^ W2[41]) << 1) | ((((W2[28] ^ W2[30]) ^ W2[36]) ^ W2[41]) >> 31);
#line 282
    A2 += ((((B2 << 5) | (B2 >> 27)) + ((C2 & (D2 | E2)) | (D2 & E2))) + W2[44]) + 2400959708U;
#line 282
    C2 = (C2 << 30) | (C2 >> 2);
#line 283
    W1[45] = ((((W1[29] ^ W1[31]) ^ W1[37]) ^ W1[42]) << 1) | ((((W1[29] ^ W1[31]) ^ W1[37]) ^ W1[42]) >> 31);
#line 283
    E1 += ((((A1 << 5) | (A1 >> 27)) + ((B1 & (C1 | D1)) | (C1 & D1))) + W1[45]) + 2400959708U;
#line 283
    B1 = (B1 << 30) | (B1 >> 2);
#line 283
    W2[45] = ((((W2[29] ^ W2[31]) ^ W2[37]) ^ W2[42]) << 1) | ((((W2[29] ^ W2[31]) ^ W2[37]) ^ W2[42]) >> 31);
#line 283
    E2 += ((((A2 << 5) | (A2 >> 27)) + ((B2 & (C2 | D2)) | (C2 & D2))) + W2[45]) + 2400959708U;
#line 283
    B2 = (B2 << 30) | (B2 >> 2);
#line 283
    W1[46] = ((((W1[30] ^ W1[32]) ^ W1[38]) ^ W1[43]) << 1) | ((((W1[30] ^ W1[32]) ^ W1[38]) ^ W1[43]) >> 31);
#line 283
    D1 += ((((E1 << 5) | (E1 >> 27)) + ((A1 & (B1 | C1)) | (B1 & C1))) + W1[46]) + 2400959708U;
#line 283
    A1 = (A1 << 30) | (A1 >> 2);
#line 283
    W2[46] = ((((W2[30] ^ W2[32]) ^ W2[38]) ^ W2[43]) << 1) | ((((W2[30] ^ W2[32]) ^ W2[38]) ^ W2[43]) >> 31);
#line 283
    D2 += ((((E2 << 5) | (E2 >> 27)) + ((A2 & (B2 | C2)) | (B2 & C2))) + W2[46]) + 2400959708U;
#line 283
    A2 = (A2 << 30) | (A2 >> 2);
#line 283
    W1[47] = ((((W1[31] ^ W1[33]) ^ W1[39]) ^ W1[44]) << 1) | ((((W1[31] ^ W1[33]) ^ W1[39]) ^ W1[44]) >> 31);
#line 283
    C1 += ((((D1 << 5) | (D1 >> 27)) + ((E1 & (A1 | B1)) | (A1 & B1))) + W1[47]) + 2400959708U;
#line 283
    E1 = (E1 << 30) | (E1 >> 2);
#line 283
    W2[47] = ((((W2[31] ^ W2[33]) ^ W2[39]) ^ W2[44]) << 1) | ((((W2[31] ^ W2[33]) ^ W2[39]) ^ W2[44]) >> 31);
#line 283
    C2 += ((((D2 << 5) | (D2 >> 27)) + ((E2 & (A2 | B2)) | (A2 & B2))) + W2[47]) + 2400959708U;
#line 283
    E2 = (E2 << 30) | (E2 >> 2);
#line 283
    W1[48] = ((((W1[32] ^ W1[34]) ^ W1[40]) ^ W1[45]) << 1) | ((((W1[32] ^ W1[34]) ^ W1[40]) ^ W1[45]) >> 31);
#line 283
    B1 += ((((C1 << 5) | (C1 >> 27)) + ((D1 & (E1 | A1)) | (E1 & A1))) + W1[48]) + 2400959708U;
#line 283
    D1 = (D1 << 30) | (D1 >> 2);
#line 283
    W2[48] = ((((W2[32] ^ W2[34]) ^ W2[40]) ^ W2[45]) << 1) | ((((W2[32] ^ W2[34]) ^ W2[40]) ^ W2[45]) >> 31);
#line 283
    B2 += ((((C2 << 5) | (C2 >> 27)) + ((D2 & (E2 | A2)) | (E2 & A2))) + W2[48]) + 2400959708U;
#line 283
    D2 = (D2 << 30) | (D2 >> 2);
#line 283
    W1[49] = ((((W1[33] ^ W1[35]) ^ W1[41]) ^ W1[46]) << 1) | ((((W1[33] ^ W1[35]) ^ W1[41]) ^ W1[46]) >> 31);
#line 283
    A1 += ((((B1 << 5) | (B1 >> 27)) + ((C1 & (D1 | E1)) | (D1 & E1))) + W1[49]) + 2400959708U;
#line 283
    C1 = (C1 << 30) | (C1 >> 2);
#line 283
    W2[49] = ((((W2[33] ^ W2[35]) ^ W2[41]) ^ W2[46]) << 1) | ((((W2[33] ^ W2[35]) ^ W2[41]) ^ W2[46]) >> 31);
#line 283
    A2 += ((((B2 << 5) | (B2 >> 27)) + ((C2 & (D2 | E2)) | (D2 & E2))) + W2[49]) + 2400959708U;
#line 283
    C2 = (C2 << 30) | (C2 >> 2);
#line 284
    W1[50] = ((((W1[34] ^ W1[36]) ^ W1[42]) ^ W1[47]) << 1) | ((((W1[34] ^ W1[36]) ^ W1[42]) ^ W1[47]) >> 31);
#line 284
    E1 += ((((A1 << 5) | (A1 >> 27)) + ((B1 & (C1 | D1)) | (C1 & D1))) + W1[50]) + 2400959708U;
#line 284
    B1 = (B1 << 30) | (B1 >> 2);
#line 284
    W2[50] = ((((W2[34] ^ W2[36]) ^ W2[42]) ^ W2[47]) << 1) | ((((W2[34] ^ W2[36]) ^ W2[42]) ^ W2[47]) >> 31);
#line 284
    E2 += ((((A2 << 5) | (A2 >> 27)) + ((B2 & (C2 | D2)) | (C2 & D2))) + W2[50]) + 2400959708U;
#line 284
    B2 = (B2 << 30) | (B2 >> 2);
#line 284
    W1[51] = ((((W1[35] ^ W1[37]) ^ W1[43]) ^ W1[48]) << 1) | ((((W1[35] ^ W1[37]) ^ W1[43]) ^ W1[48]) >> 31);
#line 284
    D1 += ((((E1 << 5) | (E1 >> 27)) + ((A1 & (B1 | C1)) | (B1 & C1))) + W1[51]) + 2400959708U;
#line 284
    A1 = (A1 << 30) | (A1 >> 2);
#line 284
    W2[51] = ((((W2[35] ^ W2[37]) ^ W2[43]) ^ W2[48]) << 1) | ((((W2[35] ^ W2[37]) ^ W2[43]) ^ W2[48]) >> 31);
#line 284
    D2 += ((((E2 << 5) | (E2 >> 27)) + ((A2 & (B2 | C2)) | (B2 & C2))) + W2[51]) + 2400959708U;
#line 284
    A2 = (A2 << 30) | (A2 >> 2);
#line 284
    W1[52] = ((((W1[36] ^ W1[38]) ^ W1[44]) ^ W1[49]) << 1) | ((((W1[36] ^ W1[38]) ^ W1[44]) ^ W1[49]) >> 31);
#line 284
    C1 += ((((D1 << 5) | (D1 >> 27)) + ((E1 & (A1 | B1)) | (A1 & B1))) + W1[52]) + 2400959708U;
#line 284
    E1 = (E1 << 30) | (E1 >> 2);
#line 284
    W2[52] = ((((W2[36] ^ W2[38]) ^ W2[44]) ^ W2[49]) << 1) | ((((W2[36] ^ W2[38]) ^ W2[44]) ^ W2[49]) >> 31);
#line 284
    C2 += ((((D2 << 5) | (D2 >> 27)) + ((E2 & (A2 | B2)) | (A2 & B2))) + W2[52]) + 2400959708U;
#line 284
    E2 = (E2 << 30) | (E2 >> 2);
#line 284
    W1[53] = ((((W1[37] ^ W1[39]) ^ W1[45]) ^ W1[50]) << 1) | ((((W1[37] ^ W1[39]) ^ W1[45]) ^ W1[50]) >> 31);
#line 284
    B1 += ((((C1 << 5) | (C1 >> 27)) + ((D1 & (E1 | A1)) | (E1 & A1))) + W1[53]) + 2400959708U;
#line 284
    D1 = (D1 << 30) | (D1 >> 2);
#line 284
    W2[53] = ((((W2[37] ^ W2[39]) ^ W2[45]) ^ W2[50]) << 1) | ((((W2[37] ^ W2[39]) ^ W2[45]) ^ W2[50]) >> 31);
#line 284
    B2 += ((((C2 << 5) | (C2 >> 27)) + ((D2 & (E2 | A2)) | (E2 & A2))) + W2[53]) + 2400959708U;
#line 284
    D2 = (D2 << 30) | (D2 >> 2);
#line 284
    W1[54] = ((((W1[38] ^ W1[40]) ^ W1[46]) ^ W1[51]) << 1) | ((((W1[38] ^ W1[40]) ^ W1[46]) ^ W1[51]) >> 31);
#line 284
    A1 += ((((B1 << 5) | (B1 >> 27)) + ((C1 & (D1 | E1)) | (D1 & E1))) + W1[54]) + 2400959708U;
#line 284
    C1 = (C1 << 30) | (C1 >> 2);
#line 284
    W2[54] = ((((W2[38] ^ W2[40]) ^ W2[46]) ^ W2[51]) << 1) | ((((W2[38] ^ W2[40]) ^ W2[46]) ^ W2[51]) >> 31);
#line 284
    A2 += ((((B2 << 5) | (B2 >> 27)) + ((C2 & (D2 | E2)) | (D2 & E2))) + W2[54]) + 2400959708U;
#line 284
    C2 = (C2 << 30) | (C2 >> 2);
#line 285
    W1[55] = ((((W1[39] ^ W1[41]) ^ W1[47]) ^ W1[52]) << 1) | ((((W1[39] ^ W1[41]) ^ W1[47]) ^ W1[52]) >> 31);
#line 285
    E1 += ((((A1 << 5) | (A1 >> 27)) + ((B1 & (C1 | D1)) | (C1 & D1))) + W1[55]) + 2400959708U;
#line 285
    B1 = (B1 << 30) | (B1 >> 2);
#line 285
    W2[55] = ((((W2[39] ^ W2[41]) ^ W2[47]) ^ W2[52]) << 1) | ((((W2[39] ^ W2[41]) ^ W2[47]) ^ W2[52]) >> 31);
#line 285
    E2 += ((((A2 << 5) | (A2 >> 27)) + ((B2 & (C2 | D2)) | (C2 & D2))) + W2[55]) + 2400959708U;
#line 285
    B2 = (B2 << 30) | (B2 >> 2);
#line 285
    W1[56] = ((((W1[40] ^ W1[42]) ^ W1[48]) ^ W1[53]) << 1) | ((((W1[40] ^ W1[42]) ^ W1[48]) ^ W1[53]) >> 31);
#line 285
    D1 += ((((E1 << 5) | (E1 >> 27)) + ((A1 & (B1 | C1)) | (B1 & C1))) + W1[56]) + 2400959708U;
#line 285
    A1 = (A1 << 30) | (A1 >> 2);
#line 285
    W2[56] = ((((W2[40] ^ W2[42]) ^ W2[48]) ^ W2[53]) << 1) | ((((W2[40] ^ W2[42]) ^ W2[48]) ^ W2[53]) >> 31);
#line 285
    D2 += ((((E2 << 5) | (E2 >> 27)) + ((A2 & (B2 | C2)) | (B2 & C2))) + W2[56]) + 2400959708U;
#line 285
    A2 = (A2 << 30) | (A2 >> 2);
#line 285
    W1[57] = ((((W1[41] ^ W1[43]) ^ W1[49]) ^ W1[54]) << 1) | ((((W1[41] ^ W1[43]) ^ W1[49]) ^ W1[54]) >> 31);
#line 285
    C1 += ((((D1 << 5) | (D1 >> 27)) + ((E1 & (A1 | B1)) | (A1 & B1))) + W1[57]) + 2400959708U;
#line 285
    E1 = (E1 << 30) | (E1 >> 2);
#line 285
    W2[57] = ((((W2[41] ^ W2[43]) ^ W2[49]) ^ W2[54]) << 1) | ((((W2[41] ^ W2[43]) ^ W2[49]) ^ W2[54]) >> 31);
#line 285
    C2 += ((((D2 << 5) | (D2 >> 27)) + ((E2 & (A2 | B2)) | (A2 & B2))) + W2[57]) + 2400959708U;
#line 285
    E2 = (E2 << 30) | (E2 >> 2);
#line 285
    W1[58] = ((((W1[42] ^ W1[44]) ^ W1[50]) ^ W1[55]) << 1) | ((((W1[42] ^ W1[44]) ^ W1[50]) ^ W1[55]) >> 31);
#line 285
    B1 += ((((C1 << 5) | (C1 >> 27)) + ((D1 & (E1 | A1)) | (E1 & A1))) + W1[58]) + 2400959708U;
#line 285
    D1 = (D1 << 30) | (D1 >> 2);
#line 285
    W2[58] = ((((W2[42] ^ W2[44]) ^ W2[50]) ^ W2[55]) << 1) | ((((W2[42] ^ W2[44]) ^ W2[50]) ^ W2[55]) >> 31);
#line 285
    B2 += ((((C2 << 5) | (C2 >> 27)) + ((D2 & (E2 | A2)) | (E2 & A2))) + W2[58]) + 2400959708U;
#line 285
    D2 = (D2 << 30) | (D2 >> 2);
#line 285
    W1[59] = ((((W1[43] ^ W1[45]) ^ W1[51]) ^ W1[56]) << 1) | ((((W1[43] ^ W1[45]) ^ W1[51]) ^ W1[56]) >> 31);
#line 285
    A1 += ((((B1 << 5) | (B1 >> 27)) + ((C1 & (D1 | E1)) | (D1 & E1))) + W1[59]) + 2400959708U;
#line 285
    C1 = (C1 << 30) | (C1 >> 2);
#line 285
    W2[59] = ((((W2[43] ^ W2[45]) ^ W2[51]) ^ W2[56]) << 1) | ((((W2[43] ^ W2[45]) ^ W2[51]) ^ W2[56]) >> 31);
#line 285
    A2 += ((((B2 << 5) | (B2 >> 27)) + ((C2 & (D2 | E2)) | (D2 & E2))) + W2[59]) + 2400959708U;
#line 285
    C2 = (C2 << 30) | (C2 >> 2);
#line 287
    W1[60] = ((((W1[44] ^ W1[46]) ^ W1[52]) ^ W1[57]) << 1) | ((((W1[44] ^ W1[46]) ^ W1[52]) ^ W1[57]) >> 31);
#line 287
    E1 += ((((A1 << 5) | (A1 >> 27)) + ((B1 ^ C1) ^ D1)) + W1[60]) + 3395469782U;
#line 287
    B1 = (B1 << 30) | (B1 >> 2);
#line 287
    W2[60] = ((((W2[44] ^ W2[46]) ^ W2[52]) ^ W2[57]) << 1) | ((((W2[44] ^ W2[46]) ^ W2[52]) ^ W2[57]) >> 31);
#line 287
    E2 += ((((A2 << 5) | (A2 >> 27)) + ((B2 ^ C2) ^ D2)) + W2[60]) + 3395469782U;
#line 287
    B2 = (B2 << 30) | (B2 >> 2);
#line 287
    W1[61] = ((((W1[45] ^ W1[47]) ^ W1[53]) ^ W1[58]) << 1) | ((((W1[45] ^ W1[47]) ^ W1[53]) ^ W1[58]) >> 31);
#line 287
    D1 += ((((E1 << 5) | (E1 >> 27)) + ((A1 ^ B1) ^ C1)) + W1[61]) + 3395469782U;
#line 287
    A1 = (A1 << 30) | (A1 >> 2);
#line 287
    W2[61] = ((((W2[45] ^ W2[47]) ^ W2[53]) ^ W2[58]) << 1) | ((((W2[45] ^ W2[47]) ^ W2[53]) ^ W2[58]) >> 31);
#line 287
    D2 += ((((E2 << 5) | (E2 >> 27)) + ((A2 ^ B2) ^ C2)) + W2[61]) + 3395469782U;
#line 287
    A2 = (A2 << 30) | (A2 >> 2);
#line 287
    W1[62] = ((((W1[46] ^ W1[48]) ^ W1[54]) ^ W1[59]) << 1) | ((((W1[46] ^ W1[48]) ^ W1[54]) ^ W1[59]) >> 31);
#line 287
    C1 += ((((D1 << 5) | (D1 >> 27)) + ((E1 ^ A1) ^ B1)) + W1[62]) + 3395469782U;
#line 287
    E1 = (E1 << 30) | (E1 >> 2);
#line 287
    W2[62] = ((((W2[46] ^ W2[48]) ^ W2[54]) ^ W2[59]) << 1) | ((((W2[46] ^ W2[48]) ^ W2[54]) ^ W2[59]) >> 31);
#line 287
    C2 += ((((D2 << 5) | (D2 >> 27)) + ((E2 ^ A2) ^ B2)) + W2[62]) + 3395469782U;
#line 287
    E2 = (E2 << 30) | (E2 >> 2);
#line 287
    W1[63] = ((((W1[47] ^ W1[49]) ^ W1[55]) ^ W1[60]) << 1) | ((((W1[47] ^ W1[49]) ^ W1[55]) ^ W1[60]) >> 31);
#line 287
    B1 += ((((C1 << 5) | (C1 >> 27)) + ((D1 ^ E1) ^ A1)) + W1[63]) + 3395469782U;
#line 287
    D1 = (D1 << 30) | (D1 >> 2);
#line 287
    W2[63] = ((((W2[47] ^ W2[49]) ^ W2[55]) ^ W2[60]) << 1) | ((((W2[47] ^ W2[49]) ^ W2[55]) ^ W2[60]) >> 31);
#line 287
    B2 += ((((C2 << 5) | (C2 >> 27)) + ((D2 ^ E2) ^ A2)) + W2[63]) + 3395469782U;
#line 287
    D2 = (D2 << 30) | (D2 >> 2);
#line 287
    W1[64] = ((((W1[48] ^ W1[50]) ^ W1[56]) ^ W1[61]) << 1) | ((((W1[48] ^ W1[50]) ^ W1[56]) ^ W1[61]) >> 31);
#line 287
    A1 += ((((B1 << 5) | (B1 >> 27)) + ((C1 ^ D1) ^ E1)) + W1[64]) + 3395469782U;
#line 287
    C1 = (C1 << 30) | (C1 >> 2);
#line 287
    W2[64] = ((((W2[48] ^ W2[50]) ^ W2[56]) ^ W2[61]) << 1) | ((((W2[48] ^ W2[50]) ^ W2[56]) ^ W2[61]) >> 31);
#line 287
    A2 += ((((B2 << 5) | (B2 >> 27)) + ((C2 ^ D2) ^ E2)) + W2[64]) + 3395469782U;
#line 287
    C2 = (C2 << 30) | (C2 >> 2);
#line 288
    W1[65] = ((((W1[49] ^ W1[51]) ^ W1[57]) ^ W1[62]) << 1) | ((((W1[49] ^ W1[51]) ^ W1[57]) ^ W1[62]) >> 31);
#line 288
    E1 += ((((A1 << 5) | (A1 >> 27)) + ((B1 ^ C1) ^ D1)) + W1[65]) + 3395469782U;
#line 288
    B1 = (B1 << 30) | (B1 >> 2);
#line 288
    W2[65] = ((((W2[49] ^ W2[51]) ^ W2[57]) ^ W2[62]) << 1) | ((((W2[49] ^ W2[51]) ^ W2[57]) ^ W2[62]) >> 31);
#line 288
    E2 += ((((A2 << 5) | (A2 >> 27)) + ((B2 ^ C2) ^ D2)) + W2[65]) + 3395469782U;
#line 288
    B2 = (B2 << 30) | (B2 >> 2);
#line 288
    W1[66] = ((((W1[50] ^ W1[52]) ^ W1[58]) ^ W1[63]) << 1) | ((((W1[50] ^ W1[52]) ^ W1[58]) ^ W1[63]) >> 31);
#line 288
    D1 += ((((E1 << 5) | (E1 >> 27)) + ((A1 ^ B1) ^ C1)) + W1[66]) + 3395469782U;
#line 288
    A1 = (A1 << 30) | (A1 >> 2);
#line 288
    W2[66] = ((((W2[50] ^ W2[52]) ^ W2[58]) ^ W2[63]) << 1) | ((((W2[50] ^ W2[52]) ^ W2[58]) ^ W2[63]) >> 31);
#line 288
    D2 += ((((E2 << 5) | (E2 >> 27)) + ((A2 ^ B2) ^ C2)) + W2[66]) + 3395469782U;
#line 288
    A2 = (A2 << 30) | (A2 >> 2);
#line 288
    W1[67] = ((((W1[51] ^ W1[53]) ^ W1[59]) ^ W1[64]) << 1) | ((((W1[51] ^ W1[53]) ^ W1[59]) ^ W1[64]) >> 31);
#line 288
    C1 += ((((D1 << 5) | (D1 >> 27)) + ((E1 ^ A1) ^ B1)) + W1[67]) + 3395469782U;
#line 288
    E1 = (E1 << 30) | (E1 >> 2);
#line 288
    W2[67] = ((((W2[51] ^ W2[53]) ^ W2[59]) ^ W2[64]) << 1) | ((((W2[51] ^ W2[53]) ^ W2[59]) ^ W2[64]) >> 31);
#line 288
    C2 += ((((D2 << 5) | (D2 >> 27)) + ((E2 ^ A2) ^ B2)) + W2[67]) + 3395469782U;
#line 288
    E2 = (E2 << 30) | (E2 >> 2);
#line 288
    W1[68] = ((((W1[52] ^ W1[54]) ^ W1[60]) ^ W1[65]) << 1) | ((((W1[52] ^ W1[54]) ^ W1[60]) ^ W1[65]) >> 31);
#line 288
    B1 += ((((C1 << 5) | (C1 >> 27)) + ((D1 ^ E1) ^ A1)) + W1[68]) + 3395469782U;
#line 288
    D1 = (D1 << 30) | (D1 >> 2);
#line 288
    W2[68] = ((((W2[52] ^ W2[54]) ^ W2[60]) ^ W2[65]) << 1) | ((((W2[52] ^ W2[54]) ^ W2[60]) ^ W2[65]) >> 31);
#line 288
    B2 += ((((C2 << 5) | (C2 >> 27)) + ((D2 ^ E2) ^ A2)) + W2[68]) + 3395469782U;
#line 288
    D2 = (D2 << 30) | (D2 >> 2);
#line 288
    W1[69] = ((((W1[53] ^ W1[55]) ^ W1[61]) ^ W1[66]) << 1) | ((((W1[53] ^ W1[55]) ^ W1[61]) ^ W1[66]) >> 31);
#line 288
    A1 += ((((B1 << 5) | (B1 >> 27)) + ((C1 ^ D1) ^ E1)) + W1[69]) + 3395469782U;
#line 288
    C1 = (C1 << 30) | (C1 >> 2);
#line 288
    W2[69] = ((((W2[53] ^ W2[55]) ^ W2[61]) ^ W2[66]) << 1) | ((((W2[53] ^ W2[55]) ^ W2[61]) ^ W2[66]) >> 31);
#line 288
    A2 += ((((B2 << 5) | (B2 >> 27)) + ((C2 ^ D2) ^ E2)) + W2[69]) + 3395469782U;
#line 288
    C2 = (C2 << 30) | (C2 >> 2);
#line 289
    W1[70] = ((((W1[54] ^ W1[56]) ^ W1[62]) ^ W1[67]) << 1) | ((((W1[54] ^ W1[56]) ^ W1[62]) ^ W1[67]) >> 31);
#line 289
    E1 += ((((A1 << 5) | (A1 >> 27)) + ((B1 ^ C1) ^ D1)) + W1[70]) + 3395469782U;
#line 289
    B1 = (B1 << 30) | (B1 >> 2);
#line 289
    W2[70] = ((((W2[54] ^ W2[56]) ^ W2[62]) ^ W2[67]) << 1) | ((((W2[54] ^ W2[56]) ^ W2[62]) ^ W2[67]) >> 31);
#line 289
    E2 += ((((A2 << 5) | (A2 >> 27)) + ((B2 ^ C2) ^ D2)) + W2[70]) + 3395469782U;
#line 289
    B2 = (B2 << 30) | (B2 >> 2);
#line 289
    W1[71] = ((((W1[55] ^ W1[57]) ^ W1[63]) ^ W1[68]) << 1) | ((((W1[55] ^ W1[57]) ^ W1[63]) ^ W1[68]) >> 31);
#line 289
    D1 += ((((E1 << 5) | (E1 >> 27)) + ((A1 ^ B1) ^ C1)) + W1[71]) + 3395469782U;
#line 289
    A1 = (A1 << 30) | (A1 >> 2);
#line 289
    W2[71] = ((((W2[55] ^ W2[57]) ^ W2[63]) ^ W2[68]) << 1) | ((((W2[55] ^ W2[57]) ^ W2[63]) ^ W2[68]) >> 31);
#line 289
    D2 += ((((E2 << 5) | (E2 >> 27)) + ((A2 ^ B2) ^ C2)) + W2[71]) + 3395469782U;
#line 289
    A2 = (A2 << 30) | (A2 >> 2);
#line 289
    W1[72] = ((((W1[56] ^ W1[58]) ^ W1[64]) ^ W1[69]) << 1) | ((((W1[56] ^ W1[58]) ^ W1[64]) ^ W1[69]) >> 31);
#line 289
    C1 += ((((D1 << 5) | (D1 >> 27)) + ((E1 ^ A1) ^ B1)) + W1[72]) + 3395469782U;
#line 289
    E1 = (E1 << 30) | (E1 >> 2);
#line 289
    W2[72] = ((((W2[56] ^ W2[58]) ^ W2[64]) ^ W2[69]) << 1) | ((((W2[56] ^ W2[58]) ^ W2[64]) ^ W2[69]) >> 31);
#line 289
    C2 += ((((D2 << 5) | (D2 >> 27)) + ((E2 ^ A2) ^ B2)) + W2[72]) + 3395469782U;
#line 289
    E2 = (E2 << 30) | (E2 >> 2);
#line 289
    W1[73] = ((((W1[57] ^ W1[59]) ^ W1[65]) ^ W1[70]) << 1) | ((((W1[57] ^ W1[59]) ^ W1[65]) ^ W1[70]) >> 31);
#line 289
    B1 += ((((C1 << 5) | (C1 >> 27)) + ((D1 ^ E1) ^ A1)) + W1[73]) + 3395469782U;
#line 289
    D1 = (D1 << 30) | (D1 >> 2);
#line 289
    W2[73] = ((((W2[57] ^ W2[59]) ^ W2[65]) ^ W2[70]) << 1) | ((((W2[57] ^ W2[59]) ^ W2[65]) ^ W2[70]) >> 31);
#line 289
    B2 += ((((C2 << 5) | (C2 >> 27)) + ((D2 ^ E2) ^ A2)) + W2[73]) + 3395469782U;
#line 289
    D2 = (D2 << 30) | (D2 >> 2);
#line 289
    W1[74] = ((((W1[58] ^ W1[60]) ^ W1[66]) ^ W1[71]) << 1) | ((((W1[58] ^ W1[60]) ^ W1[66]) ^ W1[71]) >> 31);
#line 289
    A1 += ((((B1 << 5) | (B1 >> 27)) + ((C1 ^ D1) ^ E1)) + W1[74]) + 3395469782U;
#line 289
    C1 = (C1 << 30) | (C1 >> 2);
#line 289
    W2[74] = ((((W2[58] ^ W2[60]) ^ W2[66]) ^ W2[71]) << 1) | ((((W2[58] ^ W2[60]) ^ W2[66]) ^ W2[71]) >> 31);
#line 289
    A2 += ((((B2 << 5) | (B2 >> 27)) + ((C2 ^ D2) ^ E2)) + W2[74]) + 3395469782U;
#line 289
    C2 = (C2 << 30) | (C2 >> 2);
#line 290
    W1[75] = ((((W1[59] ^ W1[61]) ^ W1[67]) ^ W1[72]) << 1) | ((((W1[59] ^ W1[61]) ^ W1[67]) ^ W1[72]) >> 31);
#line 290
    E1 += ((((A1 << 5) | (A1 >> 27)) + ((B1 ^ C1) ^ D1)) + W1[75]) + 3395469782U;
#line 290
    B1 = (B1 << 30) | (B1 >> 2);
#line 290
    W2[75] = ((((W2[59] ^ W2[61]) ^ W2[67]) ^ W2[72]) << 1) | ((((W2[59] ^ W2[61]) ^ W2[67]) ^ W2[72]) >> 31);
#line 290
    E2 += ((((A2 << 5) | (A2 >> 27)) + ((B2 ^ C2) ^ D2)) + W2[75]) + 3395469782U;
#line 290
    B2 = (B2 << 30) | (B2 >> 2);
#line 290
    W1[76] = ((((W1[60] ^ W1[62]) ^ W1[68]) ^ W1[73]) << 1) | ((((W1[60] ^ W1[62]) ^ W1[68]) ^ W1[73]) >> 31);
#line 290
    D1 += ((((E1 << 5) | (E1 >> 27)) + ((A1 ^ B1) ^ C1)) + W1[76]) + 3395469782U;
#line 290
    A1 = (A1 << 30) | (A1 >> 2);
#line 290
    W2[76] = ((((W2[60] ^ W2[62]) ^ W2[68]) ^ W2[73]) << 1) | ((((W2[60] ^ W2[62]) ^ W2[68]) ^ W2[73]) >> 31);
#line 290
    D2 += ((((E2 << 5) | (E2 >> 27)) + ((A2 ^ B2) ^ C2)) + W2[76]) + 3395469782U;
#line 290
    A2 = (A2 << 30) | (A2 >> 2);
#line 290
    W1[77] = ((((W1[61] ^ W1[63]) ^ W1[69]) ^ W1[74]) << 1) | ((((W1[61] ^ W1[63]) ^ W1[69]) ^ W1[74]) >> 31);
#line 290
    C1 += ((((D1 << 5) | (D1 >> 27)) + ((E1 ^ A1) ^ B1)) + W1[77]) + 3395469782U;
#line 290
    E1 = (E1 << 30) | (E1 >> 2);
#line 290
    W2[77] = ((((W2[61] ^ W2[63]) ^ W2[69]) ^ W2[74]) << 1) | ((((W2[61] ^ W2[63]) ^ W2[69]) ^ W2[74]) >> 31);
#line 290
    C2 += ((((D2 << 5) | (D2 >> 27)) + ((E2 ^ A2) ^ B2)) + W2[77]) + 3395469782U;
#line 290
    E2 = (E2 << 30) | (E2 >> 2);
#line 290
    W1[78] = ((((W1[62] ^ W1[64]) ^ W1[70]) ^ W1[75]) << 1) | ((((W1[62] ^ W1[64]) ^ W1[70]) ^ W1[75]) >> 31);
#line 290
    B1 += ((((C1 << 5) | (C1 >> 27)) + ((D1 ^ E1) ^ A1)) + W1[78]) + 3395469782U;
#line 290
    D1 = (D1 << 30) | (D1 >> 2);
#line 290
    W2[78] = ((((W2[62] ^ W2[64]) ^ W2[70]) ^ W2[75]) << 1) | ((((W2[62] ^ W2[64]) ^ W2[70]) ^ W2[75]) >> 31);
#line 290
    B2 += ((((C2 << 5) | (C2 >> 27)) + ((D2 ^ E2) ^ A2)) + W2[78]) + 3395469782U;
#line 290
    D2 = (D2 << 30) | (D2 >> 2);
#line 290
    W1[79] = ((((W1[63] ^ W1[65]) ^ W1[71]) ^ W1[76]) << 1) | ((((W1[63] ^ W1[65]) ^ W1[71]) ^ W1[76]) >> 31);
#line 290
    A1 += ((((B1 << 5) | (B1 >> 27)) + ((C1 ^ D1) ^ E1)) + W1[79]) + 3395469782U;
#line 290
    C1 = (C1 << 30) | (C1 >> 2);
#line 290
    W2[79] = ((((W2[63] ^ W2[65]) ^ W2[71]) ^ W2[76]) << 1) | ((((W2[63] ^ W2[65]) ^ W2[71]) ^ W2[76]) >> 31);
#line 290
    A2 += ((((B2 << 5) | (B2 >> 27)) + ((C2 ^ D2) ^ E2)) + W2[79]) + 3395469782U;
#line 290
    C2 = (C2 << 30) | (C2 >> 2);
#line 293
    A1 += H[0];
#line 294
    B1 += H[1];
#line 296
    A2 += H[0];
#line 297
    B2 += H[1];
#line 314
    if (A1 < A2) {
#line 315
      n = 0;
    } else
#line 316
    if (A1 > A2) {
#line 317
      n = 1;
    } else
#line 318
    if (B1 < B2) {
#line 319
      n = 0;
    } else {
#line 321
      n = 1;
    }
    {
#line 324
    if (n == 0) {
#line 324
      goto case_0;
    }
#line 330
    if (n == 1) {
#line 330
      goto case_1;
    }
#line 323
    goto switch_break___0;
    case_0: /* CIL Label */ 
#line 325
    A = A1;
#line 326
    B = B1;
#line 327
    W = W1;
#line 328
    goto switch_break___0;
    case_1: /* CIL Label */ 
#line 331
    A = A2;
#line 332
    B = B2;
#line 333
    W = W2;
#line 334
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 338
    if (! (A & bitMask1Low)) {
#line 338
      if (! (B & bitMask1High)) {
#line 340
        gotBits = 0;
#line 341
        if (A) {
#line 342
          s = A;
          {
#line 343
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 343
            if (! (! (s & 2147483648U))) {
#line 343
              goto while_break___7;
            }
#line 344
            s <<= 1;
#line 345
            gotBits ++;
          }
          while_break___7: /* CIL Label */ ;
          }
        } else {
#line 348
          gotBits = 32;
#line 349
          if (B) {
#line 350
            s = B;
            {
#line 351
            while (1) {
              while_continue___8: /* CIL Label */ ;
#line 351
              if (! (! (s & 2147483648U))) {
#line 351
                goto while_break___8;
              }
#line 352
              s <<= 1;
#line 353
              gotBits ++;
            }
            while_break___8: /* CIL Label */ ;
            }
          } else {
#line 356
            gotBits = 64;
          }
        }
#line 360
        *best = gotBits;
#line 362
        maxBits = gotBits + 1;
#line 363
        if (maxBits < 32) {
#line 364
          bitMask1Low = ~ ((1U << (32 - maxBits)) - 1U);
#line 365
          bitMask1High = (uInt32 )0;
        } else {
#line 367
          bitMask1Low = (uInt32 )(~ 0);
#line 368
          bitMask1High = ~ ((1U << (64 - maxBits)) - 1U);
        }
#line 372
        t = 0;
        {
#line 372
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 372
          if (! (t < 16)) {
#line 372
            goto while_break___9;
          }
#line 373
          *((output + t * 4) + 0) = (unsigned char )((*(W + t) >> 24) & 255U);
#line 373
          *((output + t * 4) + 1) = (unsigned char )((*(W + t) >> 16) & 255U);
#line 373
          *((output + t * 4) + 2) = (unsigned char )((*(W + t) >> 8) & 255U);
#line 373
          *((output + t * 4) + 3) = (unsigned char )(*(W + t) & 255U);
#line 372
          t ++;
        }
        while_break___9: /* CIL Label */ ;
        }
#line 376
        if (gotBits >= bits) {
#line 377
          return (iters + 2UL);
        }
      }
    }
    {
#line 382
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 382
      if ((unsigned long )cb != (unsigned long )((void *)0)) {
#line 382
        if ((iters & 65535UL) == 0UL) {
          {
#line 382
          gettimeofday((struct timeval */* __restrict  */)(& curr), (__timezone_ptr_t )((void *)0));
          }
#line 382
          if (gotBits > lastBits) {
#line 382
            goto _L___1;
          } else
#line 382
          if (curr.tv_sec - prev.tv_sec > 1L) {
#line 382
            goto _L___1;
          } else {
#line 382
            if (curr.tv_sec - prev.tv_sec) {
#line 382
              tmp___12 = 1000000;
            } else {
#line 382
              tmp___12 = 0;
            }
#line 382
            if ((curr.tv_usec + (__suseconds_t )tmp___12) - prev.tv_usec > 100000L) {
              _L___1: /* CIL Label */ 
              {
#line 382
              percent = (double )((int )(((counter + (double )iters) / expected) * (double )100 + 0.5));
#line 382
              tmp___11 = (*cb)((int )percent, *best, bits, counter + (double )iters,
                               expected, user_args);
              }
#line 382
              if (! tmp___11) {
#line 382
                *best = -1;
#line 382
                return (0UL);
              }
#line 382
              prev = curr;
#line 382
              lastBits = gotBits;
            }
          }
        }
      }
#line 382
      goto while_break___10;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 133
    iters += 2UL;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 385
  return (iters + 2UL);
}
}
#line 157 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libfastmint.h"
unsigned long minter_ansi_ultracompact_1(int bits , int *best , unsigned char *block ,
                                         uInt32 const   *IV , int tailIndex , unsigned long maxIter ,
                                         int (*cb)(int percent , int largest , int target ,
                                                   double count , double expected ,
                                                   void *user ) , void *user_args ,
                                         double counter , double expected ) ;
#line 158
int minter_ansi_ultracompact_1_test(void) ;
#line 6 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/fastmint_ansi_ultracompact_1.c"
int minter_ansi_ultracompact_1_test(void) 
{ 


  {
#line 9
  return (1);
}
}
#line 79 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/fastmint_ansi_ultracompact_1.c"
static int const   endTest___4  =    (int const   )3;
#line 67 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/fastmint_ansi_ultracompact_1.c"
unsigned long minter_ansi_ultracompact_1(int bits , int *best , unsigned char *block ,
                                         uInt32 const   *IV , int tailIndex , unsigned long maxIter ,
                                         int (*cb)(int percent , int largest , int target ,
                                                   double count , double expected ,
                                                   void *user ) , void *user_args ,
                                         double counter , double expected ) 
{ 
  double percent ;
  struct timeval prev ;
  struct timeval curr ;
  int lastBits ;
  unsigned long iters ;
  int t ;
  int gotBits ;
  int maxBits ;
  int tmp ;
  uInt32 bitMask1Low ;
  uInt32 bitMask1High ;
  uInt32 s ;
  uInt32 A ;
  uInt32 B ;
  uInt32 C ;
  uInt32 D ;
  uInt32 E ;
  uInt32 W[80] ;
  unsigned int tmp___0 ;
  uInt32 H[5] ;
  unsigned int tmp___1 ;
  uInt32 pH[5] ;
  unsigned int tmp___2 ;
  char const   *p ;
  unsigned char *X ;
  int addressMask ;
  unsigned char *output ;
  int W32[9] ;
  int W52[7] ;
  char wordUpdate[80] ;
  unsigned int tmp___3 ;
  uInt32 tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 69
  prev.tv_sec = (__time_t )0;
#line 69
  prev.tv_usec = (__suseconds_t )0;
#line 69
  lastBits = 0;
#line 70
  iters = 0UL;
#line 71
  t = 0;
#line 71
  gotBits = 0;
#line 71
  if (bits > 16) {
#line 71
    tmp = 16;
  } else {
#line 71
    tmp = bits;
  }
#line 71
  maxBits = tmp;
#line 72
  bitMask1Low = (uInt32 )0;
#line 72
  bitMask1High = (uInt32 )0;
#line 72
  s = (uInt32 )0;
#line 73
  A = (uInt32 )0;
#line 73
  B = (uInt32 )0;
#line 73
  C = (uInt32 )0;
#line 73
  D = (uInt32 )0;
#line 73
  E = (uInt32 )0;
#line 74
  W[0] = (uInt32 )0;
#line 74
  tmp___0 = 1U;
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
#line 74
    if (tmp___0 >= 80U) {
#line 74
      goto while_break;
    }
#line 74
    W[tmp___0] = 0U;
#line 74
    tmp___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 75
  H[0] = (uInt32 )0;
#line 75
  tmp___1 = 1U;
  {
#line 75
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 75
    if (tmp___1 >= 5U) {
#line 75
      goto while_break___0;
    }
#line 75
    H[tmp___1] = 0U;
#line 75
    tmp___1 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 75
  pH[0] = (uInt32 )0;
#line 75
  tmp___2 = 1U;
  {
#line 75
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 75
    if (tmp___2 >= 5U) {
#line 75
      goto while_break___1;
    }
#line 75
    pH[tmp___2] = 0U;
#line 75
    tmp___2 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 76
  p = encodeAlphabets[4];
#line 77
  X = (unsigned char *)(W);
#line 78
  addressMask = 0;
#line 80
  output = block;
#line 81
  W32[0] = 21;
#line 81
  W32[1] = 23;
#line 81
  W32[2] = 24;
#line 81
  W32[3] = 26;
#line 81
  W32[4] = 27;
#line 81
  W32[5] = 29;
#line 81
  W32[6] = 30;
#line 81
  W32[7] = 31;
#line 81
  W32[8] = 0;
#line 81
  W52[0] = 20;
#line 81
  W52[1] = 23;
#line 81
  W52[2] = 26;
#line 81
  W52[3] = 28;
#line 81
  W52[4] = 29;
#line 81
  W52[5] = 31;
#line 81
  W52[6] = 0;
#line 82
  wordUpdate[0] = (char)0;
#line 82
  tmp___3 = 1U;
  {
#line 82
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 82
    if (tmp___3 >= 80U) {
#line 82
      goto while_break___2;
    }
#line 82
    wordUpdate[tmp___3] = (char)0;
#line 82
    tmp___3 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 84
  *best = 0;
#line 87
  addressMask = (int )*((char *)(& endTest___4));
#line 90
  if (maxBits < 32) {
#line 91
    if (bits == 0) {
#line 91
      bitMask1Low = (uInt32 )0;
    } else {
#line 92
      bitMask1Low = ~ ((1U << (32 - maxBits)) - 1U);
    }
#line 94
    bitMask1High = (uInt32 )0;
  } else {
#line 96
    bitMask1Low = (uInt32 )(~ 0);
#line 97
    bitMask1High = ~ ((1U << (64 - maxBits)) - 1U);
  }
#line 99
  maxBits = 0;
#line 102
  t = 0;
  {
#line 102
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 102
    if (! (t < 16)) {
#line 102
      goto while_break___3;
    }
#line 103
    W[t] = (uInt32 )(((((int )*((output + t * 4) + 0) << 24) | ((int )*((output + t * 4) + 1) << 16)) | ((int )*((output + t * 4) + 2) << 8)) | (int )*((output + t * 4) + 3));
#line 102
    t ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 104
  t = 0;
  {
#line 104
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 104
    if (! (t < 5)) {
#line 104
      goto while_break___4;
    }
#line 105
    tmp___4 = (uInt32 )*(IV + t);
#line 105
    H[t] = tmp___4;
#line 105
    pH[t] = tmp___4;
#line 104
    t ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 114
  if (tailIndex == 32) {
#line 114
    goto case_32;
  }
#line 119
  if (tailIndex == 52) {
#line 119
    goto case_52;
  }
#line 109
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 110
  t = 16;
  {
#line 110
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 110
    if (! (t < 32)) {
#line 110
      goto while_break___5;
    }
#line 111
    wordUpdate[t] = (char)1;
#line 110
    t ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 112
  goto switch_break;
  case_32: /* CIL Label */ 
#line 115
  t = 0;
  {
#line 115
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 115
    if (! W32[t]) {
#line 115
      goto while_break___6;
    }
#line 116
    wordUpdate[W32[t]] = (char)1;
#line 115
    t ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 117
  goto switch_break;
  case_52: /* CIL Label */ 
#line 120
  t = 0;
  {
#line 120
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 120
    if (! W52[t]) {
#line 120
      goto while_break___7;
    }
#line 121
    wordUpdate[W52[t]] = (char)1;
#line 120
    t ++;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 122
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 124
  t = 32;
  {
#line 124
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 124
    if (! (t < 80)) {
#line 124
      goto while_break___8;
    }
#line 125
    wordUpdate[t] = (char)1;
#line 124
    t ++;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 128
  iters = 0UL;
  {
#line 128
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 128
    if (! (iters < maxIter)) {
#line 128
      goto while_break___9;
    }
#line 131
    *(X + ((tailIndex - 1) ^ addressMask)) = (unsigned char )*(p + (iters & 63UL));
#line 132
    if (! (iters & 63UL)) {
#line 133
      if (iters >> 6) {
#line 134
        *(X + ((tailIndex - 2) ^ addressMask)) = (unsigned char )*(p + ((iters >> 6) & 63UL));
      }
#line 136
      if (iters >> 12) {
#line 137
        *(X + ((tailIndex - 3) ^ addressMask)) = (unsigned char )*(p + ((iters >> 12) & 63UL));
      }
#line 139
      if (iters >> 18) {
#line 140
        *(X + ((tailIndex - 4) ^ addressMask)) = (unsigned char )*(p + ((iters >> 18) & 63UL));
      }
#line 142
      if (iters >> 24) {
#line 143
        *(X + ((tailIndex - 5) ^ addressMask)) = (unsigned char )*(p + ((iters >> 24) & 63UL));
      }
#line 145
      if (iters >> 30) {
#line 146
        *(X + ((tailIndex - 6) ^ addressMask)) = (unsigned char )*(p + ((iters >> 30) & 63UL));
      }
    }
#line 151
    if (! (iters & 63UL)) {
#line 152
      A = H[0];
#line 153
      B = H[1];
#line 154
      C = H[2];
#line 155
      D = H[3];
#line 156
      E = H[4];
#line 158
      t = 16;
      {
#line 158
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 158
        if (! (t < 32)) {
#line 158
          goto while_break___10;
        }
#line 159
        W[t] = ((((W[t - 16] ^ W[t - 14]) ^ W[t - 8]) ^ W[t - 3]) << 1) | ((((W[t - 16] ^ W[t - 14]) ^ W[t - 8]) ^ W[t - 3]) >> 31);
#line 158
        t ++;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 161
      t = 0;
      {
#line 161
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 161
        if (! (t < ((tailIndex - 1) / 20) * 5)) {
#line 161
          goto while_break___11;
        }
#line 162
        E += ((((A << 5) | (A >> 27)) + (D ^ (B & (C ^ D)))) + W[t]) + 1518500249U;
#line 162
        B = (B << 30) | (B >> 2);
#line 162
        D += ((((E << 5) | (E >> 27)) + (C ^ (A & (B ^ C)))) + W[t + 1]) + 1518500249U;
#line 162
        A = (A << 30) | (A >> 2);
#line 162
        C += ((((D << 5) | (D >> 27)) + (B ^ (E & (A ^ B)))) + W[t + 2]) + 1518500249U;
#line 162
        E = (E << 30) | (E >> 2);
#line 162
        B += ((((C << 5) | (C >> 27)) + (A ^ (D & (E ^ A)))) + W[t + 3]) + 1518500249U;
#line 162
        D = (D << 30) | (D >> 2);
#line 162
        A += ((((B << 5) | (B >> 27)) + (E ^ (C & (D ^ E)))) + W[t + 4]) + 1518500249U;
#line 162
        C = (C << 30) | (C >> 2);
#line 161
        t += 5;
      }
      while_break___11: /* CIL Label */ ;
      }
#line 165
      pH[0] = A;
#line 166
      pH[1] = B;
#line 167
      pH[2] = C;
#line 168
      pH[3] = D;
#line 169
      pH[4] = E;
    }
#line 173
    t = 16;
    {
#line 173
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 173
      if (! (t < 80)) {
#line 173
        goto while_break___12;
      }
#line 174
      if (wordUpdate[t]) {
#line 175
        W[t] = ((((W[t - 16] ^ W[t - 14]) ^ W[t - 8]) ^ W[t - 3]) << 1) | ((((W[t - 16] ^ W[t - 14]) ^ W[t - 8]) ^ W[t - 3]) >> 31);
      }
#line 173
      t ++;
    }
    while_break___12: /* CIL Label */ ;
    }
#line 178
    A = pH[0];
#line 179
    B = pH[1];
#line 180
    C = pH[2];
#line 181
    D = pH[3];
#line 182
    E = pH[4];
#line 185
    t = ((tailIndex - 1) / 20) * 5;
    {
#line 185
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 185
      if (! (t < 20)) {
#line 185
        goto while_break___13;
      }
#line 186
      E += ((((A << 5) | (A >> 27)) + (D ^ (B & (C ^ D)))) + W[t]) + 1518500249U;
#line 186
      B = (B << 30) | (B >> 2);
#line 186
      D += ((((E << 5) | (E >> 27)) + (C ^ (A & (B ^ C)))) + W[t + 1]) + 1518500249U;
#line 186
      A = (A << 30) | (A >> 2);
#line 186
      C += ((((D << 5) | (D >> 27)) + (B ^ (E & (A ^ B)))) + W[t + 2]) + 1518500249U;
#line 186
      E = (E << 30) | (E >> 2);
#line 186
      B += ((((C << 5) | (C >> 27)) + (A ^ (D & (E ^ A)))) + W[t + 3]) + 1518500249U;
#line 186
      D = (D << 30) | (D >> 2);
#line 186
      A += ((((B << 5) | (B >> 27)) + (E ^ (C & (D ^ E)))) + W[t + 4]) + 1518500249U;
#line 186
      C = (C << 30) | (C >> 2);
#line 185
      t += 5;
    }
    while_break___13: /* CIL Label */ ;
    }
#line 189
    t = 20;
    {
#line 189
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 189
      if (! (t < 40)) {
#line 189
        goto while_break___14;
      }
#line 189
      E += ((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) + W[t]) + 1859775393U;
#line 189
      B = (B << 30) | (B >> 2);
#line 189
      D += ((((E << 5) | (E >> 27)) + ((A ^ B) ^ C)) + W[t + 1]) + 1859775393U;
#line 189
      A = (A << 30) | (A >> 2);
#line 189
      C += ((((D << 5) | (D >> 27)) + ((E ^ A) ^ B)) + W[t + 2]) + 1859775393U;
#line 189
      E = (E << 30) | (E >> 2);
#line 189
      B += ((((C << 5) | (C >> 27)) + ((D ^ E) ^ A)) + W[t + 3]) + 1859775393U;
#line 189
      D = (D << 30) | (D >> 2);
#line 189
      A += ((((B << 5) | (B >> 27)) + ((C ^ D) ^ E)) + W[t + 4]) + 1859775393U;
#line 189
      C = (C << 30) | (C >> 2);
#line 189
      t += 5;
    }
    while_break___14: /* CIL Label */ ;
    }
#line 190
    t = 40;
    {
#line 190
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 190
      if (! (t < 60)) {
#line 190
        goto while_break___15;
      }
#line 190
      E += ((((A << 5) | (A >> 27)) + ((B & (C | D)) | (C & D))) + W[t]) + 2400959708U;
#line 190
      B = (B << 30) | (B >> 2);
#line 190
      D += ((((E << 5) | (E >> 27)) + ((A & (B | C)) | (B & C))) + W[t + 1]) + 2400959708U;
#line 190
      A = (A << 30) | (A >> 2);
#line 190
      C += ((((D << 5) | (D >> 27)) + ((E & (A | B)) | (A & B))) + W[t + 2]) + 2400959708U;
#line 190
      E = (E << 30) | (E >> 2);
#line 190
      B += ((((C << 5) | (C >> 27)) + ((D & (E | A)) | (E & A))) + W[t + 3]) + 2400959708U;
#line 190
      D = (D << 30) | (D >> 2);
#line 190
      A += ((((B << 5) | (B >> 27)) + ((C & (D | E)) | (D & E))) + W[t + 4]) + 2400959708U;
#line 190
      C = (C << 30) | (C >> 2);
#line 190
      t += 5;
    }
    while_break___15: /* CIL Label */ ;
    }
#line 191
    t = 60;
    {
#line 191
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 191
      if (! (t < 80)) {
#line 191
        goto while_break___16;
      }
#line 191
      E += ((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) + W[t]) + 3395469782U;
#line 191
      B = (B << 30) | (B >> 2);
#line 191
      D += ((((E << 5) | (E >> 27)) + ((A ^ B) ^ C)) + W[t + 1]) + 3395469782U;
#line 191
      A = (A << 30) | (A >> 2);
#line 191
      C += ((((D << 5) | (D >> 27)) + ((E ^ A) ^ B)) + W[t + 2]) + 3395469782U;
#line 191
      E = (E << 30) | (E >> 2);
#line 191
      B += ((((C << 5) | (C >> 27)) + ((D ^ E) ^ A)) + W[t + 3]) + 3395469782U;
#line 191
      D = (D << 30) | (D >> 2);
#line 191
      A += ((((B << 5) | (B >> 27)) + ((C ^ D) ^ E)) + W[t + 4]) + 3395469782U;
#line 191
      C = (C << 30) | (C >> 2);
#line 191
      t += 5;
    }
    while_break___16: /* CIL Label */ ;
    }
#line 194
    A += H[0];
#line 195
    B += H[1];
#line 196
    C += H[2];
#line 197
    D += H[3];
#line 198
    E += H[4];
#line 201
    if (! (A & bitMask1Low)) {
#line 201
      if (! (B & bitMask1High)) {
#line 203
        gotBits = 0;
#line 204
        if (A) {
#line 205
          s = A;
          {
#line 206
          while (1) {
            while_continue___17: /* CIL Label */ ;
#line 206
            if (! (! (s & 2147483648U))) {
#line 206
              goto while_break___17;
            }
#line 207
            s <<= 1;
#line 208
            gotBits ++;
          }
          while_break___17: /* CIL Label */ ;
          }
        } else {
#line 211
          gotBits = 32;
#line 212
          if (B) {
#line 213
            s = B;
            {
#line 214
            while (1) {
              while_continue___18: /* CIL Label */ ;
#line 214
              if (! (! (s & 2147483648U))) {
#line 214
                goto while_break___18;
              }
#line 215
              s <<= 1;
#line 216
              gotBits ++;
            }
            while_break___18: /* CIL Label */ ;
            }
          } else {
#line 219
            gotBits = 64;
          }
        }
#line 223
        *best = gotBits;
#line 225
        maxBits = gotBits + 1;
#line 226
        if (maxBits < 32) {
#line 227
          bitMask1Low = ~ ((1U << (32 - maxBits)) - 1U);
#line 228
          bitMask1High = (uInt32 )0;
        } else {
#line 230
          bitMask1Low = (uInt32 )(~ 0);
#line 231
          bitMask1High = ~ ((1U << (64 - maxBits)) - 1U);
        }
#line 235
        t = 0;
        {
#line 235
        while (1) {
          while_continue___19: /* CIL Label */ ;
#line 235
          if (! (t < 16)) {
#line 235
            goto while_break___19;
          }
#line 236
          *((output + t * 4) + 0) = (unsigned char )((W[t] >> 24) & 255U);
#line 236
          *((output + t * 4) + 1) = (unsigned char )((W[t] >> 16) & 255U);
#line 236
          *((output + t * 4) + 2) = (unsigned char )((W[t] >> 8) & 255U);
#line 236
          *((output + t * 4) + 3) = (unsigned char )(W[t] & 255U);
#line 235
          t ++;
        }
        while_break___19: /* CIL Label */ ;
        }
#line 239
        if (gotBits >= bits) {
#line 240
          return (iters + 1UL);
        }
      }
    }
    {
#line 243
    while (1) {
      while_continue___20: /* CIL Label */ ;
#line 243
      if ((unsigned long )cb != (unsigned long )((void *)0)) {
#line 243
        if ((iters & 65535UL) == 0UL) {
          {
#line 243
          gettimeofday((struct timeval */* __restrict  */)(& curr), (__timezone_ptr_t )((void *)0));
          }
#line 243
          if (gotBits > lastBits) {
#line 243
            goto _L___0;
          } else
#line 243
          if (curr.tv_sec - prev.tv_sec > 1L) {
#line 243
            goto _L___0;
          } else {
#line 243
            if (curr.tv_sec - prev.tv_sec) {
#line 243
              tmp___6 = 1000000;
            } else {
#line 243
              tmp___6 = 0;
            }
#line 243
            if ((curr.tv_usec + (__suseconds_t )tmp___6) - prev.tv_usec > 100000L) {
              _L___0: /* CIL Label */ 
              {
#line 243
              percent = (double )((int )(((counter + (double )iters) / expected) * (double )100 + 0.5));
#line 243
              tmp___5 = (*cb)((int )percent, *best, bits, counter + (double )iters,
                              expected, user_args);
              }
#line 243
              if (! tmp___5) {
#line 243
                *best = -1;
#line 243
                return (0UL);
              }
#line 243
              prev = curr;
#line 243
              lastBits = gotBits;
            }
          }
        }
      }
#line 243
      goto while_break___20;
    }
    while_break___20: /* CIL Label */ ;
    }
#line 128
    iters ++;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 246
  return (iters + 1UL);
}
}
#line 182 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libfastmint.h"
unsigned long minter_altivec_compact_2(int bits , int *best , unsigned char *block ,
                                       uInt32 const   *IV , int tailIndex , unsigned long maxIter ,
                                       int (*cb)(int percent , int largest , int target ,
                                                 double count , double expected ,
                                                 void *user ) , void *user_args ,
                                       double counter , double expected ) ;
#line 183
int minter_altivec_compact_2_test(void) ;
#line 4 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/fastmint_altivec_compact_2.c"
int minter_altivec_compact_2_test(void) 
{ 


  {
#line 12
  return (0);
}
}
#line 627 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/fastmint_altivec_compact_2.c"
unsigned long minter_altivec_compact_2(int bits , int *best , unsigned char *block ,
                                       uInt32 const   *IV , int tailIndex , unsigned long maxIter ,
                                       int (*cb)(int percent , int largest , int target ,
                                                 double count , double expected ,
                                                 void *user ) , void *user_args ,
                                       double counter , double expected ) 
{ 


  {
#line 961
  return (0UL);
}
}
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 16 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/random.h"
extern int random_getbytes(void * , size_t  ) ;
#line 91 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libfastmint.h"
int gProcessorSupportFlags ;
#line 94
int const   EncodeBitRate[5] ;
#line 96
void hashcash_select_minter(void) ;
#line 177
unsigned long minter_altivec_standard_2(int bits , int *best , unsigned char *block ,
                                        uInt32 const   *IV , int tailIndex , unsigned long maxIter ,
                                        int (*cb)(int percent , int largest , int target ,
                                                  double count , double expected ,
                                                  void *user ) , void *user_args ,
                                        double counter , double expected ) ;
#line 178
int minter_altivec_standard_2_test(void) ;
#line 188
unsigned long minter_mmx_standard_1(int bits , int *best , unsigned char *block ,
                                    uInt32 const   *IV , int tailIndex , unsigned long maxIter ,
                                    int (*cb)(int percent , int largest , int target ,
                                              double count , double expected , void *user ) ,
                                    void *user_args , double counter , double expected ) ;
#line 190
int minter_mmx_standard_1_test(void) ;
#line 195
unsigned long minter_mmx_compact_1(int bits , int *best , unsigned char *block , uInt32 const   *IV ,
                                   int tailIndex , unsigned long maxIter , int (*cb)(int percent ,
                                                                                     int largest ,
                                                                                     int target ,
                                                                                     double count ,
                                                                                     double expected ,
                                                                                     void *user ) ,
                                   void *user_args , double counter , double expected ) ;
#line 196
int minter_mmx_compact_1_test(void) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libfastmint.c"
static int fastest_minter  =    -1;
#line 28 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libfastmint.c"
static unsigned int num_minters  =    0U;
#line 30 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libfastmint.c"
static HC_Minter minters[20]  ;
#line 32 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libfastmint.c"
char const   *encodeAlphabets[5]  = {      "0123456789ABCDEF",      "0123456789abcdef",      "ABCDEFGHIJKLMNOP",      "abcdefghijklmnop", 
        "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz+/"};
#line 40 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libfastmint.c"
int const   EncodeBitRate[5]  = {      (int const   )4,      (int const   )4,      (int const   )4,      (int const   )4, 
        (int const   )6};
#line 45 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libfastmint.c"
int gProcessorSupportFlags  =    0;
#line 53 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libfastmint.c"
static uInt32 const   SHA1_IV___0[5]  = {      (uInt32 const   )1732584193,      (uInt32 const   )4023233417U,      (uInt32 const   )2562383102U,      (uInt32 const   )271733878, 
        (uInt32 const   )3285377520U};
#line 75 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libfastmint.c"
static void hashcash_detect_features(void) 
{ 


  {
#line 139
  gProcessorSupportFlags = 0;
#line 141
  return;
}
}
#line 149 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libfastmint.c"
static EncodeAlphabet const   encodings[11]  = 
#line 149
  {      (EncodeAlphabet const   )4,      (EncodeAlphabet const   )4,      (EncodeAlphabet const   )4,      (EncodeAlphabet const   )4, 
        (EncodeAlphabet const   )4,      (EncodeAlphabet const   )4,      (EncodeAlphabet const   )4,      (EncodeAlphabet const   )4, 
        (EncodeAlphabet const   )4,      (EncodeAlphabet const   )4,      (EncodeAlphabet const   )4};
#line 165 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libfastmint.c"
static HC_Mint_Routine const   funcs[12]  = 
#line 165
  {      (HC_Mint_Routine const   )(& minter_library),      (HC_Mint_Routine const   )(& minter_ansi_compact_1),      (HC_Mint_Routine const   )(& minter_ansi_standard_1),      (HC_Mint_Routine const   )(& minter_ansi_ultracompact_1), 
        (HC_Mint_Routine const   )(& minter_ansi_compact_2),      (HC_Mint_Routine const   )(& minter_ansi_standard_2),      (HC_Mint_Routine const   )(& minter_altivec_standard_1),      (HC_Mint_Routine const   )(& minter_altivec_compact_2), 
        (HC_Mint_Routine const   )(& minter_altivec_standard_2),      (HC_Mint_Routine const   )(& minter_mmx_compact_1),      (HC_Mint_Routine const   )(& minter_mmx_standard_1),      (HC_Mint_Routine const   )((void *)0)};
#line 178 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libfastmint.c"
static HC_Mint_Capable_Routine const   tests[12]  = 
#line 178
  {      (HC_Mint_Capable_Routine const   )(& minter_library_test),      (HC_Mint_Capable_Routine const   )(& minter_ansi_compact_1_test),      (HC_Mint_Capable_Routine const   )(& minter_ansi_standard_1_test),      (HC_Mint_Capable_Routine const   )(& minter_ansi_ultracompact_1_test), 
        (HC_Mint_Capable_Routine const   )(& minter_ansi_compact_2_test),      (HC_Mint_Capable_Routine const   )(& minter_ansi_standard_2_test),      (HC_Mint_Capable_Routine const   )(& minter_altivec_standard_1_test),      (HC_Mint_Capable_Routine const   )(& minter_altivec_compact_2_test), 
        (HC_Mint_Capable_Routine const   )(& minter_altivec_standard_2_test),      (HC_Mint_Capable_Routine const   )(& minter_mmx_compact_1_test),      (HC_Mint_Capable_Routine const   )(& minter_mmx_standard_1_test),      (HC_Mint_Capable_Routine const   )((void *)0)};
#line 191 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libfastmint.c"
static char const   *names[12]  = 
#line 191
  {      "SHA1 library (hashcash)",      "ANSI Compact 1-pipe",      "ANSI Standard 1-pipe",      "ANSI Ultra-Compact 1-pipe", 
        "ANSI Compact 2-pipe",      "ANSI Standard 2-pipe",      "PowerPC Altivec Standard 1x4-pipe",      "PowerPC Altivec Compact 2x4-pipe", 
        "PowerPC Altivec Standard 2x4-pipe",      "AMD64/x86 MMX Compact 1x2-pipe",      "AMD64/x86 MMX Standard 1x2-pipe",      (char const   *)((void *)0)};
#line 163 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libfastmint.c"
void hashcash_select_minter(void) 
{ 
  int i ;
  int tmp ;

  {
#line 208
  i = 0;
#line 211
  if (! num_minters) {
#line 212
    num_minters = (unsigned int )(sizeof(funcs) / sizeof(funcs[0]) - 1UL);
#line 213
    if (num_minters > 20U) {
      {
#line 214
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"INTERNAL ERROR: increase size of MAX_MINTERS\n");
#line 217
      exit(3);
      }
    }
#line 219
    i = 0;
    {
#line 219
    while (1) {
      while_continue: /* CIL Label */ ;
#line 219
      if (! ((unsigned int )i < num_minters)) {
#line 219
        goto while_break;
      }
#line 220
      minters[i].name = names[i];
#line 221
      minters[i].func = (unsigned long (*)(int bits , int *best , unsigned char *block ,
                                           uInt32 const   *IV , int tailIndex , unsigned long maxIter ,
                                           int (*cb)(int percent , int largest , int target ,
                                                     double count , double expected ,
                                                     void *user ) , void *user_args ,
                                           double counter , double expected ))funcs[i];
#line 222
      minters[i].test = (int (*)(void))tests[i];
#line 223
      minters[i].encoding = (EncodeAlphabet )encodings[i];
#line 219
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 235
  fastest_minter = 2;
#line 239
  hashcash_detect_features();
#line 244
  i = 6;
  }
  {
#line 244
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 244
    if (! ((unsigned int )i < num_minters)) {
#line 244
      goto while_break___0;
    }
    {
#line 245
    tmp = (*(minters[i].test))();
    }
#line 245
    if (tmp) {
#line 245
      fastest_minter = i;
    }
#line 244
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 247
  return;
}
}
#line 253
unsigned long hashcash_per_sec_calc(void) ;
#line 253 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libfastmint.c"
static unsigned int const   test_bits  =    (unsigned int const   )64;
#line 254 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libfastmint.c"
static char const   *test_string  =    "1:32:040404:foo@fnord.gov::0123456789abcdef:00000000";
#line 256 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libfastmint.c"
static int const   test_tail  =    (int const   )52;
#line 251 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libfastmint.c"
unsigned long hashcash_per_sec_calc(void) 
{ 
  unsigned long rate ;
  unsigned long iter_count ;
  clock_t volatile   begin ;
  clock_t volatile   end ;
  clock_t volatile   tmp ;
  clock_t volatile   res ;
  clock_t volatile   taken ;
  double elapsed ;
  double multiple ;
  unsigned char block[64] ;
  unsigned int tmp___0 ;
  int gotbits ;
  unsigned long (*best_minter_fp)(int bits , int *best , unsigned char *block , uInt32 const   *IV ,
                                  int tailIndex , unsigned long maxIter , int (*cb)(int percent ,
                                                                                    int largest ,
                                                                                    int target ,
                                                                                    double count ,
                                                                                    double expected ,
                                                                                    void *user ) ,
                                  void *user_args , double counter , double expected ) ;
  clock_t tmp___1 ;
  clock_t tmp___2 ;
  clock_t tmp___3 ;
  clock_t tmp___4 ;
  clock_t tmp___5 ;
  clock_t tmp___6 ;
  clock_t tmp___7 ;

  {
#line 257
  rate = 0UL;
#line 257
  iter_count = 256UL;
#line 258
  begin = (clock_t volatile   )0;
#line 258
  end = (clock_t volatile   )0;
#line 258
  tmp = (clock_t volatile   )0;
#line 258
  res = (clock_t volatile   )0;
#line 258
  taken = (clock_t volatile   )0;
#line 259
  elapsed = (double )0;
#line 259
  multiple = (double )0;
#line 260
  block[0] = (unsigned char)0;
#line 260
  tmp___0 = 1U;
  {
#line 260
  while (1) {
    while_continue: /* CIL Label */ ;
#line 260
    if (tmp___0 >= 64U) {
#line 260
      goto while_break;
    }
#line 260
    block[tmp___0] = (unsigned char)0;
#line 260
    tmp___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 261
  gotbits = 0;
#line 265
  if (! num_minters) {
    {
#line 265
    hashcash_select_minter();
    }
  }
  {
#line 266
  best_minter_fp = minters[fastest_minter].func;
#line 269
  tmp___1 = clock();
#line 269
  end = (clock_t volatile   )tmp___1;
  }
  {
#line 270
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 270
    tmp___2 = clock();
#line 270
    begin = (clock_t volatile   )tmp___2;
    }
#line 270
    if (! (begin == end)) {
#line 270
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 272
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 272
    tmp___3 = clock();
#line 272
    end = (clock_t volatile   )tmp___3;
    }
#line 272
    if (! (end == begin)) {
#line 272
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 274
  if (end < begin) {
#line 274
    tmp = begin;
#line 274
    begin = end;
#line 274
    end = tmp;
  }
#line 275
  res = end - begin;
#line 280
  if (res > (clock_t volatile   )1000) {
#line 282
    begin = end;
    {
#line 283
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 285
      strncpy((char */* __restrict  */)((char *)(block)), (char const   */* __restrict  */)test_string,
              (size_t )64);
#line 286
      block[test_tail] = (unsigned char)128;
#line 287
      memset((void *)((block + test_tail) + 1), 0, (size_t )(59 - (int )test_tail));
#line 288
      *((block + 60) + 0) = (unsigned char )(((test_tail << 3) >> 24) & 255);
#line 288
      *((block + 60) + 1) = (unsigned char )(((test_tail << 3) >> 16) & 255);
#line 288
      *((block + 60) + 2) = (unsigned char )(((test_tail << 3) >> 8) & 255);
#line 288
      *((block + 60) + 3) = (unsigned char )((test_tail << 3) & 255);
#line 290
      (*best_minter_fp)((int )test_bits, & gotbits, block, (uInt32 const   *)(SHA1_IV___0),
                        (int )test_tail, iter_count, (int (*)(int percent , int largest ,
                                                              int target , double count ,
                                                              double expected , void *user ))((void *)0),
                        (void *)0, (double )0, (double )0);
      }
#line 293
      if ((unsigned int const   )gotbits >= test_bits) {
        {
#line 296
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error in hashcash_quickbench(): found collision while trying to benchmark!\n");
        }
#line 298
        return (1UL);
      }
      {
#line 300
      rate += iter_count;
#line 301
      tmp___4 = clock();
#line 301
      end = (clock_t volatile   )tmp___4;
      }
#line 302
      if (end < begin) {
#line 302
        taken = begin - end;
      } else {
#line 303
        taken = end - begin;
      }
#line 283
      if (! (taken < (clock_t volatile   )8 * res)) {
#line 283
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 305
    multiple = (double )1000000L / (double )((clock_t volatile   )8 * res);
#line 306
    rate = (unsigned long )((double )rate * multiple);
#line 308
    return (rate);
  }
  {
#line 313
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 313
    if (! iter_count) {
#line 313
      goto while_break___3;
    }
    {
#line 315
    strncpy((char */* __restrict  */)((char *)(block)), (char const   */* __restrict  */)test_string,
            (size_t )64);
#line 316
    block[test_tail] = (unsigned char)128;
#line 317
    memset((void *)((block + test_tail) + 1), 0, (size_t )(59 - (int )test_tail));
#line 318
    *((block + 60) + 0) = (unsigned char )(((test_tail << 3) >> 24) & 255);
#line 318
    *((block + 60) + 1) = (unsigned char )(((test_tail << 3) >> 16) & 255);
#line 318
    *((block + 60) + 2) = (unsigned char )(((test_tail << 3) >> 8) & 255);
#line 318
    *((block + 60) + 3) = (unsigned char )((test_tail << 3) & 255);
#line 321
    tmp___5 = clock();
#line 321
    end = (clock_t volatile   )tmp___5;
    }
    {
#line 322
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 322
      tmp___6 = clock();
#line 322
      begin = (clock_t volatile   )tmp___6;
      }
#line 322
      if (! (begin == end)) {
#line 322
        goto while_break___4;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 323
    (*best_minter_fp)((int )test_bits, & gotbits, block, (uInt32 const   *)(SHA1_IV___0),
                      (int )test_tail, iter_count, (int (*)(int percent , int largest ,
                                                            int target , double count ,
                                                            double expected , void *user ))((void *)0),
                      (void *)0, (double )0, (double )0);
    }
#line 325
    if ((unsigned int const   )gotbits >= test_bits) {
      {
#line 328
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error in hashcash_quickbench(): found collision while trying to benchmark!\n");
      }
#line 329
      return (1UL);
    }
    {
#line 331
    tmp___7 = clock();
#line 331
    end = (clock_t volatile   )tmp___7;
    }
#line 332
    if (end < begin) {
#line 332
      tmp = begin;
#line 332
      begin = end;
#line 332
      end = tmp;
    }
#line 333
    elapsed = (double )(end - begin) / (double )1000000L;
#line 335
    if (end - begin > res * (clock_t volatile   )16) {
#line 336
      goto while_break___3;
    }
#line 338
    iter_count <<= 1;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 341
  rate = (unsigned long )((double )iter_count / elapsed);
#line 342
  return (rate);
}
}
#line 350 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libfastmint.c"
static int cached_per_sec  =    0;
#line 354 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libfastmint.c"
static unsigned long cache  =    0UL;
#line 352 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libfastmint.c"
unsigned long hashcash_per_sec(void) 
{ 


  {
#line 355
  if (! cached_per_sec) {
    {
#line 356
    cache = hashcash_per_sec_calc();
#line 357
    cached_per_sec = 1;
    }
  }
#line 359
  return (cache);
}
}
#line 370 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libfastmint.c"
static unsigned int const   test_bits___0  =    (unsigned int const   )22;
#line 371 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libfastmint.c"
static char const   *test_string___0  =    "1:22:040404:foo@bar.net::0123456789abcdef:0000000000";
#line 373 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libfastmint.c"
static int const   test_tail___0  =    (int const   )52;
#line 374 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libfastmint.c"
static int const   bit_stats[10]  = 
#line 374
  {      (int const   )8,      (int const   )10,      (int const   )16,      (int const   )20, 
        (int const   )22,      (int const   )24,      (int const   )26,      (int const   )28, 
        (int const   )30,      (int const   )0};
#line 366 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libfastmint.c"
unsigned long hashcash_benchtest(int verbose , int core ) 
{ 
  unsigned long i ;
  unsigned long a ;
  unsigned long b ;
  int best_minter ;
  int got_bits ;
  unsigned char block[65] ;
  unsigned int tmp ;
  clock_t volatile   begin ;
  clock_t volatile   end ;
  clock_t volatile   tmp___0 ;
  double elapsed ;
  double rate ;
  double peak_rate ;
  SHA1_ctx crypter ;
  unsigned char hash[20] ;
  unsigned int tmp___1 ;
  char const   *p ;
  char const   *q ;
  int start ;
  int stop ;
  int tmp___2 ;
  clock_t tmp___3 ;
  clock_t tmp___4 ;
  clock_t tmp___5 ;
  char *tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;

  {
#line 369
  best_minter = -1;
#line 369
  got_bits = 0;
#line 376
  block[0] = (unsigned char)0;
#line 376
  tmp = 1U;
  {
#line 376
  while (1) {
    while_continue: /* CIL Label */ ;
#line 376
    if (tmp >= 65U) {
#line 376
      goto while_break;
    }
#line 376
    block[tmp] = (unsigned char)0;
#line 376
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 377
  begin = (clock_t volatile   )0;
#line 377
  end = (clock_t volatile   )0;
#line 377
  tmp___0 = (clock_t volatile   )0;
#line 378
  elapsed = (double )0;
#line 378
  rate = (double )0;
#line 378
  peak_rate = (double )0;
#line 380
  hash[0] = (unsigned char)0;
#line 380
  tmp___1 = 1U;
  {
#line 380
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 380
    if (tmp___1 >= 20U) {
#line 380
      goto while_break___0;
    }
#line 380
    hash[tmp___1] = (unsigned char)0;
#line 380
    tmp___1 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 381
  p = (char const   *)((void *)0);
#line 381
  q = (char const   *)((void *)0);
#line 382
  start = 0;
#line 382
  stop = 0;
#line 385
  hashcash_select_minter();
  }
#line 388
  if (verbose > 0) {
    {
#line 389
    printf((char const   */* __restrict  */)"    Rate  Name (* machine default)\n");
    }
  }
#line 391
  if (verbose >= 3) {
    {
#line 391
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 393
  if (core >= 0) {
#line 394
    start = core;
#line 394
    stop = start + 1;
  } else {
#line 396
    start = 0;
#line 396
    stop = (int )num_minters;
  }
#line 398
  i = (unsigned long )start;
  {
#line 398
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 398
    if (! (i < (unsigned long )stop)) {
#line 398
      goto while_break___1;
    }
    {
#line 400
    tmp___2 = (*(minters[i].test))();
    }
#line 400
    if (! tmp___2) {
#line 401
      if (verbose >= 2) {
        {
#line 402
        printf((char const   */* __restrict  */)"   ---    %s  (Not available on this machine)\n",
               minters[i].name);
        }
      }
#line 404
      goto __Cont;
    }
#line 407
    if (verbose) {
      {
#line 408
      printf((char const   */* __restrict  */)"          %s\r", minters[i].name);
#line 409
      fflush(stdout);
      }
    }
    {
#line 413
    strncpy((char */* __restrict  */)((char *)(block)), (char const   */* __restrict  */)test_string___0,
            (size_t )64);
#line 414
    block[test_tail___0] = (unsigned char)128;
#line 415
    memset((void *)((block + test_tail___0) + 1), 0, (size_t )(59 - (int )test_tail___0));
#line 416
    *((block + 60) + 0) = (unsigned char )(((test_tail___0 << 3) >> 24) & 255);
#line 416
    *((block + 60) + 1) = (unsigned char )(((test_tail___0 << 3) >> 16) & 255);
#line 416
    *((block + 60) + 2) = (unsigned char )(((test_tail___0 << 3) >> 8) & 255);
#line 416
    *((block + 60) + 3) = (unsigned char )((test_tail___0 << 3) & 255);
#line 419
    tmp___3 = clock();
#line 419
    end = (clock_t volatile   )tmp___3;
    }
    {
#line 420
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 420
      tmp___4 = clock();
#line 420
      begin = (clock_t volatile   )tmp___4;
      }
#line 420
      if (! (begin == end)) {
#line 420
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 421
    (*(minters[i].func))((int )test_bits___0, & got_bits, block, (uInt32 const   *)(SHA1_IV___0),
                         (int )test_tail___0, (unsigned long )(1 << 30), (int (*)(int percent ,
                                                                                  int largest ,
                                                                                  int target ,
                                                                                  double count ,
                                                                                  double expected ,
                                                                                  void *user ))((void *)0),
                         (void *)0, (double )0, (double )0);
#line 423
    tmp___5 = clock();
#line 423
    end = (clock_t volatile   )tmp___5;
    }
#line 424
    if (end < begin) {
#line 424
      tmp___0 = begin;
#line 424
      begin = end;
#line 424
      end = tmp___0;
    }
    {
#line 425
    elapsed = (double )(end - begin) / (double )1000000L;
#line 432
    SHA1_Init(& crypter);
#line 433
    SHA1_Update(& crypter, (void const   *)(block), (size_t )test_tail___0);
#line 434
    SHA1_Final(& crypter, (unsigned char *)(hash));
#line 435
    a = 0UL;
    }
    {
#line 435
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 435
      if (a < 19UL) {
#line 435
        if (! ((int )hash[a] == 0)) {
#line 435
          goto while_break___3;
        }
      } else {
#line 435
        goto while_break___3;
      }
#line 435
      a ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 436
    b = 0UL;
    {
#line 436
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 436
      if (b < 8UL) {
#line 436
        if (! (((int )hash[a] & 128) == 0)) {
#line 436
          goto while_break___4;
        }
      } else {
#line 436
        goto while_break___4;
      }
#line 437
      hash[a] = (unsigned char )((int )hash[a] << 1);
#line 436
      b ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 439
    if ((unsigned long )got_bits != a * 8UL + b) {
#line 439
      goto _L;
    } else
#line 439
    if ((unsigned int const   )got_bits < test_bits___0) {
#line 439
      goto _L;
    } else
#line 439
    if ((int )block[test_tail___0] != 128) {
      _L: /* CIL Label */ 
#line 441
      if (verbose) {
        {
#line 442
        printf((char const   */* __restrict  */)"ERROR!\n");
#line 443
        printf((char const   */* __restrict  */)"    Wanted %u bits, reported %d bits, got %lu bits.\n",
               test_bits___0, got_bits, a * 8UL + b);
        }
#line 444
        if ((int )block[test_tail___0] == 128) {
          {
#line 445
          printf((char const   */* __restrict  */)"    End-of-block marker remains intact.\n");
          }
        } else {
          {
#line 447
          printf((char const   */* __restrict  */)"    End-of-block marker damaged!\n");
          }
        }
        {
#line 449
        block[test_tail___0] = (unsigned char)0;
#line 450
        printf((char const   */* __restrict  */)"    \"%s\"\n", block);
#line 451
        printf((char const   */* __restrict  */)"    Time taken: %.3f\n\n", elapsed);
        }
      }
#line 453
      goto __Cont;
    }
#line 458
    a = (unsigned long )(test_tail___0 - 8);
#line 459
    b = 0UL;
#line 460
    p = encodeAlphabets[minters[i].encoding];
    {
#line 461
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 461
      if (a < (unsigned long )test_tail___0) {
#line 461
        if (! ((int )block[a] == 48)) {
#line 461
          goto while_break___5;
        }
      } else {
#line 461
        goto while_break___5;
      }
#line 462
      a ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 464
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 464
      if (! (a < (unsigned long )test_tail___0)) {
#line 464
        goto while_break___6;
      }
      {
#line 465
      tmp___6 = strchr(p, (int )block[a]);
#line 465
      q = (char const   *)tmp___6;
      }
#line 466
      if (! q) {
#line 467
        goto while_break___6;
      }
      {
#line 468
      tmp___7 = strlen(p);
#line 468
      b = b * tmp___7 + (unsigned long )(q - p);
#line 464
      a ++;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
#line 470
    if (a != (unsigned long )test_tail___0) {
#line 471
      if (verbose) {
        {
#line 472
        printf((char const   */* __restrict  */)"ERROR!\n");
#line 473
        printf((char const   */* __restrict  */)"    Unable to parse iteration count.\n");
#line 474
        printf((char const   */* __restrict  */)"    \"%s\"\n", block);
#line 475
        printf((char const   */* __restrict  */)"    \"%s\"\n", p);
        }
      }
#line 477
      goto __Cont;
    }
#line 482
    rate = (double )b / elapsed;
#line 483
    if (verbose) {
#line 484
      if (i == (unsigned long )fastest_minter) {
#line 484
        tmp___8 = '*';
      } else {
#line 484
        tmp___8 = ' ';
      }
      {
#line 484
      printf((char const   */* __restrict  */)"%9lu %s %c\n", (unsigned long )rate,
             minters[i].name, tmp___8);
      }
    }
#line 489
    if (rate > peak_rate) {
#line 490
      peak_rate = rate;
#line 491
      best_minter = (int )i;
    }
#line 495
    if (verbose >= 3) {
      {
#line 496
      block[test_tail___0] = (unsigned char)0;
#line 497
      printf((char const   */* __restrict  */)"    Solution:   %s\n", block);
#line 498
      printf((char const   */* __restrict  */)"    Iterations: %lu\n", b);
#line 499
      printf((char const   */* __restrict  */)"    Time taken: %.3f\n\n", elapsed);
      }
    }
    __Cont: /* CIL Label */ 
#line 398
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 503
  fastest_minter = best_minter;
#line 505
  if (verbose) {
#line 505
    if (best_minter >= 0) {
      {
#line 506
      printf((char const   */* __restrict  */)"Best minter: %s (%lu hashes/sec)\n",
             minters[best_minter].name, (unsigned long )peak_rate);
      }
    }
  }
#line 509
  if (verbose >= 2) {
#line 509
    if (best_minter >= 0) {
      {
#line 510
      printf((char const   */* __restrict  */)"Projected average times to mint:\n");
#line 512
      i = 0UL;
      }
      {
#line 512
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 512
        if (! bit_stats[i]) {
#line 512
          goto while_break___7;
        }
        {
#line 513
        elapsed = (double )(1 << bit_stats[i]) / peak_rate;
#line 514
        printf((char const   */* __restrict  */)"%3d bits: %9.3f seconds", bit_stats[i],
               elapsed);
        }
#line 516
        if (elapsed > (double )200000) {
          {
#line 517
          printf((char const   */* __restrict  */)" (%.1f days)", elapsed / (double )86400);
          }
        } else
#line 518
        if (elapsed > (double )5000) {
          {
#line 519
          printf((char const   */* __restrict  */)" (%.1f hours)", elapsed / (double )3600);
          }
        } else
#line 520
        if (elapsed > (double )100) {
          {
#line 521
          printf((char const   */* __restrict  */)" (%.1f minutes)", elapsed / (double )60);
          }
        } else
#line 522
        if (elapsed < 0.005) {
          {
#line 523
          printf((char const   */* __restrict  */)" (%.1f microseconds)", elapsed * (double )1000000);
          }
        }
        {
#line 526
        printf((char const   */* __restrict  */)"\n");
#line 512
        i ++;
        }
      }
      while_break___7: /* CIL Label */ ;
      }
    }
  }
#line 530
  return ((unsigned long )peak_rate);
}
}
#line 543 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libfastmint.c"
double hashcash_fastmint(int const   bits , char const   *token , int compress , char **result ,
                         int (*cb)(int percent , int largest , int target , double count ,
                                   double expected , void *user ) , void *user_args ) 
{ 
  SHA1_ctx crypter ;
  unsigned char hash[20] ;
  unsigned int tmp ;
  unsigned int IV[5] ;
  unsigned int tmp___0 ;
  unsigned char *buffer ;
  unsigned char *block ;
  unsigned char c ;
  unsigned int buflen ;
  unsigned int tail ;
  unsigned int a ;
  unsigned int b ;
  unsigned int save_tail ;
  unsigned long t ;
  unsigned long loop ;
  unsigned long iters ;
  unsigned long i ;
  unsigned long first ;
  unsigned long (*best_minter)(int bits , int *best , unsigned char *block , uInt32 const   *IV ,
                               int tailIndex , unsigned long maxIter , int (*cb)(int percent ,
                                                                                 int largest ,
                                                                                 int target ,
                                                                                 double count ,
                                                                                 double expected ,
                                                                                 void *user ) ,
                               void *user_args , double counter , double expected ) ;
  double counter ;
  double expected ;
  double percent ;
  struct timeval prev ;
  struct timeval curr ;
  int lastBits ;
  int gotBits ;
  int bit_rate ;
  int chars ;
  int blocks ;
  int oldblocks ;
  int *best ;
  size_t tmp___1 ;
  void *tmp___2 ;
  unsigned int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 547
  hash[0] = (unsigned char)0;
#line 547
  tmp = 1U;
  {
#line 547
  while (1) {
    while_continue: /* CIL Label */ ;
#line 547
    if (tmp >= 20U) {
#line 547
      goto while_break;
    }
#line 547
    hash[tmp] = (unsigned char)0;
#line 547
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 548
  IV[0] = 0U;
#line 548
  tmp___0 = 1U;
  {
#line 548
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 548
    if (tmp___0 >= 5U) {
#line 548
      goto while_break___0;
    }
#line 548
    IV[tmp___0] = 0U;
#line 548
    tmp___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 549
  buffer = (unsigned char *)((void *)0);
#line 549
  block = (unsigned char *)((void *)0);
#line 549
  c = (unsigned char)0;
#line 550
  buflen = 0U;
#line 550
  tail = 0U;
#line 550
  a = 0U;
#line 550
  b = 0U;
#line 550
  save_tail = 0U;
#line 551
  t = 0UL;
#line 551
  loop = 0UL;
#line 551
  iters = 0UL;
#line 551
  i = 0UL;
#line 551
  first = 1UL;
#line 553
  counter = (double )0;
#line 553
  expected = (double )0;
#line 555
  prev.tv_sec = (__time_t )0;
#line 555
  prev.tv_usec = (__suseconds_t )0;
#line 555
  lastBits = 0;
#line 556
  gotBits = 0;
#line 556
  bit_rate = 6;
#line 556
  chars = 0;
#line 556
  blocks = 1;
#line 556
  oldblocks = 0;
#line 559
  best = & gotBits;
#line 562
  if (fastest_minter < 0) {
    {
#line 562
    hashcash_select_minter();
    }
  }
#line 565
  if (compress > 1) {
#line 565
    fastest_minter = 0;
  }
  {
#line 567
  best_minter = minters[fastest_minter].func;
#line 569
  expected = hashcash_expected_tries((int )bits);
  }
  again: 
  {
#line 573
  tmp___1 = strlen(token);
#line 573
  tail = (unsigned int )tmp___1;
#line 574
  buflen = (tail - tail % 64U) + 128U;
#line 575
  tmp___2 = malloc((size_t )buflen);
#line 575
  buffer = (unsigned char *)tmp___2;
#line 576
  memset((void *)buffer, 0, (size_t )buflen);
#line 577
  strncpy((char */* __restrict  */)((char *)buffer), (char const   */* __restrict  */)token,
          (size_t )buflen);
#line 580
  t = (unsigned long )(tail + 16U);
  }
  {
#line 581
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 581
    if (! ((unsigned long )tail < t)) {
#line 581
      goto while_break___1;
    }
    {
#line 582
    random_getbytes((void *)(& c), (size_t )1);
#line 583
    *(buffer + tail) = (unsigned char )*(encodeAlphabets[4] + ((int )c & 63));
#line 581
    tail ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 587
  tmp___3 = tail;
#line 587
  tail ++;
#line 587
  *(buffer + tmp___3) = (unsigned char )':';
#line 588
  save_tail = tail;
#line 590
  bit_rate = (int )EncodeBitRate[encodings[fastest_minter]];
#line 591
  chars = 31 / bit_rate;
#line 592
  if (compress) {
#line 592
    i = 1UL;
  } else {
#line 592
    i = (unsigned long )chars;
  }
  {
#line 592
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 592
    if (i <= (unsigned long )chars) {
#line 592
      if (! first) {
#line 592
        if (! (gotBits < (int )bits)) {
#line 592
          goto while_break___2;
        }
      }
    } else {
#line 592
      goto while_break___2;
    }
#line 594
    first = 0UL;
#line 595
    tail = save_tail;
#line 596
    t = (unsigned long )tail + i;
    {
#line 597
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 597
      if (! ((unsigned long )tail < t)) {
#line 597
        goto while_break___3;
      }
#line 597
      *(buffer + tail) = (unsigned char )'0';
#line 597
      tail ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 599
    if (compress == 0) {
#line 599
      goto case_0;
    }
#line 606
    if (compress == 1) {
#line 606
      goto case_1;
    }
#line 613
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 601
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 601
      if (tail % 64U != 32U) {
#line 601
        if (! (tail % 64U != 52U)) {
#line 601
          goto while_break___4;
        }
      } else {
#line 601
        goto while_break___4;
      }
#line 603
      *(buffer + tail) = (unsigned char )'0';
#line 601
      tail ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 605
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 608
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 608
      if (! ((unsigned long )(tail % 64U) < i)) {
#line 608
        if (! (tail % 64U >= 56U)) {
#line 608
          goto while_break___5;
        }
      }
#line 610
      *(buffer + tail) = (unsigned char )'0';
#line 608
      tail ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 612
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 614
    oldblocks = blocks;
#line 615
    if ((unsigned long )(tail % 64U) < i) {
#line 617
      blocks = 2;
    } else
#line 615
    if (tail % 64U >= 56U) {
#line 617
      blocks = 2;
    }
    switch_break: /* CIL Label */ ;
    }
#line 623
    t = (unsigned long )(tail - tail % 64U);
#line 624
    if (blocks > 1) {
#line 624
      if (t >= 64UL) {
#line 624
        if ((unsigned long )(tail % 64U) < i) {
#line 625
          t -= 64UL;
        }
      }
    }
    {
#line 627
    SHA1_Init(& crypter);
#line 628
    SHA1_Update(& crypter, (void const   *)buffer, t);
#line 636
    a = 0U;
    }
    {
#line 636
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 636
      if (! (a < 5U)) {
#line 636
        goto while_break___6;
      }
#line 636
      IV[a] = crypter.H[a];
#line 636
      a ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 638
    block = buffer + t;
#line 641
    *(buffer + tail) = (unsigned char)128;
#line 643
    if (blocks > oldblocks) {
      {
#line 645
      memset((void *)((buffer + tail) + 1), 0, (size_t )7);
      }
    }
#line 647
    if (blocks > 1) {
#line 647
      tmp___4 = 64;
    } else {
#line 647
      tmp___4 = 0;
    }
#line 647
    *(((block + tmp___4) + 60) + 0) = (unsigned char )(((tail << 3) >> 24) & 255U);
#line 647
    if (blocks > 1) {
#line 647
      tmp___5 = 64;
    } else {
#line 647
      tmp___5 = 0;
    }
#line 647
    *(((block + tmp___5) + 60) + 1) = (unsigned char )(((tail << 3) >> 16) & 255U);
#line 647
    if (blocks > 1) {
#line 647
      tmp___6 = 64;
    } else {
#line 647
      tmp___6 = 0;
    }
#line 647
    *(((block + tmp___6) + 60) + 2) = (unsigned char )(((tail << 3) >> 8) & 255U);
#line 647
    if (blocks > 1) {
#line 647
      tmp___7 = 64;
    } else {
#line 647
      tmp___7 = 0;
    }
    {
#line 647
    *(((block + tmp___7) + 60) + 3) = (unsigned char )((tail << 3) & 255U);
#line 648
    tail = (unsigned int )((unsigned long )tail - t);
#line 651
    loop = (*best_minter)((int )bits, & gotBits, block, (uInt32 const   *)(IV), (int )tail,
                          (unsigned long )(1U << i * (unsigned long )bit_rate), cb,
                          user_args, counter, expected);
    }
#line 654
    if (loop == 0UL) {
      {
#line 655
      free((void *)buffer);
      }
#line 656
      if (*best == -1) {
#line 656
        return ((double )-1);
      } else {
#line 657
        return ((double )0);
      }
    }
#line 659
    counter += (double )loop;
#line 592
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 663
  if (gotBits >= (int )bits) {
    {
#line 663
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 663
      if ((unsigned long )cb != (unsigned long )((void *)0)) {
#line 663
        if ((iters & 65535UL) == 0UL) {
          {
#line 663
          gettimeofday((struct timeval */* __restrict  */)(& curr), (__timezone_ptr_t )((void *)0));
          }
#line 663
          if (gotBits > lastBits) {
#line 663
            goto _L___0;
          } else
#line 663
          if (curr.tv_sec - prev.tv_sec > 1L) {
#line 663
            goto _L___0;
          } else {
#line 663
            if (curr.tv_sec - prev.tv_sec) {
#line 663
              tmp___9 = 1000000;
            } else {
#line 663
              tmp___9 = 0;
            }
#line 663
            if ((curr.tv_usec + (__suseconds_t )tmp___9) - prev.tv_usec > 100000L) {
              _L___0: /* CIL Label */ 
              {
#line 663
              percent = (double )((int )(((counter + (double )iters) / expected) * (double )100 + 0.5));
#line 663
              tmp___8 = (*cb)((int )percent, *best, (int )bits, counter + (double )iters,
                              expected, user_args);
              }
#line 663
              if (! tmp___8) {
#line 663
                *best = -1;
#line 663
                return ((double )0);
              }
#line 663
              prev = curr;
#line 663
              lastBits = gotBits;
            }
          }
        }
      }
#line 663
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
  }
  {
#line 664
  *(block + tail) = (unsigned char)0;
#line 667
  SHA1_Update(& crypter, (void const   *)block, (size_t )tail);
#line 668
  SHA1_Final(& crypter, (unsigned char *)(hash));
#line 669
  a = 0U;
  }
  {
#line 669
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 669
    if (a < 19U) {
#line 669
      if (! ((int )hash[a] == 0)) {
#line 669
        goto while_break___8;
      }
    } else {
#line 669
      goto while_break___8;
    }
#line 669
    a ++;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 671
  b = 0U;
  {
#line 671
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 671
    if (b < 8U) {
#line 671
      if (! (((int )hash[a] & 128) == 0)) {
#line 671
        goto while_break___9;
      }
    } else {
#line 671
      goto while_break___9;
    }
#line 672
    hash[a] = (unsigned char )((int )hash[a] << 1);
#line 671
    b ++;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 673
  b += a * 8U;
#line 676
  if (b < (unsigned int )gotBits) {
    {
#line 677
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR: requested %d bits, reported %d bits, got %d bits using %s minter: \"%s\"\n",
            bits, gotBits, b, minters[fastest_minter].name, buffer);
#line 680
    exit(3);
    }
  }
#line 686
  if (b < (unsigned int )bits) {
    {
#line 689
    free((void *)buffer);
    }
#line 690
    goto again;
  }
#line 693
  *result = (char *)buffer;
#line 694
  return (counter);
}
}
#line 697 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libfastmint.c"
int hashcash_core(void) 
{ 


  {
#line 699
  if (! num_minters) {
    {
#line 699
    hashcash_select_minter();
    }
  }
#line 700
  return (fastest_minter);
}
}
#line 703 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libfastmint.c"
int hashcash_use_core(int core ) 
{ 
  int tmp ;

  {
#line 705
  if (! num_minters) {
    {
#line 705
    hashcash_select_minter();
    }
  }
#line 706
  if (core < 0) {
#line 706
    return (-1);
  } else
#line 706
  if ((unsigned int )core >= num_minters) {
#line 706
    return (-1);
  }
  {
#line 707
  tmp = (*(minters[core].test))();
  }
#line 707
  if (! tmp) {
#line 707
    return (0);
  }
#line 708
  fastest_minter = core;
#line 710
  cached_per_sec = 0;
#line 711
  return (1);
}
}
#line 714 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libfastmint.c"
char const   *hashcash_core_name(int core ) 
{ 


  {
#line 716
  if (! num_minters) {
    {
#line 716
    hashcash_select_minter();
    }
  }
#line 717
  if (core < 0) {
#line 718
    return ("undefined core");
  } else
#line 717
  if ((unsigned int )core >= num_minters) {
#line 718
    return ("undefined core");
  }
#line 720
  return (minters[core].name);
}
}
#line 10 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/fastmint_mmx_standard_1.c"
int minter_mmx_standard_1_test(void) 
{ 


  {
#line 18
  return (0);
}
}
#line 287 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/fastmint_mmx_standard_1.c"
unsigned long minter_mmx_standard_1(int bits , int *best , unsigned char *block ,
                                    uInt32 const   *IV , int tailIndex , unsigned long maxIter ,
                                    int (*cb)(int percent , int largest , int target ,
                                              double count , double expected , void *user ) ,
                                    void *user_args , double counter , double expected ) 
{ 


  {
#line 636
  return (0UL);
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/sha1.h"
void SHA1_Init_With_IV(SHA1_ctx *ctx , unsigned char const   *user_IV ) ;
#line 21 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libsha1.c"
static int swap_endian32(void *data , size_t len ) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libsha1.c"
static int const   endian_test  =    (int const   )1;
#line 123 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libsha1.c"
unsigned int SHA1_IV[5]  = {      1732584193U,      4023233417U,      2562383102U,      271733878U, 
        3285377520U};
#line 138 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libsha1.c"
void SHA1_Init(SHA1_ctx *ctx ) 
{ 


  {
  {
#line 140
  ctx->bits = 0UL;
#line 141
  memcpy((void */* __restrict  */)(ctx->H), (void const   */* __restrict  */)(SHA1_IV),
         (size_t )20);
  }
#line 142
  return;
}
}
#line 147 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libsha1.c"
void SHA1_Init_With_IV(SHA1_ctx *ctx , unsigned char const   *user_IV ) 
{ 


  {
  {
#line 150
  ctx->bits = 0UL;
#line 151
  memcpy((void */* __restrict  */)(ctx->H), (void const   */* __restrict  */)user_IV,
         (size_t )20);
  }
#line 152
  if ((int )*((char *)(& endian_test)) == 1) {
    {
#line 152
    swap_endian32((void *)(ctx->H), (size_t )5);
    }
  }
#line 153
  return;
}
}
#line 155 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libsha1.c"
void SHA1_Transform(unsigned int *H , unsigned char const   *M ) 
{ 
  unsigned int A ;
  unsigned int B ;
  unsigned int C ;
  unsigned int D ;
  unsigned int E ;
  unsigned int W[16] ;
  unsigned int tmp ;

  {
#line 161
  A = *(H + 0);
#line 162
  B = *(H + 1);
#line 163
  C = *(H + 2);
#line 164
  D = *(H + 3);
#line 165
  E = *(H + 4);
#line 167
  W[0] = 0U;
#line 167
  tmp = 1U;
  {
#line 167
  while (1) {
    while_continue: /* CIL Label */ ;
#line 167
    if (tmp >= 16U) {
#line 167
      goto while_break;
    }
#line 167
    W[tmp] = 0U;
#line 167
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 172
  memcpy((void */* __restrict  */)(W), (void const   */* __restrict  */)M, (size_t )64);
#line 259
  E += ((((A << 5) | (A >> 27)) + (D ^ (B & (C ^ D)))) + W[0]) + 1518500249U;
#line 259
  B = (B << 30) | (B >> 2);
#line 259
  D += ((((E << 5) | (E >> 27)) + (C ^ (A & (B ^ C)))) + W[1]) + 1518500249U;
#line 259
  A = (A << 30) | (A >> 2);
#line 259
  C += ((((D << 5) | (D >> 27)) + (B ^ (E & (A ^ B)))) + W[2]) + 1518500249U;
#line 259
  E = (E << 30) | (E >> 2);
#line 259
  B += ((((C << 5) | (C >> 27)) + (A ^ (D & (E ^ A)))) + W[3]) + 1518500249U;
#line 259
  D = (D << 30) | (D >> 2);
#line 259
  A += ((((B << 5) | (B >> 27)) + (E ^ (C & (D ^ E)))) + W[4]) + 1518500249U;
#line 259
  C = (C << 30) | (C >> 2);
#line 259
  E += ((((A << 5) | (A >> 27)) + (D ^ (B & (C ^ D)))) + W[5]) + 1518500249U;
#line 259
  B = (B << 30) | (B >> 2);
#line 259
  D += ((((E << 5) | (E >> 27)) + (C ^ (A & (B ^ C)))) + W[6]) + 1518500249U;
#line 259
  A = (A << 30) | (A >> 2);
#line 259
  C += ((((D << 5) | (D >> 27)) + (B ^ (E & (A ^ B)))) + W[7]) + 1518500249U;
#line 259
  E = (E << 30) | (E >> 2);
#line 259
  B += ((((C << 5) | (C >> 27)) + (A ^ (D & (E ^ A)))) + W[8]) + 1518500249U;
#line 259
  D = (D << 30) | (D >> 2);
#line 259
  A += ((((B << 5) | (B >> 27)) + (E ^ (C & (D ^ E)))) + W[9]) + 1518500249U;
#line 259
  C = (C << 30) | (C >> 2);
#line 259
  E += ((((A << 5) | (A >> 27)) + (D ^ (B & (C ^ D)))) + W[10]) + 1518500249U;
#line 259
  B = (B << 30) | (B >> 2);
#line 259
  D += ((((E << 5) | (E >> 27)) + (C ^ (A & (B ^ C)))) + W[11]) + 1518500249U;
#line 259
  A = (A << 30) | (A >> 2);
#line 259
  C += ((((D << 5) | (D >> 27)) + (B ^ (E & (A ^ B)))) + W[12]) + 1518500249U;
#line 259
  E = (E << 30) | (E >> 2);
#line 259
  B += ((((C << 5) | (C >> 27)) + (A ^ (D & (E ^ A)))) + W[13]) + 1518500249U;
#line 259
  D = (D << 30) | (D >> 2);
#line 259
  A += ((((B << 5) | (B >> 27)) + (E ^ (C & (D ^ E)))) + W[14]) + 1518500249U;
#line 259
  C = (C << 30) | (C >> 2);
#line 259
  E += ((((A << 5) | (A >> 27)) + (D ^ (B & (C ^ D)))) + W[15]) + 1518500249U;
#line 259
  B = (B << 30) | (B >> 2);
#line 259
  W[0] = ((((W[0] ^ W[2]) ^ W[8]) ^ W[13]) << 1) | ((((W[0] ^ W[2]) ^ W[8]) ^ W[13]) >> 31);
#line 259
  D += ((((E << 5) | (E >> 27)) + (C ^ (A & (B ^ C)))) + W[0]) + 1518500249U;
#line 259
  A = (A << 30) | (A >> 2);
#line 259
  W[1] = ((((W[1] ^ W[3]) ^ W[9]) ^ W[14]) << 1) | ((((W[1] ^ W[3]) ^ W[9]) ^ W[14]) >> 31);
#line 259
  C += ((((D << 5) | (D >> 27)) + (B ^ (E & (A ^ B)))) + W[1]) + 1518500249U;
#line 259
  E = (E << 30) | (E >> 2);
#line 259
  W[2] = ((((W[2] ^ W[4]) ^ W[10]) ^ W[15]) << 1) | ((((W[2] ^ W[4]) ^ W[10]) ^ W[15]) >> 31);
#line 259
  B += ((((C << 5) | (C >> 27)) + (A ^ (D & (E ^ A)))) + W[2]) + 1518500249U;
#line 259
  D = (D << 30) | (D >> 2);
#line 259
  W[3] = ((((W[3] ^ W[5]) ^ W[11]) ^ W[0]) << 1) | ((((W[3] ^ W[5]) ^ W[11]) ^ W[0]) >> 31);
#line 259
  A += ((((B << 5) | (B >> 27)) + (E ^ (C & (D ^ E)))) + W[3]) + 1518500249U;
#line 259
  C = (C << 30) | (C >> 2);
#line 263
  W[4] = ((((W[4] ^ W[6]) ^ W[12]) ^ W[1]) << 1) | ((((W[4] ^ W[6]) ^ W[12]) ^ W[1]) >> 31);
#line 263
  E += ((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) + W[4]) + 1859775393U;
#line 263
  B = (B << 30) | (B >> 2);
#line 263
  W[5] = ((((W[5] ^ W[7]) ^ W[13]) ^ W[2]) << 1) | ((((W[5] ^ W[7]) ^ W[13]) ^ W[2]) >> 31);
#line 263
  D += ((((E << 5) | (E >> 27)) + ((A ^ B) ^ C)) + W[5]) + 1859775393U;
#line 263
  A = (A << 30) | (A >> 2);
#line 263
  W[6] = ((((W[6] ^ W[8]) ^ W[14]) ^ W[3]) << 1) | ((((W[6] ^ W[8]) ^ W[14]) ^ W[3]) >> 31);
#line 263
  C += ((((D << 5) | (D >> 27)) + ((E ^ A) ^ B)) + W[6]) + 1859775393U;
#line 263
  E = (E << 30) | (E >> 2);
#line 263
  W[7] = ((((W[7] ^ W[9]) ^ W[15]) ^ W[4]) << 1) | ((((W[7] ^ W[9]) ^ W[15]) ^ W[4]) >> 31);
#line 263
  B += ((((C << 5) | (C >> 27)) + ((D ^ E) ^ A)) + W[7]) + 1859775393U;
#line 263
  D = (D << 30) | (D >> 2);
#line 263
  W[8] = ((((W[8] ^ W[10]) ^ W[0]) ^ W[5]) << 1) | ((((W[8] ^ W[10]) ^ W[0]) ^ W[5]) >> 31);
#line 263
  A += ((((B << 5) | (B >> 27)) + ((C ^ D) ^ E)) + W[8]) + 1859775393U;
#line 263
  C = (C << 30) | (C >> 2);
#line 263
  W[9] = ((((W[9] ^ W[11]) ^ W[1]) ^ W[6]) << 1) | ((((W[9] ^ W[11]) ^ W[1]) ^ W[6]) >> 31);
#line 263
  E += ((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) + W[9]) + 1859775393U;
#line 263
  B = (B << 30) | (B >> 2);
#line 263
  W[10] = ((((W[10] ^ W[12]) ^ W[2]) ^ W[7]) << 1) | ((((W[10] ^ W[12]) ^ W[2]) ^ W[7]) >> 31);
#line 263
  D += ((((E << 5) | (E >> 27)) + ((A ^ B) ^ C)) + W[10]) + 1859775393U;
#line 263
  A = (A << 30) | (A >> 2);
#line 263
  W[11] = ((((W[11] ^ W[13]) ^ W[3]) ^ W[8]) << 1) | ((((W[11] ^ W[13]) ^ W[3]) ^ W[8]) >> 31);
#line 263
  C += ((((D << 5) | (D >> 27)) + ((E ^ A) ^ B)) + W[11]) + 1859775393U;
#line 263
  E = (E << 30) | (E >> 2);
#line 263
  W[12] = ((((W[12] ^ W[14]) ^ W[4]) ^ W[9]) << 1) | ((((W[12] ^ W[14]) ^ W[4]) ^ W[9]) >> 31);
#line 263
  B += ((((C << 5) | (C >> 27)) + ((D ^ E) ^ A)) + W[12]) + 1859775393U;
#line 263
  D = (D << 30) | (D >> 2);
#line 263
  W[13] = ((((W[13] ^ W[15]) ^ W[5]) ^ W[10]) << 1) | ((((W[13] ^ W[15]) ^ W[5]) ^ W[10]) >> 31);
#line 263
  A += ((((B << 5) | (B >> 27)) + ((C ^ D) ^ E)) + W[13]) + 1859775393U;
#line 263
  C = (C << 30) | (C >> 2);
#line 263
  W[14] = ((((W[14] ^ W[0]) ^ W[6]) ^ W[11]) << 1) | ((((W[14] ^ W[0]) ^ W[6]) ^ W[11]) >> 31);
#line 263
  E += ((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) + W[14]) + 1859775393U;
#line 263
  B = (B << 30) | (B >> 2);
#line 263
  W[15] = ((((W[15] ^ W[1]) ^ W[7]) ^ W[12]) << 1) | ((((W[15] ^ W[1]) ^ W[7]) ^ W[12]) >> 31);
#line 263
  D += ((((E << 5) | (E >> 27)) + ((A ^ B) ^ C)) + W[15]) + 1859775393U;
#line 263
  A = (A << 30) | (A >> 2);
#line 263
  W[0] = ((((W[0] ^ W[2]) ^ W[8]) ^ W[13]) << 1) | ((((W[0] ^ W[2]) ^ W[8]) ^ W[13]) >> 31);
#line 263
  C += ((((D << 5) | (D >> 27)) + ((E ^ A) ^ B)) + W[0]) + 1859775393U;
#line 263
  E = (E << 30) | (E >> 2);
#line 263
  W[1] = ((((W[1] ^ W[3]) ^ W[9]) ^ W[14]) << 1) | ((((W[1] ^ W[3]) ^ W[9]) ^ W[14]) >> 31);
#line 263
  B += ((((C << 5) | (C >> 27)) + ((D ^ E) ^ A)) + W[1]) + 1859775393U;
#line 263
  D = (D << 30) | (D >> 2);
#line 263
  W[2] = ((((W[2] ^ W[4]) ^ W[10]) ^ W[15]) << 1) | ((((W[2] ^ W[4]) ^ W[10]) ^ W[15]) >> 31);
#line 263
  A += ((((B << 5) | (B >> 27)) + ((C ^ D) ^ E)) + W[2]) + 1859775393U;
#line 263
  C = (C << 30) | (C >> 2);
#line 263
  W[3] = ((((W[3] ^ W[5]) ^ W[11]) ^ W[0]) << 1) | ((((W[3] ^ W[5]) ^ W[11]) ^ W[0]) >> 31);
#line 263
  E += ((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) + W[3]) + 1859775393U;
#line 263
  B = (B << 30) | (B >> 2);
#line 263
  W[4] = ((((W[4] ^ W[6]) ^ W[12]) ^ W[1]) << 1) | ((((W[4] ^ W[6]) ^ W[12]) ^ W[1]) >> 31);
#line 263
  D += ((((E << 5) | (E >> 27)) + ((A ^ B) ^ C)) + W[4]) + 1859775393U;
#line 263
  A = (A << 30) | (A >> 2);
#line 263
  W[5] = ((((W[5] ^ W[7]) ^ W[13]) ^ W[2]) << 1) | ((((W[5] ^ W[7]) ^ W[13]) ^ W[2]) >> 31);
#line 263
  C += ((((D << 5) | (D >> 27)) + ((E ^ A) ^ B)) + W[5]) + 1859775393U;
#line 263
  E = (E << 30) | (E >> 2);
#line 263
  W[6] = ((((W[6] ^ W[8]) ^ W[14]) ^ W[3]) << 1) | ((((W[6] ^ W[8]) ^ W[14]) ^ W[3]) >> 31);
#line 263
  B += ((((C << 5) | (C >> 27)) + ((D ^ E) ^ A)) + W[6]) + 1859775393U;
#line 263
  D = (D << 30) | (D >> 2);
#line 263
  W[7] = ((((W[7] ^ W[9]) ^ W[15]) ^ W[4]) << 1) | ((((W[7] ^ W[9]) ^ W[15]) ^ W[4]) >> 31);
#line 263
  A += ((((B << 5) | (B >> 27)) + ((C ^ D) ^ E)) + W[7]) + 1859775393U;
#line 263
  C = (C << 30) | (C >> 2);
#line 267
  W[8] = ((((W[8] ^ W[10]) ^ W[0]) ^ W[5]) << 1) | ((((W[8] ^ W[10]) ^ W[0]) ^ W[5]) >> 31);
#line 267
  E += ((((A << 5) | (A >> 27)) + ((B & (C | D)) | (C & D))) + W[8]) + 2400959708U;
#line 267
  B = (B << 30) | (B >> 2);
#line 267
  W[9] = ((((W[9] ^ W[11]) ^ W[1]) ^ W[6]) << 1) | ((((W[9] ^ W[11]) ^ W[1]) ^ W[6]) >> 31);
#line 267
  D += ((((E << 5) | (E >> 27)) + ((A & (B | C)) | (B & C))) + W[9]) + 2400959708U;
#line 267
  A = (A << 30) | (A >> 2);
#line 267
  W[10] = ((((W[10] ^ W[12]) ^ W[2]) ^ W[7]) << 1) | ((((W[10] ^ W[12]) ^ W[2]) ^ W[7]) >> 31);
#line 267
  C += ((((D << 5) | (D >> 27)) + ((E & (A | B)) | (A & B))) + W[10]) + 2400959708U;
#line 267
  E = (E << 30) | (E >> 2);
#line 267
  W[11] = ((((W[11] ^ W[13]) ^ W[3]) ^ W[8]) << 1) | ((((W[11] ^ W[13]) ^ W[3]) ^ W[8]) >> 31);
#line 267
  B += ((((C << 5) | (C >> 27)) + ((D & (E | A)) | (E & A))) + W[11]) + 2400959708U;
#line 267
  D = (D << 30) | (D >> 2);
#line 267
  W[12] = ((((W[12] ^ W[14]) ^ W[4]) ^ W[9]) << 1) | ((((W[12] ^ W[14]) ^ W[4]) ^ W[9]) >> 31);
#line 267
  A += ((((B << 5) | (B >> 27)) + ((C & (D | E)) | (D & E))) + W[12]) + 2400959708U;
#line 267
  C = (C << 30) | (C >> 2);
#line 267
  W[13] = ((((W[13] ^ W[15]) ^ W[5]) ^ W[10]) << 1) | ((((W[13] ^ W[15]) ^ W[5]) ^ W[10]) >> 31);
#line 267
  E += ((((A << 5) | (A >> 27)) + ((B & (C | D)) | (C & D))) + W[13]) + 2400959708U;
#line 267
  B = (B << 30) | (B >> 2);
#line 267
  W[14] = ((((W[14] ^ W[0]) ^ W[6]) ^ W[11]) << 1) | ((((W[14] ^ W[0]) ^ W[6]) ^ W[11]) >> 31);
#line 267
  D += ((((E << 5) | (E >> 27)) + ((A & (B | C)) | (B & C))) + W[14]) + 2400959708U;
#line 267
  A = (A << 30) | (A >> 2);
#line 267
  W[15] = ((((W[15] ^ W[1]) ^ W[7]) ^ W[12]) << 1) | ((((W[15] ^ W[1]) ^ W[7]) ^ W[12]) >> 31);
#line 267
  C += ((((D << 5) | (D >> 27)) + ((E & (A | B)) | (A & B))) + W[15]) + 2400959708U;
#line 267
  E = (E << 30) | (E >> 2);
#line 267
  W[0] = ((((W[0] ^ W[2]) ^ W[8]) ^ W[13]) << 1) | ((((W[0] ^ W[2]) ^ W[8]) ^ W[13]) >> 31);
#line 267
  B += ((((C << 5) | (C >> 27)) + ((D & (E | A)) | (E & A))) + W[0]) + 2400959708U;
#line 267
  D = (D << 30) | (D >> 2);
#line 267
  W[1] = ((((W[1] ^ W[3]) ^ W[9]) ^ W[14]) << 1) | ((((W[1] ^ W[3]) ^ W[9]) ^ W[14]) >> 31);
#line 267
  A += ((((B << 5) | (B >> 27)) + ((C & (D | E)) | (D & E))) + W[1]) + 2400959708U;
#line 267
  C = (C << 30) | (C >> 2);
#line 267
  W[2] = ((((W[2] ^ W[4]) ^ W[10]) ^ W[15]) << 1) | ((((W[2] ^ W[4]) ^ W[10]) ^ W[15]) >> 31);
#line 267
  E += ((((A << 5) | (A >> 27)) + ((B & (C | D)) | (C & D))) + W[2]) + 2400959708U;
#line 267
  B = (B << 30) | (B >> 2);
#line 267
  W[3] = ((((W[3] ^ W[5]) ^ W[11]) ^ W[0]) << 1) | ((((W[3] ^ W[5]) ^ W[11]) ^ W[0]) >> 31);
#line 267
  D += ((((E << 5) | (E >> 27)) + ((A & (B | C)) | (B & C))) + W[3]) + 2400959708U;
#line 267
  A = (A << 30) | (A >> 2);
#line 267
  W[4] = ((((W[4] ^ W[6]) ^ W[12]) ^ W[1]) << 1) | ((((W[4] ^ W[6]) ^ W[12]) ^ W[1]) >> 31);
#line 267
  C += ((((D << 5) | (D >> 27)) + ((E & (A | B)) | (A & B))) + W[4]) + 2400959708U;
#line 267
  E = (E << 30) | (E >> 2);
#line 267
  W[5] = ((((W[5] ^ W[7]) ^ W[13]) ^ W[2]) << 1) | ((((W[5] ^ W[7]) ^ W[13]) ^ W[2]) >> 31);
#line 267
  B += ((((C << 5) | (C >> 27)) + ((D & (E | A)) | (E & A))) + W[5]) + 2400959708U;
#line 267
  D = (D << 30) | (D >> 2);
#line 267
  W[6] = ((((W[6] ^ W[8]) ^ W[14]) ^ W[3]) << 1) | ((((W[6] ^ W[8]) ^ W[14]) ^ W[3]) >> 31);
#line 267
  A += ((((B << 5) | (B >> 27)) + ((C & (D | E)) | (D & E))) + W[6]) + 2400959708U;
#line 267
  C = (C << 30) | (C >> 2);
#line 267
  W[7] = ((((W[7] ^ W[9]) ^ W[15]) ^ W[4]) << 1) | ((((W[7] ^ W[9]) ^ W[15]) ^ W[4]) >> 31);
#line 267
  E += ((((A << 5) | (A >> 27)) + ((B & (C | D)) | (C & D))) + W[7]) + 2400959708U;
#line 267
  B = (B << 30) | (B >> 2);
#line 267
  W[8] = ((((W[8] ^ W[10]) ^ W[0]) ^ W[5]) << 1) | ((((W[8] ^ W[10]) ^ W[0]) ^ W[5]) >> 31);
#line 267
  D += ((((E << 5) | (E >> 27)) + ((A & (B | C)) | (B & C))) + W[8]) + 2400959708U;
#line 267
  A = (A << 30) | (A >> 2);
#line 267
  W[9] = ((((W[9] ^ W[11]) ^ W[1]) ^ W[6]) << 1) | ((((W[9] ^ W[11]) ^ W[1]) ^ W[6]) >> 31);
#line 267
  C += ((((D << 5) | (D >> 27)) + ((E & (A | B)) | (A & B))) + W[9]) + 2400959708U;
#line 267
  E = (E << 30) | (E >> 2);
#line 267
  W[10] = ((((W[10] ^ W[12]) ^ W[2]) ^ W[7]) << 1) | ((((W[10] ^ W[12]) ^ W[2]) ^ W[7]) >> 31);
#line 267
  B += ((((C << 5) | (C >> 27)) + ((D & (E | A)) | (E & A))) + W[10]) + 2400959708U;
#line 267
  D = (D << 30) | (D >> 2);
#line 267
  W[11] = ((((W[11] ^ W[13]) ^ W[3]) ^ W[8]) << 1) | ((((W[11] ^ W[13]) ^ W[3]) ^ W[8]) >> 31);
#line 267
  A += ((((B << 5) | (B >> 27)) + ((C & (D | E)) | (D & E))) + W[11]) + 2400959708U;
#line 267
  C = (C << 30) | (C >> 2);
#line 271
  W[12] = ((((W[12] ^ W[14]) ^ W[4]) ^ W[9]) << 1) | ((((W[12] ^ W[14]) ^ W[4]) ^ W[9]) >> 31);
#line 271
  E += ((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) + W[12]) + 3395469782U;
#line 271
  B = (B << 30) | (B >> 2);
#line 271
  W[13] = ((((W[13] ^ W[15]) ^ W[5]) ^ W[10]) << 1) | ((((W[13] ^ W[15]) ^ W[5]) ^ W[10]) >> 31);
#line 271
  D += ((((E << 5) | (E >> 27)) + ((A ^ B) ^ C)) + W[13]) + 3395469782U;
#line 271
  A = (A << 30) | (A >> 2);
#line 271
  W[14] = ((((W[14] ^ W[0]) ^ W[6]) ^ W[11]) << 1) | ((((W[14] ^ W[0]) ^ W[6]) ^ W[11]) >> 31);
#line 271
  C += ((((D << 5) | (D >> 27)) + ((E ^ A) ^ B)) + W[14]) + 3395469782U;
#line 271
  E = (E << 30) | (E >> 2);
#line 271
  W[15] = ((((W[15] ^ W[1]) ^ W[7]) ^ W[12]) << 1) | ((((W[15] ^ W[1]) ^ W[7]) ^ W[12]) >> 31);
#line 271
  B += ((((C << 5) | (C >> 27)) + ((D ^ E) ^ A)) + W[15]) + 3395469782U;
#line 271
  D = (D << 30) | (D >> 2);
#line 271
  W[0] = ((((W[0] ^ W[2]) ^ W[8]) ^ W[13]) << 1) | ((((W[0] ^ W[2]) ^ W[8]) ^ W[13]) >> 31);
#line 271
  A += ((((B << 5) | (B >> 27)) + ((C ^ D) ^ E)) + W[0]) + 3395469782U;
#line 271
  C = (C << 30) | (C >> 2);
#line 271
  W[1] = ((((W[1] ^ W[3]) ^ W[9]) ^ W[14]) << 1) | ((((W[1] ^ W[3]) ^ W[9]) ^ W[14]) >> 31);
#line 271
  E += ((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) + W[1]) + 3395469782U;
#line 271
  B = (B << 30) | (B >> 2);
#line 271
  W[2] = ((((W[2] ^ W[4]) ^ W[10]) ^ W[15]) << 1) | ((((W[2] ^ W[4]) ^ W[10]) ^ W[15]) >> 31);
#line 271
  D += ((((E << 5) | (E >> 27)) + ((A ^ B) ^ C)) + W[2]) + 3395469782U;
#line 271
  A = (A << 30) | (A >> 2);
#line 271
  W[3] = ((((W[3] ^ W[5]) ^ W[11]) ^ W[0]) << 1) | ((((W[3] ^ W[5]) ^ W[11]) ^ W[0]) >> 31);
#line 271
  C += ((((D << 5) | (D >> 27)) + ((E ^ A) ^ B)) + W[3]) + 3395469782U;
#line 271
  E = (E << 30) | (E >> 2);
#line 271
  W[4] = ((((W[4] ^ W[6]) ^ W[12]) ^ W[1]) << 1) | ((((W[4] ^ W[6]) ^ W[12]) ^ W[1]) >> 31);
#line 271
  B += ((((C << 5) | (C >> 27)) + ((D ^ E) ^ A)) + W[4]) + 3395469782U;
#line 271
  D = (D << 30) | (D >> 2);
#line 271
  W[5] = ((((W[5] ^ W[7]) ^ W[13]) ^ W[2]) << 1) | ((((W[5] ^ W[7]) ^ W[13]) ^ W[2]) >> 31);
#line 271
  A += ((((B << 5) | (B >> 27)) + ((C ^ D) ^ E)) + W[5]) + 3395469782U;
#line 271
  C = (C << 30) | (C >> 2);
#line 271
  W[6] = ((((W[6] ^ W[8]) ^ W[14]) ^ W[3]) << 1) | ((((W[6] ^ W[8]) ^ W[14]) ^ W[3]) >> 31);
#line 271
  E += ((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) + W[6]) + 3395469782U;
#line 271
  B = (B << 30) | (B >> 2);
#line 271
  W[7] = ((((W[7] ^ W[9]) ^ W[15]) ^ W[4]) << 1) | ((((W[7] ^ W[9]) ^ W[15]) ^ W[4]) >> 31);
#line 271
  D += ((((E << 5) | (E >> 27)) + ((A ^ B) ^ C)) + W[7]) + 3395469782U;
#line 271
  A = (A << 30) | (A >> 2);
#line 271
  W[8] = ((((W[8] ^ W[10]) ^ W[0]) ^ W[5]) << 1) | ((((W[8] ^ W[10]) ^ W[0]) ^ W[5]) >> 31);
#line 271
  C += ((((D << 5) | (D >> 27)) + ((E ^ A) ^ B)) + W[8]) + 3395469782U;
#line 271
  E = (E << 30) | (E >> 2);
#line 271
  W[9] = ((((W[9] ^ W[11]) ^ W[1]) ^ W[6]) << 1) | ((((W[9] ^ W[11]) ^ W[1]) ^ W[6]) >> 31);
#line 271
  B += ((((C << 5) | (C >> 27)) + ((D ^ E) ^ A)) + W[9]) + 3395469782U;
#line 271
  D = (D << 30) | (D >> 2);
#line 271
  W[10] = ((((W[10] ^ W[12]) ^ W[2]) ^ W[7]) << 1) | ((((W[10] ^ W[12]) ^ W[2]) ^ W[7]) >> 31);
#line 271
  A += ((((B << 5) | (B >> 27)) + ((C ^ D) ^ E)) + W[10]) + 3395469782U;
#line 271
  C = (C << 30) | (C >> 2);
#line 271
  W[11] = ((((W[11] ^ W[13]) ^ W[3]) ^ W[8]) << 1) | ((((W[11] ^ W[13]) ^ W[3]) ^ W[8]) >> 31);
#line 271
  E += ((((A << 5) | (A >> 27)) + ((B ^ C) ^ D)) + W[11]) + 3395469782U;
#line 271
  B = (B << 30) | (B >> 2);
#line 271
  W[12] = ((((W[12] ^ W[14]) ^ W[4]) ^ W[9]) << 1) | ((((W[12] ^ W[14]) ^ W[4]) ^ W[9]) >> 31);
#line 271
  D += ((((E << 5) | (E >> 27)) + ((A ^ B) ^ C)) + W[12]) + 3395469782U;
#line 271
  A = (A << 30) | (A >> 2);
#line 271
  W[13] = ((((W[13] ^ W[15]) ^ W[5]) ^ W[10]) << 1) | ((((W[13] ^ W[15]) ^ W[5]) ^ W[10]) >> 31);
#line 271
  C += ((((D << 5) | (D >> 27)) + ((E ^ A) ^ B)) + W[13]) + 3395469782U;
#line 271
  E = (E << 30) | (E >> 2);
#line 271
  W[14] = ((((W[14] ^ W[0]) ^ W[6]) ^ W[11]) << 1) | ((((W[14] ^ W[0]) ^ W[6]) ^ W[11]) >> 31);
#line 271
  B += ((((C << 5) | (C >> 27)) + ((D ^ E) ^ A)) + W[14]) + 3395469782U;
#line 271
  D = (D << 30) | (D >> 2);
#line 271
  W[15] = ((((W[15] ^ W[1]) ^ W[7]) ^ W[12]) << 1) | ((((W[15] ^ W[1]) ^ W[7]) ^ W[12]) >> 31);
#line 271
  A += ((((B << 5) | (B >> 27)) + ((C ^ D) ^ E)) + W[15]) + 3395469782U;
#line 271
  C = (C << 30) | (C >> 2);
#line 273
  *(H + 0) += A;
#line 274
  *(H + 1) += B;
#line 275
  *(H + 2) += C;
#line 276
  *(H + 3) += D;
#line 277
  *(H + 4) += E;
  }
#line 278
  return;
}
}
#line 280 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libsha1.c"
void SHA1_Update(SHA1_ctx *ctx , void const   *pdata , size_t data_len ) 
{ 
  unsigned char const   *data ;
  unsigned int use ;
  unsigned int mlen ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 282
  data = (unsigned char const   *)pdata;
#line 283
  use = 0U;
#line 284
  mlen = 0U;
#line 292
  mlen = (unsigned int )((ctx->bits >> 3) % 64UL);
#line 293
  ctx->bits += data_len << 3;
#line 304
  if ((size_t )(64U - mlen) < data_len) {
#line 304
    tmp = (size_t )(64U - mlen);
  } else {
#line 304
    tmp = data_len;
  }
  {
#line 304
  use = (unsigned int )tmp;
#line 305
  memcpy((void */* __restrict  */)(ctx->M + mlen), (void const   */* __restrict  */)data,
         (size_t )use);
#line 306
  mlen += use;
#line 307
  data_len -= (size_t )use;
#line 308
  data += use;
  }
  {
#line 310
  while (1) {
    while_continue: /* CIL Label */ ;
#line 310
    if (! (mlen == 64U)) {
#line 310
      goto while_break;
    }
#line 311
    if ((int )*((char *)(& endian_test)) == 1) {
      {
#line 311
      swap_endian32((void *)((unsigned int *)(ctx->M)), (size_t )(64 >> 2));
      }
    }
    {
#line 312
    SHA1_Transform((unsigned int *)(ctx->H), (unsigned char const   *)(ctx->M));
    }
#line 313
    if (64UL < data_len) {
#line 313
      tmp___0 = (size_t )64;
    } else {
#line 313
      tmp___0 = data_len;
    }
    {
#line 313
    use = (unsigned int )tmp___0;
#line 314
    memcpy((void */* __restrict  */)(ctx->M), (void const   */* __restrict  */)data,
           (size_t )use);
#line 315
    mlen = use;
#line 316
    data_len -= (size_t )use;
#line 317
    data += use;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 319
  return;
}
}
#line 321 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libsha1.c"
void SHA1_Final(SHA1_ctx *ctx , unsigned char *digest ) 
{ 
  unsigned int mlen ;
  unsigned int padding ;
  unsigned long temp ;

  {
#line 323
  mlen = 0U;
#line 324
  padding = 0U;
#line 326
  temp = 0UL;
#line 330
  mlen = (unsigned int )((ctx->bits >> 3) % 64UL);
#line 335
  ctx->M[mlen] = (unsigned char)128;
#line 335
  mlen ++;
#line 336
  padding = 64U - mlen;
#line 341
  if ((unsigned long )padding >= 2UL * sizeof(unsigned int )) {
    {
#line 342
    memset((void *)(ctx->M + mlen), 0, (unsigned long )padding - 2UL * sizeof(unsigned int ));
    }
#line 343
    if ((int )*((char *)(& endian_test)) == 1) {
      {
#line 343
      swap_endian32((void *)(ctx->M), (size_t )((64 >> 2) - 2));
      }
    }
  } else {
    {
#line 345
    memset((void *)(ctx->M + mlen), 0, (size_t )(64U - mlen));
    }
#line 346
    if ((int )*((char *)(& endian_test)) == 1) {
      {
#line 346
      swap_endian32((void *)(ctx->M), (size_t )(64 >> 2));
      }
    }
    {
#line 347
    SHA1_Transform((unsigned int *)(ctx->H), (unsigned char const   *)(ctx->M));
#line 348
    memset((void *)(ctx->M), 0, 64UL - 2UL * sizeof(unsigned int ));
    }
  }
#line 352
  if ((int )*((char *)(& endian_test)) == 1) {
#line 353
    temp = (ctx->bits << 32) | (ctx->bits >> 32);
  } else {
#line 355
    temp = ctx->bits;
  }
  {
#line 357
  memcpy((void */* __restrict  */)((ctx->M + 64) - 2UL * sizeof(unsigned int )), (void const   */* __restrict  */)(& temp),
         2UL * sizeof(unsigned int ));
#line 363
  SHA1_Transform((unsigned int *)(ctx->H), (unsigned char const   *)(ctx->M));
#line 365
  memcpy((void */* __restrict  */)digest, (void const   */* __restrict  */)(ctx->H),
         (size_t )20);
  }
#line 366
  if ((int )*((char *)(& endian_test)) == 1) {
    {
#line 366
    swap_endian32((void *)digest, (size_t )5);
    }
  }
#line 367
  return;
}
}
#line 371 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libsha1.c"
static int swap_endian32(void *data , size_t len ) 
{ 
  unsigned int tmp32 ;
  unsigned char *tmp32_as_bytes ;
  unsigned int *data_as_word32s ;
  unsigned char *data_as_bytes ;
  size_t i ;

  {
#line 373
  tmp32 = 0U;
#line 374
  tmp32_as_bytes = (unsigned char *)(& tmp32);
#line 375
  data_as_word32s = (unsigned int *)data;
#line 376
  data_as_bytes = (unsigned char *)((void *)0);
#line 377
  i = (size_t )0;
#line 379
  i = (size_t )0;
  {
#line 379
  while (1) {
    while_continue: /* CIL Label */ ;
#line 379
    if (! (i < len)) {
#line 379
      goto while_break;
    }
#line 380
    tmp32 = *(data_as_word32s + i);
#line 381
    data_as_bytes = (unsigned char *)(data_as_word32s + i);
#line 383
    *(data_as_bytes + 0) = *(tmp32_as_bytes + 3);
#line 384
    *(data_as_bytes + 1) = *(tmp32_as_bytes + 2);
#line 385
    *(data_as_bytes + 2) = *(tmp32_as_bytes + 1);
#line 386
    *(data_as_bytes + 3) = *(tmp32_as_bytes + 0);
#line 379
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 388
  return (1);
}
}
#line 4 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/fastmint_altivec_standard_2.c"
int minter_altivec_standard_2_test(void) 
{ 


  {
#line 12
  return (0);
}
}
#line 315 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/fastmint_altivec_standard_2.c"
unsigned long minter_altivec_standard_2(int bits , int *best , unsigned char *block ,
                                        uInt32 const   *IV , int tailIndex , unsigned long maxIter ,
                                        int (*cb)(int percent , int largest , int target ,
                                                  double count , double expected ,
                                                  void *user ) , void *user_args ,
                                        double counter , double expected ) 
{ 


  {
#line 675
  return (0UL);
}
}
#line 8 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/fastmint_mmx_compact_1.c"
int minter_mmx_compact_1_test(void) 
{ 


  {
#line 16
  return (0);
}
}
#line 178 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/fastmint_mmx_compact_1.c"
unsigned long minter_mmx_compact_1(int bits , int *best , unsigned char *block , uInt32 const   *IV ,
                                   int tailIndex , unsigned long maxIter , int (*cb)(int percent ,
                                                                                     int largest ,
                                                                                     int target ,
                                                                                     double count ,
                                                                                     double expected ,
                                                                                     void *user ) ,
                                   void *user_args , double counter , double expected ) 
{ 


  {
#line 479
  return (0UL);
}
}
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 9 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/sha1.c"
int SHA1_file(char *filename , unsigned char *md ) 
{ 
  FILE *file ;
  unsigned char buffer[1024] ;
  unsigned int tmp ;
  size_t bytes_read ;
  int opened ;
  SHA1_ctx ctx ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 11
  file = (FILE *)((void *)0);
#line 12
  buffer[0] = (unsigned char)0;
#line 12
  tmp = 1U;
  {
#line 12
  while (1) {
    while_continue: /* CIL Label */ ;
#line 12
    if (tmp >= 1024U) {
#line 12
      goto while_break;
    }
#line 12
    buffer[tmp] = (unsigned char)0;
#line 12
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 13
  bytes_read = (size_t )0;
#line 14
  opened = 0;
#line 17
  tmp___0 = strcmp((char const   *)filename, "-");
  }
#line 17
  if (tmp___0 == 0) {
#line 18
    file = stdin;
  } else {
    {
#line 20
    file = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"rb");
    }
#line 21
    if ((unsigned long )file == (unsigned long )((FILE *)0)) {
#line 21
      return (-1);
    }
#line 22
    opened = 1;
  }
  {
#line 25
  SHA1_Init(& ctx);
  }
  {
#line 26
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 26
    tmp___2 = feof(file);
    }
#line 26
    if (tmp___2) {
#line 26
      goto while_break___0;
    }
    {
#line 27
    bytes_read = fread((void */* __restrict  */)(buffer), (size_t )1, (size_t )1024,
                       (FILE */* __restrict  */)file);
    }
#line 28
    if (bytes_read < 1024UL) {
      {
#line 28
      tmp___1 = ferror(file);
      }
#line 28
      if (tmp___1) {
#line 29
        return (-1);
      }
    }
    {
#line 31
    SHA1_Update(& ctx, (void const   *)(buffer), bytes_read);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 33
  SHA1_Final(& ctx, md);
  }
#line 34
  if (opened) {
    {
#line 35
    fclose(file);
    }
  }
#line 37
  return (0);
}
}
#line 43
char const   *hex_digest(unsigned char *md ) ;
#line 43 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/sha1.c"
static char hex[41]  = {      (char)0};
#line 40 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/sha1.c"
char const   *hex_digest(unsigned char *md ) 
{ 
  int i ;

  {
#line 42
  i = 0;
#line 45
  i = 0;
  {
#line 45
  while (1) {
    while_continue: /* CIL Label */ ;
#line 45
    if (! (i < 20)) {
#line 45
      goto while_break;
    }
    {
#line 46
    sprintf((char */* __restrict  */)(hex + 2 * i), (char const   */* __restrict  */)"%02x",
            (int )*(md + i));
#line 45
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 48
  hex[sizeof(hex) - 1UL] = (char )'\000';
#line 49
  return ((char const   *)(hex));
}
}
#line 21 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libsha1.c"
static int swap_endian32___0(void *data , size_t len ) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libsha1.c"
static int const   endian_test___0  =    (int const   )1;
#line 371 "/home/june/repo/benchmarks/collector/temp/hashcash-1.21/libsha1.c"
static int swap_endian32___0(void *data , size_t len ) 
{ 
  unsigned int tmp32 ;
  unsigned char *tmp32_as_bytes ;
  unsigned int *data_as_word32s ;
  unsigned char *data_as_bytes ;
  size_t i ;

  {
#line 373
  tmp32 = 0U;
#line 374
  tmp32_as_bytes = (unsigned char *)(& tmp32);
#line 375
  data_as_word32s = (unsigned int *)data;
#line 376
  data_as_bytes = (unsigned char *)((void *)0);
#line 377
  i = (size_t )0;
#line 379
  i = (size_t )0;
  {
#line 379
  while (1) {
    while_continue: /* CIL Label */ ;
#line 379
    if (! (i < len)) {
#line 379
      goto while_break;
    }
#line 380
    tmp32 = *(data_as_word32s + i);
#line 381
    data_as_bytes = (unsigned char *)(data_as_word32s + i);
#line 383
    *(data_as_bytes + 0) = *(tmp32_as_bytes + 3);
#line 384
    *(data_as_bytes + 1) = *(tmp32_as_bytes + 2);
#line 385
    *(data_as_bytes + 2) = *(tmp32_as_bytes + 1);
#line 386
    *(data_as_bytes + 3) = *(tmp32_as_bytes + 0);
#line 379
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 388
  return (1);
}
}
