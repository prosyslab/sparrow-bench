/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 48 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __suseconds_t suseconds_t;
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_10 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_10 fd_set;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 43 "/usr/include/x86_64-linux-gnu/bits/uio.h"
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 20 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 23 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 26 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 30 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 27 "/usr/include/asm-generic/posix_types.h"
typedef int __kernel_pid_t;
#line 64 "/usr/include/linux/connector.h"
struct cb_id {
   __u32 idx ;
   __u32 val ;
};
#line 69 "/usr/include/linux/connector.h"
struct cn_msg {
   struct cb_id id ;
   __u32 seq ;
   __u32 ack ;
   __u16 len ;
   __u16 flags ;
   __u8 data[0] ;
};
#line 11 "/usr/include/linux/socket.h"
typedef unsigned short __kernel_sa_family_t;
#line 35 "/usr/include/linux/netlink.h"
struct sockaddr_nl {
   __kernel_sa_family_t nl_family ;
   unsigned short nl_pad ;
   __u32 nl_pid ;
   __u32 nl_groups ;
};
#line 42 "/usr/include/linux/netlink.h"
struct nlmsghdr {
   __u32 nlmsg_len ;
   __u16 nlmsg_type ;
   __u16 nlmsg_flags ;
   __u32 nlmsg_seq ;
   __u32 nlmsg_pid ;
};
#line 27 "/usr/include/linux/cn_proc.h"
enum proc_cn_mcast_op {
    PROC_CN_MCAST_LISTEN = 1,
    PROC_CN_MCAST_IGNORE = 2
} ;
#line 45
enum what {
    PROC_EVENT_NONE = 0,
    PROC_EVENT_FORK = 1,
    PROC_EVENT_EXEC = 2,
    PROC_EVENT_UID = 4,
    PROC_EVENT_GID = 64,
    PROC_EVENT_SID = 128,
    PROC_EVENT_PTRACE = 256,
    PROC_EVENT_COMM = 512,
    PROC_EVENT_COREDUMP = 1073741824,
    PROC_EVENT_EXIT = 2147483648U
} ;
#line 45 "/usr/include/linux/cn_proc.h"
struct __anonstruct_ack_63 {
   __u32 err ;
};
#line 45 "/usr/include/linux/cn_proc.h"
struct fork_proc_event {
   __kernel_pid_t parent_pid ;
   __kernel_pid_t parent_tgid ;
   __kernel_pid_t child_pid ;
   __kernel_pid_t child_tgid ;
};
#line 45 "/usr/include/linux/cn_proc.h"
struct exec_proc_event {
   __kernel_pid_t process_pid ;
   __kernel_pid_t process_tgid ;
};
#line 45 "/usr/include/linux/cn_proc.h"
union __anonunion_r_64 {
   __u32 ruid ;
   __u32 rgid ;
};
#line 45 "/usr/include/linux/cn_proc.h"
union __anonunion_e_65 {
   __u32 euid ;
   __u32 egid ;
};
#line 45 "/usr/include/linux/cn_proc.h"
struct id_proc_event {
   __kernel_pid_t process_pid ;
   __kernel_pid_t process_tgid ;
   union __anonunion_r_64 r ;
   union __anonunion_e_65 e ;
};
#line 45 "/usr/include/linux/cn_proc.h"
struct sid_proc_event {
   __kernel_pid_t process_pid ;
   __kernel_pid_t process_tgid ;
};
#line 45 "/usr/include/linux/cn_proc.h"
struct ptrace_proc_event {
   __kernel_pid_t process_pid ;
   __kernel_pid_t process_tgid ;
   __kernel_pid_t tracer_pid ;
   __kernel_pid_t tracer_tgid ;
};
#line 45 "/usr/include/linux/cn_proc.h"
struct comm_proc_event {
   __kernel_pid_t process_pid ;
   __kernel_pid_t process_tgid ;
   char comm[16] ;
};
#line 45 "/usr/include/linux/cn_proc.h"
struct coredump_proc_event {
   __kernel_pid_t process_pid ;
   __kernel_pid_t process_tgid ;
};
#line 45 "/usr/include/linux/cn_proc.h"
struct exit_proc_event {
   __kernel_pid_t process_pid ;
   __kernel_pid_t process_tgid ;
   __u32 exit_code ;
   __u32 exit_signal ;
};
#line 45 "/usr/include/linux/cn_proc.h"
union __anonunion_event_data_62 {
   struct __anonstruct_ack_63 ack ;
   struct fork_proc_event fork ;
   struct exec_proc_event exec ;
   struct id_proc_event id ;
   struct sid_proc_event sid ;
   struct ptrace_proc_event ptrace ;
   struct comm_proc_event comm ;
   struct coredump_proc_event coredump ;
   struct exit_proc_event exit ;
};
#line 45 "/usr/include/linux/cn_proc.h"
struct proc_event {
   enum what what ;
   __u32 cpu ;
   __u64 __attribute__((__aligned__(8)))  timestamp_ns ;
   union __anonunion_event_data_62 event_data ;
};
#line 98 "/home/wheatley/newnew/temp/powerstat-0.01.30/powerstat.c"
struct __anonstruct_measurement_t_66 {
   double value ;
   time_t when ;
};
#line 98 "/home/wheatley/newnew/temp/powerstat-0.01.30/powerstat.c"
typedef struct __anonstruct_measurement_t_66 measurement_t;
#line 104 "/home/wheatley/newnew/temp/powerstat-0.01.30/powerstat.c"
struct __anonstruct_stats_t_67 {
   double value[15] ;
   _Bool inaccurate[15] ;
};
#line 104 "/home/wheatley/newnew/temp/powerstat-0.01.30/powerstat.c"
typedef struct __anonstruct_stats_t_67 stats_t;
#line 110 "/home/wheatley/newnew/temp/powerstat-0.01.30/powerstat.c"
struct __anonstruct_proc_info_t_68 {
   pid_t pid ;
   char *cmdline ;
};
#line 110 "/home/wheatley/newnew/temp/powerstat-0.01.30/powerstat.c"
typedef struct __anonstruct_proc_info_t_68 proc_info_t;
#line 116 "/home/wheatley/newnew/temp/powerstat-0.01.30/powerstat.c"
struct log_item_t {
   struct log_item_t *next ;
   char *text ;
};
#line 116 "/home/wheatley/newnew/temp/powerstat-0.01.30/powerstat.c"
typedef struct log_item_t log_item_t;
#line 122 "/home/wheatley/newnew/temp/powerstat-0.01.30/powerstat.c"
struct __anonstruct_log_t_69 {
   log_item_t *head ;
   log_item_t *tail ;
};
#line 122 "/home/wheatley/newnew/temp/powerstat-0.01.30/powerstat.c"
typedef struct __anonstruct_log_t_69 log_t;
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 144 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 214
extern  __attribute__((__nothrow__)) unsigned long long ( __attribute__((__nonnull__(1),
__leaf__)) strtoull)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                     int __base ) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 390
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 444
extern unsigned int sleep(unsigned int __seconds ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 678
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 779
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 347
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) siginterrupt)(int __sig ,
                                                                                   int __interrupt ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 156 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sqrt)(double __x ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 254
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime_r)(time_t const   * __restrict  __timer ,
                                                                                         struct tm * __restrict  __tp ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 50 "/usr/include/x86_64-linux-gnu/sys/uio.h"
extern ssize_t writev(int __fd , struct iovec  const  *__iovec , int __count ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 156
extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) ;
#line 127 "/home/wheatley/newnew/temp/powerstat-0.01.30/powerstat.c"
static proc_info_t *proc_info[32769]  ;
#line 128 "/home/wheatley/newnew/temp/powerstat-0.01.30/powerstat.c"
static int max_readings  ;
#line 129 "/home/wheatley/newnew/temp/powerstat-0.01.30/powerstat.c"
static int sample_delay  =    10;
#line 130 "/home/wheatley/newnew/temp/powerstat-0.01.30/powerstat.c"
static int start_delay  =    180;
#line 131 "/home/wheatley/newnew/temp/powerstat-0.01.30/powerstat.c"
static double idle_threshold  =    (double )98;
#line 132 "/home/wheatley/newnew/temp/powerstat-0.01.30/powerstat.c"
static log_t infolog  ;
#line 133 "/home/wheatley/newnew/temp/powerstat-0.01.30/powerstat.c"
static int opts  ;
#line 134 "/home/wheatley/newnew/temp/powerstat-0.01.30/powerstat.c"
static int volatile   stop_recv  ;
#line 135 "/home/wheatley/newnew/temp/powerstat-0.01.30/powerstat.c"
static _Bool power_calc_from_capacity  =    (_Bool)0;
#line 142 "/home/wheatley/newnew/temp/powerstat-0.01.30/powerstat.c"
static char *file_get(char const   * const  file ) 
{ 
  FILE *fp ;
  char buffer[4096] ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 147
  fp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"r");
  }
#line 147
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 148
    return ((char *)((void *)0));
  }
  {
#line 150
  tmp = fgets((char */* __restrict  */)(buffer), (int )sizeof(buffer), (FILE */* __restrict  */)fp);
  }
#line 150
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 151
    fclose(fp);
    }
#line 152
    return ((char *)((void *)0));
  }
  {
#line 155
  fclose(fp);
#line 157
  tmp___0 = strdup((char const   *)(buffer));
  }
#line 157
  return (tmp___0);
}
}
#line 164 "/home/wheatley/newnew/temp/powerstat-0.01.30/powerstat.c"
static int tty_height(void) 
{ 
  int fd ;
  struct winsize ws ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 167
  fd = 0;
#line 171
  tmp = isatty(fd);
  }
#line 171
  if (tmp) {
    {
#line 171
    tmp___0 = ioctl(fd, 21523UL, & ws);
    }
#line 171
    if (tmp___0 != -1) {
#line 171
      if (0 < (int )ws.ws_row) {
#line 171
        if ((size_t )ws.ws_row == (size_t )ws.ws_row) {
#line 175
          return ((int )ws.ws_row);
        }
      }
    }
  }
#line 177
  return (25);
}
}
#line 184 "/home/wheatley/newnew/temp/powerstat-0.01.30/powerstat.c"
static void time_now(char * const  buffer , size_t const   buflen ) 
{ 
  struct tm tm ;
  time_t now ;

  {
  {
#line 189
  time(& now);
#line 190
  localtime_r((time_t const   */* __restrict  */)(& now), (struct tm */* __restrict  */)(& tm));
#line 192
  snprintf((char */* __restrict  */)buffer, (size_t )buflen, (char const   */* __restrict  */)"%2.2d:%2.2d:%2.2d ",
           tm.tm_hour, tm.tm_min, tm.tm_sec);
  }
#line 194
  return;
}
}
#line 200 "/home/wheatley/newnew/temp/powerstat-0.01.30/powerstat.c"
__inline static void log_init(void) 
{ 


  {
#line 202
  infolog.head = (log_item_t *)((void *)0);
#line 203
  infolog.tail = (log_item_t *)((void *)0);
#line 204
  return;
}
}
#line 210 "/home/wheatley/newnew/temp/powerstat-0.01.30/powerstat.c"
static int log_printf(char const   * const  fmt  , ...) 
{ 
  char buffer[4096] ;
  char tmbuffer[10] ;
  va_list ap ;
  log_item_t *log_item ;
  size_t len ;
  void *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 218
  __builtin_va_start(ap, fmt);
#line 219
  time_now((char */* const  */)(tmbuffer), (size_t const   )sizeof(tmbuffer));
#line 220
  vsnprintf((char */* __restrict  */)(buffer), sizeof(buffer), (char const   */* __restrict  */)fmt,
            ap);
#line 221
  __builtin_va_end(ap);
#line 223
  tmp = calloc((size_t )1, sizeof(log_t ));
#line 223
  log_item = (log_item_t *)tmp;
  }
#line 223
  if ((unsigned long )log_item == (unsigned long )((void *)0)) {
    {
#line 224
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory allocating log item\n");
    }
#line 225
    return (-1);
  }
  {
#line 227
  tmp___0 = strlen((char const   *)(buffer));
#line 227
  tmp___1 = strlen((char const   *)(tmbuffer));
#line 227
  len = (tmp___0 + tmp___1) + 1UL;
#line 228
  tmp___2 = calloc((size_t )1, len);
#line 228
  log_item->text = (char *)tmp___2;
#line 229
  snprintf((char */* __restrict  */)log_item->text, len, (char const   */* __restrict  */)"%s%s",
           tmbuffer, buffer);
  }
#line 231
  if ((unsigned long )infolog.head == (unsigned long )((void *)0)) {
#line 232
    infolog.head = log_item;
  } else {
#line 234
    (infolog.tail)->next = log_item;
  }
#line 236
  infolog.tail = log_item;
#line 238
  return (0);
}
}
#line 245 "/home/wheatley/newnew/temp/powerstat-0.01.30/powerstat.c"
static void log_dump(void) 
{ 
  log_item_t *log_item ;

  {
#line 249
  if ((unsigned long )infolog.head != (unsigned long )((void *)0)) {
    {
#line 250
    printf((char const   */* __restrict  */)"\nLog of fork()/exec()/exit() calls:\n");
    }
  }
#line 252
  log_item = infolog.head;
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
#line 252
    if (! ((unsigned long )log_item != (unsigned long )((void *)0))) {
#line 252
      goto while_break;
    }
    {
#line 253
    printf((char const   */* __restrict  */)"%s", log_item->text);
#line 252
    log_item = log_item->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 254
  return;
}
}
#line 260 "/home/wheatley/newnew/temp/powerstat-0.01.30/powerstat.c"
static void log_free(void) 
{ 
  log_item_t *log_item ;
  log_item_t *log_next ;

  {
#line 262
  log_item = infolog.head;
  {
#line 264
  while (1) {
    while_continue: /* CIL Label */ ;
#line 264
    if (! ((unsigned long )log_item != (unsigned long )((void *)0))) {
#line 264
      goto while_break;
    }
    {
#line 265
    log_next = log_item->next;
#line 266
    free((void *)log_item->text);
#line 267
    free((void *)log_item);
#line 269
    log_item = log_next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 271
  infolog.head = (log_item_t *)((void *)0);
#line 272
  infolog.tail = (log_item_t *)((void *)0);
#line 273
  return;
}
}
#line 279 "/home/wheatley/newnew/temp/powerstat-0.01.30/powerstat.c"
static void handle_sigint(int dummy ) 
{ 


  {
#line 282
  stop_recv = (int volatile   )1;
#line 283
  return;
}
}
#line 289 "/home/wheatley/newnew/temp/powerstat-0.01.30/powerstat.c"
static int netlink_connect(void) 
{ 
  int sock ;
  struct sockaddr_nl addr ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  __pid_t tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 294
  sock = socket(16, 2, 11);
  }
#line 294
  if (sock < 0) {
    {
#line 295
    tmp = __errno_location();
    }
#line 295
    if (*tmp == 93) {
#line 296
      return (-93);
    }
    {
#line 297
    tmp___0 = __errno_location();
#line 297
    tmp___1 = strerror(*tmp___0);
#line 297
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Socket failed: %s\n",
            tmp___1);
    }
#line 298
    return (-1);
  }
  {
#line 301
  memset((void *)(& addr), 0, sizeof(addr));
#line 302
  tmp___2 = getpid();
#line 302
  addr.nl_pid = (__u32 )tmp___2;
#line 303
  addr.nl_family = (__kernel_sa_family_t )16;
#line 304
  addr.nl_groups = (__u32 )1;
#line 306
  tmp___5 = bind(sock, (struct sockaddr  const  *)((struct sockaddr *)(& addr)), (socklen_t )sizeof(addr));
  }
#line 306
  if (tmp___5 < 0) {
    {
#line 307
    tmp___3 = __errno_location();
#line 307
    tmp___4 = strerror(*tmp___3);
#line 307
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bind failed: %s\n",
            tmp___4);
#line 308
    close(sock);
    }
#line 309
    return (-1);
  }
#line 312
  return (sock);
}
}
#line 319 "/home/wheatley/newnew/temp/powerstat-0.01.30/powerstat.c"
static int netlink_listen(int const   sock ) 
{ 
  struct iovec iov[3] ;
  struct nlmsghdr nlmsghdr ;
  struct cn_msg cn_msg ;
  enum proc_cn_mcast_op op ;
  __pid_t tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 326
  memset((void *)(& nlmsghdr), 0, sizeof(nlmsghdr));
#line 327
  nlmsghdr.nlmsg_len = (__u32 )((sizeof(cn_msg) + sizeof(op)) + (unsigned long )((int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL)));
#line 328
  tmp = getpid();
#line 328
  nlmsghdr.nlmsg_pid = (__u32 )tmp;
#line 329
  nlmsghdr.nlmsg_type = (__u16 )3;
#line 330
  iov[0].iov_base = (void *)(& nlmsghdr);
#line 331
  iov[0].iov_len = sizeof(nlmsghdr);
#line 333
  memset((void *)(& cn_msg), 0, sizeof(cn_msg));
#line 334
  cn_msg.id.idx = (__u32 )1;
#line 335
  cn_msg.id.val = (__u32 )1;
#line 336
  cn_msg.len = (__u16 )sizeof(enum proc_cn_mcast_op );
#line 337
  iov[1].iov_base = (void *)(& cn_msg);
#line 338
  iov[1].iov_len = sizeof(cn_msg);
#line 340
  op = (enum proc_cn_mcast_op )1;
#line 341
  iov[2].iov_base = (void *)(& op);
#line 342
  iov[2].iov_len = sizeof(op);
#line 344
  tmp___0 = writev((int )sock, (struct iovec  const  *)(iov), 3);
  }
#line 344
  return ((int )tmp___0);
}
}
#line 351 "/home/wheatley/newnew/temp/powerstat-0.01.30/powerstat.c"
static void stats_clear(stats_t * const  stats ) 
{ 
  int i ;

  {
#line 355
  i = 0;
  {
#line 355
  while (1) {
    while_continue: /* CIL Label */ ;
#line 355
    if (! (i < 15)) {
#line 355
      goto while_break;
    }
#line 356
    stats->value[i] = 0.0;
#line 357
    stats->inaccurate[i] = (_Bool)0;
#line 355
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 359
  return;
}
}
#line 365 "/home/wheatley/newnew/temp/powerstat-0.01.30/powerstat.c"
static void stats_clear_all(stats_t * const  stats , int const   n ) 
{ 
  int i ;

  {
#line 369
  i = 0;
  {
#line 369
  while (1) {
    while_continue: /* CIL Label */ ;
#line 369
    if (! (i < (int )n)) {
#line 369
      goto while_break;
    }
    {
#line 370
    stats_clear((stats_t */* const  */)(stats + i));
#line 369
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 371
  return;
}
}
#line 377 "/home/wheatley/newnew/temp/powerstat-0.01.30/powerstat.c"
static int stats_read(stats_t * const  info ) 
{ 
  FILE *fp ;
  char buf[4096] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 382
  fp = fopen((char const   */* __restrict  */)"/proc/stat", (char const   */* __restrict  */)"r");
  }
#line 382
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 383
    return (-1);
  }
  {
#line 385
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 385
    tmp___4 = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)fp);
    }
#line 385
    if (! ((unsigned long )tmp___4 != (unsigned long )((void *)0))) {
#line 385
      goto while_break;
    }
    {
#line 386
    tmp = strncmp((char const   *)(buf), "cpu ", (size_t )4);
    }
#line 386
    if (tmp == 0) {
      {
#line 387
      sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%*s %15lf %15lf %15lf %15lf %15lf %15lf %15lf",
             & info->value[0], & info->value[1], & info->value[2], & info->value[3],
             & info->value[4], & info->value[5], & info->value[6]);
      }
    }
    {
#line 395
    tmp___0 = strncmp((char const   *)(buf), "ctxt ", (size_t )5);
    }
#line 395
    if (tmp___0 == 0) {
      {
#line 396
      sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%*s %15lf",
             & info->value[8]);
      }
    }
    {
#line 397
    tmp___1 = strncmp((char const   *)(buf), "intr ", (size_t )5);
    }
#line 397
    if (tmp___1 == 0) {
      {
#line 398
      sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%*s %15lf",
             & info->value[7]);
      }
    }
    {
#line 399
    tmp___2 = strncmp((char const   *)(buf), "procs_running ", (size_t )14);
    }
#line 399
    if (tmp___2 == 0) {
      {
#line 400
      sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%*s %15lf",
             & info->value[9]);
      }
    }
    {
#line 401
    tmp___3 = strncmp((char const   *)(buf), "procs_blocked ", (size_t )14);
    }
#line 401
    if (tmp___3 == 0) {
      {
#line 402
      sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%*s %15lf",
             & info->value[10]);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 404
  fclose(fp);
  }
#line 406
  return (0);
}
}
#line 420 "/home/wheatley/newnew/temp/powerstat-0.01.30/powerstat.c"
static _Bool stats_gather(stats_t const   * const  s1 , stats_t const   * const  s2 ,
                          stats_t * const  res ) 
{ 
  double total ;

  {
#line 427
  if (s2->value[0] - s1->value[0] < 0.0) {
#line 427
    res->value[0] = 0.0;
  } else {
#line 427
    res->value[0] = s2->value[0] - s1->value[0];
  }
#line 428
  if (s2->value[1] - s1->value[1] < 0.0) {
#line 428
    res->value[1] = 0.0;
  } else {
#line 428
    res->value[1] = s2->value[1] - s1->value[1];
  }
#line 429
  if (s2->value[2] - s1->value[2] < 0.0) {
#line 429
    res->value[2] = 0.0;
  } else {
#line 429
    res->value[2] = s2->value[2] - s1->value[2];
  }
#line 430
  if (s2->value[3] - s1->value[3] < 0.0) {
#line 430
    res->value[3] = 0.0;
  } else {
#line 430
    res->value[3] = s2->value[3] - s1->value[3];
  }
#line 431
  if (s2->value[4] - s1->value[4] < 0.0) {
#line 431
    res->value[4] = 0.0;
  } else {
#line 431
    res->value[4] = s2->value[4] - s1->value[4];
  }
#line 432
  if (s2->value[5] - s1->value[5] < 0.0) {
#line 432
    res->value[5] = 0.0;
  } else {
#line 432
    res->value[5] = s2->value[5] - s1->value[5];
  }
#line 433
  if (s2->value[6] - s1->value[6] < 0.0) {
#line 433
    res->value[6] = 0.0;
  } else {
#line 433
    res->value[6] = s2->value[6] - s1->value[6];
  }
#line 434
  if (s2->value[8] - s1->value[8] < 0.0) {
#line 434
    res->value[8] = 0.0;
  } else {
#line 434
    res->value[8] = s2->value[8] - s1->value[8];
  }
#line 435
  if (s2->value[7] - s1->value[7] < 0.0) {
#line 435
    res->value[7] = 0.0;
  } else {
#line 435
    res->value[7] = s2->value[7] - s1->value[7];
  }
#line 437
  total = (((res->value[0] + res->value[1]) + res->value[2]) + res->value[3]) + res->value[4];
#line 444
  if (total <= 0.0) {
#line 445
    return ((_Bool)0);
  }
#line 447
  res->value[0] = (100.0 * res->value[0]) / total;
#line 448
  res->value[1] = (100.0 * res->value[1]) / total;
#line 449
  res->value[2] = (100.0 * res->value[2]) / total;
#line 450
  res->value[3] = (100.0 * res->value[3]) / total;
#line 451
  res->value[4] = (100.0 * res->value[4]) / total;
#line 453
  res->value[8] /= (double )sample_delay;
#line 454
  res->value[7] /= (double )sample_delay;
#line 456
  res->value[9] = s2->value[9];
#line 457
  res->value[10] = s2->value[10];
#line 459
  return ((_Bool)1);
}
}
#line 466 "/home/wheatley/newnew/temp/powerstat-0.01.30/powerstat.c"
static void stats_headings(void) 
{ 


  {
#line 468
  if (opts & 19) {
    {
#line 469
    printf((char const   */* __restrict  */)"  Time    User  Nice   Sys  Idle    IO  Run Ctxt/s  IRQ/s Fork Exec Exit  Watts\n");
    }
  } else {
    {
#line 471
    printf((char const   */* __restrict  */)"  Time    User  Nice   Sys  Idle    IO  Run Ctxt/s  IRQ/s  Watts\n");
    }
  }
#line 472
  return;
}
}
#line 478 "/home/wheatley/newnew/temp/powerstat-0.01.30/powerstat.c"
static void stats_ruler(void) 
{ 


  {
#line 480
  if (opts & 19) {
    {
#line 481
    printf((char const   */* __restrict  */)"-------- ----- ----- ----- ----- ----- ---- ------ ------ ---- ---- ---- ------\n");
    }
  } else {
    {
#line 483
    printf((char const   */* __restrict  */)"-------- ----- ----- ----- ----- ----- ---- ------ ------ ------\n");
    }
  }
#line 484
  return;
}
}
#line 490 "/home/wheatley/newnew/temp/powerstat-0.01.30/powerstat.c"
static void row_increment(int * const  row ) 
{ 
  int tty_rows ;
  int tmp ;

  {
  {
#line 492
  tmp = tty_height();
#line 492
  tty_rows = tmp;
#line 494
  (*row) ++;
  }
#line 495
  if (tty_rows > 2) {
#line 495
    if (*row >= tty_rows) {
      {
#line 496
      stats_headings();
#line 497
      *row = 2;
      }
    }
  }
#line 499
  return;
}
}
#line 505 "/home/wheatley/newnew/temp/powerstat-0.01.30/powerstat.c"
static void stats_print(char const   * const  prefix , _Bool const   summary , stats_t const   * const  s ) 
{ 
  char buf[10] ;
  char const   *tmp ;
  char *fmt ;
  char const   *tmp___0 ;
  char *fmt___0 ;
  char const   *tmp___1 ;

  {
#line 512
  if (summary) {
#line 513
    if (s->inaccurate[11]) {
      {
#line 514
      snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"-N/A-");
      }
    } else {
      {
#line 516
      snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%6.2f",
               s->value[11]);
      }
    }
  } else {
#line 518
    if (s->inaccurate[11]) {
#line 518
      tmp = "E";
    } else {
#line 518
      tmp = "";
    }
    {
#line 518
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%6.2f%s",
             s->value[11], tmp);
    }
  }
#line 522
  if (opts & 19) {
#line 523
    if (summary) {
#line 523
      tmp___0 = "%8.8s %5.1f %5.1f %5.1f %5.1f %5.1f %4.1f %6.1f %6.1f %4.1f %4.1f %4.1f %s\n";
    } else {
#line 523
      tmp___0 = "%8.8s %5.1f %5.1f %5.1f %5.1f %5.1f %4.0f %6.0f %6.0f %4.0f %4.0f %4.0f %s\n";
    }
    {
#line 523
    fmt = (char *)tmp___0;
#line 526
    printf((char const   */* __restrict  */)fmt, prefix, s->value[0], s->value[1],
           s->value[2], s->value[3], s->value[4], s->value[9], s->value[8], s->value[7],
           s->value[12], s->value[13], s->value[14], buf);
    }
  } else {
#line 535
    if (summary) {
#line 535
      tmp___1 = "%8.8s %5.1f %5.1f %5.1f %5.1f %5.1f %4.1f %6.1f %6.1f %s\n";
    } else {
#line 535
      tmp___1 = "%8.8s %5.1f %5.1f %5.1f %5.1f %5.1f %4.0f %6.0f %6.0f %s\n";
    }
    {
#line 535
    fmt___0 = (char *)tmp___1;
#line 538
    printf((char const   */* __restrict  */)fmt___0, prefix, s->value[0], s->value[1],
           s->value[2], s->value[3], s->value[4], s->value[9], s->value[8], s->value[7],
           buf);
    }
  }
#line 546
  return;
}
}
#line 552 "/home/wheatley/newnew/temp/powerstat-0.01.30/powerstat.c"
static void stats_average_stddev_min_max(stats_t const   * const  stats , int const   num ,
                                         stats_t * const  average , stats_t * const  stddev ,
                                         stats_t * const  min , stats_t * const  max ) 
{ 
  int i ;
  int j ;
  int valid ;
  double total ;
  double diff ;

  {
#line 562
  j = 0;
  {
#line 562
  while (1) {
    while_continue: /* CIL Label */ ;
#line 562
    if (! (j < 15)) {
#line 562
      goto while_break;
    }
#line 563
    total = 0.0;
#line 565
    max->value[j] = - 1E6;
#line 566
    min->value[j] = 1E6;
#line 568
    valid = 0;
#line 568
    i = 0;
    {
#line 568
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 568
      if (! (i < (int )num)) {
#line 568
        goto while_break___0;
      }
#line 569
      if (! (stats + i)->inaccurate[j]) {
#line 570
        if ((stats + i)->value[j] > max->value[j]) {
#line 571
          max->value[j] = (stats + i)->value[j];
        }
#line 572
        if ((stats + i)->value[j] < min->value[j]) {
#line 573
          min->value[j] = (stats + i)->value[j];
        }
#line 574
        total += (stats + i)->value[j];
#line 575
        valid ++;
      }
#line 568
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 579
    if (valid) {
#line 580
      average->value[j] = total / (double )valid;
#line 581
      total = 0.0;
#line 582
      i = 0;
      {
#line 582
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 582
        if (! (i < (int )num)) {
#line 582
          goto while_break___1;
        }
#line 583
        if (! (stats + i)->inaccurate[j]) {
#line 584
          diff = (stats + i)->value[j] - average->value[j];
#line 585
          diff *= diff;
#line 586
          total += diff;
        }
#line 582
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 589
      stddev->value[j] = total / (double )num;
#line 590
      stddev->value[j] = sqrt(stddev->value[j]);
      }
    } else {
#line 592
      average->inaccurate[j] = (_Bool)1;
#line 593
      max->inaccurate[j] = (_Bool)1;
#line 594
      min->inaccurate[j] = (_Bool)1;
#line 595
      stddev->inaccurate[j] = (_Bool)1;
#line 597
      average->value[j] = 0.0;
#line 598
      max->value[j] = 0.0;
#line 599
      min->value[j] = 0.0;
#line 600
      stddev->value[j] = 0.0;
    }
#line 562
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 603
  return;
}
}
#line 615
static void calc_standard_average(double total_capacity , double * const  rate , _Bool * const  inaccurate ) ;
#line 615 "/home/wheatley/newnew/temp/powerstat-0.01.30/powerstat.c"
static time_t time_start  =    (time_t )0;
#line 616
static void calc_standard_average(double total_capacity , double * const  rate , _Bool * const  inaccurate ) ;
#line 616 "/home/wheatley/newnew/temp/powerstat-0.01.30/powerstat.c"
static double total_capacity_start  =    0.0;
#line 617
static void calc_standard_average(double total_capacity , double * const  rate , _Bool * const  inaccurate ) ;
#line 617 "/home/wheatley/newnew/temp/powerstat-0.01.30/powerstat.c"
static _Bool first  =    (_Bool)1;
#line 610 "/home/wheatley/newnew/temp/powerstat-0.01.30/powerstat.c"
static void calc_standard_average(double total_capacity , double * const  rate , _Bool * const  inaccurate ) 
{ 
  time_t time_now___0 ;
  time_t dt ;
  double dw ;

  {
  {
#line 621
  time_now___0 = time((time_t *)((void *)0));
  }
#line 623
  if (first) {
#line 624
    time_start = time_now___0;
#line 625
    total_capacity_start = total_capacity;
#line 626
    first = (_Bool)0;
#line 627
    *rate = 0.0;
#line 628
    *inaccurate = (_Bool)1;
#line 629
    return;
  }
#line 632
  dt = time_now___0 - time_start;
#line 633
  dw = total_capacity_start - total_capacity;
#line 634
  if (dt <= 0L) {
#line 636
    *rate = 0.0;
#line 637
    *inaccurate = (_Bool)1;
#line 638
    return;
  } else
#line 634
  if (dw <= 0.0) {
#line 636
    *rate = 0.0;
#line 637
    *inaccurate = (_Bool)1;
#line 638
    return;
  }
#line 641
  *rate = (3600.0 * dw) / (double )dt;
#line 643
  *inaccurate = (_Bool )(dt < 120L);
#line 644
  return;
}
}
#line 660
static void calc_rolling_average(double total_capacity , double * const  rate , _Bool * const  inaccurate ) ;
#line 660 "/home/wheatley/newnew/temp/powerstat-0.01.30/powerstat.c"
static int index___0  =    0;
#line 662 "/home/wheatley/newnew/temp/powerstat-0.01.30/powerstat.c"
static measurement_t measurements[130]  ;
#line 655 "/home/wheatley/newnew/temp/powerstat-0.01.30/powerstat.c"
static void calc_rolling_average(double total_capacity , double * const  rate , _Bool * const  inaccurate ) 
{ 
  time_t time_now___0 ;
  time_t dt ;
  int i ;
  int j ;
  double dw ;

  {
  {
#line 665
  time_now___0 = time((time_t *)((void *)0));
#line 666
  measurements[index___0].value = total_capacity;
#line 667
  measurements[index___0].when = time_now___0;
#line 668
  index___0 = (index___0 + 1) % 130;
#line 669
  *rate = 0.0;
#line 676
  j = index___0;
#line 676
  i = 0;
  }
  {
#line 676
  while (1) {
    while_continue: /* CIL Label */ ;
#line 676
    if (! (i < 130)) {
#line 676
      goto while_break;
    }
#line 677
    j --;
#line 678
    if (j < 0) {
#line 679
      j += 130;
    }
#line 681
    if (measurements[j].when) {
#line 682
      dw = measurements[j].value - total_capacity;
#line 683
      dt = time_now___0 - measurements[j].when;
#line 684
      *rate = (3600.0 * dw) / (double )dt;
#line 686
      if (time_now___0 - measurements[j].when > 120L) {
#line 687
        *inaccurate = (_Bool)0;
#line 688
        goto while_break;
      }
    }
#line 676
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 697
  if (*rate < 0.0) {
#line 698
    *rate = 0.0;
#line 699
    *inaccurate = (_Bool)1;
  }
#line 701
  return;
}
}
#line 704 "/home/wheatley/newnew/temp/powerstat-0.01.30/powerstat.c"
static void calc_from_capacity(double total_capacity , double * const  rate , _Bool * const  inaccurate ) 
{ 


  {
#line 709
  power_calc_from_capacity = (_Bool)1;
#line 711
  if (opts & 32) {
    {
#line 712
    calc_standard_average(total_capacity, rate, inaccurate);
    }
  } else {
    {
#line 714
    calc_rolling_average(total_capacity, rate, inaccurate);
    }
  }
#line 715
  return;
}
}
#line 721 "/home/wheatley/newnew/temp/powerstat-0.01.30/powerstat.c"
static int power_rate_get_sys_fs(double * const  rate , _Bool * const  discharging ,
                                 _Bool * const  inaccurate ) 
{ 
  DIR *dir ;
  struct dirent *dirent ;
  double total_watts ;
  double total_capacity ;
  char path[4096] ;
  char *data ;
  int val ;
  FILE *fp ;
  _Bool mismatch ;
  char *tmp ;
  char buffer[4096] ;
  double voltage ;
  double amps_rate ;
  double amps_left ;
  double watts_rate ;
  double watts_left ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  char *tmp___7 ;
  size_t tmp___8 ;
  char *tmp___9 ;
  size_t tmp___10 ;
  char *tmp___11 ;
  size_t tmp___12 ;

  {
  {
#line 728
  total_watts = 0.0;
#line 728
  total_capacity = 0.0;
#line 730
  *rate = 0.0;
#line 731
  *discharging = (_Bool)0;
#line 732
  *inaccurate = (_Bool)1;
#line 734
  dir = opendir("/sys/class/power_supply");
  }
#line 734
  if ((unsigned long )dir == (unsigned long )((void *)0)) {
    {
#line 735
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Machine does not have %s, cannot run the test.\n",
            "/sys/class/power_supply");
    }
#line 736
    return (-1);
  }
  {
#line 739
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 740
    dirent = readdir(dir);
    }
#line 741
    if (dirent) {
      {
#line 741
      tmp___12 = strlen((char const   *)(dirent->d_name));
      }
#line 741
      if (tmp___12 > 2UL) {
        {
#line 748
        snprintf((char */* __restrict  */)(path), sizeof(path), (char const   */* __restrict  */)"%s/%s/type",
                 "/sys/class/power_supply", dirent->d_name);
#line 749
        data = file_get((char const   */* const  */)(path));
        }
#line 749
        if ((unsigned long )data != (unsigned long )((void *)0)) {
          {
#line 750
          tmp = strstr((char const   *)data, "Battery");
#line 750
          mismatch = (_Bool )((unsigned long )tmp == (unsigned long )((void *)0));
#line 751
          free((void *)data);
          }
#line 752
          if (mismatch) {
#line 753
            goto __Cont;
          }
        } else {
#line 755
          goto __Cont;
        }
        {
#line 757
        snprintf((char */* __restrict  */)(path), sizeof(path), (char const   */* __restrict  */)"%s/%s/uevent",
                 "/sys/class/power_supply", dirent->d_name);
#line 758
        fp = fopen((char const   */* __restrict  */)(path), (char const   */* __restrict  */)"r");
        }
#line 758
        if ((unsigned long )fp == (unsigned long )((void *)0)) {
          {
#line 759
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Battery %s present but under supported - no state present.",
                  dirent->d_name);
#line 760
          closedir(dir);
          }
#line 761
          return (-1);
        } else {
#line 764
          voltage = 0.0;
#line 765
          amps_rate = 0.0;
#line 766
          amps_left = 0.0;
#line 767
          watts_rate = 0.0;
#line 768
          watts_left = 0.0;
          {
#line 770
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 770
            tmp___11 = fgets((char */* __restrict  */)(buffer), (int )(sizeof(buffer) - 1UL),
                             (FILE */* __restrict  */)fp);
            }
#line 770
            if (! ((unsigned long )tmp___11 != (unsigned long )((void *)0))) {
#line 770
              goto while_break___0;
            }
            {
#line 771
            tmp___0 = strstr((char const   *)(buffer), "POWER_SUPPLY_STATUS=Discharging");
            }
#line 771
            if (tmp___0) {
#line 772
              *discharging = (_Bool)1;
            }
            {
#line 774
            tmp___1 = strstr((char const   *)(buffer), "POWER_SUPPLY_CHARGE_NOW=");
            }
#line 774
            if (tmp___1) {
              {
#line 774
              tmp___2 = strlen((char const   *)(buffer));
              }
#line 774
              if (tmp___2 > sizeof("POWER_SUPPLY_CHARGE_NOW=") - 1UL) {
                {
#line 776
                sscanf((char const   */* __restrict  */)((buffer + sizeof("POWER_SUPPLY_CHARGE_NOW=")) - 1),
                       (char const   */* __restrict  */)"%12d", & val);
#line 777
                amps_left = (double )val / 1000000.0;
                }
              }
            }
            {
#line 780
            tmp___3 = strstr((char const   *)(buffer), "POWER_SUPPLY_ENERGY_NOW=");
            }
#line 780
            if (tmp___3) {
              {
#line 780
              tmp___4 = strlen((char const   *)(buffer));
              }
#line 780
              if (tmp___4 > sizeof("POWER_SUPPLY_ENERGY_NOW=") - 1UL) {
                {
#line 782
                sscanf((char const   */* __restrict  */)((buffer + sizeof("POWER_SUPPLY_ENERGY_NOW=")) - 1),
                       (char const   */* __restrict  */)"%12d", & val);
#line 783
                watts_left = (double )val / 1000000.0;
                }
              }
            }
            {
#line 786
            tmp___5 = strstr((char const   *)(buffer), "POWER_SUPPLY_CURRENT_NOW=");
            }
#line 786
            if (tmp___5) {
              {
#line 786
              tmp___6 = strlen((char const   *)(buffer));
              }
#line 786
              if (tmp___6 > sizeof("POWER_SUPPLY_CURRENT_NOW=") - 1UL) {
                {
#line 788
                sscanf((char const   */* __restrict  */)((buffer + sizeof("POWER_SUPPLY_CURRENT_NOW=")) - 1),
                       (char const   */* __restrict  */)"%12d", & val);
#line 789
                amps_rate = (double )val / 1000000.0;
                }
              }
            }
            {
#line 792
            tmp___7 = strstr((char const   *)(buffer), "POWER_SUPPLY_POWER_NOW=");
            }
#line 792
            if (tmp___7) {
              {
#line 792
              tmp___8 = strlen((char const   *)(buffer));
              }
#line 792
              if (tmp___8 > sizeof("POWER_SUPPLY_POWER_NOW=") - 1UL) {
                {
#line 794
                sscanf((char const   */* __restrict  */)((buffer + sizeof("POWER_SUPPLY_POWER_NOW=")) - 1),
                       (char const   */* __restrict  */)"%12d", & val);
#line 795
                watts_rate = (double )val / 1000000.0;
                }
              }
            }
            {
#line 798
            tmp___9 = strstr((char const   *)(buffer), "POWER_SUPPLY_VOLTAGE_NOW=");
            }
#line 798
            if (tmp___9) {
              {
#line 798
              tmp___10 = strlen((char const   *)(buffer));
              }
#line 798
              if (tmp___10 > sizeof("POWER_SUPPLY_VOLTAGE_NOW=") - 1UL) {
                {
#line 800
                sscanf((char const   */* __restrict  */)((buffer + sizeof("POWER_SUPPLY_VOLTAGE_NOW=")) - 1),
                       (char const   */* __restrict  */)"%12d", & val);
#line 801
                voltage = (double )val / 1000000.0;
                }
              }
            }
          }
          while_break___0: /* CIL Label */ ;
          }
          {
#line 804
          total_watts += watts_rate + voltage * amps_rate;
#line 805
          total_capacity += watts_left + voltage * amps_left;
#line 806
          fclose(fp);
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 739
    if (! dirent) {
#line 739
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 811
  closedir(dir);
  }
#line 813
  if (! *discharging) {
    {
#line 814
    printf((char const   */* __restrict  */)"Machine is not discharging, cannot measure power usage.\n");
    }
#line 815
    return (-1);
  }
#line 823
  if (total_watts > 0.001) {
#line 824
    *rate = total_watts;
#line 825
    *inaccurate = (_Bool )(total_watts < 0.0);
#line 826
    return (0);
  }
  {
#line 830
  calc_from_capacity(total_capacity, rate, inaccurate);
  }
#line 831
  return (0);
}
}
#line 838 "/home/wheatley/newnew/temp/powerstat-0.01.30/powerstat.c"
static int power_rate_get_proc_acpi(double * const  rate , _Bool * const  discharging ,
                                    _Bool * const  inaccurate ) 
{ 
  DIR *dir ;
  FILE *file ;
  struct dirent *dirent ;
  char filename[4096] ;
  double total_watts ;
  double total_capacity ;
  double voltage ;
  double amps_rate ;
  double amps_left ;
  double watts_rate ;
  double watts_left ;
  char buffer[4096] ;
  char *ptr ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  unsigned long long tmp___5 ;
  char *tmp___6 ;
  unsigned long long tmp___7 ;
  char *tmp___8 ;
  unsigned long long tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  unsigned long long tmp___12 ;
  char *tmp___13 ;
  unsigned long long tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  unsigned long long tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;

  {
  {
#line 847
  total_watts = 0.0;
#line 847
  total_capacity = 0.0;
#line 849
  *rate = 0.0;
#line 850
  *discharging = (_Bool)0;
#line 851
  *inaccurate = (_Bool)1;
#line 853
  dir = opendir("/proc/acpi/battery");
  }
#line 853
  if ((unsigned long )dir == (unsigned long )((void *)0)) {
    {
#line 854
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Machine does not have %s, cannot run the test.\n",
            "/proc/acpi/battery");
    }
#line 855
    return (-1);
  }
  {
#line 858
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 858
    dirent = readdir(dir);
    }
#line 858
    if (! dirent) {
#line 858
      goto while_break;
    }
    {
#line 859
    voltage = 0.0;
#line 861
    amps_rate = 0.0;
#line 862
    amps_left = 0.0;
#line 864
    watts_rate = 0.0;
#line 865
    watts_left = 0.0;
#line 870
    tmp = strlen((char const   *)(dirent->d_name));
    }
#line 870
    if (tmp < 3UL) {
#line 871
      goto while_continue;
    }
    {
#line 873
    sprintf((char */* __restrict  */)(filename), (char const   */* __restrict  */)"/proc/acpi/battery/%s/state",
            dirent->d_name);
#line 874
    file = fopen((char const   */* __restrict  */)(filename), (char const   */* __restrict  */)"r");
    }
#line 874
    if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 875
      goto while_continue;
    }
    {
#line 877
    memset((void *)(buffer), 0, sizeof(buffer));
    }
    {
#line 878
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 878
      tmp___17 = fgets((char */* __restrict  */)(buffer), (int )sizeof(buffer), (FILE */* __restrict  */)file);
      }
#line 878
      if (! ((unsigned long )tmp___17 != (unsigned long )((void *)0))) {
#line 878
        goto while_break___0;
      }
      {
#line 879
      tmp___0 = strstr((char const   *)(buffer), "present:");
      }
#line 879
      if (tmp___0) {
        {
#line 879
        tmp___1 = strstr((char const   *)(buffer), "no");
        }
#line 879
        if (tmp___1) {
#line 881
          goto while_break___0;
        }
      }
      {
#line 883
      tmp___2 = strstr((char const   *)(buffer), "charging state:");
      }
#line 883
      if (tmp___2) {
        {
#line 883
        tmp___3 = strstr((char const   *)(buffer), "discharging");
        }
#line 883
        if (tmp___3) {
#line 885
          *discharging = (_Bool)1;
        } else {
          {
#line 883
          tmp___4 = strstr((char const   *)(buffer), "critical");
          }
#line 883
          if (tmp___4) {
#line 885
            *discharging = (_Bool)1;
          }
        }
      }
      {
#line 887
      ptr = strchr((char const   *)(buffer), ':');
      }
#line 888
      if (ptr) {
        {
#line 889
        ptr ++;
#line 890
        tmp___6 = strstr((char const   *)(buffer), "present voltage");
        }
#line 890
        if (tmp___6) {
          {
#line 891
          tmp___5 = strtoull((char const   */* __restrict  */)ptr, (char **/* __restrict  */)((void *)0),
                             10);
#line 891
          voltage = (double )tmp___5 / 1000.0;
          }
        }
        {
#line 893
        tmp___11 = strstr((char const   *)(buffer), "present rate");
        }
#line 893
        if (tmp___11) {
          {
#line 894
          tmp___8 = strstr((char const   *)ptr, "mW");
          }
#line 894
          if (tmp___8) {
            {
#line 895
            tmp___7 = strtoull((char const   */* __restrict  */)ptr, (char **/* __restrict  */)((void *)0),
                               10);
#line 895
            watts_rate = (double )tmp___7 / 1000.0;
            }
          }
          {
#line 896
          tmp___10 = strstr((char const   *)ptr, "mA");
          }
#line 896
          if (tmp___10) {
            {
#line 897
            tmp___9 = strtoull((char const   */* __restrict  */)ptr, (char **/* __restrict  */)((void *)0),
                               10);
#line 897
            amps_rate = (double )tmp___9 / 1000.0;
            }
          }
        }
        {
#line 900
        tmp___16 = strstr((char const   *)(buffer), "remaining capacity");
        }
#line 900
        if (tmp___16) {
          {
#line 901
          tmp___13 = strstr((char const   *)ptr, "mW");
          }
#line 901
          if (tmp___13) {
            {
#line 902
            tmp___12 = strtoull((char const   */* __restrict  */)ptr, (char **/* __restrict  */)((void *)0),
                                10);
#line 902
            watts_left = (double )tmp___12 / 1000.0;
            }
          }
          {
#line 903
          tmp___15 = strstr((char const   *)ptr, "mA");
          }
#line 903
          if (tmp___15) {
            {
#line 904
            tmp___14 = strtoull((char const   */* __restrict  */)ptr, (char **/* __restrict  */)((void *)0),
                                10);
#line 904
            amps_left = (double )tmp___14 / 1000.0;
            }
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 908
    fclose(file);
    }
#line 915
    if (voltage == 0.0) {
      {
#line 916
      sprintf((char */* __restrict  */)(filename), (char const   */* __restrict  */)"/proc/acpi/battery/%s/info",
              dirent->d_name);
#line 917
      file = fopen((char const   */* __restrict  */)(filename), (char const   */* __restrict  */)"r");
      }
#line 917
      if ((unsigned long )file != (unsigned long )((void *)0)) {
        {
#line 918
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 918
          tmp___20 = fgets((char */* __restrict  */)(buffer), (int )sizeof(buffer),
                           (FILE */* __restrict  */)file);
          }
#line 918
          if (! ((unsigned long )tmp___20 != (unsigned long )((void *)0))) {
#line 918
            goto while_break___1;
          }
          {
#line 919
          ptr = strchr((char const   *)(buffer), ':');
          }
#line 920
          if (ptr) {
            {
#line 921
            ptr ++;
#line 922
            tmp___19 = strstr((char const   *)(buffer), "design voltage:");
            }
#line 922
            if (tmp___19) {
              {
#line 923
              tmp___18 = strtoull((char const   */* __restrict  */)ptr, (char **/* __restrict  */)((void *)0),
                                  10);
#line 923
              voltage = (double )tmp___18 / 1000.0;
              }
#line 924
              goto while_break___1;
            }
          }
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 928
        fclose(file);
        }
      }
    }
#line 932
    total_watts += watts_rate + voltage * amps_rate;
#line 933
    total_capacity += watts_left + voltage * amps_left;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 935
  closedir(dir);
  }
#line 937
  if (! *discharging) {
    {
#line 938
    printf((char const   */* __restrict  */)"Machine is indicating it is not discharging and hence we cannot measure power usage.\n");
    }
#line 940
    return (-1);
  }
#line 949
  if (total_watts > 0.001) {
#line 950
    *rate = total_watts;
#line 951
    *inaccurate = (_Bool )(total_watts < 0.0);
#line 952
    return (0);
  }
  {
#line 956
  calc_from_capacity(total_capacity, rate, inaccurate);
  }
#line 957
  return (0);
}
}
#line 960 "/home/wheatley/newnew/temp/powerstat-0.01.30/powerstat.c"
static int power_rate_get(double * const  rate , _Bool * const  discharging , _Bool * const  inaccurate ) 
{ 
  struct stat buf ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 967
  tmp___0 = stat((char const   */* __restrict  */)"/sys/class/power_supply", (struct stat */* __restrict  */)(& buf));
  }
#line 967
  if (tmp___0 != -1) {
#line 967
    if ((buf.st_mode & 61440U) == 16384U) {
      {
#line 969
      tmp = power_rate_get_sys_fs(rate, discharging, inaccurate);
      }
#line 969
      return (tmp);
    }
  }
  {
#line 971
  tmp___2 = stat((char const   */* __restrict  */)"/proc/acpi/battery", (struct stat */* __restrict  */)(& buf));
  }
#line 971
  if (tmp___2 != -1) {
#line 971
    if ((buf.st_mode & 61440U) == 16384U) {
      {
#line 973
      tmp___1 = power_rate_get_proc_acpi(rate, discharging, inaccurate);
      }
#line 973
      return (tmp___1);
    }
  }
  {
#line 975
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Machine does not seem to have a battery, cannot measure power.\n");
  }
#line 976
  return (-1);
}
}
#line 983 "/home/wheatley/newnew/temp/powerstat-0.01.30/powerstat.c"
__inline static int proc_info_hash(pid_t const   pid ) 
{ 


  {
#line 985
  return ((int )(pid % 32769));
}
}
#line 992 "/home/wheatley/newnew/temp/powerstat-0.01.30/powerstat.c"
static int proc_cmdline(pid_t const   pid , char * const  cmdline , size_t const   size ) 
{ 
  FILE *fp ;
  char path[4096] ;
  int n ;
  size_t tmp ;

  {
  {
#line 999
  n = 0;
#line 1001
  *cmdline = (char )'\000';
#line 1002
  snprintf((char */* __restrict  */)(path), sizeof(path), (char const   */* __restrict  */)"/proc/%d/cmdline",
           pid);
#line 1003
  fp = fopen((char const   */* __restrict  */)(path), (char const   */* __restrict  */)"r");
  }
#line 1003
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    {
#line 1004
    tmp = fread((void */* __restrict  */)cmdline, (size_t )size, (size_t )1, (FILE */* __restrict  */)fp);
#line 1004
    n = (int )tmp;
#line 1005
    fclose(fp);
    }
  }
#line 1007
  return (n);
}
}
#line 1014 "/home/wheatley/newnew/temp/powerstat-0.01.30/powerstat.c"
static char *proc_info_get(pid_t const   pid ) 
{ 
  int i ;
  int tmp ;
  int j ;

  {
  {
#line 1016
  tmp = proc_info_hash(pid);
#line 1016
  i = tmp;
#line 1018
  j = 0;
  }
  {
#line 1018
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1018
    if (! (j < 32769)) {
#line 1018
      goto while_break;
    }
#line 1019
    if ((unsigned long )proc_info[i] != (unsigned long )((void *)0)) {
#line 1019
      if ((proc_info[i])->pid == (pid_t )pid) {
#line 1020
        return ((proc_info[i])->cmdline);
      }
    }
#line 1018
    j ++;
#line 1018
    i = (i + 1) % 32769;
  }
  while_break: /* CIL Label */ ;
  }
#line 1022
  return ((char *)"<unknown>");
}
}
#line 1029 "/home/wheatley/newnew/temp/powerstat-0.01.30/powerstat.c"
static void proc_info_free(pid_t const   pid ) 
{ 
  int i ;
  int tmp ;
  int j ;

  {
  {
#line 1031
  tmp = proc_info_hash(pid);
#line 1031
  i = tmp;
#line 1033
  j = 0;
  }
  {
#line 1033
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1033
    if (! (j < 32769)) {
#line 1033
      goto while_break;
    }
#line 1034
    if ((unsigned long )proc_info[i] != (unsigned long )((void *)0)) {
#line 1034
      if ((proc_info[i])->pid == (pid_t )pid) {
        {
#line 1035
        free((void *)(proc_info[i])->cmdline);
#line 1036
        free((void *)proc_info[i]);
#line 1037
        proc_info[i] = (proc_info_t *)((void *)0);
        }
#line 1038
        return;
      }
    }
#line 1033
    j ++;
#line 1033
    i = (i + 1) % 32769;
  }
  while_break: /* CIL Label */ ;
  }
#line 1041
  return;
}
}
#line 1047 "/home/wheatley/newnew/temp/powerstat-0.01.30/powerstat.c"
static void proc_info_unload(void) 
{ 
  int i ;

  {
#line 1051
  i = 0;
  {
#line 1051
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1051
    if (! (i < 32769)) {
#line 1051
      goto while_break;
    }
#line 1052
    if ((unsigned long )proc_info[i] != (unsigned long )((void *)0)) {
      {
#line 1053
      free((void *)(proc_info[i])->cmdline);
#line 1054
      free((void *)proc_info[i]);
#line 1055
      proc_info[i] = (proc_info_t *)((void *)0);
      }
    }
#line 1051
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1058
  return;
}
}
#line 1064 "/home/wheatley/newnew/temp/powerstat-0.01.30/powerstat.c"
static int proc_info_add(pid_t const   pid ) 
{ 
  int i ;
  int j ;
  proc_info_t *info ;
  char path[4096] ;
  char cmdline[1024] ;
  _Bool free_slot ;
  void *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 1070
  free_slot = (_Bool)0;
#line 1072
  i = proc_info_hash(pid);
#line 1073
  j = 0;
  }
  {
#line 1073
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1073
    if (! (j < 32769)) {
#line 1073
      goto while_break;
    }
#line 1074
    if ((unsigned long )proc_info[i] == (unsigned long )((void *)0)) {
#line 1075
      free_slot = (_Bool)1;
#line 1076
      goto while_break;
    }
#line 1073
    j ++;
#line 1073
    i = (i + 1) % 32769;
  }
  while_break: /* CIL Label */ ;
  }
#line 1080
  if (! free_slot) {
#line 1081
    return (-1);
  }
  {
#line 1083
  memset((void *)(cmdline), 0, sizeof(cmdline));
#line 1085
  tmp = calloc((size_t )1, sizeof(proc_info_t ));
#line 1085
  info = (proc_info_t *)tmp;
  }
#line 1085
  if ((unsigned long )info == (unsigned long )((void *)0)) {
    {
#line 1086
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot allocate all proc info\n");
    }
#line 1087
    return (-1);
  }
  {
#line 1089
  info->pid = (pid_t )pid;
#line 1091
  snprintf((char */* __restrict  */)(path), sizeof(path), (char const   */* __restrict  */)"/proc/%d/cmdline",
           info->pid);
#line 1092
  proc_cmdline(pid, (char */* const  */)(cmdline), (size_t const   )sizeof(cmdline));
#line 1094
  tmp___1 = strlen((char const   *)(cmdline));
#line 1094
  tmp___2 = malloc(tmp___1 + 1UL);
#line 1094
  tmp___0 = (char *)tmp___2;
#line 1094
  info->cmdline = tmp___0;
  }
#line 1094
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
    {
#line 1095
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot allocate all proc info\n");
#line 1096
    free((void *)info);
    }
#line 1097
    return (-1);
  }
  {
#line 1099
  strcpy((char */* __restrict  */)info->cmdline, (char const   */* __restrict  */)(cmdline));
#line 1100
  proc_info[i] = info;
  }
#line 1102
  return (-1);
}
}
#line 1109 "/home/wheatley/newnew/temp/powerstat-0.01.30/powerstat.c"
static int proc_info_load(void) 
{ 
  DIR *dir ;
  struct dirent *dirent ;
  int tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 1114
  dir = opendir("/proc");
  }
#line 1114
  if ((unsigned long )dir == (unsigned long )((void *)0)) {
#line 1115
    return (-1);
  }
  {
#line 1117
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1117
    dirent = readdir(dir);
    }
#line 1117
    if (! dirent) {
#line 1117
      goto while_break;
    }
    {
#line 1118
    tmp___0 = __ctype_b_loc();
    }
#line 1118
    if ((int const   )*(*tmp___0 + (int )dirent->d_name[0]) & 2048) {
      {
#line 1119
      tmp = atoi((char const   *)(dirent->d_name));
#line 1119
      proc_info_add((pid_t const   )tmp);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1122
  closedir(dir);
  }
#line 1123
  return (0);
}
}
#line 1130 "/home/wheatley/newnew/temp/powerstat-0.01.30/powerstat.c"
static int monitor(int const   sock ) 
{ 
  ssize_t len ;
  int readings ;
  int redone ;
  int row ;
  stats_t *stats ;
  stats_t s1 ;
  stats_t s2 ;
  stats_t average ;
  stats_t stddev ;
  stats_t min ;
  stats_t max ;
  struct nlmsghdr *nlmsghdr ;
  struct timeval t1 ;
  struct timeval t2 ;
  void *tmp ;
  _Bool redo ;
  int ret ;
  suseconds_t usec ;
  struct timeval tv ;
  char __attribute__((__aligned__(4)))  buf[4096] ;
  fd_set readfds ;
  int __d0 ;
  int __d1 ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char tmbuffer[10] ;
  _Bool discharging ;
  char buffer[80] ;
  int indent ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  size_t tmp___6 ;
  _Bool tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  struct cn_msg *cn_msg ;
  struct proc_event *proc_ev ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;

  {
  {
#line 1133
  readings = 0;
#line 1133
  redone = 0;
#line 1133
  row = 0;
#line 1138
  tmp = calloc((size_t )max_readings, sizeof(stats_t ));
#line 1138
  stats = (stats_t *)tmp;
  }
#line 1138
  if ((unsigned long )stats == (unsigned long )((void *)0)) {
    {
#line 1139
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot allocate statistics table.\n");
    }
#line 1140
    return (-1);
  }
  {
#line 1143
  stats_clear_all((stats_t */* const  */)stats, (int const   )max_readings);
#line 1144
  stats_clear((stats_t */* const  */)(& average));
#line 1145
  stats_clear((stats_t */* const  */)(& stddev));
#line 1146
  stats_clear((stats_t */* const  */)(& min));
#line 1147
  stats_clear((stats_t */* const  */)(& max));
#line 1149
  stats_headings();
#line 1150
  row ++;
#line 1152
  gettimeofday((struct timeval */* __restrict  */)(& t1), (__timezone_ptr_t )((void *)0));
#line 1153
  stats_read((stats_t */* const  */)(& s1));
  }
  {
#line 1155
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1155
    if (! stop_recv) {
#line 1155
      if (! (readings < max_readings)) {
#line 1155
        goto while_break;
      }
    } else {
#line 1155
      goto while_break;
    }
    {
#line 1156
    redo = (_Bool)0;
#line 1162
    gettimeofday((struct timeval */* __restrict  */)(& t2), (__timezone_ptr_t )((void *)0));
#line 1163
    usec = ((t1.tv_sec + (__time_t )sample_delay) - t2.tv_sec) * 1000000L + (t1.tv_usec - t2.tv_usec);
    }
#line 1164
    if (usec < 0L) {
#line 1165
      goto sample_now;
    }
#line 1166
    tv.tv_sec = usec / 1000000L;
#line 1167
    tv.tv_usec = usec % 1000000L;
#line 1169
    if (opts & 19) {
      {
#line 1171
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1171
        __asm__  volatile   ("cld; rep; "
                             "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                             "1" (& readfds.__fds_bits[0]): "memory");
#line 1171
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1172
      readfds.__fds_bits[sock / (int const   )(8 * (int )sizeof(__fd_mask ))] |= 1L << sock % (int const   )(8 * (int )sizeof(__fd_mask ));
#line 1173
      ret = select((int )(sock + 1), (fd_set */* __restrict  */)(& readfds), (fd_set */* __restrict  */)((void *)0),
                   (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
      }
    } else {
      {
#line 1175
      ret = select(0, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)((void *)0),
                   (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
      }
    }
#line 1178
    if (ret < 0) {
      {
#line 1179
      tmp___0 = __errno_location();
      }
#line 1179
      if (*tmp___0 == 4) {
#line 1180
        goto while_break;
      }
      {
#line 1181
      tmp___1 = __errno_location();
#line 1181
      tmp___2 = strerror(*tmp___1);
#line 1181
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"select: %s\n",
              tmp___2);
#line 1182
      free((void *)stats);
      }
#line 1183
      return (-1);
    }
#line 1187
    if (ret == 0) {
      sample_now: 
#line 1192
      if (redone) {
#line 1195
        if (redone & 2) {
#line 1195
          tmp___3 = "fork/exec/exit activity";
        } else {
#line 1195
          tmp___3 = "";
        }
#line 1195
        if ((redone & 6) == 6) {
#line 1195
          tmp___4 = " and ";
        } else {
#line 1195
          tmp___4 = "";
        }
#line 1195
        if (redone & 4) {
#line 1195
          tmp___5 = "low CPU idle";
        } else {
#line 1195
          tmp___5 = "";
        }
        {
#line 1195
        snprintf((char */* __restrict  */)(buffer), sizeof(buffer), (char const   */* __restrict  */)"--- Skipped samples(s) because of %s%s%s ---",
                 tmp___5, tmp___4, tmp___3);
#line 1200
        tmp___6 = strlen((char const   *)(buffer));
#line 1200
        indent = (int )((80UL - tmp___6) / 2UL);
#line 1201
        row_increment((int */* const  */)(& row));
#line 1202
        printf((char const   */* __restrict  */)"%*.*s%s\n", indent, indent, "", buffer);
#line 1203
        redone = 0;
        }
      }
      {
#line 1206
      time_now((char */* const  */)(tmbuffer), (size_t const   )sizeof(tmbuffer));
#line 1207
      gettimeofday((struct timeval */* __restrict  */)(& t1), (__timezone_ptr_t )((void *)0));
#line 1208
      stats_read((stats_t */* const  */)(& s2));
#line 1213
      tmp___7 = stats_gather((stats_t const   */* const  */)(& s1), (stats_t const   */* const  */)(& s2),
                             (stats_t */* const  */)(stats + readings));
      }
#line 1213
      if (! tmp___7) {
        {
#line 1214
        stats_clear((stats_t */* const  */)(stats + readings));
#line 1215
        stats_read((stats_t */* const  */)(& s1));
#line 1216
        gettimeofday((struct timeval */* __restrict  */)(& t1), (__timezone_ptr_t )((void *)0));
#line 1217
        redone |= 4;
        }
#line 1218
        goto while_continue;
      }
#line 1221
      if (opts & 4) {
#line 1221
        if ((stats + readings)->value[3] < idle_threshold) {
          {
#line 1223
          stats_clear((stats_t */* const  */)(stats + readings));
#line 1224
          stats_read((stats_t */* const  */)(& s1));
#line 1225
          gettimeofday((struct timeval */* __restrict  */)(& t1), (__timezone_ptr_t )((void *)0));
#line 1226
          redone |= 4;
          }
#line 1227
          goto while_continue;
        }
      }
      {
#line 1230
      tmp___8 = power_rate_get((double */* const  */)(& (stats + readings)->value[11]),
                               (_Bool */* const  */)(& discharging), (_Bool */* const  */)(& (stats + readings)->inaccurate[11]));
      }
#line 1230
      if (tmp___8 < 0) {
        {
#line 1233
        free((void *)stats);
        }
#line 1234
        return (-1);
      }
#line 1237
      if (! discharging) {
        {
#line 1238
        free((void *)stats);
        }
#line 1239
        return (-1);
      }
      {
#line 1242
      row_increment((int */* const  */)(& row));
#line 1243
      stats_print((char const   */* const  */)(tmbuffer), (_Bool const   )0, (stats_t const   */* const  */)(stats + readings));
#line 1244
      readings ++;
#line 1245
      s1 = s2;
      }
#line 1246
      goto while_continue;
    }
#line 1249
    if (opts & 19) {
      {
#line 1250
      len = recv((int )sock, (void *)(buf), sizeof(buf), 0);
      }
#line 1250
      if (len == 0L) {
        {
#line 1251
        free((void *)stats);
        }
#line 1252
        return (0);
      }
#line 1254
      if (len == -1L) {
        {
#line 1255
        tmp___11 = __errno_location();
        }
#line 1255
        if (*tmp___11 == 4) {
#line 1256
          goto while_continue;
        } else {
          {
#line 1258
          tmp___9 = __errno_location();
#line 1258
          tmp___10 = strerror(*tmp___9);
#line 1258
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"recv: %s\n",
                  tmp___10);
#line 1259
          free((void *)stats);
          }
#line 1260
          return (-1);
        }
      }
#line 1264
      nlmsghdr = (struct nlmsghdr *)(buf);
      {
#line 1264
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1264
        if (len >= (ssize_t )((int )sizeof(struct nlmsghdr ))) {
#line 1264
          if ((unsigned long )nlmsghdr->nlmsg_len >= sizeof(struct nlmsghdr )) {
#line 1264
            if (! ((ssize_t )nlmsghdr->nlmsg_len <= len)) {
#line 1264
              goto while_break___1;
            }
          } else {
#line 1264
            goto while_break___1;
          }
        } else {
#line 1264
          goto while_break___1;
        }
#line 1268
        if ((int )nlmsghdr->nlmsg_type == 2) {
#line 1270
          goto __Cont;
        } else
#line 1268
        if ((int )nlmsghdr->nlmsg_type == 1) {
#line 1270
          goto __Cont;
        }
#line 1272
        cn_msg = (struct cn_msg *)((void *)((char *)nlmsghdr + (int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL)));
#line 1274
        if (cn_msg->id.idx != 1U) {
#line 1276
          goto __Cont;
        } else
#line 1274
        if (cn_msg->id.val != 1U) {
#line 1276
          goto __Cont;
        }
#line 1278
        proc_ev = (struct proc_event *)(cn_msg->data);
        {
#line 1281
        if ((unsigned int )proc_ev->what == 1U) {
#line 1281
          goto case_1;
        }
#line 1294
        if ((unsigned int )proc_ev->what == 2U) {
#line 1294
          goto case_2;
        }
#line 1304
        if ((unsigned int )proc_ev->what == 2147483648U) {
#line 1304
          goto case_2147483648;
        }
#line 1318
        goto switch_default;
        case_1: /* CIL Label */ 
        {
#line 1282
        (stats + readings)->value[12] += 1.0;
#line 1283
        proc_info_add((pid_t const   )proc_ev->event_data.fork.child_pid);
        }
#line 1284
        if (opts & 1) {
          {
#line 1285
          tmp___12 = proc_info_get((pid_t const   )proc_ev->event_data.fork.child_pid);
#line 1285
          log_printf((char const   */* const  */)"fork: parent tid=%d pid=%d -> child tid=%d pid=%d (%s)\n",
                     proc_ev->event_data.fork.parent_pid, proc_ev->event_data.fork.parent_tgid,
                     proc_ev->event_data.fork.child_pid, proc_ev->event_data.fork.child_tgid,
                     tmp___12);
          }
        }
#line 1292
        redo = (_Bool)1;
#line 1293
        goto switch_break;
        case_2: /* CIL Label */ 
#line 1295
        (stats + readings)->value[13] += 1.0;
#line 1296
        if (opts & 1) {
          {
#line 1297
          tmp___13 = proc_info_get((pid_t const   )proc_ev->event_data.exec.process_pid);
#line 1297
          log_printf((char const   */* const  */)"exec: tid=%d pid=%d (%s)\n", proc_ev->event_data.exec.process_pid,
                     proc_ev->event_data.exec.process_tgid, tmp___13);
          }
        }
#line 1302
        redo = (_Bool)1;
#line 1303
        goto switch_break;
        case_2147483648: /* CIL Label */ 
#line 1305
        (stats + readings)->value[14] += 1.0;
#line 1306
        if (opts & 1) {
          {
#line 1307
          tmp___14 = proc_info_get((pid_t const   )proc_ev->event_data.exit.process_pid);
#line 1307
          log_printf((char const   */* const  */)"exit: tid=%d pid=%d exit_code=%d (%s)\n",
                     proc_ev->event_data.exit.process_pid, proc_ev->event_data.exit.process_tgid,
                     proc_ev->event_data.exit.exit_code, tmp___14);
          }
        }
#line 1313
        if (proc_ev->event_data.exit.process_pid == proc_ev->event_data.exit.process_tgid) {
          {
#line 1315
          proc_info_free((pid_t const   )proc_ev->event_data.exit.process_pid);
          }
        }
#line 1316
        redo = (_Bool)1;
#line 1317
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 1319
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
        __Cont: /* CIL Label */ 
#line 1264
        len -= (ssize_t )(((nlmsghdr->nlmsg_len + 4U) - 1U) & 4294967292U);
#line 1264
        nlmsghdr = (struct nlmsghdr *)((char *)nlmsghdr + (((nlmsghdr->nlmsg_len + 4U) - 1U) & 4294967292U));
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1324
      if (opts & 2) {
#line 1324
        if (redo) {
          {
#line 1325
          stats_clear((stats_t */* const  */)(stats + readings));
#line 1326
          stats_read((stats_t */* const  */)(& s1));
#line 1327
          gettimeofday((struct timeval */* __restrict  */)(& t1), (__timezone_ptr_t )((void *)0));
#line 1328
          redone |= 2;
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1334
  stats_average_stddev_min_max((stats_t const   */* const  */)stats, (int const   )readings,
                               (stats_t */* const  */)(& average), (stats_t */* const  */)(& stddev),
                               (stats_t */* const  */)(& min), (stats_t */* const  */)(& max));
  }
#line 1335
  if (readings > 0) {
    {
#line 1336
    stats_ruler();
#line 1337
    stats_print((char const   */* const  */)"Average", (_Bool const   )1, (stats_t const   */* const  */)(& average));
#line 1338
    stats_print((char const   */* const  */)"StdDev", (_Bool const   )1, (stats_t const   */* const  */)(& stddev));
#line 1339
    stats_ruler();
#line 1340
    stats_print((char const   */* const  */)"Minimum", (_Bool const   )1, (stats_t const   */* const  */)(& min));
#line 1341
    stats_print((char const   */* const  */)"Maximum", (_Bool const   )1, (stats_t const   */* const  */)(& max));
#line 1342
    stats_ruler();
    }
  }
  {
#line 1345
  printf((char const   */* __restrict  */)"Summary:\n");
#line 1346
  printf((char const   */* __restrict  */)"%6.2f Watts on Average with Standard Deviation %-6.2f\n",
         average.value[11], stddev.value[11]);
  }
#line 1349
  if (power_calc_from_capacity) {
    {
#line 1350
    printf((char const   */* __restrict  */)"Note: Power calculated from battery capacity drain, may not be accurate.\n");
    }
  } else
#line 1352
  if (opts & 32) {
    {
#line 1353
    printf((char const   */* __restrict  */)"Note: The battery supplied suitable power data, -S option not required.\n");
    }
  }
  {
#line 1356
  free((void *)stats);
  }
#line 1357
  return (0);
}
}
#line 1365 "/home/wheatley/newnew/temp/powerstat-0.01.30/powerstat.c"
void show_help(char * const  *argv ) 
{ 


  {
  {
#line 1367
  printf((char const   */* __restrict  */)"%s, version %s\n\n", "powerstat", "0.01.30");
#line 1368
  printf((char const   */* __restrict  */)"usage: %s [-d secs] [-i idle] [-b|-h|-p|-r|-s|-z] [delay [count]]\n",
         *(argv + 0));
#line 1369
  printf((char const   */* __restrict  */)"\t-b redo a sample if a system is busy, considered less than %d%% CPU idle\n",
         98);
#line 1370
  printf((char const   */* __restrict  */)"\t-d specify delay before starting, default is %d seconds\n",
         start_delay);
#line 1371
  printf((char const   */* __restrict  */)"\t-h show help\n");
#line 1372
  printf((char const   */* __restrict  */)"\t-i specify CPU idle threshold, used in conjunction with -b\n");
#line 1373
  printf((char const   */* __restrict  */)"\t-p redo a sample if we see process fork/exec/exit activity\n");
#line 1374
  printf((char const   */* __restrict  */)"\t-r redo a sample if busy and we see process activity (same as -b -p)\n");
#line 1375
  printf((char const   */* __restrict  */)"\t-s show process fork/exec/exit activity log\n");
#line 1376
  printf((char const   */* __restrict  */)"\t-S calculate power from capacity drain using standard average\n");
#line 1377
  printf((char const   */* __restrict  */)"\t-z forcibly ignore zero power rate stats from the battery\n");
#line 1378
  printf((char const   */* __restrict  */)"\tdelay: delay between each sample, default is %d seconds\n",
         10);
#line 1379
  printf((char const   */* __restrict  */)"\tcount: number of samples to take\n");
  }
#line 1380
  return;
}
}
#line 1382 "/home/wheatley/newnew/temp/powerstat-0.01.30/powerstat.c"
int main(int argc , char * const  *argv ) 
{ 
  double dummy_rate ;
  int sock ;
  int ret ;
  int i ;
  int run_duration ;
  _Bool discharging ;
  _Bool dummy_inaccurate ;
  int c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  __uid_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 1385
  sock = -1;
#line 1385
  ret = 1;
#line 1388
  signal(2, & handle_sigint);
#line 1389
  siginterrupt(2, 1);
  }
  {
#line 1391
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1392
    tmp = getopt(argc, argv, "bd:hi:prszS");
#line 1392
    c = tmp;
    }
#line 1393
    if (c == -1) {
#line 1394
      goto while_break;
    }
    {
#line 1396
    if (c == 98) {
#line 1396
      goto case_98;
    }
#line 1399
    if (c == 100) {
#line 1399
      goto case_100;
    }
#line 1406
    if (c == 104) {
#line 1406
      goto case_104;
    }
#line 1409
    if (c == 105) {
#line 1409
      goto case_105;
    }
#line 1417
    if (c == 112) {
#line 1417
      goto case_112;
    }
#line 1420
    if (c == 114) {
#line 1420
      goto case_114;
    }
#line 1423
    if (c == 115) {
#line 1423
      goto case_115;
    }
#line 1426
    if (c == 83) {
#line 1426
      goto case_83;
    }
#line 1429
    if (c == 122) {
#line 1429
      goto case_122;
    }
#line 1395
    goto switch_break;
    case_98: /* CIL Label */ 
#line 1397
    opts |= 4;
#line 1398
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 1400
    start_delay = atoi((char const   *)optarg);
    }
#line 1401
    if (start_delay < 0) {
      {
#line 1402
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Start delay must be 0 or more seconds\n");
#line 1403
      exit(1);
      }
    }
#line 1405
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 1407
    show_help(argv);
#line 1408
    exit(0);
    }
    case_105: /* CIL Label */ 
    {
#line 1410
    opts |= 4;
#line 1411
    idle_threshold = atof((char const   *)optarg);
    }
#line 1412
    if (idle_threshold < 0.0) {
      {
#line 1413
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Idle threshold must be between 0..99.99\n");
#line 1414
      exit(1);
      }
    } else
#line 1412
    if (idle_threshold > 99.99) {
      {
#line 1413
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Idle threshold must be between 0..99.99\n");
#line 1414
      exit(1);
      }
    }
#line 1416
    goto switch_break;
    case_112: /* CIL Label */ 
#line 1418
    opts |= 2;
#line 1419
    goto switch_break;
    case_114: /* CIL Label */ 
#line 1421
    opts |= 6;
#line 1422
    goto switch_break;
    case_115: /* CIL Label */ 
#line 1424
    opts |= 1;
#line 1425
    goto switch_break;
    case_83: /* CIL Label */ 
#line 1427
    opts |= 32;
#line 1428
    goto switch_break;
    case_122: /* CIL Label */ 
#line 1430
    opts |= 8;
#line 1431
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1435
  if (optind < argc) {
    {
#line 1436
    tmp___0 = optind;
#line 1436
    optind ++;
#line 1436
    sample_delay = atoi((char const   *)*(argv + tmp___0));
    }
#line 1437
    if (sample_delay < 1) {
      {
#line 1438
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Sample delay must be >= 1\n");
#line 1439
      exit(ret);
      }
    }
  }
#line 1443
  run_duration = 480 - start_delay;
#line 1445
  if (optind < argc) {
    {
#line 1446
    tmp___1 = optind;
#line 1446
    optind ++;
#line 1446
    max_readings = atoi((char const   *)*(argv + tmp___1));
    }
#line 1447
    if (max_readings * sample_delay < run_duration) {
      {
#line 1448
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Number of readings should be at least %d\n",
              run_duration / sample_delay);
#line 1450
      exit(ret);
      }
    }
  } else {
#line 1453
    max_readings = run_duration / sample_delay;
  }
  {
#line 1456
  tmp___2 = geteuid();
  }
#line 1456
  if (tmp___2 == 0U) {
#line 1457
    opts |= 16;
  } else
#line 1458
  if (opts & 19) {
    {
#line 1459
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s needs to be run with root privilege when using -p, -r, -s options\n",
            *(argv + 0));
#line 1460
    exit(ret);
    }
  }
  {
#line 1463
  tmp___3 = power_rate_get((double */* const  */)(& dummy_rate), (_Bool */* const  */)(& discharging),
                           (_Bool */* const  */)(& dummy_inaccurate));
  }
#line 1463
  if (tmp___3 < 0) {
    {
#line 1464
    exit(ret);
    }
  }
  {
#line 1465
  printf((char const   */* __restrict  */)"Running for %d seconds (%d samples at %d second intervals).\n",
         sample_delay * max_readings, max_readings, sample_delay);
#line 1467
  printf((char const   */* __restrict  */)"ACPI battery power measurements will start in %d seconds time\n",
         start_delay);
#line 1469
  printf((char const   */* __restrict  */)"\n");
  }
#line 1471
  if (start_delay > 0) {
#line 1473
    i = 0;
    {
#line 1473
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1473
      if (! (i < start_delay)) {
#line 1473
        goto while_break___0;
      }
      {
#line 1474
      printf((char const   */* __restrict  */)"Waiting %d seconds before starting (gathering samples) \r",
             start_delay - i);
#line 1475
      fflush(stdout);
#line 1476
      tmp___4 = power_rate_get((double */* const  */)(& dummy_rate), (_Bool */* const  */)(& discharging),
                               (_Bool */* const  */)(& dummy_inaccurate));
      }
#line 1476
      if (tmp___4 < 0) {
        {
#line 1477
        exit(ret);
        }
      }
      {
#line 1478
      tmp___5 = sleep(1U);
      }
#line 1478
      if (tmp___5) {
        {
#line 1479
        exit(ret);
        }
      } else
#line 1478
      if (stop_recv) {
        {
#line 1479
        exit(ret);
        }
      }
#line 1480
      if (! discharging) {
        {
#line 1481
        exit(ret);
        }
      }
#line 1473
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1483
    printf((char const   */* __restrict  */)"%79.79s\r", "");
    }
  }
  {
#line 1486
  log_init();
  }
#line 1487
  if (opts & 19) {
    {
#line 1488
    sock = netlink_connect();
    }
#line 1489
    if (sock == -93) {
#line 1490
      if (opts & 1) {
        {
#line 1491
        printf((char const   */* __restrict  */)"Cannot show process activity with this kernel.\n");
        }
      }
#line 1492
      opts &= -20;
    } else
#line 1493
    if (sock < 0) {
#line 1494
      goto abort;
    } else {
      {
#line 1496
      proc_info_load();
#line 1498
      tmp___6 = netlink_listen((int const   )sock);
      }
#line 1498
      if (tmp___6 < 0) {
#line 1499
        goto abort_sock;
      }
    }
  }
  {
#line 1503
  tmp___7 = power_rate_get((double */* const  */)(& dummy_rate), (_Bool */* const  */)(& discharging),
                           (_Bool */* const  */)(& dummy_inaccurate));
  }
#line 1503
  if (tmp___7 < 0) {
#line 1504
    goto abort_sock;
  }
  {
#line 1506
  tmp___8 = monitor((int const   )sock);
  }
#line 1506
  if (tmp___8 == 0) {
#line 1507
    ret = 0;
  }
  abort_sock: 
#line 1510
  if (opts & 19) {
    {
#line 1511
    proc_info_unload();
    }
  }
  abort: 
#line 1513
  if (opts & 19) {
    {
#line 1514
    log_dump();
#line 1515
    log_free();
    }
#line 1516
    if (sock != -1) {
      {
#line 1517
      close(sock);
      }
    }
  }
  {
#line 1520
  exit(ret);
  }
}
}
