/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 38 "/usr/include/stdint.h"
typedef int int32_t;
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 68 "/usr/include/errno.h"
typedef int error_t;
#line 77 "/usr/include/argp.h"
struct argp_option {
   char const   *name ;
   int key ;
   char const   *arg ;
   int flags ;
   char const   *doc ;
   int group ;
};
#line 142
struct argp;
#line 143
struct argp_state;
#line 144
struct argp_child;
#line 216 "/usr/include/argp.h"
struct argp {
   struct argp_option  const  *options ;
   error_t (*parser)(int __key , char *__arg , struct argp_state *__state ) ;
   char const   *args_doc ;
   char const   *doc ;
   struct argp_child  const  *children ;
   char *(*help_filter)(int __key , char const   *__text , void *__input ) ;
   char const   *argp_domain ;
};
#line 282 "/usr/include/argp.h"
struct argp_child {
   struct argp  const  *argp ;
   int flags ;
   char const   *header ;
   int group ;
};
#line 307 "/usr/include/argp.h"
struct argp_state {
   struct argp  const  *root_argp ;
   int argc ;
   char **argv ;
   int next ;
   unsigned int flags ;
   unsigned int arg_num ;
   int quoted ;
   void *input ;
   void **child_inputs ;
   void *hook ;
   char *name ;
   FILE *err_stream ;
   FILE *out_stream ;
   void *pstate ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 30 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/intel_microcode.h"
enum __anonenum_intel_ucode_status_t_30 {
    INTEL_UCODE_NOERROR = 0,
    INTEL_UCODE_BAD_PARAMETERS = 1,
    INTEL_UCODE_INVALID_DATA = 2,
    INTEL_UCODE_UNKNOWN_FORMAT = 3,
    INTEL_UCODE_COUNTEROVERFLOW = 4,
    INTEL_UCODE_BAD_EXTENDED_TABLE = 5,
    INTEL_UCODE_BAD_EXTENDED_TABLE_CHECKSUM = 6,
    INTEL_UCODE_BAD_EXTENDED_SIG_CHECKSUM = 7,
    INTEL_UCODE_BAD_CHECKSUM = 8,
    INTEL_UCODE_CALLBACK_ERROR = 9
} ;
#line 30 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/intel_microcode.h"
typedef enum __anonenum_intel_ucode_status_t_30 intel_ucode_status_t;
#line 43 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/intel_microcode.h"
struct intel_ucode_metadata {
   uint16_t date_year ;
   uint8_t date_day ;
   uint8_t date_month ;
   int32_t revision ;
   uint32_t loader_version ;
   uint32_t size ;
};
#line 100 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/intel_microcode.h"
typedef int intel_ucode_uc_callback(void *userdata , unsigned int const   uc_count ,
                                    void const   * const  uc );
#line 131 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/intel_microcode.h"
typedef int intel_ucode_sig_callback(void *userdata , unsigned int const   sig_count ,
                                     uint32_t const   cpuid , uint32_t const   pf_mask ,
                                     void const   * const  uc_data , unsigned int const   uc_data_size ,
                                     void const   * const  uc , unsigned int const   uc_size );
#line 55 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
enum __anonenum_command_line_actions_32 {
    IUCODE_DO_UPLOADUC = 1,
    IUCODE_DO_WRITEUC = 2,
    IUCODE_DO_WRITEFW = 4,
    IUCODE_DO_SELPROC = 8,
    IUCODE_DO_LOADFILE = 16,
    IUCODE_DO_WRITEFWN = 32,
    IUCODE_DO_WRITEFWE = 64,
    IUCODE_F_UCSELECT = 4096,
    IUCODE_DOMASK_NEEDSUC = 103
} ;
#line 87
enum __anonenum_intel_ucode_file_type_t_33 {
    INTEL_UC_FT_UNKNOWN = 0,
    INTEL_UC_FT_DAT = 1,
    INTEL_UC_FT_BIN = 2
} ;
#line 87 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
typedef enum __anonenum_intel_ucode_file_type_t_33 intel_ucode_file_type_t;
#line 95 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
struct filename_list {
   intel_ucode_file_type_t type ;
   struct filename_list *next ;
   char path[] ;
};
#line 104 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
struct microcode_bundle {
   struct microcode_bundle *next ;
   char const   *filename ;
   unsigned long id ;
   unsigned long size ;
   void const   *data ;
};
#line 122 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
struct intel_uclist_entry {
   unsigned long id ;
   unsigned long gid ;
   uint32_t flags ;
   uint32_t cpuid ;
   uint32_t pf_mask ;
   int32_t uc_rev ;
   void const   *uc ;
   uint32_t uc_size ;
   struct intel_uclist_entry *next ;
};
#line 138 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
struct microcode_interator_data {
   struct microcode_bundle  const  *current_bundle ;
   unsigned long total_signature_count ;
   unsigned long total_unique_sig_count ;
   unsigned long total_entry_count ;
   unsigned long current_uc ;
   char current_uc_id_str[20] ;
};
#line 149 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
struct microcode_filter_entry {
   uint32_t cpuid ;
   uint32_t pf_mask ;
   int invert ;
   struct microcode_filter_entry *next ;
};
#line 52 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/intel_microcode.c"
struct intel_ucode_v1_hdr {
   uint32_t hdrver ;
   int32_t rev ;
   uint32_t date ;
   uint32_t sig ;
   uint32_t cksum ;
   uint32_t ldrver ;
   uint32_t pf_mask ;
   uint32_t datasize ;
   uint32_t totalsize ;
   uint32_t reserved[3] ;
} __attribute__((__packed__)) ;
#line 66 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/intel_microcode.c"
struct intel_ucode_v1_extsig {
   uint32_t sig ;
   uint32_t pf_mask ;
   uint32_t cksum ;
} __attribute__((__packed__)) ;
#line 72 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/intel_microcode.c"
struct intel_ucode_v1_extsig_table {
   uint32_t count ;
   uint32_t cksum ;
   uint32_t reserved[3] ;
   struct intel_ucode_v1_extsig sigs[] ;
} __attribute__((__packed__)) ;
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 170
extern int ( __attribute__((__nonnull__(2))) openat)(int __fd , char const   *__file ,
                                                     int __oflag  , ...) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 306
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 187 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) unlinkat)(int __fd ,
                                                                                               char const   *__name ,
                                                                                               int __flag ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 404 "/usr/include/argp.h"
extern error_t argp_parse(struct argp  const  * __restrict  __argp , int __argc ,
                          char ** __restrict  __argv , unsigned int __flags , int * __restrict  __arg_index ,
                          void * __restrict  __input ) ;
#line 419
extern char const   *argp_program_version ;
#line 435
extern char const   *argp_program_bug_address ;
#line 440
extern error_t argp_err_exit_status ;
#line 490
extern void argp_state_help(struct argp_state  const  * __restrict  __state , FILE * __restrict  __stream ,
                            unsigned int __flags ) ;
#line 504
extern void ( /* format attribute */  argp_error)(struct argp_state  const  * __restrict  __state ,
                                                  char const   * __restrict  __fmt 
                                                  , ...) ;
#line 519
extern void ( /* format attribute */  argp_failure)(struct argp_state  const  * __restrict  __state ,
                                                    int __status , int __errnum ,
                                                    char const   * __restrict  __fmt 
                                                    , ...) ;
#line 141 "/usr/include/dirent.h"
extern DIR *fdopendir(int __fd ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 223
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) dirfd)(DIR *__dirp ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 52 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/intel_microcode.h"
intel_ucode_status_t intel_ucode_getmetadata(void const   * const  uc , struct intel_ucode_metadata *metadata ) ;
#line 71
char const   *intel_ucode_errstr(intel_ucode_status_t const   status ) ;
#line 73
intel_ucode_status_t intel_ucode_check_microcode(void const   * const  uc , int strict ) ;
#line 76
int intel_ucode_compare(void const   * const  uc1 , void const   * const  uc2 ) ;
#line 104
intel_ucode_status_t intel_ucode_foreach_microcode(void const   * const  uc_bundle ,
                                                   size_t const   uc_bundle_size ,
                                                   intel_ucode_uc_callback * const  action ,
                                                   void * const  userdata ) ;
#line 140
intel_ucode_status_t intel_ucode_foreach_signature(void const   * const  uc , intel_ucode_sig_callback * const  action ,
                                                   void * const  userdata ) ;
#line 55 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static enum __anonenum_command_line_actions_32 command_line_actions  ;
#line 73 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static char *progname  ;
#line 74 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static int verbosity  =    1;
#line 75 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static int strict_checks  =    1;
#line 76 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static int ignore_bad_ucode  =    0;
#line 77 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static int allow_downgrade  =    0;
#line 78 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static int list_all_microcodes  =    0;
#line 79 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static int list_sel_microcodes  =    0;
#line 80 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static int unlink_files  =    0;
#line 81 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static char *upload_microcode  =    (char *)((void *)0);
#line 82 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static char *write_microcode  =    (char *)((void *)0);
#line 83 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static char *write_early_firmware  =    (char *)((void *)0);
#line 84 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static char *write_firmware  =    (char *)((void *)0);
#line 85 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static char *write_named  =    (char *)((void *)0);
#line 92 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static intel_ucode_file_type_t ucfiletype  =    (intel_ucode_file_type_t )0;
#line 100 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static struct filename_list *input_files  =    (struct filename_list *)((void *)0);
#line 111 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static struct microcode_bundle *microcode_bundles  =    (struct microcode_bundle *)((void *)0);
#line 112 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static unsigned long last_bundle_id  =    0UL;
#line 133 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static struct intel_uclist_entry *all_microcodes  =    (struct intel_uclist_entry *)((void *)0);
#line 134 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static struct intel_uclist_entry *microcodes  =    (struct intel_uclist_entry *)((void *)0);
#line 146 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static struct microcode_interator_data microcode_interator_data  ;
#line 155 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static struct microcode_filter_entry *uc_filter_list  =    (struct microcode_filter_entry *)((void *)0);
#line 156 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static int filter_list_allow  =    1;
#line 158 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static uint32_t datefilter_max  =    4294967295U;
#line 159 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static uint32_t datefilter_min  =    (uint32_t )0;
#line 160 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static int datefilter_loose  =    0;
#line 162 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
__inline static int filter_list_active(void) 
{ 
  int tmp ;

  {
#line 164
  if (! (! uc_filter_list)) {
#line 164
    tmp = 1;
  } else
#line 164
  if (! (! ((unsigned int )command_line_actions & 4096U))) {
#line 164
    tmp = 1;
  } else {
#line 164
    tmp = 0;
  }
#line 164
  return (tmp);
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
__inline static int is_dash(char const   * const  fn ) 
{ 
  int tmp ;

  {
#line 183
  if (fn) {
#line 183
    if ((int const   )*fn == 45) {
#line 183
      if (! *(fn + 1)) {
#line 183
        tmp = 1;
      } else {
#line 183
        tmp = 0;
      }
    } else {
#line 183
      tmp = 0;
    }
  } else {
#line 183
    tmp = 0;
  }
#line 183
  return (tmp);
}
}
#line 188 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static void str_append_ucode_id(unsigned long id , unsigned long gid , char *str ,
                                unsigned int len ) 
{ 


  {
  {
#line 192
  snprintf((char */* __restrict  */)str, (size_t )len, (char const   */* __restrict  */)"%02lu/%03lu",
           gid, id);
  }
#line 193
  return;
}
}
#line 204 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static void free_uclist(struct intel_uclist_entry *p___0 ) 
{ 
  struct intel_uclist_entry *e ;

  {
  {
#line 208
  while (1) {
    while_continue: /* CIL Label */ ;
#line 208
    if (! p___0) {
#line 208
      goto while_break;
    }
    {
#line 209
    e = p___0;
#line 210
    p___0 = e->next;
#line 211
    free((void *)e);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 213
  return;
}
}
#line 218 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static void xx_uclist_remove_shadowed(unsigned long const   gid , uint32_t const   cpuid ,
                                      uint32_t const   pf_mask , int32_t const   uc_rev ,
                                      int const   downgrade , struct intel_uclist_entry **pnext ) 
{ 
  struct intel_uclist_entry *e ;

  {
  {
#line 225
  while (1) {
    while_continue: /* CIL Label */ ;
#line 225
    if (*pnext) {
#line 225
      if (! ((*pnext)->cpuid == (uint32_t )cpuid)) {
#line 225
        goto while_break;
      }
    } else {
#line 225
      goto while_break;
    }
#line 226
    e = *pnext;
#line 228
    if ((pf_mask & (unsigned int const   )e->pf_mask) == (unsigned int const   )e->pf_mask) {
#line 228
      if (uc_rev >= (int32_t const   )e->uc_rev) {
        {
#line 232
        *pnext = e->next;
#line 233
        free((void *)e);
        }
      } else
#line 228
      if (downgrade) {
#line 228
        if (gid > (unsigned long const   )e->gid) {
          {
#line 232
          *pnext = e->next;
#line 233
          free((void *)e);
          }
        } else {
#line 235
          pnext = & e->next;
        }
      } else {
#line 235
        pnext = & e->next;
      }
    } else {
#line 235
      pnext = & e->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 238
  return;
}
}
#line 267 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static int uclist_add_signature(unsigned long const   id , unsigned long const   gid ,
                                uint32_t const   flags , uint32_t const   cpuid ,
                                uint32_t const   pf_mask , int32_t const   uc_rev ,
                                void const   * const  uc , uint32_t const   uc_size ,
                                int const   strict , struct intel_uclist_entry ** const  uclist ) 
{ 
  struct intel_uclist_entry **pnext ;
  struct intel_uclist_entry *n ;
  int res ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  int dup___0 ;
  int tmp___4 ;
  void *tmp___5 ;
  long tmp___6 ;

  {
#line 279
  res = 0;
#line 281
  if (! cpuid) {
#line 281
    tmp = 1;
  } else
#line 281
  if (! uc) {
#line 281
    tmp = 1;
  } else
#line 281
  if (! uclist) {
#line 281
    tmp = 1;
  } else {
#line 281
    tmp = 0;
  }
  {
#line 281
  tmp___0 = __builtin_expect((long )tmp, 0L);
  }
#line 281
  if (tmp___0) {
#line 282
    return (22);
  }
#line 284
  pnext = (struct intel_uclist_entry **)uclist;
#line 285
  n = (struct intel_uclist_entry *)((void *)0);
  {
#line 288
  while (1) {
    while_continue: /* CIL Label */ ;
#line 288
    if (*pnext) {
#line 288
      if ((*pnext)->cpuid < (uint32_t )cpuid) {
#line 288
        tmp___1 = 1;
      } else {
#line 288
        tmp___1 = 0;
      }
    } else {
#line 288
      tmp___1 = 0;
    }
    {
#line 288
    tmp___2 = __builtin_expect((long )tmp___1, 1L);
    }
#line 288
    if (! tmp___2) {
#line 288
      goto while_break;
    }
#line 289
    pnext = & (*pnext)->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 292
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 292
    tmp___3 = __builtin_expect((long )(! (! *pnext)), 1L);
    }
#line 292
    if (tmp___3) {
#line 292
      if (! ((*pnext)->cpuid == (uint32_t )cpuid)) {
#line 292
        goto while_break___0;
      }
    } else {
#line 292
      goto while_break___0;
    }
#line 293
    if ((*pnext)->pf_mask == (uint32_t )pf_mask) {
#line 293
      if ((*pnext)->uc_rev == (int32_t )uc_rev) {
#line 294
        res = 17;
#line 295
        n = *pnext;
      }
    }
#line 297
    pnext = & (*pnext)->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 300
  if (strict) {
#line 300
    if (res == 17) {
      {
#line 301
      tmp___4 = intel_ucode_compare(uc, (void const   */* const  */)n->uc);
#line 301
      dup___0 = tmp___4;
      }
#line 302
      if (dup___0 == -22) {
#line 303
        return (- dup___0);
      } else
#line 302
      if (dup___0 == -9) {
#line 303
        return (- dup___0);
      }
    }
  }
  {
#line 306
  tmp___5 = malloc(sizeof(struct intel_uclist_entry ));
#line 306
  n = (struct intel_uclist_entry *)tmp___5;
#line 307
  tmp___6 = __builtin_expect((long )(! (! (! n))), 0L);
  }
#line 307
  if (tmp___6) {
#line 308
    return (12);
  }
  {
#line 310
  memset((void *)n, 0, sizeof(struct intel_uclist_entry ));
#line 311
  n->id = (unsigned long )id;
#line 312
  n->gid = (unsigned long )gid;
#line 313
  n->cpuid = (uint32_t )cpuid;
#line 314
  n->pf_mask = (uint32_t )pf_mask;
#line 315
  n->uc_rev = (int32_t )uc_rev;
#line 316
  n->uc = (void const   *)uc;
#line 317
  n->uc_size = (uint32_t )uc_size;
#line 318
  n->flags = (uint32_t )flags;
#line 321
  n->next = *pnext;
#line 322
  *pnext = n;
  }
#line 324
  return (res);
}
}
#line 358 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static int uclist_merge_signature(unsigned long const   id , unsigned long const   gid ,
                                  uint32_t const   cpuid , uint32_t const   pf_mask ,
                                  int32_t const   uc_rev , void const   * const  uc ,
                                  uint32_t const   uc_size , int const   downgrade ,
                                  struct intel_uclist_entry ** const  uclist ) 
{ 
  struct intel_uclist_entry **pnext ;
  struct intel_uclist_entry *n ;
  int tmp ;
  long tmp___0 ;
  struct intel_uclist_entry *e ;
  int rc ;
  int tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  void *tmp___4 ;
  long tmp___5 ;

  {
#line 370
  if (! cpuid) {
#line 370
    tmp = 1;
  } else
#line 370
  if (! uc) {
#line 370
    tmp = 1;
  } else
#line 370
  if (! uclist) {
#line 370
    tmp = 1;
  } else {
#line 370
    tmp = 0;
  }
  {
#line 370
  tmp___0 = __builtin_expect((long )tmp, 0L);
  }
#line 370
  if (tmp___0) {
#line 371
    return (22);
  }
#line 373
  pnext = (struct intel_uclist_entry **)uclist;
  {
#line 378
  while (1) {
    while_continue: /* CIL Label */ ;
#line 378
    if (*pnext) {
#line 378
      if (! ((*pnext)->cpuid < (uint32_t )cpuid)) {
#line 378
        goto while_break;
      }
    } else {
#line 378
      goto while_break;
    }
#line 379
    pnext = & (*pnext)->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 381
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 381
    if (*pnext) {
#line 381
      if (! ((*pnext)->cpuid == (uint32_t )cpuid)) {
#line 381
        goto while_break___0;
      }
    } else {
#line 381
      goto while_break___0;
    }
#line 382
    e = *pnext;
#line 384
    if (pf_mask) {
#line 384
      if ((e->pf_mask & (unsigned int )pf_mask) == 0U) {
#line 384
        tmp___2 = 1;
      } else {
#line 384
        tmp___2 = 0;
      }
    } else {
#line 384
      tmp___2 = 0;
    }
    {
#line 384
    tmp___3 = __builtin_expect((long )tmp___2, 1L);
    }
#line 384
    if (tmp___3) {
#line 386
      pnext = & e->next;
    } else
#line 387
    if (! downgrade) {
#line 387
      goto _L;
    } else
#line 387
    if (gid <= (unsigned long const   )e->gid) {
      _L: /* CIL Label */ 
#line 388
      if ((e->pf_mask & (unsigned int )pf_mask) == (unsigned int )pf_mask) {
#line 390
        if (e->uc_rev >= (int32_t )uc_rev) {
#line 392
          return (17);
        } else
#line 393
        if (pf_mask == (uint32_t const   )e->pf_mask) {
#line 396
          e->id = (unsigned long )id;
#line 397
          e->gid = (unsigned long )gid;
#line 399
          e->pf_mask = (uint32_t )pf_mask;
#line 400
          e->uc_rev = (int32_t )uc_rev;
#line 401
          e->uc = (void const   *)uc;
#line 402
          e->uc_size = (uint32_t )uc_size;
#line 403
          return (0);
        }
#line 405
        pnext = & e->next;
      } else
#line 406
      if ((pf_mask & (unsigned int const   )e->pf_mask) == (unsigned int const   )e->pf_mask) {
#line 408
        if (uc_rev >= (int32_t const   )e->uc_rev) {
          {
#line 410
          e->id = (unsigned long )id;
#line 411
          e->gid = (unsigned long )gid;
#line 413
          e->pf_mask = (uint32_t )pf_mask;
#line 414
          e->uc_rev = (int32_t )uc_rev;
#line 415
          e->uc = (void const   *)uc;
#line 416
          e->uc_size = (uint32_t )uc_size;
#line 418
          xx_uclist_remove_shadowed(gid, cpuid, pf_mask, uc_rev, downgrade, & e->next);
          }
#line 421
          return (0);
        }
#line 423
        pnext = & e->next;
      }
    } else
#line 426
    if (e->pf_mask == (uint32_t )pf_mask) {
#line 427
      if (e->uc_rev == (int32_t )uc_rev) {
#line 427
        tmp___1 = 17;
      } else {
#line 427
        tmp___1 = 0;
      }
#line 427
      rc = tmp___1;
#line 429
      e->id = (unsigned long )id;
#line 430
      e->gid = (unsigned long )gid;
#line 432
      e->pf_mask = (uint32_t )pf_mask;
#line 433
      e->uc_rev = (int32_t )uc_rev;
#line 434
      e->uc = (void const   *)uc;
#line 435
      e->uc_size = (uint32_t )uc_size;
#line 436
      return (rc);
    } else {
#line 439
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 444
  tmp___4 = malloc(sizeof(struct intel_uclist_entry ));
#line 444
  n = (struct intel_uclist_entry *)tmp___4;
#line 445
  tmp___5 = __builtin_expect((long )(! (! (! n))), 0L);
  }
#line 445
  if (tmp___5) {
#line 446
    return (12);
  }
  {
#line 448
  memset((void *)n, 0, sizeof(struct intel_uclist_entry ));
#line 449
  n->id = (unsigned long )id;
#line 450
  n->gid = (unsigned long )gid;
#line 451
  n->cpuid = (uint32_t )cpuid;
#line 452
  n->pf_mask = (uint32_t )pf_mask;
#line 453
  n->uc_rev = (int32_t )uc_rev;
#line 454
  n->uc = (void const   *)uc;
#line 455
  n->uc_size = (uint32_t )uc_size;
#line 458
  n->next = *pnext;
#line 459
  *pnext = n;
#line 461
  xx_uclist_remove_shadowed(gid, cpuid, pf_mask, uc_rev, downgrade, & n->next);
  }
#line 463
  return (0);
}
}
#line 480 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static int add_intel_microcode_bundle(char const   * const  mcb_filename , unsigned long mcb_id ,
                                      void const   * const  mcb , size_t const   mcb_size ) 
{ 
  struct microcode_bundle *b ;
  struct microcode_bundle **p___0 ;
  void *tmp ;
  char *tmp___0 ;

  {
#line 487
  if (mcb) {
#line 487
    if (! (mcb_size >= 1024UL)) {
      {
#line 487
      __assert_fail("mcb && mcb_size >= 1024", "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c",
                    487U, "add_intel_microcode_bundle");
      }
    }
  } else {
    {
#line 487
    __assert_fail("mcb && mcb_size >= 1024", "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c",
                  487U, "add_intel_microcode_bundle");
    }
  }
#line 488
  if (! mcb_filename) {
    {
#line 488
    __assert_fail("mcb_filename", "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c",
                  488U, "add_intel_microcode_bundle");
    }
  }
  {
#line 490
  tmp = malloc(sizeof(struct microcode_bundle ) + (unsigned long )mcb_size);
#line 490
  b = (struct microcode_bundle *)tmp;
  }
#line 491
  if (! b) {
#line 492
    return (12);
  }
  {
#line 494
  memset((void *)b, 0, sizeof(struct microcode_bundle ));
#line 495
  b->id = mcb_id;
#line 496
  tmp___0 = strdup((char const   *)mcb_filename);
#line 496
  b->filename = (char const   *)tmp___0;
#line 497
  b->size = (unsigned long )mcb_size;
#line 498
  b->data = (void const   *)mcb;
#line 501
  p___0 = & microcode_bundles;
  }
  {
#line 502
  while (1) {
    while_continue: /* CIL Label */ ;
#line 502
    if (! *p___0) {
#line 502
      goto while_break;
    }
#line 503
    p___0 = & (*p___0)->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 504
  *p___0 = b;
#line 506
  return (0);
}
}
#line 526 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static int load_intel_microcode_dat(FILE *fp , void **mcb , size_t *mcb_length ) 
{ 
  size_t line_buffer_size ;
  size_t buffer_size_granularity ;
  char *line_buffer ;
  char *lp ;
  size_t mcb_buflen ;
  uint32_t *mcb_buffer ;
  uint32_t *rp ;
  size_t length ;
  size_t pos ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *ep ;
  int *tmp___2 ;
  unsigned long tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;
  unsigned short const   **tmp___7 ;
  unsigned short const   **tmp___8 ;
  long tmp___9 ;
  void *tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  unsigned short const   **tmp___13 ;
  long tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  long tmp___17 ;
  void *tmp___18 ;

  {
#line 528
  line_buffer_size = (size_t )2048;
#line 529
  buffer_size_granularity = (size_t )262144;
#line 530
  line_buffer = (char *)((void *)0);
#line 533
  mcb_buffer = (uint32_t *)((void *)0);
#line 536
  pos = (size_t )0;
#line 539
  if (! mcb) {
    {
#line 539
    __assert_fail("mcb", "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c",
                  539U, "load_intel_microcode_dat");
    }
  }
#line 540
  if (! mcb_length) {
    {
#line 540
    __assert_fail("mcb_length", "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c",
                  540U, "load_intel_microcode_dat");
    }
  }
  {
#line 542
  mcb_buflen = buffer_size_granularity;
#line 543
  tmp = malloc(buffer_size_granularity * sizeof(uint32_t ));
#line 543
  mcb_buffer = (uint32_t *)tmp;
#line 544
  tmp___0 = malloc(line_buffer_size);
#line 544
  line_buffer = (char *)tmp___0;
  }
#line 545
  if (! mcb_buffer) {
#line 546
    err = 12;
#line 547
    goto err_out;
  } else
#line 545
  if (! line_buffer) {
#line 546
    err = 12;
#line 547
    goto err_out;
  }
#line 550
  err = 22;
  {
#line 551
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 551
    tmp___15 = fgets((char */* __restrict  */)line_buffer, (int )line_buffer_size,
                     (FILE */* __restrict  */)fp);
    }
#line 551
    if ((unsigned long )tmp___15 != (unsigned long )((void *)0)) {
#line 551
      tmp___16 = 1;
    } else {
#line 551
      tmp___16 = 0;
    }
    {
#line 551
    tmp___17 = __builtin_expect((long )tmp___16, 1L);
    }
#line 551
    if (! tmp___17) {
#line 551
      goto while_break;
    }
#line 558
    lp = line_buffer;
    {
#line 559
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 559
      tmp___1 = __ctype_b_loc();
      }
#line 559
      if (! ((int const   )*(*tmp___1 + (int )*lp) & 8192)) {
#line 559
        goto while_break___0;
      }
#line 560
      lp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 562
    if (! *lp) {
#line 563
      goto while_continue;
    } else
#line 562
    if ((int )*lp == 47) {
#line 563
      goto while_continue;
    }
    {
#line 565
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 565
      if (! *lp) {
#line 565
        goto while_break___1;
      }
      {
#line 568
      tmp___2 = __errno_location();
#line 568
      *tmp___2 = 0;
#line 569
      tmp___3 = strtoul((char const   */* __restrict  */)lp, (char **/* __restrict  */)(& ep),
                        0);
#line 569
      *(mcb_buffer + pos) = (uint32_t )tmp___3;
#line 570
      tmp___4 = __errno_location();
      }
#line 570
      if (*tmp___4) {
#line 570
        tmp___5 = 1;
      } else {
#line 570
        tmp___5 = 0;
      }
      {
#line 570
      tmp___6 = __builtin_expect((long )tmp___5, 0L);
      }
#line 570
      if (tmp___6) {
#line 571
        goto err_out;
      }
#line 572
      if ((unsigned long )lp == (unsigned long )ep) {
        {
#line 573
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 573
          tmp___7 = __ctype_b_loc();
          }
#line 573
          if (! ((int const   )*(*tmp___7 + (int )*lp) & 8192)) {
#line 573
            goto while_break___2;
          }
#line 574
          lp ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 577
        if ((int )*lp == 44) {
#line 578
          lp ++;
        }
        {
#line 579
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 579
          tmp___8 = __ctype_b_loc();
          }
#line 579
          if (! ((int const   )*(*tmp___8 + (int )*lp) & 8192)) {
#line 579
            goto while_break___3;
          }
#line 580
          lp ++;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 581
        tmp___9 = __builtin_expect((long )(! (! *lp)), 0L);
        }
#line 581
        if (tmp___9) {
#line 582
          goto err_out;
        }
#line 583
        goto while_break___1;
      }
      {
#line 587
      pos ++;
#line 588
      tmp___12 = __builtin_expect((long )(! (! (mcb_buflen < pos))), 0L);
      }
#line 588
      if (tmp___12) {
        {
#line 590
        mcb_buflen += buffer_size_granularity;
#line 591
        tmp___10 = realloc((void *)mcb_buffer, mcb_buflen * sizeof(uint32_t ));
#line 591
        rp = (uint32_t *)tmp___10;
#line 593
        tmp___11 = __builtin_expect((long )(! (! (! rp))), 0L);
        }
#line 593
        if (tmp___11) {
#line 594
          err = 12;
#line 595
          goto err_out;
        }
#line 597
        mcb_buffer = rp;
      }
#line 600
      lp = ep;
      {
#line 602
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 602
        tmp___13 = __ctype_b_loc();
        }
#line 602
        if (! ((int const   )*(*tmp___13 + (int )*lp) & 8192)) {
#line 602
          goto while_break___4;
        }
#line 603
        lp ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 604
      if ((int )*lp == 44) {
#line 605
        lp ++;
#line 606
        goto while_continue___1;
      } else {
        {
#line 607
        tmp___14 = __builtin_expect((long )(! (! *lp)), 0L);
        }
#line 607
        if (tmp___14) {
#line 608
          goto err_out;
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 613
  length = pos * sizeof(uint32_t );
#line 614
  if (length < 1024UL) {
#line 615
    err = 22;
#line 616
    goto err_out;
  }
  {
#line 620
  tmp___18 = realloc((void *)mcb_buffer, length);
#line 620
  rp = (uint32_t *)tmp___18;
  }
#line 621
  if (! rp) {
#line 622
    err = 12;
#line 623
    goto err_out;
  }
#line 626
  *mcb = (void *)rp;
#line 627
  *mcb_length = length;
#line 629
  err = 0;
  err_out: 
#line 632
  if (err) {
    {
#line 633
    free((void *)mcb_buffer);
#line 634
    *mcb = (void *)0;
#line 635
    *mcb_length = (size_t )0;
    }
  }
  {
#line 638
  free((void *)line_buffer);
  }
#line 639
  return (err);
}
}
#line 642 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static int load_intel_microcode_bin(int fd , void **mcb , size_t *mcb_length ) 
{ 
  size_t buffer_size_granularity ;
  int file_size_known ;
  struct stat stat___0 ;
  size_t mcb_size ;
  size_t mcb_space_left ;
  uint8_t *mcb_buffer ;
  uint8_t *rp ;
  size_t pos ;
  int err ;
  int tmp ;
  void *tmp___0 ;
  ssize_t rc ;
  int *tmp___1 ;
  int *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
#line 644
  buffer_size_granularity = (size_t )1048576;
#line 651
  mcb_buffer = (uint8_t *)((void *)0);
#line 657
  if (! mcb) {
    {
#line 657
    __assert_fail("mcb", "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c",
                  657U, "load_intel_microcode_bin");
    }
  }
#line 658
  if (! mcb_length) {
    {
#line 658
    __assert_fail("mcb_length", "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c",
                  658U, "load_intel_microcode_bin");
    }
  }
  {
#line 661
  tmp = fstat(fd, & stat___0);
  }
#line 661
  if (tmp) {
#line 665
    mcb_size = buffer_size_granularity;
#line 666
    file_size_known = 0;
  } else
#line 661
  if ((stat___0.st_mode & 61440U) == 32768U) {
#line 661
    if (stat___0.st_size > 0L) {
#line 662
      mcb_size = (size_t )stat___0.st_size;
#line 663
      file_size_known = 1;
    } else {
#line 665
      mcb_size = buffer_size_granularity;
#line 666
      file_size_known = 0;
    }
  } else {
#line 665
    mcb_size = buffer_size_granularity;
#line 666
    file_size_known = 0;
  }
#line 670
  if (mcb_size < 1024UL) {
#line 671
    err = 22;
#line 672
    goto err_out;
  }
  {
#line 675
  tmp___0 = malloc(mcb_size);
#line 675
  mcb_buffer = (uint8_t *)tmp___0;
  }
#line 676
  if (! mcb_buffer) {
#line 677
    err = 12;
#line 678
    goto err_out;
  }
#line 681
  err = 0;
#line 682
  pos = (size_t )0;
#line 683
  mcb_space_left = mcb_size;
  {
#line 684
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 687
    rc = read(fd, (void *)(mcb_buffer + pos), mcb_space_left);
    }
#line 688
    if (rc == -1L) {
      {
#line 689
      tmp___1 = __errno_location();
      }
#line 689
      if (*tmp___1 == 4) {
#line 690
        goto __Cont;
      }
      {
#line 691
      tmp___2 = __errno_location();
#line 691
      err = - *tmp___2;
      }
#line 692
      goto err_out;
    }
#line 695
    pos += (size_t )rc;
#line 696
    mcb_space_left -= (size_t )rc;
#line 698
    if (rc == 0L) {
#line 699
      goto while_break;
    }
#line 700
    if (file_size_known) {
#line 700
      if (! mcb_space_left) {
#line 701
        goto while_break;
      }
    }
#line 703
    if (! mcb_space_left) {
      {
#line 704
      mcb_size += buffer_size_granularity;
#line 705
      mcb_space_left += buffer_size_granularity;
#line 706
      tmp___3 = realloc((void *)mcb_buffer, mcb_size);
#line 706
      rp = (uint8_t *)tmp___3;
      }
#line 707
      if (! rp) {
#line 708
        err = 12;
#line 709
        goto err_out;
      }
#line 711
      mcb_buffer = rp;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 715
  mcb_size = pos;
#line 716
  if (mcb_size < 1024UL) {
#line 717
    err = 22;
#line 718
    goto err_out;
  }
  {
#line 721
  tmp___4 = realloc((void *)mcb_buffer, mcb_size);
#line 721
  rp = (uint8_t *)tmp___4;
  }
#line 722
  if (! rp) {
#line 723
    err = 12;
#line 724
    goto err_out;
  }
#line 727
  *mcb = (void *)rp;
#line 728
  *mcb_length = mcb_size;
  err_out: 
#line 731
  if (err) {
    {
#line 732
    free((void *)mcb_buffer);
#line 733
    *mcb = (void *)0;
#line 734
    *mcb_length = (size_t )0;
    }
  }
#line 737
  return (err);
}
}
#line 740 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static int load_intel_microcode_file(int fd , FILE *fp , char const   * const  fn ,
                                     intel_ucode_file_type_t const   ftype ) 
{ 
  int err ;
  void *mcb ;
  size_t mcb_length ;
  int *tmp ;
  char *tmp___0 ;

  {
#line 745
  err = 0;
#line 747
  mcb = (void *)0;
#line 748
  mcb_length = (size_t )0;
  {
#line 751
  if ((unsigned int const   )ftype == 2U) {
#line 751
    goto case_2;
  }
#line 755
  if ((unsigned int const   )ftype == 1U) {
#line 755
    goto case_1;
  }
#line 766
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 752
  err = load_intel_microcode_bin(fd, & mcb, & mcb_length);
  }
#line 753
  goto switch_break;
  case_1: /* CIL Label */ 
#line 756
  if (! fp) {
    {
#line 757
    fp = fdopen(fd, "r");
    }
  }
#line 759
  if (fp) {
    {
#line 760
    err = load_intel_microcode_dat(fp, & mcb, & mcb_length);
    }
  } else {
    {
#line 762
    tmp = __errno_location();
#line 762
    err = - *tmp;
    }
  }
#line 764
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 767
  err = 95;
  switch_break: /* CIL Label */ ;
  }
#line 770
  if (err < 0) {
    {
#line 771
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 771
      tmp___0 = strerror(- err);
#line 771
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: could not read: %s\n",
              progname, fn, tmp___0);
      }
#line 771
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 772
    goto err_out;
  }
#line 775
  if (! err) {
#line 775
    if (mcb) {
#line 775
      if (mcb_length) {
        {
#line 776
        last_bundle_id ++;
#line 777
        err = add_intel_microcode_bundle(fn, last_bundle_id, (void const   */* const  */)mcb,
                                         (size_t const   )mcb_length);
        }
#line 779
        if (! err) {
#line 780
          mcb = (void *)0;
        }
      }
    }
  }
  {
#line 784
  if (err == 0) {
#line 784
    goto case_0;
  }
#line 788
  if (err == 12) {
#line 788
    goto case_12;
  }
#line 791
  if (err == 22) {
#line 791
    goto case_22;
  }
#line 783
  goto switch_break___0;
  case_0: /* CIL Label */ 
  {
#line 785
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 785
    if (verbosity >= 2) {
      {
#line 785
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: microcode bundle %lu: %s (%zu bytes)\n",
              progname, last_bundle_id, fn, mcb_length);
      }
    }
#line 785
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 787
  goto switch_break___0;
  case_12: /* CIL Label */ 
  {
#line 789
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 789
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: could not allocate memory while loading\n",
            progname, fn);
    }
#line 789
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 790
  goto switch_break___0;
  case_22: /* CIL Label */ 
  {
#line 792
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 792
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: invalid file format\n",
            progname, fn);
    }
#line 792
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 793
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  err_out: 
#line 797
  if (fp) {
    {
#line 798
    fclose(fp);
    }
  } else
#line 799
  if (fd != -1) {
    {
#line 800
    close(fd);
    }
  }
#line 802
  return (err);
}
}
#line 805 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static int load_intel_microcode(char const   *path , intel_ucode_file_type_t const   baseftype ) 
{ 
  int fd ;
  DIR *dir ;
  int err ;
  char fnbuf[4096] ;
  char const   *fn ;
  intel_ucode_file_type_t ftype ;
  int tmp ;
  int tmp___0 ;
  struct stat st ;
  struct dirent *dentry ;
  int *tmp___1 ;
  int s ;
  int tmp___2 ;
  long tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  long tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  long tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  long tmp___15 ;
  int *tmp___16 ;
  char *tmp___17 ;
  char *p___0 ;
  int tmp___18 ;

  {
#line 808
  fd = -1;
#line 817
  if (! path) {
    {
#line 817
    __assert_fail("path", "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c",
                  817U, "load_intel_microcode");
    }
  }
  {
#line 820
  tmp___0 = is_dash((char const   */* const  */)path);
  }
#line 820
  if (tmp___0) {
#line 821
    ftype = (intel_ucode_file_type_t )baseftype;
#line 824
    if ((unsigned int )ftype == 0U) {
#line 825
      ftype = (intel_ucode_file_type_t )1;
    }
    {
#line 827
    tmp = load_intel_microcode_file(0, stdin, (char const   */* const  */)"(stdin)",
                                    (intel_ucode_file_type_t const   )ftype);
    }
#line 827
    return (tmp);
  }
#line 830
  dir = (DIR *)((void *)0);
#line 831
  fn = path;
  {
#line 833
  while (1) {
    while_continue: /* CIL Label */ ;
#line 837
    err = 0;
#line 839
    if (fd != -1) {
      {
#line 840
      close(fd);
      }
    }
#line 842
    if (dir) {
      {
#line 843
      tmp___1 = __errno_location();
#line 843
      *tmp___1 = 0;
#line 844
      dentry = readdir(dir);
      }
#line 845
      if (dentry) {
#line 848
        if ((int )dentry->d_name[0] == 46) {
#line 849
          goto __Cont;
        }
        {
#line 851
        s = snprintf((char */* __restrict  */)(fnbuf), sizeof(fnbuf), (char const   */* __restrict  */)"%s/%s",
                     path, dentry->d_name);
        }
#line 853
        if (s < 1) {
#line 853
          tmp___2 = 1;
        } else
#line 853
        if ((unsigned long )((unsigned int )s) >= sizeof(fnbuf)) {
#line 853
          tmp___2 = 1;
        } else {
#line 853
          tmp___2 = 0;
        }
        {
#line 853
        tmp___3 = __builtin_expect((long )tmp___2, 0L);
        }
#line 853
        if (tmp___3) {
          {
#line 854
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 854
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s/%s: path too long\n",
                    progname, path, dentry->d_name);
            }
#line 854
            goto while_break___0;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 856
          err = -36;
#line 857
          goto __Cont;
        }
#line 859
        fn = (char const   *)(fnbuf);
      } else {
        {
#line 861
        tmp___4 = __errno_location();
#line 861
        err = *tmp___4;
#line 862
        tmp___6 = __builtin_expect((long )(! (! err)), 0L);
        }
#line 862
        if (tmp___6) {
          {
#line 863
          while (1) {
            while_continue___1: /* CIL Label */ ;
            {
#line 863
            tmp___5 = strerror(err);
#line 863
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: cannot walk directory: %s\n",
                    progname, path, tmp___5);
            }
#line 863
            goto while_break___1;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 865
          err = - err;
        }
#line 867
        goto while_break;
      }
    }
#line 871
    if (dir) {
      {
#line 872
      tmp___7 = dirfd(dir);
#line 872
      fd = openat(tmp___7, (char const   *)(dentry->d_name), 0);
      }
    } else {
      {
#line 874
      fd = open(fn, 0);
      }
    }
    {
#line 876
    tmp___10 = __builtin_expect((long )(! (! (fd == -1))), 0L);
    }
#line 876
    if (tmp___10) {
      {
#line 877
      tmp___8 = __errno_location();
#line 877
      err = *tmp___8;
      }
      {
#line 878
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 878
        tmp___9 = strerror(err);
#line 878
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: cannot open: %s\n",
                progname, fn, tmp___9);
        }
#line 878
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 879
      err = - err;
#line 880
      goto __Cont;
    }
    {
#line 882
    tmp___13 = fstat(fd, & st);
    }
#line 882
    if (tmp___13 == -1) {
#line 882
      tmp___14 = 1;
    } else {
#line 882
      tmp___14 = 0;
    }
    {
#line 882
    tmp___15 = __builtin_expect((long )tmp___14, 0L);
    }
#line 882
    if (tmp___15) {
      {
#line 883
      tmp___11 = __errno_location();
#line 883
      err = *tmp___11;
      }
      {
#line 884
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 884
        tmp___12 = strerror(err);
#line 884
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: cannot stat inode: %s\n",
                progname, fn, tmp___12);
        }
#line 884
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 886
      err = - err;
#line 887
      goto __Cont;
    }
#line 889
    if ((st.st_mode & 61440U) == 16384U) {
#line 890
      if (! dir) {
        {
#line 891
        dir = fdopendir(fd);
        }
#line 892
        if (! dir) {
          {
#line 893
          tmp___16 = __errno_location();
#line 893
          err = *tmp___16;
          }
          {
#line 894
          while (1) {
            while_continue___4: /* CIL Label */ ;
            {
#line 894
            tmp___17 = strerror(err);
#line 894
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: cannot open directory: %s\n",
                    progname, path, tmp___17);
            }
#line 894
            goto while_break___4;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 896
          err = - err;
#line 897
          goto __Cont;
        }
#line 899
        fd = -1;
      } else {
        {
#line 901
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 901
          if (verbosity >= 1) {
            {
#line 901
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: skipping nested directory: %s\n",
                    progname, path, fn);
            }
          }
#line 901
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
      }
#line 904
      goto __Cont;
    }
#line 907
    if ((st.st_mode & 61440U) == 32768U) {
#line 907
      if (st.st_size == 0L) {
#line 908
        goto __Cont;
      }
    }
#line 910
    ftype = (intel_ucode_file_type_t )baseftype;
#line 911
    if ((unsigned int )ftype == 0U) {
#line 911
      if ((st.st_mode & 61440U) == 32768U) {
        {
#line 915
        p___0 = strrchr(fn, '.');
        }
#line 916
        if (p___0) {
          {
#line 917
          tmp___18 = strcasecmp((char const   *)(p___0 + 1), "dat");
          }
#line 917
          if (! tmp___18) {
#line 918
            ftype = (intel_ucode_file_type_t )1;
          }
        }
      }
    }
#line 931
    if ((unsigned int )ftype == 0U) {
#line 932
      ftype = (intel_ucode_file_type_t )2;
    }
    {
#line 934
    err = load_intel_microcode_file(fd, (FILE *)((void *)0), (char const   */* const  */)fn,
                                    (intel_ucode_file_type_t const   )ftype);
    }
    __Cont: /* CIL Label */ 
#line 833
    if (dir) {
#line 833
      if (! (! err)) {
#line 833
        if (! ignore_bad_ucode) {
#line 833
          goto while_break;
        }
      }
    } else {
#line 833
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 937
  if (dir) {
    {
#line 938
    closedir(dir);
    }
  }
#line 939
  if (fd != -1) {
    {
#line 940
    close(fd);
    }
  }
#line 941
  return (err);
}
}
#line 946 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static ssize_t write_data(int const   fd , void const   * const  data , uint32_t const   size ) 
{ 
  char const   *p___0 ;
  size_t len ;
  ssize_t s ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
#line 950
  p___0 = (char const   *)data;
#line 951
  len = (size_t )size;
  {
#line 954
  while (1) {
    while_continue: /* CIL Label */ ;
#line 954
    if (! (len > 0UL)) {
#line 954
      goto while_break;
    }
    {
#line 955
    s = write((int )fd, (void const   *)p___0, len);
    }
#line 956
    if (s < 0L) {
      {
#line 957
      tmp___3 = __errno_location();
      }
#line 957
      if (*tmp___3 != 4) {
        {
#line 958
        tmp___2 = __errno_location();
        }
#line 958
        if (*tmp___2) {
          {
#line 958
          tmp___0 = __errno_location();
#line 958
          tmp___1 = - *tmp___0;
          }
        } else {
#line 958
          tmp___1 = -22;
        }
#line 958
        return ((ssize_t )tmp___1);
      }
    } else {
#line 960
      p___0 += s;
#line 961
      len -= (size_t )s;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 965
  return ((ssize_t )size);
}
}
#line 968 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static void log_microcode_action(char const   * const  action , char const   * const  devname ,
                                 struct intel_uclist_entry  const  * const  uce ) 
{ 
  char id_str[20] ;

  {
  {
#line 974
  str_append_ucode_id((unsigned long )uce->id, (unsigned long )uce->gid, id_str, (unsigned int )sizeof(id_str));
  }
  {
#line 975
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 975
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: %s microcode %s (sig 0x%08x, pf_mask 0x%02x, rev 0x%04x)\n",
            progname, devname, action, id_str, uce->cpuid, uce->pf_mask, uce->uc_rev);
    }
#line 975
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 978
  return;
}
}
#line 987 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static int upload_intel_microcodes(char const   * const  devname , struct intel_uclist_entry *uc_write_list ) 
{ 
  int fd ;
  struct stat stat___0 ;
  int err ;
  size_t total_written ;
  unsigned int entries_written ;
  ssize_t rc ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;

  {
#line 992
  err = 0;
#line 993
  total_written = (size_t )0;
#line 994
  entries_written = 0U;
#line 997
  if (! uc_write_list) {
    {
#line 997
    __assert_fail("uc_write_list", "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c",
                  997U, "upload_intel_microcodes");
    }
  }
#line 998
  if (! devname) {
    {
#line 998
    __assert_fail("devname", "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c",
                  998U, "upload_intel_microcodes");
    }
  }
  {
#line 1000
  fd = open((char const   *)devname, 1);
  }
#line 1001
  if (fd == -1) {
    {
#line 1002
    tmp = __errno_location();
#line 1002
    err = *tmp;
    }
    {
#line 1003
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1003
      tmp___0 = strerror(err);
#line 1003
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: cannot open for writing: %s\n",
              progname, devname, tmp___0);
      }
#line 1003
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 1005
    return (err);
  }
  {
#line 1008
  tmp___3 = fstat(fd, & stat___0);
  }
#line 1008
  if (tmp___3 == -1) {
    {
#line 1009
    tmp___1 = __errno_location();
#line 1009
    err = *tmp___1;
    }
    {
#line 1010
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1010
      tmp___2 = strerror(err);
#line 1010
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: cannot stat: %s\n",
              progname, devname, tmp___2);
      }
#line 1010
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1011
    close(fd);
    }
#line 1012
    return (err);
  }
#line 1014
  if (! ((stat___0.st_mode & 61440U) == 8192U)) {
    {
#line 1015
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1015
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: not a character device\n",
              progname, devname);
      }
#line 1015
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1016
    close(fd);
    }
#line 1017
    return (22);
  }
  {
#line 1020
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1020
    if (uc_write_list) {
#line 1020
      if (! uc_write_list->uc) {
#line 1020
        goto while_break___2;
      }
    } else {
#line 1020
      goto while_break___2;
    }
#line 1021
    if (verbosity >= 3) {
      {
#line 1022
      log_microcode_action((char const   */* const  */)"uploading", devname, (struct intel_uclist_entry  const  */* const  */)uc_write_list);
      }
    }
    {
#line 1025
    rc = write_data((int const   )fd, (void const   */* const  */)uc_write_list->uc,
                    (uint32_t const   )uc_write_list->uc_size);
    }
#line 1027
    if (rc < 0L) {
#line 1028
      err = (int )(- rc);
      {
#line 1029
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 1029
        tmp___4 = strerror(err);
#line 1029
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: write error: %s\n",
                progname, devname, tmp___4);
        }
#line 1029
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1031
      goto while_break___2;
    } else {
#line 1033
      total_written += (size_t )rc;
#line 1034
      uc_write_list = uc_write_list->next;
#line 1035
      entries_written ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1039
  tmp___7 = close(fd);
  }
#line 1039
  if (tmp___7) {
    {
#line 1040
    tmp___5 = __errno_location();
#line 1040
    err = *tmp___5;
    }
    {
#line 1041
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 1041
      tmp___6 = strerror(err);
#line 1041
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: error while closing device: %s\n",
              progname, devname, tmp___6);
      }
#line 1041
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 1045
  if (! err) {
    {
#line 1046
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1046
      if (verbosity >= 2) {
        {
#line 1046
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: %u microcode entries uploaded, %zu bytes\n",
                progname, devname, entries_written, total_written);
        }
      }
#line 1046
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 1049
  return (err);
}
}
#line 1059
static int xx_write_cpio_hdrentry(int fd , char const   * const  name , size_t const   size ,
                                  size_t *pos ) ;
#line 1059 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static int ino  =    100;
#line 1056 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static int xx_write_cpio_hdrentry(int fd , char const   * const  name , size_t const   size ,
                                  size_t *pos ) 
{ 
  char buf[(110UL + sizeof("kernel/x86/microcode/GenuineIntel.bin")) + 16UL] ;
  int nsize ;
  int bufsize ;
  size_t tmp ;
  time_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  ssize_t tmp___3 ;

  {
#line 1065
  if (! name) {
    {
#line 1065
    __assert_fail("name", "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c",
                  1065U, "xx_write_cpio_hdrentry");
    }
  }
  {
#line 1066
  tmp = strlen((char const   *)name);
#line 1066
  nsize = (int )(tmp + 1UL);
#line 1068
  ino ++;
#line 1071
  bufsize = 110 + nsize;
  }
  {
#line 1072
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1072
    if (! ((*pos + (size_t )bufsize) % 4UL)) {
#line 1072
      goto while_break;
    }
#line 1073
    bufsize ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1079
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1079
    if (size) {
#line 1079
      if (! ((*pos + (size_t )bufsize) % 16UL)) {
#line 1079
        goto while_break___0;
      }
    } else {
#line 1079
      goto while_break___0;
    }
#line 1080
    bufsize ++;
#line 1081
    nsize ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1084
  *pos += (size_t )bufsize;
#line 1086
  memset((void *)(buf), 0, sizeof(buf));
#line 1087
  tmp___0 = time((time_t *)((void *)0));
  }
#line 1087
  if (size) {
#line 1087
    tmp___1 = 1;
  } else {
#line 1087
    tmp___1 = 2;
  }
#line 1087
  if (size) {
#line 1087
    tmp___2 = 33188;
  } else {
#line 1087
    tmp___2 = 16877;
  }
  {
#line 1087
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"070701%08X%08X%08X%08X%08X%08lX%08zX%08X%08X%08X%08X%08X%08X%s",
           ino, tmp___2, 0, 0, tmp___1, tmp___0, size, 3, 1, 0, 0, nsize, 0, name);
#line 1097
  tmp___3 = write_data((int const   )fd, (void const   */* const  */)(buf), (uint32_t const   )bufsize);
  }
#line 1097
  return ((int )tmp___3);
}
}
#line 1114 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static int write_cpio_header(int fd , size_t size ) 
{ 
  char fn[38] ;
  char *p1 ;
  char *p2 ;
  size_t pos ;
  int r ;

  {
#line 1116
  fn[0] = (char )'k';
#line 1116
  fn[1] = (char )'e';
#line 1116
  fn[2] = (char )'r';
#line 1116
  fn[3] = (char )'n';
#line 1116
  fn[4] = (char )'e';
#line 1116
  fn[5] = (char )'l';
#line 1116
  fn[6] = (char )'/';
#line 1116
  fn[7] = (char )'x';
#line 1116
  fn[8] = (char )'8';
#line 1116
  fn[9] = (char )'6';
#line 1116
  fn[10] = (char )'/';
#line 1116
  fn[11] = (char )'m';
#line 1116
  fn[12] = (char )'i';
#line 1116
  fn[13] = (char )'c';
#line 1116
  fn[14] = (char )'r';
#line 1116
  fn[15] = (char )'o';
#line 1116
  fn[16] = (char )'c';
#line 1116
  fn[17] = (char )'o';
#line 1116
  fn[18] = (char )'d';
#line 1116
  fn[19] = (char )'e';
#line 1116
  fn[20] = (char )'/';
#line 1116
  fn[21] = (char )'G';
#line 1116
  fn[22] = (char )'e';
#line 1116
  fn[23] = (char )'n';
#line 1116
  fn[24] = (char )'u';
#line 1116
  fn[25] = (char )'i';
#line 1116
  fn[26] = (char )'n';
#line 1116
  fn[27] = (char )'e';
#line 1116
  fn[28] = (char )'I';
#line 1116
  fn[29] = (char )'n';
#line 1116
  fn[30] = (char )'t';
#line 1116
  fn[31] = (char )'e';
#line 1116
  fn[32] = (char )'l';
#line 1116
  fn[33] = (char )'.';
#line 1116
  fn[34] = (char )'b';
#line 1116
  fn[35] = (char )'i';
#line 1116
  fn[36] = (char )'n';
#line 1116
  fn[37] = (char )'\000';
#line 1118
  pos = (size_t )0;
#line 1121
  p1 = fn;
  {
#line 1122
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1123
    p2 = strchr((char const   *)p1, '/');
    }
#line 1124
    if (p2) {
      {
#line 1125
      *p2 = (char)0;
#line 1126
      r = xx_write_cpio_hdrentry(fd, (char const   */* const  */)(fn), (size_t const   )0,
                                 & pos);
      }
#line 1127
      if (r < 0) {
#line 1128
        return (r);
      }
#line 1129
      *p2 = (char )'/';
#line 1130
      p2 ++;
#line 1130
      p1 = p2;
    }
#line 1122
    if (! p2) {
#line 1122
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1134
  r = xx_write_cpio_hdrentry(fd, (char const   */* const  */)(fn), (size_t const   )size,
                             & pos);
  }
#line 1135
  if (r < 0) {
#line 1136
    return (r);
  }
#line 1138
  return ((int )pos);
}
}
#line 1153 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static int write_cpio_trailer(int fd , size_t pos ) 
{ 
  char cpio_trailer[137] ;
  size_t s ;
  ssize_t tmp ;

  {
#line 1155
  cpio_trailer[0] = (char )'0';
#line 1155
  cpio_trailer[1] = (char )'7';
#line 1155
  cpio_trailer[2] = (char )'0';
#line 1155
  cpio_trailer[3] = (char )'7';
#line 1155
  cpio_trailer[4] = (char )'0';
#line 1155
  cpio_trailer[5] = (char )'1';
#line 1155
  cpio_trailer[6] = (char )'0';
#line 1155
  cpio_trailer[7] = (char )'0';
#line 1155
  cpio_trailer[8] = (char )'0';
#line 1155
  cpio_trailer[9] = (char )'0';
#line 1155
  cpio_trailer[10] = (char )'0';
#line 1155
  cpio_trailer[11] = (char )'0';
#line 1155
  cpio_trailer[12] = (char )'0';
#line 1155
  cpio_trailer[13] = (char )'0';
#line 1155
  cpio_trailer[14] = (char )'0';
#line 1155
  cpio_trailer[15] = (char )'0';
#line 1155
  cpio_trailer[16] = (char )'0';
#line 1155
  cpio_trailer[17] = (char )'0';
#line 1155
  cpio_trailer[18] = (char )'0';
#line 1155
  cpio_trailer[19] = (char )'0';
#line 1155
  cpio_trailer[20] = (char )'0';
#line 1155
  cpio_trailer[21] = (char )'0';
#line 1155
  cpio_trailer[22] = (char )'0';
#line 1155
  cpio_trailer[23] = (char )'0';
#line 1155
  cpio_trailer[24] = (char )'0';
#line 1155
  cpio_trailer[25] = (char )'0';
#line 1155
  cpio_trailer[26] = (char )'0';
#line 1155
  cpio_trailer[27] = (char )'0';
#line 1155
  cpio_trailer[28] = (char )'0';
#line 1155
  cpio_trailer[29] = (char )'0';
#line 1155
  cpio_trailer[30] = (char )'0';
#line 1155
  cpio_trailer[31] = (char )'0';
#line 1155
  cpio_trailer[32] = (char )'0';
#line 1155
  cpio_trailer[33] = (char )'0';
#line 1155
  cpio_trailer[34] = (char )'0';
#line 1155
  cpio_trailer[35] = (char )'0';
#line 1155
  cpio_trailer[36] = (char )'0';
#line 1155
  cpio_trailer[37] = (char )'0';
#line 1155
  cpio_trailer[38] = (char )'0';
#line 1155
  cpio_trailer[39] = (char )'0';
#line 1155
  cpio_trailer[40] = (char )'0';
#line 1155
  cpio_trailer[41] = (char )'0';
#line 1155
  cpio_trailer[42] = (char )'0';
#line 1155
  cpio_trailer[43] = (char )'0';
#line 1155
  cpio_trailer[44] = (char )'0';
#line 1155
  cpio_trailer[45] = (char )'1';
#line 1155
  cpio_trailer[46] = (char )'0';
#line 1155
  cpio_trailer[47] = (char )'0';
#line 1155
  cpio_trailer[48] = (char )'0';
#line 1155
  cpio_trailer[49] = (char )'0';
#line 1155
  cpio_trailer[50] = (char )'0';
#line 1155
  cpio_trailer[51] = (char )'0';
#line 1155
  cpio_trailer[52] = (char )'0';
#line 1155
  cpio_trailer[53] = (char )'0';
#line 1155
  cpio_trailer[54] = (char )'0';
#line 1155
  cpio_trailer[55] = (char )'0';
#line 1155
  cpio_trailer[56] = (char )'0';
#line 1155
  cpio_trailer[57] = (char )'0';
#line 1155
  cpio_trailer[58] = (char )'0';
#line 1155
  cpio_trailer[59] = (char )'0';
#line 1155
  cpio_trailer[60] = (char )'0';
#line 1155
  cpio_trailer[61] = (char )'0';
#line 1155
  cpio_trailer[62] = (char )'0';
#line 1155
  cpio_trailer[63] = (char )'0';
#line 1155
  cpio_trailer[64] = (char )'0';
#line 1155
  cpio_trailer[65] = (char )'0';
#line 1155
  cpio_trailer[66] = (char )'0';
#line 1155
  cpio_trailer[67] = (char )'0';
#line 1155
  cpio_trailer[68] = (char )'0';
#line 1155
  cpio_trailer[69] = (char )'0';
#line 1155
  cpio_trailer[70] = (char )'0';
#line 1155
  cpio_trailer[71] = (char )'0';
#line 1155
  cpio_trailer[72] = (char )'0';
#line 1155
  cpio_trailer[73] = (char )'0';
#line 1155
  cpio_trailer[74] = (char )'0';
#line 1155
  cpio_trailer[75] = (char )'0';
#line 1155
  cpio_trailer[76] = (char )'0';
#line 1155
  cpio_trailer[77] = (char )'0';
#line 1155
  cpio_trailer[78] = (char )'0';
#line 1155
  cpio_trailer[79] = (char )'0';
#line 1155
  cpio_trailer[80] = (char )'0';
#line 1155
  cpio_trailer[81] = (char )'0';
#line 1155
  cpio_trailer[82] = (char )'0';
#line 1155
  cpio_trailer[83] = (char )'0';
#line 1155
  cpio_trailer[84] = (char )'0';
#line 1155
  cpio_trailer[85] = (char )'0';
#line 1155
  cpio_trailer[86] = (char )'0';
#line 1155
  cpio_trailer[87] = (char )'0';
#line 1155
  cpio_trailer[88] = (char )'0';
#line 1155
  cpio_trailer[89] = (char )'0';
#line 1155
  cpio_trailer[90] = (char )'0';
#line 1155
  cpio_trailer[91] = (char )'0';
#line 1155
  cpio_trailer[92] = (char )'0';
#line 1155
  cpio_trailer[93] = (char )'0';
#line 1155
  cpio_trailer[94] = (char )'0';
#line 1155
  cpio_trailer[95] = (char )'0';
#line 1155
  cpio_trailer[96] = (char )'0';
#line 1155
  cpio_trailer[97] = (char )'0';
#line 1155
  cpio_trailer[98] = (char )'0';
#line 1155
  cpio_trailer[99] = (char )'0';
#line 1155
  cpio_trailer[100] = (char )'0';
#line 1155
  cpio_trailer[101] = (char )'B';
#line 1155
  cpio_trailer[102] = (char )'0';
#line 1155
  cpio_trailer[103] = (char )'0';
#line 1155
  cpio_trailer[104] = (char )'0';
#line 1155
  cpio_trailer[105] = (char )'0';
#line 1155
  cpio_trailer[106] = (char )'0';
#line 1155
  cpio_trailer[107] = (char )'0';
#line 1155
  cpio_trailer[108] = (char )'0';
#line 1155
  cpio_trailer[109] = (char )'0';
#line 1155
  cpio_trailer[110] = (char )'T';
#line 1155
  cpio_trailer[111] = (char )'R';
#line 1155
  cpio_trailer[112] = (char )'A';
#line 1155
  cpio_trailer[113] = (char )'I';
#line 1155
  cpio_trailer[114] = (char )'L';
#line 1155
  cpio_trailer[115] = (char )'E';
#line 1155
  cpio_trailer[116] = (char )'R';
#line 1155
  cpio_trailer[117] = (char )'!';
#line 1155
  cpio_trailer[118] = (char )'!';
#line 1155
  cpio_trailer[119] = (char )'!';
#line 1155
  cpio_trailer[120] = (char )'\000';
#line 1155
  cpio_trailer[121] = (char )'\000';
#line 1155
  cpio_trailer[122] = (char )'\000';
#line 1155
  cpio_trailer[123] = (char )'\000';
#line 1155
  cpio_trailer[124] = (char )'\000';
#line 1155
  cpio_trailer[125] = (char )'\000';
#line 1155
  cpio_trailer[126] = (char )'\000';
#line 1155
  cpio_trailer[127] = (char )'\000';
#line 1155
  cpio_trailer[128] = (char )'\000';
#line 1155
  cpio_trailer[129] = (char )'\000';
#line 1155
  cpio_trailer[130] = (char )'\000';
#line 1155
  cpio_trailer[131] = (char )'\000';
#line 1155
  cpio_trailer[132] = (char )'\000';
#line 1155
  cpio_trailer[133] = (char )'\000';
#line 1155
  cpio_trailer[134] = (char )'\000';
#line 1155
  cpio_trailer[135] = (char )'\000';
#line 1155
  cpio_trailer[136] = (char )'\000';
#line 1167
  s = sizeof(cpio_trailer) - 16UL;
  {
#line 1168
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1168
    if (! ((pos + s) % 16UL)) {
#line 1168
      goto while_break;
    }
#line 1169
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1171
  tmp = write_data((int const   )fd, (void const   */* const  */)(cpio_trailer), (uint32_t const   )s);
  }
#line 1171
  return ((int )tmp);
}
}
#line 1201 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static int write_intel_microcodes(int const   dirfd___0 , char const   * const  filename ,
                                  int ft , struct intel_uclist_entry *uc_write_list ) 
{ 
  int fd ;
  int err ;
  size_t total_written ;
  unsigned int entries_written ;
  ssize_t rc ;
  struct intel_uclist_entry *e ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;
  int tmp___7 ;
  long tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;

  {
#line 1206
  err = 0;
#line 1208
  entries_written = 0U;
#line 1212
  if (! uc_write_list) {
    {
#line 1212
    __assert_fail("uc_write_list", "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c",
                  1212U, "write_intel_microcodes");
    }
  }
#line 1213
  if (! filename) {
    {
#line 1213
    __assert_fail("filename", "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c",
                  1213U, "write_intel_microcodes");
    }
  }
#line 1216
  if (unlink_files) {
    {
#line 1217
    tmp___2 = unlinkat((int )dirfd___0, (char const   *)filename, 0);
    }
#line 1217
    if (tmp___2 == -1) {
      {
#line 1218
      tmp___1 = __errno_location();
      }
#line 1218
      if (*tmp___1 != 2) {
        {
#line 1219
        tmp = __errno_location();
#line 1219
        err = *tmp;
        }
        {
#line 1220
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 1220
          tmp___0 = strerror(err);
#line 1220
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: cannot unlink: %s\n",
                  progname, filename, tmp___0);
          }
#line 1220
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
#line 1222
        return (err);
      }
    } else {
      {
#line 1225
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1225
        if (verbosity >= 3) {
          {
#line 1225
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: unlinked %s\n",
                  progname, filename);
          }
        }
#line 1225
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  {
#line 1229
  fd = openat((int )dirfd___0, (char const   *)filename, 193, (384 | (256 >> 3)) | ((256 >> 3) >> 3));
  }
#line 1231
  if (fd == -1) {
    {
#line 1232
    tmp___3 = __errno_location();
#line 1232
    err = *tmp___3;
    }
    {
#line 1233
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1233
      tmp___4 = strerror(err);
#line 1233
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: cannot write to, or create file: %s\n",
              progname, filename, tmp___4);
      }
#line 1233
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1235
    return (err);
  }
#line 1242
  e = uc_write_list;
#line 1243
  total_written = (size_t )0;
  {
#line 1244
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1244
    if (e) {
#line 1244
      if (! e->uc) {
#line 1244
        goto while_break___2;
      }
    } else {
#line 1244
      goto while_break___2;
    }
#line 1245
    total_written += (size_t )e->uc_size;
#line 1246
    e = e->next;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1249
  if (ft == 1) {
    {
#line 1250
    tmp___5 = write_cpio_header(fd, total_written);
#line 1250
    rc = (ssize_t )tmp___5;
    }
#line 1251
    if (rc < 0L) {
#line 1252
      goto error;
    }
#line 1253
    total_written += (size_t )rc;
  }
  {
#line 1256
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1256
    if (uc_write_list) {
#line 1256
      if (! uc_write_list->uc) {
#line 1256
        goto while_break___3;
      }
    } else {
#line 1256
      goto while_break___3;
    }
#line 1257
    if (verbosity >= 3) {
      {
#line 1258
      log_microcode_action((char const   */* const  */)"writing", filename, (struct intel_uclist_entry  const  */* const  */)uc_write_list);
      }
    }
    {
#line 1261
    rc = write_data((int const   )fd, (void const   */* const  */)uc_write_list->uc,
                    (uint32_t const   )uc_write_list->uc_size);
#line 1263
    tmp___6 = __builtin_expect((long )(! (! (rc < 0L))), 0L);
    }
#line 1263
    if (tmp___6) {
#line 1264
      goto error;
    }
#line 1266
    uc_write_list = uc_write_list->next;
#line 1267
    entries_written ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1270
  if (ft == 1) {
    {
#line 1271
    tmp___7 = write_cpio_trailer(fd, total_written);
#line 1271
    rc = (ssize_t )tmp___7;
#line 1272
    tmp___8 = __builtin_expect((long )(! (! (rc < 0L))), 0L);
    }
#line 1272
    if (tmp___8) {
#line 1273
      goto error;
    }
#line 1274
    total_written += (size_t )rc;
  }
  {
#line 1277
  tmp___11 = close(fd);
  }
#line 1277
  if (tmp___11) {
    {
#line 1278
    tmp___9 = __errno_location();
#line 1278
    err = *tmp___9;
    }
    {
#line 1279
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 1279
      tmp___10 = strerror(err);
#line 1279
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: error while closing file: %s\n",
              progname, filename, tmp___10);
      }
#line 1279
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 1283
  if (! err) {
    {
#line 1284
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1284
      if (verbosity >= 2) {
        {
#line 1284
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: %u microcode entries written, %zu bytes\n",
                progname, filename, entries_written, total_written);
        }
      }
#line 1284
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 1287
  return (err);
  error: 
#line 1290
  err = (int )(- rc);
  {
#line 1291
  while (1) {
    while_continue___6: /* CIL Label */ ;
    {
#line 1291
    tmp___12 = strerror(err);
#line 1291
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: write error: %s\n",
            progname, filename, tmp___12);
    }
#line 1291
    goto while_break___6;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 1292
  return (err);
}
}
#line 1299 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static int is_in_date_range(struct intel_ucode_metadata  const  * const  m ) 
{ 
  uint32_t d ;
  int tmp ;

  {
#line 1301
  d = (uint32_t )((((int const   )m->date_year << 16) | ((int const   )m->date_month << 8)) | (int const   )m->date_day);
#line 1303
  if (d > datefilter_min) {
#line 1303
    if (d < datefilter_max) {
#line 1303
      tmp = 1;
    } else {
#line 1303
      tmp = 0;
    }
  } else {
#line 1303
    tmp = 0;
  }
#line 1303
  return (tmp);
}
}
#line 1308 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static struct microcode_filter_entry *p  ;
#line 1306 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static void free_filter_list(struct microcode_filter_entry *f ) 
{ 


  {
  {
#line 1310
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1310
    if (! f) {
#line 1310
      goto while_break;
    }
    {
#line 1311
    p = f;
#line 1312
    f = f->next;
#line 1313
    free((void *)p);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1315
  return;
}
}
#line 1317 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static void xx_merge_filter(struct microcode_filter_entry * const  f , uint32_t const   pf_mask ,
                            int const   invert ) 
{ 


  {
#line 1320
  if (f->invert == (int )invert) {
#line 1321
    f->pf_mask |= (unsigned int )pf_mask;
  } else
#line 1322
  if (! f->invert) {
#line 1323
    f->pf_mask &= (unsigned int )(~ pf_mask);
  } else {
#line 1325
    f->invert = 0;
#line 1326
    f->pf_mask = (uint32_t )pf_mask;
  }
#line 1328
  return;
}
}
#line 1330 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static int add_filter_to_list(uint32_t cpuid , uint32_t pf_mask , int invert , struct microcode_filter_entry ** const  base ) 
{ 
  struct microcode_filter_entry **pnext ;
  struct microcode_filter_entry *n ;
  void *tmp ;

  {
#line 1335
  if (! base) {
    {
#line 1335
    __assert_fail("base", "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c",
                  1335U, "add_filter_to_list");
    }
  }
#line 1337
  if (! pf_mask) {
#line 1338
    pf_mask = 4294967295U;
  }
#line 1340
  pnext = (struct microcode_filter_entry **)base;
  {
#line 1342
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1342
    if (*pnext) {
#line 1342
      if (! ((*pnext)->cpuid < cpuid)) {
#line 1342
        goto while_break;
      }
    } else {
#line 1342
      goto while_break;
    }
#line 1343
    pnext = & (*pnext)->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1345
  if (*pnext) {
#line 1345
    if ((*pnext)->cpuid == cpuid) {
#line 1346
      if ((pf_mask & (*pnext)->pf_mask) == pf_mask) {
#line 1346
        if ((*pnext)->invert == invert) {
#line 1349
          return (17);
        }
      }
      {
#line 1352
      xx_merge_filter((struct microcode_filter_entry */* const  */)*pnext, (uint32_t const   )pf_mask,
                      (int const   )invert);
      }
#line 1353
      return (0);
    }
  }
  {
#line 1357
  tmp = malloc(sizeof(struct microcode_filter_entry ));
#line 1357
  n = (struct microcode_filter_entry *)tmp;
  }
#line 1358
  if (! n) {
#line 1359
    return (12);
  }
#line 1360
  n->cpuid = cpuid;
#line 1361
  n->pf_mask = pf_mask;
#line 1362
  n->invert = invert;
#line 1363
  n->next = *pnext;
#line 1364
  *pnext = n;
#line 1366
  return (0);
}
}
#line 1370 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static void add_filter_list_to_list(struct microcode_filter_entry ** const  base ,
                                    struct microcode_filter_entry *entries ) 
{ 
  struct microcode_filter_entry **pp ;
  struct microcode_filter_entry *e ;

  {
#line 1376
  if (! base) {
    {
#line 1376
    __assert_fail("base", "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c",
                  1376U, "add_filter_list_to_list");
    }
  }
#line 1380
  pp = (struct microcode_filter_entry **)base;
  {
#line 1381
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1381
    if (! entries) {
#line 1381
      goto while_break;
    }
#line 1384
    e = entries;
#line 1385
    entries = entries->next;
    {
#line 1387
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1387
      if (*pp) {
#line 1387
        if (! ((*pp)->cpuid < e->cpuid)) {
#line 1387
          goto while_break___0;
        }
      } else {
#line 1387
        goto while_break___0;
      }
#line 1388
      pp = & (*pp)->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1390
    if (*pp) {
#line 1390
      if ((*pp)->cpuid == e->cpuid) {
        {
#line 1391
        xx_merge_filter((struct microcode_filter_entry */* const  */)*pp, (uint32_t const   )e->pf_mask,
                        (int const   )e->invert);
        }
      } else {
#line 1394
        e->next = *pp;
#line 1395
        *pp = e;
#line 1396
        e = (struct microcode_filter_entry *)((void *)0);
      }
    } else {
#line 1394
      e->next = *pp;
#line 1395
      *pp = e;
#line 1396
      e = (struct microcode_filter_entry *)((void *)0);
    }
#line 1398
    if (e) {
      {
#line 1399
      free((void *)e);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1401
  return;
}
}
#line 1404 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static int is_selected(uint32_t cpuid , uint32_t pf_mask , struct microcode_filter_entry  const  *f ) 
{ 


  {
  {
#line 1407
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1407
    if (f) {
#line 1407
      if (! (f->cpuid < (uint32_t const   )cpuid)) {
#line 1407
        goto while_break;
      }
    } else {
#line 1407
      goto while_break;
    }
#line 1408
    f = (struct microcode_filter_entry  const  *)f->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1409
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1409
    if (f) {
#line 1409
      if (! (f->cpuid == (uint32_t const   )cpuid)) {
#line 1409
        goto while_break___0;
      }
    } else {
#line 1409
      goto while_break___0;
    }
#line 1410
    if ((pf_mask & (unsigned int )f->pf_mask) != 0U) {
#line 1412
      return (! f->invert);
    } else
#line 1410
    if (f->pf_mask == 4294967295U) {
#line 1412
      return (! f->invert);
    }
#line 1413
    f = (struct microcode_filter_entry  const  *)f->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1416
  return (filter_list_allow);
}
}
#line 1421 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static int xx_uclist_add_print_errors(int status ) 
{ 


  {
  {
#line 1425
  if (status == 0) {
#line 1425
    goto case_0;
  }
#line 1425
  if (status == 17) {
#line 1425
    goto case_0;
  }
#line 1427
  if (status == 12) {
#line 1427
    goto case_12;
  }
#line 1430
  if (status == 22) {
#line 1430
    goto case_22;
  }
#line 1433
  goto switch_default;
  case_0: /* CIL Label */ 
  case_17: /* CIL Label */ 
#line 1426
  return (0);
  case_12: /* CIL Label */ 
  {
#line 1428
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1428
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Cannot add index entry: out of memory\n",
            progname);
    }
#line 1428
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1429
  return (1);
  case_22: /* CIL Label */ 
  {
#line 1431
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1431
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Internal error uclist_merge_signature() returned EINVAL\n",
            progname);
    }
#line 1431
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1432
  return (1);
  switch_default: /* CIL Label */ 
#line 1434
  return (1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1438 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static int xx_datefilter_loose_inplaceinsert(struct intel_uclist_entry **p___0 , struct intel_uclist_entry **uclist ) 
{ 
  uint32_t cpuid ;
  uint32_t pfm ;
  struct intel_uclist_entry *e ;
  int rc ;
  int tmp ;

  {
#line 1441
  cpuid = (*p___0)->cpuid;
#line 1442
  pfm = (*p___0)->pf_mask;
#line 1446
  e = *uclist;
  {
#line 1447
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1447
    if (e) {
#line 1447
      if (! (e->cpuid < cpuid)) {
#line 1447
        goto while_break;
      }
    } else {
#line 1447
      goto while_break;
    }
#line 1448
    e = e->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1449
  *uclist = e;
  {
#line 1451
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1451
    if (e) {
#line 1451
      if (! (e->cpuid == cpuid)) {
#line 1451
        goto while_break___0;
      }
    } else {
#line 1451
      goto while_break___0;
    }
#line 1452
    if (e->flags & 16U) {
#line 1452
      if (e->pf_mask & pfm) {
        {
#line 1453
        e->flags &= 4294967279U;
#line 1454
        e->flags |= 32U;
#line 1455
        tmp = uclist_merge_signature((unsigned long const   )e->id, (unsigned long const   )e->gid,
                                     (uint32_t const   )e->cpuid, (uint32_t const   )e->pf_mask,
                                     (int32_t const   )e->uc_rev, (void const   */* const  */)e->uc,
                                     (uint32_t const   )e->uc_size, (int const   )allow_downgrade,
                                     (struct intel_uclist_entry **/* const  */)p___0);
#line 1455
        rc = xx_uclist_add_print_errors(tmp);
        }
#line 1460
        if (rc) {
#line 1461
          return (rc);
        }
      }
    }
#line 1463
    e = e->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1466
  return (0);
}
}
#line 1469 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static int xx_process_ucode_signature_cb(void *userdata , unsigned int const   sig_count ,
                                         uint32_t const   cpuid , uint32_t const   pf_mask ,
                                         void const   * const  uc_data  __attribute__((__unused__)) ,
                                         unsigned int const   uc_data_size  __attribute__((__unused__)) ,
                                         void const   * const  uc , unsigned int const   uc_size ) 
{ 
  struct microcode_interator_data *ctx ;
  struct intel_ucode_metadata m ;
  intel_ucode_status_t s ;
  int add_status ;
  uint32_t uce_flags ;
  char const   *tmp ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
#line 1478
  ctx = (struct microcode_interator_data *)userdata;
#line 1484
  if (! ctx) {
    {
#line 1484
    __assert_fail("ctx", "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c",
                  1484U, "xx_process_ucode_signature_cb");
    }
  }
  {
#line 1486
  (ctx->total_signature_count) ++;
#line 1488
  s = intel_ucode_getmetadata(uc, & m);
  }
#line 1489
  if ((unsigned int )s != 0U) {
    {
#line 1490
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1490
      tmp = intel_ucode_errstr((intel_ucode_status_t const   )s);
#line 1490
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Microcode entry %s: %s\n",
              progname, ctx->current_uc_id_str, tmp);
      }
#line 1490
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 1492
    return (1);
  }
#line 1495
  if (sig_count) {
#line 1495
    uce_flags = (uint32_t )1;
  } else {
#line 1495
    uce_flags = (uint32_t )0;
  }
  {
#line 1496
  tmp___3 = is_selected((uint32_t )cpuid, (uint32_t )pf_mask, (struct microcode_filter_entry  const  *)uc_filter_list);
  }
#line 1496
  if (tmp___3) {
    {
#line 1497
    tmp___2 = is_in_date_range((struct intel_ucode_metadata  const  */* const  */)(& m));
    }
#line 1497
    if (tmp___2) {
#line 1497
      tmp___1 = 32;
    } else {
#line 1497
      tmp___1 = 16;
    }
#line 1497
    uce_flags |= (unsigned int )tmp___1;
  }
#line 1500
  if (list_all_microcodes) {
#line 1501
    if (! sig_count) {
      {
#line 1502
      printf((char const   */* __restrict  */)"  %6s: sig 0x%08x, pf mask 0x%02x, %04x-%02x-%02x, rev 0x%04x, size %u\n",
             ctx->current_uc_id_str, cpuid, pf_mask, (int )m.date_year, (int )m.date_month,
             (int )m.date_day, m.revision, uc_size);
      }
    } else {
      {
#line 1508
      printf((char const   */* __restrict  */)"          sig 0x%08x, pf mask 0x%02x, %04x-%02x-%02x, rev 0x%04x\n",
             cpuid, pf_mask, (int )m.date_year, (int )m.date_month, (int )m.date_day,
             m.revision);
      }
    }
  }
  {
#line 1515
  add_status = uclist_add_signature((unsigned long const   )ctx->current_uc, (ctx->current_bundle)->id,
                                    (uint32_t const   )uce_flags, cpuid, pf_mask,
                                    (int32_t const   )m.revision, uc, uc_size, (int const   )strict_checks,
                                    (struct intel_uclist_entry **/* const  */)(& all_microcodes));
  }
  {
#line 1521
  if (add_status == 0) {
#line 1521
    goto case_0;
  }
#line 1524
  if (add_status == 17) {
#line 1524
    goto case_17;
  }
#line 1526
  if (add_status == 9) {
#line 1526
    goto case_9;
  }
#line 1531
  goto switch_default;
  case_0: /* CIL Label */ 
#line 1522
  (ctx->total_unique_sig_count) ++;
#line 1523
  goto switch_break;
  case_17: /* CIL Label */ 
#line 1525
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 1527
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1527
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: WARNING: Microcode %s has the same revision and signature as a previously loaded microcode, but different contents\n",
            progname, ctx->current_uc_id_str);
    }
#line 1527
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1530
  return (1);
  switch_default: /* CIL Label */ 
  {
#line 1532
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 1532
    tmp___4 = strerror(add_status);
#line 1532
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Failed to add microcode entry %s: %s\n",
            progname, ctx->current_uc_id_str, tmp___4);
    }
#line 1532
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1534
  return (1);
  switch_break: /* CIL Label */ ;
  }
#line 1537
  if (uce_flags & 32U) {
    {
#line 1538
    add_status = uclist_merge_signature((unsigned long const   )ctx->current_uc, (ctx->current_bundle)->id,
                                        cpuid, pf_mask, (int32_t const   )m.revision,
                                        uc, uc_size, (int const   )allow_downgrade,
                                        (struct intel_uclist_entry **/* const  */)(& microcodes));
    }
#line 1543
    if (add_status) {
#line 1543
      if (add_status != 17) {
        {
#line 1544
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 1544
          tmp___5 = strerror(add_status);
#line 1544
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Failed to select microcode entry %s: %s\n",
                  progname, ctx->current_uc_id_str, tmp___5);
          }
#line 1544
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 1546
        return (1);
      }
    }
  }
  {
#line 1550
  tmp___6 = xx_uclist_add_print_errors(add_status);
  }
#line 1550
  return (tmp___6);
}
}
#line 1553 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static int xx_process_ucode_entry_cb(void *userdata , unsigned int const   uc_count ,
                                     void const   * const  uc ) 
{ 
  struct microcode_interator_data *ctx ;
  intel_ucode_status_t s ;
  char const   *tmp ;
  int tmp___0 ;

  {
#line 1557
  ctx = (struct microcode_interator_data *)userdata;
#line 1560
  if (! ctx) {
    {
#line 1560
    __assert_fail("ctx", "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c",
                  1560U, "xx_process_ucode_entry_cb");
    }
  }
  {
#line 1562
  ctx->current_uc = (unsigned long )uc_count;
#line 1563
  str_append_ucode_id(ctx->current_uc, (unsigned long )(ctx->current_bundle)->id,
                      ctx->current_uc_id_str, (unsigned int )sizeof(ctx->current_uc_id_str));
#line 1567
  s = intel_ucode_check_microcode(uc, strict_checks);
  }
#line 1568
  if ((unsigned int )s != 0U) {
    {
#line 1569
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1569
      tmp = intel_ucode_errstr((intel_ucode_status_t const   )s);
#line 1569
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: microcode %s: %s\n",
              progname, ctx->current_uc_id_str, tmp);
      }
#line 1569
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 1571
    if (ignore_bad_ucode) {
#line 1571
      tmp___0 = 0;
    } else {
#line 1571
      tmp___0 = 1;
    }
#line 1571
    return (tmp___0);
  }
  {
#line 1574
  (ctx->total_entry_count) ++;
#line 1576
  s = intel_ucode_foreach_signature(uc, (intel_ucode_sig_callback */* const  */)(& xx_process_ucode_signature_cb),
                                    (void */* const  */)userdata);
  }
#line 1578
  if ((unsigned int )s != 0U) {
#line 1578
    if (! ignore_bad_ucode) {
      {
#line 1579
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 1579
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: aborting microcode processing...\n",
                progname);
        }
#line 1579
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1580
      return (1);
    }
  }
#line 1583
  return (0);
}
}
#line 1586 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static int do_process_microcodes(void) 
{ 
  intel_ucode_status_t s ;
  struct microcode_bundle *mcb ;
  char const   *tmp ;
  char const   *tmp___0 ;
  struct intel_uclist_entry *uce ;
  struct intel_uclist_entry *ucl ;
  unsigned long uccount ;
  unsigned long sigcount ;
  int tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  struct intel_ucode_metadata m ;

  {
  {
#line 1591
  memset((void *)(& microcode_interator_data), 0, sizeof(microcode_interator_data));
#line 1592
  mcb = microcode_bundles;
  }
  {
#line 1594
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1594
    if (! mcb) {
#line 1594
      goto while_break;
    }
#line 1595
    if (list_all_microcodes) {
#line 1596
      if (mcb->filename) {
        {
#line 1597
        printf((char const   */* __restrict  */)"microcode bundle %lu: %s\n", mcb->id,
               mcb->filename);
        }
      } else {
        {
#line 1600
        printf((char const   */* __restrict  */)"microcode bundle %lu:\n", mcb->id);
        }
      }
    }
    {
#line 1604
    microcode_interator_data.current_bundle = (struct microcode_bundle  const  *)mcb;
#line 1605
    s = intel_ucode_foreach_microcode((void const   */* const  */)mcb->data, (size_t const   )mcb->size,
                                      (intel_ucode_uc_callback */* const  */)(& xx_process_ucode_entry_cb),
                                      (void */* const  */)(& microcode_interator_data));
    }
#line 1608
    if ((unsigned int )s != 0U) {
#line 1609
      if ((unsigned int )s != 9U) {
        {
#line 1610
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 1610
          tmp = intel_ucode_errstr((intel_ucode_status_t const   )s);
          }
#line 1610
          if (mcb->filename) {
#line 1610
            tmp___0 = mcb->filename;
          } else {
#line 1610
            tmp___0 = "(no filename)";
          }
          {
#line 1610
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: microcode bundle %s: %s\n",
                  progname, tmp___0, tmp);
          }
#line 1610
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 1614
      if (! ignore_bad_ucode) {
#line 1615
        return (1);
      }
    }
#line 1618
    mcb = mcb->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1621
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1621
    if (verbosity >= 2) {
      {
#line 1621
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: processed %lu valid microcode(s), %lu signature(s), %lu unique signature(s)\n",
              progname, microcode_interator_data.total_entry_count, microcode_interator_data.total_signature_count,
              microcode_interator_data.total_unique_sig_count);
      }
    }
#line 1621
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1632
  if (list_sel_microcodes) {
#line 1632
    goto _L;
  } else
#line 1632
  if (datefilter_loose) {
#line 1632
    goto _L;
  } else
#line 1632
  if (verbosity >= 2) {
    _L: /* CIL Label */ 
#line 1633
    uce = microcodes;
#line 1634
    ucl = all_microcodes;
#line 1635
    uccount = 0UL;
#line 1636
    sigcount = 0UL;
#line 1638
    if (list_sel_microcodes) {
      {
#line 1639
      printf((char const   */* __restrict  */)"selected microcodes:\n");
      }
    }
    {
#line 1641
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1641
      if (! uce) {
#line 1641
        goto while_break___2;
      }
#line 1646
      if (datefilter_loose) {
        {
#line 1646
        tmp___1 = xx_datefilter_loose_inplaceinsert(& uce, & ucl);
        }
#line 1646
        if (tmp___1) {
#line 1646
          tmp___2 = 1;
        } else {
#line 1646
          tmp___2 = 0;
        }
      } else {
#line 1646
        tmp___2 = 0;
      }
      {
#line 1646
      tmp___3 = __builtin_expect((long )tmp___2, 0L);
      }
#line 1646
      if (tmp___3) {
#line 1648
        return (1);
      }
      {
#line 1650
      tmp___4 = __builtin_expect((long )(! (! (! (uce->flags & 1U)))), 1L);
      }
#line 1650
      if (tmp___4) {
#line 1651
        uccount ++;
      }
#line 1653
      sigcount ++;
#line 1655
      if (list_sel_microcodes) {
        {
#line 1658
        intel_ucode_getmetadata((void const   */* const  */)uce->uc, & m);
#line 1659
        printf((char const   */* __restrict  */)"%03lu: sig 0x%08x, pf mask 0x%02x, %04x-%02x-%02x, rev 0x%04x, size %u\n",
               sigcount, uce->cpuid, uce->pf_mask, (int )m.date_year, (int )m.date_month,
               (int )m.date_day, m.revision, uce->uc_size);
        }
      }
#line 1666
      uce = uce->next;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 1668
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1668
      if (verbosity >= 2) {
        {
#line 1668
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: selected %lu microcode(s), %lu signature(s)\n",
                progname, uccount, sigcount);
        }
      }
#line 1668
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 1672
  return (0);
}
}
#line 1675 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static int do_write_microcode(char const   * const  filename , int ft ) 
{ 
  int tmp ;

  {
#line 1677
  if (! microcodes) {
#line 1678
    return (0);
  }
  {
#line 1680
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1680
    if (verbosity >= 1) {
      {
#line 1680
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Writing selected microcodes to: %s\n",
              progname, filename);
      }
    }
#line 1680
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1681
  tmp = write_intel_microcodes((int const   )-100, filename, ft, microcodes);
  }
#line 1681
  return (tmp);
}
}
#line 1684 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static int do_upload_microcode(char const   * const  filename ) 
{ 
  int tmp ;

  {
#line 1686
  if (! microcodes) {
#line 1687
    return (0);
  }
  {
#line 1689
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1689
    if (verbosity >= 1) {
      {
#line 1689
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Uploading selected microcodes to: %s\n",
              progname, filename);
      }
    }
#line 1689
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1690
  tmp = upload_intel_microcodes(filename, microcodes);
  }
#line 1690
  return (tmp);
}
}
#line 1693 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static int do_write_named(char const   * const  dirname ) 
{ 
  char fn[35] ;
  int dirfd___0 ;
  struct stat st ;
  struct intel_uclist_entry e ;
  struct intel_uclist_entry *p___0 ;
  unsigned long count ;
  int rc ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
#line 1703
  if (! microcodes) {
#line 1704
    return (0);
  }
  {
#line 1706
  dirfd___0 = open((char const   *)dirname, 0);
  }
#line 1707
  if (dirfd___0 == -1) {
    {
#line 1708
    tmp = __errno_location();
#line 1708
    rc = *tmp;
    }
    {
#line 1709
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1709
      tmp___0 = strerror(rc);
#line 1709
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: cannot open: %s\n",
              progname, dirname, tmp___0);
      }
#line 1709
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 1711
    return (rc);
  }
  {
#line 1715
  tmp___3 = fstat(dirfd___0, & st);
  }
#line 1715
  if (tmp___3 == -1) {
    {
#line 1716
    tmp___1 = __errno_location();
#line 1716
    rc = *tmp___1;
    }
    {
#line 1717
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1717
      tmp___2 = strerror(rc);
#line 1717
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: cannot stat inode: %s\n",
              progname, dirname, tmp___2);
      }
#line 1717
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1719
    goto err_exit;
  }
#line 1721
  if (! ((st.st_mode & 61440U) == 16384U)) {
    {
#line 1722
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1722
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: is not a directory\n",
              progname, dirname);
      }
#line 1722
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1723
    rc = 22;
#line 1724
    goto err_exit;
  }
  {
#line 1727
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1727
    if (verbosity >= 1) {
      {
#line 1727
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Writing microcode file(s) into %s\n",
              progname, dirname);
      }
    }
#line 1727
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1729
  p___0 = microcodes;
#line 1730
  count = 0UL;
#line 1731
  rc = 0;
  {
#line 1733
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1733
    if (p___0) {
#line 1733
      if (! (! rc)) {
#line 1733
        goto while_break___3;
      }
    } else {
#line 1733
      goto while_break___3;
    }
    {
#line 1734
    snprintf((char */* __restrict  */)(fn), sizeof(fn), (char const   */* __restrict  */)"s%08X_m%08X_r%08X.fw",
             p___0->cpuid, p___0->pf_mask, p___0->uc_rev);
#line 1737
    memcpy((void */* __restrict  */)(& e), (void const   */* __restrict  */)p___0,
           sizeof(e));
#line 1738
    e.next = (struct intel_uclist_entry *)((void *)0);
#line 1739
    rc = write_intel_microcodes((int const   )dirfd___0, (char const   */* const  */)(fn),
                                0, & e);
    }
#line 1740
    if (! rc) {
#line 1741
      count ++;
    }
#line 1743
    p___0 = p___0->next;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1745
  if (count) {
    {
#line 1746
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1746
      if (verbosity >= 2) {
        {
#line 1746
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %lu file(s) were written into %s\n",
                progname, count, dirname);
        }
      }
#line 1746
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
  } else {
    {
#line 1748
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1748
      if (verbosity >= 1) {
        {
#line 1748
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: no files were written into %s\n",
                progname, dirname);
        }
      }
#line 1748
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
  err_exit: 
  {
#line 1751
  close(dirfd___0);
  }
#line 1753
  return (rc);
}
}
#line 1756 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static int do_write_firmware(char const   * const  dirname ) 
{ 
  char fn[35] ;
  int dirfd___0 ;
  struct stat st ;
  struct intel_uclist_entry *samecpuid_list ;
  struct intel_uclist_entry *p___0 ;
  unsigned long count ;
  int rc ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  uint32_t cpuid ;
  unsigned int x86_family ;
  unsigned int x86_model ;
  unsigned int x86_mask ;
  int add_status ;
  int tmp___4 ;

  {
#line 1766
  if (! microcodes) {
#line 1767
    return (0);
  }
  {
#line 1769
  dirfd___0 = open((char const   *)dirname, 0);
  }
#line 1770
  if (dirfd___0 == -1) {
    {
#line 1771
    tmp = __errno_location();
#line 1771
    rc = *tmp;
    }
    {
#line 1772
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1772
      tmp___0 = strerror(rc);
#line 1772
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: cannot open: %s\n",
              progname, dirname, tmp___0);
      }
#line 1772
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 1774
    return (rc);
  }
  {
#line 1778
  tmp___3 = fstat(dirfd___0, & st);
  }
#line 1778
  if (tmp___3 == -1) {
    {
#line 1779
    tmp___1 = __errno_location();
#line 1779
    rc = *tmp___1;
    }
    {
#line 1780
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1780
      tmp___2 = strerror(rc);
#line 1780
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: cannot stat inode: %s\n",
              progname, dirname, tmp___2);
      }
#line 1780
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1782
    goto err_exit;
  }
#line 1784
  if (! ((st.st_mode & 61440U) == 16384U)) {
    {
#line 1785
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1785
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: is not a directory\n",
              progname, dirname);
      }
#line 1785
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1786
    rc = 22;
#line 1787
    goto err_exit;
  }
  {
#line 1790
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1790
    if (verbosity >= 1) {
      {
#line 1790
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Writing microcode firmware file(s) into %s\n",
              progname, dirname);
      }
    }
#line 1790
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1792
  p___0 = microcodes;
#line 1793
  samecpuid_list = (struct intel_uclist_entry *)((void *)0);
#line 1794
  count = 0UL;
#line 1795
  rc = 0;
  {
#line 1798
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1798
    if (p___0) {
#line 1798
      if (! (! rc)) {
#line 1798
        goto while_break___3;
      }
    } else {
#line 1798
      goto while_break___3;
    }
#line 1804
    cpuid = p___0->cpuid;
    {
#line 1805
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1805
      if (p___0) {
#line 1805
        if (! (p___0->cpuid == cpuid)) {
#line 1805
          goto while_break___4;
        }
      } else {
#line 1805
        goto while_break___4;
      }
      {
#line 1806
      add_status = uclist_merge_signature((unsigned long const   )p___0->id, (unsigned long const   )p___0->gid,
                                          (uint32_t const   )p___0->cpuid, (uint32_t const   )p___0->pf_mask,
                                          (int32_t const   )p___0->uc_rev, (void const   */* const  */)p___0->uc,
                                          (uint32_t const   )p___0->uc_size, (int const   )0,
                                          (struct intel_uclist_entry **/* const  */)(& samecpuid_list));
#line 1810
      tmp___4 = xx_uclist_add_print_errors(add_status);
      }
#line 1810
      if (tmp___4) {
#line 1811
        rc = add_status;
#line 1812
        goto err_exit;
      }
#line 1815
      p___0 = p___0->next;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1820
    x86_family = (cpuid >> 8) & 15U;
#line 1821
    x86_model = (cpuid >> 4) & 15U;
#line 1822
    x86_mask = cpuid & 15U;
#line 1823
    if (x86_family == 15U) {
#line 1824
      x86_family += (cpuid >> 20) & 255U;
    }
#line 1825
    if (x86_family >= 6U) {
#line 1826
      x86_model += ((cpuid >> 16) & 15U) << 4;
    }
    {
#line 1828
    snprintf((char */* __restrict  */)(fn), sizeof(fn), (char const   */* __restrict  */)"%02x-%02x-%02x",
             x86_family, x86_model, x86_mask);
#line 1831
    rc = write_intel_microcodes((int const   )dirfd___0, (char const   */* const  */)(fn),
                                0, samecpuid_list);
#line 1833
    free_uclist(samecpuid_list);
#line 1834
    samecpuid_list = (struct intel_uclist_entry *)((void *)0);
    }
#line 1836
    if (! rc) {
#line 1837
      count ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1839
  if (count) {
    {
#line 1840
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1840
      if (verbosity >= 2) {
        {
#line 1840
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %lu file(s) were written into %s\n",
                progname, count, dirname);
        }
      }
#line 1840
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
  } else {
    {
#line 1842
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 1842
      if (verbosity >= 1) {
        {
#line 1842
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: no files were written into %s\n",
                progname, dirname);
        }
      }
#line 1842
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
  }
  err_exit: 
  {
#line 1845
  close(dirfd___0);
  }
#line 1847
  return (rc);
}
}
#line 1850 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static int scan_system_processors(void) 
{ 
  char cpuid_device[4096] ;
  uint32_t cpuid_buf[8] ;
  struct microcode_filter_entry *uc_cpu ;
  int cpuid_fd ;
  unsigned int i ;
  unsigned int ncpu ;
  int rc ;
  int en ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  ssize_t tmp___2 ;
  int tmp___3 ;

  {
#line 1854
  uc_cpu = (struct microcode_filter_entry *)((void *)0);
#line 1856
  cpuid_fd = -1;
#line 1857
  i = 0U;
#line 1858
  ncpu = 0U;
#line 1859
  rc = 0;
  {
#line 1861
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1862
    if (cpuid_fd != -1) {
      {
#line 1863
      close(cpuid_fd);
      }
    }
    {
#line 1865
    snprintf((char */* __restrict  */)(cpuid_device), sizeof(cpuid_device), (char const   */* __restrict  */)"/dev/cpu/%u/cpuid",
             i);
#line 1867
    cpuid_fd = open((char const   *)(cpuid_device), 0);
    }
#line 1868
    if (cpuid_fd == -1) {
      {
#line 1869
      tmp = __errno_location();
#line 1869
      en = *tmp;
      }
      {
#line 1871
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1871
        if (verbosity >= 4) {
          {
#line 1871
          tmp___0 = strerror(en);
#line 1871
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: returned error status on open(): %s\n",
                  progname, cpuid_device, tmp___0);
          }
        }
#line 1871
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1874
      if (en == 4) {
#line 1875
        goto while_continue;
      }
#line 1876
      if (en == 2) {
#line 1877
        goto while_break;
      }
#line 1878
      if (en == 6) {
#line 1878
        goto _L;
      } else
#line 1878
      if (en == 5) {
        _L: /* CIL Label */ 
        {
#line 1880
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1880
          if (verbosity >= 2) {
            {
#line 1880
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: processor %u is offline or has no cpuid support\n",
                    progname, i);
            }
          }
#line 1880
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
      } else {
        {
#line 1882
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1882
          if (verbosity >= 2) {
            {
#line 1882
            tmp___1 = strerror(en);
#line 1882
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: cannot open cpuid device node: %s\n",
                    progname, cpuid_device, tmp___1);
            }
          }
#line 1882
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 1884
        rc = -1;
      }
#line 1888
      i ++;
#line 1889
      goto while_continue;
    }
    {
#line 1892
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1892
      if (verbosity >= 3) {
        {
#line 1892
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: trying to get CPUID information from %s\n",
                progname, cpuid_device);
        }
      }
#line 1892
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 1894
    tmp___2 = read(cpuid_fd, (void *)(& cpuid_buf), sizeof(cpuid_buf));
    }
#line 1894
    if (tmp___2 == -1L) {
      {
#line 1895
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 1895
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: access to CPUID(0) and CPUID(1) failed\n",
                progname, cpuid_device);
        }
#line 1895
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1898
      rc = 1;
#line 1899
      goto err_out;
    }
    {
#line 1902
    close(cpuid_fd);
#line 1903
    cpuid_fd = -1;
#line 1904
    ncpu ++;
    }
#line 1907
    if (cpuid_buf[0] > 0U) {
#line 1907
      if (cpuid_buf[1] == 1970169159U) {
#line 1907
        if (cpuid_buf[3] == 1231384169U) {
#line 1907
          if (cpuid_buf[2] == 1818588270U) {
            {
#line 1915
            tmp___3 = add_filter_to_list(cpuid_buf[4], (uint32_t )0, 0, (struct microcode_filter_entry **/* const  */)(& uc_cpu));
            }
            {
#line 1916
            if (tmp___3 == 12) {
#line 1916
              goto case_12;
            }
#line 1920
            if (tmp___3 == 17) {
#line 1920
              goto case_17;
            }
#line 1922
            goto switch_default;
            case_12: /* CIL Label */ 
            {
#line 1917
            while (1) {
              while_continue___5: /* CIL Label */ ;
              {
#line 1917
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: out of memory\n",
                      progname);
              }
#line 1917
              goto while_break___5;
            }
            while_break___5: /* CIL Label */ ;
            }
#line 1918
            rc = 1;
#line 1919
            goto err_out;
            case_17: /* CIL Label */ 
#line 1921
            goto switch_break;
            switch_default: /* CIL Label */ 
            {
#line 1923
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 1923
              if (verbosity >= 1) {
                {
#line 1923
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: system has processor(s) with signature 0x%08x\n",
                        progname, cpuid_buf[4]);
                }
              }
#line 1923
              goto while_break___6;
            }
            while_break___6: /* CIL Label */ ;
            }
            switch_break: /* CIL Label */ ;
            }
          } else {
#line 1907
            goto _L___2;
          }
        } else {
#line 1907
          goto _L___2;
        }
      } else {
#line 1907
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 1927
    if (! uc_cpu) {
      {
#line 1929
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 1929
        if (verbosity >= 2) {
          {
#line 1929
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: non-Intel processor found, skipping scan\n",
                  progname);
          }
        }
#line 1929
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 1930
      goto while_break;
    }
#line 1934
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1945
  if (i == 0U) {
#line 1945
    if (ncpu == 0U) {
      {
#line 1946
      while (1) {
        while_continue___8: /* CIL Label */ ;
        {
#line 1946
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: cpuid kernel driver unavailable, cannot scan system processor signatures\n",
                progname);
        }
#line 1946
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 1947
      rc = 0;
#line 1948
      goto err_out;
    } else {
#line 1945
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 1949
  if (rc) {
#line 1950
    if (ncpu) {
      {
#line 1951
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 1951
        if (verbosity >= 1) {
          {
#line 1951
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: some processors were not scanned due to unexpected errors\n",
                  progname);
          }
        }
#line 1951
        goto while_break___9;
      }
      while_break___9: /* CIL Label */ ;
      }
    } else {
      {
#line 1953
      while (1) {
        while_continue___10: /* CIL Label */ ;
        {
#line 1953
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: could not open cpuid devices, cannot scan system processor signatures\n",
                progname);
        }
#line 1953
        goto while_break___10;
      }
      while_break___10: /* CIL Label */ ;
      }
    }
  }
#line 1956
  rc = 0;
#line 1959
  filter_list_allow = 0;
#line 1961
  if (uc_cpu) {
    {
#line 1963
    add_filter_list_to_list((struct microcode_filter_entry **/* const  */)(& uc_filter_list),
                            uc_cpu);
#line 1964
    uc_cpu = (struct microcode_filter_entry *)((void *)0);
    }
  }
  {
#line 1966
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 1966
    if (verbosity >= 2) {
      {
#line 1966
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: checked the signature of %u processor(s)\n",
              progname, ncpu);
      }
    }
#line 1966
    goto while_break___11;
  }
  while_break___11: /* CIL Label */ ;
  }
  err_out: 
#line 1969
  if (cpuid_fd != -1) {
    {
#line 1970
    close(cpuid_fd);
    }
  }
#line 1972
  if (uc_cpu) {
    {
#line 1973
    free_filter_list(uc_cpu);
    }
  }
#line 1975
  return (rc);
}
}
#line 1980 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static char const   program_version[370]  = 
#line 1980
  {      (char const   )'i',      (char const   )'u',      (char const   )'c',      (char const   )'o', 
        (char const   )'d',      (char const   )'e',      (char const   )'_',      (char const   )'t', 
        (char const   )'o',      (char const   )'o',      (char const   )'l',      (char const   )' ', 
        (char const   )'1',      (char const   )'.',      (char const   )'0',      (char const   )'.', 
        (char const   )'3',      (char const   )'\n',      (char const   )'C',      (char const   )'o', 
        (char const   )'p',      (char const   )'y',      (char const   )'r',      (char const   )'i', 
        (char const   )'g',      (char const   )'h',      (char const   )'t',      (char const   )' ', 
        (char const   )'(',      (char const   )'c',      (char const   )')',      (char const   )' ', 
        (char const   )'2',      (char const   )'0',      (char const   )'1',      (char const   )'0', 
        (char const   )'-',      (char const   )'2',      (char const   )'0',      (char const   )'1', 
        (char const   )'4',      (char const   )' ',      (char const   )'b',      (char const   )'y', 
        (char const   )' ',      (char const   )'H',      (char const   )'e',      (char const   )'n', 
        (char const   )'r',      (char const   )'i',      (char const   )'q',      (char const   )'u', 
        (char const   )'e',      (char const   )' ',      (char const   )'d',      (char const   )'e', 
        (char const   )' ',      (char const   )'M',      (char const   )'o',      (char const   )'r', 
        (char const   )'a',      (char const   )'e',      (char const   )'s',      (char const   )' ', 
        (char const   )'H',      (char const   )'o',      (char const   )'l',      (char const   )'s', 
        (char const   )'c',      (char const   )'h',      (char const   )'u',      (char const   )'h', 
        (char const   )'\n',      (char const   )'\n',      (char const   )'B',      (char const   )'a', 
        (char const   )'s',      (char const   )'e',      (char const   )'d',      (char const   )' ', 
        (char const   )'o',      (char const   )'n',      (char const   )' ',      (char const   )'c', 
        (char const   )'o',      (char const   )'d',      (char const   )'e',      (char const   )' ', 
        (char const   )'f',      (char const   )'r',      (char const   )'o',      (char const   )'m', 
        (char const   )' ',      (char const   )'t',      (char const   )'h',      (char const   )'e', 
        (char const   )' ',      (char const   )'L',      (char const   )'i',      (char const   )'n', 
        (char const   )'u',      (char const   )'x',      (char const   )' ',      (char const   )'m', 
        (char const   )'i',      (char const   )'c',      (char const   )'r',      (char const   )'o', 
        (char const   )'c',      (char const   )'o',      (char const   )'d',      (char const   )'e', 
        (char const   )'_',      (char const   )'i',      (char const   )'n',      (char const   )'t', 
        (char const   )'e',      (char const   )'l',      (char const   )' ',      (char const   )'d', 
        (char const   )'r',      (char const   )'i',      (char const   )'v',      (char const   )'e', 
        (char const   )'r',      (char const   )' ',      (char const   )'a',      (char const   )'n', 
        (char const   )'d',      (char const   )' ',      (char const   )'f',      (char const   )'r', 
        (char const   )'o',      (char const   )'m',      (char const   )'\n',      (char const   )'t', 
        (char const   )'h',      (char const   )'e',      (char const   )' ',      (char const   )'m', 
        (char const   )'i',      (char const   )'c',      (char const   )'r',      (char const   )'o', 
        (char const   )'c',      (char const   )'o',      (char const   )'d',      (char const   )'e', 
        (char const   )'.',      (char const   )'c',      (char const   )'t',      (char const   )'l', 
        (char const   )' ',      (char const   )'p',      (char const   )'a',      (char const   )'c', 
        (char const   )'k',      (char const   )'a',      (char const   )'g',      (char const   )'e', 
        (char const   )',',      (char const   )' ',      (char const   )'c',      (char const   )'o', 
        (char const   )'p',      (char const   )'y',      (char const   )'r',      (char const   )'i', 
        (char const   )'g',      (char const   )'h',      (char const   )'t',      (char const   )' ', 
        (char const   )'(',      (char const   )'c',      (char const   )')',      (char const   )' ', 
        (char const   )'2',      (char const   )'0',      (char const   )'0',      (char const   )'0', 
        (char const   )' ',      (char const   )'b',      (char const   )'y',      (char const   )' ', 
        (char const   )'S',      (char const   )'i',      (char const   )'m',      (char const   )'o', 
        (char const   )'n',      (char const   )' ',      (char const   )'T',      (char const   )'r', 
        (char const   )'i',      (char const   )'m',      (char const   )'m',      (char const   )'e', 
        (char const   )'r',      (char const   )'\n',      (char const   )'a',      (char const   )'n', 
        (char const   )'d',      (char const   )' ',      (char const   )'T',      (char const   )'i', 
        (char const   )'g',      (char const   )'r',      (char const   )'a',      (char const   )'n', 
        (char const   )' ',      (char const   )'A',      (char const   )'i',      (char const   )'v', 
        (char const   )'a',      (char const   )'z',      (char const   )'i',      (char const   )'a', 
        (char const   )'n',      (char const   )'.',      (char const   )'\n',      (char const   )'\n', 
        (char const   )'T',      (char const   )'h',      (char const   )'i',      (char const   )'s', 
        (char const   )' ',      (char const   )'i',      (char const   )'s',      (char const   )' ', 
        (char const   )'f',      (char const   )'r',      (char const   )'e',      (char const   )'e', 
        (char const   )' ',      (char const   )'s',      (char const   )'o',      (char const   )'f', 
        (char const   )'t',      (char const   )'w',      (char const   )'a',      (char const   )'r', 
        (char const   )'e',      (char const   )';',      (char const   )' ',      (char const   )'s', 
        (char const   )'e',      (char const   )'e',      (char const   )' ',      (char const   )'t', 
        (char const   )'h',      (char const   )'e',      (char const   )' ',      (char const   )'s', 
        (char const   )'o',      (char const   )'u',      (char const   )'r',      (char const   )'c', 
        (char const   )'e',      (char const   )' ',      (char const   )'f',      (char const   )'o', 
        (char const   )'r',      (char const   )' ',      (char const   )'c',      (char const   )'o', 
        (char const   )'p',      (char const   )'y',      (char const   )'i',      (char const   )'n', 
        (char const   )'g',      (char const   )' ',      (char const   )'c',      (char const   )'o', 
        (char const   )'n',      (char const   )'d',      (char const   )'i',      (char const   )'t', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )'s', 
        (char const   )'.',      (char const   )'\n',      (char const   )'T',      (char const   )'h', 
        (char const   )'e',      (char const   )'r',      (char const   )'e',      (char const   )' ', 
        (char const   )'i',      (char const   )'s',      (char const   )' ',      (char const   )'N', 
        (char const   )'O',      (char const   )' ',      (char const   )'w',      (char const   )'a', 
        (char const   )'r',      (char const   )'r',      (char const   )'a',      (char const   )'n', 
        (char const   )'t',      (char const   )'y',      (char const   )';',      (char const   )' ', 
        (char const   )'n',      (char const   )'o',      (char const   )'t',      (char const   )' ', 
        (char const   )'e',      (char const   )'v',      (char const   )'e',      (char const   )'n', 
        (char const   )' ',      (char const   )'f',      (char const   )'o',      (char const   )'r', 
        (char const   )' ',      (char const   )'M',      (char const   )'E',      (char const   )'R', 
        (char const   )'C',      (char const   )'H',      (char const   )'A',      (char const   )'N', 
        (char const   )'T',      (char const   )'A',      (char const   )'B',      (char const   )'I', 
        (char const   )'L',      (char const   )'I',      (char const   )'T',      (char const   )'Y', 
        (char const   )' ',      (char const   )'o',      (char const   )'r',      (char const   )' ', 
        (char const   )'F',      (char const   )'I',      (char const   )'T',      (char const   )'N', 
        (char const   )'E',      (char const   )'S',      (char const   )'S',      (char const   )' ', 
        (char const   )'F',      (char const   )'O',      (char const   )'R',      (char const   )'\n', 
        (char const   )'A',      (char const   )' ',      (char const   )'P',      (char const   )'A', 
        (char const   )'R',      (char const   )'T',      (char const   )'I',      (char const   )'C', 
        (char const   )'U',      (char const   )'L',      (char const   )'A',      (char const   )'R', 
        (char const   )' ',      (char const   )'P',      (char const   )'U',      (char const   )'R', 
        (char const   )'P',      (char const   )'O',      (char const   )'S',      (char const   )'E', 
        (char const   )'.',      (char const   )'\000'};
#line 1993 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static char cmdline_doc[846]  = 
#line 1993
  {      (char )'i',      (char )'u',      (char )'c',      (char )'o', 
        (char )'d',      (char )'e',      (char )'_',      (char )'t', 
        (char )'o',      (char )'o',      (char )'l',      (char )' ', 
        (char )'-',      (char )' ',      (char )'T',      (char )'o', 
        (char )'o',      (char )'l',      (char )' ',      (char )'t', 
        (char )'o',      (char )' ',      (char )'m',      (char )'a', 
        (char )'n',      (char )'i',      (char )'p',      (char )'u', 
        (char )'l',      (char )'a',      (char )'t',      (char )'e', 
        (char )' ',      (char )'I',      (char )'n',      (char )'t', 
        (char )'e',      (char )'l',      (char )' ',      (char )'I', 
        (char )'A',      (char )'3',      (char )'2',      (char )'/', 
        (char )'X',      (char )'8',      (char )'6',      (char )'_', 
        (char )'6',      (char )'4',      (char )' ',      (char )'m', 
        (char )'i',      (char )'c',      (char )'r',      (char )'o', 
        (char )'c',      (char )'o',      (char )'d',      (char )'e', 
        (char )' ',      (char )'b',      (char )'u',      (char )'n', 
        (char )'d',      (char )'l',      (char )'e',      (char )'s', 
        (char )'\n',      (char )'\v',      (char )'T',      (char )'h', 
        (char )'e',      (char )' ',      (char )'m',      (char )'i', 
        (char )'c',      (char )'r',      (char )'o',      (char )'c', 
        (char )'o',      (char )'d',      (char )'e',      (char )' ', 
        (char )'b',      (char )'u',      (char )'n',      (char )'d', 
        (char )'l',      (char )'e',      (char )' ',      (char )'f', 
        (char )'i',      (char )'l',      (char )'e',      (char )'s', 
        (char )' ',      (char )'s',      (char )'h',      (char )'o', 
        (char )'u',      (char )'l',      (char )'d',      (char )' ', 
        (char )'b',      (char )'e',      (char )' ',      (char )'s', 
        (char )'p',      (char )'e',      (char )'c',      (char )'i', 
        (char )'f',      (char )'i',      (char )'e',      (char )'d', 
        (char )' ',      (char )'a',      (char )'s',      (char )' ', 
        (char )'a',      (char )'r',      (char )'g',      (char )'u', 
        (char )'m',      (char )'e',      (char )'n',      (char )'t', 
        (char )'s',      (char )'.',      (char )' ',      (char )' ', 
        (char )'T',      (char )'h',      (char )'e',      (char )' ', 
        (char )'b',      (char )'u',      (char )'n',      (char )'d', 
        (char )'l',      (char )'e',      (char )' ',      (char )'t', 
        (char )'y',      (char )'p',      (char )'e',      (char )' ', 
        (char )'i',      (char )'s',      (char )' ',      (char )'d', 
        (char )'e',      (char )'t',      (char )'e',      (char )'r', 
        (char )'m',      (char )'i',      (char )'n',      (char )'e', 
        (char )'d',      (char )' ',      (char )'b',      (char )'y', 
        (char )' ',      (char )'t',      (char )'h',      (char )'e', 
        (char )' ',      (char )'f',      (char )'i',      (char )'l', 
        (char )'e',      (char )' ',      (char )'n',      (char )'a', 
        (char )'m',      (char )'e',      (char )' ',      (char )'s', 
        (char )'u',      (char )'f',      (char )'f',      (char )'i', 
        (char )'x',      (char )'.',      (char )' ',      (char )' ', 
        (char )'I',      (char )'t',      (char )' ',      (char )'d', 
        (char )'e',      (char )'f',      (char )'a',      (char )'u', 
        (char )'l',      (char )'t',      (char )'s',      (char )' ', 
        (char )'t',      (char )'o',      (char )' ',      (char )'t', 
        (char )'h',      (char )'e',      (char )' ',      (char )'b', 
        (char )'i',      (char )'n',      (char )'a',      (char )'r', 
        (char )'y',      (char )' ',      (char )'f',      (char )'o', 
        (char )'r',      (char )'m',      (char )'a',      (char )'t', 
        (char )'.',      (char )'\n',      (char )'\n',      (char )'S', 
        (char )'h',      (char )'o',      (char )'u',      (char )'l', 
        (char )'d',      (char )' ',      (char )'t',      (char )'h', 
        (char )'e',      (char )' ',      (char )'f',      (char )'i', 
        (char )'l',      (char )'e',      (char )'n',      (char )'a', 
        (char )'m',      (char )'e',      (char )' ',      (char )'e', 
        (char )'n',      (char )'d',      (char )' ',      (char )'w', 
        (char )'i',      (char )'t',      (char )'h',      (char )' ', 
        (char )'\"',      (char )'.',      (char )'b',      (char )'i', 
        (char )'n',      (char )'\"',      (char )',',      (char )' ', 
        (char )'b',      (char )'i',      (char )'n',      (char )'a', 
        (char )'r',      (char )'y',      (char )' ',      (char )'m', 
        (char )'o',      (char )'d',      (char )'e',      (char )' ', 
        (char )'w',      (char )'i',      (char )'l',      (char )'l', 
        (char )' ',      (char )'b',      (char )'e',      (char )' ', 
        (char )'u',      (char )'s',      (char )'e',      (char )'d', 
        (char )'.',      (char )' ',      (char )' ',      (char )'S', 
        (char )'h',      (char )'o',      (char )'u',      (char )'l', 
        (char )'d',      (char )' ',      (char )'t',      (char )'h', 
        (char )'e',      (char )' ',      (char )'f',      (char )'i', 
        (char )'l',      (char )'e',      (char )'n',      (char )'a', 
        (char )'m',      (char )'e',      (char )' ',      (char )'e', 
        (char )'n',      (char )'d',      (char )' ',      (char )'w', 
        (char )'i',      (char )'t',      (char )'h',      (char )' ', 
        (char )'\"',      (char )'.',      (char )'d',      (char )'a', 
        (char )'t',      (char )'\"',      (char )',',      (char )' ', 
        (char )'t',      (char )'e',      (char )'x',      (char )'t', 
        (char )' ',      (char )'m',      (char )'o',      (char )'d', 
        (char )'e',      (char )' ',      (char )'w',      (char )'i', 
        (char )'l',      (char )'l',      (char )' ',      (char )'b', 
        (char )'e',      (char )' ',      (char )'u',      (char )'s', 
        (char )'e',      (char )'d',      (char )'.',      (char )' ', 
        (char )' ',      (char )'T',      (char )'h',      (char )'e', 
        (char )' ',      (char )'-',      (char )'t',      (char )' ', 
        (char )'o',      (char )'p',      (char )'t',      (char )'i', 
        (char )'o',      (char )'n',      (char )' ',      (char )'c', 
        (char )'a',      (char )'n',      (char )' ',      (char )'b', 
        (char )'e',      (char )' ',      (char )'u',      (char )'s', 
        (char )'e',      (char )'d',      (char )' ',      (char )'t', 
        (char )'o',      (char )' ',      (char )'s',      (char )'e', 
        (char )'t',      (char )' ',      (char )'t',      (char )'h', 
        (char )'e',      (char )' ',      (char )'t',      (char )'y', 
        (char )'p',      (char )'e',      (char )' ',      (char )'o', 
        (char )'f',      (char )' ',      (char )'t',      (char )'h', 
        (char )'e',      (char )' ',      (char )'m',      (char )'i', 
        (char )'c',      (char )'r',      (char )'o',      (char )'c', 
        (char )'o',      (char )'d',      (char )'e',      (char )' ', 
        (char )'b',      (char )'u',      (char )'n',      (char )'d', 
        (char )'l',      (char )'e',      (char )' ',      (char )'f', 
        (char )'i',      (char )'l',      (char )'e',      (char )'s', 
        (char )' ',      (char )'t',      (char )'h',      (char )'a', 
        (char )'t',      (char )' ',      (char )'c',      (char )'o', 
        (char )'m',      (char )'e',      (char )' ',      (char )'a', 
        (char )'f',      (char )'t',      (char )'e',      (char )'r', 
        (char )' ',      (char )'i',      (char )'t',      (char )',', 
        (char )' ',      (char )'e',      (char )'.',      (char )'g', 
        (char )'.',      (char )' ',      (char )'-',      (char )'t', 
        (char )'d',      (char )' ',      (char )'/',      (char )'t', 
        (char )'m',      (char )'p',      (char )'/',      (char )'d', 
        (char )'a',      (char )'t',      (char )'-',      (char )'f', 
        (char )'i',      (char )'l',      (char )'e',      (char )' ', 
        (char )'-',      (char )'t',      (char )'b',      (char )' ', 
        (char )'/',      (char )'t',      (char )'m',      (char )'p', 
        (char )'/',      (char )'b',      (char )'i',      (char )'n', 
        (char )'a',      (char )'r',      (char )'y',      (char )' ', 
        (char )'/',      (char )'t',      (char )'m',      (char )'p', 
        (char )'/',      (char )'b',      (char )'i',      (char )'n', 
        (char )'a',      (char )'r',      (char )'y',      (char )'2', 
        (char )'.',      (char )'\n',      (char )'\n',      (char )'T', 
        (char )'o',      (char )' ',      (char )'l',      (char )'o', 
        (char )'a',      (char )'d',      (char )' ',      (char )'m', 
        (char )'i',      (char )'c',      (char )'r',      (char )'o', 
        (char )'c',      (char )'o',      (char )'d',      (char )'e', 
        (char )' ',      (char )'d',      (char )'a',      (char )'t', 
        (char )'a',      (char )' ',      (char )'f',      (char )'r', 
        (char )'o',      (char )'m',      (char )' ',      (char )'s', 
        (char )'t',      (char )'d',      (char )'i',      (char )'n', 
        (char )',',      (char )' ',      (char )'u',      (char )'s', 
        (char )'e',      (char )' ',      (char )'\"',      (char )'-', 
        (char )'\"',      (char )' ',      (char )'a',      (char )'s', 
        (char )' ',      (char )'t',      (char )'h',      (char )'e', 
        (char )' ',      (char )'f',      (char )'i',      (char )'l', 
        (char )'e',      (char )'n',      (char )'a',      (char )'m', 
        (char )'e',      (char )'.',      (char )' ',      (char )' ', 
        (char )'F',      (char )'i',      (char )'l',      (char )'e', 
        (char )' ',      (char )'t',      (char )'y',      (char )'p', 
        (char )'e',      (char )' ',      (char )'w',      (char )'i', 
        (char )'l',      (char )'l',      (char )' ',      (char )'b', 
        (char )'e',      (char )' ',      (char )'a',      (char )'s', 
        (char )'s',      (char )'u',      (char )'m',      (char )'e', 
        (char )'d',      (char )' ',      (char )'t',      (char )'o', 
        (char )' ',      (char )'b',      (char )'e',      (char )' ', 
        (char )'t',      (char )'e',      (char )'x',      (char )'t', 
        (char )' ',      (char )'(',      (char )'\"',      (char )'.', 
        (char )'d',      (char )'a',      (char )'t',      (char )'\"', 
        (char )')',      (char )',',      (char )' ',      (char )'u', 
        (char )'s',      (char )'e',      (char )' ',      (char )'o', 
        (char )'p',      (char )'t',      (char )'i',      (char )'o', 
        (char )'n',      (char )' ',      (char )'-',      (char )'t', 
        (char )'b',      (char )' ',      (char )'t',      (char )'o', 
        (char )' ',      (char )'l',      (char )'o',      (char )'a', 
        (char )'d',      (char )' ',      (char )'b',      (char )'i', 
        (char )'n',      (char )'a',      (char )'r',      (char )'y', 
        (char )' ',      (char )'d',      (char )'a',      (char )'t', 
        (char )'a',      (char )' ',      (char )'f',      (char )'r', 
        (char )'o',      (char )'m',      (char )' ',      (char )'s', 
        (char )'t',      (char )'d',      (char )'i',      (char )'n', 
        (char )'.',      (char )'\n',      (char )'\n',      (char )'T', 
        (char )'o',      (char )' ',      (char )'l',      (char )'o', 
        (char )'a',      (char )'d',      (char )' ',      (char )'a', 
        (char )'l',      (char )'l',      (char )' ',      (char )'f', 
        (char )'i',      (char )'l',      (char )'e',      (char )'s', 
        (char )' ',      (char )'f',      (char )'r',      (char )'o', 
        (char )'m',      (char )' ',      (char )'a',      (char )' ', 
        (char )'d',      (char )'i',      (char )'r',      (char )'e', 
        (char )'c',      (char )'t',      (char )'o',      (char )'r', 
        (char )'y',      (char )',',      (char )' ',      (char )'s', 
        (char )'p',      (char )'e',      (char )'c',      (char )'i', 
        (char )'f',      (char )'y',      (char )' ',      (char )'t', 
        (char )'h',      (char )'e',      (char )' ',      (char )'d', 
        (char )'i',      (char )'r',      (char )'e',      (char )'c', 
        (char )'t',      (char )'o',      (char )'r',      (char )'y', 
        (char )' ',      (char )'n',      (char )'a',      (char )'m', 
        (char )'e',      (char )'.',      (char )' ',      (char )' ', 
        (char )'I',      (char )'t',      (char )' ',      (char )'w', 
        (char )'i',      (char )'l',      (char )'l',      (char )' ', 
        (char )'n',      (char )'o',      (char )'t',      (char )' ', 
        (char )'r',      (char )'e',      (char )'c',      (char )'u', 
        (char )'r',      (char )'s',      (char )'e',      (char )' ', 
        (char )'i',      (char )'n',      (char )'t',      (char )'o', 
        (char )' ',      (char )'s',      (char )'u',      (char )'b', 
        (char )'d',      (char )'i',      (char )'r',      (char )'e', 
        (char )'c',      (char )'t',      (char )'o',      (char )'r', 
        (char )'i',      (char )'e',      (char )'s',      (char )',', 
        (char )' ',      (char )'t',      (char )'h',      (char )'e', 
        (char )'y',      (char )' ',      (char )'w',      (char )'i', 
        (char )'l',      (char )'l',      (char )' ',      (char )'b', 
        (char )'e',      (char )' ',      (char )'s',      (char )'k', 
        (char )'i',      (char )'p',      (char )'p',      (char )'e', 
        (char )'d',      (char )'.',      (char )'\n',      (char )'\n', 
        (char )'E',      (char )'m',      (char )'p',      (char )'t', 
        (char )'y',      (char )' ',      (char )'f',      (char )'i', 
        (char )'l',      (char )'e',      (char )'s',      (char )' ', 
        (char )'a',      (char )'n',      (char )'d',      (char )' ', 
        (char )'d',      (char )'i',      (char )'r',      (char )'e', 
        (char )'c',      (char )'t',      (char )'o',      (char )'r', 
        (char )'i',      (char )'e',      (char )'s',      (char )' ', 
        (char )'w',      (char )'i',      (char )'l',      (char )'l', 
        (char )' ',      (char )'b',      (char )'e',      (char )' ', 
        (char )'i',      (char )'g',      (char )'n',      (char )'o', 
        (char )'r',      (char )'e',      (char )'d',      (char )',', 
        (char )' ',      (char )'a',      (char )'n',      (char )'d', 
        (char )' ',      (char )'w',      (char )'i',      (char )'l', 
        (char )'l',      (char )' ',      (char )'b',      (char )'e', 
        (char )' ',      (char )'s',      (char )'k',      (char )'i', 
        (char )'p',      (char )'p',      (char )'e',      (char )'d', 
        (char )'.',      (char )'\000'};
#line 2033 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static struct argp_option cmdline_options[26]  = 
#line 2033
  {      {(char const   *)((void *)0), 'h', (char const   *)((void *)0), 0, "Give this help list",
      -1}, 
        {"quiet", 'q', (char const   *)((void *)0), 0, "Quiet operation", 1}, 
        {"verbose", 'v', (char const   *)((void *)0), 0, "Verbose operation (cumulative)",
      1}, 
        {(char const   *)((void *)0), 't', "type", 0, "Sets input file type for the next microcode files. The type is a single character: \"b\" (binary), \"d\" (Intel .dat), or \"a\" (type will be selected by filename suffix)",
      10}, 
        {(char const   *)((void *)0), 's', "! | [!]signature[,pf_mask]", 0, "Select microcodes by the specificed signature and processor flags mask.  Specify more than once to select/unselect more microcodes.  Prefix with ! to unselect microcodes.  Use -s ! to disable the default behaviour of selecting all microcodes when no -s or -S filter is specified",
      20}, 
        {"scan-system", 'S', (char const   *)((void *)0), 0, "Select microcodes by scanning all online processors on this system for their signatures.  Can be combined with the -s option.  Note: this option has precedence over the -s option, microcodes selected by --scan-system cannot be unselected by -s",
      20}, 
        {"downgrade", 135, (char const   *)((void *)0), 0, "Instead of discarding microcodes based on revision level, keep the one from the file loaded last.  Files are loaded in the order they were specified in the command line",
      25}, 
        {"no-downgrade", 136, (char const   *)((void *)0), 0, "Keep the microcode with the highest revision level, regardless of the file load order (default)",
      25}, 
        {"date-before", 137, "YYYY-MM-DD", 0, "Select only microcodes older than the specified date",
      27}, 
        {"date-after", 138, "YYYY-MM-DD", 0, "Select only microcodes newer than the specified date",
      27}, 
        {"loose-date-filtering", 140, (char const   *)((void *)0), 0, "Consider for selection other revisions (outside of the date range) of every microcode that was selected within the date range",
      28}, 
        {"strict-date-filtering", 139, (char const   *)((void *)0), 0, "Select only microcodes strictly within the date range (default)",
      28}, 
        {"list", 'l', (char const   *)((void *)0), 0, "List selected microcode signatures",
      30}, 
        {"list-all", 'L', (char const   *)((void *)0), 0, "List all microcode signatures",
      30}, 
        {"kernel", 'k', "device", 1, "Upload selected microcodes to the kernel.  Optionally, the device path can be specified (default: /dev/cpu/microcode)",
      40}, 
        {"write-firmware", 'K', "directory", 1, "Write selected microcodes with the filenames expected by the Linux kernel firmware loader.  Optionally, the destination directory can be specified (default: /lib/firmware/intel-ucode)",
      40}, 
        {"write-to", 'w', "file", 0, "Write selected microcodes to a file in binary format.  The binary format is suitable to be uploaded to the kernel",
      40}, 
        {"write-named-to", 'W', "directory", 0, "Write selected microcodes to files in the specified directory, in binary format.  The file name will reflect the microcode signature, mask and revision",
      40}, 
        {"write-earlyfw", 141, "file", 0, "Write selected microcodes to an early initramfs file, which should be prepended to the regular initramfs",
      40}, 
        {"overwrite", 133, (char const   *)((void *)0), 0, "Unlink (remove) destination files before writing",
      45}, 
        {"no-overwrite", 134, (char const   *)((void *)0), 0, "Do not remove existing files (default)",
      45}, 
        {"strict-checks", 129, (char const   *)((void *)0), 0, "Perform strict checks on the microcode data (default)",
      50}, 
        {"no-strict-checks", 130, (char const   *)((void *)0), 0, "Perform less strict checks on the microcode data",
      51}, 
        {"ignore-broken", 131, (char const   *)((void *)0), 0, "Skip broken microcode entries instead of aborting",
      55}, 
        {"no-ignore-broken", 132, (char const   *)((void *)0), 0, "Abort on broken microcode entries (default)",
      56}, 
        {(char const   *)0, 0, (char const   *)0, 0, (char const   *)0, 0}};
#line 2133 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static char cmdline_nonarg_doc[26]  = 
#line 2133
  {      (char )'[',      (char )'[',      (char )'-',      (char )'t', 
        (char )'<',      (char )'t',      (char )'y',      (char )'p', 
        (char )'e',      (char )'>',      (char )']',      (char )' ', 
        (char )'f',      (char )'i',      (char )'l',      (char )'e', 
        (char )'n',      (char )'a',      (char )'m',      (char )'e', 
        (char )']',      (char )' ',      (char )'.',      (char )'.', 
        (char )'.',      (char )'\000'};
#line 2135 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static int new_filename(char const   * const  fn , intel_ucode_file_type_t ftype ) 
{ 
  struct filename_list **p___0 ;
  struct filename_list *n ;
  size_t s ;
  size_t l ;
  void *tmp ;

  {
  {
#line 2141
  l = strlen((char const   *)fn);
  }
#line 2142
  if (l > 1UL) {
#line 2142
    if ((int const   )*(fn + (l - 1UL)) == 47) {
#line 2143
      l --;
    }
  }
#line 2145
  if (! l) {
#line 2146
    return (22);
  }
  {
#line 2148
  s = (sizeof(struct filename_list ) + l) + 1UL;
#line 2149
  tmp = malloc(s);
#line 2149
  n = (struct filename_list *)tmp;
  }
#line 2150
  if (! n) {
#line 2151
    return (12);
  }
  {
#line 2153
  memset((void *)n, 0, s);
#line 2154
  memcpy((void */* __restrict  */)(n->path), (void const   */* __restrict  */)fn,
         l);
#line 2155
  n->type = ftype;
#line 2158
  p___0 = & input_files;
  }
  {
#line 2159
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2159
    if (! *p___0) {
#line 2159
      goto while_break;
    }
#line 2160
    p___0 = & (*p___0)->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 2161
  *p___0 = n;
#line 2163
  return (0);
}
}
#line 2182 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static int add_ucode_filter(char const   *arg ) 
{ 
  char *p___0 ;
  uint32_t acpuid ;
  uint32_t amask ;
  int invert ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  int *tmp___2 ;
  unsigned long tmp___3 ;
  int *tmp___4 ;
  unsigned short const   **tmp___5 ;
  int *tmp___6 ;
  unsigned long tmp___7 ;
  int *tmp___8 ;
  unsigned short const   **tmp___9 ;
  int tmp___10 ;

  {
#line 2188
  amask = (uint32_t )0;
#line 2189
  invert = 0;
  {
#line 2191
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2191
    tmp = __ctype_b_loc();
    }
#line 2191
    if (! ((int const   )*(*tmp + (int )*arg) & 8192)) {
#line 2191
      goto while_break;
    }
#line 2192
    arg ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2193
  if ((int const   )*arg == 33) {
    {
#line 2194
    invert = 1;
#line 2195
    arg ++;
#line 2198
    tmp___1 = __ctype_b_loc();
    }
#line 2198
    if ((int const   )*(*tmp___1 + (int )*arg) & 8192) {
      {
#line 2199
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 2199
        tmp___0 = __ctype_b_loc();
        }
#line 2199
        if (! ((int const   )*(*tmp___0 + (int )*arg) & 8192)) {
#line 2199
          goto while_break___0;
        }
#line 2200
        arg ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2201
      if (! *arg) {
#line 2202
        return (22);
      }
    }
#line 2204
    if (! *arg) {
#line 2205
      filter_list_allow = 0;
#line 2206
      return (0);
    }
  }
  {
#line 2210
  tmp___2 = __errno_location();
#line 2210
  *tmp___2 = 0;
#line 2211
  tmp___3 = strtoul((char const   */* __restrict  */)arg, (char **/* __restrict  */)(& p___0),
                    0);
#line 2211
  acpuid = (uint32_t )tmp___3;
#line 2212
  tmp___4 = __errno_location();
  }
#line 2212
  if (*tmp___4) {
#line 2213
    return (22);
  } else
#line 2212
  if ((unsigned long )p___0 == (unsigned long )arg) {
#line 2213
    return (22);
  } else
#line 2212
  if (! *arg) {
#line 2213
    return (22);
  }
  {
#line 2214
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 2214
    tmp___5 = __ctype_b_loc();
    }
#line 2214
    if (! ((int const   )*(*tmp___5 + (int )*p___0) & 8192)) {
#line 2214
      goto while_break___1;
    }
#line 2215
    p___0 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2217
  if ((int )*p___0 == 44) {
    {
#line 2218
    p___0 ++;
#line 2219
    arg = (char const   *)p___0;
#line 2220
    tmp___6 = __errno_location();
#line 2220
    *tmp___6 = 0;
#line 2221
    tmp___7 = strtoul((char const   */* __restrict  */)arg, (char **/* __restrict  */)(& p___0),
                      0);
#line 2221
    amask = (uint32_t )tmp___7;
#line 2222
    tmp___8 = __errno_location();
    }
#line 2222
    if (*tmp___8) {
#line 2223
      return (22);
    } else
#line 2222
    if ((unsigned long )p___0 == (unsigned long )arg) {
#line 2223
      return (22);
    } else
#line 2222
    if (! *arg) {
#line 2223
      return (22);
    }
    {
#line 2224
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 2224
      tmp___9 = __ctype_b_loc();
      }
#line 2224
      if (! ((int const   )*(*tmp___9 + (int )*p___0) & 8192)) {
#line 2224
        goto while_break___2;
      }
#line 2225
      p___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 2226
    if (*p___0) {
#line 2227
      return (22);
    }
  } else
#line 2228
  if (*p___0) {
#line 2229
    return (22);
  }
#line 2232
  if (! invert) {
#line 2233
    filter_list_allow = 0;
  }
  {
#line 2235
  tmp___10 = add_filter_to_list(acpuid, amask, invert, (struct microcode_filter_entry **/* const  */)(& uc_filter_list));
  }
#line 2235
  return (tmp___10);
}
}
#line 2239 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static int cmdline_get_date(char const   *arg , uint32_t *d ) 
{ 
  unsigned long year ;
  unsigned long month ;
  unsigned long day ;
  char *p___0 ;
  unsigned short const   **tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  unsigned short const   **tmp___4 ;

  {
  {
#line 2244
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2244
    tmp = __ctype_b_loc();
    }
#line 2244
    if (! ((int const   )*(*tmp + (int )*arg) & 8192)) {
#line 2244
      goto while_break;
    }
#line 2245
    arg ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2247
  tmp___0 = __errno_location();
#line 2247
  *tmp___0 = 0;
#line 2248
  year = strtoul((char const   */* __restrict  */)arg, (char **/* __restrict  */)(& p___0),
                 10);
#line 2249
  tmp___1 = __errno_location();
  }
#line 2249
  if (*tmp___1) {
#line 2250
    return (22);
  } else
#line 2249
  if ((unsigned long )p___0 == (unsigned long )arg) {
#line 2250
    return (22);
  } else
#line 2249
  if ((int )*p___0 != 45) {
#line 2250
    return (22);
  }
  {
#line 2251
  p___0 ++;
#line 2251
  arg = (char const   *)p___0;
#line 2252
  month = strtoul((char const   */* __restrict  */)arg, (char **/* __restrict  */)(& p___0),
                  10);
#line 2253
  tmp___2 = __errno_location();
  }
#line 2253
  if (*tmp___2) {
#line 2254
    return (22);
  } else
#line 2253
  if ((unsigned long )p___0 == (unsigned long )arg) {
#line 2254
    return (22);
  } else
#line 2253
  if ((int )*p___0 != 45) {
#line 2254
    return (22);
  }
  {
#line 2255
  p___0 ++;
#line 2255
  arg = (char const   *)p___0;
#line 2256
  day = strtoul((char const   */* __restrict  */)arg, (char **/* __restrict  */)(& p___0),
                10);
#line 2257
  tmp___3 = __errno_location();
  }
#line 2257
  if (*tmp___3) {
#line 2258
    return (22);
  } else
#line 2257
  if ((unsigned long )p___0 == (unsigned long )arg) {
#line 2258
    return (22);
  }
  {
#line 2259
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 2259
    tmp___4 = __ctype_b_loc();
    }
#line 2259
    if (! ((int const   )*(*tmp___4 + (int )*p___0) & 8192)) {
#line 2259
      goto while_break___0;
    }
#line 2260
    p___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2261
  if (*p___0) {
#line 2262
    return (22);
  }
#line 2264
  if (year > 9999UL) {
#line 2265
    return (22);
  } else
#line 2264
  if (month > 99UL) {
#line 2265
    return (22);
  } else
#line 2264
  if (day > 99UL) {
#line 2265
    return (22);
  }
#line 2268
  *d = (uint32_t )((((((((year / 1000UL << 28) | ((year / 100UL) % 10UL << 24)) | ((year / 10UL) % 10UL << 20)) | (year % 10UL << 16)) | (month / 10UL << 12)) | (month % 10UL << 8)) | (day / 10UL << 4)) | day % 10UL);
#line 2277
  return (0);
}
}
#line 2280 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static error_t cmdline_do_parse_arg(int key , char *arg , struct argp_state *state ) 
{ 
  int rc ;
  size_t tmp ;
  uint32_t *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 2286
  if (key == 104) {
#line 2286
    goto case_104;
  }
#line 2289
  if (key == 113) {
#line 2289
    goto case_113;
  }
#line 2292
  if (key == 118) {
#line 2292
    goto case_118;
  }
#line 2296
  if (key == 76) {
#line 2296
    goto case_76;
  }
#line 2299
  if (key == 108) {
#line 2299
    goto case_108;
  }
#line 2303
  if (key == 116) {
#line 2303
    goto case_116;
  }
#line 2321
  if (key == 107) {
#line 2321
    goto case_107;
  }
#line 2333
  if (key == 75) {
#line 2333
    goto case_75;
  }
#line 2345
  if (key == 119) {
#line 2345
    goto case_119;
  }
#line 2353
  if (key == 141) {
#line 2353
    goto case_141;
  }
#line 2361
  if (key == 87) {
#line 2361
    goto case_87;
  }
#line 2371
  if (key == 133) {
#line 2371
    goto case_133;
  }
#line 2374
  if (key == 134) {
#line 2374
    goto case_134;
  }
#line 2378
  if (key == 115) {
#line 2378
    goto case_115;
  }
#line 2392
  if (key == 83) {
#line 2392
    goto case_83;
  }
#line 2397
  if (key == 138) {
#line 2397
    goto case_138;
  }
#line 2397
  if (key == 137) {
#line 2397
    goto case_138;
  }
#line 2403
  if (key == 139) {
#line 2403
    goto case_139;
  }
#line 2406
  if (key == 140) {
#line 2406
    goto case_140;
  }
#line 2410
  if (key == 129) {
#line 2410
    goto case_129;
  }
#line 2413
  if (key == 130) {
#line 2413
    goto case_130;
  }
#line 2416
  if (key == 131) {
#line 2416
    goto case_131;
  }
#line 2419
  if (key == 132) {
#line 2419
    goto case_132;
  }
#line 2422
  if (key == 135) {
#line 2422
    goto case_135;
  }
#line 2425
  if (key == 136) {
#line 2425
    goto case_136;
  }
#line 2429
  if (key == 0) {
#line 2429
    goto case_0___0;
  }
#line 2437
  goto switch_default___1;
  case_104: /* CIL Label */ 
  {
#line 2287
  argp_state_help((struct argp_state  const  */* __restrict  */)state, (FILE */* __restrict  */)stdout,
                  634U);
  }
  case_113: /* CIL Label */ 
#line 2290
  verbosity = 0;
#line 2291
  goto switch_break;
  case_118: /* CIL Label */ 
#line 2293
  verbosity ++;
#line 2294
  goto switch_break;
  case_76: /* CIL Label */ 
#line 2297
  list_all_microcodes = 1;
#line 2298
  goto switch_break;
  case_108: /* CIL Label */ 
#line 2300
  list_sel_microcodes = 1;
#line 2301
  goto switch_break;
  case_116: /* CIL Label */ 
#line 2304
  if (! arg) {
    {
#line 2305
    argp_error((struct argp_state  const  */* __restrict  */)state, (char const   */* __restrict  */)"unknown file type: %s\n",
               arg);
    }
  } else {
    {
#line 2304
    tmp = strlen((char const   *)arg);
    }
#line 2304
    if (tmp > 1UL) {
      {
#line 2305
      argp_error((struct argp_state  const  */* __restrict  */)state, (char const   */* __restrict  */)"unknown file type: %s\n",
                 arg);
      }
    }
  }
  {
#line 2307
  if ((int )*arg == 100) {
#line 2307
    goto case_100;
  }
#line 2310
  if ((int )*arg == 98) {
#line 2310
    goto case_98;
  }
#line 2313
  if ((int )*arg == 97) {
#line 2313
    goto case_97;
  }
#line 2316
  goto switch_default;
  case_100: /* CIL Label */ 
#line 2308
  ucfiletype = (intel_ucode_file_type_t )1;
#line 2309
  goto switch_break___0;
  case_98: /* CIL Label */ 
#line 2311
  ucfiletype = (intel_ucode_file_type_t )2;
#line 2312
  goto switch_break___0;
  case_97: /* CIL Label */ 
#line 2314
  ucfiletype = (intel_ucode_file_type_t )0;
#line 2315
  goto switch_break___0;
  switch_default: /* CIL Label */ 
  {
#line 2317
  argp_error((struct argp_state  const  */* __restrict  */)state, (char const   */* __restrict  */)"unknown file type: %c\n",
             (int )*arg);
  }
  switch_break___0: /* CIL Label */ ;
  }
#line 2319
  goto switch_break;
  case_107: /* CIL Label */ 
#line 2322
  if ((unsigned int )command_line_actions & 1U) {
    {
#line 2323
    argp_error((struct argp_state  const  */* __restrict  */)state, (char const   */* __restrict  */)"-k option can be specified only once\n");
    }
  }
#line 2326
  if (arg) {
    {
#line 2327
    upload_microcode = strdup((char const   *)arg);
    }
  } else {
    {
#line 2329
    upload_microcode = strdup("/dev/cpu/microcode");
    }
  }
#line 2331
  command_line_actions = (enum __anonenum_command_line_actions_32 )((unsigned int )command_line_actions | 1U);
#line 2332
  goto switch_break;
  case_75: /* CIL Label */ 
#line 2334
  if ((unsigned int )command_line_actions & 4U) {
    {
#line 2335
    argp_error((struct argp_state  const  */* __restrict  */)state, (char const   */* __restrict  */)"-K option can be specified only once\n");
    }
  }
#line 2338
  if (arg) {
    {
#line 2339
    write_firmware = strdup((char const   *)arg);
    }
  } else {
    {
#line 2341
    write_firmware = strdup("/lib/firmware/intel-ucode");
    }
  }
#line 2343
  command_line_actions = (enum __anonenum_command_line_actions_32 )((unsigned int )command_line_actions | 4U);
#line 2344
  goto switch_break;
  case_119: /* CIL Label */ 
#line 2346
  if ((unsigned int )command_line_actions & 2U) {
    {
#line 2347
    argp_error((struct argp_state  const  */* __restrict  */)state, (char const   */* __restrict  */)"-w option can be specified only once\n");
    }
  }
  {
#line 2350
  write_microcode = strdup((char const   *)arg);
#line 2351
  command_line_actions = (enum __anonenum_command_line_actions_32 )((unsigned int )command_line_actions | 2U);
  }
#line 2352
  goto switch_break;
  case_141: /* CIL Label */ 
#line 2354
  if ((unsigned int )command_line_actions & 64U) {
    {
#line 2355
    argp_error((struct argp_state  const  */* __restrict  */)state, (char const   */* __restrict  */)"--write-earlyfw option can be specified only once\n");
    }
  }
  {
#line 2358
  write_early_firmware = strdup((char const   *)arg);
#line 2359
  command_line_actions = (enum __anonenum_command_line_actions_32 )((unsigned int )command_line_actions | 64U);
  }
#line 2360
  goto switch_break;
  case_87: /* CIL Label */ 
#line 2362
  if ((unsigned int )command_line_actions & 32U) {
    {
#line 2363
    argp_error((struct argp_state  const  */* __restrict  */)state, (char const   */* __restrict  */)"-W option can be specified only once\n");
    }
  }
  {
#line 2366
  write_named = strdup((char const   *)arg);
#line 2368
  command_line_actions = (enum __anonenum_command_line_actions_32 )((unsigned int )command_line_actions | 32U);
  }
#line 2369
  goto switch_break;
  case_133: /* CIL Label */ 
#line 2372
  unlink_files = 1;
#line 2373
  goto switch_break;
  case_134: /* CIL Label */ 
#line 2375
  unlink_files = 0;
#line 2376
  goto switch_break;
  case_115: /* CIL Label */ 
  {
#line 2379
  rc = add_ucode_filter((char const   *)arg);
  }
  {
#line 2382
  if (rc == 17) {
#line 2382
    goto case_17;
  }
#line 2382
  if (rc == 0) {
#line 2382
    goto case_17;
  }
#line 2384
  if (rc == 22) {
#line 2384
    goto case_22;
  }
#line 2386
  goto switch_default___0;
  case_17: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 2383
  goto switch_break___1;
  case_22: /* CIL Label */ 
  {
#line 2385
  argp_error((struct argp_state  const  */* __restrict  */)state, (char const   */* __restrict  */)"invalid filter: %s",
             arg);
  }
  switch_default___0: /* CIL Label */ 
  {
#line 2387
  argp_failure((struct argp_state  const  */* __restrict  */)state, 2, rc, (char const   */* __restrict  */)"could not add filter \'%s\'",
               arg);
  }
  switch_break___1: /* CIL Label */ ;
  }
#line 2390
  command_line_actions = (enum __anonenum_command_line_actions_32 )((unsigned int )command_line_actions | 4096U);
#line 2391
  goto switch_break;
  case_83: /* CIL Label */ 
#line 2393
  command_line_actions = (enum __anonenum_command_line_actions_32 )((unsigned int )command_line_actions | 4104U);
#line 2394
  goto switch_break;
  case_138: /* CIL Label */ 
  case_137: /* CIL Label */ 
#line 2398
  if (key == 137) {
#line 2398
    tmp___0 = & datefilter_max;
  } else {
#line 2398
    tmp___0 = & datefilter_min;
  }
  {
#line 2398
  tmp___1 = cmdline_get_date((char const   *)arg, tmp___0);
  }
#line 2398
  if (tmp___1) {
    {
#line 2400
    argp_error((struct argp_state  const  */* __restrict  */)state, (char const   */* __restrict  */)"invalid date: %s",
               arg);
    }
  }
#line 2401
  command_line_actions = (enum __anonenum_command_line_actions_32 )((unsigned int )command_line_actions | 4096U);
#line 2402
  goto switch_break;
  case_139: /* CIL Label */ 
#line 2404
  datefilter_loose = 0;
#line 2405
  goto switch_break;
  case_140: /* CIL Label */ 
#line 2407
  datefilter_loose = 1;
#line 2408
  goto switch_break;
  case_129: /* CIL Label */ 
#line 2411
  strict_checks = 1;
#line 2412
  goto switch_break;
  case_130: /* CIL Label */ 
#line 2414
  strict_checks = 0;
#line 2415
  goto switch_break;
  case_131: /* CIL Label */ 
#line 2417
  ignore_bad_ucode = 1;
#line 2418
  goto switch_break;
  case_132: /* CIL Label */ 
#line 2420
  ignore_bad_ucode = 0;
#line 2421
  goto switch_break;
  case_135: /* CIL Label */ 
#line 2423
  allow_downgrade = 1;
#line 2424
  goto switch_break;
  case_136: /* CIL Label */ 
#line 2426
  allow_downgrade = 0;
#line 2427
  goto switch_break;
  case_0___0: /* CIL Label */ 
  {
#line 2430
  rc = new_filename((char const   */* const  */)arg, ucfiletype);
  }
#line 2431
  if (rc) {
    {
#line 2432
    argp_failure((struct argp_state  const  */* __restrict  */)state, 2, rc, (char const   */* __restrict  */)"could not add path \'%s\'",
                 arg);
    }
  }
#line 2434
  command_line_actions = (enum __anonenum_command_line_actions_32 )((unsigned int )command_line_actions | 16U);
#line 2435
  goto switch_break;
  switch_default___1: /* CIL Label */ 
#line 2438
  return (7);
  switch_break: /* CIL Label */ ;
  }
#line 2441
  return (0);
}
}
#line 2444 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
static struct argp cmdline_argp  =    {(struct argp_option  const  *)(cmdline_options), & cmdline_do_parse_arg, (char const   *)(cmdline_nonarg_doc),
    (char const   *)(cmdline_doc), (struct argp_child  const  *)0, (char *(*)(int __key ,
                                                                              char const   *__text ,
                                                                              void *__input ))0,
    (char const   *)0};
#line 2450 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/iucode_tool.c"
int main(int argc , char **argv ) 
{ 
  int rc ;
  int tmp ;
  struct filename_list *fn ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 2454
  progname = *(argv + 0);
#line 2456
  argp_err_exit_status = 1;
#line 2457
  argp_program_version = program_version;
#line 2458
  argp_program_bug_address = (char const   *)((void *)0);
#line 2459
  argp_parse((struct argp  const  */* __restrict  */)(& cmdline_argp), argc, (char **/* __restrict  */)argv,
             8U, (int */* __restrict  */)((void *)0), (void */* __restrict  */)((void *)0));
  }
#line 2461
  if (! command_line_actions) {
    {
#line 2462
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2462
      if (verbosity >= 1) {
        {
#line 2462
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: nothing to do...\n",
                progname);
        }
      }
#line 2462
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 2463
    goto do_nothing;
  }
#line 2466
  if ((unsigned int )command_line_actions & 8U) {
    {
#line 2466
    tmp = scan_system_processors();
    }
#line 2466
    if (tmp) {
#line 2468
      rc = 2;
#line 2469
      goto err_exit;
    }
  }
#line 2472
  if ((unsigned int )command_line_actions & 16U) {
#line 2473
    fn = input_files;
    {
#line 2474
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2474
      if (! fn) {
#line 2474
        goto while_break___0;
      }
      {
#line 2475
      tmp___0 = load_intel_microcode((char const   *)(fn->path), (intel_ucode_file_type_t const   )fn->type);
      }
      {
#line 2476
      if (tmp___0 == 0) {
#line 2476
        goto case_0;
      }
#line 2478
      if (tmp___0 == 95) {
#line 2478
        goto case_95;
      }
#line 2481
      goto switch_default;
      case_0: /* CIL Label */ 
#line 2477
      goto switch_break;
      case_95: /* CIL Label */ 
#line 2479
      rc = 1;
#line 2480
      goto err_exit;
      switch_default: /* CIL Label */ 
#line 2482
      if (! ignore_bad_ucode) {
#line 2483
        rc = 2;
#line 2484
        goto err_exit;
      }
      switch_break: /* CIL Label */ ;
      }
#line 2487
      fn = fn->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2490
    if (microcode_bundles) {
      {
#line 2490
      tmp___1 = do_process_microcodes();
      }
#line 2490
      if (tmp___1) {
#line 2491
        rc = 2;
#line 2492
        goto err_exit;
      }
    }
  }
#line 2496
  if ((unsigned int )command_line_actions & 103U) {
#line 2497
    if (microcodes) {
#line 2498
      rc = 0;
#line 2499
      if (upload_microcode) {
        {
#line 2500
        rc = do_upload_microcode((char const   */* const  */)upload_microcode);
        }
      }
#line 2501
      if (! rc) {
#line 2501
        if (write_microcode) {
          {
#line 2502
          rc = do_write_microcode((char const   */* const  */)write_microcode, 0);
          }
        }
      }
#line 2503
      if (! rc) {
#line 2503
        if (write_early_firmware) {
          {
#line 2504
          rc = do_write_microcode((char const   */* const  */)write_early_firmware,
                                  1);
          }
        }
      }
#line 2505
      if (! rc) {
#line 2505
        if (write_firmware) {
          {
#line 2506
          rc = do_write_firmware((char const   */* const  */)write_firmware);
          }
        }
      }
#line 2507
      if (! rc) {
#line 2507
        if (write_named) {
          {
#line 2508
          rc = do_write_named((char const   */* const  */)write_named);
          }
        }
      }
#line 2510
      if (rc) {
#line 2511
        rc = 2;
#line 2512
        goto err_exit;
      }
    } else {
      {
#line 2515
      tmp___2 = filter_list_active();
      }
#line 2515
      if (tmp___2) {
        {
#line 2516
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 2516
          if (verbosity >= 1) {
            {
#line 2516
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: No valid microcodes were selected, nothing to do...\n",
                    progname);
            }
          }
#line 2516
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
      } else {
        {
#line 2518
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 2518
          if (verbosity >= 1) {
            {
#line 2518
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: No valid microcodes were loaded, nothing to do...\n",
                    progname);
            }
          }
#line 2518
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    }
  }
  do_nothing: 
#line 2524
  rc = 0;
  err_exit: 
#line 2544
  return (rc);
}
}
#line 69 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 101 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/intel_microcode.c"
__inline static uint32_t intel_ucode_v1_get_totalsize(struct intel_ucode_v1_hdr  const  * const  hdr ) 
{ 


  {
#line 104
  if (hdr->datasize != 0U) {
#line 105
    return ((uint32_t )hdr->totalsize);
  } else {
#line 107
    return ((uint32_t )(2000UL + sizeof(struct intel_ucode_v1_hdr )));
  }
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/intel_microcode.c"
__inline static uint32_t intel_ucode_v1_get_datasize(struct intel_ucode_v1_hdr  const  * const  hdr ) 
{ 


  {
#line 119
  if (hdr->datasize != 0U) {
#line 120
    return ((uint32_t )hdr->datasize);
  } else {
#line 122
    return ((uint32_t )2000);
  }
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/intel_microcode.c"
intel_ucode_status_t intel_ucode_getmetadata(void const   * const  uc , struct intel_ucode_metadata *metadata ) 
{ 
  struct intel_ucode_v1_hdr  const  *hdr ;
  int tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 136
  hdr = (struct intel_ucode_v1_hdr  const  *)uc;
#line 138
  if (! hdr) {
#line 138
    tmp = 1;
  } else
#line 138
  if (! metadata) {
#line 138
    tmp = 1;
  } else {
#line 138
    tmp = 0;
  }
  {
#line 138
  tmp___0 = __builtin_expect((long )tmp, 0L);
  }
#line 138
  if (tmp___0) {
#line 139
    return ((intel_ucode_status_t )1);
  }
  {
#line 141
  tmp___1 = __builtin_expect((long )(! (! (hdr->hdrver != 1U))), 0L);
  }
#line 141
  if (tmp___1) {
#line 142
    return ((intel_ucode_status_t )3);
  }
  {
#line 144
  metadata->date_year = (uint16_t )(hdr->date & 65535U);
#line 145
  metadata->date_day = (uint8_t )((hdr->date >> 16) & 255U);
#line 146
  metadata->date_month = (uint8_t )((hdr->date >> 24) & 255U);
#line 147
  metadata->revision = (int32_t )hdr->rev;
#line 148
  metadata->loader_version = (uint32_t )hdr->ldrver;
#line 149
  metadata->size = intel_ucode_v1_get_totalsize((struct intel_ucode_v1_hdr  const  */* const  */)hdr);
  }
#line 151
  return ((intel_ucode_status_t )0);
}
}
#line 176 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/intel_microcode.c"
int intel_ucode_compare(void const   * const  uc1 , void const   * const  uc2 ) 
{ 
  struct intel_ucode_v1_hdr  const  *hdr1 ;
  struct intel_ucode_v1_hdr  const  *hdr2 ;
  unsigned long ts1 ;
  unsigned long ts2 ;
  unsigned long ds1 ;
  unsigned long ds2 ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  uint32_t tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t tmp___5 ;
  uint32_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 178
  hdr1 = (struct intel_ucode_v1_hdr  const  *)uc1;
#line 179
  hdr2 = (struct intel_ucode_v1_hdr  const  *)uc2;
#line 182
  if (! uc1) {
#line 182
    tmp = 1;
  } else
#line 182
  if (! uc2) {
#line 182
    tmp = 1;
  } else {
#line 182
    tmp = 0;
  }
  {
#line 182
  tmp___0 = __builtin_expect((long )tmp, 0L);
  }
#line 182
  if (tmp___0) {
#line 183
    return (-22);
  }
#line 185
  if (hdr1->hdrver != 1U) {
#line 185
    tmp___1 = 1;
  } else
#line 185
  if (hdr2->hdrver != 1U) {
#line 185
    tmp___1 = 1;
  } else {
#line 185
    tmp___1 = 0;
  }
  {
#line 185
  tmp___2 = __builtin_expect((long )tmp___1, 0L);
  }
#line 185
  if (tmp___2) {
#line 186
    return (-22);
  }
  {
#line 188
  tmp___3 = intel_ucode_v1_get_totalsize((struct intel_ucode_v1_hdr  const  */* const  */)hdr1);
#line 188
  ts1 = (unsigned long )tmp___3;
#line 189
  tmp___4 = intel_ucode_v1_get_totalsize((struct intel_ucode_v1_hdr  const  */* const  */)hdr2);
#line 189
  ts2 = (unsigned long )tmp___4;
  }
#line 190
  if (ts1 != ts2) {
#line 191
    return (0);
  }
  {
#line 193
  tmp___5 = intel_ucode_v1_get_datasize((struct intel_ucode_v1_hdr  const  */* const  */)hdr1);
#line 193
  ds1 = (unsigned long )tmp___5;
#line 194
  tmp___6 = intel_ucode_v1_get_datasize((struct intel_ucode_v1_hdr  const  */* const  */)hdr2);
#line 194
  ds2 = (unsigned long )tmp___6;
  }
#line 195
  if (ds1 != ds2) {
#line 196
    return (0);
  }
#line 198
  if (ds1 + sizeof(struct intel_ucode_v1_hdr ) < ts1) {
#line 199
    return (0);
  }
#line 201
  if (hdr1->sig != hdr2->sig) {
#line 202
    return (0);
  } else
#line 201
  if (hdr1->rev != hdr2->rev) {
#line 202
    return (0);
  }
  {
#line 204
  tmp___8 = memcmp((void const   *)((uint8_t *)uc1 + sizeof(struct intel_ucode_v1_hdr )),
                   (void const   *)((uint8_t *)uc2 + sizeof(struct intel_ucode_v1_hdr )),
                   ds1);
  }
#line 204
  if (tmp___8) {
#line 206
    if (hdr1->pf_mask & hdr2->pf_mask) {
#line 206
      tmp___7 = -9;
    } else {
#line 206
      tmp___7 = 0;
    }
#line 206
    return (tmp___7);
  }
#line 214
  if (hdr1->date == hdr2->date) {
#line 214
    if (hdr1->pf_mask == hdr2->pf_mask) {
#line 214
      tmp___9 = 2;
    } else {
#line 214
      tmp___9 = 1;
    }
  } else {
#line 214
    tmp___9 = 1;
  }
#line 214
  return (tmp___9);
}
}
#line 227 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/intel_microcode.c"
char const   *intel_ucode_errstr(intel_ucode_status_t const   status ) 
{ 


  {
  {
#line 230
  if ((unsigned int const   )status == 2U) {
#line 230
    goto case_2;
  }
#line 232
  if ((unsigned int const   )status == 3U) {
#line 232
    goto case_3;
  }
#line 234
  if ((unsigned int const   )status == 5U) {
#line 234
    goto case_5;
  }
#line 236
  if ((unsigned int const   )status == 6U) {
#line 236
    goto case_6;
  }
#line 238
  if ((unsigned int const   )status == 8U) {
#line 238
    goto case_8;
  }
#line 240
  if ((unsigned int const   )status == 7U) {
#line 240
    goto case_7;
  }
#line 242
  if ((unsigned int const   )status == 4U) {
#line 242
    goto case_4;
  }
#line 244
  if ((unsigned int const   )status == 9U) {
#line 244
    goto case_9;
  }
#line 246
  if ((unsigned int const   )status == 0U) {
#line 246
    goto case_0;
  }
#line 248
  if ((unsigned int const   )status == 1U) {
#line 248
    goto case_1;
  }
#line 250
  goto switch_default;
  case_2: /* CIL Label */ 
#line 231
  return ("invalid microcode data");
  case_3: /* CIL Label */ 
#line 233
  return ("unknown microcode format");
  case_5: /* CIL Label */ 
#line 235
  return ("bad extended signature table");
  case_6: /* CIL Label */ 
#line 237
  return ("incorrect extended signature table checksum");
  case_8: /* CIL Label */ 
#line 239
  return ("incorrect microcode checksum");
  case_7: /* CIL Label */ 
#line 241
  return ("incorrect extended signature checksum");
  case_4: /* CIL Label */ 
#line 243
  return ("too many microcodes or signatures to handle");
  case_9: /* CIL Label */ 
#line 245
  return ("callback returned failure status");
  case_0: /* CIL Label */ 
#line 247
  return ("success");
  case_1: /* CIL Label */ 
#line 249
  return ("internal error: bad parameters passed to function");
  switch_default: /* CIL Label */ 
#line 251
  return ("internal error: invalid intel_ucode_status_t status");
  switch_break: /* CIL Label */ ;
  }
}
}
#line 256 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/intel_microcode.c"
__inline static int is_valid_bcd(uint32_t const   data ) 
{ 
  int tmp ;

  {
#line 260
  if (data < 2684354560U) {
#line 260
    if ((((data + 107374182U) ^ data) & 286331152U) == 0U) {
#line 260
      tmp = 1;
    } else {
#line 260
      tmp = 0;
    }
  } else {
#line 260
    tmp = 0;
  }
#line 260
  return (tmp);
}
}
#line 284 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/intel_microcode.c"
intel_ucode_status_t intel_ucode_check_microcode(void const   * const  uc , int strict ) 
{ 
  unsigned long total_size ;
  unsigned long data_size ;
  unsigned long ext_table_size ;
  struct intel_ucode_v1_hdr  const  *uc_header ;
  uint32_t sum ;
  uint32_t orig_sum ;
  unsigned int i ;
  uint32_t *p___0 ;
  long tmp ;
  long tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  unsigned int tmp___10 ;
  long tmp___11 ;
  struct intel_ucode_v1_extsig_table  const  *ext_header ;
  struct intel_ucode_v1_extsig  const  *ext_sig ;
  uint32_t ext_sigcount ;
  uint32_t ext_table_sum ;
  long tmp___12 ;
  long tmp___13 ;
  long tmp___14 ;
  unsigned int tmp___15 ;
  long tmp___16 ;
  unsigned int tmp___17 ;
  long tmp___18 ;
  int tmp___19 ;
  long tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  long tmp___23 ;

  {
  {
#line 287
  uc_header = (struct intel_ucode_v1_hdr  const  *)uc;
#line 292
  tmp = __builtin_expect((long )(! (! (! uc))), 0L);
  }
#line 292
  if (tmp) {
#line 293
    return ((intel_ucode_status_t )1);
  }
  {
#line 295
  tmp___0 = __builtin_expect((long )(! (! (uc_header->hdrver != 1U))), 0L);
  }
#line 295
  if (tmp___0) {
#line 296
    return ((intel_ucode_status_t )3);
  }
  {
#line 300
  tmp___1 = intel_ucode_v1_get_totalsize((struct intel_ucode_v1_hdr  const  */* const  */)uc_header);
#line 300
  total_size = (unsigned long )tmp___1;
#line 301
  tmp___2 = intel_ucode_v1_get_datasize((struct intel_ucode_v1_hdr  const  */* const  */)uc_header);
#line 301
  data_size = (unsigned long )tmp___2;
  }
#line 303
  if (data_size > total_size) {
#line 303
    tmp___3 = 1;
  } else
#line 303
  if (data_size < sizeof(struct intel_ucode_v1_hdr )) {
#line 303
    tmp___3 = 1;
  } else {
#line 303
    tmp___3 = 0;
  }
  {
#line 303
  tmp___4 = __builtin_expect((long )tmp___3, 0L);
  }
#line 303
  if (tmp___4) {
#line 304
    return ((intel_ucode_status_t )2);
  }
  {
#line 305
  tmp___5 = __builtin_expect((long )(! (! (data_size + sizeof(struct intel_ucode_v1_hdr ) > total_size))),
                             0L);
  }
#line 305
  if (tmp___5) {
#line 306
    return ((intel_ucode_status_t )2);
  }
  {
#line 308
  tmp___6 = __builtin_expect((long )(! (! (data_size % sizeof(uint32_t )))), 0L);
  }
#line 308
  if (tmp___6) {
#line 309
    return ((intel_ucode_status_t )2);
  }
  {
#line 310
  tmp___7 = __builtin_expect((long )(! (! (total_size % sizeof(uint32_t )))), 0L);
  }
#line 310
  if (tmp___7) {
#line 311
    return ((intel_ucode_status_t )2);
  }
#line 312
  if (strict) {
#line 312
    if (total_size % 1024UL) {
#line 312
      tmp___8 = 1;
    } else {
#line 312
      tmp___8 = 0;
    }
  } else {
#line 312
    tmp___8 = 0;
  }
  {
#line 312
  tmp___9 = __builtin_expect((long )tmp___8, 0L);
  }
#line 312
  if (tmp___9) {
#line 313
    return ((intel_ucode_status_t )2);
  }
#line 318
  orig_sum = (uint32_t )0;
#line 319
  i = (unsigned int )((sizeof(struct intel_ucode_v1_hdr ) + data_size) / sizeof(uint32_t ));
#line 320
  p___0 = (uint32_t *)uc;
  {
#line 321
  while (1) {
    while_continue: /* CIL Label */ ;
#line 321
    tmp___10 = i;
#line 321
    i --;
#line 321
    if (! tmp___10) {
#line 321
      goto while_break;
    }
#line 322
    orig_sum += *p___0;
#line 323
    p___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 325
  tmp___11 = __builtin_expect((long )(! (! (orig_sum != 0U))), 0L);
  }
#line 325
  if (tmp___11) {
#line 326
    return ((intel_ucode_status_t )8);
  }
#line 328
  ext_table_size = total_size - (sizeof(struct intel_ucode_v1_hdr ) + data_size);
#line 329
  if (ext_table_size) {
    {
#line 337
    tmp___12 = __builtin_expect((long )(! (! (ext_table_size < sizeof(struct intel_ucode_v1_extsig_table )))),
                                0L);
    }
#line 337
    if (tmp___12) {
#line 338
      return ((intel_ucode_status_t )5);
    }
    {
#line 339
    tmp___13 = __builtin_expect((long )(! (! ((ext_table_size - sizeof(struct intel_ucode_v1_extsig_table )) % sizeof(struct intel_ucode_v1_extsig )))),
                                0L);
    }
#line 339
    if (tmp___13) {
#line 340
      return ((intel_ucode_status_t )5);
    }
    {
#line 342
    ext_header = (struct intel_ucode_v1_extsig_table  const  *)((void *)(((uint8_t *)uc + sizeof(struct intel_ucode_v1_hdr )) + data_size));
#line 343
    tmp___14 = __builtin_expect((long )(! (! (ext_table_size != (unsigned long )ext_header->count * sizeof(struct intel_ucode_v1_extsig ) + sizeof(struct intel_ucode_v1_extsig_table )))),
                                0L);
    }
#line 343
    if (tmp___14) {
#line 344
      return ((intel_ucode_status_t )5);
    }
#line 347
    ext_table_sum = (uint32_t )0;
#line 349
    i = (unsigned int )(ext_table_size / sizeof(uint32_t ));
#line 350
    p___0 = (uint32_t *)ext_header;
    {
#line 351
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 351
      tmp___15 = i;
#line 351
      i --;
#line 351
      if (! tmp___15) {
#line 351
        goto while_break___0;
      }
#line 352
      ext_table_sum += *p___0;
#line 353
      p___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 355
    tmp___16 = __builtin_expect((long )(! (! (ext_table_sum != 0U))), 0L);
    }
#line 355
    if (tmp___16) {
#line 356
      return ((intel_ucode_status_t )6);
    }
#line 358
    ext_sigcount = (uint32_t )ext_header->count;
#line 361
    ext_sig = (struct intel_ucode_v1_extsig  const  *)((void *)((uint8_t *)ext_header + sizeof(struct intel_ucode_v1_extsig_table )));
#line 362
    i = ext_sigcount;
    {
#line 363
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 363
      tmp___17 = i;
#line 363
      i --;
#line 363
      if (! tmp___17) {
#line 363
        goto while_break___1;
      }
#line 364
      sum = (orig_sum - (uint32_t )((uc_header->sig + uc_header->pf_mask) + uc_header->cksum)) + (uint32_t )((ext_sig->sig + ext_sig->pf_mask) + ext_sig->cksum);
#line 367
      if (sum) {
#line 368
        return ((intel_ucode_status_t )7);
      }
#line 369
      ext_sig ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 374
  tmp___18 = __builtin_expect((long )(! (! (! uc_header->date))), 0L);
  }
#line 374
  if (tmp___18) {
#line 375
    return ((intel_ucode_status_t )2);
  }
#line 377
  if (strict) {
#line 377
    if (! uc_header->rev) {
#line 377
      tmp___19 = 1;
    } else {
#line 377
      tmp___19 = 0;
    }
  } else {
#line 377
    tmp___19 = 0;
  }
  {
#line 377
  tmp___20 = __builtin_expect((long )tmp___19, 0L);
  }
#line 377
  if (tmp___20) {
#line 378
    return ((intel_ucode_status_t )2);
  }
#line 380
  if (strict) {
    {
#line 380
    tmp___21 = is_valid_bcd(uc_header->date);
    }
#line 380
    if (tmp___21) {
#line 380
      if ((uc_header->date & 65535U) < 6549U) {
#line 380
        tmp___22 = 1;
      } else
#line 380
      if (! ((uc_header->date >> 16) & 255U)) {
#line 380
        tmp___22 = 1;
      } else
#line 380
      if (((uc_header->date >> 16) & 255U) > 49U) {
#line 380
        tmp___22 = 1;
      } else
#line 380
      if (! ((uc_header->date >> 24) & 255U)) {
#line 380
        tmp___22 = 1;
      } else
#line 380
      if (((uc_header->date >> 24) & 255U) > 18U) {
#line 380
        tmp___22 = 1;
      } else {
#line 380
        tmp___22 = 0;
      }
    } else {
#line 380
      tmp___22 = 1;
    }
  } else {
#line 380
    tmp___22 = 0;
  }
  {
#line 380
  tmp___23 = __builtin_expect((long )tmp___22, 0L);
  }
#line 380
  if (tmp___23) {
#line 384
    return ((intel_ucode_status_t )2);
  }
#line 386
  return ((intel_ucode_status_t )0);
}
}
#line 402 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/intel_microcode.c"
intel_ucode_status_t intel_ucode_foreach_signature(void const   * const  uc , intel_ucode_sig_callback * const  action ,
                                                   void * const  userdata ) 
{ 
  struct intel_ucode_v1_hdr  const  *uc_header ;
  void const   *uc_data ;
  unsigned int total_size ;
  unsigned int data_size ;
  uint32_t ext_table_size ;
  int tmp ;
  struct intel_ucode_v1_extsig_table  const  *ext_header ;
  struct intel_ucode_v1_extsig *ext_sig ;
  uint32_t ext_sigcount ;
  uint32_t i ;
  int tmp___0 ;

  {
#line 406
  uc_header = (struct intel_ucode_v1_hdr  const  *)uc;
#line 411
  if (! action) {
#line 412
    return ((intel_ucode_status_t )1);
  } else
#line 411
  if (! uc) {
#line 412
    return ((intel_ucode_status_t )1);
  }
#line 414
  if (uc_header->hdrver != 1U) {
#line 415
    return ((intel_ucode_status_t )3);
  }
  {
#line 419
  uc_data = (void const   *)((uint8_t *)uc + sizeof(struct intel_ucode_v1_hdr ));
#line 421
  total_size = intel_ucode_v1_get_totalsize((struct intel_ucode_v1_hdr  const  */* const  */)uc_header);
#line 422
  data_size = intel_ucode_v1_get_datasize((struct intel_ucode_v1_hdr  const  */* const  */)uc_header);
#line 425
  tmp = (*action)((void *)userdata, (unsigned int const   )0, uc_header->sig, uc_header->pf_mask,
                  (void const   */* const  */)uc_data, (unsigned int const   )data_size,
                  uc, (unsigned int const   )total_size);
  }
#line 425
  if (tmp) {
#line 428
    return ((intel_ucode_status_t )9);
  }
#line 430
  ext_table_size = (uint32_t )((unsigned long )total_size - (sizeof(struct intel_ucode_v1_hdr ) + (unsigned long )data_size));
#line 431
  if (ext_table_size) {
#line 439
    ext_header = (struct intel_ucode_v1_extsig_table  const  *)((void *)(((uint8_t *)uc + sizeof(struct intel_ucode_v1_hdr )) + data_size));
#line 440
    ext_sig = (struct intel_ucode_v1_extsig *)((void *)((uint8_t *)ext_header + sizeof(struct intel_ucode_v1_extsig_table )));
#line 441
    ext_sigcount = (uint32_t )ext_header->count;
#line 442
    i = (uint32_t )1;
    {
#line 442
    while (1) {
      while_continue: /* CIL Label */ ;
#line 442
      if (! (i <= ext_sigcount)) {
#line 442
        goto while_break;
      }
      {
#line 443
      tmp___0 = (*action)((void *)userdata, (unsigned int const   )i, (uint32_t const   )ext_sig->sig,
                          (uint32_t const   )ext_sig->pf_mask, (void const   */* const  */)uc_data,
                          (unsigned int const   )data_size, uc, (unsigned int const   )total_size);
      }
#line 443
      if (tmp___0) {
#line 446
        return ((intel_ucode_status_t )9);
      }
#line 447
      ext_sig ++;
#line 442
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 451
  return ((intel_ucode_status_t )0);
}
}
#line 471 "/home/june/repo/benchmarks/collector/temp/iucode-tool-1.0.3/intel_microcode.c"
intel_ucode_status_t intel_ucode_foreach_microcode(void const   * const  uc_bundle ,
                                                   size_t const   uc_bundle_size ,
                                                   intel_ucode_uc_callback * const  action ,
                                                   void * const  userdata ) 
{ 
  uint8_t const   *uc ;
  size_t leftover ;
  unsigned int uc_count ;
  unsigned int uc_size ;
  int tmp ;

  {
#line 477
  uc = (uint8_t const   *)uc_bundle;
#line 478
  leftover = (size_t )uc_bundle_size;
#line 481
  if (! uc) {
#line 482
    return ((intel_ucode_status_t )1);
  } else
#line 481
  if (! action) {
#line 482
    return ((intel_ucode_status_t )1);
  }
#line 485
  if (uc_bundle_size < 1024UL) {
#line 486
    return ((intel_ucode_status_t )2);
  }
#line 488
  if (((struct intel_ucode_v1_hdr *)uc)->hdrver != 1U) {
#line 489
    return ((intel_ucode_status_t )3);
  }
#line 493
  uc_count = 0U;
  {
#line 494
  while (1) {
    while_continue: /* CIL Label */ ;
#line 494
    if (! leftover) {
#line 494
      goto while_break;
    }
#line 497
    if (leftover < sizeof(struct intel_ucode_v1_hdr )) {
#line 498
      return ((intel_ucode_status_t )2);
    }
#line 500
    uc_count ++;
#line 501
    if (! uc_count) {
#line 502
      return ((intel_ucode_status_t )4);
    }
    {
#line 504
    uc_size = intel_ucode_v1_get_totalsize((struct intel_ucode_v1_hdr  const  */* const  */)((struct intel_ucode_v1_hdr *)uc));
    }
#line 505
    if ((unsigned long )uc_size % sizeof(uint32_t )) {
#line 506
      return ((intel_ucode_status_t )2);
    } else
#line 505
    if ((size_t )uc_size > leftover) {
#line 506
      return ((intel_ucode_status_t )2);
    }
    {
#line 508
    tmp = (*action)((void *)userdata, (unsigned int const   )uc_count, (void const   */* const  */)uc);
    }
#line 508
    if (tmp) {
#line 509
      return ((intel_ucode_status_t )9);
    }
#line 511
    uc += uc_size;
#line 512
    leftover -= (size_t )uc_size;
  }
  while_break: /* CIL Label */ ;
  }
#line 515
  return ((intel_ucode_status_t )0);
}
}
