/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 40 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/lzx.h"
struct LZXstate;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 42 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/lzx.c"
typedef unsigned char UBYTE;
#line 43 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/lzx.c"
typedef unsigned short UWORD;
#line 44 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/lzx.c"
typedef unsigned int ULONG;
#line 45 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/lzx.c"
typedef int LONG;
#line 76 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/lzx.c"
struct LZXstate {
   UBYTE *window ;
   ULONG window_size ;
   ULONG actual_size ;
   ULONG window_posn ;
   ULONG R0 ;
   ULONG R1 ;
   ULONG R2 ;
   UWORD main_elements ;
   int header_read ;
   UWORD block_type ;
   ULONG block_length ;
   ULONG block_remaining ;
   ULONG frames_read ;
   LONG intel_filesize ;
   LONG intel_curpos ;
   int intel_started ;
   UWORD PRETREE_table[(1 << 6) + (20 << 1)] ;
   UBYTE PRETREE_len[84] ;
   UWORD MAINTREE_table[(1 << 12) + (656 << 1)] ;
   UBYTE MAINTREE_len[720] ;
   UWORD LENGTH_table[(1 << 12) + (250 << 1)] ;
   UBYTE LENGTH_len[314] ;
   UWORD ALIGNED_table[(1 << 7) + (8 << 1)] ;
   UBYTE ALIGNED_len[72] ;
};
#line 418 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/lzx.c"
struct lzx_bits {
   ULONG bb ;
   int bl ;
   UBYTE *ip ;
};
#line 61 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/chm_lib.h"
typedef unsigned long long LONGUINT64;
#line 62 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/chm_lib.h"
typedef long long LONGINT64;
#line 72
struct chmFile;
#line 76 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/chm_lib.h"
struct chmUnitInfo {
   LONGUINT64 start ;
   LONGUINT64 length ;
   int space ;
   int flags ;
   char path[513] ;
};
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutex_t_11 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutex_t_11 pthread_mutex_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutexattr_t_12 {
   char __size[4] ;
   int __align ;
};
#line 129 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutexattr_t_12 pthread_mutexattr_t;
#line 156 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/chm_lib.c"
typedef unsigned char UChar;
#line 159 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/chm_lib.c"
typedef int Int32;
#line 160 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/chm_lib.c"
typedef unsigned int UInt32;
#line 161 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/chm_lib.c"
typedef long Int64;
#line 162 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/chm_lib.c"
typedef unsigned long UInt64;
#line 344 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/chm_lib.c"
struct chmItsfHeader {
   char signature[4] ;
   Int32 version ;
   Int32 header_len ;
   Int32 unknown_000c ;
   UInt32 last_modified ;
   UInt32 lang_id ;
   UChar dir_uuid[16] ;
   UChar stream_uuid[16] ;
   UInt64 unknown_offset ;
   UInt64 unknown_len ;
   UInt64 dir_offset ;
   UInt64 dir_len ;
   UInt64 data_offset ;
};
#line 420 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/chm_lib.c"
struct chmItspHeader {
   char signature[4] ;
   Int32 version ;
   Int32 header_len ;
   Int32 unknown_000c ;
   UInt32 block_len ;
   Int32 blockidx_intvl ;
   Int32 index_depth ;
   Int32 index_root ;
   Int32 index_head ;
   Int32 unknown_0024 ;
   UInt32 num_blocks ;
   Int32 unknown_002c ;
   UInt32 lang_id ;
   UChar system_uuid[16] ;
   UChar unknown_0044[16] ;
};
#line 478 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/chm_lib.c"
struct chmPmglHeader {
   char signature[4] ;
   UInt32 free_space ;
   UInt32 unknown_0008 ;
   Int32 block_prev ;
   Int32 block_next ;
};
#line 512 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/chm_lib.c"
struct chmPmgiHeader {
   char signature[4] ;
   UInt32 free_space ;
};
#line 539 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/chm_lib.c"
struct chmLzxcResetTable {
   UInt32 version ;
   UInt32 block_count ;
   UInt32 unknown ;
   UInt32 table_offset ;
   UInt64 uncompressed_len ;
   UInt64 compressed_len ;
   UInt64 block_len ;
};
#line 577 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/chm_lib.c"
struct chmLzxcControlData {
   UInt32 size ;
   char signature[4] ;
   UInt32 version ;
   UInt32 resetInterval ;
   UInt32 windowSize ;
   UInt32 windowsPerReset ;
   UInt32 unknown_18 ;
};
#line 631 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/chm_lib.c"
struct chmFile {
   int fd ;
   pthread_mutex_t mutex ;
   pthread_mutex_t lzx_mutex ;
   pthread_mutex_t cache_mutex ;
   UInt64 dir_offset ;
   UInt64 dir_len ;
   UInt64 data_offset ;
   Int32 index_root ;
   Int32 index_head ;
   UInt32 block_len ;
   UInt64 span ;
   struct chmUnitInfo rt_unit ;
   struct chmUnitInfo cn_unit ;
   struct chmLzxcResetTable reset_table ;
   int compression_enabled ;
   UInt32 window_size ;
   UInt32 reset_interval ;
   UInt32 reset_blkcount ;
   struct LZXstate *lzx_state ;
   int lzx_last_block ;
   UChar **cache_blocks ;
   UInt64 *cache_block_indices ;
   Int32 cache_num_blocks ;
};
/* compiler builtin: 
   void *__builtin_memcpy(void * , void const   * , unsigned long  ) ;  */
#line 43 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/lzx.h"
struct LZXstate *LZXinit(int window ) ;
#line 46
void LZXteardown(struct LZXstate *pState ) ;
#line 49
int LZXreset(struct LZXstate *pState ) ;
#line 52
int LZXdecompress(struct LZXstate *pState , unsigned char *inpos , unsigned char *outpos ,
                  int inlen , int outlen ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 154 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/lzx.c"
static UBYTE const   extra_bits[51]  = 
#line 154 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/lzx.c"
  {      (UBYTE const   )0,      (UBYTE const   )0,      (UBYTE const   )0,      (UBYTE const   )0, 
        (UBYTE const   )1,      (UBYTE const   )1,      (UBYTE const   )2,      (UBYTE const   )2, 
        (UBYTE const   )3,      (UBYTE const   )3,      (UBYTE const   )4,      (UBYTE const   )4, 
        (UBYTE const   )5,      (UBYTE const   )5,      (UBYTE const   )6,      (UBYTE const   )6, 
        (UBYTE const   )7,      (UBYTE const   )7,      (UBYTE const   )8,      (UBYTE const   )8, 
        (UBYTE const   )9,      (UBYTE const   )9,      (UBYTE const   )10,      (UBYTE const   )10, 
        (UBYTE const   )11,      (UBYTE const   )11,      (UBYTE const   )12,      (UBYTE const   )12, 
        (UBYTE const   )13,      (UBYTE const   )13,      (UBYTE const   )14,      (UBYTE const   )14, 
        (UBYTE const   )15,      (UBYTE const   )15,      (UBYTE const   )16,      (UBYTE const   )16, 
        (UBYTE const   )17,      (UBYTE const   )17,      (UBYTE const   )17,      (UBYTE const   )17, 
        (UBYTE const   )17,      (UBYTE const   )17,      (UBYTE const   )17,      (UBYTE const   )17, 
        (UBYTE const   )17,      (UBYTE const   )17,      (UBYTE const   )17,      (UBYTE const   )17, 
        (UBYTE const   )17,      (UBYTE const   )17,      (UBYTE const   )17};
#line 161 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/lzx.c"
static ULONG const   position_base[51]  = 
#line 161
  {      (ULONG const   )0,      (ULONG const   )1,      (ULONG const   )2,      (ULONG const   )3, 
        (ULONG const   )4,      (ULONG const   )6,      (ULONG const   )8,      (ULONG const   )12, 
        (ULONG const   )16,      (ULONG const   )24,      (ULONG const   )32,      (ULONG const   )48, 
        (ULONG const   )64,      (ULONG const   )96,      (ULONG const   )128,      (ULONG const   )192, 
        (ULONG const   )256,      (ULONG const   )384,      (ULONG const   )512,      (ULONG const   )768, 
        (ULONG const   )1024,      (ULONG const   )1536,      (ULONG const   )2048,      (ULONG const   )3072, 
        (ULONG const   )4096,      (ULONG const   )6144,      (ULONG const   )8192,      (ULONG const   )12288, 
        (ULONG const   )16384,      (ULONG const   )24576,      (ULONG const   )32768,      (ULONG const   )49152, 
        (ULONG const   )65536,      (ULONG const   )98304,      (ULONG const   )131072,      (ULONG const   )196608, 
        (ULONG const   )262144,      (ULONG const   )393216,      (ULONG const   )524288,      (ULONG const   )655360, 
        (ULONG const   )786432,      (ULONG const   )917504,      (ULONG const   )1048576,      (ULONG const   )1179648, 
        (ULONG const   )1310720,      (ULONG const   )1441792,      (ULONG const   )1572864,      (ULONG const   )1703936, 
        (ULONG const   )1835008,      (ULONG const   )1966080,      (ULONG const   )2097152};
#line 168 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/lzx.c"
struct LZXstate *LZXinit(int window ) 
{ 
  struct LZXstate *pState ;
  ULONG wndsize ;
  int i ;
  int posn_slots ;
  void *tmp ;
  UBYTE *tmp___0 ;
  void *tmp___1 ;
  ULONG tmp___2 ;
  ULONG tmp___3 ;

  {
#line 170
  pState = (struct LZXstate *)((void *)0);
#line 171
  wndsize = (ULONG )(1 << window);
#line 176
  if (window < 15) {
#line 176
    return ((struct LZXstate *)((void *)0));
  } else
#line 176
  if (window > 21) {
#line 176
    return ((struct LZXstate *)((void *)0));
  }
  {
#line 179
  tmp = malloc(sizeof(struct LZXstate ));
#line 179
  pState = (struct LZXstate *)tmp;
#line 180
  tmp___1 = malloc((size_t )wndsize);
#line 180
  tmp___0 = (UBYTE *)tmp___1;
#line 180
  pState->window = tmp___0;
  }
#line 180
  if (! tmp___0) {
    {
#line 182
    free((void *)pState);
    }
#line 183
    return ((struct LZXstate *)((void *)0));
  }
#line 185
  pState->actual_size = wndsize;
#line 186
  pState->window_size = wndsize;
#line 189
  if (window == 20) {
#line 189
    posn_slots = 42;
  } else
#line 190
  if (window == 21) {
#line 190
    posn_slots = 50;
  } else {
#line 191
    posn_slots = window << 1;
  }
#line 197
  tmp___3 = (ULONG )1;
#line 197
  pState->R2 = tmp___3;
#line 197
  tmp___2 = tmp___3;
#line 197
  pState->R1 = tmp___2;
#line 197
  pState->R0 = tmp___2;
#line 198
  pState->main_elements = (UWORD )(256 + (posn_slots << 3));
#line 199
  pState->header_read = 0;
#line 200
  pState->frames_read = (ULONG )0;
#line 201
  pState->block_remaining = (ULONG )0;
#line 202
  pState->block_type = (UWORD )0;
#line 203
  pState->intel_curpos = 0;
#line 204
  pState->intel_started = 0;
#line 205
  pState->window_posn = (ULONG )0;
#line 208
  i = 0;
  {
#line 208
  while (1) {
    while_continue: /* CIL Label */ ;
#line 208
    if (! (i < 656)) {
#line 208
      goto while_break;
    }
#line 208
    pState->MAINTREE_len[i] = (UBYTE )0;
#line 208
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 209
  i = 0;
  {
#line 209
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 209
    if (! (i < 250)) {
#line 209
      goto while_break___0;
    }
#line 209
    pState->LENGTH_len[i] = (UBYTE )0;
#line 209
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 211
  return (pState);
}
}
#line 214 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/lzx.c"
void LZXteardown(struct LZXstate *pState ) 
{ 


  {
#line 216
  if (pState) {
#line 218
    if (pState->window) {
      {
#line 219
      free((void *)pState->window);
      }
    }
    {
#line 220
    free((void *)pState);
    }
  }
#line 222
  return;
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/lzx.c"
int LZXreset(struct LZXstate *pState ) 
{ 
  int i ;
  ULONG tmp ;
  ULONG tmp___0 ;

  {
#line 228
  tmp___0 = (ULONG )1;
#line 228
  pState->R2 = tmp___0;
#line 228
  tmp = tmp___0;
#line 228
  pState->R1 = tmp;
#line 228
  pState->R0 = tmp;
#line 229
  pState->header_read = 0;
#line 230
  pState->frames_read = (ULONG )0;
#line 231
  pState->block_remaining = (ULONG )0;
#line 232
  pState->block_type = (UWORD )0;
#line 233
  pState->intel_curpos = 0;
#line 234
  pState->intel_started = 0;
#line 235
  pState->window_posn = (ULONG )0;
#line 237
  i = 0;
  {
#line 237
  while (1) {
    while_continue: /* CIL Label */ ;
#line 237
    if (! (i < 720)) {
#line 237
      goto while_break;
    }
#line 237
    pState->MAINTREE_len[i] = (UBYTE )0;
#line 237
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 238
  i = 0;
  {
#line 238
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 238
    if (! (i < 314)) {
#line 238
      goto while_break___0;
    }
#line 238
    pState->LENGTH_len[i] = (UBYTE )0;
#line 238
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 240
  return (0);
}
}
#line 348 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/lzx.c"
static int make_decode_table(ULONG nsyms , ULONG nbits , UBYTE *length , UWORD *table ) 
{ 
  register UWORD sym ;
  register ULONG leaf ;
  register UBYTE bit_num ;
  ULONG fill ;
  ULONG pos ;
  ULONG table_mask ;
  ULONG bit_mask ;
  ULONG next_symbol ;
  ULONG tmp ;
  ULONG tmp___0 ;
  ULONG tmp___1 ;

  {
#line 351
  bit_num = (UBYTE )1;
#line 353
  pos = (ULONG )0;
#line 354
  table_mask = (ULONG )(1 << nbits);
#line 355
  bit_mask = table_mask >> 1;
#line 356
  next_symbol = bit_mask;
  {
#line 359
  while (1) {
    while_continue: /* CIL Label */ ;
#line 359
    if (! ((ULONG )bit_num <= nbits)) {
#line 359
      goto while_break;
    }
#line 360
    sym = (UWORD )0;
    {
#line 360
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 360
      if (! ((ULONG )sym < nsyms)) {
#line 360
        goto while_break___0;
      }
#line 361
      if ((int )*(length + sym) == (int )bit_num) {
#line 362
        leaf = pos;
#line 364
        pos += bit_mask;
#line 364
        if (pos > table_mask) {
#line 364
          return (1);
        }
#line 367
        fill = bit_mask;
        {
#line 368
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 368
          tmp___0 = fill;
#line 368
          fill --;
#line 368
          if (! (tmp___0 > 0U)) {
#line 368
            goto while_break___1;
          }
#line 368
          tmp = leaf;
#line 368
          leaf ++;
#line 368
          *(table + tmp) = sym;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 360
      sym = (UWORD )((int )sym + 1);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 371
    bit_mask >>= 1;
#line 372
    bit_num = (UBYTE )((int )bit_num + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 376
  if (pos != table_mask) {
#line 378
    sym = (UWORD )pos;
    {
#line 378
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 378
      if (! ((ULONG )sym < table_mask)) {
#line 378
        goto while_break___2;
      }
#line 378
      *(table + sym) = (UWORD )0;
#line 378
      sym = (UWORD )((int )sym + 1);
    }
    while_break___2: /* CIL Label */ ;
    }
#line 381
    pos <<= 16;
#line 382
    table_mask <<= 16;
#line 383
    bit_mask = (ULONG )(1 << 15);
    {
#line 385
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 385
      if (! ((int )bit_num <= 16)) {
#line 385
        goto while_break___3;
      }
#line 386
      sym = (UWORD )0;
      {
#line 386
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 386
        if (! ((ULONG )sym < nsyms)) {
#line 386
          goto while_break___4;
        }
#line 387
        if ((int )*(length + sym) == (int )bit_num) {
#line 388
          leaf = pos >> 16;
#line 389
          fill = (ULONG )0;
          {
#line 389
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 389
            if (! (fill < (ULONG )bit_num - nbits)) {
#line 389
              goto while_break___5;
            }
#line 391
            if ((int )*(table + leaf) == 0) {
#line 392
              *(table + (next_symbol << 1)) = (UWORD )0;
#line 393
              *(table + ((next_symbol << 1) + 1U)) = (UWORD )0;
#line 394
              tmp___1 = next_symbol;
#line 394
              next_symbol ++;
#line 394
              *(table + leaf) = (UWORD )tmp___1;
            }
#line 397
            leaf = (ULONG )((int )*(table + leaf) << 1);
#line 398
            if ((pos >> (15U - fill)) & 1U) {
#line 398
              leaf ++;
            }
#line 389
            fill ++;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 400
          *(table + leaf) = sym;
#line 402
          pos += bit_mask;
#line 402
          if (pos > table_mask) {
#line 402
            return (1);
          }
        }
#line 386
        sym = (UWORD )((int )sym + 1);
      }
      while_break___4: /* CIL Label */ ;
      }
#line 405
      bit_mask >>= 1;
#line 406
      bit_num = (UBYTE )((int )bit_num + 1);
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 411
  if (pos == table_mask) {
#line 411
    return (0);
  }
#line 414
  sym = (UWORD )0;
  {
#line 414
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 414
    if (! ((ULONG )sym < nsyms)) {
#line 414
      goto while_break___6;
    }
#line 414
    if (*(length + sym)) {
#line 414
      return (1);
    }
#line 414
    sym = (UWORD )((int )sym + 1);
  }
  while_break___6: /* CIL Label */ ;
  }
#line 415
  return (0);
}
}
#line 424 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/lzx.c"
static int lzx_read_lens(struct LZXstate *pState , UBYTE *lens , ULONG first , ULONG last ,
                         struct lzx_bits *lb ) 
{ 
  ULONG i ;
  ULONG j ;
  ULONG x ;
  ULONG y ;
  int z ;
  register ULONG bitbuf ;
  register int bitsleft ;
  UBYTE *inpos ;
  UWORD *hufftbl ;
  int tmp ;
  int tmp___0 ;
  ULONG tmp___1 ;
  ULONG tmp___2 ;
  ULONG tmp___3 ;
  ULONG tmp___4 ;
  int tmp___5 ;
  ULONG tmp___6 ;
  ULONG tmp___7 ;
  ULONG tmp___8 ;

  {
#line 428
  bitbuf = lb->bb;
#line 429
  bitsleft = lb->bl;
#line 430
  inpos = lb->ip;
#line 433
  x = (ULONG )0;
  {
#line 433
  while (1) {
    while_continue: /* CIL Label */ ;
#line 433
    if (! (x < 20U)) {
#line 433
      goto while_break;
    }
    {
#line 434
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 434
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 434
        if (! (bitsleft < 4)) {
#line 434
          goto while_break___1;
        }
#line 434
        bitbuf |= (unsigned int )((((int )*(inpos + 1) << 8) | (int )*(inpos + 0)) << (((sizeof(ULONG ) << 3) - 16UL) - (unsigned long )bitsleft));
#line 434
        bitsleft += 16;
#line 434
        inpos += 2;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 434
      y = bitbuf >> ((sizeof(ULONG ) << 3) - 4UL);
#line 434
      bitbuf <<= 4;
#line 434
      bitsleft -= 4;
#line 434
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 435
    pState->PRETREE_len[x] = (UBYTE )y;
#line 433
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 437
  tmp = make_decode_table((ULONG )20, (ULONG )6, pState->PRETREE_len, pState->PRETREE_table);
  }
#line 437
  if (tmp) {
#line 437
    return (2);
  }
#line 439
  x = first;
  {
#line 439
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 439
    if (! (x < last)) {
#line 439
      goto while_break___2;
    }
    {
#line 440
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 440
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 440
        if (! (bitsleft < 16)) {
#line 440
          goto while_break___4;
        }
#line 440
        bitbuf |= (unsigned int )((((int )*(inpos + 1) << 8) | (int )*(inpos + 0)) << (((sizeof(ULONG ) << 3) - 16UL) - (unsigned long )bitsleft));
#line 440
        bitsleft += 16;
#line 440
        inpos += 2;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 440
      hufftbl = pState->PRETREE_table;
#line 440
      i = (ULONG )*(hufftbl + (bitbuf >> ((sizeof(ULONG ) << 3) - 6UL)));
#line 440
      if (i >= 20U) {
#line 440
        j = (ULONG )(1 << ((sizeof(ULONG ) << 3) - 6UL));
        {
#line 440
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 440
          j >>= 1;
#line 440
          i <<= 1;
#line 440
          if (bitbuf & j) {
#line 440
            tmp___0 = 1;
          } else {
#line 440
            tmp___0 = 0;
          }
#line 440
          i |= (unsigned int )tmp___0;
#line 440
          if (! j) {
#line 440
            return (2);
          }
#line 440
          i = (ULONG )*(hufftbl + i);
#line 440
          if (! (i >= 20U)) {
#line 440
            goto while_break___5;
          }
        }
        while_break___5: /* CIL Label */ ;
        }
      }
#line 440
      z = (int )i;
#line 440
      j = (ULONG )pState->PRETREE_len[z];
#line 440
      bitbuf <<= j;
#line 440
      bitsleft = (int )((ULONG )bitsleft - j);
#line 440
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 441
    if (z == 17) {
      {
#line 442
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 442
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 442
          if (! (bitsleft < 4)) {
#line 442
            goto while_break___7;
          }
#line 442
          bitbuf |= (unsigned int )((((int )*(inpos + 1) << 8) | (int )*(inpos + 0)) << (((sizeof(ULONG ) << 3) - 16UL) - (unsigned long )bitsleft));
#line 442
          bitsleft += 16;
#line 442
          inpos += 2;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 442
        y = bitbuf >> ((sizeof(ULONG ) << 3) - 4UL);
#line 442
        bitbuf <<= 4;
#line 442
        bitsleft -= 4;
#line 442
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 442
      y += 4U;
      {
#line 443
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 443
        tmp___2 = y;
#line 443
        y --;
#line 443
        if (! tmp___2) {
#line 443
          goto while_break___8;
        }
#line 443
        tmp___1 = x;
#line 443
        x ++;
#line 443
        *(lens + tmp___1) = (UBYTE )0;
      }
      while_break___8: /* CIL Label */ ;
      }
    } else
#line 445
    if (z == 18) {
      {
#line 446
      while (1) {
        while_continue___9: /* CIL Label */ ;
        {
#line 446
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 446
          if (! (bitsleft < 5)) {
#line 446
            goto while_break___10;
          }
#line 446
          bitbuf |= (unsigned int )((((int )*(inpos + 1) << 8) | (int )*(inpos + 0)) << (((sizeof(ULONG ) << 3) - 16UL) - (unsigned long )bitsleft));
#line 446
          bitsleft += 16;
#line 446
          inpos += 2;
        }
        while_break___10: /* CIL Label */ ;
        }
#line 446
        y = bitbuf >> ((sizeof(ULONG ) << 3) - 5UL);
#line 446
        bitbuf <<= 5;
#line 446
        bitsleft -= 5;
#line 446
        goto while_break___9;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 446
      y += 20U;
      {
#line 447
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 447
        tmp___4 = y;
#line 447
        y --;
#line 447
        if (! tmp___4) {
#line 447
          goto while_break___11;
        }
#line 447
        tmp___3 = x;
#line 447
        x ++;
#line 447
        *(lens + tmp___3) = (UBYTE )0;
      }
      while_break___11: /* CIL Label */ ;
      }
    } else
#line 449
    if (z == 19) {
      {
#line 450
      while (1) {
        while_continue___12: /* CIL Label */ ;
        {
#line 450
        while (1) {
          while_continue___13: /* CIL Label */ ;
#line 450
          if (! (bitsleft < 1)) {
#line 450
            goto while_break___13;
          }
#line 450
          bitbuf |= (unsigned int )((((int )*(inpos + 1) << 8) | (int )*(inpos + 0)) << (((sizeof(ULONG ) << 3) - 16UL) - (unsigned long )bitsleft));
#line 450
          bitsleft += 16;
#line 450
          inpos += 2;
        }
        while_break___13: /* CIL Label */ ;
        }
#line 450
        y = bitbuf >> ((sizeof(ULONG ) << 3) - 1UL);
#line 450
        bitbuf <<= 1;
#line 450
        bitsleft --;
#line 450
        goto while_break___12;
      }
      while_break___12: /* CIL Label */ ;
      }
#line 450
      y += 4U;
      {
#line 451
      while (1) {
        while_continue___14: /* CIL Label */ ;
        {
#line 451
        while (1) {
          while_continue___15: /* CIL Label */ ;
#line 451
          if (! (bitsleft < 16)) {
#line 451
            goto while_break___15;
          }
#line 451
          bitbuf |= (unsigned int )((((int )*(inpos + 1) << 8) | (int )*(inpos + 0)) << (((sizeof(ULONG ) << 3) - 16UL) - (unsigned long )bitsleft));
#line 451
          bitsleft += 16;
#line 451
          inpos += 2;
        }
        while_break___15: /* CIL Label */ ;
        }
#line 451
        hufftbl = pState->PRETREE_table;
#line 451
        i = (ULONG )*(hufftbl + (bitbuf >> ((sizeof(ULONG ) << 3) - 6UL)));
#line 451
        if (i >= 20U) {
#line 451
          j = (ULONG )(1 << ((sizeof(ULONG ) << 3) - 6UL));
          {
#line 451
          while (1) {
            while_continue___16: /* CIL Label */ ;
#line 451
            j >>= 1;
#line 451
            i <<= 1;
#line 451
            if (bitbuf & j) {
#line 451
              tmp___5 = 1;
            } else {
#line 451
              tmp___5 = 0;
            }
#line 451
            i |= (unsigned int )tmp___5;
#line 451
            if (! j) {
#line 451
              return (2);
            }
#line 451
            i = (ULONG )*(hufftbl + i);
#line 451
            if (! (i >= 20U)) {
#line 451
              goto while_break___16;
            }
          }
          while_break___16: /* CIL Label */ ;
          }
        }
#line 451
        z = (int )i;
#line 451
        j = (ULONG )pState->PRETREE_len[z];
#line 451
        bitbuf <<= j;
#line 451
        bitsleft = (int )((ULONG )bitsleft - j);
#line 451
        goto while_break___14;
      }
      while_break___14: /* CIL Label */ ;
      }
#line 452
      z = (int )*(lens + x) - z;
#line 452
      if (z < 0) {
#line 452
        z += 17;
      }
      {
#line 453
      while (1) {
        while_continue___17: /* CIL Label */ ;
#line 453
        tmp___7 = y;
#line 453
        y --;
#line 453
        if (! tmp___7) {
#line 453
          goto while_break___17;
        }
#line 453
        tmp___6 = x;
#line 453
        x ++;
#line 453
        *(lens + tmp___6) = (UBYTE )z;
      }
      while_break___17: /* CIL Label */ ;
      }
    } else {
#line 456
      z = (int )*(lens + x) - z;
#line 456
      if (z < 0) {
#line 456
        z += 17;
      }
#line 457
      tmp___8 = x;
#line 457
      x ++;
#line 457
      *(lens + tmp___8) = (UBYTE )z;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 461
  lb->bb = bitbuf;
#line 462
  lb->bl = bitsleft;
#line 463
  lb->ip = inpos;
#line 464
  return (0);
}
}
#line 467 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/lzx.c"
int LZXdecompress(struct LZXstate *pState , unsigned char *inpos , unsigned char *outpos ,
                  int inlen , int outlen ) 
{ 
  UBYTE *endinp ;
  UBYTE *window ;
  UBYTE *runsrc ;
  UBYTE *rundest ;
  UWORD *hufftbl ;
  ULONG window_posn ;
  ULONG window_size ;
  ULONG R0 ;
  ULONG R1 ;
  ULONG R2 ;
  register ULONG bitbuf ;
  register int bitsleft ;
  ULONG match_offset ;
  ULONG i ;
  ULONG j ;
  ULONG k ;
  struct lzx_bits lb ;
  int togo ;
  int this_run ;
  int main_element ;
  int aligned_bits ;
  int match_length ;
  int length_footer ;
  int extra ;
  int verbatim_bits ;
  ULONG tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  ULONG tmp___7 ;
  int tmp___8 ;
  UBYTE *tmp___9 ;
  int tmp___10 ;
  UBYTE *tmp___11 ;
  UBYTE *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  ULONG tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  UBYTE *tmp___19 ;
  int tmp___20 ;
  UBYTE *tmp___21 ;
  UBYTE *tmp___22 ;
  int tmp___23 ;
  ULONG tmp___24 ;
  UBYTE *data ;
  UBYTE *dataend ;
  LONG curpos ;
  LONG filesize ;
  LONG abs_off ;
  LONG rel_off ;
  UBYTE *tmp___25 ;
  ULONG tmp___26 ;

  {
#line 468
  endinp = inpos + inlen;
#line 469
  window = pState->window;
#line 473
  window_posn = pState->window_posn;
#line 474
  window_size = pState->window_size;
#line 475
  R0 = pState->R0;
#line 476
  R1 = pState->R1;
#line 477
  R2 = pState->R2;
#line 484
  togo = outlen;
  {
#line 487
  while (1) {
    while_continue: /* CIL Label */ ;
#line 487
    bitsleft = 0;
#line 487
    bitbuf = (ULONG )0;
#line 487
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 490
  if (! pState->header_read) {
#line 491
    j = (ULONG )0;
#line 491
    i = j;
    {
#line 492
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 492
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 492
        if (! (bitsleft < 1)) {
#line 492
          goto while_break___1;
        }
#line 492
        bitbuf |= (unsigned int )((((int )*(inpos + 1) << 8) | (int )*(inpos + 0)) << (((sizeof(ULONG ) << 3) - 16UL) - (unsigned long )bitsleft));
#line 492
        bitsleft += 16;
#line 492
        inpos += 2;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 492
      k = bitbuf >> ((sizeof(ULONG ) << 3) - 1UL);
#line 492
      bitbuf <<= 1;
#line 492
      bitsleft --;
#line 492
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 492
    if (k) {
      {
#line 492
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 492
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 492
          if (! (bitsleft < 16)) {
#line 492
            goto while_break___3;
          }
#line 492
          bitbuf |= (unsigned int )((((int )*(inpos + 1) << 8) | (int )*(inpos + 0)) << (((sizeof(ULONG ) << 3) - 16UL) - (unsigned long )bitsleft));
#line 492
          bitsleft += 16;
#line 492
          inpos += 2;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 492
        i = bitbuf >> ((sizeof(ULONG ) << 3) - 16UL);
#line 492
        bitbuf <<= 16;
#line 492
        bitsleft -= 16;
#line 492
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 492
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 492
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 492
          if (! (bitsleft < 16)) {
#line 492
            goto while_break___5;
          }
#line 492
          bitbuf |= (unsigned int )((((int )*(inpos + 1) << 8) | (int )*(inpos + 0)) << (((sizeof(ULONG ) << 3) - 16UL) - (unsigned long )bitsleft));
#line 492
          bitsleft += 16;
#line 492
          inpos += 2;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 492
        j = bitbuf >> ((sizeof(ULONG ) << 3) - 16UL);
#line 492
        bitbuf <<= 16;
#line 492
        bitsleft -= 16;
#line 492
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
#line 493
    pState->intel_filesize = (LONG )((i << 16) | j);
#line 494
    pState->header_read = 1;
  }
  {
#line 498
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 498
    if (! (togo > 0)) {
#line 498
      goto while_break___6;
    }
#line 500
    if (pState->block_remaining == 0U) {
#line 501
      if ((int )pState->block_type == 3) {
#line 502
        if (pState->block_length & 1U) {
#line 502
          inpos ++;
        }
        {
#line 503
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 503
          bitsleft = 0;
#line 503
          bitbuf = (ULONG )0;
#line 503
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
      }
      {
#line 506
      while (1) {
        while_continue___8: /* CIL Label */ ;
        {
#line 506
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 506
          if (! (bitsleft < 3)) {
#line 506
            goto while_break___9;
          }
#line 506
          bitbuf |= (unsigned int )((((int )*(inpos + 1) << 8) | (int )*(inpos + 0)) << (((sizeof(ULONG ) << 3) - 16UL) - (unsigned long )bitsleft));
#line 506
          bitsleft += 16;
#line 506
          inpos += 2;
        }
        while_break___9: /* CIL Label */ ;
        }
#line 506
        pState->block_type = (UWORD )(bitbuf >> ((sizeof(ULONG ) << 3) - 3UL));
#line 506
        bitbuf <<= 3;
#line 506
        bitsleft -= 3;
#line 506
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
      {
#line 507
      while (1) {
        while_continue___10: /* CIL Label */ ;
        {
#line 507
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 507
          if (! (bitsleft < 16)) {
#line 507
            goto while_break___11;
          }
#line 507
          bitbuf |= (unsigned int )((((int )*(inpos + 1) << 8) | (int )*(inpos + 0)) << (((sizeof(ULONG ) << 3) - 16UL) - (unsigned long )bitsleft));
#line 507
          bitsleft += 16;
#line 507
          inpos += 2;
        }
        while_break___11: /* CIL Label */ ;
        }
#line 507
        i = bitbuf >> ((sizeof(ULONG ) << 3) - 16UL);
#line 507
        bitbuf <<= 16;
#line 507
        bitsleft -= 16;
#line 507
        goto while_break___10;
      }
      while_break___10: /* CIL Label */ ;
      }
      {
#line 508
      while (1) {
        while_continue___12: /* CIL Label */ ;
        {
#line 508
        while (1) {
          while_continue___13: /* CIL Label */ ;
#line 508
          if (! (bitsleft < 8)) {
#line 508
            goto while_break___13;
          }
#line 508
          bitbuf |= (unsigned int )((((int )*(inpos + 1) << 8) | (int )*(inpos + 0)) << (((sizeof(ULONG ) << 3) - 16UL) - (unsigned long )bitsleft));
#line 508
          bitsleft += 16;
#line 508
          inpos += 2;
        }
        while_break___13: /* CIL Label */ ;
        }
#line 508
        j = bitbuf >> ((sizeof(ULONG ) << 3) - 8UL);
#line 508
        bitbuf <<= 8;
#line 508
        bitsleft -= 8;
#line 508
        goto while_break___12;
      }
      while_break___12: /* CIL Label */ ;
      }
#line 509
      tmp = (i << 8) | j;
#line 509
      pState->block_length = tmp;
#line 509
      pState->block_remaining = tmp;
      {
#line 512
      if ((int )pState->block_type == 2) {
#line 512
        goto case_2;
      }
#line 517
      if ((int )pState->block_type == 1) {
#line 517
        goto case_1;
      }
#line 527
      if ((int )pState->block_type == 3) {
#line 527
        goto case_3;
      }
#line 536
      goto switch_default;
      case_2: /* CIL Label */ 
#line 513
      i = (ULONG )0;
      {
#line 513
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 513
        if (! (i < 8U)) {
#line 513
          goto while_break___14;
        }
        {
#line 513
        while (1) {
          while_continue___15: /* CIL Label */ ;
          {
#line 513
          while (1) {
            while_continue___16: /* CIL Label */ ;
#line 513
            if (! (bitsleft < 3)) {
#line 513
              goto while_break___16;
            }
#line 513
            bitbuf |= (unsigned int )((((int )*(inpos + 1) << 8) | (int )*(inpos + 0)) << (((sizeof(ULONG ) << 3) - 16UL) - (unsigned long )bitsleft));
#line 513
            bitsleft += 16;
#line 513
            inpos += 2;
          }
          while_break___16: /* CIL Label */ ;
          }
#line 513
          j = bitbuf >> ((sizeof(ULONG ) << 3) - 3UL);
#line 513
          bitbuf <<= 3;
#line 513
          bitsleft -= 3;
#line 513
          goto while_break___15;
        }
        while_break___15: /* CIL Label */ ;
        }
#line 513
        pState->ALIGNED_len[i] = (UBYTE )j;
#line 513
        i ++;
      }
      while_break___14: /* CIL Label */ ;
      }
      {
#line 514
      tmp___0 = make_decode_table((ULONG )8, (ULONG )7, pState->ALIGNED_len, pState->ALIGNED_table);
      }
#line 514
      if (tmp___0) {
#line 514
        return (2);
      }
      case_1: /* CIL Label */ 
      {
#line 518
      while (1) {
        while_continue___17: /* CIL Label */ ;
        {
#line 518
        lb.bb = bitbuf;
#line 518
        lb.bl = bitsleft;
#line 518
        lb.ip = inpos;
#line 518
        tmp___1 = lzx_read_lens(pState, pState->MAINTREE_len, (ULONG )0, (ULONG )256,
                                & lb);
        }
#line 518
        if (tmp___1) {
#line 518
          return (2);
        }
#line 518
        bitbuf = lb.bb;
#line 518
        bitsleft = lb.bl;
#line 518
        inpos = lb.ip;
#line 518
        goto while_break___17;
      }
      while_break___17: /* CIL Label */ ;
      }
      {
#line 519
      while (1) {
        while_continue___18: /* CIL Label */ ;
        {
#line 519
        lb.bb = bitbuf;
#line 519
        lb.bl = bitsleft;
#line 519
        lb.ip = inpos;
#line 519
        tmp___2 = lzx_read_lens(pState, pState->MAINTREE_len, (ULONG )256, (ULONG )pState->main_elements,
                                & lb);
        }
#line 519
        if (tmp___2) {
#line 519
          return (2);
        }
#line 519
        bitbuf = lb.bb;
#line 519
        bitsleft = lb.bl;
#line 519
        inpos = lb.ip;
#line 519
        goto while_break___18;
      }
      while_break___18: /* CIL Label */ ;
      }
      {
#line 520
      tmp___3 = make_decode_table((ULONG )656, (ULONG )12, pState->MAINTREE_len, pState->MAINTREE_table);
      }
#line 520
      if (tmp___3) {
#line 520
        return (2);
      }
#line 521
      if ((int )pState->MAINTREE_len[232] != 0) {
#line 521
        pState->intel_started = 1;
      }
      {
#line 523
      while (1) {
        while_continue___19: /* CIL Label */ ;
        {
#line 523
        lb.bb = bitbuf;
#line 523
        lb.bl = bitsleft;
#line 523
        lb.ip = inpos;
#line 523
        tmp___4 = lzx_read_lens(pState, pState->LENGTH_len, (ULONG )0, (ULONG )249,
                                & lb);
        }
#line 523
        if (tmp___4) {
#line 523
          return (2);
        }
#line 523
        bitbuf = lb.bb;
#line 523
        bitsleft = lb.bl;
#line 523
        inpos = lb.ip;
#line 523
        goto while_break___19;
      }
      while_break___19: /* CIL Label */ ;
      }
      {
#line 524
      tmp___5 = make_decode_table((ULONG )250, (ULONG )12, pState->LENGTH_len, pState->LENGTH_table);
      }
#line 524
      if (tmp___5) {
#line 524
        return (2);
      }
#line 525
      goto switch_break;
      case_3: /* CIL Label */ 
#line 528
      pState->intel_started = 1;
      {
#line 529
      while (1) {
        while_continue___20: /* CIL Label */ ;
#line 529
        if (! (bitsleft < 16)) {
#line 529
          goto while_break___20;
        }
#line 529
        bitbuf |= (unsigned int )((((int )*(inpos + 1) << 8) | (int )*(inpos + 0)) << (((sizeof(ULONG ) << 3) - 16UL) - (unsigned long )bitsleft));
#line 529
        bitsleft += 16;
#line 529
        inpos += 2;
      }
      while_break___20: /* CIL Label */ ;
      }
#line 530
      if (bitsleft > 16) {
#line 530
        inpos -= 2;
      }
#line 531
      R0 = (ULONG )((((int )*(inpos + 0) | ((int )*(inpos + 1) << 8)) | ((int )*(inpos + 2) << 16)) | ((int )*(inpos + 3) << 24));
#line 531
      inpos += 4;
#line 532
      R1 = (ULONG )((((int )*(inpos + 0) | ((int )*(inpos + 1) << 8)) | ((int )*(inpos + 2) << 16)) | ((int )*(inpos + 3) << 24));
#line 532
      inpos += 4;
#line 533
      R2 = (ULONG )((((int )*(inpos + 0) | ((int )*(inpos + 1) << 8)) | ((int )*(inpos + 2) << 16)) | ((int )*(inpos + 3) << 24));
#line 533
      inpos += 4;
#line 534
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 537
      return (2);
      switch_break: /* CIL Label */ ;
      }
    }
#line 542
    if ((unsigned long )inpos > (unsigned long )endinp) {
#line 551
      if ((unsigned long )inpos > (unsigned long )(endinp + 2)) {
#line 551
        return (2);
      } else
#line 551
      if (bitsleft < 16) {
#line 551
        return (2);
      }
    }
    {
#line 554
    while (1) {
      while_continue___21: /* CIL Label */ ;
#line 554
      this_run = (int )pState->block_remaining;
#line 554
      if (this_run > 0) {
#line 554
        if (! (togo > 0)) {
#line 554
          goto while_break___21;
        }
      } else {
#line 554
        goto while_break___21;
      }
#line 555
      if (this_run > togo) {
#line 555
        this_run = togo;
      }
#line 556
      togo -= this_run;
#line 557
      pState->block_remaining -= (ULONG )this_run;
#line 560
      window_posn &= window_size - 1U;
#line 562
      if (window_posn + (ULONG )this_run > window_size) {
#line 563
        return (1);
      }
      {
#line 567
      if ((int )pState->block_type == 1) {
#line 567
        goto case_1___0;
      }
#line 632
      if ((int )pState->block_type == 2) {
#line 632
        goto case_2___0;
      }
#line 713
      if ((int )pState->block_type == 3) {
#line 713
        goto case_3___0;
      }
#line 719
      goto switch_default___0;
      case_1___0: /* CIL Label */ 
      {
#line 568
      while (1) {
        while_continue___22: /* CIL Label */ ;
#line 568
        if (! (this_run > 0)) {
#line 568
          goto while_break___22;
        }
        {
#line 569
        while (1) {
          while_continue___23: /* CIL Label */ ;
          {
#line 569
          while (1) {
            while_continue___24: /* CIL Label */ ;
#line 569
            if (! (bitsleft < 16)) {
#line 569
              goto while_break___24;
            }
#line 569
            bitbuf |= (unsigned int )((((int )*(inpos + 1) << 8) | (int )*(inpos + 0)) << (((sizeof(ULONG ) << 3) - 16UL) - (unsigned long )bitsleft));
#line 569
            bitsleft += 16;
#line 569
            inpos += 2;
          }
          while_break___24: /* CIL Label */ ;
          }
#line 569
          hufftbl = pState->MAINTREE_table;
#line 569
          i = (ULONG )*(hufftbl + (bitbuf >> ((sizeof(ULONG ) << 3) - 12UL)));
#line 569
          if (i >= 656U) {
#line 569
            j = (ULONG )(1 << ((sizeof(ULONG ) << 3) - 12UL));
            {
#line 569
            while (1) {
              while_continue___25: /* CIL Label */ ;
#line 569
              j >>= 1;
#line 569
              i <<= 1;
#line 569
              if (bitbuf & j) {
#line 569
                tmp___6 = 1;
              } else {
#line 569
                tmp___6 = 0;
              }
#line 569
              i |= (unsigned int )tmp___6;
#line 569
              if (! j) {
#line 569
                return (2);
              }
#line 569
              i = (ULONG )*(hufftbl + i);
#line 569
              if (! (i >= 656U)) {
#line 569
                goto while_break___25;
              }
            }
            while_break___25: /* CIL Label */ ;
            }
          }
#line 569
          main_element = (int )i;
#line 569
          j = (ULONG )pState->MAINTREE_len[main_element];
#line 569
          bitbuf <<= j;
#line 569
          bitsleft = (int )((ULONG )bitsleft - j);
#line 569
          goto while_break___23;
        }
        while_break___23: /* CIL Label */ ;
        }
#line 571
        if (main_element < 256) {
#line 573
          tmp___7 = window_posn;
#line 573
          window_posn ++;
#line 573
          *(window + tmp___7) = (UBYTE )main_element;
#line 574
          this_run --;
        } else {
#line 578
          main_element -= 256;
#line 580
          match_length = main_element & 7;
#line 581
          if (match_length == 7) {
            {
#line 582
            while (1) {
              while_continue___26: /* CIL Label */ ;
              {
#line 582
              while (1) {
                while_continue___27: /* CIL Label */ ;
#line 582
                if (! (bitsleft < 16)) {
#line 582
                  goto while_break___27;
                }
#line 582
                bitbuf |= (unsigned int )((((int )*(inpos + 1) << 8) | (int )*(inpos + 0)) << (((sizeof(ULONG ) << 3) - 16UL) - (unsigned long )bitsleft));
#line 582
                bitsleft += 16;
#line 582
                inpos += 2;
              }
              while_break___27: /* CIL Label */ ;
              }
#line 582
              hufftbl = pState->LENGTH_table;
#line 582
              i = (ULONG )*(hufftbl + (bitbuf >> ((sizeof(ULONG ) << 3) - 12UL)));
#line 582
              if (i >= 250U) {
#line 582
                j = (ULONG )(1 << ((sizeof(ULONG ) << 3) - 12UL));
                {
#line 582
                while (1) {
                  while_continue___28: /* CIL Label */ ;
#line 582
                  j >>= 1;
#line 582
                  i <<= 1;
#line 582
                  if (bitbuf & j) {
#line 582
                    tmp___8 = 1;
                  } else {
#line 582
                    tmp___8 = 0;
                  }
#line 582
                  i |= (unsigned int )tmp___8;
#line 582
                  if (! j) {
#line 582
                    return (2);
                  }
#line 582
                  i = (ULONG )*(hufftbl + i);
#line 582
                  if (! (i >= 250U)) {
#line 582
                    goto while_break___28;
                  }
                }
                while_break___28: /* CIL Label */ ;
                }
              }
#line 582
              length_footer = (int )i;
#line 582
              j = (ULONG )pState->LENGTH_len[length_footer];
#line 582
              bitbuf <<= j;
#line 582
              bitsleft = (int )((ULONG )bitsleft - j);
#line 582
              goto while_break___26;
            }
            while_break___26: /* CIL Label */ ;
            }
#line 583
            match_length += length_footer;
          }
#line 585
          match_length += 2;
#line 587
          match_offset = (ULONG )(main_element >> 3);
#line 589
          if (match_offset > 2U) {
#line 591
            if (match_offset != 3U) {
#line 592
              extra = (int )extra_bits[match_offset];
              {
#line 593
              while (1) {
                while_continue___29: /* CIL Label */ ;
                {
#line 593
                while (1) {
                  while_continue___30: /* CIL Label */ ;
#line 593
                  if (! (bitsleft < extra)) {
#line 593
                    goto while_break___30;
                  }
#line 593
                  bitbuf |= (unsigned int )((((int )*(inpos + 1) << 8) | (int )*(inpos + 0)) << (((sizeof(ULONG ) << 3) - 16UL) - (unsigned long )bitsleft));
#line 593
                  bitsleft += 16;
#line 593
                  inpos += 2;
                }
                while_break___30: /* CIL Label */ ;
                }
#line 593
                verbatim_bits = (int )(bitbuf >> ((sizeof(ULONG ) << 3) - (unsigned long )extra));
#line 593
                bitbuf <<= extra;
#line 593
                bitsleft -= extra;
#line 593
                goto while_break___29;
              }
              while_break___29: /* CIL Label */ ;
              }
#line 594
              match_offset = (ULONG )((position_base[match_offset] - 2U) + (ULONG const   )verbatim_bits);
            } else {
#line 597
              match_offset = (ULONG )1;
            }
#line 601
            R2 = R1;
#line 601
            R1 = R0;
#line 601
            R0 = match_offset;
          } else
#line 603
          if (match_offset == 0U) {
#line 604
            match_offset = R0;
          } else
#line 606
          if (match_offset == 1U) {
#line 607
            match_offset = R1;
#line 608
            R1 = R0;
#line 608
            R0 = match_offset;
          } else {
#line 611
            match_offset = R2;
#line 612
            R2 = R0;
#line 612
            R0 = match_offset;
          }
#line 615
          rundest = window + window_posn;
#line 616
          runsrc = rundest - match_offset;
#line 617
          window_posn += (ULONG )match_length;
#line 618
          if (window_posn > window_size) {
#line 618
            return (2);
          }
#line 619
          this_run -= match_length;
          {
#line 622
          while (1) {
            while_continue___31: /* CIL Label */ ;
#line 622
            if ((unsigned long )runsrc < (unsigned long )window) {
#line 622
              tmp___10 = match_length;
#line 622
              match_length --;
#line 622
              if (! (tmp___10 > 0)) {
#line 622
                goto while_break___31;
              }
            } else {
#line 622
              goto while_break___31;
            }
#line 623
            tmp___9 = rundest;
#line 623
            rundest ++;
#line 623
            *tmp___9 = *(runsrc + window_size);
#line 623
            runsrc ++;
          }
          while_break___31: /* CIL Label */ ;
          }
          {
#line 626
          while (1) {
            while_continue___32: /* CIL Label */ ;
#line 626
            tmp___13 = match_length;
#line 626
            match_length --;
#line 626
            if (! (tmp___13 > 0)) {
#line 626
              goto while_break___32;
            }
#line 626
            tmp___11 = rundest;
#line 626
            rundest ++;
#line 626
            tmp___12 = runsrc;
#line 626
            runsrc ++;
#line 626
            *tmp___11 = *tmp___12;
          }
          while_break___32: /* CIL Label */ ;
          }
        }
      }
      while_break___22: /* CIL Label */ ;
      }
#line 630
      goto switch_break___0;
      case_2___0: /* CIL Label */ 
      {
#line 633
      while (1) {
        while_continue___33: /* CIL Label */ ;
#line 633
        if (! (this_run > 0)) {
#line 633
          goto while_break___33;
        }
        {
#line 634
        while (1) {
          while_continue___34: /* CIL Label */ ;
          {
#line 634
          while (1) {
            while_continue___35: /* CIL Label */ ;
#line 634
            if (! (bitsleft < 16)) {
#line 634
              goto while_break___35;
            }
#line 634
            bitbuf |= (unsigned int )((((int )*(inpos + 1) << 8) | (int )*(inpos + 0)) << (((sizeof(ULONG ) << 3) - 16UL) - (unsigned long )bitsleft));
#line 634
            bitsleft += 16;
#line 634
            inpos += 2;
          }
          while_break___35: /* CIL Label */ ;
          }
#line 634
          hufftbl = pState->MAINTREE_table;
#line 634
          i = (ULONG )*(hufftbl + (bitbuf >> ((sizeof(ULONG ) << 3) - 12UL)));
#line 634
          if (i >= 656U) {
#line 634
            j = (ULONG )(1 << ((sizeof(ULONG ) << 3) - 12UL));
            {
#line 634
            while (1) {
              while_continue___36: /* CIL Label */ ;
#line 634
              j >>= 1;
#line 634
              i <<= 1;
#line 634
              if (bitbuf & j) {
#line 634
                tmp___14 = 1;
              } else {
#line 634
                tmp___14 = 0;
              }
#line 634
              i |= (unsigned int )tmp___14;
#line 634
              if (! j) {
#line 634
                return (2);
              }
#line 634
              i = (ULONG )*(hufftbl + i);
#line 634
              if (! (i >= 656U)) {
#line 634
                goto while_break___36;
              }
            }
            while_break___36: /* CIL Label */ ;
            }
          }
#line 634
          main_element = (int )i;
#line 634
          j = (ULONG )pState->MAINTREE_len[main_element];
#line 634
          bitbuf <<= j;
#line 634
          bitsleft = (int )((ULONG )bitsleft - j);
#line 634
          goto while_break___34;
        }
        while_break___34: /* CIL Label */ ;
        }
#line 636
        if (main_element < 256) {
#line 638
          tmp___15 = window_posn;
#line 638
          window_posn ++;
#line 638
          *(window + tmp___15) = (UBYTE )main_element;
#line 639
          this_run --;
        } else {
#line 643
          main_element -= 256;
#line 645
          match_length = main_element & 7;
#line 646
          if (match_length == 7) {
            {
#line 647
            while (1) {
              while_continue___37: /* CIL Label */ ;
              {
#line 647
              while (1) {
                while_continue___38: /* CIL Label */ ;
#line 647
                if (! (bitsleft < 16)) {
#line 647
                  goto while_break___38;
                }
#line 647
                bitbuf |= (unsigned int )((((int )*(inpos + 1) << 8) | (int )*(inpos + 0)) << (((sizeof(ULONG ) << 3) - 16UL) - (unsigned long )bitsleft));
#line 647
                bitsleft += 16;
#line 647
                inpos += 2;
              }
              while_break___38: /* CIL Label */ ;
              }
#line 647
              hufftbl = pState->LENGTH_table;
#line 647
              i = (ULONG )*(hufftbl + (bitbuf >> ((sizeof(ULONG ) << 3) - 12UL)));
#line 647
              if (i >= 250U) {
#line 647
                j = (ULONG )(1 << ((sizeof(ULONG ) << 3) - 12UL));
                {
#line 647
                while (1) {
                  while_continue___39: /* CIL Label */ ;
#line 647
                  j >>= 1;
#line 647
                  i <<= 1;
#line 647
                  if (bitbuf & j) {
#line 647
                    tmp___16 = 1;
                  } else {
#line 647
                    tmp___16 = 0;
                  }
#line 647
                  i |= (unsigned int )tmp___16;
#line 647
                  if (! j) {
#line 647
                    return (2);
                  }
#line 647
                  i = (ULONG )*(hufftbl + i);
#line 647
                  if (! (i >= 250U)) {
#line 647
                    goto while_break___39;
                  }
                }
                while_break___39: /* CIL Label */ ;
                }
              }
#line 647
              length_footer = (int )i;
#line 647
              j = (ULONG )pState->LENGTH_len[length_footer];
#line 647
              bitbuf <<= j;
#line 647
              bitsleft = (int )((ULONG )bitsleft - j);
#line 647
              goto while_break___37;
            }
            while_break___37: /* CIL Label */ ;
            }
#line 648
            match_length += length_footer;
          }
#line 650
          match_length += 2;
#line 652
          match_offset = (ULONG )(main_element >> 3);
#line 654
          if (match_offset > 2U) {
#line 656
            extra = (int )extra_bits[match_offset];
#line 657
            match_offset = (ULONG )(position_base[match_offset] - 2U);
#line 658
            if (extra > 3) {
#line 660
              extra -= 3;
              {
#line 661
              while (1) {
                while_continue___40: /* CIL Label */ ;
                {
#line 661
                while (1) {
                  while_continue___41: /* CIL Label */ ;
#line 661
                  if (! (bitsleft < extra)) {
#line 661
                    goto while_break___41;
                  }
#line 661
                  bitbuf |= (unsigned int )((((int )*(inpos + 1) << 8) | (int )*(inpos + 0)) << (((sizeof(ULONG ) << 3) - 16UL) - (unsigned long )bitsleft));
#line 661
                  bitsleft += 16;
#line 661
                  inpos += 2;
                }
                while_break___41: /* CIL Label */ ;
                }
#line 661
                verbatim_bits = (int )(bitbuf >> ((sizeof(ULONG ) << 3) - (unsigned long )extra));
#line 661
                bitbuf <<= extra;
#line 661
                bitsleft -= extra;
#line 661
                goto while_break___40;
              }
              while_break___40: /* CIL Label */ ;
              }
#line 662
              match_offset += (ULONG )(verbatim_bits << 3);
              {
#line 663
              while (1) {
                while_continue___42: /* CIL Label */ ;
                {
#line 663
                while (1) {
                  while_continue___43: /* CIL Label */ ;
#line 663
                  if (! (bitsleft < 16)) {
#line 663
                    goto while_break___43;
                  }
#line 663
                  bitbuf |= (unsigned int )((((int )*(inpos + 1) << 8) | (int )*(inpos + 0)) << (((sizeof(ULONG ) << 3) - 16UL) - (unsigned long )bitsleft));
#line 663
                  bitsleft += 16;
#line 663
                  inpos += 2;
                }
                while_break___43: /* CIL Label */ ;
                }
#line 663
                hufftbl = pState->ALIGNED_table;
#line 663
                i = (ULONG )*(hufftbl + (bitbuf >> ((sizeof(ULONG ) << 3) - 7UL)));
#line 663
                if (i >= 8U) {
#line 663
                  j = (ULONG )(1 << ((sizeof(ULONG ) << 3) - 7UL));
                  {
#line 663
                  while (1) {
                    while_continue___44: /* CIL Label */ ;
#line 663
                    j >>= 1;
#line 663
                    i <<= 1;
#line 663
                    if (bitbuf & j) {
#line 663
                      tmp___17 = 1;
                    } else {
#line 663
                      tmp___17 = 0;
                    }
#line 663
                    i |= (unsigned int )tmp___17;
#line 663
                    if (! j) {
#line 663
                      return (2);
                    }
#line 663
                    i = (ULONG )*(hufftbl + i);
#line 663
                    if (! (i >= 8U)) {
#line 663
                      goto while_break___44;
                    }
                  }
                  while_break___44: /* CIL Label */ ;
                  }
                }
#line 663
                aligned_bits = (int )i;
#line 663
                j = (ULONG )pState->ALIGNED_len[aligned_bits];
#line 663
                bitbuf <<= j;
#line 663
                bitsleft = (int )((ULONG )bitsleft - j);
#line 663
                goto while_break___42;
              }
              while_break___42: /* CIL Label */ ;
              }
#line 664
              match_offset += (ULONG )aligned_bits;
            } else
#line 666
            if (extra == 3) {
              {
#line 668
              while (1) {
                while_continue___45: /* CIL Label */ ;
                {
#line 668
                while (1) {
                  while_continue___46: /* CIL Label */ ;
#line 668
                  if (! (bitsleft < 16)) {
#line 668
                    goto while_break___46;
                  }
#line 668
                  bitbuf |= (unsigned int )((((int )*(inpos + 1) << 8) | (int )*(inpos + 0)) << (((sizeof(ULONG ) << 3) - 16UL) - (unsigned long )bitsleft));
#line 668
                  bitsleft += 16;
#line 668
                  inpos += 2;
                }
                while_break___46: /* CIL Label */ ;
                }
#line 668
                hufftbl = pState->ALIGNED_table;
#line 668
                i = (ULONG )*(hufftbl + (bitbuf >> ((sizeof(ULONG ) << 3) - 7UL)));
#line 668
                if (i >= 8U) {
#line 668
                  j = (ULONG )(1 << ((sizeof(ULONG ) << 3) - 7UL));
                  {
#line 668
                  while (1) {
                    while_continue___47: /* CIL Label */ ;
#line 668
                    j >>= 1;
#line 668
                    i <<= 1;
#line 668
                    if (bitbuf & j) {
#line 668
                      tmp___18 = 1;
                    } else {
#line 668
                      tmp___18 = 0;
                    }
#line 668
                    i |= (unsigned int )tmp___18;
#line 668
                    if (! j) {
#line 668
                      return (2);
                    }
#line 668
                    i = (ULONG )*(hufftbl + i);
#line 668
                    if (! (i >= 8U)) {
#line 668
                      goto while_break___47;
                    }
                  }
                  while_break___47: /* CIL Label */ ;
                  }
                }
#line 668
                aligned_bits = (int )i;
#line 668
                j = (ULONG )pState->ALIGNED_len[aligned_bits];
#line 668
                bitbuf <<= j;
#line 668
                bitsleft = (int )((ULONG )bitsleft - j);
#line 668
                goto while_break___45;
              }
              while_break___45: /* CIL Label */ ;
              }
#line 669
              match_offset += (ULONG )aligned_bits;
            } else
#line 671
            if (extra > 0) {
              {
#line 673
              while (1) {
                while_continue___48: /* CIL Label */ ;
                {
#line 673
                while (1) {
                  while_continue___49: /* CIL Label */ ;
#line 673
                  if (! (bitsleft < extra)) {
#line 673
                    goto while_break___49;
                  }
#line 673
                  bitbuf |= (unsigned int )((((int )*(inpos + 1) << 8) | (int )*(inpos + 0)) << (((sizeof(ULONG ) << 3) - 16UL) - (unsigned long )bitsleft));
#line 673
                  bitsleft += 16;
#line 673
                  inpos += 2;
                }
                while_break___49: /* CIL Label */ ;
                }
#line 673
                verbatim_bits = (int )(bitbuf >> ((sizeof(ULONG ) << 3) - (unsigned long )extra));
#line 673
                bitbuf <<= extra;
#line 673
                bitsleft -= extra;
#line 673
                goto while_break___48;
              }
              while_break___48: /* CIL Label */ ;
              }
#line 674
              match_offset += (ULONG )verbatim_bits;
            } else {
#line 678
              match_offset = (ULONG )1;
            }
#line 682
            R2 = R1;
#line 682
            R1 = R0;
#line 682
            R0 = match_offset;
          } else
#line 684
          if (match_offset == 0U) {
#line 685
            match_offset = R0;
          } else
#line 687
          if (match_offset == 1U) {
#line 688
            match_offset = R1;
#line 689
            R1 = R0;
#line 689
            R0 = match_offset;
          } else {
#line 692
            match_offset = R2;
#line 693
            R2 = R0;
#line 693
            R0 = match_offset;
          }
#line 696
          rundest = window + window_posn;
#line 697
          runsrc = rundest - match_offset;
#line 698
          window_posn += (ULONG )match_length;
#line 699
          if (window_posn > window_size) {
#line 699
            return (2);
          }
#line 700
          this_run -= match_length;
          {
#line 703
          while (1) {
            while_continue___50: /* CIL Label */ ;
#line 703
            if ((unsigned long )runsrc < (unsigned long )window) {
#line 703
              tmp___20 = match_length;
#line 703
              match_length --;
#line 703
              if (! (tmp___20 > 0)) {
#line 703
                goto while_break___50;
              }
            } else {
#line 703
              goto while_break___50;
            }
#line 704
            tmp___19 = rundest;
#line 704
            rundest ++;
#line 704
            *tmp___19 = *(runsrc + window_size);
#line 704
            runsrc ++;
          }
          while_break___50: /* CIL Label */ ;
          }
          {
#line 707
          while (1) {
            while_continue___51: /* CIL Label */ ;
#line 707
            tmp___23 = match_length;
#line 707
            match_length --;
#line 707
            if (! (tmp___23 > 0)) {
#line 707
              goto while_break___51;
            }
#line 707
            tmp___21 = rundest;
#line 707
            rundest ++;
#line 707
            tmp___22 = runsrc;
#line 707
            runsrc ++;
#line 707
            *tmp___21 = *tmp___22;
          }
          while_break___51: /* CIL Label */ ;
          }
        }
      }
      while_break___33: /* CIL Label */ ;
      }
#line 711
      goto switch_break___0;
      case_3___0: /* CIL Label */ 
#line 714
      if ((unsigned long )(inpos + this_run) > (unsigned long )endinp) {
#line 714
        return (2);
      }
      {
#line 715
      __builtin_memcpy((void *)(window + window_posn), (void const   *)inpos, (size_t )this_run);
#line 716
      inpos += this_run;
#line 716
      window_posn += (ULONG )this_run;
      }
#line 717
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
#line 720
      return (2);
      switch_break___0: /* CIL Label */ ;
      }
    }
    while_break___21: /* CIL Label */ ;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
#line 726
  if (togo != 0) {
#line 726
    return (2);
  }
#line 727
  if (! window_posn) {
#line 727
    tmp___24 = window_size;
  } else {
#line 727
    tmp___24 = window_posn;
  }
  {
#line 727
  __builtin_memcpy((void *)outpos, (void const   *)((window + tmp___24) - outlen),
                   (size_t )outlen);
#line 729
  pState->window_posn = window_posn;
#line 730
  pState->R0 = R0;
#line 731
  pState->R1 = R1;
#line 732
  pState->R2 = R2;
#line 735
  tmp___26 = pState->frames_read;
#line 735
  (pState->frames_read) ++;
  }
#line 735
  if (tmp___26 < 32768U) {
#line 735
    if (pState->intel_filesize != 0) {
#line 736
      if (outlen <= 6) {
#line 737
        pState->intel_curpos += outlen;
      } else
#line 736
      if (! pState->intel_started) {
#line 737
        pState->intel_curpos += outlen;
      } else {
#line 740
        data = outpos;
#line 741
        dataend = (data + outlen) - 10;
#line 742
        curpos = pState->intel_curpos;
#line 743
        filesize = pState->intel_filesize;
#line 746
        pState->intel_curpos = curpos + outlen;
        {
#line 748
        while (1) {
          while_continue___52: /* CIL Label */ ;
#line 748
          if (! ((unsigned long )data < (unsigned long )dataend)) {
#line 748
            goto while_break___52;
          }
#line 749
          tmp___25 = data;
#line 749
          data ++;
#line 749
          if ((int )*tmp___25 != 232) {
#line 749
            curpos ++;
#line 749
            goto while_continue___52;
          }
#line 750
          abs_off = (((int )*(data + 0) | ((int )*(data + 1) << 8)) | ((int )*(data + 2) << 16)) | ((int )*(data + 3) << 24);
#line 751
          if (abs_off >= - curpos) {
#line 751
            if (abs_off < filesize) {
#line 752
              if (abs_off >= 0) {
#line 752
                rel_off = abs_off - curpos;
              } else {
#line 752
                rel_off = abs_off + filesize;
              }
#line 753
              *(data + 0) = (UBYTE )rel_off;
#line 754
              *(data + 1) = (UBYTE )(rel_off >> 8);
#line 755
              *(data + 2) = (UBYTE )(rel_off >> 16);
#line 756
              *(data + 3) = (UBYTE )(rel_off >> 24);
            }
          }
#line 758
          data += 4;
#line 759
          curpos += 5;
        }
        while_break___52: /* CIL Label */ ;
        }
      }
    }
  }
#line 763
  return (0);
}
}
/* compiler builtin: 
   unsigned long __builtin_strlen(char const   * ) ;  */
#line 90 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/chm_lib.h"
struct chmFile *chm_open(char const   *filename ) ;
#line 94
void chm_close(struct chmFile *h ) ;
#line 98
void chm_set_param(struct chmFile *h , int paramType , int paramVal ) ;
#line 105
int chm_resolve_object(struct chmFile *h , char const   *objPath , struct chmUnitInfo *ui ) ;
#line 110
LONGINT64 chm_retrieve_object(struct chmFile *h , struct chmUnitInfo *ui , unsigned char *buf ,
                              LONGUINT64 addr , LONGINT64 len ) ;
#line 129
int chm_enumerate(struct chmFile *h , int what , int (*e)(struct chmFile *h , struct chmUnitInfo *ui ,
                                                          void *context ) , void *context ) ;
#line 134
int chm_enumerate_dir(struct chmFile *h , char const   *prefix , int what , int (*e)(struct chmFile *h ,
                                                                                     struct chmUnitInfo *ui ,
                                                                                     void *context ) ,
                      void *context ) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 523
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ffs)(int __i )  __attribute__((__const__)) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 538
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 760 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                                         pthread_mutexattr_t const   *__mutexattr ) ;
#line 765
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_destroy)(pthread_mutex_t *__mutex ) ;
#line 773
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
#line 784
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
#line 202 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/chm_lib.c"
static int _unmarshal_char_array(unsigned char **pData , unsigned int *pLenRemain ,
                                 char *dest , int count ) 
{ 


  {
#line 207
  if (count <= 0) {
#line 208
    return (0);
  } else
#line 207
  if ((unsigned int )count > *pLenRemain) {
#line 208
    return (0);
  }
  {
#line 209
  __builtin_memcpy((void *)dest, (void const   *)*pData, (unsigned long )count);
#line 210
  *pData += count;
#line 211
  *pLenRemain -= (unsigned int )count;
  }
#line 212
  return (1);
}
}
#line 215 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/chm_lib.c"
static int _unmarshal_uchar_array(unsigned char **pData , unsigned int *pLenRemain ,
                                  unsigned char *dest , int count ) 
{ 


  {
#line 220
  if (count <= 0) {
#line 221
    return (0);
  } else
#line 220
  if ((unsigned int )count > *pLenRemain) {
#line 221
    return (0);
  }
  {
#line 222
  __builtin_memcpy((void *)dest, (void const   *)*pData, (unsigned long )count);
#line 223
  *pData += count;
#line 224
  *pLenRemain -= (unsigned int )count;
  }
#line 225
  return (1);
}
}
#line 254 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/chm_lib.c"
static int _unmarshal_int32(unsigned char **pData , unsigned int *pLenRemain , Int32 *dest ) 
{ 


  {
#line 258
  if (4U > *pLenRemain) {
#line 259
    return (0);
  }
#line 260
  *dest = (((int )*(*pData + 0) | ((int )*(*pData + 1) << 8)) | ((int )*(*pData + 2) << 16)) | ((int )*(*pData + 3) << 24);
#line 261
  *pData += 4;
#line 262
  *pLenRemain -= 4U;
#line 263
  return (1);
}
}
#line 266 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/chm_lib.c"
static int _unmarshal_uint32(unsigned char **pData , unsigned int *pLenRemain , UInt32 *dest ) 
{ 


  {
#line 270
  if (4U > *pLenRemain) {
#line 271
    return (0);
  }
#line 272
  *dest = (UInt32 )((((int )*(*pData + 0) | ((int )*(*pData + 1) << 8)) | ((int )*(*pData + 2) << 16)) | ((int )*(*pData + 3) << 24));
#line 273
  *pData += 4;
#line 274
  *pLenRemain -= 4U;
#line 275
  return (1);
}
}
#line 278 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/chm_lib.c"
static int _unmarshal_int64(unsigned char **pData , unsigned int *pLenRemain , Int64 *dest ) 
{ 
  Int64 temp ;
  int i ;

  {
#line 284
  if (8U > *pLenRemain) {
#line 285
    return (0);
  }
#line 286
  temp = (Int64 )0;
#line 287
  i = 8;
  {
#line 287
  while (1) {
    while_continue: /* CIL Label */ ;
#line 287
    if (! (i > 0)) {
#line 287
      goto while_break;
    }
#line 289
    temp <<= 8;
#line 290
    temp |= (long )*(*pData + (i - 1));
#line 287
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 292
  *dest = temp;
#line 293
  *pData += 8;
#line 294
  *pLenRemain -= 8U;
#line 295
  return (1);
}
}
#line 298 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/chm_lib.c"
static int _unmarshal_uint64(unsigned char **pData , unsigned int *pLenRemain , UInt64 *dest ) 
{ 
  UInt64 temp ;
  int i ;

  {
#line 304
  if (8U > *pLenRemain) {
#line 305
    return (0);
  }
#line 306
  temp = (UInt64 )0;
#line 307
  i = 8;
  {
#line 307
  while (1) {
    while_continue: /* CIL Label */ ;
#line 307
    if (! (i > 0)) {
#line 307
      goto while_break;
    }
#line 309
    temp <<= 8;
#line 310
    temp |= (unsigned long )*(*pData + (i - 1));
#line 307
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 312
  *dest = temp;
#line 313
  *pData += 8;
#line 314
  *pLenRemain -= 8U;
#line 315
  return (1);
}
}
#line 318 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/chm_lib.c"
static int _unmarshal_uuid(unsigned char **pData , unsigned int *pDataLen , unsigned char *dest ) 
{ 
  int tmp ;

  {
  {
#line 322
  tmp = _unmarshal_uchar_array(pData, pDataLen, dest, 16);
  }
#line 322
  return (tmp);
}
}
#line 326 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/chm_lib.c"
static char const   _CHMU_RESET_TABLE[106]  = 
#line 326
  {      (char const   )':',      (char const   )':',      (char const   )'D',      (char const   )'a', 
        (char const   )'t',      (char const   )'a',      (char const   )'S',      (char const   )'p', 
        (char const   )'a',      (char const   )'c',      (char const   )'e',      (char const   )'/', 
        (char const   )'S',      (char const   )'t',      (char const   )'o',      (char const   )'r', 
        (char const   )'a',      (char const   )'g',      (char const   )'e',      (char const   )'/', 
        (char const   )'M',      (char const   )'S',      (char const   )'C',      (char const   )'o', 
        (char const   )'m',      (char const   )'p',      (char const   )'r',      (char const   )'e', 
        (char const   )'s',      (char const   )'s',      (char const   )'e',      (char const   )'d', 
        (char const   )'/',      (char const   )'T',      (char const   )'r',      (char const   )'a', 
        (char const   )'n',      (char const   )'s',      (char const   )'f',      (char const   )'o', 
        (char const   )'r',      (char const   )'m',      (char const   )'/',      (char const   )'{', 
        (char const   )'7',      (char const   )'F',      (char const   )'C',      (char const   )'2', 
        (char const   )'8',      (char const   )'9',      (char const   )'4',      (char const   )'0', 
        (char const   )'-',      (char const   )'9',      (char const   )'D',      (char const   )'3', 
        (char const   )'1',      (char const   )'-',      (char const   )'1',      (char const   )'1', 
        (char const   )'D',      (char const   )'0',      (char const   )'-',      (char const   )'9', 
        (char const   )'B',      (char const   )'2',      (char const   )'7',      (char const   )'-', 
        (char const   )'0',      (char const   )'0',      (char const   )'A',      (char const   )'0', 
        (char const   )'C',      (char const   )'9',      (char const   )'1',      (char const   )'E', 
        (char const   )'9',      (char const   )'C',      (char const   )'7',      (char const   )'C', 
        (char const   )'}',      (char const   )'/',      (char const   )'I',      (char const   )'n', 
        (char const   )'s',      (char const   )'t',      (char const   )'a',      (char const   )'n', 
        (char const   )'c',      (char const   )'e',      (char const   )'D',      (char const   )'a', 
        (char const   )'t',      (char const   )'a',      (char const   )'/',      (char const   )'R', 
        (char const   )'e',      (char const   )'s',      (char const   )'e',      (char const   )'t', 
        (char const   )'T',      (char const   )'a',      (char const   )'b',      (char const   )'l', 
        (char const   )'e',      (char const   )'\000'};
#line 330 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/chm_lib.c"
static char const   _CHMU_LZXC_CONTROLDATA[45]  = 
#line 330
  {      (char const   )':',      (char const   )':',      (char const   )'D',      (char const   )'a', 
        (char const   )'t',      (char const   )'a',      (char const   )'S',      (char const   )'p', 
        (char const   )'a',      (char const   )'c',      (char const   )'e',      (char const   )'/', 
        (char const   )'S',      (char const   )'t',      (char const   )'o',      (char const   )'r', 
        (char const   )'a',      (char const   )'g',      (char const   )'e',      (char const   )'/', 
        (char const   )'M',      (char const   )'S',      (char const   )'C',      (char const   )'o', 
        (char const   )'m',      (char const   )'p',      (char const   )'r',      (char const   )'e', 
        (char const   )'s',      (char const   )'s',      (char const   )'e',      (char const   )'d', 
        (char const   )'/',      (char const   )'C',      (char const   )'o',      (char const   )'n', 
        (char const   )'t',      (char const   )'r',      (char const   )'o',      (char const   )'l', 
        (char const   )'D',      (char const   )'a',      (char const   )'t',      (char const   )'a', 
        (char const   )'\000'};
#line 332 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/chm_lib.c"
static char const   _CHMU_CONTENT[41]  = 
#line 332
  {      (char const   )':',      (char const   )':',      (char const   )'D',      (char const   )'a', 
        (char const   )'t',      (char const   )'a',      (char const   )'S',      (char const   )'p', 
        (char const   )'a',      (char const   )'c',      (char const   )'e',      (char const   )'/', 
        (char const   )'S',      (char const   )'t',      (char const   )'o',      (char const   )'r', 
        (char const   )'a',      (char const   )'g',      (char const   )'e',      (char const   )'/', 
        (char const   )'M',      (char const   )'S',      (char const   )'C',      (char const   )'o', 
        (char const   )'m',      (char const   )'p',      (char const   )'r',      (char const   )'e', 
        (char const   )'s',      (char const   )'s',      (char const   )'e',      (char const   )'d', 
        (char const   )'/',      (char const   )'C',      (char const   )'o',      (char const   )'n', 
        (char const   )'t',      (char const   )'e',      (char const   )'n',      (char const   )'t', 
        (char const   )'\000'};
#line 387
extern int ( /* missing proto */  __builtin_memcmp)() ;
#line 361 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/chm_lib.c"
static int _unmarshal_itsf_header(unsigned char **pData , unsigned int *pDataLen ,
                                  struct chmItsfHeader *dest ) 
{ 
  int tmp ;

  {
#line 366
  if (*pDataLen != 88U) {
#line 366
    if (*pDataLen != 96U) {
#line 367
      return (0);
    }
  }
  {
#line 370
  _unmarshal_char_array(pData, pDataLen, dest->signature, 4);
#line 371
  _unmarshal_int32(pData, pDataLen, & dest->version);
#line 372
  _unmarshal_int32(pData, pDataLen, & dest->header_len);
#line 373
  _unmarshal_int32(pData, pDataLen, & dest->unknown_000c);
#line 374
  _unmarshal_uint32(pData, pDataLen, & dest->last_modified);
#line 375
  _unmarshal_uint32(pData, pDataLen, & dest->lang_id);
#line 376
  _unmarshal_uuid(pData, pDataLen, dest->dir_uuid);
#line 377
  _unmarshal_uuid(pData, pDataLen, dest->stream_uuid);
#line 378
  _unmarshal_uint64(pData, pDataLen, & dest->unknown_offset);
#line 379
  _unmarshal_uint64(pData, pDataLen, & dest->unknown_len);
#line 380
  _unmarshal_uint64(pData, pDataLen, & dest->dir_offset);
#line 381
  _unmarshal_uint64(pData, pDataLen, & dest->dir_len);
#line 387
  tmp = __builtin_memcmp(dest->signature, "ITSF", 4);
  }
#line 387
  if (tmp != 0) {
#line 388
    return (0);
  }
#line 389
  if (dest->version == 2) {
#line 391
    if (dest->header_len < 88) {
#line 392
      return (0);
    }
  } else
#line 394
  if (dest->version == 3) {
#line 396
    if (dest->header_len < 96) {
#line 397
      return (0);
    }
  } else {
#line 400
    return (0);
  }
#line 405
  if (dest->version == 3) {
#line 407
    if (*pDataLen != 0U) {
      {
#line 408
      _unmarshal_uint64(pData, pDataLen, & dest->data_offset);
      }
    } else {
#line 410
      return (0);
    }
  } else {
#line 413
    dest->data_offset = dest->dir_offset + dest->dir_len;
  }
#line 415
  return (1);
}
}
#line 439 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/chm_lib.c"
static int _unmarshal_itsp_header(unsigned char **pData , unsigned int *pDataLen ,
                                  struct chmItspHeader *dest ) 
{ 
  int tmp ;

  {
#line 444
  if (*pDataLen != 84U) {
#line 445
    return (0);
  }
  {
#line 448
  _unmarshal_char_array(pData, pDataLen, dest->signature, 4);
#line 449
  _unmarshal_int32(pData, pDataLen, & dest->version);
#line 450
  _unmarshal_int32(pData, pDataLen, & dest->header_len);
#line 451
  _unmarshal_int32(pData, pDataLen, & dest->unknown_000c);
#line 452
  _unmarshal_uint32(pData, pDataLen, & dest->block_len);
#line 453
  _unmarshal_int32(pData, pDataLen, & dest->blockidx_intvl);
#line 454
  _unmarshal_int32(pData, pDataLen, & dest->index_depth);
#line 455
  _unmarshal_int32(pData, pDataLen, & dest->index_root);
#line 456
  _unmarshal_int32(pData, pDataLen, & dest->index_head);
#line 457
  _unmarshal_int32(pData, pDataLen, & dest->unknown_0024);
#line 458
  _unmarshal_uint32(pData, pDataLen, & dest->num_blocks);
#line 459
  _unmarshal_int32(pData, pDataLen, & dest->unknown_002c);
#line 460
  _unmarshal_uint32(pData, pDataLen, & dest->lang_id);
#line 461
  _unmarshal_uuid(pData, pDataLen, dest->system_uuid);
#line 462
  _unmarshal_uchar_array(pData, pDataLen, dest->unknown_0044, 16);
#line 465
  tmp = __builtin_memcmp(dest->signature, "ITSP", 4);
  }
#line 465
  if (tmp != 0) {
#line 466
    return (0);
  }
#line 467
  if (dest->version != 1) {
#line 468
    return (0);
  }
#line 469
  if (dest->header_len != 84) {
#line 470
    return (0);
  }
#line 472
  return (1);
}
}
#line 476 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/chm_lib.c"
static char const   _chm_pmgl_marker[4]  = {      (char const   )'P',      (char const   )'M',      (char const   )'G',      (char const   )'L'};
#line 487 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/chm_lib.c"
static int _unmarshal_pmgl_header(unsigned char **pData , unsigned int *pDataLen ,
                                  struct chmPmglHeader *dest ) 
{ 
  int tmp ;

  {
#line 492
  if (*pDataLen != 20U) {
#line 493
    return (0);
  }
  {
#line 496
  _unmarshal_char_array(pData, pDataLen, dest->signature, 4);
#line 497
  _unmarshal_uint32(pData, pDataLen, & dest->free_space);
#line 498
  _unmarshal_uint32(pData, pDataLen, & dest->unknown_0008);
#line 499
  _unmarshal_int32(pData, pDataLen, & dest->block_prev);
#line 500
  _unmarshal_int32(pData, pDataLen, & dest->block_next);
#line 503
  tmp = __builtin_memcmp(dest->signature, _chm_pmgl_marker, 4);
  }
#line 503
  if (tmp != 0) {
#line 504
    return (0);
  }
#line 506
  return (1);
}
}
#line 510 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/chm_lib.c"
static char const   _chm_pmgi_marker[4]  = {      (char const   )'P',      (char const   )'M',      (char const   )'G',      (char const   )'I'};
#line 518 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/chm_lib.c"
static int _unmarshal_pmgi_header(unsigned char **pData , unsigned int *pDataLen ,
                                  struct chmPmgiHeader *dest ) 
{ 
  int tmp ;

  {
#line 523
  if (*pDataLen != 8U) {
#line 524
    return (0);
  }
  {
#line 527
  _unmarshal_char_array(pData, pDataLen, dest->signature, 4);
#line 528
  _unmarshal_uint32(pData, pDataLen, & dest->free_space);
#line 531
  tmp = __builtin_memcmp(dest->signature, _chm_pmgi_marker, 4);
  }
#line 531
  if (tmp != 0) {
#line 532
    return (0);
  }
#line 534
  return (1);
}
}
#line 550 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/chm_lib.c"
static int _unmarshal_lzxc_reset_table(unsigned char **pData , unsigned int *pDataLen ,
                                       struct chmLzxcResetTable *dest ) 
{ 


  {
#line 555
  if (*pDataLen != 40U) {
#line 556
    return (0);
  }
  {
#line 559
  _unmarshal_uint32(pData, pDataLen, & dest->version);
#line 560
  _unmarshal_uint32(pData, pDataLen, & dest->block_count);
#line 561
  _unmarshal_uint32(pData, pDataLen, & dest->unknown);
#line 562
  _unmarshal_uint32(pData, pDataLen, & dest->table_offset);
#line 563
  _unmarshal_uint64(pData, pDataLen, & dest->uncompressed_len);
#line 564
  _unmarshal_uint64(pData, pDataLen, & dest->compressed_len);
#line 565
  _unmarshal_uint64(pData, pDataLen, & dest->block_len);
  }
#line 568
  if (dest->version != 2U) {
#line 569
    return (0);
  }
#line 571
  return (1);
}
}
#line 588 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/chm_lib.c"
static int _unmarshal_lzxc_control_data(unsigned char **pData , unsigned int *pDataLen ,
                                        struct chmLzxcControlData *dest ) 
{ 
  int tmp ;

  {
#line 593
  if (*pDataLen < 24U) {
#line 594
    return (0);
  }
  {
#line 597
  _unmarshal_uint32(pData, pDataLen, & dest->size);
#line 598
  _unmarshal_char_array(pData, pDataLen, dest->signature, 4);
#line 599
  _unmarshal_uint32(pData, pDataLen, & dest->version);
#line 600
  _unmarshal_uint32(pData, pDataLen, & dest->resetInterval);
#line 601
  _unmarshal_uint32(pData, pDataLen, & dest->windowSize);
#line 602
  _unmarshal_uint32(pData, pDataLen, & dest->windowsPerReset);
  }
#line 604
  if (*pDataLen >= 28U) {
    {
#line 605
    _unmarshal_uint32(pData, pDataLen, & dest->unknown_18);
    }
  } else {
#line 607
    dest->unknown_18 = (UInt32 )0;
  }
#line 609
  if (dest->version == 2U) {
#line 611
    dest->resetInterval *= 32768U;
#line 612
    dest->windowSize *= 32768U;
  }
#line 614
  if (dest->windowSize == 0U) {
#line 615
    return (0);
  } else
#line 614
  if (dest->resetInterval == 0U) {
#line 615
    return (0);
  }
#line 618
  if (dest->windowSize == 1U) {
#line 619
    return (0);
  }
#line 620
  if (dest->resetInterval % (dest->windowSize / 2U) != 0U) {
#line 621
    return (0);
  }
  {
#line 624
  tmp = __builtin_memcmp(dest->signature, "LZXC", 4);
  }
#line 624
  if (tmp != 0) {
#line 625
    return (0);
  }
#line 627
  return (1);
}
}
#line 723
extern int ( /* missing proto */  pread64)() ;
#line 684 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/chm_lib.c"
static Int64 _chm_fetch_bytes(struct chmFile *h , UChar *buf , UInt64 os , Int64 len ) 
{ 
  Int64 readLen ;
  Int64 oldOs ;
  int tmp ;

  {
#line 689
  readLen = (Int64 )0;
#line 689
  oldOs = (Int64 )0;
#line 690
  if (h->fd == -1) {
#line 691
    return (readLen);
  }
  {
#line 693
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 693
    pthread_mutex_lock(& h->mutex);
    }
#line 693
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 723
  tmp = pread64(h->fd, buf, len, os);
#line 723
  readLen = (Int64 )tmp;
  }
  {
#line 741
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 741
    pthread_mutex_unlock(& h->mutex);
    }
#line 741
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 742
  return (readLen);
}
}
#line 750 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/chm_lib.c"
struct chmFile *chm_open(char const   *filename ) 
{ 
  unsigned char sbuffer[256] ;
  unsigned int sremain ;
  unsigned char *sbufpos ;
  struct chmFile *newHandle ;
  struct chmItsfHeader itsfHeader ;
  struct chmItspHeader itspHeader ;
  struct chmUnitInfo uiLzxc ;
  struct chmLzxcControlData ctlData ;
  void *tmp ;
  int tmp___0 ;
  Int64 tmp___1 ;
  int tmp___2 ;
  Int64 tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  LONGINT64 tmp___8 ;
  int tmp___9 ;
  LONGINT64 tmp___10 ;
  int tmp___11 ;

  {
  {
#line 756
  newHandle = (struct chmFile *)((void *)0);
#line 766
  tmp = malloc(sizeof(struct chmFile ));
#line 766
  newHandle = (struct chmFile *)tmp;
  }
#line 767
  if ((unsigned long )newHandle == (unsigned long )((void *)0)) {
#line 768
    return ((struct chmFile *)((void *)0));
  }
  {
#line 769
  newHandle->fd = -1;
#line 770
  newHandle->lzx_state = (struct LZXstate *)((void *)0);
#line 771
  newHandle->cache_blocks = (UChar **)((void *)0);
#line 772
  newHandle->cache_block_indices = (UInt64 *)((void *)0);
#line 773
  newHandle->cache_num_blocks = 0;
#line 803
  tmp___0 = open(filename, 0);
#line 803
  newHandle->fd = tmp___0;
  }
#line 803
  if (tmp___0 == -1) {
    {
#line 805
    free((void *)newHandle);
    }
#line 806
    return ((struct chmFile *)((void *)0));
  }
  {
#line 817
  pthread_mutex_init(& newHandle->mutex, (pthread_mutexattr_t const   *)((void *)0));
#line 818
  pthread_mutex_init(& newHandle->lzx_mutex, (pthread_mutexattr_t const   *)((void *)0));
#line 819
  pthread_mutex_init(& newHandle->cache_mutex, (pthread_mutexattr_t const   *)((void *)0));
#line 824
  sremain = 96U;
#line 825
  sbufpos = sbuffer;
#line 826
  tmp___1 = _chm_fetch_bytes(newHandle, sbuffer, (UInt64 )0, (Int64 )sremain);
  }
#line 826
  if (tmp___1 != (Int64 )sremain) {
    {
#line 829
    chm_close(newHandle);
    }
#line 830
    return ((struct chmFile *)((void *)0));
  } else {
    {
#line 826
    tmp___2 = _unmarshal_itsf_header(& sbufpos, & sremain, & itsfHeader);
    }
#line 826
    if (! tmp___2) {
      {
#line 829
      chm_close(newHandle);
      }
#line 830
      return ((struct chmFile *)((void *)0));
    }
  }
  {
#line 834
  newHandle->dir_offset = itsfHeader.dir_offset;
#line 835
  newHandle->dir_len = itsfHeader.dir_len;
#line 836
  newHandle->data_offset = itsfHeader.data_offset;
#line 839
  sremain = 84U;
#line 840
  sbufpos = sbuffer;
#line 841
  tmp___3 = _chm_fetch_bytes(newHandle, sbuffer, itsfHeader.dir_offset, (Int64 )sremain);
  }
#line 841
  if (tmp___3 != (Int64 )sremain) {
    {
#line 845
    chm_close(newHandle);
    }
#line 846
    return ((struct chmFile *)((void *)0));
  } else {
    {
#line 841
    tmp___4 = _unmarshal_itsp_header(& sbufpos, & sremain, & itspHeader);
    }
#line 841
    if (! tmp___4) {
      {
#line 845
      chm_close(newHandle);
      }
#line 846
      return ((struct chmFile *)((void *)0));
    }
  }
#line 850
  newHandle->dir_offset += (UInt64 )itspHeader.header_len;
#line 851
  newHandle->dir_len -= (UInt64 )itspHeader.header_len;
#line 852
  newHandle->index_root = itspHeader.index_root;
#line 853
  newHandle->index_head = itspHeader.index_head;
#line 854
  newHandle->block_len = itspHeader.block_len;
#line 859
  if (newHandle->index_root <= -1) {
#line 860
    newHandle->index_root = newHandle->index_head;
  }
  {
#line 863
  newHandle->compression_enabled = 1;
#line 893
  tmp___5 = chm_resolve_object(newHandle, _CHMU_RESET_TABLE, & newHandle->rt_unit);
  }
#line 893
  if (0 != tmp___5) {
#line 906
    newHandle->compression_enabled = 0;
  } else
#line 893
  if (newHandle->rt_unit.space == 1) {
#line 906
    newHandle->compression_enabled = 0;
  } else {
    {
#line 893
    tmp___6 = chm_resolve_object(newHandle, _CHMU_CONTENT, & newHandle->cn_unit);
    }
#line 893
    if (0 != tmp___6) {
#line 906
      newHandle->compression_enabled = 0;
    } else
#line 893
    if (newHandle->cn_unit.space == 1) {
#line 906
      newHandle->compression_enabled = 0;
    } else {
      {
#line 893
      tmp___7 = chm_resolve_object(newHandle, _CHMU_LZXC_CONTROLDATA, & uiLzxc);
      }
#line 893
      if (0 != tmp___7) {
#line 906
        newHandle->compression_enabled = 0;
      } else
#line 893
      if (uiLzxc.space == 1) {
#line 906
        newHandle->compression_enabled = 0;
      }
    }
  }
#line 910
  if (newHandle->compression_enabled) {
    {
#line 912
    sremain = 40U;
#line 913
    sbufpos = sbuffer;
#line 914
    tmp___8 = chm_retrieve_object(newHandle, & newHandle->rt_unit, sbuffer, (LONGUINT64 )0,
                                  (LONGINT64 )sremain);
    }
#line 914
    if (tmp___8 != (LONGINT64 )sremain) {
#line 919
      newHandle->compression_enabled = 0;
    } else {
      {
#line 914
      tmp___9 = _unmarshal_lzxc_reset_table(& sbufpos, & sremain, & newHandle->reset_table);
      }
#line 914
      if (! tmp___9) {
#line 919
        newHandle->compression_enabled = 0;
      }
    }
  }
#line 924
  if (newHandle->compression_enabled) {
#line 926
    sremain = (unsigned int )uiLzxc.length;
#line 927
    if (uiLzxc.length > (LONGUINT64 )sizeof(sbuffer)) {
      {
#line 929
      chm_close(newHandle);
      }
#line 930
      return ((struct chmFile *)((void *)0));
    }
    {
#line 933
    sbufpos = sbuffer;
#line 934
    tmp___10 = chm_retrieve_object(newHandle, & uiLzxc, sbuffer, (LONGUINT64 )0, (LONGINT64 )sremain);
    }
#line 934
    if (tmp___10 != (LONGINT64 )sremain) {
#line 939
      newHandle->compression_enabled = 0;
    } else {
      {
#line 934
      tmp___11 = _unmarshal_lzxc_control_data(& sbufpos, & sremain, & ctlData);
      }
#line 934
      if (! tmp___11) {
#line 939
        newHandle->compression_enabled = 0;
      }
    }
#line 942
    newHandle->window_size = ctlData.windowSize;
#line 943
    newHandle->reset_interval = ctlData.resetInterval;
#line 952
    newHandle->reset_blkcount = (newHandle->reset_interval / (newHandle->window_size / 2U)) * ctlData.windowsPerReset;
  }
  {
#line 959
  chm_set_param(newHandle, 0, 5);
  }
#line 962
  return (newHandle);
}
}
#line 966 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/chm_lib.c"
void chm_close(struct chmFile *h ) 
{ 
  int i ;

  {
#line 968
  if ((unsigned long )h != (unsigned long )((void *)0)) {
#line 970
    if (h->fd != -1) {
      {
#line 971
      close(h->fd);
      }
    }
    {
#line 972
    h->fd = -1;
#line 980
    pthread_mutex_destroy(& h->mutex);
#line 981
    pthread_mutex_destroy(& h->lzx_mutex);
#line 982
    pthread_mutex_destroy(& h->cache_mutex);
    }
#line 986
    if (h->lzx_state) {
      {
#line 987
      LZXteardown(h->lzx_state);
      }
    }
#line 988
    h->lzx_state = (struct LZXstate *)((void *)0);
#line 990
    if (h->cache_blocks) {
#line 993
      i = 0;
      {
#line 993
      while (1) {
        while_continue: /* CIL Label */ ;
#line 993
        if (! (i < h->cache_num_blocks)) {
#line 993
          goto while_break;
        }
#line 995
        if (*(h->cache_blocks + i)) {
          {
#line 996
          free((void *)*(h->cache_blocks + i));
          }
        }
#line 993
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 998
      free((void *)h->cache_blocks);
#line 999
      h->cache_blocks = (UChar **)((void *)0);
      }
    }
#line 1002
    if (h->cache_block_indices) {
      {
#line 1003
      free((void *)h->cache_block_indices);
      }
    }
    {
#line 1004
    h->cache_block_indices = (UInt64 *)((void *)0);
#line 1006
    free((void *)h);
    }
  }
#line 1008
  return;
}
}
#line 1019 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/chm_lib.c"
void chm_set_param(struct chmFile *h , int paramType , int paramVal ) 
{ 
  UChar **newBlocks ;
  UInt64 *newIndices ;
  int i ;
  void *tmp ;
  void *tmp___0 ;
  int newSlot ;

  {
  {
#line 1025
  if (paramType == 0) {
#line 1025
    goto case_0;
  }
#line 1080
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1026
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1026
    pthread_mutex_lock(& h->cache_mutex);
    }
#line 1026
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1027
  if (paramVal != h->cache_num_blocks) {
    {
#line 1034
    tmp = malloc((unsigned long )paramVal * sizeof(UChar *));
#line 1034
    newBlocks = (UChar **)tmp;
    }
#line 1035
    if ((unsigned long )newBlocks == (unsigned long )((void *)0)) {
#line 1035
      return;
    }
    {
#line 1036
    tmp___0 = malloc((unsigned long )paramVal * sizeof(UInt64 ));
#line 1036
    newIndices = (UInt64 *)tmp___0;
    }
#line 1037
    if ((unsigned long )newIndices == (unsigned long )((void *)0)) {
      {
#line 1037
      free((void *)newBlocks);
      }
#line 1037
      return;
    }
#line 1038
    i = 0;
    {
#line 1038
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1038
      if (! (i < paramVal)) {
#line 1038
        goto while_break___0;
      }
#line 1040
      *(newBlocks + i) = (UChar *)((void *)0);
#line 1041
      *(newIndices + i) = (UInt64 )0;
#line 1038
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1045
    if (h->cache_blocks) {
#line 1047
      i = 0;
      {
#line 1047
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1047
        if (! (i < h->cache_num_blocks)) {
#line 1047
          goto while_break___1;
        }
#line 1049
        newSlot = (int )(*(h->cache_block_indices + i) % (unsigned long )paramVal);
#line 1051
        if (*(h->cache_blocks + i)) {
#line 1054
          if (*(newBlocks + newSlot)) {
            {
#line 1056
            free((void *)*(h->cache_blocks + i));
#line 1057
            *(h->cache_blocks + i) = (UChar *)((void *)0);
            }
          } else {
#line 1061
            *(newBlocks + newSlot) = *(h->cache_blocks + i);
#line 1062
            *(newIndices + newSlot) = *(h->cache_block_indices + i);
          }
        }
#line 1047
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 1068
      free((void *)h->cache_blocks);
#line 1069
      free((void *)h->cache_block_indices);
      }
    }
#line 1073
    h->cache_blocks = newBlocks;
#line 1074
    h->cache_block_indices = newIndices;
#line 1075
    h->cache_num_blocks = paramVal;
  }
  {
#line 1077
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 1077
    pthread_mutex_unlock(& h->cache_mutex);
    }
#line 1077
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1078
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1081
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1083
  return;
}
}
#line 1090 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/chm_lib.c"
static void _chm_skip_cword(UChar **pEntry ) 
{ 
  UChar *tmp ;

  {
  {
#line 1092
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1092
    tmp = *pEntry;
#line 1092
    (*pEntry) ++;
#line 1092
    if (! ((int )*tmp >= 128)) {
#line 1092
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1094
  return;
}
}
#line 1097 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/chm_lib.c"
static void _chm_skip_PMGL_entry_data(UChar **pEntry ) 
{ 


  {
  {
#line 1099
  _chm_skip_cword(pEntry);
#line 1100
  _chm_skip_cword(pEntry);
#line 1101
  _chm_skip_cword(pEntry);
  }
#line 1102
  return;
}
}
#line 1105 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/chm_lib.c"
static UInt64 _chm_parse_cword(UChar **pEntry ) 
{ 
  UInt64 accum ;
  UChar temp ;
  UChar *tmp ;

  {
#line 1107
  accum = (UInt64 )0;
  {
#line 1109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1109
    tmp = *pEntry;
#line 1109
    (*pEntry) ++;
#line 1109
    temp = *tmp;
#line 1109
    if (! ((int )temp >= 128)) {
#line 1109
      goto while_break;
    }
#line 1111
    accum <<= 7;
#line 1112
    accum += (UInt64 )((int )temp & 127);
  }
  while_break: /* CIL Label */ ;
  }
#line 1115
  return ((accum << 7) + (UInt64 )temp);
}
}
#line 1119 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/chm_lib.c"
static int _chm_parse_UTF8(UChar **pEntry , UInt64 count , char *path ) 
{ 
  char *tmp ;
  UChar *tmp___0 ;

  {
  {
#line 1127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1127
    if (! (count != 0UL)) {
#line 1127
      goto while_break;
    }
#line 1129
    tmp = path;
#line 1129
    path ++;
#line 1129
    tmp___0 = *pEntry;
#line 1129
    (*pEntry) ++;
#line 1129
    *tmp = (char )*tmp___0;
#line 1130
    count --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1133
  *path = (char )'\000';
#line 1134
  return (1);
}
}
#line 1138 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/chm_lib.c"
static int _chm_parse_PMGL_entry(UChar **pEntry , struct chmUnitInfo *ui ) 
{ 
  UInt64 strLen ;
  int tmp ;
  UInt64 tmp___0 ;
  UInt64 tmp___1 ;
  UInt64 tmp___2 ;

  {
  {
#line 1143
  strLen = _chm_parse_cword(pEntry);
  }
#line 1144
  if (strLen > 512UL) {
#line 1145
    return (0);
  }
  {
#line 1148
  tmp = _chm_parse_UTF8(pEntry, strLen, ui->path);
  }
#line 1148
  if (! tmp) {
#line 1149
    return (0);
  }
  {
#line 1152
  tmp___0 = _chm_parse_cword(pEntry);
#line 1152
  ui->space = (int )tmp___0;
#line 1153
  tmp___1 = _chm_parse_cword(pEntry);
#line 1153
  ui->start = (LONGUINT64 )tmp___1;
#line 1154
  tmp___2 = _chm_parse_cword(pEntry);
#line 1154
  ui->length = (LONGUINT64 )tmp___2;
  }
#line 1155
  return (1);
}
}
#line 1159 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/chm_lib.c"
static UChar *_chm_find_in_PMGL(UChar *page_buf , UInt32 block_len , char const   *objPath ) 
{ 
  struct chmPmglHeader header ;
  unsigned int hremain ;
  UChar *end ;
  UChar *cur ;
  UChar *temp ;
  UInt64 strLen ;
  char buffer[513] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1175
  cur = page_buf;
#line 1176
  hremain = 20U;
#line 1177
  tmp = _unmarshal_pmgl_header(& cur, & hremain, & header);
  }
#line 1177
  if (! tmp) {
#line 1178
    return ((UChar *)((void *)0));
  }
#line 1179
  end = (page_buf + block_len) - header.free_space;
  {
#line 1182
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1182
    if (! ((unsigned long )cur < (unsigned long )end)) {
#line 1182
      goto while_break;
    }
    {
#line 1185
    temp = cur;
#line 1186
    strLen = _chm_parse_cword(& cur);
    }
#line 1187
    if (strLen > 512UL) {
#line 1188
      return ((UChar *)((void *)0));
    }
    {
#line 1189
    tmp___0 = _chm_parse_UTF8(& cur, strLen, buffer);
    }
#line 1189
    if (! tmp___0) {
#line 1190
      return ((UChar *)((void *)0));
    }
    {
#line 1193
    tmp___1 = strcasecmp((char const   *)(buffer), objPath);
    }
#line 1193
    if (! tmp___1) {
#line 1194
      return (temp);
    }
    {
#line 1196
    _chm_skip_PMGL_entry_data(& cur);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1199
  return ((UChar *)((void *)0));
}
}
#line 1203 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/chm_lib.c"
static Int32 _chm_find_in_PMGI(UChar *page_buf , UInt32 block_len , char const   *objPath ) 
{ 
  struct chmPmgiHeader header ;
  unsigned int hremain ;
  int page ;
  UChar *end ;
  UChar *cur ;
  UInt64 strLen ;
  char buffer[513] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  UInt64 tmp___2 ;

  {
  {
#line 1212
  page = -1;
#line 1219
  cur = page_buf;
#line 1220
  hremain = 8U;
#line 1221
  tmp = _unmarshal_pmgi_header(& cur, & hremain, & header);
  }
#line 1221
  if (! tmp) {
#line 1222
    return (-1);
  }
#line 1223
  end = (page_buf + block_len) - header.free_space;
  {
#line 1226
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1226
    if (! ((unsigned long )cur < (unsigned long )end)) {
#line 1226
      goto while_break;
    }
    {
#line 1229
    strLen = _chm_parse_cword(& cur);
    }
#line 1230
    if (strLen > 512UL) {
#line 1231
      return (-1);
    }
    {
#line 1232
    tmp___0 = _chm_parse_UTF8(& cur, strLen, buffer);
    }
#line 1232
    if (! tmp___0) {
#line 1233
      return (-1);
    }
    {
#line 1236
    tmp___1 = strcasecmp((char const   *)(buffer), objPath);
    }
#line 1236
    if (tmp___1 > 0) {
#line 1237
      return (page);
    }
    {
#line 1240
    tmp___2 = _chm_parse_cword(& cur);
#line 1240
    page = (int )tmp___2;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1243
  return (page);
}
}
#line 1247 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/chm_lib.c"
int chm_resolve_object(struct chmFile *h , char const   *objPath , struct chmUnitInfo *ui ) 
{ 
  Int32 curPage ;
  UChar *page_buf ;
  void *tmp ;
  Int64 tmp___0 ;
  UChar *pEntry ;
  UChar *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 1259
  tmp = malloc((size_t )h->block_len);
#line 1259
  page_buf = (UChar *)tmp;
  }
#line 1260
  if ((unsigned long )page_buf == (unsigned long )((void *)0)) {
#line 1261
    return (1);
  }
#line 1264
  curPage = h->index_root;
  {
#line 1267
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1267
    if (! (curPage != -1)) {
#line 1267
      goto while_break;
    }
    {
#line 1271
    tmp___0 = _chm_fetch_bytes(h, page_buf, h->dir_offset + (UInt64 )curPage * (UInt64 )h->block_len,
                               (Int64 )h->block_len);
    }
#line 1271
    if (tmp___0 != (Int64 )h->block_len) {
      {
#line 1275
      free((void *)page_buf);
      }
#line 1276
      return (1);
    }
    {
#line 1280
    tmp___3 = __builtin_memcmp(page_buf, _chm_pmgl_marker, 4);
    }
#line 1280
    if (tmp___3 == 0) {
      {
#line 1283
      tmp___1 = _chm_find_in_PMGL(page_buf, h->block_len, objPath);
#line 1283
      pEntry = tmp___1;
      }
#line 1286
      if ((unsigned long )pEntry == (unsigned long )((void *)0)) {
        {
#line 1288
        free((void *)page_buf);
        }
#line 1289
        return (1);
      }
      {
#line 1293
      _chm_parse_PMGL_entry(& pEntry, ui);
#line 1294
      free((void *)page_buf);
      }
#line 1295
      return (0);
    } else {
      {
#line 1299
      tmp___2 = __builtin_memcmp(page_buf, _chm_pmgi_marker, 4);
      }
#line 1299
      if (tmp___2 == 0) {
        {
#line 1300
        curPage = _chm_find_in_PMGI(page_buf, h->block_len, objPath);
        }
      } else {
        {
#line 1305
        free((void *)page_buf);
        }
#line 1306
        return (1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1311
  free((void *)page_buf);
  }
#line 1312
  return (1);
}
}
#line 1320 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/chm_lib.c"
static int _chm_get_cmpblock_bounds(struct chmFile *h , UInt64 block , UInt64 *start ,
                                    Int64 *len ) 
{ 
  UChar buffer[8] ;
  UChar *dummy ;
  unsigned int remain ;
  Int64 tmp ;
  int tmp___0 ;
  Int64 tmp___1 ;
  int tmp___2 ;
  Int64 tmp___3 ;
  int tmp___4 ;

  {
#line 1329
  if (block < (UInt64 )(h->reset_table.block_count - 1U)) {
    {
#line 1332
    dummy = buffer;
#line 1333
    remain = 8U;
#line 1334
    tmp = _chm_fetch_bytes(h, buffer, ((h->data_offset + (UInt64 )h->rt_unit.start) + (UInt64 )h->reset_table.table_offset) + block * 8UL,
                           (Int64 )remain);
    }
#line 1334
    if (tmp != (Int64 )remain) {
#line 1341
      return (0);
    } else {
      {
#line 1334
      tmp___0 = _unmarshal_uint64(& dummy, & remain, start);
      }
#line 1334
      if (! tmp___0) {
#line 1341
        return (0);
      }
    }
    {
#line 1344
    dummy = buffer;
#line 1345
    remain = 8U;
#line 1346
    tmp___1 = _chm_fetch_bytes(h, buffer, (((h->data_offset + (UInt64 )h->rt_unit.start) + (UInt64 )h->reset_table.table_offset) + block * 8UL) + 8UL,
                               (Int64 )remain);
    }
#line 1346
    if (tmp___1 != (Int64 )remain) {
#line 1353
      return (0);
    } else {
      {
#line 1346
      tmp___2 = _unmarshal_int64(& dummy, & remain, len);
      }
#line 1346
      if (! tmp___2) {
#line 1353
        return (0);
      }
    }
  } else {
    {
#line 1360
    dummy = buffer;
#line 1361
    remain = 8U;
#line 1362
    tmp___3 = _chm_fetch_bytes(h, buffer, ((h->data_offset + (UInt64 )h->rt_unit.start) + (UInt64 )h->reset_table.table_offset) + block * 8UL,
                               (Int64 )remain);
    }
#line 1362
    if (tmp___3 != (Int64 )remain) {
#line 1369
      return (0);
    } else {
      {
#line 1362
      tmp___4 = _unmarshal_uint64(& dummy, & remain, start);
      }
#line 1362
      if (! tmp___4) {
#line 1369
        return (0);
      }
    }
#line 1371
    *len = (Int64 )h->reset_table.compressed_len;
  }
#line 1375
  *len = (Int64 )((UInt64 )*len - *start);
#line 1376
  *start = (UInt64 )((LONGUINT64 )*start + ((LONGUINT64 )h->data_offset + h->cn_unit.start));
#line 1378
  return (1);
}
}
#line 1382 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/chm_lib.c"
static Int64 _chm_decompress_block(struct chmFile *h , UInt64 block , UChar **ubuffer ) 
{ 
  UChar *cbuffer ;
  void *tmp ;
  UInt64 cmpStart ;
  Int64 cmpLen ;
  int indexSlot ;
  UChar *lbuffer ;
  UInt32 blockAlign ;
  UInt32 i ;
  UInt32 curBlockIdx ;
  void *tmp___0 ;
  int tmp___1 ;
  Int64 tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  Int64 tmp___6 ;
  int tmp___7 ;

  {
  {
#line 1386
  tmp = malloc((size_t )((unsigned int )h->reset_table.block_len + 6144U));
#line 1386
  cbuffer = (UChar *)tmp;
#line 1391
  blockAlign = (UInt32 )(block % (unsigned long )h->reset_blkcount);
  }
#line 1394
  if ((unsigned long )cbuffer == (unsigned long )((void *)0)) {
#line 1395
    return ((Int64 )-1);
  }
#line 1398
  if (block - (UInt64 )blockAlign <= (UInt64 )h->lzx_last_block) {
#line 1398
    if (block >= (UInt64 )h->lzx_last_block) {
#line 1400
      blockAlign = (UInt32 )(block - (UInt64 )h->lzx_last_block);
    }
  }
#line 1403
  if (blockAlign != 0U) {
#line 1406
    i = blockAlign;
    {
#line 1406
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1406
      if (! (i > 0U)) {
#line 1406
        goto while_break;
      }
#line 1408
      curBlockIdx = (UInt32 )(block - (UInt64 )i);
#line 1411
      if ((UInt32 )h->lzx_last_block != curBlockIdx) {
#line 1413
        if (curBlockIdx % h->reset_blkcount == 0U) {
          {
#line 1418
          LZXreset(h->lzx_state);
          }
        }
#line 1421
        indexSlot = (int )(curBlockIdx % (unsigned int )h->cache_num_blocks);
#line 1422
        if (! *(h->cache_blocks + indexSlot)) {
          {
#line 1423
          tmp___0 = malloc((size_t )((unsigned int )h->reset_table.block_len));
#line 1423
          *(h->cache_blocks + indexSlot) = (UChar *)tmp___0;
          }
        }
#line 1424
        if (! *(h->cache_blocks + indexSlot)) {
          {
#line 1426
          free((void *)cbuffer);
          }
#line 1427
          return ((Int64 )-1);
        }
        {
#line 1429
        *(h->cache_block_indices + indexSlot) = (UInt64 )curBlockIdx;
#line 1430
        lbuffer = *(h->cache_blocks + indexSlot);
#line 1436
        tmp___1 = _chm_get_cmpblock_bounds(h, (UInt64 )curBlockIdx, & cmpStart, & cmpLen);
        }
#line 1436
        if (tmp___1) {
#line 1436
          if (cmpLen < 0L) {
            {
#line 1446
            free((void *)cbuffer);
            }
#line 1447
            return ((Int64 )0);
          } else
#line 1436
          if ((UInt64 )cmpLen > h->reset_table.block_len + 6144UL) {
            {
#line 1446
            free((void *)cbuffer);
            }
#line 1447
            return ((Int64 )0);
          } else {
            {
#line 1436
            tmp___2 = _chm_fetch_bytes(h, cbuffer, cmpStart, cmpLen);
            }
#line 1436
            if (tmp___2 != cmpLen) {
              {
#line 1446
              free((void *)cbuffer);
              }
#line 1447
              return ((Int64 )0);
            } else {
              {
#line 1436
              tmp___3 = LZXdecompress(h->lzx_state, cbuffer, lbuffer, (int )cmpLen,
                                      (int )h->reset_table.block_len);
              }
#line 1436
              if (tmp___3 != 0) {
                {
#line 1446
                free((void *)cbuffer);
                }
#line 1447
                return ((Int64 )0);
              }
            }
          }
        } else {
          {
#line 1446
          free((void *)cbuffer);
          }
#line 1447
          return ((Int64 )0);
        }
#line 1450
        h->lzx_last_block = (int )curBlockIdx;
      }
#line 1406
      i --;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 1456
  if (block % (unsigned long )h->reset_blkcount == 0UL) {
    {
#line 1461
    LZXreset(h->lzx_state);
    }
  }
#line 1466
  indexSlot = (int )(block % (unsigned long )h->cache_num_blocks);
#line 1467
  if (! *(h->cache_blocks + indexSlot)) {
    {
#line 1468
    tmp___4 = malloc((size_t )((unsigned int )h->reset_table.block_len));
#line 1468
    *(h->cache_blocks + indexSlot) = (UChar *)tmp___4;
    }
  }
#line 1469
  if (! *(h->cache_blocks + indexSlot)) {
    {
#line 1471
    free((void *)cbuffer);
    }
#line 1472
    return ((Int64 )-1);
  }
  {
#line 1474
  *(h->cache_block_indices + indexSlot) = block;
#line 1475
  lbuffer = *(h->cache_blocks + indexSlot);
#line 1476
  *ubuffer = lbuffer;
#line 1482
  tmp___5 = _chm_get_cmpblock_bounds(h, block, & cmpStart, & cmpLen);
  }
#line 1482
  if (tmp___5) {
    {
#line 1482
    tmp___6 = _chm_fetch_bytes(h, cbuffer, cmpStart, cmpLen);
    }
#line 1482
    if (tmp___6 != cmpLen) {
      {
#line 1490
      free((void *)cbuffer);
      }
#line 1491
      return ((Int64 )0);
    } else {
      {
#line 1482
      tmp___7 = LZXdecompress(h->lzx_state, cbuffer, lbuffer, (int )cmpLen, (int )h->reset_table.block_len);
      }
#line 1482
      if (tmp___7 != 0) {
        {
#line 1490
        free((void *)cbuffer);
        }
#line 1491
        return ((Int64 )0);
      }
    }
  } else {
    {
#line 1490
    free((void *)cbuffer);
    }
#line 1491
    return ((Int64 )0);
  }
  {
#line 1493
  h->lzx_last_block = (int )block;
#line 1498
  free((void *)cbuffer);
  }
#line 1499
  return ((Int64 )h->reset_table.block_len);
}
}
#line 1503 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/chm_lib.c"
static Int64 _chm_decompress_region(struct chmFile *h , UChar *buf , UInt64 start ,
                                    Int64 len ) 
{ 
  UInt64 nBlock ;
  UInt64 nOffset ;
  UInt64 nLen ;
  UInt64 gotLen ;
  UChar *ubuffer ;
  int window_size ;
  int tmp ;
  Int64 tmp___0 ;

  {
#line 1513
  if (len <= 0L) {
#line 1514
    return ((Int64 )0);
  }
#line 1517
  nBlock = start / h->reset_table.block_len;
#line 1518
  nOffset = start % h->reset_table.block_len;
#line 1519
  nLen = (UInt64 )len;
#line 1520
  if (nLen > h->reset_table.block_len - nOffset) {
#line 1521
    nLen = h->reset_table.block_len - nOffset;
  }
  {
#line 1524
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1524
    pthread_mutex_lock(& h->lzx_mutex);
    }
#line 1524
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1525
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1525
    pthread_mutex_lock(& h->cache_mutex);
    }
#line 1525
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1526
  if (*(h->cache_block_indices + nBlock % (unsigned long )h->cache_num_blocks) == nBlock) {
#line 1526
    if ((unsigned long )*(h->cache_blocks + nBlock % (unsigned long )h->cache_num_blocks) != (unsigned long )((void *)0)) {
      {
#line 1529
      __builtin_memcpy((void *)buf, (void const   *)(*(h->cache_blocks + nBlock % (unsigned long )h->cache_num_blocks) + nOffset),
                       (unsigned long )((unsigned int )nLen));
      }
      {
#line 1532
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 1532
        pthread_mutex_unlock(& h->cache_mutex);
        }
#line 1532
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 1533
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 1533
        pthread_mutex_unlock(& h->lzx_mutex);
        }
#line 1533
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1534
      return ((Int64 )nLen);
    }
  }
  {
#line 1536
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 1536
    pthread_mutex_unlock(& h->cache_mutex);
    }
#line 1536
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1539
  if (! h->lzx_state) {
    {
#line 1541
    tmp = ffs((int )h->window_size);
#line 1541
    window_size = tmp - 1;
#line 1542
    h->lzx_last_block = -1;
#line 1543
    h->lzx_state = LZXinit(window_size);
    }
  }
  {
#line 1547
  tmp___0 = _chm_decompress_block(h, nBlock, & ubuffer);
#line 1547
  gotLen = (UInt64 )tmp___0;
  }
#line 1548
  if (gotLen < nLen) {
#line 1549
    nLen = gotLen;
  }
  {
#line 1550
  __builtin_memcpy((void *)buf, (void const   *)(ubuffer + nOffset), (unsigned long )((unsigned int )nLen));
  }
  {
#line 1551
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 1551
    pthread_mutex_unlock(& h->lzx_mutex);
    }
#line 1551
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 1552
  return ((Int64 )nLen);
}
}
#line 1556 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/chm_lib.c"
LONGINT64 chm_retrieve_object(struct chmFile *h , struct chmUnitInfo *ui , unsigned char *buf ,
                              LONGUINT64 addr , LONGINT64 len ) 
{ 
  Int64 tmp ;
  Int64 swath ;
  Int64 total ;

  {
#line 1563
  if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 1564
    return ((LONGINT64 )((Int64 )0));
  }
#line 1567
  if (addr < 0ULL) {
#line 1568
    return ((LONGINT64 )((Int64 )0));
  } else
#line 1567
  if (addr >= ui->length) {
#line 1568
    return ((LONGINT64 )((Int64 )0));
  }
#line 1571
  if (addr + (LONGUINT64 )len > ui->length) {
#line 1572
    len = (LONGINT64 )(ui->length - addr);
  }
#line 1575
  if (ui->space == 0) {
    {
#line 1578
    tmp = _chm_fetch_bytes(h, buf, (h->data_offset + (UInt64 )ui->start) + (UInt64 )addr,
                           (Int64 )len);
    }
#line 1578
    return ((LONGINT64 )tmp);
  } else {
#line 1587
    swath = (Int64 )0;
#line 1587
    total = (Int64 )0;
#line 1590
    if (! h->compression_enabled) {
#line 1591
      return ((LONGINT64 )total);
    }
    {
#line 1593
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1596
      swath = _chm_decompress_region(h, buf, (UInt64 )(ui->start + addr), (Int64 )len);
      }
#line 1599
      if (swath == 0L) {
#line 1600
        return ((LONGINT64 )total);
      }
#line 1603
      total += swath;
#line 1604
      len -= (LONGINT64 )swath;
#line 1605
      addr += (LONGUINT64 )swath;
#line 1606
      buf += swath;
#line 1593
      if (! (len != 0LL)) {
#line 1593
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 1610
    return ((LONGINT64 )total);
  }
}
}
#line 1615 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/chm_lib.c"
int chm_enumerate(struct chmFile *h , int what , int (*e)(struct chmFile *h , struct chmUnitInfo *ui ,
                                                          void *context ) , void *context ) 
{ 
  Int32 curPage ;
  UChar *page_buf ;
  void *tmp ;
  struct chmPmglHeader header ;
  UChar *end ;
  UChar *cur ;
  unsigned int lenRemain ;
  UInt64 ui_path_len ;
  struct chmUnitInfo ui ;
  int type_bits ;
  int filter_bits ;
  Int64 tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  int status ;
  int tmp___4 ;

  {
  {
#line 1624
  tmp = malloc((size_t )h->block_len);
#line 1624
  page_buf = (UChar *)tmp;
#line 1633
  type_bits = what & 7;
#line 1634
  filter_bits = what & 248;
  }
#line 1636
  if ((unsigned long )page_buf == (unsigned long )((void *)0)) {
#line 1637
    return (0);
  }
#line 1640
  curPage = h->index_head;
  {
#line 1643
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1643
    if (! (curPage != -1)) {
#line 1643
      goto while_break;
    }
    {
#line 1647
    tmp___0 = _chm_fetch_bytes(h, page_buf, h->dir_offset + (UInt64 )curPage * (UInt64 )h->block_len,
                               (Int64 )h->block_len);
    }
#line 1647
    if (tmp___0 != (Int64 )h->block_len) {
      {
#line 1652
      free((void *)page_buf);
      }
#line 1653
      return (0);
    }
    {
#line 1657
    cur = page_buf;
#line 1658
    lenRemain = 20U;
#line 1659
    tmp___1 = _unmarshal_pmgl_header(& cur, & lenRemain, & header);
    }
#line 1659
    if (! tmp___1) {
      {
#line 1661
      free((void *)page_buf);
      }
#line 1662
      return (0);
    }
#line 1664
    end = (page_buf + h->block_len) - header.free_space;
    {
#line 1667
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1667
      if (! ((unsigned long )cur < (unsigned long )end)) {
#line 1667
        goto while_break___0;
      }
      {
#line 1669
      ui.flags = 0;
#line 1671
      tmp___2 = _chm_parse_PMGL_entry(& cur, & ui);
      }
#line 1671
      if (! tmp___2) {
        {
#line 1673
        free((void *)page_buf);
        }
#line 1674
        return (0);
      }
      {
#line 1678
      tmp___3 = __builtin_strlen((char const   *)(ui.path));
#line 1678
      ui_path_len = tmp___3 - 1UL;
      }
#line 1681
      if ((int )ui.path[ui_path_len] == 47) {
#line 1682
        ui.flags |= 16;
      }
#line 1685
      if ((int )ui.path[ui_path_len] != 47) {
#line 1686
        ui.flags |= 8;
      }
#line 1689
      if ((int )ui.path[0] == 47) {
#line 1693
        if ((int )ui.path[1] == 35) {
#line 1694
          ui.flags |= 4;
        } else
#line 1693
        if ((int )ui.path[1] == 36) {
#line 1694
          ui.flags |= 4;
        } else {
#line 1696
          ui.flags |= 1;
        }
      } else {
#line 1699
        ui.flags |= 2;
      }
#line 1701
      if (! (type_bits & ui.flags)) {
#line 1702
        goto while_continue___0;
      }
#line 1704
      if (filter_bits) {
#line 1704
        if (! (filter_bits & ui.flags)) {
#line 1705
          goto while_continue___0;
        }
      }
      {
#line 1709
      tmp___4 = (*e)(h, & ui, context);
#line 1709
      status = tmp___4;
      }
      {
#line 1712
      if (status == 0) {
#line 1712
        goto case_0;
      }
#line 1715
      if (status == 1) {
#line 1715
        goto case_1;
      }
#line 1717
      if (status == 2) {
#line 1717
        goto case_2;
      }
#line 1720
      goto switch_default;
      case_0: /* CIL Label */ 
      {
#line 1713
      free((void *)page_buf);
      }
#line 1714
      return (0);
      case_1: /* CIL Label */ 
#line 1716
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 1718
      free((void *)page_buf);
      }
#line 1719
      return (1);
      switch_default: /* CIL Label */ 
#line 1721
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1727
    curPage = header.block_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1730
  free((void *)page_buf);
  }
#line 1731
  return (1);
}
}
#line 1734 "/home/june/repo/benchmarks/collector/temp/chmlib-0.40a/src/chm_lib.c"
int chm_enumerate_dir(struct chmFile *h , char const   *prefix , int what , int (*e)(struct chmFile *h ,
                                                                                     struct chmUnitInfo *ui ,
                                                                                     void *context ) ,
                      void *context ) 
{ 
  Int32 curPage ;
  UChar *page_buf ;
  void *tmp ;
  struct chmPmglHeader header ;
  UChar *end ;
  UChar *cur ;
  unsigned int lenRemain ;
  int it_has_begun ;
  struct chmUnitInfo ui ;
  int type_bits ;
  int filter_bits ;
  UInt64 ui_path_len ;
  char prefixRectified[513] ;
  int prefixLen ;
  char lastPath[513] ;
  int lastPathLen ;
  unsigned long tmp___0 ;
  Int64 tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  unsigned long tmp___7 ;
  unsigned long tmp___8 ;
  int status ;
  int tmp___9 ;

  {
  {
#line 1748
  tmp = malloc((size_t )h->block_len);
#line 1748
  page_buf = (UChar *)tmp;
#line 1755
  it_has_begun = 0;
#line 1759
  type_bits = what & 7;
#line 1760
  filter_bits = what & 248;
  }
#line 1769
  if ((unsigned long )page_buf == (unsigned long )((void *)0)) {
#line 1770
    return (0);
  }
  {
#line 1773
  curPage = h->index_head;
#line 1776
  strncpy((char */* __restrict  */)(prefixRectified), (char const   */* __restrict  */)prefix,
          (size_t )512);
#line 1777
  prefixRectified[512] = (char )'\000';
#line 1778
  tmp___0 = __builtin_strlen((char const   *)(prefixRectified));
#line 1778
  prefixLen = (int )tmp___0;
  }
#line 1779
  if (prefixLen != 0) {
#line 1781
    if ((int )prefixRectified[prefixLen - 1] != 47) {
#line 1783
      prefixRectified[prefixLen] = (char )'/';
#line 1784
      prefixRectified[prefixLen + 1] = (char )'\000';
#line 1785
      prefixLen ++;
    }
  }
#line 1788
  lastPath[0] = (char )'\000';
#line 1789
  lastPathLen = -1;
  {
#line 1792
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1792
    if (! (curPage != -1)) {
#line 1792
      goto while_break;
    }
    {
#line 1796
    tmp___1 = _chm_fetch_bytes(h, page_buf, h->dir_offset + (UInt64 )curPage * (UInt64 )h->block_len,
                               (Int64 )h->block_len);
    }
#line 1796
    if (tmp___1 != (Int64 )h->block_len) {
      {
#line 1801
      free((void *)page_buf);
      }
#line 1802
      return (0);
    }
    {
#line 1806
    cur = page_buf;
#line 1807
    lenRemain = 20U;
#line 1808
    tmp___2 = _unmarshal_pmgl_header(& cur, & lenRemain, & header);
    }
#line 1808
    if (! tmp___2) {
      {
#line 1810
      free((void *)page_buf);
      }
#line 1811
      return (0);
    }
#line 1813
    end = (page_buf + h->block_len) - header.free_space;
    {
#line 1816
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1816
      if (! ((unsigned long )cur < (unsigned long )end)) {
#line 1816
        goto while_break___0;
      }
      {
#line 1818
      ui.flags = 0;
#line 1820
      tmp___3 = _chm_parse_PMGL_entry(& cur, & ui);
      }
#line 1820
      if (! tmp___3) {
        {
#line 1822
        free((void *)page_buf);
        }
#line 1823
        return (0);
      }
#line 1827
      if (! it_has_begun) {
#line 1829
        if (ui.length == 0ULL) {
          {
#line 1829
          tmp___4 = strncasecmp((char const   *)(ui.path), (char const   *)(prefixRectified),
                                (size_t )prefixLen);
          }
#line 1829
          if (tmp___4 == 0) {
#line 1830
            it_has_begun = 1;
          } else {
#line 1832
            goto while_continue___0;
          }
        } else {
#line 1832
          goto while_continue___0;
        }
#line 1834
        if ((int )ui.path[prefixLen] == 0) {
#line 1835
          goto while_continue___0;
        }
      } else {
        {
#line 1841
        tmp___5 = strncasecmp((char const   *)(ui.path), (char const   *)(prefixRectified),
                              (size_t )prefixLen);
        }
#line 1841
        if (tmp___5 != 0) {
          {
#line 1843
          free((void *)page_buf);
          }
#line 1844
          return (1);
        }
      }
#line 1849
      if (lastPathLen != -1) {
        {
#line 1851
        tmp___6 = strncasecmp((char const   *)(ui.path), (char const   *)(lastPath),
                              (size_t )lastPathLen);
        }
#line 1851
        if (tmp___6 == 0) {
#line 1852
          goto while_continue___0;
        }
      }
      {
#line 1854
      strncpy((char */* __restrict  */)(lastPath), (char const   */* __restrict  */)(ui.path),
              (size_t )512);
#line 1855
      lastPath[512] = (char )'\000';
#line 1856
      tmp___7 = __builtin_strlen((char const   *)(lastPath));
#line 1856
      lastPathLen = (int )tmp___7;
#line 1859
      tmp___8 = __builtin_strlen((char const   *)(ui.path));
#line 1859
      ui_path_len = tmp___8 - 1UL;
      }
#line 1862
      if ((int )ui.path[ui_path_len] == 47) {
#line 1863
        ui.flags |= 16;
      }
#line 1866
      if ((int )ui.path[ui_path_len] != 47) {
#line 1867
        ui.flags |= 8;
      }
#line 1870
      if ((int )ui.path[0] == 47) {
#line 1874
        if ((int )ui.path[1] == 35) {
#line 1875
          ui.flags |= 4;
        } else
#line 1874
        if ((int )ui.path[1] == 36) {
#line 1875
          ui.flags |= 4;
        } else {
#line 1877
          ui.flags |= 1;
        }
      } else {
#line 1880
        ui.flags |= 2;
      }
#line 1882
      if (! (type_bits & ui.flags)) {
#line 1883
        goto while_continue___0;
      }
#line 1885
      if (filter_bits) {
#line 1885
        if (! (filter_bits & ui.flags)) {
#line 1886
          goto while_continue___0;
        }
      }
      {
#line 1890
      tmp___9 = (*e)(h, & ui, context);
#line 1890
      status = tmp___9;
      }
      {
#line 1893
      if (status == 0) {
#line 1893
        goto case_0;
      }
#line 1896
      if (status == 1) {
#line 1896
        goto case_1;
      }
#line 1898
      if (status == 2) {
#line 1898
        goto case_2;
      }
#line 1901
      goto switch_default;
      case_0: /* CIL Label */ 
      {
#line 1894
      free((void *)page_buf);
      }
#line 1895
      return (0);
      case_1: /* CIL Label */ 
#line 1897
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 1899
      free((void *)page_buf);
      }
#line 1900
      return (1);
      switch_default: /* CIL Label */ 
#line 1902
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1908
    curPage = header.block_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1911
  free((void *)page_buf);
  }
#line 1912
  return (1);
}
}
