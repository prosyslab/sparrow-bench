/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef int __sig_atomic_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_6 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_6 __sigset_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 40 "/usr/include/signal.h"
typedef __sig_atomic_t sig_atomic_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_21 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_22 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_23 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_24 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_25 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_26 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_27 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_20 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_21 _kill ;
   struct __anonstruct__timer_22 _timer ;
   struct __anonstruct__rt_23 _rt ;
   struct __anonstruct__sigchld_24 _sigchld ;
   struct __anonstruct__sigfault_25 _sigfault ;
   struct __anonstruct__sigpoll_26 _sigpoll ;
   struct __anonstruct__sigsys_27 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_19 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_20 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_19 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_39 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_39 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 66 "/usr/include/X11/X.h"
typedef unsigned long XID;
#line 74 "/usr/include/X11/X.h"
typedef unsigned long Atom;
#line 76 "/usr/include/X11/X.h"
typedef unsigned long VisualID;
#line 77 "/usr/include/X11/X.h"
typedef unsigned long Time;
#line 96 "/usr/include/X11/X.h"
typedef XID Window;
#line 97 "/usr/include/X11/X.h"
typedef XID Drawable;
#line 100 "/usr/include/X11/X.h"
typedef XID Font;
#line 102 "/usr/include/X11/X.h"
typedef XID Pixmap;
#line 104 "/usr/include/X11/X.h"
typedef XID Colormap;
#line 105 "/usr/include/X11/X.h"
typedef XID GContext;
#line 106 "/usr/include/X11/X.h"
typedef XID KeySym;
#line 108 "/usr/include/X11/X.h"
typedef unsigned char KeyCode;
#line 92 "/usr/include/X11/Xlib.h"
typedef char *XPointer;
#line 160 "/usr/include/X11/Xlib.h"
struct _XExtData {
   int number ;
   struct _XExtData *next ;
   int (*free_private)(struct _XExtData *extension ) ;
   XPointer private_data ;
};
#line 160 "/usr/include/X11/Xlib.h"
typedef struct _XExtData XExtData;
#line 172 "/usr/include/X11/Xlib.h"
struct __anonstruct_XExtCodes_53 {
   int extension ;
   int major_opcode ;
   int first_event ;
   int first_error ;
};
#line 172 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XExtCodes_53 XExtCodes;
#line 193 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGCValues_55 {
   int function ;
   unsigned long plane_mask ;
   unsigned long foreground ;
   unsigned long background ;
   int line_width ;
   int line_style ;
   int cap_style ;
   int join_style ;
   int fill_style ;
   int fill_rule ;
   int arc_mode ;
   Pixmap tile ;
   Pixmap stipple ;
   int ts_x_origin ;
   int ts_y_origin ;
   Font font ;
   int subwindow_mode ;
   int graphics_exposures ;
   int clip_x_origin ;
   int clip_y_origin ;
   Pixmap clip_mask ;
   int dash_offset ;
   char dashes ;
};
#line 193 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGCValues_55 XGCValues;
#line 226
struct _XGC;
#line 226 "/usr/include/X11/Xlib.h"
typedef struct _XGC *GC;
#line 239 "/usr/include/X11/Xlib.h"
struct __anonstruct_Visual_56 {
   XExtData *ext_data ;
   VisualID visualid ;
   int class ;
   unsigned long red_mask ;
   unsigned long green_mask ;
   unsigned long blue_mask ;
   int bits_per_rgb ;
   int map_entries ;
};
#line 239 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Visual_56 Visual;
#line 255 "/usr/include/X11/Xlib.h"
struct __anonstruct_Depth_57 {
   int depth ;
   int nvisuals ;
   Visual *visuals ;
};
#line 255 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Depth_57 Depth;
#line 267
struct _XDisplay;
#line 267
struct _XDisplay;
#line 269 "/usr/include/X11/Xlib.h"
struct __anonstruct_Screen_58 {
   XExtData *ext_data ;
   struct _XDisplay *display ;
   Window root ;
   int width ;
   int height ;
   int mwidth ;
   int mheight ;
   int ndepths ;
   Depth *depths ;
   int root_depth ;
   Visual *root_visual ;
   GC default_gc ;
   Colormap cmap ;
   unsigned long white_pixel ;
   unsigned long black_pixel ;
   int max_maps ;
   int min_maps ;
   int backing_store ;
   int save_unders ;
   long root_input_mask ;
};
#line 269 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Screen_58 Screen;
#line 292 "/usr/include/X11/Xlib.h"
struct __anonstruct_ScreenFormat_59 {
   XExtData *ext_data ;
   int depth ;
   int bits_per_pixel ;
   int scanline_pad ;
};
#line 292 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_ScreenFormat_59 ScreenFormat;
#line 320 "/usr/include/X11/Xlib.h"
struct __anonstruct_XWindowAttributes_61 {
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   int depth ;
   Visual *visual ;
   Window root ;
   int class ;
   int bit_gravity ;
   int win_gravity ;
   int backing_store ;
   unsigned long backing_planes ;
   unsigned long backing_pixel ;
   int save_under ;
   Colormap colormap ;
   int map_installed ;
   int map_state ;
   long all_event_masks ;
   long your_event_mask ;
   long do_not_propagate_mask ;
   int override_redirect ;
   Screen *screen ;
};
#line 320 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XWindowAttributes_61 XWindowAttributes;
#line 487 "/usr/include/X11/Xlib.h"
struct __anonstruct_XModifierKeymap_73 {
   int max_keypermod ;
   KeyCode *modifiermap ;
};
#line 487 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XModifierKeymap_73 XModifierKeymap;
#line 499 "/usr/include/X11/Xlib.h"
typedef struct _XDisplay Display;
#line 502
struct _XPrivate;
#line 502
struct _XPrivate;
#line 503
struct _XrmHashBucketRec;
#line 503
struct _XrmHashBucketRec;
#line 505 "/usr/include/X11/Xlib.h"
struct __anonstruct__XPrivDisplay_74 {
   XExtData *ext_data ;
   struct _XPrivate *private1 ;
   int fd ;
   int private2 ;
   int proto_major_version ;
   int proto_minor_version ;
   char *vendor ;
   XID private3 ;
   XID private4 ;
   XID private5 ;
   int private6 ;
   XID (*resource_alloc)(struct _XDisplay * ) ;
   int byte_order ;
   int bitmap_unit ;
   int bitmap_pad ;
   int bitmap_bit_order ;
   int nformats ;
   ScreenFormat *pixmap_format ;
   int private8 ;
   int release ;
   struct _XPrivate *private9 ;
   struct _XPrivate *private10 ;
   int qlen ;
   unsigned long last_request_read ;
   unsigned long request ;
   XPointer private11 ;
   XPointer private12 ;
   XPointer private13 ;
   XPointer private14 ;
   unsigned int max_request_size ;
   struct _XrmHashBucketRec *db ;
   int (*private15)(struct _XDisplay * ) ;
   char *display_name ;
   int default_screen ;
   int nscreens ;
   Screen *screens ;
   unsigned long motion_buffer ;
   unsigned long private16 ;
   int min_keycode ;
   int max_keycode ;
   XPointer private17 ;
   XPointer private18 ;
   int private19 ;
   char *xdefaults ;
};
#line 505 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct__XPrivDisplay_74 *_XPrivDisplay;
#line 569 "/usr/include/X11/Xlib.h"
struct __anonstruct_XKeyEvent_75 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   unsigned int keycode ;
   int same_screen ;
};
#line 569 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XKeyEvent_75 XKeyEvent;
#line 587 "/usr/include/X11/Xlib.h"
struct __anonstruct_XButtonEvent_76 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   unsigned int button ;
   int same_screen ;
};
#line 587 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XButtonEvent_76 XButtonEvent;
#line 605 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMotionEvent_77 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   char is_hint ;
   int same_screen ;
};
#line 605 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMotionEvent_77 XMotionEvent;
#line 622 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCrossingEvent_78 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   int mode ;
   int detail ;
   int same_screen ;
   int focus ;
   unsigned int state ;
};
#line 622 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCrossingEvent_78 XCrossingEvent;
#line 646 "/usr/include/X11/Xlib.h"
struct __anonstruct_XFocusChangeEvent_79 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int mode ;
   int detail ;
};
#line 646 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XFocusChangeEvent_79 XFocusChangeEvent;
#line 665 "/usr/include/X11/Xlib.h"
struct __anonstruct_XKeymapEvent_80 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   char key_vector[32] ;
};
#line 665 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XKeymapEvent_80 XKeymapEvent;
#line 674 "/usr/include/X11/Xlib.h"
struct __anonstruct_XExposeEvent_81 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int count ;
};
#line 674 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XExposeEvent_81 XExposeEvent;
#line 685 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGraphicsExposeEvent_82 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Drawable drawable ;
   int x ;
   int y ;
   int width ;
   int height ;
   int count ;
   int major_code ;
   int minor_code ;
};
#line 685 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGraphicsExposeEvent_82 XGraphicsExposeEvent;
#line 698 "/usr/include/X11/Xlib.h"
struct __anonstruct_XNoExposeEvent_83 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Drawable drawable ;
   int major_code ;
   int minor_code ;
};
#line 698 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XNoExposeEvent_83 XNoExposeEvent;
#line 708 "/usr/include/X11/Xlib.h"
struct __anonstruct_XVisibilityEvent_84 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int state ;
};
#line 708 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XVisibilityEvent_84 XVisibilityEvent;
#line 717 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCreateWindowEvent_85 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   int override_redirect ;
};
#line 717 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCreateWindowEvent_85 XCreateWindowEvent;
#line 730 "/usr/include/X11/Xlib.h"
struct __anonstruct_XDestroyWindowEvent_86 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
};
#line 730 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XDestroyWindowEvent_86 XDestroyWindowEvent;
#line 739 "/usr/include/X11/Xlib.h"
struct __anonstruct_XUnmapEvent_87 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int from_configure ;
};
#line 739 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XUnmapEvent_87 XUnmapEvent;
#line 749 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMapEvent_88 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int override_redirect ;
};
#line 749 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMapEvent_88 XMapEvent;
#line 759 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMapRequestEvent_89 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
};
#line 759 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMapRequestEvent_89 XMapRequestEvent;
#line 768 "/usr/include/X11/Xlib.h"
struct __anonstruct_XReparentEvent_90 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   Window parent ;
   int x ;
   int y ;
   int override_redirect ;
};
#line 768 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XReparentEvent_90 XReparentEvent;
#line 780 "/usr/include/X11/Xlib.h"
struct __anonstruct_XConfigureEvent_91 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   Window above ;
   int override_redirect ;
};
#line 780 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XConfigureEvent_91 XConfigureEvent;
#line 794 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGravityEvent_92 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int x ;
   int y ;
};
#line 794 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGravityEvent_92 XGravityEvent;
#line 804 "/usr/include/X11/Xlib.h"
struct __anonstruct_XResizeRequestEvent_93 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int width ;
   int height ;
};
#line 804 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XResizeRequestEvent_93 XResizeRequestEvent;
#line 813 "/usr/include/X11/Xlib.h"
struct __anonstruct_XConfigureRequestEvent_94 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   Window above ;
   int detail ;
   unsigned long value_mask ;
};
#line 813 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XConfigureRequestEvent_94 XConfigureRequestEvent;
#line 828 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCirculateEvent_95 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int place ;
};
#line 828 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCirculateEvent_95 XCirculateEvent;
#line 838 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCirculateRequestEvent_96 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int place ;
};
#line 838 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCirculateRequestEvent_96 XCirculateRequestEvent;
#line 848 "/usr/include/X11/Xlib.h"
struct __anonstruct_XPropertyEvent_97 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom atom ;
   Time time ;
   int state ;
};
#line 848 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XPropertyEvent_97 XPropertyEvent;
#line 859 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionClearEvent_98 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom selection ;
   Time time ;
};
#line 859 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionClearEvent_98 XSelectionClearEvent;
#line 869 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionRequestEvent_99 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window owner ;
   Window requestor ;
   Atom selection ;
   Atom target ;
   Atom property ;
   Time time ;
};
#line 869 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionRequestEvent_99 XSelectionRequestEvent;
#line 882 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionEvent_100 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window requestor ;
   Atom selection ;
   Atom target ;
   Atom property ;
   Time time ;
};
#line 882 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionEvent_100 XSelectionEvent;
#line 894 "/usr/include/X11/Xlib.h"
struct __anonstruct_XColormapEvent_101 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Colormap colormap ;
   int new ;
   int state ;
};
#line 894 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XColormapEvent_101 XColormapEvent;
#line 909 "/usr/include/X11/Xlib.h"
union __anonunion_data_103 {
   char b[20] ;
   short s[10] ;
   long l[5] ;
};
#line 909 "/usr/include/X11/Xlib.h"
struct __anonstruct_XClientMessageEvent_102 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom message_type ;
   int format ;
   union __anonunion_data_103 data ;
};
#line 909 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XClientMessageEvent_102 XClientMessageEvent;
#line 924 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMappingEvent_104 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int request ;
   int first_keycode ;
   int count ;
};
#line 924 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMappingEvent_104 XMappingEvent;
#line 936 "/usr/include/X11/Xlib.h"
struct __anonstruct_XErrorEvent_105 {
   int type ;
   Display *display ;
   XID resourceid ;
   unsigned long serial ;
   unsigned char error_code ;
   unsigned char request_code ;
   unsigned char minor_code ;
};
#line 936 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XErrorEvent_105 XErrorEvent;
#line 946 "/usr/include/X11/Xlib.h"
struct __anonstruct_XAnyEvent_106 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
};
#line 946 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XAnyEvent_106 XAnyEvent;
#line 960 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGenericEvent_107 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   int extension ;
   int evtype ;
};
#line 960 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGenericEvent_107 XGenericEvent;
#line 970 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGenericEventCookie_108 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   int extension ;
   int evtype ;
   unsigned int cookie ;
   void *data ;
};
#line 970 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGenericEventCookie_108 XGenericEventCookie;
#line 985 "/usr/include/X11/Xlib.h"
union _XEvent {
   int type ;
   XAnyEvent xany ;
   XKeyEvent xkey ;
   XButtonEvent xbutton ;
   XMotionEvent xmotion ;
   XCrossingEvent xcrossing ;
   XFocusChangeEvent xfocus ;
   XExposeEvent xexpose ;
   XGraphicsExposeEvent xgraphicsexpose ;
   XNoExposeEvent xnoexpose ;
   XVisibilityEvent xvisibility ;
   XCreateWindowEvent xcreatewindow ;
   XDestroyWindowEvent xdestroywindow ;
   XUnmapEvent xunmap ;
   XMapEvent xmap ;
   XMapRequestEvent xmaprequest ;
   XReparentEvent xreparent ;
   XConfigureEvent xconfigure ;
   XGravityEvent xgravity ;
   XResizeRequestEvent xresizerequest ;
   XConfigureRequestEvent xconfigurerequest ;
   XCirculateEvent xcirculate ;
   XCirculateRequestEvent xcirculaterequest ;
   XPropertyEvent xproperty ;
   XSelectionClearEvent xselectionclear ;
   XSelectionRequestEvent xselectionrequest ;
   XSelectionEvent xselection ;
   XColormapEvent xcolormap ;
   XClientMessageEvent xclient ;
   XMappingEvent xmapping ;
   XErrorEvent xerror ;
   XKeymapEvent xkeymap ;
   XGenericEvent xgeneric ;
   XGenericEventCookie xcookie ;
   long pad[24] ;
};
#line 985 "/usr/include/X11/Xlib.h"
typedef union _XEvent XEvent;
#line 1029 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCharStruct_109 {
   short lbearing ;
   short rbearing ;
   short width ;
   short ascent ;
   short descent ;
   unsigned short attributes ;
};
#line 1029 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCharStruct_109 XCharStruct;
#line 1042 "/usr/include/X11/Xlib.h"
struct __anonstruct_XFontProp_110 {
   Atom name ;
   unsigned long card32 ;
};
#line 1042 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XFontProp_110 XFontProp;
#line 1047 "/usr/include/X11/Xlib.h"
struct __anonstruct_XFontStruct_111 {
   XExtData *ext_data ;
   Font fid ;
   unsigned int direction ;
   unsigned int min_char_or_byte2 ;
   unsigned int max_char_or_byte2 ;
   unsigned int min_byte1 ;
   unsigned int max_byte1 ;
   int all_chars_exist ;
   unsigned int default_char ;
   int n_properties ;
   XFontProp *properties ;
   XCharStruct min_bounds ;
   XCharStruct max_bounds ;
   XCharStruct *per_char ;
   int ascent ;
   int descent ;
};
#line 1047 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XFontStruct_111 XFontStruct;
#line 1855 "/usr/include/X11/Xlib.h"
typedef int (*XErrorHandler)(Display * , XErrorEvent * );
#line 98 "/usr/include/X11/Xmd.h"
typedef int INT32;
#line 102 "/usr/include/X11/Xmd.h"
typedef short INT16;
#line 104 "/usr/include/X11/Xmd.h"
typedef signed char INT8;
#line 108 "/usr/include/X11/Xmd.h"
typedef unsigned int CARD32;
#line 113 "/usr/include/X11/Xmd.h"
typedef unsigned short CARD16;
#line 114 "/usr/include/X11/Xmd.h"
typedef unsigned char CARD8;
#line 119 "/usr/include/X11/Xmd.h"
typedef CARD8 BYTE;
#line 120 "/usr/include/X11/Xmd.h"
typedef CARD8 BOOL;
#line 259 "/usr/include/X11/Xproto.h"
typedef CARD16 KeyButMask;
#line 425 "/usr/include/X11/Xproto.h"
struct __anonstruct_xGenericReply_147 {
   BYTE type ;
   BYTE data1 ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD32 data00 ;
   CARD32 data01 ;
   CARD32 data02 ;
   CARD32 data03 ;
   CARD32 data04 ;
   CARD32 data05 ;
};
#line 425 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xGenericReply_147 xGenericReply;
#line 466 "/usr/include/X11/Xproto.h"
struct __anonstruct_xGetGeometryReply_149 {
   BYTE type ;
   CARD8 depth ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD32 root ;
   INT16 x ;
   INT16 y ;
   CARD16 width ;
   CARD16 height ;
   CARD16 borderWidth ;
   CARD16 pad1 ;
   CARD32 pad2 ;
   CARD32 pad3 ;
};
#line 466 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xGetGeometryReply_149 xGetGeometryReply;
#line 480 "/usr/include/X11/Xproto.h"
struct __anonstruct_xQueryTreeReply_150 {
   BYTE type ;
   BYTE pad1 ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD32 root ;
   CARD32 parent ;
   CARD16 nChildren ;
   CARD16 pad2 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
};
#line 480 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xQueryTreeReply_150 xQueryTreeReply;
#line 493 "/usr/include/X11/Xproto.h"
struct __anonstruct_xInternAtomReply_151 {
   BYTE type ;
   BYTE pad1 ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD32 atom ;
   CARD32 pad2 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
};
#line 493 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xInternAtomReply_151 xInternAtomReply;
#line 506 "/usr/include/X11/Xproto.h"
struct __anonstruct_xGetAtomNameReply_152 {
   BYTE type ;
   BYTE pad1 ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD16 nameLength ;
   CARD16 pad2 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
   CARD32 pad7 ;
};
#line 506 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xGetAtomNameReply_152 xGetAtomNameReply;
#line 520 "/usr/include/X11/Xproto.h"
struct __anonstruct_xGetPropertyReply_153 {
   BYTE type ;
   CARD8 format ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD32 propertyType ;
   CARD32 bytesAfter ;
   CARD32 nItems ;
   CARD32 pad1 ;
   CARD32 pad2 ;
   CARD32 pad3 ;
};
#line 520 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xGetPropertyReply_153 xGetPropertyReply;
#line 533 "/usr/include/X11/Xproto.h"
struct __anonstruct_xListPropertiesReply_154 {
   BYTE type ;
   BYTE pad1 ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD16 nProperties ;
   CARD16 pad2 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
   CARD32 pad7 ;
};
#line 533 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xListPropertiesReply_154 xListPropertiesReply;
#line 547 "/usr/include/X11/Xproto.h"
struct __anonstruct_xGetSelectionOwnerReply_155 {
   BYTE type ;
   BYTE pad1 ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD32 owner ;
   CARD32 pad2 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
};
#line 547 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xGetSelectionOwnerReply_155 xGetSelectionOwnerReply;
#line 560 "/usr/include/X11/Xproto.h"
struct __anonstruct_xGrabPointerReply_156 {
   BYTE type ;
   BYTE status ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD32 pad1 ;
   CARD32 pad2 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
};
#line 560 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xGrabPointerReply_156 xGrabPointerReply;
#line 573 "/usr/include/X11/Xproto.h"
typedef xGrabPointerReply xGrabKeyboardReply;
#line 575 "/usr/include/X11/Xproto.h"
struct __anonstruct_xQueryPointerReply_157 {
   BYTE type ;
   BOOL sameScreen ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD32 root ;
   CARD32 child ;
   INT16 rootX ;
   INT16 rootY ;
   INT16 winX ;
   INT16 winY ;
   CARD16 mask ;
   CARD16 pad1 ;
   CARD32 pad ;
};
#line 575 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xQueryPointerReply_157 xQueryPointerReply;
#line 587 "/usr/include/X11/Xproto.h"
struct __anonstruct_xGetMotionEventsReply_158 {
   BYTE type ;
   BYTE pad1 ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD32 nEvents ;
   CARD32 pad2 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
};
#line 587 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xGetMotionEventsReply_158 xGetMotionEventsReply;
#line 600 "/usr/include/X11/Xproto.h"
struct __anonstruct_xTranslateCoordsReply_159 {
   BYTE type ;
   BOOL sameScreen ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD32 child ;
   INT16 dstX ;
   INT16 dstY ;
   CARD32 pad2 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
};
#line 600 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xTranslateCoordsReply_159 xTranslateCoordsReply;
#line 613 "/usr/include/X11/Xproto.h"
struct __anonstruct_xGetInputFocusReply_160 {
   BYTE type ;
   CARD8 revertTo ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD32 focus ;
   CARD32 pad1 ;
   CARD32 pad2 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
};
#line 613 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xGetInputFocusReply_160 xGetInputFocusReply;
#line 654 "/usr/include/X11/Xproto.h"
struct __anonstruct_xQueryTextExtentsReply_162 {
   BYTE type ;
   CARD8 drawDirection ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   INT16 fontAscent ;
   INT16 fontDescent ;
   INT16 overallAscent ;
   INT16 overallDescent ;
   INT32 overallWidth ;
   INT32 overallLeft ;
   INT32 overallRight ;
   CARD32 pad ;
};
#line 654 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xQueryTextExtentsReply_162 xQueryTextExtentsReply;
#line 665 "/usr/include/X11/Xproto.h"
struct __anonstruct_xListFontsReply_163 {
   BYTE type ;
   BYTE pad1 ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD16 nFonts ;
   CARD16 pad2 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
   CARD32 pad7 ;
};
#line 665 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xListFontsReply_163 xListFontsReply;
#line 699 "/usr/include/X11/Xproto.h"
struct __anonstruct_xGetFontPathReply_165 {
   BYTE type ;
   BYTE pad1 ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD16 nPaths ;
   CARD16 pad2 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
   CARD32 pad7 ;
};
#line 699 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xGetFontPathReply_165 xGetFontPathReply;
#line 713 "/usr/include/X11/Xproto.h"
struct __anonstruct_xGetImageReply_166 {
   BYTE type ;
   CARD8 depth ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD32 visual ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
   CARD32 pad7 ;
};
#line 713 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xGetImageReply_166 xGetImageReply;
#line 726 "/usr/include/X11/Xproto.h"
struct __anonstruct_xListInstalledColormapsReply_167 {
   BYTE type ;
   BYTE pad1 ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD16 nColormaps ;
   CARD16 pad2 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
   CARD32 pad7 ;
};
#line 726 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xListInstalledColormapsReply_167 xListInstalledColormapsReply;
#line 740 "/usr/include/X11/Xproto.h"
struct __anonstruct_xAllocColorReply_168 {
   BYTE type ;
   BYTE pad1 ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD16 red ;
   CARD16 green ;
   CARD16 blue ;
   CARD16 pad2 ;
   CARD32 pixel ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
};
#line 740 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xAllocColorReply_168 xAllocColorReply;
#line 753 "/usr/include/X11/Xproto.h"
struct __anonstruct_xAllocNamedColorReply_169 {
   BYTE type ;
   BYTE pad1 ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD32 pixel ;
   CARD16 exactRed ;
   CARD16 exactGreen ;
   CARD16 exactBlue ;
   CARD16 screenRed ;
   CARD16 screenGreen ;
   CARD16 screenBlue ;
   CARD32 pad2 ;
   CARD32 pad3 ;
};
#line 753 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xAllocNamedColorReply_169 xAllocNamedColorReply;
#line 765 "/usr/include/X11/Xproto.h"
struct __anonstruct_xAllocColorCellsReply_170 {
   BYTE type ;
   BYTE pad1 ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD16 nPixels ;
   CARD16 nMasks ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
   CARD32 pad7 ;
};
#line 765 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xAllocColorCellsReply_170 xAllocColorCellsReply;
#line 778 "/usr/include/X11/Xproto.h"
struct __anonstruct_xAllocColorPlanesReply_171 {
   BYTE type ;
   BYTE pad1 ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD16 nPixels ;
   CARD16 pad2 ;
   CARD32 redMask ;
   CARD32 greenMask ;
   CARD32 blueMask ;
   CARD32 pad3 ;
   CARD32 pad4 ;
};
#line 778 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xAllocColorPlanesReply_171 xAllocColorPlanesReply;
#line 790 "/usr/include/X11/Xproto.h"
struct __anonstruct_xQueryColorsReply_172 {
   BYTE type ;
   BYTE pad1 ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD16 nColors ;
   CARD16 pad2 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
   CARD32 pad7 ;
};
#line 790 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xQueryColorsReply_172 xQueryColorsReply;
#line 804 "/usr/include/X11/Xproto.h"
struct __anonstruct_xLookupColorReply_173 {
   BYTE type ;
   BYTE pad1 ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD16 exactRed ;
   CARD16 exactGreen ;
   CARD16 exactBlue ;
   CARD16 screenRed ;
   CARD16 screenGreen ;
   CARD16 screenBlue ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
};
#line 804 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xLookupColorReply_173 xLookupColorReply;
#line 816 "/usr/include/X11/Xproto.h"
struct __anonstruct_xQueryBestSizeReply_174 {
   BYTE type ;
   BYTE pad1 ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD16 width ;
   CARD16 height ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
   CARD32 pad7 ;
};
#line 816 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xQueryBestSizeReply_174 xQueryBestSizeReply;
#line 829 "/usr/include/X11/Xproto.h"
struct __anonstruct_xQueryExtensionReply_175 {
   BYTE type ;
   BYTE pad1 ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   BOOL present ;
   CARD8 major_opcode ;
   CARD8 first_event ;
   CARD8 first_error ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
   CARD32 pad7 ;
};
#line 829 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xQueryExtensionReply_175 xQueryExtensionReply;
#line 845 "/usr/include/X11/Xproto.h"
struct __anonstruct_xListExtensionsReply_176 {
   BYTE type ;
   CARD8 nExtensions ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD32 pad2 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
   CARD32 pad7 ;
};
#line 845 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xListExtensionsReply_176 xListExtensionsReply;
#line 859 "/usr/include/X11/Xproto.h"
struct __anonstruct_xSetMappingReply_177 {
   BYTE type ;
   CARD8 success ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD32 pad2 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
   CARD32 pad7 ;
};
#line 859 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xSetMappingReply_177 xSetMappingReply;
#line 871 "/usr/include/X11/Xproto.h"
typedef xSetMappingReply xSetPointerMappingReply;
#line 872 "/usr/include/X11/Xproto.h"
typedef xSetMappingReply xSetModifierMappingReply;
#line 874 "/usr/include/X11/Xproto.h"
struct __anonstruct_xGetPointerMappingReply_178 {
   BYTE type ;
   CARD8 nElts ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD32 pad2 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
   CARD32 pad7 ;
};
#line 874 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xGetPointerMappingReply_178 xGetPointerMappingReply;
#line 887 "/usr/include/X11/Xproto.h"
struct __anonstruct_xGetKeyboardMappingReply_179 {
   BYTE type ;
   CARD8 keySymsPerKeyCode ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD32 pad2 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
   CARD32 pad7 ;
};
#line 887 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xGetKeyboardMappingReply_179 xGetKeyboardMappingReply;
#line 900 "/usr/include/X11/Xproto.h"
struct __anonstruct_xGetModifierMappingReply_180 {
   BYTE type ;
   CARD8 numKeyPerModifier ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD32 pad1 ;
   CARD32 pad2 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
};
#line 900 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xGetModifierMappingReply_180 xGetModifierMappingReply;
#line 925 "/usr/include/X11/Xproto.h"
struct __anonstruct_xGetPointerControlReply_182 {
   BYTE type ;
   BYTE pad1 ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD16 accelNumerator ;
   CARD16 accelDenominator ;
   CARD16 threshold ;
   CARD16 pad2 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
};
#line 925 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xGetPointerControlReply_182 xGetPointerControlReply;
#line 939 "/usr/include/X11/Xproto.h"
struct __anonstruct_xGetScreenSaverReply_183 {
   BYTE type ;
   BYTE pad1 ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD16 timeout ;
   CARD16 interval ;
   BOOL preferBlanking ;
   BOOL allowExposures ;
   CARD16 pad2 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
};
#line 939 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xGetScreenSaverReply_183 xGetScreenSaverReply;
#line 954 "/usr/include/X11/Xproto.h"
struct __anonstruct_xListHostsReply_184 {
   BYTE type ;
   BOOL enabled ;
   CARD16 sequenceNumber ;
   CARD32 length ;
   CARD16 nHosts ;
   CARD16 pad1 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
   CARD32 pad7 ;
};
#line 954 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xListHostsReply_184 xListHostsReply;
#line 976 "/usr/include/X11/Xproto.h"
struct __anonstruct_xError_185 {
   BYTE type ;
   BYTE errorCode ;
   CARD16 sequenceNumber ;
   CARD32 resourceID ;
   CARD16 minorCode ;
   CARD8 majorCode ;
   BYTE pad1 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
   CARD32 pad5 ;
   CARD32 pad6 ;
   CARD32 pad7 ;
};
#line 976 "/usr/include/X11/Xproto.h"
typedef struct __anonstruct_xError_185 xError;
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_u_187 {
   BYTE type ;
   BYTE detail ;
   CARD16 sequenceNumber ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_keyButtonPointer_188 {
   CARD32 pad00 ;
   CARD32 time ;
   CARD32 root ;
   CARD32 event ;
   CARD32 child ;
   INT16 rootX ;
   INT16 rootY ;
   INT16 eventX ;
   INT16 eventY ;
   KeyButMask state ;
   BOOL sameScreen ;
   BYTE pad1 ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_enterLeave_189 {
   CARD32 pad00 ;
   CARD32 time ;
   CARD32 root ;
   CARD32 event ;
   CARD32 child ;
   INT16 rootX ;
   INT16 rootY ;
   INT16 eventX ;
   INT16 eventY ;
   KeyButMask state ;
   BYTE mode ;
   BYTE flags ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_focus_190 {
   CARD32 pad00 ;
   CARD32 window ;
   BYTE mode ;
   BYTE pad1 ;
   BYTE pad2 ;
   BYTE pad3 ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_expose_191 {
   CARD32 pad00 ;
   CARD32 window ;
   CARD16 x ;
   CARD16 y ;
   CARD16 width ;
   CARD16 height ;
   CARD16 count ;
   CARD16 pad2 ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_graphicsExposure_192 {
   CARD32 pad00 ;
   CARD32 drawable ;
   CARD16 x ;
   CARD16 y ;
   CARD16 width ;
   CARD16 height ;
   CARD16 minorEvent ;
   CARD16 count ;
   BYTE majorEvent ;
   BYTE pad1 ;
   BYTE pad2 ;
   BYTE pad3 ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_noExposure_193 {
   CARD32 pad00 ;
   CARD32 drawable ;
   CARD16 minorEvent ;
   BYTE majorEvent ;
   BYTE bpad ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_visibility_194 {
   CARD32 pad00 ;
   CARD32 window ;
   CARD8 state ;
   BYTE pad1 ;
   BYTE pad2 ;
   BYTE pad3 ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_createNotify_195 {
   CARD32 pad00 ;
   CARD32 parent ;
   CARD32 window ;
   INT16 x ;
   INT16 y ;
   CARD16 width ;
   CARD16 height ;
   CARD16 borderWidth ;
   BOOL override ;
   BYTE bpad ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_destroyNotify_196 {
   CARD32 pad00 ;
   CARD32 event ;
   CARD32 window ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_unmapNotify_197 {
   CARD32 pad00 ;
   CARD32 event ;
   CARD32 window ;
   BOOL fromConfigure ;
   BYTE pad1 ;
   BYTE pad2 ;
   BYTE pad3 ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_mapNotify_198 {
   CARD32 pad00 ;
   CARD32 event ;
   CARD32 window ;
   BOOL override ;
   BYTE pad1 ;
   BYTE pad2 ;
   BYTE pad3 ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_mapRequest_199 {
   CARD32 pad00 ;
   CARD32 parent ;
   CARD32 window ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_reparent_200 {
   CARD32 pad00 ;
   CARD32 event ;
   CARD32 window ;
   CARD32 parent ;
   INT16 x ;
   INT16 y ;
   BOOL override ;
   BYTE pad1 ;
   BYTE pad2 ;
   BYTE pad3 ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_configureNotify_201 {
   CARD32 pad00 ;
   CARD32 event ;
   CARD32 window ;
   CARD32 aboveSibling ;
   INT16 x ;
   INT16 y ;
   CARD16 width ;
   CARD16 height ;
   CARD16 borderWidth ;
   BOOL override ;
   BYTE bpad ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_configureRequest_202 {
   CARD32 pad00 ;
   CARD32 parent ;
   CARD32 window ;
   CARD32 sibling ;
   INT16 x ;
   INT16 y ;
   CARD16 width ;
   CARD16 height ;
   CARD16 borderWidth ;
   CARD16 valueMask ;
   CARD32 pad1 ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_gravity_203 {
   CARD32 pad00 ;
   CARD32 event ;
   CARD32 window ;
   INT16 x ;
   INT16 y ;
   CARD32 pad1 ;
   CARD32 pad2 ;
   CARD32 pad3 ;
   CARD32 pad4 ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_resizeRequest_204 {
   CARD32 pad00 ;
   CARD32 window ;
   CARD16 width ;
   CARD16 height ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_circulate_205 {
   CARD32 pad00 ;
   CARD32 event ;
   CARD32 window ;
   CARD32 parent ;
   BYTE place ;
   BYTE pad1 ;
   BYTE pad2 ;
   BYTE pad3 ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_property_206 {
   CARD32 pad00 ;
   CARD32 window ;
   CARD32 atom ;
   CARD32 time ;
   BYTE state ;
   BYTE pad1 ;
   CARD16 pad2 ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_selectionClear_207 {
   CARD32 pad00 ;
   CARD32 time ;
   CARD32 window ;
   CARD32 atom ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_selectionRequest_208 {
   CARD32 pad00 ;
   CARD32 time ;
   CARD32 owner ;
   CARD32 requestor ;
   CARD32 selection ;
   CARD32 target ;
   CARD32 property ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_selectionNotify_209 {
   CARD32 pad00 ;
   CARD32 time ;
   CARD32 requestor ;
   CARD32 selection ;
   CARD32 target ;
   CARD32 property ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_colormap_210 {
   CARD32 pad00 ;
   CARD32 window ;
   CARD32 colormap ;
   BOOL new ;
   BYTE state ;
   BYTE pad1 ;
   BYTE pad2 ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_mappingNotify_211 {
   CARD32 pad00 ;
   CARD8 request ;
   CARD8 firstKeyCode ;
   CARD8 count ;
   BYTE pad1 ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_l_214 {
   CARD32 type ;
   INT32 longs0 ;
   INT32 longs1 ;
   INT32 longs2 ;
   INT32 longs3 ;
   INT32 longs4 ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_s_215 {
   CARD32 type ;
   INT16 shorts0 ;
   INT16 shorts1 ;
   INT16 shorts2 ;
   INT16 shorts3 ;
   INT16 shorts4 ;
   INT16 shorts5 ;
   INT16 shorts6 ;
   INT16 shorts7 ;
   INT16 shorts8 ;
   INT16 shorts9 ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_b_216 {
   CARD32 type ;
   INT8 bytes[20] ;
};
#line 996 "/usr/include/X11/Xproto.h"
union __anonunion_u_213 {
   struct __anonstruct_l_214 l ;
   struct __anonstruct_s_215 s ;
   struct __anonstruct_b_216 b ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct __anonstruct_clientMessage_212 {
   CARD32 pad00 ;
   CARD32 window ;
   union __anonunion_u_213 u ;
};
#line 996 "/usr/include/X11/Xproto.h"
union __anonunion_u_186 {
   struct __anonstruct_u_187 u ;
   struct __anonstruct_keyButtonPointer_188 keyButtonPointer ;
   struct __anonstruct_enterLeave_189 enterLeave ;
   struct __anonstruct_focus_190 focus ;
   struct __anonstruct_expose_191 expose ;
   struct __anonstruct_graphicsExposure_192 graphicsExposure ;
   struct __anonstruct_noExposure_193 noExposure ;
   struct __anonstruct_visibility_194 visibility ;
   struct __anonstruct_createNotify_195 createNotify ;
   struct __anonstruct_destroyNotify_196 destroyNotify ;
   struct __anonstruct_unmapNotify_197 unmapNotify ;
   struct __anonstruct_mapNotify_198 mapNotify ;
   struct __anonstruct_mapRequest_199 mapRequest ;
   struct __anonstruct_reparent_200 reparent ;
   struct __anonstruct_configureNotify_201 configureNotify ;
   struct __anonstruct_configureRequest_202 configureRequest ;
   struct __anonstruct_gravity_203 gravity ;
   struct __anonstruct_resizeRequest_204 resizeRequest ;
   struct __anonstruct_circulate_205 circulate ;
   struct __anonstruct_property_206 property ;
   struct __anonstruct_selectionClear_207 selectionClear ;
   struct __anonstruct_selectionRequest_208 selectionRequest ;
   struct __anonstruct_selectionNotify_209 selectionNotify ;
   struct __anonstruct_colormap_210 colormap ;
   struct __anonstruct_mappingNotify_211 mappingNotify ;
   struct __anonstruct_clientMessage_212 clientMessage ;
};
#line 996 "/usr/include/X11/Xproto.h"
struct _xEvent {
   union __anonunion_u_186 u ;
};
#line 996 "/usr/include/X11/Xproto.h"
typedef struct _xEvent xEvent;
#line 1264 "/usr/include/X11/Xproto.h"
union __anonunion_xReply_219 {
   xGenericReply generic ;
   xGetGeometryReply geom ;
   xQueryTreeReply tree ;
   xInternAtomReply atom ;
   xGetAtomNameReply atomName ;
   xGetPropertyReply property ;
   xListPropertiesReply listProperties ;
   xGetSelectionOwnerReply selection ;
   xGrabPointerReply grabPointer ;
   xGrabKeyboardReply grabKeyboard ;
   xQueryPointerReply pointer ;
   xGetMotionEventsReply motionEvents ;
   xTranslateCoordsReply coords ;
   xGetInputFocusReply inputFocus ;
   xQueryTextExtentsReply textExtents ;
   xListFontsReply fonts ;
   xGetFontPathReply fontPath ;
   xGetImageReply image ;
   xListInstalledColormapsReply colormaps ;
   xAllocColorReply allocColor ;
   xAllocNamedColorReply allocNamedColor ;
   xAllocColorCellsReply colorCells ;
   xAllocColorPlanesReply colorPlanes ;
   xQueryColorsReply colors ;
   xLookupColorReply lookupColor ;
   xQueryBestSizeReply bestSize ;
   xQueryExtensionReply extension ;
   xListExtensionsReply extensions ;
   xSetModifierMappingReply setModifierMapping ;
   xGetModifierMappingReply getModifierMapping ;
   xSetPointerMappingReply setPointerMapping ;
   xGetKeyboardMappingReply getKeyboardMapping ;
   xGetPointerMappingReply getPointerMapping ;
   xGetPointerControlReply pointerControl ;
   xGetScreenSaverReply screenSaver ;
   xListHostsReply hosts ;
   xError error ;
   xEvent event ;
};
#line 1264 "/usr/include/X11/Xproto.h"
typedef union __anonunion_xReply_219 xReply;
#line 65 "/usr/include/X11/Xlibint.h"
struct _XGC {
   XExtData *ext_data ;
   GContext gid ;
   int rects ;
   int dashes ;
   unsigned long dirty ;
   XGCValues values ;
};
#line 75
struct _XFreeFuncs;
#line 75
struct _XSQEvent;
#line 75
struct _XExten;
#line 75
struct _XLockInfo;
#line 75
struct _XInternalAsync;
#line 75
struct _XLockPtrs;
#line 75
struct _XKeytrans;
#line 75
struct _XDisplayAtoms;
#line 75
struct _XContextDB;
#line 75 "/usr/include/X11/Xlibint.h"
struct __anonstruct_cms_292 {
   XPointer defaultCCCs ;
   XPointer clientCmaps ;
   XPointer perVisualIntensityMaps ;
};
#line 75
struct _XIMFilter;
#line 75
struct _XConnectionInfo;
#line 75
struct _XConnWatchInfo;
#line 75
struct _XkbInfoRec;
#line 75
struct _XtransConnInfo;
#line 75
struct _X11XCBPrivate;
#line 75 "/usr/include/X11/Xlibint.h"
struct _XDisplay {
   XExtData *ext_data ;
   struct _XFreeFuncs *free_funcs ;
   int fd ;
   int conn_checker ;
   int proto_major_version ;
   int proto_minor_version ;
   char *vendor ;
   XID resource_base ;
   XID resource_mask ;
   XID resource_id ;
   int resource_shift ;
   XID (*resource_alloc)(struct _XDisplay * ) ;
   int byte_order ;
   int bitmap_unit ;
   int bitmap_pad ;
   int bitmap_bit_order ;
   int nformats ;
   ScreenFormat *pixmap_format ;
   int vnumber ;
   int release ;
   struct _XSQEvent *head ;
   struct _XSQEvent *tail ;
   int qlen ;
   unsigned long last_request_read ;
   unsigned long request ;
   char *last_req ;
   char *buffer ;
   char *bufptr ;
   char *bufmax ;
   unsigned int max_request_size ;
   struct _XrmHashBucketRec *db ;
   int (*synchandler)(struct _XDisplay * ) ;
   char *display_name ;
   int default_screen ;
   int nscreens ;
   Screen *screens ;
   unsigned long motion_buffer ;
   unsigned long volatile   flags ;
   int min_keycode ;
   int max_keycode ;
   KeySym *keysyms ;
   XModifierKeymap *modifiermap ;
   int keysyms_per_keycode ;
   char *xdefaults ;
   char *scratch_buffer ;
   unsigned long scratch_length ;
   int ext_number ;
   struct _XExten *ext_procs ;
   int (*event_vec[128])(Display * , XEvent * , xEvent * ) ;
   int (*wire_vec[128])(Display * , XEvent * , xEvent * ) ;
   KeySym lock_meaning ;
   struct _XLockInfo *lock ;
   struct _XInternalAsync *async_handlers ;
   unsigned long bigreq_size ;
   struct _XLockPtrs *lock_fns ;
   void (*idlist_alloc)(Display * , XID * , int  ) ;
   struct _XKeytrans *key_bindings ;
   Font cursor_font ;
   struct _XDisplayAtoms *atoms ;
   unsigned int mode_switch ;
   unsigned int num_lock ;
   struct _XContextDB *context_db ;
   int (**error_vec)(Display * , XErrorEvent * , xError * ) ;
   struct __anonstruct_cms_292 cms ;
   struct _XIMFilter *im_filters ;
   struct _XSQEvent *qfree ;
   unsigned long next_event_serial_num ;
   struct _XExten *flushes ;
   struct _XConnectionInfo *im_fd_info ;
   int im_fd_length ;
   struct _XConnWatchInfo *conn_watchers ;
   int watcher_count ;
   XPointer filedes ;
   int (*savedsynchandler)(Display * ) ;
   XID resource_max ;
   int xcmisc_opcode ;
   struct _XkbInfoRec *xkb_info ;
   struct _XtransConnInfo *trans_conn ;
   struct _X11XCBPrivate *xcb ;
   unsigned int next_cookie ;
   int (*generic_event_vec[128])(Display * , XGenericEventCookie * , xEvent * ) ;
   int (*generic_event_copy_vec[128])(Display * , XGenericEventCookie * , XGenericEventCookie * ) ;
   void *cookiejar ;
};
#line 216 "/usr/include/X11/Xlibint.h"
struct _XSQEvent {
   struct _XSQEvent *next ;
   XEvent event ;
   unsigned long qserial_num ;
};
#line 258 "/usr/include/X11/Xlibint.h"
struct _XLockPtrs {
   void (*lock_display)(Display *dpy ) ;
   void (*unlock_display)(Display *dpy ) ;
};
#line 655 "/usr/include/X11/Xlibint.h"
struct _XInternalAsync {
   struct _XInternalAsync *next ;
   int (*handler)(Display * , xReply * , char * , int  , XPointer  ) ;
   XPointer data ;
};
#line 705 "/usr/include/X11/Xlibint.h"
struct _XFreeFuncs {
   void (*atoms)(Display * ) ;
   int (*modifiermap)(XModifierKeymap * ) ;
   void (*key_bindings)(Display * ) ;
   void (*context_db)(Display * ) ;
   void (*defaultCCCs)(Display * ) ;
   void (*clientCmaps)(Display * ) ;
   void (*intensityMaps)(Display * ) ;
   void (*im_filters)(Display * ) ;
   void (*xkb)(Display * ) ;
};
#line 790 "/usr/include/X11/Xlibint.h"
struct _XExten {
   struct _XExten *next ;
   XExtCodes codes ;
   int (*create_GC)(Display * , GC  , XExtCodes * ) ;
   int (*copy_GC)(Display * , GC  , XExtCodes * ) ;
   int (*flush_GC)(Display * , GC  , XExtCodes * ) ;
   int (*free_GC)(Display * , GC  , XExtCodes * ) ;
   int (*create_Font)(Display * , XFontStruct * , XExtCodes * ) ;
   int (*free_Font)(Display * , XFontStruct * , XExtCodes * ) ;
   int (*close_display)(Display * , XExtCodes * ) ;
   int (*error)(Display * , xError * , XExtCodes * , int * ) ;
   char *(*error_string)(Display * , int  , XExtCodes * , char * , int  ) ;
   char *name ;
   void (*error_values)(Display * , XErrorEvent * , void * ) ;
   void (*before_flush)(Display * , XExtCodes * , char const   * , long  ) ;
   struct _XExten *next_flush ;
};
#line 1202 "/usr/include/X11/Xlibint.h"
struct _XConnectionInfo {
   int fd ;
   void (*read_callback)(Display * , int  , XPointer  ) ;
   XPointer call_data ;
   XPointer *watch_data ;
   struct _XConnectionInfo *next ;
};
#line 1210 "/usr/include/X11/Xlibint.h"
struct _XConnWatchInfo {
   void (*fn)(Display * , XPointer  , int  , int  , XPointer * ) ;
   XPointer client_data ;
   struct _XConnWatchInfo *next ;
};
#line 119 "/usr/include/X11/Xutil.h"
struct __anonstruct_XWMHints_295 {
   long flags ;
   int input ;
   int initial_state ;
   Pixmap icon_pixmap ;
   Window icon_window ;
   int icon_x ;
   int icon_y ;
   Pixmap icon_mask ;
   XID window_group ;
};
#line 119 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XWMHints_295 XWMHints;
#line 163 "/usr/include/X11/Xutil.h"
struct __anonstruct_XTextProperty_296 {
   unsigned char *value ;
   Atom encoding ;
   int format ;
   unsigned long nitems ;
};
#line 163 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XTextProperty_296 XTextProperty;
#line 189 "/usr/include/X11/Xutil.h"
struct __anonstruct_XClassHint_299 {
   char *res_name ;
   char *res_class ;
};
#line 189 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XClassHint_299 XClassHint;
#line 46 "/usr/include/X11/extensions/XKBstr.h"
struct _XkbStateRec {
   unsigned char group ;
   unsigned char locked_group ;
   unsigned short base_group ;
   unsigned short latched_group ;
   unsigned char mods ;
   unsigned char base_mods ;
   unsigned char latched_mods ;
   unsigned char locked_mods ;
   unsigned char compat_state ;
   unsigned char grab_mods ;
   unsigned char compat_grab_mods ;
   unsigned char lookup_mods ;
   unsigned char compat_lookup_mods ;
   unsigned short ptr_buttons ;
};
#line 46 "/usr/include/X11/extensions/XKBstr.h"
typedef struct _XkbStateRec XkbStateRec;
#line 46 "/usr/include/X11/extensions/XKBstr.h"
typedef struct _XkbStateRec *XkbStatePtr;
#line 33 "/usr/include/X11/XKBlib.h"
struct _XkbAnyEvent {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Time time ;
   int xkb_type ;
   unsigned int device ;
};
#line 33 "/usr/include/X11/XKBlib.h"
typedef struct _XkbAnyEvent XkbAnyEvent;
#line 43 "/usr/include/X11/XKBlib.h"
struct _XkbNewKeyboardNotify {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Time time ;
   int xkb_type ;
   int device ;
   int old_device ;
   int min_key_code ;
   int max_key_code ;
   int old_min_key_code ;
   int old_max_key_code ;
   unsigned int changed ;
   char req_major ;
   char req_minor ;
};
#line 43 "/usr/include/X11/XKBlib.h"
typedef struct _XkbNewKeyboardNotify XkbNewKeyboardNotifyEvent;
#line 61 "/usr/include/X11/XKBlib.h"
struct _XkbMapNotifyEvent {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Time time ;
   int xkb_type ;
   int device ;
   unsigned int changed ;
   unsigned int flags ;
   int first_type ;
   int num_types ;
   KeyCode min_key_code ;
   KeyCode max_key_code ;
   KeyCode first_key_sym ;
   KeyCode first_key_act ;
   KeyCode first_key_behavior ;
   KeyCode first_key_explicit ;
   KeyCode first_modmap_key ;
   KeyCode first_vmodmap_key ;
   int num_key_syms ;
   int num_key_acts ;
   int num_key_behaviors ;
   int num_key_explicit ;
   int num_modmap_keys ;
   int num_vmodmap_keys ;
   unsigned int vmods ;
};
#line 61 "/usr/include/X11/XKBlib.h"
typedef struct _XkbMapNotifyEvent XkbMapNotifyEvent;
#line 90 "/usr/include/X11/XKBlib.h"
struct _XkbStateNotifyEvent {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Time time ;
   int xkb_type ;
   int device ;
   unsigned int changed ;
   int group ;
   int base_group ;
   int latched_group ;
   int locked_group ;
   unsigned int mods ;
   unsigned int base_mods ;
   unsigned int latched_mods ;
   unsigned int locked_mods ;
   int compat_state ;
   unsigned char grab_mods ;
   unsigned char compat_grab_mods ;
   unsigned char lookup_mods ;
   unsigned char compat_lookup_mods ;
   int ptr_buttons ;
   KeyCode keycode ;
   char event_type ;
   char req_major ;
   char req_minor ;
};
#line 90 "/usr/include/X11/XKBlib.h"
typedef struct _XkbStateNotifyEvent XkbStateNotifyEvent;
#line 119 "/usr/include/X11/XKBlib.h"
struct _XkbControlsNotify {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Time time ;
   int xkb_type ;
   int device ;
   unsigned int changed_ctrls ;
   unsigned int enabled_ctrls ;
   unsigned int enabled_ctrl_changes ;
   int num_groups ;
   KeyCode keycode ;
   char event_type ;
   char req_major ;
   char req_minor ;
};
#line 119 "/usr/include/X11/XKBlib.h"
typedef struct _XkbControlsNotify XkbControlsNotifyEvent;
#line 137 "/usr/include/X11/XKBlib.h"
struct _XkbIndicatorNotify {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Time time ;
   int xkb_type ;
   int device ;
   unsigned int changed ;
   unsigned int state ;
};
#line 137 "/usr/include/X11/XKBlib.h"
typedef struct _XkbIndicatorNotify XkbIndicatorNotifyEvent;
#line 149 "/usr/include/X11/XKBlib.h"
struct _XkbNamesNotify {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Time time ;
   int xkb_type ;
   int device ;
   unsigned int changed ;
   int first_type ;
   int num_types ;
   int first_lvl ;
   int num_lvls ;
   int num_aliases ;
   int num_radio_groups ;
   unsigned int changed_vmods ;
   unsigned int changed_groups ;
   unsigned int changed_indicators ;
   int first_key ;
   int num_keys ;
};
#line 149 "/usr/include/X11/XKBlib.h"
typedef struct _XkbNamesNotify XkbNamesNotifyEvent;
#line 171 "/usr/include/X11/XKBlib.h"
struct _XkbCompatMapNotify {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Time time ;
   int xkb_type ;
   int device ;
   unsigned int changed_groups ;
   int first_si ;
   int num_si ;
   int num_total_si ;
};
#line 171 "/usr/include/X11/XKBlib.h"
typedef struct _XkbCompatMapNotify XkbCompatMapNotifyEvent;
#line 185 "/usr/include/X11/XKBlib.h"
struct _XkbBellNotify {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Time time ;
   int xkb_type ;
   int device ;
   int percent ;
   int pitch ;
   int duration ;
   int bell_class ;
   int bell_id ;
   Atom name ;
   Window window ;
   int event_only ;
};
#line 185 "/usr/include/X11/XKBlib.h"
typedef struct _XkbBellNotify XkbBellNotifyEvent;
#line 203 "/usr/include/X11/XKBlib.h"
struct _XkbActionMessage {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Time time ;
   int xkb_type ;
   int device ;
   KeyCode keycode ;
   int press ;
   int key_event_follows ;
   int group ;
   unsigned int mods ;
   char message[7] ;
};
#line 203 "/usr/include/X11/XKBlib.h"
typedef struct _XkbActionMessage XkbActionMessageEvent;
#line 220 "/usr/include/X11/XKBlib.h"
struct _XkbAccessXNotify {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Time time ;
   int xkb_type ;
   int device ;
   int detail ;
   int keycode ;
   int sk_delay ;
   int debounce_delay ;
};
#line 220 "/usr/include/X11/XKBlib.h"
typedef struct _XkbAccessXNotify XkbAccessXNotifyEvent;
#line 234 "/usr/include/X11/XKBlib.h"
struct _XkbExtensionDeviceNotify {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Time time ;
   int xkb_type ;
   int device ;
   unsigned int reason ;
   unsigned int supported ;
   unsigned int unsupported ;
   int first_btn ;
   int num_btns ;
   unsigned int leds_defined ;
   unsigned int led_state ;
   int led_class ;
   int led_id ;
};
#line 234 "/usr/include/X11/XKBlib.h"
typedef struct _XkbExtensionDeviceNotify XkbExtensionDeviceNotifyEvent;
#line 254 "/usr/include/X11/XKBlib.h"
union _XkbEvent {
   int type ;
   XkbAnyEvent any ;
   XkbNewKeyboardNotifyEvent new_kbd ;
   XkbMapNotifyEvent map ;
   XkbStateNotifyEvent state ;
   XkbControlsNotifyEvent ctrls ;
   XkbIndicatorNotifyEvent indicators ;
   XkbNamesNotifyEvent names ;
   XkbCompatMapNotifyEvent compat ;
   XkbBellNotifyEvent bell ;
   XkbActionMessageEvent message ;
   XkbAccessXNotifyEvent accessx ;
   XkbExtensionDeviceNotifyEvent device ;
   XEvent core ;
};
#line 254 "/usr/include/X11/XKBlib.h"
typedef union _XkbEvent XkbEvent;
#line 160 "/usr/include/X11/Xresource.h"
struct __anonstruct_XrmValue_303 {
   unsigned int size ;
   XPointer addr ;
};
#line 160 "/usr/include/X11/Xresource.h"
typedef struct __anonstruct_XrmValue_303 XrmValue;
#line 175 "/usr/include/X11/Xresource.h"
typedef struct _XrmHashBucketRec *XrmDatabase;
#line 326
enum __anonenum_XrmOptionKind_304 {
    XrmoptionNoArg = 0,
    XrmoptionIsArg = 1,
    XrmoptionStickyArg = 2,
    XrmoptionSepArg = 3,
    XrmoptionResArg = 4,
    XrmoptionSkipArg = 5,
    XrmoptionSkipLine = 6,
    XrmoptionSkipNArgs = 7
} ;
#line 326 "/usr/include/X11/Xresource.h"
typedef enum __anonenum_XrmOptionKind_304 XrmOptionKind;
#line 338 "/usr/include/X11/Xresource.h"
struct __anonstruct_XrmOptionDescRec_305 {
   char *option ;
   char *specifier ;
   XrmOptionKind argKind ;
   XPointer value ;
};
#line 338 "/usr/include/X11/Xresource.h"
typedef struct __anonstruct_XrmOptionDescRec_305 XrmOptionDescRec;
#line 338 "/usr/include/X11/Xresource.h"
typedef struct __anonstruct_XrmOptionDescRec_305 *XrmOptionDescList;
#line 62 "/home/june/repo/benchmarks/collector2/temp/xkbind-2010.05.20/xkbind.c"
enum __anonenum_resvals_306 {
    undef = -1,
    off = 0,
    on = 1
} ;
#line 62 "/home/june/repo/benchmarks/collector2/temp/xkbind-2010.05.20/xkbind.c"
typedef enum __anonenum_resvals_306 resvals;
#line 64 "/home/june/repo/benchmarks/collector2/temp/xkbind-2010.05.20/xkbind.c"
struct __anonstruct_List_307 {
   char **items ;
   int count ;
   char *res_string ;
};
#line 64 "/home/june/repo/benchmarks/collector2/temp/xkbind-2010.05.20/xkbind.c"
typedef struct __anonstruct_List_307 List;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 846
extern void perror(char const   *__s ) ;
#line 312 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 127 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 218 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigfillset)(sigset_t *__set ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 334 "/usr/include/time.h"
extern int nanosleep(struct timespec  const  *__requested_time , struct timespec *__remaining ) ;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 497
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 531
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup)(int __fd ) ;
#line 667
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) setsid)(void) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 1499 "/usr/include/X11/Xlib.h"
extern void XrmInitialize(void) ;
#line 1527
extern char *XDisplayName(char const   * ) ;
#line 1553
extern int XInternAtoms(Display * , char ** , int  , int  , Atom * ) ;
#line 1731
extern char *XResourceManagerString(Display * ) ;
#line 1827
extern char *XDisplayString(Display * ) ;
#line 1860
extern XErrorHandler XSetErrorHandler(int (*)(Display * , XErrorEvent * ) ) ;
#line 1894
extern int XGetWMProtocols(Display * , Window  , Atom ** , int * ) ;
#line 2080
extern int XChangeProperty(Display * , Window  , Atom  , Atom  , int  , int  , unsigned char const   * ,
                           int  ) ;
#line 2104
extern int XCheckIfEvent(Display * , XEvent * , int (*)(Display * , XEvent * , XPointer  ) ,
                         XPointer  ) ;
#line 2115
extern int XCheckMaskEvent(Display * , long  , XEvent * ) ;
#line 2121
extern int XCheckTypedEvent(Display * , int  , XEvent * ) ;
#line 2172
extern int XCloseDisplay(Display * ) ;
#line 2249
extern int XDeleteProperty(Display * , Window  , Atom  ) ;
#line 2528
extern int XFree(void * ) ;
#line 2650
extern int XGetInputFocus(Display * , Window * , int * ) ;
#line 2688
extern int XGetWindowProperty(Display * , Window  , Atom  , long  , long  , int  ,
                              Atom  , Atom * , int * , unsigned long * , unsigned long * ,
                              unsigned char ** ) ;
#line 2703
extern int XGetWindowAttributes(Display * , Window  , XWindowAttributes * ) ;
#line 2753
extern int XGrabServer(Display * ) ;
#line 3029
extern int XQueryTree(Display * , Window  , Window * , Window * , Window ** , unsigned int * ) ;
#line 3141
extern int XSelectInput(Display * , Window  , long  ) ;
#line 3421
extern int XSync(Display * , int  ) ;
#line 3498
extern int XUngrabServer(Display * ) ;
#line 423 "/usr/include/X11/Xutil.h"
extern int XGetClassHint(Display * , Window  , XClassHint * ) ;
#line 464
extern int XGetTextProperty(Display * , Window  , XTextProperty * , Atom  ) ;
#line 484
extern XWMHints *XGetWMHints(Display * , Window  ) ;
#line 495
extern int XGetWMName(Display * , Window  , XTextProperty * ) ;
#line 628
extern void XSetTextProperty(Display * , Window  , XTextProperty * , Atom  ) ;
#line 653
extern void XSetWMName(Display * , Window  , XTextProperty * ) ;
#line 733
extern int XStringListToTextProperty(char ** , int  , XTextProperty * ) ;
#line 299 "/usr/include/X11/XKBlib.h"
extern Display *XkbOpenDisplay(char * , int * , int * , int * , int * , int * ) ;
#line 481
extern int XkbSelectEventDetails(Display * , unsigned int  , unsigned int  , unsigned long  ,
                                 unsigned long  ) ;
#line 592
extern int XkbLockGroup(Display * , unsigned int  , unsigned int  ) ;
#line 867
extern int XkbGetState(Display * , unsigned int  , XkbStatePtr  ) ;
#line 178 "/usr/include/X11/Xresource.h"
extern void XrmDestroyDatabase(XrmDatabase  ) ;
#line 223
extern int XrmGetResource(XrmDatabase  , char const   * , char const   * , char ** ,
                          XrmValue * ) ;
#line 270
extern int XrmCombineFileDatabase(char const   * , XrmDatabase * , int  ) ;
#line 276
extern XrmDatabase XrmGetStringDatabase(char const   * ) ;
#line 290
extern void XrmCombineDatabase(XrmDatabase  , XrmDatabase * , int  ) ;
#line 346
extern void XrmParseCommand(XrmDatabase * , XrmOptionDescList  , int  , char const   * ,
                            int * , char ** ) ;
#line 70 "/home/june/repo/benchmarks/collector2/temp/xkbind-2010.05.20/xkbind.c"
char const   *app_name  =    "xkbind";
#line 70 "/home/june/repo/benchmarks/collector2/temp/xkbind-2010.05.20/xkbind.c"
char const   *app_def_dir  =    "/usr/local/lib/xkbind/app-defaults";
#line 70 "/home/june/repo/benchmarks/collector2/temp/xkbind-2010.05.20/xkbind.c"
char const   *user_rc_file  =    ".xkbindrc";
#line 72 "/home/june/repo/benchmarks/collector2/temp/xkbind-2010.05.20/xkbind.c"
Display *dpy  ;
#line 73 "/home/june/repo/benchmarks/collector2/temp/xkbind-2010.05.20/xkbind.c"
Window root  ;
#line 74 "/home/june/repo/benchmarks/collector2/temp/xkbind-2010.05.20/xkbind.c"
int def_group  ;
#line 74 "/home/june/repo/benchmarks/collector2/temp/xkbind-2010.05.20/xkbind.c"
int xkb_event  ;
#line 75 "/home/june/repo/benchmarks/collector2/temp/xkbind-2010.05.20/xkbind.c"
char *command  ;
#line 75 "/home/june/repo/benchmarks/collector2/temp/xkbind-2010.05.20/xkbind.c"
char *def_label  ;
#line 75 "/home/june/repo/benchmarks/collector2/temp/xkbind-2010.05.20/xkbind.c"
char *noname  =    (char *)"";
#line 76 "/home/june/repo/benchmarks/collector2/temp/xkbind-2010.05.20/xkbind.c"
char *group_labels[4]  ;
#line 77 "/home/june/repo/benchmarks/collector2/temp/xkbind-2010.05.20/xkbind.c"
XkbEvent ev  ;
#line 78 "/home/june/repo/benchmarks/collector2/temp/xkbind-2010.05.20/xkbind.c"
sig_atomic_t volatile   term  ;
#line 80 "/home/june/repo/benchmarks/collector2/temp/xkbind-2010.05.20/xkbind.c"
int (*DefErrHandler)(Display * , XErrorEvent * )  ;
#line 82 "/home/june/repo/benchmarks/collector2/temp/xkbind-2010.05.20/xkbind.c"
struct timespec delay  =    {(__time_t )0, (__syscall_slong_t )20000000};
#line 84 "/home/june/repo/benchmarks/collector2/temp/xkbind-2010.05.20/xkbind.c"
int flags  ;
#line 91 "/home/june/repo/benchmarks/collector2/temp/xkbind-2010.05.20/xkbind.c"
List name_list  ;
#line 91 "/home/june/repo/benchmarks/collector2/temp/xkbind-2010.05.20/xkbind.c"
List class_list  ;
#line 93 "/home/june/repo/benchmarks/collector2/temp/xkbind-2010.05.20/xkbind.c"
char *atom_names[4]  = {      (char *)"XKBIND_NAME",      (char *)"XKBIND_GROUP",      (char *)"COMPOUND_TEXT",      (char *)"WM_TAKE_FOCUS"};
#line 94 "/home/june/repo/benchmarks/collector2/temp/xkbind-2010.05.20/xkbind.c"
Atom atoms[sizeof(atom_names) / sizeof(char *)]  ;
#line 101
void QueryTree(Window win , void (*Action)(Window  ) ) ;
#line 102
void AddWindow(Window window ) ;
#line 103
void DelWindow(Window window ) ;
#line 104
void SetWM_NAME(Window window , XTextProperty *p_tp , int group ) ;
#line 105
void SetWindow(Window window , int group ) ;
#line 106
void ChangeWindow(Window window , int group ) ;
#line 107
int GetWindowGroup(Window window ) ;
#line 108
void CheckInstance(void) ;
#line 109
Display *Initialize(int *p_argc , char **argv ) ;
#line 110
char *GetRes(XrmDatabase db , char const   *name1 , char const   *name2 , char const   *def_value ) ;
#line 111
void CleanUp(int full ) ;
#line 112
void Usage(void) ;
#line 113
int IsInputWindow(Window window ) ;
#line 114
int IgnoreWindow(Window window ) ;
#line 115
void ParseList(List *list ) ;
#line 116
void FreeList(List *list ) ;
#line 117
int PatternMatch(char const   *p , char const   *s ) ;
#line 118
resvals ResValue(char const   *s ) ;
#line 119
void SigHandler(int sig_num ) ;
#line 120
int Predicate(Display *dpy___0 , XEvent *ev___0 , XPointer arg ) ;
#line 121
int ErrHandler(Display *dpy___0 , XErrorEvent *err_event ) ;
#line 122
void SetSignals(void) ;
#line 123
void Deamonize(void) ;
#line 125 "/home/june/repo/benchmarks/collector2/temp/xkbind-2010.05.20/xkbind.c"
int main(int argc , char **argv ) 
{ 
  int revert_to ;
  int group ;
  Window window ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 130
  command = *(argv + 0);
#line 131
  SetSignals();
#line 132
  DefErrHandler = XSetErrorHandler(& ErrHandler);
#line 133
  dpy = Initialize(& argc, argv);
#line 134
  root = (((_XPrivDisplay )dpy)->screens + ((_XPrivDisplay )dpy)->default_screen)->root;
#line 136
  tmp = XInternAtoms(dpy, atom_names, (int )(sizeof(atoms) / sizeof(Atom )), 0, atoms);
  }
#line 136
  if (! tmp) {
    {
#line 138
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: XInternAtoms() error\n",
            command);
    }
#line 139
    return (1);
  }
  {
#line 142
  CheckInstance();
  }
#line 143
  if (! ((long )flags & (1L << 3))) {
    {
#line 143
    Deamonize();
    }
  }
  {
#line 145
  QueryTree(root, & AddWindow);
#line 146
  XGetInputFocus(dpy, & window, & revert_to);
  }
#line 147
  if (window != 1UL) {
#line 147
    if (window != 0UL) {
      {
#line 147
      group = GetWindowGroup(window);
      }
#line 147
      if (group != -1) {
        {
#line 148
        XkbLockGroup(dpy, 256U, (unsigned int )group);
        }
      }
    }
  }
  {
#line 151
  XkbSelectEventDetails(dpy, 256U, 2U, (unsigned long )(1L << 7), (unsigned long )(1L << 7));
#line 154
  XSelectInput(dpy, root, 1L << 19);
  }
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 157
    if (term) {
      {
#line 158
      CleanUp(1);
#line 162
      exit(0);
      }
    }
    {
#line 165
    tmp___0 = XCheckMaskEvent(dpy, -1L, (XEvent *)(& ev));
    }
#line 165
    if (! tmp___0) {
      {
#line 165
      tmp___1 = XCheckTypedEvent(dpy, xkb_event, (XEvent *)(& ev));
      }
#line 165
      if (! tmp___1) {
        {
#line 167
        nanosleep((struct timespec  const  *)(& delay), (struct timespec *)((void *)0));
        }
#line 168
        goto while_continue;
      }
    }
    {
#line 172
    if (ev.type == 21) {
#line 172
      goto case_21;
    }
#line 181
    if (ev.type == 28) {
#line 181
      goto case_28;
    }
#line 205
    if (ev.type == 9) {
#line 205
      goto case_9;
    }
#line 255
    goto switch_default;
    case_21: /* CIL Label */ 
    {
#line 177
    AddWindow(ev.core.xreparent.window);
    }
#line 178
    goto switch_break;
    case_28: /* CIL Label */ 
#line 182
    if (ev.core.xproperty.atom == 39UL) {
      {
#line 183
      window = ev.core.xproperty.window;
#line 188
      group = GetWindowGroup(window);
      }
#line 189
      if (group != -1) {
        {
#line 199
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 199
          tmp___2 = XCheckIfEvent(dpy, (XEvent *)(& ev), & Predicate, (XPointer )window);
          }
#line 199
          if (! tmp___2) {
#line 199
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 201
        SetWindow(window, group);
        }
      }
    }
#line 204
    goto switch_break;
    case_9: /* CIL Label */ 
#line 245
    if (ev.core.xfocus.detail == 3) {
#line 245
      goto _L___0;
    } else
#line 245
    if (ev.core.xfocus.detail == 0) {
#line 245
      goto _L___0;
    } else
#line 245
    if (ev.core.xfocus.detail == 2) {
      _L___0: /* CIL Label */ 
#line 245
      if (ev.core.xfocus.mode == 0) {
#line 245
        goto _L;
      } else
#line 245
      if (ev.core.xfocus.mode == 3) {
        _L: /* CIL Label */ 
        {
#line 245
        group = GetWindowGroup(ev.core.xfocus.window);
        }
#line 245
        if (group != -1) {
          {
#line 251
          XkbLockGroup(dpy, 256U, (unsigned int )group);
          }
        }
      }
    }
#line 252
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 256
    if (ev.type == xkb_event) {
#line 256
      if (ev.any.xkb_type == 2) {
        {
#line 265
        XGetInputFocus(dpy, & window, & revert_to);
        }
#line 266
        if (window != 1UL) {
#line 266
          if (window != 0UL) {
            {
#line 266
            group = GetWindowGroup(window);
            }
#line 266
            if (group != -1) {
#line 266
              if (group != ev.state.locked_group) {
                {
#line 269
                ChangeWindow(window, ev.state.locked_group);
                }
              }
            }
          }
        }
      }
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 275
  return (0);
}
}
#line 278 "/home/june/repo/benchmarks/collector2/temp/xkbind-2010.05.20/xkbind.c"
int Predicate(Display *dpy___0 , XEvent *ev___0 , XPointer arg ) 
{ 
  int tmp ;

  {
#line 280
  if (ev___0->type == 28) {
#line 280
    if (ev___0->xproperty.window == (Window )arg) {
#line 280
      if (ev___0->xproperty.atom == 39UL) {
#line 280
        tmp = 1;
      } else {
#line 280
        tmp = 0;
      }
    } else {
#line 280
      tmp = 0;
    }
  } else {
#line 280
    tmp = 0;
  }
#line 280
  return (tmp);
}
}
#line 285 "/home/june/repo/benchmarks/collector2/temp/xkbind-2010.05.20/xkbind.c"
void QueryTree(Window win , void (*Action)(Window  ) ) 
{ 
  Window rwin ;
  Window parent ;
  Window *childrens ;
  unsigned int num ;
  unsigned int i ;

  {
  {
#line 288
  i = 0U;
#line 290
  XQueryTree(dpy, win, & rwin, & parent, & childrens, & num);
  }
#line 291
  if (! childrens) {
#line 291
    return;
  }
  {
#line 292
  while (1) {
    while_continue: /* CIL Label */ ;
#line 292
    if (! num) {
#line 292
      goto while_break;
    }
    {
#line 293
    (*Action)(*(childrens + i));
#line 294
    QueryTree(*(childrens + i), Action);
#line 295
    num --;
#line 295
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 297
  XFree((void *)childrens);
  }
#line 298
  return;
}
}
#line 300 "/home/june/repo/benchmarks/collector2/temp/xkbind-2010.05.20/xkbind.c"
void AddWindow(Window window ) 
{ 
  int group ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 304
  tmp = IsInputWindow(window);
  }
#line 304
  if (tmp) {
    {
#line 304
    tmp___0 = IgnoreWindow(window);
    }
#line 304
    if (tmp___0) {
#line 304
      return;
    }
  } else {
#line 304
    return;
  }
  {
#line 306
  group = GetWindowGroup(window);
  }
#line 306
  if (group == -1) {
    {
#line 307
    SetWindow(window, def_group);
    }
  } else {
    {
#line 309
    ChangeWindow(window, group);
    }
  }
  {
#line 311
  XSelectInput(dpy, window, (1L << 21) | (1L << 22));
  }
#line 312
  return;
}
}
#line 314 "/home/june/repo/benchmarks/collector2/temp/xkbind-2010.05.20/xkbind.c"
void DelWindow(Window window ) 
{ 
  XTextProperty tp ;
  int tmp ;

  {
  {
#line 318
  tmp = XGetTextProperty(dpy, window, & tp, atoms[0]);
  }
#line 318
  if (tmp) {
    {
#line 319
    SetWM_NAME(window, & tp, -1);
#line 320
    XDeleteProperty(dpy, window, atoms[0]);
#line 321
    XDeleteProperty(dpy, window, atoms[1]);
    }
  }
#line 323
  return;
}
}
#line 325 "/home/june/repo/benchmarks/collector2/temp/xkbind-2010.05.20/xkbind.c"
void SetWM_NAME(Window window , XTextProperty *p_tp , int group ) 
{ 
  char *prefix ;
  char *s ;
  XWindowAttributes wa ;
  size_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 330
  if (group >= 0) {
#line 331
    if (group <= 3) {
#line 331
      prefix = group_labels[group];
    } else {
#line 331
      prefix = def_label;
    }
  } else {
#line 333
    prefix = (char *)"\000";
  }
  {
#line 335
  tmp = strlen((char const   *)prefix);
#line 335
  p_tp->nitems += tmp;
#line 337
  tmp___0 = malloc(p_tp->nitems + 1UL);
#line 337
  s = (char *)tmp___0;
  }
#line 338
  if (! s) {
    {
#line 339
    perror("malloc");
    }
#line 340
    return;
  }
  {
#line 343
  strcpy((char */* __restrict  */)s, (char const   */* __restrict  */)prefix);
#line 344
  strcat((char */* __restrict  */)s, (char const   */* __restrict  */)((char const   *)p_tp->value));
#line 345
  p_tp->value = (unsigned char *)s;
#line 347
  tmp___1 = XGetWindowAttributes(dpy, window, & wa);
  }
#line 347
  if (tmp___1) {
    {
#line 348
    XSelectInput(dpy, window, wa.your_event_mask & ~ (1L << 22));
#line 349
    XSync(dpy, 0);
#line 350
    XSetWMName(dpy, window, p_tp);
#line 351
    XSelectInput(dpy, window, wa.your_event_mask);
    }
  }
  {
#line 354
  free((void *)s);
  }
#line 355
  return;
}
}
#line 357 "/home/june/repo/benchmarks/collector2/temp/xkbind-2010.05.20/xkbind.c"
void ChangeWindow(Window window , int group ) 
{ 
  XTextProperty tp ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 361
  XChangeProperty(dpy, window, atoms[1], (Atom )19, 32, 0, (unsigned char const   *)((unsigned char *)(& group)),
                  1);
#line 364
  tmp___0 = XGetTextProperty(dpy, window, & tp, atoms[0]);
  }
#line 364
  if (! tmp___0) {
    {
#line 365
    tmp = XStringListToTextProperty(& noname, 1, & tp);
    }
#line 365
    if (! tmp) {
      {
#line 366
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: can\'t change window %d\n",
              command, (int )window);
      }
#line 367
      return;
    }
  }
  {
#line 371
  SetWM_NAME(window, & tp, group);
  }
#line 372
  return;
}
}
#line 374 "/home/june/repo/benchmarks/collector2/temp/xkbind-2010.05.20/xkbind.c"
void SetWindow(Window window , int group ) 
{ 
  XTextProperty tp ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 378
  XChangeProperty(dpy, window, atoms[1], (Atom )19, 32, 0, (unsigned char const   *)((unsigned char *)(& group)),
                  1);
#line 384
  tmp___0 = XGetWMName(dpy, window, & tp);
  }
#line 384
  if (! tmp___0) {
    {
#line 385
    tmp = XStringListToTextProperty(& noname, 1, & tp);
    }
#line 385
    if (! tmp) {
      {
#line 386
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: can\'t set window %d\n",
              command, (int )window);
      }
#line 387
      return;
    }
  }
  {
#line 391
  XSetTextProperty(dpy, window, & tp, atoms[0]);
#line 392
  SetWM_NAME(window, & tp, group);
  }
#line 393
  return;
}
}
#line 398 "/home/june/repo/benchmarks/collector2/temp/xkbind-2010.05.20/xkbind.c"
int GetWindowGroup(Window window ) 
{ 
  Atom actual_type ;
  int actual_format ;
  int *data ;
  int group ;
  unsigned long nitems ;
  unsigned long bytes_after ;
  int tmp ;

  {
  {
#line 404
  tmp = XGetWindowProperty(dpy, window, atoms[1], 0L, 1L, 0, (Atom )0L, & actual_type,
                           & actual_format, & nitems, & bytes_after, (unsigned char **)(& data));
  }
#line 404
  if (tmp == 0) {
#line 404
    if (actual_format) {
      {
#line 407
      group = *data;
#line 408
      XFree((void *)data);
      }
#line 409
      return (group);
    } else {
#line 411
      return (-1);
    }
  } else {
#line 411
    return (-1);
  }
}
}
#line 414 "/home/june/repo/benchmarks/collector2/temp/xkbind-2010.05.20/xkbind.c"
void CheckInstance(void) 
{ 
  Atom actual_type ;
  int actual_format ;
  unsigned long nitems ;
  unsigned long bytes_after ;
  unsigned char *data ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 421
  XGrabServer(dpy);
#line 422
  XSync(dpy, 0);
  }
#line 423
  if (! ((long )flags & 1L)) {
    {
#line 423
    tmp___0 = XGetWindowProperty(dpy, root, atoms[1], 0L, 1L, 0, (Atom )0L, & actual_type,
                                 & actual_format, & nitems, & bytes_after, & data);
    }
#line 423
    if (tmp___0 == 0) {
#line 423
      if (actual_format) {
        {
#line 426
        XFree((void *)data);
#line 427
        tmp = XDisplayString(dpy);
#line 427
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s is already running on display \"%s\"\nIf you feel sure, try with -f option.\n",
                app_name, tmp);
#line 430
        CleanUp(0);
#line 431
        exit(1);
        }
      }
    }
  }
  {
#line 433
  XChangeProperty(dpy, root, atoms[1], (Atom )19, 32, 0, (unsigned char const   *)((unsigned char *)(& def_group)),
                  1);
#line 435
  XUngrabServer(dpy);
  }
#line 436
  return;
}
}
#line 440
Display *Initialize(int *p_argc , char **argv ) ;
#line 440 "/home/june/repo/benchmarks/collector2/temp/xkbind-2010.05.20/xkbind.c"
static XrmOptionDescRec opt_table[15]  = 
#line 440
  {      {(char *)"-display", (char *)".display", (XrmOptionKind )3, (XPointer )((void *)0)}, 
        {(char *)"-help",
      (char *)".help", (XrmOptionKind )1, (XPointer )((void *)0)}, 
        {(char *)"-version", (char *)".version", (XrmOptionKind )1, (XPointer )((void *)0)}, 
        {(char *)"-force",
      (char *)".force", (XrmOptionKind )1, (XPointer )((void *)0)}, 
        {(char *)"-nodetach", (char *)".nodetach", (XrmOptionKind )1, (XPointer )((void *)0)}, 
        {(char *)"-defgrp",
      (char *)".defgroup", (XrmOptionKind )3, (XPointer )((void *)0)}, 
        {(char *)"-label0", (char *)".label.group0", (XrmOptionKind )3, (XPointer )((void *)0)}, 
        {(char *)"-label1",
      (char *)".label.group1", (XrmOptionKind )3, (XPointer )((void *)0)}, 
        {(char *)"-label2", (char *)".label.group2", (XrmOptionKind )3, (XPointer )((void *)0)}, 
        {(char *)"-label3",
      (char *)".label.group2", (XrmOptionKind )3, (XPointer )((void *)0)}, 
        {(char *)"-deflbl", (char *)".label.default", (XrmOptionKind )3, (XPointer )((void *)0)}, 
        {(char *)"-iname",
      (char *)".ignore.name", (XrmOptionKind )3, (XPointer )((void *)0)}, 
        {(char *)"-iclass", (char *)".ignore.class", (XrmOptionKind )3, (XPointer )((void *)0)}, 
        {(char *)"-ireverse",
      (char *)".ignore.reverse", (XrmOptionKind )0, (XPointer )"on"}, 
        {(char *)"-inowild", (char *)".ignore.usewild", (XrmOptionKind )0, (XPointer )"off"}};
#line 480
Display *Initialize(int *p_argc , char **argv ) ;
#line 480 "/home/june/repo/benchmarks/collector2/temp/xkbind-2010.05.20/xkbind.c"
static char msg[319]  = 
#line 480
  {      (char )'%',      (char )'s',      (char )' ',      (char )'-', 
        (char )' ',      (char )'X',      (char )' ',      (char )'K', 
        (char )'e',      (char )'y',      (char )'b',      (char )'o', 
        (char )'a',      (char )'r',      (char )'d',      (char )' ', 
        (char )'E',      (char )'x',      (char )'t',      (char )'e', 
        (char )'n',      (char )'s',      (char )'i',      (char )'o', 
        (char )'n',      (char )' ',      (char )'I',      (char )'n', 
        (char )'d',      (char )'i',      (char )'c',      (char )'a', 
        (char )'t',      (char )'o',      (char )'r',      (char )' ', 
        (char )'-',      (char )' ',      (char )'V',      (char )'e', 
        (char )'r',      (char )'s',      (char )'i',      (char )'o', 
        (char )'n',      (char )' ',      (char )'%',      (char )'s', 
        (char )'\n',      (char )'C',      (char )'o',      (char )'p', 
        (char )'y',      (char )'r',      (char )'i',      (char )'g', 
        (char )'h',      (char )'t',      (char )' ',      (char )'(', 
        (char )'C',      (char )')',      (char )' ',      (char )'2', 
        (char )'0',      (char )'0',      (char )'4',      (char )' ', 
        (char )'C',      (char )'H',      (char )'G',      (char )' ', 
        (char )'<',      (char )'%',      (char )'s',      (char )'>', 
        (char )'\n',      (char )'\n',      (char )'T',      (char )'h', 
        (char )'i',      (char )'s',      (char )' ',      (char )'p', 
        (char )'r',      (char )'o',      (char )'g',      (char )'r', 
        (char )'a',      (char )'m',      (char )' ',      (char )'i', 
        (char )'s',      (char )' ',      (char )'f',      (char )'r', 
        (char )'e',      (char )'e',      (char )' ',      (char )'s', 
        (char )'o',      (char )'f',      (char )'t',      (char )'w', 
        (char )'a',      (char )'r',      (char )'e',      (char )';', 
        (char )' ',      (char )'y',      (char )'o',      (char )'u', 
        (char )' ',      (char )'c',      (char )'a',      (char )'n', 
        (char )' ',      (char )'r',      (char )'e',      (char )'d', 
        (char )'i',      (char )'s',      (char )'t',      (char )'r', 
        (char )'i',      (char )'b',      (char )'u',      (char )'t', 
        (char )'e',      (char )' ',      (char )'i',      (char )'t', 
        (char )' ',      (char )'a',      (char )'n',      (char )'d', 
        (char )'/',      (char )'o',      (char )'r',      (char )' ', 
        (char )'m',      (char )'o',      (char )'d',      (char )'i', 
        (char )'f',      (char )'y',      (char )'\n',      (char )'i', 
        (char )'t',      (char )' ',      (char )'u',      (char )'n', 
        (char )'d',      (char )'e',      (char )'r',      (char )' ', 
        (char )'t',      (char )'h',      (char )'e',      (char )' ', 
        (char )'t',      (char )'e',      (char )'r',      (char )'m', 
        (char )'s',      (char )' ',      (char )'o',      (char )'f', 
        (char )' ',      (char )'t',      (char )'h',      (char )'e', 
        (char )' ',      (char )'G',      (char )'N',      (char )'U', 
        (char )' ',      (char )'G',      (char )'e',      (char )'n', 
        (char )'e',      (char )'r',      (char )'a',      (char )'l', 
        (char )' ',      (char )'P',      (char )'u',      (char )'b', 
        (char )'l',      (char )'i',      (char )'c',      (char )' ', 
        (char )'L',      (char )'i',      (char )'c',      (char )'e', 
        (char )'n',      (char )'s',      (char )'e',      (char )' ', 
        (char )'a',      (char )'s',      (char )' ',      (char )'p', 
        (char )'u',      (char )'b',      (char )'l',      (char )'i', 
        (char )'s',      (char )'h',      (char )'e',      (char )'d', 
        (char )' ',      (char )'b',      (char )'y',      (char )'\n', 
        (char )'t',      (char )'h',      (char )'e',      (char )' ', 
        (char )'F',      (char )'r',      (char )'e',      (char )'e', 
        (char )' ',      (char )'S',      (char )'o',      (char )'f', 
        (char )'t',      (char )'w',      (char )'a',      (char )'r', 
        (char )'e',      (char )' ',      (char )'F',      (char )'o', 
        (char )'u',      (char )'n',      (char )'d',      (char )'a', 
        (char )'t',      (char )'i',      (char )'o',      (char )'n', 
        (char )';',      (char )' ',      (char )'e',      (char )'i', 
        (char )'t',      (char )'h',      (char )'e',      (char )'r', 
        (char )' ',      (char )'v',      (char )'e',      (char )'r', 
        (char )'s',      (char )'i',      (char )'o',      (char )'n', 
        (char )' ',      (char )'2',      (char )' ',      (char )'o', 
        (char )'f',      (char )' ',      (char )'t',      (char )'h', 
        (char )'e',      (char )' ',      (char )'L',      (char )'i', 
        (char )'c',      (char )'e',      (char )'n',      (char )'s', 
        (char )'e',      (char )',',      (char )' ',      (char )'o', 
        (char )'r',      (char )'\n',      (char )'(',      (char )'a', 
        (char )'t',      (char )' ',      (char )'y',      (char )'o', 
        (char )'u',      (char )'r',      (char )' ',      (char )'o', 
        (char )'p',      (char )'t',      (char )'i',      (char )'o', 
        (char )'n',      (char )')',      (char )' ',      (char )'a', 
        (char )'n',      (char )'y',      (char )' ',      (char )'l', 
        (char )'a',      (char )'t',      (char )'e',      (char )'r', 
        (char )' ',      (char )'v',      (char )'e',      (char )'r', 
        (char )'s',      (char )'i',      (char )'o',      (char )'n', 
        (char )'.',      (char )'\n',      (char )'\000'};
#line 438 "/home/june/repo/benchmarks/collector2/temp/xkbind-2010.05.20/xkbind.c"
Display *Initialize(int *p_argc , char **argv ) 
{ 
  XrmDatabase db ;
  char *p_str ;
  char *p ;
  char *buf ;
  Display *dpy___0 ;
  int xkb_error ;
  int reason ;
  int i ;
  unsigned int l ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  XrmDatabase manager_db ;
  XrmDatabase tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  resvals tmp___9 ;
  resvals tmp___10 ;
  char buf___0[32] ;
  XkbStateRec xkb_state ;
  int grp ;
  char buf___1[16] ;
  long tmp___11 ;

  {
  {
#line 457
  db = (XrmDatabase )0;
#line 463
  XrmInitialize();
#line 464
  XrmParseCommand(& db, opt_table, (int )(sizeof(opt_table) / sizeof(XrmOptionDescRec )),
                  app_name, p_argc, argv);
#line 468
  p_str = GetRes(db, "help", (char const   *)((void *)0), "");
#line 469
  i = (int )*p_str;
#line 470
  free((void *)p_str);
  }
#line 471
  if (i) {
    {
#line 472
    XrmDestroyDatabase(db);
#line 473
    Usage();
    }
  } else
#line 471
  if (*p_argc > 1) {
    {
#line 472
    XrmDestroyDatabase(db);
#line 473
    Usage();
    }
  }
  {
#line 476
  p_str = GetRes(db, "version", (char const   *)((void *)0), "");
#line 477
  i = (int )*p_str;
#line 478
  free((void *)p_str);
  }
#line 479
  if (i) {
    {
#line 488
    XrmDestroyDatabase(db);
#line 489
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)(msg),
            app_name, "2010.05.20", "smersh@users.sf.net");
#line 490
    exit(1);
    }
  }
  {
#line 493
  p_str = GetRes(db, "force", (char const   *)((void *)0), "");
  }
#line 494
  if (*p_str) {
#line 494
    flags = (int )((long )flags | 1L);
  }
  {
#line 495
  free((void *)p_str);
#line 497
  p_str = GetRes(db, "nodetach", (char const   *)((void *)0), "");
  }
#line 498
  if (*p_str) {
#line 498
    flags = (int )((long )flags | (1L << 3));
  }
  {
#line 499
  free((void *)p_str);
#line 501
  p_str = getenv("HOME");
  }
#line 502
  if (p_str) {
    {
#line 503
    tmp = strlen((char const   *)p_str);
#line 503
    l = (unsigned int )tmp;
#line 506
    tmp___0 = strlen(user_rc_file);
#line 506
    tmp___1 = malloc(((size_t )l + tmp___0) + 2UL);
#line 506
    buf = (char *)tmp___1;
    }
#line 507
    if (buf) {
      {
#line 508
      strcpy((char */* __restrict  */)buf, (char const   */* __restrict  */)p_str);
#line 509
      p = buf + l;
      }
#line 509
      if (! *p) {
#line 509
        *p = (char )'/';
#line 509
        *(p + 1) = (char )'\000';
      }
      {
#line 510
      strcat((char */* __restrict  */)buf, (char const   */* __restrict  */)user_rc_file);
#line 511
      XrmCombineFileDatabase((char const   *)buf, & db, 0);
#line 512
      free((void *)buf);
      }
    } else {
      {
#line 514
      perror("malloc");
      }
    }
  }
  {
#line 521
  p_str = GetRes(db, "display", (char const   *)((void *)0), "");
#line 522
  dpy___0 = XkbOpenDisplay(p_str, & xkb_event, & xkb_error, (int *)((void *)0), (int *)((void *)0),
                           & reason);
  }
#line 523
  if (! dpy___0) {
    {
#line 524
    tmp___2 = XDisplayName((char const   *)p_str);
#line 524
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: can\'t open display \"%s\"\n",
            command, tmp___2);
#line 525
    free((void *)p_str);
#line 526
    exit(1);
    }
  }
  {
#line 528
  free((void *)p_str);
#line 530
  p_str = XResourceManagerString(dpy___0);
  }
#line 531
  if (p_str) {
    {
#line 532
    tmp___3 = XrmGetStringDatabase((char const   *)p_str);
#line 532
    manager_db = tmp___3;
#line 533
    XrmCombineDatabase(manager_db, & db, 0);
    }
  }
  {
#line 536
  tmp___4 = strlen(app_def_dir);
#line 536
  l = (unsigned int )tmp___4;
#line 537
  tmp___5 = strlen(app_name);
#line 537
  tmp___6 = malloc(((size_t )l + tmp___5) + 2UL);
#line 537
  buf = (char *)tmp___6;
  }
#line 538
  if (buf) {
    {
#line 539
    strcpy((char */* __restrict  */)buf, (char const   */* __restrict  */)app_def_dir);
#line 540
    p = buf + l;
    }
#line 540
    if (! *p) {
#line 540
      *p = (char )'/';
#line 540
      *(p + 1) = (char )'\000';
    }
    {
#line 541
    tmp___7 = strlen((char const   *)buf);
#line 541
    l = (unsigned int )tmp___7;
#line 542
    strcat((char */* __restrict  */)buf, (char const   */* __restrict  */)app_name);
#line 543
    tmp___8 = toupper((int )*(buf + l));
#line 543
    *(buf + l) = (char )tmp___8;
#line 544
    XrmCombineFileDatabase((char const   *)buf, & db, 0);
#line 545
    free((void *)buf);
    }
  } else {
    {
#line 547
    perror("malloc");
    }
  }
  {
#line 553
  p_str = GetRes(db, "ignore", "reverse", "off");
#line 554
  tmp___9 = ResValue((char const   *)p_str);
  }
#line 554
  if ((int )tmp___9 == 1) {
#line 554
    flags = (int )((long )flags | (1L << 1));
  }
  {
#line 555
  free((void *)p_str);
#line 557
  flags = (int )((long )flags | (1L << 2));
#line 558
  p_str = GetRes(db, "ignore", "usewild", "on");
#line 559
  tmp___10 = ResValue((char const   *)p_str);
  }
#line 559
  if ((int )tmp___10 == 0) {
#line 559
    flags = (int )((long )flags & ~ (1L << 2));
  }
  {
#line 560
  free((void *)p_str);
#line 562
  def_label = GetRes(db, "label", "default", "");
#line 563
  i = 0;
  }
  {
#line 563
  while (1) {
    while_continue: /* CIL Label */ ;
#line 563
    if (! (i <= 3)) {
#line 563
      goto while_break;
    }
    {
#line 566
    snprintf((char */* __restrict  */)(buf___0), sizeof(buf___0), (char const   */* __restrict  */)"group%d",
             i);
#line 567
    group_labels[i] = GetRes(db, "label", (char const   *)(buf___0), (char const   *)def_label);
#line 563
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 575
  xkb_state.locked_group = (unsigned char)0;
#line 576
  XkbGetState(dpy___0, 256U, & xkb_state);
#line 577
  snprintf((char */* __restrict  */)(buf___1), sizeof(buf___1), (char const   */* __restrict  */)"%d",
           (int )xkb_state.locked_group);
#line 579
  p_str = GetRes(db, "defgroup", (char const   *)((void *)0), (char const   *)(buf___1));
#line 580
  tmp___11 = strtol((char const   */* __restrict  */)p_str, (char **/* __restrict  */)(& p),
                    10);
#line 580
  def_group = (int )tmp___11;
  }
#line 581
  if (*p) {
#line 582
    def_group = grp;
  } else
#line 581
  if (def_group > 3) {
#line 582
    def_group = grp;
  }
  {
#line 583
  free((void *)p_str);
#line 586
  name_list.res_string = GetRes(db, "ignore", "name", "");
#line 587
  ParseList(& name_list);
#line 588
  class_list.res_string = GetRes(db, "ignore", "class", "");
#line 589
  ParseList(& class_list);
#line 591
  XrmDestroyDatabase(db);
  }
#line 593
  return (dpy___0);
}
}
#line 601 "/home/june/repo/benchmarks/collector2/temp/xkbind-2010.05.20/xkbind.c"
char *GetRes(XrmDatabase db , char const   *name1 , char const   *name2 , char const   *def_value ) 
{ 
  char *str_type ;
  char *ptr ;
  char *buf ;
  char *class ;
  XrmValue xv ;
  int len ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;

  {
  {
#line 607
  tmp = strlen(app_name);
#line 607
  tmp___0 = strlen(name1);
#line 607
  len = (int )((tmp + tmp___0) + 2UL);
  }
#line 608
  if (name2) {
    {
#line 608
    tmp___1 = strlen(name2);
#line 608
    len = (int )((size_t )len + (tmp___1 + 1UL));
    }
  }
  {
#line 610
  tmp___2 = malloc((size_t )len);
#line 610
  buf = (char *)tmp___2;
#line 611
  tmp___3 = malloc((size_t )len);
#line 611
  class = (char *)tmp___3;
  }
#line 612
  if (buf) {
#line 612
    if (class) {
#line 613
      if (! name2) {
        {
#line 613
        sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)"%s.%s",
                app_name, name1);
        }
      } else {
        {
#line 614
        sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)"%s.%s.%s",
                app_name, name1, name2);
        }
      }
      {
#line 615
      strcpy((char */* __restrict  */)class, (char const   */* __restrict  */)buf);
#line 616
      tmp___4 = toupper((int )*class);
#line 616
      *class = (char )tmp___4;
#line 618
      tmp___7 = XrmGetResource(db, (char const   *)buf, (char const   *)class, & str_type,
                               & xv);
      }
#line 618
      if (tmp___7) {
        {
#line 618
        tmp___8 = malloc((size_t )(xv.size + 1U));
#line 618
        ptr = (char *)tmp___8;
        }
#line 618
        if (ptr) {
          {
#line 619
          memcpy((void */* __restrict  */)ptr, (void const   */* __restrict  */)xv.addr,
                 (size_t )xv.size);
#line 620
          *(ptr + xv.size) = (char )'\000';
          }
        } else {
#line 618
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 621
        tmp___5 = strlen(def_value);
#line 621
        tmp___6 = malloc(tmp___5 + 1UL);
#line 621
        ptr = (char *)tmp___6;
        }
#line 621
        if (ptr) {
          {
#line 622
          strcpy((char */* __restrict  */)ptr, (char const   */* __restrict  */)def_value);
          }
        }
      }
      {
#line 624
      free((void *)buf);
#line 625
      free((void *)class);
      }
    }
  }
#line 628
  if (ptr) {
#line 628
    if (buf) {
#line 628
      if (! class) {
        {
#line 629
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: memory allocation error.\n",
                command);
#line 630
        exit(1);
        }
      }
    } else {
      {
#line 629
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: memory allocation error.\n",
              command);
#line 630
      exit(1);
      }
    }
  } else {
    {
#line 629
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: memory allocation error.\n",
            command);
#line 630
    exit(1);
    }
  }
#line 633
  return (ptr);
}
}
#line 636 "/home/june/repo/benchmarks/collector2/temp/xkbind-2010.05.20/xkbind.c"
void CleanUp(int full ) 
{ 
  int i ;

  {
#line 640
  if (root) {
#line 641
    if (full) {
      {
#line 642
      QueryTree(root, & DelWindow);
#line 643
      XDeleteProperty(dpy, root, atoms[1]);
#line 644
      XkbLockGroup(dpy, 256U, (unsigned int )def_group);
      }
    }
    {
#line 646
    XSync(dpy, 0);
#line 647
    XCloseDisplay(dpy);
    }
  }
#line 650
  i = 0;
  {
#line 650
  while (1) {
    while_continue: /* CIL Label */ ;
#line 650
    if (! (i <= 3)) {
#line 650
      goto while_break;
    }
#line 651
    if ((unsigned long )group_labels[i] != (unsigned long )def_label) {
      {
#line 651
      free((void *)group_labels[i]);
      }
    }
#line 650
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 652
  free((void *)def_label);
#line 654
  FreeList(& name_list);
#line 655
  FreeList(& class_list);
  }
#line 656
  return;
}
}
#line 658 "/home/june/repo/benchmarks/collector2/temp/xkbind-2010.05.20/xkbind.c"
void FreeList(List *list ) 
{ 


  {
  {
#line 660
  free((void *)list->items);
#line 661
  free((void *)list->res_string);
  }
#line 662
  return;
}
}
#line 666
void Usage(void) ;
#line 666 "/home/june/repo/benchmarks/collector2/temp/xkbind-2010.05.20/xkbind.c"
static char msg___0[330]  = 
#line 666
  {      (char )'U',      (char )'s',      (char )'a',      (char )'g', 
        (char )'e',      (char )':',      (char )' ',      (char )'%', 
        (char )'s',      (char )' ',      (char )'[',      (char )'-', 
        (char )'d',      (char )'i',      (char )'s',      (char )'p', 
        (char )'l',      (char )'a',      (char )'y',      (char )' ', 
        (char )'<',      (char )'d',      (char )'i',      (char )'s', 
        (char )'p',      (char )'l',      (char )'a',      (char )'y', 
        (char )'n',      (char )'a',      (char )'m',      (char )'e', 
        (char )'>',      (char )']',      (char )' ',      (char )'[', 
        (char )'-',      (char )'f',      (char )'o',      (char )'r', 
        (char )'c',      (char )'e',      (char )']',      (char )' ', 
        (char )'[',      (char )'-',      (char )'n',      (char )'o', 
        (char )'d',      (char )'e',      (char )'t',      (char )'a', 
        (char )'c',      (char )'h',      (char )']',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'[', 
        (char )'-',      (char )'d',      (char )'e',      (char )'f', 
        (char )'g',      (char )'r',      (char )'p',      (char )' ', 
        (char )'<',      (char )'g',      (char )'r',      (char )'o', 
        (char )'u',      (char )'p',      (char )'>',      (char )']', 
        (char )' ',      (char )'[',      (char )'-',      (char )'d', 
        (char )'e',      (char )'f',      (char )'l',      (char )'b', 
        (char )'l',      (char )' ',      (char )'<',      (char )'l', 
        (char )'a',      (char )'b',      (char )'e',      (char )'l', 
        (char )'>',      (char )']',      (char )'\n',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )'[',      (char )'-', 
        (char )'l',      (char )'a',      (char )'b',      (char )'e', 
        (char )'l',      (char )'0',      (char )' ',      (char )'<', 
        (char )'l',      (char )'a',      (char )'b',      (char )'e', 
        (char )'l',      (char )'>',      (char )']',      (char )' ', 
        (char )'[',      (char )'-',      (char )'l',      (char )'a', 
        (char )'b',      (char )'e',      (char )'l',      (char )'1', 
        (char )' ',      (char )'<',      (char )'l',      (char )'a', 
        (char )'b',      (char )'e',      (char )'l',      (char )'>', 
        (char )']',      (char )'\n',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )'[',      (char )'-',      (char )'l', 
        (char )'a',      (char )'b',      (char )'e',      (char )'l', 
        (char )'2',      (char )' ',      (char )'<',      (char )'l', 
        (char )'a',      (char )'b',      (char )'e',      (char )'l', 
        (char )'>',      (char )']',      (char )' ',      (char )'[', 
        (char )'-',      (char )'l',      (char )'a',      (char )'b', 
        (char )'e',      (char )'l',      (char )'3',      (char )' ', 
        (char )'<',      (char )'l',      (char )'a',      (char )'b', 
        (char )'e',      (char )'l',      (char )'>',      (char )']', 
        (char )'\n',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )'[',      (char )'-',      (char )'i',      (char )'n', 
        (char )'a',      (char )'m',      (char )'e',      (char )' ', 
        (char )'<',      (char )'n',      (char )'a',      (char )'m', 
        (char )'e',      (char )' ',      (char )'l',      (char )'i', 
        (char )'s',      (char )'t',      (char )'>',      (char )']', 
        (char )' ',      (char )'[',      (char )'-',      (char )'i', 
        (char )'c',      (char )'l',      (char )'a',      (char )'s', 
        (char )'s',      (char )' ',      (char )'<',      (char )'c', 
        (char )'l',      (char )'a',      (char )'s',      (char )'s', 
        (char )' ',      (char )'l',      (char )'i',      (char )'s', 
        (char )'t',      (char )'>',      (char )']',      (char )'\n', 
        (char )' ',      (char )' ',      (char )' ',      (char )' ', 
        (char )' ',      (char )' ',      (char )' ',      (char )'[', 
        (char )'-',      (char )'i',      (char )'r',      (char )'e', 
        (char )'v',      (char )'e',      (char )'r',      (char )'s', 
        (char )'e',      (char )']',      (char )' ',      (char )'[', 
        (char )'-',      (char )'i',      (char )'n',      (char )'o', 
        (char )'w',      (char )'i',      (char )'l',      (char )'d', 
        (char )']',      (char )' ',      (char )'|',      (char )' ', 
        (char )'[',      (char )'-',      (char )'h',      (char )'e', 
        (char )'l',      (char )'p',      (char )']',      (char )' ', 
        (char )'|',      (char )' ',      (char )'[',      (char )'-', 
        (char )'v',      (char )'e',      (char )'r',      (char )'s', 
        (char )'i',      (char )'o',      (char )'n',      (char )']', 
        (char )'\n',      (char )'\n',      (char )'T',      (char )'r', 
        (char )'y',      (char )' ',      (char )'\"',      (char )'m', 
        (char )'a',      (char )'n',      (char )' ',      (char )'x', 
        (char )'k',      (char )'b',      (char )'i',      (char )'n', 
        (char )'d',      (char )'\"',      (char )' ',      (char )'f', 
        (char )'o',      (char )'r',      (char )' ',      (char )'m', 
        (char )'o',      (char )'r',      (char )'e',      (char )' ', 
        (char )'i',      (char )'n',      (char )'f',      (char )'o', 
        (char )'r',      (char )'m',      (char )'a',      (char )'t', 
        (char )'i',      (char )'o',      (char )'n',      (char )'.', 
        (char )'\n',      (char )'\000'};
#line 664 "/home/june/repo/benchmarks/collector2/temp/xkbind-2010.05.20/xkbind.c"
void Usage(void) 
{ 


  {
  {
#line 676
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)(msg___0),
          command);
#line 677
  exit(1);
  }
}
}
#line 680 "/home/june/repo/benchmarks/collector2/temp/xkbind-2010.05.20/xkbind.c"
int IsInputWindow(Window window ) 
{ 
  XWMHints *hints ;
  Atom *protocols ;
  int count ;
  int ret ;
  int i ;
  int tmp ;

  {
  {
#line 685
  ret = 0;
#line 687
  hints = XGetWMHints(dpy, window);
  }
#line 688
  if (hints) {
#line 689
    if (hints->flags & 1L) {
#line 689
      if (hints->input) {
#line 689
        ret = 1;
      }
    }
    {
#line 690
    XFree((void *)hints);
    }
  }
#line 693
  if (! ret) {
    {
#line 693
    tmp = XGetWMProtocols(dpy, window, & protocols, & count);
    }
#line 693
    if (tmp) {
#line 695
      i = 0;
      {
#line 695
      while (1) {
        while_continue: /* CIL Label */ ;
#line 695
        if (! (i < count)) {
#line 695
          goto while_break;
        }
#line 696
        if (*(protocols + i) == atoms[3]) {
#line 697
          ret = 1;
#line 698
          goto while_break;
        }
#line 695
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 700
      XFree((void *)protocols);
      }
    }
  }
#line 703
  return (ret);
}
}
#line 706 "/home/june/repo/benchmarks/collector2/temp/xkbind-2010.05.20/xkbind.c"
int IgnoreWindow(Window window ) 
{ 
  XClassHint hints ;
  int ret ;
  int i ;
  int (*Compare)(char const   * , char const   * ) ;
  int ( __attribute__((__nonnull__(1,2), __leaf__)) (*tmp))(char const   *__s1 , char const   *__s2 ) ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 710
  tmp___3 = XGetClassHint(dpy, window, & hints);
  }
#line 710
  if (tmp___3) {
#line 711
    ret = 0;
#line 713
    if ((long )flags & (1L << 2)) {
#line 713
      tmp = (int ( __attribute__((__nonnull__(1,2), __leaf__)) (*))(char const   *__s1 ,
                                                                    char const   *__s2 ))(& PatternMatch);
    } else {
#line 713
      tmp = & strcmp;
    }
#line 713
    Compare = (int (*)(char const   * , char const   * ))tmp;
#line 715
    if (name_list.items) {
#line 715
      if (name_list.count) {
#line 716
        i = 0;
        {
#line 716
        while (1) {
          while_continue: /* CIL Label */ ;
#line 716
          if (! (i < name_list.count)) {
#line 716
            goto while_break;
          }
          {
#line 717
          tmp___0 = (*Compare)((char const   *)*(name_list.items + i), (char const   *)hints.res_name);
          }
#line 717
          if (! tmp___0) {
#line 718
            ret = 1;
#line 719
            goto while_break;
          }
#line 716
          i ++;
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
#line 721
    if (! ret) {
#line 721
      if (class_list.items) {
#line 721
        if (class_list.count) {
#line 722
          i = 0;
          {
#line 722
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 722
            if (! (i < class_list.count)) {
#line 722
              goto while_break___0;
            }
            {
#line 723
            tmp___1 = (*Compare)((char const   *)*(class_list.items + i), (char const   *)hints.res_class);
            }
#line 723
            if (! tmp___1) {
#line 724
              ret = 1;
#line 725
              goto while_break___0;
            }
#line 722
            i ++;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
      }
    }
    {
#line 727
    XFree((void *)hints.res_name);
#line 728
    XFree((void *)hints.res_class);
    }
#line 730
    if ((long )flags & (1L << 1)) {
#line 730
      tmp___2 = ! ret;
    } else {
#line 730
      tmp___2 = ret;
    }
#line 730
    return (tmp___2);
  } else {
#line 732
    return (1);
  }
}
}
#line 735 "/home/june/repo/benchmarks/collector2/temp/xkbind-2010.05.20/xkbind.c"
void ParseList(List *list ) 
{ 
  int in_word ;
  int quoted ;
  char *p ;
  char q ;
  char **items ;
  int index___0 ;
  char *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 741
  quoted = 0;
#line 741
  in_word = quoted;
#line 742
  p = list->res_string;
#line 743
  items = (char **)((void *)0);
#line 743
  list->items = items;
#line 744
  index___0 = 0;
#line 744
  list->count = index___0;
  {
#line 746
  while (1) {
    while_continue: /* CIL Label */ ;
#line 746
    if (! *p) {
#line 746
      goto while_break;
    }
#line 747
    if ((int )*p == 34) {
#line 747
      goto _L___0;
    } else
#line 747
    if ((int )*p == 39) {
      _L___0: /* CIL Label */ 
#line 748
      if (! quoted) {
        {
#line 749
        in_word = 1;
#line 749
        quoted = in_word;
#line 750
        tmp = p;
#line 750
        p ++;
#line 750
        q = *tmp;
#line 751
        tmp___0 = realloc((void *)items, (size_t )((index___0 + 1) * 4));
#line 751
        items = (char **)tmp___0;
#line 752
        tmp___1 = index___0;
#line 752
        index___0 ++;
#line 752
        *(items + tmp___1) = p;
        }
      } else
#line 753
      if ((int )*p == (int )q) {
#line 754
        in_word = 0;
#line 754
        quoted = in_word;
#line 755
        *p = (char )'\000';
      }
    } else
#line 757
    if ((int )*p == 32) {
#line 757
      goto _L;
    } else
#line 757
    if ((int )*p == 9) {
      _L: /* CIL Label */ 
#line 758
      if (in_word) {
#line 759
        in_word = 0;
#line 760
        *p = (char )'\000';
      }
    } else
#line 762
    if (! in_word) {
      {
#line 763
      in_word = 1;
#line 764
      tmp___2 = realloc((void *)items, (size_t )((index___0 + 1) * 4));
#line 764
      items = (char **)tmp___2;
#line 765
      tmp___3 = index___0;
#line 765
      index___0 ++;
#line 765
      *(items + tmp___3) = p;
      }
    }
#line 767
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 770
  if (! quoted) {
#line 771
    list->count = index___0;
#line 772
    list->items = items;
  } else {
    {
#line 775
    free((void *)items);
    }
  }
#line 776
  return;
}
}
#line 782 "/home/june/repo/benchmarks/collector2/temp/xkbind-2010.05.20/xkbind.c"
int PatternMatch(char const   *p , char const   *s ) 
{ 
  char *subp ;
  char *subs ;
  int esc ;

  {
#line 784
  subp = (char *)((void *)0);
  {
#line 787
  while (1) {
    while_continue: /* CIL Label */ ;
#line 787
    if (*p) {
#line 787
      if (! *s) {
#line 787
        goto while_break;
      }
    } else {
#line 787
      goto while_break;
    }
#line 788
    esc = (int const   )*p == 92;
#line 788
    if (esc) {
#line 788
      p ++;
    }
#line 789
    if ((int const   )*p == 42) {
#line 789
      if (! esc) {
#line 790
        p ++;
#line 790
        if (! *p) {
#line 790
          return (0);
        }
#line 791
        subp = (char *)p;
#line 792
        subs = (char *)s;
      } else {
#line 789
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 793
    if ((int const   )*p == 63) {
#line 793
      if (! esc) {
#line 794
        p ++;
#line 794
        s ++;
#line 795
        if (subp) {
#line 795
          if (! *p) {
#line 795
            if (*s) {
#line 796
              p = (char const   *)subp;
#line 797
              subs ++;
#line 797
              s = (char const   *)subs;
            }
          }
        }
      } else {
#line 793
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 799
    if ((int const   )*p == (int const   )*s) {
#line 800
      p ++;
#line 800
      s ++;
    } else
#line 801
    if (subp) {
#line 802
      p = (char const   *)subp;
#line 803
      subs ++;
#line 803
      s = (char const   *)subs;
    } else {
#line 804
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 806
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 806
    if (! ((int const   )*p == 42)) {
#line 806
      goto while_break___0;
    }
#line 806
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 807
  return ((int const   )*p != (int const   )*s);
}
}
#line 810 "/home/june/repo/benchmarks/collector2/temp/xkbind-2010.05.20/xkbind.c"
resvals ResValue(char const   *s ) 
{ 
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 812
  ret = -1;
#line 814
  tmp___2 = strcasecmp(s, "on");
  }
#line 814
  if (tmp___2) {
    {
#line 814
    tmp___3 = strcasecmp(s, "yes");
    }
#line 814
    if (tmp___3) {
      {
#line 814
      tmp___4 = strcasecmp(s, "true");
      }
#line 814
      if (tmp___4) {
        {
#line 816
        tmp = strcasecmp(s, "off");
        }
#line 816
        if (tmp) {
          {
#line 816
          tmp___0 = strcasecmp(s, "no");
          }
#line 816
          if (tmp___0) {
            {
#line 816
            tmp___1 = strcasecmp(s, "false");
            }
#line 816
            if (! tmp___1) {
#line 817
              ret = 0;
            }
          } else {
#line 817
            ret = 0;
          }
        } else {
#line 817
          ret = 0;
        }
      } else {
#line 815
        ret = 1;
      }
    } else {
#line 815
      ret = 1;
    }
  } else {
#line 815
    ret = 1;
  }
#line 819
  return ((resvals )ret);
}
}
#line 822 "/home/june/repo/benchmarks/collector2/temp/xkbind-2010.05.20/xkbind.c"
void SigHandler(int sig_num ) 
{ 


  {
#line 827
  term = (sig_atomic_t volatile   )sig_num;
#line 828
  return;
}
}
#line 830 "/home/june/repo/benchmarks/collector2/temp/xkbind-2010.05.20/xkbind.c"
int ErrHandler(Display *dpy___0 , XErrorEvent *err_event ) 
{ 


  {
#line 832
  if ((int )err_event->error_code == 3) {
#line 836
    return (0);
  }
  {
#line 843
  (*DefErrHandler)(dpy___0, err_event);
  }
#line 844
  return (0);
}
}
#line 847 "/home/june/repo/benchmarks/collector2/temp/xkbind-2010.05.20/xkbind.c"
void SetSignals(void) 
{ 
  struct sigaction sa ;
  sigset_t sig_mask ;

  {
  {
#line 852
  memset((void *)(& sa), 0, sizeof(sa));
#line 853
  sa.__sigaction_handler.sa_handler = (void (*)(int  ))1;
#line 856
  sigaction(14, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 857
  sigaction(26, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 858
  sigaction(27, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 859
  sigaction(1, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 861
  sa.__sigaction_handler.sa_handler = & SigHandler;
#line 862
  sigfillset(& sig_mask);
#line 863
  sa.sa_mask = sig_mask;
#line 866
  sigaction(2, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 867
  sigaction(15, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 868
  sigaction(3, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
#line 869
  sigaction(6, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
  }
#line 870
  return;
}
}
#line 873 "/home/june/repo/benchmarks/collector2/temp/xkbind-2010.05.20/xkbind.c"
void Deamonize(void) 
{ 
  int i ;
  __pid_t tmp ;

  {
  {
#line 877
  tmp = fork();
  }
  {
#line 878
  if (tmp == -1) {
#line 878
    goto case_neg_1;
  }
#line 881
  if (tmp == 0) {
#line 881
    goto case_0;
  }
#line 891
  goto switch_default;
  case_neg_1: /* CIL Label */ 
  {
#line 879
  perror((char const   *)command);
  }
#line 880
  return;
  case_0: /* CIL Label */ 
  {
#line 882
  setsid();
#line 883
  umask((__mode_t )0);
#line 884
  chdir("/");
#line 885
  i = 2;
  }
  {
#line 885
  while (1) {
    while_continue: /* CIL Label */ ;
#line 885
    if (! (i >= 0)) {
#line 885
      goto while_break;
    }
    {
#line 885
    close(i);
#line 885
    i --;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 886
  i = open("/dev/null", 2);
  }
#line 886
  if (i != -1) {
    {
#line 887
    dup(i);
#line 888
    dup(i);
    }
  }
#line 890
  return;
  switch_default: /* CIL Label */ 
  {
#line 892
  exit(0);
  }
  switch_break: /* CIL Label */ ;
  }
}
}
