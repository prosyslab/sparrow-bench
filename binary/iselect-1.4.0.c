/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 31 "/home/june/repo/benchmarks/collector/temp/iselect-1.4.0/iselect_keys.h"
struct CustomKey {
   int in ;
   int out ;
};
#line 31 "/home/june/repo/benchmarks/collector/temp/iselect-1.4.0/iselect_keys.h"
typedef struct CustomKey CustomKey;
#line 53 "/home/june/repo/benchmarks/collector/temp/iselect-1.4.0/iselect_keys.c"
struct keydef {
   char *str ;
   int key ;
};
#line 53 "/home/june/repo/benchmarks/collector/temp/iselect-1.4.0/iselect_keys.c"
typedef struct keydef keydef;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 150 "/usr/include/curses.h"
typedef unsigned long chtype;
#line 358
struct _win_st;
#line 358 "/usr/include/curses.h"
typedef struct _win_st WINDOW;
#line 360 "/usr/include/curses.h"
typedef chtype attr_t;
#line 405
struct ldat;
#line 407 "/usr/include/curses.h"
struct pdat {
   short _pad_y ;
   short _pad_x ;
   short _pad_top ;
   short _pad_left ;
   short _pad_bottom ;
   short _pad_right ;
};
#line 407 "/usr/include/curses.h"
struct _win_st {
   short _cury ;
   short _curx ;
   short _maxy ;
   short _maxx ;
   short _begy ;
   short _begx ;
   short _flags ;
   attr_t _attrs ;
   chtype _bkgd ;
   _Bool _notimeout ;
   _Bool _clear ;
   _Bool _leaveok ;
   _Bool _scroll ;
   _Bool _idlok ;
   _Bool _idcok ;
   _Bool _immed ;
   _Bool _sync ;
   _Bool _use_keypad ;
   int _delay ;
   struct ldat *_line ;
   short _regtop ;
   short _regbottom ;
   int _parx ;
   int _pary ;
   WINDOW *_parent ;
   struct pdat _pad ;
   short _yoffset ;
};
#line 34 "/home/june/repo/benchmarks/collector/temp/iselect-1.4.0/iselect_browse.h"
struct Line {
   char *cpLine ;
   int fSelectable ;
   int fSelected ;
   char *cpResult ;
};
#line 13 "/home/june/repo/benchmarks/collector/temp/iselect-1.4.0/iselect_version.c"
struct __anonstruct_iselect_version_t_1 {
   int const   v_hex ;
   char const   *v_short ;
   char const   *v_long ;
   char const   *v_tex ;
   char const   *v_gnu ;
   char const   *v_web ;
   char const   *v_sccs ;
   char const   *v_rcs ;
};
#line 13 "/home/june/repo/benchmarks/collector/temp/iselect-1.4.0/iselect_version.c"
typedef struct __anonstruct_iselect_version_t_1 iselect_version_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 109 "/home/june/repo/benchmarks/collector/temp/iselect-1.4.0/iselect_getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/iselect-1.4.0/iselect_keys.h"
void configure_custom_key(char *config ) ;
#line 37
int do_custom_key(int key ) ;
#line 38
char *key2asc(int key ) ;
#line 39
int asc2key(char *str ) ;
#line 51 "/home/june/repo/benchmarks/collector/temp/iselect-1.4.0/iselect_keys.c"
CustomKey *KeyList[1024]  = {      (CustomKey *)((void *)0)};
#line 58 "/home/june/repo/benchmarks/collector/temp/iselect-1.4.0/iselect_keys.c"
keydef KeyDef[9]  = 
#line 58
  {      {(char *)"SPACE", ' '}, 
        {(char *)"RETURN", '\n'}, 
        {(char *)"KEY_LEFT", 260}, 
        {(char *)"KEY_RIGHT", 261}, 
        {(char *)"KEY_UP", 259}, 
        {(char *)"KEY_DOWN", 258}, 
        {(char *)"KEY_NPAGE", 338}, 
        {(char *)"KEY_PPAGE", 339}, 
        {(char *)((void *)0), 0}};
#line 70 "/home/june/repo/benchmarks/collector/temp/iselect-1.4.0/iselect_keys.c"
char *key2asc(int key ) 
{ 
  char ca[1024] ;
  int i ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 75
  if (key >= 32) {
#line 75
    if (key <= 126) {
      {
#line 76
      ca[0] = (char )key;
#line 77
      ca[1] = (char )'\000';
#line 78
      tmp = strdup((char const   *)(ca));
      }
#line 78
      return (tmp);
    } else {
#line 75
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 81
    i = 0;
    {
#line 81
    while (1) {
      while_continue: /* CIL Label */ ;
#line 81
      if (! ((unsigned long )KeyDef[i].str != (unsigned long )((void *)0))) {
#line 81
        goto while_break;
      }
#line 82
      if (KeyDef[i].key == key) {
        {
#line 83
        tmp___0 = strdup((char const   *)KeyDef[i].str);
        }
#line 83
        return (tmp___0);
      }
#line 81
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 86
  return ((char *)"UNKNOWN");
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/iselect-1.4.0/iselect_keys.c"
int asc2key(char *str ) 
{ 
  int i ;
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 93
  tmp___0 = strlen((char const   *)str);
  }
#line 93
  if (tmp___0 == 1UL) {
#line 93
    if ((int )*(str + 0) >= 32) {
#line 93
      if ((int )*(str + 0) <= 126) {
#line 94
        return ((int )*(str + 0));
      } else {
#line 93
        goto _L;
      }
    } else {
#line 93
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 96
    i = 0;
    {
#line 96
    while (1) {
      while_continue: /* CIL Label */ ;
#line 96
      if (! ((unsigned long )KeyDef[i].str != (unsigned long )((void *)0))) {
#line 96
        goto while_break;
      }
      {
#line 97
      tmp = strcmp((char const   *)KeyDef[i].str, (char const   *)str);
      }
#line 97
      if (tmp == 0) {
#line 98
        return (KeyDef[i].key);
      }
#line 96
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 100
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR\n");
#line 101
    exit(1);
    }
  }
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/iselect-1.4.0/iselect_keys.c"
void configure_custom_key(char *config ) 
{ 
  char out[1024] ;
  char in[1024] ;
  char *cp ;
  CustomKey *kc ;
  int i ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 113
  cp = strchr((char const   *)config, ':');
  }
#line 113
  if ((unsigned long )cp != (unsigned long )((void *)0)) {
    {
#line 114
    strncpy((char */* __restrict  */)(in), (char const   */* __restrict  */)config,
            (size_t )(cp - config));
#line 115
    in[cp - config] = (char )'\000';
#line 116
    strcpy((char */* __restrict  */)(out), (char const   */* __restrict  */)(cp + 1));
    }
  } else {
    {
#line 119
    strcpy((char */* __restrict  */)(in), (char const   */* __restrict  */)config);
#line 120
    strcpy((char */* __restrict  */)(out), (char const   */* __restrict  */)"RETURN");
    }
  }
  {
#line 123
  tmp = malloc(sizeof(CustomKey ));
#line 123
  kc = (CustomKey *)tmp;
#line 124
  kc->in = asc2key(in);
#line 125
  kc->out = asc2key(out);
#line 127
  i = 0;
  }
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 127
    if (! ((unsigned long )KeyList[i] != (unsigned long )((void *)0))) {
#line 127
      goto while_break;
    }
#line 127
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 129
  tmp___0 = i;
#line 129
  i ++;
#line 129
  KeyList[tmp___0] = kc;
#line 130
  tmp___1 = i;
#line 130
  i ++;
#line 130
  KeyList[tmp___1] = (CustomKey *)((void *)0);
#line 132
  return;
}
}
#line 135 "/home/june/repo/benchmarks/collector/temp/iselect-1.4.0/iselect_keys.c"
int do_custom_key(int key ) 
{ 
  int i ;

  {
#line 139
  i = 0;
  {
#line 139
  while (1) {
    while_continue: /* CIL Label */ ;
#line 139
    if (! ((unsigned long )KeyList[i] != (unsigned long )((void *)0))) {
#line 139
      goto while_break;
    }
#line 140
    if ((KeyList[i])->in == key) {
#line 141
      key = (KeyList[i])->out;
    }
#line 139
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 143
  return (key);
}
}
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 538
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 587 "/usr/include/curses.h"
extern int cbreak(void) ;
#line 603
extern int delwin(WINDOW * ) ;
#line 608
extern int echo(void) ;
#line 611
extern int endwin(void) ;
#line 632
extern WINDOW *initscr(void) ;
#line 647
extern int keypad(WINDOW * , _Bool  ) ;
#line 659
extern int mvcur(int  , int  , int  , int  ) ;
#line 707
extern WINDOW *newwin(int  , int  , int  , int  ) ;
#line 709
extern int nocbreak(void) ;
#line 711
extern int noecho(void) ;
#line 741
extern int scrollok(WINDOW * , _Bool  ) ;
#line 785
extern int waddch(WINDOW * , chtype const    ) ;
#line 788
extern int waddnstr(WINDOW * , char const   * , int  ) ;
#line 803
extern int wclrtoeol(WINDOW * ) ;
#line 809
extern int werase(WINDOW * ) ;
#line 810
extern int wgetch(WINDOW * ) ;
#line 824
extern int wmove(WINDOW * , int  , int  ) ;
#line 828
extern int wredrawln(WINDOW * , int  , int  ) ;
#line 829
extern int wrefresh(WINDOW * ) ;
#line 832
extern int wscrl(WINDOW * , int  ) ;
#line 1390
extern int COLS ;
#line 1392
extern int LINES ;
#line 34 "/home/june/repo/benchmarks/collector/temp/iselect-1.4.0/iselect_browse.h"
struct Line Line  ;
#line 41 "/home/june/repo/benchmarks/collector/temp/iselect-1.4.0/iselect_browse.h"
struct Line **spaLines  ;
#line 42 "/home/june/repo/benchmarks/collector/temp/iselect-1.4.0/iselect_browse.h"
int nLines  ;
#line 47
int iSelect(char *caBuf , int pos , char *title , char *name , char *tagbegin , char *tagend ,
            int stripco , int stripws , int browsealways , int allselectable , int multiselect ,
            int exitnoselect , char **keystr ) ;
#line 52 "/home/june/repo/benchmarks/collector/temp/iselect-1.4.0/iselect_browse.c"
char *iSelect_Help[29] ;
#line 53
char *iSelect_README[35] ;
#line 55
void strip(char *string ) ;
#line 56
void diehard(void) ;
#line 57
void diesoft(void) ;
#line 58
void diealloc(void) ;
#line 59
void *smalloc(size_t size ) ;
#line 60
void *srealloc(void *ptr , size_t size ) ;
#line 61
void setup(void) ;
#line 62
char *iSelect_InputField(int wYSize , int wXSize , int wYPos , int wXPos , int bAllowEmpty ) ;
#line 63
void iSelect_Draw(WINDOW *wField , int wYSize , int wXSize , int wYPos , int wXPos ,
                  int nAbsFirstLine , int nAbsLastLine , int nRelMarked , int nRelFirstDraw ,
                  int nRelLastDraw , int nLines___0 , WINDOW *sField , char *title ,
                  char *name , WINDOW *mField , char *msg , char *tagbegin , char *tagend ) ;
#line 71
int iSelect_Browser(int wYSize , int wXSize , int wYPos , int wXPos , int selectpos ,
                    int multiselect , int sYSize , int sXSize , int sYPos , int sXPos ,
                    char *title , char *name , int mYSize , int mXSize , int mYPos ,
                    int mXPos , char **keystr , char *tagbegin , char *tagend ) ;
#line 92 "/home/june/repo/benchmarks/collector/temp/iselect-1.4.0/iselect_browse.c"
void strip(char *string ) 
{ 
  char *cps ;
  char *cp ;
  char *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;

  {
#line 97
  if ((unsigned long )string != (unsigned long )((void *)0)) {
#line 99
    cps = string;
#line 100
    cp = string;
    {
#line 101
    while (1) {
      while_continue: /* CIL Label */ ;
#line 101
      if ((int )*cp == 32) {
#line 101
        goto _L;
      } else
#line 101
      if ((int )*cp == 9) {
        _L: /* CIL Label */ 
#line 101
        if (! ((int )*cp != 0)) {
#line 101
          goto while_break;
        }
      } else {
#line 101
        goto while_break;
      }
#line 102
      cp ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 103
    if ((unsigned long )cp > (unsigned long )cps) {
      {
#line 104
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 104
        if (! ((int )*cp != 0)) {
#line 104
          goto while_break___0;
        }
#line 105
        tmp = cps;
#line 105
        cps ++;
#line 105
        tmp___0 = cp;
#line 105
        cp ++;
#line 105
        *tmp = *tmp___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 106
      *cps = (char )'\000';
    }
    {
#line 109
    tmp___1 = strlen((char const   *)string);
#line 109
    cp = string + tmp___1;
    }
    {
#line 110
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 110
      if ((unsigned long )cp > (unsigned long )string) {
#line 110
        if (! ((int )*(cp - 1) == 32)) {
#line 110
          if (! ((int )*(cp - 1) == 9)) {
#line 110
            goto while_break___1;
          }
        }
      } else {
#line 110
        goto while_break___1;
      }
#line 111
      cp --;
#line 111
      *cp = (char )'\000';
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 113
  return;
}
}
#line 119 "/home/june/repo/benchmarks/collector/temp/iselect-1.4.0/iselect_browse.c"
void diehard(void) 
{ 


  {
  {
#line 121
  signal(2, (void (*)(int  ))1);
#line 122
  signal(15, (void (*)(int  ))1);
#line 124
  mvcur(0, COLS - 1, LINES - 1, 0);
#line 126
  endwin();
#line 127
  exit(0);
  }
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/iselect-1.4.0/iselect_browse.c"
void diesoft(void) 
{ 


  {
  {
#line 133
  mvcur(0, COLS - 1, LINES - 1, 0);
#line 135
  endwin();
  }
#line 136
  return;
}
}
#line 138 "/home/june/repo/benchmarks/collector/temp/iselect-1.4.0/iselect_browse.c"
void diealloc(void) 
{ 


  {
  {
#line 140
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Memory allocation error... aborting\n");
#line 141
  diesoft();
#line 142
  exit(71);
  }
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/iselect-1.4.0/iselect_browse.c"
void *smalloc(size_t size ) 
{ 
  char *ptr ;
  void *tmp ;

  {
  {
#line 147
  tmp = malloc(size);
#line 147
  ptr = (char *)tmp;
  }
#line 148
  if ((unsigned long )((void *)0) == (unsigned long )ptr) {
    {
#line 149
    diealloc();
    }
  }
#line 150
  return ((void *)ptr);
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/iselect-1.4.0/iselect_browse.c"
void *srealloc(void *ptr , size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 155
  tmp = realloc(ptr, size);
#line 155
  ptr = tmp;
  }
#line 156
  if ((unsigned long )((void *)0) == (unsigned long )ptr) {
    {
#line 157
    diealloc();
    }
  }
#line 158
  return (ptr);
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/iselect-1.4.0/iselect_browse.c"
void setup(void) 
{ 


  {
  {
#line 166
  signal(2, (void (*)(int  ))((void *)(& diehard)));
#line 167
  signal(15, (void (*)(int  ))((void *)(& diehard)));
#line 168
  initscr();
  }
#line 169
  return;
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/iselect-1.4.0/iselect_browse.c"
char *iSelect_InputField(int wYSize , int wXSize , int wYPos , int wXPos , int bAllowEmpty ) 
{ 
  WINDOW *wField ;
  int c ;
  int nBufEnd ;
  int nBufCurPos ;
  int nScrCurPos ;
  int bEOI ;
  char *cpBuf ;
  int cpBufLen ;
  int i ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 187
  cpBufLen = 1024;
#line 188
  tmp = smalloc((size_t )(cpBufLen + 1));
#line 188
  cpBuf = (char *)tmp;
#line 189
  *(cpBuf + 0) = (char )'\000';
#line 191
  wField = newwin(wYSize, wXSize, wYPos, wXPos);
#line 192
  keypad(wField, (_Bool)1);
#line 193
  scrollok(wField, (_Bool)0);
#line 195
  nScrCurPos = 0;
#line 196
  nBufCurPos = 0;
#line 197
  nBufEnd = 0;
#line 198
  bEOI = 0;
#line 200
  wmove(wField, 0, nScrCurPos);
  }
  {
#line 201
  while (1) {
    while_continue: /* CIL Label */ ;
#line 201
    if (! (bEOI == 0)) {
#line 201
      goto while_break;
    }
    {
#line 202
    c = wgetch(wField);
    }
#line 203
    if (c >= 257) {
#line 203
      if (! (c <= 511)) {
#line 203
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 207
      c &= 255;
#line 208
      if (c < 32) {
#line 208
        goto _L;
      } else
#line 208
      if (c > 126) {
        _L: /* CIL Label */ 
#line 212
        if (c == 10) {
#line 213
          if (nBufEnd == 0) {
#line 213
            if (! bAllowEmpty) {
#line 214
              goto while_continue;
            }
          }
#line 215
          *(cpBuf + nBufEnd) = (char )'\000';
#line 216
          bEOI = 1;
        } else
#line 218
        if (c == 27) {
          {
#line 219
          strcpy((char */* __restrict  */)cpBuf, (char const   */* __restrict  */)"ESC");
#line 220
          bEOI = 1;
          }
        } else
#line 222
        if (c == 4) {
          {
#line 223
          waddch(wField, (chtype const   )'?');
#line 224
          wrefresh(wField);
          }
        } else
#line 226
        if (c == 127) {
#line 227
          if (nBufCurPos != 0) {
#line 228
            i = nBufCurPos;
            {
#line 228
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 228
              if (! (i < nBufEnd)) {
#line 228
                goto while_break___0;
              }
#line 229
              *(cpBuf + (i - 1)) = *(cpBuf + i);
#line 228
              i ++;
            }
            while_break___0: /* CIL Label */ ;
            }
#line 231
            *(cpBuf + i) = (char )'\000';
#line 232
            nBufEnd --;
#line 233
            nBufCurPos --;
#line 235
            if (nScrCurPos == wXSize - 1) {
#line 235
              if (nBufEnd >= wXSize - 1) {
                {
#line 236
                wmove(wField, 0, 0);
#line 237
                i = nBufEnd - (wXSize - 1);
                }
                {
#line 237
                while (1) {
                  while_continue___1: /* CIL Label */ ;
#line 237
                  if (! (i < nBufEnd)) {
#line 237
                    goto while_break___1;
                  }
                  {
#line 238
                  waddch(wField, (chtype const   )*(cpBuf + i));
#line 237
                  i ++;
                  }
                }
                while_break___1: /* CIL Label */ ;
                }
              } else {
                {
#line 242
                nScrCurPos --;
#line 243
                wmove(wField, 0, nScrCurPos);
#line 244
                waddch(wField, (chtype const   )' ');
#line 245
                wmove(wField, 0, nScrCurPos);
                }
              }
            } else {
              {
#line 242
              nScrCurPos --;
#line 243
              wmove(wField, 0, nScrCurPos);
#line 244
              waddch(wField, (chtype const   )' ');
#line 245
              wmove(wField, 0, nScrCurPos);
              }
            }
            {
#line 247
            wrefresh(wField);
            }
          }
        }
      }
#line 251
      if (c >= 32) {
#line 251
        if (c <= 126) {
#line 255
          if (nScrCurPos == wXSize - 1) {
            {
#line 256
            wmove(wField, 0, 0);
#line 257
            i = (nBufEnd - (wXSize - 1)) + 1;
            }
            {
#line 257
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 257
              if (! (i < nBufEnd)) {
#line 257
                goto while_break___2;
              }
              {
#line 258
              waddch(wField, (chtype const   )*(cpBuf + i));
#line 257
              i ++;
              }
            }
            while_break___2: /* CIL Label */ ;
            }
#line 260
            nScrCurPos --;
          }
#line 262
          if (nBufEnd >= cpBufLen) {
            {
#line 263
            cpBufLen += 1024;
#line 264
            tmp___0 = srealloc((void *)cpBuf, (size_t )(cpBufLen + 1));
#line 264
            cpBuf = (char *)tmp___0;
            }
          }
          {
#line 266
          tmp___1 = nBufEnd;
#line 266
          nBufEnd ++;
#line 266
          *(cpBuf + tmp___1) = (char )c;
#line 267
          nBufCurPos ++;
#line 268
          nScrCurPos ++;
#line 269
          waddch(wField, (chtype const   )c);
#line 270
          wrefresh(wField);
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 275
  fflush(stdin);
#line 276
  delwin(wField);
  }
#line 278
  return (cpBuf);
}
}
#line 284 "/home/june/repo/benchmarks/collector/temp/iselect-1.4.0/iselect_browse.c"
void iSelect_Draw(WINDOW *wField , int wYSize , int wXSize , int wYPos , int wXPos ,
                  int nAbsFirstLine , int nAbsLastLine , int nRelMarked , int nRelFirstDraw ,
                  int nRelLastDraw , int nLines___0 , WINDOW *sField , char *title ,
                  char *name , WINDOW *mField , char *msg , char *tagbegin , char *tagend ) 
{ 
  int i ;
  int j ;
  int k ;
  int mode ;
  int percent ;
  char ca[80] ;
  char *boldbegin ;
  int nboldbegin ;
  char *boldend ;
  int nboldend ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;

  {
  {
#line 305
  tmp = strlen((char const   *)tagbegin);
#line 305
  tmp___0 = strlen((char const   *)tagend);
#line 305
  tmp___1 = smalloc((tmp + tmp___0) + 2UL);
#line 305
  boldbegin = (char *)tmp___1;
#line 306
  sprintf((char */* __restrict  */)boldbegin, (char const   */* __restrict  */)"%sb%s",
          tagbegin, tagend);
#line 307
  tmp___2 = strlen((char const   *)boldbegin);
#line 307
  nboldbegin = (int )tmp___2;
#line 309
  tmp___3 = strlen((char const   *)tagbegin);
#line 309
  tmp___4 = strlen((char const   *)tagend);
#line 309
  tmp___5 = smalloc((tmp___3 + tmp___4) + 3UL);
#line 309
  boldend = (char *)tmp___5;
#line 310
  sprintf((char */* __restrict  */)boldend, (char const   */* __restrict  */)"%s/b%s",
          tagbegin, tagend);
#line 311
  tmp___6 = strlen((char const   *)boldend);
#line 311
  nboldend = (int )tmp___6;
#line 316
  i = nRelFirstDraw;
  }
  {
#line 316
  while (1) {
    while_continue: /* CIL Label */ ;
#line 316
    if (! (i <= nRelLastDraw)) {
#line 316
      goto while_break;
    }
    {
#line 317
    wmove(wField, i, 0);
#line 318
    wclrtoeol(wField);
#line 319
    mode = 0;
    }
#line 320
    if ((*(spaLines + ((nAbsFirstLine + nRelFirstDraw) + i)))->fSelectable) {
#line 321
      mode = (int )((unsigned long )mode | (1UL << 21));
    }
#line 322
    if (i == nRelMarked) {
#line 326
      mode = (int )((unsigned long )mode | (1UL << 18));
    }
#line 328
    if (wField) {
#line 328
      wField->_attrs = (attr_t )mode;
    }
#line 329
    if ((*(spaLines + ((nAbsFirstLine + nRelFirstDraw) + i)))->fSelected) {
      {
#line 330
      waddnstr(wField, "*", -1);
      }
    } else {
      {
#line 332
      waddnstr(wField, " ", -1);
      }
    }
#line 333
    k = 0;
#line 333
    j = k;
    {
#line 333
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 333
      if ((int )*((*(spaLines + ((nAbsFirstLine + nRelFirstDraw) + i)))->cpLine + j) != 0) {
#line 333
        if (! (k <= (wXSize - 1) - 2)) {
#line 333
          goto while_break___0;
        }
      } else {
#line 333
        goto while_break___0;
      }
      {
#line 334
      tmp___7 = strncasecmp((char const   *)((*(spaLines + ((nAbsFirstLine + nRelFirstDraw) + i)))->cpLine + j),
                            (char const   *)boldbegin, (size_t )nboldbegin);
      }
#line 334
      if (! tmp___7) {
#line 335
        mode = (int )((unsigned long )mode | (1UL << 21));
#line 336
        if (wField) {
#line 336
          wField->_attrs = (attr_t )mode;
        }
#line 337
        j += nboldbegin;
#line 338
        goto __Cont;
      }
      {
#line 340
      tmp___8 = strncasecmp((char const   *)((*(spaLines + ((nAbsFirstLine + nRelFirstDraw) + i)))->cpLine + j),
                            (char const   *)boldend, (size_t )nboldend);
      }
#line 340
      if (! tmp___8) {
#line 341
        mode = (int )((unsigned long )mode & ~ (1UL << 21));
#line 342
        if (wField) {
#line 342
          wField->_attrs = (attr_t )mode;
        }
#line 343
        j += nboldend;
#line 344
        goto __Cont;
      }
      {
#line 346
      waddch(wField, (chtype const   )*((*(spaLines + ((nAbsFirstLine + nRelFirstDraw) + i)))->cpLine + j));
#line 347
      j ++;
#line 348
      k ++;
      }
      __Cont: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 350
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 350
      if (! (k <= (wXSize - 1) - 2)) {
#line 350
        goto while_break___1;
      }
      {
#line 351
      waddch(wField, (chtype const   )' ');
#line 350
      k ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 352
    if (wField) {
#line 352
      wField->_attrs = 0UL;
    }
#line 316
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 354
  wmove(wField, nRelMarked, (wXSize - 1) - 1);
#line 355
  free((void *)boldbegin);
#line 356
  free((void *)boldend);
#line 361
  werase(sField);
  }
#line 362
  if (sField) {
#line 362
    sField->_attrs = 1UL << 18;
  }
  {
#line 363
  wmove(sField, 0, 0);
#line 364
  i = 0;
  }
  {
#line 364
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 364
    if (! (i < COLS)) {
#line 364
      goto while_break___2;
    }
    {
#line 365
    waddch(sField, (chtype const   )' ');
#line 364
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 368
  wmove(sField, 0, 1);
#line 369
  waddnstr(sField, (char const   *)name, -1);
#line 371
  wmove(sField, 0, COLS - 10);
  }
#line 372
  if ((1 + nAbsFirstLine) + nRelMarked == nLines___0) {
#line 373
    percent = 100;
  } else
#line 372
  if (nLines___0 == 0) {
#line 373
    percent = 100;
  } else {
#line 375
    percent = ((nAbsFirstLine + nRelMarked) * 100) / nLines___0;
  }
  {
#line 376
  sprintf((char */* __restrict  */)(ca), (char const   */* __restrict  */)"%4d,%3d%%",
          (1 + nAbsFirstLine) + nRelMarked, percent);
#line 377
  waddnstr(sField, (char const   *)(ca), -1);
#line 379
  tmp___9 = strlen((char const   *)title);
#line 379
  i = (int )((size_t )((COLS - 1) / 2) - tmp___9 / 2UL);
#line 380
  wmove(sField, 0, i);
#line 381
  waddnstr(sField, (char const   *)title, -1);
  }
#line 383
  if (sField) {
#line 383
    sField->_attrs = 0UL;
  }
  {
#line 384
  wrefresh(sField);
#line 389
  werase(mField);
#line 390
  wmove(mField, 0, 0);
#line 391
  waddnstr(mField, (char const   *)msg, -1);
#line 392
  wrefresh(mField);
  }
#line 394
  return;
}
}
#line 400 "/home/june/repo/benchmarks/collector/temp/iselect-1.4.0/iselect_browse.c"
int iSelect_Browser(int wYSize , int wXSize , int wYPos , int wXPos , int selectpos ,
                    int multiselect , int sYSize , int sXSize , int sYPos , int sXPos ,
                    char *title , char *name , int mYSize , int mXSize , int mYPos ,
                    int mXPos , char **keystr , char *tagbegin , char *tagend ) 
{ 
  WINDOW *wField ;
  WINDOW *sField ;
  WINDOW *mField ;
  WINDOW *hField ;
  int i ;
  int nFirstLine ;
  int nLastLine ;
  int nAbsFirstLine ;
  int nAbsLastLine ;
  int nRelMarked ;
  int nRelFirstDraw ;
  int nRelLastDraw ;
  int c ;
  int bEOI ;
  int bQuit ;
  int y ;
  int x ;
  int voffset ;
  char msg[128] ;
  int caLen ;
  char *ca ;
  char *ca3 ;
  char *cp ;
  char *cp2 ;
  char *cp3 ;
  char **cpp ;
  int cppsize ;
  int ok ;
  int bAllowEmpty ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  int tmp___15 ;

  {
  {
#line 416
  bQuit = 0;
#line 436
  wField = newwin(wYSize, wXSize, wYPos, wXPos);
#line 437
  werase(wField);
#line 438
  cbreak();
#line 439
  noecho();
#line 440
  keypad(wField, (_Bool)1);
#line 441
  scrollok(wField, (_Bool)0);
#line 446
  sField = newwin(sYSize, sXSize, sYPos, sXPos);
#line 447
  werase(sField);
#line 448
  strcpy((char */* __restrict  */)(msg), (char const   */* __restrict  */)"");
#line 453
  mField = newwin(mYSize, mXSize, mYPos, mXPos);
#line 454
  werase(mField);
#line 457
  nFirstLine = 0;
#line 458
  nLastLine = nLines - 1;
  }
#line 461
  if (selectpos < -1) {
#line 462
    selectpos = -1;
  }
#line 463
  if (selectpos > nLastLine) {
#line 464
    selectpos = nLastLine;
  }
#line 465
  if (selectpos == -1) {
#line 466
    selectpos = 0;
#line 468
    i = nFirstLine;
    {
#line 468
    while (1) {
      while_continue: /* CIL Label */ ;
#line 468
      if (! (i < nLastLine)) {
#line 468
        goto while_break;
      }
#line 469
      if ((*(spaLines + i))->fSelectable) {
#line 470
        selectpos = i;
#line 471
        goto while_break;
      }
#line 468
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 477
  if (nLastLine < wYSize - 1) {
#line 480
    nAbsFirstLine = nFirstLine;
#line 481
    nAbsLastLine = nLastLine;
#line 482
    nRelFirstDraw = 0;
#line 483
    nRelLastDraw = nLastLine - nFirstLine;
#line 484
    nRelMarked = selectpos;
  } else {
#line 491
    y = selectpos - (wYSize - 1) / 2;
#line 492
    if (y <= 0) {
#line 493
      y = 0;
    }
#line 494
    if (y + (wYSize - 1) > nLastLine) {
#line 495
      y = nLastLine - (wYSize - 1);
    }
#line 497
    nAbsFirstLine = y;
#line 498
    nAbsLastLine = y + (wYSize - 1);
#line 499
    nRelFirstDraw = 0;
#line 500
    nRelLastDraw = wYSize - 1;
#line 501
    nRelMarked = selectpos - y;
  }
#line 505
  ok = 0;
#line 506
  i = nFirstLine;
  {
#line 506
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 506
    if (! (i < nLastLine)) {
#line 506
      goto while_break___0;
    }
#line 507
    if ((*(spaLines + i))->fSelectable) {
#line 508
      ok = 1;
#line 509
      goto while_break___0;
    }
#line 506
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 512
  if (! ok) {
    {
#line 513
    strcpy((char */* __restrict  */)(msg), (char const   */* __restrict  */)"WARNING! No lines selectable.");
    }
  }
#line 516
  bEOI = 0;
  {
#line 517
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 517
    if (! (bEOI == 0)) {
#line 517
      goto while_break___1;
    }
    {
#line 518
    iSelect_Draw(wField, wYSize, wXSize, wYPos, wXPos, nAbsFirstLine, nAbsLastLine,
                 nRelMarked, nRelFirstDraw, nRelLastDraw, nLines, sField, title, name,
                 mField, msg, tagbegin, tagend);
#line 527
    wrefresh(wField);
#line 528
    strcpy((char */* __restrict  */)(msg), (char const   */* __restrict  */)"");
#line 529
    c = wgetch(wField);
#line 530
    *keystr = key2asc(c);
#line 531
    c = do_custom_key(c);
    }
#line 532
    if (c == 260) {
#line 533
      c = 'q';
    }
#line 534
    if (c == 261) {
#line 535
      c = '\n';
    }
#line 536
    if (c >= 257) {
#line 536
      if (c <= 511) {
#line 540
        if (c == 258) {
#line 541
          if (nAbsFirstLine + nRelMarked < nAbsLastLine) {
#line 542
            nRelMarked ++;
          } else
#line 547
          if (nAbsLastLine < nLastLine) {
            {
#line 548
            wscrl(wField, 1);
#line 549
            nAbsFirstLine ++;
#line 550
            nAbsLastLine ++;
            }
          } else {
            {
#line 555
            strcpy((char */* __restrict  */)(msg), (char const   */* __restrict  */)"Already at End.");
            }
          }
        } else
#line 559
        if (c == 259) {
#line 560
          if (nRelMarked > 0) {
#line 561
            nRelMarked --;
          } else
#line 566
          if (nAbsFirstLine > nFirstLine) {
            {
#line 567
            wscrl(wField, -1);
#line 568
            nAbsFirstLine --;
#line 569
            nAbsLastLine --;
            }
          } else {
            {
#line 574
            strcpy((char */* __restrict  */)(msg), (char const   */* __restrict  */)"Already at Begin.");
            }
          }
        } else
#line 578
        if (c == 338) {
#line 579
          if (nAbsFirstLine + nRelMarked == nLastLine) {
            {
#line 580
            strcpy((char */* __restrict  */)(msg), (char const   */* __restrict  */)"Already at End.");
            }
          } else {
#line 583
            i = 0;
            {
#line 583
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 583
              if (! (i < wYSize - 1)) {
#line 583
                goto while_break___2;
              }
#line 584
              if (nAbsFirstLine + nRelMarked < nAbsLastLine) {
#line 585
                nRelMarked ++;
              } else
#line 587
              if (nAbsLastLine < nLastLine) {
                {
#line 588
                wscrl(wField, 1);
#line 589
                nAbsFirstLine ++;
#line 590
                nAbsLastLine ++;
                }
              }
#line 583
              i ++;
            }
            while_break___2: /* CIL Label */ ;
            }
          }
        } else
#line 596
        if (c == 339) {
#line 597
          if (nAbsFirstLine + nRelMarked == nFirstLine) {
            {
#line 598
            strcpy((char */* __restrict  */)(msg), (char const   */* __restrict  */)"Already at Begin.");
            }
          } else {
#line 601
            i = 0;
            {
#line 601
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 601
              if (! (i < wYSize - 1)) {
#line 601
                goto while_break___3;
              }
#line 602
              if (nRelMarked > 0) {
#line 603
                nRelMarked --;
              } else
#line 605
              if (nAbsFirstLine > nFirstLine) {
                {
#line 606
                wscrl(wField, -1);
#line 607
                nAbsFirstLine --;
#line 608
                nAbsLastLine --;
                }
              }
#line 601
              i ++;
            }
            while_break___3: /* CIL Label */ ;
            }
          }
        } else {
          {
#line 615
          strcpy((char */* __restrict  */)(msg), (char const   */* __restrict  */)"Invalid special key. Press \'h\' for Help Page!");
          }
        }
      } else {
#line 536
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
#line 619
      c &= 255;
#line 620
      if (c < 32) {
#line 620
        goto _L___0;
      } else
#line 620
      if (c > 126) {
        _L___0: /* CIL Label */ 
#line 624
        if (c == 10) {
#line 624
          goto _L;
        } else
#line 624
        if (c == 13) {
          _L: /* CIL Label */ 
#line 625
          if ((*(spaLines + (nAbsFirstLine + nRelMarked)))->fSelectable) {
#line 626
            (*(spaLines + (nAbsFirstLine + nRelMarked)))->fSelected = 1;
#line 627
            bEOI = 1;
          } else
#line 630
          if (multiselect) {
#line 631
            i = 0;
            {
#line 631
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 631
              if (! (i < nLines)) {
#line 631
                goto while_break___4;
              }
#line 632
              if ((*(spaLines + i))->fSelected) {
#line 633
                bEOI = 1;
#line 634
                goto while_break___4;
              }
#line 631
              i ++;
            }
            while_break___4: /* CIL Label */ ;
            }
#line 637
            if (! bEOI) {
              {
#line 638
              strcpy((char */* __restrict  */)(msg), (char const   */* __restrict  */)"Line not selectable and still no others selected.");
              }
            }
          } else {
            {
#line 641
            strcpy((char */* __restrict  */)(msg), (char const   */* __restrict  */)"Line not selectable.");
            }
          }
#line 646
          if (bEOI == 1) {
            {
#line 647
            cp = (*(spaLines + (nAbsFirstLine + nRelMarked)))->cpResult;
#line 648
            caLen = 1024;
#line 649
            tmp = smalloc((size_t )(caLen + 1));
#line 649
            ca = (char *)tmp;
#line 650
            cp2 = ca;
            }
            {
#line 651
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 651
              if (bEOI == 1) {
#line 651
                if (! ((int )*cp != 0)) {
#line 651
                  goto while_break___5;
                }
              } else {
#line 651
                goto while_break___5;
              }
              {
#line 652
              tmp___11 = strncmp((char const   *)cp, "%[", (size_t )2);
              }
#line 652
              if (tmp___11) {
#line 688
                tmp___9 = cp2;
#line 688
                cp2 ++;
#line 688
                tmp___10 = cp;
#line 688
                cp ++;
#line 688
                *tmp___9 = *tmp___10;
              } else {
#line 653
                cp += 2;
#line 654
                cp3 = cp;
                {
#line 654
                while (1) {
                  while_continue___6: /* CIL Label */ ;
                  {
#line 654
                  tmp___0 = strncasecmp((char const   *)cp3, "]s", (size_t )2);
                  }
#line 654
                  if (! tmp___0) {
#line 654
                    goto while_break___6;
                  }
#line 654
                  cp3 ++;
                }
                while_break___6: /* CIL Label */ ;
                }
                {
#line 656
                tmp___1 = smalloc((size_t )((cp3 - cp) + 3L));
#line 656
                ca3 = (char *)tmp___1;
#line 657
                strncpy((char */* __restrict  */)ca3, (char const   */* __restrict  */)cp,
                        (size_t )(cp3 - cp));
#line 658
                *(ca3 + (cp3 - cp)) = (char )'\000';
#line 659
                strcat((char */* __restrict  */)ca3, (char const   */* __restrict  */)": ");
#line 660
                cp = cp3 + 1;
                }
#line 661
                if ((int )*cp == 115) {
#line 662
                  bAllowEmpty = 1;
                } else {
#line 664
                  bAllowEmpty = 0;
                }
                {
#line 665
                cp ++;
#line 667
                iSelect_Draw(wField, wYSize, wXSize, wYPos, wXPos, nAbsFirstLine,
                             nAbsLastLine, -1, nRelFirstDraw, nRelLastDraw, nLines,
                             sField, title, name, mField, ca3, tagbegin, tagend);
#line 668
                wrefresh(wField);
#line 669
                tmp___2 = strlen((char const   *)ca3);
#line 669
                tmp___3 = strlen((char const   *)ca3);
#line 669
                cp3 = iSelect_InputField(mYSize, (int )((size_t )mXSize - tmp___3),
                                         mYPos, (int )((size_t )mXPos + tmp___2),
                                         bAllowEmpty);
#line 670
                free((void *)ca3);
#line 671
                tmp___4 = strcmp((char const   *)cp3, "ESC");
                }
#line 671
                if (! tmp___4) {
                  {
#line 672
                  bEOI = 0;
#line 673
                  (*(spaLines + (nAbsFirstLine + nRelMarked)))->fSelected = 0;
#line 674
                  strcpy((char */* __restrict  */)(msg), (char const   */* __restrict  */)"Selection cancelled.");
                  }
#line 675
                  goto while_continue___5;
                }
                {
#line 677
                strcpy((char */* __restrict  */)(msg), (char const   */* __restrict  */)"");
#line 678
                tmp___7 = strlen((char const   *)cp3);
                }
#line 678
                if ((size_t )(cp2 - ca) + tmp___7 >= (size_t )caLen) {
                  {
#line 679
                  tmp___5 = strlen((char const   *)cp3);
#line 679
                  caLen = (int )((size_t )caLen + tmp___5);
#line 680
                  i = (int )(cp2 - ca);
#line 681
                  tmp___6 = srealloc((void *)ca, (size_t )(caLen + 1));
#line 681
                  ca = (char *)tmp___6;
#line 682
                  cp2 = ca + i;
                  }
                }
                {
#line 684
                strcpy((char */* __restrict  */)cp2, (char const   */* __restrict  */)cp3);
#line 685
                tmp___8 = strlen((char const   *)cp3);
#line 685
                cp2 += tmp___8;
                }
              }
            }
            while_break___5: /* CIL Label */ ;
            }
#line 691
            if (bEOI == 1) {
              {
#line 692
              *cp2 = (char )'\000';
#line 693
              tmp___12 = strcmp((char const   *)(*(spaLines + (nAbsFirstLine + nRelMarked)))->cpResult,
                                (char const   *)ca);
              }
#line 693
              if (tmp___12) {
                {
#line 694
                (*(spaLines + (nAbsFirstLine + nRelMarked)))->cpResult = strdup((char const   *)ca);
                }
              }
            }
            {
#line 696
            free((void *)ca);
            }
          }
        }
      }
#line 700
      if (c >= 32) {
#line 700
        if (c <= 126) {
#line 704
          if (c == 32) {
#line 705
            if (multiselect) {
#line 706
              if ((*(spaLines + (nAbsFirstLine + nRelMarked)))->fSelectable) {
#line 707
                if ((*(spaLines + (nAbsFirstLine + nRelMarked)))->fSelected == 0) {
#line 708
                  (*(spaLines + (nAbsFirstLine + nRelMarked)))->fSelected = 1;
                } else {
#line 710
                  (*(spaLines + (nAbsFirstLine + nRelMarked)))->fSelected = 0;
                }
              } else {
                {
#line 713
                strcpy((char */* __restrict  */)(msg), (char const   */* __restrict  */)"Line not selectable.");
                }
              }
            } else {
              {
#line 717
              strcpy((char */* __restrict  */)(msg), (char const   */* __restrict  */)"No multi-line selection allowed.");
              }
            }
          } else
#line 720
          if (c == 67) {
#line 721
            if (multiselect) {
#line 722
              i = nFirstLine;
              {
#line 722
              while (1) {
                while_continue___7: /* CIL Label */ ;
#line 722
                if (! (i < nLastLine)) {
#line 722
                  goto while_break___7;
                }
#line 723
                (*(spaLines + i))->fSelected = 0;
#line 722
                i ++;
              }
              while_break___7: /* CIL Label */ ;
              }
            } else {
              {
#line 726
              strcpy((char */* __restrict  */)(msg), (char const   */* __restrict  */)"No multi-line selection.");
              }
            }
          } else
#line 729
          if (c == 113) {
#line 730
            bEOI = 1;
#line 731
            bQuit = 1;
          } else
#line 733
          if (c == 103) {
#line 734
            if (nAbsFirstLine + nRelMarked == nFirstLine) {
              {
#line 735
              strcpy((char */* __restrict  */)(msg), (char const   */* __restrict  */)"Already at Begin.");
              }
            } else
#line 738
            if (nLastLine < wYSize - 1) {
#line 739
              nAbsFirstLine = nFirstLine;
#line 740
              nAbsLastLine = nLastLine;
#line 741
              nRelFirstDraw = 0;
#line 742
              nRelLastDraw = nLastLine - nFirstLine;
#line 743
              nRelMarked = 0;
            } else {
#line 746
              nAbsFirstLine = nFirstLine;
#line 747
              nAbsLastLine = nFirstLine + (wYSize - 1);
#line 748
              nRelFirstDraw = 0;
#line 749
              nRelLastDraw = wYSize - 1;
#line 750
              nRelMarked = 0;
            }
          } else
#line 754
          if (c == 71) {
#line 755
            if (nAbsFirstLine + nRelMarked == nLastLine) {
              {
#line 756
              strcpy((char */* __restrict  */)(msg), (char const   */* __restrict  */)"Already at End.");
              }
            } else
#line 759
            if (nLastLine < wYSize - 1) {
#line 760
              nAbsFirstLine = nFirstLine;
#line 761
              nAbsLastLine = nLastLine;
#line 762
              nRelFirstDraw = 0;
#line 763
              nRelLastDraw = nLastLine - nFirstLine;
#line 764
              nRelMarked = nLastLine - nFirstLine;
            } else {
#line 767
              nAbsFirstLine = nLastLine - (wYSize - 1);
#line 768
              nAbsLastLine = nLastLine;
#line 769
              nRelFirstDraw = 0;
#line 770
              nRelLastDraw = wYSize - 1;
#line 771
              nRelMarked = wYSize - 1;
            }
          } else
#line 775
          if (c == 104) {
#line 775
            goto _L___1;
          } else
#line 775
          if (c == 118) {
            _L___1: /* CIL Label */ 
#line 776
            if (c == 104) {
              {
#line 777
              strcpy((char */* __restrict  */)(msg), (char const   */* __restrict  */)"Help Page: Press \'q\' to exit");
              }
            } else {
              {
#line 779
              strcpy((char */* __restrict  */)(msg), (char const   */* __restrict  */)"Version Page: Press \'q\' to exit");
              }
            }
            {
#line 780
            iSelect_Draw(wField, wYSize, wXSize, wYPos, wXPos, nAbsFirstLine, nAbsLastLine,
                         nRelMarked, nRelFirstDraw, nRelLastDraw, nLines, sField,
                         title, name, mField, msg, tagbegin, tagend);
#line 781
            wrefresh(wField);
#line 783
            hField = newwin(wYSize, wXSize, wYPos, wXPos);
            }
#line 784
            if (c == 104) {
#line 785
              cpp = iSelect_Help;
            } else {
#line 787
              cpp = iSelect_README;
            }
#line 788
            voffset = 0;
            {
#line 789
            while (1) {
              while_continue___8: /* CIL Label */ ;
#line 790
              cppsize = 0;
              {
#line 790
              while (1) {
                while_continue___9: /* CIL Label */ ;
#line 790
                if (! ((unsigned long )*(cpp + cppsize) != (unsigned long )((void *)0))) {
#line 790
                  goto while_break___9;
                }
#line 790
                cppsize ++;
              }
              while_break___9: /* CIL Label */ ;
              }
#line 792
              if (voffset > cppsize - wYSize) {
#line 793
                voffset = cppsize - wYSize;
              }
#line 794
              if (voffset < 0) {
#line 795
                voffset = 0;
              }
              {
#line 796
              werase(hField);
#line 797
              y = 0;
              }
              {
#line 797
              while (1) {
                while_continue___10: /* CIL Label */ ;
#line 797
                if (y < wYSize) {
#line 797
                  if (! ((unsigned long )*(cpp + (y + voffset)) != (unsigned long )((void *)0))) {
#line 797
                    goto while_break___10;
                  }
                } else {
#line 797
                  goto while_break___10;
                }
                {
#line 798
                cp3 = strdup((char const   *)*(cpp + (y + voffset)));
#line 799
                cp = cp3;
#line 800
                x = 0;
                }
                {
#line 801
                while (1) {
                  while_continue___11: /* CIL Label */ ;
                  {
#line 802
                  cp2 = strstr((char const   *)cp, "<b>");
                  }
#line 802
                  if ((unsigned long )cp2 != (unsigned long )((void *)0)) {
                    {
#line 803
                    *cp2 = (char )'\000';
#line 804
                    wmove(hField, y, x);
#line 804
                    waddnstr(hField, (char const   *)cp, -1);
#line 804
                    tmp___13 = strlen((char const   *)cp);
#line 804
                    x = (int )((size_t )x + tmp___13);
                    }
#line 805
                    if (hField) {
#line 805
                      hField->_attrs = 1UL << 21;
                    }
                    {
#line 806
                    cp = cp2 + 3;
#line 807
                    cp2 = strstr((char const   *)cp, "</b>");
#line 808
                    *cp2 = (char )'\000';
#line 809
                    wmove(hField, y, x);
#line 809
                    waddnstr(hField, (char const   *)cp, -1);
#line 809
                    tmp___14 = strlen((char const   *)cp);
#line 809
                    x = (int )((size_t )x + tmp___14);
                    }
#line 810
                    if (hField) {
#line 810
                      hField->_attrs = 0UL;
                    }
#line 811
                    cp = cp2 + 4;
                  } else {
                    {
#line 814
                    wmove(hField, y, x);
#line 814
                    waddnstr(hField, (char const   *)cp, -1);
                    }
#line 815
                    goto while_break___11;
                  }
                }
                while_break___11: /* CIL Label */ ;
                }
                {
#line 818
                free((void *)cp3);
#line 797
                y ++;
                }
              }
              while_break___10: /* CIL Label */ ;
              }
              {
#line 820
              wrefresh(hField);
#line 821
              c = wgetch(wField);
              }
#line 822
              if (c == 113) {
#line 823
                goto while_break___8;
              } else
#line 824
              if (c == 259) {
#line 825
                voffset --;
              } else
#line 826
              if (c == 258) {
#line 827
                voffset ++;
              } else
#line 828
              if (c == 339) {
#line 829
                voffset -= wYSize;
              } else
#line 830
              if (c == 338) {
#line 831
                voffset += wYSize;
              } else
#line 832
              if (c == 103) {
#line 833
                voffset = 0;
              } else
#line 834
              if (c == 71) {
#line 835
                voffset = cppsize - wYSize;
              } else
#line 836
              if (c == 104) {
#line 837
                cpp = iSelect_Help;
              } else
#line 838
              if (c == 118) {
#line 839
                cpp = iSelect_README;
              }
            }
            while_break___8: /* CIL Label */ ;
            }
            {
#line 841
            delwin(hField);
#line 843
            nRelFirstDraw = 0;
#line 844
            nRelLastDraw = nAbsLastLine - nAbsFirstLine;
#line 845
            strcpy((char */* __restrict  */)(msg), (char const   */* __restrict  */)"");
#line 846
            iSelect_Draw(wField, wYSize, wXSize, wYPos, wXPos, nAbsFirstLine, nAbsLastLine,
                         nRelMarked, nRelFirstDraw, nRelLastDraw, nLines, sField,
                         title, name, mField, msg, tagbegin, tagend);
            }
#line 848
            if (wField) {
#line 848
              tmp___15 = (int )wField->_maxy + 1;
            } else {
#line 848
              tmp___15 = -1;
            }
            {
#line 848
            wredrawln(wField, 0, tmp___15);
#line 850
            wrefresh(wField);
            }
          } else {
            {
#line 853
            strcpy((char */* __restrict  */)(msg), (char const   */* __restrict  */)"Invalid key. Press \'h\' for Help Page!");
            }
          }
        }
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 859
  fflush(stdin);
#line 860
  echo();
#line 862
  nocbreak();
#line 864
  delwin(wField);
  }
#line 866
  if (bQuit) {
#line 867
    return (-1);
  } else {
#line 869
    return (nAbsFirstLine + nRelMarked);
  }
}
}
#line 875 "/home/june/repo/benchmarks/collector/temp/iselect-1.4.0/iselect_browse.c"
int iSelect(char *caBuf , int pos , char *title , char *name , char *tagbegin , char *tagend ,
            int stripco , int stripws , int browsealways , int allselectable , int multiselect ,
            int exitnoselect , char **keystr ) 
{ 
  WINDOW *wMain ;
  int i ;
  int j ;
  int k ;
  char *ca ;
  char *ca2 ;
  char *ca3 ;
  char *cp ;
  char *cps ;
  char *cpe ;
  struct Line *spLine ;
  int rc ;
  int ok ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  void *tmp___11 ;
  size_t tmp___12 ;
  char *tmp___13 ;
  size_t tmp___14 ;
  int tmp___15 ;
  size_t tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  size_t tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  size_t tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;

  {
#line 893
  j = 0;
#line 897
  nLines = 1;
#line 898
  i = 0;
  {
#line 898
  while (1) {
    while_continue: /* CIL Label */ ;
#line 898
    if (! ((int )*(caBuf + i) != 0)) {
#line 898
      goto while_break;
    }
#line 899
    if ((int )*(caBuf + i) == 10) {
#line 900
      nLines ++;
    }
#line 898
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 901
  tmp = smalloc(sizeof(struct Line *) * (unsigned long )nLines);
#line 901
  spaLines = (struct Line **)tmp;
#line 902
  tmp___0 = strlen((char const   *)caBuf);
#line 902
  tmp___1 = smalloc(tmp___0 + 1UL);
#line 902
  ca = (char *)tmp___1;
#line 904
  nLines = 0;
#line 905
  i = 0;
  }
  {
#line 905
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 905
    if (! ((int )*(caBuf + i) != 0)) {
#line 905
      goto while_break___0;
    }
#line 906
    if ((int )*(caBuf + i) != 10) {
#line 908
      tmp___2 = j;
#line 908
      j ++;
#line 908
      *(ca + tmp___2) = *(caBuf + i);
    } else {
#line 912
      tmp___3 = j;
#line 912
      j ++;
#line 912
      *(ca + tmp___3) = (char )'\000';
#line 913
      j = 0;
#line 916
      if (stripco) {
        {
#line 917
        tmp___4 = strncmp((char const   *)ca, "#", (size_t )1);
        }
#line 917
        if (! tmp___4) {
#line 918
          goto __Cont;
        }
      }
      {
#line 921
      tmp___5 = smalloc(sizeof(struct Line ));
#line 921
      spLine = (struct Line *)tmp___5;
#line 923
      tmp___6 = strlen((char const   *)ca);
#line 923
      tmp___7 = strlen((char const   *)tagbegin);
#line 923
      tmp___8 = smalloc((tmp___6 + tmp___7) + 2UL);
#line 923
      ca2 = (char *)tmp___8;
#line 924
      tmp___9 = strlen((char const   *)ca);
#line 924
      tmp___10 = strlen((char const   *)tagbegin);
#line 924
      tmp___11 = smalloc((tmp___9 + tmp___10) + 2UL);
#line 924
      ca3 = (char *)tmp___11;
#line 925
      sprintf((char */* __restrict  */)ca2, (char const   */* __restrict  */)"%ss",
              tagbegin);
#line 926
      sprintf((char */* __restrict  */)ca3, (char const   */* __restrict  */)"%sS",
              tagbegin);
#line 927
      cp = strstr((char const   *)ca, (char const   *)ca2);
      }
#line 927
      if ((unsigned long )cp != (unsigned long )((void *)0)) {
#line 927
        goto _L;
      } else {
        {
#line 927
        cp = strstr((char const   *)ca, (char const   *)ca3);
        }
#line 927
        if ((unsigned long )cp != (unsigned long )((void *)0)) {
          _L: /* CIL Label */ 
          {
#line 930
          cps = cp;
#line 931
          tmp___12 = strlen((char const   *)tagbegin);
#line 931
          cp += tmp___12 + 1UL;
#line 932
          tmp___24 = strncmp((char const   *)cp, ":", (size_t )1);
          }
#line 932
          if (tmp___24) {
            {
#line 942
            tmp___22 = strlen((char const   *)tagend);
#line 942
            tmp___23 = strncmp((char const   *)cp, (char const   *)tagend, tmp___22);
            }
#line 942
            if (tmp___23) {
              {
#line 950
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 950
                rc = 1;
#line 950
                goto CUS;
#line 950
                goto while_break___1;
              }
              while_break___1: /* CIL Label */ ;
              }
            } else {
              {
#line 943
              tmp___19 = strlen((char const   *)tagend);
#line 943
              cpe = cp + tmp___19;
              }
              {
#line 944
              while (1) {
                while_continue___2: /* CIL Label */ ;
#line 944
                if (! ((int )*cpe != 0)) {
#line 944
                  goto while_break___2;
                }
#line 945
                tmp___20 = cps;
#line 945
                cps ++;
#line 945
                tmp___21 = cpe;
#line 945
                cpe ++;
#line 945
                *tmp___20 = *tmp___21;
              }
              while_break___2: /* CIL Label */ ;
              }
              {
#line 946
              *cps = (char )'\000';
#line 947
              strcpy((char */* __restrict  */)ca2, (char const   */* __restrict  */)ca);
              }
            }
          } else {
#line 933
            cp ++;
#line 934
            k = 0;
            {
#line 934
            while (1) {
              while_continue___3: /* CIL Label */ ;
              {
#line 934
              tmp___14 = strlen((char const   *)tagend);
#line 934
              tmp___15 = strncmp((char const   *)cp, (char const   *)tagend, tmp___14);
              }
#line 934
              if (! tmp___15) {
#line 934
                goto while_break___3;
              }
#line 935
              tmp___13 = cp;
#line 935
              cp ++;
#line 935
              *(ca2 + k) = *tmp___13;
#line 934
              k ++;
            }
            while_break___3: /* CIL Label */ ;
            }
            {
#line 936
            *(ca2 + k) = (char )'\000';
#line 937
            tmp___16 = strlen((char const   *)tagend);
#line 937
            cpe = cp + tmp___16;
            }
            {
#line 938
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 938
              if (! ((int )*cpe != 0)) {
#line 938
                goto while_break___4;
              }
#line 939
              tmp___17 = cps;
#line 939
              cps ++;
#line 939
              tmp___18 = cpe;
#line 939
              cpe ++;
#line 939
              *tmp___17 = *tmp___18;
            }
            while_break___4: /* CIL Label */ ;
            }
#line 940
            *cps = (char )'\000';
          }
          {
#line 952
          spLine->cpLine = strdup((char const   *)ca);
#line 953
          spLine->fSelectable = 1;
#line 954
          spLine->cpResult = strdup((char const   *)ca2);
          }
        } else {
          {
#line 958
          spLine->cpLine = strdup((char const   *)ca);
          }
#line 959
          if (allselectable) {
#line 960
            spLine->fSelectable = 1;
          } else {
#line 962
            spLine->fSelectable = 0;
          }
          {
#line 963
          spLine->cpResult = strdup((char const   *)ca);
          }
        }
      }
#line 966
      spLine->fSelected = 0;
#line 967
      if (stripws) {
        {
#line 968
        strip(spLine->cpResult);
        }
      }
      {
#line 969
      tmp___25 = nLines;
#line 969
      nLines ++;
#line 969
      *(spaLines + tmp___25) = spLine;
#line 970
      free((void *)ca2);
#line 971
      free((void *)ca3);
      }
    }
    __Cont: /* CIL Label */ 
#line 905
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 974
  free((void *)ca);
  }
#line 985
  if (! browsealways) {
#line 985
    if (nLines == 0) {
      {
#line 986
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 986
        rc = -1;
#line 986
        goto CUS;
#line 986
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
  }
#line 987
  if (! browsealways) {
#line 987
    if (nLines == 1) {
#line 988
      (*(spaLines + 0))->fSelected = 1;
      {
#line 989
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 989
        rc = 0;
#line 989
        goto CUS;
#line 989
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
  }
#line 992
  if (exitnoselect) {
#line 993
    ok = 0;
#line 994
    i = 0;
    {
#line 994
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 994
      if (! (i < nLines)) {
#line 994
        goto while_break___7;
      }
#line 995
      if ((*(spaLines + i))->fSelectable) {
#line 996
        ok = 1;
#line 997
        goto while_break___7;
      }
#line 994
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 1000
    if (! ok) {
      {
#line 1001
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 1001
        rc = -1;
#line 1001
        goto CUS;
#line 1001
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
    }
  }
  {
#line 1008
  setup();
#line 1009
  wMain = newwin(LINES, COLS, 0, 0);
#line 1010
  werase(wMain);
#line 1011
  wrefresh(wMain);
#line 1016
  rc = iSelect_Browser(LINES - 2, COLS - 2, 0, 1, pos, multiselect, 1, COLS, LINES - 2,
                       0, title, name, 1, COLS - 1, LINES - 1, 0, keystr, tagbegin,
                       tagend);
#line 1026
  werase(wMain);
#line 1027
  wrefresh(wMain);
#line 1028
  delwin(wMain);
#line 1029
  diesoft();
  }
  CUS: 
#line 1032
  return (rc);
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/iselect-1.4.0/iselect_help.c"
char *iSelect_Help[29]  = 
#line 5 "/home/june/repo/benchmarks/collector/temp/iselect-1.4.0/iselect_help.c"
  {      (char *)"  <b>    _ ____       _           _   </b>",      (char *)"  <b>   (_) ___|  ___| | ___  ___| |_ </b>",      (char *)"  <b>  / /\\___ \\ / _ \\ |/ _ \\/ __| __|</b>",      (char *)"  <b> / /  ___) |  __/ |  __/ (__| |_ </b>", 
        (char *)"  <b>(_(  |____/ \\___|_|\\___|\\___|\\__|</b>",      (char *)"",      (char *)"  <b>iSelect -- Interactive Selection Tool</b>",      (char *)"", 
        (char *)"  Cursor Movement:",      (char *)"      <b>CURSOR-UP</b> ..... Move cursor one line up",      (char *)"      <b>CURSOR-DOWN</b> ... Move cursor one line down",      (char *)"      <b>PAGE-UP</b> ....... Move cursor one page up", 
        (char *)"      <b>PAGE-DOWN</b> ..... Move cursor one page down",      (char *)"      <b>g</b> ............. Goto first line",      (char *)"      <b>G</b> ............. Goto last line",      (char *)"", 
        (char *)"  Line Selection:",      (char *)"      <b>RETURN</b> ........ Select line and exit",      (char *)"      <b>CURSOR-RIGHT</b> .. Select line and exit",      (char *)"      <b>SPACE</b> ......... Select line and stay (multi-line mode only)", 
        (char *)"      <b>C</b> ............. Clear current marks (multi-line mode only)",      (char *)"",      (char *)"  Others:",      (char *)"      <b>q</b> ............. Quit (exit without selection)", 
        (char *)"      <b>CURSOR-LEFT</b> ... Quit (exit without selection)",      (char *)"      <b>h</b> ............. Help Page (this page)",      (char *)"      <b>v</b> ............. Version Page",      (char *)"", 
        (char *)((void *)0)};
#line 24 "/home/june/repo/benchmarks/collector/temp/iselect-1.4.0/iselect_version.c"
iselect_version_t iselect_version ;
#line 34 "/home/june/repo/benchmarks/collector/temp/iselect-1.4.0/iselect_version.c"
iselect_version_t iselect_version  = 
#line 34
     {(int const   )1065472, "1.4.0", "1.4.0 (08-Jul-2007)", "This is iSelect, Version 1.4.0 (08-Jul-2007)",
    "iSelect 1.4.0 (08-Jul-2007)", "iSelect/1.4.0", "@(#)iSelect 1.4.0 (08-Jul-2007)",
    "$Id: iselect_version.c,v 1.6 2007/07/08 09:28:11 rse Exp $"};
#line 5 "/home/june/repo/benchmarks/collector/temp/iselect-1.4.0/iselect_readme.c"
char *iSelect_README[35]  = 
#line 5 "/home/june/repo/benchmarks/collector/temp/iselect-1.4.0/iselect_readme.c"
  {      (char *)"  <b>    _ ____       _           _   </b>",      (char *)"  <b>   (_) ___|  ___| | ___  ___| |_ </b>",      (char *)"  <b>  / /\\___ \\ / _ \\ |/ _ \\/ __| __|</b>",      (char *)"  <b> / /  ___) |  __/ |  __/ (__| |_ </b>", 
        (char *)"  <b>(_(  |____/ \\___|_|\\___|\\___|\\__|</b>",      (char *)"",      (char *)"  <b>iSelect -- Interactive Selection Tool</b>",      (char *)"", 
        (char *)"  iSelect is an interactive line selection tool for ASCII files, operating",      (char *)"  via a full-screen Curses-based terminal session. It can be used either as",      (char *)"  an user interface frontend controlled by a Bourne-Shell/Perl/Tcl backend",      (char *)"  as its control script or in batch mode as a pipeline filter (usually", 
        (char *)"  between grep and the final executing command).   ",      (char *)"  ",      (char *)"  Version 1.4.0 (08-Jul-2007)",      (char *)"", 
        (char *)"  The latest release can be found on",      (char *)"  http://www.ossp.org/pkg/tool/iselect/",      (char *)"",      (char *)"  Copyright (c) 1997-2007 Ralf S. Engelschall <rse@engelschall.com>", 
        (char *)"",      (char *)"  This program is free software; it may be redistributed and/or modified ",      (char *)"  only under the terms of the GNU General Public License, which may be found ",      (char *)"  in the iSelect source distribution.  Look at the file COPYING for details. ", 
        (char *)"",      (char *)"  This program is distributed in the hope that it will be useful, but ",      (char *)"  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY",      (char *)"  or FITNESS FOR A PARTICULAR PURPOSE.  See the the GNU General Public ", 
        (char *)"  License for more details.",      (char *)"",      (char *)"                              Ralf S. Engelschall",      (char *)"                              rse@engelschall.com", 
        (char *)"                              www.engelschall.com",      (char *)"",      (char *)((void *)0)};
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 531
extern int fgetc(FILE *__stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 263 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 531
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup)(int __fd ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 76
extern int opterr ;
#line 80
extern int optopt ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 138 "/home/june/repo/benchmarks/collector/temp/iselect-1.4.0/iselect_getopt.h"
extern int getopt_long(int argc , char * const  *argv , char const   *shortopts ,
                       struct option  const  *longopts , int *longind ) ;
#line 47 "/home/june/repo/benchmarks/collector/temp/iselect-1.4.0/iselect_main.c"
void give_version(char *name ) ;
#line 48
void give_usage(char *name ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/iselect-1.4.0/iselect_main.c"
void give_version(char *name ) 
{ 


  {
  {
#line 52
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          iselect_version.v_tex);
#line 53
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Copyright (c) 1997-2000 Ralf S. Engelschall <rse@engelschall.com>\n");
#line 54
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\n");
#line 55
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"This program is distributed in the hope that it will be useful,\n");
#line 56
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"but WITHOUT ANY WARRANTY; without even the implied warranty of\n");
#line 57
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n");
#line 58
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"GNU General Public License for more details.\n");
#line 59
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\n");
  }
#line 60
  return;
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/iselect-1.4.0/iselect_main.c"
void give_usage(char *name ) 
{ 


  {
  {
#line 64
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s [options] [line1 line2 ...]\n",
          name);
#line 65
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 66
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" Input Options:\n");
#line 67
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -d, --delimiter=STR,STR selection tag delimiters\n");
#line 68
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -c, --strip-comments    strip sharp-comments in input buffer\n");
#line 69
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -f, --force-browse      browse even if input has 0 or only 1 line\n");
#line 70
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -a, --all-select        force all lines to be selectable\n");
#line 71
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -e, --exit-no-select    exit immediately if no lines are selectable\n");
#line 72
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 73
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" Display Options:\n");
#line 74
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -p, --position=NUM      initial line position of cursor\n");
#line 75
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -k, --key=KEY[:OKEY]    enable an additional input key\n");
#line 76
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -m, --multi-line        allow multiple lines to be selected\n");
#line 77
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -n, --name=STR          program name shown flush-left on status bar\n");
#line 78
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -t, --title=STR         title string shown centered on status bar\n");
#line 79
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 80
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" Output Options:\n");
#line 81
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -S, --strip-result      strip whitespaces in result string\n");
#line 82
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -P, --position-result   prefix result string with `N:\' (N=line number)\n");
#line 83
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -K, --key-result        prefix result string with `K:\' (K=select key)\n");
#line 84
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -Q, --quit-result=STR   result string on quit (default=\'\')\n");
#line 85
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 86
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" Giving Feedback:\n");
#line 87
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -V, --version           display version string\n");
#line 88
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -h, --help              display this page\n");
#line 89
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 90
  return;
}
}
#line 92 "/home/june/repo/benchmarks/collector/temp/iselect-1.4.0/iselect_main.c"
struct option options[17]  = 
#line 92
  {      {"delimiter", 1, (int *)((void *)0), 'd'}, 
        {"strip-comments", 0, (int *)((void *)0), 'c'}, 
        {"force-browse", 0, (int *)((void *)0), 'f'}, 
        {"all-select", 0, (int *)((void *)0), 'a'}, 
        {"exit-no-select", 0, (int *)((void *)0), 'e'}, 
        {"position", 1, (int *)((void *)0), 'p'}, 
        {"key", 1, (int *)((void *)0), 'k'}, 
        {"multi-line", 0, (int *)((void *)0), 'm'}, 
        {"name", 1, (int *)((void *)0), 'n'}, 
        {"title", 1, (int *)((void *)0), 't'}, 
        {"strip-result", 0, (int *)((void *)0), 'S'}, 
        {"position-result", 0, (int *)((void *)0), 'P'}, 
        {"key-result", 0, (int *)((void *)0), 'K'}, 
        {"quit-result", 1, (int *)((void *)0), 'Q'}, 
        {"version", 0, (int *)((void *)0), 'V'}, 
        {"help", 0, (int *)((void *)0), 'h'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), '\000'}};
#line 112 "/home/june/repo/benchmarks/collector/temp/iselect-1.4.0/iselect_main.c"
int main(int argc , char **argv ) 
{ 
  int fpStdout ;
  int fpStdin ;
  char *cp ;
  char c ;
  int pos ;
  char *progname ;
  int nBuf ;
  int p ;
  char ca[22] ;
  char *title ;
  char *name ;
  int stripco ;
  int stripws ;
  int resultline ;
  int keyresultline ;
  int browsealways ;
  int allselectable ;
  int multiselect ;
  int exitnoselect ;
  int i ;
  char *keystr ;
  char *abortstr ;
  char *tagbegin ;
  char *tagend ;
  char *caBuf ;
  int caBufLen ;
  char *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;

  {
  {
#line 118
  pos = -1;
#line 123
  title = (char *)"";
#line 124
  name = (char *)"iSelect";
#line 125
  stripco = 0;
#line 126
  stripws = 0;
#line 127
  resultline = 0;
#line 128
  keyresultline = 0;
#line 129
  browsealways = 0;
#line 130
  allselectable = 0;
#line 131
  multiselect = 0;
#line 132
  exitnoselect = 0;
#line 135
  abortstr = (char *)((void *)0);
#line 136
  tagbegin = (char *)"<";
#line 137
  tagend = (char *)">";
#line 146
  cp = strrchr((char const   *)*(argv + 0), '/');
  }
#line 146
  if ((unsigned long )cp != (unsigned long )((void *)0)) {
#line 147
    progname = cp + 1;
  } else {
#line 149
    progname = *(argv + 0);
  }
#line 150
  *(argv + 0) = progname;
#line 153
  opterr = 0;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 154
    tmp___0 = getopt_long(argc, (char * const  *)argv, "d:cfaep:k:mn:t:SPKQ:Vh", (struct option  const  *)(options),
                          (int *)((void *)0));
#line 154
    c = (char )tmp___0;
    }
#line 154
    if (! ((int )c != -1)) {
#line 154
      goto while_break;
    }
#line 155
    if ((unsigned long )optarg == (unsigned long )((void *)0)) {
#line 156
      optarg = (char *)"(null)";
    }
    {
#line 158
    if ((int )c == 100) {
#line 158
      goto case_100;
    }
#line 168
    if ((int )c == 99) {
#line 168
      goto case_99;
    }
#line 171
    if ((int )c == 102) {
#line 171
      goto case_102;
    }
#line 174
    if ((int )c == 97) {
#line 174
      goto case_97;
    }
#line 177
    if ((int )c == 101) {
#line 177
      goto case_101;
    }
#line 180
    if ((int )c == 112) {
#line 180
      goto case_112;
    }
#line 183
    if ((int )c == 107) {
#line 183
      goto case_107;
    }
#line 186
    if ((int )c == 109) {
#line 186
      goto case_109;
    }
#line 189
    if ((int )c == 110) {
#line 189
      goto case_110;
    }
#line 192
    if ((int )c == 116) {
#line 192
      goto case_116;
    }
#line 195
    if ((int )c == 83) {
#line 195
      goto case_83;
    }
#line 198
    if ((int )c == 80) {
#line 198
      goto case_80;
    }
#line 201
    if ((int )c == 75) {
#line 201
      goto case_75;
    }
#line 204
    if ((int )c == 81) {
#line 204
      goto case_81;
    }
#line 207
    if ((int )c == 86) {
#line 207
      goto case_86;
    }
#line 210
    if ((int )c == 104) {
#line 210
      goto case_104;
    }
#line 213
    if ((int )c == 63) {
#line 213
      goto case_63;
    }
#line 217
    if ((int )c == 58) {
#line 217
      goto case_58;
    }
#line 157
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 159
    tagbegin = strdup((char const   *)optarg);
#line 160
    cp = strchr((char const   *)tagbegin, ',');
    }
#line 160
    if ((unsigned long )cp == (unsigned long )((void *)0)) {
      {
#line 161
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"iSelect: bad argument to option \'%c\'\n",
              optopt);
#line 162
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Try `%s --help\' for more information.\n",
              progname);
#line 163
      exit(64);
      }
    }
#line 165
    tmp = cp;
#line 165
    cp ++;
#line 165
    *tmp = (char )'\000';
#line 166
    tagend = cp;
#line 167
    goto switch_break;
    case_99: /* CIL Label */ 
#line 169
    stripco = 1;
#line 170
    goto switch_break;
    case_102: /* CIL Label */ 
#line 172
    browsealways = 1;
#line 173
    goto switch_break;
    case_97: /* CIL Label */ 
#line 175
    allselectable = 1;
#line 176
    goto switch_break;
    case_101: /* CIL Label */ 
#line 178
    exitnoselect = 1;
#line 179
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 181
    pos = atoi((char const   *)optarg);
    }
#line 182
    goto switch_break;
    case_107: /* CIL Label */ 
    {
#line 184
    configure_custom_key(optarg);
    }
#line 185
    goto switch_break;
    case_109: /* CIL Label */ 
#line 187
    multiselect = 1;
#line 188
    goto switch_break;
    case_110: /* CIL Label */ 
    {
#line 190
    name = strdup((char const   *)optarg);
    }
#line 191
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 193
    title = strdup((char const   *)optarg);
    }
#line 194
    goto switch_break;
    case_83: /* CIL Label */ 
#line 196
    stripws = 1;
#line 197
    goto switch_break;
    case_80: /* CIL Label */ 
#line 199
    resultline = 1;
#line 200
    goto switch_break;
    case_75: /* CIL Label */ 
#line 202
    keyresultline = 1;
#line 203
    goto switch_break;
    case_81: /* CIL Label */ 
    {
#line 205
    abortstr = strdup((char const   *)optarg);
    }
#line 206
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 208
    give_version(progname);
#line 209
    exit(0);
    }
    case_104: /* CIL Label */ 
    {
#line 211
    give_usage(progname);
#line 212
    exit(0);
    }
    case_63: /* CIL Label */ 
    {
#line 214
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"iSelect: invalid option: \'%c\'\n",
            optopt);
#line 215
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Try `%s --help\' for more information.\n",
            progname);
#line 216
    exit(64);
    }
    case_58: /* CIL Label */ 
    {
#line 218
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"iSelect: missing argument to option \'%c\'\n",
            optopt);
#line 219
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Try `%s --help\' for more information.\n",
            progname);
#line 220
    exit(64);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 228
  nBuf = 0;
#line 229
  caBufLen = 1024;
#line 230
  tmp___1 = malloc((size_t )(caBufLen + 1));
#line 230
  caBuf = (char *)tmp___1;
#line 231
  *(caBuf + 0) = (char )'\000';
  }
#line 232
  if (optind < argc) {
    {
#line 234
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 234
      if (! (optind < argc)) {
#line 234
        goto while_break___0;
      }
#line 235
      if ((unsigned long )*(argv + optind) == (unsigned long )((void *)0)) {
#line 235
        cp = (char *)"";
      } else {
#line 235
        cp = *(argv + optind);
      }
      {
#line 236
      tmp___4 = strlen((char const   *)cp);
      }
#line 236
      if (((size_t )nBuf + tmp___4) + 1UL >= (size_t )caBufLen) {
        {
#line 237
        tmp___2 = strlen((char const   *)cp);
#line 237
        caBufLen = (int )((size_t )caBufLen + (tmp___2 + 1UL));
#line 238
        tmp___3 = realloc((void *)caBuf, (size_t )(caBufLen + 1));
#line 238
        caBuf = (char *)tmp___3;
        }
      }
      {
#line 240
      strcpy((char */* __restrict  */)(caBuf + nBuf), (char const   */* __restrict  */)cp);
#line 241
      tmp___5 = strlen((char const   *)cp);
#line 241
      nBuf = (int )((size_t )nBuf + tmp___5);
#line 242
      tmp___6 = nBuf;
#line 242
      nBuf ++;
#line 242
      *(caBuf + tmp___6) = (char )'\n';
#line 234
      optind ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 244
    tmp___7 = nBuf;
#line 244
    nBuf ++;
#line 244
    *(caBuf + tmp___7) = (char )'\000';
  } else
#line 246
  if (optind == argc) {
    {
#line 246
    tmp___12 = feof(stdin);
    }
#line 246
    if (tmp___12) {
      {
#line 263
      give_usage(progname);
#line 264
      exit(64);
      }
    } else {
      {
#line 248
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 248
        tmp___10 = fgetc(stdin);
#line 248
        c = (char )tmp___10;
        }
#line 248
        if (! ((int )c != -1)) {
#line 248
          goto while_break___1;
        }
#line 249
        if (nBuf >= caBufLen) {
          {
#line 250
          caBufLen += 1024;
#line 251
          tmp___8 = realloc((void *)caBuf, (size_t )(caBufLen + 1));
#line 251
          caBuf = (char *)tmp___8;
          }
        }
#line 253
        tmp___9 = nBuf;
#line 253
        nBuf ++;
#line 253
        *(caBuf + tmp___9) = c;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 255
      tmp___11 = nBuf;
#line 255
      nBuf ++;
#line 255
      *(caBuf + tmp___11) = (char )'\000';
#line 258
      fpStdin = dup(0);
#line 259
      close(0);
#line 260
      open("/dev/tty", 0);
      }
    }
  } else {
    {
#line 263
    give_usage(progname);
#line 264
    exit(64);
    }
  }
  {
#line 271
  fpStdout = dup(1);
#line 272
  close(1);
#line 273
  open("/dev/tty", 2);
  }
#line 275
  if (pos < 1) {
#line 275
    pos = 1;
  } else {
#line 275
    pos = pos;
  }
  {
#line 277
  p = iSelect(caBuf, pos - 1, title, name, tagbegin, tagend, stripco, stripws, browsealways,
              allselectable, multiselect, exitnoselect, & keystr);
  }
#line 285
  if (p != -1) {
#line 286
    i = 0;
    {
#line 286
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 286
      if (! (i < nLines)) {
#line 286
        goto while_break___2;
      }
#line 287
      if ((*(spaLines + i))->fSelected) {
#line 288
        if (resultline) {
          {
#line 289
          sprintf((char */* __restrict  */)(ca), (char const   */* __restrict  */)"%d",
                  i + 1);
#line 290
          tmp___13 = strlen((char const   *)(ca));
#line 290
          write(fpStdout, (void const   *)(ca), tmp___13);
#line 291
          write(fpStdout, (void const   *)":", (size_t )1);
          }
        }
#line 293
        if (keyresultline) {
          {
#line 294
          tmp___14 = strlen((char const   *)keystr);
#line 294
          write(fpStdout, (void const   *)keystr, tmp___14);
#line 295
          write(fpStdout, (void const   *)":", (size_t )1);
          }
        }
        {
#line 297
        tmp___15 = strlen((char const   *)(*(spaLines + i))->cpResult);
#line 297
        write(fpStdout, (void const   *)(*(spaLines + i))->cpResult, tmp___15);
#line 298
        write(fpStdout, (void const   *)"\n", (size_t )1);
        }
      }
#line 286
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else
#line 303
  if ((unsigned long )abortstr != (unsigned long )((void *)0)) {
    {
#line 304
    tmp___16 = strlen((char const   *)abortstr);
#line 304
    write(fpStdout, (void const   *)abortstr, tmp___16);
    }
  }
  {
#line 306
  exit(0);
  }
}
}
