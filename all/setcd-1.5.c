/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 20 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 154 "/usr/include/linux/cdrom.h"
struct cdrom_msf0 {
   __u8 minute ;
   __u8 second ;
   __u8 frame ;
};
#line 162 "/usr/include/linux/cdrom.h"
union cdrom_addr {
   struct cdrom_msf0 msf ;
   int lba ;
};
#line 189 "/usr/include/linux/cdrom.h"
struct cdrom_tochdr {
   __u8 cdth_trk0 ;
   __u8 cdth_trk1 ;
};
#line 219 "/usr/include/linux/cdrom.h"
struct cdrom_tocentry {
   __u8 cdte_track ;
   __u8 cdte_adr : 4 ;
   __u8 cdte_ctrl : 4 ;
   __u8 cdte_format ;
   union cdrom_addr cdte_addr ;
   __u8 cdte_datamode ;
};
#line 281
struct request_sense;
#line 281 "/usr/include/linux/cdrom.h"
struct cdrom_generic_command {
   unsigned char cmd[12] ;
   unsigned char *buffer ;
   unsigned int buflen ;
   int stat ;
   struct request_sense *sense ;
   unsigned char data_direction ;
   int quiet ;
   int timeout ;
   void *reserved[1] ;
};
#line 697 "/usr/include/linux/cdrom.h"
struct request_sense {
   __u8 error_code : 7 ;
   __u8 valid : 1 ;
   __u8 segment_number ;
   __u8 sense_key : 4 ;
   __u8 reserved2 : 1 ;
   __u8 ili : 1 ;
   __u8 reserved1 : 2 ;
   __u8 information[4] ;
   __u8 add_sense_len ;
   __u8 command_info[4] ;
   __u8 asc ;
   __u8 ascq ;
   __u8 fruc ;
   __u8 sks[3] ;
   __u8 asb[46] ;
};
#line 28 "/usr/include/linux/iso_fs.h"
struct iso_primary_descriptor {
   char type[1] ;
   char id[5] ;
   char version[1] ;
   char unused1[1] ;
   char system_id[32] ;
   char volume_id[32] ;
   char unused2[8] ;
   char volume_space_size[8] ;
   char unused3[32] ;
   char volume_set_size[4] ;
   char volume_sequence_number[4] ;
   char logical_block_size[4] ;
   char path_table_size[8] ;
   char type_l_path_table[4] ;
   char opt_type_l_path_table[4] ;
   char type_m_path_table[4] ;
   char opt_type_m_path_table[4] ;
   char root_directory_record[34] ;
   char volume_set_id[128] ;
   char publisher_id[128] ;
   char preparer_id[128] ;
   char application_id[128] ;
   char copyright_file_id[37] ;
   char abstract_file_id[37] ;
   char bibliographic_file_id[37] ;
   char creation_date[17] ;
   char modification_date[17] ;
   char expiration_date[17] ;
   char effective_date[17] ;
   char file_structure_version[1] ;
   char unused4[1] ;
   char application_data[512] ;
   char unused5[653] ;
};
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 846
extern void perror(char const   *__s ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 334 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 353
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/setcd-1.5/setcd.c"
void usage(FILE *f , char *s ) 
{ 


  {
  {
#line 40
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"Usage: %s [-hirs] [-ceflot 0|1] [-dx arg] [device] ...\n\n\t-h   print this message and copyright\n\t-i   print information about cdrom device\n\t-s   print status of cdrom device options\n\t-r   reset option flags to preferred default\n\t-c * set auto-close flag: close tray if cdrom device is opened\n\t-e * set auto-eject/auto-close behaviour\n\t-f * use file flag O_NONBLOCK in open() call\n\t-l * lock door if cdrom device is opened\n\t-o * set auto_open flag: open tray if cdrom device is released\n\t-t * enable cdrom type checking (audio/data)\n\t-d n select disc number n in jukebox\n\t-x n set speed of cdrom n times 150 KB/s (normal audio)\n",
          s);
  }
#line 53
  return;
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/setcd-1.5/setcd.c"
void print_options(int flags , int mask ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;

  {
#line 60
  if (1 & mask) {
#line 60
    if (1 & flags) {
#line 60
      tmp = "set";
    } else {
#line 60
      tmp = "cleared";
    }
    {
#line 60
    printf((char const   */* __restrict  */)"  %-20s %s\n", "Auto close tray:", tmp);
    }
  }
#line 61
  if (2 & mask) {
#line 61
    if (2 & flags) {
#line 61
      tmp___0 = "set";
    } else {
#line 61
      tmp___0 = "cleared";
    }
    {
#line 61
    printf((char const   */* __restrict  */)"  %-20s %s\n", "Auto open tray:", tmp___0);
    }
  }
#line 62
  if (4 & mask) {
#line 62
    if (4 & flags) {
#line 62
      tmp___1 = "set";
    } else {
#line 62
      tmp___1 = "cleared";
    }
    {
#line 62
    printf((char const   */* __restrict  */)"  %-20s %s\n", "Use O_NONBLOCK flag:",
           tmp___1);
    }
  }
#line 63
  if (8 & mask) {
#line 63
    if (8 & flags) {
#line 63
      tmp___2 = "set";
    } else {
#line 63
      tmp___2 = "cleared";
    }
    {
#line 63
    printf((char const   */* __restrict  */)"  %-20s %s\n", "Lock tray:", tmp___2);
    }
  }
#line 64
  if (16 & mask) {
#line 64
    if (16 & flags) {
#line 64
      tmp___3 = "set";
    } else {
#line 64
      tmp___3 = "cleared";
    }
    {
#line 64
    printf((char const   */* __restrict  */)"  %-20s %s\n", "Check CD type:", tmp___3);
    }
  }
#line 65
  return;
}
}
#line 68 "/home/june/repo/benchmarks/collector/temp/setcd-1.5/setcd.c"
void print_audio_info(int fd ) 
{ 
  struct cdrom_tochdr head ;
  struct cdrom_tocentry entry ;
  int last ;
  int first ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 73
  tmp = ioctl(fd, 21253UL, & head);
  }
#line 73
  if (tmp < 0) {
    {
#line 74
    perror("Can\'t read Table of Contents header");
    }
#line 75
    return;
  }
#line 77
  last = (int )head.cdth_trk1;
#line 77
  first = (int )head.cdth_trk0;
#line 78
  if (last == first) {
#line 78
    tmp___0 = "";
  } else {
#line 78
    tmp___0 = "s";
  }
  {
#line 78
  printf((char const   */* __restrict  */)"    %d Track%s, %d--%d\n", (last - first) + 1,
         tmp___0, first, last);
#line 80
  entry.cdte_format = (__u8 )2;
#line 81
  entry.cdte_track = (__u8 )170;
#line 82
  tmp___1 = ioctl(fd, 21254UL, & entry);
  }
#line 82
  if (tmp___1 < 0) {
    {
#line 83
    perror("can\'t read last track entry");
    }
#line 84
    return;
  }
  {
#line 86
  printf((char const   */* __restrict  */)"    Total playing time %d minutes and %d seconds\n",
         (int )entry.cdte_addr.msf.minute, (int )entry.cdte_addr.msf.second);
  }
#line 88
  return;
}
}
#line 90 "/home/june/repo/benchmarks/collector/temp/setcd-1.5/setcd.c"
char *stripped(char *s , int size , int lower ) 
{ 
  char *i ;
  char *end ;
  int tmp ;

  {
#line 92
  end = (s + size) - 1;
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
#line 93
    if (! ((int )*end == 32)) {
#line 93
      goto while_break;
    }
#line 93
    end --;
  }
  while_break: /* CIL Label */ ;
  }
#line 94
  if ((unsigned long )end == (unsigned long )((s + size) - 1)) {
#line 94
    *end = (char )'\000';
  } else {
#line 95
    end ++;
#line 95
    *end = (char )'\000';
  }
#line 96
  if (lower) {
#line 96
    i = s + 1;
    {
#line 96
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 96
      if (! ((unsigned long )i < (unsigned long )end)) {
#line 96
        goto while_break___0;
      }
      {
#line 96
      tmp = tolower((int )*i);
#line 96
      *i = (char )tmp;
#line 96
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 97
  return (s);
}
}
#line 100 "/home/june/repo/benchmarks/collector/temp/setcd-1.5/setcd.c"
void print_data_info(int fd ) 
{ 
  struct iso_primary_descriptor *vdp ;
  char buf[2048] ;
  int sector ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 105
  sector = 16;
  {
#line 105
  while (1) {
    while_continue: /* CIL Label */ ;
#line 105
    if (! (sector < 100)) {
#line 105
      goto while_break;
    }
    {
#line 106
    lseek(fd, (__off_t )(sector * 2048), 0);
#line 107
    read(fd, (void *)(buf), (size_t )2048);
#line 108
    vdp = (struct iso_primary_descriptor *)(& buf);
#line 109
    tmp___2 = strncmp((char const   *)(vdp->id), "CD001", sizeof(vdp->id));
    }
#line 109
    if (! tmp___2) {
      {
#line 111
      tmp = stripped(vdp->volume_id, 32, 1);
#line 111
      printf((char const   */* __restrict  */)"    Volume name: %s\n", tmp);
#line 113
      tmp___0 = stripped(vdp->publisher_id, 128, 0);
#line 113
      printf((char const   */* __restrict  */)"    Publisher: %s\n", tmp___0);
#line 115
      tmp___1 = stripped(vdp->preparer_id, 128, 0);
#line 115
      printf((char const   */* __restrict  */)"    Data preparer: %s\n", tmp___1);
      }
#line 117
      goto while_break;
    }
#line 105
    sector ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 120
  return;
}
}
#line 122 "/home/june/repo/benchmarks/collector/temp/setcd-1.5/setcd.c"
void print_info(int fd ) 
{ 
  int status ;
  int tmp ;

  {
  {
#line 124
  tmp = ioctl(fd, 21286UL, 2147483647);
#line 124
  status = tmp;
  }
#line 125
  if (status < 0) {
    {
#line 126
    perror("can\'t read drive status");
#line 127
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d\n",
            status);
#line 128
    exit(-8);
    }
  }
  {
#line 131
  if (status == 0) {
#line 131
    goto case_0;
  }
#line 134
  if (status == 1) {
#line 134
    goto case_1;
  }
#line 137
  if (status == 2) {
#line 137
    goto case_2;
  }
#line 140
  if (status == 3) {
#line 140
    goto case_3;
  }
#line 143
  if (status == 4) {
#line 143
    goto case_4;
  }
#line 176
  goto switch_default___0;
  case_0: /* CIL Label */ 
  {
#line 132
  printf((char const   */* __restrict  */)"  No information on drive status is available\n");
  }
#line 133
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 135
  printf((char const   */* __restrict  */)"  No disc is inserted\n");
  }
#line 136
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 138
  printf((char const   */* __restrict  */)"  CD tray is open\n");
  }
#line 139
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 141
  printf((char const   */* __restrict  */)"  Drive is not ready\n");
  }
#line 142
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 144
  printf((char const   */* __restrict  */)"  Disc found in drive:");
#line 145
  status = ioctl(fd, 21287UL);
  }
#line 146
  if (status < 0) {
    {
#line 147
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d\n",
            status);
    }
#line 148
    goto switch_break;
  }
  {
#line 152
  if (status == 105) {
#line 152
    goto case_105;
  }
#line 158
  if (status == 100) {
#line 158
    goto case_100;
  }
#line 163
  if (status == 102) {
#line 163
    goto case_102;
  }
#line 163
  if (status == 101) {
#line 163
    goto case_102;
  }
#line 168
  if (status == 104) {
#line 168
    goto case_104;
  }
#line 168
  if (status == 103) {
#line 168
    goto case_104;
  }
#line 172
  goto switch_default;
  case_105: /* CIL Label */ 
  {
#line 153
  printf((char const   */* __restrict  */)" mixed type CD (data/audio)\n");
#line 154
  print_audio_info(fd);
#line 155
  print_data_info(fd);
  }
#line 156
  goto switch_break___0;
  case_100: /* CIL Label */ 
  {
#line 159
  printf((char const   */* __restrict  */)" audio disc\n");
#line 160
  print_audio_info(fd);
  }
#line 161
  goto switch_break___0;
  case_102: /* CIL Label */ 
  case_101: /* CIL Label */ 
  {
#line 164
  printf((char const   */* __restrict  */)" data disc type %d\n", (status - 101) + 1);
#line 165
  print_data_info(fd);
  }
#line 166
  goto switch_break___0;
  case_104: /* CIL Label */ 
  case_103: /* CIL Label */ 
  {
#line 169
  printf((char const   */* __restrict  */)" XA data disc type %d\n", (status - 103) + 1);
#line 170
  print_data_info(fd);
  }
#line 171
  goto switch_break___0;
  switch_default: /* CIL Label */ 
  {
#line 173
  printf((char const   */* __restrict  */)"Unknown status %d\n", status);
  }
  switch_break___0: /* CIL Label */ ;
  }
#line 175
  goto switch_break;
  switch_default___0: /* CIL Label */ 
  {
#line 177
  printf((char const   */* __restrict  */)"  Unknow drive status return value %d\n",
         status);
  }
  switch_break: /* CIL Label */ ;
  }
#line 179
  return;
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/setcd-1.5/setcd.c"
int main(int ac , char **av ) 
{ 
  char *device ;
  int fd ;
  int c ;
  int status ;
  int reset ;
  int info ;
  int typecheck ;
  int speed ;
  int auto_close ;
  int auto_open ;
  int fflags ;
  int lock ;
  int disc ;
  int set ;
  int clear ;
  int flags ;
  struct cdrom_generic_command cgc ;
  struct request_sense sense ;
  unsigned char buffer[28] ;
  unsigned long rw_size ;
  int tmp ;
  int tmp___0 ;

  {
#line 183
  device = (char *)"/dev/cdrom";
#line 185
  status = 0;
#line 185
  reset = 0;
#line 185
  info = 0;
#line 185
  typecheck = -1;
#line 185
  speed = -1;
#line 185
  auto_close = -1;
#line 185
  auto_open = -1;
#line 185
  fflags = -1;
#line 185
  lock = -1;
#line 185
  disc = -1;
#line 187
  set = 0;
#line 187
  clear = 0;
#line 187
  flags = 0;
#line 190
  if (ac == 1) {
    {
#line 191
    usage(stderr, *(av + 0));
#line 192
    exit(-1);
    }
  }
  {
#line 194
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 194
    c = getopt(ac, (char * const  *)av, "c:d:e:f:hil:o:rst:x:");
    }
#line 194
    if (! (c != -1)) {
#line 194
      goto while_break;
    }
    {
#line 196
    if (c == 99) {
#line 196
      goto case_99;
    }
#line 197
    if (c == 100) {
#line 197
      goto case_100;
    }
#line 198
    if (c == 102) {
#line 198
      goto case_102;
    }
#line 199
    if (c == 101) {
#line 199
      goto case_101;
    }
#line 200
    if (c == 105) {
#line 200
      goto case_105;
    }
#line 201
    if (c == 108) {
#line 201
      goto case_108;
    }
#line 202
    if (c == 111) {
#line 202
      goto case_111;
    }
#line 203
    if (c == 114) {
#line 203
      goto case_114;
    }
#line 204
    if (c == 115) {
#line 204
      goto case_115;
    }
#line 205
    if (c == 116) {
#line 205
      goto case_116;
    }
#line 206
    if (c == 120) {
#line 206
      goto case_120;
    }
#line 207
    if (c == 104) {
#line 207
      goto case_104;
    }
#line 213
    goto switch_default;
    case_99: /* CIL Label */ 
    {
#line 196
    auto_close = atoi((char const   *)optarg);
    }
#line 196
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 197
    disc = atoi((char const   *)optarg);
    }
#line 197
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 198
    fflags = atoi((char const   *)optarg);
    }
#line 198
    goto switch_break;
    case_101: /* CIL Label */ 
    {
#line 199
    auto_open = atoi((char const   *)optarg);
#line 199
    auto_close = auto_open;
    }
#line 199
    goto switch_break;
    case_105: /* CIL Label */ 
#line 200
    info = 1;
#line 200
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 201
    lock = atoi((char const   *)optarg);
    }
#line 201
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 202
    auto_open = atoi((char const   *)optarg);
    }
#line 202
    goto switch_break;
    case_114: /* CIL Label */ 
#line 203
    reset = 1;
    case_115: /* CIL Label */ 
#line 204
    status = 1;
#line 204
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 205
    typecheck = atoi((char const   *)optarg);
    }
#line 205
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 206
    speed = atoi((char const   *)optarg);
    }
#line 206
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 208
    printf((char const   */* __restrict  */)"Setcd. Control the behaviour of a cdrom device.\n(c) 1997 David A. van Leeuwen\n$Revision: 1.4 $\n\n");
#line 211
    usage(stdout, *(av + 0));
#line 212
    exit(0);
    }
    switch_default: /* CIL Label */ 
    {
#line 214
    usage(stderr, *(av + 0));
#line 215
    exit(-1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 218
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 219
    if (ac > optind) {
#line 219
      device = *(av + optind);
    }
    {
#line 220
    fd = open((char const   *)device, 2048);
    }
#line 221
    if (fd < 0) {
      {
#line 222
      perror("Can\'t open device");
#line 223
      exit(-2);
      }
    }
    {
#line 225
    printf((char const   */* __restrict  */)"%s:\n", device);
    }
#line 227
    if (reset) {
#line 228
      set = 29;
#line 230
      clear = 2;
    }
#line 232
    if (auto_close >= 0) {
#line 232
      set += auto_close > 0;
#line 232
      clear += ! auto_close;
    }
#line 233
    if (auto_open >= 0) {
#line 233
      set += 2 * (auto_open > 0);
#line 233
      clear += 2 * ! auto_open;
    }
#line 234
    if (fflags >= 0) {
#line 234
      set += 4 * (fflags > 0);
#line 234
      clear += 4 * ! fflags;
    }
#line 235
    if (lock >= 0) {
#line 235
      set += 8 * (lock > 0);
#line 235
      clear += 8 * ! lock;
    }
#line 236
    if (typecheck >= 0) {
#line 236
      set += 16 * (typecheck > 0);
#line 236
      clear += 16 * ! typecheck;
    }
#line 238
    if (set) {
      {
#line 238
      flags = ioctl(fd, 21280UL, set);
      }
#line 238
      if (flags < 0) {
        {
#line 239
        perror("can\'t set options");
#line 240
        exit(-3);
        }
      }
    }
#line 242
    if (clear) {
      {
#line 242
      flags = ioctl(fd, 21281UL, clear);
      }
#line 242
      if (flags < 0) {
        {
#line 243
        perror("can\'t clear options");
#line 244
        exit(-4);
        }
      }
    }
#line 246
    if (! flags) {
#line 246
      if (status) {
        {
#line 246
        flags = ioctl(fd, 21280UL, 0);
        }
#line 246
        if (flags < 0) {
          {
#line 247
          perror("can\'t get options");
#line 248
          exit(-5);
          }
        }
      }
    }
#line 250
    if (set) {
      {
#line 251
      print_options(flags, (set | clear) | -1 * status);
      }
    } else
#line 250
    if (clear) {
      {
#line 251
      print_options(flags, (set | clear) | -1 * status);
      }
    } else
#line 250
    if (status) {
      {
#line 251
      print_options(flags, (set | clear) | -1 * status);
      }
    }
#line 252
    if (speed >= 0) {
      {
#line 258
      memset((void *)(& cgc), 0, sizeof(cgc));
#line 259
      memset((void *)(& sense), 0, sizeof(sense));
#line 260
      memset((void *)(& buffer), 0, sizeof(buffer));
#line 262
      cgc.cmd[0] = (unsigned char)182;
#line 264
      cgc.cmd[10] = (unsigned char)28;
#line 265
      cgc.sense = & sense;
#line 266
      cgc.buffer = buffer;
#line 267
      cgc.buflen = (unsigned int )sizeof(buffer);
#line 268
      cgc.data_direction = (unsigned char)1;
#line 269
      cgc.quiet = 1;
      }
#line 270
      if (speed == 0) {
#line 272
        buffer[0] = (unsigned char)4;
      }
      {
#line 274
      buffer[8] = (unsigned char)255;
#line 275
      buffer[9] = (unsigned char)255;
#line 276
      buffer[10] = (unsigned char)255;
#line 277
      buffer[11] = (unsigned char)255;
#line 278
      rw_size = (unsigned long )(177 * speed);
#line 280
      buffer[12] = (unsigned char )((rw_size >> 24) & 255UL);
#line 281
      buffer[13] = (unsigned char )((rw_size >> 16) & 255UL);
#line 282
      buffer[14] = (unsigned char )((rw_size >> 8) & 255UL);
#line 283
      buffer[15] = (unsigned char )(rw_size & 255UL);
#line 285
      buffer[18] = (unsigned char)3;
#line 286
      buffer[19] = (unsigned char)232;
#line 288
      buffer[20] = (unsigned char )((rw_size >> 24) & 255UL);
#line 289
      buffer[21] = (unsigned char )((rw_size >> 16) & 255UL);
#line 290
      buffer[22] = (unsigned char )((rw_size >> 8) & 255UL);
#line 291
      buffer[23] = (unsigned char )(rw_size & 255UL);
#line 293
      buffer[26] = (unsigned char)3;
#line 294
      buffer[27] = (unsigned char)232;
#line 295
      tmp = ioctl(fd, 21395UL, & cgc);
      }
#line 295
      if (tmp != 0) {
        {
#line 295
        tmp___0 = ioctl(fd, 21282UL, speed);
        }
#line 295
        if (tmp___0 < 0) {
          {
#line 297
          perror("can\'t set speed");
#line 298
          exit(-6);
          }
        } else {
#line 295
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 300
        printf((char const   */* __restrict  */)"  Speed set at ");
        }
#line 301
        if (! speed) {
          {
#line 301
          printf((char const   */* __restrict  */)"maximum rate / normal audio rate\n");
          }
        } else {
          {
#line 302
          printf((char const   */* __restrict  */)"%d KB/s (%dx)\n", 150 * speed,
                 speed);
          }
        }
      }
    }
#line 305
    if (disc >= 0) {
      {
#line 306
      disc = ioctl(fd, 21283UL, disc);
      }
#line 306
      if (disc < 0) {
        {
#line 307
        perror("can\'t select disc");
#line 308
        exit(-7);
        }
      } else {
        {
#line 310
        printf((char const   */* __restrict  */)"  Disc in slot %d selected\n", disc);
        }
      }
    }
#line 312
    if (info) {
      {
#line 312
      print_info(fd);
      }
    }
    {
#line 313
    close(fd);
#line 218
    optind ++;
    }
#line 218
    if (! (ac > optind)) {
#line 218
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 315
  return (0);
}
}
