/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 70 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 88 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __off64_t off_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 30 "/usr/include/x86_64-linux-gnu/sys/mtio.h"
struct mtop {
   short mt_op ;
   int mt_count ;
};
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 28 "/home/june/repo/benchmarks/collector/temp/dvdtape-1.6/isosize.c"
struct iso_primary_descriptor {
   unsigned char type[1] ;
   unsigned char id[5] ;
   unsigned char version[1] ;
   unsigned char unused1[1] ;
   unsigned char system_id[32] ;
   unsigned char volume_id[32] ;
   unsigned char unused2[8] ;
   unsigned char volume_space_size[8] ;
   unsigned char unused3[32] ;
   unsigned char volume_set_size[4] ;
   unsigned char volume_sequence_number[4] ;
   unsigned char logical_block_size[4] ;
   unsigned char path_table_size[8] ;
   unsigned char type_l_path_table[4] ;
   unsigned char opt_type_l_path_table[4] ;
   unsigned char type_m_path_table[4] ;
   unsigned char opt_type_m_path_table[4] ;
   unsigned char root_directory_record[34] ;
   unsigned char volume_set_id[128] ;
   unsigned char publisher_id[128] ;
   unsigned char preparer_id[128] ;
   unsigned char application_id[128] ;
   unsigned char copyright_file_id[37] ;
   unsigned char abstract_file_id[37] ;
   unsigned char bibliographic_file_id[37] ;
   unsigned char creation_date[17] ;
   unsigned char modification_date[17] ;
   unsigned char expiration_date[17] ;
   unsigned char effective_date[17] ;
   unsigned char file_structure_version[1] ;
   unsigned char unused4[1] ;
   unsigned char application_data[512] ;
   unsigned char unused5[653] ;
};
#line 68
struct iso_directory_record;
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 337 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off64_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                  __off64_t __offset ,
                                                                                  int __whence )  __asm__("lseek64")  ;
#line 353
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 846
extern void perror(char const   *__s ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 149 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...)  __asm__("open64")  ;
#line 195
extern int ( __attribute__((__nonnull__(1))) creat)(char const   *__file , mode_t __mode )  __asm__("creat64")  ;
#line 217 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf )  __asm__("stat64")  ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 173 "/usr/include/getopt.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 49 "/home/june/repo/benchmarks/collector/temp/dvdtape-1.6/dvdtape.c"
unsigned long long isosize(int infile ) ;
#line 51 "/home/june/repo/benchmarks/collector/temp/dvdtape-1.6/dvdtape.c"
static int layer  =    0;
#line 52 "/home/june/repo/benchmarks/collector/temp/dvdtape-1.6/dvdtape.c"
static int layers  =    1;
#line 53 "/home/june/repo/benchmarks/collector/temp/dvdtape-1.6/dvdtape.c"
static int layers_specified  =    0;
#line 54 "/home/june/repo/benchmarks/collector/temp/dvdtape-1.6/dvdtape.c"
static int side  =    0;
#line 55 "/home/june/repo/benchmarks/collector/temp/dvdtape-1.6/dvdtape.c"
static int sides  =    1;
#line 56 "/home/june/repo/benchmarks/collector/temp/dvdtape-1.6/dvdtape.c"
static int sides_specified  =    0;
#line 57 "/home/june/repo/benchmarks/collector/temp/dvdtape-1.6/dvdtape.c"
static unsigned long long offset  =    0ULL;
#line 58 "/home/june/repo/benchmarks/collector/temp/dvdtape-1.6/dvdtape.c"
static int offset_specified  =    0;
#line 59 "/home/june/repo/benchmarks/collector/temp/dvdtape-1.6/dvdtape.c"
static unsigned long long combined_length  ;
#line 61 "/home/june/repo/benchmarks/collector/temp/dvdtape-1.6/dvdtape.c"
static int combined_length_specified  =    0;
#line 62 "/home/june/repo/benchmarks/collector/temp/dvdtape-1.6/dvdtape.c"
static unsigned long long layer_length  =    0ULL;
#line 63 "/home/june/repo/benchmarks/collector/temp/dvdtape-1.6/dvdtape.c"
static int length_specified  =    0;
#line 64 "/home/june/repo/benchmarks/collector/temp/dvdtape-1.6/dvdtape.c"
static char *owner  =    (char *)"";
#line 65 "/home/june/repo/benchmarks/collector/temp/dvdtape-1.6/dvdtape.c"
static char *usertext  =    (char *)"";
#line 66 "/home/june/repo/benchmarks/collector/temp/dvdtape-1.6/dvdtape.c"
static char *input_filename  =    (char *)((void *)0);
#line 67 "/home/june/repo/benchmarks/collector/temp/dvdtape-1.6/dvdtape.c"
static char *control_filename  =    (char *)((void *)0);
#line 68 "/home/june/repo/benchmarks/collector/temp/dvdtape-1.6/dvdtape.c"
static char *control_output_filename  =    (char *)((void *)0);
#line 69 "/home/june/repo/benchmarks/collector/temp/dvdtape-1.6/dvdtape.c"
static char *output_filename  =    (char *)"/dev/st0";
#line 70 "/home/june/repo/benchmarks/collector/temp/dvdtape-1.6/dvdtape.c"
static char time_string[7]  ;
#line 71 "/home/june/repo/benchmarks/collector/temp/dvdtape-1.6/dvdtape.c"
static char track_path  ;
#line 74 "/home/june/repo/benchmarks/collector/temp/dvdtape-1.6/dvdtape.c"
static int track_path_specified  =    0;
#line 75 "/home/june/repo/benchmarks/collector/temp/dvdtape-1.6/dvdtape.c"
static char diameter  =    (char )'B';
#line 76 "/home/june/repo/benchmarks/collector/temp/dvdtape-1.6/dvdtape.c"
int readout_speed  =    2;
#line 82 "/home/june/repo/benchmarks/collector/temp/dvdtape-1.6/dvdtape.c"
char master_id[49]  = {      (char )'\000',      (char )'\000'};
#line 87 "/home/june/repo/benchmarks/collector/temp/dvdtape-1.6/dvdtape.c"
static struct option options[18]  = 
#line 87
  {      {"combined-length", 1, (int *)((void *)0), 'C'}, 
        {"controlfile", 1, (int *)((void *)0), 'c'}, 
        {"controlfile-output", 1, (int *)((void *)0), 'N'}, 
        {"diameter", 1, (int *)((void *)0), 'd'}, 
        {"inputfile", 1, (int *)((void *)0), 'i'}, 
        {"layer", 1, (int *)((void *)0), 'l'}, 
        {"layers", 1, (int *)((void *)0), 'L'}, 
        {"length", 1, (int *)((void *)0), 'b'}, 
        {"master-id", 1, (int *)((void *)0), 'm'}, 
        {"offset", 1, (int *)((void *)0), 'o'}, 
        {"outputfile", 1, (int *)((void *)0), 'f'}, 
        {"owner", 1, (int *)((void *)0), 'O'}, 
        {"readout-speed", 1, (int *)((void *)0), 'r'}, 
        {"side", 1, (int *)((void *)0), 's'}, 
        {"sides", 1, (int *)((void *)0), 'S'}, 
        {"track-path", 1, (int *)((void *)0), 't'}, 
        {"usertext", 1, (int *)((void *)0), 'u'}, 
        {(char const   *)0, 0, (int *)((void *)0), 0}};
#line 108 "/home/june/repo/benchmarks/collector/temp/dvdtape-1.6/dvdtape.c"
static void usage(void) 
{ 
  int i ;

  {
  {
#line 111
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: dvdtape [options]\nOptions:\n");
#line 113
  i = 0;
  }
  {
#line 113
  while (1) {
    while_continue: /* CIL Label */ ;
#line 113
    if (! ((unsigned long )options[i].name != (unsigned long )((void *)0))) {
#line 113
      goto while_break;
    }
    {
#line 114
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t--%s",
            options[i].name);
    }
    {
#line 116
    if (options[i].has_arg == 0) {
#line 116
      goto case_0;
    }
#line 119
    if (options[i].has_arg == 1) {
#line 119
      goto case_1;
    }
#line 122
    if (options[i].has_arg == 2) {
#line 122
      goto case_2;
    }
#line 115
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 117
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
#line 118
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 120
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"=%s\n",
            options[i].name);
    }
#line 121
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 123
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[=%s]\n",
            options[i].name);
    }
#line 124
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 113
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 127
  exit(1);
  }
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/dvdtape-1.6/dvdtape.c"
static void parse_options(int argc , char **argv ) 
{ 
  int opt ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 134
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 134
    opt = getopt_long(argc, (char * const  *)argv, "l:L:s:S:o:O:u:l:", (struct option  const  *)(options),
                      (int *)((void *)0));
    }
#line 134
    if (! (opt != -1)) {
#line 134
      goto while_break;
    }
    {
#line 137
    if (opt == 67) {
#line 137
      goto case_67;
    }
#line 146
    if (opt == 99) {
#line 146
      goto case_99;
    }
#line 147
    if (opt == 100) {
#line 147
      goto case_100;
    }
#line 158
    if (opt == 108) {
#line 158
      goto case_108;
    }
#line 159
    if (opt == 76) {
#line 159
      goto case_76;
    }
#line 163
    if (opt == 109) {
#line 163
      goto case_109;
    }
#line 167
    if (opt == 78) {
#line 167
      goto case_78;
    }
#line 168
    if (opt == 111) {
#line 168
      goto case_111;
    }
#line 177
    if (opt == 79) {
#line 177
      goto case_79;
    }
#line 178
    if (opt == 114) {
#line 178
      goto case_114;
    }
#line 188
    if (opt == 115) {
#line 188
      goto case_115;
    }
#line 189
    if (opt == 83) {
#line 189
      goto case_83;
    }
#line 193
    if (opt == 116) {
#line 193
      goto case_116;
    }
#line 209
    if (opt == 117) {
#line 209
      goto case_117;
    }
#line 210
    if (opt == 98) {
#line 210
      goto case_98;
    }
#line 219
    if (opt == 105) {
#line 219
      goto case_105;
    }
#line 220
    if (opt == 102) {
#line 220
      goto case_102;
    }
#line 221
    if (opt == 63) {
#line 221
      goto case_63;
    }
#line 225
    if (opt == 58) {
#line 225
      goto case_58;
    }
#line 136
    goto switch_break;
    case_67: /* CIL Label */ 
    {
#line 138
    tmp = sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%Ld",
                 & combined_length);
    }
#line 138
    if (tmp != 1) {
      {
#line 139
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: not an integer\n",
              optarg);
#line 142
      exit(1);
      }
    }
#line 144
    combined_length_specified = 1;
#line 145
    goto switch_break;
    case_99: /* CIL Label */ 
#line 146
    control_filename = optarg;
#line 146
    goto switch_break;
    case_100: /* CIL Label */ 
    {
#line 148
    tmp___1 = strcmp((char const   *)optarg, "8cm");
    }
#line 148
    if (tmp___1 == 0) {
#line 149
      diameter = (char )'A';
    } else {
      {
#line 150
      tmp___0 = strcmp((char const   *)optarg, "12cm");
      }
#line 150
      if (tmp___0 == 0) {
#line 151
        diameter = (char )'B';
      } else {
        {
#line 153
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Disc diameter must be \"8cm\" or \"12cm\".\n");
#line 155
        exit(1);
        }
      }
    }
#line 157
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 158
    layer = atoi((char const   *)optarg);
    }
#line 158
    goto switch_break;
    case_76: /* CIL Label */ 
    {
#line 160
    layers = atoi((char const   *)optarg);
#line 161
    layers_specified = 1;
    }
#line 162
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 164
    strncpy((char */* __restrict  */)(master_id), (char const   */* __restrict  */)optarg,
            sizeof(master_id) - 1UL);
#line 165
    master_id[sizeof(master_id) - 1UL] = (char )'\000';
    }
#line 166
    goto switch_break;
    case_78: /* CIL Label */ 
#line 167
    control_output_filename = optarg;
#line 167
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 169
    tmp___2 = sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%Ld",
                     & offset);
    }
#line 169
    if (tmp___2 != 1) {
      {
#line 170
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: not an integer\n",
              optarg);
#line 173
      exit(1);
      }
    }
#line 175
    offset_specified = 1;
#line 176
    goto switch_break;
    case_79: /* CIL Label */ 
#line 177
    owner = optarg;
#line 177
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 179
    readout_speed = atoi((char const   *)optarg);
    }
#line 180
    if (readout_speed != 2) {
#line 180
      if (readout_speed != 5) {
#line 180
        if (readout_speed != 10) {
          {
#line 183
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Read out speed must be 2, 5 or 10 for 2.52, 5.04, or 10.08 megabits/second.\n");
#line 185
          exit(1);
          }
        }
      }
    }
#line 187
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 188
    side = atoi((char const   *)optarg);
    }
#line 188
    goto switch_break;
    case_83: /* CIL Label */ 
    {
#line 190
    sides = atoi((char const   *)optarg);
#line 191
    sides_specified = 1;
    }
#line 192
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 194
    tmp___6 = strcmp((char const   *)optarg, "opposite");
    }
#line 194
    if (tmp___6 == 0) {
#line 197
      track_path = (char )'O';
    } else {
      {
#line 194
      tmp___7 = strcmp((char const   *)optarg, "out");
      }
#line 194
      if (tmp___7 == 0) {
#line 197
        track_path = (char )'O';
      } else {
        {
#line 194
        tmp___8 = strcmp((char const   *)optarg, "outward");
        }
#line 194
        if (tmp___8 == 0) {
#line 197
          track_path = (char )'O';
        } else {
          {
#line 198
          tmp___3 = strcmp((char const   *)optarg, "parallel");
          }
#line 198
          if (tmp___3 == 0) {
#line 201
            track_path = (char )'I';
          } else {
            {
#line 198
            tmp___4 = strcmp((char const   *)optarg, "in");
            }
#line 198
            if (tmp___4 == 0) {
#line 201
              track_path = (char )'I';
            } else {
              {
#line 198
              tmp___5 = strcmp((char const   *)optarg, "inward");
              }
#line 198
              if (tmp___5 == 0) {
#line 201
                track_path = (char )'I';
              } else {
                {
#line 203
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Track path must be one of opposite, out, outward (which are synonymous)\nor parallel, in or inward (which are synonymous).\n");
#line 205
                exit(1);
                }
              }
            }
          }
        }
      }
    }
#line 207
    track_path_specified = 1;
#line 208
    goto switch_break;
    case_117: /* CIL Label */ 
#line 209
    usertext = optarg;
#line 209
    goto switch_break;
    case_98: /* CIL Label */ 
    {
#line 211
    tmp___9 = sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%Ld",
                     & layer_length);
    }
#line 211
    if (tmp___9 != 1) {
      {
#line 212
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: not an integer\n",
              optarg);
#line 215
      exit(1);
      }
    }
#line 217
    length_specified = 1;
#line 218
    goto switch_break;
    case_105: /* CIL Label */ 
#line 219
    input_filename = optarg;
#line 219
    goto switch_break;
    case_102: /* CIL Label */ 
#line 220
    output_filename = optarg;
#line 220
    goto switch_break;
    case_63: /* CIL Label */ 
    {
#line 222
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown option.\n");
#line 223
    usage();
    }
    case_58: /* CIL Label */ 
    {
#line 226
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing option.\n");
#line 227
    usage();
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 231
  return;
}
}
#line 233 "/home/june/repo/benchmarks/collector/temp/dvdtape-1.6/dvdtape.c"
static void check_options(void) 
{ 
  int must_abort ;

  {
#line 235
  must_abort = 0;
#line 236
  if (side == 0) {
#line 236
    if (layer == 0) {
#line 236
      if (offset != 0ULL) {
        {
#line 237
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: You have specified a nonzero input offset, even though you are making the first layer of the first side.\n");
        }
      }
    }
  }
#line 239
  if (! sides_specified) {
#line 239
    sides = side + 1;
  }
#line 240
  if (! layers_specified) {
#line 240
    layers = layer + 1;
  }
#line 241
  if (sides > 2) {
    {
#line 242
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Disc cannot have more than two sides.\n");
#line 243
    must_abort = 1;
    }
  }
#line 245
  if (layers > 2) {
    {
#line 246
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Disc cannot have more than two layers.\n");
#line 247
    must_abort = 1;
    }
  }
#line 249
  if (side >= sides) {
    {
#line 250
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Side number (%d) is greater than or equal tonumber of sides(%d).\n",
            side, sides);
#line 254
    must_abort = 1;
    }
  }
#line 256
  if (layer >= layers) {
    {
#line 257
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Layer number (%d) is greater than or equal tonumber of layers(%d).\n",
            layer, layers);
#line 261
    must_abort = 1;
    }
  }
#line 263
  if (! input_filename) {
    {
#line 264
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Input file name not specified.\n");
#line 265
    must_abort = 1;
    }
  }
#line 267
  if (must_abort) {
    {
#line 268
    usage();
    }
  }
#line 270
  return;
}
}
#line 272 "/home/june/repo/benchmarks/collector/temp/dvdtape-1.6/dvdtape.c"
static void full_read(int infd , char *buf , int len ) 
{ 
  int this_len ;
  ssize_t tmp ;
  int *tmp___0 ;

  {
  {
#line 274
  while (1) {
    while_continue: /* CIL Label */ ;
#line 274
    if (! (len > 0)) {
#line 274
      goto while_break;
    }
    {
#line 275
    tmp = read(infd, (void *)buf, (size_t )len);
#line 275
    this_len = (int )tmp;
    }
#line 276
    if (this_len < 0) {
      {
#line 277
      tmp___0 = __errno_location();
      }
#line 277
      if (*tmp___0 == 4) {
#line 278
        goto while_continue;
      } else {
        {
#line 280
        perror("read");
#line 281
        exit(1);
        }
      }
    }
#line 284
    if (this_len == 0) {
      {
#line 285
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Premature end of file.\n");
#line 286
      exit(1);
      }
    }
#line 288
    buf += this_len;
#line 289
    len -= this_len;
  }
  while_break: /* CIL Label */ ;
  }
#line 291
  return;
}
}
#line 293 "/home/june/repo/benchmarks/collector/temp/dvdtape-1.6/dvdtape.c"
static void full_write(int outfd , char const   *buf , int len ) 
{ 
  int this_len ;
  ssize_t tmp ;
  int *tmp___0 ;

  {
  {
#line 295
  while (1) {
    while_continue: /* CIL Label */ ;
#line 295
    if (! (len > 0)) {
#line 295
      goto while_break;
    }
    {
#line 296
    tmp = write(outfd, (void const   *)buf, (size_t )len);
#line 296
    this_len = (int )tmp;
    }
#line 297
    if (this_len < 0) {
      {
#line 298
      tmp___0 = __errno_location();
      }
#line 298
      if (*tmp___0 == 4) {
#line 299
        goto while_continue;
      } else {
        {
#line 301
        perror("write");
#line 302
        exit(1);
        }
      }
    }
#line 305
    buf += this_len;
#line 306
    len -= this_len;
  }
  while_break: /* CIL Label */ ;
  }
#line 308
  return;
}
}
#line 310 "/home/june/repo/benchmarks/collector/temp/dvdtape-1.6/dvdtape.c"
static void copy_bytes(int outfd , int infd , int blocksize , unsigned long long length ) 
{ 
  int blkcount ;
  int nblocks ;
  char *buf ;
  unsigned long __lengthofbuf ;
  void *tmp ;

  {
#line 312
  blkcount = 0;
#line 313
  nblocks = (int )(length / (unsigned long long )blocksize);
  {
#line 314
  while (1) {
    while_continue: /* CIL Label */ ;
#line 314
    if (! (length > 0ULL)) {
#line 314
      goto while_break;
    }
    {
#line 315
    __lengthofbuf = (unsigned long )blocksize;
#line 315
    tmp = __builtin_alloca(sizeof(*buf) * __lengthofbuf);
#line 315
    buf = (char *)tmp;
    }
#line 316
    if (length >= (unsigned long long )blocksize) {
      {
#line 317
      full_read(infd, buf, blocksize);
#line 318
      full_write(outfd, (char const   *)buf, blocksize);
#line 319
      length -= (unsigned long long )blocksize;
      }
    } else {
      {
#line 322
      full_read(infd, buf, (int )length);
#line 323
      memset((void *)(buf + length), 0, (size_t )((unsigned long long )blocksize - length));
#line 324
      full_write(outfd, (char const   *)buf, blocksize);
      }
#line 325
      return;
    }
#line 327
    blkcount ++;
#line 328
    if (blkcount % 10000 == 0) {
      {
#line 329
      printf((char const   */* __restrict  */)"copy_bytes: %d %d byte blocks written (%d%% complete).\n",
             blkcount, blocksize, (blkcount * 100) / nblocks);
#line 331
      fflush(stdout);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 334
  return;
}
}
#line 336 "/home/june/repo/benchmarks/collector/temp/dvdtape-1.6/dvdtape.c"
static void write_vol_label(int outfd ) 
{ 
  char buf[81] ;

  {
  {
#line 339
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"VOL1REEL%-2d                           %-14.14s                            4",
          (side * layers + layer) + 1, owner);
#line 349
  full_write(outfd, (char const   *)(buf), (int )(sizeof(buf) - 1UL));
  }
#line 350
  return;
}
}
#line 352 "/home/june/repo/benchmarks/collector/temp/dvdtape-1.6/dvdtape.c"
static void write_hdr1(int outfd , char *labelid , char *fileid , int block_count ) 
{ 
  char buf[81] ;

  {
  {
#line 355
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%-4.4s%-17.17sDVD   00010001000101%6.6s000000 %06d                    ",
          labelid, fileid, time_string, block_count);
#line 370
  full_write(outfd, (char const   *)(buf), (int )(sizeof(buf) - 1UL));
  }
#line 371
  return;
}
}
#line 373 "/home/june/repo/benchmarks/collector/temp/dvdtape-1.6/dvdtape.c"
static void write_eof_mark(int outfd ) 
{ 
  struct mtop mtop ;
  int tmp ;

  {
  {
#line 378
  mtop.mt_op = (short)5;
#line 379
  mtop.mt_count = 1;
#line 380
  tmp = ioctl(outfd, (unsigned long )(((1U << 30) | (unsigned int )(109 << 8)) | 1U) | (sizeof(struct mtop ) << 16),
              & mtop);
  }
#line 380
  if (tmp < 0) {
    {
#line 381
    perror("writing end-of-file mark in tape stream");
    }
  }
#line 393
  return;
}
}
#line 395 "/home/june/repo/benchmarks/collector/temp/dvdtape-1.6/dvdtape.c"
static void write_hdr2(int outfd , char *labelid , int blocksize , int recordsize ) 
{ 
  char buf[81] ;

  {
  {
#line 398
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%-4.4sF%05d%05d                                   00                            ",
          labelid, blocksize, recordsize);
#line 408
  full_write(outfd, (char const   *)(buf), (int )(sizeof(buf) - 1UL));
#line 409
  write_eof_mark(outfd);
  }
#line 410
  return;
}
}
#line 412 "/home/june/repo/benchmarks/collector/temp/dvdtape-1.6/dvdtape.c"
static void write_ddpid(int outfd ) 
{ 
  char buf[129] ;
  char txtsize[3] ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 416
  tmp___0 = strlen((char const   *)usertext);
  }
#line 416
  if (tmp___0 == 0UL) {
    {
#line 417
    strcpy((char */* __restrict  */)(txtsize), (char const   */* __restrict  */)"  ");
    }
  } else {
    {
#line 419
    tmp = strlen((char const   *)usertext);
#line 419
    sprintf((char */* __restrict  */)(txtsize), (char const   */* __restrict  */)"%02d",
            tmp);
    }
  }
  {
#line 421
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"DDP 2.00                              %-48.48s DV%01d%01d%01d%01d%c%c00%s%-29.29s",
          master_id, sides, side, layers, layer, (int )track_path, (int )diameter,
          txtsize, usertext);
#line 454
  full_write(outfd, (char const   *)(buf), (int )(sizeof(buf) - 1UL));
  }
#line 455
  return;
}
}
#line 457 "/home/june/repo/benchmarks/collector/temp/dvdtape-1.6/dvdtape.c"
static void write_ddpms(int outfd , char *streamtype , int start , int len , char *filename ) 
{ 
  char buf[129] ;

  {
  {
#line 460
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"VVVM%-2.2s        %08d%08d        DV00                             017%-17.17s                                     ",
          streamtype, len, start, filename);
#line 491
  full_write(outfd, (char const   *)(buf), (int )(sizeof(buf) - 1UL));
  }
#line 492
  return;
}
}
#line 494 "/home/june/repo/benchmarks/collector/temp/dvdtape-1.6/dvdtape.c"
static void write_ddp_file(int outfd ) 
{ 
  int num_tape_blocks ;
  int tmp ;
  unsigned long image_blocks ;
  unsigned long image_sectors ;
  unsigned long image_start ;

  {
#line 496
  if (layer == 0) {
#line 496
    tmp = 3;
  } else
#line 496
  if ((int )track_path == 73) {
#line 496
    tmp = 3;
  } else {
#line 496
    tmp = 2;
  }
  {
#line 496
  num_tape_blocks = tmp;
#line 497
  image_blocks = (unsigned long )(((layer_length + 32768ULL) - 1ULL) / 32768ULL);
#line 499
  image_sectors = (unsigned long )((unsigned long long )image_blocks * 16ULL);
#line 502
  write_hdr1(outfd, (char *)"HDR1", (char *)"DDPID", num_tape_blocks);
#line 503
  write_hdr2(outfd, (char *)"HDR2", 128, 128);
#line 504
  write_ddpid(outfd);
  }
#line 505
  if (layer == 0) {
    {
#line 506
    image_start = 196608UL;
#line 507
    write_ddpms(outfd, (char *)"D2", 193024, 16, (char *)"CONTROL.DAT");
    }
  } else
#line 505
  if ((int )track_path == 73) {
    {
#line 506
    image_start = 196608UL;
#line 507
    write_ddpms(outfd, (char *)"D2", 193024, 16, (char *)"CONTROL.DAT");
    }
  } else {
#line 509
    image_start = (unsigned long )((196608ULL + offset / 2048ULL) - 1ULL);
  }
  {
#line 511
  write_ddpms(outfd, (char *)"D0", (int )image_start, (int )image_sectors, (char *)"MAIN.DAT");
#line 512
  write_eof_mark(outfd);
#line 516
  write_hdr1(outfd, (char *)"EOF1", (char *)"DDPID", num_tape_blocks);
#line 517
  write_hdr2(outfd, (char *)"EOF2", 128, 128);
  }
#line 519
  return;
}
}
#line 521 "/home/june/repo/benchmarks/collector/temp/dvdtape-1.6/dvdtape.c"
static void write_big_endian(unsigned char *out , unsigned long val ) 
{ 


  {
#line 523
  *(out + 0) = (unsigned char )(val >> 24);
#line 524
  *(out + 1) = (unsigned char )(val >> 16);
#line 525
  *(out + 2) = (unsigned char )(val >> 8);
#line 526
  *(out + 3) = (unsigned char )val;
#line 527
  return;
}
}
#line 529 "/home/june/repo/benchmarks/collector/temp/dvdtape-1.6/dvdtape.c"
static void make_control(unsigned char *control ) 
{ 
  unsigned long sectors_this_layer ;
  unsigned long sectors_other_layer ;
  int fd ;

  {
  {
#line 532
  memset((void *)control, 0, (size_t )32768);
#line 533
  *(control + 0) = (unsigned char)1;
  }
  {
#line 535
  if (readout_speed == 5) {
#line 535
    goto case_5;
  }
#line 536
  if (readout_speed == 10) {
#line 536
    goto case_10;
  }
#line 534
  goto switch_break;
  case_5: /* CIL Label */ 
#line 535
  *(control + 1) = (unsigned char)1;
#line 535
  goto switch_break;
  case_10: /* CIL Label */ 
#line 536
  *(control + 1) = (unsigned char)2;
#line 536
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 539
  if ((int )diameter == 65) {
#line 540
    *(control + 1) = (unsigned char )((int )*(control + 1) | 16);
  }
#line 542
  *(control + 2) = (unsigned char )(((layers - 1) << 5) | 1);
#line 543
  if ((int )track_path == 79) {
#line 544
    *(control + 2) = (unsigned char )((int )*(control + 2) | 16);
  }
#line 545
  *(control + 3) = (unsigned char )((layers - 1) << 4);
#line 546
  *(control + 5) = (unsigned char)3;
#line 547
  sectors_this_layer = (unsigned long )(196608ULL + layer_length / 2048ULL);
#line 548
  if ((int )track_path == 79) {
#line 548
    if (layers > 1) {
      {
#line 550
      sectors_other_layer = (unsigned long )((combined_length - layer_length) / 2048ULL);
#line 552
      write_big_endian((unsigned char *)(control + 8), (~ sectors_this_layer & 16777215UL) + sectors_other_layer);
#line 554
      write_big_endian((unsigned char *)(control + 12), sectors_this_layer - 1UL);
      }
    } else {
      {
#line 556
      write_big_endian((unsigned char *)(control + 8), sectors_this_layer - 1UL);
      }
    }
  } else {
    {
#line 556
    write_big_endian((unsigned char *)(control + 8), sectors_this_layer - 1UL);
    }
  }
#line 559
  if ((unsigned long )control_output_filename != (unsigned long )((void *)0)) {
    {
#line 561
    fd = creat((char const   *)control_output_filename, (mode_t )438);
    }
#line 561
    if (fd < 0) {
      {
#line 562
      perror((char const   *)control_output_filename);
      }
    } else {
      {
#line 564
      full_write(fd, (char const   *)control, 32768);
#line 565
      close(fd);
      }
    }
  }
#line 568
  return;
}
}
#line 570 "/home/june/repo/benchmarks/collector/temp/dvdtape-1.6/dvdtape.c"
static void write_control_file(int outfd ) 
{ 
  int control_size ;
  int control_fd ;
  char *control ;
  struct stat statbuf ;
  int tmp ;
  void *tmp___0 ;

  {
#line 573
  control_fd = -1;
#line 576
  if ((unsigned long )control_filename == (unsigned long )((void *)0)) {
#line 577
    control_size = 32768;
  } else {
    {
#line 580
    tmp = stat((char const   */* __restrict  */)control_filename, (struct stat */* __restrict  */)(& statbuf));
    }
#line 580
    if (tmp < 0) {
      {
#line 582
      perror((char const   *)control_filename);
#line 583
      exit(1);
      }
    } else {
      {
#line 580
      control_fd = open((char const   *)control_filename, 0);
      }
#line 580
      if (control_fd < 0) {
        {
#line 582
        perror((char const   *)control_filename);
#line 583
        exit(1);
        }
      }
    }
#line 585
    control_size = (int )statbuf.st_size;
  }
  {
#line 589
  write_hdr1(outfd, (char *)"HDR1", (char *)"CONTROL.DAT", 1);
#line 591
  write_hdr2(outfd, (char *)"HDR2", control_size, control_size / 16);
#line 592
  tmp___0 = __builtin_alloca((unsigned long )control_size);
#line 592
  control = (char *)tmp___0;
  }
#line 593
  if ((unsigned long )control == (unsigned long )((void *)0)) {
    {
#line 594
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not allocate %d bytes of memory forcontrol control data.\n",
            control_size);
#line 597
    exit(1);
    }
  }
#line 599
  if (control_fd >= 0) {
    {
#line 600
    full_read(control_fd, control, control_size);
    }
  } else {
    {
#line 602
    make_control((unsigned char *)control);
    }
  }
  {
#line 604
  full_write(outfd, (char const   *)control, control_size);
  }
#line 605
  if (control_fd >= 0) {
    {
#line 606
    close(control_fd);
    }
  }
  {
#line 607
  write_eof_mark(outfd);
#line 611
  write_hdr1(outfd, (char *)"EOF1", (char *)"CONTROL.DAT", 1);
#line 612
  write_hdr2(outfd, (char *)"EOF2", control_size, control_size / 16);
  }
#line 613
  return;
}
}
#line 615 "/home/june/repo/benchmarks/collector/temp/dvdtape-1.6/dvdtape.c"
static void write_dvd_file(int outfd , int infd ) 
{ 
  int blocksize ;
  int block_count ;

  {
  {
#line 617
  blocksize = 32768;
#line 618
  block_count = (int )(((layer_length + (unsigned long long )blocksize) - 1ULL) / (unsigned long long )blocksize);
#line 619
  write_hdr1(outfd, (char *)"HDR1", (char *)"MAIN.DAT", block_count);
#line 620
  write_hdr2(outfd, (char *)"HDR2", blocksize, 2048);
#line 621
  copy_bytes(outfd, infd, blocksize, layer_length);
#line 622
  write_eof_mark(outfd);
#line 627
  write_hdr1(outfd, (char *)"EOF1", (char *)"MAIN.DAT", block_count);
#line 628
  write_hdr2(outfd, (char *)"EOF2", blocksize, 2048);
  }
#line 629
  return;
}
}
#line 631 "/home/june/repo/benchmarks/collector/temp/dvdtape-1.6/dvdtape.c"
static void guess_length_and_offset(int infd ) 
{ 


  {
#line 633
  if (! combined_length_specified) {
#line 634
    if (layers_specified) {
#line 634
      if (layers == 1) {
#line 634
        if (length_specified) {
#line 635
          combined_length = layer_length;
        } else {
          {
#line 637
          combined_length = isosize(infd);
          }
        }
      } else {
        {
#line 637
        combined_length = isosize(infd);
        }
      }
    } else {
      {
#line 637
      combined_length = isosize(infd);
      }
    }
  }
#line 639
  if (layer > 0) {
#line 639
    if (! offset_specified) {
#line 640
      offset = 4269998080ULL;
    }
  }
#line 642
  if (! length_specified) {
#line 643
    layer_length = combined_length - offset;
#line 644
    if (layer == 0) {
#line 644
      if (layer_length > 4699979776ULL) {
#line 645
        layer_length = 4269998080ULL;
      }
    }
  }
#line 647
  if (! layers_specified) {
#line 648
    if (combined_length > 4699979776ULL) {
#line 648
      layers = 2;
    }
  }
#line 650
  if (! track_path_specified) {
#line 651
    if (layers == 1) {
#line 651
      track_path = (char )'I';
    } else {
#line 651
      track_path = (char )'O';
    }
  }
#line 653
  return;
}
}
#line 655 "/home/june/repo/benchmarks/collector/temp/dvdtape-1.6/dvdtape.c"
static void init_time(void) 
{ 
  time_t now ;
  struct tm *tm ;
  int tmp ;

  {
  {
#line 659
  time(& now);
#line 660
  tm = localtime((time_t const   *)(& now));
  }
#line 661
  if (tm->tm_year >= 100) {
#line 661
    tmp = '0';
  } else {
#line 661
    tmp = ' ';
  }
  {
#line 661
  sprintf((char */* __restrict  */)(time_string), (char const   */* __restrict  */)"%c%02d%03d",
          tmp, tm->tm_year % 100, tm->tm_yday + 1);
  }
#line 666
  return;
}
}
#line 668 "/home/june/repo/benchmarks/collector/temp/dvdtape-1.6/dvdtape.c"
int main(int argc , char **argv ) 
{ 
  int outfd ;
  int infd ;
  __off64_t tmp ;

  {
  {
#line 673
  parse_options(argc, argv);
#line 674
  check_options();
#line 676
  init_time();
#line 678
  infd = open((char const   *)input_filename, 0, 420);
  }
#line 678
  if (infd < 0) {
    {
#line 679
    perror((char const   *)input_filename);
#line 680
    exit(1);
    }
  }
  {
#line 682
  guess_length_and_offset(infd);
#line 683
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Writing %Lu bytes of DVD image starting at offset %Lu (layer %d of %d).\n",
          layer_length, offset, layer + 1, layers);
#line 684
  outfd = open((char const   *)output_filename, 65, 420);
  }
#line 684
  if (outfd < 0) {
    {
#line 685
    perror((char const   *)output_filename);
#line 686
    exit(1);
    }
  }
  {
#line 690
  tmp = lseek(infd, (off_t )offset, 0);
  }
#line 690
  if (tmp < 0L) {
    {
#line 691
    perror("llseek");
#line 692
    exit(1);
    }
  }
  {
#line 695
  write_vol_label(outfd);
#line 697
  write_ddp_file(outfd);
  }
#line 698
  if (layer == 0) {
    {
#line 699
    write_control_file(outfd);
    }
  } else
#line 698
  if ((int )track_path == 73) {
    {
#line 699
    write_control_file(outfd);
    }
  }
  {
#line 700
  write_dvd_file(outfd, infd);
#line 702
  close(infd);
#line 703
  close(outfd);
  }
#line 704
  return (0);
}
}
#line 12 "/home/june/repo/benchmarks/collector/temp/dvdtape-1.6/isosize.c"
static unsigned int isonum_731(unsigned char *p ) 
{ 


  {
#line 15
  return ((unsigned int )(((((int )*(p + 0) & 255) | (((int )*(p + 1) & 255) << 8)) | (((int )*(p + 2) & 255) << 16)) | (((int )*(p + 3) & 255) << 24)));
}
}
#line 22 "/home/june/repo/benchmarks/collector/temp/dvdtape-1.6/isosize.c"
static unsigned int isonum_733(unsigned char *p ) 
{ 
  unsigned int tmp ;

  {
  {
#line 25
  tmp = isonum_731(p);
  }
#line 25
  return (tmp);
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/dvdtape-1.6/isosize.c"
unsigned long long isosize(int infile ) 
{ 
  struct iso_primary_descriptor ipd ;
  struct iso_directory_record *idr ;
  unsigned int blksize ;
  unsigned int tmp ;

  {
  {
#line 71
  lseek(infile, (__off64_t )(16 << 11), 0);
#line 72
  read(infile, (void *)(& ipd), sizeof(ipd));
#line 74
  idr = (struct iso_directory_record *)(& ipd.root_directory_record);
#line 75
  blksize = isonum_733(ipd.logical_block_size);
#line 76
  blksize &= (unsigned int )((1 << 16) - 1);
  }
#line 77
  if (blksize == 0U) {
#line 77
    blksize = 2048U;
  }
  {
#line 78
  tmp = isonum_733(ipd.volume_space_size);
  }
#line 78
  return ((unsigned long long )tmp * (unsigned long long )blksize);
}
}
