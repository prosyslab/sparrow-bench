/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 147 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __clockid_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 243 "/usr/include/unistd.h"
typedef __off_t off_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_9 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_9 __sigset_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 91 "/usr/include/time.h"
typedef __clockid_t clockid_t;
#line 35 "/usr/include/x86_64-linux-gnu/bits/fcntl.h"
struct flock {
   short l_type ;
   short l_whence ;
   __off_t l_start ;
   __off_t l_len ;
   __pid_t l_pid ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_30 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_31 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_32 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_33 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_34 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_35 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_36 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_29 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_30 _kill ;
   struct __anonstruct__timer_31 _timer ;
   struct __anonstruct__rt_32 _rt ;
   struct __anonstruct__sigchld_33 _sigchld ;
   struct __anonstruct__sigfault_34 _sigfault ;
   struct __anonstruct__sigpoll_35 _sigpoll ;
   struct __anonstruct__sigsys_36 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_28 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_29 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_28 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_48 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_48 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_terminated_3 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_stopped_4 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_3 __wait_terminated ;
   struct __anonstruct___wait_stopped_4 __wait_stopped ;
};
#line 65 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __gid_t gid_t;
#line 80 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 42 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 53 "/usr/include/mntent.h"
struct mntent {
   char *mnt_fsname ;
   char *mnt_dir ;
   char *mnt_type ;
   char *mnt_opts ;
   int mnt_freq ;
   int mnt_passno ;
};
#line 167 "/home/june/repo/benchmarks/collector/temp/cifs-utils-6.0/mount.cifs.c"
struct parsed_mount_info {
   unsigned long flags ;
   char host[1026] ;
   char share[257] ;
   char prefix[4097] ;
   char options[4096] ;
   char domain[65] ;
   char username[33] ;
   char password[129] ;
   char addrlist[752] ;
   unsigned int got_user : 1 ;
   unsigned int got_password : 1 ;
   unsigned int fakemnt : 1 ;
   unsigned int nomtab : 1 ;
   unsigned int verboseflag : 1 ;
   unsigned int nofail : 1 ;
};
#line 1989 "/home/june/repo/benchmarks/collector/temp/cifs-utils-6.0/mount.cifs.c"
union __anonunion_66 {
   int __in ;
   int __i ;
};
#line 1994 "/home/june/repo/benchmarks/collector/temp/cifs-utils-6.0/mount.cifs.c"
union __anonunion_67 {
   int __in ;
   int __i ;
};
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 90 "/usr/include/x86_64-linux-gnu/sys/socket.h"
struct sockaddr_in;
#line 90
struct sockaddr_in6;
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 209 "/usr/include/netinet/in.h"
union __anonunion___in6_u_27 {
   uint8_t __u6_addr8[16] ;
   uint16_t __u6_addr16[8] ;
   uint32_t __u6_addr32[4] ;
};
#line 209 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion___in6_u_27 __in6_u ;
};
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 252 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 567 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 432
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) alarm)(unsigned int __seconds ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 790
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) link)(char const   *__from ,
                                                                                             char const   *__to ) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 956
extern int fsync(int __fd ) ;
#line 1016
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ftruncate)(int __fd ,
                                                                                __off_t __length ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 242 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 263 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf ) ;
#line 334 "/usr/include/time.h"
extern int nanosleep(struct timespec  const  *__requested_time , struct timespec *__remaining ) ;
#line 342
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) clock_gettime)(clockid_t __clock_id ,
                                                                                    struct timespec *__tp ) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 146
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 87 "/usr/include/mntent.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) endmntent)(FILE *__stream ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 218 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigfillset)(sigset_t *__set ) ;
#line 227
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigismember)(sigset_t const   *__set ,
                                                                                                  int __signo ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/cifs-utils-6.0/mount.h"
int mtab_unusable(void) ;
#line 36
int lock_mtab(void) ;
#line 37
void unlock_mtab(void) ;
#line 38
int my_endmntent(FILE *stream , off_t size ) ;
#line 48 "/home/june/repo/benchmarks/collector/temp/cifs-utils-6.0/mtab.c"
static int we_created_lockfile  =    0;
#line 49 "/home/june/repo/benchmarks/collector/temp/cifs-utils-6.0/mtab.c"
static int lockfile_fd  =    -1;
#line 52 "/home/june/repo/benchmarks/collector/temp/cifs-utils-6.0/mtab.c"
static int signals_have_been_setup  =    0;
#line 54 "/home/june/repo/benchmarks/collector/temp/cifs-utils-6.0/mtab.c"
static void handler(int sig  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 56
  exit(8);
  }
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/cifs-utils-6.0/mtab.c"
static void setlkw_timeout(int sig  __attribute__((__unused__)) ) 
{ 


  {
#line 62
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/cifs-utils-6.0/mtab.c"
struct timeval mono_time(void) 
{ 
  struct timeval ret ;
  struct timespec ts ;
  int tmp ;

  {
  {
#line 70
  tmp = clock_gettime(1, & ts);
  }
#line 70
  if (tmp == 0) {
#line 71
    ret.tv_sec = ts.tv_sec;
#line 72
    ret.tv_usec = ts.tv_nsec / 1000L;
#line 73
    return (ret);
  }
  {
#line 76
  gettimeofday((struct timeval */* __restrict  */)(& ret), (__timezone_ptr_t )((void *)0));
  }
#line 77
  return (ret);
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/cifs-utils-6.0/mtab.c"
int mtab_unusable(void) 
{ 
  struct stat mstat ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 89
  tmp___0 = lstat((char const   */* __restrict  */)"/etc/mtab", (struct stat */* __restrict  */)(& mstat));
  }
#line 89
  if (tmp___0) {
    {
#line 90
    tmp = __errno_location();
    }
#line 90
    return (*tmp);
  } else
#line 91
  if ((mstat.st_mode & 61440U) == 40960U) {
#line 92
    return (31);
  }
#line 93
  return (0);
}
}
#line 97 "/home/june/repo/benchmarks/collector/temp/cifs-utils-6.0/mtab.c"
void unlock_mtab(void) 
{ 


  {
#line 99
  if (we_created_lockfile) {
    {
#line 100
    close(lockfile_fd);
#line 101
    lockfile_fd = -1;
#line 102
    unlink("/etc/mtab~");
#line 103
    we_created_lockfile = 0;
    }
  }
#line 105
  return;
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/cifs-utils-6.0/mtab.c"
int lock_mtab(void) 
{ 
  int i ;
  struct timespec waittime ;
  struct timeval maxtime ;
  char linktargetfile[sizeof("/etc/mtab~") + 20UL] ;
  int sig ;
  struct sigaction sa ;
  int tmp ;
  __pid_t tmp___0 ;
  struct timeval now ;
  struct flock flock ;
  int errsv ;
  int j ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
#line 155
  if (! signals_have_been_setup) {
    {
#line 156
    sig = 0;
#line 159
    sa.__sigaction_handler.sa_handler = & handler;
#line 160
    sa.sa_flags = 0;
#line 161
    sigfillset(& sa.sa_mask);
    }
    {
#line 163
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 163
      sig ++;
#line 163
      tmp = sigismember((sigset_t const   *)(& sa.sa_mask), sig);
      }
#line 163
      if (tmp != -1) {
#line 163
        if (! (sig != 17)) {
#line 163
          goto while_break;
        }
      } else {
#line 163
        goto while_break;
      }
#line 165
      if (sig == 14) {
#line 166
        sa.__sigaction_handler.sa_handler = & setlkw_timeout;
      } else {
#line 168
        sa.__sigaction_handler.sa_handler = & handler;
      }
      {
#line 169
      sigaction(sig, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((struct sigaction *)0));
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 171
    signals_have_been_setup = 1;
  }
  {
#line 174
  tmp___0 = getpid();
#line 174
  sprintf((char */* __restrict  */)(linktargetfile), (char const   */* __restrict  */)"/etc/mtab~%d",
          tmp___0);
#line 176
  i = open((char const   *)(linktargetfile), 65, 384);
  }
#line 177
  if (i < 0) {
#line 182
    return (16);
  }
  {
#line 184
  close(i);
#line 186
  maxtime = mono_time();
#line 187
  maxtime.tv_sec += 30L;
#line 189
  waittime.tv_sec = (__time_t )0;
#line 190
  waittime.tv_nsec = (__syscall_slong_t )5000000;
  }
  {
#line 193
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 193
    if (! (! we_created_lockfile)) {
#line 193
      goto while_break___0;
    }
    {
#line 198
    j = link((char const   *)(linktargetfile), "/etc/mtab~");
#line 199
    tmp___1 = __errno_location();
#line 199
    errsv = *tmp___1;
    }
#line 201
    if (j == 0) {
#line 202
      we_created_lockfile = 1;
    }
#line 204
    if (j < 0) {
#line 204
      if (errsv != 17) {
        {
#line 205
        unlink((char const   *)(linktargetfile));
        }
#line 206
        return (16);
      }
    }
    {
#line 209
    lockfile_fd = open("/etc/mtab~", 1);
    }
#line 211
    if (lockfile_fd < 0) {
      {
#line 213
      now = mono_time();
#line 214
      tmp___2 = __errno_location();
      }
#line 214
      if (*tmp___2 == 2) {
#line 214
        if (now.tv_sec < maxtime.tv_sec) {
#line 215
          we_created_lockfile = 0;
#line 216
          goto while_continue___0;
        }
      }
      {
#line 218
      unlink((char const   *)(linktargetfile));
      }
#line 219
      return (16);
    }
#line 222
    flock.l_type = (short)1;
#line 223
    flock.l_whence = (short)0;
#line 224
    flock.l_start = (__off_t )0;
#line 225
    flock.l_len = (__off_t )0;
#line 227
    if (j == 0) {
      {
#line 231
      fcntl(lockfile_fd, 6, & flock);
#line 232
      unlink((char const   *)(linktargetfile));
      }
    } else {
      {
#line 235
      now = mono_time();
      }
#line 236
      if (now.tv_sec < maxtime.tv_sec) {
        {
#line 237
        alarm((unsigned int )(maxtime.tv_sec - now.tv_sec));
#line 238
        tmp___3 = fcntl(lockfile_fd, 7, & flock);
        }
#line 238
        if (tmp___3 == -1) {
          {
#line 239
          unlink((char const   *)(linktargetfile));
          }
#line 240
          return (16);
        }
        {
#line 242
        alarm(0U);
#line 243
        nanosleep((struct timespec  const  *)(& waittime), (struct timespec *)((void *)0));
        }
      } else {
        {
#line 245
        unlink((char const   *)(linktargetfile));
        }
#line 246
        return (16);
      }
      {
#line 248
      close(lockfile_fd);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 251
  return (0);
}
}
#line 259 "/home/june/repo/benchmarks/collector/temp/cifs-utils-6.0/mtab.c"
int my_endmntent(FILE *stream , off_t size ) 
{ 
  int rc ;
  int fd ;
  int ignore  __attribute__((__unused__)) ;
  int *tmp ;

  {
  {
#line 264
  fd = fileno(stream);
  }
#line 265
  if (fd < 0) {
#line 266
    return (-9);
  }
  {
#line 268
  rc = fflush(stream);
  }
#line 269
  if (! rc) {
    {
#line 270
    rc = fsync(fd);
    }
  }
#line 273
  if (rc) {
    {
#line 276
    tmp = __errno_location();
#line 276
    rc = *tmp;
#line 277
    ignore = ftruncate(fd, size);
    }
  }
  {
#line 280
  endmntent(stream);
  }
#line 281
  return (rc);
}
}
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 187
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 519
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atexit)(void (*__func)(void) ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 606
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) mktemp)(char *__template ) ;
#line 734
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) realpath)(char const   * __restrict  __name ,
                                                                                 char * __restrict  __resolved ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 180
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *__old ,
                                                                             char const   *__new ) ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 405
extern  __attribute__((__nothrow__)) int ( /* format attribute */  asprintf)(char ** __restrict  __ptr ,
                                                                             char const   * __restrict  __fmt 
                                                                             , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 873
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 879
extern int pclose(FILE *__stream ) ;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 497
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 675
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 678
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 681
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getgid)(void) ;
#line 700
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setuid)(__uid_t __uid ) ;
#line 705
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setreuid)(__uid_t __ruid ,
                                                                               __uid_t __euid ) ;
#line 717
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setgid)(__gid_t __gid ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 948 "/usr/include/unistd.h"
extern char *( __attribute__((__nonnull__(1))) getpass)(char const   *__prompt ) ;
#line 116 "/usr/include/pwd.h"
extern struct passwd *getpwnam(char const   *__name ) ;
#line 111 "/usr/include/grp.h"
extern struct group *getgrnam(char const   *__name ) ;
#line 127 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 135 "/usr/include/x86_64-linux-gnu/sys/mount.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) mount)(char const   *__special_file ,
                                                                            char const   *__dir ,
                                                                            char const   *__fstype ,
                                                                            unsigned long __rwflag ,
                                                                            void const   *__data ) ;
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 173 "/usr/include/getopt.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 671 "/usr/include/netdb.h"
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) gai_strerror)(int __ecode ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 184
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strndup)(char const   *__string ,
                                                                                                size_t __n )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 285
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strcspn)(char const   *__s ,
                                                                                                   char const   *__reject )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 406
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strnlen)(char const   *__string ,
                                                                                                 size_t __maxlen )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 538
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 66 "/usr/include/mntent.h"
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) setmntent)(char const   *__file ,
                                                                                  char const   *__mode ) ;
#line 71
extern  __attribute__((__nothrow__)) struct mntent *( __attribute__((__leaf__)) getmntent)(FILE *__stream ) ;
#line 83
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) addmntent)(FILE * __restrict  __stream ,
                                                                                struct mntent  const  * __restrict  __mnt ) ;
#line 26 "/usr/include/libgen.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) dirname)(char *__path ) ;
#line 34
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) __xpg_basename)(char *__path ) ;
#line 57 "/usr/include/x86_64-linux-gnu/sys/mman.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) mmap)(void *__addr ,
                                                                             size_t __len ,
                                                                             int __prot ,
                                                                             int __flags ,
                                                                             int __fd ,
                                                                             __off_t __offset ) ;
#line 76
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) munmap)(void *__addr ,
                                                                             size_t __len ) ;
#line 248 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigprocmask)(int __how ,
                                                                                  sigset_t const   * __restrict  __set ,
                                                                                  sigset_t * __restrict  __oset ) ;
#line 102 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t wait(union wait *__stat_loc ) ;
#line 28 "/usr/include/x86_64-linux-gnu/sys/fsuid.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setfsuid)(__uid_t __uid ) ;
#line 31
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setfsgid)(__gid_t __gid ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/cifs-utils-6.0/util.h"
size_t strlcpy(char *d , char const   *s , size_t bufsize ) ;
#line 29
size_t strlcat(char *d , char const   *s , size_t bufsize ) ;
#line 31
char *getusername(uid_t uid ) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/cifs-utils-6.0/resolve_host.h"
int resolve_host(char const   *host , char *addrstr ) ;
#line 185 "/home/june/repo/benchmarks/collector/temp/cifs-utils-6.0/mount.cifs.c"
char const   *thisprogram  ;
#line 186 "/home/june/repo/benchmarks/collector/temp/cifs-utils-6.0/mount.cifs.c"
char const   *cifs_fstype  =    "cifs";
#line 188
static int parse_unc(char const   *unc_name , struct parsed_mount_info *parsed_info ) ;
#line 190 "/home/june/repo/benchmarks/collector/temp/cifs-utils-6.0/mount.cifs.c"
static int check_setuid(void) 
{ 
  __uid_t tmp ;

  {
  {
#line 192
  tmp = geteuid();
  }
#line 192
  if (tmp) {
    {
#line 193
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"This program is not installed setuid root -  \"user\" CIFS mounts not supported.\n");
    }
#line 195
    return (1);
  }
#line 206
  return (0);
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/cifs-utils-6.0/mount.cifs.c"
static int check_fstab(char const   *progname , char const   *mountpoint , char const   *devname ,
                       char **options ) 
{ 
  FILE *fstab ;
  struct mntent *mnt ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 217
  fstab = setmntent("/etc/fstab", "r");
  }
#line 218
  if (! fstab) {
    {
#line 219
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t open %s for reading!\n",
            "/etc/fstab");
    }
#line 220
    return (16);
  }
  {
#line 223
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 223
    mnt = getmntent(fstab);
    }
#line 223
    if (! mnt) {
#line 223
      goto while_break;
    }
    {
#line 224
    tmp = strcmp(mountpoint, (char const   *)mnt->mnt_dir);
    }
#line 224
    if (! tmp) {
#line 225
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 227
  endmntent(fstab);
  }
#line 229
  if ((unsigned long )mnt == (unsigned long )((void *)0)) {
    {
#line 230
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: permission denied: no match for %s found in %s\n",
            progname, mountpoint, "/etc/fstab");
    }
#line 232
    return (1);
  } else {
    {
#line 229
    tmp___0 = strcmp((char const   *)mnt->mnt_fsname, devname);
    }
#line 229
    if (tmp___0) {
      {
#line 230
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: permission denied: no match for %s found in %s\n",
              progname, mountpoint, "/etc/fstab");
      }
#line 232
      return (1);
    }
  }
  {
#line 241
  free((void *)*options);
#line 242
  *options = strdup((char const   *)mnt->mnt_opts);
  }
#line 243
  return (0);
}
}
#line 255 "/home/june/repo/benchmarks/collector/temp/cifs-utils-6.0/mount.cifs.c"
static int mount_usage(FILE *stream ) 
{ 


  {
  {
#line 257
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\nUsage:  %s <remotetarget> <dir> -o <options>\n",
          thisprogram);
#line 259
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\nMount the remote target, specified as a UNC name,");
#line 260
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)" to a local directory.\n\nOptions:\n");
#line 261
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\tuser=<arg>\n\tpass=<arg>\n\tdom=<arg>\n");
#line 262
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\nLess commonly used options:");
#line 263
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\n\tcredentials=<filename>,guest,perm,noperm,setuids,nosetuids,rw,ro,");
#line 265
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\n\tsep=<char>,iocharset=<codepage>,suid,nosuid,exec,noexec,serverino,");
#line 267
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\n\tmapchars,nomapchars,nolock,servernetbiosname=<SRV_RFC1001NAME>");
#line 269
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\n\tdirectio,nounix,cifsacl,sec=<authentication mechanism>,sign,fsc");
#line 271
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\n\nOptions not needed for servers supporting CIFS Unix extensions");
#line 273
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\n\t(e.g. unneeded for mounts to most Samba versions):");
#line 275
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\n\tuid=<uid>,gid=<gid>,dir_mode=<mode>,file_mode=<mode>,sfu");
#line 277
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\n\nRarely used options:");
#line 278
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\n\tport=<tcpport>,rsize=<size>,wsize=<size>,unc=<unc_name>,ip=<ip_address>,");
#line 280
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\n\tdev,nodev,nouser_xattr,netbiosname=<OUR_RFC1001NAME>,hard,soft,intr,");
#line 282
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\n\tnointr,ignorecase,noposixpaths,noacl,prefixpath=<path>,nobrl");
#line 284
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\n\nOptions are described in more detail in the manual page");
#line 286
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\n\tman 8 mount.cifs\n");
#line 287
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\nTo display the version number of the mount helper:");
#line 288
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\n\t%s -V\n",
          thisprogram);
  }
#line 290
  if ((unsigned long )stream == (unsigned long )stderr) {
#line 291
    return (1);
  }
#line 292
  return (0);
}
}
#line 300 "/home/june/repo/benchmarks/collector/temp/cifs-utils-6.0/mount.cifs.c"
static int set_password(struct parsed_mount_info *parsed_info , char const   *src ) 
{ 
  char *dst ;
  unsigned int i ;
  unsigned int j ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 302
  dst = parsed_info->password;
#line 303
  i = 0U;
#line 303
  j = 0U;
  {
#line 305
  while (1) {
    while_continue: /* CIL Label */ ;
#line 305
    if (! *(src + i)) {
#line 305
      goto while_break;
    }
#line 306
    if ((int const   )*(src + i) == 44) {
#line 307
      tmp = j;
#line 307
      j ++;
#line 307
      *(dst + tmp) = (char )',';
    }
#line 308
    tmp___0 = j;
#line 308
    j ++;
#line 308
    tmp___1 = i;
#line 308
    i ++;
#line 308
    *(dst + tmp___0) = (char )*(src + tmp___1);
#line 309
    if ((unsigned long )j > sizeof(parsed_info->password)) {
      {
#line 310
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Converted password too long!\n");
      }
#line 311
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 314
  *(dst + j) = (char )'\000';
#line 315
  parsed_info->got_password = 1U;
#line 316
  return (0);
}
}
#line 484 "/home/june/repo/benchmarks/collector/temp/cifs-utils-6.0/mount.cifs.c"
static int drop_capabilities(int parent  __attribute__((__unused__)) ) 
{ 


  {
#line 487
  return (0);
}
}
#line 490 "/home/june/repo/benchmarks/collector/temp/cifs-utils-6.0/mount.cifs.c"
static int toggle_dac_capability(int writable  __attribute__((__unused__)) , int enable  __attribute__((__unused__)) ) 
{ 


  {
#line 493
  return (0);
}
}
#line 498 "/home/june/repo/benchmarks/collector/temp/cifs-utils-6.0/mount.cifs.c"
static void null_terminate_endl(char *source ) 
{ 
  char *newline ;
  char *tmp ;

  {
  {
#line 500
  tmp = strchr((char const   *)source, '\n');
#line 500
  newline = tmp;
  }
#line 501
  if (newline) {
#line 502
    *newline = (char )'\000';
  }
#line 503
  return;
}
}
#line 510 "/home/june/repo/benchmarks/collector/temp/cifs-utils-6.0/mount.cifs.c"
static int parse_cred_line(char *line , char **target ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 512
  if ((unsigned long )line == (unsigned long )((void *)0)) {
#line 513
    goto parsing_err;
  } else
#line 512
  if ((unsigned long )target == (unsigned long )((void *)0)) {
#line 513
    goto parsing_err;
  }
  {
#line 516
  *target = strchr((char const   *)line, '=');
  }
#line 517
  if (! *target) {
#line 518
    goto parsing_err;
  }
  {
#line 519
  (*target) ++;
#line 522
  tmp = strncasecmp("user", (char const   *)line, (size_t )4);
  }
#line 522
  if (tmp == 0) {
#line 523
    return (1);
  }
  {
#line 524
  tmp___0 = strncasecmp("pass", (char const   *)line, (size_t )4);
  }
#line 524
  if (tmp___0 == 0) {
#line 525
    return (2);
  }
  {
#line 526
  tmp___1 = strncasecmp("dom", (char const   *)line, (size_t )3);
  }
#line 526
  if (tmp___1 == 0) {
#line 527
    return (4);
  }
  parsing_err: 
#line 530
  return (0);
}
}
#line 533 "/home/june/repo/benchmarks/collector/temp/cifs-utils-6.0/mount.cifs.c"
static int open_cred_file(char *file_name , struct parsed_mount_info *parsed_info ) 
{ 
  char *line_buf ;
  char *temp_val ;
  FILE *fs ;
  int i ;
  int line_buf_size ;
  int min_non_white ;
  int *tmp ;
  int *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 536
  line_buf = (char *)((void *)0);
#line 537
  temp_val = (char *)((void *)0);
#line 538
  fs = (FILE *)((void *)0);
#line 540
  line_buf_size = 4096;
#line 541
  min_non_white = 10;
#line 543
  i = toggle_dac_capability(0, 1);
  }
#line 544
  if (i) {
#line 545
    goto return_i;
  }
  {
#line 547
  i = access((char const   *)file_name, 4);
  }
#line 548
  if (i) {
    {
#line 549
    toggle_dac_capability(0, 0);
#line 550
    tmp = __errno_location();
#line 550
    i = *tmp;
    }
#line 551
    goto return_i;
  }
  {
#line 554
  fs = fopen((char const   */* __restrict  */)file_name, (char const   */* __restrict  */)"r");
  }
#line 555
  if ((unsigned long )fs == (unsigned long )((void *)0)) {
    {
#line 556
    toggle_dac_capability(0, 0);
#line 557
    tmp___0 = __errno_location();
#line 557
    i = *tmp___0;
    }
#line 558
    goto return_i;
  }
  {
#line 561
  i = toggle_dac_capability(0, 0);
  }
#line 562
  if (i) {
#line 563
    goto return_i;
  }
  {
#line 565
  tmp___1 = malloc((size_t )line_buf_size);
#line 565
  line_buf = (char *)tmp___1;
  }
#line 566
  if ((unsigned long )line_buf == (unsigned long )((void *)0)) {
#line 567
    i = 2;
#line 568
    goto return_i;
  }
  {
#line 572
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 572
    tmp___4 = fgets((char */* __restrict  */)line_buf, line_buf_size, (FILE */* __restrict  */)fs);
    }
#line 572
    if (! tmp___4) {
#line 572
      goto while_break;
    }
#line 574
    i = 0;
    {
#line 574
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 574
      if (! (i < (line_buf_size - min_non_white) + 1)) {
#line 574
        goto while_break___0;
      }
#line 575
      if ((int )*(line_buf + i) != 32) {
#line 575
        if ((int )*(line_buf + i) != 9) {
#line 576
          goto while_break___0;
        }
      }
#line 574
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 578
    null_terminate_endl(line_buf);
#line 581
    tmp___2 = parse_cred_line(line_buf + i, & temp_val);
    }
    {
#line 582
    if (tmp___2 == 1) {
#line 582
      goto case_1;
    }
#line 587
    if (tmp___2 == 2) {
#line 587
      goto case_2;
    }
#line 592
    if (tmp___2 == 4) {
#line 592
      goto case_4;
    }
#line 599
    if (tmp___2 == 0) {
#line 599
      goto case_0;
    }
#line 581
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 583
    strlcpy(parsed_info->username, (char const   *)temp_val, sizeof(parsed_info->username));
#line 585
    parsed_info->got_user = 1U;
    }
#line 586
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 588
    i = set_password(parsed_info, (char const   *)temp_val);
    }
#line 589
    if (i) {
#line 590
      goto return_i;
    }
#line 591
    goto switch_break;
    case_4: /* CIL Label */ 
#line 593
    if (parsed_info->verboseflag) {
      {
#line 594
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"domain=%s\n",
              temp_val);
      }
    }
    {
#line 596
    strlcpy(parsed_info->domain, (char const   *)temp_val, sizeof(parsed_info->domain));
    }
#line 598
    goto switch_break;
    case_0: /* CIL Label */ 
#line 600
    if (parsed_info->verboseflag) {
#line 601
      if (temp_val) {
#line 601
        tmp___3 = (char const   *)temp_val;
      } else {
#line 601
        tmp___3 = "(null)";
      }
      {
#line 601
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Credential formatted incorrectly: %s\n",
              tmp___3);
      }
    }
#line 604
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 607
  i = 0;
  return_i: 
#line 609
  if ((unsigned long )fs != (unsigned long )((void *)0)) {
    {
#line 610
    fclose(fs);
    }
  }
#line 613
  if ((unsigned long )line_buf != (unsigned long )((void *)0)) {
    {
#line 614
    memset((void *)line_buf, 0, (size_t )line_buf_size);
    }
  }
  {
#line 615
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 615
    if ((unsigned long )line_buf != (unsigned long )((void *)0)) {
      {
#line 615
      free((void *)line_buf);
#line 615
      line_buf = (char *)((void *)0);
      }
    }
#line 615
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 616
  return (i);
}
}
#line 619 "/home/june/repo/benchmarks/collector/temp/cifs-utils-6.0/mount.cifs.c"
static int get_password_from_file(int file_descript , char *filename , struct parsed_mount_info *parsed_info ) 
{ 
  int rc ;
  char buf[sizeof(parsed_info->password) + 1UL] ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  ssize_t tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;

  {
#line 623
  rc = 0;
#line 626
  if ((unsigned long )filename != (unsigned long )((void *)0)) {
    {
#line 627
    rc = toggle_dac_capability(0, 1);
    }
#line 628
    if (rc) {
#line 629
      return (rc);
    }
    {
#line 631
    rc = access((char const   *)filename, 4);
    }
#line 632
    if (rc) {
      {
#line 633
      tmp = __errno_location();
#line 633
      tmp___0 = strerror(*tmp);
#line 633
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mount.cifs failed: access check of %s failed: %s\n",
              filename, tmp___0);
#line 636
      toggle_dac_capability(0, 0);
      }
#line 637
      return (2);
    }
    {
#line 640
    file_descript = open((char const   *)filename, 0);
    }
#line 641
    if (file_descript < 0) {
      {
#line 642
      tmp___1 = __errno_location();
#line 642
      tmp___2 = strerror(*tmp___1);
#line 642
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mount.cifs failed. %s attempting to open password file %s\n",
              tmp___2, filename);
#line 645
      toggle_dac_capability(0, 0);
      }
#line 646
      return (2);
    }
    {
#line 649
    rc = toggle_dac_capability(0, 0);
    }
#line 650
    if (rc) {
#line 651
      rc = 2;
#line 652
      goto get_pw_exit;
    }
  }
  {
#line 656
  memset((void *)(buf), 0, sizeof(buf));
#line 657
  tmp___3 = read(file_descript, (void *)(buf), sizeof(buf) - 1UL);
#line 657
  rc = (int )tmp___3;
  }
#line 658
  if (rc < 0) {
    {
#line 659
    tmp___4 = __errno_location();
#line 659
    tmp___5 = strerror(*tmp___4);
#line 659
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mount.cifs failed. Error %s reading password file\n",
            tmp___5);
#line 662
    rc = 2;
    }
#line 663
    goto get_pw_exit;
  }
  {
#line 666
  rc = set_password(parsed_info, (char const   *)(buf));
  }
  get_pw_exit: 
#line 669
  if ((unsigned long )filename != (unsigned long )((void *)0)) {
    {
#line 670
    close(file_descript);
    }
  }
#line 671
  return (rc);
}
}
#line 677 "/home/june/repo/benchmarks/collector/temp/cifs-utils-6.0/mount.cifs.c"
static int parse_opt_token(char const   *token ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  size_t tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;

  {
#line 679
  if ((unsigned long )token == (unsigned long )((void *)0)) {
#line 680
    return (-1);
  }
  {
#line 682
  tmp = strncmp(token, "users", (size_t )5);
  }
#line 682
  if (tmp == 0) {
#line 683
    return (1);
  }
  {
#line 684
  tmp___0 = strncmp(token, "user_xattr", (size_t )10);
  }
#line 684
  if (tmp___0 == 0) {
#line 685
    return (3);
  }
  {
#line 686
  tmp___1 = strncmp(token, "user", (size_t )4);
  }
#line 686
  if (tmp___1 == 0) {
#line 687
    return (2);
  }
  {
#line 688
  tmp___2 = strncmp(token, "pass", (size_t )4);
  }
#line 688
  if (tmp___2 == 0) {
#line 689
    return (4);
  }
  {
#line 690
  tmp___3 = strncmp(token, "sec", (size_t )3);
  }
#line 690
  if (tmp___3 == 0) {
#line 691
    return (5);
  }
  {
#line 692
  tmp___4 = strncmp(token, "ip", (size_t )2);
  }
#line 692
  if (tmp___4 == 0) {
#line 693
    return (6);
  }
  {
#line 694
  tmp___5 = strncmp(token, "unc", (size_t )3);
  }
#line 694
  if (tmp___5 == 0) {
#line 697
    return (7);
  } else {
    {
#line 694
    tmp___6 = strncmp(token, "target", (size_t )6);
    }
#line 694
    if (tmp___6 == 0) {
#line 697
      return (7);
    } else {
      {
#line 694
      tmp___7 = strncmp(token, "path", (size_t )4);
      }
#line 694
      if (tmp___7 == 0) {
#line 697
        return (7);
      }
    }
  }
  {
#line 698
  tmp___8 = strncmp(token, "dom", (size_t )3);
  }
#line 698
  if (tmp___8 == 0) {
#line 699
    return (15);
  } else {
    {
#line 698
    tmp___9 = strncmp(token, "workg", (size_t )5);
    }
#line 698
    if (tmp___9 == 0) {
#line 699
      return (15);
    }
  }
  {
#line 700
  tmp___10 = strncmp(token, "cred", (size_t )4);
  }
#line 700
  if (tmp___10 == 0) {
#line 701
    return (8);
  }
  {
#line 702
  tmp___11 = strncmp(token, "uid", (size_t )3);
  }
#line 702
  if (tmp___11 == 0) {
#line 703
    return (9);
  }
  {
#line 704
  tmp___12 = strncmp(token, "cruid", (size_t )5);
  }
#line 704
  if (tmp___12 == 0) {
#line 705
    return (29);
  }
  {
#line 706
  tmp___13 = strncmp(token, "gid", (size_t )3);
  }
#line 706
  if (tmp___13 == 0) {
#line 707
    return (10);
  }
  {
#line 708
  tmp___14 = strncmp(token, "fmask", (size_t )5);
  }
#line 708
  if (tmp___14 == 0) {
#line 709
    return (11);
  }
  {
#line 710
  tmp___15 = strncmp(token, "file_mode", (size_t )9);
  }
#line 710
  if (tmp___15 == 0) {
#line 711
    return (12);
  }
  {
#line 712
  tmp___16 = strncmp(token, "dmask", (size_t )5);
  }
#line 712
  if (tmp___16 == 0) {
#line 713
    return (13);
  }
  {
#line 714
  tmp___17 = strncmp(token, "dir_mode", (size_t )4);
  }
#line 714
  if (tmp___17 == 0) {
#line 715
    return (14);
  } else {
    {
#line 714
    tmp___18 = strncmp(token, "dirm", (size_t )4);
    }
#line 714
    if (tmp___18 == 0) {
#line 715
      return (14);
    }
  }
  {
#line 716
  tmp___19 = strncmp(token, "nosuid", (size_t )6);
  }
#line 716
  if (tmp___19 == 0) {
#line 717
    return (16);
  }
  {
#line 718
  tmp___20 = strncmp(token, "suid", (size_t )4);
  }
#line 718
  if (tmp___20 == 0) {
#line 719
    return (17);
  }
  {
#line 720
  tmp___21 = strncmp(token, "nodev", (size_t )5);
  }
#line 720
  if (tmp___21 == 0) {
#line 721
    return (18);
  }
  {
#line 722
  tmp___22 = strncmp(token, "nobrl", (size_t )5);
  }
#line 722
  if (tmp___22 == 0) {
#line 723
    return (20);
  } else {
    {
#line 722
    tmp___23 = strncmp(token, "nolock", (size_t )6);
    }
#line 722
    if (tmp___23 == 0) {
#line 723
      return (20);
    }
  }
  {
#line 724
  tmp___24 = strncmp(token, "mand", (size_t )4);
  }
#line 724
  if (tmp___24 == 0) {
#line 725
    return (27);
  }
  {
#line 726
  tmp___25 = strncmp(token, "nomand", (size_t )6);
  }
#line 726
  if (tmp___25 == 0) {
#line 727
    return (28);
  }
  {
#line 728
  tmp___26 = strncmp(token, "dev", (size_t )3);
  }
#line 728
  if (tmp___26 == 0) {
#line 729
    return (19);
  }
  {
#line 730
  tmp___27 = strncmp(token, "noexec", (size_t )6);
  }
#line 730
  if (tmp___27 == 0) {
#line 731
    return (21);
  }
  {
#line 732
  tmp___28 = strncmp(token, "exec", (size_t )4);
  }
#line 732
  if (tmp___28 == 0) {
#line 733
    return (22);
  }
  {
#line 734
  tmp___29 = strncmp(token, "guest", (size_t )5);
  }
#line 734
  if (tmp___29 == 0) {
#line 735
    return (23);
  }
  {
#line 736
  tmp___30 = strncmp(token, "ro", (size_t )2);
  }
#line 736
  if (tmp___30 == 0) {
#line 737
    return (24);
  }
  {
#line 738
  tmp___31 = strncmp(token, "rw", (size_t )2);
  }
#line 738
  if (tmp___31 == 0) {
    {
#line 738
    tmp___32 = strlen(token);
    }
#line 738
    if (tmp___32 == 2UL) {
#line 739
      return (25);
    }
  }
  {
#line 740
  tmp___33 = strncmp(token, "remount", (size_t )7);
  }
#line 740
  if (tmp___33 == 0) {
#line 741
    return (26);
  }
  {
#line 742
  tmp___34 = strncmp(token, "_netdev", (size_t )7);
  }
#line 742
  if (tmp___34 == 0) {
#line 743
    return (0);
  }
  {
#line 744
  tmp___35 = strncmp(token, "backupuid", (size_t )9);
  }
#line 744
  if (tmp___35 == 0) {
#line 745
    return (30);
  }
  {
#line 746
  tmp___36 = strncmp(token, "backupgid", (size_t )9);
  }
#line 746
  if (tmp___36 == 0) {
#line 747
    return (31);
  }
  {
#line 748
  tmp___37 = strncmp(token, "nofail", (size_t )6);
  }
#line 748
  if (tmp___37 == 0) {
#line 749
    return (32);
  }
#line 751
  return (-1);
}
}
#line 754 "/home/june/repo/benchmarks/collector/temp/cifs-utils-6.0/mount.cifs.c"
static int parse_options(char const   *data , struct parsed_mount_info *parsed_info ) 
{ 
  char *value ;
  char *equals ;
  char *next_keyword ;
  char *out ;
  unsigned long *filesys_flags ;
  int out_len ;
  int word_len ;
  int rc ;
  int got_bkupuid ;
  int got_bkupgid ;
  int got_uid ;
  int got_cruid ;
  int got_gid ;
  uid_t uid ;
  uid_t cruid ;
  uid_t bkupuid ;
  gid_t gid ;
  gid_t bkupgid ;
  char *ep ;
  struct passwd *pw ;
  struct group *gr ;
  char txtbuf[12] ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  unsigned long tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  unsigned long tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;
  unsigned long tmp___13 ;
  int *tmp___14 ;
  int *tmp___15 ;
  unsigned long tmp___16 ;
  int *tmp___17 ;
  int *tmp___18 ;
  unsigned long tmp___19 ;
  int *tmp___20 ;
  size_t tmp___21 ;
  size_t tmp___22 ;
  size_t tmp___23 ;
  size_t tmp___24 ;
  size_t tmp___25 ;
  size_t tmp___26 ;

  {
  {
#line 757
  value = (char *)((void *)0);
#line 758
  equals = (char *)((void *)0);
#line 759
  next_keyword = (char *)((void *)0);
#line 760
  out = parsed_info->options;
#line 761
  filesys_flags = & parsed_info->flags;
#line 762
  out_len = 0;
#line 764
  rc = 0;
#line 765
  got_bkupuid = 0;
#line 766
  got_bkupgid = 0;
#line 767
  got_uid = 0;
#line 768
  got_cruid = 0;
#line 769
  got_gid = 0;
#line 770
  cruid = (uid_t )0;
#line 770
  bkupuid = (uid_t )0;
#line 771
  bkupgid = (gid_t )0;
#line 782
  *(out + 0) = (char )'\000';
#line 785
  uid = getuid();
  }
#line 786
  if (uid != 0U) {
#line 787
    got_uid = 1;
  }
  {
#line 789
  gid = getgid();
  }
#line 790
  if (gid != 0U) {
#line 791
    got_gid = 1;
  }
#line 793
  if (! data) {
#line 794
    return (1);
  }
  {
#line 801
  while (1) {
    while_continue: /* CIL Label */ ;
#line 801
    if (data) {
#line 801
      if (! *data) {
#line 801
        goto while_break;
      }
    } else {
#line 801
      goto while_break;
    }
    {
#line 802
    next_keyword = strchr(data, ',');
    }
#line 805
    if (next_keyword) {
#line 806
      tmp = next_keyword;
#line 806
      next_keyword ++;
#line 806
      *tmp = (char)0;
    }
    {
#line 809
    value = (char *)((void *)0);
#line 810
    equals = strchr(data, '=');
    }
#line 810
    if ((unsigned long )equals != (unsigned long )((void *)0)) {
#line 811
      *equals = (char )'\000';
#line 812
      value = equals + 1;
    }
    {
#line 815
    tmp___0 = parse_opt_token(data);
    }
    {
#line 816
    if (tmp___0 == 1) {
#line 816
      goto case_1;
    }
#line 823
    if (tmp___0 == 2) {
#line 823
      goto case_2;
    }
#line 840
    if (tmp___0 == 4) {
#line 840
      goto case_4;
    }
#line 855
    if (tmp___0 == 5) {
#line 855
      goto case_5;
    }
#line 863
    if (tmp___0 == 6) {
#line 863
      goto case_6;
    }
#line 883
    if (tmp___0 == 7) {
#line 883
      goto case_7;
    }
#line 895
    if (tmp___0 == 15) {
#line 895
      goto case_15;
    }
#line 909
    if (tmp___0 == 8) {
#line 909
      goto case_8;
    }
#line 924
    if (tmp___0 == 9) {
#line 924
      goto case_9;
    }
#line 942
    if (tmp___0 == 29) {
#line 942
      goto case_29;
    }
#line 960
    if (tmp___0 == 10) {
#line 960
      goto case_10;
    }
#line 979
    if (tmp___0 == 11) {
#line 979
      goto case_11;
    }
#line 984
    if (tmp___0 == 12) {
#line 984
      goto case_12;
    }
#line 999
    if (tmp___0 == 13) {
#line 999
      goto case_13;
    }
#line 1004
    if (tmp___0 == 14) {
#line 1004
      goto case_14;
    }
#line 1017
    if (tmp___0 == 16) {
#line 1017
      goto case_16;
    }
#line 1020
    if (tmp___0 == 17) {
#line 1020
      goto case_17;
    }
#line 1023
    if (tmp___0 == 18) {
#line 1023
      goto case_18;
    }
#line 1026
    if (tmp___0 == 20) {
#line 1026
      goto case_20;
    }
#line 1029
    if (tmp___0 == 27) {
#line 1029
      goto case_27;
    }
#line 1032
    if (tmp___0 == 28) {
#line 1032
      goto case_28;
    }
#line 1035
    if (tmp___0 == 19) {
#line 1035
      goto case_19;
    }
#line 1038
    if (tmp___0 == 21) {
#line 1038
      goto case_21;
    }
#line 1041
    if (tmp___0 == 22) {
#line 1041
      goto case_22;
    }
#line 1044
    if (tmp___0 == 23) {
#line 1044
      goto case_23;
    }
#line 1048
    if (tmp___0 == 24) {
#line 1048
      goto case_24;
    }
#line 1051
    if (tmp___0 == 25) {
#line 1051
      goto case_25;
    }
#line 1054
    if (tmp___0 == 26) {
#line 1054
      goto case_26;
    }
#line 1057
    if (tmp___0 == 0) {
#line 1057
      goto case_0;
    }
#line 1059
    if (tmp___0 == 30) {
#line 1059
      goto case_30;
    }
#line 1078
    if (tmp___0 == 31) {
#line 1078
      goto case_31;
    }
#line 1097
    if (tmp___0 == 32) {
#line 1097
      goto case_32;
    }
#line 815
    goto switch_break;
    case_1: /* CIL Label */ 
#line 817
    if (! value) {
#line 818
      *filesys_flags |= 1073741824UL;
#line 819
      goto nocopy;
    } else
#line 817
    if (! *value) {
#line 818
      *filesys_flags |= 1073741824UL;
#line 819
      goto nocopy;
    }
#line 821
    goto switch_break;
    case_2: /* CIL Label */ 
#line 824
    if (! value) {
#line 824
      goto _L;
    } else
#line 824
    if (! *value) {
      _L: /* CIL Label */ 
#line 825
      if ((int const   )*(data + 4) == 0) {
#line 826
        *filesys_flags |= 2147483648UL;
#line 827
        goto nocopy;
      } else {
        {
#line 829
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"username specified with no parameter\n");
        }
#line 831
        return (1);
      }
    } else {
      {
#line 834
      strlcpy(parsed_info->username, (char const   *)value, sizeof(parsed_info->username));
#line 836
      parsed_info->got_user = 1U;
      }
#line 837
      goto nocopy;
    }
    case_4: /* CIL Label */ 
#line 841
    if (parsed_info->got_password) {
      {
#line 842
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"password specified twice, ignoring second\n");
      }
#line 844
      goto nocopy;
    }
#line 846
    if (! value) {
#line 847
      parsed_info->got_password = 1U;
#line 848
      goto nocopy;
    } else
#line 846
    if (! *value) {
#line 847
      parsed_info->got_password = 1U;
#line 848
      goto nocopy;
    }
    {
#line 850
    rc = set_password(parsed_info, (char const   *)value);
    }
#line 851
    if (rc) {
#line 852
      return (rc);
    }
#line 853
    goto nocopy;
    case_5: /* CIL Label */ 
#line 856
    if (value) {
      {
#line 857
      tmp___1 = strncmp((char const   *)value, "none", (size_t )4);
      }
#line 857
      if (tmp___1) {
        {
#line 857
        tmp___2 = strncmp((char const   *)value, "krb5", (size_t )4);
        }
#line 857
        if (! tmp___2) {
#line 859
          parsed_info->got_password = 1U;
        }
      } else {
#line 859
        parsed_info->got_password = 1U;
      }
    }
#line 861
    goto switch_break;
    case_6: /* CIL Label */ 
#line 864
    if (! value) {
      {
#line 865
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"target ip address argument missing\n");
      }
    } else
#line 864
    if (! *value) {
      {
#line 865
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"target ip address argument missing\n");
      }
    } else {
      {
#line 867
      tmp___3 = strnlen((char const   *)value, (size_t )46);
      }
#line 867
      if (tmp___3 <= 46UL) {
        {
#line 869
        strcpy((char */* __restrict  */)(parsed_info->addrlist), (char const   */* __restrict  */)value);
        }
#line 870
        if (parsed_info->verboseflag) {
          {
#line 871
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ip address %s override specified\n",
                  value);
          }
        }
#line 874
        goto nocopy;
      } else {
        {
#line 876
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ip address too long\n");
        }
#line 877
        return (1);
      }
    }
#line 880
    goto switch_break;
    case_7: /* CIL Label */ 
#line 884
    if (! value) {
      {
#line 885
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid path to network resource\n");
      }
#line 887
      return (1);
    } else
#line 884
    if (! *value) {
      {
#line 885
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid path to network resource\n");
      }
#line 887
      return (1);
    }
    {
#line 889
    rc = parse_unc((char const   *)value, parsed_info);
    }
#line 890
    if (rc) {
#line 891
      return (rc);
    }
#line 892
    goto switch_break;
    case_15: /* CIL Label */ 
#line 896
    if (! value) {
      {
#line 897
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"CIFS: invalid domain name\n");
      }
#line 898
      return (1);
    } else
#line 896
    if (! *value) {
      {
#line 897
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"CIFS: invalid domain name\n");
      }
#line 898
      return (1);
    }
    {
#line 900
    tmp___4 = strnlen((char const   *)value, sizeof(parsed_info->domain));
    }
#line 900
    if (tmp___4 >= sizeof(parsed_info->domain)) {
      {
#line 902
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"domain name too long\n");
      }
#line 903
      return (1);
    }
    {
#line 905
    strlcpy(parsed_info->domain, (char const   *)value, sizeof(parsed_info->domain));
    }
#line 907
    goto nocopy;
    case_8: /* CIL Label */ 
#line 910
    if (! value) {
      {
#line 911
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid credential file name specified\n");
      }
#line 913
      return (1);
    } else
#line 910
    if (! *value) {
      {
#line 911
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid credential file name specified\n");
      }
#line 913
      return (1);
    }
    {
#line 915
    rc = open_cred_file(value, parsed_info);
    }
#line 916
    if (rc) {
      {
#line 917
      tmp___5 = strerror(rc);
#line 917
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error %d (%s) opening credential file %s\n",
              rc, tmp___5, value);
      }
#line 920
      return (rc);
    }
#line 922
    goto nocopy;
    case_9: /* CIL Label */ 
#line 925
    if (! value) {
#line 926
      goto nocopy;
    } else
#line 925
    if (! *value) {
#line 926
      goto nocopy;
    }
    {
#line 928
    got_uid = 1;
#line 929
    pw = getpwnam((char const   *)value);
    }
#line 930
    if (pw) {
#line 931
      uid = pw->pw_uid;
#line 932
      goto nocopy;
    }
    {
#line 935
    tmp___6 = __errno_location();
#line 935
    *tmp___6 = 0;
#line 936
    tmp___7 = strtoul((char const   */* __restrict  */)value, (char **/* __restrict  */)(& ep),
                      10);
#line 936
    uid = (uid_t )tmp___7;
#line 937
    tmp___8 = __errno_location();
    }
#line 937
    if (*tmp___8 == 0) {
#line 937
      if ((int )*ep == 0) {
#line 938
        goto nocopy;
      }
    }
    {
#line 940
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad option uid=\"%s\"\n",
            value);
    }
#line 941
    return (1);
    case_29: /* CIL Label */ 
#line 943
    if (! value) {
#line 944
      goto nocopy;
    } else
#line 943
    if (! *value) {
#line 944
      goto nocopy;
    }
    {
#line 946
    got_cruid = 1;
#line 947
    pw = getpwnam((char const   *)value);
    }
#line 948
    if (pw) {
#line 949
      cruid = pw->pw_uid;
#line 950
      goto nocopy;
    }
    {
#line 953
    tmp___9 = __errno_location();
#line 953
    *tmp___9 = 0;
#line 954
    tmp___10 = strtoul((char const   */* __restrict  */)value, (char **/* __restrict  */)(& ep),
                       10);
#line 954
    cruid = (uid_t )tmp___10;
#line 955
    tmp___11 = __errno_location();
    }
#line 955
    if (*tmp___11 == 0) {
#line 955
      if ((int )*ep == 0) {
#line 956
        goto nocopy;
      }
    }
    {
#line 958
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad option: cruid=\"%s\"\n",
            value);
    }
#line 959
    return (1);
    case_10: /* CIL Label */ 
#line 961
    if (! value) {
#line 962
      goto nocopy;
    } else
#line 961
    if (! *value) {
#line 962
      goto nocopy;
    }
    {
#line 964
    got_gid = 1;
#line 965
    gr = getgrnam((char const   *)value);
    }
#line 966
    if (gr) {
#line 967
      gid = gr->gr_gid;
#line 968
      goto nocopy;
    }
    {
#line 971
    tmp___12 = __errno_location();
#line 971
    *tmp___12 = 0;
#line 972
    tmp___13 = strtoul((char const   */* __restrict  */)value, (char **/* __restrict  */)(& ep),
                       10);
#line 972
    gid = (gid_t )tmp___13;
#line 973
    tmp___14 = __errno_location();
    }
#line 973
    if (*tmp___14 == 0) {
#line 973
      if ((int )*ep == 0) {
#line 974
        goto nocopy;
      }
    }
    {
#line 976
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad option: gid=\"%s\"\n",
            value);
    }
#line 977
    return (1);
    case_11: /* CIL Label */ 
    {
#line 980
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING: CIFS mount option \'fmask\' is\t\t\t\t deprecated. Use \'file_mode\' instead.\n");
#line 983
    data = "file_mode";
    }
    case_12: /* CIL Label */ 
#line 985
    if (! value) {
      {
#line 986
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Option \'%s\' requires a numerical argument\n",
              data);
      }
#line 989
      return (1);
    } else
#line 985
    if (! *value) {
      {
#line 986
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Option \'%s\' requires a numerical argument\n",
              data);
      }
#line 989
      return (1);
    }
#line 992
    if ((int )*(value + 0) != 48) {
      {
#line 993
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING: \'%s\' not expressed in octal.\n",
              data);
      }
    }
#line 996
    goto switch_break;
    case_13: /* CIL Label */ 
    {
#line 1000
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING: CIFS mount option \'dmask\' is\t\t\t\t deprecated. Use \'dir_mode\' instead.\n");
#line 1003
    data = "dir_mode";
    }
    case_14: /* CIL Label */ 
#line 1005
    if (! value) {
      {
#line 1006
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Option \'%s\' requires a numerical argument\n",
              data);
      }
#line 1009
      return (1);
    } else
#line 1005
    if (! *value) {
      {
#line 1006
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Option \'%s\' requires a numerical argument\n",
              data);
      }
#line 1009
      return (1);
    }
#line 1012
    if ((int )*(value + 0) != 48) {
      {
#line 1013
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING: \'%s\' not expressed in octal.\n",
              data);
      }
    }
#line 1016
    goto switch_break;
    case_16: /* CIL Label */ 
#line 1018
    *filesys_flags |= 2UL;
#line 1019
    goto nocopy;
    case_17: /* CIL Label */ 
#line 1021
    *filesys_flags &= 0xfffffffffffffffdUL;
#line 1022
    goto nocopy;
    case_18: /* CIL Label */ 
#line 1024
    *filesys_flags |= 4UL;
#line 1025
    goto nocopy;
    case_20: /* CIL Label */ 
#line 1027
    *filesys_flags &= 0xffffffffffffffbfUL;
#line 1028
    goto switch_break;
    case_27: /* CIL Label */ 
#line 1030
    *filesys_flags |= 64UL;
#line 1031
    goto nocopy;
    case_28: /* CIL Label */ 
#line 1033
    *filesys_flags &= 0xffffffffffffffbfUL;
#line 1034
    goto nocopy;
    case_19: /* CIL Label */ 
#line 1036
    *filesys_flags &= 0xfffffffffffffffbUL;
#line 1037
    goto nocopy;
    case_21: /* CIL Label */ 
#line 1039
    *filesys_flags |= 8UL;
#line 1040
    goto nocopy;
    case_22: /* CIL Label */ 
#line 1042
    *filesys_flags &= 0xfffffffffffffff7UL;
#line 1043
    goto nocopy;
    case_23: /* CIL Label */ 
#line 1045
    parsed_info->got_user = 1U;
#line 1046
    parsed_info->got_password = 1U;
#line 1047
    goto nocopy;
    case_24: /* CIL Label */ 
#line 1049
    *filesys_flags |= 1UL;
#line 1050
    goto nocopy;
    case_25: /* CIL Label */ 
#line 1052
    *filesys_flags &= 0xfffffffffffffffeUL;
#line 1053
    goto nocopy;
    case_26: /* CIL Label */ 
#line 1055
    *filesys_flags |= 32UL;
#line 1056
    goto nocopy;
    case_0: /* CIL Label */ 
#line 1058
    goto nocopy;
    case_30: /* CIL Label */ 
#line 1060
    if (! value) {
#line 1061
      goto nocopy;
    } else
#line 1060
    if (! *value) {
#line 1061
      goto nocopy;
    }
    {
#line 1063
    got_bkupuid = 1;
#line 1064
    tmp___15 = __errno_location();
#line 1064
    *tmp___15 = 0;
#line 1065
    tmp___16 = strtoul((char const   */* __restrict  */)value, (char **/* __restrict  */)(& ep),
                       10);
#line 1065
    bkupuid = (uid_t )tmp___16;
#line 1066
    tmp___17 = __errno_location();
    }
#line 1066
    if (*tmp___17 == 0) {
#line 1066
      if ((int )*ep == 0) {
#line 1067
        goto nocopy;
      }
    }
    {
#line 1069
    pw = getpwnam((char const   *)value);
    }
#line 1070
    if ((unsigned long )pw == (unsigned long )((void *)0)) {
      {
#line 1071
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad user name \"%s\"\n",
              value);
      }
#line 1073
      return (1);
    }
#line 1076
    bkupuid = pw->pw_uid;
#line 1077
    goto nocopy;
    case_31: /* CIL Label */ 
#line 1079
    if (! value) {
#line 1080
      goto nocopy;
    } else
#line 1079
    if (! *value) {
#line 1080
      goto nocopy;
    }
    {
#line 1082
    got_bkupgid = 1;
#line 1083
    tmp___18 = __errno_location();
#line 1083
    *tmp___18 = 0;
#line 1084
    tmp___19 = strtoul((char const   */* __restrict  */)value, (char **/* __restrict  */)(& ep),
                       10);
#line 1084
    bkupgid = (gid_t )tmp___19;
#line 1085
    tmp___20 = __errno_location();
    }
#line 1085
    if (*tmp___20 == 0) {
#line 1085
      if ((int )*ep == 0) {
#line 1086
        goto nocopy;
      }
    }
    {
#line 1088
    gr = getgrnam((char const   *)value);
    }
#line 1089
    if ((unsigned long )gr == (unsigned long )((void *)0)) {
      {
#line 1090
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad group name \"%s\"\n",
              value);
      }
#line 1092
      return (1);
    }
#line 1095
    bkupgid = gr->gr_gid;
#line 1096
    goto nocopy;
    case_32: /* CIL Label */ 
#line 1098
    parsed_info->nofail = 1U;
#line 1099
    goto nocopy;
    switch_break: /* CIL Label */ ;
    }
    {
#line 1103
    tmp___21 = strlen(data);
#line 1103
    word_len = (int )tmp___21;
    }
#line 1104
    if (value) {
      {
#line 1105
      tmp___22 = strlen((char const   *)value);
#line 1105
      word_len = (int )((size_t )word_len + (1UL + tmp___22));
      }
    }
#line 1108
    if ((out_len + word_len) + 2 > 4096) {
      {
#line 1109
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Options string too long\n");
      }
#line 1110
      return (1);
    }
#line 1114
    if (equals) {
#line 1115
      *equals = (char )'=';
    }
#line 1118
    if (out_len) {
      {
#line 1119
      strlcat(out, ",", (size_t )4096);
      }
    }
    {
#line 1121
    strlcat(out, data, (size_t )4096);
#line 1122
    tmp___23 = strlen((char const   *)out);
#line 1122
    out_len = (int )tmp___23;
    }
    nocopy: 
#line 1124
    data = (char const   *)next_keyword;
  }
  while_break: /* CIL Label */ ;
  }
#line 1129
  if (got_uid) {
    {
#line 1130
    word_len = snprintf((char */* __restrict  */)(txtbuf), sizeof(txtbuf), (char const   */* __restrict  */)"%u",
                        uid);
    }
#line 1133
    if ((out_len + word_len) + 6 > 4096) {
      {
#line 1134
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Options string too long\n");
      }
#line 1135
      return (1);
    }
#line 1138
    if (out_len) {
      {
#line 1139
      strlcat(out, ",", (size_t )4096);
#line 1140
      out_len ++;
      }
    }
    {
#line 1142
    snprintf((char */* __restrict  */)(out + out_len), (size_t )(word_len + 5), (char const   */* __restrict  */)"uid=%s",
             txtbuf);
#line 1143
    tmp___24 = strlen((char const   *)out);
#line 1143
    out_len = (int )tmp___24;
    }
  }
#line 1145
  if (got_cruid) {
    {
#line 1146
    word_len = snprintf((char */* __restrict  */)(txtbuf), sizeof(txtbuf), (char const   */* __restrict  */)"%u",
                        cruid);
    }
#line 1149
    if ((out_len + word_len) + 8 > 4096) {
      {
#line 1150
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Options string too long\n");
      }
#line 1151
      return (1);
    }
#line 1154
    if (out_len) {
      {
#line 1155
      strlcat(out, ",", (size_t )4096);
#line 1156
      out_len ++;
      }
    }
    {
#line 1158
    snprintf((char */* __restrict  */)(out + out_len), (size_t )(word_len + 7), (char const   */* __restrict  */)"cruid=%s",
             txtbuf);
#line 1159
    tmp___25 = strlen((char const   *)out);
#line 1159
    out_len = (int )tmp___25;
    }
  }
#line 1161
  if (got_gid) {
    {
#line 1162
    word_len = snprintf((char */* __restrict  */)(txtbuf), sizeof(txtbuf), (char const   */* __restrict  */)"%u",
                        gid);
    }
#line 1165
    if ((out_len + word_len) + 6 > 4096) {
      {
#line 1166
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Options string too long\n");
      }
#line 1167
      return (1);
    }
#line 1170
    if (out_len) {
      {
#line 1171
      strlcat(out, ",", (size_t )4096);
#line 1172
      out_len ++;
      }
    }
    {
#line 1174
    snprintf((char */* __restrict  */)(out + out_len), (size_t )(word_len + 5), (char const   */* __restrict  */)"gid=%s",
             txtbuf);
    }
  }
#line 1176
  if (got_bkupuid) {
    {
#line 1177
    word_len = snprintf((char */* __restrict  */)(txtbuf), sizeof(txtbuf), (char const   */* __restrict  */)"%u",
                        bkupuid);
    }
#line 1180
    if ((out_len + word_len) + 12 > 4096) {
      {
#line 1181
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Options string too long\n");
      }
#line 1182
      return (1);
    }
#line 1185
    if (out_len) {
      {
#line 1186
      strlcat(out, ",", (size_t )4096);
#line 1187
      out_len ++;
      }
    }
    {
#line 1189
    snprintf((char */* __restrict  */)(out + out_len), (size_t )(word_len + 11), (char const   */* __restrict  */)"backupuid=%s",
             txtbuf);
#line 1190
    tmp___26 = strlen((char const   *)out);
#line 1190
    out_len = (int )tmp___26;
    }
  }
#line 1192
  if (got_bkupgid) {
    {
#line 1193
    word_len = snprintf((char */* __restrict  */)(txtbuf), sizeof(txtbuf), (char const   */* __restrict  */)"%u",
                        bkupgid);
    }
#line 1196
    if ((out_len + word_len) + 12 > 4096) {
      {
#line 1197
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Options string too long\n");
      }
#line 1198
      return (1);
    }
#line 1201
    if (out_len) {
      {
#line 1202
      strlcat(out, ",", (size_t )4096);
#line 1203
      out_len ++;
      }
    }
    {
#line 1205
    snprintf((char */* __restrict  */)(out + out_len), (size_t )(word_len + 11), (char const   */* __restrict  */)"backupgid=%s",
             txtbuf);
    }
  }
#line 1208
  return (0);
}
}
#line 1211 "/home/june/repo/benchmarks/collector/temp/cifs-utils-6.0/mount.cifs.c"
static int parse_unc(char const   *unc_name , struct parsed_mount_info *parsed_info ) 
{ 
  int length ;
  size_t tmp ;
  char const   *host ;
  char const   *share ;
  char const   *prepath ;
  size_t hostlen ;
  size_t sharelen ;
  size_t prepathlen ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 1213
  tmp = strnlen(unc_name, (size_t )1024);
#line 1213
  length = (int )tmp;
  }
#line 1217
  if (length > 1023) {
    {
#line 1218
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mount error: UNC name too long\n");
    }
#line 1219
    return (1);
  }
#line 1222
  if (length < 3) {
    {
#line 1223
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mount error: UNC name too short\n");
    }
#line 1224
    return (1);
  }
  {
#line 1227
  tmp___0 = strncasecmp("cifs://", unc_name, (size_t )7);
  }
#line 1227
  if (tmp___0 == 0) {
    {
#line 1229
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Mounting cifs URL not implemented yet. Attempt to mount %s\n",
            unc_name);
    }
#line 1232
    return (1);
  } else {
    {
#line 1227
    tmp___1 = strncasecmp("smb://", unc_name, (size_t )6);
    }
#line 1227
    if (tmp___1 == 0) {
      {
#line 1229
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Mounting cifs URL not implemented yet. Attempt to mount %s\n",
              unc_name);
      }
#line 1232
      return (1);
    }
  }
  {
#line 1235
  tmp___2 = strncmp(unc_name, "//", (size_t )2);
  }
#line 1235
  if (tmp___2) {
    {
#line 1235
    tmp___3 = strncmp(unc_name, "\\\\", (size_t )2);
    }
#line 1235
    if (tmp___3) {
      {
#line 1236
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mount.cifs: bad UNC (%s)\n",
              unc_name);
      }
#line 1237
      return (1);
    }
  }
  {
#line 1240
  host = unc_name + 2;
#line 1241
  hostlen = strcspn(host, "/\\");
  }
#line 1242
  if (! hostlen) {
    {
#line 1243
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mount.cifs: bad UNC (%s)\n",
            unc_name);
    }
#line 1244
    return (1);
  }
#line 1246
  share = (host + hostlen) + 1;
#line 1248
  if (hostlen + 1UL > sizeof(parsed_info->host)) {
    {
#line 1249
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mount.cifs: host portion of UNC too long\n");
    }
#line 1250
    return (1);
  }
  {
#line 1253
  sharelen = strcspn(share, "/\\");
  }
#line 1254
  if (sharelen + 1UL > sizeof(parsed_info->share)) {
    {
#line 1255
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mount.cifs: share portion of UNC too long\n");
    }
#line 1256
    return (1);
  }
#line 1259
  prepath = share + sharelen;
#line 1260
  if ((int const   )*prepath != 0) {
#line 1261
    prepath ++;
  }
  {
#line 1263
  prepathlen = strlen(prepath);
  }
#line 1265
  if (prepathlen + 1UL > sizeof(parsed_info->prefix)) {
    {
#line 1266
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mount.cifs: UNC prefixpath too long\n");
    }
#line 1267
    return (1);
  }
  {
#line 1271
  memcpy((void */* __restrict  */)(parsed_info->host), (void const   */* __restrict  */)host,
         hostlen);
#line 1272
  memcpy((void */* __restrict  */)(parsed_info->share), (void const   */* __restrict  */)share,
         sharelen);
#line 1273
  memcpy((void */* __restrict  */)(parsed_info->prefix), (void const   */* __restrict  */)prepath,
         prepathlen);
  }
#line 1275
  return (0);
}
}
#line 1278 "/home/june/repo/benchmarks/collector/temp/cifs-utils-6.0/mount.cifs.c"
static int get_pw_from_env(struct parsed_mount_info *parsed_info ) 
{ 
  int rc ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 1280
  rc = 0;
#line 1282
  tmp___5 = getenv("PASSWD");
  }
#line 1282
  if (tmp___5) {
    {
#line 1283
    tmp = getenv("PASSWD");
#line 1283
    rc = set_password(parsed_info, (char const   *)tmp);
    }
  } else {
    {
#line 1284
    tmp___4 = getenv("PASSWD_FD");
    }
#line 1284
    if (tmp___4) {
      {
#line 1285
      tmp___0 = getenv("PASSWD_FD");
#line 1285
      tmp___1 = atoi((char const   *)tmp___0);
#line 1285
      rc = get_password_from_file(tmp___1, (char *)((void *)0), parsed_info);
      }
    } else {
      {
#line 1287
      tmp___3 = getenv("PASSWD_FILE");
      }
#line 1287
      if (tmp___3) {
        {
#line 1288
        tmp___2 = getenv("PASSWD_FILE");
#line 1288
        rc = get_password_from_file(0, tmp___2, parsed_info);
        }
      }
    }
  }
#line 1291
  return (rc);
}
}
#line 1294 "/home/june/repo/benchmarks/collector/temp/cifs-utils-6.0/mount.cifs.c"
static struct option longopts[24]  = 
#line 1294
  {      {"all", 0, (int *)((void *)0), 'a'}, 
        {"help", 0, (int *)((void *)0), 'h'}, 
        {"move", 0, (int *)((void *)0), 'm'}, 
        {"bind", 0, (int *)((void *)0), 'b'}, 
        {"read-only", 0, (int *)((void *)0), 'r'}, 
        {"ro", 0, (int *)((void *)0), 'r'}, 
        {"verbose", 0, (int *)((void *)0), 'v'}, 
        {"version", 0, (int *)((void *)0), 'V'}, 
        {"read-write", 0, (int *)((void *)0), 'w'}, 
        {"rw", 0, (int *)((void *)0), 'w'}, 
        {"options", 1, (int *)((void *)0), 'o'}, 
        {"type", 1, (int *)((void *)0), 't'}, 
        {"uid", 1, (int *)((void *)0), '1'}, 
        {"gid", 1, (int *)((void *)0), '2'}, 
        {"user", 1, (int *)((void *)0), 'u'}, 
        {"username", 1, (int *)((void *)0), 'u'}, 
        {"dom", 1, (int *)((void *)0), 'd'}, 
        {"domain", 1, (int *)((void *)0), 'd'}, 
        {"password", 1, (int *)((void *)0), 'p'}, 
        {"pass", 1, (int *)((void *)0), 'p'}, 
        {"credentials", 1, (int *)((void *)0), 'c'}, 
        {"port", 1, (int *)((void *)0), 'P'}, 
        {"sloppy", 0, (int *)((void *)0), 's'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), 0}};
#line 1323 "/home/june/repo/benchmarks/collector/temp/cifs-utils-6.0/mount.cifs.c"
static int uppercase_string(char *string ) 
{ 
  int tmp ;

  {
#line 1325
  if (! string) {
#line 1326
    return (1);
  }
  {
#line 1328
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1328
    if (! *string) {
#line 1328
      goto while_break;
    }
#line 1330
    if ((int )((unsigned char )*(string + 0)) & 128) {
#line 1331
      return (0);
    }
    {
#line 1332
    tmp = toupper((int )((unsigned char )*string));
#line 1332
    *string = (char )tmp;
#line 1333
    string ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1336
  return (1);
}
}
#line 1339 "/home/june/repo/benchmarks/collector/temp/cifs-utils-6.0/mount.cifs.c"
static void print_cifs_mount_version(void) 
{ 


  {
  {
#line 1341
  printf((char const   */* __restrict  */)"mount.cifs version: %s\n", "6.0");
  }
#line 1342
  return;
}
}
#line 1351 "/home/june/repo/benchmarks/collector/temp/cifs-utils-6.0/mount.cifs.c"
static int check_newline(char const   *progname , char const   *name ) 
{ 
  char const   *s ;
  char *tmp ;

  {
#line 1354
  s = "\n";
  {
#line 1354
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1354
    if (! *s) {
#line 1354
      goto while_break;
    }
    {
#line 1355
    tmp = strchr(name, (int )*s);
    }
#line 1355
    if (tmp) {
      {
#line 1356
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: illegal character 0x%02x in mount entry\n",
              progname, (int const   )*s);
      }
#line 1359
      return (1);
    }
#line 1354
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1362
  return (0);
}
}
#line 1365 "/home/june/repo/benchmarks/collector/temp/cifs-utils-6.0/mount.cifs.c"
static int check_mtab(char const   *progname , char const   *devname , char const   *dir ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1368
  tmp = check_newline(progname, devname);
  }
#line 1368
  if (tmp) {
#line 1369
    return (1);
  } else {
    {
#line 1368
    tmp___0 = check_newline(progname, dir);
    }
#line 1368
    if (tmp___0) {
#line 1369
      return (1);
    }
  }
#line 1370
  return (0);
}
}
#line 1373 "/home/june/repo/benchmarks/collector/temp/cifs-utils-6.0/mount.cifs.c"
static int add_mtab(char *devname , char *mountpoint , unsigned long flags , char const   *fstype ) 
{ 
  int rc ;
  int tmprc ;
  int fd ;
  uid_t uid ;
  char *mount_user ;
  struct mntent mountent ;
  struct stat statbuf ;
  FILE *pmntfile ;
  sigset_t mask ;
  sigset_t oldmask ;
  __uid_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  int ignore  __attribute__((__unused__)) ;

  {
  {
#line 1376
  rc = 0;
#line 1378
  mount_user = (char *)((void *)0);
#line 1384
  uid = getuid();
  }
#line 1385
  if (uid != 0U) {
    {
#line 1386
    mount_user = getusername(uid);
    }
  }
  {
#line 1393
  tmp = geteuid();
#line 1393
  rc = setreuid(tmp, (__uid_t )-1);
  }
#line 1394
  if (rc != 0) {
    {
#line 1395
    tmp___0 = __errno_location();
#line 1395
    tmp___1 = strerror(*tmp___0);
#line 1395
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to set real uid to effective uid: %s\n",
            tmp___1);
    }
#line 1397
    return (16);
  }
  {
#line 1400
  rc = sigfillset(& mask);
  }
#line 1401
  if (rc) {
    {
#line 1402
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to set filled signal mask\n");
    }
#line 1403
    return (16);
  }
  {
#line 1406
  rc = sigprocmask(2, (sigset_t const   */* __restrict  */)(& mask), (sigset_t */* __restrict  */)(& oldmask));
  }
#line 1407
  if (rc) {
    {
#line 1408
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to make process ignore signals\n");
    }
#line 1409
    return (16);
  }
  {
#line 1412
  rc = toggle_dac_capability(1, 1);
  }
#line 1413
  if (rc) {
#line 1414
    return (16);
  }
  {
#line 1416
  atexit(& unlock_mtab);
#line 1417
  rc = lock_mtab();
  }
#line 1418
  if (rc) {
    {
#line 1419
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cannot lock mtab");
#line 1420
    rc = 16;
    }
#line 1421
    goto add_mtab_exit;
  }
  {
#line 1424
  pmntfile = setmntent("/etc/mtab", "a+");
  }
#line 1425
  if (! pmntfile) {
    {
#line 1426
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"could not update mount table\n");
#line 1427
    unlock_mtab();
#line 1428
    rc = 16;
    }
#line 1429
    goto add_mtab_exit;
  }
  {
#line 1432
  fd = fileno(pmntfile);
  }
#line 1433
  if (fd < 0) {
    {
#line 1434
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mntent does not appear to be valid\n");
#line 1435
    unlock_mtab();
#line 1436
    rc = 16;
    }
#line 1437
    goto add_mtab_exit;
  }
  {
#line 1440
  rc = fstat(fd, & statbuf);
  }
#line 1441
  if (rc != 0) {
    {
#line 1442
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unable to fstat open mtab\n");
#line 1443
    endmntent(pmntfile);
#line 1444
    unlock_mtab();
#line 1445
    rc = 16;
    }
#line 1446
    goto add_mtab_exit;
  }
  {
#line 1449
  mountent.mnt_fsname = devname;
#line 1450
  mountent.mnt_dir = mountpoint;
#line 1451
  mountent.mnt_type = (char *)((void *)fstype);
#line 1452
  tmp___2 = calloc((size_t )220, (size_t )1);
#line 1452
  mountent.mnt_opts = (char *)tmp___2;
  }
#line 1453
  if (mountent.mnt_opts) {
#line 1454
    if (flags & 1UL) {
      {
#line 1455
      strlcat(mountent.mnt_opts, "ro", (size_t )220);
      }
    } else {
      {
#line 1457
      strlcat(mountent.mnt_opts, "rw", (size_t )220);
      }
    }
#line 1459
    if (flags & 64UL) {
      {
#line 1460
      strlcat(mountent.mnt_opts, ",mand", (size_t )220);
      }
    }
#line 1461
    if (flags & 8UL) {
      {
#line 1462
      strlcat(mountent.mnt_opts, ",noexec", (size_t )220);
      }
    }
#line 1463
    if (flags & 2UL) {
      {
#line 1464
      strlcat(mountent.mnt_opts, ",nosuid", (size_t )220);
      }
    }
#line 1465
    if (flags & 4UL) {
      {
#line 1466
      strlcat(mountent.mnt_opts, ",nodev", (size_t )220);
      }
    }
#line 1467
    if (flags & 16UL) {
      {
#line 1468
      strlcat(mountent.mnt_opts, ",sync", (size_t )220);
      }
    }
#line 1469
    if (mount_user) {
      {
#line 1470
      strlcat(mountent.mnt_opts, ",user=", (size_t )220);
#line 1471
      strlcat(mountent.mnt_opts, (char const   *)mount_user, (size_t )220);
      }
    }
  }
  {
#line 1475
  mountent.mnt_freq = 0;
#line 1476
  mountent.mnt_passno = 0;
#line 1477
  rc = addmntent((FILE */* __restrict  */)pmntfile, (struct mntent  const  */* __restrict  */)(& mountent));
  }
#line 1478
  if (rc) {
    {
#line 1481
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unable to add mount entry to mtab\n");
#line 1482
    ignore = ftruncate(fd, statbuf.st_size);
#line 1483
    rc = 16;
    }
  }
  {
#line 1485
  tmprc = my_endmntent(pmntfile, statbuf.st_size);
  }
#line 1486
  if (tmprc) {
    {
#line 1487
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"error %d detected on close of mtab\n",
            tmprc);
#line 1488
    rc = 16;
    }
  }
  {
#line 1490
  unlock_mtab();
  }
  {
#line 1491
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1491
    if ((unsigned long )mountent.mnt_opts != (unsigned long )((void *)0)) {
      {
#line 1491
      free((void *)mountent.mnt_opts);
#line 1491
      mountent.mnt_opts = (char *)((void *)0);
      }
    }
#line 1491
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  add_mtab_exit: 
  {
#line 1493
  toggle_dac_capability(1, 0);
#line 1494
  sigprocmask(2, (sigset_t const   */* __restrict  */)(& oldmask), (sigset_t */* __restrict  */)((void *)0));
  }
#line 1496
  return (rc);
}
}
#line 1499 "/home/june/repo/benchmarks/collector/temp/cifs-utils-6.0/mount.cifs.c"
static int del_mtab(char *mountpoint ) 
{ 
  int tmprc ;
  int rc ;
  FILE *mnttmp ;
  FILE *mntmtab ;
  struct mntent *mountent ;
  char *mtabfile ;
  char *mtabdir ;
  char *mtabtmpfile ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;

  {
  {
#line 1502
  rc = 0;
#line 1507
  mtabfile = strdup("/etc/mtab");
#line 1508
  mtabdir = dirname(mtabfile);
#line 1509
  tmp = strlen((char const   *)mtabdir);
#line 1509
  tmp___0 = strlen("/.mtab.cifs.XXXXXX");
#line 1509
  tmp___1 = realloc((void *)mtabdir, (tmp + tmp___0) + 2UL);
#line 1509
  mtabdir = (char *)tmp___1;
  }
#line 1510
  if (! mtabdir) {
    {
#line 1511
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"del_mtab: cannot determine current mtab path");
#line 1512
    rc = 16;
    }
#line 1513
    goto del_mtab_exit;
  }
  {
#line 1516
  mtabtmpfile = strcat((char */* __restrict  */)mtabdir, (char const   */* __restrict  */)"/.mtab.cifs.XXXXXX");
  }
#line 1517
  if (! mtabtmpfile) {
    {
#line 1518
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"del_mtab: cannot allocate memory to tmp file");
#line 1519
    rc = 16;
    }
#line 1520
    goto del_mtab_exit;
  }
  {
#line 1523
  atexit(& unlock_mtab);
#line 1524
  rc = lock_mtab();
  }
#line 1525
  if (rc) {
    {
#line 1526
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"del_mtab: cannot lock mtab");
#line 1527
    rc = 16;
    }
#line 1528
    goto del_mtab_exit;
  }
  {
#line 1531
  mtabtmpfile = mktemp(mtabtmpfile);
  }
#line 1532
  if (! mtabtmpfile) {
    {
#line 1533
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"del_mtab: cannot setup tmp file destination");
#line 1534
    rc = 16;
    }
#line 1535
    goto del_mtab_exit;
  }
  {
#line 1538
  mntmtab = setmntent("/etc/mtab", "r");
  }
#line 1539
  if (! mntmtab) {
    {
#line 1540
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"del_mtab: could not update mount table\n");
#line 1541
    rc = 16;
    }
#line 1542
    goto del_mtab_exit;
  }
  {
#line 1545
  mnttmp = setmntent((char const   *)mtabtmpfile, "w");
  }
#line 1546
  if (! mnttmp) {
    {
#line 1547
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"del_mtab: could not update mount table\n");
#line 1548
    endmntent(mntmtab);
#line 1549
    rc = 16;
    }
#line 1550
    goto del_mtab_exit;
  }
  {
#line 1553
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1553
    mountent = getmntent(mntmtab);
    }
#line 1553
    if (! ((unsigned long )mountent != (unsigned long )((void *)0))) {
#line 1553
      goto while_break;
    }
    {
#line 1554
    tmp___2 = strcmp((char const   *)mountent->mnt_dir, (char const   *)mountpoint);
    }
#line 1554
    if (! tmp___2) {
#line 1555
      goto while_continue;
    }
    {
#line 1556
    rc = addmntent((FILE */* __restrict  */)mnttmp, (struct mntent  const  */* __restrict  */)mountent);
    }
#line 1557
    if (rc) {
      {
#line 1558
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"del_mtab: unable to add mount entry to mtab\n");
#line 1559
      rc = 16;
      }
#line 1560
      goto del_mtab_error;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1564
  endmntent(mntmtab);
#line 1566
  tmprc = my_endmntent(mnttmp, (off_t )0);
  }
#line 1567
  if (tmprc) {
    {
#line 1568
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"del_mtab: error %d detected on close of tmp file\n",
            tmprc);
#line 1569
    rc = 16;
    }
#line 1570
    goto del_mtab_error;
  }
  {
#line 1573
  tmp___4 = rename((char const   *)mtabtmpfile, "/etc/mtab");
  }
#line 1573
  if (tmp___4) {
    {
#line 1574
    tmp___3 = __errno_location();
#line 1574
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"del_mtab: error %d when renaming mtab in place\n",
            *tmp___3);
#line 1575
    rc = 16;
    }
#line 1576
    goto del_mtab_error;
  }
  del_mtab_exit: 
  {
#line 1580
  unlock_mtab();
#line 1581
  free((void *)mtabdir);
  }
#line 1582
  return (rc);
  del_mtab_error: 
  {
#line 1585
  tmp___7 = unlink((char const   *)mtabtmpfile);
  }
#line 1585
  if (tmp___7) {
    {
#line 1586
    tmp___5 = __errno_location();
#line 1586
    tmp___6 = strerror(*tmp___5);
#line 1586
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"del_mtab: failed to delete tmp file - %s\n",
            tmp___6);
    }
  }
#line 1588
  goto del_mtab_exit;
}
}
#line 1592 "/home/june/repo/benchmarks/collector/temp/cifs-utils-6.0/mount.cifs.c"
static int drop_child_privs(void) 
{ 
  int rc ;
  uid_t uid ;
  __uid_t tmp ;
  gid_t gid ;
  __gid_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 1596
  tmp = getuid();
#line 1596
  uid = tmp;
#line 1597
  tmp___0 = getgid();
#line 1597
  gid = tmp___0;
  }
#line 1599
  if (gid) {
    {
#line 1600
    rc = setgid(gid);
    }
#line 1601
    if (rc) {
      {
#line 1602
      tmp___1 = __errno_location();
#line 1602
      tmp___2 = strerror(*tmp___1);
#line 1602
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable set group identity: %s\n",
              tmp___2);
      }
#line 1604
      return (2);
    }
  }
#line 1607
  if (uid) {
    {
#line 1608
    rc = setuid(uid);
    }
#line 1609
    if (rc) {
      {
#line 1610
      tmp___3 = __errno_location();
#line 1610
      tmp___4 = strerror(*tmp___3);
#line 1610
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable set user identity: %s\n",
              tmp___4);
      }
#line 1612
      return (2);
    }
  }
#line 1616
  return (0);
}
}
#line 1625 "/home/june/repo/benchmarks/collector/temp/cifs-utils-6.0/mount.cifs.c"
static char *get_password(char const   *prompt , char *input , int capacity ) 
{ 
  int is_systemd_running ;
  struct stat a ;
  struct stat b ;
  struct stat c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *cmd ;
  char *ret ;
  FILE *ask_pass_fp ;
  int tmp___3 ;
  int len ;
  size_t tmp___4 ;
  char *tmp_pass ;
  char *tmp___5 ;
  size_t tmp___6 ;

  {
  {
#line 1634
  tmp = lstat((char const   */* __restrict  */)"/sys/fs/cgroup", (struct stat */* __restrict  */)(& a));
  }
#line 1634
  if (tmp == 0) {
    {
#line 1634
    tmp___0 = lstat((char const   */* __restrict  */)"/sys/fs/cgroup/systemd", (struct stat */* __restrict  */)(& b));
    }
#line 1634
    if (tmp___0 == 0) {
      {
#line 1634
      tmp___1 = lstat((char const   */* __restrict  */)"/bin/systemd-ask-password",
                      (struct stat */* __restrict  */)(& c));
      }
#line 1634
      if (tmp___1 == 0) {
#line 1634
        if (a.st_dev != b.st_dev) {
#line 1634
          tmp___2 = 1;
        } else {
#line 1634
          tmp___2 = 0;
        }
      } else {
#line 1634
        tmp___2 = 0;
      }
    } else {
#line 1634
      tmp___2 = 0;
    }
  } else {
#line 1634
    tmp___2 = 0;
  }
#line 1634
  is_systemd_running = tmp___2;
#line 1639
  if (is_systemd_running) {
    {
#line 1641
    ask_pass_fp = (FILE *)((void *)0);
#line 1643
    ret = (char *)((void *)0);
#line 1643
    cmd = ret;
#line 1644
    tmp___3 = asprintf((char **/* __restrict  */)(& cmd), (char const   */* __restrict  */)"/bin/systemd-ask-password \"%s\"",
                       prompt);
    }
#line 1644
    if (tmp___3 >= 0) {
      {
#line 1645
      ask_pass_fp = popen((char const   *)cmd, "re");
#line 1646
      free((void *)cmd);
      }
    }
#line 1649
    if (ask_pass_fp) {
      {
#line 1650
      ret = fgets((char */* __restrict  */)input, capacity, (FILE */* __restrict  */)ask_pass_fp);
#line 1651
      pclose(ask_pass_fp);
      }
    }
#line 1654
    if (ret) {
      {
#line 1655
      tmp___4 = strlen((char const   *)input);
#line 1655
      len = (int )tmp___4;
      }
#line 1656
      if ((int )*(input + (len - 1)) == 10) {
#line 1657
        *(input + (len - 1)) = (char )'\000';
      }
#line 1658
      return (input);
    }
  }
  {
#line 1667
  tmp___5 = getpass(prompt);
#line 1667
  tmp_pass = tmp___5;
  }
#line 1668
  if (! tmp_pass) {
#line 1669
    return ((char *)((void *)0));
  }
  {
#line 1671
  strncpy((char */* __restrict  */)input, (char const   */* __restrict  */)tmp_pass,
          (size_t )(capacity - 1));
#line 1672
  *(input + (capacity - 1)) = (char )'\000';
#line 1675
  tmp___6 = strlen((char const   *)tmp_pass);
#line 1675
  memset((void *)tmp_pass, 0, tmp___6);
  }
#line 1677
  return (input);
}
}
#line 1680 "/home/june/repo/benchmarks/collector/temp/cifs-utils-6.0/mount.cifs.c"
static int assemble_mountinfo(struct parsed_mount_info *parsed_info , char const   *thisprogram___0 ,
                              char const   *mountpoint , char const   *orig_dev ,
                              char *orgoptions ) 
{ 
  int rc ;
  __uid_t tmp ;
  __uid_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  __uid_t tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char tmp_pass[129] ;
  char *prompt ;
  int tmp___11 ;
  char const   *tmp___12 ;
  char *tmp___13 ;

  {
  {
#line 1687
  rc = drop_capabilities(0);
  }
#line 1688
  if (rc) {
#line 1689
    goto assemble_exit;
  }
  {
#line 1691
  rc = drop_child_privs();
  }
#line 1692
  if (rc) {
#line 1693
    goto assemble_exit;
  }
  {
#line 1695
  tmp = getuid();
  }
#line 1695
  if (tmp) {
    {
#line 1696
    rc = check_fstab(thisprogram___0, mountpoint, orig_dev, & orgoptions);
    }
#line 1698
    if (rc) {
#line 1699
      goto assemble_exit;
    }
#line 1702
    parsed_info->flags |= 6UL;
  }
  {
#line 1705
  rc = get_pw_from_env(parsed_info);
  }
#line 1706
  if (rc) {
#line 1707
    goto assemble_exit;
  }
#line 1709
  if (orgoptions) {
    {
#line 1710
    rc = parse_options((char const   *)orgoptions, parsed_info);
    }
#line 1711
    if (rc) {
#line 1712
      goto assemble_exit;
    }
  }
  {
#line 1715
  tmp___0 = getuid();
  }
#line 1715
  if (tmp___0) {
#line 1716
    if (! (parsed_info->flags & 3221225472UL)) {
      {
#line 1717
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: permission denied\n",
              thisprogram___0);
#line 1718
      rc = 1;
      }
#line 1719
      goto assemble_exit;
    }
  }
  {
#line 1723
  parsed_info->flags &= 1073741823UL;
#line 1725
  rc = parse_unc(orig_dev, parsed_info);
  }
#line 1726
  if (rc) {
#line 1727
    goto assemble_exit;
  }
#line 1729
  if ((int )parsed_info->addrlist[0] == 0) {
    {
#line 1730
    rc = resolve_host((char const   *)(parsed_info->host), parsed_info->addrlist);
    }
  }
  {
#line 1733
  if (rc == 1) {
#line 1733
    goto case_1;
  }
#line 1739
  if (rc == 2) {
#line 1739
    goto case_2;
  }
#line 1732
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1734
  if (rc == -11) {
    {
#line 1734
    tmp___1 = __errno_location();
#line 1734
    tmp___2 = strerror(*tmp___1);
#line 1734
    tmp___4 = (char const   *)tmp___2;
    }
  } else {
    {
#line 1734
    tmp___3 = gai_strerror(rc);
#line 1734
    tmp___4 = tmp___3;
    }
  }
  {
#line 1734
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mount error: could not resolve address for %s: %s\n",
          parsed_info->host, tmp___4);
  }
#line 1737
  goto assemble_exit;
  case_2: /* CIL Label */ 
  {
#line 1740
  tmp___5 = __errno_location();
#line 1740
  tmp___6 = strerror(*tmp___5);
#line 1740
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mount error: problem parsing address list: %s\n",
          tmp___6);
  }
#line 1742
  goto assemble_exit;
  switch_break: /* CIL Label */ ;
  }
#line 1745
  if (! parsed_info->got_user) {
    {
#line 1751
    tmp___10 = getenv("USER");
    }
#line 1751
    if (tmp___10) {
      {
#line 1752
      tmp___7 = getenv("USER");
#line 1752
      strlcpy(parsed_info->username, (char const   *)tmp___7, sizeof(parsed_info->username));
      }
    } else {
      {
#line 1755
      tmp___8 = getuid();
#line 1755
      tmp___9 = getusername(tmp___8);
#line 1755
      strlcpy(parsed_info->username, (char const   *)tmp___9, sizeof(parsed_info->username));
      }
    }
#line 1757
    parsed_info->got_user = 1U;
  }
#line 1760
  if (! parsed_info->got_password) {
    {
#line 1762
    prompt = (char *)((void *)0);
#line 1764
    tmp___11 = asprintf((char **/* __restrict  */)(& prompt), (char const   */* __restrict  */)"Password for %s@%s: ",
                        parsed_info->username, orig_dev);
    }
#line 1764
    if (tmp___11 < 0) {
#line 1765
      prompt = (char *)((void *)0);
    }
#line 1767
    if (prompt) {
#line 1767
      tmp___12 = (char const   *)prompt;
    } else {
#line 1767
      tmp___12 = "Password: ";
    }
    {
#line 1767
    tmp___13 = get_password(tmp___12, tmp_pass, 129);
    }
#line 1767
    if (tmp___13) {
      {
#line 1768
      rc = set_password(parsed_info, (char const   *)(tmp_pass));
      }
    } else {
      {
#line 1770
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error reading password, exiting\n");
#line 1771
      rc = 2;
      }
    }
    {
#line 1774
    free((void *)prompt);
    }
#line 1775
    if (rc) {
#line 1776
      goto assemble_exit;
    }
  }
#line 1780
  if (parsed_info->got_user) {
#line 1781
    if (parsed_info->options[0]) {
      {
#line 1782
      strlcat(parsed_info->options, ",", sizeof(parsed_info->options));
      }
    }
    {
#line 1784
    strlcat(parsed_info->options, "user=", sizeof(parsed_info->options));
#line 1786
    strlcat(parsed_info->options, (char const   *)(parsed_info->username), sizeof(parsed_info->options));
    }
  }
#line 1790
  if (parsed_info->domain[0]) {
#line 1791
    if (parsed_info->options[0]) {
      {
#line 1792
      strlcat(parsed_info->options, ",", sizeof(parsed_info->options));
      }
    }
    {
#line 1794
    strlcat(parsed_info->options, ",domain=", sizeof(parsed_info->options));
#line 1796
    strlcat(parsed_info->options, (char const   *)(parsed_info->domain), sizeof(parsed_info->options));
    }
  }
  assemble_exit: 
#line 1801
  return (rc);
}
}
#line 1808 "/home/june/repo/benchmarks/collector/temp/cifs-utils-6.0/mount.cifs.c"
static int acquire_mountpoint(char **mountpointp ) 
{ 
  int rc ;
  int dacrc ;
  uid_t realuid ;
  uid_t oldfsuid ;
  gid_t oldfsgid ;
  char *mountpoint ;
  int tmp ;
  __gid_t tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  uid_t uignore  __attribute__((__unused__)) ;
  int tmp___6 ;
  gid_t gignore  __attribute__((__unused__)) ;
  int tmp___7 ;

  {
  {
#line 1827
  realuid = getuid();
  }
#line 1828
  if (realuid == 0U) {
    {
#line 1829
    dacrc = toggle_dac_capability(0, 1);
    }
#line 1830
    if (dacrc) {
#line 1831
      return (dacrc);
    }
  } else {
    {
#line 1833
    tmp = setfsuid(realuid);
#line 1833
    oldfsuid = (uid_t )tmp;
#line 1834
    tmp___0 = getgid();
#line 1834
    tmp___1 = setfsgid(tmp___0);
#line 1834
    oldfsgid = (gid_t )tmp___1;
    }
  }
  {
#line 1837
  rc = chdir((char const   *)*mountpointp);
  }
#line 1838
  if (rc) {
    {
#line 1839
    tmp___2 = __errno_location();
#line 1839
    tmp___3 = strerror(*tmp___2);
#line 1839
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Couldn\'t chdir to %s: %s\n",
            *mountpointp, tmp___3);
#line 1841
    rc = 1;
    }
#line 1842
    goto restore_privs;
  }
  {
#line 1845
  mountpoint = realpath((char const   */* __restrict  */)".", (char */* __restrict  */)((void *)0));
  }
#line 1846
  if (! mountpoint) {
    {
#line 1847
    tmp___4 = __errno_location();
#line 1847
    tmp___5 = strerror(*tmp___4);
#line 1847
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to resolve %s to canonical path: %s\n",
            *mountpointp, tmp___5);
#line 1849
    rc = 2;
    }
  }
#line 1852
  *mountpointp = mountpoint;
  restore_privs: 
#line 1854
  if (realuid == 0U) {
    {
#line 1855
    dacrc = toggle_dac_capability(0, 0);
    }
#line 1856
    if (dacrc) {
#line 1857
      if (rc) {
#line 1857
        rc = rc;
      } else {
#line 1857
        rc = dacrc;
      }
    }
  } else {
    {
#line 1859
    tmp___6 = setfsuid(oldfsuid);
#line 1859
    uignore = (uid_t )tmp___6;
#line 1860
    tmp___7 = setfsgid(oldfsgid);
#line 1860
    gignore = (gid_t )tmp___7;
    }
  }
#line 1863
  return (rc);
}
}
#line 1866 "/home/june/repo/benchmarks/collector/temp/cifs-utils-6.0/mount.cifs.c"
int main(int argc , char **argv ) 
{ 
  int c ;
  char *orgoptions ;
  char *mountpoint ;
  char *options ;
  char *orig_dev ;
  char *currentaddress ;
  char *nextaddress ;
  int rc ;
  int already_uppercased ;
  int sloppy ;
  size_t options_size ;
  struct parsed_mount_info *parsed_info ;
  pid_t pid ;
  char *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  union __anonunion_66 __constr_expr_0 ;
  union __anonunion_67 __constr_expr_1 ;
  void *tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  int *tmp___14 ;
  int tmp___15 ;

  {
  {
#line 1869
  orgoptions = (char *)((void *)0);
#line 1870
  mountpoint = (char *)((void *)0);
#line 1871
  options = (char *)((void *)0);
#line 1872
  orig_dev = (char *)((void *)0);
#line 1874
  rc = 0;
#line 1875
  already_uppercased = 0;
#line 1876
  sloppy = 0;
#line 1877
  options_size = (size_t )4096;
#line 1878
  parsed_info = (struct parsed_mount_info *)((void *)0);
#line 1881
  rc = check_setuid();
  }
#line 1882
  if (rc) {
#line 1883
    return (rc);
  }
  {
#line 1885
  rc = drop_capabilities(1);
  }
#line 1886
  if (rc) {
#line 1887
    return (2);
  }
#line 1893
  if (! argc) {
    {
#line 1894
    rc = mount_usage(stderr);
    }
#line 1895
    goto mount_exit;
  } else
#line 1893
  if (! argv) {
    {
#line 1894
    rc = mount_usage(stderr);
    }
#line 1895
    goto mount_exit;
  }
  {
#line 1898
  tmp = __xpg_basename(*(argv + 0));
#line 1898
  thisprogram = (char const   *)tmp;
  }
#line 1899
  if ((unsigned long )thisprogram == (unsigned long )((void *)0)) {
#line 1900
    thisprogram = "mount.cifs";
  }
  {
#line 1903
  tmp___0 = mmap((void *)0, sizeof(*parsed_info), 3, 33, -1, (__off_t )0);
#line 1903
  parsed_info = (struct parsed_mount_info *)tmp___0;
  }
#line 1905
  if ((unsigned long )parsed_info == (unsigned long )((struct parsed_mount_info *)-1)) {
    {
#line 1906
    parsed_info = (struct parsed_mount_info *)((void *)0);
#line 1907
    tmp___1 = __errno_location();
#line 1907
    tmp___2 = strerror(*tmp___1);
#line 1907
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to allocate memory: %s\n",
            tmp___2);
    }
#line 1909
    return (2);
  }
  {
#line 1913
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1913
    c = getopt_long(argc, (char * const  *)argv, "?fhno:rsvVw", (struct option  const  *)(longopts),
                    (int *)((void *)0));
    }
#line 1913
    if (! (c != -1)) {
#line 1913
      goto while_break;
    }
    {
#line 1917
    if (c == 104) {
#line 1917
      goto case_104;
    }
#line 1917
    if (c == 63) {
#line 1917
      goto case_104;
    }
#line 1920
    if (c == 110) {
#line 1920
      goto case_110;
    }
#line 1923
    if (c == 111) {
#line 1923
      goto case_111;
    }
#line 1930
    if (c == 114) {
#line 1930
      goto case_114;
    }
#line 1933
    if (c == 118) {
#line 1933
      goto case_118;
    }
#line 1936
    if (c == 86) {
#line 1936
      goto case_86;
    }
#line 1939
    if (c == 119) {
#line 1939
      goto case_119;
    }
#line 1942
    if (c == 102) {
#line 1942
      goto case_102;
    }
#line 1945
    if (c == 115) {
#line 1945
      goto case_115;
    }
#line 1948
    goto switch_default;
    case_104: /* CIL Label */ 
    case_63: /* CIL Label */ 
    {
#line 1918
    rc = mount_usage(stdout);
    }
#line 1919
    goto mount_exit;
    case_110: /* CIL Label */ 
#line 1921
    (parsed_info->nomtab) ++;
#line 1922
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 1924
    orgoptions = strndup((char const   *)optarg, (size_t )4096);
    }
#line 1925
    if (! orgoptions) {
#line 1926
      rc = 2;
#line 1927
      goto mount_exit;
    }
#line 1929
    goto switch_break;
    case_114: /* CIL Label */ 
#line 1931
    parsed_info->flags |= 1UL;
#line 1932
    goto switch_break;
    case_118: /* CIL Label */ 
#line 1934
    (parsed_info->verboseflag) ++;
#line 1935
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 1937
    print_cifs_mount_version();
#line 1938
    exit(0);
    }
    case_119: /* CIL Label */ 
#line 1940
    parsed_info->flags &= 0xfffffffffffffffeUL;
#line 1941
    goto switch_break;
    case_102: /* CIL Label */ 
#line 1943
    (parsed_info->fakemnt) ++;
#line 1944
    goto switch_break;
    case_115: /* CIL Label */ 
#line 1946
    sloppy ++;
#line 1947
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1949
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unknown command-line option: %c\n",
            c);
#line 1950
    rc = mount_usage(stderr);
    }
#line 1951
    goto mount_exit;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1955
  if (argc < optind + 2) {
    {
#line 1956
    rc = mount_usage(stderr);
    }
#line 1957
    goto mount_exit;
  }
  {
#line 1960
  orig_dev = *(argv + optind);
#line 1961
  mountpoint = *(argv + (optind + 1));
#line 1964
  rc = acquire_mountpoint(& mountpoint);
  }
#line 1965
  if (rc) {
#line 1966
    return (rc);
  }
  {
#line 1976
  pid = fork();
  }
#line 1977
  if (pid == -1) {
    {
#line 1978
    tmp___3 = __errno_location();
#line 1978
    tmp___4 = strerror(*tmp___3);
#line 1978
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to fork: %s\n",
            tmp___4);
#line 1979
    rc = 2;
    }
#line 1980
    goto mount_exit;
  } else
#line 1981
  if (! pid) {
    {
#line 1983
    rc = assemble_mountinfo(parsed_info, thisprogram, (char const   *)mountpoint,
                            (char const   *)orig_dev, orgoptions);
    }
#line 1985
    return (rc);
  } else {
    {
#line 1988
    pid = wait((union wait *)(& rc));
#line 1989
    __constr_expr_0.__in = rc;
    }
#line 1989
    if (! ((__constr_expr_0.__i & 127) == 0)) {
      {
#line 1990
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Child process terminated abnormally.\n");
#line 1991
      rc = 2;
      }
#line 1992
      goto mount_exit;
    }
#line 1994
    __constr_expr_1.__in = rc;
#line 1994
    rc = (__constr_expr_1.__i & 65280) >> 8;
#line 1995
    if (rc) {
#line 1996
      goto mount_exit;
    }
  }
  {
#line 1999
  tmp___5 = calloc(options_size, (size_t )1);
#line 1999
  options = (char *)tmp___5;
  }
#line 2000
  if (! options) {
    {
#line 2001
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to allocate memory.\n");
#line 2002
    rc = 2;
    }
#line 2003
    goto mount_exit;
  }
  {
#line 2006
  currentaddress = parsed_info->addrlist;
#line 2007
  nextaddress = strchr((char const   *)currentaddress, ',');
  }
#line 2008
  if (nextaddress) {
#line 2009
    tmp___6 = nextaddress;
#line 2009
    nextaddress ++;
#line 2009
    *tmp___6 = (char )'\000';
  }
  mount_retry: 
#line 2012
  if (! currentaddress) {
    {
#line 2013
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to find suitable address.\n");
    }
#line 2014
    if (parsed_info->nofail) {
#line 2014
      rc = 0;
    } else {
#line 2014
      rc = 32;
    }
#line 2015
    goto mount_exit;
  }
  {
#line 2017
  strlcpy(options, "ip=", options_size);
#line 2018
  strlcat(options, (char const   *)currentaddress, options_size);
#line 2020
  strlcat(options, ",unc=\\\\", options_size);
#line 2021
  strlcat(options, (char const   *)(parsed_info->host), options_size);
#line 2022
  strlcat(options, "\\", options_size);
#line 2023
  strlcat(options, (char const   *)(parsed_info->share), options_size);
  }
#line 2025
  if (parsed_info->options[0]) {
    {
#line 2026
    strlcat(options, ",", options_size);
#line 2027
    strlcat(options, (char const   *)(parsed_info->options), options_size);
    }
  }
#line 2030
  if (parsed_info->prefix[0]) {
    {
#line 2031
    strlcat(options, ",prefixpath=", options_size);
#line 2032
    strlcat(options, (char const   *)(parsed_info->prefix), options_size);
    }
  }
#line 2035
  if (sloppy) {
    {
#line 2036
    strlcat(options, ",sloppy", options_size);
    }
  }
#line 2038
  if (parsed_info->verboseflag) {
    {
#line 2039
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s kernel mount options: %s",
            thisprogram, options);
    }
  }
#line 2042
  if (parsed_info->got_password) {
    {
#line 2047
    strlcat(options, ",pass=", options_size);
#line 2048
    strlcat(options, (char const   *)(parsed_info->password), options_size);
    }
#line 2049
    if (parsed_info->verboseflag) {
      {
#line 2050
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)",pass=********");
      }
    }
  }
#line 2053
  if (parsed_info->verboseflag) {
    {
#line 2054
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
  }
  {
#line 2056
  rc = check_mtab(thisprogram, (char const   *)orig_dev, (char const   *)mountpoint);
  }
#line 2057
  if (rc) {
#line 2058
    goto mount_exit;
  }
#line 2060
  if (! parsed_info->fakemnt) {
    {
#line 2061
    toggle_dac_capability(0, 1);
#line 2062
    rc = mount((char const   *)orig_dev, ".", cifs_fstype, parsed_info->flags, (void const   *)options);
#line 2063
    toggle_dac_capability(0, 0);
    }
#line 2064
    if (rc == 0) {
#line 2065
      goto do_mtab;
    }
    {
#line 2067
    tmp___7 = __errno_location();
    }
    {
#line 2069
    if (*tmp___7 == 113) {
#line 2069
      goto case_113;
    }
#line 2069
    if (*tmp___7 == 111) {
#line 2069
      goto case_113;
    }
#line 2077
    if (*tmp___7 == 19) {
#line 2077
      goto case_19;
    }
#line 2081
    if (*tmp___7 == 6) {
#line 2081
      goto case_6;
    }
#line 2067
    goto switch_break___0;
    case_113: /* CIL Label */ 
    case_111___0: /* CIL Label */ 
#line 2070
    currentaddress = nextaddress;
#line 2071
    if (currentaddress) {
      {
#line 2072
      nextaddress = strchr((char const   *)currentaddress, ',');
      }
#line 2073
      if (nextaddress) {
#line 2074
        tmp___8 = nextaddress;
#line 2074
        nextaddress ++;
#line 2074
        *tmp___8 = (char )'\000';
      }
    }
#line 2076
    goto mount_retry;
    case_19: /* CIL Label */ 
    {
#line 2078
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mount error: %s filesystem not supported by the system\n",
            cifs_fstype);
    }
#line 2080
    goto switch_break___0;
    case_6: /* CIL Label */ 
#line 2082
    if (! already_uppercased) {
      {
#line 2082
      tmp___9 = uppercase_string(parsed_info->host);
      }
#line 2082
      if (tmp___9) {
        {
#line 2082
        tmp___10 = uppercase_string(parsed_info->share);
        }
#line 2082
        if (tmp___10) {
          {
#line 2082
          tmp___11 = uppercase_string(parsed_info->prefix);
          }
#line 2082
          if (tmp___11) {
            {
#line 2086
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Retrying with upper case share name\n");
#line 2088
            already_uppercased = 1;
            }
#line 2089
            goto mount_retry;
          }
        }
      }
    }
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 2092
    tmp___12 = __errno_location();
#line 2092
    tmp___13 = strerror(*tmp___12);
#line 2092
    tmp___14 = __errno_location();
#line 2092
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mount error(%d): %s\n",
            *tmp___14, tmp___13);
#line 2094
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Refer to the %s(8) manual page (e.g. man %s)\n",
            thisprogram, thisprogram);
#line 2097
    rc = 32;
    }
#line 2098
    goto mount_exit;
  }
  do_mtab: 
#line 2102
  if (! parsed_info->nomtab) {
    {
#line 2102
    tmp___15 = mtab_unusable();
    }
#line 2102
    if (! tmp___15) {
#line 2103
      if (parsed_info->flags & 32UL) {
        {
#line 2104
        rc = del_mtab(mountpoint);
        }
#line 2105
        if (rc) {
#line 2106
          goto mount_exit;
        }
      }
      {
#line 2109
      rc = add_mtab(orig_dev, mountpoint, parsed_info->flags, cifs_fstype);
      }
    }
  }
  mount_exit: 
#line 2113
  if (parsed_info) {
    {
#line 2114
    memset((void *)(parsed_info->password), 0, sizeof(parsed_info->password));
#line 2115
    munmap((void *)parsed_info, sizeof(*parsed_info));
    }
  }
  {
#line 2117
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2117
    if ((unsigned long )options != (unsigned long )((void *)0)) {
      {
#line 2117
      free((void *)options);
#line 2117
      options = (char *)((void *)0);
      }
    }
#line 2117
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2118
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2118
    if ((unsigned long )orgoptions != (unsigned long )((void *)0)) {
      {
#line 2118
      free((void *)orgoptions);
#line 2118
      orgoptions = (char *)((void *)0);
      }
    }
#line 2118
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2119
  return (rc);
}
}
#line 64 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) inet_ntop)(int __af ,
                                                                                          void const   * __restrict  __cp ,
                                                                                          char * __restrict  __buf ,
                                                                                          socklen_t __len ) ;
#line 662 "/usr/include/netdb.h"
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 668
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) freeaddrinfo)(struct addrinfo *__ai ) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/cifs-utils-6.0/resolve_host.c"
int resolve_host(char const   *host , char *addrstr ) 
{ 
  int rc ;
  char tmpbuf[1037] ;
  char const   *ipaddr ;
  size_t len ;
  struct addrinfo *addrlist ;
  struct addrinfo *addr ;
  struct sockaddr_in *sin ;
  struct sockaddr_in6 *sin6 ;

  {
  {
#line 48
  rc = getaddrinfo((char const   */* __restrict  */)host, (char const   */* __restrict  */)((void *)0),
                   (struct addrinfo  const  */* __restrict  */)((void *)0), (struct addrinfo **/* __restrict  */)(& addrlist));
  }
#line 49
  if (rc != 0) {
#line 50
    return (1);
  }
#line 52
  addr = addrlist;
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
#line 53
    if (! addr) {
#line 53
      goto while_break;
    }
#line 55
    if (addr->ai_socktype != 1) {
#line 57
      addr = addr->ai_next;
#line 58
      goto while_continue;
    } else
#line 55
    if (addr->ai_protocol != 6) {
#line 57
      addr = addr->ai_next;
#line 58
      goto while_continue;
    }
    {
#line 62
    if ((int )(addr->ai_addr)->sa_family == 10) {
#line 62
      goto case_10;
    }
#line 77
    if ((int )(addr->ai_addr)->sa_family == 2) {
#line 77
      goto case_2;
    }
#line 87
    goto switch_default;
    case_10: /* CIL Label */ 
    {
#line 63
    sin6 = (struct sockaddr_in6 *)addr->ai_addr;
#line 64
    ipaddr = inet_ntop(10, (void const   */* __restrict  */)(& sin6->sin6_addr), (char */* __restrict  */)(tmpbuf),
                       (socklen_t )sizeof(tmpbuf));
    }
#line 66
    if (! ipaddr) {
#line 67
      rc = 2;
#line 68
      goto resolve_host_out;
    }
#line 71
    if (sin6->sin6_scope_id) {
      {
#line 72
      len = strnlen((char const   *)(tmpbuf), sizeof(tmpbuf));
#line 73
      snprintf((char */* __restrict  */)(tmpbuf + len), sizeof(tmpbuf) - len, (char const   */* __restrict  */)"%%%u",
               sin6->sin6_scope_id);
      }
    }
#line 76
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 78
    sin = (struct sockaddr_in *)addr->ai_addr;
#line 79
    ipaddr = inet_ntop(2, (void const   */* __restrict  */)(& sin->sin_addr), (char */* __restrict  */)(tmpbuf),
                       (socklen_t )sizeof(tmpbuf));
    }
#line 81
    if (! ipaddr) {
#line 82
      rc = 2;
#line 83
      goto resolve_host_out;
    }
#line 86
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 88
    addr = addr->ai_next;
#line 89
    goto while_continue;
    switch_break: /* CIL Label */ ;
    }
#line 92
    if ((unsigned long )addr == (unsigned long )addrlist) {
#line 93
      *addrstr = (char )'\000';
    } else {
      {
#line 95
      strlcat(addrstr, ",", (size_t )752);
      }
    }
    {
#line 97
    strlcat(addrstr, (char const   *)(tmpbuf), (size_t )752);
#line 98
    addr = addr->ai_next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  resolve_host_out: 
  {
#line 102
  freeaddrinfo(addrlist);
  }
#line 103
  return (rc);
}
}
#line 110 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/cifs-utils-6.0/util.c"
size_t strlcpy(char *d , char const   *s , size_t bufsize ) 
{ 
  size_t len ;
  size_t tmp ;
  size_t ret ;

  {
  {
#line 38
  tmp = strlen(s);
#line 38
  len = tmp;
#line 39
  ret = len;
  }
#line 40
  if (bufsize <= 0UL) {
#line 40
    return ((size_t )0);
  }
#line 41
  if (len >= bufsize) {
#line 41
    len = bufsize - 1UL;
  }
  {
#line 42
  memcpy((void */* __restrict  */)d, (void const   */* __restrict  */)s, len);
#line 43
  *(d + len) = (char)0;
  }
#line 44
  return (ret);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/cifs-utils-6.0/util.c"
size_t strlcat(char *d , char const   *s , size_t bufsize ) 
{ 
  size_t len1 ;
  size_t tmp ;
  size_t len2 ;
  size_t tmp___0 ;
  size_t ret ;

  {
  {
#line 55
  tmp = strlen((char const   *)d);
#line 55
  len1 = tmp;
#line 56
  tmp___0 = strlen(s);
#line 56
  len2 = tmp___0;
#line 57
  ret = len1 + len2;
  }
#line 59
  if (len1 + len2 >= bufsize) {
#line 60
    if (bufsize < len1 + 1UL) {
#line 61
      return (ret);
    }
#line 63
    len2 = bufsize - (len1 + 1UL);
  }
#line 65
  if (len2 > 0UL) {
    {
#line 66
    memcpy((void */* __restrict  */)(d + len1), (void const   */* __restrict  */)s,
           len2);
#line 67
    *(d + (len1 + len2)) = (char)0;
    }
  }
#line 69
  return (ret);
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/cifs-utils-6.0/util.c"
char *getusername(uid_t uid ) 
{ 
  char *username ;
  struct passwd *password ;
  struct passwd *tmp ;

  {
  {
#line 77
  username = (char *)((void *)0);
#line 78
  tmp = getpwuid(uid);
#line 78
  password = tmp;
  }
#line 80
  if (password) {
#line 81
    username = password->pw_name;
  }
#line 82
  return (username);
}
}
