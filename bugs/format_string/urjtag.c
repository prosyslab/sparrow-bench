/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 211 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stddef.h"
typedef unsigned int size_t;
#line 56 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 141 "/usr/include/bits/types.h"
typedef long __off_t;
#line 142 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 45 "/usr/include/stdio.h"
struct _IO_FILE;
#line 49 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 180 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 186 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 271 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 341 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 52 "vhdl_flex.c"
typedef short flex_int16_t;
#line 53 "vhdl_flex.c"
typedef int flex_int32_t;
#line 125 "vhdl_flex.c"
typedef void *yyscan_t;
#line 179
struct yy_buffer_state;
#line 179 "vhdl_flex.c"
typedef struct yy_buffer_state *YY_BUFFER_STATE;
#line 206 "vhdl_flex.c"
typedef size_t yy_size_t;
#line 211 "vhdl_flex.c"
struct yy_buffer_state {
   FILE *yy_input_file ;
   char *yy_ch_buf ;
   char *yy_buf_pos ;
   yy_size_t yy_buf_size ;
   int yy_n_chars ;
   int yy_is_our_buffer ;
   int yy_is_interactive ;
   int yy_at_bol ;
   int yy_bs_lineno ;
   int yy_bs_column ;
   int yy_fill_buffer ;
   int yy_buffer_status ;
};
#line 337 "vhdl_flex.c"
typedef unsigned char YY_CHAR;
#line 339 "vhdl_flex.c"
typedef int yy_state_type;
#line 33 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bsdl/bsdl_types.h"
struct scan_extra {
   int proc_mode ;
   int Compile_Errors ;
   int Base ;
};
#line 39 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bsdl/bsdl_types.h"
typedef struct scan_extra scan_extra_t;
#line 206 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bsdl/vhdl_bison.h"
union YYSTYPE {
   int integer ;
   char *str ;
};
#line 206 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bsdl/vhdl_bison.h"
typedef union YYSTYPE YYSTYPE;
#line 975 "vhdl_flex.c"
struct yyguts_t {
   scan_extra_t *yyextra_r ;
   FILE *yyin_r ;
   FILE *yyout_r ;
   size_t yy_buffer_stack_top ;
   size_t yy_buffer_stack_max ;
   YY_BUFFER_STATE *yy_buffer_stack ;
   char yy_hold_char ;
   int yy_n_chars ;
   int yyleng_r ;
   char *yy_c_buf_p ;
   int yy_init ;
   int yy_start ;
   int yy_did_buffer_switch_on_eof ;
   int yy_start_stack_ptr ;
   int yy_start_stack_depth ;
   int *yy_start_stack ;
   yy_state_type yy_last_accepting_state ;
   char *yy_last_accepting_cpos ;
   int yylineno_r ;
   int yy_flex_debug_r ;
   yy_state_type *yy_state_buf ;
   yy_state_type *yy_state_ptr ;
   char *yy_full_match ;
   int yy_lp ;
   int yy_looking_for_trail_begin ;
   int yy_full_lp ;
   int *yy_full_state ;
   char *yytext_r ;
   int yy_more_flag ;
   int yy_more_len ;
   YYSTYPE *yylval_r ;
};
#line 197 "/usr/include/sys/types.h"
typedef int int32_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 52 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 29 "../../include/bssignal.h"
struct signal;
#line 29 "../../include/bssignal.h"
typedef struct signal signal_t;
#line 28 "../../include/bsbit.h"
struct bsbit;
#line 28 "../../include/bsbit.h"
typedef struct bsbit bsbit_t;
#line 40 "../../include/bsbit.h"
struct bsbit {
   int bit ;
   char *name ;
   int type ;
   signal_t *signal ;
   int safe ;
   int control ;
   int control_value ;
   int control_state ;
};
#line 33 "../../include/bssignal.h"
struct signal {
   char *name ;
   char *pin ;
   signal_t *next ;
   bsbit_t *input ;
   bsbit_t *output ;
};
#line 41
struct salias;
#line 41 "../../include/bssignal.h"
typedef struct salias salias_t;
#line 43 "../../include/bssignal.h"
struct salias {
   char *name ;
   salias_t *next ;
   signal_t *signal ;
};
#line 29 "../../include/register.h"
struct tap_register {
   char *data ;
   int len ;
   char *string ;
};
#line 29 "../../include/register.h"
typedef struct tap_register tap_register;
#line 32 "../../include/data_register.h"
struct data_register;
#line 32 "../../include/data_register.h"
typedef struct data_register data_register;
#line 34 "../../include/data_register.h"
struct data_register {
   char name[33] ;
   tap_register *in ;
   tap_register *out ;
   data_register *next ;
};
#line 33 "../../include/instruction.h"
struct instruction;
#line 33 "../../include/instruction.h"
typedef struct instruction instruction;
#line 35 "../../include/instruction.h"
struct instruction {
   char name[21] ;
   tap_register *value ;
   tap_register *out ;
   data_register *data_register ;
   instruction *next ;
};
#line 39 "../../include/part.h"
struct part;
#line 39 "../../include/part.h"
typedef struct part part_t;
#line 41 "../../include/part.h"
struct part {
   tap_register *id ;
   char *alias ;
   char manufacturer[26] ;
   char part[21] ;
   char stepping[9] ;
   signal_t *signals ;
   salias_t *saliases ;
   int instruction_length ;
   instruction *instructions ;
   instruction *active_instruction ;
   data_register *data_registers ;
   int boundary_length ;
   bsbit_t **bsbits ;
};
#line 68
struct parts;
#line 68 "../../include/part.h"
typedef struct parts parts_t;
#line 70 "../../include/part.h"
struct parts {
   int len ;
   part_t **parts ;
};
#line 27 "../../include/pod.h"
enum __anonenum_pod_sigsel_t_24 {
    CS_NONE = 0,
    CS_TDI = 1,
    CS_TCK = 2,
    CS_TMS = 4,
    CS_TRST = 8,
    CS_RESET = 16,
    CS_SCK = 32,
    CS_SDA = 64,
    CS_SS = 128
} ;
#line 27 "../../include/pod.h"
typedef enum __anonenum_pod_sigsel_t_24 pod_sigsel_t;
#line 31 "../../include/chain.h"
struct chain_t;
#line 31 "../../include/chain.h"
typedef struct chain_t chain_t;
#line 31 "../../include/cable.h"
struct cable_t;
#line 31 "../../include/cable.h"
typedef struct cable_t cable_t;
#line 32 "../../include/usbconn.h"
struct usbconn_t;
#line 32 "../../include/usbconn.h"
typedef struct usbconn_t usbconn_t;
#line 36 "../../include/usbconn.h"
struct __anonstruct_usbconn_cable_t_25 {
   char *name ;
   char *desc ;
   char *driver ;
   int32_t vid ;
   int32_t pid ;
};
#line 36 "../../include/usbconn.h"
typedef struct __anonstruct_usbconn_cable_t_25 usbconn_cable_t;
#line 45 "../../include/usbconn.h"
struct __anonstruct_usbconn_driver_t_26 {
   char const   *type ;
   usbconn_t *(*connect)(char const   ** , int  , usbconn_cable_t * ) ;
   void (*free)(usbconn_t * ) ;
   int (*open)(usbconn_t * ) ;
   int (*close)(usbconn_t * ) ;
   int (*read)(usbconn_t * , uint8_t * , int  ) ;
   int (*write)(usbconn_t * , uint8_t * , int  , int  ) ;
};
#line 45 "../../include/usbconn.h"
typedef struct __anonstruct_usbconn_driver_t_26 usbconn_driver_t;
#line 55 "../../include/usbconn.h"
struct usbconn_t {
   usbconn_driver_t *driver ;
   void *params ;
   cable_t *cable ;
};
#line 31 "../../include/parport.h"
struct parport_t;
#line 31 "../../include/parport.h"
typedef struct parport_t parport_t;
#line 35 "../../include/parport.h"
struct __anonstruct_parport_driver_t_27 {
   char const   *type ;
   parport_t *(*connect)(char const   ** , int  ) ;
   void (*parport_free)(parport_t * ) ;
   int (*open)(parport_t * ) ;
   int (*close)(parport_t * ) ;
   int (*set_data)(parport_t * , uint8_t  ) ;
   int (*get_data)(parport_t * ) ;
   int (*get_status)(parport_t * ) ;
   int (*set_control)(parport_t * , uint8_t  ) ;
};
#line 35 "../../include/parport.h"
typedef struct __anonstruct_parport_driver_t_27 parport_driver_t;
#line 47 "../../include/parport.h"
struct parport_t {
   parport_driver_t *driver ;
   void *params ;
   cable_t *cable ;
};
#line 38 "../../include/cable.h"
struct cable_driver_t;
#line 38 "../../include/cable.h"
typedef struct cable_driver_t cable_driver_t;
#line 40
enum __anonenum_cable_flush_amount_t_28 {
    OPTIONALLY = 0,
    TO_OUTPUT = 1,
    COMPLETELY = 2
} ;
#line 40 "../../include/cable.h"
typedef enum __anonenum_cable_flush_amount_t_28 cable_flush_amount_t;
#line 48 "../../include/cable.h"
struct cable_driver_t {
   char const   *name ;
   char const   *description ;
   int (*connect)(char **params , cable_t *cable ) ;
   void (*disconnect)(cable_t *cable ) ;
   void (*cable_free)(cable_t *cable ) ;
   int (*init)(cable_t * ) ;
   void (*done)(cable_t * ) ;
   void (*set_frequency)(cable_t * , uint32_t freq ) ;
   void (*clock)(cable_t * , int  , int  , int  ) ;
   int (*get_tdo)(cable_t * ) ;
   int (*transfer)(cable_t * , int  , char * , char * ) ;
   int (*set_signal)(cable_t * , int  , int  ) ;
   int (*get_signal)(cable_t * , pod_sigsel_t  ) ;
   void (*flush)(cable_t * , cable_flush_amount_t  ) ;
   void (*help)(char const   * ) ;
};
#line 66
struct cable_queue_t;
#line 66 "../../include/cable.h"
typedef struct cable_queue_t cable_queue_t;
#line 68
enum __anonenum_action_29 {
    CABLE_CLOCK = 0,
    CABLE_GET_TDO = 1,
    CABLE_TRANSFER = 2,
    CABLE_SET_SIGNAL = 3,
    CABLE_GET_SIGNAL = 4
} ;
#line 68 "../../include/cable.h"
struct __anonstruct_clock_31 {
   int tms ;
   int tdi ;
   int n ;
};
#line 68 "../../include/cable.h"
struct __anonstruct_value_32 {
   pod_sigsel_t sig ;
   int mask ;
   int val ;
};
#line 68 "../../include/cable.h"
struct __anonstruct_transfer_33 {
   int len ;
   char *in ;
   char *out ;
};
#line 68 "../../include/cable.h"
struct __anonstruct_xferred_34 {
   int len ;
   int res ;
   char *out ;
};
#line 68 "../../include/cable.h"
union __anonunion_arg_30 {
   struct __anonstruct_clock_31 clock ;
   struct __anonstruct_value_32 value ;
   struct __anonstruct_transfer_33 transfer ;
   struct __anonstruct_xferred_34 xferred ;
};
#line 68 "../../include/cable.h"
struct cable_queue_t {
   enum __anonenum_action_29 action ;
   union __anonunion_arg_30 arg ;
};
#line 100
struct cable_queue_info_t;
#line 100 "../../include/cable.h"
typedef struct cable_queue_info_t cable_queue_info_t;
#line 102 "../../include/cable.h"
struct cable_queue_info_t {
   cable_queue_t *data ;
   int max_items ;
   int num_items ;
   int next_item ;
   int next_free ;
};
#line 110 "../../include/cable.h"
union __anonunion_link_35 {
   usbconn_t *usb ;
   parport_t *port ;
};
#line 110 "../../include/cable.h"
struct cable_t {
   cable_driver_t *driver ;
   union __anonunion_link_35 link ;
   void *params ;
   chain_t *chain ;
   cable_queue_info_t todo ;
   cable_queue_info_t done ;
   uint32_t delay ;
   uint32_t frequency ;
};
#line 30 "../../include/bsdl.h"
struct __anonstruct_bsdl_globs_t_36 {
   char **path_list ;
   int debug ;
};
#line 30 "../../include/bsdl.h"
typedef struct __anonstruct_bsdl_globs_t_36 bsdl_globs_t;
#line 41 "../../include/chain.h"
struct chain_t {
   int state ;
   parts_t *parts ;
   int total_instr_len ;
   int active_part ;
   cable_t *cable ;
   bsdl_globs_t bsdl ;
};
#line 43 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bsdl/bsdl_types.h"
struct instr_elem {
   struct instr_elem *next ;
   char *instr ;
   char *opcode ;
};
#line 49 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bsdl/bsdl_types.h"
typedef struct instr_elem instr_elem_t;
#line 58 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bsdl/bsdl_types.h"
struct ainfo_elem {
   struct ainfo_elem *next ;
   char *reg ;
   int reg_len ;
   instr_elem_t *instr_list ;
};
#line 65 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bsdl/bsdl_types.h"
typedef struct ainfo_elem ainfo_elem_t;
#line 71 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bsdl/bsdl_types.h"
struct cell_info {
   struct cell_info *next ;
   int bit_num ;
   char *port_name ;
   int cell_function ;
   char *basic_safe_value ;
   int ctrl_bit_num ;
   int disable_safe_value ;
};
#line 83 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bsdl/bsdl_types.h"
typedef struct cell_info cell_info_t;
#line 86 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bsdl/bsdl_types.h"
struct string_elem {
   struct string_elem *next ;
   char *string ;
};
#line 91 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bsdl/bsdl_types.h"
typedef struct string_elem string_elem_t;
#line 98 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bsdl/bsdl_types.h"
struct port_desc {
   string_elem_t *names_list ;
   struct port_desc *next ;
   int is_vector ;
   int low_idx ;
   int high_idx ;
};
#line 106 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bsdl/bsdl_types.h"
typedef struct port_desc port_desc_t;
#line 108
enum __anonenum_vhdl_elem_type_t_43 {
    VET_CONSTANT = 0,
    VET_ATTRIBUTE_STRING = 1,
    VET_ATTRIBUTE_DECIMAL = 2,
    VET_UNKNOWN = 3
} ;
#line 108 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bsdl/bsdl_types.h"
typedef enum __anonenum_vhdl_elem_type_t_43 vhdl_elem_type_t;
#line 116 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bsdl/bsdl_types.h"
struct vhdl_elem {
   struct vhdl_elem *next ;
   vhdl_elem_type_t type ;
   char *name ;
   char *payload ;
   int line ;
};
#line 124 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bsdl/bsdl_types.h"
typedef struct vhdl_elem vhdl_elem_t;
#line 126
enum __anonenum_bsdl_conformance_t_44 {
    CONF_1990 = 0,
    CONF_1993 = 1,
    CONF_2001 = 2,
    CONF_UNKNOWN = 3
} ;
#line 126 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bsdl/bsdl_types.h"
typedef enum __anonenum_bsdl_conformance_t_44 bsdl_conformance_t;
#line 136 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bsdl/bsdl_types.h"
struct jtag_ctrl {
   int proc_mode ;
   chain_t *chain ;
   part_t *part ;
   port_desc_t *port_desc ;
   vhdl_elem_t *vhdl_elem_first ;
   vhdl_elem_t *vhdl_elem_last ;
   char *idcode ;
   char *usercode ;
   int instr_len ;
   int bsr_len ;
   bsdl_conformance_t conformance ;
   instr_elem_t *instr_list ;
   ainfo_elem_t *ainfo_list ;
   cell_info_t *cell_info_first ;
   cell_info_t *cell_info_last ;
};
#line 156 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bsdl/bsdl_types.h"
typedef struct jtag_ctrl jtag_ctrl_t;
#line 160 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bsdl/bsdl_types.h"
struct vhdl_parser_priv {
   char Package_File_Name[100] ;
   int Reading_Package ;
   char *buffer ;
   size_t len_buffer ;
   void *scanner ;
   jtag_ctrl_t *jtag_ctrl ;
   port_desc_t tmp_port_desc ;
};
#line 170 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bsdl/bsdl_types.h"
typedef struct vhdl_parser_priv vhdl_parser_priv_t;
#line 356 "vhdl_bison.c"
typedef unsigned char yytype_uint8;
#line 371 "vhdl_bison.c"
typedef unsigned short yytype_uint16;
#line 377 "vhdl_bison.c"
typedef short yytype_int16;
#line 508 "vhdl_bison.c"
union yyalloc {
   yytype_int16 yyss_alloc ;
   YYSTYPE yyvs_alloc ;
};
#line 174 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bsdl/bsdl_types.h"
struct bsdl_parser_priv {
   void *scanner ;
   jtag_ctrl_t *jtag_ctrl ;
   int lineno ;
   ainfo_elem_t ainfo ;
   cell_info_t tmp_cell_info ;
   port_desc_t tmp_port_desc ;
};
#line 183 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bsdl/bsdl_types.h"
typedef struct bsdl_parser_priv bsdl_parser_priv_t;
#line 57 "/usr/include/bits/types.h"
typedef unsigned long long __u_quad_t;
#line 134 "/usr/include/bits/types.h"
typedef __u_quad_t __dev_t;
#line 135 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 136 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 137 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 140 "/usr/include/bits/types.h"
typedef unsigned int __nlink_t;
#line 149 "/usr/include/bits/types.h"
typedef long __time_t;
#line 164 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 169 "/usr/include/bits/types.h"
typedef long __blkcnt_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 40 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 102 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 23 "/usr/include/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 128 "/usr/include/dirent.h"
struct __dirstream;
#line 128 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 43 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
#line 54 "/usr/include/locale.h"
struct lconv {
   char *decimal_point ;
   char *thousands_sep ;
   char *grouping ;
   char *int_curr_symbol ;
   char *currency_symbol ;
   char *mon_decimal_point ;
   char *mon_thousands_sep ;
   char *mon_grouping ;
   char *positive_sign ;
   char *negative_sign ;
   char int_frac_digits ;
   char frac_digits ;
   char p_cs_precedes ;
   char p_sep_by_space ;
   char n_cs_precedes ;
   char n_sep_by_space ;
   char p_sign_posn ;
   char n_sign_posn ;
   char int_p_cs_precedes ;
   char int_p_sep_by_space ;
   char int_n_cs_precedes ;
   char int_n_sep_by_space ;
   char int_p_sign_posn ;
   char int_n_sign_posn ;
};
#line 36 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/svf/svf.h"
struct tdval {
   int token ;
   double dvalue ;
};
#line 40 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/svf/svf.h"
struct tcval {
   int token ;
   char *cvalue ;
   struct tcval *next ;
};
#line 107 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/svf/svf.h"
struct scanner_extra {
   int num_lines ;
   int print_progress ;
   int planb ;
   char decimal_point ;
};
#line 113 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/svf/svf.h"
typedef struct scanner_extra scanner_extra_t;
#line 115
struct YYLTYPE;
#line 166 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/svf/svf_bison.h"
union YYSTYPE___0 {
   int token ;
   double dvalue ;
   char *cvalue ;
   int ivalue ;
   struct tdval tdval ;
   struct tcval *tcval ;
};
#line 166 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/svf/svf_bison.h"
typedef union YYSTYPE___0 YYSTYPE___0;
#line 192 "svf_bison.h"
struct YYLTYPE {
   int first_line ;
   int first_column ;
   int last_line ;
   int last_column ;
};
#line 192 "svf_bison.h"
typedef struct YYLTYPE YYLTYPE;
#line 546 "svf_flex.c"
struct yyguts_t___0 {
   scanner_extra_t *yyextra_r ;
   FILE *yyin_r ;
   FILE *yyout_r ;
   size_t yy_buffer_stack_top ;
   size_t yy_buffer_stack_max ;
   YY_BUFFER_STATE *yy_buffer_stack ;
   char yy_hold_char ;
   int yy_n_chars ;
   int yyleng_r ;
   char *yy_c_buf_p ;
   int yy_init ;
   int yy_start ;
   int yy_did_buffer_switch_on_eof ;
   int yy_start_stack_ptr ;
   int yy_start_stack_depth ;
   int *yy_start_stack ;
   yy_state_type yy_last_accepting_state ;
   char *yy_last_accepting_cpos ;
   int yylineno_r ;
   int yy_flex_debug_r ;
   char *yytext_r ;
   int yy_more_flag ;
   int yy_more_len ;
   YYSTYPE___0 *yylval_r ;
   YYLTYPE *yylloc_r ;
};
#line 216 "svf_flex.l"
struct rwtable {
   char *rw_name ;
   int rw_yylex ;
};
#line 33 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/svf/svf.h"
enum generic_irdr_coding {
    generic_ir = 0,
    generic_dr = 1
} ;
#line 47 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/svf/svf.h"
struct ths_params {
   double number ;
   char *tdi ;
   char *tdo ;
   char *mask ;
   char *smask ;
};
#line 55 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/svf/svf.h"
struct path_states {
   int states[64] ;
   int num_states ;
};
#line 60 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/svf/svf.h"
struct runtest {
   int run_state ;
   uint32_t run_count ;
   int run_clk ;
   double min_time ;
   double max_time ;
   int end_state ;
};
#line 69 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/svf/svf.h"
struct __anonstruct_sxr_t_37 {
   struct ths_params params ;
   int no_tdi ;
   int no_tdo ;
};
#line 69 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/svf/svf.h"
typedef struct __anonstruct_sxr_t_37 sxr_t;
#line 76 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/svf/svf.h"
struct svf_parser_params {
   struct ths_params ths_params ;
   struct path_states path_states ;
   struct runtest runtest ;
};
#line 85 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/svf/svf.h"
struct parser_priv {
   struct svf_parser_params parser_params ;
   void *scanner ;
   part_t *part ;
   instruction *ir ;
   data_register *dr ;
   sxr_t sir_params ;
   sxr_t sdr_params ;
   int endir ;
   int enddr ;
   int runtest_run_state ;
   int runtest_end_state ;
   int svf_stop_on_mismatch ;
   int svf_trst_absent ;
   int svf_state_executed ;
   uint32_t ref_freq ;
   int mismatch_occurred ;
   int issued_runtest_maxtime ;
};
#line 105 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/svf/svf.h"
typedef struct parser_priv parser_priv_t;
#line 308 "svf_bison.c"
typedef signed char yytype_int8;
#line 454 "svf_bison.c"
union yyalloc___0 {
   yytype_int16 yyss_alloc ;
   YYSTYPE___0 yyvs_alloc ;
   YYLTYPE yyls_alloc ;
};
#line 143 "/usr/include/bits/types.h"
typedef int __pid_t;
#line 145 "/usr/include/bits/types.h"
typedef long __clock_t;
#line 150 "/usr/include/bits/types.h"
typedef unsigned int __useconds_t;
#line 29 "/usr/include/bits/sigset.h"
struct __anonstruct___sigset_t_5 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 29 "/usr/include/bits/sigset.h"
typedef struct __anonstruct___sigset_t_5 __sigset_t;
#line 38 "/usr/include/sys/select.h"
typedef __sigset_t sigset_t;
#line 33 "/usr/include/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 33 "/usr/include/bits/siginfo.h"
typedef union sigval sigval_t;
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__kill_27 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__timer_28 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__rt_29 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigchld_30 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigfault_31 {
   void *si_addr ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigpoll_32 {
   long si_band ;
   int si_fd ;
};
#line 51 "/usr/include/bits/siginfo.h"
union __anonunion__sifields_26 {
   int _pad[128UL / sizeof(int ) - 3UL] ;
   struct __anonstruct__kill_27 _kill ;
   struct __anonstruct__timer_28 _timer ;
   struct __anonstruct__rt_29 _rt ;
   struct __anonstruct__sigchld_30 _sigchld ;
   struct __anonstruct__sigfault_31 _sigfault ;
   struct __anonstruct__sigpoll_32 _sigpoll ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_26 _sifields ;
};
#line 51 "/usr/include/bits/siginfo.h"
typedef struct siginfo siginfo_t;
#line 25 "/usr/include/bits/sigaction.h"
union __anonunion___sigaction_handler_44 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 25 "/usr/include/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_44 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 59 "/usr/include/stdint.h"
typedef unsigned long long uint64_t;
#line 42 "../../include/bus_driver.h"
struct __anonstruct_bus_area_t_41 {
   char const   *description ;
   uint32_t start ;
   uint64_t length ;
   unsigned int width ;
};
#line 42 "../../include/bus_driver.h"
typedef struct __anonstruct_bus_area_t_41 bus_area_t;
#line 49
struct bus;
#line 49 "../../include/bus_driver.h"
typedef struct bus bus_t;
#line 50
struct bus_driver;
#line 50 "../../include/bus_driver.h"
typedef struct bus_driver bus_driver_t;
#line 52 "../../include/bus_driver.h"
struct bus_driver {
   char const   *name ;
   char const   *description ;
   bus_t *(*new_bus)(chain_t *chain , bus_driver_t const   *driver , char **cmd_params ) ;
   void (*free_bus)(bus_t *bus ) ;
   void (*printinfo)(bus_t *bus ) ;
   void (*prepare)(bus_t *bus ) ;
   int (*area)(bus_t *bus , uint32_t adr , bus_area_t *area ) ;
   void (*read_start)(bus_t *bus , uint32_t adr ) ;
   uint32_t (*read_next)(bus_t *bus , uint32_t adr ) ;
   uint32_t (*read_end)(bus_t *bus ) ;
   uint32_t (*read)(bus_t *bus , uint32_t adr ) ;
   void (*write)(bus_t *bus , uint32_t adr , uint32_t data ) ;
   int (*init)(bus_t *bus ) ;
};
#line 68 "../../include/bus_driver.h"
struct bus {
   chain_t *chain ;
   part_t *part ;
   void *params ;
   int initialized ;
   bus_driver_t const   *driver ;
};
#line 101 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/zefant-xs3.c"
typedef int ctype_t;
#line 103 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/zefant-xs3.c"
struct __anonstruct_component_t_47 {
   ctype_t ctype ;
   char *cname ;
   signal_t *a[25] ;
   signal_t *d[16] ;
   signal_t *ncs ;
   signal_t *noe ;
   signal_t *nwe ;
   signal_t *nlb ;
   signal_t *nub ;
   signal_t *nbyte ;
   signal_t *sts ;
   signal_t *nrp ;
   signal_t *si ;
   signal_t *so ;
   signal_t *sck ;
};
#line 103 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/zefant-xs3.c"
typedef struct __anonstruct_component_t_47 component_t;
#line 121 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/zefant-xs3.c"
struct __anonstruct_bus_params_t_48 {
   uint32_t last_addr ;
   component_t flash ;
   component_t ram0 ;
   component_t ram1 ;
   component_t eeprom ;
   component_t eeprom_status ;
};
#line 121 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/zefant-xs3.c"
typedef struct __anonstruct_bus_params_t_48 bus_params_t;
#line 45 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/tx4925.c"
struct __anonstruct_bus_params_t_46 {
   signal_t *oe ;
   signal_t *swe ;
   signal_t *romce[4] ;
   signal_t *sdcs[4] ;
   signal_t *addr[20] ;
   signal_t *data[16] ;
};
#line 45 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/tx4925.c"
typedef struct __anonstruct_bus_params_t_46 bus_params_t___0;
#line 45 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/slsup3.c"
struct __anonstruct_bus_params_t_46___0 {
   uint32_t last_adr ;
   signal_t *ad[20] ;
   signal_t *dq[16] ;
   signal_t *nsdce ;
   signal_t *sdclk ;
   signal_t *noe ;
   signal_t *nsrce ;
   signal_t *nflce ;
   signal_t *nflbyte ;
   signal_t *nflby ;
   signal_t *nwe ;
   signal_t *lcde ;
   signal_t *lcdrs ;
   signal_t *lcdrw ;
};
#line 45 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/slsup3.c"
typedef struct __anonstruct_bus_params_t_46___0 bus_params_t___1;
#line 45 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sharc21065l.c"
struct __anonstruct_bus_params_t_46___1 {
   uint32_t last_adr ;
   signal_t *ma[19] ;
   signal_t *md[8] ;
   signal_t *bms ;
   signal_t *nwe ;
   signal_t *noe ;
};
#line 45 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sharc21065l.c"
typedef struct __anonstruct_bus_params_t_46___1 bus_params_t___2;
#line 40 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sh7751r.c"
struct __anonstruct_bus_params_t_46___2 {
   signal_t *a[26] ;
   signal_t *d[32] ;
   signal_t *cs[8] ;
   signal_t *we[4] ;
   signal_t *rdwr ;
   signal_t *rd ;
   signal_t *bs ;
};
#line 40 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sh7751r.c"
typedef struct __anonstruct_bus_params_t_46___2 bus_params_t___3;
#line 40 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sh7750r.c"
struct __anonstruct_bus_params_t_46___3 {
   signal_t *a[26] ;
   signal_t *d[64] ;
   signal_t *cs[7] ;
   signal_t *we[4] ;
   signal_t *rdwr ;
   signal_t *rd ;
   signal_t *rdwr2 ;
   signal_t *rd2 ;
};
#line 40 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sh7750r.c"
typedef struct __anonstruct_bus_params_t_46___3 bus_params_t___4;
#line 40 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sh7727.c"
struct __anonstruct_bus_params_t_46___4 {
   signal_t *a[26] ;
   signal_t *d[32] ;
   signal_t *cs[7] ;
   signal_t *we[4] ;
   signal_t *rdwr ;
   signal_t *rd ;
   signal_t *md3 ;
   signal_t *md4 ;
};
#line 40 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sh7727.c"
typedef struct __anonstruct_bus_params_t_46___4 bus_params_t___5;
#line 43 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sa1110.c"
struct __anonstruct_bus_params_t_46___5 {
   signal_t *a[26] ;
   signal_t *d[32] ;
   signal_t *ncs[6] ;
   signal_t *rd_nwr ;
   signal_t *nwe ;
   signal_t *noe ;
};
#line 43 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sa1110.c"
typedef struct __anonstruct_bus_params_t_46___5 bus_params_t___6;
#line 76 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/s3c4510x.c"
struct __anonstruct_bus_params_t_46___6 {
   signal_t *a[22] ;
   signal_t *d[32] ;
   signal_t *nrcs[6] ;
   signal_t *necs[4] ;
   signal_t *nsdcs[4] ;
   signal_t *nwbe[4] ;
   signal_t *noe ;
   int dbuswidth ;
};
#line 76 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/s3c4510x.c"
typedef struct __anonstruct_bus_params_t_46___6 bus_params_t___7;
#line 67 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/pxa2x0_mc.h"
struct MC_registers {
   uint32_t mdcnfg ;
   uint32_t mdrefr ;
   uint32_t msc0 ;
   uint32_t msc1 ;
   uint32_t msc2 ;
   uint32_t mecr ;
   uint32_t __reserved1 ;
   uint32_t sxcnfg ;
   uint32_t __reserved2 ;
   uint32_t sxmrs ;
   uint32_t mcmem0 ;
   uint32_t mcmem1 ;
   uint32_t mcatt0 ;
   uint32_t mcatt1 ;
   uint32_t mcio0 ;
   uint32_t mcio1 ;
   uint32_t mdmrs ;
   uint32_t boot_def ;
   uint32_t __reserved3[4] ;
   uint32_t mdmrslp ;
   uint32_t __reserved4[2] ;
   uint32_t sa1111cr ;
};
#line 67 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/pxa2x0_mc.h"
typedef struct MC_registers  volatile  MC_registers_t;
#line 62 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/pxa2x0.c"
struct __anonstruct_ncs_map_entry_46 {
   char *sig_name ;
   int enabled ;
   int bus_width ;
   char label_buf[81] ;
};
#line 62 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/pxa2x0.c"
typedef struct __anonstruct_ncs_map_entry_46 ncs_map_entry;
#line 107 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/pxa2x0.c"
struct __anonstruct_bus_params_t_47 {
   uint32_t last_adr ;
   signal_t *ma[26] ;
   signal_t *md[32] ;
   signal_t *ncs[6] ;
   signal_t *dqm[4] ;
   signal_t *rdnwr ;
   signal_t *nwe ;
   signal_t *noe ;
   signal_t *nsdcas ;
   MC_registers_t MC_registers ;
   int inited ;
   int proc ;
};
#line 107 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/pxa2x0.c"
typedef struct __anonstruct_bus_params_t_47 bus_params_t___8;
#line 40 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/prototype.c"
struct __anonstruct_bus_params_t_46___7 {
   signal_t *a[32] ;
   signal_t *d[32] ;
   signal_t *cs ;
   signal_t *we ;
   signal_t *oe ;
   int alsbi ;
   int amsbi ;
   int ai ;
   int aw ;
   int dlsbi ;
   int dmsbi ;
   int di ;
   int dw ;
   int csa ;
   int wea ;
   int oea ;
   int ashift ;
};
#line 40 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/prototype.c"
typedef struct __anonstruct_bus_params_t_46___7 bus_params_t___9;
#line 39 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ppc440gx_ebc8.c"
struct __anonstruct_bus_params_t_46___8 {
   signal_t *a[32] ;
   signal_t *d[8] ;
   signal_t *ncs ;
   signal_t *nwe ;
   signal_t *noe ;
};
#line 39 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ppc440gx_ebc8.c"
typedef struct __anonstruct_bus_params_t_46___8 bus_params_t___10;
#line 37 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ppc405ep.c"
struct __anonstruct_bus_params_t_46___9 {
   signal_t *a[32] ;
   signal_t *d[16] ;
   signal_t *ncs ;
   signal_t *nwe ;
   signal_t *noe ;
};
#line 37 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ppc405ep.c"
typedef struct __anonstruct_bus_params_t_46___9 bus_params_t___11;
#line 43 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/mpc824x.c"
struct __anonstruct_bus_params_t_46___10 {
   int boot_nfoe ;
   int boot_sdma1 ;
   uint32_t last_adr ;
   signal_t *ar[23] ;
   signal_t *nrcs0 ;
   signal_t *nwe ;
   signal_t *nfoe ;
   signal_t *d[32] ;
};
#line 43 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/mpc824x.c"
typedef struct __anonstruct_bus_params_t_46___10 bus_params_t___12;
#line 48 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/mpc5200.c"
struct __anonstruct_bus_params_t_46___11 {
   uint32_t last_adr ;
   signal_t *ad[32] ;
   signal_t *ncs[6] ;
   signal_t *nwe ;
   signal_t *noe ;
   signal_t *ata_iso ;
   signal_t *nale ;
   int muxed ;
   int lpc_num_ad ;
   int lpc_num_d ;
};
#line 48 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/mpc5200.c"
typedef struct __anonstruct_bus_params_t_46___11 bus_params_t___13;
#line 54 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/lh7a400.c"
struct __anonstruct_bus_params_t_46___12 {
   signal_t *a[24] ;
   signal_t *d[32] ;
   signal_t *ncs[4] ;
   signal_t *nwe ;
   signal_t *noe ;
   signal_t *width[2] ;
};
#line 54 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/lh7a400.c"
typedef struct __anonstruct_bus_params_t_46___12 bus_params_t___14;
#line 88 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/jopcyc.c"
struct __anonstruct_component_t_47___0 {
   ctype_t ctype ;
   char *cname ;
   signal_t *a[19] ;
   signal_t *d[16] ;
   signal_t *ncs ;
   signal_t *noe ;
   signal_t *nwe ;
   signal_t *nlb ;
   signal_t *nub ;
   signal_t *ncs2 ;
   signal_t *nrdy ;
};
#line 88 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/jopcyc.c"
typedef struct __anonstruct_component_t_47___0 component_t___0;
#line 102 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/jopcyc.c"
struct __anonstruct_bus_params_t_48___0 {
   uint32_t last_addr ;
   component_t___0 rama ;
   component_t___0 ramb ;
   component_t___0 flash ;
   signal_t *ser_txd ;
   signal_t *ser_nrts ;
   signal_t *ser_rxd ;
   signal_t *ser_ncts ;
};
#line 102 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/jopcyc.c"
typedef struct __anonstruct_bus_params_t_48___0 bus_params_t___15;
#line 40 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ixp425.c"
struct __anonstruct_bus_params_t_46___13 {
   signal_t *ex_cs[8] ;
   signal_t *ex_addr[24] ;
   signal_t *ex_data[16] ;
   signal_t *ex_wr ;
   signal_t *ex_rd ;
};
#line 40 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ixp425.c"
typedef struct __anonstruct_bus_params_t_46___13 bus_params_t___16;
#line 40 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/h7202.c"
struct __anonstruct_bus_params_t_42 {
   signal_t *a[25] ;
   signal_t *d[32] ;
   signal_t *nRCS[4] ;
   signal_t *nRWE[4] ;
   signal_t *nROE ;
};
#line 40 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/h7202.c"
typedef struct __anonstruct_bus_params_t_42 bus_params_t___17;
#line 50 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 47 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/fjmem.c"
struct block_param {
   struct block_param *next ;
   uint16_t num ;
   uint32_t start ;
   uint32_t end ;
   uint16_t addr_width ;
   uint16_t data_width ;
   uint8_t ashift ;
};
#line 55 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/fjmem.c"
typedef struct block_param block_param_t;
#line 57 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/fjmem.c"
struct block_desc {
   uint16_t reg_len ;
   uint16_t instr_pos ;
   uint16_t block_pos ;
   uint16_t block_len ;
   uint16_t addr_pos ;
   uint16_t addr_len ;
   uint16_t data_pos ;
   uint16_t data_len ;
   block_param_t *blocks ;
};
#line 68 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/fjmem.c"
typedef struct block_desc block_desc_t;
#line 70 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/fjmem.c"
struct __anonstruct_bus_params_t_47___0 {
   uint32_t last_addr ;
   data_register *fjmem_reg ;
   block_desc_t block_desc ;
};
#line 70 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/fjmem.c"
typedef struct __anonstruct_bus_params_t_47___0 bus_params_t___18;
#line 52 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ejtag_dma.c"
struct __anonstruct_bus_params_t_46___14 {
   uint32_t impcode ;
};
#line 52 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ejtag_dma.c"
typedef struct __anonstruct_bus_params_t_46___14 bus_params_t___19;
#line 45 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ejtag.c"
struct __anonstruct_bus_params_t_46___15 {
   uint32_t impcode ;
   uint16_t adr_hi ;
};
#line 45 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ejtag.c"
typedef struct __anonstruct_bus_params_t_46___15 bus_params_t___20;
#line 33 "../../include/bus.h"
struct __anonstruct_buses_t_42 {
   int len ;
   bus_t **buses ;
};
#line 33 "../../include/bus.h"
typedef struct __anonstruct_buses_t_42 buses_t;
#line 43 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bscoach.c"
struct __anonstruct_bus_params_t_46___16 {
   uint32_t last_adr ;
   signal_t *adr[15] ;
   signal_t *d[8] ;
   signal_t *deca ;
   signal_t *decb ;
   signal_t *decc ;
   signal_t *we_f ;
   signal_t *oe_f ;
};
#line 43 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bscoach.c"
typedef struct __anonstruct_bus_params_t_46___16 bus_params_t___21;
#line 40 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf561_ezkit.c"
struct __anonstruct_bus_params_t_46___17 {
   signal_t *ams[4] ;
   signal_t *addr[24] ;
   signal_t *abe[4] ;
   signal_t *data[32] ;
   signal_t *awe ;
   signal_t *aoe ;
   signal_t *sras ;
   signal_t *scas ;
   signal_t *sms[4] ;
   signal_t *swe ;
};
#line 40 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf561_ezkit.c"
typedef struct __anonstruct_bus_params_t_46___17 bus_params_t___22;
#line 39 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf548_ezkit.c"
struct __anonstruct_bus_params_t_46___18 {
   signal_t *ams[4] ;
   signal_t *addr[24] ;
   signal_t *data[16] ;
   signal_t *awe ;
   signal_t *are ;
   signal_t *aoe ;
   signal_t *dcs0 ;
   signal_t *nce ;
};
#line 39 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf548_ezkit.c"
typedef struct __anonstruct_bus_params_t_46___18 bus_params_t___23;
#line 40 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf537_stamp.c"
struct __anonstruct_bus_params_t_46___19 {
   signal_t *ams[4] ;
   signal_t *addr[19] ;
   signal_t *data[16] ;
   signal_t *abe[2] ;
   signal_t *awe ;
   signal_t *are ;
   signal_t *sras ;
   signal_t *scas ;
   signal_t *sms ;
   signal_t *swe ;
};
#line 40 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf537_stamp.c"
typedef struct __anonstruct_bus_params_t_46___19 bus_params_t___24;
#line 44 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/avr32.c"
struct __anonstruct_bus_params_t_46___20 {
   unsigned int mode ;
   unsigned int slave ;
   uint32_t addr_mask ;
   uint32_t rwcs_rd ;
   uint32_t rwcs_wr ;
};
#line 44 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/avr32.c"
typedef struct __anonstruct_bus_params_t_46___20 bus_params_t___25;
#line 44 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/au1500.c"
struct __anonstruct_bus_params_t_46___21 {
   signal_t *rad[32] ;
   signal_t *nrcs[4] ;
   signal_t *nrwe ;
   signal_t *nroe ;
   signal_t *rd[32] ;
};
#line 44 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/au1500.c"
typedef struct __anonstruct_bus_params_t_46___21 bus_params_t___26;
#line 68 "../../include/flash/cfi.h"
struct cfi_query_identification_string {
   uint16_t pri_id_code ;
   void *pri_vendor_tbl ;
   uint16_t alt_id_code ;
   void *alt_vendor_tbl ;
};
#line 68 "../../include/flash/cfi.h"
typedef struct cfi_query_identification_string cfi_query_identification_string_t;
#line 103 "../../include/flash/cfi.h"
struct cfi_query_system_interface_information {
   uint16_t vcc_min_wev ;
   uint16_t vcc_max_wev ;
   uint16_t vpp_min_wev ;
   uint16_t vpp_max_wev ;
   uint32_t typ_single_write_timeout ;
   uint32_t typ_buffer_write_timeout ;
   uint32_t typ_block_erase_timeout ;
   uint32_t typ_chip_erase_timeout ;
   uint32_t max_single_write_timeout ;
   uint32_t max_buffer_write_timeout ;
   uint32_t max_block_erase_timeout ;
   uint32_t max_chip_erase_timeout ;
};
#line 103 "../../include/flash/cfi.h"
typedef struct cfi_query_system_interface_information cfi_query_system_interface_information_t;
#line 128
struct cfi_erase_block_region;
#line 128 "../../include/flash/cfi.h"
typedef struct cfi_erase_block_region cfi_erase_block_region_t;
#line 130 "../../include/flash/cfi.h"
struct cfi_device_geometry {
   uint32_t device_size ;
   uint16_t device_interface ;
   uint32_t max_bytes_write ;
   uint8_t number_of_erase_regions ;
   cfi_erase_block_region_t *erase_block_regions ;
};
#line 130 "../../include/flash/cfi.h"
typedef struct cfi_device_geometry cfi_device_geometry_t;
#line 138 "../../include/flash/cfi.h"
struct cfi_erase_block_region {
   uint32_t erase_block_size ;
   uint32_t number_of_erase_blocks ;
};
#line 155 "../../include/flash/cfi.h"
struct cfi_query_structure {
   cfi_query_identification_string_t identification_string ;
   cfi_query_system_interface_information_t system_interface_info ;
   cfi_device_geometry_t device_geometry ;
};
#line 155 "../../include/flash/cfi.h"
typedef struct cfi_query_structure cfi_query_structure_t;
#line 46 "../../include/flash.h"
struct __anonstruct_cfi_chip_t_41 {
   int width ;
   cfi_query_structure_t cfi ;
};
#line 46 "../../include/flash.h"
typedef struct __anonstruct_cfi_chip_t_41 cfi_chip_t;
#line 51 "../../include/flash.h"
struct __anonstruct_cfi_array_t_42 {
   bus_t *bus ;
   uint32_t address ;
   int bus_width ;
   cfi_chip_t **cfi_chips ;
};
#line 51 "../../include/flash.h"
typedef struct __anonstruct_cfi_array_t_42 cfi_array_t;
#line 63 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/jedec.c"
struct mtd_erase_region_info {
   uint32_t offset ;
   uint32_t erasesize ;
   uint32_t numblocks ;
};
#line 69 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/jedec.c"
struct amd_flash_info {
   int const   mfr_id ;
   int const   dev_id ;
   char const   *name ;
   long const   size ;
   uint8_t const   interface_width ;
   int const   as_method ;
   int const   numeraseregions ;
   struct mtd_erase_region_info  const  regions[4] ;
};
#line 63 "../../include/flash.h"
struct __anonstruct_flash_driver_t_44 {
   unsigned int bus_width ;
   char const   *name ;
   char const   *description ;
   int (*autodetect)(cfi_array_t *cfi_array ) ;
   void (*print_info)(cfi_array_t *cfi_array ) ;
   int (*erase_block)(cfi_array_t *cfi_array , uint32_t adr ) ;
   int (*unlock_block)(cfi_array_t *cfi_array , uint32_t adr ) ;
   int (*program)(cfi_array_t *cfi_array , uint32_t adr , uint32_t *buffer , int count ) ;
   void (*readarray)(cfi_array_t *cfi_array ) ;
};
#line 63 "../../include/flash.h"
typedef struct __anonstruct_flash_driver_t_44 flash_driver_t;
#line 187 "../../include/flash/cfi.h"
struct amd_pri_extened_query_structure {
   uint8_t major_version ;
   uint8_t minor_version ;
   uint8_t address_sensitive_unlock ;
   uint8_t erase_suspend ;
   uint8_t sector_protect ;
   uint8_t sector_temporary_unprotect ;
   uint8_t sector_protect_scheme ;
   uint8_t simultaneous_operation ;
   uint8_t burst_mode_type ;
   uint8_t page_mode_type ;
   uint16_t acc_min ;
   uint16_t acc_max ;
   uint8_t top_bottom_sector_flag ;
   uint8_t program_suspend ;
   uint8_t unlock_bypass ;
   uint8_t secsi_sector_size ;
   uint8_t embedded_hwrst_timeout_max ;
   uint8_t non_embedded_hwrst_timeout_max ;
   uint8_t erase_suspend_timeout_max ;
   uint8_t program_suspend_timeout_max ;
   uint8_t bank_organization ;
   uint8_t bank_region_info[0] ;
};
#line 187 "../../include/flash/cfi.h"
typedef struct amd_pri_extened_query_structure amd_pri_extened_query_structure_t;
#line 69 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/amd_flash.c"
struct __anonstruct_var_forced_detection_49 {
   unsigned long flash ;
   unsigned short algorithm ;
   unsigned short unlock_bypass ;
};
#line 31 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/generic.h"
struct __anonstruct_generic_params_t_21 {
   int signals ;
};
#line 31 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/generic.h"
typedef struct __anonstruct_generic_params_t_21 generic_params_t;
#line 80 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/wiggler.c"
struct __anonstruct_wiggler_params_t_44 {
   int signals ;
   int trst_lvl ;
   int srst_act ;
   int srst_inact ;
   int tms_act ;
   int tms_inact ;
   int tck_act ;
   int tck_inact ;
   int tdi_act ;
   int tdi_inact ;
   int tdo_act ;
   int tdo_inact ;
   int trst_act ;
   int trst_inact ;
   int unused_bits ;
};
#line 80 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/wiggler.c"
typedef struct __anonstruct_wiggler_params_t_44 wiggler_params_t;
#line 47 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/parport/ppdev.c"
struct port_node_t;
#line 47 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/parport/ppdev.c"
typedef struct port_node_t port_node_t;
#line 49 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/parport/ppdev.c"
struct port_node_t {
   parport_t *port ;
   port_node_t *next ;
};
#line 56 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/parport/ppdev.c"
struct __anonstruct_ppdev_params_t_44 {
   char *portname ;
   int fd ;
};
#line 56 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/parport/ppdev.c"
typedef struct __anonstruct_ppdev_params_t_44 ppdev_params_t;
#line 121 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/parport/direct.c"
struct __anonstruct_direct_params_t_41 {
   unsigned int port ;
};
#line 121 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/parport/direct.c"
typedef struct __anonstruct_direct_params_t_41 direct_params_t;
#line 45 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/detect.c"
struct id_record {
   char name[20] ;
   char fullname[100] ;
};
#line 35 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/cmd_xfer.h"
struct cx_cmd;
#line 35 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/cmd_xfer.h"
typedef struct cx_cmd cx_cmd_t;
#line 36 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/cmd_xfer.h"
struct cx_cmd {
   cx_cmd_t *next ;
   uint32_t buf_len ;
   uint32_t buf_pos ;
   uint8_t *buf ;
   uint32_t to_recv ;
};
#line 44 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/cmd_xfer.h"
struct cx_cmd_root {
   cx_cmd_t *first ;
   cx_cmd_t *last ;
};
#line 48 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/cmd_xfer.h"
typedef struct cx_cmd_root cx_cmd_root_t;
#line 158 "/usr/include/bits/types.h"
typedef int __clockid_t;
#line 92 "/usr/include/time.h"
typedef __clockid_t clockid_t;
#line 39 "../../include/cmd.h"
struct __anonstruct_cmd_t_26 {
   char *name ;
   char *desc ;
   void (*help)(void) ;
   int (*run)(chain_t *chain , char **params ) ;
};
#line 39 "../../include/cmd.h"
typedef struct __anonstruct_cmd_t_26 cmd_t;
#line 323 "/usr/lib/gcc/i486-linux-gnu/4.4.3/include/stddef.h"
typedef int wchar_t;
#line 106 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 460 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 145 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 146
extern struct _IO_FILE *stdout ;
#line 147
extern struct _IO_FILE *stderr ;
#line 214
extern int fclose(FILE *__stream ) ;
#line 249
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 333
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 682
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 688
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 799
extern  __attribute__((__nothrow__)) void clearerr(FILE *__stream ) ;
#line 803
extern  __attribute__((__nothrow__)) int ferror(FILE *__stream ) ;
#line 831
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 64 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
#line 127
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 130
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncpy)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
#line 135
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcat)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
#line 397
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 43 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 148 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 471
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 485
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
#line 488
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 289 "vhdl_flex.c"
void vhdlrestart(FILE *input_file , yyscan_t yyscanner ) ;
#line 290
void vhdl_switch_to_buffer(YY_BUFFER_STATE new_buffer , yyscan_t yyscanner ) ;
#line 291
YY_BUFFER_STATE vhdl_create_buffer(FILE *file , int size , yyscan_t yyscanner ) ;
#line 292
void vhdl_delete_buffer(YY_BUFFER_STATE b , yyscan_t yyscanner ) ;
#line 293
void vhdl_flush_buffer(YY_BUFFER_STATE b , yyscan_t yyscanner ) ;
#line 294
void vhdlpush_buffer_state(YY_BUFFER_STATE new_buffer , yyscan_t yyscanner ) ;
#line 295
void vhdlpop_buffer_state(yyscan_t yyscanner ) ;
#line 297
static void vhdlensure_buffer_stack(yyscan_t yyscanner ) ;
#line 298
static void vhdl_load_buffer_state(yyscan_t yyscanner ) ;
#line 299
static void vhdl_init_buffer(YY_BUFFER_STATE b , FILE *file , yyscan_t yyscanner ) ;
#line 303
YY_BUFFER_STATE vhdl_scan_buffer(char *base , yy_size_t size , yyscan_t yyscanner ) ;
#line 304
YY_BUFFER_STATE vhdl_scan_string(char const   *yystr , yyscan_t yyscanner ) ;
#line 305
YY_BUFFER_STATE vhdl_scan_bytes(char const   *yybytes , int _yybytes_len , yyscan_t yyscanner ) ;
#line 307
void *vhdlalloc(yy_size_t size , yyscan_t yyscanner ) ;
#line 308
void *vhdlrealloc(void *ptr , yy_size_t size , yyscan_t yyscanner ) ;
#line 309
void vhdlfree(void *ptr , yyscan_t yyscanner ) ;
#line 343
static yy_state_type yy_get_previous_state(yyscan_t yyscanner ) ;
#line 344
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state , yyscan_t yyscanner ) ;
#line 345
static int yy_get_next_buffer(yyscan_t yyscanner ) ;
#line 346
static void yy_fatal_error(char const   *msg , yyscan_t yyscanner ) ;
#line 367 "vhdl_flex.c"
static flex_int16_t const   yy_acclist[463]  = 
#line 367
  {      (flex_int16_t const   )0,      (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )72, 
        (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )72, 
        (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )83, 
        (flex_int16_t const   )81,      (flex_int16_t const   )82,      (flex_int16_t const   )72,      (flex_int16_t const   )82, 
        (flex_int16_t const   )63,      (flex_int16_t const   )82,      (flex_int16_t const   )82,      (flex_int16_t const   )79, 
        (flex_int16_t const   )82,      (flex_int16_t const   )70,      (flex_int16_t const   )82,      (flex_int16_t const   )65, 
        (flex_int16_t const   )82,      (flex_int16_t const   )66,      (flex_int16_t const   )82,      (flex_int16_t const   )82, 
        (flex_int16_t const   )64,      (flex_int16_t const   )82,      (flex_int16_t const   )81,      (flex_int16_t const   )82, 
        (flex_int16_t const   )67,      (flex_int16_t const   )82,      (flex_int16_t const   )74,      (flex_int16_t const   )77, 
        (flex_int16_t const   )82,      (flex_int16_t const   )77,      (flex_int16_t const   )82,      (flex_int16_t const   )68, 
        (flex_int16_t const   )82,      (flex_int16_t const   )80,      (flex_int16_t const   )82,      (flex_int16_t const   )82, 
        (flex_int16_t const   )75,      (flex_int16_t const   )82,      (flex_int16_t const   )75,      (flex_int16_t const   )82, 
        (flex_int16_t const   )75,      (flex_int16_t const   )82,      (flex_int16_t const   )75,      (flex_int16_t const   )82, 
        (flex_int16_t const   )75,      (flex_int16_t const   )82,      (flex_int16_t const   )75,      (flex_int16_t const   )82, 
        (flex_int16_t const   )75,      (flex_int16_t const   )82,      (flex_int16_t const   )75,      (flex_int16_t const   )82, 
        (flex_int16_t const   )75,      (flex_int16_t const   )82,      (flex_int16_t const   )75,      (flex_int16_t const   )82, 
        (flex_int16_t const   )75,      (flex_int16_t const   )82,      (flex_int16_t const   )75,      (flex_int16_t const   )82, 
        (flex_int16_t const   )75,      (flex_int16_t const   )82,      (flex_int16_t const   )75,      (flex_int16_t const   )82, 
        (flex_int16_t const   )75,      (flex_int16_t const   )82,      (flex_int16_t const   )75,      (flex_int16_t const   )82, 
        (flex_int16_t const   )74,      (flex_int16_t const   )75,      (flex_int16_t const   )82,      (flex_int16_t const   )75, 
        (flex_int16_t const   )82,      (flex_int16_t const   )75,      (flex_int16_t const   )82,      (flex_int16_t const   )75, 
        (flex_int16_t const   )82,      (flex_int16_t const   )75,      (flex_int16_t const   )82,      (flex_int16_t const   )62, 
        (flex_int16_t const   )75,      (flex_int16_t const   )82,      (flex_int16_t const   )75,      (flex_int16_t const   )82, 
        (flex_int16_t const   )75,      (flex_int16_t const   )82,      (flex_int16_t const   )75,      (flex_int16_t const   )82, 
        (flex_int16_t const   )75,      (flex_int16_t const   )82,      (flex_int16_t const   )75,      (flex_int16_t const   )82, 
        (flex_int16_t const   )75,      (flex_int16_t const   )82,      (flex_int16_t const   )75,      (flex_int16_t const   )82, 
        (flex_int16_t const   )75,      (flex_int16_t const   )82,      (flex_int16_t const   )75,      (flex_int16_t const   )82, 
        (flex_int16_t const   )59,      (flex_int16_t const   )74,      (flex_int16_t const   )75,      (flex_int16_t const   )82, 
        (flex_int16_t const   )75,      (flex_int16_t const   )82,      (flex_int16_t const   )72,      (flex_int16_t const   )76, 
        (flex_int16_t const   )73,      (flex_int16_t const   )74,      (flex_int16_t const   )77,      (flex_int16_t const   )77, 
        (flex_int16_t const   )74,      (flex_int16_t const   )71,      (flex_int16_t const   )69,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )19,      (flex_int16_t const   )75,      (flex_int16_t const   )6, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )11, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )26, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )74,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )19,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )19,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )55, 
        (flex_int16_t const   )75,      (flex_int16_t const   )56,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )73, 
        (flex_int16_t const   )10,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )24,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )9,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )17,      (flex_int16_t const   )75,      (flex_int16_t const   )20,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )4,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )20,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )58,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )61,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )57,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )29,      (flex_int16_t const   )75, 
        (flex_int16_t const   )18,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )2, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )14,      (flex_int16_t const   )75,      (flex_int16_t const   )30,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )60,      (flex_int16_t const   )75,      (flex_int16_t const   )78,      (flex_int16_t const   )33, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )15,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )21,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )35, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )48,      (flex_int16_t const   )75, 
        (flex_int16_t const   )46,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )40, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )22,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )27,      (flex_int16_t const   )75,      (flex_int16_t const   )1,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )32,      (flex_int16_t const   )75, 
        (flex_int16_t const   )16,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )8, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )51, 
        (flex_int16_t const   )75,      (flex_int16_t const   )53,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )52,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )3, 
        (flex_int16_t const   )75,      (flex_int16_t const   )23,      (flex_int16_t const   )75,      (flex_int16_t const   )28, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )31,      (flex_int16_t const   )75,      (flex_int16_t const   )44, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )41, 
        (flex_int16_t const   )75,      (flex_int16_t const   )42,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )54,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )7, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )34, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )43,      (flex_int16_t const   )75, 
        (flex_int16_t const   )45,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )49, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )5,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )36,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )50,      (flex_int16_t const   )75,      (flex_int16_t const   )25,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )47,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )38, 
        (flex_int16_t const   )75,      (flex_int16_t const   )39,      (flex_int16_t const   )75,      (flex_int16_t const   )37, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )13,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )12,      (flex_int16_t const   )75};
#line 422 "vhdl_flex.c"
static flex_int16_t const   yy_accept[353]  = 
#line 422
  {      (flex_int16_t const   )0,      (flex_int16_t const   )1,      (flex_int16_t const   )2,      (flex_int16_t const   )3, 
        (flex_int16_t const   )4,      (flex_int16_t const   )5,      (flex_int16_t const   )6,      (flex_int16_t const   )7, 
        (flex_int16_t const   )8,      (flex_int16_t const   )9,      (flex_int16_t const   )10,      (flex_int16_t const   )11, 
        (flex_int16_t const   )12,      (flex_int16_t const   )14,      (flex_int16_t const   )16,      (flex_int16_t const   )18, 
        (flex_int16_t const   )19,      (flex_int16_t const   )21,      (flex_int16_t const   )23,      (flex_int16_t const   )25, 
        (flex_int16_t const   )27,      (flex_int16_t const   )28,      (flex_int16_t const   )30,      (flex_int16_t const   )32, 
        (flex_int16_t const   )34,      (flex_int16_t const   )37,      (flex_int16_t const   )39,      (flex_int16_t const   )41, 
        (flex_int16_t const   )43,      (flex_int16_t const   )44,      (flex_int16_t const   )46,      (flex_int16_t const   )48, 
        (flex_int16_t const   )50,      (flex_int16_t const   )52,      (flex_int16_t const   )54,      (flex_int16_t const   )56, 
        (flex_int16_t const   )58,      (flex_int16_t const   )60,      (flex_int16_t const   )62,      (flex_int16_t const   )64, 
        (flex_int16_t const   )66,      (flex_int16_t const   )68,      (flex_int16_t const   )70,      (flex_int16_t const   )72, 
        (flex_int16_t const   )74,      (flex_int16_t const   )76,      (flex_int16_t const   )79,      (flex_int16_t const   )81, 
        (flex_int16_t const   )83,      (flex_int16_t const   )85,      (flex_int16_t const   )87,      (flex_int16_t const   )90, 
        (flex_int16_t const   )92,      (flex_int16_t const   )94,      (flex_int16_t const   )96,      (flex_int16_t const   )98, 
        (flex_int16_t const   )100,      (flex_int16_t const   )102,      (flex_int16_t const   )104,      (flex_int16_t const   )106, 
        (flex_int16_t const   )108,      (flex_int16_t const   )112,      (flex_int16_t const   )114,      (flex_int16_t const   )115, 
        (flex_int16_t const   )115,      (flex_int16_t const   )116,      (flex_int16_t const   )117,      (flex_int16_t const   )117, 
        (flex_int16_t const   )119,      (flex_int16_t const   )120,      (flex_int16_t const   )121,      (flex_int16_t const   )122, 
        (flex_int16_t const   )123,      (flex_int16_t const   )124,      (flex_int16_t const   )125,      (flex_int16_t const   )126, 
        (flex_int16_t const   )127,      (flex_int16_t const   )128,      (flex_int16_t const   )129,      (flex_int16_t const   )130, 
        (flex_int16_t const   )131,      (flex_int16_t const   )132,      (flex_int16_t const   )133,      (flex_int16_t const   )134, 
        (flex_int16_t const   )135,      (flex_int16_t const   )136,      (flex_int16_t const   )137,      (flex_int16_t const   )139, 
        (flex_int16_t const   )141,      (flex_int16_t const   )142,      (flex_int16_t const   )143,      (flex_int16_t const   )145, 
        (flex_int16_t const   )146,      (flex_int16_t const   )147,      (flex_int16_t const   )148,      (flex_int16_t const   )149, 
        (flex_int16_t const   )150,      (flex_int16_t const   )151,      (flex_int16_t const   )152,      (flex_int16_t const   )153, 
        (flex_int16_t const   )154,      (flex_int16_t const   )155,      (flex_int16_t const   )157,      (flex_int16_t const   )158, 
        (flex_int16_t const   )159,      (flex_int16_t const   )160,      (flex_int16_t const   )162,      (flex_int16_t const   )163, 
        (flex_int16_t const   )164,      (flex_int16_t const   )165,      (flex_int16_t const   )167,      (flex_int16_t const   )168, 
        (flex_int16_t const   )169,      (flex_int16_t const   )170,      (flex_int16_t const   )171,      (flex_int16_t const   )172, 
        (flex_int16_t const   )174,      (flex_int16_t const   )175,      (flex_int16_t const   )177,      (flex_int16_t const   )179, 
        (flex_int16_t const   )180,      (flex_int16_t const   )181,      (flex_int16_t const   )182,      (flex_int16_t const   )183, 
        (flex_int16_t const   )184,      (flex_int16_t const   )184,      (flex_int16_t const   )186,      (flex_int16_t const   )187, 
        (flex_int16_t const   )188,      (flex_int16_t const   )190,      (flex_int16_t const   )191,      (flex_int16_t const   )192, 
        (flex_int16_t const   )193,      (flex_int16_t const   )194,      (flex_int16_t const   )195,      (flex_int16_t const   )196, 
        (flex_int16_t const   )197,      (flex_int16_t const   )199,      (flex_int16_t const   )200,      (flex_int16_t const   )201, 
        (flex_int16_t const   )202,      (flex_int16_t const   )203,      (flex_int16_t const   )204,      (flex_int16_t const   )206, 
        (flex_int16_t const   )208,      (flex_int16_t const   )209,      (flex_int16_t const   )210,      (flex_int16_t const   )211, 
        (flex_int16_t const   )212,      (flex_int16_t const   )213,      (flex_int16_t const   )214,      (flex_int16_t const   )215, 
        (flex_int16_t const   )216,      (flex_int16_t const   )217,      (flex_int16_t const   )218,      (flex_int16_t const   )219, 
        (flex_int16_t const   )220,      (flex_int16_t const   )221,      (flex_int16_t const   )223,      (flex_int16_t const   )224, 
        (flex_int16_t const   )225,      (flex_int16_t const   )226,      (flex_int16_t const   )227,      (flex_int16_t const   )228, 
        (flex_int16_t const   )229,      (flex_int16_t const   )231,      (flex_int16_t const   )232,      (flex_int16_t const   )234, 
        (flex_int16_t const   )235,      (flex_int16_t const   )236,      (flex_int16_t const   )238,      (flex_int16_t const   )239, 
        (flex_int16_t const   )240,      (flex_int16_t const   )242,      (flex_int16_t const   )243,      (flex_int16_t const   )243, 
        (flex_int16_t const   )244,      (flex_int16_t const   )245,      (flex_int16_t const   )246,      (flex_int16_t const   )248, 
        (flex_int16_t const   )250,      (flex_int16_t const   )251,      (flex_int16_t const   )252,      (flex_int16_t const   )253, 
        (flex_int16_t const   )254,      (flex_int16_t const   )255,      (flex_int16_t const   )256,      (flex_int16_t const   )257, 
        (flex_int16_t const   )258,      (flex_int16_t const   )259,      (flex_int16_t const   )260,      (flex_int16_t const   )261, 
        (flex_int16_t const   )262,      (flex_int16_t const   )263,      (flex_int16_t const   )265,      (flex_int16_t const   )266, 
        (flex_int16_t const   )267,      (flex_int16_t const   )268,      (flex_int16_t const   )269,      (flex_int16_t const   )270, 
        (flex_int16_t const   )271,      (flex_int16_t const   )272,      (flex_int16_t const   )274,      (flex_int16_t const   )276, 
        (flex_int16_t const   )277,      (flex_int16_t const   )278,      (flex_int16_t const   )279,      (flex_int16_t const   )280, 
        (flex_int16_t const   )281,      (flex_int16_t const   )282,      (flex_int16_t const   )283,      (flex_int16_t const   )284, 
        (flex_int16_t const   )285,      (flex_int16_t const   )286,      (flex_int16_t const   )287,      (flex_int16_t const   )288, 
        (flex_int16_t const   )290,      (flex_int16_t const   )290,      (flex_int16_t const   )291,      (flex_int16_t const   )293, 
        (flex_int16_t const   )294,      (flex_int16_t const   )295,      (flex_int16_t const   )296,      (flex_int16_t const   )297, 
        (flex_int16_t const   )298,      (flex_int16_t const   )299,      (flex_int16_t const   )300,      (flex_int16_t const   )301, 
        (flex_int16_t const   )303,      (flex_int16_t const   )304,      (flex_int16_t const   )306,      (flex_int16_t const   )307, 
        (flex_int16_t const   )308,      (flex_int16_t const   )309,      (flex_int16_t const   )310,      (flex_int16_t const   )311, 
        (flex_int16_t const   )313,      (flex_int16_t const   )314,      (flex_int16_t const   )315,      (flex_int16_t const   )316, 
        (flex_int16_t const   )317,      (flex_int16_t const   )318,      (flex_int16_t const   )320,      (flex_int16_t const   )322, 
        (flex_int16_t const   )323,      (flex_int16_t const   )325,      (flex_int16_t const   )326,      (flex_int16_t const   )327, 
        (flex_int16_t const   )328,      (flex_int16_t const   )329,      (flex_int16_t const   )330,      (flex_int16_t const   )331, 
        (flex_int16_t const   )332,      (flex_int16_t const   )333,      (flex_int16_t const   )334,      (flex_int16_t const   )335, 
        (flex_int16_t const   )336,      (flex_int16_t const   )338,      (flex_int16_t const   )339,      (flex_int16_t const   )340, 
        (flex_int16_t const   )342,      (flex_int16_t const   )344,      (flex_int16_t const   )345,      (flex_int16_t const   )346, 
        (flex_int16_t const   )347,      (flex_int16_t const   )348,      (flex_int16_t const   )349,      (flex_int16_t const   )350, 
        (flex_int16_t const   )352,      (flex_int16_t const   )354,      (flex_int16_t const   )355,      (flex_int16_t const   )357, 
        (flex_int16_t const   )358,      (flex_int16_t const   )359,      (flex_int16_t const   )360,      (flex_int16_t const   )361, 
        (flex_int16_t const   )362,      (flex_int16_t const   )363,      (flex_int16_t const   )365,      (flex_int16_t const   )367, 
        (flex_int16_t const   )368,      (flex_int16_t const   )370,      (flex_int16_t const   )371,      (flex_int16_t const   )372, 
        (flex_int16_t const   )373,      (flex_int16_t const   )374,      (flex_int16_t const   )375,      (flex_int16_t const   )377, 
        (flex_int16_t const   )379,      (flex_int16_t const   )381,      (flex_int16_t const   )382,      (flex_int16_t const   )383, 
        (flex_int16_t const   )384,      (flex_int16_t const   )385,      (flex_int16_t const   )387,      (flex_int16_t const   )389, 
        (flex_int16_t const   )390,      (flex_int16_t const   )391,      (flex_int16_t const   )393,      (flex_int16_t const   )395, 
        (flex_int16_t const   )396,      (flex_int16_t const   )397,      (flex_int16_t const   )399,      (flex_int16_t const   )400, 
        (flex_int16_t const   )401,      (flex_int16_t const   )402,      (flex_int16_t const   )403,      (flex_int16_t const   )405, 
        (flex_int16_t const   )406,      (flex_int16_t const   )407,      (flex_int16_t const   )409,      (flex_int16_t const   )410, 
        (flex_int16_t const   )412,      (flex_int16_t const   )414,      (flex_int16_t const   )415,      (flex_int16_t const   )417, 
        (flex_int16_t const   )418,      (flex_int16_t const   )420,      (flex_int16_t const   )421,      (flex_int16_t const   )422, 
        (flex_int16_t const   )424,      (flex_int16_t const   )425,      (flex_int16_t const   )426,      (flex_int16_t const   )427, 
        (flex_int16_t const   )428,      (flex_int16_t const   )430,      (flex_int16_t const   )432,      (flex_int16_t const   )433, 
        (flex_int16_t const   )434,      (flex_int16_t const   )435,      (flex_int16_t const   )436,      (flex_int16_t const   )437, 
        (flex_int16_t const   )438,      (flex_int16_t const   )439,      (flex_int16_t const   )440,      (flex_int16_t const   )441, 
        (flex_int16_t const   )442,      (flex_int16_t const   )443,      (flex_int16_t const   )444,      (flex_int16_t const   )445, 
        (flex_int16_t const   )446,      (flex_int16_t const   )448,      (flex_int16_t const   )449,      (flex_int16_t const   )450, 
        (flex_int16_t const   )451,      (flex_int16_t const   )453,      (flex_int16_t const   )455,      (flex_int16_t const   )457, 
        (flex_int16_t const   )458,      (flex_int16_t const   )460,      (flex_int16_t const   )461,      (flex_int16_t const   )463, 
        (flex_int16_t const   )463};
#line 465 "vhdl_flex.c"
static flex_int32_t const   yy_ec[256]  = 
#line 465
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )2,      (flex_int32_t const   )2,      (flex_int32_t const   )3,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )2,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )2,      (flex_int32_t const   )1,      (flex_int32_t const   )4,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )5,      (flex_int32_t const   )6, 
        (flex_int32_t const   )7,      (flex_int32_t const   )8,      (flex_int32_t const   )9,      (flex_int32_t const   )10, 
        (flex_int32_t const   )11,      (flex_int32_t const   )12,      (flex_int32_t const   )13,      (flex_int32_t const   )1, 
        (flex_int32_t const   )14,      (flex_int32_t const   )15,      (flex_int32_t const   )16,      (flex_int32_t const   )17, 
        (flex_int32_t const   )18,      (flex_int32_t const   )19,      (flex_int32_t const   )18,      (flex_int32_t const   )18, 
        (flex_int32_t const   )18,      (flex_int32_t const   )18,      (flex_int32_t const   )20,      (flex_int32_t const   )21, 
        (flex_int32_t const   )22,      (flex_int32_t const   )23,      (flex_int32_t const   )24,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )25,      (flex_int32_t const   )26,      (flex_int32_t const   )27, 
        (flex_int32_t const   )28,      (flex_int32_t const   )29,      (flex_int32_t const   )30,      (flex_int32_t const   )31, 
        (flex_int32_t const   )32,      (flex_int32_t const   )33,      (flex_int32_t const   )34,      (flex_int32_t const   )35, 
        (flex_int32_t const   )36,      (flex_int32_t const   )37,      (flex_int32_t const   )38,      (flex_int32_t const   )39, 
        (flex_int32_t const   )40,      (flex_int32_t const   )34,      (flex_int32_t const   )41,      (flex_int32_t const   )42, 
        (flex_int32_t const   )43,      (flex_int32_t const   )44,      (flex_int32_t const   )45,      (flex_int32_t const   )46, 
        (flex_int32_t const   )47,      (flex_int32_t const   )48,      (flex_int32_t const   )49,      (flex_int32_t const   )9, 
        (flex_int32_t const   )1,      (flex_int32_t const   )9,      (flex_int32_t const   )1,      (flex_int32_t const   )50, 
        (flex_int32_t const   )1,      (flex_int32_t const   )51,      (flex_int32_t const   )52,      (flex_int32_t const   )53, 
        (flex_int32_t const   )54,      (flex_int32_t const   )55,      (flex_int32_t const   )56,      (flex_int32_t const   )57, 
        (flex_int32_t const   )58,      (flex_int32_t const   )59,      (flex_int32_t const   )34,      (flex_int32_t const   )60, 
        (flex_int32_t const   )61,      (flex_int32_t const   )62,      (flex_int32_t const   )63,      (flex_int32_t const   )64, 
        (flex_int32_t const   )65,      (flex_int32_t const   )34,      (flex_int32_t const   )66,      (flex_int32_t const   )67, 
        (flex_int32_t const   )68,      (flex_int32_t const   )69,      (flex_int32_t const   )70,      (flex_int32_t const   )71, 
        (flex_int32_t const   )72,      (flex_int32_t const   )73,      (flex_int32_t const   )74,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1};
#line 497 "vhdl_flex.c"
static flex_int32_t const   yy_meta[75]  = 
#line 497
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )2, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )3,      (flex_int32_t const   )3, 
        (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3, 
        (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3, 
        (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3, 
        (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3, 
        (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3, 
        (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3, 
        (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3, 
        (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3, 
        (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3, 
        (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3, 
        (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3, 
        (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3, 
        (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3};
#line 509 "vhdl_flex.c"
static flex_int16_t const   yy_base[355]  = 
#line 509
  {      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )49,      (flex_int16_t const   )51,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )100,      (flex_int16_t const   )0,      (flex_int16_t const   )522, 
        (flex_int16_t const   )823,      (flex_int16_t const   )489,      (flex_int16_t const   )823,      (flex_int16_t const   )475, 
        (flex_int16_t const   )823,      (flex_int16_t const   )823,      (flex_int16_t const   )823,      (flex_int16_t const   )823, 
        (flex_int16_t const   )823,      (flex_int16_t const   )823,      (flex_int16_t const   )414,      (flex_int16_t const   )823, 
        (flex_int16_t const   )103,      (flex_int16_t const   )78,      (flex_int16_t const   )385,      (flex_int16_t const   )823, 
        (flex_int16_t const   )353,      (flex_int16_t const   )95,      (flex_int16_t const   )118,      (flex_int16_t const   )50, 
        (flex_int16_t const   )42,      (flex_int16_t const   )48,      (flex_int16_t const   )58,      (flex_int16_t const   )99, 
        (flex_int16_t const   )0,      (flex_int16_t const   )138,      (flex_int16_t const   )140,      (flex_int16_t const   )102, 
        (flex_int16_t const   )156,      (flex_int16_t const   )161,      (flex_int16_t const   )150,      (flex_int16_t const   )169, 
        (flex_int16_t const   )45,      (flex_int16_t const   )177,      (flex_int16_t const   )188,      (flex_int16_t const   )167, 
        (flex_int16_t const   )187,      (flex_int16_t const   )214,      (flex_int16_t const   )0,      (flex_int16_t const   )204, 
        (flex_int16_t const   )236,      (flex_int16_t const   )213,      (flex_int16_t const   )236,      (flex_int16_t const   )254, 
        (flex_int16_t const   )256,      (flex_int16_t const   )257,      (flex_int16_t const   )286,      (flex_int16_t const   )103, 
        (flex_int16_t const   )310,      (flex_int16_t const   )168,      (flex_int16_t const   )362,      (flex_int16_t const   )318, 
        (flex_int16_t const   )823,      (flex_int16_t const   )0,      (flex_int16_t const   )317,      (flex_int16_t const   )325, 
        (flex_int16_t const   )333,      (flex_int16_t const   )313,      (flex_int16_t const   )823,      (flex_int16_t const   )823, 
        (flex_int16_t const   )0,      (flex_int16_t const   )63,      (flex_int16_t const   )170,      (flex_int16_t const   )170, 
        (flex_int16_t const   )191,      (flex_int16_t const   )236,      (flex_int16_t const   )172,      (flex_int16_t const   )211, 
        (flex_int16_t const   )233,      (flex_int16_t const   )239,      (flex_int16_t const   )247,      (flex_int16_t const   )325, 
        (flex_int16_t const   )260,      (flex_int16_t const   )318,      (flex_int16_t const   )319,      (flex_int16_t const   )0, 
        (flex_int16_t const   )321,      (flex_int16_t const   )315,      (flex_int16_t const   )0,      (flex_int16_t const   )319, 
        (flex_int16_t const   )336,      (flex_int16_t const   )317,      (flex_int16_t const   )328,      (flex_int16_t const   )328, 
        (flex_int16_t const   )329,      (flex_int16_t const   )346,      (flex_int16_t const   )343,      (flex_int16_t const   )347, 
        (flex_int16_t const   )350,      (flex_int16_t const   )0,      (flex_int16_t const   )327,      (flex_int16_t const   )338, 
        (flex_int16_t const   )351,      (flex_int16_t const   )390,      (flex_int16_t const   )379,      (flex_int16_t const   )359, 
        (flex_int16_t const   )371,      (flex_int16_t const   )371,      (flex_int16_t const   )373,      (flex_int16_t const   )373, 
        (flex_int16_t const   )384,      (flex_int16_t const   )377,      (flex_int16_t const   )375,      (flex_int16_t const   )381, 
        (flex_int16_t const   )396,      (flex_int16_t const   )381,      (flex_int16_t const   )387,      (flex_int16_t const   )392, 
        (flex_int16_t const   )394,      (flex_int16_t const   )404,      (flex_int16_t const   )407,      (flex_int16_t const   )0, 
        (flex_int16_t const   )449,      (flex_int16_t const   )0,      (flex_int16_t const   )425,      (flex_int16_t const   )416, 
        (flex_int16_t const   )266,      (flex_int16_t const   )411,      (flex_int16_t const   )428,      (flex_int16_t const   )433, 
        (flex_int16_t const   )431,      (flex_int16_t const   )434,      (flex_int16_t const   )429,      (flex_int16_t const   )434, 
        (flex_int16_t const   )0,      (flex_int16_t const   )441,      (flex_int16_t const   )435,      (flex_int16_t const   )446, 
        (flex_int16_t const   )436,      (flex_int16_t const   )446,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )448,      (flex_int16_t const   )443,      (flex_int16_t const   )263,      (flex_int16_t const   )445, 
        (flex_int16_t const   )456,      (flex_int16_t const   )459,      (flex_int16_t const   )453,      (flex_int16_t const   )455, 
        (flex_int16_t const   )259,      (flex_int16_t const   )465,      (flex_int16_t const   )460,      (flex_int16_t const   )470, 
        (flex_int16_t const   )478,      (flex_int16_t const   )0,      (flex_int16_t const   )476,      (flex_int16_t const   )484, 
        (flex_int16_t const   )477,      (flex_int16_t const   )470,      (flex_int16_t const   )483,      (flex_int16_t const   )492, 
        (flex_int16_t const   )483,      (flex_int16_t const   )493,      (flex_int16_t const   )0,      (flex_int16_t const   )498, 
        (flex_int16_t const   )500,      (flex_int16_t const   )0,      (flex_int16_t const   )504,      (flex_int16_t const   )492, 
        (flex_int16_t const   )0,      (flex_int16_t const   )495,      (flex_int16_t const   )548,      (flex_int16_t const   )488, 
        (flex_int16_t const   )509,      (flex_int16_t const   )501,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )255,      (flex_int16_t const   )514,      (flex_int16_t const   )212,      (flex_int16_t const   )506, 
        (flex_int16_t const   )507,      (flex_int16_t const   )508,      (flex_int16_t const   )525,      (flex_int16_t const   )529, 
        (flex_int16_t const   )529,      (flex_int16_t const   )548,      (flex_int16_t const   )552,      (flex_int16_t const   )545, 
        (flex_int16_t const   )544,      (flex_int16_t const   )0,      (flex_int16_t const   )539,      (flex_int16_t const   )550, 
        (flex_int16_t const   )542,      (flex_int16_t const   )559,      (flex_int16_t const   )241,      (flex_int16_t const   )548, 
        (flex_int16_t const   )539,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )547, 
        (flex_int16_t const   )554,      (flex_int16_t const   )549,      (flex_int16_t const   )548,      (flex_int16_t const   )551, 
        (flex_int16_t const   )552,      (flex_int16_t const   )550,      (flex_int16_t const   )555,      (flex_int16_t const   )556, 
        (flex_int16_t const   )559,      (flex_int16_t const   )569,      (flex_int16_t const   )573,      (flex_int16_t const   )0, 
        (flex_int16_t const   )621,      (flex_int16_t const   )627,      (flex_int16_t const   )0,      (flex_int16_t const   )596, 
        (flex_int16_t const   )595,      (flex_int16_t const   )598,      (flex_int16_t const   )588,      (flex_int16_t const   )597, 
        (flex_int16_t const   )606,      (flex_int16_t const   )594,      (flex_int16_t const   )599,      (flex_int16_t const   )0, 
        (flex_int16_t const   )616,      (flex_int16_t const   )0,      (flex_int16_t const   )620,      (flex_int16_t const   )621, 
        (flex_int16_t const   )628,      (flex_int16_t const   )634,      (flex_int16_t const   )627,      (flex_int16_t const   )0, 
        (flex_int16_t const   )633,      (flex_int16_t const   )627,      (flex_int16_t const   )234,      (flex_int16_t const   )633, 
        (flex_int16_t const   )626,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )628, 
        (flex_int16_t const   )0,      (flex_int16_t const   )630,      (flex_int16_t const   )624,      (flex_int16_t const   )627, 
        (flex_int16_t const   )195,      (flex_int16_t const   )628,      (flex_int16_t const   )630,      (flex_int16_t const   )632, 
        (flex_int16_t const   )647,      (flex_int16_t const   )635,      (flex_int16_t const   )653,      (flex_int16_t const   )635, 
        (flex_int16_t const   )0,      (flex_int16_t const   )645,      (flex_int16_t const   )646,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )662,      (flex_int16_t const   )668,      (flex_int16_t const   )671, 
        (flex_int16_t const   )676,      (flex_int16_t const   )663,      (flex_int16_t const   )660,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )222,      (flex_int16_t const   )0,      (flex_int16_t const   )681, 
        (flex_int16_t const   )676,      (flex_int16_t const   )688,      (flex_int16_t const   )685,      (flex_int16_t const   )118, 
        (flex_int16_t const   )683,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )675, 
        (flex_int16_t const   )0,      (flex_int16_t const   )676,      (flex_int16_t const   )677,      (flex_int16_t const   )678, 
        (flex_int16_t const   )694,      (flex_int16_t const   )686,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )695,      (flex_int16_t const   )152,      (flex_int16_t const   )696, 
        (flex_int16_t const   )182,      (flex_int16_t const   )0,      (flex_int16_t const   )691,      (flex_int16_t const   )697, 
        (flex_int16_t const   )134,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )696, 
        (flex_int16_t const   )691,      (flex_int16_t const   )0,      (flex_int16_t const   )709,      (flex_int16_t const   )702, 
        (flex_int16_t const   )719,      (flex_int16_t const   )713,      (flex_int16_t const   )0,      (flex_int16_t const   )128, 
        (flex_int16_t const   )711,      (flex_int16_t const   )0,      (flex_int16_t const   )98,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )716,      (flex_int16_t const   )0,      (flex_int16_t const   )718, 
        (flex_int16_t const   )0,      (flex_int16_t const   )721,      (flex_int16_t const   )725,      (flex_int16_t const   )0, 
        (flex_int16_t const   )725,      (flex_int16_t const   )724,      (flex_int16_t const   )121,      (flex_int16_t const   )730, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )727,      (flex_int16_t const   )716, 
        (flex_int16_t const   )729,      (flex_int16_t const   )116,      (flex_int16_t const   )735,      (flex_int16_t const   )739, 
        (flex_int16_t const   )738,      (flex_int16_t const   )740,      (flex_int16_t const   )93,      (flex_int16_t const   )731, 
        (flex_int16_t const   )742,      (flex_int16_t const   )35,      (flex_int16_t const   )744,      (flex_int16_t const   )525, 
        (flex_int16_t const   )0,      (flex_int16_t const   )745,      (flex_int16_t const   )747,      (flex_int16_t const   )754, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )764, 
        (flex_int16_t const   )0,      (flex_int16_t const   )751,      (flex_int16_t const   )0,      (flex_int16_t const   )823, 
        (flex_int16_t const   )816,      (flex_int16_t const   )77,      (flex_int16_t const   )819};
#line 552 "vhdl_flex.c"
static flex_int16_t const   yy_def[355]  = 
#line 552
  {      (flex_int16_t const   )0,      (flex_int16_t const   )351,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )9,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )352, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )351,      (flex_int16_t const   )352, 
        (flex_int16_t const   )351,      (flex_int16_t const   )354,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )354, 
        (flex_int16_t const   )351,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )351,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )0, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351};
#line 595 "vhdl_flex.c"
static flex_int16_t const   yy_nxt[898]  = 
#line 595
  {      (flex_int16_t const   )0,      (flex_int16_t const   )12,      (flex_int16_t const   )13,      (flex_int16_t const   )14, 
        (flex_int16_t const   )15,      (flex_int16_t const   )16,      (flex_int16_t const   )17,      (flex_int16_t const   )18, 
        (flex_int16_t const   )19,      (flex_int16_t const   )20,      (flex_int16_t const   )12,      (flex_int16_t const   )21, 
        (flex_int16_t const   )22,      (flex_int16_t const   )23,      (flex_int16_t const   )24,      (flex_int16_t const   )24, 
        (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25, 
        (flex_int16_t const   )26,      (flex_int16_t const   )27,      (flex_int16_t const   )28,      (flex_int16_t const   )12, 
        (flex_int16_t const   )20,      (flex_int16_t const   )29,      (flex_int16_t const   )30,      (flex_int16_t const   )31, 
        (flex_int16_t const   )32,      (flex_int16_t const   )33,      (flex_int16_t const   )34,      (flex_int16_t const   )35, 
        (flex_int16_t const   )36,      (flex_int16_t const   )37,      (flex_int16_t const   )36,      (flex_int16_t const   )36, 
        (flex_int16_t const   )38,      (flex_int16_t const   )36,      (flex_int16_t const   )36,      (flex_int16_t const   )39, 
        (flex_int16_t const   )40,      (flex_int16_t const   )41,      (flex_int16_t const   )42,      (flex_int16_t const   )43, 
        (flex_int16_t const   )44,      (flex_int16_t const   )36,      (flex_int16_t const   )36,      (flex_int16_t const   )45, 
        (flex_int16_t const   )36,      (flex_int16_t const   )36,      (flex_int16_t const   )20,      (flex_int16_t const   )29, 
        (flex_int16_t const   )30,      (flex_int16_t const   )31,      (flex_int16_t const   )32,      (flex_int16_t const   )33, 
        (flex_int16_t const   )34,      (flex_int16_t const   )35,      (flex_int16_t const   )36,      (flex_int16_t const   )37, 
        (flex_int16_t const   )36,      (flex_int16_t const   )38,      (flex_int16_t const   )36,      (flex_int16_t const   )36, 
        (flex_int16_t const   )39,      (flex_int16_t const   )40,      (flex_int16_t const   )41,      (flex_int16_t const   )42, 
        (flex_int16_t const   )43,      (flex_int16_t const   )44,      (flex_int16_t const   )36,      (flex_int16_t const   )36, 
        (flex_int16_t const   )45,      (flex_int16_t const   )36,      (flex_int16_t const   )36,      (flex_int16_t const   )46, 
        (flex_int16_t const   )47,      (flex_int16_t const   )46,      (flex_int16_t const   )47,      (flex_int16_t const   )80, 
        (flex_int16_t const   )72,      (flex_int16_t const   )82,      (flex_int16_t const   )48,      (flex_int16_t const   )84, 
        (flex_int16_t const   )48,      (flex_int16_t const   )342,      (flex_int16_t const   )83,      (flex_int16_t const   )104, 
        (flex_int16_t const   )49,      (flex_int16_t const   )81,      (flex_int16_t const   )49,      (flex_int16_t const   )66, 
        (flex_int16_t const   )68,      (flex_int16_t const   )68,      (flex_int16_t const   )68,      (flex_int16_t const   )68, 
        (flex_int16_t const   )68,      (flex_int16_t const   )68,      (flex_int16_t const   )50,      (flex_int16_t const   )125, 
        (flex_int16_t const   )50,      (flex_int16_t const   )46,      (flex_int16_t const   )47,      (flex_int16_t const   )46, 
        (flex_int16_t const   )47,      (flex_int16_t const   )80,      (flex_int16_t const   )82,      (flex_int16_t const   )339, 
        (flex_int16_t const   )48,      (flex_int16_t const   )84,      (flex_int16_t const   )48,      (flex_int16_t const   )83, 
        (flex_int16_t const   )104,      (flex_int16_t const   )49,      (flex_int16_t const   )81,      (flex_int16_t const   )49, 
        (flex_int16_t const   )66,      (flex_int16_t const   )67,      (flex_int16_t const   )67,      (flex_int16_t const   )68, 
        (flex_int16_t const   )68,      (flex_int16_t const   )68,      (flex_int16_t const   )68,      (flex_int16_t const   )50, 
        (flex_int16_t const   )125,      (flex_int16_t const   )50,      (flex_int16_t const   )51,      (flex_int16_t const   )52, 
        (flex_int16_t const   )85,      (flex_int16_t const   )53,      (flex_int16_t const   )334,      (flex_int16_t const   )73, 
        (flex_int16_t const   )90,      (flex_int16_t const   )54,      (flex_int16_t const   )297,      (flex_int16_t const   )298, 
        (flex_int16_t const   )74,      (flex_int16_t const   )329,      (flex_int16_t const   )75,      (flex_int16_t const   )55, 
        (flex_int16_t const   )56,      (flex_int16_t const   )57,      (flex_int16_t const   )58,      (flex_int16_t const   )121, 
        (flex_int16_t const   )59,      (flex_int16_t const   )104,      (flex_int16_t const   )91,      (flex_int16_t const   )60, 
        (flex_int16_t const   )322,      (flex_int16_t const   )61,      (flex_int16_t const   )69,      (flex_int16_t const   )76, 
        (flex_int16_t const   )51,      (flex_int16_t const   )52,      (flex_int16_t const   )85,      (flex_int16_t const   )53, 
        (flex_int16_t const   )73,      (flex_int16_t const   )77,      (flex_int16_t const   )90,      (flex_int16_t const   )54, 
        (flex_int16_t const   )78,      (flex_int16_t const   )74,      (flex_int16_t const   )79,      (flex_int16_t const   )75, 
        (flex_int16_t const   )55,      (flex_int16_t const   )56,      (flex_int16_t const   )57,      (flex_int16_t const   )58, 
        (flex_int16_t const   )121,      (flex_int16_t const   )59,      (flex_int16_t const   )104,      (flex_int16_t const   )91, 
        (flex_int16_t const   )60,      (flex_int16_t const   )88,      (flex_int16_t const   )61,      (flex_int16_t const   )69, 
        (flex_int16_t const   )86,      (flex_int16_t const   )76,      (flex_int16_t const   )320,      (flex_int16_t const   )89, 
        (flex_int16_t const   )87,      (flex_int16_t const   )92,      (flex_int16_t const   )77,      (flex_int16_t const   )98, 
        (flex_int16_t const   )313,      (flex_int16_t const   )78,      (flex_int16_t const   )96,      (flex_int16_t const   )79, 
        (flex_int16_t const   )93,      (flex_int16_t const   )94,      (flex_int16_t const   )97,      (flex_int16_t const   )105, 
        (flex_int16_t const   )105,      (flex_int16_t const   )99,      (flex_int16_t const   )100,      (flex_int16_t const   )95, 
        (flex_int16_t const   )80,      (flex_int16_t const   )122,      (flex_int16_t const   )310,      (flex_int16_t const   )88, 
        (flex_int16_t const   )131,      (flex_int16_t const   )86,      (flex_int16_t const   )308,      (flex_int16_t const   )107, 
        (flex_int16_t const   )89,      (flex_int16_t const   )87,      (flex_int16_t const   )108,      (flex_int16_t const   )92, 
        (flex_int16_t const   )101,      (flex_int16_t const   )98,      (flex_int16_t const   )102,      (flex_int16_t const   )126, 
        (flex_int16_t const   )96,      (flex_int16_t const   )127,      (flex_int16_t const   )93,      (flex_int16_t const   )94, 
        (flex_int16_t const   )97,      (flex_int16_t const   )103,      (flex_int16_t const   )99,      (flex_int16_t const   )100, 
        (flex_int16_t const   )95,      (flex_int16_t const   )106,      (flex_int16_t const   )80,      (flex_int16_t const   )122, 
        (flex_int16_t const   )105,      (flex_int16_t const   )109,      (flex_int16_t const   )131,      (flex_int16_t const   )77, 
        (flex_int16_t const   )107,      (flex_int16_t const   )87,      (flex_int16_t const   )78,      (flex_int16_t const   )108, 
        (flex_int16_t const   )79,      (flex_int16_t const   )101,      (flex_int16_t const   )128,      (flex_int16_t const   )102, 
        (flex_int16_t const   )126,      (flex_int16_t const   )112,      (flex_int16_t const   )127,      (flex_int16_t const   )292, 
        (flex_int16_t const   )110,      (flex_int16_t const   )132,      (flex_int16_t const   )103,      (flex_int16_t const   )77, 
        (flex_int16_t const   )90,      (flex_int16_t const   )276,      (flex_int16_t const   )78,      (flex_int16_t const   )106, 
        (flex_int16_t const   )79,      (flex_int16_t const   )105,      (flex_int16_t const   )109,      (flex_int16_t const   )83, 
        (flex_int16_t const   )77,      (flex_int16_t const   )269,      (flex_int16_t const   )87,      (flex_int16_t const   )78, 
        (flex_int16_t const   )238,      (flex_int16_t const   )79,      (flex_int16_t const   )111,      (flex_int16_t const   )128, 
        (flex_int16_t const   )114,      (flex_int16_t const   )113,      (flex_int16_t const   )223,      (flex_int16_t const   )112, 
        (flex_int16_t const   )129,      (flex_int16_t const   )80,      (flex_int16_t const   )110,      (flex_int16_t const   )132, 
        (flex_int16_t const   )77,      (flex_int16_t const   )133,      (flex_int16_t const   )90,      (flex_int16_t const   )78, 
        (flex_int16_t const   )107,      (flex_int16_t const   )79,      (flex_int16_t const   )115,      (flex_int16_t const   )108, 
        (flex_int16_t const   )83,      (flex_int16_t const   )134,      (flex_int16_t const   )87,      (flex_int16_t const   )130, 
        (flex_int16_t const   )110,      (flex_int16_t const   )92,      (flex_int16_t const   )96,      (flex_int16_t const   )111, 
        (flex_int16_t const   )90,      (flex_int16_t const   )114,      (flex_int16_t const   )97,      (flex_int16_t const   )113, 
        (flex_int16_t const   )93,      (flex_int16_t const   )117,      (flex_int16_t const   )129,      (flex_int16_t const   )80, 
        (flex_int16_t const   )116,      (flex_int16_t const   )135,      (flex_int16_t const   )133,      (flex_int16_t const   )118, 
        (flex_int16_t const   )138,      (flex_int16_t const   )107,      (flex_int16_t const   )111,      (flex_int16_t const   )115, 
        (flex_int16_t const   )108,      (flex_int16_t const   )119,      (flex_int16_t const   )134,      (flex_int16_t const   )87, 
        (flex_int16_t const   )130,      (flex_int16_t const   )221,      (flex_int16_t const   )110,      (flex_int16_t const   )92, 
        (flex_int16_t const   )96,      (flex_int16_t const   )198,      (flex_int16_t const   )90,      (flex_int16_t const   )120, 
        (flex_int16_t const   )97,      (flex_int16_t const   )192,      (flex_int16_t const   )93,      (flex_int16_t const   )117, 
        (flex_int16_t const   )177,      (flex_int16_t const   )116,      (flex_int16_t const   )135,      (flex_int16_t const   )98, 
        (flex_int16_t const   )118,      (flex_int16_t const   )138,      (flex_int16_t const   )64,      (flex_int16_t const   )111, 
        (flex_int16_t const   )105,      (flex_int16_t const   )105,      (flex_int16_t const   )119,      (flex_int16_t const   )69, 
        (flex_int16_t const   )69,      (flex_int16_t const   )99,      (flex_int16_t const   )100,      (flex_int16_t const   )124, 
        (flex_int16_t const   )124,      (flex_int16_t const   )124,      (flex_int16_t const   )124,      (flex_int16_t const   )124, 
        (flex_int16_t const   )124,      (flex_int16_t const   )120,      (flex_int16_t const   )66,      (flex_int16_t const   )67, 
        (flex_int16_t const   )67,      (flex_int16_t const   )68,      (flex_int16_t const   )68,      (flex_int16_t const   )68, 
        (flex_int16_t const   )68,      (flex_int16_t const   )98,      (flex_int16_t const   )66,      (flex_int16_t const   )68, 
        (flex_int16_t const   )68,      (flex_int16_t const   )68,      (flex_int16_t const   )68,      (flex_int16_t const   )68, 
        (flex_int16_t const   )68,      (flex_int16_t const   )136,      (flex_int16_t const   )99,      (flex_int16_t const   )100, 
        (flex_int16_t const   )139,      (flex_int16_t const   )105,      (flex_int16_t const   )140,      (flex_int16_t const   )141, 
        (flex_int16_t const   )69,      (flex_int16_t const   )142,      (flex_int16_t const   )143,      (flex_int16_t const   )144, 
        (flex_int16_t const   )62,      (flex_int16_t const   )145,      (flex_int16_t const   )146,      (flex_int16_t const   )149, 
        (flex_int16_t const   )137,      (flex_int16_t const   )147,      (flex_int16_t const   )148,      (flex_int16_t const   )155, 
        (flex_int16_t const   )69,      (flex_int16_t const   )150,      (flex_int16_t const   )151,      (flex_int16_t const   )152, 
        (flex_int16_t const   )154,      (flex_int16_t const   )71,      (flex_int16_t const   )156,      (flex_int16_t const   )136, 
        (flex_int16_t const   )157,      (flex_int16_t const   )139,      (flex_int16_t const   )105,      (flex_int16_t const   )140, 
        (flex_int16_t const   )141,      (flex_int16_t const   )69,      (flex_int16_t const   )142,      (flex_int16_t const   )143, 
        (flex_int16_t const   )153,      (flex_int16_t const   )144,      (flex_int16_t const   )145,      (flex_int16_t const   )146, 
        (flex_int16_t const   )149,      (flex_int16_t const   )137,      (flex_int16_t const   )147,      (flex_int16_t const   )148, 
        (flex_int16_t const   )155,      (flex_int16_t const   )69,      (flex_int16_t const   )159,      (flex_int16_t const   )150, 
        (flex_int16_t const   )151,      (flex_int16_t const   )152,      (flex_int16_t const   )154,      (flex_int16_t const   )156, 
        (flex_int16_t const   )105,      (flex_int16_t const   )105,      (flex_int16_t const   )157,      (flex_int16_t const   )158, 
        (flex_int16_t const   )70,      (flex_int16_t const   )160,      (flex_int16_t const   )140,      (flex_int16_t const   )161, 
        (flex_int16_t const   )165,      (flex_int16_t const   )153,      (flex_int16_t const   )162,      (flex_int16_t const   )163, 
        (flex_int16_t const   )164,      (flex_int16_t const   )166,      (flex_int16_t const   )167,      (flex_int16_t const   )146, 
        (flex_int16_t const   )140,      (flex_int16_t const   )161,      (flex_int16_t const   )128,      (flex_int16_t const   )159, 
        (flex_int16_t const   )168,      (flex_int16_t const   )169,      (flex_int16_t const   )65,      (flex_int16_t const   )128, 
        (flex_int16_t const   )147,      (flex_int16_t const   )148,      (flex_int16_t const   )170,      (flex_int16_t const   )171, 
        (flex_int16_t const   )172,      (flex_int16_t const   )158,      (flex_int16_t const   )160,      (flex_int16_t const   )140, 
        (flex_int16_t const   )161,      (flex_int16_t const   )105,      (flex_int16_t const   )165,      (flex_int16_t const   )162, 
        (flex_int16_t const   )163,      (flex_int16_t const   )164,      (flex_int16_t const   )166,      (flex_int16_t const   )167, 
        (flex_int16_t const   )146,      (flex_int16_t const   )140,      (flex_int16_t const   )161,      (flex_int16_t const   )128, 
        (flex_int16_t const   )173,      (flex_int16_t const   )168,      (flex_int16_t const   )175,      (flex_int16_t const   )169, 
        (flex_int16_t const   )128,      (flex_int16_t const   )147,      (flex_int16_t const   )148,      (flex_int16_t const   )170, 
        (flex_int16_t const   )171,      (flex_int16_t const   )176,      (flex_int16_t const   )172,      (flex_int16_t const   )178, 
        (flex_int16_t const   )179,      (flex_int16_t const   )181,      (flex_int16_t const   )105,      (flex_int16_t const   )124, 
        (flex_int16_t const   )124,      (flex_int16_t const   )124,      (flex_int16_t const   )124,      (flex_int16_t const   )124, 
        (flex_int16_t const   )124,      (flex_int16_t const   )180,      (flex_int16_t const   )182,      (flex_int16_t const   )183, 
        (flex_int16_t const   )184,      (flex_int16_t const   )173,      (flex_int16_t const   )185,      (flex_int16_t const   )187, 
        (flex_int16_t const   )175,      (flex_int16_t const   )186,      (flex_int16_t const   )174,      (flex_int16_t const   )64, 
        (flex_int16_t const   )188,      (flex_int16_t const   )189,      (flex_int16_t const   )176,      (flex_int16_t const   )190, 
        (flex_int16_t const   )178,      (flex_int16_t const   )191,      (flex_int16_t const   )179,      (flex_int16_t const   )181, 
        (flex_int16_t const   )193,      (flex_int16_t const   )194,      (flex_int16_t const   )195,      (flex_int16_t const   )62, 
        (flex_int16_t const   )196,      (flex_int16_t const   )197,      (flex_int16_t const   )180,      (flex_int16_t const   )182, 
        (flex_int16_t const   )183,      (flex_int16_t const   )184,      (flex_int16_t const   )199,      (flex_int16_t const   )201, 
        (flex_int16_t const   )185,      (flex_int16_t const   )187,      (flex_int16_t const   )186,      (flex_int16_t const   )200, 
        (flex_int16_t const   )174,      (flex_int16_t const   )188,      (flex_int16_t const   )189,      (flex_int16_t const   )202, 
        (flex_int16_t const   )190,      (flex_int16_t const   )203,      (flex_int16_t const   )191,      (flex_int16_t const   )204, 
        (flex_int16_t const   )207,      (flex_int16_t const   )193,      (flex_int16_t const   )206,      (flex_int16_t const   )194, 
        (flex_int16_t const   )195,      (flex_int16_t const   )196,      (flex_int16_t const   )197,      (flex_int16_t const   )183, 
        (flex_int16_t const   )205,      (flex_int16_t const   )208,      (flex_int16_t const   )351,      (flex_int16_t const   )209, 
        (flex_int16_t const   )199,      (flex_int16_t const   )201,      (flex_int16_t const   )210,      (flex_int16_t const   )211, 
        (flex_int16_t const   )200,      (flex_int16_t const   )212,      (flex_int16_t const   )213,      (flex_int16_t const   )351, 
        (flex_int16_t const   )214,      (flex_int16_t const   )202,      (flex_int16_t const   )215,      (flex_int16_t const   )203, 
        (flex_int16_t const   )218,      (flex_int16_t const   )204,      (flex_int16_t const   )207,      (flex_int16_t const   )206, 
        (flex_int16_t const   )344,      (flex_int16_t const   )345,      (flex_int16_t const   )219,      (flex_int16_t const   )222, 
        (flex_int16_t const   )183,      (flex_int16_t const   )205,      (flex_int16_t const   )220,      (flex_int16_t const   )208, 
        (flex_int16_t const   )209,      (flex_int16_t const   )224,      (flex_int16_t const   )225,      (flex_int16_t const   )226, 
        (flex_int16_t const   )210,      (flex_int16_t const   )211,      (flex_int16_t const   )227,      (flex_int16_t const   )212, 
        (flex_int16_t const   )213,      (flex_int16_t const   )214,      (flex_int16_t const   )216,      (flex_int16_t const   )215, 
        (flex_int16_t const   )216,      (flex_int16_t const   )218,      (flex_int16_t const   )217,      (flex_int16_t const   )217, 
        (flex_int16_t const   )217,      (flex_int16_t const   )217,      (flex_int16_t const   )217,      (flex_int16_t const   )217, 
        (flex_int16_t const   )219,      (flex_int16_t const   )222,      (flex_int16_t const   )228,      (flex_int16_t const   )220, 
        (flex_int16_t const   )229,      (flex_int16_t const   )230,      (flex_int16_t const   )224,      (flex_int16_t const   )225, 
        (flex_int16_t const   )226,      (flex_int16_t const   )231,      (flex_int16_t const   )232,      (flex_int16_t const   )235, 
        (flex_int16_t const   )227,      (flex_int16_t const   )233,      (flex_int16_t const   )234,      (flex_int16_t const   )236, 
        (flex_int16_t const   )237,      (flex_int16_t const   )351,      (flex_int16_t const   )239,      (flex_int16_t const   )240, 
        (flex_int16_t const   )241,      (flex_int16_t const   )242,      (flex_int16_t const   )243,      (flex_int16_t const   )244, 
        (flex_int16_t const   )245,      (flex_int16_t const   )246,      (flex_int16_t const   )247,      (flex_int16_t const   )228, 
        (flex_int16_t const   )248,      (flex_int16_t const   )229,      (flex_int16_t const   )249,      (flex_int16_t const   )230, 
        (flex_int16_t const   )245,      (flex_int16_t const   )250,      (flex_int16_t const   )251,      (flex_int16_t const   )231, 
        (flex_int16_t const   )232,      (flex_int16_t const   )235,      (flex_int16_t const   )233,      (flex_int16_t const   )234, 
        (flex_int16_t const   )236,      (flex_int16_t const   )252,      (flex_int16_t const   )237,      (flex_int16_t const   )239, 
        (flex_int16_t const   )240,      (flex_int16_t const   )241,      (flex_int16_t const   )242,      (flex_int16_t const   )243, 
        (flex_int16_t const   )244,      (flex_int16_t const   )245,      (flex_int16_t const   )246,      (flex_int16_t const   )247, 
        (flex_int16_t const   )351,      (flex_int16_t const   )248,      (flex_int16_t const   )253,      (flex_int16_t const   )249, 
        (flex_int16_t const   )254,      (flex_int16_t const   )245,      (flex_int16_t const   )250,      (flex_int16_t const   )255, 
        (flex_int16_t const   )251,      (flex_int16_t const   )256,      (flex_int16_t const   )257,      (flex_int16_t const   )258, 
        (flex_int16_t const   )351,      (flex_int16_t const   )259,      (flex_int16_t const   )252,      (flex_int16_t const   )217, 
        (flex_int16_t const   )217,      (flex_int16_t const   )217,      (flex_int16_t const   )217,      (flex_int16_t const   )217, 
        (flex_int16_t const   )217,      (flex_int16_t const   )217,      (flex_int16_t const   )217,      (flex_int16_t const   )217, 
        (flex_int16_t const   )217,      (flex_int16_t const   )217,      (flex_int16_t const   )217,      (flex_int16_t const   )260, 
        (flex_int16_t const   )253,      (flex_int16_t const   )261,      (flex_int16_t const   )254,      (flex_int16_t const   )262, 
        (flex_int16_t const   )263,      (flex_int16_t const   )255,      (flex_int16_t const   )256,      (flex_int16_t const   )264, 
        (flex_int16_t const   )257,      (flex_int16_t const   )258,      (flex_int16_t const   )259,      (flex_int16_t const   )265, 
        (flex_int16_t const   )266,      (flex_int16_t const   )267,      (flex_int16_t const   )351,      (flex_int16_t const   )268, 
        (flex_int16_t const   )270,      (flex_int16_t const   )351,      (flex_int16_t const   )271,      (flex_int16_t const   )272, 
        (flex_int16_t const   )273,      (flex_int16_t const   )274,      (flex_int16_t const   )275,      (flex_int16_t const   )277, 
        (flex_int16_t const   )260,      (flex_int16_t const   )278,      (flex_int16_t const   )279,      (flex_int16_t const   )261, 
        (flex_int16_t const   )280,      (flex_int16_t const   )262,      (flex_int16_t const   )263,      (flex_int16_t const   )281, 
        (flex_int16_t const   )282,      (flex_int16_t const   )264,      (flex_int16_t const   )283,      (flex_int16_t const   )284, 
        (flex_int16_t const   )285,      (flex_int16_t const   )265,      (flex_int16_t const   )266,      (flex_int16_t const   )267, 
        (flex_int16_t const   )268,      (flex_int16_t const   )286,      (flex_int16_t const   )270,      (flex_int16_t const   )271, 
        (flex_int16_t const   )272,      (flex_int16_t const   )273,      (flex_int16_t const   )274,      (flex_int16_t const   )275, 
        (flex_int16_t const   )277,      (flex_int16_t const   )287,      (flex_int16_t const   )278,      (flex_int16_t const   )279, 
        (flex_int16_t const   )288,      (flex_int16_t const   )289,      (flex_int16_t const   )280,      (flex_int16_t const   )290, 
        (flex_int16_t const   )281,      (flex_int16_t const   )291,      (flex_int16_t const   )282,      (flex_int16_t const   )283, 
        (flex_int16_t const   )284,      (flex_int16_t const   )285,      (flex_int16_t const   )293,      (flex_int16_t const   )351, 
        (flex_int16_t const   )294,      (flex_int16_t const   )295,      (flex_int16_t const   )296,      (flex_int16_t const   )286, 
        (flex_int16_t const   )299,      (flex_int16_t const   )351,      (flex_int16_t const   )301,      (flex_int16_t const   )302, 
        (flex_int16_t const   )303,      (flex_int16_t const   )304,      (flex_int16_t const   )300,      (flex_int16_t const   )287, 
        (flex_int16_t const   )305,      (flex_int16_t const   )309,      (flex_int16_t const   )288,      (flex_int16_t const   )289, 
        (flex_int16_t const   )290,      (flex_int16_t const   )306,      (flex_int16_t const   )291,      (flex_int16_t const   )307, 
        (flex_int16_t const   )311,      (flex_int16_t const   )312,      (flex_int16_t const   )314,      (flex_int16_t const   )315, 
        (flex_int16_t const   )293,      (flex_int16_t const   )294,      (flex_int16_t const   )316,      (flex_int16_t const   )295, 
        (flex_int16_t const   )296,      (flex_int16_t const   )317,      (flex_int16_t const   )299,      (flex_int16_t const   )301, 
        (flex_int16_t const   )302,      (flex_int16_t const   )303,      (flex_int16_t const   )304,      (flex_int16_t const   )300, 
        (flex_int16_t const   )318,      (flex_int16_t const   )332,      (flex_int16_t const   )305,      (flex_int16_t const   )309, 
        (flex_int16_t const   )319,      (flex_int16_t const   )321,      (flex_int16_t const   )306,      (flex_int16_t const   )323, 
        (flex_int16_t const   )307,      (flex_int16_t const   )311,      (flex_int16_t const   )312,      (flex_int16_t const   )314, 
        (flex_int16_t const   )315,      (flex_int16_t const   )324,      (flex_int16_t const   )325,      (flex_int16_t const   )326, 
        (flex_int16_t const   )316,      (flex_int16_t const   )327,      (flex_int16_t const   )317,      (flex_int16_t const   )328, 
        (flex_int16_t const   )330,      (flex_int16_t const   )331,      (flex_int16_t const   )333,      (flex_int16_t const   )335, 
        (flex_int16_t const   )336,      (flex_int16_t const   )338,      (flex_int16_t const   )318,      (flex_int16_t const   )332, 
        (flex_int16_t const   )337,      (flex_int16_t const   )319,      (flex_int16_t const   )321,      (flex_int16_t const   )340, 
        (flex_int16_t const   )323,      (flex_int16_t const   )341,      (flex_int16_t const   )343,      (flex_int16_t const   )346, 
        (flex_int16_t const   )347,      (flex_int16_t const   )348,      (flex_int16_t const   )324,      (flex_int16_t const   )325, 
        (flex_int16_t const   )326,      (flex_int16_t const   )349,      (flex_int16_t const   )327,      (flex_int16_t const   )350, 
        (flex_int16_t const   )328,      (flex_int16_t const   )330,      (flex_int16_t const   )331,      (flex_int16_t const   )333, 
        (flex_int16_t const   )335,      (flex_int16_t const   )351,      (flex_int16_t const   )336,      (flex_int16_t const   )338, 
        (flex_int16_t const   )351,      (flex_int16_t const   )337,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )340,      (flex_int16_t const   )351,      (flex_int16_t const   )341,      (flex_int16_t const   )343, 
        (flex_int16_t const   )346,      (flex_int16_t const   )347,      (flex_int16_t const   )351,      (flex_int16_t const   )348, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )349, 
        (flex_int16_t const   )350,      (flex_int16_t const   )63,      (flex_int16_t const   )351,      (flex_int16_t const   )63, 
        (flex_int16_t const   )123,      (flex_int16_t const   )351,      (flex_int16_t const   )123,      (flex_int16_t const   )11, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351};
#line 698 "vhdl_flex.c"
static flex_int16_t const   yy_chk[898]  = 
#line 698
  {      (flex_int16_t const   )0,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )5, 
        (flex_int16_t const   )5,      (flex_int16_t const   )6,      (flex_int16_t const   )6,      (flex_int16_t const   )31, 
        (flex_int16_t const   )353,      (flex_int16_t const   )32,      (flex_int16_t const   )5,      (flex_int16_t const   )34, 
        (flex_int16_t const   )6,      (flex_int16_t const   )337,      (flex_int16_t const   )33,      (flex_int16_t const   )44, 
        (flex_int16_t const   )5,      (flex_int16_t const   )31,      (flex_int16_t const   )6,      (flex_int16_t const   )25, 
        (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25, 
        (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )5,      (flex_int16_t const   )73, 
        (flex_int16_t const   )6,      (flex_int16_t const   )5,      (flex_int16_t const   )5,      (flex_int16_t const   )6, 
        (flex_int16_t const   )6,      (flex_int16_t const   )31,      (flex_int16_t const   )32,      (flex_int16_t const   )334, 
        (flex_int16_t const   )5,      (flex_int16_t const   )34,      (flex_int16_t const   )6,      (flex_int16_t const   )33, 
        (flex_int16_t const   )44,      (flex_int16_t const   )5,      (flex_int16_t const   )31,      (flex_int16_t const   )6, 
        (flex_int16_t const   )24,      (flex_int16_t const   )24,      (flex_int16_t const   )24,      (flex_int16_t const   )24, 
        (flex_int16_t const   )24,      (flex_int16_t const   )24,      (flex_int16_t const   )24,      (flex_int16_t const   )5, 
        (flex_int16_t const   )73,      (flex_int16_t const   )6,      (flex_int16_t const   )9,      (flex_int16_t const   )9, 
        (flex_int16_t const   )35,      (flex_int16_t const   )9,      (flex_int16_t const   )329,      (flex_int16_t const   )29, 
        (flex_int16_t const   )39,      (flex_int16_t const   )9,      (flex_int16_t const   )275,      (flex_int16_t const   )275, 
        (flex_int16_t const   )29,      (flex_int16_t const   )322,      (flex_int16_t const   )29,      (flex_int16_t const   )9, 
        (flex_int16_t const   )9,      (flex_int16_t const   )9,      (flex_int16_t const   )9,      (flex_int16_t const   )59, 
        (flex_int16_t const   )9,      (flex_int16_t const   )59,      (flex_int16_t const   )39,      (flex_int16_t const   )9, 
        (flex_int16_t const   )310,      (flex_int16_t const   )9,      (flex_int16_t const   )24,      (flex_int16_t const   )30, 
        (flex_int16_t const   )9,      (flex_int16_t const   )9,      (flex_int16_t const   )35,      (flex_int16_t const   )9, 
        (flex_int16_t const   )29,      (flex_int16_t const   )30,      (flex_int16_t const   )39,      (flex_int16_t const   )9, 
        (flex_int16_t const   )30,      (flex_int16_t const   )29,      (flex_int16_t const   )30,      (flex_int16_t const   )29, 
        (flex_int16_t const   )9,      (flex_int16_t const   )9,      (flex_int16_t const   )9,      (flex_int16_t const   )9, 
        (flex_int16_t const   )59,      (flex_int16_t const   )9,      (flex_int16_t const   )59,      (flex_int16_t const   )39, 
        (flex_int16_t const   )9,      (flex_int16_t const   )38,      (flex_int16_t const   )9,      (flex_int16_t const   )24, 
        (flex_int16_t const   )37,      (flex_int16_t const   )30,      (flex_int16_t const   )307,      (flex_int16_t const   )38, 
        (flex_int16_t const   )37,      (flex_int16_t const   )40,      (flex_int16_t const   )30,      (flex_int16_t const   )42, 
        (flex_int16_t const   )296,      (flex_int16_t const   )30,      (flex_int16_t const   )41,      (flex_int16_t const   )30, 
        (flex_int16_t const   )40,      (flex_int16_t const   )40,      (flex_int16_t const   )41,      (flex_int16_t const   )45, 
        (flex_int16_t const   )45,      (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )40, 
        (flex_int16_t const   )47,      (flex_int16_t const   )61,      (flex_int16_t const   )292,      (flex_int16_t const   )38, 
        (flex_int16_t const   )78,      (flex_int16_t const   )37,      (flex_int16_t const   )290,      (flex_int16_t const   )47, 
        (flex_int16_t const   )38,      (flex_int16_t const   )37,      (flex_int16_t const   )47,      (flex_int16_t const   )40, 
        (flex_int16_t const   )43,      (flex_int16_t const   )42,      (flex_int16_t const   )43,      (flex_int16_t const   )74, 
        (flex_int16_t const   )41,      (flex_int16_t const   )75,      (flex_int16_t const   )40,      (flex_int16_t const   )40, 
        (flex_int16_t const   )41,      (flex_int16_t const   )43,      (flex_int16_t const   )42,      (flex_int16_t const   )42, 
        (flex_int16_t const   )40,      (flex_int16_t const   )46,      (flex_int16_t const   )47,      (flex_int16_t const   )61, 
        (flex_int16_t const   )45,      (flex_int16_t const   )48,      (flex_int16_t const   )78,      (flex_int16_t const   )46, 
        (flex_int16_t const   )47,      (flex_int16_t const   )48,      (flex_int16_t const   )46,      (flex_int16_t const   )47, 
        (flex_int16_t const   )46,      (flex_int16_t const   )43,      (flex_int16_t const   )76,      (flex_int16_t const   )43, 
        (flex_int16_t const   )74,      (flex_int16_t const   )51,      (flex_int16_t const   )75,      (flex_int16_t const   )269, 
        (flex_int16_t const   )49,      (flex_int16_t const   )79,      (flex_int16_t const   )43,      (flex_int16_t const   )51, 
        (flex_int16_t const   )49,      (flex_int16_t const   )248,      (flex_int16_t const   )51,      (flex_int16_t const   )46, 
        (flex_int16_t const   )51,      (flex_int16_t const   )45,      (flex_int16_t const   )48,      (flex_int16_t const   )53, 
        (flex_int16_t const   )46,      (flex_int16_t const   )238,      (flex_int16_t const   )48,      (flex_int16_t const   )46, 
        (flex_int16_t const   )198,      (flex_int16_t const   )46,      (flex_int16_t const   )49,      (flex_int16_t const   )76, 
        (flex_int16_t const   )53,      (flex_int16_t const   )52,      (flex_int16_t const   )182,      (flex_int16_t const   )51, 
        (flex_int16_t const   )77,      (flex_int16_t const   )52,      (flex_int16_t const   )49,      (flex_int16_t const   )79, 
        (flex_int16_t const   )51,      (flex_int16_t const   )80,      (flex_int16_t const   )49,      (flex_int16_t const   )51, 
        (flex_int16_t const   )52,      (flex_int16_t const   )51,      (flex_int16_t const   )54,      (flex_int16_t const   )52, 
        (flex_int16_t const   )53,      (flex_int16_t const   )81,      (flex_int16_t const   )54,      (flex_int16_t const   )77, 
        (flex_int16_t const   )55,      (flex_int16_t const   )56,      (flex_int16_t const   )57,      (flex_int16_t const   )49, 
        (flex_int16_t const   )55,      (flex_int16_t const   )53,      (flex_int16_t const   )57,      (flex_int16_t const   )52, 
        (flex_int16_t const   )56,      (flex_int16_t const   )56,      (flex_int16_t const   )77,      (flex_int16_t const   )52, 
        (flex_int16_t const   )55,      (flex_int16_t const   )82,      (flex_int16_t const   )80,      (flex_int16_t const   )56, 
        (flex_int16_t const   )84,      (flex_int16_t const   )52,      (flex_int16_t const   )55,      (flex_int16_t const   )54, 
        (flex_int16_t const   )52,      (flex_int16_t const   )57,      (flex_int16_t const   )81,      (flex_int16_t const   )54, 
        (flex_int16_t const   )77,      (flex_int16_t const   )180,      (flex_int16_t const   )55,      (flex_int16_t const   )56, 
        (flex_int16_t const   )57,      (flex_int16_t const   )152,      (flex_int16_t const   )55,      (flex_int16_t const   )58, 
        (flex_int16_t const   )57,      (flex_int16_t const   )146,      (flex_int16_t const   )56,      (flex_int16_t const   )56, 
        (flex_int16_t const   )128,      (flex_int16_t const   )55,      (flex_int16_t const   )82,      (flex_int16_t const   )58, 
        (flex_int16_t const   )56,      (flex_int16_t const   )84,      (flex_int16_t const   )63,      (flex_int16_t const   )55, 
        (flex_int16_t const   )60,      (flex_int16_t const   )60,      (flex_int16_t const   )57,      (flex_int16_t const   )69, 
        (flex_int16_t const   )69,      (flex_int16_t const   )58,      (flex_int16_t const   )58,      (flex_int16_t const   )66, 
        (flex_int16_t const   )66,      (flex_int16_t const   )66,      (flex_int16_t const   )66,      (flex_int16_t const   )66, 
        (flex_int16_t const   )66,      (flex_int16_t const   )58,      (flex_int16_t const   )67,      (flex_int16_t const   )67, 
        (flex_int16_t const   )67,      (flex_int16_t const   )67,      (flex_int16_t const   )67,      (flex_int16_t const   )67, 
        (flex_int16_t const   )67,      (flex_int16_t const   )58,      (flex_int16_t const   )68,      (flex_int16_t const   )68, 
        (flex_int16_t const   )68,      (flex_int16_t const   )68,      (flex_int16_t const   )68,      (flex_int16_t const   )68, 
        (flex_int16_t const   )68,      (flex_int16_t const   )83,      (flex_int16_t const   )58,      (flex_int16_t const   )58, 
        (flex_int16_t const   )85,      (flex_int16_t const   )60,      (flex_int16_t const   )86,      (flex_int16_t const   )88, 
        (flex_int16_t const   )69,      (flex_int16_t const   )89,      (flex_int16_t const   )91,      (flex_int16_t const   )92, 
        (flex_int16_t const   )62,      (flex_int16_t const   )93,      (flex_int16_t const   )94,      (flex_int16_t const   )96, 
        (flex_int16_t const   )83,      (flex_int16_t const   )95,      (flex_int16_t const   )95,      (flex_int16_t const   )102, 
        (flex_int16_t const   )67,      (flex_int16_t const   )97,      (flex_int16_t const   )98,      (flex_int16_t const   )99, 
        (flex_int16_t const   )100,      (flex_int16_t const   )28,      (flex_int16_t const   )103,      (flex_int16_t const   )83, 
        (flex_int16_t const   )104,      (flex_int16_t const   )85,      (flex_int16_t const   )60,      (flex_int16_t const   )86, 
        (flex_int16_t const   )88,      (flex_int16_t const   )69,      (flex_int16_t const   )89,      (flex_int16_t const   )91, 
        (flex_int16_t const   )99,      (flex_int16_t const   )92,      (flex_int16_t const   )93,      (flex_int16_t const   )94, 
        (flex_int16_t const   )96,      (flex_int16_t const   )83,      (flex_int16_t const   )95,      (flex_int16_t const   )95, 
        (flex_int16_t const   )102,      (flex_int16_t const   )67,      (flex_int16_t const   )107,      (flex_int16_t const   )97, 
        (flex_int16_t const   )98,      (flex_int16_t const   )99,      (flex_int16_t const   )100,      (flex_int16_t const   )103, 
        (flex_int16_t const   )105,      (flex_int16_t const   )105,      (flex_int16_t const   )104,      (flex_int16_t const   )106, 
        (flex_int16_t const   )26,      (flex_int16_t const   )108,      (flex_int16_t const   )109,      (flex_int16_t const   )109, 
        (flex_int16_t const   )112,      (flex_int16_t const   )99,      (flex_int16_t const   )109,      (flex_int16_t const   )110, 
        (flex_int16_t const   )111,      (flex_int16_t const   )113,      (flex_int16_t const   )114,      (flex_int16_t const   )117, 
        (flex_int16_t const   )115,      (flex_int16_t const   )115,      (flex_int16_t const   )106,      (flex_int16_t const   )107, 
        (flex_int16_t const   )115,      (flex_int16_t const   )116,      (flex_int16_t const   )22,      (flex_int16_t const   )112, 
        (flex_int16_t const   )118,      (flex_int16_t const   )118,      (flex_int16_t const   )119,      (flex_int16_t const   )120, 
        (flex_int16_t const   )121,      (flex_int16_t const   )106,      (flex_int16_t const   )108,      (flex_int16_t const   )109, 
        (flex_int16_t const   )109,      (flex_int16_t const   )105,      (flex_int16_t const   )112,      (flex_int16_t const   )109, 
        (flex_int16_t const   )110,      (flex_int16_t const   )111,      (flex_int16_t const   )113,      (flex_int16_t const   )114, 
        (flex_int16_t const   )117,      (flex_int16_t const   )115,      (flex_int16_t const   )115,      (flex_int16_t const   )106, 
        (flex_int16_t const   )122,      (flex_int16_t const   )115,      (flex_int16_t const   )126,      (flex_int16_t const   )116, 
        (flex_int16_t const   )112,      (flex_int16_t const   )118,      (flex_int16_t const   )118,      (flex_int16_t const   )119, 
        (flex_int16_t const   )120,      (flex_int16_t const   )127,      (flex_int16_t const   )121,      (flex_int16_t const   )129, 
        (flex_int16_t const   )130,      (flex_int16_t const   )132,      (flex_int16_t const   )105,      (flex_int16_t const   )124, 
        (flex_int16_t const   )124,      (flex_int16_t const   )124,      (flex_int16_t const   )124,      (flex_int16_t const   )124, 
        (flex_int16_t const   )124,      (flex_int16_t const   )131,      (flex_int16_t const   )133,      (flex_int16_t const   )134, 
        (flex_int16_t const   )135,      (flex_int16_t const   )122,      (flex_int16_t const   )137,      (flex_int16_t const   )139, 
        (flex_int16_t const   )126,      (flex_int16_t const   )138,      (flex_int16_t const   )124,      (flex_int16_t const   )15, 
        (flex_int16_t const   )140,      (flex_int16_t const   )141,      (flex_int16_t const   )127,      (flex_int16_t const   )144, 
        (flex_int16_t const   )129,      (flex_int16_t const   )145,      (flex_int16_t const   )130,      (flex_int16_t const   )132, 
        (flex_int16_t const   )147,      (flex_int16_t const   )148,      (flex_int16_t const   )149,      (flex_int16_t const   )13, 
        (flex_int16_t const   )150,      (flex_int16_t const   )151,      (flex_int16_t const   )131,      (flex_int16_t const   )133, 
        (flex_int16_t const   )134,      (flex_int16_t const   )135,      (flex_int16_t const   )153,      (flex_int16_t const   )155, 
        (flex_int16_t const   )137,      (flex_int16_t const   )139,      (flex_int16_t const   )138,      (flex_int16_t const   )154, 
        (flex_int16_t const   )124,      (flex_int16_t const   )140,      (flex_int16_t const   )141,      (flex_int16_t const   )156, 
        (flex_int16_t const   )144,      (flex_int16_t const   )158,      (flex_int16_t const   )145,      (flex_int16_t const   )159, 
        (flex_int16_t const   )162,      (flex_int16_t const   )147,      (flex_int16_t const   )161,      (flex_int16_t const   )148, 
        (flex_int16_t const   )149,      (flex_int16_t const   )150,      (flex_int16_t const   )151,      (flex_int16_t const   )160, 
        (flex_int16_t const   )160,      (flex_int16_t const   )163,      (flex_int16_t const   )11,      (flex_int16_t const   )164, 
        (flex_int16_t const   )153,      (flex_int16_t const   )155,      (flex_int16_t const   )165,      (flex_int16_t const   )167, 
        (flex_int16_t const   )154,      (flex_int16_t const   )168,      (flex_int16_t const   )170,      (flex_int16_t const   )0, 
        (flex_int16_t const   )171,      (flex_int16_t const   )156,      (flex_int16_t const   )173,      (flex_int16_t const   )158, 
        (flex_int16_t const   )175,      (flex_int16_t const   )159,      (flex_int16_t const   )162,      (flex_int16_t const   )161, 
        (flex_int16_t const   )339,      (flex_int16_t const   )339,      (flex_int16_t const   )176,      (flex_int16_t const   )181, 
        (flex_int16_t const   )160,      (flex_int16_t const   )160,      (flex_int16_t const   )177,      (flex_int16_t const   )163, 
        (flex_int16_t const   )164,      (flex_int16_t const   )183,      (flex_int16_t const   )184,      (flex_int16_t const   )185, 
        (flex_int16_t const   )165,      (flex_int16_t const   )167,      (flex_int16_t const   )186,      (flex_int16_t const   )168, 
        (flex_int16_t const   )170,      (flex_int16_t const   )171,      (flex_int16_t const   )174,      (flex_int16_t const   )173, 
        (flex_int16_t const   )174,      (flex_int16_t const   )175,      (flex_int16_t const   )174,      (flex_int16_t const   )174, 
        (flex_int16_t const   )174,      (flex_int16_t const   )174,      (flex_int16_t const   )174,      (flex_int16_t const   )174, 
        (flex_int16_t const   )176,      (flex_int16_t const   )181,      (flex_int16_t const   )187,      (flex_int16_t const   )177, 
        (flex_int16_t const   )188,      (flex_int16_t const   )189,      (flex_int16_t const   )183,      (flex_int16_t const   )184, 
        (flex_int16_t const   )185,      (flex_int16_t const   )190,      (flex_int16_t const   )191,      (flex_int16_t const   )195, 
        (flex_int16_t const   )186,      (flex_int16_t const   )192,      (flex_int16_t const   )194,      (flex_int16_t const   )196, 
        (flex_int16_t const   )197,      (flex_int16_t const   )0,      (flex_int16_t const   )199,      (flex_int16_t const   )200, 
        (flex_int16_t const   )203,      (flex_int16_t const   )204,      (flex_int16_t const   )205,      (flex_int16_t const   )206, 
        (flex_int16_t const   )207,      (flex_int16_t const   )208,      (flex_int16_t const   )209,      (flex_int16_t const   )187, 
        (flex_int16_t const   )210,      (flex_int16_t const   )188,      (flex_int16_t const   )211,      (flex_int16_t const   )189, 
        (flex_int16_t const   )212,      (flex_int16_t const   )212,      (flex_int16_t const   )213,      (flex_int16_t const   )190, 
        (flex_int16_t const   )191,      (flex_int16_t const   )195,      (flex_int16_t const   )192,      (flex_int16_t const   )194, 
        (flex_int16_t const   )196,      (flex_int16_t const   )214,      (flex_int16_t const   )197,      (flex_int16_t const   )199, 
        (flex_int16_t const   )200,      (flex_int16_t const   )203,      (flex_int16_t const   )204,      (flex_int16_t const   )205, 
        (flex_int16_t const   )206,      (flex_int16_t const   )207,      (flex_int16_t const   )208,      (flex_int16_t const   )209, 
        (flex_int16_t const   )0,      (flex_int16_t const   )210,      (flex_int16_t const   )219,      (flex_int16_t const   )211, 
        (flex_int16_t const   )220,      (flex_int16_t const   )212,      (flex_int16_t const   )212,      (flex_int16_t const   )221, 
        (flex_int16_t const   )213,      (flex_int16_t const   )222,      (flex_int16_t const   )223,      (flex_int16_t const   )224, 
        (flex_int16_t const   )0,      (flex_int16_t const   )225,      (flex_int16_t const   )214,      (flex_int16_t const   )216, 
        (flex_int16_t const   )216,      (flex_int16_t const   )216,      (flex_int16_t const   )216,      (flex_int16_t const   )216, 
        (flex_int16_t const   )216,      (flex_int16_t const   )217,      (flex_int16_t const   )217,      (flex_int16_t const   )217, 
        (flex_int16_t const   )217,      (flex_int16_t const   )217,      (flex_int16_t const   )217,      (flex_int16_t const   )226, 
        (flex_int16_t const   )219,      (flex_int16_t const   )228,      (flex_int16_t const   )220,      (flex_int16_t const   )230, 
        (flex_int16_t const   )231,      (flex_int16_t const   )221,      (flex_int16_t const   )222,      (flex_int16_t const   )232, 
        (flex_int16_t const   )223,      (flex_int16_t const   )224,      (flex_int16_t const   )225,      (flex_int16_t const   )233, 
        (flex_int16_t const   )234,      (flex_int16_t const   )236,      (flex_int16_t const   )0,      (flex_int16_t const   )237, 
        (flex_int16_t const   )239,      (flex_int16_t const   )0,      (flex_int16_t const   )240,      (flex_int16_t const   )243, 
        (flex_int16_t const   )245,      (flex_int16_t const   )246,      (flex_int16_t const   )247,      (flex_int16_t const   )249, 
        (flex_int16_t const   )226,      (flex_int16_t const   )250,      (flex_int16_t const   )251,      (flex_int16_t const   )228, 
        (flex_int16_t const   )252,      (flex_int16_t const   )230,      (flex_int16_t const   )231,      (flex_int16_t const   )253, 
        (flex_int16_t const   )254,      (flex_int16_t const   )232,      (flex_int16_t const   )255,      (flex_int16_t const   )257, 
        (flex_int16_t const   )258,      (flex_int16_t const   )233,      (flex_int16_t const   )234,      (flex_int16_t const   )236, 
        (flex_int16_t const   )237,      (flex_int16_t const   )261,      (flex_int16_t const   )239,      (flex_int16_t const   )240, 
        (flex_int16_t const   )243,      (flex_int16_t const   )245,      (flex_int16_t const   )246,      (flex_int16_t const   )247, 
        (flex_int16_t const   )249,      (flex_int16_t const   )262,      (flex_int16_t const   )250,      (flex_int16_t const   )251, 
        (flex_int16_t const   )263,      (flex_int16_t const   )264,      (flex_int16_t const   )252,      (flex_int16_t const   )265, 
        (flex_int16_t const   )253,      (flex_int16_t const   )266,      (flex_int16_t const   )254,      (flex_int16_t const   )255, 
        (flex_int16_t const   )257,      (flex_int16_t const   )258,      (flex_int16_t const   )271,      (flex_int16_t const   )0, 
        (flex_int16_t const   )272,      (flex_int16_t const   )273,      (flex_int16_t const   )274,      (flex_int16_t const   )261, 
        (flex_int16_t const   )276,      (flex_int16_t const   )0,      (flex_int16_t const   )279,      (flex_int16_t const   )281, 
        (flex_int16_t const   )282,      (flex_int16_t const   )283,      (flex_int16_t const   )276,      (flex_int16_t const   )262, 
        (flex_int16_t const   )284,      (flex_int16_t const   )291,      (flex_int16_t const   )263,      (flex_int16_t const   )264, 
        (flex_int16_t const   )265,      (flex_int16_t const   )285,      (flex_int16_t const   )266,      (flex_int16_t const   )289, 
        (flex_int16_t const   )294,      (flex_int16_t const   )295,      (flex_int16_t const   )299,      (flex_int16_t const   )300, 
        (flex_int16_t const   )271,      (flex_int16_t const   )272,      (flex_int16_t const   )302,      (flex_int16_t const   )273, 
        (flex_int16_t const   )274,      (flex_int16_t const   )303,      (flex_int16_t const   )276,      (flex_int16_t const   )279, 
        (flex_int16_t const   )281,      (flex_int16_t const   )282,      (flex_int16_t const   )283,      (flex_int16_t const   )276, 
        (flex_int16_t const   )304,      (flex_int16_t const   )327,      (flex_int16_t const   )284,      (flex_int16_t const   )291, 
        (flex_int16_t const   )305,      (flex_int16_t const   )308,      (flex_int16_t const   )285,      (flex_int16_t const   )313, 
        (flex_int16_t const   )289,      (flex_int16_t const   )294,      (flex_int16_t const   )295,      (flex_int16_t const   )299, 
        (flex_int16_t const   )300,      (flex_int16_t const   )315,      (flex_int16_t const   )317,      (flex_int16_t const   )318, 
        (flex_int16_t const   )302,      (flex_int16_t const   )320,      (flex_int16_t const   )303,      (flex_int16_t const   )321, 
        (flex_int16_t const   )323,      (flex_int16_t const   )326,      (flex_int16_t const   )328,      (flex_int16_t const   )330, 
        (flex_int16_t const   )331,      (flex_int16_t const   )333,      (flex_int16_t const   )304,      (flex_int16_t const   )327, 
        (flex_int16_t const   )332,      (flex_int16_t const   )305,      (flex_int16_t const   )308,      (flex_int16_t const   )335, 
        (flex_int16_t const   )313,      (flex_int16_t const   )336,      (flex_int16_t const   )338,      (flex_int16_t const   )341, 
        (flex_int16_t const   )342,      (flex_int16_t const   )343,      (flex_int16_t const   )315,      (flex_int16_t const   )317, 
        (flex_int16_t const   )318,      (flex_int16_t const   )347,      (flex_int16_t const   )320,      (flex_int16_t const   )349, 
        (flex_int16_t const   )321,      (flex_int16_t const   )323,      (flex_int16_t const   )326,      (flex_int16_t const   )328, 
        (flex_int16_t const   )330,      (flex_int16_t const   )0,      (flex_int16_t const   )331,      (flex_int16_t const   )333, 
        (flex_int16_t const   )0,      (flex_int16_t const   )332,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )335,      (flex_int16_t const   )0,      (flex_int16_t const   )336,      (flex_int16_t const   )338, 
        (flex_int16_t const   )341,      (flex_int16_t const   )342,      (flex_int16_t const   )0,      (flex_int16_t const   )343, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )347, 
        (flex_int16_t const   )349,      (flex_int16_t const   )352,      (flex_int16_t const   )0,      (flex_int16_t const   )352, 
        (flex_int16_t const   )354,      (flex_int16_t const   )0,      (flex_int16_t const   )354,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351};
#line 81 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 119
extern  __attribute__((__nothrow__)) int toupper(int __c ) ;
#line 46 "../../include/jtag.h"
char const   *jtag_get_data_dir(void) ;
#line 36 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bsdl/bsdl_msg.h"
void bsdl_msg(int proc_mode , int type , char const   *format  , ...) ;
#line 31 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bsdl/vhdl_parser.h"
void *vhdl_flex_init(FILE *f , int proc_mode ) ;
#line 32
void vhdl_flex_deinit(void *scanner ) ;
#line 33
void vhdl_flex_switch_file(void *scanner , char *filename ) ;
#line 34
int vhdl_flex_get_compile_errors(void *scanner ) ;
#line 35
int vhdl_flex_postinc_compile_errors(void *scanner ) ;
#line 36
int vhdl_flex_get_lineno(void *scanner ) ;
#line 143 "vhdl_flex.l"
static char *new_string(scan_extra_t *extra , char const   *str ) ;
#line 795 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int isatty(int __fd ) ;
#line 1021 "vhdl_flex.c"
static int yy_init_globals(yyscan_t yyscanner ) ;
#line 1027
int vhdllex_init(yyscan_t *ptr_yy_globals ) ;
#line 1029
int vhdllex_init_extra(scan_extra_t *yy_user_defined , yyscan_t *ptr_yy_globals ) ;
#line 1034
int vhdllex_destroy(yyscan_t yyscanner ) ;
#line 1036
int vhdlget_debug(yyscan_t yyscanner ) ;
#line 1038
void vhdlset_debug(int bdebug , yyscan_t yyscanner ) ;
#line 1040
scan_extra_t *vhdlget_extra(yyscan_t yyscanner ) ;
#line 1042
void vhdlset_extra(scan_extra_t *user_defined , yyscan_t yyscanner ) ;
#line 1044
FILE *vhdlget_in(yyscan_t yyscanner ) ;
#line 1046
void vhdlset_in(FILE *in_str , yyscan_t yyscanner ) ;
#line 1048
FILE *vhdlget_out(yyscan_t yyscanner ) ;
#line 1050
void vhdlset_out(FILE *out_str , yyscan_t yyscanner ) ;
#line 1052
int vhdlget_leng(yyscan_t yyscanner ) ;
#line 1054
char *vhdlget_text(yyscan_t yyscanner ) ;
#line 1056
int vhdlget_lineno(yyscan_t yyscanner ) ;
#line 1058
void vhdlset_lineno(int line_number , yyscan_t yyscanner ) ;
#line 1060
YYSTYPE *vhdlget_lval(yyscan_t yyscanner ) ;
#line 1062
void vhdlset_lval(YYSTYPE *yylval_param , yyscan_t yyscanner ) ;
#line 1072
int vhdlwrap(yyscan_t scanner ) ;
#line 1176
int vhdllex(YYSTYPE *yylval_param , yyscan_t yyscanner ) ;
#line 1200 "vhdl_flex.c"
int vhdllex(YYSTYPE *yylval_param , yyscan_t yyscanner ) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register char *yy_bp ;
  register int yy_act ;
  struct yyguts_t *yyg ;
  void *tmp ;
  YY_BUFFER_STATE tmp___0 ;
  yy_state_type *tmp___1 ;
  register YY_CHAR yy_c ;
  yy_state_type *tmp___2 ;
  YY_BUFFER_STATE tmp___3 ;
  int yy_amount_of_matched_text ;
  yy_state_type yy_next_state ;
  int tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 1205
  yyg = (struct yyguts_t *)yyscanner;
#line 1211
  yyg->yylval_r = yylval_param;
#line 1213
  if (! yyg->yy_init) {
#line 1215
    yyg->yy_init = 1;
#line 1222
    if (! yyg->yy_state_buf) {
      {
#line 1223
      tmp = vhdlalloc((yy_size_t )(16386UL * sizeof(yy_state_type )), yyscanner);
#line 1223
      yyg->yy_state_buf = (yy_state_type *)tmp;
      }
    }
#line 1224
    if (! yyg->yy_state_buf) {
      {
#line 1225
      yy_fatal_error("out of dynamic memory in vhdllex()", yyscanner);
      }
    }
#line 1227
    if (! yyg->yy_start) {
#line 1228
      yyg->yy_start = 1;
    }
#line 1230
    if (! yyg->yyin_r) {
#line 1231
      yyg->yyin_r = stdin;
    }
#line 1233
    if (! yyg->yyout_r) {
#line 1234
      yyg->yyout_r = stdout;
    }
#line 1236
    if (yyg->yy_buffer_stack) {
#line 1236
      tmp___0 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
    } else {
#line 1236
      tmp___0 = (YY_BUFFER_STATE )((void *)0);
    }
#line 1236
    if (! tmp___0) {
      {
#line 1237
      vhdlensure_buffer_stack(yyscanner);
#line 1238
      *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top) = vhdl_create_buffer(yyg->yyin_r,
                                                                              16384,
                                                                              yyscanner);
      }
    }
    {
#line 1242
    vhdl_load_buffer_state(yyscanner);
    }
  }
  {
#line 1245
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1247
    yy_cp = yyg->yy_c_buf_p;
#line 1250
    *yy_cp = yyg->yy_hold_char;
#line 1255
    yy_bp = yy_cp;
#line 1257
    yy_current_state = yyg->yy_start;
#line 1259
    yyg->yy_state_ptr = yyg->yy_state_buf;
#line 1260
    tmp___1 = yyg->yy_state_ptr;
#line 1260
    (yyg->yy_state_ptr) ++;
#line 1260
    *tmp___1 = yy_current_state;
    yy_match: 
    {
#line 1263
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1265
      yy_c = (YY_CHAR )yy_ec[(unsigned int )((unsigned char )*yy_cp)];
      {
#line 1266
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1266
        if (! ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1266
          goto while_break___1;
        }
#line 1268
        yy_current_state = (int )yy_def[yy_current_state];
#line 1269
        if (yy_current_state >= 352) {
#line 1270
          yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1272
      yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 1273
      tmp___2 = yyg->yy_state_ptr;
#line 1273
      (yyg->yy_state_ptr) ++;
#line 1273
      *tmp___2 = yy_current_state;
#line 1274
      yy_cp ++;
#line 1263
      if (! ((int const   )yy_base[yy_current_state] != 823)) {
#line 1263
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    yy_find_action: 
#line 1279
    (yyg->yy_state_ptr) --;
#line 1279
    yy_current_state = *(yyg->yy_state_ptr);
#line 1280
    yyg->yy_lp = (int )yy_accept[yy_current_state];
    find_rule: 
    {
#line 1282
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1284
      if (yyg->yy_lp) {
#line 1284
        if (yyg->yy_lp < (int )yy_accept[yy_current_state + 1]) {
#line 1286
          yy_act = (int )yy_acclist[yyg->yy_lp];
#line 1288
          yyg->yy_full_match = yy_cp;
#line 1289
          goto while_break___2;
        }
      }
#line 1292
      yy_cp --;
#line 1293
      (yyg->yy_state_ptr) --;
#line 1293
      yy_current_state = *(yyg->yy_state_ptr);
#line 1294
      yyg->yy_lp = (int )yy_accept[yy_current_state];
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1297
    yyg->yytext_r = yy_bp;
#line 1297
    yyg->yyleng_r = (int )((size_t )(yy_cp - yy_bp));
#line 1297
    yyg->yy_hold_char = *yy_cp;
#line 1297
    *yy_cp = (char )'\000';
#line 1297
    yyg->yy_c_buf_p = yy_cp;
    do_action: 
    {
#line 1303
    if (yy_act == 1) {
#line 1303
      goto case_1;
    }
#line 243
    if (yy_act == 2) {
#line 243 "vhdl_flex.l"
      goto case_2;
    }
#line 245
    if (yy_act == 3) {
#line 245
      goto case_3;
    }
#line 246
    if (yy_act == 4) {
#line 246
      goto case_4;
    }
#line 247
    if (yy_act == 5) {
#line 247
      goto case_5;
    }
#line 248
    if (yy_act == 6) {
#line 248
      goto case_6;
    }
#line 249
    if (yy_act == 7) {
#line 249
      goto case_7;
    }
#line 250
    if (yy_act == 8) {
#line 250
      goto case_8;
    }
#line 251
    if (yy_act == 9) {
#line 251
      goto case_9;
    }
#line 254
    if (yy_act == 10) {
#line 254
      goto case_10;
    }
#line 255
    if (yy_act == 11) {
#line 255
      goto case_11;
    }
#line 256
    if (yy_act == 12) {
#line 256
      goto case_12;
    }
#line 257
    if (yy_act == 13) {
#line 257
      goto case_13;
    }
#line 258
    if (yy_act == 14) {
#line 258
      goto case_14;
    }
#line 259
    if (yy_act == 15) {
#line 259
      goto case_15;
    }
#line 260
    if (yy_act == 16) {
#line 260
      goto case_16;
    }
#line 261
    if (yy_act == 17) {
#line 261
      goto case_17;
    }
#line 262
    if (yy_act == 18) {
#line 262
      goto case_18;
    }
#line 263
    if (yy_act == 19) {
#line 263
      goto case_19;
    }
#line 264
    if (yy_act == 20) {
#line 264
      goto case_20;
    }
#line 265
    if (yy_act == 21) {
#line 265
      goto case_21;
    }
#line 266
    if (yy_act == 22) {
#line 266
      goto case_22;
    }
#line 267
    if (yy_act == 23) {
#line 267
      goto case_23;
    }
#line 268
    if (yy_act == 24) {
#line 268
      goto case_24;
    }
#line 269
    if (yy_act == 25) {
#line 269
      goto case_25;
    }
#line 270
    if (yy_act == 26) {
#line 270
      goto case_26;
    }
#line 271
    if (yy_act == 27) {
#line 271
      goto case_27;
    }
#line 272
    if (yy_act == 28) {
#line 272
      goto case_28;
    }
#line 273
    if (yy_act == 29) {
#line 273
      goto case_29;
    }
#line 274
    if (yy_act == 30) {
#line 274
      goto case_30;
    }
#line 275
    if (yy_act == 31) {
#line 275
      goto case_31;
    }
#line 276
    if (yy_act == 32) {
#line 276
      goto case_32;
    }
#line 277
    if (yy_act == 33) {
#line 277
      goto case_33;
    }
#line 278
    if (yy_act == 34) {
#line 278
      goto case_34;
    }
#line 279
    if (yy_act == 35) {
#line 279
      goto case_35;
    }
#line 280
    if (yy_act == 36) {
#line 280
      goto case_36;
    }
#line 281
    if (yy_act == 37) {
#line 281
      goto case_37;
    }
#line 282
    if (yy_act == 38) {
#line 282
      goto case_38;
    }
#line 283
    if (yy_act == 39) {
#line 283
      goto case_39;
    }
#line 284
    if (yy_act == 40) {
#line 284
      goto case_40;
    }
#line 285
    if (yy_act == 41) {
#line 285
      goto case_41;
    }
#line 286
    if (yy_act == 42) {
#line 286
      goto case_42;
    }
#line 287
    if (yy_act == 43) {
#line 287
      goto case_43;
    }
#line 288
    if (yy_act == 44) {
#line 288
      goto case_44;
    }
#line 289
    if (yy_act == 45) {
#line 289
      goto case_45;
    }
#line 290
    if (yy_act == 46) {
#line 290
      goto case_46;
    }
#line 291
    if (yy_act == 47) {
#line 291
      goto case_47;
    }
#line 292
    if (yy_act == 48) {
#line 292
      goto case_48;
    }
#line 293
    if (yy_act == 49) {
#line 293
      goto case_49;
    }
#line 294
    if (yy_act == 50) {
#line 294
      goto case_50;
    }
#line 295
    if (yy_act == 51) {
#line 295
      goto case_51;
    }
#line 296
    if (yy_act == 52) {
#line 296
      goto case_52;
    }
#line 297
    if (yy_act == 53) {
#line 297
      goto case_53;
    }
#line 298
    if (yy_act == 54) {
#line 298
      goto case_54;
    }
#line 299
    if (yy_act == 55) {
#line 299
      goto case_55;
    }
#line 300
    if (yy_act == 56) {
#line 300
      goto case_56;
    }
#line 301
    if (yy_act == 57) {
#line 301
      goto case_57;
    }
#line 302
    if (yy_act == 58) {
#line 302
      goto case_58;
    }
#line 303
    if (yy_act == 59) {
#line 303
      goto case_59;
    }
#line 304
    if (yy_act == 60) {
#line 304
      goto case_60;
    }
#line 305
    if (yy_act == 61) {
#line 305
      goto case_61;
    }
#line 306
    if (yy_act == 62) {
#line 306
      goto case_62;
    }
#line 307
    if (yy_act == 63) {
#line 307
      goto case_63;
    }
#line 308
    if (yy_act == 64) {
#line 308
      goto case_64;
    }
#line 309
    if (yy_act == 65) {
#line 309
      goto case_65;
    }
#line 310
    if (yy_act == 66) {
#line 310
      goto case_66;
    }
#line 311
    if (yy_act == 67) {
#line 311
      goto case_67;
    }
#line 312
    if (yy_act == 68) {
#line 312
      goto case_68;
    }
#line 313
    if (yy_act == 69) {
#line 313
      goto case_69;
    }
#line 314
    if (yy_act == 70) {
#line 314
      goto case_70;
    }
#line 315
    if (yy_act == 71) {
#line 315
      goto case_71;
    }
#line 316
    if (yy_act == 72) {
#line 316
      goto case_72;
    }
#line 317
    if (yy_act == 73) {
#line 317
      goto case_73;
    }
#line 318
    if (yy_act == 74) {
#line 318
      goto case_74;
    }
#line 321
    if (yy_act == 75) {
#line 321
      goto case_75;
    }
#line 323
    if (yy_act == 76) {
#line 323
      goto case_76;
    }
#line 325
    if (yy_act == 77) {
#line 325
      goto case_77;
    }
#line 328
    if (yy_act == 78) {
#line 328
      goto case_78;
    }
#line 330
    if (yy_act == 79) {
#line 330
      goto case_79;
    }
#line 331
    if (yy_act == 80) {
#line 331
      goto case_80;
    }
#line 332
    if (yy_act == 81) {
#line 332
      goto case_81;
    }
#line 343
    if (yy_act == 88) {
#line 343
      goto case_88;
    }
#line 343
    if (yy_act == 87) {
#line 343
      goto case_88;
    }
#line 343
    if (yy_act == 86) {
#line 343
      goto case_88;
    }
#line 343
    if (yy_act == 85) {
#line 343
      goto case_88;
    }
#line 343
    if (yy_act == 84) {
#line 343
      goto case_88;
    }
#line 344
    if (yy_act == 82) {
#line 344
      goto case_82;
    }
#line 1744
    if (yy_act == 83) {
#line 1744 "vhdl_flex.c"
      goto case_83;
    }
#line 1866
    goto switch_default;
    case_1: /* CIL Label */ 
#line 241 "vhdl_flex.l"
    return (258);
#line 242
    goto switch_break;
    case_2: /* CIL Label */ 
#line 242
    (yyg->yyextra_r)->Base = 1;
#line 243
    return (259);
#line 244
    goto switch_break;
    case_3: /* CIL Label */ 
#line 244
    (yyg->yyextra_r)->Base = 1;
#line 244
    return (260);
#line 245
    goto switch_break;
    case_4: /* CIL Label */ 
#line 245
    (yyg->yyextra_r)->Base = 1;
#line 245
    return (261);
#line 246
    goto switch_break;
    case_5: /* CIL Label */ 
#line 246
    (yyg->yyextra_r)->Base = 1;
#line 246
    return (262);
#line 247
    goto switch_break;
    case_6: /* CIL Label */ 
#line 247
    return (263);
#line 248
    goto switch_break;
    case_7: /* CIL Label */ 
#line 248
    (yyg->yyextra_r)->Base = 1;
#line 248
    return (265);
#line 249
    goto switch_break;
    case_8: /* CIL Label */ 
#line 249
    return (266);
#line 250
    goto switch_break;
    case_9: /* CIL Label */ 
#line 250
    (yyg->yyextra_r)->Base = 1;
#line 251
    yyg->yy_start = 1;
#line 252
    return (267);
#line 253
    goto switch_break;
    case_10: /* CIL Label */ 
#line 253
    return (268);
#line 254
    goto switch_break;
    case_11: /* CIL Label */ 
#line 254
    return (264);
#line 255
    goto switch_break;
    case_12: /* CIL Label */ 
#line 255
    return (269);
#line 256
    goto switch_break;
    case_13: /* CIL Label */ 
#line 256
    return (270);
#line 257
    goto switch_break;
    case_14: /* CIL Label */ 
#line 257
    return (271);
#line 258
    goto switch_break;
    case_15: /* CIL Label */ 
#line 258
    return (272);
#line 259
    goto switch_break;
    case_16: /* CIL Label */ 
#line 259
    return (273);
#line 260
    goto switch_break;
    case_17: /* CIL Label */ 
#line 260
    return (274);
#line 261
    goto switch_break;
    case_18: /* CIL Label */ 
#line 261
    return (275);
#line 262
    goto switch_break;
    case_19: /* CIL Label */ 
#line 262
    return (276);
#line 263
    goto switch_break;
    case_20: /* CIL Label */ 
#line 263
    return (277);
#line 264
    goto switch_break;
    case_21: /* CIL Label */ 
#line 264
    return (278);
#line 265
    goto switch_break;
    case_22: /* CIL Label */ 
#line 265
    return (279);
#line 266
    goto switch_break;
    case_23: /* CIL Label */ 
#line 266
    return (280);
#line 267
    goto switch_break;
    case_24: /* CIL Label */ 
#line 267
    return (281);
#line 268
    goto switch_break;
    case_25: /* CIL Label */ 
#line 268
    return (282);
#line 269
    goto switch_break;
    case_26: /* CIL Label */ 
#line 269
    return (283);
#line 270
    goto switch_break;
    case_27: /* CIL Label */ 
#line 270
    return (284);
#line 271
    goto switch_break;
    case_28: /* CIL Label */ 
#line 271
    return (285);
#line 272
    goto switch_break;
    case_29: /* CIL Label */ 
#line 272
    return (286);
#line 273
    goto switch_break;
    case_30: /* CIL Label */ 
#line 273
    return (287);
#line 274
    goto switch_break;
    case_31: /* CIL Label */ 
#line 274
    return (288);
#line 275
    goto switch_break;
    case_32: /* CIL Label */ 
#line 275
    return (289);
#line 276
    goto switch_break;
    case_33: /* CIL Label */ 
#line 276
    (yyg->yyextra_r)->Base = 1;
#line 276
    return (290);
#line 277
    goto switch_break;
    case_34: /* CIL Label */ 
#line 277
    return (291);
#line 278
    goto switch_break;
    case_35: /* CIL Label */ 
#line 278
    return (292);
#line 279
    goto switch_break;
    case_36: /* CIL Label */ 
#line 279
    yyg->yy_start = 9;
#line 279
    return (293);
#line 280
    goto switch_break;
    case_37: /* CIL Label */ 
#line 280
    return (332);
#line 281
    goto switch_break;
    case_38: /* CIL Label */ 
#line 281
    return (334);
#line 282
    goto switch_break;
    case_39: /* CIL Label */ 
#line 282
    return (335);
#line 283
    goto switch_break;
    case_40: /* CIL Label */ 
#line 283
    return (294);
#line 284
    goto switch_break;
    case_41: /* CIL Label */ 
#line 284
    return (295);
#line 285
    goto switch_break;
    case_42: /* CIL Label */ 
#line 285
    return (296);
#line 286
    goto switch_break;
    case_43: /* CIL Label */ 
#line 286
    return (298);
#line 287
    goto switch_break;
    case_44: /* CIL Label */ 
#line 287
    return (297);
#line 288
    goto switch_break;
    case_45: /* CIL Label */ 
#line 288
    return (299);
#line 289
    goto switch_break;
    case_46: /* CIL Label */ 
#line 289
    return (300);
#line 290
    goto switch_break;
    case_47: /* CIL Label */ 
#line 290
    return (333);
#line 291
    goto switch_break;
    case_48: /* CIL Label */ 
#line 291
    return (301);
#line 292
    goto switch_break;
    case_49: /* CIL Label */ 
#line 292
    return (302);
#line 293
    goto switch_break;
    case_50: /* CIL Label */ 
#line 293
    return (303);
#line 294
    goto switch_break;
    case_51: /* CIL Label */ 
#line 294
    return (304);
#line 295
    goto switch_break;
    case_52: /* CIL Label */ 
#line 295
    return (305);
#line 296
    goto switch_break;
    case_53: /* CIL Label */ 
#line 296
    return (306);
#line 297
    goto switch_break;
    case_54: /* CIL Label */ 
#line 297
    return (307);
#line 298
    goto switch_break;
    case_55: /* CIL Label */ 
#line 298
    return (308);
#line 299
    goto switch_break;
    case_56: /* CIL Label */ 
#line 299
    return (309);
#line 300
    goto switch_break;
    case_57: /* CIL Label */ 
#line 300
    return (310);
#line 301
    goto switch_break;
    case_58: /* CIL Label */ 
#line 301
    return (311);
#line 302
    goto switch_break;
    case_59: /* CIL Label */ 
#line 302
    return (312);
#line 303
    goto switch_break;
    case_60: /* CIL Label */ 
#line 303
    return (314);
#line 304
    goto switch_break;
    case_61: /* CIL Label */ 
#line 304
    return (315);
#line 305
    goto switch_break;
    case_62: /* CIL Label */ 
#line 305
    return (316);
#line 306
    goto switch_break;
    case_63: /* CIL Label */ 
#line 306
    ((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_bs_lineno) ++;
#line 307
    goto switch_break;
    case_64: /* CIL Label */ 
#line 307
    return (324);
#line 308
    goto switch_break;
    case_65: /* CIL Label */ 
#line 308
    return (325);
#line 309
    goto switch_break;
    case_66: /* CIL Label */ 
#line 309
    return (326);
#line 310
    goto switch_break;
    case_67: /* CIL Label */ 
#line 310
    return (330);
#line 311
    goto switch_break;
    case_68: /* CIL Label */ 
#line 311
    return (327);
#line 312
    goto switch_break;
    case_69: /* CIL Label */ 
#line 312
    return (328);
#line 313
    goto switch_break;
    case_70: /* CIL Label */ 
#line 313
    (yyg->yyextra_r)->Base = 2;
#line 313
    return (318);
#line 314
    goto switch_break;
    case_71: /* CIL Label */ 
#line 314
    return (329);
#line 315
    goto switch_break;
    case_72: /* CIL Label */ ;
#line 316
    goto switch_break;
    case_73: /* CIL Label */ ;
#line 317
    goto switch_break;
    case_74: /* CIL Label */ 
#line 317
    if ((yyg->yyextra_r)->Base != 2) {
#line 317
      *yy_cp = yyg->yy_hold_char;
#line 317
      yy_cp = yyg->yy_full_match;
#line 317
      (yyg->yy_lp) ++;
#line 317
      goto find_rule;
    }
    {
#line 318
    (yyg->yylval_r)->str = new_string(yyg->yyextra_r, (char const   *)yyg->yytext_r);
    }
#line 319
    return (313);
#line 320
    goto switch_break;
    case_75: /* CIL Label */ 
    {
#line 320
    (yyg->yylval_r)->str = new_string(yyg->yyextra_r, (char const   *)yyg->yytext_r);
    }
#line 321
    return (317);
#line 322
    goto switch_break;
    case_76: /* CIL Label */ 
    {
#line 322
    (yyg->yylval_r)->str = new_string(yyg->yyextra_r, (char const   *)yyg->yytext_r);
    }
#line 323
    return (319);
#line 324
    goto switch_break;
    case_77: /* CIL Label */ 
#line 324
    if ((yyg->yyextra_r)->Base != 1) {
#line 324
      *yy_cp = yyg->yy_hold_char;
#line 324
      yy_cp = yyg->yy_full_match;
#line 324
      (yyg->yy_lp) ++;
#line 324
      goto find_rule;
    }
    {
#line 325
    (yyg->yylval_r)->integer = atoi((char const   *)yyg->yytext_r);
    }
#line 326
    return (320);
#line 327
    goto switch_break;
    case_78: /* CIL Label */ 
    {
#line 327
    (yyg->yylval_r)->str = new_string(yyg->yyextra_r, (char const   *)yyg->yytext_r);
    }
#line 328
    return (321);
#line 329
    goto switch_break;
    case_79: /* CIL Label */ 
#line 329
    return (322);
#line 330
    goto switch_break;
    case_80: /* CIL Label */ 
#line 330
    return (323);
#line 331
    goto switch_break;
    case_81: /* CIL Label */ 
    {
#line 331
    bsdl_msg((yyg->yyextra_r)->proc_mode, 2, "Illegal character %c (/%03o) at line %d:\n",
             (int )*(yyg->yytext_r + (yyg->yyleng_r - 1)), (int )*(yyg->yytext_r + (yyg->yyleng_r - 1)),
             (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_bs_lineno);
#line 336
    ((yyg->yyextra_r)->Compile_Errors) ++;
    }
#line 337
    return (331);
#line 338
    goto switch_break;
    case_88: /* CIL Label */ 
    case_87: /* CIL Label */ 
    case_86: /* CIL Label */ 
    case_85: /* CIL Label */ 
    case_84: /* CIL Label */ 
    {
#line 339
    vhdlpop_buffer_state(yyscanner);
    }
#line 340
    if (yyg->yy_buffer_stack) {
#line 340
      tmp___3 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
    } else {
#line 340
      tmp___3 = (YY_BUFFER_STATE )((void *)0);
    }
#line 340
    if (! tmp___3) {
#line 341
      return (0);
    }
#line 343
    goto switch_break;
    case_82: /* CIL Label */ 
    {
#line 343
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 343
      fwrite((void const   */* __restrict  */)yyg->yytext_r, (size_t )yyg->yyleng_r,
             (size_t )1, (FILE */* __restrict  */)yyg->yyout_r);
      }
#line 343
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 344
    goto switch_break;
    case_83: /* CIL Label */ 
#line 1747 "vhdl_flex.c"
    yy_amount_of_matched_text = (int )(yy_cp - yyg->yytext_r) - 1;
#line 1750
    *yy_cp = yyg->yy_hold_char;
#line 1753
    if ((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buffer_status == 0) {
#line 1764
      yyg->yy_n_chars = (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_n_chars;
#line 1765
      (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_input_file = yyg->yyin_r;
#line 1766
      (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buffer_status = 1;
    }
#line 1776
    if ((unsigned long )yyg->yy_c_buf_p <= (unsigned long )((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + yyg->yy_n_chars)) {
      {
#line 1780
      yyg->yy_c_buf_p = yyg->yytext_r + yy_amount_of_matched_text;
#line 1782
      yy_current_state = yy_get_previous_state(yyscanner);
#line 1793
      yy_next_state = yy_try_NUL_trans(yy_current_state, yyscanner);
#line 1795
      yy_bp = yyg->yytext_r + 0;
      }
#line 1797
      if (yy_next_state) {
#line 1800
        (yyg->yy_c_buf_p) ++;
#line 1800
        yy_cp = yyg->yy_c_buf_p;
#line 1801
        yy_current_state = yy_next_state;
#line 1802
        goto yy_match;
      } else {
#line 1807
        yy_cp = yyg->yy_c_buf_p;
#line 1808
        goto yy_find_action;
      }
    } else {
      {
#line 1812
      tmp___4 = yy_get_next_buffer(yyscanner);
      }
      {
#line 1814
      if (tmp___4 == 1) {
#line 1814
        goto case_1___0;
      }
#line 1843
      if (tmp___4 == 0) {
#line 1843
        goto case_0;
      }
#line 1853
      if (tmp___4 == 2) {
#line 1853
        goto case_2___0;
      }
#line 1812
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
      {
#line 1816
      yyg->yy_did_buffer_switch_on_eof = 0;
#line 1818
      tmp___5 = vhdlwrap(yyscanner);
      }
#line 1818
      if (tmp___5) {
#line 1829
        yyg->yy_c_buf_p = yyg->yytext_r + 0;
#line 1831
        yy_act = (83 + (yyg->yy_start - 1) / 2) + 1;
#line 1832
        goto do_action;
      } else
#line 1837
      if (! yyg->yy_did_buffer_switch_on_eof) {
        {
#line 1838
        vhdlrestart(yyg->yyin_r, yyscanner);
        }
      }
#line 1840
      goto switch_break___0;
      case_0: /* CIL Label */ 
      {
#line 1844
      yyg->yy_c_buf_p = yyg->yytext_r + yy_amount_of_matched_text;
#line 1847
      yy_current_state = yy_get_previous_state(yyscanner);
#line 1849
      yy_cp = yyg->yy_c_buf_p;
#line 1850
      yy_bp = yyg->yytext_r + 0;
      }
#line 1851
      goto yy_match;
      case_2___0: /* CIL Label */ 
      {
#line 1854
      yyg->yy_c_buf_p = (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + yyg->yy_n_chars;
#line 1857
      yy_current_state = yy_get_previous_state(yyscanner);
#line 1859
      yy_cp = yyg->yy_c_buf_p;
#line 1860
      yy_bp = yyg->yytext_r + 0;
      }
#line 1861
      goto yy_find_action;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 1863
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1867
    yy_fatal_error("fatal flex scanner internal error--no action found", yyscanner);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1880 "vhdl_flex.c"
static int yy_get_next_buffer(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  register char *dest ;
  register char *source ;
  register int number_to_move ;
  register int i ;
  int ret_val ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int num_to_read ;
  int c ;
  size_t n ;
  size_t tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  yy_size_t new_size ;
  void *tmp___10 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
#line 1882
  yyg = (struct yyguts_t *)yyscanner;
#line 1883
  dest = (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf;
#line 1884
  source = yyg->yytext_r;
#line 1888
  if ((unsigned long )yyg->yy_c_buf_p > (unsigned long )((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + (yyg->yy_n_chars + 1))) {
    {
#line 1889
    yy_fatal_error("fatal flex scanner internal error--end of buffer missed", yyscanner);
    }
  }
#line 1892
  if ((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_fill_buffer == 0) {
#line 1894
    if (yyg->yy_c_buf_p - yyg->yytext_r == 1L) {
#line 1899
      return (1);
    } else {
#line 1907
      return (2);
    }
  }
#line 1914
  number_to_move = (int )(yyg->yy_c_buf_p - yyg->yytext_r) - 1;
#line 1916
  i = 0;
  {
#line 1916
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1916
    if (! (i < number_to_move)) {
#line 1916
      goto while_break;
    }
#line 1917
    tmp = dest;
#line 1917
    dest ++;
#line 1917
    tmp___0 = source;
#line 1917
    source ++;
#line 1917
    *tmp = *tmp___0;
#line 1916
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1919
  if ((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buffer_status == 2) {
#line 1923
    tmp___1 = 0;
#line 1923
    yyg->yy_n_chars = tmp___1;
#line 1923
    (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_n_chars = tmp___1;
  } else {
#line 1927
    num_to_read = (int )(((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buf_size - (yy_size_t )number_to_move) - 1U);
    {
#line 1930
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1930
      if (! (num_to_read <= 0)) {
#line 1930
        goto while_break___0;
      }
      {
#line 1933
      yy_fatal_error("input buffer overflow, can\'t enlarge buffer because scanner uses REJECT",
                     yyscanner);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1938
    if (num_to_read > 8192) {
#line 1939
      num_to_read = 8192;
    }
#line 1942
    if ((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_is_interactive) {
#line 1942
      c = '*';
#line 1942
      n = (size_t )0;
      {
#line 1942
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1942
        if (n < (size_t )num_to_read) {
          {
#line 1942
          c = _IO_getc(yyg->yyin_r);
          }
#line 1942
          if (c != -1) {
#line 1942
            if (! (c != 10)) {
#line 1942
              goto while_break___1;
            }
          } else {
#line 1942
            goto while_break___1;
          }
        } else {
#line 1942
          goto while_break___1;
        }
#line 1942
        *(((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + number_to_move) + n) = (char )c;
#line 1942
        n ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1942
      if (c == 10) {
#line 1942
        tmp___2 = n;
#line 1942
        n ++;
#line 1942
        *(((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + number_to_move) + tmp___2) = (char )c;
      }
#line 1942
      if (c == -1) {
        {
#line 1942
        tmp___3 = ferror(yyg->yyin_r);
        }
#line 1942
        if (tmp___3) {
          {
#line 1942
          yy_fatal_error("input in flex scanner failed", yyscanner);
          }
        }
      }
#line 1942
      yyg->yy_n_chars = (int )n;
    } else {
      {
#line 1942
      tmp___4 = __errno_location();
#line 1942
      *tmp___4 = 0;
      }
      {
#line 1942
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 1942
        tmp___8 = fread((void */* __restrict  */)((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + number_to_move),
                        (size_t )1, (size_t )num_to_read, (FILE */* __restrict  */)yyg->yyin_r);
#line 1942
        tmp___7 = (int )tmp___8;
#line 1942
        yyg->yy_n_chars = tmp___7;
        }
#line 1942
        if (tmp___7 == 0) {
          {
#line 1942
          tmp___9 = ferror(yyg->yyin_r);
          }
#line 1942
          if (! tmp___9) {
#line 1942
            goto while_break___2;
          }
        } else {
#line 1942
          goto while_break___2;
        }
        {
#line 1942
        tmp___5 = __errno_location();
        }
#line 1942
        if (*tmp___5 != 4) {
          {
#line 1942
          yy_fatal_error("input in flex scanner failed", yyscanner);
          }
#line 1942
          goto while_break___2;
        }
        {
#line 1942
        tmp___6 = __errno_location();
#line 1942
        *tmp___6 = 0;
#line 1942
        clearerr(yyg->yyin_r);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 1945
    (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_n_chars = yyg->yy_n_chars;
  }
#line 1948
  if (yyg->yy_n_chars == 0) {
#line 1950
    if (number_to_move == 0) {
      {
#line 1952
      ret_val = 1;
#line 1953
      vhdlrestart(yyg->yyin_r, yyscanner);
      }
    } else {
#line 1958
      ret_val = 2;
#line 1959
      (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buffer_status = 2;
    }
  } else {
#line 1965
    ret_val = 0;
  }
#line 1967
  if ((yy_size_t )(yyg->yy_n_chars + number_to_move) > (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buf_size) {
    {
#line 1969
    new_size = (yy_size_t )((yyg->yy_n_chars + number_to_move) + (yyg->yy_n_chars >> 1));
#line 1970
    tmp___10 = vhdlrealloc((void *)(*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf,
                           new_size, yyscanner);
#line 1970
    (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf = (char *)tmp___10;
    }
#line 1971
    if (! (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf) {
      {
#line 1972
      yy_fatal_error("out of dynamic memory in yy_get_next_buffer()", yyscanner);
      }
    }
  }
#line 1975
  yyg->yy_n_chars += number_to_move;
#line 1976
  *((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + yyg->yy_n_chars) = (char)0;
#line 1977
  *((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + (yyg->yy_n_chars + 1)) = (char)0;
#line 1979
  yyg->yytext_r = (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + 0;
#line 1981
  return (ret_val);
}
}
#line 1986 "vhdl_flex.c"
static yy_state_type yy_get_previous_state(yyscan_t yyscanner ) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  struct yyguts_t *yyg ;
  yy_state_type *tmp ;
  register YY_CHAR yy_c ;
  flex_int32_t tmp___0 ;
  yy_state_type *tmp___1 ;

  {
#line 1990
  yyg = (struct yyguts_t *)yyscanner;
#line 1992
  yy_current_state = yyg->yy_start;
#line 1994
  yyg->yy_state_ptr = yyg->yy_state_buf;
#line 1995
  tmp = yyg->yy_state_ptr;
#line 1995
  (yyg->yy_state_ptr) ++;
#line 1995
  *tmp = yy_current_state;
#line 1997
  yy_cp = yyg->yytext_r + 0;
  {
#line 1997
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1997
    if (! ((unsigned long )yy_cp < (unsigned long )yyg->yy_c_buf_p)) {
#line 1997
      goto while_break;
    }
#line 1999
    if (*yy_cp) {
#line 1999
      tmp___0 = yy_ec[(unsigned int )((unsigned char )*yy_cp)];
    } else {
#line 1999
      tmp___0 = (flex_int32_t const   )1;
    }
#line 1999
    yy_c = (YY_CHAR )tmp___0;
    {
#line 2000
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2000
      if (! ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 2000
        goto while_break___0;
      }
#line 2002
      yy_current_state = (int )yy_def[yy_current_state];
#line 2003
      if (yy_current_state >= 352) {
#line 2004
        yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2006
    yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 2007
    tmp___1 = yyg->yy_state_ptr;
#line 2007
    (yyg->yy_state_ptr) ++;
#line 2007
    *tmp___1 = yy_current_state;
#line 1997
    yy_cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2010
  return (yy_current_state);
}
}
#line 2018 "vhdl_flex.c"
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state , yyscan_t yyscanner ) 
{ 
  register int yy_is_jam ;
  struct yyguts_t *yyg ;
  register YY_CHAR yy_c ;
  yy_state_type *tmp ;
  int tmp___0 ;

  {
#line 2021
  yyg = (struct yyguts_t *)yyscanner;
#line 2023
  yy_c = (YY_CHAR )1;
  {
#line 2024
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2024
    if (! ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 2024
      goto while_break;
    }
#line 2026
    yy_current_state = (int )yy_def[yy_current_state];
#line 2027
    if (yy_current_state >= 352) {
#line 2028
      yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2030
  yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 2031
  yy_is_jam = yy_current_state == 351;
#line 2032
  if (! yy_is_jam) {
#line 2033
    tmp = yyg->yy_state_ptr;
#line 2033
    (yyg->yy_state_ptr) ++;
#line 2033
    *tmp = yy_current_state;
  }
#line 2035
  if (yy_is_jam) {
#line 2035
    tmp___0 = 0;
  } else {
#line 2035
    tmp___0 = yy_current_state;
  }
#line 2035
  return (tmp___0);
}
}
#line 2156 "vhdl_flex.c"
void vhdlrestart(FILE *input_file , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 2158
  yyg = (struct yyguts_t *)yyscanner;
#line 2160
  if (yyg->yy_buffer_stack) {
#line 2160
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2160
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2160
  if (! tmp) {
    {
#line 2161
    vhdlensure_buffer_stack(yyscanner);
#line 2162
    *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top) = vhdl_create_buffer(yyg->yyin_r,
                                                                            16384,
                                                                            yyscanner);
    }
  }
#line 2166
  if (yyg->yy_buffer_stack) {
#line 2166
    tmp___0 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2166
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 2166
  vhdl_init_buffer(tmp___0, input_file, yyscanner);
#line 2167
  vhdl_load_buffer_state(yyscanner);
  }
#line 2168
  return;
}
}
#line 2174 "vhdl_flex.c"
void vhdl_switch_to_buffer(YY_BUFFER_STATE new_buffer , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 2176
  yyg = (struct yyguts_t *)yyscanner;
#line 2183
  vhdlensure_buffer_stack(yyscanner);
  }
#line 2184
  if (yyg->yy_buffer_stack) {
#line 2184
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2184
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2184
  if ((unsigned long )tmp == (unsigned long )new_buffer) {
#line 2185
    return;
  }
#line 2187
  if (yyg->yy_buffer_stack) {
#line 2187
    tmp___0 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2187
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 2187
  if (tmp___0) {
#line 2190
    *(yyg->yy_c_buf_p) = yyg->yy_hold_char;
#line 2191
    (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buf_pos = yyg->yy_c_buf_p;
#line 2192
    (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_n_chars = yyg->yy_n_chars;
  }
  {
#line 2195
  *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top) = new_buffer;
#line 2196
  vhdl_load_buffer_state(yyscanner);
#line 2203
  yyg->yy_did_buffer_switch_on_eof = 1;
  }
#line 2204
  return;
}
}
#line 2206 "vhdl_flex.c"
static void vhdl_load_buffer_state(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  char *tmp ;

  {
#line 2208
  yyg = (struct yyguts_t *)yyscanner;
#line 2209
  yyg->yy_n_chars = (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_n_chars;
#line 2210
  tmp = (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buf_pos;
#line 2210
  yyg->yy_c_buf_p = tmp;
#line 2210
  yyg->yytext_r = tmp;
#line 2211
  yyg->yyin_r = (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_input_file;
#line 2212
  yyg->yy_hold_char = *(yyg->yy_c_buf_p);
#line 2213
  return;
}
}
#line 2221 "vhdl_flex.c"
YY_BUFFER_STATE vhdl_create_buffer(FILE *file , int size , yyscan_t yyscanner ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  void *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 2225
  tmp = vhdlalloc((yy_size_t )sizeof(struct yy_buffer_state ), yyscanner);
#line 2225
  b = (YY_BUFFER_STATE )tmp;
  }
#line 2226
  if (! b) {
    {
#line 2227
    yy_fatal_error("out of dynamic memory in vhdl_create_buffer()", yyscanner);
    }
  }
  {
#line 2229
  b->yy_buf_size = (yy_size_t )size;
#line 2234
  tmp___0 = vhdlalloc(b->yy_buf_size + 2U, yyscanner);
#line 2234
  b->yy_ch_buf = (char *)tmp___0;
  }
#line 2235
  if (! b->yy_ch_buf) {
    {
#line 2236
    yy_fatal_error("out of dynamic memory in vhdl_create_buffer()", yyscanner);
    }
  }
  {
#line 2238
  b->yy_is_our_buffer = 1;
#line 2240
  vhdl_init_buffer(b, file, yyscanner);
  }
#line 2242
  return (b);
}
}
#line 2249 "vhdl_flex.c"
void vhdl_delete_buffer(YY_BUFFER_STATE b , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;

  {
#line 2251
  yyg = (struct yyguts_t *)yyscanner;
#line 2253
  if (! b) {
#line 2254
    return;
  }
#line 2256
  if (yyg->yy_buffer_stack) {
#line 2256
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2256
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2256
  if ((unsigned long )b == (unsigned long )tmp) {
#line 2257
    *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top) = (YY_BUFFER_STATE )0;
  }
#line 2259
  if (b->yy_is_our_buffer) {
    {
#line 2260
    vhdlfree((void *)b->yy_ch_buf, yyscanner);
    }
  }
  {
#line 2262
  vhdlfree((void *)b, yyscanner);
  }
#line 2263
  return;
}
}
#line 2273 "vhdl_flex.c"
static void vhdl_init_buffer(YY_BUFFER_STATE b , FILE *file , yyscan_t yyscanner ) 
{ 
  int oerrno ;
  int *tmp ;
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 2276
  tmp = __errno_location();
#line 2276
  oerrno = *tmp;
#line 2277
  yyg = (struct yyguts_t *)yyscanner;
#line 2279
  vhdl_flush_buffer(b, yyscanner);
#line 2281
  b->yy_input_file = file;
#line 2282
  b->yy_fill_buffer = 1;
  }
#line 2288
  if (yyg->yy_buffer_stack) {
#line 2288
    tmp___0 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2288
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 2288
  if ((unsigned long )b != (unsigned long )tmp___0) {
#line 2289
    b->yy_bs_lineno = 1;
#line 2290
    b->yy_bs_column = 0;
  }
#line 2293
  if (file) {
    {
#line 2293
    tmp___1 = fileno(file);
#line 2293
    tmp___2 = isatty(tmp___1);
#line 2293
    b->yy_is_interactive = tmp___2 > 0;
    }
  } else {
#line 2293
    b->yy_is_interactive = 0;
  }
  {
#line 2295
  tmp___3 = __errno_location();
#line 2295
  *tmp___3 = oerrno;
  }
#line 2296
  return;
}
}
#line 2302 "vhdl_flex.c"
void vhdl_flush_buffer(YY_BUFFER_STATE b , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;

  {
#line 2304
  yyg = (struct yyguts_t *)yyscanner;
#line 2305
  if (! b) {
#line 2306
    return;
  }
#line 2308
  b->yy_n_chars = 0;
#line 2314
  *(b->yy_ch_buf + 0) = (char)0;
#line 2315
  *(b->yy_ch_buf + 1) = (char)0;
#line 2317
  b->yy_buf_pos = b->yy_ch_buf + 0;
#line 2319
  b->yy_at_bol = 1;
#line 2320
  b->yy_buffer_status = 0;
#line 2322
  if (yyg->yy_buffer_stack) {
#line 2322
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2322
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2322
  if ((unsigned long )b == (unsigned long )tmp) {
    {
#line 2323
    vhdl_load_buffer_state(yyscanner);
    }
  }
#line 2324
  return;
}
}
#line 2332 "vhdl_flex.c"
void vhdlpush_buffer_state(YY_BUFFER_STATE new_buffer , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 2334
  yyg = (struct yyguts_t *)yyscanner;
#line 2335
  if ((unsigned long )new_buffer == (unsigned long )((void *)0)) {
#line 2336
    return;
  }
  {
#line 2338
  vhdlensure_buffer_stack(yyscanner);
  }
#line 2341
  if (yyg->yy_buffer_stack) {
#line 2341
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2341
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2341
  if (tmp) {
#line 2344
    *(yyg->yy_c_buf_p) = yyg->yy_hold_char;
#line 2345
    (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buf_pos = yyg->yy_c_buf_p;
#line 2346
    (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_n_chars = yyg->yy_n_chars;
  }
#line 2350
  if (yyg->yy_buffer_stack) {
#line 2350
    tmp___0 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2350
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 2350
  if (tmp___0) {
#line 2351
    (yyg->yy_buffer_stack_top) ++;
  }
  {
#line 2352
  *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top) = new_buffer;
#line 2355
  vhdl_load_buffer_state(yyscanner);
#line 2356
  yyg->yy_did_buffer_switch_on_eof = 1;
  }
#line 2357
  return;
}
}
#line 2363 "vhdl_flex.c"
void vhdlpop_buffer_state(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;
  YY_BUFFER_STATE tmp___1 ;

  {
#line 2365
  yyg = (struct yyguts_t *)yyscanner;
#line 2366
  if (yyg->yy_buffer_stack) {
#line 2366
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2366
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2366
  if (! tmp) {
#line 2367
    return;
  }
#line 2369
  if (yyg->yy_buffer_stack) {
#line 2369
    tmp___0 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2369
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 2369
  vhdl_delete_buffer(tmp___0, yyscanner);
#line 2370
  *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top) = (YY_BUFFER_STATE )((void *)0);
  }
#line 2371
  if (yyg->yy_buffer_stack_top > 0U) {
#line 2372
    (yyg->yy_buffer_stack_top) --;
  }
#line 2374
  if (yyg->yy_buffer_stack) {
#line 2374
    tmp___1 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2374
    tmp___1 = (YY_BUFFER_STATE )((void *)0);
  }
#line 2374
  if (tmp___1) {
    {
#line 2375
    vhdl_load_buffer_state(yyscanner);
#line 2376
    yyg->yy_did_buffer_switch_on_eof = 1;
    }
  }
#line 2378
  return;
}
}
#line 2383 "vhdl_flex.c"
static void vhdlensure_buffer_stack(yyscan_t yyscanner ) 
{ 
  int num_to_alloc ;
  struct yyguts_t *yyg ;
  void *tmp ;
  int grow_size ;
  void *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 2386
  yyg = (struct yyguts_t *)yyscanner;
#line 2388
  if (! yyg->yy_buffer_stack) {
    {
#line 2394
    num_to_alloc = 1;
#line 2395
    tmp = vhdlalloc((yy_size_t )((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *)),
                    yyscanner);
#line 2395
    yyg->yy_buffer_stack = (struct yy_buffer_state **)tmp;
    }
#line 2398
    if (! yyg->yy_buffer_stack) {
      {
#line 2399
      yy_fatal_error("out of dynamic memory in vhdlensure_buffer_stack()", yyscanner);
      }
    }
    {
#line 2401
    memset((void *)yyg->yy_buffer_stack, 0, (size_t )((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *)));
#line 2403
    yyg->yy_buffer_stack_max = (size_t )num_to_alloc;
#line 2404
    yyg->yy_buffer_stack_top = (size_t )0;
    }
#line 2405
    return;
  }
#line 2408
  if (yyg->yy_buffer_stack_top >= yyg->yy_buffer_stack_max - 1U) {
    {
#line 2411
    grow_size = 8;
#line 2413
    num_to_alloc = (int )(yyg->yy_buffer_stack_max + (size_t )grow_size);
#line 2414
    tmp___0 = vhdlrealloc((void *)yyg->yy_buffer_stack, (yy_size_t )((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *)),
                          yyscanner);
#line 2414
    yyg->yy_buffer_stack = (struct yy_buffer_state **)tmp___0;
    }
#line 2418
    if (! yyg->yy_buffer_stack) {
      {
#line 2419
      yy_fatal_error("out of dynamic memory in vhdlensure_buffer_stack()", yyscanner);
      }
    }
    {
#line 2422
    memset((void *)(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max), 0, (size_t )((unsigned long )grow_size * sizeof(struct yy_buffer_state *)));
#line 2423
    yyg->yy_buffer_stack_max = (size_t )num_to_alloc;
    }
  }
#line 2425
  return;
}
}
#line 2433 "vhdl_flex.c"
YY_BUFFER_STATE vhdl_scan_buffer(char *base , yy_size_t size , yyscan_t yyscanner ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  char *tmp___0 ;
  char *__cil_tmp7 ;

  {
#line 2437
  if (size < 2U) {
#line 2441
    return ((YY_BUFFER_STATE )0);
  } else
#line 2437
  if ((int )*(base + (size - 2U)) != 0) {
#line 2441
    return ((YY_BUFFER_STATE )0);
  } else
#line 2437
  if ((int )*(base + (size - 1U)) != 0) {
#line 2441
    return ((YY_BUFFER_STATE )0);
  }
  {
#line 2443
  tmp = vhdlalloc((yy_size_t )sizeof(struct yy_buffer_state ), yyscanner);
#line 2443
  b = (YY_BUFFER_STATE )tmp;
  }
#line 2444
  if (! b) {
    {
#line 2445
    yy_fatal_error("out of dynamic memory in vhdl_scan_buffer()", yyscanner);
    }
  }
  {
#line 2447
  b->yy_buf_size = size - 2U;
#line 2448
  tmp___0 = base;
#line 2448
  b->yy_ch_buf = tmp___0;
#line 2448
  b->yy_buf_pos = tmp___0;
#line 2449
  b->yy_is_our_buffer = 0;
#line 2450
  b->yy_input_file = (FILE *)0;
#line 2451
  b->yy_n_chars = (int )b->yy_buf_size;
#line 2452
  b->yy_is_interactive = 0;
#line 2453
  b->yy_at_bol = 1;
#line 2454
  b->yy_fill_buffer = 0;
#line 2455
  b->yy_buffer_status = 0;
#line 2457
  vhdl_switch_to_buffer(b, yyscanner);
  }
#line 2459
  return (b);
}
}
#line 2470 "vhdl_flex.c"
YY_BUFFER_STATE vhdl_scan_string(char const   *yystr , yyscan_t yyscanner ) 
{ 
  size_t tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 2473
  tmp = strlen(yystr);
#line 2473
  tmp___0 = vhdl_scan_bytes(yystr, (int )tmp, yyscanner);
  }
#line 2473
  return (tmp___0);
}
}
#line 2483 "vhdl_flex.c"
YY_BUFFER_STATE vhdl_scan_bytes(char const   *yybytes , int _yybytes_len , yyscan_t yyscanner ) 
{ 
  YY_BUFFER_STATE b ;
  char *buf ;
  yy_size_t n ;
  int i ;
  void *tmp ;
  char tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 2491
  n = (yy_size_t )(_yybytes_len + 2);
#line 2492
  tmp = vhdlalloc(n, yyscanner);
#line 2492
  buf = (char *)tmp;
  }
#line 2493
  if (! buf) {
    {
#line 2494
    yy_fatal_error("out of dynamic memory in vhdl_scan_bytes()", yyscanner);
    }
  }
#line 2496
  i = 0;
  {
#line 2496
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2496
    if (! (i < _yybytes_len)) {
#line 2496
      goto while_break;
    }
#line 2497
    *(buf + i) = (char )*(yybytes + i);
#line 2496
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2499
  tmp___0 = (char)0;
#line 2499
  *(buf + (_yybytes_len + 1)) = tmp___0;
#line 2499
  *(buf + _yybytes_len) = tmp___0;
#line 2501
  b = vhdl_scan_buffer(buf, n, yyscanner);
  }
#line 2502
  if (! b) {
    {
#line 2503
    yy_fatal_error("bad buffer in vhdl_scan_bytes()", yyscanner);
    }
  }
#line 2508
  b->yy_is_our_buffer = 1;
#line 2510
  return (b);
}
}
#line 2517 "vhdl_flex.c"
static void yy_fatal_error(char const   *msg , yyscan_t yyscanner ) 
{ 
  char *__cil_tmp3 ;

  {
  {
#line 2519
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          msg);
#line 2520
  exit(2);
  }
}
}
#line 2545 "vhdl_flex.c"
scan_extra_t *vhdlget_extra(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 2547
  yyg = (struct yyguts_t *)yyscanner;
#line 2548
  return (yyg->yyextra_r);
}
}
#line 2554 "vhdl_flex.c"
int vhdlget_lineno(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;

  {
#line 2556
  yyg = (struct yyguts_t *)yyscanner;
#line 2558
  if (yyg->yy_buffer_stack) {
#line 2558
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2558
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2558
  if (! tmp) {
#line 2559
    return (0);
  }
#line 2561
  return ((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_bs_lineno);
}
}
#line 2567 "vhdl_flex.c"
int vhdlget_column(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;

  {
#line 2569
  yyg = (struct yyguts_t *)yyscanner;
#line 2571
  if (yyg->yy_buffer_stack) {
#line 2571
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2571
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2571
  if (! tmp) {
#line 2572
    return (0);
  }
#line 2574
  return ((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_bs_column);
}
}
#line 2580 "vhdl_flex.c"
FILE *vhdlget_in(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 2582
  yyg = (struct yyguts_t *)yyscanner;
#line 2583
  return (yyg->yyin_r);
}
}
#line 2589 "vhdl_flex.c"
FILE *vhdlget_out(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 2591
  yyg = (struct yyguts_t *)yyscanner;
#line 2592
  return (yyg->yyout_r);
}
}
#line 2598 "vhdl_flex.c"
int vhdlget_leng(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 2600
  yyg = (struct yyguts_t *)yyscanner;
#line 2601
  return (yyg->yyleng_r);
}
}
#line 2608 "vhdl_flex.c"
char *vhdlget_text(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 2610
  yyg = (struct yyguts_t *)yyscanner;
#line 2611
  return (yyg->yytext_r);
}
}
#line 2618 "vhdl_flex.c"
void vhdlset_extra(scan_extra_t *user_defined , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 2620
  yyg = (struct yyguts_t *)yyscanner;
#line 2621
  yyg->yyextra_r = user_defined;
#line 2622
  return;
}
}
#line 2628 "vhdl_flex.c"
void vhdlset_lineno(int line_number , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;
  char *__cil_tmp5 ;

  {
#line 2630
  yyg = (struct yyguts_t *)yyscanner;
#line 2633
  if (yyg->yy_buffer_stack) {
#line 2633
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2633
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2633
  if (! tmp) {
    {
#line 2634
    yy_fatal_error("vhdlset_lineno called with no buffer", yyscanner);
    }
  }
#line 2636
  (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_bs_lineno = line_number;
#line 2637
  return;
}
}
#line 2643 "vhdl_flex.c"
void vhdlset_column(int column_no , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;
  char *__cil_tmp5 ;

  {
#line 2645
  yyg = (struct yyguts_t *)yyscanner;
#line 2648
  if (yyg->yy_buffer_stack) {
#line 2648
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2648
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2648
  if (! tmp) {
    {
#line 2649
    yy_fatal_error("vhdlset_column called with no buffer", yyscanner);
    }
  }
#line 2651
  (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_bs_column = column_no;
#line 2652
  return;
}
}
#line 2660 "vhdl_flex.c"
void vhdlset_in(FILE *in_str , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 2662
  yyg = (struct yyguts_t *)yyscanner;
#line 2663
  yyg->yyin_r = in_str;
#line 2664
  return;
}
}
#line 2666 "vhdl_flex.c"
void vhdlset_out(FILE *out_str , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 2668
  yyg = (struct yyguts_t *)yyscanner;
#line 2669
  yyg->yyout_r = out_str;
#line 2670
  return;
}
}
#line 2672 "vhdl_flex.c"
int vhdlget_debug(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 2674
  yyg = (struct yyguts_t *)yyscanner;
#line 2675
  return (yyg->yy_flex_debug_r);
}
}
#line 2678 "vhdl_flex.c"
void vhdlset_debug(int bdebug , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 2680
  yyg = (struct yyguts_t *)yyscanner;
#line 2681
  yyg->yy_flex_debug_r = bdebug;
#line 2682
  return;
}
}
#line 2686 "vhdl_flex.c"
YYSTYPE *vhdlget_lval(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 2688
  yyg = (struct yyguts_t *)yyscanner;
#line 2689
  return (yyg->yylval_r);
}
}
#line 2692 "vhdl_flex.c"
void vhdlset_lval(YYSTYPE *yylval_param , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 2694
  yyg = (struct yyguts_t *)yyscanner;
#line 2695
  yyg->yylval_r = yylval_param;
#line 2696
  return;
}
}
#line 2705 "vhdl_flex.c"
int vhdllex_init(yyscan_t *ptr_yy_globals ) 
{ 
  int *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
#line 2708
  if ((unsigned long )ptr_yy_globals == (unsigned long )((void *)0)) {
    {
#line 2709
    tmp = __errno_location();
#line 2709
    *tmp = 22;
    }
#line 2710
    return (1);
  }
  {
#line 2713
  tmp___0 = vhdlalloc((yy_size_t )sizeof(struct yyguts_t ), (void *)0);
#line 2713
  *ptr_yy_globals = tmp___0;
  }
#line 2715
  if ((unsigned long )*ptr_yy_globals == (unsigned long )((void *)0)) {
    {
#line 2716
    tmp___1 = __errno_location();
#line 2716
    *tmp___1 = 12;
    }
#line 2717
    return (1);
  }
  {
#line 2721
  memset(*ptr_yy_globals, 0, (size_t )sizeof(struct yyguts_t ));
#line 2723
  tmp___2 = yy_init_globals(*ptr_yy_globals);
  }
#line 2723
  return (tmp___2);
}
}
#line 2734 "vhdl_flex.c"
int vhdllex_init_extra(scan_extra_t *yy_user_defined , yyscan_t *ptr_yy_globals ) 
{ 
  struct yyguts_t dummy_yyguts ;
  int *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 2739
  vhdlset_extra(yy_user_defined, (yyscan_t )(& dummy_yyguts));
  }
#line 2741
  if ((unsigned long )ptr_yy_globals == (unsigned long )((void *)0)) {
    {
#line 2742
    tmp = __errno_location();
#line 2742
    *tmp = 22;
    }
#line 2743
    return (1);
  }
  {
#line 2746
  tmp___0 = vhdlalloc((yy_size_t )sizeof(struct yyguts_t ), (yyscan_t )(& dummy_yyguts));
#line 2746
  *ptr_yy_globals = tmp___0;
  }
#line 2748
  if ((unsigned long )*ptr_yy_globals == (unsigned long )((void *)0)) {
    {
#line 2749
    tmp___1 = __errno_location();
#line 2749
    *tmp___1 = 12;
    }
#line 2750
    return (1);
  }
  {
#line 2755
  memset(*ptr_yy_globals, 0, (size_t )sizeof(struct yyguts_t ));
#line 2757
  vhdlset_extra(yy_user_defined, *ptr_yy_globals);
#line 2759
  tmp___2 = yy_init_globals(*ptr_yy_globals);
  }
#line 2759
  return (tmp___2);
}
}
#line 2762 "vhdl_flex.c"
static int yy_init_globals(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 2764
  yyg = (struct yyguts_t *)yyscanner;
#line 2769
  yyg->yy_buffer_stack = (YY_BUFFER_STATE *)0;
#line 2770
  yyg->yy_buffer_stack_top = (size_t )0;
#line 2771
  yyg->yy_buffer_stack_max = (size_t )0;
#line 2772
  yyg->yy_c_buf_p = (char *)0;
#line 2773
  yyg->yy_init = 0;
#line 2774
  yyg->yy_start = 0;
#line 2776
  yyg->yy_start_stack_ptr = 0;
#line 2777
  yyg->yy_start_stack_depth = 0;
#line 2778
  yyg->yy_start_stack = (int *)((void *)0);
#line 2780
  yyg->yy_state_buf = (yy_state_type *)0;
#line 2781
  yyg->yy_state_ptr = (yy_state_type *)0;
#line 2782
  yyg->yy_full_match = (char *)0;
#line 2783
  yyg->yy_lp = 0;
#line 2790
  yyg->yyin_r = (FILE *)0;
#line 2791
  yyg->yyout_r = (FILE *)0;
#line 2797
  return (0);
}
}
#line 2801 "vhdl_flex.c"
int vhdllex_destroy(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 2803
  yyg = (struct yyguts_t *)yyscanner;
  {
#line 2806
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2806
    if (yyg->yy_buffer_stack) {
#line 2806
      tmp___0 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
    } else {
#line 2806
      tmp___0 = (YY_BUFFER_STATE )((void *)0);
    }
#line 2806
    if (! tmp___0) {
#line 2806
      goto while_break;
    }
#line 2807
    if (yyg->yy_buffer_stack) {
#line 2807
      tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
    } else {
#line 2807
      tmp = (YY_BUFFER_STATE )((void *)0);
    }
    {
#line 2807
    vhdl_delete_buffer(tmp, yyscanner);
#line 2808
    *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top) = (YY_BUFFER_STATE )((void *)0);
#line 2809
    vhdlpop_buffer_state(yyscanner);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2813
  vhdlfree((void *)yyg->yy_buffer_stack, yyscanner);
#line 2814
  yyg->yy_buffer_stack = (YY_BUFFER_STATE *)((void *)0);
#line 2817
  vhdlfree((void *)yyg->yy_start_stack, yyscanner);
#line 2818
  yyg->yy_start_stack = (int *)((void *)0);
#line 2820
  vhdlfree((void *)yyg->yy_state_buf, yyscanner);
#line 2821
  yyg->yy_state_buf = (yy_state_type *)((void *)0);
#line 2825
  yy_init_globals(yyscanner);
#line 2828
  vhdlfree(yyscanner, yyscanner);
#line 2829
  yyscanner = (void *)0;
  }
#line 2830
  return (0);
}
}
#line 2857 "vhdl_flex.c"
void *vhdlalloc(yy_size_t size , yyscan_t yyscanner ) 
{ 
  void *tmp ;

  {
  {
#line 2859
  tmp = malloc(size);
  }
#line 2859
  return (tmp);
}
}
#line 2862 "vhdl_flex.c"
void *vhdlrealloc(void *ptr , yy_size_t size , yyscan_t yyscanner ) 
{ 
  void *tmp ;

  {
  {
#line 2871
  tmp = realloc((void *)((char *)ptr), size);
  }
#line 2871
  return (tmp);
}
}
#line 2874 "vhdl_flex.c"
void vhdlfree(void *ptr , yyscan_t yyscanner ) 
{ 


  {
  {
#line 2876
  free((void *)((char *)ptr));
  }
#line 2877
  return;
}
}
#line 357 "vhdl_flex.l"
void *vhdl_flex_init(FILE *f , int proc_mode ) 
{ 
  scan_extra_t *extra ;
  yyscan_t scanner ;
  int tmp ;
  void *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 363
  tmp = vhdllex_init(& scanner);
  }
#line 363
  if (tmp != 0) {
    {
#line 365
    bsdl_msg(proc_mode, 3, "Scanner could not be initialized\n");
    }
#line 366
    return ((void *)0);
  }
  {
#line 368
  vhdlset_in(f, scanner);
#line 370
  tmp___0 = malloc((size_t )sizeof(scan_extra_t ));
#line 370
  extra = (scan_extra_t *)tmp___0;
  }
#line 370
  if (! extra) {
    {
#line 372
    bsdl_msg(proc_mode, 3, "Out of memory, %s line %i\n", "vhdl_flex.l", 373);
#line 374
    vhdllex_destroy(scanner);
    }
#line 375
    return ((void *)0);
  }
  {
#line 378
  extra->proc_mode = proc_mode;
#line 379
  extra->Compile_Errors = 0;
#line 380
  extra->Base = 1;
#line 382
  vhdlset_extra(extra, scanner);
  }
#line 384
  return (scanner);
}
}
#line 399 "vhdl_flex.l"
void vhdl_flex_deinit(void *scanner ) 
{ 
  FILE *tmp ;
  FILE *tmp___0 ;
  scan_extra_t *tmp___1 ;

  {
  {
#line 401
  tmp___0 = vhdlget_in(scanner);
  }
#line 401
  if (tmp___0) {
    {
#line 405
    tmp = vhdlget_in(scanner);
#line 405
    fclose(tmp);
#line 406
    vhdlset_in((FILE *)((void *)0), scanner);
    }
  }
  {
#line 408
  tmp___1 = vhdlget_extra(scanner);
#line 408
  free((void *)tmp___1);
#line 409
  vhdllex_destroy(scanner);
  }
#line 410
  return;
}
}
#line 424 "vhdl_flex.l"
int vhdlwrap(yyscan_t scanner ) 
{ 
  FILE *tmp ;
  FILE *tmp___0 ;

  {
  {
#line 426
  tmp___0 = vhdlget_in(scanner);
  }
#line 426
  if (tmp___0) {
    {
#line 428
    tmp = vhdlget_in(scanner);
#line 428
    fclose(tmp);
#line 429
    vhdlset_in((FILE *)((void *)0), scanner);
    }
  }
#line 431
  return (1);
}
}
#line 447 "vhdl_flex.l"
static char *new_string(scan_extra_t *extra , char const   *str ) 
{ 
  char *n_str ;
  size_t n_str_size ;
  size_t tmp ;
  void *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 452
  tmp = strlen(str);
#line 452
  n_str_size = tmp + 1U;
#line 453
  tmp___0 = malloc(n_str_size);
#line 453
  n_str = (char *)tmp___0;
  }
#line 453
  if (n_str) {
    {
#line 455
    strncpy((char */* __restrict  */)n_str, (char const   */* __restrict  */)str,
            n_str_size - 1U);
#line 456
    *(n_str + (n_str_size - 1U)) = (char )'\000';
    }
  } else {
    {
#line 459
    bsdl_msg(extra->proc_mode, 3, "Out of memory, %s line %i\n", "vhdl_flex.l", 460);
    }
  }
#line 462
  return (n_str);
}
}
#line 478 "vhdl_flex.l"
void vhdl_flex_switch_file(void *scanner , char *filename ) 
{ 
  scan_extra_t *extra ;
  FILE *f ;
  char *s ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  char const   *db_path ;
  char const   *tmp___1 ;
  char *db_file ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  YY_BUFFER_STATE tmp___5 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 485
  s = filename;
  {
#line 486
  while (1) {
    while_continue: /* CIL Label */ ;
#line 486
    if (! *s) {
#line 486
      goto while_break;
    }
    {
#line 488
    tmp___0 = __ctype_b_loc();
    }
#line 488
    if ((int const   )*(*tmp___0 + (int )*s) & 512) {
      {
#line 489
      tmp = toupper((int )*s);
#line 489
      *s = (char )tmp;
      }
    }
#line 490
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 493
  extra = vhdlget_extra(scanner);
#line 496
  f = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 497
  if (! f) {
    {
#line 499
    tmp___1 = jtag_get_data_dir();
#line 499
    db_path = tmp___1;
#line 502
    tmp___2 = strlen(db_path);
#line 502
    tmp___3 = strlen((char const   *)filename);
#line 502
    tmp___4 = malloc(((((tmp___2 + 1U) + 4U) + 1U) + tmp___3) + 1U);
#line 502
    db_file = (char *)tmp___4;
    }
#line 502
    if (db_file) {
      {
#line 509
      strcpy((char */* __restrict  */)db_file, (char const   */* __restrict  */)db_path);
#line 510
      strcat((char */* __restrict  */)db_file, (char const   */* __restrict  */)"/");
#line 511
      strcat((char */* __restrict  */)db_file, (char const   */* __restrict  */)"bsdl");
#line 512
      strcat((char */* __restrict  */)db_file, (char const   */* __restrict  */)"/");
#line 513
      strcat((char */* __restrict  */)db_file, (char const   */* __restrict  */)filename);
#line 514
      f = fopen((char const   */* __restrict  */)db_file, (char const   */* __restrict  */)"r");
      }
#line 516
      if (! f) {
        {
#line 517
        bsdl_msg(extra->proc_mode, 3, "Cannot open file %s or %s.\n", filename, db_file);
        }
      }
      {
#line 519
      free((void *)db_file);
      }
#line 520
      if (! f) {
#line 521
        return;
      }
    }
  }
  {
#line 525
  tmp___5 = vhdl_create_buffer(f, 16384, scanner);
#line 525
  vhdlpush_buffer_state(tmp___5, scanner);
#line 526
  vhdlset_lineno(1, scanner);
  }
#line 527
  return;
}
}
#line 541 "vhdl_flex.l"
int vhdl_flex_get_compile_errors(void *scanner ) 
{ 
  scan_extra_t *extra ;
  scan_extra_t *tmp ;

  {
  {
#line 543
  tmp = vhdlget_extra(scanner);
#line 543
  extra = tmp;
  }
#line 544
  return (extra->Compile_Errors);
}
}
#line 560 "vhdl_flex.l"
static void vhdl_flex_set_compile_errors(int n , yyscan_t scanner ) 
{ 
  scan_extra_t *extra ;
  scan_extra_t *tmp ;

  {
  {
#line 562
  tmp = vhdlget_extra(scanner);
#line 562
  extra = tmp;
#line 563
  extra->Compile_Errors = n;
  }
#line 564
  return;
}
}
#line 578 "vhdl_flex.l"
int vhdl_flex_postinc_compile_errors(void *scanner ) 
{ 
  int errors ;
  int tmp ;

  {
  {
#line 580
  tmp = vhdl_flex_get_compile_errors(scanner);
#line 580
  errors = tmp;
#line 582
  vhdl_flex_set_compile_errors(errors + 1, scanner);
  }
#line 583
  return (errors);
}
}
#line 598 "vhdl_flex.l"
int vhdl_flex_get_lineno(void *scanner ) 
{ 
  int tmp ;

  {
  {
#line 600
  tmp = vhdlget_lineno(scanner);
  }
#line 600
  return (tmp);
}
}
/* compiler builtin: 
   void *__builtin_memcpy(void * , void const   * , unsigned long  ) ;  */
#line 173 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcasecmp)(char const   *__s1 ,
                                                                                         char const   *__s2 )  __attribute__((__pure__)) ;
#line 363 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 39 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bsdl/vhdl_parser.h"
vhdl_parser_priv_t *vhdl_parser_init(FILE *f , jtag_ctrl_t *jtag_ctrl ) ;
#line 40
void vhdl_parser_deinit(vhdl_parser_priv_t *priv_data ) ;
#line 41
int vhdlparse(vhdl_parser_priv_t *priv_data ) ;
#line 155 "vhdl_bison.y"
static void Init_Text(vhdl_parser_priv_t *priv ) ;
#line 156
static void Store_Text(vhdl_parser_priv_t *priv , char *Source ) ;
#line 157
static void Print_Error(vhdl_parser_priv_t *priv_data , char const   *Errmess ) ;
#line 158
static void Give_Up_And_Quit(vhdl_parser_priv_t *priv_data ) ;
#line 161
static void vhdl_set_entity(vhdl_parser_priv_t *priv , char *entityname ) ;
#line 162
static void vhdl_port_add_name(vhdl_parser_priv_t *priv , char *name ) ;
#line 163
static void vhdl_port_add_bit(vhdl_parser_priv_t *priv ) ;
#line 164
static void vhdl_port_add_range(vhdl_parser_priv_t *priv , int low , int high ) ;
#line 165
static void vhdl_port_apply_port(vhdl_parser_priv_t *priv ) ;
#line 168
static void set_attr_decimal(vhdl_parser_priv_t *priv , char *name , int value ) ;
#line 169
static void set_attr_string(vhdl_parser_priv_t *priv , char *name , char *string ) ;
#line 173
void vhdlerror(vhdl_parser_priv_t *priv_data , char const   *error_string ) ;
#line 581 "vhdl_bison.c"
static yytype_uint8 const   yytranslate[336]  = 
#line 581 "vhdl_bison.c"
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )11,      (yytype_uint8 const   )12, 
        (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )22,      (yytype_uint8 const   )23,      (yytype_uint8 const   )24, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )26,      (yytype_uint8 const   )27,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )30,      (yytype_uint8 const   )31,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )33,      (yytype_uint8 const   )34,      (yytype_uint8 const   )35,      (yytype_uint8 const   )36, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )38,      (yytype_uint8 const   )39,      (yytype_uint8 const   )40, 
        (yytype_uint8 const   )41,      (yytype_uint8 const   )42,      (yytype_uint8 const   )43,      (yytype_uint8 const   )44, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )46,      (yytype_uint8 const   )47,      (yytype_uint8 const   )48, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )50,      (yytype_uint8 const   )51,      (yytype_uint8 const   )52, 
        (yytype_uint8 const   )53,      (yytype_uint8 const   )54,      (yytype_uint8 const   )55,      (yytype_uint8 const   )56, 
        (yytype_uint8 const   )57,      (yytype_uint8 const   )58,      (yytype_uint8 const   )59,      (yytype_uint8 const   )60, 
        (yytype_uint8 const   )61,      (yytype_uint8 const   )62,      (yytype_uint8 const   )63,      (yytype_uint8 const   )64, 
        (yytype_uint8 const   )65,      (yytype_uint8 const   )66,      (yytype_uint8 const   )67,      (yytype_uint8 const   )68, 
        (yytype_uint8 const   )69,      (yytype_uint8 const   )70,      (yytype_uint8 const   )71,      (yytype_uint8 const   )72, 
        (yytype_uint8 const   )73,      (yytype_uint8 const   )74,      (yytype_uint8 const   )75,      (yytype_uint8 const   )76, 
        (yytype_uint8 const   )77,      (yytype_uint8 const   )78,      (yytype_uint8 const   )79,      (yytype_uint8 const   )80};
#line 773 "vhdl_bison.c"
static yytype_uint8 const   yyr1[146]  = 
#line 773
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )81,      (yytype_uint8 const   )82,      (yytype_uint8 const   )83, 
        (yytype_uint8 const   )83,      (yytype_uint8 const   )84,      (yytype_uint8 const   )84,      (yytype_uint8 const   )85, 
        (yytype_uint8 const   )85,      (yytype_uint8 const   )86,      (yytype_uint8 const   )87,      (yytype_uint8 const   )87, 
        (yytype_uint8 const   )88,      (yytype_uint8 const   )88,      (yytype_uint8 const   )89,      (yytype_uint8 const   )90, 
        (yytype_uint8 const   )90,      (yytype_uint8 const   )91,      (yytype_uint8 const   )91,      (yytype_uint8 const   )91, 
        (yytype_uint8 const   )91,      (yytype_uint8 const   )91,      (yytype_uint8 const   )92,      (yytype_uint8 const   )92, 
        (yytype_uint8 const   )93,      (yytype_uint8 const   )93,      (yytype_uint8 const   )94,      (yytype_uint8 const   )94, 
        (yytype_uint8 const   )94,      (yytype_uint8 const   )94,      (yytype_uint8 const   )94,      (yytype_uint8 const   )96, 
        (yytype_uint8 const   )97,      (yytype_uint8 const   )95,      (yytype_uint8 const   )98,      (yytype_uint8 const   )98, 
        (yytype_uint8 const   )99,      (yytype_uint8 const   )99,      (yytype_uint8 const   )100,      (yytype_uint8 const   )100, 
        (yytype_uint8 const   )100,      (yytype_uint8 const   )100,      (yytype_uint8 const   )100,      (yytype_uint8 const   )100, 
        (yytype_uint8 const   )101,      (yytype_uint8 const   )101,      (yytype_uint8 const   )101,      (yytype_uint8 const   )101, 
        (yytype_uint8 const   )101,      (yytype_uint8 const   )102,      (yytype_uint8 const   )102,      (yytype_uint8 const   )102, 
        (yytype_uint8 const   )102,      (yytype_uint8 const   )102,      (yytype_uint8 const   )102,      (yytype_uint8 const   )102, 
        (yytype_uint8 const   )103,      (yytype_uint8 const   )103,      (yytype_uint8 const   )104,      (yytype_uint8 const   )104, 
        (yytype_uint8 const   )105,      (yytype_uint8 const   )105,      (yytype_uint8 const   )106,      (yytype_uint8 const   )106, 
        (yytype_uint8 const   )107,      (yytype_uint8 const   )107,      (yytype_uint8 const   )108,      (yytype_uint8 const   )108, 
        (yytype_uint8 const   )109,      (yytype_uint8 const   )110,      (yytype_uint8 const   )110,      (yytype_uint8 const   )111, 
        (yytype_uint8 const   )111,      (yytype_uint8 const   )113,      (yytype_uint8 const   )112,      (yytype_uint8 const   )112, 
        (yytype_uint8 const   )114,      (yytype_uint8 const   )114,      (yytype_uint8 const   )115,      (yytype_uint8 const   )115, 
        (yytype_uint8 const   )116,      (yytype_uint8 const   )116,      (yytype_uint8 const   )117,      (yytype_uint8 const   )117, 
        (yytype_uint8 const   )118,      (yytype_uint8 const   )118,      (yytype_uint8 const   )118,      (yytype_uint8 const   )118, 
        (yytype_uint8 const   )118,      (yytype_uint8 const   )118,      (yytype_uint8 const   )118,      (yytype_uint8 const   )118, 
        (yytype_uint8 const   )118,      (yytype_uint8 const   )118,      (yytype_uint8 const   )118,      (yytype_uint8 const   )119, 
        (yytype_uint8 const   )119,      (yytype_uint8 const   )119,      (yytype_uint8 const   )119,      (yytype_uint8 const   )119, 
        (yytype_uint8 const   )120,      (yytype_uint8 const   )120,      (yytype_uint8 const   )120,      (yytype_uint8 const   )120, 
        (yytype_uint8 const   )120,      (yytype_uint8 const   )120,      (yytype_uint8 const   )120,      (yytype_uint8 const   )120, 
        (yytype_uint8 const   )122,      (yytype_uint8 const   )123,      (yytype_uint8 const   )121,      (yytype_uint8 const   )124, 
        (yytype_uint8 const   )124,      (yytype_uint8 const   )125,      (yytype_uint8 const   )125,      (yytype_uint8 const   )125, 
        (yytype_uint8 const   )126,      (yytype_uint8 const   )126,      (yytype_uint8 const   )127,      (yytype_uint8 const   )128, 
        (yytype_uint8 const   )129,      (yytype_uint8 const   )130,      (yytype_uint8 const   )130,      (yytype_uint8 const   )130, 
        (yytype_uint8 const   )130,      (yytype_uint8 const   )130,      (yytype_uint8 const   )130,      (yytype_uint8 const   )131, 
        (yytype_uint8 const   )132,      (yytype_uint8 const   )132,      (yytype_uint8 const   )133,      (yytype_uint8 const   )134, 
        (yytype_uint8 const   )135,      (yytype_uint8 const   )135,      (yytype_uint8 const   )136,      (yytype_uint8 const   )137, 
        (yytype_uint8 const   )138,      (yytype_uint8 const   )138,      (yytype_uint8 const   )140,      (yytype_uint8 const   )139, 
        (yytype_uint8 const   )141,      (yytype_uint8 const   )141,      (yytype_uint8 const   )142,      (yytype_uint8 const   )144, 
        (yytype_uint8 const   )143,      (yytype_uint8 const   )145};
#line 793 "vhdl_bison.c"
static yytype_uint8 const   yyr2[146]  = 
#line 793
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )4,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )9,      (yytype_uint8 const   )5,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )8,      (yytype_uint8 const   )10,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )5,      (yytype_uint8 const   )5, 
        (yytype_uint8 const   )12,      (yytype_uint8 const   )5,      (yytype_uint8 const   )5,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )5, 
        (yytype_uint8 const   )8,      (yytype_uint8 const   )8,      (yytype_uint8 const   )4,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )4,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )0,      (yytype_uint8 const   )9,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )9,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )7,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )8,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )8,      (yytype_uint8 const   )12, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )8,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )0,      (yytype_uint8 const   )7, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )7};
#line 815 "vhdl_bison.c"
static yytype_uint8 const   yydefact[328]  = 
#line 815
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )4,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )1,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )8,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )11,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )30,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )27,      (yytype_uint8 const   )26,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )7,      (yytype_uint8 const   )15,      (yytype_uint8 const   )0,      (yytype_uint8 const   )12, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )31,      (yytype_uint8 const   )140,      (yytype_uint8 const   )141, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )115,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )113,      (yytype_uint8 const   )116,      (yytype_uint8 const   )117, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )29,      (yytype_uint8 const   )71,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )126, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )120,      (yytype_uint8 const   )121,      (yytype_uint8 const   )122, 
        (yytype_uint8 const   )123,      (yytype_uint8 const   )124,      (yytype_uint8 const   )125,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )118,      (yytype_uint8 const   )114,      (yytype_uint8 const   )108,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )72,      (yytype_uint8 const   )0,      (yytype_uint8 const   )13,      (yytype_uint8 const   )10, 
        (yytype_uint8 const   )16,      (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19, 
        (yytype_uint8 const   )20,      (yytype_uint8 const   )21,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )136,      (yytype_uint8 const   )0,      (yytype_uint8 const   )22,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )14,      (yytype_uint8 const   )0,      (yytype_uint8 const   )138,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )32,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )137,      (yytype_uint8 const   )9, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )139,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )109,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )23,      (yytype_uint8 const   )35,      (yytype_uint8 const   )0,      (yytype_uint8 const   )33, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )142,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )119,      (yytype_uint8 const   )0,      (yytype_uint8 const   )24, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )128, 
        (yytype_uint8 const   )129,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )112, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )110,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )143,      (yytype_uint8 const   )0,      (yytype_uint8 const   )135,      (yytype_uint8 const   )130, 
        (yytype_uint8 const   )134,      (yytype_uint8 const   )0,      (yytype_uint8 const   )127,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )43,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )36,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )0,      (yytype_uint8 const   )66,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )132,      (yytype_uint8 const   )133,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )70,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )68,      (yytype_uint8 const   )0,      (yytype_uint8 const   )67,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )48, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )44,      (yytype_uint8 const   )46,      (yytype_uint8 const   )47, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )55,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )145,      (yytype_uint8 const   )131,      (yytype_uint8 const   )0,      (yytype_uint8 const   )38, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )65,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )62,      (yytype_uint8 const   )0,      (yytype_uint8 const   )61,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )58,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )56,      (yytype_uint8 const   )39,      (yytype_uint8 const   )41,      (yytype_uint8 const   )42, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )144,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )63, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )0,      (yytype_uint8 const   )50,      (yytype_uint8 const   )69, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )75,      (yytype_uint8 const   )0,      (yytype_uint8 const   )111, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )54,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )60,      (yytype_uint8 const   )57, 
        (yytype_uint8 const   )59,      (yytype_uint8 const   )34,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )64,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )51, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )79,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )76, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )52,      (yytype_uint8 const   )53,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )77,      (yytype_uint8 const   )40,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )73,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )74,      (yytype_uint8 const   )0,      (yytype_uint8 const   )83,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )80,      (yytype_uint8 const   )94,      (yytype_uint8 const   )84, 
        (yytype_uint8 const   )85,      (yytype_uint8 const   )86,      (yytype_uint8 const   )88,      (yytype_uint8 const   )89, 
        (yytype_uint8 const   )87,      (yytype_uint8 const   )90,      (yytype_uint8 const   )91,      (yytype_uint8 const   )92, 
        (yytype_uint8 const   )93,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )81,      (yytype_uint8 const   )78,      (yytype_uint8 const   )99, 
        (yytype_uint8 const   )95,      (yytype_uint8 const   )96,      (yytype_uint8 const   )97,      (yytype_uint8 const   )98, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )107,      (yytype_uint8 const   )100, 
        (yytype_uint8 const   )101,      (yytype_uint8 const   )102,      (yytype_uint8 const   )103,      (yytype_uint8 const   )104, 
        (yytype_uint8 const   )105,      (yytype_uint8 const   )106,      (yytype_uint8 const   )0,      (yytype_uint8 const   )82};
#line 853 "vhdl_bison.c"
static yytype_int16 const   yydefgoto[65]  = 
#line 853
  {      (yytype_int16 const   )-1,      (yytype_int16 const   )3,      (yytype_int16 const   )4,      (yytype_int16 const   )9, 
        (yytype_int16 const   )15,      (yytype_int16 const   )10,      (yytype_int16 const   )18,      (yytype_int16 const   )30, 
        (yytype_int16 const   )31,      (yytype_int16 const   )32,      (yytype_int16 const   )78,      (yytype_int16 const   )88, 
        (yytype_int16 const   )105,      (yytype_int16 const   )24,      (yytype_int16 const   )25,      (yytype_int16 const   )53, 
        (yytype_int16 const   )106,      (yytype_int16 const   )119,      (yytype_int16 const   )156,      (yytype_int16 const   )157, 
        (yytype_int16 const   )196,      (yytype_int16 const   )202,      (yytype_int16 const   )222,      (yytype_int16 const   )223, 
        (yytype_int16 const   )224,      (yytype_int16 const   )215,      (yytype_int16 const   )216,      (yytype_int16 const   )169, 
        (yytype_int16 const   )170,      (yytype_int16 const   )184,      (yytype_int16 const   )45,      (yytype_int16 const   )247, 
        (yytype_int16 const   )286,      (yytype_int16 const   )274,      (yytype_int16 const   )275,      (yytype_int16 const   )292, 
        (yytype_int16 const   )293,      (yytype_int16 const   )305,      (yytype_int16 const   )316,      (yytype_int16 const   )326, 
        (yytype_int16 const   )46,      (yytype_int16 const   )83,      (yytype_int16 const   )126,      (yytype_int16 const   )141, 
        (yytype_int16 const   )40,      (yytype_int16 const   )41,      (yytype_int16 const   )42,      (yytype_int16 const   )64, 
        (yytype_int16 const   )43,      (yytype_int16 const   )57,      (yytype_int16 const   )58,      (yytype_int16 const   )138, 
        (yytype_int16 const   )59,      (yytype_int16 const   )60,      (yytype_int16 const   )175,      (yytype_int16 const   )61, 
        (yytype_int16 const   )62,      (yytype_int16 const   )85,      (yytype_int16 const   )26,      (yytype_int16 const   )98, 
        (yytype_int16 const   )36,      (yytype_int16 const   )108,      (yytype_int16 const   )109,      (yytype_int16 const   )158, 
        (yytype_int16 const   )122};
#line 867 "vhdl_bison.c"
static yytype_int16 const   yypact[328]  = 
#line 867
  {      (yytype_int16 const   )142,      (yytype_int16 const   )-159,      (yytype_int16 const   )-13,      (yytype_int16 const   )109, 
        (yytype_int16 const   )129,      (yytype_int16 const   )66,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )62,      (yytype_int16 const   )11,      (yytype_int16 const   )132,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )138,      (yytype_int16 const   )-159,      (yytype_int16 const   )96,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )97,      (yytype_int16 const   )101,      (yytype_int16 const   )98, 
        (yytype_int16 const   )93,      (yytype_int16 const   )106,      (yytype_int16 const   )-159,      (yytype_int16 const   )15, 
        (yytype_int16 const   )107,      (yytype_int16 const   )160,      (yytype_int16 const   )-159,      (yytype_int16 const   )158, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )69,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )70,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )99,      (yytype_int16 const   )-159,      (yytype_int16 const   )13,      (yytype_int16 const   )110, 
        (yytype_int16 const   )131,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )31,      (yytype_int16 const   )165,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )102,      (yytype_int16 const   )106,      (yytype_int16 const   )105,      (yytype_int16 const   )113, 
        (yytype_int16 const   )104,      (yytype_int16 const   )108,      (yytype_int16 const   )164,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )169,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )112, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )117, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )116,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )74,      (yytype_int16 const   )168, 
        (yytype_int16 const   )114,      (yytype_int16 const   )123,      (yytype_int16 const   )171,      (yytype_int16 const   )115, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )64,      (yytype_int16 const   )-159,      (yytype_int16 const   )118, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )119,      (yytype_int16 const   )-159,      (yytype_int16 const   )120, 
        (yytype_int16 const   )121,      (yytype_int16 const   )176,      (yytype_int16 const   )127,      (yytype_int16 const   )125, 
        (yytype_int16 const   )133,      (yytype_int16 const   )-159,      (yytype_int16 const   )166,      (yytype_int16 const   )94, 
        (yytype_int16 const   )116,      (yytype_int16 const   )126,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )90,      (yytype_int16 const   )128,      (yytype_int16 const   )16,      (yytype_int16 const   )75, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )167,      (yytype_int16 const   )192,      (yytype_int16 const   )193, 
        (yytype_int16 const   )92,      (yytype_int16 const   )-159,      (yytype_int16 const   )139,      (yytype_int16 const   )140, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )141,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )194,      (yytype_int16 const   )175,      (yytype_int16 const   )-159,      (yytype_int16 const   )-5, 
        (yytype_int16 const   )17,      (yytype_int16 const   )-159,      (yytype_int16 const   )21,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )199,      (yytype_int16 const   )202,      (yytype_int16 const   )75, 
        (yytype_int16 const   )143,      (yytype_int16 const   )144,      (yytype_int16 const   )95,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )147,      (yytype_int16 const   )146,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )148,      (yytype_int16 const   )-159,      (yytype_int16 const   )30,      (yytype_int16 const   )153, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )201,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )149,      (yytype_int16 const   )-159,      (yytype_int16 const   )208, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )155,      (yytype_int16 const   )-12,      (yytype_int16 const   )-7, 
        (yytype_int16 const   )89,      (yytype_int16 const   )-159,      (yytype_int16 const   )30,      (yytype_int16 const   )207, 
        (yytype_int16 const   )137,      (yytype_int16 const   )210,      (yytype_int16 const   )150,      (yytype_int16 const   )213, 
        (yytype_int16 const   )215,      (yytype_int16 const   )216,      (yytype_int16 const   )217,      (yytype_int16 const   )14, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )89,      (yytype_int16 const   )-159,      (yytype_int16 const   )20, 
        (yytype_int16 const   )75,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )156, 
        (yytype_int16 const   )134,      (yytype_int16 const   )2,      (yytype_int16 const   )191,      (yytype_int16 const   )1, 
        (yytype_int16 const   )218,      (yytype_int16 const   )219,      (yytype_int16 const   )-159,      (yytype_int16 const   )159, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )91,      (yytype_int16 const   )-159,      (yytype_int16 const   )75, 
        (yytype_int16 const   )170,      (yytype_int16 const   )172,      (yytype_int16 const   )173,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )174,      (yytype_int16 const   )162,      (yytype_int16 const   )-159,      (yytype_int16 const   )19, 
        (yytype_int16 const   )163,      (yytype_int16 const   )6,      (yytype_int16 const   )177,      (yytype_int16 const   )178, 
        (yytype_int16 const   )179,      (yytype_int16 const   )190,      (yytype_int16 const   )181,      (yytype_int16 const   )180, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )182,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )198,      (yytype_int16 const   )-159,      (yytype_int16 const   )183,      (yytype_int16 const   )4, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )184,      (yytype_int16 const   )-159,      (yytype_int16 const   )185, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )186,      (yytype_int16 const   )78,      (yytype_int16 const   )79, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )188,      (yytype_int16 const   )189,      (yytype_int16 const   )-159,      (yytype_int16 const   )28, 
        (yytype_int16 const   )200,      (yytype_int16 const   )196,      (yytype_int16 const   )205,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )136,      (yytype_int16 const   )221,      (yytype_int16 const   )197,      (yytype_int16 const   )9, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )203,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )28,      (yytype_int16 const   )-159,      (yytype_int16 const   )220,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )195,      (yytype_int16 const   )204,      (yytype_int16 const   )-159,      (yytype_int16 const   )187, 
        (yytype_int16 const   )206,      (yytype_int16 const   )209,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )211,      (yytype_int16 const   )212, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )214,      (yytype_int16 const   )222,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )228,      (yytype_int16 const   )244,      (yytype_int16 const   )250,      (yytype_int16 const   )252, 
        (yytype_int16 const   )18,      (yytype_int16 const   )224,      (yytype_int16 const   )225,      (yytype_int16 const   )226, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )227,      (yytype_int16 const   )103,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )223,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )229, 
        (yytype_int16 const   )230,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )231, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )232,      (yytype_int16 const   )234,      (yytype_int16 const   )233, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )3,      (yytype_int16 const   )-159,      (yytype_int16 const   )0, 
        (yytype_int16 const   )82,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )235,      (yytype_int16 const   )3,      (yytype_int16 const   )237, 
        (yytype_int16 const   )5,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )238,      (yytype_int16 const   )29,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )239,      (yytype_int16 const   )-159};
#line 905 "vhdl_bison.c"
static yytype_int16 const   yypgoto[65]  = 
#line 905
  {      (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )241,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )145,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-53,      (yytype_int16 const   )-65, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )23,      (yytype_int16 const   )-159,      (yytype_int16 const   )48,      (yytype_int16 const   )135, 
        (yytype_int16 const   )-158,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )22, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-10,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )-39,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )236,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )242,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )-62,      (yytype_int16 const   )245,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )-107,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )-159};
#line 921 "vhdl_bison.c"
static yytype_uint16 const   yytable[311]  = 
#line 921
  {      (yytype_uint16 const   )120,      (yytype_uint16 const   )294,      (yytype_uint16 const   )198,      (yytype_uint16 const   )191, 
        (yytype_uint16 const   )290,      (yytype_uint16 const   )213,      (yytype_uint16 const   )311,      (yytype_uint16 const   )218, 
        (yytype_uint16 const   )165,      (yytype_uint16 const   )132,      (yytype_uint16 const   )218,      (yytype_uint16 const   )186, 
        (yytype_uint16 const   )13,      (yytype_uint16 const   )192,      (yytype_uint16 const   )55,      (yytype_uint16 const   )182, 
        (yytype_uint16 const   )234,      (yytype_uint16 const   )117,      (yytype_uint16 const   )186,      (yytype_uint16 const   )272, 
        (yytype_uint16 const   )213,      (yytype_uint16 const   )152,      (yytype_uint16 const   )139,      (yytype_uint16 const   )14, 
        (yytype_uint16 const   )145,      (yytype_uint16 const   )219,      (yytype_uint16 const   )163,      (yytype_uint16 const   )153, 
        (yytype_uint16 const   )273,      (yytype_uint16 const   )245,      (yytype_uint16 const   )318,      (yytype_uint16 const   )152, 
        (yytype_uint16 const   )187,      (yytype_uint16 const   )135,      (yytype_uint16 const   )136,      (yytype_uint16 const   )199, 
        (yytype_uint16 const   )200,      (yytype_uint16 const   )153,      (yytype_uint16 const   )112,      (yytype_uint16 const   )295, 
        (yytype_uint16 const   )296,      (yytype_uint16 const   )297,      (yytype_uint16 const   )298,      (yytype_uint16 const   )299, 
        (yytype_uint16 const   )300,      (yytype_uint16 const   )301,      (yytype_uint16 const   )118,      (yytype_uint16 const   )302, 
        (yytype_uint16 const   )303,      (yytype_uint16 const   )5,      (yytype_uint16 const   )164,      (yytype_uint16 const   )140, 
        (yytype_uint16 const   )154,      (yytype_uint16 const   )155,      (yytype_uint16 const   )312,      (yytype_uint16 const   )313, 
        (yytype_uint16 const   )314,      (yytype_uint16 const   )315,      (yytype_uint16 const   )246,      (yytype_uint16 const   )84, 
        (yytype_uint16 const   )133,      (yytype_uint16 const   )134,      (yytype_uint16 const   )154,      (yytype_uint16 const   )155, 
        (yytype_uint16 const   )193,      (yytype_uint16 const   )188,      (yytype_uint16 const   )214,      (yytype_uint16 const   )194, 
        (yytype_uint16 const   )220,      (yytype_uint16 const   )221,      (yytype_uint16 const   )166,      (yytype_uint16 const   )201, 
        (yytype_uint16 const   )221,      (yytype_uint16 const   )291,      (yytype_uint16 const   )11,      (yytype_uint16 const   )56, 
        (yytype_uint16 const   )183,      (yytype_uint16 const   )33,      (yytype_uint16 const   )304,      (yytype_uint16 const   )195, 
        (yytype_uint16 const   )207,      (yytype_uint16 const   )214,      (yytype_uint16 const   )319,      (yytype_uint16 const   )320, 
        (yytype_uint16 const   )321,      (yytype_uint16 const   )322,      (yytype_uint16 const   )323,      (yytype_uint16 const   )137, 
        (yytype_uint16 const   )324,      (yytype_uint16 const   )325,      (yytype_uint16 const   )152,      (yytype_uint16 const   )168, 
        (yytype_uint16 const   )152,      (yytype_uint16 const   )66,      (yytype_uint16 const   )34,      (yytype_uint16 const   )35, 
        (yytype_uint16 const   )153,      (yytype_uint16 const   )110,      (yytype_uint16 const   )153,      (yytype_uint16 const   )167, 
        (yytype_uint16 const   )86,      (yytype_uint16 const   )87,      (yytype_uint16 const   )22,      (yytype_uint16 const   )206, 
        (yytype_uint16 const   )272,      (yytype_uint16 const   )171,      (yytype_uint16 const   )168,      (yytype_uint16 const   )23, 
        (yytype_uint16 const   )37,      (yytype_uint16 const   )6,      (yytype_uint16 const   )34,      (yytype_uint16 const   )35, 
        (yytype_uint16 const   )111,      (yytype_uint16 const   )273,      (yytype_uint16 const   )38,      (yytype_uint16 const   )280, 
        (yytype_uint16 const   )185,      (yytype_uint16 const   )39,      (yytype_uint16 const   )114,      (yytype_uint16 const   )115, 
        (yytype_uint16 const   )168,      (yytype_uint16 const   )154,      (yytype_uint16 const   )155,      (yytype_uint16 const   )154, 
        (yytype_uint16 const   )155,      (yytype_uint16 const   )73,      (yytype_uint16 const   )74,      (yytype_uint16 const   )75, 
        (yytype_uint16 const   )76,      (yytype_uint16 const   )77,      (yytype_uint16 const   )7,      (yytype_uint16 const   )94, 
        (yytype_uint16 const   )12,      (yytype_uint16 const   )16,      (yytype_uint16 const   )8,      (yytype_uint16 const   )95, 
        (yytype_uint16 const   )17,      (yytype_uint16 const   )49,      (yytype_uint16 const   )38,      (yytype_uint16 const   )51, 
        (yytype_uint16 const   )50,      (yytype_uint16 const   )39,      (yytype_uint16 const   )52,      (yytype_uint16 const   )1, 
        (yytype_uint16 const   )167,      (yytype_uint16 const   )2,      (yytype_uint16 const   )190,      (yytype_uint16 const   )239, 
        (yytype_uint16 const   )241,      (yytype_uint16 const   )240,      (yytype_uint16 const   )242,      (yytype_uint16 const   )306, 
        (yytype_uint16 const   )19,      (yytype_uint16 const   )307,      (yytype_uint16 const   )34,      (yytype_uint16 const   )35, 
        (yytype_uint16 const   )173,      (yytype_uint16 const   )174,      (yytype_uint16 const   )20,      (yytype_uint16 const   )94, 
        (yytype_uint16 const   )125,      (yytype_uint16 const   )28,      (yytype_uint16 const   )94,      (yytype_uint16 const   )148, 
        (yytype_uint16 const   )251,      (yytype_uint16 const   )252,      (yytype_uint16 const   )44,      (yytype_uint16 const   )21, 
        (yytype_uint16 const   )29,      (yytype_uint16 const   )48,      (yytype_uint16 const   )27,      (yytype_uint16 const   )67, 
        (yytype_uint16 const   )63,      (yytype_uint16 const   )71,      (yytype_uint16 const   )54,      (yytype_uint16 const   )72, 
        (yytype_uint16 const   )69,      (yytype_uint16 const   )80,      (yytype_uint16 const   )81,      (yytype_uint16 const   )66, 
        (yytype_uint16 const   )84,      (yytype_uint16 const   )89,      (yytype_uint16 const   )90,      (yytype_uint16 const   )79, 
        (yytype_uint16 const   )82,      (yytype_uint16 const   )91,      (yytype_uint16 const   )92,      (yytype_uint16 const   )97, 
        (yytype_uint16 const   )96,      (yytype_uint16 const   )101,      (yytype_uint16 const   )93,      (yytype_uint16 const   )102, 
        (yytype_uint16 const   )99,      (yytype_uint16 const   )103,      (yytype_uint16 const   )113,      (yytype_uint16 const   )100, 
        (yytype_uint16 const   )107,      (yytype_uint16 const   )121,      (yytype_uint16 const   )104,      (yytype_uint16 const   )116, 
        (yytype_uint16 const   )123,      (yytype_uint16 const   )124,      (yytype_uint16 const   )130,      (yytype_uint16 const   )129, 
        (yytype_uint16 const   )127,      (yytype_uint16 const   )128,      (yytype_uint16 const   )131,      (yytype_uint16 const   )142, 
        (yytype_uint16 const   )143,      (yytype_uint16 const   )159,      (yytype_uint16 const   )151,      (yytype_uint16 const   )146, 
        (yytype_uint16 const   )147,      (yytype_uint16 const   )149,      (yytype_uint16 const   )150,      (yytype_uint16 const   )33, 
        (yytype_uint16 const   )161,      (yytype_uint16 const   )162,      (yytype_uint16 const   )160,      (yytype_uint16 const   )172, 
        (yytype_uint16 const   )167,      (yytype_uint16 const   )178,      (yytype_uint16 const   )177,      (yytype_uint16 const   )179, 
        (yytype_uint16 const   )180,      (yytype_uint16 const   )181,      (yytype_uint16 const   )197,      (yytype_uint16 const   )189, 
        (yytype_uint16 const   )228,      (yytype_uint16 const   )203,      (yytype_uint16 const   )204,      (yytype_uint16 const   )205, 
        (yytype_uint16 const   )212,      (yytype_uint16 const   )217,      (yytype_uint16 const   )232,      (yytype_uint16 const   )210, 
        (yytype_uint16 const   )268,      (yytype_uint16 const   )248,      (yytype_uint16 const   )208,      (yytype_uint16 const   )250, 
        (yytype_uint16 const   )209,      (yytype_uint16 const   )253,      (yytype_uint16 const   )211,      (yytype_uint16 const   )229, 
        (yytype_uint16 const   )238,      (yytype_uint16 const   )225,      (yytype_uint16 const   )226,      (yytype_uint16 const   )227, 
        (yytype_uint16 const   )230,      (yytype_uint16 const   )236,      (yytype_uint16 const   )231,      (yytype_uint16 const   )258, 
        (yytype_uint16 const   )261,      (yytype_uint16 const   )269,      (yytype_uint16 const   )237,      (yytype_uint16 const   )233, 
        (yytype_uint16 const   )243,      (yytype_uint16 const   )244,      (yytype_uint16 const   )249,      (yytype_uint16 const   )270, 
        (yytype_uint16 const   )254,      (yytype_uint16 const   )271,      (yytype_uint16 const   )255,      (yytype_uint16 const   )235, 
        (yytype_uint16 const   )281,      (yytype_uint16 const   )256,      (yytype_uint16 const   )257,      (yytype_uint16 const   )309, 
        (yytype_uint16 const   )259,      (yytype_uint16 const   )285,      (yytype_uint16 const   )47,      (yytype_uint16 const   )262, 
        (yytype_uint16 const   )260,      (yytype_uint16 const   )264,      (yytype_uint16 const   )0,      (yytype_uint16 const   )144, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )263,      (yytype_uint16 const   )68,      (yytype_uint16 const   )65,      (yytype_uint16 const   )265, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )266,      (yytype_uint16 const   )276,      (yytype_uint16 const   )277, 
        (yytype_uint16 const   )278,      (yytype_uint16 const   )279,      (yytype_uint16 const   )70,      (yytype_uint16 const   )282, 
        (yytype_uint16 const   )284,      (yytype_uint16 const   )267,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )176,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )283,      (yytype_uint16 const   )288,      (yytype_uint16 const   )289, 
        (yytype_uint16 const   )308,      (yytype_uint16 const   )310,      (yytype_uint16 const   )287,      (yytype_uint16 const   )317, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )327};
#line 957 "vhdl_bison.c"
static yytype_int16 const   yycheck[311]  = 
#line 957
  {      (yytype_int16 const   )107,      (yytype_int16 const   )1,      (yytype_int16 const   )1,      (yytype_int16 const   )1, 
        (yytype_int16 const   )1,      (yytype_int16 const   )1,      (yytype_int16 const   )1,      (yytype_int16 const   )1, 
        (yytype_int16 const   )15,      (yytype_int16 const   )14,      (yytype_int16 const   )1,      (yytype_int16 const   )169, 
        (yytype_int16 const   )1,      (yytype_int16 const   )11,      (yytype_int16 const   )1,      (yytype_int16 const   )1, 
        (yytype_int16 const   )12,      (yytype_int16 const   )1,      (yytype_int16 const   )176,      (yytype_int16 const   )1, 
        (yytype_int16 const   )1,      (yytype_int16 const   )1,      (yytype_int16 const   )1,      (yytype_int16 const   )12, 
        (yytype_int16 const   )131,      (yytype_int16 const   )19,      (yytype_int16 const   )38,      (yytype_int16 const   )7, 
        (yytype_int16 const   )10,      (yytype_int16 const   )1,      (yytype_int16 const   )1,      (yytype_int16 const   )1, 
        (yytype_int16 const   )12,      (yytype_int16 const   )16,      (yytype_int16 const   )17,      (yytype_int16 const   )34, 
        (yytype_int16 const   )35,      (yytype_int16 const   )7,      (yytype_int16 const   )100,      (yytype_int16 const   )39, 
        (yytype_int16 const   )40,      (yytype_int16 const   )41,      (yytype_int16 const   )42,      (yytype_int16 const   )43, 
        (yytype_int16 const   )44,      (yytype_int16 const   )45,      (yytype_int16 const   )30,      (yytype_int16 const   )47, 
        (yytype_int16 const   )48,      (yytype_int16 const   )62,      (yytype_int16 const   )62,      (yytype_int16 const   )30, 
        (yytype_int16 const   )32,      (yytype_int16 const   )33,      (yytype_int16 const   )49,      (yytype_int16 const   )50, 
        (yytype_int16 const   )51,      (yytype_int16 const   )52,      (yytype_int16 const   )30,      (yytype_int16 const   )64, 
        (yytype_int16 const   )65,      (yytype_int16 const   )123,      (yytype_int16 const   )32,      (yytype_int16 const   )33, 
        (yytype_int16 const   )62,      (yytype_int16 const   )172,      (yytype_int16 const   )62,      (yytype_int16 const   )65, 
        (yytype_int16 const   )62,      (yytype_int16 const   )63,      (yytype_int16 const   )77,      (yytype_int16 const   )70, 
        (yytype_int16 const   )63,      (yytype_int16 const   )70,      (yytype_int16 const   )8,      (yytype_int16 const   )62, 
        (yytype_int16 const   )62,      (yytype_int16 const   )62,      (yytype_int16 const   )78,      (yytype_int16 const   )77, 
        (yytype_int16 const   )187,      (yytype_int16 const   )62,      (yytype_int16 const   )53,      (yytype_int16 const   )54, 
        (yytype_int16 const   )55,      (yytype_int16 const   )56,      (yytype_int16 const   )57,      (yytype_int16 const   )70, 
        (yytype_int16 const   )59,      (yytype_int16 const   )60,      (yytype_int16 const   )1,      (yytype_int16 const   )156, 
        (yytype_int16 const   )1,      (yytype_int16 const   )62,      (yytype_int16 const   )79,      (yytype_int16 const   )80, 
        (yytype_int16 const   )7,      (yytype_int16 const   )3,      (yytype_int16 const   )7,      (yytype_int16 const   )10, 
        (yytype_int16 const   )26,      (yytype_int16 const   )27,      (yytype_int16 const   )1,      (yytype_int16 const   )12, 
        (yytype_int16 const   )1,      (yytype_int16 const   )158,      (yytype_int16 const   )171,      (yytype_int16 const   )6, 
        (yytype_int16 const   )1,      (yytype_int16 const   )0,      (yytype_int16 const   )79,      (yytype_int16 const   )80, 
        (yytype_int16 const   )18,      (yytype_int16 const   )10,      (yytype_int16 const   )7,      (yytype_int16 const   )12, 
        (yytype_int16 const   )169,      (yytype_int16 const   )10,      (yytype_int16 const   )28,      (yytype_int16 const   )29, 
        (yytype_int16 const   )185,      (yytype_int16 const   )32,      (yytype_int16 const   )33,      (yytype_int16 const   )32, 
        (yytype_int16 const   )33,      (yytype_int16 const   )21,      (yytype_int16 const   )22,      (yytype_int16 const   )23, 
        (yytype_int16 const   )24,      (yytype_int16 const   )25,      (yytype_int16 const   )1,      (yytype_int16 const   )67, 
        (yytype_int16 const   )70,      (yytype_int16 const   )1,      (yytype_int16 const   )5,      (yytype_int16 const   )71, 
        (yytype_int16 const   )4,      (yytype_int16 const   )68,      (yytype_int16 const   )7,      (yytype_int16 const   )69, 
        (yytype_int16 const   )71,      (yytype_int16 const   )10,      (yytype_int16 const   )72,      (yytype_int16 const   )1, 
        (yytype_int16 const   )10,      (yytype_int16 const   )3,      (yytype_int16 const   )12,      (yytype_int16 const   )69, 
        (yytype_int16 const   )69,      (yytype_int16 const   )71,      (yytype_int16 const   )71,      (yytype_int16 const   )69, 
        (yytype_int16 const   )14,      (yytype_int16 const   )71,      (yytype_int16 const   )79,      (yytype_int16 const   )80, 
        (yytype_int16 const   )19,      (yytype_int16 const   )20,      (yytype_int16 const   )62,      (yytype_int16 const   )67, 
        (yytype_int16 const   )68,      (yytype_int16 const   )68,      (yytype_int16 const   )67,      (yytype_int16 const   )68, 
        (yytype_int16 const   )28,      (yytype_int16 const   )29,      (yytype_int16 const   )6,      (yytype_int16 const   )70, 
        (yytype_int16 const   )62,      (yytype_int16 const   )11,      (yytype_int16 const   )72,      (yytype_int16 const   )6, 
        (yytype_int16 const   )62,      (yytype_int16 const   )68,      (yytype_int16 const   )75,      (yytype_int16 const   )62, 
        (yytype_int16 const   )74,      (yytype_int16 const   )13,      (yytype_int16 const   )9,      (yytype_int16 const   )62, 
        (yytype_int16 const   )64,      (yytype_int16 const   )13,      (yytype_int16 const   )68,      (yytype_int16 const   )75, 
        (yytype_int16 const   )72,      (yytype_int16 const   )62,      (yytype_int16 const   )15,      (yytype_int16 const   )68, 
        (yytype_int16 const   )70,      (yytype_int16 const   )13,      (yytype_int16 const   )75,      (yytype_int16 const   )64, 
        (yytype_int16 const   )72,      (yytype_int16 const   )68,      (yytype_int16 const   )68,      (yytype_int16 const   )74, 
        (yytype_int16 const   )30,      (yytype_int16 const   )30,      (yytype_int16 const   )65,      (yytype_int16 const   )71, 
        (yytype_int16 const   )8,      (yytype_int16 const   )8,      (yytype_int16 const   )8,      (yytype_int16 const   )62, 
        (yytype_int16 const   )65,      (yytype_int16 const   )65,      (yytype_int16 const   )31,      (yytype_int16 const   )8, 
        (yytype_int16 const   )6,      (yytype_int16 const   )8,      (yytype_int16 const   )62,      (yytype_int16 const   )68, 
        (yytype_int16 const   )68,      (yytype_int16 const   )66,      (yytype_int16 const   )68,      (yytype_int16 const   )62, 
        (yytype_int16 const   )8,      (yytype_int16 const   )62,      (yytype_int16 const   )69,      (yytype_int16 const   )12, 
        (yytype_int16 const   )10,      (yytype_int16 const   )8,      (yytype_int16 const   )72,      (yytype_int16 const   )8, 
        (yytype_int16 const   )8,      (yytype_int16 const   )8,      (yytype_int16 const   )35,      (yytype_int16 const   )71, 
        (yytype_int16 const   )38,      (yytype_int16 const   )11,      (yytype_int16 const   )11,      (yytype_int16 const   )72, 
        (yytype_int16 const   )70,      (yytype_int16 const   )70,      (yytype_int16 const   )36,      (yytype_int16 const   )62, 
        (yytype_int16 const   )8,      (yytype_int16 const   )37,      (yytype_int16 const   )68,      (yytype_int16 const   )34, 
        (yytype_int16 const   )68,      (yytype_int16 const   )20,      (yytype_int16 const   )68,      (yytype_int16 const   )62, 
        (yytype_int16 const   )58,      (yytype_int16 const   )68,      (yytype_int16 const   )68,      (yytype_int16 const   )68, 
        (yytype_int16 const   )68,      (yytype_int16 const   )65,      (yytype_int16 const   )68,      (yytype_int16 const   )31, 
        (yytype_int16 const   )65,      (yytype_int16 const   )9,      (yytype_int16 const   )69,      (yytype_int16 const   )72, 
        (yytype_int16 const   )68,      (yytype_int16 const   )68,      (yytype_int16 const   )62,      (yytype_int16 const   )9, 
        (yytype_int16 const   )63,      (yytype_int16 const   )9,      (yytype_int16 const   )239,      (yytype_int16 const   )215, 
        (yytype_int16 const   )274,      (yytype_int16 const   )62,      (yytype_int16 const   )244,      (yytype_int16 const   )306, 
        (yytype_int16 const   )73,      (yytype_int16 const   )38,      (yytype_int16 const   )25,      (yytype_int16 const   )65, 
        (yytype_int16 const   )68,      (yytype_int16 const   )62,      (yytype_int16 const   )-1,      (yytype_int16 const   )130, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )71,      (yytype_int16 const   )45,      (yytype_int16 const   )40,      (yytype_int16 const   )71, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )71,      (yytype_int16 const   )62,      (yytype_int16 const   )62, 
        (yytype_int16 const   )62,      (yytype_int16 const   )62,      (yytype_int16 const   )49,      (yytype_int16 const   )68, 
        (yytype_int16 const   )62,      (yytype_int16 const   )71,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )161,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )72,      (yytype_int16 const   )68,      (yytype_int16 const   )70, 
        (yytype_int16 const   )69,      (yytype_int16 const   )68,      (yytype_int16 const   )74,      (yytype_int16 const   )69, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )71};
#line 995 "vhdl_bison.c"
static yytype_uint8 const   yystos[328]  = 
#line 995
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )82, 
        (yytype_uint8 const   )83,      (yytype_uint8 const   )62,      (yytype_uint8 const   )0,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )84,      (yytype_uint8 const   )86,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )70,      (yytype_uint8 const   )1,      (yytype_uint8 const   )12,      (yytype_uint8 const   )85, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )4,      (yytype_uint8 const   )87,      (yytype_uint8 const   )14, 
        (yytype_uint8 const   )62,      (yytype_uint8 const   )70,      (yytype_uint8 const   )1,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )94,      (yytype_uint8 const   )95,      (yytype_uint8 const   )139,      (yytype_uint8 const   )72, 
        (yytype_uint8 const   )68,      (yytype_uint8 const   )62,      (yytype_uint8 const   )88,      (yytype_uint8 const   )89, 
        (yytype_uint8 const   )90,      (yytype_uint8 const   )62,      (yytype_uint8 const   )79,      (yytype_uint8 const   )80, 
        (yytype_uint8 const   )141,      (yytype_uint8 const   )1,      (yytype_uint8 const   )7,      (yytype_uint8 const   )10, 
        (yytype_uint8 const   )125,      (yytype_uint8 const   )126,      (yytype_uint8 const   )127,      (yytype_uint8 const   )129, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )111,      (yytype_uint8 const   )121,      (yytype_uint8 const   )139, 
        (yytype_uint8 const   )11,      (yytype_uint8 const   )68,      (yytype_uint8 const   )71,      (yytype_uint8 const   )69, 
        (yytype_uint8 const   )72,      (yytype_uint8 const   )96,      (yytype_uint8 const   )75,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )62,      (yytype_uint8 const   )130,      (yytype_uint8 const   )131,      (yytype_uint8 const   )133, 
        (yytype_uint8 const   )134,      (yytype_uint8 const   )136,      (yytype_uint8 const   )137,      (yytype_uint8 const   )62, 
        (yytype_uint8 const   )128,      (yytype_uint8 const   )126,      (yytype_uint8 const   )62,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )121,      (yytype_uint8 const   )74,      (yytype_uint8 const   )89,      (yytype_uint8 const   )68, 
        (yytype_uint8 const   )62,      (yytype_uint8 const   )21,      (yytype_uint8 const   )22,      (yytype_uint8 const   )23, 
        (yytype_uint8 const   )24,      (yytype_uint8 const   )25,      (yytype_uint8 const   )91,      (yytype_uint8 const   )75, 
        (yytype_uint8 const   )13,      (yytype_uint8 const   )9,      (yytype_uint8 const   )72,      (yytype_uint8 const   )122, 
        (yytype_uint8 const   )64,      (yytype_uint8 const   )138,      (yytype_uint8 const   )26,      (yytype_uint8 const   )27, 
        (yytype_uint8 const   )92,      (yytype_uint8 const   )13,      (yytype_uint8 const   )68,      (yytype_uint8 const   )62, 
        (yytype_uint8 const   )15,      (yytype_uint8 const   )75,      (yytype_uint8 const   )67,      (yytype_uint8 const   )71, 
        (yytype_uint8 const   )70,      (yytype_uint8 const   )68,      (yytype_uint8 const   )140,      (yytype_uint8 const   )72, 
        (yytype_uint8 const   )74,      (yytype_uint8 const   )13,      (yytype_uint8 const   )64,      (yytype_uint8 const   )68, 
        (yytype_uint8 const   )65,      (yytype_uint8 const   )93,      (yytype_uint8 const   )97,      (yytype_uint8 const   )30, 
        (yytype_uint8 const   )142,      (yytype_uint8 const   )143,      (yytype_uint8 const   )3,      (yytype_uint8 const   )18, 
        (yytype_uint8 const   )138,      (yytype_uint8 const   )68,      (yytype_uint8 const   )28,      (yytype_uint8 const   )29, 
        (yytype_uint8 const   )71,      (yytype_uint8 const   )1,      (yytype_uint8 const   )30,      (yytype_uint8 const   )98, 
        (yytype_uint8 const   )141,      (yytype_uint8 const   )30,      (yytype_uint8 const   )145,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )8,      (yytype_uint8 const   )68,      (yytype_uint8 const   )123,      (yytype_uint8 const   )65, 
        (yytype_uint8 const   )65,      (yytype_uint8 const   )62,      (yytype_uint8 const   )8,      (yytype_uint8 const   )31, 
        (yytype_uint8 const   )14,      (yytype_uint8 const   )65,      (yytype_uint8 const   )138,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )70,      (yytype_uint8 const   )132,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )30,      (yytype_uint8 const   )124,      (yytype_uint8 const   )8,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )95,      (yytype_uint8 const   )141,      (yytype_uint8 const   )68,      (yytype_uint8 const   )68, 
        (yytype_uint8 const   )68,      (yytype_uint8 const   )66,      (yytype_uint8 const   )68,      (yytype_uint8 const   )62, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )7,      (yytype_uint8 const   )32,      (yytype_uint8 const   )33, 
        (yytype_uint8 const   )99,      (yytype_uint8 const   )100,      (yytype_uint8 const   )144,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )69,      (yytype_uint8 const   )8,      (yytype_uint8 const   )62,      (yytype_uint8 const   )38, 
        (yytype_uint8 const   )62,      (yytype_uint8 const   )15,      (yytype_uint8 const   )77,      (yytype_uint8 const   )10, 
        (yytype_uint8 const   )100,      (yytype_uint8 const   )108,      (yytype_uint8 const   )109,      (yytype_uint8 const   )99, 
        (yytype_uint8 const   )12,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20,      (yytype_uint8 const   )135, 
        (yytype_uint8 const   )108,      (yytype_uint8 const   )72,      (yytype_uint8 const   )8,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )8,      (yytype_uint8 const   )8,      (yytype_uint8 const   )1,      (yytype_uint8 const   )62, 
        (yytype_uint8 const   )110,      (yytype_uint8 const   )99,      (yytype_uint8 const   )109,      (yytype_uint8 const   )12, 
        (yytype_uint8 const   )141,      (yytype_uint8 const   )71,      (yytype_uint8 const   )12,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )11,      (yytype_uint8 const   )62,      (yytype_uint8 const   )65,      (yytype_uint8 const   )77, 
        (yytype_uint8 const   )101,      (yytype_uint8 const   )35,      (yytype_uint8 const   )1,      (yytype_uint8 const   )34, 
        (yytype_uint8 const   )35,      (yytype_uint8 const   )70,      (yytype_uint8 const   )102,      (yytype_uint8 const   )11, 
        (yytype_uint8 const   )11,      (yytype_uint8 const   )72,      (yytype_uint8 const   )12,      (yytype_uint8 const   )141, 
        (yytype_uint8 const   )68,      (yytype_uint8 const   )68,      (yytype_uint8 const   )62,      (yytype_uint8 const   )68, 
        (yytype_uint8 const   )70,      (yytype_uint8 const   )1,      (yytype_uint8 const   )62,      (yytype_uint8 const   )106, 
        (yytype_uint8 const   )107,      (yytype_uint8 const   )70,      (yytype_uint8 const   )1,      (yytype_uint8 const   )19, 
        (yytype_uint8 const   )62,      (yytype_uint8 const   )63,      (yytype_uint8 const   )103,      (yytype_uint8 const   )104, 
        (yytype_uint8 const   )105,      (yytype_uint8 const   )68,      (yytype_uint8 const   )68,      (yytype_uint8 const   )68, 
        (yytype_uint8 const   )38,      (yytype_uint8 const   )62,      (yytype_uint8 const   )68,      (yytype_uint8 const   )68, 
        (yytype_uint8 const   )36,      (yytype_uint8 const   )72,      (yytype_uint8 const   )12,      (yytype_uint8 const   )107, 
        (yytype_uint8 const   )65,      (yytype_uint8 const   )69,      (yytype_uint8 const   )58,      (yytype_uint8 const   )69, 
        (yytype_uint8 const   )71,      (yytype_uint8 const   )69,      (yytype_uint8 const   )71,      (yytype_uint8 const   )68, 
        (yytype_uint8 const   )68,      (yytype_uint8 const   )1,      (yytype_uint8 const   )30,      (yytype_uint8 const   )112, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )62,      (yytype_uint8 const   )34,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )20,      (yytype_uint8 const   )63,      (yytype_uint8 const   )105, 
        (yytype_uint8 const   )62,      (yytype_uint8 const   )112,      (yytype_uint8 const   )31,      (yytype_uint8 const   )73, 
        (yytype_uint8 const   )68,      (yytype_uint8 const   )65,      (yytype_uint8 const   )65,      (yytype_uint8 const   )71, 
        (yytype_uint8 const   )62,      (yytype_uint8 const   )71,      (yytype_uint8 const   )71,      (yytype_uint8 const   )71, 
        (yytype_uint8 const   )8,      (yytype_uint8 const   )9,      (yytype_uint8 const   )9,      (yytype_uint8 const   )9, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )10,      (yytype_uint8 const   )114,      (yytype_uint8 const   )115, 
        (yytype_uint8 const   )62,      (yytype_uint8 const   )62,      (yytype_uint8 const   )62,      (yytype_uint8 const   )62, 
        (yytype_uint8 const   )12,      (yytype_uint8 const   )115,      (yytype_uint8 const   )68,      (yytype_uint8 const   )72, 
        (yytype_uint8 const   )62,      (yytype_uint8 const   )38,      (yytype_uint8 const   )113,      (yytype_uint8 const   )74, 
        (yytype_uint8 const   )68,      (yytype_uint8 const   )70,      (yytype_uint8 const   )1,      (yytype_uint8 const   )70, 
        (yytype_uint8 const   )116,      (yytype_uint8 const   )117,      (yytype_uint8 const   )1,      (yytype_uint8 const   )39, 
        (yytype_uint8 const   )40,      (yytype_uint8 const   )41,      (yytype_uint8 const   )42,      (yytype_uint8 const   )43, 
        (yytype_uint8 const   )44,      (yytype_uint8 const   )45,      (yytype_uint8 const   )47,      (yytype_uint8 const   )48, 
        (yytype_uint8 const   )78,      (yytype_uint8 const   )118,      (yytype_uint8 const   )69,      (yytype_uint8 const   )71, 
        (yytype_uint8 const   )69,      (yytype_uint8 const   )117,      (yytype_uint8 const   )68,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )50,      (yytype_uint8 const   )51,      (yytype_uint8 const   )52, 
        (yytype_uint8 const   )119,      (yytype_uint8 const   )69,      (yytype_uint8 const   )1,      (yytype_uint8 const   )53, 
        (yytype_uint8 const   )54,      (yytype_uint8 const   )55,      (yytype_uint8 const   )56,      (yytype_uint8 const   )57, 
        (yytype_uint8 const   )59,      (yytype_uint8 const   )60,      (yytype_uint8 const   )120,      (yytype_uint8 const   )71};
#line 1526 "vhdl_bison.c"
static void yydestruct(char const   *yymsg , int yytype , YYSTYPE *yyvaluep , vhdl_parser_priv_t *priv_data ) 
{ 
  char *__cil_tmp5 ;

  {
#line 1540
  if (! yymsg) {
#line 1541
    yymsg = "Deleting";
  }
  {
#line 1547
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 1548
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1550
  return;
}
}
#line 1588 "vhdl_bison.c"
int vhdlparse(vhdl_parser_priv_t *priv_data ) 
{ 
  int vhdlchar ;
  YYSTYPE vhdllval ;
  int vhdlnerrs ;
  int yystate ;
  int yyerrstatus ;
  yytype_int16 yyssa[200] ;
  yytype_int16 *yyss ;
  yytype_int16 *yyssp ;
  YYSTYPE yyvsa[200] ;
  YYSTYPE *yyvs ;
  YYSTYPE *yyvsp ;
  unsigned int yystacksize ;
  int yyn ;
  int yyresult ;
  int yytoken ;
  YYSTYPE yyval ;
  int yylen ;
  unsigned int yysize ;
  yytype_int16 *yyss1 ;
  union yyalloc *yyptr ;
  void *tmp ;
  unsigned int yynewbytes ;
  unsigned int yynewbytes___0 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  char *tmp___21 ;
  void *__cil_tmp47 ;
  void *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;

  {
#line 1648
  yylen = 0;
#line 1650
  yytoken = 0;
#line 1651
  yyss = yyssa;
#line 1652
  yyvs = yyvsa;
#line 1653
  yystacksize = 200U;
#line 1657
  yystate = 0;
#line 1658
  yyerrstatus = 0;
#line 1659
  vhdlnerrs = 0;
#line 1660
  vhdlchar = -2;
#line 1666
  yyssp = yyss;
#line 1667
  yyvsp = yyvs;
#line 1669
  goto yysetstate;
  yynewstate: 
#line 1677
  yyssp ++;
  yysetstate: 
#line 1680
  *yyssp = (yytype_int16 )yystate;
#line 1682
  if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1685
    yysize = (unsigned int )((yyssp - yyss) + 1L);
#line 1712
    if (10000U <= yystacksize) {
#line 1713
      goto yyexhaustedlab;
    }
#line 1714
    yystacksize *= 2U;
#line 1715
    if (10000U < yystacksize) {
#line 1716
      yystacksize = 10000U;
    }
    {
#line 1719
    yyss1 = yyss;
#line 1720
    tmp = malloc((size_t )((unsigned long )yystacksize * (sizeof(yytype_int16 ) + sizeof(YYSTYPE )) + (sizeof(union yyalloc ) - 1UL)));
#line 1720
    yyptr = (union yyalloc *)tmp;
    }
#line 1722
    if (! yyptr) {
#line 1723
      goto yyexhaustedlab;
    }
    {
#line 1724
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1724
      __builtin_memcpy((void *)(& yyptr->yyss_alloc), (void const   *)yyss, (unsigned long )yysize * sizeof(*yyss));
#line 1724
      yyss = & yyptr->yyss_alloc;
#line 1724
      yynewbytes = (unsigned int )((unsigned long )yystacksize * sizeof(*yyss) + (sizeof(union yyalloc ) - 1UL));
#line 1724
      yyptr += (unsigned long )yynewbytes / sizeof(*yyptr);
      }
#line 1724
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1725
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1725
      __builtin_memcpy((void *)(& yyptr->yyvs_alloc), (void const   *)yyvs, (unsigned long )yysize * sizeof(*yyvs));
#line 1725
      yyvs = & yyptr->yyvs_alloc;
#line 1725
      yynewbytes___0 = (unsigned int )((unsigned long )yystacksize * sizeof(*yyvs) + (sizeof(union yyalloc ) - 1UL));
#line 1725
      yyptr += (unsigned long )yynewbytes___0 / sizeof(*yyptr);
      }
#line 1725
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1727
    if ((unsigned long )yyss1 != (unsigned long )(yyssa)) {
      {
#line 1728
      free((void *)yyss1);
      }
    }
#line 1733
    yyssp = (yyss + yysize) - 1;
#line 1734
    yyvsp = (yyvs + yysize) - 1;
#line 1739
    if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1740
      goto yyabortlab;
    }
  }
#line 1745
  if (yystate == 6) {
#line 1746
    goto yyacceptlab;
  }
#line 1748
  goto yybackup;
  yybackup: 
#line 1759
  yyn = (int )yypact[yystate];
#line 1760
  if (yyn == -159) {
#line 1761
    goto yydefault;
  }
#line 1766
  if (vhdlchar == -2) {
    {
#line 1769
    vhdlchar = vhdllex(& vhdllval, priv_data->scanner);
    }
  }
#line 1772
  if (vhdlchar <= 0) {
#line 1774
    yytoken = 0;
#line 1774
    vhdlchar = yytoken;
  } else
#line 1779
  if ((unsigned int )vhdlchar <= 335U) {
#line 1779
    yytoken = (int )yytranslate[vhdlchar];
  } else {
#line 1779
    yytoken = 2;
  }
#line 1785
  yyn += yytoken;
#line 1786
  if (yyn < 0) {
#line 1787
    goto yydefault;
  } else
#line 1786
  if (310 < yyn) {
#line 1787
    goto yydefault;
  } else
#line 1786
  if ((int const   )yycheck[yyn] != (int const   )yytoken) {
#line 1787
    goto yydefault;
  }
#line 1788
  yyn = (int )yytable[yyn];
#line 1789
  if (yyn <= 0) {
#line 1791
    if (yyn == 0) {
#line 1792
      goto yyerrlab;
    } else
#line 1791
    if (yyn == -1) {
#line 1792
      goto yyerrlab;
    }
#line 1793
    yyn = - yyn;
#line 1794
    goto yyreduce;
  }
#line 1799
  if (yyerrstatus) {
#line 1800
    yyerrstatus --;
  }
#line 1806
  vhdlchar = -2;
#line 1808
  yystate = yyn;
#line 1809
  yyvsp ++;
#line 1809
  *yyvsp = vhdllval;
#line 1811
  goto yynewstate;
  yydefault: 
#line 1818
  yyn = (int )yydefact[yystate];
#line 1819
  if (yyn == 0) {
#line 1820
    goto yyerrlab;
  }
#line 1821
  goto yyreduce;
  yyreduce: 
#line 1829
  yylen = (int )yyr2[yyn];
#line 1839
  yyval = *(yyvsp + (1 - yylen));
  {
#line 1845
  if (yyn == 3) {
#line 1845
    goto case_3;
  }
#line 219
  if (yyn == 4) {
#line 219 "vhdl_bison.y"
    goto case_4;
  }
#line 225
  if (yyn == 6) {
#line 225
    goto case_6;
  }
#line 235
  if (yyn == 7) {
#line 235
    goto case_7;
  }
#line 238
  if (yyn == 8) {
#line 238
    goto case_8;
  }
#line 243
  if (yyn == 11) {
#line 243
    goto case_11;
  }
#line 253
  if (yyn == 14) {
#line 253
    goto case_14;
  }
#line 259
  if (yyn == 15) {
#line 259
    goto case_15;
  }
#line 262
  if (yyn == 16) {
#line 262
    goto case_16;
  }
#line 264
  if (yyn == 22) {
#line 264
    goto case_22;
  }
#line 269
  if (yyn == 24) {
#line 269
    goto case_24;
  }
#line 273
  if (yyn == 25) {
#line 273
    goto case_25;
  }
#line 275
  if (yyn == 30) {
#line 275
    goto case_30;
  }
#line 285
  if (yyn == 31) {
#line 285
    goto case_31;
  }
#line 291
  if (yyn == 32) {
#line 291
    goto case_32;
  }
#line 297
  if (yyn == 33) {
#line 297
    goto case_33;
  }
#line 301
  if (yyn == 34) {
#line 301
    goto case_34;
  }
#line 305
  if (yyn == 35) {
#line 305
    goto case_35;
  }
#line 310
  if (yyn == 38) {
#line 310
    goto case_38;
  }
#line 316
  if (yyn == 39) {
#line 316
    goto case_39;
  }
#line 318
  if (yyn == 40) {
#line 318
    goto case_40;
  }
#line 321
  if (yyn == 43) {
#line 321
    goto case_43;
  }
#line 328
  if (yyn == 44) {
#line 328
    goto case_44;
  }
#line 331
  if (yyn == 48) {
#line 331
    goto case_48;
  }
#line 339
  if (yyn == 52) {
#line 339
    goto case_52;
  }
#line 346
  if (yyn == 53) {
#line 346
    goto case_53;
  }
#line 349
  if (yyn == 55) {
#line 349
    goto case_55;
  }
#line 355
  if (yyn == 58) {
#line 355
    goto case_58;
  }
#line 361
  if (yyn == 59) {
#line 361
    goto case_59;
  }
#line 363
  if (yyn == 60) {
#line 363
    goto case_60;
  }
#line 366
  if (yyn == 61) {
#line 366
    goto case_61;
  }
#line 371
  if (yyn == 64) {
#line 371
    goto case_64;
  }
#line 377
  if (yyn == 65) {
#line 377
    goto case_65;
  }
#line 382
  if (yyn == 69) {
#line 382
    goto case_69;
  }
#line 390
  if (yyn == 70) {
#line 390
    goto case_70;
  }
#line 395
  if (yyn == 73) {
#line 395
    goto case_73;
  }
#line 401
  if (yyn == 75) {
#line 401
    goto case_75;
  }
#line 407
  if (yyn == 78) {
#line 407
    goto case_78;
  }
#line 414
  if (yyn == 79) {
#line 414
    goto case_79;
  }
#line 419
  if (yyn == 83) {
#line 419
    goto case_83;
  }
#line 430
  if (yyn == 94) {
#line 430
    goto case_94;
  }
#line 439
  if (yyn == 99) {
#line 439
    goto case_99;
  }
#line 446
  if (yyn == 107) {
#line 446
    goto case_107;
  }
#line 453
  if (yyn == 108) {
#line 453
    goto case_108;
  }
#line 459
  if (yyn == 109) {
#line 459
    goto case_109;
  }
#line 465
  if (yyn == 110) {
#line 465
    goto case_110;
  }
#line 469
  if (yyn == 111) {
#line 469
    goto case_111;
  }
#line 473
  if (yyn == 112) {
#line 473
    goto case_112;
  }
#line 476
  if (yyn == 115) {
#line 476
    goto case_115;
  }
#line 484
  if (yyn == 119) {
#line 484
    goto case_119;
  }
#line 494
  if (yyn == 126) {
#line 494
    goto case_126;
  }
#line 507
  if (yyn == 127) {
#line 507
    goto case_127;
  }
#line 515
  if (yyn == 128) {
#line 515
    goto case_128;
  }
#line 518
  if (yyn == 129) {
#line 518
    goto case_129;
  }
#line 520
  if (yyn == 130) {
#line 520
    goto case_130;
  }
#line 526
  if (yyn == 131) {
#line 526
    goto case_131;
  }
#line 534
  if (yyn == 134) {
#line 534
    goto case_134;
  }
#line 542
  if (yyn == 135) {
#line 542
    goto case_135;
  }
#line 545
  if (yyn == 136) {
#line 545
    goto case_136;
  }
#line 552
  if (yyn == 137) {
#line 552
    goto case_137;
  }
#line 557
  if (yyn == 138) {
#line 557
    goto case_138;
  }
#line 564
  if (yyn == 139) {
#line 564
    goto case_139;
  }
#line 568
  if (yyn == 140) {
#line 568
    goto case_140;
  }
#line 573
  if (yyn == 141) {
#line 573
    goto case_141;
  }
#line 577
  if (yyn == 143) {
#line 577
    goto case_143;
  }
#line 2419 "vhdl_bison.c"
  goto switch_default;
  case_3: /* CIL Label */ 
  {
#line 216 "vhdl_bison.y"
  vhdl_set_entity(priv_data, (yyvsp + -1)->str);
  }
#line 217
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 219
  Print_Error(priv_data, "Improper Entity declaration");
#line 220
  Print_Error(priv_data, "Check if source file is BSDL");
#line 221
  tmp___0 = vhdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 221
  if (tmp___0 > 15) {
    {
#line 221
    Give_Up_And_Quit(priv_data);
    }
#line 221
    goto yyabortlab;
  }
#line 221
  goto yyabortlab;
#line 223
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 230
  Print_Error(priv_data, "Syntax Error");
#line 231
  tmp___1 = vhdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 231
  if (tmp___1 > 15) {
    {
#line 231
    Give_Up_And_Quit(priv_data);
    }
#line 231
    goto yyabortlab;
  }
#line 231
  goto yyabortlab;
#line 233
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 235
  free((void *)(yyvsp + -1)->str);
  }
#line 236
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 238
  Print_Error(priv_data, "Syntax Error");
#line 239
  tmp___2 = vhdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 239
  if (tmp___2 > 15) {
    {
#line 239
    Give_Up_And_Quit(priv_data);
    }
#line 239
    goto yyabortlab;
  }
#line 239
  goto yyabortlab;
#line 241
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 248
  Print_Error(priv_data, "Improper Port declaration");
#line 249
  tmp___3 = vhdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 249
  if (tmp___3 > 15) {
    {
#line 249
    Give_Up_And_Quit(priv_data);
    }
#line 249
    goto yyabortlab;
  }
#line 249
  goto yyabortlab;
#line 251
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 256
  vhdl_port_apply_port(priv_data);
  }
#line 257
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 259
  vhdl_port_add_name(priv_data, (yyvsp + 0)->str);
  }
#line 260
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 261
  vhdl_port_add_name(priv_data, (yyvsp + 0)->str);
  }
#line 262
  goto switch_break;
  case_22: /* CIL Label */ 
  {
#line 266
  vhdl_port_add_bit(priv_data);
  }
#line 267
  goto switch_break;
  case_24: /* CIL Label */ 
  {
#line 270
  vhdl_port_add_range(priv_data, (yyvsp + -2)->integer, (yyvsp + 0)->integer);
  }
#line 271
  goto switch_break;
  case_25: /* CIL Label */ 
  {
#line 272
  vhdl_port_add_range(priv_data, (yyvsp + 0)->integer, (yyvsp + -2)->integer);
  }
#line 273
  goto switch_break;
  case_30: /* CIL Label */ 
  {
#line 280
  Print_Error(priv_data, "Error in Package declaration(s)");
#line 281
  tmp___4 = vhdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 281
  if (tmp___4 > 15) {
    {
#line 281
    Give_Up_And_Quit(priv_data);
    }
#line 281
    goto yyabortlab;
  }
#line 281
  goto yyabortlab;
#line 283
  goto switch_break;
  case_31: /* CIL Label */ 
  {
#line 286
  strcpy((char */* __restrict  */)(priv_data->Package_File_Name), (char const   */* __restrict  */)(yyvsp + 0)->str);
#line 287
  free((void *)(yyvsp + 0)->str);
  }
#line 289
  goto switch_break;
  case_32: /* CIL Label */ 
  {
#line 291
  priv_data->Reading_Package = 1;
#line 292
  vhdl_flex_switch_file(priv_data->scanner, priv_data->Package_File_Name);
  }
#line 295
  goto switch_break;
  case_33: /* CIL Label */ 
#line 297
  priv_data->Reading_Package = 0;
#line 299
  goto switch_break;
  case_34: /* CIL Label */ 
  {
#line 302
  free((void *)(yyvsp + -8)->str);
#line 302
  free((void *)(yyvsp + -2)->str);
  }
#line 303
  goto switch_break;
  case_35: /* CIL Label */ 
  {
#line 305
  Print_Error(priv_data, "Error in Standard Package");
#line 306
  tmp___5 = vhdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 306
  if (tmp___5 > 15) {
    {
#line 306
    Give_Up_And_Quit(priv_data);
    }
#line 306
    goto yyabortlab;
  }
#line 306
  goto yyabortlab;
#line 308
  goto switch_break;
  case_38: /* CIL Label */ 
  {
#line 313
  free((void *)(yyvsp + -3)->str);
  }
#line 314
  goto switch_break;
  case_39: /* CIL Label */ 
  {
#line 315
  free((void *)(yyvsp + -3)->str);
  }
#line 316
  goto switch_break;
  case_40: /* CIL Label */ 
  {
#line 318
  free((void *)(yyvsp + -1)->str);
  }
#line 319
  goto switch_break;
  case_43: /* CIL Label */ 
  {
#line 323
  Print_Error(priv_data, "Error in Standard Declarations");
#line 324
  tmp___6 = vhdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 324
  if (tmp___6 > 15) {
    {
#line 324
    Give_Up_And_Quit(priv_data);
    }
#line 324
    goto yyabortlab;
  }
#line 324
  goto yyabortlab;
#line 326
  goto switch_break;
  case_44: /* CIL Label */ 
  {
#line 328
  free((void *)(yyvsp + 0)->str);
  }
#line 329
  goto switch_break;
  case_48: /* CIL Label */ 
  {
#line 334
  Print_Error(priv_data, "Error in Attribute type identification");
#line 335
  tmp___7 = vhdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 335
  if (tmp___7 > 15) {
    {
#line 335
    Give_Up_And_Quit(priv_data);
    }
#line 335
    goto yyabortlab;
  }
#line 335
  goto yyabortlab;
#line 337
  goto switch_break;
  case_52: /* CIL Label */ 
  {
#line 343
  free((void *)(yyvsp + 0)->str);
  }
#line 344
  goto switch_break;
  case_53: /* CIL Label */ 
  {
#line 346
  free((void *)(yyvsp + 0)->str);
  }
#line 347
  goto switch_break;
  case_55: /* CIL Label */ 
  {
#line 350
  Print_Error(priv_data, "Error in Type definition");
#line 351
  tmp___8 = vhdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 351
  if (tmp___8 > 15) {
    {
#line 351
    Give_Up_And_Quit(priv_data);
    }
#line 351
    goto yyabortlab;
  }
#line 351
  goto yyabortlab;
#line 353
  goto switch_break;
  case_58: /* CIL Label */ 
  {
#line 358
  free((void *)(yyvsp + 0)->str);
  }
#line 359
  goto switch_break;
  case_59: /* CIL Label */ 
  {
#line 360
  free((void *)(yyvsp + 0)->str);
  }
#line 361
  goto switch_break;
  case_60: /* CIL Label */ 
  {
#line 363
  free((void *)(yyvsp + -1)->str);
  }
#line 364
  goto switch_break;
  case_61: /* CIL Label */ 
  {
#line 366
  Print_Error(priv_data, "Error in Bit definition");
#line 367
  tmp___9 = vhdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 367
  if (tmp___9 > 15) {
    {
#line 367
    Give_Up_And_Quit(priv_data);
    }
#line 367
    goto yyabortlab;
  }
#line 367
  goto yyabortlab;
#line 369
  goto switch_break;
  case_64: /* CIL Label */ 
  {
#line 374
  free((void *)(yyvsp + -3)->str);
#line 374
  free((void *)(yyvsp + -1)->str);
  }
#line 375
  goto switch_break;
  case_65: /* CIL Label */ 
  {
#line 377
  Print_Error(priv_data, "Error in Record Definition");
#line 378
  tmp___10 = vhdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 378
  if (tmp___10 > 15) {
    {
#line 378
    Give_Up_And_Quit(priv_data);
    }
#line 378
    goto yyabortlab;
  }
#line 378
  goto yyabortlab;
#line 380
  goto switch_break;
  case_69: /* CIL Label */ 
  {
#line 387
  free((void *)(yyvsp + -3)->str);
  }
#line 388
  goto switch_break;
  case_70: /* CIL Label */ 
  {
#line 390
  Print_Error(priv_data, "Error in defered constant");
#line 391
  tmp___11 = vhdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 391
  if (tmp___11 > 15) {
    {
#line 391
    Give_Up_And_Quit(priv_data);
    }
#line 391
    goto yyabortlab;
  }
#line 391
  goto yyabortlab;
#line 393
  goto switch_break;
  case_73: /* CIL Label */ 
  {
#line 398
  free((void *)(yyvsp + -4)->str);
#line 398
  free((void *)(yyvsp + 0)->str);
  }
#line 399
  goto switch_break;
  case_75: /* CIL Label */ 
  {
#line 402
  Print_Error(priv_data, "Error in Package Body definition");
#line 403
  tmp___12 = vhdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 403
  if (tmp___12 > 15) {
    {
#line 403
    Give_Up_And_Quit(priv_data);
    }
#line 403
    goto yyabortlab;
  }
#line 403
  goto yyabortlab;
#line 405
  goto switch_break;
  case_78: /* CIL Label */ 
  {
#line 411
  free((void *)(yyvsp + -7)->str);
  }
#line 412
  goto switch_break;
  case_79: /* CIL Label */ 
  {
#line 414
  Print_Error(priv_data, "Error in Cell Constant definition");
#line 415
  tmp___13 = vhdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 415
  if (tmp___13 > 15) {
    {
#line 415
    Give_Up_And_Quit(priv_data);
    }
#line 415
    goto yyabortlab;
  }
#line 415
  goto yyabortlab;
#line 417
  goto switch_break;
  case_83: /* CIL Label */ 
  {
#line 425
  Print_Error(priv_data, "Error in Cell Data Record");
#line 426
  tmp___14 = vhdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 426
  if (tmp___14 > 15) {
    {
#line 426
    Give_Up_And_Quit(priv_data);
    }
#line 426
    goto yyabortlab;
  }
#line 426
  goto yyabortlab;
#line 428
  goto switch_break;
  case_94: /* CIL Label */ 
  {
#line 434
  Print_Error(priv_data, "Error in Cell_Type Function field");
#line 435
  tmp___15 = vhdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 435
  if (tmp___15 > 15) {
    {
#line 435
    Give_Up_And_Quit(priv_data);
    }
#line 435
    goto yyabortlab;
  }
#line 435
  goto yyabortlab;
#line 437
  goto switch_break;
  case_99: /* CIL Label */ 
  {
#line 441
  Print_Error(priv_data, "Error in BScan_Inst Instruction field");
#line 442
  tmp___16 = vhdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 442
  if (tmp___16 > 15) {
    {
#line 442
    Give_Up_And_Quit(priv_data);
    }
#line 442
    goto yyabortlab;
  }
#line 442
  goto yyabortlab;
#line 444
  goto switch_break;
  case_107: /* CIL Label */ 
  {
#line 448
  Print_Error(priv_data, "Error in Constant CAP data source field");
#line 449
  tmp___17 = vhdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 449
  if (tmp___17 > 15) {
    {
#line 449
    Give_Up_And_Quit(priv_data);
    }
#line 449
    goto yyabortlab;
  }
#line 449
  goto yyabortlab;
#line 451
  goto switch_break;
  case_108: /* CIL Label */ 
  {
#line 454
  strcpy((char */* __restrict  */)(priv_data->Package_File_Name), (char const   */* __restrict  */)(yyvsp + 0)->str);
#line 455
  free((void *)(yyvsp + 0)->str);
  }
#line 457
  goto switch_break;
  case_109: /* CIL Label */ 
  {
#line 459
  priv_data->Reading_Package = 1;
#line 460
  vhdl_flex_switch_file(priv_data->scanner, priv_data->Package_File_Name);
  }
#line 463
  goto switch_break;
  case_110: /* CIL Label */ 
#line 465
  priv_data->Reading_Package = 0;
#line 467
  goto switch_break;
  case_111: /* CIL Label */ 
  {
#line 470
  free((void *)(yyvsp + -6)->str);
#line 470
  free((void *)(yyvsp + -2)->str);
  }
#line 471
  goto switch_break;
  case_112: /* CIL Label */ 
  {
#line 472
  Print_Error(priv_data, "Error in User-Defined Package declarations");
#line 473
  tmp___18 = vhdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 473
  if (tmp___18 > 15) {
    {
#line 473
    Give_Up_And_Quit(priv_data);
    }
#line 473
    goto yyabortlab;
  }
#line 473
  goto yyabortlab;
#line 474
  goto switch_break;
  case_115: /* CIL Label */ 
  {
#line 479
  Print_Error(priv_data, "Unknown VHDL statement");
#line 480
  tmp___19 = vhdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 480
  if (tmp___19 > 15) {
    {
#line 480
    Give_Up_And_Quit(priv_data);
    }
#line 480
    goto yyabortlab;
  }
#line 480
  goto yyabortlab;
#line 482
  goto switch_break;
  case_119: /* CIL Label */ 
  {
#line 491
  free((void *)(yyvsp + -5)->str);
  }
#line 492
  goto switch_break;
  case_126: /* CIL Label */ 
  {
#line 502
  Print_Error(priv_data, "Error in Attribute specification");
#line 503
  tmp___20 = vhdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 503
  if (tmp___20 > 15) {
    {
#line 503
    Give_Up_And_Quit(priv_data);
    }
#line 503
    goto yyabortlab;
  }
#line 503
  goto yyabortlab;
#line 505
  goto switch_break;
  case_127: /* CIL Label */ 
  {
#line 511
  free((void *)(yyvsp + -7)->str);
#line 511
  free((void *)(yyvsp + -5)->str);
  }
#line 513
  goto switch_break;
  case_128: /* CIL Label */ 
#line 515
  yyval.integer = 1;
#line 516
  goto switch_break;
  case_129: /* CIL Label */ 
#line 517
  yyval.integer = 0;
#line 518
  goto switch_break;
  case_130: /* CIL Label */ 
  {
#line 521
  set_attr_decimal(priv_data, (yyvsp + -7)->str, (yyvsp + -1)->integer);
#line 522
  free((void *)(yyvsp + -5)->str);
  }
#line 524
  goto switch_break;
  case_131: /* CIL Label */ 
  {
#line 530
  free((void *)(yyvsp + -11)->str);
#line 530
  free((void *)(yyvsp + -9)->str);
#line 530
  free((void *)(yyvsp + -4)->str);
  }
#line 532
  goto switch_break;
  case_134: /* CIL Label */ 
  {
#line 537
  tmp___21 = strdup((char const   *)priv_data->buffer);
#line 537
  set_attr_string(priv_data, (yyvsp + -7)->str, tmp___21);
#line 538
  free((void *)(yyvsp + -5)->str);
  }
#line 540
  goto switch_break;
  case_135: /* CIL Label */ 
  {
#line 542
  free((void *)(yyvsp + -7)->str);
#line 542
  free((void *)(yyvsp + -5)->str);
  }
#line 543
  goto switch_break;
  case_136: /* CIL Label */ 
  {
#line 546
  Init_Text(priv_data);
#line 547
  Store_Text(priv_data, (yyvsp + 0)->str);
#line 548
  free((void *)(yyvsp + 0)->str);
  }
#line 550
  goto switch_break;
  case_137: /* CIL Label */ 
  {
#line 552
  Store_Text(priv_data, (yyvsp + 0)->str);
#line 553
  free((void *)(yyvsp + 0)->str);
  }
#line 555
  goto switch_break;
  case_138: /* CIL Label */ 
  {
#line 558
  priv_data->Reading_Package = 1;
#line 559
  vhdl_flex_switch_file(priv_data->scanner, priv_data->Package_File_Name);
  }
#line 562
  goto switch_break;
  case_139: /* CIL Label */ 
#line 564
  priv_data->Reading_Package = 0;
#line 566
  goto switch_break;
  case_140: /* CIL Label */ 
  {
#line 569
  strcpy((char */* __restrict  */)(priv_data->Package_File_Name), (char const   */* __restrict  */)"STD_1532_2001");
  }
#line 571
  goto switch_break;
  case_141: /* CIL Label */ 
  {
#line 573
  strcpy((char */* __restrict  */)(priv_data->Package_File_Name), (char const   */* __restrict  */)"STD_1532_2002");
  }
#line 575
  goto switch_break;
  case_143: /* CIL Label */ 
#line 581
  priv_data->Reading_Package = 1;
#line 583
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 2419 "vhdl_bison.c"
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2423
  yyvsp -= yylen;
#line 2423
  yyssp -= yylen;
#line 2424
  yylen = 0;
#line 2427
  yyvsp ++;
#line 2427
  *yyvsp = yyval;
#line 2433
  yyn = (int )yyr1[yyn];
#line 2435
  yystate = (int )((int const   )yypgoto[yyn - 81] + (int const   )*yyssp);
#line 2436
  if (0 <= yystate) {
#line 2436
    if (yystate <= 310) {
#line 2436
      if ((int const   )yycheck[yystate] == (int const   )*yyssp) {
#line 2437
        yystate = (int )yytable[yystate];
      } else {
#line 2439
        yystate = (int )yydefgoto[yyn - 81];
      }
    } else {
#line 2439
      yystate = (int )yydefgoto[yyn - 81];
    }
  } else {
#line 2439
    yystate = (int )yydefgoto[yyn - 81];
  }
#line 2441
  goto yynewstate;
  yyerrlab: 
#line 2449
  if (! yyerrstatus) {
    {
#line 2451
    vhdlnerrs ++;
#line 2453
    vhdlerror(priv_data, "syntax error");
    }
  }
#line 2491
  if (yyerrstatus == 3) {
#line 2496
    if (vhdlchar <= 0) {
#line 2499
      if (vhdlchar == 0) {
#line 2500
        goto yyabortlab;
      }
    } else {
      {
#line 2504
      yydestruct("Error: discarding", yytoken, & vhdllval, priv_data);
#line 2506
      vhdlchar = -2;
      }
    }
  }
#line 2512
  goto yyerrlab1;
#line 2528
  yyvsp -= yylen;
#line 2528
  yyssp -= yylen;
#line 2529
  yylen = 0;
#line 2531
  yystate = (int )*yyssp;
#line 2532
  goto yyerrlab1;
  yyerrlab1: 
#line 2539
  yyerrstatus = 3;
  {
#line 2541
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2543
    yyn = (int )yypact[yystate];
#line 2544
    if (yyn != -159) {
#line 2546
      yyn ++;
#line 2547
      if (0 <= yyn) {
#line 2547
        if (yyn <= 310) {
#line 2547
          if ((int const   )yycheck[yyn] == 1) {
#line 2549
            yyn = (int )yytable[yyn];
#line 2550
            if (0 < yyn) {
#line 2551
              goto while_break___1;
            }
          }
        }
      }
    }
#line 2556
    if ((unsigned long )yyssp == (unsigned long )yyss) {
#line 2557
      goto yyabortlab;
    }
    {
#line 2560
    yydestruct("Error: popping", (int )yystos[yystate], yyvsp, priv_data);
#line 2562
    yyvsp --;
#line 2562
    yyssp --;
#line 2563
    yystate = (int )*yyssp;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2567
  yyvsp ++;
#line 2567
  *yyvsp = vhdllval;
#line 2573
  yystate = yyn;
#line 2574
  goto yynewstate;
  yyacceptlab: 
#line 2581
  yyresult = 0;
#line 2582
  goto yyreturn;
  yyabortlab: 
#line 2588
  yyresult = 1;
#line 2589
  goto yyreturn;
  yyexhaustedlab: 
  {
#line 2596
  vhdlerror(priv_data, "memory exhausted");
#line 2597
  yyresult = 2;
  }
  yyreturn: 
#line 2602
  if (vhdlchar != -2) {
    {
#line 2603
    yydestruct("Cleanup: discarding lookahead", yytoken, & vhdllval, priv_data);
    }
  }
#line 2607
  yyvsp -= yylen;
#line 2607
  yyssp -= yylen;
  {
#line 2609
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2609
    if (! ((unsigned long )yyssp != (unsigned long )yyss)) {
#line 2609
      goto while_break___2;
    }
    {
#line 2611
    yydestruct("Cleanup: popping", (int )yystos[*yyssp], yyvsp, priv_data);
#line 2613
    yyvsp --;
#line 2613
    yyssp --;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2616
  if ((unsigned long )yyss != (unsigned long )(yyssa)) {
    {
#line 2617
    free((void *)yyss);
    }
  }
#line 2624
  return (yyresult);
}
}
#line 601 "vhdl_bison.y"
static void Init_Text(vhdl_parser_priv_t *priv ) 
{ 
  void *tmp ;

  {
#line 603
  if (priv->len_buffer == 0U) {
    {
#line 605
    tmp = malloc((size_t )160);
#line 605
    priv->buffer = (char *)tmp;
#line 606
    priv->len_buffer = (size_t )160;
    }
  }
#line 608
  *(priv->buffer + 0) = (char )'\000';
#line 609
  return;
}
}
#line 625 "vhdl_bison.y"
static void Store_Text(vhdl_parser_priv_t *priv , char *Source ) 
{ 
  size_t req_len ;
  char *SourceEnd ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 630
  Source ++;
#line 630
  SourceEnd = Source;
  {
#line 631
  while (1) {
    while_continue: /* CIL Label */ ;
#line 631
    if (*SourceEnd) {
#line 631
      if ((int )*SourceEnd != 34) {
#line 631
        if (! ((int )*SourceEnd != 10)) {
#line 631
          goto while_break;
        }
      } else {
#line 631
        goto while_break;
      }
    } else {
#line 631
      goto while_break;
    }
#line 632
    SourceEnd ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 634
  *SourceEnd = (char )'\000';
#line 636
  tmp = strlen((char const   *)priv->buffer);
#line 636
  tmp___0 = strlen((char const   *)Source);
#line 636
  req_len = (tmp + tmp___0) + 1U;
  }
#line 637
  if (req_len > priv->len_buffer) {
    {
#line 639
    tmp___1 = realloc((void *)priv->buffer, req_len);
#line 639
    priv->buffer = (char *)tmp___1;
#line 640
    priv->len_buffer = req_len;
    }
  }
  {
#line 642
  strcat((char */* __restrict  */)priv->buffer, (char const   */* __restrict  */)Source);
  }
#line 643
  return;
}
}
#line 645 "vhdl_bison.y"
static void Print_Error(vhdl_parser_priv_t *priv_data , char const   *Errmess ) 
{ 
  jtag_ctrl_t *jc ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 647
  jc = priv_data->jtag_ctrl;
#line 649
  if (priv_data->Reading_Package) {
    {
#line 650
    tmp = vhdl_flex_get_lineno(priv_data->scanner);
#line 650
    bsdl_msg(jc->proc_mode, 2, "In Package %s, Line %d, %s.\n", priv_data->Package_File_Name,
             tmp, Errmess);
    }
  } else {
    {
#line 656
    tmp___0 = vhdl_flex_get_lineno(priv_data->scanner);
#line 656
    bsdl_msg(jc->proc_mode, 2, "Line %d, %s.\n", tmp___0, Errmess);
    }
  }
#line 660
  return;
}
}
#line 662 "vhdl_bison.y"
static void Give_Up_And_Quit(vhdl_parser_priv_t *priv_data ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 664
  Print_Error(priv_data, "Too many errors");
  }
#line 665
  return;
}
}
#line 667 "vhdl_bison.y"
void vhdlerror(vhdl_parser_priv_t *priv_data , char const   *error_string ) 
{ 


  {
#line 669
  return;
}
}
#line 684 "vhdl_bison.y"
static void vhdl_sem_init(vhdl_parser_priv_t *priv ) 
{ 


  {
#line 686
  priv->tmp_port_desc.names_list = (string_elem_t *)((void *)0);
#line 687
  priv->tmp_port_desc.next = (struct port_desc *)((void *)0);
#line 689
  (priv->jtag_ctrl)->port_desc = (port_desc_t *)((void *)0);
#line 691
  (priv->jtag_ctrl)->vhdl_elem_first = (vhdl_elem_t *)((void *)0);
#line 692
  (priv->jtag_ctrl)->vhdl_elem_last = (vhdl_elem_t *)((void *)0);
#line 693
  return;
}
}
#line 707 "vhdl_bison.y"
static void free_string_list(string_elem_t *sl ) 
{ 


  {
#line 709
  if (sl) {
#line 711
    if (sl->string) {
      {
#line 712
      free((void *)sl->string);
      }
    }
    {
#line 713
    free_string_list(sl->next);
#line 714
    free((void *)sl);
    }
  }
#line 716
  return;
}
}
#line 731 "vhdl_bison.y"
static void free_port_list(port_desc_t *pl , int free_me ) 
{ 


  {
#line 733
  if (pl) {
    {
#line 735
    free_string_list(pl->names_list);
#line 736
    free_port_list(pl->next, 1);
    }
#line 738
    if (free_me) {
      {
#line 739
      free((void *)pl);
      }
    }
  }
#line 741
  return;
}
}
#line 755 "vhdl_bison.y"
static void free_elem_list(vhdl_elem_t *el ) 
{ 


  {
#line 757
  if (el) {
    {
#line 759
    free_elem_list(el->next);
    }
#line 761
    if (el->name) {
      {
#line 762
      free((void *)el->name);
      }
    }
#line 764
    if (el->payload) {
      {
#line 765
      free((void *)el->payload);
      }
    }
    {
#line 766
    free((void *)el);
    }
  }
#line 768
  return;
}
}
#line 783 "vhdl_bison.y"
static void vhdl_sem_deinit(vhdl_parser_priv_t *priv_data ) 
{ 
  port_desc_t *pd ;
  vhdl_elem_t *el ;

  {
  {
#line 785
  pd = (priv_data->jtag_ctrl)->port_desc;
#line 786
  el = (priv_data->jtag_ctrl)->vhdl_elem_first;
#line 789
  free_port_list(pd, 1);
#line 790
  free_port_list(& priv_data->tmp_port_desc, 0);
#line 793
  free_elem_list(el);
#line 795
  priv_data->jtag_ctrl = (jtag_ctrl_t *)((void *)0);
  }
#line 796
  return;
}
}
#line 814 "vhdl_bison.y"
vhdl_parser_priv_t *vhdl_parser_init(FILE *f , jtag_ctrl_t *jtag_ctrl ) 
{ 
  vhdl_parser_priv_t *new_priv ;
  void *tmp ;
  void *tmp___0 ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 818
  tmp = malloc((size_t )sizeof(vhdl_parser_priv_t ));
#line 818
  new_priv = (vhdl_parser_priv_t *)tmp;
  }
#line 818
  if (! new_priv) {
    {
#line 820
    bsdl_msg(jtag_ctrl->proc_mode, 2, "Out of memory, %s line %i\n", "vhdl_bison.y",
             821);
    }
#line 822
    return ((vhdl_parser_priv_t *)((void *)0));
  }
  {
#line 825
  new_priv->jtag_ctrl = jtag_ctrl;
#line 827
  new_priv->Reading_Package = 0;
#line 828
  new_priv->buffer = (char *)((void *)0);
#line 829
  new_priv->len_buffer = (size_t )0;
#line 831
  tmp___0 = vhdl_flex_init(f, jtag_ctrl->proc_mode);
#line 831
  new_priv->scanner = tmp___0;
  }
#line 831
  if (! tmp___0) {
    {
#line 833
    free((void *)new_priv);
#line 834
    new_priv = (vhdl_parser_priv_t *)((void *)0);
    }
  }
  {
#line 837
  vhdl_sem_init(new_priv);
  }
#line 839
  return (new_priv);
}
}
#line 857 "vhdl_bison.y"
void vhdl_parser_deinit(vhdl_parser_priv_t *priv_data ) 
{ 


  {
#line 859
  if (priv_data->buffer) {
    {
#line 861
    free((void *)priv_data->buffer);
#line 862
    priv_data->buffer = (char *)((void *)0);
    }
  }
  {
#line 865
  vhdl_sem_deinit(priv_data);
#line 866
  vhdl_flex_deinit(priv_data->scanner);
#line 867
  free((void *)priv_data);
  }
#line 868
  return;
}
}
#line 882 "vhdl_bison.y"
static void vhdl_set_entity(vhdl_parser_priv_t *priv , char *entityname ) 
{ 


  {
#line 884
  if ((priv->jtag_ctrl)->proc_mode & (1 << 6)) {
    {
#line 886
    strncpy((char */* __restrict  */)(((priv->jtag_ctrl)->part)->part), (char const   */* __restrict  */)entityname,
            (size_t )20);
#line 887
    ((priv->jtag_ctrl)->part)->part[20] = (char )'\000';
    }
  }
  {
#line 890
  free((void *)entityname);
  }
#line 891
  return;
}
}
#line 907 "vhdl_bison.y"
static void vhdl_port_add_name(vhdl_parser_priv_t *priv , char *name ) 
{ 
  port_desc_t *pd ;
  string_elem_t *new_string___1 ;
  void *tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 909
  pd = & priv->tmp_port_desc;
#line 912
  tmp = malloc((size_t )sizeof(string_elem_t ));
#line 912
  new_string___1 = (string_elem_t *)tmp;
  }
#line 913
  if (new_string___1) {
#line 915
    new_string___1->next = pd->names_list;
#line 916
    new_string___1->string = name;
#line 918
    pd->names_list = new_string___1;
  } else {
    {
#line 921
    bsdl_msg((priv->jtag_ctrl)->proc_mode, 3, "Out of memory, %s line %i\n", "vhdl_bison.y",
             922);
    }
  }
#line 923
  return;
}
}
#line 940 "vhdl_bison.y"
static void vhdl_port_add_bit(vhdl_parser_priv_t *priv ) 
{ 
  port_desc_t *pd ;

  {
#line 942
  pd = & priv->tmp_port_desc;
#line 944
  pd->is_vector = 0;
#line 945
  pd->low_idx = 0;
#line 946
  pd->high_idx = 0;
#line 947
  return;
}
}
#line 965 "vhdl_bison.y"
static void vhdl_port_add_range(vhdl_parser_priv_t *priv , int low , int high ) 
{ 
  port_desc_t *pd ;

  {
#line 967
  pd = & priv->tmp_port_desc;
#line 969
  pd->is_vector = 1;
#line 970
  pd->low_idx = low;
#line 971
  pd->high_idx = high;
#line 972
  return;
}
}
#line 987 "vhdl_bison.y"
static void vhdl_port_apply_port(vhdl_parser_priv_t *priv ) 
{ 
  port_desc_t *tmp_pd ;
  port_desc_t *pd ;
  void *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 989
  tmp_pd = & priv->tmp_port_desc;
#line 990
  tmp = malloc((size_t )sizeof(port_desc_t ));
#line 990
  pd = (port_desc_t *)tmp;
  }
#line 992
  if (pd) {
#line 995
    pd->next = (priv->jtag_ctrl)->port_desc;
#line 996
    (priv->jtag_ctrl)->port_desc = pd;
#line 999
    pd->names_list = tmp_pd->names_list;
#line 1000
    pd->is_vector = tmp_pd->is_vector;
#line 1001
    pd->low_idx = tmp_pd->low_idx;
#line 1002
    pd->high_idx = tmp_pd->high_idx;
#line 1005
    tmp_pd->names_list = (string_elem_t *)((void *)0);
#line 1006
    tmp_pd->next = (struct port_desc *)((void *)0);
  } else {
    {
#line 1009
    bsdl_msg((priv->jtag_ctrl)->proc_mode, 3, "Out of memory, %s line %i\n", "vhdl_bison.y",
             1010);
    }
  }
#line 1011
  return;
}
}
#line 1013 "vhdl_bison.y"
static void add_elem(vhdl_parser_priv_t *priv , vhdl_elem_t *el ) 
{ 
  jtag_ctrl_t *jc ;

  {
#line 1015
  jc = priv->jtag_ctrl;
#line 1017
  el->next = (struct vhdl_elem *)((void *)0);
#line 1018
  if (jc->vhdl_elem_last) {
#line 1019
    (jc->vhdl_elem_last)->next = el;
  }
#line 1020
  jc->vhdl_elem_last = el;
#line 1022
  if (! jc->vhdl_elem_first) {
#line 1023
    jc->vhdl_elem_first = el;
  }
  {
#line 1025
  el->line = vhdl_flex_get_lineno(priv->scanner);
  }
#line 1026
  return;
}
}
#line 1046 "vhdl_bison.y"
static void set_attr_decimal(vhdl_parser_priv_t *priv , char *name , int value ) 
{ 
  vhdl_elem_t *el ;
  void *tmp ;
  char *string ;
  void *tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 1048
  tmp = malloc((size_t )sizeof(vhdl_elem_t ));
#line 1048
  el = (vhdl_elem_t *)tmp;
#line 1049
  tmp___0 = malloc((size_t )10);
#line 1049
  string = (char *)tmp___0;
  }
#line 1051
  if (el) {
#line 1051
    if (string) {
      {
#line 1053
      el->type = (vhdl_elem_type_t )2;
#line 1054
      el->name = name;
#line 1055
      snprintf((char */* __restrict  */)string, (size_t )10, (char const   */* __restrict  */)"%d",
               value);
#line 1056
      el->payload = string;
#line 1058
      add_elem(priv, el);
      }
    } else {
      {
#line 1061
      bsdl_msg((priv->jtag_ctrl)->proc_mode, 3, "Out of memory, %s line %i\n", "vhdl_bison.y",
               1062);
      }
    }
  } else {
    {
#line 1061
    bsdl_msg((priv->jtag_ctrl)->proc_mode, 3, "Out of memory, %s line %i\n", "vhdl_bison.y",
             1062);
    }
  }
#line 1063
  return;
}
}
#line 1065 "vhdl_bison.y"
static void set_attr_string(vhdl_parser_priv_t *priv , char *name , char *string ) 
{ 
  vhdl_elem_t *el ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 1067
  tmp = malloc((size_t )sizeof(vhdl_elem_t ));
#line 1067
  el = (vhdl_elem_t *)tmp;
#line 1070
  tmp___0 = strcasecmp((char const   *)name, "DESIGN_WARNING");
  }
#line 1070
  if (tmp___0 == 0) {
    {
#line 1076
    free((void *)name);
#line 1077
    free((void *)string);
#line 1078
    free((void *)el);
    }
#line 1079
    return;
  } else {
    {
#line 1070
    tmp___1 = strcasecmp((char const   *)name, "BOUNDARY_CELLS");
    }
#line 1070
    if (tmp___1 == 0) {
      {
#line 1076
      free((void *)name);
#line 1077
      free((void *)string);
#line 1078
      free((void *)el);
      }
#line 1079
      return;
    } else {
      {
#line 1070
      tmp___2 = strcasecmp((char const   *)name, "INSTRUCTION_SEQUENCE");
      }
#line 1070
      if (tmp___2 == 0) {
        {
#line 1076
        free((void *)name);
#line 1077
        free((void *)string);
#line 1078
        free((void *)el);
        }
#line 1079
        return;
      } else {
        {
#line 1070
        tmp___3 = strcasecmp((char const   *)name, "INSTRUCTION_USAGE");
        }
#line 1070
        if (tmp___3 == 0) {
          {
#line 1076
          free((void *)name);
#line 1077
          free((void *)string);
#line 1078
          free((void *)el);
          }
#line 1079
          return;
        } else {
          {
#line 1070
          tmp___4 = strcasecmp((char const   *)name, "ISC_DESIGN_WARNING");
          }
#line 1070
          if (tmp___4 == 0) {
            {
#line 1076
            free((void *)name);
#line 1077
            free((void *)string);
#line 1078
            free((void *)el);
            }
#line 1079
            return;
          }
        }
      }
    }
  }
#line 1082
  if (el) {
    {
#line 1084
    el->type = (vhdl_elem_type_t )1;
#line 1085
    el->name = name;
#line 1086
    el->payload = string;
#line 1088
    add_elem(priv, el);
    }
  } else {
    {
#line 1091
    bsdl_msg((priv->jtag_ctrl)->proc_mode, 3, "Out of memory, %s line %i\n", "vhdl_bison.y",
             1092);
    }
  }
#line 1093
  return;
}
}
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 339 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 138 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncat)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
#line 61 "../../include/part.h"
data_register *part_find_data_register(part_t *p , char const   *drname ) ;
#line 49 "../../include/cmd.h"
int cmd_run(chain_t *chain , char **params ) ;
#line 36 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bsdl/bsdl_parser.h"
int bsdl_flex_get_compile_errors(void *scanner ) ;
#line 38
void bsdl_flex_switch_buffer(void *scanner , char const   *buffer , int lineno ) ;
#line 42
bsdl_parser_priv_t *bsdl_parser_init(jtag_ctrl_t *jtag_ctrl ) ;
#line 43
void bsdl_parser_deinit(bsdl_parser_priv_t *priv_data ) ;
#line 44
int bsdlparse(bsdl_parser_priv_t *priv_data ) ;
#line 47
int bsdl_process_elements(jtag_ctrl_t *jc , char const   *idcode___0 ) ;
#line 58 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bsdl/bsdl_sem.c"
static void print_cmd(char **cmd ) 
{ 
  int idx ;
  char *elem ;
  char const   *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 60
  idx = 0;
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    elem = *(cmd + idx);
#line 63
    if (! elem) {
#line 63
      goto while_break;
    }
#line 64
    if (idx > 0) {
#line 64
      tmp = " ";
    } else {
#line 64
      tmp = "";
    }
    {
#line 64
    printf((char const   */* __restrict  */)"%s%s", tmp, elem);
#line 65
    idx ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 67
  printf((char const   */* __restrict  */)"\n");
  }
#line 68
  return;
}
}
#line 84 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bsdl/bsdl_sem.c"
static int bsdl_set_instruction_length(jtag_ctrl_t *jc ) 
{ 
  char lenstring[6] ;
  char *cmd[4] ;
  void *__cil_tmp4 ;
  void *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 87
  cmd[0] = (char *)"instruction";
#line 87
  cmd[1] = (char *)"length";
#line 87
  cmd[2] = lenstring;
#line 87
  cmd[3] = (char *)((void *)0);
#line 92
  snprintf((char */* __restrict  */)(lenstring), (size_t )6, (char const   */* __restrict  */)"%i",
           jc->instr_len);
#line 93
  lenstring[5] = (char )'\000';
  }
#line 95
  if (jc->proc_mode & (1 << 6)) {
    {
#line 96
    cmd_run(jc->chain, cmd);
    }
  }
#line 97
  if (jc->proc_mode & (1 << 5)) {
    {
#line 98
    print_cmd(cmd);
    }
  }
#line 100
  return (1);
}
}
#line 122 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bsdl/bsdl_sem.c"
static int bsdl_emit_ports(jtag_ctrl_t *jc ) 
{ 
  port_desc_t *pd ;
  struct string_elem *name ;
  size_t str_len ;
  size_t name_len ;
  char *port_string ;
  int idx ;
  int result ;
  char *cmd[3] ;
  void *tmp ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 124
  pd = jc->port_desc;
#line 129
  result = 0;
#line 130
  cmd[0] = (char *)"signal";
#line 130
  cmd[1] = (char *)((void *)0);
#line 130
  cmd[2] = (char *)((void *)0);
  {
#line 134
  while (1) {
    while_continue: /* CIL Label */ ;
#line 134
    if (! pd) {
#line 134
      goto while_break;
    }
#line 136
    name = pd->names_list;
    {
#line 137
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 137
      if (! name) {
#line 137
        goto while_break___0;
      }
      {
#line 144
      name_len = strlen((char const   *)name->string);
#line 145
      str_len = (((name_len + 1U) + 10U) + 1U) + 1U;
#line 146
      tmp = malloc(str_len);
#line 146
      port_string = (char *)tmp;
      }
#line 146
      if ((unsigned long )port_string != (unsigned long )((void *)0)) {
#line 148
        cmd[1] = port_string;
#line 150
        idx = pd->low_idx;
        {
#line 150
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 150
          if (! (idx <= pd->high_idx)) {
#line 150
            goto while_break___1;
          }
#line 152
          if (pd->is_vector) {
            {
#line 153
            snprintf((char */* __restrict  */)port_string, str_len - 1U, (char const   */* __restrict  */)"%s(%d)",
                     name->string, idx);
            }
          } else {
            {
#line 155
            strncpy((char */* __restrict  */)port_string, (char const   */* __restrict  */)name->string,
                    str_len - 1U);
            }
          }
#line 156
          *(port_string + (str_len - 1U)) = (char )'\000';
#line 158
          if (jc->proc_mode & (1 << 6)) {
            {
#line 159
            cmd_run(jc->chain, cmd);
            }
          }
#line 160
          if (jc->proc_mode & (1 << 5)) {
            {
#line 161
            print_cmd(cmd);
            }
          }
#line 150
          idx ++;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 164
        free((void *)port_string);
#line 165
        result = 1;
        }
      } else {
        {
#line 168
        bsdl_msg(jc->proc_mode, 3, "Out of memory, %s line %i\n", "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bsdl/bsdl_sem.c",
                 169);
        }
      }
#line 171
      name = name->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 174
    pd = pd->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 177
  return (result);
}
}
#line 196 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bsdl/bsdl_sem.c"
static int create_register(jtag_ctrl_t *jc , char *reg_name , size_t len ) 
{ 
  size_t str_len ;
  char *len_str ;
  unsigned long __lengthoflen_str ;
  void *tmp ;
  char *cmd[4] ;
  data_register *tmp___0 ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 198
  str_len = (size_t )10;
#line 199
  __lengthoflen_str = (unsigned long )(str_len + 1U);
#line 199
  tmp = __builtin_alloca(sizeof(*len_str) * __lengthoflen_str);
#line 199
  len_str = (char *)tmp;
#line 200
  cmd[0] = (char *)"register";
#line 200
  cmd[1] = reg_name;
#line 200
  cmd[2] = len_str;
#line 200
  cmd[3] = (char *)((void *)0);
#line 205
  tmp___0 = part_find_data_register(jc->part, (char const   *)reg_name);
  }
#line 205
  if (tmp___0) {
#line 206
    return (1);
  }
  {
#line 209
  snprintf((char */* __restrict  */)len_str, str_len, (char const   */* __restrict  */)"%zu",
           len);
  }
#line 211
  if (jc->proc_mode & (1 << 6)) {
    {
#line 212
    cmd_run(jc->chain, cmd);
    }
  }
#line 213
  if (jc->proc_mode & (1 << 5)) {
    {
#line 214
    print_cmd(cmd);
    }
  }
#line 216
  return (1);
}
}
#line 232 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bsdl/bsdl_sem.c"
static int bsdl_process_idcode(jtag_ctrl_t *jc ) 
{ 
  size_t tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 234
  if (jc->idcode) {
    {
#line 235
    tmp = strlen((char const   *)jc->idcode);
#line 235
    create_register(jc, (char *)"DIR", tmp);
    }
  } else {
    {
#line 237
    bsdl_msg(jc->proc_mode, 1, "No IDCODE specification found.\n");
    }
  }
#line 240
  return (1);
}
}
#line 257 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bsdl/bsdl_sem.c"
static int bsdl_process_usercode(jtag_ctrl_t *jc ) 
{ 
  size_t tmp ;
  char *__cil_tmp3 ;

  {
#line 259
  if (jc->usercode) {
    {
#line 260
    tmp = strlen((char const   *)jc->usercode);
#line 260
    create_register(jc, (char *)"USERCODE", tmp);
    }
  }
#line 264
  return (1);
}
}
#line 280 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bsdl/bsdl_sem.c"
static int bsdl_set_bsr_length(jtag_ctrl_t *jc ) 
{ 
  char *__cil_tmp2 ;

  {
  {
#line 282
  create_register(jc, (char *)"BSR", (size_t )jc->bsr_len);
  }
#line 284
  return (1);
}
}
#line 302 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bsdl/bsdl_sem.c"
static int bsdl_process_cell_info(jtag_ctrl_t *jc ) 
{ 
  cell_info_t *ci ;
  size_t str_len ;
  char *bit_num_str ;
  unsigned long __lengthofbit_num_str ;
  void *tmp ;
  char *ctrl_bit_num_str ;
  unsigned long __lengthofctrl_bit_num_str ;
  void *tmp___0 ;
  char *disable_safe_value_str ;
  unsigned long __lengthofdisable_safe_value_str ;
  void *tmp___1 ;
  char *cmd[9] ;
  int tmp___3 ;
  void *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
  {
#line 304
  ci = jc->cell_info_first;
#line 305
  str_len = (size_t )10;
#line 306
  __lengthofbit_num_str = (unsigned long )(str_len + 1U);
#line 306
  tmp = __builtin_alloca(sizeof(*bit_num_str) * __lengthofbit_num_str);
#line 306
  bit_num_str = (char *)tmp;
#line 307
  __lengthofctrl_bit_num_str = (unsigned long )(str_len + 1U);
#line 307
  tmp___0 = __builtin_alloca(sizeof(*ctrl_bit_num_str) * __lengthofctrl_bit_num_str);
#line 307
  ctrl_bit_num_str = (char *)tmp___0;
#line 308
  __lengthofdisable_safe_value_str = (unsigned long )(str_len + 1U);
#line 308
  tmp___1 = __builtin_alloca(sizeof(*disable_safe_value_str) * __lengthofdisable_safe_value_str);
#line 308
  disable_safe_value_str = (char *)tmp___1;
#line 309
  cmd[0] = (char *)"bit";
#line 309
  cmd[1] = bit_num_str;
#line 309
  cmd[2] = (char *)((void *)0);
#line 309
  cmd[3] = (char *)((void *)0);
#line 309
  cmd[4] = (char *)((void *)0);
#line 309
  cmd[5] = (char *)((void *)0);
#line 309
  cmd[6] = disable_safe_value_str;
#line 309
  cmd[7] = (char *)"Z";
#line 309
  cmd[8] = (char *)((void *)0);
  }
  {
#line 319
  while (1) {
    while_continue: /* CIL Label */ ;
#line 319
    if (! ci) {
#line 319
      goto while_break;
    }
    {
#line 322
    snprintf((char */* __restrict  */)bit_num_str, str_len, (char const   */* __restrict  */)"%i",
             ci->bit_num);
#line 323
    *(bit_num_str + str_len) = (char )'\000';
    }
    {
#line 331
    if (ci->cell_function == 282) {
#line 331
      goto case_282;
    }
#line 331
    if (ci->cell_function == 281) {
#line 331
      goto case_282;
    }
#line 331
    if (ci->cell_function == 285) {
#line 331
      goto case_282;
    }
#line 338
    if (ci->cell_function == 286) {
#line 338
      goto case_286;
    }
#line 338
    if (ci->cell_function == 280) {
#line 338
      goto case_286;
    }
#line 338
    if (ci->cell_function == 308) {
#line 338
      goto case_286;
    }
#line 343
    if (ci->cell_function == 284) {
#line 343
      goto case_284;
    }
#line 343
    if (ci->cell_function == 283) {
#line 343
      goto case_284;
    }
#line 346
    if (ci->cell_function == 287) {
#line 346
      goto case_287;
    }
#line 349
    goto switch_default;
    case_282: /* CIL Label */ 
    case_281: /* CIL Label */ 
    case_285: /* CIL Label */ 
#line 332
    cmd[2] = (char *)"O";
#line 333
    goto switch_break;
    case_286: /* CIL Label */ 
    case_280: /* CIL Label */ 
    case_308: /* CIL Label */ 
#line 339
    cmd[2] = (char *)"I";
#line 340
    goto switch_break;
    case_284: /* CIL Label */ 
    case_283: /* CIL Label */ 
#line 344
    cmd[2] = (char *)"C";
#line 345
    goto switch_break;
    case_287: /* CIL Label */ 
#line 347
    cmd[2] = (char *)"B";
#line 348
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 351
    cmd[2] = (char *)"?";
#line 352
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 355
    tmp___3 = strcasecmp((char const   *)ci->basic_safe_value, "x");
    }
#line 355
    if (tmp___3 == 0) {
#line 355
      cmd[3] = (char *)"?";
    } else {
#line 355
      cmd[3] = ci->basic_safe_value;
    }
#line 357
    cmd[4] = ci->port_name;
#line 360
    if (ci->ctrl_bit_num >= 0) {
      {
#line 363
      snprintf((char */* __restrict  */)ctrl_bit_num_str, str_len, (char const   */* __restrict  */)"%i",
               ci->ctrl_bit_num);
#line 364
      *(ctrl_bit_num_str + str_len) = (char )'\000';
#line 366
      snprintf((char */* __restrict  */)disable_safe_value_str, str_len, (char const   */* __restrict  */)"%i",
               ci->disable_safe_value);
#line 367
      *(disable_safe_value_str + str_len) = (char )'\000';
#line 368
      cmd[5] = ctrl_bit_num_str;
      }
    } else {
#line 372
      cmd[5] = (char *)((void *)0);
    }
#line 374
    if (jc->proc_mode & (1 << 6)) {
      {
#line 375
      cmd_run(jc->chain, cmd);
      }
    }
#line 376
    if (jc->proc_mode & (1 << 5)) {
      {
#line 377
      print_cmd(cmd);
      }
    }
#line 379
    ci = ci->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 382
  return (1);
}
}
#line 410 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bsdl/bsdl_sem.c"
static int bsdl_process_register_access(jtag_ctrl_t *jc ) 
{ 
  ainfo_elem_t *ai ;
  instr_elem_t *cinst ;
  int is_std ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *reg_name ;
  char *instr_name ;
  instr_elem_t *tinst ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char *cmd[5] ;
  void *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;

  {
  {
#line 421
  create_register(jc, (char *)"BYPASS", (size_t )1);
#line 425
  ai = jc->ainfo_list;
  }
  {
#line 426
  while (1) {
    while_continue: /* CIL Label */ ;
#line 426
    if (! ai) {
#line 426
      goto while_break;
    }
    {
#line 428
    is_std = 0;
#line 430
    tmp = strcasecmp((char const   *)ai->reg, "BOUNDARY");
    }
#line 430
    if (tmp == 0) {
#line 430
      is_std = 1;
    }
    {
#line 431
    tmp___0 = strcasecmp((char const   *)ai->reg, "BYPASS");
    }
#line 431
    if (tmp___0 == 0) {
#line 431
      is_std = 1;
    }
    {
#line 432
    tmp___1 = strcasecmp((char const   *)ai->reg, "DEVICE_ID");
    }
#line 432
    if (tmp___1 == 0) {
#line 432
      is_std = 1;
    }
    {
#line 433
    tmp___2 = strcasecmp((char const   *)ai->reg, "USERCODE");
    }
#line 433
    if (tmp___2 == 0) {
#line 433
      is_std = 1;
    }
#line 435
    if (! is_std) {
      {
#line 436
      create_register(jc, ai->reg, (size_t )ai->reg_len);
      }
    }
#line 438
    ai = ai->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 444
  cinst = jc->instr_list;
  {
#line 445
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 445
    if (! cinst) {
#line 445
      goto while_break___0;
    }
#line 447
    reg_name = (char *)((void *)0);
#line 448
    instr_name = (char *)((void *)0);
#line 451
    ai = jc->ainfo_list;
    {
#line 452
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 452
      if (ai) {
#line 452
        if (! ((unsigned long )reg_name == (unsigned long )((void *)0))) {
#line 452
          goto while_break___1;
        }
      } else {
#line 452
        goto while_break___1;
      }
#line 454
      tinst = ai->instr_list;
      {
#line 456
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 456
        if (tinst) {
#line 456
          if (! ((unsigned long )reg_name == (unsigned long )((void *)0))) {
#line 456
            goto while_break___2;
          }
        } else {
#line 456
          goto while_break___2;
        }
        {
#line 458
        tmp___5 = strcasecmp((char const   *)tinst->instr, (char const   *)cinst->instr);
        }
#line 458
        if (tmp___5 == 0) {
          {
#line 463
          tmp___4 = strcasecmp((char const   *)ai->reg, "BOUNDARY");
          }
#line 463
          if (tmp___4 == 0) {
#line 463
            reg_name = (char *)"BSR";
          } else {
            {
#line 464
            tmp___3 = strcasecmp((char const   *)ai->reg, "DEVICE_ID");
            }
#line 464
            if (tmp___3 == 0) {
#line 464
              reg_name = (char *)"DIR";
            } else {
#line 465
              reg_name = ai->reg;
            }
          }
        }
#line 468
        tinst = tinst->next;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 471
      ai = ai->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 474
    if ((unsigned long )reg_name == (unsigned long )((void *)0)) {
      {
#line 479
      tmp___14 = strcasecmp((char const   *)cinst->instr, "BYPASS");
      }
#line 479
      if (tmp___14 == 0) {
#line 479
        reg_name = (char *)"BYPASS";
      } else {
        {
#line 480
        tmp___13 = strcasecmp((char const   *)cinst->instr, "CLAMP");
        }
#line 480
        if (tmp___13 == 0) {
#line 480
          reg_name = (char *)"BYPASS";
        } else {
          {
#line 481
          tmp___12 = strcasecmp((char const   *)cinst->instr, "EXTEST");
          }
#line 481
          if (tmp___12 == 0) {
#line 481
            reg_name = (char *)"BSR";
          } else {
            {
#line 482
            tmp___11 = strcasecmp((char const   *)cinst->instr, "HIGHZ");
            }
#line 482
            if (tmp___11 == 0) {
#line 482
              reg_name = (char *)"BYPASS";
            } else {
              {
#line 483
              tmp___10 = strcasecmp((char const   *)cinst->instr, "IDCODE");
              }
#line 483
              if (tmp___10 == 0) {
#line 483
                reg_name = (char *)"DIR";
              } else {
                {
#line 484
                tmp___9 = strcasecmp((char const   *)cinst->instr, "INTEST");
                }
#line 484
                if (tmp___9 == 0) {
#line 484
                  reg_name = (char *)"BSR";
                } else {
                  {
#line 485
                  tmp___8 = strcasecmp((char const   *)cinst->instr, "PRELOAD");
                  }
#line 485
                  if (tmp___8 == 0) {
#line 485
                    reg_name = (char *)"BSR";
                  } else {
                    {
#line 486
                    tmp___7 = strcasecmp((char const   *)cinst->instr, "SAMPLE");
                    }
#line 486
                    if (tmp___7 == 0) {
#line 486
                      reg_name = (char *)"BSR";
                    } else {
                      {
#line 487
                      tmp___6 = strcasecmp((char const   *)cinst->instr, "USERCODE");
                      }
#line 487
                      if (tmp___6 == 0) {
#line 487
                        reg_name = (char *)"USERCODE";
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    {
#line 490
    tmp___15 = strcasecmp((char const   *)cinst->instr, "SAMPLE");
    }
#line 490
    if (tmp___15 == 0) {
#line 491
      instr_name = (char *)"SAMPLE/PRELOAD";
    } else {
#line 493
      instr_name = cinst->instr;
    }
#line 495
    if (reg_name) {
#line 497
      cmd[0] = (char *)"instruction";
#line 497
      cmd[1] = instr_name;
#line 497
      cmd[2] = cinst->opcode;
#line 497
      cmd[3] = reg_name;
#line 497
      cmd[4] = (char *)((void *)0);
#line 503
      if (jc->proc_mode & (1 << 6)) {
        {
#line 504
        cmd_run(jc->chain, cmd);
        }
      }
#line 505
      if (jc->proc_mode & (1 << 5)) {
        {
#line 506
        print_cmd(cmd);
        }
      }
    }
#line 509
    cinst = cinst->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 512
  return (1);
}
}
#line 529 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bsdl/bsdl_sem.c"
static int parse_vhdl_elem(bsdl_parser_priv_t *priv , vhdl_elem_t *elem ) 
{ 
  char *buf ;
  size_t buf_len ;
  size_t name_string_len ;
  size_t elem_string_len ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 536
  if (elem->name) {
    {
#line 536
    tmp = strlen((char const   *)elem->name);
#line 536
    name_string_len = tmp;
    }
  } else {
#line 536
    name_string_len = (size_t )0;
  }
#line 537
  if (elem->payload) {
    {
#line 537
    tmp___0 = strlen((char const   *)elem->payload);
#line 537
    elem_string_len = tmp___0;
    }
  } else {
#line 537
    elem_string_len = (size_t )0;
  }
  {
#line 540
  buf_len = ((name_string_len + 1U) + elem_string_len) + 1U;
#line 541
  tmp___1 = malloc(buf_len);
#line 541
  buf = (char *)tmp___1;
  }
#line 542
  if (! buf) {
    {
#line 544
    bsdl_msg((priv->jtag_ctrl)->proc_mode, 3, "Out of memory, %s line %i\n", "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bsdl/bsdl_sem.c",
             545);
    }
#line 546
    return (-1);
  }
#line 548
  *(buf + 0) = (char )'\000';
#line 550
  if (name_string_len > 0U) {
    {
#line 551
    strncat((char */* __restrict  */)buf, (char const   */* __restrict  */)elem->name,
            buf_len);
    }
  }
  {
#line 552
  strncat((char */* __restrict  */)buf, (char const   */* __restrict  */)" ", buf_len - name_string_len);
  }
#line 554
  if (elem_string_len > 0U) {
    {
#line 555
    strncat((char */* __restrict  */)buf, (char const   */* __restrict  */)elem->payload,
            (buf_len - name_string_len) - 1U);
    }
  }
  {
#line 557
  *(buf + (buf_len - 1U)) = (char )'\000';
#line 559
  priv->lineno = elem->line;
#line 562
  bsdl_flex_switch_buffer(priv->scanner, (char const   *)buf, elem->line);
#line 563
  bsdlparse(priv);
#line 565
  free((void *)buf);
#line 567
  tmp___4 = bsdl_flex_get_compile_errors(priv->scanner);
  }
#line 567
  if (tmp___4 == 0) {
#line 567
    tmp___3 = 1 << 4;
  } else {
#line 567
    tmp___3 = 0;
  }
#line 567
  return (tmp___3);
}
}
#line 584 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bsdl/bsdl_sem.c"
static int build_commands(bsdl_parser_priv_t *priv ) 
{ 
  jtag_ctrl_t *jc ;
  int result ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 586
  jc = priv->jtag_ctrl;
#line 587
  result = 1;
#line 589
  tmp = bsdl_emit_ports(jc);
#line 589
  result &= tmp;
#line 591
  tmp___0 = bsdl_set_instruction_length(jc);
#line 591
  result &= tmp___0;
#line 593
  tmp___1 = bsdl_process_idcode(jc);
#line 593
  result &= tmp___1;
#line 595
  tmp___2 = bsdl_process_usercode(jc);
#line 595
  result &= tmp___2;
#line 597
  tmp___3 = bsdl_set_bsr_length(jc);
#line 597
  result &= tmp___3;
#line 599
  tmp___4 = bsdl_process_register_access(jc);
#line 599
  result &= tmp___4;
#line 601
  tmp___5 = bsdl_process_cell_info(jc);
#line 601
  result &= tmp___5;
  }
#line 603
  if (result) {
#line 603
    tmp___6 = (1 << 6) | (1 << 5);
  } else {
#line 603
    tmp___6 = 0;
  }
#line 603
  return (tmp___6);
}
}
#line 620 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bsdl/bsdl_sem.c"
static int compare_idcode(jtag_ctrl_t *jc , char const   *idcode___0 ) 
{ 
  int idcode_match ;
  int idx ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 622
  idcode_match = 0;
#line 625
  if (idcode___0) {
    {
#line 627
    tmp___0 = strlen(idcode___0);
#line 627
    tmp___1 = strlen((char const   *)jc->idcode);
    }
#line 627
    if (tmp___0 == tmp___1) {
#line 632
      idcode_match = 1 << 7;
#line 633
      idx = 0;
      {
#line 633
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 633
        tmp = strlen(idcode___0);
        }
#line 633
        if (! ((size_t )idx < tmp)) {
#line 633
          goto while_break;
        }
#line 634
        if ((int )*(jc->idcode + idx) != 88) {
#line 635
          if ((int const   )*(idcode___0 + idx) != (int const   )*(jc->idcode + idx)) {
#line 636
            idcode_match = 0;
          }
        }
#line 633
        idx ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 638
      if (idcode_match) {
        {
#line 639
        bsdl_msg(jc->proc_mode, 0, "IDCODE matched\n");
        }
      } else {
        {
#line 642
        bsdl_msg(jc->proc_mode, 0, "IDCODE mismatch\n");
        }
      }
    }
  }
#line 647
  return (idcode_match);
}
}
#line 669 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bsdl/bsdl_sem.c"
int bsdl_process_elements(jtag_ctrl_t *jc , char const   *idcode___0 ) 
{ 
  bsdl_parser_priv_t *priv ;
  vhdl_elem_t *el ;
  int result ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 672
  el = jc->vhdl_elem_first;
#line 673
  result = 1 << 4;
#line 675
  priv = bsdl_parser_init(jc);
  }
#line 675
  if ((unsigned long )priv == (unsigned long )((void *)0)) {
#line 676
    return (-1);
  }
#line 678
  if (jc->proc_mode & (1 << 4)) {
    {
#line 680
    while (1) {
      while_continue: /* CIL Label */ ;
#line 680
      if (el) {
#line 680
        if (! (result & (1 << 4))) {
#line 680
          goto while_break;
        }
      } else {
#line 680
        goto while_break;
      }
      {
#line 682
      result = parse_vhdl_elem(priv, el);
#line 684
      el = el->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 687
    if (! (result & (1 << 4))) {
      {
#line 689
      bsdl_msg(jc->proc_mode, 2, "BSDL stage reported errors, aborting.\n");
#line 691
      bsdl_parser_deinit(priv);
      }
#line 692
      return (-1);
    }
  }
#line 696
  if (jc->idcode) {
    {
#line 697
    bsdl_msg(jc->proc_mode, 0, "Got IDCODE: %s\n", jc->idcode);
    }
  }
#line 700
  if (jc->proc_mode & (1 << 7)) {
    {
#line 701
    tmp = compare_idcode(jc, idcode___0);
#line 701
    result |= tmp;
    }
  }
#line 703
  if (jc->proc_mode & ((1 << 6) | (1 << 5))) {
#line 705
    if (jc->proc_mode & (1 << 7)) {
#line 705
      if (result & (1 << 7)) {
        {
#line 708
        tmp___0 = build_commands(priv);
#line 708
        result |= tmp___0;
        }
      } else {
#line 705
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 705
    if (! (jc->proc_mode & (1 << 7))) {
      {
#line 708
      tmp___0 = build_commands(priv);
#line 708
      result |= tmp___0;
      }
    }
  }
#line 710
  if ((result & jc->proc_mode) == (jc->proc_mode & ((((1 << 4) | (1 << 5)) | (1 << 6)) | (1 << 7)))) {
#line 711
    if (jc->proc_mode & (1 << 7)) {
#line 712
      result = 1;
    } else {
#line 714
      result = 0;
    }
  } else {
#line 716
    result = -1;
  }
  {
#line 718
  bsdl_parser_deinit(priv);
  }
#line 720
  return (result);
}
}
#line 289 "bsdl_flex.c"
void bsdlrestart(FILE *input_file , yyscan_t yyscanner ) ;
#line 290
void bsdl_switch_to_buffer(YY_BUFFER_STATE new_buffer , yyscan_t yyscanner ) ;
#line 291
YY_BUFFER_STATE bsdl_create_buffer(FILE *file , int size , yyscan_t yyscanner ) ;
#line 292
void bsdl_delete_buffer(YY_BUFFER_STATE b , yyscan_t yyscanner ) ;
#line 293
void bsdl_flush_buffer(YY_BUFFER_STATE b , yyscan_t yyscanner ) ;
#line 294
void bsdlpush_buffer_state(YY_BUFFER_STATE new_buffer , yyscan_t yyscanner ) ;
#line 295
void bsdlpop_buffer_state(yyscan_t yyscanner ) ;
#line 297
static void bsdlensure_buffer_stack(yyscan_t yyscanner ) ;
#line 298
static void bsdl_load_buffer_state(yyscan_t yyscanner ) ;
#line 299
static void bsdl_init_buffer(YY_BUFFER_STATE b , FILE *file , yyscan_t yyscanner ) ;
#line 303
YY_BUFFER_STATE bsdl_scan_buffer(char *base , yy_size_t size , yyscan_t yyscanner ) ;
#line 304
YY_BUFFER_STATE bsdl_scan_string(char const   *yystr , yyscan_t yyscanner ) ;
#line 305
YY_BUFFER_STATE bsdl_scan_bytes(char const   *yybytes , int _yybytes_len , yyscan_t yyscanner ) ;
#line 307
void *bsdlalloc(yy_size_t size , yyscan_t yyscanner ) ;
#line 308
void *bsdlrealloc(void *ptr , yy_size_t size , yyscan_t yyscanner ) ;
#line 309
void bsdlfree(void *ptr , yyscan_t yyscanner ) ;
#line 343
static yy_state_type yy_get_previous_state___0(yyscan_t yyscanner ) ;
#line 344
static yy_state_type yy_try_NUL_trans___0(yy_state_type yy_current_state , yyscan_t yyscanner ) ;
#line 345
static int yy_get_next_buffer___0(yyscan_t yyscanner ) ;
#line 346
static void yy_fatal_error___0(char const   *msg , yyscan_t yyscanner ) ;
#line 367 "bsdl_flex.c"
static flex_int16_t const   yy_acclist___0[880]  = 
#line 367
  {      (flex_int16_t const   )0,      (flex_int16_t const   )107,      (flex_int16_t const   )107,      (flex_int16_t const   )107, 
        (flex_int16_t const   )107,      (flex_int16_t const   )107,      (flex_int16_t const   )107,      (flex_int16_t const   )107, 
        (flex_int16_t const   )107,      (flex_int16_t const   )107,      (flex_int16_t const   )107,      (flex_int16_t const   )107, 
        (flex_int16_t const   )107,      (flex_int16_t const   )117,      (flex_int16_t const   )115,      (flex_int16_t const   )116, 
        (flex_int16_t const   )107,      (flex_int16_t const   )116,      (flex_int16_t const   )99,      (flex_int16_t const   )116, 
        (flex_int16_t const   )116,      (flex_int16_t const   )101,      (flex_int16_t const   )116,      (flex_int16_t const   )102, 
        (flex_int16_t const   )116,      (flex_int16_t const   )106,      (flex_int16_t const   )116,      (flex_int16_t const   )100, 
        (flex_int16_t const   )116,      (flex_int16_t const   )116,      (flex_int16_t const   )109,      (flex_int16_t const   )110, 
        (flex_int16_t const   )112,      (flex_int16_t const   )113,      (flex_int16_t const   )116,      (flex_int16_t const   )110, 
        (flex_int16_t const   )113,      (flex_int16_t const   )116,      (flex_int16_t const   )105,      (flex_int16_t const   )116, 
        (flex_int16_t const   )110,      (flex_int16_t const   )111,      (flex_int16_t const   )116,      (flex_int16_t const   )110, 
        (flex_int16_t const   )111,      (flex_int16_t const   )116,      (flex_int16_t const   )110,      (flex_int16_t const   )111, 
        (flex_int16_t const   )116,      (flex_int16_t const   )111,      (flex_int16_t const   )116,      (flex_int16_t const   )111, 
        (flex_int16_t const   )116,      (flex_int16_t const   )111,      (flex_int16_t const   )116,      (flex_int16_t const   )111, 
        (flex_int16_t const   )116,      (flex_int16_t const   )111,      (flex_int16_t const   )116,      (flex_int16_t const   )111, 
        (flex_int16_t const   )116,      (flex_int16_t const   )111,      (flex_int16_t const   )116,      (flex_int16_t const   )109, 
        (flex_int16_t const   )111,      (flex_int16_t const   )116,      (flex_int16_t const   )103,      (flex_int16_t const   )116, 
        (flex_int16_t const   )104,      (flex_int16_t const   )116,      (flex_int16_t const   )110,      (flex_int16_t const   )111, 
        (flex_int16_t const   )116,      (flex_int16_t const   )110,      (flex_int16_t const   )111,      (flex_int16_t const   )116, 
        (flex_int16_t const   )111,      (flex_int16_t const   )116,      (flex_int16_t const   )111,      (flex_int16_t const   )116, 
        (flex_int16_t const   )111,      (flex_int16_t const   )116,      (flex_int16_t const   )111,      (flex_int16_t const   )116, 
        (flex_int16_t const   )111,      (flex_int16_t const   )116,      (flex_int16_t const   )93,      (flex_int16_t const   )111, 
        (flex_int16_t const   )116,      (flex_int16_t const   )110,      (flex_int16_t const   )111,      (flex_int16_t const   )116, 
        (flex_int16_t const   )110,      (flex_int16_t const   )111,      (flex_int16_t const   )116,      (flex_int16_t const   )110, 
        (flex_int16_t const   )111,      (flex_int16_t const   )116,      (flex_int16_t const   )110,      (flex_int16_t const   )111, 
        (flex_int16_t const   )116,      (flex_int16_t const   )111,      (flex_int16_t const   )116,      (flex_int16_t const   )111, 
        (flex_int16_t const   )116,      (flex_int16_t const   )111,      (flex_int16_t const   )116,      (flex_int16_t const   )111, 
        (flex_int16_t const   )116,      (flex_int16_t const   )111,      (flex_int16_t const   )116,      (flex_int16_t const   )111, 
        (flex_int16_t const   )116,      (flex_int16_t const   )110,      (flex_int16_t const   )111,      (flex_int16_t const   )116, 
        (flex_int16_t const   )63,      (flex_int16_t const   )116,      (flex_int16_t const   )54,      (flex_int16_t const   )116, 
        (flex_int16_t const   )56,      (flex_int16_t const   )116,      (flex_int16_t const   )57,      (flex_int16_t const   )116, 
        (flex_int16_t const   )116,      (flex_int16_t const   )55,      (flex_int16_t const   )116,      (flex_int16_t const   )116, 
        (flex_int16_t const   )62,      (flex_int16_t const   )116,      (flex_int16_t const   )110,      (flex_int16_t const   )111, 
        (flex_int16_t const   )116,      (flex_int16_t const   )110,      (flex_int16_t const   )111,      (flex_int16_t const   )116, 
        (flex_int16_t const   )110,      (flex_int16_t const   )111,      (flex_int16_t const   )116,      (flex_int16_t const   )111, 
        (flex_int16_t const   )116,      (flex_int16_t const   )111,      (flex_int16_t const   )116,      (flex_int16_t const   )111, 
        (flex_int16_t const   )116,      (flex_int16_t const   )111,      (flex_int16_t const   )116,      (flex_int16_t const   )111, 
        (flex_int16_t const   )116,      (flex_int16_t const   )111,      (flex_int16_t const   )116,      (flex_int16_t const   )111, 
        (flex_int16_t const   )116,      (flex_int16_t const   )111,      (flex_int16_t const   )116,      (flex_int16_t const   )111, 
        (flex_int16_t const   )116,      (flex_int16_t const   )111,      (flex_int16_t const   )116,      (flex_int16_t const   )60, 
        (flex_int16_t const   )116,      (flex_int16_t const   )107,      (flex_int16_t const   )108,      (flex_int16_t const   )109, 
        (flex_int16_t const   )110,      (flex_int16_t const   )112,      (flex_int16_t const   )113,      (flex_int16_t const   )110, 
        (flex_int16_t const   )113,      (flex_int16_t const   )110,      (flex_int16_t const   )109,      (flex_int16_t const   )110, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )109,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )110, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )59,      (flex_int16_t const   )58, 
        (flex_int16_t const   )61,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )108,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )52,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )51,      (flex_int16_t const   )111,      (flex_int16_t const   )50,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )53,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )48,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )49,      (flex_int16_t const   )111,      (flex_int16_t const   )114,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )90, 
        (flex_int16_t const   )111,      (flex_int16_t const   )88,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )82,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )96,      (flex_int16_t const   )111, 
        (flex_int16_t const   )97,      (flex_int16_t const   )111,      (flex_int16_t const   )94,      (flex_int16_t const   )111, 
        (flex_int16_t const   )95,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )72,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )74,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )42,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )98,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )70,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )73,      (flex_int16_t const   )111,      (flex_int16_t const   )75,      (flex_int16_t const   )111, 
        (flex_int16_t const   )76,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )79,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )46, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )2,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )86,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )83,      (flex_int16_t const   )111,      (flex_int16_t const   )84, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )77, 
        (flex_int16_t const   )111,      (flex_int16_t const   )78,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )44,      (flex_int16_t const   )77, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )1,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )39,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )85,      (flex_int16_t const   )111,      (flex_int16_t const   )87,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )71,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )80,      (flex_int16_t const   )111,      (flex_int16_t const   )91,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )67,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )43,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )81, 
        (flex_int16_t const   )111,      (flex_int16_t const   )92,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )47,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )65,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )31, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )45, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )5,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )32,      (flex_int16_t const   )111,      (flex_int16_t const   )66,      (flex_int16_t const   )111, 
        (flex_int16_t const   )68,      (flex_int16_t const   )111,      (flex_int16_t const   )40,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )34,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )6, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )89, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )64,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )27,      (flex_int16_t const   )111,      (flex_int16_t const   )28, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )8,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )41,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )4,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )7,      (flex_int16_t const   )111, 
        (flex_int16_t const   )9,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )17, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )19,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )26,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )38,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )16,      (flex_int16_t const   )111,      (flex_int16_t const   )23,      (flex_int16_t const   )111, 
        (flex_int16_t const   )24,      (flex_int16_t const   )111,      (flex_int16_t const   )25,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )35,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )69,      (flex_int16_t const   )111,      (flex_int16_t const   )29,      (flex_int16_t const   )111, 
        (flex_int16_t const   )3,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )18, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )14,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )37, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )20, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )10,      (flex_int16_t const   )111,      (flex_int16_t const   )11, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )33,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )21,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )12,      (flex_int16_t const   )111,      (flex_int16_t const   )13, 
        (flex_int16_t const   )111,      (flex_int16_t const   )15,      (flex_int16_t const   )111,      (flex_int16_t const   )36, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )22,      (flex_int16_t const   )111,      (flex_int16_t const   )30,      (flex_int16_t const   )111};
#line 467 "bsdl_flex.c"
static flex_int16_t const   yy_accept___0[710]  = 
#line 467
  {      (flex_int16_t const   )0,      (flex_int16_t const   )1,      (flex_int16_t const   )2,      (flex_int16_t const   )3, 
        (flex_int16_t const   )4,      (flex_int16_t const   )5,      (flex_int16_t const   )6,      (flex_int16_t const   )7, 
        (flex_int16_t const   )8,      (flex_int16_t const   )9,      (flex_int16_t const   )10,      (flex_int16_t const   )11, 
        (flex_int16_t const   )12,      (flex_int16_t const   )13,      (flex_int16_t const   )14,      (flex_int16_t const   )16, 
        (flex_int16_t const   )18,      (flex_int16_t const   )20,      (flex_int16_t const   )21,      (flex_int16_t const   )23, 
        (flex_int16_t const   )25,      (flex_int16_t const   )27,      (flex_int16_t const   )29,      (flex_int16_t const   )30, 
        (flex_int16_t const   )35,      (flex_int16_t const   )38,      (flex_int16_t const   )40,      (flex_int16_t const   )43, 
        (flex_int16_t const   )46,      (flex_int16_t const   )49,      (flex_int16_t const   )51,      (flex_int16_t const   )53, 
        (flex_int16_t const   )55,      (flex_int16_t const   )57,      (flex_int16_t const   )59,      (flex_int16_t const   )61, 
        (flex_int16_t const   )63,      (flex_int16_t const   )66,      (flex_int16_t const   )68,      (flex_int16_t const   )70, 
        (flex_int16_t const   )73,      (flex_int16_t const   )76,      (flex_int16_t const   )78,      (flex_int16_t const   )80, 
        (flex_int16_t const   )82,      (flex_int16_t const   )84,      (flex_int16_t const   )86,      (flex_int16_t const   )89, 
        (flex_int16_t const   )92,      (flex_int16_t const   )95,      (flex_int16_t const   )98,      (flex_int16_t const   )101, 
        (flex_int16_t const   )103,      (flex_int16_t const   )105,      (flex_int16_t const   )107,      (flex_int16_t const   )109, 
        (flex_int16_t const   )111,      (flex_int16_t const   )113,      (flex_int16_t const   )116,      (flex_int16_t const   )118, 
        (flex_int16_t const   )120,      (flex_int16_t const   )122,      (flex_int16_t const   )124,      (flex_int16_t const   )125, 
        (flex_int16_t const   )127,      (flex_int16_t const   )128,      (flex_int16_t const   )130,      (flex_int16_t const   )133, 
        (flex_int16_t const   )136,      (flex_int16_t const   )139,      (flex_int16_t const   )141,      (flex_int16_t const   )143, 
        (flex_int16_t const   )145,      (flex_int16_t const   )147,      (flex_int16_t const   )149,      (flex_int16_t const   )151, 
        (flex_int16_t const   )153,      (flex_int16_t const   )155,      (flex_int16_t const   )157,      (flex_int16_t const   )159, 
        (flex_int16_t const   )161,      (flex_int16_t const   )162,      (flex_int16_t const   )163,      (flex_int16_t const   )163, 
        (flex_int16_t const   )167,      (flex_int16_t const   )169,      (flex_int16_t const   )170,      (flex_int16_t const   )171, 
        (flex_int16_t const   )173,      (flex_int16_t const   )174,      (flex_int16_t const   )175,      (flex_int16_t const   )176, 
        (flex_int16_t const   )177,      (flex_int16_t const   )178,      (flex_int16_t const   )179,      (flex_int16_t const   )180, 
        (flex_int16_t const   )181,      (flex_int16_t const   )182,      (flex_int16_t const   )183,      (flex_int16_t const   )184, 
        (flex_int16_t const   )185,      (flex_int16_t const   )187,      (flex_int16_t const   )188,      (flex_int16_t const   )189, 
        (flex_int16_t const   )190,      (flex_int16_t const   )191,      (flex_int16_t const   )192,      (flex_int16_t const   )193, 
        (flex_int16_t const   )194,      (flex_int16_t const   )195,      (flex_int16_t const   )196,      (flex_int16_t const   )197, 
        (flex_int16_t const   )198,      (flex_int16_t const   )199,      (flex_int16_t const   )201,      (flex_int16_t const   )202, 
        (flex_int16_t const   )203,      (flex_int16_t const   )204,      (flex_int16_t const   )205,      (flex_int16_t const   )206, 
        (flex_int16_t const   )207,      (flex_int16_t const   )208,      (flex_int16_t const   )209,      (flex_int16_t const   )210, 
        (flex_int16_t const   )211,      (flex_int16_t const   )212,      (flex_int16_t const   )213,      (flex_int16_t const   )214, 
        (flex_int16_t const   )215,      (flex_int16_t const   )216,      (flex_int16_t const   )217,      (flex_int16_t const   )218, 
        (flex_int16_t const   )219,      (flex_int16_t const   )220,      (flex_int16_t const   )221,      (flex_int16_t const   )222, 
        (flex_int16_t const   )223,      (flex_int16_t const   )224,      (flex_int16_t const   )225,      (flex_int16_t const   )226, 
        (flex_int16_t const   )227,      (flex_int16_t const   )228,      (flex_int16_t const   )229,      (flex_int16_t const   )230, 
        (flex_int16_t const   )230,      (flex_int16_t const   )231,      (flex_int16_t const   )232,      (flex_int16_t const   )233, 
        (flex_int16_t const   )234,      (flex_int16_t const   )235,      (flex_int16_t const   )236,      (flex_int16_t const   )237, 
        (flex_int16_t const   )238,      (flex_int16_t const   )239,      (flex_int16_t const   )240,      (flex_int16_t const   )241, 
        (flex_int16_t const   )242,      (flex_int16_t const   )243,      (flex_int16_t const   )244,      (flex_int16_t const   )245, 
        (flex_int16_t const   )246,      (flex_int16_t const   )247,      (flex_int16_t const   )248,      (flex_int16_t const   )249, 
        (flex_int16_t const   )250,      (flex_int16_t const   )251,      (flex_int16_t const   )252,      (flex_int16_t const   )253, 
        (flex_int16_t const   )254,      (flex_int16_t const   )255,      (flex_int16_t const   )256,      (flex_int16_t const   )257, 
        (flex_int16_t const   )258,      (flex_int16_t const   )259,      (flex_int16_t const   )260,      (flex_int16_t const   )261, 
        (flex_int16_t const   )262,      (flex_int16_t const   )263,      (flex_int16_t const   )264,      (flex_int16_t const   )265, 
        (flex_int16_t const   )266,      (flex_int16_t const   )268,      (flex_int16_t const   )269,      (flex_int16_t const   )270, 
        (flex_int16_t const   )271,      (flex_int16_t const   )272,      (flex_int16_t const   )274,      (flex_int16_t const   )276, 
        (flex_int16_t const   )277,      (flex_int16_t const   )279,      (flex_int16_t const   )280,      (flex_int16_t const   )281, 
        (flex_int16_t const   )282,      (flex_int16_t const   )283,      (flex_int16_t const   )284,      (flex_int16_t const   )285, 
        (flex_int16_t const   )286,      (flex_int16_t const   )287,      (flex_int16_t const   )287,      (flex_int16_t const   )288, 
        (flex_int16_t const   )289,      (flex_int16_t const   )290,      (flex_int16_t const   )291,      (flex_int16_t const   )292, 
        (flex_int16_t const   )293,      (flex_int16_t const   )294,      (flex_int16_t const   )295,      (flex_int16_t const   )296, 
        (flex_int16_t const   )297,      (flex_int16_t const   )298,      (flex_int16_t const   )299,      (flex_int16_t const   )300, 
        (flex_int16_t const   )301,      (flex_int16_t const   )302,      (flex_int16_t const   )303,      (flex_int16_t const   )304, 
        (flex_int16_t const   )305,      (flex_int16_t const   )306,      (flex_int16_t const   )307,      (flex_int16_t const   )308, 
        (flex_int16_t const   )309,      (flex_int16_t const   )310,      (flex_int16_t const   )311,      (flex_int16_t const   )312, 
        (flex_int16_t const   )313,      (flex_int16_t const   )314,      (flex_int16_t const   )315,      (flex_int16_t const   )316, 
        (flex_int16_t const   )317,      (flex_int16_t const   )318,      (flex_int16_t const   )319,      (flex_int16_t const   )320, 
        (flex_int16_t const   )321,      (flex_int16_t const   )322,      (flex_int16_t const   )323,      (flex_int16_t const   )324, 
        (flex_int16_t const   )325,      (flex_int16_t const   )326,      (flex_int16_t const   )328,      (flex_int16_t const   )329, 
        (flex_int16_t const   )330,      (flex_int16_t const   )331,      (flex_int16_t const   )332,      (flex_int16_t const   )333, 
        (flex_int16_t const   )334,      (flex_int16_t const   )335,      (flex_int16_t const   )336,      (flex_int16_t const   )338, 
        (flex_int16_t const   )338,      (flex_int16_t const   )339,      (flex_int16_t const   )340,      (flex_int16_t const   )341, 
        (flex_int16_t const   )342,      (flex_int16_t const   )343,      (flex_int16_t const   )344,      (flex_int16_t const   )345, 
        (flex_int16_t const   )346,      (flex_int16_t const   )347,      (flex_int16_t const   )348,      (flex_int16_t const   )349, 
        (flex_int16_t const   )350,      (flex_int16_t const   )351,      (flex_int16_t const   )352,      (flex_int16_t const   )353, 
        (flex_int16_t const   )354,      (flex_int16_t const   )355,      (flex_int16_t const   )356,      (flex_int16_t const   )357, 
        (flex_int16_t const   )358,      (flex_int16_t const   )359,      (flex_int16_t const   )361,      (flex_int16_t const   )363, 
        (flex_int16_t const   )364,      (flex_int16_t const   )366,      (flex_int16_t const   )367,      (flex_int16_t const   )368, 
        (flex_int16_t const   )369,      (flex_int16_t const   )370,      (flex_int16_t const   )372,      (flex_int16_t const   )374, 
        (flex_int16_t const   )376,      (flex_int16_t const   )378,      (flex_int16_t const   )379,      (flex_int16_t const   )380, 
        (flex_int16_t const   )382,      (flex_int16_t const   )383,      (flex_int16_t const   )384,      (flex_int16_t const   )386, 
        (flex_int16_t const   )387,      (flex_int16_t const   )388,      (flex_int16_t const   )389,      (flex_int16_t const   )390, 
        (flex_int16_t const   )391,      (flex_int16_t const   )392,      (flex_int16_t const   )393,      (flex_int16_t const   )395, 
        (flex_int16_t const   )396,      (flex_int16_t const   )397,      (flex_int16_t const   )398,      (flex_int16_t const   )399, 
        (flex_int16_t const   )400,      (flex_int16_t const   )401,      (flex_int16_t const   )402,      (flex_int16_t const   )403, 
        (flex_int16_t const   )404,      (flex_int16_t const   )405,      (flex_int16_t const   )406,      (flex_int16_t const   )407, 
        (flex_int16_t const   )408,      (flex_int16_t const   )409,      (flex_int16_t const   )410,      (flex_int16_t const   )411, 
        (flex_int16_t const   )412,      (flex_int16_t const   )413,      (flex_int16_t const   )414,      (flex_int16_t const   )415, 
        (flex_int16_t const   )416,      (flex_int16_t const   )417,      (flex_int16_t const   )418,      (flex_int16_t const   )419, 
        (flex_int16_t const   )420,      (flex_int16_t const   )421,      (flex_int16_t const   )422,      (flex_int16_t const   )423, 
        (flex_int16_t const   )424,      (flex_int16_t const   )425,      (flex_int16_t const   )426,      (flex_int16_t const   )427, 
        (flex_int16_t const   )428,      (flex_int16_t const   )429,      (flex_int16_t const   )430,      (flex_int16_t const   )431, 
        (flex_int16_t const   )432,      (flex_int16_t const   )434,      (flex_int16_t const   )435,      (flex_int16_t const   )436, 
        (flex_int16_t const   )437,      (flex_int16_t const   )439,      (flex_int16_t const   )440,      (flex_int16_t const   )442, 
        (flex_int16_t const   )444,      (flex_int16_t const   )446,      (flex_int16_t const   )447,      (flex_int16_t const   )448, 
        (flex_int16_t const   )450,      (flex_int16_t const   )451,      (flex_int16_t const   )452,      (flex_int16_t const   )453, 
        (flex_int16_t const   )454,      (flex_int16_t const   )455,      (flex_int16_t const   )456,      (flex_int16_t const   )457, 
        (flex_int16_t const   )458,      (flex_int16_t const   )459,      (flex_int16_t const   )461,      (flex_int16_t const   )462, 
        (flex_int16_t const   )463,      (flex_int16_t const   )464,      (flex_int16_t const   )465,      (flex_int16_t const   )466, 
        (flex_int16_t const   )467,      (flex_int16_t const   )468,      (flex_int16_t const   )469,      (flex_int16_t const   )470, 
        (flex_int16_t const   )471,      (flex_int16_t const   )472,      (flex_int16_t const   )473,      (flex_int16_t const   )474, 
        (flex_int16_t const   )475,      (flex_int16_t const   )476,      (flex_int16_t const   )477,      (flex_int16_t const   )478, 
        (flex_int16_t const   )479,      (flex_int16_t const   )480,      (flex_int16_t const   )481,      (flex_int16_t const   )482, 
        (flex_int16_t const   )484,      (flex_int16_t const   )485,      (flex_int16_t const   )486,      (flex_int16_t const   )487, 
        (flex_int16_t const   )488,      (flex_int16_t const   )489,      (flex_int16_t const   )491,      (flex_int16_t const   )492, 
        (flex_int16_t const   )493,      (flex_int16_t const   )495,      (flex_int16_t const   )497,      (flex_int16_t const   )498, 
        (flex_int16_t const   )499,      (flex_int16_t const   )501,      (flex_int16_t const   )503,      (flex_int16_t const   )504, 
        (flex_int16_t const   )505,      (flex_int16_t const   )506,      (flex_int16_t const   )507,      (flex_int16_t const   )508, 
        (flex_int16_t const   )509,      (flex_int16_t const   )510,      (flex_int16_t const   )513,      (flex_int16_t const   )514, 
        (flex_int16_t const   )515,      (flex_int16_t const   )516,      (flex_int16_t const   )517,      (flex_int16_t const   )518, 
        (flex_int16_t const   )519,      (flex_int16_t const   )520,      (flex_int16_t const   )521,      (flex_int16_t const   )523, 
        (flex_int16_t const   )524,      (flex_int16_t const   )525,      (flex_int16_t const   )526,      (flex_int16_t const   )527, 
        (flex_int16_t const   )528,      (flex_int16_t const   )529,      (flex_int16_t const   )530,      (flex_int16_t const   )532, 
        (flex_int16_t const   )533,      (flex_int16_t const   )534,      (flex_int16_t const   )535,      (flex_int16_t const   )536, 
        (flex_int16_t const   )537,      (flex_int16_t const   )538,      (flex_int16_t const   )539,      (flex_int16_t const   )540, 
        (flex_int16_t const   )541,      (flex_int16_t const   )542,      (flex_int16_t const   )543,      (flex_int16_t const   )544, 
        (flex_int16_t const   )546,      (flex_int16_t const   )548,      (flex_int16_t const   )549,      (flex_int16_t const   )551, 
        (flex_int16_t const   )552,      (flex_int16_t const   )554,      (flex_int16_t const   )556,      (flex_int16_t const   )557, 
        (flex_int16_t const   )558,      (flex_int16_t const   )559,      (flex_int16_t const   )560,      (flex_int16_t const   )562, 
        (flex_int16_t const   )563,      (flex_int16_t const   )564,      (flex_int16_t const   )566,      (flex_int16_t const   )567, 
        (flex_int16_t const   )568,      (flex_int16_t const   )569,      (flex_int16_t const   )570,      (flex_int16_t const   )571, 
        (flex_int16_t const   )572,      (flex_int16_t const   )573,      (flex_int16_t const   )574,      (flex_int16_t const   )575, 
        (flex_int16_t const   )576,      (flex_int16_t const   )577,      (flex_int16_t const   )578,      (flex_int16_t const   )579, 
        (flex_int16_t const   )580,      (flex_int16_t const   )581,      (flex_int16_t const   )582,      (flex_int16_t const   )583, 
        (flex_int16_t const   )584,      (flex_int16_t const   )585,      (flex_int16_t const   )586,      (flex_int16_t const   )587, 
        (flex_int16_t const   )588,      (flex_int16_t const   )589,      (flex_int16_t const   )590,      (flex_int16_t const   )591, 
        (flex_int16_t const   )593,      (flex_int16_t const   )595,      (flex_int16_t const   )596,      (flex_int16_t const   )597, 
        (flex_int16_t const   )598,      (flex_int16_t const   )599,      (flex_int16_t const   )600,      (flex_int16_t const   )602, 
        (flex_int16_t const   )603,      (flex_int16_t const   )604,      (flex_int16_t const   )605,      (flex_int16_t const   )606, 
        (flex_int16_t const   )607,      (flex_int16_t const   )608,      (flex_int16_t const   )609,      (flex_int16_t const   )611, 
        (flex_int16_t const   )612,      (flex_int16_t const   )613,      (flex_int16_t const   )614,      (flex_int16_t const   )615, 
        (flex_int16_t const   )616,      (flex_int16_t const   )617,      (flex_int16_t const   )618,      (flex_int16_t const   )619, 
        (flex_int16_t const   )621,      (flex_int16_t const   )622,      (flex_int16_t const   )623,      (flex_int16_t const   )624, 
        (flex_int16_t const   )625,      (flex_int16_t const   )626,      (flex_int16_t const   )627,      (flex_int16_t const   )628, 
        (flex_int16_t const   )629,      (flex_int16_t const   )630,      (flex_int16_t const   )631,      (flex_int16_t const   )632, 
        (flex_int16_t const   )633,      (flex_int16_t const   )634,      (flex_int16_t const   )635,      (flex_int16_t const   )637, 
        (flex_int16_t const   )638,      (flex_int16_t const   )639,      (flex_int16_t const   )640,      (flex_int16_t const   )641, 
        (flex_int16_t const   )642,      (flex_int16_t const   )643,      (flex_int16_t const   )644,      (flex_int16_t const   )645, 
        (flex_int16_t const   )646,      (flex_int16_t const   )647,      (flex_int16_t const   )648,      (flex_int16_t const   )649, 
        (flex_int16_t const   )650,      (flex_int16_t const   )651,      (flex_int16_t const   )652,      (flex_int16_t const   )653, 
        (flex_int16_t const   )654,      (flex_int16_t const   )655,      (flex_int16_t const   )656,      (flex_int16_t const   )657, 
        (flex_int16_t const   )658,      (flex_int16_t const   )659,      (flex_int16_t const   )660,      (flex_int16_t const   )662, 
        (flex_int16_t const   )663,      (flex_int16_t const   )664,      (flex_int16_t const   )665,      (flex_int16_t const   )666, 
        (flex_int16_t const   )667,      (flex_int16_t const   )668,      (flex_int16_t const   )670,      (flex_int16_t const   )672, 
        (flex_int16_t const   )674,      (flex_int16_t const   )676,      (flex_int16_t const   )677,      (flex_int16_t const   )678, 
        (flex_int16_t const   )679,      (flex_int16_t const   )680,      (flex_int16_t const   )681,      (flex_int16_t const   )682, 
        (flex_int16_t const   )683,      (flex_int16_t const   )684,      (flex_int16_t const   )685,      (flex_int16_t const   )686, 
        (flex_int16_t const   )687,      (flex_int16_t const   )688,      (flex_int16_t const   )689,      (flex_int16_t const   )691, 
        (flex_int16_t const   )692,      (flex_int16_t const   )693,      (flex_int16_t const   )694,      (flex_int16_t const   )695, 
        (flex_int16_t const   )696,      (flex_int16_t const   )697,      (flex_int16_t const   )698,      (flex_int16_t const   )699, 
        (flex_int16_t const   )701,      (flex_int16_t const   )702,      (flex_int16_t const   )703,      (flex_int16_t const   )705, 
        (flex_int16_t const   )706,      (flex_int16_t const   )707,      (flex_int16_t const   )708,      (flex_int16_t const   )709, 
        (flex_int16_t const   )710,      (flex_int16_t const   )711,      (flex_int16_t const   )712,      (flex_int16_t const   )713, 
        (flex_int16_t const   )714,      (flex_int16_t const   )715,      (flex_int16_t const   )716,      (flex_int16_t const   )717, 
        (flex_int16_t const   )718,      (flex_int16_t const   )719,      (flex_int16_t const   )720,      (flex_int16_t const   )721, 
        (flex_int16_t const   )722,      (flex_int16_t const   )723,      (flex_int16_t const   )724,      (flex_int16_t const   )725, 
        (flex_int16_t const   )726,      (flex_int16_t const   )728,      (flex_int16_t const   )729,      (flex_int16_t const   )730, 
        (flex_int16_t const   )731,      (flex_int16_t const   )732,      (flex_int16_t const   )733,      (flex_int16_t const   )735, 
        (flex_int16_t const   )737,      (flex_int16_t const   )738,      (flex_int16_t const   )740,      (flex_int16_t const   )741, 
        (flex_int16_t const   )742,      (flex_int16_t const   )744,      (flex_int16_t const   )745,      (flex_int16_t const   )746, 
        (flex_int16_t const   )747,      (flex_int16_t const   )748,      (flex_int16_t const   )749,      (flex_int16_t const   )750, 
        (flex_int16_t const   )751,      (flex_int16_t const   )752,      (flex_int16_t const   )753,      (flex_int16_t const   )754, 
        (flex_int16_t const   )755,      (flex_int16_t const   )756,      (flex_int16_t const   )757,      (flex_int16_t const   )758, 
        (flex_int16_t const   )759,      (flex_int16_t const   )760,      (flex_int16_t const   )761,      (flex_int16_t const   )762, 
        (flex_int16_t const   )763,      (flex_int16_t const   )764,      (flex_int16_t const   )765,      (flex_int16_t const   )767, 
        (flex_int16_t const   )768,      (flex_int16_t const   )769,      (flex_int16_t const   )770,      (flex_int16_t const   )772, 
        (flex_int16_t const   )774,      (flex_int16_t const   )775,      (flex_int16_t const   )777,      (flex_int16_t const   )778, 
        (flex_int16_t const   )779,      (flex_int16_t const   )780,      (flex_int16_t const   )782,      (flex_int16_t const   )783, 
        (flex_int16_t const   )784,      (flex_int16_t const   )785,      (flex_int16_t const   )786,      (flex_int16_t const   )787, 
        (flex_int16_t const   )788,      (flex_int16_t const   )789,      (flex_int16_t const   )791,      (flex_int16_t const   )792, 
        (flex_int16_t const   )794,      (flex_int16_t const   )795,      (flex_int16_t const   )796,      (flex_int16_t const   )797, 
        (flex_int16_t const   )798,      (flex_int16_t const   )799,      (flex_int16_t const   )800,      (flex_int16_t const   )802, 
        (flex_int16_t const   )804,      (flex_int16_t const   )806,      (flex_int16_t const   )808,      (flex_int16_t const   )809, 
        (flex_int16_t const   )810,      (flex_int16_t const   )811,      (flex_int16_t const   )812,      (flex_int16_t const   )813, 
        (flex_int16_t const   )814,      (flex_int16_t const   )815,      (flex_int16_t const   )816,      (flex_int16_t const   )817, 
        (flex_int16_t const   )818,      (flex_int16_t const   )819,      (flex_int16_t const   )820,      (flex_int16_t const   )821, 
        (flex_int16_t const   )823,      (flex_int16_t const   )824,      (flex_int16_t const   )826,      (flex_int16_t const   )828, 
        (flex_int16_t const   )830,      (flex_int16_t const   )831,      (flex_int16_t const   )833,      (flex_int16_t const   )834, 
        (flex_int16_t const   )835,      (flex_int16_t const   )836,      (flex_int16_t const   )837,      (flex_int16_t const   )839, 
        (flex_int16_t const   )840,      (flex_int16_t const   )841,      (flex_int16_t const   )842,      (flex_int16_t const   )843, 
        (flex_int16_t const   )845,      (flex_int16_t const   )846,      (flex_int16_t const   )847,      (flex_int16_t const   )849, 
        (flex_int16_t const   )850,      (flex_int16_t const   )851,      (flex_int16_t const   )852,      (flex_int16_t const   )853, 
        (flex_int16_t const   )855,      (flex_int16_t const   )857,      (flex_int16_t const   )858,      (flex_int16_t const   )860, 
        (flex_int16_t const   )861,      (flex_int16_t const   )862,      (flex_int16_t const   )864,      (flex_int16_t const   )865, 
        (flex_int16_t const   )867,      (flex_int16_t const   )869,      (flex_int16_t const   )871,      (flex_int16_t const   )873, 
        (flex_int16_t const   )874,      (flex_int16_t const   )875,      (flex_int16_t const   )876,      (flex_int16_t const   )878, 
        (flex_int16_t const   )880,      (flex_int16_t const   )880};
#line 549 "bsdl_flex.c"
static flex_int32_t const   yy_ec___0[256]  = 
#line 549
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )2,      (flex_int32_t const   )2,      (flex_int32_t const   )3,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )2,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )2,      (flex_int32_t const   )4,      (flex_int32_t const   )5,      (flex_int32_t const   )1, 
        (flex_int32_t const   )6,      (flex_int32_t const   )1,      (flex_int32_t const   )5,      (flex_int32_t const   )5, 
        (flex_int32_t const   )7,      (flex_int32_t const   )8,      (flex_int32_t const   )9,      (flex_int32_t const   )10, 
        (flex_int32_t const   )11,      (flex_int32_t const   )12,      (flex_int32_t const   )13,      (flex_int32_t const   )1, 
        (flex_int32_t const   )14,      (flex_int32_t const   )15,      (flex_int32_t const   )16,      (flex_int32_t const   )17, 
        (flex_int32_t const   )18,      (flex_int32_t const   )19,      (flex_int32_t const   )20,      (flex_int32_t const   )20, 
        (flex_int32_t const   )20,      (flex_int32_t const   )21,      (flex_int32_t const   )22,      (flex_int32_t const   )5, 
        (flex_int32_t const   )23,      (flex_int32_t const   )24,      (flex_int32_t const   )25,      (flex_int32_t const   )26, 
        (flex_int32_t const   )1,      (flex_int32_t const   )27,      (flex_int32_t const   )28,      (flex_int32_t const   )29, 
        (flex_int32_t const   )30,      (flex_int32_t const   )31,      (flex_int32_t const   )32,      (flex_int32_t const   )33, 
        (flex_int32_t const   )34,      (flex_int32_t const   )35,      (flex_int32_t const   )36,      (flex_int32_t const   )37, 
        (flex_int32_t const   )38,      (flex_int32_t const   )39,      (flex_int32_t const   )40,      (flex_int32_t const   )41, 
        (flex_int32_t const   )42,      (flex_int32_t const   )36,      (flex_int32_t const   )43,      (flex_int32_t const   )44, 
        (flex_int32_t const   )45,      (flex_int32_t const   )46,      (flex_int32_t const   )47,      (flex_int32_t const   )48, 
        (flex_int32_t const   )49,      (flex_int32_t const   )50,      (flex_int32_t const   )51,      (flex_int32_t const   )52, 
        (flex_int32_t const   )1,      (flex_int32_t const   )53,      (flex_int32_t const   )1,      (flex_int32_t const   )54, 
        (flex_int32_t const   )1,      (flex_int32_t const   )55,      (flex_int32_t const   )56,      (flex_int32_t const   )57, 
        (flex_int32_t const   )58,      (flex_int32_t const   )59,      (flex_int32_t const   )60,      (flex_int32_t const   )61, 
        (flex_int32_t const   )62,      (flex_int32_t const   )63,      (flex_int32_t const   )36,      (flex_int32_t const   )64, 
        (flex_int32_t const   )65,      (flex_int32_t const   )66,      (flex_int32_t const   )67,      (flex_int32_t const   )68, 
        (flex_int32_t const   )69,      (flex_int32_t const   )36,      (flex_int32_t const   )70,      (flex_int32_t const   )71, 
        (flex_int32_t const   )72,      (flex_int32_t const   )73,      (flex_int32_t const   )74,      (flex_int32_t const   )75, 
        (flex_int32_t const   )76,      (flex_int32_t const   )77,      (flex_int32_t const   )78,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )79,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1};
#line 581 "bsdl_flex.c"
static flex_int32_t const   yy_meta___0[80]  = 
#line 581
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )2, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )3,      (flex_int32_t const   )3, 
        (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3, 
        (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )3, 
        (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3, 
        (flex_int32_t const   )3,      (flex_int32_t const   )4,      (flex_int32_t const   )4,      (flex_int32_t const   )4, 
        (flex_int32_t const   )4,      (flex_int32_t const   )4,      (flex_int32_t const   )4,      (flex_int32_t const   )4, 
        (flex_int32_t const   )4,      (flex_int32_t const   )4,      (flex_int32_t const   )4,      (flex_int32_t const   )4, 
        (flex_int32_t const   )4,      (flex_int32_t const   )4,      (flex_int32_t const   )4,      (flex_int32_t const   )4, 
        (flex_int32_t const   )4,      (flex_int32_t const   )4,      (flex_int32_t const   )4,      (flex_int32_t const   )4, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )4,      (flex_int32_t const   )3, 
        (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3, 
        (flex_int32_t const   )3,      (flex_int32_t const   )4,      (flex_int32_t const   )4,      (flex_int32_t const   )4, 
        (flex_int32_t const   )4,      (flex_int32_t const   )4,      (flex_int32_t const   )4,      (flex_int32_t const   )4, 
        (flex_int32_t const   )4,      (flex_int32_t const   )4,      (flex_int32_t const   )4,      (flex_int32_t const   )4, 
        (flex_int32_t const   )4,      (flex_int32_t const   )4,      (flex_int32_t const   )4,      (flex_int32_t const   )4, 
        (flex_int32_t const   )4,      (flex_int32_t const   )4,      (flex_int32_t const   )4,      (flex_int32_t const   )1};
#line 593 "bsdl_flex.c"
static flex_int16_t const   yy_base___0[712]  = 
#line 593
  {      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )52,      (flex_int16_t const   )0,      (flex_int16_t const   )103, 
        (flex_int16_t const   )0,      (flex_int16_t const   )55,      (flex_int16_t const   )100,      (flex_int16_t const   )173, 
        (flex_int16_t const   )0,      (flex_int16_t const   )691,      (flex_int16_t const   )1591,      (flex_int16_t const   )688, 
        (flex_int16_t const   )1591,      (flex_int16_t const   )1591,      (flex_int16_t const   )1591,      (flex_int16_t const   )1591, 
        (flex_int16_t const   )1591,      (flex_int16_t const   )1591,      (flex_int16_t const   )624,      (flex_int16_t const   )240, 
        (flex_int16_t const   )77,      (flex_int16_t const   )1591,      (flex_int16_t const   )303,      (flex_int16_t const   )350, 
        (flex_int16_t const   )45,      (flex_int16_t const   )0,      (flex_int16_t const   )207,      (flex_int16_t const   )108, 
        (flex_int16_t const   )51,      (flex_int16_t const   )50,      (flex_int16_t const   )70,      (flex_int16_t const   )73, 
        (flex_int16_t const   )91,      (flex_int16_t const   )1591,      (flex_int16_t const   )1591,      (flex_int16_t const   )89, 
        (flex_int16_t const   )110,      (flex_int16_t const   )236,      (flex_int16_t const   )105,      (flex_int16_t const   )167, 
        (flex_int16_t const   )147,      (flex_int16_t const   )127,      (flex_int16_t const   )0,      (flex_int16_t const   )234, 
        (flex_int16_t const   )241,      (flex_int16_t const   )242,      (flex_int16_t const   )236,      (flex_int16_t const   )159, 
        (flex_int16_t const   )285,      (flex_int16_t const   )341,      (flex_int16_t const   )282,      (flex_int16_t const   )236, 
        (flex_int16_t const   )136,      (flex_int16_t const   )166,      (flex_int16_t const   )1591,      (flex_int16_t const   )1591, 
        (flex_int16_t const   )1591,      (flex_int16_t const   )574,      (flex_int16_t const   )559,      (flex_int16_t const   )1591, 
        (flex_int16_t const   )541,      (flex_int16_t const   )545,      (flex_int16_t const   )304,      (flex_int16_t const   )347, 
        (flex_int16_t const   )345,      (flex_int16_t const   )384,      (flex_int16_t const   )165,      (flex_int16_t const   )398, 
        (flex_int16_t const   )351,      (flex_int16_t const   )395,      (flex_int16_t const   )395,      (flex_int16_t const   )404, 
        (flex_int16_t const   )405,      (flex_int16_t const   )399,      (flex_int16_t const   )176,      (flex_int16_t const   )1591, 
        (flex_int16_t const   )511,      (flex_int16_t const   )0,      (flex_int16_t const   )463,      (flex_int16_t const   )0, 
        (flex_int16_t const   )278,      (flex_int16_t const   )0,      (flex_int16_t const   )324,      (flex_int16_t const   )194, 
        (flex_int16_t const   )0,      (flex_int16_t const   )241,      (flex_int16_t const   )405,      (flex_int16_t const   )370, 
        (flex_int16_t const   )282,      (flex_int16_t const   )390,      (flex_int16_t const   )339,      (flex_int16_t const   )400, 
        (flex_int16_t const   )401,      (flex_int16_t const   )416,      (flex_int16_t const   )406,      (flex_int16_t const   )438, 
        (flex_int16_t const   )471,      (flex_int16_t const   )443,      (flex_int16_t const   )446,      (flex_int16_t const   )449, 
        (flex_int16_t const   )450,      (flex_int16_t const   )459,      (flex_int16_t const   )452,      (flex_int16_t const   )453, 
        (flex_int16_t const   )461,      (flex_int16_t const   )473,      (flex_int16_t const   )456,      (flex_int16_t const   )461, 
        (flex_int16_t const   )477,      (flex_int16_t const   )465,      (flex_int16_t const   )462,      (flex_int16_t const   )475, 
        (flex_int16_t const   )480,      (flex_int16_t const   )496,      (flex_int16_t const   )479,      (flex_int16_t const   )477, 
        (flex_int16_t const   )485,      (flex_int16_t const   )496,      (flex_int16_t const   )501,      (flex_int16_t const   )1591, 
        (flex_int16_t const   )1591,      (flex_int16_t const   )1591,      (flex_int16_t const   )492,      (flex_int16_t const   )513, 
        (flex_int16_t const   )508,      (flex_int16_t const   )503,      (flex_int16_t const   )513,      (flex_int16_t const   )505, 
        (flex_int16_t const   )501,      (flex_int16_t const   )512,      (flex_int16_t const   )509,      (flex_int16_t const   )511, 
        (flex_int16_t const   )533,      (flex_int16_t const   )536,      (flex_int16_t const   )531,      (flex_int16_t const   )520, 
        (flex_int16_t const   )533,      (flex_int16_t const   )526,      (flex_int16_t const   )0,      (flex_int16_t const   )592, 
        (flex_int16_t const   )547,      (flex_int16_t const   )549,      (flex_int16_t const   )550,      (flex_int16_t const   )554, 
        (flex_int16_t const   )553,      (flex_int16_t const   )457,      (flex_int16_t const   )555,      (flex_int16_t const   )451, 
        (flex_int16_t const   )561,      (flex_int16_t const   )439,      (flex_int16_t const   )437,      (flex_int16_t const   )557, 
        (flex_int16_t const   )568,      (flex_int16_t const   )575,      (flex_int16_t const   )571,      (flex_int16_t const   )571, 
        (flex_int16_t const   )588,      (flex_int16_t const   )586,      (flex_int16_t const   )589,      (flex_int16_t const   )587, 
        (flex_int16_t const   )592,      (flex_int16_t const   )596,      (flex_int16_t const   )594,      (flex_int16_t const   )608, 
        (flex_int16_t const   )598,      (flex_int16_t const   )603,      (flex_int16_t const   )608,      (flex_int16_t const   )606, 
        (flex_int16_t const   )604,      (flex_int16_t const   )610,      (flex_int16_t const   )608,      (flex_int16_t const   )621, 
        (flex_int16_t const   )610,      (flex_int16_t const   )610,      (flex_int16_t const   )615,      (flex_int16_t const   )627, 
        (flex_int16_t const   )0,      (flex_int16_t const   )613,      (flex_int16_t const   )621,      (flex_int16_t const   )617, 
        (flex_int16_t const   )623,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )635, 
        (flex_int16_t const   )0,      (flex_int16_t const   )636,      (flex_int16_t const   )633,      (flex_int16_t const   )635, 
        (flex_int16_t const   )640,      (flex_int16_t const   )635,      (flex_int16_t const   )644,      (flex_int16_t const   )641, 
        (flex_int16_t const   )642,      (flex_int16_t const   )703,      (flex_int16_t const   )658,      (flex_int16_t const   )666, 
        (flex_int16_t const   )655,      (flex_int16_t const   )667,      (flex_int16_t const   )662,      (flex_int16_t const   )708, 
        (flex_int16_t const   )691,      (flex_int16_t const   )667,      (flex_int16_t const   )668,      (flex_int16_t const   )441, 
        (flex_int16_t const   )684,      (flex_int16_t const   )700,      (flex_int16_t const   )699,      (flex_int16_t const   )708, 
        (flex_int16_t const   )703,      (flex_int16_t const   )702,      (flex_int16_t const   )705,      (flex_int16_t const   )699, 
        (flex_int16_t const   )706,      (flex_int16_t const   )705,      (flex_int16_t const   )84,      (flex_int16_t const   )87, 
        (flex_int16_t const   )723,      (flex_int16_t const   )712,      (flex_int16_t const   )717,      (flex_int16_t const   )731, 
        (flex_int16_t const   )718,      (flex_int16_t const   )716,      (flex_int16_t const   )740,      (flex_int16_t const   )736, 
        (flex_int16_t const   )741,      (flex_int16_t const   )749,      (flex_int16_t const   )749,      (flex_int16_t const   )756, 
        (flex_int16_t const   )747,      (flex_int16_t const   )741,      (flex_int16_t const   )398,      (flex_int16_t const   )761, 
        (flex_int16_t const   )758,      (flex_int16_t const   )0,      (flex_int16_t const   )754,      (flex_int16_t const   )755, 
        (flex_int16_t const   )754,      (flex_int16_t const   )760,      (flex_int16_t const   )773,      (flex_int16_t const   )759, 
        (flex_int16_t const   )768,      (flex_int16_t const   )764,      (flex_int16_t const   )0,      (flex_int16_t const   )819, 
        (flex_int16_t const   )827,      (flex_int16_t const   )798,      (flex_int16_t const   )792,      (flex_int16_t const   )790, 
        (flex_int16_t const   )822,      (flex_int16_t const   )819,      (flex_int16_t const   )806,      (flex_int16_t const   )825, 
        (flex_int16_t const   )818,      (flex_int16_t const   )817,      (flex_int16_t const   )824,      (flex_int16_t const   )825, 
        (flex_int16_t const   )824,      (flex_int16_t const   )829,      (flex_int16_t const   )835,      (flex_int16_t const   )836, 
        (flex_int16_t const   )840,      (flex_int16_t const   )824,      (flex_int16_t const   )135,      (flex_int16_t const   )841, 
        (flex_int16_t const   )832,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )833, 
        (flex_int16_t const   )0,      (flex_int16_t const   )835,      (flex_int16_t const   )833,      (flex_int16_t const   )834, 
        (flex_int16_t const   )839,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )859,      (flex_int16_t const   )847,      (flex_int16_t const   )0, 
        (flex_int16_t const   )866,      (flex_int16_t const   )859,      (flex_int16_t const   )0,      (flex_int16_t const   )874, 
        (flex_int16_t const   )864,      (flex_int16_t const   )879,      (flex_int16_t const   )866,      (flex_int16_t const   )881, 
        (flex_int16_t const   )874,      (flex_int16_t const   )383,      (flex_int16_t const   )0,      (flex_int16_t const   )875, 
        (flex_int16_t const   )878,      (flex_int16_t const   )886,      (flex_int16_t const   )879,      (flex_int16_t const   )893, 
        (flex_int16_t const   )886,      (flex_int16_t const   )884,      (flex_int16_t const   )879,      (flex_int16_t const   )891, 
        (flex_int16_t const   )888,      (flex_int16_t const   )900,      (flex_int16_t const   )889,      (flex_int16_t const   )903, 
        (flex_int16_t const   )904,      (flex_int16_t const   )898,      (flex_int16_t const   )348,      (flex_int16_t const   )910, 
        (flex_int16_t const   )900,      (flex_int16_t const   )920,      (flex_int16_t const   )912,      (flex_int16_t const   )909, 
        (flex_int16_t const   )907,      (flex_int16_t const   )919,      (flex_int16_t const   )923,      (flex_int16_t const   )922, 
        (flex_int16_t const   )923,      (flex_int16_t const   )937,      (flex_int16_t const   )941,      (flex_int16_t const   )942, 
        (flex_int16_t const   )929,      (flex_int16_t const   )942,      (flex_int16_t const   )383,      (flex_int16_t const   )381, 
        (flex_int16_t const   )947,      (flex_int16_t const   )946,      (flex_int16_t const   )940,      (flex_int16_t const   )954, 
        (flex_int16_t const   )0,      (flex_int16_t const   )951,      (flex_int16_t const   )171,      (flex_int16_t const   )941, 
        (flex_int16_t const   )0,      (flex_int16_t const   )343,      (flex_int16_t const   )0,      (flex_int16_t const   )342, 
        (flex_int16_t const   )0,      (flex_int16_t const   )955,      (flex_int16_t const   )945,      (flex_int16_t const   )0, 
        (flex_int16_t const   )956,      (flex_int16_t const   )958,      (flex_int16_t const   )952,      (flex_int16_t const   )964, 
        (flex_int16_t const   )962,      (flex_int16_t const   )976,      (flex_int16_t const   )976,      (flex_int16_t const   )976, 
        (flex_int16_t const   )977,      (flex_int16_t const   )0,      (flex_int16_t const   )967,      (flex_int16_t const   )988, 
        (flex_int16_t const   )985,      (flex_int16_t const   )968,      (flex_int16_t const   )980,      (flex_int16_t const   )982, 
        (flex_int16_t const   )979,      (flex_int16_t const   )982,      (flex_int16_t const   )983,      (flex_int16_t const   )994, 
        (flex_int16_t const   )992,      (flex_int16_t const   )998,      (flex_int16_t const   )1006,      (flex_int16_t const   )1006, 
        (flex_int16_t const   )992,      (flex_int16_t const   )1007,      (flex_int16_t const   )338,      (flex_int16_t const   )1012, 
        (flex_int16_t const   )1000,      (flex_int16_t const   )1003,      (flex_int16_t const   )1012,      (flex_int16_t const   )333, 
        (flex_int16_t const   )1010,      (flex_int16_t const   )362,      (flex_int16_t const   )341,      (flex_int16_t const   )1014, 
        (flex_int16_t const   )1011,      (flex_int16_t const   )1013,      (flex_int16_t const   )1022,      (flex_int16_t const   )297, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )1012,      (flex_int16_t const   )1028, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )1033,      (flex_int16_t const   )1028, 
        (flex_int16_t const   )1025,      (flex_int16_t const   )296,      (flex_int16_t const   )1032,      (flex_int16_t const   )1039, 
        (flex_int16_t const   )1038,      (flex_int16_t const   )0,      (flex_int16_t const   )1033,      (flex_int16_t const   )1039, 
        (flex_int16_t const   )1032,      (flex_int16_t const   )1039,      (flex_int16_t const   )1041,      (flex_int16_t const   )295, 
        (flex_int16_t const   )1057,      (flex_int16_t const   )1043,      (flex_int16_t const   )0,      (flex_int16_t const   )1059, 
        (flex_int16_t const   )1058,      (flex_int16_t const   )1055,      (flex_int16_t const   )1060,      (flex_int16_t const   )1059, 
        (flex_int16_t const   )1066,      (flex_int16_t const   )1071,      (flex_int16_t const   )0,      (flex_int16_t const   )1071, 
        (flex_int16_t const   )1079,      (flex_int16_t const   )1077,      (flex_int16_t const   )1067,      (flex_int16_t const   )1067, 
        (flex_int16_t const   )294,      (flex_int16_t const   )1072,      (flex_int16_t const   )292,      (flex_int16_t const   )290, 
        (flex_int16_t const   )288,      (flex_int16_t const   )286,      (flex_int16_t const   )283,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )1076,      (flex_int16_t const   )282,      (flex_int16_t const   )1089, 
        (flex_int16_t const   )251,      (flex_int16_t const   )0,      (flex_int16_t const   )1080,      (flex_int16_t const   )1089, 
        (flex_int16_t const   )1081,      (flex_int16_t const   )1077,      (flex_int16_t const   )0,      (flex_int16_t const   )1103, 
        (flex_int16_t const   )1101,      (flex_int16_t const   )0,      (flex_int16_t const   )1102,      (flex_int16_t const   )1094, 
        (flex_int16_t const   )1103,      (flex_int16_t const   )1103,      (flex_int16_t const   )236,      (flex_int16_t const   )1106, 
        (flex_int16_t const   )1101,      (flex_int16_t const   )1105,      (flex_int16_t const   )234,      (flex_int16_t const   )1106, 
        (flex_int16_t const   )1112,      (flex_int16_t const   )232,      (flex_int16_t const   )1124,      (flex_int16_t const   )1123, 
        (flex_int16_t const   )1126,      (flex_int16_t const   )1122,      (flex_int16_t const   )1116,      (flex_int16_t const   )1121, 
        (flex_int16_t const   )1119,      (flex_int16_t const   )1139,      (flex_int16_t const   )249,      (flex_int16_t const   )234, 
        (flex_int16_t const   )1154,      (flex_int16_t const   )1128,      (flex_int16_t const   )1134,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )1132,      (flex_int16_t const   )1147,      (flex_int16_t const   )1149, 
        (flex_int16_t const   )1143,      (flex_int16_t const   )1150,      (flex_int16_t const   )0,      (flex_int16_t const   )1157, 
        (flex_int16_t const   )1168,      (flex_int16_t const   )1169,      (flex_int16_t const   )195,      (flex_int16_t const   )1174, 
        (flex_int16_t const   )1169,      (flex_int16_t const   )1152,      (flex_int16_t const   )0,      (flex_int16_t const   )1150, 
        (flex_int16_t const   )1168,      (flex_int16_t const   )1174,      (flex_int16_t const   )1166,      (flex_int16_t const   )1174, 
        (flex_int16_t const   )1180,      (flex_int16_t const   )1172,      (flex_int16_t const   )1176,      (flex_int16_t const   )0, 
        (flex_int16_t const   )1180,      (flex_int16_t const   )1182,      (flex_int16_t const   )1197,      (flex_int16_t const   )180, 
        (flex_int16_t const   )213,      (flex_int16_t const   )1191,      (flex_int16_t const   )1190,      (flex_int16_t const   )1194, 
        (flex_int16_t const   )1190,      (flex_int16_t const   )1207,      (flex_int16_t const   )1209,      (flex_int16_t const   )1206, 
        (flex_int16_t const   )1203,      (flex_int16_t const   )1211,      (flex_int16_t const   )0,      (flex_int16_t const   )1197, 
        (flex_int16_t const   )1219,      (flex_int16_t const   )1220,      (flex_int16_t const   )1213,      (flex_int16_t const   )1218, 
        (flex_int16_t const   )1213,      (flex_int16_t const   )1217,      (flex_int16_t const   )1215,      (flex_int16_t const   )172, 
        (flex_int16_t const   )1216,      (flex_int16_t const   )1234,      (flex_int16_t const   )171,      (flex_int16_t const   )1214, 
        (flex_int16_t const   )170,      (flex_int16_t const   )1238,      (flex_int16_t const   )1224,      (flex_int16_t const   )1220, 
        (flex_int16_t const   )1232,      (flex_int16_t const   )1240,      (flex_int16_t const   )1247,      (flex_int16_t const   )174, 
        (flex_int16_t const   )191,      (flex_int16_t const   )1240,      (flex_int16_t const   )0,      (flex_int16_t const   )1253, 
        (flex_int16_t const   )1243,      (flex_int16_t const   )1246,      (flex_int16_t const   )1251,      (flex_int16_t const   )1242, 
        (flex_int16_t const   )1254,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )1263,      (flex_int16_t const   )1263,      (flex_int16_t const   )1273, 
        (flex_int16_t const   )1262,      (flex_int16_t const   )1260,      (flex_int16_t const   )1304,      (flex_int16_t const   )1276, 
        (flex_int16_t const   )1269,      (flex_int16_t const   )1307,      (flex_int16_t const   )1269,      (flex_int16_t const   )1289, 
        (flex_int16_t const   )1267,      (flex_int16_t const   )1292,      (flex_int16_t const   )0,      (flex_int16_t const   )130, 
        (flex_int16_t const   )1276,      (flex_int16_t const   )1294,      (flex_int16_t const   )148,      (flex_int16_t const   )141, 
        (flex_int16_t const   )176,      (flex_int16_t const   )1298,      (flex_int16_t const   )1299,      (flex_int16_t const   )0, 
        (flex_int16_t const   )1300,      (flex_int16_t const   )1304,      (flex_int16_t const   )0,      (flex_int16_t const   )1304, 
        (flex_int16_t const   )1307,      (flex_int16_t const   )1310,      (flex_int16_t const   )1311,      (flex_int16_t const   )1325, 
        (flex_int16_t const   )1329,      (flex_int16_t const   )1336,      (flex_int16_t const   )1329,      (flex_int16_t const   )1322, 
        (flex_int16_t const   )1339,      (flex_int16_t const   )1333,      (flex_int16_t const   )1335,      (flex_int16_t const   )1337, 
        (flex_int16_t const   )1353,      (flex_int16_t const   )1341,      (flex_int16_t const   )1355,      (flex_int16_t const   )1346, 
        (flex_int16_t const   )1356,      (flex_int16_t const   )1345,      (flex_int16_t const   )1344,      (flex_int16_t const   )1359, 
        (flex_int16_t const   )0,      (flex_int16_t const   )1357,      (flex_int16_t const   )1364,      (flex_int16_t const   )1355, 
        (flex_int16_t const   )118,      (flex_int16_t const   )105,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )1363,      (flex_int16_t const   )0,      (flex_int16_t const   )1356,      (flex_int16_t const   )1359, 
        (flex_int16_t const   )0,      (flex_int16_t const   )1370,      (flex_int16_t const   )1361,      (flex_int16_t const   )1363, 
        (flex_int16_t const   )1368,      (flex_int16_t const   )1369,      (flex_int16_t const   )1371,      (flex_int16_t const   )1374, 
        (flex_int16_t const   )1392,      (flex_int16_t const   )1381,      (flex_int16_t const   )1395,      (flex_int16_t const   )1394, 
        (flex_int16_t const   )1402,      (flex_int16_t const   )1403,      (flex_int16_t const   )1410,      (flex_int16_t const   )1391, 
        (flex_int16_t const   )1401,      (flex_int16_t const   )1411,      (flex_int16_t const   )1412,      (flex_int16_t const   )1409, 
        (flex_int16_t const   )1405,      (flex_int16_t const   )1422,      (flex_int16_t const   )0,      (flex_int16_t const   )1407, 
        (flex_int16_t const   )71,      (flex_int16_t const   )99,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )1408,      (flex_int16_t const   )0,      (flex_int16_t const   )1423,      (flex_int16_t const   )1424, 
        (flex_int16_t const   )1415,      (flex_int16_t const   )0,      (flex_int16_t const   )1415,      (flex_int16_t const   )1429, 
        (flex_int16_t const   )1418,      (flex_int16_t const   )1430,      (flex_int16_t const   )1426,      (flex_int16_t const   )1423, 
        (flex_int16_t const   )1433,      (flex_int16_t const   )0,      (flex_int16_t const   )1431,      (flex_int16_t const   )0, 
        (flex_int16_t const   )1431,      (flex_int16_t const   )1446,      (flex_int16_t const   )1440,      (flex_int16_t const   )1436, 
        (flex_int16_t const   )1443,      (flex_int16_t const   )1447,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )1459,      (flex_int16_t const   )1450, 
        (flex_int16_t const   )1452,      (flex_int16_t const   )1457,      (flex_int16_t const   )1452,      (flex_int16_t const   )1471, 
        (flex_int16_t const   )1470,      (flex_int16_t const   )1458,      (flex_int16_t const   )1475,      (flex_int16_t const   )1480, 
        (flex_int16_t const   )1479,      (flex_int16_t const   )1479,      (flex_int16_t const   )1469,      (flex_int16_t const   )0, 
        (flex_int16_t const   )53,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )1471,      (flex_int16_t const   )0,      (flex_int16_t const   )1475,      (flex_int16_t const   )1490, 
        (flex_int16_t const   )1476,      (flex_int16_t const   )1483,      (flex_int16_t const   )0,      (flex_int16_t const   )1490, 
        (flex_int16_t const   )1495,      (flex_int16_t const   )1484,      (flex_int16_t const   )1500,      (flex_int16_t const   )0, 
        (flex_int16_t const   )1505,      (flex_int16_t const   )1492,      (flex_int16_t const   )0,      (flex_int16_t const   )1492, 
        (flex_int16_t const   )1500,      (flex_int16_t const   )1512,      (flex_int16_t const   )1513,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )1516,      (flex_int16_t const   )0,      (flex_int16_t const   )1510, 
        (flex_int16_t const   )1515,      (flex_int16_t const   )0,      (flex_int16_t const   )1522,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )1513, 
        (flex_int16_t const   )1524,      (flex_int16_t const   )1513,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )1591,      (flex_int16_t const   )1582,      (flex_int16_t const   )1586,      (flex_int16_t const   )101};
#line 676 "bsdl_flex.c"
static flex_int16_t const   yy_def___0[712]  = 
#line 676
  {      (flex_int16_t const   )0,      (flex_int16_t const   )708,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )5,      (flex_int16_t const   )1, 
        (flex_int16_t const   )7,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )7, 
        (flex_int16_t const   )11,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )23,      (flex_int16_t const   )708,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )27,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )27, 
        (flex_int16_t const   )27,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )27, 
        (flex_int16_t const   )27,      (flex_int16_t const   )27,      (flex_int16_t const   )27,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )27,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )27,      (flex_int16_t const   )27, 
        (flex_int16_t const   )27,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )710,      (flex_int16_t const   )708,      (flex_int16_t const   )23, 
        (flex_int16_t const   )23,      (flex_int16_t const   )711,      (flex_int16_t const   )708,      (flex_int16_t const   )27, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )27,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )710,      (flex_int16_t const   )708, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )708,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )0,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708};
#line 759 "bsdl_flex.c"
static flex_int16_t const   yy_nxt___0[1671]  = 
#line 759
  {      (flex_int16_t const   )0,      (flex_int16_t const   )14,      (flex_int16_t const   )15,      (flex_int16_t const   )16, 
        (flex_int16_t const   )17,      (flex_int16_t const   )17,      (flex_int16_t const   )17,      (flex_int16_t const   )18, 
        (flex_int16_t const   )19,      (flex_int16_t const   )20,      (flex_int16_t const   )17,      (flex_int16_t const   )21, 
        (flex_int16_t const   )22,      (flex_int16_t const   )17,      (flex_int16_t const   )23,      (flex_int16_t const   )23, 
        (flex_int16_t const   )24,      (flex_int16_t const   )24,      (flex_int16_t const   )24,      (flex_int16_t const   )24, 
        (flex_int16_t const   )24,      (flex_int16_t const   )24,      (flex_int16_t const   )25,      (flex_int16_t const   )17, 
        (flex_int16_t const   )17,      (flex_int16_t const   )17,      (flex_int16_t const   )17,      (flex_int16_t const   )26, 
        (flex_int16_t const   )27,      (flex_int16_t const   )28,      (flex_int16_t const   )26,      (flex_int16_t const   )26, 
        (flex_int16_t const   )26,      (flex_int16_t const   )29,      (flex_int16_t const   )29,      (flex_int16_t const   )30, 
        (flex_int16_t const   )29,      (flex_int16_t const   )29,      (flex_int16_t const   )29,      (flex_int16_t const   )29, 
        (flex_int16_t const   )29,      (flex_int16_t const   )29,      (flex_int16_t const   )31,      (flex_int16_t const   )32, 
        (flex_int16_t const   )33,      (flex_int16_t const   )34,      (flex_int16_t const   )35,      (flex_int16_t const   )29, 
        (flex_int16_t const   )29,      (flex_int16_t const   )36,      (flex_int16_t const   )29,      (flex_int16_t const   )29, 
        (flex_int16_t const   )37,      (flex_int16_t const   )38,      (flex_int16_t const   )17,      (flex_int16_t const   )26, 
        (flex_int16_t const   )27,      (flex_int16_t const   )28,      (flex_int16_t const   )26,      (flex_int16_t const   )26, 
        (flex_int16_t const   )26,      (flex_int16_t const   )29,      (flex_int16_t const   )29,      (flex_int16_t const   )30, 
        (flex_int16_t const   )29,      (flex_int16_t const   )29,      (flex_int16_t const   )29,      (flex_int16_t const   )29, 
        (flex_int16_t const   )29,      (flex_int16_t const   )31,      (flex_int16_t const   )32,      (flex_int16_t const   )33, 
        (flex_int16_t const   )34,      (flex_int16_t const   )35,      (flex_int16_t const   )29,      (flex_int16_t const   )29, 
        (flex_int16_t const   )36,      (flex_int16_t const   )29,      (flex_int16_t const   )29,      (flex_int16_t const   )17, 
        (flex_int16_t const   )39,      (flex_int16_t const   )40,      (flex_int16_t const   )96,      (flex_int16_t const   )57, 
        (flex_int16_t const   )40,      (flex_int16_t const   )651,      (flex_int16_t const   )90,      (flex_int16_t const   )41, 
        (flex_int16_t const   )652,      (flex_int16_t const   )42,      (flex_int16_t const   )41,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )43,      (flex_int16_t const   )44,      (flex_int16_t const   )97, 
        (flex_int16_t const   )43,      (flex_int16_t const   )98,      (flex_int16_t const   )277,      (flex_int16_t const   )278, 
        (flex_int16_t const   )45,      (flex_int16_t const   )279,      (flex_int16_t const   )280,      (flex_int16_t const   )46, 
        (flex_int16_t const   )85,      (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )685, 
        (flex_int16_t const   )39,      (flex_int16_t const   )40,      (flex_int16_t const   )96,      (flex_int16_t const   )57, 
        (flex_int16_t const   )40,      (flex_int16_t const   )90,      (flex_int16_t const   )653,      (flex_int16_t const   )41, 
        (flex_int16_t const   )42,      (flex_int16_t const   )99,      (flex_int16_t const   )41,      (flex_int16_t const   )625, 
        (flex_int16_t const   )43,      (flex_int16_t const   )44,      (flex_int16_t const   )97,      (flex_int16_t const   )43, 
        (flex_int16_t const   )101,      (flex_int16_t const   )98,      (flex_int16_t const   )708,      (flex_int16_t const   )45, 
        (flex_int16_t const   )57,      (flex_int16_t const   )40,      (flex_int16_t const   )46,      (flex_int16_t const   )47, 
        (flex_int16_t const   )48,      (flex_int16_t const   )49,      (flex_int16_t const   )50,      (flex_int16_t const   )41, 
        (flex_int16_t const   )105,      (flex_int16_t const   )51,      (flex_int16_t const   )52,      (flex_int16_t const   )624, 
        (flex_int16_t const   )100,      (flex_int16_t const   )43,      (flex_int16_t const   )94,      (flex_int16_t const   )95, 
        (flex_int16_t const   )99,      (flex_int16_t const   )53,      (flex_int16_t const   )54,      (flex_int16_t const   )55, 
        (flex_int16_t const   )102,      (flex_int16_t const   )56,      (flex_int16_t const   )326,      (flex_int16_t const   )103, 
        (flex_int16_t const   )101,      (flex_int16_t const   )708,      (flex_int16_t const   )327,      (flex_int16_t const   )593, 
        (flex_int16_t const   )57,      (flex_int16_t const   )40,      (flex_int16_t const   )109,      (flex_int16_t const   )47, 
        (flex_int16_t const   )48,      (flex_int16_t const   )49,      (flex_int16_t const   )50,      (flex_int16_t const   )41, 
        (flex_int16_t const   )105,      (flex_int16_t const   )51,      (flex_int16_t const   )52,      (flex_int16_t const   )100, 
        (flex_int16_t const   )43,      (flex_int16_t const   )592,      (flex_int16_t const   )94,      (flex_int16_t const   )95, 
        (flex_int16_t const   )53,      (flex_int16_t const   )54,      (flex_int16_t const   )55,      (flex_int16_t const   )102, 
        (flex_int16_t const   )56,      (flex_int16_t const   )58,      (flex_int16_t const   )103,      (flex_int16_t const   )59, 
        (flex_int16_t const   )121,      (flex_int16_t const   )94,      (flex_int16_t const   )95,      (flex_int16_t const   )60, 
        (flex_int16_t const   )589,      (flex_int16_t const   )61,      (flex_int16_t const   )109,      (flex_int16_t const   )384, 
        (flex_int16_t const   )385,      (flex_int16_t const   )558,      (flex_int16_t const   )559,      (flex_int16_t const   )594, 
        (flex_int16_t const   )595,      (flex_int16_t const   )108,      (flex_int16_t const   )115,      (flex_int16_t const   )106, 
        (flex_int16_t const   )62,      (flex_int16_t const   )63,      (flex_int16_t const   )64,      (flex_int16_t const   )65, 
        (flex_int16_t const   )66,      (flex_int16_t const   )122,      (flex_int16_t const   )67,      (flex_int16_t const   )141, 
        (flex_int16_t const   )68,      (flex_int16_t const   )560,      (flex_int16_t const   )131,      (flex_int16_t const   )121, 
        (flex_int16_t const   )69,      (flex_int16_t const   )94,      (flex_int16_t const   )95,      (flex_int16_t const   )70, 
        (flex_int16_t const   )71,      (flex_int16_t const   )107,      (flex_int16_t const   )72,      (flex_int16_t const   )73, 
        (flex_int16_t const   )74,      (flex_int16_t const   )75,      (flex_int16_t const   )76,      (flex_int16_t const   )77, 
        (flex_int16_t const   )108,      (flex_int16_t const   )78,      (flex_int16_t const   )115,      (flex_int16_t const   )106, 
        (flex_int16_t const   )551,      (flex_int16_t const   )549,      (flex_int16_t const   )546,      (flex_int16_t const   )528, 
        (flex_int16_t const   )66,      (flex_int16_t const   )122,      (flex_int16_t const   )67,      (flex_int16_t const   )141, 
        (flex_int16_t const   )68,      (flex_int16_t const   )131,      (flex_int16_t const   )527,      (flex_int16_t const   )88, 
        (flex_int16_t const   )69,      (flex_int16_t const   )91,      (flex_int16_t const   )70,      (flex_int16_t const   )71, 
        (flex_int16_t const   )107,      (flex_int16_t const   )72,      (flex_int16_t const   )73,      (flex_int16_t const   )74, 
        (flex_int16_t const   )75,      (flex_int16_t const   )76,      (flex_int16_t const   )77,      (flex_int16_t const   )92, 
        (flex_int16_t const   )78,      (flex_int16_t const   )512,      (flex_int16_t const   )496,      (flex_int16_t const   )93, 
        (flex_int16_t const   )79,      (flex_int16_t const   )82,      (flex_int16_t const   )83,      (flex_int16_t const   )83, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )88,      (flex_int16_t const   )120, 
        (flex_int16_t const   )495,      (flex_int16_t const   )91,      (flex_int16_t const   )91,      (flex_int16_t const   )85, 
        (flex_int16_t const   )85,      (flex_int16_t const   )85,      (flex_int16_t const   )85,      (flex_int16_t const   )85, 
        (flex_int16_t const   )85,      (flex_int16_t const   )113,      (flex_int16_t const   )92,      (flex_int16_t const   )110, 
        (flex_int16_t const   )104,      (flex_int16_t const   )88,      (flex_int16_t const   )93,      (flex_int16_t const   )112, 
        (flex_int16_t const   )93,      (flex_int16_t const   )97,      (flex_int16_t const   )90,      (flex_int16_t const   )88, 
        (flex_int16_t const   )111,      (flex_int16_t const   )114,      (flex_int16_t const   )486,      (flex_int16_t const   )144, 
        (flex_int16_t const   )483,      (flex_int16_t const   )86,      (flex_int16_t const   )479,      (flex_int16_t const   )120, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )91,      (flex_int16_t const   )85, 
        (flex_int16_t const   )85,      (flex_int16_t const   )85,      (flex_int16_t const   )85,      (flex_int16_t const   )85, 
        (flex_int16_t const   )85,      (flex_int16_t const   )113,      (flex_int16_t const   )110,      (flex_int16_t const   )104, 
        (flex_int16_t const   )88,      (flex_int16_t const   )465,      (flex_int16_t const   )112,      (flex_int16_t const   )93, 
        (flex_int16_t const   )97,      (flex_int16_t const   )90,      (flex_int16_t const   )88,      (flex_int16_t const   )111, 
        (flex_int16_t const   )114,      (flex_int16_t const   )96,      (flex_int16_t const   )144,      (flex_int16_t const   )116, 
        (flex_int16_t const   )86,      (flex_int16_t const   )87,      (flex_int16_t const   )87,      (flex_int16_t const   )87, 
        (flex_int16_t const   )87,      (flex_int16_t const   )87,      (flex_int16_t const   )87,      (flex_int16_t const   )87, 
        (flex_int16_t const   )87,      (flex_int16_t const   )117,      (flex_int16_t const   )148,      (flex_int16_t const   )708, 
        (flex_int16_t const   )119,      (flex_int16_t const   )93,      (flex_int16_t const   )87,      (flex_int16_t const   )87, 
        (flex_int16_t const   )87,      (flex_int16_t const   )87,      (flex_int16_t const   )87,      (flex_int16_t const   )87, 
        (flex_int16_t const   )444,      (flex_int16_t const   )465,      (flex_int16_t const   )86,      (flex_int16_t const   )86, 
        (flex_int16_t const   )464,      (flex_int16_t const   )96,      (flex_int16_t const   )463,      (flex_int16_t const   )116, 
        (flex_int16_t const   )462,      (flex_int16_t const   )88,      (flex_int16_t const   )461,      (flex_int16_t const   )126, 
        (flex_int16_t const   )459,      (flex_int16_t const   )444,      (flex_int16_t const   )435,      (flex_int16_t const   )429, 
        (flex_int16_t const   )117,      (flex_int16_t const   )148,      (flex_int16_t const   )708,      (flex_int16_t const   )119, 
        (flex_int16_t const   )93,      (flex_int16_t const   )424,      (flex_int16_t const   )87,      (flex_int16_t const   )87, 
        (flex_int16_t const   )87,      (flex_int16_t const   )87,      (flex_int16_t const   )87,      (flex_int16_t const   )87, 
        (flex_int16_t const   )87,      (flex_int16_t const   )87,      (flex_int16_t const   )87,      (flex_int16_t const   )87, 
        (flex_int16_t const   )87,      (flex_int16_t const   )87,      (flex_int16_t const   )87,      (flex_int16_t const   )87, 
        (flex_int16_t const   )88,      (flex_int16_t const   )86,      (flex_int16_t const   )126,      (flex_int16_t const   )94, 
        (flex_int16_t const   )95,      (flex_int16_t const   )87,      (flex_int16_t const   )87,      (flex_int16_t const   )87, 
        (flex_int16_t const   )87,      (flex_int16_t const   )87,      (flex_int16_t const   )87,      (flex_int16_t const   )423, 
        (flex_int16_t const   )118,      (flex_int16_t const   )112,      (flex_int16_t const   )88,      (flex_int16_t const   )421, 
        (flex_int16_t const   )90,      (flex_int16_t const   )150,      (flex_int16_t const   )127,      (flex_int16_t const   )89, 
        (flex_int16_t const   )416,      (flex_int16_t const   )134,      (flex_int16_t const   )128,      (flex_int16_t const   )135, 
        (flex_int16_t const   )361,      (flex_int16_t const   )387,      (flex_int16_t const   )378,      (flex_int16_t const   )147, 
        (flex_int16_t const   )86,      (flex_int16_t const   )377,      (flex_int16_t const   )361,      (flex_int16_t const   )94, 
        (flex_int16_t const   )95,      (flex_int16_t const   )87,      (flex_int16_t const   )87,      (flex_int16_t const   )87, 
        (flex_int16_t const   )87,      (flex_int16_t const   )87,      (flex_int16_t const   )87,      (flex_int16_t const   )118, 
        (flex_int16_t const   )112,      (flex_int16_t const   )88,      (flex_int16_t const   )116,      (flex_int16_t const   )90, 
        (flex_int16_t const   )150,      (flex_int16_t const   )127,      (flex_int16_t const   )89,      (flex_int16_t const   )149, 
        (flex_int16_t const   )134,      (flex_int16_t const   )128,      (flex_int16_t const   )135,      (flex_int16_t const   )129, 
        (flex_int16_t const   )130,      (flex_int16_t const   )132,      (flex_int16_t const   )137,      (flex_int16_t const   )147, 
        (flex_int16_t const   )93,      (flex_int16_t const   )94,      (flex_int16_t const   )95,      (flex_int16_t const   )120, 
        (flex_int16_t const   )98,      (flex_int16_t const   )133,      (flex_int16_t const   )152,      (flex_int16_t const   )138, 
        (flex_int16_t const   )139,      (flex_int16_t const   )345,      (flex_int16_t const   )136,      (flex_int16_t const   )140, 
        (flex_int16_t const   )151,      (flex_int16_t const   )119,      (flex_int16_t const   )116,      (flex_int16_t const   )121, 
        (flex_int16_t const   )145,      (flex_int16_t const   )146,      (flex_int16_t const   )153,      (flex_int16_t const   )149, 
        (flex_int16_t const   )154,      (flex_int16_t const   )97,      (flex_int16_t const   )129,      (flex_int16_t const   )130, 
        (flex_int16_t const   )295,      (flex_int16_t const   )132,      (flex_int16_t const   )137,      (flex_int16_t const   )93, 
        (flex_int16_t const   )266,      (flex_int16_t const   )94,      (flex_int16_t const   )95,      (flex_int16_t const   )120, 
        (flex_int16_t const   )98,      (flex_int16_t const   )133,      (flex_int16_t const   )152,      (flex_int16_t const   )138, 
        (flex_int16_t const   )139,      (flex_int16_t const   )136,      (flex_int16_t const   )140,      (flex_int16_t const   )151, 
        (flex_int16_t const   )119,      (flex_int16_t const   )155,      (flex_int16_t const   )121,      (flex_int16_t const   )145, 
        (flex_int16_t const   )146,      (flex_int16_t const   )156,      (flex_int16_t const   )153,      (flex_int16_t const   )154, 
        (flex_int16_t const   )97,      (flex_int16_t const   )143,      (flex_int16_t const   )143,      (flex_int16_t const   )143, 
        (flex_int16_t const   )143,      (flex_int16_t const   )143,      (flex_int16_t const   )143,      (flex_int16_t const   )143, 
        (flex_int16_t const   )143,      (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )157, 
        (flex_int16_t const   )145,      (flex_int16_t const   )158,      (flex_int16_t const   )161,      (flex_int16_t const   )208, 
        (flex_int16_t const   )159,      (flex_int16_t const   )207,      (flex_int16_t const   )148,      (flex_int16_t const   )160, 
        (flex_int16_t const   )162,      (flex_int16_t const   )155,      (flex_int16_t const   )163,      (flex_int16_t const   )164, 
        (flex_int16_t const   )165,      (flex_int16_t const   )156,      (flex_int16_t const   )166,      (flex_int16_t const   )167, 
        (flex_int16_t const   )168,      (flex_int16_t const   )205,      (flex_int16_t const   )88,      (flex_int16_t const   )170, 
        (flex_int16_t const   )171,      (flex_int16_t const   )172,      (flex_int16_t const   )174,      (flex_int16_t const   )203, 
        (flex_int16_t const   )169,      (flex_int16_t const   )80,      (flex_int16_t const   )157,      (flex_int16_t const   )145, 
        (flex_int16_t const   )158,      (flex_int16_t const   )175,      (flex_int16_t const   )161,      (flex_int16_t const   )159, 
        (flex_int16_t const   )100,      (flex_int16_t const   )148,      (flex_int16_t const   )160,      (flex_int16_t const   )162, 
        (flex_int16_t const   )176,      (flex_int16_t const   )163,      (flex_int16_t const   )164,      (flex_int16_t const   )177, 
        (flex_int16_t const   )165,      (flex_int16_t const   )166,      (flex_int16_t const   )167,      (flex_int16_t const   )178, 
        (flex_int16_t const   )168,      (flex_int16_t const   )88,      (flex_int16_t const   )170,      (flex_int16_t const   )179, 
        (flex_int16_t const   )171,      (flex_int16_t const   )172,      (flex_int16_t const   )174,      (flex_int16_t const   )169, 
        (flex_int16_t const   )148,      (flex_int16_t const   )173,      (flex_int16_t const   )180,      (flex_int16_t const   )181, 
        (flex_int16_t const   )175,      (flex_int16_t const   )182,      (flex_int16_t const   )184,      (flex_int16_t const   )100, 
        (flex_int16_t const   )183,      (flex_int16_t const   )125,      (flex_int16_t const   )185,      (flex_int16_t const   )176, 
        (flex_int16_t const   )186,      (flex_int16_t const   )170,      (flex_int16_t const   )187,      (flex_int16_t const   )177, 
        (flex_int16_t const   )188,      (flex_int16_t const   )148,      (flex_int16_t const   )173,      (flex_int16_t const   )178, 
        (flex_int16_t const   )193,      (flex_int16_t const   )196,      (flex_int16_t const   )179,      (flex_int16_t const   )194, 
        (flex_int16_t const   )189,      (flex_int16_t const   )191,      (flex_int16_t const   )124,      (flex_int16_t const   )148, 
        (flex_int16_t const   )173,      (flex_int16_t const   )152,      (flex_int16_t const   )180,      (flex_int16_t const   )181, 
        (flex_int16_t const   )182,      (flex_int16_t const   )184,      (flex_int16_t const   )190,      (flex_int16_t const   )195, 
        (flex_int16_t const   )183,      (flex_int16_t const   )185,      (flex_int16_t const   )192,      (flex_int16_t const   )186, 
        (flex_int16_t const   )170,      (flex_int16_t const   )187,      (flex_int16_t const   )123,      (flex_int16_t const   )188, 
        (flex_int16_t const   )148,      (flex_int16_t const   )173,      (flex_int16_t const   )81,      (flex_int16_t const   )198, 
        (flex_int16_t const   )193,      (flex_int16_t const   )196,      (flex_int16_t const   )194,      (flex_int16_t const   )199, 
        (flex_int16_t const   )189,      (flex_int16_t const   )191,      (flex_int16_t const   )200,      (flex_int16_t const   )201, 
        (flex_int16_t const   )206,      (flex_int16_t const   )152,      (flex_int16_t const   )202,      (flex_int16_t const   )204, 
        (flex_int16_t const   )209,      (flex_int16_t const   )190,      (flex_int16_t const   )195,      (flex_int16_t const   )210, 
        (flex_int16_t const   )211,      (flex_int16_t const   )192,      (flex_int16_t const   )143,      (flex_int16_t const   )143, 
        (flex_int16_t const   )143,      (flex_int16_t const   )143,      (flex_int16_t const   )143,      (flex_int16_t const   )143, 
        (flex_int16_t const   )143,      (flex_int16_t const   )143,      (flex_int16_t const   )198,      (flex_int16_t const   )200, 
        (flex_int16_t const   )212,      (flex_int16_t const   )213,      (flex_int16_t const   )199,      (flex_int16_t const   )214, 
        (flex_int16_t const   )216,      (flex_int16_t const   )200,      (flex_int16_t const   )201,      (flex_int16_t const   )197, 
        (flex_int16_t const   )206,      (flex_int16_t const   )202,      (flex_int16_t const   )204,      (flex_int16_t const   )209, 
        (flex_int16_t const   )215,      (flex_int16_t const   )217,      (flex_int16_t const   )218,      (flex_int16_t const   )210, 
        (flex_int16_t const   )211,      (flex_int16_t const   )219,      (flex_int16_t const   )220,      (flex_int16_t const   )221, 
        (flex_int16_t const   )81,      (flex_int16_t const   )222,      (flex_int16_t const   )223,      (flex_int16_t const   )224, 
        (flex_int16_t const   )225,      (flex_int16_t const   )227,      (flex_int16_t const   )200,      (flex_int16_t const   )212, 
        (flex_int16_t const   )213,      (flex_int16_t const   )226,      (flex_int16_t const   )228,      (flex_int16_t const   )214, 
        (flex_int16_t const   )216,      (flex_int16_t const   )229,      (flex_int16_t const   )232,      (flex_int16_t const   )197, 
        (flex_int16_t const   )230,      (flex_int16_t const   )231,      (flex_int16_t const   )233,      (flex_int16_t const   )215, 
        (flex_int16_t const   )217,      (flex_int16_t const   )218,      (flex_int16_t const   )234,      (flex_int16_t const   )235, 
        (flex_int16_t const   )219,      (flex_int16_t const   )220,      (flex_int16_t const   )236,      (flex_int16_t const   )221, 
        (flex_int16_t const   )222,      (flex_int16_t const   )237,      (flex_int16_t const   )223,      (flex_int16_t const   )224, 
        (flex_int16_t const   )225,      (flex_int16_t const   )227,      (flex_int16_t const   )238,      (flex_int16_t const   )242, 
        (flex_int16_t const   )226,      (flex_int16_t const   )228,      (flex_int16_t const   )239,      (flex_int16_t const   )240, 
        (flex_int16_t const   )241,      (flex_int16_t const   )229,      (flex_int16_t const   )232,      (flex_int16_t const   )230, 
        (flex_int16_t const   )231,      (flex_int16_t const   )243,      (flex_int16_t const   )233,      (flex_int16_t const   )244, 
        (flex_int16_t const   )245,      (flex_int16_t const   )234,      (flex_int16_t const   )235,      (flex_int16_t const   )246, 
        (flex_int16_t const   )249,      (flex_int16_t const   )236,      (flex_int16_t const   )80,      (flex_int16_t const   )708, 
        (flex_int16_t const   )237,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )253,      (flex_int16_t const   )238,      (flex_int16_t const   )242, 
        (flex_int16_t const   )252,      (flex_int16_t const   )239,      (flex_int16_t const   )240,      (flex_int16_t const   )241, 
        (flex_int16_t const   )250,      (flex_int16_t const   )254,      (flex_int16_t const   )264,      (flex_int16_t const   )251, 
        (flex_int16_t const   )243,      (flex_int16_t const   )708,      (flex_int16_t const   )244,      (flex_int16_t const   )245, 
        (flex_int16_t const   )265,      (flex_int16_t const   )247,      (flex_int16_t const   )246,      (flex_int16_t const   )247, 
        (flex_int16_t const   )249,      (flex_int16_t const   )248,      (flex_int16_t const   )248,      (flex_int16_t const   )248, 
        (flex_int16_t const   )248,      (flex_int16_t const   )248,      (flex_int16_t const   )248,      (flex_int16_t const   )248, 
        (flex_int16_t const   )248,      (flex_int16_t const   )253,      (flex_int16_t const   )263,      (flex_int16_t const   )252, 
        (flex_int16_t const   )267,      (flex_int16_t const   )268,      (flex_int16_t const   )274,      (flex_int16_t const   )250, 
        (flex_int16_t const   )254,      (flex_int16_t const   )264,      (flex_int16_t const   )251,      (flex_int16_t const   )255, 
        (flex_int16_t const   )256,      (flex_int16_t const   )257,      (flex_int16_t const   )258,      (flex_int16_t const   )265, 
        (flex_int16_t const   )259,      (flex_int16_t const   )708,      (flex_int16_t const   )269,      (flex_int16_t const   )260, 
        (flex_int16_t const   )708,      (flex_int16_t const   )270,      (flex_int16_t const   )271,      (flex_int16_t const   )272, 
        (flex_int16_t const   )273,      (flex_int16_t const   )275,      (flex_int16_t const   )261,      (flex_int16_t const   )276, 
        (flex_int16_t const   )262,      (flex_int16_t const   )281,      (flex_int16_t const   )263,      (flex_int16_t const   )267, 
        (flex_int16_t const   )282,      (flex_int16_t const   )268,      (flex_int16_t const   )274,      (flex_int16_t const   )283, 
        (flex_int16_t const   )284,      (flex_int16_t const   )708,      (flex_int16_t const   )285,      (flex_int16_t const   )255, 
        (flex_int16_t const   )256,      (flex_int16_t const   )257,      (flex_int16_t const   )258,      (flex_int16_t const   )286, 
        (flex_int16_t const   )259,      (flex_int16_t const   )269,      (flex_int16_t const   )287,      (flex_int16_t const   )260, 
        (flex_int16_t const   )270,      (flex_int16_t const   )271,      (flex_int16_t const   )272,      (flex_int16_t const   )273, 
        (flex_int16_t const   )275,      (flex_int16_t const   )261,      (flex_int16_t const   )276,      (flex_int16_t const   )262, 
        (flex_int16_t const   )288,      (flex_int16_t const   )281,      (flex_int16_t const   )289,      (flex_int16_t const   )282, 
        (flex_int16_t const   )290,      (flex_int16_t const   )292,      (flex_int16_t const   )283,      (flex_int16_t const   )291, 
        (flex_int16_t const   )284,      (flex_int16_t const   )285,      (flex_int16_t const   )293,      (flex_int16_t const   )294, 
        (flex_int16_t const   )296,      (flex_int16_t const   )297,      (flex_int16_t const   )286,      (flex_int16_t const   )298, 
        (flex_int16_t const   )299,      (flex_int16_t const   )300,      (flex_int16_t const   )287,      (flex_int16_t const   )301, 
        (flex_int16_t const   )302,      (flex_int16_t const   )708,      (flex_int16_t const   )303,      (flex_int16_t const   )304, 
        (flex_int16_t const   )708,      (flex_int16_t const   )305,      (flex_int16_t const   )708,      (flex_int16_t const   )288, 
        (flex_int16_t const   )708,      (flex_int16_t const   )289,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )290,      (flex_int16_t const   )292,      (flex_int16_t const   )291,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )293,      (flex_int16_t const   )294,      (flex_int16_t const   )708, 
        (flex_int16_t const   )296,      (flex_int16_t const   )297,      (flex_int16_t const   )298,      (flex_int16_t const   )299, 
        (flex_int16_t const   )300,      (flex_int16_t const   )306,      (flex_int16_t const   )301,      (flex_int16_t const   )307, 
        (flex_int16_t const   )302,      (flex_int16_t const   )303,      (flex_int16_t const   )308,      (flex_int16_t const   )304, 
        (flex_int16_t const   )305,      (flex_int16_t const   )248,      (flex_int16_t const   )248,      (flex_int16_t const   )248, 
        (flex_int16_t const   )248,      (flex_int16_t const   )248,      (flex_int16_t const   )248,      (flex_int16_t const   )248, 
        (flex_int16_t const   )248,      (flex_int16_t const   )248,      (flex_int16_t const   )248,      (flex_int16_t const   )248, 
        (flex_int16_t const   )248,      (flex_int16_t const   )248,      (flex_int16_t const   )248,      (flex_int16_t const   )248, 
        (flex_int16_t const   )248,      (flex_int16_t const   )309,      (flex_int16_t const   )310,      (flex_int16_t const   )708, 
        (flex_int16_t const   )311,      (flex_int16_t const   )306,      (flex_int16_t const   )312,      (flex_int16_t const   )307, 
        (flex_int16_t const   )313,      (flex_int16_t const   )308,      (flex_int16_t const   )314,      (flex_int16_t const   )315, 
        (flex_int16_t const   )316,      (flex_int16_t const   )708,      (flex_int16_t const   )318,      (flex_int16_t const   )317, 
        (flex_int16_t const   )319,      (flex_int16_t const   )323,      (flex_int16_t const   )321,      (flex_int16_t const   )324, 
        (flex_int16_t const   )708,      (flex_int16_t const   )325,      (flex_int16_t const   )328,      (flex_int16_t const   )708, 
        (flex_int16_t const   )320,      (flex_int16_t const   )329,      (flex_int16_t const   )330,      (flex_int16_t const   )331, 
        (flex_int16_t const   )332,      (flex_int16_t const   )309,      (flex_int16_t const   )310,      (flex_int16_t const   )311, 
        (flex_int16_t const   )322,      (flex_int16_t const   )333,      (flex_int16_t const   )312,      (flex_int16_t const   )313, 
        (flex_int16_t const   )334,      (flex_int16_t const   )314,      (flex_int16_t const   )335,      (flex_int16_t const   )315, 
        (flex_int16_t const   )316,      (flex_int16_t const   )318,      (flex_int16_t const   )317,      (flex_int16_t const   )336, 
        (flex_int16_t const   )319,      (flex_int16_t const   )323,      (flex_int16_t const   )321,      (flex_int16_t const   )324, 
        (flex_int16_t const   )325,      (flex_int16_t const   )337,      (flex_int16_t const   )328,      (flex_int16_t const   )320, 
        (flex_int16_t const   )329,      (flex_int16_t const   )330,      (flex_int16_t const   )331,      (flex_int16_t const   )332, 
        (flex_int16_t const   )338,      (flex_int16_t const   )339,      (flex_int16_t const   )341,      (flex_int16_t const   )322, 
        (flex_int16_t const   )333,      (flex_int16_t const   )340,      (flex_int16_t const   )342,      (flex_int16_t const   )334, 
        (flex_int16_t const   )343,      (flex_int16_t const   )348,      (flex_int16_t const   )335,      (flex_int16_t const   )344, 
        (flex_int16_t const   )346,      (flex_int16_t const   )347,      (flex_int16_t const   )336,      (flex_int16_t const   )349, 
        (flex_int16_t const   )350,      (flex_int16_t const   )351,      (flex_int16_t const   )708,      (flex_int16_t const   )352, 
        (flex_int16_t const   )353,      (flex_int16_t const   )337,      (flex_int16_t const   )354,      (flex_int16_t const   )708, 
        (flex_int16_t const   )355,      (flex_int16_t const   )356,      (flex_int16_t const   )358,      (flex_int16_t const   )338, 
        (flex_int16_t const   )357,      (flex_int16_t const   )339,      (flex_int16_t const   )341,      (flex_int16_t const   )359, 
        (flex_int16_t const   )340,      (flex_int16_t const   )342,      (flex_int16_t const   )360,      (flex_int16_t const   )362, 
        (flex_int16_t const   )343,      (flex_int16_t const   )348,      (flex_int16_t const   )344,      (flex_int16_t const   )346, 
        (flex_int16_t const   )347,      (flex_int16_t const   )363,      (flex_int16_t const   )349,      (flex_int16_t const   )364, 
        (flex_int16_t const   )350,      (flex_int16_t const   )351,      (flex_int16_t const   )352,      (flex_int16_t const   )353, 
        (flex_int16_t const   )365,      (flex_int16_t const   )366,      (flex_int16_t const   )354,      (flex_int16_t const   )355, 
        (flex_int16_t const   )367,      (flex_int16_t const   )356,      (flex_int16_t const   )358,      (flex_int16_t const   )357, 
        (flex_int16_t const   )368,      (flex_int16_t const   )369,      (flex_int16_t const   )370,      (flex_int16_t const   )359, 
        (flex_int16_t const   )371,      (flex_int16_t const   )360,      (flex_int16_t const   )372,      (flex_int16_t const   )362, 
        (flex_int16_t const   )373,      (flex_int16_t const   )374,      (flex_int16_t const   )708,      (flex_int16_t const   )375, 
        (flex_int16_t const   )363,      (flex_int16_t const   )376,      (flex_int16_t const   )379,      (flex_int16_t const   )364, 
        (flex_int16_t const   )380,      (flex_int16_t const   )708,      (flex_int16_t const   )381,      (flex_int16_t const   )365, 
        (flex_int16_t const   )366,      (flex_int16_t const   )382,      (flex_int16_t const   )383,      (flex_int16_t const   )367, 
        (flex_int16_t const   )386,      (flex_int16_t const   )388,      (flex_int16_t const   )390,      (flex_int16_t const   )368, 
        (flex_int16_t const   )369,      (flex_int16_t const   )370,      (flex_int16_t const   )389,      (flex_int16_t const   )371, 
        (flex_int16_t const   )393,      (flex_int16_t const   )391,      (flex_int16_t const   )372,      (flex_int16_t const   )394, 
        (flex_int16_t const   )373,      (flex_int16_t const   )374,      (flex_int16_t const   )375,      (flex_int16_t const   )392, 
        (flex_int16_t const   )395,      (flex_int16_t const   )376,      (flex_int16_t const   )379,      (flex_int16_t const   )396, 
        (flex_int16_t const   )380,      (flex_int16_t const   )381,      (flex_int16_t const   )397,      (flex_int16_t const   )398, 
        (flex_int16_t const   )399,      (flex_int16_t const   )382,      (flex_int16_t const   )383,      (flex_int16_t const   )386, 
        (flex_int16_t const   )400,      (flex_int16_t const   )388,      (flex_int16_t const   )390,      (flex_int16_t const   )401, 
        (flex_int16_t const   )402,      (flex_int16_t const   )389,      (flex_int16_t const   )403,      (flex_int16_t const   )393, 
        (flex_int16_t const   )404,      (flex_int16_t const   )391,      (flex_int16_t const   )405,      (flex_int16_t const   )394, 
        (flex_int16_t const   )406,      (flex_int16_t const   )407,      (flex_int16_t const   )392,      (flex_int16_t const   )395, 
        (flex_int16_t const   )408,      (flex_int16_t const   )409,      (flex_int16_t const   )411,      (flex_int16_t const   )396, 
        (flex_int16_t const   )410,      (flex_int16_t const   )412,      (flex_int16_t const   )397,      (flex_int16_t const   )398, 
        (flex_int16_t const   )399,      (flex_int16_t const   )413,      (flex_int16_t const   )415,      (flex_int16_t const   )400, 
        (flex_int16_t const   )414,      (flex_int16_t const   )417,      (flex_int16_t const   )426,      (flex_int16_t const   )401, 
        (flex_int16_t const   )402,      (flex_int16_t const   )403,      (flex_int16_t const   )418,      (flex_int16_t const   )404, 
        (flex_int16_t const   )419,      (flex_int16_t const   )405,      (flex_int16_t const   )420,      (flex_int16_t const   )406, 
        (flex_int16_t const   )407,      (flex_int16_t const   )422,      (flex_int16_t const   )425,      (flex_int16_t const   )408, 
        (flex_int16_t const   )427,      (flex_int16_t const   )409,      (flex_int16_t const   )411,      (flex_int16_t const   )410, 
        (flex_int16_t const   )428,      (flex_int16_t const   )412,      (flex_int16_t const   )430,      (flex_int16_t const   )431, 
        (flex_int16_t const   )432,      (flex_int16_t const   )413,      (flex_int16_t const   )415,      (flex_int16_t const   )414, 
        (flex_int16_t const   )433,      (flex_int16_t const   )417,      (flex_int16_t const   )426,      (flex_int16_t const   )434, 
        (flex_int16_t const   )436,      (flex_int16_t const   )418,      (flex_int16_t const   )437,      (flex_int16_t const   )419, 
        (flex_int16_t const   )438,      (flex_int16_t const   )420,      (flex_int16_t const   )439,      (flex_int16_t const   )440, 
        (flex_int16_t const   )422,      (flex_int16_t const   )425,      (flex_int16_t const   )441,      (flex_int16_t const   )427, 
        (flex_int16_t const   )442,      (flex_int16_t const   )443,      (flex_int16_t const   )445,      (flex_int16_t const   )428, 
        (flex_int16_t const   )446,      (flex_int16_t const   )430,      (flex_int16_t const   )447,      (flex_int16_t const   )431, 
        (flex_int16_t const   )432,      (flex_int16_t const   )448,      (flex_int16_t const   )452,      (flex_int16_t const   )433, 
        (flex_int16_t const   )449,      (flex_int16_t const   )450,      (flex_int16_t const   )434,      (flex_int16_t const   )436, 
        (flex_int16_t const   )451,      (flex_int16_t const   )453,      (flex_int16_t const   )437,      (flex_int16_t const   )438, 
        (flex_int16_t const   )454,      (flex_int16_t const   )439,      (flex_int16_t const   )440,      (flex_int16_t const   )455, 
        (flex_int16_t const   )456,      (flex_int16_t const   )441,      (flex_int16_t const   )457,      (flex_int16_t const   )442, 
        (flex_int16_t const   )443,      (flex_int16_t const   )458,      (flex_int16_t const   )445,      (flex_int16_t const   )446, 
        (flex_int16_t const   )460,      (flex_int16_t const   )466,      (flex_int16_t const   )447,      (flex_int16_t const   )467, 
        (flex_int16_t const   )469,      (flex_int16_t const   )448,      (flex_int16_t const   )452,      (flex_int16_t const   )449, 
        (flex_int16_t const   )450,      (flex_int16_t const   )468,      (flex_int16_t const   )470,      (flex_int16_t const   )451, 
        (flex_int16_t const   )471,      (flex_int16_t const   )453,      (flex_int16_t const   )472,      (flex_int16_t const   )473, 
        (flex_int16_t const   )454,      (flex_int16_t const   )474,      (flex_int16_t const   )478,      (flex_int16_t const   )455, 
        (flex_int16_t const   )456,      (flex_int16_t const   )457,      (flex_int16_t const   )475,      (flex_int16_t const   )480, 
        (flex_int16_t const   )458,      (flex_int16_t const   )476,      (flex_int16_t const   )481,      (flex_int16_t const   )460, 
        (flex_int16_t const   )466,      (flex_int16_t const   )482,      (flex_int16_t const   )477,      (flex_int16_t const   )467, 
        (flex_int16_t const   )469,      (flex_int16_t const   )484,      (flex_int16_t const   )485,      (flex_int16_t const   )487, 
        (flex_int16_t const   )468,      (flex_int16_t const   )470,      (flex_int16_t const   )488,      (flex_int16_t const   )471, 
        (flex_int16_t const   )489,      (flex_int16_t const   )490,      (flex_int16_t const   )472,      (flex_int16_t const   )473, 
        (flex_int16_t const   )491,      (flex_int16_t const   )474,      (flex_int16_t const   )478,      (flex_int16_t const   )492, 
        (flex_int16_t const   )493,      (flex_int16_t const   )475,      (flex_int16_t const   )494,      (flex_int16_t const   )480, 
        (flex_int16_t const   )476,      (flex_int16_t const   )481,      (flex_int16_t const   )708,      (flex_int16_t const   )502, 
        (flex_int16_t const   )482,      (flex_int16_t const   )477,      (flex_int16_t const   )503,      (flex_int16_t const   )504, 
        (flex_int16_t const   )484,      (flex_int16_t const   )485,      (flex_int16_t const   )505,      (flex_int16_t const   )487, 
        (flex_int16_t const   )506,      (flex_int16_t const   )508,      (flex_int16_t const   )488,      (flex_int16_t const   )497, 
        (flex_int16_t const   )489,      (flex_int16_t const   )490,      (flex_int16_t const   )507,      (flex_int16_t const   )491, 
        (flex_int16_t const   )509,      (flex_int16_t const   )498,      (flex_int16_t const   )492,      (flex_int16_t const   )493, 
        (flex_int16_t const   )515,      (flex_int16_t const   )499,      (flex_int16_t const   )494,      (flex_int16_t const   )500, 
        (flex_int16_t const   )516,      (flex_int16_t const   )501,      (flex_int16_t const   )502,      (flex_int16_t const   )510, 
        (flex_int16_t const   )511,      (flex_int16_t const   )503,      (flex_int16_t const   )504,      (flex_int16_t const   )513, 
        (flex_int16_t const   )514,      (flex_int16_t const   )518,      (flex_int16_t const   )505,      (flex_int16_t const   )517, 
        (flex_int16_t const   )506,      (flex_int16_t const   )508,      (flex_int16_t const   )519,      (flex_int16_t const   )497, 
        (flex_int16_t const   )520,      (flex_int16_t const   )507,      (flex_int16_t const   )521,      (flex_int16_t const   )524, 
        (flex_int16_t const   )509,      (flex_int16_t const   )498,      (flex_int16_t const   )522,      (flex_int16_t const   )515, 
        (flex_int16_t const   )499,      (flex_int16_t const   )523,      (flex_int16_t const   )500,      (flex_int16_t const   )516, 
        (flex_int16_t const   )501,      (flex_int16_t const   )525,      (flex_int16_t const   )526,      (flex_int16_t const   )510, 
        (flex_int16_t const   )511,      (flex_int16_t const   )529,      (flex_int16_t const   )530,      (flex_int16_t const   )513, 
        (flex_int16_t const   )514,      (flex_int16_t const   )518,      (flex_int16_t const   )517,      (flex_int16_t const   )531, 
        (flex_int16_t const   )532,      (flex_int16_t const   )519,      (flex_int16_t const   )533,      (flex_int16_t const   )520, 
        (flex_int16_t const   )534,      (flex_int16_t const   )537,      (flex_int16_t const   )521,      (flex_int16_t const   )524, 
        (flex_int16_t const   )535,      (flex_int16_t const   )522,      (flex_int16_t const   )536,      (flex_int16_t const   )538, 
        (flex_int16_t const   )523,      (flex_int16_t const   )539,      (flex_int16_t const   )540,      (flex_int16_t const   )542, 
        (flex_int16_t const   )525,      (flex_int16_t const   )541,      (flex_int16_t const   )526,      (flex_int16_t const   )543, 
        (flex_int16_t const   )529,      (flex_int16_t const   )530,      (flex_int16_t const   )544,      (flex_int16_t const   )545, 
        (flex_int16_t const   )547,      (flex_int16_t const   )548,      (flex_int16_t const   )531,      (flex_int16_t const   )532, 
        (flex_int16_t const   )550,      (flex_int16_t const   )552,      (flex_int16_t const   )533,      (flex_int16_t const   )553, 
        (flex_int16_t const   )534,      (flex_int16_t const   )537,      (flex_int16_t const   )554,      (flex_int16_t const   )535, 
        (flex_int16_t const   )555,      (flex_int16_t const   )536,      (flex_int16_t const   )538,      (flex_int16_t const   )556, 
        (flex_int16_t const   )557,      (flex_int16_t const   )539,      (flex_int16_t const   )540,      (flex_int16_t const   )542, 
        (flex_int16_t const   )541,      (flex_int16_t const   )561,      (flex_int16_t const   )543,      (flex_int16_t const   )562, 
        (flex_int16_t const   )565,      (flex_int16_t const   )544,      (flex_int16_t const   )545,      (flex_int16_t const   )547, 
        (flex_int16_t const   )563,      (flex_int16_t const   )548,      (flex_int16_t const   )564,      (flex_int16_t const   )550, 
        (flex_int16_t const   )566,      (flex_int16_t const   )552,      (flex_int16_t const   )553,      (flex_int16_t const   )567, 
        (flex_int16_t const   )568,      (flex_int16_t const   )554,      (flex_int16_t const   )569,      (flex_int16_t const   )555, 
        (flex_int16_t const   )570,      (flex_int16_t const   )708,      (flex_int16_t const   )571,      (flex_int16_t const   )556, 
        (flex_int16_t const   )557,      (flex_int16_t const   )572,      (flex_int16_t const   )708,      (flex_int16_t const   )579, 
        (flex_int16_t const   )561,      (flex_int16_t const   )580,      (flex_int16_t const   )708,      (flex_int16_t const   )562, 
        (flex_int16_t const   )565,      (flex_int16_t const   )585,      (flex_int16_t const   )587,      (flex_int16_t const   )563, 
        (flex_int16_t const   )590,      (flex_int16_t const   )564,      (flex_int16_t const   )708,      (flex_int16_t const   )566, 
        (flex_int16_t const   )586,      (flex_int16_t const   )708,      (flex_int16_t const   )567,      (flex_int16_t const   )588, 
        (flex_int16_t const   )568,      (flex_int16_t const   )591,      (flex_int16_t const   )569,      (flex_int16_t const   )596, 
        (flex_int16_t const   )570,      (flex_int16_t const   )571,      (flex_int16_t const   )597,      (flex_int16_t const   )598, 
        (flex_int16_t const   )572,      (flex_int16_t const   )573,      (flex_int16_t const   )574,      (flex_int16_t const   )579, 
        (flex_int16_t const   )580,      (flex_int16_t const   )575,      (flex_int16_t const   )581,      (flex_int16_t const   )599, 
        (flex_int16_t const   )585,      (flex_int16_t const   )587,      (flex_int16_t const   )576,      (flex_int16_t const   )590, 
        (flex_int16_t const   )582,      (flex_int16_t const   )577,      (flex_int16_t const   )578,      (flex_int16_t const   )600, 
        (flex_int16_t const   )586,      (flex_int16_t const   )583,      (flex_int16_t const   )584,      (flex_int16_t const   )588, 
        (flex_int16_t const   )601,      (flex_int16_t const   )591,      (flex_int16_t const   )602,      (flex_int16_t const   )596, 
        (flex_int16_t const   )603,      (flex_int16_t const   )604,      (flex_int16_t const   )597,      (flex_int16_t const   )598, 
        (flex_int16_t const   )605,      (flex_int16_t const   )573,      (flex_int16_t const   )574,      (flex_int16_t const   )606, 
        (flex_int16_t const   )607,      (flex_int16_t const   )575,      (flex_int16_t const   )581,      (flex_int16_t const   )599, 
        (flex_int16_t const   )608,      (flex_int16_t const   )576,      (flex_int16_t const   )609,      (flex_int16_t const   )582, 
        (flex_int16_t const   )577,      (flex_int16_t const   )578,      (flex_int16_t const   )600,      (flex_int16_t const   )610, 
        (flex_int16_t const   )583,      (flex_int16_t const   )584,      (flex_int16_t const   )611,      (flex_int16_t const   )601, 
        (flex_int16_t const   )612,      (flex_int16_t const   )602,      (flex_int16_t const   )613,      (flex_int16_t const   )603, 
        (flex_int16_t const   )614,      (flex_int16_t const   )604,      (flex_int16_t const   )615,      (flex_int16_t const   )617, 
        (flex_int16_t const   )605,      (flex_int16_t const   )616,      (flex_int16_t const   )618,      (flex_int16_t const   )606, 
        (flex_int16_t const   )607,      (flex_int16_t const   )619,      (flex_int16_t const   )620,      (flex_int16_t const   )608, 
        (flex_int16_t const   )621,      (flex_int16_t const   )622,      (flex_int16_t const   )609,      (flex_int16_t const   )623, 
        (flex_int16_t const   )626,      (flex_int16_t const   )627,      (flex_int16_t const   )610,      (flex_int16_t const   )628, 
        (flex_int16_t const   )629,      (flex_int16_t const   )611,      (flex_int16_t const   )630,      (flex_int16_t const   )612, 
        (flex_int16_t const   )631,      (flex_int16_t const   )632,      (flex_int16_t const   )613,      (flex_int16_t const   )614, 
        (flex_int16_t const   )633,      (flex_int16_t const   )634,      (flex_int16_t const   )615,      (flex_int16_t const   )617, 
        (flex_int16_t const   )616,      (flex_int16_t const   )618,      (flex_int16_t const   )635,      (flex_int16_t const   )636, 
        (flex_int16_t const   )619,      (flex_int16_t const   )637,      (flex_int16_t const   )620,      (flex_int16_t const   )621, 
        (flex_int16_t const   )638,      (flex_int16_t const   )622,      (flex_int16_t const   )623,      (flex_int16_t const   )626, 
        (flex_int16_t const   )627,      (flex_int16_t const   )639,      (flex_int16_t const   )628,      (flex_int16_t const   )640, 
        (flex_int16_t const   )629,      (flex_int16_t const   )630,      (flex_int16_t const   )641,      (flex_int16_t const   )631, 
        (flex_int16_t const   )632,      (flex_int16_t const   )642,      (flex_int16_t const   )645,      (flex_int16_t const   )633, 
        (flex_int16_t const   )634,      (flex_int16_t const   )643,      (flex_int16_t const   )644,      (flex_int16_t const   )646, 
        (flex_int16_t const   )647,      (flex_int16_t const   )635,      (flex_int16_t const   )648,      (flex_int16_t const   )636, 
        (flex_int16_t const   )637,      (flex_int16_t const   )649,      (flex_int16_t const   )708,      (flex_int16_t const   )650, 
        (flex_int16_t const   )638,      (flex_int16_t const   )654,      (flex_int16_t const   )655,      (flex_int16_t const   )656, 
        (flex_int16_t const   )659,      (flex_int16_t const   )639,      (flex_int16_t const   )657,      (flex_int16_t const   )640, 
        (flex_int16_t const   )658,      (flex_int16_t const   )660,      (flex_int16_t const   )641,      (flex_int16_t const   )661, 
        (flex_int16_t const   )666,      (flex_int16_t const   )642,      (flex_int16_t const   )645,      (flex_int16_t const   )662, 
        (flex_int16_t const   )643,      (flex_int16_t const   )644,      (flex_int16_t const   )663,      (flex_int16_t const   )646, 
        (flex_int16_t const   )647,      (flex_int16_t const   )648,      (flex_int16_t const   )664,      (flex_int16_t const   )665, 
        (flex_int16_t const   )667,      (flex_int16_t const   )649,      (flex_int16_t const   )650,      (flex_int16_t const   )668, 
        (flex_int16_t const   )654,      (flex_int16_t const   )669,      (flex_int16_t const   )655,      (flex_int16_t const   )656, 
        (flex_int16_t const   )659,      (flex_int16_t const   )657,      (flex_int16_t const   )670,      (flex_int16_t const   )658, 
        (flex_int16_t const   )660,      (flex_int16_t const   )671,      (flex_int16_t const   )672,      (flex_int16_t const   )661, 
        (flex_int16_t const   )666,      (flex_int16_t const   )673,      (flex_int16_t const   )662,      (flex_int16_t const   )674, 
        (flex_int16_t const   )675,      (flex_int16_t const   )663,      (flex_int16_t const   )676,      (flex_int16_t const   )677, 
        (flex_int16_t const   )678,      (flex_int16_t const   )664,      (flex_int16_t const   )665,      (flex_int16_t const   )679, 
        (flex_int16_t const   )667,      (flex_int16_t const   )680,      (flex_int16_t const   )668,      (flex_int16_t const   )681, 
        (flex_int16_t const   )669,      (flex_int16_t const   )682,      (flex_int16_t const   )683,      (flex_int16_t const   )708, 
        (flex_int16_t const   )684,      (flex_int16_t const   )670,      (flex_int16_t const   )686,      (flex_int16_t const   )687, 
        (flex_int16_t const   )671,      (flex_int16_t const   )688,      (flex_int16_t const   )672,      (flex_int16_t const   )689, 
        (flex_int16_t const   )673,      (flex_int16_t const   )690,      (flex_int16_t const   )674,      (flex_int16_t const   )675, 
        (flex_int16_t const   )691,      (flex_int16_t const   )676,      (flex_int16_t const   )692,      (flex_int16_t const   )677, 
        (flex_int16_t const   )678,      (flex_int16_t const   )693,      (flex_int16_t const   )679,      (flex_int16_t const   )694, 
        (flex_int16_t const   )695,      (flex_int16_t const   )680,      (flex_int16_t const   )696,      (flex_int16_t const   )681, 
        (flex_int16_t const   )697,      (flex_int16_t const   )682,      (flex_int16_t const   )683,      (flex_int16_t const   )684, 
        (flex_int16_t const   )698,      (flex_int16_t const   )686,      (flex_int16_t const   )687,      (flex_int16_t const   )699, 
        (flex_int16_t const   )700,      (flex_int16_t const   )688,      (flex_int16_t const   )689,      (flex_int16_t const   )701, 
        (flex_int16_t const   )690,      (flex_int16_t const   )702,      (flex_int16_t const   )703,      (flex_int16_t const   )704, 
        (flex_int16_t const   )691,      (flex_int16_t const   )705,      (flex_int16_t const   )692,      (flex_int16_t const   )706, 
        (flex_int16_t const   )693,      (flex_int16_t const   )707,      (flex_int16_t const   )708,      (flex_int16_t const   )694, 
        (flex_int16_t const   )695,      (flex_int16_t const   )696,      (flex_int16_t const   )708,      (flex_int16_t const   )697, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )698, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )699, 
        (flex_int16_t const   )700,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )701, 
        (flex_int16_t const   )702,      (flex_int16_t const   )708,      (flex_int16_t const   )703,      (flex_int16_t const   )704, 
        (flex_int16_t const   )705,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )706, 
        (flex_int16_t const   )707,      (flex_int16_t const   )88,      (flex_int16_t const   )88,      (flex_int16_t const   )142, 
        (flex_int16_t const   )708,      (flex_int16_t const   )142,      (flex_int16_t const   )142,      (flex_int16_t const   )13, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708};
#line 946 "bsdl_flex.c"
static flex_int16_t const   yy_chk___0[1671]  = 
#line 946
  {      (flex_int16_t const   )0,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )5,      (flex_int16_t const   )5,      (flex_int16_t const   )32,      (flex_int16_t const   )9, 
        (flex_int16_t const   )9,      (flex_int16_t const   )624,      (flex_int16_t const   )28,      (flex_int16_t const   )5, 
        (flex_int16_t const   )624,      (flex_int16_t const   )5,      (flex_int16_t const   )9,      (flex_int16_t const   )24, 
        (flex_int16_t const   )24,      (flex_int16_t const   )5,      (flex_int16_t const   )5,      (flex_int16_t const   )33, 
        (flex_int16_t const   )9,      (flex_int16_t const   )34,      (flex_int16_t const   )218,      (flex_int16_t const   )218, 
        (flex_int16_t const   )5,      (flex_int16_t const   )219,      (flex_int16_t const   )219,      (flex_int16_t const   )5, 
        (flex_int16_t const   )711,      (flex_int16_t const   )36,      (flex_int16_t const   )36,      (flex_int16_t const   )668, 
        (flex_int16_t const   )5,      (flex_int16_t const   )5,      (flex_int16_t const   )32,      (flex_int16_t const   )9, 
        (flex_int16_t const   )9,      (flex_int16_t const   )28,      (flex_int16_t const   )625,      (flex_int16_t const   )5, 
        (flex_int16_t const   )5,      (flex_int16_t const   )35,      (flex_int16_t const   )9,      (flex_int16_t const   )593, 
        (flex_int16_t const   )5,      (flex_int16_t const   )5,      (flex_int16_t const   )33,      (flex_int16_t const   )9, 
        (flex_int16_t const   )39,      (flex_int16_t const   )34,      (flex_int16_t const   )24,      (flex_int16_t const   )5, 
        (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )5,      (flex_int16_t const   )7, 
        (flex_int16_t const   )7,      (flex_int16_t const   )7,      (flex_int16_t const   )7,      (flex_int16_t const   )10, 
        (flex_int16_t const   )42,      (flex_int16_t const   )7,      (flex_int16_t const   )7,      (flex_int16_t const   )592, 
        (flex_int16_t const   )36,      (flex_int16_t const   )10,      (flex_int16_t const   )31,      (flex_int16_t const   )31, 
        (flex_int16_t const   )35,      (flex_int16_t const   )7,      (flex_int16_t const   )7,      (flex_int16_t const   )7, 
        (flex_int16_t const   )40,      (flex_int16_t const   )7,      (flex_int16_t const   )266,      (flex_int16_t const   )40, 
        (flex_int16_t const   )39,      (flex_int16_t const   )24,      (flex_int16_t const   )266,      (flex_int16_t const   )559, 
        (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )45,      (flex_int16_t const   )7, 
        (flex_int16_t const   )7,      (flex_int16_t const   )7,      (flex_int16_t const   )7,      (flex_int16_t const   )10, 
        (flex_int16_t const   )42,      (flex_int16_t const   )7,      (flex_int16_t const   )7,      (flex_int16_t const   )36, 
        (flex_int16_t const   )10,      (flex_int16_t const   )558,      (flex_int16_t const   )31,      (flex_int16_t const   )31, 
        (flex_int16_t const   )7,      (flex_int16_t const   )7,      (flex_int16_t const   )7,      (flex_int16_t const   )40, 
        (flex_int16_t const   )7,      (flex_int16_t const   )11,      (flex_int16_t const   )40,      (flex_int16_t const   )11, 
        (flex_int16_t const   )56,      (flex_int16_t const   )44,      (flex_int16_t const   )44,      (flex_int16_t const   )11, 
        (flex_int16_t const   )555,      (flex_int16_t const   )11,      (flex_int16_t const   )45,      (flex_int16_t const   )334, 
        (flex_int16_t const   )334,      (flex_int16_t const   )527,      (flex_int16_t const   )527,      (flex_int16_t const   )560, 
        (flex_int16_t const   )560,      (flex_int16_t const   )44,      (flex_int16_t const   )51,      (flex_int16_t const   )43, 
        (flex_int16_t const   )11,      (flex_int16_t const   )11,      (flex_int16_t const   )11,      (flex_int16_t const   )11, 
        (flex_int16_t const   )11,      (flex_int16_t const   )57,      (flex_int16_t const   )11,      (flex_int16_t const   )78, 
        (flex_int16_t const   )11,      (flex_int16_t const   )528,      (flex_int16_t const   )70,      (flex_int16_t const   )56, 
        (flex_int16_t const   )11,      (flex_int16_t const   )44,      (flex_int16_t const   )44,      (flex_int16_t const   )11, 
        (flex_int16_t const   )11,      (flex_int16_t const   )43,      (flex_int16_t const   )11,      (flex_int16_t const   )11, 
        (flex_int16_t const   )11,      (flex_int16_t const   )11,      (flex_int16_t const   )11,      (flex_int16_t const   )11, 
        (flex_int16_t const   )44,      (flex_int16_t const   )11,      (flex_int16_t const   )51,      (flex_int16_t const   )43, 
        (flex_int16_t const   )520,      (flex_int16_t const   )518,      (flex_int16_t const   )515,      (flex_int16_t const   )496, 
        (flex_int16_t const   )11,      (flex_int16_t const   )57,      (flex_int16_t const   )11,      (flex_int16_t const   )78, 
        (flex_int16_t const   )11,      (flex_int16_t const   )70,      (flex_int16_t const   )495,      (flex_int16_t const   )87, 
        (flex_int16_t const   )11,      (flex_int16_t const   )30,      (flex_int16_t const   )11,      (flex_int16_t const   )11, 
        (flex_int16_t const   )43,      (flex_int16_t const   )11,      (flex_int16_t const   )11,      (flex_int16_t const   )11, 
        (flex_int16_t const   )11,      (flex_int16_t const   )11,      (flex_int16_t const   )11,      (flex_int16_t const   )30, 
        (flex_int16_t const   )11,      (flex_int16_t const   )478,      (flex_int16_t const   )463,      (flex_int16_t const   )30, 
        (flex_int16_t const   )11,      (flex_int16_t const   )23,      (flex_int16_t const   )23,      (flex_int16_t const   )23, 
        (flex_int16_t const   )23,      (flex_int16_t const   )23,      (flex_int16_t const   )23,      (flex_int16_t const   )23, 
        (flex_int16_t const   )23,      (flex_int16_t const   )23,      (flex_int16_t const   )87,      (flex_int16_t const   )55, 
        (flex_int16_t const   )462,      (flex_int16_t const   )30,      (flex_int16_t const   )41,      (flex_int16_t const   )23, 
        (flex_int16_t const   )23,      (flex_int16_t const   )23,      (flex_int16_t const   )23,      (flex_int16_t const   )23, 
        (flex_int16_t const   )23,      (flex_int16_t const   )49,      (flex_int16_t const   )30,      (flex_int16_t const   )47, 
        (flex_int16_t const   )41,      (flex_int16_t const   )50,      (flex_int16_t const   )30,      (flex_int16_t const   )48, 
        (flex_int16_t const   )41,      (flex_int16_t const   )55,      (flex_int16_t const   )48,      (flex_int16_t const   )49, 
        (flex_int16_t const   )47,      (flex_int16_t const   )50,      (flex_int16_t const   )453,      (flex_int16_t const   )89, 
        (flex_int16_t const   )450,      (flex_int16_t const   )23,      (flex_int16_t const   )446,      (flex_int16_t const   )55, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )41,      (flex_int16_t const   )23, 
        (flex_int16_t const   )23,      (flex_int16_t const   )23,      (flex_int16_t const   )23,      (flex_int16_t const   )23, 
        (flex_int16_t const   )23,      (flex_int16_t const   )49,      (flex_int16_t const   )47,      (flex_int16_t const   )41, 
        (flex_int16_t const   )50,      (flex_int16_t const   )432,      (flex_int16_t const   )48,      (flex_int16_t const   )41, 
        (flex_int16_t const   )55,      (flex_int16_t const   )48,      (flex_int16_t const   )49,      (flex_int16_t const   )47, 
        (flex_int16_t const   )50,      (flex_int16_t const   )54,      (flex_int16_t const   )89,      (flex_int16_t const   )52, 
        (flex_int16_t const   )23,      (flex_int16_t const   )26,      (flex_int16_t const   )26,      (flex_int16_t const   )26, 
        (flex_int16_t const   )26,      (flex_int16_t const   )26,      (flex_int16_t const   )26,      (flex_int16_t const   )26, 
        (flex_int16_t const   )26,      (flex_int16_t const   )52,      (flex_int16_t const   )92,      (flex_int16_t const   )84, 
        (flex_int16_t const   )54,      (flex_int16_t const   )52,      (flex_int16_t const   )26,      (flex_int16_t const   )26, 
        (flex_int16_t const   )26,      (flex_int16_t const   )26,      (flex_int16_t const   )26,      (flex_int16_t const   )26, 
        (flex_int16_t const   )430,      (flex_int16_t const   )426,      (flex_int16_t const   )86,      (flex_int16_t const   )86, 
        (flex_int16_t const   )425,      (flex_int16_t const   )54,      (flex_int16_t const   )424,      (flex_int16_t const   )52, 
        (flex_int16_t const   )423,      (flex_int16_t const   )66,      (flex_int16_t const   )422,      (flex_int16_t const   )66, 
        (flex_int16_t const   )420,      (flex_int16_t const   )403,      (flex_int16_t const   )393,      (flex_int16_t const   )383, 
        (flex_int16_t const   )52,      (flex_int16_t const   )92,      (flex_int16_t const   )84,      (flex_int16_t const   )54, 
        (flex_int16_t const   )52,      (flex_int16_t const   )378,      (flex_int16_t const   )26,      (flex_int16_t const   )26, 
        (flex_int16_t const   )26,      (flex_int16_t const   )26,      (flex_int16_t const   )26,      (flex_int16_t const   )26, 
        (flex_int16_t const   )27,      (flex_int16_t const   )27,      (flex_int16_t const   )27,      (flex_int16_t const   )27, 
        (flex_int16_t const   )27,      (flex_int16_t const   )27,      (flex_int16_t const   )27,      (flex_int16_t const   )27, 
        (flex_int16_t const   )66,      (flex_int16_t const   )86,      (flex_int16_t const   )66,      (flex_int16_t const   )53, 
        (flex_int16_t const   )53,      (flex_int16_t const   )27,      (flex_int16_t const   )27,      (flex_int16_t const   )27, 
        (flex_int16_t const   )27,      (flex_int16_t const   )27,      (flex_int16_t const   )27,      (flex_int16_t const   )377, 
        (flex_int16_t const   )53,      (flex_int16_t const   )67,      (flex_int16_t const   )68,      (flex_int16_t const   )375, 
        (flex_int16_t const   )67,      (flex_int16_t const   )94,      (flex_int16_t const   )67,      (flex_int16_t const   )27, 
        (flex_int16_t const   )370,      (flex_int16_t const   )72,      (flex_int16_t const   )68,      (flex_int16_t const   )72, 
        (flex_int16_t const   )339,      (flex_int16_t const   )337,      (flex_int16_t const   )327,      (flex_int16_t const   )91, 
        (flex_int16_t const   )86,      (flex_int16_t const   )326,      (flex_int16_t const   )310,      (flex_int16_t const   )53, 
        (flex_int16_t const   )53,      (flex_int16_t const   )27,      (flex_int16_t const   )27,      (flex_int16_t const   )27, 
        (flex_int16_t const   )27,      (flex_int16_t const   )27,      (flex_int16_t const   )27,      (flex_int16_t const   )53, 
        (flex_int16_t const   )67,      (flex_int16_t const   )68,      (flex_int16_t const   )69,      (flex_int16_t const   )67, 
        (flex_int16_t const   )94,      (flex_int16_t const   )67,      (flex_int16_t const   )27,      (flex_int16_t const   )93, 
        (flex_int16_t const   )72,      (flex_int16_t const   )68,      (flex_int16_t const   )72,      (flex_int16_t const   )69, 
        (flex_int16_t const   )69,      (flex_int16_t const   )71,      (flex_int16_t const   )74,      (flex_int16_t const   )91, 
        (flex_int16_t const   )69,      (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )75, 
        (flex_int16_t const   )76,      (flex_int16_t const   )71,      (flex_int16_t const   )96,      (flex_int16_t const   )75, 
        (flex_int16_t const   )76,      (flex_int16_t const   )293,      (flex_int16_t const   )73,      (flex_int16_t const   )77, 
        (flex_int16_t const   )95,      (flex_int16_t const   )74,      (flex_int16_t const   )69,      (flex_int16_t const   )77, 
        (flex_int16_t const   )90,      (flex_int16_t const   )90,      (flex_int16_t const   )97,      (flex_int16_t const   )93, 
        (flex_int16_t const   )98,      (flex_int16_t const   )75,      (flex_int16_t const   )69,      (flex_int16_t const   )69, 
        (flex_int16_t const   )234,      (flex_int16_t const   )71,      (flex_int16_t const   )74,      (flex_int16_t const   )69, 
        (flex_int16_t const   )207,      (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )75, 
        (flex_int16_t const   )76,      (flex_int16_t const   )71,      (flex_int16_t const   )96,      (flex_int16_t const   )75, 
        (flex_int16_t const   )76,      (flex_int16_t const   )73,      (flex_int16_t const   )77,      (flex_int16_t const   )95, 
        (flex_int16_t const   )74,      (flex_int16_t const   )99,      (flex_int16_t const   )77,      (flex_int16_t const   )90, 
        (flex_int16_t const   )90,      (flex_int16_t const   )101,      (flex_int16_t const   )97,      (flex_int16_t const   )98, 
        (flex_int16_t const   )75,      (flex_int16_t const   )82,      (flex_int16_t const   )82,      (flex_int16_t const   )82, 
        (flex_int16_t const   )82,      (flex_int16_t const   )82,      (flex_int16_t const   )82,      (flex_int16_t const   )82, 
        (flex_int16_t const   )82,      (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )102, 
        (flex_int16_t const   )103,      (flex_int16_t const   )103,      (flex_int16_t const   )105,      (flex_int16_t const   )154, 
        (flex_int16_t const   )104,      (flex_int16_t const   )153,      (flex_int16_t const   )104,      (flex_int16_t const   )104, 
        (flex_int16_t const   )106,      (flex_int16_t const   )99,      (flex_int16_t const   )107,      (flex_int16_t const   )108, 
        (flex_int16_t const   )109,      (flex_int16_t const   )101,      (flex_int16_t const   )110,      (flex_int16_t const   )111, 
        (flex_int16_t const   )112,      (flex_int16_t const   )151,      (flex_int16_t const   )113,      (flex_int16_t const   )114, 
        (flex_int16_t const   )115,      (flex_int16_t const   )116,      (flex_int16_t const   )118,      (flex_int16_t const   )149, 
        (flex_int16_t const   )113,      (flex_int16_t const   )80,      (flex_int16_t const   )102,      (flex_int16_t const   )103, 
        (flex_int16_t const   )103,      (flex_int16_t const   )119,      (flex_int16_t const   )105,      (flex_int16_t const   )104, 
        (flex_int16_t const   )100,      (flex_int16_t const   )104,      (flex_int16_t const   )104,      (flex_int16_t const   )106, 
        (flex_int16_t const   )120,      (flex_int16_t const   )107,      (flex_int16_t const   )108,      (flex_int16_t const   )121, 
        (flex_int16_t const   )109,      (flex_int16_t const   )110,      (flex_int16_t const   )111,      (flex_int16_t const   )122, 
        (flex_int16_t const   )112,      (flex_int16_t const   )113,      (flex_int16_t const   )114,      (flex_int16_t const   )126, 
        (flex_int16_t const   )115,      (flex_int16_t const   )116,      (flex_int16_t const   )118,      (flex_int16_t const   )113, 
        (flex_int16_t const   )117,      (flex_int16_t const   )117,      (flex_int16_t const   )127,      (flex_int16_t const   )128, 
        (flex_int16_t const   )119,      (flex_int16_t const   )129,      (flex_int16_t const   )131,      (flex_int16_t const   )100, 
        (flex_int16_t const   )130,      (flex_int16_t const   )65,      (flex_int16_t const   )132,      (flex_int16_t const   )120, 
        (flex_int16_t const   )133,      (flex_int16_t const   )128,      (flex_int16_t const   )134,      (flex_int16_t const   )121, 
        (flex_int16_t const   )135,      (flex_int16_t const   )130,      (flex_int16_t const   )130,      (flex_int16_t const   )122, 
        (flex_int16_t const   )138,      (flex_int16_t const   )141,      (flex_int16_t const   )126,      (flex_int16_t const   )139, 
        (flex_int16_t const   )136,      (flex_int16_t const   )137,      (flex_int16_t const   )64,      (flex_int16_t const   )117, 
        (flex_int16_t const   )117,      (flex_int16_t const   )137,      (flex_int16_t const   )127,      (flex_int16_t const   )128, 
        (flex_int16_t const   )129,      (flex_int16_t const   )131,      (flex_int16_t const   )136,      (flex_int16_t const   )140, 
        (flex_int16_t const   )130,      (flex_int16_t const   )132,      (flex_int16_t const   )137,      (flex_int16_t const   )133, 
        (flex_int16_t const   )128,      (flex_int16_t const   )134,      (flex_int16_t const   )62,      (flex_int16_t const   )135, 
        (flex_int16_t const   )130,      (flex_int16_t const   )130,      (flex_int16_t const   )61,      (flex_int16_t const   )144, 
        (flex_int16_t const   )138,      (flex_int16_t const   )141,      (flex_int16_t const   )139,      (flex_int16_t const   )145, 
        (flex_int16_t const   )136,      (flex_int16_t const   )137,      (flex_int16_t const   )146,      (flex_int16_t const   )147, 
        (flex_int16_t const   )152,      (flex_int16_t const   )137,      (flex_int16_t const   )148,      (flex_int16_t const   )150, 
        (flex_int16_t const   )155,      (flex_int16_t const   )136,      (flex_int16_t const   )140,      (flex_int16_t const   )156, 
        (flex_int16_t const   )157,      (flex_int16_t const   )137,      (flex_int16_t const   )143,      (flex_int16_t const   )143, 
        (flex_int16_t const   )143,      (flex_int16_t const   )143,      (flex_int16_t const   )143,      (flex_int16_t const   )143, 
        (flex_int16_t const   )143,      (flex_int16_t const   )143,      (flex_int16_t const   )144,      (flex_int16_t const   )158, 
        (flex_int16_t const   )158,      (flex_int16_t const   )159,      (flex_int16_t const   )145,      (flex_int16_t const   )160, 
        (flex_int16_t const   )162,      (flex_int16_t const   )146,      (flex_int16_t const   )147,      (flex_int16_t const   )143, 
        (flex_int16_t const   )152,      (flex_int16_t const   )148,      (flex_int16_t const   )150,      (flex_int16_t const   )155, 
        (flex_int16_t const   )161,      (flex_int16_t const   )163,      (flex_int16_t const   )164,      (flex_int16_t const   )156, 
        (flex_int16_t const   )157,      (flex_int16_t const   )165,      (flex_int16_t const   )166,      (flex_int16_t const   )167, 
        (flex_int16_t const   )22,      (flex_int16_t const   )168,      (flex_int16_t const   )169,      (flex_int16_t const   )170, 
        (flex_int16_t const   )171,      (flex_int16_t const   )173,      (flex_int16_t const   )158,      (flex_int16_t const   )158, 
        (flex_int16_t const   )159,      (flex_int16_t const   )172,      (flex_int16_t const   )174,      (flex_int16_t const   )160, 
        (flex_int16_t const   )162,      (flex_int16_t const   )175,      (flex_int16_t const   )178,      (flex_int16_t const   )143, 
        (flex_int16_t const   )176,      (flex_int16_t const   )177,      (flex_int16_t const   )179,      (flex_int16_t const   )161, 
        (flex_int16_t const   )163,      (flex_int16_t const   )164,      (flex_int16_t const   )181,      (flex_int16_t const   )182, 
        (flex_int16_t const   )165,      (flex_int16_t const   )166,      (flex_int16_t const   )183,      (flex_int16_t const   )167, 
        (flex_int16_t const   )168,      (flex_int16_t const   )184,      (flex_int16_t const   )169,      (flex_int16_t const   )170, 
        (flex_int16_t const   )171,      (flex_int16_t const   )173,      (flex_int16_t const   )187,      (flex_int16_t const   )192, 
        (flex_int16_t const   )172,      (flex_int16_t const   )174,      (flex_int16_t const   )189,      (flex_int16_t const   )190, 
        (flex_int16_t const   )191,      (flex_int16_t const   )175,      (flex_int16_t const   )178,      (flex_int16_t const   )176, 
        (flex_int16_t const   )177,      (flex_int16_t const   )193,      (flex_int16_t const   )179,      (flex_int16_t const   )194, 
        (flex_int16_t const   )195,      (flex_int16_t const   )181,      (flex_int16_t const   )182,      (flex_int16_t const   )196, 
        (flex_int16_t const   )198,      (flex_int16_t const   )183,      (flex_int16_t const   )15,      (flex_int16_t const   )13, 
        (flex_int16_t const   )184,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )201,      (flex_int16_t const   )187,      (flex_int16_t const   )192, 
        (flex_int16_t const   )200,      (flex_int16_t const   )189,      (flex_int16_t const   )190,      (flex_int16_t const   )191, 
        (flex_int16_t const   )199,      (flex_int16_t const   )202,      (flex_int16_t const   )205,      (flex_int16_t const   )199, 
        (flex_int16_t const   )193,      (flex_int16_t const   )0,      (flex_int16_t const   )194,      (flex_int16_t const   )195, 
        (flex_int16_t const   )206,      (flex_int16_t const   )197,      (flex_int16_t const   )196,      (flex_int16_t const   )197, 
        (flex_int16_t const   )198,      (flex_int16_t const   )197,      (flex_int16_t const   )197,      (flex_int16_t const   )197, 
        (flex_int16_t const   )197,      (flex_int16_t const   )197,      (flex_int16_t const   )197,      (flex_int16_t const   )197, 
        (flex_int16_t const   )197,      (flex_int16_t const   )201,      (flex_int16_t const   )204,      (flex_int16_t const   )200, 
        (flex_int16_t const   )208,      (flex_int16_t const   )209,      (flex_int16_t const   )215,      (flex_int16_t const   )199, 
        (flex_int16_t const   )202,      (flex_int16_t const   )205,      (flex_int16_t const   )199,      (flex_int16_t const   )203, 
        (flex_int16_t const   )203,      (flex_int16_t const   )203,      (flex_int16_t const   )203,      (flex_int16_t const   )206, 
        (flex_int16_t const   )203,      (flex_int16_t const   )0,      (flex_int16_t const   )210,      (flex_int16_t const   )203, 
        (flex_int16_t const   )0,      (flex_int16_t const   )211,      (flex_int16_t const   )212,      (flex_int16_t const   )213, 
        (flex_int16_t const   )214,      (flex_int16_t const   )216,      (flex_int16_t const   )203,      (flex_int16_t const   )217, 
        (flex_int16_t const   )203,      (flex_int16_t const   )220,      (flex_int16_t const   )204,      (flex_int16_t const   )208, 
        (flex_int16_t const   )221,      (flex_int16_t const   )209,      (flex_int16_t const   )215,      (flex_int16_t const   )222, 
        (flex_int16_t const   )223,      (flex_int16_t const   )0,      (flex_int16_t const   )224,      (flex_int16_t const   )203, 
        (flex_int16_t const   )203,      (flex_int16_t const   )203,      (flex_int16_t const   )203,      (flex_int16_t const   )225, 
        (flex_int16_t const   )203,      (flex_int16_t const   )210,      (flex_int16_t const   )226,      (flex_int16_t const   )203, 
        (flex_int16_t const   )211,      (flex_int16_t const   )212,      (flex_int16_t const   )213,      (flex_int16_t const   )214, 
        (flex_int16_t const   )216,      (flex_int16_t const   )203,      (flex_int16_t const   )217,      (flex_int16_t const   )203, 
        (flex_int16_t const   )227,      (flex_int16_t const   )220,      (flex_int16_t const   )228,      (flex_int16_t const   )221, 
        (flex_int16_t const   )229,      (flex_int16_t const   )231,      (flex_int16_t const   )222,      (flex_int16_t const   )230, 
        (flex_int16_t const   )223,      (flex_int16_t const   )224,      (flex_int16_t const   )232,      (flex_int16_t const   )233, 
        (flex_int16_t const   )235,      (flex_int16_t const   )236,      (flex_int16_t const   )225,      (flex_int16_t const   )238, 
        (flex_int16_t const   )239,      (flex_int16_t const   )240,      (flex_int16_t const   )226,      (flex_int16_t const   )241, 
        (flex_int16_t const   )242,      (flex_int16_t const   )0,      (flex_int16_t const   )243,      (flex_int16_t const   )244, 
        (flex_int16_t const   )0,      (flex_int16_t const   )245,      (flex_int16_t const   )0,      (flex_int16_t const   )227, 
        (flex_int16_t const   )0,      (flex_int16_t const   )228,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )229,      (flex_int16_t const   )231,      (flex_int16_t const   )230,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )232,      (flex_int16_t const   )233,      (flex_int16_t const   )0, 
        (flex_int16_t const   )235,      (flex_int16_t const   )236,      (flex_int16_t const   )238,      (flex_int16_t const   )239, 
        (flex_int16_t const   )240,      (flex_int16_t const   )249,      (flex_int16_t const   )241,      (flex_int16_t const   )250, 
        (flex_int16_t const   )242,      (flex_int16_t const   )243,      (flex_int16_t const   )251,      (flex_int16_t const   )244, 
        (flex_int16_t const   )245,      (flex_int16_t const   )247,      (flex_int16_t const   )247,      (flex_int16_t const   )247, 
        (flex_int16_t const   )247,      (flex_int16_t const   )247,      (flex_int16_t const   )247,      (flex_int16_t const   )247, 
        (flex_int16_t const   )247,      (flex_int16_t const   )248,      (flex_int16_t const   )248,      (flex_int16_t const   )248, 
        (flex_int16_t const   )248,      (flex_int16_t const   )248,      (flex_int16_t const   )248,      (flex_int16_t const   )248, 
        (flex_int16_t const   )248,      (flex_int16_t const   )252,      (flex_int16_t const   )253,      (flex_int16_t const   )0, 
        (flex_int16_t const   )254,      (flex_int16_t const   )249,      (flex_int16_t const   )255,      (flex_int16_t const   )250, 
        (flex_int16_t const   )256,      (flex_int16_t const   )251,      (flex_int16_t const   )257,      (flex_int16_t const   )258, 
        (flex_int16_t const   )259,      (flex_int16_t const   )0,      (flex_int16_t const   )260,      (flex_int16_t const   )259, 
        (flex_int16_t const   )261,      (flex_int16_t const   )263,      (flex_int16_t const   )262,      (flex_int16_t const   )264, 
        (flex_int16_t const   )0,      (flex_int16_t const   )265,      (flex_int16_t const   )267,      (flex_int16_t const   )0, 
        (flex_int16_t const   )261,      (flex_int16_t const   )268,      (flex_int16_t const   )271,      (flex_int16_t const   )273, 
        (flex_int16_t const   )274,      (flex_int16_t const   )252,      (flex_int16_t const   )253,      (flex_int16_t const   )254, 
        (flex_int16_t const   )262,      (flex_int16_t const   )275,      (flex_int16_t const   )255,      (flex_int16_t const   )256, 
        (flex_int16_t const   )276,      (flex_int16_t const   )257,      (flex_int16_t const   )281,      (flex_int16_t const   )258, 
        (flex_int16_t const   )259,      (flex_int16_t const   )260,      (flex_int16_t const   )259,      (flex_int16_t const   )282, 
        (flex_int16_t const   )261,      (flex_int16_t const   )263,      (flex_int16_t const   )262,      (flex_int16_t const   )264, 
        (flex_int16_t const   )265,      (flex_int16_t const   )284,      (flex_int16_t const   )267,      (flex_int16_t const   )261, 
        (flex_int16_t const   )268,      (flex_int16_t const   )271,      (flex_int16_t const   )273,      (flex_int16_t const   )274, 
        (flex_int16_t const   )285,      (flex_int16_t const   )287,      (flex_int16_t const   )289,      (flex_int16_t const   )262, 
        (flex_int16_t const   )275,      (flex_int16_t const   )288,      (flex_int16_t const   )290,      (flex_int16_t const   )276, 
        (flex_int16_t const   )291,      (flex_int16_t const   )297,      (flex_int16_t const   )281,      (flex_int16_t const   )292, 
        (flex_int16_t const   )295,      (flex_int16_t const   )296,      (flex_int16_t const   )282,      (flex_int16_t const   )298, 
        (flex_int16_t const   )299,      (flex_int16_t const   )300,      (flex_int16_t const   )0,      (flex_int16_t const   )301, 
        (flex_int16_t const   )302,      (flex_int16_t const   )284,      (flex_int16_t const   )303,      (flex_int16_t const   )0, 
        (flex_int16_t const   )304,      (flex_int16_t const   )305,      (flex_int16_t const   )307,      (flex_int16_t const   )285, 
        (flex_int16_t const   )306,      (flex_int16_t const   )287,      (flex_int16_t const   )289,      (flex_int16_t const   )308, 
        (flex_int16_t const   )288,      (flex_int16_t const   )290,      (flex_int16_t const   )309,      (flex_int16_t const   )311, 
        (flex_int16_t const   )291,      (flex_int16_t const   )297,      (flex_int16_t const   )292,      (flex_int16_t const   )295, 
        (flex_int16_t const   )296,      (flex_int16_t const   )312,      (flex_int16_t const   )298,      (flex_int16_t const   )313, 
        (flex_int16_t const   )299,      (flex_int16_t const   )300,      (flex_int16_t const   )301,      (flex_int16_t const   )302, 
        (flex_int16_t const   )314,      (flex_int16_t const   )315,      (flex_int16_t const   )303,      (flex_int16_t const   )304, 
        (flex_int16_t const   )316,      (flex_int16_t const   )305,      (flex_int16_t const   )307,      (flex_int16_t const   )306, 
        (flex_int16_t const   )317,      (flex_int16_t const   )318,      (flex_int16_t const   )319,      (flex_int16_t const   )308, 
        (flex_int16_t const   )320,      (flex_int16_t const   )309,      (flex_int16_t const   )321,      (flex_int16_t const   )311, 
        (flex_int16_t const   )322,      (flex_int16_t const   )323,      (flex_int16_t const   )0,      (flex_int16_t const   )324, 
        (flex_int16_t const   )312,      (flex_int16_t const   )325,      (flex_int16_t const   )328,      (flex_int16_t const   )313, 
        (flex_int16_t const   )329,      (flex_int16_t const   )0,      (flex_int16_t const   )330,      (flex_int16_t const   )314, 
        (flex_int16_t const   )315,      (flex_int16_t const   )331,      (flex_int16_t const   )333,      (flex_int16_t const   )316, 
        (flex_int16_t const   )335,      (flex_int16_t const   )341,      (flex_int16_t const   )344,      (flex_int16_t const   )317, 
        (flex_int16_t const   )318,      (flex_int16_t const   )319,      (flex_int16_t const   )342,      (flex_int16_t const   )320, 
        (flex_int16_t const   )346,      (flex_int16_t const   )345,      (flex_int16_t const   )321,      (flex_int16_t const   )347, 
        (flex_int16_t const   )322,      (flex_int16_t const   )323,      (flex_int16_t const   )324,      (flex_int16_t const   )345, 
        (flex_int16_t const   )348,      (flex_int16_t const   )325,      (flex_int16_t const   )328,      (flex_int16_t const   )349, 
        (flex_int16_t const   )329,      (flex_int16_t const   )330,      (flex_int16_t const   )350,      (flex_int16_t const   )351, 
        (flex_int16_t const   )352,      (flex_int16_t const   )331,      (flex_int16_t const   )333,      (flex_int16_t const   )335, 
        (flex_int16_t const   )354,      (flex_int16_t const   )341,      (flex_int16_t const   )344,      (flex_int16_t const   )355, 
        (flex_int16_t const   )356,      (flex_int16_t const   )342,      (flex_int16_t const   )357,      (flex_int16_t const   )346, 
        (flex_int16_t const   )358,      (flex_int16_t const   )345,      (flex_int16_t const   )359,      (flex_int16_t const   )347, 
        (flex_int16_t const   )360,      (flex_int16_t const   )361,      (flex_int16_t const   )345,      (flex_int16_t const   )348, 
        (flex_int16_t const   )362,      (flex_int16_t const   )363,      (flex_int16_t const   )365,      (flex_int16_t const   )349, 
        (flex_int16_t const   )364,      (flex_int16_t const   )366,      (flex_int16_t const   )350,      (flex_int16_t const   )351, 
        (flex_int16_t const   )352,      (flex_int16_t const   )367,      (flex_int16_t const   )369,      (flex_int16_t const   )354, 
        (flex_int16_t const   )368,      (flex_int16_t const   )371,      (flex_int16_t const   )380,      (flex_int16_t const   )355, 
        (flex_int16_t const   )356,      (flex_int16_t const   )357,      (flex_int16_t const   )372,      (flex_int16_t const   )358, 
        (flex_int16_t const   )373,      (flex_int16_t const   )359,      (flex_int16_t const   )374,      (flex_int16_t const   )360, 
        (flex_int16_t const   )361,      (flex_int16_t const   )376,      (flex_int16_t const   )379,      (flex_int16_t const   )362, 
        (flex_int16_t const   )381,      (flex_int16_t const   )363,      (flex_int16_t const   )365,      (flex_int16_t const   )364, 
        (flex_int16_t const   )382,      (flex_int16_t const   )366,      (flex_int16_t const   )386,      (flex_int16_t const   )387, 
        (flex_int16_t const   )390,      (flex_int16_t const   )367,      (flex_int16_t const   )369,      (flex_int16_t const   )368, 
        (flex_int16_t const   )391,      (flex_int16_t const   )371,      (flex_int16_t const   )380,      (flex_int16_t const   )392, 
        (flex_int16_t const   )394,      (flex_int16_t const   )372,      (flex_int16_t const   )395,      (flex_int16_t const   )373, 
        (flex_int16_t const   )396,      (flex_int16_t const   )374,      (flex_int16_t const   )398,      (flex_int16_t const   )399, 
        (flex_int16_t const   )376,      (flex_int16_t const   )379,      (flex_int16_t const   )400,      (flex_int16_t const   )381, 
        (flex_int16_t const   )401,      (flex_int16_t const   )402,      (flex_int16_t const   )404,      (flex_int16_t const   )382, 
        (flex_int16_t const   )405,      (flex_int16_t const   )386,      (flex_int16_t const   )407,      (flex_int16_t const   )387, 
        (flex_int16_t const   )390,      (flex_int16_t const   )408,      (flex_int16_t const   )412,      (flex_int16_t const   )391, 
        (flex_int16_t const   )409,      (flex_int16_t const   )410,      (flex_int16_t const   )392,      (flex_int16_t const   )394, 
        (flex_int16_t const   )411,      (flex_int16_t const   )413,      (flex_int16_t const   )395,      (flex_int16_t const   )396, 
        (flex_int16_t const   )415,      (flex_int16_t const   )398,      (flex_int16_t const   )399,      (flex_int16_t const   )416, 
        (flex_int16_t const   )417,      (flex_int16_t const   )400,      (flex_int16_t const   )418,      (flex_int16_t const   )401, 
        (flex_int16_t const   )402,      (flex_int16_t const   )419,      (flex_int16_t const   )404,      (flex_int16_t const   )405, 
        (flex_int16_t const   )421,      (flex_int16_t const   )429,      (flex_int16_t const   )407,      (flex_int16_t const   )431, 
        (flex_int16_t const   )435,      (flex_int16_t const   )408,      (flex_int16_t const   )412,      (flex_int16_t const   )409, 
        (flex_int16_t const   )410,      (flex_int16_t const   )434,      (flex_int16_t const   )436,      (flex_int16_t const   )411, 
        (flex_int16_t const   )437,      (flex_int16_t const   )413,      (flex_int16_t const   )439,      (flex_int16_t const   )440, 
        (flex_int16_t const   )415,      (flex_int16_t const   )442,      (flex_int16_t const   )445,      (flex_int16_t const   )416, 
        (flex_int16_t const   )417,      (flex_int16_t const   )418,      (flex_int16_t const   )443,      (flex_int16_t const   )447, 
        (flex_int16_t const   )419,      (flex_int16_t const   )444,      (flex_int16_t const   )448,      (flex_int16_t const   )421, 
        (flex_int16_t const   )429,      (flex_int16_t const   )449,      (flex_int16_t const   )444,      (flex_int16_t const   )431, 
        (flex_int16_t const   )435,      (flex_int16_t const   )451,      (flex_int16_t const   )452,      (flex_int16_t const   )454, 
        (flex_int16_t const   )434,      (flex_int16_t const   )436,      (flex_int16_t const   )455,      (flex_int16_t const   )437, 
        (flex_int16_t const   )456,      (flex_int16_t const   )457,      (flex_int16_t const   )439,      (flex_int16_t const   )440, 
        (flex_int16_t const   )458,      (flex_int16_t const   )442,      (flex_int16_t const   )445,      (flex_int16_t const   )459, 
        (flex_int16_t const   )460,      (flex_int16_t const   )443,      (flex_int16_t const   )461,      (flex_int16_t const   )447, 
        (flex_int16_t const   )444,      (flex_int16_t const   )448,      (flex_int16_t const   )0,      (flex_int16_t const   )465, 
        (flex_int16_t const   )449,      (flex_int16_t const   )444,      (flex_int16_t const   )466,      (flex_int16_t const   )469, 
        (flex_int16_t const   )451,      (flex_int16_t const   )452,      (flex_int16_t const   )470,      (flex_int16_t const   )454, 
        (flex_int16_t const   )471,      (flex_int16_t const   )473,      (flex_int16_t const   )455,      (flex_int16_t const   )464, 
        (flex_int16_t const   )456,      (flex_int16_t const   )457,      (flex_int16_t const   )472,      (flex_int16_t const   )458, 
        (flex_int16_t const   )475,      (flex_int16_t const   )464,      (flex_int16_t const   )459,      (flex_int16_t const   )460, 
        (flex_int16_t const   )481,      (flex_int16_t const   )464,      (flex_int16_t const   )461,      (flex_int16_t const   )464, 
        (flex_int16_t const   )483,      (flex_int16_t const   )464,      (flex_int16_t const   )465,      (flex_int16_t const   )476, 
        (flex_int16_t const   )477,      (flex_int16_t const   )466,      (flex_int16_t const   )469,      (flex_int16_t const   )479, 
        (flex_int16_t const   )480,      (flex_int16_t const   )485,      (flex_int16_t const   )470,      (flex_int16_t const   )484, 
        (flex_int16_t const   )471,      (flex_int16_t const   )473,      (flex_int16_t const   )486,      (flex_int16_t const   )464, 
        (flex_int16_t const   )487,      (flex_int16_t const   )472,      (flex_int16_t const   )488,      (flex_int16_t const   )492, 
        (flex_int16_t const   )475,      (flex_int16_t const   )464,      (flex_int16_t const   )489,      (flex_int16_t const   )481, 
        (flex_int16_t const   )464,      (flex_int16_t const   )490,      (flex_int16_t const   )464,      (flex_int16_t const   )483, 
        (flex_int16_t const   )464,      (flex_int16_t const   )493,      (flex_int16_t const   )494,      (flex_int16_t const   )476, 
        (flex_int16_t const   )477,      (flex_int16_t const   )497,      (flex_int16_t const   )498,      (flex_int16_t const   )479, 
        (flex_int16_t const   )480,      (flex_int16_t const   )485,      (flex_int16_t const   )484,      (flex_int16_t const   )499, 
        (flex_int16_t const   )500,      (flex_int16_t const   )486,      (flex_int16_t const   )501,      (flex_int16_t const   )487, 
        (flex_int16_t const   )502,      (flex_int16_t const   )505,      (flex_int16_t const   )488,      (flex_int16_t const   )492, 
        (flex_int16_t const   )503,      (flex_int16_t const   )489,      (flex_int16_t const   )504,      (flex_int16_t const   )507, 
        (flex_int16_t const   )490,      (flex_int16_t const   )508,      (flex_int16_t const   )509,      (flex_int16_t const   )511, 
        (flex_int16_t const   )493,      (flex_int16_t const   )510,      (flex_int16_t const   )494,      (flex_int16_t const   )512, 
        (flex_int16_t const   )497,      (flex_int16_t const   )498,      (flex_int16_t const   )513,      (flex_int16_t const   )514, 
        (flex_int16_t const   )516,      (flex_int16_t const   )517,      (flex_int16_t const   )499,      (flex_int16_t const   )500, 
        (flex_int16_t const   )519,      (flex_int16_t const   )521,      (flex_int16_t const   )501,      (flex_int16_t const   )522, 
        (flex_int16_t const   )502,      (flex_int16_t const   )505,      (flex_int16_t const   )523,      (flex_int16_t const   )503, 
        (flex_int16_t const   )524,      (flex_int16_t const   )504,      (flex_int16_t const   )507,      (flex_int16_t const   )525, 
        (flex_int16_t const   )526,      (flex_int16_t const   )508,      (flex_int16_t const   )509,      (flex_int16_t const   )511, 
        (flex_int16_t const   )510,      (flex_int16_t const   )529,      (flex_int16_t const   )512,      (flex_int16_t const   )531, 
        (flex_int16_t const   )534,      (flex_int16_t const   )513,      (flex_int16_t const   )514,      (flex_int16_t const   )516, 
        (flex_int16_t const   )532,      (flex_int16_t const   )517,      (flex_int16_t const   )533,      (flex_int16_t const   )519, 
        (flex_int16_t const   )535,      (flex_int16_t const   )521,      (flex_int16_t const   )522,      (flex_int16_t const   )536, 
        (flex_int16_t const   )541,      (flex_int16_t const   )523,      (flex_int16_t const   )542,      (flex_int16_t const   )524, 
        (flex_int16_t const   )543,      (flex_int16_t const   )0,      (flex_int16_t const   )544,      (flex_int16_t const   )525, 
        (flex_int16_t const   )526,      (flex_int16_t const   )545,      (flex_int16_t const   )0,      (flex_int16_t const   )547, 
        (flex_int16_t const   )529,      (flex_int16_t const   )548,      (flex_int16_t const   )0,      (flex_int16_t const   )531, 
        (flex_int16_t const   )534,      (flex_int16_t const   )550,      (flex_int16_t const   )552,      (flex_int16_t const   )532, 
        (flex_int16_t const   )556,      (flex_int16_t const   )533,      (flex_int16_t const   )0,      (flex_int16_t const   )535, 
        (flex_int16_t const   )551,      (flex_int16_t const   )0,      (flex_int16_t const   )536,      (flex_int16_t const   )553, 
        (flex_int16_t const   )541,      (flex_int16_t const   )557,      (flex_int16_t const   )542,      (flex_int16_t const   )561, 
        (flex_int16_t const   )543,      (flex_int16_t const   )544,      (flex_int16_t const   )562,      (flex_int16_t const   )564, 
        (flex_int16_t const   )545,      (flex_int16_t const   )546,      (flex_int16_t const   )546,      (flex_int16_t const   )547, 
        (flex_int16_t const   )548,      (flex_int16_t const   )546,      (flex_int16_t const   )549,      (flex_int16_t const   )565, 
        (flex_int16_t const   )550,      (flex_int16_t const   )552,      (flex_int16_t const   )546,      (flex_int16_t const   )556, 
        (flex_int16_t const   )549,      (flex_int16_t const   )546,      (flex_int16_t const   )546,      (flex_int16_t const   )567, 
        (flex_int16_t const   )551,      (flex_int16_t const   )549,      (flex_int16_t const   )549,      (flex_int16_t const   )553, 
        (flex_int16_t const   )568,      (flex_int16_t const   )557,      (flex_int16_t const   )569,      (flex_int16_t const   )561, 
        (flex_int16_t const   )570,      (flex_int16_t const   )571,      (flex_int16_t const   )562,      (flex_int16_t const   )564, 
        (flex_int16_t const   )572,      (flex_int16_t const   )546,      (flex_int16_t const   )546,      (flex_int16_t const   )573, 
        (flex_int16_t const   )574,      (flex_int16_t const   )546,      (flex_int16_t const   )549,      (flex_int16_t const   )565, 
        (flex_int16_t const   )575,      (flex_int16_t const   )546,      (flex_int16_t const   )576,      (flex_int16_t const   )549, 
        (flex_int16_t const   )546,      (flex_int16_t const   )546,      (flex_int16_t const   )567,      (flex_int16_t const   )577, 
        (flex_int16_t const   )549,      (flex_int16_t const   )549,      (flex_int16_t const   )578,      (flex_int16_t const   )568, 
        (flex_int16_t const   )579,      (flex_int16_t const   )569,      (flex_int16_t const   )580,      (flex_int16_t const   )570, 
        (flex_int16_t const   )581,      (flex_int16_t const   )571,      (flex_int16_t const   )582,      (flex_int16_t const   )584, 
        (flex_int16_t const   )572,      (flex_int16_t const   )583,      (flex_int16_t const   )585,      (flex_int16_t const   )573, 
        (flex_int16_t const   )574,      (flex_int16_t const   )586,      (flex_int16_t const   )587,      (flex_int16_t const   )575, 
        (flex_int16_t const   )589,      (flex_int16_t const   )590,      (flex_int16_t const   )576,      (flex_int16_t const   )591, 
        (flex_int16_t const   )596,      (flex_int16_t const   )598,      (flex_int16_t const   )577,      (flex_int16_t const   )599, 
        (flex_int16_t const   )601,      (flex_int16_t const   )578,      (flex_int16_t const   )602,      (flex_int16_t const   )579, 
        (flex_int16_t const   )603,      (flex_int16_t const   )604,      (flex_int16_t const   )580,      (flex_int16_t const   )581, 
        (flex_int16_t const   )605,      (flex_int16_t const   )606,      (flex_int16_t const   )582,      (flex_int16_t const   )584, 
        (flex_int16_t const   )583,      (flex_int16_t const   )585,      (flex_int16_t const   )607,      (flex_int16_t const   )608, 
        (flex_int16_t const   )586,      (flex_int16_t const   )609,      (flex_int16_t const   )587,      (flex_int16_t const   )589, 
        (flex_int16_t const   )610,      (flex_int16_t const   )590,      (flex_int16_t const   )591,      (flex_int16_t const   )596, 
        (flex_int16_t const   )598,      (flex_int16_t const   )611,      (flex_int16_t const   )599,      (flex_int16_t const   )612, 
        (flex_int16_t const   )601,      (flex_int16_t const   )602,      (flex_int16_t const   )613,      (flex_int16_t const   )603, 
        (flex_int16_t const   )604,      (flex_int16_t const   )614,      (flex_int16_t const   )617,      (flex_int16_t const   )605, 
        (flex_int16_t const   )606,      (flex_int16_t const   )615,      (flex_int16_t const   )616,      (flex_int16_t const   )618, 
        (flex_int16_t const   )619,      (flex_int16_t const   )607,      (flex_int16_t const   )620,      (flex_int16_t const   )608, 
        (flex_int16_t const   )609,      (flex_int16_t const   )621,      (flex_int16_t const   )0,      (flex_int16_t const   )623, 
        (flex_int16_t const   )610,      (flex_int16_t const   )628,      (flex_int16_t const   )630,      (flex_int16_t const   )631, 
        (flex_int16_t const   )635,      (flex_int16_t const   )611,      (flex_int16_t const   )632,      (flex_int16_t const   )612, 
        (flex_int16_t const   )634,      (flex_int16_t const   )636,      (flex_int16_t const   )613,      (flex_int16_t const   )637, 
        (flex_int16_t const   )644,      (flex_int16_t const   )614,      (flex_int16_t const   )617,      (flex_int16_t const   )638, 
        (flex_int16_t const   )615,      (flex_int16_t const   )616,      (flex_int16_t const   )639,      (flex_int16_t const   )618, 
        (flex_int16_t const   )619,      (flex_int16_t const   )620,      (flex_int16_t const   )640,      (flex_int16_t const   )642, 
        (flex_int16_t const   )645,      (flex_int16_t const   )621,      (flex_int16_t const   )623,      (flex_int16_t const   )646, 
        (flex_int16_t const   )628,      (flex_int16_t const   )647,      (flex_int16_t const   )630,      (flex_int16_t const   )631, 
        (flex_int16_t const   )635,      (flex_int16_t const   )632,      (flex_int16_t const   )648,      (flex_int16_t const   )634, 
        (flex_int16_t const   )636,      (flex_int16_t const   )649,      (flex_int16_t const   )654,      (flex_int16_t const   )637, 
        (flex_int16_t const   )644,      (flex_int16_t const   )655,      (flex_int16_t const   )638,      (flex_int16_t const   )656, 
        (flex_int16_t const   )657,      (flex_int16_t const   )639,      (flex_int16_t const   )658,      (flex_int16_t const   )659, 
        (flex_int16_t const   )660,      (flex_int16_t const   )640,      (flex_int16_t const   )642,      (flex_int16_t const   )661, 
        (flex_int16_t const   )645,      (flex_int16_t const   )662,      (flex_int16_t const   )646,      (flex_int16_t const   )663, 
        (flex_int16_t const   )647,      (flex_int16_t const   )664,      (flex_int16_t const   )665,      (flex_int16_t const   )0, 
        (flex_int16_t const   )666,      (flex_int16_t const   )648,      (flex_int16_t const   )672,      (flex_int16_t const   )674, 
        (flex_int16_t const   )649,      (flex_int16_t const   )675,      (flex_int16_t const   )654,      (flex_int16_t const   )676, 
        (flex_int16_t const   )655,      (flex_int16_t const   )677,      (flex_int16_t const   )656,      (flex_int16_t const   )657, 
        (flex_int16_t const   )679,      (flex_int16_t const   )658,      (flex_int16_t const   )680,      (flex_int16_t const   )659, 
        (flex_int16_t const   )660,      (flex_int16_t const   )681,      (flex_int16_t const   )661,      (flex_int16_t const   )682, 
        (flex_int16_t const   )684,      (flex_int16_t const   )662,      (flex_int16_t const   )685,      (flex_int16_t const   )663, 
        (flex_int16_t const   )687,      (flex_int16_t const   )664,      (flex_int16_t const   )665,      (flex_int16_t const   )666, 
        (flex_int16_t const   )688,      (flex_int16_t const   )672,      (flex_int16_t const   )674,      (flex_int16_t const   )689, 
        (flex_int16_t const   )690,      (flex_int16_t const   )675,      (flex_int16_t const   )676,      (flex_int16_t const   )693, 
        (flex_int16_t const   )677,      (flex_int16_t const   )695,      (flex_int16_t const   )696,      (flex_int16_t const   )698, 
        (flex_int16_t const   )679,      (flex_int16_t const   )703,      (flex_int16_t const   )680,      (flex_int16_t const   )704, 
        (flex_int16_t const   )681,      (flex_int16_t const   )705,      (flex_int16_t const   )0,      (flex_int16_t const   )682, 
        (flex_int16_t const   )684,      (flex_int16_t const   )685,      (flex_int16_t const   )0,      (flex_int16_t const   )687, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )688, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )689, 
        (flex_int16_t const   )690,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )693, 
        (flex_int16_t const   )695,      (flex_int16_t const   )0,      (flex_int16_t const   )696,      (flex_int16_t const   )698, 
        (flex_int16_t const   )703,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )704, 
        (flex_int16_t const   )705,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )710, 
        (flex_int16_t const   )0,      (flex_int16_t const   )710,      (flex_int16_t const   )710,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708};
#line 31 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bsdl/bsdl_parser.h"
void *bsdl_flex_init(int proc_mode ) ;
#line 32
void bsdl_flex_deinit(void *scanner ) ;
#line 33
void bsdl_flex_set_bin_x(void *scanner ) ;
#line 34
void bsdl_flex_set_hex(void *scanner ) ;
#line 35
void bsdl_flex_set_decimal(void *scanner ) ;
#line 37
int bsdl_flex_postinc_compile_errors(void *scanner ) ;
#line 39
void bsdl_flex_stop_buffer(void *scanner ) ;
#line 143 "bsdl_flex.l"
static char *new_string___0(scan_extra_t *extra , char const   *str ) ;
#line 1355 "bsdl_flex.c"
static int yy_init_globals___0(yyscan_t yyscanner ) ;
#line 1361
int bsdllex_init(yyscan_t *ptr_yy_globals ) ;
#line 1363
int bsdllex_init_extra(scan_extra_t *yy_user_defined , yyscan_t *ptr_yy_globals ) ;
#line 1368
int bsdllex_destroy(yyscan_t yyscanner ) ;
#line 1370
int bsdlget_debug(yyscan_t yyscanner ) ;
#line 1372
void bsdlset_debug(int bdebug , yyscan_t yyscanner ) ;
#line 1374
scan_extra_t *bsdlget_extra(yyscan_t yyscanner ) ;
#line 1376
void bsdlset_extra(scan_extra_t *user_defined , yyscan_t yyscanner ) ;
#line 1378
FILE *bsdlget_in(yyscan_t yyscanner ) ;
#line 1380
void bsdlset_in(FILE *in_str , yyscan_t yyscanner ) ;
#line 1382
FILE *bsdlget_out(yyscan_t yyscanner ) ;
#line 1384
void bsdlset_out(FILE *out_str , yyscan_t yyscanner ) ;
#line 1386
int bsdlget_leng(yyscan_t yyscanner ) ;
#line 1388
char *bsdlget_text(yyscan_t yyscanner ) ;
#line 1390
int bsdlget_lineno(yyscan_t yyscanner ) ;
#line 1392
void bsdlset_lineno(int line_number , yyscan_t yyscanner ) ;
#line 1394
YYSTYPE *bsdlget_lval(yyscan_t yyscanner ) ;
#line 1396
void bsdlset_lval(YYSTYPE *yylval_param , yyscan_t yyscanner ) ;
#line 1406
int bsdlwrap(yyscan_t scanner ) ;
#line 1510
int bsdllex(YYSTYPE *yylval_param , yyscan_t yyscanner ) ;
#line 1534 "bsdl_flex.c"
int bsdllex(YYSTYPE *yylval_param , yyscan_t yyscanner ) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register char *yy_bp ;
  register int yy_act ;
  struct yyguts_t *yyg ;
  void *tmp ;
  YY_BUFFER_STATE tmp___0 ;
  yy_state_type *tmp___1 ;
  register YY_CHAR yy_c ;
  yy_state_type *tmp___2 ;
  YY_BUFFER_STATE tmp___3 ;
  int yy_amount_of_matched_text ;
  yy_state_type yy_next_state ;
  int tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 1539
  yyg = (struct yyguts_t *)yyscanner;
#line 1545
  yyg->yylval_r = yylval_param;
#line 1547
  if (! yyg->yy_init) {
#line 1549
    yyg->yy_init = 1;
#line 1556
    if (! yyg->yy_state_buf) {
      {
#line 1557
      tmp = bsdlalloc((yy_size_t )(16386UL * sizeof(yy_state_type )), yyscanner);
#line 1557
      yyg->yy_state_buf = (yy_state_type *)tmp;
      }
    }
#line 1558
    if (! yyg->yy_state_buf) {
      {
#line 1559
      yy_fatal_error___0("out of dynamic memory in bsdllex()", yyscanner);
      }
    }
#line 1561
    if (! yyg->yy_start) {
#line 1562
      yyg->yy_start = 1;
    }
#line 1564
    if (! yyg->yyin_r) {
#line 1565
      yyg->yyin_r = stdin;
    }
#line 1567
    if (! yyg->yyout_r) {
#line 1568
      yyg->yyout_r = stdout;
    }
#line 1570
    if (yyg->yy_buffer_stack) {
#line 1570
      tmp___0 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
    } else {
#line 1570
      tmp___0 = (YY_BUFFER_STATE )((void *)0);
    }
#line 1570
    if (! tmp___0) {
      {
#line 1571
      bsdlensure_buffer_stack(yyscanner);
#line 1572
      *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top) = bsdl_create_buffer(yyg->yyin_r,
                                                                              16384,
                                                                              yyscanner);
      }
    }
    {
#line 1576
    bsdl_load_buffer_state(yyscanner);
    }
  }
  {
#line 1579
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1581
    yy_cp = yyg->yy_c_buf_p;
#line 1584
    *yy_cp = yyg->yy_hold_char;
#line 1589
    yy_bp = yy_cp;
#line 1591
    yy_current_state = yyg->yy_start;
#line 1593
    yyg->yy_state_ptr = yyg->yy_state_buf;
#line 1594
    tmp___1 = yyg->yy_state_ptr;
#line 1594
    (yyg->yy_state_ptr) ++;
#line 1594
    *tmp___1 = yy_current_state;
    yy_match: 
    {
#line 1597
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1599
      yy_c = (YY_CHAR )yy_ec___0[(unsigned int )((unsigned char )*yy_cp)];
      {
#line 1600
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1600
        if (! ((int const   )yy_chk___0[(int const   )yy_base___0[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1600
          goto while_break___1;
        }
#line 1602
        yy_current_state = (int )yy_def___0[yy_current_state];
#line 1603
        if (yy_current_state >= 709) {
#line 1604
          yy_c = (YY_CHAR )yy_meta___0[(unsigned int )yy_c];
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1606
      yy_current_state = (yy_state_type )yy_nxt___0[(unsigned int )yy_base___0[yy_current_state] + (unsigned int )yy_c];
#line 1607
      tmp___2 = yyg->yy_state_ptr;
#line 1607
      (yyg->yy_state_ptr) ++;
#line 1607
      *tmp___2 = yy_current_state;
#line 1608
      yy_cp ++;
#line 1597
      if (! ((int const   )yy_base___0[yy_current_state] != 1591)) {
#line 1597
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    yy_find_action: 
#line 1613
    (yyg->yy_state_ptr) --;
#line 1613
    yy_current_state = *(yyg->yy_state_ptr);
#line 1614
    yyg->yy_lp = (int )yy_accept___0[yy_current_state];
    find_rule: 
    {
#line 1616
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1618
      if (yyg->yy_lp) {
#line 1618
        if (yyg->yy_lp < (int )yy_accept___0[yy_current_state + 1]) {
#line 1620
          yy_act = (int )yy_acclist___0[yyg->yy_lp];
#line 1622
          yyg->yy_full_match = yy_cp;
#line 1623
          goto while_break___2;
        }
      }
#line 1626
      yy_cp --;
#line 1627
      (yyg->yy_state_ptr) --;
#line 1627
      yy_current_state = *(yyg->yy_state_ptr);
#line 1628
      yyg->yy_lp = (int )yy_accept___0[yy_current_state];
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1631
    yyg->yytext_r = yy_bp;
#line 1631
    yyg->yyleng_r = (int )((size_t )(yy_cp - yy_bp));
#line 1631
    yyg->yy_hold_char = *yy_cp;
#line 1631
    *yy_cp = (char )'\000';
#line 1631
    yyg->yy_c_buf_p = yy_cp;
    do_action: 
    {
#line 1637
    if (yy_act == 1) {
#line 1637
      goto case_1;
    }
#line 277
    if (yy_act == 2) {
#line 277 "bsdl_flex.l"
      goto case_2;
    }
#line 278
    if (yy_act == 3) {
#line 278
      goto case_3;
    }
#line 279
    if (yy_act == 4) {
#line 279
      goto case_4;
    }
#line 280
    if (yy_act == 5) {
#line 280
      goto case_5;
    }
#line 281
    if (yy_act == 6) {
#line 281
      goto case_6;
    }
#line 282
    if (yy_act == 7) {
#line 282
      goto case_7;
    }
#line 283
    if (yy_act == 8) {
#line 283
      goto case_8;
    }
#line 284
    if (yy_act == 9) {
#line 284
      goto case_9;
    }
#line 285
    if (yy_act == 10) {
#line 285
      goto case_10;
    }
#line 286
    if (yy_act == 11) {
#line 286
      goto case_11;
    }
#line 288
    if (yy_act == 12) {
#line 288
      goto case_12;
    }
#line 290
    if (yy_act == 13) {
#line 290
      goto case_13;
    }
#line 291
    if (yy_act == 14) {
#line 291
      goto case_14;
    }
#line 292
    if (yy_act == 15) {
#line 292
      goto case_15;
    }
#line 293
    if (yy_act == 16) {
#line 293
      goto case_16;
    }
#line 295
    if (yy_act == 17) {
#line 295
      goto case_17;
    }
#line 296
    if (yy_act == 18) {
#line 296
      goto case_18;
    }
#line 298
    if (yy_act == 19) {
#line 298
      goto case_19;
    }
#line 299
    if (yy_act == 20) {
#line 299
      goto case_20;
    }
#line 300
    if (yy_act == 21) {
#line 300
      goto case_21;
    }
#line 301
    if (yy_act == 22) {
#line 301
      goto case_22;
    }
#line 302
    if (yy_act == 23) {
#line 302
      goto case_23;
    }
#line 303
    if (yy_act == 24) {
#line 303
      goto case_24;
    }
#line 304
    if (yy_act == 25) {
#line 304
      goto case_25;
    }
#line 305
    if (yy_act == 26) {
#line 305
      goto case_26;
    }
#line 306
    if (yy_act == 27) {
#line 306
      goto case_27;
    }
#line 307
    if (yy_act == 28) {
#line 307
      goto case_28;
    }
#line 308
    if (yy_act == 29) {
#line 308
      goto case_29;
    }
#line 309
    if (yy_act == 30) {
#line 309
      goto case_30;
    }
#line 310
    if (yy_act == 31) {
#line 310
      goto case_31;
    }
#line 311
    if (yy_act == 32) {
#line 311
      goto case_32;
    }
#line 312
    if (yy_act == 33) {
#line 312
      goto case_33;
    }
#line 313
    if (yy_act == 34) {
#line 313
      goto case_34;
    }
#line 314
    if (yy_act == 35) {
#line 314
      goto case_35;
    }
#line 315
    if (yy_act == 36) {
#line 315
      goto case_36;
    }
#line 316
    if (yy_act == 37) {
#line 316
      goto case_37;
    }
#line 317
    if (yy_act == 38) {
#line 317
      goto case_38;
    }
#line 318
    if (yy_act == 39) {
#line 318
      goto case_39;
    }
#line 319
    if (yy_act == 40) {
#line 319
      goto case_40;
    }
#line 320
    if (yy_act == 41) {
#line 320
      goto case_41;
    }
#line 321
    if (yy_act == 42) {
#line 321
      goto case_42;
    }
#line 322
    if (yy_act == 43) {
#line 322
      goto case_43;
    }
#line 323
    if (yy_act == 44) {
#line 323
      goto case_44;
    }
#line 324
    if (yy_act == 45) {
#line 324
      goto case_45;
    }
#line 325
    if (yy_act == 46) {
#line 325
      goto case_46;
    }
#line 326
    if (yy_act == 47) {
#line 326
      goto case_47;
    }
#line 327
    if (yy_act == 48) {
#line 327
      goto case_48;
    }
#line 328
    if (yy_act == 49) {
#line 328
      goto case_49;
    }
#line 329
    if (yy_act == 50) {
#line 329
      goto case_50;
    }
#line 330
    if (yy_act == 51) {
#line 330
      goto case_51;
    }
#line 331
    if (yy_act == 52) {
#line 331
      goto case_52;
    }
#line 332
    if (yy_act == 53) {
#line 332
      goto case_53;
    }
#line 333
    if (yy_act == 54) {
#line 333
      goto case_54;
    }
#line 334
    if (yy_act == 55) {
#line 334
      goto case_55;
    }
#line 335
    if (yy_act == 56) {
#line 335
      goto case_56;
    }
#line 336
    if (yy_act == 57) {
#line 336
      goto case_57;
    }
#line 337
    if (yy_act == 58) {
#line 337
      goto case_58;
    }
#line 338
    if (yy_act == 59) {
#line 338
      goto case_59;
    }
#line 339
    if (yy_act == 60) {
#line 339
      goto case_60;
    }
#line 340
    if (yy_act == 61) {
#line 340
      goto case_61;
    }
#line 341
    if (yy_act == 62) {
#line 341
      goto case_62;
    }
#line 342
    if (yy_act == 63) {
#line 342
      goto case_63;
    }
#line 343
    if (yy_act == 64) {
#line 343
      goto case_64;
    }
#line 344
    if (yy_act == 65) {
#line 344
      goto case_65;
    }
#line 345
    if (yy_act == 66) {
#line 345
      goto case_66;
    }
#line 346
    if (yy_act == 67) {
#line 346
      goto case_67;
    }
#line 347
    if (yy_act == 68) {
#line 347
      goto case_68;
    }
#line 348
    if (yy_act == 69) {
#line 348
      goto case_69;
    }
#line 349
    if (yy_act == 70) {
#line 349
      goto case_70;
    }
#line 350
    if (yy_act == 71) {
#line 350
      goto case_71;
    }
#line 351
    if (yy_act == 72) {
#line 351
      goto case_72;
    }
#line 352
    if (yy_act == 73) {
#line 352
      goto case_73;
    }
#line 353
    if (yy_act == 74) {
#line 353
      goto case_74;
    }
#line 354
    if (yy_act == 75) {
#line 354
      goto case_75;
    }
#line 355
    if (yy_act == 76) {
#line 355
      goto case_76;
    }
#line 356
    if (yy_act == 77) {
#line 356
      goto case_77;
    }
#line 357
    if (yy_act == 78) {
#line 357
      goto case_78;
    }
#line 358
    if (yy_act == 79) {
#line 358
      goto case_79;
    }
#line 359
    if (yy_act == 80) {
#line 359
      goto case_80;
    }
#line 360
    if (yy_act == 81) {
#line 360
      goto case_81;
    }
#line 361
    if (yy_act == 82) {
#line 361
      goto case_82;
    }
#line 362
    if (yy_act == 83) {
#line 362
      goto case_83;
    }
#line 363
    if (yy_act == 84) {
#line 363
      goto case_84;
    }
#line 364
    if (yy_act == 85) {
#line 364
      goto case_85;
    }
#line 365
    if (yy_act == 86) {
#line 365
      goto case_86;
    }
#line 366
    if (yy_act == 87) {
#line 366
      goto case_87;
    }
#line 367
    if (yy_act == 88) {
#line 367
      goto case_88;
    }
#line 368
    if (yy_act == 89) {
#line 368
      goto case_89;
    }
#line 369
    if (yy_act == 90) {
#line 369
      goto case_90;
    }
#line 370
    if (yy_act == 91) {
#line 370
      goto case_91;
    }
#line 371
    if (yy_act == 92) {
#line 371
      goto case_92;
    }
#line 372
    if (yy_act == 93) {
#line 372
      goto case_93;
    }
#line 373
    if (yy_act == 94) {
#line 373
      goto case_94;
    }
#line 374
    if (yy_act == 95) {
#line 374
      goto case_95;
    }
#line 375
    if (yy_act == 96) {
#line 375
      goto case_96;
    }
#line 376
    if (yy_act == 97) {
#line 376
      goto case_97;
    }
#line 377
    if (yy_act == 98) {
#line 377
      goto case_98;
    }
#line 378
    if (yy_act == 99) {
#line 378
      goto case_99;
    }
#line 379
    if (yy_act == 100) {
#line 379
      goto case_100;
    }
#line 380
    if (yy_act == 101) {
#line 380
      goto case_101;
    }
#line 381
    if (yy_act == 102) {
#line 381
      goto case_102;
    }
#line 382
    if (yy_act == 103) {
#line 382
      goto case_103;
    }
#line 383
    if (yy_act == 104) {
#line 383
      goto case_104;
    }
#line 384
    if (yy_act == 105) {
#line 384
      goto case_105;
    }
#line 385
    if (yy_act == 106) {
#line 385
      goto case_106;
    }
#line 386
    if (yy_act == 107) {
#line 386
      goto case_107;
    }
#line 387
    if (yy_act == 108) {
#line 387
      goto case_108;
    }
#line 388
    if (yy_act == 109) {
#line 388
      goto case_109;
    }
#line 391
    if (yy_act == 110) {
#line 391
      goto case_110;
    }
#line 394
    if (yy_act == 111) {
#line 394
      goto case_111;
    }
#line 396
    if (yy_act == 112) {
#line 396
      goto case_112;
    }
#line 399
    if (yy_act == 113) {
#line 399
      goto case_113;
    }
#line 402
    if (yy_act == 114) {
#line 402
      goto case_114;
    }
#line 404
    if (yy_act == 115) {
#line 404
      goto case_115;
    }
#line 416
    if (yy_act == 123) {
#line 416
      goto case_123;
    }
#line 416
    if (yy_act == 122) {
#line 416
      goto case_123;
    }
#line 416
    if (yy_act == 121) {
#line 416
      goto case_123;
    }
#line 416
    if (yy_act == 120) {
#line 416
      goto case_123;
    }
#line 416
    if (yy_act == 119) {
#line 416
      goto case_123;
    }
#line 416
    if (yy_act == 118) {
#line 416
      goto case_123;
    }
#line 416
    if (yy_act == 116) {
#line 416
      goto case_116;
    }
#line 2253
    if (yy_act == 117) {
#line 2253 "bsdl_flex.c"
      goto case_117;
    }
#line 2375
    goto switch_default;
    case_1: /* CIL Label */ 
#line 275 "bsdl_flex.l"
    (yyg->yyextra_r)->Base = 1;
#line 275
    return (258);
#line 276
    goto switch_break;
    case_2: /* CIL Label */ 
#line 276
    return (259);
#line 277
    goto switch_break;
    case_3: /* CIL Label */ 
#line 277
    return (260);
#line 278
    goto switch_break;
    case_4: /* CIL Label */ 
#line 278
    return (261);
#line 279
    goto switch_break;
    case_5: /* CIL Label */ 
#line 279
    return (262);
#line 280
    goto switch_break;
    case_6: /* CIL Label */ 
#line 280
    return (263);
#line 281
    goto switch_break;
    case_7: /* CIL Label */ 
#line 281
    return (266);
#line 282
    goto switch_break;
    case_8: /* CIL Label */ 
#line 282
    return (264);
#line 283
    goto switch_break;
    case_9: /* CIL Label */ 
#line 283
    return (265);
#line 284
    goto switch_break;
    case_10: /* CIL Label */ 
#line 284
    (yyg->yyextra_r)->Base = 1;
#line 284
    return (267);
#line 285
    goto switch_break;
    case_11: /* CIL Label */ 
#line 285
    (yyg->yyextra_r)->Base = 0;
#line 286
    return (268);
#line 287
    goto switch_break;
    case_12: /* CIL Label */ 
#line 287
    (yyg->yyextra_r)->Base = 2;
#line 288
    return (269);
#line 289
    goto switch_break;
    case_13: /* CIL Label */ 
#line 289
    return (270);
#line 290
    goto switch_break;
    case_14: /* CIL Label */ 
#line 290
    return (271);
#line 291
    goto switch_break;
    case_15: /* CIL Label */ 
#line 291
    return (272);
#line 292
    goto switch_break;
    case_16: /* CIL Label */ 
#line 292
    yyg->yy_start = 7;
#line 292
    (yyg->yyextra_r)->Base = 1;
#line 293
    return (273);
#line 294
    goto switch_break;
    case_17: /* CIL Label */ 
#line 294
    return (274);
#line 295
    goto switch_break;
    case_18: /* CIL Label */ 
#line 295
    yyg->yy_start = 5;
#line 295
    (yyg->yyextra_r)->Base = 1;
#line 296
    return (275);
#line 297
    goto switch_break;
    case_19: /* CIL Label */ 
#line 297
    (yyg->yyextra_r)->Base = 2;
#line 297
    return (276);
#line 298
    goto switch_break;
    case_20: /* CIL Label */ 
#line 298
    (yyg->yyextra_r)->Base = 2;
#line 298
    return (277);
#line 299
    goto switch_break;
    case_21: /* CIL Label */ 
#line 299
    (yyg->yyextra_r)->Base = 1;
#line 299
    return (307);
#line 300
    goto switch_break;
    case_22: /* CIL Label */ 
#line 300
    return (319);
#line 301
    goto switch_break;
    case_23: /* CIL Label */ 
#line 301
    return (320);
#line 302
    goto switch_break;
    case_24: /* CIL Label */ 
#line 302
    return (321);
#line 303
    goto switch_break;
    case_25: /* CIL Label */ 
#line 303
    return (322);
#line 304
    goto switch_break;
    case_26: /* CIL Label */ 
#line 304
    (yyg->yyextra_r)->Base = 1;
#line 304
    return (323);
#line 305
    goto switch_break;
    case_27: /* CIL Label */ 
#line 305
    return (324);
#line 306
    goto switch_break;
    case_28: /* CIL Label */ 
#line 306
    return (325);
#line 307
    goto switch_break;
    case_29: /* CIL Label */ 
#line 307
    yyg->yy_start = 11;
#line 307
    (yyg->yyextra_r)->Base = 1;
#line 307
    return (326);
#line 308
    goto switch_break;
    case_30: /* CIL Label */ 
#line 308
    (yyg->yyextra_r)->Base = 1;
#line 308
    return (327);
#line 309
    goto switch_break;
    case_31: /* CIL Label */ 
#line 309
    (yyg->yyextra_r)->Base = 1;
#line 309
    return (328);
#line 310
    goto switch_break;
    case_32: /* CIL Label */ 
#line 310
    return (329);
#line 311
    goto switch_break;
    case_33: /* CIL Label */ 
#line 311
    (yyg->yyextra_r)->Base = 2;
#line 311
    return (330);
#line 312
    goto switch_break;
    case_34: /* CIL Label */ 
#line 312
    (yyg->yyextra_r)->Base = 1;
#line 312
    return (331);
#line 313
    goto switch_break;
    case_35: /* CIL Label */ 
#line 313
    (yyg->yyextra_r)->Base = 1;
#line 313
    return (332);
#line 314
    goto switch_break;
    case_36: /* CIL Label */ 
#line 314
    (yyg->yyextra_r)->Base = 1;
#line 314
    return (333);
#line 315
    goto switch_break;
    case_37: /* CIL Label */ 
#line 315
    (yyg->yyextra_r)->Base = 1;
#line 315
    return (334);
#line 316
    goto switch_break;
    case_38: /* CIL Label */ 
#line 316
    (yyg->yyextra_r)->Base = 1;
#line 316
    return (335);
#line 317
    goto switch_break;
    case_39: /* CIL Label */ 
#line 317
    (yyg->yyextra_r)->Base = 1;
#line 317
    return (336);
#line 318
    goto switch_break;
    case_40: /* CIL Label */ 
#line 318
    return (337);
#line 319
    goto switch_break;
    case_41: /* CIL Label */ 
#line 319
    return (338);
#line 320
    goto switch_break;
    case_42: /* CIL Label */ 
#line 320
    return (339);
#line 321
    goto switch_break;
    case_43: /* CIL Label */ 
#line 321
    return (340);
#line 322
    goto switch_break;
    case_44: /* CIL Label */ 
#line 322
    return (315);
#line 323
    goto switch_break;
    case_45: /* CIL Label */ 
#line 323
    return (341);
#line 324
    goto switch_break;
    case_46: /* CIL Label */ 
#line 324
    (yyg->yyextra_r)->Base = 1;
#line 324
    return (342);
#line 325
    goto switch_break;
    case_47: /* CIL Label */ 
#line 325
    return (343);
#line 326
    goto switch_break;
    case_48: /* CIL Label */ 
#line 326
    return (344);
#line 327
    goto switch_break;
    case_49: /* CIL Label */ 
#line 327
    return (350);
#line 328
    goto switch_break;
    case_50: /* CIL Label */ 
#line 328
    return (345);
#line 329
    goto switch_break;
    case_51: /* CIL Label */ 
#line 329
    return (346);
#line 330
    goto switch_break;
    case_52: /* CIL Label */ 
#line 330
    return (360);
#line 331
    goto switch_break;
    case_53: /* CIL Label */ 
#line 331
    return (361);
#line 332
    goto switch_break;
    case_54: /* CIL Label */ 
#line 332
    return (347);
#line 333
    goto switch_break;
    case_55: /* CIL Label */ 
#line 333
    return (348);
#line 334
    goto switch_break;
    case_56: /* CIL Label */ 
#line 334
    return (352);
#line 335
    goto switch_break;
    case_57: /* CIL Label */ 
#line 335
    return (353);
#line 336
    goto switch_break;
    case_58: /* CIL Label */ 
#line 336
    return (354);
#line 337
    goto switch_break;
    case_59: /* CIL Label */ 
#line 337
    return (355);
#line 338
    goto switch_break;
    case_60: /* CIL Label */ 
#line 338
    return (356);
#line 339
    goto switch_break;
    case_61: /* CIL Label */ 
#line 339
    return (359);
#line 340
    goto switch_break;
    case_62: /* CIL Label */ 
#line 340
    return (357);
#line 341
    goto switch_break;
    case_63: /* CIL Label */ 
#line 341
    return (358);
#line 342
    goto switch_break;
    case_64: /* CIL Label */ 
#line 342
    (yyg->yyextra_r)->Base = 1;
#line 342
    return (362);
#line 343
    goto switch_break;
    case_65: /* CIL Label */ 
#line 343
    (yyg->yyextra_r)->Base = 1;
#line 343
    return (363);
#line 344
    goto switch_break;
    case_66: /* CIL Label */ 
#line 344
    return (364);
#line 345
    goto switch_break;
    case_67: /* CIL Label */ 
#line 345
    return (365);
#line 346
    goto switch_break;
    case_68: /* CIL Label */ 
#line 346
    return (366);
#line 347
    goto switch_break;
    case_69: /* CIL Label */ 
#line 347
    return (367);
#line 348
    goto switch_break;
    case_70: /* CIL Label */ 
#line 348
    return (309);
#line 349
    goto switch_break;
    case_71: /* CIL Label */ 
#line 349
    return (278);
#line 350
    goto switch_break;
    case_72: /* CIL Label */ 
#line 350
    return (310);
#line 351
    goto switch_break;
    case_73: /* CIL Label */ 
#line 351
    return (311);
#line 352
    goto switch_break;
    case_74: /* CIL Label */ 
#line 352
    return (312);
#line 353
    goto switch_break;
    case_75: /* CIL Label */ 
#line 353
    return (313);
#line 354
    goto switch_break;
    case_76: /* CIL Label */ 
#line 354
    return (314);
#line 355
    goto switch_break;
    case_77: /* CIL Label */ 
#line 355
    return (315);
#line 356
    goto switch_break;
    case_78: /* CIL Label */ 
#line 356
    return (316);
#line 357
    goto switch_break;
    case_79: /* CIL Label */ 
#line 357
    return (317);
#line 358
    goto switch_break;
    case_80: /* CIL Label */ 
#line 358
    return (318);
#line 359
    goto switch_break;
    case_81: /* CIL Label */ 
#line 359
    return (279);
#line 360
    goto switch_break;
    case_82: /* CIL Label */ 
#line 360
    return (280);
#line 361
    goto switch_break;
    case_83: /* CIL Label */ 
#line 361
    return (281);
#line 362
    goto switch_break;
    case_84: /* CIL Label */ 
#line 362
    return (282);
#line 363
    goto switch_break;
    case_85: /* CIL Label */ 
#line 363
    return (284);
#line 364
    goto switch_break;
    case_86: /* CIL Label */ 
#line 364
    return (283);
#line 365
    goto switch_break;
    case_87: /* CIL Label */ 
#line 365
    return (285);
#line 366
    goto switch_break;
    case_88: /* CIL Label */ 
#line 366
    return (286);
#line 367
    goto switch_break;
    case_89: /* CIL Label */ 
#line 367
    return (308);
#line 368
    goto switch_break;
    case_90: /* CIL Label */ 
#line 368
    return (287);
#line 369
    goto switch_break;
    case_91: /* CIL Label */ 
#line 369
    return (288);
#line 370
    goto switch_break;
    case_92: /* CIL Label */ 
#line 370
    return (289);
#line 371
    goto switch_break;
    case_93: /* CIL Label */ 
#line 371
    return (290);
#line 372
    goto switch_break;
    case_94: /* CIL Label */ 
#line 372
    return (291);
#line 373
    goto switch_break;
    case_95: /* CIL Label */ 
#line 373
    return (292);
#line 374
    goto switch_break;
    case_96: /* CIL Label */ 
#line 374
    return (294);
#line 375
    goto switch_break;
    case_97: /* CIL Label */ 
#line 375
    return (295);
#line 376
    goto switch_break;
    case_98: /* CIL Label */ 
#line 376
    return (296);
#line 377
    goto switch_break;
    case_99: /* CIL Label */ 
#line 377
    ((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_bs_lineno) ++;
#line 378
    goto switch_break;
    case_100: /* CIL Label */ 
#line 378
    return (300);
#line 379
    goto switch_break;
    case_101: /* CIL Label */ 
#line 379
    return (301);
#line 380
    goto switch_break;
    case_102: /* CIL Label */ 
#line 380
    return (302);
#line 381
    goto switch_break;
    case_103: /* CIL Label */ 
#line 381
    return (303);
#line 382
    goto switch_break;
    case_104: /* CIL Label */ 
#line 382
    return (304);
#line 383
    goto switch_break;
    case_105: /* CIL Label */ 
#line 383
    return (305);
#line 384
    goto switch_break;
    case_106: /* CIL Label */ 
#line 384
    return (306);
#line 385
    goto switch_break;
    case_107: /* CIL Label */ ;
#line 386
    goto switch_break;
    case_108: /* CIL Label */ ;
#line 387
    goto switch_break;
    case_109: /* CIL Label */ 
#line 387
    if ((yyg->yyextra_r)->Base != 2) {
#line 387
      *yy_cp = yyg->yy_hold_char;
#line 387
      yy_cp = yyg->yy_full_match;
#line 387
      (yyg->yy_lp) ++;
#line 387
      goto find_rule;
    }
    {
#line 388
    (yyg->yylval_r)->str = new_string___0(yyg->yyextra_r, (char const   *)yyg->yytext_r);
    }
#line 389
    return (299);
#line 390
    goto switch_break;
    case_110: /* CIL Label */ 
#line 390
    if ((yyg->yyextra_r)->Base != 3) {
#line 390
      *yy_cp = yyg->yy_hold_char;
#line 390
      yy_cp = yyg->yy_full_match;
#line 390
      (yyg->yy_lp) ++;
#line 390
      goto find_rule;
    }
    {
#line 391
    (yyg->yylval_r)->str = new_string___0(yyg->yyextra_r, (char const   *)yyg->yytext_r);
    }
#line 392
    return (349);
#line 393
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 393
    (yyg->yylval_r)->str = new_string___0(yyg->yyextra_r, (char const   *)yyg->yytext_r);
    }
#line 394
    return (293);
#line 395
    goto switch_break;
    case_112: /* CIL Label */ 
#line 395
    if ((yyg->yyextra_r)->Base != 0) {
#line 395
      *yy_cp = yyg->yy_hold_char;
#line 395
      yy_cp = yyg->yy_full_match;
#line 395
      (yyg->yy_lp) ++;
#line 395
      goto find_rule;
    }
    {
#line 396
    (yyg->yylval_r)->str = new_string___0(yyg->yyextra_r, (char const   *)yyg->yytext_r);
    }
#line 397
    return (298);
#line 398
    goto switch_break;
    case_113: /* CIL Label */ 
#line 398
    if ((yyg->yyextra_r)->Base != 1) {
#line 398
      *yy_cp = yyg->yy_hold_char;
#line 398
      yy_cp = yyg->yy_full_match;
#line 398
      (yyg->yy_lp) ++;
#line 398
      goto find_rule;
    }
    {
#line 399
    (yyg->yylval_r)->integer = atoi((char const   *)yyg->yytext_r);
    }
#line 400
    return (297);
#line 401
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 401
    (yyg->yylval_r)->str = new_string___0(yyg->yyextra_r, (char const   *)yyg->yytext_r);
    }
#line 402
    return (351);
#line 403
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 403
    bsdl_msg((yyg->yyextra_r)->proc_mode, 2, "Illegal character %c (/%03o) at line %d:\n",
             (int )*(yyg->yytext_r + (yyg->yyleng_r - 1)), (int )*(yyg->yytext_r + (yyg->yyleng_r - 1)),
             (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_bs_lineno);
#line 408
    ((yyg->yyextra_r)->Compile_Errors) ++;
    }
#line 409
    return (368);
#line 410
    goto switch_break;
    case_123: /* CIL Label */ 
    case_122: /* CIL Label */ 
    case_121: /* CIL Label */ 
    case_120: /* CIL Label */ 
    case_119: /* CIL Label */ 
    case_118: /* CIL Label */ 
    {
#line 411
    bsdlpop_buffer_state(yyscanner);
    }
#line 412
    if (yyg->yy_buffer_stack) {
#line 412
      tmp___3 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
    } else {
#line 412
      tmp___3 = (YY_BUFFER_STATE )((void *)0);
    }
#line 412
    if (! tmp___3) {
#line 413
      return (0);
    }
#line 415
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 415
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 415
      fwrite((void const   */* __restrict  */)yyg->yytext_r, (size_t )yyg->yyleng_r,
             (size_t )1, (FILE */* __restrict  */)yyg->yyout_r);
      }
#line 415
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 416
    goto switch_break;
    case_117: /* CIL Label */ 
#line 2256 "bsdl_flex.c"
    yy_amount_of_matched_text = (int )(yy_cp - yyg->yytext_r) - 1;
#line 2259
    *yy_cp = yyg->yy_hold_char;
#line 2262
    if ((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buffer_status == 0) {
#line 2273
      yyg->yy_n_chars = (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_n_chars;
#line 2274
      (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_input_file = yyg->yyin_r;
#line 2275
      (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buffer_status = 1;
    }
#line 2285
    if ((unsigned long )yyg->yy_c_buf_p <= (unsigned long )((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + yyg->yy_n_chars)) {
      {
#line 2289
      yyg->yy_c_buf_p = yyg->yytext_r + yy_amount_of_matched_text;
#line 2291
      yy_current_state = yy_get_previous_state___0(yyscanner);
#line 2302
      yy_next_state = yy_try_NUL_trans___0(yy_current_state, yyscanner);
#line 2304
      yy_bp = yyg->yytext_r + 0;
      }
#line 2306
      if (yy_next_state) {
#line 2309
        (yyg->yy_c_buf_p) ++;
#line 2309
        yy_cp = yyg->yy_c_buf_p;
#line 2310
        yy_current_state = yy_next_state;
#line 2311
        goto yy_match;
      } else {
#line 2316
        yy_cp = yyg->yy_c_buf_p;
#line 2317
        goto yy_find_action;
      }
    } else {
      {
#line 2321
      tmp___4 = yy_get_next_buffer___0(yyscanner);
      }
      {
#line 2323
      if (tmp___4 == 1) {
#line 2323
        goto case_1___0;
      }
#line 2352
      if (tmp___4 == 0) {
#line 2352
        goto case_0;
      }
#line 2362
      if (tmp___4 == 2) {
#line 2362
        goto case_2___0;
      }
#line 2321
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
      {
#line 2325
      yyg->yy_did_buffer_switch_on_eof = 0;
#line 2327
      tmp___5 = bsdlwrap(yyscanner);
      }
#line 2327
      if (tmp___5) {
#line 2338
        yyg->yy_c_buf_p = yyg->yytext_r + 0;
#line 2340
        yy_act = (117 + (yyg->yy_start - 1) / 2) + 1;
#line 2341
        goto do_action;
      } else
#line 2346
      if (! yyg->yy_did_buffer_switch_on_eof) {
        {
#line 2347
        bsdlrestart(yyg->yyin_r, yyscanner);
        }
      }
#line 2349
      goto switch_break___0;
      case_0: /* CIL Label */ 
      {
#line 2353
      yyg->yy_c_buf_p = yyg->yytext_r + yy_amount_of_matched_text;
#line 2356
      yy_current_state = yy_get_previous_state___0(yyscanner);
#line 2358
      yy_cp = yyg->yy_c_buf_p;
#line 2359
      yy_bp = yyg->yytext_r + 0;
      }
#line 2360
      goto yy_match;
      case_2___0: /* CIL Label */ 
      {
#line 2363
      yyg->yy_c_buf_p = (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + yyg->yy_n_chars;
#line 2366
      yy_current_state = yy_get_previous_state___0(yyscanner);
#line 2368
      yy_cp = yyg->yy_c_buf_p;
#line 2369
      yy_bp = yyg->yytext_r + 0;
      }
#line 2370
      goto yy_find_action;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 2372
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 2376
    yy_fatal_error___0("fatal flex scanner internal error--no action found", yyscanner);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 2389 "bsdl_flex.c"
static int yy_get_next_buffer___0(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  register char *dest ;
  register char *source ;
  register int number_to_move ;
  register int i ;
  int ret_val ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int num_to_read ;
  int c ;
  size_t n ;
  size_t tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  yy_size_t new_size ;
  void *tmp___10 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
#line 2391
  yyg = (struct yyguts_t *)yyscanner;
#line 2392
  dest = (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf;
#line 2393
  source = yyg->yytext_r;
#line 2397
  if ((unsigned long )yyg->yy_c_buf_p > (unsigned long )((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + (yyg->yy_n_chars + 1))) {
    {
#line 2398
    yy_fatal_error___0("fatal flex scanner internal error--end of buffer missed",
                       yyscanner);
    }
  }
#line 2401
  if ((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_fill_buffer == 0) {
#line 2403
    if (yyg->yy_c_buf_p - yyg->yytext_r == 1L) {
#line 2408
      return (1);
    } else {
#line 2416
      return (2);
    }
  }
#line 2423
  number_to_move = (int )(yyg->yy_c_buf_p - yyg->yytext_r) - 1;
#line 2425
  i = 0;
  {
#line 2425
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2425
    if (! (i < number_to_move)) {
#line 2425
      goto while_break;
    }
#line 2426
    tmp = dest;
#line 2426
    dest ++;
#line 2426
    tmp___0 = source;
#line 2426
    source ++;
#line 2426
    *tmp = *tmp___0;
#line 2425
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2428
  if ((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buffer_status == 2) {
#line 2432
    tmp___1 = 0;
#line 2432
    yyg->yy_n_chars = tmp___1;
#line 2432
    (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_n_chars = tmp___1;
  } else {
#line 2436
    num_to_read = (int )(((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buf_size - (yy_size_t )number_to_move) - 1U);
    {
#line 2439
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2439
      if (! (num_to_read <= 0)) {
#line 2439
        goto while_break___0;
      }
      {
#line 2442
      yy_fatal_error___0("input buffer overflow, can\'t enlarge buffer because scanner uses REJECT",
                         yyscanner);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2447
    if (num_to_read > 8192) {
#line 2448
      num_to_read = 8192;
    }
#line 2451
    if ((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_is_interactive) {
#line 2451
      c = '*';
#line 2451
      n = (size_t )0;
      {
#line 2451
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2451
        if (n < (size_t )num_to_read) {
          {
#line 2451
          c = _IO_getc(yyg->yyin_r);
          }
#line 2451
          if (c != -1) {
#line 2451
            if (! (c != 10)) {
#line 2451
              goto while_break___1;
            }
          } else {
#line 2451
            goto while_break___1;
          }
        } else {
#line 2451
          goto while_break___1;
        }
#line 2451
        *(((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + number_to_move) + n) = (char )c;
#line 2451
        n ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 2451
      if (c == 10) {
#line 2451
        tmp___2 = n;
#line 2451
        n ++;
#line 2451
        *(((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + number_to_move) + tmp___2) = (char )c;
      }
#line 2451
      if (c == -1) {
        {
#line 2451
        tmp___3 = ferror(yyg->yyin_r);
        }
#line 2451
        if (tmp___3) {
          {
#line 2451
          yy_fatal_error___0("input in flex scanner failed", yyscanner);
          }
        }
      }
#line 2451
      yyg->yy_n_chars = (int )n;
    } else {
      {
#line 2451
      tmp___4 = __errno_location();
#line 2451
      *tmp___4 = 0;
      }
      {
#line 2451
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 2451
        tmp___8 = fread((void */* __restrict  */)((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + number_to_move),
                        (size_t )1, (size_t )num_to_read, (FILE */* __restrict  */)yyg->yyin_r);
#line 2451
        tmp___7 = (int )tmp___8;
#line 2451
        yyg->yy_n_chars = tmp___7;
        }
#line 2451
        if (tmp___7 == 0) {
          {
#line 2451
          tmp___9 = ferror(yyg->yyin_r);
          }
#line 2451
          if (! tmp___9) {
#line 2451
            goto while_break___2;
          }
        } else {
#line 2451
          goto while_break___2;
        }
        {
#line 2451
        tmp___5 = __errno_location();
        }
#line 2451
        if (*tmp___5 != 4) {
          {
#line 2451
          yy_fatal_error___0("input in flex scanner failed", yyscanner);
          }
#line 2451
          goto while_break___2;
        }
        {
#line 2451
        tmp___6 = __errno_location();
#line 2451
        *tmp___6 = 0;
#line 2451
        clearerr(yyg->yyin_r);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 2454
    (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_n_chars = yyg->yy_n_chars;
  }
#line 2457
  if (yyg->yy_n_chars == 0) {
#line 2459
    if (number_to_move == 0) {
      {
#line 2461
      ret_val = 1;
#line 2462
      bsdlrestart(yyg->yyin_r, yyscanner);
      }
    } else {
#line 2467
      ret_val = 2;
#line 2468
      (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buffer_status = 2;
    }
  } else {
#line 2474
    ret_val = 0;
  }
#line 2476
  if ((yy_size_t )(yyg->yy_n_chars + number_to_move) > (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buf_size) {
    {
#line 2478
    new_size = (yy_size_t )((yyg->yy_n_chars + number_to_move) + (yyg->yy_n_chars >> 1));
#line 2479
    tmp___10 = bsdlrealloc((void *)(*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf,
                           new_size, yyscanner);
#line 2479
    (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf = (char *)tmp___10;
    }
#line 2480
    if (! (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf) {
      {
#line 2481
      yy_fatal_error___0("out of dynamic memory in yy_get_next_buffer()", yyscanner);
      }
    }
  }
#line 2484
  yyg->yy_n_chars += number_to_move;
#line 2485
  *((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + yyg->yy_n_chars) = (char)0;
#line 2486
  *((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + (yyg->yy_n_chars + 1)) = (char)0;
#line 2488
  yyg->yytext_r = (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + 0;
#line 2490
  return (ret_val);
}
}
#line 2495 "bsdl_flex.c"
static yy_state_type yy_get_previous_state___0(yyscan_t yyscanner ) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  struct yyguts_t *yyg ;
  yy_state_type *tmp ;
  register YY_CHAR yy_c ;
  flex_int32_t tmp___0 ;
  yy_state_type *tmp___1 ;

  {
#line 2499
  yyg = (struct yyguts_t *)yyscanner;
#line 2501
  yy_current_state = yyg->yy_start;
#line 2503
  yyg->yy_state_ptr = yyg->yy_state_buf;
#line 2504
  tmp = yyg->yy_state_ptr;
#line 2504
  (yyg->yy_state_ptr) ++;
#line 2504
  *tmp = yy_current_state;
#line 2506
  yy_cp = yyg->yytext_r + 0;
  {
#line 2506
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2506
    if (! ((unsigned long )yy_cp < (unsigned long )yyg->yy_c_buf_p)) {
#line 2506
      goto while_break;
    }
#line 2508
    if (*yy_cp) {
#line 2508
      tmp___0 = yy_ec___0[(unsigned int )((unsigned char )*yy_cp)];
    } else {
#line 2508
      tmp___0 = (flex_int32_t const   )1;
    }
#line 2508
    yy_c = (YY_CHAR )tmp___0;
    {
#line 2509
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2509
      if (! ((int const   )yy_chk___0[(int const   )yy_base___0[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 2509
        goto while_break___0;
      }
#line 2511
      yy_current_state = (int )yy_def___0[yy_current_state];
#line 2512
      if (yy_current_state >= 709) {
#line 2513
        yy_c = (YY_CHAR )yy_meta___0[(unsigned int )yy_c];
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2515
    yy_current_state = (yy_state_type )yy_nxt___0[(unsigned int )yy_base___0[yy_current_state] + (unsigned int )yy_c];
#line 2516
    tmp___1 = yyg->yy_state_ptr;
#line 2516
    (yyg->yy_state_ptr) ++;
#line 2516
    *tmp___1 = yy_current_state;
#line 2506
    yy_cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2519
  return (yy_current_state);
}
}
#line 2527 "bsdl_flex.c"
static yy_state_type yy_try_NUL_trans___0(yy_state_type yy_current_state , yyscan_t yyscanner ) 
{ 
  register int yy_is_jam ;
  struct yyguts_t *yyg ;
  register YY_CHAR yy_c ;
  yy_state_type *tmp ;
  int tmp___0 ;

  {
#line 2530
  yyg = (struct yyguts_t *)yyscanner;
#line 2532
  yy_c = (YY_CHAR )1;
  {
#line 2533
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2533
    if (! ((int const   )yy_chk___0[(int const   )yy_base___0[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 2533
      goto while_break;
    }
#line 2535
    yy_current_state = (int )yy_def___0[yy_current_state];
#line 2536
    if (yy_current_state >= 709) {
#line 2537
      yy_c = (YY_CHAR )yy_meta___0[(unsigned int )yy_c];
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2539
  yy_current_state = (yy_state_type )yy_nxt___0[(unsigned int )yy_base___0[yy_current_state] + (unsigned int )yy_c];
#line 2540
  yy_is_jam = yy_current_state == 708;
#line 2541
  if (! yy_is_jam) {
#line 2542
    tmp = yyg->yy_state_ptr;
#line 2542
    (yyg->yy_state_ptr) ++;
#line 2542
    *tmp = yy_current_state;
  }
#line 2544
  if (yy_is_jam) {
#line 2544
    tmp___0 = 0;
  } else {
#line 2544
    tmp___0 = yy_current_state;
  }
#line 2544
  return (tmp___0);
}
}
#line 2665 "bsdl_flex.c"
void bsdlrestart(FILE *input_file , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 2667
  yyg = (struct yyguts_t *)yyscanner;
#line 2669
  if (yyg->yy_buffer_stack) {
#line 2669
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2669
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2669
  if (! tmp) {
    {
#line 2670
    bsdlensure_buffer_stack(yyscanner);
#line 2671
    *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top) = bsdl_create_buffer(yyg->yyin_r,
                                                                            16384,
                                                                            yyscanner);
    }
  }
#line 2675
  if (yyg->yy_buffer_stack) {
#line 2675
    tmp___0 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2675
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 2675
  bsdl_init_buffer(tmp___0, input_file, yyscanner);
#line 2676
  bsdl_load_buffer_state(yyscanner);
  }
#line 2677
  return;
}
}
#line 2683 "bsdl_flex.c"
void bsdl_switch_to_buffer(YY_BUFFER_STATE new_buffer , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 2685
  yyg = (struct yyguts_t *)yyscanner;
#line 2692
  bsdlensure_buffer_stack(yyscanner);
  }
#line 2693
  if (yyg->yy_buffer_stack) {
#line 2693
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2693
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2693
  if ((unsigned long )tmp == (unsigned long )new_buffer) {
#line 2694
    return;
  }
#line 2696
  if (yyg->yy_buffer_stack) {
#line 2696
    tmp___0 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2696
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 2696
  if (tmp___0) {
#line 2699
    *(yyg->yy_c_buf_p) = yyg->yy_hold_char;
#line 2700
    (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buf_pos = yyg->yy_c_buf_p;
#line 2701
    (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_n_chars = yyg->yy_n_chars;
  }
  {
#line 2704
  *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top) = new_buffer;
#line 2705
  bsdl_load_buffer_state(yyscanner);
#line 2712
  yyg->yy_did_buffer_switch_on_eof = 1;
  }
#line 2713
  return;
}
}
#line 2715 "bsdl_flex.c"
static void bsdl_load_buffer_state(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  char *tmp ;

  {
#line 2717
  yyg = (struct yyguts_t *)yyscanner;
#line 2718
  yyg->yy_n_chars = (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_n_chars;
#line 2719
  tmp = (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buf_pos;
#line 2719
  yyg->yy_c_buf_p = tmp;
#line 2719
  yyg->yytext_r = tmp;
#line 2720
  yyg->yyin_r = (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_input_file;
#line 2721
  yyg->yy_hold_char = *(yyg->yy_c_buf_p);
#line 2722
  return;
}
}
#line 2730 "bsdl_flex.c"
YY_BUFFER_STATE bsdl_create_buffer(FILE *file , int size , yyscan_t yyscanner ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  void *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 2734
  tmp = bsdlalloc((yy_size_t )sizeof(struct yy_buffer_state ), yyscanner);
#line 2734
  b = (YY_BUFFER_STATE )tmp;
  }
#line 2735
  if (! b) {
    {
#line 2736
    yy_fatal_error___0("out of dynamic memory in bsdl_create_buffer()", yyscanner);
    }
  }
  {
#line 2738
  b->yy_buf_size = (yy_size_t )size;
#line 2743
  tmp___0 = bsdlalloc(b->yy_buf_size + 2U, yyscanner);
#line 2743
  b->yy_ch_buf = (char *)tmp___0;
  }
#line 2744
  if (! b->yy_ch_buf) {
    {
#line 2745
    yy_fatal_error___0("out of dynamic memory in bsdl_create_buffer()", yyscanner);
    }
  }
  {
#line 2747
  b->yy_is_our_buffer = 1;
#line 2749
  bsdl_init_buffer(b, file, yyscanner);
  }
#line 2751
  return (b);
}
}
#line 2758 "bsdl_flex.c"
void bsdl_delete_buffer(YY_BUFFER_STATE b , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;

  {
#line 2760
  yyg = (struct yyguts_t *)yyscanner;
#line 2762
  if (! b) {
#line 2763
    return;
  }
#line 2765
  if (yyg->yy_buffer_stack) {
#line 2765
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2765
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2765
  if ((unsigned long )b == (unsigned long )tmp) {
#line 2766
    *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top) = (YY_BUFFER_STATE )0;
  }
#line 2768
  if (b->yy_is_our_buffer) {
    {
#line 2769
    bsdlfree((void *)b->yy_ch_buf, yyscanner);
    }
  }
  {
#line 2771
  bsdlfree((void *)b, yyscanner);
  }
#line 2772
  return;
}
}
#line 2782 "bsdl_flex.c"
static void bsdl_init_buffer(YY_BUFFER_STATE b , FILE *file , yyscan_t yyscanner ) 
{ 
  int oerrno ;
  int *tmp ;
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 2785
  tmp = __errno_location();
#line 2785
  oerrno = *tmp;
#line 2786
  yyg = (struct yyguts_t *)yyscanner;
#line 2788
  bsdl_flush_buffer(b, yyscanner);
#line 2790
  b->yy_input_file = file;
#line 2791
  b->yy_fill_buffer = 1;
  }
#line 2797
  if (yyg->yy_buffer_stack) {
#line 2797
    tmp___0 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2797
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 2797
  if ((unsigned long )b != (unsigned long )tmp___0) {
#line 2798
    b->yy_bs_lineno = 1;
#line 2799
    b->yy_bs_column = 0;
  }
#line 2802
  if (file) {
    {
#line 2802
    tmp___1 = fileno(file);
#line 2802
    tmp___2 = isatty(tmp___1);
#line 2802
    b->yy_is_interactive = tmp___2 > 0;
    }
  } else {
#line 2802
    b->yy_is_interactive = 0;
  }
  {
#line 2804
  tmp___3 = __errno_location();
#line 2804
  *tmp___3 = oerrno;
  }
#line 2805
  return;
}
}
#line 2811 "bsdl_flex.c"
void bsdl_flush_buffer(YY_BUFFER_STATE b , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;

  {
#line 2813
  yyg = (struct yyguts_t *)yyscanner;
#line 2814
  if (! b) {
#line 2815
    return;
  }
#line 2817
  b->yy_n_chars = 0;
#line 2823
  *(b->yy_ch_buf + 0) = (char)0;
#line 2824
  *(b->yy_ch_buf + 1) = (char)0;
#line 2826
  b->yy_buf_pos = b->yy_ch_buf + 0;
#line 2828
  b->yy_at_bol = 1;
#line 2829
  b->yy_buffer_status = 0;
#line 2831
  if (yyg->yy_buffer_stack) {
#line 2831
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2831
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2831
  if ((unsigned long )b == (unsigned long )tmp) {
    {
#line 2832
    bsdl_load_buffer_state(yyscanner);
    }
  }
#line 2833
  return;
}
}
#line 2841 "bsdl_flex.c"
void bsdlpush_buffer_state(YY_BUFFER_STATE new_buffer , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 2843
  yyg = (struct yyguts_t *)yyscanner;
#line 2844
  if ((unsigned long )new_buffer == (unsigned long )((void *)0)) {
#line 2845
    return;
  }
  {
#line 2847
  bsdlensure_buffer_stack(yyscanner);
  }
#line 2850
  if (yyg->yy_buffer_stack) {
#line 2850
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2850
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2850
  if (tmp) {
#line 2853
    *(yyg->yy_c_buf_p) = yyg->yy_hold_char;
#line 2854
    (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buf_pos = yyg->yy_c_buf_p;
#line 2855
    (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_n_chars = yyg->yy_n_chars;
  }
#line 2859
  if (yyg->yy_buffer_stack) {
#line 2859
    tmp___0 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2859
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 2859
  if (tmp___0) {
#line 2860
    (yyg->yy_buffer_stack_top) ++;
  }
  {
#line 2861
  *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top) = new_buffer;
#line 2864
  bsdl_load_buffer_state(yyscanner);
#line 2865
  yyg->yy_did_buffer_switch_on_eof = 1;
  }
#line 2866
  return;
}
}
#line 2872 "bsdl_flex.c"
void bsdlpop_buffer_state(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;
  YY_BUFFER_STATE tmp___1 ;

  {
#line 2874
  yyg = (struct yyguts_t *)yyscanner;
#line 2875
  if (yyg->yy_buffer_stack) {
#line 2875
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2875
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2875
  if (! tmp) {
#line 2876
    return;
  }
#line 2878
  if (yyg->yy_buffer_stack) {
#line 2878
    tmp___0 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2878
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 2878
  bsdl_delete_buffer(tmp___0, yyscanner);
#line 2879
  *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top) = (YY_BUFFER_STATE )((void *)0);
  }
#line 2880
  if (yyg->yy_buffer_stack_top > 0U) {
#line 2881
    (yyg->yy_buffer_stack_top) --;
  }
#line 2883
  if (yyg->yy_buffer_stack) {
#line 2883
    tmp___1 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2883
    tmp___1 = (YY_BUFFER_STATE )((void *)0);
  }
#line 2883
  if (tmp___1) {
    {
#line 2884
    bsdl_load_buffer_state(yyscanner);
#line 2885
    yyg->yy_did_buffer_switch_on_eof = 1;
    }
  }
#line 2887
  return;
}
}
#line 2892 "bsdl_flex.c"
static void bsdlensure_buffer_stack(yyscan_t yyscanner ) 
{ 
  int num_to_alloc ;
  struct yyguts_t *yyg ;
  void *tmp ;
  int grow_size ;
  void *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 2895
  yyg = (struct yyguts_t *)yyscanner;
#line 2897
  if (! yyg->yy_buffer_stack) {
    {
#line 2903
    num_to_alloc = 1;
#line 2904
    tmp = bsdlalloc((yy_size_t )((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *)),
                    yyscanner);
#line 2904
    yyg->yy_buffer_stack = (struct yy_buffer_state **)tmp;
    }
#line 2907
    if (! yyg->yy_buffer_stack) {
      {
#line 2908
      yy_fatal_error___0("out of dynamic memory in bsdlensure_buffer_stack()", yyscanner);
      }
    }
    {
#line 2910
    memset((void *)yyg->yy_buffer_stack, 0, (size_t )((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *)));
#line 2912
    yyg->yy_buffer_stack_max = (size_t )num_to_alloc;
#line 2913
    yyg->yy_buffer_stack_top = (size_t )0;
    }
#line 2914
    return;
  }
#line 2917
  if (yyg->yy_buffer_stack_top >= yyg->yy_buffer_stack_max - 1U) {
    {
#line 2920
    grow_size = 8;
#line 2922
    num_to_alloc = (int )(yyg->yy_buffer_stack_max + (size_t )grow_size);
#line 2923
    tmp___0 = bsdlrealloc((void *)yyg->yy_buffer_stack, (yy_size_t )((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *)),
                          yyscanner);
#line 2923
    yyg->yy_buffer_stack = (struct yy_buffer_state **)tmp___0;
    }
#line 2927
    if (! yyg->yy_buffer_stack) {
      {
#line 2928
      yy_fatal_error___0("out of dynamic memory in bsdlensure_buffer_stack()", yyscanner);
      }
    }
    {
#line 2931
    memset((void *)(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max), 0, (size_t )((unsigned long )grow_size * sizeof(struct yy_buffer_state *)));
#line 2932
    yyg->yy_buffer_stack_max = (size_t )num_to_alloc;
    }
  }
#line 2934
  return;
}
}
#line 2942 "bsdl_flex.c"
YY_BUFFER_STATE bsdl_scan_buffer(char *base , yy_size_t size , yyscan_t yyscanner ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  char *tmp___0 ;
  char *__cil_tmp7 ;

  {
#line 2946
  if (size < 2U) {
#line 2950
    return ((YY_BUFFER_STATE )0);
  } else
#line 2946
  if ((int )*(base + (size - 2U)) != 0) {
#line 2950
    return ((YY_BUFFER_STATE )0);
  } else
#line 2946
  if ((int )*(base + (size - 1U)) != 0) {
#line 2950
    return ((YY_BUFFER_STATE )0);
  }
  {
#line 2952
  tmp = bsdlalloc((yy_size_t )sizeof(struct yy_buffer_state ), yyscanner);
#line 2952
  b = (YY_BUFFER_STATE )tmp;
  }
#line 2953
  if (! b) {
    {
#line 2954
    yy_fatal_error___0("out of dynamic memory in bsdl_scan_buffer()", yyscanner);
    }
  }
  {
#line 2956
  b->yy_buf_size = size - 2U;
#line 2957
  tmp___0 = base;
#line 2957
  b->yy_ch_buf = tmp___0;
#line 2957
  b->yy_buf_pos = tmp___0;
#line 2958
  b->yy_is_our_buffer = 0;
#line 2959
  b->yy_input_file = (FILE *)0;
#line 2960
  b->yy_n_chars = (int )b->yy_buf_size;
#line 2961
  b->yy_is_interactive = 0;
#line 2962
  b->yy_at_bol = 1;
#line 2963
  b->yy_fill_buffer = 0;
#line 2964
  b->yy_buffer_status = 0;
#line 2966
  bsdl_switch_to_buffer(b, yyscanner);
  }
#line 2968
  return (b);
}
}
#line 2979 "bsdl_flex.c"
YY_BUFFER_STATE bsdl_scan_string(char const   *yystr , yyscan_t yyscanner ) 
{ 
  size_t tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 2982
  tmp = strlen(yystr);
#line 2982
  tmp___0 = bsdl_scan_bytes(yystr, (int )tmp, yyscanner);
  }
#line 2982
  return (tmp___0);
}
}
#line 2992 "bsdl_flex.c"
YY_BUFFER_STATE bsdl_scan_bytes(char const   *yybytes , int _yybytes_len , yyscan_t yyscanner ) 
{ 
  YY_BUFFER_STATE b ;
  char *buf ;
  yy_size_t n ;
  int i ;
  void *tmp ;
  char tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 3000
  n = (yy_size_t )(_yybytes_len + 2);
#line 3001
  tmp = bsdlalloc(n, yyscanner);
#line 3001
  buf = (char *)tmp;
  }
#line 3002
  if (! buf) {
    {
#line 3003
    yy_fatal_error___0("out of dynamic memory in bsdl_scan_bytes()", yyscanner);
    }
  }
#line 3005
  i = 0;
  {
#line 3005
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3005
    if (! (i < _yybytes_len)) {
#line 3005
      goto while_break;
    }
#line 3006
    *(buf + i) = (char )*(yybytes + i);
#line 3005
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3008
  tmp___0 = (char)0;
#line 3008
  *(buf + (_yybytes_len + 1)) = tmp___0;
#line 3008
  *(buf + _yybytes_len) = tmp___0;
#line 3010
  b = bsdl_scan_buffer(buf, n, yyscanner);
  }
#line 3011
  if (! b) {
    {
#line 3012
    yy_fatal_error___0("bad buffer in bsdl_scan_bytes()", yyscanner);
    }
  }
#line 3017
  b->yy_is_our_buffer = 1;
#line 3019
  return (b);
}
}
#line 3026 "bsdl_flex.c"
static void yy_fatal_error___0(char const   *msg , yyscan_t yyscanner ) 
{ 
  char *__cil_tmp3 ;

  {
  {
#line 3028
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          msg);
#line 3029
  exit(2);
  }
}
}
#line 3054 "bsdl_flex.c"
scan_extra_t *bsdlget_extra(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 3056
  yyg = (struct yyguts_t *)yyscanner;
#line 3057
  return (yyg->yyextra_r);
}
}
#line 3063 "bsdl_flex.c"
int bsdlget_lineno(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;

  {
#line 3065
  yyg = (struct yyguts_t *)yyscanner;
#line 3067
  if (yyg->yy_buffer_stack) {
#line 3067
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 3067
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 3067
  if (! tmp) {
#line 3068
    return (0);
  }
#line 3070
  return ((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_bs_lineno);
}
}
#line 3076 "bsdl_flex.c"
int bsdlget_column(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;

  {
#line 3078
  yyg = (struct yyguts_t *)yyscanner;
#line 3080
  if (yyg->yy_buffer_stack) {
#line 3080
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 3080
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 3080
  if (! tmp) {
#line 3081
    return (0);
  }
#line 3083
  return ((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_bs_column);
}
}
#line 3089 "bsdl_flex.c"
FILE *bsdlget_in(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 3091
  yyg = (struct yyguts_t *)yyscanner;
#line 3092
  return (yyg->yyin_r);
}
}
#line 3098 "bsdl_flex.c"
FILE *bsdlget_out(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 3100
  yyg = (struct yyguts_t *)yyscanner;
#line 3101
  return (yyg->yyout_r);
}
}
#line 3107 "bsdl_flex.c"
int bsdlget_leng(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 3109
  yyg = (struct yyguts_t *)yyscanner;
#line 3110
  return (yyg->yyleng_r);
}
}
#line 3117 "bsdl_flex.c"
char *bsdlget_text(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 3119
  yyg = (struct yyguts_t *)yyscanner;
#line 3120
  return (yyg->yytext_r);
}
}
#line 3127 "bsdl_flex.c"
void bsdlset_extra(scan_extra_t *user_defined , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 3129
  yyg = (struct yyguts_t *)yyscanner;
#line 3130
  yyg->yyextra_r = user_defined;
#line 3131
  return;
}
}
#line 3137 "bsdl_flex.c"
void bsdlset_lineno(int line_number , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;
  char *__cil_tmp5 ;

  {
#line 3139
  yyg = (struct yyguts_t *)yyscanner;
#line 3142
  if (yyg->yy_buffer_stack) {
#line 3142
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 3142
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 3142
  if (! tmp) {
    {
#line 3143
    yy_fatal_error___0("bsdlset_lineno called with no buffer", yyscanner);
    }
  }
#line 3145
  (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_bs_lineno = line_number;
#line 3146
  return;
}
}
#line 3152 "bsdl_flex.c"
void bsdlset_column(int column_no , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;
  char *__cil_tmp5 ;

  {
#line 3154
  yyg = (struct yyguts_t *)yyscanner;
#line 3157
  if (yyg->yy_buffer_stack) {
#line 3157
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 3157
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 3157
  if (! tmp) {
    {
#line 3158
    yy_fatal_error___0("bsdlset_column called with no buffer", yyscanner);
    }
  }
#line 3160
  (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_bs_column = column_no;
#line 3161
  return;
}
}
#line 3169 "bsdl_flex.c"
void bsdlset_in(FILE *in_str , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 3171
  yyg = (struct yyguts_t *)yyscanner;
#line 3172
  yyg->yyin_r = in_str;
#line 3173
  return;
}
}
#line 3175 "bsdl_flex.c"
void bsdlset_out(FILE *out_str , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 3177
  yyg = (struct yyguts_t *)yyscanner;
#line 3178
  yyg->yyout_r = out_str;
#line 3179
  return;
}
}
#line 3181 "bsdl_flex.c"
int bsdlget_debug(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 3183
  yyg = (struct yyguts_t *)yyscanner;
#line 3184
  return (yyg->yy_flex_debug_r);
}
}
#line 3187 "bsdl_flex.c"
void bsdlset_debug(int bdebug , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 3189
  yyg = (struct yyguts_t *)yyscanner;
#line 3190
  yyg->yy_flex_debug_r = bdebug;
#line 3191
  return;
}
}
#line 3195 "bsdl_flex.c"
YYSTYPE *bsdlget_lval(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 3197
  yyg = (struct yyguts_t *)yyscanner;
#line 3198
  return (yyg->yylval_r);
}
}
#line 3201 "bsdl_flex.c"
void bsdlset_lval(YYSTYPE *yylval_param , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 3203
  yyg = (struct yyguts_t *)yyscanner;
#line 3204
  yyg->yylval_r = yylval_param;
#line 3205
  return;
}
}
#line 3214 "bsdl_flex.c"
int bsdllex_init(yyscan_t *ptr_yy_globals ) 
{ 
  int *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
#line 3217
  if ((unsigned long )ptr_yy_globals == (unsigned long )((void *)0)) {
    {
#line 3218
    tmp = __errno_location();
#line 3218
    *tmp = 22;
    }
#line 3219
    return (1);
  }
  {
#line 3222
  tmp___0 = bsdlalloc((yy_size_t )sizeof(struct yyguts_t ), (void *)0);
#line 3222
  *ptr_yy_globals = tmp___0;
  }
#line 3224
  if ((unsigned long )*ptr_yy_globals == (unsigned long )((void *)0)) {
    {
#line 3225
    tmp___1 = __errno_location();
#line 3225
    *tmp___1 = 12;
    }
#line 3226
    return (1);
  }
  {
#line 3230
  memset(*ptr_yy_globals, 0, (size_t )sizeof(struct yyguts_t ));
#line 3232
  tmp___2 = yy_init_globals___0(*ptr_yy_globals);
  }
#line 3232
  return (tmp___2);
}
}
#line 3243 "bsdl_flex.c"
int bsdllex_init_extra(scan_extra_t *yy_user_defined , yyscan_t *ptr_yy_globals ) 
{ 
  struct yyguts_t dummy_yyguts ;
  int *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 3248
  bsdlset_extra(yy_user_defined, (yyscan_t )(& dummy_yyguts));
  }
#line 3250
  if ((unsigned long )ptr_yy_globals == (unsigned long )((void *)0)) {
    {
#line 3251
    tmp = __errno_location();
#line 3251
    *tmp = 22;
    }
#line 3252
    return (1);
  }
  {
#line 3255
  tmp___0 = bsdlalloc((yy_size_t )sizeof(struct yyguts_t ), (yyscan_t )(& dummy_yyguts));
#line 3255
  *ptr_yy_globals = tmp___0;
  }
#line 3257
  if ((unsigned long )*ptr_yy_globals == (unsigned long )((void *)0)) {
    {
#line 3258
    tmp___1 = __errno_location();
#line 3258
    *tmp___1 = 12;
    }
#line 3259
    return (1);
  }
  {
#line 3264
  memset(*ptr_yy_globals, 0, (size_t )sizeof(struct yyguts_t ));
#line 3266
  bsdlset_extra(yy_user_defined, *ptr_yy_globals);
#line 3268
  tmp___2 = yy_init_globals___0(*ptr_yy_globals);
  }
#line 3268
  return (tmp___2);
}
}
#line 3271 "bsdl_flex.c"
static int yy_init_globals___0(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 3273
  yyg = (struct yyguts_t *)yyscanner;
#line 3278
  yyg->yy_buffer_stack = (YY_BUFFER_STATE *)0;
#line 3279
  yyg->yy_buffer_stack_top = (size_t )0;
#line 3280
  yyg->yy_buffer_stack_max = (size_t )0;
#line 3281
  yyg->yy_c_buf_p = (char *)0;
#line 3282
  yyg->yy_init = 0;
#line 3283
  yyg->yy_start = 0;
#line 3285
  yyg->yy_start_stack_ptr = 0;
#line 3286
  yyg->yy_start_stack_depth = 0;
#line 3287
  yyg->yy_start_stack = (int *)((void *)0);
#line 3289
  yyg->yy_state_buf = (yy_state_type *)0;
#line 3290
  yyg->yy_state_ptr = (yy_state_type *)0;
#line 3291
  yyg->yy_full_match = (char *)0;
#line 3292
  yyg->yy_lp = 0;
#line 3299
  yyg->yyin_r = (FILE *)0;
#line 3300
  yyg->yyout_r = (FILE *)0;
#line 3306
  return (0);
}
}
#line 3310 "bsdl_flex.c"
int bsdllex_destroy(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 3312
  yyg = (struct yyguts_t *)yyscanner;
  {
#line 3315
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3315
    if (yyg->yy_buffer_stack) {
#line 3315
      tmp___0 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
    } else {
#line 3315
      tmp___0 = (YY_BUFFER_STATE )((void *)0);
    }
#line 3315
    if (! tmp___0) {
#line 3315
      goto while_break;
    }
#line 3316
    if (yyg->yy_buffer_stack) {
#line 3316
      tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
    } else {
#line 3316
      tmp = (YY_BUFFER_STATE )((void *)0);
    }
    {
#line 3316
    bsdl_delete_buffer(tmp, yyscanner);
#line 3317
    *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top) = (YY_BUFFER_STATE )((void *)0);
#line 3318
    bsdlpop_buffer_state(yyscanner);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3322
  bsdlfree((void *)yyg->yy_buffer_stack, yyscanner);
#line 3323
  yyg->yy_buffer_stack = (YY_BUFFER_STATE *)((void *)0);
#line 3326
  bsdlfree((void *)yyg->yy_start_stack, yyscanner);
#line 3327
  yyg->yy_start_stack = (int *)((void *)0);
#line 3329
  bsdlfree((void *)yyg->yy_state_buf, yyscanner);
#line 3330
  yyg->yy_state_buf = (yy_state_type *)((void *)0);
#line 3334
  yy_init_globals___0(yyscanner);
#line 3337
  bsdlfree(yyscanner, yyscanner);
#line 3338
  yyscanner = (void *)0;
  }
#line 3339
  return (0);
}
}
#line 3366 "bsdl_flex.c"
void *bsdlalloc(yy_size_t size , yyscan_t yyscanner ) 
{ 
  void *tmp ;

  {
  {
#line 3368
  tmp = malloc(size);
  }
#line 3368
  return (tmp);
}
}
#line 3371 "bsdl_flex.c"
void *bsdlrealloc(void *ptr , yy_size_t size , yyscan_t yyscanner ) 
{ 
  void *tmp ;

  {
  {
#line 3380
  tmp = realloc((void *)((char *)ptr), size);
  }
#line 3380
  return (tmp);
}
}
#line 3383 "bsdl_flex.c"
void bsdlfree(void *ptr , yyscan_t yyscanner ) 
{ 


  {
  {
#line 3385
  free((void *)((char *)ptr));
  }
#line 3386
  return;
}
}
#line 428 "bsdl_flex.l"
void *bsdl_flex_init(int proc_mode ) 
{ 
  scan_extra_t *extra ;
  yyscan_t scanner ;
  int tmp ;
  void *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 434
  tmp = bsdllex_init(& scanner);
  }
#line 434
  if (tmp != 0) {
    {
#line 436
    bsdl_msg(proc_mode, 3, "Scanner could not be initialized\n");
    }
#line 438
    return ((void *)0);
  }
  {
#line 441
  tmp___0 = malloc((size_t )sizeof(scan_extra_t ));
#line 441
  extra = (scan_extra_t *)tmp___0;
  }
#line 441
  if (! extra) {
    {
#line 442
    bsdl_msg(proc_mode, 3, "Out of memory, %s line %i\n", "bsdl_flex.l", 443);
#line 444
    bsdllex_destroy(scanner);
    }
#line 445
    return ((void *)0);
  }
  {
#line 448
  extra->proc_mode = proc_mode;
#line 449
  extra->Compile_Errors = 0;
#line 450
  extra->Base = 1;
#line 452
  bsdlset_extra(extra, scanner);
  }
#line 454
  return (scanner);
}
}
#line 469 "bsdl_flex.l"
void bsdl_flex_deinit(void *scanner ) 
{ 
  FILE *tmp ;
  FILE *tmp___0 ;
  scan_extra_t *tmp___1 ;

  {
  {
#line 471
  tmp___0 = bsdlget_in(scanner);
  }
#line 471
  if (tmp___0) {
    {
#line 475
    tmp = bsdlget_in(scanner);
#line 475
    fclose(tmp);
#line 476
    bsdlset_in((FILE *)((void *)0), scanner);
    }
  }
  {
#line 478
  tmp___1 = bsdlget_extra(scanner);
#line 478
  free((void *)tmp___1);
#line 479
  bsdllex_destroy(scanner);
  }
#line 480
  return;
}
}
#line 494 "bsdl_flex.l"
int bsdlwrap(yyscan_t scanner ) 
{ 
  FILE *tmp ;
  FILE *tmp___0 ;

  {
  {
#line 496
  tmp___0 = bsdlget_in(scanner);
  }
#line 496
  if (tmp___0) {
    {
#line 497
    tmp = bsdlget_in(scanner);
#line 497
    fclose(tmp);
#line 498
    bsdlset_in((FILE *)((void *)0), scanner);
    }
  }
#line 500
  return (1);
}
}
#line 516 "bsdl_flex.l"
static char *new_string___0(scan_extra_t *extra , char const   *str ) 
{ 
  char *n_str ;
  size_t n_str_size ;
  size_t tmp ;
  void *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 521
  tmp = strlen(str);
#line 521
  n_str_size = tmp + 1U;
#line 522
  tmp___0 = malloc(n_str_size);
#line 522
  n_str = (char *)tmp___0;
  }
#line 522
  if (n_str) {
    {
#line 524
    strncpy((char */* __restrict  */)n_str, (char const   */* __restrict  */)str,
            n_str_size - 1U);
#line 525
    *(n_str + (n_str_size - 1U)) = (char )'\000';
    }
  } else {
    {
#line 528
    bsdl_msg(extra->proc_mode, 3, "Out of memory, %s line %i\n", "bsdl_flex.l", 529);
    }
  }
#line 531
  return (n_str);
}
}
#line 548 "bsdl_flex.l"
void bsdl_flex_switch_buffer(void *scanner , char const   *buffer , int lineno ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;

  {
#line 552
  yyg = (struct yyguts_t *)scanner;
#line 560
  if (yyg->yy_buffer_stack) {
#line 560
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 560
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 560
  bsdlpush_buffer_state(tmp, scanner);
#line 561
  bsdl_scan_string(buffer, scanner);
#line 562
  bsdlset_lineno(lineno, scanner);
  }
#line 563
  return;
}
}
#line 577 "bsdl_flex.l"
void bsdl_flex_stop_buffer(void *scanner ) 
{ 


  {
  {
#line 579
  bsdlpop_buffer_state(scanner);
  }
#line 582
  return;
}
}
#line 596 "bsdl_flex.l"
int bsdl_flex_get_compile_errors(void *scanner ) 
{ 
  scan_extra_t *extra ;
  scan_extra_t *tmp ;

  {
  {
#line 598
  tmp = bsdlget_extra(scanner);
#line 598
  extra = tmp;
  }
#line 599
  return (extra->Compile_Errors);
}
}
#line 615 "bsdl_flex.l"
static void bsdl_flex_set_compile_errors(int n , yyscan_t scanner ) 
{ 
  scan_extra_t *extra ;
  scan_extra_t *tmp ;

  {
  {
#line 617
  tmp = bsdlget_extra(scanner);
#line 617
  extra = tmp;
#line 618
  extra->Compile_Errors = n;
  }
#line 619
  return;
}
}
#line 633 "bsdl_flex.l"
int bsdl_flex_postinc_compile_errors(void *scanner ) 
{ 
  int errors ;
  int tmp ;

  {
  {
#line 635
  tmp = bsdl_flex_get_compile_errors(scanner);
#line 635
  errors = tmp;
#line 637
  bsdl_flex_set_compile_errors(errors + 1, scanner);
  }
#line 638
  return (errors);
}
}
#line 653 "bsdl_flex.l"
void bsdl_flex_set_bin_x(void *scanner ) 
{ 
  scan_extra_t *extra ;
  scan_extra_t *tmp ;

  {
  {
#line 655
  tmp = bsdlget_extra(scanner);
#line 655
  extra = tmp;
#line 656
  extra->Base = 2;
  }
#line 657
  return;
}
}
#line 671 "bsdl_flex.l"
void bsdl_flex_set_hex(void *scanner ) 
{ 
  scan_extra_t *extra ;
  scan_extra_t *tmp ;

  {
  {
#line 673
  tmp = bsdlget_extra(scanner);
#line 673
  extra = tmp;
#line 674
  extra->Base = 3;
  }
#line 675
  return;
}
}
#line 689 "bsdl_flex.l"
void bsdl_flex_set_decimal(void *scanner ) 
{ 
  scan_extra_t *extra ;
  scan_extra_t *tmp ;

  {
  {
#line 691
  tmp = bsdlget_extra(scanner);
#line 691
  extra = tmp;
#line 692
  extra->Base = 1;
  }
#line 693
  return;
}
}
#line 155 "bsdl_bison.y"
static void Print_Error___0(bsdl_parser_priv_t *priv_data , char const   *Errmess ) ;
#line 156
static void Print_Warning(bsdl_parser_priv_t *priv_data , char const   *Warnmess ) ;
#line 157
static void Give_Up_And_Quit___0(bsdl_parser_priv_t *priv_data ) ;
#line 160
static void add_instruction(bsdl_parser_priv_t *priv , char *instr , char *opcode ) ;
#line 161
static void ac_set_register(bsdl_parser_priv_t *priv , char *reg , int reg_len ) ;
#line 162
static void ac_add_instruction(bsdl_parser_priv_t *priv , char *instr ) ;
#line 163
static void ac_apply_assoc(bsdl_parser_priv_t *priv ) ;
#line 164
static void prt_add_name(bsdl_parser_priv_t *priv , char *name ) ;
#line 165
static void prt_add_bit(bsdl_parser_priv_t *priv ) ;
#line 166
static void prt_add_range(bsdl_parser_priv_t *priv , int low , int high ) ;
#line 167
static void ci_no_disable(bsdl_parser_priv_t *priv ) ;
#line 168
static void ci_set_cell_spec_disable(bsdl_parser_priv_t *priv , int ctrl_bit_num ,
                                     int safe_value , int disable_value ) ;
#line 169
static void ci_set_cell_spec(bsdl_parser_priv_t *priv , int function , char *safe_value ) ;
#line 170
static void ci_append_cell_info(bsdl_parser_priv_t *priv , int bit_num ) ;
#line 172
void bsdlerror(bsdl_parser_priv_t *priv_data , char const   *error_string ) ;
#line 646 "bsdl_bison.c"
static yytype_uint8 const   yytranslate___0[369]  = 
#line 646 "bsdl_bison.c"
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )11,      (yytype_uint8 const   )12, 
        (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )22,      (yytype_uint8 const   )23,      (yytype_uint8 const   )24, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )26,      (yytype_uint8 const   )27,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )30,      (yytype_uint8 const   )31,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )33,      (yytype_uint8 const   )34,      (yytype_uint8 const   )35,      (yytype_uint8 const   )36, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )38,      (yytype_uint8 const   )39,      (yytype_uint8 const   )40, 
        (yytype_uint8 const   )41,      (yytype_uint8 const   )42,      (yytype_uint8 const   )43,      (yytype_uint8 const   )44, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )46,      (yytype_uint8 const   )47,      (yytype_uint8 const   )48, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )50,      (yytype_uint8 const   )51,      (yytype_uint8 const   )52, 
        (yytype_uint8 const   )53,      (yytype_uint8 const   )54,      (yytype_uint8 const   )55,      (yytype_uint8 const   )56, 
        (yytype_uint8 const   )57,      (yytype_uint8 const   )58,      (yytype_uint8 const   )59,      (yytype_uint8 const   )60, 
        (yytype_uint8 const   )61,      (yytype_uint8 const   )62,      (yytype_uint8 const   )63,      (yytype_uint8 const   )64, 
        (yytype_uint8 const   )65,      (yytype_uint8 const   )66,      (yytype_uint8 const   )67,      (yytype_uint8 const   )68, 
        (yytype_uint8 const   )69,      (yytype_uint8 const   )70,      (yytype_uint8 const   )71,      (yytype_uint8 const   )72, 
        (yytype_uint8 const   )73,      (yytype_uint8 const   )74,      (yytype_uint8 const   )75,      (yytype_uint8 const   )76, 
        (yytype_uint8 const   )77,      (yytype_uint8 const   )78,      (yytype_uint8 const   )79,      (yytype_uint8 const   )80, 
        (yytype_uint8 const   )81,      (yytype_uint8 const   )82,      (yytype_uint8 const   )83,      (yytype_uint8 const   )84, 
        (yytype_uint8 const   )85,      (yytype_uint8 const   )86,      (yytype_uint8 const   )87,      (yytype_uint8 const   )88, 
        (yytype_uint8 const   )89,      (yytype_uint8 const   )90,      (yytype_uint8 const   )91,      (yytype_uint8 const   )92, 
        (yytype_uint8 const   )93,      (yytype_uint8 const   )94,      (yytype_uint8 const   )95,      (yytype_uint8 const   )96, 
        (yytype_uint8 const   )97,      (yytype_uint8 const   )98,      (yytype_uint8 const   )99,      (yytype_uint8 const   )100, 
        (yytype_uint8 const   )101,      (yytype_uint8 const   )102,      (yytype_uint8 const   )103,      (yytype_uint8 const   )104, 
        (yytype_uint8 const   )105,      (yytype_uint8 const   )106,      (yytype_uint8 const   )107,      (yytype_uint8 const   )108, 
        (yytype_uint8 const   )109,      (yytype_uint8 const   )110,      (yytype_uint8 const   )111,      (yytype_uint8 const   )112, 
        (yytype_uint8 const   )113};
#line 932 "bsdl_bison.c"
static yytype_uint8 const   yyr1___0[286]  = 
#line 932
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )114,      (yytype_uint8 const   )115,      (yytype_uint8 const   )115, 
        (yytype_uint8 const   )115,      (yytype_uint8 const   )115,      (yytype_uint8 const   )115,      (yytype_uint8 const   )115, 
        (yytype_uint8 const   )115,      (yytype_uint8 const   )115,      (yytype_uint8 const   )115,      (yytype_uint8 const   )115, 
        (yytype_uint8 const   )115,      (yytype_uint8 const   )115,      (yytype_uint8 const   )115,      (yytype_uint8 const   )115, 
        (yytype_uint8 const   )115,      (yytype_uint8 const   )115,      (yytype_uint8 const   )115,      (yytype_uint8 const   )115, 
        (yytype_uint8 const   )115,      (yytype_uint8 const   )115,      (yytype_uint8 const   )115,      (yytype_uint8 const   )115, 
        (yytype_uint8 const   )116,      (yytype_uint8 const   )117,      (yytype_uint8 const   )117,      (yytype_uint8 const   )118, 
        (yytype_uint8 const   )119,      (yytype_uint8 const   )119,      (yytype_uint8 const   )120,      (yytype_uint8 const   )120, 
        (yytype_uint8 const   )121,      (yytype_uint8 const   )121,      (yytype_uint8 const   )121,      (yytype_uint8 const   )122, 
        (yytype_uint8 const   )123,      (yytype_uint8 const   )124,      (yytype_uint8 const   )125,      (yytype_uint8 const   )126, 
        (yytype_uint8 const   )127,      (yytype_uint8 const   )128,      (yytype_uint8 const   )129,      (yytype_uint8 const   )129, 
        (yytype_uint8 const   )129,      (yytype_uint8 const   )130,      (yytype_uint8 const   )131,      (yytype_uint8 const   )131, 
        (yytype_uint8 const   )132,      (yytype_uint8 const   )133,      (yytype_uint8 const   )134,      (yytype_uint8 const   )135, 
        (yytype_uint8 const   )136,      (yytype_uint8 const   )137,      (yytype_uint8 const   )137,      (yytype_uint8 const   )137, 
        (yytype_uint8 const   )138,      (yytype_uint8 const   )139,      (yytype_uint8 const   )140,      (yytype_uint8 const   )141, 
        (yytype_uint8 const   )142,      (yytype_uint8 const   )142,      (yytype_uint8 const   )143,      (yytype_uint8 const   )144, 
        (yytype_uint8 const   )144,      (yytype_uint8 const   )145,      (yytype_uint8 const   )145,      (yytype_uint8 const   )145, 
        (yytype_uint8 const   )145,      (yytype_uint8 const   )145,      (yytype_uint8 const   )146,      (yytype_uint8 const   )146, 
        (yytype_uint8 const   )147,      (yytype_uint8 const   )147,      (yytype_uint8 const   )147,      (yytype_uint8 const   )147, 
        (yytype_uint8 const   )147,      (yytype_uint8 const   )147,      (yytype_uint8 const   )147,      (yytype_uint8 const   )147, 
        (yytype_uint8 const   )147,      (yytype_uint8 const   )147,      (yytype_uint8 const   )147,      (yytype_uint8 const   )148, 
        (yytype_uint8 const   )149,      (yytype_uint8 const   )150,      (yytype_uint8 const   )151,      (yytype_uint8 const   )151, 
        (yytype_uint8 const   )151,      (yytype_uint8 const   )152,      (yytype_uint8 const   )153,      (yytype_uint8 const   )153, 
        (yytype_uint8 const   )154,      (yytype_uint8 const   )155,      (yytype_uint8 const   )155,      (yytype_uint8 const   )155, 
        (yytype_uint8 const   )156,      (yytype_uint8 const   )156,      (yytype_uint8 const   )156,      (yytype_uint8 const   )156, 
        (yytype_uint8 const   )156,      (yytype_uint8 const   )156,      (yytype_uint8 const   )156,      (yytype_uint8 const   )156, 
        (yytype_uint8 const   )156,      (yytype_uint8 const   )157,      (yytype_uint8 const   )157,      (yytype_uint8 const   )158, 
        (yytype_uint8 const   )159,      (yytype_uint8 const   )159,      (yytype_uint8 const   )159,      (yytype_uint8 const   )159, 
        (yytype_uint8 const   )159,      (yytype_uint8 const   )159,      (yytype_uint8 const   )160,      (yytype_uint8 const   )162, 
        (yytype_uint8 const   )161,      (yytype_uint8 const   )163,      (yytype_uint8 const   )163,      (yytype_uint8 const   )164, 
        (yytype_uint8 const   )164,      (yytype_uint8 const   )164,      (yytype_uint8 const   )165,      (yytype_uint8 const   )165, 
        (yytype_uint8 const   )165,      (yytype_uint8 const   )165,      (yytype_uint8 const   )165,      (yytype_uint8 const   )165, 
        (yytype_uint8 const   )165,      (yytype_uint8 const   )165,      (yytype_uint8 const   )165,      (yytype_uint8 const   )165, 
        (yytype_uint8 const   )166,      (yytype_uint8 const   )166,      (yytype_uint8 const   )167,      (yytype_uint8 const   )168, 
        (yytype_uint8 const   )168,      (yytype_uint8 const   )168,      (yytype_uint8 const   )169,      (yytype_uint8 const   )170, 
        (yytype_uint8 const   )170,      (yytype_uint8 const   )170,      (yytype_uint8 const   )171,      (yytype_uint8 const   )171, 
        (yytype_uint8 const   )172,      (yytype_uint8 const   )173,      (yytype_uint8 const   )173,      (yytype_uint8 const   )174, 
        (yytype_uint8 const   )175,      (yytype_uint8 const   )176,      (yytype_uint8 const   )176,      (yytype_uint8 const   )177, 
        (yytype_uint8 const   )178,      (yytype_uint8 const   )179,      (yytype_uint8 const   )180,      (yytype_uint8 const   )181, 
        (yytype_uint8 const   )181,      (yytype_uint8 const   )182,      (yytype_uint8 const   )182,      (yytype_uint8 const   )183, 
        (yytype_uint8 const   )184,      (yytype_uint8 const   )184,      (yytype_uint8 const   )185,      (yytype_uint8 const   )185, 
        (yytype_uint8 const   )185,      (yytype_uint8 const   )185,      (yytype_uint8 const   )185,      (yytype_uint8 const   )185, 
        (yytype_uint8 const   )185,      (yytype_uint8 const   )185,      (yytype_uint8 const   )186,      (yytype_uint8 const   )186, 
        (yytype_uint8 const   )186,      (yytype_uint8 const   )186,      (yytype_uint8 const   )186,      (yytype_uint8 const   )186, 
        (yytype_uint8 const   )186,      (yytype_uint8 const   )187,      (yytype_uint8 const   )187,      (yytype_uint8 const   )188, 
        (yytype_uint8 const   )188,      (yytype_uint8 const   )188,      (yytype_uint8 const   )188,      (yytype_uint8 const   )188, 
        (yytype_uint8 const   )189,      (yytype_uint8 const   )190,      (yytype_uint8 const   )191,      (yytype_uint8 const   )192, 
        (yytype_uint8 const   )192,      (yytype_uint8 const   )193,      (yytype_uint8 const   )193,      (yytype_uint8 const   )194, 
        (yytype_uint8 const   )195,      (yytype_uint8 const   )195,      (yytype_uint8 const   )196,      (yytype_uint8 const   )197, 
        (yytype_uint8 const   )197,      (yytype_uint8 const   )198,      (yytype_uint8 const   )198,      (yytype_uint8 const   )198, 
        (yytype_uint8 const   )198,      (yytype_uint8 const   )199,      (yytype_uint8 const   )199,      (yytype_uint8 const   )200, 
        (yytype_uint8 const   )201,      (yytype_uint8 const   )200,      (yytype_uint8 const   )202,      (yytype_uint8 const   )202, 
        (yytype_uint8 const   )202,      (yytype_uint8 const   )203,      (yytype_uint8 const   )203,      (yytype_uint8 const   )203, 
        (yytype_uint8 const   )205,      (yytype_uint8 const   )204,      (yytype_uint8 const   )204,      (yytype_uint8 const   )206, 
        (yytype_uint8 const   )206,      (yytype_uint8 const   )207,      (yytype_uint8 const   )207,      (yytype_uint8 const   )208, 
        (yytype_uint8 const   )208,      (yytype_uint8 const   )210,      (yytype_uint8 const   )209,      (yytype_uint8 const   )211, 
        (yytype_uint8 const   )211,      (yytype_uint8 const   )211,      (yytype_uint8 const   )211,      (yytype_uint8 const   )212, 
        (yytype_uint8 const   )212,      (yytype_uint8 const   )213,      (yytype_uint8 const   )213,      (yytype_uint8 const   )213, 
        (yytype_uint8 const   )213,      (yytype_uint8 const   )214,      (yytype_uint8 const   )214,      (yytype_uint8 const   )214, 
        (yytype_uint8 const   )214,      (yytype_uint8 const   )215,      (yytype_uint8 const   )215,      (yytype_uint8 const   )215, 
        (yytype_uint8 const   )216,      (yytype_uint8 const   )216,      (yytype_uint8 const   )216,      (yytype_uint8 const   )217, 
        (yytype_uint8 const   )218,      (yytype_uint8 const   )219,      (yytype_uint8 const   )219,      (yytype_uint8 const   )219, 
        (yytype_uint8 const   )219,      (yytype_uint8 const   )220,      (yytype_uint8 const   )221,      (yytype_uint8 const   )222, 
        (yytype_uint8 const   )223,      (yytype_uint8 const   )224,      (yytype_uint8 const   )225,      (yytype_uint8 const   )226, 
        (yytype_uint8 const   )227,      (yytype_uint8 const   )227,      (yytype_uint8 const   )228,      (yytype_uint8 const   )228, 
        (yytype_uint8 const   )228,      (yytype_uint8 const   )229,      (yytype_uint8 const   )229,      (yytype_uint8 const   )230, 
        (yytype_uint8 const   )231,      (yytype_uint8 const   )231,      (yytype_uint8 const   )232,      (yytype_uint8 const   )232, 
        (yytype_uint8 const   )232,      (yytype_uint8 const   )232,      (yytype_uint8 const   )232,      (yytype_uint8 const   )233, 
        (yytype_uint8 const   )233,      (yytype_uint8 const   )234,      (yytype_uint8 const   )234,      (yytype_uint8 const   )234, 
        (yytype_uint8 const   )234,      (yytype_uint8 const   )234,      (yytype_uint8 const   )234,      (yytype_uint8 const   )234, 
        (yytype_uint8 const   )234,      (yytype_uint8 const   )235,      (yytype_uint8 const   )235,      (yytype_uint8 const   )236, 
        (yytype_uint8 const   )237,      (yytype_uint8 const   )237};
#line 966 "bsdl_bison.c"
static yytype_uint8 const   yyr2___0[286]  = 
#line 966
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )4,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )4,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )4,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )7,      (yytype_uint8 const   )1,      (yytype_uint8 const   )4,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )5, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )7,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )0,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )7,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )4,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )4,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )4,      (yytype_uint8 const   )5,      (yytype_uint8 const   )5, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )4,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )4,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )0,      (yytype_uint8 const   )4,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )0,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )5,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )5,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )7,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )4,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3};
#line 1002 "bsdl_bison.c"
static yytype_uint16 const   yydefact___0[441]  = 
#line 1002
  {      (yytype_uint16 const   )0,      (yytype_uint16 const   )23,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )145,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )2,      (yytype_uint16 const   )3,      (yytype_uint16 const   )4, 
        (yytype_uint16 const   )5,      (yytype_uint16 const   )6,      (yytype_uint16 const   )7,      (yytype_uint16 const   )8, 
        (yytype_uint16 const   )9,      (yytype_uint16 const   )10,      (yytype_uint16 const   )11,      (yytype_uint16 const   )12, 
        (yytype_uint16 const   )13,      (yytype_uint16 const   )14,      (yytype_uint16 const   )15,      (yytype_uint16 const   )16, 
        (yytype_uint16 const   )17,      (yytype_uint16 const   )18,      (yytype_uint16 const   )19,      (yytype_uint16 const   )20, 
        (yytype_uint16 const   )21,      (yytype_uint16 const   )22,      (yytype_uint16 const   )122,      (yytype_uint16 const   )123, 
        (yytype_uint16 const   )124,      (yytype_uint16 const   )125,      (yytype_uint16 const   )126,      (yytype_uint16 const   )127, 
        (yytype_uint16 const   )128,      (yytype_uint16 const   )129,      (yytype_uint16 const   )130,      (yytype_uint16 const   )131, 
        (yytype_uint16 const   )24,      (yytype_uint16 const   )0,      (yytype_uint16 const   )25,      (yytype_uint16 const   )35, 
        (yytype_uint16 const   )36,      (yytype_uint16 const   )37,      (yytype_uint16 const   )38,      (yytype_uint16 const   )39, 
        (yytype_uint16 const   )40,      (yytype_uint16 const   )44,      (yytype_uint16 const   )0,      (yytype_uint16 const   )41, 
        (yytype_uint16 const   )42,      (yytype_uint16 const   )49,      (yytype_uint16 const   )50,      (yytype_uint16 const   )51, 
        (yytype_uint16 const   )55,      (yytype_uint16 const   )56,      (yytype_uint16 const   )52,      (yytype_uint16 const   )53, 
        (yytype_uint16 const   )65,      (yytype_uint16 const   )69,      (yytype_uint16 const   )0,      (yytype_uint16 const   )66, 
        (yytype_uint16 const   )67,      (yytype_uint16 const   )68,      (yytype_uint16 const   )59,      (yytype_uint16 const   )60, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )63,      (yytype_uint16 const   )84,      (yytype_uint16 const   )88, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )85,      (yytype_uint16 const   )86,      (yytype_uint16 const   )57, 
        (yytype_uint16 const   )58,      (yytype_uint16 const   )0,      (yytype_uint16 const   )114,      (yytype_uint16 const   )119, 
        (yytype_uint16 const   )120,      (yytype_uint16 const   )121,      (yytype_uint16 const   )132,      (yytype_uint16 const   )133, 
        (yytype_uint16 const   )137,      (yytype_uint16 const   )136,      (yytype_uint16 const   )135,      (yytype_uint16 const   )134, 
        (yytype_uint16 const   )141,      (yytype_uint16 const   )142,      (yytype_uint16 const   )138,      (yytype_uint16 const   )139, 
        (yytype_uint16 const   )146,      (yytype_uint16 const   )0,      (yytype_uint16 const   )147,      (yytype_uint16 const   )150, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )148,      (yytype_uint16 const   )0,      (yytype_uint16 const   )169, 
        (yytype_uint16 const   )170,      (yytype_uint16 const   )159,      (yytype_uint16 const   )160,      (yytype_uint16 const   )162, 
        (yytype_uint16 const   )260,      (yytype_uint16 const   )0,      (yytype_uint16 const   )255,      (yytype_uint16 const   )256, 
        (yytype_uint16 const   )270,      (yytype_uint16 const   )0,      (yytype_uint16 const   )263,      (yytype_uint16 const   )264, 
        (yytype_uint16 const   )284,      (yytype_uint16 const   )283,      (yytype_uint16 const   )1,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )32,      (yytype_uint16 const   )34,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )30,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )144, 
        (yytype_uint16 const   )156,      (yytype_uint16 const   )155,      (yytype_uint16 const   )151,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )174,      (yytype_uint16 const   )176,      (yytype_uint16 const   )171, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )163,      (yytype_uint16 const   )166,      (yytype_uint16 const   )168,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )26, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )27,      (yytype_uint16 const   )28,      (yytype_uint16 const   )48, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )46,      (yytype_uint16 const   )43,      (yytype_uint16 const   )54, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )61,      (yytype_uint16 const   )82,      (yytype_uint16 const   )72, 
        (yytype_uint16 const   )73,      (yytype_uint16 const   )74,      (yytype_uint16 const   )75,      (yytype_uint16 const   )76, 
        (yytype_uint16 const   )77,      (yytype_uint16 const   )78,      (yytype_uint16 const   )79,      (yytype_uint16 const   )80, 
        (yytype_uint16 const   )81,      (yytype_uint16 const   )0,      (yytype_uint16 const   )83,      (yytype_uint16 const   )70, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )90,      (yytype_uint16 const   )87, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )115,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )140,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )182,      (yytype_uint16 const   )183,      (yytype_uint16 const   )180,      (yytype_uint16 const   )179, 
        (yytype_uint16 const   )181,      (yytype_uint16 const   )0,      (yytype_uint16 const   )175,      (yytype_uint16 const   )172, 
        (yytype_uint16 const   )161,      (yytype_uint16 const   )0,      (yytype_uint16 const   )192,      (yytype_uint16 const   )184, 
        (yytype_uint16 const   )187,      (yytype_uint16 const   )190,      (yytype_uint16 const   )189,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )186,      (yytype_uint16 const   )164,      (yytype_uint16 const   )167,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )257,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )265,      (yytype_uint16 const   )285, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )45,      (yytype_uint16 const   )64, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )62,      (yytype_uint16 const   )0,      (yytype_uint16 const   )89, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )31,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )143,      (yytype_uint16 const   )152,      (yytype_uint16 const   )0,      (yytype_uint16 const   )178, 
        (yytype_uint16 const   )177,      (yytype_uint16 const   )173,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )188,      (yytype_uint16 const   )185,      (yytype_uint16 const   )165, 
        (yytype_uint16 const   )261,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )273, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )271,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )29,      (yytype_uint16 const   )47,      (yytype_uint16 const   )71, 
        (yytype_uint16 const   )93,      (yytype_uint16 const   )95,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )91,      (yytype_uint16 const   )33,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )203,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )201,      (yytype_uint16 const   )0,      (yytype_uint16 const   )193,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )258,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )278,      (yytype_uint16 const   )281,      (yytype_uint16 const   )282,      (yytype_uint16 const   )274, 
        (yytype_uint16 const   )280,      (yytype_uint16 const   )0,      (yytype_uint16 const   )266,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )117,      (yytype_uint16 const   )0,      (yytype_uint16 const   )153, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )204,      (yytype_uint16 const   )241,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )237,      (yytype_uint16 const   )240,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )197,      (yytype_uint16 const   )0,      (yytype_uint16 const   )219, 
        (yytype_uint16 const   )194,      (yytype_uint16 const   )0,      (yytype_uint16 const   )262,      (yytype_uint16 const   )259, 
        (yytype_uint16 const   )279,      (yytype_uint16 const   )275,      (yytype_uint16 const   )276,      (yytype_uint16 const   )272, 
        (yytype_uint16 const   )268,      (yytype_uint16 const   )267,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )96,      (yytype_uint16 const   )97,      (yytype_uint16 const   )98,      (yytype_uint16 const   )99, 
        (yytype_uint16 const   )100,      (yytype_uint16 const   )101,      (yytype_uint16 const   )102,      (yytype_uint16 const   )103, 
        (yytype_uint16 const   )104,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )116,      (yytype_uint16 const   )0,      (yytype_uint16 const   )149,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )243,      (yytype_uint16 const   )238,      (yytype_uint16 const   )0,      (yytype_uint16 const   )202, 
        (yytype_uint16 const   )198,      (yytype_uint16 const   )0,      (yytype_uint16 const   )221,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )199,      (yytype_uint16 const   )0,      (yytype_uint16 const   )195,      (yytype_uint16 const   )277, 
        (yytype_uint16 const   )269,      (yytype_uint16 const   )94,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )118,      (yytype_uint16 const   )0,      (yytype_uint16 const   )157,      (yytype_uint16 const   )154, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )206,      (yytype_uint16 const   )250,      (yytype_uint16 const   )252, 
        (yytype_uint16 const   )205,      (yytype_uint16 const   )208,      (yytype_uint16 const   )210,      (yytype_uint16 const   )211, 
        (yytype_uint16 const   )207,      (yytype_uint16 const   )209,      (yytype_uint16 const   )217,      (yytype_uint16 const   )218, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )242,      (yytype_uint16 const   )200,      (yytype_uint16 const   )229, 
        (yytype_uint16 const   )220,      (yytype_uint16 const   )191,      (yytype_uint16 const   )196,      (yytype_uint16 const   )105, 
        (yytype_uint16 const   )106,      (yytype_uint16 const   )92,      (yytype_uint16 const   )108,      (yytype_uint16 const   )109, 
        (yytype_uint16 const   )110,      (yytype_uint16 const   )111,      (yytype_uint16 const   )112,      (yytype_uint16 const   )113, 
        (yytype_uint16 const   )107,      (yytype_uint16 const   )0,      (yytype_uint16 const   )244,      (yytype_uint16 const   )212, 
        (yytype_uint16 const   )245,      (yytype_uint16 const   )246,      (yytype_uint16 const   )247,      (yytype_uint16 const   )248, 
        (yytype_uint16 const   )249,      (yytype_uint16 const   )214,      (yytype_uint16 const   )0,      (yytype_uint16 const   )215, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )251,      (yytype_uint16 const   )232,      (yytype_uint16 const   )222, 
        (yytype_uint16 const   )223,      (yytype_uint16 const   )227,      (yytype_uint16 const   )230,      (yytype_uint16 const   )158, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )216,      (yytype_uint16 const   )239,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )224,      (yytype_uint16 const   )226,      (yytype_uint16 const   )233,      (yytype_uint16 const   )228, 
        (yytype_uint16 const   )231,      (yytype_uint16 const   )213,      (yytype_uint16 const   )253,      (yytype_uint16 const   )254, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )225,      (yytype_uint16 const   )236,      (yytype_uint16 const   )234, 
        (yytype_uint16 const   )235};
#line 1052 "bsdl_bison.c"
static yytype_int16 const   yydefgoto___0[124]  = 
#line 1052
  {      (yytype_int16 const   )-1,      (yytype_int16 const   )32,      (yytype_int16 const   )33,      (yytype_int16 const   )34, 
        (yytype_int16 const   )66,      (yytype_int16 const   )181,      (yytype_int16 const   )151,      (yytype_int16 const   )152, 
        (yytype_int16 const   )35,      (yytype_int16 const   )36,      (yytype_int16 const   )37,      (yytype_int16 const   )38, 
        (yytype_int16 const   )39,      (yytype_int16 const   )40,      (yytype_int16 const   )41,      (yytype_int16 const   )75, 
        (yytype_int16 const   )76,      (yytype_int16 const   )184,      (yytype_int16 const   )185,      (yytype_int16 const   )42, 
        (yytype_int16 const   )43,      (yytype_int16 const   )44,      (yytype_int16 const   )45,      (yytype_int16 const   )82, 
        (yytype_int16 const   )83,      (yytype_int16 const   )46,      (yytype_int16 const   )47,      (yytype_int16 const   )48, 
        (yytype_int16 const   )90,      (yytype_int16 const   )91,      (yytype_int16 const   )92,      (yytype_int16 const   )93, 
        (yytype_int16 const   )201,      (yytype_int16 const   )202,      (yytype_int16 const   )203,      (yytype_int16 const   )49, 
        (yytype_int16 const   )50,      (yytype_int16 const   )97,      (yytype_int16 const   )98,      (yytype_int16 const   )205, 
        (yytype_int16 const   )206,      (yytype_int16 const   )282,      (yytype_int16 const   )349,      (yytype_int16 const   )397, 
        (yytype_int16 const   )284,      (yytype_int16 const   )404,      (yytype_int16 const   )51,      (yytype_int16 const   )102, 
        (yytype_int16 const   )255,      (yytype_int16 const   )314,      (yytype_int16 const   )52,      (yytype_int16 const   )53, 
        (yytype_int16 const   )54,      (yytype_int16 const   )55,      (yytype_int16 const   )111,      (yytype_int16 const   )56, 
        (yytype_int16 const   )114,      (yytype_int16 const   )319,      (yytype_int16 const   )57,      (yytype_int16 const   )117, 
        (yytype_int16 const   )58,      (yytype_int16 const   )59,      (yytype_int16 const   )121,      (yytype_int16 const   )122, 
        (yytype_int16 const   )214,      (yytype_int16 const   )288,      (yytype_int16 const   )354,      (yytype_int16 const   )158, 
        (yytype_int16 const   )375,      (yytype_int16 const   )60,      (yytype_int16 const   )125,      (yytype_int16 const   )126, 
        (yytype_int16 const   )127,      (yytype_int16 const   )163,      (yytype_int16 const   )221,      (yytype_int16 const   )168, 
        (yytype_int16 const   )169,      (yytype_int16 const   )170,      (yytype_int16 const   )227,      (yytype_int16 const   )228, 
        (yytype_int16 const   )229,      (yytype_int16 const   )264,      (yytype_int16 const   )296,      (yytype_int16 const   )365, 
        (yytype_int16 const   )230,      (yytype_int16 const   )291,      (yytype_int16 const   )292,      (yytype_int16 const   )355, 
        (yytype_int16 const   )380,      (yytype_int16 const   )381,      (yytype_int16 const   )382,      (yytype_int16 const   )424, 
        (yytype_int16 const   )383,      (yytype_int16 const   )384,      (yytype_int16 const   )326,      (yytype_int16 const   )327, 
        (yytype_int16 const   )391,      (yytype_int16 const   )419,      (yytype_int16 const   )420,      (yytype_int16 const   )421, 
        (yytype_int16 const   )431,      (yytype_int16 const   )293,      (yytype_int16 const   )320,      (yytype_int16 const   )321, 
        (yytype_int16 const   )385,      (yytype_int16 const   )414,      (yytype_int16 const   )415,      (yytype_int16 const   )386, 
        (yytype_int16 const   )422,      (yytype_int16 const   )387,      (yytype_int16 const   )428,      (yytype_int16 const   )429, 
        (yytype_int16 const   )61,      (yytype_int16 const   )130,      (yytype_int16 const   )131,      (yytype_int16 const   )269, 
        (yytype_int16 const   )62,      (yytype_int16 const   )134,      (yytype_int16 const   )135,      (yytype_int16 const   )272, 
        (yytype_int16 const   )273,      (yytype_int16 const   )304,      (yytype_int16 const   )63,      (yytype_int16 const   )137};
#line 1072 "bsdl_bison.c"
static yytype_int16 const   yypact___0[441]  = 
#line 1072
  {      (yytype_int16 const   )1,      (yytype_int16 const   )-326,      (yytype_int16 const   )125,      (yytype_int16 const   )97, 
        (yytype_int16 const   )96,      (yytype_int16 const   )138,      (yytype_int16 const   )142,      (yytype_int16 const   )150, 
        (yytype_int16 const   )155,      (yytype_int16 const   )180,      (yytype_int16 const   )66,      (yytype_int16 const   )183, 
        (yytype_int16 const   )186,      (yytype_int16 const   )190,      (yytype_int16 const   )69,      (yytype_int16 const   )87, 
        (yytype_int16 const   )187,      (yytype_int16 const   )29,      (yytype_int16 const   )188,      (yytype_int16 const   )189, 
        (yytype_int16 const   )184,      (yytype_int16 const   )-24,      (yytype_int16 const   )74,      (yytype_int16 const   )28, 
        (yytype_int16 const   )101,      (yytype_int16 const   )193,      (yytype_int16 const   )191,      (yytype_int16 const   )2, 
        (yytype_int16 const   )111,      (yytype_int16 const   )114,      (yytype_int16 const   )115,      (yytype_int16 const   )196, 
        (yytype_int16 const   )236,      (yytype_int16 const   )-326,      (yytype_int16 const   )192,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )194,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )195,      (yytype_int16 const   )197, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )198,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )199,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )200,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )202,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )203,      (yytype_int16 const   )201,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )20,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )204,      (yytype_int16 const   )206,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )166,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-4,      (yytype_int16 const   )-326,      (yytype_int16 const   )207,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )17,      (yytype_int16 const   )208,      (yytype_int16 const   )-326,      (yytype_int16 const   )60, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )3,      (yytype_int16 const   )209,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-15,      (yytype_int16 const   )210,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )211,      (yytype_int16 const   )-326,      (yytype_int16 const   )97, 
        (yytype_int16 const   )91,      (yytype_int16 const   )214,      (yytype_int16 const   )220,      (yytype_int16 const   )221, 
        (yytype_int16 const   )218,      (yytype_int16 const   )87,      (yytype_int16 const   )113,      (yytype_int16 const   )223, 
        (yytype_int16 const   )222,      (yytype_int16 const   )216,      (yytype_int16 const   )-326,      (yytype_int16 const   )72, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )224,      (yytype_int16 const   )225,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )205, 
        (yytype_int16 const   )43,      (yytype_int16 const   )182,      (yytype_int16 const   )-326,      (yytype_int16 const   )185, 
        (yytype_int16 const   )111,      (yytype_int16 const   )-14,      (yytype_int16 const   )226,      (yytype_int16 const   )-14, 
        (yytype_int16 const   )151,      (yytype_int16 const   )181,      (yytype_int16 const   )-326,      (yytype_int16 const   )227, 
        (yytype_int16 const   )146,      (yytype_int16 const   )114,      (yytype_int16 const   )228,      (yytype_int16 const   )177, 
        (yytype_int16 const   )-58,      (yytype_int16 const   )115,      (yytype_int16 const   )233,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )20,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )136,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )229,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )156,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )230,      (yytype_int16 const   )232,      (yytype_int16 const   )231,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )235,      (yytype_int16 const   )20,      (yytype_int16 const   )-326,      (yytype_int16 const   )234, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-4,      (yytype_int16 const   )237,      (yytype_int16 const   )238, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )239,      (yytype_int16 const   )-326,      (yytype_int16 const   )212, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )113,      (yytype_int16 const   )213,      (yytype_int16 const   )-14, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-14, 
        (yytype_int16 const   )-14,      (yytype_int16 const   )181,      (yytype_int16 const   )-326,      (yytype_int16 const   )242, 
        (yytype_int16 const   )241,      (yytype_int16 const   )-326,      (yytype_int16 const   )246,      (yytype_int16 const   )243, 
        (yytype_int16 const   )244,      (yytype_int16 const   )179,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )157,      (yytype_int16 const   )214,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )113,      (yytype_int16 const   )-326,      (yytype_int16 const   )-1,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )249,      (yytype_int16 const   )245,      (yytype_int16 const   )-326,      (yytype_int16 const   )247, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )215,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-8,      (yytype_int16 const   )254, 
        (yytype_int16 const   )217,      (yytype_int16 const   )-326,      (yytype_int16 const   )-14,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )160,      (yytype_int16 const   )242,      (yytype_int16 const   )-21, 
        (yytype_int16 const   )161,      (yytype_int16 const   )-326,      (yytype_int16 const   )246,      (yytype_int16 const   )246, 
        (yytype_int16 const   )251,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )252,      (yytype_int16 const   )-326,      (yytype_int16 const   )255,      (yytype_int16 const   )256, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )258,      (yytype_int16 const   )-4, 
        (yytype_int16 const   )259,      (yytype_int16 const   )257,      (yytype_int16 const   )-12,      (yytype_int16 const   )-9, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-2,      (yytype_int16 const   )-326,      (yytype_int16 const   )263, 
        (yytype_int16 const   )253,      (yytype_int16 const   )242,      (yytype_int16 const   )-326,      (yytype_int16 const   )164, 
        (yytype_int16 const   )-50,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )68, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )246,      (yytype_int16 const   )-326,      (yytype_int16 const   )165, 
        (yytype_int16 const   )168,      (yytype_int16 const   )246,      (yytype_int16 const   )264,      (yytype_int16 const   )132, 
        (yytype_int16 const   )267,      (yytype_int16 const   )-326,      (yytype_int16 const   )169,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )240,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )268, 
        (yytype_int16 const   )248,      (yytype_int16 const   )266,      (yytype_int16 const   )270,      (yytype_int16 const   )10, 
        (yytype_int16 const   )265,      (yytype_int16 const   )-326,      (yytype_int16 const   )172,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )271,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-50,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )173,      (yytype_int16 const   )269, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )273,      (yytype_int16 const   )274,      (yytype_int16 const   )277, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-3,      (yytype_int16 const   )-326,      (yytype_int16 const   )30, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )272,      (yytype_int16 const   )250,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )176,      (yytype_int16 const   )-326,      (yytype_int16 const   )281, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )119,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )98,      (yytype_int16 const   )159, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )260,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )275,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )89,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-12,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-48, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )282,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )283,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )261,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )276,      (yytype_int16 const   )278,      (yytype_int16 const   )30,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )262,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )120, 
        (yytype_int16 const   )280,      (yytype_int16 const   )-326,      (yytype_int16 const   )-48,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )279,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )30, 
        (yytype_int16 const   )-326};
#line 1122 "bsdl_bison.c"
static yytype_int16 const   yypgoto___0[124]  = 
#line 1122
  {      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )149,      (yytype_int16 const   )-326,      (yytype_int16 const   )134,      (yytype_int16 const   )-116, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )219,      (yytype_int16 const   )-326,      (yytype_int16 const   )82,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )284,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )285,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )103,      (yytype_int16 const   )83,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )286,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-23,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-207, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )170, 
        (yytype_int16 const   )-202,      (yytype_int16 const   )-129,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )167,      (yytype_int16 const   )-142,      (yytype_int16 const   )-139,      (yytype_int16 const   )-168, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-211,      (yytype_int16 const   )-326,      (yytype_int16 const   )11,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-325,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-53,      (yytype_int16 const   )13,      (yytype_int16 const   )-26, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )48,      (yytype_int16 const   )-47,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-86, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )171,      (yytype_int16 const   )73, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )174,      (yytype_int16 const   )-154, 
        (yytype_int16 const   )40,      (yytype_int16 const   )-177,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326};
#line 1144 "bsdl_bison.c"
static yytype_uint16 const   yytable___0[435]  = 
#line 1144
  {      (yytype_uint16 const   )172,      (yytype_uint16 const   )115,      (yytype_uint16 const   )1,      (yytype_uint16 const   )119, 
        (yytype_uint16 const   )176,      (yytype_uint16 const   )2,      (yytype_uint16 const   )257,      (yytype_uint16 const   )3, 
        (yytype_uint16 const   )4,      (yytype_uint16 const   )5,      (yytype_uint16 const   )6,      (yytype_uint16 const   )7, 
        (yytype_uint16 const   )8,      (yytype_uint16 const   )9,      (yytype_uint16 const   )10,      (yytype_uint16 const   )11, 
        (yytype_uint16 const   )12,      (yytype_uint16 const   )13,      (yytype_uint16 const   )14,      (yytype_uint16 const   )15, 
        (yytype_uint16 const   )16,      (yytype_uint16 const   )17,      (yytype_uint16 const   )18,      (yytype_uint16 const   )19, 
        (yytype_uint16 const   )182,      (yytype_uint16 const   )160,      (yytype_uint16 const   )113,      (yytype_uint16 const   )234, 
        (yytype_uint16 const   )232,      (yytype_uint16 const   )108,      (yytype_uint16 const   )95,      (yytype_uint16 const   )160, 
        (yytype_uint16 const   )225,      (yytype_uint16 const   )268,      (yytype_uint16 const   )289,      (yytype_uint16 const   )240, 
        (yytype_uint16 const   )322,      (yytype_uint16 const   )280,      (yytype_uint16 const   )156,      (yytype_uint16 const   )373, 
        (yytype_uint16 const   )324,      (yytype_uint16 const   )103,      (yytype_uint16 const   )104,      (yytype_uint16 const   )105, 
        (yytype_uint16 const   )376,      (yytype_uint16 const   )325,      (yytype_uint16 const   )377,      (yytype_uint16 const   )157, 
        (yytype_uint16 const   )374,      (yytype_uint16 const   )160,      (yytype_uint16 const   )281,      (yytype_uint16 const   )241, 
        (yytype_uint16 const   )324,      (yytype_uint16 const   )20,      (yytype_uint16 const   )378,      (yytype_uint16 const   )417, 
        (yytype_uint16 const   )379,      (yytype_uint16 const   )360,      (yytype_uint16 const   )149,      (yytype_uint16 const   )265, 
        (yytype_uint16 const   )301,      (yytype_uint16 const   )302,      (yytype_uint16 const   )150,      (yytype_uint16 const   )160, 
        (yytype_uint16 const   )265,      (yytype_uint16 const   )21,      (yytype_uint16 const   )418,      (yytype_uint16 const   )73, 
        (yytype_uint16 const   )268,      (yytype_uint16 const   )22,      (yytype_uint16 const   )80,      (yytype_uint16 const   )96, 
        (yytype_uint16 const   )23,      (yytype_uint16 const   )24,      (yytype_uint16 const   )25,      (yytype_uint16 const   )226, 
        (yytype_uint16 const   )26,      (yytype_uint16 const   )27,      (yytype_uint16 const   )174,      (yytype_uint16 const   )120, 
        (yytype_uint16 const   )315,      (yytype_uint16 const   )215,      (yytype_uint16 const   )28,      (yytype_uint16 const   )109, 
        (yytype_uint16 const   )318,      (yytype_uint16 const   )110,      (yytype_uint16 const   )290,      (yytype_uint16 const   )290, 
        (yytype_uint16 const   )300,      (yytype_uint16 const   )301,      (yytype_uint16 const   )302,      (yytype_uint16 const   )267, 
        (yytype_uint16 const   )266,      (yytype_uint16 const   )254,      (yytype_uint16 const   )175,      (yytype_uint16 const   )330, 
        (yytype_uint16 const   )171,      (yytype_uint16 const   )432,      (yytype_uint16 const   )265,      (yytype_uint16 const   )161, 
        (yytype_uint16 const   )162,      (yytype_uint16 const   )216,      (yytype_uint16 const   )112,      (yytype_uint16 const   )217, 
        (yytype_uint16 const   )74,      (yytype_uint16 const   )438,      (yytype_uint16 const   )218,      (yytype_uint16 const   )81, 
        (yytype_uint16 const   )29,      (yytype_uint16 const   )30,      (yytype_uint16 const   )84,      (yytype_uint16 const   )85, 
        (yytype_uint16 const   )123,      (yytype_uint16 const   )31,      (yytype_uint16 const   )440,      (yytype_uint16 const   )128, 
        (yytype_uint16 const   )132,      (yytype_uint16 const   )209,      (yytype_uint16 const   )366,      (yytype_uint16 const   )210, 
        (yytype_uint16 const   )307,      (yytype_uint16 const   )308,      (yytype_uint16 const   )376,      (yytype_uint16 const   )332, 
        (yytype_uint16 const   )377,      (yytype_uint16 const   )86,      (yytype_uint16 const   )334,      (yytype_uint16 const   )219, 
        (yytype_uint16 const   )220,      (yytype_uint16 const   )149,      (yytype_uint16 const   )64,      (yytype_uint16 const   )212, 
        (yytype_uint16 const   )378,      (yytype_uint16 const   )150,      (yytype_uint16 const   )379,      (yytype_uint16 const   )65, 
        (yytype_uint16 const   )395,      (yytype_uint16 const   )180,      (yytype_uint16 const   )67,      (yytype_uint16 const   )113, 
        (yytype_uint16 const   )396,      (yytype_uint16 const   )87,      (yytype_uint16 const   )303,      (yytype_uint16 const   )106, 
        (yytype_uint16 const   )107,      (yytype_uint16 const   )88,      (yytype_uint16 const   )165,      (yytype_uint16 const   )166, 
        (yytype_uint16 const   )167,      (yytype_uint16 const   )124,      (yytype_uint16 const   )89,      (yytype_uint16 const   )190, 
        (yytype_uint16 const   )129,      (yytype_uint16 const   )133,      (yytype_uint16 const   )394,      (yytype_uint16 const   )338, 
        (yytype_uint16 const   )367,      (yytype_uint16 const   )340,      (yytype_uint16 const   )341,      (yytype_uint16 const   )342, 
        (yytype_uint16 const   )343,      (yytype_uint16 const   )344,      (yytype_uint16 const   )345,      (yytype_uint16 const   )346, 
        (yytype_uint16 const   )347,      (yytype_uint16 const   )225,      (yytype_uint16 const   )393,      (yytype_uint16 const   )191, 
        (yytype_uint16 const   )192,      (yytype_uint16 const   )193,      (yytype_uint16 const   )194,      (yytype_uint16 const   )195, 
        (yytype_uint16 const   )196,      (yytype_uint16 const   )197,      (yytype_uint16 const   )198,      (yytype_uint16 const   )199, 
        (yytype_uint16 const   )200,      (yytype_uint16 const   )333,      (yytype_uint16 const   )301,      (yytype_uint16 const   )302, 
        (yytype_uint16 const   )68,      (yytype_uint16 const   )245,      (yytype_uint16 const   )407,      (yytype_uint16 const   )246, 
        (yytype_uint16 const   )69,      (yytype_uint16 const   )348,      (yytype_uint16 const   )408,      (yytype_uint16 const   )409, 
        (yytype_uint16 const   )410,      (yytype_uint16 const   )411,      (yytype_uint16 const   )412,      (yytype_uint16 const   )378, 
        (yytype_uint16 const   )70,      (yytype_uint16 const   )379,      (yytype_uint16 const   )398,      (yytype_uint16 const   )399, 
        (yytype_uint16 const   )400,      (yytype_uint16 const   )71,      (yytype_uint16 const   )401,      (yytype_uint16 const   )402, 
        (yytype_uint16 const   )403,      (yytype_uint16 const   )248,      (yytype_uint16 const   )209,      (yytype_uint16 const   )249, 
        (yytype_uint16 const   )277,      (yytype_uint16 const   )297,      (yytype_uint16 const   )305,      (yytype_uint16 const   )298, 
        (yytype_uint16 const   )306,      (yytype_uint16 const   )297,      (yytype_uint16 const   )305,      (yytype_uint16 const   )331, 
        (yytype_uint16 const   )336,      (yytype_uint16 const   )305,      (yytype_uint16 const   )351,      (yytype_uint16 const   )337, 
        (yytype_uint16 const   )352,      (yytype_uint16 const   )363,      (yytype_uint16 const   )305,      (yytype_uint16 const   )364, 
        (yytype_uint16 const   )368,      (yytype_uint16 const   )363,      (yytype_uint16 const   )72,      (yytype_uint16 const   )390, 
        (yytype_uint16 const   )78,      (yytype_uint16 const   )434,      (yytype_uint16 const   )435,      (yytype_uint16 const   )77, 
        (yytype_uint16 const   )79,      (yytype_uint16 const   )94,      (yytype_uint16 const   )101,      (yytype_uint16 const   )116, 
        (yytype_uint16 const   )99,      (yytype_uint16 const   )100,      (yytype_uint16 const   )136,      (yytype_uint16 const   )118, 
        (yytype_uint16 const   )138,      (yytype_uint16 const   )139,      (yytype_uint16 const   )166,      (yytype_uint16 const   )236, 
        (yytype_uint16 const   )155,      (yytype_uint16 const   )141,      (yytype_uint16 const   )142,      (yytype_uint16 const   )143, 
        (yytype_uint16 const   )140,      (yytype_uint16 const   )145,      (yytype_uint16 const   )148,      (yytype_uint16 const   )144, 
        (yytype_uint16 const   )146,      (yytype_uint16 const   )147,      (yytype_uint16 const   )153,      (yytype_uint16 const   )154, 
        (yytype_uint16 const   )159,      (yytype_uint16 const   )164,      (yytype_uint16 const   )173,      (yytype_uint16 const   )177, 
        (yytype_uint16 const   )178,      (yytype_uint16 const   )183,      (yytype_uint16 const   )74,      (yytype_uint16 const   )81, 
        (yytype_uint16 const   )188,      (yytype_uint16 const   )204,      (yytype_uint16 const   )208,      (yytype_uint16 const   )113, 
        (yytype_uint16 const   )96,      (yytype_uint16 const   )222,      (yytype_uint16 const   )211,      (yytype_uint16 const   )223, 
        (yytype_uint16 const   )231,      (yytype_uint16 const   )167,      (yytype_uint16 const   )239,      (yytype_uint16 const   )243, 
        (yytype_uint16 const   )276,      (yytype_uint16 const   )235,      (yytype_uint16 const   )238,      (yytype_uint16 const   )250, 
        (yytype_uint16 const   )252,      (yytype_uint16 const   )253,      (yytype_uint16 const   )247,      (yytype_uint16 const   )251, 
        (yytype_uint16 const   )124,      (yytype_uint16 const   )256,      (yytype_uint16 const   )258,      (yytype_uint16 const   )213, 
        (yytype_uint16 const   )271,      (yytype_uint16 const   )259,      (yytype_uint16 const   )260,      (yytype_uint16 const   )270, 
        (yytype_uint16 const   )179,      (yytype_uint16 const   )274,      (yytype_uint16 const   )275,      (yytype_uint16 const   )283, 
        (yytype_uint16 const   )285,      (yytype_uint16 const   )286,      (yytype_uint16 const   )287,      (yytype_uint16 const   )261, 
        (yytype_uint16 const   )294,      (yytype_uint16 const   )309,      (yytype_uint16 const   )310,      (yytype_uint16 const   )329, 
        (yytype_uint16 const   )311,      (yytype_uint16 const   )312,      (yytype_uint16 const   )313,      (yytype_uint16 const   )263, 
        (yytype_uint16 const   )316,      (yytype_uint16 const   )328,      (yytype_uint16 const   )339,      (yytype_uint16 const   )317, 
        (yytype_uint16 const   )295,      (yytype_uint16 const   )350,      (yytype_uint16 const   )356,      (yytype_uint16 const   )358, 
        (yytype_uint16 const   )289,      (yytype_uint16 const   )406,      (yytype_uint16 const   )244,      (yytype_uint16 const   )362, 
        (yytype_uint16 const   )369,      (yytype_uint16 const   )225,      (yytype_uint16 const   )370,      (yytype_uint16 const   )371, 
        (yytype_uint16 const   )353,      (yytype_uint16 const   )372,      (yytype_uint16 const   )388,      (yytype_uint16 const   )324, 
        (yytype_uint16 const   )423,      (yytype_uint16 const   )425,      (yytype_uint16 const   )427,      (yytype_uint16 const   )278, 
        (yytype_uint16 const   )262,      (yytype_uint16 const   )430,      (yytype_uint16 const   )436,      (yytype_uint16 const   )279, 
        (yytype_uint16 const   )413,      (yytype_uint16 const   )359,      (yytype_uint16 const   )224,      (yytype_uint16 const   )233, 
        (yytype_uint16 const   )361,      (yytype_uint16 const   )392,      (yytype_uint16 const   )357,      (yytype_uint16 const   )323, 
        (yytype_uint16 const   )439,      (yytype_uint16 const   )416,      (yytype_uint16 const   )437,      (yytype_uint16 const   )299, 
        (yytype_uint16 const   )237,      (yytype_uint16 const   )335,      (yytype_uint16 const   )389,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )242, 
        (yytype_uint16 const   )426,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )433,      (yytype_uint16 const   )0,      (yytype_uint16 const   )405,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )186,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )435,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )187, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )189,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )207};
#line 1192 "bsdl_bison.c"
static yytype_int16 const   yycheck___0[435]  = 
#line 1192
  {      (yytype_int16 const   )129,      (yytype_int16 const   )24,      (yytype_int16 const   )1,      (yytype_int16 const   )1, 
        (yytype_int16 const   )133,      (yytype_int16 const   )4,      (yytype_int16 const   )213,      (yytype_int16 const   )6, 
        (yytype_int16 const   )7,      (yytype_int16 const   )8,      (yytype_int16 const   )9,      (yytype_int16 const   )10, 
        (yytype_int16 const   )11,      (yytype_int16 const   )12,      (yytype_int16 const   )13,      (yytype_int16 const   )14, 
        (yytype_int16 const   )15,      (yytype_int16 const   )16,      (yytype_int16 const   )17,      (yytype_int16 const   )18, 
        (yytype_int16 const   )19,      (yytype_int16 const   )20,      (yytype_int16 const   )21,      (yytype_int16 const   )22, 
        (yytype_int16 const   )140,      (yytype_int16 const   )46,      (yytype_int16 const   )38,      (yytype_int16 const   )169, 
        (yytype_int16 const   )167,      (yytype_int16 const   )1,      (yytype_int16 const   )1,      (yytype_int16 const   )46, 
        (yytype_int16 const   )46,      (yytype_int16 const   )235,      (yytype_int16 const   )42,      (yytype_int16 const   )93, 
        (yytype_int16 const   )45,      (yytype_int16 const   )38,      (yytype_int16 const   )42,      (yytype_int16 const   )42, 
        (yytype_int16 const   )42,      (yytype_int16 const   )65,      (yytype_int16 const   )66,      (yytype_int16 const   )67, 
        (yytype_int16 const   )92,      (yytype_int16 const   )47,      (yytype_int16 const   )94,      (yytype_int16 const   )51, 
        (yytype_int16 const   )51,      (yytype_int16 const   )46,      (yytype_int16 const   )51,      (yytype_int16 const   )109, 
        (yytype_int16 const   )42,      (yytype_int16 const   )52,      (yytype_int16 const   )102,      (yytype_int16 const   )103, 
        (yytype_int16 const   )104,      (yytype_int16 const   )47,      (yytype_int16 const   )38,      (yytype_int16 const   )227, 
        (yytype_int16 const   )110,      (yytype_int16 const   )111,      (yytype_int16 const   )42,      (yytype_int16 const   )46, 
        (yytype_int16 const   )232,      (yytype_int16 const   )64,      (yytype_int16 const   )391,      (yytype_int16 const   )1, 
        (yytype_int16 const   )270,      (yytype_int16 const   )68,      (yytype_int16 const   )1,      (yytype_int16 const   )42, 
        (yytype_int16 const   )71,      (yytype_int16 const   )72,      (yytype_int16 const   )73,      (yytype_int16 const   )89, 
        (yytype_int16 const   )75,      (yytype_int16 const   )76,      (yytype_int16 const   )93,      (yytype_int16 const   )77, 
        (yytype_int16 const   )287,      (yytype_int16 const   )38,      (yytype_int16 const   )81,      (yytype_int16 const   )55, 
        (yytype_int16 const   )96,      (yytype_int16 const   )57,      (yytype_int16 const   )95,      (yytype_int16 const   )95, 
        (yytype_int16 const   )109,      (yytype_int16 const   )110,      (yytype_int16 const   )111,      (yytype_int16 const   )233, 
        (yytype_int16 const   )231,      (yytype_int16 const   )209,      (yytype_int16 const   )109,      (yytype_int16 const   )297, 
        (yytype_int16 const   )93,      (yytype_int16 const   )422,      (yytype_int16 const   )266,      (yytype_int16 const   )82, 
        (yytype_int16 const   )83,      (yytype_int16 const   )58,      (yytype_int16 const   )1,      (yytype_int16 const   )60, 
        (yytype_int16 const   )38,      (yytype_int16 const   )430,      (yytype_int16 const   )63,      (yytype_int16 const   )38, 
        (yytype_int16 const   )107,      (yytype_int16 const   )108,      (yytype_int16 const   )23,      (yytype_int16 const   )24, 
        (yytype_int16 const   )1,      (yytype_int16 const   )112,      (yytype_int16 const   )439,      (yytype_int16 const   )1, 
        (yytype_int16 const   )1,      (yytype_int16 const   )45,      (yytype_int16 const   )329,      (yytype_int16 const   )47, 
        (yytype_int16 const   )274,      (yytype_int16 const   )275,      (yytype_int16 const   )92,      (yytype_int16 const   )300, 
        (yytype_int16 const   )94,      (yytype_int16 const   )38,      (yytype_int16 const   )303,      (yytype_int16 const   )84, 
        (yytype_int16 const   )85,      (yytype_int16 const   )38,      (yytype_int16 const   )5,      (yytype_int16 const   )154, 
        (yytype_int16 const   )102,      (yytype_int16 const   )42,      (yytype_int16 const   )104,      (yytype_int16 const   )38, 
        (yytype_int16 const   )38,      (yytype_int16 const   )46,      (yytype_int16 const   )42,      (yytype_int16 const   )38, 
        (yytype_int16 const   )42,      (yytype_int16 const   )54,      (yytype_int16 const   )271,      (yytype_int16 const   )69, 
        (yytype_int16 const   )70,      (yytype_int16 const   )58,      (yytype_int16 const   )86,      (yytype_int16 const   )87, 
        (yytype_int16 const   )88,      (yytype_int16 const   )38,      (yytype_int16 const   )63,      (yytype_int16 const   )38, 
        (yytype_int16 const   )38,      (yytype_int16 const   )38,      (yytype_int16 const   )365,      (yytype_int16 const   )309, 
        (yytype_int16 const   )333,      (yytype_int16 const   )25,      (yytype_int16 const   )26,      (yytype_int16 const   )27, 
        (yytype_int16 const   )28,      (yytype_int16 const   )29,      (yytype_int16 const   )30,      (yytype_int16 const   )31, 
        (yytype_int16 const   )32,      (yytype_int16 const   )46,      (yytype_int16 const   )47,      (yytype_int16 const   )54, 
        (yytype_int16 const   )55,      (yytype_int16 const   )56,      (yytype_int16 const   )57,      (yytype_int16 const   )58, 
        (yytype_int16 const   )59,      (yytype_int16 const   )60,      (yytype_int16 const   )61,      (yytype_int16 const   )62, 
        (yytype_int16 const   )63,      (yytype_int16 const   )109,      (yytype_int16 const   )110,      (yytype_int16 const   )111, 
        (yytype_int16 const   )42,      (yytype_int16 const   )45,      (yytype_int16 const   )93,      (yytype_int16 const   )47, 
        (yytype_int16 const   )42,      (yytype_int16 const   )53,      (yytype_int16 const   )97,      (yytype_int16 const   )98, 
        (yytype_int16 const   )99,      (yytype_int16 const   )100,      (yytype_int16 const   )101,      (yytype_int16 const   )102, 
        (yytype_int16 const   )42,      (yytype_int16 const   )104,      (yytype_int16 const   )35,      (yytype_int16 const   )36, 
        (yytype_int16 const   )37,      (yytype_int16 const   )42,      (yytype_int16 const   )39,      (yytype_int16 const   )40, 
        (yytype_int16 const   )41,      (yytype_int16 const   )45,      (yytype_int16 const   )45,      (yytype_int16 const   )47, 
        (yytype_int16 const   )47,      (yytype_int16 const   )45,      (yytype_int16 const   )45,      (yytype_int16 const   )47, 
        (yytype_int16 const   )47,      (yytype_int16 const   )45,      (yytype_int16 const   )45,      (yytype_int16 const   )47, 
        (yytype_int16 const   )47,      (yytype_int16 const   )45,      (yytype_int16 const   )45,      (yytype_int16 const   )47, 
        (yytype_int16 const   )47,      (yytype_int16 const   )45,      (yytype_int16 const   )45,      (yytype_int16 const   )47, 
        (yytype_int16 const   )47,      (yytype_int16 const   )45,      (yytype_int16 const   )42,      (yytype_int16 const   )47, 
        (yytype_int16 const   )38,      (yytype_int16 const   )105,      (yytype_int16 const   )106,      (yytype_int16 const   )44, 
        (yytype_int16 const   )38,      (yytype_int16 const   )42,      (yytype_int16 const   )46,      (yytype_int16 const   )38, 
        (yytype_int16 const   )44,      (yytype_int16 const   )44,      (yytype_int16 const   )38,      (yytype_int16 const   )44, 
        (yytype_int16 const   )0,      (yytype_int16 const   )45,      (yytype_int16 const   )87,      (yytype_int16 const   )93, 
        (yytype_int16 const   )74,      (yytype_int16 const   )46,      (yytype_int16 const   )45,      (yytype_int16 const   )45, 
        (yytype_int16 const   )50,      (yytype_int16 const   )45,      (yytype_int16 const   )45,      (yytype_int16 const   )48, 
        (yytype_int16 const   )46,      (yytype_int16 const   )46,      (yytype_int16 const   )46,      (yytype_int16 const   )45, 
        (yytype_int16 const   )45,      (yytype_int16 const   )45,      (yytype_int16 const   )45,      (yytype_int16 const   )45, 
        (yytype_int16 const   )45,      (yytype_int16 const   )43,      (yytype_int16 const   )38,      (yytype_int16 const   )38, 
        (yytype_int16 const   )42,      (yytype_int16 const   )38,      (yytype_int16 const   )46,      (yytype_int16 const   )38, 
        (yytype_int16 const   )42,      (yytype_int16 const   )83,      (yytype_int16 const   )42,      (yytype_int16 const   )82, 
        (yytype_int16 const   )42,      (yytype_int16 const   )88,      (yytype_int16 const   )93,      (yytype_int16 const   )38, 
        (yytype_int16 const   )93,      (yytype_int16 const   )46,      (yytype_int16 const   )46,      (yytype_int16 const   )45, 
        (yytype_int16 const   )45,      (yytype_int16 const   )42,      (yytype_int16 const   )49,      (yytype_int16 const   )47, 
        (yytype_int16 const   )38,      (yytype_int16 const   )47,      (yytype_int16 const   )45,      (yytype_int16 const   )78, 
        (yytype_int16 const   )38,      (yytype_int16 const   )47,      (yytype_int16 const   )47,      (yytype_int16 const   )46, 
        (yytype_int16 const   )139,      (yytype_int16 const   )46,      (yytype_int16 const   )46,      (yytype_int16 const   )42, 
        (yytype_int16 const   )47,      (yytype_int16 const   )46,      (yytype_int16 const   )79,      (yytype_int16 const   )83, 
        (yytype_int16 const   )42,      (yytype_int16 const   )46,      (yytype_int16 const   )46,      (yytype_int16 const   )46, 
        (yytype_int16 const   )45,      (yytype_int16 const   )45,      (yytype_int16 const   )44,      (yytype_int16 const   )90, 
        (yytype_int16 const   )45,      (yytype_int16 const   )42,      (yytype_int16 const   )42,      (yytype_int16 const   )50, 
        (yytype_int16 const   )91,      (yytype_int16 const   )42,      (yytype_int16 const   )42,      (yytype_int16 const   )45, 
        (yytype_int16 const   )42,      (yytype_int16 const   )38,      (yytype_int16 const   )180,      (yytype_int16 const   )50, 
        (yytype_int16 const   )47,      (yytype_int16 const   )46,      (yytype_int16 const   )45,      (yytype_int16 const   )45, 
        (yytype_int16 const   )80,      (yytype_int16 const   )44,      (yytype_int16 const   )50,      (yytype_int16 const   )42, 
        (yytype_int16 const   )42,      (yytype_int16 const   )42,      (yytype_int16 const   )50,      (yytype_int16 const   )245, 
        (yytype_int16 const   )225,      (yytype_int16 const   )51,      (yytype_int16 const   )50,      (yytype_int16 const   )248, 
        (yytype_int16 const   )385,      (yytype_int16 const   )322,      (yytype_int16 const   )164,      (yytype_int16 const   )168, 
        (yytype_int16 const   )323,      (yytype_int16 const   )363,      (yytype_int16 const   )90,      (yytype_int16 const   )291, 
        (yytype_int16 const   )430,      (yytype_int16 const   )388,      (yytype_int16 const   )428,      (yytype_int16 const   )270, 
        (yytype_int16 const   )173,      (yytype_int16 const   )305,      (yytype_int16 const   )96,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )177, 
        (yytype_int16 const   )91,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )94,      (yytype_int16 const   )-1,      (yytype_int16 const   )98,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )142,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )106,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )143, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )145,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )148};
#line 1242 "bsdl_bison.c"
static yytype_uint8 const   yystos___0[441]  = 
#line 1242
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )1,      (yytype_uint8 const   )4,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )7,      (yytype_uint8 const   )8,      (yytype_uint8 const   )9,      (yytype_uint8 const   )10, 
        (yytype_uint8 const   )11,      (yytype_uint8 const   )12,      (yytype_uint8 const   )13,      (yytype_uint8 const   )14, 
        (yytype_uint8 const   )15,      (yytype_uint8 const   )16,      (yytype_uint8 const   )17,      (yytype_uint8 const   )18, 
        (yytype_uint8 const   )19,      (yytype_uint8 const   )20,      (yytype_uint8 const   )21,      (yytype_uint8 const   )22, 
        (yytype_uint8 const   )52,      (yytype_uint8 const   )64,      (yytype_uint8 const   )68,      (yytype_uint8 const   )71, 
        (yytype_uint8 const   )72,      (yytype_uint8 const   )73,      (yytype_uint8 const   )75,      (yytype_uint8 const   )76, 
        (yytype_uint8 const   )81,      (yytype_uint8 const   )107,      (yytype_uint8 const   )108,      (yytype_uint8 const   )112, 
        (yytype_uint8 const   )115,      (yytype_uint8 const   )116,      (yytype_uint8 const   )117,      (yytype_uint8 const   )122, 
        (yytype_uint8 const   )123,      (yytype_uint8 const   )124,      (yytype_uint8 const   )125,      (yytype_uint8 const   )126, 
        (yytype_uint8 const   )127,      (yytype_uint8 const   )128,      (yytype_uint8 const   )133,      (yytype_uint8 const   )134, 
        (yytype_uint8 const   )135,      (yytype_uint8 const   )136,      (yytype_uint8 const   )139,      (yytype_uint8 const   )140, 
        (yytype_uint8 const   )141,      (yytype_uint8 const   )149,      (yytype_uint8 const   )150,      (yytype_uint8 const   )160, 
        (yytype_uint8 const   )164,      (yytype_uint8 const   )165,      (yytype_uint8 const   )166,      (yytype_uint8 const   )167, 
        (yytype_uint8 const   )169,      (yytype_uint8 const   )172,      (yytype_uint8 const   )174,      (yytype_uint8 const   )175, 
        (yytype_uint8 const   )183,      (yytype_uint8 const   )226,      (yytype_uint8 const   )230,      (yytype_uint8 const   )236, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )38,      (yytype_uint8 const   )118,      (yytype_uint8 const   )42, 
        (yytype_uint8 const   )42,      (yytype_uint8 const   )42,      (yytype_uint8 const   )42,      (yytype_uint8 const   )42, 
        (yytype_uint8 const   )42,      (yytype_uint8 const   )1,      (yytype_uint8 const   )38,      (yytype_uint8 const   )129, 
        (yytype_uint8 const   )130,      (yytype_uint8 const   )44,      (yytype_uint8 const   )38,      (yytype_uint8 const   )38, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )38,      (yytype_uint8 const   )137,      (yytype_uint8 const   )138, 
        (yytype_uint8 const   )23,      (yytype_uint8 const   )24,      (yytype_uint8 const   )38,      (yytype_uint8 const   )54, 
        (yytype_uint8 const   )58,      (yytype_uint8 const   )63,      (yytype_uint8 const   )142,      (yytype_uint8 const   )143, 
        (yytype_uint8 const   )144,      (yytype_uint8 const   )145,      (yytype_uint8 const   )42,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )42,      (yytype_uint8 const   )151,      (yytype_uint8 const   )152,      (yytype_uint8 const   )44, 
        (yytype_uint8 const   )44,      (yytype_uint8 const   )46,      (yytype_uint8 const   )161,      (yytype_uint8 const   )65, 
        (yytype_uint8 const   )66,      (yytype_uint8 const   )67,      (yytype_uint8 const   )69,      (yytype_uint8 const   )70, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )55,      (yytype_uint8 const   )57,      (yytype_uint8 const   )168, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )38,      (yytype_uint8 const   )170,      (yytype_uint8 const   )171, 
        (yytype_uint8 const   )38,      (yytype_uint8 const   )173,      (yytype_uint8 const   )44,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )77,      (yytype_uint8 const   )176,      (yytype_uint8 const   )177,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )38,      (yytype_uint8 const   )184,      (yytype_uint8 const   )185,      (yytype_uint8 const   )186, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )38,      (yytype_uint8 const   )227,      (yytype_uint8 const   )228, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )38,      (yytype_uint8 const   )231,      (yytype_uint8 const   )232, 
        (yytype_uint8 const   )38,      (yytype_uint8 const   )237,      (yytype_uint8 const   )0,      (yytype_uint8 const   )45, 
        (yytype_uint8 const   )50,      (yytype_uint8 const   )46,      (yytype_uint8 const   )45,      (yytype_uint8 const   )45, 
        (yytype_uint8 const   )48,      (yytype_uint8 const   )45,      (yytype_uint8 const   )46,      (yytype_uint8 const   )46, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )38,      (yytype_uint8 const   )42,      (yytype_uint8 const   )120, 
        (yytype_uint8 const   )121,      (yytype_uint8 const   )46,      (yytype_uint8 const   )45,      (yytype_uint8 const   )74, 
        (yytype_uint8 const   )42,      (yytype_uint8 const   )51,      (yytype_uint8 const   )181,      (yytype_uint8 const   )45, 
        (yytype_uint8 const   )46,      (yytype_uint8 const   )82,      (yytype_uint8 const   )83,      (yytype_uint8 const   )187, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )86,      (yytype_uint8 const   )87,      (yytype_uint8 const   )88, 
        (yytype_uint8 const   )189,      (yytype_uint8 const   )190,      (yytype_uint8 const   )191,      (yytype_uint8 const   )93, 
        (yytype_uint8 const   )187,      (yytype_uint8 const   )45,      (yytype_uint8 const   )93,      (yytype_uint8 const   )109, 
        (yytype_uint8 const   )187,      (yytype_uint8 const   )45,      (yytype_uint8 const   )45,      (yytype_uint8 const   )118, 
        (yytype_uint8 const   )46,      (yytype_uint8 const   )119,      (yytype_uint8 const   )121,      (yytype_uint8 const   )43, 
        (yytype_uint8 const   )131,      (yytype_uint8 const   )132,      (yytype_uint8 const   )130,      (yytype_uint8 const   )138, 
        (yytype_uint8 const   )42,      (yytype_uint8 const   )143,      (yytype_uint8 const   )38,      (yytype_uint8 const   )54, 
        (yytype_uint8 const   )55,      (yytype_uint8 const   )56,      (yytype_uint8 const   )57,      (yytype_uint8 const   )58, 
        (yytype_uint8 const   )59,      (yytype_uint8 const   )60,      (yytype_uint8 const   )61,      (yytype_uint8 const   )62, 
        (yytype_uint8 const   )63,      (yytype_uint8 const   )146,      (yytype_uint8 const   )147,      (yytype_uint8 const   )148, 
        (yytype_uint8 const   )38,      (yytype_uint8 const   )153,      (yytype_uint8 const   )154,      (yytype_uint8 const   )152, 
        (yytype_uint8 const   )46,      (yytype_uint8 const   )45,      (yytype_uint8 const   )47,      (yytype_uint8 const   )42, 
        (yytype_uint8 const   )171,      (yytype_uint8 const   )78,      (yytype_uint8 const   )178,      (yytype_uint8 const   )38, 
        (yytype_uint8 const   )58,      (yytype_uint8 const   )60,      (yytype_uint8 const   )63,      (yytype_uint8 const   )84, 
        (yytype_uint8 const   )85,      (yytype_uint8 const   )188,      (yytype_uint8 const   )83,      (yytype_uint8 const   )82, 
        (yytype_uint8 const   )185,      (yytype_uint8 const   )46,      (yytype_uint8 const   )89,      (yytype_uint8 const   )192, 
        (yytype_uint8 const   )193,      (yytype_uint8 const   )194,      (yytype_uint8 const   )198,      (yytype_uint8 const   )42, 
        (yytype_uint8 const   )192,      (yytype_uint8 const   )190,      (yytype_uint8 const   )191,      (yytype_uint8 const   )46, 
        (yytype_uint8 const   )93,      (yytype_uint8 const   )228,      (yytype_uint8 const   )46,      (yytype_uint8 const   )93, 
        (yytype_uint8 const   )93,      (yytype_uint8 const   )109,      (yytype_uint8 const   )232,      (yytype_uint8 const   )38, 
        (yytype_uint8 const   )120,      (yytype_uint8 const   )45,      (yytype_uint8 const   )47,      (yytype_uint8 const   )49, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )47,      (yytype_uint8 const   )45,      (yytype_uint8 const   )47, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )42,      (yytype_uint8 const   )121,      (yytype_uint8 const   )162, 
        (yytype_uint8 const   )47,      (yytype_uint8 const   )181,      (yytype_uint8 const   )45,      (yytype_uint8 const   )47, 
        (yytype_uint8 const   )47,      (yytype_uint8 const   )83,      (yytype_uint8 const   )147,      (yytype_uint8 const   )90, 
        (yytype_uint8 const   )195,      (yytype_uint8 const   )193,      (yytype_uint8 const   )192,      (yytype_uint8 const   )191, 
        (yytype_uint8 const   )186,      (yytype_uint8 const   )229,      (yytype_uint8 const   )46,      (yytype_uint8 const   )38, 
        (yytype_uint8 const   )233,      (yytype_uint8 const   )234,      (yytype_uint8 const   )46,      (yytype_uint8 const   )46, 
        (yytype_uint8 const   )93,      (yytype_uint8 const   )47,      (yytype_uint8 const   )132,      (yytype_uint8 const   )148, 
        (yytype_uint8 const   )38,      (yytype_uint8 const   )51,      (yytype_uint8 const   )155,      (yytype_uint8 const   )42, 
        (yytype_uint8 const   )158,      (yytype_uint8 const   )47,      (yytype_uint8 const   )46,      (yytype_uint8 const   )79, 
        (yytype_uint8 const   )179,      (yytype_uint8 const   )42,      (yytype_uint8 const   )95,      (yytype_uint8 const   )199, 
        (yytype_uint8 const   )200,      (yytype_uint8 const   )215,      (yytype_uint8 const   )42,      (yytype_uint8 const   )91, 
        (yytype_uint8 const   )196,      (yytype_uint8 const   )45,      (yytype_uint8 const   )47,      (yytype_uint8 const   )229, 
        (yytype_uint8 const   )109,      (yytype_uint8 const   )110,      (yytype_uint8 const   )111,      (yytype_uint8 const   )187, 
        (yytype_uint8 const   )235,      (yytype_uint8 const   )45,      (yytype_uint8 const   )47,      (yytype_uint8 const   )233, 
        (yytype_uint8 const   )233,      (yytype_uint8 const   )46,      (yytype_uint8 const   )46,      (yytype_uint8 const   )45, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )44,      (yytype_uint8 const   )163,      (yytype_uint8 const   )181, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )50,      (yytype_uint8 const   )96,      (yytype_uint8 const   )171, 
        (yytype_uint8 const   )216,      (yytype_uint8 const   )217,      (yytype_uint8 const   )45,      (yytype_uint8 const   )215, 
        (yytype_uint8 const   )42,      (yytype_uint8 const   )47,      (yytype_uint8 const   )208,      (yytype_uint8 const   )209, 
        (yytype_uint8 const   )42,      (yytype_uint8 const   )46,      (yytype_uint8 const   )186,      (yytype_uint8 const   )47, 
        (yytype_uint8 const   )235,      (yytype_uint8 const   )109,      (yytype_uint8 const   )235,      (yytype_uint8 const   )234, 
        (yytype_uint8 const   )47,      (yytype_uint8 const   )47,      (yytype_uint8 const   )233,      (yytype_uint8 const   )42, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )26,      (yytype_uint8 const   )27,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )30,      (yytype_uint8 const   )31,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )53,      (yytype_uint8 const   )156,      (yytype_uint8 const   )42,      (yytype_uint8 const   )45, 
        (yytype_uint8 const   )47,      (yytype_uint8 const   )80,      (yytype_uint8 const   )180,      (yytype_uint8 const   )201, 
        (yytype_uint8 const   )42,      (yytype_uint8 const   )90,      (yytype_uint8 const   )45,      (yytype_uint8 const   )200, 
        (yytype_uint8 const   )47,      (yytype_uint8 const   )208,      (yytype_uint8 const   )50,      (yytype_uint8 const   )45, 
        (yytype_uint8 const   )47,      (yytype_uint8 const   )197,      (yytype_uint8 const   )198,      (yytype_uint8 const   )235, 
        (yytype_uint8 const   )47,      (yytype_uint8 const   )47,      (yytype_uint8 const   )45,      (yytype_uint8 const   )45, 
        (yytype_uint8 const   )44,      (yytype_uint8 const   )42,      (yytype_uint8 const   )51,      (yytype_uint8 const   )182, 
        (yytype_uint8 const   )92,      (yytype_uint8 const   )94,      (yytype_uint8 const   )102,      (yytype_uint8 const   )104, 
        (yytype_uint8 const   )202,      (yytype_uint8 const   )203,      (yytype_uint8 const   )204,      (yytype_uint8 const   )206, 
        (yytype_uint8 const   )207,      (yytype_uint8 const   )218,      (yytype_uint8 const   )221,      (yytype_uint8 const   )223, 
        (yytype_uint8 const   )50,      (yytype_uint8 const   )96,      (yytype_uint8 const   )47,      (yytype_uint8 const   )210, 
        (yytype_uint8 const   )209,      (yytype_uint8 const   )47,      (yytype_uint8 const   )198,      (yytype_uint8 const   )38, 
        (yytype_uint8 const   )42,      (yytype_uint8 const   )157,      (yytype_uint8 const   )35,      (yytype_uint8 const   )36, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )39,      (yytype_uint8 const   )40,      (yytype_uint8 const   )41, 
        (yytype_uint8 const   )159,      (yytype_uint8 const   )98,      (yytype_uint8 const   )38,      (yytype_uint8 const   )93, 
        (yytype_uint8 const   )97,      (yytype_uint8 const   )98,      (yytype_uint8 const   )99,      (yytype_uint8 const   )100, 
        (yytype_uint8 const   )101,      (yytype_uint8 const   )207,      (yytype_uint8 const   )219,      (yytype_uint8 const   )220, 
        (yytype_uint8 const   )216,      (yytype_uint8 const   )103,      (yytype_uint8 const   )202,      (yytype_uint8 const   )211, 
        (yytype_uint8 const   )212,      (yytype_uint8 const   )213,      (yytype_uint8 const   )222,      (yytype_uint8 const   )42, 
        (yytype_uint8 const   )205,      (yytype_uint8 const   )42,      (yytype_uint8 const   )91,      (yytype_uint8 const   )50, 
        (yytype_uint8 const   )224,      (yytype_uint8 const   )225,      (yytype_uint8 const   )51,      (yytype_uint8 const   )214, 
        (yytype_uint8 const   )202,      (yytype_uint8 const   )94,      (yytype_uint8 const   )105,      (yytype_uint8 const   )106, 
        (yytype_uint8 const   )50,      (yytype_uint8 const   )225,      (yytype_uint8 const   )202,      (yytype_uint8 const   )222, 
        (yytype_uint8 const   )202};
#line 1785 "bsdl_bison.c"
static void yydestruct___0(char const   *yymsg , int yytype , YYSTYPE *yyvaluep ,
                           bsdl_parser_priv_t *priv_data ) 
{ 
  char *__cil_tmp5 ;

  {
#line 1799
  if (! yymsg) {
#line 1800
    yymsg = "Deleting";
  }
  {
#line 1806
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 1807
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1809
  return;
}
}
#line 1847 "bsdl_bison.c"
int bsdlparse(bsdl_parser_priv_t *priv_data ) 
{ 
  int bsdlchar ;
  YYSTYPE bsdllval ;
  int bsdlnerrs ;
  int yystate ;
  int yyerrstatus ;
  yytype_int16 yyssa[200] ;
  yytype_int16 *yyss ;
  yytype_int16 *yyssp ;
  YYSTYPE yyvsa[200] ;
  YYSTYPE *yyvs ;
  YYSTYPE *yyvsp ;
  unsigned int yystacksize ;
  int yyn ;
  int yyresult ;
  int yytoken ;
  YYSTYPE yyval ;
  int yylen ;
  unsigned int yysize ;
  yytype_int16 *yyss1 ;
  union yyalloc *yyptr ;
  void *tmp ;
  unsigned int yynewbytes ;
  unsigned int yynewbytes___0 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  void *__cil_tmp38 ;
  void *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;

  {
#line 1907
  yylen = 0;
#line 1909
  yytoken = 0;
#line 1910
  yyss = yyssa;
#line 1911
  yyvs = yyvsa;
#line 1912
  yystacksize = 200U;
#line 1916
  yystate = 0;
#line 1917
  yyerrstatus = 0;
#line 1918
  bsdlnerrs = 0;
#line 1919
  bsdlchar = -2;
#line 1925
  yyssp = yyss;
#line 1926
  yyvsp = yyvs;
#line 1928
  goto yysetstate;
  yynewstate: 
#line 1936
  yyssp ++;
  yysetstate: 
#line 1939
  *yyssp = (yytype_int16 )yystate;
#line 1941
  if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1944
    yysize = (unsigned int )((yyssp - yyss) + 1L);
#line 1971
    if (10000U <= yystacksize) {
#line 1972
      goto yyexhaustedlab;
    }
#line 1973
    yystacksize *= 2U;
#line 1974
    if (10000U < yystacksize) {
#line 1975
      yystacksize = 10000U;
    }
    {
#line 1978
    yyss1 = yyss;
#line 1979
    tmp = malloc((size_t )((unsigned long )yystacksize * (sizeof(yytype_int16 ) + sizeof(YYSTYPE )) + (sizeof(union yyalloc ) - 1UL)));
#line 1979
    yyptr = (union yyalloc *)tmp;
    }
#line 1981
    if (! yyptr) {
#line 1982
      goto yyexhaustedlab;
    }
    {
#line 1983
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1983
      __builtin_memcpy((void *)(& yyptr->yyss_alloc), (void const   *)yyss, (unsigned long )yysize * sizeof(*yyss));
#line 1983
      yyss = & yyptr->yyss_alloc;
#line 1983
      yynewbytes = (unsigned int )((unsigned long )yystacksize * sizeof(*yyss) + (sizeof(union yyalloc ) - 1UL));
#line 1983
      yyptr += (unsigned long )yynewbytes / sizeof(*yyptr);
      }
#line 1983
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1984
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1984
      __builtin_memcpy((void *)(& yyptr->yyvs_alloc), (void const   *)yyvs, (unsigned long )yysize * sizeof(*yyvs));
#line 1984
      yyvs = & yyptr->yyvs_alloc;
#line 1984
      yynewbytes___0 = (unsigned int )((unsigned long )yystacksize * sizeof(*yyvs) + (sizeof(union yyalloc ) - 1UL));
#line 1984
      yyptr += (unsigned long )yynewbytes___0 / sizeof(*yyptr);
      }
#line 1984
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1986
    if ((unsigned long )yyss1 != (unsigned long )(yyssa)) {
      {
#line 1987
      free((void *)yyss1);
      }
    }
#line 1992
    yyssp = (yyss + yysize) - 1;
#line 1993
    yyvsp = (yyvs + yysize) - 1;
#line 1998
    if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1999
      goto yyabortlab;
    }
  }
#line 2004
  if (yystate == 138) {
#line 2005
    goto yyacceptlab;
  }
#line 2007
  goto yybackup;
  yybackup: 
#line 2018
  yyn = (int )yypact___0[yystate];
#line 2019
  if (yyn == -326) {
#line 2020
    goto yydefault;
  }
#line 2025
  if (bsdlchar == -2) {
    {
#line 2028
    bsdlchar = bsdllex(& bsdllval, priv_data->scanner);
    }
  }
#line 2031
  if (bsdlchar <= 0) {
#line 2033
    yytoken = 0;
#line 2033
    bsdlchar = yytoken;
  } else
#line 2038
  if ((unsigned int )bsdlchar <= 368U) {
#line 2038
    yytoken = (int )yytranslate___0[bsdlchar];
  } else {
#line 2038
    yytoken = 2;
  }
#line 2044
  yyn += yytoken;
#line 2045
  if (yyn < 0) {
#line 2046
    goto yydefault;
  } else
#line 2045
  if (434 < yyn) {
#line 2046
    goto yydefault;
  } else
#line 2045
  if ((int const   )yycheck___0[yyn] != (int const   )yytoken) {
#line 2046
    goto yydefault;
  }
#line 2047
  yyn = (int )yytable___0[yyn];
#line 2048
  if (yyn <= 0) {
#line 2050
    if (yyn == 0) {
#line 2051
      goto yyerrlab;
    } else
#line 2050
    if (yyn == -1) {
#line 2051
      goto yyerrlab;
    }
#line 2052
    yyn = - yyn;
#line 2053
    goto yyreduce;
  }
#line 2058
  if (yyerrstatus) {
#line 2059
    yyerrstatus --;
  }
#line 2065
  bsdlchar = -2;
#line 2067
  yystate = yyn;
#line 2068
  yyvsp ++;
#line 2068
  *yyvsp = bsdllval;
#line 2070
  goto yynewstate;
  yydefault: 
#line 2077
  yyn = (int )yydefact___0[yystate];
#line 2078
  if (yyn == 0) {
#line 2079
    goto yyerrlab;
  }
#line 2080
  goto yyreduce;
  yyreduce: 
#line 2088
  yylen = (int )yyr2___0[yyn];
#line 2098
  yyval = *(yyvsp + (1 - yylen));
  {
#line 2104
  if (yyn == 23) {
#line 2104
    goto case_23;
  }
#line 263
  if (yyn == 27) {
#line 263 "bsdl_bison.y"
    goto case_27;
  }
#line 275
  if (yyn == 32) {
#line 275
    goto case_32;
  }
#line 284
  if (yyn == 33) {
#line 284
    goto case_33;
  }
#line 286
  if (yyn == 40) {
#line 286
    goto case_40;
  }
#line 312
  if (yyn == 44) {
#line 312
    goto case_44;
  }
#line 326
  if (yyn == 45) {
#line 326
    goto case_45;
  }
#line 329
  if (yyn == 46) {
#line 329
    goto case_46;
  }
#line 332
  if (yyn == 47) {
#line 332
    goto case_47;
  }
#line 339
  if (yyn == 48) {
#line 339
    goto case_48;
  }
#line 342
  if (yyn == 49) {
#line 342
    goto case_49;
  }
#line 347
  if (yyn == 50) {
#line 347
    goto case_50;
  }
#line 352
  if (yyn == 51) {
#line 352
    goto case_51;
  }
#line 357
  if (yyn == 55) {
#line 357
    goto case_55;
  }
#line 370
  if (yyn == 56) {
#line 370
    goto case_56;
  }
#line 373
  if (yyn == 57) {
#line 373
    goto case_57;
  }
#line 378
  if (yyn == 58) {
#line 378
    goto case_58;
  }
#line 383
  if (yyn == 62) {
#line 383
    goto case_62;
  }
#line 393
  if (yyn == 63) {
#line 393
    goto case_63;
  }
#line 396
  if (yyn == 64) {
#line 396
    goto case_64;
  }
#line 398
  if (yyn == 65) {
#line 398
    goto case_65;
  }
#line 401
  if (yyn == 66) {
#line 401
    goto case_66;
  }
#line 403
  if (yyn == 67) {
#line 403
    goto case_67;
  }
#line 405
  if (yyn == 68) {
#line 405
    goto case_68;
  }
#line 407
  if (yyn == 69) {
#line 407
    goto case_69;
  }
#line 409
  if (yyn == 72) {
#line 409
    goto case_72;
  }
#line 415
  if (yyn == 73) {
#line 415
    goto case_73;
  }
#line 417
  if (yyn == 74) {
#line 417
    goto case_74;
  }
#line 419
  if (yyn == 75) {
#line 419
    goto case_75;
  }
#line 421
  if (yyn == 76) {
#line 421
    goto case_76;
  }
#line 423
  if (yyn == 77) {
#line 423
    goto case_77;
  }
#line 425
  if (yyn == 78) {
#line 425
    goto case_78;
  }
#line 427
  if (yyn == 79) {
#line 427
    goto case_79;
  }
#line 429
  if (yyn == 80) {
#line 429
    goto case_80;
  }
#line 431
  if (yyn == 81) {
#line 431
    goto case_81;
  }
#line 433
  if (yyn == 82) {
#line 433
    goto case_82;
  }
#line 435
  if (yyn == 83) {
#line 435
    goto case_83;
  }
#line 438
  if (yyn == 84) {
#line 438
    goto case_84;
  }
#line 444
  if (yyn == 88) {
#line 444
    goto case_88;
  }
#line 454
  if (yyn == 89) {
#line 454
    goto case_89;
  }
#line 457
  if (yyn == 90) {
#line 457
    goto case_90;
  }
#line 460
  if (yyn == 92) {
#line 460
    goto case_92;
  }
#line 468
  if (yyn == 93) {
#line 468
    goto case_93;
  }
#line 474
  if (yyn == 94) {
#line 474
    goto case_94;
  }
#line 479
  if (yyn == 95) {
#line 479
    goto case_95;
  }
#line 484
  if (yyn == 96) {
#line 484
    goto case_96;
  }
#line 487
  if (yyn == 97) {
#line 487
    goto case_97;
  }
#line 489
  if (yyn == 98) {
#line 489
    goto case_98;
  }
#line 491
  if (yyn == 99) {
#line 491
    goto case_99;
  }
#line 493
  if (yyn == 100) {
#line 493
    goto case_100;
  }
#line 495
  if (yyn == 101) {
#line 495
    goto case_101;
  }
#line 497
  if (yyn == 102) {
#line 497
    goto case_102;
  }
#line 499
  if (yyn == 103) {
#line 499
    goto case_103;
  }
#line 501
  if (yyn == 104) {
#line 501
    goto case_104;
  }
#line 503
  if (yyn == 105) {
#line 503
    goto case_105;
  }
#line 506
  if (yyn == 106) {
#line 506
    goto case_106;
  }
#line 514
  if (yyn == 107) {
#line 514
    goto case_107;
  }
#line 517
  if (yyn == 108) {
#line 517
    goto case_108;
  }
#line 520
  if (yyn == 109) {
#line 520
    goto case_109;
  }
#line 522
  if (yyn == 110) {
#line 522
    goto case_110;
  }
#line 524
  if (yyn == 111) {
#line 524
    goto case_111;
  }
#line 526
  if (yyn == 112) {
#line 526
    goto case_112;
  }
#line 528
  if (yyn == 113) {
#line 528
    goto case_113;
  }
#line 530
  if (yyn == 115) {
#line 530
    goto case_115;
  }
#line 537
  if (yyn == 117) {
#line 537
    goto case_117;
  }
#line 541
  if (yyn == 118) {
#line 541
    goto case_118;
  }
#line 543
  if (yyn == 119) {
#line 543
    goto case_119;
  }
#line 548
  if (yyn == 120) {
#line 548
    goto case_120;
  }
#line 550
  if (yyn == 121) {
#line 550
    goto case_121;
  }
#line 552
  if (yyn == 137) {
#line 552
    goto case_137;
  }
#line 580
  if (yyn == 141) {
#line 580
    goto case_141;
  }
#line 592
  if (yyn == 142) {
#line 592
    goto case_142;
  }
#line 595
  if (yyn == 143) {
#line 595
    goto case_143;
  }
#line 597
  if (yyn == 146) {
#line 597
    goto case_146;
  }
#line 604
  if (yyn == 147) {
#line 604
    goto case_147;
  }
#line 608
  if (yyn == 150) {
#line 608
    goto case_150;
  }
#line 619
  if (yyn == 169) {
#line 619
    goto case_169;
  }
#line 653
  if (yyn == 170) {
#line 653
    goto case_170;
  }
#line 656
  if (yyn == 171) {
#line 656
    goto case_171;
  }
#line 658
  if (yyn == 172) {
#line 658
    goto case_172;
  }
#line 660
  if (yyn == 173) {
#line 660
    goto case_173;
  }
#line 662
  if (yyn == 174) {
#line 662
    goto case_174;
  }
#line 664
  if (yyn == 175) {
#line 664
    goto case_175;
  }
#line 666
  if (yyn == 176) {
#line 666
    goto case_176;
  }
#line 668
  if (yyn == 178) {
#line 668
    goto case_178;
  }
#line 672
  if (yyn == 197) {
#line 672
    goto case_197;
  }
#line 699
  if (yyn == 198) {
#line 699
    goto case_198;
  }
#line 701
  if (yyn == 199) {
#line 701
    goto case_199;
  }
#line 703
  if (yyn == 200) {
#line 703
    goto case_200;
  }
#line 705
  if (yyn == 204) {
#line 705
    goto case_204;
  }
#line 712
  if (yyn == 205) {
#line 712
    goto case_205;
  }
#line 714
  if (yyn == 206) {
#line 714
    goto case_206;
  }
#line 717
  if (yyn == 212) {
#line 717
    goto case_212;
  }
#line 726
  if (yyn == 213) {
#line 726
    goto case_213;
  }
#line 731
  if (yyn == 221) {
#line 731
    goto case_221;
  }
#line 744
  if (yyn == 222) {
#line 744
    goto case_222;
  }
#line 746
  if (yyn == 241) {
#line 746
    goto case_241;
  }
#line 772
  if (yyn == 242) {
#line 772
    goto case_242;
  }
#line 774
  if (yyn == 244) {
#line 774
    goto case_244;
  }
#line 779
  if (yyn == 245) {
#line 779
    goto case_245;
  }
#line 782
  if (yyn == 246) {
#line 782
    goto case_246;
  }
#line 784
  if (yyn == 247) {
#line 784
    goto case_247;
  }
#line 786
  if (yyn == 248) {
#line 786
    goto case_248;
  }
#line 788
  if (yyn == 258) {
#line 788
    goto case_258;
  }
#line 809
  if (yyn == 259) {
#line 809
    goto case_259;
  }
#line 811
  if (yyn == 260) {
#line 811
    goto case_260;
  }
#line 817
  if (yyn == 266) {
#line 817
    goto case_266;
  }
#line 829
  if (yyn == 267) {
#line 829
    goto case_267;
  }
#line 831
  if (yyn == 268) {
#line 831
    goto case_268;
  }
#line 833
  if (yyn == 269) {
#line 833
    goto case_269;
  }
#line 835
  if (yyn == 270) {
#line 835
    goto case_270;
  }
#line 841
  if (yyn == 273) {
#line 841
    goto case_273;
  }
#line 847
  if (yyn == 274) {
#line 847
    goto case_274;
  }
#line 849
  if (yyn == 275) {
#line 849
    goto case_275;
  }
#line 851
  if (yyn == 276) {
#line 851
    goto case_276;
  }
#line 853
  if (yyn == 277) {
#line 853
    goto case_277;
  }
#line 855
  if (yyn == 278) {
#line 855
    goto case_278;
  }
#line 857
  if (yyn == 279) {
#line 857
    goto case_279;
  }
#line 859
  if (yyn == 280) {
#line 859
    goto case_280;
  }
#line 861
  if (yyn == 284) {
#line 861
    goto case_284;
  }
#line 869
  if (yyn == 285) {
#line 869
    goto case_285;
  }
#line 3019 "bsdl_bison.c"
  goto switch_default;
  case_23: /* CIL Label */ 
  {
#line 257 "bsdl_bison.y"
  Print_Error___0(priv_data, "Unsupported BSDL construct found");
#line 258
  tmp___0 = bsdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 258
  if (tmp___0 > 0) {
    {
#line 258
    Give_Up_And_Quit___0(priv_data);
    }
#line 258
    goto yyabortlab;
  }
#line 259
  goto yyabortlab;
#line 261
  goto switch_break;
  case_27: /* CIL Label */ 
  {
#line 272
  free((void *)(yyvsp + -2)->str);
  }
#line 273
  goto switch_break;
  case_32: /* CIL Label */ 
  {
#line 281
  free((void *)(yyvsp + 0)->str);
  }
#line 282
  goto switch_break;
  case_33: /* CIL Label */ 
  {
#line 283
  free((void *)(yyvsp + -3)->str);
  }
#line 284
  goto switch_break;
  case_40: /* CIL Label */ 
#line 309
  (priv_data->jtag_ctrl)->instr_len = (yyvsp + 0)->integer;
#line 310
  goto switch_break;
  case_44: /* CIL Label */ 
  {
#line 319
  Print_Error___0(priv_data, "Error in Instruction_Opcode attribute statement");
#line 321
  tmp___1 = bsdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 321
  if (tmp___1 > 0) {
    {
#line 321
    Give_Up_And_Quit___0(priv_data);
    }
#line 321
    goto yyabortlab;
  }
#line 322
  goto yyabortlab;
#line 324
  goto switch_break;
  case_45: /* CIL Label */ 
  {
#line 326
  add_instruction(priv_data, (yyvsp + -3)->str, (yyvsp + -1)->str);
  }
#line 327
  goto switch_break;
  case_46: /* CIL Label */ 
#line 329
  yyval.str = (yyvsp + 0)->str;
#line 330
  goto switch_break;
  case_47: /* CIL Label */ 
  {
#line 332
  Print_Warning(priv_data, "Multiple opcode patterns are not supported, first pattern will be used");
#line 334
  yyval.str = (yyvsp + -2)->str;
#line 335
  free((void *)(yyvsp + 0)->str);
  }
#line 337
  goto switch_break;
  case_48: /* CIL Label */ 
#line 339
  yyval.str = (yyvsp + 0)->str;
#line 340
  goto switch_break;
  case_49: /* CIL Label */ 
  {
#line 344
  free((void *)(yyvsp + 0)->str);
  }
#line 345
  goto switch_break;
  case_50: /* CIL Label */ 
  {
#line 349
  free((void *)(yyvsp + 0)->str);
  }
#line 350
  goto switch_break;
  case_51: /* CIL Label */ 
  {
#line 354
  free((void *)(yyvsp + 0)->str);
  }
#line 355
  goto switch_break;
  case_55: /* CIL Label */ 
  {
#line 364
  Print_Error___0(priv_data, "Error in Opcode List");
#line 365
  tmp___2 = bsdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 365
  if (tmp___2 > 0) {
    {
#line 365
    Give_Up_And_Quit___0(priv_data);
    }
#line 365
    goto yyabortlab;
  }
#line 366
  goto yyabortlab;
#line 368
  goto switch_break;
  case_56: /* CIL Label */ 
  {
#line 370
  free((void *)(yyvsp + 0)->str);
  }
#line 371
  goto switch_break;
  case_57: /* CIL Label */ 
#line 375
  (priv_data->jtag_ctrl)->idcode = (yyvsp + 0)->str;
#line 376
  goto switch_break;
  case_58: /* CIL Label */ 
#line 380
  (priv_data->jtag_ctrl)->usercode = (yyvsp + 0)->str;
#line 381
  goto switch_break;
  case_62: /* CIL Label */ 
  {
#line 390
  ac_apply_assoc(priv_data);
  }
#line 391
  goto switch_break;
  case_63: /* CIL Label */ 
  {
#line 393
  ac_set_register(priv_data, (yyvsp + 0)->str, 0);
  }
#line 394
  goto switch_break;
  case_64: /* CIL Label */ 
  {
#line 395
  ac_set_register(priv_data, (yyvsp + -3)->str, (yyvsp + -1)->integer);
  }
#line 396
  goto switch_break;
  case_65: /* CIL Label */ 
  {
#line 398
  yyval.str = strdup("BOUNDARY");
  }
#line 399
  goto switch_break;
  case_66: /* CIL Label */ 
  {
#line 400
  yyval.str = strdup("BYPASS");
  }
#line 401
  goto switch_break;
  case_67: /* CIL Label */ 
  {
#line 402
  yyval.str = strdup("IDCODE");
  }
#line 403
  goto switch_break;
  case_68: /* CIL Label */ 
  {
#line 404
  yyval.str = strdup("USERCODE");
  }
#line 405
  goto switch_break;
  case_69: /* CIL Label */ 
  {
#line 406
  yyval.str = strdup("DEVICE_ID");
  }
#line 407
  goto switch_break;
  case_72: /* CIL Label */ 
  {
#line 412
  yyval.str = strdup("BYPASS");
  }
#line 413
  goto switch_break;
  case_73: /* CIL Label */ 
  {
#line 414
  yyval.str = strdup("CLAMP");
  }
#line 415
  goto switch_break;
  case_74: /* CIL Label */ 
  {
#line 416
  yyval.str = strdup("EXTEST");
  }
#line 417
  goto switch_break;
  case_75: /* CIL Label */ 
  {
#line 418
  yyval.str = strdup("HIGHZ");
  }
#line 419
  goto switch_break;
  case_76: /* CIL Label */ 
  {
#line 420
  yyval.str = strdup("IDCODE");
  }
#line 421
  goto switch_break;
  case_77: /* CIL Label */ 
  {
#line 422
  yyval.str = strdup("INTEST");
  }
#line 423
  goto switch_break;
  case_78: /* CIL Label */ 
  {
#line 424
  yyval.str = strdup("PRELOAD");
  }
#line 425
  goto switch_break;
  case_79: /* CIL Label */ 
  {
#line 426
  yyval.str = strdup("RUNBIST");
  }
#line 427
  goto switch_break;
  case_80: /* CIL Label */ 
  {
#line 428
  yyval.str = strdup("SAMPLE");
  }
#line 429
  goto switch_break;
  case_81: /* CIL Label */ 
  {
#line 430
  yyval.str = strdup("USERCODE");
  }
#line 431
  goto switch_break;
  case_82: /* CIL Label */ 
#line 432
  yyval.str = (yyvsp + 0)->str;
#line 433
  goto switch_break;
  case_83: /* CIL Label */ 
  {
#line 435
  ac_add_instruction(priv_data, (yyvsp + 0)->str);
  }
#line 436
  goto switch_break;
  case_84: /* CIL Label */ 
#line 441
  (priv_data->jtag_ctrl)->bsr_len = (yyvsp + 0)->integer;
#line 442
  goto switch_break;
  case_88: /* CIL Label */ 
  {
#line 450
  Print_Error___0(priv_data, "Error in Boundary Cell description");
#line 451
  tmp___3 = bsdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 451
  if (tmp___3 > 0) {
    {
#line 451
    Give_Up_And_Quit___0(priv_data);
    }
#line 451
    goto yyabortlab;
  }
#line 451
  goto yyabortlab;
#line 452
  goto switch_break;
  case_89: /* CIL Label */ 
  {
#line 454
  ci_append_cell_info(priv_data, (yyvsp + -3)->integer);
  }
#line 455
  goto switch_break;
  case_90: /* CIL Label */ 
  {
#line 457
  ci_no_disable(priv_data);
  }
#line 458
  goto switch_break;
  case_92: /* CIL Label */ 
  {
#line 463
  free((void *)(yyvsp + -6)->str);
#line 464
  ci_set_cell_spec(priv_data, (yyvsp + -2)->integer, (yyvsp + 0)->str);
  }
#line 466
  goto switch_break;
  case_93: /* CIL Label */ 
  {
#line 469
  prt_add_name(priv_data, (yyvsp + 0)->str);
#line 470
  prt_add_bit(priv_data);
  }
#line 472
  goto switch_break;
  case_94: /* CIL Label */ 
  {
#line 474
  prt_add_name(priv_data, (yyvsp + -3)->str);
#line 475
  prt_add_range(priv_data, (yyvsp + -1)->integer, (yyvsp + -1)->integer);
  }
#line 477
  goto switch_break;
  case_95: /* CIL Label */ 
  {
#line 479
  tmp___4 = strdup("*");
#line 479
  prt_add_name(priv_data, tmp___4);
#line 480
  prt_add_bit(priv_data);
  }
#line 482
  goto switch_break;
  case_96: /* CIL Label */ 
#line 484
  yyval.integer = 280;
#line 485
  goto switch_break;
  case_97: /* CIL Label */ 
#line 486
  yyval.integer = 281;
#line 487
  goto switch_break;
  case_98: /* CIL Label */ 
#line 488
  yyval.integer = 282;
#line 489
  goto switch_break;
  case_99: /* CIL Label */ 
#line 490
  yyval.integer = 283;
#line 491
  goto switch_break;
  case_100: /* CIL Label */ 
#line 492
  yyval.integer = 284;
#line 493
  goto switch_break;
  case_101: /* CIL Label */ 
#line 494
  yyval.integer = 285;
#line 495
  goto switch_break;
  case_102: /* CIL Label */ 
#line 496
  yyval.integer = 286;
#line 497
  goto switch_break;
  case_103: /* CIL Label */ 
#line 498
  yyval.integer = 287;
#line 499
  goto switch_break;
  case_104: /* CIL Label */ 
#line 500
  yyval.integer = 308;
#line 501
  goto switch_break;
  case_105: /* CIL Label */ 
#line 503
  yyval.str = (yyvsp + 0)->str;
#line 504
  goto switch_break;
  case_106: /* CIL Label */ 
  {
#line 507
  tmp___6 = malloc((size_t )2);
#line 507
  tmp___5 = (char *)tmp___6;
#line 508
  snprintf((char */* __restrict  */)tmp___5, (size_t )2, (char const   */* __restrict  */)"%i",
           (yyvsp + 0)->integer);
#line 509
  *(tmp___5 + 1) = (char )'\000';
#line 510
  yyval.str = tmp___5;
  }
#line 512
  goto switch_break;
  case_107: /* CIL Label */ 
  {
#line 514
  ci_set_cell_spec_disable(priv_data, (yyvsp + -4)->integer, (yyvsp + -2)->integer,
                           (yyvsp + 0)->integer);
  }
#line 515
  goto switch_break;
  case_108: /* CIL Label */ 
#line 517
  yyval.integer = 290;
#line 518
  goto switch_break;
  case_109: /* CIL Label */ 
#line 519
  yyval.integer = 291;
#line 520
  goto switch_break;
  case_110: /* CIL Label */ 
#line 521
  yyval.integer = 292;
#line 522
  goto switch_break;
  case_111: /* CIL Label */ 
#line 523
  yyval.integer = 294;
#line 524
  goto switch_break;
  case_112: /* CIL Label */ 
#line 525
  yyval.integer = 295;
#line 526
  goto switch_break;
  case_113: /* CIL Label */ 
#line 527
  yyval.integer = 296;
#line 528
  goto switch_break;
  case_115: /* CIL Label */ 
  {
#line 534
  bsdl_flex_set_bin_x(priv_data->scanner);
  }
#line 535
  goto switch_break;
  case_117: /* CIL Label */ 
  {
#line 538
  free((void *)(yyvsp + 0)->str);
  }
#line 539
  goto switch_break;
  case_118: /* CIL Label */ 
  {
#line 540
  free((void *)(yyvsp + 0)->str);
  }
#line 541
  goto switch_break;
  case_119: /* CIL Label */ 
#line 545
  (priv_data->jtag_ctrl)->conformance = (bsdl_conformance_t )0;
#line 546
  goto switch_break;
  case_120: /* CIL Label */ 
#line 547
  (priv_data->jtag_ctrl)->conformance = (bsdl_conformance_t )1;
#line 548
  goto switch_break;
  case_121: /* CIL Label */ 
#line 549
  (priv_data->jtag_ctrl)->conformance = (bsdl_conformance_t )2;
#line 550
  goto switch_break;
  case_137: /* CIL Label */ 
  {
#line 574
  Print_Error___0(priv_data, "Error in ISC_Pin_Behavior Definition");
#line 575
  tmp___7 = bsdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 575
  if (tmp___7 > 0) {
    {
#line 575
    Give_Up_And_Quit___0(priv_data);
    }
#line 575
    goto yyabortlab;
  }
#line 576
  goto yyabortlab;
#line 578
  goto switch_break;
  case_141: /* CIL Label */ 
  {
#line 586
  Print_Error___0(priv_data, "Error in ISC_Fixed_System_Pins Definition");
#line 587
  tmp___8 = bsdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 587
  if (tmp___8 > 0) {
    {
#line 587
    Give_Up_And_Quit___0(priv_data);
    }
#line 587
    goto yyabortlab;
  }
#line 588
  goto yyabortlab;
#line 590
  goto switch_break;
  case_142: /* CIL Label */ 
  {
#line 592
  free((void *)(yyvsp + 0)->str);
  }
#line 593
  goto switch_break;
  case_143: /* CIL Label */ 
  {
#line 594
  free((void *)(yyvsp + -3)->str);
  }
#line 595
  goto switch_break;
  case_146: /* CIL Label */ 
  {
#line 601
  free((void *)(yyvsp + 0)->str);
  }
#line 602
  goto switch_break;
  case_147: /* CIL Label */ 
  {
#line 605
  free((void *)(yyvsp + 0)->str);
  }
#line 606
  goto switch_break;
  case_150: /* CIL Label */ 
  {
#line 613
  Print_Error___0(priv_data, "Error in ISC_Security Definition");
#line 614
  tmp___9 = bsdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 614
  if (tmp___9 > 0) {
    {
#line 614
    Give_Up_And_Quit___0(priv_data);
    }
#line 614
    goto yyabortlab;
  }
#line 615
  goto yyabortlab;
#line 617
  goto switch_break;
  case_169: /* CIL Label */ 
  {
#line 647
  Print_Error___0(priv_data, "Error in ISC_Flow Definition");
#line 648
  tmp___10 = bsdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 648
  if (tmp___10 > 0) {
    {
#line 648
    Give_Up_And_Quit___0(priv_data);
    }
#line 648
    goto yyabortlab;
  }
#line 649
  goto yyabortlab;
#line 651
  goto switch_break;
  case_170: /* CIL Label */ 
  {
#line 653
  free((void *)(yyvsp + 0)->str);
  }
#line 654
  goto switch_break;
  case_171: /* CIL Label */ 
  {
#line 655
  free((void *)(yyvsp + -1)->str);
  }
#line 656
  goto switch_break;
  case_172: /* CIL Label */ 
  {
#line 657
  free((void *)(yyvsp + -2)->str);
  }
#line 658
  goto switch_break;
  case_173: /* CIL Label */ 
  {
#line 659
  free((void *)(yyvsp + -3)->str);
  }
#line 660
  goto switch_break;
  case_174: /* CIL Label */ 
  {
#line 661
  free((void *)(yyvsp + -1)->str);
  }
#line 662
  goto switch_break;
  case_175: /* CIL Label */ 
  {
#line 663
  free((void *)(yyvsp + -2)->str);
  }
#line 664
  goto switch_break;
  case_176: /* CIL Label */ 
  {
#line 665
  free((void *)(yyvsp + -1)->str);
  }
#line 666
  goto switch_break;
  case_178: /* CIL Label */ 
  {
#line 669
  free((void *)(yyvsp + -1)->str);
  }
#line 670
  goto switch_break;
  case_197: /* CIL Label */ 
  {
#line 696
  free((void *)(yyvsp + -2)->str);
  }
#line 697
  goto switch_break;
  case_198: /* CIL Label */ 
  {
#line 698
  free((void *)(yyvsp + -3)->str);
  }
#line 699
  goto switch_break;
  case_199: /* CIL Label */ 
  {
#line 700
  free((void *)(yyvsp + -3)->str);
  }
#line 701
  goto switch_break;
  case_200: /* CIL Label */ 
  {
#line 702
  free((void *)(yyvsp + -4)->str);
  }
#line 703
  goto switch_break;
  case_204: /* CIL Label */ 
  {
#line 709
  bsdl_flex_set_hex(priv_data->scanner);
  }
#line 710
  goto switch_break;
  case_205: /* CIL Label */ 
  {
#line 711
  bsdl_flex_set_decimal(priv_data->scanner);
  }
#line 712
  goto switch_break;
  case_206: /* CIL Label */ 
  {
#line 714
  free((void *)(yyvsp + 0)->str);
  }
#line 715
  goto switch_break;
  case_212: /* CIL Label */ 
  {
#line 723
  bsdl_flex_set_hex(priv_data->scanner);
  }
#line 724
  goto switch_break;
  case_213: /* CIL Label */ 
  {
#line 726
  free((void *)(yyvsp + 0)->str);
#line 727
  bsdl_flex_set_decimal(priv_data->scanner);
  }
#line 729
  goto switch_break;
  case_221: /* CIL Label */ 
  {
#line 741
  bsdl_flex_set_hex(priv_data->scanner);
  }
#line 742
  goto switch_break;
  case_222: /* CIL Label */ 
  {
#line 743
  bsdl_flex_set_decimal(priv_data->scanner);
  }
#line 744
  goto switch_break;
  case_241: /* CIL Label */ 
  {
#line 769
  free((void *)(yyvsp + 0)->str);
  }
#line 770
  goto switch_break;
  case_242: /* CIL Label */ 
  {
#line 771
  free((void *)(yyvsp + 0)->str);
  }
#line 772
  goto switch_break;
  case_244: /* CIL Label */ 
  {
#line 776
  free((void *)(yyvsp + 0)->str);
  }
#line 777
  goto switch_break;
  case_245: /* CIL Label */ 
  {
#line 779
  bsdl_flex_set_decimal(priv_data->scanner);
  }
#line 780
  goto switch_break;
  case_246: /* CIL Label */ 
  {
#line 781
  bsdl_flex_set_decimal(priv_data->scanner);
  }
#line 782
  goto switch_break;
  case_247: /* CIL Label */ 
  {
#line 783
  bsdl_flex_set_decimal(priv_data->scanner);
  }
#line 784
  goto switch_break;
  case_248: /* CIL Label */ 
  {
#line 785
  bsdl_flex_set_decimal(priv_data->scanner);
  }
#line 786
  goto switch_break;
  case_258: /* CIL Label */ 
  {
#line 806
  free((void *)(yyvsp + -4)->str);
  }
#line 807
  goto switch_break;
  case_259: /* CIL Label */ 
  {
#line 808
  free((void *)(yyvsp + -5)->str);
  }
#line 809
  goto switch_break;
  case_260: /* CIL Label */ 
  {
#line 811
  Print_Error___0(priv_data, "Error in ISC_Procedure Definition");
#line 812
  tmp___11 = bsdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 812
  if (tmp___11 > 0) {
    {
#line 812
    Give_Up_And_Quit___0(priv_data);
    }
#line 812
    goto yyabortlab;
  }
#line 813
  goto yyabortlab;
#line 815
  goto switch_break;
  case_266: /* CIL Label */ 
  {
#line 826
  free((void *)(yyvsp + -4)->str);
  }
#line 827
  goto switch_break;
  case_267: /* CIL Label */ 
  {
#line 828
  free((void *)(yyvsp + -5)->str);
  }
#line 829
  goto switch_break;
  case_268: /* CIL Label */ 
  {
#line 830
  free((void *)(yyvsp + -5)->str);
  }
#line 831
  goto switch_break;
  case_269: /* CIL Label */ 
  {
#line 832
  free((void *)(yyvsp + -6)->str);
  }
#line 833
  goto switch_break;
  case_270: /* CIL Label */ 
  {
#line 835
  Print_Error___0(priv_data, "Error in ISC_Action Definition");
#line 836
  tmp___12 = bsdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 836
  if (tmp___12 > 0) {
    {
#line 836
    Give_Up_And_Quit___0(priv_data);
    }
#line 836
    goto yyabortlab;
  }
#line 837
  goto yyabortlab;
#line 839
  goto switch_break;
  case_273: /* CIL Label */ 
  {
#line 844
  free((void *)(yyvsp + 0)->str);
  }
#line 845
  goto switch_break;
  case_274: /* CIL Label */ 
  {
#line 846
  free((void *)(yyvsp + -1)->str);
  }
#line 847
  goto switch_break;
  case_275: /* CIL Label */ 
  {
#line 848
  free((void *)(yyvsp + -2)->str);
  }
#line 849
  goto switch_break;
  case_276: /* CIL Label */ 
  {
#line 850
  free((void *)(yyvsp + -2)->str);
  }
#line 851
  goto switch_break;
  case_277: /* CIL Label */ 
  {
#line 852
  free((void *)(yyvsp + -3)->str);
  }
#line 853
  goto switch_break;
  case_278: /* CIL Label */ 
  {
#line 854
  free((void *)(yyvsp + -1)->str);
  }
#line 855
  goto switch_break;
  case_279: /* CIL Label */ 
  {
#line 856
  free((void *)(yyvsp + -2)->str);
  }
#line 857
  goto switch_break;
  case_280: /* CIL Label */ 
  {
#line 858
  free((void *)(yyvsp + -1)->str);
  }
#line 859
  goto switch_break;
  case_284: /* CIL Label */ 
  {
#line 866
  free((void *)(yyvsp + 0)->str);
  }
#line 867
  goto switch_break;
  case_285: /* CIL Label */ 
  {
#line 868
  free((void *)(yyvsp + 0)->str);
  }
#line 869
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 3019 "bsdl_bison.c"
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 3023
  yyvsp -= yylen;
#line 3023
  yyssp -= yylen;
#line 3024
  yylen = 0;
#line 3027
  yyvsp ++;
#line 3027
  *yyvsp = yyval;
#line 3033
  yyn = (int )yyr1___0[yyn];
#line 3035
  yystate = (int )((int const   )yypgoto___0[yyn - 114] + (int const   )*yyssp);
#line 3036
  if (0 <= yystate) {
#line 3036
    if (yystate <= 434) {
#line 3036
      if ((int const   )yycheck___0[yystate] == (int const   )*yyssp) {
#line 3037
        yystate = (int )yytable___0[yystate];
      } else {
#line 3039
        yystate = (int )yydefgoto___0[yyn - 114];
      }
    } else {
#line 3039
      yystate = (int )yydefgoto___0[yyn - 114];
    }
  } else {
#line 3039
    yystate = (int )yydefgoto___0[yyn - 114];
  }
#line 3041
  goto yynewstate;
  yyerrlab: 
#line 3049
  if (! yyerrstatus) {
    {
#line 3051
    bsdlnerrs ++;
#line 3053
    bsdlerror(priv_data, "syntax error");
    }
  }
#line 3091
  if (yyerrstatus == 3) {
#line 3096
    if (bsdlchar <= 0) {
#line 3099
      if (bsdlchar == 0) {
#line 3100
        goto yyabortlab;
      }
    } else {
      {
#line 3104
      yydestruct___0("Error: discarding", yytoken, & bsdllval, priv_data);
#line 3106
      bsdlchar = -2;
      }
    }
  }
#line 3112
  goto yyerrlab1;
#line 3128
  yyvsp -= yylen;
#line 3128
  yyssp -= yylen;
#line 3129
  yylen = 0;
#line 3131
  yystate = (int )*yyssp;
#line 3132
  goto yyerrlab1;
  yyerrlab1: 
#line 3139
  yyerrstatus = 3;
  {
#line 3141
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3143
    yyn = (int )yypact___0[yystate];
#line 3144
    if (yyn != -326) {
#line 3146
      yyn ++;
#line 3147
      if (0 <= yyn) {
#line 3147
        if (yyn <= 434) {
#line 3147
          if ((int const   )yycheck___0[yyn] == 1) {
#line 3149
            yyn = (int )yytable___0[yyn];
#line 3150
            if (0 < yyn) {
#line 3151
              goto while_break___1;
            }
          }
        }
      }
    }
#line 3156
    if ((unsigned long )yyssp == (unsigned long )yyss) {
#line 3157
      goto yyabortlab;
    }
    {
#line 3160
    yydestruct___0("Error: popping", (int )yystos___0[yystate], yyvsp, priv_data);
#line 3162
    yyvsp --;
#line 3162
    yyssp --;
#line 3163
    yystate = (int )*yyssp;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 3167
  yyvsp ++;
#line 3167
  *yyvsp = bsdllval;
#line 3173
  yystate = yyn;
#line 3174
  goto yynewstate;
  yyacceptlab: 
#line 3181
  yyresult = 0;
#line 3182
  goto yyreturn;
  yyabortlab: 
#line 3188
  yyresult = 1;
#line 3189
  goto yyreturn;
  yyexhaustedlab: 
  {
#line 3196
  bsdlerror(priv_data, "memory exhausted");
#line 3197
  yyresult = 2;
  }
  yyreturn: 
#line 3202
  if (bsdlchar != -2) {
    {
#line 3203
    yydestruct___0("Cleanup: discarding lookahead", yytoken, & bsdllval, priv_data);
    }
  }
#line 3207
  yyvsp -= yylen;
#line 3207
  yyssp -= yylen;
  {
#line 3209
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 3209
    if (! ((unsigned long )yyssp != (unsigned long )yyss)) {
#line 3209
      goto while_break___2;
    }
    {
#line 3211
    yydestruct___0("Cleanup: popping", (int )yystos___0[*yyssp], yyvsp, priv_data);
#line 3213
    yyvsp --;
#line 3213
    yyssp --;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 3216
  if ((unsigned long )yyss != (unsigned long )(yyssa)) {
    {
#line 3217
    free((void *)yyss);
    }
  }
#line 3224
  return (yyresult);
}
}
#line 872 "bsdl_bison.y"
static void Print_Error___0(bsdl_parser_priv_t *priv_data , char const   *Errmess ) 
{ 
  char *__cil_tmp3 ;

  {
  {
#line 874
  bsdl_msg((priv_data->jtag_ctrl)->proc_mode, 2, "Line %d, %s.\n", priv_data->lineno,
           Errmess);
  }
#line 878
  return;
}
}
#line 880 "bsdl_bison.y"
static void Print_Warning(bsdl_parser_priv_t *priv_data , char const   *Warnmess ) 
{ 
  char *__cil_tmp3 ;

  {
  {
#line 882
  bsdl_msg((priv_data->jtag_ctrl)->proc_mode, 1, "Line %d, %s.\n", priv_data->lineno,
           Warnmess);
  }
#line 886
  return;
}
}
#line 888 "bsdl_bison.y"
static void Give_Up_And_Quit___0(bsdl_parser_priv_t *priv_data ) 
{ 


  {
  {
#line 891
  bsdl_flex_stop_buffer(priv_data->scanner);
  }
#line 892
  return;
}
}
#line 894 "bsdl_bison.y"
void bsdlerror(bsdl_parser_priv_t *priv_data , char const   *error_string ) 
{ 


  {
#line 896
  return;
}
}
#line 911 "bsdl_bison.y"
static void bsdl_sem_init(bsdl_parser_priv_t *priv ) 
{ 
  jtag_ctrl_t *jc ;

  {
#line 913
  jc = priv->jtag_ctrl;
#line 915
  jc->instr_len = -1;
#line 916
  jc->bsr_len = -1;
#line 917
  jc->conformance = (bsdl_conformance_t )3;
#line 918
  jc->idcode = (char *)((void *)0);
#line 919
  jc->usercode = (char *)((void *)0);
#line 921
  jc->instr_list = (instr_elem_t *)((void *)0);
#line 923
  priv->ainfo.next = (struct ainfo_elem *)((void *)0);
#line 924
  priv->ainfo.reg = (char *)((void *)0);
#line 925
  priv->ainfo.instr_list = (instr_elem_t *)((void *)0);
#line 926
  jc->ainfo_list = (ainfo_elem_t *)((void *)0);
#line 928
  priv->tmp_cell_info.next = (struct cell_info *)((void *)0);
#line 929
  priv->tmp_cell_info.port_name = (char *)((void *)0);
#line 930
  priv->tmp_cell_info.basic_safe_value = (char *)((void *)0);
#line 931
  jc->cell_info_first = (cell_info_t *)((void *)0);
#line 932
  jc->cell_info_last = (cell_info_t *)((void *)0);
#line 934
  priv->tmp_port_desc.names_list = (string_elem_t *)((void *)0);
#line 935
  priv->tmp_port_desc.next = (struct port_desc *)((void *)0);
#line 936
  return;
}
}
#line 950 "bsdl_bison.y"
static void free_instr_list(instr_elem_t *il ) 
{ 


  {
#line 952
  if (il) {
#line 954
    if (il->instr) {
      {
#line 955
      free((void *)il->instr);
      }
    }
#line 956
    if (il->opcode) {
      {
#line 957
      free((void *)il->opcode);
      }
    }
    {
#line 958
    free_instr_list(il->next);
#line 959
    free((void *)il);
    }
  }
#line 961
  return;
}
}
#line 976 "bsdl_bison.y"
static void free_ainfo_list(ainfo_elem_t *ai , int free_me ) 
{ 


  {
#line 978
  if (ai) {
#line 980
    if (ai->reg) {
      {
#line 981
      free((void *)ai->reg);
      }
    }
    {
#line 983
    free_instr_list(ai->instr_list);
#line 984
    free_ainfo_list(ai->next, 1);
    }
#line 986
    if (free_me) {
      {
#line 987
      free((void *)ai);
      }
    }
  }
#line 989
  return;
}
}
#line 1003 "bsdl_bison.y"
static void free_string_list___0(string_elem_t *sl ) 
{ 


  {
#line 1005
  if (sl) {
#line 1007
    if (sl->string) {
      {
#line 1008
      free((void *)sl->string);
      }
    }
    {
#line 1009
    free_string_list___0(sl->next);
#line 1010
    free((void *)sl);
    }
  }
#line 1012
  return;
}
}
#line 1028 "bsdl_bison.y"
static void free_ci_list(cell_info_t *ci , int free_me ) 
{ 


  {
#line 1030
  if (ci) {
    {
#line 1032
    free_ci_list(ci->next, 1);
    }
#line 1034
    if (ci->port_name) {
      {
#line 1035
      free((void *)ci->port_name);
      }
    }
#line 1037
    if (ci->basic_safe_value) {
      {
#line 1038
      free((void *)ci->basic_safe_value);
      }
    }
#line 1040
    if (free_me) {
      {
#line 1041
      free((void *)ci);
      }
    }
  }
#line 1043
  return;
}
}
#line 1058 "bsdl_bison.y"
static void bsdl_sem_deinit(bsdl_parser_priv_t *priv ) 
{ 
  jtag_ctrl_t *jc ;
  cell_info_t *tmp ;

  {
#line 1060
  jc = priv->jtag_ctrl;
#line 1062
  if (jc->idcode) {
    {
#line 1064
    free((void *)jc->idcode);
#line 1065
    jc->idcode = (char *)((void *)0);
    }
  }
#line 1068
  if (jc->usercode) {
    {
#line 1070
    free((void *)jc->usercode);
#line 1071
    jc->usercode = (char *)((void *)0);
    }
  }
  {
#line 1075
  free_ci_list(jc->cell_info_first, 1);
#line 1076
  tmp = (cell_info_t *)((void *)0);
#line 1076
  jc->cell_info_last = tmp;
#line 1076
  jc->cell_info_first = tmp;
#line 1077
  free_ci_list(& priv->tmp_cell_info, 0);
#line 1080
  free_instr_list(jc->instr_list);
#line 1081
  jc->instr_list = (instr_elem_t *)((void *)0);
#line 1084
  free_ainfo_list(jc->ainfo_list, 1);
#line 1085
  jc->ainfo_list = (ainfo_elem_t *)((void *)0);
#line 1086
  free_ainfo_list(& priv->ainfo, 0);
#line 1089
  free_string_list___0(priv->tmp_port_desc.names_list);
#line 1090
  priv->tmp_port_desc.names_list = (string_elem_t *)((void *)0);
  }
#line 1091
  return;
}
}
#line 1108 "bsdl_bison.y"
bsdl_parser_priv_t *bsdl_parser_init(jtag_ctrl_t *jtag_ctrl ) 
{ 
  bsdl_parser_priv_t *new_priv ;
  void *tmp ;
  void *tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 1112
  tmp = malloc((size_t )sizeof(bsdl_parser_priv_t ));
#line 1112
  new_priv = (bsdl_parser_priv_t *)tmp;
  }
#line 1112
  if (! new_priv) {
    {
#line 1113
    bsdl_msg(jtag_ctrl->proc_mode, 2, "Out of memory, %s line %i\n", "bsdl_bison.y",
             1114);
    }
#line 1115
    return ((bsdl_parser_priv_t *)((void *)0));
  }
  {
#line 1118
  new_priv->jtag_ctrl = jtag_ctrl;
#line 1120
  tmp___0 = bsdl_flex_init(jtag_ctrl->proc_mode);
#line 1120
  new_priv->scanner = tmp___0;
  }
#line 1120
  if (! tmp___0) {
    {
#line 1121
    free((void *)new_priv);
#line 1122
    new_priv = (bsdl_parser_priv_t *)((void *)0);
    }
  }
  {
#line 1125
  bsdl_sem_init(new_priv);
  }
#line 1127
  return (new_priv);
}
}
#line 1145 "bsdl_bison.y"
void bsdl_parser_deinit(bsdl_parser_priv_t *priv_data ) 
{ 


  {
  {
#line 1147
  bsdl_sem_deinit(priv_data);
#line 1148
  bsdl_flex_deinit(priv_data->scanner);
#line 1149
  free((void *)priv_data);
  }
#line 1150
  return;
}
}
#line 1167 "bsdl_bison.y"
static void add_instruction(bsdl_parser_priv_t *priv , char *instr , char *opcode ) 
{ 
  instr_elem_t *new_instr ;
  void *tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 1171
  tmp = malloc((size_t )sizeof(instr_elem_t ));
#line 1171
  new_instr = (instr_elem_t *)tmp;
  }
#line 1172
  if (new_instr) {
#line 1174
    new_instr->next = (priv->jtag_ctrl)->instr_list;
#line 1175
    new_instr->instr = instr;
#line 1176
    new_instr->opcode = opcode;
#line 1178
    (priv->jtag_ctrl)->instr_list = new_instr;
  } else {
    {
#line 1181
    bsdl_msg((priv->jtag_ctrl)->proc_mode, 3, "Out of memory, %s line %i\n", "bsdl_bison.y",
             1182);
    }
  }
#line 1183
  return;
}
}
#line 1201 "bsdl_bison.y"
static void ac_set_register(bsdl_parser_priv_t *priv , char *reg , int reg_len ) 
{ 
  ainfo_elem_t *tmp_ai ;

  {
#line 1203
  tmp_ai = & priv->ainfo;
#line 1205
  tmp_ai->reg = reg;
#line 1206
  tmp_ai->reg_len = reg_len;
#line 1207
  return;
}
}
#line 1225 "bsdl_bison.y"
static void ac_add_instruction(bsdl_parser_priv_t *priv , char *instr ) 
{ 
  ainfo_elem_t *tmp_ai ;
  instr_elem_t *new_instr ;
  void *tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 1227
  tmp_ai = & priv->ainfo;
#line 1230
  tmp = malloc((size_t )sizeof(instr_elem_t ));
#line 1230
  new_instr = (instr_elem_t *)tmp;
  }
#line 1231
  if (new_instr) {
#line 1233
    new_instr->next = tmp_ai->instr_list;
#line 1234
    new_instr->instr = instr;
#line 1235
    new_instr->opcode = (char *)((void *)0);
#line 1237
    tmp_ai->instr_list = new_instr;
  } else {
    {
#line 1240
    bsdl_msg((priv->jtag_ctrl)->proc_mode, 3, "Out of memory, %s line %i\n", "bsdl_bison.y",
             1241);
    }
  }
#line 1242
  return;
}
}
#line 1258 "bsdl_bison.y"
static void ac_apply_assoc(bsdl_parser_priv_t *priv ) 
{ 
  jtag_ctrl_t *jc ;
  ainfo_elem_t *tmp_ai ;
  ainfo_elem_t *new_ai ;
  void *tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 1260
  jc = priv->jtag_ctrl;
#line 1261
  tmp_ai = & priv->ainfo;
#line 1264
  tmp = malloc((size_t )sizeof(ainfo_elem_t ));
#line 1264
  new_ai = (ainfo_elem_t *)tmp;
  }
#line 1265
  if (new_ai) {
#line 1267
    new_ai->next = jc->ainfo_list;
#line 1268
    new_ai->reg = tmp_ai->reg;
#line 1269
    new_ai->reg_len = tmp_ai->reg_len;
#line 1270
    new_ai->instr_list = tmp_ai->instr_list;
#line 1272
    jc->ainfo_list = new_ai;
  } else {
    {
#line 1275
    bsdl_msg(jc->proc_mode, 3, "Out of memory, %s line %i\n", "bsdl_bison.y", 1276);
    }
  }
#line 1279
  tmp_ai->reg = (char *)((void *)0);
#line 1280
  tmp_ai->reg_len = 0;
#line 1281
  tmp_ai->instr_list = (instr_elem_t *)((void *)0);
#line 1282
  return;
}
}
#line 1299 "bsdl_bison.y"
static void prt_add_name(bsdl_parser_priv_t *priv , char *name ) 
{ 
  port_desc_t *pd ;
  string_elem_t *new_string___1 ;
  void *tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 1301
  pd = & priv->tmp_port_desc;
#line 1304
  tmp = malloc((size_t )sizeof(string_elem_t ));
#line 1304
  new_string___1 = (string_elem_t *)tmp;
  }
#line 1305
  if (new_string___1) {
#line 1307
    new_string___1->next = pd->names_list;
#line 1308
    new_string___1->string = name;
#line 1310
    pd->names_list = new_string___1;
  } else {
    {
#line 1313
    bsdl_msg((priv->jtag_ctrl)->proc_mode, 3, "Out of memory, %s line %i\n", "bsdl_bison.y",
             1314);
    }
  }
#line 1315
  return;
}
}
#line 1332 "bsdl_bison.y"
static void prt_add_bit(bsdl_parser_priv_t *priv ) 
{ 
  port_desc_t *pd ;

  {
#line 1334
  pd = & priv->tmp_port_desc;
#line 1336
  pd->is_vector = 0;
#line 1337
  pd->low_idx = 0;
#line 1338
  pd->high_idx = 0;
#line 1339
  return;
}
}
#line 1357 "bsdl_bison.y"
static void prt_add_range(bsdl_parser_priv_t *priv , int low , int high ) 
{ 
  port_desc_t *pd ;

  {
#line 1359
  pd = & priv->tmp_port_desc;
#line 1361
  pd->is_vector = 1;
#line 1362
  pd->low_idx = low;
#line 1363
  pd->high_idx = high;
#line 1364
  return;
}
}
#line 1379 "bsdl_bison.y"
static void ci_no_disable(bsdl_parser_priv_t *priv ) 
{ 


  {
#line 1381
  priv->tmp_cell_info.ctrl_bit_num = -1;
#line 1382
  return;
}
}
#line 1402 "bsdl_bison.y"
static void ci_set_cell_spec_disable(bsdl_parser_priv_t *priv , int ctrl_bit_num ,
                                     int safe_value , int disable_value ) 
{ 
  cell_info_t *ci ;

  {
#line 1405
  ci = & priv->tmp_cell_info;
#line 1407
  ci->ctrl_bit_num = ctrl_bit_num;
#line 1408
  ci->disable_safe_value = safe_value;
#line 1410
  return;
}
}
#line 1431 "bsdl_bison.y"
static void ci_set_cell_spec(bsdl_parser_priv_t *priv , int function , char *safe_value ) 
{ 
  cell_info_t *ci ;
  port_desc_t *pd ;
  string_elem_t *name ;
  char *port_string ;
  size_t str_len ;
  size_t name_len ;
  void *tmp ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 1434
  ci = & priv->tmp_cell_info;
#line 1435
  pd = & priv->tmp_port_desc;
#line 1436
  name = priv->tmp_port_desc.names_list;
#line 1440
  ci->cell_function = function;
#line 1441
  ci->basic_safe_value = safe_value;
#line 1449
  name_len = strlen((char const   *)name->string);
#line 1450
  str_len = (((name_len + 1U) + 10U) + 1U) + 1U;
#line 1451
  tmp = malloc(str_len);
#line 1451
  port_string = (char *)tmp;
  }
#line 1451
  if ((unsigned long )port_string != (unsigned long )((void *)0)) {
#line 1453
    if (pd->is_vector) {
      {
#line 1454
      snprintf((char */* __restrict  */)port_string, str_len - 1U, (char const   */* __restrict  */)"%s(%d)",
               name->string, pd->low_idx);
      }
    } else {
      {
#line 1456
      strncpy((char */* __restrict  */)port_string, (char const   */* __restrict  */)name->string,
              str_len - 1U);
      }
    }
#line 1457
    *(port_string + (str_len - 1U)) = (char )'\000';
#line 1459
    ci->port_name = port_string;
  } else {
    {
#line 1463
    bsdl_msg((priv->jtag_ctrl)->proc_mode, 3, "Out of memory, %s line %i\n", "bsdl_bison.y",
             1464);
#line 1465
    ci->port_name = (char *)((void *)0);
    }
  }
  {
#line 1468
  free_string_list___0(priv->tmp_port_desc.names_list);
#line 1469
  priv->tmp_port_desc.names_list = (string_elem_t *)((void *)0);
  }
#line 1470
  return;
}
}
#line 1486 "bsdl_bison.y"
static void ci_append_cell_info(bsdl_parser_priv_t *priv , int bit_num ) 
{ 
  cell_info_t *tmp_ci ;
  cell_info_t *ci ;
  jtag_ctrl_t *jc ;
  void *tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 1488
  tmp_ci = & priv->tmp_cell_info;
#line 1490
  jc = priv->jtag_ctrl;
#line 1492
  tmp = malloc((size_t )sizeof(cell_info_t ));
#line 1492
  ci = (cell_info_t *)tmp;
  }
#line 1493
  if (ci) {
#line 1495
    ci->next = (struct cell_info *)((void *)0);
#line 1496
    if (jc->cell_info_last) {
#line 1497
      (jc->cell_info_last)->next = ci;
    } else {
#line 1499
      jc->cell_info_first = ci;
    }
#line 1500
    jc->cell_info_last = ci;
#line 1502
    ci->bit_num = bit_num;
#line 1503
    ci->port_name = tmp_ci->port_name;
#line 1504
    ci->cell_function = tmp_ci->cell_function;
#line 1505
    ci->basic_safe_value = tmp_ci->basic_safe_value;
#line 1506
    ci->ctrl_bit_num = tmp_ci->ctrl_bit_num;
#line 1507
    ci->disable_safe_value = tmp_ci->disable_safe_value;
#line 1509
    tmp_ci->port_name = (char *)((void *)0);
#line 1510
    tmp_ci->basic_safe_value = (char *)((void *)0);
  } else {
    {
#line 1513
    bsdl_msg(jc->proc_mode, 3, "Out of memory, %s line %i\n", "bsdl_bison.y", 1514);
    }
  }
#line 1515
  return;
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 354 "/usr/include/stdio.h"
extern int vprintf(char const   * __restrict  __format , __gnuc_va_list __arg ) ;
#line 43 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
#line 233
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
#line 135 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 150
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 163
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 209 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) stat)(char const   * __restrict  __file ,
                                                                                   struct stat * __restrict  __buf ) ;
#line 40 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *gettext(char const   *__msgid )  __attribute__((__format_arg__(1))) ;
#line 42 "../../include/bsdl.h"
int bsdl_read_file(chain_t *chain , char const   *BSDL_File_Name , int proc_mode ,
                   char const   *idcode___0 ) ;
#line 43
void bsdl_set_path(chain_t *chain , char const   *pathlist ) ;
#line 44
int bsdl_scan_files(chain_t *chain , char const   *idcode___0 , int proc_mode ) ;
#line 65 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bsdl/bsdl.c"
void bsdl_msg(int proc_mode , int type , char const   *format  , ...) 
{ 
  va_list lst ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 69
  __builtin_va_start(lst, format);
  }
  {
#line 72
  if (type == 0) {
#line 72
    goto case_0;
  }
#line 77
  if (type == 1) {
#line 77
    goto case_1;
  }
#line 82
  if (type == 2) {
#line 82
    goto case_2;
  }
#line 87
  if (type == 3) {
#line 87
    goto case_3;
  }
#line 92
  goto switch_default;
  case_0: /* CIL Label */ 
#line 73
  if (! (proc_mode & 1)) {
#line 74
    return;
  }
  {
#line 75
  printf((char const   */* __restrict  */)"-N- ");
  }
#line 76
  goto switch_break;
  case_1: /* CIL Label */ 
#line 78
  if (! (proc_mode & (1 << 1))) {
#line 79
    return;
  }
  {
#line 80
  printf((char const   */* __restrict  */)"-W- ");
  }
#line 81
  goto switch_break;
  case_2: /* CIL Label */ 
#line 83
  if (! (proc_mode & (1 << 2))) {
#line 84
    return;
  }
  {
#line 85
  printf((char const   */* __restrict  */)"-E- ");
  }
#line 86
  goto switch_break;
  case_3: /* CIL Label */ 
#line 88
  if (! (proc_mode & (1 << 3))) {
#line 89
    return;
  }
  {
#line 90
  printf((char const   */* __restrict  */)"-F- ");
  }
#line 91
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 93
  printf((char const   */* __restrict  */)"-?- ");
  }
#line 94
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 96
  vprintf((char const   */* __restrict  */)format, lst);
#line 97
  __builtin_va_end(lst);
  }
#line 98
  return;
}
}
#line 118 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bsdl/bsdl.c"
int bsdl_read_file(chain_t *chain , char const   *BSDL_File_Name , int proc_mode ,
                   char const   *idcode___0 ) 
{ 
  bsdl_globs_t *globs ;
  FILE *BSDL_File ;
  vhdl_parser_priv_t *vhdl_parser_priv ;
  jtag_ctrl_t jtag_ctrl ;
  int Compile_Errors ;
  int result ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
#line 121
  globs = & chain->bsdl;
#line 125
  Compile_Errors = 1;
#line 128
  if (globs->debug) {
#line 129
    proc_mode |= (((1 << 3) | (1 << 2)) | (1 << 1)) | 1;
  }
#line 131
  jtag_ctrl.proc_mode = proc_mode;
#line 134
  if (proc_mode & (1 << 6)) {
#line 136
    if ((unsigned long )chain == (unsigned long )((void *)0)) {
      {
#line 138
      tmp = gettext("No JTAG chain available\n");
#line 138
      bsdl_msg(proc_mode, 2, (char const   *)tmp);
      }
#line 139
      return (-1);
    }
#line 141
    if ((unsigned long )chain->parts == (unsigned long )((void *)0)) {
      {
#line 143
      tmp___0 = gettext("Chain without any parts\n");
#line 143
      bsdl_msg(proc_mode, 2, (char const   *)tmp___0);
      }
#line 144
      return (-1);
    }
#line 146
    if (chain) {
#line 146
      if (! chain->parts) {
#line 147
        return (-1);
      }
    } else {
#line 147
      return (-1);
    }
#line 149
    jtag_ctrl.chain = chain;
#line 150
    jtag_ctrl.part = *((chain->parts)->parts + chain->active_part);
  } else {
#line 154
    jtag_ctrl.chain = (chain_t *)((void *)0);
#line 155
    jtag_ctrl.part = (part_t *)((void *)0);
  }
  {
#line 158
  BSDL_File = fopen((char const   */* __restrict  */)BSDL_File_Name, (char const   */* __restrict  */)"r");
#line 160
  tmp___1 = gettext("Reading file \'%s\'\n");
#line 160
  bsdl_msg(proc_mode, 0, (char const   *)tmp___1, BSDL_File_Name);
  }
#line 162
  if ((unsigned long )BSDL_File == (unsigned long )((void *)0)) {
    {
#line 163
    tmp___2 = gettext("Unable to open BSDL file \'%s\'\n");
#line 163
    bsdl_msg(proc_mode, 2, (char const   *)tmp___2, BSDL_File_Name);
    }
#line 165
    return (-1);
  }
  {
#line 168
  vhdl_parser_priv = vhdl_parser_init(BSDL_File, & jtag_ctrl);
  }
#line 168
  if (vhdl_parser_priv) {
    {
#line 170
    (vhdl_parser_priv->jtag_ctrl)->idcode = (char *)((void *)0);
#line 172
    vhdlparse(vhdl_parser_priv);
#line 174
    Compile_Errors = vhdl_flex_get_compile_errors(vhdl_parser_priv->scanner);
    }
#line 175
    if (Compile_Errors == 0) {
      {
#line 177
      tmp___3 = gettext("BSDL file \'%s\' passed VHDL stage correctly\n");
#line 177
      bsdl_msg(proc_mode, 0, (char const   *)tmp___3, BSDL_File_Name);
#line 181
      result = bsdl_process_elements(& jtag_ctrl, idcode___0);
      }
#line 183
      if (result >= 0) {
        {
#line 184
        tmp___4 = gettext("BSDL file \'%s\' passed BSDL stage correctly\n");
#line 184
        bsdl_msg(proc_mode, 0, (char const   *)tmp___4, BSDL_File_Name);
        }
      }
    } else {
      {
#line 191
      tmp___5 = gettext("BSDL file \'%s\' contains errors in VHDL stage, stopping\n");
#line 191
      bsdl_msg(proc_mode, 2, (char const   *)tmp___5, BSDL_File_Name);
      }
    }
    {
#line 197
    vhdl_parser_deinit(vhdl_parser_priv);
    }
  }
#line 200
  if (Compile_Errors == 0) {
#line 200
    tmp___6 = result;
  } else {
#line 200
    tmp___6 = -1;
  }
#line 200
  return (tmp___6);
}
}
#line 218 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bsdl/bsdl.c"
void bsdl_set_path(chain_t *chain , char const   *pathlist ) 
{ 
  bsdl_globs_t *globs ;
  char *delim ;
  char *elem ;
  char *pathelem ;
  int num ;
  size_t len ;
  void *tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  char *__cil_tmp13 ;

  {
#line 220
  globs = & chain->bsdl;
#line 228
  if (globs->path_list) {
#line 230
    num = 0;
    {
#line 230
    while (1) {
      while_continue: /* CIL Label */ ;
#line 230
      if (! *(globs->path_list + num)) {
#line 230
        goto while_break;
      }
#line 231
      if (*(globs->path_list + num)) {
        {
#line 232
        free((void *)*(globs->path_list + num));
        }
      }
#line 230
      num ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 233
    free((void *)globs->path_list);
#line 234
    globs->path_list = (char **)((void *)0);
    }
  }
#line 238
  num = 0;
#line 238
  elem = (char *)pathlist;
  {
#line 238
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 238
    tmp___2 = strlen((char const   *)elem);
    }
#line 238
    if (! (tmp___2 > 0U)) {
#line 238
      goto while_break___0;
    }
    {
#line 240
    delim = strchr((char const   *)elem, ';');
    }
#line 241
    if (delim - elem > 0L) {
#line 241
      goto _L;
    } else
#line 241
    if ((unsigned long )delim == (unsigned long )((void *)0)) {
      _L: /* CIL Label */ 
      {
#line 243
      num ++;
#line 245
      tmp = realloc((void *)globs->path_list, (size_t )((unsigned long )(num + 1) * sizeof(char *)));
#line 245
      globs->path_list = (char **)tmp;
      }
#line 247
      if ((unsigned long )delim == (unsigned long )((void *)0)) {
        {
#line 248
        len = strlen((char const   *)elem);
        }
      } else {
#line 250
        len = (size_t )(delim - elem);
      }
      {
#line 251
      tmp___0 = malloc(len + 1U);
#line 251
      pathelem = (char *)tmp___0;
#line 252
      memcpy((void */* __restrict  */)pathelem, (void const   */* __restrict  */)elem,
             len);
#line 253
      *(pathelem + len) = (char )'\000';
#line 254
      *(globs->path_list + (num - 1)) = pathelem;
#line 255
      *(globs->path_list + num) = (char *)((void *)0);
      }
    }
#line 257
    if (delim) {
#line 257
      elem = delim + 1;
    } else {
      {
#line 257
      tmp___1 = strlen((char const   *)elem);
#line 257
      elem += tmp___1;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 260
  if (globs->debug) {
#line 261
    num = 0;
    {
#line 261
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 261
      if (! ((unsigned long )*(globs->path_list + num) != (unsigned long )((void *)0))) {
#line 261
        goto while_break___1;
      }
      {
#line 262
      bsdl_msg((((1 << 3) | (1 << 2)) | (1 << 1)) | 1, 0, "%s\n", *(globs->path_list + num));
#line 261
      num ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 264
  return;
}
}
#line 287 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bsdl/bsdl.c"
int bsdl_scan_files(chain_t *chain , char const   *idcode___0 , int proc_mode ) 
{ 
  bsdl_globs_t *globs ;
  int idx ;
  int result ;
  DIR *dir ;
  struct dirent *elem ;
  char *name ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  struct stat buf ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 289
  globs = & chain->bsdl;
#line 290
  idx = 0;
#line 291
  result = 0;
#line 294
  if ((unsigned long )globs->path_list == (unsigned long )((void *)0)) {
#line 295
    return (0);
  }
  {
#line 297
  while (1) {
    while_continue: /* CIL Label */ ;
#line 297
    if (*(globs->path_list + idx)) {
#line 297
      if (! (result <= 0)) {
#line 297
        goto while_break;
      }
    } else {
#line 297
      goto while_break;
    }
    {
#line 301
    dir = opendir((char const   *)*(globs->path_list + idx));
    }
#line 301
    if (dir) {
      {
#line 306
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 306
        elem = readdir(dir);
        }
#line 306
        if (elem) {
#line 306
          if (! (result <= 0)) {
#line 306
            goto while_break___0;
          }
        } else {
#line 306
          goto while_break___0;
        }
        {
#line 310
        tmp = strlen((char const   *)*(globs->path_list + idx));
#line 310
        tmp___0 = strlen((char const   *)(elem->d_name));
#line 310
        tmp___1 = malloc(((tmp + tmp___0) + 1U) + 1U);
#line 310
        name = (char *)tmp___1;
        }
#line 312
        if (name) {
          {
#line 316
          strcpy((char */* __restrict  */)name, (char const   */* __restrict  */)*(globs->path_list + idx));
#line 317
          strcat((char */* __restrict  */)name, (char const   */* __restrict  */)"/");
#line 318
          strcat((char */* __restrict  */)name, (char const   */* __restrict  */)(elem->d_name));
#line 320
          tmp___3 = stat((char const   */* __restrict  */)name, (struct stat */* __restrict  */)(& buf));
          }
#line 320
          if (tmp___3 == 0) {
#line 322
            if (buf.st_mode & 32768U) {
              {
#line 324
              result = bsdl_read_file(chain, (char const   *)name, proc_mode, idcode___0);
              }
#line 325
              if (result == 1) {
                {
#line 326
                tmp___2 = gettext("  Filename:     %s\n");
#line 326
                printf((char const   */* __restrict  */)tmp___2, name);
                }
              }
            }
          }
          {
#line 330
          free((void *)name);
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 334
      closedir(dir);
      }
    } else {
      {
#line 337
      tmp___4 = gettext("Cannot open directory %s\n");
#line 337
      bsdl_msg(proc_mode, 1, (char const   *)tmp___4, *(globs->path_list + idx));
      }
    }
#line 340
    idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 343
  return (result);
}
}
#line 165 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1))) strtod)(char const   * __restrict  __nptr ,
                                                                                      char ** __restrict  __endptr ) ;
#line 473
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
#line 289 "svf_flex.c"
void svfrestart(FILE *input_file , yyscan_t yyscanner ) ;
#line 290
void svf_switch_to_buffer(YY_BUFFER_STATE new_buffer , yyscan_t yyscanner ) ;
#line 291
YY_BUFFER_STATE svf_create_buffer(FILE *file , int size , yyscan_t yyscanner ) ;
#line 292
void svf_delete_buffer(YY_BUFFER_STATE b , yyscan_t yyscanner ) ;
#line 293
void svf_flush_buffer(YY_BUFFER_STATE b , yyscan_t yyscanner ) ;
#line 294
void svfpush_buffer_state(YY_BUFFER_STATE new_buffer , yyscan_t yyscanner ) ;
#line 295
void svfpop_buffer_state(yyscan_t yyscanner ) ;
#line 297
static void svfensure_buffer_stack(yyscan_t yyscanner ) ;
#line 298
static void svf_load_buffer_state(yyscan_t yyscanner ) ;
#line 299
static void svf_init_buffer(YY_BUFFER_STATE b , FILE *file , yyscan_t yyscanner ) ;
#line 303
YY_BUFFER_STATE svf_scan_buffer(char *base , yy_size_t size , yyscan_t yyscanner ) ;
#line 304
YY_BUFFER_STATE svf_scan_string(char const   *yystr , yyscan_t yyscanner ) ;
#line 305
YY_BUFFER_STATE svf_scan_bytes(char const   *yybytes , int _yybytes_len , yyscan_t yyscanner ) ;
#line 307
void *svfalloc(yy_size_t size , yyscan_t yyscanner ) ;
#line 308
void *svfrealloc(void *ptr , yy_size_t size , yyscan_t yyscanner ) ;
#line 309
void svffree(void *ptr , yyscan_t yyscanner ) ;
#line 343
static yy_state_type yy_get_previous_state___1(yyscan_t yyscanner ) ;
#line 344
static yy_state_type yy_try_NUL_trans___1(yy_state_type yy_current_state , yyscan_t yyscanner ) ;
#line 345
static int yy_get_next_buffer___1(yyscan_t yyscanner ) ;
#line 346
static void yy_fatal_error___1(char const   *msg , yyscan_t yyscanner ) ;
#line 367 "svf_flex.c"
static flex_int16_t const   yy_accept___1[43]  = 
#line 367
  {      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )12,      (flex_int16_t const   )10,      (flex_int16_t const   )5, 
        (flex_int16_t const   )8,      (flex_int16_t const   )6,      (flex_int16_t const   )7,      (flex_int16_t const   )7, 
        (flex_int16_t const   )10,      (flex_int16_t const   )2,      (flex_int16_t const   )9,      (flex_int16_t const   )1, 
        (flex_int16_t const   )7,      (flex_int16_t const   )5,      (flex_int16_t const   )6,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )2, 
        (flex_int16_t const   )0,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )4, 
        (flex_int16_t const   )0,      (flex_int16_t const   )6,      (flex_int16_t const   )2,      (flex_int16_t const   )0, 
        (flex_int16_t const   )2,      (flex_int16_t const   )0,      (flex_int16_t const   )3,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )3,      (flex_int16_t const   )0};
#line 376 "svf_flex.c"
static flex_int32_t const   yy_ec___1[256]  = 
#line 376
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )2,      (flex_int32_t const   )3,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )2,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )2,      (flex_int32_t const   )4,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )5,      (flex_int32_t const   )6,      (flex_int32_t const   )1,      (flex_int32_t const   )7, 
        (flex_int32_t const   )1,      (flex_int32_t const   )7,      (flex_int32_t const   )8,      (flex_int32_t const   )9, 
        (flex_int32_t const   )10,      (flex_int32_t const   )10,      (flex_int32_t const   )10,      (flex_int32_t const   )10, 
        (flex_int32_t const   )10,      (flex_int32_t const   )10,      (flex_int32_t const   )10,      (flex_int32_t const   )10, 
        (flex_int32_t const   )10,      (flex_int32_t const   )10,      (flex_int32_t const   )1,      (flex_int32_t const   )11, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )12,      (flex_int32_t const   )12,      (flex_int32_t const   )12, 
        (flex_int32_t const   )13,      (flex_int32_t const   )14,      (flex_int32_t const   )12,      (flex_int32_t const   )15, 
        (flex_int32_t const   )16,      (flex_int32_t const   )15,      (flex_int32_t const   )15,      (flex_int32_t const   )15, 
        (flex_int32_t const   )16,      (flex_int32_t const   )15,      (flex_int32_t const   )15,      (flex_int32_t const   )15, 
        (flex_int32_t const   )15,      (flex_int32_t const   )15,      (flex_int32_t const   )15,      (flex_int32_t const   )15, 
        (flex_int32_t const   )15,      (flex_int32_t const   )16,      (flex_int32_t const   )15,      (flex_int32_t const   )15, 
        (flex_int32_t const   )16,      (flex_int32_t const   )15,      (flex_int32_t const   )16,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )17, 
        (flex_int32_t const   )1,      (flex_int32_t const   )12,      (flex_int32_t const   )12,      (flex_int32_t const   )12, 
        (flex_int32_t const   )13,      (flex_int32_t const   )14,      (flex_int32_t const   )12,      (flex_int32_t const   )15, 
        (flex_int32_t const   )16,      (flex_int32_t const   )15,      (flex_int32_t const   )15,      (flex_int32_t const   )15, 
        (flex_int32_t const   )16,      (flex_int32_t const   )15,      (flex_int32_t const   )15,      (flex_int32_t const   )15, 
        (flex_int32_t const   )15,      (flex_int32_t const   )15,      (flex_int32_t const   )15,      (flex_int32_t const   )15, 
        (flex_int32_t const   )15,      (flex_int32_t const   )16,      (flex_int32_t const   )15,      (flex_int32_t const   )15, 
        (flex_int32_t const   )16,      (flex_int32_t const   )15,      (flex_int32_t const   )16,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1};
#line 408 "svf_flex.c"
static flex_int32_t const   yy_meta___1[18]  = 
#line 408
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )2,      (flex_int32_t const   )3, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )4,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )5,      (flex_int32_t const   )1, 
        (flex_int32_t const   )5,      (flex_int32_t const   )6,      (flex_int32_t const   )5,      (flex_int32_t const   )7, 
        (flex_int32_t const   )8,      (flex_int32_t const   )7};
#line 414 "svf_flex.c"
static flex_int16_t const   yy_base___1[49]  = 
#line 414
  {      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )83, 
        (flex_int16_t const   )82,      (flex_int16_t const   )86,      (flex_int16_t const   )89,      (flex_int16_t const   )83, 
        (flex_int16_t const   )89,      (flex_int16_t const   )0,      (flex_int16_t const   )81,      (flex_int16_t const   )89, 
        (flex_int16_t const   )72,      (flex_int16_t const   )10,      (flex_int16_t const   )89,      (flex_int16_t const   )9, 
        (flex_int16_t const   )25,      (flex_int16_t const   )66,      (flex_int16_t const   )0,      (flex_int16_t const   )19, 
        (flex_int16_t const   )57,      (flex_int16_t const   )0,      (flex_int16_t const   )41,      (flex_int16_t const   )0, 
        (flex_int16_t const   )22,      (flex_int16_t const   )0,      (flex_int16_t const   )13,      (flex_int16_t const   )34, 
        (flex_int16_t const   )43,      (flex_int16_t const   )40,      (flex_int16_t const   )0,      (flex_int16_t const   )89, 
        (flex_int16_t const   )32,      (flex_int16_t const   )0,      (flex_int16_t const   )33,      (flex_int16_t const   )23, 
        (flex_int16_t const   )21,      (flex_int16_t const   )0,      (flex_int16_t const   )89,      (flex_int16_t const   )20, 
        (flex_int16_t const   )42,      (flex_int16_t const   )89,      (flex_int16_t const   )89,      (flex_int16_t const   )48, 
        (flex_int16_t const   )55,      (flex_int16_t const   )57,      (flex_int16_t const   )65,      (flex_int16_t const   )69, 
        (flex_int16_t const   )76};
#line 423 "svf_flex.c"
static flex_int16_t const   yy_def___1[49]  = 
#line 423
  {      (flex_int16_t const   )0,      (flex_int16_t const   )42,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42, 
        (flex_int16_t const   )42,      (flex_int16_t const   )43,      (flex_int16_t const   )44,      (flex_int16_t const   )42, 
        (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )45, 
        (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )43,      (flex_int16_t const   )44, 
        (flex_int16_t const   )19,      (flex_int16_t const   )46,      (flex_int16_t const   )42,      (flex_int16_t const   )13, 
        (flex_int16_t const   )42,      (flex_int16_t const   )47,      (flex_int16_t const   )45,      (flex_int16_t const   )16, 
        (flex_int16_t const   )27,      (flex_int16_t const   )48,      (flex_int16_t const   )19,      (flex_int16_t const   )42, 
        (flex_int16_t const   )19,      (flex_int16_t const   )46,      (flex_int16_t const   )42,      (flex_int16_t const   )42, 
        (flex_int16_t const   )42,      (flex_int16_t const   )27,      (flex_int16_t const   )42,      (flex_int16_t const   )27, 
        (flex_int16_t const   )48,      (flex_int16_t const   )42,      (flex_int16_t const   )0,      (flex_int16_t const   )42, 
        (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42, 
        (flex_int16_t const   )42};
#line 432 "svf_flex.c"
static flex_int16_t const   yy_nxt___1[107]  = 
#line 432
  {      (flex_int16_t const   )0,      (flex_int16_t const   )6,      (flex_int16_t const   )7,      (flex_int16_t const   )8, 
        (flex_int16_t const   )9,      (flex_int16_t const   )10,      (flex_int16_t const   )11,      (flex_int16_t const   )6, 
        (flex_int16_t const   )6,      (flex_int16_t const   )12,      (flex_int16_t const   )13,      (flex_int16_t const   )14, 
        (flex_int16_t const   )15,      (flex_int16_t const   )15,      (flex_int16_t const   )15,      (flex_int16_t const   )15, 
        (flex_int16_t const   )15,      (flex_int16_t const   )6,      (flex_int16_t const   )22,      (flex_int16_t const   )25, 
        (flex_int16_t const   )23,      (flex_int16_t const   )30,      (flex_int16_t const   )39,      (flex_int16_t const   )25, 
        (flex_int16_t const   )24,      (flex_int16_t const   )31,      (flex_int16_t const   )25,      (flex_int16_t const   )27, 
        (flex_int16_t const   )28,      (flex_int16_t const   )35,      (flex_int16_t const   )25,      (flex_int16_t const   )36, 
        (flex_int16_t const   )36,      (flex_int16_t const   )36,      (flex_int16_t const   )32,      (flex_int16_t const   )20, 
        (flex_int16_t const   )37,      (flex_int16_t const   )20,      (flex_int16_t const   )28,      (flex_int16_t const   )20, 
        (flex_int16_t const   )38,      (flex_int16_t const   )29,      (flex_int16_t const   )40,      (flex_int16_t const   )34, 
        (flex_int16_t const   )40,      (flex_int16_t const   )39,      (flex_int16_t const   )41,      (flex_int16_t const   )24, 
        (flex_int16_t const   )41,      (flex_int16_t const   )18,      (flex_int16_t const   )18,      (flex_int16_t const   )34, 
        (flex_int16_t const   )18,      (flex_int16_t const   )18,      (flex_int16_t const   )18,      (flex_int16_t const   )18, 
        (flex_int16_t const   )18,      (flex_int16_t const   )20,      (flex_int16_t const   )20,      (flex_int16_t const   )32, 
        (flex_int16_t const   )20,      (flex_int16_t const   )20,      (flex_int16_t const   )26,      (flex_int16_t const   )26, 
        (flex_int16_t const   )26,      (flex_int16_t const   )26,      (flex_int16_t const   )33,      (flex_int16_t const   )33, 
        (flex_int16_t const   )17,      (flex_int16_t const   )33,      (flex_int16_t const   )33,      (flex_int16_t const   )33, 
        (flex_int16_t const   )33,      (flex_int16_t const   )33,      (flex_int16_t const   )25,      (flex_int16_t const   )25, 
        (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )29,      (flex_int16_t const   )29, 
        (flex_int16_t const   )29,      (flex_int16_t const   )21,      (flex_int16_t const   )29,      (flex_int16_t const   )19, 
        (flex_int16_t const   )29,      (flex_int16_t const   )17,      (flex_int16_t const   )42,      (flex_int16_t const   )16, 
        (flex_int16_t const   )16,      (flex_int16_t const   )5,      (flex_int16_t const   )42,      (flex_int16_t const   )42, 
        (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42, 
        (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42, 
        (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42, 
        (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42};
#line 448 "svf_flex.c"
static flex_int16_t const   yy_chk___1[107]  = 
#line 448
  {      (flex_int16_t const   )0,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )13,      (flex_int16_t const   )15, 
        (flex_int16_t const   )13,      (flex_int16_t const   )19,      (flex_int16_t const   )39,      (flex_int16_t const   )26, 
        (flex_int16_t const   )13,      (flex_int16_t const   )19,      (flex_int16_t const   )15,      (flex_int16_t const   )16, 
        (flex_int16_t const   )16,      (flex_int16_t const   )24,      (flex_int16_t const   )26,      (flex_int16_t const   )36, 
        (flex_int16_t const   )24,      (flex_int16_t const   )35,      (flex_int16_t const   )32,      (flex_int16_t const   )16, 
        (flex_int16_t const   )27,      (flex_int16_t const   )16,      (flex_int16_t const   )16,      (flex_int16_t const   )16, 
        (flex_int16_t const   )27,      (flex_int16_t const   )16,      (flex_int16_t const   )29,      (flex_int16_t const   )34, 
        (flex_int16_t const   )40,      (flex_int16_t const   )28,      (flex_int16_t const   )29,      (flex_int16_t const   )34, 
        (flex_int16_t const   )40,      (flex_int16_t const   )43,      (flex_int16_t const   )43,      (flex_int16_t const   )22, 
        (flex_int16_t const   )43,      (flex_int16_t const   )43,      (flex_int16_t const   )43,      (flex_int16_t const   )43, 
        (flex_int16_t const   )43,      (flex_int16_t const   )44,      (flex_int16_t const   )44,      (flex_int16_t const   )20, 
        (flex_int16_t const   )44,      (flex_int16_t const   )44,      (flex_int16_t const   )45,      (flex_int16_t const   )45, 
        (flex_int16_t const   )45,      (flex_int16_t const   )45,      (flex_int16_t const   )46,      (flex_int16_t const   )46, 
        (flex_int16_t const   )17,      (flex_int16_t const   )46,      (flex_int16_t const   )46,      (flex_int16_t const   )46, 
        (flex_int16_t const   )46,      (flex_int16_t const   )46,      (flex_int16_t const   )47,      (flex_int16_t const   )47, 
        (flex_int16_t const   )47,      (flex_int16_t const   )47,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )12,      (flex_int16_t const   )48,      (flex_int16_t const   )10, 
        (flex_int16_t const   )48,      (flex_int16_t const   )7,      (flex_int16_t const   )5,      (flex_int16_t const   )4, 
        (flex_int16_t const   )3,      (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42, 
        (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42, 
        (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42, 
        (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42, 
        (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42};
#line 128 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) struct lconv *localeconv(void) ;
#line 117 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/svf/svf.h"
void *svf_flex_init(FILE *f , int num_lines , int print_progress ) ;
#line 118
void svf_flex_deinit(void *scanner ) ;
#line 48 "svf_flex.l"
static int map_keyw_ident(YYSTYPE___0 *mylval , char *str ) ;
#line 49
static void align_string(char *str ) ;
#line 51
static void fix_yylloc(YYLTYPE *mylloc , char *str ) ;
#line 52
static void fix_yylloc_nl(YYLTYPE *mylloc , char *str , scanner_extra_t *extra ) ;
#line 53
static void progress_nl(YYLTYPE *mylloc , scanner_extra_t *extra ) ;
#line 55 "svf_flex.l"
int svfwrap(yyscan_t scanner ) 
{ 


  {
#line 57
  return (1);
}
}
#line 583 "svf_flex.c"
static int yy_init_globals___1(yyscan_t yyscanner ) ;
#line 591
int svflex_init(yyscan_t *ptr_yy_globals ) ;
#line 593
int svflex_init_extra(scanner_extra_t *yy_user_defined , yyscan_t *ptr_yy_globals ) ;
#line 598
int svflex_destroy(yyscan_t yyscanner ) ;
#line 600
int svfget_debug(yyscan_t yyscanner ) ;
#line 602
void svfset_debug(int bdebug , yyscan_t yyscanner ) ;
#line 604
scanner_extra_t *svfget_extra(yyscan_t yyscanner ) ;
#line 606
void svfset_extra(scanner_extra_t *user_defined , yyscan_t yyscanner ) ;
#line 608
FILE *svfget_in(yyscan_t yyscanner ) ;
#line 610
void svfset_in(FILE *in_str , yyscan_t yyscanner ) ;
#line 612
FILE *svfget_out(yyscan_t yyscanner ) ;
#line 614
void svfset_out(FILE *out_str , yyscan_t yyscanner ) ;
#line 616
int svfget_leng(yyscan_t yyscanner ) ;
#line 618
char *svfget_text(yyscan_t yyscanner ) ;
#line 620
int svfget_lineno(yyscan_t yyscanner ) ;
#line 622
void svfset_lineno(int line_number , yyscan_t yyscanner ) ;
#line 624
YYSTYPE___0 *svfget_lval(yyscan_t yyscanner ) ;
#line 626
void svfset_lval(YYSTYPE___0 *yylval_param , yyscan_t yyscanner ) ;
#line 628
YYLTYPE *svfget_lloc(yyscan_t yyscanner ) ;
#line 630
void svfset_lloc(YYLTYPE *yylloc_param , yyscan_t yyscanner ) ;
#line 744
int svflex(YYSTYPE___0 *yylval_param , YYLTYPE *yylloc_param , yyscan_t yyscanner ) ;
#line 768 "svf_flex.c"
int svflex(YYSTYPE___0 *yylval_param , YYLTYPE *yylloc_param , yyscan_t yyscanner ) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register char *yy_bp ;
  register int yy_act ;
  struct yyguts_t___0 *yyg ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  YY_BUFFER_STATE tmp___2 ;
  register YY_CHAR yy_c ;
  int keyw ;
  char *real_string ;
  char *tmp___3 ;
  char *point_pos ;
  char *tmp___4 ;
  scanner_extra_t *extra ;
  scanner_extra_t *tmp___5 ;
  char *cstring ;
  scanner_extra_t *tmp___6 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  char *cstring___0 ;
  scanner_extra_t *tmp___9 ;
  size_t tmp___10 ;
  void *tmp___11 ;
  scanner_extra_t *tmp___12 ;
  int yy_amount_of_matched_text ;
  yy_state_type yy_next_state ;
  int tmp___13 ;
  int tmp___14 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;

  {
#line 773
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 781
  yyg->yylval_r = yylval_param;
#line 783
  yyg->yylloc_r = yylloc_param;
#line 785
  if (! yyg->yy_init) {
#line 787
    yyg->yy_init = 1;
#line 790
    tmp___1 = 0;
#line 790
    (yyg->yylloc_r)->last_column = tmp___1;
#line 790
    tmp___0 = tmp___1;
#line 790
    (yyg->yylloc_r)->first_column = tmp___0;
#line 790
    tmp = tmp___0;
#line 790
    (yyg->yylloc_r)->last_line = tmp;
#line 790
    (yyg->yylloc_r)->first_line = tmp;
#line 793
    if (! yyg->yy_start) {
#line 794
      yyg->yy_start = 1;
    }
#line 796
    if (! yyg->yyin_r) {
#line 797
      yyg->yyin_r = stdin;
    }
#line 799
    if (! yyg->yyout_r) {
#line 800
      yyg->yyout_r = stdout;
    }
#line 802
    if (yyg->yy_buffer_stack) {
#line 802
      tmp___2 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
    } else {
#line 802
      tmp___2 = (YY_BUFFER_STATE )((void *)0);
    }
#line 802
    if (! tmp___2) {
      {
#line 803
      svfensure_buffer_stack(yyscanner);
#line 804
      *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top) = svf_create_buffer(yyg->yyin_r,
                                                                             16384,
                                                                             yyscanner);
      }
    }
    {
#line 808
    svf_load_buffer_state(yyscanner);
    }
  }
  {
#line 811
  while (1) {
    while_continue: /* CIL Label */ ;
#line 813
    yy_cp = yyg->yy_c_buf_p;
#line 816
    *yy_cp = yyg->yy_hold_char;
#line 821
    yy_bp = yy_cp;
#line 823
    yy_current_state = yyg->yy_start;
    yy_match: 
    {
#line 825
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 827
      yy_c = (YY_CHAR )yy_ec___1[(unsigned int )((unsigned char )*yy_cp)];
#line 828
      if (yy_accept___1[yy_current_state]) {
#line 830
        yyg->yy_last_accepting_state = yy_current_state;
#line 831
        yyg->yy_last_accepting_cpos = yy_cp;
      }
      {
#line 833
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 833
        if (! ((int const   )yy_chk___1[(int const   )yy_base___1[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 833
          goto while_break___1;
        }
#line 835
        yy_current_state = (int )yy_def___1[yy_current_state];
#line 836
        if (yy_current_state >= 43) {
#line 837
          yy_c = (YY_CHAR )yy_meta___1[(unsigned int )yy_c];
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 839
      yy_current_state = (yy_state_type )yy_nxt___1[(unsigned int )yy_base___1[yy_current_state] + (unsigned int )yy_c];
#line 840
      yy_cp ++;
#line 825
      if (! ((int const   )yy_base___1[yy_current_state] != 89)) {
#line 825
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    yy_find_action: 
#line 845
    yy_act = (int )yy_accept___1[yy_current_state];
#line 846
    if (yy_act == 0) {
#line 848
      yy_cp = yyg->yy_last_accepting_cpos;
#line 849
      yy_current_state = yyg->yy_last_accepting_state;
#line 850
      yy_act = (int )yy_accept___1[yy_current_state];
    }
#line 853
    yyg->yytext_r = yy_bp;
#line 853
    yyg->yyleng_r = (int )((size_t )(yy_cp - yy_bp));
#line 853
    yyg->yy_hold_char = *yy_cp;
#line 853
    *yy_cp = (char )'\000';
#line 853
    yyg->yy_c_buf_p = yy_cp;
    do_action: 
    {
#line 859
    if (yy_act == 0) {
#line 859
      goto case_0;
    }
#line 866
    if (yy_act == 1) {
#line 866
      goto case_1;
    }
#line 94
    if (yy_act == 2) {
#line 94 "svf_flex.l"
      goto case_2;
    }
#line 122
    if (yy_act == 3) {
#line 122
      goto case_3;
    }
#line 141
    if (yy_act == 4) {
#line 141
      goto case_4;
    }
#line 155
    if (yy_act == 5) {
#line 155
      goto case_5;
    }
#line 161
    if (yy_act == 6) {
#line 161
      goto case_6;
    }
#line 167
    if (yy_act == 7) {
#line 167
      goto case_7;
    }
#line 174
    if (yy_act == 8) {
#line 174
      goto case_8;
    }
#line 184
    if (yy_act == 9) {
#line 184
      goto case_9;
    }
#line 196
    if (yy_act == 14) {
#line 196
      goto case_14;
    }
#line 196
    if (yy_act == 13) {
#line 196
      goto case_14;
    }
#line 201
    if (yy_act == 10) {
#line 201
      goto case_10;
    }
#line 209
    if (yy_act == 11) {
#line 209
      goto case_11;
    }
#line 1029
    if (yy_act == 12) {
#line 1029 "svf_flex.c"
      goto case_12;
    }
#line 1151
    goto switch_default;
    case_0: /* CIL Label */ 
#line 861
    *yy_cp = yyg->yy_hold_char;
#line 862
    yy_cp = yyg->yy_last_accepting_cpos;
#line 863
    yy_current_state = yyg->yy_last_accepting_state;
#line 864
    goto yy_find_action;
    case_1: /* CIL Label */ 
    {
#line 83 "svf_flex.l"
    fix_yylloc(yyg->yylloc_r, yyg->yytext_r);
#line 84
    keyw = map_keyw_ident(yyg->yylval_r, yyg->yytext_r);
    }
#line 87
    if (keyw == 285) {
#line 88
      yyg->yy_start = 3;
    }
#line 91
    return (keyw);
#line 93
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 98
    tmp___3 = strdup((char const   *)yyg->yytext_r);
#line 98
    real_string = tmp___3;
    }
#line 104
    if (real_string) {
      {
#line 105
      tmp___4 = strchr((char const   *)real_string, '.');
#line 105
      point_pos = tmp___4;
#line 106
      tmp___5 = svfget_extra(yyscanner);
#line 106
      extra = tmp___5;
      }
#line 108
      if (point_pos) {
#line 110
        *point_pos = extra->decimal_point;
      }
      {
#line 112
      (yyg->yylval_r)->dvalue = strtod((char const   */* __restrict  */)real_string,
                                       (char **/* __restrict  */)((char **)((void *)0)));
#line 113
      fix_yylloc(yyg->yylloc_r, yyg->yytext_r);
#line 115
      free((void *)real_string);
      }
    } else {
#line 117
      (yyg->yylval_r)->dvalue = 0.0;
    }
#line 119
    return (259);
#line 121
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 132
    tmp___6 = svfget_extra(yyscanner);
#line 132
    fix_yylloc_nl(yyg->yylloc_r, yyg->yytext_r, tmp___6);
#line 133
    align_string(yyg->yytext_r);
#line 135
    tmp___7 = strlen((char const   *)yyg->yytext_r);
#line 135
    tmp___8 = calloc(tmp___7 + 1U, (size_t )sizeof(char ));
#line 135
    cstring = (char *)tmp___8;
#line 136
    strcpy((char */* __restrict  */)cstring, (char const   */* __restrict  */)yyg->yytext_r);
#line 137
    (yyg->yylval_r)->cvalue = cstring;
    }
#line 138
    return (261);
#line 140
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 146
    tmp___9 = svfget_extra(yyscanner);
#line 146
    fix_yylloc_nl(yyg->yylloc_r, yyg->yytext_r, tmp___9);
#line 147
    align_string(yyg->yytext_r);
#line 149
    tmp___10 = strlen((char const   *)yyg->yytext_r);
#line 149
    tmp___11 = calloc(tmp___10 + 1U, (size_t )sizeof(char ));
#line 149
    cstring___0 = (char *)tmp___11;
#line 150
    strcpy((char */* __restrict  */)cstring___0, (char const   */* __restrict  */)yyg->yytext_r);
#line 151
    (yyg->yylval_r)->cvalue = cstring___0;
    }
#line 152
    return (260);
#line 154
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 158
    fix_yylloc(yyg->yylloc_r, yyg->yytext_r);
    }
#line 160
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 164
    fix_yylloc(yyg->yylloc_r, yyg->yytext_r);
    }
#line 166
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 170
    fix_yylloc(yyg->yylloc_r, yyg->yytext_r);
    }
#line 171
    return ((int )*(yyg->yytext_r + 0));
#line 173
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 177
    (yyg->yylloc_r)->first_line = (yyg->yylloc_r)->last_line;
#line 178
    (yyg->yylloc_r)->first_column = (yyg->yylloc_r)->last_column;
#line 179
    ((yyg->yylloc_r)->last_line) ++;
#line 180
    (yyg->yylloc_r)->last_column = 0;
#line 181
    tmp___12 = svfget_extra(yyscanner);
#line 181
    progress_nl(yyg->yylloc_r, tmp___12);
    }
#line 183
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 189
    yyg->yy_start = 1;
#line 191
    fix_yylloc(yyg->yylloc_r, yyg->yytext_r);
    }
#line 192
    return ((int )*(yyg->yytext_r + 0));
#line 194
    goto switch_break;
    case_14: /* CIL Label */ 
    case_13: /* CIL Label */ 
#line 198
    return (-1);
#line 200
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 205
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: \"%s\" is not a legal SVF language token\n",
            yyg->yytext_r);
    }
#line 208
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 209
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 209
      fwrite((void const   */* __restrict  */)yyg->yytext_r, (size_t )yyg->yyleng_r,
             (size_t )1, (FILE */* __restrict  */)yyg->yyout_r);
      }
#line 209
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 210
    goto switch_break;
    case_12: /* CIL Label */ 
#line 1032 "svf_flex.c"
    yy_amount_of_matched_text = (int )(yy_cp - yyg->yytext_r) - 1;
#line 1035
    *yy_cp = yyg->yy_hold_char;
#line 1038
    if ((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buffer_status == 0) {
#line 1049
      yyg->yy_n_chars = (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_n_chars;
#line 1050
      (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_input_file = yyg->yyin_r;
#line 1051
      (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buffer_status = 1;
    }
#line 1061
    if ((unsigned long )yyg->yy_c_buf_p <= (unsigned long )((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + yyg->yy_n_chars)) {
      {
#line 1065
      yyg->yy_c_buf_p = yyg->yytext_r + yy_amount_of_matched_text;
#line 1067
      yy_current_state = yy_get_previous_state___1(yyscanner);
#line 1078
      yy_next_state = yy_try_NUL_trans___1(yy_current_state, yyscanner);
#line 1080
      yy_bp = yyg->yytext_r + 0;
      }
#line 1082
      if (yy_next_state) {
#line 1085
        (yyg->yy_c_buf_p) ++;
#line 1085
        yy_cp = yyg->yy_c_buf_p;
#line 1086
        yy_current_state = yy_next_state;
#line 1087
        goto yy_match;
      } else {
#line 1092
        yy_cp = yyg->yy_c_buf_p;
#line 1093
        goto yy_find_action;
      }
    } else {
      {
#line 1097
      tmp___13 = yy_get_next_buffer___1(yyscanner);
      }
      {
#line 1099
      if (tmp___13 == 1) {
#line 1099
        goto case_1___0;
      }
#line 1128
      if (tmp___13 == 0) {
#line 1128
        goto case_0___0;
      }
#line 1138
      if (tmp___13 == 2) {
#line 1138
        goto case_2___0;
      }
#line 1097
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
      {
#line 1101
      yyg->yy_did_buffer_switch_on_eof = 0;
#line 1103
      tmp___14 = svfwrap(yyscanner);
      }
#line 1103
      if (tmp___14) {
#line 1114
        yyg->yy_c_buf_p = yyg->yytext_r + 0;
#line 1116
        yy_act = (12 + (yyg->yy_start - 1) / 2) + 1;
#line 1117
        goto do_action;
      } else
#line 1122
      if (! yyg->yy_did_buffer_switch_on_eof) {
        {
#line 1123
        svfrestart(yyg->yyin_r, yyscanner);
        }
      }
#line 1125
      goto switch_break___0;
      case_0___0: /* CIL Label */ 
      {
#line 1129
      yyg->yy_c_buf_p = yyg->yytext_r + yy_amount_of_matched_text;
#line 1132
      yy_current_state = yy_get_previous_state___1(yyscanner);
#line 1134
      yy_cp = yyg->yy_c_buf_p;
#line 1135
      yy_bp = yyg->yytext_r + 0;
      }
#line 1136
      goto yy_match;
      case_2___0: /* CIL Label */ 
      {
#line 1139
      yyg->yy_c_buf_p = (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + yyg->yy_n_chars;
#line 1142
      yy_current_state = yy_get_previous_state___1(yyscanner);
#line 1144
      yy_cp = yyg->yy_c_buf_p;
#line 1145
      yy_bp = yyg->yytext_r + 0;
      }
#line 1146
      goto yy_find_action;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 1148
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1152
    yy_fatal_error___1("fatal flex scanner internal error--no action found", yyscanner);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1165 "svf_flex.c"
static int yy_get_next_buffer___1(yyscan_t yyscanner ) 
{ 
  struct yyguts_t___0 *yyg ;
  register char *dest ;
  register char *source ;
  register int number_to_move ;
  register int i ;
  int ret_val ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int num_to_read ;
  YY_BUFFER_STATE b ;
  YY_BUFFER_STATE tmp___2 ;
  int yy_c_buf_p_offset ;
  int new_size ;
  void *tmp___3 ;
  int c ;
  size_t n ;
  size_t tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;
  yy_size_t new_size___0 ;
  void *tmp___12 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;

  {
#line 1167
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 1168
  dest = (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf;
#line 1169
  source = yyg->yytext_r;
#line 1173
  if ((unsigned long )yyg->yy_c_buf_p > (unsigned long )((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + (yyg->yy_n_chars + 1))) {
    {
#line 1174
    yy_fatal_error___1("fatal flex scanner internal error--end of buffer missed",
                       yyscanner);
    }
  }
#line 1177
  if ((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_fill_buffer == 0) {
#line 1179
    if (yyg->yy_c_buf_p - yyg->yytext_r == 1L) {
#line 1184
      return (1);
    } else {
#line 1192
      return (2);
    }
  }
#line 1199
  number_to_move = (int )(yyg->yy_c_buf_p - yyg->yytext_r) - 1;
#line 1201
  i = 0;
  {
#line 1201
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1201
    if (! (i < number_to_move)) {
#line 1201
      goto while_break;
    }
#line 1202
    tmp = dest;
#line 1202
    dest ++;
#line 1202
    tmp___0 = source;
#line 1202
    source ++;
#line 1202
    *tmp = *tmp___0;
#line 1201
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1204
  if ((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buffer_status == 2) {
#line 1208
    tmp___1 = 0;
#line 1208
    yyg->yy_n_chars = tmp___1;
#line 1208
    (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_n_chars = tmp___1;
  } else {
#line 1212
    num_to_read = (int )(((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buf_size - (yy_size_t )number_to_move) - 1U);
    {
#line 1215
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1215
      if (! (num_to_read <= 0)) {
#line 1215
        goto while_break___0;
      }
#line 1219
      if (yyg->yy_buffer_stack) {
#line 1219
        tmp___2 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
      } else {
#line 1219
        tmp___2 = (YY_BUFFER_STATE )((void *)0);
      }
#line 1219
      b = tmp___2;
#line 1221
      yy_c_buf_p_offset = (int )(yyg->yy_c_buf_p - b->yy_ch_buf);
#line 1224
      if (b->yy_is_our_buffer) {
#line 1226
        new_size = (int )(b->yy_buf_size * 2U);
#line 1228
        if (new_size <= 0) {
#line 1229
          b->yy_buf_size += b->yy_buf_size / 8U;
        } else {
#line 1231
          b->yy_buf_size *= 2U;
        }
        {
#line 1233
        tmp___3 = svfrealloc((void *)b->yy_ch_buf, b->yy_buf_size + 2U, yyscanner);
#line 1233
        b->yy_ch_buf = (char *)tmp___3;
        }
      } else {
#line 1239
        b->yy_ch_buf = (char *)0;
      }
#line 1241
      if (! b->yy_ch_buf) {
        {
#line 1242
        yy_fatal_error___1("fatal error - scanner input buffer overflow", yyscanner);
        }
      }
#line 1245
      yyg->yy_c_buf_p = b->yy_ch_buf + yy_c_buf_p_offset;
#line 1247
      num_to_read = (int )(((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buf_size - (yy_size_t )number_to_move) - 1U);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1252
    if (num_to_read > 8192) {
#line 1253
      num_to_read = 8192;
    }
#line 1256
    if ((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_is_interactive) {
#line 1256
      c = '*';
#line 1256
      n = (size_t )0;
      {
#line 1256
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1256
        if (n < (size_t )num_to_read) {
          {
#line 1256
          c = _IO_getc(yyg->yyin_r);
          }
#line 1256
          if (c != -1) {
#line 1256
            if (! (c != 10)) {
#line 1256
              goto while_break___1;
            }
          } else {
#line 1256
            goto while_break___1;
          }
        } else {
#line 1256
          goto while_break___1;
        }
#line 1256
        *(((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + number_to_move) + n) = (char )c;
#line 1256
        n ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1256
      if (c == 10) {
#line 1256
        tmp___4 = n;
#line 1256
        n ++;
#line 1256
        *(((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + number_to_move) + tmp___4) = (char )c;
      }
#line 1256
      if (c == -1) {
        {
#line 1256
        tmp___5 = ferror(yyg->yyin_r);
        }
#line 1256
        if (tmp___5) {
          {
#line 1256
          yy_fatal_error___1("input in flex scanner failed", yyscanner);
          }
        }
      }
#line 1256
      yyg->yy_n_chars = (int )n;
    } else {
      {
#line 1256
      tmp___6 = __errno_location();
#line 1256
      *tmp___6 = 0;
      }
      {
#line 1256
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 1256
        tmp___10 = fread((void */* __restrict  */)((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + number_to_move),
                         (size_t )1, (size_t )num_to_read, (FILE */* __restrict  */)yyg->yyin_r);
#line 1256
        tmp___9 = (int )tmp___10;
#line 1256
        yyg->yy_n_chars = tmp___9;
        }
#line 1256
        if (tmp___9 == 0) {
          {
#line 1256
          tmp___11 = ferror(yyg->yyin_r);
          }
#line 1256
          if (! tmp___11) {
#line 1256
            goto while_break___2;
          }
        } else {
#line 1256
          goto while_break___2;
        }
        {
#line 1256
        tmp___7 = __errno_location();
        }
#line 1256
        if (*tmp___7 != 4) {
          {
#line 1256
          yy_fatal_error___1("input in flex scanner failed", yyscanner);
          }
#line 1256
          goto while_break___2;
        }
        {
#line 1256
        tmp___8 = __errno_location();
#line 1256
        *tmp___8 = 0;
#line 1256
        clearerr(yyg->yyin_r);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 1259
    (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_n_chars = yyg->yy_n_chars;
  }
#line 1262
  if (yyg->yy_n_chars == 0) {
#line 1264
    if (number_to_move == 0) {
      {
#line 1266
      ret_val = 1;
#line 1267
      svfrestart(yyg->yyin_r, yyscanner);
      }
    } else {
#line 1272
      ret_val = 2;
#line 1273
      (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buffer_status = 2;
    }
  } else {
#line 1279
    ret_val = 0;
  }
#line 1281
  if ((yy_size_t )(yyg->yy_n_chars + number_to_move) > (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buf_size) {
    {
#line 1283
    new_size___0 = (yy_size_t )((yyg->yy_n_chars + number_to_move) + (yyg->yy_n_chars >> 1));
#line 1284
    tmp___12 = svfrealloc((void *)(*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf,
                          new_size___0, yyscanner);
#line 1284
    (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf = (char *)tmp___12;
    }
#line 1285
    if (! (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf) {
      {
#line 1286
      yy_fatal_error___1("out of dynamic memory in yy_get_next_buffer()", yyscanner);
      }
    }
  }
#line 1289
  yyg->yy_n_chars += number_to_move;
#line 1290
  *((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + yyg->yy_n_chars) = (char)0;
#line 1291
  *((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + (yyg->yy_n_chars + 1)) = (char)0;
#line 1293
  yyg->yytext_r = (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + 0;
#line 1295
  return (ret_val);
}
}
#line 1300 "svf_flex.c"
static yy_state_type yy_get_previous_state___1(yyscan_t yyscanner ) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  struct yyguts_t___0 *yyg ;
  register YY_CHAR yy_c ;
  flex_int32_t tmp ;

  {
#line 1304
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 1306
  yy_current_state = yyg->yy_start;
#line 1308
  yy_cp = yyg->yytext_r + 0;
  {
#line 1308
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1308
    if (! ((unsigned long )yy_cp < (unsigned long )yyg->yy_c_buf_p)) {
#line 1308
      goto while_break;
    }
#line 1310
    if (*yy_cp) {
#line 1310
      tmp = yy_ec___1[(unsigned int )((unsigned char )*yy_cp)];
    } else {
#line 1310
      tmp = (flex_int32_t const   )1;
    }
#line 1310
    yy_c = (YY_CHAR )tmp;
#line 1311
    if (yy_accept___1[yy_current_state]) {
#line 1313
      yyg->yy_last_accepting_state = yy_current_state;
#line 1314
      yyg->yy_last_accepting_cpos = yy_cp;
    }
    {
#line 1316
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1316
      if (! ((int const   )yy_chk___1[(int const   )yy_base___1[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1316
        goto while_break___0;
      }
#line 1318
      yy_current_state = (int )yy_def___1[yy_current_state];
#line 1319
      if (yy_current_state >= 43) {
#line 1320
        yy_c = (YY_CHAR )yy_meta___1[(unsigned int )yy_c];
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1322
    yy_current_state = (yy_state_type )yy_nxt___1[(unsigned int )yy_base___1[yy_current_state] + (unsigned int )yy_c];
#line 1308
    yy_cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1325
  return (yy_current_state);
}
}
#line 1333 "svf_flex.c"
static yy_state_type yy_try_NUL_trans___1(yy_state_type yy_current_state , yyscan_t yyscanner ) 
{ 
  register int yy_is_jam ;
  struct yyguts_t___0 *yyg ;
  register char *yy_cp ;
  register YY_CHAR yy_c ;
  int tmp ;

  {
#line 1336
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 1337
  yy_cp = yyg->yy_c_buf_p;
#line 1339
  yy_c = (YY_CHAR )1;
#line 1340
  if (yy_accept___1[yy_current_state]) {
#line 1342
    yyg->yy_last_accepting_state = yy_current_state;
#line 1343
    yyg->yy_last_accepting_cpos = yy_cp;
  }
  {
#line 1345
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1345
    if (! ((int const   )yy_chk___1[(int const   )yy_base___1[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1345
      goto while_break;
    }
#line 1347
    yy_current_state = (int )yy_def___1[yy_current_state];
#line 1348
    if (yy_current_state >= 43) {
#line 1349
      yy_c = (YY_CHAR )yy_meta___1[(unsigned int )yy_c];
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1351
  yy_current_state = (yy_state_type )yy_nxt___1[(unsigned int )yy_base___1[yy_current_state] + (unsigned int )yy_c];
#line 1352
  yy_is_jam = yy_current_state == 42;
#line 1354
  if (yy_is_jam) {
#line 1354
    tmp = 0;
  } else {
#line 1354
    tmp = yy_current_state;
  }
#line 1354
  return (tmp);
}
}
#line 1475 "svf_flex.c"
void svfrestart(FILE *input_file , yyscan_t yyscanner ) 
{ 
  struct yyguts_t___0 *yyg ;
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 1477
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 1479
  if (yyg->yy_buffer_stack) {
#line 1479
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 1479
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1479
  if (! tmp) {
    {
#line 1480
    svfensure_buffer_stack(yyscanner);
#line 1481
    *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top) = svf_create_buffer(yyg->yyin_r,
                                                                           16384,
                                                                           yyscanner);
    }
  }
#line 1485
  if (yyg->yy_buffer_stack) {
#line 1485
    tmp___0 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 1485
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 1485
  svf_init_buffer(tmp___0, input_file, yyscanner);
#line 1486
  svf_load_buffer_state(yyscanner);
  }
#line 1487
  return;
}
}
#line 1493 "svf_flex.c"
void svf_switch_to_buffer(YY_BUFFER_STATE new_buffer , yyscan_t yyscanner ) 
{ 
  struct yyguts_t___0 *yyg ;
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 1495
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 1502
  svfensure_buffer_stack(yyscanner);
  }
#line 1503
  if (yyg->yy_buffer_stack) {
#line 1503
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 1503
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1503
  if ((unsigned long )tmp == (unsigned long )new_buffer) {
#line 1504
    return;
  }
#line 1506
  if (yyg->yy_buffer_stack) {
#line 1506
    tmp___0 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 1506
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1506
  if (tmp___0) {
#line 1509
    *(yyg->yy_c_buf_p) = yyg->yy_hold_char;
#line 1510
    (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buf_pos = yyg->yy_c_buf_p;
#line 1511
    (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_n_chars = yyg->yy_n_chars;
  }
  {
#line 1514
  *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top) = new_buffer;
#line 1515
  svf_load_buffer_state(yyscanner);
#line 1522
  yyg->yy_did_buffer_switch_on_eof = 1;
  }
#line 1523
  return;
}
}
#line 1525 "svf_flex.c"
static void svf_load_buffer_state(yyscan_t yyscanner ) 
{ 
  struct yyguts_t___0 *yyg ;
  char *tmp ;

  {
#line 1527
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 1528
  yyg->yy_n_chars = (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_n_chars;
#line 1529
  tmp = (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buf_pos;
#line 1529
  yyg->yy_c_buf_p = tmp;
#line 1529
  yyg->yytext_r = tmp;
#line 1530
  yyg->yyin_r = (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_input_file;
#line 1531
  yyg->yy_hold_char = *(yyg->yy_c_buf_p);
#line 1532
  return;
}
}
#line 1540 "svf_flex.c"
YY_BUFFER_STATE svf_create_buffer(FILE *file , int size , yyscan_t yyscanner ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  void *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 1544
  tmp = svfalloc((yy_size_t )sizeof(struct yy_buffer_state ), yyscanner);
#line 1544
  b = (YY_BUFFER_STATE )tmp;
  }
#line 1545
  if (! b) {
    {
#line 1546
    yy_fatal_error___1("out of dynamic memory in svf_create_buffer()", yyscanner);
    }
  }
  {
#line 1548
  b->yy_buf_size = (yy_size_t )size;
#line 1553
  tmp___0 = svfalloc(b->yy_buf_size + 2U, yyscanner);
#line 1553
  b->yy_ch_buf = (char *)tmp___0;
  }
#line 1554
  if (! b->yy_ch_buf) {
    {
#line 1555
    yy_fatal_error___1("out of dynamic memory in svf_create_buffer()", yyscanner);
    }
  }
  {
#line 1557
  b->yy_is_our_buffer = 1;
#line 1559
  svf_init_buffer(b, file, yyscanner);
  }
#line 1561
  return (b);
}
}
#line 1568 "svf_flex.c"
void svf_delete_buffer(YY_BUFFER_STATE b , yyscan_t yyscanner ) 
{ 
  struct yyguts_t___0 *yyg ;
  YY_BUFFER_STATE tmp ;

  {
#line 1570
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 1572
  if (! b) {
#line 1573
    return;
  }
#line 1575
  if (yyg->yy_buffer_stack) {
#line 1575
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 1575
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1575
  if ((unsigned long )b == (unsigned long )tmp) {
#line 1576
    *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top) = (YY_BUFFER_STATE )0;
  }
#line 1578
  if (b->yy_is_our_buffer) {
    {
#line 1579
    svffree((void *)b->yy_ch_buf, yyscanner);
    }
  }
  {
#line 1581
  svffree((void *)b, yyscanner);
  }
#line 1582
  return;
}
}
#line 1592 "svf_flex.c"
static void svf_init_buffer(YY_BUFFER_STATE b , FILE *file , yyscan_t yyscanner ) 
{ 
  int oerrno ;
  int *tmp ;
  struct yyguts_t___0 *yyg ;
  YY_BUFFER_STATE tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 1595
  tmp = __errno_location();
#line 1595
  oerrno = *tmp;
#line 1596
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 1598
  svf_flush_buffer(b, yyscanner);
#line 1600
  b->yy_input_file = file;
#line 1601
  b->yy_fill_buffer = 1;
  }
#line 1607
  if (yyg->yy_buffer_stack) {
#line 1607
    tmp___0 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 1607
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1607
  if ((unsigned long )b != (unsigned long )tmp___0) {
#line 1608
    b->yy_bs_lineno = 1;
#line 1609
    b->yy_bs_column = 0;
  }
#line 1612
  if (file) {
    {
#line 1612
    tmp___1 = fileno(file);
#line 1612
    tmp___2 = isatty(tmp___1);
#line 1612
    b->yy_is_interactive = tmp___2 > 0;
    }
  } else {
#line 1612
    b->yy_is_interactive = 0;
  }
  {
#line 1614
  tmp___3 = __errno_location();
#line 1614
  *tmp___3 = oerrno;
  }
#line 1615
  return;
}
}
#line 1621 "svf_flex.c"
void svf_flush_buffer(YY_BUFFER_STATE b , yyscan_t yyscanner ) 
{ 
  struct yyguts_t___0 *yyg ;
  YY_BUFFER_STATE tmp ;

  {
#line 1623
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 1624
  if (! b) {
#line 1625
    return;
  }
#line 1627
  b->yy_n_chars = 0;
#line 1633
  *(b->yy_ch_buf + 0) = (char)0;
#line 1634
  *(b->yy_ch_buf + 1) = (char)0;
#line 1636
  b->yy_buf_pos = b->yy_ch_buf + 0;
#line 1638
  b->yy_at_bol = 1;
#line 1639
  b->yy_buffer_status = 0;
#line 1641
  if (yyg->yy_buffer_stack) {
#line 1641
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 1641
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1641
  if ((unsigned long )b == (unsigned long )tmp) {
    {
#line 1642
    svf_load_buffer_state(yyscanner);
    }
  }
#line 1643
  return;
}
}
#line 1651 "svf_flex.c"
void svfpush_buffer_state(YY_BUFFER_STATE new_buffer , yyscan_t yyscanner ) 
{ 
  struct yyguts_t___0 *yyg ;
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 1653
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 1654
  if ((unsigned long )new_buffer == (unsigned long )((void *)0)) {
#line 1655
    return;
  }
  {
#line 1657
  svfensure_buffer_stack(yyscanner);
  }
#line 1660
  if (yyg->yy_buffer_stack) {
#line 1660
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 1660
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1660
  if (tmp) {
#line 1663
    *(yyg->yy_c_buf_p) = yyg->yy_hold_char;
#line 1664
    (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buf_pos = yyg->yy_c_buf_p;
#line 1665
    (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_n_chars = yyg->yy_n_chars;
  }
#line 1669
  if (yyg->yy_buffer_stack) {
#line 1669
    tmp___0 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 1669
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1669
  if (tmp___0) {
#line 1670
    (yyg->yy_buffer_stack_top) ++;
  }
  {
#line 1671
  *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top) = new_buffer;
#line 1674
  svf_load_buffer_state(yyscanner);
#line 1675
  yyg->yy_did_buffer_switch_on_eof = 1;
  }
#line 1676
  return;
}
}
#line 1682 "svf_flex.c"
void svfpop_buffer_state(yyscan_t yyscanner ) 
{ 
  struct yyguts_t___0 *yyg ;
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;
  YY_BUFFER_STATE tmp___1 ;

  {
#line 1684
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 1685
  if (yyg->yy_buffer_stack) {
#line 1685
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 1685
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1685
  if (! tmp) {
#line 1686
    return;
  }
#line 1688
  if (yyg->yy_buffer_stack) {
#line 1688
    tmp___0 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 1688
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 1688
  svf_delete_buffer(tmp___0, yyscanner);
#line 1689
  *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top) = (YY_BUFFER_STATE )((void *)0);
  }
#line 1690
  if (yyg->yy_buffer_stack_top > 0U) {
#line 1691
    (yyg->yy_buffer_stack_top) --;
  }
#line 1693
  if (yyg->yy_buffer_stack) {
#line 1693
    tmp___1 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 1693
    tmp___1 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1693
  if (tmp___1) {
    {
#line 1694
    svf_load_buffer_state(yyscanner);
#line 1695
    yyg->yy_did_buffer_switch_on_eof = 1;
    }
  }
#line 1697
  return;
}
}
#line 1702 "svf_flex.c"
static void svfensure_buffer_stack(yyscan_t yyscanner ) 
{ 
  int num_to_alloc ;
  struct yyguts_t___0 *yyg ;
  void *tmp ;
  int grow_size ;
  void *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 1705
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 1707
  if (! yyg->yy_buffer_stack) {
    {
#line 1713
    num_to_alloc = 1;
#line 1714
    tmp = svfalloc((yy_size_t )((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *)),
                   yyscanner);
#line 1714
    yyg->yy_buffer_stack = (struct yy_buffer_state **)tmp;
    }
#line 1717
    if (! yyg->yy_buffer_stack) {
      {
#line 1718
      yy_fatal_error___1("out of dynamic memory in svfensure_buffer_stack()", yyscanner);
      }
    }
    {
#line 1720
    memset((void *)yyg->yy_buffer_stack, 0, (size_t )((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *)));
#line 1722
    yyg->yy_buffer_stack_max = (size_t )num_to_alloc;
#line 1723
    yyg->yy_buffer_stack_top = (size_t )0;
    }
#line 1724
    return;
  }
#line 1727
  if (yyg->yy_buffer_stack_top >= yyg->yy_buffer_stack_max - 1U) {
    {
#line 1730
    grow_size = 8;
#line 1732
    num_to_alloc = (int )(yyg->yy_buffer_stack_max + (size_t )grow_size);
#line 1733
    tmp___0 = svfrealloc((void *)yyg->yy_buffer_stack, (yy_size_t )((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *)),
                         yyscanner);
#line 1733
    yyg->yy_buffer_stack = (struct yy_buffer_state **)tmp___0;
    }
#line 1737
    if (! yyg->yy_buffer_stack) {
      {
#line 1738
      yy_fatal_error___1("out of dynamic memory in svfensure_buffer_stack()", yyscanner);
      }
    }
    {
#line 1741
    memset((void *)(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max), 0, (size_t )((unsigned long )grow_size * sizeof(struct yy_buffer_state *)));
#line 1742
    yyg->yy_buffer_stack_max = (size_t )num_to_alloc;
    }
  }
#line 1744
  return;
}
}
#line 1752 "svf_flex.c"
YY_BUFFER_STATE svf_scan_buffer(char *base , yy_size_t size , yyscan_t yyscanner ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  char *tmp___0 ;
  char *__cil_tmp7 ;

  {
#line 1756
  if (size < 2U) {
#line 1760
    return ((YY_BUFFER_STATE )0);
  } else
#line 1756
  if ((int )*(base + (size - 2U)) != 0) {
#line 1760
    return ((YY_BUFFER_STATE )0);
  } else
#line 1756
  if ((int )*(base + (size - 1U)) != 0) {
#line 1760
    return ((YY_BUFFER_STATE )0);
  }
  {
#line 1762
  tmp = svfalloc((yy_size_t )sizeof(struct yy_buffer_state ), yyscanner);
#line 1762
  b = (YY_BUFFER_STATE )tmp;
  }
#line 1763
  if (! b) {
    {
#line 1764
    yy_fatal_error___1("out of dynamic memory in svf_scan_buffer()", yyscanner);
    }
  }
  {
#line 1766
  b->yy_buf_size = size - 2U;
#line 1767
  tmp___0 = base;
#line 1767
  b->yy_ch_buf = tmp___0;
#line 1767
  b->yy_buf_pos = tmp___0;
#line 1768
  b->yy_is_our_buffer = 0;
#line 1769
  b->yy_input_file = (FILE *)0;
#line 1770
  b->yy_n_chars = (int )b->yy_buf_size;
#line 1771
  b->yy_is_interactive = 0;
#line 1772
  b->yy_at_bol = 1;
#line 1773
  b->yy_fill_buffer = 0;
#line 1774
  b->yy_buffer_status = 0;
#line 1776
  svf_switch_to_buffer(b, yyscanner);
  }
#line 1778
  return (b);
}
}
#line 1789 "svf_flex.c"
YY_BUFFER_STATE svf_scan_string(char const   *yystr , yyscan_t yyscanner ) 
{ 
  size_t tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 1792
  tmp = strlen(yystr);
#line 1792
  tmp___0 = svf_scan_bytes(yystr, (int )tmp, yyscanner);
  }
#line 1792
  return (tmp___0);
}
}
#line 1802 "svf_flex.c"
YY_BUFFER_STATE svf_scan_bytes(char const   *yybytes , int _yybytes_len , yyscan_t yyscanner ) 
{ 
  YY_BUFFER_STATE b ;
  char *buf ;
  yy_size_t n ;
  int i ;
  void *tmp ;
  char tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 1810
  n = (yy_size_t )(_yybytes_len + 2);
#line 1811
  tmp = svfalloc(n, yyscanner);
#line 1811
  buf = (char *)tmp;
  }
#line 1812
  if (! buf) {
    {
#line 1813
    yy_fatal_error___1("out of dynamic memory in svf_scan_bytes()", yyscanner);
    }
  }
#line 1815
  i = 0;
  {
#line 1815
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1815
    if (! (i < _yybytes_len)) {
#line 1815
      goto while_break;
    }
#line 1816
    *(buf + i) = (char )*(yybytes + i);
#line 1815
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1818
  tmp___0 = (char)0;
#line 1818
  *(buf + (_yybytes_len + 1)) = tmp___0;
#line 1818
  *(buf + _yybytes_len) = tmp___0;
#line 1820
  b = svf_scan_buffer(buf, n, yyscanner);
  }
#line 1821
  if (! b) {
    {
#line 1822
    yy_fatal_error___1("bad buffer in svf_scan_bytes()", yyscanner);
    }
  }
#line 1827
  b->yy_is_our_buffer = 1;
#line 1829
  return (b);
}
}
#line 1836 "svf_flex.c"
static void yy_fatal_error___1(char const   *msg , yyscan_t yyscanner ) 
{ 
  char *__cil_tmp3 ;

  {
  {
#line 1838
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          msg);
#line 1839
  exit(2);
  }
}
}
#line 1864 "svf_flex.c"
scanner_extra_t *svfget_extra(yyscan_t yyscanner ) 
{ 
  struct yyguts_t___0 *yyg ;

  {
#line 1866
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 1867
  return (yyg->yyextra_r);
}
}
#line 1873 "svf_flex.c"
int svfget_lineno(yyscan_t yyscanner ) 
{ 
  struct yyguts_t___0 *yyg ;
  YY_BUFFER_STATE tmp ;

  {
#line 1875
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 1877
  if (yyg->yy_buffer_stack) {
#line 1877
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 1877
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1877
  if (! tmp) {
#line 1878
    return (0);
  }
#line 1880
  return ((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_bs_lineno);
}
}
#line 1886 "svf_flex.c"
int svfget_column(yyscan_t yyscanner ) 
{ 
  struct yyguts_t___0 *yyg ;
  YY_BUFFER_STATE tmp ;

  {
#line 1888
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 1890
  if (yyg->yy_buffer_stack) {
#line 1890
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 1890
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1890
  if (! tmp) {
#line 1891
    return (0);
  }
#line 1893
  return ((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_bs_column);
}
}
#line 1899 "svf_flex.c"
FILE *svfget_in(yyscan_t yyscanner ) 
{ 
  struct yyguts_t___0 *yyg ;

  {
#line 1901
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 1902
  return (yyg->yyin_r);
}
}
#line 1908 "svf_flex.c"
FILE *svfget_out(yyscan_t yyscanner ) 
{ 
  struct yyguts_t___0 *yyg ;

  {
#line 1910
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 1911
  return (yyg->yyout_r);
}
}
#line 1917 "svf_flex.c"
int svfget_leng(yyscan_t yyscanner ) 
{ 
  struct yyguts_t___0 *yyg ;

  {
#line 1919
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 1920
  return (yyg->yyleng_r);
}
}
#line 1927 "svf_flex.c"
char *svfget_text(yyscan_t yyscanner ) 
{ 
  struct yyguts_t___0 *yyg ;

  {
#line 1929
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 1930
  return (yyg->yytext_r);
}
}
#line 1937 "svf_flex.c"
void svfset_extra(scanner_extra_t *user_defined , yyscan_t yyscanner ) 
{ 
  struct yyguts_t___0 *yyg ;

  {
#line 1939
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 1940
  yyg->yyextra_r = user_defined;
#line 1941
  return;
}
}
#line 1947 "svf_flex.c"
void svfset_lineno(int line_number , yyscan_t yyscanner ) 
{ 
  struct yyguts_t___0 *yyg ;
  YY_BUFFER_STATE tmp ;
  char *__cil_tmp5 ;

  {
#line 1949
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 1952
  if (yyg->yy_buffer_stack) {
#line 1952
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 1952
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1952
  if (! tmp) {
    {
#line 1953
    yy_fatal_error___1("svfset_lineno called with no buffer", yyscanner);
    }
  }
#line 1955
  (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_bs_lineno = line_number;
#line 1956
  return;
}
}
#line 1962 "svf_flex.c"
void svfset_column(int column_no , yyscan_t yyscanner ) 
{ 
  struct yyguts_t___0 *yyg ;
  YY_BUFFER_STATE tmp ;
  char *__cil_tmp5 ;

  {
#line 1964
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 1967
  if (yyg->yy_buffer_stack) {
#line 1967
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 1967
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1967
  if (! tmp) {
    {
#line 1968
    yy_fatal_error___1("svfset_column called with no buffer", yyscanner);
    }
  }
#line 1970
  (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_bs_column = column_no;
#line 1971
  return;
}
}
#line 1979 "svf_flex.c"
void svfset_in(FILE *in_str , yyscan_t yyscanner ) 
{ 
  struct yyguts_t___0 *yyg ;

  {
#line 1981
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 1982
  yyg->yyin_r = in_str;
#line 1983
  return;
}
}
#line 1985 "svf_flex.c"
void svfset_out(FILE *out_str , yyscan_t yyscanner ) 
{ 
  struct yyguts_t___0 *yyg ;

  {
#line 1987
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 1988
  yyg->yyout_r = out_str;
#line 1989
  return;
}
}
#line 1991 "svf_flex.c"
int svfget_debug(yyscan_t yyscanner ) 
{ 
  struct yyguts_t___0 *yyg ;

  {
#line 1993
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 1994
  return (yyg->yy_flex_debug_r);
}
}
#line 1997 "svf_flex.c"
void svfset_debug(int bdebug , yyscan_t yyscanner ) 
{ 
  struct yyguts_t___0 *yyg ;

  {
#line 1999
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 2000
  yyg->yy_flex_debug_r = bdebug;
#line 2001
  return;
}
}
#line 2005 "svf_flex.c"
YYSTYPE___0 *svfget_lval(yyscan_t yyscanner ) 
{ 
  struct yyguts_t___0 *yyg ;

  {
#line 2007
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 2008
  return (yyg->yylval_r);
}
}
#line 2011 "svf_flex.c"
void svfset_lval(YYSTYPE___0 *yylval_param , yyscan_t yyscanner ) 
{ 
  struct yyguts_t___0 *yyg ;

  {
#line 2013
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 2014
  yyg->yylval_r = yylval_param;
#line 2015
  return;
}
}
#line 2017 "svf_flex.c"
YYLTYPE *svfget_lloc(yyscan_t yyscanner ) 
{ 
  struct yyguts_t___0 *yyg ;

  {
#line 2019
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 2020
  return (yyg->yylloc_r);
}
}
#line 2023 "svf_flex.c"
void svfset_lloc(YYLTYPE *yylloc_param , yyscan_t yyscanner ) 
{ 
  struct yyguts_t___0 *yyg ;

  {
#line 2025
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 2026
  yyg->yylloc_r = yylloc_param;
#line 2027
  return;
}
}
#line 2036 "svf_flex.c"
int svflex_init(yyscan_t *ptr_yy_globals ) 
{ 
  int *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
#line 2039
  if ((unsigned long )ptr_yy_globals == (unsigned long )((void *)0)) {
    {
#line 2040
    tmp = __errno_location();
#line 2040
    *tmp = 22;
    }
#line 2041
    return (1);
  }
  {
#line 2044
  tmp___0 = svfalloc((yy_size_t )sizeof(struct yyguts_t___0 ), (void *)0);
#line 2044
  *ptr_yy_globals = tmp___0;
  }
#line 2046
  if ((unsigned long )*ptr_yy_globals == (unsigned long )((void *)0)) {
    {
#line 2047
    tmp___1 = __errno_location();
#line 2047
    *tmp___1 = 12;
    }
#line 2048
    return (1);
  }
  {
#line 2052
  memset(*ptr_yy_globals, 0, (size_t )sizeof(struct yyguts_t___0 ));
#line 2054
  tmp___2 = yy_init_globals___1(*ptr_yy_globals);
  }
#line 2054
  return (tmp___2);
}
}
#line 2065 "svf_flex.c"
int svflex_init_extra(scanner_extra_t *yy_user_defined , yyscan_t *ptr_yy_globals ) 
{ 
  struct yyguts_t___0 dummy_yyguts ;
  int *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 2070
  svfset_extra(yy_user_defined, (yyscan_t )(& dummy_yyguts));
  }
#line 2072
  if ((unsigned long )ptr_yy_globals == (unsigned long )((void *)0)) {
    {
#line 2073
    tmp = __errno_location();
#line 2073
    *tmp = 22;
    }
#line 2074
    return (1);
  }
  {
#line 2077
  tmp___0 = svfalloc((yy_size_t )sizeof(struct yyguts_t___0 ), (yyscan_t )(& dummy_yyguts));
#line 2077
  *ptr_yy_globals = tmp___0;
  }
#line 2079
  if ((unsigned long )*ptr_yy_globals == (unsigned long )((void *)0)) {
    {
#line 2080
    tmp___1 = __errno_location();
#line 2080
    *tmp___1 = 12;
    }
#line 2081
    return (1);
  }
  {
#line 2086
  memset(*ptr_yy_globals, 0, (size_t )sizeof(struct yyguts_t___0 ));
#line 2088
  svfset_extra(yy_user_defined, *ptr_yy_globals);
#line 2090
  tmp___2 = yy_init_globals___1(*ptr_yy_globals);
  }
#line 2090
  return (tmp___2);
}
}
#line 2093 "svf_flex.c"
static int yy_init_globals___1(yyscan_t yyscanner ) 
{ 
  struct yyguts_t___0 *yyg ;

  {
#line 2095
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 2100
  yyg->yy_buffer_stack = (YY_BUFFER_STATE *)0;
#line 2101
  yyg->yy_buffer_stack_top = (size_t )0;
#line 2102
  yyg->yy_buffer_stack_max = (size_t )0;
#line 2103
  yyg->yy_c_buf_p = (char *)0;
#line 2104
  yyg->yy_init = 0;
#line 2105
  yyg->yy_start = 0;
#line 2107
  yyg->yy_start_stack_ptr = 0;
#line 2108
  yyg->yy_start_stack_depth = 0;
#line 2109
  yyg->yy_start_stack = (int *)((void *)0);
#line 2116
  yyg->yyin_r = (FILE *)0;
#line 2117
  yyg->yyout_r = (FILE *)0;
#line 2123
  return (0);
}
}
#line 2127 "svf_flex.c"
int svflex_destroy(yyscan_t yyscanner ) 
{ 
  struct yyguts_t___0 *yyg ;
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 2129
  yyg = (struct yyguts_t___0 *)yyscanner;
  {
#line 2132
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2132
    if (yyg->yy_buffer_stack) {
#line 2132
      tmp___0 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
    } else {
#line 2132
      tmp___0 = (YY_BUFFER_STATE )((void *)0);
    }
#line 2132
    if (! tmp___0) {
#line 2132
      goto while_break;
    }
#line 2133
    if (yyg->yy_buffer_stack) {
#line 2133
      tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
    } else {
#line 2133
      tmp = (YY_BUFFER_STATE )((void *)0);
    }
    {
#line 2133
    svf_delete_buffer(tmp, yyscanner);
#line 2134
    *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top) = (YY_BUFFER_STATE )((void *)0);
#line 2135
    svfpop_buffer_state(yyscanner);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2139
  svffree((void *)yyg->yy_buffer_stack, yyscanner);
#line 2140
  yyg->yy_buffer_stack = (YY_BUFFER_STATE *)((void *)0);
#line 2143
  svffree((void *)yyg->yy_start_stack, yyscanner);
#line 2144
  yyg->yy_start_stack = (int *)((void *)0);
#line 2148
  yy_init_globals___1(yyscanner);
#line 2151
  svffree(yyscanner, yyscanner);
#line 2152
  yyscanner = (void *)0;
  }
#line 2153
  return (0);
}
}
#line 2180 "svf_flex.c"
void *svfalloc(yy_size_t size , yyscan_t yyscanner ) 
{ 
  void *tmp ;

  {
  {
#line 2182
  tmp = malloc(size);
  }
#line 2182
  return (tmp);
}
}
#line 2185 "svf_flex.c"
void *svfrealloc(void *ptr , yy_size_t size , yyscan_t yyscanner ) 
{ 
  void *tmp ;

  {
  {
#line 2194
  tmp = realloc((void *)((char *)ptr), size);
  }
#line 2194
  return (tmp);
}
}
#line 2197 "svf_flex.c"
void svffree(void *ptr , yyscan_t yyscanner ) 
{ 


  {
  {
#line 2199
  free((void *)((char *)ptr));
  }
#line 2200
  return;
}
}
#line 216 "svf_flex.l"
static struct rwtable rwtable[53]  = 
#line 216 "svf_flex.l"
  {      {(char *)"ABSENT", 278}, 
        {(char *)"D", 293}, 
        {(char *)"DRCAPTURE", 314}, 
        {(char *)"DREXIT1", 312}, 
        {(char *)"DREXIT2", 313}, 
        {(char *)"DRPAUSE", 308}, 
        {(char *)"DRSELECT", 311}, 
        {(char *)"DRSHIFT", 309}, 
        {(char *)"DRUPDATE", 310}, 
        {(char *)"EMPTY", 262}, 
        {(char *)"ENDDR", 263}, 
        {(char *)"ENDIR", 264}, 
        {(char *)"ENDSTATE", 300}, 
        {(char *)"FREQUENCY", 265}, 
        {(char *)"H", 290}, 
        {(char *)"HDR", 279}, 
        {(char *)"HIR", 280}, 
        {(char *)"HZ", 266}, 
        {(char *)"IDLE", 269}, 
        {(char *)"IN", 287}, 
        {(char *)"INOUT", 289}, 
        {(char *)"IRCAPTURE", 307}, 
        {(char *)"IREXIT1", 305}, 
        {(char *)"IREXIT2", 306}, 
        {(char *)"IRPAUSE", 301}, 
        {(char *)"IRSELECT", 304}, 
        {(char *)"IRSHIFT", 302}, 
        {(char *)"IRUPDATE", 303}, 
        {(char *)"L", 291}, 
        {(char *)"MASK", 272}, 
        {(char *)"MAXIMUM", 296}, 
        {(char *)"OFF", 276}, 
        {(char *)"ON", 275}, 
        {(char *)"OUT", 288}, 
        {(char *)"PIO", 285}, 
        {(char *)"PIOMAP", 286}, 
        {(char *)"RESET", 268}, 
        {(char *)"RUNTEST", 295}, 
        {(char *)"SCK", 299}, 
        {(char *)"SDR", 281}, 
        {(char *)"SEC", 297}, 
        {(char *)"SIR", 282}, 
        {(char *)"SMASK", 273}, 
        {(char *)"STATE", 267}, 
        {(char *)"TCK", 298}, 
        {(char *)"TDI", 270}, 
        {(char *)"TDO", 271}, 
        {(char *)"TDR", 283}, 
        {(char *)"TIR", 284}, 
        {(char *)"TRST", 274}, 
        {(char *)"U", 292}, 
        {(char *)"X", 294}, 
        {(char *)"Z", 277}};
#line 278 "svf_flex.l"
static int map_keyw_ident(YYSTYPE___0 *mylval , char *str ) 
{ 
  int idx ;
  int rw ;
  int tmp ;

  {
#line 282
  rw = 258;
#line 284
  mylval->cvalue = str;
#line 286
  idx = 0;
  {
#line 286
  while (1) {
    while_continue: /* CIL Label */ ;
#line 286
    if (! ((unsigned long )idx <= sizeof(rwtable) / sizeof(rwtable[0]) - 1UL)) {
#line 286
      goto while_break;
    }
    {
#line 287
    tmp = strcasecmp((char const   *)rwtable[idx].rw_name, (char const   *)str);
    }
#line 287
    if (tmp == 0) {
#line 289
      rw = rwtable[idx].rw_yylex;
#line 290
      mylval->token = rw;
    }
#line 286
    idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 294
  return (rw);
}
}
#line 298 "svf_flex.l"
static void align_string(char *str ) 
{ 
  int src ;
  int dst ;
  int len ;
  size_t tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
  {
#line 303
  dst = 0;
#line 304
  tmp = strlen((char const   *)str);
#line 304
  len = (int )tmp;
#line 306
  src = 0;
  }
  {
#line 306
  while (1) {
    while_continue: /* CIL Label */ ;
#line 306
    if (! (src < len)) {
#line 306
      goto while_break;
    }
    {
#line 307
    tmp___1 = __ctype_b_loc();
    }
#line 307
    if ((int const   )*(*tmp___1 + (int )*(str + src)) & 4096) {
#line 308
      tmp___0 = dst;
#line 308
      dst ++;
#line 308
      *(str + tmp___0) = *(str + src);
    }
#line 306
    src ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 310
  *(str + dst) = (char )'\000';
#line 311
  return;
}
}
#line 314 "svf_flex.l"
static void fix_yylloc(YYLTYPE *mylloc , char *str ) 
{ 
  size_t tmp ;

  {
  {
#line 317
  mylloc->first_line = mylloc->last_line;
#line 318
  mylloc->first_column = mylloc->last_column;
#line 319
  tmp = strlen((char const   *)str);
#line 319
  mylloc->last_column = (int )((size_t )mylloc->last_column + tmp);
  }
#line 320
  return;
}
}
#line 323 "svf_flex.l"
static void fix_yylloc_nl(YYLTYPE *mylloc , char *str , scanner_extra_t *extra ) 
{ 
  char *p ;

  {
#line 328
  mylloc->first_line = mylloc->last_line;
#line 329
  mylloc->first_column = mylloc->last_column;
#line 330
  p = str;
  {
#line 330
  while (1) {
    while_continue: /* CIL Label */ ;
#line 330
    if (! *p) {
#line 330
      goto while_break;
    }
#line 331
    if ((int )*p == 10) {
      {
#line 332
      mylloc->last_column = 0;
#line 333
      (mylloc->last_line) ++;
#line 334
      progress_nl(mylloc, extra);
      }
    } else {
#line 336
      (mylloc->last_column) ++;
    }
#line 330
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 339
  return;
}
}
#line 342 "svf_flex.l"
static void progress_nl(YYLTYPE *mylloc , scanner_extra_t *extra ) 
{ 
  int percent ;
  char *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 347
  if (extra->print_progress) {
#line 347
    if (mylloc->last_line % 10 == 0) {
#line 348
      percent = (mylloc->last_line * 100 + 1) / extra->num_lines;
#line 349
      if (percent <= 1) {
#line 349
        return;
      }
      {
#line 350
      printf((char const   */* __restrict  */)"\r");
#line 351
      tmp = gettext("Parsing %6d/%d (%3.0d%%)");
#line 351
      printf((char const   */* __restrict  */)tmp, mylloc->last_line, extra->num_lines,
             percent);
      }
    }
  }
#line 354
  return;
}
}
#line 357 "svf_flex.l"
void *svf_flex_init(FILE *f , int num_lines , int print_progress ) 
{ 
  scanner_extra_t *extra ;
  yyscan_t scanner ;
  int tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  struct lconv *lc ;
  struct lconv *tmp___2 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 363
  tmp = svflex_init(& scanner);
  }
#line 363
  if (tmp != 0) {
#line 364
    return ((void *)0);
  }
  {
#line 366
  svfset_in(f, scanner);
#line 368
  tmp___1 = malloc((size_t )sizeof(scanner_extra_t ));
#line 368
  extra = (scanner_extra_t *)tmp___1;
  }
#line 368
  if (! extra) {
    {
#line 369
    tmp___0 = gettext("Out of memory, %s line %i\n");
#line 369
    printf((char const   */* __restrict  */)tmp___0, "svf_flex.l", 369);
#line 370
    svflex_destroy(scanner);
    }
#line 371
    return ((void *)0);
  }
  {
#line 374
  extra->num_lines = num_lines;
#line 375
  extra->print_progress = print_progress;
#line 379
  tmp___2 = localeconv();
#line 379
  lc = tmp___2;
#line 380
  extra->decimal_point = *(lc->decimal_point + 0);
#line 386
  svfset_extra(extra, scanner);
  }
#line 388
  return (scanner);
}
}
#line 392 "svf_flex.l"
void svf_flex_deinit(void *scanner ) 
{ 
  scanner_extra_t *extra ;
  scanner_extra_t *tmp ;
  char *__cil_tmp4 ;

  {
  {
#line 394
  tmp = svfget_extra(scanner);
#line 394
  extra = tmp;
  }
#line 395
  if (extra->print_progress) {
    {
#line 396
    printf((char const   */* __restrict  */)"\n");
    }
  }
  {
#line 397
  free((void *)extra);
#line 398
  svflex_destroy(scanner);
  }
#line 399
  return;
}
}
#line 120 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/svf/svf.h"
int svf_bison_init(parser_priv_t *priv_data , FILE *f , int num_lines , int print_progress ) ;
#line 121
void svf_bison_deinit(parser_priv_t *priv_data ) ;
#line 123
void svf_endxr(parser_priv_t *priv , enum generic_irdr_coding ir_dr , int state ) ;
#line 124
void svf_frequency(chain_t *chain , double freq ) ;
#line 125
int svf_hxr(enum generic_irdr_coding ir_dr , struct ths_params *params ) ;
#line 126
int svf_runtest(chain_t *chain , parser_priv_t *priv , struct runtest *params ) ;
#line 127
int svf_state(chain_t *chain , parser_priv_t *priv , struct path_states *path_states ,
              int stable_state ) ;
#line 128
int svf_sxr(chain_t *chain , parser_priv_t *priv , enum generic_irdr_coding ir_dr ,
            struct ths_params *params , struct YYLTYPE *loc ) ;
#line 129
int svf_trst(chain_t *chain , parser_priv_t *priv , int trst_mode ) ;
#line 130
int svf_txr(enum generic_irdr_coding ir_dr , struct ths_params *params ) ;
#line 47 "svf_bison.y"
void svferror(YYLTYPE *locp , parser_priv_t *priv_data , chain_t *chain , char const   *error_string ) ;
#line 49
static void svf_free_ths_params(struct ths_params *params ) ;
#line 528 "svf_bison.c"
static yytype_uint8 const   yytranslate___1[315]  = 
#line 528 "svf_bison.c"
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )61,      (yytype_uint8 const   )62,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )60, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )11,      (yytype_uint8 const   )12, 
        (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )22,      (yytype_uint8 const   )23,      (yytype_uint8 const   )24, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )26,      (yytype_uint8 const   )27,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )30,      (yytype_uint8 const   )31,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )33,      (yytype_uint8 const   )34,      (yytype_uint8 const   )35,      (yytype_uint8 const   )36, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )38,      (yytype_uint8 const   )39,      (yytype_uint8 const   )40, 
        (yytype_uint8 const   )41,      (yytype_uint8 const   )42,      (yytype_uint8 const   )43,      (yytype_uint8 const   )44, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )46,      (yytype_uint8 const   )47,      (yytype_uint8 const   )48, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )50,      (yytype_uint8 const   )51,      (yytype_uint8 const   )52, 
        (yytype_uint8 const   )53,      (yytype_uint8 const   )54,      (yytype_uint8 const   )55,      (yytype_uint8 const   )56, 
        (yytype_uint8 const   )57,      (yytype_uint8 const   )58,      (yytype_uint8 const   )59};
#line 619 "svf_bison.c"
static char const   * const  yytname[81]  = 
#line 619
  {      (char const   */* const  */)"SVF_EOF",      (char const   */* const  */)"error",      (char const   */* const  */)"$undefined",      (char const   */* const  */)"IDENTIFIER", 
        (char const   */* const  */)"NUMBER",      (char const   */* const  */)"HEXA_NUM",      (char const   */* const  */)"VECTOR_STRING",      (char const   */* const  */)"EMPTY", 
        (char const   */* const  */)"ENDDR",      (char const   */* const  */)"ENDIR",      (char const   */* const  */)"FREQUENCY",      (char const   */* const  */)"HZ", 
        (char const   */* const  */)"STATE",      (char const   */* const  */)"RESET",      (char const   */* const  */)"IDLE",      (char const   */* const  */)"TDI", 
        (char const   */* const  */)"TDO",      (char const   */* const  */)"MASK",      (char const   */* const  */)"SMASK",      (char const   */* const  */)"TRST", 
        (char const   */* const  */)"ON",      (char const   */* const  */)"OFF",      (char const   */* const  */)"Z",      (char const   */* const  */)"ABSENT", 
        (char const   */* const  */)"HDR",      (char const   */* const  */)"HIR",      (char const   */* const  */)"SDR",      (char const   */* const  */)"SIR", 
        (char const   */* const  */)"TDR",      (char const   */* const  */)"TIR",      (char const   */* const  */)"PIO",      (char const   */* const  */)"PIOMAP", 
        (char const   */* const  */)"IN",      (char const   */* const  */)"OUT",      (char const   */* const  */)"INOUT",      (char const   */* const  */)"H", 
        (char const   */* const  */)"L",      (char const   */* const  */)"U",      (char const   */* const  */)"D",      (char const   */* const  */)"X", 
        (char const   */* const  */)"RUNTEST",      (char const   */* const  */)"MAXIMUM",      (char const   */* const  */)"SEC",      (char const   */* const  */)"TCK", 
        (char const   */* const  */)"SCK",      (char const   */* const  */)"ENDSTATE",      (char const   */* const  */)"IRPAUSE",      (char const   */* const  */)"IRSHIFT", 
        (char const   */* const  */)"IRUPDATE",      (char const   */* const  */)"IRSELECT",      (char const   */* const  */)"IREXIT1",      (char const   */* const  */)"IREXIT2", 
        (char const   */* const  */)"IRCAPTURE",      (char const   */* const  */)"DRPAUSE",      (char const   */* const  */)"DRSHIFT",      (char const   */* const  */)"DRUPDATE", 
        (char const   */* const  */)"DRSELECT",      (char const   */* const  */)"DREXIT1",      (char const   */* const  */)"DREXIT2",      (char const   */* const  */)"DRCAPTURE", 
        (char const   */* const  */)"\';\'",      (char const   */* const  */)"\'(\'",      (char const   */* const  */)"\')\'",      (char const   */* const  */)"$accept", 
        (char const   */* const  */)"line",      (char const   */* const  */)"svf_statement",      (char const   */* const  */)"ths_param_list",      (char const   */* const  */)"ths_opt_param", 
        (char const   */* const  */)"stable_state",      (char const   */* const  */)"runtest_run_state_opt",      (char const   */* const  */)"runtest_clk_count",      (char const   */* const  */)"runtest_time_opt", 
        (char const   */* const  */)"runtest_time",      (char const   */* const  */)"runtest_max_time_opt",      (char const   */* const  */)"runtest_end_state_opt",      (char const   */* const  */)"all_states", 
        (char const   */* const  */)"path_states",      (char const   */* const  */)"piomap_rec",      (char const   */* const  */)"trst_mode",      (char const   */* const  */)"direction", 
        (char const   */* const  */)0};
#line 653 "svf_bison.c"
static yytype_uint8 const   yyr1___1[69]  = 
#line 653
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )63,      (yytype_uint8 const   )64,      (yytype_uint8 const   )64, 
        (yytype_uint8 const   )64,      (yytype_uint8 const   )65,      (yytype_uint8 const   )65,      (yytype_uint8 const   )65, 
        (yytype_uint8 const   )65,      (yytype_uint8 const   )65,      (yytype_uint8 const   )65,      (yytype_uint8 const   )65, 
        (yytype_uint8 const   )65,      (yytype_uint8 const   )65,      (yytype_uint8 const   )65,      (yytype_uint8 const   )65, 
        (yytype_uint8 const   )65,      (yytype_uint8 const   )65,      (yytype_uint8 const   )65,      (yytype_uint8 const   )65, 
        (yytype_uint8 const   )65,      (yytype_uint8 const   )66,      (yytype_uint8 const   )66,      (yytype_uint8 const   )67, 
        (yytype_uint8 const   )67,      (yytype_uint8 const   )67,      (yytype_uint8 const   )67,      (yytype_uint8 const   )68, 
        (yytype_uint8 const   )68,      (yytype_uint8 const   )68,      (yytype_uint8 const   )68,      (yytype_uint8 const   )69, 
        (yytype_uint8 const   )69,      (yytype_uint8 const   )70,      (yytype_uint8 const   )70,      (yytype_uint8 const   )71, 
        (yytype_uint8 const   )71,      (yytype_uint8 const   )72,      (yytype_uint8 const   )73,      (yytype_uint8 const   )73, 
        (yytype_uint8 const   )74,      (yytype_uint8 const   )74,      (yytype_uint8 const   )75,      (yytype_uint8 const   )75, 
        (yytype_uint8 const   )75,      (yytype_uint8 const   )75,      (yytype_uint8 const   )75,      (yytype_uint8 const   )75, 
        (yytype_uint8 const   )75,      (yytype_uint8 const   )75,      (yytype_uint8 const   )75,      (yytype_uint8 const   )75, 
        (yytype_uint8 const   )75,      (yytype_uint8 const   )75,      (yytype_uint8 const   )75,      (yytype_uint8 const   )75, 
        (yytype_uint8 const   )75,      (yytype_uint8 const   )75,      (yytype_uint8 const   )76,      (yytype_uint8 const   )76, 
        (yytype_uint8 const   )77,      (yytype_uint8 const   )77,      (yytype_uint8 const   )78,      (yytype_uint8 const   )78, 
        (yytype_uint8 const   )78,      (yytype_uint8 const   )78,      (yytype_uint8 const   )79,      (yytype_uint8 const   )79, 
        (yytype_uint8 const   )79};
#line 665 "svf_bison.c"
static yytype_uint8 const   yyr2___1[69]  = 
#line 665
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )4,      (yytype_uint8 const   )4,      (yytype_uint8 const   )7, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )6,      (yytype_uint8 const   )5,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )4,      (yytype_uint8 const   )4,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )0,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1};
#line 679 "svf_bison.c"
static yytype_uint8 const   yydefact___1[119]  = 
#line 679
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )58,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )31,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )27,      (yytype_uint8 const   )28,      (yytype_uint8 const   )30,      (yytype_uint8 const   )29, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )7, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )62,      (yytype_uint8 const   )63,      (yytype_uint8 const   )64, 
        (yytype_uint8 const   )65,      (yytype_uint8 const   )0,      (yytype_uint8 const   )21,      (yytype_uint8 const   )21, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )21,      (yytype_uint8 const   )21,      (yytype_uint8 const   )21, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )32,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )5,      (yytype_uint8 const   )0,      (yytype_uint8 const   )56, 
        (yytype_uint8 const   )57,      (yytype_uint8 const   )54,      (yytype_uint8 const   )50,      (yytype_uint8 const   )53, 
        (yytype_uint8 const   )48,      (yytype_uint8 const   )51,      (yytype_uint8 const   )52,      (yytype_uint8 const   )49, 
        (yytype_uint8 const   )55,      (yytype_uint8 const   )44,      (yytype_uint8 const   )47,      (yytype_uint8 const   )42, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )46,      (yytype_uint8 const   )43,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )59,      (yytype_uint8 const   )20,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )12,      (yytype_uint8 const   )66,      (yytype_uint8 const   )67,      (yytype_uint8 const   )68, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )35,      (yytype_uint8 const   )40, 
        (yytype_uint8 const   )8,      (yytype_uint8 const   )17,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )9,      (yytype_uint8 const   )22, 
        (yytype_uint8 const   )10,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16,      (yytype_uint8 const   )18, 
        (yytype_uint8 const   )19,      (yytype_uint8 const   )60,      (yytype_uint8 const   )38,      (yytype_uint8 const   )33, 
        (yytype_uint8 const   )34,      (yytype_uint8 const   )0,      (yytype_uint8 const   )40,      (yytype_uint8 const   )36, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )23,      (yytype_uint8 const   )24, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )26,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )0,      (yytype_uint8 const   )41,      (yytype_uint8 const   )14, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )13, 
        (yytype_uint8 const   )11,      (yytype_uint8 const   )61,      (yytype_uint8 const   )39};
#line 696 "svf_bison.c"
static yytype_int8 const   yydefgoto___1[17]  = 
#line 696
  {      (yytype_int8 const   )-1,      (yytype_int8 const   )2,      (yytype_int8 const   )19,      (yytype_int8 const   )66, 
        (yytype_int8 const   )87,      (yytype_int8 const   )24,      (yytype_int8 const   )43,      (yytype_int8 const   )78, 
        (yytype_int8 const   )98,      (yytype_int8 const   )79,      (yytype_int8 const   )108,      (yytype_int8 const   )101, 
        (yytype_int8 const   )64,      (yytype_int8 const   )28,      (yytype_int8 const   )106,      (yytype_int8 const   )33, 
        (yytype_int8 const   )76};
#line 705 "svf_bison.c"
static yytype_int16 const   yypact___1[119]  = 
#line 705
  {      (yytype_int16 const   )55,      (yytype_int16 const   )4,      (yytype_int16 const   )88,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )46,      (yytype_int16 const   )46,      (yytype_int16 const   )-3, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )31,      (yytype_int16 const   )17,      (yytype_int16 const   )45, 
        (yytype_int16 const   )57,      (yytype_int16 const   )62,      (yytype_int16 const   )71,      (yytype_int16 const   )73, 
        (yytype_int16 const   )67,      (yytype_int16 const   )26,      (yytype_int16 const   )46,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )18,      (yytype_int16 const   )29,      (yytype_int16 const   )79,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )-11,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )33,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )44,      (yytype_int16 const   )-23,      (yytype_int16 const   )-24,      (yytype_int16 const   )87, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )48,      (yytype_int16 const   )49, 
        (yytype_int16 const   )50,      (yytype_int16 const   )51,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )65,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )66, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )-10,      (yytype_int16 const   )-2, 
        (yytype_int16 const   )2,      (yytype_int16 const   )8,      (yytype_int16 const   )12,      (yytype_int16 const   )16, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )102,      (yytype_int16 const   )27,      (yytype_int16 const   )123,      (yytype_int16 const   )61, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )124,      (yytype_int16 const   )125, 
        (yytype_int16 const   )127,      (yytype_int16 const   )128,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )93,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )94,      (yytype_int16 const   )61,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )46,      (yytype_int16 const   )75,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )69,      (yytype_int16 const   )133, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )78,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )80,      (yytype_int16 const   )136,      (yytype_int16 const   )99,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24};
#line 722 "svf_bison.c"
static yytype_int8 const   yypgoto___1[17]  = 
#line 722
  {      (yytype_int8 const   )-24,      (yytype_int8 const   )-24,      (yytype_int8 const   )-24,      (yytype_int8 const   )85, 
        (yytype_int8 const   )-24,      (yytype_int8 const   )-6,      (yytype_int8 const   )-24,      (yytype_int8 const   )-24, 
        (yytype_int8 const   )-24,      (yytype_int8 const   )64,      (yytype_int8 const   )-24,      (yytype_int8 const   )47, 
        (yytype_int8 const   )-24,      (yytype_int8 const   )-24,      (yytype_int8 const   )-24,      (yytype_int8 const   )-24, 
        (yytype_int8 const   )37};
#line 733 "svf_bison.c"
static yytype_int8 const   yytable___1[146]  = 
#line 733
  {      (yytype_int8 const   )25,      (yytype_int8 const   )26,      (yytype_int8 const   )47,      (yytype_int8 const   )48, 
        (yytype_int8 const   )3,      (yytype_int8 const   )82,      (yytype_int8 const   )83,      (yytype_int8 const   )84, 
        (yytype_int8 const   )85,      (yytype_int8 const   )73,      (yytype_int8 const   )74,      (yytype_int8 const   )75, 
        (yytype_int8 const   )42,      (yytype_int8 const   )82,      (yytype_int8 const   )83,      (yytype_int8 const   )84, 
        (yytype_int8 const   )85,      (yytype_int8 const   )82,      (yytype_int8 const   )83,      (yytype_int8 const   )84, 
        (yytype_int8 const   )85,      (yytype_int8 const   )34,      (yytype_int8 const   )63,      (yytype_int8 const   )82, 
        (yytype_int8 const   )83,      (yytype_int8 const   )84,      (yytype_int8 const   )85,      (yytype_int8 const   )82, 
        (yytype_int8 const   )83,      (yytype_int8 const   )84,      (yytype_int8 const   )85,      (yytype_int8 const   )82, 
        (yytype_int8 const   )83,      (yytype_int8 const   )84,      (yytype_int8 const   )85,      (yytype_int8 const   )49, 
        (yytype_int8 const   )50,      (yytype_int8 const   )51,      (yytype_int8 const   )52,      (yytype_int8 const   )53, 
        (yytype_int8 const   )54,      (yytype_int8 const   )55,      (yytype_int8 const   )56,      (yytype_int8 const   )57, 
        (yytype_int8 const   )58,      (yytype_int8 const   )59,      (yytype_int8 const   )60,      (yytype_int8 const   )61, 
        (yytype_int8 const   )62,      (yytype_int8 const   )35,      (yytype_int8 const   )86,      (yytype_int8 const   )29, 
        (yytype_int8 const   )30,      (yytype_int8 const   )31,      (yytype_int8 const   )32,      (yytype_int8 const   )-2, 
        (yytype_int8 const   )1,      (yytype_int8 const   )27,      (yytype_int8 const   )88,      (yytype_int8 const   )20, 
        (yytype_int8 const   )21,      (yytype_int8 const   )36,      (yytype_int8 const   )89,      (yytype_int8 const   )-2, 
        (yytype_int8 const   )-2,      (yytype_int8 const   )-2,      (yytype_int8 const   )37,      (yytype_int8 const   )-2, 
        (yytype_int8 const   )90,      (yytype_int8 const   )94,      (yytype_int8 const   )95,      (yytype_int8 const   )96, 
        (yytype_int8 const   )91,      (yytype_int8 const   )40,      (yytype_int8 const   )-2,      (yytype_int8 const   )38, 
        (yytype_int8 const   )92,      (yytype_int8 const   )39,      (yytype_int8 const   )44,      (yytype_int8 const   )-2, 
        (yytype_int8 const   )-2,      (yytype_int8 const   )-2,      (yytype_int8 const   )-2,      (yytype_int8 const   )-2, 
        (yytype_int8 const   )-2,      (yytype_int8 const   )-2,      (yytype_int8 const   )-2,      (yytype_int8 const   )41, 
        (yytype_int8 const   )4,      (yytype_int8 const   )45,      (yytype_int8 const   )46,      (yytype_int8 const   )77, 
        (yytype_int8 const   )22,      (yytype_int8 const   )65,      (yytype_int8 const   )110,      (yytype_int8 const   )-2, 
        (yytype_int8 const   )5,      (yytype_int8 const   )6,      (yytype_int8 const   )7,      (yytype_int8 const   )23, 
        (yytype_int8 const   )8,      (yytype_int8 const   )73,      (yytype_int8 const   )74,      (yytype_int8 const   )75, 
        (yytype_int8 const   )72,      (yytype_int8 const   )93,      (yytype_int8 const   )100,      (yytype_int8 const   )9, 
        (yytype_int8 const   )80,      (yytype_int8 const   )-27,      (yytype_int8 const   )-28,      (yytype_int8 const   )-30, 
        (yytype_int8 const   )10,      (yytype_int8 const   )11,      (yytype_int8 const   )12,      (yytype_int8 const   )13, 
        (yytype_int8 const   )14,      (yytype_int8 const   )15,      (yytype_int8 const   )16,      (yytype_int8 const   )17, 
        (yytype_int8 const   )67,      (yytype_int8 const   )68,      (yytype_int8 const   )69,      (yytype_int8 const   )70, 
        (yytype_int8 const   )71,      (yytype_int8 const   )-29,      (yytype_int8 const   )81,      (yytype_int8 const   )97, 
        (yytype_int8 const   )18,      (yytype_int8 const   )102,      (yytype_int8 const   )103,      (yytype_int8 const   )112, 
        (yytype_int8 const   )104,      (yytype_int8 const   )105,      (yytype_int8 const   )107,      (yytype_int8 const   )111, 
        (yytype_int8 const   )94,      (yytype_int8 const   )114,      (yytype_int8 const   )115,      (yytype_int8 const   )117, 
        (yytype_int8 const   )116,      (yytype_int8 const   )118,      (yytype_int8 const   )99,      (yytype_int8 const   )113, 
        (yytype_int8 const   )0,      (yytype_int8 const   )109};
#line 752 "svf_bison.c"
static yytype_int8 const   yycheck___1[146]  = 
#line 752
  {      (yytype_int8 const   )6,      (yytype_int8 const   )4,      (yytype_int8 const   )13,      (yytype_int8 const   )14, 
        (yytype_int8 const   )0,      (yytype_int8 const   )15,      (yytype_int8 const   )16,      (yytype_int8 const   )17, 
        (yytype_int8 const   )18,      (yytype_int8 const   )32,      (yytype_int8 const   )33,      (yytype_int8 const   )34, 
        (yytype_int8 const   )18,      (yytype_int8 const   )15,      (yytype_int8 const   )16,      (yytype_int8 const   )17, 
        (yytype_int8 const   )18,      (yytype_int8 const   )15,      (yytype_int8 const   )16,      (yytype_int8 const   )17, 
        (yytype_int8 const   )18,      (yytype_int8 const   )4,      (yytype_int8 const   )28,      (yytype_int8 const   )15, 
        (yytype_int8 const   )16,      (yytype_int8 const   )17,      (yytype_int8 const   )18,      (yytype_int8 const   )15, 
        (yytype_int8 const   )16,      (yytype_int8 const   )17,      (yytype_int8 const   )18,      (yytype_int8 const   )15, 
        (yytype_int8 const   )16,      (yytype_int8 const   )17,      (yytype_int8 const   )18,      (yytype_int8 const   )46, 
        (yytype_int8 const   )47,      (yytype_int8 const   )48,      (yytype_int8 const   )49,      (yytype_int8 const   )50, 
        (yytype_int8 const   )51,      (yytype_int8 const   )52,      (yytype_int8 const   )53,      (yytype_int8 const   )54, 
        (yytype_int8 const   )55,      (yytype_int8 const   )56,      (yytype_int8 const   )57,      (yytype_int8 const   )58, 
        (yytype_int8 const   )59,      (yytype_int8 const   )4,      (yytype_int8 const   )60,      (yytype_int8 const   )20, 
        (yytype_int8 const   )21,      (yytype_int8 const   )22,      (yytype_int8 const   )23,      (yytype_int8 const   )0, 
        (yytype_int8 const   )1,      (yytype_int8 const   )60,      (yytype_int8 const   )60,      (yytype_int8 const   )13, 
        (yytype_int8 const   )14,      (yytype_int8 const   )4,      (yytype_int8 const   )60,      (yytype_int8 const   )8, 
        (yytype_int8 const   )9,      (yytype_int8 const   )10,      (yytype_int8 const   )4,      (yytype_int8 const   )12, 
        (yytype_int8 const   )60,      (yytype_int8 const   )42,      (yytype_int8 const   )43,      (yytype_int8 const   )44, 
        (yytype_int8 const   )60,      (yytype_int8 const   )6,      (yytype_int8 const   )19,      (yytype_int8 const   )4, 
        (yytype_int8 const   )60,      (yytype_int8 const   )4,      (yytype_int8 const   )60,      (yytype_int8 const   )24, 
        (yytype_int8 const   )25,      (yytype_int8 const   )26,      (yytype_int8 const   )27,      (yytype_int8 const   )28, 
        (yytype_int8 const   )29,      (yytype_int8 const   )30,      (yytype_int8 const   )31,      (yytype_int8 const   )61, 
        (yytype_int8 const   )0,      (yytype_int8 const   )60,      (yytype_int8 const   )11,      (yytype_int8 const   )4, 
        (yytype_int8 const   )46,      (yytype_int8 const   )60,      (yytype_int8 const   )100,      (yytype_int8 const   )40, 
        (yytype_int8 const   )8,      (yytype_int8 const   )9,      (yytype_int8 const   )10,      (yytype_int8 const   )53, 
        (yytype_int8 const   )12,      (yytype_int8 const   )32,      (yytype_int8 const   )33,      (yytype_int8 const   )34, 
        (yytype_int8 const   )60,      (yytype_int8 const   )3,      (yytype_int8 const   )45,      (yytype_int8 const   )19, 
        (yytype_int8 const   )60,      (yytype_int8 const   )60,      (yytype_int8 const   )60,      (yytype_int8 const   )60, 
        (yytype_int8 const   )24,      (yytype_int8 const   )25,      (yytype_int8 const   )26,      (yytype_int8 const   )27, 
        (yytype_int8 const   )28,      (yytype_int8 const   )29,      (yytype_int8 const   )30,      (yytype_int8 const   )31, 
        (yytype_int8 const   )35,      (yytype_int8 const   )36,      (yytype_int8 const   )37,      (yytype_int8 const   )38, 
        (yytype_int8 const   )39,      (yytype_int8 const   )60,      (yytype_int8 const   )60,      (yytype_int8 const   )4, 
        (yytype_int8 const   )40,      (yytype_int8 const   )5,      (yytype_int8 const   )5,      (yytype_int8 const   )62, 
        (yytype_int8 const   )5,      (yytype_int8 const   )5,      (yytype_int8 const   )41,      (yytype_int8 const   )60, 
        (yytype_int8 const   )42,      (yytype_int8 const   )4,      (yytype_int8 const   )60,      (yytype_int8 const   )3, 
        (yytype_int8 const   )60,      (yytype_int8 const   )42,      (yytype_int8 const   )78,      (yytype_int8 const   )106, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )98};
#line 773 "svf_bison.c"
static yytype_uint8 const   yystos___1[119]  = 
#line 773
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )1,      (yytype_uint8 const   )64,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )8,      (yytype_uint8 const   )9,      (yytype_uint8 const   )10, 
        (yytype_uint8 const   )12,      (yytype_uint8 const   )19,      (yytype_uint8 const   )24,      (yytype_uint8 const   )25, 
        (yytype_uint8 const   )26,      (yytype_uint8 const   )27,      (yytype_uint8 const   )28,      (yytype_uint8 const   )29, 
        (yytype_uint8 const   )30,      (yytype_uint8 const   )31,      (yytype_uint8 const   )40,      (yytype_uint8 const   )65, 
        (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )46,      (yytype_uint8 const   )53, 
        (yytype_uint8 const   )68,      (yytype_uint8 const   )68,      (yytype_uint8 const   )4,      (yytype_uint8 const   )60, 
        (yytype_uint8 const   )76,      (yytype_uint8 const   )20,      (yytype_uint8 const   )21,      (yytype_uint8 const   )22, 
        (yytype_uint8 const   )23,      (yytype_uint8 const   )78,      (yytype_uint8 const   )4,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )4,      (yytype_uint8 const   )4,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )61,      (yytype_uint8 const   )68,      (yytype_uint8 const   )69, 
        (yytype_uint8 const   )60,      (yytype_uint8 const   )60,      (yytype_uint8 const   )11,      (yytype_uint8 const   )13, 
        (yytype_uint8 const   )14,      (yytype_uint8 const   )46,      (yytype_uint8 const   )47,      (yytype_uint8 const   )48, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )50,      (yytype_uint8 const   )51,      (yytype_uint8 const   )52, 
        (yytype_uint8 const   )53,      (yytype_uint8 const   )54,      (yytype_uint8 const   )55,      (yytype_uint8 const   )56, 
        (yytype_uint8 const   )57,      (yytype_uint8 const   )58,      (yytype_uint8 const   )59,      (yytype_uint8 const   )68, 
        (yytype_uint8 const   )75,      (yytype_uint8 const   )60,      (yytype_uint8 const   )66,      (yytype_uint8 const   )66, 
        (yytype_uint8 const   )66,      (yytype_uint8 const   )66,      (yytype_uint8 const   )66,      (yytype_uint8 const   )66, 
        (yytype_uint8 const   )60,      (yytype_uint8 const   )32,      (yytype_uint8 const   )33,      (yytype_uint8 const   )34, 
        (yytype_uint8 const   )79,      (yytype_uint8 const   )4,      (yytype_uint8 const   )70,      (yytype_uint8 const   )72, 
        (yytype_uint8 const   )60,      (yytype_uint8 const   )60,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )60,      (yytype_uint8 const   )67, 
        (yytype_uint8 const   )60,      (yytype_uint8 const   )60,      (yytype_uint8 const   )60,      (yytype_uint8 const   )60, 
        (yytype_uint8 const   )60,      (yytype_uint8 const   )3,      (yytype_uint8 const   )42,      (yytype_uint8 const   )43, 
        (yytype_uint8 const   )44,      (yytype_uint8 const   )4,      (yytype_uint8 const   )71,      (yytype_uint8 const   )72, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )74,      (yytype_uint8 const   )5,      (yytype_uint8 const   )5, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )5,      (yytype_uint8 const   )77,      (yytype_uint8 const   )41, 
        (yytype_uint8 const   )73,      (yytype_uint8 const   )74,      (yytype_uint8 const   )68,      (yytype_uint8 const   )60, 
        (yytype_uint8 const   )62,      (yytype_uint8 const   )79,      (yytype_uint8 const   )4,      (yytype_uint8 const   )60, 
        (yytype_uint8 const   )60,      (yytype_uint8 const   )3,      (yytype_uint8 const   )42};
#line 1084 "svf_bison.c"
static unsigned int yystrlen(char const   *yystr ) 
{ 
  unsigned int yylen ;

  {
#line 1093
  yylen = 0U;
  {
#line 1093
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1093
    if (! *(yystr + yylen)) {
#line 1093
      goto while_break;
    }
#line 1094
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 1093
    yylen ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1095
  return (yylen);
}
}
#line 1108 "svf_bison.c"
static char *yystpcpy(char *yydest , char const   *yysrc ) 
{ 
  char *yyd ;
  char const   *yys ;
  char *tmp ;
  char tmp___0 ;
  char const   *tmp___1 ;

  {
#line 1117
  yyd = yydest;
#line 1118
  yys = yysrc;
  {
#line 1120
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1120
    tmp = yyd;
#line 1120
    yyd ++;
#line 1120
    tmp___1 = yys;
#line 1120
    yys ++;
#line 1120
    tmp___0 = (char )*tmp___1;
#line 1120
    *tmp = tmp___0;
#line 1120
    if (! ((int )tmp___0 != 0)) {
#line 1120
      goto while_break;
    }
#line 1121
    goto while_continue;
  }
  while_break: /* CIL Label */ ;
  }
#line 1123
  return (yyd - 1);
}
}
#line 1136 "svf_bison.c"
static unsigned int yytnamerr(char *yyres , char const   *yystr ) 
{ 
  unsigned int yyn ;
  char const   *yyp ;
  unsigned int tmp ;
  char *tmp___0 ;

  {
#line 1139
  if ((int const   )*yystr == 34) {
#line 1141
    yyn = 0U;
#line 1142
    yyp = yystr;
    {
#line 1144
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1145
      yyp ++;
      {
#line 1148
      if ((int const   )*yyp == 44) {
#line 1148
        goto case_44;
      }
#line 1148
      if ((int const   )*yyp == 39) {
#line 1148
        goto case_44;
      }
#line 1151
      if ((int const   )*yyp == 92) {
#line 1151
        goto case_92;
      }
#line 1161
      if ((int const   )*yyp == 34) {
#line 1161
        goto case_34;
      }
#line 1155
      goto switch_default;
      case_44: /* CIL Label */ 
      case_39: /* CIL Label */ 
#line 1149
      goto do_not_strip_quotes;
      case_92: /* CIL Label */ 
#line 1152
      yyp ++;
#line 1152
      if ((int const   )*yyp != 92) {
#line 1153
        goto do_not_strip_quotes;
      }
      switch_default: /* CIL Label */ 
#line 1156
      if (yyres) {
#line 1157
        *(yyres + yyn) = (char )*yyp;
      }
#line 1158
      yyn ++;
#line 1159
      goto switch_break;
      case_34: /* CIL Label */ 
#line 1162
      if (yyres) {
#line 1163
        *(yyres + yyn) = (char )'\000';
      }
#line 1164
      return (yyn);
      switch_break: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
    do_not_strip_quotes: ;
  }
#line 1169
  if (! yyres) {
    {
#line 1170
    tmp = yystrlen(yystr);
    }
#line 1170
    return (tmp);
  }
  {
#line 1172
  tmp___0 = yystpcpy(yyres, yystr);
  }
#line 1172
  return ((unsigned int )(tmp___0 - yyres));
}
}
#line 1212
static unsigned int yysyntax_error(char *yyresult , int yystate , int svfchar ) ;
#line 1212 "svf_bison.c"
static char const   yyunexpected[28]  = 
#line 1212
  {      (char const   )'s',      (char const   )'y',      (char const   )'n',      (char const   )'t', 
        (char const   )'a',      (char const   )'x',      (char const   )' ',      (char const   )'e', 
        (char const   )'r',      (char const   )'r',      (char const   )'o',      (char const   )'r', 
        (char const   )',',      (char const   )' ',      (char const   )'u',      (char const   )'n', 
        (char const   )'e',      (char const   )'x',      (char const   )'p',      (char const   )'e', 
        (char const   )'c',      (char const   )'t',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )'%',      (char const   )'s',      (char const   )'\000'};
#line 1213 "svf_bison.c"
static char const   yyexpecting[15]  = 
#line 1213
  {      (char const   )',',      (char const   )' ',      (char const   )'e',      (char const   )'x', 
        (char const   )'p',      (char const   )'e',      (char const   )'c',      (char const   )'t', 
        (char const   )'i',      (char const   )'n',      (char const   )'g',      (char const   )' ', 
        (char const   )'%',      (char const   )'s',      (char const   )'\000'};
#line 1214 "svf_bison.c"
static char const   yyor[7]  = {      (char const   )' ',      (char const   )'o',      (char const   )'r',      (char const   )' ', 
        (char const   )'%',      (char const   )'s',      (char const   )'\000'};
#line 1183 "svf_bison.c"
static unsigned int yysyntax_error(char *yyresult , int yystate , int svfchar ) 
{ 
  int yyn ;
  int yytype ;
  int tmp ;
  unsigned int yysize0 ;
  unsigned int tmp___0 ;
  unsigned int yysize ;
  unsigned int yysize1 ;
  int yysize_overflow ;
  char const   *yyarg[5] ;
  int yyx ;
  char *yyfmt ;
  char const   *yyf ;
  char yyformat[((sizeof(yyunexpected) + sizeof(yyexpecting)) - 1UL) + 3UL * (sizeof(yyor) - 1UL)] ;
  char const   *yyprefix ;
  int yyxbegin ;
  int tmp___1 ;
  int yychecklim ;
  int yyxend ;
  int tmp___2 ;
  int yycount ;
  int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  char *yyp ;
  int yyi ;
  int tmp___6 ;
  unsigned int tmp___7 ;
  char tmp___8 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;

  {
#line 1186
  yyn = (int )yypact___1[yystate];
#line 1188
  if (-24 < yyn) {
#line 1188
    if (yyn <= 145) {
#line 1192
      if ((unsigned int )svfchar <= 314U) {
#line 1192
        tmp = (int const   )yytranslate___1[svfchar];
      } else {
#line 1192
        tmp = (int const   )2;
      }
      {
#line 1192
      yytype = (int )tmp;
#line 1193
      tmp___0 = yytnamerr((char *)0, (char const   *)yytname[yytype]);
#line 1193
      yysize0 = tmp___0;
#line 1194
      yysize = yysize0;
#line 1196
      yysize_overflow = 0;
#line 1219
      yyprefix = yyexpecting;
      }
#line 1223
      if (yyn < 0) {
#line 1223
        tmp___1 = - yyn;
      } else {
#line 1223
        tmp___1 = 0;
      }
#line 1223
      yyxbegin = tmp___1;
#line 1226
      yychecklim = (145 - yyn) + 1;
#line 1227
      if (yychecklim < 63) {
#line 1227
        tmp___2 = yychecklim;
      } else {
#line 1227
        tmp___2 = 63;
      }
      {
#line 1227
      yyxend = tmp___2;
#line 1228
      yycount = 1;
#line 1230
      yyarg[0] = (char const   *)yytname[yytype];
#line 1231
      yyfmt = yystpcpy(yyformat, yyunexpected);
#line 1233
      yyx = yyxbegin;
      }
      {
#line 1233
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1233
        if (! (yyx < yyxend)) {
#line 1233
          goto while_break;
        }
#line 1234
        if ((int const   )yycheck___1[yyx + yyn] == (int const   )yyx) {
#line 1234
          if (yyx != 1) {
#line 1236
            if (yycount == 5) {
#line 1238
              yycount = 1;
#line 1239
              yysize = yysize0;
#line 1240
              yyformat[sizeof(yyunexpected) - 1UL] = (char )'\000';
#line 1241
              goto while_break;
            }
            {
#line 1243
            tmp___3 = yycount;
#line 1243
            yycount ++;
#line 1243
            yyarg[tmp___3] = (char const   *)yytname[yyx];
#line 1244
            tmp___4 = yytnamerr((char *)0, (char const   *)yytname[yyx]);
#line 1244
            yysize1 = yysize + tmp___4;
#line 1245
            yysize_overflow |= yysize1 < yysize;
#line 1246
            yysize = yysize1;
#line 1247
            yyfmt = yystpcpy(yyfmt, yyprefix);
#line 1248
            yyprefix = yyor;
            }
          }
        }
#line 1233
        yyx ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 1251
      yyf = (char const   *)(yyformat);
#line 1252
      tmp___5 = yystrlen(yyf);
#line 1252
      yysize1 = yysize + tmp___5;
#line 1253
      yysize_overflow |= yysize1 < yysize;
#line 1254
      yysize = yysize1;
      }
#line 1256
      if (yysize_overflow) {
#line 1257
        return (4294967295U);
      }
#line 1259
      if (yyresult) {
#line 1264
        yyp = yyresult;
#line 1265
        yyi = 0;
        {
#line 1266
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1266
          tmp___8 = (char )*yyf;
#line 1266
          *yyp = tmp___8;
#line 1266
          if (! ((int )tmp___8 != 0)) {
#line 1266
            goto while_break___0;
          }
#line 1268
          if ((int )*yyp == 37) {
#line 1268
            if ((int const   )*(yyf + 1) == 115) {
#line 1268
              if (yyi < yycount) {
                {
#line 1270
                tmp___6 = yyi;
#line 1270
                yyi ++;
#line 1270
                tmp___7 = yytnamerr(yyp, yyarg[tmp___6]);
#line 1270
                yyp += tmp___7;
#line 1271
                yyf += 2;
                }
              } else {
#line 1275
                yyp ++;
#line 1276
                yyf ++;
              }
            } else {
#line 1275
              yyp ++;
#line 1276
              yyf ++;
            }
          } else {
#line 1275
            yyp ++;
#line 1276
            yyf ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 1280
      return (yysize);
    } else {
#line 1189
      return (0U);
    }
  } else {
#line 1189
    return (0U);
  }
}
}
#line 1293 "svf_bison.c"
static void yydestruct___1(char const   *yymsg , int yytype , YYSTYPE___0 *yyvaluep ,
                           YYLTYPE *yylocationp , parser_priv_t *priv_data , chain_t *chain ) 
{ 
  char *__cil_tmp7 ;

  {
#line 1311
  if (! yymsg) {
#line 1312
    yymsg = "Deleting";
  }
  {
#line 1318
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 1319
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1321
  return;
}
}
#line 1332
int svfparse(parser_priv_t *priv_data , chain_t *chain ) ;
#line 1359 "svf_bison.c"
int svfparse(parser_priv_t *priv_data , chain_t *chain ) 
{ 
  int svfchar ;
  YYSTYPE___0 svflval ;
  YYLTYPE svflloc ;
  int svfnerrs ;
  int yystate ;
  int yyerrstatus ;
  yytype_int16 yyssa[200] ;
  yytype_int16 *yyss ;
  yytype_int16 *yyssp ;
  YYSTYPE___0 yyvsa[200] ;
  YYSTYPE___0 *yyvs ;
  YYSTYPE___0 *yyvsp ;
  YYLTYPE yylsa[200] ;
  YYLTYPE *yyls ;
  YYLTYPE *yylsp ;
  YYLTYPE yyerror_range[2] ;
  unsigned int yystacksize ;
  int yyn ;
  int yyresult ;
  int yytoken ;
  YYSTYPE___0 yyval ;
  YYLTYPE yyloc ;
  char yymsgbuf[128] ;
  char *yymsg ;
  unsigned int yymsg_alloc ;
  int yylen ;
  unsigned int yysize ;
  yytype_int16 *yyss1 ;
  union yyalloc___0 *yyptr ;
  void *tmp ;
  unsigned int yynewbytes ;
  unsigned int yynewbytes___0 ;
  unsigned int yynewbytes___1 ;
  struct ths_params *p ;
  struct ths_params *p___0 ;
  struct runtest *rt ;
  int tmp___0 ;
  struct runtest *rt___0 ;
  int tmp___1 ;
  struct ths_params *p___1 ;
  int result ;
  struct ths_params *p___2 ;
  int result___0 ;
  int tmp___2 ;
  struct ths_params *p___3 ;
  int result___1 ;
  struct ths_params *p___4 ;
  int result___2 ;
  int tmp___3 ;
  struct path_states *ps ;
  unsigned int yysize___0 ;
  unsigned int tmp___4 ;
  unsigned int yyalloc ;
  void *tmp___5 ;
  void *__cil_tmp57 ;
  void *__cil_tmp58 ;
  void *__cil_tmp59 ;
  void *__cil_tmp60 ;
  void *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;

  {
#line 1425
  yymsg = yymsgbuf;
#line 1426
  yymsg_alloc = (unsigned int )sizeof(yymsgbuf);
#line 1433
  yylen = 0;
#line 1435
  yytoken = 0;
#line 1436
  yyss = yyssa;
#line 1437
  yyvs = yyvsa;
#line 1438
  yyls = yylsa;
#line 1439
  yystacksize = 200U;
#line 1443
  yystate = 0;
#line 1444
  yyerrstatus = 0;
#line 1445
  svfnerrs = 0;
#line 1446
  svfchar = -2;
#line 1452
  yyssp = yyss;
#line 1453
  yyvsp = yyvs;
#line 1454
  yylsp = yyls;
#line 1458
  svflloc.last_line = 1;
#line 1458
  svflloc.first_line = svflloc.last_line;
#line 1459
  svflloc.last_column = 1;
#line 1459
  svflloc.first_column = svflloc.last_column;
#line 1462
  goto yysetstate;
  yynewstate: 
#line 1470
  yyssp ++;
  yysetstate: 
#line 1473
  *yyssp = (yytype_int16 )yystate;
#line 1475
  if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1478
    yysize = (unsigned int )((yyssp - yyss) + 1L);
#line 1508
    if (10000U <= yystacksize) {
#line 1509
      goto yyexhaustedlab;
    }
#line 1510
    yystacksize *= 2U;
#line 1511
    if (10000U < yystacksize) {
#line 1512
      yystacksize = 10000U;
    }
    {
#line 1515
    yyss1 = yyss;
#line 1516
    tmp = malloc((size_t )((unsigned long )yystacksize * ((sizeof(yytype_int16 ) + sizeof(YYSTYPE___0 )) + sizeof(YYLTYPE )) + 2UL * (sizeof(union yyalloc___0 ) - 1UL)));
#line 1516
    yyptr = (union yyalloc___0 *)tmp;
    }
#line 1518
    if (! yyptr) {
#line 1519
      goto yyexhaustedlab;
    }
    {
#line 1520
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1520
      __builtin_memcpy((void *)(& yyptr->yyss_alloc), (void const   *)yyss, (unsigned long )yysize * sizeof(*yyss));
#line 1520
      yyss = & yyptr->yyss_alloc;
#line 1520
      yynewbytes = (unsigned int )((unsigned long )yystacksize * sizeof(*yyss) + (sizeof(union yyalloc___0 ) - 1UL));
#line 1520
      yyptr += (unsigned long )yynewbytes / sizeof(*yyptr);
      }
#line 1520
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1521
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1521
      __builtin_memcpy((void *)(& yyptr->yyvs_alloc), (void const   *)yyvs, (unsigned long )yysize * sizeof(*yyvs));
#line 1521
      yyvs = & yyptr->yyvs_alloc;
#line 1521
      yynewbytes___0 = (unsigned int )((unsigned long )yystacksize * sizeof(*yyvs) + (sizeof(union yyalloc___0 ) - 1UL));
#line 1521
      yyptr += (unsigned long )yynewbytes___0 / sizeof(*yyptr);
      }
#line 1521
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1522
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1522
      __builtin_memcpy((void *)(& yyptr->yyls_alloc), (void const   *)yyls, (unsigned long )yysize * sizeof(*yyls));
#line 1522
      yyls = & yyptr->yyls_alloc;
#line 1522
      yynewbytes___1 = (unsigned int )((unsigned long )yystacksize * sizeof(*yyls) + (sizeof(union yyalloc___0 ) - 1UL));
#line 1522
      yyptr += (unsigned long )yynewbytes___1 / sizeof(*yyptr);
      }
#line 1522
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1524
    if ((unsigned long )yyss1 != (unsigned long )(yyssa)) {
      {
#line 1525
      free((void *)yyss1);
      }
    }
#line 1530
    yyssp = (yyss + yysize) - 1;
#line 1531
    yyvsp = (yyvs + yysize) - 1;
#line 1532
    yylsp = (yyls + yysize) - 1;
#line 1537
    if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1538
      goto yyabortlab;
    }
  }
#line 1543
  if (yystate == 4) {
#line 1544
    goto yyacceptlab;
  }
#line 1546
  goto yybackup;
  yybackup: 
#line 1557
  yyn = (int )yypact___1[yystate];
#line 1558
  if (yyn == -24) {
#line 1559
    goto yydefault;
  }
#line 1564
  if (svfchar == -2) {
    {
#line 1567
    svfchar = svflex(& svflval, & svflloc, priv_data->scanner);
    }
  }
#line 1570
  if (svfchar <= 0) {
#line 1572
    yytoken = 0;
#line 1572
    svfchar = yytoken;
  } else
#line 1577
  if ((unsigned int )svfchar <= 314U) {
#line 1577
    yytoken = (int )yytranslate___1[svfchar];
  } else {
#line 1577
    yytoken = 2;
  }
#line 1583
  yyn += yytoken;
#line 1584
  if (yyn < 0) {
#line 1585
    goto yydefault;
  } else
#line 1584
  if (145 < yyn) {
#line 1585
    goto yydefault;
  } else
#line 1584
  if ((int const   )yycheck___1[yyn] != (int const   )yytoken) {
#line 1585
    goto yydefault;
  }
#line 1586
  yyn = (int )yytable___1[yyn];
#line 1587
  if (yyn <= 0) {
#line 1589
    if (yyn == 0) {
#line 1590
      goto yyerrlab;
    } else
#line 1589
    if (yyn == -31) {
#line 1590
      goto yyerrlab;
    }
#line 1591
    yyn = - yyn;
#line 1592
    goto yyreduce;
  }
#line 1597
  if (yyerrstatus) {
#line 1598
    yyerrstatus --;
  }
#line 1604
  svfchar = -2;
#line 1606
  yystate = yyn;
#line 1607
  yyvsp ++;
#line 1607
  *yyvsp = svflval;
#line 1608
  yylsp ++;
#line 1608
  *yylsp = svflloc;
#line 1609
  goto yynewstate;
  yydefault: 
#line 1616
  yyn = (int )yydefact___1[yystate];
#line 1617
  if (yyn == 0) {
#line 1618
    goto yyerrlab;
  }
#line 1619
  goto yyreduce;
  yyreduce: 
#line 1627
  yylen = (int )yyr2___1[yyn];
#line 1637
  yyval = *(yyvsp + (1 - yylen));
  {
#line 1640
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1640
    if (yylen) {
#line 1640
      yyloc.first_line = ((yylsp - yylen) + 1)->first_line;
#line 1640
      yyloc.first_column = ((yylsp - yylen) + 1)->first_column;
#line 1640
      yyloc.last_line = ((yylsp - yylen) + yylen)->last_line;
#line 1640
      yyloc.last_column = ((yylsp - yylen) + yylen)->last_column;
    } else {
#line 1640
      yyloc.last_line = ((yylsp - yylen) + 0)->last_line;
#line 1640
      yyloc.first_line = yyloc.last_line;
#line 1640
      yyloc.last_column = ((yylsp - yylen) + 0)->last_column;
#line 1640
      yyloc.first_column = yyloc.last_column;
    }
#line 1640
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1644
  if (yyn == 5) {
#line 1644
    goto case_5;
  }
#line 105
  if (yyn == 6) {
#line 105 "svf_bison.y"
    goto case_6;
  }
#line 110
  if (yyn == 7) {
#line 110
    goto case_7;
  }
#line 115
  if (yyn == 8) {
#line 115
    goto case_8;
  }
#line 120
  if (yyn == 9) {
#line 120
    goto case_9;
  }
#line 129
  if (yyn == 10) {
#line 129
    goto case_10;
  }
#line 138
  if (yyn == 11) {
#line 138
    goto case_11;
  }
#line 145
  if (yyn == 12) {
#line 145
    goto case_12;
  }
#line 153
  if (yyn == 13) {
#line 153
    goto case_13;
  }
#line 168
  if (yyn == 14) {
#line 168
    goto case_14;
  }
#line 183
  if (yyn == 15) {
#line 183
    goto case_15;
  }
#line 198
  if (yyn == 16) {
#line 198
    goto case_16;
  }
#line 213
  if (yyn == 17) {
#line 213
    goto case_17;
  }
#line 221
  if (yyn == 18) {
#line 221
    goto case_18;
  }
#line 236
  if (yyn == 19) {
#line 236
    goto case_19;
  }
#line 251
  if (yyn == 20) {
#line 251
    goto case_20;
  }
#line 259
  if (yyn == 23) {
#line 259
    goto case_23;
  }
#line 272
  if (yyn == 24) {
#line 272
    goto case_24;
  }
#line 277
  if (yyn == 25) {
#line 277
    goto case_25;
  }
#line 282
  if (yyn == 26) {
#line 282
    goto case_26;
  }
#line 287
  if (yyn == 31) {
#line 287
    goto case_31;
  }
#line 298
  if (yyn == 32) {
#line 298
    goto case_32;
  }
#line 302
  if (yyn == 33) {
#line 302
    goto case_33;
  }
#line 310
  if (yyn == 34) {
#line 310
    goto case_34;
  }
#line 316
  if (yyn == 35) {
#line 316
    goto case_35;
  }
#line 324
  if (yyn == 37) {
#line 324
    goto case_37;
  }
#line 333
  if (yyn == 38) {
#line 333
    goto case_38;
  }
#line 340
  if (yyn == 39) {
#line 340
    goto case_39;
  }
#line 344
  if (yyn == 40) {
#line 344
    goto case_40;
  }
#line 348
  if (yyn == 41) {
#line 348
    goto case_41;
  }
#line 352
  if (yyn == 58) {
#line 352
    goto case_58;
  }
#line 378
  if (yyn == 59) {
#line 378
    goto case_59;
  }
#line 2021 "svf_bison.c"
  goto switch_default;
  case_5: /* CIL Label */ 
  {
#line 101 "svf_bison.y"
  svf_endxr(priv_data, (enum generic_irdr_coding )0, (yyvsp + -1)->token);
  }
#line 103
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 106
  svf_endxr(priv_data, (enum generic_irdr_coding )1, (yyvsp + -1)->token);
  }
#line 108
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 111
  svf_frequency(chain, 0.0);
  }
#line 113
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 116
  svf_frequency(chain, (yyvsp + -2)->dvalue);
  }
#line 118
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 121
  p = & priv_data->parser_params.ths_params;
#line 123
  p->number = (yyvsp + -2)->dvalue;
#line 124
  svf_hxr((enum generic_irdr_coding )1, p);
#line 125
  svf_free_ths_params(p);
  }
#line 127
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 130
  p___0 = & priv_data->parser_params.ths_params;
#line 132
  p___0->number = (yyvsp + -2)->dvalue;
#line 133
  svf_hxr((enum generic_irdr_coding )0, p___0);
#line 134
  svf_free_ths_params(p___0);
  }
#line 136
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 139
  printf((char const   */* __restrict  */)"PIOMAP not implemented\n");
#line 140
  svferror(& yyloc, priv_data, chain, "PIOMAP");
  }
#line 141
  goto yyerrorlab;
#line 143
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 146
  free((void *)(yyvsp + -1)->cvalue);
#line 147
  printf((char const   */* __restrict  */)"PIO not implemented\n");
#line 148
  svferror(& yyloc, priv_data, chain, "PIO");
  }
#line 149
  goto yyerrorlab;
#line 151
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 154
  rt = & priv_data->parser_params.runtest;
#line 156
  rt->run_state = (yyvsp + -4)->token;
#line 157
  rt->run_count = (uint32_t )(yyvsp + -3)->tdval.dvalue;
#line 158
  rt->run_clk = (yyvsp + -3)->tdval.token;
#line 159
  rt->end_state = (yyvsp + -1)->token;
#line 161
  tmp___0 = svf_runtest(chain, priv_data, rt);
  }
#line 161
  if (! tmp___0) {
    {
#line 162
    svferror(& yyloc, priv_data, chain, "RUNTEST");
    }
#line 163
    goto yyerrorlab;
  }
#line 166
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 169
  rt___0 = & priv_data->parser_params.runtest;
#line 171
  rt___0->run_state = (yyvsp + -3)->token;
#line 172
  rt___0->run_count = (uint32_t )0;
#line 173
  rt___0->run_clk = 0;
#line 174
  rt___0->end_state = (yyvsp + -1)->token;
#line 176
  tmp___1 = svf_runtest(chain, priv_data, rt___0);
  }
#line 176
  if (! tmp___1) {
    {
#line 177
    svferror(& yyloc, priv_data, chain, "RUNTEST");
    }
#line 178
    goto yyerrorlab;
  }
#line 181
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 184
  p___1 = & priv_data->parser_params.ths_params;
#line 187
  p___1->number = (yyvsp + -2)->dvalue;
#line 188
  result = svf_sxr(chain, priv_data, (enum generic_irdr_coding )1, p___1, & yyloc);
#line 189
  svf_free_ths_params(p___1);
  }
#line 191
  if (! result) {
    {
#line 192
    svferror(& yyloc, priv_data, chain, "SDR");
    }
#line 193
    goto yyerrorlab;
  }
#line 196
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 199
  p___2 = & priv_data->parser_params.ths_params;
#line 202
  p___2->number = (yyvsp + -2)->dvalue;
#line 203
  result___0 = svf_sxr(chain, priv_data, (enum generic_irdr_coding )0, p___2, & yyloc);
#line 204
  svf_free_ths_params(p___2);
  }
#line 206
  if (! result___0) {
    {
#line 207
    svferror(& yyloc, priv_data, chain, "SIR");
    }
#line 208
    goto yyerrorlab;
  }
#line 211
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 214
  tmp___2 = svf_state(chain, priv_data, & priv_data->parser_params.path_states, (yyvsp + -1)->token);
  }
#line 214
  if (! tmp___2) {
    {
#line 215
    svferror(& yyloc, priv_data, chain, "STATE");
    }
#line 216
    goto yyerrorlab;
  }
#line 219
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 222
  p___3 = & priv_data->parser_params.ths_params;
#line 225
  p___3->number = (yyvsp + -2)->dvalue;
#line 226
  result___1 = svf_txr((enum generic_irdr_coding )1, p___3);
#line 227
  svf_free_ths_params(p___3);
  }
#line 229
  if (! result___1) {
    {
#line 230
    svferror(& yyloc, priv_data, chain, "TDR");
    }
#line 231
    goto yyerrorlab;
  }
#line 234
  goto switch_break;
  case_19: /* CIL Label */ 
  {
#line 237
  p___4 = & priv_data->parser_params.ths_params;
#line 240
  p___4->number = (yyvsp + -2)->dvalue;
#line 241
  result___2 = svf_txr((enum generic_irdr_coding )0, p___4);
#line 242
  svf_free_ths_params(p___4);
  }
#line 244
  if (! result___2) {
    {
#line 245
    svferror(& yyloc, priv_data, chain, "TIR");
    }
#line 246
    goto yyerrorlab;
  }
#line 249
  goto switch_break;
  case_20: /* CIL Label */ 
  {
#line 252
  tmp___3 = svf_trst(chain, priv_data, (yyvsp + -1)->token);
  }
#line 252
  if (! tmp___3) {
    {
#line 253
    svferror(& yyloc, priv_data, chain, "TRST");
    }
#line 254
    goto yyerrorlab;
  }
#line 257
  goto switch_break;
  case_23: /* CIL Label */ 
#line 268
  priv_data->parser_params.ths_params.tdi = (yyvsp + 0)->cvalue;
#line 270
  goto switch_break;
  case_24: /* CIL Label */ 
#line 273
  priv_data->parser_params.ths_params.tdo = (yyvsp + 0)->cvalue;
#line 275
  goto switch_break;
  case_25: /* CIL Label */ 
#line 278
  priv_data->parser_params.ths_params.mask = (yyvsp + 0)->cvalue;
#line 280
  goto switch_break;
  case_26: /* CIL Label */ 
#line 283
  priv_data->parser_params.ths_params.smask = (yyvsp + 0)->cvalue;
#line 285
  goto switch_break;
  case_31: /* CIL Label */ 
#line 295
  yyval.token = 0;
#line 296
  goto switch_break;
  case_32: /* CIL Label */ 
#line 298
  yyval.token = (yyvsp + 0)->token;
#line 300
  goto switch_break;
  case_33: /* CIL Label */ 
#line 305
  yyval.tdval.token = (yyvsp + 0)->token;
#line 306
  yyval.tdval.dvalue = (yyvsp + -1)->dvalue;
#line 308
  goto switch_break;
  case_34: /* CIL Label */ 
#line 311
  yyval.tdval.token = (yyvsp + 0)->token;
#line 312
  yyval.tdval.dvalue = (yyvsp + -1)->dvalue;
#line 314
  goto switch_break;
  case_35: /* CIL Label */ 
#line 319
  priv_data->parser_params.runtest.min_time = 0.0;
#line 320
  priv_data->parser_params.runtest.max_time = 0.0;
#line 322
  goto switch_break;
  case_37: /* CIL Label */ 
#line 329
  priv_data->parser_params.runtest.min_time = (yyvsp + -2)->dvalue;
#line 331
  goto switch_break;
  case_38: /* CIL Label */ 
#line 336
  priv_data->parser_params.runtest.max_time = 0.0;
#line 338
  goto switch_break;
  case_39: /* CIL Label */ 
#line 340
  priv_data->parser_params.runtest.max_time = (yyvsp + -1)->dvalue;
#line 342
  goto switch_break;
  case_40: /* CIL Label */ 
#line 345
  yyval.token = 0;
#line 346
  goto switch_break;
  case_41: /* CIL Label */ 
#line 348
  yyval.token = (yyvsp + 0)->token;
#line 350
  goto switch_break;
  case_58: /* CIL Label */ 
#line 374
  priv_data->parser_params.path_states.num_states = 0;
#line 376
  goto switch_break;
  case_59: /* CIL Label */ 
#line 379
  ps = & priv_data->parser_params.path_states;
#line 381
  if (ps->num_states < 64) {
#line 382
    ps->states[ps->num_states] = (yyvsp + 0)->token;
#line 383
    (ps->num_states) ++;
  } else {
    {
#line 385
    printf((char const   */* __restrict  */)"Error %s: maximum number of %d path states reached.\n",
           "svf", 64);
    }
  }
#line 388
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 2021 "svf_bison.c"
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2025
  yyvsp -= yylen;
#line 2025
  yyssp -= yylen;
#line 2025
  yylsp -= yylen;
#line 2026
  yylen = 0;
#line 2029
  yyvsp ++;
#line 2029
  *yyvsp = yyval;
#line 2030
  yylsp ++;
#line 2030
  *yylsp = yyloc;
#line 2036
  yyn = (int )yyr1___1[yyn];
#line 2038
  yystate = (int )((int const   )yypgoto___1[yyn - 63] + (int const   )*yyssp);
#line 2039
  if (0 <= yystate) {
#line 2039
    if (yystate <= 145) {
#line 2039
      if ((int const   )yycheck___1[yystate] == (int const   )*yyssp) {
#line 2040
        yystate = (int )yytable___1[yystate];
      } else {
#line 2042
        yystate = (int )yydefgoto___1[yyn - 63];
      }
    } else {
#line 2042
      yystate = (int )yydefgoto___1[yyn - 63];
    }
  } else {
#line 2042
    yystate = (int )yydefgoto___1[yyn - 63];
  }
#line 2044
  goto yynewstate;
  yyerrlab: 
#line 2052
  if (! yyerrstatus) {
    {
#line 2054
    svfnerrs ++;
#line 2059
    tmp___4 = yysyntax_error((char *)0, yystate, svfchar);
#line 2059
    yysize___0 = tmp___4;
    }
#line 2060
    if (yymsg_alloc < yysize___0) {
#line 2060
      if (yymsg_alloc < 4294967295U) {
#line 2062
        yyalloc = 2U * yysize___0;
#line 2063
        if (yysize___0 <= yyalloc) {
#line 2063
          if (! (yyalloc <= 4294967295U)) {
#line 2064
            yyalloc = 4294967295U;
          }
        } else {
#line 2064
          yyalloc = 4294967295U;
        }
#line 2065
        if ((unsigned long )yymsg != (unsigned long )(yymsgbuf)) {
          {
#line 2066
          free((void *)yymsg);
          }
        }
        {
#line 2067
        tmp___5 = malloc(yyalloc);
#line 2067
        yymsg = (char *)tmp___5;
        }
#line 2068
        if (yymsg) {
#line 2069
          yymsg_alloc = yyalloc;
        } else {
#line 2072
          yymsg = yymsgbuf;
#line 2073
          yymsg_alloc = (unsigned int )sizeof(yymsgbuf);
        }
      }
    }
#line 2077
    if (0U < yysize___0) {
#line 2077
      if (yysize___0 <= yymsg_alloc) {
        {
#line 2079
        yysyntax_error(yymsg, yystate, svfchar);
#line 2080
        svferror(& svflloc, priv_data, chain, (char const   *)yymsg);
        }
      } else {
#line 2077
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 2084
      svferror(& svflloc, priv_data, chain, "syntax error");
      }
#line 2085
      if (yysize___0 != 0U) {
#line 2086
        goto yyexhaustedlab;
      }
    }
  }
#line 2092
  yyerror_range[0] = svflloc;
#line 2094
  if (yyerrstatus == 3) {
#line 2099
    if (svfchar <= 0) {
#line 2102
      if (svfchar == 0) {
#line 2103
        goto yyabortlab;
      }
    } else {
      {
#line 2107
      yydestruct___1("Error: discarding", yytoken, & svflval, & svflloc, priv_data,
                     chain);
#line 2109
      svfchar = -2;
      }
    }
  }
#line 2115
  goto yyerrlab1;
  yyerrorlab: 
#line 2129
  yyerror_range[0] = *(yylsp + (1 - yylen));
#line 2132
  yyvsp -= yylen;
#line 2132
  yyssp -= yylen;
#line 2132
  yylsp -= yylen;
#line 2133
  yylen = 0;
#line 2135
  yystate = (int )*yyssp;
#line 2136
  goto yyerrlab1;
  yyerrlab1: 
#line 2143
  yyerrstatus = 3;
  {
#line 2145
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 2147
    yyn = (int )yypact___1[yystate];
#line 2148
    if (yyn != -24) {
#line 2150
      yyn ++;
#line 2151
      if (0 <= yyn) {
#line 2151
        if (yyn <= 145) {
#line 2151
          if ((int const   )yycheck___1[yyn] == 1) {
#line 2153
            yyn = (int )yytable___1[yyn];
#line 2154
            if (0 < yyn) {
#line 2155
              goto while_break___3;
            }
          }
        }
      }
    }
#line 2160
    if ((unsigned long )yyssp == (unsigned long )yyss) {
#line 2161
      goto yyabortlab;
    }
    {
#line 2163
    yyerror_range[0] = *yylsp;
#line 2164
    yydestruct___1("Error: popping", (int )yystos___1[yystate], yyvsp, yylsp, priv_data,
                   chain);
#line 2166
    yyvsp --;
#line 2166
    yyssp --;
#line 2166
    yylsp --;
#line 2167
    yystate = (int )*yyssp;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 2171
  yyvsp ++;
#line 2171
  *yyvsp = svflval;
#line 2173
  yyerror_range[1] = svflloc;
  {
#line 2176
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 2176
    yyloc.first_line = ((yyerror_range - 1) + 1)->first_line;
#line 2176
    yyloc.first_column = ((yyerror_range - 1) + 1)->first_column;
#line 2176
    yyloc.last_line = ((yyerror_range - 1) + 2)->last_line;
#line 2176
    yyloc.last_column = ((yyerror_range - 1) + 2)->last_column;
#line 2176
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 2177
  yylsp ++;
#line 2177
  *yylsp = yyloc;
#line 2182
  yystate = yyn;
#line 2183
  goto yynewstate;
  yyacceptlab: 
#line 2190
  yyresult = 0;
#line 2191
  goto yyreturn;
  yyabortlab: 
#line 2197
  yyresult = 1;
#line 2198
  goto yyreturn;
  yyexhaustedlab: 
  {
#line 2205
  svferror(& svflloc, priv_data, chain, "memory exhausted");
#line 2206
  yyresult = 2;
  }
  yyreturn: 
#line 2211
  if (svfchar != -2) {
    {
#line 2212
    yydestruct___1("Cleanup: discarding lookahead", yytoken, & svflval, & svflloc,
                   priv_data, chain);
    }
  }
#line 2216
  yyvsp -= yylen;
#line 2216
  yyssp -= yylen;
#line 2216
  yylsp -= yylen;
  {
#line 2218
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 2218
    if (! ((unsigned long )yyssp != (unsigned long )yyss)) {
#line 2218
      goto while_break___5;
    }
    {
#line 2220
    yydestruct___1("Cleanup: popping", (int )yystos___1[*yyssp], yyvsp, yylsp, priv_data,
                   chain);
#line 2222
    yyvsp --;
#line 2222
    yyssp --;
#line 2222
    yylsp --;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
#line 2225
  if ((unsigned long )yyss != (unsigned long )(yyssa)) {
    {
#line 2226
    free((void *)yyss);
    }
  }
#line 2229
  if ((unsigned long )yymsg != (unsigned long )(yymsgbuf)) {
    {
#line 2230
    free((void *)yymsg);
    }
  }
#line 2233
  return (yyresult);
}
}
#line 411 "svf_bison.y"
void svferror(YYLTYPE *locp , parser_priv_t *priv_data , chain_t *chain , char const   *error_string ) 
{ 
  char *__cil_tmp5 ;

  {
  {
#line 414
  printf((char const   */* __restrict  */)"Error occurred for SVF command %s.\n",
         error_string);
  }
#line 415
  return;
}
}
#line 418 "svf_bison.y"
static void svf_free_ths_params(struct ths_params *params ) 
{ 


  {
#line 421
  params->number = 0.0;
#line 423
  if (params->tdi) {
    {
#line 424
    free((void *)params->tdi);
#line 425
    params->tdi = (char *)((void *)0);
    }
  }
#line 427
  if (params->tdo) {
    {
#line 428
    free((void *)params->tdo);
#line 429
    params->tdo = (char *)((void *)0);
    }
  }
#line 431
  if (params->mask) {
    {
#line 432
    free((void *)params->mask);
#line 433
    params->mask = (char *)((void *)0);
    }
  }
#line 435
  if (params->smask) {
    {
#line 436
    free((void *)params->smask);
#line 437
    params->smask = (char *)((void *)0);
    }
  }
#line 439
  return;
}
}
#line 442 "svf_bison.y"
int svf_bison_init(parser_priv_t *priv_data , FILE *f , int num_lines , int print_progress ) 
{ 
  struct svf_parser_params params ;
  void *tmp ;

  {
  {
#line 445
  params.ths_params.number = 0.0;
#line 445
  params.ths_params.tdi = (char *)((void *)0);
#line 445
  params.ths_params.tdo = (char *)((void *)0);
#line 445
  params.ths_params.mask = (char *)((void *)0);
#line 445
  params.ths_params.smask = (char *)((void *)0);
#line 445
  params.path_states.states[0] = 0;
#line 445
  params.path_states.states[1] = 0;
#line 445
  params.path_states.states[2] = 0;
#line 445
  params.path_states.states[3] = 0;
#line 445
  params.path_states.states[4] = 0;
#line 445
  params.path_states.states[5] = 0;
#line 445
  params.path_states.states[6] = 0;
#line 445
  params.path_states.states[7] = 0;
#line 445
  params.path_states.states[8] = 0;
#line 445
  params.path_states.states[9] = 0;
#line 445
  params.path_states.states[10] = 0;
#line 445
  params.path_states.states[11] = 0;
#line 445
  params.path_states.states[12] = 0;
#line 445
  params.path_states.states[13] = 0;
#line 445
  params.path_states.states[14] = 0;
#line 445
  params.path_states.states[15] = 0;
#line 445
  params.path_states.states[16] = 0;
#line 445
  params.path_states.states[17] = 0;
#line 445
  params.path_states.states[18] = 0;
#line 445
  params.path_states.states[19] = 0;
#line 445
  params.path_states.states[20] = 0;
#line 445
  params.path_states.states[21] = 0;
#line 445
  params.path_states.states[22] = 0;
#line 445
  params.path_states.states[23] = 0;
#line 445
  params.path_states.states[24] = 0;
#line 445
  params.path_states.states[25] = 0;
#line 445
  params.path_states.states[26] = 0;
#line 445
  params.path_states.states[27] = 0;
#line 445
  params.path_states.states[28] = 0;
#line 445
  params.path_states.states[29] = 0;
#line 445
  params.path_states.states[30] = 0;
#line 445
  params.path_states.states[31] = 0;
#line 445
  params.path_states.states[32] = 0;
#line 445
  params.path_states.states[33] = 0;
#line 445
  params.path_states.states[34] = 0;
#line 445
  params.path_states.states[35] = 0;
#line 445
  params.path_states.states[36] = 0;
#line 445
  params.path_states.states[37] = 0;
#line 445
  params.path_states.states[38] = 0;
#line 445
  params.path_states.states[39] = 0;
#line 445
  params.path_states.states[40] = 0;
#line 445
  params.path_states.states[41] = 0;
#line 445
  params.path_states.states[42] = 0;
#line 445
  params.path_states.states[43] = 0;
#line 445
  params.path_states.states[44] = 0;
#line 445
  params.path_states.states[45] = 0;
#line 445
  params.path_states.states[46] = 0;
#line 445
  params.path_states.states[47] = 0;
#line 445
  params.path_states.states[48] = 0;
#line 445
  params.path_states.states[49] = 0;
#line 445
  params.path_states.states[50] = 0;
#line 445
  params.path_states.states[51] = 0;
#line 445
  params.path_states.states[52] = 0;
#line 445
  params.path_states.states[53] = 0;
#line 445
  params.path_states.states[54] = 0;
#line 445
  params.path_states.states[55] = 0;
#line 445
  params.path_states.states[56] = 0;
#line 445
  params.path_states.states[57] = 0;
#line 445
  params.path_states.states[58] = 0;
#line 445
  params.path_states.states[59] = 0;
#line 445
  params.path_states.states[60] = 0;
#line 445
  params.path_states.states[61] = 0;
#line 445
  params.path_states.states[62] = 0;
#line 445
  params.path_states.states[63] = 0;
#line 445
  params.path_states.num_states = 0;
#line 445
  params.runtest.run_state = 0;
#line 445
  params.runtest.run_count = (uint32_t )0.0;
#line 445
  params.runtest.run_clk = 0;
#line 445
  params.runtest.min_time = (double )0;
#line 445
  params.runtest.max_time = (double )0;
#line 445
  params.runtest.end_state = 0;
#line 451
  priv_data->parser_params = params;
#line 453
  tmp = svf_flex_init(f, num_lines, print_progress);
#line 453
  priv_data->scanner = tmp;
  }
#line 453
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 454
    return (0);
  } else {
#line 456
    return (1);
  }
}
}
#line 460 "svf_bison.y"
void svf_bison_deinit(parser_priv_t *priv_data ) 
{ 


  {
  {
#line 463
  svf_flex_deinit(priv_data->scanner);
  }
#line 464
  return;
}
}
#line 513 "/usr/include/stdio.h"
extern int fgetc(FILE *__stream ) ;
#line 732
extern void rewind(FILE *__stream ) ;
#line 819
extern void perror(char const   *__s ) ;
#line 116 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 179 "/usr/include/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ceil(double __x )  __attribute__((__const__)) ;
#line 185
extern  __attribute__((__nothrow__)) double floor(double __x )  __attribute__((__const__)) ;
#line 222 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sigemptyset)(sigset_t *__set ) ;
#line 266
extern  __attribute__((__nothrow__)) int sigaction(int __sig , struct sigaction  const  * __restrict  __act ,
                                                   struct sigaction * __restrict  __oact ) ;
#line 448 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __useconds_t ualarm(__useconds_t __value , __useconds_t __interval ) ;
#line 35 "../../include/register.h"
tap_register *register_alloc(int len ) ;
#line 37
void register_free(tap_register *tr ) ;
#line 39
char const   *register_get_string(tap_register const   *tr ) ;
#line 41
tap_register *register_init(tap_register *tr , char const   *value ) ;
#line 60 "../../include/part.h"
instruction *part_find_instruction(part_t *p , char const   *iname ) ;
#line 63
void part_set_instruction(part_t *p , char const   *iname ) ;
#line 133 "../../include/cable.h"
int cable_set_signal(cable_t *cable , int mask , int val ) ;
#line 142
void cable_set_frequency(cable_t *cable , uint32_t new_frequency ) ;
#line 143
uint32_t cable_get_frequency(cable_t *cable ) ;
#line 53 "../../include/chain.h"
void chain_clock(chain_t *chain , int tms , int tdi , int n ) ;
#line 58
void chain_shift_instructions_mode(chain_t *chain , int capture_output , int capture ,
                                   int chain_exit ) ;
#line 60
void chain_shift_data_registers_mode(chain_t *chain , int capture_output , int capture ,
                                     int chain_exit ) ;
#line 59 "../../include/state.h"
int tap_state(chain_t *chain ) ;
#line 62
int tap_state_reset(chain_t *chain ) ;
#line 70 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/svf/svf.c"
static void svf_force_reset_state(chain_t *chain ) 
{ 


  {
  {
#line 73
  chain_clock(chain, 1, 0, 5);
#line 74
  tap_state_reset(chain);
  }
#line 75
  return;
}
}
#line 90 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/svf/svf.c"
static void svf_goto_state(chain_t *chain , int new_state ) 
{ 
  int current_state ;

  {
  {
#line 95
  current_state = tap_state(chain);
  }
#line 98
  if (new_state == 1 << 7) {
#line 99
    new_state = (1 << 7) | (1 << 3);
  }
#line 102
  if (current_state == new_state) {
#line 103
    return;
  }
  {
#line 106
  if (current_state == ((1 << 7) | (1 << 3))) {
#line 106
    goto case_exp;
  }
#line 110
  if (current_state == 1 << 3) {
#line 110
    goto case_exp___0;
  }
#line 115
  if (current_state == 1 << 1) {
#line 115
    goto case_exp___1;
  }
#line 115
  if (current_state == 1) {
#line 115
    goto case_exp___1;
  }
#line 127
  if (current_state == ((1 | (1 << 2)) | (1 << 4))) {
#line 127
    goto case_exp___2;
  }
#line 136
  if (current_state == (((1 << 1) | (1 << 2)) | (1 << 4))) {
#line 136
    goto case_exp___3;
  }
#line 146
  if (current_state == ((1 << 1) | (1 << 2))) {
#line 146
    goto case_exp___4;
  }
#line 146
  if (current_state == (1 | (1 << 2))) {
#line 146
    goto case_exp___4;
  }
#line 151
  if (current_state == ((1 | (1 << 5)) | (1 << 6))) {
#line 151
    goto case_exp___6;
  }
#line 160
  if (current_state == (((1 << 1) | (1 << 5)) | (1 << 6))) {
#line 160
    goto case_exp___7;
  }
#line 170
  if (current_state == ((1 << 1) | (1 << 6))) {
#line 170
    goto case_exp___8;
  }
#line 170
  if (current_state == (1 | (1 << 6))) {
#line 170
    goto case_exp___8;
  }
#line 175
  if (current_state == ((1 | (1 << 2)) | (1 << 5))) {
#line 175
    goto case_exp___10;
  }
#line 184
  if (current_state == (((1 << 1) | (1 << 2)) | (1 << 5))) {
#line 184
    goto case_exp___11;
  }
#line 194
  if (current_state == ((1 << 1) | (1 << 3))) {
#line 194
    goto case_exp___12;
  }
#line 194
  if (current_state == (1 | (1 << 3))) {
#line 194
    goto case_exp___12;
  }
#line 203
  goto switch_default;
  case_exp: /* CIL Label */ 
  {
#line 107
  chain_clock(chain, 0, 0, 1);
  }
#line 108
  goto switch_break;
  case_exp___0: /* CIL Label */ 
  {
#line 111
  chain_clock(chain, 1, 0, 1);
  }
#line 112
  goto switch_break;
  case_exp___1: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 116
  if (new_state == ((1 << 7) | (1 << 3))) {
    {
#line 121
    chain_clock(chain, 1, 0, 1);
    }
  } else
#line 116
  if (new_state == 1 << 3) {
    {
#line 121
    chain_clock(chain, 1, 0, 1);
    }
  } else
#line 116
  if (current_state & 1) {
#line 116
    if (new_state & (1 << 1)) {
      {
#line 121
      chain_clock(chain, 1, 0, 1);
      }
    } else {
#line 116
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 116
  if (current_state & (1 << 1)) {
#line 116
    if (new_state & 1) {
      {
#line 121
      chain_clock(chain, 1, 0, 1);
      }
    } else {
      {
#line 124
      chain_clock(chain, 0, 0, 1);
      }
    }
  } else {
    {
#line 124
    chain_clock(chain, 0, 0, 1);
    }
  }
#line 125
  goto switch_break;
  case_exp___2: /* CIL Label */ 
#line 128
  if (new_state == (1 | (1 << 2))) {
    {
#line 130
    chain_clock(chain, 0, 0, 1);
    }
  } else {
    {
#line 133
    chain_clock(chain, 1, 0, 1);
    }
  }
#line 134
  goto switch_break;
  case_exp___3: /* CIL Label */ 
#line 137
  if (new_state == ((1 << 1) | (1 << 2))) {
    {
#line 139
    chain_clock(chain, 0, 0, 1);
    }
  } else {
    {
#line 142
    chain_clock(chain, 1, 0, 1);
    }
  }
#line 143
  goto switch_break;
  case_exp___4: /* CIL Label */ 
  case_exp___5: /* CIL Label */ 
  {
#line 148
  chain_clock(chain, 1, 0, 1);
  }
#line 149
  goto switch_break;
  case_exp___6: /* CIL Label */ 
#line 152
  if (new_state == (1 | (1 << 6))) {
    {
#line 154
    chain_clock(chain, 0, 0, 1);
    }
  } else {
    {
#line 157
    chain_clock(chain, 1, 0, 1);
    }
  }
#line 158
  goto switch_break;
  case_exp___7: /* CIL Label */ 
#line 161
  if (new_state == ((1 << 1) | (1 << 6))) {
    {
#line 163
    chain_clock(chain, 0, 0, 1);
    }
  } else {
    {
#line 166
    chain_clock(chain, 1, 0, 1);
    }
  }
#line 167
  goto switch_break;
  case_exp___8: /* CIL Label */ 
  case_exp___9: /* CIL Label */ 
  {
#line 172
  chain_clock(chain, 1, 0, 1);
  }
#line 173
  goto switch_break;
  case_exp___10: /* CIL Label */ 
#line 176
  if (new_state == (1 | (1 << 2))) {
    {
#line 178
    chain_clock(chain, 0, 0, 1);
    }
  } else {
    {
#line 181
    chain_clock(chain, 1, 0, 1);
    }
  }
#line 182
  goto switch_break;
  case_exp___11: /* CIL Label */ 
#line 185
  if (new_state == ((1 << 1) | (1 << 2))) {
    {
#line 187
    chain_clock(chain, 0, 0, 1);
    }
  } else {
    {
#line 190
    chain_clock(chain, 1, 0, 1);
    }
  }
#line 191
  goto switch_break;
  case_exp___12: /* CIL Label */ 
  case_exp___13: /* CIL Label */ 
#line 195
  if (new_state == 1 << 3) {
    {
#line 197
    chain_clock(chain, 0, 0, 1);
    }
  } else {
    {
#line 200
    chain_clock(chain, 1, 0, 1);
    }
  }
#line 201
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 204
  svf_force_reset_state(chain);
  }
#line 205
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 209
  svf_goto_state(chain, new_state);
  }
#line 210
  return;
}
}
#line 225 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/svf/svf.c"
static int svf_map_state(int state ) 
{ 
  int jtag_state ;

  {
  {
#line 231
  if (state == 268) {
#line 231
    goto case_268;
  }
#line 234
  if (state == 269) {
#line 234
    goto case_269;
  }
#line 237
  if (state == 311) {
#line 237
    goto case_311;
  }
#line 240
  if (state == 314) {
#line 240
    goto case_314;
  }
#line 243
  if (state == 309) {
#line 243
    goto case_309;
  }
#line 246
  if (state == 312) {
#line 246
    goto case_312;
  }
#line 249
  if (state == 308) {
#line 249
    goto case_308;
  }
#line 252
  if (state == 313) {
#line 252
    goto case_313;
  }
#line 255
  if (state == 310) {
#line 255
    goto case_310;
  }
#line 259
  if (state == 304) {
#line 259
    goto case_304;
  }
#line 262
  if (state == 307) {
#line 262
    goto case_307;
  }
#line 265
  if (state == 302) {
#line 265
    goto case_302;
  }
#line 268
  if (state == 305) {
#line 268
    goto case_305;
  }
#line 271
  if (state == 301) {
#line 271
    goto case_301;
  }
#line 274
  if (state == 306) {
#line 274
    goto case_306;
  }
#line 277
  if (state == 303) {
#line 277
    goto case_303;
  }
#line 281
  goto switch_default;
  case_268: /* CIL Label */ 
#line 232
  jtag_state = (1 << 7) | (1 << 3);
#line 233
  goto switch_break;
  case_269: /* CIL Label */ 
#line 235
  jtag_state = 1 << 3;
#line 236
  goto switch_break;
  case_311: /* CIL Label */ 
#line 238
  jtag_state = 1;
#line 239
  goto switch_break;
  case_314: /* CIL Label */ 
#line 241
  jtag_state = (1 | (1 << 2)) | (1 << 4);
#line 242
  goto switch_break;
  case_309: /* CIL Label */ 
#line 244
  jtag_state = 1 | (1 << 2);
#line 245
  goto switch_break;
  case_312: /* CIL Label */ 
#line 247
  jtag_state = (1 | (1 << 5)) | (1 << 6);
#line 248
  goto switch_break;
  case_308: /* CIL Label */ 
#line 250
  jtag_state = 1 | (1 << 6);
#line 251
  goto switch_break;
  case_313: /* CIL Label */ 
#line 253
  jtag_state = (1 | (1 << 2)) | (1 << 5);
#line 254
  goto switch_break;
  case_310: /* CIL Label */ 
#line 256
  jtag_state = 1 | (1 << 3);
#line 257
  goto switch_break;
  case_304: /* CIL Label */ 
#line 260
  jtag_state = 1 << 1;
#line 261
  goto switch_break;
  case_307: /* CIL Label */ 
#line 263
  jtag_state = ((1 << 1) | (1 << 2)) | (1 << 4);
#line 264
  goto switch_break;
  case_302: /* CIL Label */ 
#line 266
  jtag_state = (1 << 1) | (1 << 2);
#line 267
  goto switch_break;
  case_305: /* CIL Label */ 
#line 269
  jtag_state = ((1 << 1) | (1 << 5)) | (1 << 6);
#line 270
  goto switch_break;
  case_301: /* CIL Label */ 
#line 272
  jtag_state = (1 << 1) | (1 << 6);
#line 273
  goto switch_break;
  case_306: /* CIL Label */ 
#line 275
  jtag_state = ((1 << 1) | (1 << 2)) | (1 << 5);
#line 276
  goto switch_break;
  case_303: /* CIL Label */ 
#line 278
  jtag_state = (1 << 1) | (1 << 3);
#line 279
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 282
  jtag_state = 1 << 7;
#line 283
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 286
  return (jtag_state);
}
}
#line 301 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/svf/svf.c"
static int svf_hex2dec(char nibble ) 
{ 
  int lower ;

  {
#line 306
  if ((int )nibble >= 48) {
#line 306
    if ((int )nibble <= 57) {
#line 307
      return ((int )nibble - 48);
    }
  }
  {
#line 309
  lower = tolower((int )nibble);
  }
#line 310
  if (lower >= 97) {
#line 310
    if (lower <= 102) {
#line 311
      return ((lower - 97) + 10);
    }
  }
#line 313
  return (0);
}
}
#line 342 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/svf/svf.c"
static char *svf_build_bit_string(char *hex_string , int len ) 
{ 
  char *bit_string ;
  char *bit_string_pos ;
  int nibble ;
  char *hex_string_pos ;
  int hex_string_idx ;
  char *tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  int tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp15 ;

  {
  {
#line 350
  tmp___0 = calloc((size_t )(len + 1), (size_t )sizeof(char ));
#line 350
  bit_string = (char *)tmp___0;
  }
#line 350
  if (! bit_string) {
    {
#line 351
    tmp = gettext("out of memory");
#line 351
    printf((char const   */* __restrict  */)tmp);
    }
#line 352
    return ((char *)((void *)0));
  }
  {
#line 356
  tmp___1 = strlen((char const   *)hex_string);
#line 356
  hex_string_idx = (int )tmp___1;
#line 357
  hex_string_pos = hex_string + hex_string_idx;
#line 358
  nibble = 3;
#line 359
  bit_string_pos = bit_string + len;
  }
  {
#line 360
  while (1) {
    while_continue: /* CIL Label */ ;
#line 361
    bit_string_pos --;
#line 362
    if (nibble == 3) {
#line 363
      nibble = 0;
#line 364
      hex_string_pos --;
#line 365
      hex_string_idx --;
    } else {
#line 367
      nibble ++;
    }
#line 369
    if (hex_string_idx >= 0) {
#line 369
      tmp___4 = (int )*hex_string_pos;
    } else {
#line 369
      tmp___4 = '0';
    }
    {
#line 369
    tmp___5 = svf_hex2dec((char )tmp___4);
    }
#line 369
    if (tmp___5 & (1 << nibble)) {
#line 369
      *bit_string_pos = (char )'1';
    } else {
#line 369
      *bit_string_pos = (char )'0';
    }
#line 360
    if (! ((unsigned long )bit_string_pos != (unsigned long )bit_string)) {
#line 360
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 372
  *(bit_string + len) = (char )'\000';
#line 374
  return (bit_string);
}
}
#line 392 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/svf/svf.c"
static int svf_copy_hex_to_register(char *hex_string , tap_register *reg ) 
{ 
  char *bit_string ;

  {
  {
#line 397
  bit_string = svf_build_bit_string(hex_string, reg->len);
  }
#line 397
  if (! bit_string) {
#line 398
    return (0);
  }
  {
#line 400
  register_init(reg, (char const   *)bit_string);
#line 403
  free((void *)bit_string);
  }
#line 405
  return (1);
}
}
#line 427 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/svf/svf.c"
static int svf_compare_tdo(parser_priv_t *priv , char *tdo , char *mask , tap_register *reg ,
                           YYLTYPE *loc ) 
{ 
  char *tdo_bit ;
  char *mask_bit ;
  int pos ;
  int mismatch ;
  int result ;
  char *tmp ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 431
  result = 1;
#line 433
  tdo_bit = svf_build_bit_string(tdo, reg->len);
  }
#line 433
  if (! tdo_bit) {
#line 434
    return (0);
  }
  {
#line 435
  mask_bit = svf_build_bit_string(mask, reg->len);
  }
#line 435
  if (! mask_bit) {
    {
#line 436
    free((void *)tdo_bit);
    }
#line 437
    return (0);
  }
  {
#line 441
  register_get_string((tap_register const   *)reg);
#line 443
  mismatch = -1;
#line 444
  pos = 0;
  }
  {
#line 444
  while (1) {
    while_continue: /* CIL Label */ ;
#line 444
    if (! (pos < reg->len)) {
#line 444
      goto while_break;
    }
#line 445
    if ((int )*(tdo_bit + pos) != (int )*(reg->string + pos)) {
#line 445
      if ((int )*(mask_bit + pos) == 49) {
#line 446
        mismatch = pos;
      }
    }
#line 444
    pos ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 448
  if (mismatch >= 0) {
    {
#line 449
    tmp = gettext("Error %s: mismatch at position %d for TDO\n");
#line 449
    printf((char const   */* __restrict  */)tmp, "svf", mismatch);
    }
#line 450
    if ((unsigned long )loc != (unsigned long )((void *)0)) {
      {
#line 451
      printf((char const   */* __restrict  */)" in input file between line %d col %d and line %d col %d\n",
             loc->first_line + 1, loc->first_column + 1, loc->last_line + 1, loc->last_column + 1);
      }
    }
#line 464
    if (priv->svf_stop_on_mismatch) {
#line 465
      result = 0;
    }
  }
  {
#line 468
  free((void *)mask_bit);
#line 469
  free((void *)tdo_bit);
  }
#line 471
  return (result);
}
}
#line 489 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/svf/svf.c"
static void svf_remember_param(char **rem , char *new ) 
{ 


  {
#line 492
  if (new) {
#line 493
    if (*rem) {
      {
#line 494
      free((void *)*rem);
      }
    }
#line 496
    *rem = new;
  }
#line 498
  return;
}
}
#line 516 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/svf/svf.c"
static int svf_all_care(char **string , double number ) 
{ 
  char *ptr ;
  int num ;
  int result ;
  char *tmp ;
  void *tmp___0 ;
  char *__cil_tmp8 ;

  {
#line 522
  result = 1;
#line 524
  num = (int )number;
#line 525
  if (num % 4 == 0) {
#line 525
    num /= 4;
  } else {
#line 525
    num = num / 4 + 1;
  }
  {
#line 528
  tmp___0 = calloc((size_t )(num + 1), (size_t )sizeof(char ));
#line 528
  ptr = (char *)tmp___0;
  }
#line 528
  if (! ptr) {
    {
#line 529
    tmp = gettext("out of memory");
#line 529
    printf((char const   */* __restrict  */)tmp);
    }
#line 530
    return (0);
  }
  {
#line 532
  memset((void *)ptr, 'F', (size_t )num);
#line 533
  *(ptr + num) = (char )'\000';
#line 535
  svf_remember_param(string, ptr);
  }
#line 539
  return (result);
}
}
#line 552 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/svf/svf.c"
void svf_endxr(parser_priv_t *priv , enum generic_irdr_coding ir_dr , int state ) 
{ 


  {
  {
#line 556
  if ((unsigned int )ir_dr == 0U) {
#line 556
    goto case_0;
  }
#line 559
  if ((unsigned int )ir_dr == 1U) {
#line 559
    goto case_1;
  }
#line 555
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 557
  priv->endir = svf_map_state(state);
  }
#line 558
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 560
  priv->enddr = svf_map_state(state);
  }
#line 561
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 563
  return;
}
}
#line 574 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/svf/svf.c"
void svf_frequency(chain_t *chain , double freq ) 
{ 


  {
  {
#line 577
  cable_set_frequency(chain->cable, (uint32_t )freq);
  }
#line 578
  return;
}
}
#line 597 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/svf/svf.c"
int svf_hxr(enum generic_irdr_coding ir_dr , struct ths_params *params ) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 600
  if (params->number != 0.0) {
#line 601
    if ((unsigned int )ir_dr == 0U) {
#line 601
      tmp = "HIR";
    } else {
#line 601
      tmp = "HDR";
    }
    {
#line 601
    tmp___0 = gettext("Warning %s: command %s not implemented\n");
#line 601
    printf((char const   */* __restrict  */)tmp___0, "svf", tmp);
    }
  }
#line 604
  return (1);
}
}
#line 608 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/svf/svf.c"
static int max_time_reached  ;
#line 609 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/svf/svf.c"
static void sigalrm_handler(int signal___0 ) 
{ 


  {
#line 611
  max_time_reached = 1;
#line 612
  return;
}
}
#line 627 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/svf/svf.c"
int svf_runtest(chain_t *chain , parser_priv_t *priv , struct runtest *params ) 
{ 
  uint32_t run_count ;
  uint32_t frequency ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  uint32_t tmp___3 ;
  uint32_t min_time_run_count ;
  double tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  struct sigaction sa ;
  unsigned int max_time ;
  int tmp___7 ;
  double tmp___8 ;
  uint32_t tmp___9 ;
  struct sigaction sa___0 ;
  int tmp___10 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;

  {
#line 633
  if (params->run_count > 0U) {
#line 633
    if (params->run_clk != 298) {
      {
#line 634
      tmp = gettext("Error %s: only TCK is supported for RUNTEST.\n");
#line 634
      printf((char const   */* __restrict  */)tmp, "svf");
      }
#line 635
      return (0);
    }
  }
#line 637
  if (params->max_time > 0.0) {
#line 637
    if (params->max_time < params->min_time) {
      {
#line 638
      tmp___0 = gettext("Error %s: maximum time must be larger or equal to minimum time.\n");
#line 638
      printf((char const   */* __restrict  */)tmp___0, "svf");
      }
#line 640
      return (0);
    }
  }
#line 642
  if (params->max_time > 0.0) {
#line 643
    if (! priv->issued_runtest_maxtime) {
      {
#line 644
      tmp___1 = gettext("Warning %s: maximum time for RUNTEST not guaranteed.\n");
#line 644
      printf((char const   */* __restrict  */)tmp___1, "svf");
#line 645
      tmp___2 = gettext(" This message is only displayed once.\n");
#line 645
      printf((char const   */* __restrict  */)tmp___2);
#line 646
      priv->issued_runtest_maxtime = 1;
      }
    }
  }
#line 650
  if (params->run_state != 0) {
    {
#line 651
    priv->runtest_run_state = svf_map_state(params->run_state);
    }
#line 653
    if (params->end_state == 0) {
      {
#line 654
      priv->runtest_end_state = svf_map_state(params->run_state);
      }
    }
  }
#line 656
  if (params->end_state != 0) {
    {
#line 657
    priv->runtest_end_state = svf_map_state(params->end_state);
    }
  }
#line 660
  run_count = params->run_count;
#line 661
  if (params->min_time > 0.0) {
#line 662
    if (priv->ref_freq > 0U) {
#line 662
      frequency = priv->ref_freq;
    } else {
      {
#line 662
      tmp___3 = cable_get_frequency(chain->cable);
#line 662
      frequency = tmp___3;
      }
    }
#line 663
    if (frequency > 0U) {
      {
#line 664
      tmp___4 = ceil(params->min_time * (double )frequency);
#line 664
      min_time_run_count = (uint32_t )tmp___4;
      }
#line 665
      if (min_time_run_count > run_count) {
#line 666
        run_count = min_time_run_count;
      }
    } else {
      {
#line 669
      tmp___5 = gettext("Error %s: Maximum cable clock frequency required for RUNTEST.\n");
#line 669
      printf((char const   */* __restrict  */)tmp___5, "svf");
#line 670
      tmp___6 = gettext("  Set the cable frequency with \'FREQUENCY <Hz>\'.\n");
#line 670
      printf((char const   */* __restrict  */)tmp___6);
      }
#line 671
      return (0);
    }
  }
  {
#line 675
  svf_goto_state(chain, priv->runtest_run_state);
  }
#line 692
  if (params->max_time > 0.0) {
    {
#line 696
    sa.__sigaction_handler.sa_handler = & sigalrm_handler;
#line 697
    sa.sa_flags = (-0x7FFFFFFF-1);
#line 698
    sigemptyset(& sa.sa_mask);
#line 699
    tmp___7 = sigaction(14, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
    }
#line 699
    if (tmp___7 != 0) {
      {
#line 700
      perror("sigaction");
#line 701
      exit(1);
      }
    }
    {
#line 704
    tmp___8 = floor(params->max_time / (double )1000000);
#line 704
    max_time = (unsigned int )tmp___8;
    }
#line 705
    if (max_time == 0U) {
#line 706
      max_time = 1U;
    }
    {
#line 708
    ualarm(max_time, (__useconds_t )0);
    }
  }
#line 711
  if (params->max_time > 0.0) {
    {
#line 712
    while (1) {
      while_continue: /* CIL Label */ ;
#line 712
      tmp___9 = run_count;
#line 712
      run_count --;
#line 712
      if (tmp___9 > 0U) {
#line 712
        if (! (! max_time_reached)) {
#line 712
          goto while_break;
        }
      } else {
#line 712
        goto while_break;
      }
      {
#line 713
      chain_clock(chain, 0, 0, 1);
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 716
    chain_clock(chain, 0, 0, (int )run_count);
    }
  }
  {
#line 718
  svf_goto_state(chain, priv->runtest_end_state);
  }
#line 721
  if (params->max_time > 0.0) {
    {
#line 723
    sa___0.__sigaction_handler.sa_handler = (void (*)(int  ))1;
#line 724
    sa___0.sa_flags = 0;
#line 725
    sigemptyset(& sa___0.sa_mask);
#line 726
    tmp___10 = sigaction(14, (struct sigaction  const  */* __restrict  */)(& sa___0),
                         (struct sigaction */* __restrict  */)((void *)0));
    }
#line 726
    if (tmp___10 != 0) {
      {
#line 727
      perror("sigaction");
#line 728
      exit(1);
      }
    }
  }
#line 733
  return (1);
}
}
#line 752 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/svf/svf.c"
int svf_state(chain_t *chain , parser_priv_t *priv , struct path_states *path_states ,
              int stable_state ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 758
  priv->svf_state_executed = 1;
#line 760
  i = 0;
  {
#line 760
  while (1) {
    while_continue: /* CIL Label */ ;
#line 760
    if (! (i < path_states->num_states)) {
#line 760
      goto while_break;
    }
    {
#line 761
    tmp = svf_map_state(path_states->states[i]);
#line 761
    svf_goto_state(chain, tmp);
#line 760
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 763
  if (stable_state) {
    {
#line 764
    tmp___0 = svf_map_state(stable_state);
#line 764
    svf_goto_state(chain, tmp___0);
    }
  }
#line 766
  return (1);
}
}
#line 783 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/svf/svf.c"
int svf_sxr(chain_t *chain , parser_priv_t *priv , enum generic_irdr_coding ir_dr ,
            struct ths_params *params , struct YYLTYPE *loc ) 
{ 
  sxr_t *sxr_params ;
  int len ;
  int result ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  tap_register *tmp___5 ;
  char *tmp___6 ;
  tap_register *tmp___7 ;
  tap_register *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
#line 788
  result = 1;
#line 790
  if ((unsigned int )ir_dr == 0U) {
#line 790
    sxr_params = & priv->sir_params;
  } else {
#line 790
    sxr_params = & priv->sdr_params;
  }
  {
#line 793
  svf_remember_param(& sxr_params->params.tdi, params->tdi);
#line 795
  sxr_params->params.tdo = params->tdo;
#line 797
  svf_remember_param(& sxr_params->params.mask, params->mask);
#line 799
  svf_remember_param(& sxr_params->params.smask, params->smask);
  }
#line 803
  if (sxr_params->params.number != params->number) {
#line 804
    sxr_params->no_tdi = 1;
#line 805
    sxr_params->no_tdo = 1;
#line 807
    if (! params->mask) {
      {
#line 808
      tmp = svf_all_care(& sxr_params->params.mask, params->number);
      }
#line 808
      if (! tmp) {
#line 809
        result = 0;
      }
    }
#line 810
    if (! params->smask) {
      {
#line 811
      tmp___0 = svf_all_care(& sxr_params->params.smask, params->number);
      }
#line 811
      if (! tmp___0) {
#line 812
        result = 0;
      }
    }
  }
#line 815
  sxr_params->params.number = params->number;
#line 818
  if (sxr_params->no_tdi) {
#line 819
    if (! params->tdi) {
#line 820
      if ((unsigned int )ir_dr == 0U) {
#line 820
        tmp___1 = "SIR";
      } else {
#line 820
        tmp___1 = "SDR";
      }
      {
#line 820
      tmp___2 = gettext("Error %s: first %s command after length change must have a TDI value.\n");
#line 820
      printf((char const   */* __restrict  */)tmp___2, "svf", tmp___1);
#line 822
      result = 0;
      }
    }
#line 824
    sxr_params->no_tdi = 0;
  }
#line 828
  params->tdi = (char *)((void *)0);
#line 829
  params->mask = (char *)((void *)0);
#line 830
  params->smask = (char *)((void *)0);
#line 833
  if (! result) {
#line 834
    return (0);
  }
#line 840
  len = (int )sxr_params->params.number;
  {
#line 842
  if ((unsigned int )ir_dr == 0U) {
#line 842
    goto case_0;
  }
#line 858
  if ((unsigned int )ir_dr == 1U) {
#line 858
    goto case_1;
  }
#line 841
  goto switch_break;
  case_0: /* CIL Label */ 
#line 844
  if (((priv->ir)->value)->len != len) {
    {
#line 845
    tmp___3 = gettext("Error %s: SIR command length inconsistent.\n");
#line 845
    printf((char const   */* __restrict  */)tmp___3, "svf");
    }
#line 847
    if ((unsigned long )loc != (unsigned long )((void *)0)) {
      {
#line 848
      printf((char const   */* __restrict  */)" in input file between line %d col %d and line %d col %d\n",
             loc->first_line + 1, loc->first_column + 1, loc->last_line + 1, loc->last_column + 1);
      }
    }
#line 854
    return (0);
  }
#line 856
  goto switch_break;
  case_1: /* CIL Label */ 
#line 860
  if (((priv->dr)->in)->len != len) {
    {
#line 862
    register_free((priv->dr)->in);
#line 863
    (priv->dr)->in = (tap_register *)((void *)0);
#line 864
    register_free((priv->dr)->out);
#line 865
    (priv->dr)->out = (tap_register *)((void *)0);
#line 867
    tmp___5 = register_alloc(len);
#line 867
    (priv->dr)->in = tmp___5;
    }
#line 867
    if (! tmp___5) {
      {
#line 868
      tmp___4 = gettext("out of memory");
#line 868
      printf((char const   */* __restrict  */)tmp___4);
      }
#line 869
      return (0);
    }
    {
#line 871
    tmp___7 = register_alloc(len);
#line 871
    (priv->dr)->out = tmp___7;
    }
#line 871
    if (! tmp___7) {
      {
#line 872
      tmp___6 = gettext("out of memory");
#line 872
      printf((char const   */* __restrict  */)tmp___6);
      }
#line 873
      return (0);
    }
  }
#line 876
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 881
  if ((unsigned int )ir_dr == 0U) {
#line 881
    tmp___8 = (priv->ir)->value;
  } else {
#line 881
    tmp___8 = (priv->dr)->in;
  }
  {
#line 881
  tmp___9 = svf_copy_hex_to_register(sxr_params->params.tdi, tmp___8);
  }
#line 881
  if (! tmp___9) {
#line 884
    return (0);
  }
  {
#line 889
  if ((unsigned int )ir_dr == 0U) {
#line 889
    goto case_0___0;
  }
#line 901
  if ((unsigned int )ir_dr == 1U) {
#line 901
    goto case_1___0;
  }
#line 888
  goto switch_break___0;
  case_0___0: /* CIL Label */ 
  {
#line 890
  svf_goto_state(chain, (1 << 1) | (1 << 2));
  }
#line 891
  if (sxr_params->params.tdo) {
#line 891
    tmp___10 = 1;
  } else {
#line 891
    tmp___10 = 0;
  }
  {
#line 891
  chain_shift_instructions_mode(chain, tmp___10, 0, 2);
#line 895
  svf_goto_state(chain, priv->endir);
  }
#line 897
  if (sxr_params->params.tdo) {
    {
#line 898
    result = svf_compare_tdo(priv, sxr_params->params.tdo, sxr_params->params.mask,
                             (priv->ir)->out, loc);
    }
  }
#line 899
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
  {
#line 902
  svf_goto_state(chain, 1 | (1 << 2));
  }
#line 903
  if (sxr_params->params.tdo) {
#line 903
    tmp___11 = 1;
  } else {
#line 903
    tmp___11 = 0;
  }
  {
#line 903
  chain_shift_data_registers_mode(chain, tmp___11, 0, 2);
#line 907
  svf_goto_state(chain, priv->enddr);
  }
#line 909
  if (sxr_params->params.tdo) {
    {
#line 910
    result = svf_compare_tdo(priv, sxr_params->params.tdo, sxr_params->params.mask,
                             (priv->dr)->out, loc);
    }
  }
#line 911
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 915
  if (result == 0) {
#line 916
    priv->mismatch_occurred = 1;
  }
#line 918
  return (result);
}
}
#line 939 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/svf/svf.c"
int svf_trst(chain_t *chain , parser_priv_t *priv , int trst_mode ) 
{ 
  int trst_cable ;
  char *unimplemented_mode ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 942
  trst_cable = -1;
#line 945
  if (priv->svf_trst_absent) {
    {
#line 946
    tmp = gettext("Error %s: no further TRST command allowed after mode ABSENT\n");
#line 946
    printf((char const   */* __restrict  */)tmp, "svf");
    }
#line 948
    return (0);
  }
  {
#line 952
  if (trst_mode == 275) {
#line 952
    goto case_275;
  }
#line 955
  if (trst_mode == 276) {
#line 955
    goto case_276;
  }
#line 958
  if (trst_mode == 277) {
#line 958
    goto case_277;
  }
#line 961
  if (trst_mode == 278) {
#line 961
    goto case_278;
  }
#line 976
  goto switch_default;
  case_275: /* CIL Label */ 
#line 953
  trst_cable = 0;
#line 954
  goto switch_break;
  case_276: /* CIL Label */ 
#line 956
  trst_cable = 1;
#line 957
  goto switch_break;
  case_277: /* CIL Label */ 
#line 959
  unimplemented_mode = (char *)"Z";
#line 960
  goto switch_break;
  case_278: /* CIL Label */ 
#line 962
  unimplemented_mode = (char *)"ABSENT";
#line 963
  priv->svf_trst_absent = 1;
#line 965
  if (priv->svf_state_executed) {
    {
#line 966
    tmp___0 = gettext("Error %s: TRST ABSENT must not be issued after a STATE command\n");
#line 966
    printf((char const   */* __restrict  */)tmp___0, "svf");
    }
#line 968
    return (0);
  }
#line 970
  if (priv->sir_params.params.number > 0.0) {
    {
#line 972
    tmp___1 = gettext("Error %s: TRST ABSENT must not be issued after an SIR or SDR command\n");
#line 972
    printf((char const   */* __restrict  */)tmp___1, "svf");
    }
  } else
#line 970
  if (priv->sdr_params.params.number > 0.0) {
    {
#line 972
    tmp___1 = gettext("Error %s: TRST ABSENT must not be issued after an SIR or SDR command\n");
#line 972
    printf((char const   */* __restrict  */)tmp___1, "svf");
    }
  }
#line 975
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 977
  unimplemented_mode = (char *)"UNKNOWN";
#line 978
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 981
  if (trst_cable < 0) {
    {
#line 982
    tmp___2 = gettext("Warning %s: unimplemented mode \'%s\' for TRST\n");
#line 982
    printf((char const   */* __restrict  */)tmp___2, "svf", unimplemented_mode);
    }
  } else {
#line 985
    if (trst_cable) {
#line 985
      tmp___3 = 8;
    } else {
#line 985
      tmp___3 = 0;
    }
    {
#line 985
    cable_set_signal(chain->cable, 8, tmp___3);
    }
  }
#line 987
  return (1);
}
}
#line 1007 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/svf/svf.c"
int svf_txr(enum generic_irdr_coding ir_dr , struct ths_params *params ) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 1010
  if (params->number != 0.0) {
#line 1011
    if ((unsigned int )ir_dr == 0U) {
#line 1011
      tmp = "TIR";
    } else {
#line 1011
      tmp = "TDR";
    }
    {
#line 1011
    tmp___0 = gettext("Warning %s: command %s not implemented\n");
#line 1011
    printf((char const   */* __restrict  */)tmp___0, "svf", tmp);
    }
  }
#line 1014
  return (1);
}
}
#line 1040 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/svf/svf.c"
void svf_run(chain_t *chain , FILE *SVF_FILE , int stop_on_mismatch , int print_progress ,
             uint32_t ref_freq ) 
{ 
  sxr_t sxr_default ;
  parser_priv_t priv ;
  int c ;
  int num_lines ;
  uint32_t old_frequency ;
  uint32_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *register_cmd[4] ;
  int tmp___2 ;
  char *tmp___3 ;
  char *instruction_cmd[5] ;
  char *instruction_string ;
  int len ;
  int result ;
  void *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  uint32_t tmp___9 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;

  {
  {
#line 1044
  sxr_default.params.number = 0.0;
#line 1044
  sxr_default.params.tdi = (char *)((void *)0);
#line 1044
  sxr_default.params.tdo = (char *)((void *)0);
#line 1044
  sxr_default.params.mask = (char *)((void *)0);
#line 1044
  sxr_default.params.smask = (char *)((void *)0);
#line 1044
  sxr_default.no_tdi = 1;
#line 1044
  sxr_default.no_tdo = 1;
#line 1047
  c = ~ -1;
#line 1049
  tmp = cable_get_frequency(chain->cable);
#line 1049
  old_frequency = tmp;
#line 1053
  rewind(SVF_FILE);
#line 1054
  num_lines = 0;
  }
  {
#line 1055
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1055
    if (! (-1 != c)) {
#line 1055
      goto while_break;
    }
    {
#line 1056
    c = fgetc(SVF_FILE);
    }
#line 1057
    if (10 == c) {
#line 1058
      num_lines ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1060
  rewind(SVF_FILE);
  }
#line 1061
  if (0 == num_lines) {
#line 1063
    num_lines ++;
  }
#line 1069
  if ((unsigned long )chain == (unsigned long )((void *)0)) {
    {
#line 1070
    tmp___0 = gettext("Error %s: no JTAG chain available\n");
#line 1070
    printf((char const   */* __restrict  */)tmp___0, "svf");
    }
#line 1071
    return;
  }
#line 1073
  if ((unsigned long )chain->parts == (unsigned long )((void *)0)) {
    {
#line 1074
    tmp___1 = gettext("Error %s: chain without any parts\n");
#line 1074
    printf((char const   */* __restrict  */)tmp___1, "svf");
    }
#line 1075
    return;
  }
  {
#line 1077
  priv.part = *((chain->parts)->parts + chain->active_part);
#line 1080
  priv.dr = part_find_data_register(priv.part, "SDR");
  }
#line 1080
  if (! priv.dr) {
    {
#line 1081
    register_cmd[0] = (char *)"register";
#line 1081
    register_cmd[1] = (char *)"SDR";
#line 1081
    register_cmd[2] = (char *)"32";
#line 1081
    register_cmd[3] = (char *)((void *)0);
#line 1086
    tmp___2 = cmd_run(chain, register_cmd);
    }
#line 1086
    if (tmp___2 < 1) {
#line 1087
      return;
    }
    {
#line 1089
    priv.dr = part_find_data_register(priv.part, "SDR");
    }
#line 1089
    if (! priv.dr) {
      {
#line 1090
      tmp___3 = gettext("Error %s: could not establish SDR register\n");
#line 1090
      printf((char const   */* __restrict  */)tmp___3, "svf");
      }
#line 1091
      return;
    }
  }
  {
#line 1096
  priv.ir = part_find_instruction(priv.part, "SIR");
  }
#line 1096
  if (! priv.ir) {
#line 1097
    instruction_cmd[0] = (char *)"instruction";
#line 1097
    instruction_cmd[1] = (char *)"SIR";
#line 1097
    instruction_cmd[2] = (char *)"";
#line 1097
    instruction_cmd[3] = (char *)"SDR";
#line 1097
    instruction_cmd[4] = (char *)((void *)0);
#line 1105
    len = (priv.part)->instruction_length;
#line 1106
    if (len > 0) {
      {
#line 1107
      tmp___4 = calloc((size_t )(len + 1), (size_t )sizeof(char ));
#line 1107
      instruction_string = (char *)tmp___4;
      }
#line 1107
      if ((unsigned long )instruction_string != (unsigned long )((void *)0)) {
        {
#line 1108
        memset((void *)instruction_string, '1', (size_t )len);
#line 1109
        *(instruction_string + len) = (char )'\000';
#line 1110
        instruction_cmd[2] = instruction_string;
#line 1112
        result = cmd_run(chain, instruction_cmd);
#line 1114
        free((void *)instruction_string);
        }
#line 1116
        if (result < 1) {
#line 1117
          return;
        }
      }
    }
    {
#line 1121
    priv.ir = part_find_instruction(priv.part, "SIR");
    }
#line 1121
    if (! priv.ir) {
      {
#line 1122
      tmp___5 = gettext("Error %s: could not establish SIR instruction\n");
#line 1122
      printf((char const   */* __restrict  */)tmp___5, "svf");
      }
#line 1123
      return;
    }
  }
  {
#line 1128
  priv.svf_stop_on_mismatch = stop_on_mismatch;
#line 1130
  priv.sdr_params = sxr_default;
#line 1130
  priv.sir_params = priv.sdr_params;
#line 1132
  priv.enddr = 1 << 3;
#line 1132
  priv.endir = priv.enddr;
#line 1134
  priv.runtest_end_state = 1 << 3;
#line 1134
  priv.runtest_run_state = priv.runtest_end_state;
#line 1136
  priv.svf_trst_absent = 0;
#line 1137
  priv.svf_state_executed = 0;
#line 1139
  priv.mismatch_occurred = 0;
#line 1142
  priv.issued_runtest_maxtime = 0;
#line 1144
  priv.ref_freq = ref_freq;
#line 1147
  part_set_instruction(priv.part, "SIR");
#line 1149
  tmp___6 = svf_bison_init(& priv, SVF_FILE, num_lines, print_progress);
  }
#line 1149
  if (tmp___6) {
    {
#line 1150
    svfparse(& priv, chain);
#line 1151
    svf_bison_deinit(& priv);
    }
  }
#line 1154
  if (print_progress) {
#line 1155
    if (priv.mismatch_occurred > 0) {
      {
#line 1156
      tmp___7 = gettext("Mismatches occurred between scanned device output and expected TDO values.\n");
#line 1156
      printf((char const   */* __restrict  */)tmp___7);
      }
    } else {
      {
#line 1158
      tmp___8 = gettext("Scanned device output matched expected TDO values.\n");
#line 1158
      printf((char const   */* __restrict  */)tmp___8);
      }
    }
  }
#line 1163
  if (priv.sir_params.params.tdi) {
    {
#line 1164
    free((void *)priv.sir_params.params.tdi);
    }
  }
#line 1165
  if (priv.sir_params.params.mask) {
    {
#line 1166
    free((void *)priv.sir_params.params.mask);
    }
  }
#line 1167
  if (priv.sir_params.params.smask) {
    {
#line 1168
    free((void *)priv.sir_params.params.smask);
    }
  }
#line 1170
  if (priv.sdr_params.params.tdi) {
    {
#line 1171
    free((void *)priv.sdr_params.params.tdi);
    }
  }
#line 1172
  if (priv.sdr_params.params.mask) {
    {
#line 1173
    free((void *)priv.sdr_params.params.mask);
    }
  }
#line 1174
  if (priv.sdr_params.params.smask) {
    {
#line 1175
    free((void *)priv.sdr_params.params.smask);
    }
  }
  {
#line 1178
  tmp___9 = cable_get_frequency(chain->cable);
  }
#line 1178
  if (old_frequency != tmp___9) {
    {
#line 1179
    cable_set_frequency(chain->cable, old_frequency);
    }
  }
#line 1180
  return;
}
}
#line 64 "../../include/part.h"
void part_set_signal(part_t *p , signal_t *s , int out , int val ) ;
#line 65
int part_get_signal(part_t *p , signal_t *s ) ;
#line 57 "../../include/chain.h"
void chain_shift_instructions(chain_t *chain ) ;
#line 59
void chain_shift_data_registers(chain_t *chain , int capture_output ) ;
#line 62 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/buses.h"
struct bus_driver  const  zefant_xs3_bus ;
#line 30 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/generic_bus.h"
int generic_bus_attach_sig(part_t *part , signal_t **sig , char *id ) ;
#line 32
void generic_bus_free(bus_t *bus___0 ) ;
#line 34
void generic_bus_prepare_extest(bus_t *bus___0 ) ;
#line 35
uint32_t generic_bus_read(bus_t *bus___0 , uint32_t adr ) ;
#line 155 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/zefant-xs3.c"
static bus_t *zefant_xs3_bus_new(chain_t *chain , bus_driver_t const   *driver , char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  part_t *part ;
  int failed ;
  component_t *comp ;
  int idx ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  int tmp___74 ;
  int tmp___75 ;
  int tmp___76 ;
  int tmp___77 ;
  int tmp___78 ;
  int tmp___79 ;
  int tmp___80 ;
  int tmp___81 ;
  int tmp___82 ;
  int tmp___83 ;
  int tmp___84 ;
  int tmp___85 ;
  int tmp___86 ;
  int tmp___87 ;
  int tmp___88 ;
  int tmp___89 ;
  int tmp___90 ;
  int tmp___91 ;
  int tmp___92 ;
  int tmp___93 ;
  int tmp___94 ;
  int tmp___95 ;
  int tmp___96 ;
  int tmp___97 ;
  int tmp___98 ;
  int tmp___99 ;
  int tmp___100 ;
  int tmp___101 ;
  int tmp___102 ;
  int tmp___103 ;
  int tmp___104 ;
  int tmp___105 ;
  int tmp___106 ;
  int tmp___107 ;
  int tmp___108 ;
  int tmp___109 ;
  int tmp___110 ;
  int tmp___111 ;
  int tmp___112 ;
  int tmp___113 ;
  int tmp___114 ;
  int tmp___115 ;
  int tmp___116 ;
  int tmp___117 ;
  int tmp___118 ;
  int tmp___119 ;
  int tmp___120 ;
  int tmp___121 ;
  int tmp___122 ;
  int tmp___123 ;
  int tmp___124 ;
  int tmp___125 ;
  int tmp___126 ;
  int tmp___127 ;
  int tmp___128 ;
  char *__cil_tmp139 ;
  char *__cil_tmp140 ;
  char *__cil_tmp141 ;
  char *__cil_tmp142 ;
  char *__cil_tmp143 ;
  char *__cil_tmp144 ;
  char *__cil_tmp145 ;
  char *__cil_tmp146 ;
  char *__cil_tmp147 ;
  char *__cil_tmp148 ;
  char *__cil_tmp149 ;
  char *__cil_tmp150 ;
  char *__cil_tmp151 ;
  char *__cil_tmp152 ;
  char *__cil_tmp153 ;
  char *__cil_tmp154 ;
  char *__cil_tmp155 ;
  char *__cil_tmp156 ;
  char *__cil_tmp157 ;
  char *__cil_tmp158 ;
  char *__cil_tmp159 ;
  char *__cil_tmp160 ;
  char *__cil_tmp161 ;
  char *__cil_tmp162 ;
  char *__cil_tmp163 ;
  char *__cil_tmp164 ;
  char *__cil_tmp165 ;
  char *__cil_tmp166 ;
  char *__cil_tmp167 ;
  char *__cil_tmp168 ;
  char *__cil_tmp169 ;
  char *__cil_tmp170 ;
  char *__cil_tmp171 ;
  char *__cil_tmp172 ;
  char *__cil_tmp173 ;
  char *__cil_tmp174 ;
  char *__cil_tmp175 ;
  char *__cil_tmp176 ;
  char *__cil_tmp177 ;
  char *__cil_tmp178 ;
  char *__cil_tmp179 ;
  char *__cil_tmp180 ;
  char *__cil_tmp181 ;
  char *__cil_tmp182 ;
  char *__cil_tmp183 ;
  char *__cil_tmp184 ;
  char *__cil_tmp185 ;
  char *__cil_tmp186 ;
  char *__cil_tmp187 ;
  char *__cil_tmp188 ;
  char *__cil_tmp189 ;
  char *__cil_tmp190 ;
  char *__cil_tmp191 ;
  char *__cil_tmp192 ;
  char *__cil_tmp193 ;
  char *__cil_tmp194 ;
  char *__cil_tmp195 ;
  char *__cil_tmp196 ;
  char *__cil_tmp197 ;
  char *__cil_tmp198 ;
  char *__cil_tmp199 ;
  char *__cil_tmp200 ;
  char *__cil_tmp201 ;
  char *__cil_tmp202 ;
  char *__cil_tmp203 ;
  char *__cil_tmp204 ;
  char *__cil_tmp205 ;
  char *__cil_tmp206 ;
  char *__cil_tmp207 ;
  char *__cil_tmp208 ;
  char *__cil_tmp209 ;
  char *__cil_tmp210 ;
  char *__cil_tmp211 ;
  char *__cil_tmp212 ;
  char *__cil_tmp213 ;
  char *__cil_tmp214 ;
  char *__cil_tmp215 ;
  char *__cil_tmp216 ;
  char *__cil_tmp217 ;
  char *__cil_tmp218 ;
  char *__cil_tmp219 ;
  char *__cil_tmp220 ;
  char *__cil_tmp221 ;
  char *__cil_tmp222 ;
  char *__cil_tmp223 ;
  char *__cil_tmp224 ;
  char *__cil_tmp225 ;
  char *__cil_tmp226 ;
  char *__cil_tmp227 ;
  char *__cil_tmp228 ;
  char *__cil_tmp229 ;
  char *__cil_tmp230 ;
  char *__cil_tmp231 ;
  char *__cil_tmp232 ;
  char *__cil_tmp233 ;
  char *__cil_tmp234 ;
  char *__cil_tmp235 ;
  char *__cil_tmp236 ;
  char *__cil_tmp237 ;
  char *__cil_tmp238 ;
  char *__cil_tmp239 ;
  char *__cil_tmp240 ;
  char *__cil_tmp241 ;
  char *__cil_tmp242 ;
  char *__cil_tmp243 ;
  char *__cil_tmp244 ;
  char *__cil_tmp245 ;
  char *__cil_tmp246 ;
  char *__cil_tmp247 ;
  char *__cil_tmp248 ;
  char *__cil_tmp249 ;
  char *__cil_tmp250 ;
  char *__cil_tmp251 ;
  char *__cil_tmp252 ;
  char *__cil_tmp253 ;
  char *__cil_tmp254 ;
  char *__cil_tmp255 ;
  char *__cil_tmp256 ;
  char *__cil_tmp257 ;
  char *__cil_tmp258 ;
  char *__cil_tmp259 ;
  char *__cil_tmp260 ;
  char *__cil_tmp261 ;
  char *__cil_tmp262 ;
  char *__cil_tmp263 ;
  char *__cil_tmp264 ;
  char *__cil_tmp265 ;
  char *__cil_tmp266 ;
  char *__cil_tmp267 ;
  char *__cil_tmp268 ;
  char *__cil_tmp269 ;
  char *__cil_tmp270 ;
  char *__cil_tmp271 ;
  char *__cil_tmp272 ;

  {
  {
#line 160
  failed = 0;
#line 164
  tmp = calloc((size_t )1, (size_t )sizeof(bus_t ));
#line 164
  bus___0 = (bus_t *)tmp;
  }
#line 165
  if (! bus___0) {
#line 166
    return ((bus_t *)((void *)0));
  }
  {
#line 168
  bus___0->driver = driver;
#line 169
  bus___0->params = calloc((size_t )1, (size_t )sizeof(bus_params_t ));
  }
#line 170
  if (! bus___0->params) {
    {
#line 171
    free((void *)bus___0);
    }
#line 171
    return ((bus_t *)((void *)0));
  }
  {
#line 175
  bus___0->chain = chain;
#line 176
  part = *((chain->parts)->parts + chain->active_part);
#line 176
  bus___0->part = part;
#line 181
  comp = & ((bus_params_t *)bus___0->params)->flash;
#line 182
  comp->ctype = (ctype_t )1;
#line 183
  comp->cname = (char *)"FLASH";
#line 185
  tmp___0 = generic_bus_attach_sig(part, & comp->a[0], (char *)"IO_V9");
#line 185
  failed |= tmp___0;
#line 186
  tmp___1 = generic_bus_attach_sig(part, & comp->a[1], (char *)"IO_U10");
#line 186
  failed |= tmp___1;
#line 187
  tmp___2 = generic_bus_attach_sig(part, & comp->a[2], (char *)"IO_V10");
#line 187
  failed |= tmp___2;
#line 188
  tmp___3 = generic_bus_attach_sig(part, & comp->a[3], (char *)"IO_W10");
#line 188
  failed |= tmp___3;
#line 189
  tmp___4 = generic_bus_attach_sig(part, & comp->a[4], (char *)"IO_Y10");
#line 189
  failed |= tmp___4;
#line 190
  tmp___5 = generic_bus_attach_sig(part, & comp->a[5], (char *)"IO_W8");
#line 190
  failed |= tmp___5;
#line 191
  tmp___6 = generic_bus_attach_sig(part, & comp->a[6], (char *)"IO_W9");
#line 191
  failed |= tmp___6;
#line 192
  tmp___7 = generic_bus_attach_sig(part, & comp->a[7], (char *)"IO_V8");
#line 192
  failed |= tmp___7;
#line 193
  tmp___8 = generic_bus_attach_sig(part, & comp->a[8], (char *)"IO_V6");
#line 193
  failed |= tmp___8;
#line 194
  tmp___9 = generic_bus_attach_sig(part, & comp->a[9], (char *)"IO_AA8");
#line 194
  failed |= tmp___9;
#line 195
  tmp___10 = generic_bus_attach_sig(part, & comp->a[10], (char *)"IO_AB8");
#line 195
  failed |= tmp___10;
#line 196
  tmp___11 = generic_bus_attach_sig(part, & comp->a[11], (char *)"IO_U7");
#line 196
  failed |= tmp___11;
#line 197
  tmp___12 = generic_bus_attach_sig(part, & comp->a[12], (char *)"IO_V7");
#line 197
  failed |= tmp___12;
#line 198
  tmp___13 = generic_bus_attach_sig(part, & comp->a[13], (char *)"IO_U6");
#line 198
  failed |= tmp___13;
#line 199
  tmp___14 = generic_bus_attach_sig(part, & comp->a[14], (char *)"IO_Y6");
#line 199
  failed |= tmp___14;
#line 200
  tmp___15 = generic_bus_attach_sig(part, & comp->a[15], (char *)"IO_AB11");
#line 200
  failed |= tmp___15;
#line 201
  tmp___16 = generic_bus_attach_sig(part, & comp->a[16], (char *)"IO_AB10");
#line 201
  failed |= tmp___16;
#line 202
  tmp___17 = generic_bus_attach_sig(part, & comp->a[17], (char *)"IO_AA10");
#line 202
  failed |= tmp___17;
#line 203
  tmp___18 = generic_bus_attach_sig(part, & comp->a[18], (char *)"IO_W6");
#line 203
  failed |= tmp___18;
#line 204
  tmp___19 = generic_bus_attach_sig(part, & comp->a[19], (char *)"IO_AA6");
#line 204
  failed |= tmp___19;
#line 205
  tmp___20 = generic_bus_attach_sig(part, & comp->a[20], (char *)"IO_U11");
#line 205
  failed |= tmp___20;
#line 206
  tmp___21 = generic_bus_attach_sig(part, & comp->a[21], (char *)"IO_Y13");
#line 206
  failed |= tmp___21;
#line 207
  tmp___22 = generic_bus_attach_sig(part, & comp->a[22], (char *)"IO_AB13");
#line 207
  failed |= tmp___22;
#line 208
  tmp___23 = generic_bus_attach_sig(part, & comp->a[23], (char *)"IO_U13");
#line 208
  failed |= tmp___23;
#line 209
  tmp___24 = generic_bus_attach_sig(part, & comp->a[24], (char *)"IO_AA13");
#line 209
  failed |= tmp___24;
#line 211
  tmp___25 = generic_bus_attach_sig(part, & comp->d[0], (char *)"IO_AA14");
#line 211
  failed |= tmp___25;
#line 212
  tmp___26 = generic_bus_attach_sig(part, & comp->d[1], (char *)"IO_AB14");
#line 212
  failed |= tmp___26;
#line 213
  tmp___27 = generic_bus_attach_sig(part, & comp->d[2], (char *)"IO_U12");
#line 213
  failed |= tmp___27;
#line 214
  tmp___28 = generic_bus_attach_sig(part, & comp->d[3], (char *)"IO_V12");
#line 214
  failed |= tmp___28;
#line 215
  tmp___29 = generic_bus_attach_sig(part, & comp->d[4], (char *)"IO_W11");
#line 215
  failed |= tmp___29;
#line 216
  tmp___30 = generic_bus_attach_sig(part, & comp->d[5], (char *)"IO_V11");
#line 216
  failed |= tmp___30;
#line 217
  tmp___31 = generic_bus_attach_sig(part, & comp->d[6], (char *)"IO_AB9");
#line 217
  failed |= tmp___31;
#line 218
  tmp___32 = generic_bus_attach_sig(part, & comp->d[7], (char *)"IO_AA9");
#line 218
  failed |= tmp___32;
#line 219
  tmp___33 = generic_bus_attach_sig(part, & comp->d[8], (char *)"IO_U16");
#line 219
  failed |= tmp___33;
#line 220
  tmp___34 = generic_bus_attach_sig(part, & comp->d[9], (char *)"IO_AB15");
#line 220
  failed |= tmp___34;
#line 221
  tmp___35 = generic_bus_attach_sig(part, & comp->d[10], (char *)"IO_AA15");
#line 221
  failed |= tmp___35;
#line 222
  tmp___36 = generic_bus_attach_sig(part, & comp->d[11], (char *)"IO_W14");
#line 222
  failed |= tmp___36;
#line 223
  tmp___37 = generic_bus_attach_sig(part, & comp->d[12], (char *)"IO_V14");
#line 223
  failed |= tmp___37;
#line 224
  tmp___38 = generic_bus_attach_sig(part, & comp->d[13], (char *)"IO_U14");
#line 224
  failed |= tmp___38;
#line 225
  tmp___39 = generic_bus_attach_sig(part, & comp->d[14], (char *)"IO_W13");
#line 225
  failed |= tmp___39;
#line 226
  tmp___40 = generic_bus_attach_sig(part, & comp->d[15], (char *)"IO_V13");
#line 226
  failed |= tmp___40;
#line 228
  tmp___41 = generic_bus_attach_sig(part, & comp->nwe, (char *)"IO_Y17");
#line 228
  failed |= tmp___41;
#line 229
  tmp___42 = generic_bus_attach_sig(part, & comp->noe, (char *)"IO_AA17");
#line 229
  failed |= tmp___42;
#line 230
  tmp___43 = generic_bus_attach_sig(part, & comp->ncs, (char *)"IO_U17");
#line 230
  failed |= tmp___43;
#line 231
  comp->nlb = (signal_t *)((void *)0);
#line 232
  comp->nub = (signal_t *)((void *)0);
#line 234
  tmp___44 = generic_bus_attach_sig(part, & comp->nrp, (char *)"IO_V16");
#line 234
  failed |= tmp___44;
#line 235
  tmp___45 = generic_bus_attach_sig(part, & comp->nbyte, (char *)"IO_Y16");
#line 235
  failed |= tmp___45;
#line 236
  tmp___46 = generic_bus_attach_sig(part, & comp->sts, (char *)"IO_W16");
#line 236
  failed |= tmp___46;
#line 238
  comp->si = (signal_t *)((void *)0);
#line 239
  comp->so = (signal_t *)((void *)0);
#line 240
  comp->sck = (signal_t *)((void *)0);
#line 245
  comp = & ((bus_params_t *)bus___0->params)->ram0;
#line 246
  comp->ctype = (ctype_t )0;
#line 247
  comp->cname = (char *)"RAM0";
#line 249
  tmp___47 = generic_bus_attach_sig(part, & comp->a[0], (char *)"IO_AA4");
#line 249
  failed |= tmp___47;
#line 250
  tmp___48 = generic_bus_attach_sig(part, & comp->a[1], (char *)"IO_AB4");
#line 250
  failed |= tmp___48;
#line 251
  tmp___49 = generic_bus_attach_sig(part, & comp->a[2], (char *)"IO_W5");
#line 251
  failed |= tmp___49;
#line 252
  tmp___50 = generic_bus_attach_sig(part, & comp->a[3], (char *)"IO_Y3");
#line 252
  failed |= tmp___50;
#line 253
  tmp___51 = generic_bus_attach_sig(part, & comp->a[4], (char *)"IO_Y1");
#line 253
  failed |= tmp___51;
#line 254
  tmp___52 = generic_bus_attach_sig(part, & comp->a[5], (char *)"IO_M1");
#line 254
  failed |= tmp___52;
#line 255
  tmp___53 = generic_bus_attach_sig(part, & comp->a[6], (char *)"IO_N2");
#line 255
  failed |= tmp___53;
#line 256
  tmp___54 = generic_bus_attach_sig(part, & comp->a[7], (char *)"IO_L2");
#line 256
  failed |= tmp___54;
#line 257
  tmp___55 = generic_bus_attach_sig(part, & comp->a[8], (char *)"IO_L1");
#line 257
  failed |= tmp___55;
#line 258
  tmp___56 = generic_bus_attach_sig(part, & comp->a[9], (char *)"IO_K1");
#line 258
  failed |= tmp___56;
#line 259
  tmp___57 = generic_bus_attach_sig(part, & comp->a[10], (char *)"IO_K3");
#line 259
  failed |= tmp___57;
#line 260
  tmp___58 = generic_bus_attach_sig(part, & comp->a[11], (char *)"IO_L6");
#line 260
  failed |= tmp___58;
#line 261
  tmp___59 = generic_bus_attach_sig(part, & comp->a[12], (char *)"IO_L4");
#line 261
  failed |= tmp___59;
#line 262
  tmp___60 = generic_bus_attach_sig(part, & comp->a[13], (char *)"IO_L3");
#line 262
  failed |= tmp___60;
#line 263
  tmp___61 = generic_bus_attach_sig(part, & comp->a[14], (char *)"IO_K4");
#line 263
  failed |= tmp___61;
#line 264
  tmp___62 = generic_bus_attach_sig(part, & comp->a[15], (char *)"IO_AB5");
#line 264
  failed |= tmp___62;
#line 265
  tmp___63 = generic_bus_attach_sig(part, & comp->a[16], (char *)"IO_AA5");
#line 265
  failed |= tmp___63;
#line 266
  tmp___64 = generic_bus_attach_sig(part, & comp->a[17], (char *)"IO_Y5");
#line 266
  failed |= tmp___64;
#line 267
  comp->a[18] = (signal_t *)((void *)0);
#line 268
  comp->a[19] = (signal_t *)((void *)0);
#line 269
  comp->a[20] = (signal_t *)((void *)0);
#line 270
  comp->a[21] = (signal_t *)((void *)0);
#line 271
  comp->a[22] = (signal_t *)((void *)0);
#line 272
  comp->a[23] = (signal_t *)((void *)0);
#line 273
  comp->a[24] = (signal_t *)((void *)0);
#line 275
  tmp___65 = generic_bus_attach_sig(part, & comp->d[0], (char *)"IO_W1");
#line 275
  failed |= tmp___65;
#line 276
  tmp___66 = generic_bus_attach_sig(part, & comp->d[1], (char *)"IO_V5");
#line 276
  failed |= tmp___66;
#line 277
  tmp___67 = generic_bus_attach_sig(part, & comp->d[2], (char *)"IO_V3");
#line 277
  failed |= tmp___67;
#line 278
  tmp___68 = generic_bus_attach_sig(part, & comp->d[3], (char *)"IO_V1");
#line 278
  failed |= tmp___68;
#line 279
  tmp___69 = generic_bus_attach_sig(part, & comp->d[4], (char *)"IO_N1");
#line 279
  failed |= tmp___69;
#line 280
  tmp___70 = generic_bus_attach_sig(part, & comp->d[5], (char *)"IO_N3");
#line 280
  failed |= tmp___70;
#line 281
  tmp___71 = generic_bus_attach_sig(part, & comp->d[6], (char *)"IO_M2");
#line 281
  failed |= tmp___71;
#line 282
  tmp___72 = generic_bus_attach_sig(part, & comp->d[7], (char *)"IO_M5");
#line 282
  failed |= tmp___72;
#line 283
  tmp___73 = generic_bus_attach_sig(part, & comp->d[8], (char *)"IO_M4");
#line 283
  failed |= tmp___73;
#line 284
  tmp___74 = generic_bus_attach_sig(part, & comp->d[9], (char *)"IO_M6");
#line 284
  failed |= tmp___74;
#line 285
  tmp___75 = generic_bus_attach_sig(part, & comp->d[10], (char *)"IO_L5");
#line 285
  failed |= tmp___75;
#line 286
  tmp___76 = generic_bus_attach_sig(part, & comp->d[11], (char *)"IO_N4");
#line 286
  failed |= tmp___76;
#line 287
  tmp___77 = generic_bus_attach_sig(part, & comp->d[12], (char *)"IO_T6");
#line 287
  failed |= tmp___77;
#line 288
  tmp___78 = generic_bus_attach_sig(part, & comp->d[13], (char *)"IO_V2");
#line 288
  failed |= tmp___78;
#line 289
  tmp___79 = generic_bus_attach_sig(part, & comp->d[14], (char *)"IO_V4");
#line 289
  failed |= tmp___79;
#line 290
  tmp___80 = generic_bus_attach_sig(part, & comp->d[15], (char *)"IO_U5");
#line 290
  failed |= tmp___80;
#line 292
  tmp___81 = generic_bus_attach_sig(part, & comp->ncs, (char *)"IO_W3");
#line 292
  failed |= tmp___81;
#line 293
  tmp___82 = generic_bus_attach_sig(part, & comp->noe, (char *)"IO_Y2");
#line 293
  failed |= tmp___82;
#line 294
  tmp___83 = generic_bus_attach_sig(part, & comp->nwe, (char *)"IO_M3");
#line 294
  failed |= tmp___83;
#line 295
  tmp___84 = generic_bus_attach_sig(part, & comp->nlb, (char *)"IO_W2");
#line 295
  failed |= tmp___84;
#line 296
  tmp___85 = generic_bus_attach_sig(part, & comp->nub, (char *)"IO_W4");
#line 296
  failed |= tmp___85;
#line 297
  comp->nrp = (signal_t *)((void *)0);
#line 298
  comp->nbyte = (signal_t *)((void *)0);
#line 299
  comp->sts = (signal_t *)((void *)0);
#line 301
  comp->si = (signal_t *)((void *)0);
#line 302
  comp->so = (signal_t *)((void *)0);
#line 303
  comp->sck = (signal_t *)((void *)0);
#line 308
  comp = & ((bus_params_t *)bus___0->params)->ram1;
#line 309
  comp->ctype = (ctype_t )0;
#line 310
  comp->cname = (char *)"RAM1";
#line 312
  tmp___86 = generic_bus_attach_sig(part, & comp->a[0], (char *)"IO_H5");
#line 312
  failed |= tmp___86;
#line 313
  tmp___87 = generic_bus_attach_sig(part, & comp->a[1], (char *)"IO_F5");
#line 313
  failed |= tmp___87;
#line 314
  tmp___88 = generic_bus_attach_sig(part, & comp->a[2], (char *)"IO_F2");
#line 314
  failed |= tmp___88;
#line 315
  tmp___89 = generic_bus_attach_sig(part, & comp->a[3], (char *)"IO_D1");
#line 315
  failed |= tmp___89;
#line 316
  tmp___90 = generic_bus_attach_sig(part, & comp->a[4], (char *)"IO_E1");
#line 316
  failed |= tmp___90;
#line 317
  tmp___91 = generic_bus_attach_sig(part, & comp->a[5], (char *)"IO_F10");
#line 317
  failed |= tmp___91;
#line 318
  tmp___92 = generic_bus_attach_sig(part, & comp->a[6], (char *)"IO_C7");
#line 318
  failed |= tmp___92;
#line 319
  tmp___93 = generic_bus_attach_sig(part, & comp->a[7], (char *)"IO_C10");
#line 319
  failed |= tmp___93;
#line 320
  tmp___94 = generic_bus_attach_sig(part, & comp->a[8], (char *)"IO_A10");
#line 320
  failed |= tmp___94;
#line 321
  tmp___95 = generic_bus_attach_sig(part, & comp->a[9], (char *)"IO_B10");
#line 321
  failed |= tmp___95;
#line 322
  tmp___96 = generic_bus_attach_sig(part, & comp->a[10], (char *)"IO_F11");
#line 322
  failed |= tmp___96;
#line 323
  tmp___97 = generic_bus_attach_sig(part, & comp->a[11], (char *)"IO_A9");
#line 323
  failed |= tmp___97;
#line 324
  tmp___98 = generic_bus_attach_sig(part, & comp->a[12], (char *)"IO_B9");
#line 324
  failed |= tmp___98;
#line 325
  tmp___99 = generic_bus_attach_sig(part, & comp->a[13], (char *)"IO_B8");
#line 325
  failed |= tmp___99;
#line 326
  tmp___100 = generic_bus_attach_sig(part, & comp->a[14], (char *)"IO_F9");
#line 326
  failed |= tmp___100;
#line 327
  tmp___101 = generic_bus_attach_sig(part, & comp->a[15], (char *)"IO_F4");
#line 327
  failed |= tmp___101;
#line 328
  tmp___102 = generic_bus_attach_sig(part, & comp->a[16], (char *)"IO_G6");
#line 328
  failed |= tmp___102;
#line 329
  tmp___103 = generic_bus_attach_sig(part, & comp->a[17], (char *)"IO_G5");
#line 329
  failed |= tmp___103;
#line 330
  comp->a[18] = (signal_t *)((void *)0);
#line 331
  comp->a[19] = (signal_t *)((void *)0);
#line 332
  comp->a[20] = (signal_t *)((void *)0);
#line 333
  comp->a[21] = (signal_t *)((void *)0);
#line 334
  comp->a[22] = (signal_t *)((void *)0);
#line 335
  comp->a[23] = (signal_t *)((void *)0);
#line 336
  comp->a[24] = (signal_t *)((void *)0);
#line 338
  tmp___104 = generic_bus_attach_sig(part, & comp->d[0], (char *)"IO_C1");
#line 338
  failed |= tmp___104;
#line 339
  tmp___105 = generic_bus_attach_sig(part, & comp->d[1], (char *)"IO_E2");
#line 339
  failed |= tmp___105;
#line 340
  tmp___106 = generic_bus_attach_sig(part, & comp->d[2], (char *)"IO_C2");
#line 340
  failed |= tmp___106;
#line 341
  tmp___107 = generic_bus_attach_sig(part, & comp->d[3], (char *)"IO_C3");
#line 341
  failed |= tmp___107;
#line 342
  tmp___108 = generic_bus_attach_sig(part, & comp->d[4], (char *)"IO_B5");
#line 342
  failed |= tmp___108;
#line 343
  tmp___109 = generic_bus_attach_sig(part, & comp->d[5], (char *)"IO_A5");
#line 343
  failed |= tmp___109;
#line 344
  tmp___110 = generic_bus_attach_sig(part, & comp->d[6], (char *)"IO_B6");
#line 344
  failed |= tmp___110;
#line 345
  tmp___111 = generic_bus_attach_sig(part, & comp->d[7], (char *)"IO_D7");
#line 345
  failed |= tmp___111;
#line 346
  tmp___112 = generic_bus_attach_sig(part, & comp->d[8], (char *)"IO_D9");
#line 346
  failed |= tmp___112;
#line 347
  tmp___113 = generic_bus_attach_sig(part, & comp->d[9], (char *)"IO_E9");
#line 347
  failed |= tmp___113;
#line 348
  tmp___114 = generic_bus_attach_sig(part, & comp->d[10], (char *)"IO_F7");
#line 348
  failed |= tmp___114;
#line 349
  tmp___115 = generic_bus_attach_sig(part, & comp->d[11], (char *)"IO_E7");
#line 349
  failed |= tmp___115;
#line 350
  tmp___116 = generic_bus_attach_sig(part, & comp->d[12], (char *)"IO_D5");
#line 350
  failed |= tmp___116;
#line 351
  tmp___117 = generic_bus_attach_sig(part, & comp->d[13], (char *)"IO_C4");
#line 351
  failed |= tmp___117;
#line 352
  tmp___118 = generic_bus_attach_sig(part, & comp->d[14], (char *)"IO_D3");
#line 352
  failed |= tmp___118;
#line 353
  tmp___119 = generic_bus_attach_sig(part, & comp->d[15], (char *)"IO_D4");
#line 353
  failed |= tmp___119;
#line 355
  tmp___120 = generic_bus_attach_sig(part, & comp->ncs, (char *)"IO_D2");
#line 355
  failed |= tmp___120;
#line 356
  tmp___121 = generic_bus_attach_sig(part, & comp->noe, (char *)"IO_F3");
#line 356
  failed |= tmp___121;
#line 357
  tmp___122 = generic_bus_attach_sig(part, & comp->nwe, (char *)"IO_E10");
#line 357
  failed |= tmp___122;
#line 358
  tmp___123 = generic_bus_attach_sig(part, & comp->nlb, (char *)"IO_E4");
#line 358
  failed |= tmp___123;
#line 359
  tmp___124 = generic_bus_attach_sig(part, & comp->nub, (char *)"IO_E3");
#line 359
  failed |= tmp___124;
#line 360
  comp->nrp = (signal_t *)((void *)0);
#line 361
  comp->nbyte = (signal_t *)((void *)0);
#line 362
  comp->sts = (signal_t *)((void *)0);
#line 364
  comp->si = (signal_t *)((void *)0);
#line 365
  comp->so = (signal_t *)((void *)0);
#line 366
  comp->sck = (signal_t *)((void *)0);
#line 371
  comp = & ((bus_params_t *)bus___0->params)->eeprom;
#line 372
  comp->ctype = (ctype_t )2;
#line 373
  comp->cname = (char *)"EEPROM";
#line 375
  tmp___125 = generic_bus_attach_sig(part, & comp->si, (char *)"IO_H19");
#line 375
  failed |= tmp___125;
#line 376
  tmp___126 = generic_bus_attach_sig(part, & comp->so, (char *)"IO_J21");
#line 376
  failed |= tmp___126;
#line 377
  tmp___127 = generic_bus_attach_sig(part, & comp->sck, (char *)"IO_H21");
#line 377
  failed |= tmp___127;
#line 378
  tmp___128 = generic_bus_attach_sig(part, & comp->ncs, (char *)"IO_K22");
#line 378
  failed |= tmp___128;
#line 380
  idx = 0;
  }
  {
#line 380
  while (1) {
    while_continue: /* CIL Label */ ;
#line 380
    if (! (idx < 25)) {
#line 380
      goto while_break;
    }
#line 381
    comp->a[idx] = (signal_t *)((void *)0);
#line 380
    idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 382
  idx = 0;
  {
#line 382
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 382
    if (! (idx < 16)) {
#line 382
      goto while_break___0;
    }
#line 383
    comp->d[idx] = (signal_t *)((void *)0);
#line 382
    idx ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 384
  comp->noe = (signal_t *)((void *)0);
#line 385
  comp->nwe = (signal_t *)((void *)0);
#line 386
  comp->nlb = (signal_t *)((void *)0);
#line 387
  comp->nub = (signal_t *)((void *)0);
#line 388
  comp->nrp = (signal_t *)((void *)0);
#line 389
  comp->nbyte = (signal_t *)((void *)0);
#line 390
  comp->sts = (signal_t *)((void *)0);
#line 396
  ((bus_params_t *)bus___0->params)->eeprom_status = ((bus_params_t *)bus___0->params)->eeprom;
#line 397
  comp = & ((bus_params_t *)bus___0->params)->eeprom_status;
#line 398
  comp->ctype = (ctype_t )3;
#line 399
  comp->cname = (char *)"EEPROM Status";
#line 402
  if (failed) {
    {
#line 403
    free(bus___0->params);
#line 404
    free((void *)bus___0);
    }
#line 405
    return ((bus_t *)((void *)0));
  }
#line 408
  return (bus___0);
}
}
#line 415 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/zefant-xs3.c"
static void zefant_xs3_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;
  char *__cil_tmp4 ;

  {
#line 420
  i = 0;
  {
#line 420
  while (1) {
    while_continue: /* CIL Label */ ;
#line 420
    if (! (i < ((bus___0->chain)->parts)->len)) {
#line 420
      goto while_break;
    }
#line 421
    if ((unsigned long )bus___0->part == (unsigned long )*(((bus___0->chain)->parts)->parts + i)) {
#line 422
      goto while_break;
    }
#line 420
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 423
  tmp = gettext("Simple Solutions Zefant-XS3 Board compatible bus driver via BSR (JTAG part No. %d)\n");
#line 423
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 424
  return;
}
}
#line 426 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/zefant-xs3.c"
static void setup_address(bus_t *bus___0 , uint32_t a , component_t *comp ) 
{ 
  int i ;
  part_t *p ;
  int addr_width ;

  {
#line 430
  p = bus___0->part;
#line 433
  ((bus_params_t *)bus___0->params)->last_addr = a;
  {
#line 436
  if ((unsigned int )comp->ctype == 1U) {
#line 436
    goto case_1;
  }
#line 441
  if ((unsigned int )comp->ctype == 0U) {
#line 441
    goto case_0;
  }
#line 448
  if ((unsigned int )comp->ctype == 3U) {
#line 448
    goto case_3;
  }
#line 448
  if ((unsigned int )comp->ctype == 2U) {
#line 448
    goto case_3;
  }
#line 451
  goto switch_default;
  case_1: /* CIL Label */ 
#line 437
  addr_width = 25;
#line 440
  goto switch_break;
  case_0: /* CIL Label */ 
#line 442
  addr_width = 18;
#line 445
  a >>= 1;
#line 446
  goto switch_break;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 449
  addr_width = 16;
#line 450
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 452
  addr_width = 0;
#line 453
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 456
  i = 0;
  {
#line 456
  while (1) {
    while_continue: /* CIL Label */ ;
#line 456
    if (! (i < addr_width)) {
#line 456
      goto while_break;
    }
    {
#line 457
    part_set_signal(p, comp->a[i], 1, (int )((a >> i) & 1U));
#line 456
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 458
  return;
}
}
#line 460 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/zefant-xs3.c"
static int detect_data_width(component_t *comp ) 
{ 
  int width ;

  {
  {
#line 466
  if ((unsigned int )comp->ctype == 0U) {
#line 466
    goto case_0;
  }
#line 469
  if ((unsigned int )comp->ctype == 1U) {
#line 469
    goto case_1;
  }
#line 473
  if ((unsigned int )comp->ctype == 3U) {
#line 473
    goto case_3;
  }
#line 473
  if ((unsigned int )comp->ctype == 2U) {
#line 473
    goto case_3;
  }
#line 476
  goto switch_default;
  case_0: /* CIL Label */ 
#line 467
  width = 16;
#line 468
  goto switch_break;
  case_1: /* CIL Label */ 
#line 470
  width = 16;
#line 471
  goto switch_break;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 474
  width = 8;
#line 475
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 477
  width = 0;
#line 478
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 481
  return (width);
}
}
#line 484 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/zefant-xs3.c"
static void set_data_in(bus_t *bus___0 , component_t *comp ) 
{ 
  int i ;
  part_t *p ;
  int width ;

  {
  {
#line 488
  p = bus___0->part;
#line 491
  width = detect_data_width(comp);
#line 493
  i = 0;
  }
  {
#line 493
  while (1) {
    while_continue: /* CIL Label */ ;
#line 493
    if (! (i < width)) {
#line 493
      goto while_break;
    }
    {
#line 494
    part_set_signal(p, comp->d[i], 0, 0);
#line 493
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 495
  return;
}
}
#line 497 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/zefant-xs3.c"
static void setup_data(bus_t *bus___0 , uint32_t d , component_t *comp ) 
{ 
  int i ;
  part_t *p ;
  int width ;

  {
  {
#line 501
  p = bus___0->part;
#line 504
  width = detect_data_width(comp);
#line 506
  i = 0;
  }
  {
#line 506
  while (1) {
    while_continue: /* CIL Label */ ;
#line 506
    if (! (i < width)) {
#line 506
      goto while_break;
    }
    {
#line 507
    part_set_signal(p, comp->d[i], 1, (int )((d >> i) & 1U));
#line 506
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 508
  return;
}
}
#line 510 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/zefant-xs3.c"
static uint8_t eeprom_shift_byte(chain_t *chain , part_t *p , component_t *comp ,
                                 uint8_t byte ) 
{ 
  int pos ;
  uint8_t so_data ;
  int tmp ;

  {
#line 514
  so_data = (uint8_t )0;
#line 516
  pos = 7;
  {
#line 516
  while (1) {
    while_continue: /* CIL Label */ ;
#line 516
    if (! (pos >= 0)) {
#line 516
      goto while_break;
    }
    {
#line 518
    part_set_signal(p, comp->sck, 1, 0);
#line 520
    part_set_signal(p, comp->si, 1, ((int )byte >> pos) & 1);
#line 522
    chain_shift_data_registers(chain, 1);
#line 525
    part_set_signal(p, comp->sck, 1, 1);
#line 527
    chain_shift_data_registers(chain, 1);
#line 530
    tmp = part_get_signal(p, comp->so);
#line 530
    so_data = (uint8_t )((int )so_data | (int )((uint8_t )(tmp << pos)));
#line 516
    pos --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 533
  return (so_data);
}
}
#line 536 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/zefant-xs3.c"
static void eeprom_disable_device(chain_t *chain , part_t *p , component_t *comp ) 
{ 


  {
  {
#line 540
  part_set_signal(p, comp->sck, 1, 0);
#line 541
  chain_shift_data_registers(chain, 0);
#line 544
  part_set_signal(p, comp->ncs, 1, 1);
#line 545
  chain_shift_data_registers(chain, 0);
  }
#line 546
  return;
}
}
#line 552 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/zefant-xs3.c"
static int zefant_xs3_bus_init(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain ;
  component_t *comp ;
  int tmp ;
  char *__cil_tmp6 ;

  {
  {
#line 555
  p = bus___0->part;
#line 556
  chain = bus___0->chain;
#line 559
  tmp = tap_state(chain);
  }
#line 559
  if (tmp != 1 << 3) {
#line 564
    return (0);
  }
  {
#line 569
  part_set_instruction(p, "SAMPLE/PRELOAD");
#line 570
  chain_shift_instructions(chain);
#line 573
  comp = & ((bus_params_t *)bus___0->params)->flash;
#line 574
  setup_data(bus___0, (uint32_t )0, comp);
#line 575
  part_set_signal(p, comp->ncs, 1, 1);
#line 576
  part_set_signal(p, comp->nwe, 1, 1);
#line 577
  part_set_signal(p, comp->noe, 1, 1);
#line 578
  part_set_signal(p, comp->nrp, 1, 1);
#line 579
  part_set_signal(p, comp->nbyte, 1, 1);
#line 580
  part_set_signal(p, comp->sts, 0, 0);
#line 583
  comp = & ((bus_params_t *)bus___0->params)->ram0;
#line 584
  setup_data(bus___0, (uint32_t )0, comp);
#line 585
  part_set_signal(p, comp->ncs, 1, 1);
#line 586
  part_set_signal(p, comp->nwe, 1, 1);
#line 587
  part_set_signal(p, comp->noe, 1, 1);
#line 588
  part_set_signal(p, comp->nlb, 1, 1);
#line 589
  part_set_signal(p, comp->nub, 1, 1);
#line 592
  comp = & ((bus_params_t *)bus___0->params)->ram1;
#line 593
  setup_data(bus___0, (uint32_t )0, comp);
#line 594
  part_set_signal(p, comp->ncs, 1, 1);
#line 595
  part_set_signal(p, comp->nwe, 1, 1);
#line 596
  part_set_signal(p, comp->noe, 1, 1);
#line 597
  part_set_signal(p, comp->nlb, 1, 1);
#line 598
  part_set_signal(p, comp->nub, 1, 1);
#line 601
  comp = & ((bus_params_t *)bus___0->params)->eeprom;
#line 602
  part_set_signal(p, comp->si, 1, 0);
#line 603
  part_set_signal(p, comp->so, 0, 0);
#line 604
  part_set_signal(p, comp->sck, 1, 0);
#line 605
  part_set_signal(p, comp->ncs, 1, 1);
#line 608
  comp = & ((bus_params_t *)bus___0->params)->eeprom_status;
#line 609
  part_set_signal(p, comp->si, 1, 0);
#line 610
  part_set_signal(p, comp->so, 0, 0);
#line 611
  part_set_signal(p, comp->sck, 1, 0);
#line 612
  part_set_signal(p, comp->ncs, 1, 1);
#line 614
  chain_shift_data_registers(chain, 0);
#line 616
  bus___0->initialized = 1;
  }
#line 618
  return (0);
}
}
#line 621 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/zefant-xs3.c"
static int comp_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area___0 , component_t **comp ) 
{ 
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 624
  if (adr < (uint32_t )(1 << 25)) {
#line 625
    area___0->description = "FLASH Component";
#line 626
    area___0->start = (uint32_t )0;
#line 627
    area___0->length = (uint64_t )(1 << 25);
#line 628
    area___0->width = 16U;
#line 629
    *comp = & ((bus_params_t *)bus___0->params)->flash;
  } else
#line 630
  if (adr < (uint32_t )((1 << 25) + (1 << 19))) {
#line 631
    area___0->description = "SO-DIMM RAM0 Component";
#line 632
    area___0->start = (uint32_t )(1 << 25);
#line 633
    area___0->length = (uint64_t )(1 << 19);
#line 634
    area___0->width = 16U;
#line 635
    *comp = & ((bus_params_t *)bus___0->params)->ram0;
  } else
#line 636
  if (adr < (uint32_t )(((1 << 25) + (1 << 19)) + (1 << 19))) {
#line 637
    area___0->description = "SO-DIMM RAM1 Component";
#line 638
    area___0->start = (uint32_t )((1 << 25) + (1 << 19));
#line 639
    area___0->length = (uint64_t )(1 << 19);
#line 640
    area___0->width = 16U;
#line 641
    *comp = & ((bus_params_t *)bus___0->params)->ram1;
  } else
#line 642
  if (adr < (uint32_t )((((1 << 25) + (1 << 19)) + (1 << 19)) + (1 << 16))) {
#line 643
    area___0->description = "EEPROM Component";
#line 644
    area___0->start = (uint32_t )(((1 << 25) + (1 << 19)) + (1 << 19));
#line 645
    area___0->length = (uint64_t )(1 << 16);
#line 646
    area___0->width = 8U;
#line 647
    *comp = & ((bus_params_t *)bus___0->params)->eeprom;
  } else
#line 648
  if (adr < (uint32_t )(((((1 << 25) + (1 << 19)) + (1 << 19)) + (1 << 16)) + 3)) {
#line 649
    area___0->description = "EEPROM Component Status";
#line 650
    area___0->start = (uint32_t )((((1 << 25) + (1 << 19)) + (1 << 19)) + (1 << 16));
#line 651
    area___0->length = (uint64_t )(1 << 16);
#line 652
    area___0->width = 8U;
#line 653
    *comp = & ((bus_params_t *)bus___0->params)->eeprom_status;
  } else {
#line 655
    area___0->description = "Dummy";
#line 656
    area___0->start = (uint32_t )(((1 << 25) + 2 * (1 << 19)) + 2 * (1 << 16));
#line 657
    area___0->length = 4294967296ULL;
#line 658
    area___0->width = 0U;
#line 659
    *comp = (component_t *)((void *)0);
  }
#line 662
  return (0);
}
}
#line 669 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/zefant-xs3.c"
static int zefant_xs3_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area___0 ) 
{ 
  component_t *comp ;
  int tmp ;

  {
  {
#line 674
  tmp = comp_bus_area(bus___0, adr, area___0, & comp);
  }
#line 674
  return (tmp);
}
}
#line 681 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/zefant-xs3.c"
static void zefant_xs3_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;
  bus_area_t area___0 ;
  component_t *comp ;
  uint8_t cmd ;
  char *tmp ;
  char *tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 684
  p = bus___0->part;
#line 685
  chain = bus___0->chain;
#line 688
  cmd = (uint8_t )3;
#line 690
  comp_bus_area(bus___0, adr, & area___0, & comp);
  }
#line 691
  if (! comp) {
    {
#line 692
    tmp = gettext("Address out of range\n");
#line 692
    printf((char const   */* __restrict  */)tmp);
#line 693
    ((bus_params_t *)bus___0->params)->last_addr = adr;
    }
#line 694
    return;
  }
  {
#line 700
  if ((unsigned int )comp->ctype == 0U) {
#line 700
    goto case_0;
  }
#line 700
  if ((unsigned int )comp->ctype == 1U) {
#line 700
    goto case_0;
  }
#line 716
  if ((unsigned int )comp->ctype == 3U) {
#line 716
    goto case_3;
  }
#line 719
  if ((unsigned int )comp->ctype == 2U) {
#line 719
    goto case_2;
  }
#line 736
  goto switch_default;
  case_0: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 701
  part_set_signal(p, comp->ncs, 1, 0);
#line 702
  part_set_signal(p, comp->nwe, 1, 1);
#line 703
  part_set_signal(p, comp->noe, 1, 0);
  }
#line 704
  if ((unsigned int )comp->ctype == 0U) {
    {
#line 705
    part_set_signal(p, comp->nlb, 1, 0);
#line 706
    part_set_signal(p, comp->nub, 1, 0);
    }
  }
  {
#line 709
  setup_address(bus___0, adr, comp);
#line 710
  set_data_in(bus___0, comp);
#line 712
  chain_shift_data_registers(chain, 0);
  }
#line 714
  goto switch_break;
  case_3: /* CIL Label */ 
#line 717
  cmd = (uint8_t )5;
  case_2: /* CIL Label */ 
  {
#line 721
  part_set_signal(p, comp->ncs, 1, 0);
#line 724
  eeprom_shift_byte(chain, p, comp, cmd);
  }
#line 726
  if ((unsigned int )comp->ctype == 2U) {
    {
#line 728
    eeprom_shift_byte(chain, p, comp, (uint8_t )((adr >> 8) & 255U));
#line 730
    eeprom_shift_byte(chain, p, comp, (uint8_t )(adr & 255U));
    }
  }
#line 733
  ((bus_params_t *)bus___0->params)->last_addr = adr;
#line 734
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 737
  tmp___0 = gettext("Component type not supported\n");
#line 737
  printf((char const   */* __restrict  */)tmp___0);
  }
#line 738
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 741
  return;
}
}
#line 747 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/zefant-xs3.c"
static uint32_t zefant_xs3_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  bus_area_t area___0 ;
  component_t *comp ;
  char *tmp ;
  int tmp___0 ;
  uint8_t tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 750
  p = bus___0->part;
#line 751
  chain = bus___0->chain;
#line 753
  d = (uint32_t )0;
#line 757
  comp_bus_area(bus___0, adr, & area___0, & comp);
  }
#line 758
  if (! comp) {
    {
#line 759
    tmp = gettext("Address out of range\n");
#line 759
    printf((char const   */* __restrict  */)tmp);
#line 760
    ((bus_params_t *)bus___0->params)->last_addr = adr;
    }
#line 761
    return ((uint32_t )0);
  }
  {
#line 767
  if ((unsigned int )comp->ctype == 0U) {
#line 767
    goto case_0;
  }
#line 767
  if ((unsigned int )comp->ctype == 1U) {
#line 767
    goto case_0;
  }
#line 777
  if ((unsigned int )comp->ctype == 2U) {
#line 777
    goto case_2;
  }
#line 777
  if ((unsigned int )comp->ctype == 3U) {
#line 777
    goto case_2;
  }
#line 782
  goto switch_default;
  case_0: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 768
  setup_address(bus___0, adr, comp);
#line 769
  chain_shift_data_registers(chain, 1);
#line 771
  i = 0;
  }
  {
#line 771
  while (1) {
    while_continue: /* CIL Label */ ;
#line 771
    if (! ((unsigned int )i < area___0.width)) {
#line 771
      goto while_break;
    }
    {
#line 772
    tmp___0 = part_get_signal(p, comp->d[i]);
#line 772
    d |= (uint32_t )(tmp___0 << i);
#line 771
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 774
  goto switch_break;
  case_2: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 779
  tmp___1 = eeprom_shift_byte(chain, p, comp, (uint8_t )0);
#line 779
  d = (uint32_t )tmp___1;
  }
#line 780
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 783
  tmp___2 = gettext("Component type not supported\n");
#line 783
  printf((char const   */* __restrict  */)tmp___2);
  }
#line 784
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 787
  return (d);
}
}
#line 794 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/zefant-xs3.c"
static uint32_t zefant_xs3_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  bus_area_t area___0 ;
  component_t *comp ;
  char *tmp ;
  int tmp___0 ;
  uint8_t tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 797
  p = bus___0->part;
#line 798
  chain = bus___0->chain;
#line 800
  d = (uint32_t )0;
#line 805
  comp_bus_area(bus___0, ((bus_params_t *)bus___0->params)->last_addr, & area___0,
                & comp);
  }
#line 806
  if (! comp) {
    {
#line 807
    tmp = gettext("Address out of range\n");
#line 807
    printf((char const   */* __restrict  */)tmp);
    }
#line 808
    return ((uint32_t )0);
  }
  {
#line 814
  if ((unsigned int )comp->ctype == 0U) {
#line 814
    goto case_0;
  }
#line 814
  if ((unsigned int )comp->ctype == 1U) {
#line 814
    goto case_0;
  }
#line 829
  if ((unsigned int )comp->ctype == 2U) {
#line 829
    goto case_2;
  }
#line 829
  if ((unsigned int )comp->ctype == 3U) {
#line 829
    goto case_2;
  }
#line 836
  goto switch_default;
  case_0: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 815
  part_set_signal(p, comp->ncs, 1, 1);
#line 816
  part_set_signal(p, comp->noe, 1, 1);
  }
#line 817
  if ((unsigned int )comp->ctype == 0U) {
    {
#line 818
    part_set_signal(p, comp->nlb, 1, 1);
#line 819
    part_set_signal(p, comp->nub, 1, 1);
    }
  }
  {
#line 821
  chain_shift_data_registers(chain, 1);
#line 823
  i = 0;
  }
  {
#line 823
  while (1) {
    while_continue: /* CIL Label */ ;
#line 823
    if (! ((unsigned int )i < area___0.width)) {
#line 823
      goto while_break;
    }
    {
#line 824
    tmp___0 = part_get_signal(p, comp->d[i]);
#line 824
    d |= (uint32_t )(tmp___0 << i);
#line 823
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 826
  goto switch_break;
  case_2: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 831
  tmp___1 = eeprom_shift_byte(chain, p, comp, (uint8_t )0);
#line 831
  d = (uint32_t )tmp___1;
#line 832
  eeprom_disable_device(chain, p, comp);
  }
#line 834
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 837
  tmp___2 = gettext("Component type not supported\n");
#line 837
  printf((char const   */* __restrict  */)tmp___2);
  }
#line 838
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 841
  return (d);
}
}
#line 848 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/zefant-xs3.c"
static void zefant_xs3_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain ;
  bus_area_t area___0 ;
  component_t *comp ;
  uint8_t cmd ;
  char *tmp ;
  uint8_t tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 851
  p = bus___0->part;
#line 852
  chain = bus___0->chain;
#line 855
  cmd = (uint8_t )2;
#line 857
  comp_bus_area(bus___0, adr, & area___0, & comp);
  }
#line 858
  if (! comp) {
    {
#line 859
    tmp = gettext("Address out of range\n");
#line 859
    printf((char const   */* __restrict  */)tmp);
    }
#line 860
    return;
  }
  {
#line 865
  if ((unsigned int )comp->ctype == 0U) {
#line 865
    goto case_0;
  }
#line 865
  if ((unsigned int )comp->ctype == 1U) {
#line 865
    goto case_0;
  }
#line 891
  if ((unsigned int )comp->ctype == 3U) {
#line 891
    goto case_3;
  }
#line 894
  if ((unsigned int )comp->ctype == 2U) {
#line 894
    goto case_2;
  }
#line 945
  goto switch_default;
  case_0: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 866
  part_set_signal(p, comp->ncs, 1, 0);
#line 867
  part_set_signal(p, comp->nwe, 1, 1);
#line 868
  part_set_signal(p, comp->noe, 1, 1);
  }
#line 869
  if ((unsigned int )comp->ctype == 0U) {
    {
#line 870
    part_set_signal(p, comp->nlb, 1, 0);
#line 871
    part_set_signal(p, comp->nub, 1, 0);
    }
  }
  {
#line 874
  setup_address(bus___0, adr, comp);
#line 875
  setup_data(bus___0, data, comp);
#line 877
  chain_shift_data_registers(chain, 0);
#line 879
  part_set_signal(p, comp->nwe, 1, 0);
#line 880
  chain_shift_data_registers(chain, 0);
#line 881
  part_set_signal(p, comp->nwe, 1, 1);
#line 882
  part_set_signal(p, comp->ncs, 1, 1);
  }
#line 883
  if ((unsigned int )comp->ctype == 0U) {
    {
#line 884
    part_set_signal(p, comp->nlb, 1, 1);
#line 885
    part_set_signal(p, comp->nub, 1, 1);
    }
  }
  {
#line 887
  chain_shift_data_registers(chain, 0);
  }
#line 889
  goto switch_break;
  case_3: /* CIL Label */ 
#line 892
  cmd = (uint8_t )1;
  case_2: /* CIL Label */ 
  {
#line 899
  part_set_signal(p, comp->ncs, 1, 0);
  }
  {
#line 902
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 903
    eeprom_shift_byte(chain, p, comp, (uint8_t )5);
#line 902
    tmp___0 = eeprom_shift_byte(chain, p, comp, (uint8_t )0);
    }
#line 902
    if (! ((int )tmp___0 & 1)) {
#line 902
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 906
  eeprom_disable_device(chain, p, comp);
#line 913
  part_set_signal(p, comp->ncs, 1, 0);
#line 916
  eeprom_shift_byte(chain, p, comp, (uint8_t )6);
#line 918
  eeprom_disable_device(chain, p, comp);
#line 925
  part_set_signal(p, comp->ncs, 1, 0);
#line 929
  eeprom_shift_byte(chain, p, comp, cmd);
  }
#line 931
  if ((unsigned int )comp->ctype == 2U) {
    {
#line 933
    eeprom_shift_byte(chain, p, comp, (uint8_t )((adr >> 8) & 255U));
#line 935
    eeprom_shift_byte(chain, p, comp, (uint8_t )(adr & 255U));
    }
  }
  {
#line 939
  eeprom_shift_byte(chain, p, comp, (uint8_t )(data & 255U));
#line 941
  eeprom_disable_device(chain, p, comp);
  }
#line 943
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 946
  tmp___1 = gettext("Component type not supported\n");
#line 946
  printf((char const   */* __restrict  */)tmp___1);
  }
#line 947
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 949
  return;
}
}
#line 951 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/zefant-xs3.c"
struct bus_driver  const  zefant_xs3_bus  = 
#line 951
     {"zefant-xs3", "Simple Solutions Zefant-XS3 Board compatible bus driver via BSR",
    & zefant_xs3_bus_new, & generic_bus_free, & zefant_xs3_bus_printinfo, & generic_bus_prepare_extest,
    & zefant_xs3_bus_area, & zefant_xs3_bus_read_start, & zefant_xs3_bus_read_next,
    & zefant_xs3_bus_read_end, & generic_bus_read, & zefant_xs3_bus_write, & zefant_xs3_bus_init};
#line 219 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 801
extern  __attribute__((__nothrow__)) int feof(FILE *__stream ) ;
#line 43 "../../include/jtag.h"
int big_endian ;
#line 59
void writemem(bus_t *bus___0 , FILE *f , uint32_t addr , uint32_t len ) ;
#line 36 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/writemem.c"
void writemem(bus_t *bus___0 , FILE *f , uint32_t addr , uint32_t len ) 
{ 
  uint32_t step ;
  uint32_t a ;
  int bc ;
  int bidx ;
  uint8_t b[4096] ;
  bus_area_t area___0 ;
  uint64_t end ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  uint32_t data ;
  int j ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  size_t tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  void *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;

  {
#line 41
  bc = 0;
#line 42
  bidx = 0;
#line 48
  if (! bus___0) {
    {
#line 49
    tmp = gettext("Error: Missing bus driver!\n");
#line 49
    printf((char const   */* __restrict  */)tmp);
    }
#line 50
    return;
  }
  {
#line 53
  (*((bus___0->driver)->prepare))(bus___0);
#line 55
  tmp___1 = (*((bus___0->driver)->area))(bus___0, addr, & area___0);
  }
#line 55
  if (tmp___1 != 0) {
    {
#line 56
    tmp___0 = gettext("Error: Bus width detection failed\n");
#line 56
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 57
    return;
  }
#line 59
  step = area___0.width / 8U;
#line 61
  if (step == 0U) {
    {
#line 62
    tmp___2 = gettext("Unknown bus width!\n");
#line 62
    printf((char const   */* __restrict  */)tmp___2);
    }
#line 63
    return;
  }
  {
#line 66
  addr &= ~ (step - 1U);
#line 67
  len = ((len + step) - 1U) & ~ (step - 1U);
#line 69
  tmp___3 = gettext("address: 0x%08X\n");
#line 69
  printf((char const   */* __restrict  */)tmp___3, addr);
#line 70
  tmp___4 = gettext("length:  0x%08X\n");
#line 70
  printf((char const   */* __restrict  */)tmp___4, len);
  }
#line 72
  if (len == 0U) {
    {
#line 73
    tmp___5 = gettext("length is 0.\n");
#line 73
    printf((char const   */* __restrict  */)tmp___5);
    }
#line 74
    return;
  }
  {
#line 77
  a = addr;
#line 78
  end = (uint64_t )(a + len);
#line 79
  tmp___6 = gettext("writing:\n");
#line 79
  printf((char const   */* __restrict  */)tmp___6);
  }
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    if (! ((uint64_t )a < end)) {
#line 81
      goto while_break;
    }
#line 86
    if ((uint32_t )bc < step) {
      {
#line 87
      tmp___7 = gettext("addr: 0x%08X");
#line 87
      printf((char const   */* __restrict  */)tmp___7, a);
#line 88
      printf((char const   */* __restrict  */)"\r");
#line 89
      fflush(stdout);
      }
#line 90
      if (bc != 0) {
        {
#line 91
        tmp___8 = gettext("Data not on word boundary, NOT SUPPORTED!");
#line 91
        printf((char const   */* __restrict  */)tmp___8);
        }
      }
      {
#line 92
      tmp___11 = feof(f);
      }
#line 92
      if (tmp___11) {
        {
#line 93
        tmp___9 = gettext("Unexpected end of file!\n");
#line 93
        printf((char const   */* __restrict  */)tmp___9);
#line 94
        tmp___10 = gettext("Addr: 0x%08X\n");
#line 94
        printf((char const   */* __restrict  */)tmp___10, a);
        }
#line 95
        goto while_break;
      }
      {
#line 97
      tmp___12 = fread((void */* __restrict  */)(b), (size_t )1, (size_t )4096, (FILE */* __restrict  */)f);
#line 97
      bc = (int )tmp___12;
      }
#line 98
      if (! bc) {
        {
#line 99
        tmp___13 = gettext("Short read: bc=0x%X\n");
#line 99
        printf((char const   */* __restrict  */)tmp___13, bc);
        }
      }
#line 101
      bidx = 0;
    }
#line 106
    data = (uint32_t )0;
#line 107
    j = (int )step;
    {
#line 107
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 107
      if (! (j > 0)) {
#line 107
        goto while_break___0;
      }
#line 108
      if (big_endian) {
#line 109
        tmp___14 = bidx;
#line 109
        bidx ++;
#line 109
        data |= (unsigned int )b[tmp___14];
#line 110
        data <<= 8;
#line 111
        bc --;
      } else {
#line 113
        tmp___15 = bidx;
#line 113
        bidx ++;
#line 113
        data |= (unsigned int )((int )b[tmp___15] << (step - (uint32_t )j) * 8U);
#line 114
        bc --;
      }
#line 107
      j --;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 118
    (*((bus___0->driver)->write))(bus___0, a, data);
#line 81
    a += step;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 122
  tmp___16 = gettext("\nDone.\n");
#line 122
  printf((char const   */* __restrict  */)tmp___16);
  }
#line 123
  return;
}
}
#line 341 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 61 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/buses.h"
struct bus_driver  const  tx4925_bus ;
#line 33 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/generic_bus.h"
int generic_bus_no_init(bus_t *bus___0 ) ;
#line 72 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/tx4925.c"
static bus_t *tx4925_bus_new(chain_t *chain , bus_driver_t const   *driver , char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  part_t *part ;
  char buff[15] ;
  int i ;
  int failed ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
  {
#line 79
  failed = 0;
#line 81
  tmp = calloc((size_t )1, (size_t )sizeof(bus_t ));
#line 81
  bus___0 = (bus_t *)tmp;
  }
#line 82
  if (! bus___0) {
#line 83
    return ((bus_t *)((void *)0));
  }
  {
#line 85
  bus___0->driver = driver;
#line 86
  bus___0->params = calloc((size_t )1, (size_t )sizeof(bus_params_t___0 ));
  }
#line 87
  if (! bus___0->params) {
    {
#line 88
    free((void *)bus___0);
    }
#line 89
    return ((bus_t *)((void *)0));
  }
  {
#line 92
  bus___0->chain = chain;
#line 93
  part = *((chain->parts)->parts + chain->active_part);
#line 93
  bus___0->part = part;
#line 95
  tmp___0 = generic_bus_attach_sig(part, & ((bus_params_t___0 *)bus___0->params)->oe,
                                   (char *)"OE");
#line 95
  failed |= tmp___0;
#line 97
  tmp___1 = generic_bus_attach_sig(part, & ((bus_params_t___0 *)bus___0->params)->swe,
                                   (char *)"SWE");
#line 97
  failed |= tmp___1;
#line 99
  i = 0;
  }
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! (i < 4)) {
#line 99
      goto while_break;
    }
    {
#line 100
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"ROMCE_%d",
            i);
#line 101
    tmp___2 = generic_bus_attach_sig(part, & ((bus_params_t___0 *)bus___0->params)->romce[i],
                                     buff);
#line 101
    failed |= tmp___2;
#line 99
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  i = 0;
  {
#line 104
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 104
    if (! (i < 4)) {
#line 104
      goto while_break___0;
    }
    {
#line 105
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"SDCS_%d",
            i);
#line 106
    tmp___3 = generic_bus_attach_sig(part, & ((bus_params_t___0 *)bus___0->params)->sdcs[i],
                                     buff);
#line 106
    failed |= tmp___3;
#line 104
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 109
  i = 0;
  {
#line 109
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 109
    if (! (i < 20)) {
#line 109
      goto while_break___1;
    }
    {
#line 110
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"ADDR_%d",
            i);
#line 111
    tmp___4 = generic_bus_attach_sig(part, & ((bus_params_t___0 *)bus___0->params)->addr[i],
                                     buff);
#line 111
    failed |= tmp___4;
#line 109
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 114
  i = 0;
  {
#line 114
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 114
    if (! (i < 16)) {
#line 114
      goto while_break___2;
    }
    {
#line 115
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"DATA_%d",
            i);
#line 116
    tmp___5 = generic_bus_attach_sig(part, & ((bus_params_t___0 *)bus___0->params)->data[i],
                                     buff);
#line 116
    failed |= tmp___5;
#line 114
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 119
  if (failed) {
    {
#line 120
    free(bus___0->params);
#line 121
    free((void *)bus___0);
    }
#line 122
    return ((bus_t *)((void *)0));
  }
#line 125
  return (bus___0);
}
}
#line 132 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/tx4925.c"
static void tx4925_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;
  char *__cil_tmp4 ;

  {
#line 137
  i = 0;
  {
#line 137
  while (1) {
    while_continue: /* CIL Label */ ;
#line 137
    if (! (i < ((bus___0->chain)->parts)->len)) {
#line 137
      goto while_break;
    }
#line 138
    if ((unsigned long )bus___0->part == (unsigned long )*(((bus___0->chain)->parts)->parts + i)) {
#line 139
      goto while_break;
    }
#line 137
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 140
  tmp = gettext("Toshiba TX4925 compatible bus driver via BSR (JTAG part No. %d)\n");
#line 140
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 141
  return;
}
}
#line 147 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/tx4925.c"
static int tx4925_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area___0 ) 
{ 


  {
#line 150
  area___0->description = (char const   *)((void *)0);
#line 151
  area___0->start = 0U;
#line 152
  area___0->length = 4294967296ULL;
#line 153
  area___0->width = 16U;
#line 155
  return (0);
}
}
#line 158 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/tx4925.c"
static void select_flash(bus_t *bus___0 ) 
{ 
  part_t *p ;

  {
  {
#line 161
  p = bus___0->part;
#line 163
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->romce[0], 1, 0);
#line 164
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->romce[1], 1, 1);
#line 165
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->romce[2], 1, 1);
#line 166
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->romce[3], 1, 1);
#line 167
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->sdcs[0], 1, 1);
#line 168
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->sdcs[1], 1, 1);
#line 169
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->sdcs[2], 1, 1);
#line 170
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->sdcs[3], 1, 1);
  }
#line 171
  return;
}
}
#line 173 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/tx4925.c"
static void unselect_flash(bus_t *bus___0 ) 
{ 
  part_t *p ;

  {
  {
#line 176
  p = bus___0->part;
#line 178
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->romce[0], 1, 1);
#line 179
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->romce[1], 1, 1);
#line 180
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->romce[2], 1, 1);
#line 181
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->romce[3], 1, 1);
#line 182
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->sdcs[0], 1, 1);
#line 183
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->sdcs[1], 1, 1);
#line 184
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->sdcs[2], 1, 1);
#line 185
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->sdcs[3], 1, 1);
  }
#line 186
  return;
}
}
#line 188 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/tx4925.c"
static void setup_address___0(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;
  int addr_shift ;

  {
#line 192
  p = bus___0->part;
#line 193
  addr_shift = 1;
#line 195
  i = 0;
  {
#line 195
  while (1) {
    while_continue: /* CIL Label */ ;
#line 195
    if (! (i < 20)) {
#line 195
      goto while_break;
    }
    {
#line 196
    part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->addr[i], 1, (int )((a >> (i + addr_shift)) & 1U));
#line 195
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 197
  return;
}
}
#line 199 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/tx4925.c"
static void set_data_in___0(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;

  {
#line 203
  p = bus___0->part;
#line 205
  i = 0;
  {
#line 205
  while (1) {
    while_continue: /* CIL Label */ ;
#line 205
    if (! (i < 16)) {
#line 205
      goto while_break;
    }
    {
#line 206
    part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->data[i], 0, 0);
#line 205
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 207
  return;
}
}
#line 209 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/tx4925.c"
static void setup_data___0(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;

  {
#line 213
  p = bus___0->part;
#line 215
  i = 0;
  {
#line 215
  while (1) {
    while_continue: /* CIL Label */ ;
#line 215
    if (! (i < 16)) {
#line 215
      goto while_break;
    }
    {
#line 216
    part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->data[i], 1, (int )((d >> i) & 1U));
#line 215
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 217
  return;
}
}
#line 223 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/tx4925.c"
static void tx4925_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
  {
#line 226
  p = bus___0->part;
#line 227
  chain = bus___0->chain;
#line 229
  select_flash(bus___0);
#line 230
  setup_address___0(bus___0, adr);
#line 231
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->oe, 1, 0);
#line 232
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->swe, 1, 1);
#line 234
  set_data_in___0(bus___0);
#line 236
  chain_shift_data_registers(chain, 0);
  }
#line 237
  return;
}
}
#line 243 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/tx4925.c"
static uint32_t tx4925_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 246
  p = bus___0->part;
#line 247
  chain = bus___0->chain;
#line 249
  d = (uint32_t )0;
#line 251
  setup_address___0(bus___0, adr);
#line 252
  chain_shift_data_registers(chain, 1);
#line 254
  i = 0;
  }
  {
#line 254
  while (1) {
    while_continue: /* CIL Label */ ;
#line 254
    if (! (i < 16)) {
#line 254
      goto while_break;
    }
    {
#line 255
    tmp = part_get_signal(p, ((bus_params_t___0 *)bus___0->params)->data[i]);
#line 255
    d |= (uint32_t )(tmp << i);
#line 254
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 257
  return (d);
}
}
#line 264 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/tx4925.c"
static uint32_t tx4925_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 267
  p = bus___0->part;
#line 268
  chain = bus___0->chain;
#line 270
  d = (uint32_t )0;
#line 272
  unselect_flash(bus___0);
#line 273
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->oe, 1, 1);
#line 274
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->swe, 1, 1);
#line 276
  chain_shift_data_registers(chain, 1);
#line 278
  i = 0;
  }
  {
#line 278
  while (1) {
    while_continue: /* CIL Label */ ;
#line 278
    if (! (i < 16)) {
#line 278
      goto while_break;
    }
    {
#line 279
    tmp = part_get_signal(p, ((bus_params_t___0 *)bus___0->params)->data[i]);
#line 279
    d |= (uint32_t )(tmp << i);
#line 278
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 281
  return (d);
}
}
#line 288 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/tx4925.c"
static void tx4925_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
  {
#line 291
  p = bus___0->part;
#line 292
  chain = bus___0->chain;
#line 294
  select_flash(bus___0);
#line 295
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->oe, 1, 1);
#line 297
  setup_address___0(bus___0, adr);
#line 298
  setup_data___0(bus___0, data);
#line 300
  chain_shift_data_registers(chain, 0);
#line 302
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->swe, 1, 0);
#line 303
  chain_shift_data_registers(chain, 0);
#line 304
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->swe, 1, 1);
#line 305
  unselect_flash(bus___0);
#line 306
  chain_shift_data_registers(chain, 0);
  }
#line 307
  return;
}
}
#line 309 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/tx4925.c"
struct bus_driver  const  tx4925_bus  = 
#line 309
     {"tx4925", "Toshiba TX4925 compatible bus driver via BSR", & tx4925_bus_new, & generic_bus_free,
    & tx4925_bus_printinfo, & generic_bus_prepare_extest, & tx4925_bus_area, & tx4925_bus_read_start,
    & tx4925_bus_read_next, & tx4925_bus_read_end, & generic_bus_read, & tx4925_bus_write,
    & generic_bus_no_init};
#line 60 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/buses.h"
struct bus_driver  const  slsup3_bus ;
#line 42 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/slsup3.c"
int databusio[16]  = 
#line 42 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/slsup3.c"
  {      94,      96,      98,      100, 
        102,      104,      106,      113, 
        95,      97,      99,      101, 
        103,      105,      107,      114};
#line 43 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/slsup3.c"
int addrbusio[20]  = 
#line 43
  {      93,      88,      87,      86, 
        85,      84,      83,      63, 
        64,      65,      66,      67, 
        68,      74,      75,      76, 
        77,      82,      81,      78};
#line 91 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/slsup3.c"
static bus_t *slsup3_bus_new(chain_t *chain , bus_driver_t const   *driver , char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  part_t *part ;
  char buff[10] ;
  int i ;
  int failed ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  void *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;

  {
  {
#line 98
  failed = 0;
#line 100
  tmp = calloc((size_t )1, (size_t )sizeof(bus_t ));
#line 100
  bus___0 = (bus_t *)tmp;
  }
#line 101
  if (! bus___0) {
#line 102
    return ((bus_t *)((void *)0));
  }
  {
#line 104
  bus___0->driver = driver;
#line 105
  bus___0->params = calloc((size_t )1, (size_t )sizeof(bus_params_t___1 ));
  }
#line 106
  if (! bus___0->params) {
    {
#line 107
    free((void *)bus___0);
    }
#line 108
    return ((bus_t *)((void *)0));
  }
#line 111
  bus___0->chain = chain;
#line 112
  part = *((chain->parts)->parts + chain->active_part);
#line 112
  bus___0->part = part;
#line 114
  i = 0;
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    if (! (i < 20)) {
#line 114
      goto while_break;
    }
    {
#line 115
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"IO%d",
            addrbusio[i]);
#line 116
    tmp___0 = generic_bus_attach_sig(part, & ((bus_params_t___1 *)bus___0->params)->ad[i],
                                     buff);
#line 116
    failed |= tmp___0;
#line 114
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 119
  i = 0;
  {
#line 119
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 119
    if (! (i < 16)) {
#line 119
      goto while_break___0;
    }
    {
#line 120
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"IO%d",
            databusio[i]);
#line 121
    tmp___1 = generic_bus_attach_sig(part, & ((bus_params_t___1 *)bus___0->params)->dq[i],
                                     buff);
#line 121
    failed |= tmp___1;
#line 119
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 124
  tmp___2 = generic_bus_attach_sig(part, & ((bus_params_t___1 *)bus___0->params)->noe,
                                   (char *)"IO118");
#line 124
  failed |= tmp___2;
#line 126
  tmp___3 = generic_bus_attach_sig(part, & ((bus_params_t___1 *)bus___0->params)->nsrce,
                                   (char *)"IO116");
#line 126
  failed |= tmp___3;
#line 128
  tmp___4 = generic_bus_attach_sig(part, & ((bus_params_t___1 *)bus___0->params)->nsdce,
                                   (char *)"IO119");
#line 128
  failed |= tmp___4;
#line 130
  tmp___5 = generic_bus_attach_sig(part, & ((bus_params_t___1 *)bus___0->params)->nflce,
                                   (char *)"IO117");
#line 130
  failed |= tmp___5;
#line 132
  tmp___6 = generic_bus_attach_sig(part, & ((bus_params_t___1 *)bus___0->params)->nflbyte,
                                   (char *)"IO115");
#line 132
  failed |= tmp___6;
#line 134
  tmp___7 = generic_bus_attach_sig(part, & ((bus_params_t___1 *)bus___0->params)->nflby,
                                   (char *)"IO80");
#line 134
  failed |= tmp___7;
#line 136
  tmp___8 = generic_bus_attach_sig(part, & ((bus_params_t___1 *)bus___0->params)->nwe,
                                   (char *)"IO79");
#line 136
  failed |= tmp___8;
#line 138
  tmp___9 = generic_bus_attach_sig(part, & ((bus_params_t___1 *)bus___0->params)->sdclk,
                                   (char *)"IO11");
#line 138
  failed |= tmp___9;
#line 140
  tmp___10 = generic_bus_attach_sig(part, & ((bus_params_t___1 *)bus___0->params)->lcde,
                                    (char *)"IO50");
#line 140
  failed |= tmp___10;
#line 142
  tmp___11 = generic_bus_attach_sig(part, & ((bus_params_t___1 *)bus___0->params)->lcdrs,
                                    (char *)"IO108");
#line 142
  failed |= tmp___11;
#line 144
  tmp___12 = generic_bus_attach_sig(part, & ((bus_params_t___1 *)bus___0->params)->lcdrw,
                                    (char *)"IO73");
#line 144
  failed |= tmp___12;
  }
#line 146
  if (failed) {
    {
#line 147
    free(bus___0->params);
#line 148
    free((void *)bus___0);
    }
#line 149
    return ((bus_t *)((void *)0));
  }
#line 152
  return (bus___0);
}
}
#line 159 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/slsup3.c"
static void slsup3_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;
  char *__cil_tmp4 ;

  {
#line 164
  i = 0;
  {
#line 164
  while (1) {
    while_continue: /* CIL Label */ ;
#line 164
    if (! (i < ((bus___0->chain)->parts)->len)) {
#line 164
      goto while_break;
    }
#line 165
    if ((unsigned long )bus___0->part == (unsigned long )*(((bus___0->chain)->parts)->parts + i)) {
#line 166
      goto while_break;
    }
#line 164
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 167
  tmp = gettext("SLS UP3 bus driver via BSR (JTAG part No. %d)\n");
#line 167
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 168
  return;
}
}
#line 174 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/slsup3.c"
static int slsup3_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area___0 ) 
{ 
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 177
  if (adr >= 0U) {
#line 177
    if ((unsigned long long )adr < 2097152ULL) {
#line 178
      area___0->description = "Flash Memory (2 MByte) byte mode";
#line 179
      area___0->start = 0U;
#line 180
      area___0->length = 2097152ULL;
#line 181
      area___0->width = 8U;
#line 183
      return (0);
    }
  }
#line 186
  if (adr >= 2097152U) {
#line 186
    if (adr < 2228224U) {
#line 187
      area___0->description = "SRAM 128KByte (64K x 16)";
#line 188
      area___0->start = (uint32_t )2097152;
#line 189
      area___0->length = (uint64_t )131072;
#line 190
      area___0->width = 16U;
#line 192
      return (0);
    }
  }
#line 195
  if (adr >= 3145728U) {
#line 195
    if (adr < 4194304U) {
#line 196
      area___0->description = "LCD Display (RS select by A0)";
#line 197
      area___0->start = (uint32_t )3145728;
#line 198
      area___0->length = (uint64_t )1048576;
#line 199
      area___0->width = 8U;
#line 201
      return (0);
    }
  }
#line 204
  area___0->description = (char const   *)((void *)0);
#line 205
  area___0->start = 4194304U;
#line 206
  area___0->length = 4290772992ULL;
#line 207
  area___0->width = 0U;
#line 209
  return (0);
}
}
#line 212 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/slsup3.c"
static void setup_address___1(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area___0 ;

  {
  {
#line 216
  p = bus___0->part;
#line 219
  slsup3_bus_area(bus___0, a, & area___0);
  }
#line 220
  if (area___0.width > 16U) {
#line 221
    return;
  }
  {
#line 223
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->lcdrs, 1, (int )(a & 1U));
  }
#line 226
  if (a >= 0U) {
#line 226
    if ((unsigned long long )a < 2097152ULL) {
#line 227
      i = 0;
      {
#line 227
      while (1) {
        while_continue: /* CIL Label */ ;
#line 227
        if (! (i < 20)) {
#line 227
          goto while_break;
        }
        {
#line 228
        part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->ad[i], 1, (int )((a >> (i + 1)) & 1U));
#line 227
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 229
      part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nflce, 1, 0);
#line 230
      part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->dq[15], 1, (int )(a & 1U));
      }
    } else {
      {
#line 232
      part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nflce, 1, 1);
      }
    }
  } else {
    {
#line 232
    part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nflce, 1, 1);
    }
  }
#line 235
  if (a >= 2097152U) {
#line 235
    if (a < 2228224U) {
      {
#line 236
      part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nsrce, 1, 0);
#line 237
      i = 0;
      }
      {
#line 237
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 237
        if (! (i < 20)) {
#line 237
          goto while_break___0;
        }
        {
#line 238
        part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->ad[i], 1, (int )((a >> (((unsigned int )i + area___0.width / 8U) - 1U)) & 1U));
#line 237
        i ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 240
      part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nsrce, 1, 1);
      }
    }
  } else {
    {
#line 240
    part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nsrce, 1, 1);
    }
  }
#line 243
  return;
}
}
#line 245 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/slsup3.c"
static void set_data_in___1(bus_t *bus___0 , uint32_t adr ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area___0 ;

  {
  {
#line 249
  p = bus___0->part;
#line 252
  slsup3_bus_area(bus___0, adr, & area___0);
  }
#line 253
  if (area___0.width > 16U) {
#line 254
    return;
  }
#line 256
  i = 0;
  {
#line 256
  while (1) {
    while_continue: /* CIL Label */ ;
#line 256
    if (! ((unsigned int )i < area___0.width)) {
#line 256
      goto while_break;
    }
    {
#line 257
    part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->dq[i], 0, 0);
#line 256
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 258
  return;
}
}
#line 260 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/slsup3.c"
static void setup_data___1(bus_t *bus___0 , uint32_t adr , uint32_t d ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area___0 ;

  {
  {
#line 264
  p = bus___0->part;
#line 267
  slsup3_bus_area(bus___0, adr, & area___0);
  }
#line 268
  if (area___0.width > 16U) {
#line 269
    return;
  }
#line 271
  i = 0;
  {
#line 271
  while (1) {
    while_continue: /* CIL Label */ ;
#line 271
    if (! ((unsigned int )i < area___0.width)) {
#line 271
      goto while_break;
    }
    {
#line 272
    part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->dq[i], 1, (int )((d >> i) & 1U));
#line 271
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 273
  return;
}
}
#line 275 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/slsup3.c"
static uint32_t get_data(bus_t *bus___0 , uint32_t adr ) 
{ 
  bus_area_t area___0 ;
  int i ;
  uint32_t d ;
  part_t *p ;
  int tmp ;

  {
  {
#line 280
  d = (uint32_t )0;
#line 281
  p = bus___0->part;
#line 283
  slsup3_bus_area(bus___0, adr, & area___0);
  }
#line 284
  if (area___0.width > 16U) {
#line 285
    return ((uint32_t )0);
  }
#line 287
  i = 0;
  {
#line 287
  while (1) {
    while_continue: /* CIL Label */ ;
#line 287
    if (! ((unsigned int )i < area___0.width)) {
#line 287
      goto while_break;
    }
    {
#line 288
    tmp = part_get_signal(p, ((bus_params_t___1 *)bus___0->params)->dq[i]);
#line 288
    d |= (uint32_t )(tmp << i);
#line 287
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 290
  return (d);
}
}
#line 297 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/slsup3.c"
static void slsup3_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;

  {
  {
#line 300
  p = bus___0->part;
#line 302
  ((bus_params_t___1 *)bus___0->params)->last_adr = adr;
#line 304
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nsdce, 1, 1);
#line 305
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->noe, 1, 0);
#line 306
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nsrce, 1, 1);
#line 307
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nflce, 1, 1);
#line 308
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nflbyte, 1, 0);
#line 309
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nwe, 1, 1);
#line 310
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->sdclk, 1, 0);
#line 311
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->lcde, 1, 0);
#line 312
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->lcdrw, 1, 1);
#line 314
  setup_address___1(bus___0, adr);
  }
#line 316
  if (adr >= 3145728U) {
#line 316
    if (adr < 4194304U) {
      {
#line 317
      part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->lcde, 1, 1);
#line 318
      chain_shift_data_registers(bus___0->chain, 0);
#line 319
      part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->lcde, 1, 0);
      }
    }
  }
  {
#line 322
  set_data_in___1(bus___0, adr);
#line 324
  chain_shift_data_registers(bus___0->chain, 0);
  }
#line 326
  return;
}
}
#line 332 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/slsup3.c"
static uint32_t slsup3_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t d ;
  part_t *p ;

  {
  {
#line 337
  p = bus___0->part;
#line 339
  setup_address___1(bus___0, adr);
  }
#line 341
  if (adr >= 3145728U) {
#line 341
    if (adr < 4194304U) {
      {
#line 342
      part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->lcde, 1, 1);
#line 343
      chain_shift_data_registers(bus___0->chain, 0);
#line 344
      part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->lcde, 1, 0);
      }
    }
  }
  {
#line 347
  chain_shift_data_registers(bus___0->chain, 1);
#line 349
  d = get_data(bus___0, ((bus_params_t___1 *)bus___0->params)->last_adr);
#line 351
  ((bus_params_t___1 *)bus___0->params)->last_adr = adr;
  }
#line 353
  return (d);
}
}
#line 360 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/slsup3.c"
static uint32_t slsup3_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  uint32_t d ;

  {
#line 363
  p = bus___0->part;
#line 366
  if (((bus_params_t___1 *)bus___0->params)->last_adr >= 3145728U) {
#line 366
    if (((bus_params_t___1 *)bus___0->params)->last_adr < 4194304U) {
      {
#line 367
      part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->lcde, 1, 1);
#line 368
      chain_shift_data_registers(bus___0->chain, 0);
#line 369
      part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->lcde, 1, 0);
      }
    }
  }
  {
#line 372
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->noe, 1, 1);
#line 374
  chain_shift_data_registers(bus___0->chain, 1);
#line 376
  d = get_data(bus___0, ((bus_params_t___1 *)bus___0->params)->last_adr);
  }
#line 378
  return (d);
}
}
#line 385 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/slsup3.c"
static void slsup3_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
  {
#line 388
  p = bus___0->part;
#line 389
  chain = bus___0->chain;
#line 391
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nsdce, 1, 1);
#line 392
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->noe, 1, 1);
#line 393
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nsrce, 1, 1);
#line 394
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nflce, 1, 1);
#line 395
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nflbyte, 1, 0);
#line 396
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nwe, 1, 1);
#line 397
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->sdclk, 1, 0);
#line 398
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->lcde, 1, 0);
#line 399
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->lcdrw, 1, 0);
#line 401
  setup_address___1(bus___0, adr);
#line 402
  setup_data___1(bus___0, adr, data);
  }
#line 404
  if (adr >= 3145728U) {
#line 404
    if (adr < 4194304U) {
      {
#line 405
      chain_shift_data_registers(chain, 0);
#line 406
      part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->lcde, 1, 1);
#line 407
      chain_shift_data_registers(bus___0->chain, 0);
#line 408
      part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->lcde, 1, 0);
#line 409
      chain_shift_data_registers(bus___0->chain, 0);
      }
    } else {
      {
#line 412
      chain_shift_data_registers(chain, 0);
#line 414
      part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nwe, 1, 0);
#line 415
      chain_shift_data_registers(chain, 0);
#line 416
      part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nwe, 1, 1);
#line 417
      chain_shift_data_registers(chain, 0);
      }
    }
  } else {
    {
#line 412
    chain_shift_data_registers(chain, 0);
#line 414
    part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nwe, 1, 0);
#line 415
    chain_shift_data_registers(chain, 0);
#line 416
    part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nwe, 1, 1);
#line 417
    chain_shift_data_registers(chain, 0);
    }
  }
#line 419
  return;
}
}
#line 421 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/slsup3.c"
struct bus_driver  const  slsup3_bus  = 
#line 421
     {"slsup3", "SLS UP3 compatible bus driver via BSR", & slsup3_bus_new, & generic_bus_free,
    & slsup3_bus_printinfo, & generic_bus_prepare_extest, & slsup3_bus_area, & slsup3_bus_read_start,
    & slsup3_bus_read_next, & slsup3_bus_read_end, & generic_bus_read, & slsup3_bus_write,
    & generic_bus_no_init};
#line 59 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/buses.h"
struct bus_driver  const  sharc_21065L_bus ;
#line 65 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sharc21065l.c"
static bus_t *sharc_21065L_bus_new(chain_t *chain , bus_driver_t const   *driver ,
                                   char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  part_t *part ;
  char buff[15] ;
  int i ;
  int failed ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
  {
#line 71
  failed = 0;
#line 73
  tmp = calloc((size_t )1, (size_t )sizeof(bus_t ));
#line 73
  bus___0 = (bus_t *)tmp;
  }
#line 74
  if (! bus___0) {
#line 75
    return ((bus_t *)((void *)0));
  }
  {
#line 77
  bus___0->driver = driver;
#line 78
  bus___0->params = calloc((size_t )1, (size_t )sizeof(bus_params_t___2 ));
  }
#line 79
  if (! bus___0->params) {
    {
#line 80
    free((void *)bus___0);
    }
#line 81
    return ((bus_t *)((void *)0));
  }
#line 84
  bus___0->chain = chain;
#line 85
  part = *((chain->parts)->parts + chain->active_part);
#line 85
  bus___0->part = part;
#line 87
  i = 0;
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
#line 87
    if (! (i < 19)) {
#line 87
      goto while_break;
    }
    {
#line 88
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"ADDR%d",
            i);
#line 89
    tmp___0 = generic_bus_attach_sig(part, & ((bus_params_t___2 *)bus___0->params)->ma[i],
                                     buff);
#line 89
    failed |= tmp___0;
#line 87
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  i = 0;
  {
#line 92
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 92
    if (! (i < 8)) {
#line 92
      goto while_break___0;
    }
    {
#line 93
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"DATA%d",
            i);
#line 94
    tmp___1 = generic_bus_attach_sig(part, & ((bus_params_t___2 *)bus___0->params)->md[i],
                                     buff);
#line 94
    failed |= tmp___1;
#line 92
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 97
  tmp___2 = generic_bus_attach_sig(part, & ((bus_params_t___2 *)bus___0->params)->bms,
                                   (char *)"BMS_B");
#line 97
  failed |= tmp___2;
#line 99
  tmp___3 = generic_bus_attach_sig(part, & ((bus_params_t___2 *)bus___0->params)->nwe,
                                   (char *)"WR_B");
#line 99
  failed |= tmp___3;
#line 101
  tmp___4 = generic_bus_attach_sig(part, & ((bus_params_t___2 *)bus___0->params)->noe,
                                   (char *)"RD_B");
#line 101
  failed |= tmp___4;
  }
#line 103
  if (failed) {
    {
#line 104
    free(bus___0->params);
#line 105
    free((void *)bus___0);
    }
#line 106
    return ((bus_t *)((void *)0));
  }
#line 109
  return (bus___0);
}
}
#line 116 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sharc21065l.c"
static void sharc_21065L_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;
  char *__cil_tmp4 ;

  {
#line 120
  i = 0;
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
#line 120
    if (! (i < ((bus___0->chain)->parts)->len)) {
#line 120
      goto while_break;
    }
#line 121
    if ((unsigned long )bus___0->part == (unsigned long )*(((bus___0->chain)->parts)->parts + i)) {
#line 122
      goto while_break;
    }
#line 120
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 123
  tmp = gettext("Analog Device\'s SHARC 21065L compatible bus driver via BSR (JTAG part No. %d)\n");
#line 123
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 124
  return;
}
}
#line 130 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sharc21065l.c"
static int sharc_21065L_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area___0 ) 
{ 
  char *__cil_tmp4 ;

  {
#line 134
  if (adr < 524288U) {
#line 135
    area___0->description = "Boot Memory Select";
#line 136
    area___0->start = 0U;
#line 137
    area___0->length = 524288ULL;
#line 138
    area___0->width = 8U;
#line 140
    return (0);
  }
#line 143
  area___0->description = (char const   *)((void *)0);
#line 144
  area___0->start = 4294967295U;
#line 145
  area___0->length = 524288ULL;
#line 146
  area___0->width = 0U;
#line 147
  return (0);
}
}
#line 150 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sharc21065l.c"
static void setup_address___2(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 154
  p = bus___0->part;
#line 156
  i = 0;
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 156
    if (! (i < 19)) {
#line 156
      goto while_break;
    }
    {
#line 157
    part_set_signal(p, ((bus_params_t___2 *)bus___0->params)->ma[i], 1, (int )((a >> i) & 1U));
#line 156
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 158
  return;
}
}
#line 160 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sharc21065l.c"
static void set_data_in___2(bus_t *bus___0 , uint32_t adr ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area___0 ;

  {
  {
#line 164
  p = bus___0->part;
#line 167
  sharc_21065L_bus_area(bus___0, adr, & area___0);
#line 169
  i = 0;
  }
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;
#line 169
    if (! ((unsigned int )i < area___0.width)) {
#line 169
      goto while_break;
    }
    {
#line 170
    part_set_signal(p, ((bus_params_t___2 *)bus___0->params)->md[i], 0, 0);
#line 169
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 171
  return;
}
}
#line 174 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sharc21065l.c"
static void setup_data___2(bus_t *bus___0 , uint32_t adr , uint32_t d ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area___0 ;

  {
  {
#line 178
  p = bus___0->part;
#line 181
  sharc_21065L_bus_area(bus___0, adr, & area___0);
#line 183
  i = 0;
  }
  {
#line 183
  while (1) {
    while_continue: /* CIL Label */ ;
#line 183
    if (! ((unsigned int )i < area___0.width)) {
#line 183
      goto while_break;
    }
    {
#line 184
    part_set_signal(p, ((bus_params_t___2 *)bus___0->params)->md[i], 1, (int )((d >> i) & 1U));
#line 183
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 185
  return;
}
}
#line 191 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sharc21065l.c"
static void sharc_21065L_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  chain_t *chain ;
  part_t *p ;

  {
#line 194
  chain = bus___0->chain;
#line 195
  p = bus___0->part;
#line 197
  ((bus_params_t___2 *)bus___0->params)->last_adr = adr;
#line 198
  if (adr >= 524288U) {
#line 199
    return;
  }
  {
#line 202
  part_set_signal(p, ((bus_params_t___2 *)bus___0->params)->bms, 1, 0);
#line 203
  part_set_signal(p, ((bus_params_t___2 *)bus___0->params)->nwe, 1, 1);
#line 204
  part_set_signal(p, ((bus_params_t___2 *)bus___0->params)->noe, 1, 0);
#line 206
  setup_address___2(bus___0, adr);
#line 207
  set_data_in___2(bus___0, adr);
#line 209
  chain_shift_data_registers(chain, 0);
  }
#line 210
  return;
}
}
#line 216 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sharc21065l.c"
static uint32_t sharc_21065L_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;
  uint32_t d ;
  int i ;
  bus_area_t area___0 ;
  int tmp ;

  {
#line 219
  p = bus___0->part;
#line 220
  chain = bus___0->chain;
#line 224
  ((bus_params_t___2 *)bus___0->params)->last_adr = adr;
#line 226
  if (adr < 524288U) {
    {
#line 230
    sharc_21065L_bus_area(bus___0, adr, & area___0);
#line 233
    setup_address___2(bus___0, adr);
#line 234
    chain_shift_data_registers(chain, 1);
#line 236
    d = (uint32_t )0;
#line 237
    i = 0;
    }
    {
#line 237
    while (1) {
      while_continue: /* CIL Label */ ;
#line 237
      if (! ((unsigned int )i < area___0.width)) {
#line 237
        goto while_break;
      }
      {
#line 238
      tmp = part_get_signal(p, ((bus_params_t___2 *)bus___0->params)->md[i]);
#line 238
      d |= (uint32_t )(tmp << i);
#line 237
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 240
    return (d);
  }
#line 242
  return ((uint32_t )0);
}
}
#line 249 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sharc21065l.c"
static uint32_t sharc_21065L_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  bus_area_t area___0 ;
  int tmp ;

  {
#line 252
  p = bus___0->part;
#line 253
  chain = bus___0->chain;
#line 255
  if (((bus_params_t___2 *)bus___0->params)->last_adr < 524288U) {
    {
#line 257
    d = (uint32_t )0;
#line 260
    sharc_21065L_bus_area(bus___0, ((bus_params_t___2 *)bus___0->params)->last_adr,
                          & area___0);
#line 263
    part_set_signal(p, ((bus_params_t___2 *)bus___0->params)->bms, 1, 1);
#line 264
    part_set_signal(p, ((bus_params_t___2 *)bus___0->params)->nwe, 1, 1);
#line 265
    part_set_signal(p, ((bus_params_t___2 *)bus___0->params)->noe, 1, 1);
#line 267
    chain_shift_data_registers(chain, 1);
#line 269
    i = 0;
    }
    {
#line 269
    while (1) {
      while_continue: /* CIL Label */ ;
#line 269
      if (! ((unsigned int )i < area___0.width)) {
#line 269
        goto while_break;
      }
      {
#line 270
      tmp = part_get_signal(p, ((bus_params_t___2 *)bus___0->params)->md[i]);
#line 270
      d |= (uint32_t )(tmp << i);
#line 269
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 272
    return (d);
  }
#line 275
  return ((uint32_t )0);
}
}
#line 282 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sharc21065l.c"
static void sharc_21065L_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
#line 285
  p = bus___0->part;
#line 286
  chain = bus___0->chain;
#line 288
  if (adr >= 524288U) {
#line 289
    return;
  }
  {
#line 292
  part_set_signal(p, ((bus_params_t___2 *)bus___0->params)->bms, 1, 0);
#line 293
  part_set_signal(p, ((bus_params_t___2 *)bus___0->params)->nwe, 1, 1);
#line 294
  part_set_signal(p, ((bus_params_t___2 *)bus___0->params)->noe, 1, 1);
#line 296
  setup_address___2(bus___0, adr);
#line 297
  setup_data___2(bus___0, adr, data);
#line 299
  chain_shift_data_registers(chain, 0);
#line 301
  part_set_signal(p, ((bus_params_t___2 *)bus___0->params)->nwe, 1, 0);
#line 302
  chain_shift_data_registers(chain, 0);
#line 303
  part_set_signal(p, ((bus_params_t___2 *)bus___0->params)->nwe, 1, 1);
#line 304
  chain_shift_data_registers(chain, 0);
  }
#line 305
  return;
}
}
#line 307 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sharc21065l.c"
struct bus_driver  const  sharc_21065L_bus  = 
#line 307
     {"SHARC_21065L", "SHARC_21065L compatible bus driver via BSR", & sharc_21065L_bus_new,
    & generic_bus_free, & sharc_21065L_bus_printinfo, & generic_bus_prepare_extest,
    & sharc_21065L_bus_area, & sharc_21065L_bus_read_start, & sharc_21065L_bus_read_next,
    & sharc_21065L_bus_read_end, & generic_bus_read, & sharc_21065L_bus_write, & generic_bus_no_init};
#line 58 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/buses.h"
struct bus_driver  const  sh7751r_bus ;
#line 62 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sh7751r.c"
static bus_t *sh7751r_bus_new(chain_t *chain , bus_driver_t const   *driver , char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  part_t *part ;
  char buff[10] ;
  int i ;
  int failed ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
  {
#line 69
  failed = 0;
#line 71
  tmp = calloc((size_t )1, (size_t )sizeof(bus_t ));
#line 71
  bus___0 = (bus_t *)tmp;
  }
#line 72
  if (! bus___0) {
#line 73
    return ((bus_t *)((void *)0));
  }
  {
#line 75
  bus___0->driver = driver;
#line 76
  bus___0->params = calloc((size_t )1, (size_t )sizeof(bus_params_t___3 ));
  }
#line 77
  if (! bus___0->params) {
    {
#line 78
    free((void *)bus___0);
    }
#line 79
    return ((bus_t *)((void *)0));
  }
#line 82
  bus___0->chain = chain;
#line 83
  part = *((chain->parts)->parts + chain->active_part);
#line 83
  bus___0->part = part;
#line 85
  i = 0;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! (i < 26)) {
#line 85
      goto while_break;
    }
    {
#line 86
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"A%d",
            i);
#line 87
    tmp___0 = generic_bus_attach_sig(part, & ((bus_params_t___3 *)bus___0->params)->a[i],
                                     buff);
#line 87
    failed |= tmp___0;
#line 85
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 90
  i = 0;
  {
#line 90
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 90
    if (! (i < 32)) {
#line 90
      goto while_break___0;
    }
    {
#line 91
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"D%d",
            i);
#line 92
    tmp___1 = generic_bus_attach_sig(part, & ((bus_params_t___3 *)bus___0->params)->d[i],
                                     buff);
#line 92
    failed |= tmp___1;
#line 90
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 95
  i = 0;
  {
#line 95
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 95
    if (! (i < 7)) {
#line 95
      goto while_break___1;
    }
    {
#line 96
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"CS%d",
            i);
#line 97
    tmp___2 = generic_bus_attach_sig(part, & ((bus_params_t___3 *)bus___0->params)->cs[i],
                                     buff);
#line 97
    failed |= tmp___2;
#line 95
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 100
  i = 0;
  {
#line 100
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 100
    if (! (i < 4)) {
#line 100
      goto while_break___2;
    }
    {
#line 101
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"WE%d",
            i);
#line 102
    tmp___3 = generic_bus_attach_sig(part, & ((bus_params_t___3 *)bus___0->params)->we[i],
                                     buff);
#line 102
    failed |= tmp___3;
#line 100
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 105
  tmp___4 = generic_bus_attach_sig(part, & ((bus_params_t___3 *)bus___0->params)->rdwr,
                                   (char *)"RD_WR");
#line 105
  failed |= tmp___4;
#line 107
  tmp___5 = generic_bus_attach_sig(part, & ((bus_params_t___3 *)bus___0->params)->rd,
                                   (char *)"RD_CASS_FRAME");
#line 107
  failed |= tmp___5;
  }
#line 109
  if (failed) {
    {
#line 110
    free(bus___0->params);
#line 111
    free((void *)bus___0);
    }
#line 112
    return ((bus_t *)((void *)0));
  }
#line 115
  return (bus___0);
}
}
#line 122 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sh7751r.c"
static void sh7751r_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;
  char *__cil_tmp4 ;

  {
#line 127
  i = 0;
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 127
    if (! (i < ((bus___0->chain)->parts)->len)) {
#line 127
      goto while_break;
    }
#line 128
    if ((unsigned long )bus___0->part == (unsigned long )*(((bus___0->chain)->parts)->parts + i)) {
#line 129
      goto while_break;
    }
#line 127
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 130
  tmp = gettext("Hitachi SH7751R compatible bus driver via BSR (JTAG part No. %d)\n");
#line 130
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 131
  return;
}
}
#line 137 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sh7751r.c"
static int sh7751r_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area___0 ) 
{ 


  {
#line 140
  area___0->description = (char const   *)((void *)0);
#line 141
  area___0->start = 0U;
#line 142
  area___0->length = 4294967296ULL;
#line 143
  area___0->width = 16U;
#line 145
  return (0);
}
}
#line 148 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sh7751r.c"
static void setup_address___3(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 152
  p = bus___0->part;
#line 154
  i = 0;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! (i < 26)) {
#line 154
      goto while_break;
    }
    {
#line 155
    part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->a[i], 1, (int )((a >> i) & 1U));
#line 154
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 156
  return;
}
}
#line 158 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sh7751r.c"
static void set_data_in___3(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;

  {
#line 162
  p = bus___0->part;
#line 164
  i = 0;
  {
#line 164
  while (1) {
    while_continue: /* CIL Label */ ;
#line 164
    if (! (i < 32)) {
#line 164
      goto while_break;
    }
    {
#line 165
    part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->d[i], 0, 0);
#line 164
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 166
  return;
}
}
#line 168 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sh7751r.c"
static void setup_data___3(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;

  {
#line 172
  p = bus___0->part;
#line 174
  i = 0;
  {
#line 174
  while (1) {
    while_continue: /* CIL Label */ ;
#line 174
    if (! (i < 32)) {
#line 174
      goto while_break;
    }
    {
#line 175
    part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->d[i], 1, (int )((d >> i) & 1U));
#line 174
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 176
  return;
}
}
#line 182 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sh7751r.c"
static void sh7751r_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  int cs[8] ;
  int i ;
  void *__cil_tmp6 ;

  {
#line 185
  p = bus___0->part;
#line 189
  i = 0;
  {
#line 189
  while (1) {
    while_continue: /* CIL Label */ ;
#line 189
    if (! (i < 8)) {
#line 189
      goto while_break;
    }
#line 190
    cs[i] = 1;
#line 189
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 191
  cs[(adr & 469762048U) >> 26] = 0;
#line 193
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[0], 1, cs[0]);
#line 194
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[1], 1, cs[1]);
#line 195
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[2], 1, cs[2]);
#line 196
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[3], 1, cs[3]);
#line 197
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[4], 1, cs[4]);
#line 198
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[5], 1, cs[5]);
#line 199
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[6], 1, cs[6]);
#line 200
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->rdwr, 1, 1);
#line 201
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[0], 1, 1);
#line 202
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[1], 1, 1);
#line 203
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[2], 1, 1);
#line 204
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[3], 1, 1);
#line 205
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->rd, 1, 0);
#line 207
  setup_address___3(bus___0, adr);
#line 208
  set_data_in___3(bus___0);
#line 209
  chain_shift_data_registers(bus___0->chain, 0);
  }
#line 210
  return;
}
}
#line 216 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sh7751r.c"
static uint32_t sh7751r_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 219
  p = bus___0->part;
#line 221
  d = (uint32_t )0;
#line 223
  setup_address___3(bus___0, adr);
#line 224
  chain_shift_data_registers(bus___0->chain, 1);
#line 226
  i = 0;
  }
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
#line 226
    if (! (i < 32)) {
#line 226
      goto while_break;
    }
    {
#line 227
    tmp = part_get_signal(p, ((bus_params_t___3 *)bus___0->params)->d[i]);
#line 227
    d |= (uint32_t )(tmp << i);
#line 226
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 229
  return (d);
}
}
#line 236 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sh7751r.c"
static uint32_t sh7751r_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  int cs[8] ;
  int i ;
  uint32_t d ;
  int tmp ;
  void *__cil_tmp7 ;

  {
#line 239
  p = bus___0->part;
#line 242
  d = (uint32_t )0;
#line 244
  i = 0;
  {
#line 244
  while (1) {
    while_continue: /* CIL Label */ ;
#line 244
    if (! (i < 8)) {
#line 244
      goto while_break;
    }
#line 245
    cs[i] = 1;
#line 244
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 247
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[0], 1, cs[0]);
#line 248
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[1], 1, cs[1]);
#line 249
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[2], 1, cs[2]);
#line 250
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[3], 1, cs[3]);
#line 251
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[4], 1, cs[4]);
#line 252
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[5], 1, cs[5]);
#line 253
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[6], 1, cs[6]);
#line 255
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->rd, 1, 1);
#line 256
  chain_shift_data_registers(bus___0->chain, 1);
#line 258
  i = 0;
  }
  {
#line 258
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 258
    if (! (i < 32)) {
#line 258
      goto while_break___0;
    }
    {
#line 259
    tmp = part_get_signal(p, ((bus_params_t___3 *)bus___0->params)->d[i]);
#line 259
    d |= (uint32_t )(tmp << i);
#line 258
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 261
  return (d);
}
}
#line 268 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sh7751r.c"
static void sh7751r_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  chain_t *chain ;
  part_t *p ;
  int cs[8] ;
  int i ;
  void *__cil_tmp8 ;

  {
#line 271
  chain = bus___0->chain;
#line 272
  p = bus___0->part;
#line 276
  i = 0;
  {
#line 276
  while (1) {
    while_continue: /* CIL Label */ ;
#line 276
    if (! (i < 8)) {
#line 276
      goto while_break;
    }
#line 277
    cs[i] = 1;
#line 276
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 278
  cs[(adr & 469762048U) >> 26] = 0;
#line 280
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[0], 1, cs[0]);
#line 281
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[1], 1, cs[1]);
#line 282
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[2], 1, cs[2]);
#line 283
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[3], 1, cs[3]);
#line 284
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[4], 1, cs[4]);
#line 285
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[5], 1, cs[5]);
#line 286
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[6], 1, cs[6]);
#line 288
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->rdwr, 1, 0);
#line 289
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[0], 1, 1);
#line 290
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[1], 1, 1);
#line 291
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[2], 1, 1);
#line 292
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[3], 1, 1);
#line 293
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->rd, 1, 1);
#line 295
  setup_address___3(bus___0, adr);
#line 296
  setup_data___3(bus___0, data);
#line 297
  chain_shift_data_registers(chain, 0);
#line 299
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[0], 1, 0);
#line 300
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[1], 1, 0);
#line 301
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[2], 1, 0);
#line 302
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[3], 1, 0);
#line 304
  chain_shift_data_registers(chain, 0);
#line 306
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[0], 1, 1);
#line 307
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[1], 1, 1);
#line 308
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[2], 1, 1);
#line 309
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[3], 1, 1);
#line 311
  chain_shift_data_registers(chain, 0);
  }
#line 312
  return;
}
}
#line 314 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sh7751r.c"
struct bus_driver  const  sh7751r_bus  = 
#line 314
     {"sh7751r", "Hitachi SH7751R compatible bus driver via BSR", & sh7751r_bus_new,
    & generic_bus_free, & sh7751r_bus_printinfo, & generic_bus_prepare_extest, & sh7751r_bus_area,
    & sh7751r_bus_read_start, & sh7751r_bus_read_next, & sh7751r_bus_read_end, & generic_bus_read,
    & sh7751r_bus_write, & generic_bus_no_init};
#line 57 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/buses.h"
struct bus_driver  const  sh7750r_bus ;
#line 64 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sh7750r.c"
static bus_t *sh7750r_bus_new(chain_t *chain , bus_driver_t const   *driver , char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  part_t *part ;
  char buff[10] ;
  int i ;
  int failed ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  void *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
  {
#line 71
  failed = 0;
#line 73
  tmp = calloc((size_t )1, (size_t )sizeof(bus_t ));
#line 73
  bus___0 = (bus_t *)tmp;
  }
#line 74
  if (! bus___0) {
#line 75
    return ((bus_t *)((void *)0));
  }
  {
#line 77
  bus___0->driver = driver;
#line 78
  bus___0->params = calloc((size_t )1, (size_t )sizeof(bus_params_t___4 ));
  }
#line 79
  if (! bus___0->params) {
    {
#line 80
    free((void *)bus___0);
    }
#line 81
    return ((bus_t *)((void *)0));
  }
#line 84
  bus___0->chain = chain;
#line 85
  part = *((chain->parts)->parts + chain->active_part);
#line 85
  bus___0->part = part;
#line 87
  i = 0;
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
#line 87
    if (! (i < 26)) {
#line 87
      goto while_break;
    }
    {
#line 88
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"A%d",
            i);
#line 89
    tmp___0 = generic_bus_attach_sig(part, & ((bus_params_t___4 *)bus___0->params)->a[i],
                                     buff);
#line 89
    failed |= tmp___0;
#line 87
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  i = 0;
  {
#line 92
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 92
    if (! (i < 32)) {
#line 92
      goto while_break___0;
    }
    {
#line 93
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"D%d",
            i);
#line 94
    tmp___1 = generic_bus_attach_sig(part, & ((bus_params_t___4 *)bus___0->params)->d[i],
                                     buff);
#line 94
    failed |= tmp___1;
#line 92
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 97
  i = 0;
  {
#line 97
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 97
    if (! (i < 7)) {
#line 97
      goto while_break___1;
    }
    {
#line 98
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"CS%d",
            i);
#line 99
    tmp___2 = generic_bus_attach_sig(part, & ((bus_params_t___4 *)bus___0->params)->cs[i],
                                     buff);
#line 99
    failed |= tmp___2;
#line 97
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 102
  i = 0;
  {
#line 102
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 102
    if (! (i < 8)) {
#line 102
      goto while_break___2;
    }
    {
#line 103
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"WE%d",
            i);
#line 104
    tmp___3 = generic_bus_attach_sig(part, & ((bus_params_t___4 *)bus___0->params)->we[i],
                                     buff);
#line 104
    failed |= tmp___3;
#line 102
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 107
  tmp___4 = generic_bus_attach_sig(part, & ((bus_params_t___4 *)bus___0->params)->rdwr,
                                   (char *)"RDWR");
#line 107
  failed |= tmp___4;
#line 109
  tmp___5 = generic_bus_attach_sig(part, & ((bus_params_t___4 *)bus___0->params)->rd,
                                   (char *)"RD");
#line 109
  failed |= tmp___5;
#line 111
  tmp___6 = generic_bus_attach_sig(part, & ((bus_params_t___4 *)bus___0->params)->rdwr2,
                                   (char *)"RDWR2");
#line 111
  failed |= tmp___6;
#line 113
  tmp___7 = generic_bus_attach_sig(part, & ((bus_params_t___4 *)bus___0->params)->rd2,
                                   (char *)"RD2");
#line 113
  failed |= tmp___7;
  }
#line 115
  if (failed) {
    {
#line 116
    free(bus___0->params);
#line 117
    free((void *)bus___0);
    }
#line 118
    return ((bus_t *)((void *)0));
  }
#line 121
  return (bus___0);
}
}
#line 128 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sh7750r.c"
static void sh7750r_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;
  char *__cil_tmp4 ;

  {
#line 133
  i = 0;
  {
#line 133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 133
    if (! (i < ((bus___0->chain)->parts)->len)) {
#line 133
      goto while_break;
    }
#line 134
    if ((unsigned long )bus___0->part == (unsigned long )*(((bus___0->chain)->parts)->parts + i)) {
#line 135
      goto while_break;
    }
#line 133
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 136
  tmp = gettext("Hitachi SH7750R compatible bus driver via BSR (JTAG part No. %d)\n");
#line 136
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 137
  return;
}
}
#line 143 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sh7750r.c"
static int sh7750r_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area___0 ) 
{ 


  {
#line 146
  area___0->description = (char const   *)((void *)0);
#line 147
  area___0->start = 0U;
#line 148
  area___0->length = 4294967296ULL;
#line 149
  area___0->width = 32U;
#line 151
  return (0);
}
}
#line 154 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sh7750r.c"
static void setup_address___4(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 158
  p = bus___0->part;
#line 160
  i = 0;
  {
#line 160
  while (1) {
    while_continue: /* CIL Label */ ;
#line 160
    if (! (i < 26)) {
#line 160
      goto while_break;
    }
    {
#line 161
    part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->a[i], 1, (int )((a >> i) & 1U));
#line 160
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 162
  return;
}
}
#line 164 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sh7750r.c"
static void set_data_in___4(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;

  {
#line 168
  p = bus___0->part;
#line 170
  i = 0;
  {
#line 170
  while (1) {
    while_continue: /* CIL Label */ ;
#line 170
    if (! (i < 32)) {
#line 170
      goto while_break;
    }
    {
#line 171
    part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->d[i], 0, 0);
#line 170
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 172
  return;
}
}
#line 174 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sh7750r.c"
static void setup_data___4(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;

  {
#line 178
  p = bus___0->part;
#line 180
  i = 0;
  {
#line 180
  while (1) {
    while_continue: /* CIL Label */ ;
#line 180
    if (! (i < 32)) {
#line 180
      goto while_break;
    }
    {
#line 181
    part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->d[i], 1, (int )((d >> i) & 1U));
#line 180
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 182
  return;
}
}
#line 188 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sh7750r.c"
static void sh7750r_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  int cs[8] ;
  int i ;
  void *__cil_tmp6 ;

  {
#line 191
  p = bus___0->part;
#line 195
  i = 0;
  {
#line 195
  while (1) {
    while_continue: /* CIL Label */ ;
#line 195
    if (! (i < 8)) {
#line 195
      goto while_break;
    }
#line 196
    cs[i] = 1;
#line 195
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 197
  cs[(adr & 469762048U) >> 26] = 0;
#line 199
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[0], 1, cs[0]);
#line 200
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[1], 1, cs[1]);
#line 201
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[2], 1, cs[2]);
#line 202
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[3], 1, cs[3]);
#line 203
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[4], 1, cs[4]);
#line 204
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[5], 1, cs[5]);
#line 205
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[6], 1, cs[6]);
#line 206
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->rdwr, 1, 1);
#line 207
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->rdwr2, 1, 1);
#line 208
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[0], 1, 1);
#line 209
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[1], 1, 1);
#line 210
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[2], 1, 1);
#line 211
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[3], 1, 1);
#line 212
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->rd, 1, 0);
#line 213
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->rd2, 1, 0);
#line 215
  setup_address___4(bus___0, adr);
#line 216
  set_data_in___4(bus___0);
#line 217
  chain_shift_data_registers(bus___0->chain, 0);
  }
#line 218
  return;
}
}
#line 224 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sh7750r.c"
static uint32_t sh7750r_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 227
  p = bus___0->part;
#line 229
  d = (uint32_t )0;
#line 231
  setup_address___4(bus___0, adr);
#line 232
  chain_shift_data_registers(bus___0->chain, 1);
#line 234
  i = 0;
  }
  {
#line 234
  while (1) {
    while_continue: /* CIL Label */ ;
#line 234
    if (! (i < 32)) {
#line 234
      goto while_break;
    }
    {
#line 235
    tmp = part_get_signal(p, ((bus_params_t___4 *)bus___0->params)->d[i]);
#line 235
    d |= (uint32_t )(tmp << i);
#line 234
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 237
  return (d);
}
}
#line 244 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sh7750r.c"
static uint32_t sh7750r_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  int cs[8] ;
  int i ;
  uint32_t d ;
  int tmp ;
  void *__cil_tmp7 ;

  {
#line 247
  p = bus___0->part;
#line 250
  d = (uint32_t )0;
#line 252
  i = 0;
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
#line 252
    if (! (i < 8)) {
#line 252
      goto while_break;
    }
#line 253
    cs[i] = 1;
#line 252
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 255
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[0], 1, cs[0]);
#line 256
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[1], 1, cs[1]);
#line 257
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[2], 1, cs[2]);
#line 258
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[3], 1, cs[3]);
#line 259
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[4], 1, cs[4]);
#line 260
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[5], 1, cs[5]);
#line 261
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[6], 1, cs[6]);
#line 263
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->rd, 1, 1);
#line 264
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->rd2, 1, 1);
#line 265
  chain_shift_data_registers(bus___0->chain, 1);
#line 267
  i = 0;
  }
  {
#line 267
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 267
    if (! (i < 32)) {
#line 267
      goto while_break___0;
    }
    {
#line 268
    tmp = part_get_signal(p, ((bus_params_t___4 *)bus___0->params)->d[i]);
#line 268
    d |= (uint32_t )(tmp << i);
#line 267
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 270
  return (d);
}
}
#line 277 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sh7750r.c"
static void sh7750r_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  chain_t *chain ;
  part_t *p ;
  int cs[8] ;
  int i ;
  void *__cil_tmp8 ;

  {
#line 280
  chain = bus___0->chain;
#line 281
  p = bus___0->part;
#line 285
  i = 0;
  {
#line 285
  while (1) {
    while_continue: /* CIL Label */ ;
#line 285
    if (! (i < 8)) {
#line 285
      goto while_break;
    }
#line 286
    cs[i] = 1;
#line 285
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 287
  cs[(adr & 469762048U) >> 26] = 0;
#line 289
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[0], 1, cs[0]);
#line 290
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[1], 1, cs[1]);
#line 291
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[2], 1, cs[2]);
#line 292
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[3], 1, cs[3]);
#line 293
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[4], 1, cs[4]);
#line 294
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[5], 1, cs[5]);
#line 295
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[6], 1, cs[6]);
#line 297
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->rdwr, 1, 0);
#line 298
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->rdwr2, 1, 0);
#line 299
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[0], 1, 1);
#line 300
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[1], 1, 1);
#line 301
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[2], 1, 1);
#line 302
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[3], 1, 1);
#line 303
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->rd, 1, 1);
#line 304
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->rd2, 1, 1);
#line 306
  setup_address___4(bus___0, adr);
#line 307
  setup_data___4(bus___0, data);
#line 309
  chain_shift_data_registers(chain, 0);
#line 311
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[0], 1, 0);
#line 312
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[1], 1, 0);
#line 313
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[2], 1, 0);
#line 314
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[3], 1, 0);
#line 316
  chain_shift_data_registers(chain, 0);
#line 318
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[0], 1, 1);
#line 319
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[1], 1, 1);
#line 320
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[2], 1, 1);
#line 321
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[3], 1, 1);
#line 323
  chain_shift_data_registers(chain, 0);
  }
#line 324
  return;
}
}
#line 326 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sh7750r.c"
struct bus_driver  const  sh7750r_bus  = 
#line 326
     {"sh7750r", "Hitachi SH7750R compatible bus driver via BSR", & sh7750r_bus_new,
    & generic_bus_free, & sh7750r_bus_printinfo, & generic_bus_prepare_extest, & sh7750r_bus_area,
    & sh7750r_bus_read_start, & sh7750r_bus_read_next, & sh7750r_bus_read_end, & generic_bus_read,
    & sh7750r_bus_write, & generic_bus_no_init};
#line 56 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/buses.h"
struct bus_driver  const  sh7727_bus ;
#line 64 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sh7727.c"
static bus_t *sh7727_bus_new(chain_t *chain , bus_driver_t const   *driver , char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  part_t *part ;
  char buff[10] ;
  int i ;
  int failed ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  void *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
  {
#line 71
  failed = 0;
#line 73
  tmp = calloc((size_t )1, (size_t )sizeof(bus_t ));
#line 73
  bus___0 = (bus_t *)tmp;
  }
#line 74
  if (! bus___0) {
#line 75
    return ((bus_t *)((void *)0));
  }
  {
#line 77
  bus___0->driver = driver;
#line 78
  bus___0->params = calloc((size_t )1, (size_t )sizeof(bus_params_t___5 ));
  }
#line 79
  if (! bus___0->params) {
    {
#line 80
    free((void *)bus___0);
    }
#line 81
    return ((bus_t *)((void *)0));
  }
#line 84
  bus___0->chain = chain;
#line 85
  part = *((chain->parts)->parts + chain->active_part);
#line 85
  bus___0->part = part;
#line 87
  i = 0;
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
#line 87
    if (! (i < 26)) {
#line 87
      goto while_break;
    }
    {
#line 88
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"A%d",
            i);
#line 89
    tmp___0 = generic_bus_attach_sig(part, & ((bus_params_t___5 *)bus___0->params)->a[i],
                                     buff);
#line 89
    failed |= tmp___0;
#line 87
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  i = 0;
  {
#line 92
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 92
    if (! (i < 32)) {
#line 92
      goto while_break___0;
    }
    {
#line 93
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"D%d",
            i);
#line 94
    tmp___1 = generic_bus_attach_sig(part, & ((bus_params_t___5 *)bus___0->params)->d[i],
                                     buff);
#line 94
    failed |= tmp___1;
#line 92
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 97
  i = 0;
  {
#line 97
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 97
    if (! (i < 7)) {
#line 97
      goto while_break___1;
    }
#line 98
    if (i == 1) {
#line 99
      goto __Cont;
    }
    {
#line 100
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"CS%d",
            i);
#line 101
    tmp___2 = generic_bus_attach_sig(part, & ((bus_params_t___5 *)bus___0->params)->cs[i],
                                     buff);
#line 101
    failed |= tmp___2;
    }
    __Cont: /* CIL Label */ 
#line 97
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 104
  i = 0;
  {
#line 104
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 104
    if (! (i < 4)) {
#line 104
      goto while_break___2;
    }
    {
#line 105
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"WE%d",
            i);
#line 106
    tmp___3 = generic_bus_attach_sig(part, & ((bus_params_t___5 *)bus___0->params)->we[i],
                                     buff);
#line 106
    failed |= tmp___3;
#line 104
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 109
  tmp___4 = generic_bus_attach_sig(part, & ((bus_params_t___5 *)bus___0->params)->rdwr,
                                   (char *)"RDWR");
#line 109
  failed |= tmp___4;
#line 111
  tmp___5 = generic_bus_attach_sig(part, & ((bus_params_t___5 *)bus___0->params)->rd,
                                   (char *)"RD");
#line 111
  failed |= tmp___5;
#line 113
  tmp___6 = generic_bus_attach_sig(part, & ((bus_params_t___5 *)bus___0->params)->md3,
                                   (char *)"MD3");
#line 113
  failed |= tmp___6;
#line 115
  tmp___7 = generic_bus_attach_sig(part, & ((bus_params_t___5 *)bus___0->params)->md4,
                                   (char *)"MD4");
#line 115
  failed |= tmp___7;
  }
#line 117
  if (failed) {
    {
#line 118
    free(bus___0->params);
#line 119
    free((void *)bus___0);
    }
#line 120
    return ((bus_t *)((void *)0));
  }
#line 123
  return (bus___0);
}
}
#line 130 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sh7727.c"
static void sh7727_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;
  char *__cil_tmp4 ;

  {
#line 135
  i = 0;
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 135
    if (! (i < ((bus___0->chain)->parts)->len)) {
#line 135
      goto while_break;
    }
#line 136
    if ((unsigned long )bus___0->part == (unsigned long )*(((bus___0->chain)->parts)->parts + i)) {
#line 137
      goto while_break;
    }
#line 135
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 138
  tmp = gettext("Hitachi SH7727 compatible bus driver via BSR (JTAG part No. %d)\n");
#line 138
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 139
  return;
}
}
#line 145 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sh7727.c"
static int sh7727_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area___0 ) 
{ 
  part_t *p ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp8 ;

  {
  {
#line 148
  p = bus___0->part;
#line 150
  area___0->description = (char const   *)((void *)0);
#line 151
  area___0->start = 0U;
#line 152
  area___0->length = 4294967296ULL;
#line 154
  tmp = part_get_signal(p, ((bus_params_t___5 *)bus___0->params)->md4);
#line 154
  tmp___0 = part_get_signal(p, ((bus_params_t___5 *)bus___0->params)->md3);
  }
  {
#line 155
  if (((tmp << 1) | tmp___0) == 1) {
#line 155
    goto case_1;
  }
#line 158
  if (((tmp << 1) | tmp___0) == 2) {
#line 158
    goto case_2;
  }
#line 161
  if (((tmp << 1) | tmp___0) == 3) {
#line 161
    goto case_3;
  }
#line 164
  goto switch_default;
  case_1: /* CIL Label */ 
#line 156
  area___0->width = 8U;
#line 157
  return (0);
  case_2: /* CIL Label */ 
#line 159
  area___0->width = 16U;
#line 160
  return (0);
  case_3: /* CIL Label */ 
#line 162
  area___0->width = 32U;
#line 163
  return (0);
  switch_default: /* CIL Label */ 
  {
#line 165
  tmp___1 = gettext("Error: Invalid bus width (MD3 = MD4 = 0)!\n");
#line 165
  printf((char const   */* __restrict  */)tmp___1);
#line 166
  area___0->width = 0U;
  }
#line 167
  return (1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 171 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sh7727.c"
static void setup_address___5(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 175
  p = bus___0->part;
#line 177
  i = 0;
  {
#line 177
  while (1) {
    while_continue: /* CIL Label */ ;
#line 177
    if (! (i < 26)) {
#line 177
      goto while_break;
    }
    {
#line 178
    part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->a[i], 1, (int )((a >> i) & 1U));
#line 177
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 179
  return;
}
}
#line 181 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sh7727.c"
static void set_data_in___5(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area___0 ;

  {
  {
#line 185
  p = bus___0->part;
#line 188
  sh7727_bus_area(bus___0, (uint32_t )0, & area___0);
#line 190
  i = 0;
  }
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;
#line 190
    if (! ((unsigned int )i < area___0.width)) {
#line 190
      goto while_break;
    }
    {
#line 191
    part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->d[i], 0, 0);
#line 190
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 192
  return;
}
}
#line 194 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sh7727.c"
static void setup_data___5(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area___0 ;

  {
  {
#line 198
  p = bus___0->part;
#line 201
  sh7727_bus_area(bus___0, (uint32_t )0, & area___0);
#line 203
  i = 0;
  }
  {
#line 203
  while (1) {
    while_continue: /* CIL Label */ ;
#line 203
    if (! ((unsigned int )i < area___0.width)) {
#line 203
      goto while_break;
    }
    {
#line 204
    part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->d[i], 1, (int )((d >> i) & 1U));
#line 203
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 205
  return;
}
}
#line 211 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sh7727.c"
static void sh7727_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  int cs[8] ;
  int i ;
  void *__cil_tmp6 ;

  {
#line 214
  p = bus___0->part;
#line 218
  i = 0;
  {
#line 218
  while (1) {
    while_continue: /* CIL Label */ ;
#line 218
    if (! (i < 8)) {
#line 218
      goto while_break;
    }
#line 219
    cs[i] = 1;
#line 218
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 220
  cs[(adr & 469762048U) >> 26] = 0;
#line 222
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[0], 1, cs[0]);
#line 223
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[2], 1, cs[2]);
#line 224
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[3], 1, cs[3]);
#line 225
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[4], 1, cs[4]);
#line 226
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[5], 1, cs[5]);
#line 227
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[6], 1, cs[6]);
#line 228
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->rdwr, 1, 1);
#line 229
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[0], 1, 1);
#line 230
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[1], 1, 1);
#line 231
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[2], 1, 1);
#line 232
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[3], 1, 1);
#line 233
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->rd, 1, 0);
#line 235
  setup_address___5(bus___0, adr);
#line 236
  set_data_in___5(bus___0);
#line 238
  chain_shift_data_registers(bus___0->chain, 0);
  }
#line 239
  return;
}
}
#line 245 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sh7727.c"
static uint32_t sh7727_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  int i ;
  uint32_t d ;
  bus_area_t area___0 ;
  int tmp ;

  {
  {
#line 248
  p = bus___0->part;
#line 250
  d = (uint32_t )0;
#line 253
  sh7727_bus_area(bus___0, (uint32_t )0, & area___0);
#line 255
  setup_address___5(bus___0, adr);
#line 256
  chain_shift_data_registers(bus___0->chain, 1);
#line 258
  i = 0;
  }
  {
#line 258
  while (1) {
    while_continue: /* CIL Label */ ;
#line 258
    if (! ((unsigned int )i < area___0.width)) {
#line 258
      goto while_break;
    }
    {
#line 259
    tmp = part_get_signal(p, ((bus_params_t___5 *)bus___0->params)->d[i]);
#line 259
    d |= (uint32_t )(tmp << i);
#line 258
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 261
  return (d);
}
}
#line 268 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sh7727.c"
static uint32_t sh7727_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  int i ;
  uint32_t d ;
  bus_area_t area___0 ;
  int tmp ;

  {
  {
#line 271
  p = bus___0->part;
#line 273
  d = (uint32_t )0;
#line 276
  sh7727_bus_area(bus___0, (uint32_t )0, & area___0);
#line 278
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[0], 1, 1);
#line 279
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[2], 1, 1);
#line 280
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[3], 1, 1);
#line 281
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[4], 1, 1);
#line 282
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[5], 1, 1);
#line 283
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[6], 1, 1);
#line 285
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->rd, 1, 1);
#line 286
  chain_shift_data_registers(bus___0->chain, 1);
#line 288
  i = 0;
  }
  {
#line 288
  while (1) {
    while_continue: /* CIL Label */ ;
#line 288
    if (! ((unsigned int )i < area___0.width)) {
#line 288
      goto while_break;
    }
    {
#line 289
    tmp = part_get_signal(p, ((bus_params_t___5 *)bus___0->params)->d[i]);
#line 289
    d |= (uint32_t )(tmp << i);
#line 288
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 291
  return (d);
}
}
#line 298 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sh7727.c"
static void sh7727_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  chain_t *chain ;
  part_t *p ;
  int cs[8] ;
  int i ;
  void *__cil_tmp8 ;

  {
#line 301
  chain = bus___0->chain;
#line 302
  p = bus___0->part;
#line 306
  i = 0;
  {
#line 306
  while (1) {
    while_continue: /* CIL Label */ ;
#line 306
    if (! (i < 8)) {
#line 306
      goto while_break;
    }
#line 307
    cs[i] = 1;
#line 306
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 308
  cs[(adr & 469762048U) >> 26] = 0;
#line 310
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[0], 1, cs[0]);
#line 311
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[2], 1, cs[2]);
#line 312
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[3], 1, cs[3]);
#line 313
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[4], 1, cs[4]);
#line 314
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[5], 1, cs[5]);
#line 315
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[6], 1, cs[6]);
#line 317
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->rdwr, 1, 0);
#line 318
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[0], 1, 1);
#line 319
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[1], 1, 1);
#line 320
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[2], 1, 1);
#line 321
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[3], 1, 1);
#line 322
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->rd, 1, 1);
#line 324
  setup_address___5(bus___0, adr);
#line 325
  setup_data___5(bus___0, data);
#line 327
  chain_shift_data_registers(chain, 0);
#line 329
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[0], 1, 0);
#line 330
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[1], 1, 0);
#line 331
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[2], 1, 0);
#line 332
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[3], 1, 0);
#line 334
  chain_shift_data_registers(chain, 0);
#line 336
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[0], 1, 1);
#line 337
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[1], 1, 1);
#line 338
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[2], 1, 1);
#line 339
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[3], 1, 1);
#line 341
  chain_shift_data_registers(chain, 0);
  }
#line 342
  return;
}
}
#line 344 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sh7727.c"
struct bus_driver  const  sh7727_bus  = 
#line 344
     {"sh7727", "Hitachi SH7727 compatible bus driver via BSR", & sh7727_bus_new, & generic_bus_free,
    & sh7727_bus_printinfo, & generic_bus_prepare_extest, & sh7727_bus_area, & sh7727_bus_read_start,
    & sh7727_bus_read_next, & sh7727_bus_read_end, & generic_bus_read, & sh7727_bus_write,
    & generic_bus_no_init};
#line 62 "../../include/part.h"
signal_t *part_find_signal(part_t *p , char const   *signalname ) ;
#line 55 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/buses.h"
struct bus_driver  const  sa1110_bus ;
#line 63 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sa1110.c"
static bus_t *sa1110_bus_new(chain_t *chain , bus_driver_t const   *driver , char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  part_t *part ;
  char buff[10] ;
  int i ;
  int failed ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
  {
#line 70
  failed = 0;
#line 72
  tmp = calloc((size_t )1, (size_t )sizeof(bus_t ));
#line 72
  bus___0 = (bus_t *)tmp;
  }
#line 73
  if (! bus___0) {
#line 74
    return ((bus_t *)((void *)0));
  }
  {
#line 76
  bus___0->driver = driver;
#line 77
  bus___0->params = calloc((size_t )1, (size_t )sizeof(bus_params_t___6 ));
  }
#line 78
  if (! bus___0->params) {
    {
#line 79
    free((void *)bus___0);
    }
#line 80
    return ((bus_t *)((void *)0));
  }
#line 83
  bus___0->chain = chain;
#line 84
  part = *((chain->parts)->parts + chain->active_part);
#line 84
  bus___0->part = part;
#line 86
  i = 0;
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
#line 86
    if (! (i < 26)) {
#line 86
      goto while_break;
    }
    {
#line 87
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"A%d",
            i);
#line 88
    tmp___0 = generic_bus_attach_sig(part, & ((bus_params_t___6 *)bus___0->params)->a[i],
                                     buff);
#line 88
    failed |= tmp___0;
#line 86
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 91
  i = 0;
  {
#line 91
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 91
    if (! (i < 32)) {
#line 91
      goto while_break___0;
    }
    {
#line 92
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"D%d",
            i);
#line 93
    tmp___1 = generic_bus_attach_sig(part, & ((bus_params_t___6 *)bus___0->params)->d[i],
                                     buff);
#line 93
    failed |= tmp___1;
#line 91
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 96
  i = 0;
  {
#line 96
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 96
    if (! (i < 6)) {
#line 96
      goto while_break___1;
    }
    {
#line 97
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"nCS%d",
            i);
#line 98
    tmp___2 = generic_bus_attach_sig(part, & ((bus_params_t___6 *)bus___0->params)->ncs[i],
                                     buff);
#line 98
    failed |= tmp___2;
#line 96
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 101
  tmp___3 = generic_bus_attach_sig(part, & ((bus_params_t___6 *)bus___0->params)->rd_nwr,
                                   (char *)"RD_nWR");
#line 101
  failed |= tmp___3;
#line 103
  tmp___4 = generic_bus_attach_sig(part, & ((bus_params_t___6 *)bus___0->params)->nwe,
                                   (char *)"nWE");
#line 103
  failed |= tmp___4;
#line 105
  tmp___5 = generic_bus_attach_sig(part, & ((bus_params_t___6 *)bus___0->params)->noe,
                                   (char *)"nOE");
#line 105
  failed |= tmp___5;
  }
#line 107
  if (failed) {
    {
#line 108
    free(bus___0->params);
#line 109
    free((void *)bus___0);
    }
#line 110
    return ((bus_t *)((void *)0));
  }
#line 113
  return (bus___0);
}
}
#line 120 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sa1110.c"
static void sa1110_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;
  char *__cil_tmp4 ;

  {
#line 125
  i = 0;
  {
#line 125
  while (1) {
    while_continue: /* CIL Label */ ;
#line 125
    if (! (i < ((bus___0->chain)->parts)->len)) {
#line 125
      goto while_break;
    }
#line 126
    if ((unsigned long )bus___0->part == (unsigned long )*(((bus___0->chain)->parts)->parts + i)) {
#line 127
      goto while_break;
    }
#line 125
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 128
  tmp = gettext("Intel SA-1110 compatible bus driver via BSR (JTAG part No. %d)\n");
#line 128
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 129
  return;
}
}
#line 135 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sa1110.c"
static int sa1110_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area___0 ) 
{ 
  signal_t *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp8 ;

  {
  {
#line 138
  area___0->description = (char const   *)((void *)0);
#line 139
  area___0->start = 0U;
#line 140
  area___0->length = 4294967296ULL;
#line 141
  tmp___1 = part_find_signal(bus___0->part, "ROM_SEL");
#line 141
  tmp___2 = part_get_signal(bus___0->part, tmp___1);
  }
#line 141
  if (tmp___2) {
#line 141
    area___0->width = 32U;
  } else {
#line 141
    area___0->width = 16U;
  }
#line 143
  return (0);
}
}
#line 146 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sa1110.c"
static void setup_address___6(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 150
  p = bus___0->part;
#line 152
  i = 0;
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 152
    if (! (i < 26)) {
#line 152
      goto while_break;
    }
    {
#line 153
    part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->a[i], 1, (int )((a >> i) & 1U));
#line 152
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 154
  return;
}
}
#line 156 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sa1110.c"
static void set_data_in___6(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area___0 ;

  {
  {
#line 160
  p = bus___0->part;
#line 163
  sa1110_bus_area(bus___0, (uint32_t )0, & area___0);
#line 165
  i = 0;
  }
  {
#line 165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 165
    if (! ((unsigned int )i < area___0.width)) {
#line 165
      goto while_break;
    }
    {
#line 166
    part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->d[i], 0, 0);
#line 165
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 167
  return;
}
}
#line 169 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sa1110.c"
static void setup_data___6(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area___0 ;

  {
  {
#line 173
  p = bus___0->part;
#line 176
  sa1110_bus_area(bus___0, (uint32_t )0, & area___0);
#line 178
  i = 0;
  }
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
#line 178
    if (! ((unsigned int )i < area___0.width)) {
#line 178
      goto while_break;
    }
    {
#line 179
    part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->d[i], 1, (int )((d >> i) & 1U));
#line 178
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 180
  return;
}
}
#line 186 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sa1110.c"
static void sa1110_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
  {
#line 190
  p = bus___0->part;
#line 191
  chain = bus___0->chain;
#line 193
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[0], 1, adr >> 27 != 0U);
#line 194
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[1], 1, adr >> 27 != 1U);
#line 195
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[2], 1, adr >> 27 != 2U);
#line 196
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[3], 1, adr >> 27 != 3U);
#line 197
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[4], 1, adr >> 27 != 8U);
#line 198
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[5], 1, adr >> 27 != 9U);
#line 199
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->rd_nwr, 1, 1);
#line 200
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->nwe, 1, 1);
#line 201
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->noe, 1, 0);
#line 203
  setup_address___6(bus___0, adr);
#line 204
  set_data_in___6(bus___0);
#line 206
  chain_shift_data_registers(chain, 0);
  }
#line 207
  return;
}
}
#line 213 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sa1110.c"
static uint32_t sa1110_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  bus_area_t area___0 ;
  int tmp ;

  {
  {
#line 217
  p = bus___0->part;
#line 218
  chain = bus___0->chain;
#line 220
  d = (uint32_t )0;
#line 223
  sa1110_bus_area(bus___0, adr, & area___0);
#line 225
  setup_address___6(bus___0, adr);
#line 226
  chain_shift_data_registers(chain, 1);
#line 228
  i = 0;
  }
  {
#line 228
  while (1) {
    while_continue: /* CIL Label */ ;
#line 228
    if (! ((unsigned int )i < area___0.width)) {
#line 228
      goto while_break;
    }
    {
#line 229
    tmp = part_get_signal(p, ((bus_params_t___6 *)bus___0->params)->d[i]);
#line 229
    d |= (uint32_t )(tmp << i);
#line 228
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 231
  return (d);
}
}
#line 238 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sa1110.c"
static uint32_t sa1110_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  bus_area_t area___0 ;
  int tmp ;

  {
  {
#line 242
  p = bus___0->part;
#line 243
  chain = bus___0->chain;
#line 245
  d = (uint32_t )0;
#line 248
  sa1110_bus_area(bus___0, (uint32_t )0, & area___0);
#line 250
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[0], 1, 1);
#line 251
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[1], 1, 1);
#line 252
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[2], 1, 1);
#line 253
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[3], 1, 1);
#line 254
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[4], 1, 1);
#line 255
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[5], 1, 1);
#line 256
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->noe, 1, 1);
#line 257
  chain_shift_data_registers(chain, 1);
#line 259
  i = 0;
  }
  {
#line 259
  while (1) {
    while_continue: /* CIL Label */ ;
#line 259
    if (! ((unsigned int )i < area___0.width)) {
#line 259
      goto while_break;
    }
    {
#line 260
    tmp = part_get_signal(p, ((bus_params_t___6 *)bus___0->params)->d[i]);
#line 260
    d |= (uint32_t )(tmp << i);
#line 259
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 262
  return (d);
}
}
#line 269 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sa1110.c"
static void sa1110_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
  {
#line 273
  p = bus___0->part;
#line 274
  chain = bus___0->chain;
#line 276
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[0], 1, adr >> 27 != 0U);
#line 277
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[1], 1, adr >> 27 != 1U);
#line 278
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[2], 1, adr >> 27 != 2U);
#line 279
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[3], 1, adr >> 27 != 3U);
#line 280
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[4], 1, adr >> 27 != 8U);
#line 281
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[5], 1, adr >> 27 != 9U);
#line 282
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->rd_nwr, 1, 0);
#line 283
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->nwe, 1, 1);
#line 284
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->noe, 1, 1);
#line 286
  setup_address___6(bus___0, adr);
#line 287
  setup_data___6(bus___0, data);
#line 289
  chain_shift_data_registers(chain, 0);
#line 291
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->nwe, 1, 0);
#line 292
  chain_shift_data_registers(chain, 0);
#line 293
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->nwe, 1, 1);
#line 294
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[0], 1, 1);
#line 295
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[1], 1, 1);
#line 296
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[2], 1, 1);
#line 297
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[3], 1, 1);
#line 298
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[4], 1, 1);
#line 299
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[5], 1, 1);
#line 300
  chain_shift_data_registers(chain, 0);
  }
#line 301
  return;
}
}
#line 303 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/sa1110.c"
struct bus_driver  const  sa1110_bus  = 
#line 303
     {"sa1110", "Intel SA-1110 compatible bus driver via BSR", & sa1110_bus_new, & generic_bus_free,
    & sa1110_bus_printinfo, & generic_bus_prepare_extest, & sa1110_bus_area, & sa1110_bus_read_start,
    & sa1110_bus_read_next, & sa1110_bus_read_end, & generic_bus_read, & sa1110_bus_write,
    & generic_bus_no_init};
#line 54 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/buses.h"
struct bus_driver  const  s3c4510_bus ;
#line 104 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/s3c4510x.c"
static bus_t *s3c4510_bus_new(chain_t *chain , bus_driver_t const   *driver , char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  part_t *part ;
  char buff[10] ;
  int i ;
  int failed ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
  {
#line 111
  failed = 0;
#line 113
  tmp = calloc((size_t )1, (size_t )sizeof(bus_t ));
#line 113
  bus___0 = (bus_t *)tmp;
  }
#line 114
  if (! bus___0) {
#line 115
    return ((bus_t *)((void *)0));
  }
  {
#line 117
  bus___0->driver = driver;
#line 118
  bus___0->params = calloc((size_t )1, (size_t )sizeof(bus_params_t___7 ));
  }
#line 119
  if (! bus___0->params) {
    {
#line 120
    free((void *)bus___0);
    }
#line 121
    return ((bus_t *)((void *)0));
  }
#line 125
  ((bus_params_t___7 *)bus___0->params)->dbuswidth = 16;
#line 126
  bus___0->chain = chain;
#line 127
  part = *((chain->parts)->parts + chain->active_part);
#line 127
  bus___0->part = part;
#line 129
  i = 0;
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
#line 129
    if (! (i < 22)) {
#line 129
      goto while_break;
    }
    {
#line 130
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"ADDR%d",
            i);
#line 131
    tmp___0 = generic_bus_attach_sig(part, & ((bus_params_t___7 *)bus___0->params)->a[i],
                                     buff);
#line 131
    failed |= tmp___0;
#line 129
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 134
  i = 0;
  {
#line 134
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 134
    if (! (i < 32)) {
#line 134
      goto while_break___0;
    }
    {
#line 135
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"XDATA%d",
            i);
#line 136
    tmp___1 = generic_bus_attach_sig(part, & ((bus_params_t___7 *)bus___0->params)->d[i],
                                     buff);
#line 136
    failed |= tmp___1;
#line 134
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 139
  i = 0;
  {
#line 139
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 139
    if (! (i < 6)) {
#line 139
      goto while_break___1;
    }
    {
#line 140
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"nRCS%d",
            i);
#line 141
    tmp___2 = generic_bus_attach_sig(part, & ((bus_params_t___7 *)bus___0->params)->nrcs[i],
                                     buff);
#line 141
    failed |= tmp___2;
#line 139
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 144
  i = 0;
  {
#line 144
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 144
    if (! (i < 4)) {
#line 144
      goto while_break___2;
    }
    {
#line 145
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"nECS%d",
            i);
#line 146
    tmp___3 = generic_bus_attach_sig(part, & ((bus_params_t___7 *)bus___0->params)->necs[i],
                                     buff);
#line 146
    failed |= tmp___3;
#line 144
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 149
  i = 0;
  {
#line 149
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 149
    if (! (i < 4)) {
#line 149
      goto while_break___3;
    }
    {
#line 150
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"nRAS%d",
            i);
#line 151
    tmp___4 = generic_bus_attach_sig(part, & ((bus_params_t___7 *)bus___0->params)->nsdcs[i],
                                     buff);
#line 151
    failed |= tmp___4;
#line 149
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 154
  i = 0;
  {
#line 154
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 154
    if (! (i < 4)) {
#line 154
      goto while_break___4;
    }
    {
#line 155
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"nWBE%d",
            i);
#line 156
    tmp___5 = generic_bus_attach_sig(part, & ((bus_params_t___7 *)bus___0->params)->nwbe[i],
                                     buff);
#line 156
    failed |= tmp___5;
#line 154
    i ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 159
  tmp___6 = generic_bus_attach_sig(part, & ((bus_params_t___7 *)bus___0->params)->noe,
                                   (char *)"nOE");
#line 159
  failed |= tmp___6;
  }
#line 161
  if (failed) {
    {
#line 162
    free(bus___0->params);
#line 163
    free((void *)bus___0);
    }
#line 164
    return ((bus_t *)((void *)0));
  }
#line 167
  return (bus___0);
}
}
#line 174 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/s3c4510x.c"
static void s3c4510_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;
  char *__cil_tmp4 ;

  {
#line 179
  i = 0;
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 179
    if (! (i < ((bus___0->chain)->parts)->len)) {
#line 179
      goto while_break;
    }
#line 180
    if ((unsigned long )bus___0->part == (unsigned long )*(((bus___0->chain)->parts)->parts + i)) {
#line 181
      goto while_break;
    }
#line 179
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 182
  tmp = gettext("Samsung S3C4510B compatibile bus driver via BSR (JTAG part No. %d) RCS0=%ubit\n");
#line 182
  printf((char const   */* __restrict  */)tmp, i, ((bus_params_t___7 *)bus___0->params)->dbuswidth);
  }
#line 183
  return;
}
}
#line 189 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/s3c4510x.c"
static int s3c4510_bus_init(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int tmp ;
  char *__cil_tmp5 ;

  {
  {
#line 192
  p = bus___0->part;
#line 193
  chain = bus___0->chain;
#line 195
  tmp = tap_state(chain);
  }
#line 195
  if (tmp != 1 << 3) {
#line 200
    return (0);
  }
  {
#line 203
  part_set_instruction(p, "SAMPLE/PRELOAD");
#line 204
  chain_shift_instructions(chain);
#line 205
  chain_shift_data_registers(chain, 0);
#line 207
  bus___0->initialized = 1;
  }
#line 209
  return (0);
}
}
#line 216 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/s3c4510x.c"
static int s3c4510_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area___0 ) 
{ 
  int b0size0 ;
  int b0size1 ;
  signal_t *tmp ;
  signal_t *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 221
  area___0->description = (char const   *)((void *)0);
#line 222
  area___0->start = 0U;
#line 223
  area___0->length = 4294967296ULL;
#line 226
  tmp = part_find_signal(bus___0->part, "B0SIZE0");
#line 226
  b0size0 = part_get_signal(bus___0->part, tmp);
#line 227
  tmp___0 = part_find_signal(bus___0->part, "B0SIZE1");
#line 227
  b0size1 = part_get_signal(bus___0->part, tmp___0);
  }
  {
#line 230
  if (((b0size1 << 1) | b0size0) == 1) {
#line 230
    goto case_1;
  }
#line 233
  if (((b0size1 << 1) | b0size0) == 2) {
#line 233
    goto case_2;
  }
#line 236
  if (((b0size1 << 1) | b0size0) == 3) {
#line 236
    goto case_3;
  }
#line 239
  goto switch_default;
  case_1: /* CIL Label */ 
#line 231
  tmp___1 = 8;
#line 231
  ((bus_params_t___7 *)bus___0->params)->dbuswidth = tmp___1;
#line 231
  area___0->width = (unsigned int )tmp___1;
#line 232
  return (0);
  case_2: /* CIL Label */ 
#line 234
  tmp___2 = 16;
#line 234
  ((bus_params_t___7 *)bus___0->params)->dbuswidth = tmp___2;
#line 234
  area___0->width = (unsigned int )tmp___2;
#line 235
  return (0);
  case_3: /* CIL Label */ 
#line 237
  tmp___3 = 32;
#line 237
  ((bus_params_t___7 *)bus___0->params)->dbuswidth = tmp___3;
#line 237
  area___0->width = (unsigned int )tmp___3;
#line 238
  return (0);
  switch_default: /* CIL Label */ 
  {
#line 240
  printf((char const   */* __restrict  */)"B0SIZE[1:0]: Unknown\n");
#line 241
  area___0->width = 0U;
  }
#line 242
  return (1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 246 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/s3c4510x.c"
static void s3c4510_bus_setup_ctrl(bus_t *bus___0 , int mode ) 
{ 
  int k ;
  part_t *p ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 249
  p = bus___0->part;
#line 251
  k = 0;
  {
#line 251
  while (1) {
    while_continue: /* CIL Label */ ;
#line 251
    if (! (k < 6)) {
#line 251
      goto while_break;
    }
#line 252
    if (mode & (1 << k)) {
#line 252
      tmp = 1;
    } else {
#line 252
      tmp = 0;
    }
    {
#line 252
    part_set_signal(p, ((bus_params_t___7 *)bus___0->params)->nrcs[k], 1, tmp);
#line 251
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 254
  k = 0;
  {
#line 254
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 254
    if (! (k < 4)) {
#line 254
      goto while_break___0;
    }
    {
#line 255
    part_set_signal(p, ((bus_params_t___7 *)bus___0->params)->necs[k], 1, 1);
#line 254
    k ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 257
  k = 0;
  {
#line 257
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 257
    if (! (k < 4)) {
#line 257
      goto while_break___1;
    }
    {
#line 258
    part_set_signal(p, ((bus_params_t___7 *)bus___0->params)->nsdcs[k], 1, 1);
#line 257
    k ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 260
  k = 0;
  {
#line 260
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 260
    if (! (k < 4)) {
#line 260
      goto while_break___2;
    }
#line 261
    if (mode & (1 << (k + 8))) {
#line 261
      tmp___0 = 1;
    } else {
#line 261
      tmp___0 = 0;
    }
    {
#line 261
    part_set_signal(p, ((bus_params_t___7 *)bus___0->params)->nwbe[k], 1, tmp___0);
#line 260
    k ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 263
  if (mode & (1 << 16)) {
#line 263
    tmp___1 = 1;
  } else {
#line 263
    tmp___1 = 0;
  }
  {
#line 263
  part_set_signal(p, ((bus_params_t___7 *)bus___0->params)->noe, 1, tmp___1);
  }
#line 264
  return;
}
}
#line 266 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/s3c4510x.c"
static void setup_address___7(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  int so ;
  part_t *p ;

  {
#line 270
  p = bus___0->part;
  {
#line 274
  if (((bus_params_t___7 *)bus___0->params)->dbuswidth == 32) {
#line 274
    goto case_32;
  }
#line 275
  if (((bus_params_t___7 *)bus___0->params)->dbuswidth == 16) {
#line 275
    goto case_16;
  }
#line 276
  goto switch_default;
  case_32: /* CIL Label */ 
#line 274
  so = 2;
#line 274
  goto switch_break;
  case_16: /* CIL Label */ 
#line 275
  so = 1;
#line 275
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 276
  so = 0;
#line 276
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 279
  i = 0;
  {
#line 279
  while (1) {
    while_continue: /* CIL Label */ ;
#line 279
    if (! (i < 22)) {
#line 279
      goto while_break;
    }
    {
#line 280
    part_set_signal(p, ((bus_params_t___7 *)bus___0->params)->a[i], 1, (int )((a >> (i + so)) & 1U));
#line 279
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 281
  return;
}
}
#line 283 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/s3c4510x.c"
static void set_data_in___7(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;

  {
#line 287
  p = bus___0->part;
#line 289
  i = 0;
  {
#line 289
  while (1) {
    while_continue: /* CIL Label */ ;
#line 289
    if (! (i < ((bus_params_t___7 *)bus___0->params)->dbuswidth)) {
#line 289
      goto while_break;
    }
    {
#line 290
    part_set_signal(p, ((bus_params_t___7 *)bus___0->params)->d[i], 0, 0);
#line 289
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 291
  return;
}
}
#line 293 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/s3c4510x.c"
static void setup_data___7(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;

  {
#line 297
  p = bus___0->part;
#line 299
  i = 0;
  {
#line 299
  while (1) {
    while_continue: /* CIL Label */ ;
#line 299
    if (! (i < ((bus_params_t___7 *)bus___0->params)->dbuswidth)) {
#line 299
      goto while_break;
    }
    {
#line 300
    part_set_signal(p, ((bus_params_t___7 *)bus___0->params)->d[i], 1, (int )((d >> i) & 1U));
#line 299
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 302
  i = ((bus_params_t___7 *)bus___0->params)->dbuswidth;
  {
#line 302
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 302
    if (! (i < 32)) {
#line 302
      goto while_break___0;
    }
    {
#line 303
    part_set_signal(p, ((bus_params_t___7 *)bus___0->params)->d[i], 1, 0);
#line 302
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 304
  return;
}
}
#line 310 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/s3c4510x.c"
static void s3c4510_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  chain_t *chain ;

  {
  {
#line 314
  chain = bus___0->chain;
#line 316
  s3c4510_bus_setup_ctrl(bus___0, 65534);
#line 317
  setup_address___7(bus___0, adr);
#line 318
  set_data_in___7(bus___0);
#line 319
  chain_shift_data_registers(chain, 0);
  }
#line 320
  return;
}
}
#line 326 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/s3c4510x.c"
static uint32_t s3c4510_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 330
  p = bus___0->part;
#line 331
  chain = bus___0->chain;
#line 333
  d = (uint32_t )0;
#line 335
  s3c4510_bus_setup_ctrl(bus___0, 65534);
#line 336
  setup_address___7(bus___0, adr);
#line 337
  set_data_in___7(bus___0);
#line 338
  chain_shift_data_registers(chain, 1);
#line 340
  i = 0;
  }
  {
#line 340
  while (1) {
    while_continue: /* CIL Label */ ;
#line 340
    if (! (i < ((bus_params_t___7 *)bus___0->params)->dbuswidth)) {
#line 340
      goto while_break;
    }
    {
#line 341
    tmp = part_get_signal(p, ((bus_params_t___7 *)bus___0->params)->d[i]);
#line 341
    d |= (uint32_t )(tmp << i);
#line 340
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 343
  return (d);
}
}
#line 350 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/s3c4510x.c"
static uint32_t s3c4510_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 354
  p = bus___0->part;
#line 355
  chain = bus___0->chain;
#line 357
  d = (uint32_t )0;
#line 359
  s3c4510_bus_setup_ctrl(bus___0, 131071);
#line 360
  chain_shift_data_registers(chain, 1);
#line 362
  i = 0;
  }
  {
#line 362
  while (1) {
    while_continue: /* CIL Label */ ;
#line 362
    if (! (i < ((bus_params_t___7 *)bus___0->params)->dbuswidth)) {
#line 362
      goto while_break;
    }
    {
#line 363
    tmp = part_get_signal(p, ((bus_params_t___7 *)bus___0->params)->d[i]);
#line 363
    d |= (uint32_t )(tmp << i);
#line 362
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 365
  return (d);
}
}
#line 374 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/s3c4510x.c"
static void s3c4510_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  chain_t *chain ;

  {
  {
#line 378
  chain = bus___0->chain;
#line 380
  s3c4510_bus_setup_ctrl(bus___0, 131070);
#line 381
  setup_address___7(bus___0, adr);
#line 382
  setup_data___7(bus___0, data);
#line 384
  chain_shift_data_registers(chain, 0);
  }
  {
#line 392
  if (((bus_params_t___7 *)bus___0->params)->dbuswidth == 16) {
#line 392
    goto case_16;
  }
#line 396
  if (((bus_params_t___7 *)bus___0->params)->dbuswidth == 32) {
#line 396
    goto case_32;
  }
#line 388
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 390
  s3c4510_bus_setup_ctrl(bus___0, 130814);
  }
#line 391
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 393
  s3c4510_bus_setup_ctrl(bus___0, 130302);
  }
#line 394
  goto switch_break;
  case_32: /* CIL Label */ 
  {
#line 397
  s3c4510_bus_setup_ctrl(bus___0, 127230);
  }
#line 398
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 401
  setup_address___7(bus___0, adr);
#line 402
  setup_data___7(bus___0, data);
#line 404
  chain_shift_data_registers(chain, 0);
#line 406
  s3c4510_bus_setup_ctrl(bus___0, 131071);
#line 407
  chain_shift_data_registers(chain, 0);
  }
#line 410
  return;
}
}
#line 412 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/s3c4510x.c"
struct bus_driver  const  s3c4510_bus  = 
#line 412
     {"s3c4510x", "Samsung S3C4510B compatible bus driver via BSR", & s3c4510_bus_new,
    & generic_bus_free, & s3c4510_bus_printinfo, & generic_bus_prepare_extest, & s3c4510_bus_area,
    & s3c4510_bus_read_start, & s3c4510_bus_read_next, & s3c4510_bus_read_end, & generic_bus_read,
    & s3c4510_bus_write, & s3c4510_bus_init};
#line 58 "../../include/jtag.h"
void readmem(bus_t *bus___0 , FILE *f , uint32_t addr , uint32_t len ) ;
#line 43 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/readmem.c"
void readmem(bus_t *bus___0 , FILE *f , uint32_t addr , uint32_t len ) 
{ 
  uint32_t step ;
  uint32_t a ;
  int bc ;
  uint8_t b[4096] ;
  bus_area_t area___0 ;
  uint64_t end ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  uint32_t data ;
  int j ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  void *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;

  {
#line 48
  bc = 0;
#line 54
  if (! bus___0) {
    {
#line 55
    tmp = gettext("Error: Missing bus driver!\n");
#line 55
    printf((char const   */* __restrict  */)tmp);
    }
#line 56
    return;
  }
  {
#line 59
  (*((bus___0->driver)->prepare))(bus___0);
#line 61
  tmp___1 = (*((bus___0->driver)->area))(bus___0, addr, & area___0);
  }
#line 61
  if (tmp___1 != 0) {
    {
#line 62
    tmp___0 = gettext("Error: Bus width detection failed\n");
#line 62
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 63
    return;
  }
#line 65
  step = area___0.width / 8U;
#line 67
  if (step == 0U) {
    {
#line 68
    tmp___2 = gettext("Unknown bus width!\n");
#line 68
    printf((char const   */* __restrict  */)tmp___2);
    }
#line 69
    return;
  }
  {
#line 72
  addr &= ~ (step - 1U);
#line 73
  len = ((len + step) - 1U) & ~ (step - 1U);
#line 75
  tmp___3 = gettext("address: 0x%08X\n");
#line 75
  printf((char const   */* __restrict  */)tmp___3, addr);
#line 76
  tmp___4 = gettext("length:  0x%08X\n");
#line 76
  printf((char const   */* __restrict  */)tmp___4, len);
  }
#line 78
  if (len == 0U) {
    {
#line 79
    tmp___5 = gettext("length is 0.\n");
#line 79
    printf((char const   */* __restrict  */)tmp___5);
    }
#line 80
    return;
  }
  {
#line 83
  a = addr;
#line 84
  end = (uint64_t )(a + len);
#line 85
  tmp___6 = gettext("reading:\n");
#line 85
  printf((char const   */* __restrict  */)tmp___6);
#line 86
  (*((bus___0->driver)->read_start))(bus___0, addr);
#line 87
  a += step;
  }
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
#line 87
    if (! ((uint64_t )a <= end)) {
#line 87
      goto while_break;
    }
#line 91
    if (a < addr + len) {
      {
#line 92
      data = (*((bus___0->driver)->read_next))(bus___0, a);
      }
    } else {
      {
#line 94
      data = (*((bus___0->driver)->read_end))(bus___0);
      }
    }
#line 96
    j = (int )step;
    {
#line 96
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 96
      if (! (j > 0)) {
#line 96
        goto while_break___0;
      }
#line 97
      if (big_endian) {
#line 98
        tmp___7 = bc;
#line 98
        bc ++;
#line 98
        b[tmp___7] = (uint8_t )((data >> (j - 1) * 8) & 255U);
      } else {
#line 100
        tmp___8 = bc;
#line 100
        bc ++;
#line 100
        b[tmp___8] = (uint8_t )(data & 255U);
#line 101
        data >>= 8;
      }
#line 96
      j --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 104
    if (bc >= 4096) {
#line 104
      goto _L;
    } else
#line 104
    if ((uint64_t )a >= end) {
      _L: /* CIL Label */ 
      {
#line 105
      tmp___9 = gettext("addr: 0x%08X");
#line 105
      printf((char const   */* __restrict  */)tmp___9, a);
#line 106
      printf((char const   */* __restrict  */)"\r");
#line 107
      fflush(stdout);
#line 108
      fwrite((void const   */* __restrict  */)(b), (size_t )bc, (size_t )1, (FILE */* __restrict  */)f);
#line 109
      bc = 0;
      }
    }
#line 87
    a += step;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 113
  tmp___10 = gettext("\nDone.\n");
#line 113
  printf((char const   */* __restrict  */)tmp___10);
  }
#line 114
  return;
}
}
#line 142 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
#line 52 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/buses.h"
struct bus_driver  const  pxa2x0_bus ;
#line 53
struct bus_driver  const  pxa27x_bus ;
#line 85 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/pxa2x0.c"
static ncs_map_entry pxa25x_ncs_map[6]  = {      {(char *)"nCS[0]", 1, 0, {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0}}, 
        {(char *)((void *)0), 0, 0, {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0}}, 
        {(char *)((void *)0), 0, 0, {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0}}, 
        {(char *)((void *)0), 0, 0, {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0}}, 
        {(char *)((void *)0), 0, 0, {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0}}, 
        {(char *)((void *)0), 0, 0, {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0}}};
#line 97 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/pxa2x0.c"
static ncs_map_entry pxa27x_ncs_map[6]  = {      {(char *)"nCS[0]", 1, 0, {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0}}, 
        {(char *)"GPIO[15]", 1, 16, {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0}}, 
        {(char *)"GPIO[78]", 1, 16, {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0}}, 
        {(char *)"GPIO[79]", 1, 16, {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0}}, 
        {(char *)"GPIO[80]", 1, 16, {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0}}, 
        {(char *)"GPIO[33]", 1, 16, {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0}}};
#line 141 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/pxa2x0.c"
static bus_t *pxa2xx_bus_new(chain_t *chain , bus_driver_t const   *driver , char **cmd_params___0 ) 
{ 
  part_t *part ;
  bus_t *bus___0 ;
  ncs_map_entry *ncs_map ;
  char buff[10] ;
  int i ;
  int failed ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  void *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
#line 146
  ncs_map = (ncs_map_entry *)((void *)0);
#line 149
  failed = 0;
#line 151
  if (! chain) {
#line 152
    return ((bus_t *)((void *)0));
  } else
#line 151
  if (! chain->parts) {
#line 152
    return ((bus_t *)((void *)0));
  } else
#line 151
  if ((chain->parts)->len <= chain->active_part) {
#line 152
    return ((bus_t *)((void *)0));
  } else
#line 151
  if (chain->active_part < 0) {
#line 152
    return ((bus_t *)((void *)0));
  }
  {
#line 154
  tmp = calloc((size_t )1, (size_t )sizeof(bus_t ));
#line 154
  bus___0 = (bus_t *)tmp;
  }
#line 155
  if (! bus___0) {
#line 156
    return ((bus_t *)((void *)0));
  }
  {
#line 158
  bus___0->driver = driver;
#line 159
  bus___0->params = calloc((size_t )1, (size_t )sizeof(bus_params_t___8 ));
  }
#line 160
  if (! bus___0->params) {
    {
#line 161
    free((void *)bus___0);
    }
#line 162
    return ((bus_t *)((void *)0));
  }
  {
#line 165
  bus___0->chain = chain;
#line 166
  part = *((chain->parts)->parts + chain->active_part);
#line 166
  bus___0->part = part;
#line 167
  tmp___1 = strcmp((char const   *)driver->name, "pxa2x0");
  }
#line 167
  if (tmp___1 == 0) {
#line 168
    ((bus_params_t___8 *)bus___0->params)->proc = 1;
  } else {
    {
#line 169
    tmp___0 = strcmp((char const   *)driver->name, "pxa27x");
    }
#line 169
    if (tmp___0 == 0) {
#line 170
      ((bus_params_t___8 *)bus___0->params)->proc = 2;
    } else {
      {
#line 172
      free(bus___0->params);
#line 173
      free((void *)bus___0);
      }
#line 174
      return ((bus_t *)((void *)0));
    }
  }
#line 177
  i = 0;
  {
#line 177
  while (1) {
    while_continue: /* CIL Label */ ;
#line 177
    if (! (i < 26)) {
#line 177
      goto while_break;
    }
    {
#line 178
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"MA[%d]",
            i);
#line 179
    tmp___2 = generic_bus_attach_sig(part, & ((bus_params_t___8 *)bus___0->params)->ma[i],
                                     buff);
#line 179
    failed |= tmp___2;
#line 177
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 182
  i = 0;
  {
#line 182
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 182
    if (! (i < 32)) {
#line 182
      goto while_break___0;
    }
    {
#line 183
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"MD[%d]",
            i);
#line 184
    tmp___3 = generic_bus_attach_sig(part, & ((bus_params_t___8 *)bus___0->params)->md[i],
                                     buff);
#line 184
    failed |= tmp___3;
#line 182
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 187
  if (((bus_params_t___8 *)bus___0->params)->proc == 1) {
#line 188
    ncs_map = pxa25x_ncs_map;
  } else
#line 190
  if (((bus_params_t___8 *)bus___0->params)->proc == 2) {
#line 191
    ncs_map = pxa27x_ncs_map;
  } else {
    {
#line 195
    printf((char const   */* __restrict  */)"BUG in the code, file %s, line %d: unknown PROC\n",
           "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/pxa2x0.c", 195);
#line 196
    ncs_map = pxa25x_ncs_map;
    }
  }
#line 198
  i = 0;
  {
#line 198
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 198
    if (! (i < 6)) {
#line 198
      goto while_break___1;
    }
#line 199
    if ((ncs_map + i)->enabled > 0) {
      {
#line 200
      tmp___4 = generic_bus_attach_sig(part, & ((bus_params_t___8 *)bus___0->params)->ncs[i],
                                       (ncs_map + i)->sig_name);
#line 200
      failed |= tmp___4;
      }
    } else {
#line 204
      ((bus_params_t___8 *)bus___0->params)->ncs[i] = (signal_t *)((void *)0);
    }
#line 198
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 208
  i = 0;
  {
#line 208
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 208
    if (! (i < 4)) {
#line 208
      goto while_break___2;
    }
    {
#line 209
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"DQM[%d]",
            i);
#line 210
    tmp___5 = generic_bus_attach_sig(part, & ((bus_params_t___8 *)bus___0->params)->dqm[i],
                                     buff);
#line 210
    failed |= tmp___5;
#line 208
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 213
  tmp___6 = generic_bus_attach_sig(part, & ((bus_params_t___8 *)bus___0->params)->rdnwr,
                                   (char *)"RDnWR");
#line 213
  failed |= tmp___6;
#line 215
  tmp___7 = generic_bus_attach_sig(part, & ((bus_params_t___8 *)bus___0->params)->nwe,
                                   (char *)"nWE");
#line 215
  failed |= tmp___7;
#line 217
  tmp___8 = generic_bus_attach_sig(part, & ((bus_params_t___8 *)bus___0->params)->noe,
                                   (char *)"nOE");
#line 217
  failed |= tmp___8;
#line 219
  tmp___9 = generic_bus_attach_sig(part, & ((bus_params_t___8 *)bus___0->params)->nsdcas,
                                   (char *)"nSDCAS");
#line 219
  failed |= tmp___9;
  }
#line 221
  if (failed) {
    {
#line 222
    free(bus___0->params);
#line 223
    free((void *)bus___0);
    }
#line 224
    return ((bus_t *)((void *)0));
  }
#line 227
  return (bus___0);
}
}
#line 234 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/pxa2x0.c"
static void pxa2xx_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;
  char *__cil_tmp4 ;

  {
#line 239
  i = 0;
  {
#line 239
  while (1) {
    while_continue: /* CIL Label */ ;
#line 239
    if (! (i < ((bus___0->chain)->parts)->len)) {
#line 239
      goto while_break;
    }
#line 240
    if ((unsigned long )bus___0->part == (unsigned long )*(((bus___0->chain)->parts)->parts + i)) {
#line 241
      goto while_break;
    }
#line 239
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 242
  tmp = gettext("%s (JTAG part No. %d)\n");
#line 242
  printf((char const   */* __restrict  */)tmp, (bus___0->driver)->description, i);
  }
#line 243
  return;
}
}
#line 249 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/pxa2x0.c"
static int pxa2xx_bus_init(bus_t *bus___0 ) 
{ 
  chain_t *chain ;
  part_t *p ;
  int tmp ;
  signal_t *tmp___0 ;
  int tmp___1 ;
  signal_t *tmp___2 ;
  int tmp___3 ;
  signal_t *tmp___4 ;
  int tmp___5 ;
  signal_t *tmp___6 ;
  int tmp___7 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
  {
#line 252
  chain = bus___0->chain;
#line 253
  p = bus___0->part;
#line 255
  tmp = tap_state(chain);
  }
#line 255
  if (tmp != 1 << 3) {
#line 260
    return (0);
  }
  {
#line 263
  part_set_instruction(p, "SAMPLE/PRELOAD");
#line 264
  chain_shift_instructions(chain);
#line 265
  chain_shift_data_registers(chain, 1);
  }
#line 267
  if (((bus_params_t___8 *)bus___0->params)->proc == 1) {
    {
#line 269
    tmp___0 = part_find_signal(p, "BOOT_SEL[2]");
#line 269
    tmp___1 = part_get_signal(p, tmp___0);
#line 269
    tmp___2 = part_find_signal(p, "BOOT_SEL[1]");
#line 269
    tmp___3 = part_get_signal(p, tmp___2);
#line 269
    tmp___4 = part_find_signal(p, "BOOT_SEL[0]");
#line 269
    tmp___5 = part_get_signal(p, tmp___4);
#line 269
    ((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def = (uint32_t volatile   )((1 << 3) | ((((tmp___1 << 2) | (tmp___3 << 1)) | tmp___5) & ((2 << 2) - 1)));
    }
  } else
#line 274
  if (((bus_params_t___8 *)bus___0->params)->proc == 2) {
    {
#line 276
    tmp___6 = part_find_signal(p, "BOOT_SEL");
#line 276
    tmp___7 = part_get_signal(p, tmp___6);
#line 276
    ((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def = (uint32_t volatile   )((1 << 3) | (tmp___7 & ((2 << 2) - 1)));
    }
  } else {
    {
#line 280
    printf((char const   */* __restrict  */)"BUG in the code, file %s, line %d.\n",
           "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/pxa2x0.c", 280);
    }
  }
  {
#line 282
  part_set_instruction(p, "BYPASS");
#line 283
  chain_shift_instructions(chain);
#line 285
  bus___0->initialized = 1;
  }
#line 287
  return (0);
}
}
#line 294 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/pxa2x0.c"
static int pxa2xx_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area___0 ) 
{ 
  uint32_t tmp_addr ;
  int ncs_index ;
  char const   *tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 301
  if (adr < 67108864U) {
#line 302
    area___0->description = "Static Chip Select 0";
#line 303
    area___0->start = 0U;
#line 304
    area___0->length = 67108864ULL;
#line 306
    if (pxa25x_ncs_map[0].bus_width > 0) {
#line 308
      area___0->width = (unsigned int )pxa25x_ncs_map[0].bus_width;
    } else {
      {
#line 314
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )0) {
#line 314
        goto case_0;
      }
#line 317
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )1) {
#line 317
        goto case_1;
      }
#line 321
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )3) {
#line 321
        goto case_3;
      }
#line 321
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )2) {
#line 321
        goto case_3;
      }
#line 327
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )7) {
#line 327
        goto case_7;
      }
#line 327
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )6) {
#line 327
        goto case_7;
      }
#line 327
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )5) {
#line 327
        goto case_7;
      }
#line 327
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )4) {
#line 327
        goto case_7;
      }
#line 330
      goto switch_default;
      case_0: /* CIL Label */ 
#line 315
      area___0->width = 32U;
#line 316
      goto switch_break;
      case_1: /* CIL Label */ 
#line 318
      area___0->width = 16U;
#line 319
      goto switch_break;
      case_3: /* CIL Label */ 
      case_2: /* CIL Label */ 
#line 322
      area___0->width = 0U;
#line 323
      goto switch_break;
      case_7: /* CIL Label */ 
      case_6: /* CIL Label */ 
      case_5: /* CIL Label */ 
      case_4: /* CIL Label */ 
      {
#line 328
      printf((char const   */* __restrict  */)"TODO - BOOT_SEL: %d\n", ((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1));
      }
#line 329
      return (1);
      switch_default: /* CIL Label */ 
      {
#line 331
      printf((char const   */* __restrict  */)"BUG in the code, file %s, line %d.\n",
             "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/pxa2x0.c",
             331);
      }
#line 332
      return (1);
      switch_break: /* CIL Label */ ;
      }
    }
#line 335
    return (0);
  }
#line 339
  ncs_index = 1;
#line 339
  tmp_addr = (uint32_t )67108864;
  {
#line 339
  while (1) {
    while_continue: /* CIL Label */ ;
#line 339
    if (! (ncs_index <= 5)) {
#line 339
      goto while_break;
    }
#line 341
    if (adr >= tmp_addr) {
#line 341
      if (adr < tmp_addr + 67108864U) {
#line 342
        if (pxa25x_ncs_map[ncs_index].enabled) {
#line 342
          tmp = "";
        } else {
#line 342
          tmp = "(disabled)";
        }
        {
#line 342
        sprintf((char */* __restrict  */)(pxa25x_ncs_map[ncs_index].label_buf), (char const   */* __restrict  */)"Static Chip Select %d = %s %s",
                ncs_index, pxa25x_ncs_map[ncs_index].sig_name, tmp);
#line 345
        area___0->description = (char const   *)(pxa25x_ncs_map[ncs_index].label_buf);
#line 346
        area___0->start = tmp_addr;
#line 347
        area___0->length = 67108864ULL;
#line 348
        area___0->width = (unsigned int )pxa25x_ncs_map[ncs_index].bus_width;
        }
#line 350
        return (0);
      }
    }
#line 339
    ncs_index ++;
#line 339
    tmp_addr += 67108864U;
  }
  while_break: /* CIL Label */ ;
  }
#line 354
  if (adr < 1207959552U) {
#line 355
    area___0->description = (char const   *)((void *)0);
#line 356
    area___0->start = 402653184U;
#line 357
    area___0->length = 805306368ULL;
#line 358
    area___0->width = 0U;
#line 360
    return (0);
  }
#line 363
  if (adr < 1275068416U) {
#line 364
    area___0->description = "Memory Mapped registers (Memory Ctl)";
#line 365
    area___0->start = 1207959552U;
#line 366
    area___0->length = 67108864ULL;
#line 367
    area___0->width = 32U;
#line 369
    return (0);
  }
#line 372
  area___0->description = (char const   *)((void *)0);
#line 373
  area___0->start = 1275068416U;
#line 374
  area___0->length = 3019898880ULL;
#line 375
  area___0->width = 0U;
#line 377
  return (0);
}
}
#line 384 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/pxa2x0.c"
static int pxa27x_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area___0 ) 
{ 
  uint32_t tmp_addr ;
  int ncs_index ;
  char const   *tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 391
  if (adr < 67108864U) {
#line 392
    area___0->description = "Static Chip Select 0";
#line 393
    area___0->start = 0U;
#line 394
    area___0->length = 67108864ULL;
#line 396
    if (pxa27x_ncs_map[0].bus_width > 0) {
#line 398
      area___0->width = (unsigned int )pxa27x_ncs_map[0].bus_width;
    } else {
      {
#line 404
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )0) {
#line 404
        goto case_0;
      }
#line 407
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )1) {
#line 407
        goto case_1;
      }
#line 411
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )3) {
#line 411
        goto case_3;
      }
#line 411
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )2) {
#line 411
        goto case_3;
      }
#line 417
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )7) {
#line 417
        goto case_7;
      }
#line 417
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )6) {
#line 417
        goto case_7;
      }
#line 417
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )5) {
#line 417
        goto case_7;
      }
#line 417
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )4) {
#line 417
        goto case_7;
      }
#line 420
      goto switch_default;
      case_0: /* CIL Label */ 
#line 405
      area___0->width = 32U;
#line 406
      goto switch_break;
      case_1: /* CIL Label */ 
#line 408
      area___0->width = 16U;
#line 409
      goto switch_break;
      case_3: /* CIL Label */ 
      case_2: /* CIL Label */ 
#line 412
      area___0->width = 0U;
#line 413
      goto switch_break;
      case_7: /* CIL Label */ 
      case_6: /* CIL Label */ 
      case_5: /* CIL Label */ 
      case_4: /* CIL Label */ 
      {
#line 418
      printf((char const   */* __restrict  */)"TODO - BOOT_SEL: %d\n", ((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1));
      }
#line 419
      return (1);
      switch_default: /* CIL Label */ 
      {
#line 421
      printf((char const   */* __restrict  */)"BUG in the code, file %s, line %d.\n",
             "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/pxa2x0.c",
             421);
      }
#line 422
      return (1);
      switch_break: /* CIL Label */ ;
      }
    }
#line 425
    return (0);
  }
#line 429
  ncs_index = 1;
#line 429
  tmp_addr = (uint32_t )67108864;
  {
#line 429
  while (1) {
    while_continue: /* CIL Label */ ;
#line 429
    if (! (ncs_index <= 5)) {
#line 429
      goto while_break;
    }
#line 432
    if (adr >= tmp_addr) {
#line 432
      if (adr < tmp_addr + 67108864U) {
#line 434
        if (pxa27x_ncs_map[ncs_index].enabled) {
#line 434
          tmp = "";
        } else {
#line 434
          tmp = "(disabled)";
        }
        {
#line 434
        sprintf((char */* __restrict  */)(pxa27x_ncs_map[ncs_index].label_buf), (char const   */* __restrict  */)"Static Chip Select %d = %s %s",
                ncs_index, pxa27x_ncs_map[ncs_index].sig_name, tmp);
#line 437
        area___0->description = (char const   *)(pxa27x_ncs_map[ncs_index].label_buf);
#line 438
        area___0->start = tmp_addr;
#line 439
        area___0->length = 67108864ULL;
#line 440
        area___0->width = (unsigned int )pxa27x_ncs_map[ncs_index].bus_width;
        }
#line 442
        return (0);
      }
    }
#line 429
    ncs_index ++;
#line 429
    tmp_addr += 67108864U;
  }
  while_break: /* CIL Label */ ;
  }
#line 447
  if (adr < 1073741824U) {
#line 448
    area___0->description = (char const   *)((void *)0);
#line 449
    area___0->start = 402653184U;
#line 450
    area___0->length = 671088640ULL;
#line 451
    area___0->width = 0U;
#line 453
    return (0);
  }
#line 456
  if (adr < 1610612736U) {
#line 457
    area___0->description = "PXA270 internal address space (cfg, SRAM)";
#line 458
    area___0->start = 1073741824U;
#line 459
    area___0->length = 536870912ULL;
#line 460
    area___0->width = 32U;
#line 462
    return (0);
  }
#line 465
  if (adr < 2684354560U) {
#line 466
    area___0->description = (char const   *)((void *)0);
#line 467
    area___0->start = 1610612736U;
#line 468
    area___0->length = 1073741824ULL;
#line 469
    area___0->width = 0U;
#line 471
    return (0);
  }
#line 474
  if (adr < 2952790016U) {
#line 475
    area___0->description = "PXA270 SDRAM space (4x 64MB)";
#line 476
    area___0->start = 2684354560U;
#line 477
    area___0->length = 268435456ULL;
#line 478
    area___0->width = 32U;
#line 480
    return (0);
  }
#line 483
  area___0->description = (char const   *)((void *)0);
#line 484
  area___0->start = 2952790016U;
#line 485
  area___0->length = 1342177280ULL;
#line 486
  area___0->width = 0U;
#line 488
  return (0);
}
}
#line 491 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/pxa2x0.c"
static void setup_address___8(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 495
  p = bus___0->part;
#line 497
  i = 0;
  {
#line 497
  while (1) {
    while_continue: /* CIL Label */ ;
#line 497
    if (! (i < 26)) {
#line 497
      goto while_break;
    }
    {
#line 498
    part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->ma[i], 1, (int )((a >> i) & 1U));
#line 497
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 499
  return;
}
}
#line 501 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/pxa2x0.c"
static void set_data_in___8(bus_t *bus___0 , uint32_t adr ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area___0 ;

  {
  {
#line 505
  p = bus___0->part;
#line 508
  (*((bus___0->driver)->area))(bus___0, adr, & area___0);
#line 510
  i = 0;
  }
  {
#line 510
  while (1) {
    while_continue: /* CIL Label */ ;
#line 510
    if (! ((unsigned int )i < area___0.width)) {
#line 510
      goto while_break;
    }
    {
#line 511
    part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->md[i], 0, 0);
#line 510
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 512
  return;
}
}
#line 514 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/pxa2x0.c"
static void setup_data___8(bus_t *bus___0 , uint32_t adr , uint32_t d ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area___0 ;

  {
  {
#line 518
  p = bus___0->part;
#line 521
  (*((bus___0->driver)->area))(bus___0, adr, & area___0);
#line 523
  i = 0;
  }
  {
#line 523
  while (1) {
    while_continue: /* CIL Label */ ;
#line 523
    if (! ((unsigned int )i < area___0.width)) {
#line 523
      goto while_break;
    }
    {
#line 524
    part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->md[i], 1, (int )((d >> i) & 1U));
#line 523
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 525
  return;
}
}
#line 531 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/pxa2x0.c"
static void pxa2xx_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  int cs_index ;
  chain_t *chain ;
  part_t *p ;

  {
#line 534
  cs_index = 0;
#line 536
  chain = bus___0->chain;
#line 537
  p = bus___0->part;
#line 539
  ((bus_params_t___8 *)bus___0->params)->last_adr = adr;
#line 540
  if (adr >= 402653184U) {
#line 541
    return;
  }
#line 543
  cs_index = (int )(adr >> 26);
#line 544
  if ((unsigned long )((bus_params_t___8 *)bus___0->params)->ncs[cs_index] == (unsigned long )((void *)0)) {
#line 545
    return;
  }
  {
#line 548
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->ncs[cs_index], 1, 0);
#line 549
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->dqm[0], 1, 0);
#line 550
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->dqm[1], 1, 0);
#line 551
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->dqm[2], 1, 0);
#line 552
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->dqm[3], 1, 0);
#line 553
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->rdnwr, 1, 1);
#line 554
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->nwe, 1, 1);
#line 555
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->noe, 1, 0);
#line 556
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->nsdcas, 1, 0);
#line 558
  setup_address___8(bus___0, adr);
#line 559
  set_data_in___8(bus___0, adr);
#line 561
  chain_shift_data_registers(chain, 0);
  }
#line 562
  return;
}
}
#line 568 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/pxa2x0.c"
static uint32_t pxa2xx_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;
  uint32_t d ;
  uint32_t old_last_adr ;
  int i ;
  bus_area_t area___0 ;
  int tmp ;

  {
#line 571
  p = bus___0->part;
#line 572
  chain = bus___0->chain;
#line 574
  old_last_adr = ((bus_params_t___8 *)bus___0->params)->last_adr;
#line 576
  ((bus_params_t___8 *)bus___0->params)->last_adr = adr;
#line 578
  if (adr < 402653184U) {
#line 582
    if ((unsigned long )((bus_params_t___8 *)bus___0->params)->ncs[adr >> 26] == (unsigned long )((void *)0)) {
#line 583
      return ((uint32_t )0);
    }
    {
#line 585
    (*((bus___0->driver)->area))(bus___0, adr, & area___0);
#line 588
    setup_address___8(bus___0, adr);
#line 589
    chain_shift_data_registers(chain, 1);
#line 591
    d = (uint32_t )0;
#line 592
    i = 0;
    }
    {
#line 592
    while (1) {
      while_continue: /* CIL Label */ ;
#line 592
      if (! ((unsigned int )i < area___0.width)) {
#line 592
        goto while_break;
      }
      {
#line 593
      tmp = part_get_signal(p, ((bus_params_t___8 *)bus___0->params)->md[i]);
#line 593
      d |= (uint32_t )(tmp << i);
#line 592
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 595
    return (d);
  }
#line 599
  if (adr < 1207959552U) {
#line 600
    return ((uint32_t )0);
  }
#line 602
  if (adr < 1275068416U) {
#line 603
    if (old_last_adr == 1207959620U) {
#line 604
      return ((uint32_t )((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def);
    }
#line 606
    return ((uint32_t )0);
  }
#line 609
  return ((uint32_t )0);
}
}
#line 616 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/pxa2x0.c"
static uint32_t pxa2xx_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  bus_area_t area___0 ;
  int tmp ;

  {
#line 619
  p = bus___0->part;
#line 620
  chain = bus___0->chain;
#line 622
  if (((bus_params_t___8 *)bus___0->params)->last_adr < 402653184U) {
#line 624
    d = (uint32_t )0;
#line 627
    if ((unsigned long )((bus_params_t___8 *)bus___0->params)->ncs[((bus_params_t___8 *)bus___0->params)->last_adr >> 26] == (unsigned long )((void *)0)) {
#line 628
      return ((uint32_t )0);
    }
    {
#line 630
    (*((bus___0->driver)->area))(bus___0, ((bus_params_t___8 *)bus___0->params)->last_adr,
                                 & area___0);
#line 633
    part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->ncs[0], 1, 1);
#line 634
    part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->noe, 1, 1);
#line 635
    part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->nsdcas, 1, 1);
#line 637
    chain_shift_data_registers(chain, 1);
#line 639
    i = 0;
    }
    {
#line 639
    while (1) {
      while_continue: /* CIL Label */ ;
#line 639
      if (! ((unsigned int )i < area___0.width)) {
#line 639
        goto while_break;
      }
      {
#line 640
      tmp = part_get_signal(p, ((bus_params_t___8 *)bus___0->params)->md[i]);
#line 640
      d |= (uint32_t )(tmp << i);
#line 639
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 642
    return (d);
  }
#line 646
  if (((bus_params_t___8 *)bus___0->params)->last_adr < 1207959552U) {
#line 647
    return ((uint32_t )0);
  }
#line 649
  if (((bus_params_t___8 *)bus___0->params)->last_adr < 1275068416U) {
#line 650
    if (((bus_params_t___8 *)bus___0->params)->last_adr == 1207959620U) {
#line 651
      return ((uint32_t )((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def);
    }
#line 653
    return ((uint32_t )0);
  }
#line 656
  return ((uint32_t )0);
}
}
#line 663 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/pxa2x0.c"
static void pxa2xx_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  int cs_index ;
  part_t *p ;
  chain_t *chain ;

  {
#line 666
  cs_index = 0;
#line 669
  p = bus___0->part;
#line 670
  chain = bus___0->chain;
#line 672
  if (adr >= 402653184U) {
#line 673
    return;
  }
#line 675
  cs_index = (int )(adr >> 26);
#line 676
  if ((unsigned long )((bus_params_t___8 *)bus___0->params)->ncs[cs_index] == (unsigned long )((void *)0)) {
#line 677
    return;
  }
  {
#line 679
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->ncs[cs_index], 1, 0);
#line 680
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->dqm[0], 1, 0);
#line 681
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->dqm[1], 1, 0);
#line 682
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->dqm[2], 1, 0);
#line 683
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->dqm[3], 1, 0);
#line 684
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->rdnwr, 1, 0);
#line 685
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->nwe, 1, 1);
#line 686
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->noe, 1, 1);
#line 687
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->nsdcas, 1, 0);
#line 689
  setup_address___8(bus___0, adr);
#line 690
  setup_data___8(bus___0, adr, data);
#line 692
  chain_shift_data_registers(chain, 0);
#line 694
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->nwe, 1, 0);
#line 695
  chain_shift_data_registers(chain, 0);
#line 696
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->nwe, 1, 1);
#line 697
  chain_shift_data_registers(chain, 0);
  }
#line 698
  return;
}
}
#line 700 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/pxa2x0.c"
struct bus_driver  const  pxa2x0_bus  = 
#line 700
     {"pxa2x0", "Intel PXA2x0 compatible bus driver via BSR", & pxa2xx_bus_new, & generic_bus_free,
    & pxa2xx_bus_printinfo, & generic_bus_prepare_extest, & pxa2xx_bus_area, & pxa2xx_bus_read_start,
    & pxa2xx_bus_read_next, & pxa2xx_bus_read_end, & generic_bus_read, & pxa2xx_bus_write,
    & pxa2xx_bus_init};
#line 716 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/pxa2x0.c"
struct bus_driver  const  pxa27x_bus  = 
#line 716
     {"pxa27x", "Intel PXA27x compatible bus driver via BSR", & pxa2xx_bus_new, & generic_bus_free,
    & pxa2xx_bus_printinfo, & generic_bus_prepare_extest, & pxa27x_bus_area, & pxa2xx_bus_read_start,
    & pxa2xx_bus_read_next, & pxa2xx_bus_read_end, & generic_bus_read, & pxa2xx_bus_write,
    & pxa2xx_bus_init};
#line 340 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strstr)(char const   *__haystack ,
                                                                                       char const   *__needle )  __attribute__((__pure__)) ;
#line 415 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...) ;
#line 51 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/buses.h"
struct bus_driver  const  prototype_bus ;
#line 70 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/prototype.c"
static void prototype_bus_signal_parse(char *str , char *fmt , int *inst ) 
{ 
  char pre[16] ;
  char suf[16] ;
  int tmp ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 75
  tmp = sscanf((char const   */* __restrict  */)str, (char const   */* __restrict  */)"%[^0-9]%d%s",
               pre, inst, suf);
  }
  {
#line 76
  if (tmp == 1) {
#line 76
    goto case_1;
  }
#line 79
  if (tmp == 2) {
#line 79
    goto case_2;
  }
#line 82
  if (tmp == 3) {
#line 82
    goto case_3;
  }
#line 75
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 77
  strcpy((char */* __restrict  */)fmt, (char const   */* __restrict  */)str);
  }
#line 78
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 80
  sprintf((char */* __restrict  */)fmt, (char const   */* __restrict  */)"%s%s", pre,
          "%d");
  }
#line 81
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 83
  sprintf((char */* __restrict  */)fmt, (char const   */* __restrict  */)"%s%s%s",
          pre, "%d", suf);
  }
  switch_break: /* CIL Label */ ;
  }
#line 85
  return;
}
}
#line 91 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/prototype.c"
static bus_t *prototype_bus_new(chain_t *chain , bus_driver_t const   *driver , char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  signal_t *sig ;
  char buff[16] ;
  char fmt[16] ;
  char afmt[16] ;
  char dfmt[16] ;
  char param[16] ;
  char value[16] ;
  int i ;
  int j ;
  int inst ;
  int max ;
  int min ;
  int failed ;
  int ashift ;
  void *tmp ;
  signal_t *tmp___0 ;
  signal_t *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  char *tmp___25 ;
  int tmp___26 ;
  int nbytes ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  void *__cil_tmp52 ;
  void *__cil_tmp53 ;
  void *__cil_tmp54 ;
  void *__cil_tmp55 ;
  void *__cil_tmp56 ;
  void *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;

  {
  {
#line 98
  failed = 0;
#line 99
  ashift = -1;
#line 101
  tmp = calloc((size_t )1, (size_t )sizeof(bus_t ));
#line 101
  bus___0 = (bus_t *)tmp;
  }
#line 102
  if (! bus___0) {
#line 103
    return ((bus_t *)((void *)0));
  }
  {
#line 105
  bus___0->driver = driver;
#line 106
  bus___0->params = calloc((size_t )1, (size_t )sizeof(bus_params_t___9 ));
  }
#line 107
  if (! bus___0->params) {
    {
#line 108
    free((void *)bus___0);
    }
#line 109
    return ((bus_t *)((void *)0));
  }
#line 112
  bus___0->chain = chain;
#line 113
  bus___0->part = *((chain->parts)->parts + chain->active_part);
#line 115
  tmp___1 = (signal_t *)((void *)0);
#line 115
  ((bus_params_t___9 *)bus___0->params)->we = tmp___1;
#line 115
  tmp___0 = tmp___1;
#line 115
  ((bus_params_t___9 *)bus___0->params)->oe = tmp___0;
#line 115
  ((bus_params_t___9 *)bus___0->params)->cs = tmp___0;
#line 116
  tmp___4 = -1;
#line 116
  ((bus_params_t___9 *)bus___0->params)->dmsbi = tmp___4;
#line 116
  tmp___3 = tmp___4;
#line 116
  ((bus_params_t___9 *)bus___0->params)->dlsbi = tmp___3;
#line 116
  tmp___2 = tmp___3;
#line 116
  ((bus_params_t___9 *)bus___0->params)->amsbi = tmp___2;
#line 116
  ((bus_params_t___9 *)bus___0->params)->alsbi = tmp___2;
#line 117
  i = 2;
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! *(cmd_params___0 + i)) {
#line 117
      goto while_break;
    }
    {
#line 118
    tmp___5 = strstr((char const   *)*(cmd_params___0 + i), "=");
    }
#line 118
    if (! tmp___5) {
#line 118
      goto __Cont;
    }
    {
#line 119
    sscanf((char const   */* __restrict  */)*(cmd_params___0 + i), (char const   */* __restrict  */)"%[^=]%*c%s",
           param, value);
#line 121
    tmp___11 = strcmp("amode", (char const   *)(param));
    }
#line 121
    if (! tmp___11) {
      {
#line 122
      tmp___10 = strcmp("x8", (char const   *)(value));
      }
#line 122
      if (tmp___10) {
        {
#line 124
        tmp___9 = strcmp("x16", (char const   *)(value));
        }
#line 124
        if (tmp___9) {
          {
#line 126
          tmp___8 = strcmp("x32", (char const   *)(value));
          }
#line 126
          if (tmp___8) {
            {
#line 128
            tmp___7 = strcmp("auto", (char const   *)(value));
            }
#line 128
            if (tmp___7) {
              {
#line 129
              tmp___6 = gettext("value %s not defined for parameter %s\n");
#line 129
              printf((char const   */* __restrict  */)tmp___6, value, param);
              }
            }
          } else {
#line 127
            ashift = 2;
          }
        } else {
#line 125
          ashift = 1;
        }
      } else {
#line 123
        ashift = 0;
      }
#line 130
      goto __Cont;
    }
    {
#line 133
    prototype_bus_signal_parse(value, fmt, & inst);
    }
#line 134
    if (inst > 31) {
#line 134
      goto __Cont;
    }
    {
#line 136
    sig = part_find_signal(bus___0->part, (char const   *)(value));
    }
#line 137
    if (! sig) {
      {
#line 138
      tmp___12 = gettext("signal \'%s\' is not found\n");
#line 138
      printf((char const   */* __restrict  */)tmp___12, value);
#line 139
      failed = 1;
      }
    } else {
      {
#line 140
      tmp___23 = strcmp("alsb", (char const   *)(param));
      }
#line 140
      if (tmp___23) {
        {
#line 144
        tmp___22 = strcmp("amsb", (char const   *)(param));
        }
#line 144
        if (tmp___22) {
          {
#line 148
          tmp___21 = strcmp("dlsb", (char const   *)(param));
          }
#line 148
          if (tmp___21) {
            {
#line 152
            tmp___20 = strcmp("dmsb", (char const   *)(param));
            }
#line 152
            if (tmp___20) {
              {
#line 156
              tmp___18 = strcmp("cs", (char const   *)(param));
              }
#line 156
              if (tmp___18) {
                {
#line 156
                tmp___19 = strcmp("ncs", (char const   *)(param));
                }
#line 156
                if (tmp___19) {
                  {
#line 159
                  tmp___16 = strcmp("oe", (char const   *)(param));
                  }
#line 159
                  if (tmp___16) {
                    {
#line 159
                    tmp___17 = strcmp("noe", (char const   *)(param));
                    }
#line 159
                    if (tmp___17) {
                      {
#line 162
                      tmp___14 = strcmp("we", (char const   *)(param));
                      }
#line 162
                      if (tmp___14) {
                        {
#line 162
                        tmp___15 = strcmp("nwe", (char const   *)(param));
                        }
#line 162
                        if (tmp___15) {
                          {
#line 166
                          tmp___13 = gettext("parameter %s is unknown\n");
#line 166
                          printf((char const   */* __restrict  */)tmp___13, param);
#line 167
                          failed = 1;
                          }
                        } else {
#line 162
                          goto _L;
                        }
                      } else {
                        _L: /* CIL Label */ 
#line 163
                        ((bus_params_t___9 *)bus___0->params)->we = sig;
#line 164
                        if ((int )param[0] == 110) {
#line 164
                          ((bus_params_t___9 *)bus___0->params)->wea = 0;
                        } else {
#line 164
                          ((bus_params_t___9 *)bus___0->params)->wea = 1;
                        }
                      }
                    } else {
#line 159
                      goto _L___0;
                    }
                  } else {
                    _L___0: /* CIL Label */ 
#line 160
                    ((bus_params_t___9 *)bus___0->params)->oe = sig;
#line 161
                    if ((int )param[0] == 110) {
#line 161
                      ((bus_params_t___9 *)bus___0->params)->oea = 0;
                    } else {
#line 161
                      ((bus_params_t___9 *)bus___0->params)->oea = 1;
                    }
                  }
                } else {
#line 156
                  goto _L___1;
                }
              } else {
                _L___1: /* CIL Label */ 
#line 157
                ((bus_params_t___9 *)bus___0->params)->cs = sig;
#line 158
                if ((int )param[0] == 110) {
#line 158
                  ((bus_params_t___9 *)bus___0->params)->csa = 0;
                } else {
#line 158
                  ((bus_params_t___9 *)bus___0->params)->csa = 1;
                }
              }
            } else {
              {
#line 153
              ((bus_params_t___9 *)bus___0->params)->dmsbi = inst;
#line 154
              ((bus_params_t___9 *)bus___0->params)->d[inst] = sig;
#line 155
              strcpy((char */* __restrict  */)(dfmt), (char const   */* __restrict  */)(fmt));
              }
            }
          } else {
            {
#line 149
            ((bus_params_t___9 *)bus___0->params)->dlsbi = inst;
#line 150
            ((bus_params_t___9 *)bus___0->params)->d[inst] = sig;
#line 151
            strcpy((char */* __restrict  */)(dfmt), (char const   */* __restrict  */)(fmt));
            }
          }
        } else {
          {
#line 145
          ((bus_params_t___9 *)bus___0->params)->amsbi = inst;
#line 146
          ((bus_params_t___9 *)bus___0->params)->a[inst] = sig;
#line 147
          strcpy((char */* __restrict  */)(afmt), (char const   */* __restrict  */)(fmt));
          }
        }
      } else {
        {
#line 141
        ((bus_params_t___9 *)bus___0->params)->alsbi = inst;
#line 142
        ((bus_params_t___9 *)bus___0->params)->a[inst] = sig;
#line 143
        strcpy((char */* __restrict  */)(afmt), (char const   */* __restrict  */)(fmt));
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 117
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 171
  if (((bus_params_t___9 *)bus___0->params)->alsbi >= 0) {
#line 171
    goto _L___3;
  } else
#line 171
  if (((bus_params_t___9 *)bus___0->params)->amsbi >= 0) {
    _L___3: /* CIL Label */ 
#line 172
    if (((bus_params_t___9 *)bus___0->params)->alsbi == -1) {
#line 172
      goto _L___2;
    } else
#line 172
    if (((bus_params_t___9 *)bus___0->params)->amsbi == -1) {
      _L___2: /* CIL Label */ 
#line 173
      min = 0;
      {
#line 173
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 173
        if (! (min <= 31)) {
#line 173
          goto while_break___0;
        }
        {
#line 174
        sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)(afmt),
                min);
#line 175
        ((bus_params_t___9 *)bus___0->params)->a[min] = part_find_signal(bus___0->part,
                                                                         (char const   *)(buff));
        }
#line 176
        if (((bus_params_t___9 *)bus___0->params)->a[min]) {
#line 176
          goto while_break___0;
        }
#line 173
        min ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 178
      max = 31;
      {
#line 178
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 178
        if (! (max >= 0)) {
#line 178
          goto while_break___1;
        }
        {
#line 179
        sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)(afmt),
                max);
#line 180
        ((bus_params_t___9 *)bus___0->params)->a[max] = part_find_signal(bus___0->part,
                                                                         (char const   *)(buff));
        }
#line 181
        if (((bus_params_t___9 *)bus___0->params)->a[max]) {
#line 181
          goto while_break___1;
        }
#line 178
        max --;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 183
      if (((bus_params_t___9 *)bus___0->params)->alsbi == -1) {
#line 184
        if (max - ((bus_params_t___9 *)bus___0->params)->amsbi < ((bus_params_t___9 *)bus___0->params)->amsbi - min) {
#line 184
          ((bus_params_t___9 *)bus___0->params)->alsbi = min;
        } else {
#line 184
          ((bus_params_t___9 *)bus___0->params)->alsbi = max;
        }
      } else
#line 186
      if (max - ((bus_params_t___9 *)bus___0->params)->alsbi < ((bus_params_t___9 *)bus___0->params)->alsbi - min) {
#line 186
        ((bus_params_t___9 *)bus___0->params)->amsbi = min;
      } else {
#line 186
        ((bus_params_t___9 *)bus___0->params)->amsbi = max;
      }
    }
#line 188
    if (((bus_params_t___9 *)bus___0->params)->amsbi > ((bus_params_t___9 *)bus___0->params)->alsbi) {
#line 188
      ((bus_params_t___9 *)bus___0->params)->ai = 1;
    } else {
#line 188
      ((bus_params_t___9 *)bus___0->params)->ai = -1;
    }
#line 189
    if (((bus_params_t___9 *)bus___0->params)->amsbi > ((bus_params_t___9 *)bus___0->params)->alsbi) {
#line 189
      tmp___24 = ((bus_params_t___9 *)bus___0->params)->amsbi - ((bus_params_t___9 *)bus___0->params)->alsbi;
    } else {
#line 189
      tmp___24 = ((bus_params_t___9 *)bus___0->params)->alsbi - ((bus_params_t___9 *)bus___0->params)->amsbi;
    }
#line 189
    ((bus_params_t___9 *)bus___0->params)->aw = tmp___24 + 1;
#line 190
    i = 0;
#line 190
    j = ((bus_params_t___9 *)bus___0->params)->alsbi;
    {
#line 190
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 190
      if (! (i < ((bus_params_t___9 *)bus___0->params)->aw)) {
#line 190
        goto while_break___2;
      }
      {
#line 191
      sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)(afmt),
              j);
#line 192
      ((bus_params_t___9 *)bus___0->params)->a[j] = part_find_signal(bus___0->part,
                                                                     (char const   *)(buff));
#line 190
      i ++;
#line 190
      j += ((bus_params_t___9 *)bus___0->params)->ai;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
    {
#line 195
    tmp___25 = gettext("parameters alsb=<signal> and/or amsb=<signal> are not defined\n");
#line 195
    printf((char const   */* __restrict  */)tmp___25);
#line 196
    failed = 1;
    }
  }
#line 199
  if (((bus_params_t___9 *)bus___0->params)->dlsbi >= 0) {
#line 199
    goto _L___5;
  } else
#line 199
  if (((bus_params_t___9 *)bus___0->params)->dmsbi >= 0) {
    _L___5: /* CIL Label */ 
#line 200
    if (((bus_params_t___9 *)bus___0->params)->dlsbi == -1) {
#line 200
      goto _L___4;
    } else
#line 200
    if (((bus_params_t___9 *)bus___0->params)->dmsbi == -1) {
      _L___4: /* CIL Label */ 
#line 201
      min = 0;
      {
#line 201
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 201
        if (! (min <= 31)) {
#line 201
          goto while_break___3;
        }
        {
#line 202
        sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)(dfmt),
                min);
#line 203
        ((bus_params_t___9 *)bus___0->params)->d[min] = part_find_signal(bus___0->part,
                                                                         (char const   *)(buff));
        }
#line 204
        if (((bus_params_t___9 *)bus___0->params)->d[min]) {
#line 204
          goto while_break___3;
        }
#line 201
        min ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 206
      max = 31;
      {
#line 206
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 206
        if (! (max >= 0)) {
#line 206
          goto while_break___4;
        }
        {
#line 207
        sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)(dfmt),
                max);
#line 208
        ((bus_params_t___9 *)bus___0->params)->d[max] = part_find_signal(bus___0->part,
                                                                         (char const   *)(buff));
        }
#line 209
        if (((bus_params_t___9 *)bus___0->params)->d[max]) {
#line 209
          goto while_break___4;
        }
#line 206
        max --;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 211
      if (((bus_params_t___9 *)bus___0->params)->dlsbi == -1) {
#line 212
        if (max - ((bus_params_t___9 *)bus___0->params)->dmsbi < ((bus_params_t___9 *)bus___0->params)->dmsbi - min) {
#line 212
          ((bus_params_t___9 *)bus___0->params)->dlsbi = min;
        } else {
#line 212
          ((bus_params_t___9 *)bus___0->params)->dlsbi = max;
        }
      } else
#line 214
      if (max - ((bus_params_t___9 *)bus___0->params)->dlsbi < ((bus_params_t___9 *)bus___0->params)->dlsbi - min) {
#line 214
        ((bus_params_t___9 *)bus___0->params)->dmsbi = min;
      } else {
#line 214
        ((bus_params_t___9 *)bus___0->params)->dmsbi = max;
      }
    }
#line 216
    if (((bus_params_t___9 *)bus___0->params)->dmsbi > ((bus_params_t___9 *)bus___0->params)->dlsbi) {
#line 216
      ((bus_params_t___9 *)bus___0->params)->di = 1;
    } else {
#line 216
      ((bus_params_t___9 *)bus___0->params)->di = -1;
    }
#line 217
    if (((bus_params_t___9 *)bus___0->params)->dmsbi > ((bus_params_t___9 *)bus___0->params)->dlsbi) {
#line 217
      tmp___26 = ((bus_params_t___9 *)bus___0->params)->dmsbi - ((bus_params_t___9 *)bus___0->params)->dlsbi;
    } else {
#line 217
      tmp___26 = ((bus_params_t___9 *)bus___0->params)->dlsbi - ((bus_params_t___9 *)bus___0->params)->dmsbi;
    }
#line 217
    ((bus_params_t___9 *)bus___0->params)->dw = tmp___26 + 1;
#line 218
    i = 0;
#line 218
    j = ((bus_params_t___9 *)bus___0->params)->dlsbi;
    {
#line 218
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 218
      if (! (i < ((bus_params_t___9 *)bus___0->params)->dw)) {
#line 218
        goto while_break___5;
      }
      {
#line 219
      sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)(dfmt),
              j);
#line 220
      ((bus_params_t___9 *)bus___0->params)->d[j] = part_find_signal(bus___0->part,
                                                                     (char const   *)(buff));
#line 218
      i ++;
#line 218
      j += ((bus_params_t___9 *)bus___0->params)->di;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
#line 225
    if (ashift < 0) {
#line 230
      nbytes = ((bus_params_t___9 *)bus___0->params)->dw / 8;
#line 231
      if (((bus_params_t___9 *)bus___0->params)->dw % 8 > 0) {
#line 232
        nbytes ++;
      }
#line 234
      ashift = 0;
      {
#line 235
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 235
        if (! (nbytes != 1)) {
#line 235
          goto while_break___6;
        }
#line 236
        nbytes >>= 1;
#line 237
        ashift ++;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
#line 240
    ((bus_params_t___9 *)bus___0->params)->ashift = ashift;
  } else {
    {
#line 243
    tmp___27 = gettext("parameters dlsb=<signal> and/or dmsb=<signal> are not defined\n");
#line 243
    printf((char const   */* __restrict  */)tmp___27);
#line 244
    failed = 1;
    }
  }
#line 247
  if (! ((bus_params_t___9 *)bus___0->params)->cs) {
    {
#line 248
    tmp___28 = gettext("parameter cs=<signal> or ncs=<signal> is not defined\n");
#line 248
    printf((char const   */* __restrict  */)tmp___28);
#line 249
    failed = 1;
    }
  }
#line 252
  if (! ((bus_params_t___9 *)bus___0->params)->oe) {
    {
#line 253
    tmp___29 = gettext("parameter oe=<signal> or noe=<signal> is not defined\n");
#line 253
    printf((char const   */* __restrict  */)tmp___29);
#line 254
    failed = 1;
    }
  }
#line 257
  if (! ((bus_params_t___9 *)bus___0->params)->we) {
    {
#line 258
    tmp___30 = gettext("parameter we=<signal> or nwe=<signal> is not defined\n");
#line 258
    printf((char const   */* __restrict  */)tmp___30);
#line 259
    failed = 1;
    }
  }
#line 262
  if (failed) {
    {
#line 263
    free(bus___0->params);
#line 264
    free((void *)bus___0);
    }
#line 265
    return ((bus_t *)((void *)0));
  }
#line 268
  return (bus___0);
}
}
#line 275 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/prototype.c"
static void prototype_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;
  char *__cil_tmp4 ;

  {
#line 280
  i = 0;
  {
#line 280
  while (1) {
    while_continue: /* CIL Label */ ;
#line 280
    if (! (i < ((bus___0->chain)->parts)->len)) {
#line 280
      goto while_break;
    }
#line 281
    if ((unsigned long )bus___0->part == (unsigned long )*(((bus___0->chain)->parts)->parts + i)) {
#line 282
      goto while_break;
    }
#line 280
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 283
  tmp = gettext("Configurable prototype bus driver via BSR (JTAG part No. %d)\n");
#line 283
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 284
  return;
}
}
#line 290 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/prototype.c"
static int prototype_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area___0 ) 
{ 


  {
#line 293
  area___0->description = (char const   *)((void *)0);
#line 294
  area___0->start = 0U;
#line 295
  area___0->length = 4294967296ULL;
#line 296
  area___0->width = (unsigned int )((bus_params_t___9 *)bus___0->params)->dw;
#line 298
  return (0);
}
}
#line 301 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/prototype.c"
static void setup_address___9(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  int j ;
  part_t *p ;

  {
#line 305
  p = bus___0->part;
#line 307
  a >>= ((bus_params_t___9 *)bus___0->params)->ashift;
#line 309
  i = 0;
#line 309
  j = ((bus_params_t___9 *)bus___0->params)->alsbi;
  {
#line 309
  while (1) {
    while_continue: /* CIL Label */ ;
#line 309
    if (! (i < ((bus_params_t___9 *)bus___0->params)->aw)) {
#line 309
      goto while_break;
    }
    {
#line 310
    part_set_signal(p, ((bus_params_t___9 *)bus___0->params)->a[j], 1, (int )((a >> i) & 1U));
#line 309
    i ++;
#line 309
    j += ((bus_params_t___9 *)bus___0->params)->ai;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 311
  return;
}
}
#line 313 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/prototype.c"
static void set_data_in___9(bus_t *bus___0 ) 
{ 
  int i ;
  int j ;
  part_t *p ;
  bus_area_t area___0 ;

  {
  {
#line 317
  p = bus___0->part;
#line 320
  prototype_bus_area(bus___0, (uint32_t )0, & area___0);
#line 322
  i = 0;
#line 322
  j = ((bus_params_t___9 *)bus___0->params)->dlsbi;
  }
  {
#line 322
  while (1) {
    while_continue: /* CIL Label */ ;
#line 322
    if (! (i < ((bus_params_t___9 *)bus___0->params)->dw)) {
#line 322
      goto while_break;
    }
    {
#line 323
    part_set_signal(p, ((bus_params_t___9 *)bus___0->params)->d[j], 0, 0);
#line 322
    i ++;
#line 322
    j += ((bus_params_t___9 *)bus___0->params)->di;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 324
  return;
}
}
#line 326 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/prototype.c"
static void setup_data___9(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  int j ;
  part_t *p ;
  bus_area_t area___0 ;

  {
  {
#line 330
  p = bus___0->part;
#line 333
  prototype_bus_area(bus___0, (uint32_t )0, & area___0);
#line 335
  i = 0;
#line 335
  j = ((bus_params_t___9 *)bus___0->params)->dlsbi;
  }
  {
#line 335
  while (1) {
    while_continue: /* CIL Label */ ;
#line 335
    if (! (i < ((bus_params_t___9 *)bus___0->params)->dw)) {
#line 335
      goto while_break;
    }
    {
#line 336
    part_set_signal(p, ((bus_params_t___9 *)bus___0->params)->d[j], 1, (int )((d >> i) & 1U));
#line 335
    i ++;
#line 335
    j += ((bus_params_t___9 *)bus___0->params)->di;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 337
  return;
}
}
#line 343 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/prototype.c"
static void prototype_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int tmp ;

  {
  {
#line 346
  p = bus___0->part;
#line 347
  chain = bus___0->chain;
#line 349
  part_set_signal(p, ((bus_params_t___9 *)bus___0->params)->cs, 1, ((bus_params_t___9 *)bus___0->params)->csa);
  }
#line 350
  if (((bus_params_t___9 *)bus___0->params)->wea) {
#line 350
    tmp = 0;
  } else {
#line 350
    tmp = 1;
  }
  {
#line 350
  part_set_signal(p, ((bus_params_t___9 *)bus___0->params)->we, 1, tmp);
#line 351
  part_set_signal(p, ((bus_params_t___9 *)bus___0->params)->oe, 1, ((bus_params_t___9 *)bus___0->params)->oea);
#line 353
  setup_address___9(bus___0, adr);
#line 354
  set_data_in___9(bus___0);
#line 356
  chain_shift_data_registers(chain, 0);
  }
#line 357
  return;
}
}
#line 363 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/prototype.c"
static uint32_t prototype_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  int j ;
  uint32_t d ;
  bus_area_t area___0 ;
  int tmp ;

  {
  {
#line 366
  p = bus___0->part;
#line 367
  chain = bus___0->chain;
#line 369
  d = (uint32_t )0;
#line 372
  prototype_bus_area(bus___0, adr, & area___0);
#line 374
  setup_address___9(bus___0, adr);
#line 375
  chain_shift_data_registers(chain, 1);
#line 377
  i = 0;
#line 377
  j = ((bus_params_t___9 *)bus___0->params)->dlsbi;
  }
  {
#line 377
  while (1) {
    while_continue: /* CIL Label */ ;
#line 377
    if (! (i < ((bus_params_t___9 *)bus___0->params)->dw)) {
#line 377
      goto while_break;
    }
    {
#line 378
    tmp = part_get_signal(p, ((bus_params_t___9 *)bus___0->params)->d[j]);
#line 378
    d |= (uint32_t )(tmp << i);
#line 377
    i ++;
#line 377
    j += ((bus_params_t___9 *)bus___0->params)->di;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 380
  return (d);
}
}
#line 387 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/prototype.c"
static uint32_t prototype_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  int j ;
  uint32_t d ;
  bus_area_t area___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 390
  p = bus___0->part;
#line 391
  chain = bus___0->chain;
#line 393
  d = (uint32_t )0;
#line 396
  prototype_bus_area(bus___0, (uint32_t )0, & area___0);
  }
#line 398
  if (((bus_params_t___9 *)bus___0->params)->csa) {
#line 398
    tmp = 0;
  } else {
#line 398
    tmp = 1;
  }
  {
#line 398
  part_set_signal(p, ((bus_params_t___9 *)bus___0->params)->cs, 1, tmp);
  }
#line 399
  if (((bus_params_t___9 *)bus___0->params)->oea) {
#line 399
    tmp___0 = 0;
  } else {
#line 399
    tmp___0 = 1;
  }
  {
#line 399
  part_set_signal(p, ((bus_params_t___9 *)bus___0->params)->oe, 1, tmp___0);
#line 400
  chain_shift_data_registers(chain, 1);
#line 402
  i = 0;
#line 402
  j = ((bus_params_t___9 *)bus___0->params)->dlsbi;
  }
  {
#line 402
  while (1) {
    while_continue: /* CIL Label */ ;
#line 402
    if (! (i < ((bus_params_t___9 *)bus___0->params)->dw)) {
#line 402
      goto while_break;
    }
    {
#line 403
    tmp___1 = part_get_signal(p, ((bus_params_t___9 *)bus___0->params)->d[j]);
#line 403
    d |= (uint32_t )(tmp___1 << i);
#line 402
    i ++;
#line 402
    j += ((bus_params_t___9 *)bus___0->params)->di;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 405
  return (d);
}
}
#line 412 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/prototype.c"
static void prototype_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 415
  p = bus___0->part;
#line 416
  chain = bus___0->chain;
#line 418
  part_set_signal(p, ((bus_params_t___9 *)bus___0->params)->cs, 1, ((bus_params_t___9 *)bus___0->params)->csa);
  }
#line 419
  if (((bus_params_t___9 *)bus___0->params)->wea) {
#line 419
    tmp = 0;
  } else {
#line 419
    tmp = 1;
  }
  {
#line 419
  part_set_signal(p, ((bus_params_t___9 *)bus___0->params)->we, 1, tmp);
  }
#line 420
  if (((bus_params_t___9 *)bus___0->params)->oea) {
#line 420
    tmp___0 = 0;
  } else {
#line 420
    tmp___0 = 1;
  }
  {
#line 420
  part_set_signal(p, ((bus_params_t___9 *)bus___0->params)->oe, 1, tmp___0);
#line 422
  setup_address___9(bus___0, adr);
#line 423
  setup_data___9(bus___0, data);
#line 425
  chain_shift_data_registers(chain, 0);
#line 427
  part_set_signal(p, ((bus_params_t___9 *)bus___0->params)->we, 1, ((bus_params_t___9 *)bus___0->params)->wea);
#line 428
  chain_shift_data_registers(chain, 0);
  }
#line 429
  if (((bus_params_t___9 *)bus___0->params)->wea) {
#line 429
    tmp___1 = 0;
  } else {
#line 429
    tmp___1 = 1;
  }
  {
#line 429
  part_set_signal(p, ((bus_params_t___9 *)bus___0->params)->we, 1, tmp___1);
  }
#line 430
  if (((bus_params_t___9 *)bus___0->params)->csa) {
#line 430
    tmp___2 = 0;
  } else {
#line 430
    tmp___2 = 1;
  }
  {
#line 430
  part_set_signal(p, ((bus_params_t___9 *)bus___0->params)->cs, 1, tmp___2);
#line 431
  chain_shift_data_registers(chain, 0);
  }
#line 432
  return;
}
}
#line 434 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/prototype.c"
struct bus_driver  const  prototype_bus  = 
#line 434
     {"prototype", "Configurable prototype bus driver via BSR, requires parameters:\n           amsb=<addr MSB> alsb=<addr LSB> dmsb=<data MSB> dlsb=<data LSB>\n           ncs=<CS#>|cs=<CS> noe=<OE#>|oe=<OE> nwe=<WE#>|we=<WE> [amode=auto|x8|x16|x32]",
    & prototype_bus_new, & generic_bus_free, & prototype_bus_printinfo, & generic_bus_prepare_extest,
    & prototype_bus_area, & prototype_bus_read_start, & prototype_bus_read_next, & prototype_bus_read_end,
    & generic_bus_read, & prototype_bus_write, & generic_bus_no_init};
#line 50 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/buses.h"
struct bus_driver  const  ppc440gx_ebc8_bus ;
#line 58 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ppc440gx_ebc8.c"
static bus_t *ppc440gx_ebc8_bus_new(chain_t *chain , bus_driver_t const   *driver ,
                                    char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  part_t *part ;
  char buff[10] ;
  int i ;
  int failed ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
  {
#line 65
  failed = 0;
#line 67
  tmp = calloc((size_t )1, (size_t )sizeof(bus_t ));
#line 67
  bus___0 = (bus_t *)tmp;
  }
#line 68
  if (! bus___0) {
#line 69
    return ((bus_t *)((void *)0));
  }
  {
#line 71
  bus___0->driver = driver;
#line 72
  bus___0->params = calloc((size_t )1, (size_t )sizeof(bus_params_t___10 ));
  }
#line 73
  if (! bus___0->params) {
    {
#line 74
    free((void *)bus___0);
    }
#line 75
    return ((bus_t *)((void *)0));
  }
#line 78
  bus___0->chain = chain;
#line 79
  part = *((chain->parts)->parts + chain->active_part);
#line 79
  bus___0->part = part;
#line 81
  i = 0;
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    if (! (i < 32)) {
#line 81
      goto while_break;
    }
    {
#line 82
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"EBCADR%d",
            i);
#line 83
    tmp___0 = generic_bus_attach_sig(part, & ((bus_params_t___10 *)bus___0->params)->a[i],
                                     buff);
#line 83
    failed |= tmp___0;
#line 81
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 86
  i = 0;
  {
#line 86
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 86
    if (! (i < 8)) {
#line 86
      goto while_break___0;
    }
    {
#line 87
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"EBCDATA%d",
            i);
#line 88
    tmp___1 = generic_bus_attach_sig(part, & ((bus_params_t___10 *)bus___0->params)->d[i],
                                     buff);
#line 88
    failed |= tmp___1;
#line 86
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 91
  tmp___2 = generic_bus_attach_sig(part, & ((bus_params_t___10 *)bus___0->params)->ncs,
                                   (char *)"EBCCS0_N");
#line 91
  failed |= tmp___2;
#line 93
  tmp___3 = generic_bus_attach_sig(part, & ((bus_params_t___10 *)bus___0->params)->nwe,
                                   (char *)"EBCWE_N");
#line 93
  failed |= tmp___3;
#line 95
  tmp___4 = generic_bus_attach_sig(part, & ((bus_params_t___10 *)bus___0->params)->noe,
                                   (char *)"EBCOE_N");
#line 95
  failed |= tmp___4;
  }
#line 97
  if (failed) {
    {
#line 98
    free(bus___0->params);
#line 99
    free((void *)bus___0);
    }
#line 100
    return ((bus_t *)((void *)0));
  }
#line 103
  return (bus___0);
}
}
#line 110 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ppc440gx_ebc8.c"
static void ppc440gx_ebc8_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;
  char *__cil_tmp4 ;

  {
#line 115
  i = 0;
  {
#line 115
  while (1) {
    while_continue: /* CIL Label */ ;
#line 115
    if (! (i < ((bus___0->chain)->parts)->len)) {
#line 115
      goto while_break;
    }
#line 116
    if ((unsigned long )bus___0->part == (unsigned long )*(((bus___0->chain)->parts)->parts + i)) {
#line 117
      goto while_break;
    }
#line 115
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 118
  tmp = gettext("IBM PowerPC 440GX 8-bit compatible bus driver via BSR (JTAG part No. %d)\n");
#line 118
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 119
  return;
}
}
#line 125 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ppc440gx_ebc8.c"
static int ppc440gx_ebc8_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area___0 ) 
{ 


  {
#line 128
  area___0->description = (char const   *)((void *)0);
#line 129
  area___0->start = 0U;
#line 130
  area___0->length = 4294967296ULL;
#line 131
  area___0->width = 8U;
#line 133
  return (0);
}
}
#line 136 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ppc440gx_ebc8.c"
static void setup_address___10(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 140
  p = bus___0->part;
#line 142
  i = 0;
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 142
    if (! (i < 32)) {
#line 142
      goto while_break;
    }
    {
#line 143
    part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->a[i], 1, (int )((a >> (31 - i)) & 1U));
#line 142
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 144
  return;
}
}
#line 146 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ppc440gx_ebc8.c"
static void set_data_in___10(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area___0 ;

  {
  {
#line 150
  p = bus___0->part;
#line 153
  ppc440gx_ebc8_bus_area(bus___0, (uint32_t )0, & area___0);
#line 155
  i = 0;
  }
  {
#line 155
  while (1) {
    while_continue: /* CIL Label */ ;
#line 155
    if (! ((unsigned int )i < area___0.width)) {
#line 155
      goto while_break;
    }
    {
#line 156
    part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->d[i], 0, 0);
#line 155
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 157
  return;
}
}
#line 159 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ppc440gx_ebc8.c"
static void setup_data___10(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area___0 ;

  {
  {
#line 163
  p = bus___0->part;
#line 166
  ppc440gx_ebc8_bus_area(bus___0, (uint32_t )0, & area___0);
#line 168
  i = 0;
  }
  {
#line 168
  while (1) {
    while_continue: /* CIL Label */ ;
#line 168
    if (! ((unsigned int )i < area___0.width)) {
#line 168
      goto while_break;
    }
    {
#line 169
    part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->d[7 - i], 1, (int )((d >> i) & 1U));
#line 168
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 170
  return;
}
}
#line 176 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ppc440gx_ebc8.c"
static void ppc440gx_ebc8_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
  {
#line 179
  p = bus___0->part;
#line 180
  chain = bus___0->chain;
#line 182
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->ncs, 1, 0);
#line 183
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->nwe, 1, 1);
#line 184
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->noe, 1, 0);
#line 186
  setup_address___10(bus___0, adr);
#line 187
  set_data_in___10(bus___0);
#line 189
  chain_shift_data_registers(chain, 0);
  }
#line 190
  return;
}
}
#line 196 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ppc440gx_ebc8.c"
static uint32_t ppc440gx_ebc8_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  bus_area_t area___0 ;
  int tmp ;

  {
  {
#line 199
  p = bus___0->part;
#line 200
  chain = bus___0->chain;
#line 202
  d = (uint32_t )0;
#line 205
  ppc440gx_ebc8_bus_area(bus___0, adr, & area___0);
#line 207
  setup_address___10(bus___0, adr);
#line 208
  chain_shift_data_registers(chain, 1);
#line 210
  i = 0;
  }
  {
#line 210
  while (1) {
    while_continue: /* CIL Label */ ;
#line 210
    if (! ((unsigned int )i < area___0.width)) {
#line 210
      goto while_break;
    }
    {
#line 211
    tmp = part_get_signal(p, ((bus_params_t___10 *)bus___0->params)->d[7 - i]);
#line 211
    d |= (uint32_t )(tmp << i);
#line 210
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 213
  return (d);
}
}
#line 220 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ppc440gx_ebc8.c"
static uint32_t ppc440gx_ebc8_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  bus_area_t area___0 ;
  int tmp ;

  {
  {
#line 223
  p = bus___0->part;
#line 224
  chain = bus___0->chain;
#line 226
  d = (uint32_t )0;
#line 229
  ppc440gx_ebc8_bus_area(bus___0, (uint32_t )0, & area___0);
#line 231
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->ncs, 1, 1);
#line 232
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->noe, 1, 1);
#line 233
  chain_shift_data_registers(chain, 1);
#line 235
  i = 0;
  }
  {
#line 235
  while (1) {
    while_continue: /* CIL Label */ ;
#line 235
    if (! ((unsigned int )i < area___0.width)) {
#line 235
      goto while_break;
    }
    {
#line 236
    tmp = part_get_signal(p, ((bus_params_t___10 *)bus___0->params)->d[7 - i]);
#line 236
    d |= (uint32_t )(tmp << i);
#line 235
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 238
  return (d);
}
}
#line 245 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ppc440gx_ebc8.c"
static void ppc440gx_ebc8_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
  {
#line 248
  p = bus___0->part;
#line 249
  chain = bus___0->chain;
#line 251
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->ncs, 1, 0);
#line 252
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->nwe, 1, 1);
#line 253
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->noe, 1, 1);
#line 255
  setup_address___10(bus___0, adr);
#line 256
  setup_data___10(bus___0, data);
#line 258
  chain_shift_data_registers(chain, 0);
#line 260
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->nwe, 1, 0);
#line 261
  chain_shift_data_registers(chain, 0);
#line 262
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->nwe, 1, 1);
#line 263
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->ncs, 1, 1);
#line 264
  chain_shift_data_registers(chain, 0);
  }
#line 265
  return;
}
}
#line 267 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ppc440gx_ebc8.c"
struct bus_driver  const  ppc440gx_ebc8_bus  = 
#line 267
     {"ppc440gx_ebc8", "IBM PowerPC 440GX 8-bit EBC compatible bus driver via BSR",
    & ppc440gx_ebc8_bus_new, & generic_bus_free, & ppc440gx_ebc8_bus_printinfo, & generic_bus_prepare_extest,
    & ppc440gx_ebc8_bus_area, & ppc440gx_ebc8_bus_read_start, & ppc440gx_ebc8_bus_read_next,
    & ppc440gx_ebc8_bus_read_end, & generic_bus_read, & ppc440gx_ebc8_bus_write, & generic_bus_no_init};
#line 49 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/buses.h"
struct bus_driver  const  ppc405ep_bus ;
#line 56 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ppc405ep.c"
static bus_t *ppc405ep_bus_new(chain_t *chain , bus_driver_t const   *driver , char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  part_t *part ;
  char buff[10] ;
  int i ;
  int failed ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
  {
#line 63
  failed = 0;
#line 65
  tmp = calloc((size_t )1, (size_t )sizeof(bus_t ));
#line 65
  bus___0 = (bus_t *)tmp;
  }
#line 66
  if (! bus___0) {
#line 67
    return ((bus_t *)((void *)0));
  }
  {
#line 69
  bus___0->driver = driver;
#line 70
  bus___0->params = calloc((size_t )1, (size_t )sizeof(bus_params_t___11 ));
  }
#line 71
  if (! bus___0->params) {
    {
#line 72
    free((void *)bus___0);
    }
#line 73
    return ((bus_t *)((void *)0));
  }
#line 76
  bus___0->chain = chain;
#line 77
  part = *((chain->parts)->parts + chain->active_part);
#line 77
  bus___0->part = part;
#line 79
  i = 6;
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (! (i < 32)) {
#line 79
      goto while_break;
    }
    {
#line 80
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"PerAddr%d",
            i);
#line 81
    tmp___0 = generic_bus_attach_sig(part, & ((bus_params_t___11 *)bus___0->params)->a[i],
                                     buff);
#line 81
    failed |= tmp___0;
#line 79
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 84
  i = 0;
  {
#line 84
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 84
    if (! (i < 16)) {
#line 84
      goto while_break___0;
    }
    {
#line 85
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"PerData%d",
            i);
#line 86
    tmp___1 = generic_bus_attach_sig(part, & ((bus_params_t___11 *)bus___0->params)->d[i],
                                     buff);
#line 86
    failed |= tmp___1;
#line 84
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 89
  tmp___2 = generic_bus_attach_sig(part, & ((bus_params_t___11 *)bus___0->params)->ncs,
                                   (char *)"PerCS0");
#line 89
  failed |= tmp___2;
#line 91
  tmp___3 = generic_bus_attach_sig(part, & ((bus_params_t___11 *)bus___0->params)->nwe,
                                   (char *)"PerWBE1");
#line 91
  failed |= tmp___3;
#line 93
  tmp___4 = generic_bus_attach_sig(part, & ((bus_params_t___11 *)bus___0->params)->noe,
                                   (char *)"PerOE");
#line 93
  failed |= tmp___4;
  }
#line 95
  if (failed) {
    {
#line 96
    free(bus___0->params);
#line 97
    free((void *)bus___0);
    }
#line 98
    return ((bus_t *)((void *)0));
  }
#line 101
  return (bus___0);
}
}
#line 108 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ppc405ep.c"
static void ppc405ep_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;
  char *__cil_tmp4 ;

  {
#line 113
  i = 0;
  {
#line 113
  while (1) {
    while_continue: /* CIL Label */ ;
#line 113
    if (! (i < ((bus___0->chain)->parts)->len)) {
#line 113
      goto while_break;
    }
#line 114
    if ((unsigned long )bus___0->part == (unsigned long )*(((bus___0->chain)->parts)->parts + i)) {
#line 115
      goto while_break;
    }
#line 113
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 116
  tmp = gettext("IBM PowerPC 405EP compatible bus driver via BSR (JTAG part No. %d)\n");
#line 116
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 117
  return;
}
}
#line 123 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ppc405ep.c"
static int ppc405ep_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area___0 ) 
{ 


  {
#line 126
  area___0->description = (char const   *)((void *)0);
#line 127
  area___0->start = 0U;
#line 128
  area___0->length = 4294967296ULL;
#line 129
  area___0->width = 16U;
#line 131
  return (0);
}
}
#line 134 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ppc405ep.c"
static void setup_address___11(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 138
  p = bus___0->part;
#line 140
  i = 6;
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 140
    if (! (i < 32)) {
#line 140
      goto while_break;
    }
    {
#line 141
    part_set_signal(p, ((bus_params_t___11 *)bus___0->params)->a[i], 1, (int )((a >> (31 - i)) & 1U));
#line 140
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 142
  return;
}
}
#line 144 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ppc405ep.c"
static void set_data_in___11(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area___0 ;

  {
  {
#line 148
  p = bus___0->part;
#line 151
  ppc405ep_bus_area(bus___0, (uint32_t )0, & area___0);
#line 153
  i = 0;
  }
  {
#line 153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 153
    if (! ((unsigned int )i < area___0.width)) {
#line 153
      goto while_break;
    }
    {
#line 154
    part_set_signal(p, ((bus_params_t___11 *)bus___0->params)->d[i], 0, 0);
#line 153
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 155
  return;
}
}
#line 157 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ppc405ep.c"
static void setup_data___11(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area___0 ;

  {
  {
#line 161
  p = bus___0->part;
#line 164
  ppc405ep_bus_area(bus___0, (uint32_t )0, & area___0);
#line 166
  i = 0;
  }
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
#line 166
    if (! ((unsigned int )i < area___0.width)) {
#line 166
      goto while_break;
    }
    {
#line 167
    part_set_signal(p, ((bus_params_t___11 *)bus___0->params)->d[15 - i], 1, (int )((d >> i) & 1U));
#line 166
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 168
  return;
}
}
#line 174 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ppc405ep.c"
static void ppc405ep_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
  {
#line 177
  p = bus___0->part;
#line 178
  chain = bus___0->chain;
#line 180
  part_set_signal(p, ((bus_params_t___11 *)bus___0->params)->ncs, 1, 0);
#line 181
  part_set_signal(p, ((bus_params_t___11 *)bus___0->params)->nwe, 1, 1);
#line 182
  part_set_signal(p, ((bus_params_t___11 *)bus___0->params)->noe, 1, 0);
#line 184
  setup_address___11(bus___0, adr);
#line 185
  set_data_in___11(bus___0);
#line 187
  chain_shift_data_registers(chain, 0);
  }
#line 188
  return;
}
}
#line 194 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ppc405ep.c"
static uint32_t ppc405ep_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  bus_area_t area___0 ;
  int tmp ;

  {
  {
#line 197
  p = bus___0->part;
#line 198
  chain = bus___0->chain;
#line 200
  d = (uint32_t )0;
#line 203
  ppc405ep_bus_area(bus___0, adr, & area___0);
#line 205
  setup_address___11(bus___0, adr);
#line 206
  chain_shift_data_registers(chain, 1);
#line 208
  i = 0;
  }
  {
#line 208
  while (1) {
    while_continue: /* CIL Label */ ;
#line 208
    if (! ((unsigned int )i < area___0.width)) {
#line 208
      goto while_break;
    }
    {
#line 209
    tmp = part_get_signal(p, ((bus_params_t___11 *)bus___0->params)->d[15 - i]);
#line 209
    d |= (uint32_t )(tmp << i);
#line 208
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 211
  return (d);
}
}
#line 218 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ppc405ep.c"
static uint32_t ppc405ep_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  bus_area_t area___0 ;
  int tmp ;

  {
  {
#line 221
  p = bus___0->part;
#line 222
  chain = bus___0->chain;
#line 224
  d = (uint32_t )0;
#line 227
  ppc405ep_bus_area(bus___0, (uint32_t )0, & area___0);
#line 229
  part_set_signal(p, ((bus_params_t___11 *)bus___0->params)->ncs, 1, 1);
#line 230
  part_set_signal(p, ((bus_params_t___11 *)bus___0->params)->noe, 1, 1);
#line 231
  chain_shift_data_registers(chain, 1);
#line 233
  i = 0;
  }
  {
#line 233
  while (1) {
    while_continue: /* CIL Label */ ;
#line 233
    if (! ((unsigned int )i < area___0.width)) {
#line 233
      goto while_break;
    }
    {
#line 234
    tmp = part_get_signal(p, ((bus_params_t___11 *)bus___0->params)->d[15 - i]);
#line 234
    d |= (uint32_t )(tmp << i);
#line 233
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 236
  return (d);
}
}
#line 243 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ppc405ep.c"
static void ppc405ep_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
  {
#line 246
  p = bus___0->part;
#line 247
  chain = bus___0->chain;
#line 249
  part_set_signal(p, ((bus_params_t___11 *)bus___0->params)->ncs, 1, 0);
#line 250
  part_set_signal(p, ((bus_params_t___11 *)bus___0->params)->nwe, 1, 1);
#line 251
  part_set_signal(p, ((bus_params_t___11 *)bus___0->params)->noe, 1, 1);
#line 253
  setup_address___11(bus___0, adr);
#line 254
  setup_data___11(bus___0, data);
#line 256
  chain_shift_data_registers(chain, 0);
#line 258
  part_set_signal(p, ((bus_params_t___11 *)bus___0->params)->nwe, 1, 0);
#line 259
  chain_shift_data_registers(chain, 0);
#line 260
  part_set_signal(p, ((bus_params_t___11 *)bus___0->params)->nwe, 1, 1);
#line 261
  part_set_signal(p, ((bus_params_t___11 *)bus___0->params)->ncs, 1, 1);
#line 262
  chain_shift_data_registers(chain, 0);
  }
#line 263
  return;
}
}
#line 265 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ppc405ep.c"
struct bus_driver  const  ppc405ep_bus  = 
#line 265
     {"ppc405ep", "IBM PowerPC 405EP compatible bus driver via BSR", & ppc405ep_bus_new,
    & generic_bus_free, & ppc405ep_bus_printinfo, & generic_bus_prepare_extest, & ppc405ep_bus_area,
    & ppc405ep_bus_read_start, & ppc405ep_bus_read_next, & ppc405ep_bus_read_end,
    & generic_bus_read, & ppc405ep_bus_write, & generic_bus_no_init};
#line 48 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/buses.h"
struct bus_driver  const  mpc824x_bus ;
#line 63 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/mpc824x.c"
int BUS_WIDTH  =    8;
#line 64 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/mpc824x.c"
char REVBITS  =    (char)0;
#line 65 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/mpc824x.c"
char dbgAddr  =    (char)0;
#line 66 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/mpc824x.c"
char dbgData  =    (char)0;
#line 73 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/mpc824x.c"
static bus_t *mpc824x_bus_new(chain_t *chain , bus_driver_t const   *driver , char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  part_t *part ;
  char buff[10] ;
  int i ;
  int failed ;
  signal_t *s_nfoe ;
  signal_t *s_sdma1 ;
  char param[16] ;
  char value[16] ;
  char dfltWidth ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  void *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  void *__cil_tmp38 ;
  void *__cil_tmp39 ;
  void *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;

  {
#line 80
  failed = 0;
#line 86
  dfltWidth = (char)1;
#line 88
  dbgAddr = (char)0;
#line 89
  dbgData = (char)0;
#line 90
  REVBITS = (char)0;
#line 92
  i = 2;
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    if (! *(cmd_params___0 + i)) {
#line 92
      goto while_break;
    }
    {
#line 93
    tmp___10 = strstr((char const   *)*(cmd_params___0 + i), "=");
    }
#line 93
    if (tmp___10) {
      {
#line 94
      sscanf((char const   */* __restrict  */)*(cmd_params___0 + i), (char const   */* __restrict  */)"%[^=]%*c%s",
             param, value);
#line 96
      tmp___4 = strcmp("width", (char const   *)(param));
      }
#line 96
      if (! tmp___4) {
        {
#line 97
        tmp___3 = strcmp("8", (char const   *)(value));
        }
#line 97
        if (tmp___3) {
          {
#line 100
          tmp___2 = strcmp("32", (char const   *)(value));
          }
#line 100
          if (tmp___2) {
            {
#line 104
            tmp___1 = strcmp("64", (char const   *)(value));
            }
#line 104
            if (tmp___1) {
              {
#line 111
              tmp___0 = gettext("   Only 8,32 and 64 bus width are supported for Banks 0 and 1\n");
#line 111
              printf((char const   */* __restrict  */)tmp___0);
              }
#line 112
              return ((bus_t *)((void *)0));
            } else {
              {
#line 106
              BUS_WIDTH = 32;
#line 107
              tmp = gettext("   Bus width 64 exists in mpc824x, but not supported by UrJTAG currently\n");
#line 107
              printf((char const   */* __restrict  */)tmp);
#line 108
              dfltWidth = (char)1;
              }
            }
          } else {
#line 101
            BUS_WIDTH = 32;
#line 102
            dfltWidth = (char)0;
          }
        } else {
#line 98
          BUS_WIDTH = 8;
#line 99
          dfltWidth = (char)0;
        }
      }
    } else {
      {
#line 116
      tmp___5 = strcmp("revbits", (char const   *)*(cmd_params___0 + i));
      }
#line 116
      if (! tmp___5) {
#line 117
        REVBITS = (char)1;
      }
      {
#line 119
      tmp___7 = strcmp("help", (char const   *)*(cmd_params___0 + i));
      }
#line 119
      if (! tmp___7) {
        {
#line 120
        tmp___6 = gettext("Usage: initbus mpc824x [width=WIDTH] [revbits] [dbgAddr] [dbgData]\n\n   WIDTH      data bus width - 8, 32, 64 (default 8)\n   revbits    reverse bits in data bus (default - no)\n   dbgAddr    display address bus state (default - no)\n   dbgData    display data bus state (default - no)\n");
#line 120
        printf((char const   */* __restrict  */)tmp___6);
        }
#line 125
        return ((bus_t *)((void *)0));
      }
      {
#line 128
      tmp___8 = strcmp("dbgAddr", (char const   *)*(cmd_params___0 + i));
      }
#line 128
      if (! tmp___8) {
#line 129
        dbgAddr = (char)1;
      }
      {
#line 132
      tmp___9 = strcmp("dbgData", (char const   *)*(cmd_params___0 + i));
      }
#line 132
      if (! tmp___9) {
#line 133
        dbgData = (char)1;
      }
    }
#line 92
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 139
  if (dfltWidth) {
    {
#line 140
    tmp___11 = gettext("   Using default bus width %d\n");
#line 140
    printf((char const   */* __restrict  */)tmp___11, BUS_WIDTH);
    }
  }
  {
#line 144
  tmp___12 = calloc((size_t )1, (size_t )sizeof(bus_t ));
#line 144
  bus___0 = (bus_t *)tmp___12;
  }
#line 145
  if (! bus___0) {
#line 146
    return ((bus_t *)((void *)0));
  }
  {
#line 148
  bus___0->driver = driver;
#line 149
  bus___0->params = calloc((size_t )1, (size_t )sizeof(bus_params_t___12 ));
  }
#line 150
  if (! bus___0->params) {
    {
#line 151
    free((void *)bus___0);
    }
#line 152
    return ((bus_t *)((void *)0));
  }
  {
#line 155
  bus___0->chain = chain;
#line 156
  part = *((chain->parts)->parts + chain->active_part);
#line 156
  bus___0->part = part;
#line 158
  s_nfoe = part_find_signal(part, "nFOE");
#line 159
  s_sdma1 = part_find_signal(part, "SDMA1");
#line 160
  part_set_signal(part, s_nfoe, 0, 0);
#line 161
  part_set_signal(part, s_sdma1, 0, 0);
#line 163
  part_set_instruction(part, "SAMPLE/PRELOAD");
#line 164
  chain_shift_instructions(chain);
#line 165
  chain_shift_data_registers(chain, 0);
#line 166
  part_set_instruction(part, "EXTEST");
#line 167
  chain_shift_instructions(chain);
#line 168
  chain_shift_data_registers(chain, 1);
#line 170
  ((bus_params_t___12 *)bus___0->params)->boot_nfoe = part_get_signal(part, s_nfoe);
#line 171
  ((bus_params_t___12 *)bus___0->params)->boot_sdma1 = part_get_signal(part, s_sdma1);
#line 174
  i = 0;
  }
  {
#line 174
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 174
    if (! (i <= 10)) {
#line 174
      goto while_break___0;
    }
    {
#line 175
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"SDMA%d",
            i);
#line 176
    tmp___13 = generic_bus_attach_sig(part, & ((bus_params_t___12 *)bus___0->params)->ar[i],
                                      buff);
#line 176
    failed |= tmp___13;
#line 174
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 179
  tmp___14 = generic_bus_attach_sig(part, & ((bus_params_t___12 *)bus___0->params)->ar[11],
                                    (char *)"SDBA0");
#line 179
  failed |= tmp___14;
#line 181
  i = 0;
  }
  {
#line 181
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 181
    if (! (i < 8)) {
#line 181
      goto while_break___1;
    }
    {
#line 182
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"PAR%d",
            i);
#line 183
    tmp___15 = generic_bus_attach_sig(part, & ((bus_params_t___12 *)bus___0->params)->ar[19 - i],
                                      buff);
#line 183
    failed |= tmp___15;
#line 181
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 186
  tmp___16 = generic_bus_attach_sig(part, & ((bus_params_t___12 *)bus___0->params)->ar[20],
                                    (char *)"SDBA1");
#line 186
  failed |= tmp___16;
#line 188
  tmp___17 = generic_bus_attach_sig(part, & ((bus_params_t___12 *)bus___0->params)->ar[21],
                                    (char *)"SDMA11");
#line 188
  failed |= tmp___17;
#line 190
  tmp___18 = generic_bus_attach_sig(part, & ((bus_params_t___12 *)bus___0->params)->ar[22],
                                    (char *)"SDMA12");
#line 190
  failed |= tmp___18;
#line 192
  tmp___19 = generic_bus_attach_sig(part, & ((bus_params_t___12 *)bus___0->params)->nrcs0,
                                    (char *)"nRCS0");
#line 192
  failed |= tmp___19;
#line 194
  tmp___20 = generic_bus_attach_sig(part, & ((bus_params_t___12 *)bus___0->params)->nwe,
                                    (char *)"nWE");
#line 194
  failed |= tmp___20;
#line 196
  tmp___21 = generic_bus_attach_sig(part, & ((bus_params_t___12 *)bus___0->params)->nfoe,
                                    (char *)"nFOE");
#line 196
  failed |= tmp___21;
#line 209
  i = 0;
  }
  {
#line 209
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 209
    if (! (i < 32)) {
#line 209
      goto while_break___2;
    }
    {
#line 210
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"MDH%d",
            31 - i);
#line 211
    tmp___22 = generic_bus_attach_sig(part, & ((bus_params_t___12 *)bus___0->params)->d[i],
                                      buff);
#line 211
    failed |= tmp___22;
#line 209
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 214
  if (failed) {
    {
#line 215
    free(bus___0->params);
#line 216
    free((void *)bus___0);
    }
#line 217
    return ((bus_t *)((void *)0));
  }
#line 220
  return (bus___0);
}
}
#line 227 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/mpc824x.c"
static void mpc824x_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;
  char *__cil_tmp4 ;

  {
#line 232
  i = 0;
  {
#line 232
  while (1) {
    while_continue: /* CIL Label */ ;
#line 232
    if (! (i < ((bus___0->chain)->parts)->len)) {
#line 232
      goto while_break;
    }
#line 233
    if ((unsigned long )bus___0->part == (unsigned long )*(((bus___0->chain)->parts)->parts + i)) {
#line 234
      goto while_break;
    }
#line 232
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 235
  tmp = gettext("Motorola MPC824x compatible bus driver via BSR (JTAG part No. %d)\n");
#line 235
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 236
  return;
}
}
#line 242 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/mpc824x.c"
static int mpc824x_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area___0 ) 
{ 
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 246
  if (adr < 4278190080U) {
#line 247
    area___0->description = (char const   *)((void *)0);
#line 248
    area___0->start = 0U;
#line 249
    area___0->length = 4278190080ULL;
#line 250
    area___0->width = 0U;
#line 252
    return (0);
  }
#line 255
  if (adr < 4286578688U) {
#line 256
    area___0->description = "Base ROM Interface (Bank 1)";
#line 257
    area___0->start = 4278190080U;
#line 258
    area___0->length = 8388608ULL;
#line 259
    area___0->width = 0U;
#line 261
    return (0);
  }
#line 264
  if (((bus_params_t___12 *)bus___0->params)->boot_sdma1 == 0) {
#line 265
    area___0->description = "Base ROM Interface (Bank 0)";
#line 266
    area___0->start = 4286578688U;
#line 267
    area___0->length = 8388608ULL;
#line 268
    area___0->width = (unsigned int )BUS_WIDTH;
#line 270
    return (0);
  }
#line 274
  if (adr < 4290772992U) {
#line 275
    area___0->description = (char const   *)((void *)0);
#line 276
    area___0->start = 4286578688U;
#line 277
    area___0->length = 4194304ULL;
#line 278
    area___0->width = (unsigned int )BUS_WIDTH;
#line 280
    return (0);
  }
#line 283
  area___0->description = "Base ROM Interface (Bank 0)";
#line 284
  area___0->start = 4290772992U;
#line 285
  area___0->length = 4194304ULL;
#line 286
  area___0->width = (unsigned int )BUS_WIDTH;
#line 288
  return (0);
}
}
#line 291 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/mpc824x.c"
static void setup_address___12(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;
  char *tmp ;
  int j ;
  int k ;
  char *tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 295
  p = bus___0->part;
  {
#line 298
  if (BUS_WIDTH == 8) {
#line 298
    goto case_8;
  }
#line 302
  if (BUS_WIDTH == 32) {
#line 302
    goto case_32;
  }
#line 306
  if (BUS_WIDTH == 64) {
#line 306
    goto case_64;
  }
#line 310
  goto switch_default;
  case_8: /* CIL Label */ 
#line 299
  i = 0;
  {
#line 299
  while (1) {
    while_continue: /* CIL Label */ ;
#line 299
    if (! (i < 23)) {
#line 299
      goto while_break;
    }
    {
#line 300
    part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->ar[i], 1, (int )((a >> i) & 1U));
#line 299
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 301
  goto switch_break;
  case_32: /* CIL Label */ 
#line 303
  i = 0;
  {
#line 303
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 303
    if (! (i < 21)) {
#line 303
      goto while_break___0;
    }
    {
#line 304
    part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->ar[i], 1, (int )((a >> (i + 2)) & 1U));
#line 303
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 305
  goto switch_break;
  case_64: /* CIL Label */ 
#line 307
  i = 0;
  {
#line 307
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 307
    if (! (i < 20)) {
#line 307
      goto while_break___1;
    }
    {
#line 308
    part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->ar[i], 1, (int )((a >> (i + 3)) & 1U));
#line 307
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 309
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 311
  tmp = gettext("Warning: unhandled bus width: %i\n");
#line 311
  printf((char const   */* __restrict  */)tmp, BUS_WIDTH);
  }
#line 312
  return;
  switch_break: /* CIL Label */ ;
  }
#line 316
  if (dbgAddr) {
    {
#line 319
    if (BUS_WIDTH == 8) {
#line 319
      goto case_8___0;
    }
#line 320
    if (BUS_WIDTH == 32) {
#line 320
      goto case_32___0;
    }
#line 321
    if (BUS_WIDTH == 64) {
#line 321
      goto case_64___0;
    }
#line 322
    goto switch_default___0;
    case_8___0: /* CIL Label */ 
#line 319
    k = 23;
#line 319
    goto switch_break___0;
    case_32___0: /* CIL Label */ 
#line 320
    k = 21;
#line 320
    goto switch_break___0;
    case_64___0: /* CIL Label */ 
#line 321
    k = 20;
#line 321
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 322
    return;
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 325
    tmp___0 = gettext("Addr    [%2d:0]: %06X   ");
#line 325
    printf((char const   */* __restrict  */)tmp___0, k, a);
#line 326
    i = 0;
    }
    {
#line 326
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 326
      if (! (i < 3)) {
#line 326
        goto while_break___2;
      }
#line 327
      j = 0;
      {
#line 327
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 327
        if (! (j < 8)) {
#line 327
          goto while_break___3;
        }
#line 328
        if (i * 8 + j >= 23 - k) {
          {
#line 329
          printf((char const   */* __restrict  */)"%1d", (a >> (23 - (i * 8 + j))) & 1U);
          }
        } else {
          {
#line 331
          printf((char const   */* __restrict  */)" ");
          }
        }
#line 327
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 332
      printf((char const   */* __restrict  */)" ");
#line 326
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 334
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 337
  return;
}
}
#line 339 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/mpc824x.c"
static void set_data_in___12(bus_t *bus___0 , uint32_t adr ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area___0 ;

  {
  {
#line 343
  p = bus___0->part;
#line 346
  mpc824x_bus_area(bus___0, adr, & area___0);
  }
#line 347
  if (area___0.width > 64U) {
#line 348
    return;
  }
#line 350
  i = 0;
  {
#line 350
  while (1) {
    while_continue: /* CIL Label */ ;
#line 350
    if (! ((unsigned int )i < area___0.width)) {
#line 350
      goto while_break;
    }
    {
#line 351
    part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->d[i], 0, 0);
#line 350
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 352
  return;
}
}
#line 354 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/mpc824x.c"
static void setup_data___12(bus_t *bus___0 , uint32_t adr , uint32_t d ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area___0 ;
  int tmp ;
  char *tmp___0 ;
  int j ;
  int bytes ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 358
  p = bus___0->part;
#line 361
  mpc824x_bus_area(bus___0, adr, & area___0);
  }
#line 362
  if (area___0.width > 64U) {
#line 363
    return;
  }
#line 365
  i = 0;
  {
#line 365
  while (1) {
    while_continue: /* CIL Label */ ;
#line 365
    if (! ((unsigned int )i < area___0.width)) {
#line 365
      goto while_break;
    }
#line 366
    if ((int )REVBITS == 1) {
#line 366
      tmp = (BUS_WIDTH - 1) - i;
    } else {
#line 366
      tmp = i;
    }
    {
#line 366
    part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->d[i], 1, (int )((d >> tmp) & 1U));
#line 365
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 369
  if (dbgData) {
    {
#line 370
    tmp___0 = gettext("Data WR [%d:0]: %08X   ");
#line 370
    printf((char const   */* __restrict  */)tmp___0, area___0.width - 1U, d);
#line 372
    bytes = 0;
    }
#line 373
    if (BUS_WIDTH == 8) {
#line 373
      bytes = 1;
    } else
#line 374
    if (BUS_WIDTH == 32) {
#line 374
      bytes = 4;
    } else
#line 375
    if (BUS_WIDTH == 64) {
#line 375
      bytes = 4;
    }
#line 377
    i = 0;
    {
#line 377
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 377
      if (! (i < bytes)) {
#line 377
        goto while_break___0;
      }
#line 378
      j = 0;
      {
#line 378
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 378
        if (! (j < 8)) {
#line 378
          goto while_break___1;
        }
#line 379
        if (REVBITS) {
          {
#line 380
          printf((char const   */* __restrict  */)"%1d", (d >> ((BUS_WIDTH - 1) - (i * 8 + j))) & 1U);
          }
        } else {
          {
#line 382
          printf((char const   */* __restrict  */)"%1d", (d >> (i * 8 + j)) & 1U);
          }
        }
#line 378
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 383
      printf((char const   */* __restrict  */)" ");
#line 377
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 385
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 388
  return;
}
}
#line 390 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/mpc824x.c"
static uint32_t get_data___0(bus_t *bus___0 , uint32_t adr ) 
{ 
  bus_area_t area___0 ;
  int i ;
  uint32_t d ;
  part_t *p ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int j ;
  int bytes ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 395
  d = (uint32_t )0;
#line 396
  p = bus___0->part;
#line 398
  mpc824x_bus_area(bus___0, adr, & area___0);
  }
#line 399
  if (area___0.width > 64U) {
#line 400
    return ((uint32_t )0);
  }
#line 402
  i = 0;
  {
#line 402
  while (1) {
    while_continue: /* CIL Label */ ;
#line 402
    if (! ((unsigned int )i < area___0.width)) {
#line 402
      goto while_break;
    }
    {
#line 403
    tmp = part_get_signal(p, ((bus_params_t___12 *)bus___0->params)->d[i]);
    }
#line 403
    if ((int )REVBITS == 1) {
#line 403
      tmp___0 = (BUS_WIDTH - 1) - i;
    } else {
#line 403
      tmp___0 = i;
    }
#line 403
    d |= (uint32_t )(tmp << tmp___0);
#line 402
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 406
  if (dbgData) {
    {
#line 407
    tmp___1 = gettext("Data RD [%d:0]: %08X   ");
#line 407
    printf((char const   */* __restrict  */)tmp___1, area___0.width - 1U, d);
#line 409
    bytes = 0;
    }
#line 410
    if (BUS_WIDTH == 8) {
#line 410
      bytes = 1;
    } else
#line 411
    if (BUS_WIDTH == 32) {
#line 411
      bytes = 4;
    } else
#line 412
    if (BUS_WIDTH == 64) {
#line 412
      bytes = 4;
    }
#line 414
    i = 0;
    {
#line 414
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 414
      if (! (i < bytes)) {
#line 414
        goto while_break___0;
      }
#line 415
      j = 0;
      {
#line 415
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 415
        if (! (j < 8)) {
#line 415
          goto while_break___1;
        }
#line 416
        if (REVBITS) {
          {
#line 417
          printf((char const   */* __restrict  */)"%1d", (d >> ((BUS_WIDTH - 1) - (i * 8 + j))) & 1U);
          }
        } else {
          {
#line 419
          printf((char const   */* __restrict  */)"%1d", (d >> (i * 8 + j)) & 1U);
          }
        }
#line 415
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 420
      printf((char const   */* __restrict  */)" ");
#line 414
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 422
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 425
  return (d);
}
}
#line 432 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/mpc824x.c"
static void mpc824x_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;

  {
  {
#line 435
  p = bus___0->part;
#line 437
  ((bus_params_t___12 *)bus___0->params)->last_adr = adr;
#line 440
  part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->nrcs0, 1, 0);
#line 441
  part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->nwe, 1, 1);
#line 442
  part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->nfoe, 1, 0);
#line 444
  setup_address___12(bus___0, adr);
#line 445
  set_data_in___12(bus___0, adr);
#line 447
  chain_shift_data_registers(bus___0->chain, 0);
  }
#line 448
  return;
}
}
#line 454 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/mpc824x.c"
static uint32_t mpc824x_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t d ;

  {
  {
#line 459
  setup_address___12(bus___0, adr);
#line 460
  chain_shift_data_registers(bus___0->chain, 1);
#line 462
  d = get_data___0(bus___0, ((bus_params_t___12 *)bus___0->params)->last_adr);
#line 463
  ((bus_params_t___12 *)bus___0->params)->last_adr = adr;
  }
#line 464
  return (d);
}
}
#line 471 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/mpc824x.c"
static uint32_t mpc824x_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  uint32_t tmp ;

  {
  {
#line 474
  p = bus___0->part;
#line 476
  part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->nrcs0, 1, 1);
#line 477
  part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->nfoe, 1, 1);
#line 479
  chain_shift_data_registers(bus___0->chain, 1);
#line 481
  tmp = get_data___0(bus___0, ((bus_params_t___12 *)bus___0->params)->last_adr);
  }
#line 481
  return (tmp);
}
}
#line 488 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/mpc824x.c"
static void mpc824x_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;

  {
  {
#line 491
  p = bus___0->part;
#line 493
  ((bus_params_t___12 *)bus___0->params)->last_adr = adr;
#line 497
  part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->nrcs0, 1, 0);
#line 498
  part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->nwe, 1, 1);
#line 499
  part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->nfoe, 1, 1);
#line 501
  setup_address___12(bus___0, adr);
#line 503
  setup_data___12(bus___0, adr, data);
#line 505
  chain_shift_data_registers(bus___0->chain, 0);
#line 507
  part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->nwe, 1, 0);
#line 508
  chain_shift_data_registers(bus___0->chain, 0);
#line 509
  part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->nwe, 1, 1);
#line 510
  part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->nrcs0, 1, 1);
#line 511
  chain_shift_data_registers(bus___0->chain, 0);
  }
#line 515
  return;
}
}
#line 517 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/mpc824x.c"
struct bus_driver  const  mpc824x_bus  = 
#line 517
     {"mpc824x", "Motorola MPC824x compatible bus driver via BSR", & mpc824x_bus_new,
    & generic_bus_free, & mpc824x_bus_printinfo, & generic_bus_prepare_extest, & mpc824x_bus_area,
    & mpc824x_bus_read_start, & mpc824x_bus_read_next, & mpc824x_bus_read_end, & generic_bus_read,
    & mpc824x_bus_write, & generic_bus_no_init};
#line 538 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncasecmp)(char const   *__s1 ,
                                                                                          char const   *__s2 ,
                                                                                          size_t __n )  __attribute__((__pure__)) ;
#line 47 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/buses.h"
struct bus_driver  const  mpc5200_bus ;
#line 73 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/mpc5200.c"
static bus_t *mpc5200_bus_new(chain_t *chain , bus_driver_t const   *driver , char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  bus_params_t___13 *bp ;
  part_t *part ;
  char buff[10] ;
  int i ;
  int failed ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  void *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
  {
#line 81
  failed = 0;
#line 83
  tmp = calloc((size_t )1, (size_t )sizeof(bus_t ));
#line 83
  bus___0 = (bus_t *)tmp;
  }
#line 84
  if (! bus___0) {
#line 85
    return ((bus_t *)((void *)0));
  }
  {
#line 87
  bus___0->driver = driver;
#line 88
  tmp___0 = calloc((size_t )1, (size_t )sizeof(bus_params_t___13 ));
#line 88
  bp = (bus_params_t___13 *)tmp___0;
#line 88
  bus___0->params = (void *)bp;
  }
#line 89
  if (! bus___0->params) {
    {
#line 90
    free((void *)bus___0);
    }
#line 91
    return ((bus_t *)((void *)0));
  }
#line 94
  bp->lpc_num_ad = 24;
#line 95
  bp->lpc_num_d = 8;
#line 97
  if (*(cmd_params___0 + 2)) {
    {
#line 97
    tmp___1 = strncasecmp("MUX", (char const   *)*(cmd_params___0 + 2), (size_t )3);
    }
#line 97
    if (! tmp___1) {
#line 98
      bp->lpc_num_ad = 25;
#line 99
      bp->lpc_num_d = 16;
#line 100
      bp->muxed = 1;
    }
  }
#line 102
  if (bp->muxed) {
#line 102
    tmp___2 = "";
  } else {
#line 102
    tmp___2 = "Non-";
  }
  {
#line 102
  printf((char const   */* __restrict  */)"%sMUXed %db address, %db data bus\n", tmp___2,
         bp->lpc_num_ad, bp->lpc_num_d);
#line 104
  bus___0->chain = chain;
#line 105
  part = *((chain->parts)->parts + chain->active_part);
#line 105
  bus___0->part = part;
#line 108
  i = 0;
  }
  {
#line 108
  while (1) {
    while_continue: /* CIL Label */ ;
#line 108
    if (! (i < 32)) {
#line 108
      goto while_break;
    }
    {
#line 109
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"EXT_AD_%d",
            i);
#line 110
    tmp___3 = generic_bus_attach_sig(part, & ((bus_params_t___13 *)bus___0->params)->ad[i],
                                     buff);
#line 110
    failed |= tmp___3;
#line 108
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 113
  i = 0;
  {
#line 113
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 113
    if (! (i < 6)) {
#line 113
      goto while_break___0;
    }
    {
#line 114
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"LP_CS%d_B",
            i);
#line 115
    tmp___4 = generic_bus_attach_sig(part, & ((bus_params_t___13 *)bus___0->params)->ncs[i],
                                     buff);
#line 115
    failed |= tmp___4;
#line 113
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 118
  tmp___5 = generic_bus_attach_sig(part, & ((bus_params_t___13 *)bus___0->params)->nwe,
                                   (char *)"LP_RW");
#line 118
  failed |= tmp___5;
#line 120
  tmp___6 = generic_bus_attach_sig(part, & ((bus_params_t___13 *)bus___0->params)->noe,
                                   (char *)"LP_OE");
#line 120
  failed |= tmp___6;
#line 122
  tmp___7 = generic_bus_attach_sig(part, & ((bus_params_t___13 *)bus___0->params)->nale,
                                   (char *)"LP_ALE_B");
#line 122
  failed |= tmp___7;
#line 124
  tmp___8 = generic_bus_attach_sig(part, & ((bus_params_t___13 *)bus___0->params)->ata_iso,
                                   (char *)"ATA_ISOLATION");
#line 124
  failed |= tmp___8;
  }
#line 126
  if (failed) {
    {
#line 127
    free(bus___0->params);
#line 128
    free((void *)bus___0);
    }
#line 129
    return ((bus_t *)((void *)0));
  }
#line 132
  return (bus___0);
}
}
#line 139 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/mpc5200.c"
static void mpc5200_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;
  char *__cil_tmp4 ;

  {
#line 144
  i = 0;
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
#line 144
    if (! (i < ((bus___0->chain)->parts)->len)) {
#line 144
      goto while_break;
    }
#line 145
    if ((unsigned long )bus___0->part == (unsigned long )*(((bus___0->chain)->parts)->parts + i)) {
#line 146
      goto while_break;
    }
#line 144
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 147
  tmp = gettext("Freescale MPC5200 compatible bus driver via BSR (JTAG part No. %d)\n");
#line 147
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 148
  return;
}
}
#line 154 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/mpc5200.c"
static int mpc5200_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area___0 ) 
{ 
  bus_params_t___13 *bp ;
  char *__cil_tmp5 ;

  {
#line 157
  bp = (bus_params_t___13 *)bus___0->params;
#line 159
  if ((unsigned long long )adr < (1ULL << bp->lpc_num_ad) * 6ULL) {
#line 161
    area___0->description = "LocalPlus Bus";
#line 162
    area___0->start = 0U;
#line 163
    area___0->length = (1ULL << bp->lpc_num_ad) * 6ULL;
#line 164
    area___0->width = (unsigned int )bp->lpc_num_d;
#line 165
    return (0);
  }
#line 168
  area___0->description = (char const   *)((void *)0);
#line 169
  area___0->start = (uint32_t )((1ULL << bp->lpc_num_ad) * 6ULL);
#line 170
  area___0->length = 4294967296ULL - (1ULL << bp->lpc_num_ad) * 6ULL;
#line 171
  area___0->width = 0U;
#line 172
  return (0);
}
}
#line 175 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/mpc5200.c"
static void setup_address___13(bus_t *bus___0 , uint32_t a ) 
{ 
  bus_params_t___13 *bp ;
  part_t *p ;
  int i ;

  {
#line 178
  bp = (bus_params_t___13 *)bus___0->params;
#line 179
  p = bus___0->part;
#line 182
  i = 0;
  {
#line 182
  while (1) {
    while_continue: /* CIL Label */ ;
#line 182
    if (! (i < bp->lpc_num_ad)) {
#line 182
      goto while_break;
    }
    {
#line 183
    part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->ad[i], 1, (int )((a >> i) & 1U));
#line 182
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 184
  return;
}
}
#line 186 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/mpc5200.c"
static void set_data_in___13(bus_t *bus___0 , uint32_t adr ) 
{ 
  bus_params_t___13 *bp ;
  part_t *p ;
  bus_area_t area___0 ;
  int i ;

  {
  {
#line 189
  bp = (bus_params_t___13 *)bus___0->params;
#line 190
  p = bus___0->part;
#line 194
  mpc5200_bus_area(bus___0, adr, & area___0);
  }
#line 195
  if (area___0.width > (unsigned int )bp->lpc_num_d) {
#line 196
    return;
  }
#line 198
  i = 0;
  {
#line 198
  while (1) {
    while_continue: /* CIL Label */ ;
#line 198
    if (! ((unsigned int )i < area___0.width)) {
#line 198
      goto while_break;
    }
    {
#line 199
    part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->ad[i + (32 - bp->lpc_num_d)],
                    0, 0);
#line 198
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 200
  return;
}
}
#line 202 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/mpc5200.c"
static void setup_data___13(bus_t *bus___0 , uint32_t adr , uint32_t d ) 
{ 
  bus_params_t___13 *bp ;
  part_t *p ;
  bus_area_t area___0 ;
  int i ;

  {
  {
#line 205
  bp = (bus_params_t___13 *)bus___0->params;
#line 206
  p = bus___0->part;
#line 210
  mpc5200_bus_area(bus___0, adr, & area___0);
  }
#line 211
  if (area___0.width > (unsigned int )bp->lpc_num_d) {
#line 212
    return;
  }
#line 214
  i = 0;
  {
#line 214
  while (1) {
    while_continue: /* CIL Label */ ;
#line 214
    if (! ((unsigned int )i < area___0.width)) {
#line 214
      goto while_break;
    }
    {
#line 215
    part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->ad[i + (32 - bp->lpc_num_d)],
                    1, (int )((d >> i) & 1U));
#line 214
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 216
  return;
}
}
#line 218 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/mpc5200.c"
static uint32_t get_data___1(bus_t *bus___0 , uint32_t adr ) 
{ 
  bus_params_t___13 *bp ;
  bus_area_t area___0 ;
  uint32_t d ;
  part_t *p ;
  int i ;
  int tmp ;

  {
  {
#line 221
  bp = (bus_params_t___13 *)bus___0->params;
#line 223
  d = (uint32_t )0;
#line 224
  p = bus___0->part;
#line 227
  mpc5200_bus_area(bus___0, adr, & area___0);
  }
#line 228
  if (area___0.width > (unsigned int )bp->lpc_num_d) {
#line 229
    return ((uint32_t )0);
  }
#line 231
  i = 0;
  {
#line 231
  while (1) {
    while_continue: /* CIL Label */ ;
#line 231
    if (! ((unsigned int )i < area___0.width)) {
#line 231
      goto while_break;
    }
    {
#line 232
    tmp = part_get_signal(p, ((bus_params_t___13 *)bus___0->params)->ad[i + (32 - bp->lpc_num_d)]);
#line 232
    d |= (uint32_t )(tmp << i);
#line 231
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 234
  return (d);
}
}
#line 241 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/mpc5200.c"
static void mpc5200_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  bus_params_t___13 *bp ;
  part_t *p ;
  uint8_t cs ;
  int i ;

  {
#line 244
  bp = (bus_params_t___13 *)bus___0->params;
#line 245
  p = bus___0->part;
#line 246
  cs = (uint8_t )(adr >> bp->lpc_num_ad);
#line 249
  ((bus_params_t___13 *)bus___0->params)->last_adr = adr;
#line 253
  i = 0;
  {
#line 253
  while (1) {
    while_continue: /* CIL Label */ ;
#line 253
    if (! (i < 6)) {
#line 253
      goto while_break;
    }
    {
#line 254
    part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->ncs[i], 1, ! ((int )cs == i));
#line 253
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 257
  part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->ata_iso, 1, 1);
#line 258
  part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->nwe, 1, 1);
#line 259
  part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->noe, 1, 0);
#line 261
  setup_address___13(bus___0, adr);
  }
#line 263
  if (! bp->muxed) {
    {
#line 264
    set_data_in___13(bus___0, adr);
    }
  } else {
    {
#line 266
    part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->nale, 1, 0);
#line 267
    chain_shift_data_registers(bus___0->chain, 0);
#line 268
    part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->nale, 1, 1);
    }
  }
  {
#line 270
  chain_shift_data_registers(bus___0->chain, 0);
  }
#line 271
  return;
}
}
#line 277 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/mpc5200.c"
static uint32_t mpc5200_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  bus_params_t___13 *bp ;
  part_t *p ;
  uint32_t d ;

  {
#line 280
  bp = (bus_params_t___13 *)bus___0->params;
#line 281
  p = bus___0->part;
#line 284
  if (! bp->muxed) {
    {
#line 285
    setup_address___13(bus___0, adr);
#line 286
    chain_shift_data_registers(bus___0->chain, 1);
#line 287
    d = get_data___1(bus___0, ((bus_params_t___13 *)bus___0->params)->last_adr);
    }
  } else {
    {
#line 289
    set_data_in___13(bus___0, adr);
#line 290
    chain_shift_data_registers(bus___0->chain, 0);
#line 292
    chain_shift_data_registers(bus___0->chain, 1);
#line 293
    d = get_data___1(bus___0, ((bus_params_t___13 *)bus___0->params)->last_adr);
#line 295
    setup_address___13(bus___0, adr);
#line 296
    ((bus_params_t___13 *)bus___0->params)->last_adr = adr;
#line 298
    part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->nale, 1, 0);
#line 299
    chain_shift_data_registers(bus___0->chain, 0);
#line 300
    part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->nale, 1, 1);
#line 301
    chain_shift_data_registers(bus___0->chain, 0);
    }
  }
#line 304
  ((bus_params_t___13 *)bus___0->params)->last_adr = adr;
#line 305
  return (d);
}
}
#line 312 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/mpc5200.c"
static uint32_t mpc5200_bus_read_end(bus_t *bus___0 ) 
{ 
  bus_params_t___13 *bp ;
  part_t *p ;
  int i ;
  uint32_t tmp ;

  {
#line 315
  bp = (bus_params_t___13 *)bus___0->params;
#line 316
  p = bus___0->part;
#line 319
  if (bp->muxed) {
    {
#line 320
    set_data_in___13(bus___0, ((bus_params_t___13 *)bus___0->params)->last_adr);
#line 321
    chain_shift_data_registers(bus___0->chain, 0);
    }
  }
#line 323
  i = 0;
  {
#line 323
  while (1) {
    while_continue: /* CIL Label */ ;
#line 323
    if (! (i < 6)) {
#line 323
      goto while_break;
    }
    {
#line 324
    part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->ncs[i], 1, 1);
#line 323
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 326
  part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->noe, 1, 1);
#line 328
  chain_shift_data_registers(bus___0->chain, 1);
#line 330
  tmp = get_data___1(bus___0, ((bus_params_t___13 *)bus___0->params)->last_adr);
  }
#line 330
  return (tmp);
}
}
#line 337 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/mpc5200.c"
static void mpc5200_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  bus_params_t___13 *bp ;
  part_t *p ;
  chain_t *chain ;
  uint8_t cs ;
  int i ;

  {
#line 340
  bp = (bus_params_t___13 *)bus___0->params;
#line 342
  p = bus___0->part;
#line 343
  chain = bus___0->chain;
#line 344
  cs = (uint8_t )(adr >> bp->lpc_num_ad);
#line 347
  if (bp->muxed) {
    {
#line 348
    setup_address___13(bus___0, adr);
#line 349
    part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->nale, 1, 0);
#line 350
    chain_shift_data_registers(chain, 0);
#line 351
    part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->nale, 1, 1);
#line 352
    chain_shift_data_registers(chain, 0);
    }
  }
#line 355
  i = 0;
  {
#line 355
  while (1) {
    while_continue: /* CIL Label */ ;
#line 355
    if (! (i < 6)) {
#line 355
      goto while_break;
    }
    {
#line 356
    part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->ncs[i], 1, ! ((int )cs == i));
#line 355
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 358
  part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->ata_iso, 1, 1);
#line 359
  part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->nwe, 1, 1);
#line 360
  part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->noe, 1, 1);
  }
#line 362
  if (! bp->muxed) {
    {
#line 363
    setup_address___13(bus___0, adr);
    }
  }
  {
#line 364
  setup_data___13(bus___0, adr, data);
#line 366
  chain_shift_data_registers(chain, 0);
#line 368
  part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->nwe, 1, 0);
#line 369
  chain_shift_data_registers(chain, 0);
#line 370
  part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->nwe, 1, 1);
#line 371
  chain_shift_data_registers(chain, 0);
  }
#line 372
  return;
}
}
#line 374 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/mpc5200.c"
struct bus_driver  const  mpc5200_bus  = 
#line 374
     {"mpc5200", "Freescale MPC5200 compatible bus driver via BSR, parameter: [mux]",
    & mpc5200_bus_new, & generic_bus_free, & mpc5200_bus_printinfo, & generic_bus_prepare_extest,
    & mpc5200_bus_area, & mpc5200_bus_read_start, & mpc5200_bus_read_next, & mpc5200_bus_read_end,
    & generic_bus_read, & mpc5200_bus_write, & generic_bus_no_init};
#line 46 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/buses.h"
struct bus_driver  const  lh7a400_bus ;
#line 74 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/lh7a400.c"
static bus_t *lh7a400_bus_new(chain_t *chain , bus_driver_t const   *driver , char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  part_t *part ;
  char buff[10] ;
  int i ;
  int failed ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
  {
#line 81
  failed = 0;
#line 83
  tmp = calloc((size_t )1, (size_t )sizeof(bus_t ));
#line 83
  bus___0 = (bus_t *)tmp;
  }
#line 84
  if (! bus___0) {
#line 85
    return ((bus_t *)((void *)0));
  }
  {
#line 87
  bus___0->driver = driver;
#line 88
  bus___0->params = calloc((size_t )1, (size_t )sizeof(bus_params_t___14 ));
  }
#line 89
  if (! bus___0->params) {
    {
#line 90
    free((void *)bus___0);
    }
#line 91
    return ((bus_t *)((void *)0));
  }
#line 94
  bus___0->chain = chain;
#line 95
  part = *((chain->parts)->parts + chain->active_part);
#line 95
  bus___0->part = part;
#line 97
  i = 0;
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
#line 97
    if (! (i < 24)) {
#line 97
      goto while_break;
    }
    {
#line 98
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"A%d",
            i);
#line 99
    tmp___0 = generic_bus_attach_sig(part, & ((bus_params_t___14 *)bus___0->params)->a[i],
                                     buff);
#line 99
    failed |= tmp___0;
#line 97
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  i = 0;
  {
#line 102
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 102
    if (! (i < 32)) {
#line 102
      goto while_break___0;
    }
    {
#line 103
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"D%d",
            i);
#line 104
    tmp___1 = generic_bus_attach_sig(part, & ((bus_params_t___14 *)bus___0->params)->d[i],
                                     buff);
#line 104
    failed |= tmp___1;
#line 102
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 107
  i = 0;
  {
#line 107
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 107
    if (! (i < 4)) {
#line 107
      goto while_break___1;
    }
    {
#line 108
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"nCS%d",
            i);
#line 109
    tmp___2 = generic_bus_attach_sig(part, & ((bus_params_t___14 *)bus___0->params)->ncs[i],
                                     buff);
#line 109
    failed |= tmp___2;
#line 107
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 112
  i = 0;
  {
#line 112
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 112
    if (! (i < 2)) {
#line 112
      goto while_break___2;
    }
    {
#line 113
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"WIDTH%d",
            i);
#line 114
    tmp___3 = generic_bus_attach_sig(part, & ((bus_params_t___14 *)bus___0->params)->width[i],
                                     buff);
#line 114
    failed |= tmp___3;
#line 112
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 117
  tmp___4 = generic_bus_attach_sig(part, & ((bus_params_t___14 *)bus___0->params)->nwe,
                                   (char *)"nWE0");
#line 117
  failed |= tmp___4;
#line 119
  tmp___5 = generic_bus_attach_sig(part, & ((bus_params_t___14 *)bus___0->params)->noe,
                                   (char *)"nOE");
#line 119
  failed |= tmp___5;
  }
#line 121
  if (failed) {
    {
#line 122
    free(bus___0->params);
#line 123
    free((void *)bus___0);
    }
#line 124
    return ((bus_t *)((void *)0));
  }
#line 127
  return (bus___0);
}
}
#line 134 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/lh7a400.c"
static void lh7a400_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;
  char *__cil_tmp4 ;

  {
#line 139
  i = 0;
  {
#line 139
  while (1) {
    while_continue: /* CIL Label */ ;
#line 139
    if (! (i < ((bus___0->chain)->parts)->len)) {
#line 139
      goto while_break;
    }
#line 140
    if ((unsigned long )bus___0->part == (unsigned long )*(((bus___0->chain)->parts)->parts + i)) {
#line 141
      goto while_break;
    }
#line 139
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 142
  tmp = gettext("Sharp LH7A400 compatible bus driver via BSR (JTAG part No. %d)\n");
#line 142
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 143
  return;
}
}
#line 149 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/lh7a400.c"
static int lh7a400_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area___0 ) 
{ 
  unsigned int width ;
  signal_t *tmp ;
  int tmp___0 ;
  signal_t *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 154
  area___0->description = (char const   *)((void *)0);
#line 155
  area___0->start = 0U;
#line 156
  area___0->length = 268435456ULL;
#line 159
  tmp = part_find_signal(bus___0->part, "WIDTH0");
#line 159
  tmp___0 = part_get_signal(bus___0->part, tmp);
#line 159
  width = (unsigned int )tmp___0;
#line 160
  tmp___1 = part_find_signal(bus___0->part, "WIDTH1");
#line 160
  tmp___2 = part_get_signal(bus___0->part, tmp___1);
#line 160
  width |= (unsigned int )(tmp___2 << 1);
  }
#line 162
  if (width < 0U) {
#line 163
    return (1);
  }
  {
#line 166
  if (width == 0U) {
#line 166
    goto case_0;
  }
#line 169
  if (width == 1U) {
#line 169
    goto case_1;
  }
#line 173
  if (width == 3U) {
#line 173
    goto case_3;
  }
#line 173
  if (width == 2U) {
#line 173
    goto case_3;
  }
#line 165
  goto switch_break;
  case_0: /* CIL Label */ 
#line 167
  area___0->width = 8U;
#line 168
  goto switch_break;
  case_1: /* CIL Label */ 
#line 170
  area___0->width = 16U;
#line 171
  goto switch_break;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 174
  area___0->width = 32U;
  switch_break: /* CIL Label */ ;
  }
#line 177
  return (0);
}
}
#line 180 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/lh7a400.c"
static void setup_address___14(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 184
  p = bus___0->part;
#line 186
  i = 0;
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;
#line 186
    if (! (i < 24)) {
#line 186
      goto while_break;
    }
    {
#line 187
    part_set_signal(p, ((bus_params_t___14 *)bus___0->params)->a[i], 1, (int )((a >> i) & 1U));
#line 186
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 188
  return;
}
}
#line 190 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/lh7a400.c"
static void set_data_in___14(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area___0 ;

  {
  {
#line 194
  p = bus___0->part;
#line 197
  lh7a400_bus_area(bus___0, (uint32_t )0, & area___0);
#line 199
  i = 0;
  }
  {
#line 199
  while (1) {
    while_continue: /* CIL Label */ ;
#line 199
    if (! ((unsigned int )i < area___0.width)) {
#line 199
      goto while_break;
    }
    {
#line 200
    part_set_signal(p, ((bus_params_t___14 *)bus___0->params)->d[i], 0, 0);
#line 199
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 202
  return;
}
}
#line 204 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/lh7a400.c"
static void setup_data___14(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area___0 ;

  {
  {
#line 208
  p = bus___0->part;
#line 211
  lh7a400_bus_area(bus___0, (uint32_t )0, & area___0);
#line 213
  i = 0;
  }
  {
#line 213
  while (1) {
    while_continue: /* CIL Label */ ;
#line 213
    if (! ((unsigned int )i < area___0.width)) {
#line 213
      goto while_break;
    }
    {
#line 214
    part_set_signal(p, ((bus_params_t___14 *)bus___0->params)->d[i], 1, (int )((d >> i) & 1U));
#line 213
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 215
  return;
}
}
#line 221 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/lh7a400.c"
static void lh7a400_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
  {
#line 225
  p = bus___0->part;
#line 226
  chain = bus___0->chain;
#line 228
  part_set_signal(p, ((bus_params_t___14 *)bus___0->params)->ncs[0], 1, adr >> 27 != 0U);
#line 229
  part_set_signal(p, ((bus_params_t___14 *)bus___0->params)->nwe, 1, 1);
#line 230
  part_set_signal(p, ((bus_params_t___14 *)bus___0->params)->noe, 1, 0);
#line 232
  setup_address___14(bus___0, adr);
#line 233
  set_data_in___14(bus___0);
#line 235
  chain_shift_data_registers(chain, 0);
  }
#line 236
  return;
}
}
#line 242 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/lh7a400.c"
static uint32_t lh7a400_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  bus_area_t area___0 ;
  int tmp ;

  {
  {
#line 246
  p = bus___0->part;
#line 247
  chain = bus___0->chain;
#line 249
  d = (uint32_t )0;
#line 252
  lh7a400_bus_area(bus___0, adr, & area___0);
#line 254
  setup_address___14(bus___0, adr);
#line 255
  chain_shift_data_registers(chain, 1);
#line 257
  i = 0;
  }
  {
#line 257
  while (1) {
    while_continue: /* CIL Label */ ;
#line 257
    if (! ((unsigned int )i < area___0.width)) {
#line 257
      goto while_break;
    }
    {
#line 258
    tmp = part_get_signal(p, ((bus_params_t___14 *)bus___0->params)->d[i]);
#line 258
    d |= (uint32_t )(tmp << i);
#line 257
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 260
  return (d);
}
}
#line 267 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/lh7a400.c"
static uint32_t lh7a400_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  bus_area_t area___0 ;
  int tmp ;

  {
  {
#line 271
  p = bus___0->part;
#line 272
  chain = bus___0->chain;
#line 274
  d = (uint32_t )0;
#line 277
  lh7a400_bus_area(bus___0, (uint32_t )0, & area___0);
#line 279
  part_set_signal(p, ((bus_params_t___14 *)bus___0->params)->ncs[0], 1, 1);
#line 280
  part_set_signal(p, ((bus_params_t___14 *)bus___0->params)->noe, 1, 1);
#line 282
  chain_shift_data_registers(chain, 1);
#line 284
  i = 0;
  }
  {
#line 284
  while (1) {
    while_continue: /* CIL Label */ ;
#line 284
    if (! ((unsigned int )i < area___0.width)) {
#line 284
      goto while_break;
    }
    {
#line 285
    tmp = part_get_signal(p, ((bus_params_t___14 *)bus___0->params)->d[i]);
#line 285
    d |= (uint32_t )(tmp << i);
#line 284
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 287
  return (d);
}
}
#line 294 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/lh7a400.c"
static void lh7a400_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
  {
#line 298
  p = bus___0->part;
#line 299
  chain = bus___0->chain;
#line 301
  part_set_signal(p, ((bus_params_t___14 *)bus___0->params)->ncs[0], 1, adr >> 27 != 0U);
#line 302
  part_set_signal(p, ((bus_params_t___14 *)bus___0->params)->nwe, 1, 1);
#line 303
  part_set_signal(p, ((bus_params_t___14 *)bus___0->params)->noe, 1, 1);
#line 305
  setup_address___14(bus___0, adr);
#line 306
  setup_data___14(bus___0, data);
#line 308
  chain_shift_data_registers(chain, 0);
#line 310
  part_set_signal(p, ((bus_params_t___14 *)bus___0->params)->nwe, 1, 0);
#line 311
  chain_shift_data_registers(chain, 0);
#line 313
  part_set_signal(p, ((bus_params_t___14 *)bus___0->params)->nwe, 1, 1);
#line 314
  part_set_signal(p, ((bus_params_t___14 *)bus___0->params)->ncs[0], 1, 1);
#line 315
  chain_shift_data_registers(chain, 0);
  }
#line 316
  return;
}
}
#line 318 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/lh7a400.c"
struct bus_driver  const  lh7a400_bus  = 
#line 318
     {"lh7a400", "Sharp LH7A400 compatible bus driver via BSR (flash access only!)",
    & lh7a400_bus_new, & generic_bus_free, & lh7a400_bus_printinfo, & generic_bus_prepare_extest,
    & lh7a400_bus_area, & lh7a400_bus_read_start, & lh7a400_bus_read_next, & lh7a400_bus_read_end,
    & generic_bus_read, & lh7a400_bus_write, & generic_bus_no_init};
#line 45 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/buses.h"
struct bus_driver  const  jopcyc_bus ;
#line 137 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/jopcyc.c"
static bus_t *jopcyc_bus_new(chain_t *chain , bus_driver_t const   *driver , char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  part_t *part ;
  int failed ;
  component_t___0 *comp ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  int tmp___74 ;
  int tmp___75 ;
  int tmp___76 ;
  int tmp___77 ;
  int tmp___78 ;
  int tmp___79 ;
  int tmp___80 ;
  int tmp___81 ;
  int tmp___82 ;
  int tmp___83 ;
  int tmp___84 ;
  int tmp___85 ;
  int tmp___86 ;
  int tmp___87 ;
  int tmp___88 ;
  int tmp___89 ;
  int tmp___90 ;
  int tmp___91 ;
  int tmp___92 ;
  int tmp___93 ;
  int tmp___94 ;
  int tmp___95 ;
  int tmp___96 ;
  int tmp___97 ;
  int tmp___98 ;
  int tmp___99 ;
  int tmp___100 ;
  int tmp___101 ;
  int tmp___102 ;
  int tmp___103 ;
  int tmp___104 ;
  int tmp___105 ;
  int tmp___106 ;
  int tmp___107 ;
  int tmp___108 ;
  int tmp___109 ;
  int tmp___110 ;
  int tmp___111 ;
  int tmp___112 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;
  char *__cil_tmp140 ;
  char *__cil_tmp141 ;
  char *__cil_tmp142 ;
  char *__cil_tmp143 ;
  char *__cil_tmp144 ;
  char *__cil_tmp145 ;
  char *__cil_tmp146 ;
  char *__cil_tmp147 ;
  char *__cil_tmp148 ;
  char *__cil_tmp149 ;
  char *__cil_tmp150 ;
  char *__cil_tmp151 ;
  char *__cil_tmp152 ;
  char *__cil_tmp153 ;
  char *__cil_tmp154 ;
  char *__cil_tmp155 ;
  char *__cil_tmp156 ;
  char *__cil_tmp157 ;
  char *__cil_tmp158 ;
  char *__cil_tmp159 ;
  char *__cil_tmp160 ;
  char *__cil_tmp161 ;
  char *__cil_tmp162 ;
  char *__cil_tmp163 ;
  char *__cil_tmp164 ;
  char *__cil_tmp165 ;
  char *__cil_tmp166 ;
  char *__cil_tmp167 ;
  char *__cil_tmp168 ;
  char *__cil_tmp169 ;
  char *__cil_tmp170 ;
  char *__cil_tmp171 ;
  char *__cil_tmp172 ;
  char *__cil_tmp173 ;
  char *__cil_tmp174 ;
  char *__cil_tmp175 ;
  char *__cil_tmp176 ;
  char *__cil_tmp177 ;
  char *__cil_tmp178 ;
  char *__cil_tmp179 ;
  char *__cil_tmp180 ;
  char *__cil_tmp181 ;
  char *__cil_tmp182 ;
  char *__cil_tmp183 ;
  char *__cil_tmp184 ;
  char *__cil_tmp185 ;
  char *__cil_tmp186 ;
  char *__cil_tmp187 ;
  char *__cil_tmp188 ;
  char *__cil_tmp189 ;
  char *__cil_tmp190 ;
  char *__cil_tmp191 ;
  char *__cil_tmp192 ;
  char *__cil_tmp193 ;
  char *__cil_tmp194 ;
  char *__cil_tmp195 ;
  char *__cil_tmp196 ;
  char *__cil_tmp197 ;
  char *__cil_tmp198 ;
  char *__cil_tmp199 ;
  char *__cil_tmp200 ;
  char *__cil_tmp201 ;
  char *__cil_tmp202 ;
  char *__cil_tmp203 ;
  char *__cil_tmp204 ;
  char *__cil_tmp205 ;
  char *__cil_tmp206 ;
  char *__cil_tmp207 ;
  char *__cil_tmp208 ;
  char *__cil_tmp209 ;
  char *__cil_tmp210 ;
  char *__cil_tmp211 ;
  char *__cil_tmp212 ;
  char *__cil_tmp213 ;
  char *__cil_tmp214 ;
  char *__cil_tmp215 ;
  char *__cil_tmp216 ;
  char *__cil_tmp217 ;
  char *__cil_tmp218 ;
  char *__cil_tmp219 ;
  char *__cil_tmp220 ;
  char *__cil_tmp221 ;
  char *__cil_tmp222 ;
  char *__cil_tmp223 ;
  char *__cil_tmp224 ;
  char *__cil_tmp225 ;
  char *__cil_tmp226 ;
  char *__cil_tmp227 ;
  char *__cil_tmp228 ;
  char *__cil_tmp229 ;
  char *__cil_tmp230 ;
  char *__cil_tmp231 ;
  char *__cil_tmp232 ;
  char *__cil_tmp233 ;
  char *__cil_tmp234 ;
  char *__cil_tmp235 ;
  char *__cil_tmp236 ;
  char *__cil_tmp237 ;

  {
  {
#line 142
  failed = 0;
#line 145
  tmp = calloc((size_t )1, (size_t )sizeof(bus_t ));
#line 145
  bus___0 = (bus_t *)tmp;
  }
#line 146
  if (! bus___0) {
#line 147
    return ((bus_t *)((void *)0));
  }
  {
#line 149
  bus___0->driver = driver;
#line 150
  bus___0->params = calloc((size_t )1, (size_t )sizeof(bus_params_t___15 ));
  }
#line 151
  if (! bus___0->params) {
    {
#line 152
    free((void *)bus___0);
    }
#line 153
    return ((bus_t *)((void *)0));
  }
  {
#line 156
  bus___0->chain = chain;
#line 157
  part = *((chain->parts)->parts + chain->active_part);
#line 157
  bus___0->part = part;
#line 162
  comp = & ((bus_params_t___15 *)bus___0->params)->rama;
#line 163
  comp->ctype = (ctype_t )0;
#line 164
  comp->cname = (char *)"RAMA";
#line 166
  tmp___0 = generic_bus_attach_sig(part, & comp->a[0], (char *)"IO64");
#line 166
  failed |= tmp___0;
#line 167
  tmp___1 = generic_bus_attach_sig(part, & comp->a[1], (char *)"IO66");
#line 167
  failed |= tmp___1;
#line 168
  tmp___2 = generic_bus_attach_sig(part, & comp->a[2], (char *)"IO68");
#line 168
  failed |= tmp___2;
#line 169
  tmp___3 = generic_bus_attach_sig(part, & comp->a[3], (char *)"IO74");
#line 169
  failed |= tmp___3;
#line 170
  tmp___4 = generic_bus_attach_sig(part, & comp->a[4], (char *)"IO76");
#line 170
  failed |= tmp___4;
#line 171
  tmp___5 = generic_bus_attach_sig(part, & comp->a[5], (char *)"IO107");
#line 171
  failed |= tmp___5;
#line 172
  tmp___6 = generic_bus_attach_sig(part, & comp->a[6], (char *)"IO113");
#line 172
  failed |= tmp___6;
#line 173
  tmp___7 = generic_bus_attach_sig(part, & comp->a[7], (char *)"IO115");
#line 173
  failed |= tmp___7;
#line 174
  tmp___8 = generic_bus_attach_sig(part, & comp->a[8], (char *)"IO117");
#line 174
  failed |= tmp___8;
#line 175
  tmp___9 = generic_bus_attach_sig(part, & comp->a[9], (char *)"IO119");
#line 175
  failed |= tmp___9;
#line 176
  tmp___10 = generic_bus_attach_sig(part, & comp->a[10], (char *)"IO118");
#line 176
  failed |= tmp___10;
#line 177
  tmp___11 = generic_bus_attach_sig(part, & comp->a[11], (char *)"IO116");
#line 177
  failed |= tmp___11;
#line 178
  tmp___12 = generic_bus_attach_sig(part, & comp->a[12], (char *)"IO114");
#line 178
  failed |= tmp___12;
#line 179
  tmp___13 = generic_bus_attach_sig(part, & comp->a[13], (char *)"IO108");
#line 179
  failed |= tmp___13;
#line 180
  tmp___14 = generic_bus_attach_sig(part, & comp->a[14], (char *)"IO106");
#line 180
  failed |= tmp___14;
#line 181
  tmp___15 = generic_bus_attach_sig(part, & comp->a[15], (char *)"IO67");
#line 181
  failed |= tmp___15;
#line 182
  tmp___16 = generic_bus_attach_sig(part, & comp->a[16], (char *)"IO65");
#line 182
  failed |= tmp___16;
#line 183
  tmp___17 = generic_bus_attach_sig(part, & comp->a[17], (char *)"IO63");
#line 183
  failed |= tmp___17;
#line 184
  comp->a[18] = (signal_t *)((void *)0);
#line 186
  tmp___18 = generic_bus_attach_sig(part, & comp->d[0], (char *)"IO82");
#line 186
  failed |= tmp___18;
#line 187
  tmp___19 = generic_bus_attach_sig(part, & comp->d[1], (char *)"IO84");
#line 187
  failed |= tmp___19;
#line 188
  tmp___20 = generic_bus_attach_sig(part, & comp->d[2], (char *)"IO86");
#line 188
  failed |= tmp___20;
#line 189
  tmp___21 = generic_bus_attach_sig(part, & comp->d[3], (char *)"IO88");
#line 189
  failed |= tmp___21;
#line 190
  tmp___22 = generic_bus_attach_sig(part, & comp->d[4], (char *)"IO94");
#line 190
  failed |= tmp___22;
#line 191
  tmp___23 = generic_bus_attach_sig(part, & comp->d[5], (char *)"IO98");
#line 191
  failed |= tmp___23;
#line 192
  tmp___24 = generic_bus_attach_sig(part, & comp->d[6], (char *)"IO100");
#line 192
  failed |= tmp___24;
#line 193
  tmp___25 = generic_bus_attach_sig(part, & comp->d[7], (char *)"IO104");
#line 193
  failed |= tmp___25;
#line 194
  tmp___26 = generic_bus_attach_sig(part, & comp->d[8], (char *)"IO101");
#line 194
  failed |= tmp___26;
#line 195
  tmp___27 = generic_bus_attach_sig(part, & comp->d[9], (char *)"IO99");
#line 195
  failed |= tmp___27;
#line 196
  tmp___28 = generic_bus_attach_sig(part, & comp->d[10], (char *)"IO95");
#line 196
  failed |= tmp___28;
#line 197
  tmp___29 = generic_bus_attach_sig(part, & comp->d[11], (char *)"IO93");
#line 197
  failed |= tmp___29;
#line 198
  tmp___30 = generic_bus_attach_sig(part, & comp->d[12], (char *)"IO87");
#line 198
  failed |= tmp___30;
#line 199
  tmp___31 = generic_bus_attach_sig(part, & comp->d[13], (char *)"IO85");
#line 199
  failed |= tmp___31;
#line 200
  tmp___32 = generic_bus_attach_sig(part, & comp->d[14], (char *)"IO83");
#line 200
  failed |= tmp___32;
#line 201
  tmp___33 = generic_bus_attach_sig(part, & comp->d[15], (char *)"IO79");
#line 201
  failed |= tmp___33;
#line 203
  tmp___34 = generic_bus_attach_sig(part, & comp->ncs, (char *)"IO78");
#line 203
  failed |= tmp___34;
#line 204
  tmp___35 = generic_bus_attach_sig(part, & comp->noe, (char *)"IO73");
#line 204
  failed |= tmp___35;
#line 205
  tmp___36 = generic_bus_attach_sig(part, & comp->nwe, (char *)"IO105");
#line 205
  failed |= tmp___36;
#line 206
  tmp___37 = generic_bus_attach_sig(part, & comp->nlb, (char *)"IO77");
#line 206
  failed |= tmp___37;
#line 207
  tmp___38 = generic_bus_attach_sig(part, & comp->nub, (char *)"IO75");
#line 207
  failed |= tmp___38;
#line 208
  comp->ncs2 = (signal_t *)((void *)0);
#line 209
  comp->nrdy = (signal_t *)((void *)0);
#line 214
  comp = & ((bus_params_t___15 *)bus___0->params)->ramb;
#line 215
  comp->ctype = (ctype_t )0;
#line 216
  comp->cname = (char *)"RAMB";
#line 218
  tmp___39 = generic_bus_attach_sig(part, & comp->a[0], (char *)"IO237");
#line 218
  failed |= tmp___39;
#line 219
  tmp___40 = generic_bus_attach_sig(part, & comp->a[1], (char *)"IO235");
#line 219
  failed |= tmp___40;
#line 220
  tmp___41 = generic_bus_attach_sig(part, & comp->a[2], (char *)"IO233");
#line 220
  failed |= tmp___41;
#line 221
  tmp___42 = generic_bus_attach_sig(part, & comp->a[3], (char *)"IO227");
#line 221
  failed |= tmp___42;
#line 222
  tmp___43 = generic_bus_attach_sig(part, & comp->a[4], (char *)"IO225");
#line 222
  failed |= tmp___43;
#line 223
  tmp___44 = generic_bus_attach_sig(part, & comp->a[5], (char *)"IO194");
#line 223
  failed |= tmp___44;
#line 224
  tmp___45 = generic_bus_attach_sig(part, & comp->a[6], (char *)"IO188");
#line 224
  failed |= tmp___45;
#line 225
  tmp___46 = generic_bus_attach_sig(part, & comp->a[7], (char *)"IO186");
#line 225
  failed |= tmp___46;
#line 226
  tmp___47 = generic_bus_attach_sig(part, & comp->a[8], (char *)"IO184");
#line 226
  failed |= tmp___47;
#line 227
  tmp___48 = generic_bus_attach_sig(part, & comp->a[9], (char *)"IO182");
#line 227
  failed |= tmp___48;
#line 228
  tmp___49 = generic_bus_attach_sig(part, & comp->a[10], (char *)"IO183");
#line 228
  failed |= tmp___49;
#line 229
  tmp___50 = generic_bus_attach_sig(part, & comp->a[11], (char *)"IO185");
#line 229
  failed |= tmp___50;
#line 230
  tmp___51 = generic_bus_attach_sig(part, & comp->a[12], (char *)"IO187");
#line 230
  failed |= tmp___51;
#line 231
  tmp___52 = generic_bus_attach_sig(part, & comp->a[13], (char *)"IO193");
#line 231
  failed |= tmp___52;
#line 232
  tmp___53 = generic_bus_attach_sig(part, & comp->a[14], (char *)"IO195");
#line 232
  failed |= tmp___53;
#line 233
  tmp___54 = generic_bus_attach_sig(part, & comp->a[15], (char *)"IO234");
#line 233
  failed |= tmp___54;
#line 234
  tmp___55 = generic_bus_attach_sig(part, & comp->a[16], (char *)"IO236");
#line 234
  failed |= tmp___55;
#line 235
  tmp___56 = generic_bus_attach_sig(part, & comp->a[17], (char *)"IO238");
#line 235
  failed |= tmp___56;
#line 236
  comp->a[18] = (signal_t *)((void *)0);
#line 238
  tmp___57 = generic_bus_attach_sig(part, & comp->d[0], (char *)"IO219");
#line 238
  failed |= tmp___57;
#line 239
  tmp___58 = generic_bus_attach_sig(part, & comp->d[1], (char *)"IO217");
#line 239
  failed |= tmp___58;
#line 240
  tmp___59 = generic_bus_attach_sig(part, & comp->d[2], (char *)"IO215");
#line 240
  failed |= tmp___59;
#line 241
  tmp___60 = generic_bus_attach_sig(part, & comp->d[3], (char *)"IO213");
#line 241
  failed |= tmp___60;
#line 242
  tmp___61 = generic_bus_attach_sig(part, & comp->d[4], (char *)"IO207");
#line 242
  failed |= tmp___61;
#line 243
  tmp___62 = generic_bus_attach_sig(part, & comp->d[5], (char *)"IO203");
#line 243
  failed |= tmp___62;
#line 244
  tmp___63 = generic_bus_attach_sig(part, & comp->d[6], (char *)"IO201");
#line 244
  failed |= tmp___63;
#line 245
  tmp___64 = generic_bus_attach_sig(part, & comp->d[7], (char *)"IO197");
#line 245
  failed |= tmp___64;
#line 246
  tmp___65 = generic_bus_attach_sig(part, & comp->d[8], (char *)"IO200");
#line 246
  failed |= tmp___65;
#line 247
  tmp___66 = generic_bus_attach_sig(part, & comp->d[9], (char *)"IO202");
#line 247
  failed |= tmp___66;
#line 248
  tmp___67 = generic_bus_attach_sig(part, & comp->d[10], (char *)"IO206");
#line 248
  failed |= tmp___67;
#line 249
  tmp___68 = generic_bus_attach_sig(part, & comp->d[11], (char *)"IO208");
#line 249
  failed |= tmp___68;
#line 250
  tmp___69 = generic_bus_attach_sig(part, & comp->d[12], (char *)"IO214");
#line 250
  failed |= tmp___69;
#line 251
  tmp___70 = generic_bus_attach_sig(part, & comp->d[13], (char *)"IO216");
#line 251
  failed |= tmp___70;
#line 252
  tmp___71 = generic_bus_attach_sig(part, & comp->d[14], (char *)"IO218");
#line 252
  failed |= tmp___71;
#line 253
  tmp___72 = generic_bus_attach_sig(part, & comp->d[15], (char *)"IO222");
#line 253
  failed |= tmp___72;
#line 255
  tmp___73 = generic_bus_attach_sig(part, & comp->ncs, (char *)"IO223");
#line 255
  failed |= tmp___73;
#line 256
  tmp___74 = generic_bus_attach_sig(part, & comp->noe, (char *)"IO228");
#line 256
  failed |= tmp___74;
#line 257
  tmp___75 = generic_bus_attach_sig(part, & comp->nwe, (char *)"IO196");
#line 257
  failed |= tmp___75;
#line 258
  tmp___76 = generic_bus_attach_sig(part, & comp->nlb, (char *)"IO224");
#line 258
  failed |= tmp___76;
#line 259
  tmp___77 = generic_bus_attach_sig(part, & comp->nub, (char *)"IO226");
#line 259
  failed |= tmp___77;
#line 260
  comp->ncs2 = (signal_t *)((void *)0);
#line 261
  comp->nrdy = (signal_t *)((void *)0);
#line 266
  comp = & ((bus_params_t___15 *)bus___0->params)->flash;
#line 267
  comp->ctype = (ctype_t )1;
#line 268
  comp->cname = (char *)"FLASH";
#line 270
  tmp___78 = generic_bus_attach_sig(part, & comp->a[0], (char *)"IO47");
#line 270
  failed |= tmp___78;
#line 271
  tmp___79 = generic_bus_attach_sig(part, & comp->a[1], (char *)"IO48");
#line 271
  failed |= tmp___79;
#line 272
  tmp___80 = generic_bus_attach_sig(part, & comp->a[2], (char *)"IO49");
#line 272
  failed |= tmp___80;
#line 273
  tmp___81 = generic_bus_attach_sig(part, & comp->a[3], (char *)"IO50");
#line 273
  failed |= tmp___81;
#line 274
  tmp___82 = generic_bus_attach_sig(part, & comp->a[4], (char *)"IO125");
#line 274
  failed |= tmp___82;
#line 275
  tmp___83 = generic_bus_attach_sig(part, & comp->a[5], (char *)"IO127");
#line 275
  failed |= tmp___83;
#line 276
  tmp___84 = generic_bus_attach_sig(part, & comp->a[6], (char *)"IO131");
#line 276
  failed |= tmp___84;
#line 277
  tmp___85 = generic_bus_attach_sig(part, & comp->a[7], (char *)"IO133");
#line 277
  failed |= tmp___85;
#line 278
  tmp___86 = generic_bus_attach_sig(part, & comp->a[8], (char *)"IO158");
#line 278
  failed |= tmp___86;
#line 279
  tmp___87 = generic_bus_attach_sig(part, & comp->a[9], (char *)"IO16");
#line 279
  failed |= tmp___87;
#line 280
  tmp___88 = generic_bus_attach_sig(part, & comp->a[10], (char *)"IO20");
#line 280
  failed |= tmp___88;
#line 281
  tmp___89 = generic_bus_attach_sig(part, & comp->a[11], (char *)"IO14");
#line 281
  failed |= tmp___89;
#line 282
  tmp___90 = generic_bus_attach_sig(part, & comp->a[12], (char *)"IO135");
#line 282
  failed |= tmp___90;
#line 283
  tmp___91 = generic_bus_attach_sig(part, & comp->a[13], (char *)"IO156");
#line 283
  failed |= tmp___91;
#line 284
  tmp___92 = generic_bus_attach_sig(part, & comp->a[14], (char *)"IO144");
#line 284
  failed |= tmp___92;
#line 285
  tmp___93 = generic_bus_attach_sig(part, & comp->a[15], (char *)"IO137");
#line 285
  failed |= tmp___93;
#line 286
  tmp___94 = generic_bus_attach_sig(part, & comp->a[16], (char *)"IO139");
#line 286
  failed |= tmp___94;
#line 287
  tmp___95 = generic_bus_attach_sig(part, & comp->a[17], (char *)"IO143");
#line 287
  failed |= tmp___95;
#line 288
  tmp___96 = generic_bus_attach_sig(part, & comp->a[18], (char *)"IO141");
#line 288
  failed |= tmp___96;
#line 290
  tmp___97 = generic_bus_attach_sig(part, & comp->d[0], (char *)"IO46");
#line 290
  failed |= tmp___97;
#line 291
  tmp___98 = generic_bus_attach_sig(part, & comp->d[1], (char *)"IO45");
#line 291
  failed |= tmp___98;
#line 292
  tmp___99 = generic_bus_attach_sig(part, & comp->d[2], (char *)"IO44");
#line 292
  failed |= tmp___99;
#line 293
  tmp___100 = generic_bus_attach_sig(part, & comp->d[3], (char *)"IO165");
#line 293
  failed |= tmp___100;
#line 294
  tmp___101 = generic_bus_attach_sig(part, & comp->d[4], (char *)"IO164");
#line 294
  failed |= tmp___101;
#line 295
  tmp___102 = generic_bus_attach_sig(part, & comp->d[5], (char *)"IO17");
#line 295
  failed |= tmp___102;
#line 296
  tmp___103 = generic_bus_attach_sig(part, & comp->d[6], (char *)"IO18");
#line 296
  failed |= tmp___103;
#line 297
  tmp___104 = generic_bus_attach_sig(part, & comp->d[7], (char *)"IO19");
#line 297
  failed |= tmp___104;
#line 298
  comp->d[8] = (signal_t *)((void *)0);
#line 299
  comp->d[9] = (signal_t *)((void *)0);
#line 300
  comp->d[10] = (signal_t *)((void *)0);
#line 301
  comp->d[11] = (signal_t *)((void *)0);
#line 302
  comp->d[12] = (signal_t *)((void *)0);
#line 303
  comp->d[13] = (signal_t *)((void *)0);
#line 304
  comp->d[14] = (signal_t *)((void *)0);
#line 305
  comp->d[15] = (signal_t *)((void *)0);
#line 307
  tmp___105 = generic_bus_attach_sig(part, & comp->nwe, (char *)"IO15");
#line 307
  failed |= tmp___105;
#line 308
  tmp___106 = generic_bus_attach_sig(part, & comp->noe, (char *)"IO24");
#line 308
  failed |= tmp___106;
#line 309
  tmp___107 = generic_bus_attach_sig(part, & comp->ncs, (char *)"IO37");
#line 309
  failed |= tmp___107;
#line 310
  tmp___108 = generic_bus_attach_sig(part, & comp->ncs2, (char *)"IO23");
#line 310
  failed |= tmp___108;
#line 315
  comp->nrdy = (signal_t *)((void *)0);
#line 317
  comp->nlb = (signal_t *)((void *)0);
#line 318
  comp->nub = (signal_t *)((void *)0);
#line 323
  tmp___109 = generic_bus_attach_sig(part, & ((bus_params_t___15 *)bus___0->params)->ser_rxd,
                                     (char *)"CLK2");
#line 323
  failed |= tmp___109;
#line 324
  tmp___110 = generic_bus_attach_sig(part, & ((bus_params_t___15 *)bus___0->params)->ser_nrts,
                                     (char *)"IO177");
#line 324
  failed |= tmp___110;
#line 325
  tmp___111 = generic_bus_attach_sig(part, & ((bus_params_t___15 *)bus___0->params)->ser_txd,
                                     (char *)"IO178");
#line 325
  failed |= tmp___111;
#line 326
  tmp___112 = generic_bus_attach_sig(part, & ((bus_params_t___15 *)bus___0->params)->ser_ncts,
                                     (char *)"CLK0");
#line 326
  failed |= tmp___112;
  }
#line 328
  if (failed) {
    {
#line 329
    free(bus___0->params);
#line 330
    free((void *)bus___0);
    }
#line 331
    return ((bus_t *)((void *)0));
  }
#line 334
  return (bus___0);
}
}
#line 341 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/jopcyc.c"
static void jopcyc_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;
  char *__cil_tmp4 ;

  {
#line 346
  i = 0;
  {
#line 346
  while (1) {
    while_continue: /* CIL Label */ ;
#line 346
    if (! (i < ((bus___0->chain)->parts)->len)) {
#line 346
      goto while_break;
    }
#line 347
    if ((unsigned long )bus___0->part == (unsigned long )*(((bus___0->chain)->parts)->parts + i)) {
#line 348
      goto while_break;
    }
#line 346
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 349
  tmp = gettext("JOP.design Cyclone Board compatible bus driver via BSR (JTAG part No. %d)\n");
#line 349
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 350
  return;
}
}
#line 352 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/jopcyc.c"
static void setup_address___15(bus_t *bus___0 , uint32_t a , component_t___0 *comp ) 
{ 
  int i ;
  part_t *p ;
  int addr_width ;

  {
#line 356
  p = bus___0->part;
#line 359
  ((bus_params_t___15 *)bus___0->params)->last_addr = a;
  {
#line 362
  if ((unsigned int )comp->ctype == 0U) {
#line 362
    goto case_0;
  }
#line 368
  if ((unsigned int )comp->ctype == 1U) {
#line 368
    goto case_1;
  }
#line 371
  goto switch_default;
  case_0: /* CIL Label */ 
#line 363
  addr_width = 18;
#line 366
  a >>= 1;
#line 367
  goto switch_break;
  case_1: /* CIL Label */ 
#line 369
  addr_width = 19;
#line 370
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 372
  addr_width = 0;
#line 373
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 376
  i = 0;
  {
#line 376
  while (1) {
    while_continue: /* CIL Label */ ;
#line 376
    if (! (i < addr_width)) {
#line 376
      goto while_break;
    }
    {
#line 377
    part_set_signal(p, comp->a[i], 1, (int )((a >> i) & 1U));
#line 376
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 378
  return;
}
}
#line 380 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/jopcyc.c"
static int detect_data_width___0(component_t___0 *comp ) 
{ 
  int width ;

  {
  {
#line 386
  if ((unsigned int )comp->ctype == 0U) {
#line 386
    goto case_0;
  }
#line 389
  if ((unsigned int )comp->ctype == 1U) {
#line 389
    goto case_1;
  }
#line 392
  goto switch_default;
  case_0: /* CIL Label */ 
#line 387
  width = 16;
#line 388
  goto switch_break;
  case_1: /* CIL Label */ 
#line 390
  width = 8;
#line 391
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 393
  width = 0;
#line 394
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 397
  return (width);
}
}
#line 400 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/jopcyc.c"
static void set_data_in___15(bus_t *bus___0 , component_t___0 *comp ) 
{ 
  int i ;
  part_t *p ;
  int width ;

  {
  {
#line 404
  p = bus___0->part;
#line 407
  width = detect_data_width___0(comp);
#line 409
  i = 0;
  }
  {
#line 409
  while (1) {
    while_continue: /* CIL Label */ ;
#line 409
    if (! (i < width)) {
#line 409
      goto while_break;
    }
    {
#line 410
    part_set_signal(p, comp->d[i], 0, 0);
#line 409
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 411
  return;
}
}
#line 413 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/jopcyc.c"
static void setup_data___15(bus_t *bus___0 , uint32_t d , component_t___0 *comp ) 
{ 
  int i ;
  part_t *p ;
  int width ;

  {
  {
#line 417
  p = bus___0->part;
#line 420
  width = detect_data_width___0(comp);
#line 422
  i = 0;
  }
  {
#line 422
  while (1) {
    while_continue: /* CIL Label */ ;
#line 422
    if (! (i < width)) {
#line 422
      goto while_break;
    }
    {
#line 423
    part_set_signal(p, comp->d[i], 1, (int )((d >> i) & 1U));
#line 422
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 424
  return;
}
}
#line 430 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/jopcyc.c"
static int jopcyc_bus_init(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain ;
  component_t___0 *comp ;
  int tmp ;
  char *__cil_tmp6 ;

  {
  {
#line 433
  p = bus___0->part;
#line 434
  chain = bus___0->chain;
#line 437
  tmp = tap_state(chain);
  }
#line 437
  if (tmp != 1 << 3) {
#line 442
    return (0);
  }
  {
#line 448
  part_set_instruction(p, "SAMPLE/PRELOAD");
#line 449
  chain_shift_instructions(chain);
#line 452
  comp = & ((bus_params_t___15 *)bus___0->params)->rama;
#line 453
  set_data_in___15(bus___0, comp);
#line 454
  part_set_signal(p, comp->ncs, 1, 1);
#line 455
  part_set_signal(p, comp->nwe, 1, 1);
#line 456
  part_set_signal(p, comp->noe, 1, 1);
#line 457
  part_set_signal(p, comp->nlb, 1, 1);
#line 458
  part_set_signal(p, comp->nub, 1, 1);
#line 461
  comp = & ((bus_params_t___15 *)bus___0->params)->ramb;
#line 462
  set_data_in___15(bus___0, comp);
#line 463
  part_set_signal(p, comp->ncs, 1, 1);
#line 464
  part_set_signal(p, comp->nwe, 1, 1);
#line 465
  part_set_signal(p, comp->noe, 1, 1);
#line 466
  part_set_signal(p, comp->nlb, 1, 1);
#line 467
  part_set_signal(p, comp->nub, 1, 1);
#line 470
  comp = & ((bus_params_t___15 *)bus___0->params)->flash;
#line 471
  set_data_in___15(bus___0, comp);
#line 472
  part_set_signal(p, comp->ncs, 1, 1);
#line 473
  part_set_signal(p, comp->nwe, 1, 1);
#line 474
  part_set_signal(p, comp->noe, 1, 1);
#line 475
  part_set_signal(p, comp->ncs2, 1, 1);
#line 476
  part_set_signal(p, comp->nrdy, 0, 0);
#line 479
  part_set_signal(p, ((bus_params_t___15 *)bus___0->params)->ser_rxd, 0, 0);
#line 480
  part_set_signal(p, ((bus_params_t___15 *)bus___0->params)->ser_nrts, 1, 1);
#line 481
  part_set_signal(p, ((bus_params_t___15 *)bus___0->params)->ser_txd, 1, 1);
#line 482
  part_set_signal(p, ((bus_params_t___15 *)bus___0->params)->ser_ncts, 0, 0);
#line 484
  chain_shift_data_registers(chain, 0);
#line 486
  bus___0->initialized = 1;
  }
#line 488
  return (0);
}
}
#line 491 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/jopcyc.c"
static int comp_bus_area___0(bus_t *bus___0 , uint32_t adr , bus_area_t *area___0 ,
                             component_t___0 **comp ) 
{ 
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 494
  if (adr < (uint32_t )(1 << 19)) {
#line 495
    area___0->description = "RAMA Component";
#line 496
    area___0->start = (uint32_t )0;
#line 497
    area___0->length = (uint64_t )(1 << 19);
#line 498
    area___0->width = 16U;
#line 499
    *comp = & ((bus_params_t___15 *)bus___0->params)->rama;
  } else
#line 500
  if (adr < (uint32_t )(2 * (1 << 19))) {
#line 501
    area___0->description = "RAMB Component";
#line 502
    area___0->start = (uint32_t )(1 << 19);
#line 503
    area___0->length = (uint64_t )(1 << 19);
#line 504
    area___0->width = 16U;
#line 505
    *comp = & ((bus_params_t___15 *)bus___0->params)->ramb;
  } else
#line 506
  if (adr < (uint32_t )(2 * (1 << 19) + (1 << 19))) {
#line 507
    area___0->description = "FLASH Component";
#line 508
    area___0->start = (uint32_t )(2 * (1 << 19));
#line 509
    area___0->length = (uint64_t )(1 << 19);
#line 510
    area___0->width = 8U;
#line 511
    *comp = & ((bus_params_t___15 *)bus___0->params)->flash;
  } else {
#line 513
    area___0->description = "Dummy";
#line 514
    area___0->start = (uint32_t )(2 * (1 << 19) + (1 << 19));
#line 515
    area___0->length = 4294967296ULL;
#line 516
    area___0->width = 0U;
#line 517
    *comp = (component_t___0 *)((void *)0);
  }
#line 520
  return (0);
}
}
#line 527 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/jopcyc.c"
static int jopcyc_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area___0 ) 
{ 
  component_t___0 *comp ;
  int tmp ;

  {
  {
#line 532
  tmp = comp_bus_area___0(bus___0, adr, area___0, & comp);
  }
#line 532
  return (tmp);
}
}
#line 539 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/jopcyc.c"
static void jopcyc_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;
  bus_area_t area___0 ;
  component_t___0 *comp ;
  char *tmp ;
  char *__cil_tmp8 ;

  {
  {
#line 542
  p = bus___0->part;
#line 543
  chain = bus___0->chain;
#line 547
  comp_bus_area___0(bus___0, adr, & area___0, & comp);
  }
#line 548
  if (! comp) {
    {
#line 549
    tmp = gettext("Address out of range\n");
#line 549
    printf((char const   */* __restrict  */)tmp);
#line 550
    ((bus_params_t___15 *)bus___0->params)->last_addr = adr;
    }
#line 551
    return;
  }
  {
#line 554
  part_set_signal(p, comp->ncs, 1, 0);
#line 555
  part_set_signal(p, comp->nwe, 1, 1);
#line 556
  part_set_signal(p, comp->noe, 1, 0);
  }
#line 557
  if ((unsigned int )comp->ctype == 0U) {
    {
#line 558
    part_set_signal(p, comp->nlb, 1, 0);
#line 559
    part_set_signal(p, comp->nub, 1, 0);
    }
  }
  {
#line 562
  setup_address___15(bus___0, adr, comp);
#line 563
  set_data_in___15(bus___0, comp);
#line 565
  chain_shift_data_registers(chain, 0);
  }
#line 566
  return;
}
}
#line 572 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/jopcyc.c"
static uint32_t jopcyc_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  bus_area_t area___0 ;
  component_t___0 *comp ;
  char *tmp ;
  int tmp___0 ;
  char *__cil_tmp11 ;

  {
  {
#line 575
  p = bus___0->part;
#line 576
  chain = bus___0->chain;
#line 578
  d = (uint32_t )0;
#line 582
  comp_bus_area___0(bus___0, adr, & area___0, & comp);
  }
#line 583
  if (! comp) {
    {
#line 584
    tmp = gettext("Address out of range\n");
#line 584
    printf((char const   */* __restrict  */)tmp);
#line 585
    ((bus_params_t___15 *)bus___0->params)->last_addr = adr;
    }
#line 586
    return ((uint32_t )0);
  }
  {
#line 589
  setup_address___15(bus___0, adr, comp);
#line 590
  chain_shift_data_registers(chain, 1);
#line 592
  i = 0;
  }
  {
#line 592
  while (1) {
    while_continue: /* CIL Label */ ;
#line 592
    if (! ((unsigned int )i < area___0.width)) {
#line 592
      goto while_break;
    }
    {
#line 593
    tmp___0 = part_get_signal(p, comp->d[i]);
#line 593
    d |= (uint32_t )(tmp___0 << i);
#line 592
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 595
  return (d);
}
}
#line 602 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/jopcyc.c"
static uint32_t jopcyc_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  bus_area_t area___0 ;
  component_t___0 *comp ;
  char *tmp ;
  int tmp___0 ;
  char *__cil_tmp10 ;

  {
  {
#line 605
  p = bus___0->part;
#line 606
  chain = bus___0->chain;
#line 608
  d = (uint32_t )0;
#line 613
  comp_bus_area___0(bus___0, ((bus_params_t___15 *)bus___0->params)->last_addr, & area___0,
                    & comp);
  }
#line 614
  if (! comp) {
    {
#line 615
    tmp = gettext("Address out of range\n");
#line 615
    printf((char const   */* __restrict  */)tmp);
    }
#line 616
    return ((uint32_t )0);
  }
  {
#line 619
  part_set_signal(p, comp->ncs, 1, 1);
#line 620
  part_set_signal(p, comp->noe, 1, 1);
  }
#line 621
  if ((unsigned int )comp->ctype == 0U) {
    {
#line 622
    part_set_signal(p, comp->nlb, 1, 1);
#line 623
    part_set_signal(p, comp->nub, 1, 1);
    }
  }
  {
#line 625
  chain_shift_data_registers(chain, 1);
#line 627
  i = 0;
  }
  {
#line 627
  while (1) {
    while_continue: /* CIL Label */ ;
#line 627
    if (! ((unsigned int )i < area___0.width)) {
#line 627
      goto while_break;
    }
    {
#line 628
    tmp___0 = part_get_signal(p, comp->d[i]);
#line 628
    d |= (uint32_t )(tmp___0 << i);
#line 627
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 630
  return (d);
}
}
#line 637 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/jopcyc.c"
static void jopcyc_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain ;
  bus_area_t area___0 ;
  component_t___0 *comp ;
  char *tmp ;
  char *__cil_tmp9 ;

  {
  {
#line 640
  p = bus___0->part;
#line 641
  chain = bus___0->chain;
#line 645
  comp_bus_area___0(bus___0, adr, & area___0, & comp);
  }
#line 646
  if (! comp) {
    {
#line 647
    tmp = gettext("Address out of range\n");
#line 647
    printf((char const   */* __restrict  */)tmp);
    }
#line 648
    return;
  }
  {
#line 651
  part_set_signal(p, comp->ncs, 1, 0);
#line 652
  part_set_signal(p, comp->nwe, 1, 1);
#line 653
  part_set_signal(p, comp->noe, 1, 1);
  }
#line 654
  if ((unsigned int )comp->ctype == 0U) {
    {
#line 655
    part_set_signal(p, comp->nlb, 1, 0);
#line 656
    part_set_signal(p, comp->nub, 1, 0);
    }
  }
  {
#line 659
  setup_address___15(bus___0, adr, comp);
#line 660
  setup_data___15(bus___0, data, comp);
#line 662
  chain_shift_data_registers(chain, 0);
#line 664
  part_set_signal(p, comp->nwe, 1, 0);
#line 665
  chain_shift_data_registers(chain, 0);
#line 666
  part_set_signal(p, comp->nwe, 1, 1);
#line 667
  part_set_signal(p, comp->ncs, 1, 1);
  }
#line 668
  if ((unsigned int )comp->ctype == 0U) {
    {
#line 669
    part_set_signal(p, comp->nlb, 1, 1);
#line 670
    part_set_signal(p, comp->nub, 1, 1);
    }
  }
  {
#line 672
  chain_shift_data_registers(chain, 0);
  }
#line 673
  return;
}
}
#line 675 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/jopcyc.c"
struct bus_driver  const  jopcyc_bus  = 
#line 675
     {"jopcyc", "JOP.design Cyclone Board compatible bus driver via BSR", & jopcyc_bus_new,
    & generic_bus_free, & jopcyc_bus_printinfo, & generic_bus_prepare_extest, & jopcyc_bus_area,
    & jopcyc_bus_read_start, & jopcyc_bus_read_next, & jopcyc_bus_read_end, & generic_bus_read,
    & jopcyc_bus_write, & jopcyc_bus_init};
#line 44 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/buses.h"
struct bus_driver  const  ixp425_bus ;
#line 58 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ixp425.c"
static bus_t *ixp425_bus_new(chain_t *chain , bus_driver_t const   *driver , char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  part_t *part ;
  char buff[15] ;
  int i ;
  int failed ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
  {
#line 65
  failed = 0;
#line 67
  tmp = calloc((size_t )1, (size_t )sizeof(bus_t ));
#line 67
  bus___0 = (bus_t *)tmp;
  }
#line 68
  if (! bus___0) {
#line 69
    return ((bus_t *)((void *)0));
  }
  {
#line 71
  bus___0->driver = driver;
#line 72
  bus___0->params = calloc((size_t )1, (size_t )sizeof(bus_params_t___16 ));
  }
#line 73
  if (! bus___0->params) {
    {
#line 74
    free((void *)bus___0);
    }
#line 75
    return ((bus_t *)((void *)0));
  }
#line 78
  bus___0->chain = chain;
#line 79
  part = *((chain->parts)->parts + chain->active_part);
#line 79
  bus___0->part = part;
#line 81
  i = 0;
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    if (! (i < 8)) {
#line 81
      goto while_break;
    }
    {
#line 82
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"EX_CS[%d]",
            i);
#line 83
    tmp___0 = generic_bus_attach_sig(part, & ((bus_params_t___16 *)bus___0->params)->ex_cs[i],
                                     buff);
#line 83
    failed |= tmp___0;
#line 81
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 86
  i = 0;
  {
#line 86
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 86
    if (! (i < 24)) {
#line 86
      goto while_break___0;
    }
    {
#line 87
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"EX_ADDR[%d]",
            i);
#line 88
    tmp___1 = generic_bus_attach_sig(part, & ((bus_params_t___16 *)bus___0->params)->ex_addr[i],
                                     buff);
#line 88
    failed |= tmp___1;
#line 86
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 91
  i = 0;
  {
#line 91
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 91
    if (! (i < 16)) {
#line 91
      goto while_break___1;
    }
    {
#line 92
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"EX_DATA[%d]",
            i);
#line 93
    tmp___2 = generic_bus_attach_sig(part, & ((bus_params_t___16 *)bus___0->params)->ex_data[i],
                                     buff);
#line 93
    failed |= tmp___2;
#line 91
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 96
  tmp___3 = generic_bus_attach_sig(part, & ((bus_params_t___16 *)bus___0->params)->ex_wr,
                                   (char *)"EX_WR");
#line 96
  failed |= tmp___3;
#line 98
  tmp___4 = generic_bus_attach_sig(part, & ((bus_params_t___16 *)bus___0->params)->ex_rd,
                                   (char *)"EX_RD");
#line 98
  failed |= tmp___4;
  }
#line 100
  if (failed) {
    {
#line 101
    free(bus___0->params);
#line 102
    free((void *)bus___0);
    }
#line 103
    return ((bus_t *)((void *)0));
  }
#line 106
  return (bus___0);
}
}
#line 113 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ixp425.c"
static void ixp425_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;
  char *__cil_tmp4 ;

  {
#line 118
  i = 0;
  {
#line 118
  while (1) {
    while_continue: /* CIL Label */ ;
#line 118
    if (! (i < ((bus___0->chain)->parts)->len)) {
#line 118
      goto while_break;
    }
#line 119
    if ((unsigned long )bus___0->part == (unsigned long )*(((bus___0->chain)->parts)->parts + i)) {
#line 120
      goto while_break;
    }
#line 118
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 121
  tmp = gettext("Intel IXP425 compatible bus driver via BSR (JTAG part No. %d)\n");
#line 121
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 122
  return;
}
}
#line 128 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ixp425.c"
static int ixp425_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area___0 ) 
{ 


  {
#line 131
  area___0->description = (char const   *)((void *)0);
#line 132
  area___0->start = 0U;
#line 133
  area___0->length = 4294967296ULL;
#line 134
  area___0->width = 16U;
#line 136
  return (0);
}
}
#line 139 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ixp425.c"
static void select_flash___0(bus_t *bus___0 ) 
{ 
  part_t *p ;

  {
  {
#line 142
  p = bus___0->part;
#line 144
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_cs[0], 1, 0);
#line 145
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_cs[1], 1, 1);
#line 146
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_cs[2], 1, 1);
#line 147
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_cs[3], 1, 1);
#line 148
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_cs[4], 1, 1);
#line 149
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_cs[5], 1, 1);
#line 150
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_cs[6], 1, 1);
#line 151
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_cs[7], 1, 1);
  }
#line 152
  return;
}
}
#line 154 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ixp425.c"
static void unselect_flash___0(bus_t *bus___0 ) 
{ 
  part_t *p ;

  {
  {
#line 157
  p = bus___0->part;
#line 159
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_cs[0], 1, 1);
#line 160
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_cs[1], 1, 1);
#line 161
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_cs[2], 1, 1);
#line 162
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_cs[3], 1, 1);
#line 163
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_cs[4], 1, 1);
#line 164
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_cs[5], 1, 1);
#line 165
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_cs[6], 1, 1);
#line 166
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_cs[7], 1, 1);
  }
#line 167
  return;
}
}
#line 169 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ixp425.c"
static void setup_address___16(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 173
  p = bus___0->part;
#line 175
  i = 0;
  {
#line 175
  while (1) {
    while_continue: /* CIL Label */ ;
#line 175
    if (! (i < 24)) {
#line 175
      goto while_break;
    }
    {
#line 176
    part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_addr[i], 1, (int )((a >> i) & 1U));
#line 175
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 177
  return;
}
}
#line 179 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ixp425.c"
static void set_data_in___16(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;

  {
#line 183
  p = bus___0->part;
#line 185
  i = 0;
  {
#line 185
  while (1) {
    while_continue: /* CIL Label */ ;
#line 185
    if (! (i < 16)) {
#line 185
      goto while_break;
    }
    {
#line 186
    part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_data[i], 0, 0);
#line 185
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 187
  return;
}
}
#line 189 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ixp425.c"
static void setup_data___16(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;

  {
#line 193
  p = bus___0->part;
#line 195
  i = 0;
  {
#line 195
  while (1) {
    while_continue: /* CIL Label */ ;
#line 195
    if (! (i < 16)) {
#line 195
      goto while_break;
    }
    {
#line 196
    part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_data[i], 1, (int )((d >> i) & 1U));
#line 195
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 197
  return;
}
}
#line 203 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ixp425.c"
static void ixp425_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
  {
#line 206
  p = bus___0->part;
#line 207
  chain = bus___0->chain;
#line 209
  select_flash___0(bus___0);
#line 210
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_rd, 1, 0);
#line 211
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_wr, 1, 1);
#line 213
  setup_address___16(bus___0, adr);
#line 214
  set_data_in___16(bus___0);
#line 216
  chain_shift_data_registers(chain, 0);
  }
#line 217
  return;
}
}
#line 223 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ixp425.c"
static uint32_t ixp425_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 226
  p = bus___0->part;
#line 227
  chain = bus___0->chain;
#line 229
  d = (uint32_t )0;
#line 231
  setup_address___16(bus___0, adr);
#line 232
  chain_shift_data_registers(chain, 1);
#line 234
  i = 0;
  }
  {
#line 234
  while (1) {
    while_continue: /* CIL Label */ ;
#line 234
    if (! (i < 16)) {
#line 234
      goto while_break;
    }
    {
#line 235
    tmp = part_get_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_data[i]);
#line 235
    d |= (uint32_t )(tmp << i);
#line 234
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 237
  return (d);
}
}
#line 244 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ixp425.c"
static uint32_t ixp425_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 247
  p = bus___0->part;
#line 248
  chain = bus___0->chain;
#line 250
  d = (uint32_t )0;
#line 252
  unselect_flash___0(bus___0);
#line 253
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_rd, 1, 1);
#line 254
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_wr, 1, 1);
#line 256
  chain_shift_data_registers(chain, 1);
#line 258
  i = 0;
  }
  {
#line 258
  while (1) {
    while_continue: /* CIL Label */ ;
#line 258
    if (! (i < 16)) {
#line 258
      goto while_break;
    }
    {
#line 259
    tmp = part_get_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_data[i]);
#line 259
    d |= (uint32_t )(tmp << i);
#line 258
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 261
  return (d);
}
}
#line 268 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ixp425.c"
static void ixp425_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
  {
#line 271
  p = bus___0->part;
#line 272
  chain = bus___0->chain;
#line 274
  select_flash___0(bus___0);
#line 275
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_rd, 1, 1);
#line 277
  setup_address___16(bus___0, adr);
#line 278
  setup_data___16(bus___0, data);
#line 280
  chain_shift_data_registers(chain, 0);
#line 282
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_wr, 1, 0);
#line 283
  chain_shift_data_registers(chain, 0);
#line 284
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_wr, 1, 1);
#line 285
  unselect_flash___0(bus___0);
#line 286
  chain_shift_data_registers(chain, 0);
  }
#line 287
  return;
}
}
#line 289 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ixp425.c"
struct bus_driver  const  ixp425_bus  = 
#line 289
     {"ixp425", "Intel IXP425 compatible bus driver via BSR", & ixp425_bus_new, & generic_bus_free,
    & ixp425_bus_printinfo, & generic_bus_prepare_extest, & ixp425_bus_area, & ixp425_bus_read_start,
    & ixp425_bus_read_next, & ixp425_bus_read_end, & generic_bus_read, & ixp425_bus_write,
    & generic_bus_no_init};
#line 43 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/buses.h"
struct bus_driver  const  h7202_bus ;
#line 58 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/h7202.c"
static bus_t *h7202_bus_new(chain_t *chain , bus_driver_t const   *driver , char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  part_t *part ;
  char buff[10] ;
  int i ;
  int failed ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
  {
#line 65
  failed = 0;
#line 67
  tmp = calloc((size_t )1, (size_t )sizeof(bus_t ));
#line 67
  bus___0 = (bus_t *)tmp;
  }
#line 68
  if (! bus___0) {
#line 69
    return ((bus_t *)((void *)0));
  }
  {
#line 71
  bus___0->driver = driver;
#line 72
  bus___0->params = calloc((size_t )1, (size_t )sizeof(bus_params_t___17 ));
  }
#line 73
  if (! bus___0->params) {
    {
#line 74
    free((void *)bus___0);
    }
#line 75
    return ((bus_t *)((void *)0));
  }
#line 78
  bus___0->chain = chain;
#line 79
  part = *((chain->parts)->parts + chain->active_part);
#line 79
  bus___0->part = part;
#line 81
  i = 0;
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    if (! (i < 25)) {
#line 81
      goto while_break;
    }
    {
#line 82
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"RA%d",
            i);
#line 83
    tmp___0 = generic_bus_attach_sig(part, & ((bus_params_t___17 *)bus___0->params)->a[i],
                                     buff);
#line 83
    failed |= tmp___0;
#line 81
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 86
  i = 0;
  {
#line 86
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 86
    if (! (i < 32)) {
#line 86
      goto while_break___0;
    }
    {
#line 87
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"RD%d",
            i);
#line 88
    tmp___1 = generic_bus_attach_sig(part, & ((bus_params_t___17 *)bus___0->params)->d[i],
                                     buff);
#line 88
    failed |= tmp___1;
#line 86
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 91
  i = 0;
  {
#line 91
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 91
    if (! (i < 4)) {
#line 91
      goto while_break___1;
    }
    {
#line 92
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"nRCS%d",
            i);
#line 93
    tmp___2 = generic_bus_attach_sig(part, & ((bus_params_t___17 *)bus___0->params)->nRCS[i],
                                     buff);
#line 93
    failed |= tmp___2;
#line 91
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 96
  tmp___3 = generic_bus_attach_sig(part, & ((bus_params_t___17 *)bus___0->params)->nROE,
                                   (char *)"nROE");
#line 96
  failed |= tmp___3;
#line 98
  i = 0;
  }
  {
#line 98
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 98
    if (! (i < 4)) {
#line 98
      goto while_break___2;
    }
    {
#line 99
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"nRWE%d",
            i);
#line 100
    tmp___4 = generic_bus_attach_sig(part, & ((bus_params_t___17 *)bus___0->params)->nRWE[i],
                                     buff);
#line 100
    failed |= tmp___4;
#line 98
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 103
  if (failed) {
    {
#line 104
    free(bus___0->params);
#line 105
    free((void *)bus___0);
    }
#line 106
    return ((bus_t *)((void *)0));
  }
#line 109
  return (bus___0);
}
}
#line 116 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/h7202.c"
static void h7202_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *__cil_tmp3 ;

  {
#line 121
  i = 0;
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;
#line 121
    if (! (i < ((bus___0->chain)->parts)->len)) {
#line 121
      goto while_break;
    }
#line 122
    if ((unsigned long )bus___0->part == (unsigned long )*(((bus___0->chain)->parts)->parts + i)) {
#line 123
      goto while_break;
    }
#line 121
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 124
  printf((char const   */* __restrict  */)"H7202 compatible bus driver via BSR (JTAG part No. %d)\n",
         i);
  }
#line 125
  return;
}
}
#line 131 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/h7202.c"
static int h7202_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area___0 ) 
{ 


  {
#line 134
  area___0->description = (char const   *)((void *)0);
#line 135
  area___0->start = 0U;
#line 136
  area___0->length = 4294967296ULL;
#line 137
  area___0->width = 16U;
#line 139
  return (0);
}
}
#line 142 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/h7202.c"
static void setup_address___17(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 146
  p = bus___0->part;
#line 148
  i = 0;
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;
#line 148
    if (! (i < 26)) {
#line 148
      goto while_break;
    }
    {
#line 149
    part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->a[i], 1, (int )((a >> i) & 1U));
#line 148
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 150
  return;
}
}
#line 152 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/h7202.c"
static void set_data_in___17(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area___0 ;

  {
  {
#line 156
  p = bus___0->part;
#line 159
  h7202_bus_area(bus___0, (uint32_t )0, & area___0);
#line 161
  i = 0;
  }
  {
#line 161
  while (1) {
    while_continue: /* CIL Label */ ;
#line 161
    if (! ((unsigned int )i < area___0.width)) {
#line 161
      goto while_break;
    }
    {
#line 162
    part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->d[i], 0, 0);
#line 161
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 163
  return;
}
}
#line 165 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/h7202.c"
static void setup_data___17(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area___0 ;

  {
  {
#line 169
  p = bus___0->part;
#line 172
  h7202_bus_area(bus___0, (uint32_t )0, & area___0);
#line 174
  i = 0;
  }
  {
#line 174
  while (1) {
    while_continue: /* CIL Label */ ;
#line 174
    if (! ((unsigned int )i < area___0.width)) {
#line 174
      goto while_break;
    }
    {
#line 175
    part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->d[i], 1, (int )((d >> i) & 1U));
#line 174
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 176
  return;
}
}
#line 182 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/h7202.c"
static void h7202_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
  {
#line 186
  p = bus___0->part;
#line 187
  chain = bus___0->chain;
#line 189
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRCS[0], 1, 0);
#line 190
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRCS[1], 1, 1);
#line 191
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRCS[2], 1, 1);
#line 192
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRCS[3], 1, 1);
#line 193
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRWE[0], 1, 1);
#line 194
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nROE, 1, 0);
#line 196
  setup_address___17(bus___0, adr);
#line 197
  set_data_in___17(bus___0);
#line 199
  chain_shift_data_registers(chain, 0);
  }
#line 200
  return;
}
}
#line 206 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/h7202.c"
static uint32_t h7202_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  bus_area_t area___0 ;
  int tmp ;

  {
  {
#line 210
  p = bus___0->part;
#line 211
  chain = bus___0->chain;
#line 213
  d = (uint32_t )0;
#line 216
  h7202_bus_area(bus___0, adr, & area___0);
#line 218
  setup_address___17(bus___0, adr);
#line 219
  chain_shift_data_registers(chain, 1);
#line 221
  i = 0;
  }
  {
#line 221
  while (1) {
    while_continue: /* CIL Label */ ;
#line 221
    if (! ((unsigned int )i < area___0.width)) {
#line 221
      goto while_break;
    }
    {
#line 222
    tmp = part_get_signal(p, ((bus_params_t___17 *)bus___0->params)->d[i]);
#line 222
    d |= (uint32_t )(tmp << i);
#line 221
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 224
  return (d);
}
}
#line 231 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/h7202.c"
static uint32_t h7202_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  bus_area_t area___0 ;
  int tmp ;

  {
  {
#line 235
  p = bus___0->part;
#line 236
  chain = bus___0->chain;
#line 238
  d = (uint32_t )0;
#line 241
  h7202_bus_area(bus___0, (uint32_t )0, & area___0);
#line 243
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRCS[0], 1, 1);
#line 244
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRCS[1], 1, 1);
#line 245
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRCS[2], 1, 1);
#line 246
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRCS[3], 1, 1);
#line 247
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nROE, 1, 1);
#line 248
  chain_shift_data_registers(chain, 1);
#line 250
  i = 0;
  }
  {
#line 250
  while (1) {
    while_continue: /* CIL Label */ ;
#line 250
    if (! ((unsigned int )i < area___0.width)) {
#line 250
      goto while_break;
    }
    {
#line 251
    tmp = part_get_signal(p, ((bus_params_t___17 *)bus___0->params)->d[i]);
#line 251
    d |= (uint32_t )(tmp << i);
#line 250
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 253
  return (d);
}
}
#line 260 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/h7202.c"
static void h7202_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
  {
#line 264
  p = bus___0->part;
#line 265
  chain = bus___0->chain;
#line 271
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRCS[0], 1, 0);
#line 272
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRCS[1], 1, 1);
#line 273
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRCS[2], 1, 1);
#line 274
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRCS[3], 1, 1);
#line 276
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRWE[0], 1, 0);
#line 277
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRWE[1], 1, 1);
#line 278
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRWE[2], 1, 1);
#line 279
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRWE[3], 1, 1);
#line 280
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nROE, 1, 1);
#line 282
  setup_address___17(bus___0, adr);
#line 283
  setup_data___17(bus___0, data);
#line 285
  chain_shift_data_registers(chain, 0);
#line 287
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRWE[0], 1, 1);
#line 288
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRCS[0], 1, 1);
#line 289
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRCS[1], 1, 1);
#line 290
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRCS[2], 1, 1);
#line 291
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRCS[3], 1, 1);
#line 292
  chain_shift_data_registers(chain, 0);
  }
#line 293
  return;
}
}
#line 295 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/h7202.c"
struct bus_driver  const  h7202_bus  = 
#line 295
     {"h7202", "H7202 compatible bus driver via BSR", & h7202_bus_new, & generic_bus_free,
    & h7202_bus_printinfo, & generic_bus_prepare_extest, & h7202_bus_area, & h7202_bus_read_start,
    & h7202_bus_read_next, & h7202_bus_read_end, & generic_bus_read, & h7202_bus_write,
    & generic_bus_no_init};
#line 33 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/generic_bus.c"
int generic_bus_attach_sig(part_t *part , signal_t **sig , char *id ) 
{ 
  int failed ;
  char *tmp ;
  char *__cil_tmp6 ;

  {
  {
#line 36
  failed = 0;
#line 38
  *sig = part_find_signal(part, (char const   *)id);
  }
#line 39
  if (! *sig) {
    {
#line 40
    tmp = gettext("signal \'%s\' not found\n");
#line 40
    printf((char const   */* __restrict  */)tmp, id);
#line 41
    failed = 1;
    }
  }
#line 44
  return (failed);
}
}
#line 51 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/generic_bus.c"
void generic_bus_free(bus_t *bus___0 ) 
{ 


  {
  {
#line 54
  free(bus___0->params);
#line 55
  free((void *)bus___0);
  }
#line 56
  return;
}
}
#line 62 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/generic_bus.c"
int generic_bus_no_init(bus_t *bus___0 ) 
{ 


  {
#line 65
  bus___0->initialized = 1;
#line 67
  return (0);
}
}
#line 74 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/generic_bus.c"
void generic_bus_prepare_extest(bus_t *bus___0 ) 
{ 
  char *__cil_tmp2 ;

  {
#line 77
  if (! bus___0->initialized) {
    {
#line 78
    (*((bus___0->driver)->init))(bus___0);
    }
  }
  {
#line 80
  part_set_instruction(bus___0->part, "EXTEST");
#line 81
  chain_shift_instructions(bus___0->chain);
  }
#line 82
  return;
}
}
#line 88 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/generic_bus.c"
uint32_t generic_bus_read(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t tmp ;

  {
  {
#line 91
  (*((bus___0->driver)->read_start))(bus___0, adr);
#line 92
  tmp = (*((bus___0->driver)->read_end))(bus___0);
  }
#line 92
  return (tmp);
}
}
#line 38 "../../include/register.h"
tap_register *register_fill(tap_register *tr , int val ) ;
#line 41 "../../include/data_register.h"
data_register *data_register_alloc(char const   *name , int len ) ;
#line 43 "../../include/instruction.h"
instruction *instruction_alloc(char const   *name , int len , char const   *val ) ;
#line 55 "../../include/chain.h"
int chain_set_trst(chain_t *chain , int trst ) ;
#line 42 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/buses.h"
struct bus_driver  const  fjmem_bus ;
#line 50 "../../include/cmd.h"
int cmd_params(char **params ) ;
#line 51
int cmd_get_number(char *s , unsigned int *i ) ;
#line 32 "../../include/tap.h"
void tap_reset_bypass(chain_t *chain ) ;
#line 33
void tap_capture_dr(chain_t *chain ) ;
#line 37
void tap_shift_register(chain_t *chain , tap_register const   *in , tap_register *out ,
                        int tap_exit ) ;
#line 80 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/fjmem.c"
static int fjmem_detect_reg_len(chain_t *chain , part_t *part , char *opcode , int len ) 
{ 
  data_register *dr ;
  instruction *i ;
  int l ;
  int fjmem_reg_len ;
  char *tdo_bit ;
  char *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
  {
#line 89
  dr = data_register_alloc("FJMEM_REG", 1);
  }
#line 90
  if (! dr) {
    {
#line 91
    tmp = gettext("out of memory\n");
#line 91
    printf((char const   */* __restrict  */)tmp);
    }
#line 92
    return (0);
  }
  {
#line 95
  dr->next = part->data_registers;
#line 96
  part->data_registers = dr;
#line 100
  tmp___1 = strlen((char const   *)opcode);
  }
#line 100
  if (tmp___1 != (size_t )part->instruction_length) {
    {
#line 101
    tmp___0 = gettext("invalid instruction length\n");
#line 101
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 102
    return (0);
  }
  {
#line 104
  i = instruction_alloc("FJMEM_INST", part->instruction_length, (char const   *)opcode);
  }
#line 105
  if (! i) {
    {
#line 106
    tmp___2 = gettext("out of memory\n");
#line 106
    printf((char const   */* __restrict  */)tmp___2);
    }
#line 107
    return (0);
  }
  {
#line 109
  i->next = part->instructions;
#line 110
  part->instructions = i;
#line 111
  i->data_register = dr;
#line 115
  chain_set_trst(chain, 0);
#line 116
  chain_set_trst(chain, 1);
#line 117
  tap_reset_bypass(chain);
#line 120
  register_fill(dr->in, 0);
#line 121
  tap_capture_dr(chain);
#line 122
  l = 0;
  }
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;
#line 122
    if (! (l < (chain->parts)->len)) {
#line 122
      goto while_break;
    }
    {
#line 123
    tap_shift_register(chain, (tap_register const   *)dr->in, (tap_register *)((void *)0),
                       0);
#line 122
    l ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 125
  tap_shift_register(chain, (tap_register const   *)dr->in, (tap_register *)((void *)0),
                     1);
#line 128
  part_set_instruction(part, "FJMEM_INST");
#line 129
  chain_shift_instructions(chain);
  }
#line 132
  if (len) {
#line 133
    return (len);
  }
  {
#line 140
  fjmem_reg_len = 0;
#line 141
  register_fill(dr->in, 1);
#line 142
  register_fill(dr->out, 0);
#line 143
  tdo_bit = (dr->out)->data;
#line 145
  tap_capture_dr(chain);
#line 147
  tap_shift_register(chain, (tap_register const   *)dr->in, dr->out, 0);
#line 148
  register_get_string((tap_register const   *)dr->out);
  }
  {
#line 149
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 149
    if ((int )*(tdo_bit + 0) == 0) {
#line 149
      if (! (fjmem_reg_len < 2048)) {
#line 149
        goto while_break___0;
      }
    } else {
#line 149
      goto while_break___0;
    }
    {
#line 151
    tap_shift_register(chain, (tap_register const   *)dr->in, dr->out, 0);
#line 152
    tdo_bit = (dr->out)->data;
#line 153
    fjmem_reg_len ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 156
  fjmem_reg_len -= (chain->parts)->len - 1;
#line 158
  tap_shift_register(chain, (tap_register const   *)dr->in, (tap_register *)((void *)0),
                     1);
  }
#line 163
  if (fjmem_reg_len < 2048) {
#line 163
    tmp___3 = fjmem_reg_len;
  } else {
#line 163
    tmp___3 = -1;
  }
#line 163
  return (tmp___3);
}
}
#line 166 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/fjmem.c"
static int fjmem_detect_fields(chain_t *chain , part_t *part , bus_t *bus___0 ) 
{ 
  block_desc_t *bd ;
  data_register *dr ;
  int idx ;
  char *tmp ;
  tap_register *tmp___0 ;
  char *tmp___1 ;
  tap_register *tmp___2 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 169
  bd = & ((bus_params_t___18 *)bus___0->params)->block_desc;
#line 170
  dr = ((bus_params_t___18 *)bus___0->params)->fjmem_reg;
#line 177
  bd->block_len = (uint16_t )0;
#line 178
  bd->addr_pos = (uint16_t )0;
#line 179
  bd->addr_len = (uint16_t )0;
#line 180
  bd->data_pos = (uint16_t )0;
#line 181
  bd->data_len = (uint16_t )0;
#line 184
  if (dr->in) {
    {
#line 185
    free((void *)dr->in);
    }
  }
  {
#line 186
  tmp___0 = register_alloc((int )bd->reg_len);
#line 186
  dr->in = tmp___0;
  }
#line 186
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
    {
#line 187
    tmp = gettext("out of memory\n");
#line 187
    printf((char const   */* __restrict  */)tmp);
    }
#line 188
    return (0);
  }
#line 190
  if (dr->out) {
    {
#line 191
    free((void *)dr->out);
    }
  }
  {
#line 192
  tmp___2 = register_alloc((int )bd->reg_len);
#line 192
  dr->out = tmp___2;
  }
#line 192
  if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
    {
#line 193
    tmp___1 = gettext("out of memory\n");
#line 193
    printf((char const   */* __restrict  */)tmp___1);
    }
#line 194
    return (0);
  }
  {
#line 198
  register_fill(dr->in, 1);
#line 199
  chain_shift_data_registers(chain, 1);
#line 203
  register_fill(dr->in, 0);
#line 205
  *((dr->in)->data + ((int )bd->instr_pos + 1)) = (char)1;
#line 206
  *((dr->in)->data + ((int )bd->instr_pos + 2)) = (char)1;
#line 209
  chain_shift_data_registers(chain, 1);
#line 217
  idx = (int )bd->block_pos;
  }
  {
#line 218
  while (1) {
    while_continue: /* CIL Label */ ;
#line 218
    if (*((dr->out)->data + idx)) {
#line 218
      if (! (idx < (dr->out)->len)) {
#line 218
        goto while_break;
      }
    } else {
#line 218
      goto while_break;
    }
#line 219
    idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 220
  bd->block_len = (uint16_t )(idx - (int )bd->block_pos);
#line 222
  bd->addr_pos = (uint16_t )idx;
  {
#line 223
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 223
    if ((int )*((dr->out)->data + idx) == 0) {
#line 223
      if (! (idx < (dr->out)->len)) {
#line 223
        goto while_break___0;
      }
    } else {
#line 223
      goto while_break___0;
    }
#line 224
    idx ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 225
  bd->addr_len = (uint16_t )(idx - (int )bd->addr_pos);
#line 227
  bd->data_pos = (uint16_t )idx;
  {
#line 228
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 228
    if (*((dr->out)->data + idx)) {
#line 228
      if (! (idx < (dr->out)->len)) {
#line 228
        goto while_break___1;
      }
    } else {
#line 228
      goto while_break___1;
    }
#line 229
    idx ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 230
  bd->data_len = (uint16_t )(idx - (int )bd->data_pos);
#line 238
  if ((int )bd->block_len > 0) {
#line 238
    if ((int )bd->addr_len > 0) {
#line 238
      if ((int )bd->data_len > 0) {
#line 241
        return (1);
      } else {
#line 243
        return (0);
      }
    } else {
#line 243
      return (0);
    }
  } else {
#line 243
    return (0);
  }
}
}
#line 246 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/fjmem.c"
static int fjmem_query_blocks(chain_t *chain , part_t *part , bus_t *bus___0 ) 
{ 
  block_desc_t *bd ;
  data_register *dr ;
  int max_block_num ;
  int block_num ;
  int failed ;
  int next_block_num ;
  int idx ;
  int addr_len ;
  int data_len ;
  block_param_t *bl ;
  int nbytes ;
  char *tmp ;
  void *tmp___0 ;
  uint32_t mask ;
  int tmp___1 ;
  char *__cil_tmp19 ;

  {
#line 249
  bd = & ((bus_params_t___18 *)bus___0->params)->block_desc;
#line 250
  dr = ((bus_params_t___18 *)bus___0->params)->fjmem_reg;
#line 252
  failed = 0;
#line 259
  max_block_num = (1 << (int )bd->block_len) - 1;
#line 260
  block_num = 0;
  {
#line 260
  while (1) {
    while_continue: /* CIL Label */ ;
#line 260
    if (! (block_num <= max_block_num)) {
#line 260
      goto while_break;
    }
#line 261
    next_block_num = block_num + 1;
#line 266
    idx = 0;
    {
#line 266
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 266
      if (! (idx < (int )bd->block_len)) {
#line 266
        goto while_break___0;
      }
#line 267
      *((dr->in)->data + ((int )bd->block_pos + idx)) = (char )(next_block_num & 1);
#line 268
      next_block_num >>= 1;
#line 266
      idx ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 270
    chain_shift_data_registers(chain, 1);
#line 279
    addr_len = 0;
    }
    {
#line 279
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 279
      if (! (addr_len < (int )bd->addr_len)) {
#line 279
        goto while_break___1;
      }
#line 280
      if ((int )*((dr->out)->data + ((int )bd->addr_pos + addr_len)) == 0) {
#line 281
        goto while_break___1;
      }
#line 279
      addr_len ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 284
    data_len = 0;
    {
#line 284
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 284
      if (! (data_len < (int )bd->data_len)) {
#line 284
        goto while_break___2;
      }
#line 285
      if ((int )*((dr->out)->data + ((int )bd->data_pos + data_len)) == 0) {
#line 286
        goto while_break___2;
      }
#line 284
      data_len ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 290
    if (addr_len > 0) {
#line 290
      if (data_len > 0) {
        {
#line 294
        tmp___0 = calloc((size_t )1, (size_t )sizeof(block_param_t ));
#line 294
        bl = (block_param_t *)tmp___0;
        }
#line 294
        if ((unsigned long )bl == (unsigned long )((void *)0)) {
          {
#line 295
          tmp = gettext("out of memory\n");
#line 295
          printf((char const   */* __restrict  */)tmp);
#line 296
          failed |= 1;
          }
#line 297
          goto while_break;
        }
#line 300
        bl->next = bd->blocks;
#line 301
        bl->num = (uint16_t )block_num;
#line 302
        bl->addr_width = (uint16_t )addr_len;
#line 303
        bl->data_width = (uint16_t )data_len;
#line 304
        bd->blocks = bl;
#line 307
        nbytes = data_len / 8;
#line 308
        if (data_len % 8) {
#line 309
          nbytes ++;
        }
#line 311
        bl->ashift = (uint8_t )0;
        {
#line 312
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 312
          if (! (nbytes != 1)) {
#line 312
            goto while_break___3;
          }
#line 313
          bl->ashift = (uint8_t )((int )bl->ashift + 1);
#line 314
          nbytes >>= 1;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 318
        if ((unsigned long )bl->next == (unsigned long )((void *)0)) {
#line 319
          bl->start = (uint32_t )0;
        } else
#line 321
        if ((int )bl->addr_width << (int )bl->ashift <= (int )(bl->next)->addr_width << (int )(bl->next)->ashift) {
#line 322
          bl->start = (bl->next)->start + (uint32_t )(1 << ((int )(bl->next)->addr_width + (int )(bl->next)->ashift));
        } else {
#line 324
          mask = (uint32_t )(1 << ((int )bl->addr_width + (int )bl->ashift));
#line 325
          bl->start = (bl->next)->start & ~ (mask - 1U);
#line 326
          bl->start += mask;
        }
#line 330
        bl->end = (bl->start + (uint32_t )(1 << ((int )bl->addr_width + (int )bl->ashift))) - 1U;
      }
    }
#line 260
    block_num ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 342
  if (failed) {
#line 342
    tmp___1 = 0;
  } else {
#line 342
    tmp___1 = 1;
  }
#line 342
  return (tmp___1);
}
}
#line 349 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/fjmem.c"
static bus_t *fjmem_bus_new(chain_t *chain , bus_driver_t const   *driver , char **params ) 
{ 
  bus_t *bus___0 ;
  int failed ;
  part_t *part ;
  char *opcode ;
  int fjmem_reg_len ;
  int idx ;
  char *comma ;
  char *value ;
  char *tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  block_desc_t *bd ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
#line 352
  bus___0 = (bus_t *)((void *)0);
#line 353
  failed = 0;
#line 355
  opcode = (char *)((void *)0);
#line 356
  fjmem_reg_len = 0;
#line 359
  part = *((chain->parts)->parts + chain->active_part);
#line 362
  idx = 2;
  {
#line 362
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 362
    tmp___3 = cmd_params(params);
    }
#line 362
    if (! (idx < tmp___3)) {
#line 362
      goto while_break;
    }
    {
#line 365
    comma = strchr((char const   *)*(params + idx), '=');
    }
#line 366
    if ((unsigned long )comma == (unsigned long )((void *)0)) {
      {
#line 367
      tmp = gettext("Wrong parameter specification: %s\n");
#line 367
      printf((char const   */* __restrict  */)tmp, *(params + idx));
      }
#line 368
      goto __Cont;
    }
    {
#line 372
    value = comma + 1;
#line 373
    *comma = (char )'\000';
#line 375
    tmp___0 = strcasecmp((char const   *)*(params + idx), "opcode");
    }
#line 375
    if (tmp___0 == 0) {
#line 376
      opcode = value;
    }
    {
#line 377
    tmp___2 = strcasecmp((char const   *)*(params + idx), "len");
    }
#line 377
    if (tmp___2 == 0) {
      {
#line 379
      cmd_get_number(value, & tmp___1);
#line 380
      fjmem_reg_len = (int )tmp___1;
      }
    }
    __Cont: /* CIL Label */ 
#line 362
    idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 384
  if (opcode) {
    {
#line 387
    fjmem_reg_len = fjmem_detect_reg_len(chain, part, opcode, fjmem_reg_len);
    }
#line 388
    if (fjmem_reg_len <= 0) {
#line 389
      return ((bus_t *)((void *)0));
    }
    {
#line 391
    tmp___4 = calloc((size_t )1, (size_t )sizeof(bus_t ));
#line 391
    bus___0 = (bus_t *)tmp___4;
    }
#line 392
    if (! bus___0) {
#line 393
      return ((bus_t *)((void *)0));
    }
    {
#line 395
    bus___0->driver = driver;
#line 396
    bus___0->params = calloc((size_t )1, (size_t )sizeof(bus_params_t___18 ));
    }
#line 397
    if (! bus___0->params) {
      {
#line 398
      free((void *)bus___0);
      }
#line 399
      return ((bus_t *)((void *)0));
    }
    {
#line 402
    bus___0->chain = chain;
#line 403
    bus___0->part = *((chain->parts)->parts + chain->active_part);
#line 404
    ((bus_params_t___18 *)bus___0->params)->fjmem_reg = part_find_data_register(bus___0->part,
                                                                                "FJMEM_REG");
#line 405
    bd = & ((bus_params_t___18 *)bus___0->params)->block_desc;
#line 406
    bd->blocks = (block_param_t *)((void *)0);
#line 407
    bd->reg_len = (uint16_t )fjmem_reg_len;
#line 408
    bd->instr_pos = (uint16_t )0;
#line 409
    bd->block_pos = (uint16_t )((int )bd->instr_pos + 4);
#line 411
    tmp___6 = fjmem_detect_fields(chain, part, bus___0);
    }
#line 411
    if (tmp___6 > 0) {
      {
#line 412
      tmp___5 = fjmem_query_blocks(chain, part, bus___0);
      }
#line 412
      if (! (tmp___5 > 0)) {
#line 414
        failed |= 1;
      }
    } else {
#line 416
      failed |= 1;
    }
#line 418
    if (failed) {
      {
#line 419
      free(bus___0->params);
#line 420
      free((void *)bus___0);
      }
#line 421
      return ((bus_t *)((void *)0));
    }
  } else {
    {
#line 424
    tmp___7 = gettext("Parameter for instruction opcode missing.\n");
#line 424
    printf((char const   */* __restrict  */)tmp___7);
    }
  }
#line 426
  return (bus___0);
}
}
#line 429 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/fjmem.c"
static void fjmem_free_blocks(block_param_t *bl ) 
{ 


  {
#line 432
  if (bl) {
    {
#line 433
    fjmem_free_blocks(bl->next);
#line 434
    free((void *)bl);
    }
  }
#line 436
  return;
}
}
#line 442 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/fjmem.c"
static void fjmem_bus_free(bus_t *bus___0 ) 
{ 
  data_register *dr ;
  char *__cil_tmp3 ;

  {
  {
#line 445
  dr = ((bus_params_t___18 *)bus___0->params)->fjmem_reg;
#line 449
  part_set_instruction(bus___0->part, "FJMEM_INST");
#line 450
  chain_shift_instructions(bus___0->chain);
#line 452
  register_fill(dr->in, 0);
#line 453
  chain_shift_data_registers(bus___0->chain, 0);
#line 455
  fjmem_free_blocks(((bus_params_t___18 *)bus___0->params)->block_desc.blocks);
#line 456
  ((bus_params_t___18 *)bus___0->params)->block_desc.blocks = (block_param_t *)((void *)0);
#line 458
  generic_bus_free(bus___0);
  }
#line 459
  return;
}
}
#line 465 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/fjmem.c"
static void fjmem_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;
  char *__cil_tmp4 ;

  {
#line 470
  i = 0;
  {
#line 470
  while (1) {
    while_continue: /* CIL Label */ ;
#line 470
    if (! (i < ((bus___0->chain)->parts)->len)) {
#line 470
      goto while_break;
    }
#line 471
    if ((unsigned long )bus___0->part == (unsigned long )*(((bus___0->chain)->parts)->parts + i)) {
#line 472
      goto while_break;
    }
#line 470
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 473
  tmp = gettext("fjmem FPGA bus driver via USER register (JTAG part No. %d)\n");
#line 473
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 474
  return;
}
}
#line 480 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/fjmem.c"
static void fjmem_bus_prepare(bus_t *bus___0 ) 
{ 
  char *__cil_tmp2 ;

  {
#line 483
  if (! bus___0->initialized) {
    {
#line 484
    (*((bus___0->driver)->init))(bus___0);
    }
  }
  {
#line 487
  part_set_instruction(bus___0->part, "FJMEM_INST");
#line 488
  chain_shift_instructions(bus___0->chain);
  }
#line 489
  return;
}
}
#line 491 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/fjmem.c"
static int block_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area___0 , block_param_t **bl_match ) 
{ 
  block_param_t *bl ;
  uint32_t prev_start ;
  char *__cil_tmp7 ;

  {
#line 494
  bl = ((bus_params_t___18 *)bus___0->params)->block_desc.blocks;
#line 497
  *bl_match = (block_param_t *)((void *)0);
#line 501
  prev_start = (uint32_t )0;
  {
#line 502
  while (1) {
    while_continue: /* CIL Label */ ;
#line 502
    if (! bl) {
#line 502
      goto while_break;
    }
#line 503
    if (bl->start <= adr) {
#line 503
      if (bl->end >= adr) {
#line 505
        area___0->description = (char const   *)((void *)0);
#line 506
        area___0->start = bl->start;
#line 507
        area___0->length = (uint64_t )((bl->end - bl->start) + 1U);
#line 508
        area___0->width = (unsigned int )bl->data_width;
#line 509
        *bl_match = bl;
#line 510
        prev_start = area___0->start;
      } else {
#line 503
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 511
    if (prev_start > adr) {
#line 511
      goto _L;
    } else
#line 511
    if (prev_start == 0U) {
      _L: /* CIL Label */ 
#line 511
      if (bl->end < adr) {
#line 513
        area___0->description = "Dummy";
#line 514
        area___0->start = bl->end + 1U;
#line 515
        if (prev_start > 0U) {
#line 515
          area___0->length = (uint64_t )(prev_start - (bl->end + 1U));
        } else {
#line 515
          area___0->length = 4294967296ULL;
        }
#line 516
        area___0->width = 0U;
#line 517
        *bl_match = (block_param_t *)((void *)0);
#line 518
        prev_start = area___0->start;
      } else {
#line 520
        prev_start = bl->start;
      }
    } else {
#line 520
      prev_start = bl->start;
    }
#line 522
    bl = bl->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 525
  return (0);
}
}
#line 532 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/fjmem.c"
static int fjmem_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area___0 ) 
{ 
  block_param_t *bl ;
  int tmp ;

  {
  {
#line 537
  tmp = block_bus_area(bus___0, adr, area___0, & bl);
  }
#line 537
  return (tmp);
}
}
#line 540 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/fjmem.c"
static void setup_address___18(bus_t *bus___0 , uint32_t a , block_param_t *block ) 
{ 
  data_register *dr ;
  block_desc_t *bd ;
  int idx ;
  uint16_t num ;

  {
#line 543
  dr = ((bus_params_t___18 *)bus___0->params)->fjmem_reg;
#line 544
  bd = & ((bus_params_t___18 *)bus___0->params)->block_desc;
#line 546
  num = block->num;
#line 548
  ((bus_params_t___18 *)bus___0->params)->last_addr = a;
#line 551
  a >>= (int )block->ashift;
#line 554
  idx = 0;
  {
#line 554
  while (1) {
    while_continue: /* CIL Label */ ;
#line 554
    if (! (idx < (int )bd->block_len)) {
#line 554
      goto while_break;
    }
#line 555
    *((dr->in)->data + ((int )bd->block_pos + idx)) = (char )((int )num & 1);
#line 556
    num = (uint16_t )((int )num >> 1);
#line 554
    idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 560
  idx = 0;
  {
#line 560
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 560
    if (! (idx < (int )block->addr_width)) {
#line 560
      goto while_break___0;
    }
#line 561
    *((dr->in)->data + ((int )bd->addr_pos + idx)) = (char )(a & 1U);
#line 562
    a >>= 1;
#line 560
    idx ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 564
  return;
}
}
#line 566 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/fjmem.c"
static void setup_data___18(bus_t *bus___0 , uint32_t d , block_param_t *block ) 
{ 
  data_register *dr ;
  block_desc_t *bd ;
  int idx ;

  {
#line 569
  dr = ((bus_params_t___18 *)bus___0->params)->fjmem_reg;
#line 570
  bd = & ((bus_params_t___18 *)bus___0->params)->block_desc;
#line 574
  idx = 0;
  {
#line 574
  while (1) {
    while_continue: /* CIL Label */ ;
#line 574
    if (! (idx < (int )block->data_width)) {
#line 574
      goto while_break;
    }
#line 575
    *((dr->in)->data + ((int )bd->data_pos + idx)) = (char )(d & 1U);
#line 576
    d >>= 1;
#line 574
    idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 578
  return;
}
}
#line 584 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/fjmem.c"
static void fjmem_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  chain_t *chain ;
  block_desc_t *bd ;
  data_register *dr ;
  bus_area_t area___0 ;
  block_param_t *block ;
  char *tmp ;
  char *__cil_tmp9 ;

  {
  {
#line 587
  chain = bus___0->chain;
#line 588
  bd = & ((bus_params_t___18 *)bus___0->params)->block_desc;
#line 589
  dr = ((bus_params_t___18 *)bus___0->params)->fjmem_reg;
#line 593
  block_bus_area(bus___0, adr, & area___0, & block);
  }
#line 594
  if (! block) {
    {
#line 595
    tmp = gettext("Address out of range\n");
#line 595
    printf((char const   */* __restrict  */)tmp);
#line 596
    ((bus_params_t___18 *)bus___0->params)->last_addr = adr;
    }
#line 597
    return;
  }
  {
#line 600
  setup_address___18(bus___0, adr, block);
#line 603
  *((dr->in)->data + (int )bd->instr_pos) = (char)1;
#line 604
  *((dr->in)->data + ((int )bd->instr_pos + 1)) = (char)0;
#line 605
  *((dr->in)->data + ((int )bd->instr_pos + 2)) = (char)0;
#line 607
  chain_shift_data_registers(chain, 0);
  }
#line 608
  return;
}
}
#line 614 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/fjmem.c"
static uint32_t fjmem_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  chain_t *chain ;
  block_desc_t *bd ;
  data_register *dr ;
  uint32_t d ;
  bus_area_t area___0 ;
  block_param_t *block ;
  int idx ;
  char *tmp ;
  char *__cil_tmp11 ;

  {
  {
#line 617
  chain = bus___0->chain;
#line 618
  bd = & ((bus_params_t___18 *)bus___0->params)->block_desc;
#line 619
  dr = ((bus_params_t___18 *)bus___0->params)->fjmem_reg;
#line 625
  block_bus_area(bus___0, adr, & area___0, & block);
  }
#line 626
  if (! block) {
    {
#line 627
    tmp = gettext("Address out of range\n");
#line 627
    printf((char const   */* __restrict  */)tmp);
#line 628
    ((bus_params_t___18 *)bus___0->params)->last_addr = adr;
    }
#line 629
    return ((uint32_t )0);
  }
  {
#line 632
  setup_address___18(bus___0, adr, block);
#line 633
  chain_shift_data_registers(chain, 1);
#line 636
  d = (uint32_t )0;
#line 637
  idx = 0;
  }
  {
#line 637
  while (1) {
    while_continue: /* CIL Label */ ;
#line 637
    if (! (idx < (int )block->data_width)) {
#line 637
      goto while_break;
    }
#line 638
    if (*((dr->out)->data + ((int )bd->data_pos + idx))) {
#line 639
      d |= (unsigned int )(1 << idx);
    }
#line 637
    idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 641
  return (d);
}
}
#line 648 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/fjmem.c"
static uint32_t fjmem_bus_read_end(bus_t *bus___0 ) 
{ 
  chain_t *chain ;
  block_desc_t *bd ;
  data_register *dr ;
  uint32_t d ;
  bus_area_t area___0 ;
  block_param_t *block ;
  int idx ;
  char *tmp ;
  char *__cil_tmp10 ;

  {
  {
#line 651
  chain = bus___0->chain;
#line 652
  bd = & ((bus_params_t___18 *)bus___0->params)->block_desc;
#line 653
  dr = ((bus_params_t___18 *)bus___0->params)->fjmem_reg;
#line 659
  block_bus_area(bus___0, ((bus_params_t___18 *)bus___0->params)->last_addr, & area___0,
                 & block);
  }
#line 660
  if (! block) {
    {
#line 661
    tmp = gettext("Address out of range\n");
#line 661
    printf((char const   */* __restrict  */)tmp);
    }
#line 662
    return ((uint32_t )0);
  }
  {
#line 666
  *((dr->in)->data + (int )bd->instr_pos) = (char)0;
#line 667
  *((dr->in)->data + ((int )bd->instr_pos + 1)) = (char)0;
#line 668
  *((dr->in)->data + ((int )bd->instr_pos + 2)) = (char)0;
#line 670
  chain_shift_data_registers(chain, 1);
#line 673
  d = (uint32_t )0;
#line 674
  idx = 0;
  }
  {
#line 674
  while (1) {
    while_continue: /* CIL Label */ ;
#line 674
    if (! (idx < (int )block->data_width)) {
#line 674
      goto while_break;
    }
#line 675
    if (*((dr->out)->data + ((int )bd->data_pos + idx))) {
#line 676
      d |= (unsigned int )(1 << idx);
    }
#line 674
    idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 678
  return (d);
}
}
#line 685 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/fjmem.c"
static void fjmem_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  chain_t *chain ;
  block_desc_t *bd ;
  data_register *dr ;
  bus_area_t area___0 ;
  block_param_t *block ;
  char *tmp ;
  char *__cil_tmp10 ;

  {
  {
#line 688
  chain = bus___0->chain;
#line 689
  bd = & ((bus_params_t___18 *)bus___0->params)->block_desc;
#line 690
  dr = ((bus_params_t___18 *)bus___0->params)->fjmem_reg;
#line 694
  block_bus_area(bus___0, adr, & area___0, & block);
  }
#line 695
  if (! block) {
    {
#line 696
    tmp = gettext("Address out of range\n");
#line 696
    printf((char const   */* __restrict  */)tmp);
    }
#line 697
    return;
  }
  {
#line 700
  setup_address___18(bus___0, adr, block);
#line 701
  setup_data___18(bus___0, data, block);
#line 704
  *((dr->in)->data + (int )bd->instr_pos) = (char)0;
#line 705
  *((dr->in)->data + ((int )bd->instr_pos + 1)) = (char)1;
#line 706
  *((dr->in)->data + ((int )bd->instr_pos + 2)) = (char)0;
#line 708
  chain_shift_data_registers(chain, 0);
  }
#line 709
  return;
}
}
#line 711 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/fjmem.c"
struct bus_driver  const  fjmem_bus  = 
#line 711
     {"fjmem", "FPGA JTAG memory bus driver via USER register, requires parameters:\n           opcode=<USERx OPCODE> [len=<FJMEM REG LEN>]",
    & fjmem_bus_new, & fjmem_bus_free, & fjmem_bus_printinfo, & fjmem_bus_prepare,
    & fjmem_bus_area, & fjmem_bus_read_start, & fjmem_bus_read_next, & fjmem_bus_read_end,
    & generic_bus_read, & fjmem_bus_write, & generic_bus_no_init};
#line 76 "../../include/bus_driver.h"
bus_t *bus ;
#line 63 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/buses.h"
struct bus_driver  const  ejtag_dma_bus ;
#line 88 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ejtag_dma.c"
static bus_t *ejtag_dma_bus_new(chain_t *chain , bus_driver_t const   *driver , char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  void *tmp ;

  {
  {
#line 93
  tmp = calloc((size_t )1, (size_t )sizeof(bus_t ));
#line 93
  bus___0 = (bus_t *)tmp;
  }
#line 94
  if (! bus___0) {
#line 95
    return ((bus_t *)((void *)0));
  }
  {
#line 97
  bus___0->driver = driver;
#line 98
  bus___0->params = calloc((size_t )1, (size_t )sizeof(bus_params_t___19 ));
  }
#line 99
  if (! bus___0->params) {
    {
#line 100
    free((void *)bus___0);
    }
#line 101
    return ((bus_t *)((void *)0));
  }
#line 104
  bus___0->chain = chain;
#line 105
  bus___0->part = *((chain->parts)->parts + chain->active_part);
#line 107
  return (bus___0);
}
}
#line 114 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ejtag_dma.c"
static void ejtag_dma_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;
  char *__cil_tmp4 ;

  {
#line 119
  i = 0;
  {
#line 119
  while (1) {
    while_continue: /* CIL Label */ ;
#line 119
    if (! (i < ((bus___0->chain)->parts)->len)) {
#line 119
      goto while_break;
    }
#line 120
    if ((unsigned long )bus___0->part == (unsigned long )*(((bus___0->chain)->parts)->parts + i)) {
#line 121
      goto while_break;
    }
#line 119
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 122
  tmp = gettext("EJTAG compatible bus driver via DMA (JTAG part No. %d)\n");
#line 122
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 123
  return;
}
}
#line 129 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ejtag_dma.c"
static uint32_t reg_value(tap_register *reg ) 
{ 
  uint32_t retval ;
  int i ;

  {
#line 132
  retval = (uint32_t )0;
#line 135
  i = 0;
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 135
    if (! (i < reg->len)) {
#line 135
      goto while_break;
    }
#line 136
    if (*(reg->data + i)) {
#line 137
      retval |= (unsigned int )(1 << i);
    }
#line 135
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 139
  return (retval);
}
}
#line 162
static void ejtag_dma_write(unsigned int addr , unsigned int data , int sz ) ;
#line 162 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ejtag_dma.c"
static data_register *ejctrl  =    (data_register *)((void *)0);
#line 163 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ejtag_dma.c"
static data_register *ejaddr  =    (data_register *)((void *)0);
#line 164 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ejtag_dma.c"
static data_register *ejdata  =    (data_register *)((void *)0);
#line 160 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ejtag_dma.c"
static void ejtag_dma_write(unsigned int addr , unsigned int data , int sz ) 
{ 
  int i ;
  int timeout ;
  char *tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 165
  i = 0;
#line 166
  timeout = 5;
#line 168
  if ((unsigned long )ejctrl == (unsigned long )((void *)0)) {
    {
#line 169
    ejctrl = part_find_data_register(bus->part, "EJCONTROL");
    }
  }
#line 170
  if ((unsigned long )ejaddr == (unsigned long )((void *)0)) {
    {
#line 171
    ejaddr = part_find_data_register(bus->part, "EJADDRESS");
    }
  }
#line 172
  if ((unsigned long )ejdata == (unsigned long )((void *)0)) {
    {
#line 173
    ejdata = part_find_data_register(bus->part, "EJDATA");
    }
  }
  {
#line 176
  if (sz == 0) {
#line 176
    goto case_0;
  }
#line 179
  if (sz == 7) {
#line 179
    goto case_7;
  }
#line 182
  goto switch_default;
  case_0: /* CIL Label */ 
#line 177
  data &= 255U;
#line 177
  data |= ((data << 8) | (data << 16)) | (data << 24);
#line 178
  goto switch_break;
  case_7: /* CIL Label */ 
#line 180
  data &= 65535U;
#line 180
  data |= data << 16;
#line 181
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 182
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 185
  part_set_instruction(bus->part, "EJTAG_ADDRESS");
#line 186
  chain_shift_instructions(bus->chain);
#line 187
  i = 0;
  }
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (! (i < 32)) {
#line 187
      goto while_break;
    }
#line 188
    *((ejaddr->in)->data + i) = (char )((addr >> i) & 1U);
#line 187
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 189
  chain_shift_data_registers(bus->chain, 0);
#line 193
  part_set_instruction(bus->part, "EJTAG_DATA");
#line 194
  chain_shift_instructions(bus->chain);
#line 195
  i = 0;
  }
  {
#line 195
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 195
    if (! (i < 32)) {
#line 195
      goto while_break___0;
    }
#line 196
    *((ejdata->in)->data + i) = (char )((data >> i) & 1U);
#line 195
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 197
  chain_shift_data_registers(bus->chain, 0);
#line 201
  part_set_instruction(bus->part, "EJTAG_CONTROL");
#line 202
  chain_shift_instructions(bus->chain);
#line 203
  register_fill(ejctrl->in, 0);
#line 204
  *((ejctrl->in)->data + 18) = (char)1;
#line 205
  *((ejctrl->in)->data + 15) = (char)1;
#line 206
  *((ejctrl->in)->data + 17) = (char)1;
#line 207
  *((ejctrl->in)->data + 11) = (char)1;
  }
#line 208
  if (sz) {
#line 209
    *((ejctrl->in)->data + sz) = (char)1;
  }
  {
#line 210
  chain_shift_data_registers(bus->chain, 0);
  }
  {
#line 213
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 214
    part_set_instruction(bus->part, "EJTAG_CONTROL");
#line 215
    chain_shift_instructions(bus->chain);
#line 216
    register_fill(ejctrl->in, 0);
#line 217
    *((ejctrl->in)->data + 18) = (char)1;
#line 218
    *((ejctrl->in)->data + 15) = (char)1;
#line 219
    *((ejctrl->in)->data + 17) = (char)1;
#line 220
    chain_shift_data_registers(bus->chain, 1);
#line 221
    timeout --;
    }
#line 222
    if (! timeout) {
#line 223
      goto while_break___1;
    }
#line 213
    if (! ((int )*((ejctrl->out)->data + 11) == 1)) {
#line 213
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 226
  part_set_instruction(bus->part, "EJTAG_CONTROL");
#line 227
  chain_shift_instructions(bus->chain);
#line 228
  register_fill(ejctrl->in, 0);
#line 229
  *((ejctrl->in)->data + 18) = (char)1;
#line 230
  *((ejctrl->in)->data + 15) = (char)1;
#line 231
  chain_shift_data_registers(bus->chain, 1);
  }
#line 232
  if ((int )*((ejctrl->out)->data + 10) == 1) {
    {
#line 233
    tmp = gettext("%s(%d) Error on dma write (dma transaction failed)\n");
#line 233
    printf((char const   */* __restrict  */)tmp, "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ejtag_dma.c",
           234);
    }
  }
#line 236
  return;
}
}
#line 245
static unsigned int ejtag_dma_read(unsigned int addr , int sz ) ;
#line 245 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ejtag_dma.c"
static data_register *ejctrl___0  =    (data_register *)((void *)0);
#line 246 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ejtag_dma.c"
static data_register *ejaddr___0  =    (data_register *)((void *)0);
#line 247 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ejtag_dma.c"
static data_register *ejdata___0  =    (data_register *)((void *)0);
#line 243 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ejtag_dma.c"
static unsigned int ejtag_dma_read(unsigned int addr , int sz ) 
{ 
  int i ;
  int timeout ;
  unsigned int ret ;
  char *tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 248
  i = 0;
#line 249
  timeout = 5;
#line 252
  if ((unsigned long )ejctrl___0 == (unsigned long )((void *)0)) {
    {
#line 253
    ejctrl___0 = part_find_data_register(bus->part, "EJCONTROL");
    }
  }
#line 254
  if ((unsigned long )ejaddr___0 == (unsigned long )((void *)0)) {
    {
#line 255
    ejaddr___0 = part_find_data_register(bus->part, "EJADDRESS");
    }
  }
#line 256
  if ((unsigned long )ejdata___0 == (unsigned long )((void *)0)) {
    {
#line 257
    ejdata___0 = part_find_data_register(bus->part, "EJDATA");
    }
  }
  {
#line 259
  part_set_instruction(bus->part, "EJTAG_ADDRESS");
#line 260
  chain_shift_instructions(bus->chain);
#line 261
  i = 0;
  }
  {
#line 261
  while (1) {
    while_continue: /* CIL Label */ ;
#line 261
    if (! (i < 32)) {
#line 261
      goto while_break;
    }
#line 262
    *((ejaddr___0->in)->data + i) = (char )((addr >> i) & 1U);
#line 261
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 263
  chain_shift_data_registers(bus->chain, 0);
#line 267
  part_set_instruction(bus->part, "EJTAG_CONTROL");
#line 268
  chain_shift_instructions(bus->chain);
#line 269
  register_fill(ejctrl___0->in, 0);
#line 270
  *((ejctrl___0->in)->data + 18) = (char)1;
#line 271
  *((ejctrl___0->in)->data + 15) = (char)1;
#line 272
  *((ejctrl___0->in)->data + 17) = (char)1;
#line 273
  *((ejctrl___0->in)->data + 11) = (char)1;
  }
#line 274
  if (sz) {
#line 275
    *((ejctrl___0->in)->data + sz) = (char)1;
  }
  {
#line 276
  *((ejctrl___0->in)->data + 9) = (char)1;
#line 277
  chain_shift_data_registers(bus->chain, 0);
  }
  {
#line 280
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 281
    part_set_instruction(bus->part, "EJTAG_CONTROL");
#line 282
    chain_shift_instructions(bus->chain);
#line 283
    register_fill(ejctrl___0->in, 0);
#line 284
    *((ejctrl___0->in)->data + 18) = (char)1;
#line 285
    *((ejctrl___0->in)->data + 15) = (char)1;
#line 286
    *((ejctrl___0->in)->data + 17) = (char)1;
#line 287
    chain_shift_data_registers(bus->chain, 1);
#line 291
    timeout --;
    }
#line 292
    if (! timeout) {
#line 293
      goto while_break___0;
    }
#line 280
    if (! ((int )*((ejctrl___0->out)->data + 11) == 1)) {
#line 280
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 296
  part_set_instruction(bus->part, "EJTAG_DATA");
#line 297
  chain_shift_instructions(bus->chain);
#line 298
  register_fill(ejdata___0->in, 0);
#line 299
  chain_shift_data_registers(bus->chain, 1);
#line 300
  ret = reg_value(ejdata___0->out);
#line 304
  part_set_instruction(bus->part, "EJTAG_CONTROL");
#line 305
  chain_shift_instructions(bus->chain);
#line 306
  register_fill(ejctrl___0->in, 0);
#line 307
  *((ejctrl___0->in)->data + 18) = (char)1;
#line 308
  *((ejctrl___0->in)->data + 15) = (char)1;
#line 309
  chain_shift_data_registers(bus->chain, 1);
  }
#line 314
  if ((int )*((ejctrl___0->out)->data + 10) == 1) {
    {
#line 315
    tmp = gettext("%s(%d) Error on dma read (dma transaction failed)\n");
#line 315
    printf((char const   */* __restrict  */)tmp, "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ejtag_dma.c",
           316);
    }
  }
  {
#line 320
  if (sz == 7) {
#line 320
    goto case_7;
  }
#line 321
  if (sz == 0) {
#line 321
    goto case_0;
  }
#line 323
  goto switch_default;
  case_7: /* CIL Label */ 
#line 320
  ret &= ret & 65535U;
#line 320
  goto switch_break;
  case_0: /* CIL Label */ 
#line 321
  ret &= ret & 255U;
#line 321
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 323
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 326
  return (ret);
}
}
#line 333 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ejtag_dma.c"
int ejtag_dma_bus_init(bus_t *bus___0 ) 
{ 
  data_register *ejctrl___1 ;
  data_register *ejimpl ;
  data_register *ejaddr___1 ;
  data_register *ejdata___1 ;
  int timeout ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  unsigned int val ;
  unsigned int tmp___13 ;
  char *tmp___14 ;
  unsigned int tmp___15 ;
  unsigned int tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;

  {
  {
#line 335
  ejctrl___1 = (data_register *)((void *)0);
#line 335
  ejimpl = (data_register *)((void *)0);
#line 335
  ejaddr___1 = (data_register *)((void *)0);
#line 335
  ejdata___1 = (data_register *)((void *)0);
#line 336
  timeout = 100;
#line 338
  tmp = tap_state(bus___0->chain);
  }
#line 338
  if (tmp != 1 << 3) {
#line 343
    return (0);
  }
  {
#line 346
  ejctrl___1 = part_find_data_register(bus___0->part, "EJCONTROL");
#line 347
  ejimpl = part_find_data_register(bus___0->part, "EJIMPCODE");
#line 348
  ejaddr___1 = part_find_data_register(bus___0->part, "EJADDRESS");
#line 349
  ejdata___1 = part_find_data_register(bus___0->part, "EJDATA");
  }
#line 351
  if (ejctrl___1) {
#line 351
    if (! ejimpl) {
      {
#line 352
      tmp___0 = gettext("%s(%d) EJCONTROL or EJIMPCODE register not found\n");
#line 352
      printf((char const   */* __restrict  */)tmp___0, "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ejtag_dma.c",
             353);
      }
#line 354
      return (1);
    }
  } else {
    {
#line 352
    tmp___0 = gettext("%s(%d) EJCONTROL or EJIMPCODE register not found\n");
#line 352
    printf((char const   */* __restrict  */)tmp___0, "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ejtag_dma.c",
           353);
    }
#line 354
    return (1);
  }
#line 356
  if (ejaddr___1) {
#line 356
    if (! ejdata___1) {
      {
#line 357
      tmp___1 = gettext("%s(%d) EJADDRESS of EJDATA register not found, DMA impossible\n");
#line 357
      printf((char const   */* __restrict  */)tmp___1, "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ejtag_dma.c",
             358);
      }
#line 359
      return (1);
    }
  } else {
    {
#line 357
    tmp___1 = gettext("%s(%d) EJADDRESS of EJDATA register not found, DMA impossible\n");
#line 357
    printf((char const   */* __restrict  */)tmp___1, "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ejtag_dma.c",
           358);
    }
#line 359
    return (1);
  }
  {
#line 362
  part_set_instruction(bus___0->part, "EJTAG_IMPCODE");
#line 363
  chain_shift_instructions(bus___0->chain);
#line 364
  chain_shift_data_registers(bus___0->chain, 0);
#line 365
  chain_shift_data_registers(bus___0->chain, 1);
#line 366
  tmp___2 = register_get_string((tap_register const   *)ejimpl->out);
#line 366
  printf((char const   */* __restrict  */)"ImpCode=%s\n", tmp___2);
#line 367
  ((bus_params_t___19 *)bus___0->params)->impcode = reg_value(ejimpl->out);
  }
  {
#line 370
  if (((((bus_params_t___19 *)bus___0->params)->impcode >> 29) & 7U) == 0U) {
#line 370
    goto case_0;
  }
#line 371
  if (((((bus_params_t___19 *)bus___0->params)->impcode >> 29) & 7U) == 1U) {
#line 371
    goto case_1;
  }
#line 372
  if (((((bus_params_t___19 *)bus___0->params)->impcode >> 29) & 7U) == 2U) {
#line 372
    goto case_2;
  }
#line 373
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 370
  printf((char const   */* __restrict  */)"EJTAG version: <= 2.0\n");
  }
#line 370
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 371
  printf((char const   */* __restrict  */)"EJTAG version: 2.5\n");
  }
#line 371
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 372
  printf((char const   */* __restrict  */)"EJTAG version: 2.6\n");
  }
#line 372
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 374
  printf((char const   */* __restrict  */)"EJTAG version: unknown (%d)\n", (((bus_params_t___19 *)bus___0->params)->impcode >> 29) & 7U);
  }
  switch_break: /* CIL Label */ ;
  }
#line 376
  if (((bus_params_t___19 *)bus___0->params)->impcode & 1U) {
#line 376
    tmp___3 = " MIPS64";
  } else {
#line 376
    tmp___3 = " MIPS32";
  }
#line 376
  if (((bus_params_t___19 *)bus___0->params)->impcode & (unsigned int )(1 << 14)) {
#line 376
    tmp___4 = " NoDMA";
  } else {
#line 376
    tmp___4 = " DMA";
  }
#line 376
  if (((bus_params_t___19 *)bus___0->params)->impcode & (unsigned int )(1 << 16)) {
#line 376
    tmp___5 = " MIPS16";
  } else {
#line 376
    tmp___5 = "";
  }
#line 376
  if (((bus_params_t___19 *)bus___0->params)->impcode & (unsigned int )(1 << 21)) {
#line 376
    tmp___6 = " ASID_6";
  } else {
#line 376
    tmp___6 = "";
  }
#line 376
  if (((bus_params_t___19 *)bus___0->params)->impcode & (unsigned int )(1 << 22)) {
#line 376
    tmp___7 = " ASID_8";
  } else {
#line 376
    tmp___7 = "";
  }
#line 376
  if (((bus_params_t___19 *)bus___0->params)->impcode & (unsigned int )(1 << 24)) {
#line 376
    tmp___8 = " DINTsup";
  } else {
#line 376
    tmp___8 = "";
  }
#line 376
  if (((bus_params_t___19 *)bus___0->params)->impcode & (unsigned int )(1 << 28)) {
#line 376
    tmp___9 = " R3k";
  } else {
#line 376
    tmp___9 = " R4k";
  }
  {
#line 376
  printf((char const   */* __restrict  */)"EJTAG Implementation flags:%s%s%s%s%s%s%s\n",
         tmp___9, tmp___8, tmp___7, tmp___6, tmp___5, tmp___4, tmp___3);
  }
#line 385
  if (((bus_params_t___19 *)bus___0->params)->impcode & (unsigned int )(1 << 14)) {
    {
#line 386
    printf((char const   */* __restrict  */)"Warning, plateform claim there are no DMA support\n");
    }
  }
#line 389
  if (((((bus_params_t___19 *)bus___0->params)->impcode >> 29) & 7U) != 0U) {
    {
#line 390
    printf((char const   */* __restrict  */)"Warning, plateform has a version which is not supposed to have DMA\n");
    }
  }
  {
#line 395
  part_set_instruction(bus___0->part, "EJTAGBOOT");
#line 396
  chain_shift_instructions(bus___0->chain);
#line 399
  part_set_instruction(bus___0->part, "EJTAG_CONTROL");
#line 400
  chain_shift_instructions(bus___0->chain);
#line 401
  register_fill(ejctrl___1->in, 0);
#line 404
  *((ejctrl___1->in)->data + 16) = (char)1;
#line 405
  *((ejctrl___1->in)->data + 20) = (char)1;
#line 406
  chain_shift_data_registers(bus___0->chain, 0);
#line 409
  *((ejctrl___1->in)->data + 16) = (char)0;
#line 410
  *((ejctrl___1->in)->data + 20) = (char)0;
#line 411
  chain_shift_data_registers(bus___0->chain, 0);
#line 413
  *((ejctrl___1->in)->data + 18) = (char)1;
#line 414
  *((ejctrl___1->in)->data + 15) = (char)1;
#line 415
  *((ejctrl___1->in)->data + 14) = (char)1;
#line 416
  *((ejctrl___1->in)->data + 12) = (char)1;
#line 417
  *((ejctrl___1->in)->data + 31) = (char)1;
#line 418
  chain_shift_data_registers(bus___0->chain, 0);
#line 421
  *((ejctrl___1->in)->data + 12) = (char)0;
  }
  {
#line 422
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 423
    chain_shift_data_registers(bus___0->chain, 1);
#line 424
    timeout --;
    }
#line 425
    if (! timeout) {
#line 425
      goto while_break;
    }
#line 422
    if (! ((int )*((ejctrl___1->out)->data + 3) == 1)) {
#line 422
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 428
  if (timeout == 0) {
    {
#line 430
    tmp___10 = register_get_string((tap_register const   *)ejctrl___1->out);
#line 430
    tmp___11 = gettext("%s(%d) Failed to enter debug mode, ctrl=%s\n");
#line 430
    printf((char const   */* __restrict  */)tmp___11, "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ejtag_dma.c",
           431, tmp___10);
    }
#line 433
    return (1);
  }
#line 437
  if (*((ejctrl___1->out)->data + 31)) {
    {
#line 438
    *((ejctrl___1->in)->data + 31) = (char)0;
#line 439
    chain_shift_data_registers(bus___0->chain, 0);
#line 440
    *((ejctrl___1->in)->data + 31) = (char)1;
#line 441
    chain_shift_data_registers(bus___0->chain, 1);
    }
  }
  {
#line 446
  tmp___12 = gettext("Clear memory protection bit in DCR\n");
#line 446
  printf((char const   */* __restrict  */)tmp___12);
#line 447
  tmp___13 = ejtag_dma_read(4281335808U, 8);
#line 447
  val = tmp___13;
#line 448
  ejtag_dma_write(4281335808U, val & (unsigned int )(~ (1 << 2)), 8);
#line 451
  tmp___14 = gettext("Clear Watchdog\n");
#line 451
  printf((char const   */* __restrict  */)tmp___14);
#line 452
  ejtag_dma_write(3087007872U, 0U, 8);
#line 454
  tmp___15 = ejtag_dma_read(4294840320U, 8);
#line 454
  tmp___16 = ejtag_dma_read(4294844416U, 8);
#line 454
  tmp___17 = gettext("Potential flash base address: [0x%x], [0x%x]\n");
#line 454
  printf((char const   */* __restrict  */)tmp___17, tmp___16, tmp___15);
#line 457
  tmp___18 = gettext("Processor successfully switched in debug mode.\n");
#line 457
  printf((char const   */* __restrict  */)tmp___18);
#line 459
  bus___0->initialized = 1;
  }
#line 460
  return (0);
}
}
#line 466 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ejtag_dma.c"
void ejtag_dma_bus_prepare(bus_t *bus___0 ) 
{ 


  {
#line 469
  if (! bus___0->initialized) {
    {
#line 470
    (*((bus___0->driver)->init))(bus___0);
    }
  }
#line 471
  return;
}
}
#line 477 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ejtag_dma.c"
int ejtag_dma_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area___0 ) 
{ 
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 482
  if (adr < 503316480U) {
#line 483
    area___0->description = "USEG : User addresses";
#line 484
    area___0->start = 0U;
#line 485
    area___0->length = 503316480ULL;
#line 486
    area___0->width = 32U;
  } else
#line 487
  if (adr < 536870912U) {
#line 488
    area___0->description = "FLASH : Addresses in flash (boot=0x1FC000000)";
#line 489
    area___0->start = 503316480U;
#line 490
    area___0->length = 33554432ULL;
#line 491
    area___0->width = 16U;
  } else
#line 492
  if (adr < 2147483648U) {
#line 493
    area___0->description = "USEG : User addresses";
#line 494
    area___0->start = 536870912U;
#line 495
    area___0->length = 1610612736ULL;
#line 496
    area___0->width = 32U;
  } else
#line 497
  if (adr < 2684354560U) {
#line 498
    area___0->description = "KSEG0: Kernel Unmapped Cached";
#line 499
    area___0->start = 2147483648U;
#line 500
    area___0->length = 536870912ULL;
#line 501
    area___0->width = 32U;
  } else
#line 502
  if (adr < 3221225472U) {
#line 503
    area___0->description = "KSEG1: Kernel Unmapped Uncached";
#line 504
    area___0->start = 2684354560U;
#line 505
    area___0->length = 536870912ULL;
#line 506
    area___0->width = 32U;
  } else
#line 507
  if (adr < 3758096384U) {
#line 508
    area___0->description = "SSEG : Supervisor Mapped";
#line 509
    area___0->start = 3221225472U;
#line 510
    area___0->length = 536870912ULL;
#line 511
    area___0->width = 32U;
  } else {
#line 513
    area___0->description = "KSEG3: Kernel Mapped";
#line 514
    area___0->start = 3758096384U;
#line 515
    area___0->length = 536870912ULL;
#line 516
    area___0->width = 32U;
  }
#line 518
  return (0);
}
}
#line 523 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ejtag_dma.c"
static bus_area_t area  ;
#line 524
int get_sz(uint32_t adr ) ;
#line 524 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ejtag_dma.c"
static int initialized  =    0;
#line 521 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ejtag_dma.c"
int get_sz(uint32_t adr ) 
{ 


  {
#line 526
  if (! initialized) {
    {
#line 527
    ejtag_dma_bus_area((bus_t *)((void *)0), adr, & area);
#line 528
    initialized = 1;
    }
  }
  {
#line 532
  if (area.width == 32U) {
#line 532
    goto case_32;
  }
#line 533
  if (area.width == 16U) {
#line 533
    goto case_16;
  }
#line 534
  goto switch_default;
  case_32: /* CIL Label */ 
#line 532
  return (8);
  case_16: /* CIL Label */ 
#line 533
  return (7);
  switch_default: /* CIL Label */ 
#line 534
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 536
  return (0);
}
}
#line 542 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ejtag_dma.c"
void ejtag_dma_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  int tmp ;

  {
  {
#line 545
  tmp = get_sz(adr);
#line 545
  ejtag_dma_write(adr, data, tmp);
  }
#line 546
  return;
}
}
#line 551 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ejtag_dma.c"
unsigned int ejtag_dma_bus_read(bus_t *bus___0 , uint32_t adr ) 
{ 
  int data ;
  int tmp ;
  unsigned int tmp___0 ;

  {
  {
#line 553
  tmp = get_sz(adr);
#line 553
  tmp___0 = ejtag_dma_read(adr, tmp);
#line 553
  data = (int )tmp___0;
  }
#line 555
  return ((unsigned int )data);
}
}
#line 558 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ejtag_dma.c"
static unsigned int _data_read  ;
#line 563 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ejtag_dma.c"
void ejtag_dma_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  int tmp ;

  {
  {
#line 565
  tmp = get_sz(adr);
#line 565
  _data_read = ejtag_dma_read(adr, tmp);
  }
#line 567
  return;
}
}
#line 573 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ejtag_dma.c"
unsigned int ejtag_dma_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  unsigned int tmp_value ;
  int tmp ;

  {
  {
#line 575
  tmp_value = _data_read;
#line 576
  tmp = get_sz(adr);
#line 576
  _data_read = ejtag_dma_read(adr, tmp);
  }
#line 578
  return (tmp_value);
}
}
#line 584 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ejtag_dma.c"
unsigned int ejtag_dma_bus_read_end(bus_t *bus___0 ) 
{ 


  {
#line 586
  return (_data_read);
}
}
#line 589 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ejtag_dma.c"
struct bus_driver  const  ejtag_dma_bus  = 
#line 589
     {"ejtag_dma", "EJTAG compatible bus driver via DMA", & ejtag_dma_bus_new, & generic_bus_free,
    & ejtag_dma_bus_printinfo, & ejtag_dma_bus_prepare, & ejtag_dma_bus_area, & ejtag_dma_bus_read_start,
    & ejtag_dma_bus_read_next, & ejtag_dma_bus_read_end, & ejtag_dma_bus_read, & ejtag_dma_bus_write,
    & ejtag_dma_bus_init};
#line 41 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/buses.h"
struct bus_driver  const  ejtag_bus ;
#line 115 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ejtag.c"
static bus_t *ejtag_bus_new(chain_t *chain , bus_driver_t const   *driver , char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  void *tmp ;

  {
  {
#line 120
  tmp = calloc((size_t )1, (size_t )sizeof(bus_t ));
#line 120
  bus___0 = (bus_t *)tmp;
  }
#line 121
  if (! bus___0) {
#line 122
    return ((bus_t *)((void *)0));
  }
  {
#line 124
  bus___0->driver = driver;
#line 125
  bus___0->params = calloc((size_t )1, (size_t )sizeof(bus_params_t___20 ));
  }
#line 126
  if (! bus___0->params) {
    {
#line 127
    free((void *)bus___0);
    }
#line 128
    return ((bus_t *)((void *)0));
  }
#line 131
  bus___0->chain = chain;
#line 132
  bus___0->part = *((chain->parts)->parts + chain->active_part);
#line 134
  return (bus___0);
}
}
#line 141 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ejtag.c"
static void ejtag_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;
  char *__cil_tmp4 ;

  {
#line 146
  i = 0;
  {
#line 146
  while (1) {
    while_continue: /* CIL Label */ ;
#line 146
    if (! (i < ((bus___0->chain)->parts)->len)) {
#line 146
      goto while_break;
    }
#line 147
    if ((unsigned long )bus___0->part == (unsigned long )*(((bus___0->chain)->parts)->parts + i)) {
#line 148
      goto while_break;
    }
#line 146
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 149
  tmp = gettext("EJTAG compatible bus driver via PrAcc (JTAG part No. %d)\n");
#line 149
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 150
  return;
}
}
#line 152 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ejtag.c"
static uint32_t reg_value___0(tap_register *reg ) 
{ 
  uint32_t retval ;
  int i ;

  {
#line 155
  retval = (uint32_t )0;
#line 158
  i = 0;
  {
#line 158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 158
    if (! (i < reg->len)) {
#line 158
      goto while_break;
    }
#line 159
    if (*(reg->data + i)) {
#line 160
      retval |= (unsigned int )(1 << i);
    }
#line 158
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 162
  return (retval);
}
}
#line 165 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ejtag.c"
static uint32_t ejtag_run_pracc(bus_t *bus___0 , uint32_t const   *code___0 , unsigned int len ) 
{ 
  data_register *ejaddr___1 ;
  data_register *ejdata___1 ;
  data_register *ejctrl___1 ;
  int i ;
  int pass ;
  uint32_t addr ;
  uint32_t data ;
  uint32_t retval ;
  char *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;

  {
  {
#line 172
  ejaddr___1 = part_find_data_register(bus___0->part, "EJADDRESS");
#line 173
  ejdata___1 = part_find_data_register(bus___0->part, "EJDATA");
#line 174
  ejctrl___1 = part_find_data_register(bus___0->part, "EJCONTROL");
  }
#line 175
  if (ejaddr___1) {
#line 175
    if (ejdata___1) {
#line 175
      if (! ejctrl___1) {
        {
#line 176
        tmp = gettext("%s(%d) EJADDRESS, EJDATA or EJCONTROL register not found\n");
#line 176
        printf((char const   */* __restrict  */)tmp, "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ejtag.c",
               177);
        }
#line 178
        return ((uint32_t )0);
      }
    } else {
      {
#line 176
      tmp = gettext("%s(%d) EJADDRESS, EJDATA or EJCONTROL register not found\n");
#line 176
      printf((char const   */* __restrict  */)tmp, "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ejtag.c",
             177);
      }
#line 178
      return ((uint32_t )0);
    }
  } else {
    {
#line 176
    tmp = gettext("%s(%d) EJADDRESS, EJDATA or EJCONTROL register not found\n");
#line 176
    printf((char const   */* __restrict  */)tmp, "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ejtag.c",
           177);
    }
#line 178
    return ((uint32_t )0);
  }
  {
#line 181
  part_set_instruction(bus___0->part, "EJTAG_CONTROL");
#line 182
  chain_shift_instructions(bus___0->chain);
#line 184
  pass = 0;
#line 185
  retval = (uint32_t )0;
  }
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 188
    *((ejctrl___1->in)->data + 18) = (char)1;
#line 189
    chain_shift_data_registers(bus___0->chain, 0);
#line 190
    chain_shift_data_registers(bus___0->chain, 1);
    }
#line 194
    if (*((ejctrl___1->out)->data + 31)) {
      {
#line 195
      tmp___0 = register_get_string((tap_register const   *)ejctrl___1->out);
#line 195
      tmp___1 = gettext("%s(%d) Reset occurred, ctrl=%s\n");
#line 195
      printf((char const   */* __restrict  */)tmp___1, "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ejtag.c",
             196, tmp___0);
#line 198
      bus___0->initialized = 0;
      }
#line 199
      goto while_break;
    }
#line 201
    if (! *((ejctrl___1->out)->data + 18)) {
      {
#line 202
      tmp___2 = register_get_string((tap_register const   *)ejctrl___1->out);
#line 202
      tmp___3 = gettext("%s(%d) No processor access, ctrl=%s\n");
#line 202
      printf((char const   */* __restrict  */)tmp___3, "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ejtag.c",
             203, tmp___2);
#line 205
      bus___0->initialized = 0;
      }
#line 206
      goto while_break;
    }
    {
#line 209
    part_set_instruction(bus___0->part, "EJTAG_ADDRESS");
#line 210
    chain_shift_instructions(bus___0->chain);
#line 212
    chain_shift_data_registers(bus___0->chain, 1);
#line 213
    addr = reg_value___0(ejaddr___1->out);
    }
#line 214
    if (addr & 3U) {
      {
#line 215
      tmp___4 = gettext("%s(%d) PrAcc bad alignment: addr=0x%08x\n");
#line 215
      printf((char const   */* __restrict  */)tmp___4, "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ejtag.c",
             216, addr);
#line 217
      addr &= 4294967292U;
      }
    }
    {
#line 220
    part_set_instruction(bus___0->part, "EJTAG_DATA");
#line 221
    chain_shift_instructions(bus___0->chain);
#line 223
    register_fill(ejdata___1->in, 0);
    }
#line 225
    if (*((ejctrl___1->out)->data + 19)) {
      {
#line 226
      chain_shift_data_registers(bus___0->chain, 1);
#line 227
      data = reg_value___0(ejdata___1->out);
      }
#line 232
      if (addr == 4280287232U) {
#line 234
        retval = data;
      } else {
        {
#line 236
        tmp___5 = gettext("%s(%d) Unknown write addr=0x%08x data=0x%08x\n");
#line 236
        printf((char const   */* __restrict  */)tmp___5, "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ejtag.c",
               237, addr, data);
        }
      }
    } else {
#line 240
      if (addr == 4280287744U) {
#line 240
        tmp___6 = pass;
#line 240
        pass ++;
#line 240
        if (tmp___6) {
#line 241
          goto while_break;
        }
      }
#line 243
      data = (uint32_t )0;
#line 244
      if (addr >= 4280287744U) {
#line 244
        if (addr < 4280287744U + (len << 2)) {
#line 245
          data = (uint32_t )*(code___0 + ((addr - 4280287744U) >> 2));
#line 247
          i = 0;
          {
#line 247
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 247
            if (! (i < 32)) {
#line 247
              goto while_break___0;
            }
#line 248
            *((ejdata___1->in)->data + i) = (char )((data >> i) & 1U);
#line 247
            i ++;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
      }
      {
#line 254
      chain_shift_data_registers(bus___0->chain, 0);
      }
    }
    {
#line 257
    part_set_instruction(bus___0->part, "EJTAG_CONTROL");
#line 258
    chain_shift_instructions(bus___0->chain);
#line 260
    *((ejctrl___1->in)->data + 18) = (char)0;
#line 261
    chain_shift_data_registers(bus___0->chain, 0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 263
  return (retval);
}
}
#line 266 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ejtag.c"
static int ejtag_bus_init(bus_t *bus___0 ) 
{ 
  data_register *ejctrl___1 ;
  data_register *ejimpl ;
  data_register *ejaddr___1 ;
  data_register *ejdata___1 ;
  data_register *ejall ;
  uint32_t code___0[4] ;
  int tmp ;
  char *tmp___0 ;
  uint32_t tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char *tmp___12 ;
  void *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;

  {
  {
#line 270
  code___0[0] = (uint32_t )1006960416;
#line 270
  code___0[1] = (uint32_t )882835968;
#line 270
  code___0[2] = (uint32_t )65011720;
#line 270
  code___0[3] = (uint32_t )1006829568;
#line 277
  tmp = tap_state(bus___0->chain);
  }
#line 277
  if (tmp != 1 << 3) {
#line 282
    return (0);
  }
  {
#line 285
  ejctrl___1 = part_find_data_register(bus___0->part, "EJCONTROL");
#line 286
  ejimpl = part_find_data_register(bus___0->part, "EJIMPCODE");
#line 287
  ejaddr___1 = part_find_data_register(bus___0->part, "EJADDRESS");
#line 288
  ejdata___1 = part_find_data_register(bus___0->part, "EJDATA");
#line 289
  ejall = part_find_data_register(bus___0->part, "EJALL");
  }
#line 290
  if (ejctrl___1) {
#line 290
    if (! ejimpl) {
      {
#line 291
      tmp___0 = gettext("%s(%d) EJCONTROL or EJIMPCODE register not found\n");
#line 291
      printf((char const   */* __restrict  */)tmp___0, "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ejtag.c",
             292);
      }
#line 293
      return (1);
    }
  } else {
    {
#line 291
    tmp___0 = gettext("%s(%d) EJCONTROL or EJIMPCODE register not found\n");
#line 291
    printf((char const   */* __restrict  */)tmp___0, "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ejtag.c",
           292);
    }
#line 293
    return (1);
  }
  {
#line 296
  part_set_instruction(bus___0->part, "EJTAG_IMPCODE");
#line 297
  chain_shift_instructions(bus___0->chain);
#line 298
  chain_shift_data_registers(bus___0->chain, 0);
#line 299
  chain_shift_data_registers(bus___0->chain, 1);
#line 300
  tmp___1 = reg_value___0(ejimpl->out);
#line 300
  tmp___2 = register_get_string((tap_register const   *)ejimpl->out);
#line 300
  printf((char const   */* __restrict  */)"ImpCode=%s %08X\n", tmp___2, tmp___1);
#line 301
  ((bus_params_t___20 *)bus___0->params)->impcode = reg_value___0(ejimpl->out);
  }
  {
#line 304
  if (((((bus_params_t___20 *)bus___0->params)->impcode >> 29) & 7U) == 0U) {
#line 304
    goto case_0;
  }
#line 305
  if (((((bus_params_t___20 *)bus___0->params)->impcode >> 29) & 7U) == 1U) {
#line 305
    goto case_1;
  }
#line 306
  if (((((bus_params_t___20 *)bus___0->params)->impcode >> 29) & 7U) == 2U) {
#line 306
    goto case_2;
  }
#line 307
  if (((((bus_params_t___20 *)bus___0->params)->impcode >> 29) & 7U) == 3U) {
#line 307
    goto case_3;
  }
#line 308
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 304
  printf((char const   */* __restrict  */)"EJTAG version: <= 2.0\n");
  }
#line 304
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 305
  printf((char const   */* __restrict  */)"EJTAG version: 2.5\n");
  }
#line 305
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 306
  printf((char const   */* __restrict  */)"EJTAG version: 2.6\n");
  }
#line 306
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 307
  printf((char const   */* __restrict  */)"EJTAG version: 3.1\n");
  }
#line 307
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 309
  printf((char const   */* __restrict  */)"EJTAG version: unknown (%d)\n", (((bus_params_t___20 *)bus___0->params)->impcode >> 29) & 7U);
  }
  switch_break: /* CIL Label */ ;
  }
#line 311
  if (((bus_params_t___20 *)bus___0->params)->impcode & 1U) {
#line 311
    tmp___3 = " MIPS64";
  } else {
#line 311
    tmp___3 = " MIPS32";
  }
#line 311
  if (((bus_params_t___20 *)bus___0->params)->impcode & (unsigned int )(1 << 14)) {
#line 311
    tmp___4 = " NoDMA";
  } else {
#line 311
    tmp___4 = " DMA";
  }
#line 311
  if (((bus_params_t___20 *)bus___0->params)->impcode & (unsigned int )(1 << 16)) {
#line 311
    tmp___5 = " MIPS16";
  } else {
#line 311
    tmp___5 = "";
  }
#line 311
  if (((bus_params_t___20 *)bus___0->params)->impcode & (unsigned int )(1 << 21)) {
#line 311
    tmp___6 = " ASID_6";
  } else {
#line 311
    tmp___6 = "";
  }
#line 311
  if (((bus_params_t___20 *)bus___0->params)->impcode & (unsigned int )(1 << 22)) {
#line 311
    tmp___7 = " ASID_8";
  } else {
#line 311
    tmp___7 = "";
  }
#line 311
  if (((bus_params_t___20 *)bus___0->params)->impcode & (unsigned int )(1 << 24)) {
#line 311
    tmp___8 = " DINTsup";
  } else {
#line 311
    tmp___8 = "";
  }
#line 311
  if (((bus_params_t___20 *)bus___0->params)->impcode & (unsigned int )(1 << 28)) {
#line 311
    tmp___9 = " R3k";
  } else {
#line 311
    tmp___9 = " R4k";
  }
  {
#line 311
  printf((char const   */* __restrict  */)"EJTAG Implementation flags:%s%s%s%s%s%s%s\n",
         tmp___9, tmp___8, tmp___7, tmp___6, tmp___5, tmp___4, tmp___3);
  }
#line 320
  if (((((bus_params_t___20 *)bus___0->params)->impcode >> 29) & 7U) >= 1U) {
    {
#line 321
    part_set_instruction(bus___0->part, "EJTAGBOOT");
#line 322
    chain_shift_instructions(bus___0->chain);
    }
  }
  {
#line 324
  part_set_instruction(bus___0->part, "EJTAG_CONTROL");
#line 325
  chain_shift_instructions(bus___0->chain);
#line 327
  register_fill(ejctrl___1->in, 0);
#line 328
  *((ejctrl___1->in)->data + 16) = (char)1;
#line 329
  *((ejctrl___1->in)->data + 20) = (char)1;
#line 330
  chain_shift_data_registers(bus___0->chain, 0);
#line 331
  *((ejctrl___1->in)->data + 16) = (char)0;
#line 332
  *((ejctrl___1->in)->data + 20) = (char)0;
#line 333
  chain_shift_data_registers(bus___0->chain, 0);
  }
#line 335
  if (((((bus_params_t___20 *)bus___0->params)->impcode >> 29) & 7U) == 0U) {
    {
#line 342
    part_set_instruction(bus___0->part, "EJTAG_ADDRESS");
#line 343
    chain_shift_instructions(bus___0->chain);
#line 345
    register_init(ejaddr___1->in, "11111111001100000000000000000000");
#line 347
    chain_shift_data_registers(bus___0->chain, 0);
#line 349
    part_set_instruction(bus___0->part, "EJTAG_CONTROL");
#line 350
    chain_shift_instructions(bus___0->chain);
#line 352
    register_fill(ejctrl___1->in, 0);
#line 353
    *((ejctrl___1->in)->data + 18) = (char)1;
#line 354
    *((ejctrl___1->in)->data + 17) = (char)1;
#line 355
    *((ejctrl___1->in)->data + 15) = (char)1;
#line 356
    *((ejctrl___1->in)->data + 11) = (char)1;
#line 357
    *((ejctrl___1->in)->data + 9) = (char)1;
#line 358
    *((ejctrl___1->in)->data + 8) = (char)1;
#line 359
    chain_shift_data_registers(bus___0->chain, 1);
    }
    {
#line 362
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 364
      part_set_instruction(bus___0->part, "EJTAG_CONTROL");
#line 365
      chain_shift_instructions(bus___0->chain);
#line 366
      register_fill(ejctrl___1->in, 0);
#line 368
      *((ejctrl___1->in)->data + 18) = (char)1;
#line 369
      *((ejctrl___1->in)->data + 17) = (char)1;
#line 370
      *((ejctrl___1->in)->data + 15) = (char)1;
#line 371
      chain_shift_data_registers(bus___0->chain, 1);
      }
#line 362
      if (! ((int )*((ejctrl___1->out)->data + 11) == 1)) {
#line 362
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 376
    part_set_instruction(bus___0->part, "EJTAG_DATA");
#line 377
    chain_shift_instructions(bus___0->chain);
#line 378
    register_fill(ejdata___1->in, 0);
#line 379
    chain_shift_data_registers(bus___0->chain, 1);
#line 383
    part_set_instruction(bus___0->part, "EJTAG_CONTROL");
#line 384
    chain_shift_instructions(bus___0->chain);
#line 385
    register_fill(ejctrl___1->in, 0);
#line 387
    *((ejctrl___1->in)->data + 18) = (char)1;
#line 388
    *((ejctrl___1->in)->data + 15) = (char)1;
#line 389
    chain_shift_data_registers(bus___0->chain, 1);
    }
#line 392
    if ((int )*((ejctrl___1->out)->data + 10) == 1) {
      {
#line 394
      printf((char const   */* __restrict  */)"DMA READ ERROR\n");
      }
    }
    {
#line 397
    tmp___10 = register_get_string((tap_register const   *)ejdata___1->out);
#line 397
    register_init(ejdata___1->in, tmp___10);
#line 398
    *((ejdata___1->in)->data + 2) = (char)0;
#line 404
    part_set_instruction(bus___0->part, "EJTAG_ADDRESS");
#line 405
    chain_shift_instructions(bus___0->chain);
#line 406
    register_init(ejaddr___1->in, "11111111001100000000000000000000");
#line 409
    chain_shift_data_registers(bus___0->chain, 0);
#line 411
    part_set_instruction(bus___0->part, "EJTAG_DATA");
#line 412
    chain_shift_instructions(bus___0->chain);
#line 415
    chain_shift_data_registers(bus___0->chain, 0);
#line 417
    part_set_instruction(bus___0->part, "EJTAG_CONTROL");
#line 418
    chain_shift_instructions(bus___0->chain);
#line 421
    register_fill(ejctrl___1->in, 0);
#line 422
    *((ejctrl___1->in)->data + 17) = (char)1;
#line 423
    *((ejctrl___1->in)->data + 8) = (char)1;
#line 424
    *((ejctrl___1->in)->data + 11) = (char)1;
#line 425
    *((ejctrl___1->in)->data + 15) = (char)1;
#line 426
    *((ejctrl___1->in)->data + 18) = (char)1;
#line 427
    chain_shift_data_registers(bus___0->chain, 1);
    }
    {
#line 430
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 433
      part_set_instruction(bus___0->part, "EJTAG_CONTROL");
#line 434
      chain_shift_instructions(bus___0->chain);
#line 435
      *((ejctrl___1->in)->data + 17) = (char)1;
#line 436
      *((ejctrl___1->in)->data + 15) = (char)1;
#line 437
      *((ejctrl___1->in)->data + 18) = (char)1;
#line 438
      chain_shift_data_registers(bus___0->chain, 1);
      }
#line 430
      if (! ((int )*((ejctrl___1->out)->data + 11) == 1)) {
#line 430
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 443
    part_set_instruction(bus___0->part, "EJTAG_CONTROL");
#line 444
    chain_shift_instructions(bus___0->chain);
#line 445
    register_fill(ejctrl___1->in, 0);
#line 447
    *((ejctrl___1->in)->data + 18) = (char)1;
#line 448
    *((ejctrl___1->in)->data + 15) = (char)1;
#line 449
    chain_shift_data_registers(bus___0->chain, 1);
    }
#line 452
    if ((int )*((ejctrl___1->out)->data + 10) == 1) {
      {
#line 454
      printf((char const   */* __restrict  */)"DMA WRITE ERROR\n");
      }
    }
  }
  {
#line 458
  part_set_instruction(bus___0->part, "EJTAG_CONTROL");
#line 459
  chain_shift_instructions(bus___0->chain);
#line 461
  register_fill(ejctrl___1->in, 0);
#line 462
  *((ejctrl___1->in)->data + 18) = (char)1;
#line 463
  *((ejctrl___1->in)->data + 15) = (char)1;
  }
#line 464
  if (((((bus_params_t___20 *)bus___0->params)->impcode >> 29) & 7U) >= 1U) {
#line 465
    *((ejctrl___1->in)->data + 14) = (char)1;
#line 466
    *((ejctrl___1->in)->data + 31) = (char)1;
  }
  {
#line 468
  chain_shift_data_registers(bus___0->chain, 0);
#line 470
  *((ejctrl___1->in)->data + 18) = (char)1;
#line 471
  *((ejctrl___1->in)->data + 15) = (char)1;
#line 472
  *((ejctrl___1->in)->data + 14) = (char)1;
#line 473
  *((ejctrl___1->in)->data + 12) = (char)1;
#line 475
  chain_shift_data_registers(bus___0->chain, 0);
#line 477
  *((ejctrl___1->in)->data + 12) = (char)0;
#line 478
  chain_shift_data_registers(bus___0->chain, 1);
  }
#line 480
  if (! *((ejctrl___1->out)->data + 3)) {
    {
#line 481
    tmp___11 = register_get_string((tap_register const   *)ejctrl___1->out);
#line 481
    tmp___12 = gettext("%s(%d) Failed to enter debug mode, ctrl=%s\n");
#line 481
    printf((char const   */* __restrict  */)tmp___12, "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ejtag.c",
           482, tmp___11);
    }
#line 484
    return (1);
  } else {
    {
#line 488
    printf((char const   */* __restrict  */)"Processor entered Debug Mode.\n");
    }
  }
#line 490
  if (*((ejctrl___1->out)->data + 31)) {
    {
#line 491
    *((ejctrl___1->in)->data + 31) = (char)0;
#line 492
    chain_shift_data_registers(bus___0->chain, 0);
#line 493
    *((ejctrl___1->in)->data + 31) = (char)1;
#line 494
    chain_shift_data_registers(bus___0->chain, 1);
    }
  }
  {
#line 500
  ejtag_run_pracc(bus___0, (uint32_t const   *)(code___0), 4U);
#line 501
  ((bus_params_t___20 *)bus___0->params)->adr_hi = (uint16_t )0;
#line 502
  bus___0->initialized = 1;
  }
#line 503
  return (0);
}
}
#line 510 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ejtag.c"
static void ejtag_bus_prepare(bus_t *bus___0 ) 
{ 


  {
#line 513
  if (! bus___0->initialized) {
    {
#line 514
    (*((bus___0->driver)->init))(bus___0);
    }
  }
#line 515
  return;
}
}
#line 521 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ejtag.c"
static int ejtag_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area___0 ) 
{ 


  {
#line 524
  if (adr < 536870912U) {
#line 525
    area___0->description = (char const   *)((void *)0);
#line 526
    area___0->start = 0U;
#line 527
    area___0->length = 536870912ULL;
#line 528
    area___0->width = 8U;
  } else
#line 529
  if (adr < 1073741824U) {
#line 530
    area___0->description = (char const   *)((void *)0);
#line 531
    area___0->start = 536870912U;
#line 532
    area___0->length = 536870912ULL;
#line 533
    area___0->width = 16U;
  } else
#line 534
  if (adr < 1610612736U) {
#line 535
    area___0->description = (char const   *)((void *)0);
#line 536
    area___0->start = 1073741824U;
#line 537
    area___0->length = 536870912ULL;
#line 538
    area___0->width = 32U;
  } else {
#line 540
    area___0->description = (char const   *)((void *)0);
#line 541
    area___0->start = 1610612736U;
#line 542
    area___0->length = 2684354560ULL;
#line 543
    area___0->width = 0U;
  }
#line 545
  return (0);
}
}
#line 548 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ejtag.c"
static int ejtag_gen_read(uint32_t *code___0 , uint32_t adr ) 
{ 
  uint16_t adr_hi ;
  uint16_t adr_lo ;
  uint32_t *p ;
  uint32_t *tmp ;
  uint32_t *tmp___0 ;
  uint32_t *tmp___1 ;
  uint32_t *tmp___2 ;
  uint32_t *tmp___3 ;
  uint32_t *tmp___4 ;

  {
#line 552
  p = code___0;
#line 555
  adr_lo = (uint16_t )(adr & 65535U);
#line 556
  adr_hi = (uint16_t )((adr >> 16) & 8191U);
#line 558
  adr_hi = (uint16_t )((int )adr_hi + ((int )adr_lo >> 15));
#line 560
  adr_hi = (uint16_t )((int )adr_hi + 40960);
#line 562
  if ((int )((bus_params_t___20 *)bus->params)->adr_hi != (int )adr_hi) {
#line 563
    ((bus_params_t___20 *)bus->params)->adr_hi = adr_hi;
#line 564
    tmp = p;
#line 564
    p ++;
#line 564
    *tmp = (uint32_t )(1006829568 | (int )adr_hi);
  }
  {
#line 567
  if (adr >> 29 == 0U) {
#line 567
    goto case_0;
  }
#line 570
  if (adr >> 29 == 1U) {
#line 570
    goto case_1;
  }
#line 573
  if (adr >> 29 == 2U) {
#line 573
    goto case_2;
  }
#line 576
  goto switch_default;
  case_0: /* CIL Label */ 
#line 568
  tmp___0 = p;
#line 568
  p ++;
#line 568
  *tmp___0 = 2422341632U | (unsigned int )adr_lo;
#line 569
  goto switch_break;
  case_1: /* CIL Label */ 
#line 571
  tmp___1 = p;
#line 571
  p ++;
#line 571
  *tmp___1 = 2489450496U | (unsigned int )((int )adr_lo & -2);
#line 572
  goto switch_break;
  case_2: /* CIL Label */ 
#line 574
  tmp___2 = p;
#line 574
  p ++;
#line 574
  *tmp___2 = 2355232768U | (unsigned int )((int )adr_lo & -4);
#line 575
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 577
  tmp___3 = p;
#line 577
  p ++;
#line 577
  *tmp___3 = (uint32_t )4133;
#line 578
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 580
  tmp___4 = p;
#line 580
  p ++;
#line 580
  *tmp___4 = (uint32_t )65011720;
#line 581
  return ((int )(p - code___0));
}
}
#line 588 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ejtag.c"
static void ejtag_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t code___0[3] ;
  int tmp ;
  void *__cil_tmp5 ;

  {
  {
#line 593
  tmp = ejtag_gen_read(code___0, adr);
#line 593
  ejtag_run_pracc(bus___0, (uint32_t const   *)(code___0), (unsigned int )tmp);
  }
#line 595
  return;
}
}
#line 601 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ejtag.c"
static uint32_t ejtag_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t d ;
  uint32_t code___0[4] ;
  uint32_t *p ;
  uint32_t *tmp ;
  int tmp___0 ;
  void *__cil_tmp8 ;

  {
  {
#line 605
  p = code___0;
#line 607
  tmp = p;
#line 607
  p ++;
#line 607
  *tmp = 2894200832U;
#line 608
  tmp___0 = ejtag_gen_read(p, adr);
#line 608
  p += tmp___0;
#line 610
  d = ejtag_run_pracc(bus___0, (uint32_t const   *)(code___0), (unsigned int )(p - code___0));
  }
#line 613
  return (d);
}
}
#line 624
static uint32_t ejtag_bus_read_end(bus_t *bus___0 ) ;
#line 624 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ejtag.c"
static uint32_t const   code[2]  = {      (uint32_t const   )2894200832U,      (uint32_t const   )65011720};
#line 620 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ejtag.c"
static uint32_t ejtag_bus_read_end(bus_t *bus___0 ) 
{ 
  uint32_t d ;

  {
  {
#line 629
  d = ejtag_run_pracc(bus___0, code, 2U);
  }
#line 632
  return (d);
}
}
#line 639 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ejtag.c"
static void ejtag_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  uint16_t adr_hi ;
  uint16_t adr_lo ;
  uint32_t code___0[5] ;
  uint32_t *p ;
  uint32_t *tmp ;
  uint32_t *tmp___0 ;
  uint32_t *tmp___1 ;
  uint32_t *tmp___2 ;
  uint32_t *tmp___3 ;
  uint32_t *tmp___4 ;
  uint32_t *tmp___5 ;
  uint32_t *tmp___6 ;
  uint32_t *tmp___7 ;
  void *__cil_tmp17 ;

  {
#line 643
  p = code___0;
#line 646
  adr_lo = (uint16_t )(adr & 65535U);
#line 647
  adr_hi = (uint16_t )((((adr >> 16) & 8191U) + (unsigned int )((int )adr_lo >> 15)) + 40960U);
#line 649
  if ((int )((bus_params_t___20 *)bus___0->params)->adr_hi != (int )adr_hi) {
#line 650
    ((bus_params_t___20 *)bus___0->params)->adr_hi = adr_hi;
#line 651
    tmp = p;
#line 651
    p ++;
#line 651
    *tmp = (uint32_t )(1006829568 | (int )adr_hi);
  }
  {
#line 654
  if (adr >> 29 == 0U) {
#line 654
    goto case_0;
  }
#line 658
  if (adr >> 29 == 1U) {
#line 658
    goto case_1;
  }
#line 662
  if (adr >> 29 == 2U) {
#line 662
    goto case_2;
  }
#line 653
  goto switch_break;
  case_0: /* CIL Label */ 
#line 655
  tmp___0 = p;
#line 655
  p ++;
#line 655
  *tmp___0 = 872546304U | (data & 255U);
#line 656
  tmp___1 = p;
#line 656
  p ++;
#line 656
  *tmp___1 = 2690777088U | (unsigned int )adr_lo;
#line 657
  goto switch_break;
  case_1: /* CIL Label */ 
#line 659
  tmp___2 = p;
#line 659
  p ++;
#line 659
  *tmp___2 = 872546304U | (data & 65535U);
#line 660
  tmp___3 = p;
#line 660
  p ++;
#line 660
  *tmp___3 = 2757885952U | (unsigned int )((int )adr_lo & -2);
#line 661
  goto switch_break;
  case_2: /* CIL Label */ 
#line 663
  tmp___4 = p;
#line 663
  p ++;
#line 663
  *tmp___4 = 1006764032U | (data >> 16);
#line 664
  tmp___5 = p;
#line 664
  p ++;
#line 664
  *tmp___5 = 876740608U | (data & 65535U);
#line 665
  tmp___6 = p;
#line 665
  p ++;
#line 665
  *tmp___6 = 2892103680U | (unsigned int )((int )adr_lo & -4);
#line 666
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 668
  tmp___7 = p;
#line 668
  p ++;
#line 668
  *tmp___7 = (uint32_t )65011720;
#line 670
  ejtag_run_pracc(bus___0, (uint32_t const   *)(code___0), (unsigned int )(p - code___0));
  }
#line 673
  return;
}
}
#line 675 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/ejtag.c"
struct bus_driver  const  ejtag_bus  = 
#line 675
     {"ejtag", "EJTAG compatible bus driver via PrAcc", & ejtag_bus_new, & generic_bus_free,
    & ejtag_bus_printinfo, & ejtag_bus_prepare, & ejtag_bus_area, & ejtag_bus_read_start,
    & ejtag_bus_read_next, & ejtag_bus_read_end, & generic_bus_read, & ejtag_bus_write,
    & ejtag_bus_init};
#line 38 "../../include/bus.h"
buses_t buses ;
#line 39
bus_driver_t const   *bus_drivers[37] ;
#line 41
void buses_free(void) ;
#line 42
void buses_add(bus_t *abus ) ;
#line 43
void buses_delete(bus_t *abus ) ;
#line 28 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/buses.h"
struct bus_driver  const  au1500_bus ;
#line 29
struct bus_driver  const  avr32_bus_driver ;
#line 30
struct bus_driver  const  bcm1250_bus ;
#line 31
struct bus_driver  const  bf526_ezkit_bus ;
#line 32
struct bus_driver  const  bf527_ezkit_bus ;
#line 33
struct bus_driver  const  bf533_stamp_bus ;
#line 34
struct bus_driver  const  bf533_ezkit_bus ;
#line 35
struct bus_driver  const  bf537_stamp_bus ;
#line 36
struct bus_driver  const  bf537_ezkit_bus ;
#line 37
struct bus_driver  const  bf538f_ezkit_bus ;
#line 38
struct bus_driver  const  bf548_ezkit_bus ;
#line 39
struct bus_driver  const  bf561_ezkit_bus ;
#line 40
struct bus_driver  const  bscoach_bus ;
#line 32 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/buses.c"
bus_driver_t const   *bus_drivers[37]  = 
#line 32 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/buses.c"
  {      & au1500_bus,      & avr32_bus_driver,      & bcm1250_bus,      & bf526_ezkit_bus, 
        & bf527_ezkit_bus,      & bf533_stamp_bus,      & bf533_ezkit_bus,      & bf537_stamp_bus, 
        & bf537_ezkit_bus,      & bf538f_ezkit_bus,      & bf548_ezkit_bus,      & bf561_ezkit_bus, 
        & bscoach_bus,      & ejtag_bus,      & ejtag_dma_bus,      & fjmem_bus, 
        & ixp425_bus,      & jopcyc_bus,      & h7202_bus,      & lh7a400_bus, 
        & mpc5200_bus,      & mpc824x_bus,      & ppc405ep_bus,      & ppc440gx_ebc8_bus, 
        & prototype_bus,      & pxa2x0_bus,      & pxa27x_bus,      & s3c4510_bus, 
        & sa1110_bus,      & sh7727_bus,      & sh7750r_bus,      & sh7751r_bus, 
        & sharc_21065L_bus,      & slsup3_bus,      & tx4925_bus,      & zefant_xs3_bus, 
        (bus_driver_t const   *)((void *)0)};
#line 142 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/buses.c"
bus_t *bus  =    (bus_t *)((void *)0);
#line 143 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/buses.c"
buses_t buses  =    {0, (bus_t **)((void *)0)};
#line 145 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/buses.c"
void buses_free(void) 
{ 
  int i ;

  {
#line 149
  i = 0;
  {
#line 149
  while (1) {
    while_continue: /* CIL Label */ ;
#line 149
    if (! (i < buses.len)) {
#line 149
      goto while_break;
    }
    {
#line 150
    (*(((*(buses.buses + i))->driver)->free_bus))(*(buses.buses + i));
#line 149
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 152
  free((void *)buses.buses);
#line 153
  buses.len = 0;
#line 154
  buses.buses = (bus_t **)((void *)0);
#line 155
  bus = (bus_t *)((void *)0);
  }
#line 156
  return;
}
}
#line 158 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/buses.c"
void buses_add(bus_t *abus ) 
{ 
  bus_t **b ;
  void *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp6 ;

  {
#line 162
  if ((unsigned long )abus == (unsigned long )((void *)0)) {
#line 163
    return;
  }
  {
#line 165
  tmp = realloc((void *)buses.buses, (size_t )((unsigned long )(buses.len + 1) * sizeof(bus_t *)));
#line 165
  b = (bus_t **)tmp;
  }
#line 166
  if ((unsigned long )b == (unsigned long )((void *)0)) {
    {
#line 167
    tmp___0 = gettext("Out of memory\n");
#line 167
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 168
    return;
  }
#line 170
  buses.buses = b;
#line 171
  tmp___1 = buses.len;
#line 171
  (buses.len) ++;
#line 171
  *(buses.buses + tmp___1) = abus;
#line 172
  if ((unsigned long )bus == (unsigned long )((void *)0)) {
#line 173
    bus = abus;
  }
#line 174
  return;
}
}
#line 176 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/buses.c"
void buses_delete(bus_t *abus ) 
{ 
  int i ;
  bus_t **b ;
  void *tmp ;

  {
#line 181
  i = 0;
  {
#line 181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 181
    if (! (i < buses.len)) {
#line 181
      goto while_break;
    }
#line 182
    if ((unsigned long )abus == (unsigned long )*(buses.buses + i)) {
#line 183
      goto while_break;
    }
#line 181
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 184
  if (i >= buses.len) {
#line 185
    return;
  }
  {
#line 187
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 187
    if (! (i + 1 < buses.len)) {
#line 187
      goto while_break___0;
    }
#line 188
    *(buses.buses + i) = *(buses.buses + (i + 1));
#line 189
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 191
  (buses.len) --;
#line 192
  tmp = realloc((void *)buses.buses, (size_t )((unsigned long )buses.len * sizeof(bus_t *)));
#line 192
  b = (bus_t **)tmp;
  }
#line 193
  if ((unsigned long )b != (unsigned long )((void *)0)) {
#line 194
    buses.buses = b;
  } else
#line 193
  if (buses.len == 0) {
#line 194
    buses.buses = b;
  }
#line 196
  if ((unsigned long )bus != (unsigned long )abus) {
#line 197
    return;
  }
#line 199
  if (buses.len > 0) {
#line 200
    bus = *(buses.buses + 0);
  }
#line 201
  return;
}
}
#line 68 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bscoach.c"
static bus_t *flashbscoach_bus_new(chain_t *chain , bus_driver_t const   *driver ,
                                   char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  part_t *part ;
  int failed ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;

  {
  {
#line 73
  failed = 0;
#line 75
  tmp = calloc((size_t )1, (size_t )sizeof(bus_t ));
#line 75
  bus___0 = (bus_t *)tmp;
  }
#line 76
  if (! bus___0) {
#line 77
    return ((bus_t *)((void *)0));
  }
  {
#line 79
  bus___0->driver = driver;
#line 80
  bus___0->params = calloc((size_t )1, (size_t )sizeof(bus_params_t___21 ));
  }
#line 81
  if (! bus___0->params) {
    {
#line 82
    free((void *)bus___0);
    }
#line 82
    return ((bus_t *)((void *)0));
  }
  {
#line 86
  bus___0->chain = chain;
#line 87
  part = *((chain->parts)->parts + chain->active_part);
#line 87
  bus___0->part = part;
#line 89
  tmp___0 = generic_bus_attach_sig(part, & ((bus_params_t___21 *)bus___0->params)->oe_f,
                                   (char *)"PB02_00");
#line 89
  failed |= tmp___0;
#line 90
  tmp___1 = generic_bus_attach_sig(part, & ((bus_params_t___21 *)bus___0->params)->we_f,
                                   (char *)"PB02_08");
#line 90
  failed |= tmp___1;
#line 92
  tmp___2 = generic_bus_attach_sig(part, & ((bus_params_t___21 *)bus___0->params)->deca,
                                   (char *)"PB02_04");
#line 92
  failed |= tmp___2;
#line 93
  tmp___3 = generic_bus_attach_sig(part, & ((bus_params_t___21 *)bus___0->params)->decb,
                                   (char *)"PB00_12");
#line 93
  failed |= tmp___3;
#line 94
  tmp___4 = generic_bus_attach_sig(part, & ((bus_params_t___21 *)bus___0->params)->decc,
                                   (char *)"PB02_07");
#line 94
  failed |= tmp___4;
#line 96
  tmp___5 = generic_bus_attach_sig(part, & ((bus_params_t___21 *)bus___0->params)->adr[0],
                                   (char *)"PB01_09");
#line 96
  failed |= tmp___5;
#line 97
  tmp___6 = generic_bus_attach_sig(part, & ((bus_params_t___21 *)bus___0->params)->adr[1],
                                   (char *)"PB01_06");
#line 97
  failed |= tmp___6;
#line 98
  tmp___7 = generic_bus_attach_sig(part, & ((bus_params_t___21 *)bus___0->params)->adr[2],
                                   (char *)"PB01_10");
#line 98
  failed |= tmp___7;
#line 99
  tmp___8 = generic_bus_attach_sig(part, & ((bus_params_t___21 *)bus___0->params)->adr[3],
                                   (char *)"PB01_11");
#line 99
  failed |= tmp___8;
#line 100
  tmp___9 = generic_bus_attach_sig(part, & ((bus_params_t___21 *)bus___0->params)->adr[4],
                                   (char *)"PB01_12");
#line 100
  failed |= tmp___9;
#line 101
  tmp___10 = generic_bus_attach_sig(part, & ((bus_params_t___21 *)bus___0->params)->adr[5],
                                    (char *)"PB01_13");
#line 101
  failed |= tmp___10;
#line 102
  tmp___11 = generic_bus_attach_sig(part, & ((bus_params_t___21 *)bus___0->params)->adr[6],
                                    (char *)"PB01_15");
#line 102
  failed |= tmp___11;
#line 103
  tmp___12 = generic_bus_attach_sig(part, & ((bus_params_t___21 *)bus___0->params)->adr[7],
                                    (char *)"PB01_14");
#line 103
  failed |= tmp___12;
#line 104
  tmp___13 = generic_bus_attach_sig(part, & ((bus_params_t___21 *)bus___0->params)->adr[8],
                                    (char *)"PB01_16");
#line 104
  failed |= tmp___13;
#line 105
  tmp___14 = generic_bus_attach_sig(part, & ((bus_params_t___21 *)bus___0->params)->adr[9],
                                    (char *)"PB00_01");
#line 105
  failed |= tmp___14;
#line 106
  tmp___15 = generic_bus_attach_sig(part, & ((bus_params_t___21 *)bus___0->params)->adr[10],
                                    (char *)"PB00_04");
#line 106
  failed |= tmp___15;
#line 107
  tmp___16 = generic_bus_attach_sig(part, & ((bus_params_t___21 *)bus___0->params)->adr[11],
                                    (char *)"PB00_05");
#line 107
  failed |= tmp___16;
#line 108
  tmp___17 = generic_bus_attach_sig(part, & ((bus_params_t___21 *)bus___0->params)->adr[12],
                                    (char *)"PB00_00");
#line 108
  failed |= tmp___17;
#line 109
  tmp___18 = generic_bus_attach_sig(part, & ((bus_params_t___21 *)bus___0->params)->adr[13],
                                    (char *)"PB00_07");
#line 109
  failed |= tmp___18;
#line 110
  tmp___19 = generic_bus_attach_sig(part, & ((bus_params_t___21 *)bus___0->params)->adr[14],
                                    (char *)"PB00_02");
#line 110
  failed |= tmp___19;
#line 112
  tmp___20 = generic_bus_attach_sig(part, & ((bus_params_t___21 *)bus___0->params)->d[0],
                                    (char *)"PB00_10");
#line 112
  failed |= tmp___20;
#line 113
  tmp___21 = generic_bus_attach_sig(part, & ((bus_params_t___21 *)bus___0->params)->d[1],
                                    (char *)"PB00_06");
#line 113
  failed |= tmp___21;
#line 114
  tmp___22 = generic_bus_attach_sig(part, & ((bus_params_t___21 *)bus___0->params)->d[2],
                                    (char *)"PB00_13");
#line 114
  failed |= tmp___22;
#line 115
  tmp___23 = generic_bus_attach_sig(part, & ((bus_params_t___21 *)bus___0->params)->d[3],
                                    (char *)"PB00_09");
#line 115
  failed |= tmp___23;
#line 116
  tmp___24 = generic_bus_attach_sig(part, & ((bus_params_t___21 *)bus___0->params)->d[4],
                                    (char *)"PB00_14");
#line 116
  failed |= tmp___24;
#line 117
  tmp___25 = generic_bus_attach_sig(part, & ((bus_params_t___21 *)bus___0->params)->d[5],
                                    (char *)"PB00_16");
#line 117
  failed |= tmp___25;
#line 118
  tmp___26 = generic_bus_attach_sig(part, & ((bus_params_t___21 *)bus___0->params)->d[6],
                                    (char *)"PB02_01");
#line 118
  failed |= tmp___26;
#line 119
  tmp___27 = generic_bus_attach_sig(part, & ((bus_params_t___21 *)bus___0->params)->d[7],
                                    (char *)"PB00_11");
#line 119
  failed |= tmp___27;
  }
#line 124
  if (failed) {
    {
#line 125
    free(bus___0->params);
#line 126
    free((void *)bus___0);
    }
#line 127
    return ((bus_t *)((void *)0));
  }
#line 131
  return (bus___0);
}
}
#line 138 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bscoach.c"
static void flashbscoach_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;
  char *__cil_tmp4 ;

  {
#line 143
  i = 0;
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    if (! (i < ((bus___0->chain)->parts)->len)) {
#line 143
      goto while_break;
    }
#line 144
    if ((unsigned long )bus___0->part == (unsigned long )*(((bus___0->chain)->parts)->parts + i)) {
#line 145
      goto while_break;
    }
#line 143
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 146
  tmp = gettext("Goepel electronic Boundary Scan Coach compatible bus driver via BSR (JTAG part No. %d)\n");
#line 146
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 147
  return;
}
}
#line 159 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bscoach.c"
static int flashbscoach_bus_init(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  int tmp ;
  char *__cil_tmp6 ;

  {
  {
#line 162
  p = bus___0->part;
#line 163
  chain = bus___0->chain;
#line 164
  i = 0;
#line 166
  tmp = tap_state(chain);
  }
#line 166
  if (tmp != 1 << 3) {
#line 171
    return (0);
  }
  {
#line 175
  part_set_instruction(p, "SAMPLE/PRELOAD");
#line 176
  chain_shift_instructions(chain);
#line 178
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->deca, 1, 1);
#line 179
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->decb, 1, 1);
#line 180
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->decc, 1, 1);
#line 181
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->oe_f, 1, 1);
#line 182
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->we_f, 1, 1);
#line 184
  i = 0;
  }
  {
#line 184
  while (1) {
    while_continue: /* CIL Label */ ;
#line 184
    if (! (i < 15)) {
#line 184
      goto while_break;
    }
    {
#line 185
    part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->adr[i], 1, 1);
#line 184
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 187
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->d[0], 1, 0);
#line 188
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->d[1], 1, 0);
#line 189
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->d[2], 1, 0);
#line 190
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->d[3], 1, 0);
#line 191
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->d[4], 1, 0);
#line 192
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->d[5], 1, 0);
#line 193
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->d[6], 1, 0);
#line 194
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->d[7], 1, 0);
#line 196
  chain_shift_data_registers(chain, 0);
#line 198
  bus___0->initialized = 1;
  }
#line 200
  return (0);
}
}
#line 208 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bscoach.c"
static int flashbscoach_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area___0 ) 
{ 


  {
#line 211
  area___0->description = (char const   *)((void *)0);
#line 212
  area___0->start = 0U;
#line 213
  area___0->length = 4294967296ULL;
#line 214
  area___0->width = 8U;
#line 218
  return (0);
}
}
#line 222 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bscoach.c"
static void setup_data___19(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area___0 ;

  {
  {
#line 226
  p = bus___0->part;
#line 229
  flashbscoach_bus_area(bus___0, (uint32_t )0, & area___0);
#line 233
  i = 0;
  }
  {
#line 233
  while (1) {
    while_continue: /* CIL Label */ ;
#line 233
    if (! ((unsigned int )i < area___0.width)) {
#line 233
      goto while_break;
    }
    {
#line 234
    part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->d[i], 1, (int )((d >> i) & 1U));
#line 233
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 235
  return;
}
}
#line 237 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bscoach.c"
static void set_data_in___18(bus_t *bus___0 ) 
{ 
  part_t *p ;
  bus_area_t area___0 ;

  {
  {
#line 241
  p = bus___0->part;
#line 244
  flashbscoach_bus_area(bus___0, (uint32_t )0, & area___0);
#line 246
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->d[0], 0, 0);
#line 247
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->d[1], 0, 0);
#line 248
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->d[2], 0, 0);
#line 249
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->d[3], 0, 0);
#line 250
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->d[4], 0, 0);
#line 251
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->d[5], 0, 0);
#line 252
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->d[6], 0, 0);
#line 253
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->d[7], 0, 0);
  }
#line 254
  return;
}
}
#line 255 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bscoach.c"
static void setup_address___19(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 259
  p = bus___0->part;
#line 261
  i = 0;
  {
#line 261
  while (1) {
    while_continue: /* CIL Label */ ;
#line 261
    if (! (i < 15)) {
#line 261
      goto while_break;
    }
    {
#line 262
    part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->adr[i], 1, (int )((a >> i) & 1U));
#line 261
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 263
  return;
}
}
#line 264 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bscoach.c"
static uint32_t get_data_out(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area___0 ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 268
  p = bus___0->part;
#line 270
  d = (uint32_t )0;
#line 272
  flashbscoach_bus_area(bus___0, (uint32_t )0, & area___0);
#line 274
  i = 0;
  }
  {
#line 274
  while (1) {
    while_continue: /* CIL Label */ ;
#line 274
    if (! ((unsigned int )i < area___0.width)) {
#line 274
      goto while_break;
    }
    {
#line 275
    tmp = part_get_signal(p, ((bus_params_t___21 *)bus___0->params)->d[i]);
#line 275
    d |= (uint32_t )(tmp << i);
#line 274
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 277
  return (d);
}
}
#line 283 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bscoach.c"
static void flashbscoach_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
  {
#line 286
  p = bus___0->part;
#line 287
  chain = bus___0->chain;
#line 289
  ((bus_params_t___21 *)bus___0->params)->last_adr = adr;
#line 291
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->deca, 1, 0);
#line 292
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->decb, 1, 1);
#line 293
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->decc, 1, 1);
#line 294
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->oe_f, 1, 0);
#line 295
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->we_f, 1, 1);
#line 297
  setup_address___19(bus___0, adr);
#line 298
  set_data_in___18(bus___0);
#line 300
  chain_shift_data_registers(chain, 0);
  }
#line 302
  return;
}
}
#line 308 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bscoach.c"
static uint32_t flashbscoach_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  chain_t *chain ;
  uint32_t tmp ;

  {
  {
#line 312
  chain = bus___0->chain;
#line 315
  setup_address___19(bus___0, adr);
#line 316
  chain_shift_data_registers(chain, 1);
#line 320
  tmp = get_data_out(bus___0);
  }
#line 320
  return (tmp);
}
}
#line 328 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bscoach.c"
static uint32_t flashbscoach_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain ;
  uint32_t tmp ;

  {
  {
#line 331
  p = bus___0->part;
#line 332
  chain = bus___0->chain;
#line 336
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->deca, 1, 1);
#line 337
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->decb, 1, 1);
#line 338
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->decc, 1, 1);
#line 339
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->oe_f, 1, 1);
#line 340
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->we_f, 1, 1);
#line 342
  chain_shift_data_registers(chain, 1);
#line 344
  tmp = get_data_out(bus___0);
  }
#line 344
  return (tmp);
}
}
#line 352 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bscoach.c"
static void flashbscoach_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
  {
#line 355
  p = bus___0->part;
#line 356
  chain = bus___0->chain;
#line 357
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->deca, 1, 0);
#line 358
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->decb, 1, 1);
#line 359
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->decc, 1, 1);
#line 360
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->oe_f, 1, 1);
#line 361
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->we_f, 1, 1);
#line 363
  setup_address___19(bus___0, adr);
#line 364
  setup_data___19(bus___0, data);
#line 366
  chain_shift_data_registers(chain, 0);
#line 368
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->we_f, 1, 0);
#line 369
  chain_shift_data_registers(chain, 0);
#line 371
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->deca, 1, 1);
#line 372
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->decb, 1, 1);
#line 373
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->decc, 1, 1);
#line 374
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->oe_f, 1, 1);
#line 375
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->we_f, 1, 1);
#line 377
  chain_shift_data_registers(chain, 0);
  }
#line 378
  return;
}
}
#line 380 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bscoach.c"
struct bus_driver  const  bscoach_bus  = 
#line 380
     {"flashbscoach", "Bustreiber f\303\274r Flashprogrammierung auf Goepel Boundary Scan Coach via BSR",
    & flashbscoach_bus_new, & generic_bus_free, & flashbscoach_bus_printinfo, & generic_bus_prepare_extest,
    & flashbscoach_bus_area, & flashbscoach_bus_read_start, & flashbscoach_bus_read_next,
    & flashbscoach_bus_read_end, & generic_bus_read, & flashbscoach_bus_write, & flashbscoach_bus_init};
#line 68 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf561_ezkit.c"
static bus_t *bf561_ezkit_bus_new(chain_t *chain , bus_driver_t const   *driver ,
                                  char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  part_t *part ;
  char buff[15] ;
  int i ;
  int failed ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  void *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
  {
#line 75
  failed = 0;
#line 77
  tmp = calloc((size_t )1, (size_t )sizeof(bus_t ));
#line 77
  bus___0 = (bus_t *)tmp;
  }
#line 78
  if (! bus___0) {
#line 79
    return ((bus_t *)((void *)0));
  }
  {
#line 81
  bus___0->driver = driver;
#line 82
  bus___0->params = calloc((size_t )1, (size_t )sizeof(bus_params_t___22 ));
  }
#line 83
  if (! bus___0->params) {
    {
#line 84
    free((void *)bus___0);
    }
#line 85
    return ((bus_t *)((void *)0));
  }
#line 88
  bus___0->chain = chain;
#line 89
  part = *((chain->parts)->parts + chain->active_part);
#line 89
  bus___0->part = part;
#line 91
  i = 0;
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
#line 91
    if (! (i < 4)) {
#line 91
      goto while_break;
    }
    {
#line 92
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"AMS_B%d",
            i);
#line 93
    tmp___0 = generic_bus_attach_sig(part, & ((bus_params_t___22 *)bus___0->params)->ams[i],
                                     buff);
#line 93
    failed |= tmp___0;
#line 91
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 96
  i = 0;
  {
#line 96
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 96
    if (! (i < 24)) {
#line 96
      goto while_break___0;
    }
    {
#line 97
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"ADDR%d",
            i + 2);
#line 98
    tmp___1 = generic_bus_attach_sig(part, & ((bus_params_t___22 *)bus___0->params)->addr[i],
                                     buff);
#line 98
    failed |= tmp___1;
#line 96
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 101
  i = 0;
  {
#line 101
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 101
    if (! (i < 4)) {
#line 101
      goto while_break___1;
    }
    {
#line 102
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"ABE_B%d",
            i);
#line 103
    tmp___2 = generic_bus_attach_sig(part, & ((bus_params_t___22 *)bus___0->params)->abe[i],
                                     buff);
#line 103
    failed |= tmp___2;
#line 101
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 106
  i = 0;
  {
#line 106
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 106
    if (! (i < 32)) {
#line 106
      goto while_break___2;
    }
    {
#line 107
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"DATA%d",
            i);
#line 108
    tmp___3 = generic_bus_attach_sig(part, & ((bus_params_t___22 *)bus___0->params)->data[i],
                                     buff);
#line 108
    failed |= tmp___3;
#line 106
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 111
  tmp___4 = generic_bus_attach_sig(part, & ((bus_params_t___22 *)bus___0->params)->awe,
                                   (char *)"AWE_B");
#line 111
  failed |= tmp___4;
#line 113
  tmp___5 = generic_bus_attach_sig(part, & ((bus_params_t___22 *)bus___0->params)->aoe,
                                   (char *)"AOE_B");
#line 113
  failed |= tmp___5;
#line 115
  tmp___6 = generic_bus_attach_sig(part, & ((bus_params_t___22 *)bus___0->params)->sras,
                                   (char *)"SRAS_B");
#line 115
  failed |= tmp___6;
#line 117
  tmp___7 = generic_bus_attach_sig(part, & ((bus_params_t___22 *)bus___0->params)->scas,
                                   (char *)"SCAS_B");
#line 117
  failed |= tmp___7;
#line 119
  tmp___8 = generic_bus_attach_sig(part, & ((bus_params_t___22 *)bus___0->params)->swe,
                                   (char *)"SWE_B");
#line 119
  failed |= tmp___8;
#line 121
  i = 0;
  }
  {
#line 121
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 121
    if (! (i < 4)) {
#line 121
      goto while_break___3;
    }
    {
#line 122
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"SMS_B%d",
            i);
#line 123
    tmp___9 = generic_bus_attach_sig(part, & ((bus_params_t___22 *)bus___0->params)->sms[i],
                                     buff);
#line 123
    failed |= tmp___9;
#line 121
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 126
  if (failed) {
    {
#line 127
    free(bus___0->params);
#line 128
    free((void *)bus___0);
    }
#line 129
    return ((bus_t *)((void *)0));
  }
#line 132
  return (bus___0);
}
}
#line 139 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf561_ezkit.c"
static void bf561_ezkit_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;
  char *__cil_tmp4 ;

  {
#line 144
  i = 0;
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
#line 144
    if (! (i < ((bus___0->chain)->parts)->len)) {
#line 144
      goto while_break;
    }
#line 145
    if ((unsigned long )bus___0->part == (unsigned long )*(((bus___0->chain)->parts)->parts + i)) {
#line 146
      goto while_break;
    }
#line 144
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 147
  tmp = gettext("Blackfin BF561 EZ-KIT compatible bus driver via BSR (JTAG part No. %d)\n");
#line 147
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 148
  return;
}
}
#line 154 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf561_ezkit.c"
static int bf561_ezkit_bus_area(bus_t *bus___0 , uint32_t addr , bus_area_t *area___0 ) 
{ 


  {
#line 157
  area___0->description = (char const   *)((void *)0);
#line 158
  area___0->start = 0U;
#line 159
  area___0->length = 4294967296ULL;
#line 160
  area___0->width = 16U;
#line 161
  return (0);
}
}
#line 164 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf561_ezkit.c"
static void select_flash___1(bus_t *bus___0 ) 
{ 
  part_t *p ;

  {
  {
#line 167
  p = bus___0->part;
#line 169
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->ams[0], 1, 0);
#line 170
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->ams[1], 1, 1);
#line 171
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->ams[2], 1, 1);
#line 172
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->ams[3], 1, 1);
#line 174
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->abe[0], 1, 0);
#line 175
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->abe[1], 1, 0);
#line 176
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->abe[2], 1, 0);
#line 177
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->abe[3], 1, 0);
#line 179
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->sras, 1, 1);
#line 180
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->scas, 1, 1);
#line 181
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->swe, 1, 1);
#line 182
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->sms[0], 1, 1);
#line 183
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->sms[1], 1, 1);
#line 184
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->sms[2], 1, 1);
#line 185
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->sms[3], 1, 1);
  }
#line 186
  return;
}
}
#line 188 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf561_ezkit.c"
static void unselect_flash___1(bus_t *bus___0 ) 
{ 
  part_t *p ;

  {
  {
#line 191
  p = bus___0->part;
#line 193
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->ams[0], 1, 1);
#line 194
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->ams[1], 1, 1);
#line 195
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->ams[2], 1, 1);
#line 196
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->ams[3], 1, 1);
#line 198
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->abe[0], 1, 1);
#line 199
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->abe[1], 1, 1);
#line 200
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->abe[2], 1, 1);
#line 201
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->abe[3], 1, 1);
#line 203
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->sras, 1, 1);
#line 204
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->scas, 1, 1);
#line 205
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->swe, 1, 1);
#line 206
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->sms[0], 1, 1);
#line 207
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->sms[1], 1, 1);
#line 208
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->sms[2], 1, 1);
#line 209
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->sms[3], 1, 1);
  }
#line 210
  return;
}
}
#line 212 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf561_ezkit.c"
static void setup_address___20(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 216
  p = bus___0->part;
#line 218
  i = 0;
  {
#line 218
  while (1) {
    while_continue: /* CIL Label */ ;
#line 218
    if (! (i < 24)) {
#line 218
      goto while_break;
    }
    {
#line 219
    part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->addr[i], 1, (int )((a >> (i + 2)) & 1U));
#line 218
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 220
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->abe[3], 1, (int )((a >> 1) & 1U));
  }
#line 221
  return;
}
}
#line 223 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf561_ezkit.c"
static void set_data_in___19(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;

  {
#line 227
  p = bus___0->part;
#line 229
  i = 0;
  {
#line 229
  while (1) {
    while_continue: /* CIL Label */ ;
#line 229
    if (! (i < 16)) {
#line 229
      goto while_break;
    }
    {
#line 230
    part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->data[i], 0, 0);
#line 229
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 231
  return;
}
}
#line 233 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf561_ezkit.c"
static void setup_data___20(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;

  {
#line 237
  p = bus___0->part;
#line 239
  i = 0;
  {
#line 239
  while (1) {
    while_continue: /* CIL Label */ ;
#line 239
    if (! (i < 16)) {
#line 239
      goto while_break;
    }
    {
#line 240
    part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->data[i], 1, (int )((d >> i) & 1U));
#line 239
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 242
  return;
}
}
#line 248 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf561_ezkit.c"
static void bf561_ezkit_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
  {
#line 251
  p = bus___0->part;
#line 252
  chain = bus___0->chain;
#line 254
  select_flash___1(bus___0);
#line 255
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->aoe, 1, 0);
#line 256
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->awe, 1, 1);
#line 258
  setup_address___20(bus___0, adr);
#line 259
  set_data_in___19(bus___0);
#line 261
  chain_shift_data_registers(chain, 0);
  }
#line 262
  return;
}
}
#line 268 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf561_ezkit.c"
static uint32_t bf561_ezkit_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 271
  p = bus___0->part;
#line 272
  chain = bus___0->chain;
#line 274
  d = (uint32_t )0;
#line 276
  setup_address___20(bus___0, adr);
#line 277
  chain_shift_data_registers(chain, 1);
#line 279
  i = 0;
  }
  {
#line 279
  while (1) {
    while_continue: /* CIL Label */ ;
#line 279
    if (! (i < 16)) {
#line 279
      goto while_break;
    }
    {
#line 280
    tmp = part_get_signal(p, ((bus_params_t___22 *)bus___0->params)->data[i]);
#line 280
    d |= (uint32_t )(tmp << i);
#line 279
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 282
  return (d);
}
}
#line 289 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf561_ezkit.c"
static uint32_t bf561_ezkit_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 292
  p = bus___0->part;
#line 293
  chain = bus___0->chain;
#line 295
  d = (uint32_t )0;
#line 297
  unselect_flash___1(bus___0);
#line 298
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->aoe, 1, 1);
#line 299
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->awe, 1, 1);
#line 301
  chain_shift_data_registers(chain, 1);
#line 303
  i = 0;
  }
  {
#line 303
  while (1) {
    while_continue: /* CIL Label */ ;
#line 303
    if (! (i < 16)) {
#line 303
      goto while_break;
    }
    {
#line 304
    tmp = part_get_signal(p, ((bus_params_t___22 *)bus___0->params)->data[i]);
#line 304
    d |= (uint32_t )(tmp << i);
#line 303
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 306
  return (d);
}
}
#line 313 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf561_ezkit.c"
static void bf561_ezkit_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
  {
#line 316
  p = bus___0->part;
#line 317
  chain = bus___0->chain;
#line 319
  select_flash___1(bus___0);
#line 320
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->aoe, 1, 1);
#line 322
  setup_address___20(bus___0, adr);
#line 323
  setup_data___20(bus___0, data);
#line 325
  chain_shift_data_registers(chain, 0);
#line 327
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->awe, 1, 0);
#line 328
  chain_shift_data_registers(chain, 0);
#line 329
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->awe, 1, 1);
#line 330
  unselect_flash___1(bus___0);
#line 331
  chain_shift_data_registers(chain, 0);
  }
#line 332
  return;
}
}
#line 334 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf561_ezkit.c"
struct bus_driver  const  bf561_ezkit_bus  = 
#line 334
     {"bf561_ezkit", "Blackfin BF561 EZ-KIT board bus driver", & bf561_ezkit_bus_new,
    & generic_bus_free, & bf561_ezkit_bus_printinfo, & generic_bus_prepare_extest,
    & bf561_ezkit_bus_area, & bf561_ezkit_bus_read_start, & bf561_ezkit_bus_read_next,
    & bf561_ezkit_bus_read_end, & generic_bus_read, & bf561_ezkit_bus_write, & generic_bus_no_init};
#line 63 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf548_ezkit.c"
static bus_t *bf548_ezkit_bus_new(chain_t *chain , bus_driver_t const   *driver ,
                                  char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  part_t *part ;
  char buff[15] ;
  int i ;
  int failed ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  void *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
  {
#line 70
  failed = 0;
#line 72
  tmp = calloc((size_t )1, (size_t )sizeof(bus_t ));
#line 72
  bus___0 = (bus_t *)tmp;
  }
#line 73
  if (! bus___0) {
#line 74
    return ((bus_t *)((void *)0));
  }
  {
#line 76
  bus___0->driver = driver;
#line 77
  bus___0->params = calloc((size_t )1, (size_t )sizeof(bus_params_t___23 ));
  }
#line 78
  if (! bus___0->params) {
    {
#line 79
    free((void *)bus___0);
    }
#line 80
    return ((bus_t *)((void *)0));
  }
#line 83
  bus___0->chain = chain;
#line 84
  part = *((chain->parts)->parts + chain->active_part);
#line 84
  bus___0->part = part;
#line 86
  i = 0;
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
#line 86
    if (! (i < 4)) {
#line 86
      goto while_break;
    }
    {
#line 87
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"AMS%dB",
            i);
#line 88
    tmp___0 = generic_bus_attach_sig(part, & ((bus_params_t___23 *)bus___0->params)->ams[i],
                                     buff);
#line 88
    failed |= tmp___0;
#line 86
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 91
  i = 0;
  {
#line 91
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 91
    if (! (i < 3)) {
#line 91
      goto while_break___0;
    }
    {
#line 92
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"ADDR%d",
            i + 1);
#line 93
    tmp___1 = generic_bus_attach_sig(part, & ((bus_params_t___23 *)bus___0->params)->addr[i],
                                     buff);
#line 93
    failed |= tmp___1;
#line 91
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 96
  i = 3;
  {
#line 96
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 96
    if (! (i < 9)) {
#line 96
      goto while_break___1;
    }
    {
#line 97
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"PORTH_%d",
            i + 5);
#line 98
    tmp___2 = generic_bus_attach_sig(part, & ((bus_params_t___23 *)bus___0->params)->addr[i],
                                     buff);
#line 98
    failed |= tmp___2;
#line 96
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 101
  i = 9;
  {
#line 101
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 101
    if (! (i < 24)) {
#line 101
      goto while_break___2;
    }
    {
#line 102
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"PORTI_%d",
            i - 9);
#line 103
    tmp___3 = generic_bus_attach_sig(part, & ((bus_params_t___23 *)bus___0->params)->addr[i],
                                     buff);
#line 103
    failed |= tmp___3;
#line 101
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 106
  i = 0;
  {
#line 106
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 106
    if (! (i < 16)) {
#line 106
      goto while_break___3;
    }
    {
#line 107
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"DATA%d",
            i);
#line 108
    tmp___4 = generic_bus_attach_sig(part, & ((bus_params_t___23 *)bus___0->params)->data[i],
                                     buff);
#line 108
    failed |= tmp___4;
#line 106
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 111
  tmp___5 = generic_bus_attach_sig(part, & ((bus_params_t___23 *)bus___0->params)->awe,
                                   (char *)"AWEB");
#line 111
  failed |= tmp___5;
#line 113
  tmp___6 = generic_bus_attach_sig(part, & ((bus_params_t___23 *)bus___0->params)->are,
                                   (char *)"AREB");
#line 113
  failed |= tmp___6;
#line 115
  tmp___7 = generic_bus_attach_sig(part, & ((bus_params_t___23 *)bus___0->params)->aoe,
                                   (char *)"AOEB");
#line 115
  failed |= tmp___7;
#line 117
  tmp___8 = generic_bus_attach_sig(part, & ((bus_params_t___23 *)bus___0->params)->dcs0,
                                   (char *)"CS0_B");
#line 117
  failed |= tmp___8;
#line 119
  tmp___9 = generic_bus_attach_sig(part, & ((bus_params_t___23 *)bus___0->params)->nce,
                                   (char *)"PORTJ_1");
#line 119
  failed |= tmp___9;
  }
#line 121
  if (failed) {
    {
#line 122
    free(bus___0->params);
#line 123
    free((void *)bus___0);
    }
#line 124
    return ((bus_t *)((void *)0));
  }
#line 127
  return (bus___0);
}
}
#line 134 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf548_ezkit.c"
static void bf548_ezkit_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;
  char *__cil_tmp4 ;

  {
#line 139
  i = 0;
  {
#line 139
  while (1) {
    while_continue: /* CIL Label */ ;
#line 139
    if (! (i < ((bus___0->chain)->parts)->len)) {
#line 139
      goto while_break;
    }
#line 140
    if ((unsigned long )bus___0->part == (unsigned long )*(((bus___0->chain)->parts)->parts + i)) {
#line 141
      goto while_break;
    }
#line 139
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 142
  tmp = gettext("Blackfin BF548 EZ-KIT compatible bus driver via BSR (JTAG part No. %d)\n");
#line 142
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 143
  return;
}
}
#line 149 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf548_ezkit.c"
static int bf548_ezkit_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area___0 ) 
{ 


  {
#line 152
  area___0->description = (char const   *)((void *)0);
#line 153
  area___0->start = 0U;
#line 154
  area___0->length = 4294967296ULL;
#line 155
  area___0->width = 16U;
#line 157
  return (0);
}
}
#line 160 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf548_ezkit.c"
static void select_flash___2(bus_t *bus___0 ) 
{ 
  part_t *p ;

  {
  {
#line 163
  p = bus___0->part;
#line 165
  part_set_signal(p, ((bus_params_t___23 *)bus___0->params)->ams[0], 1, 0);
#line 166
  part_set_signal(p, ((bus_params_t___23 *)bus___0->params)->ams[1], 1, 1);
#line 167
  part_set_signal(p, ((bus_params_t___23 *)bus___0->params)->ams[2], 1, 1);
#line 168
  part_set_signal(p, ((bus_params_t___23 *)bus___0->params)->ams[3], 1, 1);
#line 169
  part_set_signal(p, ((bus_params_t___23 *)bus___0->params)->dcs0, 1, 1);
#line 170
  part_set_signal(p, ((bus_params_t___23 *)bus___0->params)->nce, 1, 1);
  }
#line 171
  return;
}
}
#line 173 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf548_ezkit.c"
static void unselect_flash___2(bus_t *bus___0 ) 
{ 
  part_t *p ;

  {
  {
#line 176
  p = bus___0->part;
#line 178
  part_set_signal(p, ((bus_params_t___23 *)bus___0->params)->ams[0], 1, 1);
#line 179
  part_set_signal(p, ((bus_params_t___23 *)bus___0->params)->ams[1], 1, 1);
#line 180
  part_set_signal(p, ((bus_params_t___23 *)bus___0->params)->ams[2], 1, 1);
#line 181
  part_set_signal(p, ((bus_params_t___23 *)bus___0->params)->ams[3], 1, 1);
#line 182
  part_set_signal(p, ((bus_params_t___23 *)bus___0->params)->dcs0, 1, 1);
#line 183
  part_set_signal(p, ((bus_params_t___23 *)bus___0->params)->nce, 1, 1);
  }
#line 184
  return;
}
}
#line 186 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf548_ezkit.c"
static void setup_address___21(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 190
  p = bus___0->part;
#line 192
  i = 0;
  {
#line 192
  while (1) {
    while_continue: /* CIL Label */ ;
#line 192
    if (! (i < 24)) {
#line 192
      goto while_break;
    }
    {
#line 193
    part_set_signal(p, ((bus_params_t___23 *)bus___0->params)->addr[i], 1, (int )((a >> (i + 1)) & 1U));
#line 192
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 194
  return;
}
}
#line 196 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf548_ezkit.c"
static void set_data_in___20(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;

  {
#line 200
  p = bus___0->part;
#line 202
  i = 0;
  {
#line 202
  while (1) {
    while_continue: /* CIL Label */ ;
#line 202
    if (! (i < 16)) {
#line 202
      goto while_break;
    }
    {
#line 203
    part_set_signal(p, ((bus_params_t___23 *)bus___0->params)->data[i], 0, 0);
#line 202
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 204
  return;
}
}
#line 206 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf548_ezkit.c"
static void setup_data___21(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;

  {
#line 210
  p = bus___0->part;
#line 212
  i = 0;
  {
#line 212
  while (1) {
    while_continue: /* CIL Label */ ;
#line 212
    if (! (i < 16)) {
#line 212
      goto while_break;
    }
    {
#line 213
    part_set_signal(p, ((bus_params_t___23 *)bus___0->params)->data[i], 1, (int )((d >> i) & 1U));
#line 212
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 215
  return;
}
}
#line 221 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf548_ezkit.c"
static void bf548_ezkit_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
  {
#line 224
  p = bus___0->part;
#line 225
  chain = bus___0->chain;
#line 227
  select_flash___2(bus___0);
#line 228
  part_set_signal(p, ((bus_params_t___23 *)bus___0->params)->aoe, 1, 0);
#line 229
  part_set_signal(p, ((bus_params_t___23 *)bus___0->params)->are, 1, 0);
#line 230
  part_set_signal(p, ((bus_params_t___23 *)bus___0->params)->awe, 1, 1);
#line 232
  setup_address___21(bus___0, adr);
#line 233
  set_data_in___20(bus___0);
#line 235
  chain_shift_data_registers(chain, 0);
  }
#line 236
  return;
}
}
#line 242 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf548_ezkit.c"
static uint32_t bf548_ezkit_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 245
  p = bus___0->part;
#line 246
  chain = bus___0->chain;
#line 248
  d = (uint32_t )0;
#line 250
  setup_address___21(bus___0, adr);
#line 251
  chain_shift_data_registers(chain, 1);
#line 253
  i = 0;
  }
  {
#line 253
  while (1) {
    while_continue: /* CIL Label */ ;
#line 253
    if (! (i < 16)) {
#line 253
      goto while_break;
    }
    {
#line 254
    tmp = part_get_signal(p, ((bus_params_t___23 *)bus___0->params)->data[i]);
#line 254
    d |= (uint32_t )(tmp << i);
#line 253
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 256
  return (d);
}
}
#line 263 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf548_ezkit.c"
static uint32_t bf548_ezkit_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 266
  p = bus___0->part;
#line 267
  chain = bus___0->chain;
#line 269
  d = (uint32_t )0;
#line 271
  part_set_signal(p, ((bus_params_t___23 *)bus___0->params)->aoe, 1, 1);
#line 272
  part_set_signal(p, ((bus_params_t___23 *)bus___0->params)->are, 1, 1);
#line 273
  part_set_signal(p, ((bus_params_t___23 *)bus___0->params)->awe, 1, 1);
#line 274
  unselect_flash___2(bus___0);
#line 276
  chain_shift_data_registers(chain, 1);
#line 278
  i = 0;
  }
  {
#line 278
  while (1) {
    while_continue: /* CIL Label */ ;
#line 278
    if (! (i < 16)) {
#line 278
      goto while_break;
    }
    {
#line 279
    tmp = part_get_signal(p, ((bus_params_t___23 *)bus___0->params)->data[i]);
#line 279
    d |= (uint32_t )(tmp << i);
#line 278
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 281
  return (d);
}
}
#line 288 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf548_ezkit.c"
static void bf548_ezkit_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
  {
#line 291
  p = bus___0->part;
#line 292
  chain = bus___0->chain;
#line 294
  select_flash___2(bus___0);
#line 295
  part_set_signal(p, ((bus_params_t___23 *)bus___0->params)->aoe, 1, 0);
#line 296
  part_set_signal(p, ((bus_params_t___23 *)bus___0->params)->are, 1, 1);
#line 298
  setup_address___21(bus___0, adr);
#line 299
  setup_data___21(bus___0, data);
#line 301
  chain_shift_data_registers(chain, 0);
#line 303
  part_set_signal(p, ((bus_params_t___23 *)bus___0->params)->awe, 1, 0);
#line 304
  chain_shift_data_registers(chain, 0);
#line 305
  part_set_signal(p, ((bus_params_t___23 *)bus___0->params)->awe, 1, 1);
#line 306
  part_set_signal(p, ((bus_params_t___23 *)bus___0->params)->aoe, 1, 1);
#line 307
  unselect_flash___2(bus___0);
#line 308
  chain_shift_data_registers(chain, 0);
  }
#line 309
  return;
}
}
#line 311 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf548_ezkit.c"
struct bus_driver  const  bf548_ezkit_bus  = 
#line 311
     {"bf548_ezkit", "Blackfin BF548 EZ-KIT board bus driver", & bf548_ezkit_bus_new,
    & generic_bus_free, & bf548_ezkit_bus_printinfo, & generic_bus_prepare_extest,
    & bf548_ezkit_bus_area, & bf548_ezkit_bus_read_start, & bf548_ezkit_bus_read_next,
    & bf548_ezkit_bus_read_end, & generic_bus_read, & bf548_ezkit_bus_write, & generic_bus_no_init};
#line 68 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf537_stamp.c"
static bus_t *bf537_stamp_bus_new(chain_t *chain , bus_driver_t const   *driver ,
                                  char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  part_t *part ;
  char buff[15] ;
  int i ;
  int failed ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  void *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
  {
#line 75
  failed = 0;
#line 77
  tmp = calloc((size_t )1, (size_t )sizeof(bus_t ));
#line 77
  bus___0 = (bus_t *)tmp;
  }
#line 78
  if (! bus___0) {
#line 79
    return ((bus_t *)((void *)0));
  }
  {
#line 81
  bus___0->driver = driver;
#line 82
  bus___0->params = calloc((size_t )1, (size_t )sizeof(bus_params_t___24 ));
  }
#line 83
  if (! bus___0->params) {
    {
#line 84
    free((void *)bus___0);
    }
#line 85
    return ((bus_t *)((void *)0));
  }
#line 88
  bus___0->chain = chain;
#line 89
  part = *((chain->parts)->parts + chain->active_part);
#line 89
  bus___0->part = part;
#line 91
  i = 0;
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
#line 91
    if (! (i < 4)) {
#line 91
      goto while_break;
    }
    {
#line 92
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"AMS_B%d",
            i);
#line 93
    tmp___0 = generic_bus_attach_sig(part, & ((bus_params_t___24 *)bus___0->params)->ams[i],
                                     buff);
#line 93
    failed |= tmp___0;
#line 91
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 96
  i = 0;
  {
#line 96
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 96
    if (! (i < 19)) {
#line 96
      goto while_break___0;
    }
    {
#line 97
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"ADDR%d",
            i + 1);
#line 98
    tmp___1 = generic_bus_attach_sig(part, & ((bus_params_t___24 *)bus___0->params)->addr[i],
                                     buff);
#line 98
    failed |= tmp___1;
#line 96
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 101
  i = 0;
  {
#line 101
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 101
    if (! (i < 16)) {
#line 101
      goto while_break___1;
    }
    {
#line 102
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"DATA%d",
            i);
#line 103
    tmp___2 = generic_bus_attach_sig(part, & ((bus_params_t___24 *)bus___0->params)->data[i],
                                     buff);
#line 103
    failed |= tmp___2;
#line 101
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 106
  tmp___3 = generic_bus_attach_sig(part, & ((bus_params_t___24 *)bus___0->params)->awe,
                                   (char *)"AWE_B");
#line 106
  failed |= tmp___3;
#line 108
  tmp___4 = generic_bus_attach_sig(part, & ((bus_params_t___24 *)bus___0->params)->are,
                                   (char *)"ARE_B");
#line 108
  failed |= tmp___4;
#line 110
  tmp___5 = generic_bus_attach_sig(part, & ((bus_params_t___24 *)bus___0->params)->abe[0],
                                   (char *)"ABE_B0");
#line 110
  failed |= tmp___5;
#line 112
  tmp___6 = generic_bus_attach_sig(part, & ((bus_params_t___24 *)bus___0->params)->abe[1],
                                   (char *)"ABE_B1");
#line 112
  failed |= tmp___6;
#line 114
  tmp___7 = generic_bus_attach_sig(part, & ((bus_params_t___24 *)bus___0->params)->sras,
                                   (char *)"SRAS_B");
#line 114
  failed |= tmp___7;
#line 116
  tmp___8 = generic_bus_attach_sig(part, & ((bus_params_t___24 *)bus___0->params)->scas,
                                   (char *)"SCAS_B");
#line 116
  failed |= tmp___8;
#line 118
  tmp___9 = generic_bus_attach_sig(part, & ((bus_params_t___24 *)bus___0->params)->swe,
                                   (char *)"SWE_B");
#line 118
  failed |= tmp___9;
#line 120
  tmp___10 = generic_bus_attach_sig(part, & ((bus_params_t___24 *)bus___0->params)->sms,
                                    (char *)"SMS_B");
#line 120
  failed |= tmp___10;
  }
#line 122
  if (failed) {
    {
#line 123
    free(bus___0->params);
#line 124
    free((void *)bus___0);
    }
#line 125
    return ((bus_t *)((void *)0));
  }
#line 128
  return (bus___0);
}
}
#line 135 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf537_stamp.c"
static int bf537_stamp_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area___0 ) 
{ 


  {
#line 138
  area___0->description = (char const   *)((void *)0);
#line 139
  area___0->start = 0U;
#line 140
  area___0->length = 4294967296ULL;
#line 141
  area___0->width = 16U;
#line 143
  return (0);
}
}
#line 146 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf537_stamp.c"
static void select_flash___3(bus_t *bus___0 ) 
{ 
  part_t *p ;

  {
  {
#line 149
  p = bus___0->part;
#line 151
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->ams[0], 1, 0);
#line 152
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->ams[1], 1, 1);
#line 153
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->ams[2], 1, 1);
#line 154
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->ams[3], 1, 1);
#line 156
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->abe[0], 1, 0);
#line 157
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->abe[1], 1, 0);
#line 159
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->sras, 1, 1);
#line 160
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->scas, 1, 1);
#line 161
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->swe, 1, 1);
#line 162
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->sms, 1, 1);
  }
#line 163
  return;
}
}
#line 165 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf537_stamp.c"
static void unselect_flash___3(bus_t *bus___0 ) 
{ 
  part_t *p ;

  {
  {
#line 168
  p = bus___0->part;
#line 170
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->ams[0], 1, 1);
#line 171
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->ams[1], 1, 1);
#line 172
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->ams[2], 1, 1);
#line 173
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->ams[3], 1, 1);
#line 175
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->abe[0], 1, 1);
#line 176
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->abe[1], 1, 1);
#line 178
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->sras, 1, 1);
#line 179
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->scas, 1, 1);
#line 180
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->swe, 1, 1);
#line 181
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->sms, 1, 1);
  }
#line 182
  return;
}
}
#line 184 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf537_stamp.c"
static void setup_address___22(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 188
  p = bus___0->part;
#line 190
  i = 0;
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;
#line 190
    if (! (i < 19)) {
#line 190
      goto while_break;
    }
    {
#line 191
    part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->addr[i], 1, (int )((a >> (i + 1)) & 1U));
#line 190
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 192
  return;
}
}
#line 194 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf537_stamp.c"
static void set_data_in___21(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;

  {
#line 198
  p = bus___0->part;
#line 200
  i = 0;
  {
#line 200
  while (1) {
    while_continue: /* CIL Label */ ;
#line 200
    if (! (i < 16)) {
#line 200
      goto while_break;
    }
    {
#line 201
    part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->data[i], 0, 0);
#line 200
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 202
  return;
}
}
#line 204 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf537_stamp.c"
static void setup_data___22(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;

  {
#line 208
  p = bus___0->part;
#line 210
  i = 0;
  {
#line 210
  while (1) {
    while_continue: /* CIL Label */ ;
#line 210
    if (! (i < 16)) {
#line 210
      goto while_break;
    }
    {
#line 211
    part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->data[i], 1, (int )((d >> i) & 1U));
#line 210
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 213
  return;
}
}
#line 219 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf537_stamp.c"
static void bf537_stamp_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
  {
#line 222
  p = bus___0->part;
#line 223
  chain = bus___0->chain;
#line 225
  select_flash___3(bus___0);
#line 226
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->are, 1, 0);
#line 227
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->awe, 1, 1);
#line 229
  setup_address___22(bus___0, adr);
#line 230
  set_data_in___21(bus___0);
#line 232
  chain_shift_data_registers(chain, 0);
  }
#line 233
  return;
}
}
#line 239 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf537_stamp.c"
static uint32_t bf537_stamp_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 242
  p = bus___0->part;
#line 243
  chain = bus___0->chain;
#line 245
  d = (uint32_t )0;
#line 247
  setup_address___22(bus___0, adr);
#line 248
  chain_shift_data_registers(chain, 1);
#line 250
  i = 0;
  }
  {
#line 250
  while (1) {
    while_continue: /* CIL Label */ ;
#line 250
    if (! (i < 16)) {
#line 250
      goto while_break;
    }
    {
#line 251
    tmp = part_get_signal(p, ((bus_params_t___24 *)bus___0->params)->data[i]);
#line 251
    d |= (uint32_t )(tmp << i);
#line 250
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 253
  return (d);
}
}
#line 260 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf537_stamp.c"
static uint32_t bf537_stamp_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 263
  p = bus___0->part;
#line 264
  chain = bus___0->chain;
#line 266
  d = (uint32_t )0;
#line 268
  unselect_flash___3(bus___0);
#line 269
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->are, 1, 1);
#line 270
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->awe, 1, 1);
#line 272
  chain_shift_data_registers(chain, 1);
#line 274
  i = 0;
  }
  {
#line 274
  while (1) {
    while_continue: /* CIL Label */ ;
#line 274
    if (! (i < 16)) {
#line 274
      goto while_break;
    }
    {
#line 275
    tmp = part_get_signal(p, ((bus_params_t___24 *)bus___0->params)->data[i]);
#line 275
    d |= (uint32_t )(tmp << i);
#line 274
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 277
  return (d);
}
}
#line 284 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf537_stamp.c"
static void bf537_stamp_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
  {
#line 287
  p = bus___0->part;
#line 288
  chain = bus___0->chain;
#line 290
  select_flash___3(bus___0);
#line 291
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->are, 1, 1);
#line 293
  setup_address___22(bus___0, adr);
#line 294
  setup_data___22(bus___0, data);
#line 296
  chain_shift_data_registers(chain, 0);
#line 298
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->awe, 1, 0);
#line 299
  chain_shift_data_registers(chain, 0);
#line 300
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->awe, 1, 1);
#line 301
  unselect_flash___3(bus___0);
#line 302
  chain_shift_data_registers(chain, 0);
  }
#line 303
  return;
}
}
#line 309 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf537_stamp.c"
static void bf537_stamp_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;
  char *__cil_tmp4 ;

  {
#line 314
  i = 0;
  {
#line 314
  while (1) {
    while_continue: /* CIL Label */ ;
#line 314
    if (! (i < ((bus___0->chain)->parts)->len)) {
#line 314
      goto while_break;
    }
#line 315
    if ((unsigned long )bus___0->part == (unsigned long )*(((bus___0->chain)->parts)->parts + i)) {
#line 316
      goto while_break;
    }
#line 314
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 317
  tmp = gettext("%s (JTAG part No. %d)\n");
#line 317
  printf((char const   */* __restrict  */)tmp, (bus___0->driver)->description, i);
  }
#line 318
  return;
}
}
#line 335 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf537_stamp.c"
struct bus_driver  const  bf537_stamp_bus  = 
#line 335
     {"bf537_stamp", "Blackfin BF537 Stamp board bus driver via BSR", & bf537_stamp_bus_new,
    & generic_bus_free, & bf537_stamp_bus_printinfo, & generic_bus_prepare_extest,
    & bf537_stamp_bus_area, & bf537_stamp_bus_read_start, & bf537_stamp_bus_read_next,
    & bf537_stamp_bus_read_end, & generic_bus_read, & bf537_stamp_bus_write, & generic_bus_no_init};
#line 345 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf537_stamp.c"
struct bus_driver  const  bf537_ezkit_bus  = 
#line 345
     {"bf537_ezkit", "Blackfin BF537 EZ-KIT board bus driver via BSR", & bf537_stamp_bus_new,
    & generic_bus_free, & bf537_stamp_bus_printinfo, & generic_bus_prepare_extest,
    & bf537_stamp_bus_area, & bf537_stamp_bus_read_start, & bf537_stamp_bus_read_next,
    & bf537_stamp_bus_read_end, & generic_bus_read, & bf537_stamp_bus_write, & generic_bus_no_init};
#line 355 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf537_stamp.c"
struct bus_driver  const  bf527_ezkit_bus  = 
#line 355
     {"bf527_ezkit", "Blackfin BF527 EZ-KIT board bus driver via BSR", & bf537_stamp_bus_new,
    & generic_bus_free, & bf537_stamp_bus_printinfo, & generic_bus_prepare_extest,
    & bf537_stamp_bus_area, & bf537_stamp_bus_read_start, & bf537_stamp_bus_read_next,
    & bf537_stamp_bus_read_end, & generic_bus_read, & bf537_stamp_bus_write, & generic_bus_no_init};
#line 365 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf537_stamp.c"
struct bus_driver  const  bf538f_ezkit_bus  = 
#line 365
     {"bf538f_ezkit", "Blackfin BF538F EZ-KIT board bus driver", & bf537_stamp_bus_new,
    & generic_bus_free, & bf537_stamp_bus_printinfo, & generic_bus_prepare_extest,
    & bf537_stamp_bus_area, & bf537_stamp_bus_read_start, & bf537_stamp_bus_read_next,
    & bf537_stamp_bus_read_end, & generic_bus_read, & bf537_stamp_bus_write, & generic_bus_no_init};
#line 375 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf537_stamp.c"
struct bus_driver  const  bf526_ezkit_bus  = 
#line 375
     {"bf526_ezkit", "Blackfin BF526 EZ-KIT board bus driver", & bf537_stamp_bus_new,
    & generic_bus_free, & bf537_stamp_bus_printinfo, & generic_bus_prepare_extest,
    & bf537_stamp_bus_area, & bf537_stamp_bus_read_start, & bf537_stamp_bus_read_next,
    & bf537_stamp_bus_read_end, & generic_bus_read, & bf537_stamp_bus_write, & generic_bus_no_init};
#line 68 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf533_stamp.c"
static bus_t *bf533_stamp_bus_new(chain_t *chain , bus_driver_t const   *driver ,
                                  char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  part_t *part ;
  char buff[15] ;
  int i ;
  int failed ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  void *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
  {
#line 75
  failed = 0;
#line 77
  tmp = calloc((size_t )1, (size_t )sizeof(bus_t ));
#line 77
  bus___0 = (bus_t *)tmp;
  }
#line 78
  if (! bus___0) {
#line 79
    return ((bus_t *)((void *)0));
  }
  {
#line 81
  bus___0->driver = driver;
#line 82
  bus___0->params = calloc((size_t )1, (size_t )sizeof(bus_params_t___24 ));
  }
#line 83
  if (! bus___0->params) {
    {
#line 84
    free((void *)bus___0);
    }
#line 85
    return ((bus_t *)((void *)0));
  }
#line 88
  bus___0->chain = chain;
#line 89
  part = *((chain->parts)->parts + chain->active_part);
#line 89
  bus___0->part = part;
#line 91
  i = 0;
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
#line 91
    if (! (i < 2)) {
#line 91
      goto while_break;
    }
    {
#line 92
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"PF%d",
            i);
#line 93
    tmp___0 = generic_bus_attach_sig(part, & ((bus_params_t___24 *)bus___0->params)->abe[i],
                                     buff);
#line 93
    failed |= tmp___0;
#line 91
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 96
  i = 0;
  {
#line 96
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 96
    if (! (i < 4)) {
#line 96
      goto while_break___0;
    }
    {
#line 97
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"AMS_B%d",
            i);
#line 98
    tmp___1 = generic_bus_attach_sig(part, & ((bus_params_t___24 *)bus___0->params)->ams[i],
                                     buff);
#line 98
    failed |= tmp___1;
#line 96
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 101
  i = 0;
  {
#line 101
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 101
    if (! (i < 19)) {
#line 101
      goto while_break___1;
    }
    {
#line 102
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"ADDR[%d]",
            i + 1);
#line 103
    tmp___2 = generic_bus_attach_sig(part, & ((bus_params_t___24 *)bus___0->params)->addr[i],
                                     buff);
#line 103
    failed |= tmp___2;
#line 101
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 106
  i = 0;
  {
#line 106
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 106
    if (! (i < 16)) {
#line 106
      goto while_break___2;
    }
    {
#line 107
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"DATA[%d]",
            i);
#line 108
    tmp___3 = generic_bus_attach_sig(part, & ((bus_params_t___24 *)bus___0->params)->data[i],
                                     buff);
#line 108
    failed |= tmp___3;
#line 106
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 111
  tmp___4 = generic_bus_attach_sig(part, & ((bus_params_t___24 *)bus___0->params)->awe,
                                   (char *)"AWE_B");
#line 111
  failed |= tmp___4;
#line 113
  tmp___5 = generic_bus_attach_sig(part, & ((bus_params_t___24 *)bus___0->params)->are,
                                   (char *)"AOE_B");
#line 113
  failed |= tmp___5;
#line 115
  tmp___6 = generic_bus_attach_sig(part, & ((bus_params_t___24 *)bus___0->params)->sras,
                                   (char *)"SRAS_B");
#line 115
  failed |= tmp___6;
#line 117
  tmp___7 = generic_bus_attach_sig(part, & ((bus_params_t___24 *)bus___0->params)->scas,
                                   (char *)"SCAS_B");
#line 117
  failed |= tmp___7;
#line 119
  tmp___8 = generic_bus_attach_sig(part, & ((bus_params_t___24 *)bus___0->params)->swe,
                                   (char *)"SWE_B");
#line 119
  failed |= tmp___8;
#line 121
  tmp___9 = generic_bus_attach_sig(part, & ((bus_params_t___24 *)bus___0->params)->sms,
                                   (char *)"SMS_B");
#line 121
  failed |= tmp___9;
  }
#line 123
  if (failed) {
    {
#line 124
    free(bus___0->params);
#line 125
    free((void *)bus___0);
    }
#line 126
    return ((bus_t *)((void *)0));
  }
#line 129
  return (bus___0);
}
}
#line 136 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf533_stamp.c"
static void bf533_stamp_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;
  char *__cil_tmp4 ;

  {
#line 141
  i = 0;
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 141
    if (! (i < ((bus___0->chain)->parts)->len)) {
#line 141
      goto while_break;
    }
#line 142
    if ((unsigned long )bus___0->part == (unsigned long )*(((bus___0->chain)->parts)->parts + i)) {
#line 143
      goto while_break;
    }
#line 141
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 144
  tmp = gettext("Blackfin BF533 compatible bus driver via BSR (JTAG part No. %d)\n");
#line 144
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 145
  return;
}
}
#line 151 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf533_stamp.c"
static int bf533_stamp_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area___0 ) 
{ 


  {
#line 154
  area___0->description = (char const   *)((void *)0);
#line 155
  area___0->start = 0U;
#line 156
  area___0->length = 4294967296ULL;
#line 157
  area___0->width = 16U;
#line 159
  return (0);
}
}
#line 162 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf533_stamp.c"
static void select_flash___4(bus_t *bus___0 ) 
{ 
  part_t *p ;

  {
  {
#line 165
  p = bus___0->part;
#line 167
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->abe[0], 1, 0);
#line 168
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->abe[1], 1, 0);
#line 170
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->ams[0], 1, 0);
#line 171
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->ams[1], 1, 1);
#line 172
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->ams[2], 1, 1);
#line 173
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->ams[3], 1, 1);
#line 175
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->sras, 1, 1);
#line 176
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->scas, 1, 1);
#line 177
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->swe, 1, 1);
#line 178
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->sms, 1, 1);
  }
#line 179
  return;
}
}
#line 181 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf533_stamp.c"
static void unselect_flash___4(bus_t *bus___0 ) 
{ 
  part_t *p ;

  {
  {
#line 184
  p = bus___0->part;
#line 186
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->abe[0], 1, 0);
#line 187
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->abe[1], 1, 0);
#line 189
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->ams[0], 1, 1);
#line 190
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->ams[1], 1, 1);
#line 191
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->ams[2], 1, 1);
#line 192
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->ams[3], 1, 1);
#line 194
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->sras, 1, 1);
#line 195
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->scas, 1, 1);
#line 196
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->swe, 1, 1);
#line 197
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->sms, 1, 1);
  }
#line 198
  return;
}
}
#line 200 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf533_stamp.c"
static void setup_address___23(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 204
  p = bus___0->part;
#line 206
  i = 0;
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 206
    if (! (i < 19)) {
#line 206
      goto while_break;
    }
    {
#line 207
    part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->addr[i], 1, (int )((a >> (i + 1)) & 1U));
#line 206
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 208
  return;
}
}
#line 210 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf533_stamp.c"
static void set_data_in___22(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;

  {
#line 214
  p = bus___0->part;
#line 216
  i = 0;
  {
#line 216
  while (1) {
    while_continue: /* CIL Label */ ;
#line 216
    if (! (i < 16)) {
#line 216
      goto while_break;
    }
    {
#line 217
    part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->data[i], 0, 0);
#line 216
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 218
  return;
}
}
#line 220 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf533_stamp.c"
static void setup_data___23(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;

  {
#line 224
  p = bus___0->part;
#line 226
  i = 0;
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
#line 226
    if (! (i < 16)) {
#line 226
      goto while_break;
    }
    {
#line 227
    part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->data[i], 1, (int )((d >> i) & 1U));
#line 226
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 229
  return;
}
}
#line 235 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf533_stamp.c"
static void bf533_stamp_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
  {
#line 238
  p = bus___0->part;
#line 239
  chain = bus___0->chain;
#line 241
  select_flash___4(bus___0);
#line 242
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->are, 1, 0);
#line 243
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->awe, 1, 1);
#line 245
  setup_address___23(bus___0, adr);
#line 246
  set_data_in___22(bus___0);
#line 248
  chain_shift_data_registers(chain, 0);
  }
#line 249
  return;
}
}
#line 255 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf533_stamp.c"
static uint32_t bf533_stamp_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 258
  p = bus___0->part;
#line 259
  chain = bus___0->chain;
#line 261
  d = (uint32_t )0;
#line 263
  setup_address___23(bus___0, adr);
#line 264
  chain_shift_data_registers(chain, 1);
#line 266
  i = 0;
  }
  {
#line 266
  while (1) {
    while_continue: /* CIL Label */ ;
#line 266
    if (! (i < 16)) {
#line 266
      goto while_break;
    }
    {
#line 267
    tmp = part_get_signal(p, ((bus_params_t___24 *)bus___0->params)->data[i]);
#line 267
    d |= (uint32_t )(tmp << i);
#line 266
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 269
  return (d);
}
}
#line 276 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf533_stamp.c"
static uint32_t bf533_stamp_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 279
  p = bus___0->part;
#line 280
  chain = bus___0->chain;
#line 282
  d = (uint32_t )0;
#line 284
  unselect_flash___4(bus___0);
#line 285
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->are, 1, 1);
#line 286
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->awe, 1, 1);
#line 288
  chain_shift_data_registers(chain, 1);
#line 290
  i = 0;
  }
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
#line 290
    if (! (i < 16)) {
#line 290
      goto while_break;
    }
    {
#line 291
    tmp = part_get_signal(p, ((bus_params_t___24 *)bus___0->params)->data[i]);
#line 291
    d |= (uint32_t )(tmp << i);
#line 290
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 293
  return (d);
}
}
#line 300 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf533_stamp.c"
static void bf533_stamp_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
  {
#line 303
  p = bus___0->part;
#line 304
  chain = bus___0->chain;
#line 308
  select_flash___4(bus___0);
#line 309
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->are, 1, 1);
#line 311
  setup_address___23(bus___0, adr);
#line 312
  setup_data___23(bus___0, data);
#line 314
  chain_shift_data_registers(chain, 0);
#line 316
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->awe, 1, 0);
#line 317
  chain_shift_data_registers(chain, 0);
#line 318
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->awe, 1, 1);
#line 319
  unselect_flash___4(bus___0);
#line 320
  chain_shift_data_registers(chain, 0);
  }
#line 321
  return;
}
}
#line 323 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf533_stamp.c"
struct bus_driver  const  bf533_stamp_bus  = 
#line 323
     {"bf533_stamp", "Blackfin BF533 Stamp board bus driver", & bf533_stamp_bus_new,
    & generic_bus_free, & bf533_stamp_bus_printinfo, & generic_bus_prepare_extest,
    & bf533_stamp_bus_area, & bf533_stamp_bus_read_start, & bf533_stamp_bus_read_next,
    & bf533_stamp_bus_read_end, & generic_bus_read, & bf533_stamp_bus_write, & generic_bus_no_init};
#line 68 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf533_ezkit.c"
static bus_t *bf533_ezkit_bus_new(chain_t *chain , bus_driver_t const   *driver ,
                                  char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  part_t *part ;
  char buff[15] ;
  int i ;
  int failed ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  void *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
  {
#line 75
  failed = 0;
#line 77
  tmp = calloc((size_t )1, (size_t )sizeof(bus_t ));
#line 77
  bus___0 = (bus_t *)tmp;
  }
#line 78
  if (! bus___0) {
#line 79
    return ((bus_t *)((void *)0));
  }
  {
#line 81
  bus___0->driver = driver;
#line 82
  bus___0->params = calloc((size_t )1, (size_t )sizeof(bus_params_t___24 ));
  }
#line 83
  if (! bus___0->params) {
    {
#line 84
    free((void *)bus___0);
    }
#line 85
    return ((bus_t *)((void *)0));
  }
#line 88
  bus___0->chain = chain;
#line 89
  part = *((chain->parts)->parts + chain->active_part);
#line 89
  bus___0->part = part;
#line 91
  i = 0;
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
#line 91
    if (! (i < 4)) {
#line 91
      goto while_break;
    }
    {
#line 92
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"AMS_B%d",
            i);
#line 93
    tmp___0 = generic_bus_attach_sig(part, & ((bus_params_t___24 *)bus___0->params)->ams[i],
                                     buff);
#line 93
    failed |= tmp___0;
#line 91
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 96
  i = 0;
  {
#line 96
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 96
    if (! (i < 19)) {
#line 96
      goto while_break___0;
    }
    {
#line 97
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"ADDR[%d]",
            i + 1);
#line 98
    tmp___1 = generic_bus_attach_sig(part, & ((bus_params_t___24 *)bus___0->params)->addr[i],
                                     buff);
#line 98
    failed |= tmp___1;
#line 96
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 101
  i = 0;
  {
#line 101
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 101
    if (! (i < 16)) {
#line 101
      goto while_break___1;
    }
    {
#line 102
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"DATA[%d]",
            i);
#line 103
    tmp___2 = generic_bus_attach_sig(part, & ((bus_params_t___24 *)bus___0->params)->data[i],
                                     buff);
#line 103
    failed |= tmp___2;
#line 101
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 106
  tmp___3 = generic_bus_attach_sig(part, & ((bus_params_t___24 *)bus___0->params)->awe,
                                   (char *)"AWE_B");
#line 106
  failed |= tmp___3;
#line 108
  tmp___4 = generic_bus_attach_sig(part, & ((bus_params_t___24 *)bus___0->params)->are,
                                   (char *)"AOE_B");
#line 108
  failed |= tmp___4;
#line 110
  tmp___5 = generic_bus_attach_sig(part, & ((bus_params_t___24 *)bus___0->params)->abe[0],
                                   (char *)"ABE_B0");
#line 110
  failed |= tmp___5;
#line 112
  tmp___6 = generic_bus_attach_sig(part, & ((bus_params_t___24 *)bus___0->params)->abe[1],
                                   (char *)"ABE_B1");
#line 112
  failed |= tmp___6;
#line 114
  tmp___7 = generic_bus_attach_sig(part, & ((bus_params_t___24 *)bus___0->params)->sras,
                                   (char *)"SRAS_B");
#line 114
  failed |= tmp___7;
#line 116
  tmp___8 = generic_bus_attach_sig(part, & ((bus_params_t___24 *)bus___0->params)->scas,
                                   (char *)"SCAS_B");
#line 116
  failed |= tmp___8;
#line 118
  tmp___9 = generic_bus_attach_sig(part, & ((bus_params_t___24 *)bus___0->params)->swe,
                                   (char *)"SWE_B");
#line 118
  failed |= tmp___9;
#line 120
  tmp___10 = generic_bus_attach_sig(part, & ((bus_params_t___24 *)bus___0->params)->sms,
                                    (char *)"SMS_B");
#line 120
  failed |= tmp___10;
  }
#line 122
  if (failed) {
    {
#line 123
    free(bus___0->params);
#line 124
    free((void *)bus___0);
    }
#line 125
    return ((bus_t *)((void *)0));
  }
#line 128
  return (bus___0);
}
}
#line 135 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf533_ezkit.c"
static void bf533_ezkit_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;
  char *__cil_tmp4 ;

  {
#line 140
  i = 0;
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 140
    if (! (i < ((bus___0->chain)->parts)->len)) {
#line 140
      goto while_break;
    }
#line 141
    if ((unsigned long )bus___0->part == (unsigned long )*(((bus___0->chain)->parts)->parts + i)) {
#line 142
      goto while_break;
    }
#line 140
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 143
  tmp = gettext("Blackfin BF533 EZKit compatible bus driver via BSR (JTAG part No. %d)\n");
#line 143
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 144
  return;
}
}
#line 150 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf533_ezkit.c"
static int bf533_ezkit_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area___0 ) 
{ 


  {
#line 153
  area___0->description = (char const   *)((void *)0);
#line 154
  area___0->start = 0U;
#line 155
  area___0->length = 4294967296ULL;
#line 156
  area___0->width = 16U;
#line 158
  return (0);
}
}
#line 161 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf533_ezkit.c"
static void select_flash___5(bus_t *bus___0 ) 
{ 
  part_t *p ;

  {
  {
#line 164
  p = bus___0->part;
#line 166
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->ams[0], 1, 0);
#line 167
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->ams[1], 1, 1);
#line 168
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->ams[2], 1, 1);
#line 169
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->ams[3], 1, 1);
#line 171
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->abe[0], 1, 0);
#line 172
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->abe[1], 1, 0);
#line 174
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->sras, 1, 1);
#line 175
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->scas, 1, 1);
#line 176
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->swe, 1, 1);
#line 177
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->sms, 1, 1);
  }
#line 178
  return;
}
}
#line 180 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf533_ezkit.c"
static void unselect_flash___5(bus_t *bus___0 ) 
{ 
  part_t *p ;

  {
  {
#line 183
  p = bus___0->part;
#line 185
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->ams[0], 1, 1);
#line 186
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->ams[1], 1, 1);
#line 187
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->ams[2], 1, 1);
#line 188
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->ams[3], 1, 1);
#line 190
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->abe[0], 1, 1);
#line 191
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->abe[1], 1, 1);
#line 193
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->sras, 1, 1);
#line 194
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->scas, 1, 1);
#line 195
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->swe, 1, 1);
#line 196
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->sms, 1, 1);
  }
#line 197
  return;
}
}
#line 199 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf533_ezkit.c"
static void setup_address___24(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 203
  p = bus___0->part;
#line 205
  i = 0;
  {
#line 205
  while (1) {
    while_continue: /* CIL Label */ ;
#line 205
    if (! (i < 19)) {
#line 205
      goto while_break;
    }
    {
#line 206
    part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->addr[i], 1, (int )((a >> (i + 1)) & 1U));
#line 205
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 207
  return;
}
}
#line 209 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf533_ezkit.c"
static void set_data_in___23(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;

  {
#line 213
  p = bus___0->part;
#line 215
  i = 0;
  {
#line 215
  while (1) {
    while_continue: /* CIL Label */ ;
#line 215
    if (! (i < 16)) {
#line 215
      goto while_break;
    }
    {
#line 216
    part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->data[i], 0, 0);
#line 215
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 217
  return;
}
}
#line 219 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf533_ezkit.c"
static void setup_data___24(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;

  {
#line 223
  p = bus___0->part;
#line 225
  i = 0;
  {
#line 225
  while (1) {
    while_continue: /* CIL Label */ ;
#line 225
    if (! (i < 16)) {
#line 225
      goto while_break;
    }
    {
#line 226
    part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->data[i], 1, (int )((d >> i) & 1U));
#line 225
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 228
  return;
}
}
#line 234 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf533_ezkit.c"
static void bf533_ezkit_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
  {
#line 237
  p = bus___0->part;
#line 238
  chain = bus___0->chain;
#line 240
  select_flash___5(bus___0);
#line 241
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->are, 1, 0);
#line 242
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->awe, 1, 1);
#line 244
  setup_address___24(bus___0, adr);
#line 245
  set_data_in___23(bus___0);
#line 247
  chain_shift_data_registers(chain, 0);
  }
#line 248
  return;
}
}
#line 254 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf533_ezkit.c"
static uint32_t bf533_ezkit_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 257
  p = bus___0->part;
#line 258
  chain = bus___0->chain;
#line 260
  d = (uint32_t )0;
#line 262
  setup_address___24(bus___0, adr);
#line 263
  chain_shift_data_registers(chain, 1);
#line 265
  i = 0;
  }
  {
#line 265
  while (1) {
    while_continue: /* CIL Label */ ;
#line 265
    if (! (i < 16)) {
#line 265
      goto while_break;
    }
    {
#line 266
    tmp = part_get_signal(p, ((bus_params_t___24 *)bus___0->params)->data[i]);
#line 266
    d |= (uint32_t )(tmp << i);
#line 265
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 268
  return (d);
}
}
#line 275 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf533_ezkit.c"
static uint32_t bf533_ezkit_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 278
  p = bus___0->part;
#line 279
  chain = bus___0->chain;
#line 281
  d = (uint32_t )0;
#line 283
  unselect_flash___5(bus___0);
#line 284
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->are, 1, 1);
#line 285
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->awe, 1, 1);
#line 287
  chain_shift_data_registers(chain, 1);
#line 289
  i = 0;
  }
  {
#line 289
  while (1) {
    while_continue: /* CIL Label */ ;
#line 289
    if (! (i < 16)) {
#line 289
      goto while_break;
    }
    {
#line 290
    tmp = part_get_signal(p, ((bus_params_t___24 *)bus___0->params)->data[i]);
#line 290
    d |= (uint32_t )(tmp << i);
#line 289
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 292
  return (d);
}
}
#line 299 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf533_ezkit.c"
static void bf533_ezkit_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
  {
#line 302
  p = bus___0->part;
#line 303
  chain = bus___0->chain;
#line 307
  select_flash___5(bus___0);
#line 308
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->are, 1, 1);
#line 310
  setup_address___24(bus___0, adr);
#line 311
  setup_data___24(bus___0, data);
#line 313
  chain_shift_data_registers(chain, 0);
#line 315
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->awe, 1, 0);
#line 316
  chain_shift_data_registers(chain, 0);
#line 317
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->awe, 1, 1);
#line 318
  unselect_flash___5(bus___0);
#line 319
  chain_shift_data_registers(chain, 0);
  }
#line 320
  return;
}
}
#line 322 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bf533_ezkit.c"
struct bus_driver  const  bf533_ezkit_bus  = 
#line 322
     {"bf533_ezkit", "Blackfin BF533 EZKit board bus driver", & bf533_ezkit_bus_new,
    & generic_bus_free, & bf533_ezkit_bus_printinfo, & generic_bus_prepare_extest,
    & bf533_ezkit_bus_area, & bf533_ezkit_bus_read_start, & bf533_ezkit_bus_read_next,
    & bf533_ezkit_bus_read_end, & generic_bus_read, & bf533_ezkit_bus_write, & generic_bus_no_init};
#line 60 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bcm1250.c"
static bus_t *bcm1250_bus_new(chain_t *chain , bus_driver_t const   *driver , char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  part_t *part ;
  char buff[10] ;
  int i ;
  int failed ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
  {
#line 67
  failed = 0;
#line 69
  tmp = calloc((size_t )1, (size_t )sizeof(bus_t ));
#line 69
  bus___0 = (bus_t *)tmp;
  }
#line 70
  if (! bus___0) {
#line 71
    return ((bus_t *)((void *)0));
  }
  {
#line 73
  bus___0->driver = driver;
#line 74
  bus___0->params = calloc((size_t )1, (size_t )sizeof(bus_params_t___10 ));
  }
#line 75
  if (! bus___0->params) {
    {
#line 76
    free((void *)bus___0);
    }
#line 77
    return ((bus_t *)((void *)0));
  }
#line 80
  bus___0->chain = chain;
#line 81
  part = *((chain->parts)->parts + chain->active_part);
#line 81
  bus___0->part = part;
#line 83
  i = 0;
  {
#line 83
  while (1) {
    while_continue: /* CIL Label */ ;
#line 83
    if (! (i < 32)) {
#line 83
      goto while_break;
    }
    {
#line 84
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"IO_AD%d",
            i);
#line 85
    tmp___0 = generic_bus_attach_sig(part, & ((bus_params_t___10 *)bus___0->params)->a[i],
                                     buff);
#line 85
    failed |= tmp___0;
#line 83
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 88
  i = 0;
  {
#line 88
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 88
    if (! (i < 8)) {
#line 88
      goto while_break___0;
    }
    {
#line 89
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"IO_CS_L%d",
            i);
#line 90
    tmp___1 = generic_bus_attach_sig(part, & ((bus_params_t___10 *)bus___0->params)->d[i],
                                     buff);
#line 90
    failed |= tmp___1;
#line 88
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 93
  tmp___2 = generic_bus_attach_sig(part, & ((bus_params_t___10 *)bus___0->params)->ncs,
                                   (char *)"IO_RW");
#line 93
  failed |= tmp___2;
#line 95
  tmp___3 = generic_bus_attach_sig(part, & ((bus_params_t___10 *)bus___0->params)->nwe,
                                   (char *)"IO_WR_L");
#line 95
  failed |= tmp___3;
#line 97
  tmp___4 = generic_bus_attach_sig(part, & ((bus_params_t___10 *)bus___0->params)->noe,
                                   (char *)"IO_OE_L");
#line 97
  failed |= tmp___4;
  }
#line 99
  if (failed) {
    {
#line 100
    free(bus___0->params);
#line 101
    free((void *)bus___0);
    }
#line 102
    return ((bus_t *)((void *)0));
  }
#line 105
  return (bus___0);
}
}
#line 112 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bcm1250.c"
static void bcm1250_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;
  char *__cil_tmp4 ;

  {
#line 117
  i = 0;
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! (i < ((bus___0->chain)->parts)->len)) {
#line 117
      goto while_break;
    }
#line 118
    if ((unsigned long )bus___0->part == (unsigned long )*(((bus___0->chain)->parts)->parts + i)) {
#line 119
      goto while_break;
    }
#line 117
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 120
  tmp = gettext("Broadcom BCM1250 compatible bus driver via BSR (JTAG part No. %d)\n");
#line 120
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 121
  return;
}
}
#line 127 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bcm1250.c"
static int bcm1250_bus_area(bus_t *bus___0 , uint32_t addr , bus_area_t *area___0 ) 
{ 


  {
#line 130
  area___0->description = (char const   *)((void *)0);
#line 131
  area___0->start = 0U;
#line 132
  area___0->length = 4294967296ULL;
#line 133
  area___0->width = 8U;
#line 135
  return (0);
}
}
#line 140 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bcm1250.c"
static void setup_address___25(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 144
  p = bus___0->part;
#line 146
  i = 0;
  {
#line 146
  while (1) {
    while_continue: /* CIL Label */ ;
#line 146
    if (! (i < 24)) {
#line 146
      goto while_break;
    }
    {
#line 147
    part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->a[i], 1, (int )((a >> i) & 1U));
#line 146
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 149
  return;
}
}
#line 151 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bcm1250.c"
static void set_data_in___24(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;

  {
#line 155
  p = bus___0->part;
#line 157
  i = 0;
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;
#line 157
    if (! (i < 8)) {
#line 157
      goto while_break;
    }
    {
#line 158
    part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->a[i + 24], 0, 0);
#line 157
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  return;
}
}
#line 162 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bcm1250.c"
static void setup_data___25(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;

  {
#line 166
  p = bus___0->part;
#line 168
  i = 0;
  {
#line 168
  while (1) {
    while_continue: /* CIL Label */ ;
#line 168
    if (! (i < 8)) {
#line 168
      goto while_break;
    }
    {
#line 169
    part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->a[i + 24], 1, (int )((d >> i) & 1U));
#line 168
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 171
  return;
}
}
#line 177 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bcm1250.c"
static void bcm1250_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
  {
#line 180
  p = bus___0->part;
#line 181
  chain = bus___0->chain;
#line 183
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->d[0], 1, 0);
#line 184
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->d[1], 1, 1);
#line 185
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->d[2], 1, 1);
#line 186
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->d[3], 1, 1);
#line 187
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->d[4], 1, 1);
#line 188
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->d[5], 1, 1);
#line 189
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->d[6], 1, 1);
#line 190
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->d[7], 1, 1);
#line 191
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->ncs, 1, 1);
#line 192
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->nwe, 1, 1);
#line 193
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->noe, 1, 0);
#line 195
  setup_address___25(bus___0, adr);
#line 196
  set_data_in___24(bus___0);
#line 198
  chain_shift_data_registers(chain, 0);
  }
#line 199
  return;
}
}
#line 205 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bcm1250.c"
static uint32_t bcm1250_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 208
  p = bus___0->part;
#line 209
  chain = bus___0->chain;
#line 211
  setup_address___25(bus___0, adr);
#line 212
  chain_shift_data_registers(chain, 1);
#line 216
  d = (uint32_t )0;
#line 218
  i = 0;
  }
  {
#line 218
  while (1) {
    while_continue: /* CIL Label */ ;
#line 218
    if (! (i < 8)) {
#line 218
      goto while_break;
    }
    {
#line 219
    tmp = part_get_signal(p, ((bus_params_t___10 *)bus___0->params)->a[i + 24]);
#line 219
    d |= (uint32_t )(tmp << i);
#line 218
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  return (d);
}
}
#line 230 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bcm1250.c"
static uint32_t bcm1250_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 233
  p = bus___0->part;
#line 234
  chain = bus___0->chain;
#line 236
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->d[0], 1, 1);
#line 237
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->noe, 1, 1);
#line 238
  chain_shift_data_registers(chain, 1);
#line 242
  d = (uint32_t )0;
#line 244
  i = 0;
  }
  {
#line 244
  while (1) {
    while_continue: /* CIL Label */ ;
#line 244
    if (! (i < 8)) {
#line 244
      goto while_break;
    }
    {
#line 245
    tmp = part_get_signal(p, ((bus_params_t___10 *)bus___0->params)->a[i + 24]);
#line 245
    d |= (uint32_t )(tmp << i);
#line 244
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 248
  return (d);
}
}
#line 256 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bcm1250.c"
static void bcm1250_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
  {
#line 259
  p = bus___0->part;
#line 260
  chain = bus___0->chain;
#line 262
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->d[0], 1, 0);
#line 263
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->d[1], 1, 1);
#line 264
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->d[2], 1, 1);
#line 265
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->d[3], 1, 1);
#line 266
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->d[4], 1, 1);
#line 267
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->d[5], 1, 1);
#line 268
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->d[6], 1, 1);
#line 269
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->d[7], 1, 1);
#line 270
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->ncs, 1, 0);
#line 271
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->nwe, 1, 1);
#line 272
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->noe, 1, 1);
#line 274
  setup_address___25(bus___0, adr);
#line 275
  setup_data___25(bus___0, data);
#line 277
  chain_shift_data_registers(chain, 0);
#line 279
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->nwe, 1, 0);
#line 280
  chain_shift_data_registers(chain, 0);
#line 282
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->nwe, 1, 1);
#line 283
  chain_shift_data_registers(chain, 0);
  }
#line 284
  return;
}
}
#line 486 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/bcm1250.c"
struct bus_driver  const  bcm1250_bus  = 
#line 486
     {"bcm1250", "Broadcom BCM1250 compatible bus driver via BSR", & bcm1250_bus_new,
    & generic_bus_free, & bcm1250_bus_printinfo, & generic_bus_prepare_extest, & bcm1250_bus_area,
    & bcm1250_bus_read_start, & bcm1250_bus_read_next, & bcm1250_bus_read_end, & generic_bus_read,
    & bcm1250_bus_write, & generic_bus_no_init};
#line 131 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/avr32.c"
__inline static void register_set_bit(tap_register *tr , unsigned int bitno , unsigned int val ) 
{ 


  {
#line 134
  if (val) {
#line 134
    *(tr->data + bitno) = (char)1;
  } else {
#line 134
    *(tr->data + bitno) = (char)0;
  }
#line 135
  return;
}
}
#line 137 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/avr32.c"
__inline static int register_get_bit(tap_register *tr , unsigned int bitno ) 
{ 
  int tmp ;

  {
#line 140
  if ((int )*(tr->data + bitno) & 1) {
#line 140
    tmp = 1;
  } else {
#line 140
    tmp = 0;
  }
#line 140
  return (tmp);
}
}
#line 143 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/avr32.c"
__inline static void shift_instr(bus_t *bus___0 , unsigned int bit ) 
{ 
  tap_register *r ;
  int tmp___3 ;

  {
#line 146
  r = ((bus___0->part)->active_instruction)->out;
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 150
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 150
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 152
    chain_shift_instructions_mode(bus___0->chain, 1, 1, 1);
    }
    {
#line 153
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 153
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 148
    tmp___3 = register_get_bit(r, bit);
    }
#line 148
    if (! tmp___3) {
#line 148
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 157
  return;
}
}
#line 159 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/avr32.c"
__inline static void shift_data(bus_t *bus___0 , unsigned int bit ) 
{ 
  data_register *dr ;
  int tmp___3 ;

  {
#line 162
  dr = ((bus___0->part)->active_instruction)->data_register;
  {
#line 164
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 166
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 166
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 168
    chain_shift_data_registers(bus___0->chain, 1);
    }
    {
#line 169
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 169
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 164
    tmp___3 = register_get_bit(dr->out, bit);
    }
#line 164
    if (! tmp___3) {
#line 164
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 174
  return;
}
}
#line 178 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/avr32.c"
static void mwa_scan_in_instr(bus_t *bus___0 ) 
{ 


  {
  {
#line 181
  shift_instr(bus___0, 2U);
  }
#line 182
  return;
}
}
#line 184 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/avr32.c"
static void mwa_scan_in_addr(bus_t *bus___0 , unsigned int slave , uint32_t addr ,
                             int mode ) 
{ 
  tap_register *r ;
  int i ;

  {
#line 187
  r = (((bus___0->part)->active_instruction)->data_register)->in;
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;
#line 190
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 195
  i = 0;
  {
#line 195
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 195
    if (! (i < 4)) {
#line 195
      goto while_break___0;
    }
    {
#line 196
    register_set_bit(r, (unsigned int )(31 + i), slave & (unsigned int )(1 << i));
#line 195
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 199
  addr >>= 2;
#line 200
  i = 0;
  {
#line 200
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 200
    if (! (i < 30)) {
#line 200
      goto while_break___1;
    }
    {
#line 201
    register_set_bit(r, (unsigned int )(1 + i), addr & (unsigned int )(1 << i));
#line 200
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 204
  register_set_bit(r, 0U, (unsigned int )mode);
#line 206
  shift_data(bus___0, 32U);
  }
#line 207
  return;
}
}
#line 209 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/avr32.c"
static void mwa_scan_in_data(bus_t *bus___0 , uint32_t data ) 
{ 
  tap_register *r ;
  int i ;

  {
#line 212
  r = (((bus___0->part)->active_instruction)->data_register)->in;
  {
#line 215
  while (1) {
    while_continue: /* CIL Label */ ;
#line 215
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 217
  register_set_bit(r, 0U, 0U);
#line 218
  register_set_bit(r, 1U, 0U);
#line 219
  register_set_bit(r, 2U, 0U);
#line 221
  i = 0;
  }
  {
#line 221
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 221
    if (! (i < 32)) {
#line 221
      goto while_break___0;
    }
    {
#line 222
    register_set_bit(r, (unsigned int )(3 + i), data & (unsigned int )(1 << i));
#line 221
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 224
  shift_data(bus___0, 0U);
  }
#line 225
  return;
}
}
#line 227 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/avr32.c"
static void mwa_scan_out_data(bus_t *bus___0 , uint32_t *pdata ) 
{ 
  tap_register *r ;
  uint32_t data ;
  int i ;
  int tmp ;

  {
  {
#line 230
  r = (((bus___0->part)->active_instruction)->data_register)->out;
#line 234
  shift_data(bus___0, 32U);
#line 236
  data = (uint32_t )0;
#line 237
  i = 0;
  }
  {
#line 237
  while (1) {
    while_continue: /* CIL Label */ ;
#line 237
    if (! (i < 32)) {
#line 237
      goto while_break;
    }
    {
#line 238
    tmp = register_get_bit(r, (unsigned int )i);
#line 238
    data |= (unsigned int )(tmp << i);
#line 237
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 240
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 240
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 242
  *pdata = data;
#line 243
  return;
}
}
#line 254 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/avr32.c"
__inline static void mwa_write_word(bus_t *bus___0 , unsigned int slave , uint32_t addr ,
                                    uint32_t data ) 
{ 


  {
  {
#line 257
  mwa_scan_in_instr(bus___0);
#line 258
  mwa_scan_in_addr(bus___0, slave, addr, 0);
#line 259
  mwa_scan_in_data(bus___0, data);
  }
#line 260
  return;
}
}
#line 264 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/avr32.c"
static void nexus_access_start(bus_t *bus___0 ) 
{ 


  {
  {
#line 267
  shift_instr(bus___0, 2U);
  }
#line 268
  return;
}
}
#line 270 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/avr32.c"
static void nexus_access_end(bus_t *bus___0 ) 
{ 


  {
  {
#line 273
  tap_reset_bypass(bus___0->chain);
  }
#line 274
  return;
}
}
#line 276 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/avr32.c"
static void nexus_access_set_addr(bus_t *bus___0 , uint32_t addr , int mode ) 
{ 
  tap_register *r ;
  int i ;

  {
#line 279
  r = (((bus___0->part)->active_instruction)->data_register)->in;
  {
#line 282
  while (1) {
    while_continue: /* CIL Label */ ;
#line 282
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 285
  register_fill(r, 0);
#line 288
  addr >>= 2;
#line 289
  i = 0;
  }
  {
#line 289
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 289
    if (! (i < 7)) {
#line 289
      goto while_break___0;
    }
    {
#line 290
    register_set_bit(r, (unsigned int )(27 + i), addr & (unsigned int )(1 << i));
#line 289
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 293
  register_set_bit(r, 26U, (unsigned int )mode);
#line 295
  shift_data(bus___0, 32U);
  }
#line 296
  return;
}
}
#line 298 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/avr32.c"
static void nexus_access_read_data(bus_t *bus___0 , uint32_t *pdata ) 
{ 
  tap_register *r ;
  uint32_t data ;
  int i ;
  int tmp ;

  {
  {
#line 301
  r = (((bus___0->part)->active_instruction)->data_register)->out;
#line 305
  shift_data(bus___0, 32U);
#line 307
  data = (uint32_t )0;
#line 308
  i = 0;
  }
  {
#line 308
  while (1) {
    while_continue: /* CIL Label */ ;
#line 308
    if (! (i < 32)) {
#line 308
      goto while_break;
    }
    {
#line 309
    tmp = register_get_bit(r, (unsigned int )i);
#line 309
    data |= (unsigned int )(tmp << i);
#line 308
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 311
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 311
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 313
  *pdata = data;
#line 314
  return;
}
}
#line 316 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/avr32.c"
static void nexus_access_write_data(bus_t *bus___0 , uint32_t data ) 
{ 
  tap_register *r ;
  int i ;

  {
#line 319
  r = (((bus___0->part)->active_instruction)->data_register)->in;
  {
#line 322
  while (1) {
    while_continue: /* CIL Label */ ;
#line 322
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 324
  register_set_bit(r, 0U, 0U);
#line 325
  register_set_bit(r, 1U, 0U);
#line 327
  i = 0;
  }
  {
#line 327
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 327
    if (! (i < 32)) {
#line 327
      goto while_break___0;
    }
    {
#line 328
    register_set_bit(r, (unsigned int )(2 + i), data & (unsigned int )(1 << i));
#line 327
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 330
  shift_data(bus___0, 0U);
  }
#line 331
  return;
}
}
#line 333 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/avr32.c"
__inline static void nexus_reg_read(bus_t *bus___0 , uint32_t reg , uint32_t *data ) 
{ 


  {
  {
#line 336
  nexus_access_set_addr(bus___0, reg, 1);
#line 337
  nexus_access_read_data(bus___0, data);
  }
#line 338
  return;
}
}
#line 340 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/avr32.c"
__inline static void nexus_reg_write(bus_t *bus___0 , uint32_t reg , uint32_t data ) 
{ 


  {
  {
#line 343
  nexus_access_set_addr(bus___0, reg, 0);
#line 344
  nexus_access_write_data(bus___0, data);
  }
#line 345
  return;
}
}
#line 349 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/avr32.c"
static void nexus_memacc_set_addr(bus_t *bus___0 , uint32_t addr , uint32_t rwcs ) 
{ 


  {
  {
#line 352
  nexus_reg_write(bus___0, (uint32_t )36, addr);
#line 353
  nexus_reg_write(bus___0, (uint32_t )28, rwcs);
  }
#line 354
  return;
}
}
#line 356 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/avr32.c"
static int nexus_memacc_read(bus_t *bus___0 , uint32_t *data ) 
{ 
  uint32_t status ;
  int ret ;
  char *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 362
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 364
    nexus_reg_read(bus___0, (uint32_t )28, & status);
#line 365
    status &= 3U;
    }
#line 362
    if (! (status == 0U)) {
#line 362
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 370
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 370
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 372
  ret = 0;
  {
#line 375
  if (status == 1U) {
#line 375
    goto case_1;
  }
#line 378
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 376
  nexus_reg_read(bus___0, (uint32_t )40, data);
  }
#line 377
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 379
  tmp___0 = gettext("%s(%d): error, read failed, status=%d\n");
#line 379
  printf((char const   */* __restrict  */)tmp___0, "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/avr32.c",
         379, status);
#line 380
  *data = 4294967295U;
#line 381
  ret = -1;
  }
#line 382
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 385
  return (ret);
}
}
#line 388 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/avr32.c"
static int nexus_memacc_write(bus_t *bus___0 , uint32_t addr , uint32_t data , uint32_t rwcs ) 
{ 
  uint32_t status ;
  int ret ;
  char *tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 394
  nexus_reg_write(bus___0, (uint32_t )36, addr);
#line 395
  nexus_reg_write(bus___0, (uint32_t )28, rwcs);
#line 396
  nexus_reg_write(bus___0, (uint32_t )40, data);
#line 398
  nexus_reg_read(bus___0, (uint32_t )28, & status);
#line 399
  status &= 3U;
  }
  {
#line 401
  while (1) {
    while_continue: /* CIL Label */ ;
#line 401
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 403
  ret = 0;
#line 404
  if (status) {
    {
#line 406
    tmp___0 = gettext("%s(%d): error, write failed, status=%d\n");
#line 406
    printf((char const   */* __restrict  */)tmp___0, "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/avr32.c",
           406, status);
#line 407
    ret = -1;
    }
  }
#line 410
  return (ret);
}
}
#line 415 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/avr32.c"
static void avr32_bus_setup(bus_t *bus___0 , chain_t *chain , part_t *part , unsigned int mode ) 
{ 


  {
#line 419
  bus___0->chain = chain;
#line 420
  bus___0->part = part;
#line 421
  ((bus_params_t___25 *)bus___0->params)->mode = mode;
  {
#line 425
  if (mode == 0U) {
#line 425
    goto case_0;
  }
#line 430
  if (mode == 1U) {
#line 430
    goto case_1;
  }
#line 435
  if (mode == 2U) {
#line 435
    goto case_2;
  }
#line 440
  if (mode == 3U) {
#line 440
    goto case_3;
  }
#line 446
  if (mode == 4U) {
#line 446
    goto case_4;
  }
#line 452
  if (mode == 5U) {
#line 452
    goto case_5;
  }
#line 423
  goto switch_break;
  case_0: /* CIL Label */ 
#line 426
  ((bus_params_t___25 *)bus___0->params)->slave = 1U;
#line 427
  ((bus_params_t___25 *)bus___0->params)->addr_mask = (uint32_t )4092;
#line 428
  goto switch_break;
  case_1: /* CIL Label */ 
#line 431
  ((bus_params_t___25 *)bus___0->params)->slave = 4U;
#line 432
  ((bus_params_t___25 *)bus___0->params)->addr_mask = 4294967292U;
#line 433
  goto switch_break;
  case_2: /* CIL Label */ 
#line 436
  ((bus_params_t___25 *)bus___0->params)->slave = 5U;
#line 437
  ((bus_params_t___25 *)bus___0->params)->addr_mask = 4294967292U;
#line 438
  goto switch_break;
  case_3: /* CIL Label */ 
#line 441
  ((bus_params_t___25 *)bus___0->params)->addr_mask = 4294967295U;
#line 442
  ((bus_params_t___25 *)bus___0->params)->rwcs_rd = 2147483648U | (unsigned int )(1 << 2);
#line 443
  ((bus_params_t___25 *)bus___0->params)->rwcs_wr = (2147483648U | (unsigned int )(1 << 2)) | 1073741824U;
#line 444
  goto switch_break;
  case_4: /* CIL Label */ 
#line 447
  ((bus_params_t___25 *)bus___0->params)->addr_mask = 4294967294U;
#line 448
  ((bus_params_t___25 *)bus___0->params)->rwcs_rd = (2147483648U | (unsigned int )(1 << 2)) | 134217728U;
#line 449
  ((bus_params_t___25 *)bus___0->params)->rwcs_wr = ((2147483648U | (unsigned int )(1 << 2)) | 1073741824U) | 134217728U;
#line 450
  goto switch_break;
  case_5: /* CIL Label */ 
#line 453
  ((bus_params_t___25 *)bus___0->params)->addr_mask = 4294967292U;
#line 454
  ((bus_params_t___25 *)bus___0->params)->rwcs_rd = (2147483648U | (unsigned int )(1 << 2)) | 268435456U;
#line 455
  ((bus_params_t___25 *)bus___0->params)->rwcs_wr = ((2147483648U | (unsigned int )(1 << 2)) | 1073741824U) | 268435456U;
#line 456
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 458
  return;
}
}
#line 460 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/avr32.c"
static int check_instruction(part_t *part , char const   *instr ) 
{ 
  int ret ;
  instruction *tmp ;
  char *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 465
  tmp = part_find_instruction(part, instr);
#line 465
  ret = (unsigned long )tmp == (unsigned long )((void *)0);
  }
#line 466
  if (ret) {
    {
#line 467
    tmp___0 = gettext("%s(%d): error, instruction %s not found\n");
#line 467
    printf((char const   */* __restrict  */)tmp___0, "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/avr32.c",
           467, instr);
    }
  }
#line 469
  return (ret);
}
}
#line 476 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/avr32.c"
static bus_t *avr32_bus_new(chain_t *chain , bus_driver_t const   *driver , char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  part_t *part ;
  char *param ;
  unsigned int mode ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
#line 484
  part = *((chain->parts)->parts + chain->active_part);
#line 486
  param = *(cmd_params___0 + 2);
#line 487
  if (! param) {
    {
#line 489
    tmp = gettext("%s(%d): error, no bus mode specified\n");
#line 489
    printf((char const   */* __restrict  */)tmp, "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/avr32.c",
           489);
    }
#line 490
    return ((bus_t *)((void *)0));
  }
  {
#line 493
  tmp___6 = strcasecmp("OCD", (char const   *)param);
  }
#line 493
  if (tmp___6) {
    {
#line 497
    tmp___5 = strcasecmp("HSBC", (char const   *)param);
    }
#line 497
    if (tmp___5) {
      {
#line 501
      tmp___4 = strcasecmp("HSBU", (char const   *)param);
      }
#line 501
      if (tmp___4) {
        {
#line 505
        tmp___3 = strcasecmp("x8", (char const   *)param);
        }
#line 505
        if (tmp___3) {
          {
#line 509
          tmp___2 = strcasecmp("x16", (char const   *)param);
          }
#line 509
          if (tmp___2) {
            {
#line 513
            tmp___1 = strcasecmp("x32", (char const   *)param);
            }
#line 513
            if (tmp___1) {
              {
#line 519
              tmp___0 = gettext("%s(%d): error, invalid bus mode: %s\n");
#line 519
              printf((char const   */* __restrict  */)tmp___0, "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/avr32.c",
                     519, param);
              }
#line 520
              return ((bus_t *)((void *)0));
            } else {
#line 515
              mode = 5U;
            }
          } else {
#line 511
            mode = 4U;
          }
        } else {
#line 507
          mode = 3U;
        }
      } else {
#line 503
        mode = 2U;
      }
    } else {
#line 499
      mode = 1U;
    }
  } else {
#line 495
    mode = 0U;
  }
  {
#line 527
  if (mode == 2U) {
#line 527
    goto case_2;
  }
#line 527
  if (mode == 1U) {
#line 527
    goto case_2;
  }
#line 527
  if (mode == 0U) {
#line 527
    goto case_2;
  }
#line 533
  if (mode == 5U) {
#line 533
    goto case_5;
  }
#line 533
  if (mode == 4U) {
#line 533
    goto case_5;
  }
#line 533
  if (mode == 3U) {
#line 533
    goto case_5;
  }
#line 523
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 528
  tmp___7 = check_instruction(part, "MEMORY_WORD_ACCESS");
  }
#line 528
  if (tmp___7) {
#line 529
    return ((bus_t *)((void *)0));
  }
#line 530
  goto switch_break;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 534
  tmp___8 = check_instruction(part, "NEXUS_ACCESS");
  }
#line 534
  if (tmp___8) {
#line 535
    return ((bus_t *)((void *)0));
  }
#line 536
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 539
  tmp___9 = calloc((size_t )1, (size_t )sizeof(bus_t ));
#line 539
  bus___0 = (bus_t *)tmp___9;
  }
#line 540
  if (! bus___0) {
#line 541
    return ((bus_t *)((void *)0));
  }
  {
#line 543
  bus___0->driver = driver;
#line 544
  bus___0->params = calloc((size_t )1, (size_t )sizeof(bus_params_t___25 ));
  }
#line 545
  if (! bus___0->params) {
    {
#line 547
    free((void *)bus___0);
    }
#line 548
    return ((bus_t *)((void *)0));
  }
  {
#line 551
  avr32_bus_setup(bus___0, chain, part, mode);
  }
#line 553
  return (bus___0);
}
}
#line 560 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/avr32.c"
static void avr32_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;
  char *__cil_tmp4 ;

  {
#line 565
  i = 0;
  {
#line 565
  while (1) {
    while_continue: /* CIL Label */ ;
#line 565
    if (! (i < ((bus___0->chain)->parts)->len)) {
#line 565
      goto while_break;
    }
#line 566
    if ((unsigned long )bus___0->part == (unsigned long )*(((bus___0->chain)->parts)->parts + i)) {
#line 567
      goto while_break;
    }
#line 565
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 569
  tmp = gettext("AVR32 multi-mode bus driver (JTAG part No. %d)\n");
#line 569
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 570
  return;
}
}
#line 576 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/avr32.c"
static void avr32_bus_prepare(bus_t *bus___0 ) 
{ 


  {
#line 579
  if (! bus___0->initialized) {
    {
#line 580
    (*((bus___0->driver)->init))(bus___0);
    }
  }
#line 581
  return;
}
}
#line 587 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/avr32.c"
static int avr32_bus_area(bus_t *bus___0 , uint32_t addr , bus_area_t *area___0 ) 
{ 
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 592
  if (((bus_params_t___25 *)bus___0->params)->mode == 1U) {
#line 592
    goto case_1;
  }
#line 598
  if (((bus_params_t___25 *)bus___0->params)->mode == 2U) {
#line 598
    goto case_2;
  }
#line 604
  if (((bus_params_t___25 *)bus___0->params)->mode == 3U) {
#line 604
    goto case_3;
  }
#line 610
  if (((bus_params_t___25 *)bus___0->params)->mode == 4U) {
#line 610
    goto case_4;
  }
#line 616
  if (((bus_params_t___25 *)bus___0->params)->mode == 5U) {
#line 616
    goto case_5;
  }
#line 622
  if (((bus_params_t___25 *)bus___0->params)->mode == 0U) {
#line 622
    goto case_0;
  }
#line 632
  goto switch_default;
  case_1: /* CIL Label */ 
#line 593
  area___0->description = "HSB memory space, cached";
#line 594
  area___0->start = 0U;
#line 595
  area___0->length = 4294967296ULL;
#line 596
  area___0->width = 32U;
#line 597
  goto switch_break;
  case_2: /* CIL Label */ 
#line 599
  area___0->description = "HSB memory space, uncached";
#line 600
  area___0->start = 0U;
#line 601
  area___0->length = 4294967296ULL;
#line 602
  area___0->width = 32U;
#line 603
  goto switch_break;
  case_3: /* CIL Label */ 
#line 605
  area___0->description = "HSB memory space, uncached";
#line 606
  area___0->start = 0U;
#line 607
  area___0->length = 4294967296ULL;
#line 608
  area___0->width = 8U;
#line 609
  goto switch_break;
  case_4: /* CIL Label */ 
#line 611
  area___0->description = "HSB memory space, uncached";
#line 612
  area___0->start = 0U;
#line 613
  area___0->length = 4294967296ULL;
#line 614
  area___0->width = 16U;
#line 615
  goto switch_break;
  case_5: /* CIL Label */ 
#line 617
  area___0->description = "HSB memory space, uncached";
#line 618
  area___0->start = 0U;
#line 619
  area___0->length = 4294967296ULL;
#line 620
  area___0->width = 32U;
#line 621
  goto switch_break;
  case_0: /* CIL Label */ 
#line 623
  if ((unsigned long long )addr < 4096ULL) {
#line 625
    area___0->description = "OCD registers";
#line 626
    area___0->start = 0U;
#line 627
    area___0->length = 4096ULL;
#line 628
    area___0->width = 32U;
#line 629
    goto switch_break;
  }
  switch_default: /* CIL Label */ 
#line 633
  area___0->description = (char const   *)((void *)0);
#line 634
  area___0->length = 4294967296ULL;
#line 635
  area___0->width = 0U;
#line 636
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 639
  return (0);
}
}
#line 646 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/avr32.c"
static void avr32_bus_read_start(bus_t *bus___0 , uint32_t addr ) 
{ 
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 649
  addr &= ((bus_params_t___25 *)bus___0->params)->addr_mask;
  {
#line 651
  while (1) {
    while_continue: /* CIL Label */ ;
#line 651
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 657
  if (((bus_params_t___25 *)bus___0->params)->mode == 2U) {
#line 657
    goto case_2;
  }
#line 657
  if (((bus_params_t___25 *)bus___0->params)->mode == 1U) {
#line 657
    goto case_2;
  }
#line 657
  if (((bus_params_t___25 *)bus___0->params)->mode == 0U) {
#line 657
    goto case_2;
  }
#line 665
  if (((bus_params_t___25 *)bus___0->params)->mode == 5U) {
#line 665
    goto case_5;
  }
#line 665
  if (((bus_params_t___25 *)bus___0->params)->mode == 4U) {
#line 665
    goto case_5;
  }
#line 665
  if (((bus_params_t___25 *)bus___0->params)->mode == 3U) {
#line 665
    goto case_5;
  }
#line 653
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 658
  part_set_instruction(bus___0->part, "MEMORY_WORD_ACCESS");
#line 659
  mwa_scan_in_instr(bus___0);
#line 660
  mwa_scan_in_addr(bus___0, ((bus_params_t___25 *)bus___0->params)->slave, addr, 1);
  }
#line 661
  goto switch_break;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 666
  part_set_instruction(bus___0->part, "NEXUS_ACCESS");
#line 667
  nexus_access_start(bus___0);
#line 668
  nexus_memacc_set_addr(bus___0, addr, ((bus_params_t___25 *)bus___0->params)->rwcs_rd);
  }
#line 669
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 671
  return;
}
}
#line 677 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/avr32.c"
static uint32_t avr32_bus_read_end(bus_t *bus___0 ) 
{ 
  uint32_t data ;

  {
  {
#line 686
  if (((bus_params_t___25 *)bus___0->params)->mode == 2U) {
#line 686
    goto case_2;
  }
#line 686
  if (((bus_params_t___25 *)bus___0->params)->mode == 1U) {
#line 686
    goto case_2;
  }
#line 686
  if (((bus_params_t___25 *)bus___0->params)->mode == 0U) {
#line 686
    goto case_2;
  }
#line 691
  if (((bus_params_t___25 *)bus___0->params)->mode == 5U) {
#line 691
    goto case_5;
  }
#line 691
  if (((bus_params_t___25 *)bus___0->params)->mode == 4U) {
#line 691
    goto case_5;
  }
#line 691
  if (((bus_params_t___25 *)bus___0->params)->mode == 3U) {
#line 691
    goto case_5;
  }
#line 682
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 687
  mwa_scan_out_data(bus___0, & data);
  }
#line 688
  goto switch_break;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 692
  nexus_memacc_read(bus___0, & data);
#line 693
  nexus_access_end(bus___0);
  }
#line 694
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 697
  return (data);
}
}
#line 704 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/avr32.c"
static uint32_t avr32_bus_read_next(bus_t *bus___0 , uint32_t addr ) 
{ 
  uint32_t data ;

  {
#line 709
  addr &= ((bus_params_t___25 *)bus___0->params)->addr_mask;
  {
#line 715
  if (((bus_params_t___25 *)bus___0->params)->mode == 2U) {
#line 715
    goto case_2;
  }
#line 715
  if (((bus_params_t___25 *)bus___0->params)->mode == 1U) {
#line 715
    goto case_2;
  }
#line 715
  if (((bus_params_t___25 *)bus___0->params)->mode == 0U) {
#line 715
    goto case_2;
  }
#line 721
  if (((bus_params_t___25 *)bus___0->params)->mode == 5U) {
#line 721
    goto case_5;
  }
#line 721
  if (((bus_params_t___25 *)bus___0->params)->mode == 4U) {
#line 721
    goto case_5;
  }
#line 721
  if (((bus_params_t___25 *)bus___0->params)->mode == 3U) {
#line 721
    goto case_5;
  }
#line 711
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 716
  data = avr32_bus_read_end(bus___0);
#line 717
  avr32_bus_read_start(bus___0, addr);
  }
#line 718
  goto switch_break;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 722
  nexus_memacc_read(bus___0, & data);
#line 723
  nexus_memacc_set_addr(bus___0, addr, ((bus_params_t___25 *)bus___0->params)->rwcs_rd);
  }
#line 724
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 727
  return (data);
}
}
#line 734 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/avr32.c"
static void avr32_bus_write(bus_t *bus___0 , uint32_t addr , uint32_t data ) 
{ 
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 737
  addr &= ((bus_params_t___25 *)bus___0->params)->addr_mask;
  {
#line 743
  if (((bus_params_t___25 *)bus___0->params)->mode == 2U) {
#line 743
    goto case_2;
  }
#line 743
  if (((bus_params_t___25 *)bus___0->params)->mode == 1U) {
#line 743
    goto case_2;
  }
#line 743
  if (((bus_params_t___25 *)bus___0->params)->mode == 0U) {
#line 743
    goto case_2;
  }
#line 749
  if (((bus_params_t___25 *)bus___0->params)->mode == 5U) {
#line 749
    goto case_5;
  }
#line 749
  if (((bus_params_t___25 *)bus___0->params)->mode == 4U) {
#line 749
    goto case_5;
  }
#line 749
  if (((bus_params_t___25 *)bus___0->params)->mode == 3U) {
#line 749
    goto case_5;
  }
#line 739
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 744
  part_set_instruction(bus___0->part, "MEMORY_WORD_ACCESS");
#line 745
  mwa_write_word(bus___0, ((bus_params_t___25 *)bus___0->params)->slave, addr, data);
  }
#line 746
  goto switch_break;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 750
  part_set_instruction(bus___0->part, "NEXUS_ACCESS");
#line 751
  nexus_access_start(bus___0);
#line 752
  nexus_memacc_write(bus___0, addr, data, ((bus_params_t___25 *)bus___0->params)->rwcs_wr);
#line 753
  nexus_access_end(bus___0);
  }
#line 754
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 756
  return;
}
}
#line 758 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/avr32.c"
struct bus_driver  const  avr32_bus_driver  = 
#line 758
     {"avr32", "Atmel AVR32 multi-mode bus driver, requires <mode> parameter\n           valid <mode> parameters:\n               x8:   8 bit bus for the uncached HSB area, via OCD registers\n               x16:  16 bit bus for the uncached HSB area, via OCD registers\n               x32:  32 bit bus for the uncached HSB area, via OCD registers\n               OCD : 32 bit bus for the OCD registers\n               HSBC: 32 bit bus for the cached HSB area, via SAB\n               HSBU: 32 bit bus for the uncached HSB area, via SAB",
    & avr32_bus_new, & generic_bus_free, & avr32_bus_printinfo, & avr32_bus_prepare,
    & avr32_bus_area, & avr32_bus_read_start, & avr32_bus_read_next, & avr32_bus_read_end,
    & generic_bus_read, & avr32_bus_write, & generic_bus_no_init};
#line 62 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/au1500.c"
static bus_t *au1500_bus_new(chain_t *chain , bus_driver_t const   *driver , char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  part_t *part ;
  char buff[10] ;
  int i ;
  int failed ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
  {
#line 68
  failed = 0;
#line 70
  tmp = calloc((size_t )1, (size_t )sizeof(bus_t ));
#line 70
  bus___0 = (bus_t *)tmp;
  }
#line 71
  if (! bus___0) {
#line 72
    return ((bus_t *)((void *)0));
  }
  {
#line 74
  bus___0->driver = driver;
#line 75
  bus___0->params = calloc((size_t )1, (size_t )sizeof(bus_params_t___26 ));
  }
#line 76
  if (! bus___0->params) {
    {
#line 77
    free((void *)bus___0);
    }
#line 78
    return ((bus_t *)((void *)0));
  }
#line 81
  bus___0->chain = chain;
#line 82
  part = *((chain->parts)->parts + chain->active_part);
#line 82
  bus___0->part = part;
#line 84
  i = 0;
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
#line 84
    if (! (i < 32)) {
#line 84
      goto while_break;
    }
    {
#line 85
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"RAD%d",
            i);
#line 86
    tmp___0 = generic_bus_attach_sig(part, & ((bus_params_t___26 *)bus___0->params)->rad[i],
                                     buff);
#line 86
    failed |= tmp___0;
#line 84
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 89
  i = 0;
  {
#line 89
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 89
    if (! (i < 4)) {
#line 89
      goto while_break___0;
    }
    {
#line 90
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"RCE_N%d",
            i);
#line 91
    tmp___1 = generic_bus_attach_sig(part, & ((bus_params_t___26 *)bus___0->params)->nrcs[i],
                                     buff);
#line 91
    failed |= tmp___1;
#line 89
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 95
  tmp___2 = generic_bus_attach_sig(part, & ((bus_params_t___26 *)bus___0->params)->nrwe,
                                   (char *)"RWE_N");
#line 95
  failed |= tmp___2;
#line 97
  tmp___3 = generic_bus_attach_sig(part, & ((bus_params_t___26 *)bus___0->params)->nroe,
                                   (char *)"ROE_N");
#line 97
  failed |= tmp___3;
#line 99
  i = 0;
  }
  {
#line 99
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 99
    if (! (i < 32)) {
#line 99
      goto while_break___1;
    }
    {
#line 100
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"RD%d",
            i);
#line 101
    tmp___4 = generic_bus_attach_sig(part, & ((bus_params_t___26 *)bus___0->params)->rd[i],
                                     buff);
#line 101
    failed |= tmp___4;
#line 99
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 104
  if (failed) {
    {
#line 105
    free(bus___0->params);
#line 106
    free((void *)bus___0);
    }
#line 107
    return ((bus_t *)((void *)0));
  }
#line 110
  return (bus___0);
}
}
#line 118 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/au1500.c"
static void au1500_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;
  char *__cil_tmp4 ;

  {
#line 123
  i = 0;
  {
#line 123
  while (1) {
    while_continue: /* CIL Label */ ;
#line 123
    if (! (i < ((bus___0->chain)->parts)->len)) {
#line 123
      goto while_break;
    }
#line 124
    if ((unsigned long )bus___0->part == (unsigned long )*(((bus___0->chain)->parts)->parts + i)) {
#line 125
      goto while_break;
    }
#line 123
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 126
  tmp = gettext("AU1500 compatible bus driver via BSR (JTAG part No. %d)\n");
#line 126
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 127
  return;
}
}
#line 133 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/au1500.c"
static int au1500_bus_area(bus_t *bus___0 , uint32_t addr , bus_area_t *area___0 ) 
{ 
  signal_t *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp8 ;

  {
  {
#line 136
  area___0->description = (char const   *)((void *)0);
#line 137
  area___0->start = 0U;
#line 138
  area___0->length = 4294967296ULL;
#line 140
  tmp___1 = part_find_signal(bus___0->part, "ROMSIZ");
#line 140
  tmp___2 = part_get_signal(bus___0->part, tmp___1);
  }
#line 140
  if (tmp___2) {
#line 140
    area___0->width = 16U;
  } else {
#line 140
    area___0->width = 32U;
  }
#line 143
  return (0);
}
}
#line 147 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/au1500.c"
static void setup_address___26(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 151
  p = bus___0->part;
#line 153
  i = 0;
  {
#line 153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 153
    if (! (i < 32)) {
#line 153
      goto while_break;
    }
    {
#line 154
    part_set_signal(p, ((bus_params_t___26 *)bus___0->params)->rad[i], 1, (int )((a >> i) & 1U));
#line 153
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 155
  return;
}
}
#line 157 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/au1500.c"
static void set_data_in___25(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area___0 ;

  {
  {
#line 161
  p = bus___0->part;
#line 164
  au1500_bus_area(bus___0, (uint32_t )0, & area___0);
#line 166
  i = 0;
  }
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
#line 166
    if (! ((unsigned int )i < area___0.width)) {
#line 166
      goto while_break;
    }
    {
#line 167
    part_set_signal(p, ((bus_params_t___26 *)bus___0->params)->rd[i], 0, 0);
#line 166
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 169
  return;
}
}
#line 171 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/au1500.c"
static uint32_t get_data_out___0(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area___0 ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 175
  p = bus___0->part;
#line 177
  d = (uint32_t )0;
#line 179
  au1500_bus_area(bus___0, (uint32_t )0, & area___0);
#line 181
  i = 0;
  }
  {
#line 181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 181
    if (! ((unsigned int )i < area___0.width)) {
#line 181
      goto while_break;
    }
    {
#line 182
    tmp = part_get_signal(p, ((bus_params_t___26 *)bus___0->params)->rd[i]);
#line 182
    d |= (uint32_t )(tmp << i);
#line 181
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 184
  return (d);
}
}
#line 187 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/au1500.c"
static void setup_data___26(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area___0 ;

  {
  {
#line 191
  p = bus___0->part;
#line 194
  au1500_bus_area(bus___0, (uint32_t )0, & area___0);
#line 196
  i = 0;
  }
  {
#line 196
  while (1) {
    while_continue: /* CIL Label */ ;
#line 196
    if (! ((unsigned int )i < area___0.width)) {
#line 196
      goto while_break;
    }
    {
#line 197
    part_set_signal(p, ((bus_params_t___26 *)bus___0->params)->rd[i], 1, (int )((d >> i) & 1U));
#line 196
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 198
  return;
}
}
#line 204 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/au1500.c"
static void au1500_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
  {
#line 207
  p = bus___0->part;
#line 208
  chain = bus___0->chain;
#line 210
  part_set_signal(p, ((bus_params_t___26 *)bus___0->params)->nrcs[0], 1, 0);
#line 211
  part_set_signal(p, ((bus_params_t___26 *)bus___0->params)->nrcs[1], 1, 1);
#line 212
  part_set_signal(p, ((bus_params_t___26 *)bus___0->params)->nrcs[2], 1, 1);
#line 213
  part_set_signal(p, ((bus_params_t___26 *)bus___0->params)->nrcs[3], 1, 1);
#line 214
  part_set_signal(p, ((bus_params_t___26 *)bus___0->params)->nrwe, 1, 1);
#line 215
  part_set_signal(p, ((bus_params_t___26 *)bus___0->params)->nroe, 1, 0);
#line 217
  setup_address___26(bus___0, adr);
#line 218
  set_data_in___25(bus___0);
#line 220
  chain_shift_data_registers(chain, 0);
  }
#line 221
  return;
}
}
#line 227 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/au1500.c"
static uint32_t au1500_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  chain_t *chain ;
  uint32_t tmp ;

  {
  {
#line 230
  chain = bus___0->chain;
#line 232
  setup_address___26(bus___0, adr);
#line 233
  chain_shift_data_registers(chain, 1);
#line 235
  tmp = get_data_out___0(bus___0);
  }
#line 235
  return (tmp);
}
}
#line 242 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/au1500.c"
static uint32_t au1500_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain ;
  uint32_t tmp ;

  {
  {
#line 245
  p = bus___0->part;
#line 246
  chain = bus___0->chain;
#line 248
  part_set_signal(p, ((bus_params_t___26 *)bus___0->params)->nrcs[0], 1, 1);
#line 249
  part_set_signal(p, ((bus_params_t___26 *)bus___0->params)->nrcs[1], 1, 1);
#line 250
  part_set_signal(p, ((bus_params_t___26 *)bus___0->params)->nrcs[2], 1, 1);
#line 251
  part_set_signal(p, ((bus_params_t___26 *)bus___0->params)->nrcs[3], 1, 1);
#line 252
  part_set_signal(p, ((bus_params_t___26 *)bus___0->params)->nrwe, 1, 1);
#line 253
  part_set_signal(p, ((bus_params_t___26 *)bus___0->params)->nroe, 1, 1);
#line 255
  chain_shift_data_registers(chain, 1);
#line 257
  tmp = get_data_out___0(bus___0);
  }
#line 257
  return (tmp);
}
}
#line 264 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/au1500.c"
static void au1500_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
  {
#line 267
  p = bus___0->part;
#line 268
  chain = bus___0->chain;
#line 270
  part_set_signal(p, ((bus_params_t___26 *)bus___0->params)->nrcs[0], 1, 0);
#line 271
  part_set_signal(p, ((bus_params_t___26 *)bus___0->params)->nrcs[1], 1, 1);
#line 272
  part_set_signal(p, ((bus_params_t___26 *)bus___0->params)->nrcs[2], 1, 1);
#line 273
  part_set_signal(p, ((bus_params_t___26 *)bus___0->params)->nrcs[3], 1, 1);
#line 274
  part_set_signal(p, ((bus_params_t___26 *)bus___0->params)->nrwe, 1, 1);
#line 275
  part_set_signal(p, ((bus_params_t___26 *)bus___0->params)->nroe, 1, 1);
#line 277
  setup_address___26(bus___0, adr);
#line 278
  setup_data___26(bus___0, data);
#line 280
  chain_shift_data_registers(chain, 0);
#line 282
  part_set_signal(p, ((bus_params_t___26 *)bus___0->params)->nrwe, 1, 0);
#line 283
  chain_shift_data_registers(chain, 0);
#line 285
  part_set_signal(p, ((bus_params_t___26 *)bus___0->params)->nrwe, 1, 1);
#line 286
  part_set_signal(p, ((bus_params_t___26 *)bus___0->params)->nroe, 1, 1);
#line 287
  part_set_signal(p, ((bus_params_t___26 *)bus___0->params)->nrcs[0], 1, 1);
#line 288
  part_set_signal(p, ((bus_params_t___26 *)bus___0->params)->nrcs[1], 1, 1);
#line 289
  part_set_signal(p, ((bus_params_t___26 *)bus___0->params)->nrcs[2], 1, 1);
#line 290
  part_set_signal(p, ((bus_params_t___26 *)bus___0->params)->nrcs[3], 1, 1);
#line 292
  chain_shift_data_registers(chain, 0);
  }
#line 293
  return;
}
}
#line 295 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/bus/au1500.c"
struct bus_driver  const  au1500_bus  = 
#line 295
     {"au1500", "AU1500 BUS Driver via BSR", & au1500_bus_new, & generic_bus_free, & au1500_bus_printinfo,
    & generic_bus_prepare_extest, & au1500_bus_area, & au1500_bus_read_start, & au1500_bus_read_next,
    & au1500_bus_read_end, & generic_bus_read, & au1500_bus_write, & generic_bus_no_init};
#line 80 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/jedec.c"
static struct amd_flash_info  const  table[21]  = 
#line 80 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/jedec.c"
  {      {(int const   )1, (int const   )8900, "AMD AM29LV160DT", (long const   )2097152,
      (uint8_t const   )1, (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )65536,
                                                               (uint32_t )31}, {(uint32_t )2031616,
                                                                                (uint32_t )32768,
                                                                                (uint32_t )1},
                                                              {(uint32_t )2064384,
                                                               (uint32_t )8192, (uint32_t )2},
                                                              {(uint32_t )2080768,
                                                               (uint32_t )16384, (uint32_t )1}}}, 
        {(int const   )1,
      (int const   )8777, "AMD AM29LV160DB", (long const   )2097152, (uint8_t const   )1,
      (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )16384, (uint32_t )1},
                                         {(uint32_t )16384, (uint32_t )8192, (uint32_t )2},
                                         {(uint32_t )32768, (uint32_t )32768, (uint32_t )1},
                                         {(uint32_t )65536, (uint32_t )65536, (uint32_t )31}}}, 
        {(int const   )152,
      (int const   )194, "Toshiba TC58FVT160", (long const   )2097152, (uint8_t const   )1,
      (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )65536, (uint32_t )31},
                                         {(uint32_t )2031616, (uint32_t )32768, (uint32_t )1},
                                         {(uint32_t )2064384, (uint32_t )8192, (uint32_t )2},
                                         {(uint32_t )2080768, (uint32_t )16384, (uint32_t )1}}}, 
        {(int const   )4,
      (int const   )8900, "Fujitsu MBM29LV160TE", (long const   )2097152, (uint8_t const   )1,
      (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )65536, (uint32_t )31},
                                         {(uint32_t )2031616, (uint32_t )32768, (uint32_t )1},
                                         {(uint32_t )2064384, (uint32_t )8192, (uint32_t )2},
                                         {(uint32_t )2080768, (uint32_t )16384, (uint32_t )1}}}, 
        {(int const   )152,
      (int const   )67, "Toshiba TC58FVB160", (long const   )2097152, (uint8_t const   )1,
      (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )16384, (uint32_t )1},
                                         {(uint32_t )16384, (uint32_t )8192, (uint32_t )2},
                                         {(uint32_t )32768, (uint32_t )32768, (uint32_t )1},
                                         {(uint32_t )65536, (uint32_t )65536, (uint32_t )31}}}, 
        {(int const   )4,
      (int const   )8777, "Fujitsu MBM29LV160BE", (long const   )2097152, (uint8_t const   )1,
      (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )16384, (uint32_t )1},
                                         {(uint32_t )16384, (uint32_t )8192, (uint32_t )2},
                                         {(uint32_t )32768, (uint32_t )32768, (uint32_t )1},
                                         {(uint32_t )65536, (uint32_t )65536, (uint32_t )31}}}, 
        {(int const   )1,
      (int const   )8795, "AMD AM29LV800BB", (long const   )1048576, (uint8_t const   )1,
      (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )16384, (uint32_t )1},
                                         {(uint32_t )16384, (uint32_t )8192, (uint32_t )2},
                                         {(uint32_t )32768, (uint32_t )32768, (uint32_t )1},
                                         {(uint32_t )65536, (uint32_t )65536, (uint32_t )15}}}, 
        {(int const   )1,
      (int const   )8792, "AMD AM29F800BB", (long const   )1048576, (uint8_t const   )1,
      (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )16384, (uint32_t )1},
                                         {(uint32_t )16384, (uint32_t )8192, (uint32_t )2},
                                         {(uint32_t )32768, (uint32_t )32768, (uint32_t )1},
                                         {(uint32_t )65536, (uint32_t )65536, (uint32_t )15}}}, 
        {(int const   )1,
      (int const   )8922, "AMD AM29LV800BT", (long const   )1048576, (uint8_t const   )1,
      (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )65536, (uint32_t )15},
                                         {(uint32_t )983040, (uint32_t )32768, (uint32_t )1},
                                         {(uint32_t )1015808, (uint32_t )8192, (uint32_t )2},
                                         {(uint32_t )1032192, (uint32_t )16384, (uint32_t )1}}}, 
        {(int const   )1,
      (int const   )8918, "AMD AM29F800BT", (long const   )1048576, (uint8_t const   )1,
      (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )65536, (uint32_t )15},
                                         {(uint32_t )983040, (uint32_t )32768, (uint32_t )1},
                                         {(uint32_t )1015808, (uint32_t )8192, (uint32_t )2},
                                         {(uint32_t )1032192, (uint32_t )16384, (uint32_t )1}}}, 
        {(int const   )1,
      (int const   )8795, "AMD AM29LV800BB", (long const   )1048576, (uint8_t const   )1,
      (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )65536, (uint32_t )15},
                                         {(uint32_t )983040, (uint32_t )32768, (uint32_t )1},
                                         {(uint32_t )1015808, (uint32_t )8192, (uint32_t )2},
                                         {(uint32_t )1032192, (uint32_t )16384, (uint32_t )1}}}, 
        {(int const   )4,
      (int const   )8795, "Fujitsu MBM29LV800BB", (long const   )1048576, (uint8_t const   )1,
      (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )16384, (uint32_t )1},
                                         {(uint32_t )16384, (uint32_t )8192, (uint32_t )2},
                                         {(uint32_t )32768, (uint32_t )32768, (uint32_t )1},
                                         {(uint32_t )65536, (uint32_t )65536, (uint32_t )15}}}, 
        {(int const   )32,
      (int const   )215, "ST M29W800T", (long const   )1048576, (uint8_t const   )1,
      (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )65536, (uint32_t )15},
                                         {(uint32_t )983040, (uint32_t )32768, (uint32_t )1},
                                         {(uint32_t )1015808, (uint32_t )8192, (uint32_t )2},
                                         {(uint32_t )1032192, (uint32_t )16384, (uint32_t )1}}}, 
        {(int const   )32,
      (int const   )8900, "ST M29W160DT", (long const   )2097152, (uint8_t const   )1,
      (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )65536, (uint32_t )31},
                                         {(uint32_t )2031616, (uint32_t )32768, (uint32_t )1},
                                         {(uint32_t )2064384, (uint32_t )8192, (uint32_t )2},
                                         {(uint32_t )2080768, (uint32_t )16384, (uint32_t )1}}}, 
        {(int const   )32,
      (int const   )8777, "ST M29W160DB", (long const   )2097152, (uint8_t const   )1,
      (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )16384, (uint32_t )1},
                                         {(uint32_t )16384, (uint32_t )8192, (uint32_t )2},
                                         {(uint32_t )32768, (uint32_t )32768, (uint32_t )1},
                                         {(uint32_t )65536, (uint32_t )65536, (uint32_t )31}}}, 
        {(int const   )1,
      (int const   )8913, "AMD AM29BDS323D", (long const   )4194304, (uint8_t const   )1,
      (int const   )0, (int const   )3, {{(uint32_t )0, (uint32_t )65536, (uint32_t )48},
                                         {(uint32_t )3145728, (uint32_t )65536, (uint32_t )15},
                                         {(uint32_t )4128768, (uint32_t )8192, (uint32_t )8}}}, 
        {(int const   )1,
      (int const   )8830, "AMD AM29BDS643D", (long const   )8388608, (uint8_t const   )1,
      (int const   )0, (int const   )3, {{(uint32_t )0, (uint32_t )65536, (uint32_t )96},
                                         {(uint32_t )6291456, (uint32_t )65536, (uint32_t )31},
                                         {(uint32_t )8323072, (uint32_t )8192, (uint32_t )8}}}, 
        {(int const   )31,
      (int const   )192, "Atmel AT49xV16x", (long const   )2097152, (uint8_t const   )1,
      (int const   )0, (int const   )2, {{(uint32_t )0, (uint32_t )8192, (uint32_t )8},
                                         {(uint32_t )65536, (uint32_t )65536, (uint32_t )31}}}, 
        {(int const   )31,
      (int const   )194, "Atmel AT49xV16xT", (long const   )2097152, (uint8_t const   )1,
      (int const   )0, (int const   )2, {{(uint32_t )0, (uint32_t )65536, (uint32_t )31},
                                         {(uint32_t )2031616, (uint32_t )8192, (uint32_t )8}}}, 
        {(int const   )194,
      (int const   )8889, "MX 29LV400T", (long const   )524288, (uint8_t const   )1,
      (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )65536, (uint32_t )7},
                                         {(uint32_t )458752, (uint32_t )32768, (uint32_t )1},
                                         {(uint32_t )491520, (uint32_t )8192, (uint32_t )2},
                                         {(uint32_t )507904, (uint32_t )16384, (uint32_t )1}}}, 
        {(int const   )1,
      (int const   )79, "AMD AM29LV040B", (long const   )524288, (uint8_t const   )0,
      (int const   )1, (int const   )1, {{(uint32_t )0, (uint32_t )65536, (uint32_t )8}}}};
#line 369 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/jedec.c"
int jedec_detect(bus_t *bus___0 , uint32_t adr , cfi_array_t **cfi_array___0 ) 
{ 
  int manid_as[2] ;
  int devid_as[2] ;
  int manid ;
  int devid ;
  int ba ;
  int bw ;
  int i ;
  int j ;
  cfi_query_structure_t *cfi ;
  bus_area_t area___0 ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  uint32_t tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t tmp___5 ;
  uint32_t tmp___6 ;
  void *tmp___7 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;

  {
  {
#line 375
  manid = 0;
#line 375
  devid = 0;
#line 381
  tmp = calloc((size_t )1, (size_t )sizeof(cfi_array_t ));
#line 381
  *cfi_array___0 = (cfi_array_t *)tmp;
  }
#line 382
  if (! *cfi_array___0) {
#line 383
    return (-2);
  }
  {
#line 385
  (*cfi_array___0)->bus = bus___0;
#line 386
  (*cfi_array___0)->address = adr;
#line 387
  tmp___0 = (*((bus___0->driver)->area))(bus___0, adr, & area___0);
  }
#line 387
  if (tmp___0 != 0) {
#line 388
    return (-8);
  }
#line 389
  bw = (int )area___0.width;
#line 390
  if (bw != 8) {
#line 390
    if (bw != 16) {
#line 390
      if (bw != 32) {
#line 391
        return (-3);
      }
    }
  }
  {
#line 392
  ba = bw / 8;
#line 392
  (*cfi_array___0)->bus_width = ba;
#line 394
  tmp___1 = calloc((size_t )1, (size_t )(sizeof(cfi_chip_t *) * (unsigned long )ba));
#line 394
  (*cfi_array___0)->cfi_chips = (cfi_chip_t **)tmp___1;
  }
#line 395
  if (! (*cfi_array___0)->cfi_chips) {
#line 396
    return (-2);
  }
  {
#line 398
  tmp___2 = calloc((size_t )1, (size_t )sizeof(cfi_chip_t ));
#line 398
  *((*cfi_array___0)->cfi_chips + 0) = (cfi_chip_t *)tmp___2;
  }
#line 399
  if (! *((*cfi_array___0)->cfi_chips + 0)) {
#line 400
    return (-2);
  }
  {
#line 403
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )240);
#line 404
  (*((bus___0->driver)->write))(bus___0, adr + 2730U, (uint32_t )170);
#line 405
  (*((bus___0->driver)->write))(bus___0, adr + 1365U, (uint32_t )85);
#line 406
  (*((bus___0->driver)->write))(bus___0, adr + 2730U, (uint32_t )144);
#line 408
  tmp___3 = (*((bus___0->driver)->read))(bus___0, adr);
#line 408
  manid_as[0] = (int )tmp___3;
#line 409
  tmp___4 = (*((bus___0->driver)->read))(bus___0, adr + 2U);
#line 409
  devid_as[0] = (int )tmp___4;
#line 410
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )240);
#line 413
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )240);
#line 414
  (*((bus___0->driver)->write))(bus___0, adr + 1365U, (uint32_t )170);
#line 415
  (*((bus___0->driver)->write))(bus___0, adr + 682U, (uint32_t )85);
#line 416
  (*((bus___0->driver)->write))(bus___0, adr + 1365U, (uint32_t )144);
#line 418
  tmp___5 = (*((bus___0->driver)->read))(bus___0, adr);
#line 418
  manid_as[1] = (int )tmp___5;
#line 419
  tmp___6 = (*((bus___0->driver)->read))(bus___0, adr + 1U);
#line 419
  devid_as[1] = (int )tmp___6;
#line 420
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )240);
#line 422
  i = 0;
  }
  {
#line 422
  while (1) {
    while_continue: /* CIL Label */ ;
#line 422
    if (! ((unsigned long )i < sizeof(table) / sizeof(struct amd_flash_info ))) {
#line 422
      goto while_break;
    }
#line 425
    manid = manid_as[table[i].as_method];
#line 426
    devid = devid_as[table[i].as_method];
#line 427
    if (manid == (int )table[i].mfr_id) {
#line 427
      if (devid == (int )table[i].dev_id) {
#line 427
        goto while_break;
      }
    }
#line 422
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 429
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"dev ID=%04x   man ID=%04x\n",
          devid, manid);
  }
#line 431
  if ((unsigned long )i == sizeof(table) / sizeof(struct amd_flash_info )) {
#line 432
    return (-4);
  }
#line 434
  cfi = & (*((*cfi_array___0)->cfi_chips + 0))->cfi;
#line 436
  cfi->identification_string.pri_id_code = (uint16_t )2;
#line 437
  cfi->identification_string.pri_vendor_tbl = (void *)0;
#line 438
  cfi->identification_string.alt_id_code = (uint16_t )0;
#line 439
  cfi->identification_string.alt_vendor_tbl = (void *)0;
#line 441
  cfi->device_geometry.device_size = (uint32_t )table[i].size;
#line 443
  cfi->device_geometry.device_interface = (uint16_t )table[i].interface_width;
  {
#line 445
  if ((int const   )table[i].interface_width == 0) {
#line 445
    goto case_0;
  }
#line 448
  if ((int const   )table[i].interface_width == 1) {
#line 448
    goto case_1;
  }
#line 451
  if ((int const   )table[i].interface_width == 2) {
#line 451
    goto case_2;
  }
#line 456
  if ((int const   )table[i].interface_width == 3) {
#line 456
    goto case_3;
  }
#line 459
  if ((int const   )table[i].interface_width == 4) {
#line 459
    goto case_4;
  }
#line 464
  goto switch_default;
  case_0: /* CIL Label */ 
#line 446
  (*((*cfi_array___0)->cfi_chips + 0))->width = 1;
#line 447
  goto switch_break;
  case_1: /* CIL Label */ 
#line 449
  (*((*cfi_array___0)->cfi_chips + 0))->width = 2;
#line 450
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 452
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: Unsupported interface geometry %s, falling back to %s\n",
          "CFI_INTERFACE_X8_X16", "CFI_INTERFACE_X16");
#line 453
  (*((*cfi_array___0)->cfi_chips + 0))->width = 2;
#line 454
  cfi->device_geometry.device_interface = (uint16_t )1;
  }
#line 455
  goto switch_break;
  case_3: /* CIL Label */ 
#line 457
  (*((*cfi_array___0)->cfi_chips + 0))->width = 4;
#line 458
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 460
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: Unsupported interface geometry %s, falling back to %s\n",
          "CFI_INTERFACE_X16_X32", "CFI_INTERFACE_X32");
#line 461
  (*((*cfi_array___0)->cfi_chips + 0))->width = 4;
#line 462
  cfi->device_geometry.device_interface = (uint16_t )3;
  }
#line 463
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 466
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Unsupported interface geometry %d, bailing out\n",
          (int const   )table[i].interface_width);
#line 467
  (*((*cfi_array___0)->cfi_chips + 0))->width = 1;
#line 468
  cfi->device_geometry.device_interface = (uint16_t )0;
  }
#line 469
  return (-5);
#line 470
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 473
  cfi->device_geometry.number_of_erase_regions = (uint8_t )table[i].numeraseregions;
#line 475
  tmp___7 = malloc((size_t )((unsigned long )cfi->device_geometry.number_of_erase_regions * sizeof(cfi_erase_block_region_t )));
#line 475
  cfi->device_geometry.erase_block_regions = (cfi_erase_block_region_t *)tmp___7;
  }
#line 477
  if (! cfi->device_geometry.erase_block_regions) {
#line 478
    return (-2);
  }
#line 480
  j = 0;
  {
#line 480
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 480
    if (! (j < (int )cfi->device_geometry.number_of_erase_regions)) {
#line 480
      goto while_break___0;
    }
#line 481
    (cfi->device_geometry.erase_block_regions + j)->erase_block_size = (uint32_t )table[i].regions[j].erasesize;
#line 483
    (cfi->device_geometry.erase_block_regions + j)->number_of_erase_blocks = (uint32_t )table[i].regions[j].numblocks;
#line 480
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 487
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Found %s flash,  size = %li bytes.\n",
          table[i].name, table[i].size);
  }
#line 489
  return (0);
}
}
#line 51 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/intel.c"
static int intel_flash_erase_block(cfi_array_t *cfi_array___0 , uint32_t adr ) ;
#line 52
static int intel_flash_unlock_block(cfi_array_t *cfi_array___0 , uint32_t adr ) ;
#line 53
static int intel_flash_program_single(cfi_array_t *cfi_array___0 , uint32_t adr ,
                                      uint32_t data ) ;
#line 54
static int intel_flash_program_buffer(cfi_array_t *cfi_array___0 , uint32_t adr ,
                                      uint32_t *buffer , int count ) ;
#line 55
static int intel_flash_program(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t *buffer ,
                               int count ) ;
#line 56
static int intel_flash_erase_block32(cfi_array_t *cfi_array___0 , uint32_t adr ) ;
#line 57
static int intel_flash_unlock_block32(cfi_array_t *cfi_array___0 , uint32_t adr ) ;
#line 58
static int intel_flash_program32_single(cfi_array_t *cfi_array___0 , uint32_t adr ,
                                        uint32_t data ) ;
#line 59
static int intel_flash_program32(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t *buffer ,
                                 int count ) ;
#line 62 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/intel.c"
static int intel_flash_autodetect32(cfi_array_t *cfi_array___0 ) 
{ 
  bus_area_t area___0 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 67
  tmp = (*(((cfi_array___0->bus)->driver)->area))(cfi_array___0->bus, cfi_array___0->address,
                                                  & area___0);
  }
#line 67
  if (tmp != 0) {
#line 68
    return (0);
  }
#line 70
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 256) {
#line 70
    goto _L;
  } else
#line 70
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 257) {
#line 70
    goto _L;
  } else
#line 70
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 1) {
#line 70
    goto _L;
  } else
#line 70
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 3) {
    _L: /* CIL Label */ 
#line 70
    if (area___0.width == 32U) {
#line 70
      tmp___0 = 1;
    } else {
#line 70
      tmp___0 = 0;
    }
  } else {
#line 70
    tmp___0 = 0;
  }
#line 70
  return (tmp___0);
}
}
#line 77 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/intel.c"
static int intel_flash_autodetect(cfi_array_t *cfi_array___0 ) 
{ 
  bus_area_t area___0 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 82
  tmp = (*(((cfi_array___0->bus)->driver)->area))(cfi_array___0->bus, cfi_array___0->address,
                                                  & area___0);
  }
#line 82
  if (tmp != 0) {
#line 83
    return (0);
  }
#line 85
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 256) {
#line 85
    goto _L;
  } else
#line 85
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 257) {
#line 85
    goto _L;
  } else
#line 85
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 1) {
#line 85
    goto _L;
  } else
#line 85
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 3) {
    _L: /* CIL Label */ 
#line 85
    if (area___0.width == 16U) {
#line 85
      tmp___0 = 1;
    } else {
#line 85
      tmp___0 = 0;
    }
  } else {
#line 85
    tmp___0 = 0;
  }
#line 85
  return (tmp___0);
}
}
#line 92 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/intel.c"
static int intel_flash_autodetect8(cfi_array_t *cfi_array___0 ) 
{ 
  bus_area_t area___0 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 97
  tmp = (*(((cfi_array___0->bus)->driver)->area))(cfi_array___0->bus, cfi_array___0->address,
                                                  & area___0);
  }
#line 97
  if (tmp != 0) {
#line 98
    return (0);
  }
#line 100
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 256) {
#line 100
    goto _L;
  } else
#line 100
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 257) {
#line 100
    goto _L;
  } else
#line 100
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 1) {
#line 100
    goto _L;
  } else
#line 100
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 3) {
    _L: /* CIL Label */ 
#line 100
    if (area___0.width == 8U) {
#line 100
      tmp___0 = 1;
    } else {
#line 100
      tmp___0 = 0;
    }
  } else {
#line 100
    tmp___0 = 0;
  }
#line 100
  return (tmp___0);
}
}
#line 107 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/intel.c"
static void _intel_flash_print_info(cfi_array_t *cfi_array___0 , int o ) 
{ 
  uint32_t mid ;
  uint32_t cid ;
  bus_t *bus___0 ;
  uint32_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  uint32_t tmp___5 ;
  char *tmp___6 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;

  {
  {
#line 111
  bus___0 = cfi_array___0->bus;
#line 113
  tmp = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 113
  mid = tmp & 255U;
  }
  {
#line 115
  if (mid == 137U) {
#line 115
    goto case_137;
  }
#line 118
  if (mid == 28U) {
#line 118
    goto case_28;
  }
#line 121
  if (mid == 44U) {
#line 121
    goto case_44;
  }
#line 124
  goto switch_default;
  case_137: /* CIL Label */ 
  {
#line 116
  tmp___0 = gettext("Manufacturer: %s\n");
#line 116
  printf((char const   */* __restrict  */)tmp___0, "Intel");
  }
#line 117
  goto switch_break;
  case_28: /* CIL Label */ 
  {
#line 119
  tmp___1 = gettext("Manufacturer: %s\n");
#line 119
  printf((char const   */* __restrict  */)tmp___1, "Mitsubishi");
  }
#line 120
  goto switch_break;
  case_44: /* CIL Label */ 
  {
#line 122
  tmp___2 = gettext("Manufacturer: %s\n");
#line 122
  printf((char const   */* __restrict  */)tmp___2, "Micron Technology");
  }
#line 123
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 125
  tmp___3 = gettext("Unknown manufacturer (0x%04X)!\n");
#line 125
  printf((char const   */* __restrict  */)tmp___3, mid);
  }
#line 126
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 129
  tmp___4 = gettext("Chip: ");
#line 129
  printf((char const   */* __restrict  */)tmp___4);
#line 130
  tmp___5 = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address + (uint32_t )(1 << o));
#line 130
  cid = tmp___5 & 65535U;
  }
  {
#line 132
  if (cid == 22U) {
#line 132
    goto case_22;
  }
#line 135
  if (cid == 23U) {
#line 135
    goto case_23;
  }
#line 138
  if (cid == 24U) {
#line 138
    goto case_24;
  }
#line 141
  if (cid == 29U) {
#line 141
    goto case_29;
  }
#line 144
  if (cid == 34817U) {
#line 144
    goto case_34817;
  }
#line 147
  if (cid == 34818U) {
#line 147
    goto case_34818;
  }
#line 150
  if (cid == 34819U) {
#line 150
    goto case_34819;
  }
#line 153
  if (cid == 34821U) {
#line 153
    goto case_34821;
  }
#line 156
  if (cid == 34822U) {
#line 156
    goto case_34822;
  }
#line 159
  if (cid == 34823U) {
#line 159
    goto case_34823;
  }
#line 162
  if (cid == 34827U) {
#line 162
    goto case_34827;
  }
#line 165
  if (cid == 34828U) {
#line 165
    goto case_34828;
  }
#line 168
  if (cid == 34829U) {
#line 168
    goto case_34829;
  }
#line 171
  if (cid == 34830U) {
#line 171
    goto case_34830;
  }
#line 174
  if (cid == 34831U) {
#line 174
    goto case_34831;
  }
#line 177
  if (cid == 34832U) {
#line 177
    goto case_34832;
  }
#line 180
  goto switch_default___0;
  case_22: /* CIL Label */ 
  {
#line 133
  printf((char const   */* __restrict  */)"28F320J3A\n");
  }
#line 134
  goto switch_break___0;
  case_23: /* CIL Label */ 
  {
#line 136
  printf((char const   */* __restrict  */)"28F640J3A\n");
  }
#line 137
  goto switch_break___0;
  case_24: /* CIL Label */ 
  {
#line 139
  printf((char const   */* __restrict  */)"28F128J3A\n");
  }
#line 140
  goto switch_break___0;
  case_29: /* CIL Label */ 
  {
#line 142
  printf((char const   */* __restrict  */)"28F256J3A\n");
  }
#line 143
  goto switch_break___0;
  case_34817: /* CIL Label */ 
  {
#line 145
  printf((char const   */* __restrict  */)"28F640K3\n");
  }
#line 146
  goto switch_break___0;
  case_34818: /* CIL Label */ 
  {
#line 148
  printf((char const   */* __restrict  */)"28F128K3\n");
  }
#line 149
  goto switch_break___0;
  case_34819: /* CIL Label */ 
  {
#line 151
  printf((char const   */* __restrict  */)"28F256K3\n");
  }
#line 152
  goto switch_break___0;
  case_34821: /* CIL Label */ 
  {
#line 154
  printf((char const   */* __restrict  */)"28F640K18\n");
  }
#line 155
  goto switch_break___0;
  case_34822: /* CIL Label */ 
  {
#line 157
  printf((char const   */* __restrict  */)"28F128K18\n");
  }
#line 158
  goto switch_break___0;
  case_34823: /* CIL Label */ 
  {
#line 160
  printf((char const   */* __restrict  */)"28F256K18\n");
  }
#line 161
  goto switch_break___0;
  case_34827: /* CIL Label */ 
  {
#line 163
  printf((char const   */* __restrict  */)"GE28F640L18T\n");
  }
#line 164
  goto switch_break___0;
  case_34828: /* CIL Label */ 
  {
#line 166
  printf((char const   */* __restrict  */)"GE28F128L18T\n");
  }
#line 167
  goto switch_break___0;
  case_34829: /* CIL Label */ 
  {
#line 169
  printf((char const   */* __restrict  */)"GE28F256L18T\n");
  }
#line 170
  goto switch_break___0;
  case_34830: /* CIL Label */ 
  {
#line 172
  printf((char const   */* __restrict  */)"GE28F640L18B\n");
  }
#line 173
  goto switch_break___0;
  case_34831: /* CIL Label */ 
  {
#line 175
  printf((char const   */* __restrict  */)"GE28F128L18B\n");
  }
#line 176
  goto switch_break___0;
  case_34832: /* CIL Label */ 
  {
#line 178
  printf((char const   */* __restrict  */)"GE28F256L18B\n");
  }
#line 179
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 181
  tmp___6 = gettext("Unknown (0x%02X)!\n");
#line 181
  printf((char const   */* __restrict  */)tmp___6, cid);
  }
#line 182
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 186
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )16711935);
  }
#line 187
  return;
}
}
#line 189 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/intel.c"
static void intel_flash_print_info(cfi_array_t *cfi_array___0 ) 
{ 
  int o ;
  bus_t *bus___0 ;

  {
  {
#line 192
  o = 1;
#line 193
  bus___0 = cfi_array___0->bus;
#line 199
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )80);
#line 202
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )144);
#line 204
  _intel_flash_print_info(cfi_array___0, o);
  }
#line 205
  return;
}
}
#line 207 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/intel.c"
static void intel_flash_print_info32(cfi_array_t *cfi_array___0 ) 
{ 
  int o ;
  bus_t *bus___0 ;

  {
  {
#line 210
  o = 2;
#line 211
  bus___0 = cfi_array___0->bus;
#line 216
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )5242960);
#line 219
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )9437328);
#line 221
  _intel_flash_print_info(cfi_array___0, o);
  }
#line 222
  return;
}
}
#line 224 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/intel.c"
static int intel_flash_erase_block(cfi_array_t *cfi_array___0 , uint32_t adr ) 
{ 
  uint16_t sr ;
  bus_t *bus___0 ;
  uint32_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 228
  bus___0 = cfi_array___0->bus;
#line 230
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )80);
#line 231
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )32);
#line 232
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )208);
  }
  {
#line 234
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 234
    tmp = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 234
    sr = (uint16_t )(tmp & 254U);
    }
#line 234
    if ((int )sr & (1 << 7)) {
#line 234
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 237
  if (((int )sr & ~ (1 << 7)) == 0) {
#line 237
    goto case_0;
  }
#line 239
  if (((int )sr & ~ (1 << 7)) == ((1 << 5) | (1 << 4))) {
#line 239
    goto case_exp;
  }
#line 242
  if (((int )sr & ~ (1 << 7)) == ((1 << 5) | (1 << 3))) {
#line 242
    goto case_exp___0;
  }
#line 245
  if (((int )sr & ~ (1 << 7)) == ((1 << 5) | (1 << 1))) {
#line 245
    goto case_exp___1;
  }
#line 248
  goto switch_default;
  case_0: /* CIL Label */ 
#line 238
  return (0);
  case_exp: /* CIL Label */ 
  {
#line 240
  tmp___0 = gettext("flash: invalid command seq\n");
#line 240
  printf((char const   */* __restrict  */)tmp___0);
  }
#line 241
  return (1);
  case_exp___0: /* CIL Label */ 
  {
#line 243
  tmp___1 = gettext("flash: low vpen\n");
#line 243
  printf((char const   */* __restrict  */)tmp___1);
  }
#line 244
  return (2);
  case_exp___1: /* CIL Label */ 
  {
#line 246
  tmp___2 = gettext("flash: block locked\n");
#line 246
  printf((char const   */* __restrict  */)tmp___2);
  }
#line 247
  return (3);
  switch_default: /* CIL Label */ 
#line 249
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 252
  return (99);
}
}
#line 255 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/intel.c"
static int intel_flash_unlock_block(cfi_array_t *cfi_array___0 , uint32_t adr ) 
{ 
  uint16_t sr ;
  bus_t *bus___0 ;
  uint32_t tmp ;
  char *tmp___0 ;
  char *__cil_tmp7 ;

  {
  {
#line 259
  bus___0 = cfi_array___0->bus;
#line 261
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )80);
#line 262
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )96);
#line 263
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )208);
  }
  {
#line 265
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 265
    tmp = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 265
    sr = (uint16_t )(tmp & 254U);
    }
#line 265
    if ((int )sr & (1 << 7)) {
#line 265
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 267
  if ((int )sr != 1 << 7) {
    {
#line 268
    tmp___0 = gettext("flash: unknown error while unblocking\n");
#line 268
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 269
    return (99);
  } else {
#line 271
    return (0);
  }
}
}
#line 274 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/intel.c"
static int intel_flash_program_single(cfi_array_t *cfi_array___0 , uint32_t adr ,
                                      uint32_t data ) 
{ 
  uint16_t sr ;
  bus_t *bus___0 ;
  uint32_t tmp ;
  char *tmp___0 ;
  char *__cil_tmp8 ;

  {
  {
#line 278
  bus___0 = cfi_array___0->bus;
#line 280
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )80);
#line 281
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )64);
#line 282
  (*((bus___0->driver)->write))(bus___0, adr, data);
  }
  {
#line 284
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 284
    tmp = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 284
    sr = (uint16_t )(tmp & 254U);
    }
#line 284
    if ((int )sr & (1 << 7)) {
#line 284
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 286
  if ((int )sr != 1 << 7) {
    {
#line 287
    tmp___0 = gettext("flash: unknown error while programming\n");
#line 287
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 288
    return (99);
  } else {
#line 290
    return (0);
  }
}
}
#line 293 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/intel.c"
static int intel_flash_program_buffer(cfi_array_t *cfi_array___0 , uint32_t adr ,
                                      uint32_t *buffer , int count ) 
{ 
  uint16_t sr ;
  bus_t *bus___0 ;
  cfi_chip_t *cfi_chip ;
  int wb_bytes ;
  int chip_width ;
  int offset ;
  int wcount ;
  int idx ;
  uint32_t block_adr ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp17 ;

  {
#line 298
  bus___0 = cfi_array___0->bus;
#line 299
  cfi_chip = *(cfi_array___0->cfi_chips + 0);
#line 300
  wb_bytes = (int )cfi_chip->cfi.device_geometry.max_bytes_write;
#line 301
  chip_width = cfi_chip->width;
#line 302
  offset = 0;
  {
#line 304
  while (1) {
    while_continue: /* CIL Label */ ;
#line 304
    if (! (count > 0)) {
#line 304
      goto while_break;
    }
#line 306
    block_adr = adr;
#line 309
    wcount = (int )((unsigned int )wb_bytes - adr % (unsigned int )wb_bytes);
#line 310
    wcount /= chip_width;
#line 311
    if (wcount > count) {
#line 312
      wcount = count;
    }
    {
#line 315
    (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )80);
#line 316
    (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )232);
    }
    {
#line 318
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 318
      tmp = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 318
      sr = (uint16_t )(tmp & 254U);
      }
#line 318
      if ((int )sr & (1 << 7)) {
#line 318
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 321
    (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )(wcount - 1));
#line 324
    idx = 0;
    }
    {
#line 324
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 324
      if (! (idx < wcount)) {
#line 324
        goto while_break___1;
      }
      {
#line 325
      (*((bus___0->driver)->write))(bus___0, adr, *(buffer + (offset + idx)));
#line 326
      adr += (uint32_t )cfi_array___0->bus_width;
#line 324
      idx ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 328
    offset += wcount;
#line 331
    (*((bus___0->driver)->write))(bus___0, block_adr, (uint32_t )208);
#line 333
    count -= wcount;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 337
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 337
    tmp___0 = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 337
    sr = (uint16_t )(tmp___0 & 254U);
    }
#line 337
    if ((int )sr & (1 << 7)) {
#line 337
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 338
  if ((int )sr != 1 << 7) {
    {
#line 339
    tmp___1 = gettext("flash: unknown error while programming\n");
#line 339
    printf((char const   */* __restrict  */)tmp___1);
    }
#line 340
    return (99);
  }
#line 343
  return (0);
}
}
#line 346 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/intel.c"
static int intel_flash_program(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t *buffer ,
                               int count ) 
{ 
  cfi_query_structure_t *cfi ;
  int max_bytes_write ;
  int tmp ;
  int idx ;
  int status ;
  int tmp___0 ;

  {
#line 349
  cfi = & (*(cfi_array___0->cfi_chips + 0))->cfi;
#line 350
  max_bytes_write = (int )cfi->device_geometry.max_bytes_write;
#line 357
  if (max_bytes_write > 1) {
    {
#line 358
    tmp = intel_flash_program_buffer(cfi_array___0, adr, buffer, count);
    }
#line 358
    return (tmp);
  } else {
#line 364
    idx = 0;
    {
#line 364
    while (1) {
      while_continue: /* CIL Label */ ;
#line 364
      if (! (idx < count)) {
#line 364
        goto while_break;
      }
      {
#line 365
      tmp___0 = intel_flash_program_single(cfi_array___0, adr, *(buffer + idx));
#line 365
      status = tmp___0;
      }
#line 366
      if (status) {
#line 367
        return (status);
      }
#line 368
      adr += (uint32_t )cfi_array___0->bus_width;
#line 364
      idx ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 372
  return (0);
}
}
#line 375 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/intel.c"
static int intel_flash_erase_block32(cfi_array_t *cfi_array___0 , uint32_t adr ) 
{ 
  uint32_t sr ;
  bus_t *bus___0 ;
  uint32_t tmp ;
  char *__cil_tmp6 ;

  {
  {
#line 379
  bus___0 = cfi_array___0->bus;
#line 381
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )((80 << 16) | 80));
#line 382
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )((32 << 16) | 32));
#line 383
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )((208 << 16) | 208));
  }
  {
#line 385
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 385
    tmp = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 385
    sr = tmp & 16646398U;
    }
#line 385
    if (! ((sr & (unsigned int )(((1 << 7) << 16) | (1 << 7))) != (unsigned int )(((1 << 7) << 16) | (1 << 7)))) {
#line 385
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 387
  if (sr != (uint32_t )(((1 << 7) << 16) | (1 << 7))) {
    {
#line 388
    printf((char const   */* __restrict  */)"\nsr = 0x%08X\n", sr);
    }
#line 389
    return (99);
  } else {
#line 391
    return (0);
  }
}
}
#line 394 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/intel.c"
static int intel_flash_unlock_block32(cfi_array_t *cfi_array___0 , uint32_t adr ) 
{ 
  uint32_t sr ;
  bus_t *bus___0 ;
  uint32_t tmp ;
  char *__cil_tmp6 ;

  {
  {
#line 398
  bus___0 = cfi_array___0->bus;
#line 400
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )((80 << 16) | 80));
#line 401
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )((96 << 16) | 96));
#line 402
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )((208 << 16) | 208));
  }
  {
#line 404
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 404
    tmp = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 404
    sr = tmp & 16646398U;
    }
#line 404
    if (! ((sr & (unsigned int )(((1 << 7) << 16) | (1 << 7))) != (unsigned int )(((1 << 7) << 16) | (1 << 7)))) {
#line 404
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 406
  if (sr != (uint32_t )(((1 << 7) << 16) | (1 << 7))) {
    {
#line 407
    printf((char const   */* __restrict  */)"\nsr = 0x%08X\n", sr);
    }
#line 408
    return (99);
  } else {
#line 410
    return (0);
  }
}
}
#line 413 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/intel.c"
static int intel_flash_program32_single(cfi_array_t *cfi_array___0 , uint32_t adr ,
                                        uint32_t data ) 
{ 
  uint32_t sr ;
  bus_t *bus___0 ;
  uint32_t tmp ;
  char *__cil_tmp7 ;

  {
  {
#line 417
  bus___0 = cfi_array___0->bus;
#line 419
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )((80 << 16) | 80));
#line 420
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )((64 << 16) | 64));
#line 421
  (*((bus___0->driver)->write))(bus___0, adr, data);
  }
  {
#line 423
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 423
    tmp = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 423
    sr = tmp & 16646398U;
    }
#line 423
    if (! ((sr & (unsigned int )(((1 << 7) << 16) | (1 << 7))) != (unsigned int )(((1 << 7) << 16) | (1 << 7)))) {
#line 423
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 425
  if (sr != (uint32_t )(((1 << 7) << 16) | (1 << 7))) {
    {
#line 426
    printf((char const   */* __restrict  */)"\nsr = 0x%08X\n", sr);
    }
#line 427
    return (99);
  } else {
#line 429
    return (0);
  }
}
}
#line 432 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/intel.c"
static int intel_flash_program32(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t *buffer ,
                                 int count ) 
{ 
  int idx ;
  int status ;
  int tmp ;

  {
#line 442
  idx = 0;
  {
#line 442
  while (1) {
    while_continue: /* CIL Label */ ;
#line 442
    if (! (idx < count)) {
#line 442
      goto while_break;
    }
    {
#line 443
    tmp = intel_flash_program32_single(cfi_array___0, adr, *(buffer + idx));
#line 443
    status = tmp;
    }
#line 444
    if (status) {
#line 445
      return (status);
    }
#line 446
    adr += (uint32_t )cfi_array___0->bus_width;
#line 442
    idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 449
  return (0);
}
}
#line 452 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/intel.c"
static void intel_flash_readarray32(cfi_array_t *cfi_array___0 ) 
{ 


  {
  {
#line 456
  (*(((cfi_array___0->bus)->driver)->write))(cfi_array___0->bus, cfi_array___0->address,
                                             (uint32_t )16711935);
  }
#line 457
  return;
}
}
#line 459 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/intel.c"
static void intel_flash_readarray(cfi_array_t *cfi_array___0 ) 
{ 


  {
  {
#line 463
  (*(((cfi_array___0->bus)->driver)->write))(cfi_array___0->bus, cfi_array___0->address,
                                             (uint32_t )16711935);
  }
#line 464
  return;
}
}
#line 466 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/intel.c"
flash_driver_t intel_32_flash_driver  = 
#line 466
     {4U, "Intel Standard Command Set", "supported: 28Fxxxx, 2 x 16 bit", & intel_flash_autodetect32,
    & intel_flash_print_info32, & intel_flash_erase_block32, & intel_flash_unlock_block32,
    & intel_flash_program32, & intel_flash_readarray32};
#line 478 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/intel.c"
flash_driver_t intel_16_flash_driver  = 
#line 478
     {2U, "Intel Standard Command Set", "supported: 28Fxxxx, 1 x 16 bit", & intel_flash_autodetect,
    & intel_flash_print_info, & intel_flash_erase_block, & intel_flash_unlock_block,
    & intel_flash_program, & intel_flash_readarray};
#line 490 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/intel.c"
flash_driver_t intel_8_flash_driver  = 
#line 490
     {1U, "Intel Standard Command Set", "supported: 28Fxxxx, 1 x 8 bit", & intel_flash_autodetect8,
    & intel_flash_print_info, & intel_flash_erase_block, & intel_flash_unlock_block,
    & intel_flash_program, & intel_flash_readarray};
#line 722 "/usr/include/stdio.h"
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 83 "../../include/flash.h"
void flashmem(bus_t *bus___0 , FILE *f , uint32_t addr , int noverify ) ;
#line 84
void flashmsbin(bus_t *bus___0 , FILE *f , int noverify ) ;
#line 88
flash_driver_t *flash_drivers[8] ;
#line 61 "../../include/jtag.h"
void flasherase(bus_t *bus___0 , uint32_t addr , int number ) ;
#line 49 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/flash.c"
flash_driver_t amd_32_flash_driver ;
#line 50
flash_driver_t amd_16_flash_driver ;
#line 51
flash_driver_t amd_8_flash_driver ;
#line 55
flash_driver_t amd_29xx040_flash_driver ;
#line 57 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/flash.c"
flash_driver_t *flash_drivers[8]  = 
#line 57
  {      & amd_32_flash_driver,      & amd_16_flash_driver,      & amd_8_flash_driver,      & intel_32_flash_driver, 
        & intel_16_flash_driver,      & intel_8_flash_driver,      & amd_29xx040_flash_driver,      (flash_driver_t *)((void *)0)};
#line 68
cfi_array_t *cfi_array ;
#line 69 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/flash.c"
static flash_driver_t *flash_driver  =    (flash_driver_t *)((void *)0);
#line 71 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/flash.c"
static void set_flash_driver(void) 
{ 
  int i ;
  cfi_query_structure_t *cfi ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 77
  flash_driver = (flash_driver_t *)((void *)0);
#line 78
  if ((unsigned long )cfi_array == (unsigned long )((void *)0)) {
#line 79
    return;
  }
#line 80
  cfi = & (*(cfi_array->cfi_chips + 0))->cfi;
#line 82
  i = 0;
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    if (! ((unsigned long )flash_drivers[i] != (unsigned long )((void *)0))) {
#line 82
      goto while_break;
    }
    {
#line 83
    tmp = (*((flash_drivers[i])->autodetect))(cfi_array);
    }
#line 83
    if (tmp) {
      {
#line 84
      flash_driver = flash_drivers[i];
#line 85
      (*(flash_driver->print_info))(cfi_array);
      }
#line 86
      return;
    }
#line 82
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 89
  tmp___0 = gettext("unknown flash - vendor id: %d (0x%04x)\n");
#line 89
  printf((char const   */* __restrict  */)tmp___0, (int )cfi->identification_string.pri_id_code,
         (int )cfi->identification_string.pri_id_code);
#line 93
  tmp___1 = gettext("Flash not supported!\n");
#line 93
  printf((char const   */* __restrict  */)tmp___1);
  }
#line 94
  return;
}
}
#line 96 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/flash.c"
void flashmsbin(bus_t *bus___0 , FILE *f , int noverify ) 
{ 
  uint32_t adr ;
  cfi_query_structure_t *cfi ;
  char *tmp ;
  char sync[8] ;
  char *tmp___0 ;
  int tmp___1 ;
  uint32_t start ;
  uint32_t len ;
  int first ;
  int last ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  uint32_t a ;
  uint32_t l ;
  uint32_t c ;
  char *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  uint32_t data ;
  char *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  uint32_t a___0 ;
  uint32_t l___0 ;
  uint32_t c___0 ;
  char *tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  uint32_t data___0 ;
  uint32_t readed ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  void *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;

  {
  {
#line 102
  set_flash_driver();
  }
#line 103
  if (! cfi_array) {
    {
#line 104
    tmp = gettext("no flash driver found\n");
#line 104
    printf((char const   */* __restrict  */)tmp);
    }
#line 105
    return;
  } else
#line 103
  if (! flash_driver) {
    {
#line 104
    tmp = gettext("no flash driver found\n");
#line 104
    printf((char const   */* __restrict  */)tmp);
    }
#line 105
    return;
  }
  {
#line 107
  cfi = & (*(cfi_array->cfi_chips + 0))->cfi;
#line 112
  fread((void */* __restrict  */)(& sync), (size_t )sizeof(char ), (size_t )7, (FILE */* __restrict  */)f);
#line 113
  sync[7] = (char )'\000';
#line 114
  tmp___1 = strcmp("B000FF\n", (char const   *)(sync));
  }
#line 114
  if (tmp___1 != 0) {
    {
#line 115
    tmp___0 = gettext("Invalid sync sequence!\n");
#line 115
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 116
    return;
  }
  {
#line 126
  fread((void */* __restrict  */)(& start), (size_t )sizeof(start), (size_t )1, (FILE */* __restrict  */)f);
#line 127
  fread((void */* __restrict  */)(& len), (size_t )sizeof(len), (size_t )1, (FILE */* __restrict  */)f);
#line 128
  first = (int )(start / ((cfi->device_geometry.erase_block_regions + 0)->erase_block_size * 2U));
#line 129
  last = (int )(((start + len) - 1U) / ((cfi->device_geometry.erase_block_regions + 0)->erase_block_size * 2U));
  }
  {
#line 130
  while (1) {
    while_continue: /* CIL Label */ ;
#line 130
    if (! (first <= last)) {
#line 130
      goto while_break;
    }
    {
#line 131
    adr = ((uint32_t )first * (cfi->device_geometry.erase_block_regions + 0)->erase_block_size) * 2U;
#line 132
    (*(flash_driver->unlock_block))(cfi_array, adr);
#line 133
    tmp___2 = gettext("block %d unlocked\n");
#line 133
    printf((char const   */* __restrict  */)tmp___2, first);
#line 134
    tmp___3 = (*(flash_driver->erase_block))(cfi_array, adr);
#line 134
    tmp___4 = gettext("erasing block %d: %d\n");
#line 134
    printf((char const   */* __restrict  */)tmp___4, first, tmp___3);
#line 130
    first ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 138
  tmp___5 = gettext("program:\n");
#line 138
  printf((char const   */* __restrict  */)tmp___5);
  }
  {
#line 139
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 142
    fread((void */* __restrict  */)(& a), (size_t )sizeof(a), (size_t )1, (FILE */* __restrict  */)f);
#line 143
    fread((void */* __restrict  */)(& l), (size_t )sizeof(l), (size_t )1, (FILE */* __restrict  */)f);
#line 144
    fread((void */* __restrict  */)(& c), (size_t )sizeof(c), (size_t )1, (FILE */* __restrict  */)f);
#line 145
    tmp___7 = feof(f);
    }
#line 145
    if (tmp___7) {
      {
#line 146
      tmp___6 = gettext("Error: premature end of file\n");
#line 146
      printf((char const   */* __restrict  */)tmp___6);
      }
#line 147
      return;
    }
    {
#line 149
    tmp___8 = gettext("record: start = 0x%08X, len = 0x%08X, checksum = 0x%08X\n");
#line 149
    printf((char const   */* __restrict  */)tmp___8, a, l, c);
    }
#line 150
    if (a == 0U) {
#line 150
      if (c == 0U) {
#line 151
        goto while_break___0;
      }
    }
#line 152
    if (l & 3U) {
      {
#line 153
      tmp___9 = gettext("Error: Invalid record length!\n");
#line 153
      printf((char const   */* __restrict  */)tmp___9);
      }
#line 154
      return;
    }
    {
#line 157
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 157
      if (! l) {
#line 157
        goto while_break___1;
      }
      {
#line 160
      tmp___10 = gettext("addr: 0x%08X");
#line 160
      printf((char const   */* __restrict  */)tmp___10, a);
#line 161
      printf((char const   */* __restrict  */)"\r");
#line 162
      fflush(stdout);
#line 163
      fread((void */* __restrict  */)(& data), (size_t )sizeof(data), (size_t )1,
            (FILE */* __restrict  */)f);
#line 164
      tmp___12 = (*(flash_driver->program))(cfi_array, a, & data, 1);
      }
#line 164
      if (tmp___12) {
        {
#line 165
        tmp___11 = gettext("\nflash error\n");
#line 165
        printf((char const   */* __restrict  */)tmp___11);
        }
#line 166
        return;
      }
#line 168
      a += 4U;
#line 169
      l -= 4U;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 172
  printf((char const   */* __restrict  */)"\n");
#line 174
  (*(flash_driver->readarray))(cfi_array);
  }
#line 176
  if (noverify) {
    {
#line 177
    tmp___13 = gettext("verify skipped\n");
#line 177
    printf((char const   */* __restrict  */)tmp___13);
    }
#line 178
    return;
  }
  {
#line 181
  fseek(f, 15L, 0);
#line 182
  tmp___14 = gettext("verify:\n");
#line 182
  printf((char const   */* __restrict  */)tmp___14);
  }
  {
#line 184
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 187
    fread((void */* __restrict  */)(& a___0), (size_t )sizeof(a___0), (size_t )1,
          (FILE */* __restrict  */)f);
#line 188
    fread((void */* __restrict  */)(& l___0), (size_t )sizeof(l___0), (size_t )1,
          (FILE */* __restrict  */)f);
#line 189
    fread((void */* __restrict  */)(& c___0), (size_t )sizeof(c___0), (size_t )1,
          (FILE */* __restrict  */)f);
#line 190
    tmp___16 = feof(f);
    }
#line 190
    if (tmp___16) {
      {
#line 191
      tmp___15 = gettext("Error: premature end of file\n");
#line 191
      printf((char const   */* __restrict  */)tmp___15);
      }
#line 192
      return;
    }
    {
#line 194
    tmp___17 = gettext("record: start = 0x%08X, len = 0x%08X, checksum = 0x%08X\n");
#line 194
    printf((char const   */* __restrict  */)tmp___17, a___0, l___0, c___0);
    }
#line 195
    if (a___0 == 0U) {
#line 195
      if (c___0 == 0U) {
#line 196
        goto while_break___2;
      }
    }
#line 197
    if (l___0 & 3U) {
      {
#line 198
      tmp___18 = gettext("Error: Invalid record length!\n");
#line 198
      printf((char const   */* __restrict  */)tmp___18);
      }
#line 199
      return;
    }
    {
#line 202
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 202
      if (! l___0) {
#line 202
        goto while_break___3;
      }
      {
#line 205
      tmp___19 = gettext("addr: 0x%08X");
#line 205
      printf((char const   */* __restrict  */)tmp___19, a___0);
#line 206
      printf((char const   */* __restrict  */)"\r");
#line 207
      fflush(stdout);
#line 208
      fread((void */* __restrict  */)(& data___0), (size_t )sizeof(data___0), (size_t )1,
            (FILE */* __restrict  */)f);
#line 209
      readed = (*((bus___0->driver)->read))(bus___0, a___0);
      }
#line 210
      if (data___0 != readed) {
        {
#line 211
        tmp___20 = gettext("\nverify error: 0x%08X vs. 0x%08X at addr %08X\n");
#line 211
        printf((char const   */* __restrict  */)tmp___20, readed, data___0, a___0);
        }
#line 213
        return;
      }
#line 215
      a___0 += 4U;
#line 216
      l___0 -= 4U;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 220
  tmp___21 = gettext("\nDone.\n");
#line 220
  printf((char const   */* __restrict  */)tmp___21);
  }
#line 221
  return;
}
}
#line 223 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/flash.c"
static int find_block(cfi_query_structure_t *cfi , int adr , int bus_width , int chip_width ,
                      int *bytes_until_next_block ) 
{ 
  int i ;
  int b ;
  int bb ;
  int region_blocks ;
  int flash_block_size ;
  int region_block_size ;
  int region_size ;
  int bir ;

  {
#line 227
  b = 0;
#line 228
  bb = 0;
#line 230
  i = 0;
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    if (! (i < (int )cfi->device_geometry.number_of_erase_regions)) {
#line 230
      goto while_break;
    }
#line 231
    region_blocks = (int )(cfi->device_geometry.erase_block_regions + i)->number_of_erase_blocks;
#line 232
    flash_block_size = (int )(cfi->device_geometry.erase_block_regions + i)->erase_block_size;
#line 233
    region_block_size = (bus_width / chip_width) * flash_block_size;
#line 234
    region_size = region_blocks * region_block_size;
#line 236
    if (adr < bb + region_size) {
#line 238
      bir = (adr - bb) / region_block_size;
#line 239
      *bytes_until_next_block = (bb + (bir + 1) * region_block_size) - adr;
#line 240
      return (b + bir);
    }
#line 242
    b += region_blocks;
#line 243
    bb += region_size;
#line 230
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 245
  return (-1);
}
}
#line 248 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/flash.c"
void flashmem(bus_t *bus___0 , FILE *f , uint32_t addr , int noverify ) 
{ 
  uint32_t adr ;
  cfi_query_structure_t *cfi ;
  int *erased ;
  int i ;
  int neb ;
  int bus_width ;
  int chip_width ;
  uint32_t write_buffer[1 << 12] ;
  int write_buffer_count ;
  uint32_t write_buffer_adr ;
  char *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  uint32_t data ;
  uint8_t b[1 << 12] ;
  int bc ;
  int bn ;
  int btr ;
  int block_no ;
  int tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int j ;
  char *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  uint32_t data___0 ;
  uint32_t readed ;
  uint8_t b___0[1 << 12] ;
  int bc___0 ;
  int bn___0 ;
  int btr___0 ;
  size_t tmp___16 ;
  int j___0 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  char *tmp___21 ;
  void *__cil_tmp52 ;
  void *__cil_tmp53 ;
  void *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;

  {
  {
#line 263
  set_flash_driver();
  }
#line 264
  if (! cfi_array) {
    {
#line 265
    tmp = gettext("no flash driver found\n");
#line 265
    printf((char const   */* __restrict  */)tmp);
    }
#line 266
    return;
  } else
#line 264
  if (! flash_driver) {
    {
#line 265
    tmp = gettext("no flash driver found\n");
#line 265
    printf((char const   */* __restrict  */)tmp);
    }
#line 266
    return;
  }
#line 268
  cfi = & (*(cfi_array->cfi_chips + 0))->cfi;
#line 270
  bus_width = cfi_array->bus_width;
#line 271
  chip_width = (*(cfi_array->cfi_chips + 0))->width;
#line 273
  i = 0;
#line 273
  neb = 0;
  {
#line 273
  while (1) {
    while_continue: /* CIL Label */ ;
#line 273
    if (! (i < (int )cfi->device_geometry.number_of_erase_regions)) {
#line 273
      goto while_break;
    }
#line 274
    neb = (int )((uint32_t )neb + (cfi->device_geometry.erase_block_regions + i)->number_of_erase_blocks);
#line 273
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 276
  tmp___0 = malloc((size_t )((unsigned long )neb * sizeof(*erased)));
#line 276
  erased = (int *)tmp___0;
  }
#line 277
  if (! erased) {
    {
#line 278
    tmp___1 = gettext("Out of memory!\n");
#line 278
    printf((char const   */* __restrict  */)tmp___1);
    }
#line 279
    return;
  }
#line 281
  i = 0;
  {
#line 281
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 281
    if (! (i < neb)) {
#line 281
      goto while_break___0;
    }
#line 282
    *(erased + i) = 0;
#line 281
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 284
  tmp___2 = gettext("program:\n");
#line 284
  printf((char const   */* __restrict  */)tmp___2);
#line 285
  adr = addr;
  }
  {
#line 286
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 286
    tmp___12 = feof(f);
    }
#line 286
    if (tmp___12) {
#line 286
      goto while_break___1;
    }
    {
#line 289
    bc = 0;
#line 289
    bn = 0;
#line 289
    btr = 1 << 12;
#line 290
    tmp___3 = find_block(cfi, (int )(adr - cfi_array->address), bus_width, chip_width,
                         & btr);
#line 290
    block_no = tmp___3;
#line 292
    write_buffer_count = 0;
#line 293
    write_buffer_adr = adr;
    }
#line 295
    if (btr > 1 << 12) {
#line 295
      btr = 1 << 12;
    }
    {
#line 296
    tmp___4 = fread((void */* __restrict  */)(b), (size_t )1, (size_t )btr, (FILE */* __restrict  */)f);
#line 296
    bn = (int )tmp___4;
    }
#line 298
    if (bn > 0) {
#line 298
      if (! *(erased + block_no)) {
        {
#line 299
        (*(flash_driver->unlock_block))(cfi_array, adr);
#line 300
        tmp___5 = gettext("\nblock %d unlocked\n");
#line 300
        printf((char const   */* __restrict  */)tmp___5, block_no);
#line 301
        tmp___6 = (*(flash_driver->erase_block))(cfi_array, adr);
#line 301
        tmp___7 = gettext("erasing block %d: %d\n");
#line 301
        printf((char const   */* __restrict  */)tmp___7, block_no, tmp___6);
#line 302
        *(erased + block_no) = 1;
        }
      }
    }
#line 305
    bc = 0;
    {
#line 305
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 305
      if (! (bc < bn)) {
#line 305
        goto while_break___2;
      }
#line 307
      if ((adr & (unsigned int )((1 << 12) - 1)) == 0U) {
        {
#line 308
        tmp___8 = gettext("addr: 0x%08X");
#line 308
        printf((char const   */* __restrict  */)tmp___8, adr);
#line 309
        printf((char const   */* __restrict  */)"\r");
#line 310
        fflush(stdout);
        }
      }
#line 313
      data = (uint32_t )0;
#line 314
      j = 0;
      {
#line 314
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 314
        if (! ((unsigned int )j < flash_driver->bus_width)) {
#line 314
          goto while_break___3;
        }
#line 315
        if (big_endian) {
#line 316
          data = (data << 8) | (unsigned int )b[bc + j];
        } else {
#line 318
          data |= (unsigned int )((int )b[bc + j] << j * 8);
        }
#line 314
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 321
      tmp___9 = write_buffer_count;
#line 321
      write_buffer_count ++;
#line 321
      write_buffer[tmp___9] = data;
#line 323
      adr += flash_driver->bus_width;
#line 305
      bc = (int )((unsigned int )bc + flash_driver->bus_width);
    }
    while_break___2: /* CIL Label */ ;
    }
#line 326
    if (write_buffer_count > 0) {
      {
#line 327
      tmp___11 = (*(flash_driver->program))(cfi_array, write_buffer_adr, write_buffer,
                                            write_buffer_count);
      }
#line 327
      if (tmp___11) {
        {
#line 328
        tmp___10 = gettext("\nflash error\n");
#line 328
        printf((char const   */* __restrict  */)tmp___10);
        }
#line 329
        return;
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 333
  free((void *)erased);
#line 335
  tmp___13 = gettext("addr: 0x%08X\n");
#line 335
  printf((char const   */* __restrict  */)tmp___13, adr - flash_driver->bus_width);
#line 337
  (*(flash_driver->readarray))(cfi_array);
  }
#line 339
  if (noverify) {
    {
#line 340
    tmp___14 = gettext("verify skipped\n");
#line 340
    printf((char const   */* __restrict  */)tmp___14);
    }
#line 341
    return;
  }
  {
#line 344
  fseek(f, 0L, 0);
#line 345
  tmp___15 = gettext("verify:\n");
#line 345
  printf((char const   */* __restrict  */)tmp___15);
#line 346
  fflush(stdout);
#line 347
  adr = addr;
  }
  {
#line 348
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 348
    tmp___20 = feof(f);
    }
#line 348
    if (tmp___20) {
#line 348
      goto while_break___4;
    }
    {
#line 351
    bc___0 = 0;
#line 351
    bn___0 = 0;
#line 351
    btr___0 = 1 << 12;
#line 353
    tmp___16 = fread((void */* __restrict  */)(b___0), (size_t )1, (size_t )btr___0,
                     (FILE */* __restrict  */)f);
#line 353
    bn___0 = (int )tmp___16;
#line 355
    bc___0 = 0;
    }
    {
#line 355
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 355
      if (! (bc___0 < bn___0)) {
#line 355
        goto while_break___5;
      }
#line 357
      if ((adr & 255U) == 0U) {
        {
#line 358
        tmp___17 = gettext("addr: 0x%08X");
#line 358
        printf((char const   */* __restrict  */)tmp___17, adr);
#line 359
        printf((char const   */* __restrict  */)"\r");
#line 360
        fflush(stdout);
        }
      }
#line 363
      data___0 = (uint32_t )0;
#line 364
      j___0 = 0;
      {
#line 364
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 364
        if (! ((unsigned int )j___0 < flash_driver->bus_width)) {
#line 364
          goto while_break___6;
        }
#line 365
        if (big_endian) {
#line 366
          data___0 = (data___0 << 8) | (unsigned int )b___0[bc___0 + j___0];
        } else {
#line 368
          data___0 |= (unsigned int )((int )b___0[bc___0 + j___0] << j___0 * 8);
        }
#line 364
        j___0 ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 370
      readed = (*((bus___0->driver)->read))(bus___0, adr);
      }
#line 371
      if (data___0 != readed) {
        {
#line 372
        tmp___18 = gettext("addr: 0x%08X\n");
#line 372
        printf((char const   */* __restrict  */)tmp___18, adr);
#line 373
        tmp___19 = gettext("verify error:\nread: 0x%08X\nexpected: 0x%08X\n");
#line 373
        printf((char const   */* __restrict  */)tmp___19, readed, data___0);
        }
#line 374
        return;
      }
#line 376
      adr += flash_driver->bus_width;
#line 355
      bc___0 = (int )((unsigned int )bc___0 + flash_driver->bus_width);
    }
    while_break___5: /* CIL Label */ ;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 379
  tmp___21 = gettext("addr: 0x%08X\nDone.\n");
#line 379
  printf((char const   */* __restrict  */)tmp___21, adr - flash_driver->bus_width);
  }
#line 380
  return;
}
}
#line 382 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/flash.c"
void flasherase(bus_t *bus___0 , uint32_t addr , int number ) 
{ 
  cfi_query_structure_t *cfi ;
  int i ;
  int status ;
  char *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  int addr_block ;
  int block_no ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;

  {
  {
#line 387
  status = 0;
#line 389
  set_flash_driver();
  }
#line 390
  if (! cfi_array) {
    {
#line 391
    tmp = gettext("no flash driver found\n");
#line 391
    printf((char const   */* __restrict  */)tmp);
    }
#line 392
    return;
  } else
#line 390
  if (! flash_driver) {
    {
#line 391
    tmp = gettext("no flash driver found\n");
#line 391
    printf((char const   */* __restrict  */)tmp);
    }
#line 392
    return;
  }
#line 394
  cfi = & (*(cfi_array->cfi_chips + 0))->cfi;
#line 396
  if (number > 1) {
#line 396
    tmp___0 = "s";
  } else {
#line 396
    tmp___0 = "";
  }
  {
#line 396
  tmp___1 = gettext("\nErasing %d Flash block%s from address 0x%x\n");
#line 396
  printf((char const   */* __restrict  */)tmp___1, number, tmp___0, addr);
#line 398
  i = 1;
  }
  {
#line 398
  while (1) {
    while_continue: /* CIL Label */ ;
#line 398
    if (! (i <= number)) {
#line 398
      goto while_break;
    }
    {
#line 399
    addr_block = (int )(((cfi->device_geometry.erase_block_regions + 0)->erase_block_size * flash_driver->bus_width) / 2U);
#line 400
    block_no = (int )(addr / (uint32_t )addr_block);
#line 401
    tmp___2 = gettext("(%d%% Completed) FLASH Block %d : Unlocking ... ");
#line 401
    printf((char const   */* __restrict  */)tmp___2, (i * 100) / number, block_no);
#line 402
    fflush(stdout);
#line 403
    (*(flash_driver->unlock_block))(cfi_array, addr);
#line 404
    tmp___3 = gettext("Erasing ... ");
#line 404
    printf((char const   */* __restrict  */)tmp___3);
#line 405
    fflush(stdout);
#line 406
    status = (*(flash_driver->erase_block))(cfi_array, addr);
    }
#line 407
    if (status == 0) {
#line 408
      if (i == number) {
        {
#line 409
        printf((char const   */* __restrict  */)"\r");
#line 410
        tmp___4 = gettext("(100%% Completed) FLASH Block %d : Unlocking ... Erasing ... Ok.\n");
#line 410
        printf((char const   */* __restrict  */)tmp___4, block_no);
        }
      } else {
        {
#line 412
        tmp___5 = gettext("Ok.");
#line 412
        printf((char const   */* __restrict  */)tmp___5);
#line 413
        printf((char const   */* __restrict  */)"\r");
#line 414
        tmp___6 = gettext("%78s");
#line 414
        printf((char const   */* __restrict  */)tmp___6, "");
#line 415
        printf((char const   */* __restrict  */)"\r");
        }
      }
    } else {
      {
#line 419
      tmp___7 = gettext("ERROR.\n");
#line 419
      printf((char const   */* __restrict  */)tmp___7);
      }
    }
#line 420
    addr |= (unsigned int )(addr_block - 1);
#line 421
    addr ++;
#line 398
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 424
  if (status == 0) {
    {
#line 425
    tmp___8 = gettext("\nErasing Completed.\n");
#line 425
    printf((char const   */* __restrict  */)tmp___8);
    }
  } else {
    {
#line 427
    tmp___9 = gettext("\nErasing Failed.\n");
#line 427
    printf((char const   */* __restrict  */)tmp___9);
    }
  }
#line 432
  return;
}
}
#line 58 "../../include/flash.h"
void cfi_array_free(cfi_array_t *cfi_array___0 ) ;
#line 59
int cfi_detect(bus_t *bus___0 , uint32_t adr , cfi_array_t **cfi_array___0 ) ;
#line 81
void detectflash(bus_t *bus___0 , uint32_t adr ) ;
#line 42 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/detectflash.c"
cfi_array_t *cfi_array  =    (cfi_array_t *)((void *)0);
#line 47
int amd_detect(bus_t *bus___0 , uint32_t adr , cfi_array_t **cfi_array___0 ) ;
#line 49 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/detectflash.c"
void detectflash(bus_t *bus___0 , uint32_t adr ) 
{ 
  cfi_query_structure_t *cfi ;
  char const   *s ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  int i ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  amd_pri_extened_query_structure_t *pri_vendor_tbl ;
  uint8_t major_version ;
  uint8_t minor_version ;
  int i___0 ;
  char const   *required_or_not[2] ;
  char const   *supported_or_not[2] ;
  char const   *process_technology[6] ;
  char const   *process_technology_13[3] ;
  char const   *erase_suspend[3] ;
  char const   *sector_protect_scheme[8] ;
  char const   *page_mode_type[4] ;
  char const   *top_bottom[6] ;
  char const   *bad_value ;
  char *tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  char *tmp___36 ;
  char *tmp___37 ;
  char *tmp___38 ;
  char *tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;
  char *tmp___42 ;
  char *tmp___43 ;
  char *tmp___44 ;
  char *tmp___45 ;
  char *tmp___46 ;
  char *tmp___47 ;
  char *tmp___48 ;
  char *tmp___49 ;
  char *tmp___50 ;
  char *tmp___51 ;
  char *tmp___52 ;
  char *tmp___53 ;
  char *tmp___54 ;
  char *tmp___55 ;
  char *tmp___56 ;
  char *tmp___57 ;
  char *tmp___58 ;
  char *tmp___59 ;
  char *tmp___60 ;
  char *tmp___61 ;
  char *tmp___62 ;
  char *tmp___63 ;
  char *tmp___64 ;
  char *tmp___65 ;
  char *tmp___66 ;
  char *tmp___67 ;
  char *tmp___68 ;
  void *__cil_tmp89 ;
  void *__cil_tmp90 ;
  void *__cil_tmp91 ;
  void *__cil_tmp92 ;
  void *__cil_tmp93 ;
  void *__cil_tmp94 ;
  void *__cil_tmp95 ;
  void *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;
  char *__cil_tmp140 ;
  char *__cil_tmp141 ;
  char *__cil_tmp142 ;
  char *__cil_tmp143 ;
  char *__cil_tmp144 ;
  char *__cil_tmp145 ;
  char *__cil_tmp146 ;
  char *__cil_tmp147 ;
  char *__cil_tmp148 ;
  char *__cil_tmp149 ;
  char *__cil_tmp150 ;
  char *__cil_tmp151 ;
  char *__cil_tmp152 ;
  char *__cil_tmp153 ;
  char *__cil_tmp154 ;
  char *__cil_tmp155 ;
  char *__cil_tmp156 ;
  char *__cil_tmp157 ;
  char *__cil_tmp158 ;
  char *__cil_tmp159 ;
  char *__cil_tmp160 ;
  char *__cil_tmp161 ;
  char *__cil_tmp162 ;
  char *__cil_tmp163 ;
  char *__cil_tmp164 ;
  char *__cil_tmp165 ;
  char *__cil_tmp166 ;
  char *__cil_tmp167 ;
  char *__cil_tmp168 ;
  char *__cil_tmp169 ;
  char *__cil_tmp170 ;
  char *__cil_tmp171 ;
  char *__cil_tmp172 ;
  char *__cil_tmp173 ;
  char *__cil_tmp174 ;
  char *__cil_tmp175 ;
  char *__cil_tmp176 ;
  char *__cil_tmp177 ;
  char *__cil_tmp178 ;
  char *__cil_tmp179 ;
  char *__cil_tmp180 ;
  char *__cil_tmp181 ;
  char *__cil_tmp182 ;
  char *__cil_tmp183 ;
  char *__cil_tmp184 ;
  char *__cil_tmp185 ;
  char *__cil_tmp186 ;
  char *__cil_tmp187 ;
  char *__cil_tmp188 ;
  char *__cil_tmp189 ;
  char *__cil_tmp190 ;
  char *__cil_tmp191 ;
  char *__cil_tmp192 ;
  char *__cil_tmp193 ;
  char *__cil_tmp194 ;
  char *__cil_tmp195 ;
  char *__cil_tmp196 ;
  char *__cil_tmp197 ;
  char *__cil_tmp198 ;
  char *__cil_tmp199 ;
  char *__cil_tmp200 ;
  char *__cil_tmp201 ;
  char *__cil_tmp202 ;
  char *__cil_tmp203 ;
  char *__cil_tmp204 ;
  char *__cil_tmp205 ;
  char *__cil_tmp206 ;
  char *__cil_tmp207 ;
  char *__cil_tmp208 ;
  char *__cil_tmp209 ;
  char *__cil_tmp210 ;
  char *__cil_tmp211 ;
  char *__cil_tmp212 ;
  char *__cil_tmp213 ;
  char *__cil_tmp214 ;
  char *__cil_tmp215 ;
  char *__cil_tmp216 ;
  char *__cil_tmp217 ;
  char *__cil_tmp218 ;
  char *__cil_tmp219 ;

  {
#line 55
  if (! bus___0) {
    {
#line 56
    tmp = gettext("Error: Missing bus driver!\n");
#line 56
    printf((char const   */* __restrict  */)tmp);
    }
#line 57
    return;
  }
  {
#line 60
  cfi_array_free(cfi_array);
#line 61
  cfi_array = (cfi_array_t *)((void *)0);
#line 63
  (*((bus___0->driver)->prepare))(bus___0);
#line 65
  tmp___2 = cfi_detect(bus___0, adr, & cfi_array);
  }
#line 65
  if (tmp___2) {
    {
#line 66
    cfi_array_free(cfi_array);
#line 67
    cfi_array = (cfi_array_t *)((void *)0);
#line 68
    tmp___1 = jedec_detect(bus___0, adr, & cfi_array);
    }
#line 68
    if (tmp___1 != 0) {
      {
#line 69
      cfi_array_free(cfi_array);
#line 70
      cfi_array = (cfi_array_t *)((void *)0);
#line 71
      tmp___0 = amd_detect(bus___0, adr, & cfi_array);
      }
#line 71
      if (tmp___0 != 0) {
        {
#line 73
        cfi_array_free(cfi_array);
#line 74
        cfi_array = (cfi_array_t *)((void *)0);
        }
      }
    }
  }
#line 85
  if ((unsigned long )cfi_array == (unsigned long )((void *)0)) {
    {
#line 87
    tmp___3 = gettext("Flash not found!\n");
#line 87
    printf((char const   */* __restrict  */)tmp___3);
    }
#line 88
    return;
  }
  {
#line 91
  cfi = & (*(cfi_array->cfi_chips + 0))->cfi;
#line 96
  tmp___4 = gettext("Query identification string:\n");
#line 96
  printf((char const   */* __restrict  */)tmp___4);
  }
  {
#line 99
  if ((int )cfi->identification_string.pri_id_code == 0) {
#line 99
    goto case_0;
  }
#line 102
  if ((int )cfi->identification_string.pri_id_code == 1) {
#line 102
    goto case_1;
  }
#line 105
  if ((int )cfi->identification_string.pri_id_code == 2) {
#line 105
    goto case_2;
  }
#line 108
  if ((int )cfi->identification_string.pri_id_code == 3) {
#line 108
    goto case_3;
  }
#line 111
  if ((int )cfi->identification_string.pri_id_code == 4) {
#line 111
    goto case_4;
  }
#line 114
  if ((int )cfi->identification_string.pri_id_code == 256) {
#line 114
    goto case_256;
  }
#line 117
  if ((int )cfi->identification_string.pri_id_code == 257) {
#line 117
    goto case_257;
  }
#line 120
  if ((int )cfi->identification_string.pri_id_code == 258) {
#line 120
    goto case_258;
  }
#line 123
  goto switch_default;
  case_0: /* CIL Label */ 
#line 100
  s = "null";
#line 101
  goto switch_break;
  case_1: /* CIL Label */ 
#line 103
  s = "Intel/Sharp Extended Command Set";
#line 104
  goto switch_break;
  case_2: /* CIL Label */ 
#line 106
  s = "AMD/Fujitsu Standard Command Set";
#line 107
  goto switch_break;
  case_3: /* CIL Label */ 
#line 109
  s = "Intel Standard Command Set";
#line 110
  goto switch_break;
  case_4: /* CIL Label */ 
#line 112
  s = "AMD/Fujitsu Extended Command Set";
#line 113
  goto switch_break;
  case_256: /* CIL Label */ 
#line 115
  s = "Mitsubishi Standard Command Set";
#line 116
  goto switch_break;
  case_257: /* CIL Label */ 
#line 118
  s = "Mitsubishi Extended Command Set";
#line 119
  goto switch_break;
  case_258: /* CIL Label */ 
#line 121
  s = "Page Write Command Set";
#line 122
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 124
  s = "unknown!!!";
#line 125
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 127
  tmp___5 = gettext(s);
#line 127
  tmp___6 = gettext("\tPrimary Algorithm Command Set and Control Interface ID Code: 0x%04X (%s)\n");
#line 127
  printf((char const   */* __restrict  */)tmp___6, (int )cfi->identification_string.pri_id_code,
         tmp___5);
  }
  {
#line 129
  if ((int )cfi->identification_string.alt_id_code == 0) {
#line 129
    goto case_0___0;
  }
#line 132
  if ((int )cfi->identification_string.alt_id_code == 1) {
#line 132
    goto case_1___0;
  }
#line 135
  if ((int )cfi->identification_string.alt_id_code == 2) {
#line 135
    goto case_2___0;
  }
#line 138
  if ((int )cfi->identification_string.alt_id_code == 3) {
#line 138
    goto case_3___0;
  }
#line 141
  if ((int )cfi->identification_string.alt_id_code == 4) {
#line 141
    goto case_4___0;
  }
#line 144
  if ((int )cfi->identification_string.alt_id_code == 256) {
#line 144
    goto case_256___0;
  }
#line 147
  if ((int )cfi->identification_string.alt_id_code == 257) {
#line 147
    goto case_257___0;
  }
#line 150
  if ((int )cfi->identification_string.alt_id_code == 258) {
#line 150
    goto case_258___0;
  }
#line 153
  goto switch_default___0;
  case_0___0: /* CIL Label */ 
#line 130
  s = "null";
#line 131
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
#line 133
  s = "Intel/Sharp Extended Command Set";
#line 134
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 136
  s = "AMD/Fujitsu Standard Command Set";
#line 137
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
#line 139
  s = "Intel Standard Command Set";
#line 140
  goto switch_break___0;
  case_4___0: /* CIL Label */ 
#line 142
  s = "AMD/Fujitsu Extended Command Set";
#line 143
  goto switch_break___0;
  case_256___0: /* CIL Label */ 
#line 145
  s = "Mitsubishi Standard Command Set";
#line 146
  goto switch_break___0;
  case_257___0: /* CIL Label */ 
#line 148
  s = "Mitsubishi Extended Command Set";
#line 149
  goto switch_break___0;
  case_258___0: /* CIL Label */ 
#line 151
  s = "Page Write Command Set";
#line 152
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 154
  s = "unknown!!!";
#line 155
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 157
  tmp___7 = gettext(s);
#line 157
  tmp___8 = gettext("\tAlternate Algorithm Command Set and Control Interface ID Code: 0x%04X (%s)\n");
#line 157
  printf((char const   */* __restrict  */)tmp___8, (int )cfi->identification_string.alt_id_code,
         tmp___7);
#line 160
  tmp___9 = gettext("Query system interface information:\n");
#line 160
  printf((char const   */* __restrict  */)tmp___9);
#line 161
  tmp___10 = gettext("\tVcc Logic Supply Minimum Write/Erase or Write voltage: %d mV\n");
#line 161
  printf((char const   */* __restrict  */)tmp___10, (int )cfi->system_interface_info.vcc_min_wev);
#line 162
  tmp___11 = gettext("\tVcc Logic Supply Maximum Write/Erase or Write voltage: %d mV\n");
#line 162
  printf((char const   */* __restrict  */)tmp___11, (int )cfi->system_interface_info.vcc_max_wev);
#line 163
  tmp___12 = gettext("\tVpp [Programming] Supply Minimum Write/Erase voltage: %d mV\n");
#line 163
  printf((char const   */* __restrict  */)tmp___12, (int )cfi->system_interface_info.vpp_min_wev);
#line 164
  tmp___13 = gettext("\tVpp [Programming] Supply Maximum Write/Erase voltage: %d mV\n");
#line 164
  printf((char const   */* __restrict  */)tmp___13, (int )cfi->system_interface_info.vpp_max_wev);
#line 165
  tmp___14 = gettext("\tTypical timeout per single byte/word program: %d us\n");
#line 165
  printf((char const   */* __restrict  */)tmp___14, cfi->system_interface_info.typ_single_write_timeout);
#line 166
  tmp___15 = gettext("\tTypical timeout for maximum-size multi-byte program: %d us\n");
#line 166
  printf((char const   */* __restrict  */)tmp___15, cfi->system_interface_info.typ_buffer_write_timeout);
#line 167
  tmp___16 = gettext("\tTypical timeout per individual block erase: %d ms\n");
#line 167
  printf((char const   */* __restrict  */)tmp___16, cfi->system_interface_info.typ_block_erase_timeout);
#line 168
  tmp___17 = gettext("\tTypical timeout for full chip erase: %d ms\n");
#line 168
  printf((char const   */* __restrict  */)tmp___17, cfi->system_interface_info.typ_chip_erase_timeout);
#line 169
  tmp___18 = gettext("\tMaximum timeout for byte/word program: %d us\n");
#line 169
  printf((char const   */* __restrict  */)tmp___18, cfi->system_interface_info.max_single_write_timeout);
#line 170
  tmp___19 = gettext("\tMaximum timeout for multi-byte program: %d us\n");
#line 170
  printf((char const   */* __restrict  */)tmp___19, cfi->system_interface_info.max_buffer_write_timeout);
#line 171
  tmp___20 = gettext("\tMaximum timeout per individual block erase: %d ms\n");
#line 171
  printf((char const   */* __restrict  */)tmp___20, cfi->system_interface_info.max_block_erase_timeout);
#line 172
  tmp___21 = gettext("\tMaximum timeout for chip erase: %d ms\n");
#line 172
  printf((char const   */* __restrict  */)tmp___21, cfi->system_interface_info.max_chip_erase_timeout);
#line 175
  tmp___22 = gettext("Device geometry definition:\n");
#line 175
  printf((char const   */* __restrict  */)tmp___22);
#line 176
  tmp___23 = gettext("\tDevice Size: %d B (%d KiB, %d MiB)\n");
#line 176
  printf((char const   */* __restrict  */)tmp___23, cfi->device_geometry.device_size,
         cfi->device_geometry.device_size / 1024U, cfi->device_geometry.device_size / 1048576U);
  }
  {
#line 182
  if ((int )cfi->device_geometry.device_interface == 0) {
#line 182
    goto case_0___1;
  }
#line 185
  if ((int )cfi->device_geometry.device_interface == 1) {
#line 185
    goto case_1___1;
  }
#line 188
  if ((int )cfi->device_geometry.device_interface == 2) {
#line 188
    goto case_2___1;
  }
#line 191
  if ((int )cfi->device_geometry.device_interface == 3) {
#line 191
    goto case_3___1;
  }
#line 194
  if ((int )cfi->device_geometry.device_interface == 4) {
#line 194
    goto case_4___1;
  }
#line 197
  goto switch_default___1;
  case_0___1: /* CIL Label */ 
#line 183
  s = "x8";
#line 184
  goto switch_break___1;
  case_1___1: /* CIL Label */ 
#line 186
  s = "x16";
#line 187
  goto switch_break___1;
  case_2___1: /* CIL Label */ 
#line 189
  s = "x8/x16";
#line 190
  goto switch_break___1;
  case_3___1: /* CIL Label */ 
#line 192
  s = "x32";
#line 193
  goto switch_break___1;
  case_4___1: /* CIL Label */ 
#line 195
  s = "x16/x32";
#line 196
  goto switch_break___1;
  switch_default___1: /* CIL Label */ 
#line 198
  s = "unknown!!!";
#line 199
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
  {
#line 201
  tmp___24 = gettext(s);
#line 201
  tmp___25 = gettext("\tFlash Device Interface Code description: 0x%04X (%s)\n");
#line 201
  printf((char const   */* __restrict  */)tmp___25, (int )cfi->device_geometry.device_interface,
         tmp___24);
#line 202
  tmp___26 = gettext("\tMaximum number of bytes in multi-byte program: %d\n");
#line 202
  printf((char const   */* __restrict  */)tmp___26, cfi->device_geometry.max_bytes_write);
#line 203
  tmp___27 = gettext("\tNumber of Erase Block Regions within device: %d\n");
#line 203
  printf((char const   */* __restrict  */)tmp___27, (int )cfi->device_geometry.number_of_erase_regions);
#line 204
  tmp___28 = gettext("\tErase Block Region Information:\n");
#line 204
  printf((char const   */* __restrict  */)tmp___28);
#line 208
  i = 0;
  }
  {
#line 208
  while (1) {
    while_continue: /* CIL Label */ ;
#line 208
    if (! (i < (int )cfi->device_geometry.number_of_erase_regions)) {
#line 208
      goto while_break;
    }
    {
#line 209
    tmp___29 = gettext("\t\tRegion %d:\n");
#line 209
    printf((char const   */* __restrict  */)tmp___29, i);
#line 210
    tmp___30 = gettext("\t\t\tErase Block Size: %d B (%d KiB)\n");
#line 210
    printf((char const   */* __restrict  */)tmp___30, (cfi->device_geometry.erase_block_regions + i)->erase_block_size,
           (cfi->device_geometry.erase_block_regions + i)->erase_block_size / 1024U);
#line 213
    tmp___31 = gettext("\t\t\tNumber of Erase Blocks: %d\n");
#line 213
    printf((char const   */* __restrict  */)tmp___31, (cfi->device_geometry.erase_block_regions + i)->number_of_erase_blocks);
#line 208
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 217
  if ((int )cfi->identification_string.pri_id_code == 2) {
#line 217
    if ((unsigned long )cfi->identification_string.pri_vendor_tbl != (unsigned long )((void *)0)) {
      {
#line 224
      required_or_not[0] = "Required";
#line 224
      required_or_not[1] = "Not required";
#line 227
      supported_or_not[0] = "Supported";
#line 227
      supported_or_not[1] = "Not supported";
#line 230
      process_technology[0] = "170-nm Floating Gate technology";
#line 230
      process_technology[1] = "230-nm MirrorBit(tm) technology";
#line 230
      process_technology[2] = "130-nm Floating Gate technology";
#line 230
      process_technology[3] = "110-nm MirrorBit(tm) technology";
#line 230
      process_technology[4] = "90-nm Floating Gate technology";
#line 230
      process_technology[5] = "90-nm MirrorBit(tm) technology";
#line 235
      process_technology_13[0] = "CS49";
#line 235
      process_technology_13[1] = "CS59";
#line 235
      process_technology_13[2] = "CS99";
#line 238
      erase_suspend[0] = "Not supported";
#line 238
      erase_suspend[1] = "Read only";
#line 238
      erase_suspend[2] = "Read/write";
#line 241
      sector_protect_scheme[0] = "29F040 mode";
#line 241
      sector_protect_scheme[1] = "29F016 mode";
#line 241
      sector_protect_scheme[2] = "29F400 mode";
#line 241
      sector_protect_scheme[3] = "29LV800 mode";
#line 241
      sector_protect_scheme[4] = "29BDS640 mode (Software Command Locking)";
#line 241
      sector_protect_scheme[5] = "29BDD160 mode (New Sector Protect)";
#line 241
      sector_protect_scheme[6] = "29PDL128 mode (New Sector Protect + 29LV800)";
#line 241
      sector_protect_scheme[7] = "Advanced Sector Protect";
#line 248
      page_mode_type[0] = "Not supported";
#line 248
      page_mode_type[1] = "4 word Page";
#line 248
      page_mode_type[2] = "8 word Page";
#line 248
      page_mode_type[3] = "16 word Page";
#line 252
      top_bottom[0] = "No boot";
#line 252
      top_bottom[1] = "8x8kb sectors at top and bottom with WP control";
#line 252
      top_bottom[2] = "Bottom boot device";
#line 252
      top_bottom[3] = "Top boot device";
#line 252
      top_bottom[4] = "Uniform bottom boot device";
#line 252
      top_bottom[5] = "Uniform top boot device";
#line 257
      bad_value = "Bad value";
#line 261
      pri_vendor_tbl = (amd_pri_extened_query_structure_t *)cfi->identification_string.pri_vendor_tbl;
#line 262
      major_version = pri_vendor_tbl->major_version;
#line 263
      minor_version = pri_vendor_tbl->minor_version;
#line 265
      tmp___32 = gettext("Primary Vendor-Specific Extended Query:\n");
#line 265
      printf((char const   */* __restrict  */)tmp___32);
#line 266
      tmp___33 = gettext("\tMajor version number: %c\n");
#line 266
      printf((char const   */* __restrict  */)tmp___33, (int )pri_vendor_tbl->major_version);
#line 267
      tmp___34 = gettext("\tMinor version number: %c\n");
#line 267
      printf((char const   */* __restrict  */)tmp___34, (int )pri_vendor_tbl->minor_version);
      }
#line 268
      if ((int )major_version > 49) {
#line 268
        goto _L___1;
      } else
#line 268
      if ((int )major_version == 49) {
#line 268
        if ((int )minor_version >= 48) {
          _L___1: /* CIL Label */ 
#line 270
          if ((unsigned long )((int )pri_vendor_tbl->address_sensitive_unlock & 3) < sizeof(required_or_not) / sizeof(required_or_not[0])) {
            {
#line 271
            tmp___35 = gettext("\tAddress Sensitive Unlock: %s\n");
#line 271
            printf((char const   */* __restrict  */)tmp___35, required_or_not[(int )pri_vendor_tbl->address_sensitive_unlock & 3]);
            }
          } else {
            {
#line 274
            tmp___36 = gettext("\tAddress Sensitive Unlock: %s\n");
#line 274
            printf((char const   */* __restrict  */)tmp___36, bad_value);
            }
          }
#line 276
          if ((int )major_version > 49) {
#line 276
            goto _L;
          } else
#line 276
          if ((int )major_version == 49) {
#line 276
            if ((int )minor_version >= 52) {
              _L: /* CIL Label */ 
#line 278
              if ((unsigned long )((int )pri_vendor_tbl->address_sensitive_unlock >> 2) < sizeof(process_technology) / sizeof(process_technology[0])) {
                {
#line 279
                tmp___37 = gettext("\tProcess Technology: %s\n");
#line 279
                printf((char const   */* __restrict  */)tmp___37, process_technology[(int )pri_vendor_tbl->address_sensitive_unlock >> 2]);
                }
              } else {
                {
#line 282
                tmp___38 = gettext("\tProcess Technology: %s\n");
#line 282
                printf((char const   */* __restrict  */)tmp___38, bad_value);
                }
              }
            } else {
#line 276
              goto _L___0;
            }
          } else
          _L___0: /* CIL Label */ 
#line 284
          if ((int )major_version == 49) {
#line 284
            if ((int )minor_version == 51) {
#line 286
              if ((unsigned long )((int )pri_vendor_tbl->address_sensitive_unlock >> 2) < sizeof(process_technology_13) / sizeof(process_technology_13[0])) {
                {
#line 287
                tmp___39 = gettext("\tProcess Technology: %s\n");
#line 287
                printf((char const   */* __restrict  */)tmp___39, process_technology_13[(int )pri_vendor_tbl->address_sensitive_unlock >> 2]);
                }
              } else {
                {
#line 290
                tmp___40 = gettext("\tProcess Technology: %s\n");
#line 290
                printf((char const   */* __restrict  */)tmp___40, bad_value);
                }
              }
            }
          }
#line 292
          if ((unsigned long )pri_vendor_tbl->erase_suspend < sizeof(erase_suspend) / sizeof(erase_suspend[0])) {
            {
#line 293
            tmp___41 = gettext("\tErase Suspend: %s\n");
#line 293
            printf((char const   */* __restrict  */)tmp___41, erase_suspend[pri_vendor_tbl->erase_suspend]);
            }
          }
#line 294
          if ((int )pri_vendor_tbl->sector_protect == 0) {
            {
#line 295
            tmp___42 = gettext("\tSector Protect: Not supported\n");
#line 295
            printf((char const   */* __restrict  */)tmp___42);
            }
          } else {
            {
#line 297
            tmp___43 = gettext("\tSector Protect: %d sectors per group\n");
#line 297
            printf((char const   */* __restrict  */)tmp___43, (int )pri_vendor_tbl->sector_protect);
            }
          }
#line 298
          if ((unsigned long )pri_vendor_tbl->sector_temporary_unprotect < sizeof(supported_or_not) / sizeof(supported_or_not[0])) {
            {
#line 299
            tmp___44 = gettext("\tSector Temporary Unprotect: %s\n");
#line 299
            printf((char const   */* __restrict  */)tmp___44, supported_or_not[pri_vendor_tbl->sector_temporary_unprotect]);
            }
          } else {
            {
#line 301
            tmp___45 = gettext("\tSector Temporary Unprotect: %s\n");
#line 301
            printf((char const   */* __restrict  */)tmp___45, bad_value);
            }
          }
#line 302
          if ((unsigned long )pri_vendor_tbl->sector_protect_scheme < sizeof(sector_protect_scheme) / sizeof(sector_protect_scheme[0])) {
            {
#line 303
            tmp___46 = gettext("\tSector Protect/Unprotect Scheme: %s\n");
#line 303
            printf((char const   */* __restrict  */)tmp___46, sector_protect_scheme[pri_vendor_tbl->sector_protect_scheme]);
            }
          } else {
            {
#line 306
            tmp___47 = gettext("\tSector Protect/Unprotect Scheme: %s\n");
#line 306
            printf((char const   */* __restrict  */)tmp___47, bad_value);
            }
          }
#line 307
          if ((int )pri_vendor_tbl->simultaneous_operation == 0) {
            {
#line 308
            tmp___48 = gettext("\tSimultaneous Operation: Not supported\n");
#line 308
            printf((char const   */* __restrict  */)tmp___48);
            }
          } else {
            {
#line 310
            tmp___49 = gettext("\tSimultaneous Operation: %d sectors\n");
#line 310
            printf((char const   */* __restrict  */)tmp___49, (int )pri_vendor_tbl->simultaneous_operation);
            }
          }
#line 311
          if ((unsigned long )pri_vendor_tbl->burst_mode_type < sizeof(supported_or_not) / sizeof(supported_or_not[0])) {
            {
#line 312
            tmp___50 = gettext("\tBurst Mode Type: %s\n");
#line 312
            printf((char const   */* __restrict  */)tmp___50, supported_or_not[pri_vendor_tbl->burst_mode_type]);
            }
          } else {
            {
#line 314
            tmp___51 = gettext("\tBurst Mode Type: %s\n");
#line 314
            printf((char const   */* __restrict  */)tmp___51, bad_value);
            }
          }
#line 315
          if ((unsigned long )pri_vendor_tbl->page_mode_type < sizeof(page_mode_type) / sizeof(page_mode_type[0])) {
            {
#line 316
            tmp___52 = gettext("\tPage Mode Type: %s\n");
#line 316
            printf((char const   */* __restrict  */)tmp___52, page_mode_type[pri_vendor_tbl->page_mode_type]);
            }
          } else {
            {
#line 318
            tmp___53 = gettext("\tPage Mode Type: %s\n");
#line 318
            printf((char const   */* __restrict  */)tmp___53, bad_value);
            }
          }
        }
      }
#line 320
      if ((int )major_version > 49) {
#line 320
        goto _L___2;
      } else
#line 320
      if ((int )major_version == 49) {
#line 320
        if ((int )minor_version >= 49) {
          _L___2: /* CIL Label */ 
          {
#line 322
          tmp___54 = gettext("\tACC (Acceleration) Supply Minimum: %d mV\n");
#line 322
          printf((char const   */* __restrict  */)tmp___54, (int )pri_vendor_tbl->acc_min);
#line 323
          tmp___55 = gettext("\tACC (Acceleration) Supply Maximum: %d mV\n");
#line 323
          printf((char const   */* __restrict  */)tmp___55, (int )pri_vendor_tbl->acc_max);
          }
#line 324
          if ((unsigned long )pri_vendor_tbl->top_bottom_sector_flag < sizeof(top_bottom) / sizeof(top_bottom[0])) {
            {
#line 325
            tmp___56 = gettext("\tTop/Bottom Sector Flag: %s\n");
#line 325
            printf((char const   */* __restrict  */)tmp___56, top_bottom[pri_vendor_tbl->top_bottom_sector_flag]);
            }
          } else {
            {
#line 327
            tmp___57 = gettext("\tTop/Bottom Sector Flag: %s\n");
#line 327
            printf((char const   */* __restrict  */)tmp___57, bad_value);
            }
          }
        }
      }
#line 329
      if ((int )major_version > 49) {
#line 329
        goto _L___3;
      } else
#line 329
      if ((int )major_version == 49) {
#line 329
        if ((int )minor_version >= 50) {
          _L___3: /* CIL Label */ 
#line 331
          if ((unsigned long )pri_vendor_tbl->program_suspend < sizeof(supported_or_not) / sizeof(supported_or_not[0])) {
            {
#line 332
            tmp___58 = gettext("\tProgram Suspend: %s\n");
#line 332
            printf((char const   */* __restrict  */)tmp___58, supported_or_not[pri_vendor_tbl->program_suspend]);
            }
          } else {
            {
#line 334
            tmp___59 = gettext("\tProgram Suspend: %s\n");
#line 334
            printf((char const   */* __restrict  */)tmp___59, bad_value);
            }
          }
        }
      }
#line 336
      if ((int )major_version > 49) {
#line 336
        goto _L___4;
      } else
#line 336
      if ((int )major_version == 49) {
#line 336
        if ((int )minor_version >= 52) {
          _L___4: /* CIL Label */ 
#line 338
          if ((unsigned long )pri_vendor_tbl->unlock_bypass < sizeof(supported_or_not) / sizeof(supported_or_not[0])) {
            {
#line 339
            tmp___60 = gettext("\tUnlock Bypass: %s\n");
#line 339
            printf((char const   */* __restrict  */)tmp___60, supported_or_not[pri_vendor_tbl->unlock_bypass]);
            }
          } else {
            {
#line 341
            tmp___61 = gettext("\tUnlock Bypass: %s\n");
#line 341
            printf((char const   */* __restrict  */)tmp___61, bad_value);
            }
          }
          {
#line 342
          tmp___62 = gettext("\tSecSi Sector (Customer OTP Area) Size: %d bytes\n");
#line 342
          printf((char const   */* __restrict  */)tmp___62, (int )pri_vendor_tbl->secsi_sector_size);
#line 343
          tmp___63 = gettext("\tEmbedded Hardware Reset Timeout Maximum: %d ns\n");
#line 343
          printf((char const   */* __restrict  */)tmp___63, (int )pri_vendor_tbl->embedded_hwrst_timeout_max);
#line 344
          tmp___64 = gettext("\tNon-Embedded Hardware Reset Timeout Maximum: %d ns\n");
#line 344
          printf((char const   */* __restrict  */)tmp___64, (int )pri_vendor_tbl->non_embedded_hwrst_timeout_max);
#line 345
          tmp___65 = gettext("\tErase Suspend Timeout Maximum: %d us\n");
#line 345
          printf((char const   */* __restrict  */)tmp___65, (int )pri_vendor_tbl->erase_suspend_timeout_max);
#line 346
          tmp___66 = gettext("\tProgram Suspend Timeout Maximum: %d us\n");
#line 346
          printf((char const   */* __restrict  */)tmp___66, (int )pri_vendor_tbl->program_suspend_timeout_max);
          }
        }
      }
#line 348
      if ((int )major_version > 49) {
#line 348
        goto _L___5;
      } else
#line 348
      if ((int )major_version == 49) {
#line 348
        if ((int )minor_version >= 51) {
          _L___5: /* CIL Label */ 
#line 348
          if (pri_vendor_tbl->bank_organization) {
            {
#line 351
            tmp___67 = gettext("\tBank Organization:\n");
#line 351
            printf((char const   */* __restrict  */)tmp___67);
#line 352
            i___0 = 0;
            }
            {
#line 352
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 352
              if (! (i___0 < (int )pri_vendor_tbl->bank_organization)) {
#line 352
                goto while_break___0;
              }
              {
#line 353
              tmp___68 = gettext("\t\tBank%d: %d sectors\n");
#line 353
              printf((char const   */* __restrict  */)tmp___68, i___0 + 1, (int )pri_vendor_tbl->bank_region_info[i___0]);
#line 352
              i___0 ++;
              }
            }
            while_break___0: /* CIL Label */ ;
            }
          }
        }
      }
    }
  }
#line 356
  return;
}
}
#line 41 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/cfi.c"
void cfi_array_free(cfi_array_t *cfi_array___0 ) 
{ 
  int i ;

  {
#line 44
  if (! cfi_array___0) {
#line 45
    return;
  }
#line 47
  if (cfi_array___0->cfi_chips) {
#line 50
    i = 0;
    {
#line 50
    while (1) {
      while_continue: /* CIL Label */ ;
#line 50
      if (! (i < cfi_array___0->bus_width)) {
#line 50
        goto while_break;
      }
#line 51
      if (! *(cfi_array___0->cfi_chips + i)) {
#line 52
        goto __Cont;
      }
      {
#line 54
      free((void *)(*(cfi_array___0->cfi_chips + i))->cfi.device_geometry.erase_block_regions);
      }
#line 55
      if ((*(cfi_array___0->cfi_chips + i))->cfi.identification_string.pri_vendor_tbl) {
        {
#line 56
        free((*(cfi_array___0->cfi_chips + i))->cfi.identification_string.pri_vendor_tbl);
        }
      }
      {
#line 57
      free((void *)*(cfi_array___0->cfi_chips + i));
      }
      __Cont: /* CIL Label */ 
#line 50
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 59
    free((void *)cfi_array___0->cfi_chips);
    }
  }
  {
#line 62
  free((void *)cfi_array___0);
  }
#line 63
  return;
}
}
#line 65 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/cfi.c"
int cfi_detect(bus_t *bus___0 , uint32_t adr , cfi_array_t **cfi_array___0 ) 
{ 
  unsigned int bw ;
  unsigned int d ;
  int ba ;
  int ma ;
  bus_area_t area___0 ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  cfi_query_structure_t *cfi ;
  uint32_t tmp___2 ;
  int ret ;
  uint16_t pri_vendor_tbl_adr ;
  uint32_t tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t tmp___5 ;
  void *tmp___6 ;
  uint32_t tmp___7 ;
  uint32_t tmp___8 ;
  uint32_t tmp___9 ;
  uint32_t tmp___10 ;
  uint32_t tmp___11 ;
  uint32_t tmp___12 ;
  uint32_t tmp___13 ;
  uint32_t tmp___14 ;
  uint32_t tmp___15 ;
  uint32_t tmp___16 ;
  uint32_t tmp___17 ;
  uint32_t tmp___18 ;
  uint32_t tmp___19 ;
  int tmp___20 ;
  uint32_t tmp___21 ;
  int tmp___22 ;
  uint32_t tmp___23 ;
  int tmp___24 ;
  uint32_t tmp___25 ;
  int tmp___26 ;
  uint32_t tmp___27 ;
  uint32_t tmp___28 ;
  uint32_t tmp___29 ;
  uint32_t tmp___30 ;
  uint32_t tmp___31 ;
  uint8_t tmp___32 ;
  uint32_t tmp___33 ;
  void *tmp___34 ;
  int a ;
  int i ;
  uint32_t y ;
  uint32_t tmp___35 ;
  uint32_t tmp___36 ;
  uint32_t z ;
  uint32_t tmp___37 ;
  uint32_t tmp___38 ;
  uint32_t tmp___39 ;
  uint32_t tmp___40 ;
  amd_pri_extened_query_structure_t *pri_vendor_tbl ;
  uint8_t major_version ;
  uint8_t minor_version ;
  uint8_t num_of_banks ;
  int i___0 ;
  uint32_t tmp___41 ;
  uint32_t tmp___42 ;
  uint32_t tmp___43 ;
  uint32_t tmp___44 ;
  uint32_t tmp___45 ;
  uint32_t tmp___46 ;
  void *tmp___47 ;
  uint32_t tmp___48 ;
  uint32_t tmp___49 ;
  uint32_t tmp___50 ;
  uint32_t tmp___51 ;
  uint32_t tmp___52 ;
  uint32_t tmp___53 ;
  uint32_t tmp___54 ;
  uint32_t tmp___55 ;
  uint32_t tmp___56 ;
  uint32_t tmp___57 ;
  uint32_t tmp___58 ;
  uint32_t tmp___59 ;
  uint32_t tmp___60 ;
  uint32_t tmp___61 ;
  uint32_t tmp___62 ;
  uint32_t tmp___63 ;
  uint32_t tmp___64 ;
  uint32_t tmp___65 ;
  uint32_t tmp___66 ;
  uint32_t tmp___67 ;
  uint32_t y___0 ;
  uint32_t z___0 ;
  uint32_t n ;

  {
#line 74
  if (! cfi_array___0) {
#line 75
    return (-1);
  } else
#line 74
  if (! bus___0) {
#line 75
    return (-1);
  }
  {
#line 77
  tmp = calloc((size_t )1, (size_t )sizeof(cfi_array_t ));
#line 77
  *cfi_array___0 = (cfi_array_t *)tmp;
  }
#line 78
  if (! *cfi_array___0) {
#line 79
    return (-2);
  }
  {
#line 81
  (*cfi_array___0)->bus = bus___0;
#line 82
  (*cfi_array___0)->address = adr;
#line 83
  tmp___0 = (*((bus___0->driver)->area))(bus___0, adr, & area___0);
  }
#line 83
  if (tmp___0 != 0) {
#line 84
    return (-8);
  }
#line 85
  bw = area___0.width;
#line 86
  if (bw != 8U) {
#line 86
    if (bw != 16U) {
#line 86
      if (bw != 32U) {
#line 87
        return (-3);
      }
    }
  }
  {
#line 88
  ba = (int )(bw / 8U);
#line 88
  (*cfi_array___0)->bus_width = ba;
#line 89
  tmp___1 = calloc((size_t )ba, (size_t )sizeof(cfi_chip_t *));
#line 89
  (*cfi_array___0)->cfi_chips = (cfi_chip_t **)tmp___1;
  }
#line 90
  if (! (*cfi_array___0)->cfi_chips) {
#line 91
    return (-2);
  }
#line 93
  d = 0U;
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
#line 93
    if (! (d < bw)) {
#line 93
      goto while_break;
    }
#line 103
    ret = -4;
#line 107
    ma = 1;
    {
#line 107
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 107
      if (! (ma <= 4)) {
#line 107
        goto while_break___0;
      }
      {
#line 108
      (*((bus___0->driver)->write))(bus___0, adr + (uint32_t )((85 * ba) * ma), (uint32_t )(152 << d));
#line 110
      tmp___4 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((16 * ba) * ma));
      }
#line 110
      if (((tmp___4 >> d) & 255U) == 81U) {
        {
#line 111
        ret = -5;
#line 112
        tmp___3 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((17 * ba) * ma));
        }
#line 112
        if (((tmp___3 >> d) & 255U) == 82U) {
#line 113
          goto while_break___0;
        }
      }
      {
#line 116
      (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )(255 << d));
#line 107
      ma *= 2;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 119
    if (ma > 4) {
#line 120
      return (ret);
    }
    {
#line 122
    tmp___5 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((18 * ba) * ma));
    }
#line 122
    if (((tmp___5 >> d) & 255U) != 89U) {
      {
#line 123
      (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )(255 << d));
      }
#line 124
      return (-6);
    }
    {
#line 127
    tmp___6 = calloc((size_t )1, (size_t )sizeof(cfi_chip_t ));
#line 127
    *((*cfi_array___0)->cfi_chips + d / 8U) = (cfi_chip_t *)tmp___6;
    }
#line 128
    if (! *((*cfi_array___0)->cfi_chips + d / 8U)) {
      {
#line 129
      (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )(255 << d));
      }
#line 130
      return (-2);
    }
    {
#line 132
    cfi = & (*((*cfi_array___0)->cfi_chips + d / 8U))->cfi;
#line 135
    (*((bus___0->driver)->read_start))(bus___0, adr + (uint32_t )((19 * ba) * ma));
#line 135
    tmp___7 = (*((bus___0->driver)->read_next))(bus___0, adr + (uint32_t )((20 * ba) * ma));
#line 135
    tmp___8 = (*((bus___0->driver)->read_end))(bus___0);
#line 135
    cfi->identification_string.pri_id_code = (uint16_t )(((tmp___7 >> d) & 255U) | (((tmp___8 >> d) & 255U) << 8));
#line 136
    cfi->identification_string.pri_vendor_tbl = (void *)0;
#line 137
    (*((bus___0->driver)->read_start))(bus___0, adr + (uint32_t )((23 * ba) * ma));
#line 137
    tmp___9 = (*((bus___0->driver)->read_next))(bus___0, adr + (uint32_t )((24 * ba) * ma));
#line 137
    tmp___10 = (*((bus___0->driver)->read_end))(bus___0);
#line 137
    cfi->identification_string.alt_id_code = (uint16_t )(((tmp___9 >> d) & 255U) | (((tmp___10 >> d) & 255U) << 8));
#line 138
    cfi->identification_string.alt_vendor_tbl = (void *)0;
#line 141
    tmp___11 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((27 * ba) * ma));
#line 141
    tmp___2 = (tmp___11 >> d) & 255U;
#line 142
    cfi->system_interface_info.vcc_min_wev = (uint16_t )(((tmp___2 >> 4) & 15U) * 1000U + (tmp___2 & 15U) * 100U);
#line 143
    tmp___12 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((28 * ba) * ma));
#line 143
    tmp___2 = (tmp___12 >> d) & 255U;
#line 144
    cfi->system_interface_info.vcc_max_wev = (uint16_t )(((tmp___2 >> 4) & 15U) * 1000U + (tmp___2 & 15U) * 100U);
#line 145
    tmp___13 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((29 * ba) * ma));
#line 145
    tmp___2 = (tmp___13 >> d) & 255U;
#line 146
    cfi->system_interface_info.vpp_min_wev = (uint16_t )(((tmp___2 >> 4) & 15U) * 1000U + (tmp___2 & 15U) * 100U);
#line 147
    tmp___14 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((30 * ba) * ma));
#line 147
    tmp___2 = (tmp___14 >> d) & 255U;
#line 148
    cfi->system_interface_info.vpp_max_wev = (uint16_t )(((tmp___2 >> 4) & 15U) * 1000U + (tmp___2 & 15U) * 100U);
#line 151
    tmp___15 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((31 * ba) * ma));
#line 151
    tmp___2 = (tmp___15 >> d) & 255U;
    }
#line 152
    if (tmp___2) {
#line 152
      cfi->system_interface_info.typ_single_write_timeout = (uint32_t )(1 << tmp___2);
    } else {
#line 152
      cfi->system_interface_info.typ_single_write_timeout = (uint32_t )0;
    }
    {
#line 154
    tmp___16 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((32 * ba) * ma));
#line 154
    tmp___2 = (tmp___16 >> d) & 255U;
    }
#line 155
    if (tmp___2) {
#line 155
      cfi->system_interface_info.typ_buffer_write_timeout = (uint32_t )(1 << tmp___2);
    } else {
#line 155
      cfi->system_interface_info.typ_buffer_write_timeout = (uint32_t )0;
    }
    {
#line 157
    tmp___17 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((33 * ba) * ma));
#line 157
    tmp___2 = (tmp___17 >> d) & 255U;
    }
#line 158
    if (tmp___2) {
#line 158
      cfi->system_interface_info.typ_block_erase_timeout = (uint32_t )(1 << tmp___2);
    } else {
#line 158
      cfi->system_interface_info.typ_block_erase_timeout = (uint32_t )0;
    }
    {
#line 160
    tmp___18 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((34 * ba) * ma));
#line 160
    tmp___2 = (tmp___18 >> d) & 255U;
    }
#line 161
    if (tmp___2) {
#line 161
      cfi->system_interface_info.typ_chip_erase_timeout = (uint32_t )(1 << tmp___2);
    } else {
#line 161
      cfi->system_interface_info.typ_chip_erase_timeout = (uint32_t )0;
    }
    {
#line 163
    tmp___19 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((35 * ba) * ma));
#line 163
    tmp___2 = (tmp___19 >> d) & 255U;
    }
#line 164
    if (tmp___2) {
#line 164
      tmp___20 = 1 << tmp___2;
    } else {
#line 164
      tmp___20 = 0;
    }
    {
#line 164
    cfi->system_interface_info.max_single_write_timeout = (uint32_t )tmp___20 * cfi->system_interface_info.typ_single_write_timeout;
#line 167
    tmp___21 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((36 * ba) * ma));
#line 167
    tmp___2 = (tmp___21 >> d) & 255U;
    }
#line 168
    if (tmp___2) {
#line 168
      tmp___22 = 1 << tmp___2;
    } else {
#line 168
      tmp___22 = 0;
    }
    {
#line 168
    cfi->system_interface_info.max_buffer_write_timeout = (uint32_t )tmp___22 * cfi->system_interface_info.typ_buffer_write_timeout;
#line 171
    tmp___23 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((37 * ba) * ma));
#line 171
    tmp___2 = (tmp___23 >> d) & 255U;
    }
#line 172
    if (tmp___2) {
#line 172
      tmp___24 = 1 << tmp___2;
    } else {
#line 172
      tmp___24 = 0;
    }
    {
#line 172
    cfi->system_interface_info.max_block_erase_timeout = (uint32_t )tmp___24 * cfi->system_interface_info.typ_block_erase_timeout;
#line 175
    tmp___25 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((38 * ba) * ma));
#line 175
    tmp___2 = (tmp___25 >> d) & 255U;
    }
#line 176
    if (tmp___2) {
#line 176
      tmp___26 = 1 << tmp___2;
    } else {
#line 176
      tmp___26 = 0;
    }
    {
#line 176
    cfi->system_interface_info.max_chip_erase_timeout = (uint32_t )tmp___26 * cfi->system_interface_info.typ_chip_erase_timeout;
#line 181
    tmp___27 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((39 * ba) * ma));
#line 181
    cfi->device_geometry.device_size = (uint32_t )(1 << ((tmp___27 >> d) & 255U));
#line 183
    (*((bus___0->driver)->read_start))(bus___0, adr + (uint32_t )((40 * ba) * ma));
#line 183
    tmp___28 = (*((bus___0->driver)->read_next))(bus___0, adr + (uint32_t )((41 * ba) * ma));
#line 183
    tmp___29 = (*((bus___0->driver)->read_end))(bus___0);
#line 183
    cfi->device_geometry.device_interface = (uint16_t )(((tmp___28 >> d) & 255U) | (((tmp___29 >> d) & 255U) << 8));
#line 186
    (*((bus___0->driver)->read_start))(bus___0, adr + (uint32_t )((42 * ba) * ma));
#line 186
    tmp___30 = (*((bus___0->driver)->read_next))(bus___0, adr + (uint32_t )((43 * ba) * ma));
#line 186
    tmp___31 = (*((bus___0->driver)->read_end))(bus___0);
#line 186
    cfi->device_geometry.max_bytes_write = (uint32_t )(1 << (((tmp___30 >> d) & 255U) | (((tmp___31 >> d) & 255U) << 8)));
#line 188
    tmp___33 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((44 * ba) * ma));
#line 188
    tmp___32 = (uint8_t )((tmp___33 >> d) & 255U);
#line 188
    cfi->device_geometry.number_of_erase_regions = tmp___32;
#line 188
    tmp___2 = (uint32_t )tmp___32;
#line 190
    tmp___34 = malloc((size_t )((unsigned long )tmp___2 * sizeof(cfi_erase_block_region_t )));
#line 190
    cfi->device_geometry.erase_block_regions = (cfi_erase_block_region_t *)tmp___34;
    }
#line 191
    if (! cfi->device_geometry.erase_block_regions) {
      {
#line 192
      (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )(255 << d));
      }
#line 193
      return (-2);
    }
#line 200
    i = 0;
#line 200
    a = 45;
    {
#line 200
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 200
      if (! ((uint32_t )i < tmp___2)) {
#line 200
        goto while_break___1;
      }
      {
#line 201
      (*((bus___0->driver)->read_start))(bus___0, adr + (uint32_t )((a * ba) * ma));
#line 201
      tmp___35 = (*((bus___0->driver)->read_next))(bus___0, adr + (uint32_t )(((a + 1) * ba) * ma));
#line 201
      tmp___36 = (*((bus___0->driver)->read_end))(bus___0);
#line 201
      y = ((tmp___35 >> d) & 255U) | (((tmp___36 >> d) & 255U) << 8);
#line 202
      (*((bus___0->driver)->read_start))(bus___0, adr + (uint32_t )(((a + 2) * ba) * ma));
#line 202
      tmp___37 = (*((bus___0->driver)->read_next))(bus___0, adr + (uint32_t )((((a + 2) + 1) * ba) * ma));
#line 202
      tmp___38 = (*((bus___0->driver)->read_end))(bus___0);
#line 202
      z = (((tmp___37 >> d) & 255U) | (((tmp___38 >> d) & 255U) << 8)) << 8;
      }
#line 203
      if (z == 0U) {
#line 204
        z = (uint32_t )128;
      }
#line 205
      (cfi->device_geometry.erase_block_regions + i)->erase_block_size = z;
#line 206
      (cfi->device_geometry.erase_block_regions + i)->number_of_erase_blocks = y + 1U;
#line 200
      i ++;
#line 200
      a += 4;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 210
    (*((bus___0->driver)->read_start))(bus___0, adr + (uint32_t )((21 * ba) * ma));
#line 210
    tmp___39 = (*((bus___0->driver)->read_next))(bus___0, adr + (uint32_t )((22 * ba) * ma));
#line 210
    tmp___40 = (*((bus___0->driver)->read_end))(bus___0);
#line 210
    pri_vendor_tbl_adr = (uint16_t )(((tmp___39 >> d) & 255U) | (((tmp___40 >> d) & 255U) << 8));
    }
#line 213
    if ((int )cfi->identification_string.pri_id_code == 2) {
#line 213
      if ((int )pri_vendor_tbl_adr != 0) {
        {
#line 223
        tmp___41 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )(((int )pri_vendor_tbl_adr * ba) * ma));
        }
#line 223
        if (((tmp___41 >> d) & 255U) != 80U) {
          {
#line 224
          (*((bus___0->driver)->write))(bus___0, adr + (uint32_t )(((int )pri_vendor_tbl_adr * ba) * ma),
                                        (uint32_t )(255 << d));
          }
#line 225
          return (-9);
        } else {
          {
#line 223
          tmp___42 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((((int )pri_vendor_tbl_adr + 1) * ba) * ma));
          }
#line 223
          if (((tmp___42 >> d) & 255U) != 82U) {
            {
#line 224
            (*((bus___0->driver)->write))(bus___0, adr + (uint32_t )(((int )pri_vendor_tbl_adr * ba) * ma),
                                          (uint32_t )(255 << d));
            }
#line 225
            return (-9);
          } else {
            {
#line 223
            tmp___43 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((((int )pri_vendor_tbl_adr + 2) * ba) * ma));
            }
#line 223
            if (((tmp___43 >> d) & 255U) != 73U) {
              {
#line 224
              (*((bus___0->driver)->write))(bus___0, adr + (uint32_t )(((int )pri_vendor_tbl_adr * ba) * ma),
                                            (uint32_t )(255 << d));
              }
#line 225
              return (-9);
            }
          }
        }
        {
#line 228
        tmp___44 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((((int )pri_vendor_tbl_adr + 3) * ba) * ma));
#line 228
        major_version = (uint8_t )((tmp___44 >> d) & 255U);
#line 229
        tmp___45 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((((int )pri_vendor_tbl_adr + 4) * ba) * ma));
#line 229
        minor_version = (uint8_t )((tmp___45 >> d) & 255U);
        }
#line 230
        if ((int )major_version > 49) {
          {
#line 231
          tmp___46 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((((int )pri_vendor_tbl_adr + 23) * ba) * ma));
#line 231
          num_of_banks = (uint8_t )((tmp___46 >> d) & 255U);
          }
        } else
#line 230
        if ((int )major_version == 49) {
#line 230
          if ((int )minor_version >= 51) {
            {
#line 231
            tmp___46 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((((int )pri_vendor_tbl_adr + 23) * ba) * ma));
#line 231
            num_of_banks = (uint8_t )((tmp___46 >> d) & 255U);
            }
          } else {
#line 233
            num_of_banks = (uint8_t )0;
          }
        } else {
#line 233
          num_of_banks = (uint8_t )0;
        }
        {
#line 234
        tmp___47 = calloc((size_t )1, (size_t )(sizeof(amd_pri_extened_query_structure_t ) + (unsigned long )num_of_banks * sizeof(uint8_t )));
#line 234
        pri_vendor_tbl = (amd_pri_extened_query_structure_t *)tmp___47;
        }
#line 237
        if (! pri_vendor_tbl) {
          {
#line 238
          (*((bus___0->driver)->write))(bus___0, adr + (uint32_t )(((int )pri_vendor_tbl_adr * ba) * ma),
                                        (uint32_t )(255 << d));
          }
#line 239
          return (-2);
        }
#line 242
        if ((int )major_version > 49) {
#line 242
          goto _L;
        } else
#line 242
        if ((int )major_version == 49) {
#line 242
          if ((int )minor_version >= 48) {
            _L: /* CIL Label */ 
            {
#line 243
            pri_vendor_tbl->major_version = major_version;
#line 244
            pri_vendor_tbl->minor_version = minor_version;
#line 245
            tmp___48 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((((int )pri_vendor_tbl_adr + 5) * ba) * ma));
#line 245
            pri_vendor_tbl->address_sensitive_unlock = (uint8_t )((tmp___48 >> d) & 255U);
#line 246
            tmp___49 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((((int )pri_vendor_tbl_adr + 6) * ba) * ma));
#line 246
            pri_vendor_tbl->erase_suspend = (uint8_t )((tmp___49 >> d) & 255U);
#line 247
            tmp___50 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((((int )pri_vendor_tbl_adr + 7) * ba) * ma));
#line 247
            pri_vendor_tbl->sector_protect = (uint8_t )((tmp___50 >> d) & 255U);
#line 248
            tmp___51 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((((int )pri_vendor_tbl_adr + 8) * ba) * ma));
#line 248
            pri_vendor_tbl->sector_temporary_unprotect = (uint8_t )((tmp___51 >> d) & 255U);
#line 249
            tmp___52 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((((int )pri_vendor_tbl_adr + 9) * ba) * ma));
#line 249
            pri_vendor_tbl->sector_protect_scheme = (uint8_t )((tmp___52 >> d) & 255U);
#line 250
            tmp___53 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((((int )pri_vendor_tbl_adr + 10) * ba) * ma));
#line 250
            pri_vendor_tbl->simultaneous_operation = (uint8_t )((tmp___53 >> d) & 255U);
#line 251
            tmp___54 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((((int )pri_vendor_tbl_adr + 11) * ba) * ma));
#line 251
            pri_vendor_tbl->burst_mode_type = (uint8_t )((tmp___54 >> d) & 255U);
#line 252
            tmp___55 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((((int )pri_vendor_tbl_adr + 12) * ba) * ma));
#line 252
            pri_vendor_tbl->page_mode_type = (uint8_t )((tmp___55 >> d) & 255U);
            }
          }
        }
#line 254
        if ((int )major_version > 49) {
#line 254
          goto _L___0;
        } else
#line 254
        if ((int )major_version == 49) {
#line 254
          if ((int )minor_version >= 49) {
            _L___0: /* CIL Label */ 
            {
#line 255
            tmp___56 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((((int )pri_vendor_tbl_adr + 13) * ba) * ma));
#line 255
            tmp___2 = (tmp___56 >> d) & 255U;
#line 256
            pri_vendor_tbl->acc_min = (uint16_t )(((tmp___2 >> 4) & 15U) * 1000U + (tmp___2 & 15U) * 100U);
#line 257
            tmp___57 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((((int )pri_vendor_tbl_adr + 14) * ba) * ma));
#line 257
            tmp___2 = (tmp___57 >> d) & 255U;
#line 258
            pri_vendor_tbl->acc_max = (uint16_t )(((tmp___2 >> 4) & 15U) * 1000U + (tmp___2 & 15U) * 100U);
#line 259
            tmp___58 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((((int )pri_vendor_tbl_adr + 15) * ba) * ma));
#line 259
            pri_vendor_tbl->top_bottom_sector_flag = (uint8_t )((tmp___58 >> d) & 255U);
            }
          }
        }
#line 261
        if ((int )major_version > 49) {
          {
#line 262
          tmp___59 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((((int )pri_vendor_tbl_adr + 16) * ba) * ma));
#line 262
          pri_vendor_tbl->program_suspend = (uint8_t )((tmp___59 >> d) & 255U);
          }
        } else
#line 261
        if ((int )major_version == 49) {
#line 261
          if ((int )minor_version >= 50) {
            {
#line 262
            tmp___59 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((((int )pri_vendor_tbl_adr + 16) * ba) * ma));
#line 262
            pri_vendor_tbl->program_suspend = (uint8_t )((tmp___59 >> d) & 255U);
            }
          }
        }
#line 263
        if ((int )major_version > 49) {
#line 263
          goto _L___1;
        } else
#line 263
        if ((int )major_version == 49) {
#line 263
          if ((int )minor_version >= 51) {
            _L___1: /* CIL Label */ 
#line 264
            if (pri_vendor_tbl->simultaneous_operation) {
              {
#line 265
              tmp___60 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((((int )pri_vendor_tbl_adr + 23) * ba) * ma));
#line 265
              pri_vendor_tbl->bank_organization = (uint8_t )((tmp___60 >> d) & 255U);
              }
            } else {
#line 267
              pri_vendor_tbl->bank_organization = (uint8_t )0;
            }
#line 268
            i___0 = 0;
            {
#line 268
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 268
              if (! (i___0 < (int )pri_vendor_tbl->bank_organization)) {
#line 268
                goto while_break___2;
              }
              {
#line 269
              tmp___61 = (*((bus___0->driver)->read))(bus___0, (uint32_t )((unsigned long )adr + (((unsigned long )((int )pri_vendor_tbl_adr + 24) + (unsigned long )i___0 * sizeof(uint8_t )) * (unsigned long )ba) * (unsigned long )ma));
#line 269
              pri_vendor_tbl->bank_region_info[i___0] = (uint8_t )((tmp___61 >> d) & 255U);
#line 268
              i___0 ++;
              }
            }
            while_break___2: /* CIL Label */ ;
            }
          }
        }
#line 271
        if ((int )major_version > 49) {
#line 271
          goto _L___2;
        } else
#line 271
        if ((int )major_version == 49) {
#line 271
          if ((int )minor_version >= 52) {
            _L___2: /* CIL Label */ 
            {
#line 272
            tmp___62 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((((int )pri_vendor_tbl_adr + 17) * ba) * ma));
#line 272
            pri_vendor_tbl->unlock_bypass = (uint8_t )((tmp___62 >> d) & 255U);
#line 273
            tmp___63 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((((int )pri_vendor_tbl_adr + 18) * ba) * ma));
#line 273
            tmp___2 = (tmp___63 >> d) & 255U;
            }
#line 274
            if (tmp___2) {
#line 274
              pri_vendor_tbl->secsi_sector_size = (uint8_t )(1 << tmp___2);
            } else {
#line 274
              pri_vendor_tbl->secsi_sector_size = (uint8_t )0;
            }
            {
#line 275
            tmp___64 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((((int )pri_vendor_tbl_adr + 19) * ba) * ma));
#line 275
            tmp___2 = (tmp___64 >> d) & 255U;
            }
#line 276
            if (tmp___2) {
#line 276
              pri_vendor_tbl->embedded_hwrst_timeout_max = (uint8_t )(1 << tmp___2);
            } else {
#line 276
              pri_vendor_tbl->embedded_hwrst_timeout_max = (uint8_t )0;
            }
            {
#line 277
            tmp___65 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((((int )pri_vendor_tbl_adr + 20) * ba) * ma));
#line 277
            tmp___2 = (tmp___65 >> d) & 255U;
            }
#line 278
            if (tmp___2) {
#line 278
              pri_vendor_tbl->non_embedded_hwrst_timeout_max = (uint8_t )(1 << tmp___2);
            } else {
#line 278
              pri_vendor_tbl->non_embedded_hwrst_timeout_max = (uint8_t )0;
            }
            {
#line 279
            tmp___66 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((((int )pri_vendor_tbl_adr + 21) * ba) * ma));
#line 279
            tmp___2 = (tmp___66 >> d) & 255U;
            }
#line 280
            if (tmp___2) {
#line 280
              pri_vendor_tbl->erase_suspend_timeout_max = (uint8_t )(1 << tmp___2);
            } else {
#line 280
              pri_vendor_tbl->erase_suspend_timeout_max = (uint8_t )0;
            }
            {
#line 281
            tmp___67 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((((int )pri_vendor_tbl_adr + 22) * ba) * ma));
#line 281
            tmp___2 = (tmp___67 >> d) & 255U;
            }
#line 282
            if (tmp___2) {
#line 282
              pri_vendor_tbl->program_suspend_timeout_max = (uint8_t )(1 << tmp___2);
            } else {
#line 282
              pri_vendor_tbl->program_suspend_timeout_max = (uint8_t )0;
            }
          }
        }
#line 285
        cfi->identification_string.pri_vendor_tbl = (void *)pri_vendor_tbl;
#line 291
        if ((int )major_version > 49) {
#line 291
          goto _L___3;
        } else
#line 291
        if ((int )major_version == 49) {
#line 291
          if ((int )minor_version >= 49) {
            _L___3: /* CIL Label */ 
#line 291
            if ((int )pri_vendor_tbl->top_bottom_sector_flag == 3) {
#line 295
              n = (uint32_t )cfi->device_geometry.number_of_erase_regions;
#line 297
              i___0 = 0;
              {
#line 297
              while (1) {
                while_continue___3: /* CIL Label */ ;
#line 297
                if (! ((uint32_t )i___0 < n / 2U)) {
#line 297
                  goto while_break___3;
                }
#line 298
                z___0 = (cfi->device_geometry.erase_block_regions + i___0)->erase_block_size;
#line 299
                y___0 = (cfi->device_geometry.erase_block_regions + i___0)->number_of_erase_blocks;
#line 300
                (cfi->device_geometry.erase_block_regions + i___0)->erase_block_size = (cfi->device_geometry.erase_block_regions + ((n - (uint32_t )i___0) - 1U))->erase_block_size;
#line 302
                (cfi->device_geometry.erase_block_regions + i___0)->number_of_erase_blocks = (cfi->device_geometry.erase_block_regions + ((n - (uint32_t )i___0) - 1U))->number_of_erase_blocks;
#line 304
                (cfi->device_geometry.erase_block_regions + ((n - (uint32_t )i___0) - 1U))->erase_block_size = z___0;
#line 305
                (cfi->device_geometry.erase_block_regions + ((n - (uint32_t )i___0) - 1U))->number_of_erase_blocks = y___0;
#line 297
                i___0 ++;
              }
              while_break___3: /* CIL Label */ ;
              }
            }
          }
        }
      }
    }
    {
#line 313
    (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )(255 << d));
    }
    {
#line 323
    if ((int )cfi->device_geometry.device_interface == 0) {
#line 323
      goto case_0;
    }
#line 328
    if ((int )cfi->device_geometry.device_interface == 1) {
#line 328
      goto case_1;
    }
#line 334
    if ((int )cfi->device_geometry.device_interface == 2) {
#line 334
      goto case_2;
    }
#line 341
    if ((int )cfi->device_geometry.device_interface == 3) {
#line 341
      goto case_3;
    }
#line 347
    if ((int )cfi->device_geometry.device_interface == 4) {
#line 347
      goto case_4;
    }
#line 356
    goto switch_default;
    case_0: /* CIL Label */ 
#line 324
    if (ma != 1) {
#line 325
      return (-7);
    }
#line 326
    (*((*cfi_array___0)->cfi_chips + d / 8U))->width = 1;
#line 327
    goto switch_break;
    case_1: /* CIL Label */ 
#line 329
    if (ma != 1) {
#line 330
      return (-7);
    }
#line 331
    (*((*cfi_array___0)->cfi_chips + d / 8U))->width = 2;
#line 332
    d += 8U;
#line 333
    goto switch_break;
    case_2: /* CIL Label */ 
#line 335
    if (ma != 1) {
#line 335
      if (ma != 2) {
#line 336
        return (-7);
      }
    }
#line 337
    (*((*cfi_array___0)->cfi_chips + d / 8U))->width = 2 / ma;
#line 338
    if (ma == 1) {
#line 339
      d += 8U;
    }
#line 340
    goto switch_break;
    case_3: /* CIL Label */ 
#line 342
    if (ma != 1) {
#line 343
      return (-7);
    }
#line 344
    (*((*cfi_array___0)->cfi_chips + d / 8U))->width = 4;
#line 345
    d += 24U;
#line 346
    goto switch_break;
    case_4: /* CIL Label */ 
#line 348
    if (ma != 1) {
#line 348
      if (ma != 2) {
#line 349
        return (-7);
      }
    }
#line 350
    (*((*cfi_array___0)->cfi_chips + d / 8U))->width = 4 / ma;
#line 351
    if (ma == 1) {
#line 352
      d += 24U;
    } else {
#line 354
      d += 8U;
    }
#line 355
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 357
    return (-7);
    switch_break: /* CIL Label */ ;
    }
#line 93
    d += 8U;
  }
  while_break: /* CIL Label */ ;
  }
#line 361
  return (0);
}
}
#line 456 "/usr/include/unistd.h"
extern int usleep(__useconds_t __useconds ) ;
#line 69 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/amd_flash.c"
struct __anonstruct_var_forced_detection_49 var_forced_detection  ;
#line 78
static int amd_29xx040_autodetect(cfi_array_t *cfi_array___0 ) ;
#line 79
static int amd_29xx040_status(bus_t *bus___0 , uint32_t adr , unsigned short data ) ;
#line 80
static void amd_29xx040_print_info(cfi_array_t *cfi_array___0 ) ;
#line 81
static void amd_29xx040_read_array(cfi_array_t *cfi_array___0 ) ;
#line 82
static int amd_29xx040_erase_block(cfi_array_t *cfi_array___0 , uint32_t adr ) ;
#line 83
static int amd_29xx040_program_single(cfi_array_t *cfi_array___0 , uint32_t adr ,
                                      uint32_t data ) ;
#line 84
static int amd_29xx040_program(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t *buffer ,
                               int count ) ;
#line 85
static int amd_29xx040_unlock_block(cfi_array_t *cfi_array___0 , uint32_t adr ) ;
#line 87 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/amd_flash.c"
int amd_detect(bus_t *bus___0 , uint32_t adr , cfi_array_t **cfi_array___0 ) 
{ 
  int mid ;
  int did ;
  bus_area_t area___0 ;
  cfi_query_structure_t *cfi ;
  void *tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  int tmp___2 ;
  unsigned int bw ;
  int ba ;
  int i ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 94
  if (! cfi_array___0) {
#line 95
    return (-1);
  } else
#line 94
  if (! bus___0) {
#line 95
    return (-1);
  }
  {
#line 97
  tmp = calloc((size_t )1, (size_t )sizeof(cfi_array_t ));
#line 97
  *cfi_array___0 = (cfi_array_t *)tmp;
  }
#line 98
  if (! *cfi_array___0) {
#line 99
    return (-2);
  }
  {
#line 101
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )240);
#line 102
  (*((bus___0->driver)->write))(bus___0, adr + 1365U, (uint32_t )170);
#line 103
  (*((bus___0->driver)->write))(bus___0, adr + 682U, (uint32_t )85);
#line 104
  (*((bus___0->driver)->write))(bus___0, adr + 1365U, (uint32_t )144);
#line 105
  tmp___0 = (*((bus___0->driver)->read))(bus___0, adr);
#line 105
  mid = (int )tmp___0;
#line 106
  tmp___1 = (*((bus___0->driver)->read))(bus___0, adr + 1U);
#line 106
  did = (int )tmp___1;
#line 107
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )240);
#line 109
  printf((char const   */* __restrict  */)"%s: mid %x, did %x\n", "amd_detect", mid,
         did);
  }
#line 110
  if (mid != 1) {
#line 111
    return (-1);
  }
  {
#line 115
  if (did == 164) {
#line 115
    goto case_164;
  }
#line 118
  if (did == 79) {
#line 118
    goto case_79;
  }
#line 122
  goto switch_default;
  case_164: /* CIL Label */ 
#line 116
  var_forced_detection.flash = 1UL;
#line 117
  goto switch_break;
  case_79: /* CIL Label */ 
#line 119
  var_forced_detection.flash = 1UL;
#line 120
  var_forced_detection.algorithm = (unsigned short)1;
#line 121
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 123
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 126
  (*cfi_array___0)->bus = bus___0;
#line 127
  (*cfi_array___0)->address = (uint32_t )0;
#line 128
  tmp___2 = (*((bus___0->driver)->area))(bus___0, adr, & area___0);
  }
#line 128
  if (tmp___2 != 0) {
#line 129
    return (-8);
  }
#line 130
  bw = area___0.width;
#line 132
  if (bw != 8U) {
#line 132
    if (bw != 16U) {
#line 132
      if (bw != 32U) {
#line 133
        return (-3);
      }
    }
  }
  {
#line 134
  ba = (int )(bw / 8U);
#line 134
  (*cfi_array___0)->bus_width = ba;
#line 135
  tmp___3 = calloc((size_t )ba, (size_t )sizeof(cfi_chip_t *));
#line 135
  (*cfi_array___0)->cfi_chips = (cfi_chip_t **)tmp___3;
  }
#line 136
  if (! (*cfi_array___0)->cfi_chips) {
#line 137
    return (-2);
  }
#line 138
  i = 0;
  {
#line 138
  while (1) {
    while_continue: /* CIL Label */ ;
#line 138
    if (! (i < ba)) {
#line 138
      goto while_break;
    }
    {
#line 140
    tmp___4 = calloc((size_t )1, (size_t )sizeof(cfi_chip_t ));
#line 140
    *((*cfi_array___0)->cfi_chips + i) = (cfi_chip_t *)tmp___4;
    }
#line 141
    if (! *((*cfi_array___0)->cfi_chips + i)) {
#line 142
      return (-2);
    }
    {
#line 143
    (*((*cfi_array___0)->cfi_chips + i))->width = 1;
#line 144
    cfi = & (*((*cfi_array___0)->cfi_chips + i))->cfi;
#line 146
    cfi->identification_string.pri_id_code = (uint16_t )0;
#line 147
    cfi->identification_string.pri_vendor_tbl = (void *)0;
#line 148
    cfi->identification_string.alt_id_code = (uint16_t )0;
#line 149
    cfi->identification_string.alt_vendor_tbl = (void *)0;
#line 151
    cfi->device_geometry.device_size = (uint32_t )524288;
#line 152
    cfi->device_geometry.device_interface = (uint16_t )0;
#line 153
    cfi->device_geometry.max_bytes_write = (uint32_t )32;
#line 154
    cfi->device_geometry.number_of_erase_regions = (uint8_t )1;
#line 155
    tmp___5 = malloc((size_t )((unsigned long )cfi->device_geometry.number_of_erase_regions * sizeof(cfi_erase_block_region_t )));
#line 155
    cfi->device_geometry.erase_block_regions = (cfi_erase_block_region_t *)tmp___5;
    }
#line 157
    if (! cfi->device_geometry.erase_block_regions) {
#line 158
      return (-2);
    }
#line 160
    (cfi->device_geometry.erase_block_regions + i)->erase_block_size = (uint32_t )65536;
#line 161
    (cfi->device_geometry.erase_block_regions + i)->number_of_erase_blocks = (uint32_t )8;
#line 138
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 164
  return (0);
}
}
#line 168 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/amd_flash.c"
static int amd_29xx040_autodetect(cfi_array_t *cfi_array___0 ) 
{ 


  {
#line 170
  return (var_forced_detection.flash == 1UL);
}
}
#line 173 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/amd_flash.c"
static int amd_29xx040_status(bus_t *bus___0 , uint32_t adr , unsigned short data ) 
{ 
  short timeout ;
  unsigned short dq7bit ;
  unsigned short dq7mask ;
  unsigned short dq5mask ;
  unsigned short data1 ;
  uint32_t tmp ;
  uint32_t tmp___0 ;

  {
#line 179
  dq7mask = (unsigned short )(1 << 7);
#line 180
  dq5mask = (unsigned short )(1 << 5);
#line 181
  dq7bit = (unsigned short )((int )data & (int )dq7mask);
#line 183
  timeout = (short)0;
  {
#line 183
  while (1) {
    while_continue: /* CIL Label */ ;
#line 183
    if (! ((int )timeout < 1000)) {
#line 183
      goto while_break;
    }
    {
#line 185
    tmp = (*((bus___0->driver)->read))(bus___0, adr);
#line 185
    data1 = (unsigned short )(tmp & 255U);
    }
#line 186
    if (((int )data1 & (int )dq7mask) == (int )dq7bit) {
#line 187
      return (1);
    }
#line 189
    if (((int )data1 & (int )dq5mask) == (int )dq5mask) {
      {
#line 191
      tmp___0 = (*((bus___0->driver)->read))(bus___0, adr);
#line 191
      data1 = (unsigned short )(tmp___0 & 255U);
      }
#line 192
      if (((int )data1 & (int )dq7mask) == (int )dq7bit) {
#line 194
        return (1);
      } else {
#line 198
        return (0);
      }
    }
    {
#line 201
    usleep((__useconds_t )50);
#line 183
    timeout = (short )((int )timeout + 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 204
  return (0);
}
}
#line 209 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/amd_flash.c"
static void amd_29xx040_print_info(cfi_array_t *cfi_array___0 ) 
{ 
  int mid ;
  int did ;
  int prot ;
  bus_t *bus___0 ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
  {
#line 212
  bus___0 = cfi_array___0->bus;
#line 215
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )240);
#line 216
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )170);
#line 217
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 682U, (uint32_t )85);
#line 218
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )144);
#line 219
  tmp = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 219
  mid = (int )tmp;
#line 220
  tmp___0 = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address + 1U);
#line 220
  did = (int )tmp___0;
#line 221
  tmp___1 = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address + 2U);
#line 221
  prot = (int )tmp___1;
#line 222
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )240);
#line 224
  printf((char const   */* __restrict  */)"%s: mid %x, did %x\n", "amd_29xx040_print_info",
         mid, did);
  }
  {
#line 229
  if (mid == 1) {
#line 229
    goto case_1;
  }
#line 232
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 230
  tmp___2 = gettext("Chip: AMD Flash\n\tPartNumber: ");
#line 230
  printf((char const   */* __restrict  */)tmp___2);
  }
#line 231
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 233
  tmp___3 = gettext("Unknown manufacturer (ID 0x%04x)");
#line 233
  printf((char const   */* __restrict  */)tmp___3, mid);
  }
#line 234
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 236
  tmp___4 = gettext("\n\tChip: ");
#line 236
  printf((char const   */* __restrict  */)tmp___4);
  }
  {
#line 238
  if (did == 164) {
#line 238
    goto case_164;
  }
#line 242
  if (did == 79) {
#line 242
    goto case_79;
  }
#line 246
  goto switch_default___0;
  case_164: /* CIL Label */ 
  {
#line 239
  printf((char const   */* __restrict  */)"Am29C040B\t-\t");
#line 240
  tmp___5 = gettext("5V Flash\n");
#line 240
  printf((char const   */* __restrict  */)tmp___5);
  }
#line 241
  goto switch_break___0;
  case_79: /* CIL Label */ 
  {
#line 243
  printf((char const   */* __restrict  */)"Am29LV040B\t-\t");
#line 244
  tmp___6 = gettext("3V Flash\n");
#line 244
  printf((char const   */* __restrict  */)tmp___6);
  }
#line 245
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 247
  tmp___7 = gettext("Unknown (ID 0x%04x)");
#line 247
  printf((char const   */* __restrict  */)tmp___7, did);
  }
#line 248
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 250
  tmp___8 = gettext("\n\tProtected: %04x\n");
#line 250
  printf((char const   */* __restrict  */)tmp___8, prot);
  }
#line 251
  return;
}
}
#line 253 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/amd_flash.c"
static void amd_29xx040_read_array(cfi_array_t *cfi_array___0 ) 
{ 


  {
#line 256
  if ((int )var_forced_detection.unlock_bypass == 1) {
    {
#line 258
    (*((bus->driver)->write))(bus, cfi_array___0->address + 1365U, (uint32_t )144);
#line 259
    (*((bus->driver)->write))(bus, cfi_array___0->address + 682U, (uint32_t )0);
#line 260
    usleep((__useconds_t )100);
#line 261
    var_forced_detection.unlock_bypass = (unsigned short)0;
    }
  }
  {
#line 263
  (*(((cfi_array___0->bus)->driver)->write))(cfi_array___0->bus, cfi_array___0->address,
                                             (uint32_t )240);
  }
#line 264
  return;
}
}
#line 268 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/amd_flash.c"
static int amd_29xx040_erase_block(cfi_array_t *cfi_array___0 , uint32_t adr ) 
{ 
  bus_t *bus___0 ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 270
  bus___0 = cfi_array___0->bus;
#line 272
  printf((char const   */* __restrict  */)"flash_erase_block 0x%08X\n", adr);
  }
#line 276
  if ((int )var_forced_detection.unlock_bypass == 1) {
    {
#line 278
    (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )144);
#line 279
    (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 682U, (uint32_t )0);
#line 280
    usleep((__useconds_t )100);
#line 281
    var_forced_detection.unlock_bypass = (unsigned short)0;
    }
  }
  {
#line 284
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )240);
#line 285
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )170);
#line 286
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 682U, (uint32_t )85);
#line 287
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )128);
#line 288
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )170);
#line 289
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 682U, (uint32_t )85);
#line 291
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )48);
#line 294
  tmp = amd_29xx040_status(bus___0, adr, (unsigned short)255);
  }
#line 294
  if (tmp) {
    {
#line 295
    printf((char const   */* __restrict  */)"flash_erase_block 0x%08X DONE\n", adr);
#line 296
    amd_29xx040_read_array(cfi_array___0);
    }
#line 297
    return (1);
  }
  {
#line 299
  printf((char const   */* __restrict  */)"flash_erase_block 0x%08X FAILED\n", adr);
#line 301
  amd_29xx040_read_array(cfi_array___0);
  }
#line 303
  return (-5);
}
}
#line 306 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/amd_flash.c"
static int amd_29xx040_program_single(cfi_array_t *cfi_array___0 , uint32_t adr ,
                                      uint32_t data ) 
{ 
  int status ;
  bus_t *bus___0 ;

  {
#line 309
  bus___0 = cfi_array___0->bus;
#line 313
  if ((int )var_forced_detection.algorithm == 1) {
#line 315
    if ((int )var_forced_detection.unlock_bypass != 1) {
      {
#line 317
      (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )170);
#line 318
      (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 682U, (uint32_t )85);
#line 319
      (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )32);
#line 320
      usleep((__useconds_t )1000);
#line 321
      var_forced_detection.unlock_bypass = (unsigned short)1;
      }
    }
  } else {
    {
#line 326
    (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )170);
#line 327
    (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 682U, (uint32_t )85);
    }
  }
  {
#line 330
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )160);
#line 331
  (*((bus___0->driver)->write))(bus___0, adr, data);
#line 332
  status = amd_29xx040_status(bus___0, adr, (unsigned short )data);
  }
#line 335
  return (! status);
}
}
#line 338 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/amd_flash.c"
static int amd_29xx040_program(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t *buffer ,
                               int count ) 
{ 
  int idx ;
  int status ;
  int tmp ;

  {
#line 343
  idx = 0;
  {
#line 343
  while (1) {
    while_continue: /* CIL Label */ ;
#line 343
    if (! (idx < count)) {
#line 343
      goto while_break;
    }
    {
#line 344
    tmp = amd_29xx040_program_single(cfi_array___0, adr, *(buffer + idx));
#line 344
    status = tmp;
    }
#line 345
    if (status) {
#line 346
      return (status);
    }
#line 347
    adr += (uint32_t )cfi_array___0->bus_width;
#line 343
    idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 350
  return (0);
}
}
#line 353 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/amd_flash.c"
static int amd_29xx040_unlock_block(cfi_array_t *cfi_array___0 , uint32_t adr ) 
{ 
  char *__cil_tmp3 ;

  {
  {
#line 355
  printf((char const   */* __restrict  */)"flash_unlock_block 0x%08X IGNORE\n", adr);
  }
#line 356
  return (0);
}
}
#line 360 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/amd_flash.c"
flash_driver_t amd_29xx040_flash_driver  = 
#line 360
     {1U, "AMD Standard Command Set", "supported: AMD 29LV040B, 29C040B, 1x8 Bit", & amd_29xx040_autodetect,
    & amd_29xx040_print_info, & amd_29xx040_erase_block, & amd_29xx040_unlock_block,
    & amd_29xx040_program, & amd_29xx040_read_array};
#line 48 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/amd.c"
static int dbg  =    0;
#line 50
static int amd_flash_erase_block(cfi_array_t *cfi_array___0 , uint32_t adr ) ;
#line 51
static int amd_flash_unlock_block(cfi_array_t *cfi_array___0 , uint32_t adr ) ;
#line 52
static int amd_flash_program_single(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t data ) ;
#line 53
static int amd_flash_program_buffer(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t *buffer ,
                                    int count ) ;
#line 54
static int amd_flash_program(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t *buffer ,
                             int count ) ;
#line 55
static int amd_flash_program32(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t *buffer ,
                               int count ) ;
#line 56
static void amd_flash_read_array(cfi_array_t *cfi_array___0 ) ;
#line 75 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/amd.c"
static int amd_flash_address_shift(cfi_array_t *cfi_array___0 ) 
{ 


  {
#line 78
  if (cfi_array___0->bus_width == 4) {
#line 78
    return (2);
  }
  {
#line 85
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.device_geometry.device_interface == 1) {
#line 85
    goto case_1;
  }
#line 85
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.device_geometry.device_interface == 2) {
#line 85
    goto case_1;
  }
#line 89
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.device_geometry.device_interface == 3) {
#line 89
    goto case_3;
  }
#line 89
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.device_geometry.device_interface == 4) {
#line 89
    goto case_3;
  }
#line 92
  goto switch_default;
  case_1: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 86
  return (1);
  case_3: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 90
  return (2);
  switch_default: /* CIL Label */ 
#line 92
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 95
  if (cfi_array___0->bus_width == 2) {
#line 95
    return (1);
  }
#line 97
  return (0);
}
}
#line 101 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/amd.c"
static int amd_flash_autodetect32(cfi_array_t *cfi_array___0 ) 
{ 


  {
#line 104
  if (cfi_array___0->bus_width != 4) {
#line 104
    return (0);
  }
#line 105
  return ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 2);
}
}
#line 108 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/amd.c"
static int amd_flash_autodetect16(cfi_array_t *cfi_array___0 ) 
{ 


  {
#line 111
  if (cfi_array___0->bus_width != 2) {
#line 111
    return (0);
  }
#line 112
  return ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 2);
}
}
#line 115 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/amd.c"
static int amd_flash_autodetect8(cfi_array_t *cfi_array___0 ) 
{ 


  {
#line 118
  if (cfi_array___0->bus_width != 1) {
#line 118
    return (0);
  }
#line 119
  return ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 2);
}
}
#line 167 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/amd.c"
static int amdstatus(cfi_array_t *cfi_array___0 , uint32_t adr , int data ) 
{ 
  bus_t *bus___0 ;
  int timeout ;
  uint32_t togglemask ;
  uint32_t data1 ;
  uint32_t tmp ;
  uint32_t data2 ;
  uint32_t tmp___0 ;
  char *__cil_tmp11 ;

  {
#line 170
  bus___0 = cfi_array___0->bus;
#line 173
  togglemask = (uint32_t )(((1 << 6) << 16) + (1 << 6));
#line 176
  timeout = 0;
  {
#line 176
  while (1) {
    while_continue: /* CIL Label */ ;
#line 176
    if (! (timeout < 7000)) {
#line 176
      goto while_break;
    }
    {
#line 177
    tmp = (*((bus___0->driver)->read))(bus___0, adr);
#line 177
    data1 = tmp;
#line 178
    tmp___0 = (*((bus___0->driver)->read))(bus___0, adr);
#line 178
    data2 = tmp___0;
    }
#line 182
    if ((data1 & togglemask) == (data2 & togglemask)) {
#line 183
      return (1);
    }
#line 187
    if (dbg) {
      {
#line 188
      printf((char const   */* __restrict  */)"amdstatus %d: %04X/%04X\n", timeout,
             data1, data2);
      }
    }
    {
#line 189
    usleep((__useconds_t )100);
#line 176
    timeout ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 191
  return (0);
}
}
#line 265 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/amd.c"
static void amd_flash_print_info(cfi_array_t *cfi_array___0 ) 
{ 
  int mid ;
  int cid ;
  int prot ;
  bus_t *bus___0 ;
  int o ;
  int tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;

  {
  {
#line 269
  bus___0 = cfi_array___0->bus;
#line 270
  tmp = amd_flash_address_shift(cfi_array___0);
#line 270
  o = tmp;
#line 272
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(1365 << o),
                                (uint32_t )11141290);
#line 273
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(682 << o),
                                (uint32_t )5570645);
#line 274
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(1365 << o),
                                (uint32_t )9437328);
#line 275
  tmp___0 = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 275
  mid = (int )(tmp___0 & 65535U);
#line 276
  tmp___1 = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address + (uint32_t )(1 << o));
#line 276
  cid = (int )(tmp___1 & 65535U);
#line 277
  tmp___2 = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address + (uint32_t )(2 << o));
#line 277
  prot = (int )(tmp___2 & 255U);
#line 278
  amd_flash_read_array(cfi_array___0);
#line 279
  tmp___3 = gettext("Chip: AMD Flash\n\tManufacturer: ");
#line 279
  printf((char const   */* __restrict  */)tmp___3);
  }
  {
#line 281
  if (mid == 1) {
#line 281
    goto case_1;
  }
#line 309
  if (mid == 31) {
#line 309
    goto case_31;
  }
#line 324
  if (mid == 32) {
#line 324
    goto case_32;
  }
#line 342
  if (mid == 194) {
#line 342
    goto case_194;
  }
#line 357
  goto switch_default___3;
  case_1: /* CIL Label */ 
  {
#line 282
  printf((char const   */* __restrict  */)"AMD");
#line 283
  tmp___4 = gettext("\n\tChip: ");
#line 283
  printf((char const   */* __restrict  */)tmp___4);
  }
  {
#line 285
  if (cid == 73) {
#line 285
    goto case_73;
  }
#line 288
  if (cid == 147) {
#line 288
    goto case_147;
  }
#line 291
  if (cid == 79) {
#line 291
    goto case_79;
  }
#line 294
  if (cid == 8919) {
#line 294
    goto case_8919;
  }
#line 297
  if (cid == 8795) {
#line 297
    goto case_8795;
  }
#line 301
  if (cid == 126) {
#line 301
    goto case_126;
  }
#line 301
  if (cid == 8830) {
#line 301
    goto case_126;
  }
#line 304
  goto switch_default;
  case_73: /* CIL Label */ 
  {
#line 286
  printf((char const   */* __restrict  */)"AM29LV160DB");
  }
#line 287
  goto switch_break___0;
  case_147: /* CIL Label */ 
  {
#line 289
  printf((char const   */* __restrict  */)"Am29LV065D");
  }
#line 290
  goto switch_break___0;
  case_79: /* CIL Label */ 
  {
#line 292
  printf((char const   */* __restrict  */)"Am29LV040B");
  }
#line 293
  goto switch_break___0;
  case_8919: /* CIL Label */ 
  {
#line 295
  printf((char const   */* __restrict  */)"Am29LV640D/Am29LV641D/Am29LV642D");
  }
#line 296
  goto switch_break___0;
  case_8795: /* CIL Label */ 
  {
#line 298
  printf((char const   */* __restrict  */)"Am29LV800B");
  }
#line 299
  goto switch_break___0;
  case_126: /* CIL Label */ 
  case_8830: /* CIL Label */ 
  {
#line 302
  printf((char const   */* __restrict  */)"S92GLxxxN");
  }
#line 303
  goto switch_break___0;
  switch_default: /* CIL Label */ 
  {
#line 305
  tmp___5 = gettext("Unknown (ID 0x%04x)");
#line 305
  printf((char const   */* __restrict  */)tmp___5, cid);
  }
#line 306
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 308
  goto switch_break;
  case_31: /* CIL Label */ 
  {
#line 310
  printf((char const   */* __restrict  */)"Atmel");
#line 311
  tmp___6 = gettext("\n\tChip: ");
#line 311
  printf((char const   */* __restrict  */)tmp___6);
  }
  {
#line 313
  if (cid == 466) {
#line 313
    goto case_466;
  }
#line 316
  if (cid == 470) {
#line 316
    goto case_470;
  }
#line 319
  goto switch_default___0;
  case_466: /* CIL Label */ 
  {
#line 314
  printf((char const   */* __restrict  */)"AT49BW642DT");
  }
#line 315
  goto switch_break___1;
  case_470: /* CIL Label */ 
  {
#line 317
  printf((char const   */* __restrict  */)"AT49BW642D");
  }
#line 318
  goto switch_break___1;
  switch_default___0: /* CIL Label */ 
  {
#line 320
  tmp___7 = gettext("Unknown (ID 0x%04x)");
#line 320
  printf((char const   */* __restrict  */)tmp___7, cid);
  }
#line 321
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 323
  goto switch_break;
  case_32: /* CIL Label */ 
  {
#line 325
  printf((char const   */* __restrict  */)"ST/Samsung");
#line 326
  tmp___8 = gettext("\n\tChip: ");
#line 326
  printf((char const   */* __restrict  */)tmp___8);
  }
  {
#line 328
  if (cid == 202) {
#line 328
    goto case_202;
  }
#line 331
  if (cid == 203) {
#line 331
    goto case_203;
  }
#line 334
  if (cid == 8941) {
#line 334
    goto case_8941;
  }
#line 337
  goto switch_default___1;
  case_202: /* CIL Label */ 
  {
#line 329
  printf((char const   */* __restrict  */)"M29W320DT");
  }
#line 330
  goto switch_break___2;
  case_203: /* CIL Label */ 
  {
#line 332
  printf((char const   */* __restrict  */)"M29W320DB");
  }
#line 333
  goto switch_break___2;
  case_8941: /* CIL Label */ 
  {
#line 335
  printf((char const   */* __restrict  */)"M29W640DT");
  }
#line 336
  goto switch_break___2;
  switch_default___1: /* CIL Label */ 
  {
#line 338
  tmp___9 = gettext("Unknown (ID 0x%04x)");
#line 338
  printf((char const   */* __restrict  */)tmp___9, cid);
  }
#line 339
  goto switch_break___2;
  switch_break___2: /* CIL Label */ ;
  }
#line 341
  goto switch_break;
  case_194: /* CIL Label */ 
  {
#line 343
  printf((char const   */* __restrict  */)"Macronix");
#line 344
  tmp___10 = gettext("\n\tChip: ");
#line 344
  printf((char const   */* __restrict  */)tmp___10);
  }
  {
#line 346
  if (cid == 8777) {
#line 346
    goto case_8777;
  }
#line 349
  if (cid == 8907) {
#line 349
    goto case_8907;
  }
#line 352
  goto switch_default___2;
  case_8777: /* CIL Label */ 
  {
#line 347
  printf((char const   */* __restrict  */)"MX29LV160B");
  }
#line 348
  goto switch_break___3;
  case_8907: /* CIL Label */ 
  {
#line 350
  printf((char const   */* __restrict  */)"MX29LV640B");
  }
#line 351
  goto switch_break___3;
  switch_default___2: /* CIL Label */ 
  {
#line 353
  tmp___11 = gettext("Unknown (ID 0x%04x)");
#line 353
  printf((char const   */* __restrict  */)tmp___11, cid);
  }
#line 354
  goto switch_break___3;
  switch_break___3: /* CIL Label */ ;
  }
#line 356
  goto switch_break;
  switch_default___3: /* CIL Label */ 
  {
#line 358
  tmp___12 = gettext("Unknown manufacturer (ID 0x%04x) Chip (ID 0x%04x)");
#line 358
  printf((char const   */* __restrict  */)tmp___12, mid, cid);
  }
#line 359
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 361
  tmp___13 = gettext("\n\tProtected: %04x\n");
#line 361
  printf((char const   */* __restrict  */)tmp___13, prot);
#line 364
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )16711935);
  }
#line 365
  return;
}
}
#line 367 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/amd.c"
static int amd_flash_erase_block(cfi_array_t *cfi_array___0 , uint32_t adr ) 
{ 
  bus_t *bus___0 ;
  int o ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 370
  bus___0 = cfi_array___0->bus;
#line 371
  tmp = amd_flash_address_shift(cfi_array___0);
#line 371
  o = tmp;
#line 373
  printf((char const   */* __restrict  */)"flash_erase_block 0x%08X\n", adr);
#line 377
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(1365 << o),
                                (uint32_t )11141290);
#line 378
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(682 << o),
                                (uint32_t )5570645);
#line 379
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(1365 << o),
                                (uint32_t )8388736);
#line 380
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(1365 << o),
                                (uint32_t )11141290);
#line 381
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(682 << o),
                                (uint32_t )5570645);
#line 382
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )3145776);
#line 384
  tmp___0 = amdstatus(cfi_array___0, adr, 65535);
  }
#line 384
  if (tmp___0) {
    {
#line 385
    printf((char const   */* __restrict  */)"flash_erase_block 0x%08X DONE\n", adr);
#line 386
    amd_flash_read_array(cfi_array___0);
    }
#line 387
    return (0);
  }
  {
#line 389
  printf((char const   */* __restrict  */)"flash_erase_block 0x%08X FAILED\n", adr);
#line 391
  amd_flash_read_array(cfi_array___0);
  }
#line 393
  return (99);
}
}
#line 396 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/amd.c"
static int amd_flash_unlock_block(cfi_array_t *cfi_array___0 , uint32_t adr ) 
{ 
  char *__cil_tmp3 ;

  {
  {
#line 399
  printf((char const   */* __restrict  */)"flash_unlock_block 0x%08X IGNORE\n", adr);
  }
#line 400
  return (0);
}
}
#line 403 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/amd.c"
static int amd_flash_program_single(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t data ) 
{ 
  int status ;
  bus_t *bus___0 ;
  int o ;
  int tmp ;
  char *__cil_tmp8 ;

  {
  {
#line 407
  bus___0 = cfi_array___0->bus;
#line 408
  tmp = amd_flash_address_shift(cfi_array___0);
#line 408
  o = tmp;
  }
#line 410
  if (dbg) {
    {
#line 411
    printf((char const   */* __restrict  */)"\nflash_program 0x%08X = 0x%08X\n", adr,
           data);
    }
  }
  {
#line 413
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(1365 << o),
                                (uint32_t )11141290);
#line 414
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(682 << o),
                                (uint32_t )5570645);
#line 415
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(1365 << o),
                                (uint32_t )10485920);
#line 417
  (*((bus___0->driver)->write))(bus___0, adr, data);
#line 418
  status = amdstatus(cfi_array___0, adr, (int )data);
  }
#line 421
  return (! status);
}
}
#line 424 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/amd.c"
static int amd_program_buffer_status(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t data ) 
{ 
  bus_t *bus___0 ;
  int timeout ;
  uint32_t dq7mask ;
  uint32_t dq5mask ;
  uint32_t bit7 ;
  uint32_t data1 ;
  char *__cil_tmp10 ;

  {
#line 430
  bus___0 = cfi_array___0->bus;
#line 432
  dq7mask = (uint32_t )(1 << 7);
#line 433
  dq5mask = (uint32_t )(1 << 5);
#line 434
  bit7 = data & dq7mask;
#line 437
  timeout = 0;
  {
#line 437
  while (1) {
    while_continue: /* CIL Label */ ;
#line 437
    if (! (timeout < 7000)) {
#line 437
      goto while_break;
    }
    {
#line 438
    data1 = (*((bus___0->driver)->read))(bus___0, adr);
    }
#line 439
    if (dbg) {
      {
#line 440
      printf((char const   */* __restrict  */)"amd_program_buffer_status %d: %04X (%04X) = %04X\n",
             timeout, data1, data1 & dq7mask, bit7);
      }
    }
#line 441
    if ((data1 & dq7mask) == bit7) {
#line 442
      return (1);
    }
#line 444
    if ((data1 & dq5mask) == dq5mask) {
#line 445
      goto while_break;
    }
    {
#line 446
    usleep((__useconds_t )100);
#line 437
    timeout ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 449
  data1 = (*((bus___0->driver)->read))(bus___0, adr);
  }
#line 450
  if ((data1 & dq7mask) == bit7) {
#line 451
    return (1);
  }
#line 453
  return (0);
}
}
#line 456 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/amd.c"
static int amd_flash_program_buffer(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t *buffer ,
                                    int count ) 
{ 
  int status ;
  bus_t *bus___0 ;
  cfi_chip_t *cfi_chip ;
  int o ;
  int tmp ;
  int wb_bytes ;
  int chip_width ;
  int offset ;
  int wcount ;
  int idx ;
  uint32_t sa ;
  char *__cil_tmp16 ;

  {
  {
#line 461
  bus___0 = cfi_array___0->bus;
#line 462
  cfi_chip = *(cfi_array___0->cfi_chips + 0);
#line 463
  tmp = amd_flash_address_shift(cfi_array___0);
#line 463
  o = tmp;
#line 464
  wb_bytes = (int )cfi_chip->cfi.device_geometry.max_bytes_write;
#line 465
  chip_width = cfi_chip->width;
#line 466
  offset = 0;
  }
#line 468
  if (dbg) {
    {
#line 469
    printf((char const   */* __restrict  */)"\nflash_program_buffer 0x%08X, count 0x%08X\n",
           adr, count);
    }
  }
  {
#line 471
  while (1) {
    while_continue: /* CIL Label */ ;
#line 471
    if (! (count > 0)) {
#line 471
      goto while_break;
    }
#line 473
    sa = adr;
#line 476
    wcount = (int )((unsigned int )wb_bytes - adr % (unsigned int )wb_bytes);
#line 477
    wcount /= chip_width;
#line 478
    if (wcount > count) {
#line 479
      wcount = count;
    }
    {
#line 481
    (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(1365 << o),
                                  (uint32_t )11141290);
#line 482
    (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(682 << o),
                                  (uint32_t )5570645);
#line 483
    (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )2424869);
#line 484
    (*((bus___0->driver)->write))(bus___0, sa, (uint32_t )(wcount - 1));
#line 487
    idx = 0;
    }
    {
#line 487
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 487
      if (! (idx < wcount)) {
#line 487
        goto while_break___0;
      }
      {
#line 488
      (*((bus___0->driver)->write))(bus___0, adr, *(buffer + (offset + idx)));
#line 489
      adr += (uint32_t )cfi_array___0->bus_width;
#line 487
      idx ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 491
    offset += wcount;
#line 494
    (*((bus___0->driver)->write))(bus___0, sa, (uint32_t )2687017);
#line 496
    status = amd_program_buffer_status(cfi_array___0, adr - (uint32_t )cfi_array___0->bus_width,
                                       *(buffer + (offset - 1)));
    }
#line 498
    if (status != 1) {
#line 499
      return (1);
    }
#line 501
    count -= wcount;
  }
  while_break: /* CIL Label */ ;
  }
#line 504
  return (0);
}
}
#line 507 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/amd.c"
static int amd_flash_program(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t *buffer ,
                             int count ) 
{ 
  cfi_query_structure_t *cfi ;
  int max_bytes_write ;
  int tmp ;
  int idx ;
  int status ;
  int tmp___0 ;

  {
#line 510
  cfi = & (*(cfi_array___0->cfi_chips + 0))->cfi;
#line 511
  max_bytes_write = (int )cfi->device_geometry.max_bytes_write;
#line 518
  if (max_bytes_write > 1) {
    {
#line 519
    tmp = amd_flash_program_buffer(cfi_array___0, adr, buffer, count);
    }
#line 519
    return (tmp);
  } else {
#line 525
    idx = 0;
    {
#line 525
    while (1) {
      while_continue: /* CIL Label */ ;
#line 525
      if (! (idx < count)) {
#line 525
        goto while_break;
      }
      {
#line 526
      tmp___0 = amd_flash_program_single(cfi_array___0, adr, *(buffer + idx));
#line 526
      status = tmp___0;
      }
#line 527
      if (status) {
#line 528
        return (status);
      }
#line 529
      adr += (uint32_t )cfi_array___0->bus_width;
#line 525
      idx ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 533
  return (0);
}
}
#line 536 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/amd.c"
static int amd_flash_program32(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t *buffer ,
                               int count ) 
{ 
  int idx ;
  int status ;
  int tmp ;

  {
#line 547
  idx = 0;
  {
#line 547
  while (1) {
    while_continue: /* CIL Label */ ;
#line 547
    if (! (idx < count)) {
#line 547
      goto while_break;
    }
    {
#line 548
    tmp = amd_flash_program_single(cfi_array___0, adr, *(buffer + idx));
#line 548
    status = tmp;
    }
#line 549
    if (status) {
#line 550
      return (status);
    }
#line 551
    adr += (uint32_t )cfi_array___0->bus_width;
#line 547
    idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 554
  return (0);
}
}
#line 557 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/amd.c"
static void amd_flash_read_array(cfi_array_t *cfi_array___0 ) 
{ 


  {
  {
#line 561
  (*(((cfi_array___0->bus)->driver)->write))(cfi_array___0->bus, cfi_array___0->address,
                                             (uint32_t )15728880);
  }
#line 562
  return;
}
}
#line 564 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/amd.c"
flash_driver_t amd_32_flash_driver  = 
#line 564
     {4U, "AMD/Fujitsu Standard Command Set", "supported: AMD 29LV640D, 29LV641D, 29LV642D; 2x16 Bit",
    & amd_flash_autodetect32, & amd_flash_print_info, & amd_flash_erase_block, & amd_flash_unlock_block,
    & amd_flash_program32, & amd_flash_read_array};
#line 576 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/amd.c"
flash_driver_t amd_16_flash_driver  = 
#line 576
     {2U, "AMD/Fujitsu Standard Command Set", "supported: AMD 29LV800B, S92GLxxxN; MX29LV640B; 1x16 Bit",
    & amd_flash_autodetect16, & amd_flash_print_info, & amd_flash_erase_block, & amd_flash_unlock_block,
    & amd_flash_program, & amd_flash_read_array};
#line 588 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/amd.c"
flash_driver_t amd_8_flash_driver  = 
#line 588
     {1U, "AMD/Fujitsu Standard Command Set", "supported: AMD 29LV160, AMD 29LV065D, AMD 29LV040B, S92GLxxxN; 1x8 Bit",
    & amd_flash_autodetect8, & amd_flash_print_info, & amd_flash_erase_block, & amd_flash_unlock_block,
    & amd_flash_program, & amd_flash_read_array};
#line 53 "../../include/parport.h"
int parport_open(parport_t *port ) ;
#line 55
int parport_set_data(parport_t *port , uint8_t data ) ;
#line 56
int parport_get_data(parport_t *port ) ;
#line 57
int parport_get_status(parport_t *port ) ;
#line 144 "../../include/cable.h"
void cable_wait(cable_t *cable ) ;
#line 37 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/generic.h"
void generic_disconnect(cable_t *cable ) ;
#line 38
void generic_set_frequency(cable_t *cable , uint32_t new_frequency ) ;
#line 39
int generic_transfer(cable_t *cable , int len , char *in , char *out ) ;
#line 40
int generic_get_signal(cable_t *cable , pod_sigsel_t sig ) ;
#line 41
void generic_flush_one_by_one(cable_t *cable , cable_flush_amount_t how_much ) ;
#line 31 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/generic_parport.h"
int generic_parport_connect(char **params , cable_t *cable ) ;
#line 32
void generic_parport_free(cable_t *cable ) ;
#line 33
void generic_parport_done(cable_t *cable ) ;
#line 34
void generic_parport_help(char const   *cablename ) ;
#line 68 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/wiggler2.c"
static int wiggler2_init(cable_t *cable ) 
{ 
  int data ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 73
  tmp = parport_open(cable->link.port);
  }
#line 73
  if (tmp) {
#line 74
    return (-1);
  }
  {
#line 79
  data = parport_get_data(cable->link.port);
  }
#line 79
  if (data < 0) {
    {
#line 80
    tmp___0 = parport_set_data(cable->link.port, (uint8_t )((1 << 4) | (~ (((((1 << 3) | (1 << 2)) | (1 << 1)) | (1 << 4)) | 1) & 255)));
    }
#line 80
    if (tmp___0) {
#line 81
      return (-1);
    }
#line 82
    ((generic_params_t *)cable->params)->signals = 8;
  } else
#line 84
  if (data >> 4) {
#line 84
    ((generic_params_t *)cable->params)->signals = 8;
  } else {
#line 84
    ((generic_params_t *)cable->params)->signals = 0;
  }
#line 86
  return (0);
}
}
#line 89 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/wiggler2.c"
static void wiggler2_clock(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;
  int trst ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 93
  if (((generic_params_t *)cable->params)->signals & 8) {
#line 93
    tmp = 1;
  } else {
#line 93
    tmp = 0;
  }
#line 93
  trst = tmp;
#line 95
  if (tms) {
#line 95
    tms = 1;
  } else {
#line 95
    tms = 0;
  }
#line 96
  if (tdi) {
#line 96
    tdi = 1;
  } else {
#line 96
    tdi = 0;
  }
#line 98
  i = 0;
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! (i < n)) {
#line 98
      goto while_break;
    }
    {
#line 99
    parport_set_data(cable->link.port, (uint8_t )((((trst << 4) | (tms << 1)) | (tdi << 3)) | (~ (((((1 << 3) | (1 << 2)) | (1 << 1)) | (1 << 4)) | 1) & 255)));
#line 100
    cable_wait(cable);
#line 101
    parport_set_data(cable->link.port, (uint8_t )(((((trst << 4) | (1 << 2)) | (tms << 1)) | (tdi << 3)) | (~ (((((1 << 3) | (1 << 2)) | (1 << 1)) | (1 << 4)) | 1) & 255)));
#line 102
    cable_wait(cable);
#line 98
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 105
  ((generic_params_t *)cable->params)->signals &= 8;
#line 106
  ((generic_params_t *)cable->params)->signals |= 2;
#line 107
  if (tms) {
#line 107
    tmp___0 = 4;
  } else {
#line 107
    tmp___0 = 0;
  }
#line 107
  ((generic_params_t *)cable->params)->signals |= tmp___0;
#line 108
  if (tdi) {
#line 108
    tmp___1 = 1;
  } else {
#line 108
    tmp___1 = 0;
  }
#line 108
  ((generic_params_t *)cable->params)->signals |= tmp___1;
#line 109
  return;
}
}
#line 111 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/wiggler2.c"
static int wiggler2_get_tdo(cable_t *cable ) 
{ 
  int trst ;
  int tmp ;
  int tmp___0 ;

  {
#line 114
  if (((generic_params_t *)cable->params)->signals & 8) {
#line 114
    tmp = 1;
  } else {
#line 114
    tmp = 0;
  }
  {
#line 114
  trst = tmp;
#line 116
  parport_set_data(cable->link.port, (uint8_t )((trst << 4) | (~ (((((1 << 3) | (1 << 2)) | (1 << 1)) | (1 << 4)) | 1) & 255)));
#line 117
  ((generic_params_t *)cable->params)->signals &= -8;
#line 119
  cable_wait(cable);
#line 121
  tmp___0 = parport_get_status(cable->link.port);
  }
#line 121
  return ((tmp___0 >> 7) & 1);
}
}
#line 124 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/wiggler2.c"
static int wiggler2_set_signal(cable_t *cable , int mask , int val ) 
{ 
  int prev_sigs ;
  int data ;
  int sigs ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 127
  prev_sigs = ((generic_params_t *)cable->params)->signals;
#line 129
  mask &= 15;
#line 131
  if (mask != 0) {
#line 133
    data = 0;
#line 134
    sigs = (prev_sigs & ~ mask) | (val & mask);
#line 135
    if (sigs & 1) {
#line 135
      tmp = 1 << 3;
    } else {
#line 135
      tmp = 0;
    }
#line 135
    data |= tmp;
#line 136
    if (sigs & 2) {
#line 136
      tmp___0 = 1 << 2;
    } else {
#line 136
      tmp___0 = 0;
    }
#line 136
    data |= tmp___0;
#line 137
    if (sigs & 4) {
#line 137
      tmp___1 = 1 << 1;
    } else {
#line 137
      tmp___1 = 0;
    }
#line 137
    data |= tmp___1;
#line 138
    if (sigs & 8) {
#line 138
      tmp___2 = 1 << 4;
    } else {
#line 138
      tmp___2 = 0;
    }
    {
#line 138
    data |= tmp___2;
#line 139
    parport_set_data(cable->link.port, (uint8_t )(data | (~ (((((1 << 3) | (1 << 2)) | (1 << 1)) | (1 << 4)) | 1) & 255)));
#line 140
    ((generic_params_t *)cable->params)->signals = sigs;
    }
  }
#line 143
  return (prev_sigs);
}
}
#line 146 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/wiggler2.c"
cable_driver_t wiggler2_cable_driver  = 
#line 146
     {"WIGGLER2", "Modified (with CPU Reset) WIGGLER JTAG Cable", & generic_parport_connect,
    & generic_disconnect, & generic_parport_free, & wiggler2_init, & generic_parport_done,
    & generic_set_frequency, & wiggler2_clock, & wiggler2_get_tdo, & generic_transfer,
    & wiggler2_set_signal, & generic_get_signal, & generic_flush_one_by_one, & generic_parport_help};
#line 70 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/wiggler.c"
static char const   *std_wgl_map  =    "7,4,3,2,1,#0";
#line 112 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/wiggler.c"
static int map_pin(char *pin , int *act , int *inact ) 
{ 
  int bitnum ;
  int inverted ;
  unsigned short const   **tmp ;
  int tmp___0 ;

  {
#line 116
  inverted = 0;
#line 118
  if ((int )*pin == 35) {
#line 119
    inverted = 1;
#line 120
    pin ++;
  }
  {
#line 123
  tmp = __ctype_b_loc();
  }
#line 123
  if (! ((int const   )*(*tmp + (int )*pin) & 2048)) {
#line 124
    return (-1);
  }
  {
#line 126
  tmp___0 = atoi((char const   *)pin);
#line 126
  bitnum = tmp___0 % 8;
#line 128
  bitnum = 1 << bitnum;
  }
#line 130
  if (inverted) {
#line 130
    *act = 0;
  } else {
#line 130
    *act = bitnum;
  }
#line 131
  if (inverted) {
#line 131
    *inact = bitnum;
  } else {
#line 131
    *inact = 0;
  }
#line 133
  return (0);
}
}
#line 137 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/wiggler.c"
static int set_mapping(char *bitmap , cable_t *cable ) 
{ 
  char delim ;
  int syntax ;
  char *tdo ;
  char *trst ;
  char *tdi ;
  char *tck ;
  char *tms ;
  char *srst ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 140
  delim = (char )',';
#line 141
  syntax = 0;
#line 145
  tdo = bitmap;
#line 145
  if (tdo) {
    {
#line 146
    trst = strchr((char const   *)tdo, (int )delim);
    }
#line 146
    if (trst) {
      {
#line 147
      trst ++;
#line 148
      tdi = strchr((char const   *)trst, (int )delim);
      }
#line 148
      if (tdi) {
        {
#line 149
        tdi ++;
#line 150
        tck = strchr((char const   *)tdi, (int )delim);
        }
#line 150
        if (tck) {
          {
#line 151
          tck ++;
#line 152
          tms = strchr((char const   *)tck, (int )delim);
          }
#line 152
          if (tms) {
            {
#line 153
            tms ++;
#line 154
            srst = strchr((char const   *)tms, (int )delim);
            }
#line 154
            if (srst) {
#line 155
              srst ++;
#line 156
              syntax = 1;
            }
          }
        }
      }
    }
  }
#line 159
  if (! syntax) {
#line 160
    return (-1);
  }
  {
#line 162
  tmp = map_pin(tdo, & ((wiggler_params_t *)cable->params)->tdo_act, & ((wiggler_params_t *)cable->params)->tdo_inact);
  }
#line 162
  if (tmp != 0) {
#line 162
    return (-1);
  }
  {
#line 163
  tmp___0 = map_pin(trst, & ((wiggler_params_t *)cable->params)->trst_act, & ((wiggler_params_t *)cable->params)->trst_inact);
  }
#line 163
  if (tmp___0 != 0) {
#line 163
    return (-1);
  }
  {
#line 164
  tmp___1 = map_pin(tdi, & ((wiggler_params_t *)cable->params)->tdi_act, & ((wiggler_params_t *)cable->params)->tdi_inact);
  }
#line 164
  if (tmp___1 != 0) {
#line 164
    return (-1);
  }
  {
#line 165
  tmp___2 = map_pin(tck, & ((wiggler_params_t *)cable->params)->tck_act, & ((wiggler_params_t *)cable->params)->tck_inact);
  }
#line 165
  if (tmp___2 != 0) {
#line 165
    return (-1);
  }
  {
#line 166
  tmp___3 = map_pin(tms, & ((wiggler_params_t *)cable->params)->tms_act, & ((wiggler_params_t *)cable->params)->tms_inact);
  }
#line 166
  if (tmp___3 != 0) {
#line 166
    return (-1);
  }
  {
#line 167
  tmp___4 = map_pin(srst, & ((wiggler_params_t *)cable->params)->srst_act, & ((wiggler_params_t *)cable->params)->srst_inact);
  }
#line 167
  if (tmp___4 != 0) {
#line 167
    return (-1);
  }
#line 169
  return (0);
}
}
#line 173 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/wiggler.c"
static int wiggler_connect(char **params , cable_t *cable ) 
{ 
  int result ;
  char *param_bitmap ;
  wiggler_params_t *wiggler_params ;
  int tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 177
  param_bitmap = (char *)((void *)0);
#line 180
  tmp = cmd_params(params);
  }
#line 180
  if (tmp == 4) {
#line 182
    param_bitmap = *(params + 3);
#line 184
    *(params + 3) = (char *)((void *)0);
  }
  {
#line 187
  result = generic_parport_connect(params, cable);
  }
#line 187
  if (result != 0) {
#line 188
    return (result);
  }
#line 190
  if (param_bitmap) {
#line 191
    *(params + 3) = param_bitmap;
  }
  {
#line 193
  tmp___0 = malloc((size_t )sizeof(*wiggler_params));
#line 193
  wiggler_params = (wiggler_params_t *)tmp___0;
  }
#line 194
  if (! wiggler_params) {
    {
#line 195
    tmp___1 = gettext("%s(%d) malloc failed!\n");
#line 195
    printf((char const   */* __restrict  */)tmp___1, "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/wiggler.c",
           195);
#line 201
    (*(((cable->link.port)->driver)->parport_free))(cable->link.port);
    }
#line 202
    return (4);
  }
  {
#line 206
  free(cable->params);
#line 207
  cable->params = (void *)wiggler_params;
  }
#line 209
  if (! param_bitmap) {
#line 210
    param_bitmap = (char *)std_wgl_map;
  }
  {
#line 212
  result = set_mapping(param_bitmap, cable);
  }
#line 212
  if (result != 0) {
    {
#line 213
    tmp___2 = gettext("Pin mapping failed\n");
#line 213
    printf((char const   */* __restrict  */)tmp___2);
#line 219
    (*(((cable->link.port)->driver)->parport_free))(cable->link.port);
#line 220
    free(cable->params);
    }
#line 221
    return (result);
  }
#line 226
  ((wiggler_params_t *)cable->params)->unused_bits = ~ (((((((((((wiggler_params_t *)cable->params)->srst_act | ((wiggler_params_t *)cable->params)->srst_inact) | ((wiggler_params_t *)cable->params)->tms_act) | ((wiggler_params_t *)cable->params)->tms_inact) | ((wiggler_params_t *)cable->params)->tck_act) | ((wiggler_params_t *)cable->params)->tck_inact) | ((wiggler_params_t *)cable->params)->tdi_act) | ((wiggler_params_t *)cable->params)->tdi_inact) | ((wiggler_params_t *)cable->params)->trst_act) | ((wiggler_params_t *)cable->params)->trst_inact) & 255;
#line 232
  return (0);
}
}
#line 235 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/wiggler.c"
static int wiggler_init(cable_t *cable ) 
{ 
  int data ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 240
  tmp = parport_open(cable->link.port);
  }
#line 240
  if (tmp) {
#line 241
    return (-1);
  }
  {
#line 243
  data = parport_get_data(cable->link.port);
  }
#line 243
  if (data < 0) {
    {
#line 244
    tmp___0 = parport_set_data(cable->link.port, (uint8_t )((((wiggler_params_t *)cable->params)->trst_act | ((wiggler_params_t *)cable->params)->trst_inact) | ((wiggler_params_t *)cable->params)->unused_bits));
    }
#line 244
    if (tmp___0) {
#line 245
      return (-1);
    }
#line 246
    ((wiggler_params_t *)cable->params)->trst_lvl = ((wiggler_params_t *)cable->params)->trst_act | ((wiggler_params_t *)cable->params)->trst_inact;
  } else {
#line 248
    ((wiggler_params_t *)cable->params)->trst_lvl = data & (((wiggler_params_t *)cable->params)->trst_act | ((wiggler_params_t *)cable->params)->trst_inact);
  }
#line 250
  if (((wiggler_params_t *)cable->params)->trst_lvl == ((wiggler_params_t *)cable->params)->trst_act) {
#line 250
    ((wiggler_params_t *)cable->params)->signals = 8;
  } else {
#line 250
    ((wiggler_params_t *)cable->params)->signals = 0;
  }
#line 252
  return (0);
}
}
#line 255 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/wiggler.c"
static void wiggler_clock(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 260
  if (tms) {
#line 260
    tms = 1;
  } else {
#line 260
    tms = 0;
  }
#line 261
  if (tdi) {
#line 261
    tdi = 1;
  } else {
#line 261
    tdi = 0;
  }
#line 263
  i = 0;
  {
#line 263
  while (1) {
    while_continue: /* CIL Label */ ;
#line 263
    if (! (i < n)) {
#line 263
      goto while_break;
    }
#line 264
    if (tms) {
#line 264
      tmp = ((wiggler_params_t *)cable->params)->tms_act;
    } else {
#line 264
      tmp = ((wiggler_params_t *)cable->params)->tms_inact;
    }
#line 264
    if (tdi) {
#line 264
      tmp___0 = ((wiggler_params_t *)cable->params)->tdi_act;
    } else {
#line 264
      tmp___0 = ((wiggler_params_t *)cable->params)->tdi_inact;
    }
    {
#line 264
    parport_set_data(cable->link.port, (uint8_t )((((((wiggler_params_t *)cable->params)->trst_lvl | ((wiggler_params_t *)cable->params)->tck_inact) | tmp) | tmp___0) | ((wiggler_params_t *)cable->params)->unused_bits));
#line 269
    cable_wait(cable);
    }
#line 270
    if (tms) {
#line 270
      tmp___1 = ((wiggler_params_t *)cable->params)->tms_act;
    } else {
#line 270
      tmp___1 = ((wiggler_params_t *)cable->params)->tms_inact;
    }
#line 270
    if (tdi) {
#line 270
      tmp___2 = ((wiggler_params_t *)cable->params)->tdi_act;
    } else {
#line 270
      tmp___2 = ((wiggler_params_t *)cable->params)->tdi_inact;
    }
    {
#line 270
    parport_set_data(cable->link.port, (uint8_t )((((((wiggler_params_t *)cable->params)->trst_lvl | ((wiggler_params_t *)cable->params)->tck_act) | tmp___1) | tmp___2) | ((wiggler_params_t *)cable->params)->unused_bits));
#line 275
    cable_wait(cable);
#line 263
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 278
  ((wiggler_params_t *)cable->params)->signals &= -6;
#line 279
  if (tms) {
#line 279
    ((wiggler_params_t *)cable->params)->signals |= 4;
  }
#line 280
  if (tdi) {
#line 280
    ((wiggler_params_t *)cable->params)->signals |= 1;
  }
#line 281
  return;
}
}
#line 283 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/wiggler.c"
static int wiggler_get_tdo(cable_t *cable ) 
{ 
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 286
  parport_set_data(cable->link.port, (uint8_t )((((wiggler_params_t *)cable->params)->trst_lvl | ((wiggler_params_t *)cable->params)->tck_inact) | ((wiggler_params_t *)cable->params)->unused_bits));
#line 289
  cable_wait(cable);
#line 291
  tmp___1 = parport_get_status(cable->link.port);
  }
#line 291
  if ((tmp___1 & (((wiggler_params_t *)cable->params)->tdo_act | ((wiggler_params_t *)cable->params)->tdo_inact)) ^ ((wiggler_params_t *)cable->params)->tdo_act) {
#line 291
    tmp___0 = 0;
  } else {
#line 291
    tmp___0 = 1;
  }
#line 291
  return (tmp___0);
}
}
#line 295 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/wiggler.c"
static int wiggler_set_signal(cable_t *cable , int mask , int val ) 
{ 
  int prev_sigs ;
  int sigs ;
  int data ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 298
  prev_sigs = ((wiggler_params_t *)cable->params)->signals;
#line 300
  mask &= 15;
#line 302
  if (mask != 0) {
#line 304
    sigs = (prev_sigs & ~ mask) | (val & mask);
#line 305
    if (sigs & 8) {
#line 305
      ((wiggler_params_t *)cable->params)->trst_lvl = ((wiggler_params_t *)cable->params)->trst_act;
    } else {
#line 305
      ((wiggler_params_t *)cable->params)->trst_lvl = ((wiggler_params_t *)cable->params)->trst_inact;
    }
#line 306
    data = ((wiggler_params_t *)cable->params)->unused_bits | ((wiggler_params_t *)cable->params)->trst_lvl;
#line 307
    if (sigs & 2) {
#line 307
      tmp = ((wiggler_params_t *)cable->params)->tck_act;
    } else {
#line 307
      tmp = ((wiggler_params_t *)cable->params)->tck_inact;
    }
#line 307
    data |= tmp;
#line 308
    if (sigs & 4) {
#line 308
      tmp___0 = ((wiggler_params_t *)cable->params)->tms_act;
    } else {
#line 308
      tmp___0 = ((wiggler_params_t *)cable->params)->tms_inact;
    }
#line 308
    data |= tmp___0;
#line 309
    if (sigs & 1) {
#line 309
      tmp___1 = ((wiggler_params_t *)cable->params)->tdi_act;
    } else {
#line 309
      tmp___1 = ((wiggler_params_t *)cable->params)->tdi_inact;
    }
    {
#line 309
    data |= tmp___1;
#line 310
    parport_set_data(cable->link.port, (uint8_t )data);
#line 311
    ((wiggler_params_t *)cable->params)->signals = sigs;
    }
  }
#line 314
  return (prev_sigs);
}
}
#line 317 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/wiggler.c"
static int wiggler_get_signal(cable_t *cable , pod_sigsel_t sig ) 
{ 
  int tmp ;

  {
#line 320
  if ((unsigned int )((wiggler_params_t *)cable->params)->signals & (unsigned int )sig) {
#line 320
    tmp = 1;
  } else {
#line 320
    tmp = 0;
  }
#line 320
  return (tmp);
}
}
#line 323 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/wiggler.c"
static void wiggler_help(char const   *cablename ) 
{ 
  char *tmp ;
  char *__cil_tmp3 ;

  {
  {
#line 326
  tmp = gettext("Usage: cable %s parallel PORTADDR [TDO,TRST,TDI,TCK,TMS,SRESET]\n   or: cable %s ppdev PPDEV [TDO,TRST,TDI,TCK,TMS,SRESET]\n\nPORTADDR   parallel port address (e.g. 0x378)\nPPDEV      ppdev device (e.g. /dev/parport0)\nTDO, ...   parallel port bit number, prepend \'#\' for inversion\n           default is \'%s\'\n\n");
#line 326
  printf((char const   */* __restrict  */)tmp, cablename, cablename, std_wgl_map);
  }
#line 355
  return;
}
}
#line 357 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/wiggler.c"
cable_driver_t wiggler_cable_driver  = 
#line 357
     {"WIGGLER", "Macraigor Wiggler JTAG Cable", & wiggler_connect, & generic_disconnect,
    & generic_parport_free, & wiggler_init, & generic_parport_done, & generic_set_frequency,
    & wiggler_clock, & wiggler_get_tdo, & generic_transfer, & wiggler_set_signal,
    & wiggler_get_signal, & generic_flush_one_by_one, & wiggler_help};
#line 375 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/wiggler.c"
cable_driver_t igloo_cable_driver  = 
#line 375
     {"IGLOO", "Excelpoint IGLOO JTAG Cable", & wiggler_connect, & generic_disconnect,
    & generic_parport_free, & wiggler_init, & generic_parport_done, & generic_set_frequency,
    & wiggler_clock, & wiggler_get_tdo, & generic_transfer, & wiggler_set_signal,
    & wiggler_get_signal, & generic_flush_one_by_one, & wiggler_help};
#line 63 "../../include/usbconn.h"
int usbconn_open(usbconn_t *conn ) ;
#line 64
int usbconn_close(usbconn_t *conn ) ;
#line 65
int usbconn_read(usbconn_t *conn , uint8_t *buf , int len ) ;
#line 66
int usbconn_write(usbconn_t *conn , uint8_t *buf , int len , int recv ) ;
#line 67
usbconn_driver_t *usbconn_drivers[1] ;
#line 43 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/usbconn.c"
usbconn_driver_t *usbconn_drivers[1]  = {      (usbconn_driver_t *)((void *)0)};
#line 58 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/usbconn.c"
int usbconn_open(usbconn_t *conn ) 
{ 
  int tmp ;

  {
  {
#line 61
  tmp = (*((conn->driver)->open))(conn);
  }
#line 61
  return (tmp);
}
}
#line 64 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/usbconn.c"
int usbconn_close(usbconn_t *conn ) 
{ 
  int tmp ;

  {
  {
#line 67
  tmp = (*((conn->driver)->close))(conn);
  }
#line 67
  return (tmp);
}
}
#line 70 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/usbconn.c"
int usbconn_read(usbconn_t *conn , uint8_t *buf , int len ) 
{ 
  int tmp ;

  {
#line 73
  if ((conn->driver)->read) {
    {
#line 74
    tmp = (*((conn->driver)->read))(conn, buf, len);
    }
#line 74
    return (tmp);
  } else {
#line 76
    return (0);
  }
}
}
#line 79 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/usbconn.c"
int usbconn_write(usbconn_t *conn , uint8_t *buf , int len , int recv ) 
{ 
  int tmp ;

  {
#line 82
  if ((conn->driver)->write) {
    {
#line 83
    tmp = (*((conn->driver)->write))(conn, buf, len, recv);
    }
#line 83
    return (tmp);
  } else {
#line 85
    return (0);
  }
}
}
#line 69 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/triton.c"
static int triton_init(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 72
  tmp = parport_open(cable->link.port);
  }
#line 72
  if (tmp) {
#line 73
    return (-1);
  }
  {
#line 75
  ((generic_params_t *)cable->params)->signals = 24;
#line 76
  parport_set_data(cable->link.port, (uint8_t )((1 << 3) | (1 << 4)));
  }
#line 78
  return (0);
}
}
#line 81 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/triton.c"
static void triton_clock(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;
  int trst ;
  int tmp ;
  int sreset ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 85
  if (((generic_params_t *)cable->params)->signals & 8) {
#line 85
    tmp = 1;
  } else {
#line 85
    tmp = 0;
  }
#line 85
  trst = tmp;
#line 86
  if (((generic_params_t *)cable->params)->signals & 16) {
#line 86
    tmp___0 = 1;
  } else {
#line 86
    tmp___0 = 0;
  }
#line 86
  sreset = tmp___0;
#line 88
  if (tms) {
#line 88
    tms = 1;
  } else {
#line 88
    tms = 0;
  }
#line 89
  if (tdi) {
#line 89
    tdi = 1;
  } else {
#line 89
    tdi = 0;
  }
#line 91
  i = 0;
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
#line 91
    if (! (i < n)) {
#line 91
      goto while_break;
    }
    {
#line 92
    parport_set_data(cable->link.port, (uint8_t )((((trst << 3) | (sreset << 4)) | (tms << 2)) | (tdi << 1)));
#line 93
    cable_wait(cable);
#line 94
    parport_set_data(cable->link.port, (uint8_t )(((((trst << 3) | (sreset << 4)) | 1) | (tms << 2)) | (tdi << 1)));
#line 95
    cable_wait(cable);
#line 91
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  ((generic_params_t *)cable->params)->signals &= 24;
#line 99
  ((generic_params_t *)cable->params)->signals |= 2;
#line 100
  if (tms) {
#line 100
    tmp___1 = 4;
  } else {
#line 100
    tmp___1 = 0;
  }
#line 100
  ((generic_params_t *)cable->params)->signals |= tmp___1;
#line 101
  if (tdi) {
#line 101
    tmp___2 = 1;
  } else {
#line 101
    tmp___2 = 0;
  }
#line 101
  ((generic_params_t *)cable->params)->signals |= tmp___2;
#line 102
  return;
}
}
#line 104 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/triton.c"
static int triton_get_tdo(cable_t *cable ) 
{ 
  int trst ;
  int tmp ;
  int sreset ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 107
  if (((generic_params_t *)cable->params)->signals & 8) {
#line 107
    tmp = 1;
  } else {
#line 107
    tmp = 0;
  }
#line 107
  trst = tmp;
#line 108
  if (((generic_params_t *)cable->params)->signals & 16) {
#line 108
    tmp___0 = 1;
  } else {
#line 108
    tmp___0 = 0;
  }
  {
#line 108
  sreset = tmp___0;
#line 110
  parport_set_data(cable->link.port, (uint8_t )((trst << 3) | (sreset << 4)));
#line 111
  ((generic_params_t *)cable->params)->signals &= -8;
#line 113
  cable_wait(cable);
#line 115
  tmp___1 = parport_get_status(cable->link.port);
  }
#line 115
  return ((tmp___1 >> 7) & 1);
}
}
#line 118 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/triton.c"
static int triton_set_signal(cable_t *cable , int mask , int val ) 
{ 
  int prev_sigs ;
  int data ;
  int sigs ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 121
  prev_sigs = ((generic_params_t *)cable->params)->signals;
#line 123
  mask &= 31;
#line 125
  if (mask != 0) {
#line 127
    data = 0;
#line 128
    sigs = (((generic_params_t *)cable->params)->signals & ~ mask) | (val & mask);
#line 129
    if (sigs & 1) {
#line 129
      tmp = 1 << 1;
    } else {
#line 129
      tmp = 0;
    }
#line 129
    data |= tmp;
#line 130
    if (sigs & 2) {
#line 130
      tmp___0 = 1;
    } else {
#line 130
      tmp___0 = 0;
    }
#line 130
    data |= tmp___0;
#line 131
    if (sigs & 4) {
#line 131
      tmp___1 = 1 << 2;
    } else {
#line 131
      tmp___1 = 0;
    }
#line 131
    data |= tmp___1;
#line 132
    if (sigs & 8) {
#line 132
      tmp___2 = 1 << 3;
    } else {
#line 132
      tmp___2 = 0;
    }
#line 132
    data |= tmp___2;
#line 133
    if (sigs & 16) {
#line 133
      tmp___3 = 1 << 4;
    } else {
#line 133
      tmp___3 = 0;
    }
    {
#line 133
    data |= tmp___3;
#line 134
    parport_set_data(cable->link.port, (uint8_t )data);
#line 135
    ((generic_params_t *)cable->params)->signals = sigs;
    }
  }
#line 138
  return (prev_sigs);
}
}
#line 141 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/triton.c"
cable_driver_t triton_cable_driver  = 
#line 141
     {"TRITON", "Ka-Ro TRITON Starterkit II (PXA255/250) JTAG Cable", & generic_parport_connect,
    & generic_disconnect, & generic_parport_free, & triton_init, & generic_parport_done,
    & generic_set_frequency, & triton_clock, & triton_get_tdo, & generic_transfer,
    & triton_set_signal, & generic_get_signal, & generic_flush_one_by_one, & generic_parport_help};
#line 78 "../../include/part.h"
void parts_set_instruction(parts_t *ps , char const   *iname ) ;
#line 131 "../../include/cable.h"
int cable_get_tdo_late(cable_t *cable ) ;
#line 132
int cable_defer_get_tdo(cable_t *cable ) ;
#line 139
int cable_transfer_late(cable_t *cable , char *out ) ;
#line 140
int cable_defer_transfer(cable_t *cable , int len , char *in , char *out ) ;
#line 54 "../../include/chain.h"
void chain_defer_clock(chain_t *chain , int tms , int tdi , int n ) ;
#line 31 "../../include/tap.h"
void tap_reset(chain_t *chain ) ;
#line 34
void tap_capture_ir(chain_t *chain ) ;
#line 35
void tap_defer_shift_register(chain_t *chain , tap_register const   *in , tap_register *out ,
                              int tap_exit ) ;
#line 36
void tap_shift_register_output(chain_t *chain , tap_register const   *in , tap_register *out ,
                               int tap_exit ) ;
#line 34 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/tap.c"
void tap_reset(chain_t *chain ) 
{ 


  {
  {
#line 37
  tap_state_reset(chain);
#line 39
  chain_clock(chain, 1, 0, 5);
#line 40
  chain_clock(chain, 0, 0, 1);
  }
#line 41
  return;
}
}
#line 43 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/tap.c"
void tap_reset_bypass(chain_t *chain ) 
{ 
  tap_register *ir ;
  tap_register *tmp ;
  tap_register *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 46
  tap_reset(chain);
  }
#line 50
  if (chain->total_instr_len > 0) {
    {
#line 51
    tmp = register_alloc(chain->total_instr_len);
#line 51
    tmp___0 = register_fill(tmp, 1);
#line 51
    ir = tmp___0;
    }
#line 52
    if (! ir) {
      {
#line 53
      tmp___1 = gettext("out of memory\n");
#line 53
      printf((char const   */* __restrict  */)tmp___1);
      }
#line 54
      return;
    }
    {
#line 57
    tap_capture_ir(chain);
#line 58
    tap_shift_register(chain, (tap_register const   *)ir, (tap_register *)((void *)0),
                       1);
#line 59
    register_free(ir);
#line 61
    parts_set_instruction(chain->parts, "BYPASS");
    }
  }
#line 63
  return;
}
}
#line 65 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/tap.c"
void tap_defer_shift_register(chain_t *chain , tap_register const   *in , tap_register *out ,
                              int tap_exit ) 
{ 
  int i ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 70
  tmp___1 = tap_state(chain);
  }
#line 70
  if (! (tmp___1 & (1 << 2))) {
    {
#line 71
    tmp = tap_state(chain);
#line 71
    tmp___0 = gettext("%s: Invalid state: %2X\n");
#line 71
    printf((char const   */* __restrict  */)tmp___0, "tap_shift_register", tmp);
    }
  }
  {
#line 74
  tmp___2 = tap_state(chain);
  }
#line 74
  if (tmp___2 & (1 << 4)) {
    {
#line 75
    chain_defer_clock(chain, 0, 0, 1);
    }
  }
#line 77
  i = (int )in->len;
#line 78
  if (tap_exit) {
#line 78
    i --;
  }
#line 79
  if (out) {
#line 79
    if (out->len < i) {
#line 79
      i = out->len;
    }
  }
#line 81
  if (out) {
    {
#line 82
    cable_defer_transfer(chain->cable, i, (char *)in->data, out->data);
    }
  } else {
    {
#line 84
    cable_defer_transfer(chain->cable, i, (char *)in->data, (char *)((void *)0));
    }
  }
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
#line 86
    if (! (i < (int )in->len)) {
#line 86
      goto while_break;
    }
#line 87
    if ((unsigned long )out != (unsigned long )((void *)0)) {
#line 87
      if (i < out->len) {
        {
#line 88
        tmp___3 = cable_defer_get_tdo(chain->cable);
#line 88
        *(out->data + i) = (char )tmp___3;
        }
      }
    }
#line 89
    if (tap_exit != 0) {
#line 89
      if (i + 1 == (int )in->len) {
#line 89
        tmp___4 = 1;
      } else {
#line 89
        tmp___4 = 0;
      }
    } else {
#line 89
      tmp___4 = 0;
    }
    {
#line 89
    chain_defer_clock(chain, tmp___4, (int )*(in->data + i), 1);
#line 86
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 93
  if (tap_exit == 1) {
    {
#line 94
    chain_defer_clock(chain, 1, 0, 1);
#line 95
    chain_defer_clock(chain, 0, 0, 1);
    }
  } else
#line 96
  if (tap_exit == 3) {
    {
#line 97
    chain_defer_clock(chain, 1, 0, 1);
    }
  }
#line 98
  return;
}
}
#line 100 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/tap.c"
void tap_shift_register_output(chain_t *chain , tap_register const   *in , tap_register *out ,
                               int tap_exit ) 
{ 
  int j ;
  int tmp ;

  {
#line 103
  if ((unsigned long )out != (unsigned long )((void *)0)) {
#line 107
    j = (int )in->len;
#line 108
    if (tap_exit) {
#line 108
      j --;
    }
#line 109
    if (out) {
#line 109
      if (out->len < j) {
#line 109
        j = out->len;
      }
    }
    {
#line 114
    cable_transfer_late(chain->cable, out->data);
    }
    {
#line 115
    while (1) {
      while_continue: /* CIL Label */ ;
#line 115
      if (j < (int )in->len) {
#line 115
        if (! (j < out->len)) {
#line 115
          goto while_break;
        }
      } else {
#line 115
        goto while_break;
      }
      {
#line 116
      tmp = cable_get_tdo_late(chain->cable);
#line 116
      *(out->data + j) = (char )tmp;
#line 115
      j ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 118
  return;
}
}
#line 120 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/tap.c"
void tap_shift_register(chain_t *chain , tap_register const   *in , tap_register *out ,
                        int tap_exit ) 
{ 


  {
  {
#line 123
  tap_defer_shift_register(chain, in, out, tap_exit);
#line 124
  tap_shift_register_output(chain, in, out, tap_exit);
  }
#line 125
  return;
}
}
#line 127 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/tap.c"
void tap_capture_dr(chain_t *chain ) 
{ 
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 130
  tmp___1 = tap_state(chain);
  }
#line 130
  if ((tmp___1 & ((1 << 7) | (1 << 3))) != 1 << 3) {
    {
#line 131
    tmp = tap_state(chain);
#line 131
    tmp___0 = gettext("%s: Invalid state: %2X\n");
#line 131
    printf((char const   */* __restrict  */)tmp___0, "tap_capture_dr", tmp);
    }
  }
  {
#line 134
  chain_defer_clock(chain, 1, 0, 1);
#line 135
  chain_defer_clock(chain, 0, 0, 1);
  }
#line 136
  return;
}
}
#line 138 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/tap.c"
void tap_capture_ir(chain_t *chain ) 
{ 
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 141
  tmp___1 = tap_state(chain);
  }
#line 141
  if ((tmp___1 & ((1 << 7) | (1 << 3))) != 1 << 3) {
    {
#line 142
    tmp = tap_state(chain);
#line 142
    tmp___0 = gettext("%s: Invalid state: %2X\n");
#line 142
    printf((char const   */* __restrict  */)tmp___0, "tap_capture_ir", tmp);
    }
  }
  {
#line 145
  chain_defer_clock(chain, 1, 0, 2);
#line 146
  chain_defer_clock(chain, 0, 0, 1);
  }
#line 147
  return;
}
}
#line 60 "../../include/state.h"
int tap_state_init(chain_t *chain ) ;
#line 61
int tap_state_done(chain_t *chain ) ;
#line 63
int tap_state_set_trst(chain_t *chain , int old_trst , int new_trst ) ;
#line 64
int tap_state_clock(chain_t *chain , int tms ) ;
#line 29 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/state.c"
int tap_state(chain_t *chain ) 
{ 


  {
#line 32
  return (chain->state);
}
}
#line 35 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/state.c"
int tap_state_init(chain_t *chain ) 
{ 
  int tmp ;

  {
#line 38
  tmp = 1 << 7;
#line 38
  chain->state = tmp;
#line 38
  return (tmp);
}
}
#line 41 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/state.c"
int tap_state_done(chain_t *chain ) 
{ 
  int tmp ;

  {
#line 44
  tmp = 1 << 7;
#line 44
  chain->state = tmp;
#line 44
  return (tmp);
}
}
#line 47 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/state.c"
int tap_state_reset(chain_t *chain ) 
{ 
  int tmp ;

  {
#line 50
  tmp = (1 << 7) | (1 << 3);
#line 50
  chain->state = tmp;
#line 50
  return (tmp);
}
}
#line 53 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/state.c"
int tap_state_set_trst(chain_t *chain , int old_trst , int new_trst ) 
{ 


  {
#line 56
  if (old_trst) {
#line 56
    old_trst = 1;
  } else {
#line 56
    old_trst = 0;
  }
#line 57
  if (new_trst) {
#line 57
    new_trst = 1;
  } else {
#line 57
    new_trst = 0;
  }
#line 59
  if (old_trst != new_trst) {
#line 60
    if (new_trst) {
#line 61
      chain->state = (1 << 7) | (1 << 3);
    } else {
#line 63
      chain->state = 1 << 7;
    }
  }
#line 66
  return (chain->state);
}
}
#line 69 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/state.c"
int tap_state_clock(chain_t *chain , int tms ) 
{ 


  {
#line 72
  if (tms) {
    {
#line 74
    if (chain->state == ((1 << 7) | (1 << 3))) {
#line 74
      goto case_exp;
    }
#line 78
    if (chain->state == ((1 << 1) | (1 << 3))) {
#line 78
      goto case_exp___0;
    }
#line 78
    if (chain->state == (1 | (1 << 3))) {
#line 78
      goto case_exp___0;
    }
#line 78
    if (chain->state == 1 << 3) {
#line 78
      goto case_exp___0;
    }
#line 81
    if (chain->state == 1) {
#line 81
      goto case_1;
    }
#line 85
    if (chain->state == (1 | (1 << 2))) {
#line 85
      goto case_exp___3;
    }
#line 85
    if (chain->state == ((1 | (1 << 2)) | (1 << 4))) {
#line 85
      goto case_exp___3;
    }
#line 89
    if (chain->state == ((1 | (1 << 2)) | (1 << 5))) {
#line 89
      goto case_exp___5;
    }
#line 89
    if (chain->state == ((1 | (1 << 5)) | (1 << 6))) {
#line 89
      goto case_exp___5;
    }
#line 92
    if (chain->state == (1 | (1 << 6))) {
#line 92
      goto case_exp___7;
    }
#line 95
    if (chain->state == 1 << 1) {
#line 95
      goto case_exp___8;
    }
#line 99
    if (chain->state == ((1 << 1) | (1 << 2))) {
#line 99
      goto case_exp___9;
    }
#line 99
    if (chain->state == (((1 << 1) | (1 << 2)) | (1 << 4))) {
#line 99
      goto case_exp___9;
    }
#line 103
    if (chain->state == (((1 << 1) | (1 << 2)) | (1 << 5))) {
#line 103
      goto case_exp___11;
    }
#line 103
    if (chain->state == (((1 << 1) | (1 << 5)) | (1 << 6))) {
#line 103
      goto case_exp___11;
    }
#line 106
    if (chain->state == ((1 << 1) | (1 << 6))) {
#line 106
      goto case_exp___13;
    }
#line 109
    goto switch_default;
    case_exp: /* CIL Label */ 
#line 75
    goto switch_break;
    case_exp___0: /* CIL Label */ 
    case_exp___1: /* CIL Label */ 
    case_exp___2: /* CIL Label */ 
#line 79
    chain->state = 1;
#line 80
    goto switch_break;
    case_1: /* CIL Label */ 
#line 82
    chain->state = 1 << 1;
#line 83
    goto switch_break;
    case_exp___3: /* CIL Label */ 
    case_exp___4: /* CIL Label */ 
#line 86
    chain->state = (1 | (1 << 5)) | (1 << 6);
#line 87
    goto switch_break;
    case_exp___5: /* CIL Label */ 
    case_exp___6: /* CIL Label */ 
#line 90
    chain->state = 1 | (1 << 3);
#line 91
    goto switch_break;
    case_exp___7: /* CIL Label */ 
#line 93
    chain->state = (1 | (1 << 2)) | (1 << 5);
#line 94
    goto switch_break;
    case_exp___8: /* CIL Label */ 
#line 96
    chain->state = (1 << 7) | (1 << 3);
#line 97
    goto switch_break;
    case_exp___9: /* CIL Label */ 
    case_exp___10: /* CIL Label */ 
#line 100
    chain->state = ((1 << 1) | (1 << 5)) | (1 << 6);
#line 101
    goto switch_break;
    case_exp___11: /* CIL Label */ 
    case_exp___12: /* CIL Label */ 
#line 104
    chain->state = (1 << 1) | (1 << 3);
#line 105
    goto switch_break;
    case_exp___13: /* CIL Label */ 
#line 107
    chain->state = ((1 << 1) | (1 << 2)) | (1 << 5);
#line 108
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 110
    chain->state = 1 << 7;
#line 111
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 118
    if (chain->state == ((1 << 1) | (1 << 3))) {
#line 118
      goto case_exp___14;
    }
#line 118
    if (chain->state == (1 | (1 << 3))) {
#line 118
      goto case_exp___14;
    }
#line 118
    if (chain->state == 1 << 3) {
#line 118
      goto case_exp___14;
    }
#line 118
    if (chain->state == ((1 << 7) | (1 << 3))) {
#line 118
      goto case_exp___14;
    }
#line 121
    if (chain->state == 1) {
#line 121
      goto case_1___0;
    }
#line 126
    if (chain->state == ((1 | (1 << 2)) | (1 << 5))) {
#line 126
      goto case_exp___18;
    }
#line 126
    if (chain->state == (1 | (1 << 2))) {
#line 126
      goto case_exp___18;
    }
#line 126
    if (chain->state == ((1 | (1 << 2)) | (1 << 4))) {
#line 126
      goto case_exp___18;
    }
#line 130
    if (chain->state == (1 | (1 << 6))) {
#line 130
      goto case_exp___21;
    }
#line 130
    if (chain->state == ((1 | (1 << 5)) | (1 << 6))) {
#line 130
      goto case_exp___21;
    }
#line 133
    if (chain->state == 1 << 1) {
#line 133
      goto case_exp___23;
    }
#line 138
    if (chain->state == (((1 << 1) | (1 << 2)) | (1 << 5))) {
#line 138
      goto case_exp___24;
    }
#line 138
    if (chain->state == ((1 << 1) | (1 << 2))) {
#line 138
      goto case_exp___24;
    }
#line 138
    if (chain->state == (((1 << 1) | (1 << 2)) | (1 << 4))) {
#line 138
      goto case_exp___24;
    }
#line 142
    if (chain->state == ((1 << 1) | (1 << 6))) {
#line 142
      goto case_exp___27;
    }
#line 142
    if (chain->state == (((1 << 1) | (1 << 5)) | (1 << 6))) {
#line 142
      goto case_exp___27;
    }
#line 145
    goto switch_default___0;
    case_exp___14: /* CIL Label */ 
    case_exp___15: /* CIL Label */ 
    case_exp___16: /* CIL Label */ 
    case_exp___17: /* CIL Label */ 
#line 119
    chain->state = 1 << 3;
#line 120
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
#line 122
    chain->state = (1 | (1 << 2)) | (1 << 4);
#line 123
    goto switch_break___0;
    case_exp___18: /* CIL Label */ 
    case_exp___19: /* CIL Label */ 
    case_exp___20: /* CIL Label */ 
#line 127
    chain->state = 1 | (1 << 2);
#line 128
    goto switch_break___0;
    case_exp___21: /* CIL Label */ 
    case_exp___22: /* CIL Label */ 
#line 131
    chain->state = 1 | (1 << 6);
#line 132
    goto switch_break___0;
    case_exp___23: /* CIL Label */ 
#line 134
    chain->state = ((1 << 1) | (1 << 2)) | (1 << 4);
#line 135
    goto switch_break___0;
    case_exp___24: /* CIL Label */ 
    case_exp___25: /* CIL Label */ 
    case_exp___26: /* CIL Label */ 
#line 139
    chain->state = (1 << 1) | (1 << 2);
#line 140
    goto switch_break___0;
    case_exp___27: /* CIL Label */ 
    case_exp___28: /* CIL Label */ 
#line 143
    chain->state = (1 << 1) | (1 << 6);
#line 144
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 146
    chain->state = 1 << 7;
#line 147
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 151
  return (chain->state);
}
}
#line 36 "../../include/register.h"
tap_register *register_duplicate(tap_register const   *tr ) ;
#line 40
int register_all_bits_same_value(tap_register const   *tr ) ;
#line 42
int register_compare(tap_register const   *tr , tap_register const   *tr2 ) ;
#line 43
int register_match(tap_register const   *tr , char const   *expr ) ;
#line 44
tap_register *register_inc(tap_register *tr ) ;
#line 45
tap_register *register_dec(tap_register *tr ) ;
#line 46
tap_register *register_shift_right(tap_register *tr , int shift ) ;
#line 47
tap_register *register_shift_left(tap_register *tr , int shift ) ;
#line 30 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/register.c"
tap_register *register_alloc(int len ) 
{ 
  tap_register *tr ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 35
  if (len < 1) {
#line 36
    return ((tap_register *)((void *)0));
  }
  {
#line 38
  tmp = malloc((size_t )sizeof(tap_register ));
#line 38
  tr = (tap_register *)tmp;
  }
#line 39
  if (! tr) {
#line 40
    return ((tap_register *)((void *)0));
  }
  {
#line 42
  tmp___0 = malloc((size_t )len);
#line 42
  tr->data = (char *)tmp___0;
  }
#line 43
  if (! tr->data) {
    {
#line 44
    free((void *)tr);
    }
#line 45
    return ((tap_register *)((void *)0));
  }
  {
#line 48
  memset((void *)tr->data, 0, (size_t )len);
#line 50
  tmp___1 = malloc((size_t )(len + 1));
#line 50
  tr->string = (char *)tmp___1;
  }
#line 51
  if (! tr->string) {
    {
#line 52
    free((void *)tr->data);
#line 53
    free((void *)tr);
    }
#line 54
    return ((tap_register *)((void *)0));
  }
#line 57
  tr->len = len;
#line 58
  *(tr->string + len) = (char )'\000';
#line 60
  return (tr);
}
}
#line 63 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/register.c"
tap_register *register_duplicate(tap_register const   *tr ) 
{ 
  char const   *tmp ;
  tap_register *tmp___0 ;
  tap_register *tmp___1 ;

  {
#line 66
  if (! tr) {
#line 67
    return ((tap_register *)((void *)0));
  }
  {
#line 69
  tmp = register_get_string(tr);
#line 69
  tmp___0 = register_alloc((int )tr->len);
#line 69
  tmp___1 = register_init(tmp___0, tmp);
  }
#line 69
  return (tmp___1);
}
}
#line 72 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/register.c"
void register_free(tap_register *tr ) 
{ 


  {
#line 75
  if (tr) {
    {
#line 76
    free((void *)tr->data);
#line 77
    free((void *)tr->string);
    }
  }
  {
#line 79
  free((void *)tr);
  }
#line 80
  return;
}
}
#line 82 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/register.c"
tap_register *register_fill(tap_register *tr , int val ) 
{ 


  {
#line 85
  if (tr) {
    {
#line 86
    memset((void *)tr->data, val & 1, (size_t )tr->len);
    }
  }
#line 88
  return (tr);
}
}
#line 91 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/register.c"
char const   *register_get_string(tap_register const   *tr ) 
{ 
  int i ;

  {
#line 96
  if (! tr) {
#line 97
    return ((char const   *)((void *)0));
  }
#line 99
  i = 0;
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! (i < (int )tr->len)) {
#line 99
      goto while_break;
    }
#line 100
    if ((int )*(tr->data + i) & 1) {
#line 100
      *(tr->string + ((tr->len - 1) - (int const   )i)) = (char )'1';
    } else {
#line 100
      *(tr->string + ((tr->len - 1) - (int const   )i)) = (char )'0';
    }
#line 99
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  return ((char const   *)tr->string);
}
}
#line 105 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/register.c"
int register_all_bits_same_value(tap_register const   *tr ) 
{ 
  int i ;
  int value ;

  {
#line 109
  if (! tr) {
#line 109
    return (-1);
  }
#line 110
  if (tr->len < 0) {
#line 110
    return (-1);
  }
#line 115
  value = (int )*(tr->data + 0) & 1;
#line 117
  i = 1;
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! (i < (int )tr->len)) {
#line 117
      goto while_break;
    }
#line 119
    if (((int )*(tr->data + i) & 1) != value) {
#line 119
      return (-1);
    }
#line 117
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 121
  return (value);
}
}
#line 124 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/register.c"
tap_register *register_init(tap_register *tr , char const   *value ) 
{ 
  int i ;
  char const   *p ;
  char *tmp ;

  {
#line 131
  if (! value) {
#line 132
    return (tr);
  } else
#line 131
  if (! tr) {
#line 132
    return (tr);
  }
  {
#line 134
  tmp = strchr(value, '\000');
#line 134
  p = (char const   *)tmp;
#line 136
  i = 0;
  }
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    if (! (i < tr->len)) {
#line 136
      goto while_break;
    }
#line 137
    if ((unsigned long )p == (unsigned long )value) {
#line 138
      *(tr->data + i) = (char)0;
    } else {
#line 140
      p --;
#line 141
      if ((int const   )*p == 48) {
#line 141
        *(tr->data + i) = (char)0;
      } else {
#line 141
        *(tr->data + i) = (char)1;
      }
    }
#line 136
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 145
  return (tr);
}
}
#line 148 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/register.c"
int register_compare(tap_register const   *tr , tap_register const   *tr2 ) 
{ 
  int i ;

  {
#line 153
  if (! tr) {
#line 153
    if (! tr2) {
#line 154
      return (0);
    }
  }
#line 156
  if (! tr) {
#line 157
    return (1);
  } else
#line 156
  if (! tr2) {
#line 157
    return (1);
  }
#line 159
  if (tr->len != tr2->len) {
#line 160
    return (1);
  }
#line 162
  i = 0;
  {
#line 162
  while (1) {
    while_continue: /* CIL Label */ ;
#line 162
    if (! (i < (int )tr->len)) {
#line 162
      goto while_break;
    }
#line 163
    if ((int )*(tr->data + i) != (int )*(tr2->data + i)) {
#line 164
      return (1);
    }
#line 162
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 166
  return (0);
}
}
#line 169 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/register.c"
int register_match(tap_register const   *tr , char const   *expr ) 
{ 
  int i ;
  char const   *s ;
  size_t tmp ;

  {
#line 175
  if (! tr) {
#line 176
    return (0);
  } else
#line 175
  if (! expr) {
#line 176
    return (0);
  } else {
    {
#line 175
    tmp = strlen(expr);
    }
#line 175
    if ((size_t )tr->len != tmp) {
#line 176
      return (0);
    }
  }
  {
#line 178
  s = register_get_string(tr);
#line 180
  i = 0;
  }
  {
#line 180
  while (1) {
    while_continue: /* CIL Label */ ;
#line 180
    if (! (i < (int )tr->len)) {
#line 180
      goto while_break;
    }
#line 181
    if ((int const   )*(expr + i) != 63) {
#line 181
      if ((int const   )*(expr + i) != (int const   )*(s + i)) {
#line 182
        return (0);
      }
    }
#line 180
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 184
  return (1);
}
}
#line 187 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/register.c"
tap_register *register_inc(tap_register *tr ) 
{ 
  int i ;

  {
#line 192
  if (! tr) {
#line 193
    return ((tap_register *)((void *)0));
  }
#line 195
  i = 0;
  {
#line 195
  while (1) {
    while_continue: /* CIL Label */ ;
#line 195
    if (! (i < tr->len)) {
#line 195
      goto while_break;
    }
#line 196
    *(tr->data + i) = (char )((int )*(tr->data + i) ^ 1);
#line 198
    if ((int )*(tr->data + i) == 1) {
#line 199
      goto while_break;
    }
#line 195
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 202
  return (tr);
}
}
#line 205 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/register.c"
tap_register *register_dec(tap_register *tr ) 
{ 
  int i ;

  {
#line 210
  if (! tr) {
#line 211
    return ((tap_register *)((void *)0));
  }
#line 213
  i = 0;
  {
#line 213
  while (1) {
    while_continue: /* CIL Label */ ;
#line 213
    if (! (i < tr->len)) {
#line 213
      goto while_break;
    }
#line 214
    *(tr->data + i) = (char )((int )*(tr->data + i) ^ 1);
#line 216
    if ((int )*(tr->data + i) == 0) {
#line 217
      goto while_break;
    }
#line 213
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 220
  return (tr);
}
}
#line 223 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/register.c"
tap_register *register_shift_right(tap_register *tr , int shift ) 
{ 
  int i ;

  {
#line 228
  if (! tr) {
#line 229
    return ((tap_register *)((void *)0));
  }
#line 231
  if (shift < 1) {
#line 232
    return (tr);
  }
#line 234
  i = 0;
  {
#line 234
  while (1) {
    while_continue: /* CIL Label */ ;
#line 234
    if (! (i < tr->len)) {
#line 234
      goto while_break;
    }
#line 235
    if (i + shift < tr->len) {
#line 236
      *(tr->data + i) = *(tr->data + (i + shift));
    } else {
#line 238
      *(tr->data + i) = (char)0;
    }
#line 234
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 241
  return (tr);
}
}
#line 244 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/register.c"
tap_register *register_shift_left(tap_register *tr , int shift ) 
{ 
  int i ;

  {
#line 249
  if (! tr) {
#line 250
    return ((tap_register *)((void *)0));
  }
#line 252
  if (shift < 1) {
#line 253
    return (tr);
  }
#line 255
  i = tr->len - 1;
  {
#line 255
  while (1) {
    while_continue: /* CIL Label */ ;
#line 255
    if (! (i >= 0)) {
#line 255
      goto while_break;
    }
#line 256
    if (i - shift >= 0) {
#line 257
      *(tr->data + i) = *(tr->data + (i - shift));
    } else {
#line 259
      *(tr->data + i) = (char)0;
    }
#line 255
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 262
  return (tr);
}
}
#line 73 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 67 "/usr/include/stropts.h"
extern  __attribute__((__nothrow__)) int ioctl(int __fd , unsigned long __request 
                                               , ...) ;
#line 350 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 411 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 45 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/parport/ppdev.c"
parport_driver_t ppdev_parport_driver ;
#line 54 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/parport/ppdev.c"
static port_node_t *ports  =    (port_node_t *)((void *)0);
#line 61 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/parport/ppdev.c"
static parport_t *ppdev_parport_alloc(char const   *port ) 
{ 
  ppdev_params_t *params ;
  void *tmp ;
  char *portname ;
  char *tmp___0 ;
  parport_t *parport ;
  void *tmp___1 ;
  port_node_t *node ;
  void *tmp___2 ;

  {
  {
#line 64
  tmp = malloc((size_t )sizeof(*params));
#line 64
  params = (ppdev_params_t *)tmp;
#line 65
  tmp___0 = strdup(port);
#line 65
  portname = tmp___0;
#line 66
  tmp___1 = malloc((size_t )sizeof(*parport));
#line 66
  parport = (parport_t *)tmp___1;
#line 67
  tmp___2 = malloc((size_t )sizeof(*node));
#line 67
  node = (port_node_t *)tmp___2;
  }
#line 69
  if (! node) {
    {
#line 70
    free((void *)node);
#line 71
    free((void *)parport);
#line 72
    free((void *)params);
#line 73
    free((void *)portname);
    }
#line 74
    return ((parport_t *)((void *)0));
  } else
#line 69
  if (! parport) {
    {
#line 70
    free((void *)node);
#line 71
    free((void *)parport);
#line 72
    free((void *)params);
#line 73
    free((void *)portname);
    }
#line 74
    return ((parport_t *)((void *)0));
  } else
#line 69
  if (! params) {
    {
#line 70
    free((void *)node);
#line 71
    free((void *)parport);
#line 72
    free((void *)params);
#line 73
    free((void *)portname);
    }
#line 74
    return ((parport_t *)((void *)0));
  } else
#line 69
  if (! portname) {
    {
#line 70
    free((void *)node);
#line 71
    free((void *)parport);
#line 72
    free((void *)params);
#line 73
    free((void *)portname);
    }
#line 74
    return ((parport_t *)((void *)0));
  }
#line 77
  params->portname = portname;
#line 78
  params->fd = -1;
#line 80
  parport->params = (void *)params;
#line 81
  parport->driver = & ppdev_parport_driver;
#line 82
  parport->cable = (cable_t *)((void *)0);
#line 84
  node->port = parport;
#line 85
  node->next = ports;
#line 87
  ports = node;
#line 89
  return (parport);
}
}
#line 92 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/parport/ppdev.c"
static void ppdev_parport_free(parport_t *port ) 
{ 
  port_node_t **prev ;
  port_node_t *pn ;

  {
#line 97
  prev = & ports;
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
#line 97
    if (! *prev) {
#line 97
      goto while_break;
    }
#line 98
    if ((unsigned long )(*prev)->port == (unsigned long )port) {
#line 99
      goto while_break;
    }
#line 97
    prev = & (*prev)->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 101
  if (*prev) {
    {
#line 102
    pn = *prev;
#line 103
    *prev = pn->next;
#line 104
    free((void *)pn);
    }
  }
  {
#line 107
  free((void *)((ppdev_params_t *)port->params)->portname);
#line 108
  free(port->params);
#line 109
  free((void *)port);
  }
#line 110
  return;
}
}
#line 112 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/parport/ppdev.c"
parport_t *ppdev_connect(char const   **par , int parnum ) 
{ 
  port_node_t *pn ;
  parport_t *parport ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 118
  if (parnum != 1) {
    {
#line 119
    tmp = gettext("Syntax error!\n");
#line 119
    printf((char const   */* __restrict  */)tmp);
    }
#line 120
    return ((parport_t *)((void *)0));
  }
#line 123
  pn = ports;
  {
#line 123
  while (1) {
    while_continue: /* CIL Label */ ;
#line 123
    if (! pn) {
#line 123
      goto while_break;
    }
    {
#line 124
    tmp___2 = strcmp((char const   *)(pn->port)->params, *(par + 0));
    }
#line 124
    if (tmp___2 == 0) {
      {
#line 125
      tmp___0 = gettext((((pn->port)->cable)->driver)->description);
#line 125
      tmp___1 = gettext("Disconnecting %s from ppdev port %s\n");
#line 125
      printf((char const   */* __restrict  */)tmp___1, tmp___0, *(par + 0));
#line 126
      (*((((pn->port)->cable)->driver)->disconnect))((pn->port)->cable);
      }
#line 127
      goto while_break;
    }
#line 123
    pn = pn->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 130
  tmp___3 = gettext("Initializing ppdev port %s\n");
#line 130
  printf((char const   */* __restrict  */)tmp___3, *(par + 0));
#line 132
  parport = ppdev_parport_alloc(*(par + 0));
  }
#line 133
  if (! parport) {
    {
#line 134
    tmp___4 = gettext("%s(%d) Out of memory.\n");
#line 134
    printf((char const   */* __restrict  */)tmp___4, "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/parport/ppdev.c",
           134);
    }
#line 135
    return ((parport_t *)((void *)0));
  }
#line 138
  return (parport);
}
}
#line 141 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/parport/ppdev.c"
static int ppdev_open(parport_t *parport ) 
{ 
  ppdev_params_t *p ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 144
  p = (ppdev_params_t *)parport->params;
#line 146
  p->fd = open((char const   *)p->portname, 2);
  }
#line 147
  if (p->fd < 0) {
    {
#line 148
    tmp = __errno_location();
#line 148
    tmp___0 = strerror(*tmp);
#line 148
    tmp___1 = gettext("Could not open port %s: %s\n");
#line 148
    printf((char const   */* __restrict  */)tmp___1, p->portname, tmp___0);
    }
#line 149
    return (-1);
  }
  {
#line 152
  tmp___5 = ioctl(p->fd, (unsigned long )((unsigned int )(112 << 8) | 139U));
  }
#line 152
  if (tmp___5 == -1) {
    {
#line 153
    tmp___2 = __errno_location();
#line 153
    tmp___3 = strerror(*tmp___2);
#line 153
    tmp___4 = gettext("Could not claim ppdev device: %s\n");
#line 153
    printf((char const   */* __restrict  */)tmp___4, tmp___3);
#line 154
    close(p->fd);
#line 155
    p->fd = -1;
    }
#line 156
    return (-1);
  }
#line 159
  return (0);
}
}
#line 162 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/parport/ppdev.c"
static int ppdev_close(parport_t *parport ) 
{ 
  int r ;
  ppdev_params_t *p ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 165
  r = 0;
#line 166
  p = (ppdev_params_t *)parport->params;
#line 168
  tmp = ioctl(p->fd, (unsigned long )((unsigned int )(112 << 8) | 140U));
  }
#line 168
  if (tmp == -1) {
#line 169
    r = -1;
  }
  {
#line 171
  tmp___0 = close(p->fd);
  }
#line 171
  if (tmp___0 != 0) {
#line 172
    return (-1);
  }
#line 174
  p->fd = -1;
#line 175
  return (r);
}
}
#line 178 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/parport/ppdev.c"
static int ppdev_set_data(parport_t *parport , uint8_t data ) 
{ 
  ppdev_params_t *p ;
  int tmp ;

  {
  {
#line 181
  p = (ppdev_params_t *)parport->params;
#line 183
  tmp = ioctl(p->fd, (unsigned long )(((1U << 30) | (unsigned int )(112 << 8)) | 134U) | (sizeof(unsigned char ) << 16),
              & data);
  }
#line 183
  if (tmp == -1) {
#line 184
    return (-1);
  }
#line 186
  return (0);
}
}
#line 189 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/parport/ppdev.c"
static int ppdev_get_data(parport_t *parport ) 
{ 
  unsigned char d ;
  ppdev_params_t *p ;
  int tmp ;

  {
  {
#line 193
  p = (ppdev_params_t *)parport->params;
#line 195
  tmp = ioctl(p->fd, (unsigned long )(((2U << 30) | (unsigned int )(112 << 8)) | 133U) | (sizeof(unsigned char ) << 16),
              & d);
  }
#line 195
  if (tmp == -1) {
#line 196
    return (-1);
  }
#line 198
  return ((int )d);
}
}
#line 201 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/parport/ppdev.c"
static int ppdev_get_status(parport_t *parport ) 
{ 
  unsigned char d ;
  ppdev_params_t *p ;
  int tmp ;

  {
  {
#line 205
  p = (ppdev_params_t *)parport->params;
#line 207
  tmp = ioctl(p->fd, (unsigned long )(((2U << 30) | (unsigned int )(112 << 8)) | 129U) | (sizeof(unsigned char ) << 16),
              & d);
  }
#line 207
  if (tmp == -1) {
#line 208
    return (-1);
  }
#line 210
  return ((int )d ^ 128);
}
}
#line 213 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/parport/ppdev.c"
static int ppdev_set_control(parport_t *parport , uint8_t data ) 
{ 
  ppdev_params_t *p ;
  int tmp ;

  {
  {
#line 216
  p = (ppdev_params_t *)parport->params;
#line 218
  data = (uint8_t )((int )data ^ 11);
#line 220
  tmp = ioctl(p->fd, (unsigned long )(((1U << 30) | (unsigned int )(112 << 8)) | 132U) | (sizeof(unsigned char ) << 16),
              & data);
  }
#line 220
  if (tmp == -1) {
#line 221
    return (-1);
  }
#line 223
  return (0);
}
}
#line 226 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/parport/ppdev.c"
parport_driver_t ppdev_parport_driver  = 
#line 226
     {"ppdev", & ppdev_connect, & ppdev_parport_free, & ppdev_open, & ppdev_close, & ppdev_set_data,
    & ppdev_get_data, & ppdev_get_status, & ppdev_set_control};
#line 54 "../../include/parport.h"
int parport_close(parport_t *port ) ;
#line 58
int parport_set_control(parport_t *port , uint8_t data ) ;
#line 60
parport_driver_t *parport_drivers[3] ;
#line 29 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/parport.c"
parport_driver_t direct_parport_driver ;
#line 33 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/parport.c"
parport_driver_t *parport_drivers[3]  = {      & direct_parport_driver,      & ppdev_parport_driver,      (parport_driver_t *)((void *)0)};
#line 49 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/parport.c"
int parport_open(parport_t *port ) 
{ 
  int tmp ;

  {
  {
#line 52
  tmp = (*((port->driver)->open))(port);
  }
#line 52
  return (tmp);
}
}
#line 55 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/parport.c"
int parport_close(parport_t *port ) 
{ 
  int tmp ;

  {
  {
#line 58
  tmp = (*((port->driver)->close))(port);
  }
#line 58
  return (tmp);
}
}
#line 61 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/parport.c"
int parport_set_data(parport_t *port , uint8_t data ) 
{ 
  int tmp ;

  {
  {
#line 64
  tmp = (*((port->driver)->set_data))(port, data);
  }
#line 64
  return (tmp);
}
}
#line 67 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/parport.c"
int parport_get_data(parport_t *port ) 
{ 
  int tmp ;

  {
  {
#line 70
  tmp = (*((port->driver)->get_data))(port);
  }
#line 70
  return (tmp);
}
}
#line 73 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/parport.c"
int parport_get_status(parport_t *port ) 
{ 
  int tmp ;

  {
  {
#line 76
  tmp = (*((port->driver)->get_status))(port);
  }
#line 76
  return (tmp);
}
}
#line 79 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/parport.c"
int parport_set_control(parport_t *port , uint8_t data ) 
{ 
  int tmp ;

  {
  {
#line 82
  tmp = (*((port->driver)->set_control))(port, data);
  }
#line 82
  return (tmp);
}
}
#line 64 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/mpcbdm.c"
static int mpcbdm_init(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 67
  tmp = parport_open(cable->link.port);
  }
#line 67
  if (tmp) {
#line 68
    return (-1);
  }
  {
#line 70
  parport_set_control(cable->link.port, (uint8_t )0);
#line 71
  ((generic_params_t *)cable->params)->signals = 24;
  }
#line 73
  return (0);
}
}
#line 76 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/mpcbdm.c"
static void mpcbdm_clock(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 81
  if (tms) {
#line 81
    tms = 1;
  } else {
#line 81
    tms = 0;
  }
#line 82
  if (tdi) {
#line 82
    tdi = 1;
  } else {
#line 82
    tdi = 0;
  }
#line 84
  i = 0;
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
#line 84
    if (! (i < n)) {
#line 84
      goto while_break;
    }
    {
#line 85
    parport_set_data(cable->link.port, (uint8_t )((tms << 2) | (tdi << 1)));
#line 86
    cable_wait(cable);
#line 87
    parport_set_data(cable->link.port, (uint8_t )((1 | (tms << 2)) | (tdi << 1)));
#line 88
    cable_wait(cable);
#line 84
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 91
  ((generic_params_t *)cable->params)->signals &= 24;
#line 92
  ((generic_params_t *)cable->params)->signals |= 2;
#line 93
  if (tms) {
#line 93
    tmp = 4;
  } else {
#line 93
    tmp = 0;
  }
#line 93
  ((generic_params_t *)cable->params)->signals |= tmp;
#line 94
  if (tdi) {
#line 94
    tmp___0 = 1;
  } else {
#line 94
    tmp___0 = 0;
  }
#line 94
  ((generic_params_t *)cable->params)->signals |= tmp___0;
#line 95
  return;
}
}
#line 97 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/mpcbdm.c"
static int mpcbdm_get_tdo(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 100
  parport_set_data(cable->link.port, (uint8_t )0);
#line 101
  ((generic_params_t *)cable->params)->signals &= -8;
#line 103
  cable_wait(cable);
#line 105
  tmp = parport_get_status(cable->link.port);
  }
#line 105
  return ((tmp >> 5) & 1);
}
}
#line 108 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/mpcbdm.c"
static int mpcbdm_set_signal(cable_t *cable , int mask , int val ) 
{ 
  int prev_sigs ;
  int sigs ;
  int data ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int data___0 ;
  int tmp___2 ;

  {
#line 111
  prev_sigs = ((generic_params_t *)cable->params)->signals;
#line 113
  mask &= 31;
#line 115
  if (mask) {
#line 117
    sigs = (((generic_params_t *)cable->params)->signals & ~ mask) | (val & mask);
#line 119
    if ((mask & -25) != 0) {
#line 121
      data = 0;
#line 122
      if (sigs & 1) {
#line 122
        tmp = 1 << 1;
      } else {
#line 122
        tmp = 0;
      }
#line 122
      data |= tmp;
#line 123
      if (sigs & 2) {
#line 123
        tmp___0 = 1;
      } else {
#line 123
        tmp___0 = 0;
      }
#line 123
      data |= tmp___0;
#line 124
      if (sigs & 4) {
#line 124
        tmp___1 = 1 << 2;
      } else {
#line 124
        tmp___1 = 0;
      }
      {
#line 124
      data |= tmp___1;
#line 125
      parport_set_data(cable->link.port, (uint8_t )data);
      }
    }
#line 127
    if ((mask & 24) != 0) {
#line 129
      data___0 = 0;
#line 130
      if (sigs & 8) {
#line 130
        tmp___2 = 0;
      } else {
#line 130
        tmp___2 = 1;
      }
      {
#line 130
      data___0 |= tmp___2;
#line 132
      parport_set_control(cable->link.port, (uint8_t )data___0);
      }
    }
#line 134
    ((generic_params_t *)cable->params)->signals = sigs;
  }
#line 137
  return (prev_sigs);
}
}
#line 140 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/mpcbdm.c"
cable_driver_t mpcbdm_cable_driver  = 
#line 140
     {"MPCBDM", "Mpcbdm JTAG cable", & generic_parport_connect, & generic_disconnect,
    & generic_parport_free, & mpcbdm_init, & generic_parport_done, & generic_set_frequency,
    & mpcbdm_clock, & mpcbdm_get_tdo, & generic_transfer, & mpcbdm_set_signal, & generic_get_signal,
    & generic_flush_one_by_one, & generic_parport_help};
#line 54 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/lattice.c"
static int lattice_init(cable_t *cable ) 
{ 
  int data ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 59
  tmp = parport_open(cable->link.port);
  }
#line 59
  if (tmp) {
#line 60
    return (-1);
  }
  {
#line 62
  data = parport_get_data(cable->link.port);
  }
#line 62
  if (data < 0) {
    {
#line 63
    tmp___0 = parport_set_data(cable->link.port, (uint8_t )(1 << 4));
    }
#line 63
    if (tmp___0) {
#line 64
      return (-1);
    }
#line 65
    ((generic_params_t *)cable->params)->signals = 8;
  } else
#line 67
  if (data >> 4) {
#line 67
    ((generic_params_t *)cable->params)->signals = 8;
  } else {
#line 67
    ((generic_params_t *)cable->params)->signals = 0;
  }
#line 69
  return (0);
}
}
#line 72 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/lattice.c"
static void lattice_clock(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;
  int trst ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 76
  if (((generic_params_t *)cable->params)->signals & 8) {
#line 76
    tmp = 1;
  } else {
#line 76
    tmp = 0;
  }
#line 76
  trst = tmp;
#line 78
  if (tms) {
#line 78
    tms = 1;
  } else {
#line 78
    tms = 0;
  }
#line 79
  if (tdi) {
#line 79
    tdi = 1;
  } else {
#line 79
    tdi = 0;
  }
#line 81
  i = 0;
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    if (! (i < n)) {
#line 81
      goto while_break;
    }
    {
#line 82
    parport_set_data(cable->link.port, (uint8_t )(((trst << 4) | (tms << 2)) | tdi));
#line 83
    cable_wait(cable);
#line 84
    parport_set_data(cable->link.port, (uint8_t )((((trst << 4) | (1 << 1)) | (tms << 2)) | tdi));
#line 85
    cable_wait(cable);
#line 81
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 88
  ((generic_params_t *)cable->params)->signals &= 8;
#line 89
  ((generic_params_t *)cable->params)->signals |= 2;
#line 90
  if (tms) {
#line 90
    tmp___0 = 4;
  } else {
#line 90
    tmp___0 = 0;
  }
#line 90
  ((generic_params_t *)cable->params)->signals |= tmp___0;
#line 91
  if (tdi) {
#line 91
    tmp___1 = 1;
  } else {
#line 91
    tmp___1 = 0;
  }
#line 91
  ((generic_params_t *)cable->params)->signals |= tmp___1;
#line 92
  return;
}
}
#line 94 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/lattice.c"
static int lattice_get_tdo(cable_t *cable ) 
{ 
  int trst ;
  int tmp ;
  int tmp___0 ;

  {
#line 97
  if (((generic_params_t *)cable->params)->signals & 8) {
#line 97
    tmp = 1;
  } else {
#line 97
    tmp = 0;
  }
  {
#line 97
  trst = tmp;
#line 99
  parport_set_data(cable->link.port, (uint8_t )(trst << 4));
#line 100
  ((generic_params_t *)cable->params)->signals &= -8;
#line 102
  cable_wait(cable);
#line 104
  tmp___0 = parport_get_status(cable->link.port);
  }
#line 104
  return ((tmp___0 >> 6) & 1);
}
}
#line 107 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/lattice.c"
static int lattice_set_signal(cable_t *cable , int mask , int val ) 
{ 
  int prev_sigs ;
  int data ;
  int sigs ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 110
  prev_sigs = ((generic_params_t *)cable->params)->signals;
#line 112
  mask &= 15;
#line 114
  if (mask != 0) {
#line 116
    data = 0;
#line 117
    sigs = (((generic_params_t *)cable->params)->signals & ~ mask) | (val & mask);
#line 118
    if (sigs & 1) {
#line 118
      tmp = 1;
    } else {
#line 118
      tmp = 0;
    }
#line 118
    data |= tmp;
#line 119
    if (sigs & 2) {
#line 119
      tmp___0 = 1 << 1;
    } else {
#line 119
      tmp___0 = 0;
    }
#line 119
    data |= tmp___0;
#line 120
    if (sigs & 4) {
#line 120
      tmp___1 = 1 << 2;
    } else {
#line 120
      tmp___1 = 0;
    }
#line 120
    data |= tmp___1;
#line 121
    if (sigs & 8) {
#line 121
      tmp___2 = 1 << 4;
    } else {
#line 121
      tmp___2 = 0;
    }
    {
#line 121
    data |= tmp___2;
#line 122
    parport_set_data(cable->link.port, (uint8_t )data);
#line 123
    ((generic_params_t *)cable->params)->signals = sigs;
    }
  }
#line 126
  return (prev_sigs);
}
}
#line 129 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/lattice.c"
cable_driver_t lattice_cable_driver  = 
#line 129
     {"Lattice", "Lattice Parallel Port JTAG Cable", & generic_parport_connect, & generic_disconnect,
    & generic_parport_free, & lattice_init, & generic_parport_done, & generic_set_frequency,
    & lattice_clock, & lattice_get_tdo, & generic_transfer, & lattice_set_signal,
    & generic_get_signal, & generic_flush_one_by_one, & generic_parport_help};
#line 66 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/keithkoep.c"
static int keithkoep_init(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 69
  tmp = parport_open(cable->link.port);
  }
#line 69
  if (tmp) {
#line 70
    return (-1);
  }
  {
#line 72
  parport_set_control(cable->link.port, (uint8_t )1);
#line 73
  ((generic_params_t *)cable->params)->signals = 8;
  }
#line 75
  return (0);
}
}
#line 78 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/keithkoep.c"
static void keithkoep_clock(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 83
  if (tms) {
#line 83
    tms = 1;
  } else {
#line 83
    tms = 0;
  }
#line 84
  if (tdi) {
#line 84
    tdi = 1;
  } else {
#line 84
    tdi = 0;
  }
#line 86
  i = 0;
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
#line 86
    if (! (i < n)) {
#line 86
      goto while_break;
    }
    {
#line 87
    parport_set_data(cable->link.port, (uint8_t )((tms << 2) | tdi));
#line 88
    cable_wait(cable);
#line 89
    parport_set_data(cable->link.port, (uint8_t )(((1 << 1) | (tms << 2)) | tdi));
#line 90
    cable_wait(cable);
#line 86
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 93
  ((generic_params_t *)cable->params)->signals &= 8;
#line 94
  ((generic_params_t *)cable->params)->signals |= 2;
#line 95
  if (tms) {
#line 95
    tmp = 4;
  } else {
#line 95
    tmp = 0;
  }
#line 95
  ((generic_params_t *)cable->params)->signals |= tmp;
#line 96
  if (tdi) {
#line 96
    tmp___0 = 1;
  } else {
#line 96
    tmp___0 = 0;
  }
#line 96
  ((generic_params_t *)cable->params)->signals |= tmp___0;
#line 97
  return;
}
}
#line 99 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/keithkoep.c"
static int keithkoep_get_tdo(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 102
  parport_set_data(cable->link.port, (uint8_t )0);
#line 103
  ((generic_params_t *)cable->params)->signals &= -8;
#line 105
  cable_wait(cable);
#line 107
  tmp = parport_get_status(cable->link.port);
  }
#line 107
  return ((tmp >> 5) & 1);
}
}
#line 110 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/keithkoep.c"
static int keithkoep_set_signal(cable_t *cable , int mask , int val ) 
{ 
  int prev_sigs ;
  int sigs ;
  int data ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 113
  prev_sigs = ((generic_params_t *)cable->params)->signals;
#line 115
  mask &= 15;
#line 117
  if (mask != 0) {
#line 119
    sigs = (prev_sigs & ~ mask) | (val & mask);
#line 121
    if ((mask & -9) != 0) {
#line 123
      data = 0;
#line 124
      if (sigs & 1) {
#line 124
        tmp = 1;
      } else {
#line 124
        tmp = 0;
      }
#line 124
      data |= tmp;
#line 125
      if (sigs & 2) {
#line 125
        tmp___0 = 1 << 1;
      } else {
#line 125
        tmp___0 = 0;
      }
#line 125
      data |= tmp___0;
#line 126
      if (sigs & 4) {
#line 126
        tmp___1 = 1 << 2;
      } else {
#line 126
        tmp___1 = 0;
      }
      {
#line 126
      data |= tmp___1;
#line 127
      parport_set_data(cable->link.port, (uint8_t )data);
      }
    }
#line 129
    if ((mask & 8) != 0) {
#line 131
      if (sigs & 8) {
#line 131
        tmp___2 = 1;
      } else {
#line 131
        tmp___2 = 0;
      }
      {
#line 131
      parport_set_control(cable->link.port, (uint8_t )tmp___2);
      }
    }
#line 133
    ((generic_params_t *)cable->params)->signals = sigs;
  }
#line 136
  return (prev_sigs);
}
}
#line 139 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/keithkoep.c"
cable_driver_t keithkoep_cable_driver  = 
#line 139
     {"KeithKoep", "Keith & Koep JTAG cable", & generic_parport_connect, & generic_disconnect,
    & generic_parport_free, & keithkoep_init, & generic_parport_done, & generic_set_frequency,
    & keithkoep_clock, & keithkoep_get_tdo, & generic_transfer, & keithkoep_set_signal,
    & generic_get_signal, & generic_flush_one_by_one, & generic_parport_help};
#line 56 "../../include/jtag.h"
void idcode(chain_t *chain , unsigned int bytes ) ;
#line 35 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/idcode.c"
void idcode(chain_t *chain , unsigned int bytes ) 
{ 
  int i ;
  int hit ;
  tap_register *rz ;
  tap_register *rout ;
  tap_register *rnull ;
  tap_register *tmp ;
  tap_register *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  unsigned int tmp___6 ;
  char *tmp___7 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
  {
#line 39
  hit = 0;
#line 44
  chain_set_trst(chain, 0);
#line 45
  chain_set_trst(chain, 1);
#line 47
  tap_reset(chain);
#line 48
  tap_capture_dr(chain);
#line 51
  tmp = register_alloc(8);
#line 51
  rz = register_fill(tmp, 0);
#line 52
  tmp___0 = register_alloc(8);
#line 52
  rnull = register_fill(tmp___0, 0);
#line 53
  rout = register_alloc(8);
  }
#line 55
  if (! rz) {
    {
#line 57
    tmp___1 = gettext("Allocation failed\n");
#line 57
    printf((char const   */* __restrict  */)tmp___1);
    }
  } else
#line 55
  if (! rout) {
    {
#line 57
    tmp___1 = gettext("Allocation failed\n");
#line 57
    printf((char const   */* __restrict  */)tmp___1);
    }
  } else
#line 55
  if (! rnull) {
    {
#line 57
    tmp___1 = gettext("Allocation failed\n");
#line 57
    printf((char const   */* __restrict  */)tmp___1);
    }
  }
  {
#line 59
  tmp___2 = gettext("Read");
#line 59
  printf((char const   */* __restrict  */)tmp___2);
#line 60
  i = 0;
  }
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 60
    if (bytes) {
#line 60
      tmp___6 = bytes;
    } else {
#line 60
      tmp___6 = 1000U;
    }
#line 60
    if (! ((unsigned int )i < tmp___6)) {
#line 60
      goto while_break;
    }
    {
#line 62
    tap_shift_register(chain, (tap_register const   *)rz, rout, 0);
#line 63
    tmp___3 = register_get_string((tap_register const   *)rout);
#line 63
    tmp___4 = gettext(" %s");
#line 63
    printf((char const   */* __restrict  */)tmp___4, tmp___3);
    }
#line 64
    if (! bytes) {
      {
#line 67
      tmp___5 = register_compare((tap_register const   *)rout, (tap_register const   *)rnull);
      }
#line 67
      if (tmp___5) {
#line 70
        hit = 0;
      } else {
#line 68
        hit ++;
      }
#line 71
      if (hit > 3) {
#line 72
        goto while_break;
      }
    }
#line 60
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 75
  register_free(rz);
#line 76
  register_free(rnull);
#line 77
  register_free(rout);
#line 78
  tmp___7 = gettext("\n");
#line 78
  printf((char const   */* __restrict  */)tmp___7);
  }
#line 79
  return;
}
}
#line 184 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) strtol)(char const   * __restrict  __nptr ,
                                                                                    char ** __restrict  __endptr ,
                                                                                    int __base ) ;
#line 31 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/generic_usbconn.h"
int generic_usbconn_connect(char **params , cable_t *cable ) ;
#line 32
void generic_usbconn_done(cable_t *cable ) ;
#line 33
void generic_usbconn_help(char const   *cablename ) ;
#line 34
void generic_usbconn_free(cable_t *cable ) ;
#line 90 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/generic_usbconn.c"
usbconn_cable_t *usbconn_cables[1]  = {      (usbconn_cable_t *)((void *)0)};
#line 144 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/generic_usbconn.c"
int generic_usbconn_connect(char **params , cable_t *cable ) 
{ 
  usbconn_cable_t user_specified ;
  int paramc ;
  int tmp ;
  generic_params_t *cable_params ;
  usbconn_t *conn ;
  int i ;
  int tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int j ;
  usbconn_cable_t cable_try ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  void *tmp___11 ;
  char *tmp___12 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
  {
#line 147
  user_specified.name = (char *)((void *)0);
#line 147
  user_specified.desc = (char *)((void *)0);
#line 147
  user_specified.driver = (char *)((void *)0);
#line 147
  user_specified.vid = -1;
#line 147
  user_specified.pid = -1;
#line 155
  tmp = cmd_params(params);
#line 155
  paramc = tmp;
#line 157
  conn = (usbconn_t *)((void *)0);
#line 160
  tmp___0 = strcasecmp((char const   *)*(params + 0), "usb");
  }
#line 160
  if (tmp___0 != 0) {
#line 162
    user_specified.name = *(params + 0);
  }
#line 166
  i = 1;
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
#line 166
    if (! (i < paramc)) {
#line 166
      goto while_break;
    }
    {
#line 168
    tmp___6 = strncasecmp("pid=", (char const   *)*(params + i), (size_t )4);
    }
#line 168
    if (tmp___6 == 0) {
      {
#line 170
      tmp___1 = strtol((char const   */* __restrict  */)(*(params + i) + 4), (char **/* __restrict  */)((void *)0),
                       16);
#line 170
      user_specified.pid = (int32_t )tmp___1;
      }
    } else {
      {
#line 172
      tmp___5 = strncasecmp("vid=", (char const   *)*(params + i), (size_t )4);
      }
#line 172
      if (tmp___5 == 0) {
        {
#line 174
        tmp___2 = strtol((char const   */* __restrict  */)(*(params + i) + 4), (char **/* __restrict  */)((void *)0),
                         16);
#line 174
        user_specified.vid = (int32_t )tmp___2;
        }
      } else {
        {
#line 176
        tmp___4 = strncasecmp("desc=", (char const   *)*(params + i), (size_t )5);
        }
#line 176
        if (tmp___4 == 0) {
#line 178
          user_specified.desc = *(params + i) + 5;
        } else {
          {
#line 180
          tmp___3 = strncasecmp("driver=", (char const   *)*(params + i), (size_t )7);
          }
#line 180
          if (tmp___3 == 0) {
#line 182
            user_specified.driver = *(params + i) + 7;
          }
        }
      }
    }
#line 166
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 187
  i = 0;
  {
#line 187
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 187
    if (usbconn_drivers[i]) {
#line 187
      if (! (! conn)) {
#line 187
        goto while_break___0;
      }
    } else {
#line 187
      goto while_break___0;
    }
#line 189
    if ((unsigned long )user_specified.driver == (unsigned long )((void *)0)) {
#line 189
      goto _L___0;
    } else {
      {
#line 189
      tmp___9 = strcasecmp((char const   *)user_specified.driver, (usbconn_drivers[i])->type);
      }
#line 189
      if (tmp___9 == 0) {
        _L___0: /* CIL Label */ 
#line 195
        j = 0;
        {
#line 195
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 195
          if (usbconn_cables[j]) {
#line 195
            if (! (! conn)) {
#line 195
              goto while_break___1;
            }
          } else {
#line 195
            goto while_break___1;
          }
#line 197
          if ((unsigned long )user_specified.name == (unsigned long )((void *)0)) {
#line 197
            goto _L;
          } else {
            {
#line 197
            tmp___8 = strcasecmp((char const   *)user_specified.name, (char const   *)(usbconn_cables[j])->name);
            }
#line 197
            if (tmp___8 == 0) {
              _L: /* CIL Label */ 
              {
#line 200
              tmp___7 = strcasecmp((char const   *)(usbconn_cables[j])->driver, (usbconn_drivers[i])->type);
              }
#line 200
              if (tmp___7 == 0) {
#line 202
                cable_try = *(usbconn_cables[j]);
#line 204
                if (user_specified.vid >= 0) {
#line 204
                  cable_try.vid = user_specified.vid;
                }
#line 205
                if (user_specified.pid >= 0) {
#line 205
                  cable_try.pid = user_specified.pid;
                }
#line 206
                if ((unsigned long )user_specified.desc != (unsigned long )((char *)0)) {
#line 206
                  cable_try.desc = user_specified.desc;
                }
                {
#line 208
                conn = (*((usbconn_drivers[i])->connect))((char const   **)(params + 1),
                                                          paramc - 1, & cable_try);
                }
              }
            }
          }
#line 195
          j ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    }
#line 187
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 216
  if (! conn) {
    {
#line 217
    tmp___10 = gettext("Couldn\'t connect to suitable USB device.\n");
#line 217
    printf((char const   */* __restrict  */)tmp___10);
    }
#line 218
    return (2);
  }
  {
#line 221
  tmp___11 = malloc((size_t )sizeof(generic_params_t ));
#line 221
  cable_params = (generic_params_t *)tmp___11;
  }
#line 222
  if (! cable_params) {
    {
#line 223
    tmp___12 = gettext("%s(%d) malloc failed!\n");
#line 223
    printf((char const   */* __restrict  */)tmp___12, "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/generic_usbconn.c",
           223);
#line 224
    (*((usbconn_drivers[i])->free))(conn);
    }
#line 225
    return (4);
  }
#line 228
  cable->link.usb = conn;
#line 229
  cable->params = (void *)cable_params;
#line 230
  cable->chain = (chain_t *)((void *)0);
#line 232
  return (0);
}
}
#line 235 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/generic_usbconn.c"
void generic_usbconn_free(cable_t *cable ) 
{ 


  {
  {
#line 238
  (*(((cable->link.usb)->driver)->free))(cable->link.usb);
#line 239
  free(cable->params);
#line 240
  free((void *)cable);
  }
#line 241
  return;
}
}
#line 243 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/generic_usbconn.c"
void generic_usbconn_done(cable_t *cable ) 
{ 


  {
  {
#line 246
  usbconn_close(cable->link.usb);
  }
#line 247
  return;
}
}
#line 249 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/generic_usbconn.c"
void generic_usbconn_help(char const   *cablename ) 
{ 
  char *tmp ;
  char *__cil_tmp3 ;

  {
  {
#line 252
  tmp = gettext("Usage: cable %s [vid=VID] [pid=PID] [desc=DESC] [...]\n\nVID        USB Device Vendor ID (hex, e.g. 0abc)\nPID        USB Device Product ID (hex, e.g. 0abc)\nDESC       Some string to match in description or serial no.\n\n");
#line 252
  printf((char const   */* __restrict  */)tmp, cablename);
  }
#line 262
  return;
}
}
#line 50 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/generic_parport.c"
int generic_parport_connect(char **params , cable_t *cable ) 
{ 
  generic_params_t *cable_params ;
  parport_t *port ;
  int i ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  void *tmp___5 ;
  char *tmp___6 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
#line 57
  tmp___0 = cmd_params(params);
  }
#line 57
  if (tmp___0 < 3) {
    {
#line 58
    tmp = gettext("not enough arguments!\n");
#line 58
    printf((char const   */* __restrict  */)tmp);
    }
#line 59
    return (1);
  }
#line 63
  i = 0;
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    if (! parport_drivers[i]) {
#line 63
      goto while_break;
    }
    {
#line 64
    tmp___1 = strcasecmp((char const   *)*(params + 1), (parport_drivers[i])->type);
    }
#line 64
    if (tmp___1 == 0) {
#line 65
      goto while_break;
    }
#line 63
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 66
  if (! parport_drivers[i]) {
    {
#line 67
    tmp___2 = gettext("Unknown port driver: %s\n");
#line 67
    printf((char const   */* __restrict  */)tmp___2, *(params + 1));
    }
#line 68
    return (2);
  }
  {
#line 72
  tmp___3 = cmd_params(params);
#line 72
  port = (*((parport_drivers[i])->connect))((char const   **)(params + 2), tmp___3 - 2);
  }
#line 75
  if ((unsigned long )port == (unsigned long )((void *)0)) {
    {
#line 76
    tmp___4 = gettext("Error: Cable connection failed!\n");
#line 76
    printf((char const   */* __restrict  */)tmp___4);
    }
#line 77
    return (3);
  }
  {
#line 80
  tmp___5 = malloc((size_t )sizeof(*cable_params));
#line 80
  cable_params = (generic_params_t *)tmp___5;
  }
#line 81
  if (! cable_params) {
    {
#line 82
    tmp___6 = gettext("%s(%d) malloc failed!\n");
#line 82
    printf((char const   */* __restrict  */)tmp___6, "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/generic_parport.c",
           82);
#line 83
    (*((parport_drivers[i])->parport_free))(port);
    }
#line 84
    return (4);
  }
#line 87
  cable->link.port = port;
#line 88
  cable->params = (void *)cable_params;
#line 89
  cable->chain = (chain_t *)((void *)0);
#line 91
  return (0);
}
}
#line 94 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/generic_parport.c"
void generic_parport_free(cable_t *cable ) 
{ 


  {
  {
#line 97
  (*(((cable->link.port)->driver)->parport_free))(cable->link.port);
#line 98
  free(cable->params);
#line 99
  free((void *)cable);
  }
#line 100
  return;
}
}
#line 102 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/generic_parport.c"
void generic_parport_done(cable_t *cable ) 
{ 


  {
  {
#line 105
  parport_close(cable->link.port);
  }
#line 106
  return;
}
}
#line 108 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/generic_parport.c"
void generic_parport_help(char const   *cablename ) 
{ 
  char *tmp ;
  char *__cil_tmp3 ;

  {
  {
#line 111
  tmp = gettext("Usage: cable %s parallel PORTADDR\n   or: cable %s ppdev PPDEV\n\nPORTADDR   parallel port address (e.g. 0x378)\nPPDEV      ppdev device (e.g. /dev/parport0)\n\n");
#line 111
  printf((char const   */* __restrict  */)tmp, cablename, cablename);
  }
#line 137
  return;
}
}
#line 52 "../../include/chain.h"
void chain_disconnect(chain_t *chain ) ;
#line 126 "../../include/cable.h"
void cable_done(cable_t *cable ) ;
#line 145
void cable_purge_queue(cable_queue_info_t *q , int io ) ;
#line 146
int cable_add_queue_item(cable_t *cable , cable_queue_info_t *q ) ;
#line 147
int cable_get_queue_item(cable_t *cable , cable_queue_info_t *q ) ;
#line 35 "../../include/fclock.h"
long double frealtime(void) ;
#line 42 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/generic.h"
void generic_flush_using_transfer(cable_t *cable , cable_flush_amount_t how_much ) ;
#line 60 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/generic.c"
void generic_disconnect(cable_t *cable ) 
{ 


  {
  {
#line 63
  cable_done(cable);
#line 64
  chain_disconnect(cable->chain);
  }
#line 65
  return;
}
}
#line 67 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/generic.c"
int generic_transfer(cable_t *cable , int len , char *in , char *out ) 
{ 
  int i ;
  int tmp ;

  {
#line 72
  if (out) {
#line 73
    i = 0;
    {
#line 73
    while (1) {
      while_continue: /* CIL Label */ ;
#line 73
      if (! (i < len)) {
#line 73
        goto while_break;
      }
      {
#line 74
      tmp = (*((cable->driver)->get_tdo))(cable);
#line 74
      *(out + i) = (char )tmp;
#line 75
      (*((cable->driver)->clock))(cable, 0, (int )*(in + i), 1);
#line 73
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 78
    i = 0;
    {
#line 78
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 78
      if (! (i < len)) {
#line 78
        goto while_break___0;
      }
      {
#line 79
      (*((cable->driver)->clock))(cable, 0, (int )*(in + i), 1);
#line 78
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 82
  return (i);
}
}
#line 85 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/generic.c"
int generic_get_signal(cable_t *cable , pod_sigsel_t sig ) 
{ 
  int tmp ;

  {
#line 88
  if (((unsigned int )((generic_params_t *)cable->params)->signals & (unsigned int )sig) != 0U) {
#line 88
    tmp = 1;
  } else {
#line 88
    tmp = 0;
  }
#line 88
  return (tmp);
}
}
#line 91 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/generic.c"
int do_one_queued_action(cable_t *cable ) 
{ 
  int i ;
  int j ;
  char *tmp ;
  int r ;
  int tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 100
  i = cable_get_queue_item(cable, & cable->todo);
  }
#line 100
  if (i >= 0) {
#line 104
    if (cable->done.num_items >= cable->done.max_items) {
#line 106
      if ((unsigned int )(cable->todo.data + i)->action == 1U) {
        {
#line 110
        tmp = gettext("No space in cable activity results queue.\n");
#line 110
        printf((char const   */* __restrict  */)tmp);
#line 111
        cable_purge_queue(& cable->done, 1);
        }
      } else
#line 106
      if ((unsigned int )(cable->todo.data + i)->action == 4U) {
        {
#line 110
        tmp = gettext("No space in cable activity results queue.\n");
#line 110
        printf((char const   */* __restrict  */)tmp);
#line 111
        cable_purge_queue(& cable->done, 1);
        }
      } else
#line 106
      if ((unsigned int )(cable->todo.data + i)->action == 2U) {
        {
#line 110
        tmp = gettext("No space in cable activity results queue.\n");
#line 110
        printf((char const   */* __restrict  */)tmp);
#line 111
        cable_purge_queue(& cable->done, 1);
        }
      }
    }
    {
#line 117
    if ((unsigned int )(cable->todo.data + i)->action == 0U) {
#line 117
      goto case_0;
    }
#line 123
    if ((unsigned int )(cable->todo.data + i)->action == 3U) {
#line 123
      goto case_3;
    }
#line 128
    if ((unsigned int )(cable->todo.data + i)->action == 2U) {
#line 128
      goto case_2;
    }
#line 149
    if ((unsigned int )(cable->todo.data + i)->action == 1U) {
#line 149
      goto case_1;
    }
#line 158
    if ((unsigned int )(cable->todo.data + i)->action == 4U) {
#line 158
      goto case_4;
    }
#line 115
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 118
    (*((cable->driver)->clock))(cable, (cable->todo.data + i)->arg.clock.tms, (cable->todo.data + i)->arg.clock.tdi,
                                (cable->todo.data + i)->arg.clock.n);
    }
#line 122
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 124
    cable_set_signal(cable, (int )(cable->todo.data + i)->arg.value.sig, (cable->todo.data + i)->arg.value.val);
    }
#line 127
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 130
    tmp___0 = (*((cable->driver)->transfer))(cable, (cable->todo.data + i)->arg.transfer.len,
                                             (cable->todo.data + i)->arg.transfer.in,
                                             (cable->todo.data + i)->arg.transfer.out);
#line 130
    r = tmp___0;
#line 135
    free((void *)(cable->todo.data + i)->arg.transfer.in);
    }
#line 136
    if ((unsigned long )(cable->todo.data + i)->arg.transfer.out != (unsigned long )((void *)0)) {
      {
#line 138
      j = cable_add_queue_item(cable, & cable->done);
#line 142
      (cable->done.data + j)->action = (enum __anonenum_action_29 )2;
#line 143
      (cable->done.data + j)->arg.xferred.len = (cable->todo.data + i)->arg.transfer.len;
#line 144
      (cable->done.data + j)->arg.xferred.res = r;
#line 145
      (cable->done.data + j)->arg.xferred.out = (cable->todo.data + i)->arg.transfer.out;
      }
    }
#line 147
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 150
    j = cable_add_queue_item(cable, & cable->done);
#line 154
    (cable->done.data + j)->action = (enum __anonenum_action_29 )1;
#line 155
    (cable->done.data + j)->arg.value.val = (*((cable->driver)->get_tdo))(cable);
    }
#line 157
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 159
    j = cable_add_queue_item(cable, & cable->done);
#line 163
    (cable->done.data + j)->action = (enum __anonenum_action_29 )4;
#line 164
    (cable->done.data + j)->arg.value.sig = (cable->todo.data + i)->arg.value.sig;
#line 166
    (cable->done.data + j)->arg.value.val = (*((cable->driver)->get_signal))(cable,
                                                                             (cable->todo.data + i)->arg.value.sig);
    }
#line 169
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 175
    return (1);
  }
#line 181
  return (0);
}
}
#line 184 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/generic.c"
void generic_flush_one_by_one(cable_t *cable , cable_flush_amount_t how_much ) 
{ 
  int tmp ;

  {
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 190
    tmp = do_one_queued_action(cable);
    }
#line 190
    if (! tmp) {
#line 190
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 191
  return;
}
}
#line 193 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/generic.c"
void generic_flush_using_transfer(cable_t *cable , cable_flush_amount_t how_much ) 
{ 
  int i ;
  int j ;
  int n ;
  char *in ;
  char *out ;
  int r ;
  int bits ;
  int tdo ;
  int k ;
  int k___0 ;
  void *tmp ;
  void *tmp___0 ;
  int k___1 ;
  int tmp___1 ;
  int len ;
  int k___2 ;
  int tmp___2 ;
  int c ;
  int tmp___3 ;
  char *p ;
  int len___0 ;
  int c___0 ;
  int tmp___4 ;

  {
#line 199
  if ((unsigned int )how_much == 0U) {
#line 199
    return;
  }
#line 201
  if (cable->todo.num_items == 0) {
#line 201
    return;
  }
  {
#line 203
  while (1) {
    while_continue: /* CIL Label */ ;
#line 205
    bits = 0;
#line 205
    tdo = 0;
#line 215
    i = cable->todo.next_item;
#line 215
    n = 0;
    {
#line 215
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 215
      if (! (n < cable->todo.num_items)) {
#line 215
        goto while_break___0;
      }
#line 217
      if ((unsigned int )(cable->todo.data + i)->action != 0U) {
#line 217
        if ((unsigned int )(cable->todo.data + i)->action != 2U) {
#line 217
          if ((unsigned int )(cable->todo.data + i)->action != 1U) {
#line 224
            goto while_break___0;
          }
        }
      }
#line 226
      if ((unsigned int )(cable->todo.data + i)->action == 0U) {
#line 226
        if ((cable->todo.data + i)->arg.clock.tms != 0) {
#line 232
          goto while_break___0;
        }
      }
#line 234
      if ((unsigned int )(cable->todo.data + i)->action == 0U) {
#line 236
        k = (cable->todo.data + i)->arg.clock.n;
#line 240
        bits += k;
      } else
#line 242
      if ((unsigned int )(cable->todo.data + i)->action == 2U) {
#line 244
        k___0 = (cable->todo.data + i)->arg.transfer.len;
#line 248
        bits += k___0;
      }
#line 250
      i ++;
#line 251
      if (i >= cable->todo.max_items) {
#line 251
        i = 0;
      }
#line 215
      n ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 258
    if (bits == 0) {
      {
#line 260
      do_one_queued_action(cable);
      }
    } else
#line 258
    if (n <= 1) {
      {
#line 260
      do_one_queued_action(cable);
      }
    } else {
      {
#line 266
      tmp = malloc((size_t )bits);
#line 266
      in = (char *)tmp;
#line 267
      tmp___0 = malloc((size_t )bits);
#line 267
      out = (char *)tmp___0;
      }
#line 269
      if ((unsigned long )in == (unsigned long )((void *)0)) {
#line 269
        goto _L;
      } else
#line 269
      if ((unsigned long )out == (unsigned long )((void *)0)) {
        _L: /* CIL Label */ 
#line 271
        if ((unsigned long )in != (unsigned long )((void *)0)) {
          {
#line 271
          free((void *)in);
          }
        }
#line 272
        if ((unsigned long )out != (unsigned long )((void *)0)) {
          {
#line 272
          free((void *)out);
          }
        }
        {
#line 273
        generic_flush_one_by_one(cable, how_much);
        }
#line 274
        goto while_break;
      }
#line 277
      j = 0;
#line 277
      bits = 0;
#line 277
      i = cable->todo.next_item;
      {
#line 277
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 277
        if (! (j < n)) {
#line 277
          goto while_break___1;
        }
#line 279
        if ((unsigned int )(cable->todo.data + i)->action == 0U) {
#line 282
          k___1 = 0;
          {
#line 282
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 282
            if (! (k___1 < (cable->todo.data + i)->arg.clock.n)) {
#line 282
              goto while_break___2;
            }
#line 283
            tmp___1 = bits;
#line 283
            bits ++;
#line 283
            *(in + tmp___1) = (char )(cable->todo.data + i)->arg.clock.tdi;
#line 282
            k___1 ++;
          }
          while_break___2: /* CIL Label */ ;
          }
        } else
#line 285
        if ((unsigned int )(cable->todo.data + i)->action == 2U) {
#line 287
          len = (cable->todo.data + i)->arg.transfer.len;
#line 288
          if (len > 0) {
            {
#line 290
            memcpy((void */* __restrict  */)(in + bits), (void const   */* __restrict  */)(cable->todo.data + i)->arg.transfer.in,
                   (size_t )len);
#line 291
            bits += len;
            }
          }
        }
#line 294
        i ++;
#line 295
        if (i >= cable->todo.max_items) {
#line 295
          i = 0;
        }
#line 277
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 300
      r = (*((cable->driver)->transfer))(cable, bits, in, out);
#line 308
      j = 0;
#line 308
      bits = 0;
#line 308
      i = cable->todo.next_item;
      }
      {
#line 308
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 308
        if (! (j < n)) {
#line 308
          goto while_break___3;
        }
#line 310
        if ((unsigned int )(cable->todo.data + i)->action == 0U) {
#line 313
          k___2 = 0;
          {
#line 313
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 313
            if (! (k___2 < (cable->todo.data + i)->arg.clock.n)) {
#line 313
              goto while_break___4;
            }
#line 314
            tmp___2 = bits;
#line 314
            bits ++;
#line 314
            tdo = (int )*(out + tmp___2);
#line 313
            k___2 ++;
          }
          while_break___4: /* CIL Label */ ;
          }
        } else
#line 316
        if ((unsigned int )(cable->todo.data + i)->action == 1U) {
          {
#line 318
          tmp___3 = cable_add_queue_item(cable, & cable->done);
#line 318
          c = tmp___3;
#line 322
          (cable->done.data + c)->action = (enum __anonenum_action_29 )1;
#line 323
          (cable->done.data + c)->arg.value.val = tdo;
          }
        } else
#line 325
        if ((unsigned int )(cable->todo.data + i)->action == 2U) {
          {
#line 327
          p = (cable->todo.data + i)->arg.transfer.out;
#line 328
          len___0 = (cable->todo.data + i)->arg.transfer.len;
#line 329
          free((void *)(cable->todo.data + i)->arg.transfer.in);
          }
#line 330
          if ((unsigned long )p != (unsigned long )((void *)0)) {
            {
#line 332
            tmp___4 = cable_add_queue_item(cable, & cable->done);
#line 332
            c___0 = tmp___4;
#line 336
            (cable->done.data + c___0)->action = (enum __anonenum_action_29 )2;
#line 337
            (cable->done.data + c___0)->arg.xferred.len = len___0;
#line 338
            (cable->done.data + c___0)->arg.xferred.res = r;
#line 339
            (cable->done.data + c___0)->arg.xferred.out = p;
            }
#line 340
            if (len___0 > 0) {
              {
#line 340
              memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(out + bits),
                     (size_t )len___0);
              }
            }
          }
#line 342
          if (len___0 > 0) {
#line 342
            bits += len___0;
          }
#line 343
          if (bits > 0) {
#line 343
            tdo = (int )*(out + (bits - 1));
          }
        }
#line 345
        i ++;
#line 346
        if (i >= cable->todo.max_items) {
#line 346
          i = 0;
        }
#line 308
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 349
      cable->todo.next_item = i;
#line 350
      cable->todo.num_items -= n;
#line 352
      free((void *)in);
#line 353
      free((void *)out);
      }
    }
#line 203
    if (! (cable->todo.num_items > 0)) {
#line 203
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 357
  return;
}
}
#line 359 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/generic.c"
void generic_set_frequency(cable_t *cable , uint32_t new_frequency ) 
{ 
  double tolerance ;
  uint32_t loops ;
  uint32_t delay ;
  uint32_t frequency ;
  uint32_t i ;
  uint32_t new_delay ;
  long double start ;
  long double end ;
  long double real_frequency ;
  char *tmp ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 362
  if (new_frequency == 0U) {
#line 363
    cable->delay = (uint32_t )0;
#line 364
    cable->frequency = (uint32_t )0;
  } else {
#line 366
    tolerance = 0.1;
#line 367
    loops = (uint32_t )2048;
#line 368
    delay = cable->delay;
#line 369
    frequency = cable->frequency;
#line 371
    if ((double )new_frequency > (1.0 - tolerance) * (double )frequency) {
#line 371
      if ((double )new_frequency < (1.0 + tolerance) * (double )frequency) {
#line 373
        return;
      }
    }
    {
#line 375
    printf((char const   */* __restrict  */)"requested frequency %u, now calibrating delay loop\n",
           new_frequency);
    }
    {
#line 377
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 381
      cable->delay = delay;
#line 382
      start = frealtime();
#line 383
      i = (uint32_t )0;
      }
      {
#line 383
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 383
        if (! (i < loops)) {
#line 383
          goto while_break___0;
        }
        {
#line 384
        (*((cable->driver)->clock))(cable, 0, 0, 1);
#line 383
        i ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 386
      end = frealtime();
      }
#line 388
      if (end < start) {
        {
#line 389
        tmp = gettext("calibration error, wall clock is not monotonically increasing\n");
#line 389
        printf((char const   */* __restrict  */)tmp);
        }
#line 390
        goto while_break;
      }
#line 392
      if (end == start) {
#line 395
        loops *= 2U;
#line 396
        goto while_continue;
      }
      {
#line 398
      real_frequency = (long double )loops / (end - start);
#line 399
      printf((char const   */* __restrict  */)"new real frequency %Lg, delay %u\n",
             real_frequency, delay);
#line 402
      new_delay = (uint32_t )(((long double )delay * real_frequency) / (long double )new_frequency);
      }
#line 404
      if (real_frequency >= (long double )((1.0 - tolerance) * (double )new_frequency)) {
#line 405
        if (real_frequency <= (long double )((1.0 + tolerance) * (double )new_frequency)) {
#line 406
          frequency = (uint32_t )real_frequency;
#line 407
          goto while_break;
        }
#line 409
        if (new_delay > delay) {
#line 410
          delay = new_delay;
        } else {
#line 412
          delay ++;
        }
      } else {
#line 416
        if (delay == 0U) {
          {
#line 417
          printf((char const   */* __restrict  */)"operating without delay\n");
#line 418
          frequency = (uint32_t )real_frequency;
          }
#line 419
          goto while_break;
        }
#line 422
        if (new_delay < delay) {
#line 423
          delay = new_delay;
        } else
#line 425
        if (delay > 0U) {
#line 426
          delay --;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 431
    printf((char const   */* __restrict  */)"done\n");
#line 433
    cable->delay = delay;
#line 434
    cable->frequency = frequency;
    }
  }
#line 436
  return;
}
}
#line 54 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/ei012.c"
static int ei012_init(cable_t *cable ) 
{ 
  int data ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 59
  tmp = parport_open(cable->link.port);
  }
#line 59
  if (tmp) {
#line 60
    return (-1);
  }
  {
#line 62
  data = parport_get_data(cable->link.port);
  }
#line 62
  if (data < 0) {
    {
#line 63
    tmp___0 = parport_set_data(cable->link.port, (uint8_t )(1 << 4));
    }
#line 63
    if (tmp___0) {
#line 64
      return (-1);
    }
#line 65
    ((generic_params_t *)cable->params)->signals = 8;
  } else
#line 67
  if (data >> 4) {
#line 67
    ((generic_params_t *)cable->params)->signals = 8;
  } else {
#line 67
    ((generic_params_t *)cable->params)->signals = 0;
  }
#line 69
  return (0);
}
}
#line 72 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/ei012.c"
static void ei012_clock(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;
  int trst ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 76
  if (((generic_params_t *)cable->params)->signals & 8) {
#line 76
    tmp = 1;
  } else {
#line 76
    tmp = 0;
  }
#line 76
  trst = tmp;
#line 78
  if (tms) {
#line 78
    tms = 1;
  } else {
#line 78
    tms = 0;
  }
#line 79
  if (tdi) {
#line 79
    tdi = 1;
  } else {
#line 79
    tdi = 0;
  }
#line 81
  i = 0;
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    if (! (i < n)) {
#line 81
      goto while_break;
    }
    {
#line 82
    parport_set_data(cable->link.port, (uint8_t )(((trst << 4) | (tms << 2)) | (tdi << 1)));
#line 83
    cable_wait(cable);
#line 84
    parport_set_data(cable->link.port, (uint8_t )((((trst << 4) | 1) | (tms << 2)) | (tdi << 1)));
#line 85
    cable_wait(cable);
#line 81
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 88
  ((generic_params_t *)cable->params)->signals &= 8;
#line 89
  ((generic_params_t *)cable->params)->signals |= 2;
#line 90
  if (tms) {
#line 90
    tmp___0 = 4;
  } else {
#line 90
    tmp___0 = 0;
  }
#line 90
  ((generic_params_t *)cable->params)->signals |= tmp___0;
#line 91
  if (tdi) {
#line 91
    tmp___1 = 1;
  } else {
#line 91
    tmp___1 = 0;
  }
#line 91
  ((generic_params_t *)cable->params)->signals |= tmp___1;
#line 92
  return;
}
}
#line 94 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/ei012.c"
static int ei012_get_tdo(cable_t *cable ) 
{ 
  int trst ;
  int tmp ;
  int tmp___0 ;

  {
#line 97
  if (((generic_params_t *)cable->params)->signals & 8) {
#line 97
    tmp = 1;
  } else {
#line 97
    tmp = 0;
  }
  {
#line 97
  trst = tmp;
#line 99
  parport_set_data(cable->link.port, (uint8_t )(trst << 4));
#line 100
  ((generic_params_t *)cable->params)->signals &= -8;
#line 102
  cable_wait(cable);
#line 104
  tmp___0 = parport_get_status(cable->link.port);
  }
#line 104
  return ((tmp___0 >> 7) & 1);
}
}
#line 107 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/ei012.c"
static int ei012_set_signal(cable_t *cable , int mask , int val ) 
{ 
  int prev_sigs ;
  int data ;
  int sigs ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 110
  prev_sigs = ((generic_params_t *)cable->params)->signals;
#line 112
  mask &= 15;
#line 114
  if (mask != 0) {
#line 116
    data = 0;
#line 117
    sigs = (prev_sigs & ~ mask) | (val & mask);
#line 118
    if (sigs & 1) {
#line 118
      tmp = 1 << 1;
    } else {
#line 118
      tmp = 0;
    }
#line 118
    data |= tmp;
#line 119
    if (sigs & 2) {
#line 119
      tmp___0 = 1;
    } else {
#line 119
      tmp___0 = 0;
    }
#line 119
    data |= tmp___0;
#line 120
    if (sigs & 4) {
#line 120
      tmp___1 = 1 << 2;
    } else {
#line 120
      tmp___1 = 0;
    }
#line 120
    data |= tmp___1;
#line 121
    if (sigs & 8) {
#line 121
      tmp___2 = 1 << 4;
    } else {
#line 121
      tmp___2 = 0;
    }
    {
#line 121
    data |= tmp___2;
#line 122
    parport_set_data(cable->link.port, (uint8_t )data);
#line 123
    ((generic_params_t *)cable->params)->signals = sigs;
    }
  }
#line 126
  return (prev_sigs);
}
}
#line 129 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/ei012.c"
cable_driver_t ei012_cable_driver  = 
#line 129
     {"EI012", "ETC EI012 JTAG Cable", & generic_parport_connect, & generic_disconnect,
    & generic_parport_free, & ei012_init, & generic_parport_done, & generic_set_frequency,
    & ei012_clock, & ei012_get_tdo, & generic_transfer, & ei012_set_signal, & generic_get_signal,
    & generic_flush_one_by_one, & generic_parport_help};
#line 52 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/ea253.c"
static int ea253_init(cable_t *cable ) 
{ 
  int data ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 57
  tmp = parport_open(cable->link.port);
  }
#line 57
  if (tmp) {
#line 58
    return (-1);
  }
  {
#line 60
  data = parport_get_data(cable->link.port);
  }
#line 60
  if (data < 0) {
    {
#line 61
    tmp___0 = parport_set_data(cable->link.port, (uint8_t )(1 << 4));
    }
#line 61
    if (tmp___0) {
#line 62
      return (-1);
    }
#line 63
    ((generic_params_t *)cable->params)->signals = 8;
  } else
#line 65
  if (data >> 4) {
#line 65
    ((generic_params_t *)cable->params)->signals = 8;
  } else {
#line 65
    ((generic_params_t *)cable->params)->signals = 0;
  }
#line 67
  return (0);
}
}
#line 70 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/ea253.c"
static void ea253_clock(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;
  int trst ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 74
  if (((generic_params_t *)cable->params)->signals & 8) {
#line 74
    tmp = 1;
  } else {
#line 74
    tmp = 0;
  }
#line 74
  trst = tmp;
#line 76
  if (tms) {
#line 76
    tms = 1;
  } else {
#line 76
    tms = 0;
  }
#line 77
  if (tdi) {
#line 77
    tdi = 1;
  } else {
#line 77
    tdi = 0;
  }
#line 79
  i = 0;
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (! (i < n)) {
#line 79
      goto while_break;
    }
    {
#line 80
    parport_set_data(cable->link.port, (uint8_t )(((trst << 4) | (tms << 2)) | tdi));
#line 81
    cable_wait(cable);
#line 82
    parport_set_data(cable->link.port, (uint8_t )((((trst << 4) | (1 << 1)) | (tms << 2)) | tdi));
#line 83
    cable_wait(cable);
#line 79
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 86
  ((generic_params_t *)cable->params)->signals &= 8;
#line 87
  ((generic_params_t *)cable->params)->signals |= 2;
#line 88
  if (tms) {
#line 88
    tmp___0 = 4;
  } else {
#line 88
    tmp___0 = 0;
  }
#line 88
  ((generic_params_t *)cable->params)->signals |= tmp___0;
#line 89
  if (tdi) {
#line 89
    tmp___1 = 1;
  } else {
#line 89
    tmp___1 = 0;
  }
#line 89
  ((generic_params_t *)cable->params)->signals |= tmp___1;
#line 90
  return;
}
}
#line 92 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/ea253.c"
static int ea253_get_tdo(cable_t *cable ) 
{ 
  int trst ;
  int tmp ;
  int tmp___0 ;

  {
#line 95
  if (((generic_params_t *)cable->params)->signals & 8) {
#line 95
    tmp = 1;
  } else {
#line 95
    tmp = 0;
  }
  {
#line 95
  trst = tmp;
#line 97
  parport_set_data(cable->link.port, (uint8_t )(trst << 4));
#line 98
  ((generic_params_t *)cable->params)->signals &= -8;
#line 100
  cable_wait(cable);
#line 102
  tmp___0 = parport_get_status(cable->link.port);
  }
#line 102
  return ((tmp___0 >> 4) & 1);
}
}
#line 105 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/ea253.c"
static int ea253_set_signal(cable_t *cable , int mask , int val ) 
{ 
  int prev_sigs ;
  int data ;
  int sigs ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 108
  prev_sigs = ((generic_params_t *)cable->params)->signals;
#line 110
  mask &= 15;
#line 112
  if (mask != 0) {
#line 114
    data = 0;
#line 115
    sigs = (prev_sigs & ~ mask) | (val & mask);
#line 116
    if (sigs & 1) {
#line 116
      tmp = 1;
    } else {
#line 116
      tmp = 0;
    }
#line 116
    data |= tmp;
#line 117
    if (sigs & 2) {
#line 117
      tmp___0 = 1 << 1;
    } else {
#line 117
      tmp___0 = 0;
    }
#line 117
    data |= tmp___0;
#line 118
    if (sigs & 4) {
#line 118
      tmp___1 = 1 << 2;
    } else {
#line 118
      tmp___1 = 0;
    }
#line 118
    data |= tmp___1;
#line 119
    if (sigs & 8) {
#line 119
      tmp___2 = 1 << 4;
    } else {
#line 119
      tmp___2 = 0;
    }
    {
#line 119
    data |= tmp___2;
#line 120
    parport_set_data(cable->link.port, (uint8_t )data);
#line 121
    ((generic_params_t *)cable->params)->signals = sigs;
    }
  }
#line 124
  return (prev_sigs);
}
}
#line 127 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/ea253.c"
cable_driver_t ea253_cable_driver  = 
#line 127
     {"EA253", "ETC EA253 JTAG Cable", & generic_parport_connect, & generic_disconnect,
    & generic_parport_free, & ea253_init, & generic_parport_done, & generic_set_frequency,
    & ea253_clock, & ea253_get_tdo, & generic_transfer, & ea253_set_signal, & generic_get_signal,
    & generic_flush_one_by_one, & generic_parport_help};
#line 59 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/dlc5.c"
static int dlc5_init(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 62
  tmp = parport_open(cable->link.port);
  }
#line 62
  if (tmp) {
#line 63
    return (-1);
  }
#line 65
  ((generic_params_t *)cable->params)->signals = 8;
#line 67
  return (0);
}
}
#line 70 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/dlc5.c"
static void dlc5_clock(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 75
  if (tms) {
#line 75
    tms = 1;
  } else {
#line 75
    tms = 0;
  }
#line 76
  if (tdi) {
#line 76
    tdi = 1;
  } else {
#line 76
    tdi = 0;
  }
#line 78
  i = 0;
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    if (! (i < n)) {
#line 78
      goto while_break;
    }
    {
#line 79
    parport_set_data(cable->link.port, (uint8_t )(((1 << 4) | (tms << 2)) | tdi));
#line 80
    cable_wait(cable);
#line 81
    parport_set_data(cable->link.port, (uint8_t )((((1 << 4) | (1 << 1)) | (tms << 2)) | tdi));
#line 82
    cable_wait(cable);
#line 78
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  ((generic_params_t *)cable->params)->signals &= 8;
#line 86
  ((generic_params_t *)cable->params)->signals |= 2;
#line 87
  if (tms) {
#line 87
    tmp = 4;
  } else {
#line 87
    tmp = 0;
  }
#line 87
  ((generic_params_t *)cable->params)->signals |= tmp;
#line 88
  if (tdi) {
#line 88
    tmp___0 = 1;
  } else {
#line 88
    tmp___0 = 0;
  }
#line 88
  ((generic_params_t *)cable->params)->signals |= tmp___0;
#line 89
  return;
}
}
#line 91 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/dlc5.c"
static int dlc5_get_tdo(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 94
  parport_set_data(cable->link.port, (uint8_t )(1 << 4));
#line 95
  ((generic_params_t *)cable->params)->signals &= -8;
#line 97
  cable_wait(cable);
#line 99
  tmp = parport_get_status(cable->link.port);
  }
#line 99
  return ((tmp >> 4) & 1);
}
}
#line 102 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/dlc5.c"
static int dlc5_set_signal(cable_t *cable , int mask , int val ) 
{ 
  int prev_sigs ;
  int data ;
  int sigs ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 105
  prev_sigs = ((generic_params_t *)cable->params)->signals;
#line 107
  mask &= 7;
#line 109
  if (mask != 0) {
#line 111
    data = 0;
#line 112
    sigs = (prev_sigs & ~ mask) | (val & mask);
#line 113
    if (sigs & 1) {
#line 113
      tmp = 1;
    } else {
#line 113
      tmp = 0;
    }
#line 113
    data |= tmp;
#line 114
    if (sigs & 2) {
#line 114
      tmp___0 = 1 << 1;
    } else {
#line 114
      tmp___0 = 0;
    }
#line 114
    data |= tmp___0;
#line 115
    if (sigs & 4) {
#line 115
      tmp___1 = 1 << 2;
    } else {
#line 115
      tmp___1 = 0;
    }
    {
#line 115
    data |= tmp___1;
#line 116
    parport_set_data(cable->link.port, (uint8_t )((1 << 4) | data));
#line 117
    ((generic_params_t *)cable->params)->signals = sigs;
    }
  }
#line 120
  return (prev_sigs);
}
}
#line 123 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/dlc5.c"
cable_driver_t dlc5_cable_driver  = 
#line 123
     {"DLC5", "Xilinx DLC5 JTAG Parallel Cable III", & generic_parport_connect, & generic_disconnect,
    & generic_parport_free, & dlc5_init, & generic_parport_done, & generic_set_frequency,
    & dlc5_clock, & dlc5_get_tdo, & generic_transfer, & dlc5_set_signal, & generic_get_signal,
    & generic_flush_one_by_one, & generic_parport_help};
#line 54 "../../include/jtag.h"
int detect_register_size(chain_t *chain ) ;
#line 55
void discovery(chain_t *chain ) ;
#line 43 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/discovery.c"
int detect_register_size(chain_t *chain ) 
{ 
  int len ;
  tap_register *rz ;
  tap_register *rout ;
  tap_register *rpat ;
  int tdo ;
  int tdo_stuck ;
  int p ;
  int ok ;
  tap_register *tmp ;
  tap_register *tmp___0 ;
  tap_register *tmp___1 ;
  int i ;
  char const   *s ;
  int tmp___2 ;
  char *tmp___3 ;
  char *__cil_tmp17 ;

  {
#line 52
  tdo_stuck = -2;
#line 54
  len = 1;
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
#line 54
    if (! (len <= 1024)) {
#line 54
      goto while_break;
    }
    {
#line 56
    ok = 0;
#line 58
    tmp = register_alloc(len);
#line 58
    rz = register_fill(tmp, 0);
#line 59
    rout = register_alloc(8 + len);
#line 60
    tmp___0 = register_alloc(8 + len);
#line 60
    tmp___1 = register_fill(tmp___0, 0);
#line 60
    rpat = register_inc(tmp___1);
#line 62
    p = 1;
    }
    {
#line 62
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 62
      if (! (p < 1 << 8)) {
#line 62
        goto while_break___0;
      }
      {
#line 65
      ok = 0;
#line 67
      s = register_get_string((tap_register const   *)rpat);
      }
      {
#line 68
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 68
        if (! *s) {
#line 68
          goto while_break___1;
        }
#line 69
        s ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 71
      i = 0;
      {
#line 71
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 71
        if (! (i < 1)) {
#line 71
          goto while_break___2;
        }
        {
#line 72
        tap_shift_register(chain, (tap_register const   *)rz, (tap_register *)((void *)0),
                           0);
#line 73
        tap_shift_register(chain, (tap_register const   *)rpat, rout, 0);
#line 79
        tdo = register_all_bits_same_value((tap_register const   *)rout);
        }
#line 80
        if (tdo_stuck == -2) {
#line 80
          tdo_stuck = tdo;
        }
#line 81
        if (tdo_stuck != tdo) {
#line 81
          tdo_stuck = -1;
        }
        {
#line 83
        register_shift_right(rout, len);
#line 84
        tmp___2 = register_compare((tap_register const   *)rpat, (tap_register const   *)rout);
        }
#line 84
        if (tmp___2 == 0) {
#line 85
          ok ++;
        }
#line 71
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 90
      if (100 * ok < 100) {
#line 91
        ok = 0;
#line 92
        goto while_break___0;
      }
      {
#line 95
      register_inc(rpat);
#line 62
      p ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 98
    register_free(rz);
#line 99
    register_free(rout);
#line 100
    register_free(rpat);
    }
#line 102
    if (ok) {
#line 103
      return (len);
    }
#line 54
    len ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 106
  if (tdo_stuck >= 0) {
    {
#line 108
    tmp___3 = gettext("Warning: TDO seems to be stuck at %d\n");
#line 108
    printf((char const   */* __restrict  */)tmp___3, tdo_stuck);
    }
  }
#line 111
  return (-1);
}
}
#line 114 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/discovery.c"
void jtag_reset(chain_t *chain ) 
{ 


  {
  {
#line 117
  chain_set_trst(chain, 0);
#line 118
  chain_set_trst(chain, 1);
#line 120
  tap_reset(chain);
  }
#line 121
  return;
}
}
#line 123 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/discovery.c"
void discovery(chain_t *chain ) 
{ 
  int irlen ;
  tap_register *ir ;
  tap_register *irz ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  tap_register *tmp___2 ;
  char *tmp___3 ;
  int rs ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
  {
#line 131
  jtag_reset(chain);
#line 133
  tmp = gettext("Detecting IR length ... ");
#line 133
  printf((char const   */* __restrict  */)tmp);
#line 134
  fflush(stdout);
#line 136
  tap_capture_ir(chain);
#line 137
  irlen = detect_register_size(chain);
#line 139
  tmp___0 = gettext("%d\n");
#line 139
  printf((char const   */* __restrict  */)tmp___0, irlen);
  }
#line 141
  if (irlen < 1) {
    {
#line 142
    tmp___1 = gettext("Error: Invalid IR length!\n");
#line 142
    printf((char const   */* __restrict  */)tmp___1);
    }
#line 143
    return;
  }
  {
#line 147
  tmp___2 = register_alloc(irlen);
#line 147
  ir = register_fill(tmp___2, 1);
#line 148
  irz = register_duplicate((tap_register const   *)ir);
  }
#line 150
  if (! ir) {
    {
#line 151
    register_free(ir);
#line 152
    register_free(irz);
#line 153
    tmp___3 = gettext("Error: Out of memory!\n");
#line 153
    printf((char const   */* __restrict  */)tmp___3);
    }
#line 154
    return;
  } else
#line 150
  if (! irz) {
    {
#line 151
    register_free(ir);
#line 152
    register_free(irz);
#line 153
    tmp___3 = gettext("Error: Out of memory!\n");
#line 153
    printf((char const   */* __restrict  */)tmp___3);
    }
#line 154
    return;
  }
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 160
    jtag_reset(chain);
#line 162
    tap_capture_ir(chain);
#line 163
    tap_shift_register(chain, (tap_register const   *)ir, (tap_register *)((void *)0),
                       1);
#line 165
    tmp___4 = register_get_string((tap_register const   *)ir);
#line 165
    tmp___5 = gettext("Detecting DR length for IR %s ... ");
#line 165
    printf((char const   */* __restrict  */)tmp___5, tmp___4);
#line 166
    fflush(stdout);
#line 168
    tap_capture_dr(chain);
#line 169
    rs = detect_register_size(chain);
#line 171
    tmp___6 = gettext("%d\n");
#line 171
    printf((char const   */* __restrict  */)tmp___6, rs);
#line 173
    register_inc(ir);
#line 174
    tmp___7 = register_compare((tap_register const   *)ir, (tap_register const   *)irz);
    }
#line 174
    if (tmp___7 == 0) {
#line 175
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 177
  register_free(ir);
#line 178
  register_free(irz);
  }
#line 179
  return;
}
}
#line 766 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int abs(int __x )  __attribute__((__const__)) ;
#line 33 "/usr/include/sys/io.h"
extern  __attribute__((__nothrow__)) int ioperm(unsigned long __from , unsigned long __num ,
                                                int __turn_on ) ;
#line 39
extern  __attribute__((__nothrow__)) int iopl(int __level ) ;
#line 43 "/usr/include/sys/io.h"
__inline static unsigned char inb(unsigned short __port ) 
{ 
  unsigned char _v ;

  {
#line 48
  __asm__  volatile   ("inb %w1,%0": "=a" (_v): "Nd" (__port));
#line 49
  return (_v);
}
}
#line 96 "/usr/include/sys/io.h"
__inline static void outb(unsigned char __value , unsigned short __port ) 
{ 


  {
#line 99
  __asm__  volatile   ("outb %b0,%w1": : "a" (__value), "Nd" (__port));
#line 100
  return;
}
}
#line 119 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/parport/direct.c"
static port_node_t *ports___0  =    (port_node_t *)((void *)0);
#line 125 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/parport/direct.c"
static parport_t *direct_parport_alloc(unsigned int port ) 
{ 
  direct_params_t *params ;
  void *tmp ;
  parport_t *parport ;
  void *tmp___0 ;
  port_node_t *node ;
  void *tmp___1 ;

  {
  {
#line 128
  tmp = malloc((size_t )sizeof(*params));
#line 128
  params = (direct_params_t *)tmp;
#line 129
  tmp___0 = malloc((size_t )sizeof(*parport));
#line 129
  parport = (parport_t *)tmp___0;
#line 130
  tmp___1 = malloc((size_t )sizeof(*node));
#line 130
  node = (port_node_t *)tmp___1;
  }
#line 149
  if (! node) {
    {
#line 153
    free((void *)node);
#line 154
    free((void *)parport);
#line 155
    free((void *)params);
    }
#line 156
    return ((parport_t *)((void *)0));
  } else
#line 149
  if (! parport) {
    {
#line 153
    free((void *)node);
#line 154
    free((void *)parport);
#line 155
    free((void *)params);
    }
#line 156
    return ((parport_t *)((void *)0));
  } else
#line 149
  if (! params) {
    {
#line 153
    free((void *)node);
#line 154
    free((void *)parport);
#line 155
    free((void *)params);
    }
#line 156
    return ((parport_t *)((void *)0));
  }
#line 159
  params->port = port;
#line 161
  parport->params = (void *)params;
#line 162
  parport->driver = & direct_parport_driver;
#line 163
  parport->cable = (cable_t *)((void *)0);
#line 165
  node->port = parport;
#line 166
  node->next = ports___0;
#line 168
  ports___0 = node;
#line 170
  return (parport);
}
}
#line 173 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/parport/direct.c"
static void direct_parport_free(parport_t *port ) 
{ 
  port_node_t **prev ;
  port_node_t *pn ;

  {
#line 178
  prev = & ports___0;
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
#line 178
    if (! *prev) {
#line 178
      goto while_break;
    }
#line 179
    if ((unsigned long )(*prev)->port == (unsigned long )port) {
#line 180
      goto while_break;
    }
#line 178
    prev = & (*prev)->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 182
  if (*prev) {
    {
#line 183
    pn = *prev;
#line 184
    *prev = pn->next;
#line 185
    free((void *)pn);
    }
  }
  {
#line 188
  free(port->params);
#line 189
  free((void *)port);
  }
#line 195
  return;
}
}
#line 197 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/parport/direct.c"
parport_t *direct_connect(char const   **par , int parnum ) 
{ 
  long port_scan_val ;
  unsigned int port ;
  port_node_t *pn ;
  parport_t *parport ;
  char *tmp ;
  char *tmp___0 ;
  unsigned int aport ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 202
  pn = ports___0;
#line 205
  if (parnum != 1) {
    {
#line 206
    tmp = gettext("Syntax error!\n");
#line 206
    printf((char const   */* __restrict  */)tmp);
    }
#line 207
    return ((parport_t *)((void *)0));
  }
  {
#line 210
  port_scan_val = strtol((char const   */* __restrict  */)*(par + 0), (char **/* __restrict  */)((void *)0),
                         0);
  }
#line 212
  if (port_scan_val < 0L) {
    {
#line 213
    tmp___0 = gettext("Invalid port address!\n");
#line 213
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 214
    return ((parport_t *)((void *)0));
  } else
#line 212
  if (port_scan_val + 3L > 65535L) {
    {
#line 213
    tmp___0 = gettext("Invalid port address!\n");
#line 213
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 214
    return ((parport_t *)((void *)0));
  }
#line 217
  port = (unsigned int )port_scan_val;
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;
#line 219
    if (! pn) {
#line 219
      goto while_break;
    }
#line 220
    pn = ports___0;
    {
#line 220
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 220
      if (! pn) {
#line 220
        goto while_break___0;
      }
      {
#line 223
      aport = ((direct_params_t *)(pn->port)->params)->port;
#line 224
      tmp___3 = abs((int )(aport - port));
      }
#line 224
      if (tmp___3 < 3) {
        {
#line 225
        tmp___1 = gettext((((pn->port)->cable)->driver)->description);
#line 225
        tmp___2 = gettext("Disconnecting %s from parallel port at 0x%x\n");
#line 225
        printf((char const   */* __restrict  */)tmp___2, tmp___1, aport);
#line 226
        (*((((pn->port)->cable)->driver)->disconnect))((pn->port)->cable);
        }
#line 227
        goto while_break___0;
      }
#line 220
      pn = pn->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 231
  tmp___4 = gettext("Initializing parallel port at 0x%x\n");
#line 231
  printf((char const   */* __restrict  */)tmp___4, port);
#line 233
  parport = direct_parport_alloc(port);
  }
#line 234
  if (! parport) {
    {
#line 235
    tmp___5 = gettext("%s(%d) Out of memory.\n");
#line 235
    printf((char const   */* __restrict  */)tmp___5, "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/parport/direct.c",
           235);
    }
#line 236
    return ((parport_t *)((void *)0));
  }
#line 239
  return (parport);
}
}
#line 242 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/parport/direct.c"
static int direct_open(parport_t *parport ) 
{ 
  unsigned int port ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 248
  port = ((direct_params_t *)parport->params)->port;
#line 249
  if (port + 3U <= 1024U) {
    {
#line 249
    tmp = ioperm((unsigned long )port, 3UL, 1);
    }
#line 249
    if (tmp) {
#line 249
      tmp___1 = 1;
    } else {
#line 249
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 249
  if (port + 3U > 1024U) {
    {
#line 249
    tmp___0 = iopl(3);
    }
#line 249
    if (tmp___0) {
#line 249
      tmp___1 = 1;
    } else {
#line 249
      tmp___1 = 0;
    }
  } else {
#line 249
    tmp___1 = 0;
  }
#line 249
  return (tmp___1);
}
}
#line 253 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/parport/direct.c"
static int direct_close(parport_t *parport ) 
{ 
  unsigned int port ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 259
  port = ((direct_params_t *)parport->params)->port;
#line 260
  if (port + 3U <= 1024U) {
    {
#line 260
    tmp = ioperm((unsigned long )port, 3UL, 0);
#line 260
    tmp___1 = tmp;
    }
  } else {
    {
#line 260
    tmp___0 = iopl(0);
#line 260
    tmp___1 = tmp___0;
    }
  }
#line 260
  return (tmp___1);
}
}
#line 264 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/parport/direct.c"
static int direct_set_data(parport_t *parport , uint8_t data ) 
{ 
  unsigned int port ;

  {
  {
#line 267
  port = ((direct_params_t *)parport->params)->port;
#line 268
  outb(data, (unsigned short )port);
  }
#line 269
  return (0);
}
}
#line 272 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/parport/direct.c"
static int direct_get_data(parport_t *parport ) 
{ 
  unsigned int port ;
  unsigned char tmp ;

  {
  {
#line 275
  port = ((direct_params_t *)parport->params)->port;
#line 276
  tmp = inb((unsigned short )port);
  }
#line 276
  return ((int )tmp);
}
}
#line 279 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/parport/direct.c"
static int direct_get_status(parport_t *parport ) 
{ 
  unsigned int port ;
  unsigned char tmp ;

  {
  {
#line 282
  port = ((direct_params_t *)parport->params)->port;
#line 283
  tmp = inb((unsigned short )(port + 1U));
  }
#line 283
  return ((int )tmp ^ 128);
}
}
#line 286 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/parport/direct.c"
static int direct_set_control(parport_t *parport , uint8_t data ) 
{ 
  unsigned int port ;

  {
  {
#line 289
  port = ((direct_params_t *)parport->params)->port;
#line 290
  outb((unsigned char )((int )data ^ 11), (unsigned short )(port + 2U));
  }
#line 291
  return (0);
}
}
#line 294 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/parport/direct.c"
parport_driver_t direct_parport_driver  = 
#line 294
     {"parallel", & direct_connect, & direct_parport_free, & direct_open, & direct_close,
    & direct_set_data, & direct_get_data, & direct_get_status, & direct_set_control};
#line 604 "/usr/include/stdio.h"
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 260 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strrchr)(char const   *__s ,
                                                                                      int __c )  __attribute__((__pure__)) ;
#line 312
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strpbrk)(char const   *__s ,
                                                                                        char const   *__accept )  __attribute__((__pure__)) ;
#line 57 "../../include/part.h"
part_t *part_alloc(tap_register const   *id ) ;
#line 75
parts_t *parts_alloc(void) ;
#line 76
void parts_free(parts_t *ps ) ;
#line 77
int parts_add_part(parts_t *ps , part_t *p ) ;
#line 52 "../../include/jtag.h"
int detect_parts(chain_t *chain , char const   *db_path ) ;
#line 53
int manual_add(chain_t *chain , int instr_len ) ;
#line 50 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/detect.c"
static int find_record(char *filename , tap_register *key , struct id_record *idr ) 
{ 
  FILE *file ;
  tap_register *tr ;
  int r ;
  char *tmp ;
  char *p ;
  char *s ;
  char line[1024] ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  unsigned short const   **tmp___7 ;
  unsigned short const   **tmp___8 ;
  char *tmp___9 ;
  size_t tmp___10 ;
  unsigned short const   **tmp___11 ;
  size_t tmp___12 ;
  void *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
  {
#line 55
  r = 0;
#line 57
  file = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 58
  if (! file) {
    {
#line 59
    tmp = gettext("Cannot open %s\n");
#line 59
    printf((char const   */* __restrict  */)tmp, filename);
    }
#line 60
    return (0);
  }
  {
#line 63
  tr = register_alloc(key->len);
  }
  {
#line 65
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 70
    tmp___0 = fgets((char */* __restrict  */)(line), 1024, (FILE */* __restrict  */)file);
    }
#line 70
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 71
      goto while_break;
    }
    {
#line 74
    p = strpbrk((char const   *)(line), "#\n");
    }
#line 75
    if (p) {
#line 76
      *p = (char )'\000';
    }
#line 78
    p = line;
    {
#line 81
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 81
      if (*p) {
        {
#line 81
        tmp___1 = __ctype_b_loc();
        }
#line 81
        if (! ((int const   )*(*tmp___1 + (int )*p) & 8192)) {
#line 81
          goto while_break___0;
        }
      } else {
#line 81
        goto while_break___0;
      }
#line 82
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 85
    s = strchr((char const   *)p, '\000');
    }
    {
#line 86
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 86
      if (! ((unsigned long )s != (unsigned long )p)) {
#line 86
        goto while_break___1;
      }
      {
#line 87
      tmp___2 = __ctype_b_loc();
#line 87
      s --;
      }
#line 87
      if (! ((int const   )*(*tmp___2 + (int )*s) & 8192)) {
#line 88
        goto while_break___1;
      }
#line 89
      *s = (char )'\000';
    }
    while_break___1: /* CIL Label */ ;
    }
#line 93
    if (! *p) {
#line 94
      goto __Cont;
    }
#line 97
    s = p;
    {
#line 98
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 98
      if (*s) {
        {
#line 98
        tmp___3 = __ctype_b_loc();
        }
#line 98
        if ((int const   )*(*tmp___3 + (int )*s) & 8192) {
#line 98
          goto while_break___2;
        }
      } else {
#line 98
        goto while_break___2;
      }
#line 99
      s ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 100
    if (*s) {
#line 101
      tmp___4 = s;
#line 101
      s ++;
#line 101
      *tmp___4 = (char )'\000';
    }
    {
#line 104
    tmp___5 = strlen((char const   *)p);
    }
#line 104
    if (tmp___5 != (size_t )key->len) {
#line 105
      goto __Cont;
    }
    {
#line 108
    register_init(tr, (char const   *)p);
#line 109
    tmp___6 = register_compare((tap_register const   *)tr, (tap_register const   *)key);
    }
#line 109
    if (tmp___6) {
#line 110
      goto __Cont;
    }
#line 113
    p = s;
    {
#line 116
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 116
      if (*p) {
        {
#line 116
        tmp___7 = __ctype_b_loc();
        }
#line 116
        if (! ((int const   )*(*tmp___7 + (int )*p) & 8192)) {
#line 116
          goto while_break___3;
        }
      } else {
#line 116
        goto while_break___3;
      }
#line 117
      p ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 120
    if (! *p) {
#line 121
      goto __Cont;
    }
#line 124
    s = p;
    {
#line 125
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 125
      if (*s) {
        {
#line 125
        tmp___8 = __ctype_b_loc();
        }
#line 125
        if ((int const   )*(*tmp___8 + (int )*s) & 8192) {
#line 125
          goto while_break___4;
        }
      } else {
#line 125
        goto while_break___4;
      }
#line 126
      s ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 127
    if (*s) {
#line 128
      tmp___9 = s;
#line 128
      s ++;
#line 128
      *tmp___9 = (char )'\000';
    }
    {
#line 131
    tmp___10 = strlen((char const   *)p);
    }
#line 131
    if ((unsigned long )tmp___10 >= sizeof(idr->name)) {
#line 132
      goto __Cont;
    }
    {
#line 135
    strcpy((char */* __restrict  */)(idr->name), (char const   */* __restrict  */)p);
#line 138
    p = s;
    }
    {
#line 141
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 141
      if (*p) {
        {
#line 141
        tmp___11 = __ctype_b_loc();
        }
#line 141
        if (! ((int const   )*(*tmp___11 + (int )*p) & 8192)) {
#line 141
          goto while_break___5;
        }
      } else {
#line 141
        goto while_break___5;
      }
#line 142
      p ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 145
    if (! *p) {
#line 146
      goto __Cont;
    }
    {
#line 149
    tmp___12 = strlen((char const   *)p);
    }
#line 149
    if ((unsigned long )tmp___12 >= sizeof(idr->fullname)) {
#line 150
      goto __Cont;
    }
    {
#line 153
    strcpy((char */* __restrict  */)(idr->fullname), (char const   */* __restrict  */)p);
#line 155
    r = 1;
    }
#line 156
    goto while_break;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 159
  fclose(file);
#line 161
  register_free(tr);
  }
#line 163
  return (r);
}
}
#line 166 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/detect.c"
uint64_t bits_to_uint64(tap_register *t ) 
{ 
  int i ;
  uint64_t l ;
  uint64_t b ;

  {
#line 171
  l = (uint64_t )0;
#line 171
  b = (uint64_t )1;
#line 172
  i = 0;
  {
#line 172
  while (1) {
    while_continue: /* CIL Label */ ;
#line 172
    if (! (i < t->len)) {
#line 172
      goto while_break;
    }
#line 173
    if ((int )*(t->data + i) & 1) {
#line 173
      l |= b;
    }
#line 174
    b <<= 1;
#line 172
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 176
  return (l);
}
}
#line 180 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/detect.c"
int detect_parts(chain_t *chain , char const   *db_path ) 
{ 
  int irlen ;
  tap_register *ir ;
  int chlen ;
  tap_register *one ;
  tap_register *ones ;
  tap_register *br ;
  tap_register *id ;
  parts_t *ps ;
  int i ;
  char data_path[1024] ;
  char *cmd[3] ;
  char manufacturer[26] ;
  char partname[21] ;
  char stepping[9] ;
  char *tmp ;
  tap_register *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  tap_register *tmp___4 ;
  tap_register *tmp___5 ;
  char *tmp___6 ;
  part_t *part ;
  tap_register *did ;
  tap_register *key ;
  struct id_record idr ;
  char *p ;
  int tmp___7 ;
  uint64_t tmp___8 ;
  char const   *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  size_t tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  size_t tmp___21 ;
  char *tmp___22 ;
  int tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  size_t tmp___26 ;
  char *tmp___27 ;
  char const   *tmp___28 ;
  int tmp___29 ;
  char *tmp___30 ;
  int tmp___31 ;
  void *__cil_tmp55 ;
  void *__cil_tmp56 ;
  void *__cil_tmp57 ;
  void *__cil_tmp58 ;
  void *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;

  {
  {
#line 194
  cmd[0] = (char *)"include";
#line 194
  cmd[1] = data_path;
#line 194
  cmd[2] = (char *)((void *)0);
#line 200
  tap_reset(chain);
#line 201
  tap_capture_ir(chain);
#line 202
  irlen = detect_register_size(chain);
  }
#line 203
  if (irlen < 1) {
#line 204
    return (0);
  }
  {
#line 206
  tmp = gettext("IR length: %d\n");
#line 206
  printf((char const   */* __restrict  */)tmp, irlen);
#line 207
  chain->total_instr_len = irlen;
#line 210
  tmp___0 = register_alloc(irlen);
#line 210
  ir = register_fill(tmp___0, 1);
  }
#line 211
  if ((unsigned long )ir == (unsigned long )((void *)0)) {
    {
#line 212
    tmp___1 = gettext("out of memory\n");
#line 212
    printf((char const   */* __restrict  */)tmp___1);
    }
#line 213
    return (0);
  }
  {
#line 216
  tap_shift_register(chain, (tap_register const   *)ir, (tap_register *)((void *)0),
                     1);
#line 217
  register_free(ir);
#line 220
  tap_capture_dr(chain);
#line 221
  chlen = detect_register_size(chain);
  }
#line 222
  if (chlen < 1) {
    {
#line 223
    tmp___2 = gettext("Unable to detect JTAG chain length\n");
#line 223
    printf((char const   */* __restrict  */)tmp___2);
    }
#line 224
    return (0);
  }
  {
#line 226
  tmp___3 = gettext("Chain length: %d\n");
#line 226
  printf((char const   */* __restrict  */)tmp___3, chlen);
#line 229
  tmp___4 = register_alloc(1);
#line 229
  one = register_fill(tmp___4, 1);
#line 230
  tmp___5 = register_alloc(31);
#line 230
  ones = register_fill(tmp___5, 1);
#line 231
  br = register_alloc(1);
#line 232
  id = register_alloc(32);
#line 233
  ps = parts_alloc();
  }
#line 234
  if (! one) {
#line 234
    goto _L;
  } else
#line 234
  if (! ones) {
#line 234
    goto _L;
  } else
#line 234
  if (! br) {
#line 234
    goto _L;
  } else
#line 234
  if (! id) {
#line 234
    goto _L;
  } else
#line 234
  if (! ps) {
    _L: /* CIL Label */ 
    {
#line 235
    tmp___6 = gettext("out of memory\n");
#line 235
    printf((char const   */* __restrict  */)tmp___6);
#line 237
    register_free(one);
#line 238
    register_free(ones);
#line 239
    register_free(br);
#line 240
    register_free(id);
#line 241
    parts_free(ps);
    }
#line 242
    return (0);
  }
  {
#line 244
  chain->parts = ps;
#line 245
  chain->active_part = 0;
#line 248
  tap_reset(chain);
#line 249
  tap_capture_dr(chain);
#line 251
  i = 0;
  }
  {
#line 251
  while (1) {
    while_continue: /* CIL Label */ ;
#line 251
    if (! (i < chlen)) {
#line 251
      goto while_break;
    }
    {
#line 253
    did = br;
#line 258
    tap_shift_register(chain, (tap_register const   *)one, br, 0);
#line 259
    tmp___7 = register_compare((tap_register const   *)one, (tap_register const   *)br);
    }
#line 259
    if (tmp___7 == 0) {
      {
#line 261
      tap_shift_register(chain, (tap_register const   *)ones, id, 0);
#line 262
      register_shift_left(id, 1);
#line 263
      *(id->data + 0) = (char)1;
#line 264
      did = id;
      }
    }
    {
#line 267
    tmp___8 = bits_to_uint64(did);
#line 267
    tmp___9 = register_get_string((tap_register const   *)did);
#line 267
    tmp___10 = gettext("Device Id: %s (0x%016llX)\n");
#line 267
    printf((char const   */* __restrict  */)tmp___10, tmp___9, tmp___8);
#line 269
    part = part_alloc((tap_register const   *)did);
    }
#line 270
    if ((unsigned long )part == (unsigned long )((void *)0)) {
      {
#line 271
      tmp___11 = gettext("Out of memory\n");
#line 271
      printf((char const   */* __restrict  */)tmp___11);
      }
#line 272
      goto while_break;
    }
    {
#line 274
    parts_add_part(ps, part);
    }
#line 276
    if ((unsigned long )did == (unsigned long )br) {
#line 277
      goto __Cont;
    }
    {
#line 279
    chain->active_part = ps->len - 1;
#line 282
    tmp___28 = register_get_string((tap_register const   *)did);
#line 282
    tmp___29 = bsdl_scan_files(chain, tmp___28, (((1 << 4) | (1 << 6)) | (1 << 7)) | (1 << 3));
    }
#line 282
    if (tmp___29 <= 0) {
      {
#line 288
      strcpy((char */* __restrict  */)(data_path), (char const   */* __restrict  */)db_path);
#line 291
      strcat((char */* __restrict  */)(data_path), (char const   */* __restrict  */)"/MANUFACTURERS");
#line 293
      key = register_alloc(11);
#line 294
      memcpy((void */* __restrict  */)key->data, (void const   */* __restrict  */)(id->data + 1),
             (size_t )key->len);
#line 295
      tmp___13 = find_record(data_path, key, & idr);
      }
#line 295
      if (! tmp___13) {
        {
#line 296
        tmp___12 = gettext("  Unknown manufacturer!\n");
#line 296
        printf((char const   */* __restrict  */)tmp___12);
#line 297
        register_free(key);
        }
#line 298
        goto __Cont;
      }
      {
#line 300
      register_free(key);
#line 302
      tmp___14 = gettext("  Manufacturer: %s\n");
#line 302
      printf((char const   */* __restrict  */)tmp___14, idr.fullname);
#line 303
      tmp___16 = strlen((char const   *)(idr.fullname));
      }
#line 303
      if (tmp___16 > 25U) {
        {
#line 304
        tmp___15 = gettext("Warning: Manufacturer too long\n");
#line 304
        printf((char const   */* __restrict  */)tmp___15);
        }
      }
      {
#line 305
      strncpy((char */* __restrict  */)(manufacturer), (char const   */* __restrict  */)(idr.fullname),
              (size_t )25);
#line 306
      manufacturer[25] = (char )'\000';
#line 309
      p = strrchr((char const   *)(data_path), '/');
      }
#line 310
      if (p) {
#line 311
        *(p + 1) = (char )'\000';
      } else {
#line 313
        data_path[0] = (char )'\000';
      }
      {
#line 314
      strcat((char */* __restrict  */)(data_path), (char const   */* __restrict  */)(idr.name));
#line 315
      strcat((char */* __restrict  */)(data_path), (char const   */* __restrict  */)"/PARTS");
#line 317
      key = register_alloc(16);
#line 318
      memcpy((void */* __restrict  */)key->data, (void const   */* __restrict  */)(id->data + 12),
             (size_t )key->len);
#line 319
      tmp___18 = find_record(data_path, key, & idr);
      }
#line 319
      if (! tmp___18) {
        {
#line 320
        tmp___17 = gettext("  Unknown part!\n");
#line 320
        printf((char const   */* __restrict  */)tmp___17);
#line 321
        register_free(key);
        }
#line 322
        goto __Cont;
      }
      {
#line 324
      register_free(key);
#line 326
      tmp___19 = gettext("  Part(%d):         %s\n");
#line 326
      printf((char const   */* __restrict  */)tmp___19, chain->active_part, idr.fullname);
#line 327
      tmp___21 = strlen((char const   *)(idr.fullname));
      }
#line 327
      if (tmp___21 > 20U) {
        {
#line 328
        tmp___20 = gettext("Warning: Part too long\n");
#line 328
        printf((char const   */* __restrict  */)tmp___20);
        }
      }
      {
#line 329
      strncpy((char */* __restrict  */)(partname), (char const   */* __restrict  */)(idr.fullname),
              (size_t )20);
#line 330
      partname[20] = (char )'\000';
#line 333
      p = strrchr((char const   *)(data_path), '/');
      }
#line 334
      if (p) {
#line 335
        *(p + 1) = (char )'\000';
      } else {
#line 337
        data_path[0] = (char )'\000';
      }
      {
#line 338
      strcat((char */* __restrict  */)(data_path), (char const   */* __restrict  */)(idr.name));
#line 339
      strcat((char */* __restrict  */)(data_path), (char const   */* __restrict  */)"/STEPPINGS");
#line 341
      key = register_alloc(4);
#line 342
      memcpy((void */* __restrict  */)key->data, (void const   */* __restrict  */)(id->data + 28),
             (size_t )key->len);
#line 343
      tmp___23 = find_record(data_path, key, & idr);
      }
#line 343
      if (! tmp___23) {
        {
#line 344
        tmp___22 = gettext("  Unknown stepping!\n");
#line 344
        printf((char const   */* __restrict  */)tmp___22);
#line 345
        register_free(key);
        }
#line 346
        goto __Cont;
      }
      {
#line 348
      register_free(key);
#line 350
      tmp___24 = gettext("  Stepping:     %s\n");
#line 350
      printf((char const   */* __restrict  */)tmp___24, idr.fullname);
#line 351
      tmp___26 = strlen((char const   *)(idr.fullname));
      }
#line 351
      if (tmp___26 > 8U) {
        {
#line 352
        tmp___25 = gettext("Warning: Stepping too long\n");
#line 352
        printf((char const   */* __restrict  */)tmp___25);
        }
      }
      {
#line 353
      strncpy((char */* __restrict  */)(stepping), (char const   */* __restrict  */)(idr.fullname),
              (size_t )8);
#line 354
      stepping[8] = (char )'\000';
#line 357
      p = strrchr((char const   *)(data_path), '/');
      }
#line 358
      if (p) {
#line 359
        *(p + 1) = (char )'\000';
      } else {
#line 361
        data_path[0] = (char )'\000';
      }
      {
#line 362
      strcat((char */* __restrict  */)(data_path), (char const   */* __restrict  */)(idr.name));
#line 364
      tmp___27 = gettext("  Filename:     %s\n");
#line 364
      printf((char const   */* __restrict  */)tmp___27, data_path);
#line 367
      strcpy((char */* __restrict  */)(part->manufacturer), (char const   */* __restrict  */)(manufacturer));
#line 368
      strcpy((char */* __restrict  */)(part->part), (char const   */* __restrict  */)(partname));
#line 369
      strcpy((char */* __restrict  */)(part->stepping), (char const   */* __restrict  */)(stepping));
#line 370
      cmd_run(chain, cmd);
      }
    }
#line 375
    if ((unsigned long )part->active_instruction == (unsigned long )((void *)0)) {
      {
#line 376
      part->active_instruction = part_find_instruction(part, "IDCODE");
      }
    }
    __Cont: /* CIL Label */ 
#line 251
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 379
  i = 0;
  {
#line 379
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 379
    if (! (i < 32)) {
#line 379
      goto while_break___0;
    }
    {
#line 380
    tap_shift_register(chain, (tap_register const   *)one, br, 0);
#line 381
    tmp___31 = register_compare((tap_register const   *)one, (tap_register const   *)br);
    }
#line 381
    if (tmp___31 != 0) {
      {
#line 382
      tmp___30 = gettext("Error: Unable to detect JTAG chain end!\n");
#line 382
      printf((char const   */* __restrict  */)tmp___30);
      }
#line 383
      goto while_break___0;
    }
#line 379
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 386
  tap_shift_register(chain, (tap_register const   *)one, (tap_register *)((void *)0),
                     1);
#line 388
  register_free(one);
#line 389
  register_free(ones);
#line 390
  register_free(br);
#line 391
  register_free(id);
  }
#line 393
  return (ps->len);
}
}
#line 399 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/detect.c"
int manual_add(chain_t *chain , int instr_len ) 
{ 
  tap_register *id ;
  part_t *part ;
  char *cmd[5] ;
  char *str ;
  int result ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  void *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
  {
#line 403
  cmd[0] = (char *)((void *)0);
#line 403
  cmd[1] = (char *)((void *)0);
#line 403
  cmd[2] = (char *)((void *)0);
#line 403
  cmd[3] = (char *)((void *)0);
#line 403
  cmd[4] = (char *)((void *)0);
#line 407
  id = register_alloc(1);
  }
#line 408
  if ((unsigned long )id == (unsigned long )((void *)0)) {
    {
#line 409
    tmp = gettext("Error: Unable to allocate a register!\n");
#line 409
    printf((char const   */* __restrict  */)tmp);
    }
#line 410
    return (0);
  }
#line 414
  if ((unsigned long )chain->parts == (unsigned long )((void *)0)) {
    {
#line 415
    chain->parts = parts_alloc();
    }
#line 416
    if ((unsigned long )chain->parts == (unsigned long )((void *)0)) {
      {
#line 417
      tmp___0 = gettext("Error: Unable to allocate space for parts!\n");
#line 417
      printf((char const   */* __restrict  */)tmp___0);
      }
#line 418
      return (0);
    }
  }
  {
#line 422
  part = part_alloc((tap_register const   *)id);
  }
#line 423
  if ((unsigned long )part == (unsigned long )((void *)0)) {
    {
#line 424
    tmp___1 = gettext("Error: Unable to allocate space for a part!\n");
#line 424
    printf((char const   */* __restrict  */)tmp___1);
    }
#line 425
    return (0);
  }
  {
#line 428
  strncpy((char */* __restrict  */)(part->part), (char const   */* __restrict  */)"unknown",
          (size_t )20);
#line 429
  part->instruction_length = instr_len;
#line 431
  parts_add_part(chain->parts, part);
#line 432
  chain->active_part = (chain->parts)->len - 1;
#line 435
  cmd[0] = (char *)"register";
#line 436
  cmd[1] = (char *)"BR";
#line 437
  cmd[2] = (char *)"1";
#line 438
  cmd[3] = (char *)((void *)0);
#line 439
  tmp___3 = cmd_run(chain, cmd);
  }
#line 439
  if (tmp___3 < 1) {
    {
#line 440
    tmp___2 = gettext("Error: could not set BR register");
#line 440
    printf((char const   */* __restrict  */)tmp___2);
    }
#line 441
    return (0);
  }
  {
#line 445
  cmd[0] = (char *)"instruction";
#line 446
  cmd[1] = (char *)"BYPASS";
#line 447
  cmd[3] = (char *)"BR";
#line 448
  cmd[4] = (char *)((void *)0);
#line 449
  tmp___4 = calloc((size_t )(instr_len + 1), (size_t )sizeof(char ));
#line 449
  str = (char *)tmp___4;
  }
#line 450
  if ((unsigned long )str == (unsigned long )((void *)0)) {
    {
#line 451
    tmp___5 = gettext("Out of memory!\n");
#line 451
    printf((char const   */* __restrict  */)tmp___5);
    }
#line 452
    return (0);
  }
  {
#line 455
  memset((void *)str, '1', (size_t )instr_len);
#line 456
  *(str + instr_len) = (char )'\000';
#line 457
  cmd[2] = str;
#line 458
  result = cmd_run(chain, cmd);
#line 459
  free((void *)str);
  }
#line 461
  if (result < 1) {
    {
#line 462
    tmp___6 = gettext("Error: could not set BYPASS instruction");
#line 462
    printf((char const   */* __restrict  */)tmp___6);
    }
#line 463
    return (0);
  }
#line 467
  chain->total_instr_len += instr_len;
#line 469
  return ((chain->parts)->len);
}
}
#line 50 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/cmd_xfer.h"
int cx_cmd_space(cx_cmd_root_t *cmd_root , int max_len ) ;
#line 51
int cx_cmd_push(cx_cmd_root_t *cmd_root , uint8_t d ) ;
#line 52
cx_cmd_t *cx_cmd_dequeue(cx_cmd_root_t *cmd_root ) ;
#line 53
void cx_cmd_free(cx_cmd_t *cmd ) ;
#line 54
cx_cmd_t *cx_cmd_queue(cx_cmd_root_t *cmd_root , uint32_t to_recv ) ;
#line 55
void cx_cmd_init(cx_cmd_root_t *cmd_root ) ;
#line 56
void cx_cmd_deinit(cx_cmd_root_t *cmd_root ) ;
#line 58
void cx_xfer(cx_cmd_root_t *cmd_root , cx_cmd_t const   *out_cmd , cable_t *cable ,
             cable_flush_amount_t how_much ) ;
#line 60
uint8_t cx_xfer_recv(cable_t *cable ) ;
#line 49 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/cmd_xfer.c"
static int extend_cmd_buffer(cx_cmd_t *cmd ) 
{ 
  void *tmp ;
  int tmp___0 ;

  {
#line 53
  if (cmd->buf_pos >= cmd->buf_len) {
#line 55
    cmd->buf_len *= 2U;
#line 56
    if (cmd->buf) {
      {
#line 57
      tmp = realloc((void *)cmd->buf, cmd->buf_len);
#line 57
      cmd->buf = (uint8_t *)tmp;
      }
    }
  }
#line 60
  if (cmd->buf) {
#line 60
    tmp___0 = 1;
  } else {
#line 60
    tmp___0 = 0;
  }
#line 60
  return (tmp___0);
}
}
#line 79 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/cmd_xfer.c"
int cx_cmd_space(cx_cmd_root_t *cmd_root , int max_len ) 
{ 
  int n ;
  cx_cmd_t *cmd ;

  {
#line 83
  cmd = cmd_root->last;
#line 85
  if (! cmd) {
#line 86
    return (max_len);
  }
#line 88
  n = (int )((uint32_t )max_len - cmd->buf_pos);
#line 89
  if (n < 0) {
#line 90
    return (0);
  }
#line 92
  return (n);
}
}
#line 109 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/cmd_xfer.c"
int cx_cmd_push(cx_cmd_root_t *cmd_root , uint8_t d ) 
{ 
  cx_cmd_t *cmd ;
  int tmp ;
  uint32_t tmp___0 ;

  {
#line 112
  cmd = cmd_root->last;
#line 114
  if (! cmd) {
#line 115
    return (0);
  }
  {
#line 117
  tmp = extend_cmd_buffer(cmd);
  }
#line 117
  if (! tmp) {
#line 118
    return (0);
  }
#line 120
  tmp___0 = cmd->buf_pos;
#line 120
  (cmd->buf_pos) ++;
#line 120
  *(cmd->buf + tmp___0) = d;
#line 122
  return (1);
}
}
#line 138 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/cmd_xfer.c"
cx_cmd_t *cx_cmd_dequeue(cx_cmd_root_t *cmd_root ) 
{ 
  cx_cmd_t *cmd ;
  cx_cmd_t *tmp ;

  {
#line 141
  cmd = cmd_root->first;
#line 143
  if (cmd) {
#line 145
    tmp = cmd->next;
#line 145
    cmd_root->first = tmp;
#line 145
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 146
      cmd_root->last = (cx_cmd_t *)((void *)0);
    }
#line 147
    cmd->next = (cx_cmd_t *)((void *)0);
  }
#line 150
  return (cmd);
}
}
#line 165 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/cmd_xfer.c"
void cx_cmd_free(cx_cmd_t *cmd ) 
{ 


  {
#line 168
  if (cmd) {
#line 170
    if (cmd->buf) {
      {
#line 171
      free((void *)cmd->buf);
      }
    }
    {
#line 172
    free((void *)cmd);
    }
  }
#line 174
  return;
}
}
#line 192 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/cmd_xfer.c"
cx_cmd_t *cx_cmd_queue(cx_cmd_root_t *cmd_root , uint32_t to_recv ) 
{ 
  cx_cmd_t *cmd ;
  void *tmp ;
  uint8_t *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 195
  tmp = malloc((size_t )sizeof(cx_cmd_t ));
#line 195
  cmd = (cx_cmd_t *)tmp;
  }
#line 197
  if (cmd) {
    {
#line 199
    cmd->buf_len = (uint32_t )64;
#line 200
    tmp___1 = malloc(cmd->buf_len);
#line 200
    tmp___0 = (uint8_t *)tmp___1;
#line 200
    cmd->buf = tmp___0;
    }
#line 200
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      {
#line 202
      free((void *)cmd);
#line 203
      cmd = (cx_cmd_t *)((void *)0);
      }
    } else {
#line 207
      cmd->buf_pos = (uint32_t )0;
#line 208
      cmd->to_recv = to_recv;
#line 209
      cmd->next = (cx_cmd_t *)((void *)0);
#line 210
      if (! cmd_root->first) {
#line 211
        cmd_root->first = cmd;
      }
#line 212
      if (cmd_root->last) {
#line 213
        (cmd_root->last)->next = cmd;
      }
#line 214
      cmd_root->last = cmd;
    }
  }
#line 218
  return (cmd);
}
}
#line 233 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/cmd_xfer.c"
void cx_cmd_init(cx_cmd_root_t *cmd_root ) 
{ 


  {
#line 236
  cmd_root->first = (cx_cmd_t *)((void *)0);
#line 237
  cmd_root->last = (cx_cmd_t *)((void *)0);
#line 238
  return;
}
}
#line 252 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/cmd_xfer.c"
void cx_cmd_deinit(cx_cmd_root_t *cmd_root ) 
{ 
  cx_cmd_t *cmd ;

  {
  {
#line 256
  while (1) {
    while_continue: /* CIL Label */ ;
#line 256
    if (! cmd_root->first) {
#line 256
      goto while_break;
    }
    {
#line 258
    cmd = cx_cmd_dequeue(cmd_root);
#line 259
    cx_cmd_free(cmd);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 261
  return;
}
}
#line 285 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/cmd_xfer.c"
void cx_xfer(cx_cmd_root_t *cmd_root , cx_cmd_t const   *out_cmd , cable_t *cable ,
             cable_flush_amount_t how_much ) 
{ 
  cx_cmd_t *cmd ;
  cx_cmd_t *tmp ;
  uint32_t bytes_to_recv ;

  {
  {
#line 289
  tmp = cx_cmd_dequeue(cmd_root);
#line 289
  cmd = tmp;
#line 292
  bytes_to_recv = (uint32_t )0;
  }
  {
#line 294
  while (1) {
    while_continue: /* CIL Label */ ;
#line 294
    if (! cmd) {
#line 294
      goto while_break;
    }
    {
#line 298
    bytes_to_recv += cmd->to_recv;
#line 300
    usbconn_write(cable->link.usb, cmd->buf, (int )cmd->buf_pos, (int )cmd->to_recv);
#line 301
    cx_cmd_free(cmd);
#line 302
    cmd = cx_cmd_dequeue(cmd_root);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 308
  if (bytes_to_recv) {
#line 308
    if (out_cmd) {
      {
#line 310
      usbconn_write(cable->link.usb, (uint8_t *)out_cmd->buf, (int )out_cmd->buf_pos,
                    (int )out_cmd->to_recv);
#line 311
      bytes_to_recv += (uint32_t )out_cmd->to_recv;
      }
    }
  }
#line 314
  if (bytes_to_recv) {
    {
#line 317
    usbconn_read(cable->link.usb, (uint8_t *)((void *)0), 0);
#line 319
    bytes_to_recv = (uint32_t )0;
    }
  } else
#line 314
  if ((unsigned int )how_much != 1U) {
    {
#line 317
    usbconn_read(cable->link.usb, (uint8_t *)((void *)0), 0);
#line 319
    bytes_to_recv = (uint32_t )0;
    }
  }
#line 321
  return;
}
}
#line 335 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/cmd_xfer.c"
uint8_t cx_xfer_recv(cable_t *cable ) 
{ 
  uint8_t buf ;
  int tmp ;

  {
  {
#line 340
  tmp = usbconn_read(cable->link.usb, & buf, 1);
  }
#line 340
  if (tmp == 1) {
#line 342
    return (buf);
  } else {
#line 345
    return ((uint8_t )0);
  }
}
}
#line 124 "../../include/cable.h"
void cable_free(cable_t *cable ) ;
#line 127
void cable_flush(cable_t *cable , cable_flush_amount_t how_much ) ;
#line 128
void cable_clock(cable_t *cable , int tms , int tdi , int n ) ;
#line 129
int cable_defer_clock(cable_t *cable , int tms , int tdi , int n ) ;
#line 135
int cable_get_signal(cable_t *cable , pod_sigsel_t sig ) ;
#line 50 "../../include/chain.h"
chain_t *chain_alloc(void) ;
#line 51
void chain_free(chain_t *chain ) ;
#line 56
int chain_get_trst(chain_t *chain ) ;
#line 61
void chain_flush(chain_t *chain ) ;
#line 62
int chain_set_pod_signal(chain_t *chain , int mask , int val ) ;
#line 63
int chain_get_pod_signal(chain_t *chain , pod_sigsel_t sig ) ;
#line 36 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/chain.c"
chain_t *chain_alloc(void) 
{ 
  chain_t *chain ;
  void *tmp ;

  {
  {
#line 39
  tmp = malloc((size_t )sizeof(chain_t ));
#line 39
  chain = (chain_t *)tmp;
  }
#line 40
  if (! chain) {
#line 41
    return ((chain_t *)((void *)0));
  }
  {
#line 43
  chain->cable = (cable_t *)((void *)0);
#line 44
  chain->parts = (parts_t *)((void *)0);
#line 45
  chain->total_instr_len = 0;
#line 46
  chain->active_part = 0;
#line 47
  chain->bsdl.path_list = (char **)((void *)0);
#line 47
  chain->bsdl.debug = 0;
#line 48
  tap_state_init(chain);
  }
#line 50
  return (chain);
}
}
#line 53 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/chain.c"
void chain_free(chain_t *chain ) 
{ 


  {
#line 56
  if (! chain) {
#line 57
    return;
  }
  {
#line 59
  chain_disconnect(chain);
#line 61
  parts_free(chain->parts);
#line 62
  free((void *)chain);
  }
#line 63
  return;
}
}
#line 65 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/chain.c"
void chain_disconnect(chain_t *chain ) 
{ 


  {
#line 68
  if (! chain->cable) {
#line 69
    return;
  }
  {
#line 71
  tap_state_done(chain);
#line 72
  cable_done(chain->cable);
#line 73
  cable_free(chain->cable);
#line 74
  chain->cable = (cable_t *)((void *)0);
  }
#line 75
  return;
}
}
#line 77 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/chain.c"
void chain_clock(chain_t *chain , int tms , int tdi , int n ) 
{ 
  int i ;

  {
#line 82
  if (! chain) {
#line 83
    return;
  } else
#line 82
  if (! chain->cable) {
#line 83
    return;
  }
  {
#line 85
  cable_clock(chain->cable, tms, tdi, n);
#line 87
  i = 0;
  }
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
#line 87
    if (! (i < n)) {
#line 87
      goto while_break;
    }
    {
#line 88
    tap_state_clock(chain, tms);
#line 87
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 89
  return;
}
}
#line 91 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/chain.c"
void chain_defer_clock(chain_t *chain , int tms , int tdi , int n ) 
{ 
  int i ;

  {
#line 96
  if (! chain) {
#line 97
    return;
  } else
#line 96
  if (! chain->cable) {
#line 97
    return;
  }
  {
#line 99
  cable_defer_clock(chain->cable, tms, tdi, n);
#line 101
  i = 0;
  }
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    if (! (i < n)) {
#line 101
      goto while_break;
    }
    {
#line 102
    tap_state_clock(chain, tms);
#line 101
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 103
  return;
}
}
#line 105 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/chain.c"
int chain_set_trst(chain_t *chain , int trst ) 
{ 
  int old_val ;
  int tmp ;
  int tmp___0 ;
  int old_trst ;
  int tmp___1 ;

  {
#line 108
  if (trst) {
#line 108
    tmp = 8;
  } else {
#line 108
    tmp = 0;
  }
  {
#line 108
  tmp___0 = cable_set_signal(chain->cable, 8, tmp);
#line 108
  old_val = tmp___0;
  }
#line 109
  if (old_val & 8) {
#line 109
    tmp___1 = 1;
  } else {
#line 109
    tmp___1 = 0;
  }
  {
#line 109
  old_trst = tmp___1;
#line 110
  tap_state_set_trst(chain, old_trst, trst);
  }
#line 111
  return (trst);
}
}
#line 114 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/chain.c"
int chain_get_trst(chain_t *chain ) 
{ 
  int tmp ;

  {
  {
#line 117
  tmp = cable_get_signal(chain->cable, (pod_sigsel_t )8);
  }
#line 117
  return (tmp);
}
}
#line 120 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/chain.c"
int chain_set_pod_signal(chain_t *chain , int mask , int val ) 
{ 
  int old_val ;
  int tmp ;
  int old_trst ;
  int tmp___0 ;
  int new_trst ;
  int tmp___1 ;

  {
  {
#line 123
  tmp = cable_set_signal(chain->cable, mask, val);
#line 123
  old_val = tmp;
  }
#line 124
  if (old_val & 8) {
#line 124
    tmp___0 = 1;
  } else {
#line 124
    tmp___0 = 0;
  }
#line 124
  old_trst = tmp___0;
#line 125
  if (((old_val & ~ mask) | (val & mask)) & 8) {
#line 125
    tmp___1 = 1;
  } else {
#line 125
    tmp___1 = 0;
  }
  {
#line 125
  new_trst = tmp___1;
#line 126
  tap_state_set_trst(chain, old_trst, new_trst);
  }
#line 127
  return (old_val);
}
}
#line 130 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/chain.c"
int chain_get_pod_signal(chain_t *chain , pod_sigsel_t sig ) 
{ 
  int tmp ;

  {
  {
#line 133
  tmp = cable_get_signal(chain->cable, sig);
  }
#line 133
  return (tmp);
}
}
#line 136 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/chain.c"
void chain_shift_instructions_mode(chain_t *chain , int capture_output , int capture ,
                                   int chain_exit ) 
{ 
  int i ;
  parts_t *ps ;
  char *tmp ;
  int tmp___0 ;
  tap_register *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 142
  if (! chain) {
#line 143
    return;
  } else
#line 142
  if (! chain->parts) {
#line 143
    return;
  }
#line 145
  ps = chain->parts;
#line 147
  i = 0;
  {
#line 147
  while (1) {
    while_continue: /* CIL Label */ ;
#line 147
    if (! (i < ps->len)) {
#line 147
      goto while_break;
    }
#line 148
    if ((unsigned long )(*(ps->parts + i))->active_instruction == (unsigned long )((void *)0)) {
      {
#line 149
      tmp = gettext("%s(%d) Part %d without active instruction\n");
#line 149
      printf((char const   */* __restrict  */)tmp, "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/chain.c",
             149, i);
      }
#line 150
      return;
    }
#line 147
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 154
  if (capture) {
    {
#line 155
    tap_capture_ir(chain);
    }
  }
#line 160
  i = 0;
  {
#line 160
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 160
    if (! (i < ps->len)) {
#line 160
      goto while_break___0;
    }
#line 161
    if (i + 1 == ps->len) {
#line 161
      tmp___0 = chain_exit;
    } else {
#line 161
      tmp___0 = 0;
    }
#line 161
    if (capture_output) {
#line 161
      tmp___1 = ((*(ps->parts + i))->active_instruction)->out;
    } else {
#line 161
      tmp___1 = (tap_register *)((void *)0);
    }
    {
#line 161
    tap_defer_shift_register(chain, (tap_register const   *)((*(ps->parts + i))->active_instruction)->value,
                             tmp___1, tmp___0);
#line 160
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 166
  if (capture_output) {
#line 168
    i = 0;
    {
#line 168
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 168
      if (! (i < ps->len)) {
#line 168
        goto while_break___1;
      }
#line 169
      if (i + 1 == ps->len) {
#line 169
        tmp___2 = chain_exit;
      } else {
#line 169
        tmp___2 = 0;
      }
      {
#line 169
      tap_shift_register_output(chain, (tap_register const   *)((*(ps->parts + i))->active_instruction)->value,
                                ((*(ps->parts + i))->active_instruction)->out, tmp___2);
#line 168
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
    {
#line 177
    cable_flush(chain->cable, (cable_flush_amount_t )1);
    }
  }
#line 179
  return;
}
}
#line 181 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/chain.c"
void chain_shift_instructions(chain_t *chain ) 
{ 


  {
  {
#line 184
  chain_shift_instructions_mode(chain, 0, 1, 1);
  }
#line 185
  return;
}
}
#line 187 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/chain.c"
void chain_shift_data_registers_mode(chain_t *chain , int capture_output , int capture ,
                                     int chain_exit ) 
{ 
  int i ;
  parts_t *ps ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  tap_register *tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 193
  if (! chain) {
#line 194
    return;
  } else
#line 193
  if (! chain->parts) {
#line 194
    return;
  }
#line 196
  ps = chain->parts;
#line 198
  i = 0;
  {
#line 198
  while (1) {
    while_continue: /* CIL Label */ ;
#line 198
    if (! (i < ps->len)) {
#line 198
      goto while_break;
    }
#line 199
    if ((unsigned long )(*(ps->parts + i))->active_instruction == (unsigned long )((void *)0)) {
      {
#line 200
      tmp = gettext("%s(%d) Part %d without active instruction\n");
#line 200
      printf((char const   */* __restrict  */)tmp, "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/chain.c",
             200, i);
      }
#line 201
      return;
    }
#line 203
    if ((unsigned long )((*(ps->parts + i))->active_instruction)->data_register == (unsigned long )((void *)0)) {
      {
#line 204
      tmp___0 = gettext("%s(%d) Part %d without data register\n");
#line 204
      printf((char const   */* __restrict  */)tmp___0, "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/chain.c",
             204, i);
      }
#line 205
      return;
    }
#line 198
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 209
  if (capture) {
    {
#line 210
    tap_capture_dr(chain);
    }
  }
#line 215
  i = 0;
  {
#line 215
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 215
    if (! (i < ps->len)) {
#line 215
      goto while_break___0;
    }
#line 216
    if (i + 1 == ps->len) {
#line 216
      tmp___1 = chain_exit;
    } else {
#line 216
      tmp___1 = 0;
    }
#line 216
    if (capture_output) {
#line 216
      tmp___2 = (((*(ps->parts + i))->active_instruction)->data_register)->out;
    } else {
#line 216
      tmp___2 = (tap_register *)((void *)0);
    }
    {
#line 216
    tap_defer_shift_register(chain, (tap_register const   *)(((*(ps->parts + i))->active_instruction)->data_register)->in,
                             tmp___2, tmp___1);
#line 215
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 221
  if (capture_output) {
#line 223
    i = 0;
    {
#line 223
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 223
      if (! (i < ps->len)) {
#line 223
        goto while_break___1;
      }
#line 224
      if (i + 1 == ps->len) {
#line 224
        tmp___3 = chain_exit;
      } else {
#line 224
        tmp___3 = 0;
      }
      {
#line 224
      tap_shift_register_output(chain, (tap_register const   *)(((*(ps->parts + i))->active_instruction)->data_register)->in,
                                (((*(ps->parts + i))->active_instruction)->data_register)->out,
                                tmp___3);
#line 223
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
    {
#line 232
    cable_flush(chain->cable, (cable_flush_amount_t )1);
    }
  }
#line 234
  return;
}
}
#line 236 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/chain.c"
void chain_shift_data_registers(chain_t *chain , int capture_output ) 
{ 


  {
  {
#line 239
  chain_shift_data_registers_mode(chain, capture_output, 1, 1);
  }
#line 240
  return;
}
}
#line 242 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/chain.c"
void chain_flush(chain_t *chain ) 
{ 


  {
#line 245
  if ((unsigned long )chain->cable != (unsigned long )((void *)0)) {
    {
#line 246
    cable_flush(chain->cable, (cable_flush_amount_t )2);
    }
  }
#line 247
  return;
}
}
#line 48 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memmove)(void *__dest ,
                                                                                        void const   *__src ,
                                                                                        size_t __n ) ;
#line 125 "../../include/cable.h"
int cable_init(cable_t *cable ) ;
#line 130
int cable_get_tdo(cable_t *cable ) ;
#line 134
int cable_defer_set_signal(cable_t *cable , int mask , int val ) ;
#line 136
int cable_get_signal_late(cable_t *cable , pod_sigsel_t sig ) ;
#line 137
int cable_defer_get_signal(cable_t *cable , pod_sigsel_t sig ) ;
#line 138
int cable_transfer(cable_t *cable , int len , char *in , char *out ) ;
#line 149
cable_driver_t *cable_drivers[13] ;
#line 42 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable.c"
cable_driver_t arcom_cable_driver ;
#line 43
cable_driver_t byteblaster_cable_driver ;
#line 73 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable.c"
cable_driver_t *cable_drivers[13]  = 
#line 73
  {      & arcom_cable_driver,      & byteblaster_cable_driver,      & dlc5_cable_driver,      & ea253_cable_driver, 
        & ei012_cable_driver,      & igloo_cable_driver,      & keithkoep_cable_driver,      & lattice_cable_driver, 
        & mpcbdm_cable_driver,      & triton_cable_driver,      & wiggler_cable_driver,      & wiggler2_cable_driver, 
        (cable_driver_t *)((void *)0)};
#line 149 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable.c"
void cable_free(cable_t *cable ) 
{ 


  {
  {
#line 152
  (*((cable->driver)->cable_free))(cable);
  }
#line 153
  return;
}
}
#line 155 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable.c"
int cable_init(cable_t *cable ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp6 ;

  {
  {
#line 158
  cable->delay = (uint32_t )0;
#line 159
  cable->frequency = (uint32_t )0;
#line 161
  cable->todo.max_items = 128;
#line 162
  cable->todo.num_items = 0;
#line 163
  cable->todo.next_item = 0;
#line 164
  cable->todo.next_free = 0;
#line 165
  tmp = malloc((size_t )((unsigned long )cable->todo.max_items * sizeof(cable_queue_t )));
#line 165
  cable->todo.data = (cable_queue_t *)tmp;
#line 167
  cable->done.max_items = 128;
#line 168
  cable->done.num_items = 0;
#line 169
  cable->done.next_item = 0;
#line 170
  cable->done.next_free = 0;
#line 171
  tmp___0 = malloc((size_t )((unsigned long )cable->done.max_items * sizeof(cable_queue_t )));
#line 171
  cable->done.data = (cable_queue_t *)tmp___0;
  }
#line 173
  if ((unsigned long )cable->todo.data == (unsigned long )((void *)0)) {
#line 173
    goto _L;
  } else
#line 173
  if ((unsigned long )cable->done.data == (unsigned long )((void *)0)) {
    _L: /* CIL Label */ 
    {
#line 175
    tmp___1 = gettext("Failed to allocate memory for cable activity queue.\n");
#line 175
    printf((char const   */* __restrict  */)tmp___1);
    }
#line 176
    if ((unsigned long )cable->todo.data != (unsigned long )((void *)0)) {
      {
#line 176
      free((void *)cable->todo.data);
      }
    }
#line 177
    if ((unsigned long )cable->done.data != (unsigned long )((void *)0)) {
      {
#line 177
      free((void *)cable->done.data);
      }
    }
#line 178
    return (1);
  }
  {
#line 181
  tmp___2 = (*((cable->driver)->init))(cable);
  }
#line 181
  return (tmp___2);
}
}
#line 184 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable.c"
void cable_flush(cable_t *cable , cable_flush_amount_t how_much ) 
{ 


  {
  {
#line 187
  (*((cable->driver)->flush))(cable, how_much);
  }
#line 188
  return;
}
}
#line 190 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable.c"
void cable_done(cable_t *cable ) 
{ 


  {
  {
#line 193
  cable_flush(cable, (cable_flush_amount_t )2);
  }
#line 194
  if ((unsigned long )cable->todo.data != (unsigned long )((void *)0)) {
    {
#line 196
    free((void *)cable->todo.data);
#line 197
    free((void *)cable->done.data);
    }
  }
  {
#line 199
  (*((cable->driver)->done))(cable);
  }
#line 199
  return;
}
}
#line 202 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable.c"
int cable_add_queue_item(cable_t *cable , cable_queue_info_t *q ) 
{ 
  int i ;
  int j ;
  int new_max_items ;
  cable_queue_t *resized ;
  void *tmp ;
  char *tmp___0 ;
  int added_space ;
  int num_to_move ;
  int dest ;
  char *__cil_tmp12 ;

  {
#line 206
  if (q->num_items >= q->max_items) {
    {
#line 216
    new_max_items = q->max_items + 128;
#line 217
    tmp = realloc((void *)q->data, (size_t )((unsigned long )new_max_items * sizeof(cable_queue_t )));
#line 217
    resized = (cable_queue_t *)tmp;
    }
#line 218
    if ((unsigned long )resized == (unsigned long )((void *)0)) {
      {
#line 220
      tmp___0 = gettext("Out of memory: couldn\'t resize activity queue to %d\n");
#line 220
      printf((char const   */* __restrict  */)tmp___0, new_max_items);
      }
#line 222
      return (-1);
    }
#line 228
    q->data = resized;
#line 237
    if (q->next_item != 0) {
#line 239
      added_space = new_max_items - q->max_items;
#line 240
      num_to_move = q->max_items - q->next_item;
#line 243
      if (num_to_move <= q->next_free) {
        {
#line 249
        dest = new_max_items - num_to_move;
#line 254
        memmove((void *)(q->data + dest), (void const   *)(q->data + q->next_item),
                (size_t )((unsigned long )num_to_move * sizeof(cable_queue_t )));
#line 257
        q->next_item = dest;
        }
      } else
#line 262
      if (q->next_free <= added_space) {
        {
#line 270
        memcpy((void */* __restrict  */)(q->data + q->max_items), (void const   */* __restrict  */)(q->data + 0),
               (size_t )((unsigned long )q->next_free * sizeof(cable_queue_t )));
        }
      } else {
        {
#line 285
        memcpy((void */* __restrict  */)(q->data + q->max_items), (void const   */* __restrict  */)(q->data + 0),
               (size_t )((unsigned long )added_space * sizeof(cable_queue_t )));
#line 295
        memmove((void *)(q->data + 0), (void const   *)(q->data + added_space), (size_t )((unsigned long )(q->next_free - added_space) * sizeof(cable_queue_t )));
        }
      }
    }
#line 301
    q->max_items = new_max_items;
#line 302
    q->next_free = q->next_item + q->num_items;
#line 303
    if (q->next_free >= new_max_items) {
#line 303
      q->next_free -= new_max_items;
    }
  }
#line 311
  i = q->next_free;
#line 312
  j = i + 1;
#line 313
  if (j >= q->max_items) {
#line 313
    j = 0;
  }
#line 314
  q->next_free = j;
#line 315
  (q->num_items) ++;
#line 318
  return (i);
}
}
#line 321 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable.c"
int cable_get_queue_item(cable_t *cable , cable_queue_info_t *q ) 
{ 
  int i ;
  int j ;

  {
#line 324
  if (q->num_items > 0) {
#line 326
    i = q->next_item;
#line 327
    j = i + 1;
#line 328
    if (j >= q->max_items) {
#line 328
      j = 0;
    }
#line 329
    q->next_item = j;
#line 330
    (q->num_items) --;
#line 332
    return (i);
  }
#line 336
  return (-1);
}
}
#line 339 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable.c"
void cable_purge_queue(cable_queue_info_t *q , int io ) 
{ 
  int i ;

  {
  {
#line 342
  while (1) {
    while_continue: /* CIL Label */ ;
#line 342
    if (! (q->num_items > 0)) {
#line 342
      goto while_break;
    }
#line 344
    i = q->next_item;
#line 345
    if ((unsigned int )(q->data + i)->action == 2U) {
#line 347
      if (io == 0) {
#line 349
        if ((unsigned long )(q->data + i)->arg.transfer.in != (unsigned long )((void *)0)) {
          {
#line 349
          free((void *)(q->data + i)->arg.transfer.in);
          }
        }
#line 350
        if ((unsigned long )(q->data + i)->arg.transfer.out != (unsigned long )((void *)0)) {
          {
#line 350
          free((void *)(q->data + i)->arg.transfer.out);
          }
        }
      } else
#line 354
      if ((unsigned long )(q->data + i)->arg.xferred.out != (unsigned long )((void *)0)) {
        {
#line 354
        free((void *)(q->data + i)->arg.xferred.out);
        }
      }
    }
#line 358
    i ++;
#line 359
    if (i >= q->max_items) {
#line 359
      i = 0;
    }
#line 360
    (q->num_items) --;
  }
  while_break: /* CIL Label */ ;
  }
#line 363
  q->num_items = 0;
#line 364
  q->next_item = 0;
#line 365
  q->next_free = 0;
#line 366
  return;
}
}
#line 368 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable.c"
void cable_clock(cable_t *cable , int tms , int tdi , int n ) 
{ 


  {
  {
#line 371
  cable_flush(cable, (cable_flush_amount_t )2);
#line 372
  (*((cable->driver)->clock))(cable, tms, tdi, n);
  }
#line 373
  return;
}
}
#line 375 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable.c"
int cable_defer_clock(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;
  int tmp ;

  {
  {
#line 378
  tmp = cable_add_queue_item(cable, & cable->todo);
#line 378
  i = tmp;
  }
#line 379
  if (i < 0) {
#line 379
    return (1);
  }
  {
#line 380
  (cable->todo.data + i)->action = (enum __anonenum_action_29 )0;
#line 381
  (cable->todo.data + i)->arg.clock.tms = tms;
#line 382
  (cable->todo.data + i)->arg.clock.tdi = tdi;
#line 383
  (cable->todo.data + i)->arg.clock.n = n;
#line 384
  cable_flush(cable, (cable_flush_amount_t )0);
  }
#line 385
  return (0);
}
}
#line 388 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable.c"
int cable_get_tdo(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 391
  cable_flush(cable, (cable_flush_amount_t )2);
#line 392
  tmp = (*((cable->driver)->get_tdo))(cable);
  }
#line 392
  return (tmp);
}
}
#line 395 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable.c"
int cable_get_tdo_late(cable_t *cable ) 
{ 
  int i ;
  char *tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;

  {
  {
#line 399
  cable_flush(cable, (cable_flush_amount_t )1);
#line 400
  i = cable_get_queue_item(cable, & cable->done);
  }
#line 401
  if (i >= 0) {
#line 403
    if ((unsigned int )(cable->done.data + i)->action != 1U) {
      {
#line 405
      tmp = gettext("Internal error: Got wrong type of result from queue (%d? %p.%d)\n");
#line 405
      printf((char const   */* __restrict  */)tmp, (unsigned int )(cable->done.data + i)->action,
             & cable->done, i);
#line 407
      cable_purge_queue(& cable->done, 1);
      }
    } else {
#line 411
      return ((cable->done.data + i)->arg.value.val);
    }
  }
  {
#line 414
  tmp___0 = (*((cable->driver)->get_tdo))(cable);
  }
#line 414
  return (tmp___0);
}
}
#line 417 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable.c"
int cable_defer_get_tdo(cable_t *cable ) 
{ 
  int i ;
  int tmp ;

  {
  {
#line 420
  tmp = cable_add_queue_item(cable, & cable->todo);
#line 420
  i = tmp;
  }
#line 421
  if (i < 0) {
#line 421
    return (1);
  }
  {
#line 422
  (cable->todo.data + i)->action = (enum __anonenum_action_29 )1;
#line 423
  cable_flush(cable, (cable_flush_amount_t )0);
  }
#line 424
  return (0);
}
}
#line 427 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable.c"
int cable_set_signal(cable_t *cable , int mask , int val ) 
{ 
  int tmp ;

  {
  {
#line 430
  cable_flush(cable, (cable_flush_amount_t )2);
#line 431
  tmp = (*((cable->driver)->set_signal))(cable, mask, val);
  }
#line 431
  return (tmp);
}
}
#line 434 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable.c"
int cable_defer_set_signal(cable_t *cable , int mask , int val ) 
{ 
  int i ;
  int tmp ;

  {
  {
#line 437
  tmp = cable_add_queue_item(cable, & cable->todo);
#line 437
  i = tmp;
  }
#line 438
  if (i < 0) {
#line 438
    return (1);
  }
  {
#line 439
  (cable->todo.data + i)->action = (enum __anonenum_action_29 )3;
#line 440
  (cable->todo.data + i)->arg.value.mask = mask;
#line 441
  (cable->todo.data + i)->arg.value.val = val;
#line 442
  cable_flush(cable, (cable_flush_amount_t )0);
  }
#line 443
  return (0);
}
}
#line 446 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable.c"
int cable_get_signal(cable_t *cable , pod_sigsel_t sig ) 
{ 
  int tmp ;

  {
  {
#line 449
  cable_flush(cable, (cable_flush_amount_t )2);
#line 450
  tmp = (*((cable->driver)->get_signal))(cable, sig);
  }
#line 450
  return (tmp);
}
}
#line 453 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable.c"
int cable_get_signal_late(cable_t *cable , pod_sigsel_t sig ) 
{ 
  int i ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 457
  cable_flush(cable, (cable_flush_amount_t )1);
#line 458
  i = cable_get_queue_item(cable, & cable->done);
  }
#line 459
  if (i >= 0) {
#line 461
    if ((unsigned int )(cable->done.data + i)->action != 4U) {
      {
#line 463
      tmp = gettext("Internal error: Got wrong type of result from queue (%d? %p.%d)\n");
#line 463
      printf((char const   */* __restrict  */)tmp, (unsigned int )(cable->done.data + i)->action,
             & cable->done, i);
#line 465
      cable_purge_queue(& cable->done, 1);
      }
    } else
#line 467
    if ((unsigned int )(cable->done.data + i)->arg.value.sig != (unsigned int )sig) {
      {
#line 469
      tmp___0 = gettext("Internal error: Got wrong signal\'s value from queue (%d? %p.%d)\n");
#line 469
      printf((char const   */* __restrict  */)tmp___0, (unsigned int )(cable->done.data + i)->action,
             & cable->done, i);
#line 471
      cable_purge_queue(& cable->done, 1);
      }
    } else {
#line 475
      return ((cable->done.data + i)->arg.value.val);
    }
  }
  {
#line 478
  tmp___1 = (*((cable->driver)->get_signal))(cable, sig);
  }
#line 478
  return (tmp___1);
}
}
#line 481 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable.c"
int cable_defer_get_signal(cable_t *cable , pod_sigsel_t sig ) 
{ 
  int i ;
  int tmp ;

  {
  {
#line 484
  tmp = cable_add_queue_item(cable, & cable->todo);
#line 484
  i = tmp;
  }
#line 485
  if (i < 0) {
#line 485
    return (1);
  }
  {
#line 486
  (cable->todo.data + i)->action = (enum __anonenum_action_29 )4;
#line 487
  (cable->todo.data + i)->arg.value.sig = sig;
#line 488
  cable_flush(cable, (cable_flush_amount_t )0);
  }
#line 489
  return (0);
}
}
#line 492 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable.c"
int cable_transfer(cable_t *cable , int len , char *in , char *out ) 
{ 
  int tmp ;

  {
  {
#line 495
  cable_flush(cable, (cable_flush_amount_t )2);
#line 496
  tmp = (*((cable->driver)->transfer))(cable, len, in, out);
  }
#line 496
  return (tmp);
}
}
#line 499 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable.c"
int cable_transfer_late(cable_t *cable , char *out ) 
{ 
  int i ;
  char *tmp ;
  char *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 503
  cable_flush(cable, (cable_flush_amount_t )1);
#line 504
  i = cable_get_queue_item(cable, & cable->done);
  }
#line 506
  if (i >= 0) {
#line 506
    if ((unsigned int )(cable->done.data + i)->action == 2U) {
#line 514
      if (out) {
        {
#line 514
        memcpy((void */* __restrict  */)out, (void const   */* __restrict  */)(cable->done.data + i)->arg.xferred.out,
               (size_t )(cable->done.data + i)->arg.xferred.len);
        }
      }
      {
#line 517
      free((void *)(cable->done.data + i)->arg.xferred.out);
      }
#line 518
      return ((cable->done.data + i)->arg.xferred.res);
    }
  }
#line 521
  if ((unsigned int )(cable->done.data + i)->action != 2U) {
    {
#line 523
    tmp = gettext("Internal error: Got wrong type of result from queue (#%d %p.%d)\n");
#line 523
    printf((char const   */* __restrict  */)tmp, (unsigned int )(cable->done.data + i)->action,
           & cable->done, i);
#line 525
    cable_purge_queue(& cable->done, 1);
    }
  } else {
    {
#line 529
    tmp___0 = gettext("Internal error: Wanted transfer result but none was queued\n");
#line 529
    printf((char const   */* __restrict  */)tmp___0);
    }
  }
#line 531
  return (0);
}
}
#line 534 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable.c"
int cable_defer_transfer(cable_t *cable , int len , char *in , char *out ) 
{ 
  char *ibuf ;
  char *obuf ;
  int i ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 537
  obuf = (char *)((void *)0);
#line 540
  tmp = malloc((size_t )len);
#line 540
  ibuf = (char *)tmp;
  }
#line 541
  if ((unsigned long )ibuf == (unsigned long )((void *)0)) {
#line 541
    return (1);
  }
#line 543
  if (out) {
    {
#line 545
    tmp___0 = malloc((size_t )len);
#line 545
    obuf = (char *)tmp___0;
    }
#line 546
    if ((unsigned long )obuf == (unsigned long )((void *)0)) {
      {
#line 548
      free((void *)ibuf);
      }
#line 549
      return (1);
    }
  }
  {
#line 553
  i = cable_add_queue_item(cable, & cable->todo);
  }
#line 554
  if (i < 0) {
    {
#line 556
    free((void *)ibuf);
    }
#line 557
    if (obuf) {
      {
#line 557
      free((void *)obuf);
      }
    }
#line 558
    return (1);
  }
#line 561
  (cable->todo.data + i)->action = (enum __anonenum_action_29 )2;
#line 562
  (cable->todo.data + i)->arg.transfer.len = len;
#line 563
  if (in) {
    {
#line 563
    memcpy((void */* __restrict  */)ibuf, (void const   */* __restrict  */)in, (size_t )len);
    }
  }
  {
#line 564
  (cable->todo.data + i)->arg.transfer.in = ibuf;
#line 565
  (cable->todo.data + i)->arg.transfer.out = obuf;
#line 566
  cable_flush(cable, (cable_flush_amount_t )0);
  }
#line 567
  return (0);
}
}
#line 570 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable.c"
void cable_set_frequency(cable_t *cable , uint32_t new_frequency ) 
{ 


  {
  {
#line 573
  cable_flush(cable, (cable_flush_amount_t )2);
#line 574
  (*((cable->driver)->set_frequency))(cable, new_frequency);
  }
#line 575
  return;
}
}
#line 577 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable.c"
uint32_t cable_get_frequency(cable_t *cable ) 
{ 


  {
#line 580
  return (cable->frequency);
}
}
#line 583 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable.c"
void cable_wait(cable_t *cable ) 
{ 
  int i ;
  int volatile   j ;
  uint32_t delay ;

  {
#line 588
  delay = cable->delay;
#line 590
  if (delay == 0U) {
#line 591
    return;
  }
#line 593
  i = 0;
  {
#line 593
  while (1) {
    while_continue: /* CIL Label */ ;
#line 593
    if (! ((uint32_t )i < delay)) {
#line 593
      goto while_break;
    }
#line 594
    j = (int volatile   )i;
#line 593
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 596
  return;
}
}
#line 70 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/byteblaster.c"
static int byteblaster_init(cable_t *cable ) 
{ 
  int BB_II ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 73
  BB_II = 0;
#line 75
  tmp = parport_open(cable->link.port);
  }
#line 75
  if (tmp) {
#line 76
    return (-1);
  }
  {
#line 78
  ((generic_params_t *)cable->params)->signals = 8;
#line 81
  parport_set_data(cable->link.port, (uint8_t )(1 << 5));
#line 82
  tmp___0 = parport_get_status(cable->link.port);
  }
#line 82
  if (! ((tmp___0 >> 6) & 1)) {
#line 83
    BB_II = 1;
  }
  {
#line 84
  parport_set_data(cable->link.port, (uint8_t )0);
#line 85
  tmp___1 = parport_get_status(cable->link.port);
  }
#line 85
  if ((tmp___1 >> 6) & 1) {
#line 86
    BB_II = 1;
  }
#line 90
  if (BB_II) {
    {
#line 90
    tmp___2 = parport_get_status(cable->link.port);
    }
#line 90
    if ((tmp___2 >> 3) & 1) {
#line 91
      return (-1);
    }
  }
  {
#line 94
  parport_set_control(cable->link.port, (uint8_t )12);
  }
#line 96
  return (0);
}
}
#line 99 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/byteblaster.c"
static void byteblaster_clock(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 104
  if (tms) {
#line 104
    tms = 1;
  } else {
#line 104
    tms = 0;
  }
#line 105
  if (tdi) {
#line 105
    tdi = 1;
  } else {
#line 105
    tdi = 0;
  }
#line 107
  i = 0;
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 107
    if (! (i < n)) {
#line 107
      goto while_break;
    }
    {
#line 108
    parport_set_data(cable->link.port, (uint8_t )((tms << 1) | (tdi << 6)));
#line 109
    cable_wait(cable);
#line 110
    parport_set_data(cable->link.port, (uint8_t )((1 | (tms << 1)) | (tdi << 6)));
#line 111
    cable_wait(cable);
#line 107
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 114
  ((generic_params_t *)cable->params)->signals &= 8;
#line 115
  ((generic_params_t *)cable->params)->signals |= 2;
#line 116
  if (tms) {
#line 116
    tmp = 4;
  } else {
#line 116
    tmp = 0;
  }
#line 116
  ((generic_params_t *)cable->params)->signals |= tmp;
#line 117
  if (tdi) {
#line 117
    tmp___0 = 1;
  } else {
#line 117
    tmp___0 = 0;
  }
#line 117
  ((generic_params_t *)cable->params)->signals |= tmp___0;
#line 118
  return;
}
}
#line 120 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/byteblaster.c"
static int byteblaster_get_tdo(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 123
  parport_set_data(cable->link.port, (uint8_t )0);
#line 124
  ((generic_params_t *)cable->params)->signals &= -8;
#line 126
  cable_wait(cable);
#line 128
  tmp = parport_get_status(cable->link.port);
  }
#line 128
  return ((tmp >> 7) & 1);
}
}
#line 131 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/byteblaster.c"
static int byteblaster_set_signal(cable_t *cable , int mask , int val ) 
{ 
  int prev_sigs ;
  int data ;
  int sigs ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 134
  prev_sigs = ((generic_params_t *)cable->params)->signals;
#line 136
  mask &= 7;
#line 138
  if (mask != 0) {
#line 140
    data = 0;
#line 141
    sigs = (prev_sigs & ~ mask) | (val & mask);
#line 142
    if (sigs & 1) {
#line 142
      tmp = 1 << 6;
    } else {
#line 142
      tmp = 0;
    }
#line 142
    data |= tmp;
#line 143
    if (sigs & 2) {
#line 143
      tmp___0 = 1;
    } else {
#line 143
      tmp___0 = 0;
    }
#line 143
    data |= tmp___0;
#line 144
    if (sigs & 4) {
#line 144
      tmp___1 = 1 << 1;
    } else {
#line 144
      tmp___1 = 0;
    }
    {
#line 144
    data |= tmp___1;
#line 145
    parport_set_data(cable->link.port, (uint8_t )data);
#line 146
    ((generic_params_t *)cable->params)->signals = sigs;
    }
  }
#line 149
  return (prev_sigs);
}
}
#line 152 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/byteblaster.c"
cable_driver_t byteblaster_cable_driver  = 
#line 152
     {"ByteBlaster", "Altera ByteBlaster/ByteBlaster II/ByteBlasterMV Parallel Port Download Cable",
    & generic_parport_connect, & generic_disconnect, & generic_parport_free, & byteblaster_init,
    & generic_parport_done, & generic_set_frequency, & byteblaster_clock, & byteblaster_get_tdo,
    & generic_transfer, & byteblaster_set_signal, & generic_get_signal, & generic_flush_one_by_one,
    & generic_parport_help};
#line 52 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/arcom.c"
static int arcom_init(cable_t *cable ) 
{ 
  int data ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 57
  tmp = parport_open(cable->link.port);
  }
#line 57
  if (tmp) {
#line 58
    return (-1);
  }
  {
#line 60
  data = parport_get_data(cable->link.port);
  }
#line 60
  if (data < 0) {
    {
#line 61
    tmp___0 = parport_set_data(cable->link.port, (uint8_t )(1 << 3));
    }
#line 61
    if (tmp___0) {
#line 62
      return (-1);
    }
#line 63
    ((generic_params_t *)cable->params)->signals = 8;
  } else
#line 65
  if (data >> 3) {
#line 65
    ((generic_params_t *)cable->params)->signals = 8;
  } else {
#line 65
    ((generic_params_t *)cable->params)->signals = 0;
  }
#line 67
  return (0);
}
}
#line 70 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/arcom.c"
static void arcom_clock(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;
  int trst ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 74
  if (((generic_params_t *)cable->params)->signals & 8) {
#line 74
    tmp = 1;
  } else {
#line 74
    tmp = 0;
  }
#line 74
  trst = tmp;
#line 76
  if (tms) {
#line 76
    tms = 1;
  } else {
#line 76
    tms = 0;
  }
#line 77
  if (tdi) {
#line 77
    tdi = 1;
  } else {
#line 77
    tdi = 0;
  }
#line 79
  i = 0;
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (! (i < n)) {
#line 79
      goto while_break;
    }
    {
#line 80
    parport_set_data(cable->link.port, (uint8_t )(((trst << 3) | (tms << 2)) | (tdi << 1)));
#line 81
    cable_wait(cable);
#line 82
    parport_set_data(cable->link.port, (uint8_t )((((trst << 3) | 1) | (tms << 2)) | (tdi << 1)));
#line 83
    cable_wait(cable);
#line 79
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 86
  ((generic_params_t *)cable->params)->signals &= 8;
#line 87
  ((generic_params_t *)cable->params)->signals |= 2;
#line 88
  if (tms) {
#line 88
    tmp___0 = 4;
  } else {
#line 88
    tmp___0 = 0;
  }
#line 88
  ((generic_params_t *)cable->params)->signals |= tmp___0;
#line 89
  if (tdi) {
#line 89
    tmp___1 = 1;
  } else {
#line 89
    tmp___1 = 0;
  }
#line 89
  ((generic_params_t *)cable->params)->signals |= tmp___1;
#line 90
  return;
}
}
#line 92 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/arcom.c"
static int arcom_get_tdo(cable_t *cable ) 
{ 
  int trst ;
  int tmp ;
  int tmp___0 ;

  {
#line 95
  if (((generic_params_t *)cable->params)->signals & 8) {
#line 95
    tmp = 1;
  } else {
#line 95
    tmp = 0;
  }
  {
#line 95
  trst = tmp;
#line 97
  parport_set_data(cable->link.port, (uint8_t )(trst << 3));
#line 98
  ((generic_params_t *)cable->params)->signals &= -8;
#line 100
  cable_wait(cable);
#line 102
  tmp___0 = parport_get_status(cable->link.port);
  }
#line 102
  return ((tmp___0 >> 7) & 1);
}
}
#line 105 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/arcom.c"
static int arcom_set_signal(cable_t *cable , int mask , int val ) 
{ 
  int prev_sigs ;
  int data ;
  int sigs ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 108
  prev_sigs = ((generic_params_t *)cable->params)->signals;
#line 110
  mask &= 15;
#line 112
  if (mask != 0) {
#line 114
    data = 0;
#line 115
    sigs = (prev_sigs & ~ mask) | (val & mask);
#line 116
    if (sigs & 1) {
#line 116
      tmp = 1 << 1;
    } else {
#line 116
      tmp = 0;
    }
#line 116
    data |= tmp;
#line 117
    if (sigs & 2) {
#line 117
      tmp___0 = 1;
    } else {
#line 117
      tmp___0 = 0;
    }
#line 117
    data |= tmp___0;
#line 118
    if (sigs & 4) {
#line 118
      tmp___1 = 1 << 2;
    } else {
#line 118
      tmp___1 = 0;
    }
#line 118
    data |= tmp___1;
#line 119
    if (sigs & 8) {
#line 119
      tmp___2 = 1 << 3;
    } else {
#line 119
      tmp___2 = 0;
    }
    {
#line 119
    data |= tmp___2;
#line 120
    parport_set_data(cable->link.port, (uint8_t )data);
#line 121
    ((generic_params_t *)cable->params)->signals = sigs;
    }
  }
#line 124
  return (prev_sigs);
}
}
#line 127 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/arcom.c"
cable_driver_t arcom_cable_driver  = 
#line 127
     {"ARCOM", "Arcom JTAG Cable", & generic_parport_connect, & generic_disconnect,
    & generic_parport_free, & arcom_init, & generic_parport_done, & generic_set_frequency,
    & arcom_clock, & arcom_get_tdo, & generic_transfer, & arcom_set_signal, & generic_get_signal,
    & generic_flush_one_by_one, & generic_parport_help};
#line 80 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/jedec.c"
static struct amd_flash_info  const  table___0[21]  = 
#line 80 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/jedec.c"
  {      {(int const   )1, (int const   )8900, "AMD AM29LV160DT", (long const   )2097152,
      (uint8_t const   )1, (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )65536,
                                                               (uint32_t )31}, {(uint32_t )2031616,
                                                                                (uint32_t )32768,
                                                                                (uint32_t )1},
                                                              {(uint32_t )2064384,
                                                               (uint32_t )8192, (uint32_t )2},
                                                              {(uint32_t )2080768,
                                                               (uint32_t )16384, (uint32_t )1}}}, 
        {(int const   )1,
      (int const   )8777, "AMD AM29LV160DB", (long const   )2097152, (uint8_t const   )1,
      (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )16384, (uint32_t )1},
                                         {(uint32_t )16384, (uint32_t )8192, (uint32_t )2},
                                         {(uint32_t )32768, (uint32_t )32768, (uint32_t )1},
                                         {(uint32_t )65536, (uint32_t )65536, (uint32_t )31}}}, 
        {(int const   )152,
      (int const   )194, "Toshiba TC58FVT160", (long const   )2097152, (uint8_t const   )1,
      (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )65536, (uint32_t )31},
                                         {(uint32_t )2031616, (uint32_t )32768, (uint32_t )1},
                                         {(uint32_t )2064384, (uint32_t )8192, (uint32_t )2},
                                         {(uint32_t )2080768, (uint32_t )16384, (uint32_t )1}}}, 
        {(int const   )4,
      (int const   )8900, "Fujitsu MBM29LV160TE", (long const   )2097152, (uint8_t const   )1,
      (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )65536, (uint32_t )31},
                                         {(uint32_t )2031616, (uint32_t )32768, (uint32_t )1},
                                         {(uint32_t )2064384, (uint32_t )8192, (uint32_t )2},
                                         {(uint32_t )2080768, (uint32_t )16384, (uint32_t )1}}}, 
        {(int const   )152,
      (int const   )67, "Toshiba TC58FVB160", (long const   )2097152, (uint8_t const   )1,
      (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )16384, (uint32_t )1},
                                         {(uint32_t )16384, (uint32_t )8192, (uint32_t )2},
                                         {(uint32_t )32768, (uint32_t )32768, (uint32_t )1},
                                         {(uint32_t )65536, (uint32_t )65536, (uint32_t )31}}}, 
        {(int const   )4,
      (int const   )8777, "Fujitsu MBM29LV160BE", (long const   )2097152, (uint8_t const   )1,
      (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )16384, (uint32_t )1},
                                         {(uint32_t )16384, (uint32_t )8192, (uint32_t )2},
                                         {(uint32_t )32768, (uint32_t )32768, (uint32_t )1},
                                         {(uint32_t )65536, (uint32_t )65536, (uint32_t )31}}}, 
        {(int const   )1,
      (int const   )8795, "AMD AM29LV800BB", (long const   )1048576, (uint8_t const   )1,
      (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )16384, (uint32_t )1},
                                         {(uint32_t )16384, (uint32_t )8192, (uint32_t )2},
                                         {(uint32_t )32768, (uint32_t )32768, (uint32_t )1},
                                         {(uint32_t )65536, (uint32_t )65536, (uint32_t )15}}}, 
        {(int const   )1,
      (int const   )8792, "AMD AM29F800BB", (long const   )1048576, (uint8_t const   )1,
      (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )16384, (uint32_t )1},
                                         {(uint32_t )16384, (uint32_t )8192, (uint32_t )2},
                                         {(uint32_t )32768, (uint32_t )32768, (uint32_t )1},
                                         {(uint32_t )65536, (uint32_t )65536, (uint32_t )15}}}, 
        {(int const   )1,
      (int const   )8922, "AMD AM29LV800BT", (long const   )1048576, (uint8_t const   )1,
      (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )65536, (uint32_t )15},
                                         {(uint32_t )983040, (uint32_t )32768, (uint32_t )1},
                                         {(uint32_t )1015808, (uint32_t )8192, (uint32_t )2},
                                         {(uint32_t )1032192, (uint32_t )16384, (uint32_t )1}}}, 
        {(int const   )1,
      (int const   )8918, "AMD AM29F800BT", (long const   )1048576, (uint8_t const   )1,
      (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )65536, (uint32_t )15},
                                         {(uint32_t )983040, (uint32_t )32768, (uint32_t )1},
                                         {(uint32_t )1015808, (uint32_t )8192, (uint32_t )2},
                                         {(uint32_t )1032192, (uint32_t )16384, (uint32_t )1}}}, 
        {(int const   )1,
      (int const   )8795, "AMD AM29LV800BB", (long const   )1048576, (uint8_t const   )1,
      (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )65536, (uint32_t )15},
                                         {(uint32_t )983040, (uint32_t )32768, (uint32_t )1},
                                         {(uint32_t )1015808, (uint32_t )8192, (uint32_t )2},
                                         {(uint32_t )1032192, (uint32_t )16384, (uint32_t )1}}}, 
        {(int const   )4,
      (int const   )8795, "Fujitsu MBM29LV800BB", (long const   )1048576, (uint8_t const   )1,
      (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )16384, (uint32_t )1},
                                         {(uint32_t )16384, (uint32_t )8192, (uint32_t )2},
                                         {(uint32_t )32768, (uint32_t )32768, (uint32_t )1},
                                         {(uint32_t )65536, (uint32_t )65536, (uint32_t )15}}}, 
        {(int const   )32,
      (int const   )215, "ST M29W800T", (long const   )1048576, (uint8_t const   )1,
      (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )65536, (uint32_t )15},
                                         {(uint32_t )983040, (uint32_t )32768, (uint32_t )1},
                                         {(uint32_t )1015808, (uint32_t )8192, (uint32_t )2},
                                         {(uint32_t )1032192, (uint32_t )16384, (uint32_t )1}}}, 
        {(int const   )32,
      (int const   )8900, "ST M29W160DT", (long const   )2097152, (uint8_t const   )1,
      (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )65536, (uint32_t )31},
                                         {(uint32_t )2031616, (uint32_t )32768, (uint32_t )1},
                                         {(uint32_t )2064384, (uint32_t )8192, (uint32_t )2},
                                         {(uint32_t )2080768, (uint32_t )16384, (uint32_t )1}}}, 
        {(int const   )32,
      (int const   )8777, "ST M29W160DB", (long const   )2097152, (uint8_t const   )1,
      (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )16384, (uint32_t )1},
                                         {(uint32_t )16384, (uint32_t )8192, (uint32_t )2},
                                         {(uint32_t )32768, (uint32_t )32768, (uint32_t )1},
                                         {(uint32_t )65536, (uint32_t )65536, (uint32_t )31}}}, 
        {(int const   )1,
      (int const   )8913, "AMD AM29BDS323D", (long const   )4194304, (uint8_t const   )1,
      (int const   )0, (int const   )3, {{(uint32_t )0, (uint32_t )65536, (uint32_t )48},
                                         {(uint32_t )3145728, (uint32_t )65536, (uint32_t )15},
                                         {(uint32_t )4128768, (uint32_t )8192, (uint32_t )8}}}, 
        {(int const   )1,
      (int const   )8830, "AMD AM29BDS643D", (long const   )8388608, (uint8_t const   )1,
      (int const   )0, (int const   )3, {{(uint32_t )0, (uint32_t )65536, (uint32_t )96},
                                         {(uint32_t )6291456, (uint32_t )65536, (uint32_t )31},
                                         {(uint32_t )8323072, (uint32_t )8192, (uint32_t )8}}}, 
        {(int const   )31,
      (int const   )192, "Atmel AT49xV16x", (long const   )2097152, (uint8_t const   )1,
      (int const   )0, (int const   )2, {{(uint32_t )0, (uint32_t )8192, (uint32_t )8},
                                         {(uint32_t )65536, (uint32_t )65536, (uint32_t )31}}}, 
        {(int const   )31,
      (int const   )194, "Atmel AT49xV16xT", (long const   )2097152, (uint8_t const   )1,
      (int const   )0, (int const   )2, {{(uint32_t )0, (uint32_t )65536, (uint32_t )31},
                                         {(uint32_t )2031616, (uint32_t )8192, (uint32_t )8}}}, 
        {(int const   )194,
      (int const   )8889, "MX 29LV400T", (long const   )524288, (uint8_t const   )1,
      (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )65536, (uint32_t )7},
                                         {(uint32_t )458752, (uint32_t )32768, (uint32_t )1},
                                         {(uint32_t )491520, (uint32_t )8192, (uint32_t )2},
                                         {(uint32_t )507904, (uint32_t )16384, (uint32_t )1}}}, 
        {(int const   )1,
      (int const   )79, "AMD AM29LV040B", (long const   )524288, (uint8_t const   )0,
      (int const   )1, (int const   )1, {{(uint32_t )0, (uint32_t )65536, (uint32_t )8}}}};
#line 51 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/intel.c"
static int intel_flash_erase_block___0(cfi_array_t *cfi_array___0 , uint32_t adr ) ;
#line 52
static int intel_flash_unlock_block___0(cfi_array_t *cfi_array___0 , uint32_t adr ) ;
#line 53
static int intel_flash_program_single___0(cfi_array_t *cfi_array___0 , uint32_t adr ,
                                          uint32_t data ) ;
#line 54
static int intel_flash_program_buffer___0(cfi_array_t *cfi_array___0 , uint32_t adr ,
                                          uint32_t *buffer , int count ) ;
#line 55
static int intel_flash_program___0(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t *buffer ,
                                   int count ) ;
#line 56
static int intel_flash_erase_block32___0(cfi_array_t *cfi_array___0 , uint32_t adr ) ;
#line 57
static int intel_flash_unlock_block32___0(cfi_array_t *cfi_array___0 , uint32_t adr ) ;
#line 58
static int intel_flash_program32_single___0(cfi_array_t *cfi_array___0 , uint32_t adr ,
                                            uint32_t data ) ;
#line 59
static int intel_flash_program32___0(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t *buffer ,
                                     int count ) ;
#line 62 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/intel.c"
static int intel_flash_autodetect32___0(cfi_array_t *cfi_array___0 ) 
{ 
  bus_area_t area___0 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 67
  tmp = (*(((cfi_array___0->bus)->driver)->area))(cfi_array___0->bus, cfi_array___0->address,
                                                  & area___0);
  }
#line 67
  if (tmp != 0) {
#line 68
    return (0);
  }
#line 70
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 256) {
#line 70
    goto _L;
  } else
#line 70
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 257) {
#line 70
    goto _L;
  } else
#line 70
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 1) {
#line 70
    goto _L;
  } else
#line 70
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 3) {
    _L: /* CIL Label */ 
#line 70
    if (area___0.width == 32U) {
#line 70
      tmp___0 = 1;
    } else {
#line 70
      tmp___0 = 0;
    }
  } else {
#line 70
    tmp___0 = 0;
  }
#line 70
  return (tmp___0);
}
}
#line 77 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/intel.c"
static int intel_flash_autodetect___0(cfi_array_t *cfi_array___0 ) 
{ 
  bus_area_t area___0 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 82
  tmp = (*(((cfi_array___0->bus)->driver)->area))(cfi_array___0->bus, cfi_array___0->address,
                                                  & area___0);
  }
#line 82
  if (tmp != 0) {
#line 83
    return (0);
  }
#line 85
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 256) {
#line 85
    goto _L;
  } else
#line 85
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 257) {
#line 85
    goto _L;
  } else
#line 85
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 1) {
#line 85
    goto _L;
  } else
#line 85
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 3) {
    _L: /* CIL Label */ 
#line 85
    if (area___0.width == 16U) {
#line 85
      tmp___0 = 1;
    } else {
#line 85
      tmp___0 = 0;
    }
  } else {
#line 85
    tmp___0 = 0;
  }
#line 85
  return (tmp___0);
}
}
#line 92 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/intel.c"
static int intel_flash_autodetect8___0(cfi_array_t *cfi_array___0 ) 
{ 
  bus_area_t area___0 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 97
  tmp = (*(((cfi_array___0->bus)->driver)->area))(cfi_array___0->bus, cfi_array___0->address,
                                                  & area___0);
  }
#line 97
  if (tmp != 0) {
#line 98
    return (0);
  }
#line 100
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 256) {
#line 100
    goto _L;
  } else
#line 100
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 257) {
#line 100
    goto _L;
  } else
#line 100
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 1) {
#line 100
    goto _L;
  } else
#line 100
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 3) {
    _L: /* CIL Label */ 
#line 100
    if (area___0.width == 8U) {
#line 100
      tmp___0 = 1;
    } else {
#line 100
      tmp___0 = 0;
    }
  } else {
#line 100
    tmp___0 = 0;
  }
#line 100
  return (tmp___0);
}
}
#line 107 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/intel.c"
static void _intel_flash_print_info___0(cfi_array_t *cfi_array___0 , int o ) 
{ 
  uint32_t mid ;
  uint32_t cid ;
  bus_t *bus___0 ;
  uint32_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  uint32_t tmp___5 ;
  char *tmp___6 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;

  {
  {
#line 111
  bus___0 = cfi_array___0->bus;
#line 113
  tmp = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 113
  mid = tmp & 255U;
  }
  {
#line 115
  if (mid == 137U) {
#line 115
    goto case_137;
  }
#line 118
  if (mid == 28U) {
#line 118
    goto case_28;
  }
#line 121
  if (mid == 44U) {
#line 121
    goto case_44;
  }
#line 124
  goto switch_default;
  case_137: /* CIL Label */ 
  {
#line 116
  tmp___0 = gettext("Manufacturer: %s\n");
#line 116
  printf((char const   */* __restrict  */)tmp___0, "Intel");
  }
#line 117
  goto switch_break;
  case_28: /* CIL Label */ 
  {
#line 119
  tmp___1 = gettext("Manufacturer: %s\n");
#line 119
  printf((char const   */* __restrict  */)tmp___1, "Mitsubishi");
  }
#line 120
  goto switch_break;
  case_44: /* CIL Label */ 
  {
#line 122
  tmp___2 = gettext("Manufacturer: %s\n");
#line 122
  printf((char const   */* __restrict  */)tmp___2, "Micron Technology");
  }
#line 123
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 125
  tmp___3 = gettext("Unknown manufacturer (0x%04X)!\n");
#line 125
  printf((char const   */* __restrict  */)tmp___3, mid);
  }
#line 126
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 129
  tmp___4 = gettext("Chip: ");
#line 129
  printf((char const   */* __restrict  */)tmp___4);
#line 130
  tmp___5 = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address + (uint32_t )(1 << o));
#line 130
  cid = tmp___5 & 65535U;
  }
  {
#line 132
  if (cid == 22U) {
#line 132
    goto case_22;
  }
#line 135
  if (cid == 23U) {
#line 135
    goto case_23;
  }
#line 138
  if (cid == 24U) {
#line 138
    goto case_24;
  }
#line 141
  if (cid == 29U) {
#line 141
    goto case_29;
  }
#line 144
  if (cid == 34817U) {
#line 144
    goto case_34817;
  }
#line 147
  if (cid == 34818U) {
#line 147
    goto case_34818;
  }
#line 150
  if (cid == 34819U) {
#line 150
    goto case_34819;
  }
#line 153
  if (cid == 34821U) {
#line 153
    goto case_34821;
  }
#line 156
  if (cid == 34822U) {
#line 156
    goto case_34822;
  }
#line 159
  if (cid == 34823U) {
#line 159
    goto case_34823;
  }
#line 162
  if (cid == 34827U) {
#line 162
    goto case_34827;
  }
#line 165
  if (cid == 34828U) {
#line 165
    goto case_34828;
  }
#line 168
  if (cid == 34829U) {
#line 168
    goto case_34829;
  }
#line 171
  if (cid == 34830U) {
#line 171
    goto case_34830;
  }
#line 174
  if (cid == 34831U) {
#line 174
    goto case_34831;
  }
#line 177
  if (cid == 34832U) {
#line 177
    goto case_34832;
  }
#line 180
  goto switch_default___0;
  case_22: /* CIL Label */ 
  {
#line 133
  printf((char const   */* __restrict  */)"28F320J3A\n");
  }
#line 134
  goto switch_break___0;
  case_23: /* CIL Label */ 
  {
#line 136
  printf((char const   */* __restrict  */)"28F640J3A\n");
  }
#line 137
  goto switch_break___0;
  case_24: /* CIL Label */ 
  {
#line 139
  printf((char const   */* __restrict  */)"28F128J3A\n");
  }
#line 140
  goto switch_break___0;
  case_29: /* CIL Label */ 
  {
#line 142
  printf((char const   */* __restrict  */)"28F256J3A\n");
  }
#line 143
  goto switch_break___0;
  case_34817: /* CIL Label */ 
  {
#line 145
  printf((char const   */* __restrict  */)"28F640K3\n");
  }
#line 146
  goto switch_break___0;
  case_34818: /* CIL Label */ 
  {
#line 148
  printf((char const   */* __restrict  */)"28F128K3\n");
  }
#line 149
  goto switch_break___0;
  case_34819: /* CIL Label */ 
  {
#line 151
  printf((char const   */* __restrict  */)"28F256K3\n");
  }
#line 152
  goto switch_break___0;
  case_34821: /* CIL Label */ 
  {
#line 154
  printf((char const   */* __restrict  */)"28F640K18\n");
  }
#line 155
  goto switch_break___0;
  case_34822: /* CIL Label */ 
  {
#line 157
  printf((char const   */* __restrict  */)"28F128K18\n");
  }
#line 158
  goto switch_break___0;
  case_34823: /* CIL Label */ 
  {
#line 160
  printf((char const   */* __restrict  */)"28F256K18\n");
  }
#line 161
  goto switch_break___0;
  case_34827: /* CIL Label */ 
  {
#line 163
  printf((char const   */* __restrict  */)"GE28F640L18T\n");
  }
#line 164
  goto switch_break___0;
  case_34828: /* CIL Label */ 
  {
#line 166
  printf((char const   */* __restrict  */)"GE28F128L18T\n");
  }
#line 167
  goto switch_break___0;
  case_34829: /* CIL Label */ 
  {
#line 169
  printf((char const   */* __restrict  */)"GE28F256L18T\n");
  }
#line 170
  goto switch_break___0;
  case_34830: /* CIL Label */ 
  {
#line 172
  printf((char const   */* __restrict  */)"GE28F640L18B\n");
  }
#line 173
  goto switch_break___0;
  case_34831: /* CIL Label */ 
  {
#line 175
  printf((char const   */* __restrict  */)"GE28F128L18B\n");
  }
#line 176
  goto switch_break___0;
  case_34832: /* CIL Label */ 
  {
#line 178
  printf((char const   */* __restrict  */)"GE28F256L18B\n");
  }
#line 179
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 181
  tmp___6 = gettext("Unknown (0x%02X)!\n");
#line 181
  printf((char const   */* __restrict  */)tmp___6, cid);
  }
#line 182
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 186
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )16711935);
  }
#line 187
  return;
}
}
#line 189 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/intel.c"
static void intel_flash_print_info___0(cfi_array_t *cfi_array___0 ) 
{ 
  int o ;
  bus_t *bus___0 ;

  {
  {
#line 192
  o = 1;
#line 193
  bus___0 = cfi_array___0->bus;
#line 199
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )80);
#line 202
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )144);
#line 204
  _intel_flash_print_info___0(cfi_array___0, o);
  }
#line 205
  return;
}
}
#line 207 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/intel.c"
static void intel_flash_print_info32___0(cfi_array_t *cfi_array___0 ) 
{ 
  int o ;
  bus_t *bus___0 ;

  {
  {
#line 210
  o = 2;
#line 211
  bus___0 = cfi_array___0->bus;
#line 216
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )5242960);
#line 219
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )9437328);
#line 221
  _intel_flash_print_info___0(cfi_array___0, o);
  }
#line 222
  return;
}
}
#line 224 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/intel.c"
static int intel_flash_erase_block___0(cfi_array_t *cfi_array___0 , uint32_t adr ) 
{ 
  uint16_t sr ;
  bus_t *bus___0 ;
  uint32_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 228
  bus___0 = cfi_array___0->bus;
#line 230
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )80);
#line 231
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )32);
#line 232
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )208);
  }
  {
#line 234
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 234
    tmp = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 234
    sr = (uint16_t )(tmp & 254U);
    }
#line 234
    if ((int )sr & (1 << 7)) {
#line 234
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 237
  if (((int )sr & ~ (1 << 7)) == 0) {
#line 237
    goto case_0;
  }
#line 239
  if (((int )sr & ~ (1 << 7)) == ((1 << 5) | (1 << 4))) {
#line 239
    goto case_exp;
  }
#line 242
  if (((int )sr & ~ (1 << 7)) == ((1 << 5) | (1 << 3))) {
#line 242
    goto case_exp___0;
  }
#line 245
  if (((int )sr & ~ (1 << 7)) == ((1 << 5) | (1 << 1))) {
#line 245
    goto case_exp___1;
  }
#line 248
  goto switch_default;
  case_0: /* CIL Label */ 
#line 238
  return (0);
  case_exp: /* CIL Label */ 
  {
#line 240
  tmp___0 = gettext("flash: invalid command seq\n");
#line 240
  printf((char const   */* __restrict  */)tmp___0);
  }
#line 241
  return (1);
  case_exp___0: /* CIL Label */ 
  {
#line 243
  tmp___1 = gettext("flash: low vpen\n");
#line 243
  printf((char const   */* __restrict  */)tmp___1);
  }
#line 244
  return (2);
  case_exp___1: /* CIL Label */ 
  {
#line 246
  tmp___2 = gettext("flash: block locked\n");
#line 246
  printf((char const   */* __restrict  */)tmp___2);
  }
#line 247
  return (3);
  switch_default: /* CIL Label */ 
#line 249
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 252
  return (99);
}
}
#line 255 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/intel.c"
static int intel_flash_unlock_block___0(cfi_array_t *cfi_array___0 , uint32_t adr ) 
{ 
  uint16_t sr ;
  bus_t *bus___0 ;
  uint32_t tmp ;
  char *tmp___0 ;
  char *__cil_tmp7 ;

  {
  {
#line 259
  bus___0 = cfi_array___0->bus;
#line 261
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )80);
#line 262
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )96);
#line 263
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )208);
  }
  {
#line 265
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 265
    tmp = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 265
    sr = (uint16_t )(tmp & 254U);
    }
#line 265
    if ((int )sr & (1 << 7)) {
#line 265
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 267
  if ((int )sr != 1 << 7) {
    {
#line 268
    tmp___0 = gettext("flash: unknown error while unblocking\n");
#line 268
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 269
    return (99);
  } else {
#line 271
    return (0);
  }
}
}
#line 274 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/intel.c"
static int intel_flash_program_single___0(cfi_array_t *cfi_array___0 , uint32_t adr ,
                                          uint32_t data ) 
{ 
  uint16_t sr ;
  bus_t *bus___0 ;
  uint32_t tmp ;
  char *tmp___0 ;
  char *__cil_tmp8 ;

  {
  {
#line 278
  bus___0 = cfi_array___0->bus;
#line 280
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )80);
#line 281
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )64);
#line 282
  (*((bus___0->driver)->write))(bus___0, adr, data);
  }
  {
#line 284
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 284
    tmp = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 284
    sr = (uint16_t )(tmp & 254U);
    }
#line 284
    if ((int )sr & (1 << 7)) {
#line 284
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 286
  if ((int )sr != 1 << 7) {
    {
#line 287
    tmp___0 = gettext("flash: unknown error while programming\n");
#line 287
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 288
    return (99);
  } else {
#line 290
    return (0);
  }
}
}
#line 293 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/intel.c"
static int intel_flash_program_buffer___0(cfi_array_t *cfi_array___0 , uint32_t adr ,
                                          uint32_t *buffer , int count ) 
{ 
  uint16_t sr ;
  bus_t *bus___0 ;
  cfi_chip_t *cfi_chip ;
  int wb_bytes ;
  int chip_width ;
  int offset ;
  int wcount ;
  int idx ;
  uint32_t block_adr ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp17 ;

  {
#line 298
  bus___0 = cfi_array___0->bus;
#line 299
  cfi_chip = *(cfi_array___0->cfi_chips + 0);
#line 300
  wb_bytes = (int )cfi_chip->cfi.device_geometry.max_bytes_write;
#line 301
  chip_width = cfi_chip->width;
#line 302
  offset = 0;
  {
#line 304
  while (1) {
    while_continue: /* CIL Label */ ;
#line 304
    if (! (count > 0)) {
#line 304
      goto while_break;
    }
#line 306
    block_adr = adr;
#line 309
    wcount = (int )((unsigned int )wb_bytes - adr % (unsigned int )wb_bytes);
#line 310
    wcount /= chip_width;
#line 311
    if (wcount > count) {
#line 312
      wcount = count;
    }
    {
#line 315
    (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )80);
#line 316
    (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )232);
    }
    {
#line 318
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 318
      tmp = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 318
      sr = (uint16_t )(tmp & 254U);
      }
#line 318
      if ((int )sr & (1 << 7)) {
#line 318
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 321
    (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )(wcount - 1));
#line 324
    idx = 0;
    }
    {
#line 324
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 324
      if (! (idx < wcount)) {
#line 324
        goto while_break___1;
      }
      {
#line 325
      (*((bus___0->driver)->write))(bus___0, adr, *(buffer + (offset + idx)));
#line 326
      adr += (uint32_t )cfi_array___0->bus_width;
#line 324
      idx ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 328
    offset += wcount;
#line 331
    (*((bus___0->driver)->write))(bus___0, block_adr, (uint32_t )208);
#line 333
    count -= wcount;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 337
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 337
    tmp___0 = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 337
    sr = (uint16_t )(tmp___0 & 254U);
    }
#line 337
    if ((int )sr & (1 << 7)) {
#line 337
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 338
  if ((int )sr != 1 << 7) {
    {
#line 339
    tmp___1 = gettext("flash: unknown error while programming\n");
#line 339
    printf((char const   */* __restrict  */)tmp___1);
    }
#line 340
    return (99);
  }
#line 343
  return (0);
}
}
#line 346 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/intel.c"
static int intel_flash_program___0(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t *buffer ,
                                   int count ) 
{ 
  cfi_query_structure_t *cfi ;
  int max_bytes_write ;
  int tmp ;
  int idx ;
  int status ;
  int tmp___0 ;

  {
#line 349
  cfi = & (*(cfi_array___0->cfi_chips + 0))->cfi;
#line 350
  max_bytes_write = (int )cfi->device_geometry.max_bytes_write;
#line 357
  if (max_bytes_write > 1) {
    {
#line 358
    tmp = intel_flash_program_buffer___0(cfi_array___0, adr, buffer, count);
    }
#line 358
    return (tmp);
  } else {
#line 364
    idx = 0;
    {
#line 364
    while (1) {
      while_continue: /* CIL Label */ ;
#line 364
      if (! (idx < count)) {
#line 364
        goto while_break;
      }
      {
#line 365
      tmp___0 = intel_flash_program_single___0(cfi_array___0, adr, *(buffer + idx));
#line 365
      status = tmp___0;
      }
#line 366
      if (status) {
#line 367
        return (status);
      }
#line 368
      adr += (uint32_t )cfi_array___0->bus_width;
#line 364
      idx ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 372
  return (0);
}
}
#line 375 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/intel.c"
static int intel_flash_erase_block32___0(cfi_array_t *cfi_array___0 , uint32_t adr ) 
{ 
  uint32_t sr ;
  bus_t *bus___0 ;
  uint32_t tmp ;
  char *__cil_tmp6 ;

  {
  {
#line 379
  bus___0 = cfi_array___0->bus;
#line 381
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )((80 << 16) | 80));
#line 382
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )((32 << 16) | 32));
#line 383
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )((208 << 16) | 208));
  }
  {
#line 385
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 385
    tmp = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 385
    sr = tmp & 16646398U;
    }
#line 385
    if (! ((sr & (unsigned int )(((1 << 7) << 16) | (1 << 7))) != (unsigned int )(((1 << 7) << 16) | (1 << 7)))) {
#line 385
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 387
  if (sr != (uint32_t )(((1 << 7) << 16) | (1 << 7))) {
    {
#line 388
    printf((char const   */* __restrict  */)"\nsr = 0x%08X\n", sr);
    }
#line 389
    return (99);
  } else {
#line 391
    return (0);
  }
}
}
#line 394 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/intel.c"
static int intel_flash_unlock_block32___0(cfi_array_t *cfi_array___0 , uint32_t adr ) 
{ 
  uint32_t sr ;
  bus_t *bus___0 ;
  uint32_t tmp ;
  char *__cil_tmp6 ;

  {
  {
#line 398
  bus___0 = cfi_array___0->bus;
#line 400
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )((80 << 16) | 80));
#line 401
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )((96 << 16) | 96));
#line 402
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )((208 << 16) | 208));
  }
  {
#line 404
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 404
    tmp = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 404
    sr = tmp & 16646398U;
    }
#line 404
    if (! ((sr & (unsigned int )(((1 << 7) << 16) | (1 << 7))) != (unsigned int )(((1 << 7) << 16) | (1 << 7)))) {
#line 404
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 406
  if (sr != (uint32_t )(((1 << 7) << 16) | (1 << 7))) {
    {
#line 407
    printf((char const   */* __restrict  */)"\nsr = 0x%08X\n", sr);
    }
#line 408
    return (99);
  } else {
#line 410
    return (0);
  }
}
}
#line 413 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/intel.c"
static int intel_flash_program32_single___0(cfi_array_t *cfi_array___0 , uint32_t adr ,
                                            uint32_t data ) 
{ 
  uint32_t sr ;
  bus_t *bus___0 ;
  uint32_t tmp ;
  char *__cil_tmp7 ;

  {
  {
#line 417
  bus___0 = cfi_array___0->bus;
#line 419
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )((80 << 16) | 80));
#line 420
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )((64 << 16) | 64));
#line 421
  (*((bus___0->driver)->write))(bus___0, adr, data);
  }
  {
#line 423
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 423
    tmp = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 423
    sr = tmp & 16646398U;
    }
#line 423
    if (! ((sr & (unsigned int )(((1 << 7) << 16) | (1 << 7))) != (unsigned int )(((1 << 7) << 16) | (1 << 7)))) {
#line 423
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 425
  if (sr != (uint32_t )(((1 << 7) << 16) | (1 << 7))) {
    {
#line 426
    printf((char const   */* __restrict  */)"\nsr = 0x%08X\n", sr);
    }
#line 427
    return (99);
  } else {
#line 429
    return (0);
  }
}
}
#line 432 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/intel.c"
static int intel_flash_program32___0(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t *buffer ,
                                     int count ) 
{ 
  int idx ;
  int status ;
  int tmp ;

  {
#line 442
  idx = 0;
  {
#line 442
  while (1) {
    while_continue: /* CIL Label */ ;
#line 442
    if (! (idx < count)) {
#line 442
      goto while_break;
    }
    {
#line 443
    tmp = intel_flash_program32_single___0(cfi_array___0, adr, *(buffer + idx));
#line 443
    status = tmp;
    }
#line 444
    if (status) {
#line 445
      return (status);
    }
#line 446
    adr += (uint32_t )cfi_array___0->bus_width;
#line 442
    idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 449
  return (0);
}
}
#line 452 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/intel.c"
static void intel_flash_readarray32___0(cfi_array_t *cfi_array___0 ) 
{ 


  {
  {
#line 456
  (*(((cfi_array___0->bus)->driver)->write))(cfi_array___0->bus, cfi_array___0->address,
                                             (uint32_t )16711935);
  }
#line 457
  return;
}
}
#line 459 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/intel.c"
static void intel_flash_readarray___0(cfi_array_t *cfi_array___0 ) 
{ 


  {
  {
#line 463
  (*(((cfi_array___0->bus)->driver)->write))(cfi_array___0->bus, cfi_array___0->address,
                                             (uint32_t )16711935);
  }
#line 464
  return;
}
}
#line 69 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/flash.c"
static flash_driver_t *flash_driver___0  =    (flash_driver_t *)((void *)0);
#line 71 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/flash.c"
static void set_flash_driver___0(void) 
{ 
  int i ;
  cfi_query_structure_t *cfi ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 77
  flash_driver___0 = (flash_driver_t *)((void *)0);
#line 78
  if ((unsigned long )cfi_array == (unsigned long )((void *)0)) {
#line 79
    return;
  }
#line 80
  cfi = & (*(cfi_array->cfi_chips + 0))->cfi;
#line 82
  i = 0;
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    if (! ((unsigned long )flash_drivers[i] != (unsigned long )((void *)0))) {
#line 82
      goto while_break;
    }
    {
#line 83
    tmp = (*((flash_drivers[i])->autodetect))(cfi_array);
    }
#line 83
    if (tmp) {
      {
#line 84
      flash_driver___0 = flash_drivers[i];
#line 85
      (*(flash_driver___0->print_info))(cfi_array);
      }
#line 86
      return;
    }
#line 82
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 89
  tmp___0 = gettext("unknown flash - vendor id: %d (0x%04x)\n");
#line 89
  printf((char const   */* __restrict  */)tmp___0, (int )cfi->identification_string.pri_id_code,
         (int )cfi->identification_string.pri_id_code);
#line 93
  tmp___1 = gettext("Flash not supported!\n");
#line 93
  printf((char const   */* __restrict  */)tmp___1);
  }
#line 94
  return;
}
}
#line 223 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/flash.c"
static int find_block___0(cfi_query_structure_t *cfi , int adr , int bus_width , int chip_width ,
                          int *bytes_until_next_block ) 
{ 
  int i ;
  int b ;
  int bb ;
  int region_blocks ;
  int flash_block_size ;
  int region_block_size ;
  int region_size ;
  int bir ;

  {
#line 227
  b = 0;
#line 228
  bb = 0;
#line 230
  i = 0;
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    if (! (i < (int )cfi->device_geometry.number_of_erase_regions)) {
#line 230
      goto while_break;
    }
#line 231
    region_blocks = (int )(cfi->device_geometry.erase_block_regions + i)->number_of_erase_blocks;
#line 232
    flash_block_size = (int )(cfi->device_geometry.erase_block_regions + i)->erase_block_size;
#line 233
    region_block_size = (bus_width / chip_width) * flash_block_size;
#line 234
    region_size = region_blocks * region_block_size;
#line 236
    if (adr < bb + region_size) {
#line 238
      bir = (adr - bb) / region_block_size;
#line 239
      *bytes_until_next_block = (bb + (bir + 1) * region_block_size) - adr;
#line 240
      return (b + bir);
    }
#line 242
    b += region_blocks;
#line 243
    bb += region_size;
#line 230
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 245
  return (-1);
}
}
#line 78 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/amd_flash.c"
static int amd_29xx040_autodetect___0(cfi_array_t *cfi_array___0 ) ;
#line 79
static int amd_29xx040_status___0(bus_t *bus___0 , uint32_t adr , unsigned short data ) ;
#line 80
static void amd_29xx040_print_info___0(cfi_array_t *cfi_array___0 ) ;
#line 81
static void amd_29xx040_read_array___0(cfi_array_t *cfi_array___0 ) ;
#line 82
static int amd_29xx040_erase_block___0(cfi_array_t *cfi_array___0 , uint32_t adr ) ;
#line 83
static int amd_29xx040_program_single___0(cfi_array_t *cfi_array___0 , uint32_t adr ,
                                          uint32_t data ) ;
#line 84
static int amd_29xx040_program___0(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t *buffer ,
                                   int count ) ;
#line 85
static int amd_29xx040_unlock_block___0(cfi_array_t *cfi_array___0 , uint32_t adr ) ;
#line 168 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/amd_flash.c"
static int amd_29xx040_autodetect___0(cfi_array_t *cfi_array___0 ) 
{ 


  {
#line 170
  return (var_forced_detection.flash == 1UL);
}
}
#line 173 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/amd_flash.c"
static int amd_29xx040_status___0(bus_t *bus___0 , uint32_t adr , unsigned short data ) 
{ 
  short timeout ;
  unsigned short dq7bit ;
  unsigned short dq7mask ;
  unsigned short dq5mask ;
  unsigned short data1 ;
  uint32_t tmp ;
  uint32_t tmp___0 ;

  {
#line 179
  dq7mask = (unsigned short )(1 << 7);
#line 180
  dq5mask = (unsigned short )(1 << 5);
#line 181
  dq7bit = (unsigned short )((int )data & (int )dq7mask);
#line 183
  timeout = (short)0;
  {
#line 183
  while (1) {
    while_continue: /* CIL Label */ ;
#line 183
    if (! ((int )timeout < 1000)) {
#line 183
      goto while_break;
    }
    {
#line 185
    tmp = (*((bus___0->driver)->read))(bus___0, adr);
#line 185
    data1 = (unsigned short )(tmp & 255U);
    }
#line 186
    if (((int )data1 & (int )dq7mask) == (int )dq7bit) {
#line 187
      return (1);
    }
#line 189
    if (((int )data1 & (int )dq5mask) == (int )dq5mask) {
      {
#line 191
      tmp___0 = (*((bus___0->driver)->read))(bus___0, adr);
#line 191
      data1 = (unsigned short )(tmp___0 & 255U);
      }
#line 192
      if (((int )data1 & (int )dq7mask) == (int )dq7bit) {
#line 194
        return (1);
      } else {
#line 198
        return (0);
      }
    }
    {
#line 201
    usleep((__useconds_t )50);
#line 183
    timeout = (short )((int )timeout + 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 204
  return (0);
}
}
#line 209 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/amd_flash.c"
static void amd_29xx040_print_info___0(cfi_array_t *cfi_array___0 ) 
{ 
  int mid ;
  int did ;
  int prot ;
  bus_t *bus___0 ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
  {
#line 212
  bus___0 = cfi_array___0->bus;
#line 215
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )240);
#line 216
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )170);
#line 217
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 682U, (uint32_t )85);
#line 218
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )144);
#line 219
  tmp = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 219
  mid = (int )tmp;
#line 220
  tmp___0 = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address + 1U);
#line 220
  did = (int )tmp___0;
#line 221
  tmp___1 = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address + 2U);
#line 221
  prot = (int )tmp___1;
#line 222
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )240);
#line 224
  printf((char const   */* __restrict  */)"%s: mid %x, did %x\n", "amd_29xx040_print_info",
         mid, did);
  }
  {
#line 229
  if (mid == 1) {
#line 229
    goto case_1;
  }
#line 232
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 230
  tmp___2 = gettext("Chip: AMD Flash\n\tPartNumber: ");
#line 230
  printf((char const   */* __restrict  */)tmp___2);
  }
#line 231
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 233
  tmp___3 = gettext("Unknown manufacturer (ID 0x%04x)");
#line 233
  printf((char const   */* __restrict  */)tmp___3, mid);
  }
#line 234
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 236
  tmp___4 = gettext("\n\tChip: ");
#line 236
  printf((char const   */* __restrict  */)tmp___4);
  }
  {
#line 238
  if (did == 164) {
#line 238
    goto case_164;
  }
#line 242
  if (did == 79) {
#line 242
    goto case_79;
  }
#line 246
  goto switch_default___0;
  case_164: /* CIL Label */ 
  {
#line 239
  printf((char const   */* __restrict  */)"Am29C040B\t-\t");
#line 240
  tmp___5 = gettext("5V Flash\n");
#line 240
  printf((char const   */* __restrict  */)tmp___5);
  }
#line 241
  goto switch_break___0;
  case_79: /* CIL Label */ 
  {
#line 243
  printf((char const   */* __restrict  */)"Am29LV040B\t-\t");
#line 244
  tmp___6 = gettext("3V Flash\n");
#line 244
  printf((char const   */* __restrict  */)tmp___6);
  }
#line 245
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 247
  tmp___7 = gettext("Unknown (ID 0x%04x)");
#line 247
  printf((char const   */* __restrict  */)tmp___7, did);
  }
#line 248
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 250
  tmp___8 = gettext("\n\tProtected: %04x\n");
#line 250
  printf((char const   */* __restrict  */)tmp___8, prot);
  }
#line 251
  return;
}
}
#line 253 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/amd_flash.c"
static void amd_29xx040_read_array___0(cfi_array_t *cfi_array___0 ) 
{ 


  {
#line 256
  if ((int )var_forced_detection.unlock_bypass == 1) {
    {
#line 258
    (*((bus->driver)->write))(bus, cfi_array___0->address + 1365U, (uint32_t )144);
#line 259
    (*((bus->driver)->write))(bus, cfi_array___0->address + 682U, (uint32_t )0);
#line 260
    usleep((__useconds_t )100);
#line 261
    var_forced_detection.unlock_bypass = (unsigned short)0;
    }
  }
  {
#line 263
  (*(((cfi_array___0->bus)->driver)->write))(cfi_array___0->bus, cfi_array___0->address,
                                             (uint32_t )240);
  }
#line 264
  return;
}
}
#line 268 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/amd_flash.c"
static int amd_29xx040_erase_block___0(cfi_array_t *cfi_array___0 , uint32_t adr ) 
{ 
  bus_t *bus___0 ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 270
  bus___0 = cfi_array___0->bus;
#line 272
  printf((char const   */* __restrict  */)"flash_erase_block 0x%08X\n", adr);
  }
#line 276
  if ((int )var_forced_detection.unlock_bypass == 1) {
    {
#line 278
    (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )144);
#line 279
    (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 682U, (uint32_t )0);
#line 280
    usleep((__useconds_t )100);
#line 281
    var_forced_detection.unlock_bypass = (unsigned short)0;
    }
  }
  {
#line 284
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )240);
#line 285
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )170);
#line 286
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 682U, (uint32_t )85);
#line 287
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )128);
#line 288
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )170);
#line 289
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 682U, (uint32_t )85);
#line 291
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )48);
#line 294
  tmp = amd_29xx040_status___0(bus___0, adr, (unsigned short)255);
  }
#line 294
  if (tmp) {
    {
#line 295
    printf((char const   */* __restrict  */)"flash_erase_block 0x%08X DONE\n", adr);
#line 296
    amd_29xx040_read_array___0(cfi_array___0);
    }
#line 297
    return (1);
  }
  {
#line 299
  printf((char const   */* __restrict  */)"flash_erase_block 0x%08X FAILED\n", adr);
#line 301
  amd_29xx040_read_array___0(cfi_array___0);
  }
#line 303
  return (-5);
}
}
#line 306 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/amd_flash.c"
static int amd_29xx040_program_single___0(cfi_array_t *cfi_array___0 , uint32_t adr ,
                                          uint32_t data ) 
{ 
  int status ;
  bus_t *bus___0 ;

  {
#line 309
  bus___0 = cfi_array___0->bus;
#line 313
  if ((int )var_forced_detection.algorithm == 1) {
#line 315
    if ((int )var_forced_detection.unlock_bypass != 1) {
      {
#line 317
      (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )170);
#line 318
      (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 682U, (uint32_t )85);
#line 319
      (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )32);
#line 320
      usleep((__useconds_t )1000);
#line 321
      var_forced_detection.unlock_bypass = (unsigned short)1;
      }
    }
  } else {
    {
#line 326
    (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )170);
#line 327
    (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 682U, (uint32_t )85);
    }
  }
  {
#line 330
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )160);
#line 331
  (*((bus___0->driver)->write))(bus___0, adr, data);
#line 332
  status = amd_29xx040_status___0(bus___0, adr, (unsigned short )data);
  }
#line 335
  return (! status);
}
}
#line 338 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/amd_flash.c"
static int amd_29xx040_program___0(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t *buffer ,
                                   int count ) 
{ 
  int idx ;
  int status ;
  int tmp ;

  {
#line 343
  idx = 0;
  {
#line 343
  while (1) {
    while_continue: /* CIL Label */ ;
#line 343
    if (! (idx < count)) {
#line 343
      goto while_break;
    }
    {
#line 344
    tmp = amd_29xx040_program_single___0(cfi_array___0, adr, *(buffer + idx));
#line 344
    status = tmp;
    }
#line 345
    if (status) {
#line 346
      return (status);
    }
#line 347
    adr += (uint32_t )cfi_array___0->bus_width;
#line 343
    idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 350
  return (0);
}
}
#line 353 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/amd_flash.c"
static int amd_29xx040_unlock_block___0(cfi_array_t *cfi_array___0 , uint32_t adr ) 
{ 
  char *__cil_tmp3 ;

  {
  {
#line 355
  printf((char const   */* __restrict  */)"flash_unlock_block 0x%08X IGNORE\n", adr);
  }
#line 356
  return (0);
}
}
#line 48 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/amd.c"
static int dbg___0  =    0;
#line 50
static int amd_flash_erase_block___0(cfi_array_t *cfi_array___0 , uint32_t adr ) ;
#line 51
static int amd_flash_unlock_block___0(cfi_array_t *cfi_array___0 , uint32_t adr ) ;
#line 52
static int amd_flash_program_single___0(cfi_array_t *cfi_array___0 , uint32_t adr ,
                                        uint32_t data ) ;
#line 53
static int amd_flash_program_buffer___0(cfi_array_t *cfi_array___0 , uint32_t adr ,
                                        uint32_t *buffer , int count ) ;
#line 54
static int amd_flash_program___0(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t *buffer ,
                                 int count ) ;
#line 55
static int amd_flash_program32___0(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t *buffer ,
                                   int count ) ;
#line 56
static void amd_flash_read_array___0(cfi_array_t *cfi_array___0 ) ;
#line 75 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/amd.c"
static int amd_flash_address_shift___0(cfi_array_t *cfi_array___0 ) 
{ 


  {
#line 78
  if (cfi_array___0->bus_width == 4) {
#line 78
    return (2);
  }
  {
#line 85
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.device_geometry.device_interface == 1) {
#line 85
    goto case_1;
  }
#line 85
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.device_geometry.device_interface == 2) {
#line 85
    goto case_1;
  }
#line 89
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.device_geometry.device_interface == 3) {
#line 89
    goto case_3;
  }
#line 89
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.device_geometry.device_interface == 4) {
#line 89
    goto case_3;
  }
#line 92
  goto switch_default;
  case_1: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 86
  return (1);
  case_3: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 90
  return (2);
  switch_default: /* CIL Label */ 
#line 92
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 95
  if (cfi_array___0->bus_width == 2) {
#line 95
    return (1);
  }
#line 97
  return (0);
}
}
#line 101 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/amd.c"
static int amd_flash_autodetect32___0(cfi_array_t *cfi_array___0 ) 
{ 


  {
#line 104
  if (cfi_array___0->bus_width != 4) {
#line 104
    return (0);
  }
#line 105
  return ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 2);
}
}
#line 108 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/amd.c"
static int amd_flash_autodetect16___0(cfi_array_t *cfi_array___0 ) 
{ 


  {
#line 111
  if (cfi_array___0->bus_width != 2) {
#line 111
    return (0);
  }
#line 112
  return ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 2);
}
}
#line 115 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/amd.c"
static int amd_flash_autodetect8___0(cfi_array_t *cfi_array___0 ) 
{ 


  {
#line 118
  if (cfi_array___0->bus_width != 1) {
#line 118
    return (0);
  }
#line 119
  return ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 2);
}
}
#line 167 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/amd.c"
static int amdstatus___0(cfi_array_t *cfi_array___0 , uint32_t adr , int data ) 
{ 
  bus_t *bus___0 ;
  int timeout ;
  uint32_t togglemask ;
  uint32_t data1 ;
  uint32_t tmp ;
  uint32_t data2 ;
  uint32_t tmp___0 ;
  char *__cil_tmp11 ;

  {
#line 170
  bus___0 = cfi_array___0->bus;
#line 173
  togglemask = (uint32_t )(((1 << 6) << 16) + (1 << 6));
#line 176
  timeout = 0;
  {
#line 176
  while (1) {
    while_continue: /* CIL Label */ ;
#line 176
    if (! (timeout < 7000)) {
#line 176
      goto while_break;
    }
    {
#line 177
    tmp = (*((bus___0->driver)->read))(bus___0, adr);
#line 177
    data1 = tmp;
#line 178
    tmp___0 = (*((bus___0->driver)->read))(bus___0, adr);
#line 178
    data2 = tmp___0;
    }
#line 182
    if ((data1 & togglemask) == (data2 & togglemask)) {
#line 183
      return (1);
    }
#line 187
    if (dbg___0) {
      {
#line 188
      printf((char const   */* __restrict  */)"amdstatus %d: %04X/%04X\n", timeout,
             data1, data2);
      }
    }
    {
#line 189
    usleep((__useconds_t )100);
#line 176
    timeout ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 191
  return (0);
}
}
#line 265 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/amd.c"
static void amd_flash_print_info___0(cfi_array_t *cfi_array___0 ) 
{ 
  int mid ;
  int cid ;
  int prot ;
  bus_t *bus___0 ;
  int o ;
  int tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;

  {
  {
#line 269
  bus___0 = cfi_array___0->bus;
#line 270
  tmp = amd_flash_address_shift___0(cfi_array___0);
#line 270
  o = tmp;
#line 272
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(1365 << o),
                                (uint32_t )11141290);
#line 273
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(682 << o),
                                (uint32_t )5570645);
#line 274
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(1365 << o),
                                (uint32_t )9437328);
#line 275
  tmp___0 = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 275
  mid = (int )(tmp___0 & 65535U);
#line 276
  tmp___1 = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address + (uint32_t )(1 << o));
#line 276
  cid = (int )(tmp___1 & 65535U);
#line 277
  tmp___2 = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address + (uint32_t )(2 << o));
#line 277
  prot = (int )(tmp___2 & 255U);
#line 278
  amd_flash_read_array___0(cfi_array___0);
#line 279
  tmp___3 = gettext("Chip: AMD Flash\n\tManufacturer: ");
#line 279
  printf((char const   */* __restrict  */)tmp___3);
  }
  {
#line 281
  if (mid == 1) {
#line 281
    goto case_1;
  }
#line 309
  if (mid == 31) {
#line 309
    goto case_31;
  }
#line 324
  if (mid == 32) {
#line 324
    goto case_32;
  }
#line 342
  if (mid == 194) {
#line 342
    goto case_194;
  }
#line 357
  goto switch_default___3;
  case_1: /* CIL Label */ 
  {
#line 282
  printf((char const   */* __restrict  */)"AMD");
#line 283
  tmp___4 = gettext("\n\tChip: ");
#line 283
  printf((char const   */* __restrict  */)tmp___4);
  }
  {
#line 285
  if (cid == 73) {
#line 285
    goto case_73;
  }
#line 288
  if (cid == 147) {
#line 288
    goto case_147;
  }
#line 291
  if (cid == 79) {
#line 291
    goto case_79;
  }
#line 294
  if (cid == 8919) {
#line 294
    goto case_8919;
  }
#line 297
  if (cid == 8795) {
#line 297
    goto case_8795;
  }
#line 301
  if (cid == 126) {
#line 301
    goto case_126;
  }
#line 301
  if (cid == 8830) {
#line 301
    goto case_126;
  }
#line 304
  goto switch_default;
  case_73: /* CIL Label */ 
  {
#line 286
  printf((char const   */* __restrict  */)"AM29LV160DB");
  }
#line 287
  goto switch_break___0;
  case_147: /* CIL Label */ 
  {
#line 289
  printf((char const   */* __restrict  */)"Am29LV065D");
  }
#line 290
  goto switch_break___0;
  case_79: /* CIL Label */ 
  {
#line 292
  printf((char const   */* __restrict  */)"Am29LV040B");
  }
#line 293
  goto switch_break___0;
  case_8919: /* CIL Label */ 
  {
#line 295
  printf((char const   */* __restrict  */)"Am29LV640D/Am29LV641D/Am29LV642D");
  }
#line 296
  goto switch_break___0;
  case_8795: /* CIL Label */ 
  {
#line 298
  printf((char const   */* __restrict  */)"Am29LV800B");
  }
#line 299
  goto switch_break___0;
  case_126: /* CIL Label */ 
  case_8830: /* CIL Label */ 
  {
#line 302
  printf((char const   */* __restrict  */)"S92GLxxxN");
  }
#line 303
  goto switch_break___0;
  switch_default: /* CIL Label */ 
  {
#line 305
  tmp___5 = gettext("Unknown (ID 0x%04x)");
#line 305
  printf((char const   */* __restrict  */)tmp___5, cid);
  }
#line 306
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 308
  goto switch_break;
  case_31: /* CIL Label */ 
  {
#line 310
  printf((char const   */* __restrict  */)"Atmel");
#line 311
  tmp___6 = gettext("\n\tChip: ");
#line 311
  printf((char const   */* __restrict  */)tmp___6);
  }
  {
#line 313
  if (cid == 466) {
#line 313
    goto case_466;
  }
#line 316
  if (cid == 470) {
#line 316
    goto case_470;
  }
#line 319
  goto switch_default___0;
  case_466: /* CIL Label */ 
  {
#line 314
  printf((char const   */* __restrict  */)"AT49BW642DT");
  }
#line 315
  goto switch_break___1;
  case_470: /* CIL Label */ 
  {
#line 317
  printf((char const   */* __restrict  */)"AT49BW642D");
  }
#line 318
  goto switch_break___1;
  switch_default___0: /* CIL Label */ 
  {
#line 320
  tmp___7 = gettext("Unknown (ID 0x%04x)");
#line 320
  printf((char const   */* __restrict  */)tmp___7, cid);
  }
#line 321
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 323
  goto switch_break;
  case_32: /* CIL Label */ 
  {
#line 325
  printf((char const   */* __restrict  */)"ST/Samsung");
#line 326
  tmp___8 = gettext("\n\tChip: ");
#line 326
  printf((char const   */* __restrict  */)tmp___8);
  }
  {
#line 328
  if (cid == 202) {
#line 328
    goto case_202;
  }
#line 331
  if (cid == 203) {
#line 331
    goto case_203;
  }
#line 334
  if (cid == 8941) {
#line 334
    goto case_8941;
  }
#line 337
  goto switch_default___1;
  case_202: /* CIL Label */ 
  {
#line 329
  printf((char const   */* __restrict  */)"M29W320DT");
  }
#line 330
  goto switch_break___2;
  case_203: /* CIL Label */ 
  {
#line 332
  printf((char const   */* __restrict  */)"M29W320DB");
  }
#line 333
  goto switch_break___2;
  case_8941: /* CIL Label */ 
  {
#line 335
  printf((char const   */* __restrict  */)"M29W640DT");
  }
#line 336
  goto switch_break___2;
  switch_default___1: /* CIL Label */ 
  {
#line 338
  tmp___9 = gettext("Unknown (ID 0x%04x)");
#line 338
  printf((char const   */* __restrict  */)tmp___9, cid);
  }
#line 339
  goto switch_break___2;
  switch_break___2: /* CIL Label */ ;
  }
#line 341
  goto switch_break;
  case_194: /* CIL Label */ 
  {
#line 343
  printf((char const   */* __restrict  */)"Macronix");
#line 344
  tmp___10 = gettext("\n\tChip: ");
#line 344
  printf((char const   */* __restrict  */)tmp___10);
  }
  {
#line 346
  if (cid == 8777) {
#line 346
    goto case_8777;
  }
#line 349
  if (cid == 8907) {
#line 349
    goto case_8907;
  }
#line 352
  goto switch_default___2;
  case_8777: /* CIL Label */ 
  {
#line 347
  printf((char const   */* __restrict  */)"MX29LV160B");
  }
#line 348
  goto switch_break___3;
  case_8907: /* CIL Label */ 
  {
#line 350
  printf((char const   */* __restrict  */)"MX29LV640B");
  }
#line 351
  goto switch_break___3;
  switch_default___2: /* CIL Label */ 
  {
#line 353
  tmp___11 = gettext("Unknown (ID 0x%04x)");
#line 353
  printf((char const   */* __restrict  */)tmp___11, cid);
  }
#line 354
  goto switch_break___3;
  switch_break___3: /* CIL Label */ ;
  }
#line 356
  goto switch_break;
  switch_default___3: /* CIL Label */ 
  {
#line 358
  tmp___12 = gettext("Unknown manufacturer (ID 0x%04x) Chip (ID 0x%04x)");
#line 358
  printf((char const   */* __restrict  */)tmp___12, mid, cid);
  }
#line 359
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 361
  tmp___13 = gettext("\n\tProtected: %04x\n");
#line 361
  printf((char const   */* __restrict  */)tmp___13, prot);
#line 364
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )16711935);
  }
#line 365
  return;
}
}
#line 367 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/amd.c"
static int amd_flash_erase_block___0(cfi_array_t *cfi_array___0 , uint32_t adr ) 
{ 
  bus_t *bus___0 ;
  int o ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 370
  bus___0 = cfi_array___0->bus;
#line 371
  tmp = amd_flash_address_shift___0(cfi_array___0);
#line 371
  o = tmp;
#line 373
  printf((char const   */* __restrict  */)"flash_erase_block 0x%08X\n", adr);
#line 377
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(1365 << o),
                                (uint32_t )11141290);
#line 378
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(682 << o),
                                (uint32_t )5570645);
#line 379
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(1365 << o),
                                (uint32_t )8388736);
#line 380
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(1365 << o),
                                (uint32_t )11141290);
#line 381
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(682 << o),
                                (uint32_t )5570645);
#line 382
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )3145776);
#line 384
  tmp___0 = amdstatus___0(cfi_array___0, adr, 65535);
  }
#line 384
  if (tmp___0) {
    {
#line 385
    printf((char const   */* __restrict  */)"flash_erase_block 0x%08X DONE\n", adr);
#line 386
    amd_flash_read_array___0(cfi_array___0);
    }
#line 387
    return (0);
  }
  {
#line 389
  printf((char const   */* __restrict  */)"flash_erase_block 0x%08X FAILED\n", adr);
#line 391
  amd_flash_read_array___0(cfi_array___0);
  }
#line 393
  return (99);
}
}
#line 396 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/amd.c"
static int amd_flash_unlock_block___0(cfi_array_t *cfi_array___0 , uint32_t adr ) 
{ 
  char *__cil_tmp3 ;

  {
  {
#line 399
  printf((char const   */* __restrict  */)"flash_unlock_block 0x%08X IGNORE\n", adr);
  }
#line 400
  return (0);
}
}
#line 403 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/amd.c"
static int amd_flash_program_single___0(cfi_array_t *cfi_array___0 , uint32_t adr ,
                                        uint32_t data ) 
{ 
  int status ;
  bus_t *bus___0 ;
  int o ;
  int tmp ;
  char *__cil_tmp8 ;

  {
  {
#line 407
  bus___0 = cfi_array___0->bus;
#line 408
  tmp = amd_flash_address_shift___0(cfi_array___0);
#line 408
  o = tmp;
  }
#line 410
  if (dbg___0) {
    {
#line 411
    printf((char const   */* __restrict  */)"\nflash_program 0x%08X = 0x%08X\n", adr,
           data);
    }
  }
  {
#line 413
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(1365 << o),
                                (uint32_t )11141290);
#line 414
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(682 << o),
                                (uint32_t )5570645);
#line 415
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(1365 << o),
                                (uint32_t )10485920);
#line 417
  (*((bus___0->driver)->write))(bus___0, adr, data);
#line 418
  status = amdstatus___0(cfi_array___0, adr, (int )data);
  }
#line 421
  return (! status);
}
}
#line 424 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/amd.c"
static int amd_program_buffer_status___0(cfi_array_t *cfi_array___0 , uint32_t adr ,
                                         uint32_t data ) 
{ 
  bus_t *bus___0 ;
  int timeout ;
  uint32_t dq7mask ;
  uint32_t dq5mask ;
  uint32_t bit7 ;
  uint32_t data1 ;
  char *__cil_tmp10 ;

  {
#line 430
  bus___0 = cfi_array___0->bus;
#line 432
  dq7mask = (uint32_t )(1 << 7);
#line 433
  dq5mask = (uint32_t )(1 << 5);
#line 434
  bit7 = data & dq7mask;
#line 437
  timeout = 0;
  {
#line 437
  while (1) {
    while_continue: /* CIL Label */ ;
#line 437
    if (! (timeout < 7000)) {
#line 437
      goto while_break;
    }
    {
#line 438
    data1 = (*((bus___0->driver)->read))(bus___0, adr);
    }
#line 439
    if (dbg___0) {
      {
#line 440
      printf((char const   */* __restrict  */)"amd_program_buffer_status %d: %04X (%04X) = %04X\n",
             timeout, data1, data1 & dq7mask, bit7);
      }
    }
#line 441
    if ((data1 & dq7mask) == bit7) {
#line 442
      return (1);
    }
#line 444
    if ((data1 & dq5mask) == dq5mask) {
#line 445
      goto while_break;
    }
    {
#line 446
    usleep((__useconds_t )100);
#line 437
    timeout ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 449
  data1 = (*((bus___0->driver)->read))(bus___0, adr);
  }
#line 450
  if ((data1 & dq7mask) == bit7) {
#line 451
    return (1);
  }
#line 453
  return (0);
}
}
#line 456 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/amd.c"
static int amd_flash_program_buffer___0(cfi_array_t *cfi_array___0 , uint32_t adr ,
                                        uint32_t *buffer , int count ) 
{ 
  int status ;
  bus_t *bus___0 ;
  cfi_chip_t *cfi_chip ;
  int o ;
  int tmp ;
  int wb_bytes ;
  int chip_width ;
  int offset ;
  int wcount ;
  int idx ;
  uint32_t sa ;
  char *__cil_tmp16 ;

  {
  {
#line 461
  bus___0 = cfi_array___0->bus;
#line 462
  cfi_chip = *(cfi_array___0->cfi_chips + 0);
#line 463
  tmp = amd_flash_address_shift___0(cfi_array___0);
#line 463
  o = tmp;
#line 464
  wb_bytes = (int )cfi_chip->cfi.device_geometry.max_bytes_write;
#line 465
  chip_width = cfi_chip->width;
#line 466
  offset = 0;
  }
#line 468
  if (dbg___0) {
    {
#line 469
    printf((char const   */* __restrict  */)"\nflash_program_buffer 0x%08X, count 0x%08X\n",
           adr, count);
    }
  }
  {
#line 471
  while (1) {
    while_continue: /* CIL Label */ ;
#line 471
    if (! (count > 0)) {
#line 471
      goto while_break;
    }
#line 473
    sa = adr;
#line 476
    wcount = (int )((unsigned int )wb_bytes - adr % (unsigned int )wb_bytes);
#line 477
    wcount /= chip_width;
#line 478
    if (wcount > count) {
#line 479
      wcount = count;
    }
    {
#line 481
    (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(1365 << o),
                                  (uint32_t )11141290);
#line 482
    (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(682 << o),
                                  (uint32_t )5570645);
#line 483
    (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )2424869);
#line 484
    (*((bus___0->driver)->write))(bus___0, sa, (uint32_t )(wcount - 1));
#line 487
    idx = 0;
    }
    {
#line 487
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 487
      if (! (idx < wcount)) {
#line 487
        goto while_break___0;
      }
      {
#line 488
      (*((bus___0->driver)->write))(bus___0, adr, *(buffer + (offset + idx)));
#line 489
      adr += (uint32_t )cfi_array___0->bus_width;
#line 487
      idx ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 491
    offset += wcount;
#line 494
    (*((bus___0->driver)->write))(bus___0, sa, (uint32_t )2687017);
#line 496
    status = amd_program_buffer_status___0(cfi_array___0, adr - (uint32_t )cfi_array___0->bus_width,
                                           *(buffer + (offset - 1)));
    }
#line 498
    if (status != 1) {
#line 499
      return (1);
    }
#line 501
    count -= wcount;
  }
  while_break: /* CIL Label */ ;
  }
#line 504
  return (0);
}
}
#line 507 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/amd.c"
static int amd_flash_program___0(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t *buffer ,
                                 int count ) 
{ 
  cfi_query_structure_t *cfi ;
  int max_bytes_write ;
  int tmp ;
  int idx ;
  int status ;
  int tmp___0 ;

  {
#line 510
  cfi = & (*(cfi_array___0->cfi_chips + 0))->cfi;
#line 511
  max_bytes_write = (int )cfi->device_geometry.max_bytes_write;
#line 518
  if (max_bytes_write > 1) {
    {
#line 519
    tmp = amd_flash_program_buffer___0(cfi_array___0, adr, buffer, count);
    }
#line 519
    return (tmp);
  } else {
#line 525
    idx = 0;
    {
#line 525
    while (1) {
      while_continue: /* CIL Label */ ;
#line 525
      if (! (idx < count)) {
#line 525
        goto while_break;
      }
      {
#line 526
      tmp___0 = amd_flash_program_single___0(cfi_array___0, adr, *(buffer + idx));
#line 526
      status = tmp___0;
      }
#line 527
      if (status) {
#line 528
        return (status);
      }
#line 529
      adr += (uint32_t )cfi_array___0->bus_width;
#line 525
      idx ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 533
  return (0);
}
}
#line 536 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/amd.c"
static int amd_flash_program32___0(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t *buffer ,
                                   int count ) 
{ 
  int idx ;
  int status ;
  int tmp ;

  {
#line 547
  idx = 0;
  {
#line 547
  while (1) {
    while_continue: /* CIL Label */ ;
#line 547
    if (! (idx < count)) {
#line 547
      goto while_break;
    }
    {
#line 548
    tmp = amd_flash_program_single___0(cfi_array___0, adr, *(buffer + idx));
#line 548
    status = tmp;
    }
#line 549
    if (status) {
#line 550
      return (status);
    }
#line 551
    adr += (uint32_t )cfi_array___0->bus_width;
#line 547
    idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 554
  return (0);
}
}
#line 557 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/flash/amd.c"
static void amd_flash_read_array___0(cfi_array_t *cfi_array___0 ) 
{ 


  {
  {
#line 561
  (*(((cfi_array___0->bus)->driver)->write))(cfi_array___0->bus, cfi_array___0->address,
                                             (uint32_t )15728880);
  }
#line 562
  return;
}
}
#line 336 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) int clock_gettime(clockid_t __clock_id , struct timespec *__tp ) ;
#line 346 "/usr/include/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) int __fpclassify(double __value )  __attribute__((__const__)) ;
#line 346
extern  __attribute__((__nothrow__)) int __fpclassifyf(float __value )  __attribute__((__const__)) ;
#line 346
extern  __attribute__((__nothrow__)) int __fpclassifyl(long double __value )  __attribute__((__const__)) ;
#line 71 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void __assert_fail(char const   *__assertion ,
                                                                      char const   *__file ,
                                                                      unsigned int __line ,
                                                                      char const   *__function ) ;
#line 73 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/lib/fclock.c"
long double frealtime(void) 
{ 
  long double result ;
  struct timespec t ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 79
  tmp = clock_gettime(0, & t);
  }
#line 79
  if (tmp == -1) {
    {
#line 80
    perror("frealtime (clock_gettime)");
#line 81
    exit(1);
    }
  }
#line 83
  result = (long double )t.tv_sec + (long double )t.tv_nsec * (long double )1e-9;
#line 85
  if (sizeof(result) == sizeof(float )) {
    {
#line 85
    tmp___0 = __fpclassifyf((float )result);
#line 85
    tmp___4 = tmp___0;
    }
  } else {
#line 85
    if (sizeof(result) == sizeof(double )) {
      {
#line 85
      tmp___1 = __fpclassify((double )result);
#line 85
      tmp___3 = tmp___1;
      }
    } else {
      {
#line 85
      tmp___2 = __fpclassifyl(result);
#line 85
      tmp___3 = tmp___2;
      }
    }
#line 85
    tmp___4 = tmp___3;
  }
#line 85
  if (! (tmp___4 == 4)) {
    {
#line 85
    __assert_fail("((sizeof (result) == sizeof (float) ? __fpclassifyf (result) : sizeof (result) == sizeof (double) ? __fpclassify (result) : __fpclassifyl (result)) == FP_NORMAL)",
                  "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/lib/fclock.c",
                  85U, "frealtime");
    }
  }
#line 86
  if (! (result > (long double )0)) {
    {
#line 86
    __assert_fail("result > 0", "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/lib/fclock.c",
                  86U, "frealtime");
    }
  }
#line 87
  return (result);
}
}
#line 49 "../../include/bssignal.h"
signal_t *signal_alloc(char const   *name ) ;
#line 50
void signal_free(signal_t *s ) ;
#line 52
salias_t *salias_alloc(char const   *name , signal_t const   *signal ) ;
#line 53
void salias_free(salias_t *salias ) ;
#line 30 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/part/signal.c"
signal_t *signal_alloc(char const   *name ) 
{ 
  signal_t *s ;
  void *tmp ;

  {
  {
#line 33
  tmp = malloc((size_t )sizeof(*s));
#line 33
  s = (signal_t *)tmp;
  }
#line 34
  if (! s) {
#line 35
    return ((signal_t *)((void *)0));
  }
  {
#line 37
  s->name = strdup(name);
  }
#line 38
  if (! s->name) {
    {
#line 39
    free((void *)s);
    }
#line 40
    return ((signal_t *)((void *)0));
  }
#line 42
  s->pin = (char *)((void *)0);
#line 43
  s->next = (signal_t *)((void *)0);
#line 44
  s->input = (bsbit_t *)((void *)0);
#line 45
  s->output = (bsbit_t *)((void *)0);
#line 47
  return (s);
}
}
#line 50 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/part/signal.c"
void signal_free(signal_t *s ) 
{ 


  {
#line 53
  if (! s) {
#line 54
    return;
  }
  {
#line 55
  free((void *)s->name);
#line 56
  free((void *)s);
  }
#line 57
  return;
}
}
#line 59 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/part/signal.c"
salias_t *salias_alloc(char const   *name , signal_t const   *signal ) 
{ 
  salias_t *sa ;
  void *tmp ;

  {
  {
#line 62
  tmp = malloc((size_t )sizeof(*sa));
#line 62
  sa = (salias_t *)tmp;
  }
#line 63
  if ((unsigned long )sa == (unsigned long )((void *)0)) {
#line 64
    return ((salias_t *)((void *)0));
  }
  {
#line 66
  sa->name = strdup(name);
  }
#line 67
  if ((unsigned long )sa->name == (unsigned long )((void *)0)) {
    {
#line 68
    free((void *)sa);
    }
#line 69
    return ((salias_t *)((void *)0));
  }
#line 71
  sa->next = (salias_t *)((void *)0);
#line 72
  sa->signal = (signal_t *)signal;
#line 74
  return (sa);
}
}
#line 77 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/part/signal.c"
void salias_free(salias_t *salias ) 
{ 


  {
#line 79
  if ((unsigned long )salias == (unsigned long )((void *)0)) {
#line 80
    return;
  }
  {
#line 81
  free((void *)salias->name);
#line 82
  free((void *)salias);
  }
#line 83
  return;
}
}
#line 52 "../../include/bsbit.h"
void bsbit_free(bsbit_t *b ) ;
#line 42 "../../include/data_register.h"
void data_register_free(data_register *dr ) ;
#line 44 "../../include/instruction.h"
void instruction_free(instruction *i ) ;
#line 58 "../../include/part.h"
void part_free(part_t *p ) ;
#line 66
void part_print(part_t *p ) ;
#line 79
void parts_print(parts_t *ps ) ;
#line 34 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/part/part.c"
part_t *part_alloc(tap_register const   *id ) 
{ 
  part_t *p ;
  void *tmp ;

  {
  {
#line 37
  tmp = malloc((size_t )sizeof(*p));
#line 37
  p = (part_t *)tmp;
  }
#line 38
  if (! p) {
#line 39
    return ((part_t *)((void *)0));
  }
  {
#line 40
  p->alias = (char *)((void *)0);
#line 41
  p->id = register_duplicate(id);
#line 42
  p->manufacturer[0] = (char )'\000';
#line 43
  p->part[0] = (char )'\000';
#line 44
  p->stepping[0] = (char )'\000';
#line 45
  p->signals = (signal_t *)((void *)0);
#line 46
  p->saliases = (salias_t *)((void *)0);
#line 47
  p->instruction_length = 0;
#line 48
  p->instructions = (instruction *)((void *)0);
#line 49
  p->active_instruction = (instruction *)((void *)0);
#line 50
  p->data_registers = (data_register *)((void *)0);
#line 51
  p->boundary_length = 0;
#line 52
  p->bsbits = (bsbit_t **)((void *)0);
  }
#line 54
  return (p);
}
}
#line 57 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/part/part.c"
void part_free(part_t *p ) 
{ 
  int i ;
  signal_t *s ;
  salias_t *sa ;
  instruction *i___0 ;
  data_register *dr ;

  {
#line 62
  if (! p) {
#line 63
    return;
  }
  {
#line 66
  free((void *)p->id);
  }
#line 68
  if (p->alias) {
    {
#line 68
    free((void *)p->alias);
    }
  }
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
#line 71
    if (! p->signals) {
#line 71
      goto while_break;
    }
    {
#line 72
    s = p->signals;
#line 73
    p->signals = s->next;
#line 74
    signal_free(s);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 78
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 78
    if (! p->saliases) {
#line 78
      goto while_break___0;
    }
    {
#line 79
    sa = p->saliases;
#line 80
    p->saliases = sa->next;
#line 81
    salias_free(sa);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 85
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 85
    if (! p->instructions) {
#line 85
      goto while_break___1;
    }
    {
#line 86
    i___0 = p->instructions;
#line 87
    p->instructions = i___0->next;
#line 88
    instruction_free(i___0);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 92
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 92
    if (! p->data_registers) {
#line 92
      goto while_break___2;
    }
    {
#line 93
    dr = p->data_registers;
#line 94
    p->data_registers = dr->next;
#line 95
    data_register_free(dr);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 99
  i = 0;
  {
#line 99
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 99
    if (! (i < p->boundary_length)) {
#line 99
      goto while_break___3;
    }
    {
#line 100
    bsbit_free(*(p->bsbits + i));
#line 99
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 101
  free((void *)p->bsbits);
#line 103
  free((void *)p);
  }
#line 104
  return;
}
}
#line 106 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/part/part.c"
instruction *part_find_instruction(part_t *p , char const   *iname ) 
{ 
  instruction *i ;
  int tmp ;

  {
#line 111
  if (! p) {
#line 112
    return ((instruction *)((void *)0));
  } else
#line 111
  if (! iname) {
#line 112
    return ((instruction *)((void *)0));
  }
#line 114
  i = p->instructions;
  {
#line 115
  while (1) {
    while_continue: /* CIL Label */ ;
#line 115
    if (! i) {
#line 115
      goto while_break;
    }
    {
#line 116
    tmp = strcasecmp(iname, (char const   *)(i->name));
    }
#line 116
    if (tmp == 0) {
#line 117
      goto while_break;
    }
#line 118
    i = i->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 121
  return (i);
}
}
#line 124 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/part/part.c"
data_register *part_find_data_register(part_t *p , char const   *drname ) 
{ 
  data_register *dr ;
  int tmp ;

  {
#line 129
  if (! p) {
#line 130
    return ((data_register *)((void *)0));
  } else
#line 129
  if (! drname) {
#line 130
    return ((data_register *)((void *)0));
  }
#line 132
  dr = p->data_registers;
  {
#line 133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 133
    if (! dr) {
#line 133
      goto while_break;
    }
    {
#line 134
    tmp = strcasecmp(drname, (char const   *)(dr->name));
    }
#line 134
    if (tmp == 0) {
#line 135
      goto while_break;
    }
#line 136
    dr = dr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 139
  return (dr);
}
}
#line 142 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/part/part.c"
signal_t *part_find_signal(part_t *p , char const   *signalname ) 
{ 
  signal_t *s ;
  salias_t *sa ;
  int tmp ;
  int tmp___0 ;

  {
#line 148
  if (! p) {
#line 149
    return ((signal_t *)((void *)0));
  } else
#line 148
  if (! signalname) {
#line 149
    return ((signal_t *)((void *)0));
  }
#line 151
  s = p->signals;
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 152
    if (! s) {
#line 152
      goto while_break;
    }
    {
#line 153
    tmp = strcasecmp(signalname, (char const   *)s->name);
    }
#line 153
    if (tmp == 0) {
#line 154
      return (s);
    }
#line 155
    s = s->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 158
  sa = p->saliases;
  {
#line 159
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 159
    if (! sa) {
#line 159
      goto while_break___0;
    }
    {
#line 160
    tmp___0 = strcasecmp(signalname, (char const   *)sa->name);
    }
#line 160
    if (tmp___0 == 0) {
#line 161
      return (sa->signal);
    }
#line 162
    sa = sa->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 165
  return ((signal_t *)((void *)0));
}
}
#line 168 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/part/part.c"
void part_set_instruction(part_t *p , char const   *iname ) 
{ 


  {
#line 171
  if (p) {
    {
#line 172
    p->active_instruction = part_find_instruction(p, iname);
    }
  }
#line 173
  return;
}
}
#line 175 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/part/part.c"
void part_set_signal(part_t *p , signal_t *s , int out , int val ) 
{ 
  data_register *bsr ;
  char *tmp ;
  int control ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 180
  if (! p) {
#line 181
    return;
  } else
#line 180
  if (! s) {
#line 181
    return;
  }
  {
#line 184
  bsr = part_find_data_register(p, "BSR");
  }
#line 185
  if (! bsr) {
    {
#line 186
    tmp = gettext("%s(%s:%d) Boundary Scan Register (BSR) not found\n");
#line 186
    printf((char const   */* __restrict  */)tmp, "part_set_signal", "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/part/part.c",
           186);
    }
#line 187
    return;
  }
#line 191
  if (out) {
#line 193
    if (! s->output) {
      {
#line 194
      tmp___0 = gettext("signal \'%s\' cannot be set as output\n");
#line 194
      printf((char const   */* __restrict  */)tmp___0, s->name);
      }
#line 195
      return;
    }
#line 197
    *((bsr->in)->data + (s->output)->bit) = (char )(val & 1);
#line 199
    control = (*(p->bsbits + (s->output)->bit))->control;
#line 200
    if (control >= 0) {
#line 201
      *((bsr->in)->data + control) = (char )((*(p->bsbits + (s->output)->bit))->control_value ^ 1);
    }
  } else {
#line 203
    if (! s->input) {
      {
#line 204
      tmp___1 = gettext("signal \'%s\' cannot be set as input\n");
#line 204
      printf((char const   */* __restrict  */)tmp___1, s->name);
      }
#line 205
      return;
    }
#line 207
    if (s->output) {
#line 208
      *((bsr->in)->data + (s->output)->control) = (char )(*(p->bsbits + (s->output)->bit))->control_value;
    }
  }
#line 210
  return;
}
}
#line 212 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/part/part.c"
int part_get_signal(part_t *p , signal_t *s ) 
{ 
  data_register *bsr ;
  char *tmp ;
  char *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 217
  if (! p) {
#line 218
    return (-1);
  } else
#line 217
  if (! s) {
#line 218
    return (-1);
  }
  {
#line 221
  bsr = part_find_data_register(p, "BSR");
  }
#line 222
  if (! bsr) {
    {
#line 223
    tmp = gettext("%s(%s:%d) Boundary Scan Register (BSR) not found\n");
#line 223
    printf((char const   */* __restrict  */)tmp, "part_get_signal", "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/part/part.c",
           223);
    }
#line 224
    return (-1);
  }
#line 227
  if (! s->input) {
    {
#line 228
    tmp___0 = gettext("signal \'%s\' is not input signal\n");
#line 228
    printf((char const   */* __restrict  */)tmp___0, s->name);
    }
#line 229
    return (-1);
  }
#line 232
  return ((int )*((bsr->out)->data + (s->input)->bit));
}
}
#line 235 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/part/part.c"
void part_print(part_t *p ) 
{ 
  char const   *instruction___0 ;
  char const   *dr ;
  char format[100] ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 238
  instruction___0 = (char const   *)((void *)0);
#line 239
  dr = (char const   *)((void *)0);
#line 242
  if (! p) {
#line 243
    return;
  }
  {
#line 245
  tmp = gettext("%%-%ds %%-%ds %%-%ds %%-%ds %%-%ds\n");
#line 245
  snprintf((char */* __restrict  */)(format), (size_t )100, (char const   */* __restrict  */)tmp,
           25, 20, 8, 20, 32);
  }
#line 248
  if (p->active_instruction) {
#line 249
    instruction___0 = (char const   *)((p->active_instruction)->name);
#line 250
    if ((unsigned long )(p->active_instruction)->data_register != (unsigned long )((void *)0)) {
#line 251
      dr = (char const   *)(((p->active_instruction)->data_register)->name);
    }
  }
#line 253
  if ((unsigned long )instruction___0 == (unsigned long )((void *)0)) {
    {
#line 254
    tmp___0 = gettext("(none)");
#line 254
    instruction___0 = (char const   *)tmp___0;
    }
  }
#line 255
  if ((unsigned long )dr == (unsigned long )((void *)0)) {
    {
#line 256
    tmp___1 = gettext("(none)");
#line 256
    dr = (char const   *)tmp___1;
    }
  }
  {
#line 257
  printf((char const   */* __restrict  */)(format), p->manufacturer, p->part, p->stepping,
         instruction___0, dr);
  }
#line 258
  return;
}
}
#line 262 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/part/part.c"
parts_t *parts_alloc(void) 
{ 
  parts_t *ps ;
  void *tmp ;

  {
  {
#line 265
  tmp = malloc((size_t )sizeof(*ps));
#line 265
  ps = (parts_t *)tmp;
  }
#line 266
  if (! ps) {
#line 267
    return ((parts_t *)((void *)0));
  }
#line 269
  ps->len = 0;
#line 270
  ps->parts = (part_t **)((void *)0);
#line 272
  return (ps);
}
}
#line 275 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/part/part.c"
void parts_free(parts_t *ps ) 
{ 
  int i ;

  {
#line 280
  if (! ps) {
#line 281
    return;
  }
#line 283
  i = 0;
  {
#line 283
  while (1) {
    while_continue: /* CIL Label */ ;
#line 283
    if (! (i < ps->len)) {
#line 283
      goto while_break;
    }
    {
#line 284
    part_free(*(ps->parts + i));
#line 283
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 286
  free((void *)ps->parts);
#line 287
  free((void *)ps);
  }
#line 288
  return;
}
}
#line 290 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/part/part.c"
int parts_add_part(parts_t *ps , part_t *p ) 
{ 
  part_t **np ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 293
  tmp = realloc((void *)ps->parts, (size_t )((unsigned long )(ps->len + 1) * sizeof(*(ps->parts))));
#line 293
  np = (part_t **)tmp;
  }
#line 295
  if (! np) {
#line 296
    return (0);
  }
#line 298
  ps->parts = np;
#line 299
  tmp___0 = ps->len;
#line 299
  (ps->len) ++;
#line 299
  *(ps->parts + tmp___0) = p;
#line 301
  return (1);
}
}
#line 304 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/part/part.c"
void parts_set_instruction(parts_t *ps , char const   *iname ) 
{ 
  int i ;

  {
#line 309
  if (! ps) {
#line 310
    return;
  }
#line 312
  i = 0;
  {
#line 312
  while (1) {
    while_continue: /* CIL Label */ ;
#line 312
    if (! (i < ps->len)) {
#line 312
      goto while_break;
    }
    {
#line 313
    (*(ps->parts + i))->active_instruction = part_find_instruction(*(ps->parts + i),
                                                                   iname);
#line 312
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 314
  return;
}
}
#line 316 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/part/part.c"
void parts_print(parts_t *ps ) 
{ 
  int i ;
  part_t *p ;
  char *tmp ;
  char *__cil_tmp5 ;

  {
#line 321
  if (! ps) {
#line 322
    return;
  }
#line 324
  i = 0;
  {
#line 324
  while (1) {
    while_continue: /* CIL Label */ ;
#line 324
    if (! (i < ps->len)) {
#line 324
      goto while_break;
    }
#line 325
    p = *(ps->parts + i);
#line 327
    if (! p) {
#line 328
      goto __Cont;
    }
    {
#line 330
    tmp = gettext(" %3d ");
#line 330
    printf((char const   */* __restrict  */)tmp, i);
#line 331
    part_print(p);
    }
    __Cont: /* CIL Label */ 
#line 324
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 333
  return;
}
}
#line 33 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/part/instruction.c"
instruction *instruction_alloc(char const   *name , int len , char const   *val ) 
{ 
  instruction *i ;
  void *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  char *__cil_tmp8 ;

  {
#line 38
  if (! name) {
#line 39
    return ((instruction *)((void *)0));
  } else
#line 38
  if (! val) {
#line 39
    return ((instruction *)((void *)0));
  }
  {
#line 41
  tmp = malloc((size_t )sizeof(*i));
#line 41
  i = (instruction *)tmp;
  }
#line 42
  if (! i) {
#line 43
    return ((instruction *)((void *)0));
  }
  {
#line 45
  tmp___1 = strlen(name);
  }
#line 45
  if (tmp___1 > 20U) {
    {
#line 46
    tmp___0 = gettext("Warning: Instruction name too long\n");
#line 46
    printf((char const   */* __restrict  */)tmp___0);
    }
  }
  {
#line 47
  strncpy((char */* __restrict  */)(i->name), (char const   */* __restrict  */)name,
          (size_t )20);
#line 48
  i->name[20] = (char )'\000';
#line 50
  i->value = register_alloc(len);
  }
#line 51
  if (! i->value) {
    {
#line 52
    free((void *)i);
    }
#line 53
    return ((instruction *)((void *)0));
  }
  {
#line 55
  i->out = register_alloc(len);
  }
#line 56
  if (! i->out) {
    {
#line 57
    free((void *)i->value);
#line 58
    free((void *)i);
    }
#line 59
    return ((instruction *)((void *)0));
  }
  {
#line 62
  register_init(i->value, val);
#line 63
  i->data_register = (data_register *)((void *)0);
#line 64
  i->next = (instruction *)((void *)0);
  }
#line 66
  return (i);
}
}
#line 69 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/part/instruction.c"
void instruction_free(instruction *i ) 
{ 


  {
#line 72
  if (! i) {
#line 73
    return;
  }
#line 75
  if (i->value) {
    {
#line 76
    register_free(i->value);
    }
  }
#line 77
  if (i->out) {
    {
#line 78
    register_free(i->out);
    }
  }
  {
#line 79
  free((void *)i);
  }
#line 80
  return;
}
}
#line 33 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/part/data_register.c"
data_register *data_register_alloc(char const   *name , int len ) 
{ 
  data_register *dr ;
  void *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  char *__cil_tmp7 ;

  {
#line 38
  if (! name) {
#line 39
    return ((data_register *)((void *)0));
  }
  {
#line 41
  tmp = malloc((size_t )sizeof(*dr));
#line 41
  dr = (data_register *)tmp;
  }
#line 42
  if (! dr) {
#line 43
    return ((data_register *)((void *)0));
  }
  {
#line 45
  tmp___1 = strlen(name);
  }
#line 45
  if (tmp___1 > 32U) {
    {
#line 46
    tmp___0 = gettext("Warning: Data register name too long\n");
#line 46
    printf((char const   */* __restrict  */)tmp___0);
    }
  }
  {
#line 47
  strncpy((char */* __restrict  */)(dr->name), (char const   */* __restrict  */)name,
          (size_t )32);
#line 48
  dr->name[32] = (char )'\000';
  }
#line 50
  if (len > 0) {
    {
#line 52
    dr->in = register_alloc(len);
#line 53
    dr->out = register_alloc(len);
    }
  } else {
    {
#line 57
    dr->in = register_alloc(1);
#line 58
    dr->out = register_alloc(1);
    }
  }
#line 60
  if (! dr->in) {
    {
#line 61
    free((void *)dr->in);
#line 62
    free((void *)dr->out);
#line 63
    free((void *)(dr->name));
#line 64
    free((void *)dr);
    }
#line 65
    return ((data_register *)((void *)0));
  } else
#line 60
  if (! dr->out) {
    {
#line 61
    free((void *)dr->in);
#line 62
    free((void *)dr->out);
#line 63
    free((void *)(dr->name));
#line 64
    free((void *)dr);
    }
#line 65
    return ((data_register *)((void *)0));
  }
#line 68
  dr->next = (data_register *)((void *)0);
#line 70
  return (dr);
}
}
#line 73 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/part/data_register.c"
void data_register_free(data_register *dr ) 
{ 


  {
#line 76
  if (! dr) {
#line 77
    return;
  }
  {
#line 79
  register_free(dr->in);
#line 80
  register_free(dr->out);
#line 81
  free((void *)dr);
  }
#line 82
  return;
}
}
#line 51 "../../include/bsbit.h"
bsbit_t *bsbit_alloc(int bit , char const   *name , int type , signal_t *signal ,
                     int safe ) ;
#line 30 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/part/bsbit.c"
bsbit_t *bsbit_alloc(int bit , char const   *name , int type , signal_t *signal ,
                     int safe ) 
{ 
  bsbit_t *b ;
  void *tmp ;

  {
  {
#line 33
  tmp = malloc((size_t )sizeof(*b));
#line 33
  b = (bsbit_t *)tmp;
  }
#line 34
  if (! b) {
#line 35
    return ((bsbit_t *)((void *)0));
  }
  {
#line 37
  b->name = strdup(name);
  }
#line 38
  if (! b->name) {
    {
#line 39
    free((void *)b);
    }
#line 40
    return ((bsbit_t *)((void *)0));
  }
#line 43
  b->bit = bit;
#line 44
  b->type = type;
#line 45
  b->signal = (signal_t *)((void *)0);
#line 46
  b->safe = safe;
#line 47
  b->control = -1;
#line 49
  if ((unsigned long )signal != (unsigned long )((void *)0)) {
#line 50
    b->signal = signal;
    {
#line 52
    if (type == 1) {
#line 52
      goto case_1;
    }
#line 55
    if (type == 2) {
#line 55
      goto case_2;
    }
#line 58
    if (type == 5) {
#line 58
      goto case_5;
    }
#line 51
    goto switch_break;
    case_1: /* CIL Label */ 
#line 53
    signal->input = b;
#line 54
    goto switch_break;
    case_2: /* CIL Label */ 
#line 56
    signal->output = b;
#line 57
    goto switch_break;
    case_5: /* CIL Label */ 
#line 59
    signal->input = b;
#line 60
    signal->output = b;
#line 61
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 65
  return (b);
}
}
#line 68 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/part/bsbit.c"
void bsbit_free(bsbit_t *b ) 
{ 


  {
#line 71
  if (! b) {
#line 72
    return;
  }
  {
#line 74
  free((void *)b->name);
#line 75
  free((void *)b);
  }
#line 76
  return;
}
}
#line 68 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/wiggler2.c"
static int wiggler2_init___0(cable_t *cable ) 
{ 
  int data ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 73
  tmp = parport_open(cable->link.port);
  }
#line 73
  if (tmp) {
#line 74
    return (-1);
  }
  {
#line 79
  data = parport_get_data(cable->link.port);
  }
#line 79
  if (data < 0) {
    {
#line 80
    tmp___0 = parport_set_data(cable->link.port, (uint8_t )((1 << 4) | (~ (((((1 << 3) | (1 << 2)) | (1 << 1)) | (1 << 4)) | 1) & 255)));
    }
#line 80
    if (tmp___0) {
#line 81
      return (-1);
    }
#line 82
    ((generic_params_t *)cable->params)->signals = 8;
  } else
#line 84
  if (data >> 4) {
#line 84
    ((generic_params_t *)cable->params)->signals = 8;
  } else {
#line 84
    ((generic_params_t *)cable->params)->signals = 0;
  }
#line 86
  return (0);
}
}
#line 89 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/wiggler2.c"
static void wiggler2_clock___0(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;
  int trst ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 93
  if (((generic_params_t *)cable->params)->signals & 8) {
#line 93
    tmp = 1;
  } else {
#line 93
    tmp = 0;
  }
#line 93
  trst = tmp;
#line 95
  if (tms) {
#line 95
    tms = 1;
  } else {
#line 95
    tms = 0;
  }
#line 96
  if (tdi) {
#line 96
    tdi = 1;
  } else {
#line 96
    tdi = 0;
  }
#line 98
  i = 0;
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! (i < n)) {
#line 98
      goto while_break;
    }
    {
#line 99
    parport_set_data(cable->link.port, (uint8_t )((((trst << 4) | (tms << 1)) | (tdi << 3)) | (~ (((((1 << 3) | (1 << 2)) | (1 << 1)) | (1 << 4)) | 1) & 255)));
#line 100
    cable_wait(cable);
#line 101
    parport_set_data(cable->link.port, (uint8_t )(((((trst << 4) | (1 << 2)) | (tms << 1)) | (tdi << 3)) | (~ (((((1 << 3) | (1 << 2)) | (1 << 1)) | (1 << 4)) | 1) & 255)));
#line 102
    cable_wait(cable);
#line 98
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 105
  ((generic_params_t *)cable->params)->signals &= 8;
#line 106
  ((generic_params_t *)cable->params)->signals |= 2;
#line 107
  if (tms) {
#line 107
    tmp___0 = 4;
  } else {
#line 107
    tmp___0 = 0;
  }
#line 107
  ((generic_params_t *)cable->params)->signals |= tmp___0;
#line 108
  if (tdi) {
#line 108
    tmp___1 = 1;
  } else {
#line 108
    tmp___1 = 0;
  }
#line 108
  ((generic_params_t *)cable->params)->signals |= tmp___1;
#line 109
  return;
}
}
#line 111 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/wiggler2.c"
static int wiggler2_get_tdo___0(cable_t *cable ) 
{ 
  int trst ;
  int tmp ;
  int tmp___0 ;

  {
#line 114
  if (((generic_params_t *)cable->params)->signals & 8) {
#line 114
    tmp = 1;
  } else {
#line 114
    tmp = 0;
  }
  {
#line 114
  trst = tmp;
#line 116
  parport_set_data(cable->link.port, (uint8_t )((trst << 4) | (~ (((((1 << 3) | (1 << 2)) | (1 << 1)) | (1 << 4)) | 1) & 255)));
#line 117
  ((generic_params_t *)cable->params)->signals &= -8;
#line 119
  cable_wait(cable);
#line 121
  tmp___0 = parport_get_status(cable->link.port);
  }
#line 121
  return ((tmp___0 >> 7) & 1);
}
}
#line 124 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/wiggler2.c"
static int wiggler2_set_signal___0(cable_t *cable , int mask , int val ) 
{ 
  int prev_sigs ;
  int data ;
  int sigs ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 127
  prev_sigs = ((generic_params_t *)cable->params)->signals;
#line 129
  mask &= 15;
#line 131
  if (mask != 0) {
#line 133
    data = 0;
#line 134
    sigs = (prev_sigs & ~ mask) | (val & mask);
#line 135
    if (sigs & 1) {
#line 135
      tmp = 1 << 3;
    } else {
#line 135
      tmp = 0;
    }
#line 135
    data |= tmp;
#line 136
    if (sigs & 2) {
#line 136
      tmp___0 = 1 << 2;
    } else {
#line 136
      tmp___0 = 0;
    }
#line 136
    data |= tmp___0;
#line 137
    if (sigs & 4) {
#line 137
      tmp___1 = 1 << 1;
    } else {
#line 137
      tmp___1 = 0;
    }
#line 137
    data |= tmp___1;
#line 138
    if (sigs & 8) {
#line 138
      tmp___2 = 1 << 4;
    } else {
#line 138
      tmp___2 = 0;
    }
    {
#line 138
    data |= tmp___2;
#line 139
    parport_set_data(cable->link.port, (uint8_t )(data | (~ (((((1 << 3) | (1 << 2)) | (1 << 1)) | (1 << 4)) | 1) & 255)));
#line 140
    ((generic_params_t *)cable->params)->signals = sigs;
    }
  }
#line 143
  return (prev_sigs);
}
}
#line 70 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/wiggler.c"
static char const   *std_wgl_map___0  =    "7,4,3,2,1,#0";
#line 112 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/wiggler.c"
static int map_pin___0(char *pin , int *act , int *inact ) 
{ 
  int bitnum ;
  int inverted ;
  unsigned short const   **tmp ;
  int tmp___0 ;

  {
#line 116
  inverted = 0;
#line 118
  if ((int )*pin == 35) {
#line 119
    inverted = 1;
#line 120
    pin ++;
  }
  {
#line 123
  tmp = __ctype_b_loc();
  }
#line 123
  if (! ((int const   )*(*tmp + (int )*pin) & 2048)) {
#line 124
    return (-1);
  }
  {
#line 126
  tmp___0 = atoi((char const   *)pin);
#line 126
  bitnum = tmp___0 % 8;
#line 128
  bitnum = 1 << bitnum;
  }
#line 130
  if (inverted) {
#line 130
    *act = 0;
  } else {
#line 130
    *act = bitnum;
  }
#line 131
  if (inverted) {
#line 131
    *inact = bitnum;
  } else {
#line 131
    *inact = 0;
  }
#line 133
  return (0);
}
}
#line 137 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/wiggler.c"
static int set_mapping___0(char *bitmap , cable_t *cable ) 
{ 
  char delim ;
  int syntax ;
  char *tdo ;
  char *trst ;
  char *tdi ;
  char *tck ;
  char *tms ;
  char *srst ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 140
  delim = (char )',';
#line 141
  syntax = 0;
#line 145
  tdo = bitmap;
#line 145
  if (tdo) {
    {
#line 146
    trst = strchr((char const   *)tdo, (int )delim);
    }
#line 146
    if (trst) {
      {
#line 147
      trst ++;
#line 148
      tdi = strchr((char const   *)trst, (int )delim);
      }
#line 148
      if (tdi) {
        {
#line 149
        tdi ++;
#line 150
        tck = strchr((char const   *)tdi, (int )delim);
        }
#line 150
        if (tck) {
          {
#line 151
          tck ++;
#line 152
          tms = strchr((char const   *)tck, (int )delim);
          }
#line 152
          if (tms) {
            {
#line 153
            tms ++;
#line 154
            srst = strchr((char const   *)tms, (int )delim);
            }
#line 154
            if (srst) {
#line 155
              srst ++;
#line 156
              syntax = 1;
            }
          }
        }
      }
    }
  }
#line 159
  if (! syntax) {
#line 160
    return (-1);
  }
  {
#line 162
  tmp = map_pin___0(tdo, & ((wiggler_params_t *)cable->params)->tdo_act, & ((wiggler_params_t *)cable->params)->tdo_inact);
  }
#line 162
  if (tmp != 0) {
#line 162
    return (-1);
  }
  {
#line 163
  tmp___0 = map_pin___0(trst, & ((wiggler_params_t *)cable->params)->trst_act, & ((wiggler_params_t *)cable->params)->trst_inact);
  }
#line 163
  if (tmp___0 != 0) {
#line 163
    return (-1);
  }
  {
#line 164
  tmp___1 = map_pin___0(tdi, & ((wiggler_params_t *)cable->params)->tdi_act, & ((wiggler_params_t *)cable->params)->tdi_inact);
  }
#line 164
  if (tmp___1 != 0) {
#line 164
    return (-1);
  }
  {
#line 165
  tmp___2 = map_pin___0(tck, & ((wiggler_params_t *)cable->params)->tck_act, & ((wiggler_params_t *)cable->params)->tck_inact);
  }
#line 165
  if (tmp___2 != 0) {
#line 165
    return (-1);
  }
  {
#line 166
  tmp___3 = map_pin___0(tms, & ((wiggler_params_t *)cable->params)->tms_act, & ((wiggler_params_t *)cable->params)->tms_inact);
  }
#line 166
  if (tmp___3 != 0) {
#line 166
    return (-1);
  }
  {
#line 167
  tmp___4 = map_pin___0(srst, & ((wiggler_params_t *)cable->params)->srst_act, & ((wiggler_params_t *)cable->params)->srst_inact);
  }
#line 167
  if (tmp___4 != 0) {
#line 167
    return (-1);
  }
#line 169
  return (0);
}
}
#line 173 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/wiggler.c"
static int wiggler_connect___0(char **params , cable_t *cable ) 
{ 
  int result ;
  char *param_bitmap ;
  wiggler_params_t *wiggler_params ;
  int tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 177
  param_bitmap = (char *)((void *)0);
#line 180
  tmp = cmd_params(params);
  }
#line 180
  if (tmp == 4) {
#line 182
    param_bitmap = *(params + 3);
#line 184
    *(params + 3) = (char *)((void *)0);
  }
  {
#line 187
  result = generic_parport_connect(params, cable);
  }
#line 187
  if (result != 0) {
#line 188
    return (result);
  }
#line 190
  if (param_bitmap) {
#line 191
    *(params + 3) = param_bitmap;
  }
  {
#line 193
  tmp___0 = malloc((size_t )sizeof(*wiggler_params));
#line 193
  wiggler_params = (wiggler_params_t *)tmp___0;
  }
#line 194
  if (! wiggler_params) {
    {
#line 195
    tmp___1 = gettext("%s(%d) malloc failed!\n");
#line 195
    printf((char const   */* __restrict  */)tmp___1, "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/wiggler.c",
           195);
#line 201
    (*(((cable->link.port)->driver)->parport_free))(cable->link.port);
    }
#line 202
    return (4);
  }
  {
#line 206
  free(cable->params);
#line 207
  cable->params = (void *)wiggler_params;
  }
#line 209
  if (! param_bitmap) {
#line 210
    param_bitmap = (char *)std_wgl_map___0;
  }
  {
#line 212
  result = set_mapping___0(param_bitmap, cable);
  }
#line 212
  if (result != 0) {
    {
#line 213
    tmp___2 = gettext("Pin mapping failed\n");
#line 213
    printf((char const   */* __restrict  */)tmp___2);
#line 219
    (*(((cable->link.port)->driver)->parport_free))(cable->link.port);
#line 220
    free(cable->params);
    }
#line 221
    return (result);
  }
#line 226
  ((wiggler_params_t *)cable->params)->unused_bits = ~ (((((((((((wiggler_params_t *)cable->params)->srst_act | ((wiggler_params_t *)cable->params)->srst_inact) | ((wiggler_params_t *)cable->params)->tms_act) | ((wiggler_params_t *)cable->params)->tms_inact) | ((wiggler_params_t *)cable->params)->tck_act) | ((wiggler_params_t *)cable->params)->tck_inact) | ((wiggler_params_t *)cable->params)->tdi_act) | ((wiggler_params_t *)cable->params)->tdi_inact) | ((wiggler_params_t *)cable->params)->trst_act) | ((wiggler_params_t *)cable->params)->trst_inact) & 255;
#line 232
  return (0);
}
}
#line 235 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/wiggler.c"
static int wiggler_init___0(cable_t *cable ) 
{ 
  int data ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 240
  tmp = parport_open(cable->link.port);
  }
#line 240
  if (tmp) {
#line 241
    return (-1);
  }
  {
#line 243
  data = parport_get_data(cable->link.port);
  }
#line 243
  if (data < 0) {
    {
#line 244
    tmp___0 = parport_set_data(cable->link.port, (uint8_t )((((wiggler_params_t *)cable->params)->trst_act | ((wiggler_params_t *)cable->params)->trst_inact) | ((wiggler_params_t *)cable->params)->unused_bits));
    }
#line 244
    if (tmp___0) {
#line 245
      return (-1);
    }
#line 246
    ((wiggler_params_t *)cable->params)->trst_lvl = ((wiggler_params_t *)cable->params)->trst_act | ((wiggler_params_t *)cable->params)->trst_inact;
  } else {
#line 248
    ((wiggler_params_t *)cable->params)->trst_lvl = data & (((wiggler_params_t *)cable->params)->trst_act | ((wiggler_params_t *)cable->params)->trst_inact);
  }
#line 250
  if (((wiggler_params_t *)cable->params)->trst_lvl == ((wiggler_params_t *)cable->params)->trst_act) {
#line 250
    ((wiggler_params_t *)cable->params)->signals = 8;
  } else {
#line 250
    ((wiggler_params_t *)cable->params)->signals = 0;
  }
#line 252
  return (0);
}
}
#line 255 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/wiggler.c"
static void wiggler_clock___0(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 260
  if (tms) {
#line 260
    tms = 1;
  } else {
#line 260
    tms = 0;
  }
#line 261
  if (tdi) {
#line 261
    tdi = 1;
  } else {
#line 261
    tdi = 0;
  }
#line 263
  i = 0;
  {
#line 263
  while (1) {
    while_continue: /* CIL Label */ ;
#line 263
    if (! (i < n)) {
#line 263
      goto while_break;
    }
#line 264
    if (tms) {
#line 264
      tmp = ((wiggler_params_t *)cable->params)->tms_act;
    } else {
#line 264
      tmp = ((wiggler_params_t *)cable->params)->tms_inact;
    }
#line 264
    if (tdi) {
#line 264
      tmp___0 = ((wiggler_params_t *)cable->params)->tdi_act;
    } else {
#line 264
      tmp___0 = ((wiggler_params_t *)cable->params)->tdi_inact;
    }
    {
#line 264
    parport_set_data(cable->link.port, (uint8_t )((((((wiggler_params_t *)cable->params)->trst_lvl | ((wiggler_params_t *)cable->params)->tck_inact) | tmp) | tmp___0) | ((wiggler_params_t *)cable->params)->unused_bits));
#line 269
    cable_wait(cable);
    }
#line 270
    if (tms) {
#line 270
      tmp___1 = ((wiggler_params_t *)cable->params)->tms_act;
    } else {
#line 270
      tmp___1 = ((wiggler_params_t *)cable->params)->tms_inact;
    }
#line 270
    if (tdi) {
#line 270
      tmp___2 = ((wiggler_params_t *)cable->params)->tdi_act;
    } else {
#line 270
      tmp___2 = ((wiggler_params_t *)cable->params)->tdi_inact;
    }
    {
#line 270
    parport_set_data(cable->link.port, (uint8_t )((((((wiggler_params_t *)cable->params)->trst_lvl | ((wiggler_params_t *)cable->params)->tck_act) | tmp___1) | tmp___2) | ((wiggler_params_t *)cable->params)->unused_bits));
#line 275
    cable_wait(cable);
#line 263
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 278
  ((wiggler_params_t *)cable->params)->signals &= -6;
#line 279
  if (tms) {
#line 279
    ((wiggler_params_t *)cable->params)->signals |= 4;
  }
#line 280
  if (tdi) {
#line 280
    ((wiggler_params_t *)cable->params)->signals |= 1;
  }
#line 281
  return;
}
}
#line 283 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/wiggler.c"
static int wiggler_get_tdo___0(cable_t *cable ) 
{ 
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 286
  parport_set_data(cable->link.port, (uint8_t )((((wiggler_params_t *)cable->params)->trst_lvl | ((wiggler_params_t *)cable->params)->tck_inact) | ((wiggler_params_t *)cable->params)->unused_bits));
#line 289
  cable_wait(cable);
#line 291
  tmp___1 = parport_get_status(cable->link.port);
  }
#line 291
  if ((tmp___1 & (((wiggler_params_t *)cable->params)->tdo_act | ((wiggler_params_t *)cable->params)->tdo_inact)) ^ ((wiggler_params_t *)cable->params)->tdo_act) {
#line 291
    tmp___0 = 0;
  } else {
#line 291
    tmp___0 = 1;
  }
#line 291
  return (tmp___0);
}
}
#line 295 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/wiggler.c"
static int wiggler_set_signal___0(cable_t *cable , int mask , int val ) 
{ 
  int prev_sigs ;
  int sigs ;
  int data ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 298
  prev_sigs = ((wiggler_params_t *)cable->params)->signals;
#line 300
  mask &= 15;
#line 302
  if (mask != 0) {
#line 304
    sigs = (prev_sigs & ~ mask) | (val & mask);
#line 305
    if (sigs & 8) {
#line 305
      ((wiggler_params_t *)cable->params)->trst_lvl = ((wiggler_params_t *)cable->params)->trst_act;
    } else {
#line 305
      ((wiggler_params_t *)cable->params)->trst_lvl = ((wiggler_params_t *)cable->params)->trst_inact;
    }
#line 306
    data = ((wiggler_params_t *)cable->params)->unused_bits | ((wiggler_params_t *)cable->params)->trst_lvl;
#line 307
    if (sigs & 2) {
#line 307
      tmp = ((wiggler_params_t *)cable->params)->tck_act;
    } else {
#line 307
      tmp = ((wiggler_params_t *)cable->params)->tck_inact;
    }
#line 307
    data |= tmp;
#line 308
    if (sigs & 4) {
#line 308
      tmp___0 = ((wiggler_params_t *)cable->params)->tms_act;
    } else {
#line 308
      tmp___0 = ((wiggler_params_t *)cable->params)->tms_inact;
    }
#line 308
    data |= tmp___0;
#line 309
    if (sigs & 1) {
#line 309
      tmp___1 = ((wiggler_params_t *)cable->params)->tdi_act;
    } else {
#line 309
      tmp___1 = ((wiggler_params_t *)cable->params)->tdi_inact;
    }
    {
#line 309
    data |= tmp___1;
#line 310
    parport_set_data(cable->link.port, (uint8_t )data);
#line 311
    ((wiggler_params_t *)cable->params)->signals = sigs;
    }
  }
#line 314
  return (prev_sigs);
}
}
#line 317 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/wiggler.c"
static int wiggler_get_signal___0(cable_t *cable , pod_sigsel_t sig ) 
{ 
  int tmp ;

  {
#line 320
  if ((unsigned int )((wiggler_params_t *)cable->params)->signals & (unsigned int )sig) {
#line 320
    tmp = 1;
  } else {
#line 320
    tmp = 0;
  }
#line 320
  return (tmp);
}
}
#line 323 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/wiggler.c"
static void wiggler_help___0(char const   *cablename ) 
{ 
  char *tmp ;
  char *__cil_tmp3 ;

  {
  {
#line 326
  tmp = gettext("Usage: cable %s parallel PORTADDR [TDO,TRST,TDI,TCK,TMS,SRESET]\n   or: cable %s ppdev PPDEV [TDO,TRST,TDI,TCK,TMS,SRESET]\n\nPORTADDR   parallel port address (e.g. 0x378)\nPPDEV      ppdev device (e.g. /dev/parport0)\nTDO, ...   parallel port bit number, prepend \'#\' for inversion\n           default is \'%s\'\n\n");
#line 326
  printf((char const   */* __restrict  */)tmp, cablename, cablename, std_wgl_map___0);
  }
#line 355
  return;
}
}
#line 69 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/triton.c"
static int triton_init___0(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 72
  tmp = parport_open(cable->link.port);
  }
#line 72
  if (tmp) {
#line 73
    return (-1);
  }
  {
#line 75
  ((generic_params_t *)cable->params)->signals = 24;
#line 76
  parport_set_data(cable->link.port, (uint8_t )((1 << 3) | (1 << 4)));
  }
#line 78
  return (0);
}
}
#line 81 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/triton.c"
static void triton_clock___0(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;
  int trst ;
  int tmp ;
  int sreset ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 85
  if (((generic_params_t *)cable->params)->signals & 8) {
#line 85
    tmp = 1;
  } else {
#line 85
    tmp = 0;
  }
#line 85
  trst = tmp;
#line 86
  if (((generic_params_t *)cable->params)->signals & 16) {
#line 86
    tmp___0 = 1;
  } else {
#line 86
    tmp___0 = 0;
  }
#line 86
  sreset = tmp___0;
#line 88
  if (tms) {
#line 88
    tms = 1;
  } else {
#line 88
    tms = 0;
  }
#line 89
  if (tdi) {
#line 89
    tdi = 1;
  } else {
#line 89
    tdi = 0;
  }
#line 91
  i = 0;
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
#line 91
    if (! (i < n)) {
#line 91
      goto while_break;
    }
    {
#line 92
    parport_set_data(cable->link.port, (uint8_t )((((trst << 3) | (sreset << 4)) | (tms << 2)) | (tdi << 1)));
#line 93
    cable_wait(cable);
#line 94
    parport_set_data(cable->link.port, (uint8_t )(((((trst << 3) | (sreset << 4)) | 1) | (tms << 2)) | (tdi << 1)));
#line 95
    cable_wait(cable);
#line 91
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  ((generic_params_t *)cable->params)->signals &= 24;
#line 99
  ((generic_params_t *)cable->params)->signals |= 2;
#line 100
  if (tms) {
#line 100
    tmp___1 = 4;
  } else {
#line 100
    tmp___1 = 0;
  }
#line 100
  ((generic_params_t *)cable->params)->signals |= tmp___1;
#line 101
  if (tdi) {
#line 101
    tmp___2 = 1;
  } else {
#line 101
    tmp___2 = 0;
  }
#line 101
  ((generic_params_t *)cable->params)->signals |= tmp___2;
#line 102
  return;
}
}
#line 104 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/triton.c"
static int triton_get_tdo___0(cable_t *cable ) 
{ 
  int trst ;
  int tmp ;
  int sreset ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 107
  if (((generic_params_t *)cable->params)->signals & 8) {
#line 107
    tmp = 1;
  } else {
#line 107
    tmp = 0;
  }
#line 107
  trst = tmp;
#line 108
  if (((generic_params_t *)cable->params)->signals & 16) {
#line 108
    tmp___0 = 1;
  } else {
#line 108
    tmp___0 = 0;
  }
  {
#line 108
  sreset = tmp___0;
#line 110
  parport_set_data(cable->link.port, (uint8_t )((trst << 3) | (sreset << 4)));
#line 111
  ((generic_params_t *)cable->params)->signals &= -8;
#line 113
  cable_wait(cable);
#line 115
  tmp___1 = parport_get_status(cable->link.port);
  }
#line 115
  return ((tmp___1 >> 7) & 1);
}
}
#line 118 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/triton.c"
static int triton_set_signal___0(cable_t *cable , int mask , int val ) 
{ 
  int prev_sigs ;
  int data ;
  int sigs ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 121
  prev_sigs = ((generic_params_t *)cable->params)->signals;
#line 123
  mask &= 31;
#line 125
  if (mask != 0) {
#line 127
    data = 0;
#line 128
    sigs = (((generic_params_t *)cable->params)->signals & ~ mask) | (val & mask);
#line 129
    if (sigs & 1) {
#line 129
      tmp = 1 << 1;
    } else {
#line 129
      tmp = 0;
    }
#line 129
    data |= tmp;
#line 130
    if (sigs & 2) {
#line 130
      tmp___0 = 1;
    } else {
#line 130
      tmp___0 = 0;
    }
#line 130
    data |= tmp___0;
#line 131
    if (sigs & 4) {
#line 131
      tmp___1 = 1 << 2;
    } else {
#line 131
      tmp___1 = 0;
    }
#line 131
    data |= tmp___1;
#line 132
    if (sigs & 8) {
#line 132
      tmp___2 = 1 << 3;
    } else {
#line 132
      tmp___2 = 0;
    }
#line 132
    data |= tmp___2;
#line 133
    if (sigs & 16) {
#line 133
      tmp___3 = 1 << 4;
    } else {
#line 133
      tmp___3 = 0;
    }
    {
#line 133
    data |= tmp___3;
#line 134
    parport_set_data(cable->link.port, (uint8_t )data);
#line 135
    ((generic_params_t *)cable->params)->signals = sigs;
    }
  }
#line 138
  return (prev_sigs);
}
}
#line 54 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/parport/ppdev.c"
static port_node_t *ports___1  =    (port_node_t *)((void *)0);
#line 61 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/parport/ppdev.c"
static parport_t *ppdev_parport_alloc___0(char const   *port ) 
{ 
  ppdev_params_t *params ;
  void *tmp ;
  char *portname ;
  char *tmp___0 ;
  parport_t *parport ;
  void *tmp___1 ;
  port_node_t *node ;
  void *tmp___2 ;

  {
  {
#line 64
  tmp = malloc((size_t )sizeof(*params));
#line 64
  params = (ppdev_params_t *)tmp;
#line 65
  tmp___0 = strdup(port);
#line 65
  portname = tmp___0;
#line 66
  tmp___1 = malloc((size_t )sizeof(*parport));
#line 66
  parport = (parport_t *)tmp___1;
#line 67
  tmp___2 = malloc((size_t )sizeof(*node));
#line 67
  node = (port_node_t *)tmp___2;
  }
#line 69
  if (! node) {
    {
#line 70
    free((void *)node);
#line 71
    free((void *)parport);
#line 72
    free((void *)params);
#line 73
    free((void *)portname);
    }
#line 74
    return ((parport_t *)((void *)0));
  } else
#line 69
  if (! parport) {
    {
#line 70
    free((void *)node);
#line 71
    free((void *)parport);
#line 72
    free((void *)params);
#line 73
    free((void *)portname);
    }
#line 74
    return ((parport_t *)((void *)0));
  } else
#line 69
  if (! params) {
    {
#line 70
    free((void *)node);
#line 71
    free((void *)parport);
#line 72
    free((void *)params);
#line 73
    free((void *)portname);
    }
#line 74
    return ((parport_t *)((void *)0));
  } else
#line 69
  if (! portname) {
    {
#line 70
    free((void *)node);
#line 71
    free((void *)parport);
#line 72
    free((void *)params);
#line 73
    free((void *)portname);
    }
#line 74
    return ((parport_t *)((void *)0));
  }
#line 77
  params->portname = portname;
#line 78
  params->fd = -1;
#line 80
  parport->params = (void *)params;
#line 81
  parport->driver = & ppdev_parport_driver;
#line 82
  parport->cable = (cable_t *)((void *)0);
#line 84
  node->port = parport;
#line 85
  node->next = ports___1;
#line 87
  ports___1 = node;
#line 89
  return (parport);
}
}
#line 92 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/parport/ppdev.c"
static void ppdev_parport_free___0(parport_t *port ) 
{ 
  port_node_t **prev ;
  port_node_t *pn ;

  {
#line 97
  prev = & ports___1;
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
#line 97
    if (! *prev) {
#line 97
      goto while_break;
    }
#line 98
    if ((unsigned long )(*prev)->port == (unsigned long )port) {
#line 99
      goto while_break;
    }
#line 97
    prev = & (*prev)->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 101
  if (*prev) {
    {
#line 102
    pn = *prev;
#line 103
    *prev = pn->next;
#line 104
    free((void *)pn);
    }
  }
  {
#line 107
  free((void *)((ppdev_params_t *)port->params)->portname);
#line 108
  free(port->params);
#line 109
  free((void *)port);
  }
#line 110
  return;
}
}
#line 141 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/parport/ppdev.c"
static int ppdev_open___0(parport_t *parport ) 
{ 
  ppdev_params_t *p ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 144
  p = (ppdev_params_t *)parport->params;
#line 146
  p->fd = open((char const   *)p->portname, 2);
  }
#line 147
  if (p->fd < 0) {
    {
#line 148
    tmp = __errno_location();
#line 148
    tmp___0 = strerror(*tmp);
#line 148
    tmp___1 = gettext("Could not open port %s: %s\n");
#line 148
    printf((char const   */* __restrict  */)tmp___1, p->portname, tmp___0);
    }
#line 149
    return (-1);
  }
  {
#line 152
  tmp___5 = ioctl(p->fd, (unsigned long )((unsigned int )(112 << 8) | 139U));
  }
#line 152
  if (tmp___5 == -1) {
    {
#line 153
    tmp___2 = __errno_location();
#line 153
    tmp___3 = strerror(*tmp___2);
#line 153
    tmp___4 = gettext("Could not claim ppdev device: %s\n");
#line 153
    printf((char const   */* __restrict  */)tmp___4, tmp___3);
#line 154
    close(p->fd);
#line 155
    p->fd = -1;
    }
#line 156
    return (-1);
  }
#line 159
  return (0);
}
}
#line 162 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/parport/ppdev.c"
static int ppdev_close___0(parport_t *parport ) 
{ 
  int r ;
  ppdev_params_t *p ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 165
  r = 0;
#line 166
  p = (ppdev_params_t *)parport->params;
#line 168
  tmp = ioctl(p->fd, (unsigned long )((unsigned int )(112 << 8) | 140U));
  }
#line 168
  if (tmp == -1) {
#line 169
    r = -1;
  }
  {
#line 171
  tmp___0 = close(p->fd);
  }
#line 171
  if (tmp___0 != 0) {
#line 172
    return (-1);
  }
#line 174
  p->fd = -1;
#line 175
  return (r);
}
}
#line 178 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/parport/ppdev.c"
static int ppdev_set_data___0(parport_t *parport , uint8_t data ) 
{ 
  ppdev_params_t *p ;
  int tmp ;

  {
  {
#line 181
  p = (ppdev_params_t *)parport->params;
#line 183
  tmp = ioctl(p->fd, (unsigned long )(((1U << 30) | (unsigned int )(112 << 8)) | 134U) | (sizeof(unsigned char ) << 16),
              & data);
  }
#line 183
  if (tmp == -1) {
#line 184
    return (-1);
  }
#line 186
  return (0);
}
}
#line 189 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/parport/ppdev.c"
static int ppdev_get_data___0(parport_t *parport ) 
{ 
  unsigned char d ;
  ppdev_params_t *p ;
  int tmp ;

  {
  {
#line 193
  p = (ppdev_params_t *)parport->params;
#line 195
  tmp = ioctl(p->fd, (unsigned long )(((2U << 30) | (unsigned int )(112 << 8)) | 133U) | (sizeof(unsigned char ) << 16),
              & d);
  }
#line 195
  if (tmp == -1) {
#line 196
    return (-1);
  }
#line 198
  return ((int )d);
}
}
#line 201 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/parport/ppdev.c"
static int ppdev_get_status___0(parport_t *parport ) 
{ 
  unsigned char d ;
  ppdev_params_t *p ;
  int tmp ;

  {
  {
#line 205
  p = (ppdev_params_t *)parport->params;
#line 207
  tmp = ioctl(p->fd, (unsigned long )(((2U << 30) | (unsigned int )(112 << 8)) | 129U) | (sizeof(unsigned char ) << 16),
              & d);
  }
#line 207
  if (tmp == -1) {
#line 208
    return (-1);
  }
#line 210
  return ((int )d ^ 128);
}
}
#line 213 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/parport/ppdev.c"
static int ppdev_set_control___0(parport_t *parport , uint8_t data ) 
{ 
  ppdev_params_t *p ;
  int tmp ;

  {
  {
#line 216
  p = (ppdev_params_t *)parport->params;
#line 218
  data = (uint8_t )((int )data ^ 11);
#line 220
  tmp = ioctl(p->fd, (unsigned long )(((1U << 30) | (unsigned int )(112 << 8)) | 132U) | (sizeof(unsigned char ) << 16),
              & data);
  }
#line 220
  if (tmp == -1) {
#line 221
    return (-1);
  }
#line 223
  return (0);
}
}
#line 64 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/mpcbdm.c"
static int mpcbdm_init___0(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 67
  tmp = parport_open(cable->link.port);
  }
#line 67
  if (tmp) {
#line 68
    return (-1);
  }
  {
#line 70
  parport_set_control(cable->link.port, (uint8_t )0);
#line 71
  ((generic_params_t *)cable->params)->signals = 24;
  }
#line 73
  return (0);
}
}
#line 76 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/mpcbdm.c"
static void mpcbdm_clock___0(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 81
  if (tms) {
#line 81
    tms = 1;
  } else {
#line 81
    tms = 0;
  }
#line 82
  if (tdi) {
#line 82
    tdi = 1;
  } else {
#line 82
    tdi = 0;
  }
#line 84
  i = 0;
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
#line 84
    if (! (i < n)) {
#line 84
      goto while_break;
    }
    {
#line 85
    parport_set_data(cable->link.port, (uint8_t )((tms << 2) | (tdi << 1)));
#line 86
    cable_wait(cable);
#line 87
    parport_set_data(cable->link.port, (uint8_t )((1 | (tms << 2)) | (tdi << 1)));
#line 88
    cable_wait(cable);
#line 84
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 91
  ((generic_params_t *)cable->params)->signals &= 24;
#line 92
  ((generic_params_t *)cable->params)->signals |= 2;
#line 93
  if (tms) {
#line 93
    tmp = 4;
  } else {
#line 93
    tmp = 0;
  }
#line 93
  ((generic_params_t *)cable->params)->signals |= tmp;
#line 94
  if (tdi) {
#line 94
    tmp___0 = 1;
  } else {
#line 94
    tmp___0 = 0;
  }
#line 94
  ((generic_params_t *)cable->params)->signals |= tmp___0;
#line 95
  return;
}
}
#line 97 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/mpcbdm.c"
static int mpcbdm_get_tdo___0(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 100
  parport_set_data(cable->link.port, (uint8_t )0);
#line 101
  ((generic_params_t *)cable->params)->signals &= -8;
#line 103
  cable_wait(cable);
#line 105
  tmp = parport_get_status(cable->link.port);
  }
#line 105
  return ((tmp >> 5) & 1);
}
}
#line 108 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/mpcbdm.c"
static int mpcbdm_set_signal___0(cable_t *cable , int mask , int val ) 
{ 
  int prev_sigs ;
  int sigs ;
  int data ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int data___0 ;
  int tmp___2 ;

  {
#line 111
  prev_sigs = ((generic_params_t *)cable->params)->signals;
#line 113
  mask &= 31;
#line 115
  if (mask) {
#line 117
    sigs = (((generic_params_t *)cable->params)->signals & ~ mask) | (val & mask);
#line 119
    if ((mask & -25) != 0) {
#line 121
      data = 0;
#line 122
      if (sigs & 1) {
#line 122
        tmp = 1 << 1;
      } else {
#line 122
        tmp = 0;
      }
#line 122
      data |= tmp;
#line 123
      if (sigs & 2) {
#line 123
        tmp___0 = 1;
      } else {
#line 123
        tmp___0 = 0;
      }
#line 123
      data |= tmp___0;
#line 124
      if (sigs & 4) {
#line 124
        tmp___1 = 1 << 2;
      } else {
#line 124
        tmp___1 = 0;
      }
      {
#line 124
      data |= tmp___1;
#line 125
      parport_set_data(cable->link.port, (uint8_t )data);
      }
    }
#line 127
    if ((mask & 24) != 0) {
#line 129
      data___0 = 0;
#line 130
      if (sigs & 8) {
#line 130
        tmp___2 = 0;
      } else {
#line 130
        tmp___2 = 1;
      }
      {
#line 130
      data___0 |= tmp___2;
#line 132
      parport_set_control(cable->link.port, (uint8_t )data___0);
      }
    }
#line 134
    ((generic_params_t *)cable->params)->signals = sigs;
  }
#line 137
  return (prev_sigs);
}
}
#line 54 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/lattice.c"
static int lattice_init___0(cable_t *cable ) 
{ 
  int data ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 59
  tmp = parport_open(cable->link.port);
  }
#line 59
  if (tmp) {
#line 60
    return (-1);
  }
  {
#line 62
  data = parport_get_data(cable->link.port);
  }
#line 62
  if (data < 0) {
    {
#line 63
    tmp___0 = parport_set_data(cable->link.port, (uint8_t )(1 << 4));
    }
#line 63
    if (tmp___0) {
#line 64
      return (-1);
    }
#line 65
    ((generic_params_t *)cable->params)->signals = 8;
  } else
#line 67
  if (data >> 4) {
#line 67
    ((generic_params_t *)cable->params)->signals = 8;
  } else {
#line 67
    ((generic_params_t *)cable->params)->signals = 0;
  }
#line 69
  return (0);
}
}
#line 72 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/lattice.c"
static void lattice_clock___0(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;
  int trst ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 76
  if (((generic_params_t *)cable->params)->signals & 8) {
#line 76
    tmp = 1;
  } else {
#line 76
    tmp = 0;
  }
#line 76
  trst = tmp;
#line 78
  if (tms) {
#line 78
    tms = 1;
  } else {
#line 78
    tms = 0;
  }
#line 79
  if (tdi) {
#line 79
    tdi = 1;
  } else {
#line 79
    tdi = 0;
  }
#line 81
  i = 0;
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    if (! (i < n)) {
#line 81
      goto while_break;
    }
    {
#line 82
    parport_set_data(cable->link.port, (uint8_t )(((trst << 4) | (tms << 2)) | tdi));
#line 83
    cable_wait(cable);
#line 84
    parport_set_data(cable->link.port, (uint8_t )((((trst << 4) | (1 << 1)) | (tms << 2)) | tdi));
#line 85
    cable_wait(cable);
#line 81
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 88
  ((generic_params_t *)cable->params)->signals &= 8;
#line 89
  ((generic_params_t *)cable->params)->signals |= 2;
#line 90
  if (tms) {
#line 90
    tmp___0 = 4;
  } else {
#line 90
    tmp___0 = 0;
  }
#line 90
  ((generic_params_t *)cable->params)->signals |= tmp___0;
#line 91
  if (tdi) {
#line 91
    tmp___1 = 1;
  } else {
#line 91
    tmp___1 = 0;
  }
#line 91
  ((generic_params_t *)cable->params)->signals |= tmp___1;
#line 92
  return;
}
}
#line 94 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/lattice.c"
static int lattice_get_tdo___0(cable_t *cable ) 
{ 
  int trst ;
  int tmp ;
  int tmp___0 ;

  {
#line 97
  if (((generic_params_t *)cable->params)->signals & 8) {
#line 97
    tmp = 1;
  } else {
#line 97
    tmp = 0;
  }
  {
#line 97
  trst = tmp;
#line 99
  parport_set_data(cable->link.port, (uint8_t )(trst << 4));
#line 100
  ((generic_params_t *)cable->params)->signals &= -8;
#line 102
  cable_wait(cable);
#line 104
  tmp___0 = parport_get_status(cable->link.port);
  }
#line 104
  return ((tmp___0 >> 6) & 1);
}
}
#line 107 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/lattice.c"
static int lattice_set_signal___0(cable_t *cable , int mask , int val ) 
{ 
  int prev_sigs ;
  int data ;
  int sigs ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 110
  prev_sigs = ((generic_params_t *)cable->params)->signals;
#line 112
  mask &= 15;
#line 114
  if (mask != 0) {
#line 116
    data = 0;
#line 117
    sigs = (((generic_params_t *)cable->params)->signals & ~ mask) | (val & mask);
#line 118
    if (sigs & 1) {
#line 118
      tmp = 1;
    } else {
#line 118
      tmp = 0;
    }
#line 118
    data |= tmp;
#line 119
    if (sigs & 2) {
#line 119
      tmp___0 = 1 << 1;
    } else {
#line 119
      tmp___0 = 0;
    }
#line 119
    data |= tmp___0;
#line 120
    if (sigs & 4) {
#line 120
      tmp___1 = 1 << 2;
    } else {
#line 120
      tmp___1 = 0;
    }
#line 120
    data |= tmp___1;
#line 121
    if (sigs & 8) {
#line 121
      tmp___2 = 1 << 4;
    } else {
#line 121
      tmp___2 = 0;
    }
    {
#line 121
    data |= tmp___2;
#line 122
    parport_set_data(cable->link.port, (uint8_t )data);
#line 123
    ((generic_params_t *)cable->params)->signals = sigs;
    }
  }
#line 126
  return (prev_sigs);
}
}
#line 66 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/keithkoep.c"
static int keithkoep_init___0(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 69
  tmp = parport_open(cable->link.port);
  }
#line 69
  if (tmp) {
#line 70
    return (-1);
  }
  {
#line 72
  parport_set_control(cable->link.port, (uint8_t )1);
#line 73
  ((generic_params_t *)cable->params)->signals = 8;
  }
#line 75
  return (0);
}
}
#line 78 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/keithkoep.c"
static void keithkoep_clock___0(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 83
  if (tms) {
#line 83
    tms = 1;
  } else {
#line 83
    tms = 0;
  }
#line 84
  if (tdi) {
#line 84
    tdi = 1;
  } else {
#line 84
    tdi = 0;
  }
#line 86
  i = 0;
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
#line 86
    if (! (i < n)) {
#line 86
      goto while_break;
    }
    {
#line 87
    parport_set_data(cable->link.port, (uint8_t )((tms << 2) | tdi));
#line 88
    cable_wait(cable);
#line 89
    parport_set_data(cable->link.port, (uint8_t )(((1 << 1) | (tms << 2)) | tdi));
#line 90
    cable_wait(cable);
#line 86
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 93
  ((generic_params_t *)cable->params)->signals &= 8;
#line 94
  ((generic_params_t *)cable->params)->signals |= 2;
#line 95
  if (tms) {
#line 95
    tmp = 4;
  } else {
#line 95
    tmp = 0;
  }
#line 95
  ((generic_params_t *)cable->params)->signals |= tmp;
#line 96
  if (tdi) {
#line 96
    tmp___0 = 1;
  } else {
#line 96
    tmp___0 = 0;
  }
#line 96
  ((generic_params_t *)cable->params)->signals |= tmp___0;
#line 97
  return;
}
}
#line 99 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/keithkoep.c"
static int keithkoep_get_tdo___0(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 102
  parport_set_data(cable->link.port, (uint8_t )0);
#line 103
  ((generic_params_t *)cable->params)->signals &= -8;
#line 105
  cable_wait(cable);
#line 107
  tmp = parport_get_status(cable->link.port);
  }
#line 107
  return ((tmp >> 5) & 1);
}
}
#line 110 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/keithkoep.c"
static int keithkoep_set_signal___0(cable_t *cable , int mask , int val ) 
{ 
  int prev_sigs ;
  int sigs ;
  int data ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 113
  prev_sigs = ((generic_params_t *)cable->params)->signals;
#line 115
  mask &= 15;
#line 117
  if (mask != 0) {
#line 119
    sigs = (prev_sigs & ~ mask) | (val & mask);
#line 121
    if ((mask & -9) != 0) {
#line 123
      data = 0;
#line 124
      if (sigs & 1) {
#line 124
        tmp = 1;
      } else {
#line 124
        tmp = 0;
      }
#line 124
      data |= tmp;
#line 125
      if (sigs & 2) {
#line 125
        tmp___0 = 1 << 1;
      } else {
#line 125
        tmp___0 = 0;
      }
#line 125
      data |= tmp___0;
#line 126
      if (sigs & 4) {
#line 126
        tmp___1 = 1 << 2;
      } else {
#line 126
        tmp___1 = 0;
      }
      {
#line 126
      data |= tmp___1;
#line 127
      parport_set_data(cable->link.port, (uint8_t )data);
      }
    }
#line 129
    if ((mask & 8) != 0) {
#line 131
      if (sigs & 8) {
#line 131
        tmp___2 = 1;
      } else {
#line 131
        tmp___2 = 0;
      }
      {
#line 131
      parport_set_control(cable->link.port, (uint8_t )tmp___2);
      }
    }
#line 133
    ((generic_params_t *)cable->params)->signals = sigs;
  }
#line 136
  return (prev_sigs);
}
}
#line 54 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/ei012.c"
static int ei012_init___0(cable_t *cable ) 
{ 
  int data ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 59
  tmp = parport_open(cable->link.port);
  }
#line 59
  if (tmp) {
#line 60
    return (-1);
  }
  {
#line 62
  data = parport_get_data(cable->link.port);
  }
#line 62
  if (data < 0) {
    {
#line 63
    tmp___0 = parport_set_data(cable->link.port, (uint8_t )(1 << 4));
    }
#line 63
    if (tmp___0) {
#line 64
      return (-1);
    }
#line 65
    ((generic_params_t *)cable->params)->signals = 8;
  } else
#line 67
  if (data >> 4) {
#line 67
    ((generic_params_t *)cable->params)->signals = 8;
  } else {
#line 67
    ((generic_params_t *)cable->params)->signals = 0;
  }
#line 69
  return (0);
}
}
#line 72 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/ei012.c"
static void ei012_clock___0(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;
  int trst ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 76
  if (((generic_params_t *)cable->params)->signals & 8) {
#line 76
    tmp = 1;
  } else {
#line 76
    tmp = 0;
  }
#line 76
  trst = tmp;
#line 78
  if (tms) {
#line 78
    tms = 1;
  } else {
#line 78
    tms = 0;
  }
#line 79
  if (tdi) {
#line 79
    tdi = 1;
  } else {
#line 79
    tdi = 0;
  }
#line 81
  i = 0;
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    if (! (i < n)) {
#line 81
      goto while_break;
    }
    {
#line 82
    parport_set_data(cable->link.port, (uint8_t )(((trst << 4) | (tms << 2)) | (tdi << 1)));
#line 83
    cable_wait(cable);
#line 84
    parport_set_data(cable->link.port, (uint8_t )((((trst << 4) | 1) | (tms << 2)) | (tdi << 1)));
#line 85
    cable_wait(cable);
#line 81
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 88
  ((generic_params_t *)cable->params)->signals &= 8;
#line 89
  ((generic_params_t *)cable->params)->signals |= 2;
#line 90
  if (tms) {
#line 90
    tmp___0 = 4;
  } else {
#line 90
    tmp___0 = 0;
  }
#line 90
  ((generic_params_t *)cable->params)->signals |= tmp___0;
#line 91
  if (tdi) {
#line 91
    tmp___1 = 1;
  } else {
#line 91
    tmp___1 = 0;
  }
#line 91
  ((generic_params_t *)cable->params)->signals |= tmp___1;
#line 92
  return;
}
}
#line 94 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/ei012.c"
static int ei012_get_tdo___0(cable_t *cable ) 
{ 
  int trst ;
  int tmp ;
  int tmp___0 ;

  {
#line 97
  if (((generic_params_t *)cable->params)->signals & 8) {
#line 97
    tmp = 1;
  } else {
#line 97
    tmp = 0;
  }
  {
#line 97
  trst = tmp;
#line 99
  parport_set_data(cable->link.port, (uint8_t )(trst << 4));
#line 100
  ((generic_params_t *)cable->params)->signals &= -8;
#line 102
  cable_wait(cable);
#line 104
  tmp___0 = parport_get_status(cable->link.port);
  }
#line 104
  return ((tmp___0 >> 7) & 1);
}
}
#line 107 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/ei012.c"
static int ei012_set_signal___0(cable_t *cable , int mask , int val ) 
{ 
  int prev_sigs ;
  int data ;
  int sigs ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 110
  prev_sigs = ((generic_params_t *)cable->params)->signals;
#line 112
  mask &= 15;
#line 114
  if (mask != 0) {
#line 116
    data = 0;
#line 117
    sigs = (prev_sigs & ~ mask) | (val & mask);
#line 118
    if (sigs & 1) {
#line 118
      tmp = 1 << 1;
    } else {
#line 118
      tmp = 0;
    }
#line 118
    data |= tmp;
#line 119
    if (sigs & 2) {
#line 119
      tmp___0 = 1;
    } else {
#line 119
      tmp___0 = 0;
    }
#line 119
    data |= tmp___0;
#line 120
    if (sigs & 4) {
#line 120
      tmp___1 = 1 << 2;
    } else {
#line 120
      tmp___1 = 0;
    }
#line 120
    data |= tmp___1;
#line 121
    if (sigs & 8) {
#line 121
      tmp___2 = 1 << 4;
    } else {
#line 121
      tmp___2 = 0;
    }
    {
#line 121
    data |= tmp___2;
#line 122
    parport_set_data(cable->link.port, (uint8_t )data);
#line 123
    ((generic_params_t *)cable->params)->signals = sigs;
    }
  }
#line 126
  return (prev_sigs);
}
}
#line 52 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/ea253.c"
static int ea253_init___0(cable_t *cable ) 
{ 
  int data ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 57
  tmp = parport_open(cable->link.port);
  }
#line 57
  if (tmp) {
#line 58
    return (-1);
  }
  {
#line 60
  data = parport_get_data(cable->link.port);
  }
#line 60
  if (data < 0) {
    {
#line 61
    tmp___0 = parport_set_data(cable->link.port, (uint8_t )(1 << 4));
    }
#line 61
    if (tmp___0) {
#line 62
      return (-1);
    }
#line 63
    ((generic_params_t *)cable->params)->signals = 8;
  } else
#line 65
  if (data >> 4) {
#line 65
    ((generic_params_t *)cable->params)->signals = 8;
  } else {
#line 65
    ((generic_params_t *)cable->params)->signals = 0;
  }
#line 67
  return (0);
}
}
#line 70 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/ea253.c"
static void ea253_clock___0(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;
  int trst ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 74
  if (((generic_params_t *)cable->params)->signals & 8) {
#line 74
    tmp = 1;
  } else {
#line 74
    tmp = 0;
  }
#line 74
  trst = tmp;
#line 76
  if (tms) {
#line 76
    tms = 1;
  } else {
#line 76
    tms = 0;
  }
#line 77
  if (tdi) {
#line 77
    tdi = 1;
  } else {
#line 77
    tdi = 0;
  }
#line 79
  i = 0;
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (! (i < n)) {
#line 79
      goto while_break;
    }
    {
#line 80
    parport_set_data(cable->link.port, (uint8_t )(((trst << 4) | (tms << 2)) | tdi));
#line 81
    cable_wait(cable);
#line 82
    parport_set_data(cable->link.port, (uint8_t )((((trst << 4) | (1 << 1)) | (tms << 2)) | tdi));
#line 83
    cable_wait(cable);
#line 79
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 86
  ((generic_params_t *)cable->params)->signals &= 8;
#line 87
  ((generic_params_t *)cable->params)->signals |= 2;
#line 88
  if (tms) {
#line 88
    tmp___0 = 4;
  } else {
#line 88
    tmp___0 = 0;
  }
#line 88
  ((generic_params_t *)cable->params)->signals |= tmp___0;
#line 89
  if (tdi) {
#line 89
    tmp___1 = 1;
  } else {
#line 89
    tmp___1 = 0;
  }
#line 89
  ((generic_params_t *)cable->params)->signals |= tmp___1;
#line 90
  return;
}
}
#line 92 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/ea253.c"
static int ea253_get_tdo___0(cable_t *cable ) 
{ 
  int trst ;
  int tmp ;
  int tmp___0 ;

  {
#line 95
  if (((generic_params_t *)cable->params)->signals & 8) {
#line 95
    tmp = 1;
  } else {
#line 95
    tmp = 0;
  }
  {
#line 95
  trst = tmp;
#line 97
  parport_set_data(cable->link.port, (uint8_t )(trst << 4));
#line 98
  ((generic_params_t *)cable->params)->signals &= -8;
#line 100
  cable_wait(cable);
#line 102
  tmp___0 = parport_get_status(cable->link.port);
  }
#line 102
  return ((tmp___0 >> 4) & 1);
}
}
#line 105 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/ea253.c"
static int ea253_set_signal___0(cable_t *cable , int mask , int val ) 
{ 
  int prev_sigs ;
  int data ;
  int sigs ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 108
  prev_sigs = ((generic_params_t *)cable->params)->signals;
#line 110
  mask &= 15;
#line 112
  if (mask != 0) {
#line 114
    data = 0;
#line 115
    sigs = (prev_sigs & ~ mask) | (val & mask);
#line 116
    if (sigs & 1) {
#line 116
      tmp = 1;
    } else {
#line 116
      tmp = 0;
    }
#line 116
    data |= tmp;
#line 117
    if (sigs & 2) {
#line 117
      tmp___0 = 1 << 1;
    } else {
#line 117
      tmp___0 = 0;
    }
#line 117
    data |= tmp___0;
#line 118
    if (sigs & 4) {
#line 118
      tmp___1 = 1 << 2;
    } else {
#line 118
      tmp___1 = 0;
    }
#line 118
    data |= tmp___1;
#line 119
    if (sigs & 8) {
#line 119
      tmp___2 = 1 << 4;
    } else {
#line 119
      tmp___2 = 0;
    }
    {
#line 119
    data |= tmp___2;
#line 120
    parport_set_data(cable->link.port, (uint8_t )data);
#line 121
    ((generic_params_t *)cable->params)->signals = sigs;
    }
  }
#line 124
  return (prev_sigs);
}
}
#line 59 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/dlc5.c"
static int dlc5_init___0(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 62
  tmp = parport_open(cable->link.port);
  }
#line 62
  if (tmp) {
#line 63
    return (-1);
  }
#line 65
  ((generic_params_t *)cable->params)->signals = 8;
#line 67
  return (0);
}
}
#line 70 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/dlc5.c"
static void dlc5_clock___0(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 75
  if (tms) {
#line 75
    tms = 1;
  } else {
#line 75
    tms = 0;
  }
#line 76
  if (tdi) {
#line 76
    tdi = 1;
  } else {
#line 76
    tdi = 0;
  }
#line 78
  i = 0;
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    if (! (i < n)) {
#line 78
      goto while_break;
    }
    {
#line 79
    parport_set_data(cable->link.port, (uint8_t )(((1 << 4) | (tms << 2)) | tdi));
#line 80
    cable_wait(cable);
#line 81
    parport_set_data(cable->link.port, (uint8_t )((((1 << 4) | (1 << 1)) | (tms << 2)) | tdi));
#line 82
    cable_wait(cable);
#line 78
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  ((generic_params_t *)cable->params)->signals &= 8;
#line 86
  ((generic_params_t *)cable->params)->signals |= 2;
#line 87
  if (tms) {
#line 87
    tmp = 4;
  } else {
#line 87
    tmp = 0;
  }
#line 87
  ((generic_params_t *)cable->params)->signals |= tmp;
#line 88
  if (tdi) {
#line 88
    tmp___0 = 1;
  } else {
#line 88
    tmp___0 = 0;
  }
#line 88
  ((generic_params_t *)cable->params)->signals |= tmp___0;
#line 89
  return;
}
}
#line 91 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/dlc5.c"
static int dlc5_get_tdo___0(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 94
  parport_set_data(cable->link.port, (uint8_t )(1 << 4));
#line 95
  ((generic_params_t *)cable->params)->signals &= -8;
#line 97
  cable_wait(cable);
#line 99
  tmp = parport_get_status(cable->link.port);
  }
#line 99
  return ((tmp >> 4) & 1);
}
}
#line 102 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/dlc5.c"
static int dlc5_set_signal___0(cable_t *cable , int mask , int val ) 
{ 
  int prev_sigs ;
  int data ;
  int sigs ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 105
  prev_sigs = ((generic_params_t *)cable->params)->signals;
#line 107
  mask &= 7;
#line 109
  if (mask != 0) {
#line 111
    data = 0;
#line 112
    sigs = (prev_sigs & ~ mask) | (val & mask);
#line 113
    if (sigs & 1) {
#line 113
      tmp = 1;
    } else {
#line 113
      tmp = 0;
    }
#line 113
    data |= tmp;
#line 114
    if (sigs & 2) {
#line 114
      tmp___0 = 1 << 1;
    } else {
#line 114
      tmp___0 = 0;
    }
#line 114
    data |= tmp___0;
#line 115
    if (sigs & 4) {
#line 115
      tmp___1 = 1 << 2;
    } else {
#line 115
      tmp___1 = 0;
    }
    {
#line 115
    data |= tmp___1;
#line 116
    parport_set_data(cable->link.port, (uint8_t )((1 << 4) | data));
#line 117
    ((generic_params_t *)cable->params)->signals = sigs;
    }
  }
#line 120
  return (prev_sigs);
}
}
#line 119 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/parport/direct.c"
static port_node_t *ports___2  =    (port_node_t *)((void *)0);
#line 125 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/parport/direct.c"
static parport_t *direct_parport_alloc___0(unsigned int port ) 
{ 
  direct_params_t *params ;
  void *tmp ;
  parport_t *parport ;
  void *tmp___0 ;
  port_node_t *node ;
  void *tmp___1 ;

  {
  {
#line 128
  tmp = malloc((size_t )sizeof(*params));
#line 128
  params = (direct_params_t *)tmp;
#line 129
  tmp___0 = malloc((size_t )sizeof(*parport));
#line 129
  parport = (parport_t *)tmp___0;
#line 130
  tmp___1 = malloc((size_t )sizeof(*node));
#line 130
  node = (port_node_t *)tmp___1;
  }
#line 149
  if (! node) {
    {
#line 153
    free((void *)node);
#line 154
    free((void *)parport);
#line 155
    free((void *)params);
    }
#line 156
    return ((parport_t *)((void *)0));
  } else
#line 149
  if (! parport) {
    {
#line 153
    free((void *)node);
#line 154
    free((void *)parport);
#line 155
    free((void *)params);
    }
#line 156
    return ((parport_t *)((void *)0));
  } else
#line 149
  if (! params) {
    {
#line 153
    free((void *)node);
#line 154
    free((void *)parport);
#line 155
    free((void *)params);
    }
#line 156
    return ((parport_t *)((void *)0));
  }
#line 159
  params->port = port;
#line 161
  parport->params = (void *)params;
#line 162
  parport->driver = & direct_parport_driver;
#line 163
  parport->cable = (cable_t *)((void *)0);
#line 165
  node->port = parport;
#line 166
  node->next = ports___2;
#line 168
  ports___2 = node;
#line 170
  return (parport);
}
}
#line 173 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/parport/direct.c"
static void direct_parport_free___0(parport_t *port ) 
{ 
  port_node_t **prev ;
  port_node_t *pn ;

  {
#line 178
  prev = & ports___2;
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
#line 178
    if (! *prev) {
#line 178
      goto while_break;
    }
#line 179
    if ((unsigned long )(*prev)->port == (unsigned long )port) {
#line 180
      goto while_break;
    }
#line 178
    prev = & (*prev)->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 182
  if (*prev) {
    {
#line 183
    pn = *prev;
#line 184
    *prev = pn->next;
#line 185
    free((void *)pn);
    }
  }
  {
#line 188
  free(port->params);
#line 189
  free((void *)port);
  }
#line 195
  return;
}
}
#line 242 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/parport/direct.c"
static int direct_open___0(parport_t *parport ) 
{ 
  unsigned int port ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 248
  port = ((direct_params_t *)parport->params)->port;
#line 249
  if (port + 3U <= 1024U) {
    {
#line 249
    tmp = ioperm((unsigned long )port, 3UL, 1);
    }
#line 249
    if (tmp) {
#line 249
      tmp___1 = 1;
    } else {
#line 249
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 249
  if (port + 3U > 1024U) {
    {
#line 249
    tmp___0 = iopl(3);
    }
#line 249
    if (tmp___0) {
#line 249
      tmp___1 = 1;
    } else {
#line 249
      tmp___1 = 0;
    }
  } else {
#line 249
    tmp___1 = 0;
  }
#line 249
  return (tmp___1);
}
}
#line 253 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/parport/direct.c"
static int direct_close___0(parport_t *parport ) 
{ 
  unsigned int port ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 259
  port = ((direct_params_t *)parport->params)->port;
#line 260
  if (port + 3U <= 1024U) {
    {
#line 260
    tmp = ioperm((unsigned long )port, 3UL, 0);
#line 260
    tmp___1 = tmp;
    }
  } else {
    {
#line 260
    tmp___0 = iopl(0);
#line 260
    tmp___1 = tmp___0;
    }
  }
#line 260
  return (tmp___1);
}
}
#line 264 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/parport/direct.c"
static int direct_set_data___0(parport_t *parport , uint8_t data ) 
{ 
  unsigned int port ;

  {
  {
#line 267
  port = ((direct_params_t *)parport->params)->port;
#line 268
  outb(data, (unsigned short )port);
  }
#line 269
  return (0);
}
}
#line 272 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/parport/direct.c"
static int direct_get_data___0(parport_t *parport ) 
{ 
  unsigned int port ;
  unsigned char tmp ;

  {
  {
#line 275
  port = ((direct_params_t *)parport->params)->port;
#line 276
  tmp = inb((unsigned short )port);
  }
#line 276
  return ((int )tmp);
}
}
#line 279 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/parport/direct.c"
static int direct_get_status___0(parport_t *parport ) 
{ 
  unsigned int port ;
  unsigned char tmp ;

  {
  {
#line 282
  port = ((direct_params_t *)parport->params)->port;
#line 283
  tmp = inb((unsigned short )(port + 1U));
  }
#line 283
  return ((int )tmp ^ 128);
}
}
#line 286 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/parport/direct.c"
static int direct_set_control___0(parport_t *parport , uint8_t data ) 
{ 
  unsigned int port ;

  {
  {
#line 289
  port = ((direct_params_t *)parport->params)->port;
#line 290
  outb((unsigned char )((int )data ^ 11), (unsigned short )(port + 2U));
  }
#line 291
  return (0);
}
}
#line 50 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/detect.c"
static int find_record___0(char *filename , tap_register *key , struct id_record *idr ) 
{ 
  FILE *file ;
  tap_register *tr ;
  int r ;
  char *tmp ;
  char *p ;
  char *s ;
  char line[1024] ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  unsigned short const   **tmp___7 ;
  unsigned short const   **tmp___8 ;
  char *tmp___9 ;
  size_t tmp___10 ;
  unsigned short const   **tmp___11 ;
  size_t tmp___12 ;
  void *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
  {
#line 55
  r = 0;
#line 57
  file = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 58
  if (! file) {
    {
#line 59
    tmp = gettext("Cannot open %s\n");
#line 59
    printf((char const   */* __restrict  */)tmp, filename);
    }
#line 60
    return (0);
  }
  {
#line 63
  tr = register_alloc(key->len);
  }
  {
#line 65
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 70
    tmp___0 = fgets((char */* __restrict  */)(line), 1024, (FILE */* __restrict  */)file);
    }
#line 70
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 71
      goto while_break;
    }
    {
#line 74
    p = strpbrk((char const   *)(line), "#\n");
    }
#line 75
    if (p) {
#line 76
      *p = (char )'\000';
    }
#line 78
    p = line;
    {
#line 81
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 81
      if (*p) {
        {
#line 81
        tmp___1 = __ctype_b_loc();
        }
#line 81
        if (! ((int const   )*(*tmp___1 + (int )*p) & 8192)) {
#line 81
          goto while_break___0;
        }
      } else {
#line 81
        goto while_break___0;
      }
#line 82
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 85
    s = strchr((char const   *)p, '\000');
    }
    {
#line 86
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 86
      if (! ((unsigned long )s != (unsigned long )p)) {
#line 86
        goto while_break___1;
      }
      {
#line 87
      tmp___2 = __ctype_b_loc();
#line 87
      s --;
      }
#line 87
      if (! ((int const   )*(*tmp___2 + (int )*s) & 8192)) {
#line 88
        goto while_break___1;
      }
#line 89
      *s = (char )'\000';
    }
    while_break___1: /* CIL Label */ ;
    }
#line 93
    if (! *p) {
#line 94
      goto __Cont;
    }
#line 97
    s = p;
    {
#line 98
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 98
      if (*s) {
        {
#line 98
        tmp___3 = __ctype_b_loc();
        }
#line 98
        if ((int const   )*(*tmp___3 + (int )*s) & 8192) {
#line 98
          goto while_break___2;
        }
      } else {
#line 98
        goto while_break___2;
      }
#line 99
      s ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 100
    if (*s) {
#line 101
      tmp___4 = s;
#line 101
      s ++;
#line 101
      *tmp___4 = (char )'\000';
    }
    {
#line 104
    tmp___5 = strlen((char const   *)p);
    }
#line 104
    if (tmp___5 != (size_t )key->len) {
#line 105
      goto __Cont;
    }
    {
#line 108
    register_init(tr, (char const   *)p);
#line 109
    tmp___6 = register_compare((tap_register const   *)tr, (tap_register const   *)key);
    }
#line 109
    if (tmp___6) {
#line 110
      goto __Cont;
    }
#line 113
    p = s;
    {
#line 116
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 116
      if (*p) {
        {
#line 116
        tmp___7 = __ctype_b_loc();
        }
#line 116
        if (! ((int const   )*(*tmp___7 + (int )*p) & 8192)) {
#line 116
          goto while_break___3;
        }
      } else {
#line 116
        goto while_break___3;
      }
#line 117
      p ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 120
    if (! *p) {
#line 121
      goto __Cont;
    }
#line 124
    s = p;
    {
#line 125
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 125
      if (*s) {
        {
#line 125
        tmp___8 = __ctype_b_loc();
        }
#line 125
        if ((int const   )*(*tmp___8 + (int )*s) & 8192) {
#line 125
          goto while_break___4;
        }
      } else {
#line 125
        goto while_break___4;
      }
#line 126
      s ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 127
    if (*s) {
#line 128
      tmp___9 = s;
#line 128
      s ++;
#line 128
      *tmp___9 = (char )'\000';
    }
    {
#line 131
    tmp___10 = strlen((char const   *)p);
    }
#line 131
    if ((unsigned long )tmp___10 >= sizeof(idr->name)) {
#line 132
      goto __Cont;
    }
    {
#line 135
    strcpy((char */* __restrict  */)(idr->name), (char const   */* __restrict  */)p);
#line 138
    p = s;
    }
    {
#line 141
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 141
      if (*p) {
        {
#line 141
        tmp___11 = __ctype_b_loc();
        }
#line 141
        if (! ((int const   )*(*tmp___11 + (int )*p) & 8192)) {
#line 141
          goto while_break___5;
        }
      } else {
#line 141
        goto while_break___5;
      }
#line 142
      p ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 145
    if (! *p) {
#line 146
      goto __Cont;
    }
    {
#line 149
    tmp___12 = strlen((char const   *)p);
    }
#line 149
    if ((unsigned long )tmp___12 >= sizeof(idr->fullname)) {
#line 150
      goto __Cont;
    }
    {
#line 153
    strcpy((char */* __restrict  */)(idr->fullname), (char const   */* __restrict  */)p);
#line 155
    r = 1;
    }
#line 156
    goto while_break;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 159
  fclose(file);
#line 161
  register_free(tr);
  }
#line 163
  return (r);
}
}
#line 49 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/cmd_xfer.c"
static int extend_cmd_buffer___0(cx_cmd_t *cmd ) 
{ 
  void *tmp ;
  int tmp___0 ;

  {
#line 53
  if (cmd->buf_pos >= cmd->buf_len) {
#line 55
    cmd->buf_len *= 2U;
#line 56
    if (cmd->buf) {
      {
#line 57
      tmp = realloc((void *)cmd->buf, cmd->buf_len);
#line 57
      cmd->buf = (uint8_t *)tmp;
      }
    }
  }
#line 60
  if (cmd->buf) {
#line 60
    tmp___0 = 1;
  } else {
#line 60
    tmp___0 = 0;
  }
#line 60
  return (tmp___0);
}
}
#line 70 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/byteblaster.c"
static int byteblaster_init___0(cable_t *cable ) 
{ 
  int BB_II ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 73
  BB_II = 0;
#line 75
  tmp = parport_open(cable->link.port);
  }
#line 75
  if (tmp) {
#line 76
    return (-1);
  }
  {
#line 78
  ((generic_params_t *)cable->params)->signals = 8;
#line 81
  parport_set_data(cable->link.port, (uint8_t )(1 << 5));
#line 82
  tmp___0 = parport_get_status(cable->link.port);
  }
#line 82
  if (! ((tmp___0 >> 6) & 1)) {
#line 83
    BB_II = 1;
  }
  {
#line 84
  parport_set_data(cable->link.port, (uint8_t )0);
#line 85
  tmp___1 = parport_get_status(cable->link.port);
  }
#line 85
  if ((tmp___1 >> 6) & 1) {
#line 86
    BB_II = 1;
  }
#line 90
  if (BB_II) {
    {
#line 90
    tmp___2 = parport_get_status(cable->link.port);
    }
#line 90
    if ((tmp___2 >> 3) & 1) {
#line 91
      return (-1);
    }
  }
  {
#line 94
  parport_set_control(cable->link.port, (uint8_t )12);
  }
#line 96
  return (0);
}
}
#line 99 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/byteblaster.c"
static void byteblaster_clock___0(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 104
  if (tms) {
#line 104
    tms = 1;
  } else {
#line 104
    tms = 0;
  }
#line 105
  if (tdi) {
#line 105
    tdi = 1;
  } else {
#line 105
    tdi = 0;
  }
#line 107
  i = 0;
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 107
    if (! (i < n)) {
#line 107
      goto while_break;
    }
    {
#line 108
    parport_set_data(cable->link.port, (uint8_t )((tms << 1) | (tdi << 6)));
#line 109
    cable_wait(cable);
#line 110
    parport_set_data(cable->link.port, (uint8_t )((1 | (tms << 1)) | (tdi << 6)));
#line 111
    cable_wait(cable);
#line 107
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 114
  ((generic_params_t *)cable->params)->signals &= 8;
#line 115
  ((generic_params_t *)cable->params)->signals |= 2;
#line 116
  if (tms) {
#line 116
    tmp = 4;
  } else {
#line 116
    tmp = 0;
  }
#line 116
  ((generic_params_t *)cable->params)->signals |= tmp;
#line 117
  if (tdi) {
#line 117
    tmp___0 = 1;
  } else {
#line 117
    tmp___0 = 0;
  }
#line 117
  ((generic_params_t *)cable->params)->signals |= tmp___0;
#line 118
  return;
}
}
#line 120 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/byteblaster.c"
static int byteblaster_get_tdo___0(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 123
  parport_set_data(cable->link.port, (uint8_t )0);
#line 124
  ((generic_params_t *)cable->params)->signals &= -8;
#line 126
  cable_wait(cable);
#line 128
  tmp = parport_get_status(cable->link.port);
  }
#line 128
  return ((tmp >> 7) & 1);
}
}
#line 131 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/byteblaster.c"
static int byteblaster_set_signal___0(cable_t *cable , int mask , int val ) 
{ 
  int prev_sigs ;
  int data ;
  int sigs ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 134
  prev_sigs = ((generic_params_t *)cable->params)->signals;
#line 136
  mask &= 7;
#line 138
  if (mask != 0) {
#line 140
    data = 0;
#line 141
    sigs = (prev_sigs & ~ mask) | (val & mask);
#line 142
    if (sigs & 1) {
#line 142
      tmp = 1 << 6;
    } else {
#line 142
      tmp = 0;
    }
#line 142
    data |= tmp;
#line 143
    if (sigs & 2) {
#line 143
      tmp___0 = 1;
    } else {
#line 143
      tmp___0 = 0;
    }
#line 143
    data |= tmp___0;
#line 144
    if (sigs & 4) {
#line 144
      tmp___1 = 1 << 1;
    } else {
#line 144
      tmp___1 = 0;
    }
    {
#line 144
    data |= tmp___1;
#line 145
    parport_set_data(cable->link.port, (uint8_t )data);
#line 146
    ((generic_params_t *)cable->params)->signals = sigs;
    }
  }
#line 149
  return (prev_sigs);
}
}
#line 52 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/arcom.c"
static int arcom_init___0(cable_t *cable ) 
{ 
  int data ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 57
  tmp = parport_open(cable->link.port);
  }
#line 57
  if (tmp) {
#line 58
    return (-1);
  }
  {
#line 60
  data = parport_get_data(cable->link.port);
  }
#line 60
  if (data < 0) {
    {
#line 61
    tmp___0 = parport_set_data(cable->link.port, (uint8_t )(1 << 3));
    }
#line 61
    if (tmp___0) {
#line 62
      return (-1);
    }
#line 63
    ((generic_params_t *)cable->params)->signals = 8;
  } else
#line 65
  if (data >> 3) {
#line 65
    ((generic_params_t *)cable->params)->signals = 8;
  } else {
#line 65
    ((generic_params_t *)cable->params)->signals = 0;
  }
#line 67
  return (0);
}
}
#line 70 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/arcom.c"
static void arcom_clock___0(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;
  int trst ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 74
  if (((generic_params_t *)cable->params)->signals & 8) {
#line 74
    tmp = 1;
  } else {
#line 74
    tmp = 0;
  }
#line 74
  trst = tmp;
#line 76
  if (tms) {
#line 76
    tms = 1;
  } else {
#line 76
    tms = 0;
  }
#line 77
  if (tdi) {
#line 77
    tdi = 1;
  } else {
#line 77
    tdi = 0;
  }
#line 79
  i = 0;
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (! (i < n)) {
#line 79
      goto while_break;
    }
    {
#line 80
    parport_set_data(cable->link.port, (uint8_t )(((trst << 3) | (tms << 2)) | (tdi << 1)));
#line 81
    cable_wait(cable);
#line 82
    parport_set_data(cable->link.port, (uint8_t )((((trst << 3) | 1) | (tms << 2)) | (tdi << 1)));
#line 83
    cable_wait(cable);
#line 79
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 86
  ((generic_params_t *)cable->params)->signals &= 8;
#line 87
  ((generic_params_t *)cable->params)->signals |= 2;
#line 88
  if (tms) {
#line 88
    tmp___0 = 4;
  } else {
#line 88
    tmp___0 = 0;
  }
#line 88
  ((generic_params_t *)cable->params)->signals |= tmp___0;
#line 89
  if (tdi) {
#line 89
    tmp___1 = 1;
  } else {
#line 89
    tmp___1 = 0;
  }
#line 89
  ((generic_params_t *)cable->params)->signals |= tmp___1;
#line 90
  return;
}
}
#line 92 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/arcom.c"
static int arcom_get_tdo___0(cable_t *cable ) 
{ 
  int trst ;
  int tmp ;
  int tmp___0 ;

  {
#line 95
  if (((generic_params_t *)cable->params)->signals & 8) {
#line 95
    tmp = 1;
  } else {
#line 95
    tmp = 0;
  }
  {
#line 95
  trst = tmp;
#line 97
  parport_set_data(cable->link.port, (uint8_t )(trst << 3));
#line 98
  ((generic_params_t *)cable->params)->signals &= -8;
#line 100
  cable_wait(cable);
#line 102
  tmp___0 = parport_get_status(cable->link.port);
  }
#line 102
  return ((tmp___0 >> 7) & 1);
}
}
#line 105 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/tap/cable/arcom.c"
static int arcom_set_signal___0(cable_t *cable , int mask , int val ) 
{ 
  int prev_sigs ;
  int data ;
  int sigs ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 108
  prev_sigs = ((generic_params_t *)cable->params)->signals;
#line 110
  mask &= 15;
#line 112
  if (mask != 0) {
#line 114
    data = 0;
#line 115
    sigs = (prev_sigs & ~ mask) | (val & mask);
#line 116
    if (sigs & 1) {
#line 116
      tmp = 1 << 1;
    } else {
#line 116
      tmp = 0;
    }
#line 116
    data |= tmp;
#line 117
    if (sigs & 2) {
#line 117
      tmp___0 = 1;
    } else {
#line 117
      tmp___0 = 0;
    }
#line 117
    data |= tmp___0;
#line 118
    if (sigs & 4) {
#line 118
      tmp___1 = 1 << 2;
    } else {
#line 118
      tmp___1 = 0;
    }
#line 118
    data |= tmp___1;
#line 119
    if (sigs & 8) {
#line 119
      tmp___2 = 1 << 3;
    } else {
#line 119
      tmp___2 = 0;
    }
    {
#line 119
    data |= tmp___2;
#line 120
    parport_set_data(cable->link.port, (uint8_t )data);
#line 121
    ((generic_params_t *)cable->params)->signals = sigs;
    }
  }
#line 124
  return (prev_sigs);
}
}
#line 32 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/writemem.c"
static int cmd_writemem_run(chain_t *chain , char **params ) 
{ 
  uint32_t adr ;
  uint32_t len ;
  FILE *f ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 39
  tmp = cmd_params(params);
  }
#line 39
  if (tmp != 4) {
#line 40
    return (-1);
  }
#line 42
  if (! bus) {
    {
#line 43
    tmp___0 = gettext("Error: Bus driver missing.\n");
#line 43
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 44
    return (1);
  }
  {
#line 47
  tmp___1 = cmd_get_number(*(params + 1), & adr);
  }
#line 47
  if (tmp___1) {
#line 48
    return (-1);
  } else {
    {
#line 47
    tmp___2 = cmd_get_number(*(params + 2), & len);
    }
#line 47
    if (tmp___2) {
#line 48
      return (-1);
    }
  }
  {
#line 50
  f = fopen((char const   */* __restrict  */)*(params + 3), (char const   */* __restrict  */)"r");
  }
#line 51
  if (! f) {
    {
#line 52
    tmp___3 = gettext("Unable to open file `%s\'!\n");
#line 52
    printf((char const   */* __restrict  */)tmp___3, *(params + 3));
    }
#line 53
    return (1);
  }
  {
#line 55
  writemem(bus, f, adr, len);
#line 56
  fclose(f);
  }
#line 58
  return (1);
}
}
#line 61 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/writemem.c"
static void cmd_writemem_help(void) 
{ 
  char *tmp ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
#line 64
  tmp = gettext("Usage: %s ADDR LEN FILENAME\nWrite to device memory starting at ADDR the FILENAME file.\n\nADDR       start address of the written memory area\nLEN        written memory length\nFILENAME   name of the input file\n\nADDR and LEN could be in decimal or hexadecimal (prefixed with 0x) form.\nNOTE: This is NOT useful for FLASH programming!\n");
#line 64
  printf((char const   */* __restrict  */)tmp, "writemem");
  }
#line 75
  return;
}
}
#line 77 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/writemem.c"
cmd_t cmd_writemem  =    {(char *)"writemem", (char *)"write content of file to the memory", & cmd_writemem_help,
    & cmd_writemem_run};
#line 35 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/usleep.c"
static int cmd_usleep_run(chain_t *chain , char **params ) 
{ 
  unsigned int usecs ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 40
  tmp = cmd_params(params);
  }
#line 40
  if (tmp != 2) {
#line 41
    return (-1);
  }
  {
#line 43
  tmp___0 = cmd_get_number(*(params + 1), & usecs);
  }
#line 43
  if (tmp___0) {
#line 44
    return (-1);
  }
  {
#line 46
  usleep(usecs);
  }
#line 48
  return (1);
}
}
#line 51 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/usleep.c"
static void cmd_usleep_help(void) 
{ 
  char *tmp ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
#line 54
  tmp = gettext("Usage: %s USECS\nSleep some number of microseconds.\n");
#line 54
  printf((char const   */* __restrict  */)tmp, "usleep");
  }
#line 58
  return;
}
}
#line 60 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/usleep.c"
cmd_t cmd_usleep  =    {(char *)"usleep", (char *)"Sleep some number of microseconds", & cmd_usleep_help,
    & cmd_usleep_run};
#line 52 "../../include/cmd.h"
int cmd_test_cable(chain_t *chain ) ;
#line 37 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/test.c"
static int cmd_test_run(chain_t *chain , char **params ) 
{ 
  int data ;
  unsigned int i ;
  signal_t *s ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 44
  tmp = cmd_params(params);
  }
#line 44
  if (tmp != 4) {
#line 45
    return (-1);
  }
  {
#line 47
  tmp___0 = strcasecmp((char const   *)*(params + 1), "signal");
  }
#line 47
  if (tmp___0 != 0) {
#line 48
    return (-1);
  }
  {
#line 50
  tmp___1 = cmd_test_cable(chain);
  }
#line 50
  if (! tmp___1) {
#line 51
    return (1);
  }
#line 53
  if (! chain->parts) {
    {
#line 54
    tmp___2 = gettext("Run \"detect\" first.\n");
#line 54
    printf((char const   */* __restrict  */)tmp___2);
    }
#line 55
    return (1);
  }
#line 58
  if (chain->active_part >= (chain->parts)->len) {
    {
#line 59
    tmp___3 = gettext("%s: no active part\n");
#line 59
    printf((char const   */* __restrict  */)tmp___3, "get");
    }
#line 60
    return (1);
  }
  {
#line 63
  s = part_find_signal(*((chain->parts)->parts + chain->active_part), (char const   *)*(params + 2));
  }
#line 64
  if (! s) {
    {
#line 65
    tmp___4 = gettext("signal \'%s\' not found\n");
#line 65
    printf((char const   */* __restrict  */)tmp___4, *(params + 2));
    }
#line 66
    return (1);
  }
  {
#line 72
  tmp___5 = cmd_get_number(*(params + 3), & i);
  }
#line 72
  if (tmp___5) {
#line 73
    return (1);
  }
  {
#line 75
  data = part_get_signal(*((chain->parts)->parts + chain->active_part), s);
  }
#line 76
  if (data != -1) {
#line 77
    if ((unsigned int )data != i) {
      {
#line 78
      tmp___6 = gettext("<FAIL>%s = %d\n");
#line 78
      printf((char const   */* __restrict  */)tmp___6, *(params + 2), data);
      }
#line 79
      return (-99);
    }
  }
#line 82
  return (1);
}
}
#line 85 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/test.c"
static void cmd_test_help(void) 
{ 
  char *tmp ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
#line 88
  tmp = gettext("Usage: %s SIGNAL 0/1\nTest signal state from output BSR (Boundary Scan Register).\n\nSIGNAL        signal name (from JTAG declaration file)\n");
#line 88
  printf((char const   */* __restrict  */)tmp, "get signal");
  }
#line 94
  return;
}
}
#line 96 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/test.c"
cmd_t cmd_test  =    {(char *)"test", (char *)"test external signal value", & cmd_test_help, & cmd_test_run};
#line 35 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/svf.c"
static int cmd_svf_run(chain_t *chain , char **params ) 
{ 
  FILE *SVF_FILE ;
  int num_params ;
  int i ;
  int result ;
  int stop ;
  int print_progress ;
  uint32_t ref_freq ;
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
  {
#line 39
  result = -1;
#line 40
  stop = 0;
#line 41
  print_progress = 0;
#line 42
  ref_freq = (uint32_t )0;
#line 44
  num_params = cmd_params(params);
  }
#line 45
  if (num_params > 1) {
#line 46
    i = 2;
    {
#line 46
    while (1) {
      while_continue: /* CIL Label */ ;
#line 46
      if (! (i < num_params)) {
#line 46
        goto while_break;
      }
      {
#line 47
      tmp___2 = strcasecmp((char const   *)*(params + i), "stop");
      }
#line 47
      if (tmp___2 == 0) {
#line 48
        stop = 1;
      } else {
        {
#line 49
        tmp___1 = strcasecmp((char const   *)*(params + i), "progress");
        }
#line 49
        if (tmp___1 == 0) {
#line 50
          print_progress = 1;
        } else {
          {
#line 51
          tmp___0 = strncasecmp((char const   *)*(params + i), "ref_freq=", (size_t )9);
          }
#line 51
          if (tmp___0 == 0) {
            {
#line 52
            tmp = strtol((char const   */* __restrict  */)(*(params + i) + 9), (char **/* __restrict  */)((void *)0),
                         10);
#line 52
            ref_freq = (uint32_t )tmp;
            }
          } else {
#line 54
            return (-1);
          }
        }
      }
#line 46
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 57
    SVF_FILE = fopen((char const   */* __restrict  */)*(params + 1), (char const   */* __restrict  */)"r");
    }
#line 57
    if ((unsigned long )SVF_FILE != (unsigned long )((void *)0)) {
      {
#line 58
      svf_run(chain, SVF_FILE, stop, print_progress, ref_freq);
#line 59
      result = 1;
#line 61
      fclose(SVF_FILE);
      }
    } else {
      {
#line 63
      tmp___3 = gettext("%s: cannot open file \'%s\' for reading\n");
#line 63
      printf((char const   */* __restrict  */)tmp___3, "svf", *(params + 1));
      }
    }
  }
#line 68
  return (result);
}
}
#line 72 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/svf.c"
static void cmd_svf_help(void) 
{ 
  char *tmp ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
#line 75
  tmp = gettext("Usage: %s FILE [stop] [progress] [ref_freq=<frequency>]\nExecute svf commands from FILE.\nstop     : Command execution stops upon TDO mismatch.\nprogress : Continually displays progress status.\nref_freq : Use <frequency> as the reference for \'RUNTEST xxx SEC\' commands\n\nFILE file containing SVF commands\n");
#line 75
  printf((char const   */* __restrict  */)tmp, "svf");
  }
#line 84
  return;
}
}
#line 86 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/svf.c"
cmd_t cmd_svf  =    {(char *)"svf", (char *)"execute svf commands from file", & cmd_svf_help, & cmd_svf_run};
#line 35 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/signal.c"
static int cmd_signal_run(chain_t *chain , char **params ) 
{ 
  part_t *part ;
  signal_t *s ;
  int i ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  char *tmp___7 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
  {
#line 42
  i = cmd_params(params);
  }
#line 42
  if (i < 2) {
#line 43
    return (-1);
  }
  {
#line 46
  tmp = cmd_test_cable(chain);
  }
#line 46
  if (! tmp) {
#line 47
    return (1);
  }
#line 49
  if (! chain->parts) {
    {
#line 50
    tmp___0 = gettext("Run \"detect\" first.\n");
#line 50
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 51
    return (1);
  }
#line 54
  if (chain->active_part >= (chain->parts)->len) {
    {
#line 55
    tmp___1 = gettext("%s: no active part\n");
#line 55
    printf((char const   */* __restrict  */)tmp___1, "signal");
    }
#line 56
    return (1);
  }
  {
#line 59
  part = *((chain->parts)->parts + chain->active_part);
#line 60
  s = part_find_signal(part, (char const   *)*(params + 1));
  }
#line 60
  if ((unsigned long )s != (unsigned long )((void *)0)) {
#line 61
    if (i == 3) {
      {
#line 62
      printf((char const   */* __restrict  */)"Defining pin for signal %s\n", s->name);
      }
#line 64
      if (s->pin) {
        {
#line 64
        free((void *)s->pin);
        }
      }
      {
#line 67
      tmp___2 = strlen((char const   *)*(params + 2));
#line 67
      tmp___3 = malloc(tmp___2 + 1U);
#line 67
      s->pin = (char *)tmp___3;
#line 68
      strcpy((char */* __restrict  */)s->pin, (char const   */* __restrict  */)*(params + 2));
      }
#line 70
      return (1);
    } else {
      {
#line 73
      tmp___4 = gettext("Signal \'%s\' already defined\n");
#line 73
      printf((char const   */* __restrict  */)tmp___4, *(params + 1));
      }
#line 74
      return (1);
    }
  }
  {
#line 78
  s = signal_alloc((char const   *)*(params + 1));
  }
#line 80
  if (i == 3) {
    {
#line 82
    tmp___5 = strlen((char const   *)*(params + 2));
#line 82
    tmp___6 = malloc(tmp___5 + 1U);
#line 82
    s->pin = (char *)tmp___6;
#line 83
    strcpy((char */* __restrict  */)s->pin, (char const   */* __restrict  */)*(params + 2));
    }
  }
#line 87
  if (! s) {
    {
#line 88
    tmp___7 = gettext("out of memory\n");
#line 88
    printf((char const   */* __restrict  */)tmp___7);
    }
#line 89
    return (1);
  }
#line 92
  s->next = part->signals;
#line 93
  part->signals = s;
#line 95
  return (1);
}
}
#line 98 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/signal.c"
static void cmd_signal_help(void) 
{ 
  char *tmp ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
#line 101
  tmp = gettext("Usage: %s SIGNAL [PIN#]\nDefine new signal with name SIGNAL for a part.\n\nSIGNAL\t\tNew signal name\nPIN#   \tList of pin # for a signal\n");
#line 101
  printf((char const   */* __restrict  */)tmp, "signal");
  }
#line 108
  return;
}
}
#line 110 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/signal.c"
cmd_t cmd_signal  =    {(char *)"signal", (char *)"define new signal for a part", & cmd_signal_help, & cmd_signal_run};
#line 35 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/shift.c"
static int cmd_shift_run(chain_t *chain , char **params ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 38
  tmp = cmd_params(params);
  }
#line 38
  if (tmp != 2) {
#line 39
    return (-1);
  }
  {
#line 41
  tmp___0 = cmd_test_cable(chain);
  }
#line 41
  if (! tmp___0) {
#line 42
    return (1);
  }
  {
#line 44
  tmp___1 = strcasecmp((char const   *)*(params + 1), "ir");
  }
#line 44
  if (tmp___1 == 0) {
    {
#line 45
    chain_shift_instructions(chain);
    }
#line 46
    return (1);
  }
  {
#line 48
  tmp___2 = strcasecmp((char const   *)*(params + 1), "dr");
  }
#line 48
  if (tmp___2 == 0) {
    {
#line 49
    chain_shift_data_registers(chain, 1);
    }
#line 50
    return (1);
  }
#line 53
  return (-1);
}
}
#line 56 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/shift.c"
static void cmd_shift_help(void) 
{ 
  char *tmp ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 59
  tmp = gettext("Usage: %s\nUsage: %s\nShift instruction or data register through JTAG chain.\n");
#line 59
  printf((char const   */* __restrict  */)tmp, "shift ir", "shift dr");
  }
#line 64
  return;
}
}
#line 66 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/shift.c"
cmd_t cmd_shift  =    {(char *)"shift", (char *)"shift data/instruction registers through JTAG chain",
    & cmd_shift_help, & cmd_shift_run};
#line 712 "/usr/include/stdlib.h"
extern int system(char const   *__command ) ;
#line 39 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/shell.c"
static int cmd_shell_run(chain_t *chain , char **params ) 
{ 
  int i ;
  int len ;
  int n ;
  int tmp ;
  char *shell_cmd ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 42
  tmp = cmd_params(params);
#line 42
  n = tmp;
#line 45
  n = cmd_params(params);
  }
#line 45
  if (n == 1) {
#line 46
    return (-1);
  }
#line 57
  i = 1;
#line 57
  len = 0;
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    if (! (i < n)) {
#line 57
      goto while_break;
    }
    {
#line 57
    tmp___0 = strlen((char const   *)*(params + i));
#line 57
    len = (int )((size_t )len + (1U + tmp___0));
#line 57
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 59
  tmp___1 = malloc((size_t )len);
#line 59
  shell_cmd = (char *)tmp___1;
  }
#line 60
  if ((unsigned long )shell_cmd == (unsigned long )((void *)0)) {
    {
#line 62
    tmp___2 = gettext("Out of memory\n");
#line 62
    printf((char const   */* __restrict  */)tmp___2);
    }
#line 63
    return (-1);
  }
  {
#line 66
  strcpy((char */* __restrict  */)shell_cmd, (char const   */* __restrict  */)*(params + 1));
#line 67
  i = 2;
  }
  {
#line 67
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 67
    if (! (i < n)) {
#line 67
      goto while_break___0;
    }
    {
#line 69
    strcat((char */* __restrict  */)shell_cmd, (char const   */* __restrict  */)" ");
#line 70
    strcat((char */* __restrict  */)shell_cmd, (char const   */* __restrict  */)*(params + i));
#line 67
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 72
  printf((char const   */* __restrict  */)"Executing \'%s\'\n", shell_cmd);
#line 74
  system((char const   *)shell_cmd);
#line 75
  free((void *)shell_cmd);
  }
#line 77
  return (1);
}
}
#line 80 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/shell.c"
static void cmd_shell_help(void) 
{ 
  char *tmp ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
#line 83
  tmp = gettext("Usage: %s cmmd\nShell out to os for a command.\n\nCMMD OS Shell Command\n");
#line 83
  printf((char const   */* __restrict  */)tmp, "shell cmmd");
  }
#line 89
  return;
}
}
#line 91 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/shell.c"
cmd_t cmd_shell  =    {(char *)"shell", (char *)"shell cmmd", & cmd_shell_help, & cmd_shell_run};
#line 36 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/set.c"
static int cmd_set_run(chain_t *chain , char **params ) 
{ 
  int dir ;
  unsigned int data ;
  signal_t *s ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
  {
#line 40
  data = 0U;
#line 43
  tmp = cmd_params(params);
  }
#line 43
  if (tmp < 4) {
#line 44
    return (-1);
  } else {
    {
#line 43
    tmp___0 = cmd_params(params);
    }
#line 43
    if (tmp___0 > 5) {
#line 44
      return (-1);
    }
  }
  {
#line 46
  tmp___1 = strcasecmp((char const   *)*(params + 1), "signal");
  }
#line 46
  if (tmp___1 != 0) {
#line 47
    return (-1);
  }
  {
#line 49
  tmp___2 = cmd_test_cable(chain);
  }
#line 49
  if (! tmp___2) {
#line 50
    return (1);
  }
#line 52
  if (! chain->parts) {
    {
#line 53
    tmp___3 = gettext("Run \"detect\" first.\n");
#line 53
    printf((char const   */* __restrict  */)tmp___3);
    }
#line 54
    return (1);
  }
#line 57
  if (chain->active_part >= (chain->parts)->len) {
    {
#line 58
    tmp___4 = gettext("%s: no active part\n");
#line 58
    printf((char const   */* __restrict  */)tmp___4, "set");
    }
#line 59
    return (1);
  }
  {
#line 63
  tmp___5 = strcasecmp((char const   *)*(params + 3), "in");
  }
#line 63
  if (tmp___5 != 0) {
    {
#line 63
    tmp___6 = strcasecmp((char const   *)*(params + 3), "out");
    }
#line 63
    if (tmp___6 != 0) {
#line 64
      return (-1);
    }
  }
  {
#line 66
  tmp___8 = strcasecmp((char const   *)*(params + 3), "in");
  }
#line 66
  if (tmp___8 == 0) {
#line 66
    dir = 0;
  } else {
#line 66
    dir = 1;
  }
#line 68
  if (dir) {
    {
#line 69
    tmp___9 = cmd_get_number(*(params + 4), & data);
    }
#line 69
    if (tmp___9) {
#line 70
      return (-1);
    }
#line 71
    if (data > 1U) {
#line 72
      return (-1);
    }
  }
  {
#line 75
  s = part_find_signal(*((chain->parts)->parts + chain->active_part), (char const   *)*(params + 2));
  }
#line 76
  if (! s) {
    {
#line 77
    tmp___10 = gettext("signal \'%s\' not found\n");
#line 77
    printf((char const   */* __restrict  */)tmp___10, *(params + 2));
    }
#line 78
    return (1);
  }
  {
#line 80
  part_set_signal(*((chain->parts)->parts + chain->active_part), s, dir, (int )data);
  }
#line 82
  return (1);
}
}
#line 85 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/set.c"
static void cmd_set_help(void) 
{ 
  char *tmp ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
#line 88
  tmp = gettext("Usage: %s SIGNAL DIR [DATA]\nSet signal state in input BSR (Boundary Scan Register).\n\nSIGNAL        signal name (from JTAG declaration file)\nDIR           requested signal direction; possible values: \'in\' or \'out\'\nDATA          desired output signal value (\'0\' or \'1\'); used only if DIR\n                is \'out\'\n");
#line 88
  printf((char const   */* __restrict  */)tmp, "set signal");
  }
#line 97
  return;
}
}
#line 99 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/set.c"
cmd_t cmd_set  =    {(char *)"set", (char *)"set external signal value", & cmd_set_help, & cmd_set_run};
#line 35 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/scan.c"
static int cmd_scan_run(chain_t *chain , char **params ) 
{ 
  part_t *part ;
  data_register *bsr ;
  tap_register *obsr ;
  int i ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  instruction *tmp___4 ;
  instruction *tmp___5 ;
  char *tmp___6 ;
  signal_t *s ;
  char const   *tmp___7 ;
  int old ;
  int new ;
  salias_t *a ;
  char *tmp___8 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;

  {
  {
#line 43
  i = cmd_params(params);
  }
#line 43
  if (i < 1) {
#line 44
    return (-1);
  }
  {
#line 46
  tmp = cmd_test_cable(chain);
  }
#line 46
  if (! tmp) {
#line 47
    return (1);
  }
#line 49
  if (! chain->parts) {
    {
#line 50
    tmp___0 = gettext("Run \"detect\" first.\n");
#line 50
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 51
    return (1);
  }
#line 54
  if (chain->active_part >= (chain->parts)->len) {
    {
#line 55
    tmp___1 = gettext("%s: no active part\n");
#line 55
    printf((char const   */* __restrict  */)tmp___1, "scan");
    }
#line 56
    return (1);
  }
  {
#line 59
  part = *((chain->parts)->parts + chain->active_part);
#line 62
  bsr = part_find_data_register(part, "BSR");
  }
#line 63
  if (! bsr) {
    {
#line 64
    tmp___2 = gettext("%s(%s:%d) Boundary Scan Register (BSR) not found\n");
#line 64
    printf((char const   */* __restrict  */)tmp___2, "cmd_scan_run", "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/scan.c",
           64);
    }
#line 65
    return (1);
  }
  {
#line 68
  tmp___5 = part_find_instruction(part, "SAMPLE");
  }
#line 68
  if (tmp___5) {
    {
#line 70
    part_set_instruction(part, "SAMPLE");
    }
  } else {
    {
#line 72
    tmp___4 = part_find_instruction(part, "SAMPLE/PRELOAD");
    }
#line 72
    if (tmp___4) {
      {
#line 74
      part_set_instruction(part, "SAMPLE/PRELOAD");
      }
    } else {
      {
#line 78
      tmp___3 = gettext("%s(%s:%d) Part can\'t SAMPLE\n");
#line 78
      printf((char const   */* __restrict  */)tmp___3, "cmd_scan_run", "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/scan.c",
             78);
      }
#line 79
      return (1);
    }
  }
  {
#line 82
  chain_shift_instructions(chain);
#line 84
  obsr = register_alloc((bsr->out)->len);
  }
#line 86
  if (! obsr) {
    {
#line 88
    tmp___6 = gettext("Out of memory\n");
#line 88
    printf((char const   */* __restrict  */)tmp___6);
    }
#line 89
    return (1);
  }
  {
#line 95
  tmp___7 = register_get_string((tap_register const   *)bsr->out);
#line 95
  register_init(obsr, tmp___7);
#line 97
  chain_shift_data_registers(chain, 1);
#line 99
  s = part->signals;
  }
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! s) {
#line 99
      goto while_break;
    }
#line 101
    if ((unsigned long )s->input != (unsigned long )((void *)0)) {
#line 103
      old = (int )*(obsr->data + (s->input)->bit);
#line 104
      new = (int )*((bsr->out)->data + (s->input)->bit);
#line 105
      if (old != new) {
        {
#line 108
        printf((char const   */* __restrict  */)"%s", s->name);
#line 109
        a = part->saliases;
        }
        {
#line 109
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 109
          if (! a) {
#line 109
            goto while_break___0;
          }
#line 111
          if ((unsigned long )a->signal == (unsigned long )s) {
            {
#line 111
            printf((char const   */* __restrict  */)",%s", a->name);
            }
          }
#line 109
          a = a->next;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 113
        tmp___8 = gettext(": %d > %d\n");
#line 113
        printf((char const   */* __restrict  */)tmp___8, old, new);
        }
      }
    }
#line 99
    s = s->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 119
  register_free(obsr);
  }
#line 121
  return (1);
}
}
#line 124 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/scan.c"
static void cmd_scan_help(void) 
{ 
  char *tmp ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
#line 127
  tmp = gettext("Usage: %s [SIGNAL]* \nRead BSR and show changes since last scan.\n");
#line 127
  printf((char const   */* __restrict  */)tmp, "scan");
  }
#line 131
  return;
}
}
#line 133 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/scan.c"
cmd_t cmd_scan  =    {(char *)"scan", (char *)"read BSR and show changes since last scan", & cmd_scan_help,
    & cmd_scan_run};
#line 35 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/salias.c"
static int cmd_salias_run(chain_t *chain , char **params ) 
{ 
  part_t *part ;
  signal_t *s ;
  salias_t *sa ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  signal_t *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 42
  tmp = cmd_params(params);
  }
#line 42
  if (tmp != 3) {
#line 43
    return (-1);
  }
  {
#line 45
  tmp___0 = cmd_test_cable(chain);
  }
#line 45
  if (! tmp___0) {
#line 46
    return (1);
  }
#line 48
  if (! chain->parts) {
    {
#line 49
    tmp___1 = gettext("Run \"detect\" first.\n");
#line 49
    printf((char const   */* __restrict  */)tmp___1);
    }
#line 50
    return (1);
  }
#line 53
  if (chain->active_part >= (chain->parts)->len) {
    {
#line 54
    tmp___2 = gettext("%s: no active part\n");
#line 54
    printf((char const   */* __restrict  */)tmp___2, "signal");
    }
#line 55
    return (1);
  }
  {
#line 58
  part = *((chain->parts)->parts + chain->active_part);
#line 59
  tmp___4 = part_find_signal(part, (char const   *)*(params + 1));
  }
#line 59
  if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
    {
#line 60
    tmp___3 = gettext("Signal \'%s\' already defined\n");
#line 60
    printf((char const   */* __restrict  */)tmp___3, *(params + 1));
    }
#line 61
    return (1);
  }
  {
#line 64
  s = part_find_signal(part, (char const   *)*(params + 2));
  }
#line 65
  if ((unsigned long )s == (unsigned long )((void *)0)) {
    {
#line 66
    tmp___5 = gettext("Signal \'%s\' not found\n");
#line 66
    printf((char const   */* __restrict  */)tmp___5, *(params + 2));
    }
#line 67
    return (1);
  }
  {
#line 70
  sa = salias_alloc((char const   *)*(params + 1), (signal_t const   *)s);
  }
#line 71
  if (! sa) {
    {
#line 72
    tmp___6 = gettext("out of memory\n");
#line 72
    printf((char const   */* __restrict  */)tmp___6);
    }
#line 73
    return (1);
  }
#line 76
  sa->next = part->saliases;
#line 77
  part->saliases = sa;
#line 79
  return (1);
}
}
#line 82 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/salias.c"
static void cmd_salias_help(void) 
{ 
  char *tmp ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
#line 85
  tmp = gettext("Usage: %s ALIAS SIGNAL\nDefine new signal ALIAS as alias for existing SIGNAL.\n\nALIAS         New signal alias name\nSIGNAL        Existing signal name\n");
#line 85
  printf((char const   */* __restrict  */)tmp, "signal");
  }
#line 92
  return;
}
}
#line 94 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/salias.c"
struct __anonstruct_cmd_t_26  const  cmd_salias  =    {(char *)"salias", (char *)"define an alias for a signal", & cmd_salias_help, & cmd_salias_run};
#line 35 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/reset.c"
static int cmd_reset_run(chain_t *chain , char **params ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 38
  tmp = cmd_params(params);
  }
#line 38
  if (tmp > 1) {
#line 39
    return (-1);
  }
  {
#line 41
  tmp___0 = cmd_test_cable(chain);
  }
#line 41
  if (! tmp___0) {
#line 42
    return (1);
  }
  {
#line 44
  tap_reset_bypass(chain);
  }
#line 46
  return (1);
}
}
#line 49 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/reset.c"
static void cmd_reset_help(void) 
{ 
  char *tmp ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
#line 52
  tmp = gettext("Usage: %s\nReset current JTAG chain.\n");
#line 52
  printf((char const   */* __restrict  */)tmp, "reset");
  }
#line 56
  return;
}
}
#line 58 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/reset.c"
cmd_t cmd_reset  =    {(char *)"reset", (char *)"reset JTAG chain", & cmd_reset_help, & cmd_reset_run};
#line 35 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/register.c"
static int cmd_register_run(chain_t *chain , char **params ) 
{ 
  part_t *part ;
  unsigned int len ;
  data_register *dr ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  data_register *tmp___5 ;
  char *tmp___6 ;
  int i ;
  void *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char const   *tmp___10 ;
  int tmp___11 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
  {
#line 42
  tmp = cmd_params(params);
  }
#line 42
  if (tmp != 3) {
#line 43
    return (-1);
  }
  {
#line 46
  tmp___0 = cmd_test_cable(chain);
  }
#line 46
  if (! tmp___0) {
#line 47
    return (1);
  }
#line 49
  if (! chain->parts) {
    {
#line 50
    tmp___1 = gettext("Run \"detect\" first.\n");
#line 50
    printf((char const   */* __restrict  */)tmp___1);
    }
#line 51
    return (1);
  }
#line 54
  if (chain->active_part >= (chain->parts)->len) {
    {
#line 55
    tmp___2 = gettext("%s: no active part\n");
#line 55
    printf((char const   */* __restrict  */)tmp___2, "register");
    }
#line 56
    return (1);
  }
  {
#line 59
  tmp___3 = cmd_get_number(*(params + 2), & len);
  }
#line 59
  if (tmp___3) {
#line 60
    return (-1);
  }
  {
#line 62
  part = *((chain->parts)->parts + chain->active_part);
#line 64
  tmp___5 = part_find_data_register(part, (char const   *)*(params + 1));
  }
#line 64
  if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
    {
#line 65
    tmp___4 = gettext("Data register \'%s\' already defined\n");
#line 65
    printf((char const   */* __restrict  */)tmp___4, *(params + 1));
    }
#line 66
    return (1);
  }
  {
#line 69
  dr = data_register_alloc((char const   *)*(params + 1), (int )len);
  }
#line 70
  if (! dr) {
    {
#line 71
    tmp___6 = gettext("out of memory\n");
#line 71
    printf((char const   */* __restrict  */)tmp___6);
    }
#line 72
    return (1);
  }
  {
#line 75
  dr->next = part->data_registers;
#line 76
  part->data_registers = dr;
#line 79
  tmp___9 = strcasecmp((char const   *)(dr->name), "BSR");
  }
#line 79
  if (tmp___9 == 0) {
    {
#line 82
    part->boundary_length = (int )len;
#line 83
    tmp___7 = malloc((size_t )((unsigned long )part->boundary_length * sizeof(*(part->bsbits))));
#line 83
    part->bsbits = (bsbit_t **)tmp___7;
    }
#line 84
    if (! part->bsbits) {
      {
#line 85
      tmp___8 = gettext("out of memory\n");
#line 85
      printf((char const   */* __restrict  */)tmp___8);
      }
#line 86
      return (1);
    }
#line 88
    i = 0;
    {
#line 88
    while (1) {
      while_continue: /* CIL Label */ ;
#line 88
      if (! (i < part->boundary_length)) {
#line 88
        goto while_break;
      }
#line 89
      *(part->bsbits + i) = (bsbit_t *)((void *)0);
#line 88
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 93
  tmp___11 = strcasecmp((char const   *)(dr->name), "DIR");
  }
#line 93
  if (tmp___11 == 0) {
    {
#line 94
    tmp___10 = register_get_string((tap_register const   *)part->id);
#line 94
    register_init(dr->out, tmp___10);
    }
  }
#line 96
  return (1);
}
}
#line 99 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/register.c"
static void cmd_register_help(void) 
{ 
  char *tmp ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
#line 102
  tmp = gettext("Usage: %s NAME LENGTH\nDefine new data register with specified NAME and LENGTH.\n\nNAME          Data register name\nLENGTH        Data register length\n");
#line 102
  printf((char const   */* __restrict  */)tmp, "register");
  }
#line 109
  return;
}
}
#line 111 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/register.c"
cmd_t cmd_register  =    {(char *)"register", (char *)"define new data register for a part", & cmd_register_help,
    & cmd_register_run};
#line 34 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/readmem.c"
static int cmd_readmem_run(chain_t *chain , char **params ) 
{ 
  uint32_t adr ;
  uint32_t len ;
  FILE *f ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 41
  tmp = cmd_params(params);
  }
#line 41
  if (tmp != 4) {
#line 42
    return (-1);
  }
#line 44
  if (! bus) {
    {
#line 45
    tmp___0 = gettext("Error: Bus driver missing.\n");
#line 45
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 46
    return (1);
  }
  {
#line 49
  tmp___1 = cmd_get_number(*(params + 1), & adr);
  }
#line 49
  if (tmp___1) {
#line 50
    return (-1);
  } else {
    {
#line 49
    tmp___2 = cmd_get_number(*(params + 2), & len);
    }
#line 49
    if (tmp___2) {
#line 50
      return (-1);
    }
  }
  {
#line 52
  f = fopen((char const   */* __restrict  */)*(params + 3), (char const   */* __restrict  */)"w");
  }
#line 53
  if (! f) {
    {
#line 54
    tmp___3 = gettext("Unable to create file `%s\'!\n");
#line 54
    printf((char const   */* __restrict  */)tmp___3, *(params + 3));
    }
#line 55
    return (1);
  }
  {
#line 57
  readmem(bus, f, adr, len);
#line 58
  fclose(f);
  }
#line 60
  return (1);
}
}
#line 63 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/readmem.c"
static void cmd_readmem_help(void) 
{ 
  char *tmp ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
#line 66
  tmp = gettext("Usage: %s ADDR LEN FILENAME\nCopy device memory content starting with ADDR to FILENAME file.\n\nADDR       start address of the copied memory area\nLEN        copied memory length\nFILENAME   name of the output file\n\nADDR and LEN could be in decimal or hexadecimal (prefixed with 0x) form.\n");
#line 66
  printf((char const   */* __restrict  */)tmp, "readmem");
  }
#line 76
  return;
}
}
#line 78 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/readmem.c"
cmd_t cmd_readmem  =    {(char *)"readmem", (char *)"read content of the memory and write it to file",
    & cmd_readmem_help, & cmd_readmem_run};
#line 31 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/quit.c"
static int cmd_quit_run(chain_t *chain , char **params ) 
{ 


  {
#line 34
  if (*(params + 1)) {
#line 35
    return (-1);
  }
#line 37
  return (0);
}
}
#line 40 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/quit.c"
static void cmd_quit_help(void) 
{ 
  char *tmp ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 43
  tmp = gettext("Usage: %s\nExit from %s.\n");
#line 43
  printf((char const   */* __restrict  */)tmp, "quit", "urjtag");
  }
#line 47
  return;
}
}
#line 49 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/quit.c"
cmd_t cmd_quit  =    {(char *)"quit", (char *)"exit and terminate this session", & cmd_quit_help, & cmd_quit_run};
#line 865 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) size_t mbstowcs(wchar_t * __restrict  __pwcs ,
                                                     char const   * __restrict  __s ,
                                                     size_t __n ) ;
#line 868
extern  __attribute__((__nothrow__)) size_t wcstombs(char * __restrict  __s , wchar_t const   * __restrict  __pwcs ,
                                                     size_t __n ) ;
#line 562 "/usr/include/stdio.h"
extern int putchar(int __c ) ;
#line 668
extern int puts(char const   *__s ) ;
#line 284 "/usr/include/wchar.h"
extern  __attribute__((__nothrow__)) size_t wcslen(wchar_t const   *__s )  __attribute__((__pure__)) ;
#line 602
extern  __attribute__((__nothrow__)) int swprintf(wchar_t * __restrict  __s , size_t __n ,
                                                  wchar_t const   * __restrict  __format 
                                                  , ...) ;
#line 46 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/print.c"
static int cmd_print_run(chain_t *chain , char **params ) 
{ 
  char format[128] ;
  wchar_t wformat[128] ;
  wchar_t wheader[128] ;
  char header[128] ;
  int i ;
  int noheader ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  part_t *part ;
  signal_t *s ;
  salias_t *sa ;
  int tmp___3 ;
  part_t *part___0 ;
  instruction *inst ;
  char *tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  size_t tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  size_t tmp___25 ;
  size_t tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  int i___0 ;
  uint64_t a ;
  bus_area_t area___0 ;
  char *tmp___29 ;
  char *tmp___30 ;
  int tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  char *tmp___37 ;
  char *tmp___38 ;
  void *__cil_tmp57 ;
  void *__cil_tmp58 ;
  void *__cil_tmp59 ;
  void *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;

  {
  {
#line 56
  noheader = 0;
#line 58
  tmp = cmd_params(params);
  }
#line 58
  if (tmp > 2) {
#line 59
    return (-1);
  }
  {
#line 61
  tmp___0 = cmd_test_cable(chain);
  }
#line 61
  if (! tmp___0) {
#line 62
    return (1);
  }
#line 64
  if (! chain->parts) {
    {
#line 65
    tmp___1 = gettext("Run \"detect\" first.\n");
#line 65
    printf((char const   */* __restrict  */)tmp___1);
    }
#line 66
    return (1);
  }
  {
#line 69
  tmp___15 = cmd_params(params);
  }
#line 69
  if (tmp___15 == 2) {
    {
#line 70
    tmp___2 = strcasecmp((char const   *)*(params + 1), "bus");
    }
#line 70
    if (tmp___2 == 0) {
#line 71
      noheader = 1;
    }
    {
#line 73
    tmp___3 = strcasecmp((char const   *)*(params + 1), "signals");
    }
#line 73
    if (tmp___3 == 0) {
      {
#line 75
      printf((char const   */* __restrict  */)"Signals:\n");
#line 78
      part = *((chain->parts)->parts + chain->active_part);
#line 79
      s = part->signals;
      }
      {
#line 79
      while (1) {
        while_continue: /* CIL Label */ ;
#line 79
        if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 79
          goto while_break;
        }
#line 81
        if (s->pin) {
          {
#line 81
          printf((char const   */* __restrict  */)"%s %s", s->name, s->pin);
          }
        } else {
          {
#line 82
          printf((char const   */* __restrict  */)"%s", s->name);
          }
        }
#line 83
        if (s->input) {
          {
#line 83
          printf((char const   */* __restrict  */)"\tinput=%s", (s->input)->name);
          }
        }
#line 84
        if (s->output) {
          {
#line 84
          printf((char const   */* __restrict  */)"\toutput=%s", (s->output)->name);
          }
        }
#line 86
        sa = part->saliases;
        {
#line 86
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 86
          if (! ((unsigned long )sa != (unsigned long )((void *)0))) {
#line 86
            goto while_break___0;
          }
#line 87
          if ((unsigned long )s == (unsigned long )sa->signal) {
            {
#line 87
            printf((char const   */* __restrict  */)"\tsalias=%s", sa->name);
            }
          }
#line 86
          sa = sa->next;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 89
        printf((char const   */* __restrict  */)"\n");
#line 79
        s = s->next;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 91
      return (1);
    }
    {
#line 94
    tmp___14 = strcasecmp((char const   *)*(params + 1), "instructions");
    }
#line 94
    if (tmp___14 == 0) {
      {
#line 98
      tmp___4 = gettext(" Active %%-%ds %%-%ds");
#line 98
      snprintf((char */* __restrict  */)(format), (size_t )128, (char const   */* __restrict  */)tmp___4,
               20, 32);
#line 101
      tmp___6 = mbstowcs((wchar_t */* __restrict  */)(wformat), (char const   */* __restrict  */)(format),
                         (size_t )128);
      }
#line 101
      if (tmp___6 == 4294967295U) {
        {
#line 102
        tmp___5 = gettext("(%d) String conversion failed!\n");
#line 102
        printf((char const   */* __restrict  */)tmp___5, 102);
        }
      }
      {
#line 103
      tmp___7 = gettext("Register");
#line 103
      tmp___8 = gettext("Instruction");
#line 103
      swprintf((wchar_t */* __restrict  */)(wheader), (size_t )128, (wchar_t const   */* __restrict  */)(wformat),
               tmp___8, tmp___7);
#line 104
      tmp___10 = wcstombs((char */* __restrict  */)(header), (wchar_t const   */* __restrict  */)(wheader),
                          (size_t )128);
      }
#line 104
      if (tmp___10 == 4294967295U) {
        {
#line 105
        tmp___9 = gettext("(%d) String conversion failed!\n");
#line 105
        printf((char const   */* __restrict  */)tmp___9, 105);
        }
      }
      {
#line 111
      puts((char const   *)(header));
#line 113
      i = 0;
      }
      {
#line 113
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 113
        tmp___11 = wcslen((wchar_t const   *)(wheader));
        }
#line 113
        if (! ((size_t )i < tmp___11)) {
#line 113
          goto while_break___1;
        }
        {
#line 114
        putchar('-');
#line 113
        i ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 115
      putchar('\n');
#line 117
      tmp___12 = gettext("   %%c    %%-%ds %%-%ds\n");
#line 117
      snprintf((char */* __restrict  */)(format), (size_t )128, (char const   */* __restrict  */)tmp___12,
               20, 32);
#line 120
      part___0 = *((chain->parts)->parts + chain->active_part);
#line 121
      inst = part___0->instructions;
      }
      {
#line 121
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 121
        if (! ((unsigned long )inst != (unsigned long )((void *)0))) {
#line 121
          goto while_break___2;
        }
#line 122
        if ((unsigned long )inst == (unsigned long )part___0->active_instruction) {
#line 122
          tmp___13 = 'X';
        } else {
#line 122
          tmp___13 = ' ';
        }
        {
#line 122
        printf((char const   */* __restrict  */)(format), tmp___13, inst->name, (inst->data_register)->name);
#line 121
        inst = inst->next;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 128
      return (1);
    }
  }
#line 132
  if (noheader == 0) {
    {
#line 133
    tmp___16 = gettext(" No. %%-%ds %%-%ds %%-%ds %%-%ds %%-%ds");
#line 133
    snprintf((char */* __restrict  */)(format), (size_t )128, (char const   */* __restrict  */)tmp___16,
             25, 20, 8, 20, 32);
#line 136
    tmp___18 = mbstowcs((wchar_t */* __restrict  */)(wformat), (char const   */* __restrict  */)(format),
                        (size_t )128);
    }
#line 136
    if (tmp___18 == 4294967295U) {
      {
#line 137
      tmp___17 = gettext("(%d) String conversion failed!\n");
#line 137
      printf((char const   */* __restrict  */)tmp___17, 137);
      }
    }
    {
#line 138
    tmp___19 = gettext("Register");
#line 138
    tmp___20 = gettext("Instruction");
#line 138
    tmp___21 = gettext("Stepping");
#line 138
    tmp___22 = gettext("Part");
#line 138
    tmp___23 = gettext("Manufacturer");
#line 138
    swprintf((wchar_t */* __restrict  */)(wheader), (size_t )128, (wchar_t const   */* __restrict  */)(wformat),
             tmp___23, tmp___22, tmp___21, tmp___20, tmp___19);
#line 139
    tmp___25 = wcstombs((char */* __restrict  */)(header), (wchar_t const   */* __restrict  */)(wheader),
                        (size_t )128);
    }
#line 139
    if (tmp___25 == 4294967295U) {
      {
#line 140
      tmp___24 = gettext("(%d) String conversion failed!\n");
#line 140
      printf((char const   */* __restrict  */)tmp___24, 140);
      }
    }
    {
#line 146
    puts((char const   *)(header));
#line 148
    i = 0;
    }
    {
#line 148
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 148
      tmp___26 = wcslen((wchar_t const   *)(wheader));
      }
#line 148
      if (! ((size_t )i < tmp___26)) {
#line 148
        goto while_break___3;
      }
      {
#line 149
      putchar('-');
#line 148
      i ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 150
    putchar('\n');
    }
  }
  {
#line 153
  tmp___35 = cmd_params(params);
  }
#line 153
  if (tmp___35 == 1) {
#line 154
    if ((chain->parts)->len > chain->active_part) {
#line 155
      if ((*((chain->parts)->parts + chain->active_part))->alias) {
        {
#line 156
        tmp___27 = gettext(" %3d %s ");
#line 156
        printf((char const   */* __restrict  */)tmp___27, chain->active_part, (*((chain->parts)->parts + chain->active_part))->alias);
        }
      } else {
        {
#line 158
        tmp___28 = gettext(" %3d ");
#line 158
        printf((char const   */* __restrict  */)tmp___28, chain->active_part);
        }
      }
      {
#line 160
      part_print(*((chain->parts)->parts + chain->active_part));
      }
    }
#line 162
    if ((unsigned long )bus != (unsigned long )((void *)0)) {
#line 167
      i___0 = 0;
      {
#line 167
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 167
        if (! (i___0 < buses.len)) {
#line 167
          goto while_break___4;
        }
#line 168
        if ((unsigned long )*(buses.buses + i___0) == (unsigned long )bus) {
#line 169
          goto while_break___4;
        }
#line 167
        i___0 ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 170
      tmp___29 = gettext("\nActive bus:\n*%d: ");
#line 170
      printf((char const   */* __restrict  */)tmp___29, i___0);
#line 171
      (*((bus->driver)->printinfo))(bus);
#line 173
      a = (uint64_t )0;
      }
      {
#line 173
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 173
        if (! (a < 4294967296ULL)) {
#line 173
          goto while_break___5;
        }
        {
#line 174
        tmp___31 = (*((bus->driver)->area))(bus, (uint32_t )a, & area___0);
        }
#line 174
        if (tmp___31 != 0) {
          {
#line 175
          tmp___30 = gettext("Error in bus area discovery at 0x%08llX\n");
#line 175
          printf((char const   */* __restrict  */)tmp___30, a);
          }
#line 176
          goto while_break___5;
        }
#line 178
        if (area___0.width != 0U) {
#line 179
          if ((unsigned long )area___0.description != (unsigned long )((void *)0)) {
            {
#line 180
            tmp___32 = gettext(area___0.description);
#line 180
            tmp___33 = gettext("\tstart: 0x%08X, length: 0x%08llX, data width: %d bit, (%s)\n");
#line 180
            printf((char const   */* __restrict  */)tmp___33, area___0.start, area___0.length,
                   area___0.width, tmp___32);
            }
          } else {
            {
#line 182
            tmp___34 = gettext("\tstart: 0x%08X, length: 0x%08llX, data width: %d bit\n");
#line 182
            printf((char const   */* __restrict  */)tmp___34, area___0.start, area___0.length,
                   area___0.width);
            }
          }
        }
#line 173
        a = (uint64_t )area___0.start + area___0.length;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
#line 187
    return (1);
  }
  {
#line 190
  tmp___36 = strcasecmp((char const   *)*(params + 1), "chain");
  }
#line 190
  if (tmp___36 == 0) {
    {
#line 191
    parts_print(chain->parts);
    }
#line 192
    return (1);
  }
#line 195
  i = 0;
  {
#line 195
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 195
    if (! (i < buses.len)) {
#line 195
      goto while_break___6;
    }
#line 196
    if ((unsigned long )*(buses.buses + i) == (unsigned long )bus) {
      {
#line 197
      tmp___37 = gettext("*%d: ");
#line 197
      printf((char const   */* __restrict  */)tmp___37, i);
      }
    } else {
      {
#line 199
      tmp___38 = gettext("%d: ");
#line 199
      printf((char const   */* __restrict  */)tmp___38, i);
      }
    }
    {
#line 200
    (*(((*(buses.buses + i))->driver)->printinfo))(*(buses.buses + i));
#line 195
    i ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
#line 203
  return (1);
}
}
#line 206 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/print.c"
static void cmd_print_help(void) 
{ 
  char *tmp ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
#line 209
  tmp = gettext("Usage: %s [chain|bus|signals|instructions]\nDisplay JTAG chain status.\n\nDisplay list of the parts connected to the JTAG chain including\npart number and current (active) instruction and data register.\n");
#line 209
  printf((char const   */* __restrict  */)tmp, "print");
  }
#line 216
  return;
}
}
#line 218 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/print.c"
cmd_t cmd_print  =    {(char *)"print", (char *)"display JTAG chain list/status", & cmd_print_help, & cmd_print_run};
#line 38 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/pod.c"
static int cmd_pod_run(chain_t *chain , char **params ) 
{ 
  int i ;
  int j ;
  int mask ;
  int val ;
  int tmp ;
  char *eq ;
  char *tmp___0 ;
  pod_sigsel_t it ;
  int n ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
  {
#line 42
  mask = 0;
#line 43
  val = 0;
#line 45
  i = cmd_params(params);
  }
#line 45
  if (i < 2) {
#line 46
    return (-1);
  }
  {
#line 48
  tmp = cmd_test_cable(chain);
  }
#line 48
  if (! tmp) {
#line 49
    return (-1);
  }
#line 51
  j = 1;
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
#line 51
    if (! (j < i)) {
#line 51
      goto while_break;
    }
    {
#line 53
    tmp___0 = strrchr((char const   *)*(params + j), '=');
#line 53
    eq = tmp___0;
    }
#line 54
    if (! eq) {
#line 55
      return (-1);
    }
    {
#line 56
    it = (pod_sigsel_t )0;
#line 57
    tmp___1 = strlen((char const   *)*(params + j));
#line 57
    n = (int )tmp___1;
    }
#line 58
    if (n > 4) {
      {
#line 58
      tmp___6 = strncasecmp((char const   *)*(params + j), "tck", (size_t )3);
      }
#line 58
      if (tmp___6 == 0) {
#line 58
        it = (pod_sigsel_t )2;
      } else {
#line 58
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 59
    if (n > 4) {
      {
#line 59
      tmp___5 = strncasecmp((char const   *)*(params + j), "tms", (size_t )3);
      }
#line 59
      if (tmp___5 == 0) {
#line 59
        it = (pod_sigsel_t )4;
      } else {
#line 59
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 60
    if (n > 4) {
      {
#line 60
      tmp___4 = strncasecmp((char const   *)*(params + j), "tdi", (size_t )3);
      }
#line 60
      if (tmp___4 == 0) {
#line 60
        it = (pod_sigsel_t )1;
      } else {
#line 60
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 61
    if (n > 5) {
      {
#line 61
      tmp___3 = strncasecmp((char const   *)*(params + j), "trst", (size_t )3);
      }
#line 61
      if (tmp___3 == 0) {
#line 61
        it = (pod_sigsel_t )8;
      } else {
#line 61
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 62
    if (n > 6) {
      {
#line 62
      tmp___2 = strncasecmp((char const   *)*(params + j), "reset", (size_t )3);
      }
#line 62
      if (tmp___2 == 0) {
#line 62
        it = (pod_sigsel_t )16;
      }
    }
#line 63
    if ((unsigned int )it == 0U) {
#line 64
      return (-1);
    }
    {
#line 65
    mask = (int )((unsigned int )mask | (unsigned int )it);
#line 66
    tmp___7 = atoi((char const   *)(eq + 1));
    }
#line 66
    if (tmp___7 != 0) {
#line 66
      val = (int )((unsigned int )val | (unsigned int )it);
    }
#line 51
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 69
  chain_set_pod_signal(chain, mask, val);
  }
#line 71
  return (1);
}
}
#line 74 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/pod.c"
static void cmd_pod_help(void) 
{ 
  char *tmp ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
#line 77
  tmp = gettext("Usage: %s SIGNAL=# [SIGNAL=# ...]\nSet state of POD signal(s) to 0 or 1.\n\nSIGNAL\t    TCK,TMS, TDI, TRST, or RESET\n#          0 or 1\n");
#line 77
  printf((char const   */* __restrict  */)tmp, "pod");
  }
#line 84
  return;
}
}
#line 86 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/pod.c"
cmd_t cmd_pod  =    {(char *)"pod", (char *)"Set state of POD signal(s)", & cmd_pod_help, & cmd_pod_run};
#line 34 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/peekpoke.c"
static int cmd_peek_run(chain_t *chain , char **params ) 
{ 
  uint32_t adr ;
  uint32_t val ;
  int pars ;
  int j ;
  bus_area_t area___0 ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 38
  j = 1;
#line 43
  pars = cmd_params(params);
  }
#line 43
  if (pars < 2) {
#line 44
    return (-1);
  }
#line 46
  if (! bus) {
    {
#line 47
    tmp = gettext("Error: Bus driver missing.\n");
#line 47
    printf((char const   */* __restrict  */)tmp);
    }
#line 48
    return (1);
  }
  {
#line 50
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 51
    tmp___0 = cmd_get_number(*(params + j), & adr);
    }
#line 51
    if (tmp___0) {
#line 52
      return (-1);
    }
    {
#line 54
    (*((bus->driver)->prepare))(bus);
#line 55
    (*((bus->driver)->area))(bus, adr, & area___0);
#line 56
    val = (*((bus->driver)->read))(bus, adr);
    }
    {
#line 60
    if (area___0.width == 8U) {
#line 60
      goto case_8;
    }
#line 64
    if (area___0.width == 16U) {
#line 64
      goto case_16;
    }
#line 68
    goto switch_default;
    case_8: /* CIL Label */ 
    {
#line 61
    val &= 255U;
#line 62
    tmp___1 = gettext("bus_read(0x%08x) = 0x%02X (%i)\n");
#line 62
    printf((char const   */* __restrict  */)tmp___1, adr, val, val);
    }
#line 63
    goto switch_break;
    case_16: /* CIL Label */ 
    {
#line 65
    val &= 65535U;
#line 66
    tmp___2 = gettext("bus_read(0x%08x) = 0x%04X (%i)\n");
#line 66
    printf((char const   */* __restrict  */)tmp___2, adr, val, val);
    }
#line 67
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 69
    tmp___3 = gettext("bus_read(0x%08x) = 0x%08X (%i)\n");
#line 69
    printf((char const   */* __restrict  */)tmp___3, adr, val, val);
    }
    switch_break: /* CIL Label */ ;
    }
#line 50
    j ++;
#line 50
    if (! (j != pars)) {
#line 50
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 73
  return (1);
}
}
#line 76 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/peekpoke.c"
static void cmd_peek_help(void) 
{ 
  char *tmp ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
#line 79
  tmp = gettext("Usage: %s ADDR\nRead a single word (bus width size).\n\nADDR       address to read from\n\nADDR could be in decimal or hexadecimal (prefixed with 0x) form.\n\n");
#line 79
  printf((char const   */* __restrict  */)tmp, "peek");
  }
#line 88
  return;
}
}
#line 90 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/peekpoke.c"
cmd_t cmd_peek  =    {(char *)"peek", (char *)"read a single word", & cmd_peek_help, & cmd_peek_run};
#line 97 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/peekpoke.c"
static int cmd_poke_run(chain_t *chain , char **params ) 
{ 
  uint32_t adr ;
  uint32_t val ;
  bus_area_t area___0 ;
  int k ;
  int pars ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp12 ;

  {
  {
#line 103
  k = 1;
#line 103
  tmp = cmd_params(params);
#line 103
  pars = tmp;
  }
#line 105
  if (pars < 3) {
#line 106
    return (-1);
  } else
#line 105
  if (! (pars & 1)) {
#line 106
    return (-1);
  }
#line 108
  if (! bus) {
    {
#line 109
    tmp___0 = gettext("Error: Bus driver missing.\n");
#line 109
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 110
    return (1);
  }
  {
#line 114
  (*((bus->driver)->prepare))(bus);
  }
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    if (! (k < pars)) {
#line 116
      goto while_break;
    }
    {
#line 117
    tmp___1 = cmd_get_number(*(params + k), & adr);
    }
#line 117
    if (tmp___1) {
#line 118
      return (-1);
    } else {
      {
#line 117
      tmp___2 = cmd_get_number(*(params + (k + 1)), & val);
      }
#line 117
      if (tmp___2) {
#line 118
        return (-1);
      }
    }
    {
#line 119
    (*((bus->driver)->area))(bus, adr, & area___0);
#line 120
    (*((bus->driver)->write))(bus, adr, val);
#line 121
    k += 2;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 124
  return (1);
}
}
#line 127 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/peekpoke.c"
static void cmd_poke_help(void) 
{ 
  char *tmp ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
#line 130
  tmp = gettext("Usage: %s ADDR VAL [ADDR VAL] ... \nWrite a single word (bus width size).\n\nADDR       address to write\nVAL        value to write\n\nADDR and VAL could be in decimal or hexadecimal (prefixed with 0x) form.\n\n");
#line 130
  printf((char const   */* __restrict  */)tmp, "poke");
  }
#line 140
  return;
}
}
#line 142 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/peekpoke.c"
cmd_t cmd_poke  =    {(char *)"poke", (char *)"write a single word", & cmd_poke_help, & cmd_poke_run};
#line 35 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/part.c"
static int cmd_part_run(chain_t *chain , char **params ) 
{ 
  unsigned int n ;
  part_t *part ;
  size_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int i ;
  char *a ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
  {
#line 41
  tmp___2 = cmd_params(params);
  }
#line 41
  if (tmp___2 == 3) {
    {
#line 42
    tmp___1 = strcasecmp((char const   *)*(params + 1), "alias");
    }
#line 42
    if (tmp___1 == 0) {
      {
#line 44
      part = *((chain->parts)->parts + chain->active_part);
#line 45
      tmp = strlen((char const   *)*(params + 2));
#line 45
      tmp___0 = malloc(tmp + 1U);
#line 45
      part->alias = (char *)tmp___0;
#line 46
      strcpy((char */* __restrict  */)part->alias, (char const   */* __restrict  */)*(params + 2));
      }
#line 47
      return (1);
    }
  }
  {
#line 52
  tmp___3 = cmd_params(params);
  }
#line 52
  if (tmp___3 != 2) {
#line 53
    return (-1);
  }
  {
#line 55
  tmp___4 = cmd_test_cable(chain);
  }
#line 55
  if (! tmp___4) {
#line 56
    return (1);
  }
#line 58
  if (! chain->parts) {
    {
#line 59
    tmp___5 = gettext("Run \"detect\" first.\n");
#line 59
    printf((char const   */* __restrict  */)tmp___5);
    }
#line 60
    return (1);
  }
  {
#line 64
  tmp___7 = cmd_get_number(*(params + 1), & n);
  }
#line 64
  if (tmp___7) {
#line 70
    i = 0;
    {
#line 70
    while (1) {
      while_continue: /* CIL Label */ ;
#line 70
      if (! (i < (chain->parts)->len)) {
#line 70
        goto while_break;
      }
#line 71
      a = (*((chain->parts)->parts + i))->alias;
#line 72
      if (a) {
        {
#line 72
        tmp___6 = strcasecmp((char const   *)a, (char const   *)*(params + 1));
        }
#line 72
        if (tmp___6 == 0) {
#line 72
          goto while_break;
        }
      }
#line 70
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 74
    if (i < (chain->parts)->len) {
#line 74
      n = (unsigned int )i;
    } else {
#line 77
      return (-1);
    }
  }
#line 80
  if (n >= (unsigned int )(chain->parts)->len) {
    {
#line 81
    tmp___8 = gettext("%s: invalid part number\n");
#line 81
    printf((char const   */* __restrict  */)tmp___8, "part");
    }
#line 82
    return (1);
  }
#line 85
  chain->active_part = (int )n;
#line 87
  return (1);
}
}
#line 90 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/part.c"
static void cmd_part_help(void) 
{ 
  char *tmp ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
#line 93
  tmp = gettext("Usage: %s PART\nChange active part for current JTAG chain.\n\nPART          part number | alias\n");
#line 93
  printf((char const   */* __restrict  */)tmp, "part");
  }
#line 99
  return;
}
}
#line 101 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/part.c"
cmd_t cmd_part  =    {(char *)"part", (char *)"change active part for current JTAG chain", & cmd_part_help,
    & cmd_part_run};
#line 44 "../../include/jtag.h"
int debug_mode ;
#line 48
int jtag_parse_file(chain_t *chain , char const   *filename ) ;
#line 49
int jtag_parse_line(chain_t *chain , char *line ) ;
#line 50
int jtag_parse_stream(chain_t *chain , FILE *f ) ;
#line 42 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/parse.c"
int jtag_parse_line(chain_t *chain , char *line ) 
{ 
  int l ;
  int i ;
  int r ;
  int tcnt ;
  char **a ;
  char *c ;
  char *d ;
  char *sline ;
  size_t tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  unsigned short const   **tmp___5 ;
  char *tmp___6 ;
  void *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
#line 50
  if ((unsigned long )line == (unsigned long )((void *)0)) {
#line 51
    return (1);
  }
  {
#line 52
  tmp = strlen((char const   *)line);
#line 52
  l = (int )tmp;
  }
#line 53
  if (l == 0) {
#line 54
    return (1);
  }
  {
#line 57
  tmp___0 = malloc((size_t )((unsigned long )(l + 1) * sizeof(char )));
#line 57
  sline = (char *)tmp___0;
  }
#line 58
  if ((unsigned long )sline == (unsigned long )((void *)0)) {
    {
#line 59
    tmp___1 = gettext("Out of memory\n");
#line 59
    printf((char const   */* __restrict  */)tmp___1);
    }
#line 60
    return (1);
  }
#line 64
  c = line;
#line 65
  d = sline;
#line 66
  tcnt = 0;
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 69
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 69
      tmp___2 = __ctype_b_loc();
      }
#line 69
      if (! ((int const   )*(*tmp___2 + (int )*c) & 8192)) {
#line 69
        goto while_break___0;
      }
#line 70
      c ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 73
    if ((int )*c == 0) {
#line 74
      goto while_break;
    } else
#line 73
    if ((int )*c == 35) {
#line 74
      goto while_break;
    }
    {
#line 77
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 77
      tmp___5 = __ctype_b_loc();
      }
#line 77
      if ((int const   )*(*tmp___5 + (int )*c) & 8192) {
#line 77
        goto while_break___1;
      } else
#line 77
      if (! ((int )*c != 0)) {
#line 77
        goto while_break___1;
      }
#line 78
      tmp___3 = d;
#line 78
      d ++;
#line 78
      tmp___4 = c;
#line 78
      c ++;
#line 78
      *tmp___3 = *tmp___4;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 81
    tmp___6 = d;
#line 81
    d ++;
#line 81
    *tmp___6 = (char )'\000';
#line 82
    tcnt ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  if (tcnt == 0) {
    {
#line 86
    free((void *)sline);
    }
#line 87
    return (1);
  }
  {
#line 91
  tmp___7 = malloc((size_t )((unsigned long )(tcnt + 1) * sizeof(char *)));
#line 91
  a = (char **)tmp___7;
  }
#line 92
  if ((unsigned long )a == (unsigned long )((void *)0)) {
    {
#line 93
    tmp___8 = gettext("Out of memory\n");
#line 93
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___8);
    }
#line 94
    return (1);
  }
#line 98
  d = sline;
#line 99
  i = 0;
  {
#line 99
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 99
    if (! (i < tcnt)) {
#line 99
      goto while_break___2;
    }
#line 101
    *(a + i) = d;
    {
#line 102
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 102
      tmp___9 = d;
#line 102
      d ++;
#line 102
      if (! ((int )*tmp___9 != 0)) {
#line 102
        goto while_break___3;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 99
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 105
  *(a + tcnt) = (char *)((void *)0);
#line 107
  r = cmd_run(chain, a);
  }
#line 108
  if (debug_mode & 1) {
    {
#line 108
    printf((char const   */* __restrict  */)"Return in jtag_parse_line r=%d\n", r);
    }
  }
  {
#line 109
  free((void *)a);
#line 110
  free((void *)sline);
  }
#line 111
  return (r);
}
}
#line 115 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/parse.c"
int jtag_parse_stream(chain_t *chain , FILE *f ) 
{ 
  char inputline[101] ;
  int go ;
  int i ;
  int c ;
  int lnr ;
  int clip ;
  int found_comment ;
  int tmp ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 119
  go = 1;
#line 122
  lnr = 0;
  {
#line 123
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    i = 0;
#line 125
    clip = 0;
#line 126
    found_comment = 0;
    {
#line 129
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 130
      c = fgetc(f);
      }
#line 131
      if (c == -1) {
#line 132
        goto while_break___0;
      } else
#line 131
      if (c == 10) {
#line 132
        goto while_break___0;
      }
#line 133
      if (c == 35) {
#line 134
        found_comment = 1;
      }
#line 135
      if ((unsigned long )i < sizeof(inputline) - 1UL) {
#line 136
        tmp = i;
#line 136
        i ++;
#line 136
        inputline[tmp] = (char )c;
      } else {
#line 138
        clip = 1;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 140
    inputline[i] = (char )'\000';
#line 141
    lnr ++;
#line 142
    if (clip) {
#line 142
      if (! found_comment) {
        {
#line 143
        fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Warning: line %d exceeds %d characters, clipped\n",
                lnr, (int )sizeof(inputline) - 1);
        }
      }
    }
    {
#line 144
    go = jtag_parse_line(chain, inputline);
#line 145
    chain_flush(chain);
    }
#line 123
    if (go) {
#line 123
      if (! (c != -1)) {
#line 123
        goto while_break;
      }
    } else {
#line 123
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 149
  return (go);
}
}
#line 152 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/parse.c"
int jtag_parse_file(chain_t *chain , char const   *filename ) 
{ 
  FILE *f ;
  int go ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 158
  f = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 159
  if (! f) {
#line 160
    return (-1);
  }
  {
#line 162
  go = jtag_parse_stream(chain, f);
#line 164
  fclose(f);
  }
#line 165
  if (debug_mode & 1) {
    {
#line 165
    printf((char const   */* __restrict  */)"File Closed gp=%d\n", go);
    }
  }
#line 166
  return (go);
}
}
#line 34 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/jtag_data_dir.c"
char const   *jtag_get_data_dir(void) 
{ 
  char *__cil_tmp1 ;

  {
#line 36
  return ("/usr/local/share/urjtag");
}
}
#line 35 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/instruction.c"
static int cmd_instruction_run(chain_t *chain , char **params ) 
{ 
  part_t *part ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  unsigned int len ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  instruction *i ;
  char *tmp___8 ;
  size_t tmp___9 ;
  char *tmp___10 ;
  instruction *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
  {
#line 40
  tmp = cmd_test_cable(chain);
  }
#line 40
  if (! tmp) {
#line 41
    return (1);
  }
#line 43
  if (! chain->parts) {
    {
#line 44
    tmp___0 = gettext("Run \"detect\" first.\n");
#line 44
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 45
    return (1);
  }
#line 48
  if (chain->active_part >= (chain->parts)->len) {
    {
#line 49
    tmp___1 = gettext("%s: no active part\n");
#line 49
    printf((char const   */* __restrict  */)tmp___1, "instruction");
    }
#line 50
    return (1);
  }
  {
#line 53
  part = *((chain->parts)->parts + chain->active_part);
#line 55
  tmp___3 = cmd_params(params);
  }
#line 55
  if (tmp___3 == 2) {
    {
#line 56
    part_set_instruction(part, (char const   *)*(params + 1));
    }
#line 57
    if ((unsigned long )part->active_instruction == (unsigned long )((void *)0)) {
      {
#line 58
      tmp___2 = gettext("%s: unknown instruction \'%s\'\n");
#line 58
      printf((char const   */* __restrict  */)tmp___2, "instruction", *(params + 1));
      }
    }
#line 59
    return (1);
  }
  {
#line 62
  tmp___7 = cmd_params(params);
  }
#line 62
  if (tmp___7 == 3) {
    {
#line 65
    tmp___4 = strcasecmp((char const   *)*(params + 1), "length");
    }
#line 65
    if (tmp___4 != 0) {
#line 66
      return (-1);
    }
#line 68
    if ((unsigned long )part->instructions != (unsigned long )((void *)0)) {
      {
#line 69
      tmp___5 = gettext("instruction length is already set and used\n");
#line 69
      printf((char const   */* __restrict  */)tmp___5);
      }
#line 70
      return (1);
    }
    {
#line 73
    tmp___6 = cmd_get_number(*(params + 2), & len);
    }
#line 73
    if (tmp___6) {
#line 74
      return (-1);
    }
#line 76
    part->instruction_length = (int )len;
#line 77
    return (1);
  }
  {
#line 80
  tmp___14 = cmd_params(params);
  }
#line 80
  if (tmp___14 == 4) {
    {
#line 83
    tmp___9 = strlen((char const   *)*(params + 2));
    }
#line 83
    if (tmp___9 != (size_t )part->instruction_length) {
      {
#line 84
      tmp___8 = gettext("invalid instruction length\n");
#line 84
      printf((char const   */* __restrict  */)tmp___8);
      }
#line 85
      return (1);
    }
    {
#line 88
    tmp___11 = part_find_instruction(part, (char const   *)*(params + 1));
    }
#line 88
    if ((unsigned long )tmp___11 != (unsigned long )((void *)0)) {
      {
#line 89
      tmp___10 = gettext("Instruction \'%s\' already defined\n");
#line 89
      printf((char const   */* __restrict  */)tmp___10, *(params + 1));
      }
#line 90
      return (1);
    }
    {
#line 93
    i = instruction_alloc((char const   *)*(params + 1), part->instruction_length,
                          (char const   *)*(params + 2));
    }
#line 94
    if (! i) {
      {
#line 95
      tmp___12 = gettext("out of memory\n");
#line 95
      printf((char const   */* __restrict  */)tmp___12);
      }
#line 96
      return (1);
    }
    {
#line 99
    i->next = part->instructions;
#line 100
    part->instructions = i;
#line 102
    i->data_register = part_find_data_register(part, (char const   *)*(params + 3));
    }
#line 103
    if ((unsigned long )i->data_register == (unsigned long )((void *)0)) {
      {
#line 104
      tmp___13 = gettext("unknown data register \'%s\'\n");
#line 104
      printf((char const   */* __restrict  */)tmp___13, *(params + 3));
      }
#line 105
      return (1);
    }
#line 108
    return (1);
  }
#line 111
  return (-1);
}
}
#line 114 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/instruction.c"
static void cmd_instruction_help(void) 
{ 
  char *tmp ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 117
  tmp = gettext("Usage: %s INSTRUCTION\nUsage: %s length LENGTH\nUsage: %s INSTRUCTION CODE REGISTER\nChange active INSTRUCTION for a part or declare new instruction.\n\nINSTRUCTION   instruction name (e.g. BYPASS)\nLENGTH        common instruction length\nCODE          instruction code (e.g. 11111)\nREGISTER      default data register for instruction (e.g. BR)\n");
#line 117
  printf((char const   */* __restrict  */)tmp, "instruction", "instruction", "instruction");
  }
#line 128
  return;
}
}
#line 130 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/instruction.c"
cmd_t cmd_instruction  =    {(char *)"instruction", (char *)"change active instruction for a part or declare new instruction",
    & cmd_instruction_help, & cmd_instruction_run};
#line 34 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/initbus.c"
static int cmd_initbus_run(chain_t *chain , char **params ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  bus_t *abus ;
  bus_t *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
  {
#line 39
  tmp = cmd_params(params);
  }
#line 39
  if (tmp < 2) {
#line 40
    return (-1);
  }
  {
#line 42
  tmp___0 = cmd_test_cable(chain);
  }
#line 42
  if (! tmp___0) {
#line 43
    return (1);
  }
#line 45
  if (! chain->parts) {
    {
#line 46
    tmp___1 = gettext("Run \"detect\" first.\n");
#line 46
    printf((char const   */* __restrict  */)tmp___1);
    }
#line 47
    return (1);
  }
#line 50
  if (chain->active_part >= (chain->parts)->len) {
    {
#line 51
    tmp___2 = gettext("%s: no active part\n");
#line 51
    printf((char const   */* __restrict  */)tmp___2, "initbus");
    }
#line 52
    return (1);
  } else
#line 50
  if (chain->active_part < 0) {
    {
#line 51
    tmp___2 = gettext("%s: no active part\n");
#line 51
    printf((char const   */* __restrict  */)tmp___2, "initbus");
    }
#line 52
    return (1);
  }
#line 55
  i = 0;
  {
#line 55
  while (1) {
    while_continue: /* CIL Label */ ;
#line 55
    if (! ((unsigned long )bus_drivers[i] != (unsigned long )((void *)0))) {
#line 55
      goto while_break;
    }
    {
#line 56
    tmp___8 = strcasecmp((char const   *)(bus_drivers[i])->name, (char const   *)*(params + 1));
    }
#line 56
    if (tmp___8 == 0) {
      {
#line 57
      tmp___3 = (*((bus_drivers[i])->new_bus))(chain, bus_drivers[i], params);
#line 57
      abus = tmp___3;
      }
#line 58
      if ((unsigned long )abus == (unsigned long )((void *)0)) {
        {
#line 59
        tmp___4 = gettext("bus alloc/attach failed!\n");
#line 59
        printf((char const   */* __restrict  */)tmp___4);
        }
#line 60
        return (1);
      }
      {
#line 62
      buses_add(abus);
#line 63
      tmp___6 = (*((abus->driver)->init))(abus);
      }
#line 63
      if (tmp___6 != 0) {
        {
#line 64
        tmp___5 = gettext("bus initialization failed!\n");
#line 64
        printf((char const   */* __restrict  */)tmp___5);
        }
      }
#line 66
      i = 0;
      {
#line 66
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 66
        if (! (i < buses.len)) {
#line 66
          goto while_break___0;
        }
#line 67
        if ((unsigned long )*(buses.buses + i) == (unsigned long )bus) {
#line 68
          goto while_break___0;
        }
#line 66
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 69
      if (i != buses.len - 1) {
        {
#line 70
        tmp___7 = gettext("Initialized bus %d, active bus %d\n");
#line 70
        printf((char const   */* __restrict  */)tmp___7, buses.len - 1, i);
        }
      }
#line 72
      return (1);
    }
#line 55
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 76
  tmp___9 = gettext("Unknown bus: %s\n");
#line 76
  printf((char const   */* __restrict  */)tmp___9, *(params + 1));
  }
#line 78
  return (1);
}
}
#line 81 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/initbus.c"
static void cmd_initbus_help(void) 
{ 
  int i ;
  char *tmp ;
  char *tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 86
  tmp = gettext("Usage: %s BUSNAME\nInitialize new bus driver for active part.\n\nBUSNAME       Name of the bus\n\nList of available buses:\n");
#line 86
  printf((char const   */* __restrict  */)tmp, "initbus");
#line 95
  i = 0;
  }
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    if (! ((unsigned long )bus_drivers[i] != (unsigned long )((void *)0))) {
#line 95
      goto while_break;
    }
    {
#line 96
    tmp___0 = gettext("%-10s %s\n");
#line 96
    printf((char const   */* __restrict  */)tmp___0, (bus_drivers[i])->name, (bus_drivers[i])->description);
#line 95
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 97
  return;
}
}
#line 99 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/initbus.c"
struct __anonstruct_cmd_t_26  const  cmd_initbus  =    {(char *)"initbus", (char *)"initialize bus driver for active part", & cmd_initbus_help,
    & cmd_initbus_run};
#line 37 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/include.c"
static int cmd_include_or_script_run(chain_t *chain , int is_include , char **params ) 
{ 
  int go ;
  int i ;
  int j ;
  char *path ;
  int len ;
  int tmp ;
  char *tmp___0 ;
  char const   *jtag_data_dir ;
  char const   *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
  {
#line 40
  go = 0;
#line 40
  j = 1;
#line 44
  tmp = cmd_params(params);
  }
#line 44
  if (tmp < 2) {
#line 45
    return (-1);
  }
#line 47
  if (! is_include) {
    {
#line 49
    tmp___0 = gettext("Please use the \'include\' command instead of \'script\'\n");
#line 49
    printf((char const   */* __restrict  */)tmp___0);
    }
  }
#line 55
  path = *(params + 1);
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    if (! ((int )*path == 46)) {
#line 59
      goto while_break;
    }
#line 59
    path ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 60
  if ((int )*path == 47) {
    {
#line 62
    path = strdup((char const   *)*(params + 1));
    }
  } else
#line 60
  if ((int )*path == 92) {
    {
#line 62
    path = strdup((char const   *)*(params + 1));
    }
  } else
#line 60
  if (! is_include) {
    {
#line 62
    path = strdup((char const   *)*(params + 1));
    }
  } else {
    {
#line 66
    tmp___1 = jtag_get_data_dir();
#line 66
    jtag_data_dir = tmp___1;
#line 67
    tmp___2 = strlen(jtag_data_dir);
#line 67
    tmp___3 = strlen((char const   *)*(params + 1));
#line 67
    len = (int )((tmp___2 + tmp___3) + 2U);
#line 67
    tmp___4 = malloc((size_t )len);
#line 67
    path = (char *)tmp___4;
    }
#line 68
    if ((unsigned long )path != (unsigned long )((void *)0)) {
      {
#line 70
      snprintf((char */* __restrict  */)path, (size_t )len, (char const   */* __restrict  */)"%s/%s",
               jtag_data_dir, *(params + 1));
      }
    }
  }
#line 73
  if ((unsigned long )path == (unsigned long )((void *)0)) {
    {
#line 74
    tmp___5 = gettext("Out of memory\n");
#line 74
    printf((char const   */* __restrict  */)tmp___5);
    }
#line 75
    return (1);
  }
  {
#line 80
  tmp___6 = bsdl_read_file(chain, (char const   *)path, 1 << 3, (char const   *)((void *)0));
  }
#line 80
  if (tmp___6 >= 0) {
    {
#line 83
    go = bsdl_read_file(chain, (char const   *)path, ((((1 << 4) | (1 << 6)) | (1 << 1)) | (1 << 2)) | (1 << 3),
                        (char const   *)((void *)0));
#line 85
    free((void *)path);
    }
#line 86
    return (1);
  }
  {
#line 90
  tmp___7 = cmd_params(params);
  }
#line 90
  if (tmp___7 > 2) {
    {
#line 91
    sscanf((char const   */* __restrict  */)*(params + 2), (char const   */* __restrict  */)"%d",
           & j);
    }
  }
#line 94
  i = 0;
  {
#line 94
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 94
    if (! (i < j)) {
#line 94
      goto while_break___0;
    }
    {
#line 95
    go = jtag_parse_file(chain, (char const   *)path);
    }
#line 97
    if (go < 0) {
#line 98
      if (go != -99) {
        {
#line 99
        tmp___8 = gettext("Unable to open file `%s go=%d\'!\n");
#line 99
        printf((char const   */* __restrict  */)tmp___8, path, go);
        }
      }
#line 100
      goto while_break___0;
    }
#line 94
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 104
  free((void *)path);
  }
#line 106
  if (go) {
#line 106
    tmp___9 = 1;
  } else {
#line 106
    tmp___9 = 0;
  }
#line 106
  return (tmp___9);
}
}
#line 109 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/include.c"
static void cmd_include_or_script_help(char *cmd ) 
{ 
  char *tmp ;
  char *__cil_tmp3 ;

  {
  {
#line 112
  tmp = gettext("Usage: %s FILENAME [n] \nRun command sequence n times from external FILENAME.\n\nFILENAME      Name of the file with commands\n");
#line 112
  printf((char const   */* __restrict  */)tmp, cmd);
  }
#line 118
  return;
}
}
#line 120 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/include.c"
static int cmd_include_run(chain_t *chain , char **params ) 
{ 
  int tmp ;

  {
  {
#line 123
  tmp = cmd_include_or_script_run(chain, 1, params);
  }
#line 123
  return (tmp);
}
}
#line 126 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/include.c"
static void cmd_include_help(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
#line 129
  cmd_include_or_script_help((char *)"include");
  }
#line 130
  return;
}
}
#line 132 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/include.c"
cmd_t cmd_include  =    {(char *)"include", (char *)"include command sequence from external repository",
    & cmd_include_help, & cmd_include_run};
#line 139 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/include.c"
static int cmd_script_run(chain_t *chain , char **params ) 
{ 
  int tmp ;

  {
  {
#line 142
  tmp = cmd_include_or_script_run(chain, 0, params);
  }
#line 142
  return (tmp);
}
}
#line 145 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/include.c"
static void cmd_script_help(void) 
{ 
  char *__cil_tmp1 ;

  {
  {
#line 148
  cmd_include_or_script_help((char *)"script");
  }
#line 149
  return;
}
}
#line 151 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/include.c"
cmd_t cmd_script  =    {(char *)"script", (char *)"run command sequence from external file", & cmd_script_help,
    & cmd_script_run};
#line 32 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/idcode.c"
static int cmd_idcode_run(chain_t *chain , char **params ) 
{ 
  unsigned int bytes ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *__cil_tmp9 ;

  {
  {
#line 35
  bytes = 0U;
#line 37
  tmp___1 = cmd_params(params);
  }
#line 37
  if (tmp___1 == 1) {
#line 38
    bytes = 0U;
  } else {
    {
#line 41
    tmp___0 = cmd_params(params);
    }
#line 41
    if (tmp___0 > 2) {
#line 42
      return (-1);
    } else {
      {
#line 44
      tmp = cmd_get_number(*(params + 1), & bytes);
      }
#line 44
      if (tmp) {
#line 45
        return (-1);
      }
    }
  }
  {
#line 47
  tmp___2 = cmd_test_cable(chain);
  }
#line 47
  if (! tmp___2) {
#line 48
    return (1);
  }
  {
#line 50
  tmp___3 = gettext("Reading %d bytes if idcode\n");
#line 50
  printf((char const   */* __restrict  */)tmp___3, bytes);
#line 51
  idcode(chain, bytes);
  }
#line 52
  return (1);
}
}
#line 55 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/idcode.c"
static void cmd_idcode_help(void) 
{ 
  char *tmp ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
#line 58
  tmp = gettext("Usage: %s [BYTES]\nRead [BYTES]|all IDCODEs of all parts in a JTAG chain.\n\nBYTES must be an unsigned integer, Use 0 for BYTES to read all bytes\n");
#line 58
  printf((char const   */* __restrict  */)tmp, "idcode");
  }
#line 64
  return;
}
}
#line 66 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/idcode.c"
cmd_t cmd_idcode  =    {(char *)"idcode", (char *)"Read IDCODEs of all parts in a JTAG chain", & cmd_idcode_help,
    & cmd_idcode_run};
#line 46 "../../include/cmd.h"
cmd_t const   *cmds[41] ;
#line 32 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/help.c"
static int cmd_help_run(chain_t *chain , char **params ) 
{ 
  int i ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 38
  if (! *(params + 1)) {
    {
#line 39
    tmp = gettext("Command list:\n\n");
#line 39
    printf((char const   */* __restrict  */)tmp);
#line 40
    i = 0;
    }
    {
#line 40
    while (1) {
      while_continue: /* CIL Label */ ;
#line 40
      if (! cmds[i]) {
#line 40
        goto while_break;
      }
#line 41
      if ((cmds[i])->desc) {
        {
#line 41
        tmp___0 = gettext((char const   *)(cmds[i])->desc);
#line 41
        tmp___2 = tmp___0;
        }
      } else {
        {
#line 41
        tmp___1 = gettext("(no description available)");
#line 41
        tmp___2 = tmp___1;
        }
      }
      {
#line 41
      tmp___3 = gettext("%-13s %s\n");
#line 41
      printf((char const   */* __restrict  */)tmp___3, (cmds[i])->name, tmp___2);
#line 40
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 42
    tmp___4 = gettext("\nType \"help COMMAND\" for details about a particular command.\n");
#line 42
    printf((char const   */* __restrict  */)tmp___4);
    }
#line 43
    return (1);
  }
#line 46
  if (*(params + 2)) {
#line 47
    return (-1);
  }
#line 50
  i = 0;
  {
#line 50
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 50
    if (! cmds[i]) {
#line 50
      goto while_break___0;
    }
    {
#line 51
    tmp___5 = strcasecmp((char const   *)(cmds[i])->name, (char const   *)*(params + 1));
    }
#line 51
    if (tmp___5 == 0) {
#line 52
      if ((cmds[i])->help) {
        {
#line 53
        (*((cmds[i])->help))();
        }
      }
#line 54
      return (1);
    }
#line 50
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 57
  tmp___6 = gettext("%s: unknown command\n");
#line 57
  printf((char const   */* __restrict  */)tmp___6, *(params + 1));
  }
#line 59
  return (1);
}
}
#line 62 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/help.c"
static void cmd_help_help(void) 
{ 
  char *tmp ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
#line 65
  tmp = gettext("Usage: %s [COMMAND]\nPrint short help for COMMAND, or list of available commands.\n");
#line 65
  printf((char const   */* __restrict  */)tmp, "help");
  }
#line 69
  return;
}
}
#line 71 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/help.c"
cmd_t cmd_help  =    {(char *)"help", (char *)"display this help", & cmd_help_help, & cmd_help_run};
#line 36 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/get.c"
static int cmd_get_run(chain_t *chain , char **params ) 
{ 
  int data ;
  signal_t *s ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 42
  tmp = cmd_params(params);
  }
#line 42
  if (tmp != 3) {
#line 43
    return (-1);
  }
  {
#line 45
  tmp___0 = strcasecmp((char const   *)*(params + 1), "signal");
  }
#line 45
  if (tmp___0 != 0) {
#line 46
    return (-1);
  }
  {
#line 48
  tmp___1 = cmd_test_cable(chain);
  }
#line 48
  if (! tmp___1) {
#line 49
    return (1);
  }
#line 51
  if (! chain->parts) {
    {
#line 52
    tmp___2 = gettext("Run \"detect\" first.\n");
#line 52
    printf((char const   */* __restrict  */)tmp___2);
    }
#line 53
    return (1);
  }
#line 56
  if (chain->active_part >= (chain->parts)->len) {
    {
#line 57
    tmp___3 = gettext("%s: no active part\n");
#line 57
    printf((char const   */* __restrict  */)tmp___3, "get");
    }
#line 58
    return (1);
  }
  {
#line 61
  s = part_find_signal(*((chain->parts)->parts + chain->active_part), (char const   *)*(params + 2));
  }
#line 62
  if (! s) {
    {
#line 63
    tmp___4 = gettext("signal \'%s\' not found\n");
#line 63
    printf((char const   */* __restrict  */)tmp___4, *(params + 2));
    }
#line 64
    return (1);
  }
  {
#line 66
  data = part_get_signal(*((chain->parts)->parts + chain->active_part), s);
  }
#line 67
  if (data != -1) {
    {
#line 68
    tmp___5 = gettext("%s = %d\n");
#line 68
    printf((char const   */* __restrict  */)tmp___5, *(params + 2), data);
    }
  }
#line 70
  return (1);
}
}
#line 73 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/get.c"
static void cmd_get_help(void) 
{ 
  char *tmp ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
#line 76
  tmp = gettext("Usage: %s SIGNAL\nGet signal state from output BSR (Boundary Scan Register).\n\nSIGNAL        signal name (from JTAG declaration file)\n");
#line 76
  printf((char const   */* __restrict  */)tmp, "get signal");
  }
#line 82
  return;
}
}
#line 84 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/get.c"
cmd_t cmd_get  =    {(char *)"get", (char *)"get external signal value", & cmd_get_help, & cmd_get_run};
#line 34 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/frequency.c"
static int cmd_frequency_run(chain_t *chain , char **params ) 
{ 
  unsigned int freq ;
  int tmp ;
  uint32_t tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 39
  tmp = cmd_test_cable(chain);
  }
#line 39
  if (! tmp) {
#line 40
    return (1);
  }
  {
#line 42
  tmp___2 = cmd_params(params);
  }
#line 42
  if (tmp___2 == 1) {
    {
#line 43
    tmp___0 = cable_get_frequency(chain->cable);
#line 43
    tmp___1 = gettext("Current TCK frequency is %u Hz\n");
#line 43
    printf((char const   */* __restrict  */)tmp___1, tmp___0);
    }
#line 44
    return (1);
  }
  {
#line 47
  tmp___3 = cmd_params(params);
  }
#line 47
  if (tmp___3 != 2) {
#line 48
    return (-1);
  }
  {
#line 50
  tmp___4 = cmd_get_number(*(params + 1), & freq);
  }
#line 50
  if (tmp___4) {
#line 51
    return (-1);
  }
  {
#line 53
  tmp___5 = gettext("Setting TCK frequency to %u Hz\n");
#line 53
  printf((char const   */* __restrict  */)tmp___5, freq);
#line 54
  cable_set_frequency(chain->cable, freq);
  }
#line 56
  return (1);
}
}
#line 59 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/frequency.c"
static void cmd_frequency_help(void) 
{ 
  char *tmp ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
#line 62
  tmp = gettext("Usage: %s [FREQ]\nChange TCK frequency to FREQ or print current TCK frequency.\n\nFREQ is in hertz. It\'s a maximum TCK frequency for JTAG interface.\nIn some cases the TCK frequency is less than FREQ, but the frequency\nis never more than FREQ. Maximum supported frequency depends on JTAG\nadapter.\n\nFREQ must be an unsigned integer. Minimum allowed frequency is 1 Hz.\nUse 0 for FREQ to disable frequency limit.\n");
#line 62
  printf((char const   */* __restrict  */)tmp, "frequency");
  }
#line 74
  return;
}
}
#line 76 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/frequency.c"
cmd_t cmd_frequency  =    {(char *)"frequency", (char *)"setup JTAG frequency", & cmd_frequency_help, & cmd_frequency_run};
#line 36 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/flashmem.c"
static int cmd_flashmem_run(chain_t *chain , char **params ) 
{ 
  int msbin ;
  int noverify ;
  uint32_t adr ;
  FILE *f ;
  int paramc ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
#line 40
  noverify = 0;
#line 41
  adr = (uint32_t )0;
#line 43
  tmp = cmd_params(params);
#line 43
  paramc = tmp;
  }
#line 45
  if (paramc < 3) {
#line 46
    return (-1);
  }
#line 48
  if (! bus) {
    {
#line 49
    tmp___0 = gettext("Error: Bus driver missing.\n");
#line 49
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 50
    return (1);
  }
  {
#line 53
  tmp___1 = strcasecmp("msbin", (char const   *)*(params + 1));
#line 53
  msbin = tmp___1 == 0;
  }
#line 54
  if (! msbin) {
    {
#line 54
    tmp___2 = cmd_get_number(*(params + 1), & adr);
    }
#line 54
    if (tmp___2) {
#line 55
      return (-1);
    }
  }
#line 57
  if (paramc > 3) {
    {
#line 58
    tmp___3 = strcasecmp("noverify", (char const   *)*(params + 3));
#line 58
    noverify = tmp___3 == 0;
    }
  } else {
#line 60
    noverify = 0;
  }
  {
#line 62
  f = fopen((char const   */* __restrict  */)*(params + 2), (char const   */* __restrict  */)"rb");
  }
#line 63
  if (! f) {
    {
#line 64
    tmp___4 = gettext("Unable to open file `%s\'!\n");
#line 64
    printf((char const   */* __restrict  */)tmp___4, *(params + 2));
    }
#line 65
    return (1);
  }
#line 67
  if (msbin) {
    {
#line 68
    flashmsbin(bus, f, noverify);
    }
  } else {
    {
#line 70
    flashmem(bus, f, adr, noverify);
    }
  }
  {
#line 71
  fclose(f);
  }
#line 73
  return (1);
}
}
#line 76 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/flashmem.c"
static void cmd_flashmem_help(void) 
{ 
  int i ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 81
  tmp = gettext("Usage: %s ADDR FILENAME [noverify]\nUsage: %s FILENAME [noverify]\nProgram FILENAME content to flash memory.\n\nADDR       target address for raw binary image\nFILENAME   name of the input file\n%-10s FILENAME is in MS .bin format (for WinCE)\n%-10s if specified, verification is skipped\n\nADDR could be in decimal or hexadecimal (prefixed with 0x) form.\n\nSupported Flash Memories:\n");
#line 81
  printf((char const   */* __restrict  */)tmp, "flashmem", "flashmem msbin", "msbin",
         "noverify");
#line 96
  i = 0;
  }
  {
#line 96
  while (1) {
    while_continue: /* CIL Label */ ;
#line 96
    if (! flash_drivers[i]) {
#line 96
      goto while_break;
    }
    {
#line 97
    tmp___0 = gettext((flash_drivers[i])->description);
#line 97
    tmp___1 = gettext((flash_drivers[i])->name);
#line 97
    tmp___2 = gettext("%s\n     %s\n");
#line 97
    printf((char const   */* __restrict  */)tmp___2, tmp___1, tmp___0);
#line 96
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  return;
}
}
#line 100 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/flashmem.c"
cmd_t cmd_flashmem  =    {(char *)"flashmem", (char *)"burn flash memory with data from a file", & cmd_flashmem_help,
    & cmd_flashmem_run};
#line 36 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/eraseflash.c"
static int cmd_eraseflash_run(chain_t *chain , char **params ) 
{ 
  uint32_t adr ;
  unsigned int number ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp10 ;

  {
  {
#line 39
  adr = (uint32_t )0;
#line 40
  number = 0U;
#line 42
  tmp = cmd_params(params);
  }
#line 42
  if (tmp != 3) {
#line 43
    return (-1);
  }
  {
#line 44
  tmp___0 = cmd_test_cable(chain);
  }
#line 44
  if (! tmp___0) {
#line 45
    return (1);
  }
#line 46
  if (! bus) {
    {
#line 47
    tmp___1 = gettext("Error: Bus driver missing.\n");
#line 47
    printf((char const   */* __restrict  */)tmp___1);
    }
#line 48
    return (1);
  }
  {
#line 50
  tmp___2 = cmd_get_number(*(params + 1), & adr);
  }
#line 50
  if (tmp___2) {
#line 51
    return (-1);
  }
  {
#line 52
  tmp___3 = cmd_get_number(*(params + 2), & number);
  }
#line 52
  if (tmp___3) {
#line 53
    return (-1);
  }
  {
#line 54
  flasherase(bus, adr, (int )number);
  }
#line 56
  return (1);
}
}
#line 59 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/eraseflash.c"
static void cmd_eraseflash_help(void) 
{ 
  int i ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 64
  tmp = gettext("Usage: %s ADDR BLOCKS\nErase flash memory from ADDR.\n\nADDR       target addres for erasing block\nBLOCKS     number of blocks to erase\n\nADDR and BLOCKS could be in decimal or hexadecimal (prefixed with 0x) form.\n\nSupported Flash Memories:\n");
#line 64
  printf((char const   */* __restrict  */)tmp, "eraseflash");
#line 76
  i = 0;
  }
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    if (! flash_drivers[i]) {
#line 76
      goto while_break;
    }
    {
#line 77
    tmp___0 = gettext((flash_drivers[i])->description);
#line 77
    tmp___1 = gettext((flash_drivers[i])->name);
#line 77
    tmp___2 = gettext("%s\n     %s\n");
#line 77
    printf((char const   */* __restrict  */)tmp___2, tmp___1, tmp___0);
#line 76
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 78
  return;
}
}
#line 80 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/eraseflash.c"
cmd_t cmd_eraseflash  =    {(char *)"eraseflash", (char *)"erase flash memory by number of blocks", & cmd_eraseflash_help,
    & cmd_eraseflash_run};
#line 34 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/endian.c"
static int cmd_endian_run(chain_t *chain , char **params ) 
{ 
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 37
  tmp = cmd_params(params);
  }
#line 37
  if (tmp > 2) {
#line 38
    return (-1);
  }
#line 40
  if (! *(params + 1)) {
#line 41
    if (big_endian) {
      {
#line 42
      tmp___0 = gettext("Endianess for external files: big\n");
#line 42
      printf((char const   */* __restrict  */)tmp___0);
      }
    } else {
      {
#line 44
      tmp___1 = gettext("Endianess for external files: little\n");
#line 44
      printf((char const   */* __restrict  */)tmp___1);
      }
    }
#line 45
    return (1);
  }
  {
#line 49
  tmp___2 = strcasecmp((char const   *)*(params + 1), "little");
  }
#line 49
  if (tmp___2 == 0) {
#line 50
    big_endian = 0;
#line 51
    return (1);
  }
  {
#line 53
  tmp___3 = strcasecmp((char const   *)*(params + 1), "big");
  }
#line 53
  if (tmp___3 == 0) {
#line 54
    big_endian = 1;
#line 55
    return (1);
  }
#line 58
  return (-1);
}
}
#line 61 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/endian.c"
static void cmd_endian_help(void) 
{ 
  char *tmp ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
#line 64
  tmp = gettext("Usage: %s\nSet or print endianess for external files.\n");
#line 64
  printf((char const   */* __restrict  */)tmp, "endian [little|big]");
  }
#line 68
  return;
}
}
#line 70 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/endian.c"
cmd_t cmd_endian  =    {(char *)"endian", (char *)"set/print endianess", & cmd_endian_help, & cmd_endian_run};
#line 286 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2))) strspn)(char const   *__s ,
                                                                                        char const   *__accept )  __attribute__((__pure__)) ;
#line 35 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/dr.c"
static int cmd_dr_run(chain_t *chain , char **params ) 
{ 
  int dir ;
  tap_register *r ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  unsigned int bit ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  char *tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char const   *tmp___12 ;
  char *tmp___13 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;

  {
  {
#line 38
  dir = 1;
#line 41
  tmp = cmd_params(params);
  }
#line 41
  if (tmp < 1) {
#line 42
    return (-1);
  } else {
    {
#line 41
    tmp___0 = cmd_params(params);
    }
#line 41
    if (tmp___0 > 2) {
#line 42
      return (-1);
    }
  }
  {
#line 44
  tmp___1 = cmd_test_cable(chain);
  }
#line 44
  if (! tmp___1) {
#line 45
    return (1);
  }
#line 47
  if (! chain->parts) {
    {
#line 48
    tmp___2 = gettext("Run \"detect\" first.\n");
#line 48
    printf((char const   */* __restrict  */)tmp___2);
    }
#line 49
    return (1);
  }
#line 52
  if (chain->active_part >= (chain->parts)->len) {
    {
#line 53
    tmp___3 = gettext("%s: no active part\n");
#line 53
    printf((char const   */* __restrict  */)tmp___3, "dr");
    }
#line 54
    return (1);
  }
#line 57
  if ((unsigned long )(*((chain->parts)->parts + chain->active_part))->active_instruction == (unsigned long )((void *)0)) {
    {
#line 58
    tmp___4 = gettext("%s: part without active instruction\n");
#line 58
    printf((char const   */* __restrict  */)tmp___4, "dr");
    }
#line 59
    return (1);
  }
#line 61
  if ((unsigned long )((*((chain->parts)->parts + chain->active_part))->active_instruction)->data_register == (unsigned long )((void *)0)) {
    {
#line 62
    tmp___5 = gettext("%s: part without active data register\n");
#line 62
    printf((char const   */* __restrict  */)tmp___5, "dr");
    }
#line 63
    return (1);
  }
#line 66
  if (*(params + 1)) {
    {
#line 67
    tmp___11 = strcasecmp((char const   *)*(params + 1), "in");
    }
#line 67
    if (tmp___11 == 0) {
#line 68
      dir = 0;
    } else {
      {
#line 69
      tmp___10 = strcasecmp((char const   *)*(params + 1), "out");
      }
#line 69
      if (tmp___10 == 0) {
#line 70
        dir = 1;
      } else {
        {
#line 73
        tmp___6 = strspn((char const   *)*(params + 1), "01");
#line 73
        tmp___7 = strlen((char const   *)*(params + 1));
        }
#line 73
        if (tmp___6 != tmp___7) {
#line 74
          return (-1);
        }
        {
#line 77
        r = (((*((chain->parts)->parts + chain->active_part))->active_instruction)->data_register)->in;
#line 78
        tmp___9 = strlen((char const   *)*(params + 1));
        }
#line 78
        if ((size_t )r->len != tmp___9) {
          {
#line 79
          tmp___8 = gettext("%s: register length mismatch\n");
#line 79
          printf((char const   */* __restrict  */)tmp___8, "dr");
          }
#line 80
          return (1);
        }
#line 82
        bit = 0U;
        {
#line 82
        while (1) {
          while_continue: /* CIL Label */ ;
#line 82
          if (! *(*(params + 1) + bit)) {
#line 82
            goto while_break;
          }
#line 83
          *(r->data + ((unsigned int )(r->len - 1) - bit)) = (char )((int )*(*(params + 1) + bit) == 49);
#line 82
          bit ++;
        }
        while_break: /* CIL Label */ ;
        }
#line 86
        dir = 0;
      }
    }
  }
#line 90
  if (dir) {
#line 91
    r = (((*((chain->parts)->parts + chain->active_part))->active_instruction)->data_register)->out;
  } else {
#line 93
    r = (((*((chain->parts)->parts + chain->active_part))->active_instruction)->data_register)->in;
  }
  {
#line 94
  tmp___12 = register_get_string((tap_register const   *)r);
#line 94
  tmp___13 = gettext("%s\n");
#line 94
  printf((char const   */* __restrict  */)tmp___13, tmp___12);
  }
#line 96
  return (1);
}
}
#line 99 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/dr.c"
static void cmd_dr_help(void) 
{ 
  char *tmp ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 102
  tmp = gettext("Usage: %s [DIR]\nUsage: %s BITSTRING\nDisplay input or output data register content or set current register.\n\nDIR           requested data register; possible values: \'in\' for\n              input and \'out\' for output; default is \'out\'\nBITSTRING     set current data register with BITSTRING (e.g. 01010)\n");
#line 102
  printf((char const   */* __restrict  */)tmp, "dr", "dr");
  }
#line 111
  return;
}
}
#line 113 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/dr.c"
cmd_t cmd_dr  =    {(char *)"dr", (char *)"display active data register for a part", & cmd_dr_help,
    & cmd_dr_run};
#line 33 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/discovery.c"
static int cmd_discovery_run(chain_t *chain , char **params ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 36
  tmp = cmd_params(params);
  }
#line 36
  if (tmp != 1) {
#line 37
    return (-1);
  }
  {
#line 39
  tmp___0 = cmd_test_cable(chain);
  }
#line 39
  if (! tmp___0) {
#line 40
    return (1);
  }
  {
#line 42
  discovery(chain);
  }
#line 44
  return (1);
}
}
#line 47 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/discovery.c"
static void cmd_discovery_help(void) 
{ 
  char *tmp ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 50
  tmp = gettext("Usage: %s\nDiscovery of unknown parts in the JTAG chain.\n\n\'%s\' attempts to detect these parameters of an unknown JTAG\nchain:\n 1. IR (instruction register) length\n 2. DR (data register) length for all possible instructions\n\nWarning: This may be dangerous for some parts (especially if the\npart doesn\'t have TRST signal).\n");
#line 50
  printf((char const   */* __restrict  */)tmp, "discovery", "discovery");
  }
#line 62
  return;
}
}
#line 64 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/discovery.c"
cmd_t cmd_discovery  =    {(char *)"discovery", (char *)"discovery of unknown parts in the JTAG chain", & cmd_discovery_help,
    & cmd_discovery_run};
#line 32 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/detectflash.c"
static int cmd_detectflash_run(chain_t *chain , char **params ) 
{ 
  uint32_t adr ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp7 ;

  {
  {
#line 37
  tmp = cmd_params(params);
  }
#line 37
  if (tmp != 2) {
#line 38
    return (-1);
  }
#line 40
  if (! bus) {
    {
#line 41
    tmp___0 = gettext("Error: Bus driver missing.\n");
#line 41
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 42
    return (1);
  }
  {
#line 45
  tmp___1 = cmd_get_number(*(params + 1), & adr);
  }
#line 45
  if (tmp___1) {
#line 46
    return (-1);
  }
  {
#line 48
  detectflash(bus, adr);
  }
#line 50
  return (1);
}
}
#line 53 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/detectflash.c"
static void cmd_detectflash_help(void) 
{ 
  char *tmp ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
#line 56
  tmp = gettext("Usage: %s ADDRESS\nDetect flash memory type connected to a part.\n\nADDRESS    Base address for memory region\n");
#line 56
  printf((char const   */* __restrict  */)tmp, "detectflash");
  }
#line 62
  return;
}
}
#line 64 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/detectflash.c"
cmd_t cmd_detectflash  =    {(char *)"detectflash", (char *)"detect parameters of flash chips attached to a part",
    & cmd_detectflash_help, & cmd_detectflash_run};
#line 36 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/detect.c"
static int cmd_detect_run(chain_t *chain , char **params ) 
{ 
  int i ;
  bus_t *abus ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 42
  tmp = cmd_params(params);
  }
#line 42
  if (tmp != 1) {
#line 43
    return (-1);
  }
  {
#line 45
  tmp___0 = cmd_test_cable(chain);
  }
#line 45
  if (! tmp___0) {
#line 46
    return (1);
  }
  {
#line 48
  buses_free();
#line 49
  parts_free(chain->parts);
#line 50
  chain->parts = (parts_t *)((void *)0);
#line 51
  tmp___1 = jtag_get_data_dir();
#line 51
  detect_parts(chain, tmp___1);
  }
#line 52
  if (! chain->parts) {
#line 53
    return (1);
  }
#line 54
  if (! (chain->parts)->len) {
    {
#line 55
    parts_free(chain->parts);
#line 56
    chain->parts = (parts_t *)((void *)0);
    }
#line 57
    return (1);
  }
  {
#line 59
  parts_set_instruction(chain->parts, "SAMPLE/PRELOAD");
#line 60
  chain_shift_instructions(chain);
#line 61
  chain_shift_data_registers(chain, 1);
#line 62
  parts_set_instruction(chain->parts, "BYPASS");
#line 63
  chain_shift_instructions(chain);
#line 66
  i = 0;
  }
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 66
    if (! (i < buses.len)) {
#line 66
      goto while_break;
    }
#line 68
    abus = *(buses.buses + i);
#line 69
    if ((abus->driver)->init) {
      {
#line 71
      tmp___2 = (*((abus->driver)->init))(abus);
      }
#line 71
      if (tmp___2 != 0) {
#line 72
        return (-1);
      }
    }
#line 66
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 76
  return (1);
}
}
#line 79 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/detect.c"
static void cmd_detect_help(void) 
{ 
  char *tmp ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
#line 82
  tmp = gettext("Usage: %s\nDetect parts on the JTAG chain.\n\nOutput from this command is a list of the detected parts.\nIf no parts are detected other commands may not work properly.\n");
#line 82
  printf((char const   */* __restrict  */)tmp, "detect");
  }
#line 89
  return;
}
}
#line 91 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/detect.c"
cmd_t cmd_detect  =    {(char *)"detect", (char *)"detect parts on the JTAG chain", & cmd_detect_help,
    & cmd_detect_run};
#line 37 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/debug.c"
static int cmd_debug_run(chain_t *chain , char **params ) 
{ 
  unsigned int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 42
  tmp = cmd_params(params);
  }
#line 42
  if (tmp != 2) {
#line 43
    return (-1);
  }
  {
#line 45
  tmp___0 = cmd_get_number(*(params + 1), & i);
  }
#line 45
  if (tmp___0) {
#line 46
    return (1);
  }
#line 48
  debug_mode = (int )i;
#line 49
  return (1);
}
}
#line 52 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/debug.c"
static void cmd_debug_help(void) 
{ 
  char *tmp ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
#line 55
  tmp = gettext("Usage: %s  n\nEnabled debugging.\n\nn =1 fileio, 2=tap commands, 4 =?\n");
#line 55
  printf((char const   */* __restrict  */)tmp, "debug n");
  }
#line 61
  return;
}
}
#line 63 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/debug.c"
cmd_t cmd_debug  =    {(char *)"debug", (char *)"debug jtag program", & cmd_debug_help, & cmd_debug_run};
#line 40 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/cmd.c"
cmd_t cmd_cable ;
#line 48
cmd_t cmd_bit ;
#line 53
cmd_t cmd_bus ;
#line 72
cmd_t cmd_addpart ;
#line 78
cmd_t cmd_bsdl ;
#line 82 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/cmd.c"
cmd_t const   *cmds[41]  = 
#line 82
  {      (cmd_t const   *)(& cmd_quit),      (cmd_t const   *)(& cmd_help),      (cmd_t const   *)(& cmd_frequency),      (cmd_t const   *)(& cmd_cable), 
        (cmd_t const   *)(& cmd_reset),      (cmd_t const   *)(& cmd_discovery),      (cmd_t const   *)(& cmd_idcode),      (cmd_t const   *)(& cmd_detect), 
        (cmd_t const   *)(& cmd_signal),      (cmd_t const   *)(& cmd_scan),      & cmd_salias,      (cmd_t const   *)(& cmd_bit), 
        (cmd_t const   *)(& cmd_register),      & cmd_initbus,      (cmd_t const   *)(& cmd_print),      (cmd_t const   *)(& cmd_part), 
        (cmd_t const   *)(& cmd_bus),      (cmd_t const   *)(& cmd_instruction),      (cmd_t const   *)(& cmd_shift),      (cmd_t const   *)(& cmd_dr), 
        (cmd_t const   *)(& cmd_get),      (cmd_t const   *)(& cmd_test),      (cmd_t const   *)(& cmd_shell),      (cmd_t const   *)(& cmd_set), 
        (cmd_t const   *)(& cmd_endian),      (cmd_t const   *)(& cmd_peek),      (cmd_t const   *)(& cmd_poke),      (cmd_t const   *)(& cmd_pod), 
        (cmd_t const   *)(& cmd_readmem),      (cmd_t const   *)(& cmd_writemem),      (cmd_t const   *)(& cmd_detectflash),      (cmd_t const   *)(& cmd_flashmem), 
        (cmd_t const   *)(& cmd_eraseflash),      (cmd_t const   *)(& cmd_script),      (cmd_t const   *)(& cmd_include),      (cmd_t const   *)(& cmd_addpart), 
        (cmd_t const   *)(& cmd_usleep),      (cmd_t const   *)(& cmd_svf),      (cmd_t const   *)(& cmd_bsdl),      (cmd_t const   *)(& cmd_debug), 
        (cmd_t const   *)((void *)0)};
#line 164 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/cmd.c"
int cmd_test_cable(chain_t *chain ) 
{ 
  char *tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 167
  if (chain->cable) {
#line 168
    return (1);
  }
  {
#line 170
  tmp = gettext("Error: Cable not configured. Please use \'%s\' command first!\n");
#line 170
  printf((char const   */* __restrict  */)tmp, "cable");
  }
#line 171
  return (0);
}
}
#line 176 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/cmd.c"
int cmd_run(chain_t *chain , char **params ) 
{ 
  int i ;
  int pidx ;
  size_t len ;
  int r ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 182
  if (! *(params + 0)) {
#line 183
    return (1);
  }
  {
#line 185
  pidx = -1;
#line 186
  len = strlen((char const   *)*(params + 0));
#line 188
  i = 0;
  }
  {
#line 188
  while (1) {
    while_continue: /* CIL Label */ ;
#line 188
    if (! cmds[i]) {
#line 188
      goto while_break;
    }
    {
#line 189
    tmp___1 = strcasecmp((char const   *)(cmds[i])->name, (char const   *)*(params + 0));
    }
#line 189
    if (tmp___1 == 0) {
      run_cmd: 
      {
#line 192
      r = (*((cmds[i])->run))(chain, params);
      }
#line 193
      if (r < 0) {
        {
#line 194
        tmp = gettext("%s: syntax error!\n");
#line 194
        printf((char const   */* __restrict  */)tmp, *(params + 0));
        }
      }
#line 195
      return (r);
    } else {
      {
#line 196
      tmp___0 = strncasecmp((char const   *)(cmds[i])->name, (char const   *)*(params + 0),
                            len);
      }
#line 196
      if (tmp___0 == 0) {
#line 197
        if (pidx == -1) {
#line 198
          pidx = i;
        } else {
#line 200
          pidx = -2;
        }
      }
    }
#line 188
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 205
  if (pidx == -2) {
#line 205
    goto case_neg_2;
  }
#line 206
  if (pidx == -1) {
#line 206
    goto case_neg_1;
  }
#line 207
  goto switch_default;
  case_neg_2: /* CIL Label */ 
  {
#line 205
  tmp___2 = gettext("%s: Ambiguous command\n");
#line 205
  printf((char const   */* __restrict  */)tmp___2, *(params + 0));
  }
#line 205
  goto switch_break;
  case_neg_1: /* CIL Label */ 
  {
#line 206
  tmp___3 = gettext("%s: unknown command\n");
#line 206
  printf((char const   */* __restrict  */)tmp___3, *(params + 0));
  }
#line 206
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 207
  i = pidx;
#line 207
  goto run_cmd;
  switch_break: /* CIL Label */ ;
  }
#line 210
  return (1);
}
}
#line 213 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/cmd.c"
int cmd_params(char **params ) 
{ 
  int i ;

  {
#line 216
  i = 0;
  {
#line 218
  while (1) {
    while_continue: /* CIL Label */ ;
#line 218
    if (! *(params + i)) {
#line 218
      goto while_break;
    }
#line 219
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 221
  return (i);
}
}
#line 224 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/cmd.c"
int cmd_get_number(char *s , unsigned int *i ) 
{ 
  int n ;
  int r ;
  size_t l ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 231
  if (! s) {
#line 232
    return (-1);
  } else
#line 231
  if (! i) {
#line 232
    return (-1);
  }
  {
#line 234
  l = strlen((char const   *)s);
#line 236
  n = -1;
#line 237
  r = sscanf((char const   */* __restrict  */)s, (char const   */* __restrict  */)"0x%x%n",
             i, & n);
  }
#line 238
  if (r == 1) {
#line 238
    if ((size_t )n == l) {
#line 239
      return (0);
    }
  }
  {
#line 241
  n = -1;
#line 242
  r = sscanf((char const   */* __restrict  */)s, (char const   */* __restrict  */)"%u%n",
             i, & n);
  }
#line 243
  if (r == 1) {
#line 243
    if ((size_t )n == l) {
#line 244
      return (0);
    }
  }
#line 246
  return (-1);
}
}
#line 40 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/cable.c"
static int cmd_cable_run(chain_t *chain , char **params ) 
{ 
  cable_t *cable ;
  int i ;
  int paramc ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmparam ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
  {
#line 45
  tmp = cmd_params(params);
#line 45
  paramc = tmp;
  }
#line 48
  if (paramc < 2) {
#line 48
    return (-1);
  }
#line 51
  i = 0;
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
#line 51
    if (! parport_drivers[i]) {
#line 51
      goto while_break;
    }
    {
#line 52
    tmp___0 = strcasecmp((char const   *)*(params + 1), (parport_drivers[i])->type);
    }
#line 52
    if (tmp___0 == 0) {
#line 53
      goto while_break;
    }
#line 51
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 55
  if ((unsigned long )parport_drivers[i] != (unsigned long )((parport_driver_t *)0)) {
    {
#line 58
    tmp___1 = gettext("Note: the \'cable\' command syntax changed, please read the help text\n");
#line 58
    printf((char const   */* __restrict  */)tmp___1);
    }
#line 59
    if (paramc >= 4) {
#line 62
      tmparam = *(params + 3);
#line 63
      *(params + 3) = *(params + 2);
#line 64
      *(params + 2) = *(params + 1);
#line 65
      *(params + 1) = tmparam;
    } else {
#line 68
      return (-1);
    }
  }
#line 72
  i = 0;
  {
#line 72
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 72
    if (! cable_drivers[i]) {
#line 72
      goto while_break___0;
    }
    {
#line 73
    tmp___2 = strcasecmp((char const   *)*(params + 1), (cable_drivers[i])->name);
    }
#line 73
    if (tmp___2 == 0) {
#line 74
      goto while_break___0;
    }
#line 72
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 75
  if (! cable_drivers[i]) {
    {
#line 76
    tmp___3 = gettext("Unknown cable type: %s\n");
#line 76
    printf((char const   */* __restrict  */)tmp___3, *(params + 1));
    }
#line 77
    return (1);
  }
#line 80
  if (paramc >= 3) {
    {
#line 82
    tmp___4 = strcasecmp((char const   *)*(params + 2), "help");
    }
#line 82
    if (tmp___4 == 0) {
      {
#line 84
      (*((cable_drivers[i])->help))((cable_drivers[i])->name);
      }
#line 85
      return (1);
    }
  }
#line 89
  if (bus) {
    {
#line 90
    (*((bus->driver)->free_bus))(bus);
#line 91
    bus = (bus_t *)((void *)0);
    }
  }
  {
#line 94
  chain_disconnect(chain);
#line 96
  tmp___5 = calloc((size_t )1, (size_t )sizeof(cable_t ));
#line 96
  cable = (cable_t *)tmp___5;
  }
#line 97
  if (! cable) {
    {
#line 98
    tmp___6 = gettext("%s(%d) malloc failed!\n");
#line 98
    printf((char const   */* __restrict  */)tmp___6, "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/cable.c",
           98);
    }
#line 99
    return (1);
  }
  {
#line 102
  cable->driver = cable_drivers[i];
#line 104
  params ++;
#line 104
  tmp___8 = (*((cable->driver)->connect))(params, cable);
  }
#line 104
  if (tmp___8) {
    {
#line 105
    tmp___7 = gettext("Error: Cable connection failed!\n");
#line 105
    printf((char const   */* __restrict  */)tmp___7);
#line 106
    free((void *)cable);
    }
#line 107
    return (1);
  }
  {
#line 110
  chain->cable = cable;
#line 112
  tmp___10 = cable_init(chain->cable);
  }
#line 112
  if (tmp___10) {
    {
#line 113
    tmp___9 = gettext("Error: Cable initialization failed!\n");
#line 113
    printf((char const   */* __restrict  */)tmp___9);
#line 114
    chain_disconnect(chain);
    }
#line 115
    return (1);
  }
  {
#line 117
  chain_set_trst(chain, 0);
#line 118
  chain_set_trst(chain, 1);
#line 119
  tap_reset(chain);
  }
#line 121
  return (1);
}
}
#line 124 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/cable.c"
static void cmd_cable_help(void) 
{ 
  int i ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 129
  tmp = gettext("Usage: %s DRIVER [DRIVER_OPTS]\nSelect JTAG cable type.\n\nDRIVER      name of cable\nDRIVER_OPTS options for the selected cable\n\nType \"cable DRIVER help\" for info about options for cable DRIVER.\n\nList of supported cables:\n");
#line 129
  printf((char const   */* __restrict  */)tmp, "cable");
#line 141
  i = 0;
  }
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 141
    if (! cable_drivers[i]) {
#line 141
      goto while_break;
    }
    {
#line 142
    tmp___0 = gettext((cable_drivers[i])->description);
#line 142
    tmp___1 = gettext("%-13s %s\n");
#line 142
    printf((char const   */* __restrict  */)tmp___1, (cable_drivers[i])->name, tmp___0);
#line 141
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 143
  return;
}
}
#line 145 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/cable.c"
cmd_t cmd_cable  =    {(char *)"cable", (char *)"select JTAG cable", & cmd_cable_help, & cmd_cable_run};
#line 34 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/bus.c"
static int cmd_bus_run(chain_t *chain , char **params ) 
{ 
  unsigned int n ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 39
  tmp = cmd_params(params);
  }
#line 39
  if (tmp != 2) {
#line 40
    return (-1);
  }
  {
#line 42
  tmp___0 = cmd_test_cable(chain);
  }
#line 42
  if (! tmp___0) {
#line 43
    return (1);
  }
#line 45
  if (! chain->parts) {
    {
#line 46
    tmp___1 = gettext("Run \"detect\" first.\n");
#line 46
    printf((char const   */* __restrict  */)tmp___1);
    }
#line 47
    return (1);
  }
  {
#line 50
  tmp___2 = cmd_get_number(*(params + 1), & n);
  }
#line 50
  if (tmp___2) {
#line 51
    return (-1);
  }
#line 53
  if (n >= (unsigned int )buses.len) {
    {
#line 54
    tmp___3 = gettext("%s: invalid bus number\n");
#line 54
    printf((char const   */* __restrict  */)tmp___3, "bus");
    }
#line 55
    return (1);
  }
#line 58
  bus = *(buses.buses + n);
#line 60
  return (1);
}
}
#line 63 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/bus.c"
static void cmd_bus_help(void) 
{ 
  char *tmp ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
#line 66
  tmp = gettext("Usage: %s BUS\nChange active bus.\n\nBUS           bus number\n");
#line 66
  printf((char const   */* __restrict  */)tmp, "bus");
  }
#line 72
  return;
}
}
#line 74 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/bus.c"
cmd_t cmd_bus  =    {(char *)"bus", (char *)"change active bus", & cmd_bus_help, & cmd_bus_run};
#line 35 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/bsdl.c"
static int cmd_bsdl_run(chain_t *chain , char **params ) 
{ 
  int num_params ;
  int result ;
  bsdl_globs_t *globs ;
  int debug_save ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
  {
#line 38
  result = -1;
#line 39
  globs = & chain->bsdl;
#line 41
  num_params = cmd_params(params);
  }
#line 42
  if (num_params >= 2) {
    {
#line 43
    tmp___1 = strcmp((char const   *)*(params + 1), "test");
    }
#line 43
    if (tmp___1 == 0) {
#line 46
      debug_save = globs->debug;
#line 47
      globs->debug = 1;
#line 48
      if (num_params == 3) {
        {
#line 49
        tmp___0 = bsdl_read_file(chain, (char const   *)*(params + 2), (1 << 4) | ((((1 << 3) | (1 << 2)) | (1 << 1)) | 1),
                                 (char const   *)((void *)0));
        }
#line 49
        if (tmp___0 >= 0) {
#line 49
          result = 1;
        } else {
#line 49
          result = -1;
        }
      } else
#line 50
      if (num_params == 2) {
        {
#line 51
        bsdl_scan_files(chain, (char const   *)((void *)0), (1 << 4) | ((((1 << 3) | (1 << 2)) | (1 << 1)) | 1));
#line 52
        result = 1;
        }
      }
#line 54
      globs->debug = debug_save;
    }
    {
#line 57
    tmp___4 = strcmp((char const   *)*(params + 1), "dump");
    }
#line 57
    if (tmp___4 == 0) {
#line 58
      if (num_params == 3) {
        {
#line 59
        tmp___3 = bsdl_read_file(chain, (char const   *)*(params + 2), ((((1 << 4) | (1 << 5)) | (1 << 1)) | (1 << 2)) | (1 << 3),
                                 (char const   *)((void *)0));
        }
#line 59
        if (tmp___3 >= 0) {
#line 59
          result = 1;
        } else {
#line 59
          result = -1;
        }
      } else
#line 60
      if (num_params == 2) {
        {
#line 61
        bsdl_scan_files(chain, (char const   *)((void *)0), ((((1 << 4) | (1 << 5)) | (1 << 1)) | (1 << 2)) | (1 << 3));
#line 62
        result = 1;
        }
      }
    }
#line 66
    if (num_params == 3) {
      {
#line 67
      tmp___5 = strcmp((char const   *)*(params + 1), "path");
      }
#line 67
      if (tmp___5 == 0) {
        {
#line 68
        bsdl_set_path(chain, (char const   *)*(params + 2));
#line 69
        result = 1;
        }
      }
      {
#line 72
      tmp___8 = strcmp((char const   *)*(params + 1), "debug");
      }
#line 72
      if (tmp___8 == 0) {
        {
#line 73
        tmp___6 = strcmp((char const   *)*(params + 2), "on");
        }
#line 73
        if (tmp___6 == 0) {
#line 74
          globs->debug = 1;
#line 75
          result = 1;
        }
        {
#line 77
        tmp___7 = strcmp((char const   *)*(params + 2), "off");
        }
#line 77
        if (tmp___7 == 0) {
#line 78
          globs->debug = 0;
#line 79
          result = 1;
        }
      }
    }
  }
#line 85
  return (result);
}
}
#line 89 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/bsdl.c"
static void cmd_bsdl_help(void) 
{ 
  char *tmp ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 92
  tmp = gettext("Usage: %s path PATHLIST\nUsage: %s test [FILE]\nUsage: %s dump [FILE]\nUsage: %s debug on|off\nManage BSDL files\n\nPATHLIST semicolon separated list of directory paths to search for BSDL files\nFILE file containing part description in BSDL format\n");
#line 92
  printf((char const   */* __restrict  */)tmp, "bsdl", "bsdl", "bsdl", "bsdl");
  }
#line 102
  return;
}
}
#line 104 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/bsdl.c"
cmd_t cmd_bsdl  =    {(char *)"bsdl", (char *)"manage BSDL files", & cmd_bsdl_help, & cmd_bsdl_run};
#line 34 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/bit.c"
static void cmd_bit_print_params(char **params , unsigned int parameters , char *command ) 
{ 
  unsigned int i ;
  char *__cil_tmp5 ;

  {
  {
#line 39
  strcpy((char */* __restrict  */)command, (char const   */* __restrict  */)*(params + 0));
#line 40
  i = 1U;
  }
  {
#line 40
  while (1) {
    while_continue: /* CIL Label */ ;
#line 40
    if (! (i < parameters)) {
#line 40
      goto while_break;
    }
    {
#line 41
    strcat((char */* __restrict  */)command, (char const   */* __restrict  */)" ");
#line 42
    strcat((char */* __restrict  */)command, (char const   */* __restrict  */)*(params + i));
#line 40
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 44
  return;
}
}
#line 46 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/bit.c"
static int cmd_bit_run(chain_t *chain , char **params ) 
{ 
  part_t *part ;
  data_register *bsr ;
  unsigned int bit ;
  int type ;
  int safe ;
  unsigned int control ;
  unsigned int parameters ;
  int tmp ;
  char command[1024] ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  size_t tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  size_t tmp___14 ;
  signal_t *tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  size_t tmp___22 ;
  int tmp___23 ;
  void *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;

  {
  {
#line 55
  tmp = cmd_params(params);
#line 55
  parameters = (unsigned int )tmp;
#line 58
  cmd_bit_print_params(params, parameters, command);
  }
#line 60
  if (parameters != 5U) {
#line 60
    if (parameters != 8U) {
      {
#line 61
      tmp___0 = gettext("%s: invalid number of parameters (%d) for command \'%s\'\n");
#line 61
      printf((char const   */* __restrict  */)tmp___0, "bit", parameters, command);
      }
#line 62
      return (-1);
    }
  }
  {
#line 65
  tmp___2 = cmd_test_cable(chain);
  }
#line 65
  if (! tmp___2) {
    {
#line 66
    tmp___1 = gettext("%s: cable test failed for command \'%s\'\n");
#line 66
    printf((char const   */* __restrict  */)tmp___1, "bit", command);
    }
#line 67
    return (1);
  }
#line 70
  if (! chain->parts) {
    {
#line 71
    tmp___3 = gettext("Run \"detect\" first.\n");
#line 71
    printf((char const   */* __restrict  */)tmp___3);
    }
#line 72
    return (1);
  }
#line 75
  if (chain->active_part >= (chain->parts)->len) {
    {
#line 76
    tmp___4 = gettext("%s: no active part\n");
#line 76
    printf((char const   */* __restrict  */)tmp___4, "bit");
    }
#line 77
    return (1);
  }
  {
#line 80
  part = *((chain->parts)->parts + chain->active_part);
#line 81
  bsr = part_find_data_register(part, "BSR");
  }
#line 82
  if ((unsigned long )bsr == (unsigned long )((void *)0)) {
    {
#line 83
    tmp___5 = gettext("%s: missing Boundary Scan Register (BSR) for command \'%s\'\n");
#line 83
    printf((char const   */* __restrict  */)tmp___5, "bit", command);
    }
#line 84
    return (1);
  }
  {
#line 88
  tmp___7 = cmd_get_number(*(params + 1), & bit);
  }
#line 88
  if (tmp___7) {
    {
#line 89
    tmp___6 = gettext("%s: unable to get boundary bit number for command \'%s\'\n");
#line 89
    printf((char const   */* __restrict  */)tmp___6, "bit", command);
    }
#line 90
    return (-1);
  }
#line 93
  if (bit >= (unsigned int )(bsr->in)->len) {
    {
#line 94
    tmp___8 = gettext("%s: invalid boundary bit number for command \'%s\'\n");
#line 94
    printf((char const   */* __restrict  */)tmp___8, "bit", command);
    }
#line 95
    return (1);
  }
#line 97
  if ((unsigned long )*(part->bsbits + bit) != (unsigned long )((void *)0)) {
    {
#line 98
    tmp___9 = gettext("%s: duplicate bit declaration for command \'%s\'\n");
#line 98
    printf((char const   */* __restrict  */)tmp___9, "bit", command);
    }
#line 99
    return (1);
  }
  {
#line 103
  tmp___11 = strlen((char const   *)*(params + 2));
  }
#line 103
  if (tmp___11 != 1U) {
    {
#line 104
    tmp___10 = gettext("%s: invalid bit type length for command \'%s\'\n");
#line 104
    printf((char const   */* __restrict  */)tmp___10, "bit", command);
    }
#line 105
    return (-1);
  }
  {
#line 109
  if ((int )*(*(params + 2) + 0) == 105) {
#line 109
    goto case_105;
  }
#line 109
  if ((int )*(*(params + 2) + 0) == 73) {
#line 109
    goto case_105;
  }
#line 113
  if ((int )*(*(params + 2) + 0) == 111) {
#line 113
    goto case_111;
  }
#line 113
  if ((int )*(*(params + 2) + 0) == 79) {
#line 113
    goto case_111;
  }
#line 117
  if ((int )*(*(params + 2) + 0) == 98) {
#line 117
    goto case_98;
  }
#line 117
  if ((int )*(*(params + 2) + 0) == 66) {
#line 117
    goto case_98;
  }
#line 121
  if ((int )*(*(params + 2) + 0) == 99) {
#line 121
    goto case_99;
  }
#line 121
  if ((int )*(*(params + 2) + 0) == 67) {
#line 121
    goto case_99;
  }
#line 125
  if ((int )*(*(params + 2) + 0) == 120) {
#line 125
    goto case_120;
  }
#line 125
  if ((int )*(*(params + 2) + 0) == 88) {
#line 125
    goto case_120;
  }
#line 128
  goto switch_default;
  case_105: /* CIL Label */ 
  case_73: /* CIL Label */ 
#line 110
  type = 1;
#line 111
  goto switch_break;
  case_111: /* CIL Label */ 
  case_79: /* CIL Label */ 
#line 114
  type = 2;
#line 115
  goto switch_break;
  case_98: /* CIL Label */ 
  case_66: /* CIL Label */ 
#line 118
  type = 5;
#line 119
  goto switch_break;
  case_99: /* CIL Label */ 
  case_67: /* CIL Label */ 
#line 122
  type = 3;
#line 123
  goto switch_break;
  case_120: /* CIL Label */ 
  case_88: /* CIL Label */ 
#line 126
  type = 4;
#line 127
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 129
  tmp___12 = gettext("%s: invalid bit type for command \'%s\'\n");
#line 129
  printf((char const   */* __restrict  */)tmp___12, "bit", command);
  }
#line 130
  return (-1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 134
  tmp___14 = strlen((char const   *)*(params + 3));
  }
#line 134
  if (tmp___14 != 1U) {
    {
#line 135
    tmp___13 = gettext("%s: invalid default value length for command \'%s\'\n");
#line 135
    printf((char const   */* __restrict  */)tmp___13, "bit", command);
    }
#line 136
    return (-1);
  }
#line 139
  if ((int )*(*(params + 3) + 0) == 49) {
#line 139
    safe = 1;
  } else {
#line 139
    safe = 0;
  }
  {
#line 140
  *((bsr->in)->data + bit) = (char )safe;
#line 143
  tmp___15 = part_find_signal(part, (char const   *)*(params + 4));
#line 143
  *(part->bsbits + bit) = bsbit_alloc((int )bit, (char const   *)*(params + 4), type,
                                      tmp___15, safe);
  }
#line 144
  if ((unsigned long )*(part->bsbits + bit) == (unsigned long )((void *)0)) {
    {
#line 145
    tmp___16 = gettext("%s: out of memory for command \'%s\'\n");
#line 145
    printf((char const   */* __restrict  */)tmp___16, "bit", command);
    }
#line 146
    return (1);
  }
  {
#line 150
  tmp___17 = cmd_params(params);
  }
#line 150
  if (tmp___17 == 5) {
#line 151
    return (1);
  }
  {
#line 154
  tmp___19 = cmd_get_number(*(params + 5), & control);
  }
#line 154
  if (tmp___19) {
    {
#line 155
    tmp___18 = gettext("%s: unable to get control bit number for command \'%s\'\n");
#line 155
    printf((char const   */* __restrict  */)tmp___18, "bit", command);
    }
#line 156
    return (-1);
  }
#line 158
  if (control >= (unsigned int )(bsr->in)->len) {
    {
#line 159
    tmp___20 = gettext("%s: invalid control bit number for command \'%s\'\n");
#line 159
    printf((char const   */* __restrict  */)tmp___20, "bit", command);
    }
#line 160
    return (1);
  }
  {
#line 162
  (*(part->bsbits + bit))->control = (int )control;
#line 165
  tmp___22 = strlen((char const   *)*(params + 6));
  }
#line 165
  if (tmp___22 != 1U) {
    {
#line 166
    tmp___21 = gettext("%s: invalid control value length for command \'%s\'\n");
#line 166
    printf((char const   */* __restrict  */)tmp___21, "bit", command);
    }
#line 167
    return (-1);
  }
#line 169
  if ((int )*(*(params + 6) + 0) == 49) {
#line 169
    (*(part->bsbits + bit))->control_value = 1;
  } else {
#line 169
    (*(part->bsbits + bit))->control_value = 0;
  }
  {
#line 172
  tmp___23 = strcasecmp((char const   *)*(params + 7), "Z");
  }
#line 172
  if (tmp___23) {
#line 173
    return (-1);
  }
#line 175
  (*(part->bsbits + bit))->control_state = -1;
#line 177
  return (1);
}
}
#line 180 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/bit.c"
static void cmd_bit_help(void) 
{ 
  char *tmp ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
#line 183
  tmp = gettext("Usage: %s NUMBER TYPE DEFAULT SIGNAL [CBIT CVAL CSTATE]\nDefine new BSR (Boundary Scan Register) bit for SIGNAL, with\nDEFAULT value.\n\nNUMBER        Bit number in the BSR\nTYPE          Bit type, valid values are I, O, B, C, and X\nDEFAULT       Default (safe) bit value, valid values are 1, 0, ?\nSIGNAL        Associated signal name\nCBIT          Control bit number\nCVAL          Control value\nCSTATE        Control state, valid state is only Z\n");
#line 183
  printf((char const   */* __restrict  */)tmp, "bit");
  }
#line 196
  return;
}
}
#line 198 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/bit.c"
cmd_t cmd_bit  =    {(char *)"bit", (char *)"define new BSR bit", & cmd_bit_help, & cmd_bit_run};
#line 34 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/addpart.c"
static int cmd_addpart_run(chain_t *chain , char **params ) 
{ 
  unsigned int len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp7 ;

  {
  {
#line 39
  tmp = cmd_params(params);
  }
#line 39
  if (tmp != 2) {
#line 40
    return (-1);
  }
  {
#line 42
  tmp___0 = cmd_get_number(*(params + 1), & len);
  }
#line 42
  if (tmp___0) {
#line 43
    return (-1);
  }
  {
#line 45
  tmp___1 = cmd_test_cable(chain);
  }
#line 45
  if (! tmp___1) {
#line 46
    return (1);
  }
  {
#line 48
  manual_add(chain, (int )len);
  }
#line 50
  if ((unsigned long )chain->parts == (unsigned long )((void *)0)) {
#line 51
    return (1);
  }
#line 53
  if ((chain->parts)->len == 0) {
    {
#line 54
    parts_free(chain->parts);
#line 55
    chain->parts = (parts_t *)((void *)0);
    }
  }
  {
#line 58
  parts_set_instruction(chain->parts, "BYPASS");
#line 59
  chain_shift_instructions(chain);
  }
#line 61
  return (1);
}
}
#line 65 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/addpart.c"
static void cmd_addpart_help(void) 
{ 
  char *tmp ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
#line 68
  tmp = gettext("Usage: %s IRLENGTH\nManually add a part to the end of the chain.\n\nIRLENGTH           instruction register length\n");
#line 68
  printf((char const   */* __restrict  */)tmp, "addpart");
  }
#line 74
  return;
}
}
#line 77 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/cmd/addpart.c"
cmd_t cmd_addpart  =    {(char *)"addpart", (char *)"manually adds parts on the JTAG chain", & cmd_addpart_help,
    & cmd_addpart_run};
#line 83 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *textdomain(char const   *__domainname ) ;
#line 87
extern  __attribute__((__nothrow__)) char *bindtextdomain(char const   *__domainname ,
                                                          char const   *__dirname ) ;
#line 566 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) getenv)(char const   *__name ) ;
#line 692 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t getuid(void) ;
#line 695
extern  __attribute__((__nothrow__)) __uid_t geteuid(void) ;
#line 73 "/usr/include/getopt.h"
extern int optind ;
#line 321 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) mkdir)(char const   *__path ,
                                                                                  __mode_t __mode ) ;
#line 175 "/usr/include/getopt.h"
extern  __attribute__((__nothrow__)) int getopt_long(int ___argc , char * const  *___argv ,
                                                     char const   *__shortopts , struct option  const  *__longopts ,
                                                     int *__longind ) ;
#line 125 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *setlocale(int __category , char const   *__locale ) ;
#line 58 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/jtag.c"
int debug_mode  =    0;
#line 59 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/jtag.c"
int big_endian  =    0;
#line 60 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/jtag.c"
int interactive  =    0;
#line 67 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/jtag.c"
static void jtag_create_jtagdir(void) 
{ 
  char *home ;
  char *tmp ;
  char *jdir ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 70
  tmp = getenv("HOME");
#line 70
  home = tmp;
  }
#line 73
  if (! home) {
#line 74
    return;
  }
  {
#line 76
  tmp___0 = strlen((char const   *)home);
#line 76
  tmp___1 = strlen(".jtag");
#line 76
  tmp___2 = malloc((tmp___0 + tmp___1) + 2U);
#line 76
  jdir = (char *)tmp___2;
  }
#line 77
  if (! jdir) {
#line 78
    return;
  }
  {
#line 80
  strcpy((char */* __restrict  */)jdir, (char const   */* __restrict  */)home);
#line 81
  strcat((char */* __restrict  */)jdir, (char const   */* __restrict  */)"/");
#line 82
  strcat((char */* __restrict  */)jdir, (char const   */* __restrict  */)".jtag");
#line 88
  mkdir((char const   *)jdir, (__mode_t )((((448 | (256 >> 3)) | (64 >> 3)) | ((256 >> 3) >> 3)) | ((64 >> 3) >> 3)));
#line 91
  free((void *)jdir);
  }
#line 92
  return;
}
}
#line 150 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/jtag.c"
static int jtag_readline_multiple_commands_support(chain_t *chain , char *line ) 
{ 
  int r ;
  char *nextcmd ;
  size_t tmp ;
  char *tmp___0 ;
  char *__cil_tmp7 ;

  {
#line 153
  nextcmd = line;
#line 155
  if (! line) {
#line 156
    return (1);
  } else {
    {
#line 155
    tmp = strlen((char const   *)line);
    }
#line 155
    if (! (tmp > 0U)) {
#line 156
      return (1);
    }
  }
  {
#line 158
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 159
    line = nextcmd;
#line 161
    nextcmd = strstr((char const   *)nextcmd, "::");
    }
#line 163
    if (nextcmd) {
#line 164
      tmp___0 = nextcmd;
#line 164
      nextcmd ++;
#line 164
      *tmp___0 = (char)0;
#line 165
      nextcmd ++;
      {
#line 166
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 166
        if (! ((int )*line == 58)) {
#line 166
          goto while_break___0;
        }
#line 166
        line ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 169
    r = jtag_parse_line(chain, line);
#line 171
    chain_flush(chain);
    }
#line 158
    if (nextcmd) {
#line 158
      if (! r) {
#line 158
        goto while_break;
      }
    } else {
#line 158
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 175
  return (r);
}
}
#line 178 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/jtag.c"
static void jtag_readline_loop(chain_t *chain , char const   *prompt ) 
{ 
  char line[1024] ;
  int tmp ;
  char *tmp___0 ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 225
  line[0] = (char)0;
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 228
    tmp = jtag_readline_multiple_commands_support(chain, line);
    }
#line 228
    if (! tmp) {
#line 229
      goto while_break;
    }
    {
#line 230
    printf((char const   */* __restrict  */)"%s", prompt);
#line 231
    fflush(stdout);
#line 226
    tmp___0 = fgets((char */* __restrict  */)(line), 1023, (FILE */* __restrict  */)stdin);
    }
#line 226
    if (! tmp___0) {
#line 226
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 235
  return;
}
}
#line 237 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/jtag.c"
static int jtag_parse_rc(chain_t *chain ) 
{ 
  char *home ;
  char *tmp ;
  char *file ;
  int go ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 240
  tmp = getenv("HOME");
#line 240
  home = tmp;
  }
#line 244
  if (! home) {
#line 245
    return (1);
  }
  {
#line 247
  tmp___0 = strlen((char const   *)home);
#line 247
  tmp___1 = strlen(".jtag");
#line 247
  tmp___2 = strlen("rc");
#line 247
  tmp___3 = malloc(((tmp___0 + tmp___1) + tmp___2) + 3U);
#line 247
  file = (char *)tmp___3;
  }
#line 248
  if (! file) {
#line 249
    return (1);
  }
  {
#line 251
  strcpy((char */* __restrict  */)file, (char const   */* __restrict  */)home);
#line 252
  strcat((char */* __restrict  */)file, (char const   */* __restrict  */)"/");
#line 253
  strcat((char */* __restrict  */)file, (char const   */* __restrict  */)".jtag");
#line 254
  strcat((char */* __restrict  */)file, (char const   */* __restrict  */)"/");
#line 255
  strcat((char */* __restrict  */)file, (char const   */* __restrict  */)"rc");
#line 257
  go = jtag_parse_file(chain, (char const   *)file);
#line 259
  free((void *)file);
  }
#line 261
  return (go);
}
}
#line 264 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/jtag.c"
static void cleanup(chain_t *chain ) 
{ 


  {
  {
#line 267
  cfi_array_free(cfi_array);
#line 268
  cfi_array = (cfi_array_t *)((void *)0);
  }
#line 270
  if (bus) {
    {
#line 271
    (*((bus->driver)->free_bus))(bus);
#line 272
    bus = (bus_t *)((void *)0);
    }
  }
  {
#line 274
  chain_free(chain);
#line 275
  chain = (chain_t *)((void *)0);
  }
#line 276
  return;
}
}
#line 278 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/jtag.c"
char const   *jtag_argv0  ;
#line 308
int main(int argc , char * const  *argv ) ;
#line 308 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/jtag.c"
static struct option long_options[6]  = {      {"version", 0, (int *)0, 'v'}, 
        {"norc", 0, (int *)0, 'n'}, 
        {"interactive", 0, (int *)0, 'i'}, 
        {"help", 0, (int *)0, 'h'}, 
        {"quiet", 0, (int *)0, 'q'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 279 "/home/wslee/benchmarks/embedded/urjtag-0.0+r1476/src/jtag.c"
int main(int argc , char * const  *argv ) 
{ 
  int go ;
  int i ;
  int c ;
  int norc ;
  int help ;
  int version ;
  int quiet ;
  chain_t *chain ;
  char *tmp ;
  __uid_t tmp___0 ;
  __uid_t tmp___1 ;
  int option_index ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  char const   *tmp___23 ;
  char *tmp___24 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;

  {
  {
#line 282
  go = 0;
#line 285
  norc = 0;
#line 286
  help = 0;
#line 287
  version = 0;
#line 288
  quiet = 0;
#line 289
  chain = (chain_t *)((void *)0);
#line 291
  jtag_argv0 = (char const   *)*(argv + 0);
#line 293
  tmp___0 = geteuid();
  }
#line 293
  if (tmp___0 == 0U) {
    {
#line 293
    tmp___1 = getuid();
    }
#line 293
    if (tmp___1 != 0U) {
      {
#line 295
      tmp = gettext("\'%s\' must not be run suid root!\n");
#line 295
      printf((char const   */* __restrict  */)tmp, "jtag");
      }
#line 296
      return (-1);
    }
  }
  {
#line 301
  setlocale(6, "");
#line 302
  bindtextdomain("urjtag", "/usr/local/share/locale");
#line 303
  textdomain("urjtag");
  }
  {
#line 306
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 319
    option_index = 0;
#line 321
    c = getopt_long(argc, argv, "vnhiq", (struct option  const  *)(long_options),
                    & option_index);
    }
#line 325
    if (c == -1) {
#line 326
      goto while_break;
    }
    {
#line 330
    if (c == 118) {
#line 330
      goto case_118;
    }
#line 334
    if (c == 110) {
#line 334
      goto case_110;
    }
#line 338
    if (c == 105) {
#line 338
      goto case_105;
    }
#line 347
    if (c == 113) {
#line 347
      goto case_113;
    }
#line 343
    goto switch_default;
    case_118: /* CIL Label */ 
#line 331
    version = 1;
#line 332
    goto switch_break;
    case_110: /* CIL Label */ 
#line 335
    norc = 1;
#line 336
    goto switch_break;
    case_105: /* CIL Label */ 
#line 339
    interactive = 1;
#line 340
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 344
    help = 1;
#line 345
    goto switch_break;
    case_113: /* CIL Label */ 
#line 348
    quiet = 1;
#line 349
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 353
  if (help) {
    {
#line 356
    tmp___2 = gettext("%s #%s\n");
#line 356
    printf((char const   */* __restrict  */)tmp___2, "UrJTAG 0.9", "1476");
#line 357
    printf((char const   */* __restrict  */)"\n");
#line 359
    tmp___3 = gettext("Usage: %s [OPTIONS] [FILE [FILE ... ]] \n");
#line 359
    printf((char const   */* __restrict  */)tmp___3, "jtag");
#line 360
    printf((char const   */* __restrict  */)"\n");
#line 362
    tmp___4 = gettext("  -h, --help          display this help and exit\n");
#line 362
    printf((char const   */* __restrict  */)tmp___4);
#line 363
    tmp___5 = gettext("  -v, --version       display version information and exit\n");
#line 363
    printf((char const   */* __restrict  */)tmp___5);
#line 364
    printf((char const   */* __restrict  */)"\n");
#line 365
    tmp___6 = gettext("  -n, --norc          disable reading ~/.jtag/rc on startup\n");
#line 365
    printf((char const   */* __restrict  */)tmp___6);
#line 366
    tmp___7 = gettext("  -i, --interactive   enter interactive mode after reading files\n");
#line 366
    printf((char const   */* __restrict  */)tmp___7);
#line 367
    tmp___8 = gettext("  -q, --quiet         Do not print help on startup\n");
#line 367
    printf((char const   */* __restrict  */)tmp___8);
#line 368
    printf((char const   */* __restrict  */)"\n");
#line 369
    tmp___9 = gettext("  [FILE]              file containing commands to execute\n");
#line 369
    printf((char const   */* __restrict  */)tmp___9);
#line 370
    printf((char const   */* __restrict  */)"\n");
#line 372
    tmp___10 = gettext("  Please report bugs at http://www.urjtag.org\n");
#line 372
    printf((char const   */* __restrict  */)tmp___10);
#line 374
    exit(0);
    }
  }
#line 377
  if (version) {
    {
#line 379
    tmp___11 = gettext("\n%s #%s\n\nCopyright (C) 2002, 2003 ETC s.r.o.\nCopyright (C) 2007, 2008 Kolja Waschk and the respective authors\n");
#line 379
    printf((char const   */* __restrict  */)tmp___11, "UrJTAG 0.9", "1476");
#line 384
    tmp___12 = gettext("\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n");
#line 384
    printf((char const   */* __restrict  */)tmp___12);
#line 399
    exit(0);
    }
  }
#line 403
  if (argc > optind) {
#line 404
    i = optind;
    {
#line 404
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 404
      if (! (i < argc)) {
#line 404
        goto while_break___0;
      }
      {
#line 405
      chain = chain_alloc();
      }
#line 406
      if (! chain) {
        {
#line 407
        tmp___13 = gettext("Out of memory\n");
#line 407
        printf((char const   */* __restrict  */)tmp___13);
        }
#line 408
        return (-1);
      }
      {
#line 411
      go = jtag_parse_file(chain, (char const   *)*(argv + i));
#line 412
      cleanup(chain);
      }
#line 413
      if (go < 0) {
        {
#line 414
        tmp___14 = gettext("Unable to open file `%s\'!\n");
#line 414
        printf((char const   */* __restrict  */)tmp___14, *(argv + i));
        }
#line 415
        goto while_break___0;
      }
#line 404
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 419
    if (! interactive) {
#line 419
      return (0);
    }
  }
  {
#line 423
  tmp___16 = isatty(0);
  }
#line 423
  if (! tmp___16) {
    {
#line 424
    chain = chain_alloc();
    }
#line 425
    if (! chain) {
      {
#line 426
      tmp___15 = gettext("Out of memory\n");
#line 426
      printf((char const   */* __restrict  */)tmp___15);
      }
#line 427
      return (-1);
    }
    {
#line 429
    jtag_parse_stream(chain, stdin);
#line 431
    cleanup(chain);
    }
#line 433
    return (0);
  }
#line 437
  if (! quiet) {
    {
#line 438
    tmp___17 = gettext("\n%s #%s\nCopyright (C) 2002, 2003 ETC s.r.o.\nCopyright (C) 2007, 2008 Kolja Waschk and the respective authors\n\n%s is free software, covered by the GNU General Public License, and you are\nwelcome to change it and/or distribute copies of it under certain conditions.\nThere is absolutely no warranty for %s.\n\n");
#line 438
    printf((char const   */* __restrict  */)tmp___17, "UrJTAG 0.9", "1476", "UrJTAG",
           "UrJTAG");
    }
  }
  {
#line 448
  chain = chain_alloc();
  }
#line 449
  if (! chain) {
    {
#line 450
    tmp___18 = gettext("Out of memory\n");
#line 450
    printf((char const   */* __restrict  */)tmp___18);
    }
#line 451
    return (-1);
  }
#line 454
  if (! quiet) {
    {
#line 455
    tmp___19 = gettext("WARNING: %s may damage your hardware!\n");
#line 455
    printf((char const   */* __restrict  */)tmp___19, "UrJTAG");
#line 456
    tmp___20 = gettext("Type \"quit\" to exit, \"help\" for help.\n\n");
#line 456
    printf((char const   */* __restrict  */)tmp___20);
    }
  }
  {
#line 460
  jtag_create_jtagdir();
  }
#line 463
  if (norc) {
#line 463
    go = 1;
  } else {
    {
#line 463
    tmp___21 = jtag_parse_rc(chain);
#line 463
    go = tmp___21;
    }
  }
#line 471
  if (go) {
    {
#line 479
    tmp___24 = getenv("JTAG_PROMPT");
#line 479
    tmp___23 = (char const   *)tmp___24;
    }
#line 479
    if (! tmp___23) {
#line 479
      tmp___23 = "jtag> ";
    }
    {
#line 479
    jtag_readline_loop(chain, tmp___23);
    }
  }
  {
#line 487
  cleanup(chain);
  }
#line 489
  return (0);
}
}
