/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 70 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 44 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/rsshconf.h"
struct __anonstruct_ShellOptions_t_28 {
   unsigned int shell_flags ;
   mode_t rssh_umask ;
   char *chroot_path ;
};
#line 44 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/rsshconf.h"
typedef struct __anonstruct_ShellOptions_t_28 ShellOptions_t;
#line 41 "/usr/include/wordexp.h"
struct __anonstruct_wordexp_t_26 {
   size_t we_wordc ;
   char **we_wordv ;
   size_t we_offs ;
};
#line 41 "/usr/include/wordexp.h"
typedef struct __anonstruct_wordexp_t_26 wordexp_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 42 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/rssh.h"
typedef char bool;
#line 43 "/usr/include/regex.h"
typedef unsigned long reg_syntax_t;
#line 368 "/usr/include/regex.h"
struct re_pattern_buffer {
   unsigned char *__buffer ;
   unsigned long __allocated ;
   unsigned long __used ;
   reg_syntax_t __syntax ;
   char *__fastmap ;
   unsigned char *__translate ;
   size_t re_nsub ;
   unsigned int __can_be_null : 1 ;
   unsigned int __regs_allocated : 2 ;
   unsigned int __fastmap_accurate : 1 ;
   unsigned int __no_sub : 1 ;
   unsigned int __not_bol : 1 ;
   unsigned int __not_eol : 1 ;
   unsigned int __newline_anchor : 1 ;
};
#line 434 "/usr/include/regex.h"
typedef struct re_pattern_buffer regex_t;
#line 437 "/usr/include/regex.h"
typedef int regoff_t;
#line 463 "/usr/include/regex.h"
struct __anonstruct_regmatch_t_30 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 463 "/usr/include/regex.h"
typedef struct __anonstruct_regmatch_t_30 regmatch_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 578
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) putenv)(char *__string ) ;
#line 563 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execv)(char const   *__path ,
                                                                                              char * const  *__argv ) ;
#line 675
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 34 "/usr/include/libgen.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) __xpg_basename)(char *__path ) ;
#line 110 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 312 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask ) ;
#line 52 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/rsshconf.h"
int read_shell_config(ShellOptions_t *opts , char const   *filename , int do_log ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/log.h"
char *log_make_ident(char const   *name ) ;
#line 35
void log_set_priority(int new_level ) ;
#line 36
void log_set_facility(int new_fac ) ;
#line 37
void log_open(void) ;
#line 39
void log_msg(char *msg  , ...) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/util.h"
void fail(int flags , int argc , char **argv ) ;
#line 36
char *check_command_line(char **cl , ShellOptions_t *opts ) ;
#line 37
char *get_command(char *cl , ShellOptions_t *opts ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/argvec.h"
char **build_arg_vector(char *str , size_t reserve ) ;
#line 75 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/main.c"
char **build_shell_args(struct passwd uinfo , ShellOptions_t *opts , char *cmdline ,
                        char **cmd ) ;
#line 77
void vers_info(void) ;
#line 82 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/main.c"
char *progname  ;
#line 83 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/main.c"
char *username  ;
#line 84 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/main.c"
char *version  =    (char *)"rssh 2.3.4";
#line 85 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/main.c"
char *copyr  =    (char *)"Copyright 2002-2010 Derek D. Martin <rssh-discuss at lists dot sourceforge dot net>";
#line 88 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/main.c"
int main(int argc , char **argv ) 
{ 
  char **argvec ;
  char *cmd ;
  ShellOptions_t opts ;
  struct passwd uinfo ;
  struct passwd *temp ;
  int tmp ;
  int tmp___0 ;
  __uid_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;

  {
#line 90
  argvec = (char **)((void *)0);
#line 97
  if (argc == 2) {
    {
#line 97
    tmp = strcmp((char const   *)*(argv + 1), "-v");
    }
#line 97
    if (! tmp) {
      {
#line 98
      vers_info();
#line 99
      exit(0);
      }
    }
  }
  {
#line 103
  opts.rssh_umask = (mode_t )18;
#line 104
  opts.shell_flags = 0U;
#line 105
  opts.chroot_path = (char *)((void *)0);
#line 106
  memset((void *)(& uinfo), 0, sizeof(uinfo));
#line 107
  tmp___0 = putenv((char *)"PATH=/bin:/usr/bin");
  }
#line 107
  if (tmp___0) {
    {
#line 108
    log_msg((char *)"fatal error: could not set PATH environment var");
#line 109
    exit(1);
    }
  }
  {
#line 113
  tmp___1 = getuid();
#line 113
  temp = getpwuid(tmp___1);
  }
#line 113
  if (temp) {
#line 114
    uinfo = *temp;
#line 115
    username = uinfo.pw_name;
  } else {
#line 119
    username = (char *)"unknown user!";
  }
  {
#line 120
  tmp___2 = __xpg_basename(*(argv + 0));
#line 120
  tmp___3 = log_make_ident((char const   *)tmp___2);
#line 120
  progname = strdup((char const   *)tmp___3);
#line 121
  log_set_facility(3 << 3);
#line 122
  log_open();
#line 125
  tmp___4 = read_shell_config(& opts, "/usr/local/etc/rssh.conf", 1);
  }
#line 125
  if (! tmp___4) {
    {
#line 126
    log_set_priority(3);
#line 127
    log_msg((char *)"there were errors processing configuration file!");
#line 128
    fail(0, argc, argv);
    }
  }
  {
#line 132
  umask(opts.rssh_umask);
  }
#line 135
  if (argc < 3) {
    {
#line 135
    fail((int )opts.shell_flags, argc, argv);
    }
  }
  {
#line 138
  tmp___5 = strcmp("-c", (char const   *)*(argv + 1));
  }
#line 138
  if (tmp___5) {
    {
#line 138
    fail((int )opts.shell_flags, argc, argv);
    }
  }
  {
#line 141
  argvec = build_shell_args(uinfo, & opts, *(argv + 2), & cmd);
  }
#line 141
  if (! argvec) {
    {
#line 142
    fail((int )opts.shell_flags, argc, argv);
    }
  }
  {
#line 145
  execv((char const   *)cmd, (char * const  *)argvec);
#line 148
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: execv() failed.  ",
          cmd);
#line 149
  log_set_priority(3);
#line 150
  log_msg((char *)"execv failed: cmd line %s", *(argv + 2));
#line 152
  tmp___6 = __errno_location();
  }
  {
#line 155
  if (*tmp___6 == 2) {
#line 155
    goto case_2;
  }
#line 155
  if (*tmp___6 == 20) {
#line 155
    goto case_2;
  }
#line 155
  if (*tmp___6 == 13) {
#line 155
    goto case_2;
  }
#line 160
  if (*tmp___6 == 1) {
#line 160
    goto case_1;
  }
#line 166
  goto switch_default;
  case_2: /* CIL Label */ 
  case_20: /* CIL Label */ 
  case_13: /* CIL Label */ 
  {
#line 156
  tmp___7 = __xpg_basename(*(argv + 0));
#line 156
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s is not an executable file, or permission denied.\n\n",
          tmp___7, *(argvec + 0));
  }
#line 159
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 162
  tmp___8 = __xpg_basename(*(argv + 0));
#line 162
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: FS mounted nosuid or process is being traced\n (and you are not root)\n\n",
          tmp___8);
  }
#line 165
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 167
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"an unknown error occurred.\n\n");
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 170
  exit(1);
  }
}
}
#line 174 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/main.c"
char **build_shell_args(struct passwd uinfo , ShellOptions_t *opts , char *cmdline ,
                        char **cmd ) 
{ 
  char **argvec ;
  char *temp ;
  int len ;
  char *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  void *tmp___10 ;
  char *tmp___11 ;

  {
  {
#line 187
  tmp = get_command(cmdline, opts);
#line 187
  *cmd = tmp;
  }
#line 187
  if (! tmp) {
#line 187
    return ((char **)((void *)0));
  }
#line 190
  if (opts->shell_flags & (unsigned int )(1 << 6)) {
    {
#line 201
    tmp___0 = malloc(6UL * sizeof(char *));
#line 201
    argvec = (char **)tmp___0;
    }
#line 201
    if (! argvec) {
      {
#line 202
      log_set_priority(3);
#line 203
      log_msg((char *)"OOM error in build_shell_args() (fatal)");
#line 204
      exit(1);
      }
    }
    {
#line 207
    *(argvec + 0) = (char *)"/usr/local/libexec/rssh_chroot_helper";
#line 210
    tmp___6 = strcmp((char const   *)*cmd, "/usr/bin/scp");
    }
#line 210
    if (tmp___6) {
      {
#line 212
      tmp___5 = strcmp((char const   *)*cmd, "/usr/lib/openssh/sftp-server");
      }
#line 212
      if (tmp___5) {
        {
#line 214
        tmp___4 = strcmp((char const   *)*cmd, "/usr/bin/cvs");
        }
#line 214
        if (tmp___4) {
          {
#line 216
          tmp___3 = strcmp((char const   *)*cmd, "/usr/bin/rdist");
          }
#line 216
          if (tmp___3) {
            {
#line 218
            tmp___2 = strcmp((char const   *)*cmd, "/usr/bin/rsync");
            }
#line 218
            if (tmp___2) {
              {
#line 220
              tmp___1 = strcmp((char const   *)*cmd, "/usr/bin/svnserve");
              }
#line 220
              if (tmp___1) {
                {
#line 223
                log_set_priority(3);
#line 224
                log_msg((char *)"fatal error identifying the correct command (this should never happen)");
#line 226
                exit(1);
                }
              } else {
#line 221
                *(argvec + 1) = (char *)"6";
              }
            } else {
#line 219
              *(argvec + 1) = (char *)"5";
            }
          } else {
#line 217
            *(argvec + 1) = (char *)"4";
          }
        } else {
#line 215
          *(argvec + 1) = (char *)"3";
        }
      } else {
#line 213
        *(argvec + 1) = (char *)"2";
      }
    } else {
#line 211
      *(argvec + 1) = (char *)"1";
    }
    {
#line 228
    *(argvec + 2) = cmdline;
#line 229
    *(argvec + 3) = (char *)((void *)0);
#line 232
    *cmd = (char *)"/usr/local/libexec/rssh_chroot_helper";
#line 235
    tmp___7 = strlen((char const   *)cmdline);
#line 235
    tmp___8 = strlen((char const   *)*(argvec + 2));
#line 235
    tmp___9 = strlen("/usr/local/libexec/rssh_chroot_helper");
#line 235
    len = (int )(((tmp___7 + tmp___8) + tmp___9) + 9UL);
#line 237
    tmp___10 = malloc((size_t )len);
#line 237
    temp = (char *)tmp___10;
    }
#line 237
    if (! temp) {
      {
#line 238
      log_set_priority(3);
#line 239
      log_msg((char *)"OOM error in build_shell_args() (fatal)");
#line 240
      exit(1);
      }
    }
    {
#line 244
    snprintf((char */* __restrict  */)temp, (size_t )len, (char const   */* __restrict  */)"%s %s \"%s\"",
             "/usr/local/libexec/rssh_chroot_helper", *(argvec + 1), cmdline);
#line 250
    log_set_priority(6);
#line 251
    log_msg((char *)"chroot cmd line: %s", temp);
    }
#line 253
    return (argvec);
  }
  {
#line 257
  argvec = build_arg_vector(cmdline, (size_t )0);
#line 258
  tmp___11 = check_command_line(argvec, opts);
  }
#line 258
  if (tmp___11) {
#line 258
    return (argvec);
  } else {
#line 259
    return ((char **)((void *)0));
  }
}
}
#line 262 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/main.c"
void vers_info(void) 
{ 


  {
  {
#line 264
  printf((char const   */* __restrict  */)"\n%s\n", version);
#line 265
  printf((char const   */* __restrict  */)"%s\n\n", copyr);
#line 266
  printf((char const   */* __restrict  */)"%20s = %s\n", "rssh config file", "/usr/local/etc/rssh.conf");
#line 267
  printf((char const   */* __restrict  */)"%20s = %s\n", "chroot helper path", "/usr/local/libexec/rssh_chroot_helper");
#line 268
  printf((char const   */* __restrict  */)"%20s = %s\n", "scp binary path", "/usr/bin/scp");
#line 269
  printf((char const   */* __restrict  */)"%20s = %s\n", "sftp server binary", "/usr/lib/openssh/sftp-server");
#line 270
  printf((char const   */* __restrict  */)"%20s = %s\n", "cvs binary path", "/usr/bin/cvs");
#line 271
  printf((char const   */* __restrict  */)"%20s = %s\n", "rdist binary path", "/usr/bin/rdist");
#line 272
  printf((char const   */* __restrict  */)"%20s = %s\n", "rsync binary path", "/usr/bin/rsync");
#line 273
  printf((char const   */* __restrict  */)"%20s = %s\n\n", "svnserve binary path",
         "/usr/bin/svnserve");
  }
#line 274
  return;
}
}
#line 62 "/usr/include/wordexp.h"
extern int wordexp(char const   * __restrict  __words , wordexp_t * __restrict  __pwordexp ,
                   int __flags ) ;
#line 70 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/argvec.c"
char **build_arg_vector(char *str , size_t reserve ) 
{ 
  wordexp_t result ;
  int retc ;

  {
  {
#line 80
  result.we_offs = reserve;
#line 81
  retc = wordexp((char const   */* __restrict  */)str, (wordexp_t */* __restrict  */)(& result),
                 5);
  }
#line 81
  if (retc) {
    {
#line 82
    log_set_priority(3);
    }
    {
#line 85
    if (retc == 4) {
#line 85
      goto case_4;
    }
#line 85
    if (retc == 2) {
#line 85
      goto case_4;
    }
#line 102
    if (retc == 1) {
#line 102
      goto case_1;
    }
#line 107
    if (retc == 3) {
#line 107
      goto case_3;
    }
#line 112
    if (retc == 5) {
#line 112
      goto case_5;
    }
#line 124
    goto switch_default;
    case_4: /* CIL Label */ 
    case_2: /* CIL Label */ 
    {
#line 86
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: bad characters in arguments\n",
            progname);
#line 88
    log_msg((char *)"user %s usedbad chars in command", username);
    }
#line 89
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 103
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: wordexp() allocation failed\n",
            progname);
#line 105
    log_msg((char *)"wordexp() allocation failed");
    }
#line 106
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 108
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: wordexp() bad value\n",
            progname);
#line 110
    log_msg((char *)"wordexp() bad value");
    }
#line 111
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 113
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: wordexp() bad syntax\n",
            progname);
#line 115
    log_msg((char *)"wordexp() bad syntax");
    }
#line 116
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 125
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error expanding arguments\n",
            progname);
#line 127
    log_msg((char *)"error expanding arguments for user %s", username);
#line 129
    log_msg((char *)"retc = %d (this shouldn\'t happen)", retc);
    }
    switch_break: /* CIL Label */ ;
    }
    {
#line 131
    exit(1);
    }
  }
#line 133
  return (result.we_wordv);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 390 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 175 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void closelog(void) ;
#line 181
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 190
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/log.h"
char *log_set_ident(char const   *name ) ;
#line 38
void log_close(void) ;
#line 59 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/log.c"
static char *ident  =    (char *)((void *)0);
#line 60 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/log.c"
static int facility  =    1 << 3;
#line 61 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/log.c"
static int level  =    4;
#line 68 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/log.c"
char *log_set_ident(char const   *name ) 
{ 


  {
#line 71
  if (ident) {
    {
#line 72
    free((void *)ident);
#line 73
    ident = (char *)((void *)0);
    }
  }
#line 75
  if (name) {
    {
#line 75
    ident = strdup(name);
    }
  }
#line 76
  return (ident);
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/log.c"
char *log_make_ident(char const   *name ) 
{ 
  char *temp ;
  char *tmp ;

  {
#line 90
  if (ident) {
    {
#line 91
    free((void *)ident);
#line 92
    ident = (char *)((void *)0);
    }
  }
#line 95
  if (! name) {
#line 95
    ident = (char *)((void *)0);
#line 95
    return (ident);
  }
  {
#line 96
  tmp = __xpg_basename((char *)name);
#line 96
  ident = strdup((char const   *)tmp);
  }
#line 98
  if ((int )*(ident + 0) == 45) {
    {
#line 99
    temp = strdup((char const   *)(ident + 1));
#line 100
    free((void *)ident);
#line 101
    ident = temp;
    }
  }
#line 103
  return (ident);
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/log.c"
void log_set_priority(int new_level ) 
{ 


  {
#line 109
  level = new_level;
#line 110
  return;
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/log.c"
void log_set_facility(int new_fac ) 
{ 


  {
#line 115
  facility = new_fac;
#line 116
  return;
}
}
#line 119 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/log.c"
void log_open(void) 
{ 


  {
  {
#line 121
  openlog((char const   *)ident, 3, facility);
  }
#line 122
  return;
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/log.c"
void log_close(void) 
{ 


  {
  {
#line 127
  closelog();
  }
#line 128
  return;
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/log.c"
void log_msg(char *msg  , ...) 
{ 
  char *format_temp ;
  va_list arglist ;
  int length ;
  int retc ;
  size_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 140
  format_temp = (char *)((void *)0);
#line 149
  tmp = strlen((char const   *)msg);
#line 149
  length = (int )(50UL + tmp);
#line 150
  tmp___0 = malloc((size_t )length);
#line 150
  format_temp = (char *)tmp___0;
  }
#line 150
  if ((unsigned long )format_temp == (unsigned long )((void *)0)) {
    {
#line 151
    syslog(3, "Could not allocate mem in log_msg(), log.c");
#line 152
    exit(1);
    }
  }
  {
#line 154
  memset((void *)format_temp, 0, (size_t )length);
#line 157
  __builtin_va_start(arglist, msg);
#line 158
  retc = vsnprintf((char */* __restrict  */)format_temp, (size_t )length, (char const   */* __restrict  */)msg,
                   arglist);
#line 159
  __builtin_va_end(arglist);
  }
#line 167
  if (retc > length) {
    {
#line 169
    tmp___1 = realloc((void *)format_temp, (size_t )(retc + 1));
#line 169
    format_temp = (char *)tmp___1;
    }
#line 169
    if ((unsigned long )format_temp == (unsigned long )((void *)0)) {
      {
#line 171
      syslog(3, "Could not allocate mem in log_msg(), log.c");
#line 173
      exit(1);
      }
    }
    {
#line 175
    __builtin_va_start(arglist, msg);
#line 176
    vsnprintf((char */* __restrict  */)format_temp, (size_t )(retc + 1), (char const   */* __restrict  */)msg,
              arglist);
#line 177
    __builtin_va_end(arglist);
    }
  }
  {
#line 180
  while (1) {
    while_continue: /* CIL Label */ ;
#line 180
    if (! (retc == -1)) {
#line 180
      goto while_break;
    }
    {
#line 181
    length += 50;
#line 182
    tmp___2 = realloc((void *)format_temp, (size_t )length);
#line 182
    format_temp = (char *)tmp___2;
    }
#line 182
    if ((unsigned long )format_temp == (unsigned long )((void *)0)) {
      {
#line 184
      syslog(3, "Could not allocate mem in log_msg(), log.c");
#line 186
      exit(1);
      }
    }
    {
#line 188
    memset((void *)format_temp, 0, (size_t )length);
#line 189
    __builtin_va_start(arglist, msg);
#line 190
    retc = vsnprintf((char */* __restrict  */)format_temp, (size_t )length, (char const   */* __restrict  */)msg,
                     arglist);
#line 191
    __builtin_va_end(arglist);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 193
  syslog(facility | level, "%s", format_temp);
#line 194
  free((void *)format_temp);
  }
#line 195
  return;
}
}
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/util.h"
int validate_umask(char const   *temp , int *mask ) ;
#line 40
int validate_access(char const   *temp , bool *allow_sftp , bool *allow_scp , bool *allow_cvs ,
                    bool *allow_rdist , bool *allow_rsync , bool *allow_svnserve ) ;
#line 67 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/rsshconf.c"
char const   *keywords[12]  = 
#line 67 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/rsshconf.c"
  {      "#",      "allowscp",      "allowsftp",      "allowcvs", 
        "allowrdist",      "allowrsync",      "allowsvnserve",      "chrootpath", 
        "logfacility",      "umask",      "user",      (char const   *)((void *)0)};
#line 82 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/rsshconf.c"
int log  =    0;
#line 85 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/rsshconf.c"
static bool got_user_config  =    (bool )0;
#line 89
int get_keyword(char const   *line , char *keyword , int *end ) ;
#line 90
int eat_char_token(char const   tokchar , char const   *line , bool colon , bool ign_spc ) ;
#line 92
int process_umask(ShellOptions_t *opts , char const   *line , int const   lineno ) ;
#line 93
int process_user(ShellOptions_t *opts , char const   *line , int const   lineno ) ;
#line 95
int process_allow_scp(ShellOptions_t *opts , char const   *line , int const   lineno ) ;
#line 98
int process_allow_sftp(ShellOptions_t *opts , char const   *line , int const   lineno ) ;
#line 101
int process_allow_cvs(ShellOptions_t *opts , char const   *line , int const   lineno ) ;
#line 104
int process_allow_rdist(ShellOptions_t *opts , char const   *line , int const   lineno ) ;
#line 107
int process_allow_rsync(ShellOptions_t *opts , char const   *line , int const   lineno ) ;
#line 110
int process_allow_svnserve(ShellOptions_t *opts , char const   *line , int const   lineno ) ;
#line 113
int get_token(char const   *str , char *buf , int const   buflen , bool const   colon ,
              bool const   ign_spc ) ;
#line 116
int process_config_line(ShellOptions_t *opts , FILE *cfg_file , char const   *line ,
                        int const   lineno ) ;
#line 119
int process_chroot_path(ShellOptions_t *opts , char const   *line , int const   lineno ) ;
#line 122
int process_log_facility(ShellOptions_t *opts , char const   *line , int const   lineno ) ;
#line 125
int get_asgn_param(char const   *line , int const   lineno , char *buf , int const   buflen ) ;
#line 132 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/rsshconf.c"
int read_shell_config(ShellOptions_t *opts , char const   *filename , int do_log ) 
{ 
  FILE *cfg_file ;
  int linenum ;
  int status ;
  char line[1025] ;
  int tmp ;
  char *tmp___0 ;

  {
  {
#line 136
  status = 1;
#line 139
  log = do_log;
#line 140
  memset((void *)(line), 0, (size_t )1025);
#line 141
  cfg_file = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 142
  if (! cfg_file) {
#line 143
    if (log) {
      {
#line 144
      log_set_priority(4);
#line 145
      log_msg((char *)"config file (%s) missing, using defaults", filename);
      }
    }
#line 148
    opts->shell_flags = 1U;
#line 149
    return (0);
  }
#line 151
  linenum = 0;
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 152
    if (! got_user_config) {
      {
#line 152
      tmp___0 = fgets((char */* __restrict  */)(line), 1024, (FILE */* __restrict  */)cfg_file);
      }
#line 152
      if (! tmp___0) {
#line 152
        goto while_break;
      }
    } else {
#line 152
      goto while_break;
    }
    {
#line 153
    linenum ++;
#line 154
    tmp = process_config_line(opts, cfg_file, (char const   *)(line), (int const   )linenum);
    }
#line 154
    if (! tmp) {
#line 155
      status = 0;
    }
    {
#line 156
    memset((void *)(line), 0, (size_t )1025);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 158
  fclose(cfg_file);
  }
#line 159
  return (status);
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/rsshconf.c"
int process_config_line(ShellOptions_t *opts , FILE *cfg_file , char const   *line ,
                        int const   lineno ) 
{ 
  char *newline ;
  char tmp[1025] ;
  char keywrd[61] ;
  int pos ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
  {
#line 174
  pos = 0;
#line 177
  newline = strchr(line, '\n');
  }
#line 177
  if (newline) {
#line 178
    *newline = (char )'\000';
  } else {
#line 181
    if (log) {
      {
#line 182
      log_set_priority(3);
#line 183
      log_msg((char *)"line %d: line too long", lineno);
      }
    }
    {
#line 185
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 185
      tmp___0 = fgets((char */* __restrict  */)(tmp), 1024, (FILE */* __restrict  */)cfg_file);
      }
#line 185
      if (! tmp___0) {
#line 185
        goto while_break;
      }
      {
#line 186
      newline = strchr(line, '\n');
      }
#line 186
      if (newline) {
#line 187
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 189
    return (0);
  }
  {
#line 194
  tmp___1 = get_keyword(line, keywrd, & pos);
  }
  {
#line 195
  if (tmp___1 == -1) {
#line 195
    goto case_neg_1;
  }
#line 198
  if (tmp___1 == 0) {
#line 198
    goto case_0;
  }
#line 201
  if (tmp___1 == 1) {
#line 201
    goto case_1;
  }
#line 206
  if (tmp___1 == 2) {
#line 206
    goto case_2;
  }
#line 211
  if (tmp___1 == 3) {
#line 211
    goto case_3;
  }
#line 216
  if (tmp___1 == 4) {
#line 216
    goto case_4;
  }
#line 221
  if (tmp___1 == 5) {
#line 221
    goto case_5;
  }
#line 226
  if (tmp___1 == 6) {
#line 226
    goto case_6;
  }
#line 231
  if (tmp___1 == 7) {
#line 231
    goto case_7;
  }
#line 236
  if (tmp___1 == 8) {
#line 236
    goto case_8;
  }
#line 241
  if (tmp___1 == 9) {
#line 241
    goto case_9;
  }
#line 246
  if (tmp___1 == 10) {
#line 246
    goto case_10;
  }
#line 251
  goto switch_default;
  case_neg_1: /* CIL Label */ 
#line 197
  return (1);
  case_0: /* CIL Label */ 
#line 200
  return (1);
  case_1: /* CIL Label */ 
  {
#line 203
  tmp___2 = process_allow_scp(opts, line + pos, lineno);
  }
#line 203
  if (! tmp___2) {
#line 204
    return (0);
  }
#line 205
  return (1);
  case_2: /* CIL Label */ 
  {
#line 208
  tmp___3 = process_allow_sftp(opts, line + pos, lineno);
  }
#line 208
  if (! tmp___3) {
#line 209
    return (0);
  }
#line 210
  return (1);
  case_3: /* CIL Label */ 
  {
#line 213
  tmp___4 = process_allow_cvs(opts, line + pos, lineno);
  }
#line 213
  if (! tmp___4) {
#line 214
    return (0);
  }
#line 215
  return (1);
  case_4: /* CIL Label */ 
  {
#line 218
  tmp___5 = process_allow_rdist(opts, line + pos, lineno);
  }
#line 218
  if (! tmp___5) {
#line 219
    return (0);
  }
#line 220
  return (1);
  case_5: /* CIL Label */ 
  {
#line 223
  tmp___6 = process_allow_rsync(opts, line + pos, lineno);
  }
#line 223
  if (! tmp___6) {
#line 224
    return (0);
  }
#line 225
  return (1);
  case_6: /* CIL Label */ 
  {
#line 228
  tmp___7 = process_allow_svnserve(opts, line + pos, lineno);
  }
#line 228
  if (! tmp___7) {
#line 229
    return (0);
  }
#line 230
  return (1);
  case_7: /* CIL Label */ 
  {
#line 233
  tmp___8 = process_chroot_path(opts, line + pos, lineno);
  }
#line 233
  if (! tmp___8) {
#line 234
    return (0);
  }
#line 235
  return (1);
  case_8: /* CIL Label */ 
  {
#line 238
  tmp___9 = process_log_facility(opts, line + pos, lineno);
  }
#line 238
  if (! tmp___9) {
#line 239
    return (0);
  }
#line 240
  return (1);
  case_9: /* CIL Label */ 
  {
#line 243
  tmp___10 = process_umask(opts, line + pos, lineno);
  }
#line 243
  if (! tmp___10) {
#line 244
    return (0);
  }
#line 245
  return (1);
  case_10: /* CIL Label */ 
  {
#line 248
  tmp___11 = process_user(opts, line + pos, lineno);
  }
#line 248
  if (! tmp___11) {
#line 249
    return (0);
  }
#line 250
  return (1);
  switch_default: /* CIL Label */ 
#line 253
  if (log) {
    {
#line 254
    log_set_priority(3);
#line 255
    log_msg((char *)"line %d: syntax error parsing config file", lineno);
    }
  }
#line 258
  if (keywrd[0]) {
#line 258
    if (log) {
      {
#line 259
      log_msg((char *)"unknown keyword: %s", keywrd);
      }
    }
  }
#line 260
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 263
  return (1);
}
}
#line 279 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/rsshconf.c"
int get_keyword(char const   *line , char *keyword , int *end ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 281
  i = 0;
#line 284
  memset((void *)keyword, 0, (size_t )61);
#line 287
  tmp = get_token(line, keyword, (int const   )61, (bool const   )0, (bool const   )0);
#line 287
  *end = tmp;
  }
#line 287
  if (! tmp) {
#line 288
    return (-1);
  }
  {
#line 289
  while (1) {
    while_continue: /* CIL Label */ ;
#line 289
    if (! ((unsigned long )keywords[i] != (unsigned long )((void *)0))) {
#line 289
      goto while_break;
    }
    {
#line 290
    tmp___0 = strncmp(keywords[i], (char const   *)keyword, (size_t )60);
    }
#line 290
    if (! tmp___0) {
#line 290
      return (i);
    }
#line 291
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 293
  return (-1);
}
}
#line 327 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/rsshconf.c"
int get_token(char const   *str , char *buf , int const   buflen , bool const   colon ,
              bool const   ign_spc ) 
{ 
  int line_len ;
  int len ;
  char *copy ;
  char *start ;
  char *end ;
  char *quote[2] ;
  int adjust ;
  int i ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;

  {
  {
#line 336
  adjust = 0;
#line 340
  memset((void *)buf, 0, (size_t )buflen);
#line 341
  copy = strdup(str);
  }
#line 341
  if (! copy) {
#line 342
    if (log) {
      {
#line 343
      log_set_priority(3);
#line 344
      log_msg((char *)"OOM error in get_token() (fatal)");
      }
    }
    {
#line 346
    exit(1);
    }
  }
  {
#line 348
  start = copy;
#line 349
  tmp = strlen((char const   *)copy);
#line 349
  line_len = (int )tmp;
  }
  {
#line 353
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 353
    tmp___0 = __ctype_b_loc();
    }
#line 353
    if (! ((int const   )*(*tmp___0 + (int )*start) & 8192)) {
#line 353
      goto while_break;
    }
#line 353
    start ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 354
  end = start;
#line 356
  if ((int )*start == 0) {
#line 356
    return (0);
  }
  {
#line 359
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 359
    if (! ((unsigned long )end <= (unsigned long )(copy + line_len))) {
#line 359
      goto while_break___0;
    }
#line 362
    if (! ign_spc) {
      {
#line 362
      tmp___1 = __ctype_b_loc();
      }
#line 362
      if ((int const   )*(*tmp___1 + (int )*end) & 8192) {
#line 363
        end --;
#line 364
        goto while_break___0;
      }
    }
#line 368
    if ((int )*end == 61) {
#line 368
      goto _L;
    } else
#line 368
    if ((int )*end == 35) {
#line 368
      goto _L;
    } else
#line 368
    if (colon) {
#line 368
      if ((int )*end == 58) {
        _L: /* CIL Label */ 
#line 370
        if ((unsigned long )end == (unsigned long )start) {
#line 370
          goto while_break___0;
        }
#line 372
        end --;
#line 373
        goto while_break___0;
      }
    }
#line 395
    if ((int )*end == 34) {
#line 395
      goto _L___0;
    } else
#line 395
    if ((int )*end == 39) {
      _L___0: /* CIL Label */ 
      {
#line 396
      quote[0] = end;
#line 397
      quote[1] = strchr((char const   *)(end + 1), (int )*end);
      }
#line 400
      if (! quote[1]) {
#line 400
        return (-1);
      }
#line 404
      len = (int )((quote[1] - quote[0]) - 1L);
#line 406
      i = 0;
      {
#line 406
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 406
        if (! (i < len)) {
#line 406
          goto while_break___1;
        }
#line 407
        *(quote[0] + i) = *((quote[0] + i) + 1);
#line 406
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 409
      len = (int )((copy - quote[1]) + (long )line_len);
#line 410
      i = 0;
      {
#line 410
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 410
        if (! (i < len)) {
#line 410
          goto while_break___2;
        }
#line 411
        *((quote[1] - 1) + i) = *((quote[1] + 1) + i);
#line 410
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 413
      line_len -= 2;
#line 415
      end = quote[1] - 2;
#line 417
      adjust += 2;
    }
#line 421
    end ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 425
  len = (int )((end + 1) - start);
#line 426
  if (len > (int )(buflen - 1)) {
#line 426
    tmp___2 = buflen - 1;
  } else {
#line 426
    tmp___2 = (int const   )len;
  }
  {
#line 426
  strncpy((char */* __restrict  */)buf, (char const   */* __restrict  */)start, (size_t )tmp___2);
#line 427
  free((void *)copy);
  }
#line 428
  return ((int )(((end + 1) + adjust) - copy));
}
}
#line 440 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/rsshconf.c"
int process_allow_scp(ShellOptions_t *opts , char const   *line , int const   lineno ) 
{ 
  int tmp ;

  {
  {
#line 444
  tmp = eat_char_token((char const   )'#', line, (bool )0, (bool )1);
  }
#line 444
  if (! tmp) {
#line 445
    if (log) {
      {
#line 445
      log_msg((char *)"line %d: syntax error parsing config file", lineno);
      }
    }
#line 447
    return (0);
  }
#line 449
  if (log) {
    {
#line 450
    log_set_priority(7);
#line 451
    log_msg((char *)"allowing scp to all users");
    }
  }
#line 453
  opts->shell_flags |= 1U;
#line 454
  return (1);
}
}
#line 465 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/rsshconf.c"
int process_allow_sftp(ShellOptions_t *opts , char const   *line , int const   lineno ) 
{ 
  int pos ;

  {
  {
#line 471
  pos = eat_char_token((char const   )'#', line, (bool )0, (bool )1);
  }
#line 471
  if (! pos) {
#line 472
    if (log) {
      {
#line 472
      log_msg((char *)"line %d: syntax error parsing config file", lineno);
      }
    }
#line 474
    return (0);
  }
#line 476
  if (log) {
    {
#line 477
    log_set_priority(7);
#line 478
    log_msg((char *)"allowing sftp to all users");
    }
  }
#line 480
  opts->shell_flags |= (unsigned int )(1 << 1);
#line 481
  return (1);
}
}
#line 493 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/rsshconf.c"
int process_allow_cvs(ShellOptions_t *opts , char const   *line , int const   lineno ) 
{ 
  int pos ;

  {
  {
#line 499
  pos = eat_char_token((char const   )'#', line, (bool )0, (bool )1);
  }
#line 499
  if (! pos) {
#line 500
    if (log) {
      {
#line 500
      log_msg((char *)"line %d: syntax error parsing config file", lineno);
      }
    }
#line 502
    return (0);
  }
#line 504
  if (log) {
    {
#line 505
    log_set_priority(7);
#line 506
    log_msg((char *)"allowing cvs to all users");
    }
  }
#line 508
  opts->shell_flags |= (unsigned int )(1 << 2);
#line 509
  return (1);
}
}
#line 521 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/rsshconf.c"
int process_allow_rdist(ShellOptions_t *opts , char const   *line , int const   lineno ) 
{ 
  int pos ;

  {
  {
#line 527
  pos = eat_char_token((char const   )'#', line, (bool )0, (bool )1);
  }
#line 527
  if (! pos) {
#line 528
    if (log) {
      {
#line 528
      log_msg((char *)"line %d: syntax error parsing config file", lineno);
      }
    }
#line 530
    return (0);
  }
  {
#line 532
  log_set_priority(7);
  }
#line 533
  if (log) {
    {
#line 534
    log_msg((char *)"allowing rdist to all users");
#line 535
    opts->shell_flags |= (unsigned int )(1 << 3);
    }
  }
#line 537
  return (1);
}
}
#line 549 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/rsshconf.c"
int process_allow_rsync(ShellOptions_t *opts , char const   *line , int const   lineno ) 
{ 
  int pos ;

  {
  {
#line 555
  pos = eat_char_token((char const   )'#', line, (bool )0, (bool )1);
  }
#line 555
  if (! pos) {
#line 556
    if (log) {
      {
#line 556
      log_msg((char *)"line %d: syntax error parsing config file", lineno);
      }
    }
#line 558
    return (0);
  }
#line 560
  if (log) {
    {
#line 561
    log_set_priority(7);
#line 562
    log_msg((char *)"allowing rsync to all users");
    }
  }
#line 564
  opts->shell_flags |= (unsigned int )(1 << 4);
#line 565
  return (1);
}
}
#line 577 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/rsshconf.c"
int process_allow_svnserve(ShellOptions_t *opts , char const   *line , int const   lineno ) 
{ 
  int pos ;

  {
  {
#line 583
  pos = eat_char_token((char const   )'#', line, (bool )0, (bool )1);
  }
#line 583
  if (! pos) {
#line 584
    if (log) {
      {
#line 584
      log_msg((char *)"line %d: syntax error parsing config file", lineno);
      }
    }
#line 586
    return (0);
  }
#line 588
  if (log) {
    {
#line 589
    log_set_priority(7);
#line 590
    log_msg((char *)"allowing svnserve to all users");
    }
  }
#line 592
  opts->shell_flags |= (unsigned int )(1 << 5);
#line 593
  return (1);
}
}
#line 597 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/rsshconf.c"
int process_chroot_path(ShellOptions_t *opts , char const   *line , int const   lineno ) 
{ 
  char *temp ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 612
  tmp = malloc((size_t )1025);
#line 612
  temp = (char *)tmp;
  }
#line 612
  if (! temp) {
#line 613
    if (log) {
      {
#line 613
      log_msg((char *)"fatal error: can\'t allocate space for chroot path");
      }
    }
    {
#line 614
    exit(1);
    }
  }
  {
#line 617
  tmp___0 = get_asgn_param(line, lineno, temp, (int const   )1025);
  }
#line 617
  if (! tmp___0) {
    {
#line 618
    free((void *)temp);
    }
#line 619
    return (0);
  }
#line 623
  if (opts->chroot_path) {
    {
#line 623
    free((void *)opts->chroot_path);
    }
  }
#line 624
  if (log) {
    {
#line 625
    log_set_priority(7);
#line 626
    log_msg((char *)"chrooting all users to %s", temp);
    }
  }
#line 629
  opts->chroot_path = temp;
#line 630
  opts->shell_flags |= (unsigned int )(1 << 6);
#line 631
  return (1);
}
}
#line 635 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/rsshconf.c"
int process_log_facility(ShellOptions_t *opts , char const   *line , int const   lineno ) 
{ 
  char *temp ;
  char *facname ;
  int fac ;
  int pos ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;

  {
  {
#line 640
  facname = (char *)((void *)0);
#line 641
  fac = 0;
#line 644
  tmp = malloc((size_t )1025);
#line 644
  temp = (char *)tmp;
  }
#line 644
  if (! temp) {
#line 645
    if (log) {
      {
#line 646
      log_set_priority(3);
#line 647
      log_msg((char *)"fatal error: can\'t allocate space for log facility");
      }
    }
    {
#line 649
    exit(1);
    }
  }
  {
#line 652
  pos = get_asgn_param(line, lineno, temp, (int const   )1025);
  }
#line 652
  if (! pos) {
    {
#line 653
    free((void *)temp);
    }
#line 654
    return (0);
  }
  {
#line 657
  tmp___0 = strncmp((char const   *)temp, "LOG_KERN", (size_t )1024);
  }
#line 657
  if (tmp___0) {
    {
#line 657
    tmp___1 = strncmp((char const   *)temp, "kern", (size_t )1024);
    }
#line 657
    if (! tmp___1) {
#line 659
      facname = (char *)"LOG_KERN";
#line 660
      fac = 0;
    }
  } else {
#line 659
    facname = (char *)"LOG_KERN";
#line 660
    fac = 0;
  }
  {
#line 665
  tmp___2 = strncmp((char const   *)temp, "LOG_USER", (size_t )1024);
  }
#line 665
  if (tmp___2) {
    {
#line 665
    tmp___3 = strncmp((char const   *)temp, "user", (size_t )1024);
    }
#line 665
    if (! tmp___3) {
#line 667
      facname = (char *)"LOG_USER";
#line 668
      fac = 1 << 3;
    }
  } else {
#line 667
    facname = (char *)"LOG_USER";
#line 668
    fac = 1 << 3;
  }
  {
#line 673
  tmp___4 = strncmp((char const   *)temp, "LOG_MAIL", (size_t )1024);
  }
#line 673
  if (tmp___4) {
    {
#line 673
    tmp___5 = strncmp((char const   *)temp, "mail", (size_t )1024);
    }
#line 673
    if (! tmp___5) {
#line 675
      facname = (char *)"LOG_MAIL";
#line 676
      fac = 2 << 3;
    }
  } else {
#line 675
    facname = (char *)"LOG_MAIL";
#line 676
    fac = 2 << 3;
  }
  {
#line 681
  tmp___6 = strncmp((char const   *)temp, "LOG_DAEMON", (size_t )1024);
  }
#line 681
  if (tmp___6) {
    {
#line 681
    tmp___7 = strncmp((char const   *)temp, "daemon", (size_t )1024);
    }
#line 681
    if (! tmp___7) {
#line 683
      facname = (char *)"LOG_DAEMON";
#line 684
      fac = 3 << 3;
    }
  } else {
#line 683
    facname = (char *)"LOG_DAEMON";
#line 684
    fac = 3 << 3;
  }
  {
#line 689
  tmp___8 = strncmp((char const   *)temp, "LOG_AUTH", (size_t )1024);
  }
#line 689
  if (tmp___8) {
    {
#line 689
    tmp___9 = strncmp((char const   *)temp, "auth", (size_t )1024);
    }
#line 689
    if (! tmp___9) {
#line 691
      facname = (char *)"LOG_AUTH";
#line 692
      fac = 4 << 3;
    }
  } else {
#line 691
    facname = (char *)"LOG_AUTH";
#line 692
    fac = 4 << 3;
  }
  {
#line 697
  tmp___10 = strncmp((char const   *)temp, "LOG_AUTHPRIV", (size_t )1024);
  }
#line 697
  if (tmp___10) {
    {
#line 697
    tmp___11 = strncmp((char const   *)temp, "authpriv", (size_t )1024);
    }
#line 697
    if (! tmp___11) {
#line 699
      facname = (char *)"LOG_AUTHPRIV";
#line 700
      fac = 10 << 3;
    }
  } else {
#line 699
    facname = (char *)"LOG_AUTHPRIV";
#line 700
    fac = 10 << 3;
  }
  {
#line 705
  tmp___12 = strncmp((char const   *)temp, "LOG_SYSLOG", (size_t )1024);
  }
#line 705
  if (tmp___12) {
    {
#line 705
    tmp___13 = strncmp((char const   *)temp, "syslog", (size_t )1024);
    }
#line 705
    if (! tmp___13) {
#line 707
      facname = (char *)"LOG_SYSLOG";
#line 708
      fac = 5 << 3;
    }
  } else {
#line 707
    facname = (char *)"LOG_SYSLOG";
#line 708
    fac = 5 << 3;
  }
  {
#line 713
  tmp___14 = strncmp((char const   *)temp, "LOG_LPR", (size_t )1024);
  }
#line 713
  if (tmp___14) {
    {
#line 713
    tmp___15 = strncmp((char const   *)temp, "lpr", (size_t )1024);
    }
#line 713
    if (! tmp___15) {
#line 715
      facname = (char *)"LOG_LPR";
#line 716
      fac = 6 << 3;
    }
  } else {
#line 715
    facname = (char *)"LOG_LPR";
#line 716
    fac = 6 << 3;
  }
  {
#line 721
  tmp___16 = strncmp((char const   *)temp, "LOG_NEWS", (size_t )1024);
  }
#line 721
  if (tmp___16) {
    {
#line 721
    tmp___17 = strncmp((char const   *)temp, "news", (size_t )1024);
    }
#line 721
    if (! tmp___17) {
#line 723
      facname = (char *)"LOG_NEWS";
#line 724
      fac = 7 << 3;
    }
  } else {
#line 723
    facname = (char *)"LOG_NEWS";
#line 724
    fac = 7 << 3;
  }
  {
#line 729
  tmp___18 = strncmp((char const   *)temp, "LOG_UUCP", (size_t )1024);
  }
#line 729
  if (tmp___18) {
    {
#line 729
    tmp___19 = strncmp((char const   *)temp, "uucp", (size_t )1024);
    }
#line 729
    if (! tmp___19) {
#line 731
      facname = (char *)"LOG_UUCP";
#line 732
      fac = 8 << 3;
    }
  } else {
#line 731
    facname = (char *)"LOG_UUCP";
#line 732
    fac = 8 << 3;
  }
  {
#line 737
  tmp___20 = strncmp((char const   *)temp, "LOG_CRON", (size_t )1024);
  }
#line 737
  if (tmp___20) {
    {
#line 737
    tmp___21 = strncmp((char const   *)temp, "cron", (size_t )1024);
    }
#line 737
    if (! tmp___21) {
#line 739
      facname = (char *)"LOG_CRON";
#line 740
      fac = 9 << 3;
    }
  } else {
#line 739
    facname = (char *)"LOG_CRON";
#line 740
    fac = 9 << 3;
  }
  {
#line 745
  tmp___22 = strncmp((char const   *)temp, "LOG_FTP", (size_t )1024);
  }
#line 745
  if (tmp___22) {
    {
#line 745
    tmp___23 = strncmp((char const   *)temp, "ftp", (size_t )1024);
    }
#line 745
    if (! tmp___23) {
#line 747
      facname = (char *)"LOG_FTP";
#line 748
      fac = 11 << 3;
    }
  } else {
#line 747
    facname = (char *)"LOG_FTP";
#line 748
    fac = 11 << 3;
  }
  {
#line 753
  tmp___24 = strncmp((char const   *)temp, "LOG_LOCAL0", (size_t )1024);
  }
#line 753
  if (tmp___24) {
    {
#line 753
    tmp___25 = strncmp((char const   *)temp, "local0", (size_t )1024);
    }
#line 753
    if (! tmp___25) {
#line 755
      facname = (char *)"LOG_LOCAL0";
#line 756
      fac = 16 << 3;
    }
  } else {
#line 755
    facname = (char *)"LOG_LOCAL0";
#line 756
    fac = 16 << 3;
  }
  {
#line 761
  tmp___26 = strncmp((char const   *)temp, "LOG_LOCAL1", (size_t )1024);
  }
#line 761
  if (tmp___26) {
    {
#line 761
    tmp___27 = strncmp((char const   *)temp, "local1", (size_t )1024);
    }
#line 761
    if (! tmp___27) {
#line 763
      facname = (char *)"LOG_LOCAL1";
#line 764
      fac = 17 << 3;
    }
  } else {
#line 763
    facname = (char *)"LOG_LOCAL1";
#line 764
    fac = 17 << 3;
  }
  {
#line 769
  tmp___28 = strncmp((char const   *)temp, "LOG_LOCAL2", (size_t )1024);
  }
#line 769
  if (tmp___28) {
    {
#line 769
    tmp___29 = strncmp((char const   *)temp, "local2", (size_t )1024);
    }
#line 769
    if (! tmp___29) {
#line 771
      facname = (char *)"LOG_LOCAL2";
#line 772
      fac = 18 << 3;
    }
  } else {
#line 771
    facname = (char *)"LOG_LOCAL2";
#line 772
    fac = 18 << 3;
  }
  {
#line 777
  tmp___30 = strncmp((char const   *)temp, "LOG_LOCAL3", (size_t )1024);
  }
#line 777
  if (tmp___30) {
    {
#line 777
    tmp___31 = strncmp((char const   *)temp, "local3", (size_t )1024);
    }
#line 777
    if (! tmp___31) {
#line 779
      facname = (char *)"LOG_LOCAL3";
#line 780
      fac = 19 << 3;
    }
  } else {
#line 779
    facname = (char *)"LOG_LOCAL3";
#line 780
    fac = 19 << 3;
  }
  {
#line 785
  tmp___32 = strncmp((char const   *)temp, "LOG_LOCAL4", (size_t )1024);
  }
#line 785
  if (tmp___32) {
    {
#line 785
    tmp___33 = strncmp((char const   *)temp, "local4", (size_t )1024);
    }
#line 785
    if (! tmp___33) {
#line 787
      facname = (char *)"LOG_LOCAL4";
#line 788
      fac = 20 << 3;
    }
  } else {
#line 787
    facname = (char *)"LOG_LOCAL4";
#line 788
    fac = 20 << 3;
  }
  {
#line 793
  tmp___34 = strncmp((char const   *)temp, "LOG_LOCAL5", (size_t )1024);
  }
#line 793
  if (tmp___34) {
    {
#line 793
    tmp___35 = strncmp((char const   *)temp, "local5", (size_t )1024);
    }
#line 793
    if (! tmp___35) {
#line 795
      facname = (char *)"LOG_LOCAL5";
#line 796
      fac = 21 << 3;
    }
  } else {
#line 795
    facname = (char *)"LOG_LOCAL5";
#line 796
    fac = 21 << 3;
  }
  {
#line 801
  tmp___36 = strncmp((char const   *)temp, "LOG_LOCAL6", (size_t )1024);
  }
#line 801
  if (tmp___36) {
    {
#line 801
    tmp___37 = strncmp((char const   *)temp, "local6", (size_t )1024);
    }
#line 801
    if (! tmp___37) {
#line 803
      facname = (char *)"LOG_LOCAL6";
#line 804
      fac = 22 << 3;
    }
  } else {
#line 803
    facname = (char *)"LOG_LOCAL6";
#line 804
    fac = 22 << 3;
  }
  {
#line 809
  tmp___38 = strncmp((char const   *)temp, "LOG_LOCAL7", (size_t )1024);
  }
#line 809
  if (tmp___38) {
    {
#line 809
    tmp___39 = strncmp((char const   *)temp, "local7", (size_t )1024);
    }
#line 809
    if (! tmp___39) {
#line 811
      facname = (char *)"LOG_LOCAL7";
#line 812
      fac = 23 << 3;
    }
  } else {
#line 811
    facname = (char *)"LOG_LOCAL7";
#line 812
    fac = 23 << 3;
  }
  {
#line 816
  free((void *)temp);
#line 817
  tmp___40 = eat_char_token((char const   )'#', line + pos, (bool )0, (bool )1);
  }
#line 817
  if (! tmp___40) {
#line 818
    if (log) {
      {
#line 818
      log_msg((char *)"line %d: syntax error parsing config file", lineno);
      }
    }
#line 820
    return (0);
  }
#line 822
  if (facname) {
    {
#line 823
    log_set_priority(7);
    }
#line 824
    if (log) {
      {
#line 824
      log_msg((char *)"setting log facility to %s", facname);
      }
    }
    {
#line 825
    log_set_facility(fac);
    }
#line 826
    return (1);
  }
#line 828
  if (log) {
    {
#line 829
    log_msg((char *)"line %d: unknown log facility specified", lineno);
#line 830
    log_set_facility(1 << 3);
    }
  }
#line 832
  return (0);
}
}
#line 836 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/rsshconf.c"
int process_umask(ShellOptions_t *opts , char const   *line , int const   lineno ) 
{ 
  char *temp ;
  int mask ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 843
  tmp = malloc((size_t )1025);
#line 843
  temp = (char *)tmp;
  }
#line 843
  if (! temp) {
#line 844
    if (log) {
      {
#line 845
      log_set_priority(3);
#line 846
      log_msg((char *)"fatal error: can\'t allocate space in process_umask()");
      }
    }
    {
#line 848
    exit(1);
    }
  }
  {
#line 851
  tmp___0 = get_asgn_param(line, lineno, temp, (int const   )1025);
  }
#line 851
  if (! tmp___0) {
    {
#line 852
    free((void *)temp);
    }
#line 853
    return (0);
  }
  {
#line 857
  tmp___1 = validate_umask((char const   *)temp, & mask);
  }
#line 857
  if (! tmp___1) {
#line 858
    if (log) {
      {
#line 859
      log_set_priority(4);
#line 860
      log_msg((char *)"line %d: invalid umask specified, using default 077", lineno);
      }
    }
    {
#line 863
    opts->rssh_umask = (mode_t )63;
#line 864
    free((void *)temp);
    }
#line 865
    return (0);
  }
#line 867
  if (log) {
    {
#line 868
    log_set_priority(7);
#line 869
    log_msg((char *)"setting umask to %#o", mask);
    }
  }
  {
#line 871
  opts->rssh_umask = (mode_t )mask;
#line 872
  free((void *)temp);
  }
#line 873
  return (1);
}
}
#line 876 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/rsshconf.c"
int process_user(ShellOptions_t *opts , char const   *line , int const   lineno ) 
{ 
  char *temp ;
  char user[1025] ;
  char mask[1025] ;
  char axs[1025] ;
  char *path ;
  int tmpmask ;
  int pos ;
  int len ;
  int optlen ;
  bool allow_scp ;
  bool allow_sftp ;
  bool allow_cvs ;
  bool allow_rdist ;
  bool allow_rsync ;
  bool allow_svnserve ;
  void *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  unsigned short const   **tmp___5 ;
  int tmp___6 ;

  {
  {
#line 884
  path = (char *)((void *)0);
#line 897
  tmp = malloc((size_t )1025);
#line 897
  temp = (char *)tmp;
  }
#line 897
  if (! temp) {
#line 898
    if (log) {
      {
#line 898
      log_msg((char *)"fatal error: can\'t allocate space for user options");
      }
    }
    {
#line 899
    exit(1);
    }
  }
  {
#line 903
  tmp___0 = get_asgn_param(line, lineno, temp, (int const   )1024);
  }
#line 903
  if (! tmp___0) {
    {
#line 904
    free((void *)temp);
    }
#line 905
    return (0);
  }
  {
#line 907
  tmp___1 = strlen((char const   *)temp);
#line 907
  optlen = (int )tmp___1;
#line 910
  pos = get_token((char const   *)temp, user, (int const   )1025, (bool const   )1,
                  (bool const   )1);
  }
#line 910
  if (! pos) {
#line 911
    if (log) {
      {
#line 912
      log_set_priority(3);
#line 913
      log_msg((char *)"syntax error parsing config file, line %d", lineno);
      }
    }
#line 916
    return (0);
  }
  {
#line 927
  tmp___2 = strcmp((char const   *)(user), (char const   *)username);
  }
#line 927
  if (tmp___2) {
#line 927
    return (1);
  }
#line 928
  if (log) {
    {
#line 929
    log_set_priority(7);
#line 930
    log_msg((char *)"line %d: configuring user %s", lineno, user);
    }
  }
  {
#line 932
  len = eat_char_token((char const   )':', (char const   *)(temp + pos), (bool )1,
                       (bool )0);
  }
#line 932
  if (! len) {
#line 933
    if (log) {
      {
#line 933
      log_msg((char *)"syntax error parsing config file: line %d ", lineno);
      }
    }
#line 935
    return (0);
  }
  {
#line 937
  pos += len;
#line 940
  len = get_token((char const   *)(temp + pos), mask, (int const   )1025, (bool const   )1,
                  (bool const   )0);
  }
#line 940
  if (! len) {
#line 942
    if (log) {
      {
#line 943
      log_set_priority(3);
#line 944
      log_msg((char *)"syntax error parsing user umask, line %d", lineno);
      }
    }
#line 946
    return (0);
  }
  {
#line 948
  pos += len;
#line 951
  len = eat_char_token((char const   )':', (char const   *)(temp + pos), (bool )1,
                       (bool )0);
  }
#line 951
  if (! len) {
#line 952
    if (log) {
      {
#line 952
      log_msg((char *)"syntax error parsing config file: line %d ", lineno);
      }
    }
#line 954
    return (0);
  }
  {
#line 956
  pos += len;
#line 957
  len = get_token((char const   *)(temp + pos), axs, (int const   )1025, (bool const   )1,
                  (bool const   )0);
  }
#line 957
  if (! len) {
#line 959
    if (log) {
      {
#line 960
      log_set_priority(3);
#line 961
      log_msg((char *)"syntax error parsing user access, line %d", lineno);
      }
    }
#line 963
    return (0);
  }
  {
#line 965
  tmp___3 = validate_access((char const   *)(axs), & allow_sftp, & allow_scp, & allow_cvs,
                            & allow_rdist, & allow_rsync, & allow_svnserve);
  }
#line 965
  if (! tmp___3) {
#line 967
    if (log) {
      {
#line 968
      log_set_priority(3);
#line 969
      log_msg((char *)"syntax error parsing access bits, line %d", lineno);
      }
    }
#line 971
    return (0);
  }
  {
#line 973
  pos += len;
#line 976
  len = eat_char_token((char const   )':', (char const   *)(temp + pos), (bool )1,
                       (bool )0);
  }
#line 976
  if (! len) {
#line 976
    goto cleanup;
  }
  {
#line 977
  pos += len;
#line 978
  tmp___4 = malloc((size_t )1025);
#line 978
  path = (char *)tmp___4;
  }
#line 978
  if (! path) {
#line 979
    if (log) {
      {
#line 979
      log_msg((char *)"fatal error: can\'t allocate space for chroot path");
      }
    }
    {
#line 980
    exit(1);
    }
  }
  {
#line 982
  len = get_token((char const   *)(temp + pos), path, (int const   )1025, (bool const   )1,
                  (bool const   )1);
  }
#line 982
  if (! len) {
    {
#line 984
    free((void *)path);
#line 985
    path = (char *)((void *)0);
    }
  }
#line 987
  pos += len;
  cleanup: 
  {
#line 991
  while (1) {
    while_continue: /* CIL Label */ ;
#line 991
    if ((int )*(temp + pos) != 0) {
      {
#line 991
      tmp___5 = __ctype_b_loc();
      }
#line 991
      if (! ((int const   )*(*tmp___5 + (int )*(temp + pos)) & 8192)) {
#line 991
        goto while_break;
      }
    } else {
#line 991
      goto while_break;
    }
#line 991
    pos ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 992
  if ((int )*(temp + pos) != 0) {
#line 993
    if (log) {
      {
#line 994
      log_set_priority(3);
#line 995
      log_msg((char *)"syntax error parsing user config: line %d", lineno);
      }
    }
#line 997
    return (0);
  }
  {
#line 1001
  tmp___6 = validate_umask((char const   *)(mask), & tmpmask);
  }
#line 1001
  if (! tmp___6) {
#line 1002
    if (log) {
      {
#line 1003
      log_set_priority(4);
#line 1004
      log_msg((char *)"line %d: invalid umask specified, using default", lineno);
      }
    }
#line 1007
    tmpmask = 63;
  }
#line 1009
  if (log) {
    {
#line 1010
    log_set_priority(7);
#line 1011
    log_msg((char *)"setting %s\'s umask to %#o", user, tmpmask);
    }
  }
#line 1013
  opts->rssh_umask = (mode_t )tmpmask;
#line 1018
  opts->shell_flags = 0U;
#line 1020
  if (allow_scp) {
#line 1021
    if (log) {
      {
#line 1021
      log_msg((char *)"allowing scp to user %s", user);
      }
    }
#line 1022
    opts->shell_flags |= 1U;
  }
#line 1024
  if (allow_sftp) {
#line 1025
    if (log) {
      {
#line 1025
      log_msg((char *)"allowing sftp to user %s", user);
      }
    }
#line 1026
    opts->shell_flags |= (unsigned int )(1 << 1);
  }
#line 1028
  if (allow_cvs) {
#line 1029
    if (log) {
      {
#line 1029
      log_msg((char *)"allowing cvs to user %s", user);
      }
    }
#line 1030
    opts->shell_flags |= (unsigned int )(1 << 2);
  }
#line 1032
  if (allow_rdist) {
#line 1033
    if (log) {
      {
#line 1033
      log_msg((char *)"allowing rdist to user %s", user);
      }
    }
#line 1034
    opts->shell_flags |= (unsigned int )(1 << 3);
  }
#line 1036
  if (allow_rsync) {
#line 1037
    if (log) {
      {
#line 1037
      log_msg((char *)"allowing rsync to user %s", user);
      }
    }
#line 1038
    opts->shell_flags |= (unsigned int )(1 << 4);
  }
#line 1040
  if (allow_svnserve) {
#line 1041
    if (log) {
      {
#line 1041
      log_msg((char *)"allowing svnserve to user %s", user);
      }
    }
#line 1042
    opts->shell_flags |= (unsigned int )(1 << 5);
  }
#line 1044
  if (path) {
#line 1045
    if (log) {
      {
#line 1045
      log_msg((char *)"chrooting %s to %s", user, path);
      }
    }
#line 1046
    opts->shell_flags |= (unsigned int )(1 << 6);
  }
#line 1048
  opts->chroot_path = path;
#line 1049
  got_user_config = (bool )1;
#line 1050
  return (1);
}
}
#line 1054 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/rsshconf.c"
int get_asgn_param(char const   *line , int const   lineno , char *buf , int const   buflen ) 
{ 
  int pos ;
  int len ;
  int tmp ;

  {
  {
#line 1063
  pos = eat_char_token((char const   )'=', line, (bool )0, (bool )1);
  }
#line 1063
  if (pos <= 0) {
#line 1064
    if (log) {
      {
#line 1065
      log_set_priority(3);
#line 1066
      log_msg((char *)"error parsing config file at line %d: assignment expected",
              lineno);
      }
    }
#line 1069
    return (0);
  }
  {
#line 1072
  len = get_token(line + pos, buf, buflen, (bool const   )0, (bool const   )0);
  }
#line 1072
  if (! len) {
#line 1073
    if (log) {
      {
#line 1074
      log_set_priority(3);
#line 1075
      log_msg((char *)"syntax error parsing config file, line %d", lineno);
      }
    }
#line 1078
    return (0);
  }
  {
#line 1080
  pos += len;
#line 1082
  tmp = eat_char_token((char const   )'#', line + pos, (bool )0, (bool )1);
  }
#line 1082
  if (! tmp) {
#line 1083
    if (log) {
      {
#line 1084
      log_set_priority(3);
#line 1085
      log_msg((char *)"syntax error parsing config file at line %d", lineno);
      }
    }
#line 1088
    return (0);
  }
#line 1090
  return (pos);
}
}
#line 1097 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/rsshconf.c"
int eat_char_token(char const   tokchar , char const   *line , bool colon , bool ign_spc ) 
{ 
  char token[1025] ;
  int pos ;

  {
  {
#line 1103
  pos = get_token(line, token, (int const   )1025, (bool const   )colon, (bool const   )ign_spc);
  }
#line 1103
  if (! pos) {
#line 1104
    return (-1);
  }
#line 1105
  if ((int )token[0] == (int )tokchar) {
#line 1105
    if ((int )token[1] == 0) {
#line 1105
      return (pos);
    }
  }
#line 1106
  return (0);
}
}
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 140
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 573 "/usr/include/regex.h"
extern int regcomp(regex_t * __restrict  __preg , char const   * __restrict  __pattern ,
                   int __cflags ) ;
#line 577
extern int regexec(regex_t const   * __restrict  __preg , char const   * __restrict  __string ,
                   size_t __nmatch , regmatch_t * __restrict  __pmatch , int __eflags ) ;
#line 585
extern void regfree(regex_t *__preg ) ;
#line 71 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/util.c"
void fail(int flags , int argc , char **argv ) 
{ 
  char *cmd ;
  int size ;
  void *tmp ;

  {
  {
#line 74
  size = 0;
#line 76
  log_set_priority(3);
  }
#line 79
  if (flags & 1) {
#line 79
    size += 4;
  }
#line 80
  if (flags & (1 << 1)) {
#line 80
    size += 5;
  }
#line 81
  if (flags & (1 << 2)) {
#line 81
    size += 4;
  }
#line 82
  if (flags & (1 << 3)) {
#line 82
    size += 6;
  }
#line 83
  if (flags & (1 << 4)) {
#line 83
    size += 6;
  }
#line 84
  if (flags & (1 << 5)) {
#line 84
    size += 8;
  }
#line 87
  if (! size) {
#line 87
    cmd = (char *)"This user is locked out.";
  } else {
    {
#line 89
    size += 19;
#line 90
    tmp = malloc((size_t )size);
#line 90
    cmd = (char *)tmp;
    }
#line 90
    if (! cmd) {
      {
#line 91
      log_msg((char *)"fatal error: out of mem allocating log msg");
#line 92
      exit(1);
      }
    }
    {
#line 94
    *(cmd + 0) = (char )'\000';
#line 95
    strncat((char */* __restrict  */)cmd, (char const   */* __restrict  */)"Allowed commands: ",
            (size_t )size);
    }
#line 96
    if (flags & 1) {
      {
#line 97
      strncat((char */* __restrict  */)cmd, (char const   */* __restrict  */)"scp ",
              (size_t )size);
      }
    }
#line 98
    if (flags & (1 << 1)) {
      {
#line 99
      strncat((char */* __restrict  */)cmd, (char const   */* __restrict  */)"sftp ",
              (size_t )size);
      }
    }
#line 100
    if (flags & (1 << 2)) {
      {
#line 101
      strncat((char */* __restrict  */)cmd, (char const   */* __restrict  */)"cvs ",
              (size_t )size);
      }
    }
#line 102
    if (flags & (1 << 3)) {
      {
#line 103
      strncat((char */* __restrict  */)cmd, (char const   */* __restrict  */)"rdist ",
              (size_t )size);
      }
    }
#line 104
    if (flags & (1 << 4)) {
      {
#line 105
      strncat((char */* __restrict  */)cmd, (char const   */* __restrict  */)"rsync ",
              (size_t )size);
      }
    }
#line 106
    if (flags & (1 << 5)) {
      {
#line 107
      strncat((char */* __restrict  */)cmd, (char const   */* __restrict  */)"svnserve",
              (size_t )size);
      }
    }
  }
  {
#line 111
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nThis account is restricted by rssh.\n%s\n\nIf you believe this is in error, please contact your system administrator.\n\n",
          cmd);
  }
#line 114
  if (argc < 3) {
    {
#line 115
    log_msg((char *)"user %s attempted to log in with a shell", username);
    }
  } else {
    {
#line 118
    log_msg((char *)"user %s attempted to execute forbidden commands", username);
#line 120
    log_msg((char *)"command: %s", *(argv + 2));
    }
  }
  {
#line 123
  exit(1);
  }
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/util.c"
bool opt_exist(char *cl , char opt ) 
{ 
  int i ;
  int len ;
  size_t tmp ;

  {
  {
#line 139
  i = 1;
#line 142
  tmp = strlen((char const   *)cl);
#line 142
  len = (int )tmp;
  }
#line 145
  if (! ((int )*(cl + 0) == 45)) {
#line 145
    return ((bool )0);
  }
  {
#line 146
  while (1) {
    while_continue: /* CIL Label */ ;
#line 146
    if (! (i < len)) {
#line 146
      goto while_break;
    }
#line 147
    if ((int )*(cl + i) == (int )opt) {
#line 147
      return ((bool )1);
    }
#line 148
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 150
  return ((bool )0);
}
}
#line 154 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/util.c"
bool opt_filter(char **vec , char const   opt ) 
{ 
  bool tmp ;

  {
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 156
    if (vec) {
#line 156
      if (! *vec) {
#line 156
        goto while_break;
      }
    } else {
#line 156
      goto while_break;
    }
    {
#line 157
    tmp = opt_exist(*vec, (char )opt);
    }
#line 157
    if (tmp) {
      {
#line 158
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nillegal insecure %c option",
              (int const   )opt);
#line 159
      log_msg((char *)"insecure %c option in command line!", (int const   )opt);
      }
#line 160
      return ((bool )1);
    }
#line 162
    vec ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 164
  return ((bool )0);
}
}
#line 168 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/util.c"
bool check_command(char *cl , ShellOptions_t *opts , char *cmd , int cmdflag ) 
{ 
  char *prog ;
  char *tmp ;
  bool need_free ;
  bool rc ;
  int i ;
  size_t len ;
  unsigned short const   **tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 171
  tmp = cl;
#line 172
  need_free = (bool )0;
#line 173
  rc = (bool )0;
#line 178
  if (opts->shell_flags & (unsigned int )cmdflag) {
    {
#line 180
    len = strlen((char const   *)cl);
#line 181
    i = 0;
    }
    {
#line 181
    while (1) {
      while_continue: /* CIL Label */ ;
#line 181
      if ((size_t )i < len) {
        {
#line 181
        tmp___0 = __ctype_b_loc();
        }
#line 181
        if ((int const   )*(*tmp___0 + (int )*(cl + i)) & 8192) {
#line 181
          goto while_break;
        }
      } else {
#line 181
        goto while_break;
      }
#line 181
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 182
    if ((size_t )i < len) {
      {
#line 183
      tmp___1 = malloc(sizeof(char ) * (unsigned long )(i + 1));
#line 183
      tmp = (char *)tmp___1;
      }
#line 183
      if (! tmp) {
        {
#line 184
        log_msg((char *)"malloc() failed in check_command()");
        }
#line 185
        return ((bool )0);
      }
      {
#line 187
      need_free = (bool )1;
#line 188
      memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)cl, (size_t )i);
#line 189
      *(tmp + i) = (char )'\000';
      }
    }
    {
#line 193
    prog = __xpg_basename(cmd);
#line 194
    tmp___2 = strcmp((char const   *)tmp, (char const   *)cmd);
    }
#line 194
    if (tmp___2) {
      {
#line 194
      tmp___3 = strcmp((char const   *)tmp, (char const   *)prog);
      }
#line 194
      if (! tmp___3) {
        {
#line 195
        log_msg((char *)"cmd \'%s\' approved", prog);
#line 196
        rc = (bool )1;
        }
      }
    } else {
      {
#line 195
      log_msg((char *)"cmd \'%s\' approved", prog);
#line 196
      rc = (bool )1;
      }
    }
  }
#line 199
  if (need_free) {
    {
#line 199
    free((void *)tmp);
    }
  }
#line 200
  return (rc);
}
}
#line 232
static int rsync_e_okay(char **vec ) ;
#line 232 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/util.c"
static char const   pattern[40]  = 
#line 232
  {      (char const   )'^',      (char const   )'-',      (char const   )'[',      (char const   )'a', 
        (char const   )'-',      (char const   )'d',      (char const   )'f',      (char const   )'-', 
        (char const   )'z',      (char const   )'A',      (char const   )'-',      (char const   )'Z', 
        (char const   )']',      (char const   )'*',      (char const   )'e',      (char const   )'[', 
        (char const   )'0',      (char const   )'-',      (char const   )'9',      (char const   )']', 
        (char const   )'*',      (char const   )'\\',      (char const   )'.',      (char const   )'[', 
        (char const   )'0',      (char const   )'-',      (char const   )'9',      (char const   )']', 
        (char const   )'*',      (char const   )'[',      (char const   )'a',      (char const   )'-', 
        (char const   )'z',      (char const   )'A',      (char const   )'-',      (char const   )'Z', 
        (char const   )']',      (char const   )'*',      (char const   )'$',      (char const   )'\000'};
#line 212 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/util.c"
static int rsync_e_okay(char **vec ) 
{ 
  regex_t re ;
  int server ;
  int e_found ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  bool tmp___7 ;

  {
#line 215
  server = 0;
#line 216
  e_found = 0;
#line 241
  if (vec) {
#line 241
    if (*(vec + 0)) {
#line 241
      if (*(vec + 1)) {
        {
#line 241
        tmp = strcmp((char const   *)*(vec + 1), "--server");
        }
#line 241
        if (tmp == 0) {
#line 242
          server = 1;
        }
      }
    }
  }
  {
#line 246
  tmp___0 = regcomp((regex_t */* __restrict  */)(& re), (char const   */* __restrict  */)(pattern),
                    1 | (((1 << 1) << 1) << 1));
  }
#line 246
  if (tmp___0 != 0) {
#line 247
    return (0);
  }
  {
#line 249
  while (1) {
    while_continue: /* CIL Label */ ;
#line 249
    if (vec) {
#line 249
      if (! *vec) {
#line 249
        goto while_break;
      }
    } else {
#line 249
      goto while_break;
    }
    {
#line 250
    tmp___1 = strcmp((char const   *)*vec, "--");
    }
#line 250
    if (tmp___1 == 0) {
#line 250
      goto while_break;
    }
    {
#line 251
    tmp___2 = strcmp((char const   *)*vec, "--rsh");
    }
#line 251
    if (tmp___2 == 0) {
      {
#line 253
      regfree(& re);
      }
#line 254
      return (0);
    } else {
      {
#line 251
      tmp___3 = strlen("--rsh=");
#line 251
      tmp___4 = strncmp((char const   *)*vec, "--rsh=", tmp___3);
      }
#line 251
      if (tmp___4 == 0) {
        {
#line 253
        regfree(& re);
        }
#line 254
        return (0);
      }
    }
    {
#line 256
    tmp___6 = strncmp((char const   *)*vec, "--", (size_t )2);
    }
#line 256
    if (tmp___6 != 0) {
      {
#line 256
      tmp___7 = opt_exist(*vec, (char )'e');
      }
#line 256
      if (tmp___7) {
        {
#line 257
        e_found = 1;
#line 258
        tmp___5 = regexec((regex_t const   */* __restrict  */)(& re), (char const   */* __restrict  */)*vec,
                          (size_t )0, (regmatch_t */* __restrict  */)((void *)0),
                          0);
        }
#line 258
        if (tmp___5 != 0) {
          {
#line 259
          regfree(& re);
          }
#line 260
          return (0);
        }
      }
    }
#line 263
    vec ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 265
  regfree(& re);
  }
#line 266
  if (e_found) {
#line 266
    if (! server) {
#line 266
      return (0);
    }
  }
#line 267
  return (1);
}
}
#line 278 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/util.c"
char *check_command_line(char **cl , ShellOptions_t *opts ) 
{ 
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;
  bool tmp___5 ;
  int tmp___6 ;
  bool tmp___7 ;
  int tmp___8 ;
  bool tmp___9 ;

  {
  {
#line 282
  tmp = check_command(*cl, opts, (char *)"/usr/lib/openssh/sftp-server", 1 << 1);
  }
#line 282
  if (tmp) {
#line 283
    return ((char *)"/usr/lib/openssh/sftp-server");
  }
  {
#line 285
  tmp___1 = check_command(*cl, opts, (char *)"/usr/bin/scp", 1);
  }
#line 285
  if (tmp___1) {
    {
#line 287
    tmp___0 = opt_filter(cl, (char const   )'S');
    }
#line 287
    if (tmp___0) {
#line 287
      return ((char *)((void *)0));
    }
#line 288
    return ((char *)"/usr/bin/scp");
  }
  {
#line 291
  tmp___3 = check_command(*cl, opts, (char *)"/usr/bin/cvs", 1 << 2);
  }
#line 291
  if (tmp___3) {
    {
#line 292
    tmp___2 = opt_filter(cl, (char const   )'e');
    }
#line 292
    if (tmp___2) {
#line 292
      return ((char *)((void *)0));
    }
#line 293
    return ((char *)"/usr/bin/cvs");
  }
  {
#line 296
  tmp___5 = check_command(*cl, opts, (char *)"/usr/bin/rdist", 1 << 3);
  }
#line 296
  if (tmp___5) {
    {
#line 298
    tmp___4 = opt_filter(cl, (char const   )'P');
    }
#line 298
    if (tmp___4) {
#line 298
      return ((char *)((void *)0));
    }
#line 299
    return ((char *)"/usr/bin/rdist");
  }
  {
#line 302
  tmp___7 = check_command(*cl, opts, (char *)"/usr/bin/rsync", 1 << 4);
  }
#line 302
  if (tmp___7) {
    {
#line 304
    tmp___6 = rsync_e_okay(cl);
    }
#line 304
    if (! tmp___6) {
      {
#line 305
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\ninsecure -e or --rsh option not allowed.");
#line 306
      log_msg((char *)"insecure -e or --rsh option in rsync command line!");
      }
#line 307
      return ((char *)((void *)0));
    }
#line 309
    return ((char *)"/usr/bin/rsync");
  }
  {
#line 311
  tmp___9 = check_command(*cl, opts, (char *)"/usr/bin/svnserve", 1 << 5);
  }
#line 311
  if (tmp___9) {
#line 313
    if ((unsigned long )*(cl + 1) == (unsigned long )((void *)0)) {
      {
#line 314
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nextra svnserver parameter(s) not allowed.");
#line 315
      log_msg((char *)"unallowed option(s) in svnserver command line!");
      }
#line 316
      return ((char *)((void *)0));
    } else {
      {
#line 313
      tmp___8 = strcmp((char const   *)*(cl + 1), "-t");
      }
#line 313
      if (tmp___8 != 0) {
        {
#line 314
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nextra svnserver parameter(s) not allowed.");
#line 315
        log_msg((char *)"unallowed option(s) in svnserver command line!");
        }
#line 316
        return ((char *)((void *)0));
      } else
#line 313
      if ((unsigned long )*(cl + 2) != (unsigned long )((void *)0)) {
        {
#line 314
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nextra svnserver parameter(s) not allowed.");
#line 315
        log_msg((char *)"unallowed option(s) in svnserver command line!");
        }
#line 316
        return ((char *)((void *)0));
      }
    }
#line 319
    return ((char *)"/usr/bin/svnserve");
  }
#line 322
  return ((char *)((void *)0));
}
}
#line 332 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/util.c"
char *get_command(char *cl , ShellOptions_t *opts ) 
{ 
  bool tmp ;
  bool tmp___0 ;
  bool tmp___1 ;
  bool tmp___2 ;
  bool tmp___3 ;
  bool tmp___4 ;

  {
  {
#line 335
  tmp = check_command(cl, opts, (char *)"/usr/lib/openssh/sftp-server", 1 << 1);
  }
#line 335
  if (tmp) {
#line 336
    return ((char *)"/usr/lib/openssh/sftp-server");
  }
  {
#line 337
  tmp___0 = check_command(cl, opts, (char *)"/usr/bin/scp", 1);
  }
#line 337
  if (tmp___0) {
#line 338
    return ((char *)"/usr/bin/scp");
  }
  {
#line 339
  tmp___1 = check_command(cl, opts, (char *)"/usr/bin/cvs", 1 << 2);
  }
#line 339
  if (tmp___1) {
#line 340
    return ((char *)"/usr/bin/cvs");
  }
  {
#line 341
  tmp___2 = check_command(cl, opts, (char *)"/usr/bin/rdist", 1 << 3);
  }
#line 341
  if (tmp___2) {
#line 342
    return ((char *)"/usr/bin/rdist");
  }
  {
#line 343
  tmp___3 = check_command(cl, opts, (char *)"/usr/bin/rsync", 1 << 4);
  }
#line 343
  if (tmp___3) {
#line 344
    return ((char *)"/usr/bin/rsync");
  }
  {
#line 345
  tmp___4 = check_command(cl, opts, (char *)"/usr/bin/svnserve", 1 << 5);
  }
#line 345
  if (tmp___4) {
#line 346
    return ((char *)"/usr/bin/svnserve");
  }
#line 347
  return ((char *)((void *)0));
}
}
#line 359 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/util.c"
char *extract_root(char *root , char *path ) 
{ 
  char *temp ;
  int len ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 364
  tmp = strlen((char const   *)root);
#line 364
  len = (int )tmp;
  }
#line 366
  if ((int )*(root + (len - 1)) == 47) {
#line 367
    *(root + (len - 1)) = (char )'\000';
#line 368
    len --;
  }
  {
#line 370
  tmp___0 = strncmp((char const   *)root, (char const   *)path, (size_t )len);
  }
#line 370
  if (tmp___0) {
#line 370
    return ((char *)((void *)0));
  }
#line 377
  if ((int )*(path + len) != 47) {
#line 377
    return ((char *)((void *)0));
  }
  {
#line 378
  temp = strdup((char const   *)(path + len));
  }
#line 378
  if (! temp) {
    {
#line 379
    log_set_priority(3);
#line 380
    log_msg((char *)"can\'t allocate memory in function extract_root()");
#line 381
    exit(1);
    }
  }
#line 383
  return (temp);
}
}
#line 392 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/util.c"
int validate_umask(char const   *temp , int *mask ) 
{ 
  char *err ;
  long tmp ;

  {
  {
#line 394
  err = (char *)((void *)0);
#line 397
  tmp = strtol((char const   */* __restrict  */)temp, (char **/* __restrict  */)(& err),
               8);
#line 397
  *mask = (int )tmp;
  }
#line 398
  if (*err) {
#line 398
    return (0);
  }
#line 400
  if (*mask < 0) {
#line 400
    return (0);
  } else
#line 400
  if (*mask > 511) {
#line 400
    return (0);
  }
#line 401
  return (1);
}
}
#line 411 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/util.c"
int validate_access(char const   *temp , bool *allow_sftp , bool *allow_scp , bool *allow_cvs ,
                    bool *allow_rdist , bool *allow_rsync , bool *allow_svnserve ) 
{ 
  int i ;
  size_t tmp ;

  {
  {
#line 419
  tmp = strlen(temp);
  }
#line 419
  if (tmp != 6UL) {
#line 419
    return (0);
  }
#line 421
  i = 0;
  {
#line 421
  while (1) {
    while_continue: /* CIL Label */ ;
#line 421
    if (! (i < 6)) {
#line 421
      goto while_break;
    }
#line 422
    if ((int const   )*(temp + i) < 48) {
#line 422
      return (0);
    } else
#line 422
    if ((int const   )*(temp + i) > 49) {
#line 422
      return (0);
    }
#line 421
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 424
  *allow_rsync = (bool )((int const   )*(temp + 0) - 48);
#line 425
  *allow_rdist = (bool )((int const   )*(temp + 1) - 48);
#line 426
  *allow_cvs = (bool )((int const   )*(temp + 2) - 48);
#line 427
  *allow_sftp = (bool )((int const   )*(temp + 3) - 48);
#line 428
  *allow_scp = (bool )((int const   )*(temp + 4) - 48);
#line 429
  *allow_svnserve = (bool )((int const   )*(temp + 5) - 48);
#line 430
  return (1);
}
}
#line 437 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/util.c"
char *get_username(void) 
{ 
  struct passwd *temp ;
  __uid_t tmp ;

  {
  {
#line 441
  tmp = getuid();
#line 441
  temp = getpwuid(tmp);
  }
#line 441
  if (! temp) {
#line 441
    return ((char *)"unknown user!");
  }
#line 442
  return (temp->pw_name);
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/log.c"
static char *ident___0  =    (char *)((void *)0);
#line 60 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/log.c"
static int facility___0  =    1 << 3;
#line 61 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/log.c"
static int level___0  =    4;
#line 85 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/rsshconf.c"
static bool got_user_config___0  =    (bool )0;
#line 232 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/util.c"
static int rsync_e_okay___0(char **vec ) ;
#line 232 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/util.c"
static char const   pattern___0[40]  = 
#line 232
  {      (char const   )'^',      (char const   )'-',      (char const   )'[',      (char const   )'a', 
        (char const   )'-',      (char const   )'d',      (char const   )'f',      (char const   )'-', 
        (char const   )'z',      (char const   )'A',      (char const   )'-',      (char const   )'Z', 
        (char const   )']',      (char const   )'*',      (char const   )'e',      (char const   )'[', 
        (char const   )'0',      (char const   )'-',      (char const   )'9',      (char const   )']', 
        (char const   )'*',      (char const   )'\\',      (char const   )'.',      (char const   )'[', 
        (char const   )'0',      (char const   )'-',      (char const   )'9',      (char const   )']', 
        (char const   )'*',      (char const   )'[',      (char const   )'a',      (char const   )'-', 
        (char const   )'z',      (char const   )'A',      (char const   )'-',      (char const   )'Z', 
        (char const   )']',      (char const   )'*',      (char const   )'$',      (char const   )'\000'};
#line 212 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/util.c"
static int rsync_e_okay___0(char **vec ) 
{ 
  regex_t re ;
  int server ;
  int e_found ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  bool tmp___7 ;

  {
#line 215
  server = 0;
#line 216
  e_found = 0;
#line 241
  if (vec) {
#line 241
    if (*(vec + 0)) {
#line 241
      if (*(vec + 1)) {
        {
#line 241
        tmp = strcmp((char const   *)*(vec + 1), "--server");
        }
#line 241
        if (tmp == 0) {
#line 242
          server = 1;
        }
      }
    }
  }
  {
#line 246
  tmp___0 = regcomp((regex_t */* __restrict  */)(& re), (char const   */* __restrict  */)(pattern___0),
                    1 | (((1 << 1) << 1) << 1));
  }
#line 246
  if (tmp___0 != 0) {
#line 247
    return (0);
  }
  {
#line 249
  while (1) {
    while_continue: /* CIL Label */ ;
#line 249
    if (vec) {
#line 249
      if (! *vec) {
#line 249
        goto while_break;
      }
    } else {
#line 249
      goto while_break;
    }
    {
#line 250
    tmp___1 = strcmp((char const   *)*vec, "--");
    }
#line 250
    if (tmp___1 == 0) {
#line 250
      goto while_break;
    }
    {
#line 251
    tmp___2 = strcmp((char const   *)*vec, "--rsh");
    }
#line 251
    if (tmp___2 == 0) {
      {
#line 253
      regfree(& re);
      }
#line 254
      return (0);
    } else {
      {
#line 251
      tmp___3 = strlen("--rsh=");
#line 251
      tmp___4 = strncmp((char const   *)*vec, "--rsh=", tmp___3);
      }
#line 251
      if (tmp___4 == 0) {
        {
#line 253
        regfree(& re);
        }
#line 254
        return (0);
      }
    }
    {
#line 256
    tmp___6 = strncmp((char const   *)*vec, "--", (size_t )2);
    }
#line 256
    if (tmp___6 != 0) {
      {
#line 256
      tmp___7 = opt_exist(*vec, (char )'e');
      }
#line 256
      if (tmp___7) {
        {
#line 257
        e_found = 1;
#line 258
        tmp___5 = regexec((regex_t const   */* __restrict  */)(& re), (char const   */* __restrict  */)*vec,
                          (size_t )0, (regmatch_t */* __restrict  */)((void *)0),
                          0);
        }
#line 258
        if (tmp___5 != 0) {
          {
#line 259
          regfree(& re);
          }
#line 260
          return (0);
        }
      }
    }
#line 263
    vec ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 265
  regfree(& re);
  }
#line 266
  if (e_found) {
#line 266
    if (! server) {
#line 266
      return (0);
    }
  }
#line 267
  return (1);
}
}
#line 497 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 678
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 700
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setuid)(__uid_t __uid ) ;
#line 944
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chroot)(char const   *__path ) ;
#line 413 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 81 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/rssh_chroot_helper.c"
static int log_init  =    0;
#line 86 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/rssh_chroot_helper.c"
void ch_start_logging(void) 
{ 
  __uid_t tmp ;

  {
#line 89
  if (log_init) {
#line 89
    return;
  }
  {
#line 90
  log_set_facility(1 << 3);
#line 91
  log_set_priority(6);
#line 92
  log_open();
#line 93
  tmp = getuid();
#line 93
  log_msg((char *)"new session for %s, UID=%d", username, tmp);
#line 95
  log_set_priority(3);
#line 96
  log_init = 1;
  }
#line 97
  return;
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/rssh-2.3.4/rssh_chroot_helper.c"
void ch_fatal_error(char *func , char *arg , char *strerr ) 
{ 
  __uid_t tmp ;
  __uid_t tmp___0 ;

  {
  {
#line 103
  tmp___0 = geteuid();
  }
#line 103
  if (! tmp___0) {
    {
#line 103
    tmp = getuid();
#line 103
    setuid(tmp);
    }
  }
  {
#line 104
  ch_start_logging();
#line 107
  log_msg((char *)"%s failed, %s: %s", func, arg, strerr);
#line 108
  log_close();
#line 109
  exit(1);
  }
}
}
