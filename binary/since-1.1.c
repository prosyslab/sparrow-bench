/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 128 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino64_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 92 "/usr/include/stdio.h"
typedef __off64_t off_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 50 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ino64_t ino_t;
#line 60 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __dev_t dev_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_13 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_13 __sigset_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_31 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_32 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_33 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_34 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_35 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_36 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_37 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_30 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_31 _kill ;
   struct __anonstruct__timer_32 _timer ;
   struct __anonstruct__rt_33 _rt ;
   struct __anonstruct__sigchld_34 _sigchld ;
   struct __anonstruct__sigfault_35 _sigfault ;
   struct __anonstruct__sigpoll_36 _sigpoll ;
   struct __anonstruct__sigsys_37 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_29 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_30 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_29 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_49 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_49 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 47 "/home/june/repo/benchmarks/collector/temp/since-1.1/since.c"
struct fmt_map {
   int f_bytes ;
   char *f_string ;
};
#line 52 "/home/june/repo/benchmarks/collector/temp/since-1.1/since.c"
struct data_file {
   int d_fd ;
   char *d_name ;
   dev_t d_dev ;
   ino_t d_ino ;
   off_t d_had ;
   off_t d_now ;
   off_t d_pos ;
   int d_offset ;
   int d_notify ;
   unsigned char d_jump : 1 ;
   unsigned char d_write : 1 ;
   unsigned char d_deleted : 1 ;
   unsigned char d_replaced : 1 ;
   unsigned char d_notable : 1 ;
   unsigned char d_moved : 1 ;
};
#line 70 "/home/june/repo/benchmarks/collector/temp/since-1.1/since.c"
struct since_state {
   int s_disk_device ;
   int s_disk_inode ;
   int s_disk_size ;
   int s_arch_device ;
   int s_arch_inode ;
   int s_arch_size ;
   char s_fmt[100] ;
   int s_fmt_used ;
   int s_fmt_output ;
   int s_fmt_prefix ;
   int s_error ;
   int s_readonly ;
   int s_verbose ;
   int s_relaxed ;
   int s_follow ;
   int s_discard ;
   struct timespec s_delay ;
   int s_atomic ;
   int s_domap ;
   int s_nozip ;
   char *s_name ;
   int s_fd ;
   int s_size ;
   char *s_buffer ;
   int s_ismap ;
   int s_add ;
   char *s_append ;
   struct data_file *s_data_files ;
   unsigned int s_data_count ;
   sigset_t s_set ;
   int s_notify ;
   FILE *s_header ;
};
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 180
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *__old ,
                                                                             char const   *__new ) ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 187
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 214
extern  __attribute__((__nothrow__)) unsigned long long ( __attribute__((__nonnull__(1),
__leaf__)) strtoull)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                     int __base ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 734
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) realpath)(char const   * __restrict  __name ,
                                                                                 char * __restrict  __resolved ) ;
#line 337 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off64_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                  __off64_t __offset ,
                                                                                  int __whence )  __asm__("lseek64")  ;
#line 353
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 675
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 149 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...)  __asm__("open64")  ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 215 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 218
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigfillset)(sigset_t *__set ) ;
#line 221
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigaddset)(sigset_t *__set ,
                                                                                                int __signo ) ;
#line 248
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigprocmask)(int __how ,
                                                                                  sigset_t const   * __restrict  __set ,
                                                                                  sigset_t * __restrict  __oset ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 334 "/usr/include/time.h"
extern int nanosleep(struct timespec  const  *__requested_time , struct timespec *__remaining ) ;
#line 110 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 61 "/usr/include/x86_64-linux-gnu/sys/mman.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) mmap)(void *__addr ,
                                                                             size_t __len ,
                                                                             int __prot ,
                                                                             int __flags ,
                                                                             int __fd ,
                                                                             __off64_t __offset )  __asm__("mmap64")  ;
#line 76
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) munmap)(void *__addr ,
                                                                             size_t __len ) ;
#line 217 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf )  __asm__("stat64")  ;
#line 220
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf )  __asm__("fstat64")  ;
#line 115 "/home/june/repo/benchmarks/collector/temp/since-1.1/since.c"
struct fmt_map fmt_table[5]  = {      {(int )sizeof(unsigned int ), (char *)"x"}, 
        {(int )sizeof(unsigned long ), (char *)"lx"}, 
        {(int )sizeof(unsigned long long ), (char *)"llx"}, 
        {(int )sizeof(unsigned short ), (char *)"hx"}, 
        {0, (char *)((void *)0)}};
#line 125
static void forget_state_file(struct since_state *sn ) ;
#line 126
static int tmp_state_file(struct since_state *sn , int (*call)(struct since_state *sn ) ) ;
#line 128 "/home/june/repo/benchmarks/collector/temp/since-1.1/since.c"
int volatile   since_run  =    (int volatile   )1;
#line 132 "/home/june/repo/benchmarks/collector/temp/since-1.1/since.c"
void handle_signal(int s ) 
{ 


  {
#line 134
  since_run = (int volatile   )0;
#line 135
  return;
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/since-1.1/since.c"
static void forget_state_file(struct since_state *sn ) 
{ 


  {
#line 139
  if (sn->s_buffer) {
#line 140
    if (sn->s_ismap) {
      {
#line 141
      munmap((void *)sn->s_buffer, (size_t )sn->s_size);
#line 142
      sn->s_ismap = 0;
      }
    } else {
      {
#line 144
      free((void *)sn->s_buffer);
      }
    }
#line 146
    sn->s_buffer = (char *)((void *)0);
  }
#line 148
  sn->s_size = 0;
#line 150
  if (sn->s_append) {
    {
#line 151
    free((void *)sn->s_append);
#line 152
    sn->s_append = (char *)((void *)0);
    }
  }
#line 154
  sn->s_add = 0;
#line 155
  return;
}
}
#line 157 "/home/june/repo/benchmarks/collector/temp/since-1.1/since.c"
static int tmp_state_file(struct since_state *sn , int (*call)(struct since_state *sn ) ) 
{ 
  char canon[4096] ;
  char tmp[4096] ;
  char *tptr ;
  int result ;
  int tfd ;
  int nfd ;
  int mode ;
  int flags ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  __pid_t tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;

  {
  {
#line 162
  tmp___2 = realpath((char const   */* __restrict  */)sn->s_name, (char */* __restrict  */)(canon));
  }
#line 162
  if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
    {
#line 163
    tmp___0 = __errno_location();
#line 163
    tmp___1 = strerror(*tmp___0);
#line 163
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"since: unable to establish true location of %s: %s\n",
            sn->s_name, tmp___1);
    }
#line 164
    return (-1);
  }
  {
#line 167
  tmp___3 = getpid();
#line 167
  result = snprintf((char */* __restrict  */)(tmp), (size_t )4096, (char const   */* __restrict  */)"%s.%d",
                    canon, tmp___3);
  }
#line 168
  if (result < 0) {
    {
#line 169
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"since: tmp file of %s exeeded limits\n",
            canon);
    }
#line 170
    return (-1);
  } else
#line 168
  if (result >= 4096) {
    {
#line 169
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"since: tmp file of %s exeeded limits\n",
            canon);
    }
#line 170
    return (-1);
  }
#line 173
  if (sn->s_verbose > 1) {
    {
#line 174
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"since: creating tmp file %s\n",
            tmp);
    }
  }
  {
#line 177
  mode = (384 | (128 >> 3)) | (256 >> 3);
#line 178
  flags = 194;
#line 180
  flags |= 131072;
#line 183
  nfd = open((char const   *)(tmp), flags, mode);
  }
#line 184
  if (nfd < 0) {
    {
#line 185
    tmp___4 = __errno_location();
#line 185
    tmp___5 = strerror(*tmp___4);
#line 185
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"since: unable to create tmp file %s: %s\n",
            tmp, tmp___5);
    }
#line 186
    return (-1);
  }
  {
#line 189
  tfd = sn->s_fd;
#line 190
  tptr = sn->s_name;
#line 192
  sn->s_fd = nfd;
#line 193
  sn->s_name = tmp;
#line 195
  result = (*call)(sn);
#line 197
  sn->s_fd = tfd;
#line 198
  sn->s_name = tptr;
  }
#line 200
  if (result < 0) {
    {
#line 201
    close(nfd);
#line 202
    unlink((char const   *)(tmp));
    }
  }
  {
#line 205
  tmp___8 = rename((char const   *)(tmp), (char const   *)sn->s_name);
  }
#line 205
  if (tmp___8) {
    {
#line 206
    tmp___6 = __errno_location();
#line 206
    tmp___7 = strerror(*tmp___6);
#line 206
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"since: unable to rename %s to %s: %s\n",
            tmp, sn->s_name, tmp___7);
#line 207
    close(nfd);
#line 208
    unlink((char const   *)(tmp));
    }
#line 209
    return (-1);
  }
  {
#line 212
  sn->s_fd = nfd;
#line 213
  close(tfd);
  }
#line 215
  return (0);
}
}
#line 220 "/home/june/repo/benchmarks/collector/temp/since-1.1/since.c"
static void init_state(struct since_state *sn ) 
{ 
  struct stat st ;

  {
#line 224
  sn->s_arch_device = (int )sizeof(st.st_dev);
#line 225
  sn->s_arch_inode = (int )sizeof(st.st_ino);
#line 226
  sn->s_arch_size = (int )sizeof(st.st_size);
#line 228
  sn->s_disk_device = sn->s_arch_device;
#line 229
  sn->s_disk_inode = sn->s_arch_inode;
#line 230
  sn->s_disk_size = sn->s_arch_size;
#line 232
  sn->s_fmt_used = 0;
#line 233
  sn->s_fmt_output = 0;
#line 234
  sn->s_fmt_prefix = 0;
#line 236
  sn->s_error = 0;
#line 237
  sn->s_readonly = 0;
#line 238
  sn->s_verbose = 1;
#line 239
  sn->s_relaxed = 0;
#line 240
  sn->s_follow = 0;
#line 241
  sn->s_discard = 0;
#line 242
  sn->s_delay.tv_sec = (__time_t )1;
#line 243
  sn->s_delay.tv_nsec = (__syscall_slong_t )0;
#line 244
  sn->s_atomic = 0;
#line 245
  sn->s_domap = 1;
#line 246
  sn->s_nozip = 0;
#line 248
  sn->s_name = (char *)((void *)0);
#line 249
  sn->s_fd = -1;
#line 251
  sn->s_size = 0;
#line 252
  sn->s_buffer = (char *)((void *)0);
#line 253
  sn->s_ismap = 0;
#line 255
  sn->s_add = 0;
#line 256
  sn->s_append = (char *)((void *)0);
#line 258
  sn->s_data_files = (struct data_file *)((void *)0);
#line 259
  sn->s_data_count = 0U;
#line 261
  sn->s_notify = -1;
#line 263
  sn->s_header = stdout;
#line 264
  return;
}
}
#line 266 "/home/june/repo/benchmarks/collector/temp/since-1.1/since.c"
void destroy_state(struct since_state *sn ) 
{ 
  int i ;
  struct data_file *df ;

  {
  {
#line 271
  forget_state_file(sn);
  }
#line 273
  if (sn->s_data_files) {
#line 274
    i = 0;
    {
#line 274
    while (1) {
      while_continue: /* CIL Label */ ;
#line 274
      if (! ((unsigned int )i < sn->s_data_count)) {
#line 274
        goto while_break;
      }
#line 275
      df = sn->s_data_files + i;
#line 276
      if (df->d_fd >= 0) {
        {
#line 277
        close(df->d_fd);
#line 278
        df->d_fd = -1;
        }
      }
#line 280
      df->d_offset = -1;
#line 274
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 282
    free((void *)sn->s_data_files);
#line 283
    sn->s_data_files = (struct data_file *)((void *)0);
    }
  }
#line 285
  sn->s_data_count = 0U;
#line 287
  if (sn->s_notify >= 0) {
    {
#line 288
    close(sn->s_notify);
#line 289
    sn->s_notify = -1;
    }
  }
#line 292
  if (sn->s_fd >= 0) {
    {
#line 293
    close(sn->s_fd);
#line 294
    sn->s_fd = -1;
    }
  }
#line 297
  if (sn->s_name) {
    {
#line 298
    free((void *)sn->s_name);
#line 299
    sn->s_name = (char *)((void *)0);
    }
  }
#line 301
  return;
}
}
#line 305 "/home/june/repo/benchmarks/collector/temp/since-1.1/since.c"
static int try_state_file(struct since_state *sn , char *path , char *append , int more ) 
{ 
  int flags ;
  int mode ;
  int plen ;
  int alen ;
  int result ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;

  {
#line 310
  if ((unsigned long )path == (unsigned long )((void *)0)) {
#line 311
    return (-1);
  }
#line 314
  if (append) {
    {
#line 315
    tmp___0 = strlen((char const   *)path);
#line 315
    plen = (int )tmp___0;
#line 316
    tmp___1 = strlen((char const   *)append);
#line 316
    alen = (int )tmp___1;
#line 317
    tmp___2 = malloc((size_t )((plen + alen) + 2));
#line 317
    tmp = (char *)tmp___2;
    }
#line 318
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
      {
#line 319
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"since: unable to allocate %d bytes\n",
              (plen + alen) + 2);
      }
#line 320
      return (-1);
    }
#line 322
    if (plen > 0) {
#line 322
      if ((int )*(path + (plen - 1)) == 47) {
#line 323
        plen --;
      }
    }
    {
#line 325
    strcpy((char */* __restrict  */)tmp, (char const   */* __restrict  */)path);
#line 326
    *(tmp + plen) = (char )'/';
#line 327
    strcpy((char */* __restrict  */)((tmp + plen) + 1), (char const   */* __restrict  */)append);
    }
  } else {
    {
#line 329
    tmp = strdup((char const   *)path);
    }
#line 330
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
      {
#line 331
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"since: unable to duplicate %s\n",
              path);
      }
#line 332
      return (-1);
    }
  }
#line 335
  sn->s_name = tmp;
#line 337
  if (sn->s_readonly) {
#line 337
    tmp___3 = 0;
  } else {
#line 337
    tmp___3 = 66;
  }
#line 337
  flags = tmp___3 | more;
#line 339
  mode = (384 | (128 >> 3)) | (256 >> 3);
#line 341
  if (sn->s_verbose > 2) {
    {
#line 342
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"since: attempting to open %s\n",
            sn->s_name);
    }
  }
  {
#line 345
  sn->s_fd = open((char const   *)sn->s_name, flags, mode);
  }
#line 346
  if (sn->s_fd >= 0) {
#line 347
    if (sn->s_verbose > 1) {
      {
#line 348
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"since: opened %s\n",
              sn->s_name);
      }
    }
#line 350
    return (0);
  }
  {
#line 353
  result = -1;
#line 355
  tmp___4 = __errno_location();
  }
#line 355
  if (*tmp___4 == 2) {
#line 356
    if (sn->s_readonly) {
#line 357
      result = 1;
    }
  }
#line 361
  if (result < 0) {
    {
#line 362
    tmp___5 = __errno_location();
#line 362
    tmp___6 = strerror(*tmp___5);
#line 362
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"since: unable to open %s: %s\n",
            sn->s_name, tmp___6);
    }
  }
  {
#line 365
  free((void *)sn->s_name);
#line 366
  sn->s_name = (char *)((void *)0);
  }
#line 368
  return (result);
}
}
#line 371 "/home/june/repo/benchmarks/collector/temp/since-1.1/since.c"
static int open_state_file(struct since_state *sn , char *name ) 
{ 
  char *ptr ;
  int more ;
  struct passwd *pw ;
  int result ;
  int tmp ;
  __uid_t tmp___0 ;

  {
#line 378
  if (name) {
    {
#line 379
    tmp = try_state_file(sn, name, (char *)((void *)0), 0);
    }
#line 379
    return (tmp);
  }
  {
#line 382
  ptr = getenv("SINCE");
#line 383
  result = try_state_file(sn, ptr, (char *)((void *)0), 0);
  }
#line 383
  if (result >= 0) {
#line 384
    return (result);
  }
  {
#line 387
  ptr = getenv("HOME");
  }
#line 388
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
    {
#line 389
    tmp___0 = getuid();
#line 389
    pw = getpwuid(tmp___0);
    }
#line 390
    if (pw) {
#line 391
      ptr = pw->pw_dir;
    }
  }
  {
#line 394
  result = try_state_file(sn, ptr, (char *)".since", 0);
  }
#line 394
  if (result >= 0) {
#line 395
    return (result);
  }
  {
#line 399
  more = 131072;
#line 403
  result = try_state_file(sn, (char *)"/tmp/since", (char *)((void *)0), more);
  }
#line 403
  if (result >= 0) {
#line 404
    if (sn->s_verbose > 0) {
      {
#line 405
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"since: using fallback %s\n",
              "/tmp/since");
      }
    }
#line 407
    return (result);
  }
  {
#line 410
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"since: unable to open any state file\n");
  }
#line 411
  return (-1);
}
}
#line 416 "/home/june/repo/benchmarks/collector/temp/since-1.1/since.c"
static int load_state_file(struct since_state *sn ) 
{ 
  struct stat st ;
  int prot ;
  int flags ;
  int rr ;
  unsigned int rt ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  ssize_t tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;

  {
#line 431
  sn->s_ismap = 0;
#line 433
  if (sn->s_fd < 0) {
#line 435
    return (1);
  }
  {
#line 438
  tmp___1 = fstat(sn->s_fd, & st);
  }
#line 438
  if (tmp___1) {
    {
#line 439
    tmp = __errno_location();
#line 439
    tmp___0 = strerror(*tmp);
#line 439
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"since: unable to stat %s: %s\n",
            sn->s_name, tmp___0);
    }
#line 440
    return (-1);
  }
#line 443
  sn->s_size = (int )st.st_size;
#line 444
  if (sn->s_size == 0) {
#line 445
    return (0);
  }
#line 448
  if (sn->s_domap) {
#line 450
    prot = 1;
#line 451
    if (! sn->s_readonly) {
#line 451
      prot |= 2;
    }
#line 452
    if (sn->s_atomic) {
#line 452
      flags = 2;
    } else {
#line 452
      flags = 1;
    }
    {
#line 453
    tmp___2 = mmap((void *)0, (size_t )sn->s_size, prot, flags, sn->s_fd, (__off64_t )0);
#line 453
    sn->s_buffer = (char *)tmp___2;
    }
#line 454
    if ((unsigned long )((void *)sn->s_buffer) != (unsigned long )((void *)-1)) {
#line 458
      sn->s_ismap = 1;
#line 459
      return (0);
    }
  }
  {
#line 463
  tmp___3 = malloc((size_t )sn->s_size);
#line 463
  sn->s_buffer = (char *)tmp___3;
  }
#line 464
  if ((unsigned long )sn->s_buffer == (unsigned long )((void *)0)) {
    {
#line 465
    tmp___4 = __errno_location();
#line 465
    tmp___5 = strerror(*tmp___4);
#line 465
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"since: unable to allocate %d bytes to load state file %s: %s\n",
            sn->s_size, sn->s_name, tmp___5);
    }
#line 466
    return (-1);
  }
#line 469
  rt = 0U;
  {
#line 469
  while (1) {
    while_continue: /* CIL Label */ ;
#line 469
    if (! (rt < (unsigned int )sn->s_size)) {
#line 469
      goto while_break;
    }
    {
#line 470
    tmp___6 = read(sn->s_fd, (void *)(sn->s_buffer + rt), (size_t )((unsigned int )sn->s_size - rt));
#line 470
    rr = (int )tmp___6;
    }
#line 471
    if (rr < 0) {
      {
#line 472
      tmp___7 = __errno_location();
      }
      {
#line 474
      if (*tmp___7 == 4) {
#line 474
        goto case_4;
      }
#line 474
      if (*tmp___7 == 11) {
#line 474
        goto case_4;
      }
#line 476
      goto switch_default;
      case_4: /* CIL Label */ 
      case_11: /* CIL Label */ 
#line 475
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 477
      tmp___8 = __errno_location();
#line 477
      tmp___9 = strerror(*tmp___8);
#line 477
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"since: read of %s failed after %d bytes: %s\n",
              sn->s_name, rt, tmp___9);
      }
#line 478
      return (-1);
      switch_break: /* CIL Label */ ;
      }
    }
#line 481
    if (rr == 0) {
      {
#line 482
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"since: premature end of %s: %d bytes outstanding\n",
              sn->s_name, (unsigned int )sn->s_size - rt);
      }
#line 483
      return (-1);
    }
#line 485
    rt += (unsigned int )rr;
  }
  while_break: /* CIL Label */ ;
  }
#line 492
  return (0);
}
}
#line 497 "/home/june/repo/benchmarks/collector/temp/since-1.1/since.c"
static int check_state_file(struct since_state *sn ) 
{ 
  int i ;
  int x ;
  int w ;
  int d ;
  int sep[3] ;
  unsigned short const   **tmp ;

  {
#line 501
  sep[0] = ':';
#line 502
  sep[1] = ':';
#line 503
  sep[2] = '\n';
#line 505
  if ((unsigned long )sn->s_buffer == (unsigned long )((void *)0)) {
#line 505
    goto _L;
  } else
#line 505
  if (sn->s_size == 0) {
    _L: /* CIL Label */ 
#line 506
    if (sn->s_verbose > 2) {
      {
#line 507
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"since: will not check an empty or nonexistant file\n");
      }
    }
#line 509
    return (1);
  }
#line 512
  w = 0;
#line 514
  i = 0;
#line 514
  x = 0;
  {
#line 514
  while (1) {
    while_continue: /* CIL Label */ ;
#line 514
    if (i < sn->s_size) {
#line 514
      if (! (x < 3)) {
#line 514
        goto while_break;
      }
    } else {
#line 514
      goto while_break;
    }
    {
#line 515
    tmp = __ctype_b_loc();
    }
#line 515
    if (! ((int const   )*(*tmp + (int )*(sn->s_buffer + i)) & 4096)) {
#line 517
      if ((int )*(sn->s_buffer + i) == sep[x]) {
#line 518
        d = i - w;
#line 519
        if (d % 2) {
          {
#line 520
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"since: data field has to contain an even number of bytes, not %d\n",
                  d);
          }
#line 521
          return (-1);
        }
#line 523
        d /= 2;
        {
#line 528
        if (x == 0) {
#line 528
          goto case_0;
        }
#line 529
        if (x == 1) {
#line 529
          goto case_1;
        }
#line 530
        if (x == 2) {
#line 530
          goto case_2;
        }
#line 527
        goto switch_break;
        case_0: /* CIL Label */ 
#line 528
        sn->s_disk_device = d;
#line 528
        goto switch_break;
        case_1: /* CIL Label */ 
#line 529
        sn->s_disk_inode = d;
#line 529
        goto switch_break;
        case_2: /* CIL Label */ 
#line 530
        sn->s_disk_size = d;
#line 530
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 532
        x ++;
#line 533
        w = i + 1;
      } else {
        {
#line 535
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"since: corrupt state file %s at %d\n",
                sn->s_name, i);
        }
#line 536
        return (-1);
      }
    }
#line 514
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 540
  if (x < 3) {
    {
#line 541
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"since: no fields within %d bytes in file %s\n",
            i, sn->s_name);
    }
#line 542
    return (-1);
  }
#line 545
  return (0);
}
}
#line 550 "/home/june/repo/benchmarks/collector/temp/since-1.1/since.c"
static int internal_upgrade_state_file(struct since_state *sn ) 
{ 
  char line[100] ;
  char *ptr ;
  int result ;
  int sw ;
  int sr ;
  int i ;
  int k ;
  int x ;
  int pad[3] ;
  int end[3] ;
  int sep[3] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  ssize_t tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  char const   *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  __off64_t tmp___8 ;

  {
#line 557
  if (sn->s_arch_device < sn->s_disk_device) {
#line 557
    tmp = 0;
  } else {
#line 557
    tmp = sn->s_arch_device - sn->s_disk_device;
  }
#line 557
  pad[0] = tmp * 2;
#line 558
  if (sn->s_arch_inode < sn->s_disk_inode) {
#line 558
    tmp___0 = 0;
  } else {
#line 558
    tmp___0 = sn->s_arch_inode - sn->s_disk_inode;
  }
#line 558
  pad[1] = tmp___0 * 2;
#line 559
  if (sn->s_arch_size < sn->s_disk_size) {
#line 559
    tmp___1 = 0;
  } else {
#line 559
    tmp___1 = sn->s_arch_size - sn->s_disk_size;
  }
#line 559
  pad[2] = tmp___1 * 2;
#line 561
  end[0] = sn->s_disk_device * 2;
#line 562
  end[1] = sn->s_disk_inode * 2;
#line 563
  end[2] = sn->s_disk_size * 2;
#line 565
  sep[0] = ':';
#line 566
  sep[1] = ':';
#line 567
  sep[2] = '\n';
#line 571
  sw = 0;
#line 572
  sr = 0;
#line 573
  x = 0;
  {
#line 573
  while (1) {
    while_continue: /* CIL Label */ ;
#line 573
    if (! (x < 3)) {
#line 573
      goto while_break;
    }
#line 574
    sw += (pad[x] + end[x]) + 1;
#line 575
    sr += end[x] + 1;
#line 573
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 583
  if (sw >= 100) {
    {
#line 584
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"since: major logic failure: want to rewrite to %d, limit at %d\n",
            sw, 100);
    }
#line 585
    return (-1);
  }
#line 588
  i = 0;
  {
#line 588
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 588
    if (! (i < sn->s_size)) {
#line 588
      goto while_break___0;
    }
#line 589
    ptr = sn->s_buffer + i;
#line 590
    k = 0;
#line 591
    x = 0;
    {
#line 591
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 591
      if (! (x < 3)) {
#line 591
        goto while_break___1;
      }
#line 592
      if (pad[x] > 0) {
        {
#line 593
        memset((void *)(line + k), '0', (size_t )pad[x]);
#line 594
        k += pad[x];
        }
      }
      {
#line 596
      memcpy((void */* __restrict  */)(line + k), (void const   */* __restrict  */)ptr,
             (size_t )end[x]);
      }
#line 597
      if ((int )*(ptr + end[x]) != sep[x]) {
        {
#line 598
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"since: data corruption: expected a separator, not 0x%x in line at %d in %s\n",
                (int )*(ptr + end[x]), i, sn->s_name);
        }
#line 599
        return (-1);
      }
#line 601
      k += end[x];
#line 602
      line[k] = (char )sep[x];
#line 603
      k ++;
#line 604
      ptr += end[x] + 1;
#line 591
      x ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 606
    tmp___2 = write(sn->s_fd, (void const   *)(line), (size_t )k);
#line 606
    result = (int )tmp___2;
    }
#line 607
    if (result != sw) {
#line 608
      if (result < 0) {
        {
#line 608
        tmp___3 = __errno_location();
#line 608
        tmp___4 = strerror(*tmp___3);
#line 608
        tmp___5 = (char const   *)tmp___4;
        }
      } else {
#line 608
        tmp___5 = "incomplete write";
      }
      {
#line 608
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"since: unable to write line to %s: %s\n",
              sn->s_name, tmp___5);
      }
#line 609
      return (-1);
    }
#line 588
    i += sr;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 613
  sn->s_disk_device += pad[0] / 2;
#line 614
  sn->s_disk_inode += pad[1] / 2;
#line 615
  sn->s_disk_size += pad[2] / 2;
#line 617
  tmp___8 = lseek(sn->s_fd, (__off64_t )0, 0);
  }
#line 617
  if (tmp___8 != 0L) {
    {
#line 618
    tmp___6 = __errno_location();
#line 618
    tmp___7 = strerror(*tmp___6);
#line 618
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"since: unable to rewind tmp file to start: %s\n",
            tmp___7);
    }
#line 619
    return (-1);
  }
#line 622
  return (0);
}
}
#line 625 "/home/june/repo/benchmarks/collector/temp/since-1.1/since.c"
static int maybe_upgrade_state_file(struct since_state *sn ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 627
  if (sn->s_disk_device >= sn->s_arch_device) {
#line 627
    if (sn->s_disk_inode >= sn->s_arch_inode) {
#line 627
      if (sn->s_disk_size >= sn->s_arch_size) {
#line 630
        if (sn->s_verbose > 4) {
          {
#line 631
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"since: state file data fields greater or equal to architecture, no rewrite needed\n");
          }
        }
#line 633
        return (0);
      }
    }
  }
#line 636
  if (sn->s_readonly) {
    {
#line 637
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"since: need to rewrite state file %s, but invoked as readonly\n",
            sn->s_name);
    }
#line 638
    return (-1);
  }
#line 641
  if ((unsigned long )sn->s_buffer == (unsigned long )((void *)0)) {
    {
#line 642
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"since: major logic failure, attempting to upgrade empty file\n");
    }
#line 643
    return (-1);
  } else
#line 641
  if (sn->s_size == 0) {
    {
#line 642
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"since: major logic failure, attempting to upgrade empty file\n");
    }
#line 643
    return (-1);
  }
  {
#line 646
  tmp = tmp_state_file(sn, & internal_upgrade_state_file);
  }
#line 646
  if (tmp) {
#line 647
    return (-1);
  }
  {
#line 650
  forget_state_file(sn);
#line 652
  tmp___0 = load_state_file(sn);
  }
#line 652
  return (tmp___0);
}
}
#line 657 "/home/june/repo/benchmarks/collector/temp/since-1.1/since.c"
static int make_fmt_field(struct since_state *sn , int disk , int arch , int suffix ) 
{ 
  int have ;
  int pad ;
  int i ;
  int result ;
  int tmp ;

  {
#line 661
  have = 100 - sn->s_fmt_used;
#line 663
  if (disk < arch) {
#line 664
    return (-1);
  }
#line 667
  if (disk > arch) {
#line 668
    pad = (disk - arch) * 2;
#line 669
    if (pad > have) {
#line 670
      return (-1);
    }
#line 672
    i = 0;
    {
#line 672
    while (1) {
      while_continue: /* CIL Label */ ;
#line 672
      if (! (i < pad)) {
#line 672
        goto while_break;
      }
#line 673
      tmp = sn->s_fmt_used;
#line 673
      (sn->s_fmt_used) ++;
#line 673
      sn->s_fmt[tmp] = (char )'0';
#line 672
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 675
    have -= pad;
  }
#line 678
  i = 0;
  {
#line 678
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 678
    if (! (fmt_table[i].f_bytes > 0)) {
#line 678
      goto while_break___0;
    }
#line 679
    if (fmt_table[i].f_bytes == arch) {
      {
#line 680
      result = snprintf((char */* __restrict  */)(sn->s_fmt + sn->s_fmt_used), (size_t )have,
                        (char const   */* __restrict  */)"%%0%d%s%c", arch * 2, fmt_table[i].f_string,
                        suffix);
      }
#line 681
      if (result < 0) {
#line 682
        return (-1);
      } else
#line 681
      if (result >= have) {
#line 682
        return (-1);
      }
#line 685
      sn->s_fmt_used += result;
#line 686
      return (0);
    }
#line 678
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 690
  return (-1);
}
}
#line 693 "/home/june/repo/benchmarks/collector/temp/since-1.1/since.c"
static int make_fmt_string(struct since_state *sn ) 
{ 
  int result ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 697
  sn->s_fmt_used = 0;
#line 698
  sn->s_fmt_output = 0;
#line 699
  sn->s_fmt_prefix = 0;
#line 701
  result = 0;
#line 703
  tmp = make_fmt_field(sn, sn->s_disk_device, sn->s_arch_device, ':');
#line 703
  result += tmp;
#line 704
  tmp___0 = make_fmt_field(sn, sn->s_disk_inode, sn->s_arch_inode, ':');
#line 704
  result += tmp___0;
#line 706
  tmp___1 = make_fmt_field(sn, sn->s_disk_size, sn->s_arch_size, '\000');
#line 706
  result += tmp___1;
  }
#line 708
  if (result) {
    {
#line 709
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"since: internal logic failure generating format string\n");
    }
#line 710
    return (-1);
  }
#line 717
  sn->s_fmt_prefix = (2 * sn->s_disk_device + 1) + 2 * sn->s_disk_inode;
#line 718
  sn->s_fmt_output = (sn->s_fmt_prefix + 1) + 2 * sn->s_disk_size;
#line 720
  if (sn->s_fmt_output + 1 >= 100) {
    {
#line 721
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"since: oversize fields: limit=%d, wanted=%d\n",
            100, sn->s_fmt_output + 1);
    }
#line 722
    return (-1);
  }
#line 725
  return (0);
}
}
#line 730 "/home/june/repo/benchmarks/collector/temp/since-1.1/since.c"
static char *ignore_suffix[5]  = {      (char *)".gz",      (char *)".bz2",      (char *)".Z",      (char *)".zip", 
        (char *)((void *)0)};
#line 732 "/home/june/repo/benchmarks/collector/temp/since-1.1/since.c"
static int setup_data(struct since_state *sn , char *name ) 
{ 
  struct data_file *tmp ;
  struct stat st ;
  int fd ;
  int i ;
  char *suffix ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;

  {
#line 739
  if (sn->s_nozip) {
    {
#line 740
    suffix = strrchr((char const   *)name, '.');
    }
#line 741
    if (suffix) {
#line 742
      i = 0;
      {
#line 742
      while (1) {
        while_continue: /* CIL Label */ ;
#line 742
        if (! ignore_suffix[i]) {
#line 742
          goto while_break;
        }
        {
#line 743
        tmp___0 = strcmp((char const   *)suffix, (char const   *)ignore_suffix[i]);
        }
#line 743
        if (! tmp___0) {
#line 744
          if (sn->s_verbose > 4) {
            {
#line 745
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"since: not displaying presumed compressed file %s\n",
                    name);
            }
          }
#line 747
          return (0);
        }
#line 742
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 753
  fd = open((char const   *)name, 0);
  }
#line 754
  if (fd < 0) {
    {
#line 755
    tmp___1 = __errno_location();
#line 755
    tmp___2 = strerror(*tmp___1);
#line 755
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"since: unable to open %s: %s\n",
            name, tmp___2);
    }
#line 756
    return (1);
  }
  {
#line 759
  tmp___5 = fstat(fd, & st);
  }
#line 759
  if (tmp___5) {
    {
#line 760
    tmp___3 = __errno_location();
#line 760
    tmp___4 = strerror(*tmp___3);
#line 760
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"since: unable to fstat %s: %s\n",
            name, tmp___4);
    }
#line 761
    return (1);
  }
#line 764
  if (! (32768U & st.st_mode)) {
    {
#line 765
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"since: unable to handle special file %s\n",
            name);
    }
#line 766
    return (1);
  }
  {
#line 769
  tmp___6 = realloc((void *)sn->s_data_files, sizeof(struct data_file ) * (unsigned long )(sn->s_data_count + 1U));
#line 769
  tmp = (struct data_file *)tmp___6;
  }
#line 770
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 771
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"since: unable to allocate %u bytes for %s\n",
            sizeof(struct data_file ) * (unsigned long )sn->s_data_count, name);
    }
#line 772
    return (-1);
  }
#line 775
  sn->s_data_files = tmp;
#line 776
  tmp = sn->s_data_files + sn->s_data_count;
#line 777
  (sn->s_data_count) ++;
#line 779
  tmp->d_name = name;
#line 780
  tmp->d_fd = fd;
#line 782
  tmp->d_dev = st.st_dev;
#line 783
  tmp->d_ino = st.st_ino;
#line 785
  tmp->d_had = (off_t )0;
#line 786
  tmp->d_now = st.st_size;
#line 787
  tmp->d_pos = (off_t )0;
#line 789
  tmp->d_write = (unsigned char)0;
#line 790
  tmp->d_jump = (unsigned char)0;
#line 791
  tmp->d_deleted = (unsigned char)0;
#line 792
  tmp->d_replaced = (unsigned char)0;
#line 793
  tmp->d_moved = (unsigned char)0;
#line 794
  tmp->d_notable = (unsigned char)1;
#line 796
  tmp->d_offset = -1;
#line 797
  tmp->d_notify = -1;
#line 799
  return (0);
}
}
#line 804 "/home/june/repo/benchmarks/collector/temp/since-1.1/since.c"
static int lookup_entries(struct since_state *sn ) 
{ 
  char line[100] ;
  char *end ;
  int i ;
  int j ;
  int result ;
  struct data_file *df ;
  unsigned long long tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
#line 810
  if ((unsigned long )sn->s_buffer == (unsigned long )((void *)0)) {
#line 811
    return (0);
  } else
#line 810
  if (sn->s_size == 0) {
#line 811
    return (0);
  }
#line 815
  i = 0;
  {
#line 815
  while (1) {
    while_continue: /* CIL Label */ ;
#line 815
    if (! ((unsigned int )i < sn->s_data_count)) {
#line 815
      goto while_break;
    }
    {
#line 816
    df = sn->s_data_files + i;
#line 817
    result = snprintf((char */* __restrict  */)(line), (size_t )100, (char const   */* __restrict  */)(sn->s_fmt),
                      df->d_dev, df->d_ino, 0);
    }
#line 818
    if (result != sn->s_fmt_output) {
      {
#line 819
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"since: logic problem: expected state line to be %d bytes, printed %d\n",
              sn->s_fmt_output, result);
      }
#line 820
      return (-1);
    }
#line 822
    j = 0;
    {
#line 822
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 822
      if (! (j < sn->s_size)) {
#line 822
        goto while_break___0;
      }
      {
#line 823
      tmp___1 = memcmp((void const   *)(sn->s_buffer + j), (void const   *)(line),
                       (size_t )sn->s_fmt_prefix);
      }
#line 823
      if (! tmp___1) {
#line 824
        df->d_offset = j;
#line 825
        if ((unsigned long )sn->s_arch_size > sizeof(unsigned long )) {
          {
#line 826
          tmp = strtoull((char const   */* __restrict  */)(((sn->s_buffer + j) + sn->s_fmt_prefix) + 1),
                         (char **/* __restrict  */)(& end), 16);
#line 826
          df->d_had = (off_t )tmp;
          }
        } else {
          {
#line 828
          tmp___0 = strtoul((char const   */* __restrict  */)(((sn->s_buffer + j) + sn->s_fmt_prefix) + 1),
                            (char **/* __restrict  */)(& end), 16);
#line 828
          df->d_had = (off_t )tmp___0;
          }
        }
#line 830
        if ((int )*(end + 0) != 10) {
          {
#line 831
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"since: parse problem: unable to convert value at offset %d to number\n",
                  (j + sn->s_fmt_prefix) + 1);
          }
#line 832
          return (-1);
        }
#line 835
        if (df->d_had > df->d_now) {
          {
#line 836
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"since: considering %s to be truncated, displaying from start\n",
                  df->d_name);
#line 837
          df->d_had = (off_t )0;
#line 838
          df->d_write = (unsigned char)1;
          }
        }
#line 841
        if (df->d_pos != df->d_had) {
#line 843
          df->d_pos = df->d_had;
#line 844
          df->d_jump = (unsigned char)1;
        }
#line 847
        if (sn->s_verbose > 3) {
          {
#line 852
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"since: found record for %s at offset %d, now=%ld, had=%ld\n",
                  df->d_name, j, df->d_now, df->d_had);
          }
        }
#line 855
        goto while_break___0;
      }
#line 822
      j += sn->s_fmt_output + 1;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 815
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 860
  return (0);
}
}
#line 865 "/home/june/repo/benchmarks/collector/temp/since-1.1/since.c"
static int setup_watch(struct since_state *sn ) 
{ 


  {
#line 890
  return (0);
}
}
#line 893 "/home/june/repo/benchmarks/collector/temp/since-1.1/since.c"
static int check_file(struct since_state *sn , struct data_file *df ) 
{ 
  struct stat st ;
  int again ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 898
  tmp___0 = stat((char const   */* __restrict  */)df->d_name, (struct stat */* __restrict  */)(& st));
  }
#line 898
  if (tmp___0 == 0) {
#line 899
    if (st.st_ino != df->d_ino) {
#line 899
      goto _L;
    } else
#line 899
    if (st.st_dev != df->d_dev) {
      _L: /* CIL Label */ 
#line 901
      if ((int )df->d_replaced == 0) {
#line 902
        df->d_replaced = (unsigned char)1;
#line 903
        df->d_notable = (unsigned char)1;
      }
#line 909
      again = 1;
    } else {
#line 911
      again = 0;
#line 913
      df->d_replaced = (unsigned char)0;
#line 914
      df->d_moved = (unsigned char)0;
    }
  } else {
    {
#line 917
    tmp = __errno_location();
    }
    {
#line 918
    if (*tmp == 2) {
#line 918
      goto case_2;
    }
#line 917
    goto switch_break;
    case_2: /* CIL Label */ 
#line 919
    if ((int )df->d_moved == 0) {
#line 920
      df->d_moved = (unsigned char)1;
#line 921
      df->d_notable = (unsigned char)1;
    }
#line 923
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 926
    again = 1;
  }
#line 929
  if (again) {
    {
#line 930
    tmp___3 = fstat(df->d_fd, & st);
    }
#line 930
    if (tmp___3) {
      {
#line 931
      tmp___1 = __errno_location();
#line 931
      tmp___2 = strerror(*tmp___1);
#line 931
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"since: unable to stat %s: %s\n",
              df->d_name, tmp___2);
      }
#line 932
      return (-1);
    }
#line 934
    if (st.st_nlink == 0UL) {
#line 936
      if ((int )df->d_deleted == 0) {
#line 937
        df->d_deleted = (unsigned char)1;
#line 938
        df->d_notable = (unsigned char)1;
      }
    } else
#line 941
    if ((int )df->d_moved == 0) {
#line 942
      df->d_moved = (unsigned char)1;
#line 943
      df->d_notable = (unsigned char)1;
    }
  }
#line 952
  if (st.st_size < df->d_now) {
    {
#line 953
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"since: considering %s to be truncated, displaying from start\n",
            df->d_name);
#line 954
    df->d_had = (off_t )0;
#line 955
    df->d_pos = (off_t )0;
#line 956
    df->d_jump = (unsigned char)1;
#line 957
    df->d_write = (unsigned char)1;
#line 958
    df->d_notable = (unsigned char)1;
    }
  }
#line 961
  if (df->d_now < st.st_size) {
#line 962
    df->d_notable = (unsigned char)1;
  }
#line 964
  df->d_now = st.st_size;
#line 966
  return (0);
}
}
#line 969 "/home/june/repo/benchmarks/collector/temp/since-1.1/since.c"
static int notify_watch(struct since_state *sn ) 
{ 


  {
#line 1035
  return (-1);
}
}
#line 1039 "/home/june/repo/benchmarks/collector/temp/since-1.1/since.c"
static int poll_watch(struct since_state *sn ) 
{ 
  unsigned int i ;
  struct data_file *df ;
  int tmp ;

  {
  {
#line 1044
  sigprocmask(1, (sigset_t const   */* __restrict  */)(& sn->s_set), (sigset_t */* __restrict  */)((void *)0));
#line 1045
  nanosleep((struct timespec  const  *)(& sn->s_delay), (struct timespec *)((void *)0));
#line 1046
  sigprocmask(0, (sigset_t const   */* __restrict  */)(& sn->s_set), (sigset_t */* __restrict  */)((void *)0));
  }
#line 1048
  if (since_run == (int volatile   )0) {
#line 1049
    return (1);
  }
#line 1052
  i = 0U;
  {
#line 1052
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1052
    if (! (i < sn->s_data_count)) {
#line 1052
      goto while_break;
    }
    {
#line 1053
    df = sn->s_data_files + i;
#line 1054
    tmp = check_file(sn, df);
    }
#line 1054
    if (tmp < 0) {
#line 1055
      return (-1);
    }
#line 1052
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1059
  return (0);
}
}
#line 1062 "/home/june/repo/benchmarks/collector/temp/since-1.1/since.c"
int run_watch(struct since_state *sn ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1064
  if (sn->s_notify < 0) {
    {
#line 1065
    tmp = poll_watch(sn);
    }
#line 1065
    return (tmp);
  } else {
    {
#line 1067
    tmp___0 = notify_watch(sn);
    }
#line 1067
    return (tmp___0);
  }
}
}
#line 1073 "/home/june/repo/benchmarks/collector/temp/since-1.1/since.c"
static int display_header(struct since_state *sn , struct data_file *df , int single ,
                          int chuck ) 
{ 
  off_t delta ;
  unsigned int value ;
  unsigned int z ;
  int nada ;
  char *suffixes[6] ;

  {
#line 1078
  suffixes[0] = (char *)"b";
#line 1078
  suffixes[1] = (char *)"kb";
#line 1078
  suffixes[2] = (char *)"Mb";
#line 1078
  suffixes[3] = (char *)"Gb";
#line 1078
  suffixes[4] = (char *)"Tb";
#line 1078
  suffixes[5] = (char *)((void *)0);
  {
#line 1081
  if (sn->s_verbose == 0) {
#line 1081
    goto case_0;
  }
#line 1082
  if (sn->s_verbose == 1) {
#line 1082
    goto case_1;
  }
#line 1083
  if (sn->s_verbose == 2) {
#line 1083
    goto case_2;
  }
#line 1080
  goto switch_break;
  case_0: /* CIL Label */ 
#line 1081
  return (0);
  case_1: /* CIL Label */ 
#line 1082
  if (single) {
#line 1082
    return (0);
  }
  case_2: /* CIL Label */ 
#line 1083
  if ((int )df->d_notable == 0) {
#line 1083
    return (0);
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 1086
  df->d_notable = (unsigned char)0;
#line 1089
  fprintf((FILE */* __restrict  */)sn->s_header, (char const   */* __restrict  */)"==> %s ",
          df->d_name);
#line 1091
  nada = 1;
  }
#line 1093
  if (df->d_deleted) {
    {
#line 1094
    fprintf((FILE */* __restrict  */)sn->s_header, (char const   */* __restrict  */)"[deleted] ");
#line 1095
    nada = 0;
    }
  } else
#line 1096
  if (df->d_moved) {
    {
#line 1097
    fprintf((FILE */* __restrict  */)sn->s_header, (char const   */* __restrict  */)"[moved] ");
#line 1098
    nada = 0;
    }
  }
#line 1108
  if (df->d_pos != df->d_now) {
#line 1109
    if (chuck) {
      {
#line 1110
      fprintf((FILE */* __restrict  */)sn->s_header, (char const   */* __restrict  */)"[discarded] ");
      }
    }
#line 1112
    if (sn->s_verbose > 2) {
#line 1113
      delta = df->d_now - df->d_pos;
#line 1114
      z = 0U;
      {
#line 1114
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1114
        if (suffixes[z + 1U]) {
#line 1114
          if (! (delta > 9999L)) {
#line 1114
            goto while_break;
          }
        } else {
#line 1114
          goto while_break;
        }
#line 1115
        delta /= 1024L;
#line 1114
        z ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 1117
      value = (unsigned int )delta;
#line 1118
      fprintf((FILE */* __restrict  */)sn->s_header, (char const   */* __restrict  */)"(+%u%s) ",
              value, suffixes[z]);
      }
    }
#line 1120
    nada = 0;
  }
#line 1123
  if (nada) {
    {
#line 1124
    fprintf((FILE */* __restrict  */)sn->s_header, (char const   */* __restrict  */)"[nothing new] ");
    }
  }
  {
#line 1127
  fprintf((FILE */* __restrict  */)sn->s_header, (char const   */* __restrict  */)"<==\n");
#line 1128
  fflush(sn->s_header);
  }
#line 1130
  return (0);
}
}
#line 1133 "/home/june/repo/benchmarks/collector/temp/since-1.1/since.c"
static int display_buffer(struct since_state *sn , struct data_file *df , char *buffer ,
                          unsigned int len ) 
{ 
  int wr ;
  int result ;
  unsigned int wt ;
  unsigned int i ;
  unsigned int back ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 1147
  wt = 0U;
#line 1148
  result = 1;
#line 1149
  since_run = (int volatile   )1;
#line 1150
  sigprocmask(1, (sigset_t const   */* __restrict  */)(& sn->s_set), (sigset_t */* __restrict  */)((void *)0));
  }
  {
#line 1152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1152
    if (! since_run) {
#line 1152
      goto while_break;
    }
    {
#line 1153
    tmp = write(1, (void const   *)(buffer + wt), (size_t )(len - wt));
#line 1153
    wr = (int )tmp;
    }
    {
#line 1155
    if (wr == -1) {
#line 1155
      goto case_neg_1;
    }
#line 1173
    if (wr == 0) {
#line 1173
      goto case_0;
    }
#line 1176
    goto switch_default___0;
    case_neg_1: /* CIL Label */ 
    {
#line 1159
    tmp___0 = __errno_location();
    }
    {
#line 1161
    if (*tmp___0 == 32) {
#line 1161
      goto case_32;
    }
#line 1161
    if (*tmp___0 == 4) {
#line 1161
      goto case_32;
    }
#line 1164
    if (*tmp___0 == 11) {
#line 1164
      goto case_11;
    }
#line 1166
    goto switch_default;
    case_32: /* CIL Label */ 
    case_4: /* CIL Label */ 
#line 1162
    since_run = (int volatile   )0;
#line 1163
    result = 1;
    case_11: /* CIL Label */ 
#line 1165
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 1168
    tmp___1 = __errno_location();
#line 1168
    tmp___2 = strerror(*tmp___1);
#line 1168
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"since: unable to display output: %s\n",
            tmp___2);
#line 1169
    since_run = (int volatile   )0;
#line 1170
    result = -1;
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 1172
    goto switch_break;
    case_0: /* CIL Label */ 
#line 1175
    goto switch_break;
    switch_default___0: /* CIL Label */ 
#line 1177
    wt += (unsigned int )wr;
#line 1178
    if (wt >= len) {
#line 1179
      since_run = (int volatile   )0;
#line 1180
      result = 0;
    }
#line 1182
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1186
  sigprocmask(0, (sigset_t const   */* __restrict  */)(& sn->s_set), (sigset_t */* __restrict  */)((void *)0));
#line 1187
  since_run = (int volatile   )1;
  }
#line 1193
  if (result < 0) {
#line 1194
    return (-1);
  }
#line 1197
  if (result == 0) {
#line 1198
    df->d_pos += (off_t )len;
#line 1199
    df->d_write = (unsigned char)1;
#line 1200
    return (0);
  }
#line 1205
  if (wt <= 0U) {
#line 1206
    return (1);
  }
#line 1210
  if (wt <= 160U) {
#line 1210
    back = 0U;
  } else {
#line 1210
    back = wt - 160U;
  }
#line 1211
  i = wt;
  {
#line 1213
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1214
    i --;
#line 1215
    if ((int )*(buffer + i) == 10) {
#line 1219
      wt = i + 1U;
#line 1220
      goto while_break___0;
    }
#line 1213
    if (! (i > back)) {
#line 1213
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1228
  df->d_pos += (off_t )wt;
#line 1229
  df->d_write = (unsigned char)1;
#line 1231
  return (1);
}
}
#line 1234 "/home/june/repo/benchmarks/collector/temp/since-1.1/since.c"
static int display_file(struct since_state *sn , struct data_file *df , int single ) 
{ 
  char *ptr ;
  char buffer[4096] ;
  int rr ;
  int result ;
  off_t range ;
  off_t i ;
  unsigned int fixup ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  __off64_t tmp___2 ;
  ssize_t tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;

  {
#line 1243
  if (df->d_had > df->d_now) {
    {
#line 1244
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"since: considering %s to be truncated, displaying from start\n",
            df->d_name);
#line 1245
    df->d_had = (off_t )0;
#line 1247
    df->d_write = (unsigned char)1;
    }
  }
#line 1250
  if (df->d_pos < df->d_had) {
#line 1251
    df->d_jump = (unsigned char)1;
#line 1252
    df->d_pos = df->d_had;
  }
#line 1262
  range = df->d_now - df->d_pos;
#line 1263
  if (range == 0L) {
    {
#line 1264
    display_header(sn, df, single, 0);
    }
#line 1265
    return (0);
  }
#line 1268
  if (range > 4096L) {
#line 1268
    if (sn->s_domap) {
      {
#line 1269
      fixup = (unsigned int )(df->d_pos & 4095L);
#line 1270
      tmp = mmap((void *)0, (size_t )(range + range), 1, 2, df->d_fd, df->d_pos - (off_t )fixup);
#line 1270
      ptr = (char *)tmp;
      }
#line 1271
      if ((unsigned long )((void *)ptr) != (unsigned long )((void *)-1)) {
        {
#line 1272
        display_header(sn, df, single, 0);
#line 1274
        result = display_buffer(sn, df, ptr + fixup, (unsigned int )range);
#line 1275
        df->d_jump = (unsigned char)1;
#line 1276
        munmap((void *)ptr, (size_t )(range + (off_t )fixup));
        }
#line 1278
        return (result);
      }
    }
  }
#line 1286
  if (df->d_jump) {
    {
#line 1287
    tmp___2 = lseek(df->d_fd, df->d_pos, 0);
    }
#line 1287
    if (tmp___2 != df->d_pos) {
      {
#line 1288
      tmp___0 = __errno_location();
#line 1288
      tmp___1 = strerror(*tmp___0);
#line 1288
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"since: unable to seek in file %s: %s\n",
              df->d_name, tmp___1);
      }
#line 1289
      return (-1);
    }
#line 1291
    df->d_jump = (unsigned char)0;
  }
  {
#line 1294
  display_header(sn, df, single, 0);
#line 1295
  i = (off_t )0;
#line 1296
  df->d_write = (unsigned char)1;
  }
  {
#line 1297
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1297
    if (! (df->d_pos < df->d_now)) {
#line 1297
      goto while_break;
    }
    {
#line 1298
    tmp___3 = read(df->d_fd, (void *)(buffer), (size_t )4096);
#line 1298
    rr = (int )tmp___3;
    }
    {
#line 1300
    if (rr == -1) {
#line 1300
      goto case_neg_1;
    }
#line 1310
    if (rr == 0) {
#line 1310
      goto case_0;
    }
#line 1313
    goto switch_default___0;
    case_neg_1: /* CIL Label */ 
    {
#line 1301
    tmp___4 = __errno_location();
    }
    {
#line 1303
    if (*tmp___4 == 4) {
#line 1303
      goto case_4;
    }
#line 1303
    if (*tmp___4 == 11) {
#line 1303
      goto case_4;
    }
#line 1305
    goto switch_default;
    case_4: /* CIL Label */ 
    case_11: /* CIL Label */ 
#line 1304
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 1306
    tmp___5 = __errno_location();
#line 1306
    tmp___6 = strerror(*tmp___5);
#line 1306
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"since: unable to read from %s: %s\n",
            df->d_name, tmp___6);
    }
#line 1307
    return (-1);
    switch_break___0: /* CIL Label */ ;
    }
#line 1309
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 1311
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"since: unexpected eof while reading from %s\n",
            df->d_name);
    }
#line 1312
    goto switch_break;
    switch_default___0: /* CIL Label */ 
    {
#line 1314
    result = display_buffer(sn, df, buffer, (unsigned int )rr);
    }
#line 1315
    if (result != 0) {
#line 1316
      return (result);
    }
#line 1318
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1322
  if (df->d_now < df->d_pos) {
#line 1324
    df->d_now = df->d_pos;
  }
#line 1327
  return (0);
}
}
#line 1330 "/home/june/repo/benchmarks/collector/temp/since-1.1/since.c"
static int display_files(struct since_state *sn ) 
{ 
  unsigned int i ;
  int result ;
  int single ;

  {
#line 1339
  if (sn->s_data_count == 1U) {
#line 1339
    single = 1;
  } else {
#line 1339
    single = 0;
  }
#line 1341
  i = 0U;
  {
#line 1341
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1341
    if (! (i < sn->s_data_count)) {
#line 1341
      goto while_break;
    }
    {
#line 1342
    result = display_file(sn, sn->s_data_files + i, single);
    }
#line 1343
    if (result) {
#line 1344
      return (result);
    }
#line 1341
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1348
  return (0);
}
}
#line 1353 "/home/june/repo/benchmarks/collector/temp/since-1.1/since.c"
static void discard_files(struct since_state *sn ) 
{ 
  unsigned int i ;
  struct data_file *df ;
  int single ;

  {
#line 1363
  if (sn->s_data_count == 1U) {
#line 1363
    single = 1;
  } else {
#line 1363
    single = 0;
  }
#line 1365
  i = 0U;
  {
#line 1365
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1365
    if (! (i < sn->s_data_count)) {
#line 1365
      goto while_break;
    }
    {
#line 1366
    df = sn->s_data_files + i;
#line 1368
    display_header(sn, df, single, 1);
    }
#line 1370
    if (df->d_pos != df->d_now) {
#line 1371
      df->d_pos = df->d_now;
#line 1372
      df->d_jump = (unsigned char)1;
#line 1373
      df->d_write = (unsigned char)1;
    }
#line 1365
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1377
  return;
}
}
#line 1381 "/home/june/repo/benchmarks/collector/temp/since-1.1/since.c"
static int append_state_file(struct since_state *sn ) 
{ 
  int sofar ;
  int result ;
  int *tmp ;
  char *tmp___0 ;
  __off64_t tmp___1 ;
  ssize_t tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;

  {
#line 1385
  if ((unsigned long )sn->s_append == (unsigned long )((void *)0)) {
#line 1386
    return (0);
  } else
#line 1385
  if (sn->s_add == 0) {
#line 1386
    return (0);
  }
  {
#line 1389
  tmp___1 = lseek(sn->s_fd, (__off64_t )sn->s_size, 0);
  }
#line 1389
  if (tmp___1 != (__off64_t )sn->s_size) {
    {
#line 1390
    tmp = __errno_location();
#line 1390
    tmp___0 = strerror(*tmp);
#line 1390
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"since: unable to seek to end of file %s: %s\n",
            sn->s_name, tmp___0);
    }
#line 1391
    return (-1);
  }
#line 1394
  sofar = 0;
  {
#line 1395
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1395
    if (! (sofar < sn->s_add)) {
#line 1395
      goto while_break;
    }
    {
#line 1396
    tmp___2 = write(sn->s_fd, (void const   *)(sn->s_append + sofar), (size_t )(sn->s_add - sofar));
#line 1396
    result = (int )tmp___2;
    }
#line 1397
    if (result < 0) {
      {
#line 1398
      tmp___3 = __errno_location();
      }
      {
#line 1400
      if (*tmp___3 == 4) {
#line 1400
        goto case_4;
      }
#line 1400
      if (*tmp___3 == 11) {
#line 1400
        goto case_4;
      }
#line 1402
      goto switch_default;
      case_4: /* CIL Label */ 
      case_11: /* CIL Label */ 
#line 1401
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 1403
      tmp___4 = __errno_location();
#line 1403
      tmp___5 = strerror(*tmp___4);
#line 1403
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"since: unable to write %d bytes to %s: %s\n",
              sn->s_add - sofar, sn->s_name, tmp___5);
      }
#line 1404
      return (-1);
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 1407
      sofar += result;
#line 1408
      if (result == 0) {
        {
#line 1409
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"since: warning: wrote 0 bytes to file to %s\n",
                sn->s_name);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1414
  return (0);
}
}
#line 1417 "/home/june/repo/benchmarks/collector/temp/since-1.1/since.c"
static int internal_update_state_file(struct since_state *sn ) 
{ 
  int sofar ;
  int result ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
#line 1428
  sofar = 0;
  {
#line 1429
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1429
    if (! (sofar < sn->s_size)) {
#line 1429
      goto while_break;
    }
    {
#line 1430
    tmp = write(sn->s_fd, (void const   *)(sn->s_buffer + sofar), (size_t )(sn->s_size - sofar));
#line 1430
    result = (int )tmp;
    }
#line 1431
    if (result < 0) {
      {
#line 1432
      tmp___0 = __errno_location();
      }
      {
#line 1434
      if (*tmp___0 == 4) {
#line 1434
        goto case_4;
      }
#line 1434
      if (*tmp___0 == 11) {
#line 1434
        goto case_4;
      }
#line 1436
      goto switch_default;
      case_4: /* CIL Label */ 
      case_11: /* CIL Label */ 
#line 1435
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 1437
      tmp___1 = __errno_location();
#line 1437
      tmp___2 = strerror(*tmp___1);
#line 1437
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"since: unable to rewrite %d bytes to %s: %s\n",
              sn->s_size - sofar, sn->s_name, tmp___2);
      }
#line 1438
      return (-1);
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 1441
      sofar += result;
#line 1442
      if (result == 0) {
        {
#line 1443
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"since: warning: wrote 0 bytes to file to %s\n",
                sn->s_name);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1448
  tmp___3 = append_state_file(sn);
  }
#line 1448
  return (tmp___3);
}
}
#line 1451 "/home/june/repo/benchmarks/collector/temp/since-1.1/since.c"
static int update_state_file(struct since_state *sn ) 
{ 
  char *tmp ;
  char *target ;
  int i ;
  int j ;
  int result ;
  int redo ;
  int changed ;
  struct data_file *df ;
  void *tmp___0 ;

  {
#line 1458
  if (sn->s_readonly) {
#line 1459
    if (sn->s_verbose > 2) {
      {
#line 1460
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"since: readonly, not updatating %s\n",
              sn->s_name);
      }
    }
#line 1462
    return (1);
  }
#line 1465
  changed = 0;
#line 1466
  redo = sn->s_atomic;
#line 1468
  i = 0;
  {
#line 1468
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1468
    if (! ((unsigned int )i < sn->s_data_count)) {
#line 1468
      goto while_break;
    }
#line 1469
    df = sn->s_data_files + i;
#line 1470
    if (df->d_write) {
#line 1471
      changed = 1;
#line 1472
      if (df->d_offset < 0) {
#line 1474
        j = (int )(sn->s_data_count - 1U);
        {
#line 1474
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1474
          if (! (j > i)) {
#line 1474
            goto while_break___0;
          }
#line 1475
          if ((sn->s_data_files + j)->d_ino == df->d_ino) {
#line 1475
            if ((sn->s_data_files + j)->d_dev == df->d_dev) {
#line 1475
              if ((sn->s_data_files + j)->d_offset < 0) {
#line 1475
                if ((sn->s_data_files + j)->d_write) {
#line 1479
                  goto while_break___0;
                }
              }
            }
          }
#line 1474
          j --;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 1482
        if (i != j) {
#line 1483
          goto __Cont;
        }
        {
#line 1485
        tmp___0 = realloc((void *)sn->s_append, (size_t )((sn->s_add + sn->s_fmt_output) + 1));
#line 1485
        tmp = (char *)tmp___0;
        }
#line 1486
        if ((unsigned long )tmp == (unsigned long )((void *)0)) {
          {
#line 1487
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"since: unable to allocate %d bytes for append buffer \n",
                  (sn->s_add + sn->s_fmt_output) + 1);
          }
#line 1488
          return (-1);
        }
#line 1490
        sn->s_append = tmp;
#line 1491
        target = sn->s_append + sn->s_add;
#line 1492
        sn->s_add += sn->s_fmt_output + 1;
      } else {
#line 1494
        target = sn->s_buffer + df->d_offset;
#line 1495
        if (sn->s_ismap) {
#line 1495
          redo = sn->s_atomic;
        } else {
#line 1495
          redo = 1;
        }
      }
      {
#line 1498
      result = snprintf((char */* __restrict  */)target, (size_t )(sn->s_fmt_output + 1),
                        (char const   */* __restrict  */)(sn->s_fmt), df->d_dev, df->d_ino,
                        df->d_pos);
#line 1499
      *(target + sn->s_fmt_output) = (char )'\n';
      }
#line 1500
      if (result != sn->s_fmt_output) {
        {
#line 1501
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"since: logic failure: wanted to print %d, got %d\n",
                sn->s_fmt_output, result);
        }
#line 1502
        return (-1);
      }
    }
    __Cont: /* CIL Label */ 
#line 1468
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1507
  if (changed) {
#line 1508
    if (redo) {
      {
#line 1509
      result = tmp_state_file(sn, & internal_update_state_file);
      }
    } else {
      {
#line 1511
      result = append_state_file(sn);
      }
    }
  } else {
#line 1514
    result = 0;
  }
  {
#line 1517
  forget_state_file(sn);
  }
#line 1519
  return (result);
}
}
#line 1524 "/home/june/repo/benchmarks/collector/temp/since-1.1/since.c"
static void copying(void) 
{ 


  {
  {
#line 1526
  printf((char const   */* __restrict  */)"since: Copyright (c) 1998-2008 Marc Welz\n");
#line 1527
  printf((char const   */* __restrict  */)"       May only be distributed in accordance with the terms of the GNU General\n");
#line 1528
  printf((char const   */* __restrict  */)"       Public License v3 or newer as published by the Free Software Foundation\n");
  }
#line 1529
  return;
}
}
#line 1531 "/home/june/repo/benchmarks/collector/temp/since-1.1/since.c"
static void usage(char *app ) 
{ 
  int i ;

  {
  {
#line 1535
  printf((char const   */* __restrict  */)"since displays the data appended to files since the last time since was run\n\n");
#line 1537
  printf((char const   */* __restrict  */)"Usage: %s [option ...] file ...\n", app);
#line 1539
  printf((char const   */* __restrict  */)"\nOptions\n");
#line 1540
  printf((char const   */* __restrict  */)" -a        update state file atomically\n");
#line 1541
  printf((char const   */* __restrict  */)" -d int    set the interval when following files\n");
#line 1542
  printf((char const   */* __restrict  */)" -e        print header lines to standard error\n");
#line 1543
  printf((char const   */* __restrict  */)" -f        follow files, periodically check if more data has been appended\n");
#line 1544
  printf((char const   */* __restrict  */)" -h        this help\n");
#line 1545
  printf((char const   */* __restrict  */)" -l        lax mode, do not fail if some files are inaccessible\n");
#line 1546
  printf((char const   */* __restrict  */)" -m        do not use mmap() to access files, use read()\n");
#line 1547
  printf((char const   */* __restrict  */)" -n        do not update since state file\n");
#line 1548
  printf((char const   */* __restrict  */)" -q        reduce verbosity to nothing\n");
#line 1549
  printf((char const   */* __restrict  */)" -s file   specify the state file, overriding SINCE variable and home directory\n");
#line 1550
  printf((char const   */* __restrict  */)" -v        increase verbosity, can be given multiple times\n");
#line 1551
  printf((char const   */* __restrict  */)" -x        ignore files with compressed extensions:");
#line 1552
  i = 0;
  }
  {
#line 1552
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1552
    if (! ignore_suffix[i]) {
#line 1552
      goto while_break;
    }
    {
#line 1553
    printf((char const   */* __restrict  */)" %s", ignore_suffix[i]);
#line 1552
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1555
  printf((char const   */* __restrict  */)"\n");
#line 1556
  printf((char const   */* __restrict  */)" -z        discard initial output\n");
#line 1558
  printf((char const   */* __restrict  */)" -V        print version information\n");
#line 1561
  printf((char const   */* __restrict  */)"\nExample\n");
#line 1562
  printf((char const   */* __restrict  */)" $ since -lz /var/log/*\n");
#line 1563
  printf((char const   */* __restrict  */)" $ logger foobar\n");
#line 1564
  printf((char const   */* __restrict  */)" $ since -lx /var/log/*\n");
  }
#line 1565
  return;
}
}
#line 1567 "/home/june/repo/benchmarks/collector/temp/since-1.1/since.c"
int main(int argc , char **argv ) 
{ 
  int i ;
  int j ;
  int result ;
  int dashes ;
  struct since_state state ;
  struct since_state *sn ;
  struct sigaction sag ;
  char *state_file ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 1574
  sn = & state;
#line 1575
  state_file = (char *)((void *)0);
#line 1577
  init_state(sn);
#line 1579
  j = 1;
#line 1579
  i = j;
#line 1580
  dashes = 0;
  }
  {
#line 1582
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1582
    if (! (i < argc)) {
#line 1582
      goto while_break;
    }
#line 1583
    if ((int )*(*(argv + i) + 0) == 45) {
#line 1583
      if (dashes == 0) {
        {
#line 1585
        if ((int )*(*(argv + i) + j) == 99) {
#line 1585
          goto case_99;
        }
#line 1588
        if ((int )*(*(argv + i) + j) == 104) {
#line 1588
          goto case_104;
        }
#line 1592
        if ((int )*(*(argv + i) + j) == 115) {
#line 1592
          goto case_115;
        }
#line 1606
        if ((int )*(*(argv + i) + j) == 100) {
#line 1606
          goto case_100;
        }
#line 1624
        if ((int )*(*(argv + i) + j) == 97) {
#line 1624
          goto case_97;
        }
#line 1628
        if ((int )*(*(argv + i) + j) == 101) {
#line 1628
          goto case_101;
        }
#line 1632
        if ((int )*(*(argv + i) + j) == 102) {
#line 1632
          goto case_102;
        }
#line 1636
        if ((int )*(*(argv + i) + j) == 108) {
#line 1636
          goto case_108;
        }
#line 1640
        if ((int )*(*(argv + i) + j) == 109) {
#line 1640
          goto case_109;
        }
#line 1644
        if ((int )*(*(argv + i) + j) == 110) {
#line 1644
          goto case_110;
        }
#line 1648
        if ((int )*(*(argv + i) + j) == 113) {
#line 1648
          goto case_113;
        }
#line 1652
        if ((int )*(*(argv + i) + j) == 118) {
#line 1652
          goto case_118;
        }
#line 1656
        if ((int )*(*(argv + i) + j) == 120) {
#line 1656
          goto case_120;
        }
#line 1660
        if ((int )*(*(argv + i) + j) == 122) {
#line 1660
          goto case_122;
        }
#line 1665
        if ((int )*(*(argv + i) + j) == 86) {
#line 1665
          goto case_86;
        }
#line 1670
        if ((int )*(*(argv + i) + j) == 45) {
#line 1670
          goto case_45;
        }
#line 1676
        if ((int )*(*(argv + i) + j) == 0) {
#line 1676
          goto case_0;
        }
#line 1680
        goto switch_default;
        case_99: /* CIL Label */ 
        {
#line 1586
        copying();
        }
#line 1587
        return (0);
        case_104: /* CIL Label */ 
        {
#line 1589
        usage(*(argv + 0));
        }
#line 1590
        return (0);
#line 1591
        goto switch_break;
        case_115: /* CIL Label */ 
#line 1593
        j ++;
#line 1594
        if ((int )*(*(argv + i) + j) == 0) {
#line 1595
          j = 0;
#line 1596
          i ++;
        }
#line 1598
        if (i >= argc) {
          {
#line 1599
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"since: -s needs a filename as parameter\n");
          }
#line 1600
          return (64);
        }
#line 1602
        state_file = *(argv + i) + j;
#line 1603
        i ++;
#line 1604
        j = 1;
#line 1605
        goto switch_break;
        case_100: /* CIL Label */ 
#line 1607
        j ++;
#line 1608
        if ((int )*(*(argv + i) + j) == 0) {
#line 1609
          j = 0;
#line 1610
          i ++;
        }
#line 1612
        if (i >= argc) {
          {
#line 1613
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"since: -d needs an integer parameter\n");
          }
#line 1614
          return (64);
        }
        {
#line 1616
        tmp = atoi((char const   *)(*(argv + i) + j));
#line 1616
        sn->s_delay.tv_sec = (__time_t )tmp;
#line 1617
        sn->s_delay.tv_nsec = (__syscall_slong_t )0;
        }
#line 1618
        if (sn->s_delay.tv_sec < 0L) {
#line 1619
          sn->s_delay.tv_sec = (__time_t )1;
        }
#line 1621
        i ++;
#line 1622
        j = 1;
#line 1623
        goto switch_break;
        case_97: /* CIL Label */ 
#line 1625
        j ++;
#line 1626
        sn->s_atomic = 1;
#line 1627
        goto switch_break;
        case_101: /* CIL Label */ 
#line 1629
        j ++;
#line 1630
        sn->s_header = stderr;
#line 1631
        goto switch_break;
        case_102: /* CIL Label */ 
#line 1633
        j ++;
#line 1634
        sn->s_follow = 1;
#line 1635
        goto switch_break;
        case_108: /* CIL Label */ 
#line 1637
        j ++;
#line 1638
        sn->s_relaxed = 1;
#line 1639
        goto switch_break;
        case_109: /* CIL Label */ 
#line 1641
        j ++;
#line 1642
        sn->s_domap = 1 - sn->s_domap;
#line 1643
        goto switch_break;
        case_110: /* CIL Label */ 
#line 1645
        j ++;
#line 1646
        sn->s_readonly = 1;
#line 1647
        goto switch_break;
        case_113: /* CIL Label */ 
#line 1649
        j ++;
#line 1650
        sn->s_verbose = 0;
#line 1651
        goto switch_break;
        case_118: /* CIL Label */ 
#line 1653
        j ++;
#line 1654
        (sn->s_verbose) ++;
#line 1655
        goto switch_break;
        case_120: /* CIL Label */ 
#line 1657
        j ++;
#line 1658
        (sn->s_nozip) ++;
#line 1659
        goto switch_break;
        case_122: /* CIL Label */ 
#line 1661
        j ++;
#line 1662
        (sn->s_discard) ++;
#line 1663
        goto switch_break;
        case_86: /* CIL Label */ 
        {
#line 1666
        j ++;
#line 1667
        printf((char const   */* __restrict  */)"since %s\n", "1.1");
        }
#line 1668
        return (0);
        case_45: /* CIL Label */ 
#line 1671
        if (j == 1) {
#line 1671
          if ((int )*(*(argv + i) + (j + 1)) == 0) {
#line 1672
            dashes = 1;
          }
        }
#line 1674
        j ++;
#line 1675
        goto switch_break;
        case_0: /* CIL Label */ 
#line 1677
        j = 1;
#line 1678
        i ++;
#line 1679
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 1681
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"since: unknown option -%c (use -h for help)\n",
                (int )*(*(argv + i) + j));
        }
#line 1682
        return (64);
        switch_break: /* CIL Label */ ;
        }
      } else {
#line 1583
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 1685
      result = setup_data(sn, *(argv + i));
      }
#line 1686
      if (result < 0) {
#line 1687
        return (71);
      } else
#line 1686
      if (sn->s_relaxed == 0) {
#line 1686
        if (result > 0) {
#line 1687
          return (71);
        }
      }
#line 1689
      i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1693
  if (sn->s_data_count <= 0U) {
    {
#line 1694
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"since: need at least one filename (use -h for help)\n");
    }
#line 1695
    return (64);
  }
  {
#line 1699
  tmp___0 = open_state_file(sn, state_file);
  }
#line 1699
  if (tmp___0 < 0) {
#line 1700
    return (71);
  }
  {
#line 1704
  tmp___1 = load_state_file(sn);
  }
#line 1704
  if (tmp___1 < 0) {
#line 1705
    return (71);
  }
  {
#line 1709
  tmp___2 = check_state_file(sn);
  }
#line 1709
  if (tmp___2 < 0) {
#line 1710
    return (65);
  }
  {
#line 1713
  tmp___3 = maybe_upgrade_state_file(sn);
  }
#line 1713
  if (tmp___3 < 0) {
#line 1714
    return (71);
  }
  {
#line 1717
  tmp___4 = make_fmt_string(sn);
  }
#line 1717
  if (tmp___4 < 0) {
#line 1718
    return (70);
  }
  {
#line 1721
  tmp___5 = lookup_entries(sn);
  }
#line 1721
  if (tmp___5 < 0) {
#line 1722
    return (71);
  }
  {
#line 1731
  sigemptyset(& sn->s_set);
#line 1732
  sigaddset(& sn->s_set, 2);
#line 1733
  sigaddset(& sn->s_set, 13);
#line 1735
  sigprocmask(0, (sigset_t const   */* __restrict  */)(& sn->s_set), (sigset_t */* __restrict  */)((void *)0));
#line 1737
  sag.__sigaction_handler.sa_handler = & handle_signal;
#line 1738
  sigfillset(& sag.sa_mask);
#line 1739
  sag.sa_flags = 0;
#line 1740
  sigaction(13, (struct sigaction  const  */* __restrict  */)(& sag), (struct sigaction */* __restrict  */)((void *)0));
#line 1741
  sigaction(2, (struct sigaction  const  */* __restrict  */)(& sag), (struct sigaction */* __restrict  */)((void *)0));
  }
#line 1743
  if (sn->s_discard) {
    {
#line 1744
    discard_files(sn);
    }
  } else {
    {
#line 1746
    tmp___6 = display_files(sn);
    }
#line 1746
    if (tmp___6 < 0) {
#line 1747
      return (71);
    }
  }
#line 1750
  if (sn->s_follow) {
    {
#line 1751
    tmp___7 = setup_watch(sn);
    }
#line 1751
    if (tmp___7 < 0) {
#line 1752
      return (71);
    }
    {
#line 1754
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1755
      result = run_watch(sn);
      }
#line 1756
      if (result == 0) {
        {
#line 1757
        result = display_files(sn);
        }
      }
#line 1754
      if (! (result == 0)) {
#line 1754
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1760
    if (result < 0) {
#line 1761
      return (71);
    }
  }
  {
#line 1765
  tmp___8 = update_state_file(sn);
  }
#line 1765
  if (tmp___8 < 0) {
#line 1766
    return (71);
  }
  {
#line 1769
  destroy_state(sn);
  }
#line 1771
  return (0);
}
}
