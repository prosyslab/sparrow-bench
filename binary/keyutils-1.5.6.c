/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 38 "/usr/include/stdint.h"
typedef int int32_t;
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __u_char;
#line 32 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __u_int;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 33 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_char u_char;
#line 35 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_int u_int;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 201 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned short u_int16_t;
#line 202 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int u_int32_t;
#line 43 "/usr/include/x86_64-linux-gnu/bits/uio.h"
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 90 "/usr/include/x86_64-linux-gnu/sys/socket.h"
struct sockaddr_in;
#line 90
struct sockaddr_in6;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 209 "/usr/include/netinet/in.h"
union __anonunion___in6_u_22 {
   uint8_t __u6_addr8[16] ;
   uint16_t __u6_addr16[8] ;
   uint32_t __u6_addr32[4] ;
};
#line 209 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion___in6_u_22 __in6_u ;
};
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 252 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 98 "/usr/include/arpa/nameser.h"
enum __ns_sect {
    ns_s_qd = 0,
    ns_s_zn = 0,
    ns_s_an = 1,
    ns_s_pr = 1,
    ns_s_ns = 2,
    ns_s_ud = 2,
    ns_s_ar = 3,
    ns_s_max = 4
} ;
#line 98 "/usr/include/arpa/nameser.h"
typedef enum __ns_sect ns_sect;
#line 114 "/usr/include/arpa/nameser.h"
struct __ns_msg {
   u_char const   *_msg ;
   u_char const   *_eom ;
   u_int16_t _id ;
   u_int16_t _flags ;
   u_int16_t _counts[4] ;
   u_char const   *_sections[4] ;
   ns_sect _sect ;
   int _rrnum ;
   u_char const   *_msg_ptr ;
};
#line 114 "/usr/include/arpa/nameser.h"
typedef struct __ns_msg ns_msg;
#line 138 "/usr/include/arpa/nameser.h"
struct __ns_rr {
   char name[1025] ;
   u_int16_t type ;
   u_int16_t rr_class ;
   u_int32_t ttl ;
   u_int16_t rdlength ;
   u_char const   *rdata ;
};
#line 138 "/usr/include/arpa/nameser.h"
typedef struct __ns_rr ns_rr;
#line 252
enum __ns_type {
    ns_t_invalid = 0,
    ns_t_a = 1,
    ns_t_ns = 2,
    ns_t_md = 3,
    ns_t_mf = 4,
    ns_t_cname = 5,
    ns_t_soa = 6,
    ns_t_mb = 7,
    ns_t_mg = 8,
    ns_t_mr = 9,
    ns_t_null = 10,
    ns_t_wks = 11,
    ns_t_ptr = 12,
    ns_t_hinfo = 13,
    ns_t_minfo = 14,
    ns_t_mx = 15,
    ns_t_txt = 16,
    ns_t_rp = 17,
    ns_t_afsdb = 18,
    ns_t_x25 = 19,
    ns_t_isdn = 20,
    ns_t_rt = 21,
    ns_t_nsap = 22,
    ns_t_nsap_ptr = 23,
    ns_t_sig = 24,
    ns_t_key = 25,
    ns_t_px = 26,
    ns_t_gpos = 27,
    ns_t_aaaa = 28,
    ns_t_loc = 29,
    ns_t_nxt = 30,
    ns_t_eid = 31,
    ns_t_nimloc = 32,
    ns_t_srv = 33,
    ns_t_atma = 34,
    ns_t_naptr = 35,
    ns_t_kx = 36,
    ns_t_cert = 37,
    ns_t_a6 = 38,
    ns_t_dname = 39,
    ns_t_sink = 40,
    ns_t_opt = 41,
    ns_t_apl = 42,
    ns_t_tkey = 249,
    ns_t_tsig = 250,
    ns_t_ixfr = 251,
    ns_t_axfr = 252,
    ns_t_mailb = 253,
    ns_t_maila = 254,
    ns_t_any = 255,
    ns_t_zxfr = 256,
    ns_t_max = 65536
} ;
#line 252 "/usr/include/arpa/nameser.h"
typedef enum __ns_type ns_type;
#line 48 "/usr/include/arpa/nameser_compat.h"
struct __anonstruct_HEADER_48 {
   unsigned int id : 16 ;
   unsigned int rd : 1 ;
   unsigned int tc : 1 ;
   unsigned int aa : 1 ;
   unsigned int opcode : 4 ;
   unsigned int qr : 1 ;
   unsigned int rcode : 4 ;
   unsigned int cd : 1 ;
   unsigned int ad : 1 ;
   unsigned int unused : 1 ;
   unsigned int ra : 1 ;
   unsigned int qdcount : 16 ;
   unsigned int ancount : 16 ;
   unsigned int nscount : 16 ;
   unsigned int arcount : 16 ;
};
#line 48 "/usr/include/arpa/nameser_compat.h"
typedef struct __anonstruct_HEADER_48 HEADER;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 567 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 21 "./keyutils.h"
typedef int32_t key_serial_t;
#line 468 "/home/wheatley/newnew/temp/keyutils-1.5.6/key.dns_resolver.c"
union __anonunion_response_68 {
   HEADER hdr ;
   u_char buf[512] ;
};
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_14 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_14 fd_set;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 845 "/home/wheatley/newnew/temp/keyutils-1.5.6/request-key.c"
union __anonunion_53 {
   int __in ;
   int __i ;
};
#line 848 "/home/wheatley/newnew/temp/keyutils-1.5.6/request-key.c"
union __anonunion_54 {
   int __in ;
   int __i ;
};
#line 843 "/home/wheatley/newnew/temp/keyutils-1.5.6/request-key.c"
union __anonunion_55 {
   int __in ;
   int __i ;
};
#line 843 "/home/wheatley/newnew/temp/keyutils-1.5.6/request-key.c"
union __anonunion_56 {
   int __in ;
   int __i ;
};
#line 854 "/home/wheatley/newnew/temp/keyutils-1.5.6/request-key.c"
union __anonunion_57 {
   int __in ;
   int __i ;
};
#line 857 "/home/wheatley/newnew/temp/keyutils-1.5.6/request-key.c"
union __anonunion_58 {
   int __in ;
   int __i ;
};
#line 852 "/home/wheatley/newnew/temp/keyutils-1.5.6/request-key.c"
union __anonunion_59 {
   int __in ;
   int __i ;
};
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 65 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __gid_t gid_t;
#line 80 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 43 "/home/wheatley/newnew/temp/keyutils-1.5.6/keyutils.h"
typedef uint32_t key_perm_t;
#line 24 "/home/wheatley/newnew/temp/keyutils-1.5.6/keyctl.c"
struct command {
   int (*action)(int argc , char **argv ) ;
   char const   *name ;
   char const   *format ;
};
#line 1390 "/home/wheatley/newnew/temp/keyutils-1.5.6/keyctl.c"
struct purge_data {
   char const   *type ;
   char const   *desc ;
   size_t desc_len ;
   size_t type_len ;
   char prefix_match ;
   char case_indep ;
};
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 473 "/usr/include/arpa/nameser.h"
extern  __attribute__((__nothrow__)) u_int ( __attribute__((__leaf__)) ns_get16)(u_char const   * ) ;
#line 477
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ns_initparse)(u_char const   * ,
                                                                                   int  ,
                                                                                   ns_msg * ) ;
#line 480
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ns_parserr)(ns_msg * ,
                                                                                 ns_sect  ,
                                                                                 int  ,
                                                                                 ns_rr * ) ;
#line 498
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ns_name_uncompress)(u_char const   * ,
                                                                                         u_char const   * ,
                                                                                         u_char const   * ,
                                                                                         char * ,
                                                                                         size_t  ) ;
#line 64 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) inet_ntop)(int __af ,
                                                                                          void const   * __restrict  __cp ,
                                                                                          char * __restrict  __buf ,
                                                                                          socklen_t __len ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 405
extern  __attribute__((__nothrow__)) int ( /* format attribute */  asprintf)(char ** __restrict  __ptr ,
                                                                             char const   * __restrict  __fmt 
                                                                             , ...) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 277 "/usr/include/resolv.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) __res_query)(char const   * ,
                                                                                  int  ,
                                                                                  int  ,
                                                                                  u_char * ,
                                                                                  int  ) ;
#line 71 "/usr/include/getopt.h"
extern int optind ;
#line 173
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 61 "/usr/include/netdb.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __h_errno_location)(void)  __attribute__((__const__)) ;
#line 95
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) hstrerror)(int __err_num ) ;
#line 662
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 668
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) freeaddrinfo)(struct addrinfo *__ai ) ;
#line 671
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) gai_strerror)(int __ecode ) ;
#line 181 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 190
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 200
extern void ( /* format attribute */  vsyslog)(int __pri , char const   *__fmt , __gnuc_va_list __ap ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 489
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) index)(char const   *__s ,
                                                                                              int __c )  __attribute__((__pure__)) ;
#line 517
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) rindex)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 17 "./keyutils.h"
extern char const   keyutils_version_string[] ;
#line 18
extern char const   keyutils_build_string[] ;
#line 139
extern long keyctl_negate(key_serial_t id , unsigned int timeout , key_serial_t ringid ) ;
#line 141
extern long keyctl_set_timeout(key_serial_t key , unsigned int timeout ) ;
#line 145
extern long keyctl_reject(key_serial_t id , unsigned int timeout , unsigned int error ,
                          key_serial_t ringid ) ;
#line 148
extern long keyctl_instantiate_iov(key_serial_t id , struct iovec  const  *payload_iov ,
                                   unsigned int ioc , key_serial_t ringid ) ;
#line 157
extern int keyctl_describe_alloc(key_serial_t id , char **_buffer ) ;
#line 158
extern int keyctl_read_alloc(key_serial_t id , void **_buffer ) ;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 779 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 60 "/home/wheatley/newnew/temp/keyutils-1.5.6/key.dns_resolver.c"
static char const   *DNS_PARSE_VERSION  =    "1.0";
#line 61 "/home/wheatley/newnew/temp/keyutils-1.5.6/key.dns_resolver.c"
static char const   prog[17]  = 
#line 61
  {      (char const   )'k',      (char const   )'e',      (char const   )'y',      (char const   )'.', 
        (char const   )'d',      (char const   )'n',      (char const   )'s',      (char const   )'_', 
        (char const   )'r',      (char const   )'e',      (char const   )'s',      (char const   )'o', 
        (char const   )'l',      (char const   )'v',      (char const   )'e',      (char const   )'r', 
        (char const   )'\000'};
#line 62 "/home/wheatley/newnew/temp/keyutils-1.5.6/key.dns_resolver.c"
static char const   key_type[13]  = 
#line 62
  {      (char const   )'d',      (char const   )'n',      (char const   )'s',      (char const   )'_', 
        (char const   )'r',      (char const   )'e',      (char const   )'s',      (char const   )'o', 
        (char const   )'l',      (char const   )'v',      (char const   )'e',      (char const   )'r', 
        (char const   )'\000'};
#line 63 "/home/wheatley/newnew/temp/keyutils-1.5.6/key.dns_resolver.c"
static char const   a_query_type[2]  = {      (char const   )'a',      (char const   )'\000'};
#line 64 "/home/wheatley/newnew/temp/keyutils-1.5.6/key.dns_resolver.c"
static char const   aaaa_query_type[5]  = {      (char const   )'a',      (char const   )'a',      (char const   )'a',      (char const   )'a', 
        (char const   )'\000'};
#line 65 "/home/wheatley/newnew/temp/keyutils-1.5.6/key.dns_resolver.c"
static char const   afsdb_query_type[6]  = {      (char const   )'a',      (char const   )'f',      (char const   )'s',      (char const   )'d', 
        (char const   )'b',      (char const   )'\000'};
#line 66 "/home/wheatley/newnew/temp/keyutils-1.5.6/key.dns_resolver.c"
static key_serial_t key  ;
#line 67 "/home/wheatley/newnew/temp/keyutils-1.5.6/key.dns_resolver.c"
static int verbose  ;
#line 68 "/home/wheatley/newnew/temp/keyutils-1.5.6/key.dns_resolver.c"
static int debug_mode  ;
#line 88 "/home/wheatley/newnew/temp/keyutils-1.5.6/key.dns_resolver.c"
struct iovec payload[256]  ;
#line 89 "/home/wheatley/newnew/temp/keyutils-1.5.6/key.dns_resolver.c"
int payload_index  ;
#line 95
static  __attribute__((__noreturn__)) void ( /* format attribute */  error)(char const   *fmt 
                                                                            , ...) ;
#line 95 "/home/wheatley/newnew/temp/keyutils-1.5.6/key.dns_resolver.c"
static void ( /* format attribute */  error)(char const   *fmt  , ...) 
{ 
  va_list va ;
  int tmp ;

  {
  {
#line 100
  __builtin_va_start(va, fmt);
#line 101
  tmp = isatty(2);
  }
#line 101
  if (tmp) {
    {
#line 102
    vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
             va);
#line 103
    fputc('\n', stderr);
    }
  } else {
    {
#line 105
    vsyslog(3, fmt, va);
    }
  }
  {
#line 107
  __builtin_va_end(va);
  }
#line 114
  if (! debug_mode) {
    {
#line 115
    keyctl_negate(key, 1U, 0);
    }
  }
  {
#line 117
  exit(1);
  }
}
}
#line 125 "/home/wheatley/newnew/temp/keyutils-1.5.6/key.dns_resolver.c"
static void ( /* format attribute */  _error)(char const   *fmt  , ...) 
{ 
  va_list va ;
  int tmp ;

  {
  {
#line 130
  __builtin_va_start(va, fmt);
#line 131
  tmp = isatty(2);
  }
#line 131
  if (tmp) {
    {
#line 132
    vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
             va);
#line 133
    fputc('\n', stderr);
    }
  } else {
    {
#line 135
    vsyslog(3, fmt, va);
    }
  }
  {
#line 137
  __builtin_va_end(va);
  }
#line 138
  return;
}
}
#line 143 "/home/wheatley/newnew/temp/keyutils-1.5.6/key.dns_resolver.c"
static void ( /* format attribute */  info)(char const   *fmt  , ...) 
{ 
  va_list va ;
  int tmp ;

  {
#line 148
  if (verbose < 1) {
#line 149
    return;
  }
  {
#line 151
  __builtin_va_start(va, fmt);
#line 152
  tmp = isatty(1);
  }
#line 152
  if (tmp) {
    {
#line 153
    fputs((char const   */* __restrict  */)"I: ", (FILE */* __restrict  */)stdout);
#line 154
    vfprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)fmt,
             va);
#line 155
    fputc('\n', stdout);
    }
  } else {
    {
#line 157
    vsyslog(6, fmt, va);
    }
  }
  {
#line 159
  __builtin_va_end(va);
  }
#line 160
  return;
}
}
#line 165 "/home/wheatley/newnew/temp/keyutils-1.5.6/key.dns_resolver.c"
static int const   ns_errno_map[5]  = {      (int const   )111,      (int const   )61,      (int const   )11,      (int const   )111, 
        (int const   )61};
#line 173
static  __attribute__((__noreturn__)) void nsError(int err , char const   *domain ) ;
#line 173 "/home/wheatley/newnew/temp/keyutils-1.5.6/key.dns_resolver.c"
static void nsError(int err , char const   *domain ) 
{ 
  unsigned int timeout ;
  int ret ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
#line 176
  timeout = 60U;
#line 179
  tmp___1 = isatty(2);
  }
#line 179
  if (tmp___1) {
    {
#line 180
    tmp = hstrerror(err);
#line 180
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s.\n",
            domain, tmp);
    }
  } else {
    {
#line 182
    tmp___0 = hstrerror(err);
#line 182
    syslog(6, "%s: %s", domain, tmp___0);
    }
  }
#line 184
  if ((unsigned long )err >= sizeof(ns_errno_map) / sizeof(ns_errno_map[0])) {
#line 185
    err = 111;
  } else {
#line 187
    err = (int )ns_errno_map[err];
  }
  {
#line 189
  info("Reject the key with error %d", err);
  }
#line 191
  if (err == 11) {
#line 192
    timeout = 1U;
  } else
#line 193
  if (err == 111) {
#line 194
    timeout = 10U;
  }
#line 196
  if (! debug_mode) {
    {
#line 197
    tmp___2 = keyctl_reject(key, timeout, (unsigned int )err, 0);
#line 197
    ret = (int )tmp___2;
    }
#line 198
    if (ret == -1) {
      {
#line 199
      error("Error: %s: keyctl_reject: %m", "nsError");
      }
    }
  }
  {
#line 201
  exit(0);
  }
}
}
#line 207 "/home/wheatley/newnew/temp/keyutils-1.5.6/key.dns_resolver.c"
static void ( /* format attribute */  debug)(char const   *fmt  , ...) 
{ 
  va_list va ;
  int tmp ;

  {
#line 212
  if (verbose < 2) {
#line 213
    return;
  }
  {
#line 215
  __builtin_va_start(va, fmt);
#line 216
  tmp = isatty(1);
  }
#line 216
  if (tmp) {
    {
#line 217
    fputs((char const   */* __restrict  */)"D: ", (FILE */* __restrict  */)stdout);
#line 218
    vfprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)fmt,
             va);
#line 219
    fputc('\n', stdout);
    }
  } else {
    {
#line 221
    vsyslog(7, fmt, va);
    }
  }
  {
#line 223
  __builtin_va_end(va);
  }
#line 224
  return;
}
}
#line 229 "/home/wheatley/newnew/temp/keyutils-1.5.6/key.dns_resolver.c"
static void append_address_to_payload(char *p , size_t sz ) 
{ 
  int loop ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 233
  debug("append \'%*.*s\'", (int )sz, (int )sz, p);
#line 236
  loop = 0;
  }
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
#line 236
    if (! (loop < payload_index)) {
#line 236
      goto while_break;
    }
#line 237
    if (payload[loop].iov_len == sz) {
      {
#line 237
      tmp = memcmp((void const   *)payload[loop].iov_base, (void const   *)p, sz);
      }
#line 237
      if (tmp == 0) {
#line 239
        return;
      }
    }
#line 236
    loop ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 241
  if (payload_index != 0) {
#line 242
    if (payload_index + 2 > 255) {
#line 243
      return;
    }
#line 244
    payload[payload_index].iov_base = (void *)",";
#line 245
    tmp___0 = payload_index;
#line 245
    payload_index ++;
#line 245
    payload[tmp___0].iov_len = (size_t )1;
  } else
#line 247
  if (payload_index + 1 > 255) {
#line 248
    return;
  }
#line 251
  payload[payload_index].iov_base = (void *)p;
#line 252
  tmp___1 = payload_index;
#line 252
  payload_index ++;
#line 252
  payload[tmp___1].iov_len = sz;
#line 253
  return;
}
}
#line 258 "/home/wheatley/newnew/temp/keyutils-1.5.6/key.dns_resolver.c"
static void dump_payload(void) 
{ 
  size_t plen ;
  size_t n ;
  char *buf ;
  char *p ;
  int loop ;
  void *tmp ;

  {
#line 264
  if (debug_mode) {
#line 265
    verbose = 1;
  }
#line 266
  if (verbose < 1) {
#line 267
    return;
  }
#line 269
  plen = (size_t )0;
#line 270
  loop = 0;
  {
#line 270
  while (1) {
    while_continue: /* CIL Label */ ;
#line 270
    if (! (loop < payload_index)) {
#line 270
      goto while_break;
    }
    {
#line 271
    n = payload[loop].iov_len;
#line 272
    debug("seg[%d]: %zu", loop, n);
#line 273
    plen += n;
#line 270
    loop ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 275
  if (plen == 0UL) {
    {
#line 276
    info("The key instantiation data is empty");
    }
#line 277
    return;
  }
  {
#line 280
  debug("total: %zu", plen);
#line 281
  tmp = malloc(plen + 1UL);
#line 281
  buf = (char *)tmp;
  }
#line 282
  if (! buf) {
#line 283
    return;
  }
#line 285
  p = buf;
#line 286
  loop = 0;
  {
#line 286
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 286
    if (! (loop < payload_index)) {
#line 286
      goto while_break___0;
    }
    {
#line 287
    n = payload[loop].iov_len;
#line 288
    memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)payload[loop].iov_base,
           n);
#line 289
    p += n;
#line 286
    loop ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 292
  info("The key instantiation data is \'%s\'", buf);
#line 293
  free((void *)buf);
  }
#line 294
  return;
}
}
#line 300 "/home/wheatley/newnew/temp/keyutils-1.5.6/key.dns_resolver.c"
static int dns_resolver(char const   *server_name , unsigned int mask ) 
{ 
  struct addrinfo hints ;
  struct addrinfo *addr ;
  struct addrinfo *ai ;
  size_t slen ;
  char buf[47] ;
  char *seg ;
  int ret ;
  int len ;
  void *sa ;
  char const   *tmp ;
  char const   *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 309
  debug("Resolve \'%s\' with %x", server_name, mask);
#line 311
  memset((void *)(& hints), 0, sizeof(hints));
  }
  {
#line 313
  if ((mask & 255U) == 1U) {
#line 313
    goto case_1;
  }
#line 314
  if ((mask & 255U) == 2U) {
#line 314
    goto case_2;
  }
#line 315
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 313
  hints.ai_family = 2;
#line 313
  debug("IPv4");
  }
#line 313
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 314
  hints.ai_family = 10;
#line 314
  debug("IPv6");
  }
#line 314
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 315
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 319
  ret = getaddrinfo((char const   */* __restrict  */)server_name, (char const   */* __restrict  */)((void *)0),
                    (struct addrinfo  const  */* __restrict  */)(& hints), (struct addrinfo **/* __restrict  */)(& addr));
  }
#line 320
  if (ret) {
    {
#line 321
    tmp = gai_strerror(ret);
#line 321
    info("unable to resolve hostname: %s [%s]", server_name, tmp);
    }
#line 323
    return (-1);
  }
  {
#line 326
  debug("getaddrinfo = %d", ret);
#line 328
  ai = addr;
  }
  {
#line 328
  while (1) {
    while_continue: /* CIL Label */ ;
#line 328
    if (! ai) {
#line 328
      goto while_break;
    }
    {
#line 329
    debug("RR: %x,%x,%x,%x,%x,%s", ai->ai_flags, ai->ai_family, ai->ai_socktype, ai->ai_protocol,
          ai->ai_addrlen, ai->ai_canonname);
    }
    {
#line 336
    if (ai->ai_family == 2) {
#line 336
      goto case_2___0;
    }
#line 342
    if (ai->ai_family == 10) {
#line 342
      goto case_10;
    }
#line 348
    goto switch_default___0;
    case_2___0: /* CIL Label */ 
#line 337
    if (! (mask & 1U)) {
#line 338
      goto __Cont;
    }
#line 339
    sa = (void *)(& ((struct sockaddr_in *)ai->ai_addr)->sin_addr);
#line 340
    len = 16;
#line 341
    goto switch_break___0;
    case_10: /* CIL Label */ 
#line 343
    if (! (mask & 2U)) {
#line 344
      goto __Cont;
    }
#line 345
    sa = (void *)(& ((struct sockaddr_in6 *)ai->ai_addr)->sin6_addr);
#line 346
    len = 46;
#line 347
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 349
    debug("Address of unknown family %u", addr->ai_family);
    }
#line 350
    goto __Cont;
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 353
    tmp___0 = inet_ntop(ai->ai_family, (void const   */* __restrict  */)sa, (char */* __restrict  */)(buf),
                        (socklen_t )len);
    }
#line 353
    if (! tmp___0) {
      {
#line 354
      error("Error: %s: inet_ntop: %m", "dns_resolver");
      }
    }
    {
#line 356
    slen = strlen((char const   *)(buf));
#line 357
    tmp___1 = malloc(slen);
#line 357
    seg = (char *)tmp___1;
    }
#line 358
    if (! seg) {
      {
#line 359
      error("Error: %s: inet_ntop: %m", "dns_resolver");
      }
    }
    {
#line 360
    memcpy((void */* __restrict  */)seg, (void const   */* __restrict  */)(buf), slen);
#line 361
    append_address_to_payload(seg, slen);
    }
#line 362
    if (mask & 256U) {
#line 363
      goto while_break;
    }
    __Cont: /* CIL Label */ 
#line 328
    ai = ai->ai_next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 366
  freeaddrinfo(addr);
  }
#line 367
  return (0);
}
}
#line 373 "/home/wheatley/newnew/temp/keyutils-1.5.6/key.dns_resolver.c"
static void afsdb_hosts_to_addrs(char **vllist , int *vlsnum , ns_msg handle , ns_sect section ,
                                 unsigned int mask , unsigned long *_ttl ) 
{ 
  int rrnum ;
  ns_rr rr ;
  int subtype ;
  int i ;
  int ret ;
  unsigned int ttl ;
  unsigned int rr_ttl ;
  int tmp ;
  void *tmp___0 ;
  u_int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 383
  ttl = 4294967295U;
#line 385
  debug("AFSDB RR count is %d", (int )handle._counts[section]);
#line 388
  rrnum = 0;
  }
  {
#line 388
  while (1) {
    while_continue: /* CIL Label */ ;
#line 388
    if (! (rrnum < (int )handle._counts[section])) {
#line 388
      goto while_break;
    }
    {
#line 390
    tmp = ns_parserr(& handle, section, rrnum, & rr);
    }
#line 390
    if (tmp) {
      {
#line 391
      _error("ns_parserr failed : %m");
      }
#line 392
      goto __Cont;
    }
#line 396
    if ((unsigned int )((ns_type )((int )rr.type)) == 18U) {
      {
#line 397
      tmp___0 = malloc((size_t )1025);
#line 397
      *(vllist + *vlsnum) = (char *)tmp___0;
      }
#line 398
      if (! *(vllist + *vlsnum)) {
        {
#line 399
        error("Error: Out of memory");
        }
      }
      {
#line 401
      tmp___1 = ns_get16(rr.rdata + 0);
#line 401
      subtype = (int )tmp___1;
#line 404
      tmp___2 = ns_name_uncompress(handle._msg + 0, handle._eom + 0, (rr.rdata + 0) + 2,
                                   *(vllist + *vlsnum), (size_t )1025);
      }
#line 404
      if (tmp___2 < 0) {
        {
#line 409
        error("Error: ns_name_uncompress failed");
        }
      }
#line 411
      rr_ttl = rr.ttl;
#line 412
      if (ttl > rr_ttl) {
#line 413
        ttl = rr_ttl;
      }
#line 419
      i = 0;
      {
#line 419
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 419
        if (! (i < *vlsnum)) {
#line 419
          goto while_break___0;
        }
        {
#line 420
        tmp___3 = strcasecmp((char const   *)*(vllist + i), (char const   *)*(vllist + *vlsnum));
        }
#line 420
        if (tmp___3 == 0) {
#line 421
          goto next_one;
        }
#line 419
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 424
      ret = dns_resolver((char const   *)*(vllist + *vlsnum), mask);
      }
#line 425
      if (ret) {
        {
#line 426
        debug("AFSDB RR can\'t resolve.subtype:%d, server name:%s, netmask:%u", subtype,
              *(vllist + *vlsnum), mask);
        }
#line 429
        goto next_one;
      }
      {
#line 432
      info("AFSDB RR subtype:%d, server name:%s, ip:%*.*s, ttl:%u", subtype, *(vllist + *vlsnum),
           (int )payload[payload_index - 1].iov_len, (int )payload[payload_index - 1].iov_len,
           (char *)payload[payload_index - 1].iov_base, ttl);
#line 440
      (*vlsnum) ++;
      }
#line 441
      goto __Cont;
      next_one: 
      {
#line 444
      free((void *)*(vllist + *vlsnum));
      }
    }
    __Cont: /* CIL Label */ 
#line 388
    rrnum ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 448
  *_ttl = (unsigned long )ttl;
#line 449
  info("ttl: %u", ttl);
  }
#line 450
  return;
}
}
#line 458
static  __attribute__((__noreturn__)) int dns_query_afsdb(key_serial_t key___0 , char const   *cell ,
                                                          char *options ) ;
#line 458 "/home/wheatley/newnew/temp/keyutils-1.5.6/key.dns_resolver.c"
static int dns_query_afsdb(key_serial_t key___0 , char const   *cell , char *options ) 
{ 
  int ret ;
  char *vllist[15] ;
  int vlsnum ;
  unsigned int mask ;
  int response_len ;
  ns_msg handle ;
  unsigned long ttl ;
  union __anonunion_response_68 response ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;

  {
  {
#line 463
  vlsnum = 0;
#line 464
  mask = 255U;
#line 467
  ttl = 0xffffffffffffffffUL;
#line 473
  debug("Get AFSDB RR for cell name:\'%s\', options:\'%s\'", cell, options);
#line 476
  response_len = __res_query(cell, 1, 18, response.buf, (int )sizeof(response));
  }
#line 482
  if (response_len < 0) {
    {
#line 484
    tmp = __h_errno_location();
#line 484
    nsError(*tmp, cell);
    }
  }
  {
#line 486
  tmp___0 = ns_initparse((u_char const   *)(response.buf), response_len, & handle);
  }
#line 486
  if (tmp___0 < 0) {
    {
#line 487
    error("Error: ns_initparse: %m");
    }
  }
  {
#line 490
  tmp___2 = strcmp((char const   *)options, "ipv4");
  }
#line 490
  if (tmp___2 == 0) {
#line 491
    mask = 1U;
  } else {
    {
#line 492
    tmp___1 = strcmp((char const   *)options, "ipv6");
    }
#line 492
    if (tmp___1 == 0) {
#line 493
      mask = 2U;
    }
  }
  {
#line 496
  afsdb_hosts_to_addrs(vllist, & vlsnum, handle, (ns_sect )1, mask, & ttl);
#line 498
  info("DNS query AFSDB RR results:%u ttl:%lu", payload_index, ttl);
  }
#line 501
  if (! debug_mode) {
    {
#line 502
    tmp___3 = keyctl_set_timeout(key___0, (unsigned int )ttl);
#line 502
    ret = (int )tmp___3;
    }
#line 503
    if (ret == -1) {
      {
#line 504
      error("Error: %s: keyctl_set_timeout: %m", "dns_query_afsdb");
      }
    }
  }
#line 508
  if (payload_index == 0) {
    {
#line 509
    nsError(4, cell);
    }
  }
  {
#line 512
  payload[payload_index].iov_base = (void *)"";
#line 513
  tmp___4 = payload_index;
#line 513
  payload_index ++;
#line 513
  payload[tmp___4].iov_len = (size_t )1;
#line 514
  dump_payload();
  }
#line 517
  if (! debug_mode) {
    {
#line 518
    tmp___5 = keyctl_instantiate_iov(key___0, (struct iovec  const  *)(payload), (unsigned int )payload_index,
                                     0);
#line 518
    ret = (int )tmp___5;
    }
#line 519
    if (ret == -1) {
      {
#line 520
      error("Error: %s: keyctl_instantiate: %m", "dns_query_afsdb");
      }
    }
  }
  {
#line 523
  exit(0);
  }
}
}
#line 533
static  __attribute__((__noreturn__)) int dns_query_a_or_aaaa(key_serial_t key___0 ,
                                                              char const   *hostname ,
                                                              char *options ) ;
#line 533 "/home/wheatley/newnew/temp/keyutils-1.5.6/key.dns_resolver.c"
static int dns_query_a_or_aaaa(key_serial_t key___0 , char const   *hostname , char *options ) 
{ 
  unsigned int mask ;
  int ret ;
  char *key___1 ;
  char *val ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;

  {
  {
#line 539
  debug("Get A/AAAA RR for hostname:\'%s\', options:\'%s\'", hostname, options);
  }
#line 542
  if (! *(options + 0)) {
#line 544
    mask = 257U;
  } else {
#line 548
    mask = 511U;
    {
#line 550
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 551
      key___1 = options;
#line 552
      options = strchr((char const   *)options, ' ');
      }
#line 553
      if (! options) {
        {
#line 554
        tmp = strlen((char const   *)key___1);
#line 554
        options = key___1 + tmp;
        }
      } else {
#line 556
        tmp___0 = options;
#line 556
        options ++;
#line 556
        *tmp___0 = (char )'\000';
      }
#line 557
      if (! *key___1) {
#line 558
        goto __Cont;
      }
      {
#line 559
      tmp___1 = strchr((char const   *)key___1, ',');
      }
#line 559
      if (tmp___1) {
        {
#line 560
        error("Error: Option name \'%s\' contains a comma", key___1);
        }
      }
      {
#line 562
      val = strchr((char const   *)key___1, '=');
      }
#line 563
      if (val) {
#line 564
        tmp___2 = val;
#line 564
        val ++;
#line 564
        *tmp___2 = (char )'\000';
      }
      {
#line 566
      debug("Opt %s", key___1);
#line 568
      tmp___5 = strcmp((char const   *)key___1, "ipv4");
      }
#line 568
      if (tmp___5 == 0) {
#line 569
        mask &= 4294967040U;
#line 570
        mask |= 1U;
      } else {
        {
#line 571
        tmp___4 = strcmp((char const   *)key___1, "ipv6");
        }
#line 571
        if (tmp___4 == 0) {
#line 572
          mask &= 4294967040U;
#line 573
          mask |= 2U;
        } else {
          {
#line 574
          tmp___3 = strcmp((char const   *)key___1, "list");
          }
#line 574
          if (tmp___3 == 0) {
#line 575
            mask &= 4294967039U;
#line 576
            mask |= 512U;
          }
        }
      }
      __Cont: /* CIL Label */ 
#line 550
      if (! *options) {
#line 550
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 583
  ret = dns_resolver(hostname, mask);
  }
#line 584
  if (ret) {
    {
#line 585
    nsError(4, hostname);
    }
  }
#line 588
  if (payload_index == 0) {
    {
#line 589
    nsError(4, hostname);
    }
  }
  {
#line 592
  payload[payload_index].iov_base = (void *)"";
#line 593
  tmp___6 = payload_index;
#line 593
  payload_index ++;
#line 593
  payload[tmp___6].iov_len = (size_t )1;
#line 594
  dump_payload();
  }
#line 597
  if (! debug_mode) {
    {
#line 598
    tmp___7 = keyctl_instantiate_iov(key___0, (struct iovec  const  *)(payload), (unsigned int )payload_index,
                                     0);
#line 598
    ret = (int )tmp___7;
    }
#line 599
    if (ret == -1) {
      {
#line 600
      error("Error: %s: keyctl_instantiate: %m", "dns_query_a_or_aaaa");
      }
    }
  }
  {
#line 603
  exit(0);
  }
}
}
#line 609
static  __attribute__((__noreturn__)) void usage(void) ;
#line 609 "/home/wheatley/newnew/temp/keyutils-1.5.6/key.dns_resolver.c"
static void usage(void) 
{ 
  int tmp ;

  {
  {
#line 612
  tmp = isatty(2);
  }
#line 612
  if (tmp) {
    {
#line 613
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s [-vv] key_serial\n",
            prog);
#line 616
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s -D [-vv] <desc> <calloutinfo>\n",
            prog);
    }
  } else {
    {
#line 620
    info("Usage: %s [-vv] key_serial", prog);
    }
  }
#line 622
  if (! debug_mode) {
    {
#line 623
    keyctl_negate(key, 1U, 0);
    }
  }
  {
#line 624
  exit(2);
  }
}
}
#line 627 "/home/wheatley/newnew/temp/keyutils-1.5.6/key.dns_resolver.c"
struct option  const  long_options[4]  = {      {"debug", 0, (int *)((void *)0), 'D'}, 
        {"verbose", 0, (int *)((void *)0), 'v'}, 
        {"version", 0, (int *)((void *)0), 'V'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), 0}};
#line 637 "/home/wheatley/newnew/temp/keyutils-1.5.6/key.dns_resolver.c"
int main(int argc , char **argv ) 
{ 
  int ktlen ;
  int qtlen ;
  int ret ;
  char *keyend ;
  char *p ;
  char *callout_info ;
  char *buf ;
  char *name ;
  int tmp ;
  int *tmp___0 ;
  long tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 641
  callout_info = (char *)((void *)0);
#line 642
  buf = (char *)((void *)0);
#line 644
  openlog(prog, 0, 3 << 3);
  }
  {
#line 646
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 646
    ret = getopt_long(argc, (char * const  *)argv, "vD", long_options, (int *)((void *)0));
    }
#line 646
    if (! (ret != -1)) {
#line 646
      goto while_break;
    }
    {
#line 648
    if (ret == 68) {
#line 648
      goto case_68;
    }
#line 651
    if (ret == 86) {
#line 651
      goto case_86;
    }
#line 657
    if (ret == 118) {
#line 657
      goto case_118;
    }
#line 660
    goto switch_default;
    case_68: /* CIL Label */ 
#line 649
    debug_mode = 1;
#line 650
    goto while_continue;
    case_86: /* CIL Label */ 
    {
#line 652
    printf((char const   */* __restrict  */)"version: %s from %s (%s)\n", DNS_PARSE_VERSION,
           keyutils_version_string, keyutils_build_string);
#line 656
    exit(0);
    }
    case_118: /* CIL Label */ 
#line 658
    verbose ++;
#line 659
    goto while_continue;
    switch_default: /* CIL Label */ 
    {
#line 661
    tmp = isatty(2);
    }
#line 661
    if (! tmp) {
      {
#line 662
      syslog(3, "unknown option: %c", ret);
      }
    }
    {
#line 663
    usage();
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 667
  argc -= optind;
#line 668
  argv += optind;
#line 670
  if (! debug_mode) {
#line 671
    if (argc != 1) {
      {
#line 672
      usage();
      }
    }
    {
#line 675
    tmp___0 = __errno_location();
#line 675
    *tmp___0 = 0;
#line 676
    tmp___1 = strtol((char const   */* __restrict  */)*argv, (char **/* __restrict  */)((void *)0),
                     10);
#line 676
    key = (key_serial_t )tmp___1;
#line 677
    tmp___2 = __errno_location();
    }
#line 677
    if (*tmp___2 != 0) {
      {
#line 678
      error("Error: Invalid key ID format: %m");
      }
    }
#line 681
    if (! buf) {
      {
#line 682
      ret = keyctl_describe_alloc(key, & buf);
      }
#line 683
      if (ret == -1) {
        {
#line 684
        error("Error: keyctl_describe_alloc failed: %m");
        }
      }
    }
#line 688
    if (! callout_info) {
      {
#line 689
      ret = keyctl_read_alloc(-7, (void **)(& callout_info));
      }
#line 691
      if (ret == -1) {
        {
#line 692
        error("Error: Invalid key callout_info read: %m");
        }
      }
    }
  } else {
#line 695
    if (argc != 2) {
      {
#line 696
      usage();
      }
    }
    {
#line 698
    ret = asprintf((char **/* __restrict  */)(& buf), (char const   */* __restrict  */)"%s;-1;-1;0;%s",
                   key_type, *(argv + 0));
    }
#line 699
    if (ret < 0) {
      {
#line 700
      error("Error: Error %m");
      }
    }
#line 701
    callout_info = *(argv + 1);
  }
  {
#line 704
  ret = 1;
#line 705
  info("Key description: \'%s\'", buf);
#line 706
  info("Callout info: \'%s\'", callout_info);
#line 708
  p = strchr((char const   *)buf, ';');
  }
#line 709
  if (! p) {
    {
#line 710
    error("Error: Badly formatted key description \'%s\'", buf);
    }
  }
#line 711
  ktlen = (int )(p - buf);
#line 714
  if ((unsigned long )ktlen != sizeof(key_type) - 1UL) {
    {
#line 716
    error("Error: Key type is not supported: \'%*.*s\'", ktlen, ktlen, buf);
    }
  } else {
    {
#line 714
    tmp___3 = memcmp((void const   *)buf, (void const   *)(key_type), (size_t )ktlen);
    }
#line 714
    if (tmp___3 != 0) {
      {
#line 716
      error("Error: Key type is not supported: \'%*.*s\'", ktlen, ktlen, buf);
      }
    }
  }
  {
#line 718
  keyend = (buf + ktlen) + 1;
#line 721
  keyend = rindex((char const   *)keyend, ';');
  }
#line 722
  if (! keyend) {
    {
#line 723
    error("Error: Invalid key description: %s", buf);
    }
  }
  {
#line 724
  keyend ++;
#line 726
  name = index((char const   *)keyend, ':');
  }
#line 727
  if (! name) {
    {
#line 728
    dns_query_a_or_aaaa(key, (char const   *)keyend, callout_info);
    }
  }
#line 730
  qtlen = (int )(name - keyend);
#line 731
  name ++;
#line 733
  if ((unsigned long )qtlen == sizeof(a_query_type) - 1UL) {
    {
#line 733
    tmp___4 = memcmp((void const   *)keyend, (void const   *)(a_query_type), sizeof(a_query_type) - 1UL);
    }
#line 733
    if (tmp___4 == 0) {
      {
#line 738
      info("Do DNS query of A/AAAA type for:\'%s\' mask:\'%s\'", name, callout_info);
#line 740
      dns_query_a_or_aaaa(key, (char const   *)name, callout_info);
      }
    } else {
#line 733
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 733
  if ((unsigned long )qtlen == sizeof(aaaa_query_type) - 1UL) {
    {
#line 733
    tmp___5 = memcmp((void const   *)keyend, (void const   *)(aaaa_query_type), sizeof(aaaa_query_type) - 1UL);
    }
#line 733
    if (tmp___5 == 0) {
      {
#line 738
      info("Do DNS query of A/AAAA type for:\'%s\' mask:\'%s\'", name, callout_info);
#line 740
      dns_query_a_or_aaaa(key, (char const   *)name, callout_info);
      }
    }
  }
#line 743
  if ((unsigned long )qtlen == sizeof(afsdb_query_type) - 1UL) {
    {
#line 743
    tmp___6 = memcmp((void const   *)keyend, (void const   *)(afsdb_query_type), sizeof(afsdb_query_type) - 1UL);
    }
#line 743
    if (tmp___6 == 0) {
      {
#line 746
      info("Do DNS query of AFSDB type for:\'%s\' mask:\'%s\'", name, callout_info);
#line 748
      dns_query_afsdb(key, (char const   *)name, callout_info);
      }
    }
  }
  {
#line 751
  error("Error: Query type: \"%*.*s\" is not supported", qtlen, qtlen, keyend);
  }
}
}
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 96
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memchr)(void const   *__s ,
                                                                                               int __c ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 175 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void closelog(void) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 417
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 531
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup)(int __fd ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 563
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execv)(char const   *__path ,
                                                                                              char * const  *__argv ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 146
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 110 "/home/wheatley/newnew/temp/keyutils-1.5.6/keyutils.h"
extern key_serial_t request_key(char const   *type , char const   *description , char const   *callout_info ,
                                key_serial_t destringid ) ;
#line 135
extern long keyctl_instantiate(key_serial_t id , void const   *payload , size_t plen ,
                               key_serial_t ringid ) ;
#line 142
extern long keyctl_assume_authority(key_serial_t key ) ;
#line 35 "/home/wheatley/newnew/temp/keyutils-1.5.6/request-key.c"
static int xdebug  ;
#line 36 "/home/wheatley/newnew/temp/keyutils-1.5.6/request-key.c"
static int xnolog  ;
#line 37 "/home/wheatley/newnew/temp/keyutils-1.5.6/request-key.c"
static char *xkey  ;
#line 38 "/home/wheatley/newnew/temp/keyutils-1.5.6/request-key.c"
static char *xuid  ;
#line 39 "/home/wheatley/newnew/temp/keyutils-1.5.6/request-key.c"
static char *xgid  ;
#line 40 "/home/wheatley/newnew/temp/keyutils-1.5.6/request-key.c"
static char *xthread_keyring  ;
#line 41 "/home/wheatley/newnew/temp/keyutils-1.5.6/request-key.c"
static char *xprocess_keyring  ;
#line 42 "/home/wheatley/newnew/temp/keyutils-1.5.6/request-key.c"
static char *xsession_keyring  ;
#line 43 "/home/wheatley/newnew/temp/keyutils-1.5.6/request-key.c"
static char conffile[256]  ;
#line 44 "/home/wheatley/newnew/temp/keyutils-1.5.6/request-key.c"
static int confline  ;
#line 45 "/home/wheatley/newnew/temp/keyutils-1.5.6/request-key.c"
static int norecurse  ;
#line 47
static  __attribute__((__noreturn__)) void lookup_action(char *op , key_serial_t key___0 ,
                                                         char *ktype , char *kdesc ,
                                                         char *callout_info ) ;
#line 54
static  __attribute__((__noreturn__)) void execute_program(char *op , key_serial_t key___0 ,
                                                           char *ktype , char *kdesc ,
                                                           char *callout_info , char *cmdline ) ;
#line 62
static  __attribute__((__noreturn__)) void pipe_to_program(char *op , key_serial_t key___0 ,
                                                           char *ktype , char *kdesc ,
                                                           char *callout_info , char *prog___0 ,
                                                           char **argv ) ;
#line 71
static int match(char const   *pattern , int plen , char const   *datum , int dlen ) ;
#line 73
static void ( /* format attribute */  debug___0)(char const   *fmt  , ...) ;
#line 74 "/home/wheatley/newnew/temp/keyutils-1.5.6/request-key.c"
static void ( /* format attribute */  debug___0)(char const   *fmt  , ...) 
{ 
  va_list va ;

  {
#line 78
  if (xdebug) {
    {
#line 79
    __builtin_va_start(va, fmt);
#line 80
    vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
             va);
#line 81
    __builtin_va_end(va);
    }
#line 83
    if (! xnolog) {
      {
#line 84
      openlog("request-key", 0, 10 << 3);
#line 86
      __builtin_va_start(va, fmt);
#line 87
      vsyslog(7, fmt, va);
#line 88
      __builtin_va_end(va);
#line 90
      closelog();
      }
    }
  }
#line 93
  return;
}
}
#line 95
static  __attribute__((__noreturn__)) void ( /* format attribute */  error___0)(char const   *fmt 
                                                                                , ...) ;
#line 96
static  __attribute__((__noreturn__)) void ( /* format attribute */  error___0)(char const   *fmt 
                                                                                , ...) ;
#line 96 "/home/wheatley/newnew/temp/keyutils-1.5.6/request-key.c"
static void ( /* format attribute */  error___0)(char const   *fmt  , ...) 
{ 
  va_list va ;

  {
#line 100
  if (xdebug) {
    {
#line 101
    __builtin_va_start(va, fmt);
#line 102
    vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
             va);
#line 103
    __builtin_va_end(va);
    }
  }
#line 106
  if (! xnolog) {
    {
#line 107
    openlog("request-key", 0, 10 << 3);
#line 109
    __builtin_va_start(va, fmt);
#line 110
    vsyslog(3, fmt, va);
#line 111
    __builtin_va_end(va);
#line 113
    closelog();
    }
  }
  {
#line 116
  exit(1);
  }
}
}
#line 122 "/home/wheatley/newnew/temp/keyutils-1.5.6/request-key.c"
static void oops(int x ) 
{ 


  {
  {
#line 124
  error___0("Died on signal %d", x);
  }
}
}
#line 253
static  __attribute__((__noreturn__)) void lookup_action(char *op , key_serial_t key___0 ,
                                                         char *ktype , char *kdesc ,
                                                         char *callout_info ) ;
#line 253 "/home/wheatley/newnew/temp/keyutils-1.5.6/request-key.c"
static void lookup_action(char *op , key_serial_t key___0 , char *ktype , char *kdesc ,
                          char *callout_info ) 
{ 
  char buf[4098] ;
  char *p ;
  char *q ;
  FILE *conf ;
  int len ;
  int oplen ;
  int ktlen ;
  int kdlen ;
  int cilen ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int *tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  size_t tmp___7 ;
  unsigned short const   **tmp___8 ;
  unsigned short const   **tmp___9 ;
  int tmp___10 ;
  unsigned short const   **tmp___11 ;
  unsigned short const   **tmp___12 ;
  int tmp___13 ;
  unsigned short const   **tmp___14 ;
  unsigned short const   **tmp___15 ;
  int tmp___16 ;
  unsigned short const   **tmp___17 ;
  unsigned short const   **tmp___18 ;
  int tmp___19 ;
  unsigned short const   **tmp___20 ;

  {
  {
#line 263
  tmp = strlen((char const   *)op);
#line 263
  oplen = (int )tmp;
#line 264
  tmp___0 = strlen((char const   *)ktype);
#line 264
  ktlen = (int )tmp___0;
#line 265
  tmp___1 = strlen((char const   *)kdesc);
#line 265
  kdlen = (int )tmp___1;
#line 266
  tmp___2 = strlen((char const   *)callout_info);
#line 266
  cilen = (int )tmp___2;
#line 269
  tmp___4 = strlen((char const   *)ktype);
  }
#line 269
  if (tmp___4 <= sizeof(conffile) - 30UL) {
#line 270
    if (xdebug < 2) {
      {
#line 271
      snprintf((char */* __restrict  */)(conffile), sizeof(conffile) - 1UL, (char const   */* __restrict  */)"/etc/request-key.d/%s.conf",
               ktype);
      }
    } else {
      {
#line 274
      snprintf((char */* __restrict  */)(conffile), sizeof(conffile) - 1UL, (char const   */* __restrict  */)"request-key.d/%s.conf",
               ktype);
      }
    }
    {
#line 276
    conf = fopen((char const   */* __restrict  */)(conffile), (char const   */* __restrict  */)"r");
    }
#line 277
    if (conf) {
#line 278
      goto opened_conf_file;
    }
    {
#line 279
    tmp___3 = __errno_location();
    }
#line 279
    if (*tmp___3 != 2) {
      {
#line 280
      error___0("Cannot open %s: %m\n", conffile);
      }
    }
  }
#line 283
  if (xdebug < 2) {
    {
#line 284
    snprintf((char */* __restrict  */)(conffile), sizeof(conffile) - 1UL, (char const   */* __restrict  */)"/etc/request-key.conf");
    }
  } else {
    {
#line 286
    snprintf((char */* __restrict  */)(conffile), sizeof(conffile) - 1UL, (char const   */* __restrict  */)"request-key.conf");
    }
  }
  {
#line 287
  conf = fopen((char const   */* __restrict  */)(conffile), (char const   */* __restrict  */)"r");
  }
#line 288
  if (! conf) {
    {
#line 289
    error___0("Cannot open %s: %m\n", conffile);
    }
  }
  opened_conf_file: 
  {
#line 292
  debug___0("Opened config file \'%s\'\n", conffile);
#line 294
  confline = 1;
  }
  {
#line 294
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 296
    tmp___6 = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)conf);
    }
#line 296
    if (! tmp___6) {
      {
#line 297
      tmp___5 = feof(conf);
      }
#line 297
      if (tmp___5) {
        {
#line 298
        error___0("Cannot find command to construct key %d\n", key___0);
        }
      }
      {
#line 299
      error___0("%s: error %m\n", conffile);
      }
    }
    {
#line 302
    tmp___7 = strlen((char const   *)(buf));
#line 302
    len = (int )tmp___7;
    }
#line 303
    if ((unsigned long )len >= sizeof(buf) - 2UL) {
      {
#line 304
      error___0("%s:%d: Line too long\n", conffile, confline);
      }
    }
#line 307
    if (len == 1) {
#line 308
      goto __Cont;
    } else
#line 307
    if ((int )buf[0] == 35) {
#line 308
      goto __Cont;
    } else {
      {
#line 307
      tmp___8 = __ctype_b_loc();
      }
#line 307
      if ((int const   )*(*tmp___8 + (int )buf[0]) & 8192) {
#line 308
        goto __Cont;
      }
    }
#line 310
    len --;
#line 310
    buf[len] = (char)0;
#line 311
    p = buf;
#line 314
    q = p;
    {
#line 315
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 315
      if (*p) {
        {
#line 315
        tmp___9 = __ctype_b_loc();
        }
#line 315
        if ((int const   )*(*tmp___9 + (int )*p) & 8192) {
#line 315
          goto while_break___0;
        }
      } else {
#line 315
        goto while_break___0;
      }
#line 315
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 316
    if (! *p) {
#line 317
      goto syntax_error;
    }
    {
#line 318
    *p = (char)0;
#line 320
    tmp___10 = match((char const   *)q, (int )(p - q), (char const   *)op, oplen);
    }
#line 320
    if (! tmp___10) {
#line 321
      goto __Cont;
    }
#line 323
    p ++;
    {
#line 326
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 326
      tmp___11 = __ctype_b_loc();
      }
#line 326
      if (! ((int const   )*(*tmp___11 + (int )*p) & 8192)) {
#line 326
        goto while_break___1;
      }
#line 326
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 327
    if (! *p) {
#line 328
      goto syntax_error;
    }
#line 330
    q = p;
    {
#line 331
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 331
      if (*p) {
        {
#line 331
        tmp___12 = __ctype_b_loc();
        }
#line 331
        if ((int const   )*(*tmp___12 + (int )*p) & 8192) {
#line 331
          goto while_break___2;
        }
      } else {
#line 331
        goto while_break___2;
      }
#line 331
      p ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 332
    if (! *p) {
#line 333
      goto syntax_error;
    }
    {
#line 334
    *p = (char)0;
#line 336
    tmp___13 = match((char const   *)q, (int )(p - q), (char const   *)ktype, ktlen);
    }
#line 336
    if (! tmp___13) {
#line 337
      goto __Cont;
    }
#line 339
    p ++;
    {
#line 342
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 342
      tmp___14 = __ctype_b_loc();
      }
#line 342
      if (! ((int const   )*(*tmp___14 + (int )*p) & 8192)) {
#line 342
        goto while_break___3;
      }
#line 342
      p ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 343
    if (! *p) {
#line 344
      goto syntax_error;
    }
#line 346
    q = p;
    {
#line 347
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 347
      if (*p) {
        {
#line 347
        tmp___15 = __ctype_b_loc();
        }
#line 347
        if ((int const   )*(*tmp___15 + (int )*p) & 8192) {
#line 347
          goto while_break___4;
        }
      } else {
#line 347
        goto while_break___4;
      }
#line 347
      p ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 348
    if (! *p) {
#line 349
      goto syntax_error;
    }
    {
#line 350
    *p = (char)0;
#line 352
    tmp___16 = match((char const   *)q, (int )(p - q), (char const   *)kdesc, kdlen);
    }
#line 352
    if (! tmp___16) {
#line 353
      goto __Cont;
    }
#line 355
    p ++;
    {
#line 358
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 358
      tmp___17 = __ctype_b_loc();
      }
#line 358
      if (! ((int const   )*(*tmp___17 + (int )*p) & 8192)) {
#line 358
        goto while_break___5;
      }
#line 358
      p ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 359
    if (! *p) {
#line 360
      goto syntax_error;
    }
#line 362
    q = p;
    {
#line 363
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 363
      if (*p) {
        {
#line 363
        tmp___18 = __ctype_b_loc();
        }
#line 363
        if ((int const   )*(*tmp___18 + (int )*p) & 8192) {
#line 363
          goto while_break___6;
        }
      } else {
#line 363
        goto while_break___6;
      }
#line 363
      p ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 364
    if (! *p) {
#line 365
      goto syntax_error;
    }
    {
#line 366
    *p = (char)0;
#line 368
    tmp___19 = match((char const   *)q, (int )(p - q), (char const   *)callout_info,
                     cilen);
    }
#line 368
    if (! tmp___19) {
#line 369
      goto __Cont;
    }
    {
#line 371
    p ++;
#line 373
    debug___0("%s:%d: Line matches\n", conffile, confline);
    }
    {
#line 376
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 376
      tmp___20 = __ctype_b_loc();
      }
#line 376
      if (! ((int const   )*(*tmp___20 + (int )*p) & 8192)) {
#line 376
        goto while_break___7;
      }
#line 376
      p ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 377
    if (! *p) {
#line 378
      goto syntax_error;
    }
    {
#line 380
    fclose(conf);
#line 382
    execute_program(op, key___0, ktype, kdesc, callout_info, p);
    }
    __Cont: /* CIL Label */ 
#line 294
    confline ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 385
  error___0("%s: No matching action\n", conffile);
  }
  syntax_error: 
  {
#line 388
  error___0("%s:%d: Syntax error\n", conffile, confline);
  }
}
}
#line 398 "/home/wheatley/newnew/temp/keyutils-1.5.6/request-key.c"
static int match(char const   *pattern , int plen , char const   *datum , int dlen ) 
{ 
  char const   *asterisk ;
  int n ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 403
  debug___0("match(%*.*s,%*.*s)\n", plen, plen, pattern, dlen, dlen, datum);
#line 405
  tmp = memchr((void const   *)pattern, '*', (size_t )plen);
#line 405
  asterisk = (char const   *)tmp;
  }
#line 406
  if (! asterisk) {
#line 408
    if (plen == dlen) {
      {
#line 408
      tmp___0 = memcmp((void const   *)pattern, (void const   *)datum, (size_t )dlen);
      }
#line 408
      if (tmp___0 == 0) {
#line 409
        goto yes;
      }
    }
#line 410
    goto no;
  }
#line 414
  if (dlen < plen - 1) {
#line 415
    goto no;
  }
#line 417
  n = (int )(asterisk - pattern);
#line 418
  if (n == 0) {
#line 420
    pattern ++;
#line 421
    if (! *pattern) {
#line 422
      goto yes;
    }
    {
#line 425
    plen --;
#line 426
    tmp___1 = memcmp((void const   *)pattern, (void const   *)(datum + (dlen - plen)),
                     (size_t )plen);
    }
#line 426
    if (tmp___1 == 0) {
#line 427
      goto yes;
    }
#line 428
    goto no;
  }
  {
#line 432
  tmp___2 = memcmp((void const   *)pattern, (void const   *)datum, (size_t )n);
  }
#line 432
  if (tmp___2 != 0) {
#line 433
    goto no;
  }
#line 435
  if (! *(asterisk + 1)) {
#line 436
    goto yes;
  }
  {
#line 439
  asterisk ++;
#line 440
  n = (plen - n) - 1;
#line 441
  tmp___3 = memcmp((void const   *)pattern, (void const   *)(datum + (dlen - n)),
                   (size_t )n);
  }
#line 441
  if (tmp___3 == 0) {
#line 442
    goto yes;
  }
  no: 
  {
#line 445
  debug___0(" = no\n");
  }
#line 446
  return (0);
  yes: 
  {
#line 449
  debug___0(" = yes\n");
  }
#line 450
  return (1);
}
}
#line 458
static  __attribute__((__noreturn__)) void execute_program(char *op , key_serial_t key___0 ,
                                                           char *ktype , char *kdesc ,
                                                           char *callout_info , char *cmdline ) ;
#line 458 "/home/wheatley/newnew/temp/keyutils-1.5.6/request-key.c"
static void execute_program(char *op , key_serial_t key___0 , char *ktype , char *kdesc ,
                            char *callout_info , char *cmdline ) 
{ 
  char *argv[256] ;
  char *prog___0 ;
  char *p ;
  char *q ;
  int argc ;
  int pipeit ;
  unsigned short const   **tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  char *tmp___4 ;
  key_serial_t keysub ;
  void *tmp___5 ;
  char *ksdesc ;
  char *end ;
  char *subdata ;
  int ret ;
  int loop ;
  char *tmp___6 ;
  char *tmp___7 ;
  unsigned short const   **tmp___8 ;
  char **ap ;
  char const   *tmp___9 ;

  {
  {
#line 469
  debug___0("execute_program(\'%s\',\'%s\')\n", callout_info, cmdline);
#line 474
  pipeit = 0;
  }
#line 476
  if ((int )*(cmdline + 0) == 124) {
#line 477
    pipeit = 1;
#line 478
    cmdline ++;
  }
#line 482
  p = cmdline;
#line 482
  prog___0 = p;
  {
#line 483
  while (1) {
    while_continue: /* CIL Label */ ;
#line 483
    if (*p) {
      {
#line 483
      tmp = __ctype_b_loc();
      }
#line 483
      if ((int const   )*(*tmp + (int )*p) & 8192) {
#line 483
        goto while_break;
      }
    } else {
#line 483
      goto while_break;
    }
#line 483
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 487
  if (*p) {
#line 488
    tmp___0 = p;
#line 488
    p ++;
#line 488
    *tmp___0 = (char)0;
  }
  {
#line 490
  tmp___1 = strrchr((char const   *)prog___0, '/');
#line 490
  argv[0] = tmp___1 + 1;
#line 493
  argc = 1;
  }
  {
#line 493
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 493
    if (! p) {
#line 493
      goto while_break___0;
    }
    {
#line 494
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 494
      tmp___2 = __ctype_b_loc();
      }
#line 494
      if (! ((int const   )*(*tmp___2 + (int )*p) & 8192)) {
#line 494
        goto while_break___1;
      }
#line 494
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 495
    if (! *p) {
#line 496
      goto while_break___0;
    }
#line 498
    if (argc >= 254) {
      {
#line 499
      error___0("%s:%d: Too many arguments\n", conffile, confline);
      }
    }
#line 500
    q = p;
#line 500
    argv[argc] = q;
    {
#line 502
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 502
      if (*p) {
        {
#line 502
        tmp___3 = __ctype_b_loc();
        }
#line 502
        if ((int const   )*(*tmp___3 + (int )*p) & 8192) {
#line 502
          goto while_break___2;
        }
      } else {
#line 502
        goto while_break___2;
      }
#line 502
      p ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 504
    if (*p) {
#line 505
      tmp___4 = p;
#line 505
      p ++;
#line 505
      *tmp___4 = (char)0;
    } else {
#line 507
      p = (char *)((void *)0);
    }
    {
#line 509
    debug___0("argv[%d]: \'%s\'\n", argc, argv[argc]);
    }
#line 511
    if ((int )*q != 37) {
#line 512
      goto __Cont;
    }
#line 515
    q ++;
#line 516
    if (! *q) {
      {
#line 517
      error___0("%s:%d: Missing macro name\n", conffile, confline);
      }
    }
#line 519
    if ((int )*q == 37) {
#line 521
      (argv[argc]) ++;
#line 522
      goto __Cont;
    }
#line 526
    if (! *(q + 1)) {
      {
#line 528
      if ((int )*q == 111) {
#line 528
        goto case_111;
      }
#line 529
      if ((int )*q == 107) {
#line 529
        goto case_107;
      }
#line 530
      if ((int )*q == 116) {
#line 530
        goto case_116;
      }
#line 531
      if ((int )*q == 100) {
#line 531
        goto case_100;
      }
#line 532
      if ((int )*q == 99) {
#line 532
        goto case_99;
      }
#line 533
      if ((int )*q == 117) {
#line 533
        goto case_117;
      }
#line 534
      if ((int )*q == 103) {
#line 534
        goto case_103;
      }
#line 535
      if ((int )*q == 84) {
#line 535
        goto case_84;
      }
#line 536
      if ((int )*q == 80) {
#line 536
        goto case_80;
      }
#line 537
      if ((int )*q == 83) {
#line 537
        goto case_83;
      }
#line 538
      goto switch_default;
      case_111: /* CIL Label */ 
#line 528
      argv[argc] = op;
#line 528
      goto __Cont;
      case_107: /* CIL Label */ 
#line 529
      argv[argc] = xkey;
#line 529
      goto __Cont;
      case_116: /* CIL Label */ 
#line 530
      argv[argc] = ktype;
#line 530
      goto __Cont;
      case_100: /* CIL Label */ 
#line 531
      argv[argc] = kdesc;
#line 531
      goto __Cont;
      case_99: /* CIL Label */ 
#line 532
      argv[argc] = callout_info;
#line 532
      goto __Cont;
      case_117: /* CIL Label */ 
#line 533
      argv[argc] = xuid;
#line 533
      goto __Cont;
      case_103: /* CIL Label */ 
#line 534
      argv[argc] = xgid;
#line 534
      goto __Cont;
      case_84: /* CIL Label */ 
#line 535
      argv[argc] = xthread_keyring;
#line 535
      goto __Cont;
      case_80: /* CIL Label */ 
#line 536
      argv[argc] = xprocess_keyring;
#line 536
      goto __Cont;
      case_83: /* CIL Label */ 
#line 537
      argv[argc] = xsession_keyring;
#line 537
      goto __Cont;
      switch_default: /* CIL Label */ 
      {
#line 539
      error___0("%s:%d: Unsupported macro\n", conffile, confline);
      }
      switch_break: /* CIL Label */ ;
      }
    }
#line 544
    if ((int )*q == 123) {
      {
#line 551
      q ++;
#line 552
      ksdesc = strchr((char const   *)q, ':');
      }
#line 553
      if (! ksdesc) {
        {
#line 554
        error___0("%s:%d: Keysub macro lacks \':\'\n", conffile, confline);
        }
      }
      {
#line 555
      tmp___6 = ksdesc;
#line 555
      ksdesc ++;
#line 555
      *tmp___6 = (char)0;
#line 556
      end = strchr((char const   *)ksdesc, '}');
      }
#line 557
      if (! end) {
        {
#line 558
        error___0("%s:%d: Unterminated keysub macro\n", conffile, confline);
        }
      }
#line 560
      tmp___7 = end;
#line 560
      end ++;
#line 560
      *tmp___7 = (char)0;
#line 561
      if (*end) {
        {
#line 562
        error___0("%s:%d: Keysub macro has trailing rubbish\n", conffile, confline);
        }
      }
      {
#line 564
      debug___0("Keysub: %s key \"%s\"\n", q, ksdesc);
      }
#line 566
      if (! *(q + 0)) {
        {
#line 567
        error___0("%s:%d: Keysub type empty\n", conffile, confline);
        }
      }
#line 569
      if (! *(ksdesc + 0)) {
        {
#line 570
        error___0("%s:%d: Keysub description empty\n", conffile, confline);
        }
      }
      {
#line 575
      keysub = request_key((char const   *)q, (char const   *)ksdesc, (char const   *)((void *)0),
                           0);
      }
#line 576
      if (keysub < 0) {
        {
#line 577
        error___0("%s:%d: Keysub key not found: %m\n", conffile, confline);
        }
      }
      {
#line 579
      ret = keyctl_read_alloc(keysub, & tmp___5);
      }
#line 580
      if (ret < 0) {
        {
#line 581
        error___0("%s:%d: Can\'t read keysub %d data: %m\n", conffile, confline, keysub);
        }
      }
#line 582
      subdata = (char *)tmp___5;
#line 584
      loop = 0;
      {
#line 584
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 584
        if (! (loop < ret)) {
#line 584
          goto while_break___3;
        }
        {
#line 585
        tmp___8 = __ctype_b_loc();
        }
#line 585
        if (! ((int const   )*(*tmp___8 + (int )*(subdata + loop)) & 16384)) {
          {
#line 586
          error___0("keysub %d data not printable (\'%02hhx\')\n", keysub, (int )*(subdata + loop));
          }
        }
#line 584
        loop ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 589
      argv[argc] = subdata;
#line 590
      goto __Cont;
    }
    __Cont: /* CIL Label */ 
#line 493
    argc ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 594
  if (argc == 0) {
    {
#line 595
    error___0("%s:%d: No arguments\n", conffile, confline);
    }
  }
#line 597
  argv[argc] = (char *)((void *)0);
#line 599
  if (xdebug) {
#line 602
    if (pipeit) {
#line 602
      tmp___9 = "PipeThru";
    } else {
#line 602
      tmp___9 = "Run";
    }
    {
#line 602
    debug___0("%s %s\n", tmp___9, prog___0);
#line 603
    ap = argv;
    }
    {
#line 603
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 603
      if (! *ap) {
#line 603
        goto while_break___4;
      }
      {
#line 604
      debug___0("- argv[%td] = \"%s\"\n", ap - argv, *ap);
#line 603
      ap ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 614
  if (pipeit) {
    {
#line 615
    pipe_to_program(op, key___0, ktype, kdesc, callout_info, prog___0, argv);
    }
  }
  {
#line 618
  execv((char const   *)prog___0, (char * const  *)(argv));
#line 620
  error___0("%s:%d: Failed to execute \'%s\': %m\n", conffile, confline, prog___0);
  }
}
}
#line 629
static  __attribute__((__noreturn__)) void pipe_to_program(char *op , key_serial_t key___0 ,
                                                           char *ktype , char *kdesc ,
                                                           char *callout_info , char *prog___0 ,
                                                           char **argv ) ;
#line 629 "/home/wheatley/newnew/temp/keyutils-1.5.6/request-key.c"
static void pipe_to_program(char *op , key_serial_t key___0 , char *ktype , char *kdesc ,
                            char *callout_info , char *prog___0 , char **argv ) 
{ 
  char errbuf[512] ;
  char payload___0[32769] ;
  char *pp ;
  char *pc ;
  char *pe ;
  int ipi[2] ;
  int opi[2] ;
  int epi[2] ;
  int childpid ;
  int ifl ;
  int ofl ;
  int efl ;
  int npay ;
  int ninfo ;
  int espace ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  fd_set rfds ;
  fd_set wfds ;
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;
  ssize_t tmp___10 ;
  int *tmp___11 ;
  ssize_t tmp___12 ;
  char *nl ;
  ssize_t tmp___13 ;
  int n ;
  int rest ;
  void *tmp___14 ;
  int n___0 ;
  __pid_t tmp___15 ;
  union __anonunion_53 __constr_expr_0 ;
  union __anonunion_54 __constr_expr_1 ;
  union __anonunion_55 __constr_expr_2 ;
  union __anonunion_56 __constr_expr_3 ;
  union __anonunion_57 __constr_expr_4 ;
  union __anonunion_58 __constr_expr_5 ;
  union __anonunion_59 __constr_expr_6 ;
  long tmp___16 ;

  {
  {
#line 641
  debug___0("pipe_to_program(%s -> %s)", callout_info, prog___0);
#line 643
  tmp___0 = pipe((int *)(ipi));
  }
#line 643
  if (tmp___0 < 0) {
    {
#line 644
    error___0("pipe failed: %m");
    }
  } else {
    {
#line 643
    tmp___1 = pipe((int *)(opi));
    }
#line 643
    if (tmp___1 < 0) {
      {
#line 644
      error___0("pipe failed: %m");
      }
    } else {
      {
#line 643
      tmp___2 = pipe((int *)(epi));
      }
#line 643
      if (tmp___2 < 0) {
        {
#line 644
        error___0("pipe failed: %m");
        }
      }
    }
  }
  {
#line 646
  childpid = fork();
  }
#line 647
  if (childpid == -1) {
    {
#line 648
    error___0("fork failed: %m");
    }
  }
#line 650
  if (childpid == 0) {
    {
#line 652
    tmp___3 = dup2(ipi[0], 0);
    }
#line 652
    if (tmp___3 < 0) {
      {
#line 655
      error___0("dup2 failed: %m");
      }
    } else {
      {
#line 652
      tmp___4 = dup2(opi[1], 1);
      }
#line 652
      if (tmp___4 < 0) {
        {
#line 655
        error___0("dup2 failed: %m");
        }
      } else {
        {
#line 652
        tmp___5 = dup2(epi[1], 2);
        }
#line 652
        if (tmp___5 < 0) {
          {
#line 655
          error___0("dup2 failed: %m");
          }
        }
      }
    }
    {
#line 656
    close(ipi[0]);
#line 657
    close(ipi[1]);
#line 658
    close(opi[0]);
#line 659
    close(opi[1]);
#line 660
    close(epi[0]);
#line 661
    close(epi[1]);
#line 663
    execv((char const   *)prog___0, (char * const  *)argv);
#line 664
    error___0("%s:%d: Failed to execute \'%s\': %m\n", conffile, confline, prog___0);
    }
  }
  {
#line 668
  close(ipi[0]);
#line 669
  close(opi[1]);
#line 670
  close(epi[1]);
#line 676
  ifl = fcntl(ipi[1], 3);
#line 677
  ofl = fcntl(opi[0], 3);
#line 678
  efl = fcntl(epi[0], 3);
  }
#line 679
  if (ifl < 0) {
    {
#line 680
    error___0("fcntl/F_GETFL failed: %m");
    }
  } else
#line 679
  if (ofl < 0) {
    {
#line 680
    error___0("fcntl/F_GETFL failed: %m");
    }
  } else
#line 679
  if (efl < 0) {
    {
#line 680
    error___0("fcntl/F_GETFL failed: %m");
    }
  }
  {
#line 682
  ifl |= 2048;
#line 683
  ofl |= 2048;
#line 684
  efl |= 2048;
#line 686
  tmp___6 = fcntl(ipi[1], 4, ifl);
  }
#line 686
  if (tmp___6 < 0) {
    {
#line 689
    error___0("fcntl/F_SETFL failed: %m");
    }
  } else {
    {
#line 686
    tmp___7 = fcntl(opi[0], 4, ofl);
    }
#line 686
    if (tmp___7 < 0) {
      {
#line 689
      error___0("fcntl/F_SETFL failed: %m");
      }
    } else {
      {
#line 686
      tmp___8 = fcntl(epi[0], 4, efl);
      }
#line 686
      if (tmp___8 < 0) {
        {
#line 689
        error___0("fcntl/F_SETFL failed: %m");
        }
      }
    }
  }
  {
#line 691
  tmp___9 = strlen((char const   *)callout_info);
#line 691
  ninfo = (int )tmp___9;
#line 692
  pc = callout_info;
#line 694
  npay = (int )sizeof(payload___0);
#line 695
  pp = payload___0;
#line 697
  espace = (int )sizeof(errbuf);
#line 698
  pe = errbuf;
  }
  {
#line 700
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 703
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 703
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& rfds.__fds_bits[0]): "memory");
#line 703
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 704
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 704
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& wfds.__fds_bits[0]): "memory");
#line 704
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 706
    if (ipi[1] != -1) {
#line 707
      if (ninfo > 0) {
#line 708
        wfds.__fds_bits[ipi[1] / (8 * (int )sizeof(__fd_mask ))] |= 1L << ipi[1] % (8 * (int )sizeof(__fd_mask ));
      } else {
        {
#line 711
        close(ipi[1]);
#line 712
        ipi[1] = -1;
        }
#line 713
        goto __Cont;
      }
    }
#line 717
    if (opi[0] != -1) {
#line 718
      rfds.__fds_bits[opi[0] / (8 * (int )sizeof(__fd_mask ))] |= 1L << opi[0] % (8 * (int )sizeof(__fd_mask ));
    }
#line 720
    if (epi[0] != -1) {
#line 721
      rfds.__fds_bits[epi[0] / (8 * (int )sizeof(__fd_mask ))] |= 1L << epi[0] % (8 * (int )sizeof(__fd_mask ));
    }
#line 723
    if (ipi[1] > opi[0]) {
#line 723
      tmp = ipi[1];
    } else {
#line 723
      tmp = opi[0];
    }
#line 724
    if (tmp > epi[0]) {
#line 724
      tmp = tmp;
    } else {
#line 724
      tmp = epi[0];
    }
    {
#line 725
    tmp ++;
#line 727
    debug___0("select r=%d,%d w=%d m=%d\n", opi[0], epi[0], ipi[1], tmp);
#line 729
    tmp = select(tmp, (fd_set */* __restrict  */)(& rfds), (fd_set */* __restrict  */)(& wfds),
                 (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)((void *)0));
    }
#line 730
    if (tmp < 0) {
      {
#line 731
      error___0("select failed: %m\n");
      }
    }
#line 733
    if (ipi[1] != -1) {
#line 733
      if ((wfds.__fds_bits[ipi[1] / (8 * (int )sizeof(__fd_mask ))] & (1L << ipi[1] % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 734
        tmp___10 = write(ipi[1], (void const   *)pc, (size_t )ninfo);
#line 734
        tmp = (int )tmp___10;
        }
#line 735
        if (tmp < 0) {
          {
#line 736
          tmp___11 = __errno_location();
          }
#line 736
          if (*tmp___11 != 32) {
            {
#line 737
            error___0("write failed: %m\n");
            }
          }
          {
#line 739
          debug___0("EPIPE");
#line 740
          ninfo = 0;
          }
        } else {
          {
#line 743
          debug___0("wrote %d\n", tmp);
#line 745
          pc += tmp;
#line 746
          ninfo -= tmp;
          }
        }
      }
    }
#line 750
    if (opi[0] != -1) {
#line 750
      if ((rfds.__fds_bits[opi[0] / (8 * (int )sizeof(__fd_mask ))] & (1L << opi[0] % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 751
        tmp___12 = read(opi[0], (void *)pp, (size_t )npay);
#line 751
        tmp = (int )tmp___12;
        }
#line 752
        if (tmp < 0) {
          {
#line 753
          error___0("read failed: %m\n");
          }
        }
        {
#line 755
        debug___0("read %d\n", tmp);
        }
#line 757
        if (tmp == 0) {
          {
#line 758
          close(opi[0]);
#line 759
          opi[0] = -1;
          }
        } else {
#line 762
          pp += tmp;
#line 763
          npay -= tmp;
#line 765
          if (npay == 0) {
            {
#line 766
            error___0("Too much data read from query program\n");
            }
          }
        }
      }
    }
#line 770
    if (epi[0] != -1) {
#line 770
      if ((rfds.__fds_bits[epi[0] / (8 * (int )sizeof(__fd_mask ))] & (1L << epi[0] % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 773
        tmp___13 = read(epi[0], (void *)pe, (size_t )espace);
#line 773
        tmp = (int )tmp___13;
        }
#line 774
        if (tmp < 0) {
          {
#line 775
          error___0("read failed: %m\n");
          }
        }
        {
#line 777
        debug___0("read err %d\n", tmp);
        }
#line 779
        if (tmp == 0) {
          {
#line 780
          close(epi[0]);
#line 781
          epi[0] = -1;
          }
#line 782
          goto __Cont;
        }
#line 785
        pe += tmp;
#line 786
        espace -= tmp;
        {
#line 788
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 788
          tmp___14 = memchr((void const   *)(errbuf), '\n', (size_t )(pe - errbuf));
#line 788
          nl = (char *)tmp___14;
          }
#line 788
          if (! nl) {
#line 788
            goto while_break___2;
          }
#line 791
          nl ++;
#line 792
          n = (int )(nl - errbuf);
#line 794
          if (xdebug) {
            {
#line 795
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Child: %*.*s",
                    n, n, errbuf);
            }
          }
#line 797
          if (! xnolog) {
            {
#line 798
            openlog("request-key", 0, 10 << 3);
#line 799
            syslog(3, "Child: %*.*s", n, n, errbuf);
#line 800
            closelog();
            }
          }
#line 803
          rest = (int )(pe - nl);
#line 804
          if (rest > 0) {
            {
#line 805
            memmove((void *)(errbuf), (void const   *)nl, (size_t )rest);
#line 806
            pe -= n;
#line 807
            espace += n;
            }
          } else {
#line 810
            pe = errbuf;
#line 811
            espace = (int )sizeof(errbuf);
          }
        }
        while_break___2: /* CIL Label */ ;
        }
#line 815
        if (espace == 0) {
#line 816
          n___0 = (int )sizeof(errbuf);
#line 818
          if (xdebug) {
            {
#line 819
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Child: %*.*s",
                    n___0, n___0, errbuf);
            }
          }
#line 821
          if (! xnolog) {
            {
#line 822
            openlog("request-key", 0, 10 << 3);
#line 823
            syslog(3, "Child: %*.*s", n___0, n___0, errbuf);
#line 824
            closelog();
            }
          }
#line 827
          pe = errbuf;
#line 828
          espace = (int )sizeof(errbuf);
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 700
    if (! (ipi[1] != -1)) {
#line 700
      if (! (opi[0] != -1)) {
#line 700
        if (! (epi[0] != -1)) {
#line 700
          goto while_break;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 835
  tmp___15 = waitpid(childpid, & tmp, 0);
  }
#line 835
  if (tmp___15 != childpid) {
    {
#line 836
    error___0("wait for child failed: %m\n");
    }
  }
#line 843
  __constr_expr_2.__in = tmp;
#line 843
  if ((__constr_expr_2.__i & 127) == 0) {
#line 843
    __constr_expr_3.__in = tmp;
#line 843
    if ((__constr_expr_3.__i & 65280) >> 8 != 0) {
#line 844
      if (norecurse) {
        {
#line 845
        __constr_expr_0.__in = tmp;
#line 845
        error___0("child exited %d\n", (__constr_expr_0.__i & 65280) >> 8);
        }
      }
      {
#line 847
      norecurse = 1;
#line 848
      __constr_expr_1.__in = tmp;
#line 848
      debug___0("child exited %d\n", (__constr_expr_1.__i & 65280) >> 8);
#line 849
      lookup_action((char *)"negate", key___0, ktype, kdesc, callout_info);
      }
    }
  }
#line 852
  __constr_expr_6.__in = tmp;
#line 852
  if ((int )((signed char )((__constr_expr_6.__i & 127) + 1)) >> 1 > 0) {
#line 853
    if (norecurse) {
      {
#line 854
      __constr_expr_4.__in = tmp;
#line 854
      error___0("child died on signal %d\n", __constr_expr_4.__i & 127);
      }
    }
    {
#line 856
    norecurse = 1;
#line 857
    __constr_expr_5.__in = tmp;
#line 857
    debug___0("child died on signal %d\n", __constr_expr_5.__i & 127);
#line 858
    lookup_action((char *)"negate", key___0, ktype, kdesc, callout_info);
    }
  }
  {
#line 862
  debug___0("instantiate with %td bytes\n", pp - payload___0);
#line 864
  tmp___16 = keyctl_instantiate(key___0, (void const   *)(payload___0), (size_t )(pp - payload___0),
                                0);
  }
#line 864
  if (tmp___16 < 0L) {
    {
#line 865
    error___0("instantiate key failed: %m\n");
    }
  }
  {
#line 867
  debug___0("instantiation successful\n");
#line 868
  exit(0);
  }
}
}
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 580
extern int putchar(int __c ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 187 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 121 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memrchr)(void const   *__s ,
                                                                                                int __c ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 538
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 573 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execl)(char const   *__path ,
                                                                                              char const   *__arg 
                                                                                              , ...) ;
#line 578
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execvp)(char const   *__file ,
                                                                                               char * const  *__argv ) ;
#line 678
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 684
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getegid)(void) ;
#line 689
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getgroups)(int __size ,
                                                                                __gid_t *__list ) ;
#line 104 "/home/wheatley/newnew/temp/keyutils-1.5.6/keyutils.h"
extern key_serial_t add_key(char const   *type , char const   *description , void const   *payload ,
                            size_t plen , key_serial_t ringid ) ;
#line 120
extern key_serial_t keyctl_get_keyring_ID(key_serial_t id , int create ) ;
#line 121
extern key_serial_t keyctl_join_session_keyring(char const   *name ) ;
#line 122
extern long keyctl_update(key_serial_t id , void const   *payload , size_t plen ) ;
#line 123
extern long keyctl_revoke(key_serial_t id ) ;
#line 124
extern long keyctl_chown(key_serial_t id , uid_t uid , gid_t gid ) ;
#line 125
extern long keyctl_setperm(key_serial_t id , key_perm_t perm ) ;
#line 126
extern long keyctl_describe(key_serial_t id , char *buffer , size_t buflen ) ;
#line 127
extern long keyctl_clear(key_serial_t ringid ) ;
#line 128
extern long keyctl_link(key_serial_t id , key_serial_t ringid ) ;
#line 129
extern long keyctl_unlink(key_serial_t id , key_serial_t ringid ) ;
#line 130
extern long keyctl_search(key_serial_t ringid , char const   *type , char const   *description ,
                          key_serial_t destringid ) ;
#line 134
extern long keyctl_read(key_serial_t id , char *buffer , size_t buflen ) ;
#line 144
extern long keyctl_session_to_parent(void) ;
#line 152
extern long keyctl_invalidate(key_serial_t id ) ;
#line 159
extern int keyctl_get_security_alloc(key_serial_t id , char **_buffer ) ;
#line 164
extern int recursive_session_key_scan(int (*func)(key_serial_t parent , key_serial_t key ,
                                                  char *desc , int desc_len , void *data ) ,
                                      void *data ) ;
#line 30 "/home/wheatley/newnew/temp/keyutils-1.5.6/keyctl.c"
static int act_keyctl___version(int argc , char **argv ) ;
#line 31
static int act_keyctl_show(int argc , char **argv ) ;
#line 32
static int act_keyctl_add(int argc , char **argv ) ;
#line 33
static int act_keyctl_padd(int argc , char **argv ) ;
#line 34
static int act_keyctl_request(int argc , char **argv ) ;
#line 35
static int act_keyctl_request2(int argc , char **argv ) ;
#line 36
static int act_keyctl_prequest2(int argc , char **argv ) ;
#line 37
static int act_keyctl_update(int argc , char **argv ) ;
#line 38
static int act_keyctl_pupdate(int argc , char **argv ) ;
#line 39
static int act_keyctl_newring(int argc , char **argv ) ;
#line 40
static int act_keyctl_revoke(int argc , char **argv ) ;
#line 41
static int act_keyctl_clear(int argc , char **argv ) ;
#line 42
static int act_keyctl_link(int argc , char **argv ) ;
#line 43
static int act_keyctl_unlink(int argc , char **argv ) ;
#line 44
static int act_keyctl_search(int argc , char **argv ) ;
#line 45
static int act_keyctl_read(int argc , char **argv ) ;
#line 46
static int act_keyctl_pipe(int argc , char **argv ) ;
#line 47
static int act_keyctl_print(int argc , char **argv ) ;
#line 48
static int act_keyctl_list(int argc , char **argv ) ;
#line 49
static int act_keyctl_rlist(int argc , char **argv ) ;
#line 50
static int act_keyctl_describe(int argc , char **argv ) ;
#line 51
static int act_keyctl_rdescribe(int argc , char **argv ) ;
#line 52
static int act_keyctl_chown(int argc , char **argv ) ;
#line 53
static int act_keyctl_chgrp(int argc , char **argv ) ;
#line 54
static int act_keyctl_setperm(int argc , char **argv ) ;
#line 55
static int act_keyctl_session(int argc , char **argv ) ;
#line 56
static int act_keyctl_instantiate(int argc , char **argv ) ;
#line 57
static int act_keyctl_pinstantiate(int argc , char **argv ) ;
#line 58
static int act_keyctl_negate(int argc , char **argv ) ;
#line 59
static int act_keyctl_timeout(int argc , char **argv ) ;
#line 60
static int act_keyctl_security(int argc , char **argv ) ;
#line 61
static int act_keyctl_new_session(int argc , char **argv ) ;
#line 62
static int act_keyctl_reject(int argc , char **argv ) ;
#line 63
static int act_keyctl_reap(int argc , char **argv ) ;
#line 64
static int act_keyctl_purge(int argc , char **argv ) ;
#line 65
static int act_keyctl_invalidate(int argc , char **argv ) ;
#line 67 "/home/wheatley/newnew/temp/keyutils-1.5.6/keyctl.c"
struct command  const  commands[41]  = 
#line 67
  {      {& act_keyctl___version, "--version", ""}, 
        {& act_keyctl_add, "add", "<type> <desc> <data> <keyring>"}, 
        {& act_keyctl_chgrp, "chgrp", "<key> <gid>"}, 
        {& act_keyctl_chown, "chown", "<key> <uid>"}, 
        {& act_keyctl_clear, "clear", "<keyring>"}, 
        {& act_keyctl_describe, "describe", "<keyring>"}, 
        {& act_keyctl_instantiate, "instantiate", "<key> <data> <keyring>"}, 
        {& act_keyctl_invalidate, "invalidate", "<key>"}, 
        {& act_keyctl_link, "link", "<key> <keyring>"}, 
        {& act_keyctl_list, "list", "<keyring>"}, 
        {& act_keyctl_negate, "negate", "<key> <timeout> <keyring>"}, 
        {& act_keyctl_new_session, "new_session", ""}, 
        {& act_keyctl_newring, "newring", "<name> <keyring>"}, 
        {& act_keyctl_padd, "padd", "<type> <desc> <keyring>"}, 
        {& act_keyctl_pinstantiate, "pinstantiate", "<key> <keyring>"}, 
        {& act_keyctl_pipe, "pipe", "<key>"}, 
        {& act_keyctl_prequest2, "prequest2", "<type> <desc> [<dest_keyring>]"}, 
        {& act_keyctl_print, "print", "<key>"}, 
        {& act_keyctl_pupdate, "pupdate", "<key>"}, 
        {& act_keyctl_purge, "purge", "<type>"}, 
        {(int (*)(int argc , char **argv ))((void *)0), "purge", "[-p] [-i] <type> <desc>"}, 
        {(int (*)(int argc ,
               char **argv ))((void *)0), "purge", "-s <type> <desc>"}, 
        {& act_keyctl_rdescribe, "rdescribe", "<keyring> [sep]"}, 
        {& act_keyctl_read, "read", "<key>"}, 
        {& act_keyctl_reap, "reap", "[-v]"}, 
        {& act_keyctl_reject, "reject", "<key> <timeout> <error> <keyring>"}, 
        {& act_keyctl_request, "request", "<type> <desc> [<dest_keyring>]"}, 
        {& act_keyctl_request2, "request2", "<type> <desc> <info> [<dest_keyring>]"}, 
        {& act_keyctl_revoke,
      "revoke", "<key>"}, 
        {& act_keyctl_rlist, "rlist", "<keyring>"}, 
        {& act_keyctl_search, "search", "<keyring> <type> <desc> [<dest_keyring>]"}, 
        {& act_keyctl_security, "security", "<key>"}, 
        {& act_keyctl_session, "session", ""}, 
        {(int (*)(int argc , char **argv ))((void *)0), "session", "- [<prog> <arg1> <arg2> ...]"}, 
        {(int (*)(int argc ,
               char **argv ))((void *)0), "session", "<name> [<prog> <arg1> <arg2> ...]"}, 
        {& act_keyctl_setperm,
      "setperm", "<key> <mask>"}, 
        {& act_keyctl_show, "show", "[-x] [<keyring>]"}, 
        {& act_keyctl_timeout, "timeout", "<key> <timeout>"}, 
        {& act_keyctl_unlink, "unlink", "<key> [<keyring>]"}, 
        {& act_keyctl_update, "update", "<key> <data>"}, 
        {(int (*)(int argc , char **argv ))((void *)0), (char const   *)((void *)0),
      (char const   *)((void *)0)}};
#line 111
static int dump_key_tree(key_serial_t keyring , char const   *name , int hex_key_IDs ) ;
#line 112
static  __attribute__((__noreturn__)) void format(void) ;
#line 113
__inline static  __attribute__((__noreturn__)) void error___1(char const   *msg ) ;
#line 114
static key_serial_t get_key_id(char const   *arg ) ;
#line 116 "/home/wheatley/newnew/temp/keyutils-1.5.6/keyctl.c"
static uid_t myuid  ;
#line 117 "/home/wheatley/newnew/temp/keyutils-1.5.6/keyctl.c"
static gid_t mygid  ;
#line 117 "/home/wheatley/newnew/temp/keyutils-1.5.6/keyctl.c"
static gid_t *mygroups  ;
#line 118 "/home/wheatley/newnew/temp/keyutils-1.5.6/keyctl.c"
static int myngroups  ;
#line 119 "/home/wheatley/newnew/temp/keyutils-1.5.6/keyctl.c"
static int verbose___0  ;
#line 125
__inline static  __attribute__((__noreturn__)) void error___1(char const   *msg ) ;
#line 125 "/home/wheatley/newnew/temp/keyutils-1.5.6/keyctl.c"
__inline static void error___1(char const   *msg ) 
{ 


  {
  {
#line 127
  perror(msg);
#line 128
  exit(1);
  }
}
}
#line 201
static  __attribute__((__noreturn__)) void format(void) ;
#line 201 "/home/wheatley/newnew/temp/keyutils-1.5.6/keyctl.c"
static void format(void) 
{ 
  struct command  const  *cmd ;

  {
  {
#line 205
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Format:\n");
#line 207
  cmd = commands;
  }
  {
#line 207
  while (1) {
    while_continue: /* CIL Label */ ;
#line 207
    if (! cmd->name) {
#line 207
      goto while_break;
    }
    {
#line 208
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  keyctl %s %s\n",
            cmd->name, cmd->format);
#line 207
    cmd ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 210
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 211
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Key/keyring ID:\n");
#line 212
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  <nnn>   numeric keyring ID\n");
#line 213
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  @t      thread keyring\n");
#line 214
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  @p      process keyring\n");
#line 215
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  @s      session keyring\n");
#line 216
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  @u      user keyring\n");
#line 217
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  @us     user default session keyring\n");
#line 218
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  @g      group keyring\n");
#line 219
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  @a      assumed request_key authorisation key\n");
#line 220
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 221
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"<type> can be \"user\" for a user-defined keyring\n");
#line 222
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"If you do this, prefix the description with \"<subtype>:\"\n");
#line 224
  exit(2);
  }
}
}
#line 232 "/home/wheatley/newnew/temp/keyutils-1.5.6/keyctl.c"
static int act_keyctl___version(int argc , char **argv ) 
{ 


  {
  {
#line 234
  printf((char const   */* __restrict  */)"keyctl from %s (Built %s)\n", keyutils_version_string,
         keyutils_build_string);
  }
#line 236
  return (0);
}
}
#line 245 "/home/wheatley/newnew/temp/keyutils-1.5.6/keyctl.c"
static char input[1048577]  ;
#line 243 "/home/wheatley/newnew/temp/keyutils-1.5.6/keyctl.c"
static char *grab_stdin(size_t *_size ) 
{ 
  int n ;
  int tmp ;
  ssize_t tmp___0 ;

  {
#line 248
  n = 0;
  {
#line 249
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 250
    tmp___0 = read(0, (void *)(input + n), (sizeof(input) - 1UL) - (unsigned long )n);
#line 250
    tmp = (int )tmp___0;
    }
#line 251
    if (tmp < 0) {
      {
#line 252
      error___1("stdin");
      }
    }
#line 254
    if (tmp == 0) {
#line 255
      goto while_break;
    }
#line 257
    n += tmp;
#line 249
    if (! ((unsigned long )n < sizeof(input))) {
#line 249
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 261
  if ((unsigned long )n >= sizeof(input)) {
    {
#line 262
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Too much data read on stdin\n");
#line 263
    exit(1);
    }
  }
#line 266
  input[n] = (char )'\000';
#line 267
  *_size = (size_t )n;
#line 269
  return (input);
}
}
#line 278 "/home/wheatley/newnew/temp/keyutils-1.5.6/keyctl.c"
static void calc_perms(char *pretty , key_perm_t perm , uid_t uid , gid_t gid ) 
{ 
  unsigned int perms ;
  gid_t *pg ;
  int loop ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 284
  perms = (perm & 1056964608U) >> 24;
#line 286
  if (uid == myuid) {
#line 287
    perms |= (perm & 4128768U) >> 16;
#line 288
    goto write_mask;
  }
#line 291
  if (gid != 4294967295U) {
#line 292
    if (gid == mygid) {
#line 293
      perms |= (perm & 16128U) >> 8;
#line 294
      goto write_mask;
    }
#line 297
    pg = mygroups;
#line 298
    loop = myngroups;
    {
#line 298
    while (1) {
      while_continue: /* CIL Label */ ;
#line 298
      if (! (loop > 0)) {
#line 298
        goto while_break;
      }
#line 299
      if (gid == *pg) {
#line 300
        perms |= (perm & 16128U) >> 8;
#line 301
        goto write_mask;
      }
#line 298
      loop --;
#line 298
      pg ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 306
  perms |= perm & 63U;
  write_mask: 
#line 309
  if (perms & 1U) {
#line 309
    tmp = 'v';
  } else {
#line 309
    tmp = '-';
  }
#line 309
  if (perms & 2U) {
#line 309
    tmp___0 = 'r';
  } else {
#line 309
    tmp___0 = '-';
  }
#line 309
  if (perms & 4U) {
#line 309
    tmp___1 = 'w';
  } else {
#line 309
    tmp___1 = '-';
  }
#line 309
  if (perms & 8U) {
#line 309
    tmp___2 = 's';
  } else {
#line 309
    tmp___2 = '-';
  }
#line 309
  if (perms & 16U) {
#line 309
    tmp___3 = 'l';
  } else {
#line 309
    tmp___3 = '-';
  }
#line 309
  if (perms & 16U) {
#line 309
    tmp___4 = 'a';
  } else {
#line 309
    tmp___4 = '-';
  }
  {
#line 309
  sprintf((char */* __restrict  */)pretty, (char const   */* __restrict  */)"--%c%c%c%c%c%c",
          tmp___4, tmp___3, tmp___2, tmp___1, tmp___0, tmp);
  }
#line 317
  return;
}
}
#line 323 "/home/wheatley/newnew/temp/keyutils-1.5.6/keyctl.c"
static int act_keyctl_show(int argc , char **argv ) 
{ 
  key_serial_t keyring ;
  int hex_key_IDs ;
  int tmp ;
  char const   *tmp___0 ;

  {
#line 325
  keyring = -3;
#line 326
  hex_key_IDs = 0;
#line 328
  if (argc >= 2) {
    {
#line 328
    tmp = strcmp((char const   *)*(argv + 1), "-x");
    }
#line 328
    if (tmp == 0) {
#line 329
      hex_key_IDs = 1;
#line 330
      argc --;
#line 331
      argv ++;
    }
  }
#line 334
  if (argc > 2) {
    {
#line 335
    format();
    }
  }
#line 337
  if (argc == 2) {
    {
#line 338
    keyring = get_key_id((char const   *)*(argv + 1));
    }
  }
#line 340
  if (argc == 2) {
#line 340
    tmp___0 = "Keyring";
  } else {
#line 340
    tmp___0 = "Session Keyring";
  }
  {
#line 340
  dump_key_tree(keyring, tmp___0, hex_key_IDs);
  }
#line 341
  return (0);
}
}
#line 349 "/home/wheatley/newnew/temp/keyutils-1.5.6/keyctl.c"
static int act_keyctl_add(int argc , char **argv ) 
{ 
  key_serial_t dest ;
  int ret ;
  size_t tmp ;

  {
#line 354
  if (argc != 5) {
    {
#line 355
    format();
    }
  }
  {
#line 357
  dest = get_key_id((char const   *)*(argv + 4));
#line 359
  tmp = strlen((char const   *)*(argv + 3));
#line 359
  ret = add_key((char const   *)*(argv + 1), (char const   *)*(argv + 2), (void const   *)*(argv + 3),
                tmp, dest);
  }
#line 360
  if (ret < 0) {
    {
#line 361
    error___1("add_key");
    }
  }
  {
#line 364
  printf((char const   */* __restrict  */)"%d\n", ret);
  }
#line 365
  return (0);
}
}
#line 373 "/home/wheatley/newnew/temp/keyutils-1.5.6/keyctl.c"
static int act_keyctl_padd(int argc , char **argv ) 
{ 
  key_serial_t dest ;
  size_t datalen ;
  void *data ;
  int ret ;
  char *tmp ;

  {
#line 381
  if (argc != 4) {
    {
#line 382
    format();
    }
  }
  {
#line 384
  dest = get_key_id((char const   *)*(argv + 3));
#line 386
  tmp = grab_stdin(& datalen);
#line 386
  data = (void *)tmp;
#line 388
  ret = add_key((char const   *)*(argv + 1), (char const   *)*(argv + 2), (void const   *)data,
                datalen, dest);
  }
#line 389
  if (ret < 0) {
    {
#line 390
    error___1("add_key");
    }
  }
  {
#line 393
  printf((char const   */* __restrict  */)"%d\n", ret);
  }
#line 394
  return (0);
}
}
#line 402 "/home/wheatley/newnew/temp/keyutils-1.5.6/keyctl.c"
static int act_keyctl_request(int argc , char **argv ) 
{ 
  key_serial_t dest ;
  int ret ;

  {
#line 407
  if (argc != 3) {
#line 407
    if (argc != 4) {
      {
#line 408
      format();
      }
    }
  }
#line 410
  dest = 0;
#line 411
  if (argc == 4) {
    {
#line 412
    dest = get_key_id((char const   *)*(argv + 3));
    }
  }
  {
#line 414
  ret = request_key((char const   *)*(argv + 1), (char const   *)*(argv + 2), (char const   *)((void *)0),
                    dest);
  }
#line 415
  if (ret < 0) {
    {
#line 416
    error___1("request_key");
    }
  }
  {
#line 419
  printf((char const   */* __restrict  */)"%d\n", ret);
  }
#line 420
  return (0);
}
}
#line 428 "/home/wheatley/newnew/temp/keyutils-1.5.6/keyctl.c"
static int act_keyctl_request2(int argc , char **argv ) 
{ 
  key_serial_t dest ;
  int ret ;

  {
#line 433
  if (argc != 4) {
#line 433
    if (argc != 5) {
      {
#line 434
      format();
      }
    }
  }
#line 436
  dest = 0;
#line 437
  if (argc == 5) {
    {
#line 438
    dest = get_key_id((char const   *)*(argv + 4));
    }
  }
  {
#line 440
  ret = request_key((char const   *)*(argv + 1), (char const   *)*(argv + 2), (char const   *)*(argv + 3),
                    dest);
  }
#line 441
  if (ret < 0) {
    {
#line 442
    error___1("request_key");
    }
  }
  {
#line 445
  printf((char const   */* __restrict  */)"%d\n", ret);
  }
#line 446
  return (0);
}
}
#line 455 "/home/wheatley/newnew/temp/keyutils-1.5.6/keyctl.c"
static int act_keyctl_prequest2(int argc , char **argv ) 
{ 
  char *args[6] ;
  size_t datalen ;
  int tmp ;

  {
#line 460
  if (argc != 3) {
#line 460
    if (argc != 4) {
      {
#line 461
      format();
      }
    }
  }
  {
#line 463
  args[0] = *(argv + 0);
#line 464
  args[1] = *(argv + 1);
#line 465
  args[2] = *(argv + 2);
#line 466
  args[3] = grab_stdin(& datalen);
#line 467
  args[4] = *(argv + 3);
#line 468
  args[5] = (char *)((void *)0);
#line 470
  tmp = act_keyctl_request2(argc + 1, args);
  }
#line 470
  return (tmp);
}
}
#line 478 "/home/wheatley/newnew/temp/keyutils-1.5.6/keyctl.c"
static int act_keyctl_update(int argc , char **argv ) 
{ 
  key_serial_t key___0 ;
  size_t tmp ;
  long tmp___0 ;

  {
#line 482
  if (argc != 3) {
    {
#line 483
    format();
    }
  }
  {
#line 485
  key___0 = get_key_id((char const   *)*(argv + 1));
#line 487
  tmp = strlen((char const   *)*(argv + 2));
#line 487
  tmp___0 = keyctl_update(key___0, (void const   *)*(argv + 2), tmp);
  }
#line 487
  if (tmp___0 < 0L) {
    {
#line 488
    error___1("keyctl_update");
    }
  }
#line 490
  return (0);
}
}
#line 498 "/home/wheatley/newnew/temp/keyutils-1.5.6/keyctl.c"
static int act_keyctl_pupdate(int argc , char **argv ) 
{ 
  key_serial_t key___0 ;
  size_t datalen ;
  void *data ;
  char *tmp ;
  long tmp___0 ;

  {
#line 504
  if (argc != 2) {
    {
#line 505
    format();
    }
  }
  {
#line 507
  key___0 = get_key_id((char const   *)*(argv + 1));
#line 508
  tmp = grab_stdin(& datalen);
#line 508
  data = (void *)tmp;
#line 510
  tmp___0 = keyctl_update(key___0, (void const   *)data, datalen);
  }
#line 510
  if (tmp___0 < 0L) {
    {
#line 511
    error___1("keyctl_update");
    }
  }
#line 513
  return (0);
}
}
#line 521 "/home/wheatley/newnew/temp/keyutils-1.5.6/keyctl.c"
static int act_keyctl_newring(int argc , char **argv ) 
{ 
  key_serial_t dest ;
  int ret ;

  {
#line 526
  if (argc != 3) {
    {
#line 527
    format();
    }
  }
  {
#line 529
  dest = get_key_id((char const   *)*(argv + 2));
#line 531
  ret = add_key("keyring", (char const   *)*(argv + 1), (void const   *)((void *)0),
                (size_t )0, dest);
  }
#line 532
  if (ret < 0) {
    {
#line 533
    error___1("add_key");
    }
  }
  {
#line 535
  printf((char const   */* __restrict  */)"%d\n", ret);
  }
#line 536
  return (0);
}
}
#line 544 "/home/wheatley/newnew/temp/keyutils-1.5.6/keyctl.c"
static int act_keyctl_revoke(int argc , char **argv ) 
{ 
  key_serial_t key___0 ;
  long tmp ;

  {
#line 548
  if (argc != 2) {
    {
#line 549
    format();
    }
  }
  {
#line 551
  key___0 = get_key_id((char const   *)*(argv + 1));
#line 553
  tmp = keyctl_revoke(key___0);
  }
#line 553
  if (tmp < 0L) {
    {
#line 554
    error___1("keyctl_revoke");
    }
  }
#line 556
  return (0);
}
}
#line 564 "/home/wheatley/newnew/temp/keyutils-1.5.6/keyctl.c"
static int act_keyctl_clear(int argc , char **argv ) 
{ 
  key_serial_t keyring ;
  long tmp ;

  {
#line 568
  if (argc != 2) {
    {
#line 569
    format();
    }
  }
  {
#line 571
  keyring = get_key_id((char const   *)*(argv + 1));
#line 573
  tmp = keyctl_clear(keyring);
  }
#line 573
  if (tmp < 0L) {
    {
#line 574
    error___1("keyctl_clear");
    }
  }
#line 576
  return (0);
}
}
#line 584 "/home/wheatley/newnew/temp/keyutils-1.5.6/keyctl.c"
static int act_keyctl_link(int argc , char **argv ) 
{ 
  key_serial_t keyring ;
  key_serial_t key___0 ;
  long tmp ;

  {
#line 588
  if (argc != 3) {
    {
#line 589
    format();
    }
  }
  {
#line 591
  key___0 = get_key_id((char const   *)*(argv + 1));
#line 592
  keyring = get_key_id((char const   *)*(argv + 2));
#line 594
  tmp = keyctl_link(key___0, keyring);
  }
#line 594
  if (tmp < 0L) {
    {
#line 595
    error___1("keyctl_link");
    }
  }
#line 597
  return (0);
}
}
#line 604 "/home/wheatley/newnew/temp/keyutils-1.5.6/keyctl.c"
static int act_keyctl_unlink_func(key_serial_t parent , key_serial_t key___0 , char *desc ,
                                  int desc_len , void *data ) 
{ 
  key_serial_t *target ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 607
  target = (key_serial_t *)data;
#line 609
  if (key___0 == *target) {
    {
#line 610
    tmp___1 = keyctl_unlink(key___0, parent);
    }
#line 610
    if (tmp___1 < 0L) {
#line 610
      tmp___0 = 0;
    } else {
#line 610
      tmp___0 = 1;
    }
#line 610
    return (tmp___0);
  }
#line 611
  return (0);
}
}
#line 617 "/home/wheatley/newnew/temp/keyutils-1.5.6/keyctl.c"
static int act_keyctl_unlink(int argc , char **argv ) 
{ 
  key_serial_t keyring ;
  key_serial_t key___0 ;
  int n ;
  long tmp ;

  {
#line 622
  if (argc != 2) {
#line 622
    if (argc != 3) {
      {
#line 623
      format();
      }
    }
  }
  {
#line 625
  key___0 = get_key_id((char const   *)*(argv + 1));
  }
#line 627
  if (argc == 3) {
    {
#line 628
    keyring = get_key_id((char const   *)*(argv + 2));
#line 629
    tmp = keyctl_unlink(key___0, keyring);
    }
#line 629
    if (tmp < 0L) {
      {
#line 630
      error___1("keyctl_unlink");
      }
    }
  } else {
    {
#line 632
    n = recursive_session_key_scan(& act_keyctl_unlink_func, (void *)(& key___0));
#line 633
    printf((char const   */* __restrict  */)"%d links removed\n", n);
    }
  }
#line 636
  return (0);
}
}
#line 643 "/home/wheatley/newnew/temp/keyutils-1.5.6/keyctl.c"
static int act_keyctl_search(int argc , char **argv ) 
{ 
  key_serial_t keyring ;
  key_serial_t dest ;
  int ret ;
  long tmp ;

  {
#line 648
  if (argc != 4) {
#line 648
    if (argc != 5) {
      {
#line 649
      format();
      }
    }
  }
  {
#line 651
  keyring = get_key_id((char const   *)*(argv + 1));
#line 653
  dest = 0;
  }
#line 654
  if (argc == 5) {
    {
#line 655
    dest = get_key_id((char const   *)*(argv + 4));
    }
  }
  {
#line 657
  tmp = keyctl_search(keyring, (char const   *)*(argv + 2), (char const   *)*(argv + 3),
                      dest);
#line 657
  ret = (int )tmp;
  }
#line 658
  if (ret < 0) {
    {
#line 659
    error___1("keyctl_search");
    }
  }
  {
#line 662
  printf((char const   */* __restrict  */)"%d\n", ret);
  }
#line 663
  return (0);
}
}
#line 671 "/home/wheatley/newnew/temp/keyutils-1.5.6/keyctl.c"
static int act_keyctl_read(int argc , char **argv ) 
{ 
  key_serial_t key___0 ;
  void *buffer ;
  char *p ;
  int ret ;
  int sep ;
  int col ;

  {
#line 678
  if (argc != 2) {
    {
#line 679
    format();
    }
  }
  {
#line 681
  key___0 = get_key_id((char const   *)*(argv + 1));
#line 684
  ret = keyctl_read_alloc(key___0, & buffer);
  }
#line 685
  if (ret < 0) {
    {
#line 686
    error___1("keyctl_read_alloc");
    }
  }
#line 688
  if (ret == 0) {
    {
#line 689
    printf((char const   */* __restrict  */)"No data in key\n");
    }
#line 690
    return (0);
  }
  {
#line 694
  printf((char const   */* __restrict  */)"%u bytes of data in key:\n", ret);
#line 696
  sep = 0;
#line 697
  col = 0;
#line 698
  p = (char *)buffer;
  }
  {
#line 700
  while (1) {
    while_continue: /* CIL Label */ ;
#line 701
    if (sep) {
      {
#line 702
      putchar(sep);
#line 703
      sep = 0;
      }
    }
    {
#line 706
    printf((char const   */* __restrict  */)"%02hhx", (int )*p);
#line 707
    p ++;
#line 709
    col ++;
    }
#line 710
    if (col % 32 == 0) {
#line 711
      sep = '\n';
    } else
#line 712
    if (col % 4 == 0) {
#line 713
      sep = ' ';
    }
#line 700
    ret --;
#line 700
    if (! (ret > 0)) {
#line 700
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 717
  printf((char const   */* __restrict  */)"\n");
  }
#line 718
  return (0);
}
}
#line 726 "/home/wheatley/newnew/temp/keyutils-1.5.6/keyctl.c"
static int act_keyctl_pipe(int argc , char **argv ) 
{ 
  key_serial_t key___0 ;
  void *buffer ;
  int ret ;
  ssize_t tmp ;

  {
#line 732
  if (argc != 2) {
    {
#line 733
    format();
    }
  }
  {
#line 735
  key___0 = get_key_id((char const   *)*(argv + 1));
#line 738
  ret = keyctl_read_alloc(key___0, & buffer);
  }
#line 739
  if (ret < 0) {
    {
#line 740
    error___1("keyctl_read_alloc");
    }
  }
#line 742
  if (ret > 0) {
    {
#line 742
    tmp = write(1, (void const   *)buffer, (size_t )ret);
    }
#line 742
    if (tmp < 0L) {
      {
#line 743
      error___1("write");
      }
    }
  }
#line 744
  return (0);
}
}
#line 752 "/home/wheatley/newnew/temp/keyutils-1.5.6/keyctl.c"
static int act_keyctl_print(int argc , char **argv ) 
{ 
  key_serial_t key___0 ;
  void *buffer ;
  char *p ;
  int loop ;
  int ret ;
  unsigned short const   **tmp ;

  {
#line 759
  if (argc != 2) {
    {
#line 760
    format();
    }
  }
  {
#line 762
  key___0 = get_key_id((char const   *)*(argv + 1));
#line 765
  ret = keyctl_read_alloc(key___0, & buffer);
  }
#line 766
  if (ret < 0) {
    {
#line 767
    error___1("keyctl_read_alloc");
    }
  }
#line 770
  p = (char *)buffer;
#line 771
  loop = ret;
  {
#line 771
  while (1) {
    while_continue: /* CIL Label */ ;
#line 771
    if (! (loop > 0)) {
#line 771
      goto while_break;
    }
    {
#line 772
    tmp = __ctype_b_loc();
    }
#line 772
    if (! ((int const   )*(*tmp + (int )*p) & 16384)) {
#line 773
      goto not_printable;
    }
#line 771
    loop --;
#line 771
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 776
  printf((char const   */* __restrict  */)"%s\n", (char *)buffer);
  }
#line 777
  return (0);
  not_printable: 
  {
#line 781
  printf((char const   */* __restrict  */)":hex:");
#line 782
  p = (char *)buffer;
#line 783
  loop = ret;
  }
  {
#line 783
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 783
    if (! (loop > 0)) {
#line 783
      goto while_break___0;
    }
    {
#line 784
    printf((char const   */* __restrict  */)"%02hhx", (int )*p);
#line 783
    loop --;
#line 783
    p ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 785
  printf((char const   */* __restrict  */)"\n");
  }
#line 786
  return (0);
}
}
#line 794 "/home/wheatley/newnew/temp/keyutils-1.5.6/keyctl.c"
static int act_keyctl_list(int argc , char **argv ) 
{ 
  key_serial_t keyring ;
  key_serial_t key___0 ;
  key_serial_t *pk ;
  key_perm_t perm ;
  void *keylist ;
  char *buffer ;
  char pretty_mask[9] ;
  uid_t uid ;
  gid_t gid ;
  int count ;
  int tlen ;
  int dpos ;
  int n ;
  int ret ;
  key_serial_t *tmp ;

  {
#line 804
  if (argc != 2) {
    {
#line 805
    format();
    }
  }
  {
#line 807
  keyring = get_key_id((char const   *)*(argv + 1));
#line 810
  count = keyctl_read_alloc(keyring, & keylist);
  }
#line 811
  if (count < 0) {
    {
#line 812
    error___1("keyctl_read_alloc");
    }
  }
#line 814
  count = (int )((unsigned long )count / sizeof(key_serial_t ));
#line 816
  if (count == 0) {
    {
#line 817
    printf((char const   */* __restrict  */)"keyring is empty\n");
    }
#line 818
    return (0);
  }
#line 822
  if (count == 1) {
    {
#line 823
    printf((char const   */* __restrict  */)"1 key in keyring:\n");
    }
  } else {
    {
#line 825
    printf((char const   */* __restrict  */)"%u keys in keyring:\n", count);
    }
  }
#line 827
  pk = (key_serial_t *)keylist;
  {
#line 828
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 829
    tmp = pk;
#line 829
    pk ++;
#line 829
    key___0 = *tmp;
#line 831
    ret = keyctl_describe_alloc(key___0, & buffer);
    }
#line 832
    if (ret < 0) {
      {
#line 833
      printf((char const   */* __restrict  */)"%9d: key inaccessible (%m)\n", key___0);
      }
#line 834
      goto __Cont;
    }
    {
#line 837
    uid = (uid_t )0;
#line 838
    gid = (gid_t )0;
#line 839
    perm = (key_perm_t )0;
#line 841
    tlen = -1;
#line 842
    dpos = -1;
#line 844
    n = sscanf((char const   */* __restrict  */)buffer, (char const   */* __restrict  */)"%*[^;]%n;%d;%d;%x;%n",
               & tlen, & uid, & gid, & perm, & dpos);
    }
#line 846
    if (n != 3) {
      {
#line 847
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unparseable description obtained for key %d\n",
              key___0);
#line 848
      exit(3);
      }
    }
    {
#line 851
    calc_perms(pretty_mask, perm, uid, gid);
#line 853
    printf((char const   */* __restrict  */)"%9d: %s %5d %5d %*.*s: %s\n", key___0,
           pretty_mask, uid, gid, tlen, tlen, buffer, buffer + dpos);
#line 860
    free((void *)buffer);
    }
    __Cont: /* CIL Label */ 
#line 828
    count --;
#line 828
    if (! count) {
#line 828
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 864
  return (0);
}
}
#line 872 "/home/wheatley/newnew/temp/keyutils-1.5.6/keyctl.c"
static int act_keyctl_rlist(int argc , char **argv ) 
{ 
  key_serial_t keyring ;
  key_serial_t key___0 ;
  key_serial_t *pk ;
  void *keylist ;
  int count ;
  key_serial_t *tmp ;
  int tmp___0 ;

  {
#line 878
  if (argc != 2) {
    {
#line 879
    format();
    }
  }
  {
#line 881
  keyring = get_key_id((char const   *)*(argv + 1));
#line 884
  count = keyctl_read_alloc(keyring, & keylist);
  }
#line 885
  if (count < 0) {
    {
#line 886
    error___1("keyctl_read_alloc");
    }
  }
#line 888
  count = (int )((unsigned long )count / sizeof(key_serial_t ));
#line 891
  if (count <= 0) {
    {
#line 892
    printf((char const   */* __restrict  */)"\n");
    }
  } else {
#line 895
    pk = (key_serial_t *)keylist;
    {
#line 896
    while (1) {
      while_continue: /* CIL Label */ ;
#line 896
      if (! (count > 0)) {
#line 896
        goto while_break;
      }
#line 897
      tmp = pk;
#line 897
      pk ++;
#line 897
      key___0 = *tmp;
#line 898
      if (count == 1) {
#line 898
        tmp___0 = '\n';
      } else {
#line 898
        tmp___0 = ' ';
      }
      {
#line 898
      printf((char const   */* __restrict  */)"%d%c", key___0, tmp___0);
#line 896
      count --;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 902
  return (0);
}
}
#line 910 "/home/wheatley/newnew/temp/keyutils-1.5.6/keyctl.c"
static int act_keyctl_describe(int argc , char **argv ) 
{ 
  key_serial_t key___0 ;
  key_perm_t perm ;
  char *buffer ;
  uid_t uid ;
  gid_t gid ;
  int tlen ;
  int dpos ;
  int n ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;

  {
#line 919
  if (argc != 2) {
    {
#line 920
    format();
    }
  }
  {
#line 922
  key___0 = get_key_id((char const   *)*(argv + 1));
#line 925
  ret = keyctl_describe_alloc(key___0, & buffer);
  }
#line 926
  if (ret < 0) {
    {
#line 927
    error___1("keyctl_describe");
    }
  }
  {
#line 930
  uid = (uid_t )0;
#line 931
  gid = (gid_t )0;
#line 932
  perm = (key_perm_t )0;
#line 934
  tlen = -1;
#line 935
  dpos = -1;
#line 937
  n = sscanf((char const   */* __restrict  */)buffer, (char const   */* __restrict  */)"%*[^;]%n;%d;%d;%x;%n",
             & tlen, & uid, & gid, & perm, & dpos);
  }
#line 939
  if (n != 3) {
    {
#line 940
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unparseable description obtained for key %d\n",
            key___0);
#line 941
    exit(3);
    }
  }
#line 945
  if (perm & 1U) {
#line 945
    tmp = 'v';
  } else {
#line 945
    tmp = '-';
  }
#line 945
  if (perm & 2U) {
#line 945
    tmp___0 = 'r';
  } else {
#line 945
    tmp___0 = '-';
  }
#line 945
  if (perm & 4U) {
#line 945
    tmp___1 = 'w';
  } else {
#line 945
    tmp___1 = '-';
  }
#line 945
  if (perm & 8U) {
#line 945
    tmp___2 = 's';
  } else {
#line 945
    tmp___2 = '-';
  }
#line 945
  if (perm & 16U) {
#line 945
    tmp___3 = 'l';
  } else {
#line 945
    tmp___3 = '-';
  }
#line 945
  if (perm & 16U) {
#line 945
    tmp___4 = 'a';
  } else {
#line 945
    tmp___4 = '-';
  }
#line 945
  if (perm & 256U) {
#line 945
    tmp___5 = 'v';
  } else {
#line 945
    tmp___5 = '-';
  }
#line 945
  if (perm & 512U) {
#line 945
    tmp___6 = 'r';
  } else {
#line 945
    tmp___6 = '-';
  }
#line 945
  if (perm & 1024U) {
#line 945
    tmp___7 = 'w';
  } else {
#line 945
    tmp___7 = '-';
  }
#line 945
  if (perm & 2048U) {
#line 945
    tmp___8 = 's';
  } else {
#line 945
    tmp___8 = '-';
  }
#line 945
  if (perm & 4096U) {
#line 945
    tmp___9 = 'l';
  } else {
#line 945
    tmp___9 = '-';
  }
#line 945
  if (perm & 8192U) {
#line 945
    tmp___10 = 'a';
  } else {
#line 945
    tmp___10 = '-';
  }
#line 945
  if (perm & 65536U) {
#line 945
    tmp___11 = 'v';
  } else {
#line 945
    tmp___11 = '-';
  }
#line 945
  if (perm & 131072U) {
#line 945
    tmp___12 = 'r';
  } else {
#line 945
    tmp___12 = '-';
  }
#line 945
  if (perm & 262144U) {
#line 945
    tmp___13 = 'w';
  } else {
#line 945
    tmp___13 = '-';
  }
#line 945
  if (perm & 524288U) {
#line 945
    tmp___14 = 's';
  } else {
#line 945
    tmp___14 = '-';
  }
#line 945
  if (perm & 1048576U) {
#line 945
    tmp___15 = 'l';
  } else {
#line 945
    tmp___15 = '-';
  }
#line 945
  if (perm & 2097152U) {
#line 945
    tmp___16 = 'a';
  } else {
#line 945
    tmp___16 = '-';
  }
#line 945
  if (perm & 16777216U) {
#line 945
    tmp___17 = 'v';
  } else {
#line 945
    tmp___17 = '-';
  }
#line 945
  if (perm & 33554432U) {
#line 945
    tmp___18 = 'r';
  } else {
#line 945
    tmp___18 = '-';
  }
#line 945
  if (perm & 67108864U) {
#line 945
    tmp___19 = 'w';
  } else {
#line 945
    tmp___19 = '-';
  }
#line 945
  if (perm & 134217728U) {
#line 945
    tmp___20 = 's';
  } else {
#line 945
    tmp___20 = '-';
  }
#line 945
  if (perm & 268435456U) {
#line 945
    tmp___21 = 'l';
  } else {
#line 945
    tmp___21 = '-';
  }
#line 945
  if (perm & 536870912U) {
#line 945
    tmp___22 = 'a';
  } else {
#line 945
    tmp___22 = '-';
  }
  {
#line 945
  printf((char const   */* __restrict  */)"%9d: %c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c %5d %5d %*.*s: %s\n",
         key___0, tmp___22, tmp___21, tmp___20, tmp___19, tmp___18, tmp___17, tmp___16,
         tmp___15, tmp___14, tmp___13, tmp___12, tmp___11, tmp___10, tmp___9, tmp___8,
         tmp___7, tmp___6, tmp___5, tmp___4, tmp___3, tmp___2, tmp___1, tmp___0, tmp,
         uid, gid, tlen, tlen, buffer, buffer + dpos);
  }
#line 980
  return (0);
}
}
#line 988 "/home/wheatley/newnew/temp/keyutils-1.5.6/keyctl.c"
static int act_keyctl_rdescribe(int argc , char **argv ) 
{ 
  key_serial_t key___0 ;
  char *buffer ;
  char *q ;
  int ret ;

  {
#line 994
  if (argc != 2) {
#line 994
    if (argc != 3) {
      {
#line 995
      format();
      }
    }
  }
#line 996
  if (argc == 3) {
#line 996
    if (! *(*(argv + 2) + 0)) {
      {
#line 997
      format();
      }
    }
  }
  {
#line 999
  key___0 = get_key_id((char const   *)*(argv + 1));
#line 1002
  ret = keyctl_describe_alloc(key___0, & buffer);
  }
#line 1003
  if (ret < 0) {
    {
#line 1004
    error___1("keyctl_describe");
    }
  }
#line 1007
  if (argc == 3) {
#line 1008
    q = buffer;
    {
#line 1008
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1008
      if (! *q) {
#line 1008
        goto while_break;
      }
#line 1009
      if ((int )*q == 59) {
#line 1010
        *q = *(*(argv + 2) + 0);
      }
#line 1008
      q ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1014
  printf((char const   */* __restrict  */)"%s\n", buffer);
  }
#line 1015
  return (0);
}
}
#line 1023 "/home/wheatley/newnew/temp/keyutils-1.5.6/keyctl.c"
static int act_keyctl_chown(int argc , char **argv ) 
{ 
  key_serial_t key___0 ;
  uid_t uid ;
  char *q ;
  unsigned long tmp ;
  long tmp___0 ;

  {
#line 1029
  if (argc != 3) {
    {
#line 1030
    format();
    }
  }
  {
#line 1032
  key___0 = get_key_id((char const   *)*(argv + 1));
#line 1034
  tmp = strtoul((char const   */* __restrict  */)*(argv + 2), (char **/* __restrict  */)(& q),
                0);
#line 1034
  uid = (uid_t )tmp;
  }
#line 1035
  if (*q) {
    {
#line 1036
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unparsable uid: \'%s\'\n",
            *(argv + 2));
#line 1037
    exit(2);
    }
  }
  {
#line 1040
  tmp___0 = keyctl_chown(key___0, uid, (gid_t )-1);
  }
#line 1040
  if (tmp___0 < 0L) {
    {
#line 1041
    error___1("keyctl_chown");
    }
  }
#line 1043
  return (0);
}
}
#line 1051 "/home/wheatley/newnew/temp/keyutils-1.5.6/keyctl.c"
static int act_keyctl_chgrp(int argc , char **argv ) 
{ 
  key_serial_t key___0 ;
  gid_t gid ;
  char *q ;
  unsigned long tmp ;
  long tmp___0 ;

  {
#line 1057
  if (argc != 3) {
    {
#line 1058
    format();
    }
  }
  {
#line 1060
  key___0 = get_key_id((char const   *)*(argv + 1));
#line 1062
  tmp = strtoul((char const   */* __restrict  */)*(argv + 2), (char **/* __restrict  */)(& q),
                0);
#line 1062
  gid = (gid_t )tmp;
  }
#line 1063
  if (*q) {
    {
#line 1064
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unparsable gid: \'%s\'\n",
            *(argv + 2));
#line 1065
    exit(2);
    }
  }
  {
#line 1068
  tmp___0 = keyctl_chown(key___0, (uid_t )-1, gid);
  }
#line 1068
  if (tmp___0 < 0L) {
    {
#line 1069
    error___1("keyctl_chown");
    }
  }
#line 1071
  return (0);
}
}
#line 1079 "/home/wheatley/newnew/temp/keyutils-1.5.6/keyctl.c"
static int act_keyctl_setperm(int argc , char **argv ) 
{ 
  key_serial_t key___0 ;
  key_perm_t perm ;
  char *q ;
  unsigned long tmp ;
  long tmp___0 ;

  {
#line 1085
  if (argc != 3) {
    {
#line 1086
    format();
    }
  }
  {
#line 1088
  key___0 = get_key_id((char const   *)*(argv + 1));
#line 1089
  tmp = strtoul((char const   */* __restrict  */)*(argv + 2), (char **/* __restrict  */)(& q),
                0);
#line 1089
  perm = (key_perm_t )tmp;
  }
#line 1090
  if (*q) {
    {
#line 1091
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unparsable permissions: \'%s\'\n",
            *(argv + 2));
#line 1092
    exit(2);
    }
  }
  {
#line 1095
  tmp___0 = keyctl_setperm(key___0, perm);
  }
#line 1095
  if (tmp___0 < 0L) {
    {
#line 1096
    error___1("keyctl_setperm");
    }
  }
#line 1098
  return (0);
}
}
#line 1106 "/home/wheatley/newnew/temp/keyutils-1.5.6/keyctl.c"
static int act_keyctl_session(int argc , char **argv ) 
{ 
  char *p ;
  char *q ;
  int ret ;
  int tmp ;

  {
#line 1111
  argv ++;
#line 1112
  argc --;
#line 1116
  p = (char *)((void *)0);
#line 1117
  if (argc != 0) {
    {
#line 1119
    p = *argv;
#line 1120
    tmp = strcmp((char const   *)p, "-");
    }
#line 1120
    if (tmp == 0) {
#line 1121
      p = (char *)((void *)0);
    }
#line 1123
    argv ++;
#line 1124
    argc --;
  }
  {
#line 1128
  ret = keyctl_join_session_keyring((char const   *)p);
  }
#line 1129
  if (ret < 0) {
    {
#line 1130
    error___1("keyctl_join_session_keyring");
    }
  }
  {
#line 1132
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Joined session keyring: %d\n",
          ret);
  }
#line 1135
  if (argc == 0) {
    {
#line 1136
    q = getenv("SHELL");
    }
#line 1137
    if (! q) {
#line 1138
      q = (char *)"/bin/sh";
    }
    {
#line 1139
    execl((char const   *)q, (char const   *)q, (void *)0);
#line 1140
    error___1((char const   *)q);
    }
  }
  {
#line 1144
  execvp((char const   *)*(argv + 0), (char * const  *)argv);
#line 1145
  error___1((char const   *)*(argv + 0));
  }
}
}
#line 1153 "/home/wheatley/newnew/temp/keyutils-1.5.6/keyctl.c"
static int act_keyctl_instantiate(int argc , char **argv ) 
{ 
  key_serial_t key___0 ;
  key_serial_t dest ;
  size_t tmp ;
  long tmp___0 ;

  {
#line 1157
  if (argc != 4) {
    {
#line 1158
    format();
    }
  }
  {
#line 1160
  key___0 = get_key_id((char const   *)*(argv + 1));
#line 1161
  dest = get_key_id((char const   *)*(argv + 3));
#line 1163
  tmp = strlen((char const   *)*(argv + 2));
#line 1163
  tmp___0 = keyctl_instantiate(key___0, (void const   *)*(argv + 2), tmp, dest);
  }
#line 1163
  if (tmp___0 < 0L) {
    {
#line 1164
    error___1("keyctl_instantiate");
    }
  }
#line 1166
  return (0);
}
}
#line 1174 "/home/wheatley/newnew/temp/keyutils-1.5.6/keyctl.c"
static int act_keyctl_pinstantiate(int argc , char **argv ) 
{ 
  key_serial_t key___0 ;
  key_serial_t dest ;
  size_t datalen ;
  void *data ;
  char *tmp ;
  long tmp___0 ;

  {
#line 1180
  if (argc != 3) {
    {
#line 1181
    format();
    }
  }
  {
#line 1183
  key___0 = get_key_id((char const   *)*(argv + 1));
#line 1184
  dest = get_key_id((char const   *)*(argv + 2));
#line 1185
  tmp = grab_stdin(& datalen);
#line 1185
  data = (void *)tmp;
#line 1187
  tmp___0 = keyctl_instantiate(key___0, (void const   *)data, datalen, dest);
  }
#line 1187
  if (tmp___0 < 0L) {
    {
#line 1188
    error___1("keyctl_instantiate");
    }
  }
#line 1190
  return (0);
}
}
#line 1198 "/home/wheatley/newnew/temp/keyutils-1.5.6/keyctl.c"
static int act_keyctl_negate(int argc , char **argv ) 
{ 
  unsigned long timeout ;
  key_serial_t key___0 ;
  key_serial_t dest ;
  char *q ;
  long tmp ;

  {
#line 1204
  if (argc != 4) {
    {
#line 1205
    format();
    }
  }
  {
#line 1207
  key___0 = get_key_id((char const   *)*(argv + 1));
#line 1209
  timeout = strtoul((char const   */* __restrict  */)*(argv + 2), (char **/* __restrict  */)(& q),
                    10);
  }
#line 1210
  if (*q) {
    {
#line 1211
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unparsable timeout: \'%s\'\n",
            *(argv + 2));
#line 1212
    exit(2);
    }
  }
  {
#line 1215
  dest = get_key_id((char const   *)*(argv + 3));
#line 1217
  tmp = keyctl_negate(key___0, (unsigned int )timeout, dest);
  }
#line 1217
  if (tmp < 0L) {
    {
#line 1218
    error___1("keyctl_negate");
    }
  }
#line 1220
  return (0);
}
}
#line 1228 "/home/wheatley/newnew/temp/keyutils-1.5.6/keyctl.c"
static int act_keyctl_timeout(int argc , char **argv ) 
{ 
  unsigned long timeout ;
  key_serial_t key___0 ;
  char *q ;
  long tmp ;

  {
#line 1234
  if (argc != 3) {
    {
#line 1235
    format();
    }
  }
  {
#line 1237
  key___0 = get_key_id((char const   *)*(argv + 1));
#line 1239
  timeout = strtoul((char const   */* __restrict  */)*(argv + 2), (char **/* __restrict  */)(& q),
                    10);
  }
#line 1240
  if (*q) {
    {
#line 1241
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unparsable timeout: \'%s\'\n",
            *(argv + 2));
#line 1242
    exit(2);
    }
  }
  {
#line 1245
  tmp = keyctl_set_timeout(key___0, (unsigned int )timeout);
  }
#line 1245
  if (tmp < 0L) {
    {
#line 1246
    error___1("keyctl_set_timeout");
    }
  }
#line 1248
  return (0);
}
}
#line 1256 "/home/wheatley/newnew/temp/keyutils-1.5.6/keyctl.c"
static int act_keyctl_security(int argc , char **argv ) 
{ 
  key_serial_t key___0 ;
  char *buffer ;
  int ret ;

  {
#line 1262
  if (argc != 2) {
    {
#line 1263
    format();
    }
  }
  {
#line 1265
  key___0 = get_key_id((char const   *)*(argv + 1));
#line 1268
  ret = keyctl_get_security_alloc(key___0, & buffer);
  }
#line 1269
  if (ret < 0) {
    {
#line 1270
    error___1("keyctl_getsecurity");
    }
  }
  {
#line 1272
  printf((char const   */* __restrict  */)"%s\n", buffer);
  }
#line 1273
  return (0);
}
}
#line 1280 "/home/wheatley/newnew/temp/keyutils-1.5.6/keyctl.c"
static int act_keyctl_new_session(int argc , char **argv ) 
{ 
  key_serial_t keyring ;
  key_serial_t tmp ;
  long tmp___0 ;

  {
#line 1284
  if (argc != 1) {
    {
#line 1285
    format();
    }
  }
  {
#line 1287
  tmp = keyctl_join_session_keyring((char const   *)((void *)0));
  }
#line 1287
  if (tmp < 0) {
    {
#line 1288
    error___1("keyctl_join_session_keyring");
    }
  }
  {
#line 1290
  tmp___0 = keyctl_session_to_parent();
  }
#line 1290
  if (tmp___0 < 0L) {
    {
#line 1291
    error___1("keyctl_session_to_parent");
    }
  }
  {
#line 1293
  keyring = keyctl_get_keyring_ID(-3, 0);
  }
#line 1294
  if (keyring < 0) {
    {
#line 1295
    error___1("keyctl_get_keyring_ID");
    }
  }
  {
#line 1298
  printf((char const   */* __restrict  */)"%d\n", keyring);
  }
#line 1299
  return (0);
}
}
#line 1306 "/home/wheatley/newnew/temp/keyutils-1.5.6/keyctl.c"
static int act_keyctl_reject(int argc , char **argv ) 
{ 
  unsigned long timeout ;
  key_serial_t key___0 ;
  key_serial_t dest ;
  unsigned long rejerr ;
  char *q ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
#line 1313
  if (argc != 5) {
    {
#line 1314
    format();
    }
  }
  {
#line 1316
  key___0 = get_key_id((char const   *)*(argv + 1));
#line 1318
  timeout = strtoul((char const   */* __restrict  */)*(argv + 2), (char **/* __restrict  */)(& q),
                    10);
  }
#line 1319
  if (*q) {
    {
#line 1320
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unparsable timeout: \'%s\'\n",
            *(argv + 2));
#line 1321
    exit(2);
    }
  }
  {
#line 1324
  tmp___1 = strcmp((char const   *)*(argv + 3), "rejected");
  }
#line 1324
  if (tmp___1 == 0) {
#line 1325
    rejerr = 129UL;
  } else {
    {
#line 1326
    tmp___0 = strcmp((char const   *)*(argv + 3), "revoked");
    }
#line 1326
    if (tmp___0 == 0) {
#line 1327
      rejerr = 128UL;
    } else {
      {
#line 1328
      tmp = strcmp((char const   *)*(argv + 3), "expired");
      }
#line 1328
      if (tmp == 0) {
#line 1329
        rejerr = 127UL;
      } else {
        {
#line 1331
        rejerr = strtoul((char const   */* __restrict  */)*(argv + 3), (char **/* __restrict  */)(& q),
                         10);
        }
#line 1332
        if (*q) {
          {
#line 1333
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unparsable error: \'%s\'\n",
                  *(argv + 3));
#line 1334
          exit(2);
          }
        }
      }
    }
  }
  {
#line 1338
  dest = get_key_id((char const   *)*(argv + 4));
#line 1340
  tmp___2 = keyctl_reject(key___0, (unsigned int )timeout, (unsigned int )rejerr,
                          dest);
  }
#line 1340
  if (tmp___2 < 0L) {
    {
#line 1341
    error___1("keyctl_negate");
    }
  }
#line 1343
  return (0);
}
}
#line 1350 "/home/wheatley/newnew/temp/keyutils-1.5.6/keyctl.c"
static int act_keyctl_reap_func(key_serial_t parent , key_serial_t key___0 , char *desc ,
                                int desc_len , void *data ) 
{ 
  long tmp ;
  int *tmp___0 ;

  {
#line 1353
  if (desc_len < 0) {
    {
#line 1353
    tmp___0 = __errno_location();
    }
#line 1353
    if (*tmp___0 != 13) {
#line 1354
      if (verbose___0) {
        {
#line 1355
        printf((char const   */* __restrict  */)"Reap %d", key___0);
        }
      }
      {
#line 1356
      tmp = keyctl_unlink(key___0, parent);
      }
#line 1356
      if (tmp < 0L) {
#line 1357
        if (verbose___0) {
          {
#line 1358
          printf((char const   */* __restrict  */)"... failed %m\n");
          }
        }
#line 1359
        return (0);
      } else {
#line 1361
        if (verbose___0) {
          {
#line 1362
          printf((char const   */* __restrict  */)"\n");
          }
        }
#line 1363
        return (1);
      }
    }
  }
#line 1366
  return (0);
}
}
#line 1372 "/home/wheatley/newnew/temp/keyutils-1.5.6/keyctl.c"
static int act_keyctl_reap(int argc , char **argv ) 
{ 
  int n ;
  int tmp ;

  {
#line 1376
  if (argc > 1) {
    {
#line 1376
    tmp = strcmp((char const   *)*(argv + 1), "-v");
    }
#line 1376
    if (tmp == 0) {
#line 1377
      verbose___0 = 1;
#line 1378
      argc --;
#line 1379
      argv ++;
    }
  }
#line 1382
  if (argc != 1) {
    {
#line 1383
    format();
    }
  }
  {
#line 1385
  n = recursive_session_key_scan(& act_keyctl_reap_func, (void *)0);
#line 1386
  printf((char const   */* __restrict  */)"%d keys reaped\n", n);
  }
#line 1387
  return (0);
}
}
#line 1402 "/home/wheatley/newnew/temp/keyutils-1.5.6/keyctl.c"
static int act_keyctl_purge_type_func(key_serial_t parent , key_serial_t key___0 ,
                                      char *raw , int raw_len , void *data ) 
{ 
  struct purge_data  const  *purge ;
  char *p ;
  char *type ;
  void *tmp ;
  int tmp___0 ;
  int tmp___2 ;
  long tmp___3 ;

  {
#line 1405
  purge = (struct purge_data  const  *)data;
#line 1408
  if (parent == 0) {
#line 1409
    return (0);
  } else
#line 1408
  if (! raw) {
#line 1409
    return (0);
  }
  {
#line 1412
  type = raw;
#line 1413
  tmp = memchr((void const   *)raw, ';', (size_t )raw_len);
#line 1413
  p = (char *)tmp;
  }
#line 1414
  if (! p) {
#line 1415
    return (0);
  }
  {
#line 1416
  *p = (char)0;
#line 1417
  tmp___0 = strcmp((char const   *)type, (char const   *)purge->type);
  }
#line 1417
  if (tmp___0 != 0) {
#line 1418
    return (0);
  }
  {
#line 1420
  tmp___3 = keyctl_unlink(key___0, parent);
  }
#line 1420
  if (tmp___3 < 0L) {
#line 1420
    tmp___2 = 0;
  } else {
#line 1420
    tmp___2 = 1;
  }
#line 1420
  return (tmp___2);
}
}
#line 1426 "/home/wheatley/newnew/temp/keyutils-1.5.6/keyctl.c"
static int act_keyctl_purge_literal_func(key_serial_t parent , key_serial_t key___0 ,
                                         char *raw , int raw_len , void *data ) 
{ 
  struct purge_data  const  *purge ;
  size_t tlen ;
  char *p ;
  char *type ;
  char *desc ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___5 ;
  long tmp___6 ;

  {
#line 1429
  purge = (struct purge_data  const  *)data;
#line 1433
  if (parent == 0) {
#line 1434
    return (0);
  } else
#line 1433
  if (! raw) {
#line 1434
    return (0);
  }
  {
#line 1437
  type = raw;
#line 1438
  tmp = memchr((void const   *)type, ';', (size_t )raw_len);
#line 1438
  p = (char *)tmp;
  }
#line 1439
  if (! p) {
#line 1440
    return (0);
  }
#line 1442
  tlen = (size_t )(p - type);
#line 1443
  if (tlen != (size_t )purge->type_len) {
#line 1444
    return (0);
  }
  {
#line 1445
  tmp___0 = memcmp((void const   *)type, (void const   *)purge->type, tlen);
  }
#line 1445
  if (tmp___0 != 0) {
#line 1446
    return (0);
  }
  {
#line 1449
  p ++;
#line 1450
  tmp___1 = memrchr((void const   *)p, ';', (size_t )((raw + raw_len) - p));
#line 1450
  desc = (char *)tmp___1;
  }
#line 1451
  if (! desc) {
#line 1452
    return (0);
  }
#line 1453
  desc ++;
#line 1455
  if (purge->prefix_match) {
#line 1456
    if ((size_t const   )((long )raw_len - (desc - raw)) < purge->desc_len) {
#line 1457
      return (0);
    }
  } else
#line 1459
  if ((size_t const   )((long )raw_len - (desc - raw)) != purge->desc_len) {
#line 1460
    return (0);
  }
#line 1463
  if (purge->case_indep) {
    {
#line 1464
    tmp___2 = strncasecmp((char const   *)purge->desc, (char const   *)desc, (size_t )purge->desc_len);
    }
#line 1464
    if (tmp___2 != 0) {
#line 1465
      return (0);
    }
  } else {
    {
#line 1467
    tmp___3 = memcmp((void const   *)purge->desc, (void const   *)desc, (size_t )purge->desc_len);
    }
#line 1467
    if (tmp___3 != 0) {
#line 1468
      return (0);
    }
  }
  {
#line 1471
  printf((char const   */* __restrict  */)"%*.*s \'%s\'\n", (int )tlen, (int )tlen,
         type, desc);
#line 1473
  tmp___6 = keyctl_unlink(key___0, parent);
  }
#line 1473
  if (tmp___6 < 0L) {
#line 1473
    tmp___5 = 0;
  } else {
#line 1473
    tmp___5 = 1;
  }
#line 1473
  return (tmp___5);
}
}
#line 1479 "/home/wheatley/newnew/temp/keyutils-1.5.6/keyctl.c"
static int act_keyctl_purge_search_func(key_serial_t parent , key_serial_t keyring ,
                                        char *raw , int raw_len , void *data ) 
{ 
  struct purge_data  const  *purge ;
  key_serial_t key___0 ;
  int kcount ;
  int tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 1482
  purge = (struct purge_data  const  *)data;
#line 1484
  kcount = 0;
#line 1486
  if (! raw) {
#line 1487
    return (0);
  } else {
    {
#line 1486
    tmp = memcmp((void const   *)raw, (void const   *)"keyring;", (size_t )8);
    }
#line 1486
    if (tmp != 0) {
#line 1487
      return (0);
    }
  }
  {
#line 1489
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1490
    tmp___0 = keyctl_search(keyring, (char const   *)purge->type, (char const   *)purge->desc,
                            0);
#line 1490
    key___0 = (key_serial_t )tmp___0;
#line 1491
    tmp___1 = keyctl_unlink(key___0, keyring);
    }
#line 1491
    if (tmp___1 < 0L) {
#line 1492
      return (kcount);
    }
#line 1493
    kcount ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1495
  return (kcount);
}
}
#line 1501 "/home/wheatley/newnew/temp/keyutils-1.5.6/keyctl.c"
static int act_keyctl_purge(int argc , char **argv ) 
{ 
  int (*func)(key_serial_t parent , key_serial_t key , char *desc , int desc_len ,
              void *data ) ;
  struct purge_data purge ;
  int n ;
  int search_mode ;
  size_t tmp ;

  {
#line 1504
  purge.type = (char const   *)0;
#line 1504
  purge.desc = (char const   *)0;
#line 1504
  purge.desc_len = 0UL;
#line 1504
  purge.type_len = 0UL;
#line 1504
  purge.prefix_match = (char)0;
#line 1504
  purge.case_indep = (char)0;
#line 1508
  n = 0;
#line 1508
  search_mode = 0;
#line 1510
  argc --;
#line 1511
  argv ++;
  {
#line 1512
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1512
    if (argc > 0) {
#line 1512
      if (! ((int )*(*(argv + 0) + 0) == 45)) {
#line 1512
        goto while_break;
      }
    } else {
#line 1512
      goto while_break;
    }
#line 1513
    if ((int )*(*(argv + 0) + 1) == 115) {
#line 1514
      search_mode = 1;
    } else
#line 1515
    if ((int )*(*(argv + 0) + 1) == 112) {
#line 1516
      purge.prefix_match = (char)1;
    } else
#line 1517
    if ((int )*(*(argv + 0) + 1) == 105) {
#line 1518
      purge.case_indep = (char)1;
    } else {
      {
#line 1520
      format();
      }
    }
#line 1521
    argc --;
#line 1522
    argv ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1525
  if (argc < 1) {
    {
#line 1526
    format();
    }
  }
  {
#line 1528
  purge.type = (char const   *)*(argv + 0);
#line 1529
  purge.desc = (char const   *)*(argv + 1);
#line 1530
  purge.type_len = strlen(purge.type);
  }
#line 1531
  if (purge.desc) {
    {
#line 1531
    tmp = strlen(purge.desc);
#line 1531
    purge.desc_len = tmp;
    }
  } else {
#line 1531
    purge.desc_len = (size_t )0;
  }
#line 1533
  if (search_mode == 1) {
#line 1534
    if (argc != 2) {
      {
#line 1535
      format();
      }
    } else
#line 1534
    if (purge.prefix_match) {
      {
#line 1535
      format();
      }
    } else
#line 1534
    if (purge.case_indep) {
      {
#line 1535
      format();
      }
    }
#line 1538
    func = & act_keyctl_purge_search_func;
  } else
#line 1539
  if (argc == 1) {
#line 1540
    if (purge.prefix_match) {
      {
#line 1541
      format();
      }
    } else
#line 1540
    if (purge.case_indep) {
      {
#line 1541
      format();
      }
    }
#line 1543
    func = & act_keyctl_purge_type_func;
  } else
#line 1544
  if (argc == 2) {
#line 1547
    func = & act_keyctl_purge_literal_func;
  } else {
    {
#line 1549
    format();
    }
  }
  {
#line 1552
  n = recursive_session_key_scan(func, (void *)(& purge));
#line 1553
  printf((char const   */* __restrict  */)"purged %d keys\n", n);
  }
#line 1554
  return (0);
}
}
#line 1561 "/home/wheatley/newnew/temp/keyutils-1.5.6/keyctl.c"
static int act_keyctl_invalidate(int argc , char **argv ) 
{ 
  key_serial_t key___0 ;
  long tmp ;

  {
#line 1565
  if (argc != 2) {
    {
#line 1566
    format();
    }
  }
  {
#line 1568
  key___0 = get_key_id((char const   *)*(argv + 1));
#line 1570
  tmp = keyctl_invalidate(key___0);
  }
#line 1570
  if (tmp < 0L) {
    {
#line 1571
    error___1("keyctl_invalidate");
    }
  }
#line 1573
  return (0);
}
}
#line 1580 "/home/wheatley/newnew/temp/keyutils-1.5.6/keyctl.c"
static key_serial_t get_key_id(char const   *arg ) 
{ 
  key_serial_t id ;
  char *end ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  unsigned long tmp___6 ;

  {
#line 1586
  if ((int const   )*(arg + 0) == 64) {
    {
#line 1587
    tmp = strcmp(arg, "@t");
    }
#line 1587
    if (tmp == 0) {
#line 1587
      return (-1);
    }
    {
#line 1588
    tmp___0 = strcmp(arg, "@p");
    }
#line 1588
    if (tmp___0 == 0) {
#line 1588
      return (-2);
    }
    {
#line 1589
    tmp___1 = strcmp(arg, "@s");
    }
#line 1589
    if (tmp___1 == 0) {
#line 1589
      return (-3);
    }
    {
#line 1590
    tmp___2 = strcmp(arg, "@u");
    }
#line 1590
    if (tmp___2 == 0) {
#line 1590
      return (-4);
    }
    {
#line 1591
    tmp___3 = strcmp(arg, "@us");
    }
#line 1591
    if (tmp___3 == 0) {
#line 1591
      return (-5);
    }
    {
#line 1592
    tmp___4 = strcmp(arg, "@g");
    }
#line 1592
    if (tmp___4 == 0) {
#line 1592
      return (-6);
    }
    {
#line 1593
    tmp___5 = strcmp(arg, "@a");
    }
#line 1593
    if (tmp___5 == 0) {
#line 1593
      return (-7);
    }
    {
#line 1595
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown special key: \'%s\'\n",
            arg);
#line 1596
    exit(2);
    }
  }
  {
#line 1600
  tmp___6 = strtoul((char const   */* __restrict  */)arg, (char **/* __restrict  */)(& end),
                    0);
#line 1600
  id = (key_serial_t )tmp___6;
  }
#line 1601
  if (*end) {
    {
#line 1602
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unparsable key: \'%s\'\n",
            arg);
#line 1603
    exit(2);
    }
  }
#line 1606
  return (id);
}
}
#line 1616 "/home/wheatley/newnew/temp/keyutils-1.5.6/keyctl.c"
static char dumpindent[64]  ;
#line 1614 "/home/wheatley/newnew/temp/keyutils-1.5.6/keyctl.c"
static int dump_key_tree_aux(key_serial_t key___0 , int depth , int more , int hex_key_IDs ) 
{ 
  key_serial_t *pk ;
  key_perm_t perm ;
  size_t ringlen ;
  size_t desclen ;
  void *payload___0 ;
  char *desc ;
  char type[255] ;
  char pretty_mask[9] ;
  int uid ;
  int gid ;
  int ret ;
  int n ;
  int dpos ;
  int rdepth ;
  int kcount ;
  long tmp ;
  void *tmp___0 ;
  long tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  key_serial_t *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
#line 1622
  kcount = 0;
#line 1624
  if (depth > 32) {
#line 1625
    return (0);
  }
  {
#line 1628
  tmp = keyctl_describe(key___0, (char *)((void *)0), (size_t )0);
#line 1628
  ret = (int )tmp;
  }
#line 1629
  if (ret < 0) {
    {
#line 1630
    printf((char const   */* __restrict  */)"%d: key inaccessible (%m)\n", key___0);
    }
#line 1631
    return (0);
  }
  {
#line 1633
  desclen = (size_t )(ret + 1);
#line 1635
  tmp___0 = malloc(desclen);
#line 1635
  desc = (char *)tmp___0;
  }
#line 1636
  if (! desc) {
    {
#line 1637
    error___1("malloc");
    }
  }
  {
#line 1640
  tmp___1 = keyctl_describe(key___0, desc, desclen);
#line 1640
  ret = (int )tmp___1;
  }
#line 1641
  if (ret < 0) {
    {
#line 1642
    printf((char const   */* __restrict  */)"%d: key inaccessible (%m)\n", key___0);
#line 1643
    free((void *)desc);
    }
#line 1644
    return (0);
  }
#line 1647
  if ((size_t )ret < desclen) {
#line 1647
    desclen = (size_t )ret;
  } else {
#line 1647
    desclen = desclen;
  }
  {
#line 1649
  *(desc + desclen) = (char)0;
#line 1652
  type[0] = (char)0;
#line 1653
  uid = 0;
#line 1654
  gid = 0;
#line 1655
  perm = (key_perm_t )0;
#line 1657
  n = sscanf((char const   */* __restrict  */)desc, (char const   */* __restrict  */)"%[^;];%d;%d;%x;%n",
             type, & uid, & gid, & perm, & dpos);
  }
#line 1660
  if (n != 4) {
    {
#line 1661
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unparseable description obtained for key %d\n",
            key___0);
#line 1662
    exit(3);
    }
  }
  {
#line 1666
  calc_perms(pretty_mask, perm, (uid_t )uid, (gid_t )gid);
  }
#line 1668
  if (hex_key_IDs) {
#line 1669
    if (depth > 0) {
#line 1669
      tmp___2 = "\\_ ";
    } else {
#line 1669
      tmp___2 = "";
    }
    {
#line 1669
    printf((char const   */* __restrict  */)"0x%08x %s  %5d %5d  %s%s%s: %s\n", key___0,
           pretty_mask, uid, gid, dumpindent, tmp___2, type, desc + dpos);
    }
  } else {
#line 1677
    if (depth > 0) {
#line 1677
      tmp___3 = "\\_ ";
    } else {
#line 1677
      tmp___3 = "";
    }
    {
#line 1677
    printf((char const   */* __restrict  */)"%10d %s  %5d %5d  %s%s%s: %s\n", key___0,
           pretty_mask, uid, gid, dumpindent, tmp___3, type, desc + dpos);
    }
  }
  {
#line 1687
  tmp___14 = strcmp((char const   *)(type), "keyring");
  }
#line 1687
  if (tmp___14 == 0) {
    {
#line 1689
    tmp___4 = keyctl_read(key___0, (char *)((void *)0), (size_t )0);
#line 1689
    ret = (int )tmp___4;
    }
#line 1690
    if (ret < 0) {
      {
#line 1691
      error___1("keyctl_read");
      }
    }
#line 1692
    if (ret == 0) {
#line 1693
      return (0);
    }
    {
#line 1694
    ringlen = (size_t )ret;
#line 1697
    payload___0 = malloc(ringlen);
    }
#line 1698
    if (! payload___0) {
      {
#line 1699
      error___1("malloc");
      }
    }
    {
#line 1701
    tmp___5 = keyctl_read(key___0, (char *)payload___0, ringlen);
#line 1701
    ret = (int )tmp___5;
    }
#line 1702
    if (ret < 0) {
      {
#line 1703
      error___1("keyctl_read");
      }
    }
#line 1705
    if ((size_t )ret < ringlen) {
#line 1705
      ringlen = (size_t )ret;
    } else {
#line 1705
      ringlen = ringlen;
    }
#line 1706
    kcount = (int )(ringlen / sizeof(key_serial_t ));
#line 1709
    pk = (key_serial_t *)payload___0;
    {
#line 1710
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1711
      tmp___6 = pk;
#line 1711
      pk ++;
#line 1711
      key___0 = *tmp___6;
#line 1714
      tmp___13 = strcmp((char const   *)(type), "keyring");
      }
#line 1714
      if (tmp___13 == 0) {
#line 1715
        if (depth == 0) {
#line 1716
          rdepth = depth;
#line 1717
          tmp___7 = rdepth;
#line 1717
          rdepth ++;
#line 1717
          dumpindent[tmp___7] = (char )' ';
#line 1718
          dumpindent[rdepth] = (char)0;
        } else {
#line 1721
          rdepth = depth;
#line 1722
          tmp___8 = rdepth;
#line 1722
          rdepth ++;
#line 1722
          dumpindent[tmp___8] = (char )' ';
#line 1723
          tmp___9 = rdepth;
#line 1723
          rdepth ++;
#line 1723
          dumpindent[tmp___9] = (char )' ';
#line 1724
          tmp___10 = rdepth;
#line 1724
          rdepth ++;
#line 1724
          dumpindent[tmp___10] = (char )' ';
#line 1725
          tmp___11 = rdepth;
#line 1725
          rdepth ++;
#line 1725
          dumpindent[tmp___11] = (char )' ';
#line 1726
          dumpindent[rdepth] = (char)0;
        }
#line 1729
        if (more) {
#line 1730
          dumpindent[depth] = (char )'|';
        }
        {
#line 1732
        tmp___12 = dump_key_tree_aux(key___0, rdepth, ringlen - 4UL >= sizeof(key_serial_t ),
                                     hex_key_IDs);
#line 1732
        kcount += tmp___12;
        }
      }
#line 1710
      ringlen -= 4UL;
#line 1710
      if (! (ringlen >= sizeof(key_serial_t ))) {
#line 1710
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1740
    free(payload___0);
    }
  }
  {
#line 1743
  free((void *)desc);
  }
#line 1744
  return (kcount);
}
}
#line 1752 "/home/wheatley/newnew/temp/keyutils-1.5.6/keyctl.c"
static int dump_key_tree(key_serial_t keyring , char const   *name , int hex_key_IDs ) 
{ 
  int tmp ;

  {
  {
#line 1754
  printf((char const   */* __restrict  */)"%s\n", name);
#line 1756
  keyring = keyctl_get_keyring_ID(keyring, 0);
  }
#line 1757
  if (keyring == -1) {
    {
#line 1758
    error___1("Unable to dump key");
    }
  }
  {
#line 1760
  tmp = dump_key_tree_aux(keyring, 0, 0, hex_key_IDs);
  }
#line 1760
  return (tmp);
}
}
