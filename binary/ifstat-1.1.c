/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 35 "/home/june/repo/benchmarks/collector/temp/ifstat-1.1/ifstat.h"
struct ifstat_data {
   char *name ;
   int namelen ;
   unsigned long long obout ;
   unsigned long long obin ;
   unsigned long long bout ;
   unsigned long long bin ;
   int flags ;
   int index ;
   struct ifstat_data *next ;
};
#line 43 "/home/june/repo/benchmarks/collector/temp/ifstat-1.1/ifstat.h"
struct ifstat_list {
   struct ifstat_data *first ;
   int flags ;
};
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_2 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_2 __sigset_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_3 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_3 fd_set;
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_20 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_21 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_22 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_23 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_24 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_25 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_26 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_19 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_20 _kill ;
   struct __anonstruct__timer_21 _timer ;
   struct __anonstruct__rt_22 _rt ;
   struct __anonstruct__sigchld_23 _sigchld ;
   struct __anonstruct__sigfault_24 _sigfault ;
   struct __anonstruct__sigpoll_25 _sigpoll ;
   struct __anonstruct__sigsys_26 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_18 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_19 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_18 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_38 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_38 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 49 "/home/june/repo/benchmarks/collector/temp/ifstat-1.1/ifstat.h"
struct ifstat_driver {
   char *name ;
   int (*open_driver)(struct ifstat_driver *driver , char *options ) ;
   int (*scan_interfaces)(struct ifstat_driver *driver , struct ifstat_list *ifs ) ;
   int (*get_stats)(struct ifstat_driver *driver , struct ifstat_list *ifs ) ;
   void (*close_driver)(struct ifstat_driver *driver ) ;
   void *data ;
};
#line 189 "/home/june/repo/benchmarks/collector/temp/ifstat-1.1/ifstat.c"
struct __anonstruct_termsize_53 {
   int cols ;
   int lines ;
   int datalines ;
};
#line 183 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 33 "/usr/include/net/if.h"
struct if_nameindex {
   unsigned int if_index ;
   char *if_name ;
};
#line 111 "/usr/include/net/if.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 126 "/usr/include/net/if.h"
union __anonunion_ifr_ifrn_51 {
   char ifrn_name[16] ;
};
#line 126 "/usr/include/net/if.h"
union __anonunion_ifr_ifru_52 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16] ;
   char ifru_newname[16] ;
   __caddr_t ifru_data ;
};
#line 126 "/usr/include/net/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_51 ifr_ifrn ;
   union __anonunion_ifr_ifru_52 ifr_ifru ;
};
#line 773 "/home/june/repo/benchmarks/collector/temp/ifstat-1.1/drivers.c"
struct proc_driver_data {
   char *file ;
   int checked ;
};
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 435 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 71 "/home/june/repo/benchmarks/collector/temp/ifstat-1.1/ifstat.h"
void ifstat_add_interface(struct ifstat_list *ifs , char *ifname , int flags ) ;
#line 72
void ifstat_free_interface(struct ifstat_data *data ) ;
#line 74
void ifstat_set_interface_stats(struct ifstat_data *data , unsigned long long bytesin ,
                                unsigned long long bytesout ) ;
#line 78
void ifstat_set_interface_index(struct ifstat_data *data , int index___0 ) ;
#line 84
struct ifstat_data *ifstat_get_interface(struct ifstat_list *ifs , char *ifname ) ;
#line 87
void ifstat_reset_interfaces(struct ifstat_list *ifs ) ;
#line 90
char *ifstat_progname ;
#line 91
void (*ifstat_error)(char *format  , ...) ;
#line 92
int ifstat_quiet ;
#line 95
char const   *ifstat_version ;
#line 98
void ifstat_perror(char *func ) ;
#line 48 "/home/june/repo/benchmarks/collector/temp/ifstat-1.1/data.c"
char const   *ifstat_version  =    "1.1";
#line 49 "/home/june/repo/benchmarks/collector/temp/ifstat-1.1/data.c"
int ifstat_quiet  =    0;
#line 50 "/home/june/repo/benchmarks/collector/temp/ifstat-1.1/data.c"
char *ifstat_progname  =    (char *)"libifstat";
#line 52 "/home/june/repo/benchmarks/collector/temp/ifstat-1.1/data.c"
void _ifstat_error(char *format  , ...) 
{ 
  va_list ap ;

  {
  {
#line 55
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
          ifstat_progname);
#line 56
  __builtin_va_start(ap, format);
#line 57
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)format,
           ap);
#line 58
  __builtin_va_end(ap);
#line 59
  _IO_putc('\n', stderr);
  }
#line 60
  return;
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/ifstat-1.1/data.c"
void (*ifstat_error)(char *format  , ...)  =    & _ifstat_error;
#line 64 "/home/june/repo/benchmarks/collector/temp/ifstat-1.1/data.c"
void ifstat_perror(char *func ) 
{ 
  int *tmp ;
  char *tmp___0 ;

  {
  {
#line 65
  tmp = __errno_location();
#line 65
  tmp___0 = strerror(*tmp);
#line 65
  (*ifstat_error)((char *)"%s: %s", func, tmp___0);
  }
#line 66
  return;
}
}
#line 68 "/home/june/repo/benchmarks/collector/temp/ifstat-1.1/data.c"
void ifstat_add_interface(struct ifstat_list *ifs , char *ifname , int flags ) 
{ 
  struct ifstat_data *cur ;
  struct ifstat_data *last ;
  int len ;
  size_t tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 73
  if ((int )*ifname == 0) {
#line 74
    return;
  }
  {
#line 75
  tmp = strlen((char const   *)ifname);
#line 75
  len = (int )tmp;
#line 77
  last = (struct ifstat_data *)((void *)0);
#line 78
  cur = ifs->first;
  }
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    if (! ((unsigned long )cur != (unsigned long )((void *)0))) {
#line 78
      goto while_break;
    }
#line 79
    if (len == cur->namelen) {
#line 79
      if ((int )*(cur->name + 0) == (int )*(ifname + 0)) {
        {
#line 79
        tmp___0 = strncmp((char const   *)(cur->name + 1), (char const   *)(ifname + 1),
                          (size_t )(len - 1));
        }
#line 79
        if (! tmp___0) {
#line 79
          if (! (flags & 128)) {
#line 79
            if (! (cur->flags & 128)) {
#line 83
              return;
            }
          }
        }
      }
    }
#line 84
    last = cur;
#line 78
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 87
  tmp___1 = calloc((size_t )1, sizeof(struct ifstat_data ));
#line 87
  cur = (struct ifstat_data *)tmp___1;
  }
#line 87
  if ((unsigned long )cur == (unsigned long )((void *)0)) {
    {
#line 88
    ifstat_perror((char *)"malloc");
#line 89
    exit(1);
    }
  }
  {
#line 91
  cur->name = strdup((char const   *)ifname);
#line 92
  cur->namelen = len;
#line 93
  cur->flags = flags;
  }
#line 94
  if ((unsigned long )last != (unsigned long )((void *)0)) {
#line 95
    last->next = cur;
  }
#line 96
  if ((unsigned long )ifs->first == (unsigned long )((void *)0)) {
#line 97
    ifs->first = cur;
  }
#line 98
  return;
}
}
#line 100 "/home/june/repo/benchmarks/collector/temp/ifstat-1.1/data.c"
void ifstat_free_interface(struct ifstat_data *data ) 
{ 


  {
  {
#line 101
  free((void *)data->name);
#line 102
  free((void *)data);
  }
#line 103
  return;
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/ifstat-1.1/data.c"
void ifstat_set_interface_stats(struct ifstat_data *data , unsigned long long bytesin ,
                                unsigned long long bytesout ) 
{ 


  {
#line 108
  if (data->bout > bytesout) {
#line 108
    goto _L;
  } else
#line 108
  if (data->bin > bytesin) {
    _L: /* CIL Label */ 
#line 109
    if (! ifstat_quiet) {
      {
#line 110
      (*ifstat_error)((char *)"warning: rollover for interface %s, reinitialising.",
                      data->name);
      }
    }
#line 111
    data->obout = bytesout;
#line 112
    data->obin = bytesin;
  } else {
#line 114
    data->obout = data->bout;
#line 115
    data->obin = data->bin;
  }
#line 117
  data->bout = bytesout;
#line 118
  data->bin = bytesin;
#line 119
  data->flags |= 4;
#line 120
  return;
}
}
#line 122 "/home/june/repo/benchmarks/collector/temp/ifstat-1.1/data.c"
void ifstat_set_interface_index(struct ifstat_data *data , int index___0 ) 
{ 


  {
#line 124
  data->index = index___0;
#line 125
  data->flags |= 8;
#line 126
  return;
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/ifstat-1.1/data.c"
struct ifstat_data *ifstat_get_interface(struct ifstat_list *ifs , char *ifname ) 
{ 
  struct ifstat_data *ptr ;
  int len ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 130
  tmp = strlen((char const   *)ifname);
#line 130
  len = (int )tmp;
#line 132
  ptr = ifs->first;
  }
  {
#line 132
  while (1) {
    while_continue: /* CIL Label */ ;
#line 132
    if (! ((unsigned long )ptr != (unsigned long )((void *)0))) {
#line 132
      goto while_break;
    }
#line 133
    if (len == ptr->namelen) {
#line 133
      if ((int )*(ptr->name + 0) == (int )*(ifname + 0)) {
        {
#line 133
        tmp___0 = strncmp((char const   *)(ptr->name + 1), (char const   *)(ifname + 1),
                          (size_t )(len - 1));
        }
#line 133
        if (! tmp___0) {
#line 133
          if (! (ptr->flags & 128)) {
#line 137
            return (ptr);
          }
        }
      }
    }
#line 132
    ptr = ptr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 138
  return ((struct ifstat_data *)((void *)0));
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/ifstat-1.1/data.c"
void ifstat_reset_interfaces(struct ifstat_list *ifs ) 
{ 
  struct ifstat_data *ptr ;
  int hasindex ;

  {
#line 143
  hasindex = 1;
#line 145
  ptr = ifs->first;
  {
#line 145
  while (1) {
    while_continue: /* CIL Label */ ;
#line 145
    if (! ((unsigned long )ptr != (unsigned long )((void *)0))) {
#line 145
      goto while_break;
    }
#line 146
    if (! (ptr->flags & 8)) {
#line 147
      hasindex = 0;
    }
#line 148
    ptr->flags &= -13;
#line 145
    ptr = ptr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 150
  if (hasindex) {
#line 151
    ifs->flags |= 8;
  } else {
#line 153
    ifs->flags &= -9;
  }
#line 154
  return;
}
}
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 243 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 215 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 144 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 101 "/home/june/repo/benchmarks/collector/temp/ifstat-1.1/ifstat.h"
int ifstat_get_driver(char *name , struct ifstat_driver *driver ) ;
#line 103
char *ifstat_list_drivers(void) ;
#line 71 "/home/june/repo/benchmarks/collector/temp/ifstat-1.1/ifstat.c"
static void _setsig(int sig , void (*handler)(int  ) ) 
{ 
  struct sigaction sa ;

  {
  {
#line 74
  memset((void *)(& sa), 0, sizeof(struct sigaction ));
#line 75
  sa.__sigaction_handler.sa_handler = handler;
#line 76
  sigemptyset(& sa.sa_mask);
#line 77
  sa.sa_flags = 268435456;
#line 78
  sigaction(sig, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
  }
#line 79
  return;
}
}
#line 132 "/home/june/repo/benchmarks/collector/temp/ifstat-1.1/ifstat.c"
static int parse_interfaces(char *string , struct ifstat_list *ifs ) 
{ 
  char *s ;
  char *d ;
  char *buf ;
  int len ;
  int escaped ;
  size_t tmp ;
  void *tmp___0 ;
  char *tmp___1 ;

  {
#line 134
  escaped = 0;
#line 136
  if ((unsigned long )string == (unsigned long )((void *)0)) {
#line 137
    return (0);
  } else {
    {
#line 136
    tmp = strlen((char const   *)string);
#line 136
    len = (int )tmp;
    }
#line 136
    if (len <= 0) {
#line 137
      return (0);
    }
  }
  {
#line 139
  tmp___0 = malloc((size_t )(len + 1));
#line 139
  buf = (char *)tmp___0;
  }
#line 139
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    {
#line 140
    ifstat_perror((char *)"malloc");
    }
#line 141
    return (0);
  }
#line 144
  d = buf;
#line 145
  s = string;
  {
#line 145
  while (1) {
    while_continue: /* CIL Label */ ;
#line 145
    if (! ((int )*s != 0)) {
#line 145
      goto while_break;
    }
#line 146
    if (! escaped) {
#line 147
      if ((int )*s == 92) {
#line 148
        escaped = 1;
#line 149
        goto __Cont;
      }
#line 151
      if ((int )*s == 44) {
        {
#line 152
        *d = (char )'\000';
#line 153
        ifstat_add_interface(ifs, buf, 0);
#line 154
        d = buf;
        }
#line 155
        goto __Cont;
      }
    } else {
#line 158
      escaped = 0;
    }
#line 159
    tmp___1 = d;
#line 159
    d ++;
#line 159
    *tmp___1 = *s;
    __Cont: /* CIL Label */ 
#line 145
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 161
  *d = (char )'\000';
#line 162
  if ((int )*buf != 0) {
    {
#line 163
    ifstat_add_interface(ifs, buf, 0);
    }
  }
  {
#line 165
  free((void *)buf);
  }
#line 166
  return (1);
}
}
#line 169 "/home/june/repo/benchmarks/collector/temp/ifstat-1.1/ifstat.c"
static void usage(int result ) 
{ 


  {
  {
#line 170
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"usage: %s [-a] [-l] [-z] [-n] [-v] [-h] [-t] [-i if0,if1,...]\n       [-d drv[:opt]] [-s [comm@][#]host[/nn]] [-T] [-A] [-w]\n       [-W] [-S] [-b] [-q] [delay[/delay] [count]]\n",
          ifstat_progname);
#line 174
  exit(result);
  }
}
}
#line 177 "/home/june/repo/benchmarks/collector/temp/ifstat-1.1/ifstat.c"
static void print_center(char *s , int len , int width ) 
{ 
  int ofs ;
  int i ;

  {
#line 180
  ofs = (width - len) / 2;
#line 181
  i = 0;
  {
#line 181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 181
    if (! (i < ofs)) {
#line 181
      goto while_break;
    }
    {
#line 182
    _IO_putc(' ', stdout);
#line 181
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 183
  i = 0;
  {
#line 183
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 183
    if (! (i < len)) {
#line 183
      goto while_break___0;
    }
    {
#line 184
    _IO_putc((int )*(s + i), stdout);
#line 183
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 185
  i = 0;
  {
#line 185
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 185
    if (! (i < width - (ofs + len))) {
#line 185
      goto while_break___1;
    }
    {
#line 186
    _IO_putc(' ', stdout);
#line 185
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 187
  return;
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/ifstat-1.1/ifstat.c"
struct __anonstruct_termsize_53 termsize  ;
#line 194 "/home/june/repo/benchmarks/collector/temp/ifstat-1.1/ifstat.c"
int _sigwinch  =    0;
#line 195 "/home/june/repo/benchmarks/collector/temp/ifstat-1.1/ifstat.c"
static void update_termsize(int sig ) 
{ 
  struct winsize ws ;
  int tmp ;

  {
  {
#line 199
  tmp = ioctl(1, 21523UL, & ws);
  }
#line 199
  if (tmp == 0) {
#line 199
    if ((int )ws.ws_row > 0) {
#line 199
      if ((int )ws.ws_col > 0) {
#line 201
        termsize.cols = (int )ws.ws_col;
#line 202
        termsize.lines = (int )ws.ws_row;
      } else {
#line 204
        termsize.lines = 25;
#line 205
        termsize.cols = 80;
      }
    } else {
#line 204
      termsize.lines = 25;
#line 205
      termsize.cols = 80;
    }
  } else {
#line 204
    termsize.lines = 25;
#line 205
    termsize.cols = 80;
  }
#line 208
  if (sig == 28) {
#line 209
    _sigwinch = 1;
  }
#line 213
  return;
}
}
#line 215 "/home/june/repo/benchmarks/collector/temp/ifstat-1.1/ifstat.c"
int _sigcont  =    0;
#line 217 "/home/june/repo/benchmarks/collector/temp/ifstat-1.1/ifstat.c"
static void sigcont(int sig ) 
{ 


  {
#line 219
  _sigcont = 1;
#line 221
  return;
}
}
#line 249 "/home/june/repo/benchmarks/collector/temp/ifstat-1.1/ifstat.c"
static void print_wrap(int options , int line ) 
{ 


  {
  {
#line 250
  _IO_putc('\n', stdout);
#line 251
  _IO_putc((int )((char )((line - 1) % 26 + 65)), stdout);
  }
#line 252
  if (options & 1) {
    {
#line 253
    fputs((char const   */* __restrict  */)"         ", (FILE */* __restrict  */)stdout);
    }
  }
#line 254
  return;
}
}
#line 256 "/home/june/repo/benchmarks/collector/temp/ifstat-1.1/ifstat.c"
static int pos_next(int pos , int len , int options ) 
{ 
  int ofs ;
  unsigned long tmp ;

  {
#line 257
  if (options & 1) {
#line 257
    tmp = (8UL + sizeof("  ")) - 1UL;
  } else {
#line 257
    tmp = 1UL;
  }
#line 257
  ofs = (int )tmp;
#line 259
  pos = (int )((unsigned long )pos + (((unsigned long )len + sizeof("  ")) - 1UL));
#line 260
  if (options & 64) {
#line 260
    if ((pos + ofs) + len >= termsize.cols) {
#line 261
      pos = 0;
    }
  }
#line 262
  return (pos);
}
}
#line 265 "/home/june/repo/benchmarks/collector/temp/ifstat-1.1/ifstat.c"
static void print_legend(struct ifstat_data *ptr , int options , int line ) 
{ 
  int len ;
  int pos ;
  char const   *tmp ;

  {
#line 268
  if (line == 0) {
    {
#line 269
    _IO_putc('\n', stdout);
    }
#line 270
    if (options & 1) {
      {
#line 271
      fputs((char const   */* __restrict  */)"HH:MM:SS  ", (FILE */* __restrict  */)stdout);
      }
    } else
#line 272
    if (options & 64) {
      {
#line 273
      _IO_putc(' ', stdout);
      }
    }
  } else {
    {
#line 275
    print_wrap(options, line);
    }
  }
#line 277
  pos = 0;
  {
#line 278
  while (1) {
    while_continue: /* CIL Label */ ;
#line 278
    if (! ((unsigned long )ptr != (unsigned long )((void *)0))) {
#line 278
      goto while_break;
    }
#line 279
    if (pos > 0) {
      {
#line 280
      fputs((char const   */* __restrict  */)"  ", (FILE */* __restrict  */)stdout);
      }
    }
#line 281
    if (options & 2) {
#line 281
      len = (int )(((ssize_t )sizeof("12345.12") - 1L) * 2L + ((ssize_t )sizeof("  ") - 1L));
    } else
#line 281
    if ((ssize_t )ptr->namelen < ((ssize_t )sizeof("12345.12") - 1L) * 2L + ((ssize_t )sizeof("  ") - 1L)) {
#line 281
      len = (int )(((ssize_t )sizeof("12345.12") - 1L) * 2L + ((ssize_t )sizeof("  ") - 1L));
    } else {
#line 281
      len = ptr->namelen;
    }
#line 282
    if (options & 4) {
#line 282
      tmp = " Kbps in  Kbps out";
    } else {
#line 282
      tmp = " KB/s in  KB/s out";
    }
    {
#line 282
    print_center((char *)tmp, (int )(((ssize_t )sizeof("12345.12") - 1L) * 2L + ((ssize_t )sizeof("  ") - 1L)),
                 len);
#line 284
    pos = pos_next(pos, len, options);
    }
#line 284
    if (pos == 0) {
#line 284
      if ((unsigned long )ptr->next != (unsigned long )((void *)0)) {
#line 285
        return;
      }
    }
#line 278
    ptr = ptr->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 287
  _IO_putc('\n', stdout);
  }
#line 288
  return;
}
}
#line 290 "/home/june/repo/benchmarks/collector/temp/ifstat-1.1/ifstat.c"
static void print_header(struct ifstat_list *ifs , int options ) 
{ 
  struct ifstat_data *ptr ;
  struct ifstat_data *start ;
  int len ;
  int pos ;
  int line ;
  int tmp ;

  {
#line 294
  if (options & 1) {
    {
#line 295
    fputs((char const   */* __restrict  */)"  Time    ", (FILE */* __restrict  */)stdout);
    }
  } else
#line 296
  if (options & 64) {
    {
#line 297
    _IO_putc(' ', stdout);
    }
  }
#line 299
  pos = 0;
#line 300
  line = 0;
#line 301
  start = ifs->first;
#line 302
  ptr = ifs->first;
  {
#line 302
  while (1) {
    while_continue: /* CIL Label */ ;
#line 302
    if (! ((unsigned long )ptr != (unsigned long )((void *)0))) {
#line 302
      goto while_break;
    }
#line 303
    if (pos == 0) {
#line 303
      if ((unsigned long )ptr != (unsigned long )ifs->first) {
        {
#line 304
        print_legend(start, options, line);
#line 305
        start = ptr;
#line 306
        line ++;
#line 306
        print_wrap(options, line);
        }
      } else {
#line 303
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 307
    if (pos > 0) {
      {
#line 308
      fputs((char const   */* __restrict  */)"  ", (FILE */* __restrict  */)stdout);
      }
    }
#line 309
    if (options & 2) {
#line 309
      len = (int )(((ssize_t )sizeof("12345.12") - 1L) * 2L + ((ssize_t )sizeof("  ") - 1L));
    } else
#line 309
    if ((ssize_t )ptr->namelen < ((ssize_t )sizeof("12345.12") - 1L) * 2L + ((ssize_t )sizeof("  ") - 1L)) {
#line 309
      len = (int )(((ssize_t )sizeof("12345.12") - 1L) * 2L + ((ssize_t )sizeof("  ") - 1L));
    } else {
#line 309
      len = ptr->namelen;
    }
#line 310
    if (ptr->namelen < len) {
#line 310
      tmp = ptr->namelen;
    } else {
#line 310
      tmp = len;
    }
    {
#line 310
    print_center(ptr->name, tmp, len);
#line 311
    pos = pos_next(pos, len, options);
#line 302
    ptr = ptr->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 313
  termsize.datalines = line + 1;
#line 314
  print_legend(start, options, line);
  }
#line 315
  return;
}
}
#line 317 "/home/june/repo/benchmarks/collector/temp/ifstat-1.1/ifstat.c"
static void print_stats(struct ifstat_list *ifs , struct timeval *start , struct timeval *end ,
                        int options ) 
{ 
  struct ifstat_data *ptr ;
  int hasindex ;
  int pos ;
  int len ;
  int line ;
  char stats[(((ssize_t )sizeof("12345.12") - 1L) * 2L + ((ssize_t )sizeof("  ") - 1L)) + 1L] ;
  double delay ;
  double kbin ;
  double kbout ;
  double tkbin ;
  double tkbout ;
  double scale ;
  struct tm *ltm ;
  time_t t ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;

  {
#line 322
  hasindex = 1;
#line 322
  pos = 0;
#line 322
  line = 0;
#line 327
  if (options & 256) {
    {
#line 328
    _IO_putc('\r', stdout);
    }
  }
#line 330
  if (options & 1) {
    {
#line 331
    t = end->tv_sec;
#line 332
    ltm = localtime((time_t const   *)(& t));
    }
#line 332
    if ((unsigned long )ltm != (unsigned long )((void *)0)) {
      {
#line 333
      fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%02d:%02d:%02d  ",
              ltm->tm_hour, ltm->tm_min, ltm->tm_sec);
      }
    } else {
      {
#line 336
      fputs((char const   */* __restrict  */)"--:--:--  ", (FILE */* __restrict  */)stdout);
      }
    }
  } else
#line 337
  if (options & 64) {
    {
#line 338
    _IO_putc(' ', stdout);
    }
  }
#line 340
  delay = (double )(end->tv_sec - start->tv_sec) + (double )(end->tv_usec - start->tv_usec) / (double )1000000;
#line 342
  if (options & 4) {
#line 342
    tmp = 128;
  } else {
#line 342
    tmp = 1024;
  }
#line 342
  scale = delay * (double )tmp;
#line 344
  tkbout = (double )0;
#line 344
  tkbin = tkbout;
#line 345
  ptr = ifs->first;
  {
#line 345
  while (1) {
    while_continue: /* CIL Label */ ;
#line 345
    if (! ((unsigned long )ptr != (unsigned long )((void *)0))) {
#line 345
      goto while_break;
    }
#line 346
    if (ptr->flags & 4) {
#line 347
      kbin = (double )(ptr->bin - ptr->obin) / scale;
#line 348
      tkbin += kbin;
#line 349
      kbout = (double )(ptr->bout - ptr->obout) / scale;
#line 350
      tkbout += kbout;
#line 351
      ptr->flags &= -5;
    } else
#line 352
    if (ptr->flags & 128) {
#line 353
      kbin = tkbin;
#line 354
      kbout = tkbout;
    } else {
#line 356
      kbin = (double )-1;
#line 357
      kbout = (double )-1;
    }
#line 360
    if (ptr->flags & 8) {
#line 361
      ptr->flags &= -9;
    } else {
#line 363
      hasindex = 0;
    }
#line 365
    if (kbin >= (double )0) {
#line 366
      if (kbin < 1e+5) {
#line 366
        tmp___1 = "%8.2f";
      } else {
#line 366
        if (kbin < 1e+6) {
#line 366
          tmp___0 = "%.1f";
        } else {
#line 366
          tmp___0 = "%.2e";
        }
#line 366
        tmp___1 = tmp___0;
      }
      {
#line 366
      snprintf((char */* __restrict  */)(stats), sizeof("12345.12"), (char const   */* __restrict  */)tmp___1,
               kbin);
      }
    } else {
      {
#line 368
      strcpy((char */* __restrict  */)(stats), (char const   */* __restrict  */)"     n/a");
      }
    }
    {
#line 369
    strcpy((char */* __restrict  */)((stats + sizeof("12345.12")) - 1), (char const   */* __restrict  */)"  ");
    }
#line 370
    if (kbout >= (double )0) {
#line 371
      if (kbout < 1e+5) {
#line 371
        tmp___3 = "%8.2f";
      } else {
#line 371
        if (kbout < 1e+6) {
#line 371
          tmp___2 = "%.1f";
        } else {
#line 371
          tmp___2 = "%.2e";
        }
#line 371
        tmp___3 = tmp___2;
      }
      {
#line 371
      snprintf((char */* __restrict  */)(((stats + sizeof("12345.12")) + sizeof("  ")) - 2),
               sizeof("12345.12"), (char const   */* __restrict  */)tmp___3, kbout);
      }
    } else {
      {
#line 374
      strcpy((char */* __restrict  */)(((stats + sizeof("12345.12")) + sizeof("  ")) - 2),
             (char const   */* __restrict  */)"     n/a");
      }
    }
#line 376
    if (pos == 0) {
#line 376
      if ((unsigned long )ptr != (unsigned long )ifs->first) {
        {
#line 377
        line ++;
#line 377
        print_wrap(options, line);
        }
      } else {
#line 376
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 378
    if (pos > 0) {
      {
#line 379
      fputs((char const   */* __restrict  */)"  ", (FILE */* __restrict  */)stdout);
      }
    }
#line 381
    if (options & 2) {
#line 381
      len = (int )(((ssize_t )sizeof("12345.12") - 1L) * 2L + ((ssize_t )sizeof("  ") - 1L));
    } else
#line 381
    if ((ssize_t )ptr->namelen < ((ssize_t )sizeof("12345.12") - 1L) * 2L + ((ssize_t )sizeof("  ") - 1L)) {
#line 381
      len = (int )(((ssize_t )sizeof("12345.12") - 1L) * 2L + ((ssize_t )sizeof("  ") - 1L));
    } else {
#line 381
      len = ptr->namelen;
    }
    {
#line 382
    print_center(stats, (int )(((ssize_t )sizeof("12345.12") - 1L) * 2L + ((ssize_t )sizeof("  ") - 1L)),
                 len);
#line 383
    pos = pos_next(pos, len, options);
#line 345
    ptr = ptr->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 385
  termsize.datalines = line + 1;
#line 386
  if (! (options & 256)) {
    {
#line 387
    _IO_putc('\n', stdout);
    }
  }
#line 389
  if (hasindex) {
#line 389
    if (! (options & 8)) {
#line 390
      ifs->flags |= 8;
    } else {
#line 392
      ifs->flags &= -9;
    }
  } else {
#line 392
    ifs->flags &= -9;
  }
#line 393
  return;
}
}
#line 395 "/home/june/repo/benchmarks/collector/temp/ifstat-1.1/ifstat.c"
static void filter_interfaces(struct ifstat_list *ifs , int options ) 
{ 
  struct ifstat_data *cur ;
  struct ifstat_data *next ;
  struct ifstat_data *parent ;

  {
#line 398
  cur = ifs->first;
#line 399
  parent = (struct ifstat_data *)((void *)0);
  {
#line 400
  while (1) {
    while_continue: /* CIL Label */ ;
#line 400
    if (! ((unsigned long )cur != (unsigned long )((void *)0))) {
#line 400
      goto while_break;
    }
#line 401
    if (! (cur->flags & 4)) {
#line 401
      goto _L;
    } else
#line 401
    if (options & 16) {
#line 401
      if (cur->bin == 0ULL) {
#line 401
        if (cur->bout == 0ULL) {
          _L: /* CIL Label */ 
#line 403
          next = cur->next;
#line 404
          if ((unsigned long )parent != (unsigned long )((void *)0)) {
#line 405
            parent->next = next;
          } else {
#line 407
            ifs->first = next;
          }
          {
#line 408
          ifstat_free_interface(cur);
#line 409
          cur = next;
          }
        } else {
#line 411
          parent = cur;
#line 412
          cur = cur->next;
        }
      } else {
#line 411
        parent = cur;
#line 412
        cur = cur->next;
      }
    } else {
#line 411
      parent = cur;
#line 412
      cur = cur->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 415
  return;
}
}
#line 417 "/home/june/repo/benchmarks/collector/temp/ifstat-1.1/ifstat.c"
static void needarg(char opt , int arg , int argc ) 
{ 


  {
#line 418
  if (arg + 1 >= argc) {
    {
#line 419
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: option \'%c\' requires an argument!\n",
            ifstat_progname, (int )opt);
#line 420
    usage(1);
    }
  }
#line 422
  return;
}
}
#line 424 "/home/june/repo/benchmarks/collector/temp/ifstat-1.1/ifstat.c"
static double getdelay(char *string ) 
{ 
  double delay ;

  {
  {
#line 427
  delay = atof((char const   *)string);
  }
#line 427
  if (delay < 0.1) {
    {
#line 428
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: bad or too short delay \'%s\'!\n",
            ifstat_progname, string);
#line 429
    exit(1);
    }
  }
#line 431
  return (delay);
}
}
#line 435 "/home/june/repo/benchmarks/collector/temp/ifstat-1.1/ifstat.c"
static int notdone(struct timeval *start , struct timeval *tv_delay , struct timeval *remains ) 
{ 
  struct timeval now ;
  struct timeval end ;

  {
  {
#line 440
  gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )((void *)0));
#line 442
  end.tv_sec = start->tv_sec + tv_delay->tv_sec;
#line 443
  end.tv_usec = start->tv_usec + tv_delay->tv_usec;
  }
#line 444
  if (end.tv_usec >= 1000000L) {
#line 445
    end.tv_sec += end.tv_usec / 1000000L;
#line 446
    end.tv_usec %= 1000000L;
  }
#line 449
  remains->tv_sec = end.tv_sec - now.tv_sec;
#line 450
  remains->tv_usec = end.tv_usec - now.tv_usec;
#line 451
  if (remains->tv_usec < 0L) {
#line 452
    (remains->tv_sec) --;
#line 453
    remains->tv_usec += 1000000L;
  }
#line 455
  return (remains->tv_sec >= 0L);
}
}
#line 458 "/home/june/repo/benchmarks/collector/temp/ifstat-1.1/ifstat.c"
int main(int argc , char **argv ) 
{ 
  struct ifstat_list ifs ;
  struct ifstat_driver driver ;
  int arg ;
  int iter ;
  int lasthdr ;
  char *opt ;
  char *dname ;
  char *dopts ;
  double delay ;
  double first_delay ;
  int count ;
  int options ;
  struct timeval start ;
  struct timeval tv_delay ;
  struct timeval tv ;
  char const   *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  double tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 463
  dname = (char *)((void *)0);
#line 464
  dopts = (char *)((void *)0);
#line 465
  delay = (double )1;
#line 465
  first_delay = (double )1;
#line 466
  count = 0;
#line 467
  options = 0;
#line 471
  ifstat_progname = strrchr((char const   *)*(argv + 0), '/');
  }
#line 471
  if ((unsigned long )ifstat_progname != (unsigned long )((void *)0)) {
#line 472
    ifstat_progname ++;
  } else {
#line 474
    ifstat_progname = *(argv + 0);
  }
#line 476
  ifs.flags = 0;
#line 477
  ifs.first = (struct ifstat_data *)((void *)0);
#line 480
  arg = 1;
  {
#line 480
  while (1) {
    while_continue: /* CIL Label */ ;
#line 480
    if (! (arg < argc)) {
#line 480
      goto while_break;
    }
#line 481
    if ((int )*(*(argv + arg) + 0) != 45) {
#line 482
      goto while_break;
    } else
#line 481
    if ((int )*(*(argv + arg) + 1) == 0) {
#line 482
      goto while_break;
    }
#line 483
    opt = *(argv + arg) + 1;
    {
#line 484
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 484
      if (! *opt) {
#line 484
        goto while_break___0;
      }
      {
#line 486
      if ((int )*opt == 97) {
#line 486
        goto case_97;
      }
#line 489
      if ((int )*opt == 108) {
#line 489
        goto case_108;
      }
#line 492
      if ((int )*opt == 118) {
#line 492
        goto case_118;
      }
#line 500
      if ((int )*opt == 65) {
#line 500
        goto case_65;
      }
#line 503
      if ((int )*opt == 110) {
#line 503
        goto case_110;
      }
#line 506
      if ((int )*opt == 116) {
#line 506
        goto case_116;
      }
#line 509
      if ((int )*opt == 119) {
#line 509
        goto case_119;
      }
#line 512
      if ((int )*opt == 98) {
#line 512
        goto case_98;
      }
#line 515
      if ((int )*opt == 122) {
#line 515
        goto case_122;
      }
#line 518
      if ((int )*opt == 87) {
#line 518
        goto case_87;
      }
#line 521
      if ((int )*opt == 84) {
#line 521
        goto case_84;
      }
#line 524
      if ((int )*opt == 83) {
#line 524
        goto case_83;
      }
#line 527
      if ((int )*opt == 100) {
#line 527
        goto case_100;
      }
#line 533
      if ((int )*opt == 105) {
#line 533
        goto case_105;
      }
#line 541
      if ((int )*opt == 115) {
#line 541
        goto case_115;
      }
#line 546
      if ((int )*opt == 113) {
#line 546
        goto case_113;
      }
#line 549
      if ((int )*opt == 104) {
#line 549
        goto case_104;
      }
#line 551
      goto switch_default;
      case_97: /* CIL Label */ 
#line 487
      ifs.flags |= 3;
#line 488
      goto switch_break;
      case_108: /* CIL Label */ 
#line 490
      ifs.flags |= 1;
#line 491
      goto switch_break;
      case_118: /* CIL Label */ 
      {
#line 493
      printf((char const   */* __restrict  */)"ifstat version %s.\nCopyright (C) 2001-2003, Ga\353l Roualland <gael.roualland@dial.oleane.com>\n",
             ifstat_version);
#line 496
      opt = ifstat_list_drivers();
      }
#line 497
      if ((unsigned long )opt != (unsigned long )((void *)0)) {
#line 497
        tmp = (char const   *)opt;
      } else {
#line 497
        tmp = "";
      }
      {
#line 497
      printf((char const   */* __restrict  */)"Compiled-in drivers: %s.\n", tmp);
#line 498
      free((void *)opt);
#line 499
      exit(0);
      }
      case_65: /* CIL Label */ 
#line 501
      options |= 8;
#line 502
      goto switch_break;
      case_110: /* CIL Label */ 
#line 504
      options |= 128;
#line 505
      goto switch_break;
      case_116: /* CIL Label */ 
#line 507
      options |= 1;
#line 508
      goto switch_break;
      case_119: /* CIL Label */ 
#line 510
      options |= 2;
#line 511
      goto switch_break;
      case_98: /* CIL Label */ 
#line 513
      options |= 4;
#line 514
      goto switch_break;
      case_122: /* CIL Label */ 
#line 516
      options |= 16;
#line 517
      goto switch_break;
      case_87: /* CIL Label */ 
#line 519
      options |= 66;
#line 520
      goto switch_break;
      case_84: /* CIL Label */ 
#line 522
      ifs.flags |= 128;
#line 523
      goto switch_break;
      case_83: /* CIL Label */ 
#line 525
      options |= 384;
#line 526
      goto switch_break;
      case_100: /* CIL Label */ 
      {
#line 528
      needarg(*opt, arg, argc);
#line 529
      arg ++;
#line 529
      dname = *(argv + arg);
#line 530
      dopts = strchr((char const   *)dname, ':');
      }
#line 530
      if ((unsigned long )dopts != (unsigned long )((void *)0)) {
#line 531
        tmp___0 = dopts;
#line 531
        dopts ++;
#line 531
        *tmp___0 = (char )'\000';
      }
#line 532
      goto switch_break;
      case_105: /* CIL Label */ 
      {
#line 534
      needarg(*opt, arg, argc);
#line 535
      arg ++;
#line 535
      tmp___1 = parse_interfaces(*(argv + arg), & ifs);
      }
#line 535
      if (! tmp___1) {
        {
#line 536
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error parsing interface list.\n",
                ifstat_progname);
#line 537
        exit(1);
        }
      }
#line 539
      options |= 32;
#line 540
      goto switch_break;
      case_115: /* CIL Label */ 
      {
#line 542
      needarg(*opt, arg, argc);
#line 543
      dname = (char *)"snmp";
#line 544
      arg ++;
#line 544
      dopts = *(argv + arg);
      }
#line 545
      goto switch_break;
      case_113: /* CIL Label */ 
#line 547
      ifstat_quiet = 1;
#line 548
      goto switch_break;
      case_104: /* CIL Label */ 
      {
#line 550
      usage(0);
      }
      switch_default: /* CIL Label */ 
      {
#line 552
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: invalid option \'-%c\'.\n",
              ifstat_progname, (int )*opt);
#line 553
      usage(1);
      }
      switch_break: /* CIL Label */ ;
      }
#line 555
      opt ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 480
    arg ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 559
  if (options & 256) {
#line 560
    options &= -65;
  }
#line 563
  if (arg < argc) {
    {
#line 564
    opt = strchr((char const   *)*(argv + arg), '/');
    }
#line 564
    if ((unsigned long )opt != (unsigned long )((void *)0)) {
#line 565
      tmp___2 = opt;
#line 565
      opt ++;
#line 565
      *tmp___2 = (char )'\000';
    }
    {
#line 566
    first_delay = getdelay(*(argv + arg));
    }
#line 567
    if ((unsigned long )opt != (unsigned long )((void *)0)) {
      {
#line 567
      tmp___3 = getdelay(opt);
#line 567
      delay = tmp___3;
      }
    } else {
#line 567
      delay = first_delay;
    }
#line 568
    arg ++;
  }
#line 572
  if (arg < argc) {
    {
#line 573
    count = atoi((char const   *)*(argv + arg));
    }
#line 573
    if (count <= 0) {
      {
#line 574
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: bad count \'%s\'!\n",
              ifstat_progname, *(argv + arg));
      }
#line 575
      return (1);
    }
#line 577
    arg ++;
  }
#line 581
  if (arg < argc) {
    {
#line 582
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: too many arguments!\n",
            ifstat_progname);
    }
#line 583
    return (1);
  }
  {
#line 587
  tmp___4 = ifstat_get_driver(dname, & driver);
  }
#line 587
  if (! tmp___4) {
    {
#line 588
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: driver %s not available in this binary!\n",
            ifstat_progname, dname);
    }
#line 589
    return (1);
  }
#line 593
  if ((unsigned long )driver.open_driver != (unsigned long )((void *)0)) {
    {
#line 593
    tmp___5 = (*(driver.open_driver))(& driver, dopts);
    }
#line 593
    if (! tmp___5) {
#line 595
      return (1);
    }
  }
#line 597
  if ((unsigned long )ifs.first == (unsigned long )((void *)0)) {
    {
#line 598
    (*(driver.scan_interfaces))(& driver, & ifs);
    }
  }
#line 601
  if ((unsigned long )ifs.first != (unsigned long )((void *)0)) {
#line 602
    if ((unsigned long )driver.get_stats != (unsigned long )((void *)0)) {
      {
#line 602
      tmp___6 = (*(driver.get_stats))(& driver, & ifs);
      }
#line 602
      if (! tmp___6) {
#line 603
        return (1);
      }
    }
    {
#line 604
    gettimeofday((struct timeval */* __restrict  */)(& start), (__timezone_ptr_t )((void *)0));
    }
#line 606
    if (! (options & 32)) {
      {
#line 607
      filter_interfaces(& ifs, options);
      }
    }
    {
#line 609
    ifstat_reset_interfaces(& ifs);
    }
  }
#line 612
  if ((unsigned long )ifs.first == (unsigned long )((void *)0)) {
    {
#line 613
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: no interfaces to monitor!\n",
            ifstat_progname);
    }
#line 614
    if ((unsigned long )driver.close_driver != (unsigned long )((void *)0)) {
      {
#line 615
      (*(driver.close_driver))(& driver);
      }
    }
#line 616
    return (1);
  }
#line 619
  if (ifs.flags & 128) {
    {
#line 620
    ifstat_add_interface(& ifs, (char *)"Total", 128);
    }
  }
#line 623
  if (! (options & 128)) {
    {
#line 624
    update_termsize(0);
#line 626
    _setsig(28, & update_termsize);
    }
  } else
#line 623
  if (options & 64) {
    {
#line 624
    update_termsize(0);
#line 626
    _setsig(28, & update_termsize);
    }
  }
#line 631
  if (! (options & 128)) {
    {
#line 632
    _setsig(18, & sigcont);
    }
  } else
#line 631
  if (options & 256) {
    {
#line 632
    _setsig(18, & sigcont);
    }
  }
  {
#line 635
  print_header(& ifs, options);
#line 636
  lasthdr = 1;
#line 638
  tv_delay.tv_sec = (__time_t )((int )first_delay);
#line 639
  tv_delay.tv_usec = (__suseconds_t )((int )((first_delay - (double )tv_delay.tv_sec) * (double )1000000));
#line 641
  iter = 1;
  }
  {
#line 641
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 641
    if (! (count == 0)) {
#line 641
      if (! (iter <= count)) {
#line 641
        goto while_break___1;
      }
    }
#line 642
    if (iter == 2) {
#line 642
      if (first_delay != delay) {
#line 643
        tv_delay.tv_sec = (__time_t )((int )delay);
#line 644
        tv_delay.tv_usec = (__suseconds_t )((int )((delay - (double )tv_delay.tv_sec) * (double )1000000));
      }
    }
#line 646
    tv = tv_delay;
    {
#line 647
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 647
      tmp___7 = select(0, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)((void *)0),
                       (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
      }
#line 647
      if (tmp___7 != 0) {
#line 647
        if (_sigwinch) {
          {
#line 647
          tmp___8 = notdone(& start, & tv_delay, & tv);
          }
#line 647
          if (! tmp___8) {
#line 647
            goto while_break___2;
          }
        } else {
#line 647
          goto while_break___2;
        }
      } else {
#line 647
        goto while_break___2;
      }
#line 650
      _sigwinch = 0;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 651
    if (_sigcont) {
      {
#line 656
      print_header(& ifs, options);
#line 657
      lasthdr = iter;
#line 658
      _sigcont = 0;
      }
    } else
#line 651
    if (! (options & 128)) {
#line 651
      if (termsize.lines > 3 * termsize.datalines) {
#line 651
        if ((iter - lasthdr) * termsize.datalines >= termsize.lines - 3 * termsize.datalines) {
          {
#line 656
          print_header(& ifs, options);
#line 657
          lasthdr = iter;
#line 658
          _sigcont = 0;
          }
        }
      }
    }
#line 660
    if ((unsigned long )driver.get_stats != (unsigned long )((void *)0)) {
      {
#line 660
      tmp___9 = (*(driver.get_stats))(& driver, & ifs);
      }
#line 660
      if (! tmp___9) {
#line 661
        return (1);
      }
    }
    {
#line 662
    gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
#line 663
    print_stats(& ifs, & start, & tv, options);
#line 664
    start = tv;
#line 665
    fflush(stdout);
#line 641
    iter ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 668
  if ((unsigned long )driver.close_driver != (unsigned long )((void *)0)) {
    {
#line 669
    (*(driver.close_driver))(& driver);
    }
  }
#line 671
  return (0);
}
}
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 197 "/usr/include/net/if.h"
extern  __attribute__((__nothrow__)) struct if_nameindex *( __attribute__((__leaf__)) if_nameindex)(void) ;
#line 200
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) if_freenameindex)(struct if_nameindex *__ptr ) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 141 "/home/june/repo/benchmarks/collector/temp/ifstat-1.1/drivers.c"
static void examine_interface(struct ifstat_list *ifs , char *name , int ifflags ,
                              int iftype ) 
{ 


  {
#line 145
  if (ifflags & 8) {
#line 145
    if (! (ifs->flags & 1)) {
#line 146
      return;
    }
  }
#line 149
  if (! (ifflags & 1)) {
#line 149
    if (! (ifs->flags & 2)) {
#line 150
      return;
    }
  }
  {
#line 157
  ifstat_add_interface(ifs, name, 0);
  }
#line 158
  return;
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/ifstat-1.1/drivers.c"
static int ioctl_map_ifs(int sd , int (*mapf)(int sd , struct ifreq *ifr , void *data ) ,
                         void *mdata ) 
{ 
  struct if_nameindex *iflist ;
  struct if_nameindex *cur ;
  struct ifreq ifr ;
  int tmp ;

  {
  {
#line 169
  iflist = if_nameindex();
  }
#line 169
  if ((unsigned long )iflist == (unsigned long )((void *)0)) {
    {
#line 170
    ifstat_perror((char *)"if_nameindex");
    }
#line 171
    return (0);
  }
#line 174
  cur = iflist;
  {
#line 174
  while (1) {
    while_continue: /* CIL Label */ ;
#line 174
    if (cur->if_index != 0U) {
#line 174
      if (! ((unsigned long )cur->if_name != (unsigned long )((void *)0))) {
#line 174
        goto while_break;
      }
    } else {
#line 174
      goto while_break;
    }
    {
#line 175
    memcpy((void */* __restrict  */)(ifr.ifr_ifrn.ifrn_name), (void const   */* __restrict  */)cur->if_name,
           sizeof(ifr.ifr_ifrn.ifrn_name));
#line 176
    ifr.ifr_ifrn.ifrn_name[sizeof(ifr.ifr_ifrn.ifrn_name) - 1UL] = (char )'\000';
#line 177
    tmp = (*mapf)(sd, & ifr, mdata);
    }
#line 177
    if (! tmp) {
#line 178
      return (0);
    }
#line 174
    cur ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 180
  if_freenameindex(iflist);
  }
#line 181
  return (1);
}
}
#line 234 "/home/june/repo/benchmarks/collector/temp/ifstat-1.1/drivers.c"
static int ioctl_map_scan(int sd , struct ifreq *ifr , void *data ) 
{ 
  int tmp ;

  {
  {
#line 236
  tmp = ioctl(sd, 35091UL, (char *)ifr);
  }
#line 236
  if (tmp != 0) {
#line 237
    return (1);
  }
  {
#line 238
  examine_interface((struct ifstat_list *)data, ifr->ifr_ifrn.ifrn_name, (int )ifr->ifr_ifru.ifru_flags,
                    0);
  }
#line 240
  return (1);
}
}
#line 243 "/home/june/repo/benchmarks/collector/temp/ifstat-1.1/drivers.c"
static int ioctl_scan_interfaces(struct ifstat_driver *driver , struct ifstat_list *ifs ) 
{ 
  int sd ;

  {
  {
#line 248
  sd = socket(2, 2, 0);
  }
#line 248
  if (sd < 0) {
    {
#line 249
    ifstat_perror((char *)"socket");
    }
#line 250
    return (0);
  }
  {
#line 253
  ioctl_map_ifs(sd, & ioctl_map_scan, (void *)ifs);
#line 254
  close(sd);
  }
#line 256
  return (1);
}
}
#line 778 "/home/june/repo/benchmarks/collector/temp/ifstat-1.1/drivers.c"
static int proc_open_driver(struct ifstat_driver *driver , char *options ) 
{ 
  struct proc_driver_data *data ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 782
  tmp = malloc(sizeof(struct proc_driver_data ));
#line 782
  data = (struct proc_driver_data *)tmp;
  }
#line 782
  if ((unsigned long )data == (unsigned long )((void *)0)) {
    {
#line 783
    ifstat_perror((char *)"malloc");
    }
#line 784
    return (0);
  }
#line 787
  if ((unsigned long )options != (unsigned long )((void *)0)) {
    {
#line 787
    tmp___0 = strdup((char const   *)options);
#line 787
    data->file = tmp___0;
    }
  } else {
#line 787
    data->file = (char *)((void *)0);
  }
#line 788
  data->checked = 0;
#line 789
  driver->data = (void *)data;
#line 791
  return (1);
}
}
#line 794 "/home/june/repo/benchmarks/collector/temp/ifstat-1.1/drivers.c"
static void proc_close_driver(struct ifstat_driver *driver ) 
{ 
  struct proc_driver_data *data ;

  {
#line 795
  data = (struct proc_driver_data *)driver->data;
#line 797
  if ((unsigned long )data->file != (unsigned long )((void *)0)) {
    {
#line 798
    free((void *)data->file);
    }
  }
  {
#line 799
  free((void *)data);
  }
#line 800
  return;
}
}
#line 802 "/home/june/repo/benchmarks/collector/temp/ifstat-1.1/drivers.c"
static int proc_get_stats(struct ifstat_driver *driver , struct ifstat_list *ifs ) 
{ 
  char buf[1024] ;
  FILE *f ;
  char *iface ;
  char *stats ;
  unsigned long long bytesin ;
  unsigned long long bytesout ;
  struct ifstat_data *cur ;
  struct proc_driver_data *data ;
  char *file ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;

  {
#line 809
  data = (struct proc_driver_data *)driver->data;
#line 812
  if ((unsigned long )data->file != (unsigned long )((void *)0)) {
#line 813
    file = data->file;
  } else {
#line 815
    file = (char *)"/proc/net/dev";
  }
  {
#line 817
  f = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"r");
  }
#line 817
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 818
    tmp = __errno_location();
#line 818
    tmp___0 = strerror(*tmp);
#line 818
    (*ifstat_error)((char *)"can\'t open %s: %s", file, tmp___0);
    }
#line 819
    return (0);
  }
  {
#line 823
  tmp___1 = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)f);
  }
#line 823
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 824
    goto badproc;
  }
#line 825
  if (! data->checked) {
    {
#line 825
    tmp___2 = strncmp((char const   *)(buf), "Inter-|", (size_t )7);
    }
#line 825
    if (tmp___2) {
#line 826
      goto badproc;
    }
  }
  {
#line 827
  tmp___3 = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)f);
  }
#line 827
  if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
#line 828
    goto badproc;
  }
#line 829
  if (! data->checked) {
    {
#line 830
    tmp___4 = strncmp((char const   *)(buf), " face |by", (size_t )9);
    }
#line 830
    if (tmp___4) {
#line 831
      goto badproc;
    }
#line 832
    data->checked = 1;
  }
  {
#line 835
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 835
    tmp___7 = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)f);
    }
#line 835
    if (! ((unsigned long )tmp___7 != (unsigned long )((void *)0))) {
#line 835
      goto while_break;
    }
    {
#line 836
    stats = strchr((char const   *)(buf), ':');
    }
#line 836
    if ((unsigned long )stats == (unsigned long )((void *)0)) {
#line 837
      goto while_continue;
    }
#line 838
    tmp___5 = stats;
#line 838
    stats ++;
#line 838
    *tmp___5 = (char )'\000';
#line 839
    iface = buf;
    {
#line 840
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 840
      if (! ((int )*iface == 32)) {
#line 840
        goto while_break___0;
      }
#line 841
      iface ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 842
    if ((int )*iface == 0) {
#line 843
      goto while_continue;
    }
    {
#line 844
    tmp___6 = sscanf((char const   */* __restrict  */)stats, (char const   */* __restrict  */)"%llu %*u %*u %*u %*u %*u %*u %*u %llu %*u",
                     & bytesin, & bytesout);
    }
#line 844
    if (tmp___6 != 2) {
#line 845
      goto while_continue;
    }
    {
#line 847
    cur = ifstat_get_interface(ifs, iface);
    }
#line 847
    if ((unsigned long )cur != (unsigned long )((void *)0)) {
      {
#line 848
      ifstat_set_interface_stats(cur, bytesin, bytesout);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 850
  fclose(f);
  }
#line 851
  return (1);
  badproc: 
  {
#line 854
  fclose(f);
#line 855
  (*ifstat_error)((char *)"%s: unsupported format.", file);
  }
#line 856
  return (0);
}
}
#line 1348 "/home/june/repo/benchmarks/collector/temp/ifstat-1.1/drivers.c"
static struct ifstat_driver drivers[2]  = {      {(char *)"proc", & proc_open_driver, & ioctl_scan_interfaces, & proc_get_stats,
      & proc_close_driver, (void *)0}, 
        {(char *)((void *)0), (int (*)(struct ifstat_driver *driver , char *options ))((void *)0),
      (int (*)(struct ifstat_driver *driver , struct ifstat_list *ifs ))((void *)0),
      (int (*)(struct ifstat_driver *driver , struct ifstat_list *ifs ))((void *)0),
      (void (*)(struct ifstat_driver *driver ))((void *)0), (void *)0}};
#line 1386 "/home/june/repo/benchmarks/collector/temp/ifstat-1.1/drivers.c"
int ifstat_get_driver(char *name , struct ifstat_driver *driver ) 
{ 
  int num ;
  int tmp ;

  {
#line 1387
  num = 0;
#line 1389
  if ((unsigned long )name != (unsigned long )((void *)0)) {
#line 1390
    num = 0;
    {
#line 1390
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1390
      if (! ((unsigned long )drivers[num].name != (unsigned long )((void *)0))) {
#line 1390
        goto while_break;
      }
      {
#line 1391
      tmp = strcasecmp((char const   *)drivers[num].name, (char const   *)name);
      }
#line 1391
      if (! tmp) {
#line 1392
        goto while_break;
      }
#line 1390
      num ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1394
  if ((unsigned long )drivers[num].name == (unsigned long )((void *)0)) {
#line 1395
    return (0);
  }
  {
#line 1397
  memcpy((void */* __restrict  */)driver, (void const   */* __restrict  */)(& drivers[num]),
         sizeof(struct ifstat_driver ));
#line 1398
  driver->data = (void *)0;
  }
#line 1399
  return (1);
}
}
#line 1402 "/home/june/repo/benchmarks/collector/temp/ifstat-1.1/drivers.c"
char *ifstat_list_drivers(void) 
{ 
  int num ;
  int len ;
  int pos ;
  char *res ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;

  {
#line 1404
  len = 0;
#line 1404
  pos = 0;
#line 1407
  num = 0;
  {
#line 1407
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1407
    if (! ((unsigned long )drivers[num].name != (unsigned long )((void *)0))) {
#line 1407
      goto while_break;
    }
    {
#line 1408
    tmp = strlen((char const   *)drivers[num].name);
#line 1408
    len = (int )((size_t )len + (tmp + 2UL));
#line 1407
    num ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1410
  tmp___0 = malloc((size_t )(len + 1));
#line 1410
  res = (char *)tmp___0;
  }
#line 1410
  if ((unsigned long )res == (unsigned long )((void *)0)) {
    {
#line 1411
    ifstat_perror((char *)"malloc");
    }
#line 1412
    return ((char *)((void *)0));
  }
#line 1415
  num = 0;
  {
#line 1415
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1415
    if (! ((unsigned long )drivers[num].name != (unsigned long )((void *)0))) {
#line 1415
      goto while_break___0;
    }
#line 1416
    if (num != 0) {
      {
#line 1417
      memcpy((void */* __restrict  */)(res + pos), (void const   */* __restrict  */)", ",
             (size_t )2);
#line 1418
      pos += 2;
      }
    }
    {
#line 1420
    tmp___1 = strlen((char const   *)drivers[num].name);
#line 1420
    len = (int )tmp___1;
#line 1421
    memcpy((void */* __restrict  */)(res + pos), (void const   */* __restrict  */)drivers[num].name,
           (size_t )len);
#line 1422
    pos += len;
#line 1415
    num ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1424
  *(res + pos) = (char )'\000';
#line 1425
  return (res);
}
}
