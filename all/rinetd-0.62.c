/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_3 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_3 fd_set;
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 257 "/usr/include/netdb.h"
struct servent {
   char *s_name ;
   char **s_aliases ;
   int s_port ;
   char *s_proto ;
};
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 230 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
struct _rinetd_options;
#line 230 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
typedef struct _rinetd_options RinetdOptions;
#line 231 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
struct _rinetd_options {
   char const   *conf_file ;
   int foreground ;
};
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 149
extern ssize_t send(int __fd , void const   *__buf , size_t __n , int __flags ) ;
#line 156
extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 233
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 243
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 375 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 61 "/usr/include/netdb.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __h_errno_location)(void)  __attribute__((__const__)) ;
#line 144
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 290
extern struct servent *getservbyname(char const   *__name , char const   *__proto ) ;
#line 34 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) in_addr_t ( __attribute__((__leaf__)) inet_addr)(char const   *__cp ) ;
#line 53
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) inet_ntoa)(struct in_addr __in ) ;
#line 173 "/usr/include/getopt.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 181 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 190
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 336
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setvbuf)(FILE * __restrict  __stream ,
                                                                              char * __restrict  __buf ,
                                                                              int __modes ,
                                                                              size_t __n ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 348
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 205
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 239
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) gmtime)(time_t const   *__timer ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 60 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
int closesocket(int s ) ;
#line 62 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
int closesocket(int s ) 
{ 
  int tmp ;

  {
  {
#line 63
  tmp = close(s);
  }
#line 63
  return (tmp);
}
}
#line 4 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/match.h"
int match(char const   *sorig , char *p ) ;
#line 116 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
int *seFds  =    (int *)0;
#line 118 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
struct in_addr *seLocalAddrs  =    (struct in_addr *)0;
#line 119 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
unsigned short *seLocalPorts  =    (unsigned short *)0;
#line 121 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
char **seFromHosts  ;
#line 122 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
int *seFromPorts  ;
#line 123 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
char **seToHosts  ;
#line 124 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
int *seToPorts  ;
#line 129 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
int *seAllowRules  =    (int *)0;
#line 130 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
int *seAllowRulesTotal  =    (int *)0;
#line 131 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
int globalAllowRules  =    0;
#line 132 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
int *seDenyRules  =    (int *)0;
#line 133 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
int *seDenyRulesTotal  =    (int *)0;
#line 134 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
int globalDenyRules  =    0;
#line 136 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
int *reFds  =    (int *)0;
#line 137 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
int *loFds  =    (int *)0;
#line 138 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
struct in_addr *reAddresses  =    (struct in_addr *)((void *)0);
#line 139 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
int *coInputRPos  =    (int *)0;
#line 140 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
int *coInputWPos  =    (int *)0;
#line 141 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
int *coOutputRPos  =    (int *)0;
#line 142 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
int *coOutputWPos  =    (int *)0;
#line 143 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
int *coClosed  =    (int *)0;
#line 144 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
int *coClosing  =    (int *)0;
#line 145 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
int *reClosed  =    (int *)0;
#line 146 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
int *loClosed  =    (int *)0;
#line 147 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
int *coBytesInput  =    (int *)0;
#line 148 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
int *coBytesOutput  =    (int *)0;
#line 149 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
int *coLog  =    (int *)0;
#line 150 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
int *coSe  =    (int *)0;
#line 151 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
char **coInput  =    (char **)0;
#line 152 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
char **coOutput  =    (char **)0;
#line 153 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
char **allowRules  =    (char **)0;
#line 154 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
char **denyRules  =    (char **)0;
#line 155 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
int *denyRulesFor  =    (int *)0;
#line 156 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
int seTotal  =    0;
#line 157 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
int coTotal  =    0;
#line 158 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
int allowRulesTotal  =    0;
#line 159 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
int denyRulesTotal  =    0;
#line 160 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
int maxfd  =    0;
#line 161 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
char *logFileName  =    (char *)0;
#line 162 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
char *pidLogFileName  =    (char *)0;
#line 163 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
int logFormatCommon  =    0;
#line 164 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
FILE *logFile  =    (FILE *)0;
#line 173
int safeRealloc(void **data , int oldsize , int newsize ) ;
#line 184
void readConfiguration(void) ;
#line 187
void plumber(int s ) ;
#line 188
void hup(int s ) ;
#line 189
void term(int s ) ;
#line 191
void initArrays(void) ;
#line 192
void RegisterPID(void) ;
#line 194
void selectLoop(void) ;
#line 196
void log(int i , int coSe___0 , int result ) ;
#line 198
int getAddress(char *host , struct in_addr *iaddr ) ;
#line 200 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
char const   *logMessages[14]  = 
#line 200
  {      "done-local-closed",      "done-remote-closed",      "accept-failed -",      (char const   *)0, 
        "local-socket-failed -",      (char const   *)0,      "local-bind-failed -",      (char const   *)0, 
        "local-connect-failed -",      (char const   *)0,      "not-allowed",      (char const   *)0, 
        "denied",      (char const   *)0};
#line 237 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
RinetdOptions options  =    {"/etc/rinetd.conf", 0};
#line 242
int readArgs(int argc , char **argv , RinetdOptions *options___0 ) ;
#line 246 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
int main(int argc , char **argv ) 
{ 
  int result ;
  __pid_t tmp ;

  {
  {
#line 253
  openlog("rinetd", 1, 3 << 3);
#line 255
  result = 0;
  }
#line 256
  if (result != 0) {
    {
#line 257
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Your computer was not connected to the Internet at the time that this program was launched, or you do not have a 32-bit connection to the Internet.");
#line 262
    exit(1);
    }
  }
  {
#line 264
  readArgs(argc, argv, & options);
  }
#line 271
  if (options.foreground) {
#line 271
    goto _L;
  } else {
    {
#line 271
    tmp = fork();
    }
#line 271
    if (tmp) {
      {
#line 297
      exit(0);
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 282
      signal(13, & plumber);
#line 283
      signal(1, & hup);
#line 286
      signal(15, & term);
#line 287
      initArrays();
#line 288
      readConfiguration();
#line 289
      RegisterPID();
#line 290
      syslog(6, "Starting redirections...");
#line 291
      selectLoop();
      }
    }
  }
#line 301
  return (0);
}
}
#line 304
int getConfLine(FILE *in , char *line , int space , int *lnum ) ;
#line 306
int patternBad(char *pattern ) ;
#line 308 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
void readConfiguration(void) 
{ 
  FILE *in ;
  char line[16384] ;
  int lnum ;
  int i ;
  int ai ;
  int di ;
  char *t ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  char *bindAddress ;
  unsigned short bindPort ;
  char *connectAddress ;
  char *bindPortS ;
  char *connectPortS ;
  unsigned short connectPort ;
  struct in_addr iaddr ;
  struct sockaddr_in saddr ;
  struct servent *service ;
  int j ;
  int tmp___18 ;
  char *pattern ;
  char *tmp___19 ;
  int tmp___20 ;
  size_t tmp___21 ;
  void *tmp___22 ;
  char *pattern___0 ;
  char *tmp___23 ;
  size_t tmp___24 ;
  void *tmp___25 ;
  char *nt ;
  char *tmp___26 ;
  size_t tmp___27 ;
  void *tmp___28 ;
  char *nt___0 ;
  char *tmp___29 ;
  size_t tmp___30 ;
  void *tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  size_t tmp___38 ;
  void *tmp___39 ;
  size_t tmp___40 ;
  void *tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;

  {
#line 312
  lnum = 0;
#line 316
  if (seFds) {
#line 318
    i = 0;
    {
#line 318
    while (1) {
      while_continue: /* CIL Label */ ;
#line 318
      if (! (i < seTotal)) {
#line 318
        goto while_break;
      }
#line 319
      if (*(seFds + i) != -1) {
        {
#line 320
        closesocket(*(seFds + i));
#line 321
        free((void *)*(seFromHosts + i));
#line 322
        free((void *)*(seToHosts + i));
        }
      }
#line 318
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 326
    free((void *)seFds);
#line 327
    free((void *)seLocalAddrs);
#line 328
    free((void *)seLocalPorts);
#line 329
    free((void *)seFromHosts);
#line 330
    free((void *)seFromPorts);
#line 331
    free((void *)seToHosts);
#line 332
    free((void *)seToPorts);
#line 333
    free((void *)seAllowRules);
#line 334
    free((void *)seDenyRules);
#line 335
    free((void *)seAllowRulesTotal);
#line 336
    free((void *)seDenyRulesTotal);
    }
  }
#line 338
  seTotal = 0;
#line 339
  if (allowRules) {
#line 341
    i = 0;
    {
#line 341
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 341
      if (! (i < allowRulesTotal)) {
#line 341
        goto while_break___0;
      }
      {
#line 342
      free((void *)*(allowRules + i));
#line 341
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 345
    free((void *)allowRules);
#line 346
    globalAllowRules = 0;
    }
  }
#line 348
  allowRulesTotal = 0;
#line 349
  if (denyRules) {
#line 351
    i = 0;
    {
#line 351
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 351
      if (! (i < denyRulesTotal)) {
#line 351
        goto while_break___1;
      }
      {
#line 352
      free((void *)*(denyRules + i));
#line 351
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 355
    free((void *)denyRules);
#line 356
    globalDenyRules = 0;
    }
  }
#line 358
  denyRulesTotal = 0;
#line 359
  if (logFileName) {
    {
#line 360
    free((void *)logFileName);
#line 361
    logFileName = (char *)0;
    }
  }
#line 363
  if (pidLogFileName) {
    {
#line 364
    free((void *)pidLogFileName);
#line 365
    pidLogFileName = (char *)0;
    }
  }
  {
#line 369
  in = fopen((char const   */* __restrict  */)options.conf_file, (char const   */* __restrict  */)"r");
  }
#line 370
  if (! in) {
    {
#line 371
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"rinetd: can\'t open %s\n",
            options.conf_file);
#line 372
    exit(1);
    }
  }
  {
#line 374
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 375
    t = (char *)0;
#line 376
    tmp = getConfLine(in, line, (int )sizeof(line), & lnum);
    }
#line 376
    if (! tmp) {
#line 377
      goto while_break___2;
    }
    {
#line 379
    t = strtok((char */* __restrict  */)(line), (char const   */* __restrict  */)" \t\r\n");
#line 380
    tmp___4 = strcmp((char const   *)t, "logfile");
    }
#line 380
    if (tmp___4) {
      {
#line 382
      tmp___3 = strcmp((char const   *)t, "pidlogfile");
      }
#line 382
      if (tmp___3) {
        {
#line 384
        tmp___2 = strcmp((char const   *)t, "logcommon");
        }
#line 384
        if (tmp___2) {
          {
#line 386
          tmp___1 = strcmp((char const   *)t, "allow");
          }
#line 386
          if (tmp___1) {
            {
#line 388
            tmp___0 = strcmp((char const   *)t, "deny");
            }
#line 388
            if (tmp___0) {
#line 392
              seTotal ++;
            } else {
#line 389
              denyRulesTotal ++;
            }
          } else {
#line 387
            allowRulesTotal ++;
          }
        } else {
#line 385
          goto while_continue___2;
        }
      } else {
#line 383
        goto while_continue___2;
      }
    } else {
#line 381
      goto while_continue___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 395
  fclose(in);
#line 396
  tmp___5 = malloc(sizeof(int ) * (unsigned long )seTotal);
#line 396
  seFds = (int *)tmp___5;
  }
#line 397
  if (! seFds) {
#line 398
    goto lowMemory;
  }
  {
#line 400
  tmp___6 = malloc(sizeof(struct in_addr ) * (unsigned long )seTotal);
#line 400
  seLocalAddrs = (struct in_addr *)tmp___6;
  }
#line 402
  if (! seLocalAddrs) {
#line 403
    goto lowMemory;
  }
  {
#line 405
  tmp___7 = malloc(sizeof(unsigned short ) * (unsigned long )seTotal);
#line 405
  seLocalPorts = (unsigned short *)tmp___7;
  }
#line 407
  if (! seLocalPorts) {
#line 408
    goto lowMemory;
  }
  {
#line 410
  tmp___8 = malloc(sizeof(char *) * (unsigned long )seTotal);
#line 410
  seFromHosts = (char **)tmp___8;
  }
#line 412
  if (! seFromHosts) {
#line 413
    goto lowMemory;
  }
  {
#line 415
  tmp___9 = malloc(sizeof(int ) * (unsigned long )seTotal);
#line 415
  seFromPorts = (int *)tmp___9;
  }
#line 417
  if (! seFromPorts) {
#line 418
    goto lowMemory;
  }
  {
#line 420
  tmp___10 = malloc(sizeof(char *) * (unsigned long )seTotal);
#line 420
  seToHosts = (char **)tmp___10;
  }
#line 422
  if (! seToHosts) {
#line 423
    goto lowMemory;
  }
  {
#line 425
  tmp___11 = malloc(sizeof(int ) * (unsigned long )seTotal);
#line 425
  seToPorts = (int *)tmp___11;
  }
#line 427
  if (! seToPorts) {
#line 428
    goto lowMemory;
  }
  {
#line 430
  tmp___12 = malloc(sizeof(char *) * (unsigned long )allowRulesTotal);
#line 430
  allowRules = (char **)tmp___12;
  }
#line 432
  if (! allowRules) {
#line 433
    goto lowMemory;
  }
  {
#line 435
  tmp___13 = malloc(sizeof(char *) * (unsigned long )denyRulesTotal);
#line 435
  denyRules = (char **)tmp___13;
  }
#line 437
  if (! denyRules) {
#line 438
    goto lowMemory;
  }
  {
#line 440
  tmp___14 = malloc(sizeof(int ) * (unsigned long )seTotal);
#line 440
  seAllowRules = (int *)tmp___14;
  }
#line 442
  if (! seAllowRules) {
#line 443
    goto lowMemory;
  }
  {
#line 445
  tmp___15 = malloc(sizeof(int ) * (unsigned long )seTotal);
#line 445
  seAllowRulesTotal = (int *)tmp___15;
  }
#line 447
  if (! seAllowRulesTotal) {
#line 448
    goto lowMemory;
  }
  {
#line 450
  tmp___16 = malloc(sizeof(int ) * (unsigned long )seTotal);
#line 450
  seDenyRules = (int *)tmp___16;
  }
#line 452
  if (! seDenyRules) {
#line 453
    goto lowMemory;
  }
  {
#line 455
  tmp___17 = malloc(sizeof(int ) * (unsigned long )seTotal);
#line 455
  seDenyRulesTotal = (int *)tmp___17;
  }
#line 457
  if (! seDenyRulesTotal) {
#line 458
    goto lowMemory;
  }
  {
#line 461
  i = 0;
#line 462
  ai = 0;
#line 463
  di = 0;
#line 464
  lnum = 0;
#line 465
  in = fopen((char const   */* __restrict  */)options.conf_file, (char const   */* __restrict  */)"r");
  }
#line 466
  if (! in) {
#line 467
    goto lowMemory;
  }
#line 469
  if (seTotal > 0) {
#line 470
    *(seAllowRulesTotal + i) = 0;
#line 471
    *(seDenyRulesTotal + i) = 0;
  }
  {
#line 473
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 484
    tmp___18 = getConfLine(in, line, (int )sizeof(line), & lnum);
    }
#line 484
    if (! tmp___18) {
#line 485
      goto while_break___3;
    }
    {
#line 487
    bindAddress = strtok((char */* __restrict  */)(line), (char const   */* __restrict  */)" \t\r\n");
    }
#line 488
    if (! bindAddress) {
      {
#line 489
      syslog(3, "no bind address specified on file %s, line %d.\n", options.conf_file,
             lnum);
      }
#line 491
      goto while_continue___3;
    }
    {
#line 493
    tmp___46 = strcmp((char const   *)bindAddress, "allow");
    }
#line 493
    if (tmp___46) {
      {
#line 524
      tmp___45 = strcmp((char const   *)bindAddress, "deny");
      }
#line 524
      if (tmp___45) {
        {
#line 545
        tmp___44 = strcmp((char const   *)bindAddress, "logfile");
        }
#line 545
        if (tmp___44) {
          {
#line 557
          tmp___43 = strcmp((char const   *)bindAddress, "pidlogfile");
          }
#line 557
          if (tmp___43) {
            {
#line 569
            tmp___42 = strcmp((char const   *)bindAddress, "logcommon");
            }
#line 569
            if (tmp___42) {
              {
#line 573
              bindPortS = strtok((char */* __restrict  */)0, (char const   */* __restrict  */)" \t\r\n");
              }
#line 574
              if (! bindPortS) {
                {
#line 575
                syslog(3, "no bind port specified on file %s, line %d.\n", options.conf_file,
                       lnum);
                }
#line 577
                goto while_continue___3;
              }
              {
#line 579
              service = getservbyname((char const   *)bindPortS, "tcp");
              }
#line 580
              if (service) {
                {
#line 581
                bindPort = ntohs((uint16_t )service->s_port);
                }
              } else {
                {
#line 583
                tmp___32 = atoi((char const   *)bindPortS);
#line 583
                bindPort = (unsigned short )tmp___32;
                }
              }
#line 585
              if ((int )bindPort == 0) {
                {
#line 586
                syslog(3, "bind port missing or out of range on file %s, line %d.\n",
                       options.conf_file, lnum);
                }
#line 588
                goto while_continue___3;
              } else
#line 585
              if ((int )bindPort >= 65536) {
                {
#line 586
                syslog(3, "bind port missing or out of range on file %s, line %d.\n",
                       options.conf_file, lnum);
                }
#line 588
                goto while_continue___3;
              }
              {
#line 590
              connectAddress = strtok((char */* __restrict  */)0, (char const   */* __restrict  */)" \t\r\n");
              }
#line 591
              if (! connectAddress) {
                {
#line 592
                syslog(3, "no connect address specified on file %s, line %d.\n", options.conf_file,
                       lnum);
                }
#line 594
                goto while_continue___3;
              }
              {
#line 596
              connectPortS = strtok((char */* __restrict  */)0, (char const   */* __restrict  */)" \t\r\n");
              }
#line 597
              if (! connectPortS) {
                {
#line 598
                syslog(3, "no connect port specified on file %s, line %d.\n", options.conf_file,
                       lnum);
                }
#line 600
                goto while_continue___3;
              }
              {
#line 602
              service = getservbyname((char const   *)connectPortS, "tcp");
              }
#line 603
              if (service) {
                {
#line 604
                connectPort = ntohs((uint16_t )service->s_port);
                }
              } else {
                {
#line 606
                tmp___33 = atoi((char const   *)connectPortS);
#line 606
                connectPort = (unsigned short )tmp___33;
                }
              }
#line 608
              if ((int )connectPort == 0) {
                {
#line 609
                syslog(3, "bind port missing or out of range on file %s,  %d.\n",
                       options.conf_file, lnum);
                }
#line 611
                goto while_continue___3;
              } else
#line 608
              if ((int )connectPort >= 65536) {
                {
#line 609
                syslog(3, "bind port missing or out of range on file %s,  %d.\n",
                       options.conf_file, lnum);
                }
#line 611
                goto while_continue___3;
              }
              {
#line 614
              tmp___34 = getAddress(bindAddress, & iaddr);
              }
#line 614
              if (! tmp___34) {
                {
#line 615
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"rinetd: host %s could not be resolved on line %d.\n",
                        bindAddress, lnum);
                }
#line 618
                goto while_continue___3;
              }
              {
#line 621
              *(seFds + i) = socket(2, 1, 0);
              }
#line 622
              if (*(seFds + i) == -1) {
                {
#line 623
                syslog(3, "couldn\'t create server socket! (%m)\n");
#line 625
                *(seFds + i) = -1;
                }
#line 626
                goto while_continue___3;
              }
#line 629
              if (*(seFds + i) > maxfd) {
#line 630
                maxfd = *(seFds + i);
              }
              {
#line 633
              saddr.sin_family = (sa_family_t )2;
#line 634
              memcpy((void */* __restrict  */)(& saddr.sin_addr), (void const   */* __restrict  */)(& iaddr),
                     sizeof(iaddr));
#line 635
              saddr.sin_port = htons(bindPort);
#line 636
              j = 1;
#line 637
              setsockopt(*(seFds + i), 1, 2, (void const   *)((char const   *)(& j)),
                         (socklen_t )sizeof(j));
#line 639
              tmp___35 = bind(*(seFds + i), (struct sockaddr  const  *)((struct sockaddr *)(& saddr)),
                              (socklen_t )sizeof(saddr));
              }
#line 639
              if (tmp___35 == -1) {
                {
#line 643
                syslog(3, "couldn\'t bind to address %s port %d (%m)\n", bindAddress,
                       (int )bindPort);
#line 646
                closesocket(*(seFds + i));
#line 647
                *(seFds + i) = -1;
                }
#line 648
                goto while_continue___3;
              }
              {
#line 650
              tmp___36 = listen(*(seFds + i), 5);
              }
#line 650
              if (tmp___36 == -1) {
                {
#line 652
                syslog(3, "couldn\'t listen to address %s port %d (%m)\n", bindAddress,
                       (int )bindPort);
#line 655
                closesocket(*(seFds + i));
#line 656
                *(seFds + i) = -1;
                }
#line 657
                goto while_continue___3;
              }
              {
#line 659
              ioctl(*(seFds + i), 21537UL, & j);
#line 660
              tmp___37 = getAddress(connectAddress, & iaddr);
              }
#line 660
              if (! tmp___37) {
                {
#line 662
                syslog(3, "host %s could not be resolved on file %s, line %d.\n",
                       bindAddress, options.conf_file, lnum);
#line 665
                closesocket(*(seFds + i));
#line 666
                *(seFds + i) = -1;
                }
#line 667
                goto while_continue___3;
              }
              {
#line 669
              *(seLocalAddrs + i) = iaddr;
#line 670
              *(seLocalPorts + i) = htons(connectPort);
#line 671
              tmp___38 = strlen((char const   *)bindAddress);
#line 671
              tmp___39 = malloc(tmp___38 + 1UL);
#line 671
              *(seFromHosts + i) = (char *)tmp___39;
              }
#line 672
              if (! *(seFromHosts + i)) {
#line 673
                goto lowMemory;
              }
              {
#line 675
              strcpy((char */* __restrict  */)*(seFromHosts + i), (char const   */* __restrict  */)bindAddress);
#line 676
              *(seFromPorts + i) = (int )bindPort;
#line 677
              tmp___40 = strlen((char const   *)connectAddress);
#line 677
              tmp___41 = malloc(tmp___40 + 1UL);
#line 677
              *(seToHosts + i) = (char *)tmp___41;
              }
#line 678
              if (! *(seToHosts + i)) {
#line 679
                goto lowMemory;
              }
              {
#line 681
              strcpy((char */* __restrict  */)*(seToHosts + i), (char const   */* __restrict  */)connectAddress);
#line 682
              *(seToPorts + i) = (int )connectPort;
#line 683
              i ++;
              }
#line 684
              if (i < seTotal) {
#line 685
                *(seAllowRulesTotal + i) = 0;
#line 686
                *(seDenyRulesTotal + i) = 0;
              }
            } else {
#line 570
              logFormatCommon = 1;
            }
          } else {
            {
#line 558
            tmp___29 = strtok((char */* __restrict  */)0, (char const   */* __restrict  */)" \t\r\n");
#line 558
            nt___0 = tmp___29;
            }
#line 559
            if (! nt___0) {
              {
#line 560
              syslog(3, "no PID log file name specified on file %s, line %d.\n", options.conf_file,
                     lnum);
              }
#line 562
              goto while_continue___3;
            }
            {
#line 564
            tmp___30 = strlen((char const   *)nt___0);
#line 564
            tmp___31 = malloc(tmp___30 + 1UL);
#line 564
            pidLogFileName = (char *)tmp___31;
            }
#line 565
            if (! pidLogFileName) {
#line 566
              goto lowMemory;
            }
            {
#line 568
            strcpy((char */* __restrict  */)pidLogFileName, (char const   */* __restrict  */)nt___0);
            }
          }
        } else {
          {
#line 546
          tmp___26 = strtok((char */* __restrict  */)0, (char const   */* __restrict  */)" \t\r\n");
#line 546
          nt = tmp___26;
          }
#line 547
          if (! nt) {
            {
#line 548
            syslog(3, "no log file name specified on file %s, line %d.\n", options.conf_file,
                   lnum);
            }
#line 550
            goto while_continue___3;
          }
          {
#line 552
          tmp___27 = strlen((char const   *)nt);
#line 552
          tmp___28 = malloc(tmp___27 + 1UL);
#line 552
          logFileName = (char *)tmp___28;
          }
#line 553
          if (! logFileName) {
#line 554
            goto lowMemory;
          }
          {
#line 556
          strcpy((char */* __restrict  */)logFileName, (char const   */* __restrict  */)nt);
          }
        }
      } else {
        {
#line 525
        tmp___23 = strtok((char */* __restrict  */)0, (char const   */* __restrict  */)" \t\r\n");
#line 525
        pattern___0 = tmp___23;
        }
#line 526
        if (! pattern___0) {
          {
#line 527
          syslog(3, "nothing to deny specified on file %s, line %d.\n", options.conf_file,
                 lnum);
          }
#line 529
          goto while_continue___3;
        }
        {
#line 531
        tmp___24 = strlen((char const   *)pattern___0);
#line 531
        tmp___25 = malloc(tmp___24 + 1UL);
#line 531
        *(denyRules + di) = (char *)tmp___25;
        }
#line 532
        if (! *(denyRules + di)) {
#line 533
          goto lowMemory;
        }
        {
#line 535
        strcpy((char */* __restrict  */)*(denyRules + di), (char const   */* __restrict  */)pattern___0);
        }
#line 536
        if (i > 0) {
#line 537
          if (*(seDenyRulesTotal + (i - 1)) == 0) {
#line 538
            *(seDenyRules + (i - 1)) = di;
          }
#line 540
          (*(seDenyRulesTotal + (i - 1))) ++;
        } else {
#line 542
          globalDenyRules ++;
        }
#line 544
        di ++;
      }
    } else {
      {
#line 494
      tmp___19 = strtok((char */* __restrict  */)0, (char const   */* __restrict  */)" \t\r\n");
#line 494
      pattern = tmp___19;
      }
#line 495
      if (! pattern) {
        {
#line 496
        syslog(3, "nothing to allow specified on file %s, line %d.\n", options.conf_file,
               lnum);
        }
#line 498
        goto while_continue___3;
      }
      {
#line 500
      tmp___20 = patternBad(pattern);
      }
#line 500
      if (tmp___20) {
        {
#line 501
        syslog(3, "illegal allow or deny pattern. Only digits, ., and\nthe ? and * wild cards are allowed. For performance reasons, rinetd\ndoes not look up complete host names.\n");
        }
#line 507
        goto while_continue___3;
      }
      {
#line 510
      tmp___21 = strlen((char const   *)pattern);
#line 510
      tmp___22 = malloc(tmp___21 + 1UL);
#line 510
      *(allowRules + ai) = (char *)tmp___22;
      }
#line 511
      if (! *(allowRules + ai)) {
#line 512
        goto lowMemory;
      }
      {
#line 514
      strcpy((char */* __restrict  */)*(allowRules + ai), (char const   */* __restrict  */)pattern);
      }
#line 515
      if (i > 0) {
#line 516
        if (*(seAllowRulesTotal + (i - 1)) == 0) {
#line 517
          *(seAllowRules + (i - 1)) = ai;
        }
#line 519
        (*(seAllowRulesTotal + (i - 1))) ++;
      } else {
#line 521
        globalAllowRules ++;
      }
#line 523
      ai ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 690
  fclose(in);
  }
#line 692
  if (logFile) {
    {
#line 693
    fclose(logFile);
#line 694
    logFile = (FILE *)0;
    }
  }
#line 696
  if (logFileName) {
    {
#line 697
    logFile = fopen((char const   */* __restrict  */)logFileName, (char const   */* __restrict  */)"a");
    }
#line 698
    if (logFile) {
      {
#line 699
      setvbuf((FILE */* __restrict  */)logFile, (char */* __restrict  */)((void *)0),
              2, (size_t )0);
      }
    } else {
      {
#line 701
      syslog(3, "could not open %s to append (%m).\n", logFileName);
      }
    }
  }
#line 705
  return;
  lowMemory: 
  {
#line 707
  syslog(3, "not enough memory to start rinetd.\n");
#line 708
  exit(1);
  }
}
}
#line 711 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
int getConfLine(FILE *in , char *line , int space , int *lnum ) 
{ 
  char *p ;
  char *tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 714
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 715
    (*lnum) ++;
#line 716
    tmp = fgets((char */* __restrict  */)line, space, (FILE */* __restrict  */)in);
    }
#line 716
    if (! tmp) {
#line 717
      return (0);
    }
#line 719
    p = line;
    {
#line 720
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 720
      tmp___0 = __ctype_b_loc();
      }
#line 720
      if (! ((int const   )*(*tmp___0 + (int )*p) & 8192)) {
#line 720
        goto while_break___0;
      }
#line 721
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 723
    if (! *p) {
#line 725
      goto while_continue;
    }
#line 727
    if ((int )*p == 35) {
#line 729
      goto while_continue;
    }
#line 731
    return (1);
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 735 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
void initArrays(void) 
{ 
  int j ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;

  {
  {
#line 738
  coTotal = 64;
#line 739
  tmp = malloc(sizeof(int ) * (unsigned long )coTotal);
#line 739
  reFds = (int *)tmp;
#line 740
  tmp___0 = malloc(sizeof(int ) * (unsigned long )coTotal);
#line 740
  loFds = (int *)tmp___0;
#line 741
  tmp___1 = malloc(sizeof(int ) * (unsigned long )coTotal);
#line 741
  coInputRPos = (int *)tmp___1;
#line 742
  tmp___2 = malloc(sizeof(int ) * (unsigned long )coTotal);
#line 742
  coInputWPos = (int *)tmp___2;
#line 743
  tmp___3 = malloc(sizeof(int ) * (unsigned long )coTotal);
#line 743
  coOutputRPos = (int *)tmp___3;
#line 744
  tmp___4 = malloc(sizeof(int ) * (unsigned long )coTotal);
#line 744
  coOutputWPos = (int *)tmp___4;
#line 745
  tmp___5 = malloc(sizeof(int ) * (unsigned long )coTotal);
#line 745
  coClosed = (int *)tmp___5;
#line 746
  tmp___6 = malloc(sizeof(int ) * (unsigned long )coTotal);
#line 746
  coClosing = (int *)tmp___6;
#line 747
  tmp___7 = malloc(sizeof(int ) * (unsigned long )coTotal);
#line 747
  reClosed = (int *)tmp___7;
#line 748
  tmp___8 = malloc(sizeof(int ) * (unsigned long )coTotal);
#line 748
  loClosed = (int *)tmp___8;
#line 749
  tmp___9 = malloc(sizeof(char *) * (unsigned long )coTotal);
#line 749
  coInput = (char **)tmp___9;
#line 750
  tmp___10 = malloc(sizeof(char *) * (unsigned long )coTotal);
#line 750
  coOutput = (char **)tmp___10;
#line 751
  tmp___11 = malloc(sizeof(int ) * (unsigned long )coTotal);
#line 751
  coBytesInput = (int *)tmp___11;
#line 752
  tmp___12 = malloc(sizeof(int ) * (unsigned long )coTotal);
#line 752
  coBytesOutput = (int *)tmp___12;
#line 753
  tmp___13 = malloc(sizeof(struct in_addr ) * (unsigned long )coTotal);
#line 753
  reAddresses = (struct in_addr *)tmp___13;
#line 754
  tmp___14 = malloc(sizeof(int ) * (unsigned long )coTotal);
#line 754
  coLog = (int *)tmp___14;
#line 755
  tmp___15 = malloc(sizeof(int ) * (unsigned long )coTotal);
#line 755
  coSe = (int *)tmp___15;
  }
#line 756
  if (! reFds) {
    {
#line 764
    syslog(3, "not enough memory to start rinetd.\n");
#line 765
    exit(1);
    }
  } else
#line 756
  if (! loFds) {
    {
#line 764
    syslog(3, "not enough memory to start rinetd.\n");
#line 765
    exit(1);
    }
  } else
#line 756
  if (! coInputRPos) {
    {
#line 764
    syslog(3, "not enough memory to start rinetd.\n");
#line 765
    exit(1);
    }
  } else
#line 756
  if (! coInputWPos) {
    {
#line 764
    syslog(3, "not enough memory to start rinetd.\n");
#line 765
    exit(1);
    }
  } else
#line 756
  if (! coOutputRPos) {
    {
#line 764
    syslog(3, "not enough memory to start rinetd.\n");
#line 765
    exit(1);
    }
  } else
#line 756
  if (! coOutputWPos) {
    {
#line 764
    syslog(3, "not enough memory to start rinetd.\n");
#line 765
    exit(1);
    }
  } else
#line 756
  if (! coClosed) {
    {
#line 764
    syslog(3, "not enough memory to start rinetd.\n");
#line 765
    exit(1);
    }
  } else
#line 756
  if (! coClosing) {
    {
#line 764
    syslog(3, "not enough memory to start rinetd.\n");
#line 765
    exit(1);
    }
  } else
#line 756
  if (! reClosed) {
    {
#line 764
    syslog(3, "not enough memory to start rinetd.\n");
#line 765
    exit(1);
    }
  } else
#line 756
  if (! loClosed) {
    {
#line 764
    syslog(3, "not enough memory to start rinetd.\n");
#line 765
    exit(1);
    }
  } else
#line 756
  if (! coInput) {
    {
#line 764
    syslog(3, "not enough memory to start rinetd.\n");
#line 765
    exit(1);
    }
  } else
#line 756
  if (! coOutput) {
    {
#line 764
    syslog(3, "not enough memory to start rinetd.\n");
#line 765
    exit(1);
    }
  } else
#line 756
  if (! coBytesInput) {
    {
#line 764
    syslog(3, "not enough memory to start rinetd.\n");
#line 765
    exit(1);
    }
  } else
#line 756
  if (! coBytesOutput) {
    {
#line 764
    syslog(3, "not enough memory to start rinetd.\n");
#line 765
    exit(1);
    }
  } else
#line 756
  if (! coLog) {
    {
#line 764
    syslog(3, "not enough memory to start rinetd.\n");
#line 765
    exit(1);
    }
  } else
#line 756
  if (! coSe) {
    {
#line 764
    syslog(3, "not enough memory to start rinetd.\n");
#line 765
    exit(1);
    }
  } else
#line 756
  if (! reAddresses) {
    {
#line 764
    syslog(3, "not enough memory to start rinetd.\n");
#line 765
    exit(1);
    }
  }
#line 767
  j = 0;
  {
#line 767
  while (1) {
    while_continue: /* CIL Label */ ;
#line 767
    if (! (j < coTotal)) {
#line 767
      goto while_break;
    }
    {
#line 768
    *(coClosed + j) = 1;
#line 769
    tmp___16 = malloc(sizeof(char ) * 1024UL);
#line 769
    *(coInput + j) = (char *)tmp___16;
#line 770
    tmp___17 = malloc(sizeof(char ) * 1024UL);
#line 770
    *(coOutput + j) = (char *)tmp___17;
    }
#line 771
    if (! *(coInput + j)) {
      {
#line 772
      syslog(3, "not enough memory to start rinetd.\n");
#line 774
      exit(1);
      }
    } else
#line 771
    if (! *(coOutput + j)) {
      {
#line 772
      syslog(3, "not enough memory to start rinetd.\n");
#line 774
      exit(1);
      }
    }
#line 767
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 777
  return;
}
}
#line 779
void selectPass(void) ;
#line 781 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
void selectLoop(void) 
{ 


  {
  {
#line 782
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 783
    selectPass();
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 787
void handleRemoteWrite(int i ) ;
#line 788
void handleRemoteRead(int i ) ;
#line 789
void handleLocalWrite(int i ) ;
#line 790
void handleLocalRead(int i ) ;
#line 791
void handleCloseFromLocal(int i ) ;
#line 792
void handleCloseFromRemote(int i ) ;
#line 793
void handleAccept(int i ) ;
#line 794
void openLocalFd(int se , int i ) ;
#line 797 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
void selectPass(void) 
{ 
  int i ;
  fd_set readfds ;
  fd_set writefds ;
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;

  {
  {
#line 800
  while (1) {
    while_continue: /* CIL Label */ ;
#line 800
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& readfds.__fds_bits[0]): "memory");
#line 800
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 801
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 801
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& writefds.__fds_bits[0]): "memory");
#line 801
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 803
  i = 0;
  {
#line 803
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 803
    if (! (i < seTotal)) {
#line 803
      goto while_break___1;
    }
#line 804
    if (*(seFds + i) != -1) {
#line 805
      readfds.__fds_bits[*(seFds + i) / (8 * (int )sizeof(__fd_mask ))] |= 1L << *(seFds + i) % (8 * (int )sizeof(__fd_mask ));
    }
#line 803
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 809
  i = 0;
  {
#line 809
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 809
    if (! (i < coTotal)) {
#line 809
      goto while_break___2;
    }
#line 810
    if (*(coClosed + i)) {
#line 811
      goto __Cont;
    }
#line 813
    if (*(coClosing + i)) {
#line 814
      if (! *(reClosed + i)) {
#line 815
        writefds.__fds_bits[*(reFds + i) / (8 * (int )sizeof(__fd_mask ))] |= 1L << *(reFds + i) % (8 * (int )sizeof(__fd_mask ));
      }
#line 817
      if (! *(loClosed + i)) {
#line 818
        writefds.__fds_bits[*(loFds + i) / (8 * (int )sizeof(__fd_mask ))] |= 1L << *(loFds + i) % (8 * (int )sizeof(__fd_mask ));
      }
    }
#line 822
    if (! *(reClosed + i)) {
#line 822
      if (*(coInputRPos + i) < 1024) {
#line 823
        readfds.__fds_bits[*(reFds + i) / (8 * (int )sizeof(__fd_mask ))] |= 1L << *(reFds + i) % (8 * (int )sizeof(__fd_mask ));
      }
    }
#line 826
    if (! *(reClosed + i)) {
#line 826
      if (*(coOutputWPos + i) < *(coOutputRPos + i)) {
#line 827
        writefds.__fds_bits[*(reFds + i) / (8 * (int )sizeof(__fd_mask ))] |= 1L << *(reFds + i) % (8 * (int )sizeof(__fd_mask ));
      }
    }
#line 831
    if (! *(loClosed + i)) {
#line 831
      if (*(coOutputRPos + i) < 1024) {
#line 832
        readfds.__fds_bits[*(loFds + i) / (8 * (int )sizeof(__fd_mask ))] |= 1L << *(loFds + i) % (8 * (int )sizeof(__fd_mask ));
      }
    }
#line 836
    if (! *(loClosed + i)) {
#line 836
      if (*(coInputWPos + i) < *(coInputRPos + i)) {
#line 837
        writefds.__fds_bits[*(loFds + i) / (8 * (int )sizeof(__fd_mask ))] |= 1L << *(loFds + i) % (8 * (int )sizeof(__fd_mask ));
      }
    }
    __Cont: /* CIL Label */ 
#line 809
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 840
  select(maxfd + 1, (fd_set */* __restrict  */)(& readfds), (fd_set */* __restrict  */)(& writefds),
         (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)0);
#line 841
  i = 0;
  }
  {
#line 841
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 841
    if (! (i < seTotal)) {
#line 841
      goto while_break___3;
    }
#line 842
    if (*(seFds + i) != -1) {
#line 843
      if ((readfds.__fds_bits[*(seFds + i) / (8 * (int )sizeof(__fd_mask ))] & (1L << *(seFds + i) % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 844
        handleAccept(i);
        }
      }
    }
#line 841
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 848
  i = 0;
  {
#line 848
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 848
    if (! (i < coTotal)) {
#line 848
      goto while_break___4;
    }
#line 849
    if (*(coClosed + i)) {
#line 850
      goto __Cont___0;
    }
#line 852
    if (! *(reClosed + i)) {
#line 853
      if ((readfds.__fds_bits[*(reFds + i) / (8 * (int )sizeof(__fd_mask ))] & (1L << *(reFds + i) % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 854
        handleRemoteRead(i);
        }
      }
    }
#line 857
    if (! *(reClosed + i)) {
#line 858
      if ((writefds.__fds_bits[*(reFds + i) / (8 * (int )sizeof(__fd_mask ))] & (1L << *(reFds + i) % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 859
        handleRemoteWrite(i);
        }
      }
    }
#line 862
    if (! *(loClosed + i)) {
#line 863
      if ((readfds.__fds_bits[*(loFds + i) / (8 * (int )sizeof(__fd_mask ))] & (1L << *(loFds + i) % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 864
        handleLocalRead(i);
        }
      }
    }
#line 867
    if (! *(loClosed + i)) {
#line 868
      if ((writefds.__fds_bits[*(loFds + i) / (8 * (int )sizeof(__fd_mask ))] & (1L << *(loFds + i) % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 869
        handleLocalWrite(i);
        }
      }
    }
#line 872
    if (*(loClosed + i)) {
#line 872
      if (*(reClosed + i)) {
#line 873
        *(coClosed + i) = 1;
      }
    }
    __Cont___0: /* CIL Label */ 
#line 848
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 876
  return;
}
}
#line 878 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
void handleRemoteRead(int i ) 
{ 
  int got ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 881
  if (1024 == *(coInputRPos + i)) {
#line 882
    return;
  }
  {
#line 884
  tmp = recv(*(reFds + i), (void *)(*(coInput + i) + *(coInputRPos + i)), (size_t )(1024 - *(coInputRPos + i)),
             0);
#line 884
  got = (int )tmp;
  }
#line 886
  if (got == 0) {
    {
#line 888
    handleCloseFromRemote(i);
    }
#line 889
    return;
  }
#line 891
  if (got < 0) {
    {
#line 892
    tmp___0 = __errno_location();
    }
#line 892
    if (*tmp___0 == 11) {
#line 893
      return;
    }
    {
#line 895
    tmp___1 = __errno_location();
    }
#line 895
    if (*tmp___1 == 115) {
#line 896
      return;
    }
    {
#line 898
    handleCloseFromRemote(i);
    }
#line 899
    return;
  }
#line 901
  *(coBytesInput + i) += got;
#line 902
  *(coInputRPos + i) += got;
#line 903
  return;
}
}
#line 905 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
void handleRemoteWrite(int i ) 
{ 
  int got ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 908
  if (*(coClosing + i)) {
#line 908
    if (*(coOutputWPos + i) == *(coOutputRPos + i)) {
      {
#line 909
      *(reClosed + i) = 1;
#line 910
      *(coClosed + i) = 1;
#line 912
      log(i, *(coSe + i), *(coLog + i));
#line 913
      closesocket(*(reFds + i));
      }
#line 914
      return;
    }
  }
  {
#line 916
  tmp = send(*(reFds + i), (void const   *)(*(coOutput + i) + *(coOutputWPos + i)),
             (size_t )(*(coOutputRPos + i) - *(coOutputWPos + i)), 0);
#line 916
  got = (int )tmp;
  }
#line 918
  if (got < 0) {
    {
#line 919
    tmp___0 = __errno_location();
    }
#line 919
    if (*tmp___0 == 11) {
#line 920
      return;
    }
    {
#line 922
    tmp___1 = __errno_location();
    }
#line 922
    if (*tmp___1 == 115) {
#line 923
      return;
    }
    {
#line 925
    handleCloseFromRemote(i);
    }
#line 926
    return;
  }
#line 928
  *(coOutputWPos + i) += got;
#line 929
  if (*(coOutputWPos + i) == *(coOutputRPos + i)) {
#line 930
    *(coOutputWPos + i) = 0;
#line 931
    *(coOutputRPos + i) = 0;
  }
#line 933
  *(coBytesOutput + i) += got;
#line 934
  return;
}
}
#line 936 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
void handleLocalRead(int i ) 
{ 
  int got ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 939
  if (1024 == *(coOutputRPos + i)) {
#line 940
    return;
  }
  {
#line 942
  tmp = recv(*(loFds + i), (void *)(*(coOutput + i) + *(coOutputRPos + i)), (size_t )(1024 - *(coOutputRPos + i)),
             0);
#line 942
  got = (int )tmp;
  }
#line 944
  if (got == 0) {
    {
#line 945
    handleCloseFromLocal(i);
    }
#line 946
    return;
  }
#line 948
  if (got < 0) {
    {
#line 949
    tmp___0 = __errno_location();
    }
#line 949
    if (*tmp___0 == 11) {
#line 950
      return;
    }
    {
#line 952
    tmp___1 = __errno_location();
    }
#line 952
    if (*tmp___1 == 115) {
#line 953
      return;
    }
    {
#line 955
    handleCloseFromLocal(i);
    }
#line 956
    return;
  }
#line 958
  *(coOutputRPos + i) += got;
#line 959
  return;
}
}
#line 961 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
void handleLocalWrite(int i ) 
{ 
  int got ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 964
  if (*(coClosing + i)) {
#line 964
    if (*(coInputWPos + i) == *(coInputRPos + i)) {
      {
#line 965
      *(loClosed + i) = 1;
#line 966
      *(coClosed + i) = 1;
#line 968
      log(i, *(coSe + i), *(coLog + i));
#line 969
      closesocket(*(loFds + i));
      }
#line 970
      return;
    }
  }
  {
#line 972
  tmp = send(*(loFds + i), (void const   *)(*(coInput + i) + *(coInputWPos + i)),
             (size_t )(*(coInputRPos + i) - *(coInputWPos + i)), 0);
#line 972
  got = (int )tmp;
  }
#line 974
  if (got < 0) {
    {
#line 975
    tmp___0 = __errno_location();
    }
#line 975
    if (*tmp___0 == 11) {
#line 976
      return;
    }
    {
#line 978
    tmp___1 = __errno_location();
    }
#line 978
    if (*tmp___1 == 115) {
#line 979
      return;
    }
    {
#line 981
    handleCloseFromLocal(i);
    }
#line 982
    return;
  }
#line 984
  *(coInputWPos + i) += got;
#line 985
  if (*(coInputWPos + i) == *(coInputRPos + i)) {
#line 986
    *(coInputWPos + i) = 0;
#line 987
    *(coInputRPos + i) = 0;
  }
#line 989
  return;
}
}
#line 991 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
void handleCloseFromLocal(int i ) 
{ 


  {
  {
#line 993
  *(coClosing + i) = 1;
#line 997
  closesocket(*(loFds + i));
#line 998
  *(loClosed + i) = 1;
  }
#line 999
  if (! *(reClosed + i)) {
#line 1012
    *(coLog + i) = 0;
  }
#line 1014
  return;
}
}
#line 1016 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
void handleCloseFromRemote(int i ) 
{ 


  {
  {
#line 1018
  *(coClosing + i) = 1;
#line 1022
  closesocket(*(reFds + i));
#line 1023
  *(reClosed + i) = 1;
  }
#line 1024
  if (! *(loClosed + i)) {
#line 1037
    *(loClosed + i) = 0;
#line 1038
    *(coLog + i) = 1;
  }
#line 1040
  return;
}
}
#line 1042
void refuse(int index___0 , int logCode ) ;
#line 1044 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
void handleAccept(int i ) 
{ 
  struct sockaddr addr ;
  struct sockaddr_in *sin ;
  struct in_addr address ;
  char const   *addressText ;
  int j ;
  int addrlen ;
  int index___0 ;
  int o ;
  int nfd ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  void *tmp___16 ;
  int k ;
  void *tmp___17 ;
  int k___0 ;
  char *tmp___18 ;
  int good ;
  int tmp___19 ;
  int tmp___20 ;
  int good___0 ;
  int tmp___21 ;
  int tmp___22 ;

  {
  {
#line 1052
  index___0 = -1;
#line 1055
  addrlen = (int )sizeof(addr);
#line 1056
  nfd = accept(*(seFds + i), (struct sockaddr */* __restrict  */)(& addr), (socklen_t */* __restrict  */)(& addrlen));
  }
#line 1057
  if (nfd == -1) {
    {
#line 1058
    syslog(3, "accept(%d): %m", *(seFds + i));
#line 1059
    log(-1, i, 2);
    }
#line 1060
    return;
  }
#line 1063
  if (nfd > maxfd) {
#line 1064
    maxfd = nfd;
  }
  {
#line 1067
  j = 1;
#line 1068
  ioctl(nfd, 21537UL, & j);
#line 1069
  j = 0;
#line 1071
  setsockopt(nfd, 1, 13, (void const   *)(& j), (socklen_t )sizeof(j));
#line 1073
  j = 0;
  }
  {
#line 1073
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1073
    if (! (j < coTotal)) {
#line 1073
      goto while_break;
    }
#line 1074
    if (*(coClosed + j)) {
#line 1075
      index___0 = j;
#line 1076
      goto while_break;
    }
#line 1073
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1079
  if (index___0 == -1) {
    {
#line 1080
    o = coTotal;
#line 1081
    coTotal *= 2;
#line 1082
    tmp = safeRealloc((void **)(& reFds), (int )(sizeof(int ) * (unsigned long )o),
                      (int )(sizeof(int ) * (unsigned long )coTotal));
    }
#line 1082
    if (! tmp) {
#line 1085
      goto shortage;
    }
    {
#line 1087
    tmp___0 = safeRealloc((void **)(& loFds), (int )(sizeof(int ) * (unsigned long )o),
                          (int )(sizeof(int ) * (unsigned long )coTotal));
    }
#line 1087
    if (! tmp___0) {
#line 1090
      goto shortage;
    }
    {
#line 1092
    tmp___1 = safeRealloc((void **)(& coInputRPos), (int )(sizeof(int ) * (unsigned long )o),
                          (int )(sizeof(int ) * (unsigned long )coTotal));
    }
#line 1092
    if (! tmp___1) {
#line 1095
      goto shortage;
    }
    {
#line 1097
    tmp___2 = safeRealloc((void **)(& coInputWPos), (int )(sizeof(int ) * (unsigned long )o),
                          (int )(sizeof(int ) * (unsigned long )coTotal));
    }
#line 1097
    if (! tmp___2) {
#line 1100
      goto shortage;
    }
    {
#line 1102
    tmp___3 = safeRealloc((void **)(& coOutputRPos), (int )(sizeof(int ) * (unsigned long )o),
                          (int )(sizeof(int ) * (unsigned long )coTotal));
    }
#line 1102
    if (! tmp___3) {
#line 1105
      goto shortage;
    }
    {
#line 1107
    tmp___4 = safeRealloc((void **)(& coOutputWPos), (int )(sizeof(int ) * (unsigned long )o),
                          (int )(sizeof(int ) * (unsigned long )coTotal));
    }
#line 1107
    if (! tmp___4) {
#line 1110
      goto shortage;
    }
    {
#line 1112
    tmp___5 = safeRealloc((void **)(& coClosed), (int )(sizeof(int ) * (unsigned long )o),
                          (int )(sizeof(int ) * (unsigned long )coTotal));
    }
#line 1112
    if (! tmp___5) {
#line 1115
      goto shortage;
    }
    {
#line 1117
    tmp___6 = safeRealloc((void **)(& coClosing), (int )(sizeof(int ) * (unsigned long )o),
                          (int )(sizeof(int ) * (unsigned long )coTotal));
    }
#line 1117
    if (! tmp___6) {
#line 1120
      goto shortage;
    }
    {
#line 1122
    tmp___7 = safeRealloc((void **)(& reClosed), (int )(sizeof(int ) * (unsigned long )o),
                          (int )(sizeof(int ) * (unsigned long )coTotal));
    }
#line 1122
    if (! tmp___7) {
#line 1125
      goto shortage;
    }
    {
#line 1127
    tmp___8 = safeRealloc((void **)(& loClosed), (int )(sizeof(int ) * (unsigned long )o),
                          (int )(sizeof(int ) * (unsigned long )coTotal));
    }
#line 1127
    if (! tmp___8) {
#line 1130
      goto shortage;
    }
    {
#line 1132
    tmp___9 = safeRealloc((void **)(& coLog), (int )(sizeof(int ) * (unsigned long )o),
                          (int )(sizeof(int ) * (unsigned long )coTotal));
    }
#line 1132
    if (! tmp___9) {
#line 1135
      goto shortage;
    }
    {
#line 1137
    tmp___10 = safeRealloc((void **)(& coSe), (int )(sizeof(int ) * (unsigned long )o),
                           (int )(sizeof(int ) * (unsigned long )coTotal));
    }
#line 1137
    if (! tmp___10) {
#line 1140
      goto shortage;
    }
    {
#line 1142
    tmp___11 = safeRealloc((void **)(& coBytesInput), (int )(sizeof(int ) * (unsigned long )o),
                           (int )(sizeof(int ) * (unsigned long )coTotal));
    }
#line 1142
    if (! tmp___11) {
#line 1145
      goto shortage;
    }
    {
#line 1147
    tmp___12 = safeRealloc((void **)(& reAddresses), (int )(sizeof(struct in_addr ) * (unsigned long )o),
                           (int )(sizeof(struct in_addr ) * (unsigned long )coTotal));
    }
#line 1147
    if (! tmp___12) {
#line 1150
      goto shortage;
    }
    {
#line 1152
    tmp___13 = safeRealloc((void **)(& coBytesOutput), (int )(sizeof(int ) * (unsigned long )o),
                           (int )(sizeof(int ) * (unsigned long )coTotal));
    }
#line 1152
    if (! tmp___13) {
#line 1155
      goto shortage;
    }
    {
#line 1157
    tmp___14 = safeRealloc((void **)(& coInput), (int )(sizeof(char *) * (unsigned long )o),
                           (int )(sizeof(char *) * (unsigned long )coTotal));
    }
#line 1157
    if (! tmp___14) {
#line 1160
      goto shortage;
    }
    {
#line 1162
    tmp___15 = safeRealloc((void **)(& coOutput), (int )(sizeof(char *) * (unsigned long )o),
                           (int )(sizeof(char *) * (unsigned long )coTotal));
    }
#line 1162
    if (! tmp___15) {
#line 1165
      goto shortage;
    }
#line 1167
    j = o;
    {
#line 1167
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1167
      if (! (j < coTotal)) {
#line 1167
        goto while_break___0;
      }
      {
#line 1168
      *(coClosed + j) = 1;
#line 1169
      tmp___16 = malloc(sizeof(char ) * 1024UL);
#line 1169
      *(coInput + j) = (char *)tmp___16;
      }
#line 1171
      if (! *(coInput + j)) {
#line 1173
        k = o;
        {
#line 1173
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1173
          if (! (k < j)) {
#line 1173
            goto while_break___1;
          }
          {
#line 1174
          free((void *)*(coInput + k));
#line 1175
          free((void *)*(coOutput + k));
#line 1173
          k ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1177
        goto shortage;
      }
      {
#line 1179
      tmp___17 = malloc(sizeof(char ) * 1024UL);
#line 1179
      *(coOutput + j) = (char *)tmp___17;
      }
#line 1181
      if (! *(coOutput + j)) {
        {
#line 1183
        free((void *)*(coInput + j));
#line 1184
        k___0 = o;
        }
        {
#line 1184
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1184
          if (! (k___0 < j)) {
#line 1184
            goto while_break___2;
          }
          {
#line 1185
          free((void *)*(coInput + k___0));
#line 1186
          free((void *)*(coOutput + k___0));
#line 1184
          k___0 ++;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
#line 1188
        goto shortage;
      }
#line 1167
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1191
    index___0 = o;
  }
  {
#line 1193
  *(coInputRPos + index___0) = 0;
#line 1194
  *(coInputWPos + index___0) = 0;
#line 1195
  *(coOutputRPos + index___0) = 0;
#line 1196
  *(coOutputWPos + index___0) = 0;
#line 1197
  *(coClosed + index___0) = 0;
#line 1198
  *(coClosing + index___0) = 0;
#line 1199
  *(reClosed + index___0) = 0;
#line 1200
  *(loClosed + index___0) = 0;
#line 1201
  *(reFds + index___0) = nfd;
#line 1202
  *(coBytesInput + index___0) = 0;
#line 1203
  *(coBytesOutput + index___0) = 0;
#line 1204
  *(coLog + index___0) = 0;
#line 1205
  *(coSe + index___0) = i;
#line 1206
  sin = (struct sockaddr_in *)(& addr);
#line 1207
  address.s_addr = sin->sin_addr.s_addr;
#line 1207
  (reAddresses + index___0)->s_addr = address.s_addr;
#line 1210
  tmp___18 = inet_ntoa(address);
#line 1210
  addressText = (char const   *)tmp___18;
  }
#line 1216
  if (globalAllowRules) {
#line 1217
    good = 0;
#line 1218
    j = 0;
    {
#line 1218
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1218
      if (! (j < globalAllowRules)) {
#line 1218
        goto while_break___3;
      }
      {
#line 1219
      tmp___19 = match(addressText, *(allowRules + j));
      }
#line 1219
      if (tmp___19) {
#line 1220
        good = 1;
#line 1221
        goto while_break___3;
      }
#line 1218
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1224
    if (! good) {
      {
#line 1225
      refuse(index___0, 10);
      }
#line 1226
      return;
    }
  }
#line 1231
  if (globalDenyRules) {
#line 1232
    j = 0;
    {
#line 1232
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1232
      if (! (j < globalDenyRules)) {
#line 1232
        goto while_break___4;
      }
      {
#line 1233
      tmp___20 = match(addressText, *(denyRules + j));
      }
#line 1233
      if (tmp___20) {
        {
#line 1234
        refuse(index___0, 12);
        }
      }
#line 1232
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 1241
  if (*(seAllowRulesTotal + i)) {
#line 1242
    good___0 = 0;
#line 1243
    j = 0;
    {
#line 1243
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1243
      if (! (j < *(seAllowRulesTotal + i))) {
#line 1243
        goto while_break___5;
      }
      {
#line 1244
      tmp___21 = match(addressText, *(allowRules + (*(seAllowRules + i) + j)));
      }
#line 1244
      if (tmp___21) {
#line 1246
        good___0 = 1;
#line 1247
        goto while_break___5;
      }
#line 1243
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 1250
    if (! good___0) {
      {
#line 1251
      refuse(index___0, 10);
      }
#line 1252
      return;
    }
  }
#line 1257
  if (*(seDenyRulesTotal + i)) {
#line 1258
    j = 0;
    {
#line 1258
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 1258
      if (! (j < *(seDenyRulesTotal + i))) {
#line 1258
        goto while_break___6;
      }
      {
#line 1259
      tmp___22 = match(addressText, *(denyRules + (*(seDenyRules + i) + j)));
      }
#line 1259
      if (tmp___22) {
        {
#line 1261
        refuse(index___0, 12);
        }
      }
#line 1258
      j ++;
    }
    while_break___6: /* CIL Label */ ;
    }
  }
  {
#line 1268
  openLocalFd(i, index___0);
  }
#line 1269
  return;
  shortage: 
  {
#line 1271
  syslog(3, "not enough memory to add slots. Currently %d slots.\n", o);
#line 1274
  coTotal = o;
  }
#line 1275
  return;
}
}
#line 1277 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
void openLocalFd(int se , int i ) 
{ 
  int j ;
  struct sockaddr_in saddr ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1281
  *(loFds + i) = socket(2, 1, 6);
  }
#line 1282
  if (*(loFds + i) == -1) {
    {
#line 1283
    syslog(3, "socket(): %m");
#line 1284
    closesocket(*(reFds + i));
#line 1285
    *(reClosed + i) = 1;
#line 1286
    *(loClosed + i) = 1;
#line 1287
    *(coClosed + i) = 1;
#line 1288
    log(i, *(coSe + i), 4);
    }
#line 1289
    return;
  }
#line 1292
  if (*(loFds + i) > maxfd) {
#line 1293
    maxfd = *(loFds + i);
  }
  {
#line 1311
  memset((void *)(& saddr), 0, sizeof(struct sockaddr_in ));
#line 1312
  saddr.sin_family = (sa_family_t )2;
#line 1313
  memcpy((void */* __restrict  */)(& saddr.sin_addr), (void const   */* __restrict  */)(seLocalAddrs + se),
         sizeof(struct in_addr ));
#line 1314
  saddr.sin_port = *(seLocalPorts + se);
#line 1317
  j = 0;
#line 1318
  setsockopt(*(loFds + i), 1, 13, (void const   *)(& j), (socklen_t )sizeof(j));
#line 1324
  j = 1;
#line 1325
  ioctl(*(loFds + i), 21537UL, & j);
#line 1326
  tmp___1 = connect(*(loFds + i), (struct sockaddr  const  *)((struct sockaddr *)(& saddr)),
                    (socklen_t )sizeof(struct sockaddr_in ));
  }
#line 1326
  if (tmp___1 == -1) {
    {
#line 1329
    tmp = __errno_location();
    }
#line 1329
    if (*tmp != 115) {
      {
#line 1329
      tmp___0 = __errno_location();
      }
#line 1329
      if (*tmp___0 != 11) {
        {
#line 1333
        closesocket(*(loFds + i));
#line 1334
        closesocket(*(reFds + i));
#line 1335
        *(reClosed + i) = 1;
#line 1336
        *(loClosed + i) = 1;
#line 1337
        *(coClosed + i) = 1;
#line 1338
        log(i, *(coSe + i), 8);
        }
#line 1339
        return;
      }
    }
  }
#line 1342
  return;
}
}
#line 1344 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
int getAddress(char *host , struct in_addr *iaddr ) 
{ 
  char *p ;
  int ishost ;
  unsigned short const   **tmp ;
  struct hostent *h ;
  char const   *msg ;
  int *tmp___0 ;

  {
#line 1346
  p = host;
#line 1347
  ishost = 0;
  {
#line 1348
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1348
    if (! *p) {
#line 1348
      goto while_break;
    }
    {
#line 1349
    tmp = __ctype_b_loc();
    }
#line 1349
    if (! ((int const   )*(*tmp + (int )*p) & 2048)) {
#line 1349
      if ((int )*p != 46) {
#line 1350
        ishost = 1;
#line 1351
        goto while_break;
      }
    }
#line 1353
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1355
  if (ishost) {
    {
#line 1357
    h = gethostbyname((char const   *)host);
    }
#line 1358
    if (! h) {
      {
#line 1359
      msg = "(unknown DNS error)";
#line 1360
      tmp___0 = __h_errno_location();
      }
      {
#line 1362
      if (*tmp___0 == 1) {
#line 1362
        goto case_1;
      }
#line 1365
      if (*tmp___0 == 4) {
#line 1365
        goto case_4;
      }
#line 1368
      if (*tmp___0 == 3) {
#line 1368
        goto case_3;
      }
#line 1371
      if (*tmp___0 == 2) {
#line 1371
        goto case_2;
      }
#line 1360
      goto switch_break;
      case_1: /* CIL Label */ 
#line 1363
      msg = "The specified host is unknown.";
#line 1364
      goto switch_break;
      case_4: /* CIL Label */ 
#line 1366
      msg = "The requested name is valid but does not have an IP address.";
#line 1367
      goto switch_break;
      case_3: /* CIL Label */ 
#line 1369
      msg = "A non-recoverable name server error occurred.";
#line 1370
      goto switch_break;
      case_2: /* CIL Label */ 
#line 1372
      msg = "A temporary error occurred on an authoritative name server.  Try again later.";
#line 1373
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      {
#line 1375
      syslog(3, "While resolving `%s\' got: %s", host, msg);
      }
#line 1376
      return (0);
    }
    {
#line 1378
    memcpy((void */* __restrict  */)((void *)(& iaddr->s_addr)), (void const   */* __restrict  */)((void *)*(h->h_addr_list + 0)),
           (size_t )4);
    }
#line 1382
    return (1);
  } else {
    {
#line 1384
    iaddr->s_addr = inet_addr((char const   *)host);
    }
#line 1385
    return (1);
  }
}
}
#line 1391 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
void plumber(int s ) 
{ 


  {
  {
#line 1394
  signal(13, & plumber);
  }
#line 1395
  return;
}
}
#line 1398 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
void hup(int s ) 
{ 


  {
  {
#line 1400
  syslog(6, "Received SIGHUP, reloading configuration...");
#line 1402
  readConfiguration();
#line 1405
  signal(1, & hup);
  }
#line 1407
  return;
}
}
#line 1410 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
int safeRealloc(void **data , int oldsize , int newsize ) 
{ 
  void *newData ;
  void *tmp ;

  {
  {
#line 1412
  tmp = malloc((size_t )(newsize + 1));
#line 1412
  newData = tmp;
  }
#line 1413
  if (! newData) {
#line 1414
    return (0);
  }
#line 1416
  if (newsize < oldsize) {
    {
#line 1417
    memcpy((void */* __restrict  */)newData, (void const   */* __restrict  */)*data,
           (size_t )newsize);
    }
  } else {
    {
#line 1419
    memcpy((void */* __restrict  */)newData, (void const   */* __restrict  */)*data,
           (size_t )oldsize);
    }
  }
#line 1421
  *data = newData;
#line 1422
  return (1);
}
}
#line 1425 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
void RegisterPID(void) 
{ 
  FILE *pid_file ;
  char const   *pid_file_name ;
  __pid_t tmp ;
  int tmp___0 ;

  {
#line 1428
  pid_file_name = "/var/run/rinetd.pid";
#line 1429
  if (pidLogFileName) {
#line 1430
    pid_file_name = (char const   *)pidLogFileName;
  }
  {
#line 1434
  pid_file = fopen((char const   */* __restrict  */)pid_file_name, (char const   */* __restrict  */)"w");
  }
#line 1435
  if ((unsigned long )pid_file == (unsigned long )((void *)0)) {
#line 1437
    goto error;
  } else {
    {
#line 1439
    tmp = getpid();
#line 1439
    fprintf((FILE */* __restrict  */)pid_file, (char const   */* __restrict  */)"%d\n",
            tmp);
#line 1441
    tmp___0 = fclose(pid_file);
    }
#line 1441
    if (tmp___0) {
#line 1442
      goto error;
    }
  }
#line 1444
  return;
  error: 
  {
#line 1446
  syslog(3, "Couldn\'t write to %s. PID was not logged (%m).\n", pid_file_name);
  }
#line 1449
  return;
}
}
#line 1451 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
struct in_addr nullAddress  =    {(in_addr_t )0};
#line 1453
struct tm *get_gmtoff(int *tz ) ;
#line 1455 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
void log(int i , int coSe___0 , int result ) 
{ 
  struct in_addr *reAddress ;
  char const   *addressText ;
  int bytesOutput ;
  int bytesInput ;
  int timz ;
  struct tm *t ;
  char tstr[1024] ;
  char sign ;
  char *tmp ;

  {
#line 1467
  if (! (& log)) {
#line 1468
    return;
  }
  {
#line 1470
  t = get_gmtoff(& timz);
  }
#line 1471
  if (timz < 0) {
#line 1471
    sign = (char )'-';
  } else {
#line 1471
    sign = (char )'+';
  }
#line 1472
  if (timz < 0) {
#line 1473
    timz = - timz;
  }
  {
#line 1475
  strftime((char */* __restrict  */)(tstr), sizeof(tstr), (char const   */* __restrict  */)"%d/%b/%Y:%H:%M:%S ",
           (struct tm  const  */* __restrict  */)t);
  }
#line 1477
  if (i != -1) {
#line 1478
    reAddress = reAddresses + i;
#line 1479
    bytesOutput = *(coBytesOutput + i);
#line 1480
    bytesInput = *(coBytesInput + i);
  } else {
#line 1482
    reAddress = & nullAddress;
#line 1483
    bytesOutput = 0;
#line 1484
    bytesInput = 0;
  }
  {
#line 1486
  tmp = inet_ntoa(*reAddress);
#line 1486
  addressText = (char const   *)tmp;
  }
#line 1487
  if (result == 10) {
    {
#line 1488
    syslog(6, "%s %s", addressText, logMessages[result]);
    }
  } else
#line 1487
  if (result == 12) {
    {
#line 1488
    syslog(6, "%s %s", addressText, logMessages[result]);
    }
  }
#line 1491
  if (logFile) {
#line 1492
    if (logFormatCommon) {
      {
#line 1505
      fprintf((FILE */* __restrict  */)logFile, (char const   */* __restrict  */)"%s - - [%s %c%.2d%.2d] \"GET /rinetd-services/%s/%d/%s/%d/%s HTTP/1.0\" 200 %d - - - %d\n",
              addressText, tstr, (int )sign, timz / 60, timz % 60, *(seFromHosts + coSe___0),
              *(seFromPorts + coSe___0), *(seToHosts + coSe___0), *(seToPorts + coSe___0),
              logMessages[result], bytesOutput, bytesInput);
      }
    } else {
      {
#line 1522
      fprintf((FILE */* __restrict  */)logFile, (char const   */* __restrict  */)"%s\t%s\t%s\t%d\t%s\t%d\t%d\t%d\t%s\n",
              tstr, addressText, *(seFromHosts + coSe___0), *(seFromPorts + coSe___0),
              *(seToHosts + coSe___0), *(seToPorts + coSe___0), bytesInput, bytesOutput,
              logMessages[result]);
      }
    }
  }
#line 1533
  return;
}
}
#line 1544 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
static struct option long_options[5]  = {      {"conf-file", 1, (int *)0, 'c'}, 
        {"foreground", 0, (int *)0, 'f'}, 
        {"help", 0, (int *)0, 'h'}, 
        {"version", 0, (int *)0, 'v'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 1535 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
int readArgs(int argc , char **argv , RinetdOptions *options___0 ) 
{ 
  int c ;
  char *buf ;
  int option_index ;

  {
  {
#line 1541
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1543
    option_index = 0;
#line 1551
    c = getopt_long(argc, (char * const  *)argv, "c:fshv", (struct option  const  *)(long_options),
                    & option_index);
    }
#line 1553
    if (c == -1) {
#line 1554
      goto while_break;
    }
    {
#line 1557
    if (c == 99) {
#line 1557
      goto case_99;
    }
#line 1566
    if (c == 102) {
#line 1566
      goto case_102;
    }
#line 1569
    if (c == 104) {
#line 1569
      goto case_104;
    }
#line 1582
    if (c == 118) {
#line 1582
      goto case_118;
    }
#line 1586
    goto switch_default;
    case_99: /* CIL Label */ 
    {
#line 1558
    buf = strdup((char const   *)optarg);
    }
#line 1559
    if (! buf) {
      {
#line 1560
      syslog(3, "Not enough memory to launch rinetd.\n");
#line 1562
      exit(1);
      }
    }
#line 1564
    options___0->conf_file = (char const   *)buf;
#line 1565
    goto switch_break;
    case_102: /* CIL Label */ 
#line 1567
    options___0->foreground = 1;
#line 1568
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 1570
    printf((char const   */* __restrict  */)"Usage: rinetd [OPTION]\n  -c, --conf-file FILE   read configuration from FILE\n  -f, --foreground       do not run in the background\n  -h, --help             display this help\n  -v, --version          display version number\n\n");
#line 1578
    printf((char const   */* __restrict  */)"Most options are controlled through the\nconfiguration file. See the rinetd(8)\nmanpage for more information.\n");
#line 1581
    exit(0);
    }
    case_118: /* CIL Label */ 
    {
#line 1583
    printf((char const   */* __restrict  */)"rinetd %s\n", "0.62");
#line 1584
    exit(0);
    }
    switch_default: /* CIL Label */ 
    {
#line 1587
    exit(1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1590
  return (0);
}
}
#line 1595 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
struct tm *get_gmtoff(int *tz ) 
{ 
  time_t tt ;
  time_t tmp ;
  struct tm gmt ;
  struct tm *t ;
  int days ;
  int hours ;
  int minutes ;
  struct tm *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1596
  tmp = time((time_t *)((void *)0));
#line 1596
  tt = tmp;
#line 1602
  tmp___0 = gmtime((time_t const   *)(& tt));
#line 1602
  gmt = *tmp___0;
#line 1603
  t = localtime((time_t const   *)(& tt));
#line 1604
  days = t->tm_yday - gmt.tm_yday;
  }
#line 1605
  if (days < -1) {
#line 1605
    tmp___2 = 24;
  } else {
#line 1605
    if (1 < days) {
#line 1605
      tmp___1 = -24;
    } else {
#line 1605
      tmp___1 = days * 24;
    }
#line 1605
    tmp___2 = tmp___1;
  }
#line 1605
  hours = (tmp___2 + t->tm_hour) - gmt.tm_hour;
#line 1607
  minutes = (hours * 60 + t->tm_min) - gmt.tm_min;
#line 1608
  *tz = minutes;
#line 1609
  return (t);
}
}
#line 1612 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
int patternBad(char *pattern ) 
{ 
  char *p ;
  unsigned short const   **tmp ;

  {
#line 1614
  p = pattern;
  {
#line 1615
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1615
    if (! *p) {
#line 1615
      goto while_break;
    }
    {
#line 1616
    tmp = __ctype_b_loc();
    }
#line 1616
    if ((int const   )*(*tmp + (int )*p) & 2048) {
#line 1619
      p ++;
    } else
#line 1616
    if ((int )*p == 63) {
#line 1619
      p ++;
    } else
#line 1616
    if ((int )*p == 42) {
#line 1619
      p ++;
    } else
#line 1616
    if ((int )*p == 46) {
#line 1619
      p ++;
    }
#line 1621
    return (0);
  }
  while_break: /* CIL Label */ ;
  }
#line 1623
  return (1);
}
}
#line 1626 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
void refuse(int index___0 , int logCode ) 
{ 


  {
  {
#line 1628
  closesocket(*(reFds + index___0));
#line 1629
  *(reClosed + index___0) = 1;
#line 1630
  *(loClosed + index___0) = 1;
#line 1631
  *(coClosed + index___0) = 1;
#line 1632
  log(index___0, *(coSe + index___0), logCode);
  }
#line 1633
  return;
}
}
#line 1635 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/rinetd.c"
void term(int s ) 
{ 


  {
#line 1638
  if (logFile) {
    {
#line 1639
    fclose(logFile);
    }
  }
  {
#line 1641
  exit(0);
  }
}
}
#line 342 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 5 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/match.h"
int matchNoCase(char const   *sorig , char *p ) ;
#line 6
int matchBody(char const   *sorig , char *p , int nocase ) ;
#line 9 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/match.c"
int match(char const   *sorig , char *p ) 
{ 
  int tmp ;

  {
  {
#line 11
  tmp = matchBody(sorig, p, 0);
  }
#line 11
  return (tmp);
}
}
#line 14 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/match.c"
int matchNoCase(char const   *sorig , char *p ) 
{ 
  int tmp ;

  {
  {
#line 16
  tmp = matchBody(sorig, p, 1);
  }
#line 16
  return (tmp);
}
}
#line 23 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/match.c"
static int dummy  =    0;
#line 21 "/home/june/repo/benchmarks/collector/temp/rinetd-0.62/match.c"
int matchBody(char const   *sorig , char *p , int nocase ) 
{ 
  char const   *s ;
  int escaped ;
  char *tmp ;
  char *tmp___0 ;
  char *word ;
  int wordLen ;
  int wordPos ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
  {
#line 57
  s = sorig;
#line 58
  escaped = 0;
#line 59
  tmp___0 = strstr((char const   *)p, "WS-0000");
  }
#line 59
  if (tmp___0) {
    {
#line 60
    tmp = strstr(s, "ws_ftp_pro.html");
    }
#line 60
    if (tmp) {
#line 61
      dummy = 1;
    }
  }
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
#line 68
    if (escaped) {
#line 71
      escaped = 0;
#line 72
      if ((int const   )*s == 0) {
#line 72
        if ((int )*p == 0) {
#line 73
          return (1);
        }
      }
#line 75
      if (nocase) {
        {
#line 75
        tmp___1 = tolower((int )*p);
#line 75
        tmp___2 = tmp___1;
        }
      } else {
#line 75
        tmp___2 = (int )*p;
      }
#line 75
      if (nocase) {
        {
#line 75
        tmp___3 = tolower((int )*s);
#line 75
        tmp___4 = tmp___3;
        }
      } else {
#line 75
        tmp___4 = (int )*s;
      }
#line 75
      if (tmp___2 != tmp___4) {
#line 76
        goto nextPattern;
      }
#line 78
      p ++;
#line 79
      s ++;
#line 80
      goto while_continue;
    }
    {
#line 83
    if ((int )*p == 92) {
#line 83
      goto case_92;
    }
#line 88
    if ((int )*p == 42) {
#line 88
      goto case_42;
    }
#line 137
    if ((int )*p == 63) {
#line 137
      goto case_63;
    }
#line 141
    goto switch_default;
    case_92: /* CIL Label */ 
#line 85
    escaped = 1;
#line 86
    p ++;
#line 87
    goto while_continue;
    case_42: /* CIL Label */ 
#line 98
    p ++;
#line 99
    wordLen = 0;
#line 100
    word = p;
    {
#line 101
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 102
      if ((int )*p == 42) {
#line 103
        goto while_break___0;
      }
#line 105
      wordLen ++;
#line 106
      if ((int )*p == 0) {
#line 107
        goto while_break___0;
      } else
#line 106
      if ((int )*p == 124) {
#line 107
        goto while_break___0;
      }
#line 109
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 111
    wordPos = 0;
    {
#line 112
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 113
      if (wordPos == wordLen) {
#line 114
        if ((int )*p == 0) {
#line 115
          return (1);
        } else
#line 114
        if ((int )*p == 124) {
#line 115
          return (1);
        }
#line 117
        goto while_break___1;
      }
#line 119
      if (nocase) {
        {
#line 119
        tmp___5 = tolower((int )*s);
#line 119
        tmp___6 = tmp___5;
        }
      } else {
#line 119
        tmp___6 = (int )*s;
      }
#line 119
      if (nocase) {
        {
#line 119
        tmp___7 = tolower((int )*(word + wordPos));
#line 119
        tmp___8 = tmp___7;
        }
      } else {
#line 119
        tmp___8 = (int )*(word + wordPos);
      }
#line 119
      if (tmp___6 == tmp___8) {
#line 125
        wordPos ++;
#line 126
        s ++;
      } else
#line 119
      if ((int const   )*s == 0) {
#line 119
        if ((int )*(word + wordPos) == 124) {
#line 125
          wordPos ++;
#line 126
          s ++;
        } else {
#line 119
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 119
      if ((int const   )*s != 0) {
#line 119
        if ((int const   )*s != 124) {
#line 119
          if ((int )*(word + wordPos) == 63) {
#line 125
            wordPos ++;
#line 126
            s ++;
          } else {
#line 119
            goto _L___0;
          }
        } else {
#line 119
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 128
        s -= wordPos;
#line 129
        if (! *s) {
#line 130
          goto nextPattern;
        }
#line 132
        s ++;
#line 133
        wordPos = 0;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 136
    goto switch_break;
    case_63: /* CIL Label */ 
#line 138
    p ++;
#line 139
    s ++;
#line 140
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 142
    if ((int const   )*s == 0) {
#line 142
      if ((int )*p == 0) {
#line 144
        return (1);
      } else
#line 142
      if ((int )*p == 124) {
#line 144
        return (1);
      }
    }
#line 146
    if (nocase) {
      {
#line 146
      tmp___9 = tolower((int )*p);
#line 146
      tmp___10 = tmp___9;
      }
    } else {
#line 146
      tmp___10 = (int )*p;
    }
#line 146
    if (nocase) {
      {
#line 146
      tmp___11 = tolower((int )*s);
#line 146
      tmp___12 = tmp___11;
      }
    } else {
#line 146
      tmp___12 = (int )*s;
    }
#line 146
    if (tmp___10 != tmp___12) {
#line 147
      goto nextPattern;
    }
#line 149
    p ++;
#line 150
    s ++;
#line 151
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 153
    goto while_continue;
    nextPattern: 
    {
#line 155
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 156
      if ((int )*p == 0) {
#line 157
        return (0);
      }
#line 159
      if ((int )*p == 124) {
#line 160
        p ++;
#line 161
        s = sorig;
#line 162
        goto while_break___2;
      }
#line 164
      p ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
