/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 92 "/usr/include/stdio.h"
typedef __off64_t off_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 368 "/usr/include/x86_64-linux-gnu/zconf.h"
typedef unsigned char Byte;
#line 370 "/usr/include/x86_64-linux-gnu/zconf.h"
typedef unsigned int uInt;
#line 371 "/usr/include/x86_64-linux-gnu/zconf.h"
typedef unsigned long uLong;
#line 377 "/usr/include/x86_64-linux-gnu/zconf.h"
typedef Byte Bytef;
#line 386 "/usr/include/x86_64-linux-gnu/zconf.h"
typedef void *voidpf;
#line 83 "/usr/include/zlib.h"
struct internal_state;
#line 83
struct internal_state;
#line 85 "/usr/include/zlib.h"
struct z_stream_s {
   Bytef *next_in ;
   uInt avail_in ;
   uLong total_in ;
   Bytef *next_out ;
   uInt avail_out ;
   uLong total_out ;
   char *msg ;
   struct internal_state *state ;
   voidpf (*zalloc)(voidpf opaque , uInt items , uInt size ) ;
   void (*zfree)(voidpf opaque , voidpf address ) ;
   voidpf opaque ;
   int data_type ;
   uLong adler ;
   uLong reserved ;
};
#line 85 "/usr/include/zlib.h"
typedef struct z_stream_s z_stream;
#line 106 "/usr/include/zlib.h"
typedef z_stream *z_streamp;
#line 1742 "/usr/include/zlib.h"
struct internal_state {
   int dummy ;
};
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 846
extern void perror(char const   *__s ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 149 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...)  __asm__("open64")  ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 392 "/usr/include/zlib.h"
extern int inflate(z_streamp strm , int flush ) ;
#line 508
extern int inflateEnd(z_streamp strm ) ;
#line 1641
extern int inflateInit2_(z_streamp strm , int windowBits , char const   *version ,
                         int stream_size ) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/gzrt-0.8/gzrecover.c"
static char const   *optstring  =    "ho:psVv";
#line 38 "/home/june/repo/benchmarks/collector/temp/gzrt-0.8/gzrecover.c"
static char const   *usage  =    "Usage: gzrecover [-hpsVv] [-o <outfile>] [infile]";
#line 41 "/home/june/repo/benchmarks/collector/temp/gzrt-0.8/gzrecover.c"
static int split_mode  =    0;
#line 42 "/home/june/repo/benchmarks/collector/temp/gzrt-0.8/gzrecover.c"
static int verbose_mode  =    0;
#line 43 "/home/june/repo/benchmarks/collector/temp/gzrt-0.8/gzrecover.c"
static int outfile_specified  =    0;
#line 44 "/home/june/repo/benchmarks/collector/temp/gzrt-0.8/gzrecover.c"
static int stdout_specified  =    0;
#line 45 "/home/june/repo/benchmarks/collector/temp/gzrt-0.8/gzrecover.c"
static char *user_outname  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/gzrt-0.8/gzrecover.c"
static size_t inbuf_size  =    (size_t )1048576;
#line 47 "/home/june/repo/benchmarks/collector/temp/gzrt-0.8/gzrecover.c"
static size_t outbuf_size  =    (size_t )65536;
#line 50 "/home/june/repo/benchmarks/collector/temp/gzrt-0.8/gzrecover.c"
void show_usage_and_exit(int exit_status ) 
{ 


  {
  {
#line 53
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          usage);
#line 54
  exit(exit_status);
  }
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/gzrt-0.8/gzrecover.c"
ssize_t read_internal(int fd , void *buf , size_t count ) 
{ 
  ssize_t rc ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 63
  rc = (ssize_t )0;
  {
#line 65
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 67
    rc = read(fd, buf, count);
    }
#line 68
    if (rc == -1L) {
      {
#line 68
      tmp = __errno_location();
      }
#line 68
      if (*tmp == 4) {
#line 69
        goto __Cont;
      } else {
        {
#line 68
        tmp___0 = __errno_location();
        }
#line 68
        if (*tmp___0 == 11) {
#line 69
          goto __Cont;
        }
      }
    }
#line 71
    return (rc);
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 81
int open_outfile(char *infile ) ;
#line 81 "/home/june/repo/benchmarks/collector/temp/gzrt-0.8/gzrecover.c"
static int suffix  =    1;
#line 76 "/home/june/repo/benchmarks/collector/temp/gzrt-0.8/gzrecover.c"
int open_outfile(char *infile ) 
{ 
  int ofd ;
  char *outfile ;
  char *ptr ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 84
  if (stdout_specified) {
#line 85
    return (1);
  }
#line 88
  if (outfile_specified) {
    {
#line 89
    tmp = strlen((char const   *)user_outname);
#line 89
    tmp___0 = malloc(tmp + 9UL);
#line 89
    outfile = (char *)tmp___0;
    }
  } else {
    {
#line 91
    tmp___1 = strlen((char const   *)infile);
#line 91
    tmp___2 = malloc(tmp___1 + 25UL);
#line 91
    outfile = (char *)tmp___2;
    }
  }
#line 92
  if ((unsigned long )outfile == (unsigned long )((char *)0)) {
    {
#line 92
    perror("malloc");
#line 92
    exit(1);
    }
  }
#line 94
  if (! outfile_specified) {
    {
#line 96
    ptr = strstr((char const   *)infile, ".gz");
    }
#line 97
    if (ptr) {
#line 98
      *ptr = (char )'\000';
    }
    {
#line 100
    ptr = strrchr((char const   *)infile, '/');
    }
#line 101
    if (ptr) {
#line 102
      infile = ptr + 1;
    }
  }
#line 105
  if (outfile_specified) {
#line 105
    if (split_mode) {
      {
#line 106
      tmp___3 = suffix;
#line 106
      suffix ++;
#line 106
      sprintf((char */* __restrict  */)outfile, (char const   */* __restrict  */)"%s.%d",
              user_outname, tmp___3);
      }
    } else {
#line 105
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 107
  if (outfile_specified) {
    {
#line 108
    strcpy((char */* __restrict  */)outfile, (char const   */* __restrict  */)user_outname);
    }
  } else
#line 109
  if (split_mode) {
    {
#line 110
    tmp___4 = suffix;
#line 110
    suffix ++;
#line 110
    sprintf((char */* __restrict  */)outfile, (char const   */* __restrict  */)"%s.recovered.%d",
            infile, tmp___4);
    }
  } else {
    {
#line 112
    sprintf((char */* __restrict  */)outfile, (char const   */* __restrict  */)"%s.recovered",
            infile);
    }
  }
  {
#line 115
  ofd = open((char const   *)outfile, 66, 384);
  }
#line 116
  if (ofd == -1) {
    {
#line 116
    perror("open");
#line 116
    exit(1);
    }
  }
#line 118
  if (verbose_mode) {
    {
#line 119
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Opened output file for writing: %s\n",
            outfile);
    }
  }
  {
#line 121
  free((void *)outfile);
  }
#line 123
  return (ofd);
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/gzrt-0.8/gzrecover.c"
void init_zlib(z_stream *d_stream , unsigned char *buffer , size_t bufsize ) 
{ 
  int rc ;

  {
  {
#line 132
  memset((void *)d_stream, 0, sizeof(z_stream ));
#line 133
  d_stream->next_in = buffer;
#line 134
  d_stream->avail_in = (uInt )bufsize;
#line 136
  rc = inflateInit2_(d_stream, -15, "1.2.8", (int )sizeof(z_stream ));
  }
#line 137
  if (rc != 0) {
    {
#line 137
    perror("inflateInit2");
#line 137
    exit(1);
    }
  }
#line 138
  return;
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/gzrt-0.8/gzrecover.c"
void skip_gzip_header(z_stream *d_stream ) 
{ 
  char flags ;
  unsigned int len ;

  {
#line 147
  flags = (char )*(d_stream->next_in + 3);
#line 148
  d_stream->next_in += 10;
#line 149
  d_stream->avail_in -= 10U;
#line 151
  if (((int )flags & 4) != 0) {
#line 153
    len = (unsigned int )*(d_stream->next_in);
#line 154
    len += (unsigned int )*(d_stream->next_in) << 8;
#line 155
    d_stream->next_in += 2U + len;
#line 156
    d_stream->avail_in -= 2U + len;
  }
#line 159
  if (((int )flags & 8) != 0) {
    {
#line 161
    while (1) {
      while_continue: /* CIL Label */ ;
#line 161
      if (! ((int )*(d_stream->next_in) != 0)) {
#line 161
        goto while_break;
      }
#line 163
      (d_stream->next_in) ++;
#line 164
      (d_stream->avail_in) --;
    }
    while_break: /* CIL Label */ ;
    }
#line 166
    (d_stream->next_in) ++;
#line 167
    (d_stream->avail_in) --;
  }
#line 170
  if (((int )flags & 16) != 0) {
    {
#line 171
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 171
      if (! ((int )*(d_stream->next_in) != 0)) {
#line 171
        goto while_break___0;
      }
#line 173
      (d_stream->next_in) ++;
#line 174
      (d_stream->avail_in) --;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 177
  if (((int )flags & 2) != 0) {
#line 179
    d_stream->next_in += 2;
#line 180
    d_stream->avail_in -= 2U;
  }
#line 182
  return;
}
}
#line 185 "/home/june/repo/benchmarks/collector/temp/gzrt-0.8/gzrecover.c"
int main(int argc , char **argv ) 
{ 
  int opt ;
  int rc ;
  int rc2 ;
  int ifd ;
  int ofd ;
  int founderr ;
  int foundgood ;
  ssize_t bytes_read ;
  ssize_t tot_written ;
  off_t errpos ;
  off_t errinc ;
  off_t readpos ;
  char *infile ;
  unsigned char *inbuf ;
  unsigned char *outbuf ;
  z_stream d_stream ;
  void *tmp ;
  void *tmp___0 ;
  ssize_t tmp___1 ;
  off_t tmppos ;

  {
#line 188
  founderr = 0;
#line 188
  foundgood = 0;
#line 189
  bytes_read = (ssize_t )0;
#line 189
  tot_written = (ssize_t )0;
#line 190
  errpos = (off_t )0;
#line 190
  errinc = (off_t )0;
#line 190
  readpos = (off_t )0;
  {
#line 196
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 196
    opt = getopt(argc, (char * const  *)argv, optstring);
    }
#line 196
    if (! (opt != -1)) {
#line 196
      goto while_break;
    }
    {
#line 200
    if (opt == 104) {
#line 200
      goto case_104;
    }
#line 204
    if (opt == 111) {
#line 204
      goto case_111;
    }
#line 209
    if (opt == 112) {
#line 209
      goto case_112;
    }
#line 213
    if (opt == 115) {
#line 213
      goto case_115;
    }
#line 217
    if (opt == 118) {
#line 217
      goto case_118;
    }
#line 221
    if (opt == 86) {
#line 221
      goto case_86;
    }
#line 225
    goto switch_default;
    case_104: /* CIL Label */ 
    {
#line 201
    show_usage_and_exit(0);
    }
#line 202
    goto switch_break;
    case_111: /* CIL Label */ 
#line 205
    user_outname = optarg;
#line 206
    outfile_specified = 1;
#line 207
    goto switch_break;
    case_112: /* CIL Label */ 
#line 210
    stdout_specified = 1;
#line 211
    goto switch_break;
    case_115: /* CIL Label */ 
#line 214
    split_mode = 1;
#line 215
    goto switch_break;
    case_118: /* CIL Label */ 
#line 218
    verbose_mode = 1;
#line 219
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 222
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"gzrecover %s\n",
            "0.8");
    }
#line 223
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 226
    show_usage_and_exit(1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 231
  if (outfile_specified) {
#line 231
    if (stdout_specified) {
      {
#line 233
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"gzrecover: Cannot specify output filename (-o) and stdout (-p) simultaneously.\n");
#line 234
      show_usage_and_exit(1);
      }
    }
  }
  {
#line 238
  tmp = malloc(inbuf_size);
#line 238
  inbuf = (unsigned char *)tmp;
  }
#line 239
  if ((unsigned long )inbuf == (unsigned long )((unsigned char *)0)) {
    {
#line 239
    perror("malloc");
#line 239
    exit(1);
    }
  }
#line 243
  if (optind == argc) {
#line 245
    infile = (char *)"stdin";
#line 246
    ifd = 0;
  } else {
    {
#line 250
    infile = *(argv + optind);
#line 251
    ifd = open((char const   *)infile, 0);
    }
  }
#line 253
  if (ifd == -1) {
    {
#line 253
    free((void *)inbuf);
#line 253
    perror("open");
#line 253
    exit(1);
    }
  }
#line 255
  if (verbose_mode) {
    {
#line 256
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Opened input file for reading: %s\n",
            infile);
    }
  }
  {
#line 259
  ofd = open_outfile(infile);
#line 260
  tmp___0 = malloc(outbuf_size);
#line 260
  outbuf = (unsigned char *)tmp___0;
  }
#line 261
  if ((unsigned long )outbuf == (unsigned long )((unsigned char *)0)) {
    {
#line 261
    perror("malloc");
#line 261
    exit(1);
    }
  }
  {
#line 264
  bytes_read = read_internal(ifd, (void *)inbuf, inbuf_size);
  }
#line 265
  if (-1L == bytes_read) {
    {
#line 265
    perror("read");
#line 265
    exit(1);
    }
  }
#line 266
  if (bytes_read == 0L) {
#line 268
    if (verbose_mode) {
      {
#line 269
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"File is empty\n");
      }
    }
    {
#line 270
    close(ifd);
#line 271
    close(ofd);
#line 272
    free((void *)inbuf);
#line 273
    free((void *)outbuf);
    }
#line 274
    return (0);
  }
  {
#line 276
  readpos = bytes_read;
#line 278
  init_zlib(& d_stream, inbuf, (size_t )bytes_read);
#line 280
  skip_gzip_header(& d_stream);
  }
  {
#line 283
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 285
    d_stream.next_out = outbuf;
#line 286
    d_stream.avail_out = (uInt )outbuf_size;
#line 288
    rc = inflate(& d_stream, 0);
    }
#line 295
    if (rc != 0) {
#line 295
      if (rc != 1) {
#line 297
        foundgood = 0;
#line 303
        if (! founderr) {
#line 305
          founderr = 1;
#line 306
          errpos = bytes_read - (ssize_t )d_stream.avail_in;
#line 308
          if (verbose_mode) {
            {
#line 309
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Found error at byte %d in input stream\n",
                    (int )(readpos - (bytes_read - errpos)));
            }
          }
#line 312
          if (d_stream.avail_in == 0U) {
            {
#line 314
            bytes_read = read_internal(ifd, (void *)inbuf, inbuf_size);
            }
#line 315
            if (bytes_read == -1L) {
              {
#line 315
              perror("read");
#line 315
              exit(1);
              }
            }
#line 316
            if (bytes_read == 0L) {
#line 317
              goto while_break___0;
            }
            {
#line 318
            readpos += bytes_read;
#line 320
            errinc = (off_t )0;
#line 321
            inflateEnd(& d_stream);
#line 322
            init_zlib(& d_stream, inbuf, (size_t )bytes_read);
            }
#line 323
            goto __Cont;
          }
        }
        {
#line 335
        inflateEnd(& d_stream);
#line 336
        errinc ++;
        }
#line 339
        if ((size_t )bytes_read > (size_t )(errpos + errinc)) {
          {
#line 341
          init_zlib(& d_stream, (inbuf + errpos) + errinc, (size_t )(bytes_read - (errpos + errinc)));
          }
        } else {
          {
#line 346
          bytes_read = read_internal(ifd, (void *)inbuf, inbuf_size);
          }
#line 347
          if (bytes_read == -1L) {
            {
#line 347
            perror("read");
#line 347
            exit(1);
            }
          }
#line 348
          if (bytes_read == 0L) {
#line 349
            goto while_break___0;
          }
          {
#line 350
          readpos += bytes_read;
#line 352
          inflateEnd(& d_stream);
#line 353
          init_zlib(& d_stream, inbuf, (size_t )bytes_read);
#line 357
          errpos = (off_t )0;
#line 358
          errinc = (off_t )0;
          }
        }
#line 361
        goto __Cont;
      }
    }
#line 370
    if (founderr & ! foundgood) {
#line 372
      foundgood = 1;
#line 373
      founderr = 0;
#line 374
      errinc = (off_t )0;
#line 376
      if (verbose_mode) {
        {
#line 377
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Found good data at byte %d in input stream\n",
                (int )(readpos - (bytes_read - (ssize_t )d_stream.avail_in)));
        }
      }
#line 380
      if (split_mode) {
        {
#line 382
        close(ofd);
#line 383
        ofd = open_outfile(infile);
        }
      }
    }
    {
#line 388
    tmp___1 = write(ofd, (void const   *)outbuf, outbuf_size - (size_t )d_stream.avail_out);
#line 388
    rc2 = (int )tmp___1;
    }
#line 389
    if (rc2 == -1) {
      {
#line 389
      perror("write");
#line 389
      exit(1);
      }
    }
#line 390
    tot_written += (ssize_t )rc2;
#line 393
    if (d_stream.avail_in == 0U) {
      {
#line 395
      bytes_read = read_internal(ifd, (void *)inbuf, inbuf_size);
      }
#line 396
      if (bytes_read == -1L) {
        {
#line 396
        perror("read");
#line 396
        exit(1);
        }
      }
#line 397
      if (bytes_read == 0L) {
#line 398
        goto while_break___0;
      }
#line 399
      readpos += bytes_read;
#line 401
      errinc = (off_t )0;
#line 402
      d_stream.next_in = inbuf;
#line 403
      d_stream.avail_in = (uInt )bytes_read;
    }
#line 410
    if (rc == 1) {
      {
#line 412
      tmppos = (off_t )d_stream.avail_in;
#line 414
      inflateEnd(& d_stream);
      }
#line 415
      if ((unsigned long )d_stream.next_in == (unsigned long )inbuf) {
        {
#line 417
        init_zlib(& d_stream, inbuf, (size_t )bytes_read);
        }
      } else {
        {
#line 421
        init_zlib(& d_stream, (inbuf + (bytes_read - tmppos)) + 1, (size_t )(tmppos + 1L));
        }
      }
#line 425
      goto __Cont;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 429
  inflateEnd(& d_stream);
#line 432
  close(ofd);
#line 433
  close(ifd);
  }
#line 435
  if (verbose_mode) {
    {
#line 436
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Total decompressed output = %d bytes\n",
            (int )tot_written);
    }
  }
  {
#line 439
  free((void *)inbuf);
#line 440
  free((void *)outbuf);
  }
#line 442
  return (0);
}
}
