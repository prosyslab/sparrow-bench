/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 33 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_long;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 36 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_long u_long;
#line 106 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
typedef unsigned char gf;
#line 627 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
struct fec_parms {
   u_long magic ;
   int k ;
   int n ;
   gf *enc_matrix ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 128 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino64_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 181 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef __off64_t __loff_t;
#line 44 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __loff_t loff_t;
#line 88 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __off64_t off_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino64_t d_ino ;
   __off64_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 55 "/usr/include/stdint.h"
typedef unsigned long uint64_t;
#line 20 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 26 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 30 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 87 "/usr/include/asm-generic/posix_types.h"
typedef long long __kernel_loff_t;
#line 25 "./include/mtd/mtd-abi.h"
struct erase_info_user {
   __u32 start ;
   __u32 length ;
};
#line 30 "./include/mtd/mtd-abi.h"
struct erase_info_user64 {
   __u64 start ;
   __u64 length ;
};
#line 35 "./include/mtd/mtd-abi.h"
struct mtd_oob_buf {
   __u32 start ;
   __u32 length ;
   unsigned char *ptr ;
};
#line 41 "./include/mtd/mtd-abi.h"
struct mtd_oob_buf64 {
   __u64 start ;
   __u32 pad ;
   __u32 length ;
   __u64 usr_ptr ;
};
#line 83 "./include/mtd/mtd-abi.h"
struct mtd_write_req {
   __u64 start ;
   __u64 len ;
   __u64 ooblen ;
   __u64 usr_data ;
   __u64 usr_oob ;
   __u8 mode ;
   __u8 padding[7] ;
};
#line 135 "./include/mtd/mtd-abi.h"
struct region_info_user {
   __u32 offset ;
   __u32 erasesize ;
   __u32 numblocks ;
   __u32 regionindex ;
};
#line 209 "./include/mtd/mtd-abi.h"
struct nand_oobinfo {
   __u32 useecc ;
   __u32 eccbytes ;
   __u32 oobfree[8][2] ;
   __u32 eccpos[32] ;
};
#line 29 "./include/mtd/mtd-user.h"
typedef struct erase_info_user erase_info_t;
#line 36 "./include/libmtd.h"
typedef void *libmtd_t;
#line 47 "./include/libmtd.h"
struct mtd_info {
   int mtd_dev_cnt ;
   int lowest_mtd_num ;
   int highest_mtd_num ;
   unsigned int sysfs_supported : 1 ;
};
#line 73 "./include/libmtd.h"
struct mtd_dev_info {
   int mtd_num ;
   int major ;
   int minor ;
   int type ;
   char const   type_str[65] ;
   char const   name[128] ;
   long long size ;
   int eb_cnt ;
   int eb_size ;
   int min_io_size ;
   int subpage_size ;
   int oob_size ;
   int region_cnt ;
   unsigned int writable : 1 ;
   unsigned int bb_allowed : 1 ;
};
#line 79 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd_int.h"
struct libmtd {
   char *sysfs_mtd ;
   char *mtd ;
   char *mtd_dev ;
   char *mtd_name ;
   char *mtd_type ;
   char *mtd_eb_size ;
   char *mtd_size ;
   char *mtd_min_io_size ;
   char *mtd_subpage_size ;
   char *mtd_oob_size ;
   char *mtd_region_cnt ;
   char *mtd_flags ;
   unsigned int sysfs_supported : 1 ;
   unsigned int offs64_ioctls : 2 ;
};
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 246 "./include/mtd/mtd-abi.h"
struct mtd_ecc_stats {
   __u32 corrected ;
   __u32 failed ;
   __u32 badblocks ;
   __u32 bbtblocks ;
};
#line 92 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/nanddump.c"
enum __anonenum_bb_method_33 {
    padbad = 0,
    dumpbad = 1,
    skipbad = 2
} ;
#line 125 "./include/mtd/mtd-abi.h"
struct mtd_info_user {
   __u8 type ;
   __u32 flags ;
   __u32 size ;
   __u32 erasesize ;
   __u32 writesize ;
   __u32 oobsize ;
   __u64 padding ;
};
#line 59 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd_legacy.c"
struct proc_parse_info {
   int mtd_num ;
   long long size ;
   char name[128] ;
   int eb_size ;
   char *buf ;
   int data_size ;
   char *next ;
};
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 96 "./include/linux/jffs2.h"
struct __anonstruct_jint32_t_33 {
   uint32_t v32 ;
} __attribute__((__packed__)) ;
#line 96 "./include/linux/jffs2.h"
typedef struct __anonstruct_jint32_t_33 jint32_t;
#line 104 "./include/linux/jffs2.h"
struct __anonstruct_jint16_t_35 {
   uint16_t v16 ;
} __attribute__((__packed__)) ;
#line 104 "./include/linux/jffs2.h"
typedef struct __anonstruct_jint16_t_35 jint16_t;
#line 108 "./include/linux/jffs2.h"
struct jffs2_unknown_node {
   jint16_t magic ;
   jint16_t nodetype ;
   jint32_t totlen ;
   jint32_t hdr_crc ;
} __attribute__((__packed__)) ;
#line 32 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __u_int;
#line 35 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_int u_int;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 200 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned char u_int8_t;
#line 201 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned short u_int16_t;
#line 202 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int u_int32_t;
#line 28 "./include/mtd/mtd-user.h"
typedef struct mtd_info_user mtd_info_t;
#line 36 "./include/mtd/ftl-user.h"
struct erase_unit_header_t {
   u_int8_t LinkTargetTuple[5] ;
   u_int8_t DataOrgTuple[10] ;
   u_int8_t NumTransferUnits ;
   u_int32_t EraseCount ;
   u_int16_t LogicalEUN ;
   u_int8_t BlockSize ;
   u_int8_t EraseUnitSize ;
   u_int16_t FirstPhysicalEUN ;
   u_int16_t NumEraseUnits ;
   u_int32_t FormattedSize ;
   u_int32_t FirstVMAddress ;
   u_int16_t NumVMPages ;
   u_int8_t Flags ;
   u_int8_t Code ;
   u_int32_t SerialNumber ;
   u_int32_t AltEUHOffset ;
   u_int32_t BAMOffset ;
   u_int8_t Reserved[12] ;
   u_int8_t EndTuple[2] ;
};
#line 36 "./include/mtd/ftl-user.h"
typedef struct erase_unit_header_t erase_unit_header_t;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 117 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static char const   *allPp[17]  = 
#line 117 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
  {      (char const   *)((void *)0),      (char const   *)((void *)0),      "111",      "1101", 
        "11001",      "101001",      "1100001",      "10010001", 
        "101110001",      "1000100001",      "10010000001",      "101000000001", 
        "1100101000001",      "11011000000001",      "110000100010001",      "1100000000000001", 
        "11010000000010001"};
#line 147 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static gf gf_exp[2 * ((1 << 8) - 1)]  ;
#line 148 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static int gf_log[((1 << 8) - 1) + 1]  ;
#line 149 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static gf inverse[((1 << 8) - 1) + 1]  ;
#line 156 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
__inline static gf modnn(int x ) 
{ 


  {
  {
#line 159
  while (1) {
    while_continue: /* CIL Label */ ;
#line 159
    if (! (x >= (1 << 8) - 1)) {
#line 159
      goto while_break;
    }
#line 160
    x -= (1 << 8) - 1;
#line 161
    x = (x >> 8) + (x & ((1 << 8) - 1));
  }
  while_break: /* CIL Label */ ;
  }
#line 163
  return ((gf )x);
}
}
#line 179 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static gf gf_mul_table[((1 << 8) - 1) + 1][((1 << 8) - 1) + 1]  ;
#line 187 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static void init_mul_table(void) 
{ 
  int i ;
  int j ;
  gf tmp ;
  gf tmp___0 ;

  {
#line 191
  i = 0;
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 191
    if (! (i < ((1 << 8) - 1) + 1)) {
#line 191
      goto while_break;
    }
#line 192
    j = 0;
    {
#line 192
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 192
      if (! (j < ((1 << 8) - 1) + 1)) {
#line 192
        goto while_break___0;
      }
      {
#line 193
      tmp = modnn(gf_log[i] + gf_log[j]);
#line 193
      gf_mul_table[i][j] = gf_exp[tmp];
#line 192
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 191
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 195
  j = 0;
  {
#line 195
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 195
    if (! (j < ((1 << 8) - 1) + 1)) {
#line 195
      goto while_break___1;
    }
#line 196
    tmp___0 = (gf )0;
#line 196
    gf_mul_table[j][0] = tmp___0;
#line 196
    gf_mul_table[0][j] = tmp___0;
#line 195
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 197
  return;
}
}
#line 228 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static void *my_malloc(int sz , char const   *err_string ) 
{ 
  void *p ;
  void *tmp ;

  {
  {
#line 231
  tmp = malloc((size_t )sz);
#line 231
  p = tmp;
  }
#line 232
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 233
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-- malloc failure allocating %s\n",
            err_string);
#line 234
    exit(1);
    }
  }
#line 236
  return (p);
}
}
#line 245 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static void generate_gf(void) 
{ 
  int i ;
  gf mask ;
  char const   *Pp ;

  {
#line 250
  Pp = allPp[8];
#line 252
  mask = (gf )1;
#line 253
  gf_exp[8] = (gf )0;
#line 260
  i = 0;
  {
#line 260
  while (1) {
    while_continue: /* CIL Label */ ;
#line 260
    if (! (i < 8)) {
#line 260
      goto while_break;
    }
#line 261
    gf_exp[i] = mask;
#line 262
    gf_log[gf_exp[i]] = i;
#line 267
    if ((int const   )*(Pp + i) == 49) {
#line 268
      gf_exp[8] = (gf )((int )gf_exp[8] ^ (int )mask);
    }
#line 260
    i ++;
#line 260
    mask = (gf )((int )mask << 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 274
  gf_log[gf_exp[8]] = 8;
#line 281
  mask = (gf )(1 << 7);
#line 282
  i = 9;
  {
#line 282
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 282
    if (! (i < (1 << 8) - 1)) {
#line 282
      goto while_break___0;
    }
#line 283
    if ((int )gf_exp[i - 1] >= (int )mask) {
#line 284
      gf_exp[i] = (gf )((int )gf_exp[8] ^ (((int )gf_exp[i - 1] ^ (int )mask) << 1));
    } else {
#line 286
      gf_exp[i] = (gf )((int )gf_exp[i - 1] << 1);
    }
#line 287
    gf_log[gf_exp[i]] = i;
#line 282
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 292
  gf_log[0] = (1 << 8) - 1;
#line 294
  i = 0;
  {
#line 294
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 294
    if (! (i < (1 << 8) - 1)) {
#line 294
      goto while_break___1;
    }
#line 295
    gf_exp[i + ((1 << 8) - 1)] = gf_exp[i];
#line 294
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 302
  inverse[0] = (gf )0;
#line 303
  inverse[1] = (gf )1;
#line 304
  i = 2;
  {
#line 304
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 304
    if (! (i <= (1 << 8) - 1)) {
#line 304
      goto while_break___2;
    }
#line 305
    inverse[i] = gf_exp[((1 << 8) - 1) - gf_log[i]];
#line 304
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 306
  return;
}
}
#line 325 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static void addmul1(gf *dst1 , gf *src1 , gf c , int sz ) 
{ 
  register gf *__gf_mulc_ ;
  register gf *dst ;
  register gf *src ;
  gf *lim ;

  {
#line 329
  dst = dst1;
#line 329
  src = src1;
#line 330
  lim = dst + ((sz - 16) + 1);
#line 332
  __gf_mulc_ = gf_mul_table[c];
  {
#line 335
  while (1) {
    while_continue: /* CIL Label */ ;
#line 335
    if (! ((unsigned long )dst < (unsigned long )lim)) {
#line 335
      goto while_break;
    }
#line 336
    *(dst + 0) = (gf )((int )*(dst + 0) ^ (int )*(__gf_mulc_ + *(src + 0)));
#line 337
    *(dst + 1) = (gf )((int )*(dst + 1) ^ (int )*(__gf_mulc_ + *(src + 1)));
#line 338
    *(dst + 2) = (gf )((int )*(dst + 2) ^ (int )*(__gf_mulc_ + *(src + 2)));
#line 339
    *(dst + 3) = (gf )((int )*(dst + 3) ^ (int )*(__gf_mulc_ + *(src + 3)));
#line 341
    *(dst + 4) = (gf )((int )*(dst + 4) ^ (int )*(__gf_mulc_ + *(src + 4)));
#line 342
    *(dst + 5) = (gf )((int )*(dst + 5) ^ (int )*(__gf_mulc_ + *(src + 5)));
#line 343
    *(dst + 6) = (gf )((int )*(dst + 6) ^ (int )*(__gf_mulc_ + *(src + 6)));
#line 344
    *(dst + 7) = (gf )((int )*(dst + 7) ^ (int )*(__gf_mulc_ + *(src + 7)));
#line 347
    *(dst + 8) = (gf )((int )*(dst + 8) ^ (int )*(__gf_mulc_ + *(src + 8)));
#line 348
    *(dst + 9) = (gf )((int )*(dst + 9) ^ (int )*(__gf_mulc_ + *(src + 9)));
#line 349
    *(dst + 10) = (gf )((int )*(dst + 10) ^ (int )*(__gf_mulc_ + *(src + 10)));
#line 350
    *(dst + 11) = (gf )((int )*(dst + 11) ^ (int )*(__gf_mulc_ + *(src + 11)));
#line 351
    *(dst + 12) = (gf )((int )*(dst + 12) ^ (int )*(__gf_mulc_ + *(src + 12)));
#line 352
    *(dst + 13) = (gf )((int )*(dst + 13) ^ (int )*(__gf_mulc_ + *(src + 13)));
#line 353
    *(dst + 14) = (gf )((int )*(dst + 14) ^ (int )*(__gf_mulc_ + *(src + 14)));
#line 354
    *(dst + 15) = (gf )((int )*(dst + 15) ^ (int )*(__gf_mulc_ + *(src + 15)));
#line 335
    dst += 16;
#line 335
    src += 16;
  }
  while_break: /* CIL Label */ ;
  }
#line 358
  lim += 15;
  {
#line 359
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 359
    if (! ((unsigned long )dst < (unsigned long )lim)) {
#line 359
      goto while_break___0;
    }
#line 360
    *dst = (gf )((int )*dst ^ (int )*(__gf_mulc_ + *src));
#line 359
    dst ++;
#line 359
    src ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 361
  return;
}
}
#line 366 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static void matmul(gf *a , gf *b , gf *c , int n , int k , int m ) 
{ 
  int row ;
  int col ;
  int i ;
  gf *pa ;
  gf *pb ;
  gf acc ;

  {
#line 371
  row = 0;
  {
#line 371
  while (1) {
    while_continue: /* CIL Label */ ;
#line 371
    if (! (row < n)) {
#line 371
      goto while_break;
    }
#line 372
    col = 0;
    {
#line 372
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 372
      if (! (col < m)) {
#line 372
        goto while_break___0;
      }
#line 373
      pa = a + row * k;
#line 374
      pb = b + col;
#line 375
      acc = (gf )0;
#line 376
      i = 0;
      {
#line 376
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 376
        if (! (i < k)) {
#line 376
          goto while_break___1;
        }
#line 377
        acc = (gf )((int )acc ^ (int )gf_mul_table[*pa][*pb]);
#line 376
        i ++;
#line 376
        pa ++;
#line 376
        pb += m;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 378
      *(c + (row * m + col)) = acc;
#line 372
      col ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 371
    row ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 381
  return;
}
}
#line 410 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static int invert_mat(gf *src , int k ) 
{ 
  gf c ;
  gf *p ;
  int irow ;
  int icol ;
  int row ;
  int col ;
  int i ;
  int ix ;
  int error ;
  int *indxc ;
  void *tmp ;
  int *indxr ;
  void *tmp___0 ;
  int *ipiv ;
  void *tmp___1 ;
  gf *id_row ;
  void *tmp___2 ;
  gf *temp_row ;
  void *tmp___3 ;
  gf *pivot_row ;
  gf tmp___4 ;
  int tmp___5 ;
  gf tmp___6 ;

  {
  {
#line 416
  error = 1;
#line 417
  tmp = my_malloc((int )((unsigned long )k * sizeof(int )), "indxc");
#line 417
  indxc = (int *)tmp;
#line 418
  tmp___0 = my_malloc((int )((unsigned long )k * sizeof(int )), "indxr");
#line 418
  indxr = (int *)tmp___0;
#line 419
  tmp___1 = my_malloc((int )((unsigned long )k * sizeof(int )), "ipiv");
#line 419
  ipiv = (int *)tmp___1;
#line 420
  tmp___2 = my_malloc((int )((unsigned long )k * sizeof(gf )), " ## __LINE__ ## ");
#line 420
  id_row = (gf *)tmp___2;
#line 421
  tmp___3 = my_malloc((int )((unsigned long )k * sizeof(gf )), " ## __LINE__ ## ");
#line 421
  temp_row = (gf *)tmp___3;
#line 423
  memset((void *)id_row, '\000', (unsigned long )k * sizeof(gf ));
#line 428
  i = 0;
  }
  {
#line 428
  while (1) {
    while_continue: /* CIL Label */ ;
#line 428
    if (! (i < k)) {
#line 428
      goto while_break;
    }
#line 429
    *(ipiv + i) = 0;
#line 428
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 431
  col = 0;
  {
#line 431
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 431
    if (! (col < k)) {
#line 431
      goto while_break___0;
    }
#line 437
    icol = -1;
#line 437
    irow = icol;
#line 438
    if (*(ipiv + col) != 1) {
#line 438
      if ((int )*(src + (col * k + col)) != 0) {
#line 439
        irow = col;
#line 440
        icol = col;
#line 441
        goto found_piv;
      }
    }
#line 443
    row = 0;
    {
#line 443
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 443
      if (! (row < k)) {
#line 443
        goto while_break___1;
      }
#line 444
      if (*(ipiv + row) != 1) {
#line 445
        ix = 0;
        {
#line 445
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 445
          if (! (ix < k)) {
#line 445
            goto while_break___2;
          }
#line 447
          if (*(ipiv + ix) == 0) {
#line 448
            if ((int )*(src + (row * k + ix)) != 0) {
#line 449
              irow = row;
#line 450
              icol = ix;
#line 451
              goto found_piv;
            }
          } else
#line 453
          if (*(ipiv + ix) > 1) {
            {
#line 454
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"singular matrix\n");
            }
#line 455
            goto fail;
          }
#line 445
          ix ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 443
      row ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 460
    if (icol == -1) {
      {
#line 461
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"XXX pivot not found!\n");
      }
#line 462
      goto fail;
    }
    found_piv: 
#line 465
    (*(ipiv + icol)) ++;
#line 471
    if (irow != icol) {
#line 472
      ix = 0;
      {
#line 472
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 472
        if (! (ix < k)) {
#line 472
          goto while_break___3;
        }
#line 473
        tmp___4 = *(src + (irow * k + ix));
#line 473
        *(src + (irow * k + ix)) = *(src + (icol * k + ix));
#line 473
        *(src + (icol * k + ix)) = tmp___4;
#line 472
        ix ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 476
    *(indxr + col) = irow;
#line 477
    *(indxc + col) = icol;
#line 478
    pivot_row = src + icol * k;
#line 479
    c = *(pivot_row + icol);
#line 480
    if ((int )c == 0) {
      {
#line 481
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"singular matrix 2\n");
      }
#line 482
      goto fail;
    }
#line 484
    if ((int )c != 1) {
#line 490
      c = inverse[c];
#line 491
      *(pivot_row + icol) = (gf )1;
#line 492
      ix = 0;
      {
#line 492
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 492
        if (! (ix < k)) {
#line 492
          goto while_break___4;
        }
#line 493
        *(pivot_row + ix) = gf_mul_table[c][*(pivot_row + ix)];
#line 492
        ix ++;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
    {
#line 502
    *(id_row + icol) = (gf )1;
#line 503
    tmp___5 = memcmp((void const   *)pivot_row, (void const   *)id_row, (unsigned long )k * sizeof(gf ));
    }
#line 503
    if (tmp___5 != 0) {
#line 504
      p = src;
#line 504
      ix = 0;
      {
#line 504
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 504
        if (! (ix < k)) {
#line 504
          goto while_break___5;
        }
#line 505
        if (ix != icol) {
#line 506
          c = *(p + icol);
#line 507
          *(p + icol) = (gf )0;
#line 508
          if ((int )c != 0) {
            {
#line 508
            addmul1(p, pivot_row, c, k);
            }
          }
        }
#line 504
        ix ++;
#line 504
        p += k;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
#line 512
    *(id_row + icol) = (gf )0;
#line 431
    col ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 514
  col = k - 1;
  {
#line 514
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 514
    if (! (col >= 0)) {
#line 514
      goto while_break___6;
    }
#line 515
    if (*(indxr + col) < 0) {
      {
#line 516
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"AARGH, indxr[col] %d\n",
              *(indxr + col));
      }
    } else
#line 515
    if (*(indxr + col) >= k) {
      {
#line 516
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"AARGH, indxr[col] %d\n",
              *(indxr + col));
      }
    } else
#line 517
    if (*(indxc + col) < 0) {
      {
#line 518
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"AARGH, indxc[col] %d\n",
              *(indxc + col));
      }
    } else
#line 517
    if (*(indxc + col) >= k) {
      {
#line 518
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"AARGH, indxc[col] %d\n",
              *(indxc + col));
      }
    } else
#line 520
    if (*(indxr + col) != *(indxc + col)) {
#line 521
      row = 0;
      {
#line 521
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 521
        if (! (row < k)) {
#line 521
          goto while_break___7;
        }
#line 522
        tmp___6 = *(src + (row * k + *(indxr + col)));
#line 522
        *(src + (row * k + *(indxr + col))) = *(src + (row * k + *(indxc + col)));
#line 522
        *(src + (row * k + *(indxc + col))) = tmp___6;
#line 521
        row ++;
      }
      while_break___7: /* CIL Label */ ;
      }
    }
#line 514
    col --;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 526
  error = 0;
  fail: 
  {
#line 528
  free((void *)indxc);
#line 529
  free((void *)indxr);
#line 530
  free((void *)ipiv);
#line 531
  free((void *)id_row);
#line 532
  free((void *)temp_row);
  }
#line 533
  return (error);
}
}
#line 548 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
int invert_vdm(gf *src , int k ) 
{ 
  int i ;
  int j ;
  int row ;
  int col ;
  gf *b ;
  gf *c ;
  gf *p ;
  gf t ;
  gf xx ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  gf p_i ;

  {
#line 555
  if (k == 1) {
#line 556
    return (0);
  }
  {
#line 561
  tmp = my_malloc((int )((unsigned long )k * sizeof(gf )), " ## __LINE__ ## ");
#line 561
  c = (gf *)tmp;
#line 562
  tmp___0 = my_malloc((int )((unsigned long )k * sizeof(gf )), " ## __LINE__ ## ");
#line 562
  b = (gf *)tmp___0;
#line 564
  tmp___1 = my_malloc((int )((unsigned long )k * sizeof(gf )), " ## __LINE__ ## ");
#line 564
  p = (gf *)tmp___1;
#line 566
  j = 1;
#line 566
  i = 0;
  }
  {
#line 566
  while (1) {
    while_continue: /* CIL Label */ ;
#line 566
    if (! (i < k)) {
#line 566
      goto while_break;
    }
#line 567
    *(c + i) = (gf )0;
#line 568
    *(p + i) = *(src + j);
#line 566
    i ++;
#line 566
    j += k;
  }
  while_break: /* CIL Label */ ;
  }
#line 576
  *(c + (k - 1)) = *(p + 0);
#line 577
  i = 1;
  {
#line 577
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 577
    if (! (i < k)) {
#line 577
      goto while_break___0;
    }
#line 578
    p_i = *(p + i);
#line 579
    j = (k - 1) - (i - 1);
    {
#line 579
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 579
      if (! (j < k - 1)) {
#line 579
        goto while_break___1;
      }
#line 580
      *(c + j) = (gf )((int )*(c + j) ^ (int )gf_mul_table[p_i][*(c + (j + 1))]);
#line 579
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 581
    *(c + (k - 1)) = (gf )((int )*(c + (k - 1)) ^ (int )p_i);
#line 577
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 584
  row = 0;
  {
#line 584
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 584
    if (! (row < k)) {
#line 584
      goto while_break___2;
    }
#line 588
    xx = *(p + row);
#line 589
    t = (gf )1;
#line 590
    *(b + (k - 1)) = (gf )1;
#line 591
    i = k - 2;
    {
#line 591
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 591
      if (! (i >= 0)) {
#line 591
        goto while_break___3;
      }
#line 592
      *(b + i) = (gf )((int )*(c + (i + 1)) ^ (int )gf_mul_table[xx][*(b + (i + 1))]);
#line 593
      t = (gf )((int )gf_mul_table[xx][t] ^ (int )*(b + i));
#line 591
      i --;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 595
    col = 0;
    {
#line 595
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 595
      if (! (col < k)) {
#line 595
        goto while_break___4;
      }
#line 596
      *(src + (col * k + row)) = gf_mul_table[inverse[t]][*(b + col)];
#line 595
      col ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 584
    row ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 598
  free((void *)c);
#line 599
  free((void *)b);
#line 600
  free((void *)p);
  }
#line 601
  return (0);
}
}
#line 604 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static int fec_initialized  =    0;
#line 605 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static void init_fec(void) 
{ 


  {
  {
#line 609
  generate_gf();
#line 613
  init_mul_table();
#line 616
  fec_initialized = 1;
  }
#line 617
  return;
}
}
#line 635 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
void fec_free(struct fec_parms *p ) 
{ 


  {
#line 638
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 639
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad parameters to fec_free\n");
    }
#line 640
    return;
  } else
#line 638
  if (p->magic != ((unsigned long )((4274785772U ^ (unsigned int )p->k) ^ (unsigned int )p->n) ^ (unsigned long )p->enc_matrix)) {
    {
#line 639
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad parameters to fec_free\n");
    }
#line 640
    return;
  }
  {
#line 642
  free((void *)p->enc_matrix);
#line 643
  free((void *)p);
  }
#line 644
  return;
}
}
#line 650 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
struct fec_parms *fec_new(int k , int n ) 
{ 
  int row ;
  int col ;
  gf *p ;
  gf *tmp_m ;
  struct fec_parms *retval ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  gf tmp___2 ;

  {
#line 658
  if (fec_initialized == 0) {
    {
#line 659
    init_fec();
    }
  }
#line 661
  if (k > ((1 << 8) - 1) + 1) {
    {
#line 662
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid parameters k %d n %d GF_SIZE %d\n",
            k, n, (1 << 8) - 1);
    }
#line 664
    return ((struct fec_parms *)((void *)0));
  } else
#line 661
  if (n > ((1 << 8) - 1) + 1) {
    {
#line 662
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid parameters k %d n %d GF_SIZE %d\n",
            k, n, (1 << 8) - 1);
    }
#line 664
    return ((struct fec_parms *)((void *)0));
  } else
#line 661
  if (k > n) {
    {
#line 662
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid parameters k %d n %d GF_SIZE %d\n",
            k, n, (1 << 8) - 1);
    }
#line 664
    return ((struct fec_parms *)((void *)0));
  }
  {
#line 666
  tmp = my_malloc((int )sizeof(struct fec_parms ), "new_code");
#line 666
  retval = (struct fec_parms *)tmp;
#line 667
  retval->k = k;
#line 668
  retval->n = n;
#line 669
  tmp___0 = my_malloc((int )((unsigned long )(n * k) * sizeof(gf )), " ## __LINE__ ## ");
#line 669
  retval->enc_matrix = (gf *)tmp___0;
#line 670
  retval->magic = (unsigned long )((4274785772U ^ (unsigned int )retval->k) ^ (unsigned int )retval->n) ^ (unsigned long )retval->enc_matrix;
#line 671
  tmp___1 = my_malloc((int )((unsigned long )(n * k) * sizeof(gf )), " ## __LINE__ ## ");
#line 671
  tmp_m = (gf *)tmp___1;
#line 676
  *(tmp_m + 0) = (gf )1;
#line 677
  col = 1;
  }
  {
#line 677
  while (1) {
    while_continue: /* CIL Label */ ;
#line 677
    if (! (col < k)) {
#line 677
      goto while_break;
    }
#line 678
    *(tmp_m + col) = (gf )0;
#line 677
    col ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 679
  p = tmp_m + k;
#line 679
  row = 0;
  {
#line 679
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 679
    if (! (row < n - 1)) {
#line 679
      goto while_break___0;
    }
#line 680
    col = 0;
    {
#line 680
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 680
      if (! (col < k)) {
#line 680
        goto while_break___1;
      }
      {
#line 681
      tmp___2 = modnn(row * col);
#line 681
      *(p + col) = gf_exp[tmp___2];
#line 680
      col ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 679
    row ++;
#line 679
    p += k;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 690
  invert_vdm(tmp_m, k);
#line 691
  matmul(tmp_m + k * k, tmp_m, retval->enc_matrix + k * k, n - k, k, k);
#line 695
  memset((void *)retval->enc_matrix, '\000', (unsigned long )(k * k) * sizeof(gf ));
#line 696
  p = retval->enc_matrix;
#line 696
  col = 0;
  }
  {
#line 696
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 696
    if (! (col < k)) {
#line 696
      goto while_break___2;
    }
#line 697
    *p = (gf )1;
#line 696
    col ++;
#line 696
    p += k + 1;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 698
  free((void *)tmp_m);
  }
#line 704
  return (retval);
}
}
#line 712 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
void fec_encode(struct fec_parms *code , gf **src , gf *fec , int index___0 , int sz ) 
{ 
  int i ;
  int k ;
  gf *p ;

  {
#line 715
  k = code->k;
#line 721
  if (index___0 < k) {
    {
#line 722
    memcpy((void */* __restrict  */)fec, (void const   */* __restrict  */)*(src + index___0),
           (unsigned long )sz * sizeof(gf ));
    }
  } else
#line 723
  if (index___0 < code->n) {
    {
#line 724
    p = code->enc_matrix + index___0 * k;
#line 725
    memset((void *)fec, '\000', (unsigned long )sz * sizeof(gf ));
#line 726
    i = 0;
    }
    {
#line 726
    while (1) {
      while_continue: /* CIL Label */ ;
#line 726
      if (! (i < k)) {
#line 726
        goto while_break;
      }
#line 727
      if ((int )*(p + i) != 0) {
        {
#line 727
        addmul1(fec, *(src + i), *(p + i), sz);
        }
      }
#line 726
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 729
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid index %d (max %d)\n",
            index___0, code->n - 1);
    }
  }
#line 731
  return;
}
}
#line 733 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
void fec_encode_linear(struct fec_parms *code , gf *src , gf *fec , int index___0 ,
                       int sz ) 
{ 
  int i ;
  int k ;
  gf *p ;

  {
#line 735
  k = code->k;
#line 741
  if (index___0 < k) {
    {
#line 742
    memcpy((void */* __restrict  */)fec, (void const   */* __restrict  */)(src + index___0 * sz),
           (unsigned long )sz * sizeof(gf ));
    }
  } else
#line 743
  if (index___0 < code->n) {
    {
#line 744
    p = code->enc_matrix + index___0 * k;
#line 745
    memset((void *)fec, '\000', (unsigned long )sz * sizeof(gf ));
#line 746
    i = 0;
    }
    {
#line 746
    while (1) {
      while_continue: /* CIL Label */ ;
#line 746
      if (! (i < k)) {
#line 746
        goto while_break;
      }
#line 747
      if ((int )*(p + i) != 0) {
        {
#line 747
        addmul1(fec, src + i * sz, *(p + i), sz);
        }
      }
#line 746
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 749
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid index %d (max %d)\n",
            index___0, code->n - 1);
    }
  }
#line 751
  return;
}
}
#line 755 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static int shuffle(gf **pkt , int *index___0 , int k ) 
{ 
  int i ;
  int c ;
  int tmp ;
  gf *tmp___0 ;

  {
#line 760
  i = 0;
  {
#line 760
  while (1) {
    while_continue: /* CIL Label */ ;
#line 760
    if (! (i < k)) {
#line 760
      goto while_break;
    }
#line 761
    if (*(index___0 + i) >= k) {
#line 762
      i ++;
    } else
#line 761
    if (*(index___0 + i) == i) {
#line 762
      i ++;
    } else {
#line 767
      c = *(index___0 + i);
#line 769
      if (*(index___0 + c) == c) {
#line 771
        return (1);
      }
#line 773
      tmp = *(index___0 + i);
#line 773
      *(index___0 + i) = *(index___0 + c);
#line 773
      *(index___0 + c) = tmp;
#line 774
      tmp___0 = *(pkt + i);
#line 774
      *(pkt + i) = *(pkt + c);
#line 774
      *(pkt + c) = tmp___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 787
  return (0);
}
}
#line 795 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static gf *build_decode_matrix(struct fec_parms *code , int *index___0 ) 
{ 
  int i ;
  int k ;
  gf *p ;
  gf *matrix ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 798
  k = code->k;
#line 799
  tmp = my_malloc((int )((unsigned long )(k * k) * sizeof(gf )), " ## __LINE__ ## ");
#line 799
  matrix = (gf *)tmp;
#line 802
  i = 0;
#line 802
  p = matrix;
  }
  {
#line 802
  while (1) {
    while_continue: /* CIL Label */ ;
#line 802
    if (! (i < k)) {
#line 802
      goto while_break;
    }
#line 804
    if (*(index___0 + i) < k) {
      {
#line 805
      memset((void *)p, '\000', (unsigned long )k * sizeof(gf ));
#line 806
      *(p + i) = (gf )1;
      }
    } else
#line 809
    if (*(index___0 + i) < code->n) {
      {
#line 810
      memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(code->enc_matrix + *(index___0 + i) * k),
             (unsigned long )k * sizeof(gf ));
      }
    } else {
      {
#line 812
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"decode: invalid index %d (max %d)\n",
              *(index___0 + i), code->n - 1);
#line 814
      free((void *)matrix);
      }
#line 815
      return ((gf *)((void *)0));
    }
#line 802
    i ++;
#line 802
    p += k;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 819
  tmp___0 = invert_mat(matrix, k);
  }
#line 819
  if (tmp___0) {
    {
#line 820
    free((void *)matrix);
#line 821
    matrix = (gf *)((void *)0);
    }
  }
#line 824
  return (matrix);
}
}
#line 838 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
int fec_decode(struct fec_parms *code , gf **pkt , int *index___0 , int sz ) 
{ 
  gf *m_dec ;
  gf **new_pkt ;
  int row ;
  int col ;
  int k ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 843
  k = code->k;
#line 848
  tmp = shuffle(pkt, index___0, k);
  }
#line 848
  if (tmp) {
#line 849
    return (1);
  }
  {
#line 850
  m_dec = build_decode_matrix(code, index___0);
  }
#line 852
  if ((unsigned long )m_dec == (unsigned long )((void *)0)) {
#line 853
    return (1);
  }
  {
#line 857
  tmp___0 = my_malloc((int )((unsigned long )k * sizeof(gf *)), "new pkt pointers");
#line 857
  new_pkt = (gf **)tmp___0;
#line 858
  row = 0;
  }
  {
#line 858
  while (1) {
    while_continue: /* CIL Label */ ;
#line 858
    if (! (row < k)) {
#line 858
      goto while_break;
    }
#line 859
    if (*(index___0 + row) >= k) {
      {
#line 860
      tmp___1 = my_malloc((int )((unsigned long )sz * sizeof(gf )), "new pkt buffer");
#line 860
      *(new_pkt + row) = (gf *)tmp___1;
#line 861
      memset((void *)*(new_pkt + row), '\000', (unsigned long )sz * sizeof(gf ));
#line 862
      col = 0;
      }
      {
#line 862
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 862
        if (! (col < k)) {
#line 862
          goto while_break___0;
        }
#line 863
        if ((int )*(m_dec + (row * k + col)) != 0) {
          {
#line 863
          addmul1(*(new_pkt + row), *(pkt + col), *(m_dec + (row * k + col)), sz);
          }
        }
#line 862
        col ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 858
    row ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 869
  row = 0;
  {
#line 869
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 869
    if (! (row < k)) {
#line 869
      goto while_break___1;
    }
#line 870
    if (*(index___0 + row) >= k) {
      {
#line 871
      memcpy((void */* __restrict  */)*(pkt + row), (void const   */* __restrict  */)*(new_pkt + row),
             (unsigned long )sz * sizeof(gf ));
#line 872
      free((void *)*(new_pkt + row));
      }
    }
#line 869
    row ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 875
  free((void *)new_pkt);
#line 876
  free((void *)m_dec);
  }
#line 878
  return (0);
}
}
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 27 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) gnu_dev_major)(unsigned long long __dev )  __attribute__((__const__)) ;
#line 30
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) gnu_dev_minor)(unsigned long long __dev )  __attribute__((__const__)) ;
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 337 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off64_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                  __off64_t __offset ,
                                                                                  int __whence )  __asm__("lseek64")  ;
#line 353
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 149 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...)  __asm__("open64")  ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 165
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp )  __asm__("readdir64")  ;
#line 217 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf )  __asm__("stat64")  ;
#line 220
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf )  __asm__("fstat64")  ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 100 "./include/libmtd.h"
libmtd_t libmtd_open(void) ;
#line 106
void libmtd_close(libmtd_t desc ) ;
#line 115
int mtd_dev_present(libmtd_t desc , int mtd_num ) ;
#line 126
int mtd_get_info(libmtd_t desc , struct mtd_info *info ) ;
#line 139
int mtd_get_dev_info(libmtd_t desc , char const   *node , struct mtd_dev_info *mtd ) ;
#line 150
int mtd_get_dev_info1(libmtd_t desc , int mtd_num , struct mtd_dev_info *mtd ) ;
#line 162
int mtd_lock(struct mtd_dev_info  const  *mtd , int fd , int eb ) ;
#line 174
int mtd_unlock(struct mtd_dev_info  const  *mtd , int fd , int eb ) ;
#line 186
int mtd_erase(libmtd_t desc , struct mtd_dev_info  const  *mtd , int fd , int eb ) ;
#line 199
int mtd_regioninfo(int fd , int regidx , struct region_info_user *reginfo ) ;
#line 213
int mtd_is_locked(struct mtd_dev_info  const  *mtd , int fd , int eb ) ;
#line 225
int mtd_torture(libmtd_t desc , struct mtd_dev_info  const  *mtd , int fd , int eb ) ;
#line 236
int mtd_is_bad(struct mtd_dev_info  const  *mtd , int fd , int eb ) ;
#line 247
int mtd_mark_bad(struct mtd_dev_info  const  *mtd , int fd , int eb ) ;
#line 262
int mtd_read(struct mtd_dev_info  const  *mtd , int fd , int eb , int offs , void *buf ,
             int len ) ;
#line 284
int mtd_write(libmtd_t desc , struct mtd_dev_info  const  *mtd , int fd , int eb ,
              int offs , void *data , int len , void *oob , int ooblen , uint8_t mode ) ;
#line 302
int mtd_read_oob(libmtd_t desc , struct mtd_dev_info  const  *mtd , int fd , uint64_t start ,
                 uint64_t length___0 , void *data ) ;
#line 319
int mtd_write_oob(libmtd_t desc , struct mtd_dev_info  const  *mtd , int fd , uint64_t start ,
                  uint64_t length___0 , void *data ) ;
#line 334
int mtd_write_img(struct mtd_dev_info  const  *mtd , int fd , int eb , int offs ,
                  char const   *img_name ) ;
#line 346
int mtd_probe_node(libmtd_t desc , char const   *node ) ;
#line 98 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd_int.h"
int legacy_dev_present(int mtd_num ) ;
#line 99
int legacy_mtd_get_info(struct mtd_info *info ) ;
#line 100
int legacy_get_dev_info(char const   *node , struct mtd_dev_info *mtd ) ;
#line 101
int legacy_get_dev_info1(int mtd_num , struct mtd_dev_info *mtd ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 38 "./include/xalloc.h"
static void *xmalloc(size_t size )  __attribute__((__unused__)) ;
#line 38 "./include/xalloc.h"
static void *xmalloc(size_t size ) 
{ 
  void *ptr ;
  void *tmp ;
  int _err ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 41
  tmp = malloc(size);
#line 41
  ptr = tmp;
  }
#line 43
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 43
    if (size != 0UL) {
      {
#line 44
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 44
        tmp___0 = __errno_location();
#line 44
        _err = *tmp___0;
#line 44
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: out of memory\n",
                "libmtd");
#line 44
        tmp___1 = strerror(_err);
#line 44
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
                (int )sizeof("libmtd") + 1, "", _err, tmp___1);
#line 44
        exit(-1);
        }
#line 44
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 45
  return (ptr);
}
}
#line 48
static void *xcalloc(size_t nmemb , size_t size )  __attribute__((__unused__)) ;
#line 48 "./include/xalloc.h"
static void *xcalloc(size_t nmemb , size_t size ) 
{ 
  void *ptr ;
  void *tmp ;
  int _err ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 51
  tmp = calloc(nmemb, size);
#line 51
  ptr = tmp;
  }
#line 53
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 53
    if (nmemb != 0UL) {
#line 53
      if (size != 0UL) {
        {
#line 54
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 54
          tmp___0 = __errno_location();
#line 54
          _err = *tmp___0;
#line 54
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: out of memory\n",
                  "libmtd");
#line 54
          tmp___1 = strerror(_err);
#line 54
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
                  (int )sizeof("libmtd") + 1, "", _err, tmp___1);
#line 54
          exit(-1);
          }
#line 54
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
  }
#line 55
  return (ptr);
}
}
#line 58
static void *xzalloc(size_t size )  __attribute__((__unused__)) ;
#line 58 "./include/xalloc.h"
static void *xzalloc(size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 61
  tmp = xcalloc((size_t )1, size);
  }
#line 61
  return (tmp);
}
}
#line 50 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static char *mkpath(char const   *path , char const   *name ) 
{ 
  char *n ;
  size_t len1 ;
  size_t tmp ;
  size_t len2 ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 53
  tmp = strlen(path);
#line 53
  len1 = tmp;
#line 54
  tmp___0 = strlen(name);
#line 54
  len2 = tmp___0;
#line 56
  tmp___1 = xmalloc((len1 + len2) + 2UL);
#line 56
  n = (char *)tmp___1;
#line 58
  memcpy((void */* __restrict  */)n, (void const   */* __restrict  */)path, len1);
  }
#line 59
  if ((int )*(n + (len1 - 1UL)) != 47) {
#line 60
    tmp___2 = len1;
#line 60
    len1 ++;
#line 60
    *(n + tmp___2) = (char )'/';
  }
  {
#line 62
  memcpy((void */* __restrict  */)(n + len1), (void const   */* __restrict  */)name,
         len2 + 1UL);
  }
#line 63
  return (n);
}
}
#line 76 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int read_data(char const   *file , void *buf , int buf_len ) 
{ 
  int fd ;
  int rd ;
  int tmp ;
  int tmp1 ;
  ssize_t tmp___0 ;
  int _err ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  ssize_t tmp___4 ;
  int _err___0 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;
  int _err___1 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;

  {
  {
#line 80
  fd = open(file, 524288);
  }
#line 81
  if (fd == -1) {
#line 82
    return (-1);
  }
  {
#line 84
  tmp___0 = read(fd, buf, (size_t )buf_len);
#line 84
  rd = (int )tmp___0;
  }
#line 85
  if (rd == -1) {
    {
#line 86
    tmp___1 = __errno_location();
#line 86
    _err = *tmp___1;
#line 86
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: cannot read \"%s\"\n",
            "libmtd", file);
#line 86
    tmp___2 = strerror(_err);
#line 86
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err, tmp___2);
    }
#line 87
    goto out_error;
  }
#line 90
  if (rd == buf_len) {
    {
#line 91
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: contents of \"%s\" is too long\n",
            "libmtd", file);
#line 92
    tmp___3 = __errno_location();
#line 92
    *tmp___3 = 22;
    }
#line 93
    goto out_error;
  }
  {
#line 96
  *((char *)buf + rd) = (char )'\000';
#line 99
  tmp___4 = read(fd, (void *)(& tmp), (size_t )1);
#line 99
  tmp1 = (int )tmp___4;
  }
#line 100
  if (tmp1 == 1) {
    {
#line 101
    tmp___5 = __errno_location();
#line 101
    _err___0 = *tmp___5;
#line 101
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: cannot read \"%s\"\n",
            "libmtd", file);
#line 101
    tmp___6 = strerror(_err___0);
#line 101
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err___0, tmp___6);
    }
#line 102
    goto out_error;
  }
#line 104
  if (tmp1) {
    {
#line 105
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: file \"%s\" contains too much data (> %d bytes)\n",
            "libmtd", file, buf_len);
#line 107
    tmp___7 = __errno_location();
#line 107
    *tmp___7 = 22;
    }
#line 108
    goto out_error;
  }
  {
#line 111
  tmp___10 = close(fd);
  }
#line 111
  if (tmp___10) {
    {
#line 112
    tmp___8 = __errno_location();
#line 112
    _err___1 = *tmp___8;
#line 112
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: close failed on \"%s\"\n",
            "libmtd", file);
#line 112
    tmp___9 = strerror(_err___1);
#line 112
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err___1, tmp___9);
    }
#line 113
    return (-1);
  }
#line 116
  return (rd);
  out_error: 
  {
#line 119
  close(fd);
  }
#line 120
  return (-1);
}
}
#line 131 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int read_major(char const   *file , int *major , int *minor ) 
{ 
  int ret ;
  char buf[50] ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 136
  ret = read_data(file, (void *)(buf), 50);
  }
#line 137
  if (ret < 0) {
#line 138
    return (ret);
  }
  {
#line 140
  ret = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%d:%d\n",
               major, minor);
  }
#line 141
  if (ret != 2) {
    {
#line 142
    tmp = __errno_location();
#line 142
    *tmp = 22;
#line 143
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: \"%s\" does not have major:minor format\n",
            "libmtd", file);
    }
#line 143
    return (-1);
  }
#line 146
  if (*major < 0) {
    {
#line 147
    tmp___0 = __errno_location();
#line 147
    *tmp___0 = 22;
#line 148
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: bad major:minor %d:%d in \"%s\"\n",
            "libmtd", *major, *minor, file);
    }
#line 148
    return (-1);
  } else
#line 146
  if (*minor < 0) {
    {
#line 147
    tmp___0 = __errno_location();
#line 147
    *tmp___0 = 22;
#line 148
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: bad major:minor %d:%d in \"%s\"\n",
            "libmtd", *major, *minor, file);
    }
#line 148
    return (-1);
  }
#line 152
  return (0);
}
}
#line 164 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int dev_get_major(struct libmtd *lib , int mtd_num , int *major , int *minor ) 
{ 
  size_t tmp ;
  char *file ;
  unsigned long __lengthoffile ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 166
  tmp = strlen((char const   *)lib->mtd_dev);
#line 166
  __lengthoffile = tmp + 50UL;
#line 166
  tmp___0 = __builtin_alloca(sizeof(*file) * __lengthoffile);
#line 166
  file = (char *)tmp___0;
#line 168
  sprintf((char */* __restrict  */)file, (char const   */* __restrict  */)lib->mtd_dev,
          mtd_num);
#line 169
  tmp___1 = read_major((char const   *)file, major, minor);
  }
#line 169
  return (tmp___1);
}
}
#line 182 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int dev_read_data(char const   *patt , int mtd_num , void *buf , int buf_len ) 
{ 
  size_t tmp ;
  char *file ;
  unsigned long __lengthoffile ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 184
  tmp = strlen(patt);
#line 184
  __lengthoffile = tmp + 100UL;
#line 184
  tmp___0 = __builtin_alloca(sizeof(*file) * __lengthoffile);
#line 184
  file = (char *)tmp___0;
#line 186
  sprintf((char */* __restrict  */)file, (char const   */* __restrict  */)patt, mtd_num);
#line 187
  tmp___1 = read_data((char const   *)file, buf, buf_len);
  }
#line 187
  return (tmp___1);
}
}
#line 199 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int read_hex_ll(char const   *file , long long *value ) 
{ 
  int fd ;
  int rd ;
  char buf[50] ;
  ssize_t tmp ;
  int _err ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int _err___0 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;

  {
  {
#line 204
  fd = open(file, 524288);
  }
#line 205
  if (fd == -1) {
#line 206
    return (-1);
  }
  {
#line 208
  tmp = read(fd, (void *)(buf), sizeof(buf));
#line 208
  rd = (int )tmp;
  }
#line 209
  if (rd == -1) {
    {
#line 210
    tmp___0 = __errno_location();
#line 210
    _err = *tmp___0;
#line 210
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: cannot read \"%s\"\n",
            "libmtd", file);
#line 210
    tmp___1 = strerror(_err);
#line 210
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err, tmp___1);
    }
#line 211
    goto out_error;
  }
#line 213
  if ((unsigned long )rd == sizeof(buf)) {
    {
#line 214
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: contents of \"%s\" is too long\n",
            "libmtd", file);
#line 215
    tmp___2 = __errno_location();
#line 215
    *tmp___2 = 22;
    }
#line 216
    goto out_error;
  }
  {
#line 218
  buf[rd] = (char )'\000';
#line 220
  tmp___4 = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%llx\n",
                   value);
  }
#line 220
  if (tmp___4 != 1) {
    {
#line 221
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: cannot read integer from \"%s\"\n\n",
            "libmtd", file);
#line 222
    tmp___3 = __errno_location();
#line 222
    *tmp___3 = 22;
    }
#line 223
    goto out_error;
  }
#line 226
  if (*value < 0LL) {
    {
#line 227
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: negative value %lld in \"%s\"\n",
            "libmtd", *value, file);
#line 228
    tmp___5 = __errno_location();
#line 228
    *tmp___5 = 22;
    }
#line 229
    goto out_error;
  }
  {
#line 232
  tmp___8 = close(fd);
  }
#line 232
  if (tmp___8) {
    {
#line 233
    tmp___6 = __errno_location();
#line 233
    _err___0 = *tmp___6;
#line 233
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: close failed on \"%s\"\n",
            "libmtd", file);
#line 233
    tmp___7 = strerror(_err___0);
#line 233
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err___0, tmp___7);
    }
#line 233
    return (-1);
  }
#line 235
  return (0);
  out_error: 
  {
#line 238
  close(fd);
  }
#line 239
  return (-1);
}
}
#line 251 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int read_pos_ll(char const   *file , long long *value ) 
{ 
  int fd ;
  int rd ;
  char buf[50] ;
  ssize_t tmp ;
  int _err ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int _err___0 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;

  {
  {
#line 256
  fd = open(file, 524288);
  }
#line 257
  if (fd == -1) {
#line 258
    return (-1);
  }
  {
#line 260
  tmp = read(fd, (void *)(buf), (size_t )50);
#line 260
  rd = (int )tmp;
  }
#line 261
  if (rd == -1) {
    {
#line 262
    tmp___0 = __errno_location();
#line 262
    _err = *tmp___0;
#line 262
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: cannot read \"%s\"\n",
            "libmtd", file);
#line 262
    tmp___1 = strerror(_err);
#line 262
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err, tmp___1);
    }
#line 263
    goto out_error;
  }
#line 265
  if (rd == 50) {
    {
#line 266
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: contents of \"%s\" is too long\n",
            "libmtd", file);
#line 267
    tmp___2 = __errno_location();
#line 267
    *tmp___2 = 22;
    }
#line 268
    goto out_error;
  }
  {
#line 271
  tmp___4 = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%lld\n",
                   value);
  }
#line 271
  if (tmp___4 != 1) {
    {
#line 272
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: cannot read integer from \"%s\"\n\n",
            "libmtd", file);
#line 273
    tmp___3 = __errno_location();
#line 273
    *tmp___3 = 22;
    }
#line 274
    goto out_error;
  }
#line 277
  if (*value < 0LL) {
    {
#line 278
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: negative value %lld in \"%s\"\n",
            "libmtd", *value, file);
#line 279
    tmp___5 = __errno_location();
#line 279
    *tmp___5 = 22;
    }
#line 280
    goto out_error;
  }
  {
#line 283
  tmp___8 = close(fd);
  }
#line 283
  if (tmp___8) {
    {
#line 284
    tmp___6 = __errno_location();
#line 284
    _err___0 = *tmp___6;
#line 284
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: close failed on \"%s\"\n",
            "libmtd", file);
#line 284
    tmp___7 = strerror(_err___0);
#line 284
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err___0, tmp___7);
    }
#line 284
    return (-1);
  }
#line 286
  return (0);
  out_error: 
  {
#line 289
  close(fd);
  }
#line 290
  return (-1);
}
}
#line 301 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int read_hex_int(char const   *file , int *value ) 
{ 
  long long res ;
  int tmp ;
  int *tmp___0 ;

  {
  {
#line 305
  tmp = read_hex_ll(file, & res);
  }
#line 305
  if (tmp) {
#line 306
    return (-1);
  }
#line 309
  if (res > 2147483647LL) {
    {
#line 310
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: value %lld read from file \"%s\" is out of range\n",
            "libmtd", res, file);
#line 312
    tmp___0 = __errno_location();
#line 312
    *tmp___0 = 22;
    }
#line 313
    return (-1);
  } else
#line 309
  if (res < (-0x7FFFFFFF-1)) {
    {
#line 310
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: value %lld read from file \"%s\" is out of range\n",
            "libmtd", res, file);
#line 312
    tmp___0 = __errno_location();
#line 312
    *tmp___0 = 22;
    }
#line 313
    return (-1);
  }
#line 316
  *value = (int )res;
#line 317
  return (0);
}
}
#line 328 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int read_pos_int(char const   *file , int *value ) 
{ 
  long long res ;
  int tmp ;
  int *tmp___0 ;

  {
  {
#line 332
  tmp = read_pos_ll(file, & res);
  }
#line 332
  if (tmp) {
#line 333
    return (-1);
  }
#line 336
  if (res > 2147483647LL) {
    {
#line 337
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: value %lld read from file \"%s\" is out of range\n",
            "libmtd", res, file);
#line 339
    tmp___0 = __errno_location();
#line 339
    *tmp___0 = 22;
    }
#line 340
    return (-1);
  }
#line 343
  *value = (int )res;
#line 344
  return (0);
}
}
#line 355 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int dev_read_hex_int(char const   *patt , int mtd_num , int *value ) 
{ 
  size_t tmp ;
  char *file ;
  unsigned long __lengthoffile ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 357
  tmp = strlen(patt);
#line 357
  __lengthoffile = tmp + 50UL;
#line 357
  tmp___0 = __builtin_alloca(sizeof(*file) * __lengthoffile);
#line 357
  file = (char *)tmp___0;
#line 359
  sprintf((char */* __restrict  */)file, (char const   */* __restrict  */)patt, mtd_num);
#line 360
  tmp___1 = read_hex_int((char const   *)file, value);
  }
#line 360
  return (tmp___1);
}
}
#line 371 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int dev_read_pos_int(char const   *patt , int mtd_num , int *value ) 
{ 
  size_t tmp ;
  char *file ;
  unsigned long __lengthoffile ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 373
  tmp = strlen(patt);
#line 373
  __lengthoffile = tmp + 50UL;
#line 373
  tmp___0 = __builtin_alloca(sizeof(*file) * __lengthoffile);
#line 373
  file = (char *)tmp___0;
#line 375
  sprintf((char */* __restrict  */)file, (char const   */* __restrict  */)patt, mtd_num);
#line 376
  tmp___1 = read_pos_int((char const   *)file, value);
  }
#line 376
  return (tmp___1);
}
}
#line 387 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int dev_read_pos_ll(char const   *patt , int mtd_num , long long *value ) 
{ 
  size_t tmp ;
  char *file ;
  unsigned long __lengthoffile ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 389
  tmp = strlen(patt);
#line 389
  __lengthoffile = tmp + 50UL;
#line 389
  tmp___0 = __builtin_alloca(sizeof(*file) * __lengthoffile);
#line 389
  file = (char *)tmp___0;
#line 391
  sprintf((char */* __restrict  */)file, (char const   */* __restrict  */)patt, mtd_num);
#line 392
  tmp___1 = read_pos_ll((char const   *)file, value);
  }
#line 392
  return (tmp___1);
}
}
#line 402 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int type_str2int(char const   *str ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 404
  tmp = strcmp(str, "nand");
  }
#line 404
  if (! tmp) {
#line 405
    return (4);
  }
  {
#line 406
  tmp___0 = strcmp(str, "nor");
  }
#line 406
  if (! tmp___0) {
#line 407
    return (3);
  }
  {
#line 408
  tmp___1 = strcmp(str, "rom");
  }
#line 408
  if (! tmp___1) {
#line 409
    return (2);
  }
  {
#line 410
  tmp___2 = strcmp(str, "absent");
  }
#line 410
  if (! tmp___2) {
#line 411
    return (0);
  }
  {
#line 412
  tmp___3 = strcmp(str, "dataflash");
  }
#line 412
  if (! tmp___3) {
#line 413
    return (6);
  }
  {
#line 414
  tmp___4 = strcmp(str, "ram");
  }
#line 414
  if (! tmp___4) {
#line 415
    return (1);
  }
  {
#line 416
  tmp___5 = strcmp(str, "ubi");
  }
#line 416
  if (! tmp___5) {
#line 417
    return (7);
  }
#line 418
  return (-1);
}
}
#line 429 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int dev_node2num(struct libmtd *lib , char const   *node , int *mtd_num ) 
{ 
  struct stat st ;
  int i ;
  int mjr ;
  int mnr ;
  struct mtd_info info ;
  int _err ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  int tmp___5 ;
  int mjr1 ;
  int mnr1 ;
  int ret ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;

  {
  {
#line 435
  tmp___1 = stat((char const   */* __restrict  */)node, (struct stat */* __restrict  */)(& st));
  }
#line 435
  if (tmp___1) {
    {
#line 436
    tmp = __errno_location();
#line 436
    _err = *tmp;
#line 436
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: cannot get information about \"%s\"\n",
            "libmtd", node);
#line 436
    tmp___0 = strerror(_err);
#line 436
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err, tmp___0);
    }
#line 436
    return (-1);
  }
#line 438
  if (! ((st.st_mode & 61440U) == 8192U)) {
    {
#line 439
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: \"%s\" is not a character device\n",
            "libmtd", node);
#line 440
    tmp___2 = __errno_location();
#line 440
    *tmp___2 = 22;
    }
#line 441
    return (-1);
  }
  {
#line 444
  tmp___3 = gnu_dev_major((unsigned long long )st.st_rdev);
#line 444
  mjr = (int )tmp___3;
#line 445
  tmp___4 = gnu_dev_minor((unsigned long long )st.st_rdev);
#line 445
  mnr = (int )tmp___4;
#line 447
  tmp___5 = mtd_get_info((libmtd_t )((libmtd_t *)lib), & info);
  }
#line 447
  if (tmp___5) {
#line 448
    return (-1);
  }
#line 450
  i = info.lowest_mtd_num;
  {
#line 450
  while (1) {
    while_continue: /* CIL Label */ ;
#line 450
    if (! (i <= info.highest_mtd_num)) {
#line 450
      goto while_break;
    }
    {
#line 453
    ret = dev_get_major(lib, i, & mjr1, & mnr1);
    }
#line 454
    if (ret) {
      {
#line 455
      tmp___6 = __errno_location();
      }
#line 455
      if (*tmp___6 == 2) {
#line 456
        goto __Cont;
      }
      {
#line 457
      tmp___7 = __errno_location();
      }
#line 457
      if (! *tmp___7) {
#line 458
        goto while_break;
      }
#line 459
      return (-1);
    }
#line 462
    if (mjr1 == mjr) {
#line 462
      if (mnr1 == mnr) {
        {
#line 463
        tmp___8 = __errno_location();
#line 463
        *tmp___8 = 0;
#line 464
        *mtd_num = i;
        }
#line 465
        return (0);
      }
    }
    __Cont: /* CIL Label */ 
#line 450
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 469
  tmp___9 = __errno_location();
#line 469
  *tmp___9 = 19;
  }
#line 470
  return (-1);
}
}
#line 489 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int sysfs_is_supported(struct libmtd *lib ) 
{ 
  int fd ;
  int num ;
  DIR *sysfs_mtd ;
  size_t tmp ;
  char *file ;
  unsigned long __lengthoffile ;
  void *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int _err ;
  int *tmp___3 ;
  char *tmp___4 ;
  int ret ;
  int mtd_num ;
  char tmp_buf[256] ;
  struct dirent *dirent ;
  int *tmp___5 ;
  size_t tmp___6 ;
  int _err___0 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int _err___1 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;

  {
  {
#line 491
  num = -1;
#line 493
  tmp = strlen((char const   *)lib->mtd_name);
#line 493
  __lengthoffile = tmp + 10UL;
#line 493
  tmp___0 = __builtin_alloca(sizeof(*file) * __lengthoffile);
#line 493
  file = (char *)tmp___0;
#line 495
  sysfs_mtd = opendir((char const   *)lib->sysfs_mtd);
  }
#line 496
  if (! sysfs_mtd) {
    {
#line 497
    tmp___2 = __errno_location();
    }
#line 497
    if (*tmp___2 == 2) {
      {
#line 498
      tmp___1 = __errno_location();
#line 498
      *tmp___1 = 0;
      }
#line 499
      return (0);
    }
    {
#line 501
    tmp___3 = __errno_location();
#line 501
    _err = *tmp___3;
#line 501
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: cannot open \"%s\"\n",
            "libmtd", lib->sysfs_mtd);
#line 501
    tmp___4 = strerror(_err);
#line 501
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err, tmp___4);
    }
#line 501
    return (-1);
  }
  {
#line 508
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 513
    dirent = readdir(sysfs_mtd);
    }
#line 514
    if (! dirent) {
#line 515
      goto while_break;
    }
    {
#line 517
    tmp___6 = strlen((char const   *)(dirent->d_name));
    }
#line 517
    if (tmp___6 >= 255UL) {
      {
#line 518
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: invalid entry in %s: \"%s\"\n",
              "libmtd", lib->sysfs_mtd, dirent->d_name);
#line 520
      tmp___5 = __errno_location();
#line 520
      *tmp___5 = 22;
#line 521
      closedir(sysfs_mtd);
      }
#line 522
      return (-1);
    }
    {
#line 525
    ret = sscanf((char const   */* __restrict  */)(dirent->d_name), (char const   */* __restrict  */)"mtd%d%s",
                 & mtd_num, tmp_buf);
    }
#line 527
    if (ret == 1) {
#line 528
      num = mtd_num;
#line 529
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 533
  tmp___9 = closedir(sysfs_mtd);
  }
#line 533
  if (tmp___9) {
    {
#line 534
    tmp___7 = __errno_location();
#line 534
    _err___0 = *tmp___7;
#line 534
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: closedir failed on \"%s\"\n",
            "libmtd", lib->sysfs_mtd);
#line 534
    tmp___8 = strerror(_err___0);
#line 534
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err___0, tmp___8);
    }
#line 534
    return (-1);
  }
#line 536
  if (num == -1) {
#line 538
    return (0);
  }
  {
#line 540
  sprintf((char */* __restrict  */)file, (char const   */* __restrict  */)lib->mtd_name,
          num);
#line 541
  fd = open((char const   *)file, 524288);
  }
#line 542
  if (fd == -1) {
#line 543
    return (0);
  }
  {
#line 545
  tmp___12 = close(fd);
  }
#line 545
  if (tmp___12) {
    {
#line 546
    tmp___10 = __errno_location();
#line 546
    _err___1 = *tmp___10;
#line 546
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: close failed on \"%s\"\n",
            "libmtd", file);
#line 546
    tmp___11 = strerror(_err___1);
#line 546
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err___1, tmp___11);
    }
#line 547
    return (-1);
  }
#line 550
  return (1);
}
}
#line 553 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
libmtd_t libmtd_open(void) 
{ 
  struct libmtd *lib ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 557
  tmp = xzalloc(sizeof(*lib));
#line 557
  lib = (struct libmtd *)tmp;
#line 559
  lib->offs64_ioctls = 0U;
#line 561
  lib->sysfs_mtd = mkpath("/sys", "class/mtd");
  }
#line 562
  if (! lib->sysfs_mtd) {
#line 563
    goto out_error;
  }
  {
#line 565
  lib->mtd = mkpath((char const   *)lib->sysfs_mtd, "mtd%d");
  }
#line 566
  if (! lib->mtd) {
#line 567
    goto out_error;
  }
  {
#line 569
  lib->mtd_name = mkpath((char const   *)lib->mtd, "name");
  }
#line 570
  if (! lib->mtd_name) {
#line 571
    goto out_error;
  }
  {
#line 573
  tmp___2 = sysfs_is_supported(lib);
  }
#line 573
  if (! tmp___2) {
    {
#line 574
    free((void *)lib->mtd);
#line 575
    free((void *)lib->sysfs_mtd);
#line 576
    free((void *)lib->mtd_name);
#line 577
    tmp___1 = (char *)((void *)0);
#line 577
    lib->sysfs_mtd = tmp___1;
#line 577
    tmp___0 = tmp___1;
#line 577
    lib->mtd = tmp___0;
#line 577
    lib->mtd_name = tmp___0;
    }
#line 578
    return ((libmtd_t )lib);
  }
  {
#line 581
  lib->mtd_dev = mkpath((char const   *)lib->mtd, "dev");
  }
#line 582
  if (! lib->mtd_dev) {
#line 583
    goto out_error;
  }
  {
#line 585
  lib->mtd_type = mkpath((char const   *)lib->mtd, "type");
  }
#line 586
  if (! lib->mtd_type) {
#line 587
    goto out_error;
  }
  {
#line 589
  lib->mtd_eb_size = mkpath((char const   *)lib->mtd, "erasesize");
  }
#line 590
  if (! lib->mtd_eb_size) {
#line 591
    goto out_error;
  }
  {
#line 593
  lib->mtd_size = mkpath((char const   *)lib->mtd, "size");
  }
#line 594
  if (! lib->mtd_size) {
#line 595
    goto out_error;
  }
  {
#line 597
  lib->mtd_min_io_size = mkpath((char const   *)lib->mtd, "writesize");
  }
#line 598
  if (! lib->mtd_min_io_size) {
#line 599
    goto out_error;
  }
  {
#line 601
  lib->mtd_subpage_size = mkpath((char const   *)lib->mtd, "subpagesize");
  }
#line 602
  if (! lib->mtd_subpage_size) {
#line 603
    goto out_error;
  }
  {
#line 605
  lib->mtd_oob_size = mkpath((char const   *)lib->mtd, "oobsize");
  }
#line 606
  if (! lib->mtd_oob_size) {
#line 607
    goto out_error;
  }
  {
#line 609
  lib->mtd_region_cnt = mkpath((char const   *)lib->mtd, "numeraseregions");
  }
#line 610
  if (! lib->mtd_region_cnt) {
#line 611
    goto out_error;
  }
  {
#line 613
  lib->mtd_flags = mkpath((char const   *)lib->mtd, "flags");
  }
#line 614
  if (! lib->mtd_flags) {
#line 615
    goto out_error;
  }
#line 617
  lib->sysfs_supported = 1U;
#line 618
  return ((libmtd_t )lib);
  out_error: 
  {
#line 621
  libmtd_close((libmtd_t )lib);
  }
#line 622
  return ((void *)0);
}
}
#line 625 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
void libmtd_close(libmtd_t desc ) 
{ 
  struct libmtd *lib ;

  {
  {
#line 627
  lib = (struct libmtd *)desc;
#line 629
  free((void *)lib->mtd_flags);
#line 630
  free((void *)lib->mtd_region_cnt);
#line 631
  free((void *)lib->mtd_oob_size);
#line 632
  free((void *)lib->mtd_subpage_size);
#line 633
  free((void *)lib->mtd_min_io_size);
#line 634
  free((void *)lib->mtd_size);
#line 635
  free((void *)lib->mtd_eb_size);
#line 636
  free((void *)lib->mtd_type);
#line 637
  free((void *)lib->mtd_dev);
#line 638
  free((void *)lib->mtd_name);
#line 639
  free((void *)lib->mtd);
#line 640
  free((void *)lib->sysfs_mtd);
#line 641
  free((void *)lib);
  }
#line 642
  return;
}
}
#line 644 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
int mtd_dev_present(libmtd_t desc , int mtd_num ) 
{ 
  struct stat st ;
  struct libmtd *lib ;
  int tmp ;
  size_t tmp___0 ;
  char *file ;
  unsigned long __lengthoffile ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 646
  lib = (struct libmtd *)desc;
#line 648
  if (! lib->sysfs_supported) {
    {
#line 649
    tmp = legacy_dev_present(mtd_num);
    }
#line 649
    return (tmp);
  } else {
    {
#line 651
    tmp___0 = strlen((char const   *)lib->mtd);
#line 651
    __lengthoffile = tmp___0 + 10UL;
#line 651
    tmp___1 = __builtin_alloca(sizeof(*file) * __lengthoffile);
#line 651
    file = (char *)tmp___1;
#line 653
    sprintf((char */* __restrict  */)file, (char const   */* __restrict  */)lib->mtd,
            mtd_num);
#line 654
    tmp___2 = stat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& st));
    }
#line 654
    if (tmp___2) {
#line 654
      tmp___3 = 0;
    } else {
#line 654
      tmp___3 = 1;
    }
#line 654
    return (tmp___3);
  }
}
}
#line 658 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
int mtd_get_info(libmtd_t desc , struct mtd_info *info ) 
{ 
  DIR *sysfs_mtd ;
  struct dirent *dirent ;
  struct libmtd *lib ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int _err ;
  int *tmp___2 ;
  char *tmp___3 ;
  int mtd_num ;
  int ret ;
  char tmp_buf[256] ;
  int *tmp___4 ;
  int *tmp___5 ;
  size_t tmp___6 ;
  int _err___0 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int *tmp___9 ;
  int _err___1 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;

  {
  {
#line 662
  lib = (struct libmtd *)desc;
#line 664
  memset((void *)info, 0, sizeof(struct mtd_info ));
  }
#line 666
  if (! lib->sysfs_supported) {
    {
#line 667
    tmp = legacy_mtd_get_info(info);
    }
#line 667
    return (tmp);
  }
  {
#line 669
  info->sysfs_supported = 1U;
#line 675
  sysfs_mtd = opendir((char const   *)lib->sysfs_mtd);
  }
#line 676
  if (! sysfs_mtd) {
    {
#line 677
    tmp___1 = __errno_location();
    }
#line 677
    if (*tmp___1 == 2) {
      {
#line 678
      tmp___0 = __errno_location();
#line 678
      *tmp___0 = 19;
      }
#line 679
      return (-1);
    }
    {
#line 681
    tmp___2 = __errno_location();
#line 681
    _err = *tmp___2;
#line 681
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: cannot open \"%s\"\n",
            "libmtd", lib->sysfs_mtd);
#line 681
    tmp___3 = strerror(_err);
#line 681
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err, tmp___3);
    }
#line 681
    return (-1);
  }
#line 684
  info->lowest_mtd_num = 2147483647;
  {
#line 685
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 689
    tmp___4 = __errno_location();
#line 689
    *tmp___4 = 0;
#line 690
    dirent = readdir(sysfs_mtd);
    }
#line 691
    if (! dirent) {
#line 692
      goto while_break;
    }
    {
#line 694
    tmp___6 = strlen((char const   *)(dirent->d_name));
    }
#line 694
    if (tmp___6 >= 255UL) {
      {
#line 695
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: invalid entry in %s: \"%s\"\n",
              "libmtd", lib->sysfs_mtd, dirent->d_name);
#line 697
      tmp___5 = __errno_location();
#line 697
      *tmp___5 = 22;
      }
#line 698
      goto out_close;
    }
    {
#line 701
    ret = sscanf((char const   */* __restrict  */)(dirent->d_name), (char const   */* __restrict  */)"mtd%d%s",
                 & mtd_num, tmp_buf);
    }
#line 703
    if (ret == 1) {
#line 704
      (info->mtd_dev_cnt) ++;
#line 705
      if (mtd_num > info->highest_mtd_num) {
#line 706
        info->highest_mtd_num = mtd_num;
      }
#line 707
      if (mtd_num < info->lowest_mtd_num) {
#line 708
        info->lowest_mtd_num = mtd_num;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 712
  if (! dirent) {
    {
#line 712
    tmp___9 = __errno_location();
    }
#line 712
    if (*tmp___9) {
      {
#line 713
      tmp___7 = __errno_location();
#line 713
      _err___0 = *tmp___7;
#line 713
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: readdir failed on \"%s\"\n",
              "libmtd", lib->sysfs_mtd);
#line 713
      tmp___8 = strerror(_err___0);
#line 713
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
              (int )sizeof("libmtd") + 1, "", _err___0, tmp___8);
      }
#line 714
      goto out_close;
    }
  }
  {
#line 717
  tmp___12 = closedir(sysfs_mtd);
  }
#line 717
  if (tmp___12) {
    {
#line 718
    tmp___10 = __errno_location();
#line 718
    _err___1 = *tmp___10;
#line 718
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: closedir failed on \"%s\"\n",
            "libmtd", lib->sysfs_mtd);
#line 718
    tmp___11 = strerror(_err___1);
#line 718
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err___1, tmp___11);
    }
#line 718
    return (-1);
  }
#line 720
  if (info->lowest_mtd_num == 2147483647) {
#line 721
    info->lowest_mtd_num = 0;
  }
#line 723
  return (0);
  out_close: 
  {
#line 726
  closedir(sysfs_mtd);
  }
#line 727
  return (-1);
}
}
#line 730 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
int mtd_get_dev_info1(libmtd_t desc , int mtd_num , struct mtd_dev_info *mtd ) 
{ 
  int ret ;
  struct libmtd *lib ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 733
  lib = (struct libmtd *)desc;
#line 735
  memset((void *)mtd, 0, sizeof(struct mtd_dev_info ));
#line 736
  mtd->mtd_num = mtd_num;
#line 738
  tmp___1 = mtd_dev_present(desc, mtd_num);
  }
#line 738
  if (tmp___1) {
#line 741
    if (! lib->sysfs_supported) {
      {
#line 742
      tmp___0 = legacy_get_dev_info1(mtd_num, mtd);
      }
#line 742
      return (tmp___0);
    }
  } else {
    {
#line 739
    tmp = __errno_location();
#line 739
    *tmp = 19;
    }
#line 740
    return (-1);
  }
  {
#line 744
  tmp___2 = dev_get_major(lib, mtd_num, & mtd->major, & mtd->minor);
  }
#line 744
  if (tmp___2) {
#line 745
    return (-1);
  }
  {
#line 747
  ret = dev_read_data((char const   *)lib->mtd_name, mtd_num, (void *)(& mtd->name),
                      128);
  }
#line 749
  if (ret < 0) {
#line 750
    return (-1);
  }
  {
#line 751
  *((char *)(mtd->name) + (ret - 1)) = (char )'\000';
#line 753
  ret = dev_read_data((char const   *)lib->mtd_type, mtd_num, (void *)(& mtd->type_str),
                      65);
  }
#line 755
  if (ret < 0) {
#line 756
    return (-1);
  }
  {
#line 757
  *((char *)(mtd->type_str) + (ret - 1)) = (char )'\000';
#line 759
  tmp___3 = dev_read_pos_int((char const   *)lib->mtd_eb_size, mtd_num, & mtd->eb_size);
  }
#line 759
  if (tmp___3) {
#line 760
    return (-1);
  }
  {
#line 761
  tmp___4 = dev_read_pos_ll((char const   *)lib->mtd_size, mtd_num, & mtd->size);
  }
#line 761
  if (tmp___4) {
#line 762
    return (-1);
  }
  {
#line 763
  tmp___5 = dev_read_pos_int((char const   *)lib->mtd_min_io_size, mtd_num, & mtd->min_io_size);
  }
#line 763
  if (tmp___5) {
#line 764
    return (-1);
  }
  {
#line 765
  tmp___6 = dev_read_pos_int((char const   *)lib->mtd_subpage_size, mtd_num, & mtd->subpage_size);
  }
#line 765
  if (tmp___6) {
#line 766
    return (-1);
  }
  {
#line 767
  tmp___7 = dev_read_pos_int((char const   *)lib->mtd_oob_size, mtd_num, & mtd->oob_size);
  }
#line 767
  if (tmp___7) {
#line 768
    return (-1);
  }
  {
#line 769
  tmp___8 = dev_read_pos_int((char const   *)lib->mtd_region_cnt, mtd_num, & mtd->region_cnt);
  }
#line 769
  if (tmp___8) {
#line 770
    return (-1);
  }
  {
#line 771
  tmp___9 = dev_read_hex_int((char const   *)lib->mtd_flags, mtd_num, & ret);
  }
#line 771
  if (tmp___9) {
#line 772
    return (-1);
  }
  {
#line 773
  mtd->writable = (unsigned int )(! (! (ret & 1024)));
#line 775
  mtd->eb_cnt = (int )(mtd->size / (long long )mtd->eb_size);
#line 776
  mtd->type = type_str2int(mtd->type_str);
#line 777
  mtd->bb_allowed = (unsigned int )(! (! (mtd->type == 4)));
  }
#line 779
  return (0);
}
}
#line 782 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
int mtd_get_dev_info(libmtd_t desc , char const   *node , struct mtd_dev_info *mtd ) 
{ 
  int mtd_num ;
  struct libmtd *lib ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 785
  lib = (struct libmtd *)desc;
#line 787
  if (! lib->sysfs_supported) {
    {
#line 788
    tmp = legacy_get_dev_info(node, mtd);
    }
#line 788
    return (tmp);
  }
  {
#line 790
  tmp___0 = dev_node2num(lib, node, & mtd_num);
  }
#line 790
  if (tmp___0) {
#line 791
    return (-1);
  }
  {
#line 793
  tmp___1 = mtd_get_dev_info1(desc, mtd_num, mtd);
  }
#line 793
  return (tmp___1);
}
}
#line 796 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
__inline static int mtd_ioctl_error(struct mtd_dev_info  const  *mtd , int eb , char const   *sreq ) 
{ 
  int _err ;
  int *tmp ;
  char *tmp___0 ;

  {
  {
#line 799
  tmp = __errno_location();
#line 799
  _err = *tmp;
#line 799
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: %s ioctl failed for eraseblock %d (mtd%d)\n",
          "libmtd", sreq, eb, mtd->mtd_num);
#line 799
  tmp___0 = strerror(_err);
#line 799
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
          (int )sizeof("libmtd") + 1, "", _err, tmp___0);
  }
#line 799
  return (-1);
}
}
#line 803 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int mtd_valid_erase_block(struct mtd_dev_info  const  *mtd , int eb ) 
{ 
  int *tmp ;

  {
#line 805
  if (eb < 0) {
    {
#line 806
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: bad eraseblock number %d, mtd%d has %d eraseblocks\n",
            "libmtd", eb, mtd->mtd_num, mtd->eb_cnt);
#line 808
    tmp = __errno_location();
#line 808
    *tmp = 22;
    }
#line 809
    return (-1);
  } else
#line 805
  if (eb >= (int )mtd->eb_cnt) {
    {
#line 806
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: bad eraseblock number %d, mtd%d has %d eraseblocks\n",
            "libmtd", eb, mtd->mtd_num, mtd->eb_cnt);
#line 808
    tmp = __errno_location();
#line 808
    *tmp = 22;
    }
#line 809
    return (-1);
  }
#line 811
  return (0);
}
}
#line 814 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int mtd_xlock(struct mtd_dev_info  const  *mtd , int fd , int eb , int req ,
                     char const   *sreq ) 
{ 
  int ret ;
  struct erase_info_user ei ;
  int tmp ;

  {
  {
#line 820
  ret = mtd_valid_erase_block(mtd, eb);
  }
#line 821
  if (ret) {
#line 822
    return (ret);
  }
  {
#line 824
  ei.start = (__u32 )(eb * (int )mtd->eb_size);
#line 825
  ei.length = (__u32 )mtd->eb_size;
#line 827
  ret = ioctl(fd, (unsigned long )req, & ei);
  }
#line 828
  if (ret < 0) {
    {
#line 829
    tmp = mtd_ioctl_error(mtd, eb, sreq);
    }
#line 829
    return (tmp);
  }
#line 831
  return (0);
}
}
#line 835 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
int mtd_lock(struct mtd_dev_info  const  *mtd , int fd , int eb ) 
{ 
  int tmp ;

  {
  {
#line 837
  tmp = mtd_xlock(mtd, fd, eb, (int )((unsigned long )(((1U << 30) | (unsigned int )(77 << 8)) | 5U) | (sizeof(struct erase_info_user ) << 16)),
                  "MEMLOCK");
  }
#line 837
  return (tmp);
}
}
#line 840 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
int mtd_unlock(struct mtd_dev_info  const  *mtd , int fd , int eb ) 
{ 
  int tmp ;

  {
  {
#line 842
  tmp = mtd_xlock(mtd, fd, eb, (int )((unsigned long )(((1U << 30) | (unsigned int )(77 << 8)) | 6U) | (sizeof(struct erase_info_user ) << 16)),
                  "MEMUNLOCK");
  }
#line 842
  return (tmp);
}
}
#line 845 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
int mtd_erase(libmtd_t desc , struct mtd_dev_info  const  *mtd , int fd , int eb ) 
{ 
  int ret ;
  struct libmtd *lib ;
  struct erase_info_user64 ei64 ;
  struct erase_info_user ei ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 848
  lib = (struct libmtd *)desc;
#line 852
  ret = mtd_valid_erase_block(mtd, eb);
  }
#line 853
  if (ret) {
#line 854
    return (ret);
  }
#line 856
  ei64.start = (__u64 )eb * (__u64 )mtd->eb_size;
#line 857
  ei64.length = (__u64 )mtd->eb_size;
#line 859
  if (lib->offs64_ioctls == 2U) {
#line 859
    goto _L;
  } else
#line 859
  if (lib->offs64_ioctls == 0U) {
    _L: /* CIL Label */ 
    {
#line 861
    ret = ioctl(fd, (unsigned long )(((1U << 30) | (unsigned int )(77 << 8)) | 20U) | (sizeof(struct erase_info_user64 ) << 16),
                & ei64);
    }
#line 862
    if (ret == 0) {
#line 863
      return (ret);
    }
    {
#line 865
    tmp___0 = __errno_location();
    }
#line 865
    if (*tmp___0 != 25) {
      {
#line 867
      tmp = mtd_ioctl_error(mtd, eb, "MEMERASE64");
      }
#line 867
      return (tmp);
    } else
#line 865
    if (lib->offs64_ioctls != 0U) {
      {
#line 867
      tmp = mtd_ioctl_error(mtd, eb, "MEMERASE64");
      }
#line 867
      return (tmp);
    }
#line 874
    lib->offs64_ioctls = 1U;
  }
#line 877
  if (ei64.start + ei64.length > 4294967295ULL) {
    {
#line 878
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: this system can address only %u eraseblocks\n",
            "libmtd", 4294967295U / (unsigned int )mtd->eb_size);
#line 880
    tmp___1 = __errno_location();
#line 880
    *tmp___1 = 22;
    }
#line 881
    return (-1);
  }
  {
#line 884
  ei.start = (__u32 )ei64.start;
#line 885
  ei.length = (__u32 )ei64.length;
#line 886
  ret = ioctl(fd, (unsigned long )(((1U << 30) | (unsigned int )(77 << 8)) | 2U) | (sizeof(struct erase_info_user ) << 16),
              & ei);
  }
#line 887
  if (ret < 0) {
    {
#line 888
    tmp___2 = mtd_ioctl_error(mtd, eb, "MEMERASE");
    }
#line 888
    return (tmp___2);
  }
#line 889
  return (0);
}
}
#line 892 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
int mtd_regioninfo(int fd , int regidx , struct region_info_user *reginfo ) 
{ 
  int ret ;
  int *tmp ;
  int _err ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
#line 896
  if (regidx < 0) {
    {
#line 897
    tmp = __errno_location();
#line 897
    *tmp = 19;
    }
#line 898
    return (-1);
  }
  {
#line 901
  ret = ioctl(fd, (unsigned long )(((3U << 30) | (unsigned int )(77 << 8)) | 8U) | (sizeof(struct region_info_user ) << 16),
              reginfo);
  }
#line 902
  if (ret < 0) {
    {
#line 903
    tmp___0 = __errno_location();
#line 903
    _err = *tmp___0;
#line 903
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: %s ioctl failed for erase region %d\n",
            "libmtd", "MEMGETREGIONINFO", regidx);
#line 903
    tmp___1 = strerror(_err);
#line 903
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err, tmp___1);
    }
#line 903
    return (-1);
  }
#line 906
  return (0);
}
}
#line 909 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
int mtd_is_locked(struct mtd_dev_info  const  *mtd , int fd , int eb ) 
{ 
  int ret ;
  erase_info_t ei ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 914
  ei.start = (__u32 )(eb * (int )mtd->eb_size);
#line 915
  ei.length = (__u32 )mtd->eb_size;
#line 917
  ret = ioctl(fd, (unsigned long )(((2U << 30) | (unsigned int )(77 << 8)) | 23U) | (sizeof(struct erase_info_user ) << 16),
              & ei);
  }
#line 918
  if (ret < 0) {
    {
#line 919
    tmp___1 = __errno_location();
    }
#line 919
    if (*tmp___1 != 25) {
      {
#line 919
      tmp___2 = __errno_location();
      }
#line 919
      if (*tmp___2 != 95) {
        {
#line 920
        tmp = mtd_ioctl_error(mtd, eb, "MEMISLOCKED");
        }
#line 920
        return (tmp);
      } else {
        {
#line 922
        tmp___0 = __errno_location();
#line 922
        *tmp___0 = 95;
        }
      }
    } else {
      {
#line 922
      tmp___0 = __errno_location();
#line 922
      *tmp___0 = 95;
      }
    }
  }
#line 925
  return (ret);
}
}
#line 929 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static uint8_t patterns[3]  = {      (uint8_t )165,      (uint8_t )90,      (uint8_t )0};
#line 940 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int check_pattern(void const   *buf , uint8_t patt , int size ) 
{ 
  int i ;

  {
#line 944
  i = 0;
  {
#line 944
  while (1) {
    while_continue: /* CIL Label */ ;
#line 944
    if (! (i < size)) {
#line 944
      goto while_break;
    }
#line 945
    if ((int const   )*((uint8_t const   *)buf + i) != (int const   )patt) {
#line 946
      return (0);
    }
#line 944
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 947
  return (1);
}
}
#line 950 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
int mtd_torture(libmtd_t desc , struct mtd_dev_info  const  *mtd , int fd , int eb ) 
{ 
  int err ;
  int i ;
  int patt_count ;
  void *buf ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 955
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 955
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 955
      printf((char const   */* __restrict  */)"%s: run torture test for PEB %d\n",
             "libmtd", eb);
      }
#line 955
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 955
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 956
  patt_count = (int )(sizeof(patterns) / sizeof(patterns[0]));
#line 958
  buf = xmalloc((size_t )mtd->eb_size);
#line 960
  i = 0;
  }
  {
#line 960
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 960
    if (! (i < patt_count)) {
#line 960
      goto while_break___1;
    }
    {
#line 961
    err = mtd_erase(desc, mtd, fd, eb);
    }
#line 962
    if (err) {
#line 963
      goto out;
    }
    {
#line 966
    err = mtd_read(mtd, fd, eb, 0, buf, (int )mtd->eb_size);
    }
#line 967
    if (err) {
#line 968
      goto out;
    }
    {
#line 970
    err = check_pattern((void const   *)buf, (uint8_t )255, (int )mtd->eb_size);
    }
#line 971
    if (err == 0) {
      {
#line 972
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: erased PEB %d, but a non-0xFF byte found\n",
              "libmtd", eb);
#line 973
      tmp = __errno_location();
#line 973
      *tmp = 5;
      }
#line 974
      goto out;
    }
    {
#line 978
    memset(buf, (int )patterns[i], (size_t )mtd->eb_size);
#line 979
    err = mtd_write(desc, mtd, fd, eb, 0, buf, (int )mtd->eb_size, (void *)0, 0, (uint8_t )0);
    }
#line 981
    if (err) {
#line 982
      goto out;
    }
    {
#line 984
    memset(buf, ~ ((int )patterns[i]), (size_t )mtd->eb_size);
#line 985
    err = mtd_read(mtd, fd, eb, 0, buf, (int )mtd->eb_size);
    }
#line 986
    if (err) {
#line 987
      goto out;
    }
    {
#line 989
    err = check_pattern((void const   *)buf, patterns[i], (int )mtd->eb_size);
    }
#line 990
    if (err == 0) {
      {
#line 991
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: pattern %x checking failed for PEB %d\n",
              "libmtd", (int )patterns[i], eb);
#line 993
      tmp___0 = __errno_location();
#line 993
      *tmp___0 = 5;
      }
#line 994
      goto out;
    }
#line 960
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 998
  err = 0;
  {
#line 999
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 999
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 999
      printf((char const   */* __restrict  */)"%s: PEB %d passed torture test, do not mark it a bad\n",
             "libmtd", eb);
      }
#line 999
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 999
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  out: 
  {
#line 1002
  free(buf);
  }
#line 1003
  return (-1);
}
}
#line 1006 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
int mtd_is_bad(struct mtd_dev_info  const  *mtd , int fd , int eb ) 
{ 
  int ret ;
  loff_t seek ;
  int tmp ;

  {
  {
#line 1011
  ret = mtd_valid_erase_block(mtd, eb);
  }
#line 1012
  if (ret) {
#line 1013
    return (ret);
  }
#line 1015
  if (! mtd->bb_allowed) {
#line 1016
    return (0);
  }
  {
#line 1018
  seek = (loff_t )eb * (loff_t )mtd->eb_size;
#line 1019
  ret = ioctl(fd, (unsigned long )(((1U << 30) | (unsigned int )(77 << 8)) | 11U) | (sizeof(__kernel_loff_t ) << 16),
              & seek);
  }
#line 1020
  if (ret == -1) {
    {
#line 1021
    tmp = mtd_ioctl_error(mtd, eb, "MEMGETBADBLOCK");
    }
#line 1021
    return (tmp);
  }
#line 1022
  return (ret);
}
}
#line 1025 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
int mtd_mark_bad(struct mtd_dev_info  const  *mtd , int fd , int eb ) 
{ 
  int ret ;
  loff_t seek ;
  int *tmp ;
  int tmp___0 ;

  {
#line 1030
  if (! mtd->bb_allowed) {
    {
#line 1031
    tmp = __errno_location();
#line 1031
    *tmp = 22;
    }
#line 1032
    return (-1);
  }
  {
#line 1035
  ret = mtd_valid_erase_block(mtd, eb);
  }
#line 1036
  if (ret) {
#line 1037
    return (ret);
  }
  {
#line 1039
  seek = (loff_t )eb * (loff_t )mtd->eb_size;
#line 1040
  ret = ioctl(fd, (unsigned long )(((1U << 30) | (unsigned int )(77 << 8)) | 12U) | (sizeof(__kernel_loff_t ) << 16),
              & seek);
  }
#line 1041
  if (ret == -1) {
    {
#line 1042
    tmp___0 = mtd_ioctl_error(mtd, eb, "MEMSETBADBLOCK");
    }
#line 1042
    return (tmp___0);
  }
#line 1043
  return (0);
}
}
#line 1046 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
int mtd_read(struct mtd_dev_info  const  *mtd , int fd , int eb , int offs , void *buf ,
             int len ) 
{ 
  int ret ;
  int rd ;
  off_t seek ;
  int *tmp ;
  int _err ;
  int *tmp___0 ;
  char *tmp___1 ;
  __off64_t tmp___2 ;
  ssize_t tmp___3 ;
  int _err___0 ;
  int *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 1049
  rd = 0;
#line 1052
  ret = mtd_valid_erase_block(mtd, eb);
  }
#line 1053
  if (ret) {
#line 1054
    return (ret);
  }
#line 1056
  if (offs < 0) {
    {
#line 1057
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: bad offset %d or length %d, mtd%d eraseblock size is %d\n",
            "libmtd", offs, len, mtd->mtd_num, mtd->eb_size);
#line 1059
    tmp = __errno_location();
#line 1059
    *tmp = 22;
    }
#line 1060
    return (-1);
  } else
#line 1056
  if (offs + len > (int )mtd->eb_size) {
    {
#line 1057
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: bad offset %d or length %d, mtd%d eraseblock size is %d\n",
            "libmtd", offs, len, mtd->mtd_num, mtd->eb_size);
#line 1059
    tmp = __errno_location();
#line 1059
    *tmp = 22;
    }
#line 1060
    return (-1);
  }
  {
#line 1064
  seek = (off_t )eb * (off_t )mtd->eb_size + (off_t )offs;
#line 1065
  tmp___2 = lseek(fd, seek, 0);
  }
#line 1065
  if (tmp___2 != seek) {
    {
#line 1066
    tmp___0 = __errno_location();
#line 1066
    _err = *tmp___0;
#line 1066
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: cannot seek mtd%d to offset %llu\n",
            "libmtd", mtd->mtd_num, (unsigned long long )seek);
#line 1066
    tmp___1 = strerror(_err);
#line 1066
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err, tmp___1);
    }
#line 1066
    return (-1);
  }
  {
#line 1069
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1069
    if (! (rd < len)) {
#line 1069
      goto while_break;
    }
    {
#line 1070
    tmp___3 = read(fd, buf, (size_t )len);
#line 1070
    ret = (int )tmp___3;
    }
#line 1071
    if (ret < 0) {
      {
#line 1072
      tmp___4 = __errno_location();
#line 1072
      _err___0 = *tmp___4;
#line 1072
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: cannot read %d bytes from mtd%d (eraseblock %d, offset %d)\n",
              "libmtd", len, mtd->mtd_num, eb, offs);
#line 1072
      tmp___5 = strerror(_err___0);
#line 1072
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
              (int )sizeof("libmtd") + 1, "", _err___0, tmp___5);
      }
#line 1072
      return (-1);
    }
#line 1074
    rd += ret;
  }
  while_break: /* CIL Label */ ;
  }
#line 1077
  return (0);
}
}
#line 1080 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int legacy_auto_oob_layout(struct mtd_dev_info  const  *mtd , int fd , int ooblen ,
                                  void *oob ) 
{ 
  struct nand_oobinfo old_oobinfo ;
  int start ;
  int len ;
  uint8_t *tmp_buf ;
  int _err ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int i ;
  int tags_pos ;

  {
  {
#line 1087
  tmp___1 = ioctl(fd, (unsigned long )(((2U << 30) | (unsigned int )(77 << 8)) | 10U) | (sizeof(struct nand_oobinfo ) << 16),
                  & old_oobinfo);
  }
#line 1087
  if (tmp___1) {
    {
#line 1088
    tmp = __errno_location();
#line 1088
    _err = *tmp;
#line 1088
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: MEMGETOOBSEL failed\n",
            "libmtd");
#line 1088
    tmp___0 = strerror(_err);
#line 1088
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err, tmp___0);
    }
#line 1088
    return (-1);
  }
  {
#line 1090
  tmp___2 = malloc((size_t )ooblen);
#line 1090
  tmp_buf = (uint8_t *)tmp___2;
#line 1091
  memcpy((void */* __restrict  */)tmp_buf, (void const   */* __restrict  */)oob, (size_t )ooblen);
  }
#line 1097
  if (old_oobinfo.useecc == 2U) {
#line 1098
    tags_pos = 0;
#line 1099
    i = 0;
    {
#line 1099
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1099
      if (! old_oobinfo.oobfree[i][1]) {
#line 1099
        goto while_break;
      }
      {
#line 1101
      start = (int )old_oobinfo.oobfree[i][0];
#line 1102
      len = (int )old_oobinfo.oobfree[i][1];
#line 1103
      memcpy((void */* __restrict  */)(oob + start), (void const   */* __restrict  */)(tmp_buf + tags_pos),
             (size_t )len);
#line 1104
      tags_pos += len;
#line 1099
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1108
    start = (int )old_oobinfo.eccbytes;
#line 1109
    len = (int )(mtd->oob_size - (int const   )start);
#line 1110
    memcpy((void */* __restrict  */)(oob + start), (void const   */* __restrict  */)(tmp_buf + start),
           (size_t )len);
    }
  }
#line 1113
  return (0);
}
}
#line 1116 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
int mtd_write(libmtd_t desc , struct mtd_dev_info  const  *mtd , int fd , int eb ,
              int offs , void *data , int len , void *oob , int ooblen , uint8_t mode ) 
{ 
  int ret ;
  off_t seek ;
  struct mtd_write_req ops ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int _err ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int _err___0 ;
  int *tmp___9 ;
  char *tmp___10 ;
  __off64_t tmp___11 ;
  ssize_t tmp___12 ;
  int _err___1 ;
  int *tmp___13 ;
  char *tmp___14 ;

  {
  {
#line 1124
  ret = mtd_valid_erase_block(mtd, eb);
  }
#line 1125
  if (ret) {
#line 1126
    return (ret);
  }
#line 1128
  if (offs < 0) {
    {
#line 1129
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: bad offset %d or length %d, mtd%d eraseblock size is %d\n",
            "libmtd", offs, len, mtd->mtd_num, mtd->eb_size);
#line 1131
    tmp = __errno_location();
#line 1131
    *tmp = 22;
    }
#line 1132
    return (-1);
  } else
#line 1128
  if (offs + len > (int )mtd->eb_size) {
    {
#line 1129
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: bad offset %d or length %d, mtd%d eraseblock size is %d\n",
            "libmtd", offs, len, mtd->mtd_num, mtd->eb_size);
#line 1131
    tmp = __errno_location();
#line 1131
    *tmp = 22;
    }
#line 1132
    return (-1);
  }
#line 1134
  if (offs % (int )mtd->subpage_size) {
    {
#line 1135
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: write offset %d is not aligned to mtd%d min. I/O size %d\n",
            "libmtd", offs, mtd->mtd_num, mtd->subpage_size);
#line 1137
    tmp___0 = __errno_location();
#line 1137
    *tmp___0 = 22;
    }
#line 1138
    return (-1);
  }
#line 1140
  if (len % (int )mtd->subpage_size) {
    {
#line 1141
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: write length %d is not aligned to mtd%d min. I/O size %d\n",
            "libmtd", len, mtd->mtd_num, mtd->subpage_size);
#line 1143
    tmp___1 = __errno_location();
#line 1143
    *tmp___1 = 22;
    }
#line 1144
    return (-1);
  }
#line 1148
  seek = (off_t )eb * (off_t )mtd->eb_size + (off_t )offs;
#line 1150
  if (oob) {
    {
#line 1151
    ops.start = (__u64 )seek;
#line 1152
    ops.len = (__u64 )len;
#line 1153
    ops.ooblen = (__u64 )ooblen;
#line 1154
    ops.usr_data = (__u64 )((unsigned long )data);
#line 1155
    ops.usr_oob = (__u64 )((unsigned long )oob);
#line 1156
    ops.mode = mode;
#line 1158
    ret = ioctl(fd, (unsigned long )(((3U << 30) | (unsigned int )(77 << 8)) | 24U) | (sizeof(struct mtd_write_req ) << 16),
                & ops);
    }
#line 1159
    if (ret == 0) {
#line 1160
      return (0);
    } else {
      {
#line 1161
      tmp___3 = __errno_location();
      }
#line 1161
      if (*tmp___3 != 25) {
        {
#line 1161
        tmp___4 = __errno_location();
        }
#line 1161
        if (*tmp___4 != 95) {
          {
#line 1162
          tmp___2 = mtd_ioctl_error(mtd, eb, "MEMWRITE");
          }
#line 1162
          return (tmp___2);
        }
      }
    }
#line 1165
    if ((int )mode == 1) {
      {
#line 1166
      tmp___5 = legacy_auto_oob_layout(mtd, fd, ooblen, oob);
      }
#line 1166
      if (tmp___5) {
#line 1167
        return (-1);
      }
    }
    {
#line 1168
    tmp___8 = mtd_write_oob(desc, mtd, fd, (uint64_t )seek, (uint64_t )ooblen, oob);
    }
#line 1168
    if (tmp___8 < 0) {
      {
#line 1169
      tmp___6 = __errno_location();
#line 1169
      _err = *tmp___6;
#line 1169
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: cannot write to OOB\n",
              "libmtd");
#line 1169
      tmp___7 = strerror(_err);
#line 1169
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
              (int )sizeof("libmtd") + 1, "", _err, tmp___7);
      }
#line 1169
      return (-1);
    }
  }
#line 1171
  if (data) {
    {
#line 1173
    tmp___11 = lseek(fd, seek, 0);
    }
#line 1173
    if (tmp___11 != seek) {
      {
#line 1174
      tmp___9 = __errno_location();
#line 1174
      _err___0 = *tmp___9;
#line 1174
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: cannot seek mtd%d to offset %llu\n",
              "libmtd", mtd->mtd_num, (unsigned long long )seek);
#line 1174
      tmp___10 = strerror(_err___0);
#line 1174
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
              (int )sizeof("libmtd") + 1, "", _err___0, tmp___10);
      }
#line 1174
      return (-1);
    }
    {
#line 1176
    tmp___12 = write(fd, (void const   *)data, (size_t )len);
#line 1176
    ret = (int )tmp___12;
    }
#line 1177
    if (ret != len) {
      {
#line 1178
      tmp___13 = __errno_location();
#line 1178
      _err___1 = *tmp___13;
#line 1178
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: cannot write %d bytes to mtd%d (eraseblock %d, offset %d)\n",
              "libmtd", len, mtd->mtd_num, eb, offs);
#line 1178
      tmp___14 = strerror(_err___1);
#line 1178
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
              (int )sizeof("libmtd") + 1, "", _err___1, tmp___14);
      }
#line 1178
      return (-1);
    }
  }
#line 1183
  return (0);
}
}
#line 1186 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
int do_oob_op(libmtd_t desc , struct mtd_dev_info  const  *mtd , int fd , uint64_t start ,
              uint64_t length___0 , void *data , unsigned int cmd64 , unsigned int cmd ) 
{ 
  int ret ;
  int oob_offs ;
  struct mtd_oob_buf64 oob64 ;
  struct mtd_oob_buf oob ;
  unsigned long long max_offs ;
  char const   *cmd64_str ;
  char const   *cmd_str ;
  struct libmtd *lib ;
  int *tmp ;
  int *tmp___0 ;
  int _err ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int _err___0 ;
  int *tmp___5 ;
  char *tmp___6 ;

  {
#line 1195
  lib = (struct libmtd *)desc;
#line 1197
  if ((unsigned long )cmd64 == ((unsigned long )(((3U << 30) | (unsigned int )(77 << 8)) | 22U) | (sizeof(struct mtd_oob_buf64 ) << 16))) {
#line 1198
    cmd64_str = "MEMREADOOB64";
#line 1199
    cmd_str = "MEMREADOOB";
  } else {
#line 1201
    cmd64_str = "MEMWRITEOOB64";
#line 1202
    cmd_str = "MEMWRITEOOB";
  }
#line 1205
  max_offs = (unsigned long long )mtd->eb_cnt * (unsigned long long )mtd->eb_size;
#line 1206
  if ((unsigned long long )start >= max_offs) {
    {
#line 1207
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: bad page address %lu, mtd%d has %d eraseblocks (%llu bytes)\n",
            "libmtd", start, mtd->mtd_num, mtd->eb_cnt, max_offs);
#line 1209
    tmp = __errno_location();
#line 1209
    *tmp = 22;
    }
#line 1210
    return (-1);
  }
#line 1213
  oob_offs = (int )(start & (unsigned long )(mtd->min_io_size - 1));
#line 1214
  if ((uint64_t )oob_offs + length___0 > (uint64_t )mtd->oob_size) {
    {
#line 1215
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: Cannot write %lu OOB bytes to address %lu (OOB offset %u) - mtd%d OOB size is only %d bytes\n",
            "libmtd", length___0, start, oob_offs, mtd->mtd_num, mtd->oob_size);
#line 1217
    tmp___0 = __errno_location();
#line 1217
    *tmp___0 = 22;
    }
#line 1218
    return (-1);
  } else
#line 1214
  if (length___0 == 0UL) {
    {
#line 1215
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: Cannot write %lu OOB bytes to address %lu (OOB offset %u) - mtd%d OOB size is only %d bytes\n",
            "libmtd", length___0, start, oob_offs, mtd->mtd_num, mtd->oob_size);
#line 1217
    tmp___0 = __errno_location();
#line 1217
    *tmp___0 = 22;
    }
#line 1218
    return (-1);
  }
#line 1221
  oob64.start = (__u64 )start;
#line 1222
  oob64.length = (__u32 )length___0;
#line 1223
  oob64.usr_ptr = (__u64 )((unsigned long )data);
#line 1225
  if (lib->offs64_ioctls == 2U) {
#line 1225
    goto _L;
  } else
#line 1225
  if (lib->offs64_ioctls == 0U) {
    _L: /* CIL Label */ 
    {
#line 1227
    ret = ioctl(fd, (unsigned long )cmd64, & oob64);
    }
#line 1228
    if (ret == 0) {
#line 1229
      return (ret);
    }
    {
#line 1231
    tmp___3 = __errno_location();
    }
#line 1231
    if (*tmp___3 != 25) {
      {
#line 1233
      tmp___1 = __errno_location();
#line 1233
      _err = *tmp___1;
#line 1233
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: %s ioctl failed for mtd%d, offset %lu (eraseblock %lu)\n",
              "libmtd", cmd64_str, mtd->mtd_num, start, start / (uint64_t )mtd->eb_size);
#line 1233
      tmp___2 = strerror(_err);
#line 1233
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
              (int )sizeof("libmtd") + 1, "", _err, tmp___2);
      }
    } else
#line 1231
    if (lib->offs64_ioctls != 0U) {
      {
#line 1233
      tmp___1 = __errno_location();
#line 1233
      _err = *tmp___1;
#line 1233
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: %s ioctl failed for mtd%d, offset %lu (eraseblock %lu)\n",
              "libmtd", cmd64_str, mtd->mtd_num, start, start / (uint64_t )mtd->eb_size);
#line 1233
      tmp___2 = strerror(_err);
#line 1233
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
              (int )sizeof("libmtd") + 1, "", _err, tmp___2);
      }
    }
#line 1242
    lib->offs64_ioctls = 1U;
  }
#line 1245
  if (oob64.start > 4294967295ULL) {
    {
#line 1246
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: this system can address only up to address %lu\n",
            "libmtd", 4294967295UL);
#line 1248
    tmp___4 = __errno_location();
#line 1248
    *tmp___4 = 22;
    }
#line 1249
    return (-1);
  }
  {
#line 1252
  oob.start = (__u32 )oob64.start;
#line 1253
  oob.length = oob64.length;
#line 1254
  oob.ptr = (unsigned char *)data;
#line 1256
  ret = ioctl(fd, (unsigned long )cmd, & oob);
  }
#line 1257
  if (ret < 0) {
    {
#line 1258
    tmp___5 = __errno_location();
#line 1258
    _err___0 = *tmp___5;
#line 1258
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: %s ioctl failed for mtd%d, offset %lu (eraseblock %lu)\n",
            "libmtd", cmd_str, mtd->mtd_num, start, start / (uint64_t )mtd->eb_size);
#line 1258
    tmp___6 = strerror(_err___0);
#line 1258
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err___0, tmp___6);
    }
  }
#line 1260
  return (ret);
}
}
#line 1263 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
int mtd_read_oob(libmtd_t desc , struct mtd_dev_info  const  *mtd , int fd , uint64_t start ,
                 uint64_t length___0 , void *data ) 
{ 
  int tmp ;

  {
  {
#line 1266
  tmp = do_oob_op(desc, mtd, fd, start, length___0, data, (unsigned int )((unsigned long )(((3U << 30) | (unsigned int )(77 << 8)) | 22U) | (sizeof(struct mtd_oob_buf64 ) << 16)),
                  (unsigned int )((unsigned long )(((3U << 30) | (unsigned int )(77 << 8)) | 4U) | (sizeof(struct mtd_oob_buf ) << 16)));
  }
#line 1266
  return (tmp);
}
}
#line 1270 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
int mtd_write_oob(libmtd_t desc , struct mtd_dev_info  const  *mtd , int fd , uint64_t start ,
                  uint64_t length___0 , void *data ) 
{ 
  int tmp ;

  {
  {
#line 1273
  tmp = do_oob_op(desc, mtd, fd, start, length___0, data, (unsigned int )((unsigned long )(((3U << 30) | (unsigned int )(77 << 8)) | 21U) | (sizeof(struct mtd_oob_buf64 ) << 16)),
                  (unsigned int )((unsigned long )(((3U << 30) | (unsigned int )(77 << 8)) | 3U) | (sizeof(struct mtd_oob_buf ) << 16)));
  }
#line 1273
  return (tmp);
}
}
#line 1277 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
int mtd_write_img(struct mtd_dev_info  const  *mtd , int fd , int eb , int offs ,
                  char const   *img_name ) 
{ 
  int tmp ;
  int ret ;
  int in_fd ;
  int len ;
  int written ;
  off_t seek ;
  struct stat st ;
  char *buf ;
  int *tmp___0 ;
  int *tmp___1 ;
  int _err ;
  int *tmp___2 ;
  char *tmp___3 ;
  int _err___0 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int _err___1 ;
  int *tmp___9 ;
  char *tmp___10 ;
  __off64_t tmp___11 ;
  void *tmp___12 ;
  int rd ;
  ssize_t tmp___13 ;
  int _err___2 ;
  int *tmp___14 ;
  char *tmp___15 ;
  ssize_t tmp___16 ;
  int _err___3 ;
  int *tmp___17 ;
  char *tmp___18 ;

  {
  {
#line 1280
  written = 0;
#line 1285
  ret = mtd_valid_erase_block(mtd, eb);
  }
#line 1286
  if (ret) {
#line 1287
    return (ret);
  }
#line 1289
  if (offs < 0) {
    {
#line 1290
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: bad offset %d, mtd%d eraseblock size is %d\n",
            "libmtd", offs, mtd->mtd_num, mtd->eb_size);
#line 1292
    tmp___0 = __errno_location();
#line 1292
    *tmp___0 = 22;
    }
#line 1293
    return (-1);
  } else
#line 1289
  if (offs >= (int )mtd->eb_size) {
    {
#line 1290
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: bad offset %d, mtd%d eraseblock size is %d\n",
            "libmtd", offs, mtd->mtd_num, mtd->eb_size);
#line 1292
    tmp___0 = __errno_location();
#line 1292
    *tmp___0 = 22;
    }
#line 1293
    return (-1);
  }
#line 1295
  if (offs % (int )mtd->subpage_size) {
    {
#line 1296
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: write offset %d is not aligned to mtd%d min. I/O size %d\n",
            "libmtd", offs, mtd->mtd_num, mtd->subpage_size);
#line 1298
    tmp___1 = __errno_location();
#line 1298
    *tmp___1 = 22;
    }
#line 1299
    return (-1);
  }
  {
#line 1302
  in_fd = open(img_name, 524288);
  }
#line 1303
  if (in_fd == -1) {
    {
#line 1304
    tmp___2 = __errno_location();
#line 1304
    _err = *tmp___2;
#line 1304
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: cannot open \"%s\"\n",
            "libmtd", img_name);
#line 1304
    tmp___3 = strerror(_err);
#line 1304
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err, tmp___3);
    }
#line 1304
    return (-1);
  }
  {
#line 1306
  tmp___6 = fstat(in_fd, & st);
  }
#line 1306
  if (tmp___6) {
    {
#line 1307
    tmp___4 = __errno_location();
#line 1307
    _err___0 = *tmp___4;
#line 1307
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: cannot stat %s\n",
            "libmtd", img_name);
#line 1307
    tmp___5 = strerror(_err___0);
#line 1307
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err___0, tmp___5);
    }
#line 1308
    goto out_close;
  }
#line 1311
  len = (int )st.st_size;
#line 1312
  if (len % (int )mtd->subpage_size) {
    {
#line 1313
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: size of \"%s\" is %d byte, which is not aligned to mtd%d min. I/O size %d\n",
            "libmtd", img_name, len, mtd->mtd_num, mtd->subpage_size);
#line 1316
    tmp___7 = __errno_location();
#line 1316
    *tmp___7 = 22;
    }
#line 1317
    goto out_close;
  }
#line 1319
  tmp = (((offs + len) + (int )mtd->eb_size) - 1) / (int )mtd->eb_size;
#line 1320
  if (eb + tmp > (int )mtd->eb_cnt) {
    {
#line 1321
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: \"%s\" image size is %d bytes, mtd%d size is %d eraseblocks, the image does not fit if we write it starting from eraseblock %d, offset %d\n",
            "libmtd", img_name, len, mtd->mtd_num, mtd->eb_cnt, eb, offs);
#line 1325
    tmp___8 = __errno_location();
#line 1325
    *tmp___8 = 22;
    }
#line 1326
    goto out_close;
  }
  {
#line 1330
  seek = (off_t )eb * (off_t )mtd->eb_size + (off_t )offs;
#line 1331
  tmp___11 = lseek(fd, seek, 0);
  }
#line 1331
  if (tmp___11 != seek) {
    {
#line 1332
    tmp___9 = __errno_location();
#line 1332
    _err___1 = *tmp___9;
#line 1332
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: cannot seek mtd%d to offset %llu\n",
            "libmtd", mtd->mtd_num, (unsigned long long )seek);
#line 1332
    tmp___10 = strerror(_err___1);
#line 1332
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err___1, tmp___10);
    }
#line 1334
    goto out_close;
  }
  {
#line 1337
  tmp___12 = xmalloc((size_t )mtd->eb_size);
#line 1337
  buf = (char *)tmp___12;
  }
  {
#line 1339
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1339
    if (! (written < len)) {
#line 1339
      goto while_break;
    }
#line 1340
    rd = 0;
    {
#line 1342
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1343
      tmp___13 = read(in_fd, (void *)buf, (size_t )((mtd->eb_size - (int const   )offs) - (int const   )rd));
#line 1343
      ret = (int )tmp___13;
      }
#line 1344
      if (ret == -1) {
        {
#line 1345
        tmp___14 = __errno_location();
#line 1345
        _err___2 = *tmp___14;
#line 1345
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: cannot read \"%s\"\n",
                "libmtd", img_name);
#line 1345
        tmp___15 = strerror(_err___2);
#line 1345
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
                (int )sizeof("libmtd") + 1, "", _err___2, tmp___15);
        }
#line 1346
        goto out_free;
      }
#line 1348
      rd += ret;
#line 1342
      if (ret) {
#line 1342
        if (! (rd < (int )(mtd->eb_size - (int const   )offs))) {
#line 1342
          goto while_break___0;
        }
      } else {
#line 1342
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1351
    tmp___16 = write(fd, (void const   *)buf, (size_t )rd);
#line 1351
    ret = (int )tmp___16;
    }
#line 1352
    if (ret != rd) {
      {
#line 1353
      tmp___17 = __errno_location();
#line 1353
      _err___3 = *tmp___17;
#line 1353
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: cannot write %d bytes to mtd%d (eraseblock %d, offset %d)\n",
              "libmtd", len, mtd->mtd_num, eb, offs);
#line 1353
      tmp___18 = strerror(_err___3);
#line 1353
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
              (int )sizeof("libmtd") + 1, "", _err___3, tmp___18);
      }
#line 1355
      goto out_free;
    }
#line 1358
    offs = 0;
#line 1359
    eb ++;
#line 1360
    written += rd;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1363
  free((void *)buf);
#line 1364
  close(in_fd);
  }
#line 1365
  return (0);
  out_free: 
  {
#line 1368
  free((void *)buf);
  }
  out_close: 
  {
#line 1370
  close(in_fd);
  }
#line 1371
  return (-1);
}
}
#line 1374 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
int mtd_probe_node(libmtd_t desc , char const   *node ) 
{ 
  struct stat st ;
  struct mtd_info info ;
  int i ;
  int mjr ;
  int mnr ;
  struct libmtd *lib ;
  int _err ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  int tmp___5 ;
  int mjr1 ;
  int mnr1 ;
  int ret ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;

  {
  {
#line 1379
  lib = (struct libmtd *)desc;
#line 1381
  tmp___1 = stat((char const   */* __restrict  */)node, (struct stat */* __restrict  */)(& st));
  }
#line 1381
  if (tmp___1) {
    {
#line 1382
    tmp = __errno_location();
#line 1382
    _err = *tmp;
#line 1382
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: cannot get information about \"%s\"\n",
            "libmtd", node);
#line 1382
    tmp___0 = strerror(_err);
#line 1382
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err, tmp___0);
    }
#line 1382
    return (-1);
  }
#line 1384
  if (! ((st.st_mode & 61440U) == 8192U)) {
    {
#line 1385
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: \"%s\" is not a character device\n",
            "libmtd", node);
#line 1386
    tmp___2 = __errno_location();
#line 1386
    *tmp___2 = 22;
    }
#line 1387
    return (-1);
  }
  {
#line 1390
  tmp___3 = gnu_dev_major((unsigned long long )st.st_rdev);
#line 1390
  mjr = (int )tmp___3;
#line 1391
  tmp___4 = gnu_dev_minor((unsigned long long )st.st_rdev);
#line 1391
  mnr = (int )tmp___4;
#line 1393
  tmp___5 = mtd_get_info((libmtd_t )((libmtd_t *)lib), & info);
  }
#line 1393
  if (tmp___5) {
#line 1394
    return (-1);
  }
#line 1396
  if (! lib->sysfs_supported) {
#line 1397
    return (0);
  }
#line 1399
  i = info.lowest_mtd_num;
  {
#line 1399
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1399
    if (! (i <= info.highest_mtd_num)) {
#line 1399
      goto while_break;
    }
    {
#line 1402
    ret = dev_get_major(lib, i, & mjr1, & mnr1);
    }
#line 1403
    if (ret) {
      {
#line 1404
      tmp___6 = __errno_location();
      }
#line 1404
      if (*tmp___6 == 2) {
#line 1405
        goto __Cont;
      }
      {
#line 1406
      tmp___7 = __errno_location();
      }
#line 1406
      if (! *tmp___7) {
#line 1407
        goto while_break;
      }
#line 1408
      return (-1);
    }
#line 1411
    if (mjr1 == mjr) {
#line 1411
      if (mnr1 == mnr) {
#line 1412
        return (1);
      }
    }
    __Cont: /* CIL Label */ 
#line 1399
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1415
  tmp___8 = __errno_location();
#line 1415
  *tmp___8 = 0;
  }
#line 1416
  return (-1);
}
}
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 846 "/usr/include/stdio.h"
extern void perror(char const   *__s ) ;
#line 209 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1), __leaf__)) strtoll)(char const   * __restrict  __nptr ,
                                                                                                    char ** __restrict  __endptr ,
                                                                                                    int __base ) ;
#line 176 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 779 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 173
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 128 "./include/common.h"
__inline static long long simple_strtoll(char const   *snum , int *error ) 
{ 
  char *endptr ;
  long long ret ;
  long long tmp ;

  {
  {
#line 128
  tmp = strtoll((char const   */* __restrict  */)snum, (char **/* __restrict  */)(& endptr),
                0);
#line 128
  ret = tmp;
  }
#line 128
  if (error) {
#line 128
    if (! *snum) {
      {
#line 128
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: %s: unable to parse the number \'%s\'\n",
              "nanddump", "strtoll", snum);
#line 128
      *error = 1;
      }
    } else
#line 128
    if (*endptr) {
      {
#line 128
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: %s: unable to parse the number \'%s\'\n",
              "nanddump", "strtoll", snum);
#line 128
      *error = 1;
      }
    }
  }
#line 128
  return (ret);
}
}
#line 38 "./include/xalloc.h"
static void *xmalloc___0(size_t size )  __attribute__((__unused__)) ;
#line 38 "./include/xalloc.h"
static void *xmalloc___0(size_t size ) 
{ 
  void *ptr ;
  void *tmp ;
  int _err ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 41
  tmp = malloc(size);
#line 41
  ptr = tmp;
  }
#line 43
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 43
    if (size != 0UL) {
      {
#line 44
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 44
        tmp___0 = __errno_location();
#line 44
        _err = *tmp___0;
#line 44
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: out of memory\n",
                "nanddump");
#line 44
        tmp___1 = strerror(_err);
#line 44
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
                (int )sizeof("nanddump") + 1, "", _err, tmp___1);
#line 44
        exit(-1);
        }
#line 44
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 45
  return (ptr);
}
}
#line 37 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/nanddump.c"
static void display_help(void) 
{ 


  {
  {
#line 39
  printf((char const   */* __restrict  */)"Usage: %s [OPTIONS] MTD-device\nDumps the contents of a nand mtd partition.\n\n           --help               Display this help and exit\n           --version            Output version information and exit\n           --bb=METHOD          Choose bad block handling method (see below).\n-a         --forcebinary        Force printing of binary data to tty\n-c         --canonicalprint     Print canonical Hex+ASCII dump\n-f file    --file=file          Dump to file\n-l length  --length=length      Length\n-n         --noecc              Read without error correction\n           --omitoob            Omit OOB data (default)\n-o         --oob                Dump OOB data\n-p         --prettyprint        Print nice (hexdump)\n-q         --quiet              Don\'t display progress and status messages\n-s addr    --startaddress=addr  Start address\n\n--bb=METHOD, where METHOD can be `padbad\', `dumpbad\', or `skipbad\':\n    padbad:  dump flash data, substituting 0xFF for any bad blocks\n    dumpbad: dump flash data, including any bad blocks\n    skipbad: dump good data, completely skipping any bad blocks (default)\n",
         "nanddump");
#line 62
  exit(0);
  }
}
}
#line 65 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/nanddump.c"
static void display_version(void) 
{ 


  {
  {
#line 67
  printf((char const   */* __restrict  */)"%1$s 1.5.0\n\n%1$s comes with NO WARRANTY\nto the extent permitted by law.\n\nYou may redistribute copies of %1$s\nunder the terms of the GNU General Public Licence.\nSee the file `COPYING\' for more information.\n",
         "nanddump");
#line 76
  exit(0);
  }
}
}
#line 81 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/nanddump.c"
static _Bool pretty_print  =    (_Bool)0;
#line 82 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/nanddump.c"
static _Bool noecc  =    (_Bool)0;
#line 83 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/nanddump.c"
static _Bool omitoob  =    (_Bool)1;
#line 84 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/nanddump.c"
static long long start_addr  ;
#line 85 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/nanddump.c"
static long long length  ;
#line 86 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/nanddump.c"
static char const   *mtddev  ;
#line 87 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/nanddump.c"
static char const   *dumpfile  ;
#line 88 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/nanddump.c"
static _Bool quiet  =    (_Bool)0;
#line 89 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/nanddump.c"
static _Bool canonical  =    (_Bool)0;
#line 90 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/nanddump.c"
static _Bool forcebinary  =    (_Bool)0;
#line 92 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/nanddump.c"
static enum __anonenum_bb_method_33 bb_method  =    (enum __anonenum_bb_method_33 )2;
#line 105
static void process_options(int argc , char * const  *argv ) ;
#line 105 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/nanddump.c"
static char const   *short_options  =    "s:f:l:opqnca";
#line 106 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/nanddump.c"
static struct option  const  long_options[14]  = 
#line 106
  {      {"help", 0, (int *)0, 0}, 
        {"version", 0, (int *)0, 0}, 
        {"bb", 1, (int *)0, 0}, 
        {"omitoob", 0, (int *)0, 0}, 
        {"forcebinary", 0, (int *)0, 'a'}, 
        {"canonicalprint", 0, (int *)0, 'c'}, 
        {"file", 1, (int *)0, 'f'}, 
        {"oob", 0, (int *)0, 'o'}, 
        {"prettyprint", 0, (int *)0, 'p'}, 
        {"startaddress", 1, (int *)0, 's'}, 
        {"length", 1, (int *)0, 'l'}, 
        {"noecc", 0, (int *)0, 'n'}, 
        {"quiet", 0, (int *)0, 'q'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 98 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/nanddump.c"
static void process_options(int argc , char * const  *argv ) 
{ 
  int error ;
  _Bool oob_default ;
  int option_index ;
  int c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
#line 100
  error = 0;
#line 101
  oob_default = (_Bool)1;
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 104
    option_index = 0;
#line 123
    tmp = getopt_long(argc, argv, short_options, long_options, & option_index);
#line 123
    c = tmp;
    }
#line 125
    if (c == -1) {
#line 126
      goto while_break;
    }
    {
#line 130
    if (c == 0) {
#line 130
      goto case_0;
    }
#line 159
    if (c == 115) {
#line 159
      goto case_115;
    }
#line 162
    if (c == 102) {
#line 162
      goto case_102;
    }
#line 168
    if (c == 108) {
#line 168
      goto case_108;
    }
#line 171
    if (c == 111) {
#line 171
      goto case_111;
    }
#line 179
    if (c == 97) {
#line 179
      goto case_97;
    }
#line 182
    if (c == 99) {
#line 182
      goto case_99;
    }
#line 184
    if (c == 112) {
#line 184
      goto case_112;
    }
#line 187
    if (c == 113) {
#line 187
      goto case_113;
    }
#line 190
    if (c == 110) {
#line 190
      goto case_110;
    }
#line 193
    if (c == 63) {
#line 193
      goto case_63;
    }
#line 129
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 132
    if (option_index == 0) {
#line 132
      goto case_0___0;
    }
#line 135
    if (option_index == 1) {
#line 135
      goto case_1;
    }
#line 138
    if (option_index == 2) {
#line 138
      goto case_2;
    }
#line 149
    if (option_index == 3) {
#line 149
      goto case_3;
    }
#line 131
    goto switch_break___0;
    case_0___0: /* CIL Label */ 
    {
#line 133
    display_help();
    }
#line 134
    goto switch_break___0;
    case_1: /* CIL Label */ 
    {
#line 136
    display_version();
    }
#line 137
    goto switch_break___0;
    case_2: /* CIL Label */ 
    {
#line 140
    tmp___2 = strcmp((char const   *)optarg, "padbad");
    }
#line 140
    if (tmp___2) {
      {
#line 142
      tmp___1 = strcmp((char const   *)optarg, "dumpbad");
      }
#line 142
      if (tmp___1) {
        {
#line 144
        tmp___0 = strcmp((char const   *)optarg, "skipbad");
        }
#line 144
        if (tmp___0) {
#line 147
          error ++;
        } else {
#line 145
          bb_method = (enum __anonenum_bb_method_33 )2;
        }
      } else {
#line 143
        bb_method = (enum __anonenum_bb_method_33 )1;
      }
    } else {
#line 141
      bb_method = (enum __anonenum_bb_method_33 )0;
    }
#line 148
    goto switch_break___0;
    case_3: /* CIL Label */ 
#line 150
    if (oob_default) {
#line 151
      oob_default = (_Bool)0;
#line 152
      omitoob = (_Bool)1;
    } else {
      {
#line 154
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 154
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: --oob and --oomitoob are mutually exclusive\n",
                "nanddump");
#line 154
        exit(-1);
        }
#line 154
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 156
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 158
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 160
    start_addr = simple_strtoll((char const   *)optarg, & error);
    }
#line 161
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 163
    tmp___3 = strdup((char const   *)optarg);
#line 163
    dumpfile = (char const   *)tmp___3;
    }
#line 163
    if (! dumpfile) {
      {
#line 164
      perror("stddup");
#line 165
      exit(1);
      }
    }
#line 167
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 169
    length = simple_strtoll((char const   *)optarg, & error);
    }
#line 170
    goto switch_break;
    case_111: /* CIL Label */ 
#line 172
    if (oob_default) {
#line 173
      oob_default = (_Bool)0;
#line 174
      omitoob = (_Bool)0;
    } else {
      {
#line 176
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 176
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: --oob and --oomitoob are mutually exclusive\n",
                "nanddump");
#line 176
        exit(-1);
        }
#line 176
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 178
    goto switch_break;
    case_97: /* CIL Label */ 
#line 180
    forcebinary = (_Bool)1;
#line 181
    goto switch_break;
    case_99: /* CIL Label */ 
#line 183
    canonical = (_Bool)1;
    case_112: /* CIL Label */ 
#line 185
    pretty_print = (_Bool)1;
#line 186
    goto switch_break;
    case_113: /* CIL Label */ 
#line 188
    quiet = (_Bool)1;
#line 189
    goto switch_break;
    case_110: /* CIL Label */ 
#line 191
    noecc = (_Bool)1;
#line 192
    goto switch_break;
    case_63: /* CIL Label */ 
#line 194
    error ++;
#line 195
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 199
  if (start_addr < 0LL) {
    {
#line 200
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 200
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: Can\'t specify negative offset with option -s: %lld\n",
              "nanddump", start_addr);
#line 200
      exit(-1);
      }
#line 200
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 203
  if (length < 0LL) {
    {
#line 204
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 204
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: Can\'t specify negative length with option -l: %lld\n",
              "nanddump", length);
#line 204
      exit(-1);
      }
#line 204
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 206
  if (quiet) {
#line 206
    if (pretty_print) {
      {
#line 207
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The quiet and pretty print options are mutually-\nexclusive. Choose one or the other.\n");
#line 209
      exit(1);
      }
    }
  }
#line 212
  if (forcebinary) {
#line 212
    if (pretty_print) {
      {
#line 213
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The forcebinary and pretty print options are\nmutually-exclusive. Choose one or the other.\n");
#line 216
      exit(1);
      }
    }
  }
#line 219
  if (argc - optind != 1) {
    {
#line 220
    display_help();
    }
  } else
#line 219
  if (error) {
    {
#line 220
    display_help();
    }
  }
#line 222
  mtddev = (char const   *)*(argv + optind);
#line 223
  return;
}
}
#line 257
static void pretty_dump_to_buffer(unsigned char const   *buf , size_t len , char *linebuf ,
                                  size_t linebuflen , _Bool pagedump , _Bool ascii ,
                                  unsigned long long prefix ) ;
#line 257 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/nanddump.c"
static char const   hex_asc[17]  = 
#line 257
  {      (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'a',      (char const   )'b', 
        (char const   )'c',      (char const   )'d',      (char const   )'e',      (char const   )'f', 
        (char const   )'\000'};
#line 253 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/nanddump.c"
static void pretty_dump_to_buffer(unsigned char const   *buf , size_t len , char *linebuf ,
                                  size_t linebuflen , _Bool pagedump , _Bool ascii ,
                                  unsigned long long prefix ) 
{ 
  unsigned char ch ;
  unsigned int j ;
  unsigned int lx ;
  unsigned int ascii_column ;
  int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  size_t tmp___5 ;
  unsigned int tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  unsigned short const   **tmp___12 ;
  unsigned int tmp___13 ;
  unsigned int tmp___14 ;
  unsigned int tmp___15 ;

  {
#line 259
  lx = 0U;
#line 261
  if (pagedump) {
    {
#line 262
    tmp = sprintf((char */* __restrict  */)linebuf, (char const   */* __restrict  */)"0x%.8llx: ",
                  prefix);
#line 262
    lx += (unsigned int )tmp;
    }
  } else {
    {
#line 264
    tmp___0 = sprintf((char */* __restrict  */)linebuf, (char const   */* __restrict  */)"  OOB Data: ");
#line 264
    lx += (unsigned int )tmp___0;
    }
  }
#line 266
  if (! len) {
#line 267
    goto nil;
  }
#line 268
  if (len > 16UL) {
#line 269
    len = (size_t )16;
  }
#line 271
  j = 0U;
  {
#line 271
  while (1) {
    while_continue: /* CIL Label */ ;
#line 271
    if ((size_t )j < len) {
#line 271
      if (! ((size_t )(lx + 3U) <= linebuflen)) {
#line 271
        goto while_break;
      }
    } else {
#line 271
      goto while_break;
    }
#line 272
    ch = (unsigned char )*(buf + j);
#line 273
    tmp___1 = lx;
#line 273
    lx ++;
#line 273
    *(linebuf + tmp___1) = (char )hex_asc[((int )ch & 240) >> 4];
#line 274
    tmp___2 = lx;
#line 274
    lx ++;
#line 274
    *(linebuf + tmp___2) = (char )hex_asc[(int )ch & 15];
#line 275
    tmp___3 = lx;
#line 275
    lx ++;
#line 275
    *(linebuf + tmp___3) = (char )' ';
#line 271
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 277
  if (j) {
#line 278
    lx --;
  }
#line 280
  ascii_column = 62U;
#line 282
  if (! ascii) {
#line 283
    goto nil;
  }
#line 286
  if (linebuflen < (size_t )ascii_column) {
#line 286
    tmp___7 = linebuflen;
  } else {
#line 286
    tmp___7 = (size_t )ascii_column;
  }
#line 286
  if ((unsigned int )((int )tmp___7 - 1) - lx > 1U) {
#line 286
    if (linebuflen < (size_t )ascii_column) {
#line 286
      tmp___5 = linebuflen;
    } else {
#line 286
      tmp___5 = (size_t )ascii_column;
    }
#line 286
    tmp___6 = (unsigned int )((int )tmp___5 - 1) - lx;
  } else {
#line 286
    tmp___6 = 1U;
  }
  {
#line 286
  tmp___8 = sprintf((char */* __restrict  */)(linebuf + lx), (char const   */* __restrict  */)"%*s",
                    tmp___6, " ");
#line 286
  lx += (unsigned int )tmp___8;
#line 290
  tmp___9 = lx;
#line 290
  lx ++;
#line 290
  *(linebuf + tmp___9) = (char )'|';
#line 291
  j = 0U;
  }
  {
#line 291
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 291
    if ((size_t )j < len) {
#line 291
      if (! ((size_t )(lx + 2U) < linebuflen)) {
#line 291
        goto while_break___0;
      }
    } else {
#line 291
      goto while_break___0;
    }
#line 292
    tmp___10 = lx;
#line 292
    lx ++;
#line 292
    if (((int const   )*(buf + j) & -128) == 0) {
      {
#line 292
      tmp___12 = __ctype_b_loc();
      }
#line 292
      if ((int const   )*(*tmp___12 + (int )*(buf + j)) & 16384) {
#line 292
        *(linebuf + tmp___10) = (char )*(buf + j);
      } else {
#line 292
        *(linebuf + tmp___10) = (char )'.';
      }
    } else {
#line 292
      *(linebuf + tmp___10) = (char )'.';
    }
#line 291
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 294
  tmp___13 = lx;
#line 294
  lx ++;
#line 294
  *(linebuf + tmp___13) = (char )'|';
  nil: 
#line 296
  tmp___14 = lx;
#line 296
  lx ++;
#line 296
  *(linebuf + tmp___14) = (char )'\n';
#line 297
  tmp___15 = lx;
#line 297
  lx ++;
#line 297
  *(linebuf + tmp___15) = (char )'\000';
#line 298
  return;
}
}
#line 304 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/nanddump.c"
int main(int argc , char * const  *argv ) 
{ 
  long long ofs ;
  long long end_addr ;
  long long blockstart ;
  int i ;
  int fd ;
  int ofd ;
  int bs ;
  int badblock ;
  struct mtd_dev_info mtd ;
  char pretty_buf[80] ;
  int firstblock ;
  struct mtd_ecc_stats stat1 ;
  struct mtd_ecc_stats stat2 ;
  _Bool eccstats ;
  unsigned char *readbuf ;
  unsigned char *oobbuf ;
  libmtd_t mtd_desc ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;

  {
  {
#line 306
  end_addr = 0LL;
#line 307
  blockstart = 1LL;
#line 308
  ofd = 0;
#line 308
  badblock = 0;
#line 311
  firstblock = 1;
#line 313
  eccstats = (_Bool)0;
#line 314
  readbuf = (unsigned char *)((void *)0);
#line 314
  oobbuf = (unsigned char *)((void *)0);
#line 317
  process_options(argc, argv);
#line 320
  mtd_desc = libmtd_open();
  }
#line 321
  if (! mtd_desc) {
    {
#line 322
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: can\'t initialize libmtd\n",
            "nanddump");
    }
#line 322
    return (-1);
  }
  {
#line 325
  fd = open(mtddev, 0);
  }
#line 325
  if (fd == -1) {
    {
#line 326
    perror(mtddev);
#line 327
    exit(1);
    }
  }
  {
#line 331
  tmp = mtd_get_dev_info(mtd_desc, mtddev, & mtd);
  }
#line 331
  if (tmp < 0) {
    {
#line 332
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: mtd_get_dev_info failed\n",
            "nanddump");
    }
#line 332
    return (-1);
  }
  {
#line 335
  tmp___0 = xmalloc___0(sizeof(oobbuf) * (unsigned long )mtd.oob_size);
#line 335
  oobbuf = (unsigned char *)tmp___0;
#line 336
  tmp___1 = xmalloc___0(sizeof(readbuf) * (unsigned long )mtd.min_io_size);
#line 336
  readbuf = (unsigned char *)tmp___1;
  }
#line 338
  if (noecc) {
    {
#line 339
    tmp___2 = ioctl(fd, (unsigned long )((unsigned int )(77 << 8) | 19U), 3);
    }
#line 339
    if (tmp___2 != 0) {
      {
#line 340
      perror("MTDFILEMODE");
      }
#line 341
      goto closeall;
    }
  } else {
    {
#line 345
    tmp___3 = ioctl(fd, (unsigned long )(((2U << 30) | (unsigned int )(77 << 8)) | 18U) | (sizeof(struct mtd_ecc_stats ) << 16),
                    & stat1);
    }
#line 345
    if (tmp___3) {
      {
#line 354
      perror("No ECC status information available");
      }
    } else {
#line 346
      eccstats = (_Bool)1;
#line 347
      if (! quiet) {
        {
#line 348
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ECC failed: %d\n",
                stat1.failed);
#line 349
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ECC corrected: %d\n",
                stat1.corrected);
#line 350
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Number of bad blocks: %d\n",
                stat1.badblocks);
#line 351
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Number of bbt blocks: %d\n",
                stat1.bbtblocks);
        }
      }
    }
  }
#line 359
  if (! dumpfile) {
#line 360
    ofd = 1;
  } else {
    {
#line 361
    ofd = open(dumpfile, 577, 420);
    }
#line 361
    if (ofd == -1) {
      {
#line 362
      perror(dumpfile);
      }
#line 363
      goto closeall;
    }
  }
#line 366
  if (! pretty_print) {
#line 366
    if (! forcebinary) {
      {
#line 366
      tmp___4 = isatty(ofd);
      }
#line 366
      if (tmp___4) {
        {
#line 367
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Not printing binary garbage to tty. Use \'-a\'\nor \'--forcebinary\' to override.\n");
        }
#line 369
        goto closeall;
      }
    }
  }
#line 373
  if (start_addr & (long long )(mtd.min_io_size - 1)) {
    {
#line 374
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"the start address (-s parameter) is not page-aligned!\nThe pagesize of this NAND Flash is 0x%x.\n",
            mtd.min_io_size);
    }
#line 377
    goto closeall;
  }
#line 379
  if (length) {
#line 380
    end_addr = start_addr + length;
  }
#line 381
  if (! length) {
#line 382
    end_addr = mtd.size;
  } else
#line 381
  if (end_addr > mtd.size) {
#line 382
    end_addr = mtd.size;
  }
#line 384
  bs = mtd.min_io_size;
#line 387
  if (! quiet) {
    {
#line 388
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Block size %d, page size %d, OOB size %d\n",
            mtd.eb_size, mtd.min_io_size, mtd.oob_size);
#line 390
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Dumping data starting at 0x%08llx and ending at 0x%08llx...\n",
            start_addr, end_addr);
    }
  }
#line 396
  ofs = start_addr;
  {
#line 396
  while (1) {
    while_continue: /* CIL Label */ ;
#line 396
    if (! (ofs < end_addr)) {
#line 396
      goto while_break;
    }
#line 398
    if ((unsigned int )bb_method == 1U) {
#line 399
      badblock = 0;
    } else
#line 400
    if (blockstart != (ofs & (long long )(~ mtd.eb_size + 1))) {
#line 400
      goto _L;
    } else
#line 400
    if (firstblock) {
      _L: /* CIL Label */ 
      {
#line 402
      blockstart = ofs & (long long )(~ mtd.eb_size + 1);
#line 403
      firstblock = 0;
#line 404
      badblock = mtd_is_bad((struct mtd_dev_info  const  *)(& mtd), fd, (int )(ofs / (long long )mtd.eb_size));
      }
#line 404
      if (badblock < 0) {
        {
#line 405
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: libmtd: mtd_is_bad\n",
                "nanddump");
        }
#line 406
        goto closeall;
      }
    }
#line 410
    if (badblock) {
#line 412
      if ((unsigned int )bb_method == 2U) {
#line 413
        end_addr += (long long )mtd.eb_size;
#line 414
        ofs += (long long )(mtd.eb_size - bs);
#line 415
        if (end_addr > mtd.size) {
#line 416
          end_addr = mtd.size;
        }
#line 417
        goto __Cont;
      }
      {
#line 419
      memset((void *)readbuf, 255, (size_t )bs);
      }
    } else {
      {
#line 422
      tmp___5 = mtd_read((struct mtd_dev_info  const  *)(& mtd), fd, (int )(ofs / (long long )mtd.eb_size),
                         (int )(ofs % (long long )mtd.eb_size), (void *)readbuf, bs);
      }
#line 422
      if (tmp___5) {
        {
#line 423
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: mtd_read\n",
                "nanddump");
        }
#line 424
        goto closeall;
      }
    }
#line 429
    if (eccstats) {
      {
#line 430
      tmp___6 = ioctl(fd, (unsigned long )(((2U << 30) | (unsigned int )(77 << 8)) | 18U) | (sizeof(struct mtd_ecc_stats ) << 16),
                      & stat2);
      }
#line 430
      if (tmp___6) {
        {
#line 431
        perror("ioctl(ECCGETSTATS)");
        }
#line 432
        goto closeall;
      }
#line 434
      if (stat1.failed != stat2.failed) {
        {
#line 435
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ECC: %d uncorrectable bitflip(s) at offset 0x%08llx\n",
                stat2.failed - stat1.failed, ofs);
        }
      }
#line 438
      if (stat1.corrected != stat2.corrected) {
        {
#line 439
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ECC: %d corrected bitflip(s) at offset 0x%08llx\n",
                stat2.corrected - stat1.corrected, ofs);
        }
      }
#line 442
      stat1 = stat2;
    }
#line 446
    if (pretty_print) {
#line 447
      i = 0;
      {
#line 447
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 447
        if (! (i < bs)) {
#line 447
          goto while_break___0;
        }
        {
#line 448
        pretty_dump_to_buffer((unsigned char const   *)(readbuf + i), (size_t )16,
                              pretty_buf, (size_t )80, (_Bool)1, canonical, (unsigned long long )(ofs + (long long )i));
#line 450
        tmp___7 = strlen((char const   *)(pretty_buf));
#line 450
        write(ofd, (void const   *)(pretty_buf), tmp___7);
#line 447
        i += 16;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 453
      write(ofd, (void const   *)readbuf, (size_t )bs);
      }
    }
#line 455
    if (omitoob) {
#line 456
      goto __Cont;
    }
#line 458
    if (badblock) {
      {
#line 459
      memset((void *)oobbuf, 255, (size_t )mtd.oob_size);
      }
    } else {
      {
#line 462
      tmp___8 = mtd_read_oob(mtd_desc, (struct mtd_dev_info  const  *)(& mtd), fd,
                             (uint64_t )ofs, (uint64_t )mtd.oob_size, (void *)oobbuf);
      }
#line 462
      if (tmp___8) {
        {
#line 463
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: libmtd: mtd_read_oob\n",
                "nanddump");
        }
#line 464
        goto closeall;
      }
    }
#line 469
    if (pretty_print) {
#line 470
      i = 0;
      {
#line 470
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 470
        if (! (i < mtd.oob_size)) {
#line 470
          goto while_break___1;
        }
        {
#line 471
        pretty_dump_to_buffer((unsigned char const   *)(oobbuf + i), (size_t )(mtd.oob_size - i),
                              pretty_buf, (size_t )80, (_Bool)0, canonical, 0ULL);
#line 473
        tmp___9 = strlen((char const   *)(pretty_buf));
#line 473
        write(ofd, (void const   *)(pretty_buf), tmp___9);
#line 470
        i += 16;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
      {
#line 476
      write(ofd, (void const   *)oobbuf, (size_t )mtd.oob_size);
      }
    }
    __Cont: /* CIL Label */ 
#line 396
    ofs += (long long )bs;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 480
  close(fd);
#line 481
  close(ofd);
#line 482
  free((void *)oobbuf);
#line 483
  free((void *)readbuf);
  }
#line 486
  return (0);
  closeall: 
  {
#line 489
  close(fd);
#line 490
  close(ofd);
#line 491
  free((void *)oobbuf);
#line 492
  free((void *)readbuf);
#line 493
  exit(1);
  }
}
}
#line 97 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd_int.h"
int legacy_libmtd_open(void) ;
#line 96 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memchr)(void const   *__s ,
                                                                                               int __c ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 38 "./include/xalloc.h"
static void *xmalloc___1(size_t size )  __attribute__((__unused__)) ;
#line 38 "./include/xalloc.h"
static void *xmalloc___1(size_t size ) 
{ 
  void *ptr ;
  void *tmp ;
  int _err ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 41
  tmp = malloc(size);
#line 41
  ptr = tmp;
  }
#line 43
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 43
    if (size != 0UL) {
      {
#line 44
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 44
        tmp___0 = __errno_location();
#line 44
        _err = *tmp___0;
#line 44
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: out of memory\n",
                "libmtd");
#line 44
        tmp___1 = strerror(_err);
#line 44
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
                (int )sizeof("libmtd") + 1, "", _err, tmp___1);
#line 44
        exit(-1);
        }
#line 44
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 45
  return (ptr);
}
}
#line 70 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd_legacy.c"
static int proc_parse_start(struct proc_parse_info *pi ) 
{ 
  int fd ;
  int ret ;
  void *tmp ;
  ssize_t tmp___0 ;
  int _err ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 74
  fd = open("/proc/mtd", 0);
  }
#line 75
  if (fd == -1) {
#line 76
    return (-1);
  }
  {
#line 78
  tmp = xmalloc___1((size_t )4096);
#line 78
  pi->buf = (char *)tmp;
#line 80
  tmp___0 = read(fd, (void *)pi->buf, (size_t )4096);
#line 80
  ret = (int )tmp___0;
  }
#line 81
  if (ret == -1) {
    {
#line 82
    tmp___1 = __errno_location();
#line 82
    _err = *tmp___1;
#line 82
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: cannot read \"%s\"\n",
            "libmtd", "/proc/mtd");
#line 82
    tmp___2 = strerror(_err);
#line 82
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err, tmp___2);
    }
#line 83
    goto out_free;
  }
#line 86
  if ((unsigned long )ret < sizeof("dev:    size   erasesize  name\n") - 1UL) {
    {
#line 88
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: \"%s\" does not start with \"%s\"\n",
            "libmtd", "/proc/mtd", "dev:    size   erasesize  name\n");
    }
#line 90
    goto out_free;
  } else {
    {
#line 86
    tmp___3 = memcmp((void const   *)pi->buf, (void const   *)"dev:    size   erasesize  name\n",
                     sizeof("dev:    size   erasesize  name\n") - 1UL);
    }
#line 86
    if (tmp___3) {
      {
#line 88
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: \"%s\" does not start with \"%s\"\n",
              "libmtd", "/proc/mtd", "dev:    size   erasesize  name\n");
      }
#line 90
      goto out_free;
    }
  }
  {
#line 93
  pi->data_size = ret;
#line 94
  pi->next = pi->buf + (sizeof("dev:    size   erasesize  name\n") - 1UL);
#line 96
  close(fd);
  }
#line 97
  return (0);
  out_free: 
  {
#line 100
  free((void *)pi->buf);
#line 101
  close(fd);
  }
#line 102
  return (-1);
}
}
#line 105 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd_legacy.c"
static int proc_parse_next(struct proc_parse_info *pi ) 
{ 
  int ret ;
  int len ;
  int pos ;
  char *p ;
  char *p1 ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 107
  pos = (int )(pi->next - pi->buf);
#line 110
  if (pos >= pi->data_size) {
    {
#line 111
    free((void *)pi->buf);
    }
#line 112
    return (0);
  }
  {
#line 115
  ret = sscanf((char const   */* __restrict  */)pi->next, (char const   */* __restrict  */)"mtd%d: %llx %x",
               & pi->mtd_num, & pi->size, & pi->eb_size);
  }
#line 117
  if (ret != 3) {
    {
#line 118
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: \"%s\" pattern not found\n",
            "libmtd", "mtd%d: %llx %x");
    }
#line 118
    return (-1);
  }
  {
#line 120
  tmp = memchr((void const   *)pi->next, '\"', (size_t )(pi->data_size - pos));
#line 120
  p = (char *)tmp;
  }
#line 121
  if (! p) {
    {
#line 122
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: opening \" not found\n",
            "libmtd");
    }
#line 122
    return (-1);
  }
#line 123
  p ++;
#line 124
  pos = (int )(p - pi->buf);
#line 125
  if (pos >= pi->data_size) {
    {
#line 126
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: opening \" not found\n",
            "libmtd");
    }
#line 126
    return (-1);
  }
  {
#line 128
  tmp___0 = memchr((void const   *)p, '\"', (size_t )(pi->data_size - pos));
#line 128
  p1 = (char *)tmp___0;
  }
#line 129
  if (! p1) {
    {
#line 130
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: closing \" not found\n",
            "libmtd");
    }
#line 130
    return (-1);
  }
#line 131
  pos = (int )(p1 - pi->buf);
#line 132
  if (pos >= pi->data_size) {
    {
#line 133
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: closing \" not found\n",
            "libmtd");
    }
#line 133
    return (-1);
  }
#line 135
  len = (int )(p1 - p);
#line 136
  if (len > 127) {
    {
#line 137
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: too long mtd%d device name\n",
            "libmtd", pi->mtd_num);
    }
#line 137
    return (-1);
  }
  {
#line 139
  memcpy((void */* __restrict  */)(pi->name), (void const   */* __restrict  */)p,
         (size_t )len);
#line 140
  pi->name[len] = (char )'\000';
  }
#line 142
  if ((int )*(p1 + 1) != 10) {
    {
#line 143
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: opening \"\n\" not found\n",
            "libmtd");
    }
#line 143
    return (-1);
  }
#line 144
  pi->next = p1 + 2;
#line 145
  return (1);
}
}
#line 157 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd_legacy.c"
int legacy_libmtd_open(void) 
{ 
  int fd ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 161
  fd = open("/proc/mtd", 0);
  }
#line 162
  if (fd == -1) {
    {
#line 163
    tmp___0 = __errno_location();
    }
#line 163
    if (*tmp___0 == 2) {
      {
#line 164
      tmp = __errno_location();
#line 164
      *tmp = 0;
      }
    }
#line 165
    return (-1);
  }
  {
#line 168
  close(fd);
  }
#line 169
  return (0);
}
}
#line 180 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd_legacy.c"
int legacy_dev_present(int mtd_num ) 
{ 
  int ret ;
  struct proc_parse_info pi ;
  int tmp ;

  {
  {
#line 185
  ret = proc_parse_start(& pi);
  }
#line 186
  if (ret) {
#line 187
    return (-1);
  }
  {
#line 189
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 189
    tmp = proc_parse_next(& pi);
    }
#line 189
    if (! tmp) {
#line 189
      goto while_break;
    }
#line 190
    if (pi.mtd_num == mtd_num) {
#line 191
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 194
  return (0);
}
}
#line 203 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd_legacy.c"
int legacy_mtd_get_info(struct mtd_info *info ) 
{ 
  int ret ;
  struct proc_parse_info pi ;
  int tmp ;

  {
  {
#line 208
  ret = proc_parse_start(& pi);
  }
#line 209
  if (ret) {
#line 210
    return (-1);
  }
#line 212
  info->lowest_mtd_num = 2147483647;
  {
#line 213
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 213
    tmp = proc_parse_next(& pi);
    }
#line 213
    if (! tmp) {
#line 213
      goto while_break;
    }
#line 214
    (info->mtd_dev_cnt) ++;
#line 215
    if (pi.mtd_num > info->highest_mtd_num) {
#line 216
      info->highest_mtd_num = pi.mtd_num;
    }
#line 217
    if (pi.mtd_num < info->lowest_mtd_num) {
#line 218
      info->lowest_mtd_num = pi.mtd_num;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 221
  return (0);
}
}
#line 232 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd_legacy.c"
int legacy_get_dev_info(char const   *node , struct mtd_dev_info *mtd ) 
{ 
  struct stat st ;
  struct mtd_info_user ui ;
  int fd ;
  int ret ;
  loff_t offs ;
  struct proc_parse_info pi ;
  int _err ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  int *tmp___6 ;
  int _err___0 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int _err___1 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int _err___2 ;
  int *tmp___12 ;
  char *tmp___13 ;
  int *tmp___14 ;
  int *tmp___15 ;
  int tmp___16 ;
  int *tmp___17 ;

  {
  {
#line 237
  offs = (loff_t )0;
#line 240
  tmp___2 = stat((char const   */* __restrict  */)node, (struct stat */* __restrict  */)(& st));
  }
#line 240
  if (tmp___2) {
    {
#line 241
    tmp = __errno_location();
#line 241
    _err = *tmp;
#line 241
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: cannot open \"%s\"\n",
            "libmtd", node);
#line 241
    tmp___0 = strerror(_err);
#line 241
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err, tmp___0);
#line 242
    tmp___1 = __errno_location();
    }
#line 242
    if (*tmp___1 == 2) {
      {
#line 243
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 243
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 243
          printf((char const   */* __restrict  */)"%s: MTD subsystem is old and does not support sysfs, so MTD character device nodes have to exist\n",
                 "libmtd");
          }
#line 243
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 243
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 248
  if (! ((st.st_mode & 61440U) == 8192U)) {
    {
#line 249
    tmp___3 = __errno_location();
#line 249
    *tmp___3 = 22;
#line 250
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: \"%s\" is not a character device\n",
            "libmtd", node);
    }
#line 250
    return (-1);
  }
  {
#line 253
  memset((void *)mtd, '\000', sizeof(struct mtd_dev_info ));
#line 254
  tmp___4 = gnu_dev_major((unsigned long long )st.st_rdev);
#line 254
  mtd->major = (int )tmp___4;
#line 255
  tmp___5 = gnu_dev_minor((unsigned long long )st.st_rdev);
#line 255
  mtd->minor = (int )tmp___5;
  }
#line 257
  if (mtd->major != 90) {
    {
#line 258
    tmp___6 = __errno_location();
#line 258
    *tmp___6 = 22;
#line 259
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: \"%s\" has major number %d, MTD devices have major %d\n",
            "libmtd", node, mtd->major, 90);
    }
#line 259
    return (-1);
  }
  {
#line 263
  mtd->mtd_num = mtd->minor / 2;
#line 265
  fd = open(node, 0);
  }
#line 266
  if (fd == -1) {
    {
#line 267
    tmp___7 = __errno_location();
#line 267
    _err___0 = *tmp___7;
#line 267
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: cannot open \"%s\"\n",
            "libmtd", node);
#line 267
    tmp___8 = strerror(_err___0);
#line 267
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err___0, tmp___8);
    }
#line 267
    return (-1);
  }
  {
#line 269
  tmp___11 = ioctl(fd, (unsigned long )(((2U << 30) | (unsigned int )(77 << 8)) | 1U) | (sizeof(struct mtd_info_user ) << 16),
                   & ui);
  }
#line 269
  if (tmp___11) {
    {
#line 270
    tmp___9 = __errno_location();
#line 270
    _err___1 = *tmp___9;
#line 270
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: MEMGETINFO ioctl request failed\n",
            "libmtd");
#line 270
    tmp___10 = strerror(_err___1);
#line 270
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err___1, tmp___10);
    }
#line 271
    goto out_close;
  }
  {
#line 274
  ret = ioctl(fd, (unsigned long )(((1U << 30) | (unsigned int )(77 << 8)) | 11U) | (sizeof(__kernel_loff_t ) << 16),
              & offs);
  }
#line 275
  if (ret == -1) {
    {
#line 276
    tmp___14 = __errno_location();
    }
#line 276
    if (*tmp___14 != 95) {
      {
#line 277
      tmp___12 = __errno_location();
#line 277
      _err___2 = *tmp___12;
#line 277
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: MEMGETBADBLOCK ioctl failed\n",
              "libmtd");
#line 277
      tmp___13 = strerror(_err___2);
#line 277
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
              (int )sizeof("libmtd") + 1, "", _err___2, tmp___13);
      }
#line 278
      goto out_close;
    }
    {
#line 280
    tmp___15 = __errno_location();
#line 280
    *tmp___15 = 0;
#line 281
    mtd->bb_allowed = 0U;
    }
  } else {
#line 283
    mtd->bb_allowed = 1U;
  }
#line 285
  mtd->type = (int )ui.type;
#line 286
  mtd->size = (long long )ui.size;
#line 287
  mtd->eb_size = (int )ui.erasesize;
#line 288
  mtd->min_io_size = (int )ui.writesize;
#line 289
  mtd->oob_size = (int )ui.oobsize;
#line 291
  if (mtd->min_io_size <= 0) {
    {
#line 292
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: mtd%d (%s) has insane min. I/O unit size %d\n",
            "libmtd", mtd->mtd_num, node, mtd->min_io_size);
    }
#line 294
    goto out_close;
  }
#line 296
  if (mtd->eb_size <= 0) {
    {
#line 297
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: mtd%d (%s) has insane eraseblock size %d\n",
            "libmtd", mtd->mtd_num, node, mtd->eb_size);
    }
#line 299
    goto out_close;
  } else
#line 296
  if (mtd->eb_size < mtd->min_io_size) {
    {
#line 297
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: mtd%d (%s) has insane eraseblock size %d\n",
            "libmtd", mtd->mtd_num, node, mtd->eb_size);
    }
#line 299
    goto out_close;
  }
#line 301
  if (mtd->size <= 0LL) {
    {
#line 302
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: mtd%d (%s) has insane size %lld\n",
            "libmtd", mtd->mtd_num, node, mtd->size);
    }
#line 304
    goto out_close;
  } else
#line 301
  if (mtd->size < (long long )mtd->eb_size) {
    {
#line 302
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: mtd%d (%s) has insane size %lld\n",
            "libmtd", mtd->mtd_num, node, mtd->size);
    }
#line 304
    goto out_close;
  }
#line 306
  mtd->eb_cnt = (int )(mtd->size / (long long )mtd->eb_size);
  {
#line 309
  if (mtd->type == 0) {
#line 309
    goto case_0;
  }
#line 313
  if (mtd->type == 1) {
#line 313
    goto case_1;
  }
#line 316
  if (mtd->type == 2) {
#line 316
    goto case_2;
  }
#line 319
  if (mtd->type == 3) {
#line 319
    goto case_3;
  }
#line 322
  if (mtd->type == 4) {
#line 322
    goto case_4;
  }
#line 325
  if (mtd->type == 6) {
#line 325
    goto case_6;
  }
#line 328
  if (mtd->type == 7) {
#line 328
    goto case_7;
  }
#line 331
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 310
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: mtd%d (%s) is removable and is not present\n",
          "libmtd", mtd->mtd_num, node);
  }
#line 312
  goto out_close;
  case_1: /* CIL Label */ 
  {
#line 314
  strcpy((char */* __restrict  */)((char *)(mtd->type_str)), (char const   */* __restrict  */)"ram");
  }
#line 315
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 317
  strcpy((char */* __restrict  */)((char *)(mtd->type_str)), (char const   */* __restrict  */)"rom");
  }
#line 318
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 320
  strcpy((char */* __restrict  */)((char *)(mtd->type_str)), (char const   */* __restrict  */)"nor");
  }
#line 321
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 323
  strcpy((char */* __restrict  */)((char *)(mtd->type_str)), (char const   */* __restrict  */)"nand");
  }
#line 324
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 326
  strcpy((char */* __restrict  */)((char *)(mtd->type_str)), (char const   */* __restrict  */)"dataflash");
  }
#line 327
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 329
  strcpy((char */* __restrict  */)((char *)(mtd->type_str)), (char const   */* __restrict  */)"ubi");
  }
#line 330
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 332
  goto out_close;
  switch_break: /* CIL Label */ ;
  }
#line 335
  if (ui.flags & 1024U) {
#line 336
    mtd->writable = 1U;
  }
  {
#line 337
  mtd->subpage_size = mtd->min_io_size;
#line 339
  close(fd);
#line 345
  ret = proc_parse_start(& pi);
  }
#line 346
  if (ret) {
#line 347
    return (-1);
  }
  {
#line 349
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 349
    tmp___16 = proc_parse_next(& pi);
    }
#line 349
    if (! tmp___16) {
#line 349
      goto while_break___1;
    }
#line 350
    if (pi.mtd_num == mtd->mtd_num) {
      {
#line 351
      strcpy((char */* __restrict  */)((char *)(mtd->name)), (char const   */* __restrict  */)(pi.name));
      }
#line 352
      return (0);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 356
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: mtd%d not found in \"%s\"\n",
          "libmtd", mtd->mtd_num, "/proc/mtd");
#line 357
  tmp___17 = __errno_location();
#line 357
  *tmp___17 = 2;
  }
#line 358
  return (-1);
  out_close: 
  {
#line 361
  close(fd);
  }
#line 362
  return (-1);
}
}
#line 373 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd_legacy.c"
int legacy_get_dev_info1(int mtd_num , struct mtd_dev_info *mtd ) 
{ 
  char node[sizeof("/dev/mtd%d") + 20UL] ;
  int tmp ;

  {
  {
#line 377
  sprintf((char */* __restrict  */)(node), (char const   */* __restrict  */)"/dev/mtd%d",
          mtd_num);
#line 378
  tmp = legacy_get_dev_info((char const   *)(node), mtd);
  }
#line 378
  return (tmp);
}
}
#line 42 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libcrc32.c"
static uint32_t const   crc32_table[256]  = 
#line 42 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libcrc32.c"
  {      (uint32_t const   )0L,      (uint32_t const   )1996959894L,      (uint32_t const   )3993919788L,      (uint32_t const   )2567524794L, 
        (uint32_t const   )124634137L,      (uint32_t const   )1886057615L,      (uint32_t const   )3915621685L,      (uint32_t const   )2657392035L, 
        (uint32_t const   )249268274L,      (uint32_t const   )2044508324L,      (uint32_t const   )3772115230L,      (uint32_t const   )2547177864L, 
        (uint32_t const   )162941995L,      (uint32_t const   )2125561021L,      (uint32_t const   )3887607047L,      (uint32_t const   )2428444049L, 
        (uint32_t const   )498536548L,      (uint32_t const   )1789927666L,      (uint32_t const   )4089016648L,      (uint32_t const   )2227061214L, 
        (uint32_t const   )450548861L,      (uint32_t const   )1843258603L,      (uint32_t const   )4107580753L,      (uint32_t const   )2211677639L, 
        (uint32_t const   )325883990L,      (uint32_t const   )1684777152L,      (uint32_t const   )4251122042L,      (uint32_t const   )2321926636L, 
        (uint32_t const   )335633487L,      (uint32_t const   )1661365465L,      (uint32_t const   )4195302755L,      (uint32_t const   )2366115317L, 
        (uint32_t const   )997073096L,      (uint32_t const   )1281953886L,      (uint32_t const   )3579855332L,      (uint32_t const   )2724688242L, 
        (uint32_t const   )1006888145L,      (uint32_t const   )1258607687L,      (uint32_t const   )3524101629L,      (uint32_t const   )2768942443L, 
        (uint32_t const   )901097722L,      (uint32_t const   )1119000684L,      (uint32_t const   )3686517206L,      (uint32_t const   )2898065728L, 
        (uint32_t const   )853044451L,      (uint32_t const   )1172266101L,      (uint32_t const   )3705015759L,      (uint32_t const   )2882616665L, 
        (uint32_t const   )651767980L,      (uint32_t const   )1373503546L,      (uint32_t const   )3369554304L,      (uint32_t const   )3218104598L, 
        (uint32_t const   )565507253L,      (uint32_t const   )1454621731L,      (uint32_t const   )3485111705L,      (uint32_t const   )3099436303L, 
        (uint32_t const   )671266974L,      (uint32_t const   )1594198024L,      (uint32_t const   )3322730930L,      (uint32_t const   )2970347812L, 
        (uint32_t const   )795835527L,      (uint32_t const   )1483230225L,      (uint32_t const   )3244367275L,      (uint32_t const   )3060149565L, 
        (uint32_t const   )1994146192L,      (uint32_t const   )31158534L,      (uint32_t const   )2563907772L,      (uint32_t const   )4023717930L, 
        (uint32_t const   )1907459465L,      (uint32_t const   )112637215L,      (uint32_t const   )2680153253L,      (uint32_t const   )3904427059L, 
        (uint32_t const   )2013776290L,      (uint32_t const   )251722036L,      (uint32_t const   )2517215374L,      (uint32_t const   )3775830040L, 
        (uint32_t const   )2137656763L,      (uint32_t const   )141376813L,      (uint32_t const   )2439277719L,      (uint32_t const   )3865271297L, 
        (uint32_t const   )1802195444L,      (uint32_t const   )476864866L,      (uint32_t const   )2238001368L,      (uint32_t const   )4066508878L, 
        (uint32_t const   )1812370925L,      (uint32_t const   )453092731L,      (uint32_t const   )2181625025L,      (uint32_t const   )4111451223L, 
        (uint32_t const   )1706088902L,      (uint32_t const   )314042704L,      (uint32_t const   )2344532202L,      (uint32_t const   )4240017532L, 
        (uint32_t const   )1658658271L,      (uint32_t const   )366619977L,      (uint32_t const   )2362670323L,      (uint32_t const   )4224994405L, 
        (uint32_t const   )1303535960L,      (uint32_t const   )984961486L,      (uint32_t const   )2747007092L,      (uint32_t const   )3569037538L, 
        (uint32_t const   )1256170817L,      (uint32_t const   )1037604311L,      (uint32_t const   )2765210733L,      (uint32_t const   )3554079995L, 
        (uint32_t const   )1131014506L,      (uint32_t const   )879679996L,      (uint32_t const   )2909243462L,      (uint32_t const   )3663771856L, 
        (uint32_t const   )1141124467L,      (uint32_t const   )855842277L,      (uint32_t const   )2852801631L,      (uint32_t const   )3708648649L, 
        (uint32_t const   )1342533948L,      (uint32_t const   )654459306L,      (uint32_t const   )3188396048L,      (uint32_t const   )3373015174L, 
        (uint32_t const   )1466479909L,      (uint32_t const   )544179635L,      (uint32_t const   )3110523913L,      (uint32_t const   )3462522015L, 
        (uint32_t const   )1591671054L,      (uint32_t const   )702138776L,      (uint32_t const   )2966460450L,      (uint32_t const   )3352799412L, 
        (uint32_t const   )1504918807L,      (uint32_t const   )783551873L,      (uint32_t const   )3082640443L,      (uint32_t const   )3233442989L, 
        (uint32_t const   )3988292384L,      (uint32_t const   )2596254646L,      (uint32_t const   )62317068L,      (uint32_t const   )1957810842L, 
        (uint32_t const   )3939845945L,      (uint32_t const   )2647816111L,      (uint32_t const   )81470997L,      (uint32_t const   )1943803523L, 
        (uint32_t const   )3814918930L,      (uint32_t const   )2489596804L,      (uint32_t const   )225274430L,      (uint32_t const   )2053790376L, 
        (uint32_t const   )3826175755L,      (uint32_t const   )2466906013L,      (uint32_t const   )167816743L,      (uint32_t const   )2097651377L, 
        (uint32_t const   )4027552580L,      (uint32_t const   )2265490386L,      (uint32_t const   )503444072L,      (uint32_t const   )1762050814L, 
        (uint32_t const   )4150417245L,      (uint32_t const   )2154129355L,      (uint32_t const   )426522225L,      (uint32_t const   )1852507879L, 
        (uint32_t const   )4275313526L,      (uint32_t const   )2312317920L,      (uint32_t const   )282753626L,      (uint32_t const   )1742555852L, 
        (uint32_t const   )4189708143L,      (uint32_t const   )2394877945L,      (uint32_t const   )397917763L,      (uint32_t const   )1622183637L, 
        (uint32_t const   )3604390888L,      (uint32_t const   )2714866558L,      (uint32_t const   )953729732L,      (uint32_t const   )1340076626L, 
        (uint32_t const   )3518719985L,      (uint32_t const   )2797360999L,      (uint32_t const   )1068828381L,      (uint32_t const   )1219638859L, 
        (uint32_t const   )3624741850L,      (uint32_t const   )2936675148L,      (uint32_t const   )906185462L,      (uint32_t const   )1090812512L, 
        (uint32_t const   )3747672003L,      (uint32_t const   )2825379669L,      (uint32_t const   )829329135L,      (uint32_t const   )1181335161L, 
        (uint32_t const   )3412177804L,      (uint32_t const   )3160834842L,      (uint32_t const   )628085408L,      (uint32_t const   )1382605366L, 
        (uint32_t const   )3423369109L,      (uint32_t const   )3138078467L,      (uint32_t const   )570562233L,      (uint32_t const   )1426400815L, 
        (uint32_t const   )3317316542L,      (uint32_t const   )2998733608L,      (uint32_t const   )733239954L,      (uint32_t const   )1555261956L, 
        (uint32_t const   )3268935591L,      (uint32_t const   )3050360625L,      (uint32_t const   )752459403L,      (uint32_t const   )1541320221L, 
        (uint32_t const   )2607071920L,      (uint32_t const   )3965973030L,      (uint32_t const   )1969922972L,      (uint32_t const   )40735498L, 
        (uint32_t const   )2617837225L,      (uint32_t const   )3943577151L,      (uint32_t const   )1913087877L,      (uint32_t const   )83908371L, 
        (uint32_t const   )2512341634L,      (uint32_t const   )3803740692L,      (uint32_t const   )2075208622L,      (uint32_t const   )213261112L, 
        (uint32_t const   )2463272603L,      (uint32_t const   )3855990285L,      (uint32_t const   )2094854071L,      (uint32_t const   )198958881L, 
        (uint32_t const   )2262029012L,      (uint32_t const   )4057260610L,      (uint32_t const   )1759359992L,      (uint32_t const   )534414190L, 
        (uint32_t const   )2176718541L,      (uint32_t const   )4139329115L,      (uint32_t const   )1873836001L,      (uint32_t const   )414664567L, 
        (uint32_t const   )2282248934L,      (uint32_t const   )4279200368L,      (uint32_t const   )1711684554L,      (uint32_t const   )285281116L, 
        (uint32_t const   )2405801727L,      (uint32_t const   )4167216745L,      (uint32_t const   )1634467795L,      (uint32_t const   )376229701L, 
        (uint32_t const   )2685067896L,      (uint32_t const   )3608007406L,      (uint32_t const   )1308918612L,      (uint32_t const   )956543938L, 
        (uint32_t const   )2808555105L,      (uint32_t const   )3495958263L,      (uint32_t const   )1231636301L,      (uint32_t const   )1047427035L, 
        (uint32_t const   )2932959818L,      (uint32_t const   )3654703836L,      (uint32_t const   )1088359270L,      (uint32_t const   )936918000L, 
        (uint32_t const   )2847714899L,      (uint32_t const   )3736837829L,      (uint32_t const   )1202900863L,      (uint32_t const   )817233897L, 
        (uint32_t const   )3183342108L,      (uint32_t const   )3401237130L,      (uint32_t const   )1404277552L,      (uint32_t const   )615818150L, 
        (uint32_t const   )3134207493L,      (uint32_t const   )3453421203L,      (uint32_t const   )1423857449L,      (uint32_t const   )601450431L, 
        (uint32_t const   )3009837614L,      (uint32_t const   )3294710456L,      (uint32_t const   )1567103746L,      (uint32_t const   )711928724L, 
        (uint32_t const   )3020668471L,      (uint32_t const   )3272380065L,      (uint32_t const   )1510334235L,      (uint32_t const   )755167117L};
#line 97 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libcrc32.c"
uint32_t mtd_crc32(uint32_t val , void const   *ss , int len ) 
{ 
  unsigned char const   *s ;
  unsigned char const   *tmp ;

  {
#line 99
  s = (unsigned char const   *)ss;
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    len --;
#line 101
    if (! (len >= 0)) {
#line 101
      goto while_break;
    }
#line 102
    tmp = s;
#line 102
    s ++;
#line 102
    val = (uint32_t )(crc32_table[(val ^ (unsigned int )*tmp) & 255U] ^ (unsigned int const   )(val >> 8));
  }
  while_break: /* CIL Label */ ;
  }
#line 103
  return (val);
}
}
/* compiler builtin: 
   int __builtin_bswap32(int  ) ;  */
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 44 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static unsigned int __bswap_32(unsigned int __bsx ) 
{ 
  int tmp ;

  {
  {
#line 47
  tmp = __builtin_bswap32((int )__bsx);
  }
#line 47
  return ((unsigned int )tmp);
}
}
#line 187 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 214
extern  __attribute__((__nothrow__)) unsigned long long ( __attribute__((__nonnull__(1),
__leaf__)) strtoull)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                     int __base ) ;
#line 129 "./include/common.h"
__inline static unsigned long simple_strtoul(char const   *snum , int *error ) 
{ 
  char *endptr ;
  unsigned long ret ;
  unsigned long tmp ;

  {
  {
#line 129
  tmp = strtoul((char const   */* __restrict  */)snum, (char **/* __restrict  */)(& endptr),
                0);
#line 129
  ret = tmp;
  }
#line 129
  if (error) {
#line 129
    if (! *snum) {
      {
#line 129
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: %s: unable to parse the number \'%s\'\n",
              "flash_erase", "strtoul", snum);
#line 129
      *error = 1;
      }
    } else
#line 129
    if (*endptr) {
      {
#line 129
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: %s: unable to parse the number \'%s\'\n",
              "flash_erase", "strtoul", snum);
#line 129
      *error = 1;
      }
    }
  }
#line 129
  return (ret);
}
}
#line 130 "./include/common.h"
__inline static unsigned long long simple_strtoull(char const   *snum , int *error ) 
{ 
  char *endptr ;
  unsigned long long ret ;
  unsigned long long tmp ;

  {
  {
#line 130
  tmp = strtoull((char const   */* __restrict  */)snum, (char **/* __restrict  */)(& endptr),
                 0);
#line 130
  ret = tmp;
  }
#line 130
  if (error) {
#line 130
    if (! *snum) {
      {
#line 130
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: %s: unable to parse the number \'%s\'\n",
              "flash_erase", "strtoull", snum);
#line 130
      *error = 1;
      }
    } else
#line 130
    if (*endptr) {
      {
#line 130
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: %s: unable to parse the number \'%s\'\n",
              "flash_erase", "strtoull", snum);
#line 130
      *error = 1;
      }
    }
  }
#line 130
  return (ret);
}
}
#line 22 "./include/mtd/jffs2-user.h"
int target_endian ;
#line 42 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/flash_erase.c"
static char const   *mtd_device  ;
#line 44 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/flash_erase.c"
static int quiet___0  ;
#line 45 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/flash_erase.c"
static int jffs2  ;
#line 46 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/flash_erase.c"
static int noskipbad  ;
#line 47 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/flash_erase.c"
static int unlock  ;
#line 49 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/flash_erase.c"
static struct jffs2_unknown_node cleanmarker  ;
#line 50 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/flash_erase.c"
int target_endian  =    1234;
#line 52 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/flash_erase.c"
static void show_progress(struct mtd_dev_info *mtd , uint64_t start , int eb , int eb_start ,
                          int eb_cnt ) 
{ 


  {
  {
#line 55
  while (1) {
    while_continue: /* CIL Label */ ;
#line 55
    if (! quiet___0) {
      {
#line 55
      printf((char const   */* __restrict  */)"\rErasing %d Kibyte @ %lx -- %2i %% complete ",
             mtd->eb_size / 1024, start, ((eb - eb_start) * 100) / eb_cnt);
      }
    }
#line 55
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 57
  fflush(stdout);
  }
#line 58
  return;
}
}
#line 60 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/flash_erase.c"
static void display_help___0(void) 
{ 


  {
  {
#line 62
  printf((char const   */* __restrict  */)"Usage: %s [options] MTD_DEVICE <start offset> <block count>\nErase blocks of the specified MTD device.\nSpecify a count of 0 to erase to end of device.\n\n  -j, --jffs2       format the device for jffs2\n  -N, --noskipbad   don\'t skip bad blocks\n  -u, --unlock      unlock sectors before erasing\n  -q, --quiet       do not display progress messages\n      --silent      same as --quiet\n      --help        display this help and exit\n      --version     output version information and exit\n",
         "flash_erase");
  }
#line 74
  return;
}
}
#line 76 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/flash_erase.c"
static void display_version___0(void) 
{ 


  {
  {
#line 78
  printf((char const   */* __restrict  */)"%1$s version 1.5.0\n\nCopyright (C) 2000 Arcom Control Systems Ltd\n\n%1$s comes with NO WARRANTY\nto the extent permitted by law.\n\nYou may redistribute copies of %1$s\nunder the terms of the GNU General Public Licence.\nSee the file `COPYING\' for more information.\n",
         "flash_erase");
  }
#line 89
  return;
}
}
#line 107 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/flash_erase.c"
static char const   *short_options___0  =    "jNqu";
#line 108 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/flash_erase.c"
static struct option  const  long_options___0[8]  = 
#line 108
  {      {"help", 0, (int *)0, 0}, 
        {"version", 0, (int *)0, 0}, 
        {"jffs2", 0, (int *)0, 'j'}, 
        {"noskipbad", 0, (int *)0, 'N'}, 
        {"quiet", 0, (int *)0, 'q'}, 
        {"silent", 0, (int *)0, 'q'}, 
        {"unlock", 0, (int *)0, 'u'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 117 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static char const   *allPp___0[17]  = 
#line 117 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
  {      (char const   *)((void *)0),      (char const   *)((void *)0),      "111",      "1101", 
        "11001",      "101001",      "1100001",      "10010001", 
        "101110001",      "1000100001",      "10010000001",      "101000000001", 
        "1100101000001",      "11011000000001",      "110000100010001",      "1100000000000001", 
        "11010000000010001"};
#line 147 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static gf gf_exp___0[2 * ((1 << 8) - 1)]  ;
#line 148 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static int gf_log___0[((1 << 8) - 1) + 1]  ;
#line 149 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static gf inverse___0[((1 << 8) - 1) + 1]  ;
#line 179 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static gf gf_mul_table___0[((1 << 8) - 1) + 1][((1 << 8) - 1) + 1]  ;
#line 187 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static void init_mul_table___0(void) 
{ 
  int i ;
  int j ;
  gf tmp ;
  gf tmp___0 ;

  {
#line 191
  i = 0;
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 191
    if (! (i < ((1 << 8) - 1) + 1)) {
#line 191
      goto while_break;
    }
#line 192
    j = 0;
    {
#line 192
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 192
      if (! (j < ((1 << 8) - 1) + 1)) {
#line 192
        goto while_break___0;
      }
      {
#line 193
      tmp = modnn(gf_log___0[i] + gf_log___0[j]);
#line 193
      gf_mul_table___0[i][j] = gf_exp___0[tmp];
#line 192
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 191
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 195
  j = 0;
  {
#line 195
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 195
    if (! (j < ((1 << 8) - 1) + 1)) {
#line 195
      goto while_break___1;
    }
#line 196
    tmp___0 = (gf )0;
#line 196
    gf_mul_table___0[j][0] = tmp___0;
#line 196
    gf_mul_table___0[0][j] = tmp___0;
#line 195
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 197
  return;
}
}
#line 228 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static void *my_malloc___0(int sz , char const   *err_string ) 
{ 
  void *p ;
  void *tmp ;

  {
  {
#line 231
  tmp = malloc((size_t )sz);
#line 231
  p = tmp;
  }
#line 232
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 233
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-- malloc failure allocating %s\n",
            err_string);
#line 234
    exit(1);
    }
  }
#line 236
  return (p);
}
}
#line 245 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static void generate_gf___0(void) 
{ 
  int i ;
  gf mask ;
  char const   *Pp ;

  {
#line 250
  Pp = allPp___0[8];
#line 252
  mask = (gf )1;
#line 253
  gf_exp___0[8] = (gf )0;
#line 260
  i = 0;
  {
#line 260
  while (1) {
    while_continue: /* CIL Label */ ;
#line 260
    if (! (i < 8)) {
#line 260
      goto while_break;
    }
#line 261
    gf_exp___0[i] = mask;
#line 262
    gf_log___0[gf_exp___0[i]] = i;
#line 267
    if ((int const   )*(Pp + i) == 49) {
#line 268
      gf_exp___0[8] = (gf )((int )gf_exp___0[8] ^ (int )mask);
    }
#line 260
    i ++;
#line 260
    mask = (gf )((int )mask << 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 274
  gf_log___0[gf_exp___0[8]] = 8;
#line 281
  mask = (gf )(1 << 7);
#line 282
  i = 9;
  {
#line 282
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 282
    if (! (i < (1 << 8) - 1)) {
#line 282
      goto while_break___0;
    }
#line 283
    if ((int )gf_exp___0[i - 1] >= (int )mask) {
#line 284
      gf_exp___0[i] = (gf )((int )gf_exp___0[8] ^ (((int )gf_exp___0[i - 1] ^ (int )mask) << 1));
    } else {
#line 286
      gf_exp___0[i] = (gf )((int )gf_exp___0[i - 1] << 1);
    }
#line 287
    gf_log___0[gf_exp___0[i]] = i;
#line 282
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 292
  gf_log___0[0] = (1 << 8) - 1;
#line 294
  i = 0;
  {
#line 294
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 294
    if (! (i < (1 << 8) - 1)) {
#line 294
      goto while_break___1;
    }
#line 295
    gf_exp___0[i + ((1 << 8) - 1)] = gf_exp___0[i];
#line 294
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 302
  inverse___0[0] = (gf )0;
#line 303
  inverse___0[1] = (gf )1;
#line 304
  i = 2;
  {
#line 304
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 304
    if (! (i <= (1 << 8) - 1)) {
#line 304
      goto while_break___2;
    }
#line 305
    inverse___0[i] = gf_exp___0[((1 << 8) - 1) - gf_log___0[i]];
#line 304
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 306
  return;
}
}
#line 325 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static void addmul1___0(gf *dst1 , gf *src1 , gf c , int sz ) 
{ 
  register gf *__gf_mulc_ ;
  register gf *dst ;
  register gf *src ;
  gf *lim ;

  {
#line 329
  dst = dst1;
#line 329
  src = src1;
#line 330
  lim = dst + ((sz - 16) + 1);
#line 332
  __gf_mulc_ = gf_mul_table___0[c];
  {
#line 335
  while (1) {
    while_continue: /* CIL Label */ ;
#line 335
    if (! ((unsigned long )dst < (unsigned long )lim)) {
#line 335
      goto while_break;
    }
#line 336
    *(dst + 0) = (gf )((int )*(dst + 0) ^ (int )*(__gf_mulc_ + *(src + 0)));
#line 337
    *(dst + 1) = (gf )((int )*(dst + 1) ^ (int )*(__gf_mulc_ + *(src + 1)));
#line 338
    *(dst + 2) = (gf )((int )*(dst + 2) ^ (int )*(__gf_mulc_ + *(src + 2)));
#line 339
    *(dst + 3) = (gf )((int )*(dst + 3) ^ (int )*(__gf_mulc_ + *(src + 3)));
#line 341
    *(dst + 4) = (gf )((int )*(dst + 4) ^ (int )*(__gf_mulc_ + *(src + 4)));
#line 342
    *(dst + 5) = (gf )((int )*(dst + 5) ^ (int )*(__gf_mulc_ + *(src + 5)));
#line 343
    *(dst + 6) = (gf )((int )*(dst + 6) ^ (int )*(__gf_mulc_ + *(src + 6)));
#line 344
    *(dst + 7) = (gf )((int )*(dst + 7) ^ (int )*(__gf_mulc_ + *(src + 7)));
#line 347
    *(dst + 8) = (gf )((int )*(dst + 8) ^ (int )*(__gf_mulc_ + *(src + 8)));
#line 348
    *(dst + 9) = (gf )((int )*(dst + 9) ^ (int )*(__gf_mulc_ + *(src + 9)));
#line 349
    *(dst + 10) = (gf )((int )*(dst + 10) ^ (int )*(__gf_mulc_ + *(src + 10)));
#line 350
    *(dst + 11) = (gf )((int )*(dst + 11) ^ (int )*(__gf_mulc_ + *(src + 11)));
#line 351
    *(dst + 12) = (gf )((int )*(dst + 12) ^ (int )*(__gf_mulc_ + *(src + 12)));
#line 352
    *(dst + 13) = (gf )((int )*(dst + 13) ^ (int )*(__gf_mulc_ + *(src + 13)));
#line 353
    *(dst + 14) = (gf )((int )*(dst + 14) ^ (int )*(__gf_mulc_ + *(src + 14)));
#line 354
    *(dst + 15) = (gf )((int )*(dst + 15) ^ (int )*(__gf_mulc_ + *(src + 15)));
#line 335
    dst += 16;
#line 335
    src += 16;
  }
  while_break: /* CIL Label */ ;
  }
#line 358
  lim += 15;
  {
#line 359
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 359
    if (! ((unsigned long )dst < (unsigned long )lim)) {
#line 359
      goto while_break___0;
    }
#line 360
    *dst = (gf )((int )*dst ^ (int )*(__gf_mulc_ + *src));
#line 359
    dst ++;
#line 359
    src ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 361
  return;
}
}
#line 366 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static void matmul___0(gf *a , gf *b , gf *c , int n , int k , int m ) 
{ 
  int row ;
  int col ;
  int i ;
  gf *pa ;
  gf *pb ;
  gf acc ;

  {
#line 371
  row = 0;
  {
#line 371
  while (1) {
    while_continue: /* CIL Label */ ;
#line 371
    if (! (row < n)) {
#line 371
      goto while_break;
    }
#line 372
    col = 0;
    {
#line 372
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 372
      if (! (col < m)) {
#line 372
        goto while_break___0;
      }
#line 373
      pa = a + row * k;
#line 374
      pb = b + col;
#line 375
      acc = (gf )0;
#line 376
      i = 0;
      {
#line 376
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 376
        if (! (i < k)) {
#line 376
          goto while_break___1;
        }
#line 377
        acc = (gf )((int )acc ^ (int )gf_mul_table___0[*pa][*pb]);
#line 376
        i ++;
#line 376
        pa ++;
#line 376
        pb += m;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 378
      *(c + (row * m + col)) = acc;
#line 372
      col ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 371
    row ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 381
  return;
}
}
#line 410 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static int invert_mat___0(gf *src , int k ) 
{ 
  gf c ;
  gf *p ;
  int irow ;
  int icol ;
  int row ;
  int col ;
  int i ;
  int ix ;
  int error ;
  int *indxc ;
  void *tmp ;
  int *indxr ;
  void *tmp___0 ;
  int *ipiv ;
  void *tmp___1 ;
  gf *id_row ;
  void *tmp___2 ;
  gf *temp_row ;
  void *tmp___3 ;
  gf *pivot_row ;
  gf tmp___4 ;
  int tmp___5 ;
  gf tmp___6 ;

  {
  {
#line 416
  error = 1;
#line 417
  tmp = my_malloc___0((int )((unsigned long )k * sizeof(int )), "indxc");
#line 417
  indxc = (int *)tmp;
#line 418
  tmp___0 = my_malloc___0((int )((unsigned long )k * sizeof(int )), "indxr");
#line 418
  indxr = (int *)tmp___0;
#line 419
  tmp___1 = my_malloc___0((int )((unsigned long )k * sizeof(int )), "ipiv");
#line 419
  ipiv = (int *)tmp___1;
#line 420
  tmp___2 = my_malloc___0((int )((unsigned long )k * sizeof(gf )), " ## __LINE__ ## ");
#line 420
  id_row = (gf *)tmp___2;
#line 421
  tmp___3 = my_malloc___0((int )((unsigned long )k * sizeof(gf )), " ## __LINE__ ## ");
#line 421
  temp_row = (gf *)tmp___3;
#line 423
  memset((void *)id_row, '\000', (unsigned long )k * sizeof(gf ));
#line 428
  i = 0;
  }
  {
#line 428
  while (1) {
    while_continue: /* CIL Label */ ;
#line 428
    if (! (i < k)) {
#line 428
      goto while_break;
    }
#line 429
    *(ipiv + i) = 0;
#line 428
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 431
  col = 0;
  {
#line 431
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 431
    if (! (col < k)) {
#line 431
      goto while_break___0;
    }
#line 437
    icol = -1;
#line 437
    irow = icol;
#line 438
    if (*(ipiv + col) != 1) {
#line 438
      if ((int )*(src + (col * k + col)) != 0) {
#line 439
        irow = col;
#line 440
        icol = col;
#line 441
        goto found_piv;
      }
    }
#line 443
    row = 0;
    {
#line 443
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 443
      if (! (row < k)) {
#line 443
        goto while_break___1;
      }
#line 444
      if (*(ipiv + row) != 1) {
#line 445
        ix = 0;
        {
#line 445
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 445
          if (! (ix < k)) {
#line 445
            goto while_break___2;
          }
#line 447
          if (*(ipiv + ix) == 0) {
#line 448
            if ((int )*(src + (row * k + ix)) != 0) {
#line 449
              irow = row;
#line 450
              icol = ix;
#line 451
              goto found_piv;
            }
          } else
#line 453
          if (*(ipiv + ix) > 1) {
            {
#line 454
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"singular matrix\n");
            }
#line 455
            goto fail;
          }
#line 445
          ix ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 443
      row ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 460
    if (icol == -1) {
      {
#line 461
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"XXX pivot not found!\n");
      }
#line 462
      goto fail;
    }
    found_piv: 
#line 465
    (*(ipiv + icol)) ++;
#line 471
    if (irow != icol) {
#line 472
      ix = 0;
      {
#line 472
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 472
        if (! (ix < k)) {
#line 472
          goto while_break___3;
        }
#line 473
        tmp___4 = *(src + (irow * k + ix));
#line 473
        *(src + (irow * k + ix)) = *(src + (icol * k + ix));
#line 473
        *(src + (icol * k + ix)) = tmp___4;
#line 472
        ix ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 476
    *(indxr + col) = irow;
#line 477
    *(indxc + col) = icol;
#line 478
    pivot_row = src + icol * k;
#line 479
    c = *(pivot_row + icol);
#line 480
    if ((int )c == 0) {
      {
#line 481
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"singular matrix 2\n");
      }
#line 482
      goto fail;
    }
#line 484
    if ((int )c != 1) {
#line 490
      c = inverse___0[c];
#line 491
      *(pivot_row + icol) = (gf )1;
#line 492
      ix = 0;
      {
#line 492
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 492
        if (! (ix < k)) {
#line 492
          goto while_break___4;
        }
#line 493
        *(pivot_row + ix) = gf_mul_table___0[c][*(pivot_row + ix)];
#line 492
        ix ++;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
    {
#line 502
    *(id_row + icol) = (gf )1;
#line 503
    tmp___5 = memcmp((void const   *)pivot_row, (void const   *)id_row, (unsigned long )k * sizeof(gf ));
    }
#line 503
    if (tmp___5 != 0) {
#line 504
      p = src;
#line 504
      ix = 0;
      {
#line 504
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 504
        if (! (ix < k)) {
#line 504
          goto while_break___5;
        }
#line 505
        if (ix != icol) {
#line 506
          c = *(p + icol);
#line 507
          *(p + icol) = (gf )0;
#line 508
          if ((int )c != 0) {
            {
#line 508
            addmul1___0(p, pivot_row, c, k);
            }
          }
        }
#line 504
        ix ++;
#line 504
        p += k;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
#line 512
    *(id_row + icol) = (gf )0;
#line 431
    col ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 514
  col = k - 1;
  {
#line 514
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 514
    if (! (col >= 0)) {
#line 514
      goto while_break___6;
    }
#line 515
    if (*(indxr + col) < 0) {
      {
#line 516
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"AARGH, indxr[col] %d\n",
              *(indxr + col));
      }
    } else
#line 515
    if (*(indxr + col) >= k) {
      {
#line 516
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"AARGH, indxr[col] %d\n",
              *(indxr + col));
      }
    } else
#line 517
    if (*(indxc + col) < 0) {
      {
#line 518
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"AARGH, indxc[col] %d\n",
              *(indxc + col));
      }
    } else
#line 517
    if (*(indxc + col) >= k) {
      {
#line 518
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"AARGH, indxc[col] %d\n",
              *(indxc + col));
      }
    } else
#line 520
    if (*(indxr + col) != *(indxc + col)) {
#line 521
      row = 0;
      {
#line 521
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 521
        if (! (row < k)) {
#line 521
          goto while_break___7;
        }
#line 522
        tmp___6 = *(src + (row * k + *(indxr + col)));
#line 522
        *(src + (row * k + *(indxr + col))) = *(src + (row * k + *(indxc + col)));
#line 522
        *(src + (row * k + *(indxc + col))) = tmp___6;
#line 521
        row ++;
      }
      while_break___7: /* CIL Label */ ;
      }
    }
#line 514
    col --;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 526
  error = 0;
  fail: 
  {
#line 528
  free((void *)indxc);
#line 529
  free((void *)indxr);
#line 530
  free((void *)ipiv);
#line 531
  free((void *)id_row);
#line 532
  free((void *)temp_row);
  }
#line 533
  return (error);
}
}
#line 604 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static int fec_initialized___0  =    0;
#line 605 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static void init_fec___0(void) 
{ 


  {
  {
#line 609
  generate_gf___0();
#line 613
  init_mul_table___0();
#line 616
  fec_initialized___0 = 1;
  }
#line 617
  return;
}
}
#line 755 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static int shuffle___0(gf **pkt , int *index___0 , int k ) 
{ 
  int i ;
  int c ;
  int tmp ;
  gf *tmp___0 ;

  {
#line 760
  i = 0;
  {
#line 760
  while (1) {
    while_continue: /* CIL Label */ ;
#line 760
    if (! (i < k)) {
#line 760
      goto while_break;
    }
#line 761
    if (*(index___0 + i) >= k) {
#line 762
      i ++;
    } else
#line 761
    if (*(index___0 + i) == i) {
#line 762
      i ++;
    } else {
#line 767
      c = *(index___0 + i);
#line 769
      if (*(index___0 + c) == c) {
#line 771
        return (1);
      }
#line 773
      tmp = *(index___0 + i);
#line 773
      *(index___0 + i) = *(index___0 + c);
#line 773
      *(index___0 + c) = tmp;
#line 774
      tmp___0 = *(pkt + i);
#line 774
      *(pkt + i) = *(pkt + c);
#line 774
      *(pkt + c) = tmp___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 787
  return (0);
}
}
#line 795 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static gf *build_decode_matrix___0(struct fec_parms *code , int *index___0 ) 
{ 
  int i ;
  int k ;
  gf *p ;
  gf *matrix ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 798
  k = code->k;
#line 799
  tmp = my_malloc___0((int )((unsigned long )(k * k) * sizeof(gf )), " ## __LINE__ ## ");
#line 799
  matrix = (gf *)tmp;
#line 802
  i = 0;
#line 802
  p = matrix;
  }
  {
#line 802
  while (1) {
    while_continue: /* CIL Label */ ;
#line 802
    if (! (i < k)) {
#line 802
      goto while_break;
    }
#line 804
    if (*(index___0 + i) < k) {
      {
#line 805
      memset((void *)p, '\000', (unsigned long )k * sizeof(gf ));
#line 806
      *(p + i) = (gf )1;
      }
    } else
#line 809
    if (*(index___0 + i) < code->n) {
      {
#line 810
      memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(code->enc_matrix + *(index___0 + i) * k),
             (unsigned long )k * sizeof(gf ));
      }
    } else {
      {
#line 812
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"decode: invalid index %d (max %d)\n",
              *(index___0 + i), code->n - 1);
#line 814
      free((void *)matrix);
      }
#line 815
      return ((gf *)((void *)0));
    }
#line 802
    i ++;
#line 802
    p += k;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 819
  tmp___0 = invert_mat___0(matrix, k);
  }
#line 819
  if (tmp___0) {
    {
#line 820
    free((void *)matrix);
#line 821
    matrix = (gf *)((void *)0);
    }
  }
#line 824
  return (matrix);
}
}
#line 38 "./include/xalloc.h"
static void *xmalloc___2(size_t size )  __attribute__((__unused__)) ;
#line 38 "./include/xalloc.h"
static void *xmalloc___2(size_t size ) 
{ 
  void *ptr ;
  void *tmp ;
  int _err ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 41
  tmp = malloc(size);
#line 41
  ptr = tmp;
  }
#line 43
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 43
    if (size != 0UL) {
      {
#line 44
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 44
        tmp___0 = __errno_location();
#line 44
        _err = *tmp___0;
#line 44
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: out of memory\n",
                "libmtd");
#line 44
        tmp___1 = strerror(_err);
#line 44
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
                (int )sizeof("libmtd") + 1, "", _err, tmp___1);
#line 44
        exit(-1);
        }
#line 44
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 45
  return (ptr);
}
}
#line 48
static void *xcalloc___0(size_t nmemb , size_t size )  __attribute__((__unused__)) ;
#line 48 "./include/xalloc.h"
static void *xcalloc___0(size_t nmemb , size_t size ) 
{ 
  void *ptr ;
  void *tmp ;
  int _err ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 51
  tmp = calloc(nmemb, size);
#line 51
  ptr = tmp;
  }
#line 53
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 53
    if (nmemb != 0UL) {
#line 53
      if (size != 0UL) {
        {
#line 54
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 54
          tmp___0 = __errno_location();
#line 54
          _err = *tmp___0;
#line 54
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: out of memory\n",
                  "libmtd");
#line 54
          tmp___1 = strerror(_err);
#line 54
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
                  (int )sizeof("libmtd") + 1, "", _err, tmp___1);
#line 54
          exit(-1);
          }
#line 54
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
  }
#line 55
  return (ptr);
}
}
#line 58
static void *xzalloc___0(size_t size )  __attribute__((__unused__)) ;
#line 58 "./include/xalloc.h"
static void *xzalloc___0(size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 61
  tmp = xcalloc___0((size_t )1, size);
  }
#line 61
  return (tmp);
}
}
#line 50 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static char *mkpath___0(char const   *path , char const   *name ) 
{ 
  char *n ;
  size_t len1 ;
  size_t tmp ;
  size_t len2 ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 53
  tmp = strlen(path);
#line 53
  len1 = tmp;
#line 54
  tmp___0 = strlen(name);
#line 54
  len2 = tmp___0;
#line 56
  tmp___1 = xmalloc___2((len1 + len2) + 2UL);
#line 56
  n = (char *)tmp___1;
#line 58
  memcpy((void */* __restrict  */)n, (void const   */* __restrict  */)path, len1);
  }
#line 59
  if ((int )*(n + (len1 - 1UL)) != 47) {
#line 60
    tmp___2 = len1;
#line 60
    len1 ++;
#line 60
    *(n + tmp___2) = (char )'/';
  }
  {
#line 62
  memcpy((void */* __restrict  */)(n + len1), (void const   */* __restrict  */)name,
         len2 + 1UL);
  }
#line 63
  return (n);
}
}
#line 76 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int read_data___0(char const   *file , void *buf , int buf_len ) 
{ 
  int fd ;
  int rd ;
  int tmp ;
  int tmp1 ;
  ssize_t tmp___0 ;
  int _err ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  ssize_t tmp___4 ;
  int _err___0 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;
  int _err___1 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;

  {
  {
#line 80
  fd = open(file, 524288);
  }
#line 81
  if (fd == -1) {
#line 82
    return (-1);
  }
  {
#line 84
  tmp___0 = read(fd, buf, (size_t )buf_len);
#line 84
  rd = (int )tmp___0;
  }
#line 85
  if (rd == -1) {
    {
#line 86
    tmp___1 = __errno_location();
#line 86
    _err = *tmp___1;
#line 86
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: cannot read \"%s\"\n",
            "libmtd", file);
#line 86
    tmp___2 = strerror(_err);
#line 86
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err, tmp___2);
    }
#line 87
    goto out_error;
  }
#line 90
  if (rd == buf_len) {
    {
#line 91
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: contents of \"%s\" is too long\n",
            "libmtd", file);
#line 92
    tmp___3 = __errno_location();
#line 92
    *tmp___3 = 22;
    }
#line 93
    goto out_error;
  }
  {
#line 96
  *((char *)buf + rd) = (char )'\000';
#line 99
  tmp___4 = read(fd, (void *)(& tmp), (size_t )1);
#line 99
  tmp1 = (int )tmp___4;
  }
#line 100
  if (tmp1 == 1) {
    {
#line 101
    tmp___5 = __errno_location();
#line 101
    _err___0 = *tmp___5;
#line 101
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: cannot read \"%s\"\n",
            "libmtd", file);
#line 101
    tmp___6 = strerror(_err___0);
#line 101
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err___0, tmp___6);
    }
#line 102
    goto out_error;
  }
#line 104
  if (tmp1) {
    {
#line 105
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: file \"%s\" contains too much data (> %d bytes)\n",
            "libmtd", file, buf_len);
#line 107
    tmp___7 = __errno_location();
#line 107
    *tmp___7 = 22;
    }
#line 108
    goto out_error;
  }
  {
#line 111
  tmp___10 = close(fd);
  }
#line 111
  if (tmp___10) {
    {
#line 112
    tmp___8 = __errno_location();
#line 112
    _err___1 = *tmp___8;
#line 112
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: close failed on \"%s\"\n",
            "libmtd", file);
#line 112
    tmp___9 = strerror(_err___1);
#line 112
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err___1, tmp___9);
    }
#line 113
    return (-1);
  }
#line 116
  return (rd);
  out_error: 
  {
#line 119
  close(fd);
  }
#line 120
  return (-1);
}
}
#line 131 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int read_major___0(char const   *file , int *major , int *minor ) 
{ 
  int ret ;
  char buf[50] ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 136
  ret = read_data___0(file, (void *)(buf), 50);
  }
#line 137
  if (ret < 0) {
#line 138
    return (ret);
  }
  {
#line 140
  ret = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%d:%d\n",
               major, minor);
  }
#line 141
  if (ret != 2) {
    {
#line 142
    tmp = __errno_location();
#line 142
    *tmp = 22;
#line 143
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: \"%s\" does not have major:minor format\n",
            "libmtd", file);
    }
#line 143
    return (-1);
  }
#line 146
  if (*major < 0) {
    {
#line 147
    tmp___0 = __errno_location();
#line 147
    *tmp___0 = 22;
#line 148
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: bad major:minor %d:%d in \"%s\"\n",
            "libmtd", *major, *minor, file);
    }
#line 148
    return (-1);
  } else
#line 146
  if (*minor < 0) {
    {
#line 147
    tmp___0 = __errno_location();
#line 147
    *tmp___0 = 22;
#line 148
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: bad major:minor %d:%d in \"%s\"\n",
            "libmtd", *major, *minor, file);
    }
#line 148
    return (-1);
  }
#line 152
  return (0);
}
}
#line 164 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int dev_get_major___0(struct libmtd *lib , int mtd_num , int *major , int *minor ) 
{ 
  size_t tmp ;
  char *file ;
  unsigned long __lengthoffile ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 166
  tmp = strlen((char const   *)lib->mtd_dev);
#line 166
  __lengthoffile = tmp + 50UL;
#line 166
  tmp___0 = __builtin_alloca(sizeof(*file) * __lengthoffile);
#line 166
  file = (char *)tmp___0;
#line 168
  sprintf((char */* __restrict  */)file, (char const   */* __restrict  */)lib->mtd_dev,
          mtd_num);
#line 169
  tmp___1 = read_major___0((char const   *)file, major, minor);
  }
#line 169
  return (tmp___1);
}
}
#line 182 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int dev_read_data___0(char const   *patt , int mtd_num , void *buf , int buf_len ) 
{ 
  size_t tmp ;
  char *file ;
  unsigned long __lengthoffile ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 184
  tmp = strlen(patt);
#line 184
  __lengthoffile = tmp + 100UL;
#line 184
  tmp___0 = __builtin_alloca(sizeof(*file) * __lengthoffile);
#line 184
  file = (char *)tmp___0;
#line 186
  sprintf((char */* __restrict  */)file, (char const   */* __restrict  */)patt, mtd_num);
#line 187
  tmp___1 = read_data___0((char const   *)file, buf, buf_len);
  }
#line 187
  return (tmp___1);
}
}
#line 199 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int read_hex_ll___0(char const   *file , long long *value ) 
{ 
  int fd ;
  int rd ;
  char buf[50] ;
  ssize_t tmp ;
  int _err ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int _err___0 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;

  {
  {
#line 204
  fd = open(file, 524288);
  }
#line 205
  if (fd == -1) {
#line 206
    return (-1);
  }
  {
#line 208
  tmp = read(fd, (void *)(buf), sizeof(buf));
#line 208
  rd = (int )tmp;
  }
#line 209
  if (rd == -1) {
    {
#line 210
    tmp___0 = __errno_location();
#line 210
    _err = *tmp___0;
#line 210
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: cannot read \"%s\"\n",
            "libmtd", file);
#line 210
    tmp___1 = strerror(_err);
#line 210
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err, tmp___1);
    }
#line 211
    goto out_error;
  }
#line 213
  if ((unsigned long )rd == sizeof(buf)) {
    {
#line 214
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: contents of \"%s\" is too long\n",
            "libmtd", file);
#line 215
    tmp___2 = __errno_location();
#line 215
    *tmp___2 = 22;
    }
#line 216
    goto out_error;
  }
  {
#line 218
  buf[rd] = (char )'\000';
#line 220
  tmp___4 = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%llx\n",
                   value);
  }
#line 220
  if (tmp___4 != 1) {
    {
#line 221
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: cannot read integer from \"%s\"\n\n",
            "libmtd", file);
#line 222
    tmp___3 = __errno_location();
#line 222
    *tmp___3 = 22;
    }
#line 223
    goto out_error;
  }
#line 226
  if (*value < 0LL) {
    {
#line 227
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: negative value %lld in \"%s\"\n",
            "libmtd", *value, file);
#line 228
    tmp___5 = __errno_location();
#line 228
    *tmp___5 = 22;
    }
#line 229
    goto out_error;
  }
  {
#line 232
  tmp___8 = close(fd);
  }
#line 232
  if (tmp___8) {
    {
#line 233
    tmp___6 = __errno_location();
#line 233
    _err___0 = *tmp___6;
#line 233
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: close failed on \"%s\"\n",
            "libmtd", file);
#line 233
    tmp___7 = strerror(_err___0);
#line 233
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err___0, tmp___7);
    }
#line 233
    return (-1);
  }
#line 235
  return (0);
  out_error: 
  {
#line 238
  close(fd);
  }
#line 239
  return (-1);
}
}
#line 251 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int read_pos_ll___0(char const   *file , long long *value ) 
{ 
  int fd ;
  int rd ;
  char buf[50] ;
  ssize_t tmp ;
  int _err ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int _err___0 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;

  {
  {
#line 256
  fd = open(file, 524288);
  }
#line 257
  if (fd == -1) {
#line 258
    return (-1);
  }
  {
#line 260
  tmp = read(fd, (void *)(buf), (size_t )50);
#line 260
  rd = (int )tmp;
  }
#line 261
  if (rd == -1) {
    {
#line 262
    tmp___0 = __errno_location();
#line 262
    _err = *tmp___0;
#line 262
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: cannot read \"%s\"\n",
            "libmtd", file);
#line 262
    tmp___1 = strerror(_err);
#line 262
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err, tmp___1);
    }
#line 263
    goto out_error;
  }
#line 265
  if (rd == 50) {
    {
#line 266
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: contents of \"%s\" is too long\n",
            "libmtd", file);
#line 267
    tmp___2 = __errno_location();
#line 267
    *tmp___2 = 22;
    }
#line 268
    goto out_error;
  }
  {
#line 271
  tmp___4 = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%lld\n",
                   value);
  }
#line 271
  if (tmp___4 != 1) {
    {
#line 272
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: cannot read integer from \"%s\"\n\n",
            "libmtd", file);
#line 273
    tmp___3 = __errno_location();
#line 273
    *tmp___3 = 22;
    }
#line 274
    goto out_error;
  }
#line 277
  if (*value < 0LL) {
    {
#line 278
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: negative value %lld in \"%s\"\n",
            "libmtd", *value, file);
#line 279
    tmp___5 = __errno_location();
#line 279
    *tmp___5 = 22;
    }
#line 280
    goto out_error;
  }
  {
#line 283
  tmp___8 = close(fd);
  }
#line 283
  if (tmp___8) {
    {
#line 284
    tmp___6 = __errno_location();
#line 284
    _err___0 = *tmp___6;
#line 284
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: close failed on \"%s\"\n",
            "libmtd", file);
#line 284
    tmp___7 = strerror(_err___0);
#line 284
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err___0, tmp___7);
    }
#line 284
    return (-1);
  }
#line 286
  return (0);
  out_error: 
  {
#line 289
  close(fd);
  }
#line 290
  return (-1);
}
}
#line 301 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int read_hex_int___0(char const   *file , int *value ) 
{ 
  long long res ;
  int tmp ;
  int *tmp___0 ;

  {
  {
#line 305
  tmp = read_hex_ll___0(file, & res);
  }
#line 305
  if (tmp) {
#line 306
    return (-1);
  }
#line 309
  if (res > 2147483647LL) {
    {
#line 310
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: value %lld read from file \"%s\" is out of range\n",
            "libmtd", res, file);
#line 312
    tmp___0 = __errno_location();
#line 312
    *tmp___0 = 22;
    }
#line 313
    return (-1);
  } else
#line 309
  if (res < (-0x7FFFFFFF-1)) {
    {
#line 310
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: value %lld read from file \"%s\" is out of range\n",
            "libmtd", res, file);
#line 312
    tmp___0 = __errno_location();
#line 312
    *tmp___0 = 22;
    }
#line 313
    return (-1);
  }
#line 316
  *value = (int )res;
#line 317
  return (0);
}
}
#line 328 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int read_pos_int___0(char const   *file , int *value ) 
{ 
  long long res ;
  int tmp ;
  int *tmp___0 ;

  {
  {
#line 332
  tmp = read_pos_ll___0(file, & res);
  }
#line 332
  if (tmp) {
#line 333
    return (-1);
  }
#line 336
  if (res > 2147483647LL) {
    {
#line 337
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: value %lld read from file \"%s\" is out of range\n",
            "libmtd", res, file);
#line 339
    tmp___0 = __errno_location();
#line 339
    *tmp___0 = 22;
    }
#line 340
    return (-1);
  }
#line 343
  *value = (int )res;
#line 344
  return (0);
}
}
#line 355 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int dev_read_hex_int___0(char const   *patt , int mtd_num , int *value ) 
{ 
  size_t tmp ;
  char *file ;
  unsigned long __lengthoffile ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 357
  tmp = strlen(patt);
#line 357
  __lengthoffile = tmp + 50UL;
#line 357
  tmp___0 = __builtin_alloca(sizeof(*file) * __lengthoffile);
#line 357
  file = (char *)tmp___0;
#line 359
  sprintf((char */* __restrict  */)file, (char const   */* __restrict  */)patt, mtd_num);
#line 360
  tmp___1 = read_hex_int___0((char const   *)file, value);
  }
#line 360
  return (tmp___1);
}
}
#line 371 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int dev_read_pos_int___0(char const   *patt , int mtd_num , int *value ) 
{ 
  size_t tmp ;
  char *file ;
  unsigned long __lengthoffile ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 373
  tmp = strlen(patt);
#line 373
  __lengthoffile = tmp + 50UL;
#line 373
  tmp___0 = __builtin_alloca(sizeof(*file) * __lengthoffile);
#line 373
  file = (char *)tmp___0;
#line 375
  sprintf((char */* __restrict  */)file, (char const   */* __restrict  */)patt, mtd_num);
#line 376
  tmp___1 = read_pos_int___0((char const   *)file, value);
  }
#line 376
  return (tmp___1);
}
}
#line 387 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int dev_read_pos_ll___0(char const   *patt , int mtd_num , long long *value ) 
{ 
  size_t tmp ;
  char *file ;
  unsigned long __lengthoffile ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 389
  tmp = strlen(patt);
#line 389
  __lengthoffile = tmp + 50UL;
#line 389
  tmp___0 = __builtin_alloca(sizeof(*file) * __lengthoffile);
#line 389
  file = (char *)tmp___0;
#line 391
  sprintf((char */* __restrict  */)file, (char const   */* __restrict  */)patt, mtd_num);
#line 392
  tmp___1 = read_pos_ll___0((char const   *)file, value);
  }
#line 392
  return (tmp___1);
}
}
#line 402 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int type_str2int___0(char const   *str ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 404
  tmp = strcmp(str, "nand");
  }
#line 404
  if (! tmp) {
#line 405
    return (4);
  }
  {
#line 406
  tmp___0 = strcmp(str, "nor");
  }
#line 406
  if (! tmp___0) {
#line 407
    return (3);
  }
  {
#line 408
  tmp___1 = strcmp(str, "rom");
  }
#line 408
  if (! tmp___1) {
#line 409
    return (2);
  }
  {
#line 410
  tmp___2 = strcmp(str, "absent");
  }
#line 410
  if (! tmp___2) {
#line 411
    return (0);
  }
  {
#line 412
  tmp___3 = strcmp(str, "dataflash");
  }
#line 412
  if (! tmp___3) {
#line 413
    return (6);
  }
  {
#line 414
  tmp___4 = strcmp(str, "ram");
  }
#line 414
  if (! tmp___4) {
#line 415
    return (1);
  }
  {
#line 416
  tmp___5 = strcmp(str, "ubi");
  }
#line 416
  if (! tmp___5) {
#line 417
    return (7);
  }
#line 418
  return (-1);
}
}
#line 429 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int dev_node2num___0(struct libmtd *lib , char const   *node , int *mtd_num ) 
{ 
  struct stat st ;
  int i ;
  int mjr ;
  int mnr ;
  struct mtd_info info ;
  int _err ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  int tmp___5 ;
  int mjr1 ;
  int mnr1 ;
  int ret ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;

  {
  {
#line 435
  tmp___1 = stat((char const   */* __restrict  */)node, (struct stat */* __restrict  */)(& st));
  }
#line 435
  if (tmp___1) {
    {
#line 436
    tmp = __errno_location();
#line 436
    _err = *tmp;
#line 436
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: cannot get information about \"%s\"\n",
            "libmtd", node);
#line 436
    tmp___0 = strerror(_err);
#line 436
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err, tmp___0);
    }
#line 436
    return (-1);
  }
#line 438
  if (! ((st.st_mode & 61440U) == 8192U)) {
    {
#line 439
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: \"%s\" is not a character device\n",
            "libmtd", node);
#line 440
    tmp___2 = __errno_location();
#line 440
    *tmp___2 = 22;
    }
#line 441
    return (-1);
  }
  {
#line 444
  tmp___3 = gnu_dev_major((unsigned long long )st.st_rdev);
#line 444
  mjr = (int )tmp___3;
#line 445
  tmp___4 = gnu_dev_minor((unsigned long long )st.st_rdev);
#line 445
  mnr = (int )tmp___4;
#line 447
  tmp___5 = mtd_get_info((libmtd_t )((libmtd_t *)lib), & info);
  }
#line 447
  if (tmp___5) {
#line 448
    return (-1);
  }
#line 450
  i = info.lowest_mtd_num;
  {
#line 450
  while (1) {
    while_continue: /* CIL Label */ ;
#line 450
    if (! (i <= info.highest_mtd_num)) {
#line 450
      goto while_break;
    }
    {
#line 453
    ret = dev_get_major___0(lib, i, & mjr1, & mnr1);
    }
#line 454
    if (ret) {
      {
#line 455
      tmp___6 = __errno_location();
      }
#line 455
      if (*tmp___6 == 2) {
#line 456
        goto __Cont;
      }
      {
#line 457
      tmp___7 = __errno_location();
      }
#line 457
      if (! *tmp___7) {
#line 458
        goto while_break;
      }
#line 459
      return (-1);
    }
#line 462
    if (mjr1 == mjr) {
#line 462
      if (mnr1 == mnr) {
        {
#line 463
        tmp___8 = __errno_location();
#line 463
        *tmp___8 = 0;
#line 464
        *mtd_num = i;
        }
#line 465
        return (0);
      }
    }
    __Cont: /* CIL Label */ 
#line 450
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 469
  tmp___9 = __errno_location();
#line 469
  *tmp___9 = 19;
  }
#line 470
  return (-1);
}
}
#line 489 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int sysfs_is_supported___0(struct libmtd *lib ) 
{ 
  int fd ;
  int num ;
  DIR *sysfs_mtd ;
  size_t tmp ;
  char *file ;
  unsigned long __lengthoffile ;
  void *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int _err ;
  int *tmp___3 ;
  char *tmp___4 ;
  int ret ;
  int mtd_num ;
  char tmp_buf[256] ;
  struct dirent *dirent ;
  int *tmp___5 ;
  size_t tmp___6 ;
  int _err___0 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int _err___1 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;

  {
  {
#line 491
  num = -1;
#line 493
  tmp = strlen((char const   *)lib->mtd_name);
#line 493
  __lengthoffile = tmp + 10UL;
#line 493
  tmp___0 = __builtin_alloca(sizeof(*file) * __lengthoffile);
#line 493
  file = (char *)tmp___0;
#line 495
  sysfs_mtd = opendir((char const   *)lib->sysfs_mtd);
  }
#line 496
  if (! sysfs_mtd) {
    {
#line 497
    tmp___2 = __errno_location();
    }
#line 497
    if (*tmp___2 == 2) {
      {
#line 498
      tmp___1 = __errno_location();
#line 498
      *tmp___1 = 0;
      }
#line 499
      return (0);
    }
    {
#line 501
    tmp___3 = __errno_location();
#line 501
    _err = *tmp___3;
#line 501
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: cannot open \"%s\"\n",
            "libmtd", lib->sysfs_mtd);
#line 501
    tmp___4 = strerror(_err);
#line 501
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err, tmp___4);
    }
#line 501
    return (-1);
  }
  {
#line 508
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 513
    dirent = readdir(sysfs_mtd);
    }
#line 514
    if (! dirent) {
#line 515
      goto while_break;
    }
    {
#line 517
    tmp___6 = strlen((char const   *)(dirent->d_name));
    }
#line 517
    if (tmp___6 >= 255UL) {
      {
#line 518
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: invalid entry in %s: \"%s\"\n",
              "libmtd", lib->sysfs_mtd, dirent->d_name);
#line 520
      tmp___5 = __errno_location();
#line 520
      *tmp___5 = 22;
#line 521
      closedir(sysfs_mtd);
      }
#line 522
      return (-1);
    }
    {
#line 525
    ret = sscanf((char const   */* __restrict  */)(dirent->d_name), (char const   */* __restrict  */)"mtd%d%s",
                 & mtd_num, tmp_buf);
    }
#line 527
    if (ret == 1) {
#line 528
      num = mtd_num;
#line 529
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 533
  tmp___9 = closedir(sysfs_mtd);
  }
#line 533
  if (tmp___9) {
    {
#line 534
    tmp___7 = __errno_location();
#line 534
    _err___0 = *tmp___7;
#line 534
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: closedir failed on \"%s\"\n",
            "libmtd", lib->sysfs_mtd);
#line 534
    tmp___8 = strerror(_err___0);
#line 534
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err___0, tmp___8);
    }
#line 534
    return (-1);
  }
#line 536
  if (num == -1) {
#line 538
    return (0);
  }
  {
#line 540
  sprintf((char */* __restrict  */)file, (char const   */* __restrict  */)lib->mtd_name,
          num);
#line 541
  fd = open((char const   *)file, 524288);
  }
#line 542
  if (fd == -1) {
#line 543
    return (0);
  }
  {
#line 545
  tmp___12 = close(fd);
  }
#line 545
  if (tmp___12) {
    {
#line 546
    tmp___10 = __errno_location();
#line 546
    _err___1 = *tmp___10;
#line 546
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: close failed on \"%s\"\n",
            "libmtd", file);
#line 546
    tmp___11 = strerror(_err___1);
#line 546
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err___1, tmp___11);
    }
#line 547
    return (-1);
  }
#line 550
  return (1);
}
}
#line 803 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int mtd_valid_erase_block___0(struct mtd_dev_info  const  *mtd , int eb ) 
{ 
  int *tmp ;

  {
#line 805
  if (eb < 0) {
    {
#line 806
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: bad eraseblock number %d, mtd%d has %d eraseblocks\n",
            "libmtd", eb, mtd->mtd_num, mtd->eb_cnt);
#line 808
    tmp = __errno_location();
#line 808
    *tmp = 22;
    }
#line 809
    return (-1);
  } else
#line 805
  if (eb >= (int )mtd->eb_cnt) {
    {
#line 806
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: bad eraseblock number %d, mtd%d has %d eraseblocks\n",
            "libmtd", eb, mtd->mtd_num, mtd->eb_cnt);
#line 808
    tmp = __errno_location();
#line 808
    *tmp = 22;
    }
#line 809
    return (-1);
  }
#line 811
  return (0);
}
}
#line 814 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int mtd_xlock___0(struct mtd_dev_info  const  *mtd , int fd , int eb , int req ,
                         char const   *sreq ) 
{ 
  int ret ;
  struct erase_info_user ei ;
  int tmp ;

  {
  {
#line 820
  ret = mtd_valid_erase_block___0(mtd, eb);
  }
#line 821
  if (ret) {
#line 822
    return (ret);
  }
  {
#line 824
  ei.start = (__u32 )(eb * (int )mtd->eb_size);
#line 825
  ei.length = (__u32 )mtd->eb_size;
#line 827
  ret = ioctl(fd, (unsigned long )req, & ei);
  }
#line 828
  if (ret < 0) {
    {
#line 829
    tmp = mtd_ioctl_error(mtd, eb, sreq);
    }
#line 829
    return (tmp);
  }
#line 831
  return (0);
}
}
#line 929 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static uint8_t patterns___0[3]  = {      (uint8_t )165,      (uint8_t )90,      (uint8_t )0};
#line 940 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int check_pattern___0(void const   *buf , uint8_t patt , int size ) 
{ 
  int i ;

  {
#line 944
  i = 0;
  {
#line 944
  while (1) {
    while_continue: /* CIL Label */ ;
#line 944
    if (! (i < size)) {
#line 944
      goto while_break;
    }
#line 945
    if ((int const   )*((uint8_t const   *)buf + i) != (int const   )patt) {
#line 946
      return (0);
    }
#line 944
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 947
  return (1);
}
}
#line 1080 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int legacy_auto_oob_layout___0(struct mtd_dev_info  const  *mtd , int fd ,
                                      int ooblen , void *oob ) 
{ 
  struct nand_oobinfo old_oobinfo ;
  int start ;
  int len ;
  uint8_t *tmp_buf ;
  int _err ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int i ;
  int tags_pos ;

  {
  {
#line 1087
  tmp___1 = ioctl(fd, (unsigned long )(((2U << 30) | (unsigned int )(77 << 8)) | 10U) | (sizeof(struct nand_oobinfo ) << 16),
                  & old_oobinfo);
  }
#line 1087
  if (tmp___1) {
    {
#line 1088
    tmp = __errno_location();
#line 1088
    _err = *tmp;
#line 1088
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: MEMGETOOBSEL failed\n",
            "libmtd");
#line 1088
    tmp___0 = strerror(_err);
#line 1088
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err, tmp___0);
    }
#line 1088
    return (-1);
  }
  {
#line 1090
  tmp___2 = malloc((size_t )ooblen);
#line 1090
  tmp_buf = (uint8_t *)tmp___2;
#line 1091
  memcpy((void */* __restrict  */)tmp_buf, (void const   */* __restrict  */)oob, (size_t )ooblen);
  }
#line 1097
  if (old_oobinfo.useecc == 2U) {
#line 1098
    tags_pos = 0;
#line 1099
    i = 0;
    {
#line 1099
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1099
      if (! old_oobinfo.oobfree[i][1]) {
#line 1099
        goto while_break;
      }
      {
#line 1101
      start = (int )old_oobinfo.oobfree[i][0];
#line 1102
      len = (int )old_oobinfo.oobfree[i][1];
#line 1103
      memcpy((void */* __restrict  */)(oob + start), (void const   */* __restrict  */)(tmp_buf + tags_pos),
             (size_t )len);
#line 1104
      tags_pos += len;
#line 1099
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1108
    start = (int )old_oobinfo.eccbytes;
#line 1109
    len = (int )(mtd->oob_size - (int const   )start);
#line 1110
    memcpy((void */* __restrict  */)(oob + start), (void const   */* __restrict  */)(tmp_buf + start),
           (size_t )len);
    }
  }
#line 1113
  return (0);
}
}
#line 38 "./include/xalloc.h"
static void *xmalloc___3(size_t size )  __attribute__((__unused__)) ;
#line 38 "./include/xalloc.h"
static void *xmalloc___3(size_t size ) 
{ 
  void *ptr ;
  void *tmp ;
  int _err ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 41
  tmp = malloc(size);
#line 41
  ptr = tmp;
  }
#line 43
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 43
    if (size != 0UL) {
      {
#line 44
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 44
        tmp___0 = __errno_location();
#line 44
        _err = *tmp___0;
#line 44
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: out of memory\n",
                "libmtd");
#line 44
        tmp___1 = strerror(_err);
#line 44
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
                (int )sizeof("libmtd") + 1, "", _err, tmp___1);
#line 44
        exit(-1);
        }
#line 44
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 45
  return (ptr);
}
}
#line 70 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd_legacy.c"
static int proc_parse_start___0(struct proc_parse_info *pi ) 
{ 
  int fd ;
  int ret ;
  void *tmp ;
  ssize_t tmp___0 ;
  int _err ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 74
  fd = open("/proc/mtd", 0);
  }
#line 75
  if (fd == -1) {
#line 76
    return (-1);
  }
  {
#line 78
  tmp = xmalloc___3((size_t )4096);
#line 78
  pi->buf = (char *)tmp;
#line 80
  tmp___0 = read(fd, (void *)pi->buf, (size_t )4096);
#line 80
  ret = (int )tmp___0;
  }
#line 81
  if (ret == -1) {
    {
#line 82
    tmp___1 = __errno_location();
#line 82
    _err = *tmp___1;
#line 82
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: cannot read \"%s\"\n",
            "libmtd", "/proc/mtd");
#line 82
    tmp___2 = strerror(_err);
#line 82
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err, tmp___2);
    }
#line 83
    goto out_free;
  }
#line 86
  if ((unsigned long )ret < sizeof("dev:    size   erasesize  name\n") - 1UL) {
    {
#line 88
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: \"%s\" does not start with \"%s\"\n",
            "libmtd", "/proc/mtd", "dev:    size   erasesize  name\n");
    }
#line 90
    goto out_free;
  } else {
    {
#line 86
    tmp___3 = memcmp((void const   *)pi->buf, (void const   *)"dev:    size   erasesize  name\n",
                     sizeof("dev:    size   erasesize  name\n") - 1UL);
    }
#line 86
    if (tmp___3) {
      {
#line 88
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: \"%s\" does not start with \"%s\"\n",
              "libmtd", "/proc/mtd", "dev:    size   erasesize  name\n");
      }
#line 90
      goto out_free;
    }
  }
  {
#line 93
  pi->data_size = ret;
#line 94
  pi->next = pi->buf + (sizeof("dev:    size   erasesize  name\n") - 1UL);
#line 96
  close(fd);
  }
#line 97
  return (0);
  out_free: 
  {
#line 100
  free((void *)pi->buf);
#line 101
  close(fd);
  }
#line 102
  return (-1);
}
}
#line 105 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd_legacy.c"
static int proc_parse_next___0(struct proc_parse_info *pi ) 
{ 
  int ret ;
  int len ;
  int pos ;
  char *p ;
  char *p1 ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 107
  pos = (int )(pi->next - pi->buf);
#line 110
  if (pos >= pi->data_size) {
    {
#line 111
    free((void *)pi->buf);
    }
#line 112
    return (0);
  }
  {
#line 115
  ret = sscanf((char const   */* __restrict  */)pi->next, (char const   */* __restrict  */)"mtd%d: %llx %x",
               & pi->mtd_num, & pi->size, & pi->eb_size);
  }
#line 117
  if (ret != 3) {
    {
#line 118
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: \"%s\" pattern not found\n",
            "libmtd", "mtd%d: %llx %x");
    }
#line 118
    return (-1);
  }
  {
#line 120
  tmp = memchr((void const   *)pi->next, '\"', (size_t )(pi->data_size - pos));
#line 120
  p = (char *)tmp;
  }
#line 121
  if (! p) {
    {
#line 122
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: opening \" not found\n",
            "libmtd");
    }
#line 122
    return (-1);
  }
#line 123
  p ++;
#line 124
  pos = (int )(p - pi->buf);
#line 125
  if (pos >= pi->data_size) {
    {
#line 126
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: opening \" not found\n",
            "libmtd");
    }
#line 126
    return (-1);
  }
  {
#line 128
  tmp___0 = memchr((void const   *)p, '\"', (size_t )(pi->data_size - pos));
#line 128
  p1 = (char *)tmp___0;
  }
#line 129
  if (! p1) {
    {
#line 130
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: closing \" not found\n",
            "libmtd");
    }
#line 130
    return (-1);
  }
#line 131
  pos = (int )(p1 - pi->buf);
#line 132
  if (pos >= pi->data_size) {
    {
#line 133
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: closing \" not found\n",
            "libmtd");
    }
#line 133
    return (-1);
  }
#line 135
  len = (int )(p1 - p);
#line 136
  if (len > 127) {
    {
#line 137
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: too long mtd%d device name\n",
            "libmtd", pi->mtd_num);
    }
#line 137
    return (-1);
  }
  {
#line 139
  memcpy((void */* __restrict  */)(pi->name), (void const   */* __restrict  */)p,
         (size_t )len);
#line 140
  pi->name[len] = (char )'\000';
  }
#line 142
  if ((int )*(p1 + 1) != 10) {
    {
#line 143
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: opening \"\n\" not found\n",
            "libmtd");
    }
#line 143
    return (-1);
  }
#line 144
  pi->next = p1 + 2;
#line 145
  return (1);
}
}
#line 42 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libcrc32.c"
static uint32_t const   crc32_table___0[256]  = 
#line 42 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libcrc32.c"
  {      (uint32_t const   )0L,      (uint32_t const   )1996959894L,      (uint32_t const   )3993919788L,      (uint32_t const   )2567524794L, 
        (uint32_t const   )124634137L,      (uint32_t const   )1886057615L,      (uint32_t const   )3915621685L,      (uint32_t const   )2657392035L, 
        (uint32_t const   )249268274L,      (uint32_t const   )2044508324L,      (uint32_t const   )3772115230L,      (uint32_t const   )2547177864L, 
        (uint32_t const   )162941995L,      (uint32_t const   )2125561021L,      (uint32_t const   )3887607047L,      (uint32_t const   )2428444049L, 
        (uint32_t const   )498536548L,      (uint32_t const   )1789927666L,      (uint32_t const   )4089016648L,      (uint32_t const   )2227061214L, 
        (uint32_t const   )450548861L,      (uint32_t const   )1843258603L,      (uint32_t const   )4107580753L,      (uint32_t const   )2211677639L, 
        (uint32_t const   )325883990L,      (uint32_t const   )1684777152L,      (uint32_t const   )4251122042L,      (uint32_t const   )2321926636L, 
        (uint32_t const   )335633487L,      (uint32_t const   )1661365465L,      (uint32_t const   )4195302755L,      (uint32_t const   )2366115317L, 
        (uint32_t const   )997073096L,      (uint32_t const   )1281953886L,      (uint32_t const   )3579855332L,      (uint32_t const   )2724688242L, 
        (uint32_t const   )1006888145L,      (uint32_t const   )1258607687L,      (uint32_t const   )3524101629L,      (uint32_t const   )2768942443L, 
        (uint32_t const   )901097722L,      (uint32_t const   )1119000684L,      (uint32_t const   )3686517206L,      (uint32_t const   )2898065728L, 
        (uint32_t const   )853044451L,      (uint32_t const   )1172266101L,      (uint32_t const   )3705015759L,      (uint32_t const   )2882616665L, 
        (uint32_t const   )651767980L,      (uint32_t const   )1373503546L,      (uint32_t const   )3369554304L,      (uint32_t const   )3218104598L, 
        (uint32_t const   )565507253L,      (uint32_t const   )1454621731L,      (uint32_t const   )3485111705L,      (uint32_t const   )3099436303L, 
        (uint32_t const   )671266974L,      (uint32_t const   )1594198024L,      (uint32_t const   )3322730930L,      (uint32_t const   )2970347812L, 
        (uint32_t const   )795835527L,      (uint32_t const   )1483230225L,      (uint32_t const   )3244367275L,      (uint32_t const   )3060149565L, 
        (uint32_t const   )1994146192L,      (uint32_t const   )31158534L,      (uint32_t const   )2563907772L,      (uint32_t const   )4023717930L, 
        (uint32_t const   )1907459465L,      (uint32_t const   )112637215L,      (uint32_t const   )2680153253L,      (uint32_t const   )3904427059L, 
        (uint32_t const   )2013776290L,      (uint32_t const   )251722036L,      (uint32_t const   )2517215374L,      (uint32_t const   )3775830040L, 
        (uint32_t const   )2137656763L,      (uint32_t const   )141376813L,      (uint32_t const   )2439277719L,      (uint32_t const   )3865271297L, 
        (uint32_t const   )1802195444L,      (uint32_t const   )476864866L,      (uint32_t const   )2238001368L,      (uint32_t const   )4066508878L, 
        (uint32_t const   )1812370925L,      (uint32_t const   )453092731L,      (uint32_t const   )2181625025L,      (uint32_t const   )4111451223L, 
        (uint32_t const   )1706088902L,      (uint32_t const   )314042704L,      (uint32_t const   )2344532202L,      (uint32_t const   )4240017532L, 
        (uint32_t const   )1658658271L,      (uint32_t const   )366619977L,      (uint32_t const   )2362670323L,      (uint32_t const   )4224994405L, 
        (uint32_t const   )1303535960L,      (uint32_t const   )984961486L,      (uint32_t const   )2747007092L,      (uint32_t const   )3569037538L, 
        (uint32_t const   )1256170817L,      (uint32_t const   )1037604311L,      (uint32_t const   )2765210733L,      (uint32_t const   )3554079995L, 
        (uint32_t const   )1131014506L,      (uint32_t const   )879679996L,      (uint32_t const   )2909243462L,      (uint32_t const   )3663771856L, 
        (uint32_t const   )1141124467L,      (uint32_t const   )855842277L,      (uint32_t const   )2852801631L,      (uint32_t const   )3708648649L, 
        (uint32_t const   )1342533948L,      (uint32_t const   )654459306L,      (uint32_t const   )3188396048L,      (uint32_t const   )3373015174L, 
        (uint32_t const   )1466479909L,      (uint32_t const   )544179635L,      (uint32_t const   )3110523913L,      (uint32_t const   )3462522015L, 
        (uint32_t const   )1591671054L,      (uint32_t const   )702138776L,      (uint32_t const   )2966460450L,      (uint32_t const   )3352799412L, 
        (uint32_t const   )1504918807L,      (uint32_t const   )783551873L,      (uint32_t const   )3082640443L,      (uint32_t const   )3233442989L, 
        (uint32_t const   )3988292384L,      (uint32_t const   )2596254646L,      (uint32_t const   )62317068L,      (uint32_t const   )1957810842L, 
        (uint32_t const   )3939845945L,      (uint32_t const   )2647816111L,      (uint32_t const   )81470997L,      (uint32_t const   )1943803523L, 
        (uint32_t const   )3814918930L,      (uint32_t const   )2489596804L,      (uint32_t const   )225274430L,      (uint32_t const   )2053790376L, 
        (uint32_t const   )3826175755L,      (uint32_t const   )2466906013L,      (uint32_t const   )167816743L,      (uint32_t const   )2097651377L, 
        (uint32_t const   )4027552580L,      (uint32_t const   )2265490386L,      (uint32_t const   )503444072L,      (uint32_t const   )1762050814L, 
        (uint32_t const   )4150417245L,      (uint32_t const   )2154129355L,      (uint32_t const   )426522225L,      (uint32_t const   )1852507879L, 
        (uint32_t const   )4275313526L,      (uint32_t const   )2312317920L,      (uint32_t const   )282753626L,      (uint32_t const   )1742555852L, 
        (uint32_t const   )4189708143L,      (uint32_t const   )2394877945L,      (uint32_t const   )397917763L,      (uint32_t const   )1622183637L, 
        (uint32_t const   )3604390888L,      (uint32_t const   )2714866558L,      (uint32_t const   )953729732L,      (uint32_t const   )1340076626L, 
        (uint32_t const   )3518719985L,      (uint32_t const   )2797360999L,      (uint32_t const   )1068828381L,      (uint32_t const   )1219638859L, 
        (uint32_t const   )3624741850L,      (uint32_t const   )2936675148L,      (uint32_t const   )906185462L,      (uint32_t const   )1090812512L, 
        (uint32_t const   )3747672003L,      (uint32_t const   )2825379669L,      (uint32_t const   )829329135L,      (uint32_t const   )1181335161L, 
        (uint32_t const   )3412177804L,      (uint32_t const   )3160834842L,      (uint32_t const   )628085408L,      (uint32_t const   )1382605366L, 
        (uint32_t const   )3423369109L,      (uint32_t const   )3138078467L,      (uint32_t const   )570562233L,      (uint32_t const   )1426400815L, 
        (uint32_t const   )3317316542L,      (uint32_t const   )2998733608L,      (uint32_t const   )733239954L,      (uint32_t const   )1555261956L, 
        (uint32_t const   )3268935591L,      (uint32_t const   )3050360625L,      (uint32_t const   )752459403L,      (uint32_t const   )1541320221L, 
        (uint32_t const   )2607071920L,      (uint32_t const   )3965973030L,      (uint32_t const   )1969922972L,      (uint32_t const   )40735498L, 
        (uint32_t const   )2617837225L,      (uint32_t const   )3943577151L,      (uint32_t const   )1913087877L,      (uint32_t const   )83908371L, 
        (uint32_t const   )2512341634L,      (uint32_t const   )3803740692L,      (uint32_t const   )2075208622L,      (uint32_t const   )213261112L, 
        (uint32_t const   )2463272603L,      (uint32_t const   )3855990285L,      (uint32_t const   )2094854071L,      (uint32_t const   )198958881L, 
        (uint32_t const   )2262029012L,      (uint32_t const   )4057260610L,      (uint32_t const   )1759359992L,      (uint32_t const   )534414190L, 
        (uint32_t const   )2176718541L,      (uint32_t const   )4139329115L,      (uint32_t const   )1873836001L,      (uint32_t const   )414664567L, 
        (uint32_t const   )2282248934L,      (uint32_t const   )4279200368L,      (uint32_t const   )1711684554L,      (uint32_t const   )285281116L, 
        (uint32_t const   )2405801727L,      (uint32_t const   )4167216745L,      (uint32_t const   )1634467795L,      (uint32_t const   )376229701L, 
        (uint32_t const   )2685067896L,      (uint32_t const   )3608007406L,      (uint32_t const   )1308918612L,      (uint32_t const   )956543938L, 
        (uint32_t const   )2808555105L,      (uint32_t const   )3495958263L,      (uint32_t const   )1231636301L,      (uint32_t const   )1047427035L, 
        (uint32_t const   )2932959818L,      (uint32_t const   )3654703836L,      (uint32_t const   )1088359270L,      (uint32_t const   )936918000L, 
        (uint32_t const   )2847714899L,      (uint32_t const   )3736837829L,      (uint32_t const   )1202900863L,      (uint32_t const   )817233897L, 
        (uint32_t const   )3183342108L,      (uint32_t const   )3401237130L,      (uint32_t const   )1404277552L,      (uint32_t const   )615818150L, 
        (uint32_t const   )3134207493L,      (uint32_t const   )3453421203L,      (uint32_t const   )1423857449L,      (uint32_t const   )601450431L, 
        (uint32_t const   )3009837614L,      (uint32_t const   )3294710456L,      (uint32_t const   )1567103746L,      (uint32_t const   )711928724L, 
        (uint32_t const   )3020668471L,      (uint32_t const   )3272380065L,      (uint32_t const   )1510334235L,      (uint32_t const   )755167117L};
#line 117 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static char const   *allPp___1[17]  = 
#line 117 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
  {      (char const   *)((void *)0),      (char const   *)((void *)0),      "111",      "1101", 
        "11001",      "101001",      "1100001",      "10010001", 
        "101110001",      "1000100001",      "10010000001",      "101000000001", 
        "1100101000001",      "11011000000001",      "110000100010001",      "1100000000000001", 
        "11010000000010001"};
#line 147 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static gf gf_exp___1[2 * ((1 << 8) - 1)]  ;
#line 148 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static int gf_log___1[((1 << 8) - 1) + 1]  ;
#line 149 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static gf inverse___1[((1 << 8) - 1) + 1]  ;
#line 179 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static gf gf_mul_table___1[((1 << 8) - 1) + 1][((1 << 8) - 1) + 1]  ;
#line 187 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static void init_mul_table___1(void) 
{ 
  int i ;
  int j ;
  gf tmp ;
  gf tmp___0 ;

  {
#line 191
  i = 0;
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 191
    if (! (i < ((1 << 8) - 1) + 1)) {
#line 191
      goto while_break;
    }
#line 192
    j = 0;
    {
#line 192
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 192
      if (! (j < ((1 << 8) - 1) + 1)) {
#line 192
        goto while_break___0;
      }
      {
#line 193
      tmp = modnn(gf_log___1[i] + gf_log___1[j]);
#line 193
      gf_mul_table___1[i][j] = gf_exp___1[tmp];
#line 192
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 191
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 195
  j = 0;
  {
#line 195
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 195
    if (! (j < ((1 << 8) - 1) + 1)) {
#line 195
      goto while_break___1;
    }
#line 196
    tmp___0 = (gf )0;
#line 196
    gf_mul_table___1[j][0] = tmp___0;
#line 196
    gf_mul_table___1[0][j] = tmp___0;
#line 195
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 197
  return;
}
}
#line 228 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static void *my_malloc___1(int sz , char const   *err_string ) 
{ 
  void *p ;
  void *tmp ;

  {
  {
#line 231
  tmp = malloc((size_t )sz);
#line 231
  p = tmp;
  }
#line 232
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 233
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-- malloc failure allocating %s\n",
            err_string);
#line 234
    exit(1);
    }
  }
#line 236
  return (p);
}
}
#line 245 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static void generate_gf___1(void) 
{ 
  int i ;
  gf mask ;
  char const   *Pp ;

  {
#line 250
  Pp = allPp___1[8];
#line 252
  mask = (gf )1;
#line 253
  gf_exp___1[8] = (gf )0;
#line 260
  i = 0;
  {
#line 260
  while (1) {
    while_continue: /* CIL Label */ ;
#line 260
    if (! (i < 8)) {
#line 260
      goto while_break;
    }
#line 261
    gf_exp___1[i] = mask;
#line 262
    gf_log___1[gf_exp___1[i]] = i;
#line 267
    if ((int const   )*(Pp + i) == 49) {
#line 268
      gf_exp___1[8] = (gf )((int )gf_exp___1[8] ^ (int )mask);
    }
#line 260
    i ++;
#line 260
    mask = (gf )((int )mask << 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 274
  gf_log___1[gf_exp___1[8]] = 8;
#line 281
  mask = (gf )(1 << 7);
#line 282
  i = 9;
  {
#line 282
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 282
    if (! (i < (1 << 8) - 1)) {
#line 282
      goto while_break___0;
    }
#line 283
    if ((int )gf_exp___1[i - 1] >= (int )mask) {
#line 284
      gf_exp___1[i] = (gf )((int )gf_exp___1[8] ^ (((int )gf_exp___1[i - 1] ^ (int )mask) << 1));
    } else {
#line 286
      gf_exp___1[i] = (gf )((int )gf_exp___1[i - 1] << 1);
    }
#line 287
    gf_log___1[gf_exp___1[i]] = i;
#line 282
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 292
  gf_log___1[0] = (1 << 8) - 1;
#line 294
  i = 0;
  {
#line 294
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 294
    if (! (i < (1 << 8) - 1)) {
#line 294
      goto while_break___1;
    }
#line 295
    gf_exp___1[i + ((1 << 8) - 1)] = gf_exp___1[i];
#line 294
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 302
  inverse___1[0] = (gf )0;
#line 303
  inverse___1[1] = (gf )1;
#line 304
  i = 2;
  {
#line 304
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 304
    if (! (i <= (1 << 8) - 1)) {
#line 304
      goto while_break___2;
    }
#line 305
    inverse___1[i] = gf_exp___1[((1 << 8) - 1) - gf_log___1[i]];
#line 304
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 306
  return;
}
}
#line 325 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static void addmul1___1(gf *dst1 , gf *src1 , gf c , int sz ) 
{ 
  register gf *__gf_mulc_ ;
  register gf *dst ;
  register gf *src ;
  gf *lim ;

  {
#line 329
  dst = dst1;
#line 329
  src = src1;
#line 330
  lim = dst + ((sz - 16) + 1);
#line 332
  __gf_mulc_ = gf_mul_table___1[c];
  {
#line 335
  while (1) {
    while_continue: /* CIL Label */ ;
#line 335
    if (! ((unsigned long )dst < (unsigned long )lim)) {
#line 335
      goto while_break;
    }
#line 336
    *(dst + 0) = (gf )((int )*(dst + 0) ^ (int )*(__gf_mulc_ + *(src + 0)));
#line 337
    *(dst + 1) = (gf )((int )*(dst + 1) ^ (int )*(__gf_mulc_ + *(src + 1)));
#line 338
    *(dst + 2) = (gf )((int )*(dst + 2) ^ (int )*(__gf_mulc_ + *(src + 2)));
#line 339
    *(dst + 3) = (gf )((int )*(dst + 3) ^ (int )*(__gf_mulc_ + *(src + 3)));
#line 341
    *(dst + 4) = (gf )((int )*(dst + 4) ^ (int )*(__gf_mulc_ + *(src + 4)));
#line 342
    *(dst + 5) = (gf )((int )*(dst + 5) ^ (int )*(__gf_mulc_ + *(src + 5)));
#line 343
    *(dst + 6) = (gf )((int )*(dst + 6) ^ (int )*(__gf_mulc_ + *(src + 6)));
#line 344
    *(dst + 7) = (gf )((int )*(dst + 7) ^ (int )*(__gf_mulc_ + *(src + 7)));
#line 347
    *(dst + 8) = (gf )((int )*(dst + 8) ^ (int )*(__gf_mulc_ + *(src + 8)));
#line 348
    *(dst + 9) = (gf )((int )*(dst + 9) ^ (int )*(__gf_mulc_ + *(src + 9)));
#line 349
    *(dst + 10) = (gf )((int )*(dst + 10) ^ (int )*(__gf_mulc_ + *(src + 10)));
#line 350
    *(dst + 11) = (gf )((int )*(dst + 11) ^ (int )*(__gf_mulc_ + *(src + 11)));
#line 351
    *(dst + 12) = (gf )((int )*(dst + 12) ^ (int )*(__gf_mulc_ + *(src + 12)));
#line 352
    *(dst + 13) = (gf )((int )*(dst + 13) ^ (int )*(__gf_mulc_ + *(src + 13)));
#line 353
    *(dst + 14) = (gf )((int )*(dst + 14) ^ (int )*(__gf_mulc_ + *(src + 14)));
#line 354
    *(dst + 15) = (gf )((int )*(dst + 15) ^ (int )*(__gf_mulc_ + *(src + 15)));
#line 335
    dst += 16;
#line 335
    src += 16;
  }
  while_break: /* CIL Label */ ;
  }
#line 358
  lim += 15;
  {
#line 359
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 359
    if (! ((unsigned long )dst < (unsigned long )lim)) {
#line 359
      goto while_break___0;
    }
#line 360
    *dst = (gf )((int )*dst ^ (int )*(__gf_mulc_ + *src));
#line 359
    dst ++;
#line 359
    src ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 361
  return;
}
}
#line 366 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static void matmul___1(gf *a , gf *b , gf *c , int n , int k , int m ) 
{ 
  int row ;
  int col ;
  int i ;
  gf *pa ;
  gf *pb ;
  gf acc ;

  {
#line 371
  row = 0;
  {
#line 371
  while (1) {
    while_continue: /* CIL Label */ ;
#line 371
    if (! (row < n)) {
#line 371
      goto while_break;
    }
#line 372
    col = 0;
    {
#line 372
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 372
      if (! (col < m)) {
#line 372
        goto while_break___0;
      }
#line 373
      pa = a + row * k;
#line 374
      pb = b + col;
#line 375
      acc = (gf )0;
#line 376
      i = 0;
      {
#line 376
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 376
        if (! (i < k)) {
#line 376
          goto while_break___1;
        }
#line 377
        acc = (gf )((int )acc ^ (int )gf_mul_table___1[*pa][*pb]);
#line 376
        i ++;
#line 376
        pa ++;
#line 376
        pb += m;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 378
      *(c + (row * m + col)) = acc;
#line 372
      col ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 371
    row ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 381
  return;
}
}
#line 410 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static int invert_mat___1(gf *src , int k ) 
{ 
  gf c ;
  gf *p ;
  int irow ;
  int icol ;
  int row ;
  int col ;
  int i ;
  int ix ;
  int error ;
  int *indxc ;
  void *tmp ;
  int *indxr ;
  void *tmp___0 ;
  int *ipiv ;
  void *tmp___1 ;
  gf *id_row ;
  void *tmp___2 ;
  gf *temp_row ;
  void *tmp___3 ;
  gf *pivot_row ;
  gf tmp___4 ;
  int tmp___5 ;
  gf tmp___6 ;

  {
  {
#line 416
  error = 1;
#line 417
  tmp = my_malloc___1((int )((unsigned long )k * sizeof(int )), "indxc");
#line 417
  indxc = (int *)tmp;
#line 418
  tmp___0 = my_malloc___1((int )((unsigned long )k * sizeof(int )), "indxr");
#line 418
  indxr = (int *)tmp___0;
#line 419
  tmp___1 = my_malloc___1((int )((unsigned long )k * sizeof(int )), "ipiv");
#line 419
  ipiv = (int *)tmp___1;
#line 420
  tmp___2 = my_malloc___1((int )((unsigned long )k * sizeof(gf )), " ## __LINE__ ## ");
#line 420
  id_row = (gf *)tmp___2;
#line 421
  tmp___3 = my_malloc___1((int )((unsigned long )k * sizeof(gf )), " ## __LINE__ ## ");
#line 421
  temp_row = (gf *)tmp___3;
#line 423
  memset((void *)id_row, '\000', (unsigned long )k * sizeof(gf ));
#line 428
  i = 0;
  }
  {
#line 428
  while (1) {
    while_continue: /* CIL Label */ ;
#line 428
    if (! (i < k)) {
#line 428
      goto while_break;
    }
#line 429
    *(ipiv + i) = 0;
#line 428
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 431
  col = 0;
  {
#line 431
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 431
    if (! (col < k)) {
#line 431
      goto while_break___0;
    }
#line 437
    icol = -1;
#line 437
    irow = icol;
#line 438
    if (*(ipiv + col) != 1) {
#line 438
      if ((int )*(src + (col * k + col)) != 0) {
#line 439
        irow = col;
#line 440
        icol = col;
#line 441
        goto found_piv;
      }
    }
#line 443
    row = 0;
    {
#line 443
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 443
      if (! (row < k)) {
#line 443
        goto while_break___1;
      }
#line 444
      if (*(ipiv + row) != 1) {
#line 445
        ix = 0;
        {
#line 445
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 445
          if (! (ix < k)) {
#line 445
            goto while_break___2;
          }
#line 447
          if (*(ipiv + ix) == 0) {
#line 448
            if ((int )*(src + (row * k + ix)) != 0) {
#line 449
              irow = row;
#line 450
              icol = ix;
#line 451
              goto found_piv;
            }
          } else
#line 453
          if (*(ipiv + ix) > 1) {
            {
#line 454
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"singular matrix\n");
            }
#line 455
            goto fail;
          }
#line 445
          ix ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 443
      row ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 460
    if (icol == -1) {
      {
#line 461
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"XXX pivot not found!\n");
      }
#line 462
      goto fail;
    }
    found_piv: 
#line 465
    (*(ipiv + icol)) ++;
#line 471
    if (irow != icol) {
#line 472
      ix = 0;
      {
#line 472
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 472
        if (! (ix < k)) {
#line 472
          goto while_break___3;
        }
#line 473
        tmp___4 = *(src + (irow * k + ix));
#line 473
        *(src + (irow * k + ix)) = *(src + (icol * k + ix));
#line 473
        *(src + (icol * k + ix)) = tmp___4;
#line 472
        ix ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 476
    *(indxr + col) = irow;
#line 477
    *(indxc + col) = icol;
#line 478
    pivot_row = src + icol * k;
#line 479
    c = *(pivot_row + icol);
#line 480
    if ((int )c == 0) {
      {
#line 481
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"singular matrix 2\n");
      }
#line 482
      goto fail;
    }
#line 484
    if ((int )c != 1) {
#line 490
      c = inverse___1[c];
#line 491
      *(pivot_row + icol) = (gf )1;
#line 492
      ix = 0;
      {
#line 492
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 492
        if (! (ix < k)) {
#line 492
          goto while_break___4;
        }
#line 493
        *(pivot_row + ix) = gf_mul_table___1[c][*(pivot_row + ix)];
#line 492
        ix ++;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
    {
#line 502
    *(id_row + icol) = (gf )1;
#line 503
    tmp___5 = memcmp((void const   *)pivot_row, (void const   *)id_row, (unsigned long )k * sizeof(gf ));
    }
#line 503
    if (tmp___5 != 0) {
#line 504
      p = src;
#line 504
      ix = 0;
      {
#line 504
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 504
        if (! (ix < k)) {
#line 504
          goto while_break___5;
        }
#line 505
        if (ix != icol) {
#line 506
          c = *(p + icol);
#line 507
          *(p + icol) = (gf )0;
#line 508
          if ((int )c != 0) {
            {
#line 508
            addmul1___1(p, pivot_row, c, k);
            }
          }
        }
#line 504
        ix ++;
#line 504
        p += k;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
#line 512
    *(id_row + icol) = (gf )0;
#line 431
    col ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 514
  col = k - 1;
  {
#line 514
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 514
    if (! (col >= 0)) {
#line 514
      goto while_break___6;
    }
#line 515
    if (*(indxr + col) < 0) {
      {
#line 516
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"AARGH, indxr[col] %d\n",
              *(indxr + col));
      }
    } else
#line 515
    if (*(indxr + col) >= k) {
      {
#line 516
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"AARGH, indxr[col] %d\n",
              *(indxr + col));
      }
    } else
#line 517
    if (*(indxc + col) < 0) {
      {
#line 518
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"AARGH, indxc[col] %d\n",
              *(indxc + col));
      }
    } else
#line 517
    if (*(indxc + col) >= k) {
      {
#line 518
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"AARGH, indxc[col] %d\n",
              *(indxc + col));
      }
    } else
#line 520
    if (*(indxr + col) != *(indxc + col)) {
#line 521
      row = 0;
      {
#line 521
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 521
        if (! (row < k)) {
#line 521
          goto while_break___7;
        }
#line 522
        tmp___6 = *(src + (row * k + *(indxr + col)));
#line 522
        *(src + (row * k + *(indxr + col))) = *(src + (row * k + *(indxc + col)));
#line 522
        *(src + (row * k + *(indxc + col))) = tmp___6;
#line 521
        row ++;
      }
      while_break___7: /* CIL Label */ ;
      }
    }
#line 514
    col --;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 526
  error = 0;
  fail: 
  {
#line 528
  free((void *)indxc);
#line 529
  free((void *)indxr);
#line 530
  free((void *)ipiv);
#line 531
  free((void *)id_row);
#line 532
  free((void *)temp_row);
  }
#line 533
  return (error);
}
}
#line 604 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static int fec_initialized___1  =    0;
#line 605 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static void init_fec___1(void) 
{ 


  {
  {
#line 609
  generate_gf___1();
#line 613
  init_mul_table___1();
#line 616
  fec_initialized___1 = 1;
  }
#line 617
  return;
}
}
#line 755 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static int shuffle___1(gf **pkt , int *index___0 , int k ) 
{ 
  int i ;
  int c ;
  int tmp ;
  gf *tmp___0 ;

  {
#line 760
  i = 0;
  {
#line 760
  while (1) {
    while_continue: /* CIL Label */ ;
#line 760
    if (! (i < k)) {
#line 760
      goto while_break;
    }
#line 761
    if (*(index___0 + i) >= k) {
#line 762
      i ++;
    } else
#line 761
    if (*(index___0 + i) == i) {
#line 762
      i ++;
    } else {
#line 767
      c = *(index___0 + i);
#line 769
      if (*(index___0 + c) == c) {
#line 771
        return (1);
      }
#line 773
      tmp = *(index___0 + i);
#line 773
      *(index___0 + i) = *(index___0 + c);
#line 773
      *(index___0 + c) = tmp;
#line 774
      tmp___0 = *(pkt + i);
#line 774
      *(pkt + i) = *(pkt + c);
#line 774
      *(pkt + c) = tmp___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 787
  return (0);
}
}
#line 795 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static gf *build_decode_matrix___1(struct fec_parms *code , int *index___0 ) 
{ 
  int i ;
  int k ;
  gf *p ;
  gf *matrix ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 798
  k = code->k;
#line 799
  tmp = my_malloc___1((int )((unsigned long )(k * k) * sizeof(gf )), " ## __LINE__ ## ");
#line 799
  matrix = (gf *)tmp;
#line 802
  i = 0;
#line 802
  p = matrix;
  }
  {
#line 802
  while (1) {
    while_continue: /* CIL Label */ ;
#line 802
    if (! (i < k)) {
#line 802
      goto while_break;
    }
#line 804
    if (*(index___0 + i) < k) {
      {
#line 805
      memset((void *)p, '\000', (unsigned long )k * sizeof(gf ));
#line 806
      *(p + i) = (gf )1;
      }
    } else
#line 809
    if (*(index___0 + i) < code->n) {
      {
#line 810
      memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(code->enc_matrix + *(index___0 + i) * k),
             (unsigned long )k * sizeof(gf ));
      }
    } else {
      {
#line 812
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"decode: invalid index %d (max %d)\n",
              *(index___0 + i), code->n - 1);
#line 814
      free((void *)matrix);
      }
#line 815
      return ((gf *)((void *)0));
    }
#line 802
    i ++;
#line 802
    p += k;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 819
  tmp___0 = invert_mat___1(matrix, k);
  }
#line 819
  if (tmp___0) {
    {
#line 820
    free((void *)matrix);
#line 821
    matrix = (gf *)((void *)0);
    }
  }
#line 824
  return (matrix);
}
}
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 580
extern int putchar(int __c ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 150 "/usr/include/getopt.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 72 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/ftl_format.c"
static void print_size(u_int s ) 
{ 


  {
#line 74
  if (s > 1048576U) {
#line 74
    if (s % 1048576U == 0U) {
      {
#line 75
      printf((char const   */* __restrict  */)"%d mb", s / 1048576U);
      }
    } else {
#line 74
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 76
  if (s > 1024U) {
#line 76
    if (s % 1024U == 0U) {
      {
#line 77
      printf((char const   */* __restrict  */)"%d kb", s / 1024U);
      }
    } else {
      {
#line 79
      printf((char const   */* __restrict  */)"%d bytes", s);
      }
    }
  } else {
    {
#line 79
    printf((char const   */* __restrict  */)"%d bytes", s);
    }
  }
#line 80
  return;
}
}
#line 84 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/ftl_format.c"
static char const   LinkTarget[5]  = {      (char const   )19,      (char const   )3,      (char const   )'C',      (char const   )'I', 
        (char const   )'S'};
#line 87 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/ftl_format.c"
static char const   DataOrg[10]  = 
#line 87
  {      (char const   )70,      (char const   )57,      (char const   )0,      (char const   )'F', 
        (char const   )'T',      (char const   )'L',      (char const   )'1',      (char const   )'0', 
        (char const   )'0',      (char const   )0};
#line 91 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/ftl_format.c"
static void build_header(erase_unit_header_t *hdr , u_int RegionSize , u_int BlockSize ,
                         u_int Spare , int Reserve , u_int BootSize ) 
{ 
  u_int i ;
  u_int BootUnits ;
  u_int nbam ;
  u_int __FormattedSize ;
  u_int8_t tmp ;
  time_t tmp___0 ;

  {
  {
#line 98
  memset((void *)hdr, 255, sizeof(*hdr));
#line 99
  memcpy((void */* __restrict  */)(hdr->LinkTargetTuple), (void const   */* __restrict  */)(LinkTarget),
         (size_t )5);
#line 100
  memcpy((void */* __restrict  */)(hdr->DataOrgTuple), (void const   */* __restrict  */)(DataOrg),
         (size_t )10);
#line 101
  tmp = (u_int8_t )255;
#line 101
  hdr->EndTuple[1] = tmp;
#line 101
  hdr->EndTuple[0] = tmp;
#line 102
  BootSize = (BootSize + (BlockSize - 1U)) & ~ (BlockSize - 1U);
#line 103
  BootUnits = BootSize / BlockSize;
#line 106
  hdr->BlockSize = (u_int8_t )9;
#line 107
  hdr->EraseUnitSize = (u_int8_t )0;
#line 108
  i = BlockSize;
  }
  {
#line 108
  while (1) {
    while_continue: /* CIL Label */ ;
#line 108
    if (! (i > 1U)) {
#line 108
      goto while_break;
    }
#line 109
    hdr->EraseUnitSize = (u_int8_t )((int )hdr->EraseUnitSize + 1);
#line 108
    i >>= 1;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 110
  hdr->EraseCount = (u_int32_t )0;
#line 111
  hdr->FirstPhysicalEUN = (u_int16_t )BootUnits;
#line 112
  hdr->NumEraseUnits = (u_int16_t )((RegionSize - BootSize) >> (int )hdr->EraseUnitSize);
#line 113
  hdr->NumTransferUnits = (u_int8_t )Spare;
#line 114
  __FormattedSize = RegionSize - ((Spare + BootUnits) << (int )hdr->EraseUnitSize);
#line 116
  hdr->BAMOffset = (u_int32_t )128;
#line 118
  nbam = (u_int )(((((unsigned long )(1 << ((int )hdr->EraseUnitSize - (int )hdr->BlockSize)) * sizeof(u_int ) + (unsigned long )hdr->BAMOffset) + (unsigned long )(1 << (int )hdr->BlockSize)) - 1UL) >> (int )hdr->BlockSize);
#line 121
  __FormattedSize -= ((u_int )hdr->NumEraseUnits - Spare) * (nbam << (int )hdr->BlockSize);
#line 123
  __FormattedSize -= (__FormattedSize * (u_int )Reserve) / 100U & 4294963200U;
#line 125
  hdr->FormattedSize = __FormattedSize;
#line 128
  hdr->NumVMPages = (u_int16_t )0;
#line 129
  hdr->Flags = (u_int8_t )0;
#line 131
  tmp___0 = time((time_t *)((void *)0));
#line 131
  hdr->SerialNumber = (u_int32_t )tmp___0;
  }
#line 134
  return;
}
}
#line 138 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/ftl_format.c"
static int format_partition(int fd , int quiet___1 , int interrogate , u_int spare ,
                            int reserve , u_int bootsize ) 
{ 
  mtd_info_t mtd ;
  erase_info_t erase ;
  erase_unit_header_t hdr ;
  u_int step ;
  u_int lun ;
  u_int i ;
  u_int nbam ;
  u_int *bam ;
  int tmp ;
  char str[3] ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  u_int ofs ;
  __off64_t tmp___5 ;
  ssize_t tmp___6 ;
  __off64_t tmp___7 ;
  ssize_t tmp___8 ;

  {
  {
#line 147
  tmp = ioctl(fd, (unsigned long )(((2U << 30) | (unsigned int )(77 << 8)) | 1U) | (sizeof(struct mtd_info_user ) << 16),
              & mtd);
  }
#line 147
  if (tmp != 0) {
    {
#line 148
    perror("get info failed");
    }
#line 149
    return (-1);
  }
  {
#line 163
  build_header(& hdr, mtd.size, mtd.erasesize, spare, reserve, bootsize);
  }
#line 166
  if (! quiet___1) {
    {
#line 167
    printf((char const   */* __restrict  */)"Partition size = ");
#line 168
    print_size(mtd.size);
#line 169
    printf((char const   */* __restrict  */)", erase unit size = ");
#line 170
    print_size(mtd.erasesize);
#line 171
    printf((char const   */* __restrict  */)", %d transfer units\n", spare);
    }
#line 172
    if (bootsize != 0U) {
      {
#line 173
      print_size((u_int )((int )hdr.FirstPhysicalEUN << (int )hdr.EraseUnitSize));
#line 174
      printf((char const   */* __restrict  */)" allocated for boot image\n");
      }
    }
    {
#line 176
    printf((char const   */* __restrict  */)"Reserved %d%%, formatted size = ", reserve);
#line 177
    print_size(hdr.FormattedSize);
#line 178
    printf((char const   */* __restrict  */)"\n");
#line 179
    fflush(stdout);
    }
  }
#line 182
  if (interrogate) {
    {
#line 184
    printf((char const   */* __restrict  */)"This will destroy all data on the target device.  Confirm (y/n): ");
#line 186
    tmp___0 = fgets((char */* __restrict  */)(str), 3, (FILE */* __restrict  */)stdin);
    }
#line 186
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 187
      return (-1);
    }
    {
#line 188
    tmp___1 = strcmp((char const   *)(str), "y\n");
    }
#line 188
    if (tmp___1 != 0) {
      {
#line 188
      tmp___2 = strcmp((char const   *)(str), "Y\n");
      }
#line 188
      if (tmp___2 != 0) {
#line 189
        return (-1);
      }
    }
  }
  {
#line 193
  nbam = (u_int )(((((unsigned long )(mtd.erasesize >> (int )hdr.BlockSize) * sizeof(u_int ) + (unsigned long )hdr.BAMOffset) + (unsigned long )(1 << (int )hdr.BlockSize)) - 1UL) >> (int )hdr.BlockSize);
#line 195
  tmp___3 = malloc((unsigned long )nbam * sizeof(u_int ));
#line 195
  bam = (u_int *)tmp___3;
#line 196
  i = (u_int )0;
  }
  {
#line 196
  while (1) {
    while_continue: /* CIL Label */ ;
#line 196
    if (! (i < nbam)) {
#line 196
      goto while_break;
    }
#line 197
    *(bam + i) = (u_int )48;
#line 196
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 200
  if (! quiet___1) {
    {
#line 201
    printf((char const   */* __restrict  */)"Erasing all blocks...\n");
#line 202
    fflush(stdout);
    }
  }
#line 204
  erase.length = mtd.erasesize;
#line 205
  erase.start = mtd.erasesize * (__u32 )hdr.FirstPhysicalEUN;
#line 206
  i = (u_int )0;
  {
#line 206
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 206
    if (! (i < (u_int )hdr.NumEraseUnits)) {
#line 206
      goto while_break___0;
    }
    {
#line 207
    tmp___4 = ioctl(fd, (unsigned long )(((1U << 30) | (unsigned int )(77 << 8)) | 2U) | (sizeof(struct erase_info_user ) << 16),
                    & erase);
    }
#line 207
    if (tmp___4 < 0) {
#line 208
      if (! quiet___1) {
        {
#line 209
        putchar('\n');
#line 210
        fflush(stdout);
        }
      }
      {
#line 212
      perror("block erase failed");
      }
#line 213
      return (-1);
    }
#line 215
    erase.start += erase.length;
#line 216
    if (! quiet___1) {
#line 217
      if (mtd.size <= 8388608U) {
#line 218
        if (erase.start % 1048576U) {
#line 219
          if (! (erase.start % 131072U)) {
            {
#line 219
            putchar('-');
            }
          }
        } else {
          {
#line 221
          putchar('+');
          }
        }
      } else
#line 224
      if (erase.start % 8388608U) {
#line 225
        if (! (erase.start % 1048576U)) {
          {
#line 225
          putchar('+');
          }
        }
      } else {
        {
#line 227
        putchar('*');
        }
      }
      {
#line 229
      fflush(stdout);
      }
    }
#line 206
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 232
  if (! quiet___1) {
    {
#line 232
    putchar('\n');
    }
  }
#line 235
  if (! quiet___1) {
    {
#line 236
    printf((char const   */* __restrict  */)"Writing erase unit headers...\n");
#line 237
    fflush(stdout);
    }
  }
#line 239
  lun = (u_int )0;
#line 241
  if (spare) {
#line 241
    step = (u_int )hdr.NumEraseUnits / spare;
  } else {
#line 241
    step = (u_int )((int )hdr.NumEraseUnits + 1);
  }
#line 242
  i = (u_int )0;
  {
#line 242
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 242
    if (! (i < (u_int )hdr.NumEraseUnits)) {
#line 242
      goto while_break___1;
    }
    {
#line 243
    ofs = (i + (u_int )hdr.FirstPhysicalEUN) << (int )hdr.EraseUnitSize;
#line 244
    tmp___5 = lseek(fd, (__off64_t )ofs, 0);
    }
#line 244
    if (tmp___5 == -1L) {
      {
#line 245
      perror("seek failed");
      }
#line 246
      goto while_break___1;
    }
#line 249
    if ((i + 1U) % step == 0U) {
#line 250
      hdr.LogicalEUN = (u_int16_t )65535;
    } else {
#line 252
      hdr.LogicalEUN = (u_int16_t )lun;
#line 253
      lun ++;
    }
    {
#line 255
    tmp___6 = write(fd, (void const   *)(& hdr), sizeof(hdr));
    }
#line 255
    if (tmp___6 == -1L) {
      {
#line 256
      perror("write failed");
      }
#line 257
      goto while_break___1;
    }
    {
#line 259
    tmp___7 = lseek(fd, (__off64_t )(ofs + hdr.BAMOffset), 0);
    }
#line 259
    if (tmp___7 == -1L) {
      {
#line 260
      perror("seek failed");
      }
#line 261
      goto while_break___1;
    }
    {
#line 263
    tmp___8 = write(fd, (void const   *)bam, (unsigned long )nbam * sizeof(u_int ));
    }
#line 263
    if (tmp___8 == -1L) {
      {
#line 264
      perror("write failed");
      }
#line 265
      goto while_break___1;
    }
#line 242
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 268
  if (i < (u_int )hdr.NumEraseUnits) {
#line 269
    return (-1);
  } else {
#line 271
    return (0);
  }
}
}
#line 38 "./include/xalloc.h"
static void *xmalloc___4(size_t size )  __attribute__((__unused__)) ;
#line 38 "./include/xalloc.h"
static void *xmalloc___4(size_t size ) 
{ 
  void *ptr ;
  void *tmp ;
  int _err ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 41
  tmp = malloc(size);
#line 41
  ptr = tmp;
  }
#line 43
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 43
    if (size != 0UL) {
      {
#line 44
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 44
        tmp___0 = __errno_location();
#line 44
        _err = *tmp___0;
#line 44
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: out of memory\n",
                "libmtd");
#line 44
        tmp___1 = strerror(_err);
#line 44
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
                (int )sizeof("libmtd") + 1, "", _err, tmp___1);
#line 44
        exit(-1);
        }
#line 44
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 45
  return (ptr);
}
}
#line 48
static void *xcalloc___1(size_t nmemb , size_t size )  __attribute__((__unused__)) ;
#line 48 "./include/xalloc.h"
static void *xcalloc___1(size_t nmemb , size_t size ) 
{ 
  void *ptr ;
  void *tmp ;
  int _err ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 51
  tmp = calloc(nmemb, size);
#line 51
  ptr = tmp;
  }
#line 53
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 53
    if (nmemb != 0UL) {
#line 53
      if (size != 0UL) {
        {
#line 54
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 54
          tmp___0 = __errno_location();
#line 54
          _err = *tmp___0;
#line 54
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: out of memory\n",
                  "libmtd");
#line 54
          tmp___1 = strerror(_err);
#line 54
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
                  (int )sizeof("libmtd") + 1, "", _err, tmp___1);
#line 54
          exit(-1);
          }
#line 54
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
  }
#line 55
  return (ptr);
}
}
#line 58
static void *xzalloc___1(size_t size )  __attribute__((__unused__)) ;
#line 58 "./include/xalloc.h"
static void *xzalloc___1(size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 61
  tmp = xcalloc___1((size_t )1, size);
  }
#line 61
  return (tmp);
}
}
#line 50 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static char *mkpath___1(char const   *path , char const   *name ) 
{ 
  char *n ;
  size_t len1 ;
  size_t tmp ;
  size_t len2 ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 53
  tmp = strlen(path);
#line 53
  len1 = tmp;
#line 54
  tmp___0 = strlen(name);
#line 54
  len2 = tmp___0;
#line 56
  tmp___1 = xmalloc___4((len1 + len2) + 2UL);
#line 56
  n = (char *)tmp___1;
#line 58
  memcpy((void */* __restrict  */)n, (void const   */* __restrict  */)path, len1);
  }
#line 59
  if ((int )*(n + (len1 - 1UL)) != 47) {
#line 60
    tmp___2 = len1;
#line 60
    len1 ++;
#line 60
    *(n + tmp___2) = (char )'/';
  }
  {
#line 62
  memcpy((void */* __restrict  */)(n + len1), (void const   */* __restrict  */)name,
         len2 + 1UL);
  }
#line 63
  return (n);
}
}
#line 76 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int read_data___1(char const   *file , void *buf , int buf_len ) 
{ 
  int fd ;
  int rd ;
  int tmp ;
  int tmp1 ;
  ssize_t tmp___0 ;
  int _err ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  ssize_t tmp___4 ;
  int _err___0 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;
  int _err___1 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;

  {
  {
#line 80
  fd = open(file, 524288);
  }
#line 81
  if (fd == -1) {
#line 82
    return (-1);
  }
  {
#line 84
  tmp___0 = read(fd, buf, (size_t )buf_len);
#line 84
  rd = (int )tmp___0;
  }
#line 85
  if (rd == -1) {
    {
#line 86
    tmp___1 = __errno_location();
#line 86
    _err = *tmp___1;
#line 86
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: cannot read \"%s\"\n",
            "libmtd", file);
#line 86
    tmp___2 = strerror(_err);
#line 86
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err, tmp___2);
    }
#line 87
    goto out_error;
  }
#line 90
  if (rd == buf_len) {
    {
#line 91
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: contents of \"%s\" is too long\n",
            "libmtd", file);
#line 92
    tmp___3 = __errno_location();
#line 92
    *tmp___3 = 22;
    }
#line 93
    goto out_error;
  }
  {
#line 96
  *((char *)buf + rd) = (char )'\000';
#line 99
  tmp___4 = read(fd, (void *)(& tmp), (size_t )1);
#line 99
  tmp1 = (int )tmp___4;
  }
#line 100
  if (tmp1 == 1) {
    {
#line 101
    tmp___5 = __errno_location();
#line 101
    _err___0 = *tmp___5;
#line 101
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: cannot read \"%s\"\n",
            "libmtd", file);
#line 101
    tmp___6 = strerror(_err___0);
#line 101
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err___0, tmp___6);
    }
#line 102
    goto out_error;
  }
#line 104
  if (tmp1) {
    {
#line 105
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: file \"%s\" contains too much data (> %d bytes)\n",
            "libmtd", file, buf_len);
#line 107
    tmp___7 = __errno_location();
#line 107
    *tmp___7 = 22;
    }
#line 108
    goto out_error;
  }
  {
#line 111
  tmp___10 = close(fd);
  }
#line 111
  if (tmp___10) {
    {
#line 112
    tmp___8 = __errno_location();
#line 112
    _err___1 = *tmp___8;
#line 112
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: close failed on \"%s\"\n",
            "libmtd", file);
#line 112
    tmp___9 = strerror(_err___1);
#line 112
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err___1, tmp___9);
    }
#line 113
    return (-1);
  }
#line 116
  return (rd);
  out_error: 
  {
#line 119
  close(fd);
  }
#line 120
  return (-1);
}
}
#line 131 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int read_major___1(char const   *file , int *major , int *minor ) 
{ 
  int ret ;
  char buf[50] ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 136
  ret = read_data___1(file, (void *)(buf), 50);
  }
#line 137
  if (ret < 0) {
#line 138
    return (ret);
  }
  {
#line 140
  ret = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%d:%d\n",
               major, minor);
  }
#line 141
  if (ret != 2) {
    {
#line 142
    tmp = __errno_location();
#line 142
    *tmp = 22;
#line 143
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: \"%s\" does not have major:minor format\n",
            "libmtd", file);
    }
#line 143
    return (-1);
  }
#line 146
  if (*major < 0) {
    {
#line 147
    tmp___0 = __errno_location();
#line 147
    *tmp___0 = 22;
#line 148
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: bad major:minor %d:%d in \"%s\"\n",
            "libmtd", *major, *minor, file);
    }
#line 148
    return (-1);
  } else
#line 146
  if (*minor < 0) {
    {
#line 147
    tmp___0 = __errno_location();
#line 147
    *tmp___0 = 22;
#line 148
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: bad major:minor %d:%d in \"%s\"\n",
            "libmtd", *major, *minor, file);
    }
#line 148
    return (-1);
  }
#line 152
  return (0);
}
}
#line 164 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int dev_get_major___1(struct libmtd *lib , int mtd_num , int *major , int *minor ) 
{ 
  size_t tmp ;
  char *file ;
  unsigned long __lengthoffile ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 166
  tmp = strlen((char const   *)lib->mtd_dev);
#line 166
  __lengthoffile = tmp + 50UL;
#line 166
  tmp___0 = __builtin_alloca(sizeof(*file) * __lengthoffile);
#line 166
  file = (char *)tmp___0;
#line 168
  sprintf((char */* __restrict  */)file, (char const   */* __restrict  */)lib->mtd_dev,
          mtd_num);
#line 169
  tmp___1 = read_major___1((char const   *)file, major, minor);
  }
#line 169
  return (tmp___1);
}
}
#line 182 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int dev_read_data___1(char const   *patt , int mtd_num , void *buf , int buf_len ) 
{ 
  size_t tmp ;
  char *file ;
  unsigned long __lengthoffile ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 184
  tmp = strlen(patt);
#line 184
  __lengthoffile = tmp + 100UL;
#line 184
  tmp___0 = __builtin_alloca(sizeof(*file) * __lengthoffile);
#line 184
  file = (char *)tmp___0;
#line 186
  sprintf((char */* __restrict  */)file, (char const   */* __restrict  */)patt, mtd_num);
#line 187
  tmp___1 = read_data___1((char const   *)file, buf, buf_len);
  }
#line 187
  return (tmp___1);
}
}
#line 199 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int read_hex_ll___1(char const   *file , long long *value ) 
{ 
  int fd ;
  int rd ;
  char buf[50] ;
  ssize_t tmp ;
  int _err ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int _err___0 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;

  {
  {
#line 204
  fd = open(file, 524288);
  }
#line 205
  if (fd == -1) {
#line 206
    return (-1);
  }
  {
#line 208
  tmp = read(fd, (void *)(buf), sizeof(buf));
#line 208
  rd = (int )tmp;
  }
#line 209
  if (rd == -1) {
    {
#line 210
    tmp___0 = __errno_location();
#line 210
    _err = *tmp___0;
#line 210
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: cannot read \"%s\"\n",
            "libmtd", file);
#line 210
    tmp___1 = strerror(_err);
#line 210
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err, tmp___1);
    }
#line 211
    goto out_error;
  }
#line 213
  if ((unsigned long )rd == sizeof(buf)) {
    {
#line 214
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: contents of \"%s\" is too long\n",
            "libmtd", file);
#line 215
    tmp___2 = __errno_location();
#line 215
    *tmp___2 = 22;
    }
#line 216
    goto out_error;
  }
  {
#line 218
  buf[rd] = (char )'\000';
#line 220
  tmp___4 = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%llx\n",
                   value);
  }
#line 220
  if (tmp___4 != 1) {
    {
#line 221
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: cannot read integer from \"%s\"\n\n",
            "libmtd", file);
#line 222
    tmp___3 = __errno_location();
#line 222
    *tmp___3 = 22;
    }
#line 223
    goto out_error;
  }
#line 226
  if (*value < 0LL) {
    {
#line 227
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: negative value %lld in \"%s\"\n",
            "libmtd", *value, file);
#line 228
    tmp___5 = __errno_location();
#line 228
    *tmp___5 = 22;
    }
#line 229
    goto out_error;
  }
  {
#line 232
  tmp___8 = close(fd);
  }
#line 232
  if (tmp___8) {
    {
#line 233
    tmp___6 = __errno_location();
#line 233
    _err___0 = *tmp___6;
#line 233
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: close failed on \"%s\"\n",
            "libmtd", file);
#line 233
    tmp___7 = strerror(_err___0);
#line 233
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err___0, tmp___7);
    }
#line 233
    return (-1);
  }
#line 235
  return (0);
  out_error: 
  {
#line 238
  close(fd);
  }
#line 239
  return (-1);
}
}
#line 251 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int read_pos_ll___1(char const   *file , long long *value ) 
{ 
  int fd ;
  int rd ;
  char buf[50] ;
  ssize_t tmp ;
  int _err ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int _err___0 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;

  {
  {
#line 256
  fd = open(file, 524288);
  }
#line 257
  if (fd == -1) {
#line 258
    return (-1);
  }
  {
#line 260
  tmp = read(fd, (void *)(buf), (size_t )50);
#line 260
  rd = (int )tmp;
  }
#line 261
  if (rd == -1) {
    {
#line 262
    tmp___0 = __errno_location();
#line 262
    _err = *tmp___0;
#line 262
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: cannot read \"%s\"\n",
            "libmtd", file);
#line 262
    tmp___1 = strerror(_err);
#line 262
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err, tmp___1);
    }
#line 263
    goto out_error;
  }
#line 265
  if (rd == 50) {
    {
#line 266
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: contents of \"%s\" is too long\n",
            "libmtd", file);
#line 267
    tmp___2 = __errno_location();
#line 267
    *tmp___2 = 22;
    }
#line 268
    goto out_error;
  }
  {
#line 271
  tmp___4 = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%lld\n",
                   value);
  }
#line 271
  if (tmp___4 != 1) {
    {
#line 272
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: cannot read integer from \"%s\"\n\n",
            "libmtd", file);
#line 273
    tmp___3 = __errno_location();
#line 273
    *tmp___3 = 22;
    }
#line 274
    goto out_error;
  }
#line 277
  if (*value < 0LL) {
    {
#line 278
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: negative value %lld in \"%s\"\n",
            "libmtd", *value, file);
#line 279
    tmp___5 = __errno_location();
#line 279
    *tmp___5 = 22;
    }
#line 280
    goto out_error;
  }
  {
#line 283
  tmp___8 = close(fd);
  }
#line 283
  if (tmp___8) {
    {
#line 284
    tmp___6 = __errno_location();
#line 284
    _err___0 = *tmp___6;
#line 284
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: close failed on \"%s\"\n",
            "libmtd", file);
#line 284
    tmp___7 = strerror(_err___0);
#line 284
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err___0, tmp___7);
    }
#line 284
    return (-1);
  }
#line 286
  return (0);
  out_error: 
  {
#line 289
  close(fd);
  }
#line 290
  return (-1);
}
}
#line 301 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int read_hex_int___1(char const   *file , int *value ) 
{ 
  long long res ;
  int tmp ;
  int *tmp___0 ;

  {
  {
#line 305
  tmp = read_hex_ll___1(file, & res);
  }
#line 305
  if (tmp) {
#line 306
    return (-1);
  }
#line 309
  if (res > 2147483647LL) {
    {
#line 310
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: value %lld read from file \"%s\" is out of range\n",
            "libmtd", res, file);
#line 312
    tmp___0 = __errno_location();
#line 312
    *tmp___0 = 22;
    }
#line 313
    return (-1);
  } else
#line 309
  if (res < (-0x7FFFFFFF-1)) {
    {
#line 310
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: value %lld read from file \"%s\" is out of range\n",
            "libmtd", res, file);
#line 312
    tmp___0 = __errno_location();
#line 312
    *tmp___0 = 22;
    }
#line 313
    return (-1);
  }
#line 316
  *value = (int )res;
#line 317
  return (0);
}
}
#line 328 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int read_pos_int___1(char const   *file , int *value ) 
{ 
  long long res ;
  int tmp ;
  int *tmp___0 ;

  {
  {
#line 332
  tmp = read_pos_ll___1(file, & res);
  }
#line 332
  if (tmp) {
#line 333
    return (-1);
  }
#line 336
  if (res > 2147483647LL) {
    {
#line 337
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: value %lld read from file \"%s\" is out of range\n",
            "libmtd", res, file);
#line 339
    tmp___0 = __errno_location();
#line 339
    *tmp___0 = 22;
    }
#line 340
    return (-1);
  }
#line 343
  *value = (int )res;
#line 344
  return (0);
}
}
#line 355 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int dev_read_hex_int___1(char const   *patt , int mtd_num , int *value ) 
{ 
  size_t tmp ;
  char *file ;
  unsigned long __lengthoffile ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 357
  tmp = strlen(patt);
#line 357
  __lengthoffile = tmp + 50UL;
#line 357
  tmp___0 = __builtin_alloca(sizeof(*file) * __lengthoffile);
#line 357
  file = (char *)tmp___0;
#line 359
  sprintf((char */* __restrict  */)file, (char const   */* __restrict  */)patt, mtd_num);
#line 360
  tmp___1 = read_hex_int___1((char const   *)file, value);
  }
#line 360
  return (tmp___1);
}
}
#line 371 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int dev_read_pos_int___1(char const   *patt , int mtd_num , int *value ) 
{ 
  size_t tmp ;
  char *file ;
  unsigned long __lengthoffile ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 373
  tmp = strlen(patt);
#line 373
  __lengthoffile = tmp + 50UL;
#line 373
  tmp___0 = __builtin_alloca(sizeof(*file) * __lengthoffile);
#line 373
  file = (char *)tmp___0;
#line 375
  sprintf((char */* __restrict  */)file, (char const   */* __restrict  */)patt, mtd_num);
#line 376
  tmp___1 = read_pos_int___1((char const   *)file, value);
  }
#line 376
  return (tmp___1);
}
}
#line 387 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int dev_read_pos_ll___1(char const   *patt , int mtd_num , long long *value ) 
{ 
  size_t tmp ;
  char *file ;
  unsigned long __lengthoffile ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 389
  tmp = strlen(patt);
#line 389
  __lengthoffile = tmp + 50UL;
#line 389
  tmp___0 = __builtin_alloca(sizeof(*file) * __lengthoffile);
#line 389
  file = (char *)tmp___0;
#line 391
  sprintf((char */* __restrict  */)file, (char const   */* __restrict  */)patt, mtd_num);
#line 392
  tmp___1 = read_pos_ll___1((char const   *)file, value);
  }
#line 392
  return (tmp___1);
}
}
#line 402 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int type_str2int___1(char const   *str ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 404
  tmp = strcmp(str, "nand");
  }
#line 404
  if (! tmp) {
#line 405
    return (4);
  }
  {
#line 406
  tmp___0 = strcmp(str, "nor");
  }
#line 406
  if (! tmp___0) {
#line 407
    return (3);
  }
  {
#line 408
  tmp___1 = strcmp(str, "rom");
  }
#line 408
  if (! tmp___1) {
#line 409
    return (2);
  }
  {
#line 410
  tmp___2 = strcmp(str, "absent");
  }
#line 410
  if (! tmp___2) {
#line 411
    return (0);
  }
  {
#line 412
  tmp___3 = strcmp(str, "dataflash");
  }
#line 412
  if (! tmp___3) {
#line 413
    return (6);
  }
  {
#line 414
  tmp___4 = strcmp(str, "ram");
  }
#line 414
  if (! tmp___4) {
#line 415
    return (1);
  }
  {
#line 416
  tmp___5 = strcmp(str, "ubi");
  }
#line 416
  if (! tmp___5) {
#line 417
    return (7);
  }
#line 418
  return (-1);
}
}
#line 429 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int dev_node2num___1(struct libmtd *lib , char const   *node , int *mtd_num ) 
{ 
  struct stat st ;
  int i ;
  int mjr ;
  int mnr ;
  struct mtd_info info ;
  int _err ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  int tmp___5 ;
  int mjr1 ;
  int mnr1 ;
  int ret ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;

  {
  {
#line 435
  tmp___1 = stat((char const   */* __restrict  */)node, (struct stat */* __restrict  */)(& st));
  }
#line 435
  if (tmp___1) {
    {
#line 436
    tmp = __errno_location();
#line 436
    _err = *tmp;
#line 436
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: cannot get information about \"%s\"\n",
            "libmtd", node);
#line 436
    tmp___0 = strerror(_err);
#line 436
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err, tmp___0);
    }
#line 436
    return (-1);
  }
#line 438
  if (! ((st.st_mode & 61440U) == 8192U)) {
    {
#line 439
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: \"%s\" is not a character device\n",
            "libmtd", node);
#line 440
    tmp___2 = __errno_location();
#line 440
    *tmp___2 = 22;
    }
#line 441
    return (-1);
  }
  {
#line 444
  tmp___3 = gnu_dev_major((unsigned long long )st.st_rdev);
#line 444
  mjr = (int )tmp___3;
#line 445
  tmp___4 = gnu_dev_minor((unsigned long long )st.st_rdev);
#line 445
  mnr = (int )tmp___4;
#line 447
  tmp___5 = mtd_get_info((libmtd_t )((libmtd_t *)lib), & info);
  }
#line 447
  if (tmp___5) {
#line 448
    return (-1);
  }
#line 450
  i = info.lowest_mtd_num;
  {
#line 450
  while (1) {
    while_continue: /* CIL Label */ ;
#line 450
    if (! (i <= info.highest_mtd_num)) {
#line 450
      goto while_break;
    }
    {
#line 453
    ret = dev_get_major___1(lib, i, & mjr1, & mnr1);
    }
#line 454
    if (ret) {
      {
#line 455
      tmp___6 = __errno_location();
      }
#line 455
      if (*tmp___6 == 2) {
#line 456
        goto __Cont;
      }
      {
#line 457
      tmp___7 = __errno_location();
      }
#line 457
      if (! *tmp___7) {
#line 458
        goto while_break;
      }
#line 459
      return (-1);
    }
#line 462
    if (mjr1 == mjr) {
#line 462
      if (mnr1 == mnr) {
        {
#line 463
        tmp___8 = __errno_location();
#line 463
        *tmp___8 = 0;
#line 464
        *mtd_num = i;
        }
#line 465
        return (0);
      }
    }
    __Cont: /* CIL Label */ 
#line 450
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 469
  tmp___9 = __errno_location();
#line 469
  *tmp___9 = 19;
  }
#line 470
  return (-1);
}
}
#line 489 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int sysfs_is_supported___1(struct libmtd *lib ) 
{ 
  int fd ;
  int num ;
  DIR *sysfs_mtd ;
  size_t tmp ;
  char *file ;
  unsigned long __lengthoffile ;
  void *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int _err ;
  int *tmp___3 ;
  char *tmp___4 ;
  int ret ;
  int mtd_num ;
  char tmp_buf[256] ;
  struct dirent *dirent ;
  int *tmp___5 ;
  size_t tmp___6 ;
  int _err___0 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int _err___1 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;

  {
  {
#line 491
  num = -1;
#line 493
  tmp = strlen((char const   *)lib->mtd_name);
#line 493
  __lengthoffile = tmp + 10UL;
#line 493
  tmp___0 = __builtin_alloca(sizeof(*file) * __lengthoffile);
#line 493
  file = (char *)tmp___0;
#line 495
  sysfs_mtd = opendir((char const   *)lib->sysfs_mtd);
  }
#line 496
  if (! sysfs_mtd) {
    {
#line 497
    tmp___2 = __errno_location();
    }
#line 497
    if (*tmp___2 == 2) {
      {
#line 498
      tmp___1 = __errno_location();
#line 498
      *tmp___1 = 0;
      }
#line 499
      return (0);
    }
    {
#line 501
    tmp___3 = __errno_location();
#line 501
    _err = *tmp___3;
#line 501
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: cannot open \"%s\"\n",
            "libmtd", lib->sysfs_mtd);
#line 501
    tmp___4 = strerror(_err);
#line 501
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err, tmp___4);
    }
#line 501
    return (-1);
  }
  {
#line 508
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 513
    dirent = readdir(sysfs_mtd);
    }
#line 514
    if (! dirent) {
#line 515
      goto while_break;
    }
    {
#line 517
    tmp___6 = strlen((char const   *)(dirent->d_name));
    }
#line 517
    if (tmp___6 >= 255UL) {
      {
#line 518
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: invalid entry in %s: \"%s\"\n",
              "libmtd", lib->sysfs_mtd, dirent->d_name);
#line 520
      tmp___5 = __errno_location();
#line 520
      *tmp___5 = 22;
#line 521
      closedir(sysfs_mtd);
      }
#line 522
      return (-1);
    }
    {
#line 525
    ret = sscanf((char const   */* __restrict  */)(dirent->d_name), (char const   */* __restrict  */)"mtd%d%s",
                 & mtd_num, tmp_buf);
    }
#line 527
    if (ret == 1) {
#line 528
      num = mtd_num;
#line 529
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 533
  tmp___9 = closedir(sysfs_mtd);
  }
#line 533
  if (tmp___9) {
    {
#line 534
    tmp___7 = __errno_location();
#line 534
    _err___0 = *tmp___7;
#line 534
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: closedir failed on \"%s\"\n",
            "libmtd", lib->sysfs_mtd);
#line 534
    tmp___8 = strerror(_err___0);
#line 534
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err___0, tmp___8);
    }
#line 534
    return (-1);
  }
#line 536
  if (num == -1) {
#line 538
    return (0);
  }
  {
#line 540
  sprintf((char */* __restrict  */)file, (char const   */* __restrict  */)lib->mtd_name,
          num);
#line 541
  fd = open((char const   *)file, 524288);
  }
#line 542
  if (fd == -1) {
#line 543
    return (0);
  }
  {
#line 545
  tmp___12 = close(fd);
  }
#line 545
  if (tmp___12) {
    {
#line 546
    tmp___10 = __errno_location();
#line 546
    _err___1 = *tmp___10;
#line 546
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: close failed on \"%s\"\n",
            "libmtd", file);
#line 546
    tmp___11 = strerror(_err___1);
#line 546
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err___1, tmp___11);
    }
#line 547
    return (-1);
  }
#line 550
  return (1);
}
}
#line 803 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int mtd_valid_erase_block___1(struct mtd_dev_info  const  *mtd , int eb ) 
{ 
  int *tmp ;

  {
#line 805
  if (eb < 0) {
    {
#line 806
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: bad eraseblock number %d, mtd%d has %d eraseblocks\n",
            "libmtd", eb, mtd->mtd_num, mtd->eb_cnt);
#line 808
    tmp = __errno_location();
#line 808
    *tmp = 22;
    }
#line 809
    return (-1);
  } else
#line 805
  if (eb >= (int )mtd->eb_cnt) {
    {
#line 806
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: bad eraseblock number %d, mtd%d has %d eraseblocks\n",
            "libmtd", eb, mtd->mtd_num, mtd->eb_cnt);
#line 808
    tmp = __errno_location();
#line 808
    *tmp = 22;
    }
#line 809
    return (-1);
  }
#line 811
  return (0);
}
}
#line 814 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int mtd_xlock___1(struct mtd_dev_info  const  *mtd , int fd , int eb , int req ,
                         char const   *sreq ) 
{ 
  int ret ;
  struct erase_info_user ei ;
  int tmp ;

  {
  {
#line 820
  ret = mtd_valid_erase_block___1(mtd, eb);
  }
#line 821
  if (ret) {
#line 822
    return (ret);
  }
  {
#line 824
  ei.start = (__u32 )(eb * (int )mtd->eb_size);
#line 825
  ei.length = (__u32 )mtd->eb_size;
#line 827
  ret = ioctl(fd, (unsigned long )req, & ei);
  }
#line 828
  if (ret < 0) {
    {
#line 829
    tmp = mtd_ioctl_error(mtd, eb, sreq);
    }
#line 829
    return (tmp);
  }
#line 831
  return (0);
}
}
#line 929 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static uint8_t patterns___1[3]  = {      (uint8_t )165,      (uint8_t )90,      (uint8_t )0};
#line 940 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int check_pattern___1(void const   *buf , uint8_t patt , int size ) 
{ 
  int i ;

  {
#line 944
  i = 0;
  {
#line 944
  while (1) {
    while_continue: /* CIL Label */ ;
#line 944
    if (! (i < size)) {
#line 944
      goto while_break;
    }
#line 945
    if ((int const   )*((uint8_t const   *)buf + i) != (int const   )patt) {
#line 946
      return (0);
    }
#line 944
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 947
  return (1);
}
}
#line 1080 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int legacy_auto_oob_layout___1(struct mtd_dev_info  const  *mtd , int fd ,
                                      int ooblen , void *oob ) 
{ 
  struct nand_oobinfo old_oobinfo ;
  int start ;
  int len ;
  uint8_t *tmp_buf ;
  int _err ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int i ;
  int tags_pos ;

  {
  {
#line 1087
  tmp___1 = ioctl(fd, (unsigned long )(((2U << 30) | (unsigned int )(77 << 8)) | 10U) | (sizeof(struct nand_oobinfo ) << 16),
                  & old_oobinfo);
  }
#line 1087
  if (tmp___1) {
    {
#line 1088
    tmp = __errno_location();
#line 1088
    _err = *tmp;
#line 1088
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: MEMGETOOBSEL failed\n",
            "libmtd");
#line 1088
    tmp___0 = strerror(_err);
#line 1088
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err, tmp___0);
    }
#line 1088
    return (-1);
  }
  {
#line 1090
  tmp___2 = malloc((size_t )ooblen);
#line 1090
  tmp_buf = (uint8_t *)tmp___2;
#line 1091
  memcpy((void */* __restrict  */)tmp_buf, (void const   */* __restrict  */)oob, (size_t )ooblen);
  }
#line 1097
  if (old_oobinfo.useecc == 2U) {
#line 1098
    tags_pos = 0;
#line 1099
    i = 0;
    {
#line 1099
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1099
      if (! old_oobinfo.oobfree[i][1]) {
#line 1099
        goto while_break;
      }
      {
#line 1101
      start = (int )old_oobinfo.oobfree[i][0];
#line 1102
      len = (int )old_oobinfo.oobfree[i][1];
#line 1103
      memcpy((void */* __restrict  */)(oob + start), (void const   */* __restrict  */)(tmp_buf + tags_pos),
             (size_t )len);
#line 1104
      tags_pos += len;
#line 1099
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1108
    start = (int )old_oobinfo.eccbytes;
#line 1109
    len = (int )(mtd->oob_size - (int const   )start);
#line 1110
    memcpy((void */* __restrict  */)(oob + start), (void const   */* __restrict  */)(tmp_buf + start),
           (size_t )len);
    }
  }
#line 1113
  return (0);
}
}
#line 38 "./include/xalloc.h"
static void *xmalloc___5(size_t size )  __attribute__((__unused__)) ;
#line 38 "./include/xalloc.h"
static void *xmalloc___5(size_t size ) 
{ 
  void *ptr ;
  void *tmp ;
  int _err ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 41
  tmp = malloc(size);
#line 41
  ptr = tmp;
  }
#line 43
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 43
    if (size != 0UL) {
      {
#line 44
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 44
        tmp___0 = __errno_location();
#line 44
        _err = *tmp___0;
#line 44
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: out of memory\n",
                "libmtd");
#line 44
        tmp___1 = strerror(_err);
#line 44
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
                (int )sizeof("libmtd") + 1, "", _err, tmp___1);
#line 44
        exit(-1);
        }
#line 44
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 45
  return (ptr);
}
}
#line 70 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd_legacy.c"
static int proc_parse_start___1(struct proc_parse_info *pi ) 
{ 
  int fd ;
  int ret ;
  void *tmp ;
  ssize_t tmp___0 ;
  int _err ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 74
  fd = open("/proc/mtd", 0);
  }
#line 75
  if (fd == -1) {
#line 76
    return (-1);
  }
  {
#line 78
  tmp = xmalloc___5((size_t )4096);
#line 78
  pi->buf = (char *)tmp;
#line 80
  tmp___0 = read(fd, (void *)pi->buf, (size_t )4096);
#line 80
  ret = (int )tmp___0;
  }
#line 81
  if (ret == -1) {
    {
#line 82
    tmp___1 = __errno_location();
#line 82
    _err = *tmp___1;
#line 82
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: cannot read \"%s\"\n",
            "libmtd", "/proc/mtd");
#line 82
    tmp___2 = strerror(_err);
#line 82
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err, tmp___2);
    }
#line 83
    goto out_free;
  }
#line 86
  if ((unsigned long )ret < sizeof("dev:    size   erasesize  name\n") - 1UL) {
    {
#line 88
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: \"%s\" does not start with \"%s\"\n",
            "libmtd", "/proc/mtd", "dev:    size   erasesize  name\n");
    }
#line 90
    goto out_free;
  } else {
    {
#line 86
    tmp___3 = memcmp((void const   *)pi->buf, (void const   *)"dev:    size   erasesize  name\n",
                     sizeof("dev:    size   erasesize  name\n") - 1UL);
    }
#line 86
    if (tmp___3) {
      {
#line 88
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: \"%s\" does not start with \"%s\"\n",
              "libmtd", "/proc/mtd", "dev:    size   erasesize  name\n");
      }
#line 90
      goto out_free;
    }
  }
  {
#line 93
  pi->data_size = ret;
#line 94
  pi->next = pi->buf + (sizeof("dev:    size   erasesize  name\n") - 1UL);
#line 96
  close(fd);
  }
#line 97
  return (0);
  out_free: 
  {
#line 100
  free((void *)pi->buf);
#line 101
  close(fd);
  }
#line 102
  return (-1);
}
}
#line 105 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd_legacy.c"
static int proc_parse_next___1(struct proc_parse_info *pi ) 
{ 
  int ret ;
  int len ;
  int pos ;
  char *p ;
  char *p1 ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 107
  pos = (int )(pi->next - pi->buf);
#line 110
  if (pos >= pi->data_size) {
    {
#line 111
    free((void *)pi->buf);
    }
#line 112
    return (0);
  }
  {
#line 115
  ret = sscanf((char const   */* __restrict  */)pi->next, (char const   */* __restrict  */)"mtd%d: %llx %x",
               & pi->mtd_num, & pi->size, & pi->eb_size);
  }
#line 117
  if (ret != 3) {
    {
#line 118
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: \"%s\" pattern not found\n",
            "libmtd", "mtd%d: %llx %x");
    }
#line 118
    return (-1);
  }
  {
#line 120
  tmp = memchr((void const   *)pi->next, '\"', (size_t )(pi->data_size - pos));
#line 120
  p = (char *)tmp;
  }
#line 121
  if (! p) {
    {
#line 122
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: opening \" not found\n",
            "libmtd");
    }
#line 122
    return (-1);
  }
#line 123
  p ++;
#line 124
  pos = (int )(p - pi->buf);
#line 125
  if (pos >= pi->data_size) {
    {
#line 126
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: opening \" not found\n",
            "libmtd");
    }
#line 126
    return (-1);
  }
  {
#line 128
  tmp___0 = memchr((void const   *)p, '\"', (size_t )(pi->data_size - pos));
#line 128
  p1 = (char *)tmp___0;
  }
#line 129
  if (! p1) {
    {
#line 130
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: closing \" not found\n",
            "libmtd");
    }
#line 130
    return (-1);
  }
#line 131
  pos = (int )(p1 - pi->buf);
#line 132
  if (pos >= pi->data_size) {
    {
#line 133
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: closing \" not found\n",
            "libmtd");
    }
#line 133
    return (-1);
  }
#line 135
  len = (int )(p1 - p);
#line 136
  if (len > 127) {
    {
#line 137
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: too long mtd%d device name\n",
            "libmtd", pi->mtd_num);
    }
#line 137
    return (-1);
  }
  {
#line 139
  memcpy((void */* __restrict  */)(pi->name), (void const   */* __restrict  */)p,
         (size_t )len);
#line 140
  pi->name[len] = (char )'\000';
  }
#line 142
  if ((int )*(p1 + 1) != 10) {
    {
#line 143
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: opening \"\n\" not found\n",
            "libmtd");
    }
#line 143
    return (-1);
  }
#line 144
  pi->next = p1 + 2;
#line 145
  return (1);
}
}
#line 42 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libcrc32.c"
static uint32_t const   crc32_table___1[256]  = 
#line 42 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libcrc32.c"
  {      (uint32_t const   )0L,      (uint32_t const   )1996959894L,      (uint32_t const   )3993919788L,      (uint32_t const   )2567524794L, 
        (uint32_t const   )124634137L,      (uint32_t const   )1886057615L,      (uint32_t const   )3915621685L,      (uint32_t const   )2657392035L, 
        (uint32_t const   )249268274L,      (uint32_t const   )2044508324L,      (uint32_t const   )3772115230L,      (uint32_t const   )2547177864L, 
        (uint32_t const   )162941995L,      (uint32_t const   )2125561021L,      (uint32_t const   )3887607047L,      (uint32_t const   )2428444049L, 
        (uint32_t const   )498536548L,      (uint32_t const   )1789927666L,      (uint32_t const   )4089016648L,      (uint32_t const   )2227061214L, 
        (uint32_t const   )450548861L,      (uint32_t const   )1843258603L,      (uint32_t const   )4107580753L,      (uint32_t const   )2211677639L, 
        (uint32_t const   )325883990L,      (uint32_t const   )1684777152L,      (uint32_t const   )4251122042L,      (uint32_t const   )2321926636L, 
        (uint32_t const   )335633487L,      (uint32_t const   )1661365465L,      (uint32_t const   )4195302755L,      (uint32_t const   )2366115317L, 
        (uint32_t const   )997073096L,      (uint32_t const   )1281953886L,      (uint32_t const   )3579855332L,      (uint32_t const   )2724688242L, 
        (uint32_t const   )1006888145L,      (uint32_t const   )1258607687L,      (uint32_t const   )3524101629L,      (uint32_t const   )2768942443L, 
        (uint32_t const   )901097722L,      (uint32_t const   )1119000684L,      (uint32_t const   )3686517206L,      (uint32_t const   )2898065728L, 
        (uint32_t const   )853044451L,      (uint32_t const   )1172266101L,      (uint32_t const   )3705015759L,      (uint32_t const   )2882616665L, 
        (uint32_t const   )651767980L,      (uint32_t const   )1373503546L,      (uint32_t const   )3369554304L,      (uint32_t const   )3218104598L, 
        (uint32_t const   )565507253L,      (uint32_t const   )1454621731L,      (uint32_t const   )3485111705L,      (uint32_t const   )3099436303L, 
        (uint32_t const   )671266974L,      (uint32_t const   )1594198024L,      (uint32_t const   )3322730930L,      (uint32_t const   )2970347812L, 
        (uint32_t const   )795835527L,      (uint32_t const   )1483230225L,      (uint32_t const   )3244367275L,      (uint32_t const   )3060149565L, 
        (uint32_t const   )1994146192L,      (uint32_t const   )31158534L,      (uint32_t const   )2563907772L,      (uint32_t const   )4023717930L, 
        (uint32_t const   )1907459465L,      (uint32_t const   )112637215L,      (uint32_t const   )2680153253L,      (uint32_t const   )3904427059L, 
        (uint32_t const   )2013776290L,      (uint32_t const   )251722036L,      (uint32_t const   )2517215374L,      (uint32_t const   )3775830040L, 
        (uint32_t const   )2137656763L,      (uint32_t const   )141376813L,      (uint32_t const   )2439277719L,      (uint32_t const   )3865271297L, 
        (uint32_t const   )1802195444L,      (uint32_t const   )476864866L,      (uint32_t const   )2238001368L,      (uint32_t const   )4066508878L, 
        (uint32_t const   )1812370925L,      (uint32_t const   )453092731L,      (uint32_t const   )2181625025L,      (uint32_t const   )4111451223L, 
        (uint32_t const   )1706088902L,      (uint32_t const   )314042704L,      (uint32_t const   )2344532202L,      (uint32_t const   )4240017532L, 
        (uint32_t const   )1658658271L,      (uint32_t const   )366619977L,      (uint32_t const   )2362670323L,      (uint32_t const   )4224994405L, 
        (uint32_t const   )1303535960L,      (uint32_t const   )984961486L,      (uint32_t const   )2747007092L,      (uint32_t const   )3569037538L, 
        (uint32_t const   )1256170817L,      (uint32_t const   )1037604311L,      (uint32_t const   )2765210733L,      (uint32_t const   )3554079995L, 
        (uint32_t const   )1131014506L,      (uint32_t const   )879679996L,      (uint32_t const   )2909243462L,      (uint32_t const   )3663771856L, 
        (uint32_t const   )1141124467L,      (uint32_t const   )855842277L,      (uint32_t const   )2852801631L,      (uint32_t const   )3708648649L, 
        (uint32_t const   )1342533948L,      (uint32_t const   )654459306L,      (uint32_t const   )3188396048L,      (uint32_t const   )3373015174L, 
        (uint32_t const   )1466479909L,      (uint32_t const   )544179635L,      (uint32_t const   )3110523913L,      (uint32_t const   )3462522015L, 
        (uint32_t const   )1591671054L,      (uint32_t const   )702138776L,      (uint32_t const   )2966460450L,      (uint32_t const   )3352799412L, 
        (uint32_t const   )1504918807L,      (uint32_t const   )783551873L,      (uint32_t const   )3082640443L,      (uint32_t const   )3233442989L, 
        (uint32_t const   )3988292384L,      (uint32_t const   )2596254646L,      (uint32_t const   )62317068L,      (uint32_t const   )1957810842L, 
        (uint32_t const   )3939845945L,      (uint32_t const   )2647816111L,      (uint32_t const   )81470997L,      (uint32_t const   )1943803523L, 
        (uint32_t const   )3814918930L,      (uint32_t const   )2489596804L,      (uint32_t const   )225274430L,      (uint32_t const   )2053790376L, 
        (uint32_t const   )3826175755L,      (uint32_t const   )2466906013L,      (uint32_t const   )167816743L,      (uint32_t const   )2097651377L, 
        (uint32_t const   )4027552580L,      (uint32_t const   )2265490386L,      (uint32_t const   )503444072L,      (uint32_t const   )1762050814L, 
        (uint32_t const   )4150417245L,      (uint32_t const   )2154129355L,      (uint32_t const   )426522225L,      (uint32_t const   )1852507879L, 
        (uint32_t const   )4275313526L,      (uint32_t const   )2312317920L,      (uint32_t const   )282753626L,      (uint32_t const   )1742555852L, 
        (uint32_t const   )4189708143L,      (uint32_t const   )2394877945L,      (uint32_t const   )397917763L,      (uint32_t const   )1622183637L, 
        (uint32_t const   )3604390888L,      (uint32_t const   )2714866558L,      (uint32_t const   )953729732L,      (uint32_t const   )1340076626L, 
        (uint32_t const   )3518719985L,      (uint32_t const   )2797360999L,      (uint32_t const   )1068828381L,      (uint32_t const   )1219638859L, 
        (uint32_t const   )3624741850L,      (uint32_t const   )2936675148L,      (uint32_t const   )906185462L,      (uint32_t const   )1090812512L, 
        (uint32_t const   )3747672003L,      (uint32_t const   )2825379669L,      (uint32_t const   )829329135L,      (uint32_t const   )1181335161L, 
        (uint32_t const   )3412177804L,      (uint32_t const   )3160834842L,      (uint32_t const   )628085408L,      (uint32_t const   )1382605366L, 
        (uint32_t const   )3423369109L,      (uint32_t const   )3138078467L,      (uint32_t const   )570562233L,      (uint32_t const   )1426400815L, 
        (uint32_t const   )3317316542L,      (uint32_t const   )2998733608L,      (uint32_t const   )733239954L,      (uint32_t const   )1555261956L, 
        (uint32_t const   )3268935591L,      (uint32_t const   )3050360625L,      (uint32_t const   )752459403L,      (uint32_t const   )1541320221L, 
        (uint32_t const   )2607071920L,      (uint32_t const   )3965973030L,      (uint32_t const   )1969922972L,      (uint32_t const   )40735498L, 
        (uint32_t const   )2617837225L,      (uint32_t const   )3943577151L,      (uint32_t const   )1913087877L,      (uint32_t const   )83908371L, 
        (uint32_t const   )2512341634L,      (uint32_t const   )3803740692L,      (uint32_t const   )2075208622L,      (uint32_t const   )213261112L, 
        (uint32_t const   )2463272603L,      (uint32_t const   )3855990285L,      (uint32_t const   )2094854071L,      (uint32_t const   )198958881L, 
        (uint32_t const   )2262029012L,      (uint32_t const   )4057260610L,      (uint32_t const   )1759359992L,      (uint32_t const   )534414190L, 
        (uint32_t const   )2176718541L,      (uint32_t const   )4139329115L,      (uint32_t const   )1873836001L,      (uint32_t const   )414664567L, 
        (uint32_t const   )2282248934L,      (uint32_t const   )4279200368L,      (uint32_t const   )1711684554L,      (uint32_t const   )285281116L, 
        (uint32_t const   )2405801727L,      (uint32_t const   )4167216745L,      (uint32_t const   )1634467795L,      (uint32_t const   )376229701L, 
        (uint32_t const   )2685067896L,      (uint32_t const   )3608007406L,      (uint32_t const   )1308918612L,      (uint32_t const   )956543938L, 
        (uint32_t const   )2808555105L,      (uint32_t const   )3495958263L,      (uint32_t const   )1231636301L,      (uint32_t const   )1047427035L, 
        (uint32_t const   )2932959818L,      (uint32_t const   )3654703836L,      (uint32_t const   )1088359270L,      (uint32_t const   )936918000L, 
        (uint32_t const   )2847714899L,      (uint32_t const   )3736837829L,      (uint32_t const   )1202900863L,      (uint32_t const   )817233897L, 
        (uint32_t const   )3183342108L,      (uint32_t const   )3401237130L,      (uint32_t const   )1404277552L,      (uint32_t const   )615818150L, 
        (uint32_t const   )3134207493L,      (uint32_t const   )3453421203L,      (uint32_t const   )1423857449L,      (uint32_t const   )601450431L, 
        (uint32_t const   )3009837614L,      (uint32_t const   )3294710456L,      (uint32_t const   )1567103746L,      (uint32_t const   )711928724L, 
        (uint32_t const   )3020668471L,      (uint32_t const   )3272380065L,      (uint32_t const   )1510334235L,      (uint32_t const   )755167117L};
#line 72 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/ftl_check.c"
static void print_size___0(u_int s ) 
{ 


  {
#line 74
  if (s > 1048576U) {
#line 74
    if (s % 1048576U == 0U) {
      {
#line 75
      printf((char const   */* __restrict  */)"%d mb", s / 1048576U);
      }
    } else {
#line 74
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 76
  if (s > 1024U) {
#line 76
    if (s % 1024U == 0U) {
      {
#line 77
      printf((char const   */* __restrict  */)"%d kb", s / 1024U);
      }
    } else {
      {
#line 79
      printf((char const   */* __restrict  */)"%d bytes", s);
      }
    }
  } else {
    {
#line 79
    printf((char const   */* __restrict  */)"%d bytes", s);
    }
  }
#line 80
  return;
}
}
#line 84 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/ftl_check.c"
static void check_partition(int fd ) 
{ 
  mtd_info_t mtd ;
  erase_unit_header_t hdr ;
  erase_unit_header_t hdr2 ;
  u_int i ;
  u_int j ;
  u_int nbam ;
  u_int *bam ;
  int control ;
  int data ;
  int free___0 ;
  int deleted ;
  int tmp ;
  __off64_t tmp___0 ;
  void *tmp___1 ;
  __off64_t tmp___2 ;
  ssize_t tmp___3 ;
  __off64_t tmp___4 ;
  ssize_t tmp___5 ;

  {
  {
#line 92
  tmp = ioctl(fd, (unsigned long )(((2U << 30) | (unsigned int )(77 << 8)) | 1U) | (sizeof(struct mtd_info_user ) << 16),
              & mtd);
  }
#line 92
  if (tmp != 0) {
    {
#line 93
    perror("get info failed");
    }
#line 94
    return;
  }
  {
#line 97
  printf((char const   */* __restrict  */)"Memory region info:\n");
#line 98
  printf((char const   */* __restrict  */)"  Region size = ");
#line 99
  print_size___0(mtd.size);
#line 100
  printf((char const   */* __restrict  */)"  Erase block size = ");
#line 101
  print_size___0(mtd.erasesize);
#line 102
  printf((char const   */* __restrict  */)"\n\n");
#line 104
  i = (u_int )0;
  }
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 104
    if (! (i < mtd.size / mtd.erasesize)) {
#line 104
      goto while_break;
    }
    {
#line 105
    tmp___0 = lseek(fd, (__off64_t )(i * mtd.erasesize), 0);
    }
#line 105
    if (tmp___0 == -1L) {
      {
#line 106
      perror("seek failed");
      }
#line 107
      goto while_break;
    }
    {
#line 109
    read(fd, (void *)(& hdr), sizeof(hdr));
    }
#line 110
    if (hdr.FormattedSize > 0U) {
#line 110
      if (hdr.FormattedSize <= mtd.size) {
#line 110
        if ((int )hdr.NumEraseUnits > 0) {
#line 110
          if ((__u32 )hdr.NumEraseUnits <= mtd.size / mtd.erasesize) {
#line 114
            goto while_break;
          }
        }
      }
    }
#line 104
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 116
  if (i == mtd.size / mtd.erasesize) {
    {
#line 117
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No valid erase unit headers!\n");
    }
#line 118
    return;
  }
  {
#line 121
  printf((char const   */* __restrict  */)"Partition header:\n");
#line 122
  printf((char const   */* __restrict  */)"  Formatted size = ");
#line 123
  print_size___0(hdr.FormattedSize);
#line 124
  printf((char const   */* __restrict  */)", erase units = %d, transfer units = %d\n",
         (int )hdr.NumEraseUnits, (int )hdr.NumTransferUnits);
#line 126
  printf((char const   */* __restrict  */)"  Erase unit size = ");
#line 127
  print_size___0((u_int )(1 << (int )hdr.EraseUnitSize));
#line 128
  printf((char const   */* __restrict  */)", virtual block size = ");
#line 129
  print_size___0((u_int )(1 << (int )hdr.BlockSize));
#line 130
  printf((char const   */* __restrict  */)"\n");
#line 133
  nbam = mtd.erasesize >> (int )hdr.BlockSize;
#line 134
  tmp___1 = malloc((unsigned long )nbam * sizeof(u_int ));
#line 134
  bam = (u_int *)tmp___1;
#line 136
  i = (u_int )0;
  }
  {
#line 136
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 136
    if (! (i < (u_int )hdr.NumEraseUnits)) {
#line 136
      goto while_break___0;
    }
    {
#line 137
    tmp___2 = lseek(fd, (__off64_t )(i << (int )hdr.EraseUnitSize), 0);
    }
#line 137
    if (tmp___2 == -1L) {
      {
#line 138
      perror("seek failed");
      }
#line 139
      goto while_break___0;
    }
    {
#line 141
    tmp___3 = read(fd, (void *)(& hdr2), sizeof(hdr2));
    }
#line 141
    if (tmp___3 == -1L) {
      {
#line 142
      perror("read failed");
      }
#line 143
      goto while_break___0;
    }
    {
#line 145
    printf((char const   */* __restrict  */)"\nErase unit %d:\n", i);
    }
#line 146
    if (hdr2.FormattedSize != hdr.FormattedSize) {
      {
#line 149
      printf((char const   */* __restrict  */)"  Erase unit header is corrupt.\n");
      }
    } else
#line 146
    if ((int )hdr2.NumEraseUnits != (int )hdr.NumEraseUnits) {
      {
#line 149
      printf((char const   */* __restrict  */)"  Erase unit header is corrupt.\n");
      }
    } else
#line 146
    if (hdr2.SerialNumber != hdr.SerialNumber) {
      {
#line 149
      printf((char const   */* __restrict  */)"  Erase unit header is corrupt.\n");
      }
    } else
#line 150
    if ((int )hdr2.LogicalEUN == 65535) {
      {
#line 151
      printf((char const   */* __restrict  */)"  Transfer unit, erase count = %d\n",
             hdr2.EraseCount);
      }
    } else {
      {
#line 153
      printf((char const   */* __restrict  */)"  Logical unit %d, erase count = %d\n",
             (int )hdr2.LogicalEUN, hdr2.EraseCount);
#line 155
      tmp___4 = lseek(fd, (__off64_t )((i << (int )hdr.EraseUnitSize) + hdr.BAMOffset),
                      0);
      }
#line 155
      if (tmp___4 == -1L) {
        {
#line 157
        perror("seek failed");
        }
#line 158
        goto while_break___0;
      }
      {
#line 160
      tmp___5 = read(fd, (void *)bam, (unsigned long )nbam * sizeof(u_int ));
      }
#line 160
      if (tmp___5 == -1L) {
        {
#line 161
        perror("read failed");
        }
#line 162
        goto while_break___0;
      }
#line 164
      data = 0;
#line 164
      control = data;
#line 164
      deleted = control;
#line 164
      free___0 = deleted;
#line 165
      j = (u_int )0;
      {
#line 165
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 165
        if (! (j < nbam)) {
#line 165
          goto while_break___1;
        }
#line 166
        if (*(bam + j) == 4294967295U) {
#line 167
          free___0 ++;
        } else
#line 168
        if (*(bam + j) == 0U) {
#line 169
          deleted ++;
        } else
#line 168
        if (*(bam + j) == 4294967294U) {
#line 169
          deleted ++;
        } else {
          {
#line 171
          if ((*(bam + j) & 127U) == 48U) {
#line 171
            goto case_48;
          }
#line 172
          if ((*(bam + j) & 127U) == 64U) {
#line 172
            goto case_64;
          }
#line 173
          goto switch_default;
          case_48: /* CIL Label */ 
#line 171
          control ++;
#line 171
          goto switch_break;
          case_64: /* CIL Label */ 
#line 172
          data ++;
#line 172
          goto switch_break;
          switch_default: /* CIL Label */ 
#line 173
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
        }
#line 165
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 176
      printf((char const   */* __restrict  */)"  Block allocation: %d control, %d data, %d free, %d deleted\n",
             control, data, free___0, deleted);
      }
    }
#line 136
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 180
  return;
}
}
#line 183 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/ftl_check.c"
void showusage(void) 
{ 


  {
  {
#line 185
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"usage: %s device\n",
          "ftl_check");
  }
#line 186
  return;
}
}
#line 117 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static char const   *allPp___2[17]  = 
#line 117 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
  {      (char const   *)((void *)0),      (char const   *)((void *)0),      "111",      "1101", 
        "11001",      "101001",      "1100001",      "10010001", 
        "101110001",      "1000100001",      "10010000001",      "101000000001", 
        "1100101000001",      "11011000000001",      "110000100010001",      "1100000000000001", 
        "11010000000010001"};
#line 147 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static gf gf_exp___2[2 * ((1 << 8) - 1)]  ;
#line 148 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static int gf_log___2[((1 << 8) - 1) + 1]  ;
#line 149 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static gf inverse___2[((1 << 8) - 1) + 1]  ;
#line 179 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static gf gf_mul_table___2[((1 << 8) - 1) + 1][((1 << 8) - 1) + 1]  ;
#line 187 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static void init_mul_table___2(void) 
{ 
  int i ;
  int j ;
  gf tmp ;
  gf tmp___0 ;

  {
#line 191
  i = 0;
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 191
    if (! (i < ((1 << 8) - 1) + 1)) {
#line 191
      goto while_break;
    }
#line 192
    j = 0;
    {
#line 192
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 192
      if (! (j < ((1 << 8) - 1) + 1)) {
#line 192
        goto while_break___0;
      }
      {
#line 193
      tmp = modnn(gf_log___2[i] + gf_log___2[j]);
#line 193
      gf_mul_table___2[i][j] = gf_exp___2[tmp];
#line 192
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 191
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 195
  j = 0;
  {
#line 195
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 195
    if (! (j < ((1 << 8) - 1) + 1)) {
#line 195
      goto while_break___1;
    }
#line 196
    tmp___0 = (gf )0;
#line 196
    gf_mul_table___2[j][0] = tmp___0;
#line 196
    gf_mul_table___2[0][j] = tmp___0;
#line 195
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 197
  return;
}
}
#line 228 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static void *my_malloc___2(int sz , char const   *err_string ) 
{ 
  void *p ;
  void *tmp ;

  {
  {
#line 231
  tmp = malloc((size_t )sz);
#line 231
  p = tmp;
  }
#line 232
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 233
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-- malloc failure allocating %s\n",
            err_string);
#line 234
    exit(1);
    }
  }
#line 236
  return (p);
}
}
#line 245 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static void generate_gf___2(void) 
{ 
  int i ;
  gf mask ;
  char const   *Pp ;

  {
#line 250
  Pp = allPp___2[8];
#line 252
  mask = (gf )1;
#line 253
  gf_exp___2[8] = (gf )0;
#line 260
  i = 0;
  {
#line 260
  while (1) {
    while_continue: /* CIL Label */ ;
#line 260
    if (! (i < 8)) {
#line 260
      goto while_break;
    }
#line 261
    gf_exp___2[i] = mask;
#line 262
    gf_log___2[gf_exp___2[i]] = i;
#line 267
    if ((int const   )*(Pp + i) == 49) {
#line 268
      gf_exp___2[8] = (gf )((int )gf_exp___2[8] ^ (int )mask);
    }
#line 260
    i ++;
#line 260
    mask = (gf )((int )mask << 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 274
  gf_log___2[gf_exp___2[8]] = 8;
#line 281
  mask = (gf )(1 << 7);
#line 282
  i = 9;
  {
#line 282
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 282
    if (! (i < (1 << 8) - 1)) {
#line 282
      goto while_break___0;
    }
#line 283
    if ((int )gf_exp___2[i - 1] >= (int )mask) {
#line 284
      gf_exp___2[i] = (gf )((int )gf_exp___2[8] ^ (((int )gf_exp___2[i - 1] ^ (int )mask) << 1));
    } else {
#line 286
      gf_exp___2[i] = (gf )((int )gf_exp___2[i - 1] << 1);
    }
#line 287
    gf_log___2[gf_exp___2[i]] = i;
#line 282
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 292
  gf_log___2[0] = (1 << 8) - 1;
#line 294
  i = 0;
  {
#line 294
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 294
    if (! (i < (1 << 8) - 1)) {
#line 294
      goto while_break___1;
    }
#line 295
    gf_exp___2[i + ((1 << 8) - 1)] = gf_exp___2[i];
#line 294
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 302
  inverse___2[0] = (gf )0;
#line 303
  inverse___2[1] = (gf )1;
#line 304
  i = 2;
  {
#line 304
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 304
    if (! (i <= (1 << 8) - 1)) {
#line 304
      goto while_break___2;
    }
#line 305
    inverse___2[i] = gf_exp___2[((1 << 8) - 1) - gf_log___2[i]];
#line 304
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 306
  return;
}
}
#line 325 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static void addmul1___2(gf *dst1 , gf *src1 , gf c , int sz ) 
{ 
  register gf *__gf_mulc_ ;
  register gf *dst ;
  register gf *src ;
  gf *lim ;

  {
#line 329
  dst = dst1;
#line 329
  src = src1;
#line 330
  lim = dst + ((sz - 16) + 1);
#line 332
  __gf_mulc_ = gf_mul_table___2[c];
  {
#line 335
  while (1) {
    while_continue: /* CIL Label */ ;
#line 335
    if (! ((unsigned long )dst < (unsigned long )lim)) {
#line 335
      goto while_break;
    }
#line 336
    *(dst + 0) = (gf )((int )*(dst + 0) ^ (int )*(__gf_mulc_ + *(src + 0)));
#line 337
    *(dst + 1) = (gf )((int )*(dst + 1) ^ (int )*(__gf_mulc_ + *(src + 1)));
#line 338
    *(dst + 2) = (gf )((int )*(dst + 2) ^ (int )*(__gf_mulc_ + *(src + 2)));
#line 339
    *(dst + 3) = (gf )((int )*(dst + 3) ^ (int )*(__gf_mulc_ + *(src + 3)));
#line 341
    *(dst + 4) = (gf )((int )*(dst + 4) ^ (int )*(__gf_mulc_ + *(src + 4)));
#line 342
    *(dst + 5) = (gf )((int )*(dst + 5) ^ (int )*(__gf_mulc_ + *(src + 5)));
#line 343
    *(dst + 6) = (gf )((int )*(dst + 6) ^ (int )*(__gf_mulc_ + *(src + 6)));
#line 344
    *(dst + 7) = (gf )((int )*(dst + 7) ^ (int )*(__gf_mulc_ + *(src + 7)));
#line 347
    *(dst + 8) = (gf )((int )*(dst + 8) ^ (int )*(__gf_mulc_ + *(src + 8)));
#line 348
    *(dst + 9) = (gf )((int )*(dst + 9) ^ (int )*(__gf_mulc_ + *(src + 9)));
#line 349
    *(dst + 10) = (gf )((int )*(dst + 10) ^ (int )*(__gf_mulc_ + *(src + 10)));
#line 350
    *(dst + 11) = (gf )((int )*(dst + 11) ^ (int )*(__gf_mulc_ + *(src + 11)));
#line 351
    *(dst + 12) = (gf )((int )*(dst + 12) ^ (int )*(__gf_mulc_ + *(src + 12)));
#line 352
    *(dst + 13) = (gf )((int )*(dst + 13) ^ (int )*(__gf_mulc_ + *(src + 13)));
#line 353
    *(dst + 14) = (gf )((int )*(dst + 14) ^ (int )*(__gf_mulc_ + *(src + 14)));
#line 354
    *(dst + 15) = (gf )((int )*(dst + 15) ^ (int )*(__gf_mulc_ + *(src + 15)));
#line 335
    dst += 16;
#line 335
    src += 16;
  }
  while_break: /* CIL Label */ ;
  }
#line 358
  lim += 15;
  {
#line 359
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 359
    if (! ((unsigned long )dst < (unsigned long )lim)) {
#line 359
      goto while_break___0;
    }
#line 360
    *dst = (gf )((int )*dst ^ (int )*(__gf_mulc_ + *src));
#line 359
    dst ++;
#line 359
    src ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 361
  return;
}
}
#line 366 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static void matmul___2(gf *a , gf *b , gf *c , int n , int k , int m ) 
{ 
  int row ;
  int col ;
  int i ;
  gf *pa ;
  gf *pb ;
  gf acc ;

  {
#line 371
  row = 0;
  {
#line 371
  while (1) {
    while_continue: /* CIL Label */ ;
#line 371
    if (! (row < n)) {
#line 371
      goto while_break;
    }
#line 372
    col = 0;
    {
#line 372
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 372
      if (! (col < m)) {
#line 372
        goto while_break___0;
      }
#line 373
      pa = a + row * k;
#line 374
      pb = b + col;
#line 375
      acc = (gf )0;
#line 376
      i = 0;
      {
#line 376
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 376
        if (! (i < k)) {
#line 376
          goto while_break___1;
        }
#line 377
        acc = (gf )((int )acc ^ (int )gf_mul_table___2[*pa][*pb]);
#line 376
        i ++;
#line 376
        pa ++;
#line 376
        pb += m;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 378
      *(c + (row * m + col)) = acc;
#line 372
      col ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 371
    row ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 381
  return;
}
}
#line 410 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static int invert_mat___2(gf *src , int k ) 
{ 
  gf c ;
  gf *p ;
  int irow ;
  int icol ;
  int row ;
  int col ;
  int i ;
  int ix ;
  int error ;
  int *indxc ;
  void *tmp ;
  int *indxr ;
  void *tmp___0 ;
  int *ipiv ;
  void *tmp___1 ;
  gf *id_row ;
  void *tmp___2 ;
  gf *temp_row ;
  void *tmp___3 ;
  gf *pivot_row ;
  gf tmp___4 ;
  int tmp___5 ;
  gf tmp___6 ;

  {
  {
#line 416
  error = 1;
#line 417
  tmp = my_malloc___2((int )((unsigned long )k * sizeof(int )), "indxc");
#line 417
  indxc = (int *)tmp;
#line 418
  tmp___0 = my_malloc___2((int )((unsigned long )k * sizeof(int )), "indxr");
#line 418
  indxr = (int *)tmp___0;
#line 419
  tmp___1 = my_malloc___2((int )((unsigned long )k * sizeof(int )), "ipiv");
#line 419
  ipiv = (int *)tmp___1;
#line 420
  tmp___2 = my_malloc___2((int )((unsigned long )k * sizeof(gf )), " ## __LINE__ ## ");
#line 420
  id_row = (gf *)tmp___2;
#line 421
  tmp___3 = my_malloc___2((int )((unsigned long )k * sizeof(gf )), " ## __LINE__ ## ");
#line 421
  temp_row = (gf *)tmp___3;
#line 423
  memset((void *)id_row, '\000', (unsigned long )k * sizeof(gf ));
#line 428
  i = 0;
  }
  {
#line 428
  while (1) {
    while_continue: /* CIL Label */ ;
#line 428
    if (! (i < k)) {
#line 428
      goto while_break;
    }
#line 429
    *(ipiv + i) = 0;
#line 428
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 431
  col = 0;
  {
#line 431
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 431
    if (! (col < k)) {
#line 431
      goto while_break___0;
    }
#line 437
    icol = -1;
#line 437
    irow = icol;
#line 438
    if (*(ipiv + col) != 1) {
#line 438
      if ((int )*(src + (col * k + col)) != 0) {
#line 439
        irow = col;
#line 440
        icol = col;
#line 441
        goto found_piv;
      }
    }
#line 443
    row = 0;
    {
#line 443
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 443
      if (! (row < k)) {
#line 443
        goto while_break___1;
      }
#line 444
      if (*(ipiv + row) != 1) {
#line 445
        ix = 0;
        {
#line 445
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 445
          if (! (ix < k)) {
#line 445
            goto while_break___2;
          }
#line 447
          if (*(ipiv + ix) == 0) {
#line 448
            if ((int )*(src + (row * k + ix)) != 0) {
#line 449
              irow = row;
#line 450
              icol = ix;
#line 451
              goto found_piv;
            }
          } else
#line 453
          if (*(ipiv + ix) > 1) {
            {
#line 454
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"singular matrix\n");
            }
#line 455
            goto fail;
          }
#line 445
          ix ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 443
      row ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 460
    if (icol == -1) {
      {
#line 461
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"XXX pivot not found!\n");
      }
#line 462
      goto fail;
    }
    found_piv: 
#line 465
    (*(ipiv + icol)) ++;
#line 471
    if (irow != icol) {
#line 472
      ix = 0;
      {
#line 472
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 472
        if (! (ix < k)) {
#line 472
          goto while_break___3;
        }
#line 473
        tmp___4 = *(src + (irow * k + ix));
#line 473
        *(src + (irow * k + ix)) = *(src + (icol * k + ix));
#line 473
        *(src + (icol * k + ix)) = tmp___4;
#line 472
        ix ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 476
    *(indxr + col) = irow;
#line 477
    *(indxc + col) = icol;
#line 478
    pivot_row = src + icol * k;
#line 479
    c = *(pivot_row + icol);
#line 480
    if ((int )c == 0) {
      {
#line 481
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"singular matrix 2\n");
      }
#line 482
      goto fail;
    }
#line 484
    if ((int )c != 1) {
#line 490
      c = inverse___2[c];
#line 491
      *(pivot_row + icol) = (gf )1;
#line 492
      ix = 0;
      {
#line 492
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 492
        if (! (ix < k)) {
#line 492
          goto while_break___4;
        }
#line 493
        *(pivot_row + ix) = gf_mul_table___2[c][*(pivot_row + ix)];
#line 492
        ix ++;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
    {
#line 502
    *(id_row + icol) = (gf )1;
#line 503
    tmp___5 = memcmp((void const   *)pivot_row, (void const   *)id_row, (unsigned long )k * sizeof(gf ));
    }
#line 503
    if (tmp___5 != 0) {
#line 504
      p = src;
#line 504
      ix = 0;
      {
#line 504
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 504
        if (! (ix < k)) {
#line 504
          goto while_break___5;
        }
#line 505
        if (ix != icol) {
#line 506
          c = *(p + icol);
#line 507
          *(p + icol) = (gf )0;
#line 508
          if ((int )c != 0) {
            {
#line 508
            addmul1___2(p, pivot_row, c, k);
            }
          }
        }
#line 504
        ix ++;
#line 504
        p += k;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
#line 512
    *(id_row + icol) = (gf )0;
#line 431
    col ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 514
  col = k - 1;
  {
#line 514
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 514
    if (! (col >= 0)) {
#line 514
      goto while_break___6;
    }
#line 515
    if (*(indxr + col) < 0) {
      {
#line 516
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"AARGH, indxr[col] %d\n",
              *(indxr + col));
      }
    } else
#line 515
    if (*(indxr + col) >= k) {
      {
#line 516
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"AARGH, indxr[col] %d\n",
              *(indxr + col));
      }
    } else
#line 517
    if (*(indxc + col) < 0) {
      {
#line 518
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"AARGH, indxc[col] %d\n",
              *(indxc + col));
      }
    } else
#line 517
    if (*(indxc + col) >= k) {
      {
#line 518
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"AARGH, indxc[col] %d\n",
              *(indxc + col));
      }
    } else
#line 520
    if (*(indxr + col) != *(indxc + col)) {
#line 521
      row = 0;
      {
#line 521
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 521
        if (! (row < k)) {
#line 521
          goto while_break___7;
        }
#line 522
        tmp___6 = *(src + (row * k + *(indxr + col)));
#line 522
        *(src + (row * k + *(indxr + col))) = *(src + (row * k + *(indxc + col)));
#line 522
        *(src + (row * k + *(indxc + col))) = tmp___6;
#line 521
        row ++;
      }
      while_break___7: /* CIL Label */ ;
      }
    }
#line 514
    col --;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 526
  error = 0;
  fail: 
  {
#line 528
  free((void *)indxc);
#line 529
  free((void *)indxr);
#line 530
  free((void *)ipiv);
#line 531
  free((void *)id_row);
#line 532
  free((void *)temp_row);
  }
#line 533
  return (error);
}
}
#line 604 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static int fec_initialized___2  =    0;
#line 605 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static void init_fec___2(void) 
{ 


  {
  {
#line 609
  generate_gf___2();
#line 613
  init_mul_table___2();
#line 616
  fec_initialized___2 = 1;
  }
#line 617
  return;
}
}
#line 755 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static int shuffle___2(gf **pkt , int *index___0 , int k ) 
{ 
  int i ;
  int c ;
  int tmp ;
  gf *tmp___0 ;

  {
#line 760
  i = 0;
  {
#line 760
  while (1) {
    while_continue: /* CIL Label */ ;
#line 760
    if (! (i < k)) {
#line 760
      goto while_break;
    }
#line 761
    if (*(index___0 + i) >= k) {
#line 762
      i ++;
    } else
#line 761
    if (*(index___0 + i) == i) {
#line 762
      i ++;
    } else {
#line 767
      c = *(index___0 + i);
#line 769
      if (*(index___0 + c) == c) {
#line 771
        return (1);
      }
#line 773
      tmp = *(index___0 + i);
#line 773
      *(index___0 + i) = *(index___0 + c);
#line 773
      *(index___0 + c) = tmp;
#line 774
      tmp___0 = *(pkt + i);
#line 774
      *(pkt + i) = *(pkt + c);
#line 774
      *(pkt + c) = tmp___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 787
  return (0);
}
}
#line 795 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static gf *build_decode_matrix___2(struct fec_parms *code , int *index___0 ) 
{ 
  int i ;
  int k ;
  gf *p ;
  gf *matrix ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 798
  k = code->k;
#line 799
  tmp = my_malloc___2((int )((unsigned long )(k * k) * sizeof(gf )), " ## __LINE__ ## ");
#line 799
  matrix = (gf *)tmp;
#line 802
  i = 0;
#line 802
  p = matrix;
  }
  {
#line 802
  while (1) {
    while_continue: /* CIL Label */ ;
#line 802
    if (! (i < k)) {
#line 802
      goto while_break;
    }
#line 804
    if (*(index___0 + i) < k) {
      {
#line 805
      memset((void *)p, '\000', (unsigned long )k * sizeof(gf ));
#line 806
      *(p + i) = (gf )1;
      }
    } else
#line 809
    if (*(index___0 + i) < code->n) {
      {
#line 810
      memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(code->enc_matrix + *(index___0 + i) * k),
             (unsigned long )k * sizeof(gf ));
      }
    } else {
      {
#line 812
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"decode: invalid index %d (max %d)\n",
              *(index___0 + i), code->n - 1);
#line 814
      free((void *)matrix);
      }
#line 815
      return ((gf *)((void *)0));
    }
#line 802
    i ++;
#line 802
    p += k;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 819
  tmp___0 = invert_mat___2(matrix, k);
  }
#line 819
  if (tmp___0) {
    {
#line 820
    free((void *)matrix);
#line 821
    matrix = (gf *)((void *)0);
    }
  }
#line 824
  return (matrix);
}
}
#line 38 "./include/xalloc.h"
static void *xmalloc___6(size_t size )  __attribute__((__unused__)) ;
#line 38 "./include/xalloc.h"
static void *xmalloc___6(size_t size ) 
{ 
  void *ptr ;
  void *tmp ;
  int _err ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 41
  tmp = malloc(size);
#line 41
  ptr = tmp;
  }
#line 43
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 43
    if (size != 0UL) {
      {
#line 44
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 44
        tmp___0 = __errno_location();
#line 44
        _err = *tmp___0;
#line 44
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: out of memory\n",
                "libmtd");
#line 44
        tmp___1 = strerror(_err);
#line 44
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
                (int )sizeof("libmtd") + 1, "", _err, tmp___1);
#line 44
        exit(-1);
        }
#line 44
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 45
  return (ptr);
}
}
#line 48
static void *xcalloc___2(size_t nmemb , size_t size )  __attribute__((__unused__)) ;
#line 48 "./include/xalloc.h"
static void *xcalloc___2(size_t nmemb , size_t size ) 
{ 
  void *ptr ;
  void *tmp ;
  int _err ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 51
  tmp = calloc(nmemb, size);
#line 51
  ptr = tmp;
  }
#line 53
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 53
    if (nmemb != 0UL) {
#line 53
      if (size != 0UL) {
        {
#line 54
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 54
          tmp___0 = __errno_location();
#line 54
          _err = *tmp___0;
#line 54
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: out of memory\n",
                  "libmtd");
#line 54
          tmp___1 = strerror(_err);
#line 54
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
                  (int )sizeof("libmtd") + 1, "", _err, tmp___1);
#line 54
          exit(-1);
          }
#line 54
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
  }
#line 55
  return (ptr);
}
}
#line 58
static void *xzalloc___2(size_t size )  __attribute__((__unused__)) ;
#line 58 "./include/xalloc.h"
static void *xzalloc___2(size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 61
  tmp = xcalloc___2((size_t )1, size);
  }
#line 61
  return (tmp);
}
}
#line 50 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static char *mkpath___2(char const   *path , char const   *name ) 
{ 
  char *n ;
  size_t len1 ;
  size_t tmp ;
  size_t len2 ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 53
  tmp = strlen(path);
#line 53
  len1 = tmp;
#line 54
  tmp___0 = strlen(name);
#line 54
  len2 = tmp___0;
#line 56
  tmp___1 = xmalloc___6((len1 + len2) + 2UL);
#line 56
  n = (char *)tmp___1;
#line 58
  memcpy((void */* __restrict  */)n, (void const   */* __restrict  */)path, len1);
  }
#line 59
  if ((int )*(n + (len1 - 1UL)) != 47) {
#line 60
    tmp___2 = len1;
#line 60
    len1 ++;
#line 60
    *(n + tmp___2) = (char )'/';
  }
  {
#line 62
  memcpy((void */* __restrict  */)(n + len1), (void const   */* __restrict  */)name,
         len2 + 1UL);
  }
#line 63
  return (n);
}
}
#line 76 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int read_data___2(char const   *file , void *buf , int buf_len ) 
{ 
  int fd ;
  int rd ;
  int tmp ;
  int tmp1 ;
  ssize_t tmp___0 ;
  int _err ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  ssize_t tmp___4 ;
  int _err___0 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;
  int _err___1 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;

  {
  {
#line 80
  fd = open(file, 524288);
  }
#line 81
  if (fd == -1) {
#line 82
    return (-1);
  }
  {
#line 84
  tmp___0 = read(fd, buf, (size_t )buf_len);
#line 84
  rd = (int )tmp___0;
  }
#line 85
  if (rd == -1) {
    {
#line 86
    tmp___1 = __errno_location();
#line 86
    _err = *tmp___1;
#line 86
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: cannot read \"%s\"\n",
            "libmtd", file);
#line 86
    tmp___2 = strerror(_err);
#line 86
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err, tmp___2);
    }
#line 87
    goto out_error;
  }
#line 90
  if (rd == buf_len) {
    {
#line 91
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: contents of \"%s\" is too long\n",
            "libmtd", file);
#line 92
    tmp___3 = __errno_location();
#line 92
    *tmp___3 = 22;
    }
#line 93
    goto out_error;
  }
  {
#line 96
  *((char *)buf + rd) = (char )'\000';
#line 99
  tmp___4 = read(fd, (void *)(& tmp), (size_t )1);
#line 99
  tmp1 = (int )tmp___4;
  }
#line 100
  if (tmp1 == 1) {
    {
#line 101
    tmp___5 = __errno_location();
#line 101
    _err___0 = *tmp___5;
#line 101
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: cannot read \"%s\"\n",
            "libmtd", file);
#line 101
    tmp___6 = strerror(_err___0);
#line 101
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err___0, tmp___6);
    }
#line 102
    goto out_error;
  }
#line 104
  if (tmp1) {
    {
#line 105
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: file \"%s\" contains too much data (> %d bytes)\n",
            "libmtd", file, buf_len);
#line 107
    tmp___7 = __errno_location();
#line 107
    *tmp___7 = 22;
    }
#line 108
    goto out_error;
  }
  {
#line 111
  tmp___10 = close(fd);
  }
#line 111
  if (tmp___10) {
    {
#line 112
    tmp___8 = __errno_location();
#line 112
    _err___1 = *tmp___8;
#line 112
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: close failed on \"%s\"\n",
            "libmtd", file);
#line 112
    tmp___9 = strerror(_err___1);
#line 112
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err___1, tmp___9);
    }
#line 113
    return (-1);
  }
#line 116
  return (rd);
  out_error: 
  {
#line 119
  close(fd);
  }
#line 120
  return (-1);
}
}
#line 131 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int read_major___2(char const   *file , int *major , int *minor ) 
{ 
  int ret ;
  char buf[50] ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 136
  ret = read_data___2(file, (void *)(buf), 50);
  }
#line 137
  if (ret < 0) {
#line 138
    return (ret);
  }
  {
#line 140
  ret = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%d:%d\n",
               major, minor);
  }
#line 141
  if (ret != 2) {
    {
#line 142
    tmp = __errno_location();
#line 142
    *tmp = 22;
#line 143
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: \"%s\" does not have major:minor format\n",
            "libmtd", file);
    }
#line 143
    return (-1);
  }
#line 146
  if (*major < 0) {
    {
#line 147
    tmp___0 = __errno_location();
#line 147
    *tmp___0 = 22;
#line 148
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: bad major:minor %d:%d in \"%s\"\n",
            "libmtd", *major, *minor, file);
    }
#line 148
    return (-1);
  } else
#line 146
  if (*minor < 0) {
    {
#line 147
    tmp___0 = __errno_location();
#line 147
    *tmp___0 = 22;
#line 148
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: bad major:minor %d:%d in \"%s\"\n",
            "libmtd", *major, *minor, file);
    }
#line 148
    return (-1);
  }
#line 152
  return (0);
}
}
#line 164 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int dev_get_major___2(struct libmtd *lib , int mtd_num , int *major , int *minor ) 
{ 
  size_t tmp ;
  char *file ;
  unsigned long __lengthoffile ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 166
  tmp = strlen((char const   *)lib->mtd_dev);
#line 166
  __lengthoffile = tmp + 50UL;
#line 166
  tmp___0 = __builtin_alloca(sizeof(*file) * __lengthoffile);
#line 166
  file = (char *)tmp___0;
#line 168
  sprintf((char */* __restrict  */)file, (char const   */* __restrict  */)lib->mtd_dev,
          mtd_num);
#line 169
  tmp___1 = read_major___2((char const   *)file, major, minor);
  }
#line 169
  return (tmp___1);
}
}
#line 182 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int dev_read_data___2(char const   *patt , int mtd_num , void *buf , int buf_len ) 
{ 
  size_t tmp ;
  char *file ;
  unsigned long __lengthoffile ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 184
  tmp = strlen(patt);
#line 184
  __lengthoffile = tmp + 100UL;
#line 184
  tmp___0 = __builtin_alloca(sizeof(*file) * __lengthoffile);
#line 184
  file = (char *)tmp___0;
#line 186
  sprintf((char */* __restrict  */)file, (char const   */* __restrict  */)patt, mtd_num);
#line 187
  tmp___1 = read_data___2((char const   *)file, buf, buf_len);
  }
#line 187
  return (tmp___1);
}
}
#line 199 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int read_hex_ll___2(char const   *file , long long *value ) 
{ 
  int fd ;
  int rd ;
  char buf[50] ;
  ssize_t tmp ;
  int _err ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int _err___0 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;

  {
  {
#line 204
  fd = open(file, 524288);
  }
#line 205
  if (fd == -1) {
#line 206
    return (-1);
  }
  {
#line 208
  tmp = read(fd, (void *)(buf), sizeof(buf));
#line 208
  rd = (int )tmp;
  }
#line 209
  if (rd == -1) {
    {
#line 210
    tmp___0 = __errno_location();
#line 210
    _err = *tmp___0;
#line 210
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: cannot read \"%s\"\n",
            "libmtd", file);
#line 210
    tmp___1 = strerror(_err);
#line 210
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err, tmp___1);
    }
#line 211
    goto out_error;
  }
#line 213
  if ((unsigned long )rd == sizeof(buf)) {
    {
#line 214
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: contents of \"%s\" is too long\n",
            "libmtd", file);
#line 215
    tmp___2 = __errno_location();
#line 215
    *tmp___2 = 22;
    }
#line 216
    goto out_error;
  }
  {
#line 218
  buf[rd] = (char )'\000';
#line 220
  tmp___4 = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%llx\n",
                   value);
  }
#line 220
  if (tmp___4 != 1) {
    {
#line 221
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: cannot read integer from \"%s\"\n\n",
            "libmtd", file);
#line 222
    tmp___3 = __errno_location();
#line 222
    *tmp___3 = 22;
    }
#line 223
    goto out_error;
  }
#line 226
  if (*value < 0LL) {
    {
#line 227
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: negative value %lld in \"%s\"\n",
            "libmtd", *value, file);
#line 228
    tmp___5 = __errno_location();
#line 228
    *tmp___5 = 22;
    }
#line 229
    goto out_error;
  }
  {
#line 232
  tmp___8 = close(fd);
  }
#line 232
  if (tmp___8) {
    {
#line 233
    tmp___6 = __errno_location();
#line 233
    _err___0 = *tmp___6;
#line 233
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: close failed on \"%s\"\n",
            "libmtd", file);
#line 233
    tmp___7 = strerror(_err___0);
#line 233
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err___0, tmp___7);
    }
#line 233
    return (-1);
  }
#line 235
  return (0);
  out_error: 
  {
#line 238
  close(fd);
  }
#line 239
  return (-1);
}
}
#line 251 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int read_pos_ll___2(char const   *file , long long *value ) 
{ 
  int fd ;
  int rd ;
  char buf[50] ;
  ssize_t tmp ;
  int _err ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int _err___0 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;

  {
  {
#line 256
  fd = open(file, 524288);
  }
#line 257
  if (fd == -1) {
#line 258
    return (-1);
  }
  {
#line 260
  tmp = read(fd, (void *)(buf), (size_t )50);
#line 260
  rd = (int )tmp;
  }
#line 261
  if (rd == -1) {
    {
#line 262
    tmp___0 = __errno_location();
#line 262
    _err = *tmp___0;
#line 262
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: cannot read \"%s\"\n",
            "libmtd", file);
#line 262
    tmp___1 = strerror(_err);
#line 262
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err, tmp___1);
    }
#line 263
    goto out_error;
  }
#line 265
  if (rd == 50) {
    {
#line 266
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: contents of \"%s\" is too long\n",
            "libmtd", file);
#line 267
    tmp___2 = __errno_location();
#line 267
    *tmp___2 = 22;
    }
#line 268
    goto out_error;
  }
  {
#line 271
  tmp___4 = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%lld\n",
                   value);
  }
#line 271
  if (tmp___4 != 1) {
    {
#line 272
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: cannot read integer from \"%s\"\n\n",
            "libmtd", file);
#line 273
    tmp___3 = __errno_location();
#line 273
    *tmp___3 = 22;
    }
#line 274
    goto out_error;
  }
#line 277
  if (*value < 0LL) {
    {
#line 278
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: negative value %lld in \"%s\"\n",
            "libmtd", *value, file);
#line 279
    tmp___5 = __errno_location();
#line 279
    *tmp___5 = 22;
    }
#line 280
    goto out_error;
  }
  {
#line 283
  tmp___8 = close(fd);
  }
#line 283
  if (tmp___8) {
    {
#line 284
    tmp___6 = __errno_location();
#line 284
    _err___0 = *tmp___6;
#line 284
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: close failed on \"%s\"\n",
            "libmtd", file);
#line 284
    tmp___7 = strerror(_err___0);
#line 284
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err___0, tmp___7);
    }
#line 284
    return (-1);
  }
#line 286
  return (0);
  out_error: 
  {
#line 289
  close(fd);
  }
#line 290
  return (-1);
}
}
#line 301 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int read_hex_int___2(char const   *file , int *value ) 
{ 
  long long res ;
  int tmp ;
  int *tmp___0 ;

  {
  {
#line 305
  tmp = read_hex_ll___2(file, & res);
  }
#line 305
  if (tmp) {
#line 306
    return (-1);
  }
#line 309
  if (res > 2147483647LL) {
    {
#line 310
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: value %lld read from file \"%s\" is out of range\n",
            "libmtd", res, file);
#line 312
    tmp___0 = __errno_location();
#line 312
    *tmp___0 = 22;
    }
#line 313
    return (-1);
  } else
#line 309
  if (res < (-0x7FFFFFFF-1)) {
    {
#line 310
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: value %lld read from file \"%s\" is out of range\n",
            "libmtd", res, file);
#line 312
    tmp___0 = __errno_location();
#line 312
    *tmp___0 = 22;
    }
#line 313
    return (-1);
  }
#line 316
  *value = (int )res;
#line 317
  return (0);
}
}
#line 328 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int read_pos_int___2(char const   *file , int *value ) 
{ 
  long long res ;
  int tmp ;
  int *tmp___0 ;

  {
  {
#line 332
  tmp = read_pos_ll___2(file, & res);
  }
#line 332
  if (tmp) {
#line 333
    return (-1);
  }
#line 336
  if (res > 2147483647LL) {
    {
#line 337
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: value %lld read from file \"%s\" is out of range\n",
            "libmtd", res, file);
#line 339
    tmp___0 = __errno_location();
#line 339
    *tmp___0 = 22;
    }
#line 340
    return (-1);
  }
#line 343
  *value = (int )res;
#line 344
  return (0);
}
}
#line 355 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int dev_read_hex_int___2(char const   *patt , int mtd_num , int *value ) 
{ 
  size_t tmp ;
  char *file ;
  unsigned long __lengthoffile ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 357
  tmp = strlen(patt);
#line 357
  __lengthoffile = tmp + 50UL;
#line 357
  tmp___0 = __builtin_alloca(sizeof(*file) * __lengthoffile);
#line 357
  file = (char *)tmp___0;
#line 359
  sprintf((char */* __restrict  */)file, (char const   */* __restrict  */)patt, mtd_num);
#line 360
  tmp___1 = read_hex_int___2((char const   *)file, value);
  }
#line 360
  return (tmp___1);
}
}
#line 371 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int dev_read_pos_int___2(char const   *patt , int mtd_num , int *value ) 
{ 
  size_t tmp ;
  char *file ;
  unsigned long __lengthoffile ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 373
  tmp = strlen(patt);
#line 373
  __lengthoffile = tmp + 50UL;
#line 373
  tmp___0 = __builtin_alloca(sizeof(*file) * __lengthoffile);
#line 373
  file = (char *)tmp___0;
#line 375
  sprintf((char */* __restrict  */)file, (char const   */* __restrict  */)patt, mtd_num);
#line 376
  tmp___1 = read_pos_int___2((char const   *)file, value);
  }
#line 376
  return (tmp___1);
}
}
#line 387 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int dev_read_pos_ll___2(char const   *patt , int mtd_num , long long *value ) 
{ 
  size_t tmp ;
  char *file ;
  unsigned long __lengthoffile ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 389
  tmp = strlen(patt);
#line 389
  __lengthoffile = tmp + 50UL;
#line 389
  tmp___0 = __builtin_alloca(sizeof(*file) * __lengthoffile);
#line 389
  file = (char *)tmp___0;
#line 391
  sprintf((char */* __restrict  */)file, (char const   */* __restrict  */)patt, mtd_num);
#line 392
  tmp___1 = read_pos_ll___2((char const   *)file, value);
  }
#line 392
  return (tmp___1);
}
}
#line 402 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int type_str2int___2(char const   *str ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 404
  tmp = strcmp(str, "nand");
  }
#line 404
  if (! tmp) {
#line 405
    return (4);
  }
  {
#line 406
  tmp___0 = strcmp(str, "nor");
  }
#line 406
  if (! tmp___0) {
#line 407
    return (3);
  }
  {
#line 408
  tmp___1 = strcmp(str, "rom");
  }
#line 408
  if (! tmp___1) {
#line 409
    return (2);
  }
  {
#line 410
  tmp___2 = strcmp(str, "absent");
  }
#line 410
  if (! tmp___2) {
#line 411
    return (0);
  }
  {
#line 412
  tmp___3 = strcmp(str, "dataflash");
  }
#line 412
  if (! tmp___3) {
#line 413
    return (6);
  }
  {
#line 414
  tmp___4 = strcmp(str, "ram");
  }
#line 414
  if (! tmp___4) {
#line 415
    return (1);
  }
  {
#line 416
  tmp___5 = strcmp(str, "ubi");
  }
#line 416
  if (! tmp___5) {
#line 417
    return (7);
  }
#line 418
  return (-1);
}
}
#line 429 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int dev_node2num___2(struct libmtd *lib , char const   *node , int *mtd_num ) 
{ 
  struct stat st ;
  int i ;
  int mjr ;
  int mnr ;
  struct mtd_info info ;
  int _err ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  int tmp___5 ;
  int mjr1 ;
  int mnr1 ;
  int ret ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;

  {
  {
#line 435
  tmp___1 = stat((char const   */* __restrict  */)node, (struct stat */* __restrict  */)(& st));
  }
#line 435
  if (tmp___1) {
    {
#line 436
    tmp = __errno_location();
#line 436
    _err = *tmp;
#line 436
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: cannot get information about \"%s\"\n",
            "libmtd", node);
#line 436
    tmp___0 = strerror(_err);
#line 436
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err, tmp___0);
    }
#line 436
    return (-1);
  }
#line 438
  if (! ((st.st_mode & 61440U) == 8192U)) {
    {
#line 439
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: \"%s\" is not a character device\n",
            "libmtd", node);
#line 440
    tmp___2 = __errno_location();
#line 440
    *tmp___2 = 22;
    }
#line 441
    return (-1);
  }
  {
#line 444
  tmp___3 = gnu_dev_major((unsigned long long )st.st_rdev);
#line 444
  mjr = (int )tmp___3;
#line 445
  tmp___4 = gnu_dev_minor((unsigned long long )st.st_rdev);
#line 445
  mnr = (int )tmp___4;
#line 447
  tmp___5 = mtd_get_info((libmtd_t )((libmtd_t *)lib), & info);
  }
#line 447
  if (tmp___5) {
#line 448
    return (-1);
  }
#line 450
  i = info.lowest_mtd_num;
  {
#line 450
  while (1) {
    while_continue: /* CIL Label */ ;
#line 450
    if (! (i <= info.highest_mtd_num)) {
#line 450
      goto while_break;
    }
    {
#line 453
    ret = dev_get_major___2(lib, i, & mjr1, & mnr1);
    }
#line 454
    if (ret) {
      {
#line 455
      tmp___6 = __errno_location();
      }
#line 455
      if (*tmp___6 == 2) {
#line 456
        goto __Cont;
      }
      {
#line 457
      tmp___7 = __errno_location();
      }
#line 457
      if (! *tmp___7) {
#line 458
        goto while_break;
      }
#line 459
      return (-1);
    }
#line 462
    if (mjr1 == mjr) {
#line 462
      if (mnr1 == mnr) {
        {
#line 463
        tmp___8 = __errno_location();
#line 463
        *tmp___8 = 0;
#line 464
        *mtd_num = i;
        }
#line 465
        return (0);
      }
    }
    __Cont: /* CIL Label */ 
#line 450
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 469
  tmp___9 = __errno_location();
#line 469
  *tmp___9 = 19;
  }
#line 470
  return (-1);
}
}
#line 489 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int sysfs_is_supported___2(struct libmtd *lib ) 
{ 
  int fd ;
  int num ;
  DIR *sysfs_mtd ;
  size_t tmp ;
  char *file ;
  unsigned long __lengthoffile ;
  void *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int _err ;
  int *tmp___3 ;
  char *tmp___4 ;
  int ret ;
  int mtd_num ;
  char tmp_buf[256] ;
  struct dirent *dirent ;
  int *tmp___5 ;
  size_t tmp___6 ;
  int _err___0 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int _err___1 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;

  {
  {
#line 491
  num = -1;
#line 493
  tmp = strlen((char const   *)lib->mtd_name);
#line 493
  __lengthoffile = tmp + 10UL;
#line 493
  tmp___0 = __builtin_alloca(sizeof(*file) * __lengthoffile);
#line 493
  file = (char *)tmp___0;
#line 495
  sysfs_mtd = opendir((char const   *)lib->sysfs_mtd);
  }
#line 496
  if (! sysfs_mtd) {
    {
#line 497
    tmp___2 = __errno_location();
    }
#line 497
    if (*tmp___2 == 2) {
      {
#line 498
      tmp___1 = __errno_location();
#line 498
      *tmp___1 = 0;
      }
#line 499
      return (0);
    }
    {
#line 501
    tmp___3 = __errno_location();
#line 501
    _err = *tmp___3;
#line 501
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: cannot open \"%s\"\n",
            "libmtd", lib->sysfs_mtd);
#line 501
    tmp___4 = strerror(_err);
#line 501
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err, tmp___4);
    }
#line 501
    return (-1);
  }
  {
#line 508
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 513
    dirent = readdir(sysfs_mtd);
    }
#line 514
    if (! dirent) {
#line 515
      goto while_break;
    }
    {
#line 517
    tmp___6 = strlen((char const   *)(dirent->d_name));
    }
#line 517
    if (tmp___6 >= 255UL) {
      {
#line 518
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: invalid entry in %s: \"%s\"\n",
              "libmtd", lib->sysfs_mtd, dirent->d_name);
#line 520
      tmp___5 = __errno_location();
#line 520
      *tmp___5 = 22;
#line 521
      closedir(sysfs_mtd);
      }
#line 522
      return (-1);
    }
    {
#line 525
    ret = sscanf((char const   */* __restrict  */)(dirent->d_name), (char const   */* __restrict  */)"mtd%d%s",
                 & mtd_num, tmp_buf);
    }
#line 527
    if (ret == 1) {
#line 528
      num = mtd_num;
#line 529
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 533
  tmp___9 = closedir(sysfs_mtd);
  }
#line 533
  if (tmp___9) {
    {
#line 534
    tmp___7 = __errno_location();
#line 534
    _err___0 = *tmp___7;
#line 534
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: closedir failed on \"%s\"\n",
            "libmtd", lib->sysfs_mtd);
#line 534
    tmp___8 = strerror(_err___0);
#line 534
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err___0, tmp___8);
    }
#line 534
    return (-1);
  }
#line 536
  if (num == -1) {
#line 538
    return (0);
  }
  {
#line 540
  sprintf((char */* __restrict  */)file, (char const   */* __restrict  */)lib->mtd_name,
          num);
#line 541
  fd = open((char const   *)file, 524288);
  }
#line 542
  if (fd == -1) {
#line 543
    return (0);
  }
  {
#line 545
  tmp___12 = close(fd);
  }
#line 545
  if (tmp___12) {
    {
#line 546
    tmp___10 = __errno_location();
#line 546
    _err___1 = *tmp___10;
#line 546
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: close failed on \"%s\"\n",
            "libmtd", file);
#line 546
    tmp___11 = strerror(_err___1);
#line 546
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err___1, tmp___11);
    }
#line 547
    return (-1);
  }
#line 550
  return (1);
}
}
#line 803 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int mtd_valid_erase_block___2(struct mtd_dev_info  const  *mtd , int eb ) 
{ 
  int *tmp ;

  {
#line 805
  if (eb < 0) {
    {
#line 806
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: bad eraseblock number %d, mtd%d has %d eraseblocks\n",
            "libmtd", eb, mtd->mtd_num, mtd->eb_cnt);
#line 808
    tmp = __errno_location();
#line 808
    *tmp = 22;
    }
#line 809
    return (-1);
  } else
#line 805
  if (eb >= (int )mtd->eb_cnt) {
    {
#line 806
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: bad eraseblock number %d, mtd%d has %d eraseblocks\n",
            "libmtd", eb, mtd->mtd_num, mtd->eb_cnt);
#line 808
    tmp = __errno_location();
#line 808
    *tmp = 22;
    }
#line 809
    return (-1);
  }
#line 811
  return (0);
}
}
#line 814 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int mtd_xlock___2(struct mtd_dev_info  const  *mtd , int fd , int eb , int req ,
                         char const   *sreq ) 
{ 
  int ret ;
  struct erase_info_user ei ;
  int tmp ;

  {
  {
#line 820
  ret = mtd_valid_erase_block___2(mtd, eb);
  }
#line 821
  if (ret) {
#line 822
    return (ret);
  }
  {
#line 824
  ei.start = (__u32 )(eb * (int )mtd->eb_size);
#line 825
  ei.length = (__u32 )mtd->eb_size;
#line 827
  ret = ioctl(fd, (unsigned long )req, & ei);
  }
#line 828
  if (ret < 0) {
    {
#line 829
    tmp = mtd_ioctl_error(mtd, eb, sreq);
    }
#line 829
    return (tmp);
  }
#line 831
  return (0);
}
}
#line 929 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static uint8_t patterns___2[3]  = {      (uint8_t )165,      (uint8_t )90,      (uint8_t )0};
#line 940 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int check_pattern___2(void const   *buf , uint8_t patt , int size ) 
{ 
  int i ;

  {
#line 944
  i = 0;
  {
#line 944
  while (1) {
    while_continue: /* CIL Label */ ;
#line 944
    if (! (i < size)) {
#line 944
      goto while_break;
    }
#line 945
    if ((int const   )*((uint8_t const   *)buf + i) != (int const   )patt) {
#line 946
      return (0);
    }
#line 944
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 947
  return (1);
}
}
#line 1080 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int legacy_auto_oob_layout___2(struct mtd_dev_info  const  *mtd , int fd ,
                                      int ooblen , void *oob ) 
{ 
  struct nand_oobinfo old_oobinfo ;
  int start ;
  int len ;
  uint8_t *tmp_buf ;
  int _err ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int i ;
  int tags_pos ;

  {
  {
#line 1087
  tmp___1 = ioctl(fd, (unsigned long )(((2U << 30) | (unsigned int )(77 << 8)) | 10U) | (sizeof(struct nand_oobinfo ) << 16),
                  & old_oobinfo);
  }
#line 1087
  if (tmp___1) {
    {
#line 1088
    tmp = __errno_location();
#line 1088
    _err = *tmp;
#line 1088
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: MEMGETOOBSEL failed\n",
            "libmtd");
#line 1088
    tmp___0 = strerror(_err);
#line 1088
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err, tmp___0);
    }
#line 1088
    return (-1);
  }
  {
#line 1090
  tmp___2 = malloc((size_t )ooblen);
#line 1090
  tmp_buf = (uint8_t *)tmp___2;
#line 1091
  memcpy((void */* __restrict  */)tmp_buf, (void const   */* __restrict  */)oob, (size_t )ooblen);
  }
#line 1097
  if (old_oobinfo.useecc == 2U) {
#line 1098
    tags_pos = 0;
#line 1099
    i = 0;
    {
#line 1099
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1099
      if (! old_oobinfo.oobfree[i][1]) {
#line 1099
        goto while_break;
      }
      {
#line 1101
      start = (int )old_oobinfo.oobfree[i][0];
#line 1102
      len = (int )old_oobinfo.oobfree[i][1];
#line 1103
      memcpy((void */* __restrict  */)(oob + start), (void const   */* __restrict  */)(tmp_buf + tags_pos),
             (size_t )len);
#line 1104
      tags_pos += len;
#line 1099
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1108
    start = (int )old_oobinfo.eccbytes;
#line 1109
    len = (int )(mtd->oob_size - (int const   )start);
#line 1110
    memcpy((void */* __restrict  */)(oob + start), (void const   */* __restrict  */)(tmp_buf + start),
           (size_t )len);
    }
  }
#line 1113
  return (0);
}
}
#line 38 "./include/xalloc.h"
static void *xmalloc___7(size_t size )  __attribute__((__unused__)) ;
#line 38 "./include/xalloc.h"
static void *xmalloc___7(size_t size ) 
{ 
  void *ptr ;
  void *tmp ;
  int _err ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 41
  tmp = malloc(size);
#line 41
  ptr = tmp;
  }
#line 43
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 43
    if (size != 0UL) {
      {
#line 44
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 44
        tmp___0 = __errno_location();
#line 44
        _err = *tmp___0;
#line 44
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: out of memory\n",
                "libmtd");
#line 44
        tmp___1 = strerror(_err);
#line 44
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
                (int )sizeof("libmtd") + 1, "", _err, tmp___1);
#line 44
        exit(-1);
        }
#line 44
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 45
  return (ptr);
}
}
#line 70 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd_legacy.c"
static int proc_parse_start___2(struct proc_parse_info *pi ) 
{ 
  int fd ;
  int ret ;
  void *tmp ;
  ssize_t tmp___0 ;
  int _err ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 74
  fd = open("/proc/mtd", 0);
  }
#line 75
  if (fd == -1) {
#line 76
    return (-1);
  }
  {
#line 78
  tmp = xmalloc___7((size_t )4096);
#line 78
  pi->buf = (char *)tmp;
#line 80
  tmp___0 = read(fd, (void *)pi->buf, (size_t )4096);
#line 80
  ret = (int )tmp___0;
  }
#line 81
  if (ret == -1) {
    {
#line 82
    tmp___1 = __errno_location();
#line 82
    _err = *tmp___1;
#line 82
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: cannot read \"%s\"\n",
            "libmtd", "/proc/mtd");
#line 82
    tmp___2 = strerror(_err);
#line 82
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err, tmp___2);
    }
#line 83
    goto out_free;
  }
#line 86
  if ((unsigned long )ret < sizeof("dev:    size   erasesize  name\n") - 1UL) {
    {
#line 88
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: \"%s\" does not start with \"%s\"\n",
            "libmtd", "/proc/mtd", "dev:    size   erasesize  name\n");
    }
#line 90
    goto out_free;
  } else {
    {
#line 86
    tmp___3 = memcmp((void const   *)pi->buf, (void const   *)"dev:    size   erasesize  name\n",
                     sizeof("dev:    size   erasesize  name\n") - 1UL);
    }
#line 86
    if (tmp___3) {
      {
#line 88
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: \"%s\" does not start with \"%s\"\n",
              "libmtd", "/proc/mtd", "dev:    size   erasesize  name\n");
      }
#line 90
      goto out_free;
    }
  }
  {
#line 93
  pi->data_size = ret;
#line 94
  pi->next = pi->buf + (sizeof("dev:    size   erasesize  name\n") - 1UL);
#line 96
  close(fd);
  }
#line 97
  return (0);
  out_free: 
  {
#line 100
  free((void *)pi->buf);
#line 101
  close(fd);
  }
#line 102
  return (-1);
}
}
#line 105 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd_legacy.c"
static int proc_parse_next___2(struct proc_parse_info *pi ) 
{ 
  int ret ;
  int len ;
  int pos ;
  char *p ;
  char *p1 ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 107
  pos = (int )(pi->next - pi->buf);
#line 110
  if (pos >= pi->data_size) {
    {
#line 111
    free((void *)pi->buf);
    }
#line 112
    return (0);
  }
  {
#line 115
  ret = sscanf((char const   */* __restrict  */)pi->next, (char const   */* __restrict  */)"mtd%d: %llx %x",
               & pi->mtd_num, & pi->size, & pi->eb_size);
  }
#line 117
  if (ret != 3) {
    {
#line 118
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: \"%s\" pattern not found\n",
            "libmtd", "mtd%d: %llx %x");
    }
#line 118
    return (-1);
  }
  {
#line 120
  tmp = memchr((void const   *)pi->next, '\"', (size_t )(pi->data_size - pos));
#line 120
  p = (char *)tmp;
  }
#line 121
  if (! p) {
    {
#line 122
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: opening \" not found\n",
            "libmtd");
    }
#line 122
    return (-1);
  }
#line 123
  p ++;
#line 124
  pos = (int )(p - pi->buf);
#line 125
  if (pos >= pi->data_size) {
    {
#line 126
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: opening \" not found\n",
            "libmtd");
    }
#line 126
    return (-1);
  }
  {
#line 128
  tmp___0 = memchr((void const   *)p, '\"', (size_t )(pi->data_size - pos));
#line 128
  p1 = (char *)tmp___0;
  }
#line 129
  if (! p1) {
    {
#line 130
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: closing \" not found\n",
            "libmtd");
    }
#line 130
    return (-1);
  }
#line 131
  pos = (int )(p1 - pi->buf);
#line 132
  if (pos >= pi->data_size) {
    {
#line 133
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: closing \" not found\n",
            "libmtd");
    }
#line 133
    return (-1);
  }
#line 135
  len = (int )(p1 - p);
#line 136
  if (len > 127) {
    {
#line 137
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: too long mtd%d device name\n",
            "libmtd", pi->mtd_num);
    }
#line 137
    return (-1);
  }
  {
#line 139
  memcpy((void */* __restrict  */)(pi->name), (void const   */* __restrict  */)p,
         (size_t )len);
#line 140
  pi->name[len] = (char )'\000';
  }
#line 142
  if ((int )*(p1 + 1) != 10) {
    {
#line 143
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: opening \"\n\" not found\n",
            "libmtd");
    }
#line 143
    return (-1);
  }
#line 144
  pi->next = p1 + 2;
#line 145
  return (1);
}
}
#line 42 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libcrc32.c"
static uint32_t const   crc32_table___2[256]  = 
#line 42 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libcrc32.c"
  {      (uint32_t const   )0L,      (uint32_t const   )1996959894L,      (uint32_t const   )3993919788L,      (uint32_t const   )2567524794L, 
        (uint32_t const   )124634137L,      (uint32_t const   )1886057615L,      (uint32_t const   )3915621685L,      (uint32_t const   )2657392035L, 
        (uint32_t const   )249268274L,      (uint32_t const   )2044508324L,      (uint32_t const   )3772115230L,      (uint32_t const   )2547177864L, 
        (uint32_t const   )162941995L,      (uint32_t const   )2125561021L,      (uint32_t const   )3887607047L,      (uint32_t const   )2428444049L, 
        (uint32_t const   )498536548L,      (uint32_t const   )1789927666L,      (uint32_t const   )4089016648L,      (uint32_t const   )2227061214L, 
        (uint32_t const   )450548861L,      (uint32_t const   )1843258603L,      (uint32_t const   )4107580753L,      (uint32_t const   )2211677639L, 
        (uint32_t const   )325883990L,      (uint32_t const   )1684777152L,      (uint32_t const   )4251122042L,      (uint32_t const   )2321926636L, 
        (uint32_t const   )335633487L,      (uint32_t const   )1661365465L,      (uint32_t const   )4195302755L,      (uint32_t const   )2366115317L, 
        (uint32_t const   )997073096L,      (uint32_t const   )1281953886L,      (uint32_t const   )3579855332L,      (uint32_t const   )2724688242L, 
        (uint32_t const   )1006888145L,      (uint32_t const   )1258607687L,      (uint32_t const   )3524101629L,      (uint32_t const   )2768942443L, 
        (uint32_t const   )901097722L,      (uint32_t const   )1119000684L,      (uint32_t const   )3686517206L,      (uint32_t const   )2898065728L, 
        (uint32_t const   )853044451L,      (uint32_t const   )1172266101L,      (uint32_t const   )3705015759L,      (uint32_t const   )2882616665L, 
        (uint32_t const   )651767980L,      (uint32_t const   )1373503546L,      (uint32_t const   )3369554304L,      (uint32_t const   )3218104598L, 
        (uint32_t const   )565507253L,      (uint32_t const   )1454621731L,      (uint32_t const   )3485111705L,      (uint32_t const   )3099436303L, 
        (uint32_t const   )671266974L,      (uint32_t const   )1594198024L,      (uint32_t const   )3322730930L,      (uint32_t const   )2970347812L, 
        (uint32_t const   )795835527L,      (uint32_t const   )1483230225L,      (uint32_t const   )3244367275L,      (uint32_t const   )3060149565L, 
        (uint32_t const   )1994146192L,      (uint32_t const   )31158534L,      (uint32_t const   )2563907772L,      (uint32_t const   )4023717930L, 
        (uint32_t const   )1907459465L,      (uint32_t const   )112637215L,      (uint32_t const   )2680153253L,      (uint32_t const   )3904427059L, 
        (uint32_t const   )2013776290L,      (uint32_t const   )251722036L,      (uint32_t const   )2517215374L,      (uint32_t const   )3775830040L, 
        (uint32_t const   )2137656763L,      (uint32_t const   )141376813L,      (uint32_t const   )2439277719L,      (uint32_t const   )3865271297L, 
        (uint32_t const   )1802195444L,      (uint32_t const   )476864866L,      (uint32_t const   )2238001368L,      (uint32_t const   )4066508878L, 
        (uint32_t const   )1812370925L,      (uint32_t const   )453092731L,      (uint32_t const   )2181625025L,      (uint32_t const   )4111451223L, 
        (uint32_t const   )1706088902L,      (uint32_t const   )314042704L,      (uint32_t const   )2344532202L,      (uint32_t const   )4240017532L, 
        (uint32_t const   )1658658271L,      (uint32_t const   )366619977L,      (uint32_t const   )2362670323L,      (uint32_t const   )4224994405L, 
        (uint32_t const   )1303535960L,      (uint32_t const   )984961486L,      (uint32_t const   )2747007092L,      (uint32_t const   )3569037538L, 
        (uint32_t const   )1256170817L,      (uint32_t const   )1037604311L,      (uint32_t const   )2765210733L,      (uint32_t const   )3554079995L, 
        (uint32_t const   )1131014506L,      (uint32_t const   )879679996L,      (uint32_t const   )2909243462L,      (uint32_t const   )3663771856L, 
        (uint32_t const   )1141124467L,      (uint32_t const   )855842277L,      (uint32_t const   )2852801631L,      (uint32_t const   )3708648649L, 
        (uint32_t const   )1342533948L,      (uint32_t const   )654459306L,      (uint32_t const   )3188396048L,      (uint32_t const   )3373015174L, 
        (uint32_t const   )1466479909L,      (uint32_t const   )544179635L,      (uint32_t const   )3110523913L,      (uint32_t const   )3462522015L, 
        (uint32_t const   )1591671054L,      (uint32_t const   )702138776L,      (uint32_t const   )2966460450L,      (uint32_t const   )3352799412L, 
        (uint32_t const   )1504918807L,      (uint32_t const   )783551873L,      (uint32_t const   )3082640443L,      (uint32_t const   )3233442989L, 
        (uint32_t const   )3988292384L,      (uint32_t const   )2596254646L,      (uint32_t const   )62317068L,      (uint32_t const   )1957810842L, 
        (uint32_t const   )3939845945L,      (uint32_t const   )2647816111L,      (uint32_t const   )81470997L,      (uint32_t const   )1943803523L, 
        (uint32_t const   )3814918930L,      (uint32_t const   )2489596804L,      (uint32_t const   )225274430L,      (uint32_t const   )2053790376L, 
        (uint32_t const   )3826175755L,      (uint32_t const   )2466906013L,      (uint32_t const   )167816743L,      (uint32_t const   )2097651377L, 
        (uint32_t const   )4027552580L,      (uint32_t const   )2265490386L,      (uint32_t const   )503444072L,      (uint32_t const   )1762050814L, 
        (uint32_t const   )4150417245L,      (uint32_t const   )2154129355L,      (uint32_t const   )426522225L,      (uint32_t const   )1852507879L, 
        (uint32_t const   )4275313526L,      (uint32_t const   )2312317920L,      (uint32_t const   )282753626L,      (uint32_t const   )1742555852L, 
        (uint32_t const   )4189708143L,      (uint32_t const   )2394877945L,      (uint32_t const   )397917763L,      (uint32_t const   )1622183637L, 
        (uint32_t const   )3604390888L,      (uint32_t const   )2714866558L,      (uint32_t const   )953729732L,      (uint32_t const   )1340076626L, 
        (uint32_t const   )3518719985L,      (uint32_t const   )2797360999L,      (uint32_t const   )1068828381L,      (uint32_t const   )1219638859L, 
        (uint32_t const   )3624741850L,      (uint32_t const   )2936675148L,      (uint32_t const   )906185462L,      (uint32_t const   )1090812512L, 
        (uint32_t const   )3747672003L,      (uint32_t const   )2825379669L,      (uint32_t const   )829329135L,      (uint32_t const   )1181335161L, 
        (uint32_t const   )3412177804L,      (uint32_t const   )3160834842L,      (uint32_t const   )628085408L,      (uint32_t const   )1382605366L, 
        (uint32_t const   )3423369109L,      (uint32_t const   )3138078467L,      (uint32_t const   )570562233L,      (uint32_t const   )1426400815L, 
        (uint32_t const   )3317316542L,      (uint32_t const   )2998733608L,      (uint32_t const   )733239954L,      (uint32_t const   )1555261956L, 
        (uint32_t const   )3268935591L,      (uint32_t const   )3050360625L,      (uint32_t const   )752459403L,      (uint32_t const   )1541320221L, 
        (uint32_t const   )2607071920L,      (uint32_t const   )3965973030L,      (uint32_t const   )1969922972L,      (uint32_t const   )40735498L, 
        (uint32_t const   )2617837225L,      (uint32_t const   )3943577151L,      (uint32_t const   )1913087877L,      (uint32_t const   )83908371L, 
        (uint32_t const   )2512341634L,      (uint32_t const   )3803740692L,      (uint32_t const   )2075208622L,      (uint32_t const   )213261112L, 
        (uint32_t const   )2463272603L,      (uint32_t const   )3855990285L,      (uint32_t const   )2094854071L,      (uint32_t const   )198958881L, 
        (uint32_t const   )2262029012L,      (uint32_t const   )4057260610L,      (uint32_t const   )1759359992L,      (uint32_t const   )534414190L, 
        (uint32_t const   )2176718541L,      (uint32_t const   )4139329115L,      (uint32_t const   )1873836001L,      (uint32_t const   )414664567L, 
        (uint32_t const   )2282248934L,      (uint32_t const   )4279200368L,      (uint32_t const   )1711684554L,      (uint32_t const   )285281116L, 
        (uint32_t const   )2405801727L,      (uint32_t const   )4167216745L,      (uint32_t const   )1634467795L,      (uint32_t const   )376229701L, 
        (uint32_t const   )2685067896L,      (uint32_t const   )3608007406L,      (uint32_t const   )1308918612L,      (uint32_t const   )956543938L, 
        (uint32_t const   )2808555105L,      (uint32_t const   )3495958263L,      (uint32_t const   )1231636301L,      (uint32_t const   )1047427035L, 
        (uint32_t const   )2932959818L,      (uint32_t const   )3654703836L,      (uint32_t const   )1088359270L,      (uint32_t const   )936918000L, 
        (uint32_t const   )2847714899L,      (uint32_t const   )3736837829L,      (uint32_t const   )1202900863L,      (uint32_t const   )817233897L, 
        (uint32_t const   )3183342108L,      (uint32_t const   )3401237130L,      (uint32_t const   )1404277552L,      (uint32_t const   )615818150L, 
        (uint32_t const   )3134207493L,      (uint32_t const   )3453421203L,      (uint32_t const   )1423857449L,      (uint32_t const   )601450431L, 
        (uint32_t const   )3009837614L,      (uint32_t const   )3294710456L,      (uint32_t const   )1567103746L,      (uint32_t const   )711928724L, 
        (uint32_t const   )3020668471L,      (uint32_t const   )3272380065L,      (uint32_t const   )1510334235L,      (uint32_t const   )755167117L};
#line 117 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static char const   *allPp___3[17]  = 
#line 117 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
  {      (char const   *)((void *)0),      (char const   *)((void *)0),      "111",      "1101", 
        "11001",      "101001",      "1100001",      "10010001", 
        "101110001",      "1000100001",      "10010000001",      "101000000001", 
        "1100101000001",      "11011000000001",      "110000100010001",      "1100000000000001", 
        "11010000000010001"};
#line 147 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static gf gf_exp___3[2 * ((1 << 8) - 1)]  ;
#line 148 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static int gf_log___3[((1 << 8) - 1) + 1]  ;
#line 149 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static gf inverse___3[((1 << 8) - 1) + 1]  ;
#line 179 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static gf gf_mul_table___3[((1 << 8) - 1) + 1][((1 << 8) - 1) + 1]  ;
#line 187 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static void init_mul_table___3(void) 
{ 
  int i ;
  int j ;
  gf tmp ;
  gf tmp___0 ;

  {
#line 191
  i = 0;
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 191
    if (! (i < ((1 << 8) - 1) + 1)) {
#line 191
      goto while_break;
    }
#line 192
    j = 0;
    {
#line 192
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 192
      if (! (j < ((1 << 8) - 1) + 1)) {
#line 192
        goto while_break___0;
      }
      {
#line 193
      tmp = modnn(gf_log___3[i] + gf_log___3[j]);
#line 193
      gf_mul_table___3[i][j] = gf_exp___3[tmp];
#line 192
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 191
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 195
  j = 0;
  {
#line 195
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 195
    if (! (j < ((1 << 8) - 1) + 1)) {
#line 195
      goto while_break___1;
    }
#line 196
    tmp___0 = (gf )0;
#line 196
    gf_mul_table___3[j][0] = tmp___0;
#line 196
    gf_mul_table___3[0][j] = tmp___0;
#line 195
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 197
  return;
}
}
#line 228 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static void *my_malloc___3(int sz , char const   *err_string ) 
{ 
  void *p ;
  void *tmp ;

  {
  {
#line 231
  tmp = malloc((size_t )sz);
#line 231
  p = tmp;
  }
#line 232
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 233
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"-- malloc failure allocating %s\n",
            err_string);
#line 234
    exit(1);
    }
  }
#line 236
  return (p);
}
}
#line 245 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static void generate_gf___3(void) 
{ 
  int i ;
  gf mask ;
  char const   *Pp ;

  {
#line 250
  Pp = allPp___3[8];
#line 252
  mask = (gf )1;
#line 253
  gf_exp___3[8] = (gf )0;
#line 260
  i = 0;
  {
#line 260
  while (1) {
    while_continue: /* CIL Label */ ;
#line 260
    if (! (i < 8)) {
#line 260
      goto while_break;
    }
#line 261
    gf_exp___3[i] = mask;
#line 262
    gf_log___3[gf_exp___3[i]] = i;
#line 267
    if ((int const   )*(Pp + i) == 49) {
#line 268
      gf_exp___3[8] = (gf )((int )gf_exp___3[8] ^ (int )mask);
    }
#line 260
    i ++;
#line 260
    mask = (gf )((int )mask << 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 274
  gf_log___3[gf_exp___3[8]] = 8;
#line 281
  mask = (gf )(1 << 7);
#line 282
  i = 9;
  {
#line 282
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 282
    if (! (i < (1 << 8) - 1)) {
#line 282
      goto while_break___0;
    }
#line 283
    if ((int )gf_exp___3[i - 1] >= (int )mask) {
#line 284
      gf_exp___3[i] = (gf )((int )gf_exp___3[8] ^ (((int )gf_exp___3[i - 1] ^ (int )mask) << 1));
    } else {
#line 286
      gf_exp___3[i] = (gf )((int )gf_exp___3[i - 1] << 1);
    }
#line 287
    gf_log___3[gf_exp___3[i]] = i;
#line 282
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 292
  gf_log___3[0] = (1 << 8) - 1;
#line 294
  i = 0;
  {
#line 294
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 294
    if (! (i < (1 << 8) - 1)) {
#line 294
      goto while_break___1;
    }
#line 295
    gf_exp___3[i + ((1 << 8) - 1)] = gf_exp___3[i];
#line 294
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 302
  inverse___3[0] = (gf )0;
#line 303
  inverse___3[1] = (gf )1;
#line 304
  i = 2;
  {
#line 304
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 304
    if (! (i <= (1 << 8) - 1)) {
#line 304
      goto while_break___2;
    }
#line 305
    inverse___3[i] = gf_exp___3[((1 << 8) - 1) - gf_log___3[i]];
#line 304
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 306
  return;
}
}
#line 325 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static void addmul1___3(gf *dst1 , gf *src1 , gf c , int sz ) 
{ 
  register gf *__gf_mulc_ ;
  register gf *dst ;
  register gf *src ;
  gf *lim ;

  {
#line 329
  dst = dst1;
#line 329
  src = src1;
#line 330
  lim = dst + ((sz - 16) + 1);
#line 332
  __gf_mulc_ = gf_mul_table___3[c];
  {
#line 335
  while (1) {
    while_continue: /* CIL Label */ ;
#line 335
    if (! ((unsigned long )dst < (unsigned long )lim)) {
#line 335
      goto while_break;
    }
#line 336
    *(dst + 0) = (gf )((int )*(dst + 0) ^ (int )*(__gf_mulc_ + *(src + 0)));
#line 337
    *(dst + 1) = (gf )((int )*(dst + 1) ^ (int )*(__gf_mulc_ + *(src + 1)));
#line 338
    *(dst + 2) = (gf )((int )*(dst + 2) ^ (int )*(__gf_mulc_ + *(src + 2)));
#line 339
    *(dst + 3) = (gf )((int )*(dst + 3) ^ (int )*(__gf_mulc_ + *(src + 3)));
#line 341
    *(dst + 4) = (gf )((int )*(dst + 4) ^ (int )*(__gf_mulc_ + *(src + 4)));
#line 342
    *(dst + 5) = (gf )((int )*(dst + 5) ^ (int )*(__gf_mulc_ + *(src + 5)));
#line 343
    *(dst + 6) = (gf )((int )*(dst + 6) ^ (int )*(__gf_mulc_ + *(src + 6)));
#line 344
    *(dst + 7) = (gf )((int )*(dst + 7) ^ (int )*(__gf_mulc_ + *(src + 7)));
#line 347
    *(dst + 8) = (gf )((int )*(dst + 8) ^ (int )*(__gf_mulc_ + *(src + 8)));
#line 348
    *(dst + 9) = (gf )((int )*(dst + 9) ^ (int )*(__gf_mulc_ + *(src + 9)));
#line 349
    *(dst + 10) = (gf )((int )*(dst + 10) ^ (int )*(__gf_mulc_ + *(src + 10)));
#line 350
    *(dst + 11) = (gf )((int )*(dst + 11) ^ (int )*(__gf_mulc_ + *(src + 11)));
#line 351
    *(dst + 12) = (gf )((int )*(dst + 12) ^ (int )*(__gf_mulc_ + *(src + 12)));
#line 352
    *(dst + 13) = (gf )((int )*(dst + 13) ^ (int )*(__gf_mulc_ + *(src + 13)));
#line 353
    *(dst + 14) = (gf )((int )*(dst + 14) ^ (int )*(__gf_mulc_ + *(src + 14)));
#line 354
    *(dst + 15) = (gf )((int )*(dst + 15) ^ (int )*(__gf_mulc_ + *(src + 15)));
#line 335
    dst += 16;
#line 335
    src += 16;
  }
  while_break: /* CIL Label */ ;
  }
#line 358
  lim += 15;
  {
#line 359
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 359
    if (! ((unsigned long )dst < (unsigned long )lim)) {
#line 359
      goto while_break___0;
    }
#line 360
    *dst = (gf )((int )*dst ^ (int )*(__gf_mulc_ + *src));
#line 359
    dst ++;
#line 359
    src ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 361
  return;
}
}
#line 366 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static void matmul___3(gf *a , gf *b , gf *c , int n , int k , int m ) 
{ 
  int row ;
  int col ;
  int i ;
  gf *pa ;
  gf *pb ;
  gf acc ;

  {
#line 371
  row = 0;
  {
#line 371
  while (1) {
    while_continue: /* CIL Label */ ;
#line 371
    if (! (row < n)) {
#line 371
      goto while_break;
    }
#line 372
    col = 0;
    {
#line 372
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 372
      if (! (col < m)) {
#line 372
        goto while_break___0;
      }
#line 373
      pa = a + row * k;
#line 374
      pb = b + col;
#line 375
      acc = (gf )0;
#line 376
      i = 0;
      {
#line 376
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 376
        if (! (i < k)) {
#line 376
          goto while_break___1;
        }
#line 377
        acc = (gf )((int )acc ^ (int )gf_mul_table___3[*pa][*pb]);
#line 376
        i ++;
#line 376
        pa ++;
#line 376
        pb += m;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 378
      *(c + (row * m + col)) = acc;
#line 372
      col ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 371
    row ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 381
  return;
}
}
#line 410 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static int invert_mat___3(gf *src , int k ) 
{ 
  gf c ;
  gf *p ;
  int irow ;
  int icol ;
  int row ;
  int col ;
  int i ;
  int ix ;
  int error ;
  int *indxc ;
  void *tmp ;
  int *indxr ;
  void *tmp___0 ;
  int *ipiv ;
  void *tmp___1 ;
  gf *id_row ;
  void *tmp___2 ;
  gf *temp_row ;
  void *tmp___3 ;
  gf *pivot_row ;
  gf tmp___4 ;
  int tmp___5 ;
  gf tmp___6 ;

  {
  {
#line 416
  error = 1;
#line 417
  tmp = my_malloc___3((int )((unsigned long )k * sizeof(int )), "indxc");
#line 417
  indxc = (int *)tmp;
#line 418
  tmp___0 = my_malloc___3((int )((unsigned long )k * sizeof(int )), "indxr");
#line 418
  indxr = (int *)tmp___0;
#line 419
  tmp___1 = my_malloc___3((int )((unsigned long )k * sizeof(int )), "ipiv");
#line 419
  ipiv = (int *)tmp___1;
#line 420
  tmp___2 = my_malloc___3((int )((unsigned long )k * sizeof(gf )), " ## __LINE__ ## ");
#line 420
  id_row = (gf *)tmp___2;
#line 421
  tmp___3 = my_malloc___3((int )((unsigned long )k * sizeof(gf )), " ## __LINE__ ## ");
#line 421
  temp_row = (gf *)tmp___3;
#line 423
  memset((void *)id_row, '\000', (unsigned long )k * sizeof(gf ));
#line 428
  i = 0;
  }
  {
#line 428
  while (1) {
    while_continue: /* CIL Label */ ;
#line 428
    if (! (i < k)) {
#line 428
      goto while_break;
    }
#line 429
    *(ipiv + i) = 0;
#line 428
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 431
  col = 0;
  {
#line 431
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 431
    if (! (col < k)) {
#line 431
      goto while_break___0;
    }
#line 437
    icol = -1;
#line 437
    irow = icol;
#line 438
    if (*(ipiv + col) != 1) {
#line 438
      if ((int )*(src + (col * k + col)) != 0) {
#line 439
        irow = col;
#line 440
        icol = col;
#line 441
        goto found_piv;
      }
    }
#line 443
    row = 0;
    {
#line 443
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 443
      if (! (row < k)) {
#line 443
        goto while_break___1;
      }
#line 444
      if (*(ipiv + row) != 1) {
#line 445
        ix = 0;
        {
#line 445
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 445
          if (! (ix < k)) {
#line 445
            goto while_break___2;
          }
#line 447
          if (*(ipiv + ix) == 0) {
#line 448
            if ((int )*(src + (row * k + ix)) != 0) {
#line 449
              irow = row;
#line 450
              icol = ix;
#line 451
              goto found_piv;
            }
          } else
#line 453
          if (*(ipiv + ix) > 1) {
            {
#line 454
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"singular matrix\n");
            }
#line 455
            goto fail;
          }
#line 445
          ix ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 443
      row ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 460
    if (icol == -1) {
      {
#line 461
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"XXX pivot not found!\n");
      }
#line 462
      goto fail;
    }
    found_piv: 
#line 465
    (*(ipiv + icol)) ++;
#line 471
    if (irow != icol) {
#line 472
      ix = 0;
      {
#line 472
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 472
        if (! (ix < k)) {
#line 472
          goto while_break___3;
        }
#line 473
        tmp___4 = *(src + (irow * k + ix));
#line 473
        *(src + (irow * k + ix)) = *(src + (icol * k + ix));
#line 473
        *(src + (icol * k + ix)) = tmp___4;
#line 472
        ix ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 476
    *(indxr + col) = irow;
#line 477
    *(indxc + col) = icol;
#line 478
    pivot_row = src + icol * k;
#line 479
    c = *(pivot_row + icol);
#line 480
    if ((int )c == 0) {
      {
#line 481
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"singular matrix 2\n");
      }
#line 482
      goto fail;
    }
#line 484
    if ((int )c != 1) {
#line 490
      c = inverse___3[c];
#line 491
      *(pivot_row + icol) = (gf )1;
#line 492
      ix = 0;
      {
#line 492
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 492
        if (! (ix < k)) {
#line 492
          goto while_break___4;
        }
#line 493
        *(pivot_row + ix) = gf_mul_table___3[c][*(pivot_row + ix)];
#line 492
        ix ++;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
    {
#line 502
    *(id_row + icol) = (gf )1;
#line 503
    tmp___5 = memcmp((void const   *)pivot_row, (void const   *)id_row, (unsigned long )k * sizeof(gf ));
    }
#line 503
    if (tmp___5 != 0) {
#line 504
      p = src;
#line 504
      ix = 0;
      {
#line 504
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 504
        if (! (ix < k)) {
#line 504
          goto while_break___5;
        }
#line 505
        if (ix != icol) {
#line 506
          c = *(p + icol);
#line 507
          *(p + icol) = (gf )0;
#line 508
          if ((int )c != 0) {
            {
#line 508
            addmul1___3(p, pivot_row, c, k);
            }
          }
        }
#line 504
        ix ++;
#line 504
        p += k;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
#line 512
    *(id_row + icol) = (gf )0;
#line 431
    col ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 514
  col = k - 1;
  {
#line 514
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 514
    if (! (col >= 0)) {
#line 514
      goto while_break___6;
    }
#line 515
    if (*(indxr + col) < 0) {
      {
#line 516
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"AARGH, indxr[col] %d\n",
              *(indxr + col));
      }
    } else
#line 515
    if (*(indxr + col) >= k) {
      {
#line 516
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"AARGH, indxr[col] %d\n",
              *(indxr + col));
      }
    } else
#line 517
    if (*(indxc + col) < 0) {
      {
#line 518
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"AARGH, indxc[col] %d\n",
              *(indxc + col));
      }
    } else
#line 517
    if (*(indxc + col) >= k) {
      {
#line 518
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"AARGH, indxc[col] %d\n",
              *(indxc + col));
      }
    } else
#line 520
    if (*(indxr + col) != *(indxc + col)) {
#line 521
      row = 0;
      {
#line 521
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 521
        if (! (row < k)) {
#line 521
          goto while_break___7;
        }
#line 522
        tmp___6 = *(src + (row * k + *(indxr + col)));
#line 522
        *(src + (row * k + *(indxr + col))) = *(src + (row * k + *(indxc + col)));
#line 522
        *(src + (row * k + *(indxc + col))) = tmp___6;
#line 521
        row ++;
      }
      while_break___7: /* CIL Label */ ;
      }
    }
#line 514
    col --;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 526
  error = 0;
  fail: 
  {
#line 528
  free((void *)indxc);
#line 529
  free((void *)indxr);
#line 530
  free((void *)ipiv);
#line 531
  free((void *)id_row);
#line 532
  free((void *)temp_row);
  }
#line 533
  return (error);
}
}
#line 604 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static int fec_initialized___3  =    0;
#line 605 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static void init_fec___3(void) 
{ 


  {
  {
#line 609
  generate_gf___3();
#line 613
  init_mul_table___3();
#line 616
  fec_initialized___3 = 1;
  }
#line 617
  return;
}
}
#line 755 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static int shuffle___3(gf **pkt , int *index___0 , int k ) 
{ 
  int i ;
  int c ;
  int tmp ;
  gf *tmp___0 ;

  {
#line 760
  i = 0;
  {
#line 760
  while (1) {
    while_continue: /* CIL Label */ ;
#line 760
    if (! (i < k)) {
#line 760
      goto while_break;
    }
#line 761
    if (*(index___0 + i) >= k) {
#line 762
      i ++;
    } else
#line 761
    if (*(index___0 + i) == i) {
#line 762
      i ++;
    } else {
#line 767
      c = *(index___0 + i);
#line 769
      if (*(index___0 + c) == c) {
#line 771
        return (1);
      }
#line 773
      tmp = *(index___0 + i);
#line 773
      *(index___0 + i) = *(index___0 + c);
#line 773
      *(index___0 + c) = tmp;
#line 774
      tmp___0 = *(pkt + i);
#line 774
      *(pkt + i) = *(pkt + c);
#line 774
      *(pkt + c) = tmp___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 787
  return (0);
}
}
#line 795 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libfec.c"
static gf *build_decode_matrix___3(struct fec_parms *code , int *index___0 ) 
{ 
  int i ;
  int k ;
  gf *p ;
  gf *matrix ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 798
  k = code->k;
#line 799
  tmp = my_malloc___3((int )((unsigned long )(k * k) * sizeof(gf )), " ## __LINE__ ## ");
#line 799
  matrix = (gf *)tmp;
#line 802
  i = 0;
#line 802
  p = matrix;
  }
  {
#line 802
  while (1) {
    while_continue: /* CIL Label */ ;
#line 802
    if (! (i < k)) {
#line 802
      goto while_break;
    }
#line 804
    if (*(index___0 + i) < k) {
      {
#line 805
      memset((void *)p, '\000', (unsigned long )k * sizeof(gf ));
#line 806
      *(p + i) = (gf )1;
      }
    } else
#line 809
    if (*(index___0 + i) < code->n) {
      {
#line 810
      memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(code->enc_matrix + *(index___0 + i) * k),
             (unsigned long )k * sizeof(gf ));
      }
    } else {
      {
#line 812
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"decode: invalid index %d (max %d)\n",
              *(index___0 + i), code->n - 1);
#line 814
      free((void *)matrix);
      }
#line 815
      return ((gf *)((void *)0));
    }
#line 802
    i ++;
#line 802
    p += k;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 819
  tmp___0 = invert_mat___3(matrix, k);
  }
#line 819
  if (tmp___0) {
    {
#line 820
    free((void *)matrix);
#line 821
    matrix = (gf *)((void *)0);
    }
  }
#line 824
  return (matrix);
}
}
#line 38 "./include/xalloc.h"
static void *xmalloc___8(size_t size )  __attribute__((__unused__)) ;
#line 38 "./include/xalloc.h"
static void *xmalloc___8(size_t size ) 
{ 
  void *ptr ;
  void *tmp ;
  int _err ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 41
  tmp = malloc(size);
#line 41
  ptr = tmp;
  }
#line 43
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 43
    if (size != 0UL) {
      {
#line 44
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 44
        tmp___0 = __errno_location();
#line 44
        _err = *tmp___0;
#line 44
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: out of memory\n",
                "libmtd");
#line 44
        tmp___1 = strerror(_err);
#line 44
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
                (int )sizeof("libmtd") + 1, "", _err, tmp___1);
#line 44
        exit(-1);
        }
#line 44
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 45
  return (ptr);
}
}
#line 48
static void *xcalloc___3(size_t nmemb , size_t size )  __attribute__((__unused__)) ;
#line 48 "./include/xalloc.h"
static void *xcalloc___3(size_t nmemb , size_t size ) 
{ 
  void *ptr ;
  void *tmp ;
  int _err ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 51
  tmp = calloc(nmemb, size);
#line 51
  ptr = tmp;
  }
#line 53
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 53
    if (nmemb != 0UL) {
#line 53
      if (size != 0UL) {
        {
#line 54
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 54
          tmp___0 = __errno_location();
#line 54
          _err = *tmp___0;
#line 54
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: out of memory\n",
                  "libmtd");
#line 54
          tmp___1 = strerror(_err);
#line 54
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
                  (int )sizeof("libmtd") + 1, "", _err, tmp___1);
#line 54
          exit(-1);
          }
#line 54
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
  }
#line 55
  return (ptr);
}
}
#line 58
static void *xzalloc___3(size_t size )  __attribute__((__unused__)) ;
#line 58 "./include/xalloc.h"
static void *xzalloc___3(size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 61
  tmp = xcalloc___3((size_t )1, size);
  }
#line 61
  return (tmp);
}
}
#line 50 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static char *mkpath___3(char const   *path , char const   *name ) 
{ 
  char *n ;
  size_t len1 ;
  size_t tmp ;
  size_t len2 ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 53
  tmp = strlen(path);
#line 53
  len1 = tmp;
#line 54
  tmp___0 = strlen(name);
#line 54
  len2 = tmp___0;
#line 56
  tmp___1 = xmalloc___8((len1 + len2) + 2UL);
#line 56
  n = (char *)tmp___1;
#line 58
  memcpy((void */* __restrict  */)n, (void const   */* __restrict  */)path, len1);
  }
#line 59
  if ((int )*(n + (len1 - 1UL)) != 47) {
#line 60
    tmp___2 = len1;
#line 60
    len1 ++;
#line 60
    *(n + tmp___2) = (char )'/';
  }
  {
#line 62
  memcpy((void */* __restrict  */)(n + len1), (void const   */* __restrict  */)name,
         len2 + 1UL);
  }
#line 63
  return (n);
}
}
#line 76 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int read_data___3(char const   *file , void *buf , int buf_len ) 
{ 
  int fd ;
  int rd ;
  int tmp ;
  int tmp1 ;
  ssize_t tmp___0 ;
  int _err ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  ssize_t tmp___4 ;
  int _err___0 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;
  int _err___1 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;

  {
  {
#line 80
  fd = open(file, 524288);
  }
#line 81
  if (fd == -1) {
#line 82
    return (-1);
  }
  {
#line 84
  tmp___0 = read(fd, buf, (size_t )buf_len);
#line 84
  rd = (int )tmp___0;
  }
#line 85
  if (rd == -1) {
    {
#line 86
    tmp___1 = __errno_location();
#line 86
    _err = *tmp___1;
#line 86
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: cannot read \"%s\"\n",
            "libmtd", file);
#line 86
    tmp___2 = strerror(_err);
#line 86
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err, tmp___2);
    }
#line 87
    goto out_error;
  }
#line 90
  if (rd == buf_len) {
    {
#line 91
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: contents of \"%s\" is too long\n",
            "libmtd", file);
#line 92
    tmp___3 = __errno_location();
#line 92
    *tmp___3 = 22;
    }
#line 93
    goto out_error;
  }
  {
#line 96
  *((char *)buf + rd) = (char )'\000';
#line 99
  tmp___4 = read(fd, (void *)(& tmp), (size_t )1);
#line 99
  tmp1 = (int )tmp___4;
  }
#line 100
  if (tmp1 == 1) {
    {
#line 101
    tmp___5 = __errno_location();
#line 101
    _err___0 = *tmp___5;
#line 101
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: cannot read \"%s\"\n",
            "libmtd", file);
#line 101
    tmp___6 = strerror(_err___0);
#line 101
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err___0, tmp___6);
    }
#line 102
    goto out_error;
  }
#line 104
  if (tmp1) {
    {
#line 105
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: file \"%s\" contains too much data (> %d bytes)\n",
            "libmtd", file, buf_len);
#line 107
    tmp___7 = __errno_location();
#line 107
    *tmp___7 = 22;
    }
#line 108
    goto out_error;
  }
  {
#line 111
  tmp___10 = close(fd);
  }
#line 111
  if (tmp___10) {
    {
#line 112
    tmp___8 = __errno_location();
#line 112
    _err___1 = *tmp___8;
#line 112
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: close failed on \"%s\"\n",
            "libmtd", file);
#line 112
    tmp___9 = strerror(_err___1);
#line 112
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err___1, tmp___9);
    }
#line 113
    return (-1);
  }
#line 116
  return (rd);
  out_error: 
  {
#line 119
  close(fd);
  }
#line 120
  return (-1);
}
}
#line 131 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int read_major___3(char const   *file , int *major , int *minor ) 
{ 
  int ret ;
  char buf[50] ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 136
  ret = read_data___3(file, (void *)(buf), 50);
  }
#line 137
  if (ret < 0) {
#line 138
    return (ret);
  }
  {
#line 140
  ret = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%d:%d\n",
               major, minor);
  }
#line 141
  if (ret != 2) {
    {
#line 142
    tmp = __errno_location();
#line 142
    *tmp = 22;
#line 143
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: \"%s\" does not have major:minor format\n",
            "libmtd", file);
    }
#line 143
    return (-1);
  }
#line 146
  if (*major < 0) {
    {
#line 147
    tmp___0 = __errno_location();
#line 147
    *tmp___0 = 22;
#line 148
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: bad major:minor %d:%d in \"%s\"\n",
            "libmtd", *major, *minor, file);
    }
#line 148
    return (-1);
  } else
#line 146
  if (*minor < 0) {
    {
#line 147
    tmp___0 = __errno_location();
#line 147
    *tmp___0 = 22;
#line 148
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: bad major:minor %d:%d in \"%s\"\n",
            "libmtd", *major, *minor, file);
    }
#line 148
    return (-1);
  }
#line 152
  return (0);
}
}
#line 164 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int dev_get_major___3(struct libmtd *lib , int mtd_num , int *major , int *minor ) 
{ 
  size_t tmp ;
  char *file ;
  unsigned long __lengthoffile ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 166
  tmp = strlen((char const   *)lib->mtd_dev);
#line 166
  __lengthoffile = tmp + 50UL;
#line 166
  tmp___0 = __builtin_alloca(sizeof(*file) * __lengthoffile);
#line 166
  file = (char *)tmp___0;
#line 168
  sprintf((char */* __restrict  */)file, (char const   */* __restrict  */)lib->mtd_dev,
          mtd_num);
#line 169
  tmp___1 = read_major___3((char const   *)file, major, minor);
  }
#line 169
  return (tmp___1);
}
}
#line 182 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int dev_read_data___3(char const   *patt , int mtd_num , void *buf , int buf_len ) 
{ 
  size_t tmp ;
  char *file ;
  unsigned long __lengthoffile ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 184
  tmp = strlen(patt);
#line 184
  __lengthoffile = tmp + 100UL;
#line 184
  tmp___0 = __builtin_alloca(sizeof(*file) * __lengthoffile);
#line 184
  file = (char *)tmp___0;
#line 186
  sprintf((char */* __restrict  */)file, (char const   */* __restrict  */)patt, mtd_num);
#line 187
  tmp___1 = read_data___3((char const   *)file, buf, buf_len);
  }
#line 187
  return (tmp___1);
}
}
#line 199 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int read_hex_ll___3(char const   *file , long long *value ) 
{ 
  int fd ;
  int rd ;
  char buf[50] ;
  ssize_t tmp ;
  int _err ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int _err___0 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;

  {
  {
#line 204
  fd = open(file, 524288);
  }
#line 205
  if (fd == -1) {
#line 206
    return (-1);
  }
  {
#line 208
  tmp = read(fd, (void *)(buf), sizeof(buf));
#line 208
  rd = (int )tmp;
  }
#line 209
  if (rd == -1) {
    {
#line 210
    tmp___0 = __errno_location();
#line 210
    _err = *tmp___0;
#line 210
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: cannot read \"%s\"\n",
            "libmtd", file);
#line 210
    tmp___1 = strerror(_err);
#line 210
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err, tmp___1);
    }
#line 211
    goto out_error;
  }
#line 213
  if ((unsigned long )rd == sizeof(buf)) {
    {
#line 214
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: contents of \"%s\" is too long\n",
            "libmtd", file);
#line 215
    tmp___2 = __errno_location();
#line 215
    *tmp___2 = 22;
    }
#line 216
    goto out_error;
  }
  {
#line 218
  buf[rd] = (char )'\000';
#line 220
  tmp___4 = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%llx\n",
                   value);
  }
#line 220
  if (tmp___4 != 1) {
    {
#line 221
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: cannot read integer from \"%s\"\n\n",
            "libmtd", file);
#line 222
    tmp___3 = __errno_location();
#line 222
    *tmp___3 = 22;
    }
#line 223
    goto out_error;
  }
#line 226
  if (*value < 0LL) {
    {
#line 227
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: negative value %lld in \"%s\"\n",
            "libmtd", *value, file);
#line 228
    tmp___5 = __errno_location();
#line 228
    *tmp___5 = 22;
    }
#line 229
    goto out_error;
  }
  {
#line 232
  tmp___8 = close(fd);
  }
#line 232
  if (tmp___8) {
    {
#line 233
    tmp___6 = __errno_location();
#line 233
    _err___0 = *tmp___6;
#line 233
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: close failed on \"%s\"\n",
            "libmtd", file);
#line 233
    tmp___7 = strerror(_err___0);
#line 233
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err___0, tmp___7);
    }
#line 233
    return (-1);
  }
#line 235
  return (0);
  out_error: 
  {
#line 238
  close(fd);
  }
#line 239
  return (-1);
}
}
#line 251 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int read_pos_ll___3(char const   *file , long long *value ) 
{ 
  int fd ;
  int rd ;
  char buf[50] ;
  ssize_t tmp ;
  int _err ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int _err___0 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;

  {
  {
#line 256
  fd = open(file, 524288);
  }
#line 257
  if (fd == -1) {
#line 258
    return (-1);
  }
  {
#line 260
  tmp = read(fd, (void *)(buf), (size_t )50);
#line 260
  rd = (int )tmp;
  }
#line 261
  if (rd == -1) {
    {
#line 262
    tmp___0 = __errno_location();
#line 262
    _err = *tmp___0;
#line 262
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: cannot read \"%s\"\n",
            "libmtd", file);
#line 262
    tmp___1 = strerror(_err);
#line 262
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err, tmp___1);
    }
#line 263
    goto out_error;
  }
#line 265
  if (rd == 50) {
    {
#line 266
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: contents of \"%s\" is too long\n",
            "libmtd", file);
#line 267
    tmp___2 = __errno_location();
#line 267
    *tmp___2 = 22;
    }
#line 268
    goto out_error;
  }
  {
#line 271
  tmp___4 = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%lld\n",
                   value);
  }
#line 271
  if (tmp___4 != 1) {
    {
#line 272
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: cannot read integer from \"%s\"\n\n",
            "libmtd", file);
#line 273
    tmp___3 = __errno_location();
#line 273
    *tmp___3 = 22;
    }
#line 274
    goto out_error;
  }
#line 277
  if (*value < 0LL) {
    {
#line 278
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: negative value %lld in \"%s\"\n",
            "libmtd", *value, file);
#line 279
    tmp___5 = __errno_location();
#line 279
    *tmp___5 = 22;
    }
#line 280
    goto out_error;
  }
  {
#line 283
  tmp___8 = close(fd);
  }
#line 283
  if (tmp___8) {
    {
#line 284
    tmp___6 = __errno_location();
#line 284
    _err___0 = *tmp___6;
#line 284
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: close failed on \"%s\"\n",
            "libmtd", file);
#line 284
    tmp___7 = strerror(_err___0);
#line 284
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err___0, tmp___7);
    }
#line 284
    return (-1);
  }
#line 286
  return (0);
  out_error: 
  {
#line 289
  close(fd);
  }
#line 290
  return (-1);
}
}
#line 301 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int read_hex_int___3(char const   *file , int *value ) 
{ 
  long long res ;
  int tmp ;
  int *tmp___0 ;

  {
  {
#line 305
  tmp = read_hex_ll___3(file, & res);
  }
#line 305
  if (tmp) {
#line 306
    return (-1);
  }
#line 309
  if (res > 2147483647LL) {
    {
#line 310
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: value %lld read from file \"%s\" is out of range\n",
            "libmtd", res, file);
#line 312
    tmp___0 = __errno_location();
#line 312
    *tmp___0 = 22;
    }
#line 313
    return (-1);
  } else
#line 309
  if (res < (-0x7FFFFFFF-1)) {
    {
#line 310
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: value %lld read from file \"%s\" is out of range\n",
            "libmtd", res, file);
#line 312
    tmp___0 = __errno_location();
#line 312
    *tmp___0 = 22;
    }
#line 313
    return (-1);
  }
#line 316
  *value = (int )res;
#line 317
  return (0);
}
}
#line 328 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int read_pos_int___3(char const   *file , int *value ) 
{ 
  long long res ;
  int tmp ;
  int *tmp___0 ;

  {
  {
#line 332
  tmp = read_pos_ll___3(file, & res);
  }
#line 332
  if (tmp) {
#line 333
    return (-1);
  }
#line 336
  if (res > 2147483647LL) {
    {
#line 337
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: value %lld read from file \"%s\" is out of range\n",
            "libmtd", res, file);
#line 339
    tmp___0 = __errno_location();
#line 339
    *tmp___0 = 22;
    }
#line 340
    return (-1);
  }
#line 343
  *value = (int )res;
#line 344
  return (0);
}
}
#line 355 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int dev_read_hex_int___3(char const   *patt , int mtd_num , int *value ) 
{ 
  size_t tmp ;
  char *file ;
  unsigned long __lengthoffile ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 357
  tmp = strlen(patt);
#line 357
  __lengthoffile = tmp + 50UL;
#line 357
  tmp___0 = __builtin_alloca(sizeof(*file) * __lengthoffile);
#line 357
  file = (char *)tmp___0;
#line 359
  sprintf((char */* __restrict  */)file, (char const   */* __restrict  */)patt, mtd_num);
#line 360
  tmp___1 = read_hex_int___3((char const   *)file, value);
  }
#line 360
  return (tmp___1);
}
}
#line 371 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int dev_read_pos_int___3(char const   *patt , int mtd_num , int *value ) 
{ 
  size_t tmp ;
  char *file ;
  unsigned long __lengthoffile ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 373
  tmp = strlen(patt);
#line 373
  __lengthoffile = tmp + 50UL;
#line 373
  tmp___0 = __builtin_alloca(sizeof(*file) * __lengthoffile);
#line 373
  file = (char *)tmp___0;
#line 375
  sprintf((char */* __restrict  */)file, (char const   */* __restrict  */)patt, mtd_num);
#line 376
  tmp___1 = read_pos_int___3((char const   *)file, value);
  }
#line 376
  return (tmp___1);
}
}
#line 387 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int dev_read_pos_ll___3(char const   *patt , int mtd_num , long long *value ) 
{ 
  size_t tmp ;
  char *file ;
  unsigned long __lengthoffile ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 389
  tmp = strlen(patt);
#line 389
  __lengthoffile = tmp + 50UL;
#line 389
  tmp___0 = __builtin_alloca(sizeof(*file) * __lengthoffile);
#line 389
  file = (char *)tmp___0;
#line 391
  sprintf((char */* __restrict  */)file, (char const   */* __restrict  */)patt, mtd_num);
#line 392
  tmp___1 = read_pos_ll___3((char const   *)file, value);
  }
#line 392
  return (tmp___1);
}
}
#line 402 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int type_str2int___3(char const   *str ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 404
  tmp = strcmp(str, "nand");
  }
#line 404
  if (! tmp) {
#line 405
    return (4);
  }
  {
#line 406
  tmp___0 = strcmp(str, "nor");
  }
#line 406
  if (! tmp___0) {
#line 407
    return (3);
  }
  {
#line 408
  tmp___1 = strcmp(str, "rom");
  }
#line 408
  if (! tmp___1) {
#line 409
    return (2);
  }
  {
#line 410
  tmp___2 = strcmp(str, "absent");
  }
#line 410
  if (! tmp___2) {
#line 411
    return (0);
  }
  {
#line 412
  tmp___3 = strcmp(str, "dataflash");
  }
#line 412
  if (! tmp___3) {
#line 413
    return (6);
  }
  {
#line 414
  tmp___4 = strcmp(str, "ram");
  }
#line 414
  if (! tmp___4) {
#line 415
    return (1);
  }
  {
#line 416
  tmp___5 = strcmp(str, "ubi");
  }
#line 416
  if (! tmp___5) {
#line 417
    return (7);
  }
#line 418
  return (-1);
}
}
#line 429 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int dev_node2num___3(struct libmtd *lib , char const   *node , int *mtd_num ) 
{ 
  struct stat st ;
  int i ;
  int mjr ;
  int mnr ;
  struct mtd_info info ;
  int _err ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  int tmp___5 ;
  int mjr1 ;
  int mnr1 ;
  int ret ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;

  {
  {
#line 435
  tmp___1 = stat((char const   */* __restrict  */)node, (struct stat */* __restrict  */)(& st));
  }
#line 435
  if (tmp___1) {
    {
#line 436
    tmp = __errno_location();
#line 436
    _err = *tmp;
#line 436
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: cannot get information about \"%s\"\n",
            "libmtd", node);
#line 436
    tmp___0 = strerror(_err);
#line 436
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err, tmp___0);
    }
#line 436
    return (-1);
  }
#line 438
  if (! ((st.st_mode & 61440U) == 8192U)) {
    {
#line 439
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: \"%s\" is not a character device\n",
            "libmtd", node);
#line 440
    tmp___2 = __errno_location();
#line 440
    *tmp___2 = 22;
    }
#line 441
    return (-1);
  }
  {
#line 444
  tmp___3 = gnu_dev_major((unsigned long long )st.st_rdev);
#line 444
  mjr = (int )tmp___3;
#line 445
  tmp___4 = gnu_dev_minor((unsigned long long )st.st_rdev);
#line 445
  mnr = (int )tmp___4;
#line 447
  tmp___5 = mtd_get_info((libmtd_t )((libmtd_t *)lib), & info);
  }
#line 447
  if (tmp___5) {
#line 448
    return (-1);
  }
#line 450
  i = info.lowest_mtd_num;
  {
#line 450
  while (1) {
    while_continue: /* CIL Label */ ;
#line 450
    if (! (i <= info.highest_mtd_num)) {
#line 450
      goto while_break;
    }
    {
#line 453
    ret = dev_get_major___3(lib, i, & mjr1, & mnr1);
    }
#line 454
    if (ret) {
      {
#line 455
      tmp___6 = __errno_location();
      }
#line 455
      if (*tmp___6 == 2) {
#line 456
        goto __Cont;
      }
      {
#line 457
      tmp___7 = __errno_location();
      }
#line 457
      if (! *tmp___7) {
#line 458
        goto while_break;
      }
#line 459
      return (-1);
    }
#line 462
    if (mjr1 == mjr) {
#line 462
      if (mnr1 == mnr) {
        {
#line 463
        tmp___8 = __errno_location();
#line 463
        *tmp___8 = 0;
#line 464
        *mtd_num = i;
        }
#line 465
        return (0);
      }
    }
    __Cont: /* CIL Label */ 
#line 450
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 469
  tmp___9 = __errno_location();
#line 469
  *tmp___9 = 19;
  }
#line 470
  return (-1);
}
}
#line 489 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int sysfs_is_supported___3(struct libmtd *lib ) 
{ 
  int fd ;
  int num ;
  DIR *sysfs_mtd ;
  size_t tmp ;
  char *file ;
  unsigned long __lengthoffile ;
  void *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int _err ;
  int *tmp___3 ;
  char *tmp___4 ;
  int ret ;
  int mtd_num ;
  char tmp_buf[256] ;
  struct dirent *dirent ;
  int *tmp___5 ;
  size_t tmp___6 ;
  int _err___0 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int _err___1 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;

  {
  {
#line 491
  num = -1;
#line 493
  tmp = strlen((char const   *)lib->mtd_name);
#line 493
  __lengthoffile = tmp + 10UL;
#line 493
  tmp___0 = __builtin_alloca(sizeof(*file) * __lengthoffile);
#line 493
  file = (char *)tmp___0;
#line 495
  sysfs_mtd = opendir((char const   *)lib->sysfs_mtd);
  }
#line 496
  if (! sysfs_mtd) {
    {
#line 497
    tmp___2 = __errno_location();
    }
#line 497
    if (*tmp___2 == 2) {
      {
#line 498
      tmp___1 = __errno_location();
#line 498
      *tmp___1 = 0;
      }
#line 499
      return (0);
    }
    {
#line 501
    tmp___3 = __errno_location();
#line 501
    _err = *tmp___3;
#line 501
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: cannot open \"%s\"\n",
            "libmtd", lib->sysfs_mtd);
#line 501
    tmp___4 = strerror(_err);
#line 501
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err, tmp___4);
    }
#line 501
    return (-1);
  }
  {
#line 508
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 513
    dirent = readdir(sysfs_mtd);
    }
#line 514
    if (! dirent) {
#line 515
      goto while_break;
    }
    {
#line 517
    tmp___6 = strlen((char const   *)(dirent->d_name));
    }
#line 517
    if (tmp___6 >= 255UL) {
      {
#line 518
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: invalid entry in %s: \"%s\"\n",
              "libmtd", lib->sysfs_mtd, dirent->d_name);
#line 520
      tmp___5 = __errno_location();
#line 520
      *tmp___5 = 22;
#line 521
      closedir(sysfs_mtd);
      }
#line 522
      return (-1);
    }
    {
#line 525
    ret = sscanf((char const   */* __restrict  */)(dirent->d_name), (char const   */* __restrict  */)"mtd%d%s",
                 & mtd_num, tmp_buf);
    }
#line 527
    if (ret == 1) {
#line 528
      num = mtd_num;
#line 529
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 533
  tmp___9 = closedir(sysfs_mtd);
  }
#line 533
  if (tmp___9) {
    {
#line 534
    tmp___7 = __errno_location();
#line 534
    _err___0 = *tmp___7;
#line 534
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: closedir failed on \"%s\"\n",
            "libmtd", lib->sysfs_mtd);
#line 534
    tmp___8 = strerror(_err___0);
#line 534
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err___0, tmp___8);
    }
#line 534
    return (-1);
  }
#line 536
  if (num == -1) {
#line 538
    return (0);
  }
  {
#line 540
  sprintf((char */* __restrict  */)file, (char const   */* __restrict  */)lib->mtd_name,
          num);
#line 541
  fd = open((char const   *)file, 524288);
  }
#line 542
  if (fd == -1) {
#line 543
    return (0);
  }
  {
#line 545
  tmp___12 = close(fd);
  }
#line 545
  if (tmp___12) {
    {
#line 546
    tmp___10 = __errno_location();
#line 546
    _err___1 = *tmp___10;
#line 546
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: close failed on \"%s\"\n",
            "libmtd", file);
#line 546
    tmp___11 = strerror(_err___1);
#line 546
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err___1, tmp___11);
    }
#line 547
    return (-1);
  }
#line 550
  return (1);
}
}
#line 803 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int mtd_valid_erase_block___3(struct mtd_dev_info  const  *mtd , int eb ) 
{ 
  int *tmp ;

  {
#line 805
  if (eb < 0) {
    {
#line 806
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: bad eraseblock number %d, mtd%d has %d eraseblocks\n",
            "libmtd", eb, mtd->mtd_num, mtd->eb_cnt);
#line 808
    tmp = __errno_location();
#line 808
    *tmp = 22;
    }
#line 809
    return (-1);
  } else
#line 805
  if (eb >= (int )mtd->eb_cnt) {
    {
#line 806
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: bad eraseblock number %d, mtd%d has %d eraseblocks\n",
            "libmtd", eb, mtd->mtd_num, mtd->eb_cnt);
#line 808
    tmp = __errno_location();
#line 808
    *tmp = 22;
    }
#line 809
    return (-1);
  }
#line 811
  return (0);
}
}
#line 814 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int mtd_xlock___3(struct mtd_dev_info  const  *mtd , int fd , int eb , int req ,
                         char const   *sreq ) 
{ 
  int ret ;
  struct erase_info_user ei ;
  int tmp ;

  {
  {
#line 820
  ret = mtd_valid_erase_block___3(mtd, eb);
  }
#line 821
  if (ret) {
#line 822
    return (ret);
  }
  {
#line 824
  ei.start = (__u32 )(eb * (int )mtd->eb_size);
#line 825
  ei.length = (__u32 )mtd->eb_size;
#line 827
  ret = ioctl(fd, (unsigned long )req, & ei);
  }
#line 828
  if (ret < 0) {
    {
#line 829
    tmp = mtd_ioctl_error(mtd, eb, sreq);
    }
#line 829
    return (tmp);
  }
#line 831
  return (0);
}
}
#line 929 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static uint8_t patterns___3[3]  = {      (uint8_t )165,      (uint8_t )90,      (uint8_t )0};
#line 940 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int check_pattern___3(void const   *buf , uint8_t patt , int size ) 
{ 
  int i ;

  {
#line 944
  i = 0;
  {
#line 944
  while (1) {
    while_continue: /* CIL Label */ ;
#line 944
    if (! (i < size)) {
#line 944
      goto while_break;
    }
#line 945
    if ((int const   )*((uint8_t const   *)buf + i) != (int const   )patt) {
#line 946
      return (0);
    }
#line 944
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 947
  return (1);
}
}
#line 1080 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd.c"
static int legacy_auto_oob_layout___3(struct mtd_dev_info  const  *mtd , int fd ,
                                      int ooblen , void *oob ) 
{ 
  struct nand_oobinfo old_oobinfo ;
  int start ;
  int len ;
  uint8_t *tmp_buf ;
  int _err ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int i ;
  int tags_pos ;

  {
  {
#line 1087
  tmp___1 = ioctl(fd, (unsigned long )(((2U << 30) | (unsigned int )(77 << 8)) | 10U) | (sizeof(struct nand_oobinfo ) << 16),
                  & old_oobinfo);
  }
#line 1087
  if (tmp___1) {
    {
#line 1088
    tmp = __errno_location();
#line 1088
    _err = *tmp;
#line 1088
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: MEMGETOOBSEL failed\n",
            "libmtd");
#line 1088
    tmp___0 = strerror(_err);
#line 1088
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err, tmp___0);
    }
#line 1088
    return (-1);
  }
  {
#line 1090
  tmp___2 = malloc((size_t )ooblen);
#line 1090
  tmp_buf = (uint8_t *)tmp___2;
#line 1091
  memcpy((void */* __restrict  */)tmp_buf, (void const   */* __restrict  */)oob, (size_t )ooblen);
  }
#line 1097
  if (old_oobinfo.useecc == 2U) {
#line 1098
    tags_pos = 0;
#line 1099
    i = 0;
    {
#line 1099
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1099
      if (! old_oobinfo.oobfree[i][1]) {
#line 1099
        goto while_break;
      }
      {
#line 1101
      start = (int )old_oobinfo.oobfree[i][0];
#line 1102
      len = (int )old_oobinfo.oobfree[i][1];
#line 1103
      memcpy((void */* __restrict  */)(oob + start), (void const   */* __restrict  */)(tmp_buf + tags_pos),
             (size_t )len);
#line 1104
      tags_pos += len;
#line 1099
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1108
    start = (int )old_oobinfo.eccbytes;
#line 1109
    len = (int )(mtd->oob_size - (int const   )start);
#line 1110
    memcpy((void */* __restrict  */)(oob + start), (void const   */* __restrict  */)(tmp_buf + start),
           (size_t )len);
    }
  }
#line 1113
  return (0);
}
}
#line 38 "./include/xalloc.h"
static void *xmalloc___9(size_t size )  __attribute__((__unused__)) ;
#line 38 "./include/xalloc.h"
static void *xmalloc___9(size_t size ) 
{ 
  void *ptr ;
  void *tmp ;
  int _err ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 41
  tmp = malloc(size);
#line 41
  ptr = tmp;
  }
#line 43
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 43
    if (size != 0UL) {
      {
#line 44
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 44
        tmp___0 = __errno_location();
#line 44
        _err = *tmp___0;
#line 44
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: out of memory\n",
                "libmtd");
#line 44
        tmp___1 = strerror(_err);
#line 44
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
                (int )sizeof("libmtd") + 1, "", _err, tmp___1);
#line 44
        exit(-1);
        }
#line 44
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 45
  return (ptr);
}
}
#line 70 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd_legacy.c"
static int proc_parse_start___3(struct proc_parse_info *pi ) 
{ 
  int fd ;
  int ret ;
  void *tmp ;
  ssize_t tmp___0 ;
  int _err ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 74
  fd = open("/proc/mtd", 0);
  }
#line 75
  if (fd == -1) {
#line 76
    return (-1);
  }
  {
#line 78
  tmp = xmalloc___9((size_t )4096);
#line 78
  pi->buf = (char *)tmp;
#line 80
  tmp___0 = read(fd, (void *)pi->buf, (size_t )4096);
#line 80
  ret = (int )tmp___0;
  }
#line 81
  if (ret == -1) {
    {
#line 82
    tmp___1 = __errno_location();
#line 82
    _err = *tmp___1;
#line 82
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: cannot read \"%s\"\n",
            "libmtd", "/proc/mtd");
#line 82
    tmp___2 = strerror(_err);
#line 82
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%*serror %d (%s)\n",
            (int )sizeof("libmtd") + 1, "", _err, tmp___2);
    }
#line 83
    goto out_free;
  }
#line 86
  if ((unsigned long )ret < sizeof("dev:    size   erasesize  name\n") - 1UL) {
    {
#line 88
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: \"%s\" does not start with \"%s\"\n",
            "libmtd", "/proc/mtd", "dev:    size   erasesize  name\n");
    }
#line 90
    goto out_free;
  } else {
    {
#line 86
    tmp___3 = memcmp((void const   *)pi->buf, (void const   *)"dev:    size   erasesize  name\n",
                     sizeof("dev:    size   erasesize  name\n") - 1UL);
    }
#line 86
    if (tmp___3) {
      {
#line 88
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: \"%s\" does not start with \"%s\"\n",
              "libmtd", "/proc/mtd", "dev:    size   erasesize  name\n");
      }
#line 90
      goto out_free;
    }
  }
  {
#line 93
  pi->data_size = ret;
#line 94
  pi->next = pi->buf + (sizeof("dev:    size   erasesize  name\n") - 1UL);
#line 96
  close(fd);
  }
#line 97
  return (0);
  out_free: 
  {
#line 100
  free((void *)pi->buf);
#line 101
  close(fd);
  }
#line 102
  return (-1);
}
}
#line 105 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libmtd_legacy.c"
static int proc_parse_next___3(struct proc_parse_info *pi ) 
{ 
  int ret ;
  int len ;
  int pos ;
  char *p ;
  char *p1 ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 107
  pos = (int )(pi->next - pi->buf);
#line 110
  if (pos >= pi->data_size) {
    {
#line 111
    free((void *)pi->buf);
    }
#line 112
    return (0);
  }
  {
#line 115
  ret = sscanf((char const   */* __restrict  */)pi->next, (char const   */* __restrict  */)"mtd%d: %llx %x",
               & pi->mtd_num, & pi->size, & pi->eb_size);
  }
#line 117
  if (ret != 3) {
    {
#line 118
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: \"%s\" pattern not found\n",
            "libmtd", "mtd%d: %llx %x");
    }
#line 118
    return (-1);
  }
  {
#line 120
  tmp = memchr((void const   *)pi->next, '\"', (size_t )(pi->data_size - pos));
#line 120
  p = (char *)tmp;
  }
#line 121
  if (! p) {
    {
#line 122
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: opening \" not found\n",
            "libmtd");
    }
#line 122
    return (-1);
  }
#line 123
  p ++;
#line 124
  pos = (int )(p - pi->buf);
#line 125
  if (pos >= pi->data_size) {
    {
#line 126
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: opening \" not found\n",
            "libmtd");
    }
#line 126
    return (-1);
  }
  {
#line 128
  tmp___0 = memchr((void const   *)p, '\"', (size_t )(pi->data_size - pos));
#line 128
  p1 = (char *)tmp___0;
  }
#line 129
  if (! p1) {
    {
#line 130
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: closing \" not found\n",
            "libmtd");
    }
#line 130
    return (-1);
  }
#line 131
  pos = (int )(p1 - pi->buf);
#line 132
  if (pos >= pi->data_size) {
    {
#line 133
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: closing \" not found\n",
            "libmtd");
    }
#line 133
    return (-1);
  }
#line 135
  len = (int )(p1 - p);
#line 136
  if (len > 127) {
    {
#line 137
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: too long mtd%d device name\n",
            "libmtd", pi->mtd_num);
    }
#line 137
    return (-1);
  }
  {
#line 139
  memcpy((void */* __restrict  */)(pi->name), (void const   */* __restrict  */)p,
         (size_t )len);
#line 140
  pi->name[len] = (char )'\000';
  }
#line 142
  if ((int )*(p1 + 1) != 10) {
    {
#line 143
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error!: opening \"\n\" not found\n",
            "libmtd");
    }
#line 143
    return (-1);
  }
#line 144
  pi->next = p1 + 2;
#line 145
  return (1);
}
}
#line 15 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/doc_loadbios.c"
unsigned char databuf[512]  ;
#line 42 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libcrc32.c"
static uint32_t const   crc32_table___3[256]  = 
#line 42 "/home/wheatley/newnew/temp/mtd-utils-1.5.0/lib/libcrc32.c"
  {      (uint32_t const   )0L,      (uint32_t const   )1996959894L,      (uint32_t const   )3993919788L,      (uint32_t const   )2567524794L, 
        (uint32_t const   )124634137L,      (uint32_t const   )1886057615L,      (uint32_t const   )3915621685L,      (uint32_t const   )2657392035L, 
        (uint32_t const   )249268274L,      (uint32_t const   )2044508324L,      (uint32_t const   )3772115230L,      (uint32_t const   )2547177864L, 
        (uint32_t const   )162941995L,      (uint32_t const   )2125561021L,      (uint32_t const   )3887607047L,      (uint32_t const   )2428444049L, 
        (uint32_t const   )498536548L,      (uint32_t const   )1789927666L,      (uint32_t const   )4089016648L,      (uint32_t const   )2227061214L, 
        (uint32_t const   )450548861L,      (uint32_t const   )1843258603L,      (uint32_t const   )4107580753L,      (uint32_t const   )2211677639L, 
        (uint32_t const   )325883990L,      (uint32_t const   )1684777152L,      (uint32_t const   )4251122042L,      (uint32_t const   )2321926636L, 
        (uint32_t const   )335633487L,      (uint32_t const   )1661365465L,      (uint32_t const   )4195302755L,      (uint32_t const   )2366115317L, 
        (uint32_t const   )997073096L,      (uint32_t const   )1281953886L,      (uint32_t const   )3579855332L,      (uint32_t const   )2724688242L, 
        (uint32_t const   )1006888145L,      (uint32_t const   )1258607687L,      (uint32_t const   )3524101629L,      (uint32_t const   )2768942443L, 
        (uint32_t const   )901097722L,      (uint32_t const   )1119000684L,      (uint32_t const   )3686517206L,      (uint32_t const   )2898065728L, 
        (uint32_t const   )853044451L,      (uint32_t const   )1172266101L,      (uint32_t const   )3705015759L,      (uint32_t const   )2882616665L, 
        (uint32_t const   )651767980L,      (uint32_t const   )1373503546L,      (uint32_t const   )3369554304L,      (uint32_t const   )3218104598L, 
        (uint32_t const   )565507253L,      (uint32_t const   )1454621731L,      (uint32_t const   )3485111705L,      (uint32_t const   )3099436303L, 
        (uint32_t const   )671266974L,      (uint32_t const   )1594198024L,      (uint32_t const   )3322730930L,      (uint32_t const   )2970347812L, 
        (uint32_t const   )795835527L,      (uint32_t const   )1483230225L,      (uint32_t const   )3244367275L,      (uint32_t const   )3060149565L, 
        (uint32_t const   )1994146192L,      (uint32_t const   )31158534L,      (uint32_t const   )2563907772L,      (uint32_t const   )4023717930L, 
        (uint32_t const   )1907459465L,      (uint32_t const   )112637215L,      (uint32_t const   )2680153253L,      (uint32_t const   )3904427059L, 
        (uint32_t const   )2013776290L,      (uint32_t const   )251722036L,      (uint32_t const   )2517215374L,      (uint32_t const   )3775830040L, 
        (uint32_t const   )2137656763L,      (uint32_t const   )141376813L,      (uint32_t const   )2439277719L,      (uint32_t const   )3865271297L, 
        (uint32_t const   )1802195444L,      (uint32_t const   )476864866L,      (uint32_t const   )2238001368L,      (uint32_t const   )4066508878L, 
        (uint32_t const   )1812370925L,      (uint32_t const   )453092731L,      (uint32_t const   )2181625025L,      (uint32_t const   )4111451223L, 
        (uint32_t const   )1706088902L,      (uint32_t const   )314042704L,      (uint32_t const   )2344532202L,      (uint32_t const   )4240017532L, 
        (uint32_t const   )1658658271L,      (uint32_t const   )366619977L,      (uint32_t const   )2362670323L,      (uint32_t const   )4224994405L, 
        (uint32_t const   )1303535960L,      (uint32_t const   )984961486L,      (uint32_t const   )2747007092L,      (uint32_t const   )3569037538L, 
        (uint32_t const   )1256170817L,      (uint32_t const   )1037604311L,      (uint32_t const   )2765210733L,      (uint32_t const   )3554079995L, 
        (uint32_t const   )1131014506L,      (uint32_t const   )879679996L,      (uint32_t const   )2909243462L,      (uint32_t const   )3663771856L, 
        (uint32_t const   )1141124467L,      (uint32_t const   )855842277L,      (uint32_t const   )2852801631L,      (uint32_t const   )3708648649L, 
        (uint32_t const   )1342533948L,      (uint32_t const   )654459306L,      (uint32_t const   )3188396048L,      (uint32_t const   )3373015174L, 
        (uint32_t const   )1466479909L,      (uint32_t const   )544179635L,      (uint32_t const   )3110523913L,      (uint32_t const   )3462522015L, 
        (uint32_t const   )1591671054L,      (uint32_t const   )702138776L,      (uint32_t const   )2966460450L,      (uint32_t const   )3352799412L, 
        (uint32_t const   )1504918807L,      (uint32_t const   )783551873L,      (uint32_t const   )3082640443L,      (uint32_t const   )3233442989L, 
        (uint32_t const   )3988292384L,      (uint32_t const   )2596254646L,      (uint32_t const   )62317068L,      (uint32_t const   )1957810842L, 
        (uint32_t const   )3939845945L,      (uint32_t const   )2647816111L,      (uint32_t const   )81470997L,      (uint32_t const   )1943803523L, 
        (uint32_t const   )3814918930L,      (uint32_t const   )2489596804L,      (uint32_t const   )225274430L,      (uint32_t const   )2053790376L, 
        (uint32_t const   )3826175755L,      (uint32_t const   )2466906013L,      (uint32_t const   )167816743L,      (uint32_t const   )2097651377L, 
        (uint32_t const   )4027552580L,      (uint32_t const   )2265490386L,      (uint32_t const   )503444072L,      (uint32_t const   )1762050814L, 
        (uint32_t const   )4150417245L,      (uint32_t const   )2154129355L,      (uint32_t const   )426522225L,      (uint32_t const   )1852507879L, 
        (uint32_t const   )4275313526L,      (uint32_t const   )2312317920L,      (uint32_t const   )282753626L,      (uint32_t const   )1742555852L, 
        (uint32_t const   )4189708143L,      (uint32_t const   )2394877945L,      (uint32_t const   )397917763L,      (uint32_t const   )1622183637L, 
        (uint32_t const   )3604390888L,      (uint32_t const   )2714866558L,      (uint32_t const   )953729732L,      (uint32_t const   )1340076626L, 
        (uint32_t const   )3518719985L,      (uint32_t const   )2797360999L,      (uint32_t const   )1068828381L,      (uint32_t const   )1219638859L, 
        (uint32_t const   )3624741850L,      (uint32_t const   )2936675148L,      (uint32_t const   )906185462L,      (uint32_t const   )1090812512L, 
        (uint32_t const   )3747672003L,      (uint32_t const   )2825379669L,      (uint32_t const   )829329135L,      (uint32_t const   )1181335161L, 
        (uint32_t const   )3412177804L,      (uint32_t const   )3160834842L,      (uint32_t const   )628085408L,      (uint32_t const   )1382605366L, 
        (uint32_t const   )3423369109L,      (uint32_t const   )3138078467L,      (uint32_t const   )570562233L,      (uint32_t const   )1426400815L, 
        (uint32_t const   )3317316542L,      (uint32_t const   )2998733608L,      (uint32_t const   )733239954L,      (uint32_t const   )1555261956L, 
        (uint32_t const   )3268935591L,      (uint32_t const   )3050360625L,      (uint32_t const   )752459403L,      (uint32_t const   )1541320221L, 
        (uint32_t const   )2607071920L,      (uint32_t const   )3965973030L,      (uint32_t const   )1969922972L,      (uint32_t const   )40735498L, 
        (uint32_t const   )2617837225L,      (uint32_t const   )3943577151L,      (uint32_t const   )1913087877L,      (uint32_t const   )83908371L, 
        (uint32_t const   )2512341634L,      (uint32_t const   )3803740692L,      (uint32_t const   )2075208622L,      (uint32_t const   )213261112L, 
        (uint32_t const   )2463272603L,      (uint32_t const   )3855990285L,      (uint32_t const   )2094854071L,      (uint32_t const   )198958881L, 
        (uint32_t const   )2262029012L,      (uint32_t const   )4057260610L,      (uint32_t const   )1759359992L,      (uint32_t const   )534414190L, 
        (uint32_t const   )2176718541L,      (uint32_t const   )4139329115L,      (uint32_t const   )1873836001L,      (uint32_t const   )414664567L, 
        (uint32_t const   )2282248934L,      (uint32_t const   )4279200368L,      (uint32_t const   )1711684554L,      (uint32_t const   )285281116L, 
        (uint32_t const   )2405801727L,      (uint32_t const   )4167216745L,      (uint32_t const   )1634467795L,      (uint32_t const   )376229701L, 
        (uint32_t const   )2685067896L,      (uint32_t const   )3608007406L,      (uint32_t const   )1308918612L,      (uint32_t const   )956543938L, 
        (uint32_t const   )2808555105L,      (uint32_t const   )3495958263L,      (uint32_t const   )1231636301L,      (uint32_t const   )1047427035L, 
        (uint32_t const   )2932959818L,      (uint32_t const   )3654703836L,      (uint32_t const   )1088359270L,      (uint32_t const   )936918000L, 
        (uint32_t const   )2847714899L,      (uint32_t const   )3736837829L,      (uint32_t const   )1202900863L,      (uint32_t const   )817233897L, 
        (uint32_t const   )3183342108L,      (uint32_t const   )3401237130L,      (uint32_t const   )1404277552L,      (uint32_t const   )615818150L, 
        (uint32_t const   )3134207493L,      (uint32_t const   )3453421203L,      (uint32_t const   )1423857449L,      (uint32_t const   )601450431L, 
        (uint32_t const   )3009837614L,      (uint32_t const   )3294710456L,      (uint32_t const   )1567103746L,      (uint32_t const   )711928724L, 
        (uint32_t const   )3020668471L,      (uint32_t const   )3272380065L,      (uint32_t const   )1510334235L,      (uint32_t const   )755167117L};
