/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 23 "include/errorcode.h"
enum __anonenum_RC_TYPE_59 {
    RC_OK = 0,
    RC_ERROR = 1,
    RC_INVALID_POINTER = 2,
    RC_OUT_OF_MEMORY = 3,
    RC_OUT_BUFFER_OVERFLOW = 4,
    RC_IP_SOCKET_CREATE_ERROR = 16,
    RC_IP_BAD_PARAMETER = 17,
    RC_IP_INVALID_REMOTE_ADDR = 18,
    RC_IP_CONNECT_FAILED = 19,
    RC_IP_SEND_ERROR = 20,
    RC_IP_RECV_ERROR = 21,
    RC_IP_OBJECT_NOT_INITIALIZED = 22,
    RC_IP_OS_SOCKET_INIT_FAILED = 23,
    RC_IP_SOCKET_BIND_ERROR = 24,
    RC_TCP_OBJECT_NOT_INITIALIZED = 32,
    RC_HTTP_OBJECT_NOT_INITIALIZED = 48,
    RC_HTTP_BAD_PARAMETER = 49,
    RC_DYNDNS_BUFFER_TOO_SMALL = 64,
    RC_DYNDNS_INVALID_IP_ADDR_IN_HTTP_RESPONSE = 65,
    RC_DYNDNS_INVALID_RSP_FROM_IP_SERVER = 66,
    RC_DYNDNS_TOO_MANY_ALIASES = 67,
    RC_DYNDNS_INVALID_OPTION = 68,
    RC_DYNDNS_INVALID_OR_MISSING_PARAMETERS = 69,
    RC_DYNDNS_UNRESOLVED_ALIAS = 70,
    RC_DYNDNS_INVALID_DNS_SYSTEM_DEFAULT = 71,
    RC_DYNDNS_RSP_NOTOK = 72,
    RC_DYNDNS_RSP_RETRY_LATER = 73,
    RC_CMD_PARSER_INVALID_OPTION = 80,
    RC_CMD_PARSER_INVALID_OPTION_ARGUMENT = 81,
    RC_OS_ERROR_INSTALLING_SIGNAL_HANDLER = 96,
    RC_OS_INVALID_IP_ADDRESS = 97,
    RC_OS_FORK_FAILURE = 98,
    RC_OS_CHANGE_PERSONA_FAILURE = 99,
    RC_OS_INVALID_UID = 100,
    RC_OS_INVALID_GID = 101,
    RC_FILE_IO_OPEN_ERROR = 112,
    RC_FILE_IO_READ_ERROR = 113,
    RC_FILE_IO_OUT_OF_BUFFER = 114,
    RC_RESTART = 255
} ;
#line 23 "include/errorcode.h"
typedef enum __anonenum_RC_TYPE_59 RC_TYPE;
#line 208 "include/os.h"
enum __anonenum_DBG_DEST_65 {
    DBG_STD_LOG = 0,
    DBG_SYS_LOG = 1,
    DBG_FILE_LOG = 2
} ;
#line 208 "include/os.h"
typedef enum __anonenum_DBG_DEST_65 DBG_DEST;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 183 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 65 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __gid_t gid_t;
#line 80 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 111 "/usr/include/net/if.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 126 "/usr/include/net/if.h"
union __anonunion_ifr_ifrn_63 {
   char ifrn_name[16] ;
};
#line 126 "/usr/include/net/if.h"
union __anonunion_ifr_ifru_64 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16] ;
   char ifru_newname[16] ;
   __caddr_t ifru_data ;
};
#line 126 "/usr/include/net/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_63 ifr_ifrn ;
   union __anonunion_ifr_ifru_64 ifr_ifru ;
};
#line 567 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 71 "include/os.h"
typedef int SOCKET;
#line 113 "include/os.h"
typedef int BOOL;
#line 164 "include/os.h"
struct __anonstruct_OS_USER_INFO_73 {
   uid_t uid ;
   gid_t gid ;
};
#line 164 "include/os.h"
typedef struct __anonstruct_OS_USER_INFO_73 OS_USER_INFO;
#line 39 "include/ip.h"
struct __anonstruct_IP_SOCKET_77 {
   BOOL initialized ;
   char *ifname ;
   BOOL bound ;
   int type ;
   SOCKET socket ;
   struct sockaddr_in local_addr ;
   struct sockaddr remote_addr ;
   socklen_t remote_len ;
   char const   *p_remote_host_name ;
   unsigned short port ;
   int timeout ;
};
#line 39 "include/ip.h"
typedef struct __anonstruct_IP_SOCKET_77 IP_SOCKET;
#line 34 "include/tcp.h"
struct __anonstruct_TCP_SOCKET_78 {
   IP_SOCKET super ;
   BOOL initialized ;
};
#line 34 "include/tcp.h"
typedef struct __anonstruct_TCP_SOCKET_78 TCP_SOCKET;
#line 34 "include/http_client.h"
struct __anonstruct_HTTP_CLIENT_80 {
   TCP_SOCKET super ;
   BOOL initialized ;
};
#line 34 "include/http_client.h"
typedef struct __anonstruct_HTTP_CLIENT_80 HTTP_CLIENT;
#line 40 "include/http_client.h"
struct __anonstruct_HTTP_TRANSACTION_81 {
   char *p_req ;
   int req_len ;
   char *p_rsp ;
   int max_rsp_len ;
   int rsp_len ;
   char *p_rsp_body ;
   int status ;
   char status_desc[256] ;
};
#line 40 "include/http_client.h"
typedef struct __anonstruct_HTTP_TRANSACTION_81 HTTP_TRANSACTION;
#line 31 "include/debug_if.h"
struct __anonstruct_DBG_TYPE_82 {
   int level ;
   int verbose ;
   char p_logfilename[1024] ;
   FILE *p_file ;
};
#line 31 "include/debug_if.h"
typedef struct __anonstruct_DBG_TYPE_82 DBG_TYPE;
#line 33 "include/dyndns.h"
enum __anonenum_DYNDNS_SYSTEM_ID_83 {
    DYNDNS_DEFAULT = 0,
    FREEDNS_AFRAID_ORG_DEFAULT = 1,
    ZONE_EDIT_DEFAULT = 2,
    CUSTOM_HTTP_BASIC_AUTH = 3,
    NOIP_DEFAULT = 4,
    EASYDNS_DEFAULT = 5,
    TZO_DEFAULT = 6,
    DYNDNS_3322_DYNAMIC = 7,
    SITELUTIONS_DOMAIN = 8,
    DNSOMATIC_DEFAULT = 9,
    DNSEXIT_DEFAULT = 10,
    HE_IPV6TB = 11,
    HE_DYNDNS = 12,
    CHANGEIP_DEFAULT = 13,
    DYNSIP_DEFAULT = 14,
    LAST_DNS_SYSTEM = -1
} ;
#line 33 "include/dyndns.h"
typedef enum __anonenum_DYNDNS_SYSTEM_ID_83 DYNDNS_SYSTEM_ID;
#line 220
struct _DYN_DNS_CLIENT;
#line 227 "include/dyndns.h"
struct __anonstruct_DYNDNS_SYSTEM_84 {
   char const   *p_key ;
   RC_TYPE (*p_rsp_ok_func)(struct _DYN_DNS_CLIENT *this , HTTP_TRANSACTION *p_tr ,
                            int infnr ) ;
   int (*p_dns_update_req_func)(struct _DYN_DNS_CLIENT *this , int infnr , int alnr ) ;
   char const   *p_ip_server_name ;
   char const   *p_ip_server_url ;
   char const   *p_dyndns_server_name ;
   char const   *p_dyndns_server_url ;
};
#line 227 "include/dyndns.h"
typedef struct __anonstruct_DYNDNS_SYSTEM_84 DYNDNS_SYSTEM;
#line 238 "include/dyndns.h"
struct __anonstruct_DYNDNS_SYSTEM_INFO_85 {
   DYNDNS_SYSTEM_ID id ;
   DYNDNS_SYSTEM system ;
};
#line 238 "include/dyndns.h"
typedef struct __anonstruct_DYNDNS_SYSTEM_INFO_85 DYNDNS_SYSTEM_INFO;
#line 244
enum __anonenum_DYN_DNS_CMD_86 {
    NO_CMD = 0,
    CMD_STOP = 1,
    CMD_RESTART = 2
} ;
#line 244 "include/dyndns.h"
typedef enum __anonenum_DYN_DNS_CMD_86 DYN_DNS_CMD;
#line 251 "include/dyndns.h"
struct __anonstruct_DYNDNS_CREDENTIALS_87 {
   char my_username[50] ;
   char my_password[50] ;
   char *p_enc_usr_passwd_buffer ;
   int size ;
   BOOL encoded ;
};
#line 251 "include/dyndns.h"
typedef struct __anonstruct_DYNDNS_CREDENTIALS_87 DYNDNS_CREDENTIALS;
#line 260 "include/dyndns.h"
struct __anonstruct_DYNDNS_SERVER_NAME_88 {
   char name[256] ;
   int port ;
};
#line 260 "include/dyndns.h"
typedef struct __anonstruct_DYNDNS_SERVER_NAME_88 DYNDNS_SERVER_NAME;
#line 267 "include/dyndns.h"
struct __anonstruct_DYNDNS_ALIAS_INFO_89 {
   DYNDNS_SERVER_NAME names ;
   int update_required ;
};
#line 267 "include/dyndns.h"
typedef struct __anonstruct_DYNDNS_ALIAS_INFO_89 DYNDNS_ALIAS_INFO;
#line 273 "include/dyndns.h"
struct __anonstruct_DYNDNS_INFO_TYPE_90 {
   BOOL my_ip_has_changed ;
   DYNDNS_SERVER_NAME my_ip_address ;
   DYNDNS_CREDENTIALS credentials ;
   DYNDNS_SYSTEM *p_dns_system ;
   DYNDNS_SERVER_NAME dyndns_server_name ;
   char dyndns_server_url[256] ;
   DYNDNS_SERVER_NAME ip_server_name ;
   char ip_server_url[256] ;
   DYNDNS_SERVER_NAME proxy_server_name ;
   DYNDNS_ALIAS_INFO alias_info[10] ;
   int alias_count ;
   BOOL wildcard ;
};
#line 273 "include/dyndns.h"
typedef struct __anonstruct_DYNDNS_INFO_TYPE_90 DYNDNS_INFO_TYPE;
#line 289 "include/dyndns.h"
struct __anonstruct_USER_INFO_91 {
   uid_t uid ;
   gid_t gid ;
};
#line 289 "include/dyndns.h"
typedef struct __anonstruct_USER_INFO_91 USER_INFO;
#line 295 "include/dyndns.h"
struct DYN_DNS_CLIENT {
   char *cfgfile ;
   char *pidfile ;
   char *external_command ;
   DYN_DNS_CMD cmd ;
   int sleep_sec ;
   int normal_update_period_sec ;
   int error_update_period_sec ;
   int forced_update_period_sec ;
   int time_since_last_update ;
   int cmd_check_period ;
   int total_iterations ;
   int num_iterations ;
   char *cache_file ;
   char *bind_interface ;
   char *check_interface ;
   BOOL initialized ;
   BOOL run_in_background ;
   BOOL debug_to_syslog ;
   BOOL change_persona ;
   BOOL test_update ;
   HTTP_CLIENT http_to_ip_server[5] ;
   HTTP_CLIENT http_to_dyndns[5] ;
   HTTP_TRANSACTION http_tr ;
   char *p_work_buffer ;
   int work_buffer_size ;
   char *p_req_buffer ;
   int req_buffer_size ;
   USER_INFO sys_usr_info ;
   DYNDNS_INFO_TYPE info[5] ;
   int info_count ;
   BOOL abort_on_network_errors ;
   BOOL force_addr_update ;
   BOOL use_proxy ;
   BOOL abort ;
   DBG_TYPE dbg ;
};
#line 295 "include/dyndns.h"
typedef struct DYN_DNS_CLIENT DYN_DNS_CLIENT;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 42 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 33 "include/get_cmd.h"
struct __anonstruct_CMD_DATA_83 {
   int argc ;
   char **argv ;
};
#line 33 "include/get_cmd.h"
typedef struct __anonstruct_CMD_DATA_83 CMD_DATA;
#line 40 "include/get_cmd.h"
struct __anonstruct_CMD_OPTION_HANDLER_TYPE_84 {
   RC_TYPE (*p_func)(CMD_DATA *p_cmd , int current_nr , void *p_context ) ;
   void *p_context ;
};
#line 40 "include/get_cmd.h"
typedef struct __anonstruct_CMD_OPTION_HANDLER_TYPE_84 CMD_OPTION_HANDLER_TYPE;
#line 47 "include/get_cmd.h"
struct __anonstruct_CMD_DESCRIPTION_TYPE_85 {
   char *p_option ;
   int arg_nr ;
   CMD_OPTION_HANDLER_TYPE p_handler ;
   char *p_description ;
};
#line 47 "include/get_cmd.h"
typedef struct __anonstruct_CMD_DESCRIPTION_TYPE_85 CMD_DESCRIPTION_TYPE;
#line 827 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/inadyn_cmd.c"
enum __anonenum_PARSER_STATE_86 {
    NEW_LINE = 0,
    COMMENT = 1,
    DATA = 2,
    SPACE = 3,
    ESCAPE = 4
} ;
#line 827 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/inadyn_cmd.c"
typedef enum __anonenum_PARSER_STATE_86 PARSER_STATE;
#line 836 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/inadyn_cmd.c"
struct __anonstruct_OPTION_FILE_PARSER_87 {
   FILE *p_file ;
   PARSER_STATE state ;
};
#line 836 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/inadyn_cmd.c"
typedef struct __anonstruct_OPTION_FILE_PARSER_87 OPTION_FILE_PARSER;
#line 35 "include/sha1.h"
struct __anonstruct_sha1_context_1 {
   unsigned long total[2] ;
   unsigned long state[5] ;
   unsigned char buffer[64] ;
};
#line 35 "include/sha1.h"
typedef struct __anonstruct_sha1_context_1 sha1_context;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 22 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/errorcode.c"
struct __anonstruct_ERROR_NAME_22 {
   RC_TYPE rc ;
   char const   *p_name ;
};
#line 22 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/errorcode.c"
typedef struct __anonstruct_ERROR_NAME_22 ERROR_NAME;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 260 "/usr/include/unistd.h"
typedef __pid_t pid_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_16 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_16 __sigset_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_37 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_38 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_39 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_40 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_41 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_42 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_43 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_36 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_37 _kill ;
   struct __anonstruct__timer_38 _timer ;
   struct __anonstruct__rt_39 _rt ;
   struct __anonstruct__sigchld_40 _sigchld ;
   struct __anonstruct__sigfault_41 _sigfault ;
   struct __anonstruct__sigpoll_42 _sigpoll ;
   struct __anonstruct__sigsys_43 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_35 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_36 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_35 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_55 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_55 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 35 "include/md5.h"
struct __anonstruct_md5_context_1 {
   unsigned long total[2] ;
   unsigned long state[4] ;
   unsigned char buffer[64] ;
};
#line 35 "include/md5.h"
typedef struct __anonstruct_md5_context_1 md5_context;
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 278
extern FILE *freopen(char const   * __restrict  __filename , char const   * __restrict  __modes ,
                     FILE * __restrict  __stream ) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 390
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 190 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 219 "include/os.h"
RC_TYPE os_open_dbg_output(DBG_DEST dest , char const   *p_prg_name , char const   *p_logfile_name ) ;
#line 224
RC_TYPE os_close_dbg_output(void) ;
#line 230
RC_TYPE os_syslog_open(char const   *p_prg_name ) ;
#line 231
RC_TYPE os_syslog_close(void) ;
#line 45 "include/debug_if.h"
DBG_DEST get_dbg_dest(void) ;
#line 46
void set_dbg_dest(DBG_DEST dest ) ;
#line 51
void os_printf(int prio , char *fmt  , ...) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/os.c"
static DBG_DEST global_mod_dbg_dest  =    (DBG_DEST )0;
#line 41 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/os.c"
DBG_DEST get_dbg_dest(void) 
{ 


  {
#line 43
  return (global_mod_dbg_dest);
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/os.c"
void set_dbg_dest(DBG_DEST dest ) 
{ 


  {
#line 48
  global_mod_dbg_dest = dest;
#line 49
  return;
}
}
#line 55
static char *current_time(void) ;
#line 55 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/os.c"
static char const   wday_name[7][3]  = { {        (char const   )'S',        (char const   )'u',        (char const   )'n'}, 
   {        (char const   )'M',        (char const   )'o',        (char const   )'n'}, 
   {        (char const   )'T',        (char const   )'u',        (char const   )'e'}, 
   {        (char const   )'W',        (char const   )'e',        (char const   )'d'}, 
   {        (char const   )'T',        (char const   )'h',        (char const   )'u'}, 
   {        (char const   )'F',        (char const   )'r',        (char const   )'i'}, 
   {        (char const   )'S',        (char const   )'a',        (char const   )'t'}};
#line 59 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/os.c"
static char const   mon_name[12][3]  = 
#line 59
  { {        (char const   )'J',        (char const   )'a',        (char const   )'n'}, 
   {        (char const   )'F',        (char const   )'e',        (char const   )'b'}, 
   {        (char const   )'M',        (char const   )'a',        (char const   )'r'}, 
   {        (char const   )'A',        (char const   )'p',        (char const   )'r'}, 
   {        (char const   )'M',        (char const   )'a',        (char const   )'y'}, 
   {        (char const   )'J',        (char const   )'u',        (char const   )'n'}, 
   {        (char const   )'J',        (char const   )'u',        (char const   )'l'}, 
   {        (char const   )'A',        (char const   )'u',        (char const   )'g'}, 
   {        (char const   )'S',        (char const   )'e',        (char const   )'p'}, 
   {        (char const   )'O',        (char const   )'c',        (char const   )'t'}, 
   {        (char const   )'N',        (char const   )'o',        (char const   )'v'}, 
   {        (char const   )'D',        (char const   )'e',        (char const   )'c'}};
#line 63 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/os.c"
static char result[26]  ;
#line 51 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/os.c"
static char *current_time(void) 
{ 
  time_t now ;
  struct tm *timeptr ;

  {
  {
#line 65
  time(& now);
#line 66
  timeptr = localtime((time_t const   *)(& now));
#line 68
  sprintf((char */* __restrict  */)(result), (char const   */* __restrict  */)"%.3s %.3s%3d %.2d:%.2d:%.2d %d:",
          wday_name[timeptr->tm_wday], mon_name[timeptr->tm_mon], timeptr->tm_mday,
          timeptr->tm_hour, timeptr->tm_min, timeptr->tm_sec, 1900 + timeptr->tm_year);
  }
#line 73
  return (result);
}
}
#line 79 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/os.c"
static char message[1025]  ;
#line 76 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/os.c"
void os_printf(int prio , char *fmt  , ...) 
{ 
  va_list args ;
  char *tmp ;
  DBG_DEST tmp___0 ;

  {
  {
#line 81
  message[1024] = (char)0;
#line 82
  __builtin_va_start(args, fmt);
#line 83
  vsnprintf((char */* __restrict  */)(message), sizeof(message), (char const   */* __restrict  */)fmt,
            args);
#line 84
  __builtin_va_end(args);
#line 87
  tmp___0 = get_dbg_dest();
  }
#line 87
  if ((unsigned int )tmp___0 == 1U) {
    {
#line 89
    syslog(prio, "%s", message);
    }
  } else {
    {
#line 94
    tmp = current_time();
#line 94
    printf((char const   */* __restrict  */)"%s %s\n", tmp, message);
#line 95
    fflush(stdout);
    }
  }
#line 97
  return;
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/os.c"
RC_TYPE os_open_dbg_output(DBG_DEST dest , char const   *p_prg_name , char const   *p_logfile_name ) 
{ 
  RC_TYPE rc ;
  DBG_DEST tmp ;
  FILE *pF ;
  FILE *tmp___0 ;

  {
  {
#line 110
  rc = (RC_TYPE )0;
#line 111
  set_dbg_dest(dest);
#line 113
  tmp = get_dbg_dest();
  }
  {
#line 115
  if ((unsigned int )tmp == 1U) {
#line 115
    goto case_1;
  }
#line 124
  if ((unsigned int )tmp == 2U) {
#line 124
    goto case_2;
  }
#line 139
  goto switch_default;
  case_1: /* CIL Label */ 
#line 116
  if ((unsigned long )p_prg_name == (unsigned long )((void *)0)) {
#line 118
    rc = (RC_TYPE )2;
#line 119
    goto switch_break;
  }
  {
#line 121
  rc = os_syslog_open(p_prg_name);
  }
#line 122
  goto switch_break;
  case_2: /* CIL Label */ 
#line 125
  if ((unsigned long )p_logfile_name == (unsigned long )((void *)0)) {
#line 127
    rc = (RC_TYPE )2;
#line 128
    goto switch_break;
  }
  {
#line 131
  tmp___0 = freopen((char const   */* __restrict  */)p_logfile_name, (char const   */* __restrict  */)"ab",
                    (FILE */* __restrict  */)stdout);
#line 131
  pF = tmp___0;
  }
#line 132
  if ((unsigned long )pF == (unsigned long )((void *)0)) {
#line 134
    rc = (RC_TYPE )112;
  }
#line 136
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 140
  rc = (RC_TYPE )0;
  switch_break: /* CIL Label */ ;
  }
#line 142
  return (rc);
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/os.c"
RC_TYPE os_close_dbg_output(void) 
{ 
  RC_TYPE rc ;
  DBG_DEST tmp ;

  {
  {
#line 150
  rc = (RC_TYPE )0;
#line 151
  tmp = get_dbg_dest();
  }
  {
#line 153
  if ((unsigned int )tmp == 1U) {
#line 153
    goto case_1;
  }
#line 157
  if ((unsigned int )tmp == 2U) {
#line 157
    goto case_2;
  }
#line 163
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 154
  rc = os_syslog_close();
  }
#line 155
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 158
  fclose(stdout);
#line 159
  rc = (RC_TYPE )0;
  }
#line 160
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 164
  rc = (RC_TYPE )0;
  switch_break: /* CIL Label */ ;
  }
#line 166
  return (rc);
}
}
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 374 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) ntohl)(uint32_t __netlong )  __attribute__((__const__)) ;
#line 272 "/usr/include/stdio.h"
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 273 "/usr/include/resolv.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) __res_init)(void) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 315
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strpbrk)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 557
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strsep)(char ** __restrict  __stringp ,
                                                                                                 char const   * __restrict  __delim ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 312 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask ) ;
#line 321
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 353
extern int close(int __fd ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 53 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) inet_ntoa)(struct in_addr __in ) ;
#line 662 "/usr/include/netdb.h"
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 668
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) freeaddrinfo)(struct addrinfo *__ai ) ;
#line 671
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) gai_strerror)(int __ecode ) ;
#line 677
extern int getnameinfo(struct sockaddr  const  * __restrict  __sa , socklen_t __salen ,
                       char * __restrict  __host , socklen_t __hostlen , char * __restrict  __serv ,
                       socklen_t __servlen , int __flags ) ;
#line 170 "include/os.h"
RC_TYPE os_change_persona(OS_USER_INFO *p_usr_info ) ;
#line 173
void os_sleep_ms(int ms ) ;
#line 176
int os_get_socket_error(void) ;
#line 206
RC_TYPE close_console_window(void) ;
#line 236
RC_TYPE os_shell_execute(char *p_cmd , char *ip , char *hostname , char *iface ) ;
#line 61 "include/http_client.h"
RC_TYPE http_client_construct(HTTP_CLIENT *p_self ) ;
#line 66
RC_TYPE http_client_destruct(HTTP_CLIENT *p_self , int num ) ;
#line 73
RC_TYPE http_client_init(HTTP_CLIENT *p_self , char *msg ) ;
#line 78
RC_TYPE http_client_shutdown(HTTP_CLIENT *p_self ) ;
#line 81
RC_TYPE http_client_transaction(HTTP_CLIENT *p_self , HTTP_TRANSACTION *p_tr ) ;
#line 84
RC_TYPE http_client_set_port(HTTP_CLIENT *p_self , int p ) ;
#line 85
RC_TYPE http_client_set_remote_name(HTTP_CLIENT *p_self , char const   *p ) ;
#line 88
RC_TYPE http_client_set_bind_iface(HTTP_CLIENT *p_self , char *ifname ) ;
#line 341 "include/dyndns.h"
DYNDNS_SYSTEM_INFO *get_dyndns_system_table(void) ;
#line 346
RC_TYPE get_default_config_data(DYN_DNS_CLIENT *p_self ) ;
#line 360
RC_TYPE get_config_data(DYN_DNS_CLIENT *p_self , int argc , char **argv ) ;
#line 365
void dyn_dns_print_hello(void) ;
#line 370
RC_TYPE dyn_dns_construct(DYN_DNS_CLIENT **pp_self ) ;
#line 375
RC_TYPE dyn_dns_destruct(DYN_DNS_CLIENT *p_self ) ;
#line 382
RC_TYPE dyn_dns_init(DYN_DNS_CLIENT *p_self ) ;
#line 387
RC_TYPE dyn_dns_shutdown(DYN_DNS_CLIENT *p_self ) ;
#line 400
RC_TYPE dyn_dns_update_ip(DYN_DNS_CLIENT *p_self ) ;
#line 410
int dyn_dns_main(DYN_DNS_CLIENT *p_dyndns , int argc , char **argv ) ;
#line 50 "include/base64.h"
int base64_encode(unsigned char *dst , size_t *dlen , unsigned char const   *src ,
                  size_t slen ) ;
#line 74 "include/md5.h"
void md5(unsigned char const   *input , size_t ilen , unsigned char *output ) ;
#line 74 "include/sha1.h"
void sha1(unsigned char const   *input , size_t ilen , unsigned char *output ) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/dyndns.c"
static int cached_time_since_last_update  =    0;
#line 45 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/dyndns.c"
static int cached_num_iterations  =    0;
#line 47
static int get_req_for_dyndns_server(DYN_DNS_CLIENT *p_self , int infcnt , int alcnt ) ;
#line 48
static int get_req_for_freedns_server(DYN_DNS_CLIENT *p_self , int infcnt , int alcnt ) ;
#line 49
static int get_req_for_generic_server(DYN_DNS_CLIENT *p_self , int infcnt , int alcnt ) ;
#line 50
static int get_req_for_zoneedit_server(DYN_DNS_CLIENT *p_self , int infcnt , int alcnt ) ;
#line 51
static int get_req_for_easydns_server(DYN_DNS_CLIENT *p_self , int infcnt , int alcnt ) ;
#line 52
static int get_req_for_tzo_server(DYN_DNS_CLIENT *p_self , int infcnt , int alcnt ) ;
#line 53
static int get_req_for_sitelutions_server(DYN_DNS_CLIENT *p_self , int infcnt , int alcnt ) ;
#line 54
static int get_req_for_dnsexit_server(DYN_DNS_CLIENT *p_self , int infcnt , int alcnt ) ;
#line 55
static int get_req_for_he_ipv6tb_server(DYN_DNS_CLIENT *p_self , int infcnt , int alcnt ) ;
#line 56
static int get_req_for_changeip_server(DYN_DNS_CLIENT *p_self , int infcnt , int alcnt ) ;
#line 58
static RC_TYPE is_dyndns_server_rsp_ok(DYN_DNS_CLIENT *p_self , HTTP_TRANSACTION *p_tr ,
                                       int infnr ) ;
#line 59
static RC_TYPE is_freedns_server_rsp_ok(DYN_DNS_CLIENT *p_self , HTTP_TRANSACTION *p_tr ,
                                        int infnr ) ;
#line 60
static RC_TYPE is_generic_server_rsp_ok(DYN_DNS_CLIENT *p_self , HTTP_TRANSACTION *p_tr ,
                                        int infnr ) ;
#line 61
static RC_TYPE is_zoneedit_server_rsp_ok(DYN_DNS_CLIENT *p_self , HTTP_TRANSACTION *p_tr ,
                                         int infnr ) ;
#line 62
static RC_TYPE is_easydns_server_rsp_ok(DYN_DNS_CLIENT *p_self , HTTP_TRANSACTION *p_tr ,
                                        int infnr ) ;
#line 63
static RC_TYPE is_tzo_server_rsp_ok(DYN_DNS_CLIENT *p_self , HTTP_TRANSACTION *p_tr ,
                                    int infnr ) ;
#line 64
static RC_TYPE is_sitelutions_server_rsp_ok(DYN_DNS_CLIENT *p_self , HTTP_TRANSACTION *p_tr ,
                                            int infnr ) ;
#line 65
static RC_TYPE is_dnsexit_server_rsp_ok(DYN_DNS_CLIENT *p_self , HTTP_TRANSACTION *p_tr ,
                                        int infnr ) ;
#line 66
static RC_TYPE is_he_ipv6_server_rsp_ok(DYN_DNS_CLIENT *p_self , HTTP_TRANSACTION *p_tr ,
                                        int infnr ) ;
#line 68 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/dyndns.c"
DYNDNS_SYSTEM_INFO dns_system_table[16]  = 
#line 68
  {      {(DYNDNS_SYSTEM_ID )0, {"default@dyndns.org", (RC_TYPE (*)(struct _DYN_DNS_CLIENT *this ,
                                                                HTTP_TRANSACTION *p_tr ,
                                                                int infnr ))(& is_dyndns_server_rsp_ok),
                             (int (*)(struct _DYN_DNS_CLIENT *this , int infnr , int alnr ))(& get_req_for_dyndns_server),
                             "checkip.dyndns.org", "/", "members.dyndns.org", "/nic/update"}}, 
        {(DYNDNS_SYSTEM_ID )1,
      {"default@freedns.afraid.org", (RC_TYPE (*)(struct _DYN_DNS_CLIENT *this , HTTP_TRANSACTION *p_tr ,
                                                  int infnr ))(& is_freedns_server_rsp_ok),
       (int (*)(struct _DYN_DNS_CLIENT *this , int infnr , int alnr ))(& get_req_for_freedns_server),
       "checkip.dyndns.org", "/", "freedns.afraid.org", "/dynamic/update.php"}}, 
        {(DYNDNS_SYSTEM_ID )2, {"default@zoneedit.com", (RC_TYPE (*)(struct _DYN_DNS_CLIENT *this ,
                                                                  HTTP_TRANSACTION *p_tr ,
                                                                  int infnr ))(& is_zoneedit_server_rsp_ok),
                             (int (*)(struct _DYN_DNS_CLIENT *this , int infnr , int alnr ))(& get_req_for_zoneedit_server),
                             "dynamic.zoneedit.com", "/checkip.html", "dynamic.zoneedit.com",
                             "/auth/dynamic.html"}}, 
        {(DYNDNS_SYSTEM_ID )4, {"default@no-ip.com", (RC_TYPE (*)(struct _DYN_DNS_CLIENT *this ,
                                                               HTTP_TRANSACTION *p_tr ,
                                                               int infnr ))(& is_dyndns_server_rsp_ok),
                             (int (*)(struct _DYN_DNS_CLIENT *this , int infnr , int alnr ))(& get_req_for_dyndns_server),
                             "ip1.dynupdate.no-ip.com", "/", "dynupdate.no-ip.com",
                             "/nic/update"}}, 
        {(DYNDNS_SYSTEM_ID )5, {"default@easydns.com", (RC_TYPE (*)(struct _DYN_DNS_CLIENT *this ,
                                                                 HTTP_TRANSACTION *p_tr ,
                                                                 int infnr ))(& is_easydns_server_rsp_ok),
                             (int (*)(struct _DYN_DNS_CLIENT *this , int infnr , int alnr ))(& get_req_for_easydns_server),
                             "checkip.dyndns.org", "/", "members.easydns.com", "/dyn/dyndns.php"}}, 
        {(DYNDNS_SYSTEM_ID )6,
      {"default@tzo.com", (RC_TYPE (*)(struct _DYN_DNS_CLIENT *this , HTTP_TRANSACTION *p_tr ,
                                       int infnr ))(& is_tzo_server_rsp_ok), (int (*)(struct _DYN_DNS_CLIENT *this ,
                                                                                      int infnr ,
                                                                                      int alnr ))(& get_req_for_tzo_server),
       "echo.tzo.com", "/", "rh.tzo.com", "/webclient/tzoperl.html"}}, 
        {(DYNDNS_SYSTEM_ID )7, {"dyndns@3322.org", (RC_TYPE (*)(struct _DYN_DNS_CLIENT *this ,
                                                             HTTP_TRANSACTION *p_tr ,
                                                             int infnr ))(& is_dyndns_server_rsp_ok),
                             (int (*)(struct _DYN_DNS_CLIENT *this , int infnr , int alnr ))(& get_req_for_dyndns_server),
                             "bliao.com", "/ip.phtml", "members.3322.org", "/dyndns/update"}}, 
        {(DYNDNS_SYSTEM_ID )8,
      {"default@sitelutions.com", (RC_TYPE (*)(struct _DYN_DNS_CLIENT *this , HTTP_TRANSACTION *p_tr ,
                                               int infnr ))(& is_sitelutions_server_rsp_ok),
       (int (*)(struct _DYN_DNS_CLIENT *this , int infnr , int alnr ))(& get_req_for_sitelutions_server),
       "checkip.dyndns.org", "/", "www.sitelutions.com", "/dnsup"}}, 
        {(DYNDNS_SYSTEM_ID )9, {"default@dnsomatic.com", (RC_TYPE (*)(struct _DYN_DNS_CLIENT *this ,
                                                                   HTTP_TRANSACTION *p_tr ,
                                                                   int infnr ))(& is_dyndns_server_rsp_ok),
                             (int (*)(struct _DYN_DNS_CLIENT *this , int infnr , int alnr ))(& get_req_for_dyndns_server),
                             "myip.dnsomatic.com", "/", "updates.dnsomatic.com", "/nic/update"}}, 
        {(DYNDNS_SYSTEM_ID )10,
      {"default@dnsexit.com", (RC_TYPE (*)(struct _DYN_DNS_CLIENT *this , HTTP_TRANSACTION *p_tr ,
                                           int infnr ))(& is_dnsexit_server_rsp_ok),
       (int (*)(struct _DYN_DNS_CLIENT *this , int infnr , int alnr ))(& get_req_for_dnsexit_server),
       "ip.dnsexit.com", "/", "update.dnsexit.com", "/RemoteUpdate.sv"}}, 
        {(DYNDNS_SYSTEM_ID )11, {"ipv6tb@he.net", (RC_TYPE (*)(struct _DYN_DNS_CLIENT *this ,
                                                            HTTP_TRANSACTION *p_tr ,
                                                            int infnr ))(& is_he_ipv6_server_rsp_ok),
                              (int (*)(struct _DYN_DNS_CLIENT *this , int infnr ,
                                       int alnr ))(& get_req_for_he_ipv6tb_server),
                              "checkip.dns.he.net", "/", "ipv4.tunnelbroker.net",
                              "/ipv4_end.php"}}, 
        {(DYNDNS_SYSTEM_ID )12, {"dyndns@he.net", (RC_TYPE (*)(struct _DYN_DNS_CLIENT *this ,
                                                            HTTP_TRANSACTION *p_tr ,
                                                            int infnr ))(& is_dyndns_server_rsp_ok),
                              (int (*)(struct _DYN_DNS_CLIENT *this , int infnr ,
                                       int alnr ))(& get_req_for_dyndns_server), "checkip.dns.he.net",
                              "/", "dyn.dns.he.net", "/nic/update"}}, 
        {(DYNDNS_SYSTEM_ID )13, {"default@changeip.com", (RC_TYPE (*)(struct _DYN_DNS_CLIENT *this ,
                                                                   HTTP_TRANSACTION *p_tr ,
                                                                   int infnr ))(& is_dyndns_server_rsp_ok),
                              (int (*)(struct _DYN_DNS_CLIENT *this , int infnr ,
                                       int alnr ))(& get_req_for_changeip_server),
                              "ip.changeip.com", "/", "nic.changeip.com", "/nic/update"}}, 
        {(DYNDNS_SYSTEM_ID )14,
      {"default@dynsip.org", (RC_TYPE (*)(struct _DYN_DNS_CLIENT *this , HTTP_TRANSACTION *p_tr ,
                                          int infnr ))(& is_dyndns_server_rsp_ok),
       (int (*)(struct _DYN_DNS_CLIENT *this , int infnr , int alnr ))(& get_req_for_dyndns_server),
       "checkip.dyndns.org", "/", "dynsip.org", "/nic/update"}}, 
        {(DYNDNS_SYSTEM_ID )3, {"custom@http_srv_basic_auth", (RC_TYPE (*)(struct _DYN_DNS_CLIENT *this ,
                                                                        HTTP_TRANSACTION *p_tr ,
                                                                        int infnr ))(& is_generic_server_rsp_ok),
                             (int (*)(struct _DYN_DNS_CLIENT *this , int infnr , int alnr ))(& get_req_for_generic_server),
                             "checkip.dyndns.org", "/", "", ""}}, 
        {(DYNDNS_SYSTEM_ID )-1, {(char const   *)((void *)0), (RC_TYPE (*)(struct _DYN_DNS_CLIENT *this ,
                                                                        HTTP_TRANSACTION *p_tr ,
                                                                        int infnr ))((void *)0),
                              (int (*)(struct _DYN_DNS_CLIENT *this , int infnr ,
                                       int alnr ))((void *)0), (char const   *)((void *)0),
                              (char const   *)((void *)0), (char const   *)((void *)0),
                              (char const   *)((void *)0)}}};
#line 179 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/dyndns.c"
static DYNDNS_SYSTEM *get_dns_system_by_id(DYNDNS_SYSTEM_ID id ) 
{ 
  DYNDNS_SYSTEM_INFO *it ;

  {
#line 183
  it = dns_system_table;
  {
#line 183
  while (1) {
    while_continue: /* CIL Label */ ;
#line 183
    if (! ((int )it->id != -1)) {
#line 183
      goto while_break;
    }
#line 185
    if ((int )it->id == (int )id) {
#line 187
      return (& it->system);
    }
#line 183
    it ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 191
  return ((DYNDNS_SYSTEM *)((void *)0));
}
}
#line 194 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/dyndns.c"
DYNDNS_SYSTEM_INFO *get_dyndns_system_table(void) 
{ 


  {
#line 196
  return (dns_system_table);
}
}
#line 200 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/dyndns.c"
static RC_TYPE dyn_dns_wait_for_cmd(DYN_DNS_CLIENT *p_self ) 
{ 
  int counter ;
  DYN_DNS_CMD old_cmd ;
  int tmp ;

  {
#line 205
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 207
    return ((RC_TYPE )2);
  }
#line 210
  old_cmd = p_self->cmd;
#line 211
  if ((unsigned int )old_cmd != 0U) {
#line 213
    return ((RC_TYPE )0);
  }
#line 216
  counter = p_self->sleep_sec / p_self->cmd_check_period;
  {
#line 217
  while (1) {
    while_continue: /* CIL Label */ ;
#line 217
    tmp = counter;
#line 217
    counter --;
#line 217
    if (! tmp) {
#line 217
      goto while_break;
    }
#line 219
    if ((unsigned int )p_self->cmd != (unsigned int )old_cmd) {
#line 221
      goto while_break;
    }
    {
#line 223
    os_sleep_ms(p_self->cmd_check_period * 1000);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 226
  return ((RC_TYPE )0);
}
}
#line 229 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/dyndns.c"
static RC_TYPE is_http_status_code_ok(int status ) 
{ 


  {
#line 231
  if (status == 200) {
#line 232
    return ((RC_TYPE )0);
  } else
#line 233
  if (status >= 500) {
#line 233
    if (status < 600) {
#line 234
      return ((RC_TYPE )73);
    } else {
#line 236
      return ((RC_TYPE )72);
    }
  } else {
#line 236
    return ((RC_TYPE )72);
  }
}
}
#line 239 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/dyndns.c"
static int get_req_for_dyndns_server(DYN_DNS_CLIENT *p_self , int infcnt , int alcnt ) 
{ 
  int tmp ;

  {
#line 241
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 244
    return (0);
  }
  {
#line 247
  tmp = sprintf((char */* __restrict  */)p_self->p_req_buffer, (char const   */* __restrict  */)"GET %s?hostname=%s&myip=%s HTTP/1.0\r\nHost: %s\r\nAuthorization: Basic %s\r\nUser-Agent: inadyn/1.99.4 troglobit@gmail.com\r\n\r\n",
                p_self->info[infcnt].dyndns_server_url, p_self->info[infcnt].alias_info[alcnt].names.name,
                p_self->info[infcnt].my_ip_address.name, p_self->info[infcnt].dyndns_server_name.name,
                p_self->info[infcnt].credentials.p_enc_usr_passwd_buffer);
  }
#line 247
  return (tmp);
}
}
#line 255 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/dyndns.c"
static int get_req_for_freedns_server(DYN_DNS_CLIENT *p_self , int infcnt , int alcnt ) 
{ 
  RC_TYPE rc ;
  RC_TYPE rc2 ;
  HTTP_CLIENT http_to_dyndns ;
  HTTP_TRANSACTION http_tr ;
  char buffer[256] ;
  unsigned char digestbuf[20] ;
  char digeststr[41] ;
  int i ;
  char *buf ;
  char *tmp ;
  char *line ;
  char host[256] ;
  char updateurl[256] ;
  char *hash ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 257
  rc = (RC_TYPE )0;
#line 269
  hash = (char *)((void *)0);
#line 271
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 274
    return (0);
  }
  {
#line 279
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 281
    rc = http_client_construct(& http_to_dyndns);
    }
#line 281
    if ((unsigned int )rc != 0U) {
#line 282
      goto while_break;
    }
    {
#line 284
    http_client_set_port(& http_to_dyndns, p_self->info[infcnt].dyndns_server_name.port);
#line 285
    http_client_set_remote_name(& http_to_dyndns, (char const   *)(p_self->info[infcnt].dyndns_server_name.name));
#line 286
    http_client_set_bind_iface(& http_to_dyndns, p_self->bind_interface);
#line 288
    rc = http_client_init(& http_to_dyndns, (char *)"Sending update URL query");
    }
#line 288
    if ((unsigned int )rc != 0U) {
#line 289
      goto while_break;
    }
    {
#line 291
    snprintf((char */* __restrict  */)(buffer), sizeof(buffer), (char const   */* __restrict  */)"%s|%s",
             p_self->info[infcnt].credentials.my_username, p_self->info[infcnt].credentials.my_password);
#line 294
    tmp___0 = strlen((char const   *)(buffer));
#line 294
    sha1((unsigned char const   *)((unsigned char *)(buffer)), tmp___0, (unsigned char *)(digestbuf));
#line 295
    i = 0;
    }
    {
#line 295
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 295
      if (! (i < 20)) {
#line 295
        goto while_break___0;
      }
      {
#line 296
      sprintf((char */* __restrict  */)(& digeststr[i * 2]), (char const   */* __restrict  */)"%02x",
              (int )digestbuf[i]);
#line 295
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 298
    snprintf((char */* __restrict  */)(buffer), sizeof(buffer), (char const   */* __restrict  */)"/api/?action=getdyndns&sha=%s",
             digeststr);
#line 300
    http_tr.req_len = sprintf((char */* __restrict  */)p_self->p_req_buffer, (char const   */* __restrict  */)"GET %s HTTP/1.0\r\nHost: %s\r\nUser-Agent: inadyn/1.99.4 troglobit@gmail.com\r\n\r\n",
                              buffer, p_self->info[infcnt].dyndns_server_name.name);
#line 302
    http_tr.p_req = p_self->p_req_buffer;
#line 303
    http_tr.p_rsp = p_self->p_work_buffer;
#line 304
    http_tr.max_rsp_len = p_self->work_buffer_size - 1;
#line 305
    http_tr.rsp_len = 0;
#line 307
    rc = http_client_transaction(& http_to_dyndns, & http_tr);
#line 308
    *(http_tr.p_rsp + http_tr.rsp_len) = (char)0;
#line 310
    rc2 = http_client_shutdown(& http_to_dyndns);
#line 312
    http_client_destruct(& http_to_dyndns, 1);
    }
#line 314
    if ((unsigned int )rc != 0U) {
#line 315
      goto while_break;
    } else
#line 314
    if ((unsigned int )rc2 != 0U) {
#line 315
      goto while_break;
    }
    {
#line 317
    rc = is_http_status_code_ok(http_tr.status);
    }
#line 317
    if ((unsigned int )rc != 0U) {
#line 318
      goto while_break;
    }
    {
#line 320
    buf = strdup((char const   *)http_tr.p_rsp_body);
#line 320
    tmp = buf;
#line 322
    line = strsep((char **/* __restrict  */)(& tmp), (char const   */* __restrict  */)"\n");
    }
    {
#line 322
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 322
      if (! line) {
#line 322
        goto while_break___1;
      }
#line 323
      if (*line) {
        {
#line 323
        tmp___1 = sscanf((char const   */* __restrict  */)line, (char const   */* __restrict  */)"%255[^|\r\n]|%*[^|\r\n]|%255[^|\r\n]",
                         host, updateurl);
        }
#line 323
        if (tmp___1 == 2) {
          {
#line 323
          tmp___2 = strcmp((char const   *)(host), (char const   *)(p_self->info[infcnt].alias_info[alcnt].names.name));
          }
#line 323
          if (! tmp___2) {
            {
#line 326
            hash = strstr((char const   *)(updateurl), "?");
            }
#line 327
            goto while_break___1;
          }
        }
      }
      {
#line 322
      line = strsep((char **/* __restrict  */)(& tmp), (char const   */* __restrict  */)"\n");
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 331
    free((void *)buf);
    }
#line 333
    if (! hash) {
#line 334
      rc = (RC_TYPE )72;
    }
#line 279
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 338
  if ((unsigned int )rc != 0U) {
    {
#line 340
    os_printf(6, (char *)"Update URL query failed");
    }
#line 341
    return (0);
  }
  {
#line 344
  tmp___3 = sprintf((char */* __restrict  */)p_self->p_req_buffer, (char const   */* __restrict  */)"GET %s?%s&address=%s HTTP/1.0\r\nHost: %s\r\nUser-Agent: inadyn/1.99.4 troglobit@gmail.com\r\n\r\n",
                    p_self->info[infcnt].dyndns_server_url, hash, p_self->info[infcnt].my_ip_address.name,
                    p_self->info[infcnt].dyndns_server_name.name);
  }
#line 344
  return (tmp___3);
}
}
#line 352 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/dyndns.c"
static int get_req_for_generic_server(DYN_DNS_CLIENT *p_self , int infcnt , int alcnt ) 
{ 
  int tmp ;

  {
#line 354
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 357
    return (0);
  }
  {
#line 360
  tmp = sprintf((char */* __restrict  */)p_self->p_req_buffer, (char const   */* __restrict  */)"GET %s%s HTTP/1.0\r\nHost: %s\r\nAuthorization: Basic %s\r\nUser-Agent: inadyn/1.99.4 troglobit@gmail.com\r\n\r\n",
                p_self->info[infcnt].dyndns_server_url, p_self->info[infcnt].alias_info[alcnt].names.name,
                p_self->info[infcnt].dyndns_server_name.name, p_self->info[infcnt].credentials.p_enc_usr_passwd_buffer);
  }
#line 360
  return (tmp);
}
}
#line 367 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/dyndns.c"
static int get_req_for_zoneedit_server(DYN_DNS_CLIENT *p_self , int infcnt , int alcnt ) 
{ 
  int tmp ;

  {
#line 369
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 372
    return (0);
  }
  {
#line 375
  tmp = sprintf((char */* __restrict  */)p_self->p_req_buffer, (char const   */* __restrict  */)"GET %s?host=%s&dnsto=%s HTTP/1.0\r\nHost: %s\r\nAuthorization: Basic %s\r\nUser-Agent: inadyn/1.99.4 troglobit@gmail.com\r\n\r\n",
                p_self->info[infcnt].dyndns_server_url, p_self->info[infcnt].alias_info[alcnt].names.name,
                p_self->info[infcnt].my_ip_address.name, p_self->info[infcnt].dyndns_server_name.name,
                p_self->info[infcnt].credentials.p_enc_usr_passwd_buffer);
  }
#line 375
  return (tmp);
}
}
#line 383 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/dyndns.c"
static int get_req_for_easydns_server(DYN_DNS_CLIENT *p_self , int infcnt , int alcnt ) 
{ 
  char const   *tmp ;
  int tmp___0 ;

  {
#line 385
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 388
    return (0);
  }
#line 391
  if (p_self->info[infcnt].wildcard) {
#line 391
    tmp = "ON";
  } else {
#line 391
    tmp = "OFF";
  }
  {
#line 391
  tmp___0 = sprintf((char */* __restrict  */)p_self->p_req_buffer, (char const   */* __restrict  */)"GET %s?hostname=%s&myip=%s&wildcard=%s HTTP/1.0\r\nHost: %s\r\nAuthorization: Basic %s\r\nUser-Agent: inadyn/1.99.4 troglobit@gmail.com\r\n\r\n",
                    p_self->info[infcnt].dyndns_server_url, p_self->info[infcnt].alias_info[alcnt].names.name,
                    p_self->info[infcnt].my_ip_address.name, tmp, p_self->info[infcnt].dyndns_server_name.name,
                    p_self->info[infcnt].credentials.p_enc_usr_passwd_buffer);
  }
#line 391
  return (tmp___0);
}
}
#line 400 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/dyndns.c"
static int get_req_for_tzo_server(DYN_DNS_CLIENT *p_self , int infcnt , int alcnt ) 
{ 
  int tmp ;

  {
#line 402
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 405
    return (0);
  }
  {
#line 408
  tmp = sprintf((char */* __restrict  */)p_self->p_req_buffer, (char const   */* __restrict  */)"GET %s?tzoname=%s&email=%s&tzokey=%s&ipaddress=%s&system=tzodns&info=1 HTTP/1.0\r\nHost: %s\r\nUser-Agent: inadyn/1.99.4 troglobit@gmail.com\r\n\r\n",
                p_self->info[infcnt].dyndns_server_url, p_self->info[infcnt].alias_info[alcnt].names.name,
                p_self->info[infcnt].credentials.my_username, p_self->info[infcnt].credentials.my_password,
                p_self->info[infcnt].my_ip_address.name, p_self->info[infcnt].dyndns_server_name.name);
  }
#line 408
  return (tmp);
}
}
#line 417 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/dyndns.c"
static int get_req_for_sitelutions_server(DYN_DNS_CLIENT *p_self , int infcnt , int alcnt ) 
{ 
  int tmp ;

  {
#line 419
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 422
    return (0);
  }
  {
#line 425
  tmp = sprintf((char */* __restrict  */)p_self->p_req_buffer, (char const   */* __restrict  */)"GET %s?user=%s&pass=%s&id=%s&ip=%s HTTP/1.0\r\nHost: %s\r\nUser-Agent: inadyn/1.99.4 troglobit@gmail.com\r\n\r\n",
                p_self->info[infcnt].dyndns_server_url, p_self->info[infcnt].credentials.my_username,
                p_self->info[infcnt].credentials.my_password, p_self->info[infcnt].alias_info[alcnt].names.name,
                p_self->info[infcnt].my_ip_address.name, p_self->info[infcnt].dyndns_server_name.name);
  }
#line 425
  return (tmp);
}
}
#line 434 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/dyndns.c"
static int get_req_for_dnsexit_server(DYN_DNS_CLIENT *p_self , int infcnt , int alcnt ) 
{ 
  int tmp ;

  {
#line 436
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 439
    return (0);
  }
  {
#line 442
  tmp = sprintf((char */* __restrict  */)p_self->p_req_buffer, (char const   */* __restrict  */)"GET %s?login=%s&password=%s&host=%s&myip=%s HTTP/1.0\r\nHost: %s\r\nUser-Agent: inadyn/1.99.4 troglobit@gmail.com\r\n\r\n",
                p_self->info[infcnt].dyndns_server_url, p_self->info[infcnt].credentials.my_username,
                p_self->info[infcnt].credentials.my_password, p_self->info[infcnt].alias_info[alcnt].names.name,
                p_self->info[infcnt].my_ip_address.name, p_self->info[infcnt].dyndns_server_name.name);
  }
#line 442
  return (tmp);
}
}
#line 451 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/dyndns.c"
static int get_req_for_he_ipv6tb_server(DYN_DNS_CLIENT *p_self , int infcnt , int alcnt ) 
{ 
  unsigned char digestbuf[16] ;
  char digeststr[33] ;
  int i ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 457
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 460
    return (0);
  }
  {
#line 463
  tmp = strlen((char const   *)(p_self->info[infcnt].credentials.my_password));
#line 463
  md5((unsigned char const   *)((unsigned char *)(p_self->info[infcnt].credentials.my_password)),
      tmp, (unsigned char *)(digestbuf));
#line 465
  i = 0;
  }
  {
#line 465
  while (1) {
    while_continue: /* CIL Label */ ;
#line 465
    if (! (i < 16)) {
#line 465
      goto while_break;
    }
    {
#line 466
    sprintf((char */* __restrict  */)(& digeststr[i * 2]), (char const   */* __restrict  */)"%02x",
            (int )digestbuf[i]);
#line 465
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 467
  tmp___0 = sprintf((char */* __restrict  */)p_self->p_req_buffer, (char const   */* __restrict  */)"GET %s?ip=%s&apikey=%s&pass=%s&tid=%s HTTP/1.0\r\nHost: %s\r\nUser-Agent: inadyn/1.99.4 troglobit@gmail.com\r\n\r\n",
                    p_self->info[infcnt].dyndns_server_url, p_self->info[infcnt].my_ip_address.name,
                    p_self->info[infcnt].credentials.my_username, digeststr, p_self->info[infcnt].alias_info[alcnt].names.name,
                    p_self->info[infcnt].dyndns_server_name.name);
  }
#line 467
  return (tmp___0);
}
}
#line 476 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/dyndns.c"
static int get_req_for_changeip_server(DYN_DNS_CLIENT *p_self , int infcnt , int alcnt ) 
{ 
  int tmp ;

  {
#line 478
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 481
    return (0);
  }
  {
#line 484
  tmp = sprintf((char */* __restrict  */)p_self->p_req_buffer, (char const   */* __restrict  */)"GET %s?system=dyndns&hostname=%s&myip=%s HTTP/1.0\r\nHost: %s\r\nAuthorization: Basic %s\r\nUser-Agent: inadyn/1.99.4 troglobit@gmail.com\r\n\r\n",
                p_self->info[infcnt].dyndns_server_url, p_self->info[infcnt].alias_info[alcnt].names.name,
                p_self->info[infcnt].my_ip_address.name, p_self->info[infcnt].dyndns_server_name.name,
                p_self->info[infcnt].credentials.p_enc_usr_passwd_buffer);
  }
#line 484
  return (tmp);
}
}
#line 495 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/dyndns.c"
static RC_TYPE do_ip_check_interface(DYN_DNS_CLIENT *p_self ) 
{ 
  struct ifreq ifr ;
  in_addr_t new_ip ;
  char *new_ip_str ;
  int i ;
  int sd ;
  int tmp ;
  int code ;
  int tmp___0 ;
  char *tmp___1 ;
  int code___0 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int anychange ;
  DYNDNS_INFO_TYPE *info ;
  int tmp___5 ;

  {
#line 502
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 504
    return ((RC_TYPE )2);
  }
#line 507
  if (p_self->check_interface) {
    {
#line 509
    os_printf(6, (char *)"Checking for IP# change, querying interface %s", p_self->check_interface);
#line 512
    tmp = socket(2, 2, 0);
#line 512
    sd = tmp;
    }
#line 514
    if (sd < 0) {
      {
#line 516
      tmp___0 = os_get_socket_error();
#line 516
      code = tmp___0;
#line 518
      tmp___1 = strerror(code);
#line 518
      os_printf(4, (char *)"Failed opening network socket: %s", tmp___1);
      }
#line 519
      return ((RC_TYPE )23);
    }
    {
#line 522
    memset((void *)(& ifr), 0, sizeof(struct ifreq ));
#line 523
    ifr.ifr_ifru.ifru_addr.sa_family = (sa_family_t )2;
#line 524
    snprintf((char */* __restrict  */)(ifr.ifr_ifrn.ifrn_name), (size_t )16, (char const   */* __restrict  */)"%s",
             p_self->check_interface);
#line 525
    tmp___4 = ioctl(sd, 35093UL, & ifr);
    }
#line 525
    if (tmp___4 != -1) {
      {
#line 527
      new_ip = ntohl(((struct sockaddr_in *)(& ifr.ifr_ifru.ifru_addr))->sin_addr.s_addr);
#line 528
      new_ip_str = inet_ntoa(((struct sockaddr_in *)(& ifr.ifr_ifru.ifru_addr))->sin_addr);
      }
    } else {
      {
#line 532
      tmp___2 = os_get_socket_error();
#line 532
      code___0 = tmp___2;
#line 534
      tmp___3 = strerror(code___0);
#line 534
      os_printf(3, (char *)"Failed reading IP address of interface %s: %s", p_self->check_interface,
                tmp___3);
      }
#line 536
      return ((RC_TYPE )1);
    }
    {
#line 538
    close(sd);
    }
  } else {
#line 542
    return ((RC_TYPE )1);
  }
#line 545
  if ((new_ip & 4278190080U) == 0U) {
    {
#line 551
    os_printf(4, (char *)"Interface %s has invalid IP# %s", p_self->check_interface,
              new_ip_str);
    }
#line 553
    return ((RC_TYPE )1);
  } else
#line 545
  if ((new_ip & 4278190080U) == 2130706432U) {
    {
#line 551
    os_printf(4, (char *)"Interface %s has invalid IP# %s", p_self->check_interface,
              new_ip_str);
    }
#line 553
    return ((RC_TYPE )1);
  } else
#line 545
  if ((new_ip & 4294901760U) == 2851995648U) {
    {
#line 551
    os_printf(4, (char *)"Interface %s has invalid IP# %s", p_self->check_interface,
              new_ip_str);
    }
#line 553
    return ((RC_TYPE )1);
  } else
#line 545
  if ((new_ip & 4026531840U) == 3758096384U) {
    {
#line 551
    os_printf(4, (char *)"Interface %s has invalid IP# %s", p_self->check_interface,
              new_ip_str);
    }
#line 553
    return ((RC_TYPE )1);
  } else
#line 545
  if ((new_ip & 3758096384U) == 3758096384U) {
    {
#line 551
    os_printf(4, (char *)"Interface %s has invalid IP# %s", p_self->check_interface,
              new_ip_str);
    }
#line 553
    return ((RC_TYPE )1);
  }
#line 556
  anychange = 0;
#line 558
  i = 0;
  {
#line 558
  while (1) {
    while_continue: /* CIL Label */ ;
#line 558
    if (! (i < p_self->info_count)) {
#line 558
      goto while_break;
    }
    {
#line 560
    info = & p_self->info[i];
#line 562
    tmp___5 = strcmp((char const   *)(info->my_ip_address.name), (char const   *)new_ip_str);
#line 562
    info->my_ip_has_changed = tmp___5 != 0;
    }
#line 563
    if (info->my_ip_has_changed) {
      {
#line 565
      anychange ++;
#line 566
      strcpy((char */* __restrict  */)(info->my_ip_address.name), (char const   */* __restrict  */)new_ip_str);
      }
    }
#line 558
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 570
  if (! anychange) {
    {
#line 572
    os_printf(6, (char *)"No IP# change detected, still at %s", new_ip_str);
    }
  }
#line 575
  return ((RC_TYPE )0);
}
}
#line 578 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/dyndns.c"
static int get_req_for_ip_server(DYN_DNS_CLIENT *p_self , int infcnt ) 
{ 
  int tmp ;

  {
#line 580
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 583
    return (0);
  }
  {
#line 586
  tmp = sprintf((char */* __restrict  */)p_self->p_req_buffer, (char const   */* __restrict  */)"GET %s HTTP/1.0\r\nHost: %s\r\nUser-Agent: inadyn/1.99.4 troglobit@gmail.com\r\n\r\n",
                p_self->info[infcnt].ip_server_url, p_self->info[infcnt].ip_server_name.name);
  }
#line 586
  return (tmp);
}
}
#line 593 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/dyndns.c"
static RC_TYPE do_ip_server_transaction(DYN_DNS_CLIENT *p_self , int servernum ) 
{ 
  RC_TYPE rc ;
  HTTP_CLIENT *p_http ;
  HTTP_TRANSACTION *p_tr ;

  {
#line 595
  rc = (RC_TYPE )0;
#line 599
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 601
    return ((RC_TYPE )2);
  }
  {
#line 603
  p_http = & p_self->http_to_ip_server[servernum];
#line 605
  rc = http_client_init(p_http, (char *)"Checking for IP# change");
  }
#line 606
  if ((unsigned int )rc != 0U) {
#line 608
    return (rc);
  }
  {
#line 612
  p_tr = & p_self->http_tr;
#line 613
  p_tr->req_len = get_req_for_ip_server(p_self, servernum);
  }
#line 614
  if (p_self->dbg.level > 2) {
    {
#line 616
    os_printf(7, (char *)"Querying DDNS server for my public IP#:");
#line 617
    os_printf(7, (char *)"%s", p_self->p_req_buffer);
    }
  }
  {
#line 619
  p_tr->p_req = p_self->p_req_buffer;
#line 620
  p_tr->p_rsp = p_self->p_work_buffer;
#line 621
  p_tr->max_rsp_len = p_self->work_buffer_size - 1;
#line 622
  p_tr->rsp_len = 0;
#line 624
  rc = http_client_transaction(p_http, & p_self->http_tr);
#line 625
  *(p_tr->p_rsp + p_tr->rsp_len) = (char)0;
  }
#line 627
  if (p_tr->status != 200) {
#line 628
    rc = (RC_TYPE )66;
  }
  {
#line 630
  http_client_shutdown(p_http);
  }
#line 632
  return (rc);
}
}
#line 641 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/dyndns.c"
static RC_TYPE do_parse_my_ip_address(DYN_DNS_CLIENT *p_self , int servernum ) 
{ 
  int ip1 ;
  int ip2 ;
  int ip3 ;
  int ip4 ;
  int count ;
  int i ;
  char *p_ip ;
  char *p_current_str ;
  BOOL found ;
  char new_ip_str[16] ;
  int anychange ;
  DYNDNS_INFO_TYPE *info ;
  int tmp ;

  {
#line 643
  ip1 = 0;
#line 643
  ip2 = 0;
#line 643
  ip3 = 0;
#line 643
  ip4 = 0;
#line 651
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 653
    return ((RC_TYPE )2);
  } else
#line 651
  if (p_self->http_tr.rsp_len <= 0) {
#line 653
    return ((RC_TYPE )2);
  } else
#line 651
  if ((unsigned long )p_self->http_tr.p_rsp == (unsigned long )((void *)0)) {
#line 653
    return ((RC_TYPE )2);
  }
#line 656
  p_current_str = p_self->http_tr.p_rsp_body;
#line 658
  found = 0;
  {
#line 659
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 662
    p_ip = strpbrk((char const   *)p_current_str, "0123456789");
    }
#line 663
    if ((unsigned long )p_ip != (unsigned long )((void *)0)) {
      {
#line 666
      count = sscanf((char const   */* __restrict  */)p_ip, (char const   */* __restrict  */)"%d.%d.%d.%d",
                     & ip1, & ip2, & ip3, & ip4);
      }
#line 667
      if (count != 4) {
#line 673
        p_current_str = p_ip + 1;
      } else
#line 667
      if (ip1 <= 0) {
#line 673
        p_current_str = p_ip + 1;
      } else
#line 667
      if (ip1 > 255) {
#line 673
        p_current_str = p_ip + 1;
      } else
#line 667
      if (ip2 < 0) {
#line 673
        p_current_str = p_ip + 1;
      } else
#line 667
      if (ip2 > 255) {
#line 673
        p_current_str = p_ip + 1;
      } else
#line 667
      if (ip3 < 0) {
#line 673
        p_current_str = p_ip + 1;
      } else
#line 667
      if (ip3 > 255) {
#line 673
        p_current_str = p_ip + 1;
      } else
#line 667
      if (ip4 < 0) {
#line 673
        p_current_str = p_ip + 1;
      } else
#line 667
      if (ip4 > 255) {
#line 673
        p_current_str = p_ip + 1;
      } else {
#line 678
        found = 1;
#line 679
        goto while_break;
      }
    }
#line 659
    if (! ((unsigned long )p_ip != (unsigned long )((void *)0))) {
#line 659
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 685
  if (found) {
#line 687
    anychange = 0;
#line 689
    i = 0;
    {
#line 689
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 689
      if (! (i < p_self->info_count)) {
#line 689
        goto while_break___0;
      }
      {
#line 691
      info = & p_self->info[i];
#line 693
      sprintf((char */* __restrict  */)(new_ip_str), (char const   */* __restrict  */)"%d.%d.%d.%d",
              ip1, ip2, ip3, ip4);
#line 695
      tmp = strcmp((char const   *)(info->my_ip_address.name), (char const   *)(new_ip_str));
#line 695
      info->my_ip_has_changed = tmp != 0;
      }
#line 696
      if (info->my_ip_has_changed) {
        {
#line 698
        anychange ++;
#line 699
        strcpy((char */* __restrict  */)(info->my_ip_address.name), (char const   */* __restrict  */)(new_ip_str));
        }
      }
#line 689
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 703
    if (! anychange) {
      {
#line 705
      os_printf(6, (char *)"No IP# change detected, still at %s", new_ip_str);
      }
    }
#line 708
    return ((RC_TYPE )0);
  }
#line 711
  return ((RC_TYPE )66);
}
}
#line 723 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/dyndns.c"
static RC_TYPE do_check_alias_update_table(DYN_DNS_CLIENT *p_self ) 
{ 
  int i ;
  int j ;
  DYNDNS_INFO_TYPE *info ;

  {
#line 730
  if (p_self->info[0].my_ip_has_changed) {
#line 730
    goto _L;
  } else
#line 730
  if (p_self->force_addr_update) {
#line 730
    goto _L;
  } else
#line 730
  if (p_self->time_since_last_update > p_self->forced_update_period_sec) {
    _L: /* CIL Label */ 
#line 733
    i = 0;
    {
#line 733
    while (1) {
      while_continue: /* CIL Label */ ;
#line 733
      if (! (i < p_self->info_count)) {
#line 733
        goto while_break;
      }
#line 735
      info = & p_self->info[i];
#line 737
      j = 0;
      {
#line 737
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 737
        if (! (j < info->alias_count)) {
#line 737
          goto while_break___0;
        }
        {
#line 739
        info->alias_info[j].update_required = 1;
#line 740
        os_printf(4, (char *)"Update needed for alias %s, new IP# %s", info->alias_info[j].names.name,
                  info->my_ip_address.name);
#line 737
        j ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 733
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 746
  return ((RC_TYPE )0);
}
}
#line 752 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/dyndns.c"
static RC_TYPE is_dyndns_server_rsp_ok(DYN_DNS_CLIENT *p_self , HTTP_TRANSACTION *p_tr ,
                                       int infnr ) 
{ 
  char *p_rsp ;
  RC_TYPE rc ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 755
  p_rsp = p_tr->p_rsp_body;
#line 759
  rc = is_http_status_code_ok(p_tr->status);
  }
#line 759
  if ((unsigned int )rc != 0U) {
#line 760
    return (rc);
  }
  {
#line 762
  tmp___1 = strstr((char const   *)p_rsp, "good");
  }
#line 762
  if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 764
    return ((RC_TYPE )0);
  } else {
    {
#line 762
    tmp___2 = strstr((char const   *)p_rsp, "nochg");
    }
#line 762
    if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 764
      return ((RC_TYPE )0);
    } else {
      {
#line 765
      tmp = strstr((char const   *)p_rsp, "dnserr");
      }
#line 765
      if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 767
        return ((RC_TYPE )73);
      } else {
        {
#line 765
        tmp___0 = strstr((char const   *)p_rsp, "911");
        }
#line 765
        if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 767
          return ((RC_TYPE )73);
        } else {
#line 769
          return ((RC_TYPE )72);
        }
      }
    }
  }
}
}
#line 777 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/dyndns.c"
static RC_TYPE is_freedns_server_rsp_ok(DYN_DNS_CLIENT *p_self , HTTP_TRANSACTION *p_tr ,
                                        int infnr ) 
{ 
  char *p_rsp ;
  RC_TYPE rc ;
  char *tmp ;

  {
  {
#line 779
  p_rsp = p_tr->p_rsp_body;
#line 782
  rc = is_http_status_code_ok(p_tr->status);
  }
#line 782
  if ((unsigned int )rc != 0U) {
#line 783
    return (rc);
  }
  {
#line 785
  tmp = strstr((char const   *)p_rsp, (char const   *)(p_self->info[infnr].my_ip_address.name));
  }
#line 785
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 786
    return ((RC_TYPE )0);
  } else {
#line 788
    return ((RC_TYPE )72);
  }
}
}
#line 795 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/dyndns.c"
static RC_TYPE is_generic_server_rsp_ok(DYN_DNS_CLIENT *p_self , HTTP_TRANSACTION *p_tr ,
                                        int infnr ) 
{ 
  char *p_rsp ;
  RC_TYPE rc ;
  char *tmp ;

  {
  {
#line 798
  p_rsp = p_tr->p_rsp_body;
#line 802
  rc = is_http_status_code_ok(p_tr->status);
  }
#line 802
  if ((unsigned int )rc != 0U) {
#line 803
    return (rc);
  }
  {
#line 805
  tmp = strstr((char const   *)p_rsp, "OK");
  }
#line 805
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 806
    return ((RC_TYPE )0);
  } else {
#line 808
    return ((RC_TYPE )72);
  }
}
}
#line 816 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/dyndns.c"
static RC_TYPE is_zoneedit_server_rsp_ok(DYN_DNS_CLIENT *p_self , HTTP_TRANSACTION *p_tr ,
                                         int infnr ) 
{ 
  RC_TYPE rc ;
  int code ;

  {
  {
#line 822
  rc = is_http_status_code_ok(p_tr->status);
  }
#line 822
  if ((unsigned int )rc != 0U) {
#line 823
    return (rc);
  }
  {
#line 825
  code = -1;
#line 826
  sscanf((char const   */* __restrict  */)p_tr->p_rsp_body, (char const   */* __restrict  */)"%*s CODE=\"%d\" ",
         & code);
  }
  {
#line 831
  if (code == 707) {
#line 831
    goto case_707;
  }
#line 831
  if (code == 201) {
#line 831
    goto case_707;
  }
#line 831
  if (code == 200) {
#line 831
    goto case_707;
  }
#line 834
  goto switch_default;
  case_707: /* CIL Label */ 
  case_201: /* CIL Label */ 
  case_200: /* CIL Label */ 
#line 833
  return ((RC_TYPE )0);
  switch_default: /* CIL Label */ 
#line 835
  return ((RC_TYPE )72);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 842 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/dyndns.c"
static RC_TYPE is_easydns_server_rsp_ok(DYN_DNS_CLIENT *p_self , HTTP_TRANSACTION *p_tr ,
                                        int infnr ) 
{ 
  char *p_rsp ;
  RC_TYPE rc ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 845
  p_rsp = p_tr->p_rsp_body;
#line 849
  rc = is_http_status_code_ok(p_tr->status);
  }
#line 849
  if ((unsigned int )rc != 0U) {
#line 850
    return (rc);
  }
  {
#line 852
  tmp___0 = strstr((char const   *)p_rsp, "NOERROR");
  }
#line 852
  if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 853
    return ((RC_TYPE )0);
  } else {
    {
#line 854
    tmp = strstr((char const   *)p_rsp, "TOOSOON");
    }
#line 854
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 855
      return ((RC_TYPE )73);
    } else {
#line 857
      return ((RC_TYPE )72);
    }
  }
}
}
#line 861 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/dyndns.c"
static RC_TYPE is_tzo_server_rsp_ok(DYN_DNS_CLIENT *p_self , HTTP_TRANSACTION *p_tr ,
                                    int infnr ) 
{ 
  RC_TYPE rc ;
  int code ;

  {
  {
#line 867
  rc = is_http_status_code_ok(p_tr->status);
  }
#line 867
  if ((unsigned int )rc != 0U) {
#line 868
    return (rc);
  }
  {
#line 870
  code = -1;
#line 871
  sscanf((char const   */* __restrict  */)p_tr->p_rsp_body, (char const   */* __restrict  */)"%d ",
         & code);
  }
  {
#line 875
  if (code == 304) {
#line 875
    goto case_304;
  }
#line 875
  if (code == 200) {
#line 875
    goto case_304;
  }
#line 878
  if (code == 500) {
#line 878
    goto case_500;
  }
#line 878
  if (code == 414) {
#line 878
    goto case_500;
  }
#line 880
  goto switch_default;
  case_304: /* CIL Label */ 
  case_200: /* CIL Label */ 
#line 876
  return ((RC_TYPE )0);
  case_500: /* CIL Label */ 
  case_414: /* CIL Label */ 
#line 879
  return ((RC_TYPE )73);
  switch_default: /* CIL Label */ 
#line 881
  return ((RC_TYPE )72);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 885 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/dyndns.c"
static RC_TYPE is_sitelutions_server_rsp_ok(DYN_DNS_CLIENT *p_self , HTTP_TRANSACTION *p_tr ,
                                            int infnr ) 
{ 
  char *p_rsp ;
  RC_TYPE rc ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 888
  p_rsp = p_tr->p_rsp_body;
#line 892
  rc = is_http_status_code_ok(p_tr->status);
  }
#line 892
  if ((unsigned int )rc != 0U) {
#line 893
    return (rc);
  }
  {
#line 895
  tmp___0 = strstr((char const   *)p_rsp, "success");
  }
#line 895
  if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 896
    return ((RC_TYPE )0);
  } else {
    {
#line 897
    tmp = strstr((char const   *)p_rsp, "dberror");
    }
#line 897
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 898
      return ((RC_TYPE )73);
    } else {
#line 900
      return ((RC_TYPE )72);
    }
  }
}
}
#line 903 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/dyndns.c"
static RC_TYPE is_dnsexit_server_rsp_ok(DYN_DNS_CLIENT *p_self , HTTP_TRANSACTION *p_tr ,
                                        int infnr ) 
{ 
  RC_TYPE rc ;
  int code ;
  char *tmp ;

  {
  {
#line 909
  rc = is_http_status_code_ok(p_tr->status);
  }
#line 909
  if ((unsigned int )rc != 0U) {
#line 910
    return (rc);
  }
  {
#line 912
  code = -1;
#line 914
  tmp = strstr((char const   *)p_tr->p_rsp_body, "\n");
  }
#line 914
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
    {
#line 915
    tmp ++;
#line 915
    sscanf((char const   */* __restrict  */)tmp, (char const   */* __restrict  */)"%d=",
           & code);
    }
  }
  {
#line 919
  if (code == 1) {
#line 919
    goto case_1;
  }
#line 919
  if (code == 0) {
#line 919
    goto case_1;
  }
#line 922
  if (code == 11) {
#line 922
    goto case_11;
  }
#line 922
  if (code == 4) {
#line 922
    goto case_11;
  }
#line 924
  goto switch_default;
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 920
  return ((RC_TYPE )0);
  case_11: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 923
  return ((RC_TYPE )73);
  switch_default: /* CIL Label */ 
#line 925
  return ((RC_TYPE )72);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 932 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/dyndns.c"
static RC_TYPE is_he_ipv6_server_rsp_ok(DYN_DNS_CLIENT *p_self , HTTP_TRANSACTION *p_tr ,
                                        int infnr ) 
{ 
  char *p_rsp ;
  RC_TYPE rc ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 934
  p_rsp = p_tr->p_rsp_body;
#line 937
  rc = is_http_status_code_ok(p_tr->status);
  }
#line 937
  if ((unsigned int )rc != 0U) {
#line 938
    return (rc);
  }
  {
#line 940
  tmp = strstr((char const   *)p_rsp, (char const   *)(p_self->info[infnr].my_ip_address.name));
  }
#line 940
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 942
    return ((RC_TYPE )0);
  } else {
    {
#line 940
    tmp___0 = strstr((char const   *)p_rsp, "-ERROR: This tunnel is already associated with this IP address.");
    }
#line 940
    if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 942
      return ((RC_TYPE )0);
    } else {
#line 944
      return ((RC_TYPE )72);
    }
  }
}
}
#line 947 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/dyndns.c"
static RC_TYPE do_update_alias_table(DYN_DNS_CLIENT *p_self ) 
{ 
  int i ;
  int j ;
  RC_TYPE rc ;
  RC_TYPE rc2 ;
  HTTP_TRANSACTION http_tr ;
  int anychange ;
  DYNDNS_INFO_TYPE *info ;
  char const   *tmp ;
  char const   *tmp___0 ;
  FILE *fp ;
  int tmp___1 ;

  {
#line 950
  rc = (RC_TYPE )0;
#line 952
  anychange = 0;
#line 954
  i = 0;
  {
#line 954
  while (1) {
    while_continue: /* CIL Label */ ;
#line 954
    if (! (i < p_self->info_count)) {
#line 954
      goto while_break;
    }
#line 956
    info = & p_self->info[i];
#line 958
    j = 0;
    {
#line 958
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 958
      if (! (j < info->alias_count)) {
#line 958
        goto while_break___0;
      }
#line 960
      if (info->alias_info[j].update_required != 1) {
#line 962
        goto __Cont;
      }
      {
#line 965
      rc = http_client_init(& p_self->http_to_dyndns[i], (char *)"Sending IP# update to DDNS server");
      }
#line 966
      if ((unsigned int )rc != 0U) {
#line 968
        goto while_break___0;
      }
      {
#line 972
      http_tr.req_len = (*((info->p_dns_system)->p_dns_update_req_func))((struct _DYN_DNS_CLIENT *)p_self,
                                                                         i, j);
#line 974
      http_tr.p_req = p_self->p_req_buffer;
#line 975
      http_tr.p_rsp = p_self->p_work_buffer;
#line 976
      http_tr.max_rsp_len = p_self->work_buffer_size - 1;
#line 977
      http_tr.rsp_len = 0;
#line 979
      rc = http_client_transaction(& p_self->http_to_dyndns[i], & http_tr);
#line 980
      *(http_tr.p_rsp + http_tr.rsp_len) = (char)0;
      }
#line 982
      if (p_self->dbg.level > 2) {
        {
#line 984
        *(p_self->p_req_buffer + http_tr.req_len) = (char)0;
#line 985
        os_printf(7, (char *)"Sending alias table update to DDNS server:");
#line 986
        os_printf(7, (char *)"%s", p_self->p_req_buffer);
        }
      }
#line 989
      if ((unsigned int )rc == 0U) {
        {
#line 991
        rc = (*((info->p_dns_system)->p_rsp_ok_func))((struct _DYN_DNS_CLIENT *)p_self,
                                                      & http_tr, i);
        }
#line 993
        if ((unsigned int )rc == 0U) {
          {
#line 995
          info->alias_info[j].update_required = 0;
#line 997
          os_printf(6, (char *)"Successful alias table update for %s => new IP# %s",
                    info->alias_info[j].names.name, info->my_ip_address.name);
#line 999
          p_self->time_since_last_update = 0;
#line 1000
          anychange ++;
          }
        } else {
#line 1004
          if ((unsigned int )rc == 73U) {
#line 1004
            tmp = "Temporary";
          } else {
#line 1004
            tmp = "Fatal";
          }
          {
#line 1004
          os_printf(4, (char *)"%s error in DDNS server response:", tmp);
          }
#line 1006
          if ((unsigned long )http_tr.p_rsp_body != (unsigned long )http_tr.p_rsp) {
#line 1006
            tmp___0 = (char const   *)http_tr.p_rsp_body;
          } else {
#line 1006
            tmp___0 = "";
          }
          {
#line 1006
          os_printf(4, (char *)"[%d %s] %s", http_tr.status, http_tr.status_desc,
                    tmp___0);
          }
        }
#line 1011
        if (p_self->dbg.level > 2) {
          {
#line 1013
          os_printf(7, (char *)"DDNS server response:");
#line 1014
          os_printf(7, (char *)"%s", http_tr.p_rsp);
          }
        }
      }
      {
#line 1018
      rc2 = http_client_shutdown(& p_self->http_to_dyndns[i]);
      }
#line 1019
      if ((unsigned int )rc == 0U) {
#line 1023
        rc = rc2;
      }
#line 1025
      if ((unsigned int )rc != 0U) {
#line 1027
        goto while_break___0;
      }
      {
#line 1029
      os_sleep_ms(1000);
      }
      __Cont: /* CIL Label */ 
#line 958
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 954
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1034
  if (anychange) {
#line 1034
    goto _L;
  } else {
    {
#line 1034
    tmp___1 = access((char const   *)p_self->cache_file, 0);
    }
#line 1034
    if (tmp___1) {
      _L: /* CIL Label */ 
      {
#line 1039
      fp = fopen((char const   */* __restrict  */)p_self->cache_file, (char const   */* __restrict  */)"w");
      }
#line 1040
      if (fp) {
        {
#line 1042
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s",
                p_self->info[0].my_ip_address.name);
#line 1043
        fclose(fp);
        }
      }
#line 1047
      if (anychange) {
#line 1047
        if (p_self->external_command) {
          {
#line 1049
          os_shell_execute(p_self->external_command, p_self->info[0].my_ip_address.name,
                           p_self->info[0].alias_info[0].names.name, p_self->bind_interface);
          }
        }
      }
    }
  }
#line 1056
  return (rc);
}
}
#line 1060 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/dyndns.c"
RC_TYPE get_default_config_data(DYN_DNS_CLIENT *p_self ) 
{ 
  RC_TYPE rc ;
  int i ;

  {
#line 1062
  rc = (RC_TYPE )0;
  {
#line 1065
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1067
    p_self->info[0].p_dns_system = get_dns_system_by_id((DYNDNS_SYSTEM_ID )0);
    }
#line 1068
    if ((unsigned long )p_self->info[0].p_dns_system == (unsigned long )((void *)0)) {
#line 1070
      rc = (RC_TYPE )71;
#line 1071
      goto while_break;
    }
#line 1075
    p_self->forced_update_period_sec = 2592000;
#line 1078
    p_self->error_update_period_sec = 600;
#line 1081
    p_self->normal_update_period_sec = 120;
#line 1082
    p_self->sleep_sec = 120;
#line 1085
    i = 0;
    {
#line 1085
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1085
      if (! (i < 5)) {
#line 1085
        goto while_break___0;
      }
#line 1086
      p_self->info[i].wildcard = 0;
#line 1085
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1089
    p_self->pidfile = strdup("/var/run/inadyn/inadyn.pid");
    }
#line 1065
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1095
  return (rc);
}
}
#line 1099 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/dyndns.c"
static RC_TYPE get_encoded_user_passwd(DYN_DNS_CLIENT *p_self ) 
{ 
  RC_TYPE rc ;
  char const   *format ;
  char *p_tmp_buff ;
  int size ;
  int actual_len ;
  int i ;
  char *p_b64_buff ;
  int rc2 ;
  size_t dlen ;
  DYNDNS_INFO_TYPE *info ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;

  {
#line 1101
  rc = (RC_TYPE )0;
#line 1102
  format = "%s:%s";
#line 1103
  p_tmp_buff = (char *)((void *)0);
#line 1105
  i = 0;
#line 1106
  p_b64_buff = (char *)((void *)0);
  {
#line 1109
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1111
    dlen = (size_t )0;
#line 1112
    info = & p_self->info[i];
#line 1114
    tmp = strlen((char const   *)(info->credentials.my_password));
#line 1114
    tmp___0 = strlen((char const   *)(info->credentials.my_username));
#line 1114
    tmp___1 = strlen(format);
#line 1114
    size = (int )(((tmp + tmp___0) + tmp___1) + 1UL);
#line 1118
    tmp___2 = malloc((size_t )size);
#line 1118
    p_tmp_buff = (char *)tmp___2;
    }
#line 1119
    if ((unsigned long )p_tmp_buff == (unsigned long )((void *)0)) {
#line 1121
      info->credentials.encoded = 0;
#line 1122
      rc = (RC_TYPE )3;
#line 1123
      goto while_break;
    }
    {
#line 1126
    actual_len = sprintf((char */* __restrict  */)p_tmp_buff, (char const   */* __restrict  */)format,
                         info->credentials.my_username, info->credentials.my_password);
    }
#line 1129
    if (actual_len >= size) {
#line 1131
      info->credentials.encoded = 0;
#line 1132
      rc = (RC_TYPE )4;
#line 1133
      goto while_break;
    }
    {
#line 1137
    tmp___3 = strlen((char const   *)p_tmp_buff);
#line 1137
    base64_encode((unsigned char *)((void *)0), & dlen, (unsigned char const   *)((unsigned char *)p_tmp_buff),
                  tmp___3);
#line 1138
    tmp___4 = malloc(dlen);
#line 1138
    p_b64_buff = (char *)tmp___4;
    }
#line 1139
    if ((unsigned long )p_b64_buff == (unsigned long )((void *)0)) {
#line 1141
      info->credentials.encoded = 0;
#line 1142
      rc = (RC_TYPE )3;
#line 1143
      goto while_break;
    }
    {
#line 1147
    tmp___5 = strlen((char const   *)p_tmp_buff);
#line 1147
    rc2 = base64_encode((unsigned char *)p_b64_buff, & dlen, (unsigned char const   *)((unsigned char *)p_tmp_buff),
                        tmp___5);
    }
#line 1148
    if (rc2 != 0) {
#line 1150
      info->credentials.encoded = 0;
#line 1151
      rc = (RC_TYPE )4;
#line 1152
      goto while_break;
    }
    {
#line 1155
    info->credentials.p_enc_usr_passwd_buffer = p_b64_buff;
#line 1156
    info->credentials.encoded = 1;
#line 1157
    tmp___6 = strlen((char const   *)info->credentials.p_enc_usr_passwd_buffer);
#line 1157
    info->credentials.size = (int )tmp___6;
#line 1159
    free((void *)p_tmp_buff);
#line 1160
    p_tmp_buff = (char *)((void *)0);
#line 1109
    i ++;
    }
#line 1109
    if (! (i < p_self->info_count)) {
#line 1109
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1164
  if (p_tmp_buff) {
    {
#line 1165
    free((void *)p_tmp_buff);
    }
  }
#line 1166
  p_tmp_buff = (char *)((void *)0);
#line 1168
  return (rc);
}
}
#line 1171 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/dyndns.c"
void dyn_dns_print_hello(void) 
{ 


  {
  {
#line 1173
  os_printf(6, (char *)"%s", "Inadyn version 1.99.4 -- Dynamic DNS update client.");
  }
#line 1174
  return;
}
}
#line 1179 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/dyndns.c"
RC_TYPE dyn_dns_construct(DYN_DNS_CLIENT **pp_self ) 
{ 
  RC_TYPE rc ;
  DYN_DNS_CLIENT *p_self ;
  BOOL http_to_dyndns_constructed ;
  BOOL http_to_ip_constructed ;
  int i ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 1183
  http_to_dyndns_constructed = 0;
#line 1184
  http_to_ip_constructed = 0;
#line 1187
  if ((unsigned long )pp_self == (unsigned long )((void *)0)) {
#line 1189
    return ((RC_TYPE )2);
  }
  {
#line 1192
  tmp = malloc(sizeof(DYN_DNS_CLIENT ));
#line 1192
  *pp_self = (DYN_DNS_CLIENT *)tmp;
  }
#line 1193
  if ((unsigned long )*pp_self == (unsigned long )((void *)0)) {
#line 1195
    return ((RC_TYPE )3);
  }
  {
#line 1198
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1200
    p_self = *pp_self;
#line 1201
    memset((void *)p_self, 0, sizeof(DYN_DNS_CLIENT ));
#line 1204
    p_self->work_buffer_size = 2500;
#line 1205
    tmp___0 = malloc((size_t )p_self->work_buffer_size);
#line 1205
    p_self->p_work_buffer = (char *)tmp___0;
    }
#line 1206
    if ((unsigned long )p_self->p_work_buffer == (unsigned long )((void *)0)) {
#line 1208
      rc = (RC_TYPE )3;
#line 1209
      goto while_break;
    }
    {
#line 1213
    p_self->req_buffer_size = 2500;
#line 1214
    tmp___1 = malloc((size_t )p_self->req_buffer_size);
#line 1214
    p_self->p_req_buffer = (char *)tmp___1;
    }
#line 1215
    if ((unsigned long )p_self->p_req_buffer == (unsigned long )((void *)0)) {
#line 1217
      rc = (RC_TYPE )3;
#line 1218
      goto while_break;
    }
#line 1221
    i = 0;
    {
#line 1222
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1222
      if (! (i < 5)) {
#line 1222
        goto while_break___0;
      }
      {
#line 1224
      tmp___2 = i;
#line 1224
      i ++;
#line 1224
      rc = http_client_construct(& p_self->http_to_ip_server[tmp___2]);
      }
#line 1225
      if ((unsigned int )rc != 0U) {
#line 1227
        rc = (RC_TYPE )3;
#line 1228
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1231
    http_to_ip_constructed = 1;
#line 1233
    i = 0;
    {
#line 1234
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1234
      if (! (i < 5)) {
#line 1234
        goto while_break___1;
      }
      {
#line 1236
      tmp___3 = i;
#line 1236
      i ++;
#line 1236
      rc = http_client_construct(& p_self->http_to_dyndns[tmp___3]);
      }
#line 1237
      if ((unsigned int )rc != 0U) {
#line 1239
        rc = (RC_TYPE )3;
#line 1240
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1243
    http_to_dyndns_constructed = 1;
#line 1245
    p_self->cmd = (DYN_DNS_CMD )0;
#line 1246
    p_self->normal_update_period_sec = 120;
#line 1247
    p_self->sleep_sec = 120;
#line 1248
    p_self->total_iterations = 0;
#line 1249
    p_self->initialized = 0;
#line 1251
    i = 0;
    {
#line 1252
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1252
      if (! (i < 5)) {
#line 1252
        goto while_break___2;
      }
#line 1254
      tmp___4 = i;
#line 1254
      i ++;
#line 1254
      p_self->info[tmp___4].credentials.p_enc_usr_passwd_buffer = (char *)((void *)0);
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1198
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1259
  if ((unsigned int )rc != 0U) {
    {
#line 1262
    free((void *)*pp_self);
#line 1264
    free((void *)p_self->p_work_buffer);
#line 1266
    free((void *)p_self->p_work_buffer);
    }
#line 1268
    if (http_to_dyndns_constructed) {
      {
#line 1270
      http_client_destruct(p_self->http_to_dyndns, 5);
      }
    }
#line 1272
    if (http_to_ip_constructed) {
      {
#line 1274
      http_client_destruct(p_self->http_to_ip_server, 5);
      }
    }
  }
#line 1278
  return ((RC_TYPE )0);
}
}
#line 1285 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/dyndns.c"
RC_TYPE dyn_dns_destruct(DYN_DNS_CLIENT *p_self ) 
{ 
  int i ;
  RC_TYPE rc ;
  DYNDNS_INFO_TYPE *info ;

  {
#line 1290
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 1292
    return ((RC_TYPE )0);
  }
#line 1295
  if (p_self->initialized == 1) {
    {
#line 1297
    dyn_dns_shutdown(p_self);
    }
  }
  {
#line 1300
  rc = http_client_destruct(p_self->http_to_ip_server, 5);
#line 1306
  rc = http_client_destruct(p_self->http_to_dyndns, 5);
#line 1312
  free((void *)p_self->p_work_buffer);
#line 1313
  p_self->p_work_buffer = (char *)((void *)0);
#line 1315
  free((void *)p_self->p_req_buffer);
#line 1316
  p_self->p_req_buffer = (char *)((void *)0);
#line 1318
  i = 0;
  }
  {
#line 1319
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1319
    if (! (i < 5)) {
#line 1319
      goto while_break;
    }
    {
#line 1321
    info = & p_self->info[i];
#line 1323
    free((void *)info->credentials.p_enc_usr_passwd_buffer);
#line 1324
    info->credentials.p_enc_usr_passwd_buffer = (char *)((void *)0);
#line 1326
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1329
  free((void *)p_self->cfgfile);
#line 1330
  p_self->cfgfile = (char *)((void *)0);
#line 1332
  free((void *)p_self->pidfile);
#line 1333
  p_self->pidfile = (char *)((void *)0);
#line 1335
  free((void *)p_self->external_command);
#line 1336
  p_self->external_command = (char *)((void *)0);
#line 1338
  free((void *)p_self->bind_interface);
#line 1339
  p_self->bind_interface = (char *)((void *)0);
#line 1341
  free((void *)p_self->check_interface);
#line 1342
  p_self->check_interface = (char *)((void *)0);
#line 1344
  free((void *)p_self->cache_file);
#line 1345
  p_self->cache_file = (char *)((void *)0);
#line 1348
  cached_time_since_last_update = p_self->time_since_last_update;
#line 1349
  cached_num_iterations = p_self->num_iterations;
#line 1351
  free((void *)p_self);
#line 1352
  p_self = (DYN_DNS_CLIENT *)((void *)0);
  }
#line 1354
  return ((RC_TYPE )0);
}
}
#line 1363 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/dyndns.c"
RC_TYPE dyn_dns_init(DYN_DNS_CLIENT *p_self ) 
{ 
  int i ;
  DYNDNS_INFO_TYPE *info ;
  size_t tmp ;

  {
#line 1365
  i = 0;
#line 1367
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 1369
    return ((RC_TYPE )2);
  }
#line 1372
  if (p_self->initialized == 1) {
#line 1374
    return ((RC_TYPE )0);
  }
#line 1377
  p_self->abort_on_network_errors = 0;
#line 1378
  p_self->force_addr_update = 0;
  {
#line 1380
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1382
    info = & p_self->info[i];
#line 1384
    tmp = strlen((char const   *)(info->proxy_server_name.name));
    }
#line 1384
    if (tmp > 0UL) {
      {
#line 1386
      http_client_set_port(& p_self->http_to_ip_server[i], info->proxy_server_name.port);
#line 1387
      http_client_set_remote_name(& p_self->http_to_ip_server[i], (char const   *)(info->proxy_server_name.name));
#line 1389
      http_client_set_port(& p_self->http_to_dyndns[i], info->proxy_server_name.port);
#line 1390
      http_client_set_remote_name(& p_self->http_to_dyndns[i], (char const   *)(info->proxy_server_name.name));
      }
    } else {
      {
#line 1394
      http_client_set_port(& p_self->http_to_ip_server[i], info->ip_server_name.port);
#line 1395
      http_client_set_remote_name(& p_self->http_to_ip_server[i], (char const   *)(info->ip_server_name.name));
#line 1397
      http_client_set_port(& p_self->http_to_dyndns[i], info->dyndns_server_name.port);
#line 1398
      http_client_set_remote_name(& p_self->http_to_dyndns[i], (char const   *)(info->dyndns_server_name.name));
      }
    }
    {
#line 1401
    http_client_set_bind_iface(& p_self->http_to_dyndns[i], p_self->bind_interface);
#line 1402
    http_client_set_bind_iface(& p_self->http_to_ip_server[i], p_self->bind_interface);
#line 1380
    i ++;
    }
#line 1380
    if (! (i < p_self->info_count)) {
#line 1380
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1406
  p_self->cmd = (DYN_DNS_CMD )0;
#line 1407
  if (p_self->cmd_check_period == 0) {
#line 1409
    p_self->cmd_check_period = 1;
  }
#line 1413
  p_self->time_since_last_update = cached_time_since_last_update;
#line 1414
  p_self->num_iterations = cached_num_iterations;
#line 1416
  p_self->initialized = 1;
#line 1418
  return ((RC_TYPE )0);
}
}
#line 1424 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/dyndns.c"
RC_TYPE dyn_dns_shutdown(DYN_DNS_CLIENT *p_self ) 
{ 


  {
#line 1426
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 1428
    return ((RC_TYPE )2);
  }
#line 1431
  if (p_self->initialized == 0) {
#line 1433
    return ((RC_TYPE )0);
  }
#line 1436
  return ((RC_TYPE )0);
}
}
#line 1449 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/dyndns.c"
RC_TYPE dyn_dns_update_ip(DYN_DNS_CLIENT *p_self ) 
{ 
  int servernum ;
  RC_TYPE rc ;

  {
#line 1451
  servernum = 0;
#line 1455
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 1457
    return ((RC_TYPE )2);
  }
  {
#line 1460
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1462
    if (p_self->check_interface) {
      {
#line 1464
      rc = do_ip_check_interface(p_self);
      }
#line 1465
      if ((unsigned int )rc != 0U) {
#line 1467
        goto while_break;
      }
    } else {
      {
#line 1473
      rc = do_ip_server_transaction(p_self, servernum);
      }
#line 1474
      if ((unsigned int )rc != 0U) {
#line 1476
        goto while_break;
      }
#line 1478
      if (p_self->dbg.level > 1) {
        {
#line 1480
        os_printf(7, (char *)"IP server response:");
#line 1481
        os_printf(7, (char *)"%s", p_self->p_work_buffer);
        }
      }
      {
#line 1485
      rc = do_parse_my_ip_address(p_self, servernum);
      }
#line 1486
      if ((unsigned int )rc != 0U) {
#line 1488
        goto while_break;
      }
#line 1491
      if (p_self->dbg.level > 1) {
        {
#line 1493
        os_printf(6, (char *)"Current public IP# %s", p_self->info[servernum].my_ip_address.name);
        }
      }
    }
    {
#line 1497
    rc = do_check_alias_update_table(p_self);
    }
#line 1498
    if ((unsigned int )rc != 0U) {
#line 1500
      goto while_break;
    }
    {
#line 1504
    rc = do_update_alias_table(p_self);
    }
#line 1505
    if ((unsigned int )rc != 0U) {
#line 1507
      goto while_break;
    }
#line 1460
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1512
  return (rc);
}
}
#line 1523 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/dyndns.c"
int dyn_dns_main(DYN_DNS_CLIENT *p_dyndns , int argc , char **argv ) 
{ 
  FILE *fp ;
  RC_TYPE rc ;
  int i ;
  int s ;
  char name[256] ;
  OS_USER_INFO os_usr_info ;
  size_t tmp ;
  DBG_DEST tmp___0 ;
  DBG_DEST tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  __pid_t tmp___4 ;
  struct addrinfo hints ;
  struct addrinfo *result___0 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;

  {
#line 1526
  rc = (RC_TYPE )0;
#line 1530
  if ((unsigned long )p_dyndns == (unsigned long )((void *)0)) {
#line 1532
    return (2);
  }
  {
#line 1536
  mkdir("/var/run/inadyn", (__mode_t )493);
#line 1539
  rc = get_config_data(p_dyndns, argc, argv);
  }
#line 1540
  if ((unsigned int )rc != 0U) {
#line 1542
    return ((int )rc);
  } else
#line 1540
  if (p_dyndns->abort) {
#line 1542
    return ((int )rc);
  }
#line 1545
  if (p_dyndns->change_persona) {
    {
#line 1549
    memset((void *)(& os_usr_info), 0, sizeof(os_usr_info));
#line 1550
    os_usr_info.gid = p_dyndns->sys_usr_info.gid;
#line 1551
    os_usr_info.uid = p_dyndns->sys_usr_info.uid;
#line 1552
    rc = os_change_persona(& os_usr_info);
    }
#line 1553
    if ((unsigned int )rc != 0U) {
#line 1555
      return ((int )rc);
    }
  }
  {
#line 1560
  tmp = strlen((char const   *)(p_dyndns->dbg.p_logfilename));
  }
#line 1560
  if (tmp != 0UL) {
    {
#line 1562
    rc = os_open_dbg_output((DBG_DEST )2, "", (char const   *)(p_dyndns->dbg.p_logfilename));
    }
#line 1563
    if ((unsigned int )rc != 0U) {
#line 1565
      return ((int )rc);
    }
  }
#line 1569
  if (p_dyndns->debug_to_syslog == 1) {
#line 1569
    goto _L;
  } else
#line 1569
  if (p_dyndns->run_in_background == 1) {
    _L: /* CIL Label */ 
    {
#line 1571
    tmp___0 = get_dbg_dest();
    }
#line 1571
    if ((unsigned int )tmp___0 == 0U) {
      {
#line 1573
      rc = os_open_dbg_output((DBG_DEST )1, "inadyn", (char const   *)((void *)0));
      }
#line 1574
      if ((unsigned int )rc != 0U) {
#line 1576
        return ((int )rc);
      }
    }
  }
#line 1582
  if (p_dyndns->run_in_background == 1) {
    {
#line 1584
    rc = close_console_window();
    }
#line 1585
    if ((unsigned int )rc != 0U) {
#line 1587
      return ((int )rc);
    }
    {
#line 1589
    tmp___1 = get_dbg_dest();
    }
#line 1589
    if ((unsigned int )tmp___1 == 1U) {
      {
#line 1591
      fclose(stdout);
      }
    }
  }
  {
#line 1596
  umask((__mode_t )((128 >> 3) | ((128 >> 3) >> 3)));
#line 1599
  fp = fopen((char const   */* __restrict  */)p_dyndns->pidfile, (char const   */* __restrict  */)"w");
  }
#line 1600
  if (! fp) {
    {
#line 1602
    tmp___2 = __errno_location();
#line 1602
    tmp___3 = strerror(*tmp___2);
#line 1602
    os_printf(3, (char *)"Failed opening pidfile %s for writing: %s", p_dyndns->pidfile,
              tmp___3);
    }
#line 1603
    return (1);
  }
  {
#line 1605
  tmp___4 = getpid();
#line 1605
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%u", tmp___4);
#line 1606
  fclose(fp);
#line 1608
  dyn_dns_print_hello();
#line 1615
  fp = fopen((char const   */* __restrict  */)p_dyndns->cache_file, (char const   */* __restrict  */)"r");
  }
#line 1616
  if (! fp) {
    {
#line 1622
    __res_init();
#line 1625
    i = 0;
    }
    {
#line 1625
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1625
      if (! (i < p_dyndns->info_count)) {
#line 1625
        goto while_break;
      }
#line 1627
      if (p_dyndns->info[i].alias_count) {
        {
#line 1627
        tmp___7 = strcmp((p_dyndns->info[i].p_dns_system)->p_key, "ipv6tb@he.net");
        }
#line 1627
        if (tmp___7) {
          {
#line 1632
          memset((void *)(& hints), 0, sizeof(struct addrinfo ));
#line 1633
          hints.ai_family = 2;
#line 1634
          hints.ai_socktype = 2;
#line 1635
          hints.ai_flags = 0;
#line 1636
          hints.ai_protocol = 0;
#line 1638
          s = getaddrinfo((char const   */* __restrict  */)(p_dyndns->info[i].alias_info[0].names.name),
                          (char const   */* __restrict  */)((void *)0), (struct addrinfo  const  */* __restrict  */)(& hints),
                          (struct addrinfo **/* __restrict  */)(& result___0));
          }
#line 1638
          if (s) {
            {
#line 1650
            tmp___6 = gai_strerror(s);
#line 1650
            os_printf(4, (char *)"Failed resolving hostname %s: %s", p_dyndns->info[i].alias_info[0].names.name,
                      tmp___6);
            }
          } else {
            {
#line 1641
            tmp___5 = getnameinfo((struct sockaddr  const  */* __restrict  */)result___0->ai_addr,
                                  result___0->ai_addrlen, (char */* __restrict  */)(name),
                                  (socklen_t )sizeof(name), (char */* __restrict  */)((void *)0),
                                  (socklen_t )0, 1);
            }
#line 1641
            if (! tmp___5) {
              {
#line 1644
              strncpy((char */* __restrict  */)(p_dyndns->info[i].my_ip_address.name),
                      (char const   */* __restrict  */)(name), sizeof(p_dyndns->info[i].my_ip_address.name));
#line 1645
              os_printf(6, (char *)"Resolving hostname %s => IP# %s", p_dyndns->info[i].alias_info[0].names.name,
                        name);
              }
            }
            {
#line 1647
            freeaddrinfo(result___0);
            }
          }
        }
      }
#line 1625
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1657
    tmp___8 = fgets((char */* __restrict  */)(name), (int )sizeof(name), (FILE */* __restrict  */)fp);
    }
#line 1657
    if (tmp___8) {
      {
#line 1659
      os_printf(6, (char *)"Cached IP# %s from previous invocation.", name);
#line 1662
      i = 0;
      }
      {
#line 1662
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1662
        if (! (i < p_dyndns->info_count)) {
#line 1662
          goto while_break___0;
        }
        {
#line 1664
        strncpy((char */* __restrict  */)(p_dyndns->info[i].my_ip_address.name), (char const   */* __restrict  */)(name),
                sizeof(p_dyndns->info[i].my_ip_address.name));
#line 1662
        i ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 1667
    fclose(fp);
    }
  }
  {
#line 1670
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 1672
    rc = dyn_dns_init(p_dyndns);
    }
#line 1673
    if ((unsigned int )rc != 0U) {
#line 1674
      goto while_break___1;
    }
    {
#line 1676
    rc = get_encoded_user_passwd(p_dyndns);
    }
#line 1677
    if ((unsigned int )rc != 0U) {
#line 1678
      goto while_break___1;
    }
#line 1680
    if (p_dyndns->test_update == 1) {
#line 1681
      p_dyndns->force_addr_update = 1;
    }
    {
#line 1684
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 1686
      rc = dyn_dns_update_ip(p_dyndns);
      }
#line 1687
      if ((unsigned int )rc != 0U) {
#line 1689
        if ((unsigned int )p_dyndns->cmd == 2U) {
          {
#line 1691
          os_printf(7, (char *)"RESTART command received. Restarting.");
#line 1692
          rc = (RC_TYPE )255;
          }
#line 1693
          goto while_break___2;
        }
#line 1696
        if ((unsigned int )rc == 72U) {
          {
#line 1698
          os_printf(3, (char *)"Error response from DDNS server, exiting!");
          }
#line 1699
          goto while_break___2;
        }
      } else {
#line 1705
        (p_dyndns->num_iterations) ++;
      }
#line 1709
      if (p_dyndns->total_iterations != 0) {
#line 1709
        if (p_dyndns->num_iterations >= p_dyndns->total_iterations) {
#line 1710
          goto while_break___2;
        }
      }
#line 1712
      if ((unsigned int )rc == 73U) {
#line 1712
        p_dyndns->sleep_sec = p_dyndns->error_update_period_sec;
      } else {
#line 1712
        p_dyndns->sleep_sec = p_dyndns->normal_update_period_sec;
      }
#line 1714
      if ((unsigned int )rc != 0U) {
        {
#line 1719
        os_printf(4, (char *)"Will retry again in %d sec...", p_dyndns->sleep_sec);
        }
      }
      {
#line 1723
      dyn_dns_wait_for_cmd(p_dyndns);
      }
#line 1724
      if ((unsigned int )p_dyndns->cmd == 1U) {
        {
#line 1726
        os_printf(7, (char *)"STOP command received, exiting.");
#line 1727
        rc = (RC_TYPE )0;
        }
#line 1728
        goto while_break___2;
      } else
#line 1730
      if ((unsigned int )p_dyndns->cmd == 2U) {
        {
#line 1732
        os_printf(7, (char *)"RESTART command received, restarting.");
#line 1733
        rc = (RC_TYPE )255;
        }
#line 1734
        goto while_break___2;
      }
#line 1737
      if (p_dyndns->dbg.level > 0) {
        {
#line 1739
        os_printf(7, (char *)".");
        }
      }
#line 1742
      p_dyndns->time_since_last_update += p_dyndns->sleep_sec;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1670
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1748
  if ((unsigned int )rc == 0U) {
    {
#line 1750
    rc = dyn_dns_shutdown(p_dyndns);
    }
  }
#line 1753
  return ((int )rc);
}
}
#line 69 "include/base64.h"
int base64_decode(unsigned char *dst , size_t *dlen , unsigned char const   *src ,
                  size_t slen ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/base64.c"
static unsigned char const   base64_enc_map[64]  = 
#line 28 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/base64.c"
  {      (unsigned char const   )'A',      (unsigned char const   )'B',      (unsigned char const   )'C',      (unsigned char const   )'D', 
        (unsigned char const   )'E',      (unsigned char const   )'F',      (unsigned char const   )'G',      (unsigned char const   )'H', 
        (unsigned char const   )'I',      (unsigned char const   )'J',      (unsigned char const   )'K',      (unsigned char const   )'L', 
        (unsigned char const   )'M',      (unsigned char const   )'N',      (unsigned char const   )'O',      (unsigned char const   )'P', 
        (unsigned char const   )'Q',      (unsigned char const   )'R',      (unsigned char const   )'S',      (unsigned char const   )'T', 
        (unsigned char const   )'U',      (unsigned char const   )'V',      (unsigned char const   )'W',      (unsigned char const   )'X', 
        (unsigned char const   )'Y',      (unsigned char const   )'Z',      (unsigned char const   )'a',      (unsigned char const   )'b', 
        (unsigned char const   )'c',      (unsigned char const   )'d',      (unsigned char const   )'e',      (unsigned char const   )'f', 
        (unsigned char const   )'g',      (unsigned char const   )'h',      (unsigned char const   )'i',      (unsigned char const   )'j', 
        (unsigned char const   )'k',      (unsigned char const   )'l',      (unsigned char const   )'m',      (unsigned char const   )'n', 
        (unsigned char const   )'o',      (unsigned char const   )'p',      (unsigned char const   )'q',      (unsigned char const   )'r', 
        (unsigned char const   )'s',      (unsigned char const   )'t',      (unsigned char const   )'u',      (unsigned char const   )'v', 
        (unsigned char const   )'w',      (unsigned char const   )'x',      (unsigned char const   )'y',      (unsigned char const   )'z', 
        (unsigned char const   )'0',      (unsigned char const   )'1',      (unsigned char const   )'2',      (unsigned char const   )'3', 
        (unsigned char const   )'4',      (unsigned char const   )'5',      (unsigned char const   )'6',      (unsigned char const   )'7', 
        (unsigned char const   )'8',      (unsigned char const   )'9',      (unsigned char const   )'+',      (unsigned char const   )'/'};
#line 39 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/base64.c"
static unsigned char const   base64_dec_map[128]  = 
#line 39
  {      (unsigned char const   )127,      (unsigned char const   )127,      (unsigned char const   )127,      (unsigned char const   )127, 
        (unsigned char const   )127,      (unsigned char const   )127,      (unsigned char const   )127,      (unsigned char const   )127, 
        (unsigned char const   )127,      (unsigned char const   )127,      (unsigned char const   )127,      (unsigned char const   )127, 
        (unsigned char const   )127,      (unsigned char const   )127,      (unsigned char const   )127,      (unsigned char const   )127, 
        (unsigned char const   )127,      (unsigned char const   )127,      (unsigned char const   )127,      (unsigned char const   )127, 
        (unsigned char const   )127,      (unsigned char const   )127,      (unsigned char const   )127,      (unsigned char const   )127, 
        (unsigned char const   )127,      (unsigned char const   )127,      (unsigned char const   )127,      (unsigned char const   )127, 
        (unsigned char const   )127,      (unsigned char const   )127,      (unsigned char const   )127,      (unsigned char const   )127, 
        (unsigned char const   )127,      (unsigned char const   )127,      (unsigned char const   )127,      (unsigned char const   )127, 
        (unsigned char const   )127,      (unsigned char const   )127,      (unsigned char const   )127,      (unsigned char const   )127, 
        (unsigned char const   )127,      (unsigned char const   )127,      (unsigned char const   )127,      (unsigned char const   )62, 
        (unsigned char const   )127,      (unsigned char const   )127,      (unsigned char const   )127,      (unsigned char const   )63, 
        (unsigned char const   )52,      (unsigned char const   )53,      (unsigned char const   )54,      (unsigned char const   )55, 
        (unsigned char const   )56,      (unsigned char const   )57,      (unsigned char const   )58,      (unsigned char const   )59, 
        (unsigned char const   )60,      (unsigned char const   )61,      (unsigned char const   )127,      (unsigned char const   )127, 
        (unsigned char const   )127,      (unsigned char const   )64,      (unsigned char const   )127,      (unsigned char const   )127, 
        (unsigned char const   )127,      (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )2, 
        (unsigned char const   )3,      (unsigned char const   )4,      (unsigned char const   )5,      (unsigned char const   )6, 
        (unsigned char const   )7,      (unsigned char const   )8,      (unsigned char const   )9,      (unsigned char const   )10, 
        (unsigned char const   )11,      (unsigned char const   )12,      (unsigned char const   )13,      (unsigned char const   )14, 
        (unsigned char const   )15,      (unsigned char const   )16,      (unsigned char const   )17,      (unsigned char const   )18, 
        (unsigned char const   )19,      (unsigned char const   )20,      (unsigned char const   )21,      (unsigned char const   )22, 
        (unsigned char const   )23,      (unsigned char const   )24,      (unsigned char const   )25,      (unsigned char const   )127, 
        (unsigned char const   )127,      (unsigned char const   )127,      (unsigned char const   )127,      (unsigned char const   )127, 
        (unsigned char const   )127,      (unsigned char const   )26,      (unsigned char const   )27,      (unsigned char const   )28, 
        (unsigned char const   )29,      (unsigned char const   )30,      (unsigned char const   )31,      (unsigned char const   )32, 
        (unsigned char const   )33,      (unsigned char const   )34,      (unsigned char const   )35,      (unsigned char const   )36, 
        (unsigned char const   )37,      (unsigned char const   )38,      (unsigned char const   )39,      (unsigned char const   )40, 
        (unsigned char const   )41,      (unsigned char const   )42,      (unsigned char const   )43,      (unsigned char const   )44, 
        (unsigned char const   )45,      (unsigned char const   )46,      (unsigned char const   )47,      (unsigned char const   )48, 
        (unsigned char const   )49,      (unsigned char const   )50,      (unsigned char const   )51,      (unsigned char const   )127, 
        (unsigned char const   )127,      (unsigned char const   )127,      (unsigned char const   )127,      (unsigned char const   )127};
#line 59 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/base64.c"
int base64_encode(unsigned char *dst , size_t *dlen , unsigned char const   *src ,
                  size_t slen ) 
{ 
  size_t i ;
  size_t n ;
  int C1 ;
  int C2 ;
  int C3 ;
  unsigned char *p ;
  unsigned char const   *tmp ;
  unsigned char const   *tmp___0 ;
  unsigned char const   *tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char const   *tmp___6 ;
  unsigned char const   *tmp___7 ;
  unsigned char *tmp___8 ;
  unsigned char *tmp___9 ;
  unsigned char *tmp___10 ;
  unsigned char *tmp___11 ;
  unsigned char *tmp___12 ;

  {
#line 66
  if (slen == 0UL) {
#line 67
    return (0);
  }
#line 69
  n = (slen << 3) / 6UL;
  {
#line 73
  if ((slen << 3) - n * 6UL == 2UL) {
#line 73
    goto case_2;
  }
#line 74
  if ((slen << 3) - n * 6UL == 4UL) {
#line 74
    goto case_4;
  }
#line 75
  goto switch_default;
  case_2: /* CIL Label */ 
#line 73
  n += 3UL;
#line 73
  goto switch_break;
  case_4: /* CIL Label */ 
#line 74
  n += 2UL;
#line 74
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 75
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 78
  if (*dlen < n + 1UL) {
#line 80
    *dlen = n + 1UL;
#line 81
    return (-42);
  }
#line 84
  n = (slen / 3UL) * 3UL;
#line 86
  i = (size_t )0;
#line 86
  p = dst;
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
#line 86
    if (! (i < n)) {
#line 86
      goto while_break;
    }
#line 88
    tmp = src;
#line 88
    src ++;
#line 88
    C1 = (int )*tmp;
#line 89
    tmp___0 = src;
#line 89
    src ++;
#line 89
    C2 = (int )*tmp___0;
#line 90
    tmp___1 = src;
#line 90
    src ++;
#line 90
    C3 = (int )*tmp___1;
#line 92
    tmp___2 = p;
#line 92
    p ++;
#line 92
    *tmp___2 = (unsigned char )base64_enc_map[(C1 >> 2) & 63];
#line 93
    tmp___3 = p;
#line 93
    p ++;
#line 93
    *tmp___3 = (unsigned char )base64_enc_map[(((C1 & 3) << 4) + (C2 >> 4)) & 63];
#line 94
    tmp___4 = p;
#line 94
    p ++;
#line 94
    *tmp___4 = (unsigned char )base64_enc_map[(((C2 & 15) << 2) + (C3 >> 6)) & 63];
#line 95
    tmp___5 = p;
#line 95
    p ++;
#line 95
    *tmp___5 = (unsigned char )base64_enc_map[C3 & 63];
#line 86
    i += 3UL;
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  if (i < slen) {
#line 100
    tmp___6 = src;
#line 100
    src ++;
#line 100
    C1 = (int )*tmp___6;
#line 101
    if (i + 1UL < slen) {
#line 101
      tmp___7 = src;
#line 101
      src ++;
#line 101
      C2 = (int )*tmp___7;
    } else {
#line 101
      C2 = 0;
    }
#line 103
    tmp___8 = p;
#line 103
    p ++;
#line 103
    *tmp___8 = (unsigned char )base64_enc_map[(C1 >> 2) & 63];
#line 104
    tmp___9 = p;
#line 104
    p ++;
#line 104
    *tmp___9 = (unsigned char )base64_enc_map[(((C1 & 3) << 4) + (C2 >> 4)) & 63];
#line 106
    if (i + 1UL < slen) {
#line 107
      tmp___10 = p;
#line 107
      p ++;
#line 107
      *tmp___10 = (unsigned char )base64_enc_map[((C2 & 15) << 2) & 63];
    } else {
#line 108
      tmp___11 = p;
#line 108
      p ++;
#line 108
      *tmp___11 = (unsigned char )'=';
    }
#line 110
    tmp___12 = p;
#line 110
    p ++;
#line 110
    *tmp___12 = (unsigned char )'=';
  }
#line 113
  *dlen = (size_t )(p - dst);
#line 114
  *p = (unsigned char)0;
#line 116
  return (0);
}
}
#line 122 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/base64.c"
int base64_decode(unsigned char *dst , size_t *dlen , unsigned char const   *src ,
                  size_t slen ) 
{ 
  size_t i ;
  size_t j ;
  size_t n ;
  unsigned long x ;
  unsigned char *p ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;

  {
#line 129
  n = (size_t )0;
#line 129
  j = n;
#line 129
  i = j;
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
#line 129
    if (! (i < slen)) {
#line 129
      goto while_break;
    }
#line 131
    if (slen - i >= 2UL) {
#line 131
      if ((int const   )*(src + i) == 13) {
#line 131
        if ((int const   )*(src + (i + 1UL)) == 10) {
#line 133
          goto __Cont;
        }
      }
    }
#line 135
    if ((int const   )*(src + i) == 10) {
#line 136
      goto __Cont;
    }
#line 138
    if ((int const   )*(src + i) == 61) {
#line 138
      j ++;
#line 138
      if (j > 2UL) {
#line 139
        return (-44);
      }
    }
#line 141
    if ((int const   )*(src + i) > 127) {
#line 142
      return (-44);
    } else
#line 141
    if ((int const   )base64_dec_map[*(src + i)] == 127) {
#line 142
      return (-44);
    }
#line 144
    if ((int const   )base64_dec_map[*(src + i)] < 64) {
#line 144
      if (j != 0UL) {
#line 145
        return (-44);
      }
    }
#line 147
    n ++;
    __Cont: /* CIL Label */ 
#line 129
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 150
  if (n == 0UL) {
#line 151
    return (0);
  }
#line 153
  n = (n * 6UL + 7UL) >> 3;
#line 155
  if (*dlen < n) {
#line 157
    *dlen = n;
#line 158
    return (-42);
  }
#line 161
  j = (size_t )3;
#line 161
  x = 0UL;
#line 161
  n = x;
#line 161
  p = dst;
  {
#line 161
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 161
    if (! (i > 0UL)) {
#line 161
      goto while_break___0;
    }
#line 163
    if ((int const   )*src == 13) {
#line 164
      goto __Cont___0;
    } else
#line 163
    if ((int const   )*src == 10) {
#line 164
      goto __Cont___0;
    }
#line 166
    j -= (size_t )((int const   )base64_dec_map[*src] == 64);
#line 167
    x = (x << 6) | (unsigned long )((int const   )base64_dec_map[*src] & 63);
#line 169
    n ++;
#line 169
    if (n == 4UL) {
#line 171
      n = (size_t )0;
#line 172
      if (j > 0UL) {
#line 172
        tmp = p;
#line 172
        p ++;
#line 172
        *tmp = (unsigned char )(x >> 16);
      }
#line 173
      if (j > 1UL) {
#line 173
        tmp___0 = p;
#line 173
        p ++;
#line 173
        *tmp___0 = (unsigned char )(x >> 8);
      }
#line 174
      if (j > 2UL) {
#line 174
        tmp___1 = p;
#line 174
        p ++;
#line 174
        *tmp___1 = (unsigned char )x;
      }
    }
    __Cont___0: /* CIL Label */ 
#line 161
    i --;
#line 161
    src ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 178
  *dlen = (size_t )(p - dst);
#line 180
  return (0);
}
}
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 425 "/usr/include/stdio.h"
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...)  __asm__("__isoc99_fscanf")  ;
#line 695
extern int puts(char const   *__s ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 619 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) sysconf)(int __name ) ;
#line 675
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 681
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getgid)(void) ;
#line 149 "/usr/include/pwd.h"
extern int getpwnam_r(char const   * __restrict  __name , struct passwd * __restrict  __resultbuf ,
                      char * __restrict  __buffer , size_t __buflen , struct passwd ** __restrict  __result ) ;
#line 152 "/usr/include/grp.h"
extern int getgrnam_r(char const   * __restrict  __name , struct group * __restrict  __resultbuf ,
                      char * __restrict  __buffer , size_t __buflen , struct group ** __restrict  __result ) ;
#line 416 "include/dyndns.h"
void print_help_page(void) ;
#line 69 "include/get_cmd.h"
RC_TYPE get_cmd_parse_data(char **argv , int argc , CMD_DESCRIPTION_TYPE *p_cmd_descr ) ;
#line 73
RC_TYPE cmd_add_val(CMD_DATA *p_cmd , char *p_val ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/inadyn_cmd.c"
static int curr_info  ;
#line 40
static RC_TYPE help_handler(CMD_DATA *p_cmd , int current_nr , void *p_context ) ;
#line 41
static RC_TYPE test_handler(CMD_DATA *p_cmd , int current_nr , void *p_context ) ;
#line 42
static RC_TYPE get_wildcard_handler(CMD_DATA *p_cmd , int current_nr , void *p_context ) ;
#line 43
static RC_TYPE get_username_handler(CMD_DATA *p_cmd , int current_nr , void *p_context ) ;
#line 44
static RC_TYPE get_password_handler(CMD_DATA *p_cmd , int current_nr , void *p_context ) ;
#line 45
static RC_TYPE get_alias_handler(CMD_DATA *p_cmd , int current_nr , void *p_context ) ;
#line 46
static RC_TYPE get_dns_server_name_handler(CMD_DATA *p_cmd , int current_nr , void *p_context ) ;
#line 47
static RC_TYPE get_dns_server_url_handler(CMD_DATA *p_cmd , int current_nr , void *p_context ) ;
#line 48
static RC_TYPE get_ip_server_name_handler(CMD_DATA *p_cmd , int current_nr , void *p_context ) ;
#line 49
static RC_TYPE get_dyndns_system_handler(CMD_DATA *p_cmd , int current_nr , void *p_context ) ;
#line 50
static RC_TYPE get_update_period_handler(CMD_DATA *p_cmd , int current_nr , void *p_context ) ;
#line 51
static RC_TYPE get_update_period_sec_handler(CMD_DATA *p_cmd , int current_nr , void *p_context ) ;
#line 52
static RC_TYPE get_forced_update_period_handler(CMD_DATA *p_cmd , int current_nr ,
                                                void *p_context ) ;
#line 53
static RC_TYPE get_logfile_name(CMD_DATA *p_cmd , int current_nr , void *p_context ) ;
#line 54
static RC_TYPE set_silent_handler(CMD_DATA *p_cmd , int current_nr , void *p_context ) ;
#line 55
static RC_TYPE set_verbose_handler(CMD_DATA *p_cmd , int current_nr , void *p_context ) ;
#line 56
static RC_TYPE get_proxy_server_handler(CMD_DATA *p_cmd , int current_nr , void *p_context ) ;
#line 57
static RC_TYPE get_options_from_file_handler(CMD_DATA *p_cmd , int current_nr , void *p_context ) ;
#line 58
static RC_TYPE set_iterations_handler(CMD_DATA *p_cmd , int current_nr , void *p_context ) ;
#line 59
static RC_TYPE set_syslog_handler(CMD_DATA *p_cmd , int current_nr , void *p_context ) ;
#line 60
static RC_TYPE set_change_persona_handler(CMD_DATA *p_cmd , int current_nr , void *p_context ) ;
#line 61
static RC_TYPE set_bind_interface(CMD_DATA *p_cmd , int current_nr , void *p_context ) ;
#line 62
static RC_TYPE set_check_interface(CMD_DATA *p_cmd , int current_nr , void *p_context ) ;
#line 63
static RC_TYPE set_pidfile(CMD_DATA *p_cmd , int current_nr , void *p_context ) ;
#line 64
static RC_TYPE set_cachefile(CMD_DATA *p_cmd , int current_nr , void *p_context ) ;
#line 65
static RC_TYPE print_version_handler(CMD_DATA *p_cmd , int current_nr , void *p_context ) ;
#line 66
static RC_TYPE get_exec_handler(CMD_DATA *p_cmd , int current_nr , void *p_context ) ;
#line 68 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/inadyn_cmd.c"
static CMD_DESCRIPTION_TYPE cmd_options_table[64]  = 
#line 68
  {      {(char *)"-a", 1, {& get_alias_handler, (void *)0}, (char *)""}, 
        {(char *)"--alias", 1, {& get_alias_handler, (void *)0}, (char *)"<NAME>\n\t\t\tAlias hostname. This option can appear multiple times."}, 
        {(char *)"-b",
      0, {& set_silent_handler, (void *)0}, (char *)""}, 
        {(char *)"--background", 0, {& set_silent_handler, (void *)0}, (char *)"Run in background."}, 
        {(char *)"-B",
      1, {& set_bind_interface, (void *)0}, (char *)""}, 
        {(char *)"--bind", 1, {& set_bind_interface, (void *)0}, (char *)"<IFNAME>\n\t\t\tSet interface to bind to, only on UNIX systems."}, 
        {(char *)"-c",
      1, {& set_cachefile, (void *)0}, (char *)""}, 
        {(char *)"--cachefile", 1, {& set_cachefile, (void *)0}, (char *)"<FILE>\n\t\t\tSet cachefile, default /var/run/inadyn/inadyn.cache"}, 
        {(char *)"-d",
      1, {& set_change_persona_handler, (void *)0}, (char *)""}, 
        {(char *)"--drop-privs", 1, {& set_change_persona_handler, (void *)0}, (char *)"<USER[:GROUP]>\n\t\t\tAfter init switch to a new user/group.\n\t\t\tOnly on UNIX systems."}, 
        {(char *)"--change_persona",
      1, {& set_change_persona_handler, (void *)0}, (char *)((void *)0)}, 
        {(char *)"-e", 1, {& get_exec_handler, (void *)0}, (char *)""}, 
        {(char *)"--exec", 1, {& get_exec_handler, (void *)0}, (char *)"Full path to external command to run after an IP update."}, 
        {(char *)"-f",
      1, {& get_forced_update_period_handler, (void *)0}, (char *)""}, 
        {(char *)"--forced-update", 1, {& get_forced_update_period_handler, (void *)0},
      (char *)"<SEC>\n\t\t\tForced DDNS server update interval. Default: 1 week"}, 
        {(char *)"--forced_update_period",
      1, {& get_forced_update_period_handler, (void *)0}, (char *)((void *)0)}, 
        {(char *)"-F", 1, {& get_options_from_file_handler, (void *)0}, (char *)""}, 
        {(char *)"--config", 1, {& get_options_from_file_handler, (void *)0}, (char *)"<FILE>\n\t\t\tConfiguration file, containing further options.  Default\n\t\t\tconfig file: /etc/inadyn.conf, is used if inadyn is\n\t\t\tcalled without any command line options."}, 
        {(char *)"--input_file",
      1, {& get_options_from_file_handler, (void *)0}, (char *)((void *)0)}, 
        {(char *)"-H", 2, {& get_ip_server_name_handler, (void *)0}, (char *)""}, 
        {(char *)"--checkip-url", 2, {& get_ip_server_name_handler, (void *)0}, (char *)"<NAME[:PORT] URL>\n\t\t\tLocal IP is detected by parsing the response after\n\t\t\treturned by this server and URL.  The first IP found\n\t\t\tin the HTTP response is considered \'my IP\'.\n\t\t\tDefault value: \'checkip.dyndns.org /\'"}, 
        {(char *)"--ip_server_name",
      2, {& get_ip_server_name_handler, (void *)0}, (char *)((void *)0)}, 
        {(char *)"-n", 1, {& set_iterations_handler, (void *)0}, (char *)""}, 
        {(char *)"--iterations", 1, {& set_iterations_handler, (void *)0}, (char *)"<NUM>\n\t\t\tSet the number of DNS updates. Default: 0 (forever)"}, 
        {(char *)"-i",
      1, {& set_check_interface, (void *)0}, (char *)""}, 
        {(char *)"--iface", 1, {& set_check_interface, (void *)0}, (char *)"<IFNAME>\n\t\t\tSet interface to check for IP, only on UNIX systems.\n\t\t\tExternal IP check is not performed."}, 
        {(char *)"-L",
      1, {& get_logfile_name, (void *)0}, (char *)""}, 
        {(char *)"--logfile", 1, {& get_logfile_name, (void *)0}, (char *)"<FILE>\n\t\t\tFull path to log file"}, 
        {(char *)"--log_file",
      1, {& get_logfile_name, (void *)0}, (char *)((void *)0)}, 
        {(char *)"-N", 1, {& get_dns_server_name_handler, (void *)0}, (char *)""}, 
        {(char *)"--server-name", 1, {& get_dns_server_name_handler, (void *)0}, (char *)"[<NAME>[:port]]\n\t\t\tThe server that receives the update DNS request.\n\t\t\tAllows the use of unknown DNS services that accept HTTP\n\t\t\tupdates.  If no proxy is wanted, then it is enough to\n\t\t\tset the dyndns system.  Default servers will be taken."}, 
        {(char *)"--dyndns_server_name",
      1, {& get_dns_server_name_handler, (void *)0}, (char *)((void *)0)}, 
        {(char *)"-U", 1, {& get_dns_server_url_handler, (void *)0}, (char *)""}, 
        {(char *)"--server-url", 1, {& get_dns_server_url_handler, (void *)0}, (char *)"<URL>\n\t\t\tFull URL relative to DynDNS server root.\n\t\t\tEx: /some_script.php?hostname=\n"}, 
        {(char *)"--dyndns_server_url",
      1, {& get_dns_server_url_handler, (void *)0}, (char *)((void *)0)}, 
        {(char *)"-S", 1, {& get_dyndns_system_handler, (void *)0}, (char *)""}, 
        {(char *)"--system", 1, {& get_dyndns_system_handler, (void *)0}, (char *)"<PROVIDER>\n\t\t\tSelect DDNS service provider, one of the following.\n\t\t\to For dyndns.org:         default@dyndns.org\n\t\t\to For freedns.afraid.org: default@freedns.afraid.org\n\t\t\to For zoneedit.com:       default@zoneedit.com\n\t\t\to For no-ip.com:          default@no-ip.com\n\t\t\to For easydns.com:        default@easydns.com\n\t\t\to For tzo.com:            default@tzo.com\n\t\t\to For 3322.org:           dyndns@3322.org\n\t\t\to For dnsomatic.com:      default@dnsomatic.com\n\t\t\to For tunnelbroker.net:   ipv6tb@he.net\n\t\t\to For dns.he.net:         dyndns@he.net\n\t\t\to For dynsip.org:         default@dynsip.org\n\t\t\to For sitelutions.com:    default@sitelutions.com\n\t\t\to For dnsexit.com:   \t  default@dnsexit.com\n\t\t\to For generic:            custom@http_svr_basic_auth\n\n\t\t\tDefault value:            default@dyndns.org"}, 
        {(char *)"--dyndns_system",
      1, {& get_dyndns_system_handler, (void *)0}, (char *)((void *)0)}, 
        {(char *)"-x", 1, {& get_proxy_server_handler, (void *)0}, (char *)""}, 
        {(char *)"--proxy-server", 1, {& get_proxy_server_handler, (void *)0}, (char *)"[NAME[:port]]\n\t\t\tHTTP proxy server name, and optional port. Default: N/A"}, 
        {(char *)"--proxy_server",
      1, {& get_proxy_server_handler, (void *)0}, (char *)((void *)0)}, 
        {(char *)"-T", 1, {& get_update_period_sec_handler, (void *)0}, (char *)""}, 
        {(char *)"--period", 1, {& get_update_period_sec_handler, (void *)0}, (char *)"<SEC>\n\t\t\tIP change check interval.  Default: 2 min. Max: 10 days"}, 
        {(char *)"--update_period_sec",
      1, {& get_update_period_sec_handler, (void *)0}, (char *)((void *)0)}, 
        {(char *)"--update_period", 1, {& get_update_period_handler, (void *)0}, (char *)((void *)0)}, 
        {(char *)"-P",
      1, {& set_pidfile, (void *)0}, (char *)""}, 
        {(char *)"--pidfile", 1, {& set_pidfile, (void *)0}, (char *)"<FILE>\n\t\t\tSet pidfile, default /var/run/inadyn/inadyn.pid"}, 
        {(char *)"-s",
      0, {& set_syslog_handler, (void *)0}, (char *)""}, 
        {(char *)"--syslog", 0, {& set_syslog_handler, (void *)0}, (char *)"Force logging to syslog, e.g., /var/log/messages, only on UNIX systems"}, 
        {(char *)"-t",
      0, {& test_handler, (void *)0}, (char *)""}, 
        {(char *)"--test", 0, {& test_handler, (void *)0}, (char *)"Force one update and quit."}, 
        {(char *)"-u",
      1, {& get_username_handler, (void *)0}, (char *)""}, 
        {(char *)"--username", 1, {& get_username_handler, (void *)0}, (char *)"<USERNAME>\n\t\t\tYour DDNS user name, or hash"}, 
        {(char *)"-p",
      1, {& get_password_handler, (void *)0}, (char *)""}, 
        {(char *)"--password", 1, {& get_password_handler, (void *)0}, (char *)"<PASSWORD>\n\t\t\tYour DDNS user password."}, 
        {(char *)"-w",
      0, {& get_wildcard_handler, (void *)0}, (char *)""}, 
        {(char *)"--wildcard", 0, {& get_wildcard_handler, (void *)0}, (char *)"Enable domain wildcarding for easydns.com."}, 
        {(char *)"-h",
      0, {& help_handler, (void *)0}, (char *)""}, 
        {(char *)"--help", 0, {& help_handler, (void *)0}, (char *)"This online help."}, 
        {(char *)"-V",
      1, {& set_verbose_handler, (void *)0}, (char *)""}, 
        {(char *)"--verbose", 1, {& set_verbose_handler, (void *)0}, (char *)"Debug level: 0 - 5"}, 
        {(char *)"-v",
      0, {& print_version_handler, (void *)0}, (char *)""}, 
        {(char *)"--version", 0, {& print_version_handler, (void *)0}, (char *)"Show inadyn version"}, 
        {(char *)((void *)0),
      0, {(RC_TYPE (*)(CMD_DATA *p_cmd , int current_nr , void *p_context ))0, (void *)0},
      (char *)((void *)0)}};
#line 208 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/inadyn_cmd.c"
void print_help_page(void) 
{ 
  CMD_DESCRIPTION_TYPE *it ;
  size_t tmp ;

  {
  {
#line 212
  puts("Inadyn is a dynamic DNS (DDNS) client.  It does periodic and/or on-demand checks\nof your externally visible IP address and updates the hostname to IP mapping at\nyour DDNS service provider when necessary.\n");
#line 215
  puts("dyndns.org:\n\tinadyn -u username -p password -a my.registrated.name\n");
#line 218
  it = cmd_options_table;
  }
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;
#line 219
    if (! ((unsigned long )it->p_option != (unsigned long )((void *)0))) {
#line 219
      goto while_break;
    }
#line 221
    if (it->p_description) {
      {
#line 223
      tmp = strlen((char const   *)it->p_option);
      }
#line 223
      if (tmp == 2UL) {
        {
#line 224
        printf((char const   */* __restrict  */)"  %s, ", it->p_option);
        }
      } else {
        {
#line 226
        printf((char const   */* __restrict  */)"%-16s  %s\n", it->p_option, it->p_description);
        }
      }
    }
#line 228
    it ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 230
  return;
}
}
#line 232 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/inadyn_cmd.c"
static RC_TYPE help_handler(CMD_DATA *p_cmd , int current_nr , void *p_context ) 
{ 
  DYN_DNS_CLIENT *p_self ;

  {
#line 234
  p_self = (DYN_DNS_CLIENT *)p_context;
#line 239
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 240
    return ((RC_TYPE )2);
  }
  {
#line 242
  p_self->abort = 1;
#line 243
  print_help_page();
  }
#line 245
  return ((RC_TYPE )0);
}
}
#line 248 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/inadyn_cmd.c"
static RC_TYPE test_handler(CMD_DATA *p_cmd , int current_nr , void *p_context ) 
{ 
  DYN_DNS_CLIENT *p_self ;

  {
#line 250
  p_self = (DYN_DNS_CLIENT *)p_context;
#line 255
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 256
    return ((RC_TYPE )2);
  }
#line 258
  p_self->test_update = 1;
#line 259
  p_self->total_iterations = 1;
#line 260
  p_self->dbg.level = 5;
#line 262
  return ((RC_TYPE )0);
}
}
#line 265 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/inadyn_cmd.c"
static RC_TYPE get_wildcard_handler(CMD_DATA *p_cmd , int current_nr , void *p_context ) 
{ 
  DYN_DNS_CLIENT *p_self ;

  {
#line 267
  p_self = (DYN_DNS_CLIENT *)p_context;
#line 272
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 273
    return ((RC_TYPE )2);
  }
#line 275
  p_self->info[curr_info].wildcard = 1;
#line 277
  return ((RC_TYPE )0);
}
}
#line 280 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/inadyn_cmd.c"
static RC_TYPE set_verbose_handler(CMD_DATA *p_cmd , int current_nr , void *p_context ) 
{ 
  DYN_DNS_CLIENT *p_self ;
  int tmp ;

  {
#line 282
  p_self = (DYN_DNS_CLIENT *)p_context;
#line 284
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 285
    return ((RC_TYPE )2);
  }
  {
#line 287
  tmp = sscanf((char const   */* __restrict  */)*(p_cmd->argv + current_nr), (char const   */* __restrict  */)"%d",
               & p_self->dbg.level);
  }
#line 287
  if (tmp != 1) {
#line 288
    return ((RC_TYPE )68);
  }
#line 290
  return ((RC_TYPE )0);
}
}
#line 293 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/inadyn_cmd.c"
static RC_TYPE set_iterations_handler(CMD_DATA *p_cmd , int current_nr , void *p_context ) 
{ 
  DYN_DNS_CLIENT *p_self ;
  int tmp ;

  {
#line 295
  p_self = (DYN_DNS_CLIENT *)p_context;
#line 297
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 298
    return ((RC_TYPE )2);
  }
  {
#line 300
  tmp = sscanf((char const   */* __restrict  */)*(p_cmd->argv + current_nr), (char const   */* __restrict  */)"%d",
               & p_self->total_iterations);
  }
#line 300
  if (tmp != 1) {
#line 301
    return ((RC_TYPE )68);
  }
#line 303
  if (p_self->sleep_sec < 0) {
#line 303
    p_self->total_iterations = 0;
  } else {
#line 303
    p_self->total_iterations = p_self->total_iterations;
  }
#line 307
  return ((RC_TYPE )0);
}
}
#line 310 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/inadyn_cmd.c"
static RC_TYPE set_silent_handler(CMD_DATA *p_cmd , int current_nr , void *p_context ) 
{ 
  DYN_DNS_CLIENT *p_self ;

  {
#line 312
  p_self = (DYN_DNS_CLIENT *)p_context;
#line 317
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 318
    return ((RC_TYPE )2);
  }
#line 320
  p_self->run_in_background = 1;
#line 322
  return ((RC_TYPE )0);
}
}
#line 325 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/inadyn_cmd.c"
static RC_TYPE get_logfile_name(CMD_DATA *p_cmd , int current_nr , void *p_context ) 
{ 
  DYN_DNS_CLIENT *p_self ;
  size_t tmp ;

  {
#line 327
  p_self = (DYN_DNS_CLIENT *)p_context;
#line 329
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 330
    return ((RC_TYPE )2);
  }
  {
#line 332
  tmp = strlen((char const   *)*(p_cmd->argv + current_nr));
  }
#line 332
  if (sizeof(p_self->dbg.p_logfilename) < tmp) {
#line 333
    return ((RC_TYPE )64);
  }
  {
#line 335
  strcpy((char */* __restrict  */)(p_self->dbg.p_logfilename), (char const   */* __restrict  */)*(p_cmd->argv + current_nr));
  }
#line 337
  return ((RC_TYPE )0);
}
}
#line 340 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/inadyn_cmd.c"
static RC_TYPE get_username_handler(CMD_DATA *p_cmd , int current_nr , void *p_context ) 
{ 
  DYN_DNS_CLIENT *p_self ;
  size_t tmp ;

  {
#line 342
  p_self = (DYN_DNS_CLIENT *)p_context;
#line 344
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 345
    return ((RC_TYPE )2);
  }
  {
#line 347
  tmp = strlen((char const   *)*(p_cmd->argv + current_nr));
  }
#line 347
  if (sizeof(p_self->info[curr_info].credentials.my_username) < tmp) {
#line 348
    return ((RC_TYPE )64);
  }
  {
#line 350
  strcpy((char */* __restrict  */)(p_self->info[curr_info].credentials.my_username),
         (char const   */* __restrict  */)*(p_cmd->argv + current_nr));
  }
#line 352
  return ((RC_TYPE )0);
}
}
#line 355 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/inadyn_cmd.c"
static RC_TYPE get_password_handler(CMD_DATA *p_cmd , int current_nr , void *p_context ) 
{ 
  DYN_DNS_CLIENT *p_self ;
  size_t tmp ;

  {
#line 357
  p_self = (DYN_DNS_CLIENT *)p_context;
#line 359
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 360
    return ((RC_TYPE )2);
  }
  {
#line 362
  tmp = strlen((char const   *)*(p_cmd->argv + current_nr));
  }
#line 362
  if (sizeof(p_self->info[curr_info].credentials.my_password) < tmp) {
#line 363
    return ((RC_TYPE )64);
  }
  {
#line 365
  strcpy((char */* __restrict  */)(p_self->info[curr_info].credentials.my_password),
         (char const   */* __restrict  */)*(p_cmd->argv + current_nr));
  }
#line 367
  return ((RC_TYPE )0);
}
}
#line 370 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/inadyn_cmd.c"
static RC_TYPE get_alias_handler(CMD_DATA *p_cmd , int current_nr , void *p_context ) 
{ 
  DYN_DNS_CLIENT *p_self ;
  size_t tmp ;

  {
#line 372
  p_self = (DYN_DNS_CLIENT *)p_context;
#line 374
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 375
    return ((RC_TYPE )2);
  }
#line 377
  if (p_self->info[curr_info].alias_count >= 10) {
#line 378
    return ((RC_TYPE )67);
  }
  {
#line 380
  tmp = strlen((char const   *)*(p_cmd->argv + current_nr));
  }
#line 380
  if (sizeof(p_self->info[curr_info].alias_info[p_self->info[curr_info].alias_count].names) < tmp) {
#line 381
    return ((RC_TYPE )64);
  }
  {
#line 383
  strcpy((char */* __restrict  */)(p_self->info[curr_info].alias_info[p_self->info[curr_info].alias_count].names.name),
         (char const   */* __restrict  */)*(p_cmd->argv + current_nr));
#line 384
  (p_self->info[curr_info].alias_count) ++;
  }
#line 386
  return ((RC_TYPE )0);
}
}
#line 389 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/inadyn_cmd.c"
static RC_TYPE get_name_and_port(char *p_src , char *p_dest_name , int *p_dest_port ) 
{ 
  char const   *p_port ;
  char *tmp ;
  int port_nr ;
  int len ;
  int port_ok ;
  int tmp___0 ;

  {
  {
#line 391
  tmp = strstr((char const   *)p_src, ":");
#line 391
  p_port = (char const   *)tmp;
  }
#line 393
  if (p_port) {
    {
#line 396
    tmp___0 = sscanf((char const   */* __restrict  */)(p_port + 1), (char const   */* __restrict  */)"%d",
                     & port_nr);
#line 396
    port_ok = tmp___0;
    }
#line 398
    if (port_ok != 1) {
#line 399
      return ((RC_TYPE )68);
    }
    {
#line 401
    *p_dest_port = port_nr;
#line 402
    len = (int )(p_port - (char const   *)p_src);
#line 403
    memcpy((void */* __restrict  */)p_dest_name, (void const   */* __restrict  */)p_src,
           (size_t )len);
#line 404
    *(p_dest_name + len) = (char)0;
    }
  } else {
    {
#line 408
    strcpy((char */* __restrict  */)p_dest_name, (char const   */* __restrict  */)p_src);
    }
  }
#line 411
  return ((RC_TYPE )0);
}
}
#line 417 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/inadyn_cmd.c"
static RC_TYPE get_ip_server_name_handler(CMD_DATA *p_cmd , int current_nr , void *p_context ) 
{ 
  DYN_DNS_CLIENT *p_self ;
  RC_TYPE rc ;
  int port ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 419
  p_self = (DYN_DNS_CLIENT *)p_context;
#line 421
  port = -1;
#line 423
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 424
    return ((RC_TYPE )2);
  }
  {
#line 427
  tmp = strlen((char const   *)*(p_cmd->argv + current_nr));
  }
#line 427
  if (sizeof(p_self->info[curr_info].ip_server_name) < tmp + 1UL) {
#line 428
    return ((RC_TYPE )64);
  }
  {
#line 430
  p_self->info[curr_info].ip_server_name.port = 80;
#line 431
  rc = get_name_and_port(*(p_cmd->argv + current_nr), p_self->info[curr_info].ip_server_name.name,
                         & port);
  }
#line 432
  if ((unsigned int )rc == 0U) {
#line 432
    if (port != -1) {
#line 433
      p_self->info[curr_info].ip_server_name.port = port;
    }
  }
  {
#line 435
  tmp___0 = strlen((char const   *)*(p_cmd->argv + (current_nr + 1)));
  }
#line 435
  if (sizeof(p_self->info[curr_info].ip_server_url) < tmp___0 + 1UL) {
#line 436
    return ((RC_TYPE )64);
  }
  {
#line 438
  strcpy((char */* __restrict  */)(p_self->info[curr_info].ip_server_url), (char const   */* __restrict  */)*(p_cmd->argv + (current_nr + 1)));
  }
#line 440
  return (rc);
}
}
#line 443 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/inadyn_cmd.c"
static RC_TYPE get_dns_server_name_handler(CMD_DATA *p_cmd , int current_nr , void *p_context ) 
{ 
  DYN_DNS_CLIENT *p_self ;
  RC_TYPE rc ;
  int port ;
  size_t tmp ;

  {
#line 445
  p_self = (DYN_DNS_CLIENT *)p_context;
#line 447
  port = -1;
#line 449
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 450
    return ((RC_TYPE )2);
  }
  {
#line 452
  tmp = strlen((char const   *)*(p_cmd->argv + current_nr));
  }
#line 452
  if (sizeof(p_self->info[curr_info].dyndns_server_name) < tmp) {
#line 453
    return ((RC_TYPE )64);
  }
  {
#line 455
  p_self->info[curr_info].dyndns_server_name.port = 80;
#line 456
  rc = get_name_and_port(*(p_cmd->argv + current_nr), p_self->info[curr_info].dyndns_server_name.name,
                         & port);
  }
#line 457
  if ((unsigned int )rc == 0U) {
#line 457
    if (port != -1) {
#line 458
      p_self->info[curr_info].dyndns_server_name.port = port;
    }
  }
#line 460
  return (rc);
}
}
#line 463 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/inadyn_cmd.c"
static RC_TYPE get_dns_server_url_handler(CMD_DATA *p_cmd , int current_nr , void *p_context ) 
{ 
  DYN_DNS_CLIENT *p_self ;
  size_t tmp ;

  {
#line 465
  p_self = (DYN_DNS_CLIENT *)p_context;
#line 467
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 468
    return ((RC_TYPE )2);
  }
  {
#line 470
  tmp = strlen((char const   *)*(p_cmd->argv + current_nr));
  }
#line 470
  if (sizeof(p_self->info[curr_info].dyndns_server_url) < tmp) {
#line 471
    return ((RC_TYPE )64);
  }
  {
#line 473
  strcpy((char */* __restrict  */)(p_self->info[curr_info].dyndns_server_url), (char const   */* __restrict  */)*(p_cmd->argv + current_nr));
  }
#line 475
  return ((RC_TYPE )0);
}
}
#line 480 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/inadyn_cmd.c"
static RC_TYPE get_proxy_server_handler(CMD_DATA *p_cmd , int current_nr , void *p_context ) 
{ 
  DYN_DNS_CLIENT *p_self ;
  RC_TYPE rc ;
  int port ;
  size_t tmp ;

  {
#line 482
  p_self = (DYN_DNS_CLIENT *)p_context;
#line 484
  port = -1;
#line 486
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 487
    return ((RC_TYPE )2);
  }
  {
#line 489
  tmp = strlen((char const   *)*(p_cmd->argv + current_nr));
  }
#line 489
  if (sizeof(p_self->info[curr_info].proxy_server_name) < tmp) {
#line 490
    return ((RC_TYPE )64);
  }
  {
#line 492
  p_self->info[curr_info].proxy_server_name.port = 80;
#line 493
  rc = get_name_and_port(*(p_cmd->argv + current_nr), p_self->info[curr_info].proxy_server_name.name,
                         & port);
  }
#line 494
  if ((unsigned int )rc == 0U) {
#line 494
    if (port != -1) {
#line 495
      p_self->info[curr_info].proxy_server_name.port = port;
    }
  }
#line 497
  return (rc);
}
}
#line 502 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/inadyn_cmd.c"
static RC_TYPE get_update_period_handler(CMD_DATA *p_cmd , int current_nr , void *p_context ) 
{ 
  DYN_DNS_CLIENT *p_self ;
  int tmp ;

  {
#line 504
  p_self = (DYN_DNS_CLIENT *)p_context;
#line 506
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 507
    return ((RC_TYPE )2);
  }
  {
#line 509
  tmp = sscanf((char const   */* __restrict  */)*(p_cmd->argv + current_nr), (char const   */* __restrict  */)"%d",
               & p_self->sleep_sec);
  }
#line 509
  if (tmp != 1) {
#line 510
    return ((RC_TYPE )68);
  }
#line 512
  p_self->sleep_sec /= 1000;
#line 513
  if (p_self->sleep_sec < 30) {
#line 513
    p_self->sleep_sec = 30;
  } else {
#line 513
    p_self->sleep_sec = p_self->sleep_sec;
  }
#line 514
  if (p_self->sleep_sec > 864000) {
#line 514
    p_self->sleep_sec = 864000;
  }
#line 516
  return ((RC_TYPE )0);
}
}
#line 519 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/inadyn_cmd.c"
static RC_TYPE get_update_period_sec_handler(CMD_DATA *p_cmd , int current_nr , void *p_context ) 
{ 
  DYN_DNS_CLIENT *p_self ;
  int tmp ;

  {
#line 521
  p_self = (DYN_DNS_CLIENT *)p_context;
#line 523
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 524
    return ((RC_TYPE )2);
  }
  {
#line 526
  tmp = sscanf((char const   */* __restrict  */)*(p_cmd->argv + current_nr), (char const   */* __restrict  */)"%d",
               & p_self->normal_update_period_sec);
  }
#line 526
  if (tmp != 1) {
#line 527
    return ((RC_TYPE )68);
  }
#line 529
  if (p_self->normal_update_period_sec < 30) {
#line 529
    p_self->normal_update_period_sec = 30;
  } else {
#line 529
    p_self->normal_update_period_sec = p_self->normal_update_period_sec;
  }
#line 530
  if (p_self->normal_update_period_sec > 864000) {
#line 530
    p_self->normal_update_period_sec = 864000;
  }
#line 532
  return ((RC_TYPE )0);
}
}
#line 535 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/inadyn_cmd.c"
static RC_TYPE get_forced_update_period_handler(CMD_DATA *p_cmd , int current_nr ,
                                                void *p_context ) 
{ 
  DYN_DNS_CLIENT *p_self ;
  int tmp ;

  {
#line 537
  p_self = (DYN_DNS_CLIENT *)p_context;
#line 539
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 540
    return ((RC_TYPE )2);
  }
  {
#line 542
  tmp = sscanf((char const   */* __restrict  */)*(p_cmd->argv + current_nr), (char const   */* __restrict  */)"%d",
               & p_self->forced_update_period_sec);
  }
#line 542
  if (tmp != 1) {
#line 543
    return ((RC_TYPE )68);
  }
#line 545
  return ((RC_TYPE )0);
}
}
#line 548 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/inadyn_cmd.c"
static RC_TYPE set_syslog_handler(CMD_DATA *p_cmd , int current_nr , void *p_context ) 
{ 
  DYN_DNS_CLIENT *p_self ;

  {
#line 550
  p_self = (DYN_DNS_CLIENT *)p_context;
#line 555
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 556
    return ((RC_TYPE )2);
  }
#line 558
  p_self->debug_to_syslog = 1;
#line 560
  return ((RC_TYPE )0);
}
}
#line 567 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/inadyn_cmd.c"
static RC_TYPE set_change_persona_handler(CMD_DATA *p_cmd , int current_nr , void *p_context ) 
{ 
  int s ;
  int result___0 ;
  char *arg ;
  char *buf ;
  char *p_gid ;
  ssize_t bufsize ;
  gid_t gid ;
  uid_t uid ;
  struct passwd pwd ;
  struct passwd *pwd_res ;
  long login_len_max ;
  DYN_DNS_CLIENT *p_self ;
  char groupname[33] ;
  unsigned int tmp ;
  char *username ;
  unsigned long __lengthofusername ;
  void *tmp___0 ;
  char fmt[65] ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  struct group grp ;
  struct group *grp_res ;
  void *tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  __gid_t tmp___7 ;

  {
#line 569
  result___0 = 0;
#line 576
  p_self = (DYN_DNS_CLIENT *)p_context;
#line 578
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 579
    return ((RC_TYPE )2);
  }
  {
#line 582
  login_len_max = sysconf(71);
  }
#line 583
  if (login_len_max <= 0L) {
#line 584
    login_len_max = 32L;
  }
#line 586
  arg = *(p_cmd->argv + current_nr);
#line 588
  groupname[0] = (char )'\000';
#line 588
  tmp = 1U;
  {
#line 588
  while (1) {
    while_continue: /* CIL Label */ ;
#line 588
    if (tmp >= 33U) {
#line 588
      goto while_break;
    }
#line 588
    groupname[tmp] = (char)0;
#line 588
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 589
  __lengthofusername = (unsigned long )(login_len_max + 1L);
#line 589
  tmp___0 = __builtin_alloca(sizeof(*username) * __lengthofusername);
#line 589
  username = (char *)tmp___0;
#line 592
  uid = getuid();
#line 593
  gid = getgid();
#line 595
  p_gid = strstr((char const   *)arg, ":");
  }
#line 596
  if (p_gid) {
    {
#line 598
    tmp___1 = strlen((char const   *)(p_gid + 1));
    }
#line 598
    if (tmp___1 > 0UL) {
      {
#line 598
      tmp___2 = sscanf((char const   */* __restrict  */)(p_gid + 1), (char const   */* __restrict  */)"%32[a-zA-Z-]",
                       groupname);
      }
#line 598
      if (tmp___2 != 1) {
#line 600
        return ((RC_TYPE )68);
      }
    }
  }
  {
#line 603
  snprintf((char */* __restrict  */)(fmt), sizeof(fmt), (char const   */* __restrict  */)"%%%ld[a-zA-Z-]",
           login_len_max);
#line 604
  tmp___3 = sscanf((char const   */* __restrict  */)arg, (char const   */* __restrict  */)(fmt),
                   username);
  }
#line 604
  if (tmp___3 != 1) {
#line 605
    return ((RC_TYPE )68);
  }
  {
#line 608
  tmp___5 = strlen((char const   *)(groupname));
  }
#line 608
  if (tmp___5 > 0UL) {
    {
#line 613
    bufsize = sysconf(69);
    }
#line 614
    if (bufsize == -1L) {
#line 615
      bufsize = (ssize_t )16384;
    }
    {
#line 617
    tmp___4 = malloc((size_t )bufsize);
#line 617
    buf = (char *)tmp___4;
    }
#line 618
    if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 619
      return ((RC_TYPE )3);
    }
    {
#line 621
    s = getgrnam_r((char const   */* __restrict  */)(groupname), (struct group */* __restrict  */)(& grp),
                   (char */* __restrict  */)buf, (size_t )bufsize, (struct group **/* __restrict  */)(& grp_res));
    }
#line 622
    if ((unsigned long )grp_res != (unsigned long )((void *)0)) {
#line 624
      gid = grp.gr_gid;
    } else
#line 628
    if (s == 0) {
      {
#line 630
      os_printf(3, (char *)"Cannot find GROUP %s", groupname);
#line 631
      result___0 = 101;
      }
    } else {
#line 635
      result___0 = 1;
    }
    {
#line 638
    free((void *)buf);
    }
#line 640
    if (0 != result___0) {
#line 641
      return ((RC_TYPE )result___0);
    }
  }
  {
#line 644
  bufsize = sysconf(70);
  }
#line 645
  if (bufsize == -1L) {
#line 646
    bufsize = (ssize_t )16384;
  }
  {
#line 648
  tmp___6 = malloc((size_t )bufsize);
#line 648
  buf = (char *)tmp___6;
  }
#line 649
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 650
    return ((RC_TYPE )3);
  }
  {
#line 652
  s = getpwnam_r((char const   */* __restrict  */)username, (struct passwd */* __restrict  */)(& pwd),
                 (char */* __restrict  */)buf, (size_t )bufsize, (struct passwd **/* __restrict  */)(& pwd_res));
  }
#line 653
  if ((unsigned long )pwd_res != (unsigned long )((void *)0)) {
    {
#line 655
    uid = pwd.pw_uid;
#line 656
    tmp___7 = getgid();
    }
#line 656
    if (gid == tmp___7) {
#line 657
      gid = pwd.pw_gid;
    }
  } else
#line 661
  if (s == 0) {
    {
#line 663
    os_printf(3, (char *)"Cannot find USER %s", username);
#line 664
    result___0 = 100;
    }
  } else {
#line 668
    result___0 = 1;
  }
  {
#line 671
  free((void *)buf);
  }
#line 673
  if (0 != result___0) {
#line 674
    return ((RC_TYPE )result___0);
  }
#line 676
  p_self->change_persona = 1;
#line 677
  p_self->sys_usr_info.gid = gid;
#line 678
  p_self->sys_usr_info.uid = uid;
#line 681
  return ((RC_TYPE )0);
}
}
#line 684 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/inadyn_cmd.c"
static RC_TYPE set_bind_interface(CMD_DATA *p_cmd , int current_nr , void *p_context ) 
{ 
  DYN_DNS_CLIENT *p_self ;

  {
#line 686
  p_self = (DYN_DNS_CLIENT *)p_context;
#line 688
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 689
    return ((RC_TYPE )2);
  }
  {
#line 691
  p_self->bind_interface = strdup((char const   *)*(p_cmd->argv + current_nr));
  }
#line 693
  return ((RC_TYPE )0);
}
}
#line 696 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/inadyn_cmd.c"
static RC_TYPE set_check_interface(CMD_DATA *p_cmd , int current_nr , void *p_context ) 
{ 
  DYN_DNS_CLIENT *p_self ;

  {
#line 698
  p_self = (DYN_DNS_CLIENT *)p_context;
#line 700
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 701
    return ((RC_TYPE )2);
  }
  {
#line 703
  p_self->check_interface = strdup((char const   *)*(p_cmd->argv + current_nr));
  }
#line 705
  return ((RC_TYPE )0);
}
}
#line 708 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/inadyn_cmd.c"
static RC_TYPE set_pidfile(CMD_DATA *p_cmd , int current_nr , void *p_context ) 
{ 
  DYN_DNS_CLIENT *p_self ;

  {
#line 710
  p_self = (DYN_DNS_CLIENT *)p_context;
#line 712
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 713
    return ((RC_TYPE )2);
  }
  {
#line 715
  p_self->pidfile = strdup((char const   *)*(p_cmd->argv + current_nr));
  }
#line 717
  return ((RC_TYPE )0);
}
}
#line 720 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/inadyn_cmd.c"
static RC_TYPE set_cachefile(CMD_DATA *p_cmd , int current_nr , void *p_context ) 
{ 
  DYN_DNS_CLIENT *p_self ;

  {
#line 722
  p_self = (DYN_DNS_CLIENT *)p_context;
#line 724
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 725
    return ((RC_TYPE )2);
  }
  {
#line 727
  p_self->cache_file = strdup((char const   *)*(p_cmd->argv + current_nr));
  }
#line 729
  return ((RC_TYPE )0);
}
}
#line 732 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/inadyn_cmd.c"
static RC_TYPE print_version_handler(CMD_DATA *p_cmd , int current_nr , void *p_context ) 
{ 
  DYN_DNS_CLIENT *p_self ;

  {
#line 734
  p_self = (DYN_DNS_CLIENT *)p_context;
#line 739
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 740
    return ((RC_TYPE )2);
  }
  {
#line 742
  printf((char const   */* __restrict  */)"%s\n", "Inadyn version 1.99.4 -- Dynamic DNS update client.");
#line 743
  p_self->abort = 1;
  }
#line 745
  return ((RC_TYPE )0);
}
}
#line 748 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/inadyn_cmd.c"
static RC_TYPE get_exec_handler(CMD_DATA *p_cmd , int current_nr , void *p_context ) 
{ 
  DYN_DNS_CLIENT *p_self ;

  {
#line 750
  p_self = (DYN_DNS_CLIENT *)p_context;
#line 755
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 756
    return ((RC_TYPE )2);
  }
  {
#line 758
  p_self->external_command = strdup((char const   *)*(p_cmd->argv + current_nr));
  }
#line 760
  return ((RC_TYPE )0);
}
}
#line 770 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/inadyn_cmd.c"
static RC_TYPE get_dyndns_system_handler(CMD_DATA *p_cmd , int current_nr , void *p_context ) 
{ 
  DYNDNS_SYSTEM *p_dns_system ;
  DYN_DNS_CLIENT *p_self ;
  DYNDNS_SYSTEM_INFO *it ;
  int tmp ;

  {
#line 772
  p_dns_system = (DYNDNS_SYSTEM *)((void *)0);
#line 773
  p_self = (DYN_DNS_CLIENT *)p_context;
#line 776
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 777
    return ((RC_TYPE )2);
  }
  {
#line 779
  it = get_dyndns_system_table();
  }
  {
#line 780
  while (1) {
    while_continue: /* CIL Label */ ;
#line 780
    if ((unsigned long )it != (unsigned long )((void *)0)) {
#line 780
      if (! ((int )it->id != -1)) {
#line 780
        goto while_break;
      }
    } else {
#line 780
      goto while_break;
    }
    {
#line 782
    tmp = strcmp(it->system.p_key, (char const   *)*(p_cmd->argv + current_nr));
    }
#line 782
    if (tmp == 0) {
#line 784
      p_dns_system = & it->system;
#line 785
      goto while_break;
    }
#line 780
    it ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 789
  if ((unsigned long )p_dns_system == (unsigned long )((void *)0)) {
    {
#line 791
    os_printf(3, (char *)"Cannot find DDNS provider %s, check your spelling.", *(p_cmd->argv + current_nr));
    }
#line 792
    return ((RC_TYPE )81);
  }
#line 795
  curr_info = 0;
  {
#line 795
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 795
    if (curr_info < p_self->info_count) {
#line 795
      if (curr_info < 5) {
#line 795
        if (! ((unsigned long )p_self->info[curr_info].p_dns_system != (unsigned long )p_dns_system)) {
#line 795
          goto while_break___0;
        }
      } else {
#line 795
        goto while_break___0;
      }
    } else {
#line 795
      goto while_break___0;
    }
#line 795
    curr_info ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 800
  if (curr_info >= p_self->info_count) {
#line 802
    if (curr_info < 5) {
#line 804
      (p_self->info_count) ++;
#line 805
      p_self->info[curr_info].p_dns_system = p_dns_system;
    } else {
#line 809
      return ((RC_TYPE )64);
    }
  }
#line 813
  return ((RC_TYPE )0);
}
}
#line 816 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/inadyn_cmd.c"
static RC_TYPE push_in_buffer(char *p_src , int src_len , char *p_buffer , int *p_act_len ,
                              int max_len ) 
{ 


  {
#line 818
  if (*p_act_len + src_len > max_len) {
#line 819
    return ((RC_TYPE )114);
  }
  {
#line 821
  memcpy((void */* __restrict  */)(p_buffer + *p_act_len), (void const   */* __restrict  */)p_src,
         (size_t )src_len);
#line 822
  *p_act_len += src_len;
  }
#line 824
  return ((RC_TYPE )0);
}
}
#line 842 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/inadyn_cmd.c"
static RC_TYPE parser_init(OPTION_FILE_PARSER *p_cfg , FILE *p_file ) 
{ 


  {
  {
#line 844
  memset((void *)p_cfg, 0, sizeof(*p_cfg));
#line 845
  p_cfg->state = (PARSER_STATE )0;
#line 846
  p_cfg->p_file = p_file;
  }
#line 848
  return ((RC_TYPE )0);
}
}
#line 867 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/inadyn_cmd.c"
static RC_TYPE parser_read_option(OPTION_FILE_PARSER *p_cfg , char *p_buffer , int maxlen ) 
{ 
  RC_TYPE rc ;
  BOOL parse_end ;
  int count ;
  char ch ;
  int n ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  char ch___0 ;

  {
#line 869
  rc = (RC_TYPE )0;
#line 870
  parse_end = 0;
#line 871
  count = 0;
#line 872
  *p_buffer = (char)0;
  {
#line 874
  while (1) {
    while_continue: /* CIL Label */ ;
#line 874
    if (! (! parse_end)) {
#line 874
      goto while_break;
    }
    {
#line 879
    n = fscanf((FILE */* __restrict  */)p_cfg->p_file, (char const   */* __restrict  */)"%c",
               & ch);
    }
#line 879
    if (n < 0) {
      {
#line 881
      tmp = feof(p_cfg->p_file);
      }
#line 881
      if (tmp) {
#line 882
        goto while_break;
      }
#line 884
      rc = (RC_TYPE )113;
#line 886
      goto while_break;
    }
    {
#line 892
    if ((unsigned int )p_cfg->state == 0U) {
#line 892
      goto case_0;
    }
#line 922
    if ((unsigned int )p_cfg->state == 3U) {
#line 922
      goto case_3;
    }
#line 951
    if ((unsigned int )p_cfg->state == 1U) {
#line 951
      goto case_1;
    }
#line 956
    if ((unsigned int )p_cfg->state == 2U) {
#line 956
      goto case_2;
    }
#line 988
    if ((unsigned int )p_cfg->state == 4U) {
#line 988
      goto case_4;
    }
#line 995
    goto switch_default;
    case_0: /* CIL Label */ 
#line 893
    if ((int )ch == 92) {
#line 895
      p_cfg->state = (PARSER_STATE )4;
#line 896
      goto switch_break;
    }
#line 899
    if ((int )ch == 35) {
#line 901
      p_cfg->state = (PARSER_STATE )1;
#line 902
      goto switch_break;
    }
    {
#line 905
    tmp___0 = __ctype_b_loc();
    }
#line 905
    if (! ((int const   )*(*tmp___0 + (int )ch) & 8192)) {
#line 907
      if ((int )ch != 45) {
        {
#line 909
        rc = push_in_buffer((char *)"--", 2, p_buffer, & count, maxlen);
        }
#line 909
        if ((unsigned int )rc != 0U) {
#line 910
          goto switch_break;
        }
      }
      {
#line 913
      rc = push_in_buffer(& ch, 1, p_buffer, & count, maxlen);
      }
#line 913
      if ((unsigned int )rc != 0U) {
#line 914
        goto switch_break;
      }
#line 916
      p_cfg->state = (PARSER_STATE )2;
#line 917
      goto switch_break;
    }
#line 920
    goto switch_break;
    case_3: /* CIL Label */ 
#line 923
    if ((int )ch == 92) {
#line 925
      p_cfg->state = (PARSER_STATE )4;
#line 926
      goto switch_break;
    }
#line 929
    if ((int )ch == 35) {
#line 931
      p_cfg->state = (PARSER_STATE )1;
#line 932
      goto switch_break;
    }
#line 935
    if ((int )ch == 10) {
#line 937
      p_cfg->state = (PARSER_STATE )0;
#line 938
      goto switch_break;
    } else
#line 935
    if ((int )ch == 13) {
#line 937
      p_cfg->state = (PARSER_STATE )0;
#line 938
      goto switch_break;
    }
    {
#line 941
    tmp___1 = __ctype_b_loc();
    }
#line 941
    if (! ((int const   )*(*tmp___1 + (int )ch) & 8192)) {
      {
#line 943
      rc = push_in_buffer(& ch, 1, p_buffer, & count, maxlen);
      }
#line 943
      if ((unsigned int )rc != 0U) {
#line 944
        goto switch_break;
      }
#line 946
      p_cfg->state = (PARSER_STATE )2;
#line 947
      goto switch_break;
    }
#line 949
    goto switch_break;
    case_1: /* CIL Label */ 
#line 952
    if ((int )ch == 10) {
#line 953
      p_cfg->state = (PARSER_STATE )0;
    } else
#line 952
    if ((int )ch == 13) {
#line 953
      p_cfg->state = (PARSER_STATE )0;
    }
#line 954
    goto switch_break;
    case_2: /* CIL Label */ 
#line 957
    if ((int )ch == 92) {
#line 959
      p_cfg->state = (PARSER_STATE )4;
#line 960
      goto switch_break;
    }
#line 963
    if ((int )ch == 35) {
#line 965
      p_cfg->state = (PARSER_STATE )1;
#line 966
      goto switch_break;
    }
#line 969
    if ((int )ch == 10) {
#line 971
      p_cfg->state = (PARSER_STATE )0;
#line 972
      parse_end = 1;
#line 973
      goto switch_break;
    } else
#line 969
    if ((int )ch == 13) {
#line 971
      p_cfg->state = (PARSER_STATE )0;
#line 972
      parse_end = 1;
#line 973
      goto switch_break;
    }
    {
#line 976
    tmp___2 = __ctype_b_loc();
    }
#line 976
    if ((int const   )*(*tmp___2 + (int )ch) & 8192) {
#line 978
      p_cfg->state = (PARSER_STATE )3;
#line 979
      parse_end = 1;
#line 980
      goto switch_break;
    }
    {
#line 984
    rc = push_in_buffer(& ch, 1, p_buffer, & count, maxlen);
    }
#line 984
    if ((unsigned int )rc != 0U) {
#line 985
      goto switch_break;
    }
#line 986
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 989
    rc = push_in_buffer(& ch, 1, p_buffer, & count, maxlen);
    }
#line 989
    if ((unsigned int )rc != 0U) {
#line 990
      goto switch_break;
    }
#line 992
    p_cfg->state = (PARSER_STATE )2;
#line 993
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 996
    rc = (RC_TYPE )80;
#line 997
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1000
    if ((unsigned int )rc != 0U) {
#line 1001
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1004
  if ((unsigned int )rc == 0U) {
    {
#line 1006
    ch___0 = (char)0;
#line 1007
    rc = push_in_buffer(& ch___0, 1, p_buffer, & count, maxlen);
    }
  }
#line 1010
  return (rc);
}
}
#line 1023 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/inadyn_cmd.c"
static RC_TYPE get_options_from_file_handler(CMD_DATA *p_cmd , int current_nr , void *p_context ) 
{ 
  RC_TYPE rc ;
  DYN_DNS_CLIENT *p_self ;
  FILE *p_file ;
  char *p_tmp_buffer ;
  int buffer_size ;
  OPTION_FILE_PARSER parser ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
#line 1025
  rc = (RC_TYPE )0;
#line 1026
  p_self = (DYN_DNS_CLIENT *)p_context;
#line 1027
  p_file = (FILE *)((void *)0);
#line 1028
  p_tmp_buffer = (char *)((void *)0);
#line 1029
  buffer_size = 256;
#line 1032
  if (! p_self) {
#line 1033
    return ((RC_TYPE )2);
  } else
#line 1032
  if (! p_cmd) {
#line 1033
    return ((RC_TYPE )2);
  }
  {
#line 1035
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1037
    tmp = malloc((size_t )buffer_size);
#line 1037
    p_tmp_buffer = (char *)tmp;
    }
#line 1038
    if (! p_tmp_buffer) {
#line 1040
      rc = (RC_TYPE )3;
#line 1041
      goto while_break;
    }
    {
#line 1044
    p_file = fopen((char const   */* __restrict  */)*(p_cmd->argv + current_nr), (char const   */* __restrict  */)"r");
    }
#line 1045
    if (! p_file) {
      {
#line 1047
      tmp___0 = __errno_location();
#line 1047
      tmp___1 = strerror(*tmp___0);
#line 1047
      os_printf(3, (char *)"Cannot open config file %s: %s", *(p_cmd->argv + current_nr),
                tmp___1);
#line 1048
      rc = (RC_TYPE )112;
      }
#line 1049
      goto while_break;
    }
#line 1053
    if (p_self->cfgfile) {
      {
#line 1054
      free((void *)p_self->cfgfile);
      }
    }
    {
#line 1055
    p_self->cfgfile = strdup((char const   *)*(p_cmd->argv + current_nr));
#line 1057
    rc = parser_init(& parser, p_file);
    }
#line 1057
    if ((unsigned int )rc != 0U) {
#line 1058
      goto while_break;
    }
    {
#line 1060
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1060
      tmp___3 = feof(p_file);
      }
#line 1060
      if (tmp___3) {
#line 1060
        goto while_break___0;
      }
      {
#line 1062
      rc = parser_read_option(& parser, p_tmp_buffer, buffer_size);
      }
#line 1063
      if ((unsigned int )rc != 0U) {
#line 1064
        goto while_break___0;
      }
      {
#line 1066
      tmp___2 = strlen((char const   *)p_tmp_buffer);
      }
#line 1066
      if (! tmp___2) {
#line 1067
        goto while_break___0;
      }
      {
#line 1069
      rc = cmd_add_val(p_cmd, p_tmp_buffer);
      }
#line 1070
      if ((unsigned int )rc != 0U) {
#line 1071
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1035
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1076
  if (p_file) {
    {
#line 1077
    fclose(p_file);
    }
  }
#line 1079
  if (p_tmp_buffer) {
    {
#line 1080
    free((void *)p_tmp_buffer);
    }
  }
#line 1082
  return (rc);
}
}
#line 1085 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/inadyn_cmd.c"
static void check_setting(int cond , int no , char *msg , int *ok ) 
{ 


  {
#line 1087
  if (! cond) {
    {
#line 1089
    os_printf(4, (char *)"%s in account %d", msg, no + 1);
#line 1090
    *ok = 0;
    }
  }
#line 1092
  return;
}
}
#line 1095 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/inadyn_cmd.c"
static int validate_configuration(DYN_DNS_CLIENT *p_self ) 
{ 
  int i ;
  int num ;
  int ok ;
  DYNDNS_INFO_TYPE *account ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 1097
  num = 0;
#line 1099
  if (! p_self->info_count) {
    {
#line 1101
    os_printf(3, (char *)"No DDNS provider setup in configuration.");
    }
#line 1102
    return (1);
  }
#line 1105
  i = 0;
  {
#line 1105
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1105
    if (! (i < p_self->info_count)) {
#line 1105
      goto while_break;
    }
    {
#line 1107
    ok = 1;
#line 1108
    account = & p_self->info[i];
#line 1110
    tmp = strlen((char const   *)(account->credentials.my_username));
#line 1110
    check_setting((int )tmp, i, (char *)"Missing username", & ok);
#line 1111
    tmp___0 = strlen((char const   *)(account->credentials.my_password));
#line 1111
    check_setting((int )tmp___0, i, (char *)"Missing password", & ok);
#line 1112
    check_setting(account->alias_count, i, (char *)"Missing your alias/hostname",
                  & ok);
#line 1113
    tmp___1 = strlen((char const   *)(account->dyndns_server_name.name));
#line 1113
    check_setting((int )tmp___1, i, (char *)"Missing DDNS server address, check DDNS provider",
                  & ok);
#line 1114
    tmp___2 = strlen((char const   *)(account->ip_server_name.name));
#line 1114
    check_setting((int )tmp___2, i, (char *)"Missing check IP address, check DDNS provider",
                  & ok);
    }
#line 1116
    if (ok) {
#line 1117
      num ++;
    }
#line 1105
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1120
  if (! num) {
    {
#line 1122
    os_printf(3, (char *)"No valid DDNS setup exists.");
    }
#line 1123
    return (1);
  }
#line 1126
  if (num != p_self->info_count) {
    {
#line 1127
    os_printf(4, (char *)"Not all account setups are valid, please check configuration.");
    }
  }
#line 1129
  return (0);
}
}
#line 1148 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/inadyn_cmd.c"
RC_TYPE get_config_data(DYN_DNS_CLIENT *p_self , int argc , char **argv ) 
{ 
  int i ;
  RC_TYPE rc ;
  int cache_file_len ;
  CMD_DESCRIPTION_TYPE *it ;
  char *custom_argv[3] ;
  int custom_argc ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  char *tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;

  {
#line 1151
  rc = (RC_TYPE )0;
  {
#line 1155
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1158
    rc = get_default_config_data(p_self);
    }
#line 1159
    if ((unsigned int )rc != 0U) {
#line 1160
      goto while_break;
    }
#line 1163
    it = cmd_options_table;
    {
#line 1164
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1164
      if (! ((unsigned long )it->p_option != (unsigned long )((void *)0))) {
#line 1164
        goto while_break___0;
      }
#line 1166
      it->p_handler.p_context = (void *)p_self;
#line 1167
      it ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1171
    if (argc == 1) {
#line 1173
      custom_argv[0] = (char *)"";
#line 1173
      custom_argv[1] = (char *)"--input_file";
#line 1173
      custom_argv[2] = (char *)"/etc/inadyn.conf";
#line 1174
      custom_argc = (int )(sizeof(custom_argv) / sizeof(char *));
#line 1176
      if (p_self->dbg.level) {
        {
#line 1177
        os_printf(5, (char *)"Using default config file %s", "/etc/inadyn.conf");
        }
      }
#line 1179
      if (p_self->cfgfile) {
        {
#line 1180
        free((void *)p_self->cfgfile);
        }
      }
      {
#line 1181
      p_self->cfgfile = strdup("/etc/inadyn.conf");
#line 1182
      rc = get_cmd_parse_data(custom_argv, custom_argc, cmd_options_table);
      }
    } else {
      {
#line 1186
      rc = get_cmd_parse_data(argv, argc, cmd_options_table);
      }
    }
#line 1189
    if ((unsigned int )rc != 0U) {
#line 1190
      goto while_break;
    } else
#line 1189
    if (p_self->abort) {
#line 1190
      goto while_break;
    }
#line 1193
    i = 0;
    {
#line 1194
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1197
      tmp___1 = strlen((char const   *)(p_self->info[i].ip_server_name.name));
      }
#line 1197
      if (tmp___1 == 0UL) {
        {
#line 1199
        tmp = strlen((p_self->info[i].p_dns_system)->p_ip_server_name);
        }
#line 1199
        if (sizeof(p_self->info[i].ip_server_name.name) < tmp) {
#line 1201
          rc = (RC_TYPE )64;
#line 1202
          goto while_break___1;
        }
        {
#line 1204
        strcpy((char */* __restrict  */)(p_self->info[i].ip_server_name.name), (char const   */* __restrict  */)(p_self->info[i].p_dns_system)->p_ip_server_name);
#line 1206
        tmp___0 = strlen((p_self->info[i].p_dns_system)->p_ip_server_url);
        }
#line 1206
        if (sizeof(p_self->info[i].ip_server_url) < tmp___0) {
#line 1208
          rc = (RC_TYPE )64;
#line 1209
          goto while_break___1;
        }
        {
#line 1211
        strcpy((char */* __restrict  */)(p_self->info[i].ip_server_url), (char const   */* __restrict  */)(p_self->info[i].p_dns_system)->p_ip_server_url);
        }
      }
      {
#line 1215
      tmp___4 = strlen((char const   *)(p_self->info[i].dyndns_server_name.name));
      }
#line 1215
      if (tmp___4 == 0UL) {
        {
#line 1217
        tmp___2 = strlen((p_self->info[i].p_dns_system)->p_dyndns_server_name);
        }
#line 1217
        if (sizeof(p_self->info[i].dyndns_server_name.name) < tmp___2) {
#line 1219
          rc = (RC_TYPE )64;
#line 1220
          goto while_break___1;
        }
        {
#line 1222
        strcpy((char */* __restrict  */)(p_self->info[i].dyndns_server_name.name),
               (char const   */* __restrict  */)(p_self->info[i].p_dns_system)->p_dyndns_server_name);
#line 1224
        tmp___3 = strlen((p_self->info[i].p_dns_system)->p_dyndns_server_url);
        }
#line 1224
        if (sizeof(p_self->info[i].dyndns_server_url) < tmp___3) {
#line 1226
          rc = (RC_TYPE )64;
#line 1227
          goto while_break___1;
        }
        {
#line 1229
        strcpy((char */* __restrict  */)(p_self->info[i].dyndns_server_url), (char const   */* __restrict  */)(p_self->info[i].p_dns_system)->p_dyndns_server_url);
        }
      }
#line 1194
      i ++;
#line 1194
      if (! (i < p_self->info_count)) {
#line 1194
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1235
    tmp___5 = validate_configuration(p_self);
    }
#line 1235
    if (tmp___5) {
#line 1237
      rc = (RC_TYPE )69;
#line 1238
      goto while_break;
    }
#line 1242
    if (p_self->bind_interface) {
#line 1242
      if (! p_self->cache_file) {
        {
#line 1244
        tmp___6 = strlen("/var/run/inadyn/%s.cache");
#line 1244
        tmp___7 = strlen((char const   *)p_self->bind_interface);
#line 1244
        cache_file_len = (int )((tmp___6 - 2UL) + tmp___7);
#line 1245
        tmp___9 = malloc((size_t )(cache_file_len + 1));
#line 1245
        tmp___8 = (char *)tmp___9;
#line 1245
        p_self->cache_file = tmp___8;
        }
#line 1245
        if ((unsigned long )tmp___8 == (unsigned long )((void *)0)) {
#line 1247
          rc = (RC_TYPE )3;
#line 1248
          goto while_break;
        }
        {
#line 1251
        tmp___10 = snprintf((char */* __restrict  */)p_self->cache_file, (size_t )(cache_file_len + 1),
                            (char const   */* __restrict  */)"/var/run/inadyn/%s.cache",
                            p_self->bind_interface);
        }
#line 1251
        if (tmp___10 != cache_file_len) {
#line 1254
          rc = (RC_TYPE )1;
#line 1255
          goto while_break;
        }
      } else {
        {
#line 1260
        p_self->cache_file = strdup("/var/run/inadyn/inadyn.cache");
        }
      }
    } else {
      {
#line 1260
      p_self->cache_file = strdup("/var/run/inadyn/inadyn.cache");
      }
    }
#line 1155
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1266
  return (rc);
}
}
#line 48 "include/sha1.h"
void sha1_starts(sha1_context *ctx ) ;
#line 57
void sha1_update(sha1_context *ctx , unsigned char const   *input , size_t ilen ) ;
#line 65
void sha1_finish(sha1_context *ctx , unsigned char *output ) ;
#line 59 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/sha1.c"
void sha1_starts(sha1_context *ctx ) 
{ 


  {
#line 61
  ctx->total[0] = 0UL;
#line 62
  ctx->total[1] = 0UL;
#line 64
  ctx->state[0] = 1732584193UL;
#line 65
  ctx->state[1] = 4023233417UL;
#line 66
  ctx->state[2] = 2562383102UL;
#line 67
  ctx->state[3] = 271733878UL;
#line 68
  ctx->state[4] = 3285377520UL;
#line 69
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/sha1.c"
static void sha1_process(sha1_context *ctx , unsigned char const   *data ) 
{ 
  unsigned long temp ;
  unsigned long W[16] ;
  unsigned long A ;
  unsigned long B ;
  unsigned long C ;
  unsigned long D ;
  unsigned long E ;

  {
#line 75
  W[0] = ((((unsigned long )*(data + 0) << 24) | ((unsigned long )*(data + 1) << 16)) | ((unsigned long )*(data + 2) << 8)) | (unsigned long )*(data + 3);
#line 76
  W[1] = ((((unsigned long )*(data + 4) << 24) | ((unsigned long )*(data + 5) << 16)) | ((unsigned long )*(data + 6) << 8)) | (unsigned long )*(data + 7);
#line 77
  W[2] = ((((unsigned long )*(data + 8) << 24) | ((unsigned long )*(data + 9) << 16)) | ((unsigned long )*(data + 10) << 8)) | (unsigned long )*(data + 11);
#line 78
  W[3] = ((((unsigned long )*(data + 12) << 24) | ((unsigned long )*(data + 13) << 16)) | ((unsigned long )*(data + 14) << 8)) | (unsigned long )*(data + 15);
#line 79
  W[4] = ((((unsigned long )*(data + 16) << 24) | ((unsigned long )*(data + 17) << 16)) | ((unsigned long )*(data + 18) << 8)) | (unsigned long )*(data + 19);
#line 80
  W[5] = ((((unsigned long )*(data + 20) << 24) | ((unsigned long )*(data + 21) << 16)) | ((unsigned long )*(data + 22) << 8)) | (unsigned long )*(data + 23);
#line 81
  W[6] = ((((unsigned long )*(data + 24) << 24) | ((unsigned long )*(data + 25) << 16)) | ((unsigned long )*(data + 26) << 8)) | (unsigned long )*(data + 27);
#line 82
  W[7] = ((((unsigned long )*(data + 28) << 24) | ((unsigned long )*(data + 29) << 16)) | ((unsigned long )*(data + 30) << 8)) | (unsigned long )*(data + 31);
#line 83
  W[8] = ((((unsigned long )*(data + 32) << 24) | ((unsigned long )*(data + 33) << 16)) | ((unsigned long )*(data + 34) << 8)) | (unsigned long )*(data + 35);
#line 84
  W[9] = ((((unsigned long )*(data + 36) << 24) | ((unsigned long )*(data + 37) << 16)) | ((unsigned long )*(data + 38) << 8)) | (unsigned long )*(data + 39);
#line 85
  W[10] = ((((unsigned long )*(data + 40) << 24) | ((unsigned long )*(data + 41) << 16)) | ((unsigned long )*(data + 42) << 8)) | (unsigned long )*(data + 43);
#line 86
  W[11] = ((((unsigned long )*(data + 44) << 24) | ((unsigned long )*(data + 45) << 16)) | ((unsigned long )*(data + 46) << 8)) | (unsigned long )*(data + 47);
#line 87
  W[12] = ((((unsigned long )*(data + 48) << 24) | ((unsigned long )*(data + 49) << 16)) | ((unsigned long )*(data + 50) << 8)) | (unsigned long )*(data + 51);
#line 88
  W[13] = ((((unsigned long )*(data + 52) << 24) | ((unsigned long )*(data + 53) << 16)) | ((unsigned long )*(data + 54) << 8)) | (unsigned long )*(data + 55);
#line 89
  W[14] = ((((unsigned long )*(data + 56) << 24) | ((unsigned long )*(data + 57) << 16)) | ((unsigned long )*(data + 58) << 8)) | (unsigned long )*(data + 59);
#line 90
  W[15] = ((((unsigned long )*(data + 60) << 24) | ((unsigned long )*(data + 61) << 16)) | ((unsigned long )*(data + 62) << 8)) | (unsigned long )*(data + 63);
#line 106
  A = ctx->state[0];
#line 107
  B = ctx->state[1];
#line 108
  C = ctx->state[2];
#line 109
  D = ctx->state[3];
#line 110
  E = ctx->state[4];
#line 115
  E += ((((A << 5) | ((A & 4294967295UL) >> 27)) + (D ^ (B & (C ^ D)))) + 1518500249UL) + W[0];
#line 115
  B = (B << 30) | ((B & 4294967295UL) >> 2);
#line 116
  D += ((((E << 5) | ((E & 4294967295UL) >> 27)) + (C ^ (A & (B ^ C)))) + 1518500249UL) + W[1];
#line 116
  A = (A << 30) | ((A & 4294967295UL) >> 2);
#line 117
  C += ((((D << 5) | ((D & 4294967295UL) >> 27)) + (B ^ (E & (A ^ B)))) + 1518500249UL) + W[2];
#line 117
  E = (E << 30) | ((E & 4294967295UL) >> 2);
#line 118
  B += ((((C << 5) | ((C & 4294967295UL) >> 27)) + (A ^ (D & (E ^ A)))) + 1518500249UL) + W[3];
#line 118
  D = (D << 30) | ((D & 4294967295UL) >> 2);
#line 119
  A += ((((B << 5) | ((B & 4294967295UL) >> 27)) + (E ^ (C & (D ^ E)))) + 1518500249UL) + W[4];
#line 119
  C = (C << 30) | ((C & 4294967295UL) >> 2);
#line 120
  E += ((((A << 5) | ((A & 4294967295UL) >> 27)) + (D ^ (B & (C ^ D)))) + 1518500249UL) + W[5];
#line 120
  B = (B << 30) | ((B & 4294967295UL) >> 2);
#line 121
  D += ((((E << 5) | ((E & 4294967295UL) >> 27)) + (C ^ (A & (B ^ C)))) + 1518500249UL) + W[6];
#line 121
  A = (A << 30) | ((A & 4294967295UL) >> 2);
#line 122
  C += ((((D << 5) | ((D & 4294967295UL) >> 27)) + (B ^ (E & (A ^ B)))) + 1518500249UL) + W[7];
#line 122
  E = (E << 30) | ((E & 4294967295UL) >> 2);
#line 123
  B += ((((C << 5) | ((C & 4294967295UL) >> 27)) + (A ^ (D & (E ^ A)))) + 1518500249UL) + W[8];
#line 123
  D = (D << 30) | ((D & 4294967295UL) >> 2);
#line 124
  A += ((((B << 5) | ((B & 4294967295UL) >> 27)) + (E ^ (C & (D ^ E)))) + 1518500249UL) + W[9];
#line 124
  C = (C << 30) | ((C & 4294967295UL) >> 2);
#line 125
  E += ((((A << 5) | ((A & 4294967295UL) >> 27)) + (D ^ (B & (C ^ D)))) + 1518500249UL) + W[10];
#line 125
  B = (B << 30) | ((B & 4294967295UL) >> 2);
#line 126
  D += ((((E << 5) | ((E & 4294967295UL) >> 27)) + (C ^ (A & (B ^ C)))) + 1518500249UL) + W[11];
#line 126
  A = (A << 30) | ((A & 4294967295UL) >> 2);
#line 127
  C += ((((D << 5) | ((D & 4294967295UL) >> 27)) + (B ^ (E & (A ^ B)))) + 1518500249UL) + W[12];
#line 127
  E = (E << 30) | ((E & 4294967295UL) >> 2);
#line 128
  B += ((((C << 5) | ((C & 4294967295UL) >> 27)) + (A ^ (D & (E ^ A)))) + 1518500249UL) + W[13];
#line 128
  D = (D << 30) | ((D & 4294967295UL) >> 2);
#line 129
  A += ((((B << 5) | ((B & 4294967295UL) >> 27)) + (E ^ (C & (D ^ E)))) + 1518500249UL) + W[14];
#line 129
  C = (C << 30) | ((C & 4294967295UL) >> 2);
#line 130
  E += ((((A << 5) | ((A & 4294967295UL) >> 27)) + (D ^ (B & (C ^ D)))) + 1518500249UL) + W[15];
#line 130
  B = (B << 30) | ((B & 4294967295UL) >> 2);
#line 131
  temp = ((W[13] ^ W[8]) ^ W[2]) ^ W[0];
#line 131
  W[0] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 131
  D += ((((E << 5) | ((E & 4294967295UL) >> 27)) + (C ^ (A & (B ^ C)))) + 1518500249UL) + W[0];
#line 131
  A = (A << 30) | ((A & 4294967295UL) >> 2);
#line 132
  temp = ((W[14] ^ W[9]) ^ W[3]) ^ W[1];
#line 132
  W[1] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 132
  C += ((((D << 5) | ((D & 4294967295UL) >> 27)) + (B ^ (E & (A ^ B)))) + 1518500249UL) + W[1];
#line 132
  E = (E << 30) | ((E & 4294967295UL) >> 2);
#line 133
  temp = ((W[15] ^ W[10]) ^ W[4]) ^ W[2];
#line 133
  W[2] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 133
  B += ((((C << 5) | ((C & 4294967295UL) >> 27)) + (A ^ (D & (E ^ A)))) + 1518500249UL) + W[2];
#line 133
  D = (D << 30) | ((D & 4294967295UL) >> 2);
#line 134
  temp = ((W[0] ^ W[11]) ^ W[5]) ^ W[3];
#line 134
  W[3] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 134
  A += ((((B << 5) | ((B & 4294967295UL) >> 27)) + (E ^ (C & (D ^ E)))) + 1518500249UL) + W[3];
#line 134
  C = (C << 30) | ((C & 4294967295UL) >> 2);
#line 142
  temp = ((W[1] ^ W[12]) ^ W[6]) ^ W[4];
#line 142
  W[4] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 142
  E += ((((A << 5) | ((A & 4294967295UL) >> 27)) + ((B ^ C) ^ D)) + 1859775393UL) + W[4];
#line 142
  B = (B << 30) | ((B & 4294967295UL) >> 2);
#line 143
  temp = ((W[2] ^ W[13]) ^ W[7]) ^ W[5];
#line 143
  W[5] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 143
  D += ((((E << 5) | ((E & 4294967295UL) >> 27)) + ((A ^ B) ^ C)) + 1859775393UL) + W[5];
#line 143
  A = (A << 30) | ((A & 4294967295UL) >> 2);
#line 144
  temp = ((W[3] ^ W[14]) ^ W[8]) ^ W[6];
#line 144
  W[6] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 144
  C += ((((D << 5) | ((D & 4294967295UL) >> 27)) + ((E ^ A) ^ B)) + 1859775393UL) + W[6];
#line 144
  E = (E << 30) | ((E & 4294967295UL) >> 2);
#line 145
  temp = ((W[4] ^ W[15]) ^ W[9]) ^ W[7];
#line 145
  W[7] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 145
  B += ((((C << 5) | ((C & 4294967295UL) >> 27)) + ((D ^ E) ^ A)) + 1859775393UL) + W[7];
#line 145
  D = (D << 30) | ((D & 4294967295UL) >> 2);
#line 146
  temp = ((W[5] ^ W[0]) ^ W[10]) ^ W[8];
#line 146
  W[8] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 146
  A += ((((B << 5) | ((B & 4294967295UL) >> 27)) + ((C ^ D) ^ E)) + 1859775393UL) + W[8];
#line 146
  C = (C << 30) | ((C & 4294967295UL) >> 2);
#line 147
  temp = ((W[6] ^ W[1]) ^ W[11]) ^ W[9];
#line 147
  W[9] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 147
  E += ((((A << 5) | ((A & 4294967295UL) >> 27)) + ((B ^ C) ^ D)) + 1859775393UL) + W[9];
#line 147
  B = (B << 30) | ((B & 4294967295UL) >> 2);
#line 148
  temp = ((W[7] ^ W[2]) ^ W[12]) ^ W[10];
#line 148
  W[10] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 148
  D += ((((E << 5) | ((E & 4294967295UL) >> 27)) + ((A ^ B) ^ C)) + 1859775393UL) + W[10];
#line 148
  A = (A << 30) | ((A & 4294967295UL) >> 2);
#line 149
  temp = ((W[8] ^ W[3]) ^ W[13]) ^ W[11];
#line 149
  W[11] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 149
  C += ((((D << 5) | ((D & 4294967295UL) >> 27)) + ((E ^ A) ^ B)) + 1859775393UL) + W[11];
#line 149
  E = (E << 30) | ((E & 4294967295UL) >> 2);
#line 150
  temp = ((W[9] ^ W[4]) ^ W[14]) ^ W[12];
#line 150
  W[12] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 150
  B += ((((C << 5) | ((C & 4294967295UL) >> 27)) + ((D ^ E) ^ A)) + 1859775393UL) + W[12];
#line 150
  D = (D << 30) | ((D & 4294967295UL) >> 2);
#line 151
  temp = ((W[10] ^ W[5]) ^ W[15]) ^ W[13];
#line 151
  W[13] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 151
  A += ((((B << 5) | ((B & 4294967295UL) >> 27)) + ((C ^ D) ^ E)) + 1859775393UL) + W[13];
#line 151
  C = (C << 30) | ((C & 4294967295UL) >> 2);
#line 152
  temp = ((W[11] ^ W[6]) ^ W[0]) ^ W[14];
#line 152
  W[14] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 152
  E += ((((A << 5) | ((A & 4294967295UL) >> 27)) + ((B ^ C) ^ D)) + 1859775393UL) + W[14];
#line 152
  B = (B << 30) | ((B & 4294967295UL) >> 2);
#line 153
  temp = ((W[12] ^ W[7]) ^ W[1]) ^ W[15];
#line 153
  W[15] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 153
  D += ((((E << 5) | ((E & 4294967295UL) >> 27)) + ((A ^ B) ^ C)) + 1859775393UL) + W[15];
#line 153
  A = (A << 30) | ((A & 4294967295UL) >> 2);
#line 154
  temp = ((W[13] ^ W[8]) ^ W[2]) ^ W[0];
#line 154
  W[0] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 154
  C += ((((D << 5) | ((D & 4294967295UL) >> 27)) + ((E ^ A) ^ B)) + 1859775393UL) + W[0];
#line 154
  E = (E << 30) | ((E & 4294967295UL) >> 2);
#line 155
  temp = ((W[14] ^ W[9]) ^ W[3]) ^ W[1];
#line 155
  W[1] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 155
  B += ((((C << 5) | ((C & 4294967295UL) >> 27)) + ((D ^ E) ^ A)) + 1859775393UL) + W[1];
#line 155
  D = (D << 30) | ((D & 4294967295UL) >> 2);
#line 156
  temp = ((W[15] ^ W[10]) ^ W[4]) ^ W[2];
#line 156
  W[2] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 156
  A += ((((B << 5) | ((B & 4294967295UL) >> 27)) + ((C ^ D) ^ E)) + 1859775393UL) + W[2];
#line 156
  C = (C << 30) | ((C & 4294967295UL) >> 2);
#line 157
  temp = ((W[0] ^ W[11]) ^ W[5]) ^ W[3];
#line 157
  W[3] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 157
  E += ((((A << 5) | ((A & 4294967295UL) >> 27)) + ((B ^ C) ^ D)) + 1859775393UL) + W[3];
#line 157
  B = (B << 30) | ((B & 4294967295UL) >> 2);
#line 158
  temp = ((W[1] ^ W[12]) ^ W[6]) ^ W[4];
#line 158
  W[4] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 158
  D += ((((E << 5) | ((E & 4294967295UL) >> 27)) + ((A ^ B) ^ C)) + 1859775393UL) + W[4];
#line 158
  A = (A << 30) | ((A & 4294967295UL) >> 2);
#line 159
  temp = ((W[2] ^ W[13]) ^ W[7]) ^ W[5];
#line 159
  W[5] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 159
  C += ((((D << 5) | ((D & 4294967295UL) >> 27)) + ((E ^ A) ^ B)) + 1859775393UL) + W[5];
#line 159
  E = (E << 30) | ((E & 4294967295UL) >> 2);
#line 160
  temp = ((W[3] ^ W[14]) ^ W[8]) ^ W[6];
#line 160
  W[6] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 160
  B += ((((C << 5) | ((C & 4294967295UL) >> 27)) + ((D ^ E) ^ A)) + 1859775393UL) + W[6];
#line 160
  D = (D << 30) | ((D & 4294967295UL) >> 2);
#line 161
  temp = ((W[4] ^ W[15]) ^ W[9]) ^ W[7];
#line 161
  W[7] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 161
  A += ((((B << 5) | ((B & 4294967295UL) >> 27)) + ((C ^ D) ^ E)) + 1859775393UL) + W[7];
#line 161
  C = (C << 30) | ((C & 4294967295UL) >> 2);
#line 169
  temp = ((W[5] ^ W[0]) ^ W[10]) ^ W[8];
#line 169
  W[8] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 169
  E += ((((A << 5) | ((A & 4294967295UL) >> 27)) + ((B & C) | (D & (B | C)))) + 2400959708UL) + W[8];
#line 169
  B = (B << 30) | ((B & 4294967295UL) >> 2);
#line 170
  temp = ((W[6] ^ W[1]) ^ W[11]) ^ W[9];
#line 170
  W[9] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 170
  D += ((((E << 5) | ((E & 4294967295UL) >> 27)) + ((A & B) | (C & (A | B)))) + 2400959708UL) + W[9];
#line 170
  A = (A << 30) | ((A & 4294967295UL) >> 2);
#line 171
  temp = ((W[7] ^ W[2]) ^ W[12]) ^ W[10];
#line 171
  W[10] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 171
  C += ((((D << 5) | ((D & 4294967295UL) >> 27)) + ((E & A) | (B & (E | A)))) + 2400959708UL) + W[10];
#line 171
  E = (E << 30) | ((E & 4294967295UL) >> 2);
#line 172
  temp = ((W[8] ^ W[3]) ^ W[13]) ^ W[11];
#line 172
  W[11] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 172
  B += ((((C << 5) | ((C & 4294967295UL) >> 27)) + ((D & E) | (A & (D | E)))) + 2400959708UL) + W[11];
#line 172
  D = (D << 30) | ((D & 4294967295UL) >> 2);
#line 173
  temp = ((W[9] ^ W[4]) ^ W[14]) ^ W[12];
#line 173
  W[12] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 173
  A += ((((B << 5) | ((B & 4294967295UL) >> 27)) + ((C & D) | (E & (C | D)))) + 2400959708UL) + W[12];
#line 173
  C = (C << 30) | ((C & 4294967295UL) >> 2);
#line 174
  temp = ((W[10] ^ W[5]) ^ W[15]) ^ W[13];
#line 174
  W[13] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 174
  E += ((((A << 5) | ((A & 4294967295UL) >> 27)) + ((B & C) | (D & (B | C)))) + 2400959708UL) + W[13];
#line 174
  B = (B << 30) | ((B & 4294967295UL) >> 2);
#line 175
  temp = ((W[11] ^ W[6]) ^ W[0]) ^ W[14];
#line 175
  W[14] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 175
  D += ((((E << 5) | ((E & 4294967295UL) >> 27)) + ((A & B) | (C & (A | B)))) + 2400959708UL) + W[14];
#line 175
  A = (A << 30) | ((A & 4294967295UL) >> 2);
#line 176
  temp = ((W[12] ^ W[7]) ^ W[1]) ^ W[15];
#line 176
  W[15] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 176
  C += ((((D << 5) | ((D & 4294967295UL) >> 27)) + ((E & A) | (B & (E | A)))) + 2400959708UL) + W[15];
#line 176
  E = (E << 30) | ((E & 4294967295UL) >> 2);
#line 177
  temp = ((W[13] ^ W[8]) ^ W[2]) ^ W[0];
#line 177
  W[0] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 177
  B += ((((C << 5) | ((C & 4294967295UL) >> 27)) + ((D & E) | (A & (D | E)))) + 2400959708UL) + W[0];
#line 177
  D = (D << 30) | ((D & 4294967295UL) >> 2);
#line 178
  temp = ((W[14] ^ W[9]) ^ W[3]) ^ W[1];
#line 178
  W[1] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 178
  A += ((((B << 5) | ((B & 4294967295UL) >> 27)) + ((C & D) | (E & (C | D)))) + 2400959708UL) + W[1];
#line 178
  C = (C << 30) | ((C & 4294967295UL) >> 2);
#line 179
  temp = ((W[15] ^ W[10]) ^ W[4]) ^ W[2];
#line 179
  W[2] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 179
  E += ((((A << 5) | ((A & 4294967295UL) >> 27)) + ((B & C) | (D & (B | C)))) + 2400959708UL) + W[2];
#line 179
  B = (B << 30) | ((B & 4294967295UL) >> 2);
#line 180
  temp = ((W[0] ^ W[11]) ^ W[5]) ^ W[3];
#line 180
  W[3] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 180
  D += ((((E << 5) | ((E & 4294967295UL) >> 27)) + ((A & B) | (C & (A | B)))) + 2400959708UL) + W[3];
#line 180
  A = (A << 30) | ((A & 4294967295UL) >> 2);
#line 181
  temp = ((W[1] ^ W[12]) ^ W[6]) ^ W[4];
#line 181
  W[4] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 181
  C += ((((D << 5) | ((D & 4294967295UL) >> 27)) + ((E & A) | (B & (E | A)))) + 2400959708UL) + W[4];
#line 181
  E = (E << 30) | ((E & 4294967295UL) >> 2);
#line 182
  temp = ((W[2] ^ W[13]) ^ W[7]) ^ W[5];
#line 182
  W[5] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 182
  B += ((((C << 5) | ((C & 4294967295UL) >> 27)) + ((D & E) | (A & (D | E)))) + 2400959708UL) + W[5];
#line 182
  D = (D << 30) | ((D & 4294967295UL) >> 2);
#line 183
  temp = ((W[3] ^ W[14]) ^ W[8]) ^ W[6];
#line 183
  W[6] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 183
  A += ((((B << 5) | ((B & 4294967295UL) >> 27)) + ((C & D) | (E & (C | D)))) + 2400959708UL) + W[6];
#line 183
  C = (C << 30) | ((C & 4294967295UL) >> 2);
#line 184
  temp = ((W[4] ^ W[15]) ^ W[9]) ^ W[7];
#line 184
  W[7] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 184
  E += ((((A << 5) | ((A & 4294967295UL) >> 27)) + ((B & C) | (D & (B | C)))) + 2400959708UL) + W[7];
#line 184
  B = (B << 30) | ((B & 4294967295UL) >> 2);
#line 185
  temp = ((W[5] ^ W[0]) ^ W[10]) ^ W[8];
#line 185
  W[8] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 185
  D += ((((E << 5) | ((E & 4294967295UL) >> 27)) + ((A & B) | (C & (A | B)))) + 2400959708UL) + W[8];
#line 185
  A = (A << 30) | ((A & 4294967295UL) >> 2);
#line 186
  temp = ((W[6] ^ W[1]) ^ W[11]) ^ W[9];
#line 186
  W[9] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 186
  C += ((((D << 5) | ((D & 4294967295UL) >> 27)) + ((E & A) | (B & (E | A)))) + 2400959708UL) + W[9];
#line 186
  E = (E << 30) | ((E & 4294967295UL) >> 2);
#line 187
  temp = ((W[7] ^ W[2]) ^ W[12]) ^ W[10];
#line 187
  W[10] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 187
  B += ((((C << 5) | ((C & 4294967295UL) >> 27)) + ((D & E) | (A & (D | E)))) + 2400959708UL) + W[10];
#line 187
  D = (D << 30) | ((D & 4294967295UL) >> 2);
#line 188
  temp = ((W[8] ^ W[3]) ^ W[13]) ^ W[11];
#line 188
  W[11] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 188
  A += ((((B << 5) | ((B & 4294967295UL) >> 27)) + ((C & D) | (E & (C | D)))) + 2400959708UL) + W[11];
#line 188
  C = (C << 30) | ((C & 4294967295UL) >> 2);
#line 196
  temp = ((W[9] ^ W[4]) ^ W[14]) ^ W[12];
#line 196
  W[12] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 196
  E += ((((A << 5) | ((A & 4294967295UL) >> 27)) + ((B ^ C) ^ D)) + 3395469782UL) + W[12];
#line 196
  B = (B << 30) | ((B & 4294967295UL) >> 2);
#line 197
  temp = ((W[10] ^ W[5]) ^ W[15]) ^ W[13];
#line 197
  W[13] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 197
  D += ((((E << 5) | ((E & 4294967295UL) >> 27)) + ((A ^ B) ^ C)) + 3395469782UL) + W[13];
#line 197
  A = (A << 30) | ((A & 4294967295UL) >> 2);
#line 198
  temp = ((W[11] ^ W[6]) ^ W[0]) ^ W[14];
#line 198
  W[14] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 198
  C += ((((D << 5) | ((D & 4294967295UL) >> 27)) + ((E ^ A) ^ B)) + 3395469782UL) + W[14];
#line 198
  E = (E << 30) | ((E & 4294967295UL) >> 2);
#line 199
  temp = ((W[12] ^ W[7]) ^ W[1]) ^ W[15];
#line 199
  W[15] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 199
  B += ((((C << 5) | ((C & 4294967295UL) >> 27)) + ((D ^ E) ^ A)) + 3395469782UL) + W[15];
#line 199
  D = (D << 30) | ((D & 4294967295UL) >> 2);
#line 200
  temp = ((W[13] ^ W[8]) ^ W[2]) ^ W[0];
#line 200
  W[0] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 200
  A += ((((B << 5) | ((B & 4294967295UL) >> 27)) + ((C ^ D) ^ E)) + 3395469782UL) + W[0];
#line 200
  C = (C << 30) | ((C & 4294967295UL) >> 2);
#line 201
  temp = ((W[14] ^ W[9]) ^ W[3]) ^ W[1];
#line 201
  W[1] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 201
  E += ((((A << 5) | ((A & 4294967295UL) >> 27)) + ((B ^ C) ^ D)) + 3395469782UL) + W[1];
#line 201
  B = (B << 30) | ((B & 4294967295UL) >> 2);
#line 202
  temp = ((W[15] ^ W[10]) ^ W[4]) ^ W[2];
#line 202
  W[2] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 202
  D += ((((E << 5) | ((E & 4294967295UL) >> 27)) + ((A ^ B) ^ C)) + 3395469782UL) + W[2];
#line 202
  A = (A << 30) | ((A & 4294967295UL) >> 2);
#line 203
  temp = ((W[0] ^ W[11]) ^ W[5]) ^ W[3];
#line 203
  W[3] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 203
  C += ((((D << 5) | ((D & 4294967295UL) >> 27)) + ((E ^ A) ^ B)) + 3395469782UL) + W[3];
#line 203
  E = (E << 30) | ((E & 4294967295UL) >> 2);
#line 204
  temp = ((W[1] ^ W[12]) ^ W[6]) ^ W[4];
#line 204
  W[4] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 204
  B += ((((C << 5) | ((C & 4294967295UL) >> 27)) + ((D ^ E) ^ A)) + 3395469782UL) + W[4];
#line 204
  D = (D << 30) | ((D & 4294967295UL) >> 2);
#line 205
  temp = ((W[2] ^ W[13]) ^ W[7]) ^ W[5];
#line 205
  W[5] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 205
  A += ((((B << 5) | ((B & 4294967295UL) >> 27)) + ((C ^ D) ^ E)) + 3395469782UL) + W[5];
#line 205
  C = (C << 30) | ((C & 4294967295UL) >> 2);
#line 206
  temp = ((W[3] ^ W[14]) ^ W[8]) ^ W[6];
#line 206
  W[6] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 206
  E += ((((A << 5) | ((A & 4294967295UL) >> 27)) + ((B ^ C) ^ D)) + 3395469782UL) + W[6];
#line 206
  B = (B << 30) | ((B & 4294967295UL) >> 2);
#line 207
  temp = ((W[4] ^ W[15]) ^ W[9]) ^ W[7];
#line 207
  W[7] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 207
  D += ((((E << 5) | ((E & 4294967295UL) >> 27)) + ((A ^ B) ^ C)) + 3395469782UL) + W[7];
#line 207
  A = (A << 30) | ((A & 4294967295UL) >> 2);
#line 208
  temp = ((W[5] ^ W[0]) ^ W[10]) ^ W[8];
#line 208
  W[8] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 208
  C += ((((D << 5) | ((D & 4294967295UL) >> 27)) + ((E ^ A) ^ B)) + 3395469782UL) + W[8];
#line 208
  E = (E << 30) | ((E & 4294967295UL) >> 2);
#line 209
  temp = ((W[6] ^ W[1]) ^ W[11]) ^ W[9];
#line 209
  W[9] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 209
  B += ((((C << 5) | ((C & 4294967295UL) >> 27)) + ((D ^ E) ^ A)) + 3395469782UL) + W[9];
#line 209
  D = (D << 30) | ((D & 4294967295UL) >> 2);
#line 210
  temp = ((W[7] ^ W[2]) ^ W[12]) ^ W[10];
#line 210
  W[10] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 210
  A += ((((B << 5) | ((B & 4294967295UL) >> 27)) + ((C ^ D) ^ E)) + 3395469782UL) + W[10];
#line 210
  C = (C << 30) | ((C & 4294967295UL) >> 2);
#line 211
  temp = ((W[8] ^ W[3]) ^ W[13]) ^ W[11];
#line 211
  W[11] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 211
  E += ((((A << 5) | ((A & 4294967295UL) >> 27)) + ((B ^ C) ^ D)) + 3395469782UL) + W[11];
#line 211
  B = (B << 30) | ((B & 4294967295UL) >> 2);
#line 212
  temp = ((W[9] ^ W[4]) ^ W[14]) ^ W[12];
#line 212
  W[12] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 212
  D += ((((E << 5) | ((E & 4294967295UL) >> 27)) + ((A ^ B) ^ C)) + 3395469782UL) + W[12];
#line 212
  A = (A << 30) | ((A & 4294967295UL) >> 2);
#line 213
  temp = ((W[10] ^ W[5]) ^ W[15]) ^ W[13];
#line 213
  W[13] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 213
  C += ((((D << 5) | ((D & 4294967295UL) >> 27)) + ((E ^ A) ^ B)) + 3395469782UL) + W[13];
#line 213
  E = (E << 30) | ((E & 4294967295UL) >> 2);
#line 214
  temp = ((W[11] ^ W[6]) ^ W[0]) ^ W[14];
#line 214
  W[14] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 214
  B += ((((C << 5) | ((C & 4294967295UL) >> 27)) + ((D ^ E) ^ A)) + 3395469782UL) + W[14];
#line 214
  D = (D << 30) | ((D & 4294967295UL) >> 2);
#line 215
  temp = ((W[12] ^ W[7]) ^ W[1]) ^ W[15];
#line 215
  W[15] = (temp << 1) | ((temp & 4294967295UL) >> 31);
#line 215
  A += ((((B << 5) | ((B & 4294967295UL) >> 27)) + ((C ^ D) ^ E)) + 3395469782UL) + W[15];
#line 215
  C = (C << 30) | ((C & 4294967295UL) >> 2);
#line 220
  ctx->state[0] += A;
#line 221
  ctx->state[1] += B;
#line 222
  ctx->state[2] += C;
#line 223
  ctx->state[3] += D;
#line 224
  ctx->state[4] += E;
#line 225
  return;
}
}
#line 230 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/sha1.c"
void sha1_update(sha1_context *ctx , unsigned char const   *input , size_t ilen ) 
{ 
  size_t fill ;
  unsigned long left ;

  {
#line 235
  if (ilen <= 0UL) {
#line 236
    return;
  }
#line 238
  left = ctx->total[0] & 63UL;
#line 239
  fill = 64UL - left;
#line 241
  ctx->total[0] += ilen;
#line 242
  ctx->total[0] &= 4294967295UL;
#line 244
  if (ctx->total[0] < ilen) {
#line 245
    (ctx->total[1]) ++;
  }
#line 247
  if (left) {
#line 247
    if (ilen >= fill) {
      {
#line 249
      memcpy((void */* __restrict  */)((void *)(ctx->buffer + left)), (void const   */* __restrict  */)((void *)input),
             fill);
#line 251
      sha1_process(ctx, (unsigned char const   *)(ctx->buffer));
#line 252
      input += fill;
#line 253
      ilen -= fill;
#line 254
      left = 0UL;
      }
    }
  }
  {
#line 257
  while (1) {
    while_continue: /* CIL Label */ ;
#line 257
    if (! (ilen >= 64UL)) {
#line 257
      goto while_break;
    }
    {
#line 259
    sha1_process(ctx, (unsigned char const   *)input);
#line 260
    input += 64;
#line 261
    ilen -= 64UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 264
  if (ilen > 0UL) {
    {
#line 266
    memcpy((void */* __restrict  */)((void *)(ctx->buffer + left)), (void const   */* __restrict  */)((void *)input),
           ilen);
    }
  }
#line 269
  return;
}
}
#line 271 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/sha1.c"
static unsigned char const   sha1_padding[64]  = 
#line 271
  {      (unsigned char const   )128,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0};
#line 282 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/sha1.c"
void sha1_finish(sha1_context *ctx , unsigned char *output ) 
{ 
  unsigned long last ;
  unsigned long padn ;
  unsigned long high ;
  unsigned long low ;
  unsigned char msglen[8] ;

  {
#line 288
  high = (ctx->total[0] >> 29) | (ctx->total[1] << 3);
#line 290
  low = ctx->total[0] << 3;
#line 292
  msglen[0] = (unsigned char )(high >> 24);
#line 292
  msglen[1] = (unsigned char )(high >> 16);
#line 292
  msglen[2] = (unsigned char )(high >> 8);
#line 292
  msglen[3] = (unsigned char )high;
#line 293
  msglen[4] = (unsigned char )(low >> 24);
#line 293
  msglen[5] = (unsigned char )(low >> 16);
#line 293
  msglen[6] = (unsigned char )(low >> 8);
#line 293
  msglen[7] = (unsigned char )low;
#line 295
  last = ctx->total[0] & 63UL;
#line 296
  if (last < 56UL) {
#line 296
    padn = 56UL - last;
  } else {
#line 296
    padn = 120UL - last;
  }
  {
#line 298
  sha1_update(ctx, (unsigned char const   *)((unsigned char *)(sha1_padding)), padn);
#line 299
  sha1_update(ctx, (unsigned char const   *)(msglen), (size_t )8);
#line 301
  *(output + 0) = (unsigned char )(ctx->state[0] >> 24);
#line 301
  *(output + 1) = (unsigned char )(ctx->state[0] >> 16);
#line 301
  *(output + 2) = (unsigned char )(ctx->state[0] >> 8);
#line 301
  *(output + 3) = (unsigned char )ctx->state[0];
#line 302
  *(output + 4) = (unsigned char )(ctx->state[1] >> 24);
#line 302
  *(output + 5) = (unsigned char )(ctx->state[1] >> 16);
#line 302
  *(output + 6) = (unsigned char )(ctx->state[1] >> 8);
#line 302
  *(output + 7) = (unsigned char )ctx->state[1];
#line 303
  *(output + 8) = (unsigned char )(ctx->state[2] >> 24);
#line 303
  *(output + 9) = (unsigned char )(ctx->state[2] >> 16);
#line 303
  *(output + 10) = (unsigned char )(ctx->state[2] >> 8);
#line 303
  *(output + 11) = (unsigned char )ctx->state[2];
#line 304
  *(output + 12) = (unsigned char )(ctx->state[3] >> 24);
#line 304
  *(output + 13) = (unsigned char )(ctx->state[3] >> 16);
#line 304
  *(output + 14) = (unsigned char )(ctx->state[3] >> 8);
#line 304
  *(output + 15) = (unsigned char )ctx->state[3];
#line 305
  *(output + 16) = (unsigned char )(ctx->state[4] >> 24);
#line 305
  *(output + 17) = (unsigned char )(ctx->state[4] >> 16);
#line 305
  *(output + 18) = (unsigned char )(ctx->state[4] >> 8);
#line 305
  *(output + 19) = (unsigned char )ctx->state[4];
  }
#line 306
  return;
}
}
#line 311 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/sha1.c"
void sha1(unsigned char const   *input , size_t ilen , unsigned char *output ) 
{ 
  sha1_context ctx ;

  {
  {
#line 315
  sha1_starts(& ctx);
#line 316
  sha1_update(& ctx, input, ilen);
#line 317
  sha1_finish(& ctx, output);
#line 319
  memset((void *)(& ctx), 0, sizeof(sha1_context ));
  }
#line 320
  return;
}
}
#line 123 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 63 "include/ip.h"
RC_TYPE ip_construct(IP_SOCKET *p_self ) ;
#line 68
RC_TYPE ip_destruct(IP_SOCKET *p_self ) ;
#line 75
RC_TYPE ip_initialize(IP_SOCKET *p_self ) ;
#line 80
RC_TYPE ip_shutdown(IP_SOCKET *p_self ) ;
#line 83
RC_TYPE ip_send(IP_SOCKET *p_self , char const   *p_buf , int len ) ;
#line 86
RC_TYPE ip_recv(IP_SOCKET *p_self , char *p_buf , int max_recv_len , int *p_recv_len ) ;
#line 90
RC_TYPE ip_set_port(IP_SOCKET *p_self , int p ) ;
#line 91
RC_TYPE ip_set_remote_name(IP_SOCKET *p_self , char const   *p ) ;
#line 92
RC_TYPE ip_set_remote_timeout(IP_SOCKET *p_self , int t ) ;
#line 93
RC_TYPE ip_set_bind_iface(IP_SOCKET *p_self , char *ifname ) ;
#line 95
RC_TYPE ip_get_port(IP_SOCKET *p_self , int *p_port ) ;
#line 96
RC_TYPE ip_get_remote_name(IP_SOCKET *p_self , char const   **p ) ;
#line 97
RC_TYPE ip_get_remote_timeout(IP_SOCKET *p_self , int *p ) ;
#line 98
RC_TYPE ip_get_bind_iface(IP_SOCKET *p_self , char **ifname ) ;
#line 50 "include/tcp.h"
RC_TYPE tcp_construct(TCP_SOCKET *p_self ) ;
#line 55
RC_TYPE tcp_destruct(TCP_SOCKET *p_self ) ;
#line 62
RC_TYPE tcp_initialize(TCP_SOCKET *p_self , char *msg ) ;
#line 67
RC_TYPE tcp_shutdown(TCP_SOCKET *p_self ) ;
#line 71
RC_TYPE tcp_send(TCP_SOCKET *p_self , char const   *p_buf , int len ) ;
#line 74
RC_TYPE tcp_recv(TCP_SOCKET *p_self , char *p_buf , int max_recv_len , int *p_recv_len ) ;
#line 78
RC_TYPE tcp_set_port(TCP_SOCKET *p_self , int p ) ;
#line 79
RC_TYPE tcp_set_remote_name(TCP_SOCKET *p_self , char const   *p ) ;
#line 80
RC_TYPE tcp_set_remote_timeout(TCP_SOCKET *p_self , int p ) ;
#line 81
RC_TYPE tcp_set_bind_iface(TCP_SOCKET *p_self , char *ifname ) ;
#line 83
RC_TYPE tcp_get_port(TCP_SOCKET *p_self , int *p ) ;
#line 84
RC_TYPE tcp_get_remote_name(TCP_SOCKET *p_self , char const   **p ) ;
#line 85
RC_TYPE tcp_get_remote_timeout(TCP_SOCKET *p_self , int *p ) ;
#line 86
RC_TYPE tcp_get_bind_iface(TCP_SOCKET *p_self , char **ifname ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/tcp.c"
RC_TYPE tcp_construct(TCP_SOCKET *p_self ) 
{ 
  RC_TYPE rc ;

  {
#line 31
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 33
    return ((RC_TYPE )2);
  }
  {
#line 36
  rc = ip_construct(& p_self->super);
  }
#line 37
  if ((unsigned int )rc != 0U) {
#line 39
    return (rc);
  }
  {
#line 43
  memset((void *)((char *)p_self + sizeof(p_self->super)), 0, sizeof(*p_self) - sizeof(p_self->super));
#line 44
  p_self->initialized = 0;
  }
#line 46
  return ((RC_TYPE )0);
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/tcp.c"
RC_TYPE tcp_destruct(TCP_SOCKET *p_self ) 
{ 
  RC_TYPE tmp ;

  {
#line 54
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 56
    return ((RC_TYPE )0);
  }
#line 59
  if (p_self->initialized == 1) {
    {
#line 61
    tcp_shutdown(p_self);
    }
  }
  {
#line 64
  tmp = ip_destruct(& p_self->super);
  }
#line 64
  return (tmp);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/tcp.c"
static RC_TYPE local_set_params(TCP_SOCKET *p_self ) 
{ 
  int timeout ;

  {
  {
#line 72
  tcp_get_remote_timeout(p_self, & timeout);
  }
#line 74
  if (timeout == 0) {
    {
#line 76
    tcp_set_remote_timeout(p_self, 20000);
    }
  }
#line 79
  return ((RC_TYPE )0);
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/tcp.c"
RC_TYPE tcp_initialize(TCP_SOCKET *p_self , char *msg ) 
{ 
  RC_TYPE rc ;
  struct timeval sv ;
  int svlen ;
  char host[1025] ;
  int code ;
  int tmp ;
  char *tmp___0 ;
  int code___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int code___1 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;

  {
#line 91
  svlen = (int )sizeof(sv);
  {
#line 94
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 96
    local_set_params(p_self);
#line 99
    rc = ip_initialize(& p_self->super);
    }
#line 100
    if ((unsigned int )rc != 0U) {
#line 102
      goto while_break;
    }
#line 106
    if (p_self->super.type == 0) {
      {
#line 108
      p_self->super.socket = socket(2, 1, 0);
      }
#line 109
      if (p_self->super.socket == -1) {
        {
#line 111
        tmp = os_get_socket_error();
#line 111
        code = tmp;
#line 113
        tmp___0 = strerror(code);
#line 113
        os_printf(3, (char *)"Error creating client socket: %s", tmp___0);
#line 114
        rc = (RC_TYPE )16;
        }
#line 115
        goto while_break;
      }
#line 120
      p_self->initialized = 1;
#line 122
      if (p_self->super.bound == 1) {
        {
#line 124
        tmp___3 = bind(p_self->super.socket, (struct sockaddr  const  *)((struct sockaddr *)(& p_self->super.local_addr)),
                       (socklen_t )sizeof(struct sockaddr_in ));
        }
#line 124
        if (tmp___3 < 0) {
          {
#line 126
          tmp___1 = os_get_socket_error();
#line 126
          code___0 = tmp___1;
#line 128
          tmp___2 = strerror(code___0);
#line 128
          os_printf(4, (char *)"Failed binding client socket to local address: %s",
                    tmp___2);
#line 129
          rc = (RC_TYPE )24;
          }
#line 130
          goto while_break;
        }
      }
    } else {
#line 136
      p_self->initialized = 1;
#line 137
      rc = (RC_TYPE )17;
    }
    {
#line 141
    sv.tv_sec = (__time_t )(p_self->super.timeout / 1000);
#line 142
    sv.tv_usec = (__suseconds_t )((p_self->super.timeout % 1000) * 1000);
#line 143
    setsockopt(p_self->super.socket, 1, 20, (void const   *)(& sv), (socklen_t )svlen);
#line 144
    setsockopt(p_self->super.socket, 1, 21, (void const   *)(& sv), (socklen_t )svlen);
#line 146
    tmp___4 = getnameinfo((struct sockaddr  const  */* __restrict  */)(& p_self->super.remote_addr),
                          p_self->super.remote_len, (char */* __restrict  */)(host),
                          (socklen_t )1025, (char */* __restrict  */)((void *)0),
                          (socklen_t )0, 1);
    }
#line 146
    if (! tmp___4) {
      {
#line 148
      os_printf(6, (char *)"%s, connecting to %s(%s)", msg, p_self->super.p_remote_host_name,
                host);
      }
    }
    {
#line 151
    tmp___7 = connect(p_self->super.socket, (struct sockaddr  const  *)(& p_self->super.remote_addr),
                      p_self->super.remote_len);
    }
#line 151
    if (0 != tmp___7) {
      {
#line 153
      tmp___5 = os_get_socket_error();
#line 153
      code___1 = tmp___5;
#line 155
      tmp___6 = strerror(code___1);
#line 155
      os_printf(4, (char *)"Failed connecting to remote server: %s", tmp___6);
#line 156
      rc = (RC_TYPE )19;
      }
#line 157
      goto while_break;
    }
#line 94
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 162
  if ((unsigned int )rc != 0U) {
    {
#line 164
    tcp_shutdown(p_self);
    }
#line 165
    return (rc);
  }
#line 168
  return ((RC_TYPE )0);
}
}
#line 173 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/tcp.c"
RC_TYPE tcp_shutdown(TCP_SOCKET *p_self ) 
{ 
  RC_TYPE tmp ;

  {
#line 175
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 177
    return ((RC_TYPE )2);
  }
#line 180
  if (! p_self->initialized) {
#line 182
    return ((RC_TYPE )0);
  }
  {
#line 185
  p_self->initialized = 0;
#line 187
  tmp = ip_shutdown(& p_self->super);
  }
#line 187
  return (tmp);
}
}
#line 192 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/tcp.c"
RC_TYPE tcp_send(TCP_SOCKET *p_self , char const   *p_buf , int len ) 
{ 
  RC_TYPE tmp ;

  {
#line 194
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 196
    return ((RC_TYPE )2);
  }
#line 199
  if (! p_self->initialized) {
#line 201
    return ((RC_TYPE )32);
  }
  {
#line 204
  tmp = ip_send(& p_self->super, p_buf, len);
  }
#line 204
  return (tmp);
}
}
#line 208 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/tcp.c"
RC_TYPE tcp_recv(TCP_SOCKET *p_self , char *p_buf , int max_recv_len , int *p_recv_len ) 
{ 
  RC_TYPE tmp ;

  {
#line 210
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 212
    return ((RC_TYPE )2);
  }
#line 215
  if (! p_self->initialized) {
#line 217
    return ((RC_TYPE )32);
  }
  {
#line 219
  tmp = ip_recv(& p_self->super, p_buf, max_recv_len, p_recv_len);
  }
#line 219
  return (tmp);
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/tcp.c"
RC_TYPE tcp_set_port(TCP_SOCKET *p_self , int p ) 
{ 
  RC_TYPE tmp ;

  {
#line 226
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 228
    return ((RC_TYPE )2);
  }
  {
#line 231
  tmp = ip_set_port(& p_self->super, p);
  }
#line 231
  return (tmp);
}
}
#line 234 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/tcp.c"
RC_TYPE tcp_set_remote_name(TCP_SOCKET *p_self , char const   *p ) 
{ 
  RC_TYPE tmp ;

  {
#line 236
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 238
    return ((RC_TYPE )2);
  }
  {
#line 241
  tmp = ip_set_remote_name(& p_self->super, p);
  }
#line 241
  return (tmp);
}
}
#line 244 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/tcp.c"
RC_TYPE tcp_set_remote_timeout(TCP_SOCKET *p_self , int p ) 
{ 
  RC_TYPE tmp ;

  {
#line 246
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 248
    return ((RC_TYPE )2);
  }
  {
#line 251
  tmp = ip_set_remote_timeout(& p_self->super, p);
  }
#line 251
  return (tmp);
}
}
#line 254 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/tcp.c"
RC_TYPE tcp_set_bind_iface(TCP_SOCKET *p_self , char *ifname ) 
{ 
  RC_TYPE tmp ;

  {
#line 256
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 258
    return ((RC_TYPE )2);
  }
  {
#line 261
  tmp = ip_set_bind_iface(& p_self->super, ifname);
  }
#line 261
  return (tmp);
}
}
#line 264 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/tcp.c"
RC_TYPE tcp_get_port(TCP_SOCKET *p_self , int *p ) 
{ 
  RC_TYPE tmp ;

  {
#line 266
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 268
    return ((RC_TYPE )2);
  }
  {
#line 271
  tmp = ip_get_port(& p_self->super, p);
  }
#line 271
  return (tmp);
}
}
#line 274 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/tcp.c"
RC_TYPE tcp_get_remote_name(TCP_SOCKET *p_self , char const   **p ) 
{ 
  RC_TYPE tmp ;

  {
#line 276
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 278
    return ((RC_TYPE )2);
  }
  {
#line 281
  tmp = ip_get_remote_name(& p_self->super, p);
  }
#line 281
  return (tmp);
}
}
#line 284 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/tcp.c"
RC_TYPE tcp_get_remote_timeout(TCP_SOCKET *p_self , int *p ) 
{ 
  RC_TYPE tmp ;

  {
#line 286
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 288
    return ((RC_TYPE )2);
  }
  {
#line 291
  tmp = ip_get_remote_timeout(& p_self->super, p);
  }
#line 291
  return (tmp);
}
}
#line 294 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/tcp.c"
RC_TYPE tcp_get_bind_iface(TCP_SOCKET *p_self , char **ifname ) 
{ 
  RC_TYPE tmp ;

  {
#line 296
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 298
    return ((RC_TYPE )2);
  } else
#line 296
  if ((unsigned long )ifname == (unsigned long )((void *)0)) {
#line 298
    return ((RC_TYPE )2);
  }
  {
#line 301
  tmp = ip_get_bind_iface(& p_self->super, ifname);
  }
#line 301
  return (tmp);
}
}
#line 74 "include/errorcode.h"
char const   *errorcode_get_name(RC_TYPE rc ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/errorcode.c"
static ERROR_NAME const   global_error_table[36]  = 
#line 28 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/errorcode.c"
  {      {(RC_TYPE )0, "RC_OK"}, 
        {(RC_TYPE )1, "RC_ERROR"}, 
        {(RC_TYPE )2, "RC_INVALID_POINTER"}, 
        {(RC_TYPE )3, "RC_OUT_OF_MEMORY"}, 
        {(RC_TYPE )4, "RC_OUT_BUFFER_OVERFLOW"}, 
        {(RC_TYPE )16, "RC_IP_SOCKET_CREATE_ERROR"}, 
        {(RC_TYPE )17, "RC_IP_BAD_PARAMETER"}, 
        {(RC_TYPE )18, "RC_IP_INVALID_REMOTE_ADDR"}, 
        {(RC_TYPE )19, "RC_IP_CONNECT_FAILED"}, 
        {(RC_TYPE )20, "RC_IP_SEND_ERROR"}, 
        {(RC_TYPE )21, "RC_IP_RECV_ERROR"}, 
        {(RC_TYPE )22, "RC_IP_OBJECT_NOT_INITIALIZED"}, 
        {(RC_TYPE )23, "RC_IP_OS_SOCKET_INIT_FAILED"}, 
        {(RC_TYPE )32, "RC_TCP_OBJECT_NOT_INITIALIZED"}, 
        {(RC_TYPE )48, "RC_HTTP_OBJECT_NOT_INITIALIZED"}, 
        {(RC_TYPE )49, "RC_HTTP_BAD_PARAMETER"}, 
        {(RC_TYPE )64, "RC_DYNDNS_BUFFER_TOO_SMALL"}, 
        {(RC_TYPE )65, "RC_DYNDNS_INVALID_IP_ADDR_IN_HTTP_RESPONSE"}, 
        {(RC_TYPE )66, "RC_DYNDNS_INVALID_RSP_FROM_IP_SERVER"}, 
        {(RC_TYPE )67, "RC_DYNDNS_TOO_MANY_ALIASES"}, 
        {(RC_TYPE )68, "RC_DYNDNS_INVALID_OPTION"}, 
        {(RC_TYPE )69, "RC_DYNDNS_INVALID_OR_MISSING_PARAMETERS"}, 
        {(RC_TYPE )70, "RC_DYNDNS_UNRESOLVED_ALIAS"}, 
        {(RC_TYPE )72, "RC_DYNDNS_RSP_NOTOK"}, 
        {(RC_TYPE )73, "RC_DYNDNS_RSP_RETRY_LATER"}, 
        {(RC_TYPE )80, "RC_CMD_PARSER_INVALID_OPTION"}, 
        {(RC_TYPE )81, "RC_CMD_PARSER_INVALID_OPTION_ARGUMENT"}, 
        {(RC_TYPE )96, "RC_OS_ERROR_INSTALLING_SIGNAL_HANDLER"}, 
        {(RC_TYPE )98, "RC_FORK_FAILURE"}, 
        {(RC_TYPE )99, "RC_OS_CHANGE_PERSONA_FAILURE"}, 
        {(RC_TYPE )100, "RC_OS_INVALID_UID"}, 
        {(RC_TYPE )101, "RC_OS_INVALID_GID"}, 
        {(RC_TYPE )112, "RC_FILE_IO_OPEN_ERROR"}, 
        {(RC_TYPE )113, "RC_FILE_IO_READ_ERROR"}, 
        {(RC_TYPE )114, "RC_FILE_IO_OUT_OF_BUFFER"}, 
        {(RC_TYPE )0, (char const   *)((void *)0)}};
#line 76 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/errorcode.c"
static char const   *unknown_error  =    "Unknown error";
#line 78 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/errorcode.c"
char const   *errorcode_get_name(RC_TYPE rc ) 
{ 
  ERROR_NAME const   *it ;

  {
#line 80
  it = global_error_table;
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    if (! ((unsigned long )it->p_name != (unsigned long )((void *)0))) {
#line 82
      goto while_break;
    }
#line 84
    if ((unsigned int const   )it->rc == (unsigned int const   )rc) {
#line 86
      return ((char const   *)it->p_name);
    }
#line 88
    it ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 91
  return (unknown_error);
}
}
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 170
extern struct _IO_FILE *stderr ;
#line 460 "/usr/include/unistd.h"
extern int usleep(__useconds_t __useconds ) ;
#line 497
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 573
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execl)(char const   *__path ,
                                                                                              char const   *__arg 
                                                                                              , ...) ;
#line 667
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) setsid)(void) ;
#line 700
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setuid)(__uid_t __uid ) ;
#line 717
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setgid)(__gid_t __gid ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 764
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) vfork)(void) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 584
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) setenv)(char const   *__name ,
                                                                                             char const   *__value ,
                                                                                             int __replace ) ;
#line 215 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 221
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigaddset)(sigset_t *__set ,
                                                                                                int __signo ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 175 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void closelog(void) ;
#line 181
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 181 "include/os.h"
RC_TYPE os_ip_support_startup(void) ;
#line 184
RC_TYPE os_ip_support_cleanup(void) ;
#line 187
RC_TYPE os_install_signal_handler(void *p_dyndns ) ;
#line 190
int inadyn_main(int argc , char **argv ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/os_unix.c"
void os_sleep_ms(int ms ) 
{ 


  {
  {
#line 35
  usleep((__useconds_t )(ms * 1000));
  }
#line 36
  return;
}
}
#line 38 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/os_unix.c"
int os_get_socket_error(void) 
{ 
  int *tmp ;

  {
  {
#line 40
  tmp = __errno_location();
  }
#line 40
  return (*tmp);
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/os_unix.c"
RC_TYPE os_ip_support_startup(void) 
{ 


  {
#line 45
  return ((RC_TYPE )0);
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/os_unix.c"
RC_TYPE os_ip_support_cleanup(void) 
{ 


  {
#line 50
  return ((RC_TYPE )0);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/os_unix.c"
RC_TYPE os_shell_execute(char *p_cmd , char *ip , char *hostname , char *iface ) 
{ 
  RC_TYPE rc ;
  int child ;

  {
  {
#line 55
  rc = (RC_TYPE )0;
#line 58
  child = vfork();
  }
  {
#line 61
  if (child == 0) {
#line 61
    goto case_0;
  }
#line 70
  if (child == -1) {
#line 70
    goto case_neg_1;
  }
#line 74
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 62
  setenv("INADYN_IP", (char const   *)ip, 1);
#line 63
  setenv("INADYN_HOSTNAME", (char const   *)hostname, 1);
  }
#line 64
  if (iface) {
    {
#line 65
    setenv("INADYN_IFACE", (char const   *)iface, 1);
    }
  }
  {
#line 66
  execl("/bin/sh", "sh", "-c", p_cmd, (char *)0);
#line 67
  exit(1);
  }
#line 68
  goto switch_break;
  case_neg_1: /* CIL Label */ 
#line 71
  rc = (RC_TYPE )98;
#line 72
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 75
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 78
  return (rc);
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/os_unix.c"
static void *global_p_signal_handler_param  =    (void *)0;
#line 95 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/os_unix.c"
static void unix_signal_handler(int signo ) 
{ 
  DYN_DNS_CLIENT *p_self ;

  {
#line 97
  p_self = (DYN_DNS_CLIENT *)global_p_signal_handler_param;
#line 99
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 102
    return;
  }
  {
#line 107
  if (signo == 1) {
#line 107
    goto case_1;
  }
#line 115
  if (signo == 15) {
#line 115
    goto case_15;
  }
#line 115
  if (signo == 14) {
#line 115
    goto case_15;
  }
#line 115
  if (signo == 3) {
#line 115
    goto case_15;
  }
#line 115
  if (signo == 2) {
#line 115
    goto case_15;
  }
#line 120
  goto switch_default;
  case_1: /* CIL Label */ 
#line 109
  p_self->cmd = (DYN_DNS_CMD )2;
#line 110
  goto switch_break;
  case_15: /* CIL Label */ 
  case_14: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 117
  p_self->cmd = (DYN_DNS_CMD )1;
#line 118
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 122
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 124
  return;
}
}
#line 132 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/os_unix.c"
RC_TYPE os_install_signal_handler(void *p_dyndns ) 
{ 
  RC_TYPE rc ;
  struct sigaction newact ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
  {
#line 136
  newact.__sigaction_handler.sa_handler = & unix_signal_handler;
#line 137
  newact.sa_flags = 0;
#line 139
  tmp = sigemptyset(& newact.sa_mask);
  }
#line 139
  if (tmp) {
#line 139
    tmp___11 = 1;
  } else {
    {
#line 139
    tmp___0 = sigaddset(& newact.sa_mask, 1);
    }
#line 139
    if (tmp___0) {
#line 139
      tmp___11 = 1;
    } else {
      {
#line 139
      tmp___1 = sigaddset(& newact.sa_mask, 2);
      }
#line 139
      if (tmp___1) {
#line 139
        tmp___11 = 1;
      } else {
        {
#line 139
        tmp___2 = sigaddset(& newact.sa_mask, 3);
        }
#line 139
        if (tmp___2) {
#line 139
          tmp___11 = 1;
        } else {
          {
#line 139
          tmp___3 = sigaddset(& newact.sa_mask, 15);
          }
#line 139
          if (tmp___3) {
#line 139
            tmp___11 = 1;
          } else {
            {
#line 139
            tmp___4 = sigaction(14, (struct sigaction  const  */* __restrict  */)(& newact),
                                (struct sigaction */* __restrict  */)((void *)0));
            }
#line 139
            if (tmp___4) {
#line 139
              tmp___11 = 1;
            } else {
              {
#line 139
              tmp___5 = sigemptyset(& newact.sa_mask);
              }
#line 139
              if (tmp___5) {
#line 139
                tmp___11 = 1;
              } else {
                {
#line 139
                tmp___6 = sigaddset(& newact.sa_mask, 14);
                }
#line 139
                if (tmp___6) {
#line 139
                  tmp___11 = 1;
                } else {
                  {
#line 139
                  tmp___7 = sigaction(1, (struct sigaction  const  */* __restrict  */)(& newact),
                                      (struct sigaction */* __restrict  */)((void *)0));
                  }
#line 139
                  if (tmp___7) {
#line 139
                    tmp___11 = 1;
                  } else {
                    {
#line 139
                    tmp___8 = sigaction(2, (struct sigaction  const  */* __restrict  */)(& newact),
                                        (struct sigaction */* __restrict  */)((void *)0));
                    }
#line 139
                    if (tmp___8) {
#line 139
                      tmp___11 = 1;
                    } else {
                      {
#line 139
                      tmp___9 = sigaction(3, (struct sigaction  const  */* __restrict  */)(& newact),
                                          (struct sigaction */* __restrict  */)((void *)0));
                      }
#line 139
                      if (tmp___9) {
#line 139
                        tmp___11 = 1;
                      } else {
                        {
#line 139
                        tmp___10 = sigaction(15, (struct sigaction  const  */* __restrict  */)(& newact),
                                             (struct sigaction */* __restrict  */)((void *)0));
                        }
#line 139
                        if (tmp___10) {
#line 139
                          tmp___11 = 1;
                        } else {
#line 139
                          tmp___11 = 0;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 139
  rc = (RC_TYPE )tmp___11;
#line 151
  if ((unsigned int )rc == 0U) {
#line 153
    global_p_signal_handler_param = p_dyndns;
  }
#line 156
  return (rc);
}
}
#line 178 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/os_unix.c"
RC_TYPE close_console_window(void) 
{ 
  pid_t pid ;
  __pid_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 180
  tmp = fork();
#line 180
  pid = tmp;
  }
#line 182
  if (pid < 0) {
#line 184
    return ((RC_TYPE )98);
  }
#line 187
  if (pid == 0) {
    {
#line 189
    fclose(stdin);
#line 190
    fclose(stderr);
#line 191
    setsid();
#line 192
    tmp___2 = chdir("/");
    }
#line 192
    if (-1 == tmp___2) {
      {
#line 194
      tmp___0 = __errno_location();
#line 194
      tmp___1 = strerror(*tmp___0);
#line 194
      os_printf(4, (char *)"Failed changing cwd to /: %s", tmp___1);
      }
    }
    {
#line 196
    umask((__mode_t )0);
    }
#line 198
    return ((RC_TYPE )0);
  }
  {
#line 201
  exit(0);
  }
#line 203
  return ((RC_TYPE )0);
}
}
#line 207 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/os_unix.c"
int main(int argc , char **argv ) 
{ 
  int tmp ;

  {
  {
#line 209
  tmp = inadyn_main(argc, argv);
  }
#line 209
  return (tmp);
}
}
#line 212 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/os_unix.c"
RC_TYPE os_syslog_open(char const   *p_prg_name ) 
{ 


  {
  {
#line 214
  openlog(p_prg_name, 1, 1 << 3);
  }
#line 215
  return ((RC_TYPE )0);
}
}
#line 218 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/os_unix.c"
RC_TYPE os_syslog_close(void) 
{ 


  {
  {
#line 220
  closelog();
  }
#line 221
  return ((RC_TYPE )0);
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/os_unix.c"
RC_TYPE os_change_persona(OS_USER_INFO *p_usr_info ) 
{ 
  int rc ;
  __gid_t tmp ;
  __uid_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 228
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 230
    tmp = getgid();
    }
#line 230
    if (p_usr_info->gid != tmp) {
      {
#line 232
      rc = setgid(p_usr_info->gid);
      }
#line 232
      if (rc != 0) {
#line 234
        goto while_break;
      }
    }
    {
#line 238
    tmp___0 = getuid();
    }
#line 238
    if (p_usr_info->uid != tmp___0) {
      {
#line 240
      rc = setuid(p_usr_info->uid);
      }
#line 240
      if (rc != 0) {
#line 242
        goto while_break;
      }
    }
#line 228
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 248
  if (rc != 0) {
    {
#line 250
    tmp___1 = __errno_location();
#line 250
    tmp___2 = strerror(*tmp___1);
#line 250
    os_printf(4, (char *)"Failed dropping privileges: %s", tmp___2);
    }
#line 251
    return ((RC_TYPE )99);
  }
#line 254
  return ((RC_TYPE )0);
}
}
#line 48 "include/md5.h"
void md5_starts(md5_context *ctx ) ;
#line 57
void md5_update(md5_context *ctx , unsigned char const   *input , size_t ilen ) ;
#line 65
void md5_finish(md5_context *ctx , unsigned char *output ) ;
#line 59 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/md5.c"
void md5_starts(md5_context *ctx ) 
{ 


  {
#line 61
  ctx->total[0] = 0UL;
#line 62
  ctx->total[1] = 0UL;
#line 64
  ctx->state[0] = 1732584193UL;
#line 65
  ctx->state[1] = 4023233417UL;
#line 66
  ctx->state[2] = 2562383102UL;
#line 67
  ctx->state[3] = 271733878UL;
#line 68
  return;
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/md5.c"
static void md5_process(md5_context *ctx , unsigned char const   *data ) 
{ 
  unsigned long X[16] ;
  unsigned long A ;
  unsigned long B ;
  unsigned long C ;
  unsigned long D ;

  {
#line 74
  X[0] = (((unsigned long )*(data + 0) | ((unsigned long )*(data + 1) << 8)) | ((unsigned long )*(data + 2) << 16)) | ((unsigned long )*(data + 3) << 24);
#line 75
  X[1] = (((unsigned long )*(data + 4) | ((unsigned long )*(data + 5) << 8)) | ((unsigned long )*(data + 6) << 16)) | ((unsigned long )*(data + 7) << 24);
#line 76
  X[2] = (((unsigned long )*(data + 8) | ((unsigned long )*(data + 9) << 8)) | ((unsigned long )*(data + 10) << 16)) | ((unsigned long )*(data + 11) << 24);
#line 77
  X[3] = (((unsigned long )*(data + 12) | ((unsigned long )*(data + 13) << 8)) | ((unsigned long )*(data + 14) << 16)) | ((unsigned long )*(data + 15) << 24);
#line 78
  X[4] = (((unsigned long )*(data + 16) | ((unsigned long )*(data + 17) << 8)) | ((unsigned long )*(data + 18) << 16)) | ((unsigned long )*(data + 19) << 24);
#line 79
  X[5] = (((unsigned long )*(data + 20) | ((unsigned long )*(data + 21) << 8)) | ((unsigned long )*(data + 22) << 16)) | ((unsigned long )*(data + 23) << 24);
#line 80
  X[6] = (((unsigned long )*(data + 24) | ((unsigned long )*(data + 25) << 8)) | ((unsigned long )*(data + 26) << 16)) | ((unsigned long )*(data + 27) << 24);
#line 81
  X[7] = (((unsigned long )*(data + 28) | ((unsigned long )*(data + 29) << 8)) | ((unsigned long )*(data + 30) << 16)) | ((unsigned long )*(data + 31) << 24);
#line 82
  X[8] = (((unsigned long )*(data + 32) | ((unsigned long )*(data + 33) << 8)) | ((unsigned long )*(data + 34) << 16)) | ((unsigned long )*(data + 35) << 24);
#line 83
  X[9] = (((unsigned long )*(data + 36) | ((unsigned long )*(data + 37) << 8)) | ((unsigned long )*(data + 38) << 16)) | ((unsigned long )*(data + 39) << 24);
#line 84
  X[10] = (((unsigned long )*(data + 40) | ((unsigned long )*(data + 41) << 8)) | ((unsigned long )*(data + 42) << 16)) | ((unsigned long )*(data + 43) << 24);
#line 85
  X[11] = (((unsigned long )*(data + 44) | ((unsigned long )*(data + 45) << 8)) | ((unsigned long )*(data + 46) << 16)) | ((unsigned long )*(data + 47) << 24);
#line 86
  X[12] = (((unsigned long )*(data + 48) | ((unsigned long )*(data + 49) << 8)) | ((unsigned long )*(data + 50) << 16)) | ((unsigned long )*(data + 51) << 24);
#line 87
  X[13] = (((unsigned long )*(data + 52) | ((unsigned long )*(data + 53) << 8)) | ((unsigned long )*(data + 54) << 16)) | ((unsigned long )*(data + 55) << 24);
#line 88
  X[14] = (((unsigned long )*(data + 56) | ((unsigned long )*(data + 57) << 8)) | ((unsigned long )*(data + 58) << 16)) | ((unsigned long )*(data + 59) << 24);
#line 89
  X[15] = (((unsigned long )*(data + 60) | ((unsigned long )*(data + 61) << 8)) | ((unsigned long )*(data + 62) << 16)) | ((unsigned long )*(data + 63) << 24);
#line 98
  A = ctx->state[0];
#line 99
  B = ctx->state[1];
#line 100
  C = ctx->state[2];
#line 101
  D = ctx->state[3];
#line 105
  A += ((D ^ (B & (C ^ D))) + X[0]) + 3614090360UL;
#line 105
  A = ((A << 7) | ((A & 4294967295UL) >> 25)) + B;
#line 106
  D += ((C ^ (A & (B ^ C))) + X[1]) + 3905402710UL;
#line 106
  D = ((D << 12) | ((D & 4294967295UL) >> 20)) + A;
#line 107
  C += ((B ^ (D & (A ^ B))) + X[2]) + 606105819UL;
#line 107
  C = ((C << 17) | ((C & 4294967295UL) >> 15)) + D;
#line 108
  B += ((A ^ (C & (D ^ A))) + X[3]) + 3250441966UL;
#line 108
  B = ((B << 22) | ((B & 4294967295UL) >> 10)) + C;
#line 109
  A += ((D ^ (B & (C ^ D))) + X[4]) + 4118548399UL;
#line 109
  A = ((A << 7) | ((A & 4294967295UL) >> 25)) + B;
#line 110
  D += ((C ^ (A & (B ^ C))) + X[5]) + 1200080426UL;
#line 110
  D = ((D << 12) | ((D & 4294967295UL) >> 20)) + A;
#line 111
  C += ((B ^ (D & (A ^ B))) + X[6]) + 2821735955UL;
#line 111
  C = ((C << 17) | ((C & 4294967295UL) >> 15)) + D;
#line 112
  B += ((A ^ (C & (D ^ A))) + X[7]) + 4249261313UL;
#line 112
  B = ((B << 22) | ((B & 4294967295UL) >> 10)) + C;
#line 113
  A += ((D ^ (B & (C ^ D))) + X[8]) + 1770035416UL;
#line 113
  A = ((A << 7) | ((A & 4294967295UL) >> 25)) + B;
#line 114
  D += ((C ^ (A & (B ^ C))) + X[9]) + 2336552879UL;
#line 114
  D = ((D << 12) | ((D & 4294967295UL) >> 20)) + A;
#line 115
  C += ((B ^ (D & (A ^ B))) + X[10]) + 4294925233UL;
#line 115
  C = ((C << 17) | ((C & 4294967295UL) >> 15)) + D;
#line 116
  B += ((A ^ (C & (D ^ A))) + X[11]) + 2304563134UL;
#line 116
  B = ((B << 22) | ((B & 4294967295UL) >> 10)) + C;
#line 117
  A += ((D ^ (B & (C ^ D))) + X[12]) + 1804603682UL;
#line 117
  A = ((A << 7) | ((A & 4294967295UL) >> 25)) + B;
#line 118
  D += ((C ^ (A & (B ^ C))) + X[13]) + 4254626195UL;
#line 118
  D = ((D << 12) | ((D & 4294967295UL) >> 20)) + A;
#line 119
  C += ((B ^ (D & (A ^ B))) + X[14]) + 2792965006UL;
#line 119
  C = ((C << 17) | ((C & 4294967295UL) >> 15)) + D;
#line 120
  B += ((A ^ (C & (D ^ A))) + X[15]) + 1236535329UL;
#line 120
  B = ((B << 22) | ((B & 4294967295UL) >> 10)) + C;
#line 126
  A += ((C ^ (D & (B ^ C))) + X[1]) + 4129170786UL;
#line 126
  A = ((A << 5) | ((A & 4294967295UL) >> 27)) + B;
#line 127
  D += ((B ^ (C & (A ^ B))) + X[6]) + 3225465664UL;
#line 127
  D = ((D << 9) | ((D & 4294967295UL) >> 23)) + A;
#line 128
  C += ((A ^ (B & (D ^ A))) + X[11]) + 643717713UL;
#line 128
  C = ((C << 14) | ((C & 4294967295UL) >> 18)) + D;
#line 129
  B += ((D ^ (A & (C ^ D))) + X[0]) + 3921069994UL;
#line 129
  B = ((B << 20) | ((B & 4294967295UL) >> 12)) + C;
#line 130
  A += ((C ^ (D & (B ^ C))) + X[5]) + 3593408605UL;
#line 130
  A = ((A << 5) | ((A & 4294967295UL) >> 27)) + B;
#line 131
  D += ((B ^ (C & (A ^ B))) + X[10]) + 38016083UL;
#line 131
  D = ((D << 9) | ((D & 4294967295UL) >> 23)) + A;
#line 132
  C += ((A ^ (B & (D ^ A))) + X[15]) + 3634488961UL;
#line 132
  C = ((C << 14) | ((C & 4294967295UL) >> 18)) + D;
#line 133
  B += ((D ^ (A & (C ^ D))) + X[4]) + 3889429448UL;
#line 133
  B = ((B << 20) | ((B & 4294967295UL) >> 12)) + C;
#line 134
  A += ((C ^ (D & (B ^ C))) + X[9]) + 568446438UL;
#line 134
  A = ((A << 5) | ((A & 4294967295UL) >> 27)) + B;
#line 135
  D += ((B ^ (C & (A ^ B))) + X[14]) + 3275163606UL;
#line 135
  D = ((D << 9) | ((D & 4294967295UL) >> 23)) + A;
#line 136
  C += ((A ^ (B & (D ^ A))) + X[3]) + 4107603335UL;
#line 136
  C = ((C << 14) | ((C & 4294967295UL) >> 18)) + D;
#line 137
  B += ((D ^ (A & (C ^ D))) + X[8]) + 1163531501UL;
#line 137
  B = ((B << 20) | ((B & 4294967295UL) >> 12)) + C;
#line 138
  A += ((C ^ (D & (B ^ C))) + X[13]) + 2850285829UL;
#line 138
  A = ((A << 5) | ((A & 4294967295UL) >> 27)) + B;
#line 139
  D += ((B ^ (C & (A ^ B))) + X[2]) + 4243563512UL;
#line 139
  D = ((D << 9) | ((D & 4294967295UL) >> 23)) + A;
#line 140
  C += ((A ^ (B & (D ^ A))) + X[7]) + 1735328473UL;
#line 140
  C = ((C << 14) | ((C & 4294967295UL) >> 18)) + D;
#line 141
  B += ((D ^ (A & (C ^ D))) + X[12]) + 2368359562UL;
#line 141
  B = ((B << 20) | ((B & 4294967295UL) >> 12)) + C;
#line 147
  A += (((B ^ C) ^ D) + X[5]) + 4294588738UL;
#line 147
  A = ((A << 4) | ((A & 4294967295UL) >> 28)) + B;
#line 148
  D += (((A ^ B) ^ C) + X[8]) + 2272392833UL;
#line 148
  D = ((D << 11) | ((D & 4294967295UL) >> 21)) + A;
#line 149
  C += (((D ^ A) ^ B) + X[11]) + 1839030562UL;
#line 149
  C = ((C << 16) | ((C & 4294967295UL) >> 16)) + D;
#line 150
  B += (((C ^ D) ^ A) + X[14]) + 4259657740UL;
#line 150
  B = ((B << 23) | ((B & 4294967295UL) >> 9)) + C;
#line 151
  A += (((B ^ C) ^ D) + X[1]) + 2763975236UL;
#line 151
  A = ((A << 4) | ((A & 4294967295UL) >> 28)) + B;
#line 152
  D += (((A ^ B) ^ C) + X[4]) + 1272893353UL;
#line 152
  D = ((D << 11) | ((D & 4294967295UL) >> 21)) + A;
#line 153
  C += (((D ^ A) ^ B) + X[7]) + 4139469664UL;
#line 153
  C = ((C << 16) | ((C & 4294967295UL) >> 16)) + D;
#line 154
  B += (((C ^ D) ^ A) + X[10]) + 3200236656UL;
#line 154
  B = ((B << 23) | ((B & 4294967295UL) >> 9)) + C;
#line 155
  A += (((B ^ C) ^ D) + X[13]) + 681279174UL;
#line 155
  A = ((A << 4) | ((A & 4294967295UL) >> 28)) + B;
#line 156
  D += (((A ^ B) ^ C) + X[0]) + 3936430074UL;
#line 156
  D = ((D << 11) | ((D & 4294967295UL) >> 21)) + A;
#line 157
  C += (((D ^ A) ^ B) + X[3]) + 3572445317UL;
#line 157
  C = ((C << 16) | ((C & 4294967295UL) >> 16)) + D;
#line 158
  B += (((C ^ D) ^ A) + X[6]) + 76029189UL;
#line 158
  B = ((B << 23) | ((B & 4294967295UL) >> 9)) + C;
#line 159
  A += (((B ^ C) ^ D) + X[9]) + 3654602809UL;
#line 159
  A = ((A << 4) | ((A & 4294967295UL) >> 28)) + B;
#line 160
  D += (((A ^ B) ^ C) + X[12]) + 3873151461UL;
#line 160
  D = ((D << 11) | ((D & 4294967295UL) >> 21)) + A;
#line 161
  C += (((D ^ A) ^ B) + X[15]) + 530742520UL;
#line 161
  C = ((C << 16) | ((C & 4294967295UL) >> 16)) + D;
#line 162
  B += (((C ^ D) ^ A) + X[2]) + 3299628645UL;
#line 162
  B = ((B << 23) | ((B & 4294967295UL) >> 9)) + C;
#line 168
  A += ((C ^ (B | ~ D)) + X[0]) + 4096336452UL;
#line 168
  A = ((A << 6) | ((A & 4294967295UL) >> 26)) + B;
#line 169
  D += ((B ^ (A | ~ C)) + X[7]) + 1126891415UL;
#line 169
  D = ((D << 10) | ((D & 4294967295UL) >> 22)) + A;
#line 170
  C += ((A ^ (D | ~ B)) + X[14]) + 2878612391UL;
#line 170
  C = ((C << 15) | ((C & 4294967295UL) >> 17)) + D;
#line 171
  B += ((D ^ (C | ~ A)) + X[5]) + 4237533241UL;
#line 171
  B = ((B << 21) | ((B & 4294967295UL) >> 11)) + C;
#line 172
  A += ((C ^ (B | ~ D)) + X[12]) + 1700485571UL;
#line 172
  A = ((A << 6) | ((A & 4294967295UL) >> 26)) + B;
#line 173
  D += ((B ^ (A | ~ C)) + X[3]) + 2399980690UL;
#line 173
  D = ((D << 10) | ((D & 4294967295UL) >> 22)) + A;
#line 174
  C += ((A ^ (D | ~ B)) + X[10]) + 4293915773UL;
#line 174
  C = ((C << 15) | ((C & 4294967295UL) >> 17)) + D;
#line 175
  B += ((D ^ (C | ~ A)) + X[1]) + 2240044497UL;
#line 175
  B = ((B << 21) | ((B & 4294967295UL) >> 11)) + C;
#line 176
  A += ((C ^ (B | ~ D)) + X[8]) + 1873313359UL;
#line 176
  A = ((A << 6) | ((A & 4294967295UL) >> 26)) + B;
#line 177
  D += ((B ^ (A | ~ C)) + X[15]) + 4264355552UL;
#line 177
  D = ((D << 10) | ((D & 4294967295UL) >> 22)) + A;
#line 178
  C += ((A ^ (D | ~ B)) + X[6]) + 2734768916UL;
#line 178
  C = ((C << 15) | ((C & 4294967295UL) >> 17)) + D;
#line 179
  B += ((D ^ (C | ~ A)) + X[13]) + 1309151649UL;
#line 179
  B = ((B << 21) | ((B & 4294967295UL) >> 11)) + C;
#line 180
  A += ((C ^ (B | ~ D)) + X[4]) + 4149444226UL;
#line 180
  A = ((A << 6) | ((A & 4294967295UL) >> 26)) + B;
#line 181
  D += ((B ^ (A | ~ C)) + X[11]) + 3174756917UL;
#line 181
  D = ((D << 10) | ((D & 4294967295UL) >> 22)) + A;
#line 182
  C += ((A ^ (D | ~ B)) + X[2]) + 718787259UL;
#line 182
  C = ((C << 15) | ((C & 4294967295UL) >> 17)) + D;
#line 183
  B += ((D ^ (C | ~ A)) + X[9]) + 3951481745UL;
#line 183
  B = ((B << 21) | ((B & 4294967295UL) >> 11)) + C;
#line 187
  ctx->state[0] += A;
#line 188
  ctx->state[1] += B;
#line 189
  ctx->state[2] += C;
#line 190
  ctx->state[3] += D;
#line 191
  return;
}
}
#line 196 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/md5.c"
void md5_update(md5_context *ctx , unsigned char const   *input , size_t ilen ) 
{ 
  size_t fill ;
  unsigned long left ;

  {
#line 201
  if (ilen <= 0UL) {
#line 202
    return;
  }
#line 204
  left = ctx->total[0] & 63UL;
#line 205
  fill = 64UL - left;
#line 207
  ctx->total[0] += ilen;
#line 208
  ctx->total[0] &= 4294967295UL;
#line 210
  if (ctx->total[0] < ilen) {
#line 211
    (ctx->total[1]) ++;
  }
#line 213
  if (left) {
#line 213
    if (ilen >= fill) {
      {
#line 215
      memcpy((void */* __restrict  */)((void *)(ctx->buffer + left)), (void const   */* __restrict  */)((void *)input),
             fill);
#line 217
      md5_process(ctx, (unsigned char const   *)(ctx->buffer));
#line 218
      input += fill;
#line 219
      ilen -= fill;
#line 220
      left = 0UL;
      }
    }
  }
  {
#line 223
  while (1) {
    while_continue: /* CIL Label */ ;
#line 223
    if (! (ilen >= 64UL)) {
#line 223
      goto while_break;
    }
    {
#line 225
    md5_process(ctx, (unsigned char const   *)input);
#line 226
    input += 64;
#line 227
    ilen -= 64UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 230
  if (ilen > 0UL) {
    {
#line 232
    memcpy((void */* __restrict  */)((void *)(ctx->buffer + left)), (void const   */* __restrict  */)((void *)input),
           ilen);
    }
  }
#line 235
  return;
}
}
#line 237 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/md5.c"
static unsigned char const   md5_padding[64]  = 
#line 237
  {      (unsigned char const   )128,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0};
#line 248 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/md5.c"
void md5_finish(md5_context *ctx , unsigned char *output ) 
{ 
  unsigned long last ;
  unsigned long padn ;
  unsigned long high ;
  unsigned long low ;
  unsigned char msglen[8] ;

  {
#line 254
  high = (ctx->total[0] >> 29) | (ctx->total[1] << 3);
#line 256
  low = ctx->total[0] << 3;
#line 258
  msglen[0] = (unsigned char )low;
#line 258
  msglen[1] = (unsigned char )(low >> 8);
#line 258
  msglen[2] = (unsigned char )(low >> 16);
#line 258
  msglen[3] = (unsigned char )(low >> 24);
#line 259
  msglen[4] = (unsigned char )high;
#line 259
  msglen[5] = (unsigned char )(high >> 8);
#line 259
  msglen[6] = (unsigned char )(high >> 16);
#line 259
  msglen[7] = (unsigned char )(high >> 24);
#line 261
  last = ctx->total[0] & 63UL;
#line 262
  if (last < 56UL) {
#line 262
    padn = 56UL - last;
  } else {
#line 262
    padn = 120UL - last;
  }
  {
#line 264
  md5_update(ctx, (unsigned char const   *)((unsigned char *)(md5_padding)), padn);
#line 265
  md5_update(ctx, (unsigned char const   *)(msglen), (size_t )8);
#line 267
  *(output + 0) = (unsigned char )ctx->state[0];
#line 267
  *(output + 1) = (unsigned char )(ctx->state[0] >> 8);
#line 267
  *(output + 2) = (unsigned char )(ctx->state[0] >> 16);
#line 267
  *(output + 3) = (unsigned char )(ctx->state[0] >> 24);
#line 268
  *(output + 4) = (unsigned char )ctx->state[1];
#line 268
  *(output + 5) = (unsigned char )(ctx->state[1] >> 8);
#line 268
  *(output + 6) = (unsigned char )(ctx->state[1] >> 16);
#line 268
  *(output + 7) = (unsigned char )(ctx->state[1] >> 24);
#line 269
  *(output + 8) = (unsigned char )ctx->state[2];
#line 269
  *(output + 9) = (unsigned char )(ctx->state[2] >> 8);
#line 269
  *(output + 10) = (unsigned char )(ctx->state[2] >> 16);
#line 269
  *(output + 11) = (unsigned char )(ctx->state[2] >> 24);
#line 270
  *(output + 12) = (unsigned char )ctx->state[3];
#line 270
  *(output + 13) = (unsigned char )(ctx->state[3] >> 8);
#line 270
  *(output + 14) = (unsigned char )(ctx->state[3] >> 16);
#line 270
  *(output + 15) = (unsigned char )(ctx->state[3] >> 24);
  }
#line 271
  return;
}
}
#line 276 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/md5.c"
void md5(unsigned char const   *input , size_t ilen , unsigned char *output ) 
{ 
  md5_context ctx ;

  {
  {
#line 280
  md5_starts(& ctx);
#line 281
  md5_update(& ctx, input, ilen);
#line 282
  md5_finish(& ctx, output);
#line 284
  memset((void *)(& ctx), 0, sizeof(md5_context ));
  }
#line 285
  return;
}
}
#line 28 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/main.c"
int inadyn_main(int argc , char **argv ) 
{ 
  int restart ;
  BOOL os_handler_installed ;
  RC_TYPE rc ;
  DYN_DNS_CLIENT *p_dyndns ;
  char const   *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;

  {
#line 30
  restart = 0;
#line 31
  os_handler_installed = 0;
#line 32
  rc = (RC_TYPE )0;
#line 33
  p_dyndns = (DYN_DNS_CLIENT *)((void *)0);
  {
#line 35
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 38
    rc = dyn_dns_construct(& p_dyndns);
    }
#line 39
    if ((unsigned int )rc != 0U) {
#line 41
      goto while_break;
    }
#line 45
    if (! os_handler_installed) {
      {
#line 47
      rc = os_install_signal_handler((void *)p_dyndns);
      }
#line 48
      if ((unsigned int )rc != 0U) {
        {
#line 50
        tmp = errorcode_get_name(rc);
#line 50
        os_printf(4, (char *)"Failed installing OS signal handler: %s", tmp);
        }
#line 51
        goto while_break;
      }
#line 53
      os_handler_installed = 1;
    }
    {
#line 56
    tmp___0 = dyn_dns_main(p_dyndns, argc, argv);
#line 56
    rc = (RC_TYPE )tmp___0;
    }
#line 57
    if ((unsigned int )rc == 255U) {
      {
#line 59
      restart = 1;
#line 62
      rc = dyn_dns_destruct(p_dyndns);
      }
#line 63
      if ((unsigned int )rc != 0U) {
        {
#line 65
        tmp___1 = errorcode_get_name(rc);
#line 65
        os_printf(4, (char *)"Failed cleaning up before restart: %s, ignoring...",
                  tmp___1);
        }
      }
    } else {
#line 71
      restart = 0;
    }
#line 35
    if (! restart) {
#line 35
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 76
  if ((unsigned int )rc != 0U) {
    {
#line 78
    tmp___2 = errorcode_get_name(rc);
    }
#line 78
    if (restart) {
#line 78
      tmp___3 = "re";
    } else {
#line 78
      tmp___3 = "";
    }
    {
#line 78
    os_printf(4, (char *)"Failed %sstarting daemon: %s", tmp___3, tmp___2);
    }
  }
  {
#line 82
  dyn_dns_destruct(p_dyndns);
#line 83
  os_close_dbg_output();
  }
#line 85
  return ((int )rc);
}
}
#line 149 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern ssize_t send(int __fd , void const   *__buf , size_t __n , int __flags ) ;
#line 156
extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) ;
#line 379 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/ip.c"
RC_TYPE ip_construct(IP_SOCKET *p_self ) 
{ 


  {
#line 35
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 37
    return ((RC_TYPE )2);
  }
  {
#line 40
  memset((void *)p_self, 0, sizeof(IP_SOCKET ));
#line 42
  p_self->initialized = 0;
#line 43
  p_self->bound = 0;
#line 44
  p_self->socket = -1;
#line 45
  memset((void *)(& p_self->local_addr), 0, sizeof(p_self->local_addr));
#line 46
  memset((void *)(& p_self->remote_addr), 0, sizeof(p_self->remote_addr));
#line 47
  p_self->timeout = 20000;
  }
#line 49
  return ((RC_TYPE )0);
}
}
#line 55 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/ip.c"
RC_TYPE ip_destruct(IP_SOCKET *p_self ) 
{ 


  {
#line 57
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 59
    return ((RC_TYPE )0);
  }
#line 62
  if (p_self->initialized == 1) {
    {
#line 64
    ip_shutdown(p_self);
    }
  }
#line 67
  return ((RC_TYPE )0);
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/ip.c"
RC_TYPE ip_initialize(IP_SOCKET *p_self ) 
{ 
  RC_TYPE rc ;
  struct ifreq ifr ;
  struct sockaddr_in *addrp ;
  int sd ;
  int tmp ;
  int code ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int code___0 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int s ;
  char port[10] ;
  struct addrinfo hints ;
  struct addrinfo *result___0 ;
  char const   *tmp___6 ;

  {
#line 79
  rc = (RC_TYPE )0;
#line 81
  addrp = (struct sockaddr_in *)((void *)0);
#line 83
  if (p_self->initialized == 1) {
#line 85
    return ((RC_TYPE )0);
  }
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 90
    rc = os_ip_support_startup();
    }
#line 91
    if ((unsigned int )rc != 0U) {
#line 93
      goto while_break;
    }
#line 97
    if (p_self->ifname) {
      {
#line 99
      tmp = socket(2, 2, 0);
#line 99
      sd = tmp;
      }
#line 101
      if (sd < 0) {
        {
#line 103
        tmp___0 = os_get_socket_error();
#line 103
        code = tmp___0;
#line 105
        tmp___1 = strerror(code);
#line 105
        os_printf(4, (char *)"Failed opening network socket: %s", tmp___1);
#line 106
        rc = (RC_TYPE )23;
        }
#line 107
        goto while_break;
      }
      {
#line 110
      memset((void *)(& ifr), 0, sizeof(struct ifreq ));
#line 111
      strncpy((char */* __restrict  */)(ifr.ifr_ifrn.ifrn_name), (char const   */* __restrict  */)p_self->ifname,
              (size_t )16);
#line 112
      tmp___5 = ioctl(sd, 35093UL, & ifr);
      }
#line 112
      if (tmp___5 != -1) {
        {
#line 114
        p_self->local_addr.sin_family = (sa_family_t )2;
#line 115
        p_self->local_addr.sin_port = htons((uint16_t )0);
#line 116
        addrp = (struct sockaddr_in *)(& ifr.ifr_ifru.ifru_addr);
#line 117
        p_self->local_addr.sin_addr.s_addr = addrp->sin_addr.s_addr;
#line 118
        p_self->bound = 1;
#line 120
        tmp___2 = inet_ntoa(p_self->local_addr.sin_addr);
#line 120
        os_printf(6, (char *)"Bound to interface %s (IP# %s)", p_self->ifname, tmp___2);
        }
      } else {
        {
#line 124
        tmp___3 = os_get_socket_error();
#line 124
        code___0 = tmp___3;
#line 126
        tmp___4 = strerror(code___0);
#line 126
        os_printf(3, (char *)"Failed reading IP address of interface %s: %s", p_self->ifname,
                  tmp___4);
#line 127
        p_self->bound = 0;
        }
      }
      {
#line 129
      close(sd);
      }
    }
#line 133
    if ((unsigned long )p_self->p_remote_host_name != (unsigned long )((void *)0)) {
      {
#line 140
      __res_init();
#line 143
      memset((void *)(& hints), 0, sizeof(struct addrinfo ));
#line 144
      hints.ai_family = 2;
#line 145
      hints.ai_socktype = 2;
#line 146
      snprintf((char */* __restrict  */)(port), sizeof(port), (char const   */* __restrict  */)"%d",
               (int )p_self->port);
#line 148
      s = getaddrinfo((char const   */* __restrict  */)p_self->p_remote_host_name,
                      (char const   */* __restrict  */)(port), (struct addrinfo  const  */* __restrict  */)(& hints),
                      (struct addrinfo **/* __restrict  */)(& result___0));
      }
#line 149
      if (s != 0) {
        {
#line 151
        tmp___6 = gai_strerror(s);
#line 151
        os_printf(4, (char *)"Failed resolving hostname %s: %s", p_self->p_remote_host_name,
                  tmp___6);
#line 152
        rc = (RC_TYPE )18;
        }
#line 153
        goto while_break;
      } else
#line 149
      if (! result___0) {
        {
#line 151
        tmp___6 = gai_strerror(s);
#line 151
        os_printf(4, (char *)"Failed resolving hostname %s: %s", p_self->p_remote_host_name,
                  tmp___6);
#line 152
        rc = (RC_TYPE )18;
        }
#line 153
        goto while_break;
      }
      {
#line 159
      p_self->remote_addr = *(result___0->ai_addr);
#line 160
      p_self->remote_len = result___0->ai_addrlen;
#line 162
      freeaddrinfo(result___0);
      }
    }
#line 88
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 167
  if ((unsigned int )rc != 0U) {
    {
#line 169
    ip_shutdown(p_self);
    }
#line 170
    return (rc);
  }
#line 173
  p_self->initialized = 1;
#line 175
  return ((RC_TYPE )0);
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/ip.c"
RC_TYPE ip_shutdown(IP_SOCKET *p_self ) 
{ 


  {
#line 183
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 185
    return ((RC_TYPE )2);
  }
#line 188
  if (! p_self->initialized) {
#line 190
    return ((RC_TYPE )0);
  }
#line 193
  if (p_self->socket > -1) {
    {
#line 195
    close(p_self->socket);
#line 196
    p_self->socket = -1;
    }
  }
  {
#line 199
  os_ip_support_cleanup();
#line 201
  p_self->initialized = 0;
  }
#line 203
  return ((RC_TYPE )0);
}
}
#line 206 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/ip.c"
RC_TYPE ip_send(IP_SOCKET *p_self , char const   *p_buf , int len ) 
{ 
  int code ;
  int tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;

  {
#line 208
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 210
    return ((RC_TYPE )2);
  }
#line 213
  if (! p_self->initialized) {
#line 215
    return ((RC_TYPE )22);
  }
  {
#line 218
  tmp___1 = send(p_self->socket, (void const   *)((char *)p_buf), (size_t )len, 0);
  }
#line 218
  if (tmp___1 == -1L) {
    {
#line 220
    tmp = os_get_socket_error();
#line 220
    code = tmp;
#line 222
    tmp___0 = strerror(code);
#line 222
    os_printf(4, (char *)"Network error while sending query/update: %s", tmp___0);
    }
#line 223
    return ((RC_TYPE )20);
  }
#line 226
  return ((RC_TYPE )0);
}
}
#line 238 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/ip.c"
RC_TYPE ip_recv(IP_SOCKET *p_self , char *p_buf , int max_recv_len , int *p_recv_len ) 
{ 
  RC_TYPE rc ;
  int remaining_buf_len ;
  int total_recv_len ;
  int recv_len ;
  int chunk_size ;
  int tmp ;
  ssize_t tmp___0 ;
  int code ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 240
  rc = (RC_TYPE )0;
#line 241
  remaining_buf_len = max_recv_len;
#line 242
  total_recv_len = 0;
#line 243
  recv_len = 0;
#line 245
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 247
    return ((RC_TYPE )2);
  } else
#line 245
  if ((unsigned long )p_buf == (unsigned long )((void *)0)) {
#line 247
    return ((RC_TYPE )2);
  } else
#line 245
  if ((unsigned long )p_recv_len == (unsigned long )((void *)0)) {
#line 247
    return ((RC_TYPE )2);
  }
#line 250
  if (! p_self->initialized) {
#line 252
    return ((RC_TYPE )22);
  }
  {
#line 255
  while (1) {
    while_continue: /* CIL Label */ ;
#line 255
    if (! (remaining_buf_len > 0)) {
#line 255
      goto while_break;
    }
#line 257
    if (remaining_buf_len > 100) {
#line 257
      tmp = 100;
    } else {
#line 257
      tmp = remaining_buf_len;
    }
    {
#line 257
    chunk_size = tmp;
#line 260
    tmp___0 = recv(p_self->socket, (void *)(p_buf + total_recv_len), (size_t )chunk_size,
                   0);
#line 260
    recv_len = (int )tmp___0;
    }
#line 261
    if (recv_len < 0) {
      {
#line 263
      tmp___1 = os_get_socket_error();
#line 263
      code = tmp___1;
#line 265
      tmp___2 = strerror(code);
#line 265
      os_printf(4, (char *)"Network error while waiting for reply: %s", tmp___2);
#line 266
      rc = (RC_TYPE )21;
      }
#line 267
      goto while_break;
    }
#line 270
    if (recv_len == 0) {
#line 272
      if (total_recv_len == 0) {
#line 274
        rc = (RC_TYPE )21;
      }
#line 276
      goto while_break;
    }
#line 279
    total_recv_len += recv_len;
#line 280
    remaining_buf_len = max_recv_len - total_recv_len;
  }
  while_break: /* CIL Label */ ;
  }
#line 283
  *p_recv_len = total_recv_len;
#line 285
  return (rc);
}
}
#line 291 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/ip.c"
RC_TYPE ip_set_port(IP_SOCKET *p_self , int p ) 
{ 


  {
#line 293
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 295
    return ((RC_TYPE )2);
  }
#line 298
  if (p < 0) {
#line 300
    return ((RC_TYPE )17);
  } else
#line 298
  if (p > 65535) {
#line 300
    return ((RC_TYPE )17);
  }
#line 303
  p_self->port = (unsigned short )p;
#line 305
  return ((RC_TYPE )0);
}
}
#line 308 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/ip.c"
RC_TYPE ip_set_remote_name(IP_SOCKET *p_self , char const   *p ) 
{ 


  {
#line 310
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 312
    return ((RC_TYPE )2);
  }
#line 315
  p_self->p_remote_host_name = p;
#line 317
  return ((RC_TYPE )0);
}
}
#line 320 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/ip.c"
RC_TYPE ip_set_remote_timeout(IP_SOCKET *p_self , int t ) 
{ 


  {
#line 322
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 324
    return ((RC_TYPE )2);
  }
#line 327
  p_self->timeout = t;
#line 329
  return ((RC_TYPE )0);
}
}
#line 332 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/ip.c"
RC_TYPE ip_set_bind_iface(IP_SOCKET *p_self , char *ifname ) 
{ 


  {
#line 334
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 336
    return ((RC_TYPE )2);
  }
#line 339
  p_self->ifname = ifname;
#line 341
  return ((RC_TYPE )0);
}
}
#line 344 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/ip.c"
RC_TYPE ip_get_port(IP_SOCKET *p_self , int *p_port ) 
{ 


  {
#line 346
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 348
    return ((RC_TYPE )2);
  } else
#line 346
  if ((unsigned long )p_port == (unsigned long )((void *)0)) {
#line 348
    return ((RC_TYPE )2);
  }
#line 351
  *p_port = (int )p_self->port;
#line 353
  return ((RC_TYPE )0);
}
}
#line 356 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/ip.c"
RC_TYPE ip_get_remote_name(IP_SOCKET *p_self , char const   **p ) 
{ 


  {
#line 358
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 360
    return ((RC_TYPE )2);
  } else
#line 358
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 360
    return ((RC_TYPE )2);
  }
#line 363
  *p = p_self->p_remote_host_name;
#line 365
  return ((RC_TYPE )0);
}
}
#line 368 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/ip.c"
RC_TYPE ip_get_remote_timeout(IP_SOCKET *p_self , int *p ) 
{ 


  {
#line 370
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 372
    return ((RC_TYPE )2);
  } else
#line 370
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 372
    return ((RC_TYPE )2);
  }
#line 375
  *p = p_self->timeout;
#line 377
  return ((RC_TYPE )0);
}
}
#line 380 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/ip.c"
RC_TYPE ip_get_bind_iface(IP_SOCKET *p_self , char **ifname ) 
{ 


  {
#line 382
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 384
    return ((RC_TYPE )2);
  } else
#line 382
  if ((unsigned long )ifname == (unsigned long )((void *)0)) {
#line 384
    return ((RC_TYPE )2);
  }
#line 387
  *ifname = p_self->ifname;
#line 389
  return ((RC_TYPE )0);
}
}
#line 87 "include/http_client.h"
RC_TYPE http_client_set_remote_timeout(HTTP_CLIENT *p_self , int p ) ;
#line 90
RC_TYPE http_client_get_port(HTTP_CLIENT *p_self , int *p ) ;
#line 91
RC_TYPE http_client_get_remote_name(HTTP_CLIENT *p_self , char const   **p ) ;
#line 92
RC_TYPE http_client_get_remote_timeout(HTTP_CLIENT *p_self , int *p ) ;
#line 93
RC_TYPE http_client_get_bind_iface(HTTP_CLIENT *p_self , char **ifname ) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/http_client.c"
RC_TYPE http_client_construct(HTTP_CLIENT *p_self ) 
{ 
  RC_TYPE rc ;

  {
#line 35
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 37
    return ((RC_TYPE )2);
  }
  {
#line 40
  rc = tcp_construct(& p_self->super);
  }
#line 41
  if ((unsigned int )rc != 0U) {
#line 43
    return (rc);
  }
  {
#line 47
  memset((void *)((char *)p_self + sizeof(p_self->super)), 0, sizeof(*p_self) - sizeof(p_self->super));
#line 48
  p_self->initialized = 0;
  }
#line 50
  return ((RC_TYPE )0);
}
}
#line 56 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/http_client.c"
RC_TYPE http_client_destruct(HTTP_CLIENT *p_self , int num ) 
{ 
  int i ;
  int rv ;
  int tmp ;
  RC_TYPE tmp___0 ;

  {
#line 58
  i = 0;
#line 58
  rv = 0;
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 60
    if (! (i < num)) {
#line 60
      goto while_break;
    }
    {
#line 62
    tmp = i;
#line 62
    i ++;
#line 62
    tmp___0 = tcp_destruct(& (p_self + tmp)->super);
#line 62
    rv = (int )tmp___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 65
  return ((RC_TYPE )rv);
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/http_client.c"
static RC_TYPE local_set_params___0(HTTP_CLIENT *p_self ) 
{ 
  int timeout ;
  int port ;

  {
  {
#line 72
  timeout = 0;
#line 75
  http_client_get_remote_timeout(p_self, & timeout);
  }
#line 76
  if (timeout == 0) {
    {
#line 78
    http_client_set_remote_timeout(p_self, 10000);
    }
  }
  {
#line 81
  http_client_get_port(p_self, & port);
  }
#line 82
  if (port == 0) {
    {
#line 84
    http_client_set_port(p_self, 80);
    }
  }
#line 87
  return ((RC_TYPE )0);
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/http_client.c"
RC_TYPE http_client_init(HTTP_CLIENT *p_self , char *msg ) 
{ 
  RC_TYPE rc ;

  {
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 101
    rc = local_set_params___0(p_self);
    }
#line 102
    if ((unsigned int )rc != 0U) {
#line 104
      goto while_break;
    }
    {
#line 107
    rc = tcp_initialize(& p_self->super, msg);
    }
#line 108
    if ((unsigned int )rc != 0U) {
#line 110
      goto while_break;
    }
#line 99
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 115
  if ((unsigned int )rc != 0U) {
    {
#line 117
    http_client_shutdown(p_self);
    }
#line 118
    return (rc);
  }
#line 121
  p_self->initialized = 1;
#line 123
  return ((RC_TYPE )0);
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/http_client.c"
RC_TYPE http_client_shutdown(HTTP_CLIENT *p_self ) 
{ 
  RC_TYPE tmp ;

  {
#line 131
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 133
    return ((RC_TYPE )2);
  }
#line 136
  if (! p_self->initialized) {
#line 138
    return ((RC_TYPE )0);
  }
  {
#line 141
  p_self->initialized = 0;
#line 143
  tmp = tcp_shutdown(& p_self->super);
  }
#line 143
  return (tmp);
}
}
#line 146 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/http_client.c"
static void http_response_parse(HTTP_TRANSACTION *p_tr ) 
{ 
  char *body ;
  char *rsp ;
  char *tmp ;
  int status ;
  int tmp___0 ;
  char sep[5] ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
  {
#line 148
  tmp = p_tr->p_rsp;
#line 148
  p_tr->p_rsp_body = tmp;
#line 148
  rsp = tmp;
#line 149
  tmp___0 = 0;
#line 149
  p_tr->status = tmp___0;
#line 149
  status = tmp___0;
#line 150
  memset((void *)(p_tr->status_desc), 0, sizeof(p_tr->status_desc));
#line 151
  sep[0] = (char )'\r';
#line 151
  sep[1] = (char )'\n';
#line 151
  sep[2] = (char )'\r';
#line 151
  sep[3] = (char )'\n';
#line 151
  sep[4] = (char )'\000';
  }
#line 152
  if ((unsigned long )rsp != (unsigned long )((void *)0)) {
    {
#line 152
    body = strstr((char const   *)rsp, (char const   *)(sep));
    }
#line 152
    if ((unsigned long )body != (unsigned long )((void *)0)) {
      {
#line 153
      tmp___1 = strlen((char const   *)(sep));
#line 153
      body += tmp___1;
#line 154
      p_tr->p_rsp_body = body;
      }
    }
  }
  {
#line 156
  tmp___2 = sscanf((char const   */* __restrict  */)p_tr->p_rsp, (char const   */* __restrict  */)"HTTP/1.%*c %d %255[^\r\n]",
                   & status, p_tr->status_desc);
  }
#line 156
  if (tmp___2 == 2) {
#line 157
    p_tr->status = status;
  }
#line 158
  return;
}
}
#line 161 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/http_client.c"
RC_TYPE http_client_transaction(HTTP_CLIENT *p_self , HTTP_TRANSACTION *p_tr ) 
{ 
  RC_TYPE rc ;

  {
#line 164
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 166
    return ((RC_TYPE )2);
  } else
#line 164
  if ((unsigned long )p_tr == (unsigned long )((void *)0)) {
#line 166
    return ((RC_TYPE )2);
  }
#line 169
  if (! p_self->initialized) {
#line 171
    return ((RC_TYPE )48);
  }
  {
#line 174
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 176
    rc = tcp_send(& p_self->super, (char const   *)p_tr->p_req, p_tr->req_len);
    }
#line 177
    if ((unsigned int )rc != 0U) {
#line 179
      goto while_break;
    }
    {
#line 182
    rc = tcp_recv(& p_self->super, p_tr->p_rsp, p_tr->max_rsp_len, & p_tr->rsp_len);
    }
#line 174
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 186
  http_response_parse(p_tr);
  }
#line 188
  return (rc);
}
}
#line 193 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/http_client.c"
RC_TYPE http_client_set_port(HTTP_CLIENT *p_self , int p ) 
{ 
  RC_TYPE tmp ;

  {
#line 195
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 197
    return ((RC_TYPE )2);
  }
  {
#line 200
  tmp = tcp_set_port(& p_self->super, p);
  }
#line 200
  return (tmp);
}
}
#line 203 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/http_client.c"
RC_TYPE http_client_set_remote_name(HTTP_CLIENT *p_self , char const   *p ) 
{ 
  RC_TYPE tmp ;

  {
#line 205
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 207
    return ((RC_TYPE )2);
  }
  {
#line 210
  tmp = tcp_set_remote_name(& p_self->super, p);
  }
#line 210
  return (tmp);
}
}
#line 213 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/http_client.c"
RC_TYPE http_client_set_remote_timeout(HTTP_CLIENT *p_self , int p ) 
{ 
  RC_TYPE tmp ;

  {
#line 215
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 217
    return ((RC_TYPE )2);
  }
  {
#line 220
  tmp = tcp_set_remote_timeout(& p_self->super, p);
  }
#line 220
  return (tmp);
}
}
#line 223 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/http_client.c"
RC_TYPE http_client_set_bind_iface(HTTP_CLIENT *p_self , char *ifname ) 
{ 
  RC_TYPE tmp ;

  {
#line 225
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 227
    return ((RC_TYPE )2);
  }
  {
#line 230
  tmp = tcp_set_bind_iface(& p_self->super, ifname);
  }
#line 230
  return (tmp);
}
}
#line 233 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/http_client.c"
RC_TYPE http_client_get_port(HTTP_CLIENT *p_self , int *p ) 
{ 
  RC_TYPE tmp ;

  {
#line 235
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 237
    return ((RC_TYPE )2);
  }
  {
#line 240
  tmp = tcp_get_port(& p_self->super, p);
  }
#line 240
  return (tmp);
}
}
#line 243 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/http_client.c"
RC_TYPE http_client_get_remote_name(HTTP_CLIENT *p_self , char const   **p ) 
{ 
  RC_TYPE tmp ;

  {
#line 245
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 247
    return ((RC_TYPE )2);
  }
  {
#line 250
  tmp = tcp_get_remote_name(& p_self->super, p);
  }
#line 250
  return (tmp);
}
}
#line 253 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/http_client.c"
RC_TYPE http_client_get_remote_timeout(HTTP_CLIENT *p_self , int *p ) 
{ 
  RC_TYPE tmp ;

  {
#line 255
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 257
    return ((RC_TYPE )2);
  }
  {
#line 260
  tmp = tcp_get_remote_timeout(& p_self->super, p);
  }
#line 260
  return (tmp);
}
}
#line 263 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/http_client.c"
RC_TYPE http_client_get_bind_iface(HTTP_CLIENT *p_self , char **ifname ) 
{ 
  RC_TYPE tmp ;

  {
#line 265
  if ((unsigned long )p_self == (unsigned long )((void *)0)) {
#line 267
    return ((RC_TYPE )2);
  } else
#line 265
  if ((unsigned long )ifname == (unsigned long )((void *)0)) {
#line 267
    return ((RC_TYPE )2);
  }
  {
#line 270
  tmp = tcp_get_bind_iface(& p_self->super, ifname);
  }
#line 270
  return (tmp);
}
}
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/get_cmd.c"
static CMD_DESCRIPTION_TYPE *opt_search(CMD_DESCRIPTION_TYPE *p_table , char *p_opt ) 
{ 
  CMD_DESCRIPTION_TYPE *it ;
  int tmp ;

  {
#line 36
  it = p_table;
  {
#line 38
  while (1) {
    while_continue: /* CIL Label */ ;
#line 38
    if (! ((unsigned long )it->p_option != (unsigned long )((void *)0))) {
#line 38
      goto while_break;
    }
    {
#line 40
    tmp = strcmp((char const   *)p_opt, (char const   *)it->p_option);
    }
#line 40
    if (tmp == 0) {
#line 42
      return (it);
    }
#line 44
    it ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 47
  return ((CMD_DESCRIPTION_TYPE *)((void *)0));
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/get_cmd.c"
RC_TYPE cmd_init(CMD_DATA *p_cmd ) 
{ 


  {
#line 55
  if (! p_cmd) {
#line 57
    return ((RC_TYPE )2);
  }
  {
#line 60
  memset((void *)p_cmd, 0, sizeof(*p_cmd));
  }
#line 62
  return ((RC_TYPE )0);
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/get_cmd.c"
RC_TYPE cmd_destruct(CMD_DATA *p_cmd ) 
{ 
  int i ;

  {
#line 67
  if (! p_cmd) {
#line 69
    return ((RC_TYPE )2);
  }
#line 72
  if (p_cmd->argv) {
#line 76
    i = 0;
    {
#line 76
    while (1) {
      while_continue: /* CIL Label */ ;
#line 76
      if (! (i < p_cmd->argc)) {
#line 76
        goto while_break;
      }
#line 78
      if (*(p_cmd->argv + i)) {
        {
#line 80
        free((void *)*(p_cmd->argv + i));
        }
      }
#line 76
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 83
    free((void *)p_cmd->argv);
    }
  }
#line 86
  return ((RC_TYPE )0);
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/get_cmd.c"
RC_TYPE cmd_add_val(CMD_DATA *p_cmd , char *p_val ) 
{ 
  RC_TYPE rc ;
  char *p ;
  char **pp ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 93
  rc = (RC_TYPE )0;
#line 95
  if (! p_cmd) {
#line 97
    return ((RC_TYPE )2);
  } else
#line 95
  if (! p_val) {
#line 97
    return ((RC_TYPE )2);
  }
  {
#line 100
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 103
    tmp = realloc((void *)p_cmd->argv, (unsigned long )(p_cmd->argc + 1) * sizeof(char *));
#line 103
    pp = (char **)tmp;
    }
#line 104
    if (! pp) {
#line 106
      rc = (RC_TYPE )3;
#line 107
      goto while_break;
    }
    {
#line 109
    p_cmd->argv = pp;
#line 111
    tmp___0 = strlen((char const   *)p_val);
#line 111
    tmp___1 = malloc(tmp___0 + 1UL);
#line 111
    p = (char *)tmp___1;
    }
#line 112
    if (! p) {
#line 114
      rc = (RC_TYPE )3;
#line 115
      goto while_break;
    }
    {
#line 118
    strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)p_val);
#line 119
    *(p_cmd->argv + p_cmd->argc) = p;
#line 120
    (p_cmd->argc) ++;
    }
#line 100
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 124
  return (rc);
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/get_cmd.c"
RC_TYPE cmd_add_vals_from_argv(CMD_DATA *p_cmd , char **argv , int argc ) 
{ 
  int i ;
  RC_TYPE rc ;

  {
#line 134
  rc = (RC_TYPE )0;
#line 136
  if (! p_cmd) {
#line 138
    return ((RC_TYPE )2);
  } else
#line 136
  if (! argv) {
#line 138
    return ((RC_TYPE )2);
  } else
#line 136
  if (! argc) {
#line 138
    return ((RC_TYPE )2);
  }
#line 141
  i = 0;
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 141
    if (! (i < argc)) {
#line 141
      goto while_break;
    }
    {
#line 143
    rc = cmd_add_val(p_cmd, *(argv + i));
    }
#line 144
    if ((unsigned int )rc != 0U) {
#line 145
      goto while_break;
    }
#line 141
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 148
  return (rc);
}
}
#line 169 "/home/june/repo/benchmarks/collector/temp/inadyn-1.99.4/src/get_cmd.c"
RC_TYPE get_cmd_parse_data(char **argv , int argc , CMD_DESCRIPTION_TYPE *p_cmd_descr ) 
{ 
  RC_TYPE rc ;
  CMD_DATA cmd ;
  int curr_arg_nr ;
  CMD_DESCRIPTION_TYPE *p_curr_opt ;
  CMD_DESCRIPTION_TYPE *tmp ;

  {
#line 171
  rc = (RC_TYPE )0;
#line 173
  curr_arg_nr = 1;
#line 175
  if ((unsigned long )argv == (unsigned long )((void *)0)) {
#line 177
    return ((RC_TYPE )2);
  } else
#line 175
  if ((unsigned long )p_cmd_descr == (unsigned long )((void *)0)) {
#line 177
    return ((RC_TYPE )2);
  }
  {
#line 180
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 182
    rc = cmd_init(& cmd);
    }
#line 183
    if ((unsigned int )rc != 0U) {
#line 185
      goto while_break;
    }
    {
#line 188
    rc = cmd_add_vals_from_argv(& cmd, argv, argc);
    }
#line 189
    if ((unsigned int )rc != 0U) {
#line 191
      goto while_break;
    }
    {
#line 194
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 194
      if (! (curr_arg_nr < cmd.argc)) {
#line 194
        goto while_break___0;
      }
      {
#line 196
      tmp = opt_search(p_cmd_descr, *(cmd.argv + curr_arg_nr));
#line 196
      p_curr_opt = tmp;
      }
#line 198
      if ((unsigned long )p_curr_opt == (unsigned long )((void *)0)) {
        {
#line 200
        rc = (RC_TYPE )80;
#line 201
        os_printf(4, (char *)"Invalid option name at position %d: %s", curr_arg_nr + 1,
                  *(cmd.argv + curr_arg_nr));
        }
#line 203
        goto while_break___0;
      }
#line 208
      curr_arg_nr ++;
#line 211
      if (curr_arg_nr + p_curr_opt->arg_nr > cmd.argc) {
        {
#line 213
        rc = (RC_TYPE )81;
#line 214
        os_printf(4, (char *)"Missing option value at position %d: %s", curr_arg_nr + 1,
                  p_curr_opt->p_option);
        }
#line 216
        goto while_break___0;
      }
      {
#line 219
      rc = (*(p_curr_opt->p_handler.p_func))(& cmd, curr_arg_nr, p_curr_opt->p_handler.p_context);
      }
#line 220
      if ((unsigned int )rc != 0U) {
        {
#line 222
        os_printf(4, (char *)"Error parsing option %s", *(cmd.argv + (curr_arg_nr - 1)));
        }
#line 223
        goto while_break___0;
      }
#line 226
      curr_arg_nr += p_curr_opt->arg_nr;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 180
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 231
  cmd_destruct(& cmd);
  }
#line 233
  return (rc);
}
}
