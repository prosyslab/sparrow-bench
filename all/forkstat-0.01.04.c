/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 55 "/usr/include/stdint.h"
typedef unsigned long uint64_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 43 "/usr/include/x86_64-linux-gnu/bits/uio.h"
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 20 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 23 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 26 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 30 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
#line 27 "/usr/include/asm-generic/posix_types.h"
typedef int __kernel_pid_t;
#line 64 "/usr/include/linux/connector.h"
struct cb_id {
   __u32 idx ;
   __u32 val ;
};
#line 69 "/usr/include/linux/connector.h"
struct cn_msg {
   struct cb_id id ;
   __u32 seq ;
   __u32 ack ;
   __u16 len ;
   __u16 flags ;
   __u8 data[0] ;
};
#line 11 "/usr/include/linux/socket.h"
typedef unsigned short __kernel_sa_family_t;
#line 35 "/usr/include/linux/netlink.h"
struct sockaddr_nl {
   __kernel_sa_family_t nl_family ;
   unsigned short nl_pad ;
   __u32 nl_pid ;
   __u32 nl_groups ;
};
#line 42 "/usr/include/linux/netlink.h"
struct nlmsghdr {
   __u32 nlmsg_len ;
   __u16 nlmsg_type ;
   __u16 nlmsg_flags ;
   __u32 nlmsg_seq ;
   __u32 nlmsg_pid ;
};
#line 27 "/usr/include/linux/cn_proc.h"
enum proc_cn_mcast_op {
    PROC_CN_MCAST_LISTEN = 1,
    PROC_CN_MCAST_IGNORE = 2
} ;
#line 45
enum what {
    PROC_EVENT_NONE = 0,
    PROC_EVENT_FORK = 1,
    PROC_EVENT_EXEC = 2,
    PROC_EVENT_UID = 4,
    PROC_EVENT_GID = 64,
    PROC_EVENT_SID = 128,
    PROC_EVENT_PTRACE = 256,
    PROC_EVENT_COMM = 512,
    PROC_EVENT_COREDUMP = 1073741824,
    PROC_EVENT_EXIT = 2147483648U
} ;
#line 45 "/usr/include/linux/cn_proc.h"
struct __anonstruct_ack_62 {
   __u32 err ;
};
#line 45 "/usr/include/linux/cn_proc.h"
struct fork_proc_event {
   __kernel_pid_t parent_pid ;
   __kernel_pid_t parent_tgid ;
   __kernel_pid_t child_pid ;
   __kernel_pid_t child_tgid ;
};
#line 45 "/usr/include/linux/cn_proc.h"
struct exec_proc_event {
   __kernel_pid_t process_pid ;
   __kernel_pid_t process_tgid ;
};
#line 45 "/usr/include/linux/cn_proc.h"
union __anonunion_r_63 {
   __u32 ruid ;
   __u32 rgid ;
};
#line 45 "/usr/include/linux/cn_proc.h"
union __anonunion_e_64 {
   __u32 euid ;
   __u32 egid ;
};
#line 45 "/usr/include/linux/cn_proc.h"
struct id_proc_event {
   __kernel_pid_t process_pid ;
   __kernel_pid_t process_tgid ;
   union __anonunion_r_63 r ;
   union __anonunion_e_64 e ;
};
#line 45 "/usr/include/linux/cn_proc.h"
struct sid_proc_event {
   __kernel_pid_t process_pid ;
   __kernel_pid_t process_tgid ;
};
#line 45 "/usr/include/linux/cn_proc.h"
struct ptrace_proc_event {
   __kernel_pid_t process_pid ;
   __kernel_pid_t process_tgid ;
   __kernel_pid_t tracer_pid ;
   __kernel_pid_t tracer_tgid ;
};
#line 45 "/usr/include/linux/cn_proc.h"
struct comm_proc_event {
   __kernel_pid_t process_pid ;
   __kernel_pid_t process_tgid ;
   char comm[16] ;
};
#line 45 "/usr/include/linux/cn_proc.h"
struct coredump_proc_event {
   __kernel_pid_t process_pid ;
   __kernel_pid_t process_tgid ;
};
#line 45 "/usr/include/linux/cn_proc.h"
struct exit_proc_event {
   __kernel_pid_t process_pid ;
   __kernel_pid_t process_tgid ;
   __u32 exit_code ;
   __u32 exit_signal ;
};
#line 45 "/usr/include/linux/cn_proc.h"
union __anonunion_event_data_61 {
   struct __anonstruct_ack_62 ack ;
   struct fork_proc_event fork ;
   struct exec_proc_event exec ;
   struct id_proc_event id ;
   struct sid_proc_event sid ;
   struct ptrace_proc_event ptrace ;
   struct comm_proc_event comm ;
   struct coredump_proc_event coredump ;
   struct exit_proc_event exit ;
};
#line 45 "/usr/include/linux/cn_proc.h"
struct proc_event {
   enum what what ;
   __u32 cpu ;
   __u64 __attribute__((__aligned__(8)))  timestamp_ns ;
   union __anonunion_event_data_61 event_data ;
};
#line 72 "/home/june/repo/benchmarks/collector/temp/forkstat-0.01.04/forkstat.c"
struct proc_info {
   pid_t pid ;
   char *cmdline ;
   _Bool kernel_thread ;
   struct timeval start ;
   struct proc_info *next ;
};
#line 72 "/home/june/repo/benchmarks/collector/temp/forkstat-0.01.04/forkstat.c"
typedef struct proc_info proc_info_t;
#line 81 "/home/june/repo/benchmarks/collector/temp/forkstat-0.01.04/forkstat.c"
struct __anonstruct_kernel_task_info_65 {
   char *task ;
   size_t len ;
};
#line 81 "/home/june/repo/benchmarks/collector/temp/forkstat-0.01.04/forkstat.c"
typedef struct __anonstruct_kernel_task_info_65 kernel_task_info;
#line 95 "/home/june/repo/benchmarks/collector/temp/forkstat-0.01.04/forkstat.c"
struct proc_stats {
   char *name ;
   uint64_t count[5] ;
   uint64_t total ;
   struct proc_stats *next ;
};
#line 95 "/home/june/repo/benchmarks/collector/temp/forkstat-0.01.04/forkstat.c"
typedef struct proc_stats proc_stats_t;
#line 102 "/home/june/repo/benchmarks/collector/temp/forkstat-0.01.04/forkstat.c"
struct __anonstruct_ev_map_t_67 {
   char const   *event ;
   char const   *label ;
   int const   flag ;
   int const   stat ;
};
#line 102 "/home/june/repo/benchmarks/collector/temp/forkstat-0.01.04/forkstat.c"
typedef struct __anonstruct_ev_map_t_67 ev_map_t;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 183
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 765
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 34 "/usr/include/libgen.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) __xpg_basename)(char *__path ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 359
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2,3), __leaf__)) strtok_r)(char * __restrict  __s ,
                                                                                                   char const   * __restrict  __delim ,
                                                                                                   char ** __restrict  __save_ptr ) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 432
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) alarm)(unsigned int __seconds ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 639
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpgid)(__pid_t __pid ) ;
#line 678
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 779
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 347
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) siginterrupt)(int __sig ,
                                                                                   int __interrupt ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 254
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime_r)(time_t const   * __restrict  __timer ,
                                                                                         struct tm * __restrict  __tp ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 50 "/usr/include/x86_64-linux-gnu/sys/uio.h"
extern ssize_t writev(int __fd , struct iovec  const  *__iovec , int __count ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 156
extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) ;
#line 109 "/home/june/repo/benchmarks/collector/temp/forkstat-0.01.04/forkstat.c"
static ev_map_t const   ev_map[7]  = {      {"fork", "Fork", (int const   )256, (int const   )0}, 
        {"exec", "Exec", (int const   )512, (int const   )1}, 
        {"exit", "Exit", (int const   )1024, (int const   )2}, 
        {"core", "Coredump", (int const   )2048, (int const   )3}, 
        {"comm", "Comm", (int const   )4096, (int const   )4}, 
        {"all", "", (int const   )7936, (int const   )0}, 
        {(char const   *)((void *)0), (char const   *)((void *)0), (int const   )0, (int const   )0}};
#line 121 "/home/june/repo/benchmarks/collector/temp/forkstat-0.01.04/forkstat.c"
static _Bool stop_recv  ;
#line 122 "/home/june/repo/benchmarks/collector/temp/forkstat-0.01.04/forkstat.c"
static _Bool sane_procs  ;
#line 123 "/home/june/repo/benchmarks/collector/temp/forkstat-0.01.04/forkstat.c"
static proc_info_t *proc_info[32769]  ;
#line 124 "/home/june/repo/benchmarks/collector/temp/forkstat-0.01.04/forkstat.c"
static proc_stats_t *proc_stats[32769]  ;
#line 125 "/home/june/repo/benchmarks/collector/temp/forkstat-0.01.04/forkstat.c"
static unsigned int opt_flags  =    1U;
#line 126 "/home/june/repo/benchmarks/collector/temp/forkstat-0.01.04/forkstat.c"
static int row  =    0;
#line 127 "/home/june/repo/benchmarks/collector/temp/forkstat-0.01.04/forkstat.c"
static long opt_duration  =    -1L;
#line 130 "/home/june/repo/benchmarks/collector/temp/forkstat-0.01.04/forkstat.c"
static proc_info_t no_info  =    {-1, (char *)"<unknown>", (_Bool)0, {(__time_t )0, (__suseconds_t )0}, (struct proc_info *)((void *)0)};
#line 138
static proc_info_t *proc_info_get(pid_t const   pid ) ;
#line 149
static _Bool sane_proc_pid_info(void) ;
#line 149 "/home/june/repo/benchmarks/collector/temp/forkstat-0.01.04/forkstat.c"
static char const   pattern[11]  = 
#line 149
  {      (char const   )'c',      (char const   )'o',      (char const   )'n',      (char const   )'t', 
        (char const   )'a',      (char const   )'i',      (char const   )'n',      (char const   )'e', 
        (char const   )'r',      (char const   )'=',      (char const   )'\000'};
#line 146 "/home/june/repo/benchmarks/collector/temp/forkstat-0.01.04/forkstat.c"
static _Bool sane_proc_pid_info(void) 
{ 
  FILE *fp ;
  char const   *ptr ;
  _Bool ret ;
  int ch ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 150
  ptr = pattern;
#line 151
  ret = (_Bool)1;
#line 153
  fp = fopen((char const   */* __restrict  */)"/proc/1/environ", (char const   */* __restrict  */)"r");
  }
#line 154
  if (! fp) {
#line 155
    return ((_Bool)0);
  }
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 157
    tmp___0 = feof(fp);
    }
#line 157
    if (tmp___0) {
#line 157
      goto while_break;
    }
    {
#line 158
    tmp = _IO_getc(fp);
#line 158
    ch = tmp;
    }
#line 160
    if ((int const   )*ptr == (int const   )ch) {
#line 161
      ptr ++;
#line 163
      if ((int const   )*ptr == 0) {
#line 164
        ret = (_Bool)0;
#line 165
        goto while_break;
      }
    } else {
      {
#line 169
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 170
        ch = _IO_getc(fp);
        }
#line 169
        if (ch != -1) {
#line 169
          if (! (ch != 0)) {
#line 169
            goto while_break___0;
          }
        } else {
#line 169
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 172
      ptr = pattern;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 176
  fclose(fp);
  }
#line 178
  return (ret);
}
}
#line 204
static _Bool pid_a_kernel_thread(char const   *task , pid_t const   id ) ;
#line 204 "/home/june/repo/benchmarks/collector/temp/forkstat-0.01.04/forkstat.c"
static kernel_task_info kernel_tasks[23]  = 
#line 204
  {      {(char *)"swapper/", sizeof("swapper/") - 1UL}, 
        {(char *)"kworker/", sizeof("kworker/") - 1UL}, 
        {(char *)"ksoftirqd/", sizeof("ksoftirqd/") - 1UL}, 
        {(char *)"watchdog/", sizeof("watchdog/") - 1UL}, 
        {(char *)"migration/", sizeof("migration/") - 1UL}, 
        {(char *)"irq/", sizeof("irq/") - 1UL}, 
        {(char *)"mmcqd/", sizeof("mmcqd/") - 1UL}, 
        {(char *)"jbd2/", sizeof("jbd2/") - 1UL}, 
        {(char *)"kthreadd", sizeof("kthreadd") - 1UL}, 
        {(char *)"kthrotld", sizeof("kthrotld") - 1UL}, 
        {(char *)"kswapd", sizeof("kswapd") - 1UL}, 
        {(char *)"ecryptfs-kthrea", sizeof("ecryptfs-kthrea") - 1UL}, 
        {(char *)"kauditd", sizeof("kauditd") - 1UL}, 
        {(char *)"kblockd", sizeof("kblockd") - 1UL}, 
        {(char *)"kcryptd", sizeof("kcryptd") - 1UL}, 
        {(char *)"kdevtmpfs", sizeof("kdevtmpfs") - 1UL}, 
        {(char *)"khelper", sizeof("khelper") - 1UL}, 
        {(char *)"khubd", sizeof("khubd") - 1UL}, 
        {(char *)"khugepaged", sizeof("khugepaged") - 1UL}, 
        {(char *)"khungtaskd", sizeof("khungtaskd") - 1UL}, 
        {(char *)"flush-", sizeof("flush-") - 1UL}, 
        {(char *)"bdi-default-", sizeof("bdi-default-") - 1UL}, 
        {(char *)((void *)0), (size_t )0}};
#line 185 "/home/june/repo/benchmarks/collector/temp/forkstat-0.01.04/forkstat.c"
static _Bool pid_a_kernel_thread(char const   *task , pid_t const   id ) 
{ 
  __pid_t tmp ;
  int i ;
  pid_t pgid ;
  __pid_t tmp___0 ;
  int tmp___1 ;

  {
#line 187
  if (sane_procs) {
    {
#line 188
    tmp = getpgid((__pid_t )id);
    }
#line 188
    return ((_Bool )(tmp == 0));
  } else {
    {
#line 192
    tmp___0 = getpgid((__pid_t )id);
#line 192
    pgid = tmp___0;
    }
#line 195
    if (pgid >= 0) {
#line 196
      return ((_Bool )(pgid == 0));
    }
#line 230
    i = 0;
    {
#line 230
    while (1) {
      while_continue: /* CIL Label */ ;
#line 230
      if (! ((unsigned long )kernel_tasks[i].task != (unsigned long )((void *)0))) {
#line 230
        goto while_break;
      }
      {
#line 231
      tmp___1 = strncmp(task, (char const   *)kernel_tasks[i].task, kernel_tasks[i].len);
      }
#line 231
      if (tmp___1 == 0) {
#line 232
        return ((_Bool)1);
      }
#line 230
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 235
  return ((_Bool)0);
}
}
#line 242 "/home/june/repo/benchmarks/collector/temp/forkstat-0.01.04/forkstat.c"
static int tty_height(void) 
{ 
  int fd ;
  struct winsize ws ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 245
  fd = 0;
#line 249
  tmp = isatty(fd);
  }
#line 249
  if (tmp) {
    {
#line 249
    tmp___0 = ioctl(fd, 21523UL, & ws);
    }
#line 249
    if (tmp___0 != -1) {
#line 249
      if (0 < (int )ws.ws_row) {
#line 249
        if ((size_t )ws.ws_row == (size_t )ws.ws_row) {
#line 253
          return ((int )ws.ws_row);
        }
      }
    }
  }
#line 255
  return (25);
}
}
#line 258 "/home/june/repo/benchmarks/collector/temp/forkstat-0.01.04/forkstat.c"
static void print_heading(void) 
{ 


  {
#line 260
  if (opt_flags & 16U) {
#line 261
    return;
  }
  {
#line 263
  printf((char const   */* __restrict  */)"Time     Event  PID  Info  Duration Process\n");
  }
#line 264
  return;
}
}
#line 270 "/home/june/repo/benchmarks/collector/temp/forkstat-0.01.04/forkstat.c"
static void row_increment(void) 
{ 
  int tty_rows ;
  int tmp ;

  {
  {
#line 272
  tmp = tty_height();
#line 272
  tty_rows = tmp;
#line 274
  row ++;
  }
#line 275
  if (tty_rows > 2) {
#line 275
    if (row >= tty_rows) {
      {
#line 276
      print_heading();
#line 277
      row = 2;
      }
    }
  }
#line 279
  return;
}
}
#line 285 "/home/june/repo/benchmarks/collector/temp/forkstat-0.01.04/forkstat.c"
__inline static double timeval_to_double(struct timeval  const  *tv ) 
{ 


  {
#line 287
  return ((double )tv->tv_sec + (double )tv->tv_usec / 1000000.0);
}
}
#line 294 "/home/june/repo/benchmarks/collector/temp/forkstat-0.01.04/forkstat.c"
__inline static int proc_info_hash(pid_t const   pid ) 
{ 


  {
#line 296
  return ((int )(pid % 32769));
}
}
#line 303 "/home/june/repo/benchmarks/collector/temp/forkstat-0.01.04/forkstat.c"
__inline static int proc_name_hash(char const   *str ) 
{ 
  unsigned long h ;
  unsigned long g ;

  {
#line 305
  h = 0UL;
  {
#line 307
  while (1) {
    while_continue: /* CIL Label */ ;
#line 307
    if (! *str) {
#line 307
      goto while_break;
    }
#line 309
    h = (h << 4) + (unsigned long )*str;
#line 310
    g = h & 4026531840UL;
#line 310
    if (0UL != g) {
#line 311
      h ^= g >> 24;
#line 312
      h ^= g;
    }
#line 314
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 317
  return ((int )(h % 32769UL));
}
}
#line 320 "/home/june/repo/benchmarks/collector/temp/forkstat-0.01.04/forkstat.c"
static void proc_stats_account(pid_t pid , int event ) 
{ 
  int h ;
  char *name ;
  proc_stats_t *stats ;
  proc_info_t *info ;
  int tmp ;
  void *tmp___0 ;

  {
#line 327
  if (! (opt_flags & 8U)) {
#line 328
    return;
  }
  {
#line 330
  info = proc_info_get(pid);
  }
#line 331
  if ((unsigned long )info == (unsigned long )(& no_info)) {
#line 332
    return;
  }
  {
#line 334
  name = info->cmdline;
#line 335
  h = proc_name_hash((char const   *)name);
#line 336
  stats = proc_stats[h];
  }
  {
#line 338
  while (1) {
    while_continue: /* CIL Label */ ;
#line 338
    if (! stats) {
#line 338
      goto while_break;
    }
    {
#line 339
    tmp = strcmp((char const   *)stats->name, (char const   *)name);
    }
#line 339
    if (! tmp) {
#line 340
      (stats->count[event]) ++;
#line 341
      (stats->total) ++;
#line 342
      return;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 345
  tmp___0 = calloc((size_t )1, sizeof(*stats));
#line 345
  stats = (proc_stats_t *)tmp___0;
  }
#line 346
  if ((unsigned long )stats == (unsigned long )((void *)0)) {
#line 347
    return;
  }
  {
#line 349
  stats->name = strdup((char const   *)name);
  }
#line 350
  if ((unsigned long )stats->name == (unsigned long )((void *)0)) {
    {
#line 351
    free((void *)stats);
    }
#line 352
    return;
  }
#line 354
  (stats->count[event]) ++;
#line 355
  (stats->total) ++;
#line 356
  stats->next = proc_stats[h];
#line 357
  proc_stats[h] = stats;
#line 358
  return;
}
}
#line 360 "/home/june/repo/benchmarks/collector/temp/forkstat-0.01.04/forkstat.c"
int stats_cmp(void const   *v1 , void const   *v2 ) 
{ 
  proc_stats_t **s1 ;
  proc_stats_t **s2 ;

  {
#line 362
  s1 = (proc_stats_t **)v1;
#line 363
  s2 = (proc_stats_t **)v2;
#line 365
  return ((int )((*s2)->total - (*s1)->total));
}
}
#line 368 "/home/june/repo/benchmarks/collector/temp/forkstat-0.01.04/forkstat.c"
void proc_stats_report(void) 
{ 
  int i ;
  int n ;
  proc_stats_t *stats ;
  proc_stats_t **sorted ;
  void *tmp ;
  int tmp___0 ;
  int j ;

  {
#line 371
  n = 0;
#line 374
  if (! (opt_flags & 8U)) {
#line 375
    return;
  }
#line 377
  i = 0;
  {
#line 377
  while (1) {
    while_continue: /* CIL Label */ ;
#line 377
    if (! (i < 32769)) {
#line 377
      goto while_break;
    }
#line 378
    stats = proc_stats[i];
    {
#line 378
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 378
      if (! stats) {
#line 378
        goto while_break___0;
      }
#line 379
      n ++;
#line 378
      stats = stats->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 377
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 381
  if (! n) {
    {
#line 382
    printf((char const   */* __restrict  */)"\nNo statistics gathered.\n");
    }
#line 383
    return;
  }
  {
#line 386
  printf((char const   */* __restrict  */)"\n");
#line 387
  i = 0;
  }
  {
#line 387
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 387
    if (! (i < 5)) {
#line 387
      goto while_break___1;
    }
    {
#line 388
    printf((char const   */* __restrict  */)"%8s ", ev_map[i].label);
#line 387
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 389
  printf((char const   */* __restrict  */)"   Total Process\n");
#line 391
  tmp = calloc((size_t )n, sizeof(proc_stats_t *));
#line 391
  sorted = (proc_stats_t **)tmp;
  }
#line 392
  if ((unsigned long )sorted == (unsigned long )((void *)0)) {
    {
#line 393
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot sort statistics, out of memory.\n");
    }
#line 394
    return;
  }
#line 397
  n = 0;
#line 397
  i = 0;
  {
#line 397
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 397
    if (! (i < 32769)) {
#line 397
      goto while_break___2;
    }
#line 398
    stats = proc_stats[i];
    {
#line 398
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 398
      if (! stats) {
#line 398
        goto while_break___3;
      }
#line 399
      tmp___0 = n;
#line 399
      n ++;
#line 399
      *(sorted + tmp___0) = stats;
#line 398
      stats = stats->next;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 397
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 401
  qsort((void *)sorted, (size_t )n, sizeof(proc_stats_t *), & stats_cmp);
#line 402
  i = 0;
  }
  {
#line 402
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 402
    if (! (i < n)) {
#line 402
      goto while_break___4;
    }
#line 404
    stats = *(sorted + i);
#line 406
    j = 0;
    {
#line 406
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 406
      if (! (j < 5)) {
#line 406
        goto while_break___5;
      }
      {
#line 407
      printf((char const   */* __restrict  */)"%8lu ", stats->count[j]);
#line 406
      j ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 408
    printf((char const   */* __restrict  */)"%8lu %s\n", stats->total, stats->name);
#line 402
    i ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 410
  free((void *)sorted);
  }
#line 411
  return;
}
}
#line 413 "/home/june/repo/benchmarks/collector/temp/forkstat-0.01.04/forkstat.c"
void proc_stats_free(void) 
{ 
  int i ;
  proc_stats_t *stats ;
  proc_stats_t *next ;

  {
#line 417
  i = 0;
  {
#line 417
  while (1) {
    while_continue: /* CIL Label */ ;
#line 417
    if (! (i < 32769)) {
#line 417
      goto while_break;
    }
#line 418
    stats = proc_stats[i];
    {
#line 420
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 420
      if (! stats) {
#line 420
        goto while_break___0;
      }
      {
#line 421
      next = stats->next;
#line 423
      free((void *)stats->name);
#line 424
      free((void *)stats);
#line 426
      stats = next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 417
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 429
  return;
}
}
#line 435 "/home/june/repo/benchmarks/collector/temp/forkstat-0.01.04/forkstat.c"
static char *proc_comm(pid_t const   pid ) 
{ 
  char buffer[4096] ;
  int fd ;
  ssize_t ret ;
  char *tmp ;

  {
  {
#line 441
  snprintf((char */* __restrict  */)(buffer), sizeof(buffer), (char const   */* __restrict  */)"/proc/%d/comm",
           pid);
#line 442
  fd = open((char const   *)(buffer), 0);
  }
#line 442
  if (fd < 0) {
#line 443
    return ((char *)((void *)0));
  }
  {
#line 445
  ret = read(fd, (void *)(buffer), sizeof(buffer) - 1UL);
  }
#line 445
  if (ret <= 0L) {
    {
#line 446
    close(fd);
    }
#line 447
    return ((char *)((void *)0));
  }
  {
#line 449
  close(fd);
#line 450
  buffer[ret - 1L] = (char )'\000';
#line 451
  tmp = strdup((char const   *)(buffer));
  }
#line 451
  return (tmp);
}
}
#line 458 "/home/june/repo/benchmarks/collector/temp/forkstat-0.01.04/forkstat.c"
static char *proc_cmdline(pid_t const   pid ) 
{ 
  char buffer[4096] ;
  char *ptr ;
  int fd ;
  ssize_t ret ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 465
  snprintf((char */* __restrict  */)(buffer), sizeof(buffer), (char const   */* __restrict  */)"/proc/%d/cmdline",
           pid);
#line 466
  fd = open((char const   *)(buffer), 0);
  }
#line 466
  if (fd < 0) {
    {
#line 467
    tmp = proc_comm(pid);
    }
#line 467
    return (tmp);
  }
  {
#line 470
  memset((void *)(buffer), 0, sizeof(buffer));
#line 471
  ret = read(fd, (void *)(buffer), sizeof(buffer) - 1UL);
  }
#line 471
  if (ret <= 0L) {
    {
#line 472
    close(fd);
#line 473
    tmp___0 = proc_comm(pid);
    }
#line 473
    return (tmp___0);
  }
  {
#line 475
  close(fd);
#line 476
  buffer[ret] = (char )'\000';
  }
#line 481
  if (opt_flags & 1U) {
#line 482
    ptr = buffer;
    {
#line 482
    while (1) {
      while_continue: /* CIL Label */ ;
#line 482
      if (! ((unsigned long )ptr < (unsigned long )(buffer + ret))) {
#line 482
        goto while_break;
      }
#line 483
      if ((int )*ptr == 0) {
#line 484
        if ((int )*(ptr + 1) == 0) {
#line 485
          goto while_break;
        }
#line 486
        *ptr = (char )' ';
      }
#line 482
      ptr ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 493
  if (opt_flags & 2U) {
#line 494
    ptr = buffer;
    {
#line 494
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 494
      if (*ptr) {
#line 494
        if (! ((unsigned long )ptr < (unsigned long )(buffer + ret))) {
#line 494
          goto while_break___0;
        }
      } else {
#line 494
        goto while_break___0;
      }
#line 495
      if ((int )*ptr == 32) {
#line 496
        *ptr = (char )'\000';
#line 497
        goto while_break___0;
      }
#line 494
      ptr ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 502
  if (opt_flags & 4U) {
    {
#line 503
    tmp___1 = __xpg_basename(buffer);
#line 503
    tmp___2 = strdup((char const   *)tmp___1);
    }
#line 503
    return (tmp___2);
  }
  {
#line 505
  tmp___3 = strdup((char const   *)(buffer));
  }
#line 505
  return (tmp___3);
}
}
#line 512 "/home/june/repo/benchmarks/collector/temp/forkstat-0.01.04/forkstat.c"
static proc_info_t *proc_info_get(pid_t const   pid ) 
{ 
  int i ;
  int tmp ;
  proc_info_t *info ;

  {
  {
#line 514
  tmp = proc_info_hash(pid);
#line 514
  i = tmp;
#line 515
  info = proc_info[i];
  }
  {
#line 517
  while (1) {
    while_continue: /* CIL Label */ ;
#line 517
    if (! info) {
#line 517
      goto while_break;
    }
#line 518
    if ((proc_info[i])->pid == (pid_t )pid) {
#line 519
      return (info);
    }
#line 520
    info = info->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 522
  return (& no_info);
}
}
#line 529 "/home/june/repo/benchmarks/collector/temp/forkstat-0.01.04/forkstat.c"
static void proc_info_free(pid_t const   pid ) 
{ 
  int i ;
  int tmp ;
  proc_info_t *info ;

  {
  {
#line 531
  tmp = proc_info_hash(pid);
#line 531
  i = tmp;
#line 532
  info = proc_info[i];
  }
  {
#line 534
  while (1) {
    while_continue: /* CIL Label */ ;
#line 534
    if (! info) {
#line 534
      goto while_break;
    }
#line 535
    if (info->pid == (pid_t )pid) {
      {
#line 536
      info->pid = -1;
#line 537
      free((void *)info->cmdline);
#line 538
      info->cmdline = (char *)((void *)0);
      }
#line 539
      return;
    }
#line 541
    info = info->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 543
  return;
}
}
#line 549 "/home/june/repo/benchmarks/collector/temp/forkstat-0.01.04/forkstat.c"
static void proc_info_unload(void) 
{ 
  int i ;
  proc_info_t *info ;
  proc_info_t *next ;

  {
#line 553
  i = 0;
  {
#line 553
  while (1) {
    while_continue: /* CIL Label */ ;
#line 553
    if (! (i < 32769)) {
#line 553
      goto while_break;
    }
#line 554
    info = proc_info[i];
    {
#line 556
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 556
      if (! info) {
#line 556
        goto while_break___0;
      }
      {
#line 557
      next = info->next;
#line 558
      free((void *)info->cmdline);
#line 559
      free((void *)info);
#line 560
      info = next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 553
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 563
  return;
}
}
#line 569 "/home/june/repo/benchmarks/collector/temp/forkstat-0.01.04/forkstat.c"
static proc_info_t const   *proc_info_update(pid_t const   pid ) 
{ 
  proc_info_t *info ;
  proc_info_t *tmp ;
  char *newcmd ;

  {
  {
#line 571
  tmp = proc_info_get(pid);
#line 571
  info = tmp;
  }
#line 574
  if ((unsigned long )info == (unsigned long )(& no_info)) {
#line 575
    return ((proc_info_t const   *)(& no_info));
  }
  {
#line 576
  newcmd = proc_cmdline(pid);
  }
#line 576
  if ((unsigned long )newcmd == (unsigned long )((void *)0)) {
#line 577
    return ((proc_info_t const   *)(& no_info));
  }
  {
#line 579
  free((void *)info->cmdline);
#line 580
  info->cmdline = newcmd;
  }
#line 582
  return ((proc_info_t const   *)info);
}
}
#line 589 "/home/june/repo/benchmarks/collector/temp/forkstat-0.01.04/forkstat.c"
static proc_info_t *proc_info_add(pid_t const   pid , struct timeval *tv ) 
{ 
  int i ;
  int tmp ;
  proc_info_t *info ;
  char *cmdline ;
  void *tmp___0 ;

  {
  {
#line 591
  tmp = proc_info_hash(pid);
#line 591
  i = tmp;
#line 595
  cmdline = proc_cmdline(pid);
  }
#line 595
  if ((unsigned long )cmdline == (unsigned long )((void *)0)) {
    {
#line 596
    free((void *)cmdline);
    }
#line 597
    return ((proc_info_t *)((void *)0));
  }
#line 601
  info = proc_info[i];
  {
#line 602
  while (1) {
    while_continue: /* CIL Label */ ;
#line 602
    if (! info) {
#line 602
      goto while_break;
    }
#line 603
    if (info->pid == -1) {
#line 604
      goto while_break;
    }
#line 605
    info = info->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 608
  if ((unsigned long )info == (unsigned long )((void *)0)) {
    {
#line 609
    tmp___0 = calloc((size_t )1, sizeof(proc_info_t ));
#line 609
    info = (proc_info_t *)tmp___0;
    }
#line 609
    if ((unsigned long )info == (unsigned long )((void *)0)) {
      {
#line 610
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot allocate all proc info\n");
#line 611
      free((void *)cmdline);
      }
#line 612
      return ((proc_info_t *)((void *)0));
    }
#line 614
    info->next = proc_info[i];
#line 615
    proc_info[i] = info;
  }
  {
#line 617
  info->cmdline = cmdline;
#line 618
  info->pid = (pid_t )pid;
#line 619
  info->kernel_thread = pid_a_kernel_thread((char const   *)cmdline, pid);
  }
#line 621
  if (tv) {
#line 622
    info->start = *tv;
  } else {
#line 624
    info->start.tv_sec = (__time_t )0;
#line 625
    info->start.tv_usec = (__suseconds_t )0;
  }
#line 628
  return (info);
}
}
#line 635 "/home/june/repo/benchmarks/collector/temp/forkstat-0.01.04/forkstat.c"
static void proc_thread_info_add(pid_t pid ) 
{ 
  DIR *dir ;
  struct dirent *dirent ;
  char path[4096] ;
  pid_t tpid ;
  int tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 641
  snprintf((char */* __restrict  */)(path), sizeof(path), (char const   */* __restrict  */)"/proc/%i/task",
           pid);
#line 643
  dir = opendir((char const   *)(path));
  }
#line 643
  if ((unsigned long )dir == (unsigned long )((void *)0)) {
#line 644
    return;
  }
  {
#line 646
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 646
    dirent = readdir(dir);
    }
#line 646
    if (! dirent) {
#line 646
      goto while_break;
    }
    {
#line 647
    tmp___0 = __ctype_b_loc();
    }
#line 647
    if ((int const   )*(*tmp___0 + (int )dirent->d_name[0]) & 2048) {
      {
#line 648
      tmp = atoi((char const   *)(dirent->d_name));
#line 648
      tpid = tmp;
      }
#line 649
      if (tpid != pid) {
        {
#line 650
        proc_info_add((pid_t const   )tpid, (struct timeval *)((void *)0));
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 654
  closedir(dir);
  }
#line 655
  return;
}
}
#line 661 "/home/june/repo/benchmarks/collector/temp/forkstat-0.01.04/forkstat.c"
static int proc_info_load(void) 
{ 
  DIR *dir ;
  struct dirent *dirent ;
  pid_t pid ;
  int tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 666
  dir = opendir("/proc");
  }
#line 666
  if ((unsigned long )dir == (unsigned long )((void *)0)) {
#line 667
    return (-1);
  }
  {
#line 669
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 669
    dirent = readdir(dir);
    }
#line 669
    if (! dirent) {
#line 669
      goto while_break;
    }
    {
#line 670
    tmp___0 = __ctype_b_loc();
    }
#line 670
    if ((int const   )*(*tmp___0 + (int )dirent->d_name[0]) & 2048) {
      {
#line 671
      tmp = atoi((char const   *)(dirent->d_name));
#line 671
      pid = tmp;
#line 672
      proc_info_add((pid_t const   )pid, (struct timeval *)((void *)0));
#line 673
      proc_thread_info_add(pid);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 677
  closedir(dir);
  }
#line 678
  return (0);
}
}
#line 685 "/home/june/repo/benchmarks/collector/temp/forkstat-0.01.04/forkstat.c"
static void handle_sigstop(int dummy ) 
{ 


  {
#line 688
  stop_recv = (_Bool)1;
#line 689
  return;
}
}
#line 695 "/home/june/repo/benchmarks/collector/temp/forkstat-0.01.04/forkstat.c"
static int netlink_connect(void) 
{ 
  int sock ;
  struct sockaddr_nl addr ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  __pid_t tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 700
  sock = socket(16, 2, 11);
  }
#line 700
  if (sock < 0) {
    {
#line 701
    tmp = __errno_location();
    }
#line 701
    if (*tmp == 93) {
#line 702
      return (-93);
    }
    {
#line 703
    tmp___0 = __errno_location();
#line 703
    tmp___1 = strerror(*tmp___0);
#line 703
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Socket failed: %s\n",
            tmp___1);
    }
#line 704
    return (-1);
  }
  {
#line 707
  memset((void *)(& addr), 0, sizeof(addr));
#line 708
  tmp___2 = getpid();
#line 708
  addr.nl_pid = (__u32 )tmp___2;
#line 709
  addr.nl_family = (__kernel_sa_family_t )16;
#line 710
  addr.nl_groups = (__u32 )1;
#line 712
  tmp___5 = bind(sock, (struct sockaddr  const  *)((struct sockaddr *)(& addr)), (socklen_t )sizeof(addr));
  }
#line 712
  if (tmp___5 < 0) {
    {
#line 713
    tmp___3 = __errno_location();
#line 713
    tmp___4 = strerror(*tmp___3);
#line 713
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bind failed: %s\n",
            tmp___4);
#line 714
    close(sock);
    }
#line 715
    return (-1);
  }
#line 718
  return (sock);
}
}
#line 725 "/home/june/repo/benchmarks/collector/temp/forkstat-0.01.04/forkstat.c"
static int netlink_listen(int const   sock ) 
{ 
  struct iovec iov[3] ;
  struct nlmsghdr nlmsghdr ;
  struct cn_msg cn_msg ;
  enum proc_cn_mcast_op op ;
  __pid_t tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 732
  memset((void *)(& nlmsghdr), 0, sizeof(nlmsghdr));
#line 733
  nlmsghdr.nlmsg_len = (__u32 )((sizeof(cn_msg) + sizeof(op)) + (unsigned long )((int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL)));
#line 734
  tmp = getpid();
#line 734
  nlmsghdr.nlmsg_pid = (__u32 )tmp;
#line 735
  nlmsghdr.nlmsg_type = (__u16 )3;
#line 736
  iov[0].iov_base = (void *)(& nlmsghdr);
#line 737
  iov[0].iov_len = sizeof(nlmsghdr);
#line 739
  memset((void *)(& cn_msg), 0, sizeof(cn_msg));
#line 740
  cn_msg.id.idx = (__u32 )1;
#line 741
  cn_msg.id.val = (__u32 )1;
#line 742
  cn_msg.len = (__u16 )sizeof(enum proc_cn_mcast_op );
#line 743
  iov[1].iov_base = (void *)(& cn_msg);
#line 744
  iov[1].iov_len = sizeof(cn_msg);
#line 746
  op = (enum proc_cn_mcast_op )1;
#line 747
  iov[2].iov_base = (void *)(& op);
#line 748
  iov[2].iov_len = sizeof(op);
#line 750
  tmp___0 = writev((int )sock, (struct iovec  const  *)(iov), 3);
  }
#line 750
  return ((int )tmp___0);
}
}
#line 757 "/home/june/repo/benchmarks/collector/temp/forkstat-0.01.04/forkstat.c"
static int monitor(int const   sock ) 
{ 
  ssize_t len ;
  struct nlmsghdr *nlmsghdr ;
  char __attribute__((__aligned__(4)))  buf[4096] ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  struct cn_msg *cn_msg ;
  struct proc_event *proc_ev ;
  struct tm tm ;
  struct timeval tv ;
  time_t now ;
  char when[10] ;
  char duration[32] ;
  char *comm ;
  proc_info_t const   *info1 ;
  proc_info_t const   *info2 ;
  proc_info_t *tmp___2 ;
  proc_info_t *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  proc_info_t *tmp___10 ;
  double d1 ;
  double d2 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  proc_info_t *tmp___13 ;
  char const   *tmp___14 ;
  char const   *tmp___15 ;
  proc_info_t *tmp___16 ;
  char const   *tmp___17 ;
  char const   *tmp___18 ;

  {
  {
#line 762
  print_heading();
  }
  {
#line 764
  while (1) {
    while_continue: /* CIL Label */ ;
#line 764
    if (! (! stop_recv)) {
#line 764
      goto while_break;
    }
    {
#line 767
    len = recv((int )sock, (void *)(buf), sizeof(buf), 0);
    }
#line 767
    if (len == 0L) {
#line 768
      return (0);
    }
#line 770
    if (len == -1L) {
      {
#line 771
      tmp___1 = __errno_location();
      }
#line 771
      if (*tmp___1 == 4) {
#line 772
        return (0);
      } else {
        {
#line 774
        tmp = __errno_location();
#line 774
        tmp___0 = strerror(*tmp);
#line 774
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"recv: %s\n",
                tmp___0);
        }
#line 775
        return (-1);
      }
    }
#line 779
    nlmsghdr = (struct nlmsghdr *)(buf);
    {
#line 779
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 779
      if (len >= (ssize_t )((int )sizeof(struct nlmsghdr ))) {
#line 779
        if ((unsigned long )nlmsghdr->nlmsg_len >= sizeof(struct nlmsghdr )) {
#line 779
          if (! ((ssize_t )nlmsghdr->nlmsg_len <= len)) {
#line 779
            goto while_break___0;
          }
        } else {
#line 779
          goto while_break___0;
        }
      } else {
#line 779
        goto while_break___0;
      }
#line 793
      if ((int )nlmsghdr->nlmsg_type == 2) {
#line 795
        goto __Cont;
      } else
#line 793
      if ((int )nlmsghdr->nlmsg_type == 1) {
#line 795
        goto __Cont;
      }
#line 797
      cn_msg = (struct cn_msg *)((void *)((char *)nlmsghdr + (int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL)));
#line 798
      if (cn_msg->id.idx != 1U) {
#line 800
        goto __Cont;
      } else
#line 798
      if (cn_msg->id.val != 1U) {
#line 800
        goto __Cont;
      }
      {
#line 802
      proc_ev = (struct proc_event *)(cn_msg->data);
#line 804
      time(& now);
#line 805
      localtime_r((time_t const   */* __restrict  */)(& now), (struct tm */* __restrict  */)(& tm));
#line 807
      snprintf((char */* __restrict  */)(when), sizeof(when), (char const   */* __restrict  */)"%2.2d:%2.2d:%2.2d",
               tm.tm_hour, tm.tm_min, tm.tm_sec);
      }
      {
#line 811
      if ((unsigned int )proc_ev->what == 1U) {
#line 811
        goto case_1;
      }
#line 837
      if ((unsigned int )proc_ev->what == 2U) {
#line 837
        goto case_2;
      }
#line 851
      if ((unsigned int )proc_ev->what == 2147483648U) {
#line 851
        goto case_2147483648;
      }
#line 877
      if ((unsigned int )proc_ev->what == 1073741824U) {
#line 877
        goto case_1073741824;
      }
#line 891
      if ((unsigned int )proc_ev->what == 512U) {
#line 891
        goto case_512;
      }
#line 911
      goto switch_default;
      case_1: /* CIL Label */ 
      {
#line 812
      proc_stats_account(proc_ev->event_data.fork.parent_pid, 0);
#line 813
      gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
#line 814
      tmp___2 = proc_info_get((pid_t const   )proc_ev->event_data.fork.parent_pid);
#line 814
      info1 = (proc_info_t const   *)tmp___2;
#line 815
      tmp___3 = proc_info_add((pid_t const   )proc_ev->event_data.fork.child_pid,
                              & tv);
#line 815
      info2 = (proc_info_t const   *)tmp___3;
      }
#line 816
      if (! (opt_flags & 16U)) {
#line 816
        if (opt_flags & 256U) {
#line 817
          if ((unsigned long )info1 != (unsigned long )((void *)0)) {
#line 817
            if ((unsigned long )info2 != (unsigned long )((void *)0)) {
              {
#line 818
              row_increment();
              }
#line 819
              if (info1->kernel_thread) {
#line 819
                tmp___4 = "]";
              } else {
#line 819
                tmp___4 = "";
              }
#line 819
              if (info1->kernel_thread) {
#line 819
                tmp___5 = "[";
              } else {
#line 819
                tmp___5 = "";
              }
              {
#line 819
              printf((char const   */* __restrict  */)"%s fork %5d parent %8s %s%s%s\n",
                     when, proc_ev->event_data.fork.parent_pid, "", tmp___5, info1->cmdline,
                     tmp___4);
#line 826
              row_increment();
              }
#line 827
              if (info1->kernel_thread) {
#line 827
                tmp___6 = "]";
              } else {
#line 827
                tmp___6 = "";
              }
#line 827
              if (info1->kernel_thread) {
#line 827
                tmp___7 = "[";
              } else {
#line 827
                tmp___7 = "";
              }
              {
#line 827
              printf((char const   */* __restrict  */)"%s fork %5d child  %8s %s%s%s\n",
                     when, proc_ev->event_data.fork.child_pid, "", tmp___7, info2->cmdline,
                     tmp___6);
              }
            }
          }
        }
      }
#line 836
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 838
      proc_stats_account(proc_ev->event_data.exec.process_pid, 1);
#line 839
      info1 = proc_info_update((pid_t const   )proc_ev->event_data.exec.process_pid);
      }
#line 840
      if (! (opt_flags & 16U)) {
#line 840
        if (opt_flags & 512U) {
          {
#line 841
          row_increment();
          }
#line 842
          if (info1->kernel_thread) {
#line 842
            tmp___8 = "]";
          } else {
#line 842
            tmp___8 = "";
          }
#line 842
          if (info1->kernel_thread) {
#line 842
            tmp___9 = "[";
          } else {
#line 842
            tmp___9 = "";
          }
          {
#line 842
          printf((char const   */* __restrict  */)"%s exec %5d        %8s %s%s%s\n",
                 when, proc_ev->event_data.exec.process_pid, "", tmp___9, info1->cmdline,
                 tmp___8);
          }
        }
      }
#line 850
      goto switch_break;
      case_2147483648: /* CIL Label */ 
      {
#line 852
      proc_stats_account(proc_ev->event_data.exit.process_pid, 2);
      }
#line 853
      if (! (opt_flags & 16U)) {
#line 853
        if (opt_flags & 1024U) {
          {
#line 854
          tmp___10 = proc_info_get((pid_t const   )proc_ev->event_data.exit.process_pid);
#line 854
          info1 = (proc_info_t const   *)tmp___10;
          }
#line 855
          if (info1->start.tv_sec) {
            {
#line 858
            gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
#line 859
            d1 = timeval_to_double(& info1->start);
#line 860
            d2 = timeval_to_double((struct timeval  const  *)(& tv));
#line 861
            snprintf((char */* __restrict  */)(duration), sizeof(duration), (char const   */* __restrict  */)"%8.3f",
                     d2 - d1);
            }
          } else {
            {
#line 863
            snprintf((char */* __restrict  */)(duration), sizeof(duration), (char const   */* __restrict  */)"unknown");
            }
          }
          {
#line 865
          row_increment();
          }
#line 866
          if (info1->kernel_thread) {
#line 866
            tmp___11 = "]";
          } else {
#line 866
            tmp___11 = "";
          }
#line 866
          if (info1->kernel_thread) {
#line 866
            tmp___12 = "[";
          } else {
#line 866
            tmp___12 = "";
          }
          {
#line 866
          printf((char const   */* __restrict  */)"%s exit %5d  %5d %8s %s%s%s\n",
                 when, proc_ev->event_data.exit.process_pid, proc_ev->event_data.exit.exit_code,
                 duration, tmp___12, info1->cmdline, tmp___11);
          }
        }
      }
      {
#line 875
      proc_info_free((pid_t const   )proc_ev->event_data.exit.process_pid);
      }
#line 876
      goto switch_break;
      case_1073741824: /* CIL Label */ 
      {
#line 878
      proc_stats_account(proc_ev->event_data.coredump.process_pid, 3);
      }
#line 879
      if (! (opt_flags & 16U)) {
#line 879
        if (opt_flags & 2048U) {
          {
#line 880
          tmp___13 = proc_info_get((pid_t const   )proc_ev->event_data.coredump.process_pid);
#line 880
          info1 = (proc_info_t const   *)tmp___13;
#line 881
          row_increment();
          }
#line 882
          if (info1->kernel_thread) {
#line 882
            tmp___14 = "]";
          } else {
#line 882
            tmp___14 = "";
          }
#line 882
          if (info1->kernel_thread) {
#line 882
            tmp___15 = "[";
          } else {
#line 882
            tmp___15 = "";
          }
          {
#line 882
          printf((char const   */* __restrict  */)"%s core %5d        %8s %s%s%s\n",
                 when, proc_ev->event_data.exit.process_pid, "", tmp___15, info1->cmdline,
                 tmp___14);
          }
        }
      }
#line 890
      goto switch_break;
      case_512: /* CIL Label */ 
      {
#line 892
      proc_stats_account(proc_ev->event_data.comm.process_pid, 4);
      }
#line 893
      if (! (opt_flags & 16U)) {
#line 893
        if (opt_flags & 4096U) {
          {
#line 894
          tmp___16 = proc_info_get((pid_t const   )proc_ev->event_data.comm.process_pid);
#line 894
          info1 = (proc_info_t const   *)tmp___16;
#line 895
          comm = proc_comm((pid_t const   )proc_ev->event_data.coredump.process_pid);
          }
#line 896
          if ((unsigned long )comm == (unsigned long )((void *)0)) {
#line 897
            goto switch_break;
          }
          {
#line 898
          row_increment();
          }
#line 900
          if (info1->kernel_thread) {
#line 900
            tmp___17 = "]";
          } else {
#line 900
            tmp___17 = "";
          }
#line 900
          if (info1->kernel_thread) {
#line 900
            tmp___18 = "[";
          } else {
#line 900
            tmp___18 = "";
          }
          {
#line 900
          printf((char const   */* __restrict  */)"%s comm %5d        %8s %s%s%s -> %s\n",
                 when, proc_ev->event_data.exit.process_pid, "", tmp___18, info1->cmdline,
                 tmp___17, comm);
#line 908
          free((void *)comm);
          }
        }
      }
#line 910
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 912
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      __Cont: /* CIL Label */ 
#line 779
      len -= (ssize_t )(((nlmsghdr->nlmsg_len + 4U) - 1U) & 4294967292U);
#line 779
      nlmsghdr = (struct nlmsghdr *)((char *)nlmsghdr + (((nlmsghdr->nlmsg_len + 4U) - 1U) & 4294967292U));
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 916
  return (0);
}
}
#line 923 "/home/june/repo/benchmarks/collector/temp/forkstat-0.01.04/forkstat.c"
void show_help(char * const  *argv ) 
{ 


  {
  {
#line 925
  printf((char const   */* __restrict  */)"%s, version %s\n\n", "forkstat", "0.01.04");
#line 926
  printf((char const   */* __restrict  */)"usage: %s [-d|-D|-e|-h|-s|-S|-q]\n", *(argv + 0));
#line 927
  printf((char const   */* __restrict  */)"-d\tstrip off directory path from process name.\n");
#line 928
  printf((char const   */* __restrict  */)"-D\tspecify run duration in seconds.\n");
#line 929
  printf((char const   */* __restrict  */)"-e\tselect which events to monitor.\n");
#line 930
  printf((char const   */* __restrict  */)"-h\tshow this help.\n");
#line 931
  printf((char const   */* __restrict  */)"-s\tshow short process name.\n");
#line 932
  printf((char const   */* __restrict  */)"-S\tshow event statistics at end of the run.\n");
#line 933
  printf((char const   */* __restrict  */)"-q\trun quietly and enable -S option.\n");
  }
#line 934
  return;
}
}
#line 936 "/home/june/repo/benchmarks/collector/temp/forkstat-0.01.04/forkstat.c"
static int parse_ev(char const   *arg ) 
{ 
  char *str ;
  char *token ;
  char *saveptr ;
  int i ;
  _Bool found ;
  int tmp ;

  {
#line 938
  saveptr = (char *)((void *)0);
#line 940
  str = (char *)arg;
  {
#line 940
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 940
    token = strtok_r((char */* __restrict  */)str, (char const   */* __restrict  */)",",
                     (char **/* __restrict  */)(& saveptr));
    }
#line 940
    if (! ((unsigned long )token != (unsigned long )((void *)0))) {
#line 940
      goto while_break;
    }
#line 942
    found = (_Bool)0;
#line 944
    i = 0;
    {
#line 944
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 944
      if (! ev_map[i].event) {
#line 944
        goto while_break___0;
      }
      {
#line 945
      tmp = strcmp((char const   *)token, (char const   *)ev_map[i].event);
      }
#line 945
      if (! tmp) {
#line 946
        opt_flags |= (unsigned int )ev_map[i].flag;
#line 947
        found = (_Bool)1;
      }
#line 944
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 950
    if (! found) {
      {
#line 951
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown event \'%s\'.\n",
              token);
      }
#line 952
      return (-1);
    }
#line 940
    str = (char *)((void *)0);
  }
  while_break: /* CIL Label */ ;
  }
#line 955
  return (0);
}
}
#line 958 "/home/june/repo/benchmarks/collector/temp/forkstat-0.01.04/forkstat.c"
int main(int argc , char * const  *argv ) 
{ 
  int sock ;
  int ret ;
  int c ;
  int tmp ;
  int tmp___0 ;
  __uid_t tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 960
  sock = -1;
#line 960
  ret = 1;
#line 962
  signal(2, & handle_sigstop);
#line 963
  signal(14, & handle_sigstop);
#line 964
  siginterrupt(2, 1);
  }
  {
#line 966
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 967
    tmp = getopt(argc, argv, "dD:e:hsSq");
#line 967
    c = tmp;
    }
#line 968
    if (c == -1) {
#line 969
      goto while_break;
    }
    {
#line 971
    if (c == 100) {
#line 971
      goto case_100;
    }
#line 974
    if (c == 68) {
#line 974
      goto case_68;
    }
#line 981
    if (c == 101) {
#line 981
      goto case_101;
    }
#line 985
    if (c == 104) {
#line 985
      goto case_104;
    }
#line 988
    if (c == 115) {
#line 988
      goto case_115;
    }
#line 992
    if (c == 83) {
#line 992
      goto case_83;
    }
#line 995
    if (c == 113) {
#line 995
      goto case_113;
    }
#line 998
    goto switch_default;
    case_100: /* CIL Label */ 
#line 972
    opt_flags |= 4U;
#line 973
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 975
    opt_duration = strtol((char const   */* __restrict  */)optarg, (char **/* __restrict  */)((void *)0),
                          10);
    }
#line 976
    if (opt_duration <= 0L) {
      {
#line 977
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Illegal duration.\n");
#line 978
      exit(1);
      }
    }
#line 980
    goto switch_break;
    case_101: /* CIL Label */ 
    {
#line 982
    tmp___0 = parse_ev((char const   *)optarg);
    }
#line 982
    if (tmp___0 < 0) {
      {
#line 983
      exit(1);
      }
    }
#line 984
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 986
    show_help(argv);
#line 987
    exit(0);
    }
    case_115: /* CIL Label */ 
#line 989
    opt_flags &= 4294967294U;
#line 990
    opt_flags |= 2U;
#line 991
    goto switch_break;
    case_83: /* CIL Label */ 
#line 993
    opt_flags |= 8U;
#line 994
    goto switch_break;
    case_113: /* CIL Label */ 
#line 996
    opt_flags |= 16U;
#line 997
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 999
    show_help(argv);
#line 1000
    exit(1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1004
  if ((opt_flags & 7936U) == 0U) {
#line 1005
    opt_flags |= 1792U;
  }
  {
#line 1007
  tmp___1 = geteuid();
  }
#line 1007
  if (tmp___1 != 0U) {
    {
#line 1008
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Need to run with root access.\n");
    }
#line 1009
    goto abort_sock;
  }
  {
#line 1012
  sane_procs = sane_proc_pid_info();
#line 1014
  tmp___2 = proc_info_load();
  }
#line 1014
  if (tmp___2 < 0) {
    {
#line 1015
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot load process cache. Is /proc mounted?\n");
    }
#line 1016
    goto abort_sock;
  }
  {
#line 1019
  sock = netlink_connect();
  }
#line 1020
  if (sock == -93) {
    {
#line 1021
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot show process activity with this kernel, netlink required.\n");
    }
#line 1022
    goto abort_sock;
  }
#line 1025
  if (sock < 0) {
#line 1026
    goto abort_sock;
  }
  {
#line 1028
  tmp___5 = netlink_listen((int const   )sock);
  }
#line 1028
  if (tmp___5 < 0) {
    {
#line 1029
    tmp___3 = __errno_location();
#line 1029
    tmp___4 = strerror(*tmp___3);
#line 1029
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Netlink listen failed: %s\n",
            tmp___4);
    }
#line 1030
    goto close_abort;
  }
#line 1033
  if (opt_duration > 0L) {
    {
#line 1034
    alarm((unsigned int )opt_duration);
    }
  }
  {
#line 1036
  tmp___6 = monitor((int const   )sock);
  }
#line 1036
  if (tmp___6 == 0) {
    {
#line 1037
    ret = 0;
#line 1038
    proc_stats_report();
    }
  }
  close_abort: 
  {
#line 1042
  close(sock);
  }
  abort_sock: 
  {
#line 1044
  proc_info_unload();
#line 1045
  proc_stats_free();
#line 1047
  exit(ret);
  }
}
}
