/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 141 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/basic/fixdep.c"
struct item {
   struct item *next ;
   unsigned int len ;
   unsigned int hash ;
   char name[0] ;
};
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 19 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/expr.h"
struct file {
   struct file *next ;
   struct file *parent ;
   char const   *name ;
   int lineno ;
};
#line 26
enum tristate {
    no = 0,
    mod = 1,
    yes = 2
} ;
#line 26 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/expr.h"
typedef enum tristate tristate;
#line 30
enum expr_type {
    E_NONE = 0,
    E_OR = 1,
    E_AND = 2,
    E_NOT = 3,
    E_EQUAL = 4,
    E_UNEQUAL = 5,
    E_LIST = 6,
    E_SYMBOL = 7,
    E_RANGE = 8
} ;
#line 34
struct expr;
#line 34
struct symbol;
#line 34 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/expr.h"
union expr_data {
   struct expr *expr ;
   struct symbol *sym ;
};
#line 39 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/expr.h"
struct expr {
   enum expr_type type ;
   union expr_data left ;
   union expr_data right ;
};
#line 51 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/expr.h"
struct expr_value {
   struct expr *expr ;
   tristate tri ;
};
#line 56 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/expr.h"
struct symbol_value {
   void *val ;
   tristate tri ;
};
#line 61
enum symbol_type {
    S_UNKNOWN = 0,
    S_BOOLEAN = 1,
    S_TRISTATE = 2,
    S_INT = 3,
    S_HEX = 4,
    S_STRING = 5,
    S_OTHER = 6
} ;
#line 74
struct property;
#line 74 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/expr.h"
struct symbol {
   struct symbol *next ;
   char *name ;
   enum symbol_type type ;
   struct symbol_value curr ;
   struct symbol_value def[4] ;
   tristate visible ;
   int flags ;
   struct property *prop ;
   struct expr_value dir_dep ;
   struct expr_value rev_dep ;
};
#line 122
enum prop_type {
    P_UNKNOWN = 0,
    P_PROMPT = 1,
    P_COMMENT = 2,
    P_MENU = 3,
    P_DEFAULT = 4,
    P_CHOICE = 5,
    P_SELECT = 6,
    P_RANGE = 7,
    P_ENV = 8,
    P_SYMBOL = 9
} ;
#line 135
struct menu;
#line 135 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/expr.h"
struct property {
   struct property *next ;
   struct symbol *sym ;
   enum prop_type type ;
   char const   *text ;
   struct expr_value visible ;
   struct expr *expr ;
   struct menu *menu ;
   struct file *file ;
   int lineno ;
};
#line 158 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/expr.h"
struct menu {
   struct menu *next ;
   struct menu *parent ;
   struct menu *list ;
   struct symbol *sym ;
   struct property *prompt ;
   struct expr *visibility ;
   struct expr *dep ;
   unsigned int flags ;
   char *help ;
   struct file *file ;
   int lineno ;
   void *data ;
};
#line 208
struct gstr;
#line 47 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/lkc.h"
enum conf_def_mode {
    def_default = 0,
    def_yes = 1,
    def_mod = 2,
    def_no = 3,
    def_random = 4
} ;
#line 120 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/lkc.h"
struct gstr {
   size_t len ;
   char *s ;
   int max_width ;
};
#line 23 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/conf.c"
enum input_mode {
    oldaskconfig = 0,
    silentoldconfig = 1,
    oldconfig = 2,
    allnoconfig = 3,
    allyesconfig = 4,
    allmodconfig = 5,
    alldefconfig = 6,
    randconfig = 7,
    defconfig = 8,
    savedefconfig = 9,
    listnewconfig = 10,
    oldnoconfig = 11
} ;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 59 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/lkc.h"
struct kconf_id {
   int name ;
   int token ;
   unsigned int flags ;
   enum symbol_type stype ;
};
#line 85 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/lkc.h"
struct conf_printer {
   void (*print_symbol)(FILE * , struct symbol * , char const   * , void * ) ;
   void (*print_comment)(FILE * , char const   * , void * ) ;
};
#line 176 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/zconf.tab.c"
union YYSTYPE {
   char *string ;
   struct file *file ;
   struct symbol *symbol ;
   struct expr *expr ;
   struct menu *menu ;
   struct kconf_id  const  *id ;
};
#line 176 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/zconf.tab.c"
typedef union YYSTYPE YYSTYPE;
#line 69 "scripts/kconfig/zconf.gperf"
struct kconf_id_strings_t {
   char kconf_id_strings_str2[sizeof("if")] ;
   char kconf_id_strings_str3[sizeof("int")] ;
   char kconf_id_strings_str5[sizeof("endif")] ;
   char kconf_id_strings_str7[sizeof("default")] ;
   char kconf_id_strings_str8[sizeof("tristate")] ;
   char kconf_id_strings_str9[sizeof("endchoice")] ;
   char kconf_id_strings_str12[sizeof("def_tristate")] ;
   char kconf_id_strings_str13[sizeof("def_bool")] ;
   char kconf_id_strings_str14[sizeof("defconfig_list")] ;
   char kconf_id_strings_str17[sizeof("on")] ;
   char kconf_id_strings_str18[sizeof("optional")] ;
   char kconf_id_strings_str21[sizeof("option")] ;
   char kconf_id_strings_str22[sizeof("endmenu")] ;
   char kconf_id_strings_str23[sizeof("mainmenu")] ;
   char kconf_id_strings_str25[sizeof("menuconfig")] ;
   char kconf_id_strings_str27[sizeof("modules")] ;
   char kconf_id_strings_str29[sizeof("menu")] ;
   char kconf_id_strings_str31[sizeof("select")] ;
   char kconf_id_strings_str32[sizeof("comment")] ;
   char kconf_id_strings_str33[sizeof("env")] ;
   char kconf_id_strings_str35[sizeof("range")] ;
   char kconf_id_strings_str36[sizeof("choice")] ;
   char kconf_id_strings_str39[sizeof("bool")] ;
   char kconf_id_strings_str41[sizeof("source")] ;
   char kconf_id_strings_str42[sizeof("visible")] ;
   char kconf_id_strings_str43[sizeof("hex")] ;
   char kconf_id_strings_str46[sizeof("config")] ;
   char kconf_id_strings_str47[sizeof("boolean")] ;
   char kconf_id_strings_str51[sizeof("string")] ;
   char kconf_id_strings_str54[sizeof("help")] ;
   char kconf_id_strings_str56[sizeof("prompt")] ;
   char kconf_id_strings_str72[sizeof("depends")] ;
};
#line 211 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/zconf.tab.c"
typedef unsigned char yytype_uint8;
#line 218 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/zconf.tab.c"
typedef signed char yytype_int8;
#line 226 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/zconf.tab.c"
typedef unsigned short yytype_uint16;
#line 232 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/zconf.tab.c"
typedef short yytype_int16;
#line 363 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/zconf.tab.c"
union yyalloc {
   yytype_int16 yyss_alloc ;
   YYSTYPE yyvs_alloc ;
};
#line 70 "scripts/kconfig/zconf.lex.c_shipped"
typedef short flex_int16_t;
#line 71 "scripts/kconfig/zconf.lex.c_shipped"
typedef int flex_int32_t;
#line 171
struct yy_buffer_state;
#line 171 "scripts/kconfig/zconf.lex.c_shipped"
typedef struct yy_buffer_state *YY_BUFFER_STATE;
#line 202 "scripts/kconfig/zconf.lex.c_shipped"
typedef size_t yy_size_t;
#line 207 "scripts/kconfig/zconf.lex.c_shipped"
struct yy_buffer_state {
   FILE *yy_input_file ;
   char *yy_ch_buf ;
   char *yy_buf_pos ;
   yy_size_t yy_buf_size ;
   int yy_n_chars ;
   int yy_is_our_buffer ;
   int yy_is_interactive ;
   int yy_at_bol ;
   int yy_bs_lineno ;
   int yy_bs_column ;
   int yy_fill_buffer ;
   int yy_buffer_status ;
};
#line 360 "scripts/kconfig/zconf.lex.c_shipped"
typedef int yy_state_type;
#line 783 "scripts/kconfig/zconf.lex.c_shipped"
struct __anonstruct_current_pos_31 {
   struct file *file ;
   int lineno ;
};
#line 791 "scripts/kconfig/zconf.lex.c_shipped"
struct buffer {
   struct buffer *parent ;
   YY_BUFFER_STATE state ;
};
#line 43 "/usr/include/regex.h"
typedef unsigned long reg_syntax_t;
#line 368 "/usr/include/regex.h"
struct re_pattern_buffer {
   unsigned char *__buffer ;
   unsigned long __allocated ;
   unsigned long __used ;
   reg_syntax_t __syntax ;
   char *__fastmap ;
   unsigned char *__translate ;
   size_t re_nsub ;
   unsigned int __can_be_null : 1 ;
   unsigned int __regs_allocated : 2 ;
   unsigned int __fastmap_accurate : 1 ;
   unsigned int __no_sub : 1 ;
   unsigned int __not_bol : 1 ;
   unsigned int __not_eol : 1 ;
   unsigned int __newline_anchor : 1 ;
};
#line 434 "/usr/include/regex.h"
typedef struct re_pattern_buffer regex_t;
#line 437 "/usr/include/regex.h"
typedef int regoff_t;
#line 463 "/usr/include/regex.h"
struct __anonstruct_regmatch_t_33 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 463 "/usr/include/regex.h"
typedef struct __anonstruct_regmatch_t_33 regmatch_t;
#line 48 "/usr/include/x86_64-linux-gnu/sys/utsname.h"
struct utsname {
   char sysname[65] ;
   char nodename[65] ;
   char release[65] ;
   char version[65] ;
   char machine[65] ;
   char __domainname[65] ;
};
#line 989 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/symbol.c"
struct dep_stack {
   struct dep_stack *prev ;
   struct dep_stack *next ;
   struct symbol *sym ;
   struct property *prop ;
   struct expr *expr ;
};
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 31 "/usr/include/elf.h"
typedef uint16_t Elf32_Half;
#line 35 "/usr/include/elf.h"
typedef uint32_t Elf32_Word;
#line 47 "/usr/include/elf.h"
typedef uint32_t Elf32_Addr;
#line 51 "/usr/include/elf.h"
typedef uint32_t Elf32_Off;
#line 55 "/usr/include/elf.h"
typedef uint16_t Elf32_Section;
#line 67 "/usr/include/elf.h"
struct __anonstruct_Elf32_Ehdr_28 {
   unsigned char e_ident[16] ;
   Elf32_Half e_type ;
   Elf32_Half e_machine ;
   Elf32_Word e_version ;
   Elf32_Addr e_entry ;
   Elf32_Off e_phoff ;
   Elf32_Off e_shoff ;
   Elf32_Word e_flags ;
   Elf32_Half e_ehsize ;
   Elf32_Half e_phentsize ;
   Elf32_Half e_phnum ;
   Elf32_Half e_shentsize ;
   Elf32_Half e_shnum ;
   Elf32_Half e_shstrndx ;
};
#line 67 "/usr/include/elf.h"
typedef struct __anonstruct_Elf32_Ehdr_28 Elf32_Ehdr;
#line 272 "/usr/include/elf.h"
struct __anonstruct_Elf32_Shdr_30 {
   Elf32_Word sh_name ;
   Elf32_Word sh_type ;
   Elf32_Word sh_flags ;
   Elf32_Addr sh_addr ;
   Elf32_Off sh_offset ;
   Elf32_Word sh_size ;
   Elf32_Word sh_link ;
   Elf32_Word sh_info ;
   Elf32_Word sh_addralign ;
   Elf32_Word sh_entsize ;
};
#line 272 "/usr/include/elf.h"
typedef struct __anonstruct_Elf32_Shdr_30 Elf32_Shdr;
#line 381 "/usr/include/elf.h"
struct __anonstruct_Elf32_Sym_32 {
   Elf32_Word st_name ;
   Elf32_Addr st_value ;
   Elf32_Word st_size ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf32_Section st_shndx ;
};
#line 381 "/usr/include/elf.h"
typedef struct __anonstruct_Elf32_Sym_32 Elf32_Sym;
#line 496 "/usr/include/elf.h"
struct __anonstruct_Elf32_Rel_36 {
   Elf32_Addr r_offset ;
   Elf32_Word r_info ;
};
#line 496 "/usr/include/elf.h"
typedef struct __anonstruct_Elf32_Rel_36 Elf32_Rel;
#line 541 "/usr/include/elf.h"
struct __anonstruct_Elf32_Phdr_40 {
   Elf32_Word p_type ;
   Elf32_Off p_offset ;
   Elf32_Addr p_vaddr ;
   Elf32_Addr p_paddr ;
   Elf32_Word p_filesz ;
   Elf32_Word p_memsz ;
   Elf32_Word p_flags ;
   Elf32_Word p_align ;
};
#line 541 "/usr/include/elf.h"
typedef struct __anonstruct_Elf32_Phdr_40 Elf32_Phdr;
#line 20 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 23 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 26 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 24 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/arch/x86/tools/relocs.c"
struct section {
   Elf32_Shdr shdr ;
   struct section *link ;
   Elf32_Sym *symtab ;
   Elf32_Rel *reltab ;
   char *strtab ;
};
#line 33
enum symtype {
    S_ABS = 0,
    S_REL = 1,
    S_SEG = 2,
    S_LIN = 3,
    S_NSYMTYPES = 4
} ;
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 57 "/usr/include/x86_64-linux-gnu/sys/mman.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) mmap)(void *__addr ,
                                                                             size_t __len ,
                                                                             int __prot ,
                                                                             int __flags ,
                                                                             int __fd ,
                                                                             __off_t __offset ) ;
#line 76
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) munmap)(void *__addr ,
                                                                             size_t __len ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 580
extern int putchar(int __c ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 124
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 374 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) ntohl)(uint32_t __netlong )  __attribute__((__const__)) ;
#line 123 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/basic/fixdep.c"
char *target  ;
#line 124 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/basic/fixdep.c"
char *depfile  ;
#line 125 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/basic/fixdep.c"
char *cmdline  ;
#line 127 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/basic/fixdep.c"
static void usage(void) 
{ 


  {
  {
#line 129
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: fixdep <depfile> <target> <cmdline>\n");
#line 130
  exit(1);
  }
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/basic/fixdep.c"
static void print_cmdline(void) 
{ 


  {
  {
#line 138
  printf((char const   */* __restrict  */)"cmd_%s := %s\n\n", target, cmdline);
  }
#line 139
  return;
}
}
#line 149 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/basic/fixdep.c"
static struct item *hashtab[256]  ;
#line 151 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/basic/fixdep.c"
static unsigned int strhash(char const   *str , unsigned int sz ) 
{ 
  unsigned int i ;
  unsigned int hash ;

  {
#line 154
  hash = 2166136261U;
#line 156
  i = 0U;
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 156
    if (! (i < sz)) {
#line 156
      goto while_break;
    }
#line 157
    hash = (hash ^ (unsigned int )*(str + i)) * 16777619U;
#line 156
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 158
  return (hash);
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/basic/fixdep.c"
static int is_defined_config(char const   *name , int len , unsigned int hash ) 
{ 
  struct item *aux ;
  int tmp ;

  {
#line 168
  aux = hashtab[hash % 256U];
  {
#line 168
  while (1) {
    while_continue: /* CIL Label */ ;
#line 168
    if (! aux) {
#line 168
      goto while_break;
    }
#line 169
    if (aux->hash == hash) {
#line 169
      if (aux->len == (unsigned int )len) {
        {
#line 169
        tmp = memcmp((void const   *)(aux->name), (void const   *)name, (size_t )len);
        }
#line 169
        if (tmp == 0) {
#line 171
          return (1);
        }
      }
    }
#line 168
    aux = aux->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 173
  return (0);
}
}
#line 179 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/basic/fixdep.c"
static void define_config(char const   *name , int len , unsigned int hash ) 
{ 
  struct item *aux ;
  void *tmp ;

  {
  {
#line 181
  tmp = malloc(sizeof(*aux) + (unsigned long )len);
#line 181
  aux = (struct item *)tmp;
  }
#line 183
  if (! aux) {
    {
#line 184
    perror("fixdep:malloc");
#line 185
    exit(1);
    }
  }
  {
#line 187
  memcpy((void */* __restrict  */)(aux->name), (void const   */* __restrict  */)name,
         (size_t )len);
#line 188
  aux->len = (unsigned int )len;
#line 189
  aux->hash = hash;
#line 190
  aux->next = hashtab[hash % 256U];
#line 191
  hashtab[hash % 256U] = aux;
  }
#line 192
  return;
}
}
#line 197 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/basic/fixdep.c"
static void clear_config(void) 
{ 
  struct item *aux ;
  struct item *next ;
  unsigned int i ;

  {
#line 202
  i = 0U;
  {
#line 202
  while (1) {
    while_continue: /* CIL Label */ ;
#line 202
    if (! (i < 256U)) {
#line 202
      goto while_break;
    }
#line 203
    aux = hashtab[i];
    {
#line 203
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 203
      if (! aux) {
#line 203
        goto while_break___0;
      }
      {
#line 204
      next = aux->next;
#line 205
      free((void *)aux);
#line 203
      aux = next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 207
    hashtab[i] = (struct item *)((void *)0);
#line 202
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 209
  return;
}
}
#line 214 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/basic/fixdep.c"
static void use_config(char const   *m , int slen ) 
{ 
  unsigned int hash ;
  unsigned int tmp ;
  int c ;
  int i ;
  int tmp___0 ;

  {
  {
#line 216
  tmp = strhash(m, (unsigned int )slen);
#line 216
  hash = tmp;
#line 219
  tmp___0 = is_defined_config(m, slen, hash);
  }
#line 219
  if (tmp___0) {
#line 220
    return;
  }
  {
#line 222
  define_config(m, slen, hash);
#line 224
  printf((char const   */* __restrict  */)"    $(wildcard include/config/");
#line 225
  i = 0;
  }
  {
#line 225
  while (1) {
    while_continue: /* CIL Label */ ;
#line 225
    if (! (i < slen)) {
#line 225
      goto while_break;
    }
#line 226
    c = (int )*(m + i);
#line 227
    if (c == 95) {
#line 228
      c = '/';
    } else {
      {
#line 230
      c = tolower(c);
      }
    }
    {
#line 231
    putchar(c);
#line 225
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 233
  printf((char const   */* __restrict  */)".h) \\\n");
  }
#line 234
  return;
}
}
#line 236 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/basic/fixdep.c"
static void parse_config_file(char const   *map , size_t len ) 
{ 
  int const   *end ;
  int const   *m ;
  char const   *p ;
  char const   *q ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;
  int tmp___5 ;

  {
#line 238
  end = (int const   *)(map + len);
#line 240
  m = (int const   *)map + 1;
  {
#line 243
  while (1) {
    while_continue: /* CIL Label */ ;
#line 243
    if (! ((unsigned long )m < (unsigned long )end)) {
#line 243
      goto while_break;
    }
    {
#line 244
    tmp = ntohl((uint32_t )1129270854);
    }
#line 244
    if ((uint32_t )*m == tmp) {
#line 244
      p = (char const   *)((char *)m);
#line 244
      goto conf;
    }
    {
#line 245
    tmp___0 = ntohl((uint32_t )1330529865);
    }
#line 245
    if ((uint32_t )*m == tmp___0) {
#line 245
      p = (char const   *)((char *)m - 1);
#line 245
      goto conf;
    }
    {
#line 246
    tmp___1 = ntohl((uint32_t )1313229127);
    }
#line 246
    if ((uint32_t )*m == tmp___1) {
#line 246
      p = (char const   *)((char *)m - 2);
#line 246
      goto conf;
    }
    {
#line 247
    tmp___2 = ntohl((uint32_t )1179207519);
    }
#line 247
    if ((uint32_t )*m == tmp___2) {
#line 247
      p = (char const   *)((char *)m - 3);
#line 247
      goto conf;
    }
#line 248
    goto __Cont;
    conf: 
#line 250
    if ((unsigned long )p > (unsigned long )((map + len) - 7)) {
#line 251
      goto __Cont;
    }
    {
#line 252
    tmp___3 = memcmp((void const   *)p, (void const   *)"CONFIG_", (size_t )7);
    }
#line 252
    if (tmp___3) {
#line 253
      goto __Cont;
    }
#line 254
    q = p + 7;
    {
#line 254
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 254
      if (! ((unsigned long )q < (unsigned long )(map + len))) {
#line 254
        goto while_break___0;
      }
      {
#line 255
      tmp___4 = __ctype_b_loc();
      }
#line 255
      if (! ((int const   )*(*tmp___4 + (int )*q) & 8)) {
#line 255
        if (! ((int const   )*q == 95)) {
#line 256
          goto found;
        }
      }
#line 254
      q ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 258
    goto __Cont;
    found: 
    {
#line 261
    tmp___5 = memcmp((void const   *)(q - 7), (void const   *)"_MODULE", (size_t )7);
    }
#line 261
    if (! tmp___5) {
#line 262
      q -= 7;
    }
#line 263
    if ((q - p) - 7L < 0L) {
#line 264
      goto __Cont;
    }
    {
#line 265
    use_config(p + 7, (int )((q - p) - 7L));
    }
    __Cont: /* CIL Label */ 
#line 243
    m ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 267
  return;
}
}
#line 270 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/basic/fixdep.c"
static int strrcmp(char *s , char *sub ) 
{ 
  int slen ;
  size_t tmp ;
  int sublen ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 272
  tmp = strlen((char const   *)s);
#line 272
  slen = (int )tmp;
#line 273
  tmp___0 = strlen((char const   *)sub);
#line 273
  sublen = (int )tmp___0;
  }
#line 275
  if (sublen > slen) {
#line 276
    return (1);
  }
  {
#line 278
  tmp___1 = memcmp((void const   *)((s + slen) - sublen), (void const   *)sub, (size_t )sublen);
  }
#line 278
  return (tmp___1);
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/basic/fixdep.c"
static void do_config_file(char const   *filename ) 
{ 
  struct stat st ;
  int fd ;
  void *map ;

  {
  {
#line 287
  fd = open(filename, 0);
  }
#line 288
  if (fd < 0) {
    {
#line 289
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fixdep: error opening config file: ");
#line 290
    perror(filename);
#line 291
    exit(2);
    }
  }
  {
#line 293
  fstat(fd, & st);
  }
#line 294
  if (st.st_size == 0L) {
    {
#line 295
    close(fd);
    }
#line 296
    return;
  }
  {
#line 298
  map = mmap((void *)0, (size_t )st.st_size, 1, 2, fd, (__off_t )0);
  }
#line 299
  if ((long )map == -1L) {
    {
#line 300
    perror("fixdep: mmap");
#line 301
    close(fd);
    }
#line 302
    return;
  }
  {
#line 305
  parse_config_file((char const   *)map, (size_t )st.st_size);
#line 307
  munmap(map, (size_t )st.st_size);
#line 309
  close(fd);
  }
#line 310
  return;
}
}
#line 317 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/basic/fixdep.c"
static void parse_dep_file(void *map , size_t len ) 
{ 
  char *m ;
  char *end ;
  char *p ;
  char s[4096] ;
  int first ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 319
  m = (char *)map;
#line 320
  end = m + len;
#line 325
  p = strchr((char const   *)m, ':');
  }
#line 326
  if (! p) {
    {
#line 327
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fixdep: parse error\n");
#line 328
    exit(1);
    }
  }
  {
#line 330
  memcpy((void */* __restrict  */)(s), (void const   */* __restrict  */)m, (size_t )(p - m));
#line 330
  s[p - m] = (char)0;
#line 331
  m = p + 1;
#line 333
  clear_config();
#line 335
  first = 1;
  }
  {
#line 336
  while (1) {
    while_continue: /* CIL Label */ ;
#line 336
    if (! ((unsigned long )m < (unsigned long )end)) {
#line 336
      goto while_break;
    }
    {
#line 337
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 337
      if ((unsigned long )m < (unsigned long )end) {
#line 337
        if (! ((int )*m == 32)) {
#line 337
          if (! ((int )*m == 92)) {
#line 337
            if (! ((int )*m == 10)) {
#line 337
              goto while_break___0;
            }
          }
        }
      } else {
#line 337
        goto while_break___0;
      }
#line 338
      m ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 339
    p = m;
    {
#line 340
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 340
      if ((unsigned long )p < (unsigned long )end) {
#line 340
        if (! ((int )*p != 32)) {
#line 340
          goto while_break___1;
        }
      } else {
#line 340
        goto while_break___1;
      }
#line 340
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 341
    if ((unsigned long )p == (unsigned long )end) {
      {
#line 342
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 342
        p --;
#line 342
        tmp = __ctype_b_loc();
        }
#line 342
        if ((int const   )*(*tmp + (int )*p) & 8) {
#line 342
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 343
      p ++;
    }
    {
#line 345
    memcpy((void */* __restrict  */)(s), (void const   */* __restrict  */)m, (size_t )(p - m));
#line 345
    s[p - m] = (char)0;
#line 346
    tmp___0 = strrcmp(s, (char *)"include/generated/autoconf.h");
    }
#line 346
    if (tmp___0) {
      {
#line 346
      tmp___1 = strrcmp(s, (char *)"arch/um/include/uml-config.h");
      }
#line 346
      if (tmp___1) {
        {
#line 346
        tmp___2 = strrcmp(s, (char *)"include/linux/kconfig.h");
        }
#line 346
        if (tmp___2) {
          {
#line 346
          tmp___3 = strrcmp(s, (char *)".ver");
          }
#line 346
          if (tmp___3) {
#line 356
            if (first) {
              {
#line 357
              printf((char const   */* __restrict  */)"source_%s := %s\n\n", target,
                     s);
#line 358
              printf((char const   */* __restrict  */)"deps_%s := \\\n", target);
              }
            } else {
              {
#line 360
              printf((char const   */* __restrict  */)"  %s \\\n", s);
              }
            }
            {
#line 361
            do_config_file((char const   *)(s));
            }
          }
        }
      }
    }
#line 363
    first = 0;
#line 364
    m = p + 1;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 366
  printf((char const   */* __restrict  */)"\n%s: $(deps_%s)\n\n", target, target);
#line 367
  printf((char const   */* __restrict  */)"$(deps_%s):\n", target);
  }
#line 368
  return;
}
}
#line 370 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/basic/fixdep.c"
static void print_deps(void) 
{ 
  struct stat st ;
  int fd ;
  void *map ;
  int tmp ;

  {
  {
#line 376
  fd = open((char const   *)depfile, 0);
  }
#line 377
  if (fd < 0) {
    {
#line 378
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fixdep: error opening depfile: ");
#line 379
    perror((char const   *)depfile);
#line 380
    exit(2);
    }
  }
  {
#line 382
  tmp = fstat(fd, & st);
  }
#line 382
  if (tmp < 0) {
    {
#line 383
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fixdep: error fstat\'ing depfile: ");
#line 384
    perror((char const   *)depfile);
#line 385
    exit(2);
    }
  }
#line 387
  if (st.st_size == 0L) {
    {
#line 388
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fixdep: %s is empty\n",
            depfile);
#line 389
    close(fd);
    }
#line 390
    return;
  }
  {
#line 392
  map = mmap((void *)0, (size_t )st.st_size, 1, 2, fd, (__off_t )0);
  }
#line 393
  if ((long )map == -1L) {
    {
#line 394
    perror("fixdep: mmap");
#line 395
    close(fd);
    }
#line 396
    return;
  }
  {
#line 399
  parse_dep_file(map, (size_t )st.st_size);
#line 401
  munmap(map, (size_t )st.st_size);
#line 403
  close(fd);
  }
#line 404
  return;
}
}
#line 408
static void traps(void) ;
#line 408 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/basic/fixdep.c"
static char test[5]  __attribute__((__aligned__(sizeof(int ))))  = {      (char )'C',      (char )'O',      (char )'N',      (char )'F', 
        (char )'\000'};
#line 406 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/basic/fixdep.c"
static void traps(void) 
{ 
  int *p ;
  uint32_t tmp ;

  {
  {
#line 409
  p = (int *)(test);
#line 411
  tmp = ntohl((uint32_t )1129270854);
  }
#line 411
  if ((uint32_t )*p != tmp) {
    {
#line 412
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fixdep: sizeof(int) != 4 or wrong endianess? %#x\n",
            *p);
#line 414
    exit(2);
    }
  }
#line 416
  return;
}
}
#line 418 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/basic/fixdep.c"
int main(int argc , char **argv ) 
{ 


  {
  {
#line 420
  traps();
  }
#line 422
  if (argc != 4) {
    {
#line 423
    usage();
    }
  }
  {
#line 425
  depfile = *(argv + 1);
#line 426
  target = *(argv + 2);
#line 427
  cmdline = *(argv + 3);
#line 429
  print_cmdline();
#line 430
  print_deps();
  }
#line 432
  return (0);
}
}
#line 124 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 376
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand)(unsigned int __seed ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 779 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 173
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 39 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) gettext)(char const   *__msgid )  __attribute__((__format_arg__(1))) ;
#line 82
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) textdomain)(char const   *__domainname ) ;
#line 86
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) bindtextdomain)(char const   *__domainname ,
                                                                                       char const   *__dirname ) ;
#line 4 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/lkc_proto.h"
void conf_parse(char const   *name ) ;
#line 5
int conf_read(char const   *name ) ;
#line 6
int conf_read_simple(char const   *name , int def ) ;
#line 7
int conf_write_defconfig(char const   *filename ) ;
#line 8
int conf_write(char const   *name ) ;
#line 9
int conf_write_autoconf(void) ;
#line 10
_Bool conf_get_changed(void) ;
#line 15
struct menu rootmenu ;
#line 17
_Bool menu_is_visible(struct menu *menu ) ;
#line 19
char const   *menu_get_prompt(struct menu *menu ) ;
#line 21
struct menu *menu_get_parent_menu(struct menu *menu ) ;
#line 22
_Bool menu_has_help(struct menu *menu ) ;
#line 26
void menu_get_ext_help(struct menu *menu , struct gstr *help ) ;
#line 37
void sym_calc_value(struct symbol *sym ) ;
#line 38
enum symbol_type sym_get_type(struct symbol *sym ) ;
#line 39
_Bool sym_tristate_within_range(struct symbol *sym , tristate val ) ;
#line 40
_Bool sym_set_tristate_value(struct symbol *sym , tristate val ) ;
#line 44
_Bool sym_set_string_value(struct symbol *sym , char const   *newval ) ;
#line 45
_Bool sym_is_changable(struct symbol *sym ) ;
#line 48
char const   *sym_get_string_value(struct symbol *sym ) ;
#line 78 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/lkc.h"
char const   *conf_get_configname(void) ;
#line 80
char *conf_get_default_confname(void) ;
#line 83
void conf_set_all_new_symbols(enum conf_def_mode mode ) ;
#line 129
struct gstr str_new(void) ;
#line 131
void str_free(struct gstr *gs ) ;
#line 134
char const   *str_get(struct gstr *gs ) ;
#line 150 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/lkc.h"
__inline static tristate sym_get_tristate_value(struct symbol *sym ) 
{ 


  {
#line 152
  return (sym->curr.tri);
}
}
#line 156 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/lkc.h"
__inline static struct symbol *sym_get_choice_value(struct symbol *sym ) 
{ 


  {
#line 158
  return ((struct symbol *)sym->curr.val);
}
}
#line 161 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/lkc.h"
__inline static _Bool sym_set_choice_value(struct symbol *ch , struct symbol *chval ) 
{ 
  _Bool tmp ;

  {
  {
#line 163
  tmp = sym_set_tristate_value(chval, (tristate )2);
  }
#line 163
  return (tmp);
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/lkc.h"
__inline static _Bool sym_is_choice(struct symbol *sym ) 
{ 
  int tmp ;

  {
#line 168
  if (sym->flags & 16) {
#line 168
    tmp = 1;
  } else {
#line 168
    tmp = 0;
  }
#line 168
  return ((_Bool )tmp);
}
}
#line 171 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/lkc.h"
__inline static _Bool sym_is_choice_value(struct symbol *sym ) 
{ 
  int tmp ;

  {
#line 173
  if (sym->flags & 32) {
#line 173
    tmp = 1;
  } else {
#line 173
    tmp = 0;
  }
#line 173
  return ((_Bool )tmp);
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/lkc.h"
__inline static _Bool sym_has_value(struct symbol *sym ) 
{ 
  int tmp ;

  {
#line 183
  if (sym->flags & 65536) {
#line 183
    tmp = 1;
  } else {
#line 183
    tmp = 0;
  }
#line 183
  return ((_Bool )tmp);
}
}
#line 19 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/conf.c"
static void conf(struct menu *menu ) ;
#line 20
static void check_conf(struct menu *menu ) ;
#line 21
static void xfgets(char *str , int size , FILE *in ) ;
#line 23 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/conf.c"
enum input_mode input_mode  =    (enum input_mode )0;
#line 38 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/conf.c"
static int indent  =    1;
#line 39 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/conf.c"
static int valid_stdin  =    1;
#line 40 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/conf.c"
static int sync_kconfig  ;
#line 41 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/conf.c"
static int conf_cnt  ;
#line 42 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/conf.c"
static char line[128]  ;
#line 43 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/conf.c"
static struct menu *rootEntry  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/conf.c"
static void print_help(struct menu *menu ) 
{ 
  struct gstr help ;
  struct gstr tmp ;
  char const   *tmp___0 ;

  {
  {
#line 47
  tmp = str_new();
#line 47
  help = tmp;
#line 49
  menu_get_ext_help(menu, & help);
#line 51
  tmp___0 = str_get(& help);
#line 51
  printf((char const   */* __restrict  */)"\n%s\n", tmp___0);
#line 52
  str_free(& help);
  }
#line 53
  return;
}
}
#line 55 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/conf.c"
static void strip(char *str ) 
{ 
  char *p ;
  int l ;
  unsigned short const   **tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
#line 57
  p = str;
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 60
    tmp = __ctype_b_loc();
    }
#line 60
    if (! ((int const   )*(*tmp + (int )*p) & 8192)) {
#line 60
      goto while_break;
    }
#line 61
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 62
  tmp___0 = strlen((char const   *)p);
#line 62
  l = (int )tmp___0;
  }
#line 63
  if ((unsigned long )p != (unsigned long )str) {
    {
#line 64
    memmove((void *)str, (void const   *)p, (size_t )(l + 1));
    }
  }
#line 65
  if (! l) {
#line 66
    return;
  }
#line 67
  p = (str + l) - 1;
  {
#line 68
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 68
    tmp___2 = __ctype_b_loc();
    }
#line 68
    if (! ((int const   )*(*tmp___2 + (int )*p) & 8192)) {
#line 68
      goto while_break___0;
    }
#line 69
    tmp___1 = p;
#line 69
    p --;
#line 69
    *tmp___1 = (char)0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 70
  return;
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/conf.c"
static void check_stdin(void) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 74
  if (! valid_stdin) {
    {
#line 75
    tmp = gettext("aborted!\n\n");
#line 75
    printf((char const   */* __restrict  */)tmp);
#line 76
    tmp___0 = gettext("Console input/output is redirected. ");
#line 76
    printf((char const   */* __restrict  */)tmp___0);
#line 77
    tmp___1 = gettext("Run \'make oldconfig\' to update configuration.\n\n");
#line 77
    printf((char const   */* __restrict  */)tmp___1);
#line 78
    exit(1);
    }
  }
#line 80
  return;
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/conf.c"
static int conf_askvalue(struct symbol *sym , char const   *def ) 
{ 
  enum symbol_type type ;
  enum symbol_type tmp ;
  char *tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;

  {
  {
#line 84
  tmp = sym_get_type(sym);
#line 84
  type = tmp;
#line 86
  tmp___1 = sym_has_value(sym);
  }
#line 86
  if (! tmp___1) {
    {
#line 87
    tmp___0 = gettext("(NEW) ");
#line 87
    printf((char const   */* __restrict  */)tmp___0);
    }
  }
  {
#line 89
  line[0] = (char )'\n';
#line 90
  line[1] = (char)0;
#line 92
  tmp___2 = sym_is_changable(sym);
  }
#line 92
  if (! tmp___2) {
    {
#line 93
    printf((char const   */* __restrict  */)"%s\n", def);
#line 94
    line[0] = (char )'\n';
#line 95
    line[1] = (char)0;
    }
#line 96
    return (0);
  }
  {
#line 101
  if ((unsigned int )input_mode == 1U) {
#line 101
    goto case_1;
  }
#line 101
  if ((unsigned int )input_mode == 2U) {
#line 101
    goto case_1;
  }
#line 108
  if ((unsigned int )input_mode == 0U) {
#line 108
    goto case_0;
  }
#line 112
  goto switch_default;
  case_1: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 102
  tmp___3 = sym_has_value(sym);
  }
#line 102
  if (tmp___3) {
    {
#line 103
    printf((char const   */* __restrict  */)"%s\n", def);
    }
#line 104
    return (0);
  }
  {
#line 106
  check_stdin();
  }
  case_0: /* CIL Label */ 
  {
#line 109
  fflush(stdout);
#line 110
  xfgets(line, 128, stdin);
  }
#line 111
  return (1);
  switch_default: /* CIL Label */ 
#line 113
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 119
  if ((unsigned int )type == 5U) {
#line 119
    goto case_5;
  }
#line 119
  if ((unsigned int )type == 4U) {
#line 119
    goto case_5;
  }
#line 119
  if ((unsigned int )type == 3U) {
#line 119
    goto case_5;
  }
#line 122
  goto switch_default___0;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 120
  printf((char const   */* __restrict  */)"%s\n", def);
  }
#line 121
  return (1);
  switch_default___0: /* CIL Label */ ;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 125
  printf((char const   */* __restrict  */)"%s", line);
  }
#line 126
  return (1);
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/conf.c"
static int conf_string(struct menu *menu ) 
{ 
  struct symbol *sym ;
  char const   *def ;
  char *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  _Bool tmp___3 ;

  {
#line 131
  sym = menu->sym;
  {
#line 134
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 135
    tmp = gettext((menu->prompt)->text);
#line 135
    printf((char const   */* __restrict  */)"%*s%s ", indent - 1, "", tmp);
#line 136
    printf((char const   */* __restrict  */)"(%s) ", sym->name);
#line 137
    def = sym_get_string_value(sym);
#line 138
    tmp___0 = sym_get_string_value(sym);
    }
#line 138
    if (tmp___0) {
      {
#line 139
      printf((char const   */* __restrict  */)"[%s] ", def);
      }
    }
    {
#line 140
    tmp___1 = conf_askvalue(sym, def);
    }
#line 140
    if (! tmp___1) {
#line 141
      return (0);
    }
    {
#line 143
    if ((int )line[0] == 10) {
#line 143
      goto case_10;
    }
#line 145
    if ((int )line[0] == 63) {
#line 145
      goto case_63;
    }
#line 153
    goto switch_default;
    case_10: /* CIL Label */ 
#line 144
    goto switch_break;
    case_63: /* CIL Label */ 
#line 147
    if ((int )line[1] == 10) {
      {
#line 148
      print_help(menu);
#line 149
      def = (char const   *)((void *)0);
      }
#line 150
      goto switch_break;
    }
    switch_default: /* CIL Label */ 
    {
#line 154
    tmp___2 = strlen((char const   *)(line));
#line 154
    line[tmp___2 - 1UL] = (char)0;
#line 155
    def = (char const   *)(line);
    }
    switch_break: /* CIL Label */ ;
    }
#line 157
    if (def) {
      {
#line 157
      tmp___3 = sym_set_string_value(sym, def);
      }
#line 157
      if (tmp___3) {
#line 158
        return (0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/conf.c"
static int conf_sym(struct menu *menu ) 
{ 
  struct symbol *sym ;
  tristate oldval ;
  tristate newval ;
  char *tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  _Bool tmp___8 ;

  {
#line 164
  sym = menu->sym;
  {
#line 167
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 168
    tmp = gettext((menu->prompt)->text);
#line 168
    printf((char const   */* __restrict  */)"%*s%s ", indent - 1, "", tmp);
    }
#line 169
    if (sym->name) {
      {
#line 170
      printf((char const   */* __restrict  */)"(%s) ", sym->name);
      }
    }
    {
#line 171
    putchar('[');
#line 172
    oldval = sym_get_tristate_value(sym);
    }
    {
#line 174
    if ((unsigned int )oldval == 0U) {
#line 174
      goto case_0;
    }
#line 177
    if ((unsigned int )oldval == 1U) {
#line 177
      goto case_1;
    }
#line 180
    if ((unsigned int )oldval == 2U) {
#line 180
      goto case_2;
    }
#line 173
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 175
    putchar('N');
    }
#line 176
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 178
    putchar('M');
    }
#line 179
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 181
    putchar('Y');
    }
#line 182
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 184
    if ((unsigned int )oldval != 0U) {
      {
#line 184
      tmp___0 = sym_tristate_within_range(sym, (tristate )0);
      }
#line 184
      if (tmp___0) {
        {
#line 185
        printf((char const   */* __restrict  */)"/n");
        }
      }
    }
#line 186
    if ((unsigned int )oldval != 1U) {
      {
#line 186
      tmp___1 = sym_tristate_within_range(sym, (tristate )1);
      }
#line 186
      if (tmp___1) {
        {
#line 187
        printf((char const   */* __restrict  */)"/m");
        }
      }
    }
#line 188
    if ((unsigned int )oldval != 2U) {
      {
#line 188
      tmp___2 = sym_tristate_within_range(sym, (tristate )2);
      }
#line 188
      if (tmp___2) {
        {
#line 189
        printf((char const   */* __restrict  */)"/y");
        }
      }
    }
    {
#line 190
    tmp___3 = menu_has_help(menu);
    }
#line 190
    if (tmp___3) {
      {
#line 191
      printf((char const   */* __restrict  */)"/?");
      }
    }
    {
#line 192
    printf((char const   */* __restrict  */)"] ");
#line 193
    tmp___4 = sym_get_string_value(sym);
#line 193
    tmp___5 = conf_askvalue(sym, tmp___4);
    }
#line 193
    if (! tmp___5) {
#line 194
      return (0);
    }
    {
#line 195
    strip(line);
    }
    {
#line 199
    if ((int )line[0] == 78) {
#line 199
      goto case_78;
    }
#line 199
    if ((int )line[0] == 110) {
#line 199
      goto case_78;
    }
#line 205
    if ((int )line[0] == 77) {
#line 205
      goto case_77;
    }
#line 205
    if ((int )line[0] == 109) {
#line 205
      goto case_77;
    }
#line 211
    if ((int )line[0] == 89) {
#line 211
      goto case_89;
    }
#line 211
    if ((int )line[0] == 121) {
#line 211
      goto case_89;
    }
#line 216
    if ((int )line[0] == 0) {
#line 216
      goto case_0___0;
    }
#line 219
    if ((int )line[0] == 63) {
#line 219
      goto case_63;
    }
#line 221
    goto switch_default;
    case_78: /* CIL Label */ 
    case_110: /* CIL Label */ 
#line 200
    newval = (tristate )0;
#line 201
    if (! line[1]) {
#line 202
      goto switch_break___0;
    } else {
      {
#line 201
      tmp___6 = strcmp((char const   *)(& line[1]), "o");
      }
#line 201
      if (! tmp___6) {
#line 202
        goto switch_break___0;
      }
    }
#line 203
    goto while_continue;
    case_77: /* CIL Label */ 
    case_109: /* CIL Label */ 
#line 206
    newval = (tristate )1;
#line 207
    if (! line[1]) {
#line 208
      goto switch_break___0;
    }
#line 209
    goto while_continue;
    case_89: /* CIL Label */ 
    case_121: /* CIL Label */ 
#line 212
    newval = (tristate )2;
#line 213
    if (! line[1]) {
#line 214
      goto switch_break___0;
    } else {
      {
#line 213
      tmp___7 = strcmp((char const   *)(& line[1]), "es");
      }
#line 213
      if (! tmp___7) {
#line 214
        goto switch_break___0;
      }
    }
#line 215
    goto while_continue;
    case_0___0: /* CIL Label */ 
#line 217
    newval = oldval;
#line 218
    goto switch_break___0;
    case_63: /* CIL Label */ 
#line 220
    goto help;
    switch_default: /* CIL Label */ 
#line 222
    goto while_continue;
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 224
    tmp___8 = sym_set_tristate_value(sym, newval);
    }
#line 224
    if (tmp___8) {
#line 225
      return (0);
    }
    help: 
    {
#line 227
    print_help(menu);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/conf.c"
static int conf_choice(struct menu *menu ) 
{ 
  struct symbol *sym ;
  struct symbol *def_sym ;
  struct menu *child ;
  _Bool is_new ;
  _Bool tmp ;
  int tmp___0 ;
  tristate tmp___1 ;
  tristate tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  _Bool tmp___5 ;
  int cnt ;
  int def ;
  char const   *tmp___6 ;
  char *tmp___7 ;
  _Bool tmp___8 ;
  char const   *tmp___9 ;
  char *tmp___10 ;
  char const   *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  _Bool tmp___14 ;
  char *tmp___15 ;
  _Bool tmp___16 ;
  unsigned short const   **tmp___17 ;
  _Bool tmp___18 ;
  size_t tmp___19 ;

  {
  {
#line 237
  sym = menu->sym;
#line 238
  tmp = sym_has_value(sym);
  }
#line 238
  if (tmp) {
#line 238
    tmp___0 = 0;
  } else {
#line 238
    tmp___0 = 1;
  }
  {
#line 238
  is_new = (_Bool )tmp___0;
#line 239
  tmp___5 = sym_is_changable(sym);
  }
#line 239
  if (tmp___5) {
    {
#line 240
    conf_sym(menu);
#line 241
    sym_calc_value(sym);
#line 242
    tmp___1 = sym_get_tristate_value(sym);
    }
    {
#line 243
    if ((unsigned int )tmp___1 == 0U) {
#line 243
      goto case_0;
    }
#line 245
    if ((unsigned int )tmp___1 == 1U) {
#line 245
      goto case_1;
    }
#line 247
    if ((unsigned int )tmp___1 == 2U) {
#line 247
      goto case_2;
    }
#line 242
    goto switch_break;
    case_0: /* CIL Label */ 
#line 244
    return (1);
    case_1: /* CIL Label */ 
#line 246
    return (0);
    case_2: /* CIL Label */ 
#line 248
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 251
    tmp___2 = sym_get_tristate_value(sym);
    }
    {
#line 252
    if ((unsigned int )tmp___2 == 0U) {
#line 252
      goto case_0___0;
    }
#line 254
    if ((unsigned int )tmp___2 == 1U) {
#line 254
      goto case_1___0;
    }
#line 257
    if ((unsigned int )tmp___2 == 2U) {
#line 257
      goto case_2___0;
    }
#line 251
    goto switch_break___0;
    case_0___0: /* CIL Label */ 
#line 253
    return (1);
    case_1___0: /* CIL Label */ 
    {
#line 255
    tmp___3 = menu_get_prompt(menu);
#line 255
    tmp___4 = gettext(tmp___3);
#line 255
    printf((char const   */* __restrict  */)"%*s%s\n", indent - 1, "", tmp___4);
    }
#line 256
    return (0);
    case_2___0: /* CIL Label */ 
#line 258
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
  {
#line 262
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 265
    tmp___6 = menu_get_prompt(menu);
#line 265
    tmp___7 = gettext(tmp___6);
#line 265
    printf((char const   */* __restrict  */)"%*s%s\n", indent - 1, "", tmp___7);
#line 266
    def_sym = sym_get_choice_value(sym);
#line 267
    def = 0;
#line 267
    cnt = def;
#line 268
    line[0] = (char)0;
#line 269
    child = menu->list;
    }
    {
#line 269
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 269
      if (! child) {
#line 269
        goto while_break___0;
      }
      {
#line 270
      tmp___8 = menu_is_visible(child);
      }
#line 270
      if (! tmp___8) {
#line 271
        goto __Cont;
      }
#line 272
      if (! child->sym) {
        {
#line 273
        tmp___9 = menu_get_prompt(child);
#line 273
        tmp___10 = gettext(tmp___9);
#line 273
        printf((char const   */* __restrict  */)"%*c %s\n", indent, '*', tmp___10);
        }
#line 274
        goto __Cont;
      }
#line 276
      cnt ++;
#line 277
      if ((unsigned long )child->sym == (unsigned long )def_sym) {
        {
#line 278
        def = cnt;
#line 279
        printf((char const   */* __restrict  */)"%*c", indent, '>');
        }
      } else {
        {
#line 281
        printf((char const   */* __restrict  */)"%*c", indent, ' ');
        }
      }
      {
#line 282
      tmp___11 = menu_get_prompt(child);
#line 282
      tmp___12 = gettext(tmp___11);
#line 282
      printf((char const   */* __restrict  */)" %d. %s", cnt, tmp___12);
      }
#line 283
      if ((child->sym)->name) {
        {
#line 284
        printf((char const   */* __restrict  */)" (%s)", (child->sym)->name);
        }
      }
      {
#line 285
      tmp___14 = sym_has_value(child->sym);
      }
#line 285
      if (! tmp___14) {
        {
#line 286
        tmp___13 = gettext(" (NEW)");
#line 286
        printf((char const   */* __restrict  */)tmp___13);
        }
      }
      {
#line 287
      printf((char const   */* __restrict  */)"\n");
      }
      __Cont: /* CIL Label */ 
#line 269
      child = child->next;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 289
    tmp___15 = gettext("%*schoice");
#line 289
    printf((char const   */* __restrict  */)tmp___15, indent - 1, "");
    }
#line 290
    if (cnt == 1) {
      {
#line 291
      printf((char const   */* __restrict  */)"[1]: 1\n");
      }
#line 292
      goto conf_childs;
    }
    {
#line 294
    printf((char const   */* __restrict  */)"[1-%d", cnt);
#line 295
    tmp___16 = menu_has_help(menu);
    }
#line 295
    if (tmp___16) {
      {
#line 296
      printf((char const   */* __restrict  */)"?");
      }
    }
    {
#line 297
    printf((char const   */* __restrict  */)"]: ");
    }
    {
#line 300
    if ((unsigned int )input_mode == 1U) {
#line 300
      goto case_1___1;
    }
#line 300
    if ((unsigned int )input_mode == 2U) {
#line 300
      goto case_1___1;
    }
#line 308
    if ((unsigned int )input_mode == 0U) {
#line 308
      goto case_0___1;
    }
#line 323
    goto switch_default;
    case_1___1: /* CIL Label */ 
    case_2___1: /* CIL Label */ 
#line 301
    if (! is_new) {
      {
#line 302
      cnt = def;
#line 303
      printf((char const   */* __restrict  */)"%d\n", cnt);
      }
#line 304
      goto switch_break___1;
    }
    {
#line 306
    check_stdin();
    }
    case_0___1: /* CIL Label */ 
    {
#line 309
    fflush(stdout);
#line 310
    xfgets(line, 128, stdin);
#line 311
    strip(line);
    }
#line 312
    if ((int )line[0] == 63) {
      {
#line 313
      print_help(menu);
      }
#line 314
      goto while_continue;
    }
#line 316
    if (! line[0]) {
#line 317
      cnt = def;
    } else {
      {
#line 318
      tmp___17 = __ctype_b_loc();
      }
#line 318
      if ((int const   )*(*tmp___17 + (int )line[0]) & 2048) {
        {
#line 319
        cnt = atoi((char const   *)(line));
        }
      } else {
#line 321
        goto while_continue;
      }
    }
#line 322
    goto switch_break___1;
    switch_default: /* CIL Label */ 
#line 324
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
    conf_childs: 
#line 328
    child = menu->list;
    {
#line 328
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 328
      if (! child) {
#line 328
        goto while_break___1;
      }
#line 329
      if (! child->sym) {
#line 330
        goto __Cont___0;
      } else {
        {
#line 329
        tmp___18 = menu_is_visible(child);
        }
#line 329
        if (! tmp___18) {
#line 330
          goto __Cont___0;
        }
      }
#line 331
      cnt --;
#line 331
      if (! cnt) {
#line 332
        goto while_break___1;
      }
      __Cont___0: /* CIL Label */ 
#line 328
      child = child->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 334
    if (! child) {
#line 335
      goto while_continue;
    }
#line 336
    if (line[0]) {
      {
#line 336
      tmp___19 = strlen((char const   *)(line));
      }
#line 336
      if ((int )line[tmp___19 - 1UL] == 63) {
        {
#line 337
        print_help(child);
        }
#line 338
        goto while_continue;
      }
    }
    {
#line 340
    sym_set_choice_value(sym, child->sym);
#line 341
    child = child->list;
    }
    {
#line 341
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 341
      if (! child) {
#line 341
        goto while_break___2;
      }
      {
#line 342
      indent += 2;
#line 343
      conf(child);
#line 344
      indent -= 2;
#line 341
      child = child->next;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 346
    return (1);
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 350 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/conf.c"
static void conf(struct menu *menu ) 
{ 
  struct symbol *sym ;
  struct property *prop ;
  struct menu *child ;
  _Bool tmp ;
  char const   *prompt ;
  char *tmp___0 ;
  _Bool tmp___1 ;

  {
  {
#line 356
  tmp = menu_is_visible(menu);
  }
#line 356
  if (! tmp) {
#line 357
    return;
  }
#line 359
  sym = menu->sym;
#line 360
  prop = menu->prompt;
#line 361
  if (prop) {
    {
#line 365
    if ((unsigned int )prop->type == 3U) {
#line 365
      goto case_3;
    }
#line 374
    if ((unsigned int )prop->type == 2U) {
#line 374
      goto case_2;
    }
#line 381
    goto switch_default;
    case_3: /* CIL Label */ 
#line 366
    if ((unsigned int )input_mode == 1U) {
#line 366
      goto _L;
    } else
#line 366
    if ((unsigned int )input_mode == 10U) {
#line 366
      goto _L;
    } else
#line 366
    if ((unsigned int )input_mode == 11U) {
      _L: /* CIL Label */ 
#line 366
      if ((unsigned long )rootEntry != (unsigned long )menu) {
        {
#line 370
        check_conf(menu);
        }
#line 371
        return;
      }
    }
    case_2: /* CIL Label */ 
    {
#line 375
    prompt = menu_get_prompt(menu);
    }
#line 376
    if (prompt) {
      {
#line 377
      tmp___0 = gettext(prompt);
#line 377
      printf((char const   */* __restrict  */)"%*c\n%*c %s\n%*c\n", indent, '*', indent,
             '*', tmp___0, indent, '*');
      }
    }
    switch_default: /* CIL Label */ ;
    switch_break: /* CIL Label */ ;
    }
  }
#line 386
  if (! sym) {
#line 387
    goto conf_childs;
  }
  {
#line 389
  tmp___1 = sym_is_choice(sym);
  }
#line 389
  if (tmp___1) {
    {
#line 390
    conf_choice(menu);
    }
#line 391
    if ((unsigned int )sym->curr.tri != 1U) {
#line 392
      return;
    }
#line 393
    goto conf_childs;
  }
  {
#line 399
  if ((unsigned int )sym->type == 5U) {
#line 399
    goto case_5;
  }
#line 399
  if ((unsigned int )sym->type == 4U) {
#line 399
    goto case_5;
  }
#line 399
  if ((unsigned int )sym->type == 3U) {
#line 399
    goto case_5;
  }
#line 402
  goto switch_default___0;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3___0: /* CIL Label */ 
  {
#line 400
  conf_string(menu);
  }
#line 401
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 403
  conf_sym(menu);
  }
#line 404
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  conf_childs: 
#line 408
  if (sym) {
#line 409
    indent += 2;
  }
#line 410
  child = menu->list;
  {
#line 410
  while (1) {
    while_continue: /* CIL Label */ ;
#line 410
    if (! child) {
#line 410
      goto while_break;
    }
    {
#line 411
    conf(child);
#line 410
    child = child->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 412
  if (sym) {
#line 413
    indent -= 2;
  }
#line 414
  return;
}
}
#line 416 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/conf.c"
static void check_conf(struct menu *menu ) 
{ 
  struct symbol *sym ;
  struct menu *child ;
  _Bool tmp ;
  _Bool tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;
  tristate tmp___5 ;
  _Bool tmp___6 ;

  {
  {
#line 421
  tmp = menu_is_visible(menu);
  }
#line 421
  if (! tmp) {
#line 422
    return;
  }
#line 424
  sym = menu->sym;
#line 425
  if (sym) {
    {
#line 425
    tmp___6 = sym_has_value(sym);
    }
#line 425
    if (! tmp___6) {
      {
#line 426
      tmp___3 = sym_is_changable(sym);
      }
#line 426
      if (tmp___3) {
#line 426
        goto _L;
      } else {
        {
#line 426
        tmp___4 = sym_is_choice(sym);
        }
#line 426
        if (tmp___4) {
          {
#line 426
          tmp___5 = sym_get_tristate_value(sym);
          }
#line 426
          if ((unsigned int )tmp___5 == 2U) {
            _L: /* CIL Label */ 
#line 428
            if ((unsigned int )input_mode == 10U) {
#line 429
              if (sym->name) {
                {
#line 429
                tmp___0 = sym_is_choice_value(sym);
                }
#line 429
                if (! tmp___0) {
                  {
#line 430
                  printf((char const   */* __restrict  */)"%s%s\n", "CONFIG_", sym->name);
                  }
                }
              }
            } else
#line 432
            if ((unsigned int )input_mode != 11U) {
#line 433
              tmp___2 = conf_cnt;
#line 433
              conf_cnt ++;
#line 433
              if (! tmp___2) {
                {
#line 434
                tmp___1 = gettext("*\n* Restart config...\n*\n");
#line 434
                printf((char const   */* __restrict  */)tmp___1);
                }
              }
              {
#line 435
              rootEntry = menu_get_parent_menu(menu);
#line 436
              conf(rootEntry);
              }
            }
          }
        }
      }
    }
  }
#line 441
  child = menu->list;
  {
#line 441
  while (1) {
    while_continue: /* CIL Label */ ;
#line 441
    if (! child) {
#line 441
      goto while_break;
    }
    {
#line 442
    check_conf(child);
#line 441
    child = child->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 443
  return;
}
}
#line 445 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/conf.c"
static struct option long_opts[13]  = 
#line 445
  {      {"oldaskconfig", 0, (int *)((void *)0), 0}, 
        {"oldconfig", 0, (int *)((void *)0), 2}, 
        {"silentoldconfig", 0, (int *)((void *)0), 1}, 
        {"defconfig", 2, (int *)((void *)0), 8}, 
        {"savedefconfig", 1, (int *)((void *)0), 9}, 
        {"allnoconfig", 0, (int *)((void *)0), 3}, 
        {"allyesconfig", 0, (int *)((void *)0), 4}, 
        {"allmodconfig", 0, (int *)((void *)0), 5}, 
        {"alldefconfig", 0, (int *)((void *)0), 6}, 
        {"randconfig", 0, (int *)((void *)0), 7}, 
        {"listnewconfig", 0, (int *)((void *)0), 10}, 
        {"oldnoconfig", 0, (int *)((void *)0), 11}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), 0}};
#line 461 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/conf.c"
static void conf_usage(char const   *progname ) 
{ 


  {
  {
#line 464
  printf((char const   */* __restrict  */)"Usage: %s [option] <kconfig-file>\n", progname);
#line 465
  printf((char const   */* __restrict  */)"[option] is _one_ of the following:\n");
#line 466
  printf((char const   */* __restrict  */)"  --listnewconfig         List new options\n");
#line 467
  printf((char const   */* __restrict  */)"  --oldaskconfig          Start a new configuration using a line-oriented program\n");
#line 468
  printf((char const   */* __restrict  */)"  --oldconfig             Update a configuration using a provided .config as base\n");
#line 469
  printf((char const   */* __restrict  */)"  --silentoldconfig       Same as oldconfig, but quietly, additionally update deps\n");
#line 470
  printf((char const   */* __restrict  */)"  --oldnoconfig           Same as silentoldconfig but set new symbols to no\n");
#line 471
  printf((char const   */* __restrict  */)"  --defconfig <file>      New config with default defined in <file>\n");
#line 472
  printf((char const   */* __restrict  */)"  --savedefconfig <file>  Save the minimal current configuration to <file>\n");
#line 473
  printf((char const   */* __restrict  */)"  --allnoconfig           New config where all options are answered with no\n");
#line 474
  printf((char const   */* __restrict  */)"  --allyesconfig          New config where all options are answered with yes\n");
#line 475
  printf((char const   */* __restrict  */)"  --allmodconfig          New config where all options are answered with mod\n");
#line 476
  printf((char const   */* __restrict  */)"  --alldefconfig          New config with all symbols set to default\n");
#line 477
  printf((char const   */* __restrict  */)"  --randconfig            New config with random answer to all options\n");
  }
#line 478
  return;
}
}
#line 680 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/conf.c"
static void xfgets(char *str , int size , FILE *in ) 
{ 
  char *tmp ;

  {
  {
#line 682
  tmp = fgets((char */* __restrict  */)str, size, (FILE */* __restrict  */)in);
  }
#line 682
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 683
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nError in reading or end of file.\n");
    }
  }
#line 684
  return;
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void *__builtin_memcpy(void * , void const   * , unsigned long  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 127 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 435 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 180 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *__old ,
                                                                             char const   *__new ) ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 377
extern int vprintf(char const   * __restrict  __format , __gnuc_va_list __arg ) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 390
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 826
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) clearerr)(FILE *__stream ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 374
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 140
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 285
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strcspn)(char const   *__s ,
                                                                                                   char const   *__reject )  __attribute__((__pure__)) ;
#line 315
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strpbrk)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 176 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/expr.h"
struct file *file_list  ;
#line 177 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/expr.h"
struct file *current_file  ;
#line 180
struct symbol symbol_yes ;
#line 180
struct symbol symbol_no ;
#line 180
struct symbol symbol_mod ;
#line 181 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/expr.h"
struct symbol *modules_sym  ;
#line 182 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/expr.h"
struct symbol *sym_defconfig_list  ;
#line 183
int cdebug ;
#line 184
struct expr *expr_alloc_symbol(struct symbol *sym ) ;
#line 185
struct expr *expr_alloc_one(enum expr_type type , struct expr *ce ) ;
#line 186
struct expr *expr_alloc_two(enum expr_type type , struct expr *e1 , struct expr *e2 ) ;
#line 187
struct expr *expr_alloc_comp(enum expr_type type , struct symbol *s1 , struct symbol *s2 ) ;
#line 188
struct expr *expr_alloc_and(struct expr *e1 , struct expr *e2 ) ;
#line 189
struct expr *expr_alloc_or(struct expr *e1 , struct expr *e2 ) ;
#line 190
struct expr *expr_copy(struct expr  const  *org ) ;
#line 191
void expr_free(struct expr *e ) ;
#line 192
int expr_eq(struct expr *e1 , struct expr *e2 ) ;
#line 193
void expr_eliminate_eq(struct expr **ep1 , struct expr **ep2 ) ;
#line 194
tristate expr_calc_value(struct expr *e ) ;
#line 195
struct expr *expr_eliminate_yn(struct expr *e ) ;
#line 196
struct expr *expr_trans_bool(struct expr *e ) ;
#line 197
struct expr *expr_eliminate_dups(struct expr *e ) ;
#line 198
struct expr *expr_transform(struct expr *e ) ;
#line 199
int expr_contains_symbol(struct expr *dep , struct symbol *sym ) ;
#line 200
_Bool expr_depends_symbol(struct expr *dep , struct symbol *sym ) ;
#line 201
struct expr *expr_extract_eq_and(struct expr **ep1 , struct expr **ep2 ) ;
#line 202
struct expr *expr_extract_eq_or(struct expr **ep1 , struct expr **ep2 ) ;
#line 203
void expr_extract_eq(enum expr_type type , struct expr **ep , struct expr **ep1 ,
                     struct expr **ep2 ) ;
#line 204
struct expr *expr_trans_compare(struct expr *e , enum expr_type type , struct symbol *sym ) ;
#line 205
struct expr *expr_simplify_unmet_dep(struct expr *e1 , struct expr *e2 ) ;
#line 207
void expr_fprint(struct expr *e , FILE *out ) ;
#line 209
void expr_gstr_print(struct expr *e , struct gstr *gs ) ;
#line 211 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/expr.h"
__inline static int expr_is_yes(struct expr *e ) 
{ 
  int tmp ;

  {
#line 213
  if (! e) {
#line 213
    tmp = 1;
  } else
#line 213
  if ((unsigned int )e->type == 7U) {
#line 213
    if ((unsigned long )e->left.sym == (unsigned long )(& symbol_yes)) {
#line 213
      tmp = 1;
    } else {
#line 213
      tmp = 0;
    }
  } else {
#line 213
    tmp = 0;
  }
#line 213
  return (tmp);
}
}
#line 216 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/expr.h"
__inline static int expr_is_no(struct expr *e ) 
{ 
  int tmp ;

  {
#line 218
  if (e) {
#line 218
    if ((unsigned int )e->type == 7U) {
#line 218
      if ((unsigned long )e->left.sym == (unsigned long )(& symbol_no)) {
#line 218
        tmp = 1;
      } else {
#line 218
        tmp = 0;
      }
    } else {
#line 218
      tmp = 0;
    }
  } else {
#line 218
    tmp = 0;
  }
#line 218
  return (tmp);
}
}
#line 11 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/lkc_proto.h"
void conf_set_changed_callback(void (*fn)(void) ) ;
#line 12
void conf_set_message_callback(void (*fn)(char const   *fmt , va_list ap ) ) ;
#line 15 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/lkc_proto.h"
struct menu rootmenu  ;
#line 18
_Bool menu_has_prompt(struct menu *menu ) ;
#line 20
struct menu *menu_get_root_menu(struct menu *menu ) ;
#line 23
char const   *menu_get_help(struct menu *menu ) ;
#line 24
void get_symbol_str(struct gstr *r , struct symbol *sym ) ;
#line 25
struct gstr get_relations_str(struct symbol **sym_arr ) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/lkc_proto.h"
struct symbol *symbol_hash[9973]  ;
#line 31
struct symbol *sym_lookup(char const   *name , int flags ) ;
#line 32
struct symbol *sym_find(char const   *name ) ;
#line 33
char const   *sym_expand_string_value(char const   *in ) ;
#line 34
char const   *sym_escape_string_value(char const   *in ) ;
#line 35
struct symbol **sym_re_search(char const   *pattern ) ;
#line 36
char const   *sym_type_name(enum symbol_type type ) ;
#line 41
tristate sym_toggle_tristate_value(struct symbol *sym ) ;
#line 42
_Bool sym_string_valid(struct symbol *sym , char const   *str ) ;
#line 43
_Bool sym_string_within_range(struct symbol *sym , char const   *str ) ;
#line 46
struct property *sym_get_choice_prop(struct symbol *sym ) ;
#line 47
struct property *sym_get_default_prop(struct symbol *sym ) ;
#line 50
char const   *prop_get_type_name(enum prop_type type ) ;
#line 53
int expr_compare_type(enum expr_type t1 , enum expr_type t2 ) ;
#line 54
void expr_print(struct expr *e , void (*fn)(void * , struct symbol * , char const   * ) ,
                void *data , int prevtoken ) ;
#line 66 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/lkc.h"
int zconfdebug  ;
#line 68
int zconfparse(void) ;
#line 69
void zconfdump(FILE *out ) ;
#line 70
void zconf_starthelp(void) ;
#line 71
FILE *zconf_fopen(char const   *name ) ;
#line 72
void zconf_initscan(char const   *name ) ;
#line 73
void zconf_nextfile(char const   *name ) ;
#line 74
int zconf_lineno(void) ;
#line 75
char const   *zconf_curname(void) ;
#line 79
char const   *conf_get_autoconfig_name(void) ;
#line 81
void sym_set_change_count(int count ) ;
#line 82
void sym_add_change_count(int count ) ;
#line 91 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/lkc.h"
__inline static void xfwrite(void const   *str , size_t len , size_t count , FILE *out ) 
{ 
  size_t tmp ;

  {
#line 93
  if (! (len != 0UL)) {
    {
#line 93
    __assert_fail("len != 0", "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/lkc.h",
                  93U, "xfwrite");
    }
  }
  {
#line 95
  tmp = fwrite((void const   */* __restrict  */)str, len, count, (FILE */* __restrict  */)out);
  }
#line 95
  if (tmp != count) {
    {
#line 96
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error in writing or end of file.\n");
    }
  }
#line 97
  return;
}
}
#line 100
void _menu_init(void) ;
#line 101
void menu_warn(struct menu *menu , char const   *fmt  , ...) ;
#line 102
struct menu *menu_add_menu(void) ;
#line 103
void menu_end_menu(void) ;
#line 104
void menu_add_entry(struct symbol *sym ) ;
#line 105
void menu_end_entry(void) ;
#line 106
void menu_add_dep(struct expr *dep ) ;
#line 107
void menu_add_visibility(struct expr *expr ) ;
#line 108
struct property *menu_add_prop(enum prop_type type , char *prompt , struct expr *expr ,
                               struct expr *dep ) ;
#line 109
struct property *menu_add_prompt(enum prop_type type , char *prompt , struct expr *dep ) ;
#line 110
void menu_add_expr(enum prop_type type , struct expr *expr , struct expr *dep ) ;
#line 111
void menu_add_symbol(enum prop_type type , struct symbol *sym , struct expr *dep ) ;
#line 112
void menu_add_option(int token , char *arg ) ;
#line 113
void menu_finalize(struct menu *parent ) ;
#line 114
void menu_set_type(int type ) ;
#line 117
struct file *file_lookup(char const   *name ) ;
#line 118
int file_write_dep(char const   *name ) ;
#line 130
struct gstr str_assign(char const   *s ) ;
#line 132
void str_append(struct gstr *gs , char const   *s ) ;
#line 133
void str_printf(struct gstr *gs , char const   *fmt  , ...) ;
#line 137 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/lkc.h"
struct expr *sym_env_list  ;
#line 139
void sym_init(void) ;
#line 140
void sym_clear_all_valid(void) ;
#line 141
void sym_set_all_changed(void) ;
#line 142
void sym_set_changed(struct symbol *sym ) ;
#line 143
struct symbol *sym_choice_default(struct symbol *sym ) ;
#line 144
char const   *sym_get_string_default(struct symbol *sym ) ;
#line 145
struct symbol *sym_check_deps(struct symbol *sym ) ;
#line 146
struct property *prop_alloc(enum prop_type type , struct symbol *sym ) ;
#line 147
struct symbol *prop_get_symbol(struct property *prop ) ;
#line 148
struct property *sym_get_env_prop(struct symbol *sym ) ;
#line 176 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/lkc.h"
__inline static _Bool sym_is_optional(struct symbol *sym ) 
{ 
  int tmp ;

  {
#line 178
  if (sym->flags & 256) {
#line 178
    tmp = 1;
  } else {
#line 178
    tmp = 0;
  }
#line 178
  return ((_Bool )tmp);
}
}
#line 97 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/zconf.tab.c"
int cdebug  =    1;
#line 99
int zconflex(void) ;
#line 100
static void zconfprint(char const   *err  , ...) ;
#line 101
static void zconf_error(char const   *err  , ...) ;
#line 102
static void zconferror(char const   *err ) ;
#line 103
static _Bool zconf_endtoken(struct kconf_id  const  *id , int starttoken , int endtoken ) ;
#line 107 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/zconf.tab.c"
static struct menu *current_menu  ;
#line 107 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/zconf.tab.c"
static struct menu *current_entry  ;
#line 12 "scripts/kconfig/zconf.gperf"
__inline static struct kconf_id  const __attribute__((__gnu_inline__)) *kconf_id_lookup(char const   *str ,
                                                                                        unsigned int len ) ;
#line 25
__inline static unsigned int kconf_id_hash(char const   *str , unsigned int len ) ;
#line 25 "scripts/kconfig/zconf.gperf"
static unsigned char const   asso_values[256]  = 
#line 25
  {      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )25,      (unsigned char const   )25, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )5, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )5,      (unsigned char const   )0,      (unsigned char const   )10,      (unsigned char const   )5, 
        (unsigned char const   )45,      (unsigned char const   )73,      (unsigned char const   )20,      (unsigned char const   )20, 
        (unsigned char const   )0,      (unsigned char const   )15,      (unsigned char const   )15,      (unsigned char const   )73, 
        (unsigned char const   )20,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73, 
        (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73,      (unsigned char const   )73};
#line 16 "scripts/kconfig/zconf.gperf"
__inline static unsigned int kconf_id_hash(char const   *str , unsigned int len ) 
{ 
  register int hval ;

  {
#line 54
  hval = (int )len;
  {
#line 62
  if (hval == 1) {
#line 62
    goto case_1;
  }
#line 62
  if (hval == 2) {
#line 62
    goto case_1;
  }
#line 58
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 59
  hval += (int )asso_values[(unsigned char )*(str + 2)];
  case_1: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 63
  hval += (int )asso_values[(unsigned char )*(str + 0)];
#line 64
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 66
  return ((unsigned int )(hval + (int )asso_values[(unsigned char )*(str + (len - 1U))]));
}
}
#line 104 "scripts/kconfig/zconf.gperf"
static struct kconf_id_strings_t  const  kconf_id_strings_contents  = 
#line 104
     {{(char )'i', (char )'f', (char )'\000'}, {(char )'i', (char )'n', (char )'t',
                                              (char )'\000'}, {(char )'e', (char )'n',
                                                               (char )'d', (char )'i',
                                                               (char )'f', (char )'\000'},
    {(char )'d', (char )'e', (char )'f', (char )'a', (char )'u', (char )'l', (char )'t',
     (char )'\000'}, {(char )'t', (char )'r', (char )'i', (char )'s', (char )'t',
                      (char )'a', (char )'t', (char )'e', (char )'\000'}, {(char )'e',
                                                                           (char )'n',
                                                                           (char )'d',
                                                                           (char )'c',
                                                                           (char )'h',
                                                                           (char )'o',
                                                                           (char )'i',
                                                                           (char )'c',
                                                                           (char )'e',
                                                                           (char )'\000'},
    {(char )'d', (char )'e', (char )'f', (char )'_', (char )'t', (char )'r', (char )'i',
     (char )'s', (char )'t', (char )'a', (char )'t', (char )'e', (char )'\000'}, {(char )'d',
                                                                                  (char )'e',
                                                                                  (char )'f',
                                                                                  (char )'_',
                                                                                  (char )'b',
                                                                                  (char )'o',
                                                                                  (char )'o',
                                                                                  (char )'l',
                                                                                  (char )'\000'},
    {(char )'d', (char )'e', (char )'f', (char )'c', (char )'o', (char )'n', (char )'f',
     (char )'i', (char )'g', (char )'_', (char )'l', (char )'i', (char )'s', (char )'t',
     (char )'\000'}, {(char )'o', (char )'n', (char )'\000'}, {(char )'o', (char )'p',
                                                               (char )'t', (char )'i',
                                                               (char )'o', (char )'n',
                                                               (char )'a', (char )'l',
                                                               (char )'\000'}, {(char )'o',
                                                                                (char )'p',
                                                                                (char )'t',
                                                                                (char )'i',
                                                                                (char )'o',
                                                                                (char )'n',
                                                                                (char )'\000'},
    {(char )'e', (char )'n', (char )'d', (char )'m', (char )'e', (char )'n', (char )'u',
     (char )'\000'}, {(char )'m', (char )'a', (char )'i', (char )'n', (char )'m',
                      (char )'e', (char )'n', (char )'u', (char )'\000'}, {(char )'m',
                                                                           (char )'e',
                                                                           (char )'n',
                                                                           (char )'u',
                                                                           (char )'c',
                                                                           (char )'o',
                                                                           (char )'n',
                                                                           (char )'f',
                                                                           (char )'i',
                                                                           (char )'g',
                                                                           (char )'\000'},
    {(char )'m', (char )'o', (char )'d', (char )'u', (char )'l', (char )'e', (char )'s',
     (char )'\000'}, {(char )'m', (char )'e', (char )'n', (char )'u', (char )'\000'},
    {(char )'s', (char )'e', (char )'l', (char )'e', (char )'c', (char )'t', (char )'\000'},
    {(char )'c', (char )'o', (char )'m', (char )'m', (char )'e', (char )'n', (char )'t',
     (char )'\000'}, {(char )'e', (char )'n', (char )'v', (char )'\000'}, {(char )'r',
                                                                           (char )'a',
                                                                           (char )'n',
                                                                           (char )'g',
                                                                           (char )'e',
                                                                           (char )'\000'},
    {(char )'c', (char )'h', (char )'o', (char )'i', (char )'c', (char )'e', (char )'\000'},
    {(char )'b', (char )'o', (char )'o', (char )'l', (char )'\000'}, {(char )'s',
                                                                      (char )'o',
                                                                      (char )'u',
                                                                      (char )'r',
                                                                      (char )'c',
                                                                      (char )'e',
                                                                      (char )'\000'},
    {(char )'v', (char )'i', (char )'s', (char )'i', (char )'b', (char )'l', (char )'e',
     (char )'\000'}, {(char )'h', (char )'e', (char )'x', (char )'\000'}, {(char )'c',
                                                                           (char )'o',
                                                                           (char )'n',
                                                                           (char )'f',
                                                                           (char )'i',
                                                                           (char )'g',
                                                                           (char )'\000'},
    {(char )'b', (char )'o', (char )'o', (char )'l', (char )'e', (char )'a', (char )'n',
     (char )'\000'}, {(char )'s', (char )'t', (char )'r', (char )'i', (char )'n',
                      (char )'g', (char )'\000'}, {(char )'h', (char )'e', (char )'l',
                                                   (char )'p', (char )'\000'}, {(char )'p',
                                                                                (char )'r',
                                                                                (char )'o',
                                                                                (char )'m',
                                                                                (char )'p',
                                                                                (char )'t',
                                                                                (char )'\000'},
    {(char )'d', (char )'e', (char )'p', (char )'e', (char )'n', (char )'d', (char )'s',
     (char )'\000'}};
#line 158 "scripts/kconfig/zconf.gperf"
static struct kconf_id  const  wordlist[73]  = 
#line 158
  {      {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str2)),
      269, 3U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str3)),
      274, 1U, (enum symbol_type )3}, 
        {-1, 0, 0U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str5)),
      270, 1U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str7)),
      275, 1U, (enum symbol_type )0}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str8)),
      274, 1U, (enum symbol_type )2}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str9)),
      263, 1U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str12)),
      275, 1U, (enum symbol_type )2}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str13)),
      275, 1U, (enum symbol_type )1}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str14)),
      2, 4U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str17)),
      280, 2U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str18)),
      272, 1U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str21)),
      279, 1U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str22)),
      260, 1U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str23)),
      258, 1U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str25)),
      266, 1U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str27)),
      1, 4U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str29)),
      259, 1U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str31)),
      276, 1U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str32)),
      264, 1U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str33)),
      3, 4U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str35)),
      277, 1U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str36)),
      262, 1U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str39)),
      274, 1U, (enum symbol_type )1}, 
        {-1, 0, 0U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str41)),
      261, 1U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str42)),
      278, 1U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str43)),
      274, 1U, (enum symbol_type )4}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str46)),
      265, 1U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str47)),
      274, 1U, (enum symbol_type )1}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str51)),
      274, 1U, (enum symbol_type )5}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str54)),
      267, 1U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str56)),
      273, 1U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {-1, 0, 0U, 0U}, 
        {(int )((long )(& ((struct kconf_id_strings_t *)0)->kconf_id_strings_str72)),
      271, 1U, 0U}};
#line 141 "scripts/kconfig/zconf.gperf"
__inline static struct kconf_id  const __attribute__((__gnu_inline__)) *kconf_id_lookup(char const   *str ,
                                                                                        unsigned int len ) 
{ 
  register int key ;
  unsigned int tmp ;
  register int o ;
  register char const   *s ;
  int tmp___0 ;

  {
#line 30
  if (len <= 14U) {
#line 30
    if (len >= 2U) {
      {
#line 32
      tmp = kconf_id_hash(str, len);
#line 32
      key = (int )tmp;
      }
#line 34
      if (key <= 72) {
#line 34
        if (key >= 0) {
#line 36
          o = (int )wordlist[key].name;
#line 37
          if (o >= 0) {
#line 39
            s = (char const   *)(& kconf_id_strings_contents) + o;
#line 41
            if ((int const   )*str == (int const   )*s) {
              {
#line 41
              tmp___0 = strncmp(str + 1, s + 1, (size_t )(len - 1U));
              }
#line 41
              if (! tmp___0) {
#line 41
                if ((int const   )*(s + len) == 0) {
#line 42
                  return ((struct kconf_id  const __attribute__((__gnu_inline__)) *)(& wordlist[key]));
                }
              }
            }
          }
        }
      }
    }
  }
#line 46
  return ((struct kconf_id  const __attribute__((__gnu_inline__)) *)0);
}
}
#line 436 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/zconf.tab.c"
static yytype_uint8 const   yytranslate[291]  = 
#line 436 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/zconf.tab.c"
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )11,      (yytype_uint8 const   )12, 
        (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )22,      (yytype_uint8 const   )23,      (yytype_uint8 const   )24, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )26,      (yytype_uint8 const   )27,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )30,      (yytype_uint8 const   )31,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )33,      (yytype_uint8 const   )34,      (yytype_uint8 const   )35};
#line 473 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/zconf.tab.c"
static yytype_uint16 const   yyprhs[119]  = 
#line 473
  {      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )3,      (yytype_uint16 const   )6, 
        (yytype_uint16 const   )8,      (yytype_uint16 const   )11,      (yytype_uint16 const   )13,      (yytype_uint16 const   )14, 
        (yytype_uint16 const   )17,      (yytype_uint16 const   )20,      (yytype_uint16 const   )23,      (yytype_uint16 const   )26, 
        (yytype_uint16 const   )31,      (yytype_uint16 const   )36,      (yytype_uint16 const   )40,      (yytype_uint16 const   )42, 
        (yytype_uint16 const   )44,      (yytype_uint16 const   )46,      (yytype_uint16 const   )48,      (yytype_uint16 const   )50, 
        (yytype_uint16 const   )52,      (yytype_uint16 const   )54,      (yytype_uint16 const   )56,      (yytype_uint16 const   )58, 
        (yytype_uint16 const   )60,      (yytype_uint16 const   )62,      (yytype_uint16 const   )64,      (yytype_uint16 const   )66, 
        (yytype_uint16 const   )68,      (yytype_uint16 const   )72,      (yytype_uint16 const   )75,      (yytype_uint16 const   )79, 
        (yytype_uint16 const   )82,      (yytype_uint16 const   )86,      (yytype_uint16 const   )89,      (yytype_uint16 const   )90, 
        (yytype_uint16 const   )93,      (yytype_uint16 const   )96,      (yytype_uint16 const   )99,      (yytype_uint16 const   )102, 
        (yytype_uint16 const   )105,      (yytype_uint16 const   )108,      (yytype_uint16 const   )112,      (yytype_uint16 const   )117, 
        (yytype_uint16 const   )122,      (yytype_uint16 const   )127,      (yytype_uint16 const   )133,      (yytype_uint16 const   )137, 
        (yytype_uint16 const   )138,      (yytype_uint16 const   )142,      (yytype_uint16 const   )143,      (yytype_uint16 const   )146, 
        (yytype_uint16 const   )150,      (yytype_uint16 const   )153,      (yytype_uint16 const   )155,      (yytype_uint16 const   )159, 
        (yytype_uint16 const   )160,      (yytype_uint16 const   )163,      (yytype_uint16 const   )166,      (yytype_uint16 const   )169, 
        (yytype_uint16 const   )172,      (yytype_uint16 const   )175,      (yytype_uint16 const   )180,      (yytype_uint16 const   )184, 
        (yytype_uint16 const   )187,      (yytype_uint16 const   )192,      (yytype_uint16 const   )193,      (yytype_uint16 const   )196, 
        (yytype_uint16 const   )200,      (yytype_uint16 const   )202,      (yytype_uint16 const   )206,      (yytype_uint16 const   )207, 
        (yytype_uint16 const   )210,      (yytype_uint16 const   )213,      (yytype_uint16 const   )216,      (yytype_uint16 const   )220, 
        (yytype_uint16 const   )224,      (yytype_uint16 const   )228,      (yytype_uint16 const   )230,      (yytype_uint16 const   )234, 
        (yytype_uint16 const   )235,      (yytype_uint16 const   )238,      (yytype_uint16 const   )241,      (yytype_uint16 const   )244, 
        (yytype_uint16 const   )248,      (yytype_uint16 const   )252,      (yytype_uint16 const   )255,      (yytype_uint16 const   )258, 
        (yytype_uint16 const   )261,      (yytype_uint16 const   )262,      (yytype_uint16 const   )265,      (yytype_uint16 const   )268, 
        (yytype_uint16 const   )271,      (yytype_uint16 const   )276,      (yytype_uint16 const   )277,      (yytype_uint16 const   )280, 
        (yytype_uint16 const   )283,      (yytype_uint16 const   )286,      (yytype_uint16 const   )287,      (yytype_uint16 const   )290, 
        (yytype_uint16 const   )292,      (yytype_uint16 const   )294,      (yytype_uint16 const   )297,      (yytype_uint16 const   )300, 
        (yytype_uint16 const   )303,      (yytype_uint16 const   )305,      (yytype_uint16 const   )308,      (yytype_uint16 const   )309, 
        (yytype_uint16 const   )312,      (yytype_uint16 const   )314,      (yytype_uint16 const   )318,      (yytype_uint16 const   )322, 
        (yytype_uint16 const   )326,      (yytype_uint16 const   )329,      (yytype_uint16 const   )333,      (yytype_uint16 const   )337, 
        (yytype_uint16 const   )339,      (yytype_uint16 const   )341,      (yytype_uint16 const   )342};
#line 490 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/zconf.tab.c"
static yytype_int8 const   yyrhs[344]  = 
#line 490
  {      (yytype_int8 const   )37,      (yytype_int8 const   )0,      (yytype_int8 const   )-1,      (yytype_int8 const   )81, 
        (yytype_int8 const   )38,      (yytype_int8 const   )-1,      (yytype_int8 const   )38,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )63,      (yytype_int8 const   )39,      (yytype_int8 const   )-1,      (yytype_int8 const   )39, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )-1,      (yytype_int8 const   )39,      (yytype_int8 const   )41, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )39,      (yytype_int8 const   )55,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )39,      (yytype_int8 const   )67,      (yytype_int8 const   )-1,      (yytype_int8 const   )39, 
        (yytype_int8 const   )80,      (yytype_int8 const   )-1,      (yytype_int8 const   )39,      (yytype_int8 const   )26, 
        (yytype_int8 const   )1,      (yytype_int8 const   )31,      (yytype_int8 const   )-1,      (yytype_int8 const   )39, 
        (yytype_int8 const   )40,      (yytype_int8 const   )1,      (yytype_int8 const   )31,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )39,      (yytype_int8 const   )1,      (yytype_int8 const   )31,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )16,      (yytype_int8 const   )-1,      (yytype_int8 const   )18,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )19,      (yytype_int8 const   )-1,      (yytype_int8 const   )21,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )17,      (yytype_int8 const   )-1,      (yytype_int8 const   )22,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )20,      (yytype_int8 const   )-1,      (yytype_int8 const   )23,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )31,      (yytype_int8 const   )-1,      (yytype_int8 const   )61,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )71,      (yytype_int8 const   )-1,      (yytype_int8 const   )44,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )46,      (yytype_int8 const   )-1,      (yytype_int8 const   )69,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )26,      (yytype_int8 const   )1,      (yytype_int8 const   )31,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )1,      (yytype_int8 const   )31,      (yytype_int8 const   )-1,      (yytype_int8 const   )10, 
        (yytype_int8 const   )26,      (yytype_int8 const   )31,      (yytype_int8 const   )-1,      (yytype_int8 const   )43, 
        (yytype_int8 const   )47,      (yytype_int8 const   )-1,      (yytype_int8 const   )11,      (yytype_int8 const   )26, 
        (yytype_int8 const   )31,      (yytype_int8 const   )-1,      (yytype_int8 const   )45,      (yytype_int8 const   )47, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )-1,      (yytype_int8 const   )47,      (yytype_int8 const   )48, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )47,      (yytype_int8 const   )49,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )47,      (yytype_int8 const   )75,      (yytype_int8 const   )-1,      (yytype_int8 const   )47, 
        (yytype_int8 const   )73,      (yytype_int8 const   )-1,      (yytype_int8 const   )47,      (yytype_int8 const   )42, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )47,      (yytype_int8 const   )31,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )19,      (yytype_int8 const   )78,      (yytype_int8 const   )31,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )18,      (yytype_int8 const   )79,      (yytype_int8 const   )82,      (yytype_int8 const   )31, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )20,      (yytype_int8 const   )83,      (yytype_int8 const   )82, 
        (yytype_int8 const   )31,      (yytype_int8 const   )-1,      (yytype_int8 const   )21,      (yytype_int8 const   )26, 
        (yytype_int8 const   )82,      (yytype_int8 const   )31,      (yytype_int8 const   )-1,      (yytype_int8 const   )22, 
        (yytype_int8 const   )84,      (yytype_int8 const   )84,      (yytype_int8 const   )82,      (yytype_int8 const   )31, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )24,      (yytype_int8 const   )50,      (yytype_int8 const   )31, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )-1,      (yytype_int8 const   )50,      (yytype_int8 const   )26, 
        (yytype_int8 const   )51,      (yytype_int8 const   )-1,      (yytype_int8 const   )-1,      (yytype_int8 const   )34, 
        (yytype_int8 const   )79,      (yytype_int8 const   )-1,      (yytype_int8 const   )7,      (yytype_int8 const   )85, 
        (yytype_int8 const   )31,      (yytype_int8 const   )-1,      (yytype_int8 const   )52,      (yytype_int8 const   )56, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )80,      (yytype_int8 const   )-1,      (yytype_int8 const   )53, 
        (yytype_int8 const   )58,      (yytype_int8 const   )54,      (yytype_int8 const   )-1,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )56,      (yytype_int8 const   )57,      (yytype_int8 const   )-1,      (yytype_int8 const   )56, 
        (yytype_int8 const   )75,      (yytype_int8 const   )-1,      (yytype_int8 const   )56,      (yytype_int8 const   )73, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )56,      (yytype_int8 const   )31,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )56,      (yytype_int8 const   )42,      (yytype_int8 const   )-1,      (yytype_int8 const   )18, 
        (yytype_int8 const   )79,      (yytype_int8 const   )82,      (yytype_int8 const   )31,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )19,      (yytype_int8 const   )78,      (yytype_int8 const   )31,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )17,      (yytype_int8 const   )31,      (yytype_int8 const   )-1,      (yytype_int8 const   )20, 
        (yytype_int8 const   )26,      (yytype_int8 const   )82,      (yytype_int8 const   )31,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )58,      (yytype_int8 const   )41,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )14,      (yytype_int8 const   )83,      (yytype_int8 const   )81,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )80,      (yytype_int8 const   )-1,      (yytype_int8 const   )59,      (yytype_int8 const   )62, 
        (yytype_int8 const   )60,      (yytype_int8 const   )-1,      (yytype_int8 const   )-1,      (yytype_int8 const   )62, 
        (yytype_int8 const   )41,      (yytype_int8 const   )-1,      (yytype_int8 const   )62,      (yytype_int8 const   )67, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )62,      (yytype_int8 const   )55,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )3,      (yytype_int8 const   )79,      (yytype_int8 const   )81,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )4,      (yytype_int8 const   )79,      (yytype_int8 const   )31,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )64,      (yytype_int8 const   )76,      (yytype_int8 const   )74,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )80,      (yytype_int8 const   )-1,      (yytype_int8 const   )65,      (yytype_int8 const   )68, 
        (yytype_int8 const   )66,      (yytype_int8 const   )-1,      (yytype_int8 const   )-1,      (yytype_int8 const   )68, 
        (yytype_int8 const   )41,      (yytype_int8 const   )-1,      (yytype_int8 const   )68,      (yytype_int8 const   )67, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )68,      (yytype_int8 const   )55,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )6,      (yytype_int8 const   )79,      (yytype_int8 const   )31,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )9,      (yytype_int8 const   )79,      (yytype_int8 const   )31,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )70,      (yytype_int8 const   )74,      (yytype_int8 const   )-1,      (yytype_int8 const   )12, 
        (yytype_int8 const   )31,      (yytype_int8 const   )-1,      (yytype_int8 const   )72,      (yytype_int8 const   )13, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )-1,      (yytype_int8 const   )74,      (yytype_int8 const   )75, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )74,      (yytype_int8 const   )31,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )74,      (yytype_int8 const   )42,      (yytype_int8 const   )-1,      (yytype_int8 const   )16, 
        (yytype_int8 const   )25,      (yytype_int8 const   )83,      (yytype_int8 const   )31,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )76,      (yytype_int8 const   )77,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )76,      (yytype_int8 const   )31,      (yytype_int8 const   )-1,      (yytype_int8 const   )23, 
        (yytype_int8 const   )82,      (yytype_int8 const   )-1,      (yytype_int8 const   )-1,      (yytype_int8 const   )79, 
        (yytype_int8 const   )82,      (yytype_int8 const   )-1,      (yytype_int8 const   )26,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )27,      (yytype_int8 const   )-1,      (yytype_int8 const   )5,      (yytype_int8 const   )31, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )8,      (yytype_int8 const   )31,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )15,      (yytype_int8 const   )31,      (yytype_int8 const   )-1,      (yytype_int8 const   )31, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )81,      (yytype_int8 const   )31,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )14,      (yytype_int8 const   )83,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )84,      (yytype_int8 const   )-1,      (yytype_int8 const   )84,      (yytype_int8 const   )34, 
        (yytype_int8 const   )84,      (yytype_int8 const   )-1,      (yytype_int8 const   )84,      (yytype_int8 const   )28, 
        (yytype_int8 const   )84,      (yytype_int8 const   )-1,      (yytype_int8 const   )30,      (yytype_int8 const   )83, 
        (yytype_int8 const   )29,      (yytype_int8 const   )-1,      (yytype_int8 const   )35,      (yytype_int8 const   )83, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )83,      (yytype_int8 const   )32,      (yytype_int8 const   )83, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )83,      (yytype_int8 const   )33,      (yytype_int8 const   )83, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )26,      (yytype_int8 const   )-1,      (yytype_int8 const   )27, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )-1,      (yytype_int8 const   )26,      (yytype_int8 const   )-1};
#line 530 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/zconf.tab.c"
static yytype_uint16 const   yyrline[119]  = 
#line 530
  {      (yytype_uint16 const   )0,      (yytype_uint16 const   )104,      (yytype_uint16 const   )104,      (yytype_uint16 const   )104, 
        (yytype_uint16 const   )106,      (yytype_uint16 const   )106,      (yytype_uint16 const   )108,      (yytype_uint16 const   )110, 
        (yytype_uint16 const   )111,      (yytype_uint16 const   )112,      (yytype_uint16 const   )113,      (yytype_uint16 const   )114, 
        (yytype_uint16 const   )115,      (yytype_uint16 const   )119,      (yytype_uint16 const   )123,      (yytype_uint16 const   )123, 
        (yytype_uint16 const   )123,      (yytype_uint16 const   )123,      (yytype_uint16 const   )123,      (yytype_uint16 const   )123, 
        (yytype_uint16 const   )123,      (yytype_uint16 const   )123,      (yytype_uint16 const   )127,      (yytype_uint16 const   )128, 
        (yytype_uint16 const   )129,      (yytype_uint16 const   )130,      (yytype_uint16 const   )131,      (yytype_uint16 const   )132, 
        (yytype_uint16 const   )136,      (yytype_uint16 const   )137,      (yytype_uint16 const   )143,      (yytype_uint16 const   )151, 
        (yytype_uint16 const   )157,      (yytype_uint16 const   )165,      (yytype_uint16 const   )175,      (yytype_uint16 const   )177, 
        (yytype_uint16 const   )178,      (yytype_uint16 const   )179,      (yytype_uint16 const   )180,      (yytype_uint16 const   )181, 
        (yytype_uint16 const   )182,      (yytype_uint16 const   )185,      (yytype_uint16 const   )193,      (yytype_uint16 const   )199, 
        (yytype_uint16 const   )209,      (yytype_uint16 const   )215,      (yytype_uint16 const   )221,      (yytype_uint16 const   )224, 
        (yytype_uint16 const   )226,      (yytype_uint16 const   )237,      (yytype_uint16 const   )238,      (yytype_uint16 const   )243, 
        (yytype_uint16 const   )252,      (yytype_uint16 const   )257,      (yytype_uint16 const   )265,      (yytype_uint16 const   )268, 
        (yytype_uint16 const   )270,      (yytype_uint16 const   )271,      (yytype_uint16 const   )272,      (yytype_uint16 const   )273, 
        (yytype_uint16 const   )274,      (yytype_uint16 const   )277,      (yytype_uint16 const   )283,      (yytype_uint16 const   )294, 
        (yytype_uint16 const   )300,      (yytype_uint16 const   )310,      (yytype_uint16 const   )312,      (yytype_uint16 const   )317, 
        (yytype_uint16 const   )325,      (yytype_uint16 const   )333,      (yytype_uint16 const   )336,      (yytype_uint16 const   )338, 
        (yytype_uint16 const   )339,      (yytype_uint16 const   )340,      (yytype_uint16 const   )345,      (yytype_uint16 const   )352, 
        (yytype_uint16 const   )359,      (yytype_uint16 const   )364,      (yytype_uint16 const   )372,      (yytype_uint16 const   )375, 
        (yytype_uint16 const   )377,      (yytype_uint16 const   )378,      (yytype_uint16 const   )379,      (yytype_uint16 const   )382, 
        (yytype_uint16 const   )390,      (yytype_uint16 const   )397,      (yytype_uint16 const   )404,      (yytype_uint16 const   )410, 
        (yytype_uint16 const   )417,      (yytype_uint16 const   )419,      (yytype_uint16 const   )420,      (yytype_uint16 const   )421, 
        (yytype_uint16 const   )424,      (yytype_uint16 const   )432,      (yytype_uint16 const   )434,      (yytype_uint16 const   )435, 
        (yytype_uint16 const   )438,      (yytype_uint16 const   )445,      (yytype_uint16 const   )447,      (yytype_uint16 const   )452, 
        (yytype_uint16 const   )453,      (yytype_uint16 const   )456,      (yytype_uint16 const   )457,      (yytype_uint16 const   )458, 
        (yytype_uint16 const   )462,      (yytype_uint16 const   )463,      (yytype_uint16 const   )466,      (yytype_uint16 const   )467, 
        (yytype_uint16 const   )470,      (yytype_uint16 const   )471,      (yytype_uint16 const   )472,      (yytype_uint16 const   )473, 
        (yytype_uint16 const   )474,      (yytype_uint16 const   )475,      (yytype_uint16 const   )476,      (yytype_uint16 const   )479, 
        (yytype_uint16 const   )480,      (yytype_uint16 const   )483,      (yytype_uint16 const   )484};
#line 550 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/zconf.tab.c"
static char const   * const  yytname[87]  = 
#line 550
  {      (char const   */* const  */)"$end",      (char const   */* const  */)"error",      (char const   */* const  */)"$undefined",      (char const   */* const  */)"T_MAINMENU", 
        (char const   */* const  */)"T_MENU",      (char const   */* const  */)"T_ENDMENU",      (char const   */* const  */)"T_SOURCE",      (char const   */* const  */)"T_CHOICE", 
        (char const   */* const  */)"T_ENDCHOICE",      (char const   */* const  */)"T_COMMENT",      (char const   */* const  */)"T_CONFIG",      (char const   */* const  */)"T_MENUCONFIG", 
        (char const   */* const  */)"T_HELP",      (char const   */* const  */)"T_HELPTEXT",      (char const   */* const  */)"T_IF",      (char const   */* const  */)"T_ENDIF", 
        (char const   */* const  */)"T_DEPENDS",      (char const   */* const  */)"T_OPTIONAL",      (char const   */* const  */)"T_PROMPT",      (char const   */* const  */)"T_TYPE", 
        (char const   */* const  */)"T_DEFAULT",      (char const   */* const  */)"T_SELECT",      (char const   */* const  */)"T_RANGE",      (char const   */* const  */)"T_VISIBLE", 
        (char const   */* const  */)"T_OPTION",      (char const   */* const  */)"T_ON",      (char const   */* const  */)"T_WORD",      (char const   */* const  */)"T_WORD_QUOTE", 
        (char const   */* const  */)"T_UNEQUAL",      (char const   */* const  */)"T_CLOSE_PAREN",      (char const   */* const  */)"T_OPEN_PAREN",      (char const   */* const  */)"T_EOL", 
        (char const   */* const  */)"T_OR",      (char const   */* const  */)"T_AND",      (char const   */* const  */)"T_EQUAL",      (char const   */* const  */)"T_NOT", 
        (char const   */* const  */)"$accept",      (char const   */* const  */)"input",      (char const   */* const  */)"start",      (char const   */* const  */)"stmt_list", 
        (char const   */* const  */)"option_name",      (char const   */* const  */)"common_stmt",      (char const   */* const  */)"option_error",      (char const   */* const  */)"config_entry_start", 
        (char const   */* const  */)"config_stmt",      (char const   */* const  */)"menuconfig_entry_start",      (char const   */* const  */)"menuconfig_stmt",      (char const   */* const  */)"config_option_list", 
        (char const   */* const  */)"config_option",      (char const   */* const  */)"symbol_option",      (char const   */* const  */)"symbol_option_list",      (char const   */* const  */)"symbol_option_arg", 
        (char const   */* const  */)"choice",      (char const   */* const  */)"choice_entry",      (char const   */* const  */)"choice_end",      (char const   */* const  */)"choice_stmt", 
        (char const   */* const  */)"choice_option_list",      (char const   */* const  */)"choice_option",      (char const   */* const  */)"choice_block",      (char const   */* const  */)"if_entry", 
        (char const   */* const  */)"if_end",      (char const   */* const  */)"if_stmt",      (char const   */* const  */)"if_block",      (char const   */* const  */)"mainmenu_stmt", 
        (char const   */* const  */)"menu",      (char const   */* const  */)"menu_entry",      (char const   */* const  */)"menu_end",      (char const   */* const  */)"menu_stmt", 
        (char const   */* const  */)"menu_block",      (char const   */* const  */)"source_stmt",      (char const   */* const  */)"comment",      (char const   */* const  */)"comment_stmt", 
        (char const   */* const  */)"help_start",      (char const   */* const  */)"help",      (char const   */* const  */)"depends_list",      (char const   */* const  */)"depends", 
        (char const   */* const  */)"visibility_list",      (char const   */* const  */)"visible",      (char const   */* const  */)"prompt_stmt_opt",      (char const   */* const  */)"prompt", 
        (char const   */* const  */)"end",      (char const   */* const  */)"nl",      (char const   */* const  */)"if_expr",      (char const   */* const  */)"expr", 
        (char const   */* const  */)"symbol",      (char const   */* const  */)"word_opt",      (char const   */* const  */)0};
#line 585 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/zconf.tab.c"
static yytype_uint8 const   yyr1[119]  = 
#line 585
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )36,      (yytype_uint8 const   )37,      (yytype_uint8 const   )37, 
        (yytype_uint8 const   )38,      (yytype_uint8 const   )38,      (yytype_uint8 const   )39,      (yytype_uint8 const   )39, 
        (yytype_uint8 const   )39,      (yytype_uint8 const   )39,      (yytype_uint8 const   )39,      (yytype_uint8 const   )39, 
        (yytype_uint8 const   )39,      (yytype_uint8 const   )39,      (yytype_uint8 const   )40,      (yytype_uint8 const   )40, 
        (yytype_uint8 const   )40,      (yytype_uint8 const   )40,      (yytype_uint8 const   )40,      (yytype_uint8 const   )40, 
        (yytype_uint8 const   )40,      (yytype_uint8 const   )40,      (yytype_uint8 const   )41,      (yytype_uint8 const   )41, 
        (yytype_uint8 const   )41,      (yytype_uint8 const   )41,      (yytype_uint8 const   )41,      (yytype_uint8 const   )41, 
        (yytype_uint8 const   )42,      (yytype_uint8 const   )42,      (yytype_uint8 const   )43,      (yytype_uint8 const   )44, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )46,      (yytype_uint8 const   )47,      (yytype_uint8 const   )47, 
        (yytype_uint8 const   )47,      (yytype_uint8 const   )47,      (yytype_uint8 const   )47,      (yytype_uint8 const   )47, 
        (yytype_uint8 const   )47,      (yytype_uint8 const   )48,      (yytype_uint8 const   )48,      (yytype_uint8 const   )48, 
        (yytype_uint8 const   )48,      (yytype_uint8 const   )48,      (yytype_uint8 const   )49,      (yytype_uint8 const   )50, 
        (yytype_uint8 const   )50,      (yytype_uint8 const   )51,      (yytype_uint8 const   )51,      (yytype_uint8 const   )52, 
        (yytype_uint8 const   )53,      (yytype_uint8 const   )54,      (yytype_uint8 const   )55,      (yytype_uint8 const   )56, 
        (yytype_uint8 const   )56,      (yytype_uint8 const   )56,      (yytype_uint8 const   )56,      (yytype_uint8 const   )56, 
        (yytype_uint8 const   )56,      (yytype_uint8 const   )57,      (yytype_uint8 const   )57,      (yytype_uint8 const   )57, 
        (yytype_uint8 const   )57,      (yytype_uint8 const   )58,      (yytype_uint8 const   )58,      (yytype_uint8 const   )59, 
        (yytype_uint8 const   )60,      (yytype_uint8 const   )61,      (yytype_uint8 const   )62,      (yytype_uint8 const   )62, 
        (yytype_uint8 const   )62,      (yytype_uint8 const   )62,      (yytype_uint8 const   )63,      (yytype_uint8 const   )64, 
        (yytype_uint8 const   )65,      (yytype_uint8 const   )66,      (yytype_uint8 const   )67,      (yytype_uint8 const   )68, 
        (yytype_uint8 const   )68,      (yytype_uint8 const   )68,      (yytype_uint8 const   )68,      (yytype_uint8 const   )69, 
        (yytype_uint8 const   )70,      (yytype_uint8 const   )71,      (yytype_uint8 const   )72,      (yytype_uint8 const   )73, 
        (yytype_uint8 const   )74,      (yytype_uint8 const   )74,      (yytype_uint8 const   )74,      (yytype_uint8 const   )74, 
        (yytype_uint8 const   )75,      (yytype_uint8 const   )76,      (yytype_uint8 const   )76,      (yytype_uint8 const   )76, 
        (yytype_uint8 const   )77,      (yytype_uint8 const   )78,      (yytype_uint8 const   )78,      (yytype_uint8 const   )79, 
        (yytype_uint8 const   )79,      (yytype_uint8 const   )80,      (yytype_uint8 const   )80,      (yytype_uint8 const   )80, 
        (yytype_uint8 const   )81,      (yytype_uint8 const   )81,      (yytype_uint8 const   )82,      (yytype_uint8 const   )82, 
        (yytype_uint8 const   )83,      (yytype_uint8 const   )83,      (yytype_uint8 const   )83,      (yytype_uint8 const   )83, 
        (yytype_uint8 const   )83,      (yytype_uint8 const   )83,      (yytype_uint8 const   )83,      (yytype_uint8 const   )84, 
        (yytype_uint8 const   )84,      (yytype_uint8 const   )85,      (yytype_uint8 const   )85};
#line 602 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/zconf.tab.c"
static yytype_uint8 const   yyr2[119]  = 
#line 602
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )2,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )5,      (yytype_uint8 const   )3,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )4,      (yytype_uint8 const   )3,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )0,      (yytype_uint8 const   )1};
#line 621 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/zconf.tab.c"
static yytype_uint8 const   yydefact[191]  = 
#line 621
  {      (yytype_uint8 const   )6,      (yytype_uint8 const   )0,      (yytype_uint8 const   )104,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )0,      (yytype_uint8 const   )6,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )99,      (yytype_uint8 const   )100,      (yytype_uint8 const   )0,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )117,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )14, 
        (yytype_uint8 const   )18,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )19,      (yytype_uint8 const   )21,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )22,      (yytype_uint8 const   )0,      (yytype_uint8 const   )7,      (yytype_uint8 const   )34, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )34,      (yytype_uint8 const   )26,      (yytype_uint8 const   )55, 
        (yytype_uint8 const   )65,      (yytype_uint8 const   )8,      (yytype_uint8 const   )70,      (yytype_uint8 const   )23, 
        (yytype_uint8 const   )93,      (yytype_uint8 const   )79,      (yytype_uint8 const   )9,      (yytype_uint8 const   )27, 
        (yytype_uint8 const   )88,      (yytype_uint8 const   )24,      (yytype_uint8 const   )10,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )105,      (yytype_uint8 const   )2,      (yytype_uint8 const   )74,      (yytype_uint8 const   )13, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )101,      (yytype_uint8 const   )0,      (yytype_uint8 const   )118, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )102,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )115,      (yytype_uint8 const   )116,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )108,      (yytype_uint8 const   )103, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )88, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )75,      (yytype_uint8 const   )83, 
        (yytype_uint8 const   )51,      (yytype_uint8 const   )84,      (yytype_uint8 const   )30,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )112,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )67,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )11, 
        (yytype_uint8 const   )12,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )97,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )47,      (yytype_uint8 const   )0,      (yytype_uint8 const   )40, 
        (yytype_uint8 const   )39,      (yytype_uint8 const   )35,      (yytype_uint8 const   )36,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )38,      (yytype_uint8 const   )37,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )97,      (yytype_uint8 const   )0,      (yytype_uint8 const   )59,      (yytype_uint8 const   )60, 
        (yytype_uint8 const   )56,      (yytype_uint8 const   )58,      (yytype_uint8 const   )57,      (yytype_uint8 const   )66, 
        (yytype_uint8 const   )54,      (yytype_uint8 const   )53,      (yytype_uint8 const   )71,      (yytype_uint8 const   )73, 
        (yytype_uint8 const   )69,      (yytype_uint8 const   )72,      (yytype_uint8 const   )68,      (yytype_uint8 const   )106, 
        (yytype_uint8 const   )95,      (yytype_uint8 const   )0,      (yytype_uint8 const   )94,      (yytype_uint8 const   )80, 
        (yytype_uint8 const   )82,      (yytype_uint8 const   )78,      (yytype_uint8 const   )81,      (yytype_uint8 const   )77, 
        (yytype_uint8 const   )90,      (yytype_uint8 const   )91,      (yytype_uint8 const   )89,      (yytype_uint8 const   )111, 
        (yytype_uint8 const   )113,      (yytype_uint8 const   )114,      (yytype_uint8 const   )110,      (yytype_uint8 const   )109, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )86,      (yytype_uint8 const   )0,      (yytype_uint8 const   )106, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )106,      (yytype_uint8 const   )106,      (yytype_uint8 const   )106, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )87, 
        (yytype_uint8 const   )63,      (yytype_uint8 const   )106,      (yytype_uint8 const   )0,      (yytype_uint8 const   )106, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )96,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )41,      (yytype_uint8 const   )98,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )106,      (yytype_uint8 const   )49,      (yytype_uint8 const   )46,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )62,      (yytype_uint8 const   )0,      (yytype_uint8 const   )107, 
        (yytype_uint8 const   )92,      (yytype_uint8 const   )42,      (yytype_uint8 const   )43,      (yytype_uint8 const   )44, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )48,      (yytype_uint8 const   )61, 
        (yytype_uint8 const   )64,      (yytype_uint8 const   )45,      (yytype_uint8 const   )50};
#line 646 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/zconf.tab.c"
static yytype_int16 const   yydefgoto[50]  = 
#line 646
  {      (yytype_int16 const   )-1,      (yytype_int16 const   )3,      (yytype_int16 const   )4,      (yytype_int16 const   )5, 
        (yytype_int16 const   )33,      (yytype_int16 const   )34,      (yytype_int16 const   )108,      (yytype_int16 const   )35, 
        (yytype_int16 const   )36,      (yytype_int16 const   )37,      (yytype_int16 const   )38,      (yytype_int16 const   )74, 
        (yytype_int16 const   )109,      (yytype_int16 const   )110,      (yytype_int16 const   )157,      (yytype_int16 const   )186, 
        (yytype_int16 const   )39,      (yytype_int16 const   )40,      (yytype_int16 const   )124,      (yytype_int16 const   )41, 
        (yytype_int16 const   )76,      (yytype_int16 const   )120,      (yytype_int16 const   )77,      (yytype_int16 const   )42, 
        (yytype_int16 const   )128,      (yytype_int16 const   )43,      (yytype_int16 const   )78,      (yytype_int16 const   )6, 
        (yytype_int16 const   )44,      (yytype_int16 const   )45,      (yytype_int16 const   )137,      (yytype_int16 const   )46, 
        (yytype_int16 const   )80,      (yytype_int16 const   )47,      (yytype_int16 const   )48,      (yytype_int16 const   )49, 
        (yytype_int16 const   )111,      (yytype_int16 const   )112,      (yytype_int16 const   )81,      (yytype_int16 const   )113, 
        (yytype_int16 const   )79,      (yytype_int16 const   )134,      (yytype_int16 const   )152,      (yytype_int16 const   )153, 
        (yytype_int16 const   )50,      (yytype_int16 const   )7,      (yytype_int16 const   )165,      (yytype_int16 const   )69, 
        (yytype_int16 const   )70,      (yytype_int16 const   )60};
#line 658 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/zconf.tab.c"
static yytype_int16 const   yypact[191]  = 
#line 658
  {      (yytype_int16 const   )4,      (yytype_int16 const   )42,      (yytype_int16 const   )-90,      (yytype_int16 const   )96, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )111,      (yytype_int16 const   )-90,      (yytype_int16 const   )15, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )75,      (yytype_int16 const   )-90, 
        (yytype_int16 const   )82,      (yytype_int16 const   )42,      (yytype_int16 const   )104,      (yytype_int16 const   )42, 
        (yytype_int16 const   )110,      (yytype_int16 const   )107,      (yytype_int16 const   )42,      (yytype_int16 const   )115, 
        (yytype_int16 const   )125,      (yytype_int16 const   )-4,      (yytype_int16 const   )121,      (yytype_int16 const   )-90, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )162, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )163,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )139, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )138,      (yytype_int16 const   )-90, 
        (yytype_int16 const   )142,      (yytype_int16 const   )-90,      (yytype_int16 const   )143,      (yytype_int16 const   )-90, 
        (yytype_int16 const   )152,      (yytype_int16 const   )-90,      (yytype_int16 const   )164,      (yytype_int16 const   )167, 
        (yytype_int16 const   )168,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-4, 
        (yytype_int16 const   )-4,      (yytype_int16 const   )77,      (yytype_int16 const   )-18,      (yytype_int16 const   )-90, 
        (yytype_int16 const   )177,      (yytype_int16 const   )185,      (yytype_int16 const   )33,      (yytype_int16 const   )71, 
        (yytype_int16 const   )195,      (yytype_int16 const   )247,      (yytype_int16 const   )236,      (yytype_int16 const   )-2, 
        (yytype_int16 const   )236,      (yytype_int16 const   )171,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90, 
        (yytype_int16 const   )41,      (yytype_int16 const   )-90,      (yytype_int16 const   )-4,      (yytype_int16 const   )-4, 
        (yytype_int16 const   )138,      (yytype_int16 const   )97,      (yytype_int16 const   )97,      (yytype_int16 const   )-90, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )186,      (yytype_int16 const   )187,      (yytype_int16 const   )194, 
        (yytype_int16 const   )42,      (yytype_int16 const   )42,      (yytype_int16 const   )-4,      (yytype_int16 const   )196, 
        (yytype_int16 const   )97,      (yytype_int16 const   )-90,      (yytype_int16 const   )219,      (yytype_int16 const   )-90, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )210, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )204,      (yytype_int16 const   )42, 
        (yytype_int16 const   )42,      (yytype_int16 const   )199,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )222, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )223,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90, 
        (yytype_int16 const   )215,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-4,      (yytype_int16 const   )222, 
        (yytype_int16 const   )228,      (yytype_int16 const   )222,      (yytype_int16 const   )-5,      (yytype_int16 const   )222, 
        (yytype_int16 const   )97,      (yytype_int16 const   )35,      (yytype_int16 const   )229,      (yytype_int16 const   )-90, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )222,      (yytype_int16 const   )232,      (yytype_int16 const   )222, 
        (yytype_int16 const   )-4,      (yytype_int16 const   )-90,      (yytype_int16 const   )135,      (yytype_int16 const   )233, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )234,      (yytype_int16 const   )235, 
        (yytype_int16 const   )222,      (yytype_int16 const   )240,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90, 
        (yytype_int16 const   )237,      (yytype_int16 const   )-90,      (yytype_int16 const   )239,      (yytype_int16 const   )-13, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90, 
        (yytype_int16 const   )244,      (yytype_int16 const   )42,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90};
#line 683 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/zconf.tab.c"
static yytype_int16 const   yypgoto[50]  = 
#line 683
  {      (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )269,      (yytype_int16 const   )271, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )23,      (yytype_int16 const   )-70,      (yytype_int16 const   )-90, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )243, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-48, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-20, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )-90, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )206,      (yytype_int16 const   )205,      (yytype_int16 const   )-68, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )-90,      (yytype_int16 const   )169,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )27,      (yytype_int16 const   )-7,      (yytype_int16 const   )118,      (yytype_int16 const   )-66, 
        (yytype_int16 const   )-89,      (yytype_int16 const   )-90};
#line 697 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/zconf.tab.c"
static yytype_int16 const   yytable[291]  = 
#line 697
  {      (yytype_int16 const   )10,      (yytype_int16 const   )88,      (yytype_int16 const   )89,      (yytype_int16 const   )54, 
        (yytype_int16 const   )146,      (yytype_int16 const   )147,      (yytype_int16 const   )119,      (yytype_int16 const   )1, 
        (yytype_int16 const   )122,      (yytype_int16 const   )164,      (yytype_int16 const   )93,      (yytype_int16 const   )141, 
        (yytype_int16 const   )56,      (yytype_int16 const   )142,      (yytype_int16 const   )58,      (yytype_int16 const   )156, 
        (yytype_int16 const   )94,      (yytype_int16 const   )62,      (yytype_int16 const   )1,      (yytype_int16 const   )90, 
        (yytype_int16 const   )91,      (yytype_int16 const   )131,      (yytype_int16 const   )65,      (yytype_int16 const   )66, 
        (yytype_int16 const   )144,      (yytype_int16 const   )145,      (yytype_int16 const   )67,      (yytype_int16 const   )90, 
        (yytype_int16 const   )91,      (yytype_int16 const   )132,      (yytype_int16 const   )127,      (yytype_int16 const   )68, 
        (yytype_int16 const   )136,      (yytype_int16 const   )-31,      (yytype_int16 const   )97,      (yytype_int16 const   )2, 
        (yytype_int16 const   )154,      (yytype_int16 const   )-31,      (yytype_int16 const   )-31,      (yytype_int16 const   )-31, 
        (yytype_int16 const   )-31,      (yytype_int16 const   )-31,      (yytype_int16 const   )-31,      (yytype_int16 const   )-31, 
        (yytype_int16 const   )-31,      (yytype_int16 const   )98,      (yytype_int16 const   )52,      (yytype_int16 const   )-31, 
        (yytype_int16 const   )-31,      (yytype_int16 const   )99,      (yytype_int16 const   )-31,      (yytype_int16 const   )100, 
        (yytype_int16 const   )101,      (yytype_int16 const   )102,      (yytype_int16 const   )103,      (yytype_int16 const   )104, 
        (yytype_int16 const   )-31,      (yytype_int16 const   )105,      (yytype_int16 const   )129,      (yytype_int16 const   )106, 
        (yytype_int16 const   )138,      (yytype_int16 const   )173,      (yytype_int16 const   )92,      (yytype_int16 const   )141, 
        (yytype_int16 const   )107,      (yytype_int16 const   )142,      (yytype_int16 const   )174,      (yytype_int16 const   )172, 
        (yytype_int16 const   )8,      (yytype_int16 const   )9,      (yytype_int16 const   )143,      (yytype_int16 const   )-33, 
        (yytype_int16 const   )97,      (yytype_int16 const   )90,      (yytype_int16 const   )91,      (yytype_int16 const   )-33, 
        (yytype_int16 const   )-33,      (yytype_int16 const   )-33,      (yytype_int16 const   )-33,      (yytype_int16 const   )-33, 
        (yytype_int16 const   )-33,      (yytype_int16 const   )-33,      (yytype_int16 const   )-33,      (yytype_int16 const   )98, 
        (yytype_int16 const   )166,      (yytype_int16 const   )-33,      (yytype_int16 const   )-33,      (yytype_int16 const   )99, 
        (yytype_int16 const   )-33,      (yytype_int16 const   )100,      (yytype_int16 const   )101,      (yytype_int16 const   )102, 
        (yytype_int16 const   )103,      (yytype_int16 const   )104,      (yytype_int16 const   )-33,      (yytype_int16 const   )105, 
        (yytype_int16 const   )11,      (yytype_int16 const   )106,      (yytype_int16 const   )179,      (yytype_int16 const   )151, 
        (yytype_int16 const   )123,      (yytype_int16 const   )126,      (yytype_int16 const   )107,      (yytype_int16 const   )135, 
        (yytype_int16 const   )125,      (yytype_int16 const   )130,      (yytype_int16 const   )2,      (yytype_int16 const   )139, 
        (yytype_int16 const   )2,      (yytype_int16 const   )90,      (yytype_int16 const   )91,      (yytype_int16 const   )-5, 
        (yytype_int16 const   )12,      (yytype_int16 const   )55,      (yytype_int16 const   )161,      (yytype_int16 const   )13, 
        (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )16,      (yytype_int16 const   )17, 
        (yytype_int16 const   )18,      (yytype_int16 const   )19,      (yytype_int16 const   )20,      (yytype_int16 const   )65, 
        (yytype_int16 const   )66,      (yytype_int16 const   )21,      (yytype_int16 const   )22,      (yytype_int16 const   )23, 
        (yytype_int16 const   )24,      (yytype_int16 const   )25,      (yytype_int16 const   )26,      (yytype_int16 const   )27, 
        (yytype_int16 const   )28,      (yytype_int16 const   )29,      (yytype_int16 const   )30,      (yytype_int16 const   )57, 
        (yytype_int16 const   )59,      (yytype_int16 const   )31,      (yytype_int16 const   )61,      (yytype_int16 const   )-4, 
        (yytype_int16 const   )12,      (yytype_int16 const   )63,      (yytype_int16 const   )32,      (yytype_int16 const   )13, 
        (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )16,      (yytype_int16 const   )17, 
        (yytype_int16 const   )18,      (yytype_int16 const   )19,      (yytype_int16 const   )20,      (yytype_int16 const   )64, 
        (yytype_int16 const   )71,      (yytype_int16 const   )21,      (yytype_int16 const   )22,      (yytype_int16 const   )23, 
        (yytype_int16 const   )24,      (yytype_int16 const   )25,      (yytype_int16 const   )26,      (yytype_int16 const   )27, 
        (yytype_int16 const   )28,      (yytype_int16 const   )29,      (yytype_int16 const   )30,      (yytype_int16 const   )72, 
        (yytype_int16 const   )73,      (yytype_int16 const   )31,      (yytype_int16 const   )180,      (yytype_int16 const   )90, 
        (yytype_int16 const   )91,      (yytype_int16 const   )52,      (yytype_int16 const   )32,      (yytype_int16 const   )-85, 
        (yytype_int16 const   )97,      (yytype_int16 const   )82,      (yytype_int16 const   )83,      (yytype_int16 const   )-85, 
        (yytype_int16 const   )-85,      (yytype_int16 const   )-85,      (yytype_int16 const   )-85,      (yytype_int16 const   )-85, 
        (yytype_int16 const   )-85,      (yytype_int16 const   )-85,      (yytype_int16 const   )-85,      (yytype_int16 const   )84, 
        (yytype_int16 const   )190,      (yytype_int16 const   )-85,      (yytype_int16 const   )-85,      (yytype_int16 const   )99, 
        (yytype_int16 const   )-85,      (yytype_int16 const   )-85,      (yytype_int16 const   )-85,      (yytype_int16 const   )-85, 
        (yytype_int16 const   )-85,      (yytype_int16 const   )-85,      (yytype_int16 const   )-85,      (yytype_int16 const   )85, 
        (yytype_int16 const   )97,      (yytype_int16 const   )106,      (yytype_int16 const   )86,      (yytype_int16 const   )87, 
        (yytype_int16 const   )-52,      (yytype_int16 const   )-52,      (yytype_int16 const   )140,      (yytype_int16 const   )-52, 
        (yytype_int16 const   )-52,      (yytype_int16 const   )-52,      (yytype_int16 const   )-52,      (yytype_int16 const   )98, 
        (yytype_int16 const   )95,      (yytype_int16 const   )-52,      (yytype_int16 const   )-52,      (yytype_int16 const   )99, 
        (yytype_int16 const   )114,      (yytype_int16 const   )115,      (yytype_int16 const   )116,      (yytype_int16 const   )117, 
        (yytype_int16 const   )96,      (yytype_int16 const   )148,      (yytype_int16 const   )149,      (yytype_int16 const   )150, 
        (yytype_int16 const   )158,      (yytype_int16 const   )106,      (yytype_int16 const   )155,      (yytype_int16 const   )159, 
        (yytype_int16 const   )97,      (yytype_int16 const   )163,      (yytype_int16 const   )118,      (yytype_int16 const   )-76, 
        (yytype_int16 const   )-76,      (yytype_int16 const   )-76,      (yytype_int16 const   )-76,      (yytype_int16 const   )-76, 
        (yytype_int16 const   )-76,      (yytype_int16 const   )-76,      (yytype_int16 const   )-76,      (yytype_int16 const   )160, 
        (yytype_int16 const   )164,      (yytype_int16 const   )-76,      (yytype_int16 const   )-76,      (yytype_int16 const   )99, 
        (yytype_int16 const   )13,      (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )16, 
        (yytype_int16 const   )17,      (yytype_int16 const   )18,      (yytype_int16 const   )19,      (yytype_int16 const   )20, 
        (yytype_int16 const   )91,      (yytype_int16 const   )106,      (yytype_int16 const   )21,      (yytype_int16 const   )22, 
        (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )140,      (yytype_int16 const   )17, 
        (yytype_int16 const   )18,      (yytype_int16 const   )19,      (yytype_int16 const   )20,      (yytype_int16 const   )168, 
        (yytype_int16 const   )175,      (yytype_int16 const   )21,      (yytype_int16 const   )22,      (yytype_int16 const   )177, 
        (yytype_int16 const   )181,      (yytype_int16 const   )182,      (yytype_int16 const   )183,      (yytype_int16 const   )32, 
        (yytype_int16 const   )187,      (yytype_int16 const   )167,      (yytype_int16 const   )188,      (yytype_int16 const   )169, 
        (yytype_int16 const   )170,      (yytype_int16 const   )171,      (yytype_int16 const   )185,      (yytype_int16 const   )189, 
        (yytype_int16 const   )53,      (yytype_int16 const   )51,      (yytype_int16 const   )32,      (yytype_int16 const   )176, 
        (yytype_int16 const   )75,      (yytype_int16 const   )178,      (yytype_int16 const   )121,      (yytype_int16 const   )0, 
        (yytype_int16 const   )133,      (yytype_int16 const   )162,      (yytype_int16 const   )0,      (yytype_int16 const   )0, 
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )184};
#line 731 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/zconf.tab.c"
static yytype_int16 const   yycheck[291]  = 
#line 731
  {      (yytype_int16 const   )1,      (yytype_int16 const   )67,      (yytype_int16 const   )68,      (yytype_int16 const   )10, 
        (yytype_int16 const   )93,      (yytype_int16 const   )94,      (yytype_int16 const   )76,      (yytype_int16 const   )3, 
        (yytype_int16 const   )76,      (yytype_int16 const   )14,      (yytype_int16 const   )28,      (yytype_int16 const   )81, 
        (yytype_int16 const   )13,      (yytype_int16 const   )81,      (yytype_int16 const   )15,      (yytype_int16 const   )104, 
        (yytype_int16 const   )34,      (yytype_int16 const   )18,      (yytype_int16 const   )3,      (yytype_int16 const   )32, 
        (yytype_int16 const   )33,      (yytype_int16 const   )23,      (yytype_int16 const   )26,      (yytype_int16 const   )27, 
        (yytype_int16 const   )90,      (yytype_int16 const   )91,      (yytype_int16 const   )30,      (yytype_int16 const   )32, 
        (yytype_int16 const   )33,      (yytype_int16 const   )31,      (yytype_int16 const   )78,      (yytype_int16 const   )35, 
        (yytype_int16 const   )80,      (yytype_int16 const   )0,      (yytype_int16 const   )1,      (yytype_int16 const   )31, 
        (yytype_int16 const   )102,      (yytype_int16 const   )4,      (yytype_int16 const   )5,      (yytype_int16 const   )6, 
        (yytype_int16 const   )7,      (yytype_int16 const   )8,      (yytype_int16 const   )9,      (yytype_int16 const   )10, 
        (yytype_int16 const   )11,      (yytype_int16 const   )12,      (yytype_int16 const   )31,      (yytype_int16 const   )14, 
        (yytype_int16 const   )15,      (yytype_int16 const   )16,      (yytype_int16 const   )17,      (yytype_int16 const   )18, 
        (yytype_int16 const   )19,      (yytype_int16 const   )20,      (yytype_int16 const   )21,      (yytype_int16 const   )22, 
        (yytype_int16 const   )23,      (yytype_int16 const   )24,      (yytype_int16 const   )78,      (yytype_int16 const   )26, 
        (yytype_int16 const   )80,      (yytype_int16 const   )26,      (yytype_int16 const   )69,      (yytype_int16 const   )133, 
        (yytype_int16 const   )31,      (yytype_int16 const   )133,      (yytype_int16 const   )31,      (yytype_int16 const   )156, 
        (yytype_int16 const   )26,      (yytype_int16 const   )27,      (yytype_int16 const   )29,      (yytype_int16 const   )0, 
        (yytype_int16 const   )1,      (yytype_int16 const   )32,      (yytype_int16 const   )33,      (yytype_int16 const   )4, 
        (yytype_int16 const   )5,      (yytype_int16 const   )6,      (yytype_int16 const   )7,      (yytype_int16 const   )8, 
        (yytype_int16 const   )9,      (yytype_int16 const   )10,      (yytype_int16 const   )11,      (yytype_int16 const   )12, 
        (yytype_int16 const   )150,      (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )16, 
        (yytype_int16 const   )17,      (yytype_int16 const   )18,      (yytype_int16 const   )19,      (yytype_int16 const   )20, 
        (yytype_int16 const   )21,      (yytype_int16 const   )22,      (yytype_int16 const   )23,      (yytype_int16 const   )24, 
        (yytype_int16 const   )0,      (yytype_int16 const   )26,      (yytype_int16 const   )164,      (yytype_int16 const   )100, 
        (yytype_int16 const   )77,      (yytype_int16 const   )78,      (yytype_int16 const   )31,      (yytype_int16 const   )80, 
        (yytype_int16 const   )77,      (yytype_int16 const   )78,      (yytype_int16 const   )31,      (yytype_int16 const   )80, 
        (yytype_int16 const   )31,      (yytype_int16 const   )32,      (yytype_int16 const   )33,      (yytype_int16 const   )0, 
        (yytype_int16 const   )1,      (yytype_int16 const   )31,      (yytype_int16 const   )115,      (yytype_int16 const   )4, 
        (yytype_int16 const   )5,      (yytype_int16 const   )6,      (yytype_int16 const   )7,      (yytype_int16 const   )8, 
        (yytype_int16 const   )9,      (yytype_int16 const   )10,      (yytype_int16 const   )11,      (yytype_int16 const   )26, 
        (yytype_int16 const   )27,      (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )16, 
        (yytype_int16 const   )17,      (yytype_int16 const   )18,      (yytype_int16 const   )19,      (yytype_int16 const   )20, 
        (yytype_int16 const   )21,      (yytype_int16 const   )22,      (yytype_int16 const   )23,      (yytype_int16 const   )31, 
        (yytype_int16 const   )26,      (yytype_int16 const   )26,      (yytype_int16 const   )31,      (yytype_int16 const   )0, 
        (yytype_int16 const   )1,      (yytype_int16 const   )26,      (yytype_int16 const   )31,      (yytype_int16 const   )4, 
        (yytype_int16 const   )5,      (yytype_int16 const   )6,      (yytype_int16 const   )7,      (yytype_int16 const   )8, 
        (yytype_int16 const   )9,      (yytype_int16 const   )10,      (yytype_int16 const   )11,      (yytype_int16 const   )26, 
        (yytype_int16 const   )31,      (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )16, 
        (yytype_int16 const   )17,      (yytype_int16 const   )18,      (yytype_int16 const   )19,      (yytype_int16 const   )20, 
        (yytype_int16 const   )21,      (yytype_int16 const   )22,      (yytype_int16 const   )23,      (yytype_int16 const   )1, 
        (yytype_int16 const   )1,      (yytype_int16 const   )26,      (yytype_int16 const   )31,      (yytype_int16 const   )32, 
        (yytype_int16 const   )33,      (yytype_int16 const   )31,      (yytype_int16 const   )31,      (yytype_int16 const   )0, 
        (yytype_int16 const   )1,      (yytype_int16 const   )31,      (yytype_int16 const   )31,      (yytype_int16 const   )4, 
        (yytype_int16 const   )5,      (yytype_int16 const   )6,      (yytype_int16 const   )7,      (yytype_int16 const   )8, 
        (yytype_int16 const   )9,      (yytype_int16 const   )10,      (yytype_int16 const   )11,      (yytype_int16 const   )31, 
        (yytype_int16 const   )185,      (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )16, 
        (yytype_int16 const   )17,      (yytype_int16 const   )18,      (yytype_int16 const   )19,      (yytype_int16 const   )20, 
        (yytype_int16 const   )21,      (yytype_int16 const   )22,      (yytype_int16 const   )23,      (yytype_int16 const   )31, 
        (yytype_int16 const   )1,      (yytype_int16 const   )26,      (yytype_int16 const   )31,      (yytype_int16 const   )31, 
        (yytype_int16 const   )5,      (yytype_int16 const   )6,      (yytype_int16 const   )31,      (yytype_int16 const   )8, 
        (yytype_int16 const   )9,      (yytype_int16 const   )10,      (yytype_int16 const   )11,      (yytype_int16 const   )12, 
        (yytype_int16 const   )31,      (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )16, 
        (yytype_int16 const   )17,      (yytype_int16 const   )18,      (yytype_int16 const   )19,      (yytype_int16 const   )20, 
        (yytype_int16 const   )31,      (yytype_int16 const   )31,      (yytype_int16 const   )31,      (yytype_int16 const   )25, 
        (yytype_int16 const   )1,      (yytype_int16 const   )26,      (yytype_int16 const   )26,      (yytype_int16 const   )13, 
        (yytype_int16 const   )1,      (yytype_int16 const   )26,      (yytype_int16 const   )31,      (yytype_int16 const   )4, 
        (yytype_int16 const   )5,      (yytype_int16 const   )6,      (yytype_int16 const   )7,      (yytype_int16 const   )8, 
        (yytype_int16 const   )9,      (yytype_int16 const   )10,      (yytype_int16 const   )11,      (yytype_int16 const   )31, 
        (yytype_int16 const   )14,      (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )16, 
        (yytype_int16 const   )4,      (yytype_int16 const   )5,      (yytype_int16 const   )6,      (yytype_int16 const   )7, 
        (yytype_int16 const   )8,      (yytype_int16 const   )9,      (yytype_int16 const   )10,      (yytype_int16 const   )11, 
        (yytype_int16 const   )33,      (yytype_int16 const   )26,      (yytype_int16 const   )14,      (yytype_int16 const   )15, 
        (yytype_int16 const   )5,      (yytype_int16 const   )6,      (yytype_int16 const   )31,      (yytype_int16 const   )8, 
        (yytype_int16 const   )9,      (yytype_int16 const   )10,      (yytype_int16 const   )11,      (yytype_int16 const   )31, 
        (yytype_int16 const   )31,      (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )31, 
        (yytype_int16 const   )31,      (yytype_int16 const   )31,      (yytype_int16 const   )31,      (yytype_int16 const   )31, 
        (yytype_int16 const   )31,      (yytype_int16 const   )151,      (yytype_int16 const   )31,      (yytype_int16 const   )153, 
        (yytype_int16 const   )154,      (yytype_int16 const   )155,      (yytype_int16 const   )34,      (yytype_int16 const   )31, 
        (yytype_int16 const   )7,      (yytype_int16 const   )6,      (yytype_int16 const   )31,      (yytype_int16 const   )161, 
        (yytype_int16 const   )37,      (yytype_int16 const   )163,      (yytype_int16 const   )76,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )79,      (yytype_int16 const   )116,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )172};
#line 767 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/zconf.tab.c"
static yytype_uint8 const   yystos[191]  = 
#line 767
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )3,      (yytype_uint8 const   )31,      (yytype_uint8 const   )37, 
        (yytype_uint8 const   )38,      (yytype_uint8 const   )39,      (yytype_uint8 const   )63,      (yytype_uint8 const   )81, 
        (yytype_uint8 const   )26,      (yytype_uint8 const   )27,      (yytype_uint8 const   )79,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )4,      (yytype_uint8 const   )5,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )7,      (yytype_uint8 const   )8,      (yytype_uint8 const   )9,      (yytype_uint8 const   )10, 
        (yytype_uint8 const   )11,      (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )22,      (yytype_uint8 const   )23,      (yytype_uint8 const   )26, 
        (yytype_uint8 const   )31,      (yytype_uint8 const   )40,      (yytype_uint8 const   )41,      (yytype_uint8 const   )43, 
        (yytype_uint8 const   )44,      (yytype_uint8 const   )45,      (yytype_uint8 const   )46,      (yytype_uint8 const   )52, 
        (yytype_uint8 const   )53,      (yytype_uint8 const   )55,      (yytype_uint8 const   )59,      (yytype_uint8 const   )61, 
        (yytype_uint8 const   )64,      (yytype_uint8 const   )65,      (yytype_uint8 const   )67,      (yytype_uint8 const   )69, 
        (yytype_uint8 const   )70,      (yytype_uint8 const   )71,      (yytype_uint8 const   )80,      (yytype_uint8 const   )39, 
        (yytype_uint8 const   )31,      (yytype_uint8 const   )38,      (yytype_uint8 const   )81,      (yytype_uint8 const   )31, 
        (yytype_uint8 const   )79,      (yytype_uint8 const   )31,      (yytype_uint8 const   )79,      (yytype_uint8 const   )26, 
        (yytype_uint8 const   )85,      (yytype_uint8 const   )31,      (yytype_uint8 const   )79,      (yytype_uint8 const   )26, 
        (yytype_uint8 const   )26,      (yytype_uint8 const   )26,      (yytype_uint8 const   )27,      (yytype_uint8 const   )30, 
        (yytype_uint8 const   )35,      (yytype_uint8 const   )83,      (yytype_uint8 const   )84,      (yytype_uint8 const   )31, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )47,      (yytype_uint8 const   )47, 
        (yytype_uint8 const   )56,      (yytype_uint8 const   )58,      (yytype_uint8 const   )62,      (yytype_uint8 const   )76, 
        (yytype_uint8 const   )68,      (yytype_uint8 const   )74,      (yytype_uint8 const   )31,      (yytype_uint8 const   )31, 
        (yytype_uint8 const   )31,      (yytype_uint8 const   )31,      (yytype_uint8 const   )31,      (yytype_uint8 const   )31, 
        (yytype_uint8 const   )83,      (yytype_uint8 const   )83,      (yytype_uint8 const   )32,      (yytype_uint8 const   )33, 
        (yytype_uint8 const   )81,      (yytype_uint8 const   )28,      (yytype_uint8 const   )34,      (yytype_uint8 const   )31, 
        (yytype_uint8 const   )31,      (yytype_uint8 const   )1,      (yytype_uint8 const   )12,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20,      (yytype_uint8 const   )21, 
        (yytype_uint8 const   )22,      (yytype_uint8 const   )24,      (yytype_uint8 const   )26,      (yytype_uint8 const   )31, 
        (yytype_uint8 const   )42,      (yytype_uint8 const   )48,      (yytype_uint8 const   )49,      (yytype_uint8 const   )72, 
        (yytype_uint8 const   )73,      (yytype_uint8 const   )75,      (yytype_uint8 const   )17,      (yytype_uint8 const   )18, 
        (yytype_uint8 const   )19,      (yytype_uint8 const   )20,      (yytype_uint8 const   )31,      (yytype_uint8 const   )42, 
        (yytype_uint8 const   )57,      (yytype_uint8 const   )73,      (yytype_uint8 const   )75,      (yytype_uint8 const   )41, 
        (yytype_uint8 const   )54,      (yytype_uint8 const   )80,      (yytype_uint8 const   )41,      (yytype_uint8 const   )55, 
        (yytype_uint8 const   )60,      (yytype_uint8 const   )67,      (yytype_uint8 const   )80,      (yytype_uint8 const   )23, 
        (yytype_uint8 const   )31,      (yytype_uint8 const   )74,      (yytype_uint8 const   )77,      (yytype_uint8 const   )41, 
        (yytype_uint8 const   )55,      (yytype_uint8 const   )66,      (yytype_uint8 const   )67,      (yytype_uint8 const   )80, 
        (yytype_uint8 const   )31,      (yytype_uint8 const   )42,      (yytype_uint8 const   )75,      (yytype_uint8 const   )29, 
        (yytype_uint8 const   )83,      (yytype_uint8 const   )83,      (yytype_uint8 const   )84,      (yytype_uint8 const   )84, 
        (yytype_uint8 const   )31,      (yytype_uint8 const   )31,      (yytype_uint8 const   )25,      (yytype_uint8 const   )79, 
        (yytype_uint8 const   )78,      (yytype_uint8 const   )79,      (yytype_uint8 const   )83,      (yytype_uint8 const   )26, 
        (yytype_uint8 const   )84,      (yytype_uint8 const   )50,      (yytype_uint8 const   )1,      (yytype_uint8 const   )13, 
        (yytype_uint8 const   )31,      (yytype_uint8 const   )79,      (yytype_uint8 const   )78,      (yytype_uint8 const   )26, 
        (yytype_uint8 const   )14,      (yytype_uint8 const   )82,      (yytype_uint8 const   )83,      (yytype_uint8 const   )82, 
        (yytype_uint8 const   )31,      (yytype_uint8 const   )82,      (yytype_uint8 const   )82,      (yytype_uint8 const   )82, 
        (yytype_uint8 const   )84,      (yytype_uint8 const   )26,      (yytype_uint8 const   )31,      (yytype_uint8 const   )31, 
        (yytype_uint8 const   )82,      (yytype_uint8 const   )31,      (yytype_uint8 const   )82,      (yytype_uint8 const   )83, 
        (yytype_uint8 const   )31,      (yytype_uint8 const   )31,      (yytype_uint8 const   )31,      (yytype_uint8 const   )31, 
        (yytype_uint8 const   )82,      (yytype_uint8 const   )34,      (yytype_uint8 const   )51,      (yytype_uint8 const   )31, 
        (yytype_uint8 const   )31,      (yytype_uint8 const   )31,      (yytype_uint8 const   )79};
#line 923 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/zconf.tab.c"
static void yy_symbol_value_print(FILE *yyoutput , int yytype , YYSTYPE const   * const  yyvaluep ) 
{ 


  {
#line 933
  if (! yyvaluep) {
#line 934
    return;
  }
  {
#line 943
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 944
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 946
  return;
}
}
#line 955 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/zconf.tab.c"
static void yy_symbol_print(FILE *yyoutput , int yytype , YYSTYPE const   * const  yyvaluep ) 
{ 


  {
#line 965
  if (yytype < 36) {
    {
#line 966
    fprintf((FILE */* __restrict  */)yyoutput, (char const   */* __restrict  */)"token %s (",
            yytname[yytype]);
    }
  } else {
    {
#line 968
    fprintf((FILE */* __restrict  */)yyoutput, (char const   */* __restrict  */)"nterm %s (",
            yytname[yytype]);
    }
  }
  {
#line 970
  yy_symbol_value_print(yyoutput, yytype, yyvaluep);
#line 971
  fprintf((FILE */* __restrict  */)yyoutput, (char const   */* __restrict  */)")");
  }
#line 972
  return;
}
}
#line 981 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/zconf.tab.c"
static void yy_stack_print(yytype_int16 *yybottom , yytype_int16 *yytop ) 
{ 
  int yybot ;

  {
  {
#line 990
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Stack now");
  }
  {
#line 991
  while (1) {
    while_continue: /* CIL Label */ ;
#line 991
    if (! ((unsigned long )yybottom <= (unsigned long )yytop)) {
#line 991
      goto while_break;
    }
    {
#line 993
    yybot = (int )*yybottom;
#line 994
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %d",
            yybot);
#line 991
    yybottom ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 996
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 997
  return;
}
}
#line 1012 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/zconf.tab.c"
static void yy_reduce_print(YYSTYPE *yyvsp , int yyrule ) 
{ 
  int yynrhs ;
  int yyi ;
  unsigned long yylno ;

  {
  {
#line 1021
  yynrhs = (int )yyr2[yyrule];
#line 1023
  yylno = (unsigned long )yyrline[yyrule];
#line 1024
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Reducing stack by rule %d (line %lu):\n",
          yyrule - 1, yylno);
#line 1027
  yyi = 0;
  }
  {
#line 1027
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1027
    if (! (yyi < yynrhs)) {
#line 1027
      goto while_break;
    }
    {
#line 1029
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   $%d = ",
            yyi + 1);
#line 1030
    yy_symbol_print(stderr, (int )yyrhs[(int const   )yyprhs[yyrule] + (int const   )yyi],
                    (YYSTYPE const   */* const  */)(yyvsp + ((yyi + 1) - yynrhs)));
#line 1033
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 1027
    yyi ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1035
  return;
}
}
#line 1290 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/zconf.tab.c"
static void yydestruct(char const   *yymsg , int yytype , YYSTYPE *yyvaluep ) 
{ 


  {
#line 1302
  if (! yymsg) {
#line 1303
    yymsg = "Deleting";
  }
  {
#line 1304
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1304
    if (zconfdebug) {
      {
#line 1304
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
              yymsg);
#line 1304
      yy_symbol_print(stderr, yytype, (YYSTYPE const   */* const  */)yyvaluep);
#line 1304
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
#line 1304
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1308
  if (yytype == 53) {
#line 1308
    goto case_53;
  }
#line 1318
  if (yytype == 59) {
#line 1318
    goto case_59;
  }
#line 1328
  if (yytype == 65) {
#line 1328
    goto case_65;
  }
#line 1339
  goto switch_default;
  case_53: /* CIL Label */ 
  {
#line 1311
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: missing end statement for this entry\n",
          ((yyvaluep->menu)->file)->name, (yyvaluep->menu)->lineno);
  }
#line 1313
  if ((unsigned long )current_menu == (unsigned long )yyvaluep->menu) {
    {
#line 1314
    menu_end_menu();
    }
  }
#line 1317
  goto switch_break;
  case_59: /* CIL Label */ 
  {
#line 1321
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: missing end statement for this entry\n",
          ((yyvaluep->menu)->file)->name, (yyvaluep->menu)->lineno);
  }
#line 1323
  if ((unsigned long )current_menu == (unsigned long )yyvaluep->menu) {
    {
#line 1324
    menu_end_menu();
    }
  }
#line 1327
  goto switch_break;
  case_65: /* CIL Label */ 
  {
#line 1331
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: missing end statement for this entry\n",
          ((yyvaluep->menu)->file)->name, (yyvaluep->menu)->lineno);
  }
#line 1333
  if ((unsigned long )current_menu == (unsigned long )yyvaluep->menu) {
    {
#line 1334
    menu_end_menu();
    }
  }
#line 1337
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1340
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1342
  return;
}
}
#line 1361 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/zconf.tab.c"
int zconfchar  ;
#line 1364 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/zconf.tab.c"
YYSTYPE zconflval  ;
#line 1367 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/zconf.tab.c"
int zconfnerrs  ;
#line 1388 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/zconf.tab.c"
int zconfparse(void) 
{ 
  int yystate ;
  int yyerrstatus ;
  yytype_int16 yyssa[200] ;
  yytype_int16 *yyss ;
  yytype_int16 *yyssp ;
  YYSTYPE yyvsa[200] ;
  YYSTYPE *yyvs ;
  YYSTYPE *yyvsp ;
  unsigned long yystacksize ;
  int yyn ;
  int yyresult ;
  int yytoken ;
  YYSTYPE yyval ;
  int yylen ;
  unsigned long yysize ;
  yytype_int16 *yyss1 ;
  union yyalloc *yyptr ;
  void *tmp ;
  unsigned long yynewbytes ;
  unsigned long yynewbytes___0 ;
  struct symbol *sym ;
  struct symbol *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  struct symbol *sym___0 ;
  struct symbol *tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  int tmp___10 ;
  char const   *tmp___11 ;
  int tmp___12 ;
  char const   *tmp___13 ;
  int tmp___14 ;
  char const   *tmp___15 ;
  struct symbol *tmp___16 ;
  int tmp___17 ;
  char const   *tmp___18 ;
  struct expr *tmp___19 ;
  int tmp___20 ;
  char const   *tmp___21 ;
  struct kconf_id  const  *id ;
  size_t tmp___22 ;
  struct kconf_id  const __attribute__((__gnu_inline__)) *tmp___23 ;
  struct symbol *sym___1 ;
  struct symbol *tmp___24 ;
  int tmp___25 ;
  char const   *tmp___26 ;
  int tmp___27 ;
  char const   *tmp___28 ;
  _Bool tmp___29 ;
  int tmp___30 ;
  char const   *tmp___31 ;
  int tmp___32 ;
  char const   *tmp___33 ;
  int tmp___34 ;
  char const   *tmp___35 ;
  struct symbol *tmp___36 ;
  int tmp___37 ;
  char const   *tmp___38 ;
  int tmp___39 ;
  char const   *tmp___40 ;
  int tmp___41 ;
  char const   *tmp___42 ;
  _Bool tmp___43 ;
  int tmp___44 ;
  char const   *tmp___45 ;
  int tmp___46 ;
  char const   *tmp___47 ;
  _Bool tmp___48 ;
  int tmp___49 ;
  char const   *tmp___50 ;
  int tmp___51 ;
  char const   *tmp___52 ;
  int tmp___53 ;
  char const   *tmp___54 ;
  int tmp___55 ;
  char const   *tmp___56 ;

  {
#line 1441
  yylen = 0;
#line 1443
  yytoken = 0;
#line 1444
  yyss = yyssa;
#line 1445
  yyvs = yyvsa;
#line 1446
  yystacksize = 200UL;
  {
#line 1448
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1448
    if (zconfdebug) {
      {
#line 1448
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Starting parse\n");
      }
    }
#line 1448
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1450
  yystate = 0;
#line 1451
  yyerrstatus = 0;
#line 1452
  zconfnerrs = 0;
#line 1453
  zconfchar = -2;
#line 1459
  yyssp = yyss;
#line 1460
  yyvsp = yyvs;
#line 1462
  goto yysetstate;
  yynewstate: 
#line 1470
  yyssp ++;
  yysetstate: 
#line 1473
  *yyssp = (yytype_int16 )yystate;
#line 1475
  if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1478
    yysize = (unsigned long )((yyssp - yyss) + 1L);
#line 1505
    if (10000UL <= yystacksize) {
#line 1506
      goto yyexhaustedlab;
    }
#line 1507
    yystacksize *= 2UL;
#line 1508
    if (10000UL < yystacksize) {
#line 1509
      yystacksize = 10000UL;
    }
    {
#line 1512
    yyss1 = yyss;
#line 1513
    tmp = malloc(yystacksize * (sizeof(yytype_int16 ) + sizeof(YYSTYPE )) + (sizeof(union yyalloc ) - 1UL));
#line 1513
    yyptr = (union yyalloc *)tmp;
    }
#line 1515
    if (! yyptr) {
#line 1516
      goto yyexhaustedlab;
    }
    {
#line 1517
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1517
      __builtin_memcpy((void *)(& yyptr->yyss_alloc), (void const   *)yyss, yysize * sizeof(*yyss));
#line 1517
      yyss = & yyptr->yyss_alloc;
#line 1517
      yynewbytes = yystacksize * sizeof(*yyss) + (sizeof(union yyalloc ) - 1UL);
#line 1517
      yyptr += yynewbytes / sizeof(*yyptr);
      }
#line 1517
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1518
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1518
      __builtin_memcpy((void *)(& yyptr->yyvs_alloc), (void const   *)yyvs, yysize * sizeof(*yyvs));
#line 1518
      yyvs = & yyptr->yyvs_alloc;
#line 1518
      yynewbytes___0 = yystacksize * sizeof(*yyvs) + (sizeof(union yyalloc ) - 1UL);
#line 1518
      yyptr += yynewbytes___0 / sizeof(*yyptr);
      }
#line 1518
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1520
    if ((unsigned long )yyss1 != (unsigned long )(yyssa)) {
      {
#line 1521
      free((void *)yyss1);
      }
    }
#line 1526
    yyssp = (yyss + yysize) - 1;
#line 1527
    yyvsp = (yyvs + yysize) - 1;
    {
#line 1529
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1529
      if (zconfdebug) {
        {
#line 1529
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Stack size increased to %lu\n",
                yystacksize);
        }
      }
#line 1529
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1532
    if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1533
      goto yyabortlab;
    }
  }
  {
#line 1536
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1536
    if (zconfdebug) {
      {
#line 1536
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Entering state %d\n",
              yystate);
      }
    }
#line 1536
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1538
  if (yystate == 11) {
#line 1539
    goto yyacceptlab;
  }
#line 1541
  goto yybackup;
  yybackup: 
#line 1552
  yyn = (int )yypact[yystate];
#line 1553
  if (yyn == -90) {
#line 1554
    goto yydefault;
  }
#line 1559
  if (zconfchar == -2) {
    {
#line 1561
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1561
      if (zconfdebug) {
        {
#line 1561
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Reading a token: ");
        }
      }
#line 1561
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 1562
    zconfchar = zconflex();
    }
  }
#line 1565
  if (zconfchar <= 0) {
#line 1567
    yytoken = 0;
#line 1567
    zconfchar = yytoken;
    {
#line 1568
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1568
      if (zconfdebug) {
        {
#line 1568
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Now at end of input.\n");
        }
      }
#line 1568
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
  } else {
#line 1572
    if ((unsigned int )zconfchar <= 290U) {
#line 1572
      yytoken = (int )yytranslate[zconfchar];
    } else {
#line 1572
      yytoken = 2;
    }
    {
#line 1573
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 1573
      if (zconfdebug) {
        {
#line 1573
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
                "Next token is");
#line 1573
        yy_symbol_print(stderr, yytoken, (YYSTYPE const   */* const  */)(& zconflval));
#line 1573
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
        }
      }
#line 1573
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
  }
#line 1578
  yyn += yytoken;
#line 1579
  if (yyn < 0) {
#line 1580
    goto yydefault;
  } else
#line 1579
  if (290 < yyn) {
#line 1580
    goto yydefault;
  } else
#line 1579
  if ((int const   )yycheck[yyn] != (int const   )yytoken) {
#line 1580
    goto yydefault;
  }
#line 1581
  yyn = (int )yytable[yyn];
#line 1582
  if (yyn <= 0) {
#line 1584
    if (yyn == 0) {
#line 1585
      goto yyerrlab;
    } else
#line 1584
    if (yyn == -86) {
#line 1585
      goto yyerrlab;
    }
#line 1586
    yyn = - yyn;
#line 1587
    goto yyreduce;
  }
#line 1592
  if (yyerrstatus) {
#line 1593
    yyerrstatus --;
  }
  {
#line 1596
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 1596
    if (zconfdebug) {
      {
#line 1596
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
              "Shifting");
#line 1596
      yy_symbol_print(stderr, yytoken, (YYSTYPE const   */* const  */)(& zconflval));
#line 1596
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
#line 1596
    goto while_break___7;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 1599
  zconfchar = -2;
#line 1601
  yystate = yyn;
#line 1602
  yyvsp ++;
#line 1602
  *yyvsp = zconflval;
#line 1604
  goto yynewstate;
  yydefault: 
#line 1611
  yyn = (int )yydefact[yystate];
#line 1612
  if (yyn == 0) {
#line 1613
    goto yyerrlab;
  }
#line 1614
  goto yyreduce;
  yyreduce: 
#line 1622
  yylen = (int )yyr2[yyn];
#line 1632
  yyval = *(yyvsp + (1 - yylen));
  {
#line 1635
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 1635
    if (zconfdebug) {
      {
#line 1635
      yy_reduce_print(yyvsp, yyn);
      }
    }
#line 1635
    goto while_break___8;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 1638
  if (yyn == 10) {
#line 1638
    goto case_10;
  }
#line 1643
  if (yyn == 11) {
#line 1643
    goto case_11;
  }
#line 1648
  if (yyn == 12) {
#line 1648
    goto case_12;
  }
#line 1655
  if (yyn == 13) {
#line 1655
    goto case_13;
  }
#line 1660
  if (yyn == 28) {
#line 1660
    goto case_28;
  }
#line 1665
  if (yyn == 29) {
#line 1665
    goto case_29;
  }
#line 1670
  if (yyn == 30) {
#line 1670
    goto case_30;
  }
#line 1680
  if (yyn == 31) {
#line 1680
    goto case_31;
  }
#line 1688
  if (yyn == 32) {
#line 1688
    goto case_32;
  }
#line 1698
  if (yyn == 33) {
#line 1698
    goto case_33;
  }
#line 1710
  if (yyn == 41) {
#line 1710
    goto case_41;
  }
#line 1720
  if (yyn == 42) {
#line 1720
    goto case_42;
  }
#line 1728
  if (yyn == 43) {
#line 1728
    goto case_43;
  }
#line 1740
  if (yyn == 44) {
#line 1740
    goto case_44;
  }
#line 1748
  if (yyn == 45) {
#line 1748
    goto case_45;
  }
#line 1756
  if (yyn == 48) {
#line 1756
    goto case_48;
  }
#line 1768
  if (yyn == 49) {
#line 1768
    goto case_49;
  }
#line 1773
  if (yyn == 50) {
#line 1773
    goto case_50;
  }
#line 1778
  if (yyn == 51) {
#line 1778
    goto case_51;
  }
#line 1789
  if (yyn == 52) {
#line 1789
    goto case_52;
  }
#line 1796
  if (yyn == 53) {
#line 1796
    goto case_53;
  }
#line 1806
  if (yyn == 61) {
#line 1806
    goto case_61;
  }
#line 1814
  if (yyn == 62) {
#line 1814
    goto case_62;
  }
#line 1827
  if (yyn == 63) {
#line 1827
    goto case_63;
  }
#line 1835
  if (yyn == 64) {
#line 1835
    goto case_64;
  }
#line 1847
  if (yyn == 67) {
#line 1847
    goto case_67;
  }
#line 1857
  if (yyn == 68) {
#line 1857
    goto case_68;
  }
#line 1867
  if (yyn == 74) {
#line 1867
    goto case_74;
  }
#line 1874
  if (yyn == 75) {
#line 1874
    goto case_75;
  }
#line 1883
  if (yyn == 76) {
#line 1883
    goto case_76;
  }
#line 1890
  if (yyn == 77) {
#line 1890
    goto case_77;
  }
#line 1900
  if (yyn == 83) {
#line 1900
    goto case_83;
  }
#line 1908
  if (yyn == 84) {
#line 1908
    goto case_84;
  }
#line 1917
  if (yyn == 85) {
#line 1917
    goto case_85;
  }
#line 1924
  if (yyn == 86) {
#line 1924
    goto case_86;
  }
#line 1932
  if (yyn == 87) {
#line 1932
    goto case_87;
  }
#line 1939
  if (yyn == 92) {
#line 1939
    goto case_92;
  }
#line 1947
  if (yyn == 96) {
#line 1947
    goto case_96;
  }
#line 1954
  if (yyn == 98) {
#line 1954
    goto case_98;
  }
#line 1961
  if (yyn == 101) {
#line 1961
    goto case_101;
  }
#line 1966
  if (yyn == 102) {
#line 1966
    goto case_102;
  }
#line 1971
  if (yyn == 103) {
#line 1971
    goto case_103;
  }
#line 1976
  if (yyn == 106) {
#line 1976
    goto case_106;
  }
#line 1981
  if (yyn == 107) {
#line 1981
    goto case_107;
  }
#line 1986
  if (yyn == 108) {
#line 1986
    goto case_108;
  }
#line 1991
  if (yyn == 109) {
#line 1991
    goto case_109;
  }
#line 1996
  if (yyn == 110) {
#line 1996
    goto case_110;
  }
#line 2001
  if (yyn == 111) {
#line 2001
    goto case_111;
  }
#line 2006
  if (yyn == 112) {
#line 2006
    goto case_112;
  }
#line 2011
  if (yyn == 113) {
#line 2011
    goto case_113;
  }
#line 2016
  if (yyn == 114) {
#line 2016
    goto case_114;
  }
#line 2021
  if (yyn == 115) {
#line 2021
    goto case_115;
  }
#line 2026
  if (yyn == 116) {
#line 2026
    goto case_116;
  }
#line 2031
  if (yyn == 117) {
#line 2031
    goto case_117;
  }
#line 2038
  goto switch_default;
  case_10: /* CIL Label */ 
  {
#line 1640
  zconf_error("unexpected end statement");
  }
#line 1641
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 1645
  zconf_error("unknown statement \"%s\"", (yyvsp + -2)->string);
  }
#line 1646
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 1651
  zconf_error("unexpected option \"%s\"", (char const   *)(& kconf_id_strings_contents) + ((yyvsp + -2)->id)->name);
  }
#line 1653
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 1657
  zconf_error("invalid statement");
  }
#line 1658
  goto switch_break;
  case_28: /* CIL Label */ 
  {
#line 1662
  zconf_error("unknown option \"%s\"", (yyvsp + -2)->string);
  }
#line 1663
  goto switch_break;
  case_29: /* CIL Label */ 
  {
#line 1667
  zconf_error("invalid option");
  }
#line 1668
  goto switch_break;
  case_30: /* CIL Label */ 
  {
#line 1673
  tmp___0 = sym_lookup((char const   *)(yyvsp + -1)->string, 0);
#line 1673
  sym = tmp___0;
#line 1674
  sym->flags |= 256;
#line 1675
  menu_add_entry(sym);
  }
#line 1676
  if (cdebug & 2) {
    {
#line 1676
    tmp___1 = zconf_lineno();
#line 1676
    tmp___2 = zconf_curname();
#line 1676
    printf((char const   */* __restrict  */)"%s:%d:config %s\n", tmp___2, tmp___1,
           (yyvsp + -1)->string);
    }
  }
#line 1678
  goto switch_break;
  case_31: /* CIL Label */ 
  {
#line 1683
  menu_end_entry();
  }
#line 1684
  if (cdebug & 2) {
    {
#line 1684
    tmp___3 = zconf_lineno();
#line 1684
    tmp___4 = zconf_curname();
#line 1684
    printf((char const   */* __restrict  */)"%s:%d:endconfig\n", tmp___4, tmp___3);
    }
  }
#line 1686
  goto switch_break;
  case_32: /* CIL Label */ 
  {
#line 1691
  tmp___5 = sym_lookup((char const   *)(yyvsp + -1)->string, 0);
#line 1691
  sym___0 = tmp___5;
#line 1692
  sym___0->flags |= 256;
#line 1693
  menu_add_entry(sym___0);
  }
#line 1694
  if (cdebug & 2) {
    {
#line 1694
    tmp___6 = zconf_lineno();
#line 1694
    tmp___7 = zconf_curname();
#line 1694
    printf((char const   */* __restrict  */)"%s:%d:menuconfig %s\n", tmp___7, tmp___6,
           (yyvsp + -1)->string);
    }
  }
#line 1696
  goto switch_break;
  case_33: /* CIL Label */ 
#line 1701
  if (current_entry->prompt) {
#line 1702
    (current_entry->prompt)->type = (enum prop_type )3;
  } else {
    {
#line 1704
    zconfprint("warning: menuconfig statement without prompt");
    }
  }
  {
#line 1705
  menu_end_entry();
  }
#line 1706
  if (cdebug & 2) {
    {
#line 1706
    tmp___8 = zconf_lineno();
#line 1706
    tmp___9 = zconf_curname();
#line 1706
    printf((char const   */* __restrict  */)"%s:%d:endconfig\n", tmp___9, tmp___8);
    }
  }
#line 1708
  goto switch_break;
  case_41: /* CIL Label */ 
  {
#line 1713
  menu_set_type((int )((yyvsp + -2)->id)->stype);
  }
#line 1714
  if (cdebug & 2) {
    {
#line 1714
    tmp___10 = zconf_lineno();
#line 1714
    tmp___11 = zconf_curname();
#line 1714
    printf((char const   */* __restrict  */)"%s:%d:type(%u)\n", tmp___11, tmp___10,
           (unsigned int const   )((yyvsp + -2)->id)->stype);
    }
  }
#line 1718
  goto switch_break;
  case_42: /* CIL Label */ 
  {
#line 1723
  menu_add_prompt((enum prop_type )1, (yyvsp + -2)->string, (yyvsp + -1)->expr);
  }
#line 1724
  if (cdebug & 2) {
    {
#line 1724
    tmp___12 = zconf_lineno();
#line 1724
    tmp___13 = zconf_curname();
#line 1724
    printf((char const   */* __restrict  */)"%s:%d:prompt\n", tmp___13, tmp___12);
    }
  }
#line 1726
  goto switch_break;
  case_43: /* CIL Label */ 
  {
#line 1731
  menu_add_expr((enum prop_type )4, (yyvsp + -2)->expr, (yyvsp + -1)->expr);
  }
#line 1732
  if ((unsigned int const   )((yyvsp + -3)->id)->stype != 0U) {
    {
#line 1733
    menu_set_type((int )((yyvsp + -3)->id)->stype);
    }
  }
#line 1734
  if (cdebug & 2) {
    {
#line 1734
    tmp___14 = zconf_lineno();
#line 1734
    tmp___15 = zconf_curname();
#line 1734
    printf((char const   */* __restrict  */)"%s:%d:default(%u)\n", tmp___15, tmp___14,
           (unsigned int const   )((yyvsp + -3)->id)->stype);
    }
  }
#line 1738
  goto switch_break;
  case_44: /* CIL Label */ 
  {
#line 1743
  tmp___16 = sym_lookup((char const   *)(yyvsp + -2)->string, 0);
#line 1743
  menu_add_symbol((enum prop_type )6, tmp___16, (yyvsp + -1)->expr);
  }
#line 1744
  if (cdebug & 2) {
    {
#line 1744
    tmp___17 = zconf_lineno();
#line 1744
    tmp___18 = zconf_curname();
#line 1744
    printf((char const   */* __restrict  */)"%s:%d:select\n", tmp___18, tmp___17);
    }
  }
#line 1746
  goto switch_break;
  case_45: /* CIL Label */ 
  {
#line 1751
  tmp___19 = expr_alloc_comp((enum expr_type )8, (yyvsp + -3)->symbol, (yyvsp + -2)->symbol);
#line 1751
  menu_add_expr((enum prop_type )7, tmp___19, (yyvsp + -1)->expr);
  }
#line 1752
  if (cdebug & 2) {
    {
#line 1752
    tmp___20 = zconf_lineno();
#line 1752
    tmp___21 = zconf_curname();
#line 1752
    printf((char const   */* __restrict  */)"%s:%d:range\n", tmp___21, tmp___20);
    }
  }
#line 1754
  goto switch_break;
  case_48: /* CIL Label */ 
  {
#line 1759
  tmp___22 = strlen((char const   *)(yyvsp + -1)->string);
#line 1759
  tmp___23 = kconf_id_lookup((char const   *)(yyvsp + -1)->string, (unsigned int )tmp___22);
#line 1759
  id = (struct kconf_id  const  *)tmp___23;
  }
#line 1760
  if (id) {
#line 1760
    if (id->flags & 4U) {
      {
#line 1761
      menu_add_option((int )id->token, (yyvsp + 0)->string);
      }
    } else {
      {
#line 1763
      zconfprint("warning: ignoring unknown option %s", (yyvsp + -1)->string);
      }
    }
  } else {
    {
#line 1763
    zconfprint("warning: ignoring unknown option %s", (yyvsp + -1)->string);
    }
  }
  {
#line 1764
  free((void *)(yyvsp + -1)->string);
  }
#line 1766
  goto switch_break;
  case_49: /* CIL Label */ 
#line 1770
  yyval.string = (char *)((void *)0);
#line 1771
  goto switch_break;
  case_50: /* CIL Label */ 
#line 1775
  yyval.string = (yyvsp + 0)->string;
#line 1776
  goto switch_break;
  case_51: /* CIL Label */ 
  {
#line 1781
  tmp___24 = sym_lookup((char const   *)(yyvsp + -1)->string, 16);
#line 1781
  sym___1 = tmp___24;
#line 1782
  sym___1->flags |= 4096;
#line 1783
  menu_add_entry(sym___1);
#line 1784
  menu_add_expr((enum prop_type )5, (struct expr *)((void *)0), (struct expr *)((void *)0));
  }
#line 1785
  if (cdebug & 2) {
    {
#line 1785
    tmp___25 = zconf_lineno();
#line 1785
    tmp___26 = zconf_curname();
#line 1785
    printf((char const   */* __restrict  */)"%s:%d:choice\n", tmp___26, tmp___25);
    }
  }
#line 1787
  goto switch_break;
  case_52: /* CIL Label */ 
  {
#line 1792
  yyval.menu = menu_add_menu();
  }
#line 1794
  goto switch_break;
  case_53: /* CIL Label */ 
  {
#line 1799
  tmp___29 = zconf_endtoken((yyvsp + 0)->id, 262, 263);
  }
#line 1799
  if (tmp___29) {
    {
#line 1800
    menu_end_menu();
    }
#line 1801
    if (cdebug & 2) {
      {
#line 1801
      tmp___27 = zconf_lineno();
#line 1801
      tmp___28 = zconf_curname();
#line 1801
      printf((char const   */* __restrict  */)"%s:%d:endchoice\n", tmp___28, tmp___27);
      }
    }
  }
#line 1804
  goto switch_break;
  case_61: /* CIL Label */ 
  {
#line 1809
  menu_add_prompt((enum prop_type )1, (yyvsp + -2)->string, (yyvsp + -1)->expr);
  }
#line 1810
  if (cdebug & 2) {
    {
#line 1810
    tmp___30 = zconf_lineno();
#line 1810
    tmp___31 = zconf_curname();
#line 1810
    printf((char const   */* __restrict  */)"%s:%d:prompt\n", tmp___31, tmp___30);
    }
  }
#line 1812
  goto switch_break;
  case_62: /* CIL Label */ 
#line 1817
  if ((unsigned int const   )((yyvsp + -2)->id)->stype == 1U) {
#line 1817
    goto _L;
  } else
#line 1817
  if ((unsigned int const   )((yyvsp + -2)->id)->stype == 2U) {
    _L: /* CIL Label */ 
    {
#line 1818
    menu_set_type((int )((yyvsp + -2)->id)->stype);
    }
#line 1819
    if (cdebug & 2) {
      {
#line 1819
      tmp___32 = zconf_lineno();
#line 1819
      tmp___33 = zconf_curname();
#line 1819
      printf((char const   */* __restrict  */)"%s:%d:type(%u)\n", tmp___33, tmp___32,
             (unsigned int const   )((yyvsp + -2)->id)->stype);
      }
    }
  } else {
#line 1823
    goto yyerrorlab;
  }
#line 1825
  goto switch_break;
  case_63: /* CIL Label */ 
#line 1830
  (current_entry->sym)->flags |= 256;
#line 1831
  if (cdebug & 2) {
    {
#line 1831
    tmp___34 = zconf_lineno();
#line 1831
    tmp___35 = zconf_curname();
#line 1831
    printf((char const   */* __restrict  */)"%s:%d:optional\n", tmp___35, tmp___34);
    }
  }
#line 1833
  goto switch_break;
  case_64: /* CIL Label */ 
#line 1838
  if ((unsigned int const   )((yyvsp + -3)->id)->stype == 0U) {
    {
#line 1839
    tmp___36 = sym_lookup((char const   *)(yyvsp + -2)->string, 0);
#line 1839
    menu_add_symbol((enum prop_type )4, tmp___36, (yyvsp + -1)->expr);
    }
#line 1840
    if (cdebug & 2) {
      {
#line 1840
      tmp___37 = zconf_lineno();
#line 1840
      tmp___38 = zconf_curname();
#line 1840
      printf((char const   */* __restrict  */)"%s:%d:default\n", tmp___38, tmp___37);
      }
    }
  } else {
#line 1843
    goto yyerrorlab;
  }
#line 1845
  goto switch_break;
  case_67: /* CIL Label */ 
#line 1850
  if (cdebug & 2) {
    {
#line 1850
    tmp___39 = zconf_lineno();
#line 1850
    tmp___40 = zconf_curname();
#line 1850
    printf((char const   */* __restrict  */)"%s:%d:if\n", tmp___40, tmp___39);
    }
  }
  {
#line 1851
  menu_add_entry((struct symbol *)((void *)0));
#line 1852
  menu_add_dep((yyvsp + -1)->expr);
#line 1853
  yyval.menu = menu_add_menu();
  }
#line 1855
  goto switch_break;
  case_68: /* CIL Label */ 
  {
#line 1860
  tmp___43 = zconf_endtoken((yyvsp + 0)->id, 269, 270);
  }
#line 1860
  if (tmp___43) {
    {
#line 1861
    menu_end_menu();
    }
#line 1862
    if (cdebug & 2) {
      {
#line 1862
      tmp___41 = zconf_lineno();
#line 1862
      tmp___42 = zconf_curname();
#line 1862
      printf((char const   */* __restrict  */)"%s:%d:endif\n", tmp___42, tmp___41);
      }
    }
  }
#line 1865
  goto switch_break;
  case_74: /* CIL Label */ 
  {
#line 1870
  menu_add_prompt((enum prop_type )3, (yyvsp + -1)->string, (struct expr *)((void *)0));
  }
#line 1872
  goto switch_break;
  case_75: /* CIL Label */ 
  {
#line 1877
  menu_add_entry((struct symbol *)((void *)0));
#line 1878
  menu_add_prompt((enum prop_type )3, (yyvsp + -1)->string, (struct expr *)((void *)0));
  }
#line 1879
  if (cdebug & 2) {
    {
#line 1879
    tmp___44 = zconf_lineno();
#line 1879
    tmp___45 = zconf_curname();
#line 1879
    printf((char const   */* __restrict  */)"%s:%d:menu\n", tmp___45, tmp___44);
    }
  }
#line 1881
  goto switch_break;
  case_76: /* CIL Label */ 
  {
#line 1886
  yyval.menu = menu_add_menu();
  }
#line 1888
  goto switch_break;
  case_77: /* CIL Label */ 
  {
#line 1893
  tmp___48 = zconf_endtoken((yyvsp + 0)->id, 259, 260);
  }
#line 1893
  if (tmp___48) {
    {
#line 1894
    menu_end_menu();
    }
#line 1895
    if (cdebug & 2) {
      {
#line 1895
      tmp___46 = zconf_lineno();
#line 1895
      tmp___47 = zconf_curname();
#line 1895
      printf((char const   */* __restrict  */)"%s:%d:endmenu\n", tmp___47, tmp___46);
      }
    }
  }
#line 1898
  goto switch_break;
  case_83: /* CIL Label */ 
#line 1903
  if (cdebug & 2) {
    {
#line 1903
    tmp___49 = zconf_lineno();
#line 1903
    tmp___50 = zconf_curname();
#line 1903
    printf((char const   */* __restrict  */)"%s:%d:source %s\n", tmp___50, tmp___49,
           (yyvsp + -1)->string);
    }
  }
  {
#line 1904
  zconf_nextfile((char const   *)(yyvsp + -1)->string);
  }
#line 1906
  goto switch_break;
  case_84: /* CIL Label */ 
  {
#line 1911
  menu_add_entry((struct symbol *)((void *)0));
#line 1912
  menu_add_prompt((enum prop_type )2, (yyvsp + -1)->string, (struct expr *)((void *)0));
  }
#line 1913
  if (cdebug & 2) {
    {
#line 1913
    tmp___51 = zconf_lineno();
#line 1913
    tmp___52 = zconf_curname();
#line 1913
    printf((char const   */* __restrict  */)"%s:%d:comment\n", tmp___52, tmp___51);
    }
  }
#line 1915
  goto switch_break;
  case_85: /* CIL Label */ 
  {
#line 1920
  menu_end_entry();
  }
#line 1922
  goto switch_break;
  case_86: /* CIL Label */ 
#line 1927
  if (cdebug & 2) {
    {
#line 1927
    tmp___53 = zconf_lineno();
#line 1927
    tmp___54 = zconf_curname();
#line 1927
    printf((char const   */* __restrict  */)"%s:%d:help\n", tmp___54, tmp___53);
    }
  }
  {
#line 1928
  zconf_starthelp();
  }
#line 1930
  goto switch_break;
  case_87: /* CIL Label */ 
#line 1935
  current_entry->help = (yyvsp + 0)->string;
#line 1937
  goto switch_break;
  case_92: /* CIL Label */ 
  {
#line 1942
  menu_add_dep((yyvsp + -1)->expr);
  }
#line 1943
  if (cdebug & 2) {
    {
#line 1943
    tmp___55 = zconf_lineno();
#line 1943
    tmp___56 = zconf_curname();
#line 1943
    printf((char const   */* __restrict  */)"%s:%d:depends on\n", tmp___56, tmp___55);
    }
  }
#line 1945
  goto switch_break;
  case_96: /* CIL Label */ 
  {
#line 1950
  menu_add_visibility((yyvsp + 0)->expr);
  }
#line 1952
  goto switch_break;
  case_98: /* CIL Label */ 
  {
#line 1957
  menu_add_prompt((enum prop_type )1, (yyvsp + -1)->string, (yyvsp + 0)->expr);
  }
#line 1959
  goto switch_break;
  case_101: /* CIL Label */ 
#line 1963
  yyval.id = (yyvsp + -1)->id;
#line 1964
  goto switch_break;
  case_102: /* CIL Label */ 
#line 1968
  yyval.id = (yyvsp + -1)->id;
#line 1969
  goto switch_break;
  case_103: /* CIL Label */ 
#line 1973
  yyval.id = (yyvsp + -1)->id;
#line 1974
  goto switch_break;
  case_106: /* CIL Label */ 
#line 1978
  yyval.expr = (struct expr *)((void *)0);
#line 1979
  goto switch_break;
  case_107: /* CIL Label */ 
#line 1983
  yyval.expr = (yyvsp + 0)->expr;
#line 1984
  goto switch_break;
  case_108: /* CIL Label */ 
  {
#line 1988
  yyval.expr = expr_alloc_symbol((yyvsp + 0)->symbol);
  }
#line 1989
  goto switch_break;
  case_109: /* CIL Label */ 
  {
#line 1993
  yyval.expr = expr_alloc_comp((enum expr_type )4, (yyvsp + -2)->symbol, (yyvsp + 0)->symbol);
  }
#line 1994
  goto switch_break;
  case_110: /* CIL Label */ 
  {
#line 1998
  yyval.expr = expr_alloc_comp((enum expr_type )5, (yyvsp + -2)->symbol, (yyvsp + 0)->symbol);
  }
#line 1999
  goto switch_break;
  case_111: /* CIL Label */ 
#line 2003
  yyval.expr = (yyvsp + -1)->expr;
#line 2004
  goto switch_break;
  case_112: /* CIL Label */ 
  {
#line 2008
  yyval.expr = expr_alloc_one((enum expr_type )3, (yyvsp + 0)->expr);
  }
#line 2009
  goto switch_break;
  case_113: /* CIL Label */ 
  {
#line 2013
  yyval.expr = expr_alloc_two((enum expr_type )1, (yyvsp + -2)->expr, (yyvsp + 0)->expr);
  }
#line 2014
  goto switch_break;
  case_114: /* CIL Label */ 
  {
#line 2018
  yyval.expr = expr_alloc_two((enum expr_type )2, (yyvsp + -2)->expr, (yyvsp + 0)->expr);
  }
#line 2019
  goto switch_break;
  case_115: /* CIL Label */ 
  {
#line 2023
  yyval.symbol = sym_lookup((char const   *)(yyvsp + 0)->string, 0);
#line 2023
  free((void *)(yyvsp + 0)->string);
  }
#line 2024
  goto switch_break;
  case_116: /* CIL Label */ 
  {
#line 2028
  yyval.symbol = sym_lookup((char const   *)(yyvsp + 0)->string, 1);
#line 2028
  free((void *)(yyvsp + 0)->string);
  }
#line 2029
  goto switch_break;
  case_117: /* CIL Label */ 
#line 2033
  yyval.string = (char *)((void *)0);
#line 2034
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 2038
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 2040
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 2040
    if (zconfdebug) {
      {
#line 2040
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
              "-> $$ =");
#line 2040
      yy_symbol_print(stderr, (int )yyr1[yyn], (YYSTYPE const   */* const  */)(& yyval));
#line 2040
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
#line 2040
    goto while_break___9;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 2042
  yyvsp -= yylen;
#line 2042
  yyssp -= yylen;
#line 2043
  yylen = 0;
  {
#line 2044
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 2044
    if (zconfdebug) {
      {
#line 2044
      yy_stack_print(yyss, yyssp);
      }
    }
#line 2044
    goto while_break___10;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 2046
  yyvsp ++;
#line 2046
  *yyvsp = yyval;
#line 2052
  yyn = (int )yyr1[yyn];
#line 2054
  yystate = (int )((int const   )yypgoto[yyn - 36] + (int const   )*yyssp);
#line 2055
  if (0 <= yystate) {
#line 2055
    if (yystate <= 290) {
#line 2055
      if ((int const   )yycheck[yystate] == (int const   )*yyssp) {
#line 2056
        yystate = (int )yytable[yystate];
      } else {
#line 2058
        yystate = (int )yydefgoto[yyn - 36];
      }
    } else {
#line 2058
      yystate = (int )yydefgoto[yyn - 36];
    }
  } else {
#line 2058
    yystate = (int )yydefgoto[yyn - 36];
  }
#line 2060
  goto yynewstate;
  yyerrlab: 
#line 2068
  if (! yyerrstatus) {
    {
#line 2070
    zconfnerrs ++;
#line 2072
    zconferror("syntax error");
    }
  }
#line 2110
  if (yyerrstatus == 3) {
#line 2115
    if (zconfchar <= 0) {
#line 2118
      if (zconfchar == 0) {
#line 2119
        goto yyabortlab;
      }
    } else {
      {
#line 2123
      yydestruct("Error: discarding", yytoken, & zconflval);
#line 2125
      zconfchar = -2;
      }
    }
  }
#line 2131
  goto yyerrlab1;
  yyerrorlab: 
#line 2147
  yyvsp -= yylen;
#line 2147
  yyssp -= yylen;
#line 2148
  yylen = 0;
  {
#line 2149
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 2149
    if (zconfdebug) {
      {
#line 2149
      yy_stack_print(yyss, yyssp);
      }
    }
#line 2149
    goto while_break___11;
  }
  while_break___11: /* CIL Label */ ;
  }
#line 2150
  yystate = (int )*yyssp;
#line 2151
  goto yyerrlab1;
  yyerrlab1: 
#line 2158
  yyerrstatus = 3;
  {
#line 2160
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 2162
    yyn = (int )yypact[yystate];
#line 2163
    if (yyn != -90) {
#line 2165
      yyn ++;
#line 2166
      if (0 <= yyn) {
#line 2166
        if (yyn <= 290) {
#line 2166
          if ((int const   )yycheck[yyn] == 1) {
#line 2168
            yyn = (int )yytable[yyn];
#line 2169
            if (0 < yyn) {
#line 2170
              goto while_break___12;
            }
          }
        }
      }
    }
#line 2175
    if ((unsigned long )yyssp == (unsigned long )yyss) {
#line 2176
      goto yyabortlab;
    }
    {
#line 2179
    yydestruct("Error: popping", (int )yystos[yystate], yyvsp);
#line 2181
    yyvsp --;
#line 2181
    yyssp --;
#line 2182
    yystate = (int )*yyssp;
    }
    {
#line 2183
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 2183
      if (zconfdebug) {
        {
#line 2183
        yy_stack_print(yyss, yyssp);
        }
      }
#line 2183
      goto while_break___13;
    }
    while_break___13: /* CIL Label */ ;
    }
  }
  while_break___12: /* CIL Label */ ;
  }
#line 2186
  yyvsp ++;
#line 2186
  *yyvsp = zconflval;
  {
#line 2190
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 2190
    if (zconfdebug) {
      {
#line 2190
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s ",
              "Shifting");
#line 2190
      yy_symbol_print(stderr, (int )yystos[yyn], (YYSTYPE const   */* const  */)yyvsp);
#line 2190
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
#line 2190
    goto while_break___14;
  }
  while_break___14: /* CIL Label */ ;
  }
#line 2192
  yystate = yyn;
#line 2193
  goto yynewstate;
  yyacceptlab: 
#line 2200
  yyresult = 0;
#line 2201
  goto yyreturn;
  yyabortlab: 
#line 2207
  yyresult = 1;
#line 2208
  goto yyreturn;
  yyexhaustedlab: 
  {
#line 2215
  zconferror("memory exhausted");
#line 2216
  yyresult = 2;
  }
  yyreturn: 
#line 2221
  if (zconfchar != -2) {
    {
#line 2222
    yydestruct("Cleanup: discarding lookahead", yytoken, & zconflval);
    }
  }
#line 2226
  yyvsp -= yylen;
#line 2226
  yyssp -= yylen;
  {
#line 2227
  while (1) {
    while_continue___15: /* CIL Label */ ;
#line 2227
    if (zconfdebug) {
      {
#line 2227
      yy_stack_print(yyss, yyssp);
      }
    }
#line 2227
    goto while_break___15;
  }
  while_break___15: /* CIL Label */ ;
  }
  {
#line 2228
  while (1) {
    while_continue___16: /* CIL Label */ ;
#line 2228
    if (! ((unsigned long )yyssp != (unsigned long )yyss)) {
#line 2228
      goto while_break___16;
    }
    {
#line 2230
    yydestruct("Cleanup: popping", (int )yystos[*yyssp], yyvsp);
#line 2232
    yyvsp --;
#line 2232
    yyssp --;
    }
  }
  while_break___16: /* CIL Label */ ;
  }
#line 2235
  if ((unsigned long )yyss != (unsigned long )(yyssa)) {
    {
#line 2236
    free((void *)yyss);
    }
  }
#line 2243
  return (yyresult);
}
}
#line 2250 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/zconf.tab.c"
void conf_parse(char const   *name ) 
{ 
  struct symbol *sym ;
  int i ;
  char *tmp ;
  struct property *prop ;
  struct symbol *tmp___0 ;
  char *tmp___1 ;
  struct symbol *tmp___2 ;

  {
  {
#line 2255
  zconf_initscan(name);
#line 2257
  sym_init();
#line 2258
  _menu_init();
#line 2259
  modules_sym = sym_lookup((char const   *)((void *)0), 0);
#line 2260
  modules_sym->type = (enum symbol_type )1;
#line 2261
  modules_sym->flags |= 4096;
#line 2262
  rootmenu.prompt = menu_add_prompt((enum prop_type )3, (char *)"Linux Kernel Configuration",
                                    (struct expr *)((void *)0));
#line 2264
  tmp = getenv("ZCONF_DEBUG");
  }
#line 2264
  if (tmp) {
#line 2265
    zconfdebug = 1;
  }
  {
#line 2266
  zconfparse();
  }
#line 2267
  if (zconfnerrs) {
    {
#line 2268
    exit(1);
    }
  }
#line 2269
  if (! modules_sym->prop) {
    {
#line 2272
    prop = prop_alloc((enum prop_type )4, modules_sym);
#line 2273
    tmp___0 = sym_lookup("MODULES", 0);
#line 2273
    prop->expr = expr_alloc_symbol(tmp___0);
    }
  }
  {
#line 2276
  tmp___1 = gettext((rootmenu.prompt)->text);
#line 2276
  (rootmenu.prompt)->text = (char const   *)tmp___1;
#line 2277
  (rootmenu.prompt)->text = sym_expand_string_value((rootmenu.prompt)->text);
#line 2279
  menu_finalize(& rootmenu);
#line 2280
  i = 0;
  }
  {
#line 2280
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2280
    if (! (i < 9973)) {
#line 2280
      goto while_break;
    }
#line 2280
    sym = symbol_hash[i];
    {
#line 2280
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2280
      if (! sym) {
#line 2280
        goto while_break___0;
      }
#line 2280
      if ((unsigned int )sym->type != 6U) {
        {
#line 2281
        tmp___2 = sym_check_deps(sym);
        }
#line 2281
        if (tmp___2) {
#line 2282
          zconfnerrs ++;
        }
      }
#line 2280
      sym = sym->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2280
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2284
  if (zconfnerrs) {
    {
#line 2285
    exit(1);
    }
  }
  {
#line 2286
  sym_set_change_count(1);
  }
#line 2287
  return;
}
}
#line 2289 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/zconf.tab.c"
static char const   *zconf_tokenname(int token ) 
{ 


  {
  {
#line 2292
  if (token == 259) {
#line 2292
    goto case_259;
  }
#line 2293
  if (token == 260) {
#line 2293
    goto case_260;
  }
#line 2294
  if (token == 262) {
#line 2294
    goto case_262;
  }
#line 2295
  if (token == 263) {
#line 2295
    goto case_263;
  }
#line 2296
  if (token == 269) {
#line 2296
    goto case_269;
  }
#line 2297
  if (token == 270) {
#line 2297
    goto case_270;
  }
#line 2298
  if (token == 271) {
#line 2298
    goto case_271;
  }
#line 2299
  if (token == 278) {
#line 2299
    goto case_278;
  }
#line 2291
  goto switch_break;
  case_259: /* CIL Label */ 
#line 2292
  return ("menu");
  case_260: /* CIL Label */ 
#line 2293
  return ("endmenu");
  case_262: /* CIL Label */ 
#line 2294
  return ("choice");
  case_263: /* CIL Label */ 
#line 2295
  return ("endchoice");
  case_269: /* CIL Label */ 
#line 2296
  return ("if");
  case_270: /* CIL Label */ 
#line 2297
  return ("endif");
  case_271: /* CIL Label */ 
#line 2298
  return ("depends");
  case_278: /* CIL Label */ 
#line 2299
  return ("visible");
  switch_break: /* CIL Label */ ;
  }
#line 2301
  return ("<token>");
}
}
#line 2304 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/zconf.tab.c"
static _Bool zconf_endtoken(struct kconf_id  const  *id , int starttoken , int endtoken ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 2306
  if (id->token != (int const   )endtoken) {
    {
#line 2307
    tmp = zconf_tokenname(starttoken);
#line 2307
    zconf_error("unexpected \'%s\' within %s block", (char const   *)(& kconf_id_strings_contents) + id->name,
                tmp);
#line 2309
    zconfnerrs ++;
    }
#line 2310
    return ((_Bool)0);
  }
#line 2312
  if ((unsigned long )current_menu->file != (unsigned long )current_file) {
    {
#line 2313
    tmp___0 = zconf_tokenname(starttoken);
#line 2313
    zconf_error("\'%s\' in different file than \'%s\'", (char const   *)(& kconf_id_strings_contents) + id->name,
                tmp___0);
#line 2315
    tmp___1 = zconf_tokenname(starttoken);
#line 2315
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: location of the \'%s\'\n",
            (current_menu->file)->name, current_menu->lineno, tmp___1);
#line 2318
    zconfnerrs ++;
    }
#line 2319
    return ((_Bool)0);
  }
#line 2321
  return ((_Bool)1);
}
}
#line 2324 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/zconf.tab.c"
static void zconfprint(char const   *err  , ...) 
{ 
  va_list ap ;
  int tmp ;
  char const   *tmp___0 ;

  {
  {
#line 2328
  tmp = zconf_lineno();
#line 2328
  tmp___0 = zconf_curname();
#line 2328
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: ",
          tmp___0, tmp);
#line 2329
  __builtin_va_start(ap, err);
#line 2330
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)err,
           ap);
#line 2331
  __builtin_va_end(ap);
#line 2332
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 2333
  return;
}
}
#line 2335 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/zconf.tab.c"
static void zconf_error(char const   *err  , ...) 
{ 
  va_list ap ;
  int tmp ;
  char const   *tmp___0 ;

  {
  {
#line 2339
  zconfnerrs ++;
#line 2340
  tmp = zconf_lineno();
#line 2340
  tmp___0 = zconf_curname();
#line 2340
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: ",
          tmp___0, tmp);
#line 2341
  __builtin_va_start(ap, err);
#line 2342
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)err,
           ap);
#line 2343
  __builtin_va_end(ap);
#line 2344
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 2345
  return;
}
}
#line 2347 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/zconf.tab.c"
static void zconferror(char const   *err ) 
{ 
  int tmp ;
  char const   *tmp___0 ;

  {
  {
#line 2349
  tmp = zconf_lineno();
#line 2349
  tmp___0 = zconf_curname();
#line 2349
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d: %s\n",
          tmp___0, tmp + 1, err);
  }
#line 2350
  return;
}
}
#line 2352 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/zconf.tab.c"
static void print_quoted_string(FILE *out , char const   *str ) 
{ 
  char const   *p ;
  int len ;
  char *tmp ;

  {
  {
#line 2357
  _IO_putc('\"', out);
  }
  {
#line 2358
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2358
    tmp = strchr(str, '\"');
#line 2358
    p = (char const   *)tmp;
    }
#line 2358
    if (! p) {
#line 2358
      goto while_break;
    }
#line 2359
    len = (int )(p - str);
#line 2360
    if (len) {
      {
#line 2361
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%.*s",
              len, str);
      }
    }
    {
#line 2362
    fputs((char const   */* __restrict  */)"\\\"", (FILE */* __restrict  */)out);
#line 2363
    str = p + 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2365
  fputs((char const   */* __restrict  */)str, (FILE */* __restrict  */)out);
#line 2366
  _IO_putc('\"', out);
  }
#line 2367
  return;
}
}
#line 2369 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/zconf.tab.c"
static void print_symbol(FILE *out , struct menu *menu ) 
{ 
  struct symbol *sym ;
  struct property *prop ;
  _Bool tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int len ;
  size_t tmp___2 ;

  {
  {
#line 2371
  sym = menu->sym;
#line 2374
  tmp = sym_is_choice(sym);
  }
#line 2374
  if (tmp) {
    {
#line 2375
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\nchoice\n");
    }
  } else {
    {
#line 2377
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\nconfig %s\n",
            sym->name);
    }
  }
  {
#line 2379
  if ((unsigned int )sym->type == 1U) {
#line 2379
    goto case_1;
  }
#line 2382
  if ((unsigned int )sym->type == 2U) {
#line 2382
    goto case_2;
  }
#line 2385
  if ((unsigned int )sym->type == 5U) {
#line 2385
    goto case_5;
  }
#line 2388
  if ((unsigned int )sym->type == 3U) {
#line 2388
    goto case_3;
  }
#line 2391
  if ((unsigned int )sym->type == 4U) {
#line 2391
    goto case_4;
  }
#line 2394
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 2380
  fputs((char const   */* __restrict  */)"  boolean\n", (FILE */* __restrict  */)out);
  }
#line 2381
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 2383
  fputs((char const   */* __restrict  */)"  tristate\n", (FILE */* __restrict  */)out);
  }
#line 2384
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 2386
  fputs((char const   */* __restrict  */)"  string\n", (FILE */* __restrict  */)out);
  }
#line 2387
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 2389
  fputs((char const   */* __restrict  */)"  integer\n", (FILE */* __restrict  */)out);
  }
#line 2390
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 2392
  fputs((char const   */* __restrict  */)"  hex\n", (FILE */* __restrict  */)out);
  }
#line 2393
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 2395
  fputs((char const   */* __restrict  */)"  ???\n", (FILE */* __restrict  */)out);
  }
#line 2396
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2398
  prop = sym->prop;
  {
#line 2398
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2398
    if (! prop) {
#line 2398
      goto while_break;
    }
#line 2399
    if ((unsigned long )prop->menu != (unsigned long )menu) {
#line 2400
      goto __Cont;
    }
    {
#line 2402
    if ((unsigned int )prop->type == 1U) {
#line 2402
      goto case_1___0;
    }
#line 2411
    if ((unsigned int )prop->type == 4U) {
#line 2411
      goto case_4___0;
    }
#line 2420
    if ((unsigned int )prop->type == 5U) {
#line 2420
      goto case_5___0;
    }
#line 2423
    if ((unsigned int )prop->type == 6U) {
#line 2423
      goto case_6;
    }
#line 2428
    if ((unsigned int )prop->type == 7U) {
#line 2428
      goto case_7;
    }
#line 2433
    if ((unsigned int )prop->type == 3U) {
#line 2433
      goto case_3___0;
    }
#line 2438
    goto switch_default___0;
    case_1___0: /* CIL Label */ 
    {
#line 2403
    fputs((char const   */* __restrict  */)"  prompt ", (FILE */* __restrict  */)out);
#line 2404
    print_quoted_string(out, prop->text);
#line 2405
    tmp___0 = expr_is_yes(prop->visible.expr);
    }
#line 2405
    if (! tmp___0) {
      {
#line 2406
      fputs((char const   */* __restrict  */)" if ", (FILE */* __restrict  */)out);
#line 2407
      expr_fprint(prop->visible.expr, out);
      }
    }
    {
#line 2409
    fputc('\n', out);
    }
#line 2410
    goto switch_break___0;
    case_4___0: /* CIL Label */ 
    {
#line 2412
    fputs((char const   */* __restrict  */)"  default ", (FILE */* __restrict  */)out);
#line 2413
    expr_fprint(prop->expr, out);
#line 2414
    tmp___1 = expr_is_yes(prop->visible.expr);
    }
#line 2414
    if (! tmp___1) {
      {
#line 2415
      fputs((char const   */* __restrict  */)" if ", (FILE */* __restrict  */)out);
#line 2416
      expr_fprint(prop->visible.expr, out);
      }
    }
    {
#line 2418
    fputc('\n', out);
    }
#line 2419
    goto switch_break___0;
    case_5___0: /* CIL Label */ 
    {
#line 2421
    fputs((char const   */* __restrict  */)"  #choice value\n", (FILE */* __restrict  */)out);
    }
#line 2422
    goto switch_break___0;
    case_6: /* CIL Label */ 
    {
#line 2424
    fputs((char const   */* __restrict  */)"  select ", (FILE */* __restrict  */)out);
#line 2425
    expr_fprint(prop->expr, out);
#line 2426
    fputc('\n', out);
    }
#line 2427
    goto switch_break___0;
    case_7: /* CIL Label */ 
    {
#line 2429
    fputs((char const   */* __restrict  */)"  range ", (FILE */* __restrict  */)out);
#line 2430
    expr_fprint(prop->expr, out);
#line 2431
    fputc('\n', out);
    }
#line 2432
    goto switch_break___0;
    case_3___0: /* CIL Label */ 
    {
#line 2434
    fputs((char const   */* __restrict  */)"  menu ", (FILE */* __restrict  */)out);
#line 2435
    print_quoted_string(out, prop->text);
#line 2436
    fputc('\n', out);
    }
#line 2437
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 2439
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"  unknown prop %d!\n",
            (unsigned int )prop->type);
    }
#line 2440
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 2398
    prop = prop->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 2443
  if (menu->help) {
    {
#line 2444
    tmp___2 = strlen((char const   *)menu->help);
#line 2444
    len = (int )tmp___2;
    }
    {
#line 2445
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2445
      len --;
#line 2445
      if (! ((int )*(menu->help + len) == 10)) {
#line 2445
        goto while_break___0;
      }
#line 2446
      *(menu->help + len) = (char)0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2447
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"  help\n%s\n",
            menu->help);
    }
  }
#line 2449
  return;
}
}
#line 2451 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/zconf.tab.c"
void zconfdump(FILE *out ) 
{ 
  struct property *prop ;
  struct symbol *sym ;
  struct menu *menu ;
  int tmp ;

  {
#line 2457
  menu = rootmenu.list;
  {
#line 2458
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2458
    if (! menu) {
#line 2458
      goto while_break;
    }
#line 2459
    sym = menu->sym;
#line 2459
    if (sym) {
      {
#line 2460
      print_symbol(out, menu);
      }
    } else {
#line 2461
      prop = menu->prompt;
#line 2461
      if (prop) {
        {
#line 2463
        if ((unsigned int )prop->type == 2U) {
#line 2463
          goto case_2;
        }
#line 2468
        if ((unsigned int )prop->type == 3U) {
#line 2468
          goto case_3;
        }
#line 2473
        goto switch_default;
        case_2: /* CIL Label */ 
        {
#line 2464
        fputs((char const   */* __restrict  */)"\ncomment ", (FILE */* __restrict  */)out);
#line 2465
        print_quoted_string(out, prop->text);
#line 2466
        fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)out);
        }
#line 2467
        goto switch_break;
        case_3: /* CIL Label */ 
        {
#line 2469
        fputs((char const   */* __restrict  */)"\nmenu ", (FILE */* __restrict  */)out);
#line 2470
        print_quoted_string(out, prop->text);
#line 2471
        fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)out);
        }
#line 2472
        goto switch_break;
        switch_default: /* CIL Label */ ;
        switch_break: /* CIL Label */ ;
        }
        {
#line 2476
        tmp = expr_is_yes(prop->visible.expr);
        }
#line 2476
        if (! tmp) {
          {
#line 2477
          fputs((char const   */* __restrict  */)"  depends ", (FILE */* __restrict  */)out);
#line 2478
          expr_fprint(prop->visible.expr, out);
#line 2479
          fputc('\n', out);
          }
        }
      }
    }
#line 2483
    if (menu->list) {
#line 2484
      menu = menu->list;
    } else
#line 2485
    if (menu->next) {
#line 2486
      menu = menu->next;
    } else {
      {
#line 2487
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2487
        menu = menu->parent;
#line 2487
        if (! menu) {
#line 2487
          goto while_break___0;
        }
#line 2488
        if (menu->prompt) {
#line 2488
          if ((unsigned int )(menu->prompt)->type == 3U) {
            {
#line 2489
            fputs((char const   */* __restrict  */)"\nendmenu\n", (FILE */* __restrict  */)out);
            }
          }
        }
#line 2490
        if (menu->next) {
#line 2491
          menu = menu->next;
#line 2492
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2496
  return;
}
}
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 174 "scripts/kconfig/zconf.lex.c_shipped"
int zconfleng  ;
#line 176
FILE *zconfin ;
#line 176
FILE *zconfout ;
#line 271 "scripts/kconfig/zconf.lex.c_shipped"
static size_t yy_buffer_stack_top  =    (size_t )0;
#line 272 "scripts/kconfig/zconf.lex.c_shipped"
static size_t yy_buffer_stack_max  =    (size_t )0;
#line 273 "scripts/kconfig/zconf.lex.c_shipped"
static YY_BUFFER_STATE *yy_buffer_stack  =    (YY_BUFFER_STATE *)0;
#line 291 "scripts/kconfig/zconf.lex.c_shipped"
static char yy_hold_char  ;
#line 292 "scripts/kconfig/zconf.lex.c_shipped"
static int yy_n_chars  ;
#line 296 "scripts/kconfig/zconf.lex.c_shipped"
static char *yy_c_buf_p  =    (char *)0;
#line 297 "scripts/kconfig/zconf.lex.c_shipped"
static int yy_init  =    0;
#line 298 "scripts/kconfig/zconf.lex.c_shipped"
static int yy_start  =    0;
#line 303 "scripts/kconfig/zconf.lex.c_shipped"
static int yy_did_buffer_switch_on_eof  ;
#line 305
void zconfrestart(FILE *input_file ) ;
#line 306
void zconf_switch_to_buffer(YY_BUFFER_STATE new_buffer ) ;
#line 307
YY_BUFFER_STATE zconf_create_buffer(FILE *file , int size ) ;
#line 308
void zconf_delete_buffer(YY_BUFFER_STATE b ) ;
#line 309
void zconf_flush_buffer(YY_BUFFER_STATE b ) ;
#line 310
void zconfpush_buffer_state(YY_BUFFER_STATE new_buffer ) ;
#line 311
void zconfpop_buffer_state(void) ;
#line 313
static void zconfensure_buffer_stack(void) ;
#line 314
static void zconf_load_buffer_state(void) ;
#line 315
static void zconf_init_buffer(YY_BUFFER_STATE b , FILE *file ) ;
#line 319
YY_BUFFER_STATE zconf_scan_buffer(char *base , yy_size_t size ) ;
#line 320
YY_BUFFER_STATE zconf_scan_string(char const   *yystr ) ;
#line 321
YY_BUFFER_STATE zconf_scan_bytes(char const   *yybytes , int _yybytes_len ) ;
#line 323
void *zconfalloc(yy_size_t size ) ;
#line 324
void *zconfrealloc(void *ptr , yy_size_t size ) ;
#line 325
void zconffree(void *ptr ) ;
#line 358 "scripts/kconfig/zconf.lex.c_shipped"
FILE *zconfin  =    (FILE *)0;
#line 358 "scripts/kconfig/zconf.lex.c_shipped"
FILE *zconfout  =    (FILE *)0;
#line 362
int zconflineno ;
#line 364 "scripts/kconfig/zconf.lex.c_shipped"
int zconflineno  =    1;
#line 366 "scripts/kconfig/zconf.lex.c_shipped"
char *zconftext  ;
#line 368 "scripts/kconfig/zconf.lex.c_shipped"
static flex_int16_t const   yy_nxt[61][17]  = 
#line 368
  { {        (flex_int16_t const   )0,        (flex_int16_t const   )0,        (flex_int16_t const   )0,        (flex_int16_t const   )0, 
            (flex_int16_t const   )0,        (flex_int16_t const   )0,        (flex_int16_t const   )0,        (flex_int16_t const   )0, 
            (flex_int16_t const   )0,        (flex_int16_t const   )0,        (flex_int16_t const   )0,        (flex_int16_t const   )0, 
            (flex_int16_t const   )0,        (flex_int16_t const   )0,        (flex_int16_t const   )0,        (flex_int16_t const   )0, 
            (flex_int16_t const   )0}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )12,        (flex_int16_t const   )13,        (flex_int16_t const   )14, 
            (flex_int16_t const   )12,        (flex_int16_t const   )12,        (flex_int16_t const   )15,        (flex_int16_t const   )12, 
            (flex_int16_t const   )12,        (flex_int16_t const   )12,        (flex_int16_t const   )12,        (flex_int16_t const   )12, 
            (flex_int16_t const   )12,        (flex_int16_t const   )12,        (flex_int16_t const   )12,        (flex_int16_t const   )12, 
            (flex_int16_t const   )12}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )12,        (flex_int16_t const   )13,        (flex_int16_t const   )14, 
            (flex_int16_t const   )12,        (flex_int16_t const   )12,        (flex_int16_t const   )15,        (flex_int16_t const   )12, 
            (flex_int16_t const   )12,        (flex_int16_t const   )12,        (flex_int16_t const   )12,        (flex_int16_t const   )12, 
            (flex_int16_t const   )12,        (flex_int16_t const   )12,        (flex_int16_t const   )12,        (flex_int16_t const   )12, 
            (flex_int16_t const   )12}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )16,        (flex_int16_t const   )16,        (flex_int16_t const   )17, 
            (flex_int16_t const   )16,        (flex_int16_t const   )16,        (flex_int16_t const   )16,        (flex_int16_t const   )16, 
            (flex_int16_t const   )16,        (flex_int16_t const   )16,        (flex_int16_t const   )16,        (flex_int16_t const   )16, 
            (flex_int16_t const   )16,        (flex_int16_t const   )18,        (flex_int16_t const   )16,        (flex_int16_t const   )16, 
            (flex_int16_t const   )16}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )16,        (flex_int16_t const   )16,        (flex_int16_t const   )17, 
            (flex_int16_t const   )16,        (flex_int16_t const   )16,        (flex_int16_t const   )16,        (flex_int16_t const   )16, 
            (flex_int16_t const   )16,        (flex_int16_t const   )16,        (flex_int16_t const   )16,        (flex_int16_t const   )16, 
            (flex_int16_t const   )16,        (flex_int16_t const   )18,        (flex_int16_t const   )16,        (flex_int16_t const   )16, 
            (flex_int16_t const   )16}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )19,        (flex_int16_t const   )20,        (flex_int16_t const   )21, 
            (flex_int16_t const   )19,        (flex_int16_t const   )19,        (flex_int16_t const   )19,        (flex_int16_t const   )19, 
            (flex_int16_t const   )19,        (flex_int16_t const   )19,        (flex_int16_t const   )19,        (flex_int16_t const   )19, 
            (flex_int16_t const   )19,        (flex_int16_t const   )19,        (flex_int16_t const   )19,        (flex_int16_t const   )19, 
            (flex_int16_t const   )19}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )19,        (flex_int16_t const   )20,        (flex_int16_t const   )21, 
            (flex_int16_t const   )19,        (flex_int16_t const   )19,        (flex_int16_t const   )19,        (flex_int16_t const   )19, 
            (flex_int16_t const   )19,        (flex_int16_t const   )19,        (flex_int16_t const   )19,        (flex_int16_t const   )19, 
            (flex_int16_t const   )19,        (flex_int16_t const   )19,        (flex_int16_t const   )19,        (flex_int16_t const   )19, 
            (flex_int16_t const   )19}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )22,        (flex_int16_t const   )22,        (flex_int16_t const   )23, 
            (flex_int16_t const   )22,        (flex_int16_t const   )24,        (flex_int16_t const   )22,        (flex_int16_t const   )22, 
            (flex_int16_t const   )24,        (flex_int16_t const   )22,        (flex_int16_t const   )22,        (flex_int16_t const   )22, 
            (flex_int16_t const   )22,        (flex_int16_t const   )22,        (flex_int16_t const   )22,        (flex_int16_t const   )25, 
            (flex_int16_t const   )22}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )22,        (flex_int16_t const   )22,        (flex_int16_t const   )23, 
            (flex_int16_t const   )22,        (flex_int16_t const   )24,        (flex_int16_t const   )22,        (flex_int16_t const   )22, 
            (flex_int16_t const   )24,        (flex_int16_t const   )22,        (flex_int16_t const   )22,        (flex_int16_t const   )22, 
            (flex_int16_t const   )22,        (flex_int16_t const   )22,        (flex_int16_t const   )22,        (flex_int16_t const   )25, 
            (flex_int16_t const   )22}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )26,        (flex_int16_t const   )26,        (flex_int16_t const   )27, 
            (flex_int16_t const   )28,        (flex_int16_t const   )29,        (flex_int16_t const   )30,        (flex_int16_t const   )31, 
            (flex_int16_t const   )29,        (flex_int16_t const   )32,        (flex_int16_t const   )33,        (flex_int16_t const   )34, 
            (flex_int16_t const   )35,        (flex_int16_t const   )35,        (flex_int16_t const   )36,        (flex_int16_t const   )37, 
            (flex_int16_t const   )38}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )26,        (flex_int16_t const   )26,        (flex_int16_t const   )27, 
            (flex_int16_t const   )28,        (flex_int16_t const   )29,        (flex_int16_t const   )30,        (flex_int16_t const   )31, 
            (flex_int16_t const   )29,        (flex_int16_t const   )32,        (flex_int16_t const   )33,        (flex_int16_t const   )34, 
            (flex_int16_t const   )35,        (flex_int16_t const   )35,        (flex_int16_t const   )36,        (flex_int16_t const   )37, 
            (flex_int16_t const   )38}, 
   {        (flex_int16_t const   )-11,        (flex_int16_t const   )-11,        (flex_int16_t const   )-11,        (flex_int16_t const   )-11, 
            (flex_int16_t const   )-11,        (flex_int16_t const   )-11,        (flex_int16_t const   )-11,        (flex_int16_t const   )-11, 
            (flex_int16_t const   )-11,        (flex_int16_t const   )-11,        (flex_int16_t const   )-11,        (flex_int16_t const   )-11, 
            (flex_int16_t const   )-11,        (flex_int16_t const   )-11,        (flex_int16_t const   )-11,        (flex_int16_t const   )-11, 
            (flex_int16_t const   )-11}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-12,        (flex_int16_t const   )-12,        (flex_int16_t const   )-12, 
            (flex_int16_t const   )-12,        (flex_int16_t const   )-12,        (flex_int16_t const   )-12,        (flex_int16_t const   )-12, 
            (flex_int16_t const   )-12,        (flex_int16_t const   )-12,        (flex_int16_t const   )-12,        (flex_int16_t const   )-12, 
            (flex_int16_t const   )-12,        (flex_int16_t const   )-12,        (flex_int16_t const   )-12,        (flex_int16_t const   )-12, 
            (flex_int16_t const   )-12}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-13,        (flex_int16_t const   )39,        (flex_int16_t const   )40, 
            (flex_int16_t const   )-13,        (flex_int16_t const   )-13,        (flex_int16_t const   )41,        (flex_int16_t const   )-13, 
            (flex_int16_t const   )-13,        (flex_int16_t const   )-13,        (flex_int16_t const   )-13,        (flex_int16_t const   )-13, 
            (flex_int16_t const   )-13,        (flex_int16_t const   )-13,        (flex_int16_t const   )-13,        (flex_int16_t const   )-13, 
            (flex_int16_t const   )-13}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-14,        (flex_int16_t const   )-14,        (flex_int16_t const   )-14, 
            (flex_int16_t const   )-14,        (flex_int16_t const   )-14,        (flex_int16_t const   )-14,        (flex_int16_t const   )-14, 
            (flex_int16_t const   )-14,        (flex_int16_t const   )-14,        (flex_int16_t const   )-14,        (flex_int16_t const   )-14, 
            (flex_int16_t const   )-14,        (flex_int16_t const   )-14,        (flex_int16_t const   )-14,        (flex_int16_t const   )-14, 
            (flex_int16_t const   )-14}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )42,        (flex_int16_t const   )42,        (flex_int16_t const   )43, 
            (flex_int16_t const   )42,        (flex_int16_t const   )42,        (flex_int16_t const   )42,        (flex_int16_t const   )42, 
            (flex_int16_t const   )42,        (flex_int16_t const   )42,        (flex_int16_t const   )42,        (flex_int16_t const   )42, 
            (flex_int16_t const   )42,        (flex_int16_t const   )42,        (flex_int16_t const   )42,        (flex_int16_t const   )42, 
            (flex_int16_t const   )42}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-16,        (flex_int16_t const   )-16,        (flex_int16_t const   )-16, 
            (flex_int16_t const   )-16,        (flex_int16_t const   )-16,        (flex_int16_t const   )-16,        (flex_int16_t const   )-16, 
            (flex_int16_t const   )-16,        (flex_int16_t const   )-16,        (flex_int16_t const   )-16,        (flex_int16_t const   )-16, 
            (flex_int16_t const   )-16,        (flex_int16_t const   )-16,        (flex_int16_t const   )-16,        (flex_int16_t const   )-16, 
            (flex_int16_t const   )-16}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-17,        (flex_int16_t const   )-17,        (flex_int16_t const   )-17, 
            (flex_int16_t const   )-17,        (flex_int16_t const   )-17,        (flex_int16_t const   )-17,        (flex_int16_t const   )-17, 
            (flex_int16_t const   )-17,        (flex_int16_t const   )-17,        (flex_int16_t const   )-17,        (flex_int16_t const   )-17, 
            (flex_int16_t const   )-17,        (flex_int16_t const   )-17,        (flex_int16_t const   )-17,        (flex_int16_t const   )-17, 
            (flex_int16_t const   )-17}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-18,        (flex_int16_t const   )-18,        (flex_int16_t const   )-18, 
            (flex_int16_t const   )-18,        (flex_int16_t const   )-18,        (flex_int16_t const   )-18,        (flex_int16_t const   )-18, 
            (flex_int16_t const   )-18,        (flex_int16_t const   )-18,        (flex_int16_t const   )-18,        (flex_int16_t const   )-18, 
            (flex_int16_t const   )-18,        (flex_int16_t const   )44,        (flex_int16_t const   )-18,        (flex_int16_t const   )-18, 
            (flex_int16_t const   )-18}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )-19, 
            (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )45, 
            (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )45, 
            (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )45, 
            (flex_int16_t const   )45}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-20,        (flex_int16_t const   )46,        (flex_int16_t const   )47, 
            (flex_int16_t const   )-20,        (flex_int16_t const   )-20,        (flex_int16_t const   )-20,        (flex_int16_t const   )-20, 
            (flex_int16_t const   )-20,        (flex_int16_t const   )-20,        (flex_int16_t const   )-20,        (flex_int16_t const   )-20, 
            (flex_int16_t const   )-20,        (flex_int16_t const   )-20,        (flex_int16_t const   )-20,        (flex_int16_t const   )-20, 
            (flex_int16_t const   )-20}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )48,        (flex_int16_t const   )-21,        (flex_int16_t const   )-21, 
            (flex_int16_t const   )48,        (flex_int16_t const   )48,        (flex_int16_t const   )48,        (flex_int16_t const   )48, 
            (flex_int16_t const   )48,        (flex_int16_t const   )48,        (flex_int16_t const   )48,        (flex_int16_t const   )48, 
            (flex_int16_t const   )48,        (flex_int16_t const   )48,        (flex_int16_t const   )48,        (flex_int16_t const   )48, 
            (flex_int16_t const   )48}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )49,        (flex_int16_t const   )49,        (flex_int16_t const   )50, 
            (flex_int16_t const   )49,        (flex_int16_t const   )-22,        (flex_int16_t const   )49,        (flex_int16_t const   )49, 
            (flex_int16_t const   )-22,        (flex_int16_t const   )49,        (flex_int16_t const   )49,        (flex_int16_t const   )49, 
            (flex_int16_t const   )49,        (flex_int16_t const   )49,        (flex_int16_t const   )49,        (flex_int16_t const   )-22, 
            (flex_int16_t const   )49}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-23,        (flex_int16_t const   )-23,        (flex_int16_t const   )-23, 
            (flex_int16_t const   )-23,        (flex_int16_t const   )-23,        (flex_int16_t const   )-23,        (flex_int16_t const   )-23, 
            (flex_int16_t const   )-23,        (flex_int16_t const   )-23,        (flex_int16_t const   )-23,        (flex_int16_t const   )-23, 
            (flex_int16_t const   )-23,        (flex_int16_t const   )-23,        (flex_int16_t const   )-23,        (flex_int16_t const   )-23, 
            (flex_int16_t const   )-23}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-24,        (flex_int16_t const   )-24,        (flex_int16_t const   )-24, 
            (flex_int16_t const   )-24,        (flex_int16_t const   )-24,        (flex_int16_t const   )-24,        (flex_int16_t const   )-24, 
            (flex_int16_t const   )-24,        (flex_int16_t const   )-24,        (flex_int16_t const   )-24,        (flex_int16_t const   )-24, 
            (flex_int16_t const   )-24,        (flex_int16_t const   )-24,        (flex_int16_t const   )-24,        (flex_int16_t const   )-24, 
            (flex_int16_t const   )-24}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )51,        (flex_int16_t const   )51,        (flex_int16_t const   )52, 
            (flex_int16_t const   )51,        (flex_int16_t const   )51,        (flex_int16_t const   )51,        (flex_int16_t const   )51, 
            (flex_int16_t const   )51,        (flex_int16_t const   )51,        (flex_int16_t const   )51,        (flex_int16_t const   )51, 
            (flex_int16_t const   )51,        (flex_int16_t const   )51,        (flex_int16_t const   )51,        (flex_int16_t const   )51, 
            (flex_int16_t const   )51}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-26,        (flex_int16_t const   )-26,        (flex_int16_t const   )-26, 
            (flex_int16_t const   )-26,        (flex_int16_t const   )-26,        (flex_int16_t const   )-26,        (flex_int16_t const   )-26, 
            (flex_int16_t const   )-26,        (flex_int16_t const   )-26,        (flex_int16_t const   )-26,        (flex_int16_t const   )-26, 
            (flex_int16_t const   )-26,        (flex_int16_t const   )-26,        (flex_int16_t const   )-26,        (flex_int16_t const   )-26, 
            (flex_int16_t const   )-26}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-27,        (flex_int16_t const   )-27,        (flex_int16_t const   )-27, 
            (flex_int16_t const   )-27,        (flex_int16_t const   )-27,        (flex_int16_t const   )-27,        (flex_int16_t const   )-27, 
            (flex_int16_t const   )-27,        (flex_int16_t const   )-27,        (flex_int16_t const   )-27,        (flex_int16_t const   )-27, 
            (flex_int16_t const   )-27,        (flex_int16_t const   )-27,        (flex_int16_t const   )-27,        (flex_int16_t const   )-27, 
            (flex_int16_t const   )-27}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-28,        (flex_int16_t const   )-28,        (flex_int16_t const   )-28, 
            (flex_int16_t const   )-28,        (flex_int16_t const   )-28,        (flex_int16_t const   )-28,        (flex_int16_t const   )-28, 
            (flex_int16_t const   )-28,        (flex_int16_t const   )-28,        (flex_int16_t const   )-28,        (flex_int16_t const   )-28, 
            (flex_int16_t const   )-28,        (flex_int16_t const   )-28,        (flex_int16_t const   )53,        (flex_int16_t const   )-28, 
            (flex_int16_t const   )-28}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-29,        (flex_int16_t const   )-29,        (flex_int16_t const   )-29, 
            (flex_int16_t const   )-29,        (flex_int16_t const   )-29,        (flex_int16_t const   )-29,        (flex_int16_t const   )-29, 
            (flex_int16_t const   )-29,        (flex_int16_t const   )-29,        (flex_int16_t const   )-29,        (flex_int16_t const   )-29, 
            (flex_int16_t const   )-29,        (flex_int16_t const   )-29,        (flex_int16_t const   )-29,        (flex_int16_t const   )-29, 
            (flex_int16_t const   )-29}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )54,        (flex_int16_t const   )54,        (flex_int16_t const   )-30, 
            (flex_int16_t const   )54,        (flex_int16_t const   )54,        (flex_int16_t const   )54,        (flex_int16_t const   )54, 
            (flex_int16_t const   )54,        (flex_int16_t const   )54,        (flex_int16_t const   )54,        (flex_int16_t const   )54, 
            (flex_int16_t const   )54,        (flex_int16_t const   )54,        (flex_int16_t const   )54,        (flex_int16_t const   )54, 
            (flex_int16_t const   )54}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-31,        (flex_int16_t const   )-31,        (flex_int16_t const   )-31, 
            (flex_int16_t const   )-31,        (flex_int16_t const   )-31,        (flex_int16_t const   )-31,        (flex_int16_t const   )55, 
            (flex_int16_t const   )-31,        (flex_int16_t const   )-31,        (flex_int16_t const   )-31,        (flex_int16_t const   )-31, 
            (flex_int16_t const   )-31,        (flex_int16_t const   )-31,        (flex_int16_t const   )-31,        (flex_int16_t const   )-31, 
            (flex_int16_t const   )-31}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-32,        (flex_int16_t const   )-32,        (flex_int16_t const   )-32, 
            (flex_int16_t const   )-32,        (flex_int16_t const   )-32,        (flex_int16_t const   )-32,        (flex_int16_t const   )-32, 
            (flex_int16_t const   )-32,        (flex_int16_t const   )-32,        (flex_int16_t const   )-32,        (flex_int16_t const   )-32, 
            (flex_int16_t const   )-32,        (flex_int16_t const   )-32,        (flex_int16_t const   )-32,        (flex_int16_t const   )-32, 
            (flex_int16_t const   )-32}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-33,        (flex_int16_t const   )-33,        (flex_int16_t const   )-33, 
            (flex_int16_t const   )-33,        (flex_int16_t const   )-33,        (flex_int16_t const   )-33,        (flex_int16_t const   )-33, 
            (flex_int16_t const   )-33,        (flex_int16_t const   )-33,        (flex_int16_t const   )-33,        (flex_int16_t const   )-33, 
            (flex_int16_t const   )-33,        (flex_int16_t const   )-33,        (flex_int16_t const   )-33,        (flex_int16_t const   )-33, 
            (flex_int16_t const   )-33}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-34,        (flex_int16_t const   )-34,        (flex_int16_t const   )-34, 
            (flex_int16_t const   )-34,        (flex_int16_t const   )-34,        (flex_int16_t const   )-34,        (flex_int16_t const   )-34, 
            (flex_int16_t const   )-34,        (flex_int16_t const   )-34,        (flex_int16_t const   )-34,        (flex_int16_t const   )56, 
            (flex_int16_t const   )57,        (flex_int16_t const   )57,        (flex_int16_t const   )-34,        (flex_int16_t const   )-34, 
            (flex_int16_t const   )-34}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-35,        (flex_int16_t const   )-35,        (flex_int16_t const   )-35, 
            (flex_int16_t const   )-35,        (flex_int16_t const   )-35,        (flex_int16_t const   )-35,        (flex_int16_t const   )-35, 
            (flex_int16_t const   )-35,        (flex_int16_t const   )-35,        (flex_int16_t const   )-35,        (flex_int16_t const   )57, 
            (flex_int16_t const   )57,        (flex_int16_t const   )57,        (flex_int16_t const   )-35,        (flex_int16_t const   )-35, 
            (flex_int16_t const   )-35}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-36,        (flex_int16_t const   )-36,        (flex_int16_t const   )-36, 
            (flex_int16_t const   )-36,        (flex_int16_t const   )-36,        (flex_int16_t const   )-36,        (flex_int16_t const   )-36, 
            (flex_int16_t const   )-36,        (flex_int16_t const   )-36,        (flex_int16_t const   )-36,        (flex_int16_t const   )-36, 
            (flex_int16_t const   )-36,        (flex_int16_t const   )-36,        (flex_int16_t const   )-36,        (flex_int16_t const   )-36, 
            (flex_int16_t const   )-36}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-37,        (flex_int16_t const   )-37,        (flex_int16_t const   )58, 
            (flex_int16_t const   )-37,        (flex_int16_t const   )-37,        (flex_int16_t const   )-37,        (flex_int16_t const   )-37, 
            (flex_int16_t const   )-37,        (flex_int16_t const   )-37,        (flex_int16_t const   )-37,        (flex_int16_t const   )-37, 
            (flex_int16_t const   )-37,        (flex_int16_t const   )-37,        (flex_int16_t const   )-37,        (flex_int16_t const   )-37, 
            (flex_int16_t const   )-37}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-38,        (flex_int16_t const   )-38,        (flex_int16_t const   )-38, 
            (flex_int16_t const   )-38,        (flex_int16_t const   )-38,        (flex_int16_t const   )-38,        (flex_int16_t const   )-38, 
            (flex_int16_t const   )-38,        (flex_int16_t const   )-38,        (flex_int16_t const   )-38,        (flex_int16_t const   )-38, 
            (flex_int16_t const   )-38,        (flex_int16_t const   )-38,        (flex_int16_t const   )-38,        (flex_int16_t const   )-38, 
            (flex_int16_t const   )59}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-39,        (flex_int16_t const   )39,        (flex_int16_t const   )40, 
            (flex_int16_t const   )-39,        (flex_int16_t const   )-39,        (flex_int16_t const   )41,        (flex_int16_t const   )-39, 
            (flex_int16_t const   )-39,        (flex_int16_t const   )-39,        (flex_int16_t const   )-39,        (flex_int16_t const   )-39, 
            (flex_int16_t const   )-39,        (flex_int16_t const   )-39,        (flex_int16_t const   )-39,        (flex_int16_t const   )-39, 
            (flex_int16_t const   )-39}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-40,        (flex_int16_t const   )-40,        (flex_int16_t const   )-40, 
            (flex_int16_t const   )-40,        (flex_int16_t const   )-40,        (flex_int16_t const   )-40,        (flex_int16_t const   )-40, 
            (flex_int16_t const   )-40,        (flex_int16_t const   )-40,        (flex_int16_t const   )-40,        (flex_int16_t const   )-40, 
            (flex_int16_t const   )-40,        (flex_int16_t const   )-40,        (flex_int16_t const   )-40,        (flex_int16_t const   )-40, 
            (flex_int16_t const   )-40}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )42,        (flex_int16_t const   )42,        (flex_int16_t const   )43, 
            (flex_int16_t const   )42,        (flex_int16_t const   )42,        (flex_int16_t const   )42,        (flex_int16_t const   )42, 
            (flex_int16_t const   )42,        (flex_int16_t const   )42,        (flex_int16_t const   )42,        (flex_int16_t const   )42, 
            (flex_int16_t const   )42,        (flex_int16_t const   )42,        (flex_int16_t const   )42,        (flex_int16_t const   )42, 
            (flex_int16_t const   )42}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )42,        (flex_int16_t const   )42,        (flex_int16_t const   )43, 
            (flex_int16_t const   )42,        (flex_int16_t const   )42,        (flex_int16_t const   )42,        (flex_int16_t const   )42, 
            (flex_int16_t const   )42,        (flex_int16_t const   )42,        (flex_int16_t const   )42,        (flex_int16_t const   )42, 
            (flex_int16_t const   )42,        (flex_int16_t const   )42,        (flex_int16_t const   )42,        (flex_int16_t const   )42, 
            (flex_int16_t const   )42}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-43,        (flex_int16_t const   )-43,        (flex_int16_t const   )-43, 
            (flex_int16_t const   )-43,        (flex_int16_t const   )-43,        (flex_int16_t const   )-43,        (flex_int16_t const   )-43, 
            (flex_int16_t const   )-43,        (flex_int16_t const   )-43,        (flex_int16_t const   )-43,        (flex_int16_t const   )-43, 
            (flex_int16_t const   )-43,        (flex_int16_t const   )-43,        (flex_int16_t const   )-43,        (flex_int16_t const   )-43, 
            (flex_int16_t const   )-43}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-44,        (flex_int16_t const   )-44,        (flex_int16_t const   )-44, 
            (flex_int16_t const   )-44,        (flex_int16_t const   )-44,        (flex_int16_t const   )-44,        (flex_int16_t const   )-44, 
            (flex_int16_t const   )-44,        (flex_int16_t const   )-44,        (flex_int16_t const   )-44,        (flex_int16_t const   )-44, 
            (flex_int16_t const   )-44,        (flex_int16_t const   )44,        (flex_int16_t const   )-44,        (flex_int16_t const   )-44, 
            (flex_int16_t const   )-44}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )-45, 
            (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )45, 
            (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )45, 
            (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )45,        (flex_int16_t const   )45, 
            (flex_int16_t const   )45}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-46,        (flex_int16_t const   )46,        (flex_int16_t const   )47, 
            (flex_int16_t const   )-46,        (flex_int16_t const   )-46,        (flex_int16_t const   )-46,        (flex_int16_t const   )-46, 
            (flex_int16_t const   )-46,        (flex_int16_t const   )-46,        (flex_int16_t const   )-46,        (flex_int16_t const   )-46, 
            (flex_int16_t const   )-46,        (flex_int16_t const   )-46,        (flex_int16_t const   )-46,        (flex_int16_t const   )-46, 
            (flex_int16_t const   )-46}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )48,        (flex_int16_t const   )-47,        (flex_int16_t const   )-47, 
            (flex_int16_t const   )48,        (flex_int16_t const   )48,        (flex_int16_t const   )48,        (flex_int16_t const   )48, 
            (flex_int16_t const   )48,        (flex_int16_t const   )48,        (flex_int16_t const   )48,        (flex_int16_t const   )48, 
            (flex_int16_t const   )48,        (flex_int16_t const   )48,        (flex_int16_t const   )48,        (flex_int16_t const   )48, 
            (flex_int16_t const   )48}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-48,        (flex_int16_t const   )-48,        (flex_int16_t const   )-48, 
            (flex_int16_t const   )-48,        (flex_int16_t const   )-48,        (flex_int16_t const   )-48,        (flex_int16_t const   )-48, 
            (flex_int16_t const   )-48,        (flex_int16_t const   )-48,        (flex_int16_t const   )-48,        (flex_int16_t const   )-48, 
            (flex_int16_t const   )-48,        (flex_int16_t const   )-48,        (flex_int16_t const   )-48,        (flex_int16_t const   )-48, 
            (flex_int16_t const   )-48}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )49,        (flex_int16_t const   )49,        (flex_int16_t const   )50, 
            (flex_int16_t const   )49,        (flex_int16_t const   )-49,        (flex_int16_t const   )49,        (flex_int16_t const   )49, 
            (flex_int16_t const   )-49,        (flex_int16_t const   )49,        (flex_int16_t const   )49,        (flex_int16_t const   )49, 
            (flex_int16_t const   )49,        (flex_int16_t const   )49,        (flex_int16_t const   )49,        (flex_int16_t const   )-49, 
            (flex_int16_t const   )49}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-50,        (flex_int16_t const   )-50,        (flex_int16_t const   )-50, 
            (flex_int16_t const   )-50,        (flex_int16_t const   )-50,        (flex_int16_t const   )-50,        (flex_int16_t const   )-50, 
            (flex_int16_t const   )-50,        (flex_int16_t const   )-50,        (flex_int16_t const   )-50,        (flex_int16_t const   )-50, 
            (flex_int16_t const   )-50,        (flex_int16_t const   )-50,        (flex_int16_t const   )-50,        (flex_int16_t const   )-50, 
            (flex_int16_t const   )-50}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-51,        (flex_int16_t const   )-51,        (flex_int16_t const   )52, 
            (flex_int16_t const   )-51,        (flex_int16_t const   )-51,        (flex_int16_t const   )-51,        (flex_int16_t const   )-51, 
            (flex_int16_t const   )-51,        (flex_int16_t const   )-51,        (flex_int16_t const   )-51,        (flex_int16_t const   )-51, 
            (flex_int16_t const   )-51,        (flex_int16_t const   )-51,        (flex_int16_t const   )-51,        (flex_int16_t const   )-51, 
            (flex_int16_t const   )-51}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-52,        (flex_int16_t const   )-52,        (flex_int16_t const   )-52, 
            (flex_int16_t const   )-52,        (flex_int16_t const   )-52,        (flex_int16_t const   )-52,        (flex_int16_t const   )-52, 
            (flex_int16_t const   )-52,        (flex_int16_t const   )-52,        (flex_int16_t const   )-52,        (flex_int16_t const   )-52, 
            (flex_int16_t const   )-52,        (flex_int16_t const   )-52,        (flex_int16_t const   )-52,        (flex_int16_t const   )-52, 
            (flex_int16_t const   )-52}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-53,        (flex_int16_t const   )-53,        (flex_int16_t const   )-53, 
            (flex_int16_t const   )-53,        (flex_int16_t const   )-53,        (flex_int16_t const   )-53,        (flex_int16_t const   )-53, 
            (flex_int16_t const   )-53,        (flex_int16_t const   )-53,        (flex_int16_t const   )-53,        (flex_int16_t const   )-53, 
            (flex_int16_t const   )-53,        (flex_int16_t const   )-53,        (flex_int16_t const   )-53,        (flex_int16_t const   )-53, 
            (flex_int16_t const   )-53}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )54,        (flex_int16_t const   )54,        (flex_int16_t const   )-54, 
            (flex_int16_t const   )54,        (flex_int16_t const   )54,        (flex_int16_t const   )54,        (flex_int16_t const   )54, 
            (flex_int16_t const   )54,        (flex_int16_t const   )54,        (flex_int16_t const   )54,        (flex_int16_t const   )54, 
            (flex_int16_t const   )54,        (flex_int16_t const   )54,        (flex_int16_t const   )54,        (flex_int16_t const   )54, 
            (flex_int16_t const   )54}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-55,        (flex_int16_t const   )-55,        (flex_int16_t const   )-55, 
            (flex_int16_t const   )-55,        (flex_int16_t const   )-55,        (flex_int16_t const   )-55,        (flex_int16_t const   )-55, 
            (flex_int16_t const   )-55,        (flex_int16_t const   )-55,        (flex_int16_t const   )-55,        (flex_int16_t const   )-55, 
            (flex_int16_t const   )-55,        (flex_int16_t const   )-55,        (flex_int16_t const   )-55,        (flex_int16_t const   )-55, 
            (flex_int16_t const   )-55}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-56,        (flex_int16_t const   )-56,        (flex_int16_t const   )-56, 
            (flex_int16_t const   )-56,        (flex_int16_t const   )-56,        (flex_int16_t const   )-56,        (flex_int16_t const   )-56, 
            (flex_int16_t const   )-56,        (flex_int16_t const   )-56,        (flex_int16_t const   )-56,        (flex_int16_t const   )60, 
            (flex_int16_t const   )57,        (flex_int16_t const   )57,        (flex_int16_t const   )-56,        (flex_int16_t const   )-56, 
            (flex_int16_t const   )-56}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-57,        (flex_int16_t const   )-57,        (flex_int16_t const   )-57, 
            (flex_int16_t const   )-57,        (flex_int16_t const   )-57,        (flex_int16_t const   )-57,        (flex_int16_t const   )-57, 
            (flex_int16_t const   )-57,        (flex_int16_t const   )-57,        (flex_int16_t const   )-57,        (flex_int16_t const   )57, 
            (flex_int16_t const   )57,        (flex_int16_t const   )57,        (flex_int16_t const   )-57,        (flex_int16_t const   )-57, 
            (flex_int16_t const   )-57}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-58,        (flex_int16_t const   )-58,        (flex_int16_t const   )-58, 
            (flex_int16_t const   )-58,        (flex_int16_t const   )-58,        (flex_int16_t const   )-58,        (flex_int16_t const   )-58, 
            (flex_int16_t const   )-58,        (flex_int16_t const   )-58,        (flex_int16_t const   )-58,        (flex_int16_t const   )-58, 
            (flex_int16_t const   )-58,        (flex_int16_t const   )-58,        (flex_int16_t const   )-58,        (flex_int16_t const   )-58, 
            (flex_int16_t const   )-58}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-59,        (flex_int16_t const   )-59,        (flex_int16_t const   )-59, 
            (flex_int16_t const   )-59,        (flex_int16_t const   )-59,        (flex_int16_t const   )-59,        (flex_int16_t const   )-59, 
            (flex_int16_t const   )-59,        (flex_int16_t const   )-59,        (flex_int16_t const   )-59,        (flex_int16_t const   )-59, 
            (flex_int16_t const   )-59,        (flex_int16_t const   )-59,        (flex_int16_t const   )-59,        (flex_int16_t const   )-59, 
            (flex_int16_t const   )-59}, 
   {        (flex_int16_t const   )11,        (flex_int16_t const   )-60,        (flex_int16_t const   )-60,        (flex_int16_t const   )-60, 
            (flex_int16_t const   )-60,        (flex_int16_t const   )-60,        (flex_int16_t const   )-60,        (flex_int16_t const   )-60, 
            (flex_int16_t const   )-60,        (flex_int16_t const   )-60,        (flex_int16_t const   )-60,        (flex_int16_t const   )57, 
            (flex_int16_t const   )57,        (flex_int16_t const   )57,        (flex_int16_t const   )-60,        (flex_int16_t const   )-60, 
            (flex_int16_t const   )-60}};
#line 689
static yy_state_type yy_get_previous_state(void) ;
#line 690
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state ) ;
#line 691
static int yy_get_next_buffer(void) ;
#line 692
static void yy_fatal_error(char const   *msg ) ;
#line 713 "scripts/kconfig/zconf.lex.c_shipped"
static flex_int16_t const   yy_accept[61]  = 
#line 713
  {      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )34, 
        (flex_int16_t const   )5,      (flex_int16_t const   )4,      (flex_int16_t const   )2,      (flex_int16_t const   )3, 
        (flex_int16_t const   )7,      (flex_int16_t const   )8,      (flex_int16_t const   )6,      (flex_int16_t const   )32, 
        (flex_int16_t const   )29,      (flex_int16_t const   )31,      (flex_int16_t const   )24,      (flex_int16_t const   )28, 
        (flex_int16_t const   )27,      (flex_int16_t const   )26,      (flex_int16_t const   )22,      (flex_int16_t const   )17, 
        (flex_int16_t const   )13,      (flex_int16_t const   )16,      (flex_int16_t const   )20,      (flex_int16_t const   )22, 
        (flex_int16_t const   )11,      (flex_int16_t const   )12,      (flex_int16_t const   )19,      (flex_int16_t const   )19, 
        (flex_int16_t const   )14,      (flex_int16_t const   )22,      (flex_int16_t const   )22,      (flex_int16_t const   )4, 
        (flex_int16_t const   )2,      (flex_int16_t const   )3,      (flex_int16_t const   )3,      (flex_int16_t const   )1, 
        (flex_int16_t const   )6,      (flex_int16_t const   )32,      (flex_int16_t const   )29,      (flex_int16_t const   )31, 
        (flex_int16_t const   )30,      (flex_int16_t const   )24,      (flex_int16_t const   )23,      (flex_int16_t const   )26, 
        (flex_int16_t const   )25,      (flex_int16_t const   )15,      (flex_int16_t const   )20,      (flex_int16_t const   )9, 
        (flex_int16_t const   )19,      (flex_int16_t const   )19,      (flex_int16_t const   )21,      (flex_int16_t const   )10, 
        (flex_int16_t const   )18};
#line 723 "scripts/kconfig/zconf.lex.c_shipped"
static flex_int32_t const   yy_ec[256]  = 
#line 723
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )2,      (flex_int32_t const   )3,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )2,      (flex_int32_t const   )4,      (flex_int32_t const   )5,      (flex_int32_t const   )6, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )7,      (flex_int32_t const   )8, 
        (flex_int32_t const   )9,      (flex_int32_t const   )10,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )11,      (flex_int32_t const   )12,      (flex_int32_t const   )12, 
        (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13, 
        (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13, 
        (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )14,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13, 
        (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13, 
        (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13, 
        (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13, 
        (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13, 
        (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13, 
        (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )1, 
        (flex_int32_t const   )15,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )13, 
        (flex_int32_t const   )1,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13, 
        (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13, 
        (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13, 
        (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13, 
        (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13, 
        (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13, 
        (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )1, 
        (flex_int32_t const   )16,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1};
#line 755
int zconf_flex_debug ;
#line 756 "scripts/kconfig/zconf.lex.c_shipped"
int zconf_flex_debug  =    0;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 497
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 783 "scripts/kconfig/zconf.lex.c_shipped"
static struct __anonstruct_current_pos_31 current_pos  ;
#line 788 "scripts/kconfig/zconf.lex.c_shipped"
static char *text  ;
#line 789 "scripts/kconfig/zconf.lex.c_shipped"
static int text_size  ;
#line 789 "scripts/kconfig/zconf.lex.c_shipped"
static int text_asize  ;
#line 796 "scripts/kconfig/zconf.lex.c_shipped"
struct buffer *current_buf  ;
#line 798 "scripts/kconfig/zconf.lex.c_shipped"
static int last_ts  ;
#line 798 "scripts/kconfig/zconf.lex.c_shipped"
static int first_ts  ;
#line 800
static void zconf_endhelp(void) ;
#line 801
static void zconf_endfile(void) ;
#line 803 "scripts/kconfig/zconf.lex.c_shipped"
static void new_string(void) 
{ 
  void *tmp ;

  {
  {
#line 805
  tmp = malloc((size_t )16);
#line 805
  text = (char *)tmp;
#line 806
  text_asize = 16;
#line 807
  text_size = 0;
#line 808
  *text = (char)0;
  }
#line 809
  return;
}
}
#line 811 "scripts/kconfig/zconf.lex.c_shipped"
static void append_string(char const   *str , int size ) 
{ 
  int new_size ;
  void *tmp ;

  {
#line 813
  new_size = (text_size + size) + 1;
#line 814
  if (new_size > text_asize) {
    {
#line 815
    new_size += 15;
#line 816
    new_size &= -16;
#line 817
    tmp = realloc((void *)text, (size_t )new_size);
#line 817
    text = (char *)tmp;
#line 818
    text_asize = new_size;
    }
  }
  {
#line 820
  memcpy((void */* __restrict  */)(text + text_size), (void const   */* __restrict  */)str,
         (size_t )size);
#line 821
  text_size += size;
#line 822
  *(text + text_size) = (char)0;
  }
#line 823
  return;
}
}
#line 825 "scripts/kconfig/zconf.lex.c_shipped"
static void alloc_string(char const   *str , int size ) 
{ 
  void *tmp ;

  {
  {
#line 827
  tmp = malloc((size_t )(size + 1));
#line 827
  text = (char *)tmp;
#line 828
  memcpy((void */* __restrict  */)text, (void const   */* __restrict  */)str, (size_t )size);
#line 829
  *(text + size) = (char)0;
  }
#line 830
  return;
}
}
#line 850
static int yy_init_globals(void) ;
#line 855
int zconflex_destroy(void) ;
#line 857
int zconfget_debug(void) ;
#line 859
void zconfset_debug(int bdebug ) ;
#line 865
FILE *zconfget_in(void) ;
#line 867
void zconfset_in(FILE *in_str ) ;
#line 869
FILE *zconfget_out(void) ;
#line 871
void zconfset_out(FILE *out_str ) ;
#line 873
int zconfget_leng(void) ;
#line 875
char *zconfget_text(void) ;
#line 877
int zconfget_lineno(void) ;
#line 879
void zconfset_lineno(int line_number ) ;
#line 893
static void yyunput(int c , char *yy_bp ) ;
#line 994 "scripts/kconfig/zconf.lex.c_shipped"
int zconflex(void) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register char *yy_bp ;
  register int yy_act ;
  int str ;
  int ts ;
  int i ;
  YY_BUFFER_STATE tmp ;
  struct kconf_id  const  *id ;
  struct kconf_id  const __attribute__((__gnu_inline__)) *tmp___0 ;
  struct kconf_id  const  *id___0 ;
  struct kconf_id  const __attribute__((__gnu_inline__)) *tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  int yy_amount_of_matched_text ;
  yy_state_type yy_next_state ;
  int tmp___4 ;

  {
#line 1000
  str = 0;
#line 1003
  if (! yy_init) {
#line 1005
    yy_init = 1;
#line 1011
    if (! yy_start) {
#line 1012
      yy_start = 1;
    }
#line 1014
    if (! zconfin) {
#line 1015
      zconfin = stdin;
    }
#line 1017
    if (! zconfout) {
#line 1018
      zconfout = stdout;
    }
#line 1020
    if (yy_buffer_stack) {
#line 1020
      tmp = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
#line 1020
      tmp = (YY_BUFFER_STATE )((void *)0);
    }
#line 1020
    if (! tmp) {
      {
#line 1021
      zconfensure_buffer_stack();
#line 1022
      *(yy_buffer_stack + yy_buffer_stack_top) = zconf_create_buffer(zconfin, 16384);
      }
    }
    {
#line 1026
    zconf_load_buffer_state();
    }
  }
  {
#line 1029
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1031
    yy_cp = yy_c_buf_p;
#line 1034
    *yy_cp = yy_hold_char;
#line 1039
    yy_bp = yy_cp;
#line 1041
    yy_current_state = yy_start;
    yy_match: 
    {
#line 1043
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1043
      yy_current_state = (yy_state_type )yy_nxt[yy_current_state][yy_ec[(unsigned int )((unsigned char )*yy_cp)]];
#line 1043
      if (! (yy_current_state > 0)) {
#line 1043
        goto while_break___0;
      }
#line 1044
      yy_cp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1046
    yy_current_state = - yy_current_state;
    yy_find_action: 
#line 1049
    yy_act = (int )yy_accept[yy_current_state];
#line 1051
    zconftext = yy_bp;
#line 1051
    zconfleng = (int )((size_t )(yy_cp - yy_bp));
#line 1051
    yy_hold_char = *yy_cp;
#line 1051
    *yy_cp = (char )'\000';
#line 1051
    yy_c_buf_p = yy_cp;
    do_action: 
    {
#line 1059
    if (yy_act == 2) {
#line 1059
      goto case_2;
    }
#line 1059
    if (yy_act == 1) {
#line 1059
      goto case_2;
    }
#line 1067
    if (yy_act == 3) {
#line 1067
      goto case_3;
    }
#line 1071
    if (yy_act == 4) {
#line 1071
      goto case_4;
    }
#line 1077
    if (yy_act == 5) {
#line 1077
      goto case_5;
    }
#line 1085
    if (yy_act == 6) {
#line 1085
      goto case_6;
    }
#line 1101
    if (yy_act == 7) {
#line 1101
      goto case_7;
    }
#line 1105
    if (yy_act == 8) {
#line 1105
      goto case_8;
    }
#line 1115
    if (yy_act == 9) {
#line 1115
      goto case_9;
    }
#line 1119
    if (yy_act == 10) {
#line 1119
      goto case_10;
    }
#line 1123
    if (yy_act == 11) {
#line 1123
      goto case_11;
    }
#line 1127
    if (yy_act == 12) {
#line 1127
      goto case_12;
    }
#line 1131
    if (yy_act == 13) {
#line 1131
      goto case_13;
    }
#line 1135
    if (yy_act == 14) {
#line 1135
      goto case_14;
    }
#line 1139
    if (yy_act == 15) {
#line 1139
      goto case_15;
    }
#line 1143
    if (yy_act == 16) {
#line 1143
      goto case_16;
    }
#line 1151
    if (yy_act == 17) {
#line 1151
      goto case_17;
    }
#line 1156
    if (yy_act == 18) {
#line 1156
      goto case_18;
    }
#line 1160
    if (yy_act == 19) {
#line 1160
      goto case_19;
    }
#line 1173
    if (yy_act == 20) {
#line 1173
      goto case_20;
    }
#line 1177
    if (yy_act == 21) {
#line 1177
      goto case_21;
    }
#line 1182
    if (yy_act == 22) {
#line 1182
      goto case_22;
    }
#line 1186
    if (yy_act == 39) {
#line 1186
      goto case_39;
    }
#line 1192
    if (yy_act == 23) {
#line 1192
      goto case_23;
    }
#line 1204
    if (yy_act == 24) {
#line 1204
      goto case_24;
    }
#line 1210
    if (yy_act == 25) {
#line 1210
      goto case_25;
    }
#line 1222
    if (yy_act == 26) {
#line 1222
      goto case_26;
    }
#line 1228
    if (yy_act == 27) {
#line 1228
      goto case_27;
    }
#line 1239
    if (yy_act == 28) {
#line 1239
      goto case_28;
    }
#line 1249
    if (yy_act == 38) {
#line 1249
      goto case_38;
    }
#line 1255
    if (yy_act == 29) {
#line 1255
      goto case_29;
    }
#line 1280
    if (yy_act == 30) {
#line 1280
      goto case_30;
    }
#line 1292
    if (yy_act == 31) {
#line 1292
      goto case_31;
    }
#line 1300
    if (yy_act == 32) {
#line 1300
      goto case_32;
    }
#line 1313
    if (yy_act == 37) {
#line 1313
      goto case_37;
    }
#line 1321
    if (yy_act == 36) {
#line 1321
      goto case_36;
    }
#line 1321
    if (yy_act == 35) {
#line 1321
      goto case_36;
    }
#line 1331
    if (yy_act == 33) {
#line 1331
      goto case_33;
    }
#line 1336
    if (yy_act == 34) {
#line 1336
      goto case_34;
    }
#line 1458
    goto switch_default;
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
#line 1063
    (current_file->lineno) ++;
#line 1064
    return (286);
#line 1066
    goto switch_break;
    case_3: /* CIL Label */ 
#line 1070
    goto switch_break;
    case_4: /* CIL Label */ 
#line 1074
    yy_start = 3;
#line 1076
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 1080
    yyunput((int )*(zconftext + 0), zconftext);
#line 1081
    yy_start = 3;
    }
#line 1083
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 1088
    tmp___0 = kconf_id_lookup((char const   *)zconftext, (unsigned int )zconfleng);
#line 1088
    id = (struct kconf_id  const  *)tmp___0;
#line 1089
    yy_start = 9;
#line 1090
    current_pos.file = current_file;
#line 1091
    current_pos.lineno = current_file->lineno;
    }
#line 1092
    if (id) {
#line 1092
      if (id->flags & 1U) {
#line 1093
        zconflval.id = id;
#line 1094
        return ((int )id->token);
      }
    }
    {
#line 1096
    alloc_string((char const   *)zconftext, zconfleng);
#line 1097
    zconflval.string = text;
    }
#line 1098
    return (281);
#line 1100
    goto switch_break;
    case_7: /* CIL Label */ 
#line 1104
    goto switch_break;
    case_8: /* CIL Label */ 
#line 1109
    yy_start = 1;
#line 1110
    (current_file->lineno) ++;
#line 1111
    return (286);
#line 1113
    goto switch_break;
    case_9: /* CIL Label */ 
#line 1117
    return (288);
#line 1118
    goto switch_break;
    case_10: /* CIL Label */ 
#line 1121
    return (287);
#line 1122
    goto switch_break;
    case_11: /* CIL Label */ 
#line 1125
    return (285);
#line 1126
    goto switch_break;
    case_12: /* CIL Label */ 
#line 1129
    return (284);
#line 1130
    goto switch_break;
    case_13: /* CIL Label */ 
#line 1133
    return (290);
#line 1134
    goto switch_break;
    case_14: /* CIL Label */ 
#line 1137
    return (289);
#line 1138
    goto switch_break;
    case_15: /* CIL Label */ 
#line 1141
    return (283);
#line 1142
    goto switch_break;
    case_16: /* CIL Label */ 
    {
#line 1146
    str = (int )*(zconftext + 0);
#line 1147
    new_string();
#line 1148
    yy_start = 7;
    }
#line 1150
    goto switch_break;
    case_17: /* CIL Label */ 
#line 1154
    yy_start = 1;
#line 1154
    (current_file->lineno) ++;
#line 1154
    return (286);
#line 1155
    goto switch_break;
    case_18: /* CIL Label */ 
#line 1159
    goto switch_break;
    case_19: /* CIL Label */ 
    {
#line 1163
    tmp___1 = kconf_id_lookup((char const   *)zconftext, (unsigned int )zconfleng);
#line 1163
    id___0 = (struct kconf_id  const  *)tmp___1;
    }
#line 1164
    if (id___0) {
#line 1164
      if (id___0->flags & 2U) {
#line 1165
        zconflval.id = id___0;
#line 1166
        return ((int )id___0->token);
      }
    }
    {
#line 1168
    alloc_string((char const   *)zconftext, zconfleng);
#line 1169
    zconflval.string = text;
    }
#line 1170
    return (281);
#line 1172
    goto switch_break;
    case_20: /* CIL Label */ 
#line 1176
    goto switch_break;
    case_21: /* CIL Label */ 
#line 1180
    (current_file->lineno) ++;
#line 1181
    goto switch_break;
    case_22: /* CIL Label */ 
#line 1185
    goto switch_break;
    case_39: /* CIL Label */ 
#line 1188
    yy_start = 1;
#line 1190
    goto switch_break;
    case_23: /* CIL Label */ 
    {
#line 1194
    *yy_cp = yy_hold_char;
#line 1195
    yy_cp --;
#line 1195
    yy_c_buf_p = yy_cp;
#line 1196
    zconftext = yy_bp;
#line 1196
    zconfleng = (int )((size_t )(yy_cp - yy_bp));
#line 1196
    yy_hold_char = *yy_cp;
#line 1196
    *yy_cp = (char )'\000';
#line 1196
    yy_c_buf_p = yy_cp;
#line 1199
    append_string((char const   *)zconftext, zconfleng);
#line 1200
    zconflval.string = text;
    }
#line 1201
    return (282);
#line 1203
    goto switch_break;
    case_24: /* CIL Label */ 
    {
#line 1207
    append_string((char const   *)zconftext, zconfleng);
    }
#line 1209
    goto switch_break;
    case_25: /* CIL Label */ 
    {
#line 1212
    *yy_cp = yy_hold_char;
#line 1213
    yy_cp --;
#line 1213
    yy_c_buf_p = yy_cp;
#line 1214
    zconftext = yy_bp;
#line 1214
    zconfleng = (int )((size_t )(yy_cp - yy_bp));
#line 1214
    yy_hold_char = *yy_cp;
#line 1214
    *yy_cp = (char )'\000';
#line 1214
    yy_c_buf_p = yy_cp;
#line 1217
    append_string((char const   *)(zconftext + 1), zconfleng - 1);
#line 1218
    zconflval.string = text;
    }
#line 1219
    return (282);
#line 1221
    goto switch_break;
    case_26: /* CIL Label */ 
    {
#line 1225
    append_string((char const   *)(zconftext + 1), zconfleng - 1);
    }
#line 1227
    goto switch_break;
    case_27: /* CIL Label */ 
#line 1231
    if (str == (int )*(zconftext + 0)) {
#line 1232
      yy_start = 9;
#line 1233
      zconflval.string = text;
#line 1234
      return (282);
    } else {
      {
#line 1236
      append_string((char const   *)zconftext, 1);
      }
    }
#line 1238
    goto switch_break;
    case_28: /* CIL Label */ 
    {
#line 1243
    tmp___2 = zconf_lineno();
#line 1243
    tmp___3 = zconf_curname();
#line 1243
    printf((char const   */* __restrict  */)"%s:%d:warning: multi-line strings not supported\n",
           tmp___3, tmp___2);
#line 1244
    (current_file->lineno) ++;
#line 1245
    yy_start = 1;
    }
#line 1246
    return (286);
#line 1248
    goto switch_break;
    case_38: /* CIL Label */ 
#line 1251
    yy_start = 1;
#line 1253
    goto switch_break;
    case_29: /* CIL Label */ 
#line 1258
    ts = 0;
#line 1259
    i = 0;
    {
#line 1259
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1259
      if (! (i < zconfleng)) {
#line 1259
        goto while_break___1;
      }
#line 1260
      if ((int )*(zconftext + i) == 9) {
#line 1261
        ts = (ts & -8) + 8;
      } else {
#line 1263
        ts ++;
      }
#line 1259
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1265
    last_ts = ts;
#line 1266
    if (first_ts) {
#line 1267
      if (ts < first_ts) {
        {
#line 1268
        zconf_endhelp();
        }
#line 1269
        return (268);
      }
#line 1271
      ts -= first_ts;
      {
#line 1272
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1272
        if (! (ts > 8)) {
#line 1272
          goto while_break___2;
        }
        {
#line 1273
        append_string("        ", 8);
#line 1274
        ts -= 8;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 1276
      append_string("        ", ts);
      }
    }
#line 1279
    goto switch_break;
    case_30: /* CIL Label */ 
    {
#line 1282
    *yy_cp = yy_hold_char;
#line 1283
    yy_cp --;
#line 1283
    yy_c_buf_p = yy_cp;
#line 1284
    zconftext = yy_bp;
#line 1284
    zconfleng = (int )((size_t )(yy_cp - yy_bp));
#line 1284
    yy_hold_char = *yy_cp;
#line 1284
    *yy_cp = (char )'\000';
#line 1284
    yy_c_buf_p = yy_cp;
#line 1287
    (current_file->lineno) ++;
#line 1288
    zconf_endhelp();
    }
#line 1289
    return (268);
#line 1291
    goto switch_break;
    case_31: /* CIL Label */ 
    {
#line 1296
    (current_file->lineno) ++;
#line 1297
    append_string("\n", 1);
    }
#line 1299
    goto switch_break;
    case_32: /* CIL Label */ 
    {
#line 1303
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1303
      if (! zconfleng) {
#line 1303
        goto while_break___3;
      }
#line 1304
      if ((int )*(zconftext + (zconfleng - 1)) != 32) {
#line 1304
        if ((int )*(zconftext + (zconfleng - 1)) != 9) {
#line 1305
          goto while_break___3;
        }
      }
#line 1306
      zconfleng --;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 1308
    append_string((char const   *)zconftext, zconfleng);
    }
#line 1309
    if (! first_ts) {
#line 1310
      first_ts = last_ts;
    }
#line 1312
    goto switch_break;
    case_37: /* CIL Label */ 
    {
#line 1315
    zconf_endhelp();
    }
#line 1316
    return (268);
#line 1318
    goto switch_break;
    case_36: /* CIL Label */ 
    case_35: /* CIL Label */ 
#line 1323
    if (current_file) {
      {
#line 1324
      zconf_endfile();
      }
#line 1325
      return (286);
    }
    {
#line 1327
    fclose(zconfin);
    }
#line 1328
    return (0);
#line 1330
    goto switch_break;
    case_33: /* CIL Label */ 
    {
#line 1333
    yy_fatal_error("flex scanner jammed");
    }
#line 1334
    goto switch_break;
    case_34: /* CIL Label */ 
#line 1339
    yy_amount_of_matched_text = (int )(yy_cp - zconftext) - 1;
#line 1342
    *yy_cp = yy_hold_char;
#line 1345
    if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status == 0) {
#line 1356
      yy_n_chars = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars;
#line 1357
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_input_file = zconfin;
#line 1358
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status = 1;
    }
#line 1368
    if ((unsigned long )yy_c_buf_p <= (unsigned long )((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + yy_n_chars)) {
      {
#line 1372
      yy_c_buf_p = zconftext + yy_amount_of_matched_text;
#line 1374
      yy_current_state = yy_get_previous_state();
#line 1385
      yy_next_state = yy_try_NUL_trans(yy_current_state);
#line 1387
      yy_bp = zconftext + 0;
      }
#line 1389
      if (yy_next_state) {
#line 1392
        yy_c_buf_p ++;
#line 1392
        yy_cp = yy_c_buf_p;
#line 1393
        yy_current_state = yy_next_state;
#line 1394
        goto yy_match;
      } else {
#line 1399
        yy_cp = yy_c_buf_p;
#line 1400
        goto yy_find_action;
      }
    } else {
      {
#line 1404
      tmp___4 = yy_get_next_buffer();
      }
      {
#line 1406
      if (tmp___4 == 1) {
#line 1406
        goto case_1___0;
      }
#line 1435
      if (tmp___4 == 0) {
#line 1435
        goto case_0;
      }
#line 1445
      if (tmp___4 == 2) {
#line 1445
        goto case_2___0;
      }
#line 1404
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
#line 1408
      yy_did_buffer_switch_on_eof = 0;
#line 1421
      yy_c_buf_p = zconftext + 0;
#line 1423
      yy_act = (34 + (yy_start - 1) / 2) + 1;
#line 1424
      goto do_action;
#line 1432
      goto switch_break___0;
      case_0: /* CIL Label */ 
      {
#line 1436
      yy_c_buf_p = zconftext + yy_amount_of_matched_text;
#line 1439
      yy_current_state = yy_get_previous_state();
#line 1441
      yy_cp = yy_c_buf_p;
#line 1442
      yy_bp = zconftext + 0;
      }
#line 1443
      goto yy_match;
      case_2___0: /* CIL Label */ 
      {
#line 1446
      yy_c_buf_p = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + yy_n_chars;
#line 1449
      yy_current_state = yy_get_previous_state();
#line 1451
      yy_cp = yy_c_buf_p;
#line 1452
      yy_bp = zconftext + 0;
      }
#line 1453
      goto yy_find_action;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 1455
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1459
    yy_fatal_error("fatal flex scanner internal error--no action found");
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1472 "scripts/kconfig/zconf.lex.c_shipped"
static int yy_get_next_buffer(void) 
{ 
  register char *dest ;
  register char *source ;
  register int number_to_move ;
  register int i ;
  int ret_val ;
  char *tmp ;
  char *tmp___0 ;
  int num_to_read ;
  YY_BUFFER_STATE b ;
  YY_BUFFER_STATE tmp___1 ;
  int yy_c_buf_p_offset ;
  int new_size ;
  void *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  ssize_t tmp___7 ;
  yy_size_t new_size___0 ;
  void *tmp___8 ;

  {
#line 1474
  dest = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf;
#line 1475
  source = zconftext;
#line 1479
  if ((unsigned long )yy_c_buf_p > (unsigned long )((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + (yy_n_chars + 1))) {
    {
#line 1480
    yy_fatal_error("fatal flex scanner internal error--end of buffer missed");
    }
  }
#line 1483
  if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_fill_buffer == 0) {
#line 1485
    if (yy_c_buf_p - zconftext == 1L) {
#line 1490
      return (1);
    } else {
#line 1498
      return (2);
    }
  }
#line 1505
  number_to_move = (int )(yy_c_buf_p - zconftext) - 1;
#line 1507
  i = 0;
  {
#line 1507
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1507
    if (! (i < number_to_move)) {
#line 1507
      goto while_break;
    }
#line 1508
    tmp = dest;
#line 1508
    dest ++;
#line 1508
    tmp___0 = source;
#line 1508
    source ++;
#line 1508
    *tmp = *tmp___0;
#line 1507
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1510
  if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status == 2) {
#line 1514
    yy_n_chars = 0;
#line 1514
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  } else {
#line 1518
    num_to_read = (int )(((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size - (yy_size_t )number_to_move) - 1UL);
    {
#line 1521
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1521
      if (! (num_to_read <= 0)) {
#line 1521
        goto while_break___0;
      }
#line 1525
      if (yy_buffer_stack) {
#line 1525
        tmp___1 = *(yy_buffer_stack + yy_buffer_stack_top);
      } else {
#line 1525
        tmp___1 = (YY_BUFFER_STATE )((void *)0);
      }
#line 1525
      b = tmp___1;
#line 1527
      yy_c_buf_p_offset = (int )(yy_c_buf_p - b->yy_ch_buf);
#line 1530
      if (b->yy_is_our_buffer) {
#line 1532
        new_size = (int )(b->yy_buf_size * 2UL);
#line 1534
        if (new_size <= 0) {
#line 1535
          b->yy_buf_size += b->yy_buf_size / 8UL;
        } else {
#line 1537
          b->yy_buf_size *= 2UL;
        }
        {
#line 1539
        tmp___2 = zconfrealloc((void *)b->yy_ch_buf, b->yy_buf_size + 2UL);
#line 1539
        b->yy_ch_buf = (char *)tmp___2;
        }
      } else {
#line 1545
        b->yy_ch_buf = (char *)0;
      }
#line 1547
      if (! b->yy_ch_buf) {
        {
#line 1548
        yy_fatal_error("fatal error - scanner input buffer overflow");
        }
      }
#line 1551
      yy_c_buf_p = b->yy_ch_buf + yy_c_buf_p_offset;
#line 1553
      num_to_read = (int )(((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size - (yy_size_t )number_to_move) - 1UL);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1558
    if (num_to_read > 8192) {
#line 1559
      num_to_read = 8192;
    }
    {
#line 1562
    tmp___3 = __errno_location();
#line 1562
    *tmp___3 = 0;
    }
    {
#line 1562
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1562
      tmp___6 = fileno(zconfin);
#line 1562
      tmp___7 = read(tmp___6, (void *)((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + number_to_move),
                     (size_t )num_to_read);
#line 1562
      yy_n_chars = (int )tmp___7;
      }
#line 1562
      if (! (yy_n_chars < 0)) {
#line 1562
        goto while_break___1;
      }
      {
#line 1562
      tmp___4 = __errno_location();
      }
#line 1562
      if (*tmp___4 != 4) {
        {
#line 1562
        yy_fatal_error("input in flex scanner failed");
        }
#line 1562
        goto while_break___1;
      }
      {
#line 1562
      tmp___5 = __errno_location();
#line 1562
      *tmp___5 = 0;
#line 1562
      clearerr(zconfin);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1565
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  }
#line 1568
  if (yy_n_chars == 0) {
#line 1570
    if (number_to_move == 0) {
      {
#line 1572
      ret_val = 1;
#line 1573
      zconfrestart(zconfin);
      }
    } else {
#line 1578
      ret_val = 2;
#line 1579
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status = 2;
    }
  } else {
#line 1585
    ret_val = 0;
  }
#line 1587
  if ((yy_size_t )(yy_n_chars + number_to_move) > (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size) {
    {
#line 1589
    new_size___0 = (yy_size_t )((yy_n_chars + number_to_move) + (yy_n_chars >> 1));
#line 1590
    tmp___8 = zconfrealloc((void *)(*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf,
                           new_size___0);
#line 1590
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf = (char *)tmp___8;
    }
#line 1591
    if (! (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf) {
      {
#line 1592
      yy_fatal_error("out of dynamic memory in yy_get_next_buffer()");
      }
    }
  }
#line 1595
  yy_n_chars += number_to_move;
#line 1596
  *((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + yy_n_chars) = (char)0;
#line 1597
  *((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + (yy_n_chars + 1)) = (char)0;
#line 1599
  zconftext = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + 0;
#line 1601
  return (ret_val);
}
}
#line 1606 "scripts/kconfig/zconf.lex.c_shipped"
static yy_state_type yy_get_previous_state(void) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  flex_int32_t tmp ;

  {
#line 1611
  yy_current_state = yy_start;
#line 1613
  yy_cp = zconftext + 0;
  {
#line 1613
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1613
    if (! ((unsigned long )yy_cp < (unsigned long )yy_c_buf_p)) {
#line 1613
      goto while_break;
    }
#line 1615
    if (*yy_cp) {
#line 1615
      tmp = yy_ec[(unsigned int )((unsigned char )*yy_cp)];
    } else {
#line 1615
      tmp = (flex_int32_t const   )1;
    }
#line 1615
    yy_current_state = (yy_state_type )yy_nxt[yy_current_state][tmp];
#line 1613
    yy_cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1618
  return (yy_current_state);
}
}
#line 1626 "scripts/kconfig/zconf.lex.c_shipped"
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state ) 
{ 
  register int yy_is_jam ;
  int tmp ;

  {
#line 1630
  yy_current_state = (yy_state_type )yy_nxt[yy_current_state][1];
#line 1631
  yy_is_jam = yy_current_state <= 0;
#line 1633
  if (yy_is_jam) {
#line 1633
    tmp = 0;
  } else {
#line 1633
    tmp = yy_current_state;
  }
#line 1633
  return (tmp);
}
}
#line 1636 "scripts/kconfig/zconf.lex.c_shipped"
static void yyunput(int c , char *yy_bp ) 
{ 
  register char *yy_cp ;
  register int number_to_move ;
  register char *dest ;
  register char *source ;

  {
#line 1640
  yy_cp = yy_c_buf_p;
#line 1643
  *yy_cp = yy_hold_char;
#line 1645
  if ((unsigned long )yy_cp < (unsigned long )((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + 2)) {
#line 1648
    number_to_move = yy_n_chars + 2;
#line 1649
    dest = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size + 2UL);
#line 1651
    source = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + number_to_move;
    {
#line 1654
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1654
      if (! ((unsigned long )source > (unsigned long )(*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf)) {
#line 1654
        goto while_break;
      }
#line 1655
      dest --;
#line 1655
      source --;
#line 1655
      *dest = *source;
    }
    while_break: /* CIL Label */ ;
    }
#line 1657
    yy_cp += (int )(dest - source);
#line 1658
    yy_bp += (int )(dest - source);
#line 1659
    yy_n_chars = (int )(*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size;
#line 1659
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
#line 1662
    if ((unsigned long )yy_cp < (unsigned long )((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + 2)) {
      {
#line 1663
      yy_fatal_error("flex scanner push-back overflow");
      }
    }
  }
#line 1666
  yy_cp --;
#line 1666
  *yy_cp = (char )c;
#line 1668
  zconftext = yy_bp;
#line 1669
  yy_hold_char = *yy_cp;
#line 1670
  yy_c_buf_p = yy_cp;
#line 1671
  return;
}
}
#line 1752 "scripts/kconfig/zconf.lex.c_shipped"
void zconfrestart(FILE *input_file ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 1755
  if (yy_buffer_stack) {
#line 1755
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1755
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1755
  if (! tmp) {
    {
#line 1756
    zconfensure_buffer_stack();
#line 1757
    *(yy_buffer_stack + yy_buffer_stack_top) = zconf_create_buffer(zconfin, 16384);
    }
  }
#line 1761
  if (yy_buffer_stack) {
#line 1761
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1761
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 1761
  zconf_init_buffer(tmp___0, input_file);
#line 1762
  zconf_load_buffer_state();
  }
#line 1763
  return;
}
}
#line 1769 "scripts/kconfig/zconf.lex.c_shipped"
void zconf_switch_to_buffer(YY_BUFFER_STATE new_buffer ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 1777
  zconfensure_buffer_stack();
  }
#line 1778
  if (yy_buffer_stack) {
#line 1778
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1778
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1778
  if ((unsigned long )tmp == (unsigned long )new_buffer) {
#line 1779
    return;
  }
#line 1781
  if (yy_buffer_stack) {
#line 1781
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1781
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1781
  if (tmp___0) {
#line 1784
    *yy_c_buf_p = yy_hold_char;
#line 1785
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_pos = yy_c_buf_p;
#line 1786
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  }
  {
#line 1789
  *(yy_buffer_stack + yy_buffer_stack_top) = new_buffer;
#line 1790
  zconf_load_buffer_state();
#line 1797
  yy_did_buffer_switch_on_eof = 1;
  }
#line 1798
  return;
}
}
#line 1800 "scripts/kconfig/zconf.lex.c_shipped"
static void zconf_load_buffer_state(void) 
{ 


  {
#line 1802
  yy_n_chars = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars;
#line 1803
  yy_c_buf_p = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_pos;
#line 1803
  zconftext = yy_c_buf_p;
#line 1804
  zconfin = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_input_file;
#line 1805
  yy_hold_char = *yy_c_buf_p;
#line 1806
  return;
}
}
#line 1814 "scripts/kconfig/zconf.lex.c_shipped"
YY_BUFFER_STATE zconf_create_buffer(FILE *file , int size ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 1818
  tmp = zconfalloc(sizeof(struct yy_buffer_state ));
#line 1818
  b = (YY_BUFFER_STATE )tmp;
  }
#line 1819
  if (! b) {
    {
#line 1820
    yy_fatal_error("out of dynamic memory in zconf_create_buffer()");
    }
  }
  {
#line 1822
  b->yy_buf_size = (yy_size_t )size;
#line 1827
  tmp___0 = zconfalloc(b->yy_buf_size + 2UL);
#line 1827
  b->yy_ch_buf = (char *)tmp___0;
  }
#line 1828
  if (! b->yy_ch_buf) {
    {
#line 1829
    yy_fatal_error("out of dynamic memory in zconf_create_buffer()");
    }
  }
  {
#line 1831
  b->yy_is_our_buffer = 1;
#line 1833
  zconf_init_buffer(b, file);
  }
#line 1835
  return (b);
}
}
#line 1842 "scripts/kconfig/zconf.lex.c_shipped"
void zconf_delete_buffer(YY_BUFFER_STATE b ) 
{ 
  YY_BUFFER_STATE tmp ;

  {
#line 1845
  if (! b) {
#line 1846
    return;
  }
#line 1848
  if (yy_buffer_stack) {
#line 1848
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1848
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1848
  if ((unsigned long )b == (unsigned long )tmp) {
#line 1849
    *(yy_buffer_stack + yy_buffer_stack_top) = (YY_BUFFER_STATE )0;
  }
#line 1851
  if (b->yy_is_our_buffer) {
    {
#line 1852
    zconffree((void *)b->yy_ch_buf);
    }
  }
  {
#line 1854
  zconffree((void *)b);
  }
#line 1855
  return;
}
}
#line 1861 "scripts/kconfig/zconf.lex.c_shipped"
static void zconf_init_buffer(YY_BUFFER_STATE b , FILE *file ) 
{ 
  int oerrno ;
  int *tmp ;
  YY_BUFFER_STATE tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 1864
  tmp = __errno_location();
#line 1864
  oerrno = *tmp;
#line 1866
  zconf_flush_buffer(b);
#line 1868
  b->yy_input_file = file;
#line 1869
  b->yy_fill_buffer = 1;
  }
#line 1875
  if (yy_buffer_stack) {
#line 1875
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1875
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1875
  if ((unsigned long )b != (unsigned long )tmp___0) {
#line 1876
    b->yy_bs_lineno = 1;
#line 1877
    b->yy_bs_column = 0;
  }
  {
#line 1880
  b->yy_is_interactive = 0;
#line 1882
  tmp___1 = __errno_location();
#line 1882
  *tmp___1 = oerrno;
  }
#line 1883
  return;
}
}
#line 1889 "scripts/kconfig/zconf.lex.c_shipped"
void zconf_flush_buffer(YY_BUFFER_STATE b ) 
{ 
  YY_BUFFER_STATE tmp ;

  {
#line 1891
  if (! b) {
#line 1892
    return;
  }
#line 1894
  b->yy_n_chars = 0;
#line 1900
  *(b->yy_ch_buf + 0) = (char)0;
#line 1901
  *(b->yy_ch_buf + 1) = (char)0;
#line 1903
  b->yy_buf_pos = b->yy_ch_buf + 0;
#line 1905
  b->yy_at_bol = 1;
#line 1906
  b->yy_buffer_status = 0;
#line 1908
  if (yy_buffer_stack) {
#line 1908
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1908
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1908
  if ((unsigned long )b == (unsigned long )tmp) {
    {
#line 1909
    zconf_load_buffer_state();
    }
  }
#line 1910
  return;
}
}
#line 1918 "scripts/kconfig/zconf.lex.c_shipped"
void zconfpush_buffer_state(YY_BUFFER_STATE new_buffer ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 1920
  if ((unsigned long )new_buffer == (unsigned long )((void *)0)) {
#line 1921
    return;
  }
  {
#line 1923
  zconfensure_buffer_stack();
  }
#line 1926
  if (yy_buffer_stack) {
#line 1926
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1926
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1926
  if (tmp) {
#line 1929
    *yy_c_buf_p = yy_hold_char;
#line 1930
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_pos = yy_c_buf_p;
#line 1931
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  }
#line 1935
  if (yy_buffer_stack) {
#line 1935
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1935
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1935
  if (tmp___0) {
#line 1936
    yy_buffer_stack_top ++;
  }
  {
#line 1937
  *(yy_buffer_stack + yy_buffer_stack_top) = new_buffer;
#line 1940
  zconf_load_buffer_state();
#line 1941
  yy_did_buffer_switch_on_eof = 1;
  }
#line 1942
  return;
}
}
#line 1948 "scripts/kconfig/zconf.lex.c_shipped"
void zconfpop_buffer_state(void) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;
  YY_BUFFER_STATE tmp___1 ;

  {
#line 1950
  if (yy_buffer_stack) {
#line 1950
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1950
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1950
  if (! tmp) {
#line 1951
    return;
  }
#line 1953
  if (yy_buffer_stack) {
#line 1953
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1953
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 1953
  zconf_delete_buffer(tmp___0);
#line 1954
  *(yy_buffer_stack + yy_buffer_stack_top) = (YY_BUFFER_STATE )((void *)0);
  }
#line 1955
  if (yy_buffer_stack_top > 0UL) {
#line 1956
    yy_buffer_stack_top --;
  }
#line 1958
  if (yy_buffer_stack) {
#line 1958
    tmp___1 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1958
    tmp___1 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1958
  if (tmp___1) {
    {
#line 1959
    zconf_load_buffer_state();
#line 1960
    yy_did_buffer_switch_on_eof = 1;
    }
  }
#line 1962
  return;
}
}
#line 1967 "scripts/kconfig/zconf.lex.c_shipped"
static void zconfensure_buffer_stack(void) 
{ 
  int num_to_alloc ;
  void *tmp ;
  int grow_size ;
  void *tmp___0 ;

  {
#line 1971
  if (! yy_buffer_stack) {
    {
#line 1977
    num_to_alloc = 1;
#line 1978
    tmp = zconfalloc((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *));
#line 1978
    yy_buffer_stack = (struct yy_buffer_state **)tmp;
    }
#line 1981
    if (! yy_buffer_stack) {
      {
#line 1982
      yy_fatal_error("out of dynamic memory in zconfensure_buffer_stack()");
      }
    }
    {
#line 1984
    memset((void *)yy_buffer_stack, 0, (unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *));
#line 1986
    yy_buffer_stack_max = (size_t )num_to_alloc;
#line 1987
    yy_buffer_stack_top = (size_t )0;
    }
#line 1988
    return;
  }
#line 1991
  if (yy_buffer_stack_top >= yy_buffer_stack_max - 1UL) {
    {
#line 1994
    grow_size = 8;
#line 1996
    num_to_alloc = (int )(yy_buffer_stack_max + (size_t )grow_size);
#line 1997
    tmp___0 = zconfrealloc((void *)yy_buffer_stack, (unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *));
#line 1997
    yy_buffer_stack = (struct yy_buffer_state **)tmp___0;
    }
#line 2001
    if (! yy_buffer_stack) {
      {
#line 2002
      yy_fatal_error("out of dynamic memory in zconfensure_buffer_stack()");
      }
    }
    {
#line 2005
    memset((void *)(yy_buffer_stack + yy_buffer_stack_max), 0, (unsigned long )grow_size * sizeof(struct yy_buffer_state *));
#line 2006
    yy_buffer_stack_max = (size_t )num_to_alloc;
    }
  }
#line 2008
  return;
}
}
#line 2016 "scripts/kconfig/zconf.lex.c_shipped"
YY_BUFFER_STATE zconf_scan_buffer(char *base , yy_size_t size ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  char *tmp___0 ;

  {
#line 2020
  if (size < 2UL) {
#line 2024
    return ((YY_BUFFER_STATE )0);
  } else
#line 2020
  if ((int )*(base + (size - 2UL)) != 0) {
#line 2024
    return ((YY_BUFFER_STATE )0);
  } else
#line 2020
  if ((int )*(base + (size - 1UL)) != 0) {
#line 2024
    return ((YY_BUFFER_STATE )0);
  }
  {
#line 2026
  tmp = zconfalloc(sizeof(struct yy_buffer_state ));
#line 2026
  b = (YY_BUFFER_STATE )tmp;
  }
#line 2027
  if (! b) {
    {
#line 2028
    yy_fatal_error("out of dynamic memory in zconf_scan_buffer()");
    }
  }
  {
#line 2030
  b->yy_buf_size = size - 2UL;
#line 2031
  tmp___0 = base;
#line 2031
  b->yy_ch_buf = tmp___0;
#line 2031
  b->yy_buf_pos = tmp___0;
#line 2032
  b->yy_is_our_buffer = 0;
#line 2033
  b->yy_input_file = (FILE *)0;
#line 2034
  b->yy_n_chars = (int )b->yy_buf_size;
#line 2035
  b->yy_is_interactive = 0;
#line 2036
  b->yy_at_bol = 1;
#line 2037
  b->yy_fill_buffer = 0;
#line 2038
  b->yy_buffer_status = 0;
#line 2040
  zconf_switch_to_buffer(b);
  }
#line 2042
  return (b);
}
}
#line 2053 "scripts/kconfig/zconf.lex.c_shipped"
YY_BUFFER_STATE zconf_scan_string(char const   *yystr ) 
{ 
  size_t tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 2056
  tmp = strlen(yystr);
#line 2056
  tmp___0 = zconf_scan_bytes(yystr, (int )tmp);
  }
#line 2056
  return (tmp___0);
}
}
#line 2066 "scripts/kconfig/zconf.lex.c_shipped"
YY_BUFFER_STATE zconf_scan_bytes(char const   *yybytes , int _yybytes_len ) 
{ 
  YY_BUFFER_STATE b ;
  char *buf ;
  yy_size_t n ;
  int i ;
  void *tmp ;
  char tmp___0 ;

  {
  {
#line 2074
  n = (yy_size_t )(_yybytes_len + 2);
#line 2075
  tmp = zconfalloc(n);
#line 2075
  buf = (char *)tmp;
  }
#line 2076
  if (! buf) {
    {
#line 2077
    yy_fatal_error("out of dynamic memory in zconf_scan_bytes()");
    }
  }
#line 2079
  i = 0;
  {
#line 2079
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2079
    if (! (i < _yybytes_len)) {
#line 2079
      goto while_break;
    }
#line 2080
    *(buf + i) = (char )*(yybytes + i);
#line 2079
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2082
  tmp___0 = (char)0;
#line 2082
  *(buf + (_yybytes_len + 1)) = tmp___0;
#line 2082
  *(buf + _yybytes_len) = tmp___0;
#line 2084
  b = zconf_scan_buffer(buf, n);
  }
#line 2085
  if (! b) {
    {
#line 2086
    yy_fatal_error("bad buffer in zconf_scan_bytes()");
    }
  }
#line 2091
  b->yy_is_our_buffer = 1;
#line 2093
  return (b);
}
}
#line 2100 "scripts/kconfig/zconf.lex.c_shipped"
static void yy_fatal_error(char const   *msg ) 
{ 


  {
  {
#line 2102
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          msg);
#line 2103
  exit(2);
  }
}
}
#line 2128 "scripts/kconfig/zconf.lex.c_shipped"
int zconfget_lineno(void) 
{ 


  {
#line 2131
  return (zconflineno);
}
}
#line 2137 "scripts/kconfig/zconf.lex.c_shipped"
FILE *zconfget_in(void) 
{ 


  {
#line 2139
  return (zconfin);
}
}
#line 2145 "scripts/kconfig/zconf.lex.c_shipped"
FILE *zconfget_out(void) 
{ 


  {
#line 2147
  return (zconfout);
}
}
#line 2153 "scripts/kconfig/zconf.lex.c_shipped"
int zconfget_leng(void) 
{ 


  {
#line 2155
  return (zconfleng);
}
}
#line 2162 "scripts/kconfig/zconf.lex.c_shipped"
char *zconfget_text(void) 
{ 


  {
#line 2164
  return (zconftext);
}
}
#line 2171 "scripts/kconfig/zconf.lex.c_shipped"
void zconfset_lineno(int line_number ) 
{ 


  {
#line 2174
  zconflineno = line_number;
#line 2175
  return;
}
}
#line 2183 "scripts/kconfig/zconf.lex.c_shipped"
void zconfset_in(FILE *in_str ) 
{ 


  {
#line 2185
  zconfin = in_str;
#line 2186
  return;
}
}
#line 2188 "scripts/kconfig/zconf.lex.c_shipped"
void zconfset_out(FILE *out_str ) 
{ 


  {
#line 2190
  zconfout = out_str;
#line 2191
  return;
}
}
#line 2193 "scripts/kconfig/zconf.lex.c_shipped"
int zconfget_debug(void) 
{ 


  {
#line 2195
  return (zconf_flex_debug);
}
}
#line 2198 "scripts/kconfig/zconf.lex.c_shipped"
void zconfset_debug(int bdebug ) 
{ 


  {
#line 2200
  zconf_flex_debug = bdebug;
#line 2201
  return;
}
}
#line 2203 "scripts/kconfig/zconf.lex.c_shipped"
static int yy_init_globals(void) 
{ 


  {
#line 2209
  yy_buffer_stack = (YY_BUFFER_STATE *)0;
#line 2210
  yy_buffer_stack_top = (size_t )0;
#line 2211
  yy_buffer_stack_max = (size_t )0;
#line 2212
  yy_c_buf_p = (char *)0;
#line 2213
  yy_init = 0;
#line 2214
  yy_start = 0;
#line 2221
  zconfin = (FILE *)0;
#line 2222
  zconfout = (FILE *)0;
#line 2228
  return (0);
}
}
#line 2232 "scripts/kconfig/zconf.lex.c_shipped"
int zconflex_destroy(void) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 2236
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2236
    if (yy_buffer_stack) {
#line 2236
      tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
#line 2236
      tmp___0 = (YY_BUFFER_STATE )((void *)0);
    }
#line 2236
    if (! tmp___0) {
#line 2236
      goto while_break;
    }
#line 2237
    if (yy_buffer_stack) {
#line 2237
      tmp = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
#line 2237
      tmp = (YY_BUFFER_STATE )((void *)0);
    }
    {
#line 2237
    zconf_delete_buffer(tmp);
#line 2238
    *(yy_buffer_stack + yy_buffer_stack_top) = (YY_BUFFER_STATE )((void *)0);
#line 2239
    zconfpop_buffer_state();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2243
  zconffree((void *)yy_buffer_stack);
#line 2244
  yy_buffer_stack = (YY_BUFFER_STATE *)((void *)0);
#line 2248
  yy_init_globals();
  }
#line 2250
  return (0);
}
}
#line 2277 "scripts/kconfig/zconf.lex.c_shipped"
void *zconfalloc(yy_size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 2279
  tmp = malloc(size);
  }
#line 2279
  return (tmp);
}
}
#line 2282 "scripts/kconfig/zconf.lex.c_shipped"
void *zconfrealloc(void *ptr , yy_size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 2291
  tmp = realloc((void *)((char *)ptr), size);
  }
#line 2291
  return (tmp);
}
}
#line 2294 "scripts/kconfig/zconf.lex.c_shipped"
void zconffree(void *ptr ) 
{ 


  {
  {
#line 2296
  free((void *)((char *)ptr));
  }
#line 2297
  return;
}
}
#line 2301 "scripts/kconfig/zconf.lex.c_shipped"
void zconf_starthelp(void) 
{ 


  {
  {
#line 2303
  new_string();
#line 2304
  first_ts = 0;
#line 2304
  last_ts = first_ts;
#line 2305
  yy_start = 5;
  }
#line 2306
  return;
}
}
#line 2308 "scripts/kconfig/zconf.lex.c_shipped"
static void zconf_endhelp(void) 
{ 


  {
#line 2310
  zconflval.string = text;
#line 2311
  yy_start = 1;
#line 2312
  return;
}
}
#line 2322 "scripts/kconfig/zconf.lex.c_shipped"
FILE *zconf_fopen(char const   *name ) 
{ 
  char *env ;
  char fullname___0[4097] ;
  FILE *f ;

  {
  {
#line 2327
  f = fopen((char const   */* __restrict  */)name, (char const   */* __restrict  */)"r");
  }
#line 2328
  if (! f) {
#line 2328
    if ((unsigned long )name != (unsigned long )((void *)0)) {
#line 2328
      if ((int const   )*(name + 0) != 47) {
        {
#line 2329
        env = getenv("srctree");
        }
#line 2330
        if (env) {
          {
#line 2331
          sprintf((char */* __restrict  */)(fullname___0), (char const   */* __restrict  */)"%s/%s",
                  env, name);
#line 2332
          f = fopen((char const   */* __restrict  */)(fullname___0), (char const   */* __restrict  */)"r");
          }
        }
      }
    }
  }
#line 2335
  return (f);
}
}
#line 2338 "scripts/kconfig/zconf.lex.c_shipped"
void zconf_initscan(char const   *name ) 
{ 
  void *tmp ;

  {
  {
#line 2340
  zconfin = zconf_fopen(name);
  }
#line 2341
  if (! zconfin) {
    {
#line 2342
    printf((char const   */* __restrict  */)"can\'t find file %s\n", name);
#line 2343
    exit(1);
    }
  }
  {
#line 2346
  tmp = malloc(sizeof(*current_buf));
#line 2346
  current_buf = (struct buffer *)tmp;
#line 2347
  memset((void *)current_buf, 0, sizeof(*current_buf));
#line 2349
  current_file = file_lookup(name);
#line 2350
  current_file->lineno = 1;
  }
#line 2351
  return;
}
}
#line 2353 "scripts/kconfig/zconf.lex.c_shipped"
void zconf_nextfile(char const   *name ) 
{ 
  struct file *iter ;
  struct file *file ;
  struct file *tmp ;
  struct buffer *buf ;
  void *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  YY_BUFFER_STATE tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 2356
  tmp = file_lookup(name);
#line 2356
  file = tmp;
#line 2357
  tmp___0 = malloc(sizeof(*buf));
#line 2357
  buf = (struct buffer *)tmp___0;
#line 2358
  memset((void *)buf, 0, sizeof(*buf));
  }
#line 2360
  if (yy_buffer_stack) {
#line 2360
    current_buf->state = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 2360
    current_buf->state = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 2361
  zconfin = zconf_fopen(file->name);
  }
#line 2362
  if (! zconfin) {
    {
#line 2363
    tmp___1 = zconf_lineno();
#line 2363
    tmp___2 = zconf_curname();
#line 2363
    printf((char const   */* __restrict  */)"%s:%d: can\'t open file \"%s\"\n", tmp___2,
           tmp___1, file->name);
#line 2365
    exit(1);
    }
  }
  {
#line 2367
  tmp___3 = zconf_create_buffer(zconfin, 16384);
#line 2367
  zconf_switch_to_buffer(tmp___3);
#line 2368
  buf->parent = current_buf;
#line 2369
  current_buf = buf;
#line 2371
  iter = current_file->parent;
  }
  {
#line 2371
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2371
    if (! iter) {
#line 2371
      goto while_break;
    }
    {
#line 2372
    tmp___8 = strcmp(current_file->name, iter->name);
    }
#line 2372
    if (! tmp___8) {
      {
#line 2373
      tmp___4 = zconf_curname();
#line 2373
      tmp___5 = zconf_lineno();
#line 2373
      tmp___6 = zconf_curname();
#line 2373
      printf((char const   */* __restrict  */)"%s:%d: recursive inclusion detected. Inclusion path:\n  current file : \'%s\'\n",
             tmp___6, tmp___5, tmp___4);
#line 2377
      iter = current_file->parent;
      }
      {
#line 2378
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2378
        if (iter) {
          {
#line 2378
          tmp___7 = strcmp(iter->name, current_file->name);
          }
#line 2378
          if (! tmp___7) {
#line 2378
            goto while_break___0;
          }
        } else {
#line 2378
          goto while_break___0;
        }
        {
#line 2380
        printf((char const   */* __restrict  */)"  included from: \'%s:%d\'\n", iter->name,
               iter->lineno - 1);
#line 2382
        iter = iter->parent;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2384
      if (iter) {
        {
#line 2385
        printf((char const   */* __restrict  */)"  included from: \'%s:%d\'\n", iter->name,
               iter->lineno + 1);
        }
      }
      {
#line 2387
      exit(1);
      }
    }
#line 2371
    iter = iter->parent;
  }
  while_break: /* CIL Label */ ;
  }
#line 2390
  file->lineno = 1;
#line 2391
  file->parent = current_file;
#line 2392
  current_file = file;
#line 2393
  return;
}
}
#line 2395 "scripts/kconfig/zconf.lex.c_shipped"
static void zconf_endfile(void) 
{ 
  struct buffer *parent ;
  YY_BUFFER_STATE tmp ;

  {
#line 2399
  current_file = current_file->parent;
#line 2401
  parent = current_buf->parent;
#line 2402
  if (parent) {
    {
#line 2403
    fclose(zconfin);
    }
#line 2404
    if (yy_buffer_stack) {
#line 2404
      tmp = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
#line 2404
      tmp = (YY_BUFFER_STATE )((void *)0);
    }
    {
#line 2404
    zconf_delete_buffer(tmp);
#line 2405
    zconf_switch_to_buffer(parent->state);
    }
  }
  {
#line 2407
  free((void *)current_buf);
#line 2408
  current_buf = parent;
  }
#line 2409
  return;
}
}
#line 2411 "scripts/kconfig/zconf.lex.c_shipped"
int zconf_lineno(void) 
{ 


  {
#line 2413
  return (current_pos.lineno);
}
}
#line 2416 "scripts/kconfig/zconf.lex.c_shipped"
char const   *zconf_curname(void) 
{ 
  char const   *tmp ;

  {
#line 2418
  if (current_pos.file) {
#line 2418
    tmp = (current_pos.file)->name;
  } else {
#line 2418
    tmp = "<none>";
  }
#line 2418
  return (tmp);
}
}
#line 14 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/util.c"
struct file *file_lookup(char const   *name ) 
{ 
  struct file *file ;
  char const   *file_name ;
  char const   *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 17
  tmp = sym_expand_string_value(name);
#line 17
  file_name = tmp;
#line 19
  file = file_list;
  }
  {
#line 19
  while (1) {
    while_continue: /* CIL Label */ ;
#line 19
    if (! file) {
#line 19
      goto while_break;
    }
    {
#line 20
    tmp___0 = strcmp(name, file->name);
    }
#line 20
    if (! tmp___0) {
      {
#line 21
      free((void *)file_name);
      }
#line 22
      return (file);
    }
#line 19
    file = file->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 26
  tmp___1 = malloc(sizeof(*file));
#line 26
  file = (struct file *)tmp___1;
#line 27
  memset((void *)file, 0, sizeof(*file));
#line 28
  file->name = file_name;
#line 29
  file->next = file_list;
#line 30
  file_list = file;
  }
#line 31
  return (file);
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/util.c"
int file_write_dep(char const   *name ) 
{ 
  struct symbol *sym ;
  struct symbol *env_sym ;
  struct expr *e ;
  struct file *file ;
  FILE *out ;
  char const   *tmp ;
  struct property *prop ;
  char const   *value ;
  char *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 42
  if (! name) {
#line 43
    name = ".kconfig.d";
  }
  {
#line 44
  out = fopen((char const   */* __restrict  */)"..config.tmp", (char const   */* __restrict  */)"w");
  }
#line 45
  if (! out) {
#line 46
    return (1);
  }
  {
#line 47
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"deps_config := \\\n");
#line 48
  file = file_list;
  }
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! file) {
#line 48
      goto while_break;
    }
#line 49
    if (file->next) {
      {
#line 50
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\t%s \\\n",
              file->name);
      }
    } else {
      {
#line 52
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\t%s\n",
              file->name);
      }
    }
#line 48
    file = file->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 54
  tmp = conf_get_autoconfig_name();
#line 54
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\n%s: \\\n\t$(deps_config)\n\n",
          tmp);
#line 57
  e = sym_env_list;
  }
  {
#line 57
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 57
    if (e) {
#line 57
      sym = e->right.sym;
#line 57
      if (! sym) {
#line 57
        goto while_break___0;
      }
    } else {
#line 57
      goto while_break___0;
    }
    {
#line 61
    prop = sym_get_env_prop(sym);
#line 62
    env_sym = prop_get_symbol(prop);
    }
#line 63
    if (! env_sym) {
#line 64
      goto __Cont;
    }
    {
#line 65
    tmp___0 = getenv((char const   *)env_sym->name);
#line 65
    value = (char const   *)tmp___0;
    }
#line 66
    if (! value) {
#line 67
      value = "";
    }
    {
#line 68
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"ifneq \"$(%s)\" \"%s\"\n",
            env_sym->name, value);
#line 69
    tmp___1 = conf_get_autoconfig_name();
#line 69
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"%s: FORCE\n",
            tmp___1);
#line 70
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"endif\n");
    }
    __Cont: /* CIL Label */ 
#line 57
    e = e->left.expr;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 73
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\n$(deps_config): ;\n");
#line 74
  fclose(out);
#line 75
  rename("..config.tmp", name);
  }
#line 76
  return (0);
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/util.c"
struct gstr str_new(void) 
{ 
  struct gstr gs ;
  void *tmp ;

  {
  {
#line 84
  tmp = malloc(sizeof(char ) * 64UL);
#line 84
  gs.s = (char *)tmp;
#line 85
  gs.len = (size_t )64;
#line 86
  gs.max_width = 0;
#line 87
  strcpy((char */* __restrict  */)gs.s, (char const   */* __restrict  */)"\000");
  }
#line 88
  return (gs);
}
}
#line 92 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/util.c"
struct gstr str_assign(char const   *s ) 
{ 
  struct gstr gs ;
  size_t tmp ;

  {
  {
#line 95
  gs.s = strdup(s);
#line 96
  tmp = strlen(s);
#line 96
  gs.len = tmp + 1UL;
#line 97
  gs.max_width = 0;
  }
#line 98
  return (gs);
}
}
#line 102 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/util.c"
void str_free(struct gstr *gs ) 
{ 


  {
#line 104
  if (gs->s) {
    {
#line 105
    free((void *)gs->s);
    }
  }
#line 106
  gs->s = (char *)((void *)0);
#line 107
  gs->len = (size_t )0;
#line 108
  return;
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/util.c"
void str_append(struct gstr *gs , char const   *s ) 
{ 
  size_t l ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 114
  if (s) {
    {
#line 115
    tmp = strlen((char const   *)gs->s);
#line 115
    tmp___0 = strlen(s);
#line 115
    l = (tmp + tmp___0) + 1UL;
    }
#line 116
    if (l > gs->len) {
      {
#line 117
      tmp___1 = realloc((void *)gs->s, l);
#line 117
      gs->s = (char *)tmp___1;
#line 118
      gs->len = l;
      }
    }
    {
#line 120
    strcat((char */* __restrict  */)gs->s, (char const   */* __restrict  */)s);
    }
  }
#line 122
  return;
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/util.c"
void str_printf(struct gstr *gs , char const   *fmt  , ...) 
{ 
  va_list ap ;
  char s[10000] ;

  {
  {
#line 129
  __builtin_va_start(ap, fmt);
#line 130
  vsnprintf((char */* __restrict  */)(s), sizeof(s), (char const   */* __restrict  */)fmt,
            ap);
#line 131
  str_append(gs, (char const   *)(s));
#line 132
  __builtin_va_end(ap);
  }
#line 133
  return;
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/util.c"
char const   *str_get(struct gstr *gs ) 
{ 


  {
#line 138
  return ((char const   *)gs->s);
}
}
#line 321 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
#line 19 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/confdata.c"
static void ( /* format attribute */  conf_warning)(char const   *fmt  , ...) ;
#line 22
static void ( /* format attribute */  conf_message)(char const   *fmt  , ...) ;
#line 25 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/confdata.c"
static char const   *conf_filename  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/confdata.c"
static int conf_lineno  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/confdata.c"
static int conf_warnings  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/confdata.c"
static int conf_unsaved  ;
#line 28 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/confdata.c"
char const   conf_defname[21]  = 
#line 28
  {      (char const   )'a',      (char const   )'r',      (char const   )'c',      (char const   )'h', 
        (char const   )'/',      (char const   )'$',      (char const   )'A',      (char const   )'R', 
        (char const   )'C',      (char const   )'H',      (char const   )'/',      (char const   )'d', 
        (char const   )'e',      (char const   )'f',      (char const   )'c',      (char const   )'o', 
        (char const   )'n',      (char const   )'f',      (char const   )'i',      (char const   )'g', 
        (char const   )'\000'};
#line 30 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/confdata.c"
static void ( /* format attribute */  conf_warning)(char const   *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 33
  __builtin_va_start(ap, fmt);
#line 34
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d:warning: ",
          conf_filename, conf_lineno);
#line 35
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
           ap);
#line 36
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 37
  __builtin_va_end(ap);
#line 38
  conf_warnings ++;
  }
#line 39
  return;
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/confdata.c"
static void conf_default_message_callback(char const   *fmt , va_list ap ) 
{ 


  {
  {
#line 43
  printf((char const   */* __restrict  */)"#\n# ");
#line 44
  vprintf((char const   */* __restrict  */)fmt, ap);
#line 45
  printf((char const   */* __restrict  */)"\n#\n");
  }
#line 46
  return;
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/confdata.c"
static void (*conf_message_callback)(char const   *fmt , va_list ap )  =    & conf_default_message_callback;
#line 50 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/confdata.c"
void conf_set_message_callback(void (*fn)(char const   *fmt , va_list ap ) ) 
{ 


  {
#line 52
  conf_message_callback = fn;
#line 53
  return;
}
}
#line 55 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/confdata.c"
static void ( /* format attribute */  conf_message)(char const   *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 59
  __builtin_va_start(ap, fmt);
  }
#line 60
  if (conf_message_callback) {
    {
#line 61
    (*conf_message_callback)(fmt, ap);
    }
  }
#line 62
  return;
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/confdata.c"
char const   *conf_get_configname(void) 
{ 
  char *name ;
  char *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 66
  tmp = getenv("KCONFIG_CONFIG");
#line 66
  name = tmp;
  }
#line 68
  if (name) {
#line 68
    tmp___0 = (char const   *)name;
  } else {
#line 68
    tmp___0 = ".config";
  }
#line 68
  return (tmp___0);
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/confdata.c"
char const   *conf_get_autoconfig_name(void) 
{ 
  char *name ;
  char *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 73
  tmp = getenv("KCONFIG_AUTOCONFIG");
#line 73
  name = tmp;
  }
#line 75
  if (name) {
#line 75
    tmp___0 = (char const   *)name;
  } else {
#line 75
    tmp___0 = "include/config/auto.conf";
  }
#line 75
  return (tmp___0);
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/confdata.c"
static char res_value[256]  ;
#line 78 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/confdata.c"
static char *conf_expand_value(char const   *in ) 
{ 
  struct symbol *sym ;
  char const   *src ;
  char *dst ;
  char name[256] ;
  char *tmp ;
  char const   *tmp___0 ;
  unsigned short const   **tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;

  {
#line 85
  res_value[0] = (char)0;
#line 86
  dst = name;
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 87
    tmp___3 = strchr(in, '$');
#line 87
    src = (char const   *)tmp___3;
    }
#line 87
    if (! src) {
#line 87
      goto while_break;
    }
    {
#line 88
    strncat((char */* __restrict  */)(res_value), (char const   */* __restrict  */)in,
            (size_t )(src - in));
#line 89
    src ++;
#line 90
    dst = name;
    }
    {
#line 91
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 91
      tmp___1 = __ctype_b_loc();
      }
#line 91
      if (! ((int const   )*(*tmp___1 + (int )*src) & 8)) {
#line 91
        if (! ((int const   )*src == 95)) {
#line 91
          goto while_break___0;
        }
      }
#line 92
      tmp = dst;
#line 92
      dst ++;
#line 92
      tmp___0 = src;
#line 92
      src ++;
#line 92
      *tmp = (char )*tmp___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 93
    *dst = (char)0;
#line 94
    sym = sym_lookup((char const   *)(name), 0);
#line 95
    sym_calc_value(sym);
#line 96
    tmp___2 = sym_get_string_value(sym);
#line 96
    strcat((char */* __restrict  */)(res_value), (char const   */* __restrict  */)tmp___2);
#line 97
    in = src;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 99
  strcat((char */* __restrict  */)(res_value), (char const   */* __restrict  */)in);
  }
#line 101
  return (res_value);
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/confdata.c"
static char fullname[4097]  ;
#line 104 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/confdata.c"
char *conf_get_default_confname(void) 
{ 
  struct stat buf ;
  char *env ;
  char *name ;
  int tmp ;

  {
  {
#line 110
  name = conf_expand_value(conf_defname);
#line 111
  env = getenv("srctree");
  }
#line 112
  if (env) {
    {
#line 113
    sprintf((char */* __restrict  */)(fullname), (char const   */* __restrict  */)"%s/%s",
            env, name);
#line 114
    tmp = stat((char const   */* __restrict  */)(fullname), (struct stat */* __restrict  */)(& buf));
    }
#line 114
    if (! tmp) {
#line 115
      return (fullname);
    }
  }
#line 117
  return (name);
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/confdata.c"
static int conf_set_sym_val(struct symbol *sym , int def , int def_flags , char *p ) 
{ 
  char *p2 ;
  unsigned short const   **tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  _Bool tmp___3 ;

  {
  {
#line 125
  if ((unsigned int )sym->type == 2U) {
#line 125
    goto case_2;
  }
#line 132
  if ((unsigned int )sym->type == 1U) {
#line 132
    goto case_1;
  }
#line 145
  if ((unsigned int )sym->type == 6U) {
#line 145
    goto case_6;
  }
#line 153
  if ((unsigned int )sym->type == 5U) {
#line 153
    goto case_5;
  }
#line 169
  if ((unsigned int )sym->type == 4U) {
#line 169
    goto done;
  }
#line 169
  if ((unsigned int )sym->type == 3U) {
#line 169
    goto done;
  }
#line 179
  goto switch_default;
  case_2: /* CIL Label */ 
#line 126
  if ((int )*(p + 0) == 109) {
#line 127
    sym->def[def].tri = (tristate )1;
#line 128
    sym->flags |= def_flags;
#line 129
    goto switch_break;
  }
  case_1: /* CIL Label */ 
#line 133
  if ((int )*(p + 0) == 121) {
#line 134
    sym->def[def].tri = (tristate )2;
#line 135
    sym->flags |= def_flags;
#line 136
    goto switch_break;
  }
#line 138
  if ((int )*(p + 0) == 110) {
#line 139
    sym->def[def].tri = (tristate )0;
#line 140
    sym->flags |= def_flags;
#line 141
    goto switch_break;
  }
  {
#line 143
  conf_warning("symbol value \'%s\' invalid for %s", p, sym->name);
  }
#line 144
  return (1);
  case_6: /* CIL Label */ 
#line 146
  if ((int )*p != 34) {
#line 147
    p2 = p;
    {
#line 147
    while (1) {
      while_continue: /* CIL Label */ ;
#line 147
      if (*p2) {
        {
#line 147
        tmp = __ctype_b_loc();
        }
#line 147
        if ((int const   )*(*tmp + (int )*p2) & 8192) {
#line 147
          goto while_break;
        }
      } else {
#line 147
        goto while_break;
      }
#line 147
      p2 ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 149
    sym->type = (enum symbol_type )5;
#line 150
    goto done;
  }
  case_5: /* CIL Label */ 
#line 154
  tmp___0 = p;
#line 154
  p ++;
#line 154
  if ((int )*tmp___0 != 34) {
#line 155
    goto switch_break;
  }
#line 156
  p2 = p;
  {
#line 156
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 156
    p2 = strpbrk((char const   *)p2, "\"\\");
    }
#line 156
    if (! p2) {
#line 156
      goto while_break___0;
    }
#line 157
    if ((int )*p2 == 34) {
#line 158
      *p2 = (char)0;
#line 159
      goto while_break___0;
    }
    {
#line 161
    tmp___1 = strlen((char const   *)p2);
#line 161
    memmove((void *)p2, (void const   *)(p2 + 1), tmp___1);
#line 156
    p2 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 163
  if (! p2) {
    {
#line 164
    conf_warning("invalid string found");
    }
#line 165
    return (1);
  }
  done: 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 171
  tmp___3 = sym_string_valid(sym, (char const   *)p);
  }
#line 171
  if (tmp___3) {
    {
#line 172
    tmp___2 = strdup((char const   *)p);
#line 172
    sym->def[def].val = (void *)tmp___2;
#line 173
    sym->flags |= def_flags;
    }
  } else {
    {
#line 175
    conf_warning("symbol value \'%s\' invalid for %s", p, sym->name);
    }
#line 176
    return (1);
  }
#line 178
  goto switch_break;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 182
  return (0);
}
}
#line 185 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/confdata.c"
int conf_read_simple(char const   *name , int def ) 
{ 
  FILE *in ;
  char line___0[1024] ;
  char *p ;
  char *p2 ;
  struct symbol *sym ;
  int i ;
  int def_flags ;
  struct property *prop ;
  tristate tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  _Bool tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  int tmp___15 ;
  size_t tmp___16 ;
  int tmp___17 ;
  struct symbol *cs ;
  struct property *tmp___18 ;
  struct symbol *tmp___19 ;
  _Bool tmp___20 ;
  char *tmp___21 ;

  {
#line 187
  in = (FILE *)((void *)0);
#line 193
  if (name) {
    {
#line 194
    in = zconf_fopen(name);
    }
  } else {
    {
#line 198
    name = conf_get_configname();
#line 199
    in = zconf_fopen(name);
    }
#line 200
    if (in) {
#line 201
      goto load;
    }
    {
#line 202
    sym_add_change_count(1);
    }
#line 203
    if (! sym_defconfig_list) {
#line 204
      if (modules_sym) {
        {
#line 205
        sym_calc_value(modules_sym);
        }
      }
#line 206
      return (1);
    }
#line 209
    prop = sym_defconfig_list->prop;
    {
#line 209
    while (1) {
      while_continue: /* CIL Label */ ;
#line 209
      if (! prop) {
#line 209
        goto while_break;
      }
#line 209
      if ((unsigned int )prop->type == 4U) {
        {
#line 210
        tmp = expr_calc_value(prop->visible.expr);
        }
#line 210
        if ((unsigned int )tmp == 0U) {
#line 212
          goto __Cont;
        } else
#line 210
        if ((unsigned int )(prop->expr)->type != 7U) {
#line 212
          goto __Cont;
        }
        {
#line 213
        tmp___0 = conf_expand_value((char const   *)((prop->expr)->left.sym)->name);
#line 213
        name = (char const   *)tmp___0;
#line 214
        in = zconf_fopen(name);
        }
#line 215
        if (in) {
          {
#line 216
          tmp___1 = gettext("using defaults found in %s");
#line 216
          conf_message((char const   *)tmp___1, name);
          }
#line 218
          goto load;
        }
      }
      __Cont: /* CIL Label */ 
#line 209
      prop = prop->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 222
  if (! in) {
#line 223
    return (1);
  }
  load: 
#line 226
  conf_filename = name;
#line 227
  conf_lineno = 0;
#line 228
  conf_warnings = 0;
#line 229
  conf_unsaved = 0;
#line 231
  def_flags = 65536 << def;
#line 232
  i = 0;
  {
#line 232
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 232
    if (! (i < 9973)) {
#line 232
      goto while_break___0;
    }
#line 232
    sym = symbol_hash[i];
    {
#line 232
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 232
      if (! sym) {
#line 232
        goto while_break___1;
      }
#line 232
      if ((unsigned int )sym->type != 6U) {
        {
#line 233
        sym->flags |= 1024;
#line 234
        sym->flags &= ~ (def_flags | 128);
#line 235
        tmp___2 = sym_is_choice(sym);
        }
#line 235
        if (tmp___2) {
#line 236
          sym->flags |= def_flags;
        }
        {
#line 240
        if ((unsigned int )sym->type == 5U) {
#line 240
          goto case_5;
        }
#line 240
        if ((unsigned int )sym->type == 4U) {
#line 240
          goto case_5;
        }
#line 240
        if ((unsigned int )sym->type == 3U) {
#line 240
          goto case_5;
        }
#line 244
        goto switch_default;
        case_5: /* CIL Label */ 
        case_4: /* CIL Label */ 
        case_3: /* CIL Label */ 
#line 241
        if (sym->def[def].val) {
          {
#line 242
          free(sym->def[def].val);
          }
        }
        switch_default: /* CIL Label */ 
#line 245
        sym->def[def].val = (void *)0;
#line 246
        sym->def[def].tri = (tristate )0;
        switch_break: /* CIL Label */ ;
        }
      }
#line 232
      sym = sym->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 232
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 250
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 250
    tmp___21 = fgets((char */* __restrict  */)(line___0), (int )sizeof(line___0),
                     (FILE */* __restrict  */)in);
    }
#line 250
    if (! tmp___21) {
#line 250
      goto while_break___2;
    }
#line 251
    conf_lineno ++;
#line 252
    sym = (struct symbol *)((void *)0);
#line 253
    if ((int )line___0[0] == 35) {
      {
#line 254
      tmp___3 = strlen("CONFIG_");
#line 254
      tmp___4 = memcmp((void const   *)(line___0 + 2), (void const   *)"CONFIG_",
                       tmp___3);
      }
#line 254
      if (tmp___4) {
#line 255
        goto while_continue___2;
      }
      {
#line 256
      tmp___5 = strlen("CONFIG_");
#line 256
      p = strchr((char const   *)((line___0 + 2) + tmp___5), ' ');
      }
#line 257
      if (! p) {
#line 258
        goto while_continue___2;
      }
      {
#line 259
      tmp___6 = p;
#line 259
      p ++;
#line 259
      *tmp___6 = (char)0;
#line 260
      tmp___7 = strncmp((char const   *)p, "is not set", (size_t )10);
      }
#line 260
      if (tmp___7) {
#line 261
        goto while_continue___2;
      }
#line 262
      if (def == 0) {
        {
#line 263
        tmp___8 = strlen("CONFIG_");
#line 263
        sym = sym_find((char const   *)((line___0 + 2) + tmp___8));
        }
#line 264
        if (! sym) {
          {
#line 265
          sym_add_change_count(1);
          }
#line 266
          goto setsym;
        }
      } else {
        {
#line 269
        tmp___9 = strlen("CONFIG_");
#line 269
        sym = sym_lookup((char const   *)((line___0 + 2) + tmp___9), 0);
        }
#line 270
        if ((unsigned int )sym->type == 0U) {
#line 271
          sym->type = (enum symbol_type )1;
        }
      }
#line 273
      if (sym->flags & def_flags) {
        {
#line 274
        conf_warning("override: reassigning to symbol %s", sym->name);
        }
      }
      {
#line 278
      if ((unsigned int )sym->type == 2U) {
#line 278
        goto case_2;
      }
#line 278
      if ((unsigned int )sym->type == 1U) {
#line 278
        goto case_2;
      }
#line 282
      goto switch_default___0;
      case_2: /* CIL Label */ 
      case_1: /* CIL Label */ 
#line 279
      sym->def[def].tri = (tristate )0;
#line 280
      sym->flags |= def_flags;
#line 281
      goto switch_break___0;
      switch_default___0: /* CIL Label */ ;
      switch_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 285
      tmp___16 = strlen("CONFIG_");
#line 285
      tmp___17 = memcmp((void const   *)(line___0), (void const   *)"CONFIG_", tmp___16);
      }
#line 285
      if (tmp___17 == 0) {
        {
#line 286
        tmp___10 = strlen("CONFIG_");
#line 286
        p = strchr((char const   *)(line___0 + tmp___10), '=');
        }
#line 287
        if (! p) {
#line 288
          goto while_continue___2;
        }
        {
#line 289
        tmp___11 = p;
#line 289
        p ++;
#line 289
        *tmp___11 = (char)0;
#line 290
        p2 = strchr((char const   *)p, '\n');
        }
#line 291
        if (p2) {
#line 292
          tmp___12 = p2;
#line 292
          p2 --;
#line 292
          *tmp___12 = (char)0;
#line 293
          if ((int )*p2 == 13) {
#line 294
            *p2 = (char)0;
          }
        }
#line 296
        if (def == 0) {
          {
#line 297
          tmp___13 = strlen("CONFIG_");
#line 297
          sym = sym_find((char const   *)(line___0 + tmp___13));
          }
#line 298
          if (! sym) {
            {
#line 299
            sym_add_change_count(1);
            }
#line 300
            goto setsym;
          }
        } else {
          {
#line 303
          tmp___14 = strlen("CONFIG_");
#line 303
          sym = sym_lookup((char const   *)(line___0 + tmp___14), 0);
          }
#line 304
          if ((unsigned int )sym->type == 0U) {
#line 305
            sym->type = (enum symbol_type )6;
          }
        }
#line 307
        if (sym->flags & def_flags) {
          {
#line 308
          conf_warning("override: reassigning to symbol %s", sym->name);
          }
        }
        {
#line 310
        tmp___15 = conf_set_sym_val(sym, def, def_flags, p);
        }
#line 310
        if (tmp___15) {
#line 311
          goto while_continue___2;
        }
      } else {
#line 313
        if ((int )line___0[0] != 13) {
#line 313
          if ((int )line___0[0] != 10) {
            {
#line 314
            conf_warning("unexpected data");
            }
          }
        }
#line 315
        goto while_continue___2;
      }
    }
    setsym: 
#line 318
    if (sym) {
      {
#line 318
      tmp___20 = sym_is_choice_value(sym);
      }
#line 318
      if (tmp___20) {
        {
#line 319
        tmp___18 = sym_get_choice_prop(sym);
#line 319
        tmp___19 = prop_get_symbol(tmp___18);
#line 319
        cs = tmp___19;
        }
        {
#line 321
        if ((unsigned int )sym->def[def].tri == 0U) {
#line 321
          goto case_0;
        }
#line 323
        if ((unsigned int )sym->def[def].tri == 1U) {
#line 323
          goto case_1___0;
        }
#line 329
        if ((unsigned int )sym->def[def].tri == 2U) {
#line 329
          goto case_2___0;
        }
#line 320
        goto switch_break___1;
        case_0: /* CIL Label */ 
#line 322
        goto switch_break___1;
        case_1___0: /* CIL Label */ 
#line 324
        if ((unsigned int )cs->def[def].tri == 2U) {
          {
#line 325
          conf_warning("%s creates inconsistent choice state", sym->name);
#line 326
          cs->flags &= ~ def_flags;
          }
        }
#line 328
        goto switch_break___1;
        case_2___0: /* CIL Label */ 
#line 330
        if ((unsigned int )cs->def[def].tri != 0U) {
          {
#line 331
          conf_warning("override: %s changes choice state", sym->name);
          }
        }
#line 332
        cs->def[def].val = (void *)sym;
#line 333
        goto switch_break___1;
        switch_break___1: /* CIL Label */ ;
        }
#line 335
        if ((unsigned int )cs->def[def].tri > (unsigned int )sym->def[def].tri) {
#line 335
          cs->def[def].tri = cs->def[def].tri;
        } else {
#line 335
          cs->def[def].tri = sym->def[def].tri;
        }
      }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 338
  fclose(in);
  }
#line 340
  if (modules_sym) {
    {
#line 341
    sym_calc_value(modules_sym);
    }
  }
#line 342
  return (0);
}
}
#line 345 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/confdata.c"
int conf_read(char const   *name ) 
{ 
  struct symbol *sym ;
  int i ;
  int tmp ;
  _Bool tmp___0 ;
  tristate tmp___1 ;
  _Bool tmp___2 ;
  int tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;
  _Bool tmp___6 ;
  _Bool tmp___7 ;
  _Bool tmp___8 ;
  int tmp___9 ;

  {
  {
#line 350
  sym_set_change_count(0);
#line 352
  tmp = conf_read_simple(name, 0);
  }
#line 352
  if (tmp) {
#line 353
    return (1);
  }
#line 355
  i = 0;
  {
#line 355
  while (1) {
    while_continue: /* CIL Label */ ;
#line 355
    if (! (i < 9973)) {
#line 355
      goto while_break;
    }
#line 355
    sym = symbol_hash[i];
    {
#line 355
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 355
      if (! sym) {
#line 355
        goto while_break___0;
      }
#line 355
      if ((unsigned int )sym->type != 6U) {
        {
#line 356
        sym_calc_value(sym);
#line 357
        tmp___0 = sym_is_choice(sym);
        }
#line 357
        if (tmp___0) {
#line 358
          goto __Cont;
        } else
#line 357
        if (sym->flags & 4096) {
#line 358
          goto __Cont;
        }
        {
#line 359
        tmp___5 = sym_has_value(sym);
        }
#line 359
        if (tmp___5) {
#line 359
          if (sym->flags & 512) {
            {
#line 363
            if ((unsigned int )sym->type == 2U) {
#line 363
              goto case_2;
            }
#line 363
            if ((unsigned int )sym->type == 1U) {
#line 363
              goto case_2;
            }
#line 369
            goto switch_default;
            case_2: /* CIL Label */ 
            case_1: /* CIL Label */ 
            {
#line 364
            tmp___1 = sym_get_tristate_value(sym);
            }
#line 364
            if ((unsigned int )sym->def[0].tri != (unsigned int )tmp___1) {
#line 365
              goto switch_break;
            }
            {
#line 366
            tmp___2 = sym_is_choice(sym);
            }
#line 366
            if (! tmp___2) {
#line 367
              goto __Cont;
            }
            switch_default: /* CIL Label */ 
            {
#line 370
            tmp___3 = strcmp((char const   *)sym->curr.val, (char const   *)sym->def[0].val);
            }
#line 370
            if (! tmp___3) {
#line 371
              goto __Cont;
            }
#line 372
            goto switch_break;
            switch_break: /* CIL Label */ ;
            }
          } else {
#line 359
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
          {
#line 374
          tmp___4 = sym_has_value(sym);
          }
#line 374
          if (! tmp___4) {
#line 374
            if (! (sym->flags & 512)) {
#line 376
              goto __Cont;
            }
          }
        }
#line 377
        conf_unsaved ++;
      }
      __Cont: /* CIL Label */ 
#line 355
      sym = sym->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 355
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 381
  i = 0;
  {
#line 381
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 381
    if (! (i < 9973)) {
#line 381
      goto while_break___1;
    }
#line 381
    sym = symbol_hash[i];
    {
#line 381
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 381
      if (! sym) {
#line 381
        goto while_break___2;
      }
#line 381
      if ((unsigned int )sym->type != 6U) {
        {
#line 382
        tmp___7 = sym_has_value(sym);
        }
#line 382
        if (tmp___7) {
          {
#line 382
          tmp___8 = sym_is_choice_value(sym);
          }
#line 382
          if (! tmp___8) {
#line 388
            if ((unsigned int )sym->visible == 0U) {
#line 388
              if (! conf_unsaved) {
#line 389
                sym->flags &= -65537;
              }
            }
            {
#line 393
            if ((unsigned int )sym->type == 4U) {
#line 393
              goto case_4;
            }
#line 393
            if ((unsigned int )sym->type == 3U) {
#line 393
              goto case_4;
            }
#line 393
            if ((unsigned int )sym->type == 5U) {
#line 393
              goto case_4;
            }
#line 400
            goto switch_default___0;
            case_4: /* CIL Label */ 
            case_3: /* CIL Label */ 
            case_5: /* CIL Label */ 
            {
#line 395
            tmp___6 = sym_string_within_range(sym, (char const   *)sym->def[0].val);
            }
#line 395
            if (tmp___6) {
#line 396
              goto switch_break___0;
            }
#line 397
            sym->flags &= -65665;
#line 398
            conf_unsaved ++;
#line 399
            goto switch_break___0;
            switch_default___0: /* CIL Label */ 
#line 401
            goto switch_break___0;
            switch_break___0: /* CIL Label */ ;
            }
          }
        }
      }
#line 381
      sym = sym->next;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 381
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 406
  if (conf_warnings) {
#line 406
    tmp___9 = 1;
  } else
#line 406
  if (conf_unsaved) {
#line 406
    tmp___9 = 1;
  } else {
#line 406
    tmp___9 = 0;
  }
  {
#line 406
  sym_add_change_count(tmp___9);
  }
#line 408
  return (0);
}
}
#line 419 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/confdata.c"
static void kconfig_print_symbol(FILE *fp , struct symbol *sym , char const   *value ,
                                 void *arg ) 
{ 
  _Bool skip_unset ;

  {
  {
#line 425
  if ((unsigned int )sym->type == 2U) {
#line 425
    goto case_2;
  }
#line 425
  if ((unsigned int )sym->type == 1U) {
#line 425
    goto case_2;
  }
#line 435
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 426
  if ((int const   )*value == 110) {
#line 427
    skip_unset = (_Bool )((unsigned long )arg != (unsigned long )((void *)0));
#line 429
    if (! skip_unset) {
      {
#line 430
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"# %s%s is not set\n",
              "CONFIG_", sym->name);
      }
    }
#line 432
    return;
  }
#line 434
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 436
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 439
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s%s=%s\n",
          "CONFIG_", sym->name, value);
  }
#line 440
  return;
}
}
#line 442 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/confdata.c"
static void kconfig_print_comment(FILE *fp , char const   *value , void *arg ) 
{ 
  char const   *p ;
  size_t l ;
  char const   *tmp ;

  {
#line 445
  p = value;
  {
#line 448
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 449
    l = strcspn(p, "\n");
#line 450
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"#");
    }
#line 451
    if (l) {
      {
#line 452
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" ");
#line 453
      xfwrite((void const   *)p, l, (size_t )1, fp);
#line 454
      p += l;
      }
    }
    {
#line 456
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
#line 457
    tmp = p;
#line 457
    p ++;
    }
#line 457
    if ((int const   )*tmp == 0) {
#line 458
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 460
  return;
}
}
#line 462 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/confdata.c"
static struct conf_printer kconfig_printer_cb  =    {& kconfig_print_symbol, & kconfig_print_comment};
#line 473 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/confdata.c"
static void header_print_symbol(FILE *fp , struct symbol *sym , char const   *value ,
                                void *arg ) 
{ 
  char const   *suffix ;
  char const   *prefix ;

  {
  {
#line 479
  if ((unsigned int )sym->type == 2U) {
#line 479
    goto case_2;
  }
#line 479
  if ((unsigned int )sym->type == 1U) {
#line 479
    goto case_2;
  }
#line 494
  if ((unsigned int )sym->type == 4U) {
#line 494
    goto case_4;
  }
#line 504
  if ((unsigned int )sym->type == 3U) {
#line 504
    goto case_3;
  }
#line 504
  if ((unsigned int )sym->type == 5U) {
#line 504
    goto case_3;
  }
#line 508
  goto switch_default___0;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 480
  suffix = "";
  {
#line 483
  if ((int const   )*value == 110) {
#line 483
    goto case_110;
  }
#line 485
  if ((int const   )*value == 109) {
#line 485
    goto case_109;
  }
#line 488
  goto switch_default;
  case_110: /* CIL Label */ 
#line 484
  goto switch_break___0;
  case_109: /* CIL Label */ 
#line 486
  suffix = "_MODULE";
  switch_default: /* CIL Label */ 
  {
#line 489
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"#define %s%s%s 1\n",
          "CONFIG_", sym->name, suffix);
  }
  switch_break___0: /* CIL Label */ ;
  }
#line 492
  goto switch_break;
  case_4: /* CIL Label */ 
#line 495
  prefix = "";
#line 497
  if ((int const   )*(value + 0) != 48) {
#line 498
    prefix = "0x";
  } else
#line 497
  if ((int const   )*(value + 1) != 120) {
#line 497
    if ((int const   )*(value + 1) != 88) {
#line 498
      prefix = "0x";
    }
  }
  {
#line 499
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"#define %s%s %s%s\n",
          "CONFIG_", sym->name, prefix, value);
  }
#line 501
  goto switch_break;
  case_3: /* CIL Label */ 
  case_5: /* CIL Label */ 
  {
#line 505
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"#define %s%s %s\n",
          "CONFIG_", sym->name, value);
  }
#line 507
  goto switch_break;
  switch_default___0: /* CIL Label */ 
#line 509
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 512
  return;
}
}
#line 514 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/confdata.c"
static void header_print_comment(FILE *fp , char const   *value , void *arg ) 
{ 
  char const   *p ;
  size_t l ;
  char const   *tmp ;

  {
  {
#line 517
  p = value;
#line 520
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"/*\n");
  }
  {
#line 521
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 522
    l = strcspn(p, "\n");
#line 523
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" *");
    }
#line 524
    if (l) {
      {
#line 525
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" ");
#line 526
      xfwrite((void const   *)p, l, (size_t )1, fp);
#line 527
      p += l;
      }
    }
    {
#line 529
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
#line 530
    tmp = p;
#line 530
    p ++;
    }
#line 530
    if ((int const   )*tmp == 0) {
#line 531
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 533
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" */\n");
  }
#line 534
  return;
}
}
#line 536 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/confdata.c"
static struct conf_printer header_printer_cb  =    {& header_print_symbol, & header_print_comment};
#line 547 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/confdata.c"
static void tristate_print_symbol(FILE *fp , struct symbol *sym , char const   *value ,
                                  void *arg ) 
{ 
  int tmp ;

  {
#line 551
  if ((unsigned int )sym->type == 2U) {
#line 551
    if ((int const   )*value != 110) {
      {
#line 552
      tmp = toupper((int )*value);
#line 552
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s%s=%c\n",
              "CONFIG_", sym->name, (int )((char )tmp));
      }
    }
  }
#line 553
  return;
}
}
#line 555 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/confdata.c"
static struct conf_printer tristate_printer_cb  =    {& tristate_print_symbol, & kconfig_print_comment};
#line 561 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/confdata.c"
static void conf_write_symbol(FILE *fp , struct symbol *sym , struct conf_printer *printer ,
                              void *printer_arg ) 
{ 
  char const   *str ;

  {
  {
#line 568
  if ((unsigned int )sym->type == 0U) {
#line 568
    goto case_0;
  }
#line 568
  if ((unsigned int )sym->type == 6U) {
#line 568
    goto case_0;
  }
#line 570
  if ((unsigned int )sym->type == 5U) {
#line 570
    goto case_5;
  }
#line 576
  goto switch_default;
  case_0: /* CIL Label */ 
  case_6: /* CIL Label */ 
#line 569
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 571
  str = sym_get_string_value(sym);
#line 572
  str = sym_escape_string_value(str);
#line 573
  (*(printer->print_symbol))(fp, sym, str, printer_arg);
#line 574
  free((void *)str);
  }
#line 575
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 577
  str = sym_get_string_value(sym);
#line 578
  (*(printer->print_symbol))(fp, sym, str, printer_arg);
  }
  switch_break: /* CIL Label */ ;
  }
#line 580
  return;
}
}
#line 582 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/confdata.c"
static void conf_write_heading(FILE *fp , struct conf_printer *printer , void *printer_arg ) 
{ 
  char buf[256] ;

  {
  {
#line 587
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"\nAutomatically generated file; DO NOT EDIT.\n%s\n",
           (rootmenu.prompt)->text);
#line 593
  (*(printer->print_comment))(fp, (char const   *)(buf), printer_arg);
  }
#line 594
  return;
}
}
#line 600 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/confdata.c"
int conf_write_defconfig(char const   *filename ) 
{ 
  struct symbol *sym ;
  struct menu *menu ;
  FILE *out ;
  _Bool tmp ;
  _Bool tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  struct symbol *cs ;
  struct symbol *ds ;
  struct property *tmp___4 ;
  tristate tmp___5 ;
  _Bool tmp___6 ;
  _Bool tmp___7 ;
  _Bool tmp___8 ;

  {
  {
#line 606
  out = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"w");
  }
#line 607
  if (! out) {
#line 608
    return (1);
  }
  {
#line 610
  sym_clear_all_valid();
#line 613
  menu = rootmenu.list;
  }
  {
#line 615
  while (1) {
    while_continue: /* CIL Label */ ;
#line 615
    if (! ((unsigned long )menu != (unsigned long )((void *)0))) {
#line 615
      goto while_break;
    }
#line 617
    sym = menu->sym;
#line 618
    if ((unsigned long )sym == (unsigned long )((void *)0)) {
      {
#line 619
      tmp = menu_is_visible(menu);
      }
#line 619
      if (! tmp) {
#line 620
        goto next_menu;
      }
    } else {
      {
#line 621
      tmp___8 = sym_is_choice(sym);
      }
#line 621
      if (! tmp___8) {
        {
#line 622
        sym_calc_value(sym);
        }
#line 623
        if (! (sym->flags & 512)) {
#line 624
          goto next_menu;
        }
        {
#line 625
        sym->flags &= -513;
#line 627
        tmp___0 = sym_is_changable(sym);
        }
#line 627
        if (! tmp___0) {
#line 628
          goto next_menu;
        }
        {
#line 630
        tmp___1 = sym_get_string_default(sym);
#line 630
        tmp___2 = sym_get_string_value(sym);
#line 630
        tmp___3 = strcmp(tmp___2, tmp___1);
        }
#line 630
        if (tmp___3 == 0) {
#line 631
          goto next_menu;
        }
        {
#line 640
        tmp___7 = sym_is_choice_value(sym);
        }
#line 640
        if (tmp___7) {
          {
#line 644
          tmp___4 = sym_get_choice_prop(sym);
#line 644
          cs = prop_get_symbol(tmp___4);
#line 645
          ds = sym_choice_default(cs);
#line 646
          tmp___6 = sym_is_optional(cs);
          }
#line 646
          if (! tmp___6) {
#line 646
            if ((unsigned long )sym == (unsigned long )ds) {
#line 647
              if ((unsigned int )sym->type == 1U) {
                {
#line 647
                tmp___5 = sym_get_tristate_value(sym);
                }
#line 647
                if ((unsigned int )tmp___5 == 2U) {
#line 649
                  goto next_menu;
                }
              }
            }
          }
        }
        {
#line 652
        conf_write_symbol(out, sym, & kconfig_printer_cb, (void *)0);
        }
      }
    }
    next_menu: 
#line 655
    if ((unsigned long )menu->list != (unsigned long )((void *)0)) {
#line 656
      menu = menu->list;
    } else
#line 658
    if ((unsigned long )menu->next != (unsigned long )((void *)0)) {
#line 659
      menu = menu->next;
    } else {
      {
#line 661
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 661
        menu = menu->parent;
#line 661
        if (! menu) {
#line 661
          goto while_break___0;
        }
#line 662
        if ((unsigned long )menu->next != (unsigned long )((void *)0)) {
#line 663
          menu = menu->next;
#line 664
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 669
  fclose(out);
  }
#line 670
  return (0);
}
}
#line 673 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/confdata.c"
int conf_write(char const   *name ) 
{ 
  FILE *out ;
  struct symbol *sym ;
  struct menu *menu ;
  char const   *basename ;
  char const   *str ;
  char dirname[4097] ;
  char tmpname[4097] ;
  char newname[4097] ;
  char *env ;
  struct stat st ;
  char *slash ;
  int size ;
  int tmp ;
  __pid_t tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;

  {
#line 683
  dirname[0] = (char)0;
#line 684
  if (name) {
#line 684
    if (*(name + 0)) {
      {
#line 688
      tmp = stat((char const   */* __restrict  */)name, (struct stat */* __restrict  */)(& st));
      }
#line 688
      if (tmp) {
        _L: /* CIL Label */ 
        {
#line 692
        slash = strrchr(name, '/');
        }
#line 692
        if (slash) {
          {
#line 693
          size = (int )((slash - (char *)name) + 1L);
#line 694
          memcpy((void */* __restrict  */)(dirname), (void const   */* __restrict  */)name,
                 (size_t )size);
#line 695
          dirname[size] = (char)0;
          }
#line 696
          if (*(slash + 1)) {
#line 697
            basename = (char const   *)(slash + 1);
          } else {
            {
#line 699
            basename = conf_get_configname();
            }
          }
        } else {
#line 701
          basename = name;
        }
      } else
#line 688
      if ((st.st_mode & 61440U) == 16384U) {
        {
#line 689
        strcpy((char */* __restrict  */)(dirname), (char const   */* __restrict  */)name);
#line 690
        strcat((char */* __restrict  */)(dirname), (char const   */* __restrict  */)"/");
#line 691
        basename = conf_get_configname();
        }
      } else {
#line 688
        goto _L;
      }
    } else {
      {
#line 703
      basename = conf_get_configname();
      }
    }
  } else {
    {
#line 703
    basename = conf_get_configname();
    }
  }
  {
#line 705
  sprintf((char */* __restrict  */)(newname), (char const   */* __restrict  */)"%s%s",
          dirname, basename);
#line 706
  env = getenv("KCONFIG_OVERWRITECONFIG");
  }
#line 707
  if (! env) {
    {
#line 708
    tmp___0 = getpid();
#line 708
    sprintf((char */* __restrict  */)(tmpname), (char const   */* __restrict  */)"%s.tmpconfig.%d",
            dirname, tmp___0);
#line 709
    out = fopen((char const   */* __restrict  */)(tmpname), (char const   */* __restrict  */)"w");
    }
  } else
#line 707
  if (! *env) {
    {
#line 708
    tmp___0 = getpid();
#line 708
    sprintf((char */* __restrict  */)(tmpname), (char const   */* __restrict  */)"%s.tmpconfig.%d",
            dirname, tmp___0);
#line 709
    out = fopen((char const   */* __restrict  */)(tmpname), (char const   */* __restrict  */)"w");
    }
  } else {
    {
#line 711
    tmpname[0] = (char)0;
#line 712
    out = fopen((char const   */* __restrict  */)(newname), (char const   */* __restrict  */)"w");
    }
  }
#line 714
  if (! out) {
#line 715
    return (1);
  }
  {
#line 717
  conf_write_heading(out, & kconfig_printer_cb, (void *)0);
#line 719
  tmp___1 = conf_get_changed();
  }
#line 719
  if (! tmp___1) {
    {
#line 720
    sym_clear_all_valid();
    }
  }
#line 722
  menu = rootmenu.list;
  {
#line 723
  while (1) {
    while_continue: /* CIL Label */ ;
#line 723
    if (! menu) {
#line 723
      goto while_break;
    }
#line 724
    sym = menu->sym;
#line 725
    if (! sym) {
      {
#line 726
      tmp___2 = menu_is_visible(menu);
      }
#line 726
      if (! tmp___2) {
#line 727
        goto next;
      }
      {
#line 728
      str = menu_get_prompt(menu);
#line 729
      fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)"\n#\n# %s\n#\n",
              str);
      }
    } else
#line 733
    if (! (sym->flags & 16)) {
      {
#line 734
      sym_calc_value(sym);
      }
#line 735
      if (! (sym->flags & 512)) {
#line 736
        goto next;
      }
      {
#line 737
      sym->flags &= -513;
#line 739
      conf_write_symbol(out, sym, & kconfig_printer_cb, (void *)0);
      }
    }
    next: 
#line 743
    if (menu->list) {
#line 744
      menu = menu->list;
#line 745
      goto while_continue;
    }
#line 747
    if (menu->next) {
#line 748
      menu = menu->next;
    } else {
      {
#line 749
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 749
        menu = menu->parent;
#line 749
        if (! menu) {
#line 749
          goto while_break___0;
        }
#line 750
        if (menu->next) {
#line 751
          menu = menu->next;
#line 752
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 756
  fclose(out);
  }
#line 758
  if (tmpname[0]) {
    {
#line 759
    strcat((char */* __restrict  */)(dirname), (char const   */* __restrict  */)basename);
#line 760
    strcat((char */* __restrict  */)(dirname), (char const   */* __restrict  */)".old");
#line 761
    rename((char const   *)(newname), (char const   *)(dirname));
#line 762
    tmp___3 = rename((char const   *)(tmpname), (char const   *)(newname));
    }
#line 762
    if (tmp___3) {
#line 763
      return (1);
    }
  }
  {
#line 766
  tmp___4 = gettext("configuration written to %s");
#line 766
  conf_message((char const   *)tmp___4, newname);
#line 768
  sym_set_change_count(0);
  }
#line 770
  return (0);
}
}
#line 773 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/confdata.c"
static int conf_split_config(void) 
{ 
  char const   *name ;
  char path[4097] ;
  char *s ;
  char *d ;
  char c ;
  struct symbol *sym ;
  struct stat sb ;
  int res ;
  int i ;
  int fd ;
  int tmp ;
  tristate tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  tristate tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;

  {
  {
#line 782
  name = conf_get_autoconfig_name();
#line 783
  conf_read_simple(name, 1);
#line 785
  tmp = chdir("include/config");
  }
#line 785
  if (tmp) {
#line 786
    return (1);
  }
#line 788
  res = 0;
#line 789
  i = 0;
  {
#line 789
  while (1) {
    while_continue: /* CIL Label */ ;
#line 789
    if (! (i < 9973)) {
#line 789
      goto while_break;
    }
#line 789
    sym = symbol_hash[i];
    {
#line 789
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 789
      if (! sym) {
#line 789
        goto while_break___0;
      }
#line 789
      if ((unsigned int )sym->type != 6U) {
        {
#line 790
        sym_calc_value(sym);
        }
#line 791
        if (sym->flags & 4096) {
#line 792
          goto __Cont;
        } else
#line 791
        if (! sym->name) {
#line 792
          goto __Cont;
        }
#line 793
        if (sym->flags & 512) {
#line 794
          if (sym->flags & 131072) {
            {
#line 801
            if ((unsigned int )sym->type == 2U) {
#line 801
              goto case_2;
            }
#line 801
            if ((unsigned int )sym->type == 1U) {
#line 801
              goto case_2;
            }
#line 808
            if ((unsigned int )sym->type == 3U) {
#line 808
              goto case_3;
            }
#line 808
            if ((unsigned int )sym->type == 4U) {
#line 808
              goto case_3;
            }
#line 808
            if ((unsigned int )sym->type == 5U) {
#line 808
              goto case_3;
            }
#line 813
            goto switch_default;
            case_2: /* CIL Label */ 
            case_1: /* CIL Label */ 
            {
#line 802
            tmp___0 = sym_get_tristate_value(sym);
            }
#line 802
            if ((unsigned int )tmp___0 == (unsigned int )sym->def[1].tri) {
#line 804
              goto __Cont;
            }
#line 805
            goto switch_break;
            case_3: /* CIL Label */ 
            case_4: /* CIL Label */ 
            case_5: /* CIL Label */ 
            {
#line 809
            tmp___1 = sym_get_string_value(sym);
#line 809
            tmp___2 = strcmp(tmp___1, (char const   *)sym->def[1].val);
            }
#line 809
            if (! tmp___2) {
#line 811
              goto __Cont;
            }
#line 812
            goto switch_break;
            switch_default: /* CIL Label */ 
#line 814
            goto switch_break;
            switch_break: /* CIL Label */ ;
            }
          } else {
            {
#line 823
            if ((unsigned int )sym->type == 2U) {
#line 823
              goto case_2___0;
            }
#line 823
            if ((unsigned int )sym->type == 1U) {
#line 823
              goto case_2___0;
            }
#line 827
            goto switch_default___0;
            case_2___0: /* CIL Label */ 
            case_1___0: /* CIL Label */ 
            {
#line 824
            tmp___3 = sym_get_tristate_value(sym);
            }
#line 824
            if ((unsigned int )tmp___3 == 0U) {
#line 825
              goto __Cont;
            }
#line 826
            goto switch_break___0;
            switch_default___0: /* CIL Label */ 
#line 828
            goto switch_break___0;
            switch_break___0: /* CIL Label */ ;
            }
          }
        } else
#line 831
        if (! (sym->flags & 131072)) {
#line 833
          goto __Cont;
        }
#line 841
        s = sym->name;
#line 842
        d = path;
        {
#line 843
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 843
          tmp___6 = s;
#line 843
          s ++;
#line 843
          c = *tmp___6;
#line 843
          if (! c) {
#line 843
            goto while_break___1;
          }
          {
#line 844
          tmp___4 = tolower((int )c);
#line 844
          c = (char )tmp___4;
#line 845
          tmp___5 = d;
#line 845
          d ++;
          }
#line 845
          if ((int )c == 95) {
#line 845
            *tmp___5 = (char )'/';
          } else {
#line 845
            *tmp___5 = c;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 847
        strcpy((char */* __restrict  */)d, (char const   */* __restrict  */)".h");
#line 850
        fd = open((char const   *)(path), 577, 420);
        }
#line 851
        if (fd == -1) {
          {
#line 852
          tmp___7 = __errno_location();
          }
#line 852
          if (*tmp___7 != 2) {
#line 853
            res = 1;
#line 854
            goto while_break___0;
          }
#line 860
          d = path;
          {
#line 861
          while (1) {
            while_continue___2: /* CIL Label */ ;
            {
#line 861
            d = strchr((char const   *)d, '/');
            }
#line 861
            if (! d) {
#line 861
              goto while_break___2;
            }
            {
#line 862
            *d = (char)0;
#line 863
            tmp___8 = stat((char const   */* __restrict  */)(path), (struct stat */* __restrict  */)(& sb));
            }
#line 863
            if (tmp___8) {
              {
#line 863
              tmp___9 = mkdir((char const   *)(path), (__mode_t )493);
              }
#line 863
              if (tmp___9) {
#line 864
                res = 1;
#line 865
                goto out;
              }
            }
#line 867
            tmp___10 = d;
#line 867
            d ++;
#line 867
            *tmp___10 = (char )'/';
          }
          while_break___2: /* CIL Label */ ;
          }
          {
#line 870
          fd = open((char const   *)(path), 577, 420);
          }
#line 871
          if (fd == -1) {
#line 872
            res = 1;
#line 873
            goto while_break___0;
          }
        }
        {
#line 876
        close(fd);
        }
      }
      __Cont: /* CIL Label */ 
#line 789
      sym = sym->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 789
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  out: 
  {
#line 879
  tmp___11 = chdir("../..");
  }
#line 879
  if (tmp___11) {
#line 880
    return (1);
  }
#line 882
  return (res);
}
}
#line 885 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/confdata.c"
int conf_write_autoconf(void) 
{ 
  struct symbol *sym ;
  char const   *name ;
  FILE *out ;
  FILE *tristate___0 ;
  FILE *out_h ;
  int i ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 892
  sym_clear_all_valid();
#line 894
  file_write_dep("include/config/auto.conf.cmd");
#line 896
  tmp = conf_split_config();
  }
#line 896
  if (tmp) {
#line 897
    return (1);
  }
  {
#line 899
  out = fopen((char const   */* __restrict  */)".tmpconfig", (char const   */* __restrict  */)"w");
  }
#line 900
  if (! out) {
#line 901
    return (1);
  }
  {
#line 903
  tristate___0 = fopen((char const   */* __restrict  */)".tmpconfig_tristate", (char const   */* __restrict  */)"w");
  }
#line 904
  if (! tristate___0) {
    {
#line 905
    fclose(out);
    }
#line 906
    return (1);
  }
  {
#line 909
  out_h = fopen((char const   */* __restrict  */)".tmpconfig.h", (char const   */* __restrict  */)"w");
  }
#line 910
  if (! out_h) {
    {
#line 911
    fclose(out);
#line 912
    fclose(tristate___0);
    }
#line 913
    return (1);
  }
  {
#line 916
  conf_write_heading(out, & kconfig_printer_cb, (void *)0);
#line 918
  conf_write_heading(tristate___0, & tristate_printer_cb, (void *)0);
#line 920
  conf_write_heading(out_h, & header_printer_cb, (void *)0);
#line 922
  i = 0;
  }
  {
#line 922
  while (1) {
    while_continue: /* CIL Label */ ;
#line 922
    if (! (i < 9973)) {
#line 922
      goto while_break;
    }
#line 922
    sym = symbol_hash[i];
    {
#line 922
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 922
      if (! sym) {
#line 922
        goto while_break___0;
      }
#line 922
      if ((unsigned int )sym->type != 6U) {
        {
#line 923
        sym_calc_value(sym);
        }
#line 924
        if (! (sym->flags & 512)) {
#line 925
          goto __Cont;
        } else
#line 924
        if (! sym->name) {
#line 925
          goto __Cont;
        }
        {
#line 928
        conf_write_symbol(out, sym, & kconfig_printer_cb, (void *)1);
#line 930
        conf_write_symbol(tristate___0, sym, & tristate_printer_cb, (void *)1);
#line 932
        conf_write_symbol(out_h, sym, & header_printer_cb, (void *)0);
        }
      }
      __Cont: /* CIL Label */ 
#line 922
      sym = sym->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 922
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 934
  fclose(out);
#line 935
  fclose(tristate___0);
#line 936
  fclose(out_h);
#line 938
  tmp___0 = getenv("KCONFIG_AUTOHEADER");
#line 938
  name = (char const   *)tmp___0;
  }
#line 939
  if (! name) {
#line 940
    name = "include/generated/autoconf.h";
  }
  {
#line 941
  tmp___1 = rename(".tmpconfig.h", name);
  }
#line 941
  if (tmp___1) {
#line 942
    return (1);
  }
  {
#line 943
  tmp___2 = getenv("KCONFIG_TRISTATE");
#line 943
  name = (char const   *)tmp___2;
  }
#line 944
  if (! name) {
#line 945
    name = "include/config/tristate.conf";
  }
  {
#line 946
  tmp___3 = rename(".tmpconfig_tristate", name);
  }
#line 946
  if (tmp___3) {
#line 947
    return (1);
  }
  {
#line 948
  name = conf_get_autoconfig_name();
#line 953
  tmp___4 = rename(".tmpconfig", name);
  }
#line 953
  if (tmp___4) {
#line 954
    return (1);
  }
#line 956
  return (0);
}
}
#line 959 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/confdata.c"
static int sym_change_count  ;
#line 960 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/confdata.c"
static void (*conf_changed_callback)(void)  ;
#line 962 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/confdata.c"
void sym_set_change_count(int count ) 
{ 
  int _sym_change_count ;

  {
#line 964
  _sym_change_count = sym_change_count;
#line 965
  sym_change_count = count;
#line 966
  if (conf_changed_callback) {
#line 966
    if ((int )((_Bool )_sym_change_count) != (int )((_Bool )count)) {
      {
#line 968
      (*conf_changed_callback)();
      }
    }
  }
#line 969
  return;
}
}
#line 971 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/confdata.c"
void sym_add_change_count(int count ) 
{ 


  {
  {
#line 973
  sym_set_change_count(count + sym_change_count);
  }
#line 974
  return;
}
}
#line 976 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/confdata.c"
_Bool conf_get_changed(void) 
{ 


  {
#line 978
  return ((_Bool )sym_change_count);
}
}
#line 981 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/confdata.c"
void conf_set_changed_callback(void (*fn)(void) ) 
{ 


  {
#line 983
  conf_changed_callback = fn;
#line 984
  return;
}
}
#line 986 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/confdata.c"
static void randomize_choice_values(struct symbol *csym ) 
{ 
  struct property *prop ;
  struct symbol *sym ;
  struct expr *e ;
  int cnt ;
  int def ;
  int tmp ;
  int tmp___0 ;

  {
#line 998
  if ((unsigned int )csym->curr.tri != 2U) {
#line 999
    return;
  }
  {
#line 1001
  prop = sym_get_choice_prop(csym);
#line 1004
  cnt = 0;
#line 1005
  e = prop->expr;
  }
  {
#line 1005
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1005
    if (e) {
#line 1005
      sym = e->right.sym;
#line 1005
      if (! sym) {
#line 1005
        goto while_break;
      }
    } else {
#line 1005
      goto while_break;
    }
#line 1006
    cnt ++;
#line 1005
    e = e->left.expr;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1012
  tmp = rand();
#line 1012
  def = tmp % cnt;
#line 1014
  cnt = 0;
#line 1015
  e = prop->expr;
  }
  {
#line 1015
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1015
    if (e) {
#line 1015
      sym = e->right.sym;
#line 1015
      if (! sym) {
#line 1015
        goto while_break___0;
      }
    } else {
#line 1015
      goto while_break___0;
    }
#line 1016
    tmp___0 = cnt;
#line 1016
    cnt ++;
#line 1016
    if (def == tmp___0) {
#line 1017
      sym->def[0].tri = (tristate )2;
#line 1018
      csym->def[0].val = (void *)sym;
    } else {
#line 1021
      sym->def[0].tri = (tristate )0;
    }
#line 1015
    e = e->left.expr;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1024
  csym->flags |= 65536;
#line 1026
  csym->flags &= -129;
#line 1027
  return;
}
}
#line 1029 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/confdata.c"
static void set_all_choice_values(struct symbol *csym ) 
{ 
  struct property *prop ;
  struct symbol *sym ;
  struct expr *e ;
  _Bool tmp ;

  {
  {
#line 1035
  prop = sym_get_choice_prop(csym);
#line 1040
  e = prop->expr;
  }
  {
#line 1040
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1040
    if (e) {
#line 1040
      sym = e->right.sym;
#line 1040
      if (! sym) {
#line 1040
        goto while_break;
      }
    } else {
#line 1040
      goto while_break;
    }
    {
#line 1041
    tmp = sym_has_value(sym);
    }
#line 1041
    if (! tmp) {
#line 1042
      sym->def[0].tri = (tristate )0;
    }
#line 1040
    e = e->left.expr;
  }
  while_break: /* CIL Label */ ;
  }
#line 1044
  csym->flags |= 65536;
#line 1046
  csym->flags &= -129;
#line 1047
  return;
}
}
#line 1049 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/confdata.c"
void conf_set_all_new_symbols(enum conf_def_mode mode ) 
{ 
  struct symbol *sym ;
  struct symbol *csym ;
  int i ;
  int cnt ;
  _Bool tmp ;
  enum symbol_type tmp___0 ;
  enum symbol_type tmp___2 ;
  int tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;
  _Bool tmp___6 ;

  {
#line 1054
  i = 0;
  {
#line 1054
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1054
    if (! (i < 9973)) {
#line 1054
      goto while_break;
    }
#line 1054
    sym = symbol_hash[i];
    {
#line 1054
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1054
      if (! sym) {
#line 1054
        goto while_break___0;
      }
#line 1054
      if ((unsigned int )sym->type != 6U) {
        {
#line 1055
        tmp = sym_has_value(sym);
        }
#line 1055
        if (tmp) {
#line 1056
          goto __Cont;
        }
        {
#line 1057
        tmp___0 = sym_get_type(sym);
        }
        {
#line 1059
        if ((unsigned int )tmp___0 == 2U) {
#line 1059
          goto case_2;
        }
#line 1059
        if ((unsigned int )tmp___0 == 1U) {
#line 1059
          goto case_2;
        }
#line 1080
        goto switch_default___0;
        case_2: /* CIL Label */ 
        case_1: /* CIL Label */ 
        {
#line 1061
        if ((unsigned int )mode == 1U) {
#line 1061
          goto case_1___0;
        }
#line 1064
        if ((unsigned int )mode == 2U) {
#line 1064
          goto case_2___0;
        }
#line 1067
        if ((unsigned int )mode == 3U) {
#line 1067
          goto case_3;
        }
#line 1070
        if ((unsigned int )mode == 4U) {
#line 1070
          goto case_4;
        }
#line 1074
        goto switch_default;
        case_1___0: /* CIL Label */ 
#line 1062
        sym->def[0].tri = (tristate )2;
#line 1063
        goto switch_break___0;
        case_2___0: /* CIL Label */ 
#line 1065
        sym->def[0].tri = (tristate )1;
#line 1066
        goto switch_break___0;
        case_3: /* CIL Label */ 
#line 1068
        sym->def[0].tri = (tristate )0;
#line 1069
        goto switch_break___0;
        case_4: /* CIL Label */ 
        {
#line 1071
        tmp___2 = sym_get_type(sym);
        }
#line 1071
        if ((unsigned int )tmp___2 == 2U) {
#line 1071
          cnt = 3;
        } else {
#line 1071
          cnt = 2;
        }
        {
#line 1072
        tmp___3 = rand();
#line 1072
        sym->def[0].tri = (tristate )(tmp___3 % cnt);
        }
#line 1073
        goto switch_break___0;
        switch_default: /* CIL Label */ 
#line 1075
        goto __Cont;
        switch_break___0: /* CIL Label */ ;
        }
        {
#line 1077
        tmp___4 = sym_is_choice(sym);
        }
#line 1077
        if (tmp___4) {
#line 1077
          if (! ((unsigned int )mode == 4U)) {
#line 1078
            sym->flags |= 65536;
          }
        } else {
#line 1078
          sym->flags |= 65536;
        }
#line 1079
        goto switch_break;
        switch_default___0: /* CIL Label */ 
#line 1081
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
      __Cont: /* CIL Label */ 
#line 1054
      sym = sym->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1054
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1086
  sym_clear_all_valid();
#line 1097
  i = 0;
  }
  {
#line 1097
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1097
    if (! (i < 9973)) {
#line 1097
      goto while_break___1;
    }
#line 1097
    csym = symbol_hash[i];
    {
#line 1097
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1097
      if (! csym) {
#line 1097
        goto while_break___2;
      }
#line 1097
      if ((unsigned int )csym->type != 6U) {
        {
#line 1098
        tmp___5 = sym_has_value(csym);
        }
#line 1098
        if (tmp___5) {
#line 1099
          goto __Cont___0;
        } else {
          {
#line 1098
          tmp___6 = sym_is_choice(csym);
          }
#line 1098
          if (! tmp___6) {
#line 1099
            goto __Cont___0;
          }
        }
        {
#line 1101
        sym_calc_value(csym);
        }
#line 1102
        if ((unsigned int )mode == 4U) {
          {
#line 1103
          randomize_choice_values(csym);
          }
        } else {
          {
#line 1105
          set_all_choice_values(csym);
          }
        }
      }
      __Cont___0: /* CIL Label */ 
#line 1097
      csym = csym->next;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1097
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1107
  return;
}
}
#line 14 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/expr.c"
struct expr *expr_alloc_symbol(struct symbol *sym ) 
{ 
  struct expr *e ;
  void *tmp ;

  {
  {
#line 16
  tmp = calloc((size_t )1, sizeof(*e));
#line 16
  e = (struct expr *)tmp;
#line 17
  e->type = (enum expr_type )7;
#line 18
  e->left.sym = sym;
  }
#line 19
  return (e);
}
}
#line 22 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/expr.c"
struct expr *expr_alloc_one(enum expr_type type , struct expr *ce ) 
{ 
  struct expr *e ;
  void *tmp ;

  {
  {
#line 24
  tmp = calloc((size_t )1, sizeof(*e));
#line 24
  e = (struct expr *)tmp;
#line 25
  e->type = type;
#line 26
  e->left.expr = ce;
  }
#line 27
  return (e);
}
}
#line 30 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/expr.c"
struct expr *expr_alloc_two(enum expr_type type , struct expr *e1 , struct expr *e2 ) 
{ 
  struct expr *e ;
  void *tmp ;

  {
  {
#line 32
  tmp = calloc((size_t )1, sizeof(*e));
#line 32
  e = (struct expr *)tmp;
#line 33
  e->type = type;
#line 34
  e->left.expr = e1;
#line 35
  e->right.expr = e2;
  }
#line 36
  return (e);
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/expr.c"
struct expr *expr_alloc_comp(enum expr_type type , struct symbol *s1 , struct symbol *s2 ) 
{ 
  struct expr *e ;
  void *tmp ;

  {
  {
#line 41
  tmp = calloc((size_t )1, sizeof(*e));
#line 41
  e = (struct expr *)tmp;
#line 42
  e->type = type;
#line 43
  e->left.sym = s1;
#line 44
  e->right.sym = s2;
  }
#line 45
  return (e);
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/expr.c"
struct expr *expr_alloc_and(struct expr *e1 , struct expr *e2 ) 
{ 
  struct expr *tmp ;
  struct expr *tmp___0 ;

  {
#line 50
  if (! e1) {
#line 51
    return (e2);
  }
#line 52
  if (e2) {
    {
#line 52
    tmp = expr_alloc_two((enum expr_type )2, e1, e2);
#line 52
    tmp___0 = tmp;
    }
  } else {
#line 52
    tmp___0 = e1;
  }
#line 52
  return (tmp___0);
}
}
#line 55 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/expr.c"
struct expr *expr_alloc_or(struct expr *e1 , struct expr *e2 ) 
{ 
  struct expr *tmp ;
  struct expr *tmp___0 ;

  {
#line 57
  if (! e1) {
#line 58
    return (e2);
  }
#line 59
  if (e2) {
    {
#line 59
    tmp = expr_alloc_two((enum expr_type )1, e1, e2);
#line 59
    tmp___0 = tmp;
    }
  } else {
#line 59
    tmp___0 = e1;
  }
#line 59
  return (tmp___0);
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/expr.c"
struct expr *expr_copy(struct expr  const  *org ) 
{ 
  struct expr *e ;
  void *tmp ;

  {
#line 66
  if (! org) {
#line 67
    return ((struct expr *)((void *)0));
  }
  {
#line 69
  tmp = malloc(sizeof(*org));
#line 69
  e = (struct expr *)tmp;
#line 70
  memcpy((void */* __restrict  */)e, (void const   */* __restrict  */)org, sizeof(*org));
  }
  {
#line 72
  if ((unsigned int const   )org->type == 7U) {
#line 72
    goto case_7;
  }
#line 75
  if ((unsigned int const   )org->type == 3U) {
#line 75
    goto case_3;
  }
#line 79
  if ((unsigned int const   )org->type == 5U) {
#line 79
    goto case_5;
  }
#line 79
  if ((unsigned int const   )org->type == 4U) {
#line 79
    goto case_5;
  }
#line 85
  if ((unsigned int const   )org->type == 6U) {
#line 85
    goto case_6;
  }
#line 85
  if ((unsigned int const   )org->type == 1U) {
#line 85
    goto case_6;
  }
#line 85
  if ((unsigned int const   )org->type == 2U) {
#line 85
    goto case_6;
  }
#line 89
  goto switch_default;
  case_7: /* CIL Label */ 
#line 73
  e->left = (union expr_data )org->left;
#line 74
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 76
  e->left.expr = expr_copy((struct expr  const  *)org->left.expr);
  }
#line 77
  goto switch_break;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 80
  e->left.sym = (struct symbol *)org->left.sym;
#line 81
  e->right.sym = (struct symbol *)org->right.sym;
#line 82
  goto switch_break;
  case_6: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 86
  e->left.expr = expr_copy((struct expr  const  *)org->left.expr);
#line 87
  e->right.expr = expr_copy((struct expr  const  *)org->right.expr);
  }
#line 88
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 90
  printf((char const   */* __restrict  */)"can\'t copy type %d\n", (unsigned int )e->type);
#line 91
  free((void *)e);
#line 92
  e = (struct expr *)((void *)0);
  }
#line 93
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 96
  return (e);
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/expr.c"
void expr_free(struct expr *e ) 
{ 


  {
#line 101
  if (! e) {
#line 102
    return;
  }
  {
#line 105
  if ((unsigned int )e->type == 7U) {
#line 105
    goto case_7;
  }
#line 107
  if ((unsigned int )e->type == 3U) {
#line 107
    goto case_3;
  }
#line 111
  if ((unsigned int )e->type == 5U) {
#line 111
    goto case_5;
  }
#line 111
  if ((unsigned int )e->type == 4U) {
#line 111
    goto case_5;
  }
#line 114
  if ((unsigned int )e->type == 2U) {
#line 114
    goto case_2;
  }
#line 114
  if ((unsigned int )e->type == 1U) {
#line 114
    goto case_2;
  }
#line 118
  goto switch_default;
  case_7: /* CIL Label */ 
#line 106
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 108
  expr_free(e->left.expr);
  }
#line 109
  return;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 112
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 115
  expr_free(e->left.expr);
#line 116
  expr_free(e->right.expr);
  }
#line 117
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 119
  printf((char const   */* __restrict  */)"how to free type %d?\n", (unsigned int )e->type);
  }
#line 120
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 122
  free((void *)e);
  }
#line 123
  return;
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/expr.c"
static int trans_count  ;
#line 130 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/expr.c"
static void __expr_eliminate_eq(enum expr_type type , struct expr **ep1 , struct expr **ep2 ) 
{ 
  int tmp ;

  {
#line 132
  if ((unsigned int )(*ep1)->type == (unsigned int )type) {
    {
#line 133
    __expr_eliminate_eq(type, & (*ep1)->left.expr, ep2);
#line 134
    __expr_eliminate_eq(type, & (*ep1)->right.expr, ep2);
    }
#line 135
    return;
  }
#line 137
  if ((unsigned int )(*ep2)->type == (unsigned int )type) {
    {
#line 138
    __expr_eliminate_eq(type, ep1, & (*ep2)->left.expr);
#line 139
    __expr_eliminate_eq(type, ep1, & (*ep2)->right.expr);
    }
#line 140
    return;
  }
#line 142
  if ((unsigned int )(*ep1)->type == 7U) {
#line 142
    if ((unsigned int )(*ep2)->type == 7U) {
#line 142
      if ((unsigned long )(*ep1)->left.sym == (unsigned long )(*ep2)->left.sym) {
#line 142
        if ((unsigned long )(*ep1)->left.sym == (unsigned long )(& symbol_yes)) {
#line 145
          return;
        } else
#line 142
        if ((unsigned long )(*ep1)->left.sym == (unsigned long )(& symbol_no)) {
#line 145
          return;
        }
      }
    }
  }
  {
#line 146
  tmp = expr_eq(*ep1, *ep2);
  }
#line 146
  if (! tmp) {
#line 147
    return;
  }
  {
#line 148
  trans_count ++;
#line 149
  expr_free(*ep1);
#line 149
  expr_free(*ep2);
  }
  {
#line 151
  if ((unsigned int )type == 1U) {
#line 151
    goto case_1;
  }
#line 155
  if ((unsigned int )type == 2U) {
#line 155
    goto case_2;
  }
#line 159
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 152
  *ep1 = expr_alloc_symbol(& symbol_no);
#line 153
  *ep2 = expr_alloc_symbol(& symbol_no);
  }
#line 154
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 156
  *ep1 = expr_alloc_symbol(& symbol_yes);
#line 157
  *ep2 = expr_alloc_symbol(& symbol_yes);
  }
#line 158
  goto switch_break;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 162
  return;
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/expr.c"
void expr_eliminate_eq(struct expr **ep1 , struct expr **ep2 ) 
{ 


  {
#line 166
  if (! *ep1) {
#line 167
    return;
  } else
#line 166
  if (! *ep2) {
#line 167
    return;
  }
  {
#line 170
  if ((unsigned int )(*ep1)->type == 2U) {
#line 170
    goto case_2;
  }
#line 170
  if ((unsigned int )(*ep1)->type == 1U) {
#line 170
    goto case_2;
  }
#line 172
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 171
  __expr_eliminate_eq((*ep1)->type, ep1, ep2);
  }
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 175
  if ((unsigned int )(*ep1)->type != (unsigned int )(*ep2)->type) {
    {
#line 177
    if ((unsigned int )(*ep2)->type == 2U) {
#line 177
      goto case_2___0;
    }
#line 177
    if ((unsigned int )(*ep2)->type == 1U) {
#line 177
      goto case_2___0;
    }
#line 179
    goto switch_default___0;
    case_2___0: /* CIL Label */ 
    case_1___0: /* CIL Label */ 
    {
#line 178
    __expr_eliminate_eq((*ep2)->type, ep1, ep2);
    }
    switch_default___0: /* CIL Label */ ;
    switch_break___0: /* CIL Label */ ;
    }
  }
  {
#line 182
  *ep1 = expr_eliminate_yn(*ep1);
#line 183
  *ep2 = expr_eliminate_yn(*ep2);
  }
#line 184
  return;
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/expr.c"
int expr_eq(struct expr *e1 , struct expr *e2 ) 
{ 
  int res ;
  int old_count ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 193
  if ((unsigned int )e1->type != (unsigned int )e2->type) {
#line 194
    return (0);
  }
  {
#line 197
  if ((unsigned int )e1->type == 5U) {
#line 197
    goto case_5;
  }
#line 197
  if ((unsigned int )e1->type == 4U) {
#line 197
    goto case_5;
  }
#line 199
  if ((unsigned int )e1->type == 7U) {
#line 199
    goto case_7;
  }
#line 201
  if ((unsigned int )e1->type == 3U) {
#line 201
    goto case_3;
  }
#line 204
  if ((unsigned int )e1->type == 1U) {
#line 204
    goto case_1;
  }
#line 204
  if ((unsigned int )e1->type == 2U) {
#line 204
    goto case_1;
  }
#line 217
  if ((unsigned int )e1->type == 0U) {
#line 217
    goto case_0;
  }
#line 217
  if ((unsigned int )e1->type == 8U) {
#line 217
    goto case_0;
  }
#line 217
  if ((unsigned int )e1->type == 6U) {
#line 217
    goto case_0;
  }
#line 195
  goto switch_break;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 198
  if ((unsigned long )e1->left.sym == (unsigned long )e2->left.sym) {
#line 198
    if ((unsigned long )e1->right.sym == (unsigned long )e2->right.sym) {
#line 198
      tmp = 1;
    } else {
#line 198
      tmp = 0;
    }
  } else {
#line 198
    tmp = 0;
  }
#line 198
  return (tmp);
  case_7: /* CIL Label */ 
#line 200
  return ((unsigned long )e1->left.sym == (unsigned long )e2->left.sym);
  case_3: /* CIL Label */ 
  {
#line 202
  tmp___0 = expr_eq(e1->left.expr, e2->left.expr);
  }
#line 202
  return (tmp___0);
  case_1: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 205
  e1 = expr_copy((struct expr  const  *)e1);
#line 206
  e2 = expr_copy((struct expr  const  *)e2);
#line 207
  old_count = trans_count;
#line 208
  expr_eliminate_eq(& e1, & e2);
  }
#line 209
  if ((unsigned int )e1->type == 7U) {
#line 209
    if ((unsigned int )e2->type == 7U) {
#line 209
      if ((unsigned long )e1->left.sym == (unsigned long )e2->left.sym) {
#line 209
        tmp___1 = 1;
      } else {
#line 209
        tmp___1 = 0;
      }
    } else {
#line 209
      tmp___1 = 0;
    }
  } else {
#line 209
    tmp___1 = 0;
  }
  {
#line 209
  res = tmp___1;
#line 211
  expr_free(e1);
#line 212
  expr_free(e2);
#line 213
  trans_count = old_count;
  }
#line 214
  return (res);
  case_0: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_6: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 228
  return (0);
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/expr.c"
struct expr *expr_eliminate_yn(struct expr *e ) 
{ 
  struct expr *tmp ;

  {
#line 235
  if (e) {
    {
#line 236
    if ((unsigned int )e->type == 2U) {
#line 236
      goto case_2;
    }
#line 272
    if ((unsigned int )e->type == 1U) {
#line 272
      goto case_1;
    }
#line 308
    goto switch_default;
    case_2: /* CIL Label */ 
    {
#line 237
    e->left.expr = expr_eliminate_yn(e->left.expr);
#line 238
    e->right.expr = expr_eliminate_yn(e->right.expr);
    }
#line 239
    if ((unsigned int )(e->left.expr)->type == 7U) {
#line 240
      if ((unsigned long )(e->left.expr)->left.sym == (unsigned long )(& symbol_no)) {
        {
#line 241
        expr_free(e->left.expr);
#line 242
        expr_free(e->right.expr);
#line 243
        e->type = (enum expr_type )7;
#line 244
        e->left.sym = & symbol_no;
#line 245
        e->right.expr = (struct expr *)((void *)0);
        }
#line 246
        return (e);
      } else
#line 247
      if ((unsigned long )(e->left.expr)->left.sym == (unsigned long )(& symbol_yes)) {
        {
#line 248
        free((void *)e->left.expr);
#line 249
        tmp = e->right.expr;
#line 250
        *e = *(e->right.expr);
#line 251
        free((void *)tmp);
        }
#line 252
        return (e);
      }
    }
#line 255
    if ((unsigned int )(e->right.expr)->type == 7U) {
#line 256
      if ((unsigned long )(e->right.expr)->left.sym == (unsigned long )(& symbol_no)) {
        {
#line 257
        expr_free(e->left.expr);
#line 258
        expr_free(e->right.expr);
#line 259
        e->type = (enum expr_type )7;
#line 260
        e->left.sym = & symbol_no;
#line 261
        e->right.expr = (struct expr *)((void *)0);
        }
#line 262
        return (e);
      } else
#line 263
      if ((unsigned long )(e->right.expr)->left.sym == (unsigned long )(& symbol_yes)) {
        {
#line 264
        free((void *)e->right.expr);
#line 265
        tmp = e->left.expr;
#line 266
        *e = *(e->left.expr);
#line 267
        free((void *)tmp);
        }
#line 268
        return (e);
      }
    }
#line 271
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 273
    e->left.expr = expr_eliminate_yn(e->left.expr);
#line 274
    e->right.expr = expr_eliminate_yn(e->right.expr);
    }
#line 275
    if ((unsigned int )(e->left.expr)->type == 7U) {
#line 276
      if ((unsigned long )(e->left.expr)->left.sym == (unsigned long )(& symbol_no)) {
        {
#line 277
        free((void *)e->left.expr);
#line 278
        tmp = e->right.expr;
#line 279
        *e = *(e->right.expr);
#line 280
        free((void *)tmp);
        }
#line 281
        return (e);
      } else
#line 282
      if ((unsigned long )(e->left.expr)->left.sym == (unsigned long )(& symbol_yes)) {
        {
#line 283
        expr_free(e->left.expr);
#line 284
        expr_free(e->right.expr);
#line 285
        e->type = (enum expr_type )7;
#line 286
        e->left.sym = & symbol_yes;
#line 287
        e->right.expr = (struct expr *)((void *)0);
        }
#line 288
        return (e);
      }
    }
#line 291
    if ((unsigned int )(e->right.expr)->type == 7U) {
#line 292
      if ((unsigned long )(e->right.expr)->left.sym == (unsigned long )(& symbol_no)) {
        {
#line 293
        free((void *)e->right.expr);
#line 294
        tmp = e->left.expr;
#line 295
        *e = *(e->left.expr);
#line 296
        free((void *)tmp);
        }
#line 297
        return (e);
      } else
#line 298
      if ((unsigned long )(e->right.expr)->left.sym == (unsigned long )(& symbol_yes)) {
        {
#line 299
        expr_free(e->left.expr);
#line 300
        expr_free(e->right.expr);
#line 301
        e->type = (enum expr_type )7;
#line 302
        e->left.sym = & symbol_yes;
#line 303
        e->right.expr = (struct expr *)((void *)0);
        }
#line 304
        return (e);
      }
    }
#line 307
    goto switch_break;
    switch_default: /* CIL Label */ ;
    switch_break: /* CIL Label */ ;
    }
  }
#line 311
  return (e);
}
}
#line 317 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/expr.c"
struct expr *expr_trans_bool(struct expr *e ) 
{ 


  {
#line 319
  if (! e) {
#line 320
    return ((struct expr *)((void *)0));
  }
  {
#line 324
  if ((unsigned int )e->type == 3U) {
#line 324
    goto case_3;
  }
#line 324
  if ((unsigned int )e->type == 1U) {
#line 324
    goto case_3;
  }
#line 324
  if ((unsigned int )e->type == 2U) {
#line 324
    goto case_3;
  }
#line 328
  if ((unsigned int )e->type == 5U) {
#line 328
    goto case_5;
  }
#line 337
  goto switch_default;
  case_3: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 325
  e->left.expr = expr_trans_bool(e->left.expr);
#line 326
  e->right.expr = expr_trans_bool(e->right.expr);
  }
#line 327
  goto switch_break;
  case_5: /* CIL Label */ 
#line 330
  if ((unsigned int )(e->left.sym)->type == 2U) {
#line 331
    if ((unsigned long )e->right.sym == (unsigned long )(& symbol_no)) {
#line 332
      e->type = (enum expr_type )7;
#line 333
      e->right.sym = (struct symbol *)((void *)0);
    }
  }
#line 336
  goto switch_break;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 340
  return (e);
}
}
#line 346 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/expr.c"
static struct expr *expr_join_or(struct expr *e1 , struct expr *e2 ) 
{ 
  struct expr *tmp ;
  struct symbol *sym1 ;
  struct symbol *sym2 ;
  struct expr *tmp___0 ;
  int tmp___1 ;
  struct expr *tmp___2 ;
  struct expr *tmp___3 ;
  struct expr *tmp___4 ;
  struct expr *tmp___5 ;

  {
  {
#line 351
  tmp___1 = expr_eq(e1, e2);
  }
#line 351
  if (tmp___1) {
    {
#line 352
    tmp___0 = expr_copy((struct expr  const  *)e1);
    }
#line 352
    return (tmp___0);
  }
#line 353
  if ((unsigned int )e1->type != 4U) {
#line 353
    if ((unsigned int )e1->type != 5U) {
#line 353
      if ((unsigned int )e1->type != 7U) {
#line 353
        if ((unsigned int )e1->type != 3U) {
#line 354
          return ((struct expr *)((void *)0));
        }
      }
    }
  }
#line 355
  if ((unsigned int )e2->type != 4U) {
#line 355
    if ((unsigned int )e2->type != 5U) {
#line 355
      if ((unsigned int )e2->type != 7U) {
#line 355
        if ((unsigned int )e2->type != 3U) {
#line 356
          return ((struct expr *)((void *)0));
        }
      }
    }
  }
#line 357
  if ((unsigned int )e1->type == 3U) {
#line 358
    tmp = e1->left.expr;
#line 359
    if ((unsigned int )tmp->type != 4U) {
#line 359
      if ((unsigned int )tmp->type != 5U) {
#line 359
        if ((unsigned int )tmp->type != 7U) {
#line 360
          return ((struct expr *)((void *)0));
        }
      }
    }
#line 361
    sym1 = tmp->left.sym;
  } else {
#line 363
    sym1 = e1->left.sym;
  }
#line 364
  if ((unsigned int )e2->type == 3U) {
#line 365
    if ((unsigned int )(e2->left.expr)->type != 7U) {
#line 366
      return ((struct expr *)((void *)0));
    }
#line 367
    sym2 = (e2->left.expr)->left.sym;
  } else {
#line 369
    sym2 = e2->left.sym;
  }
#line 370
  if ((unsigned long )sym1 != (unsigned long )sym2) {
#line 371
    return ((struct expr *)((void *)0));
  }
#line 372
  if ((unsigned int )sym1->type != 1U) {
#line 372
    if ((unsigned int )sym1->type != 2U) {
#line 373
      return ((struct expr *)((void *)0));
    }
  }
#line 374
  if ((unsigned int )sym1->type == 2U) {
#line 375
    if ((unsigned int )e1->type == 4U) {
#line 375
      if ((unsigned int )e2->type == 4U) {
#line 375
        if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_yes)) {
#line 375
          if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_mod)) {
            {
#line 379
            tmp___2 = expr_alloc_comp((enum expr_type )5, sym1, & symbol_no);
            }
#line 379
            return (tmp___2);
          } else {
#line 375
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 375
        if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_mod)) {
#line 375
          if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_yes)) {
            {
#line 379
            tmp___2 = expr_alloc_comp((enum expr_type )5, sym1, & symbol_no);
            }
#line 379
            return (tmp___2);
          }
        }
      }
    }
#line 381
    if ((unsigned int )e1->type == 4U) {
#line 381
      if ((unsigned int )e2->type == 4U) {
#line 381
        if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_yes)) {
#line 381
          if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_no)) {
            {
#line 385
            tmp___3 = expr_alloc_comp((enum expr_type )5, sym1, & symbol_mod);
            }
#line 385
            return (tmp___3);
          } else {
#line 381
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 381
        if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_no)) {
#line 381
          if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_yes)) {
            {
#line 385
            tmp___3 = expr_alloc_comp((enum expr_type )5, sym1, & symbol_mod);
            }
#line 385
            return (tmp___3);
          }
        }
      }
    }
#line 387
    if ((unsigned int )e1->type == 4U) {
#line 387
      if ((unsigned int )e2->type == 4U) {
#line 387
        if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_mod)) {
#line 387
          if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_no)) {
            {
#line 391
            tmp___4 = expr_alloc_comp((enum expr_type )5, sym1, & symbol_yes);
            }
#line 391
            return (tmp___4);
          } else {
#line 387
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 387
        if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_no)) {
#line 387
          if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_mod)) {
            {
#line 391
            tmp___4 = expr_alloc_comp((enum expr_type )5, sym1, & symbol_yes);
            }
#line 391
            return (tmp___4);
          }
        }
      }
    }
  }
#line 394
  if ((unsigned int )sym1->type == 1U) {
#line 394
    if ((unsigned long )sym1 == (unsigned long )sym2) {
#line 395
      if ((unsigned int )e1->type == 3U) {
#line 395
        if ((unsigned int )(e1->left.expr)->type == 7U) {
#line 395
          if ((unsigned int )e2->type == 7U) {
            {
#line 397
            tmp___5 = expr_alloc_symbol(& symbol_yes);
            }
#line 397
            return (tmp___5);
          } else {
#line 395
            goto _L___3;
          }
        } else {
#line 395
          goto _L___3;
        }
      } else
      _L___3: /* CIL Label */ 
#line 395
      if ((unsigned int )e2->type == 3U) {
#line 395
        if ((unsigned int )(e2->left.expr)->type == 7U) {
#line 395
          if ((unsigned int )e1->type == 7U) {
            {
#line 397
            tmp___5 = expr_alloc_symbol(& symbol_yes);
            }
#line 397
            return (tmp___5);
          }
        }
      }
    }
  }
#line 407
  return ((struct expr *)((void *)0));
}
}
#line 410 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/expr.c"
static struct expr *expr_join_and(struct expr *e1 , struct expr *e2 ) 
{ 
  struct expr *tmp ;
  struct symbol *sym1 ;
  struct symbol *sym2 ;
  struct expr *tmp___0 ;
  int tmp___1 ;
  struct expr *tmp___2 ;
  struct expr *tmp___3 ;
  struct expr *tmp___4 ;
  struct expr *tmp___5 ;
  struct expr *tmp___6 ;
  struct expr *tmp___7 ;
  struct expr *tmp___8 ;
  struct expr *tmp___9 ;
  struct expr *tmp___10 ;
  struct expr *tmp___11 ;
  struct expr *tmp___12 ;
  struct expr *tmp___13 ;

  {
  {
#line 415
  tmp___1 = expr_eq(e1, e2);
  }
#line 415
  if (tmp___1) {
    {
#line 416
    tmp___0 = expr_copy((struct expr  const  *)e1);
    }
#line 416
    return (tmp___0);
  }
#line 417
  if ((unsigned int )e1->type != 4U) {
#line 417
    if ((unsigned int )e1->type != 5U) {
#line 417
      if ((unsigned int )e1->type != 7U) {
#line 417
        if ((unsigned int )e1->type != 3U) {
#line 418
          return ((struct expr *)((void *)0));
        }
      }
    }
  }
#line 419
  if ((unsigned int )e2->type != 4U) {
#line 419
    if ((unsigned int )e2->type != 5U) {
#line 419
      if ((unsigned int )e2->type != 7U) {
#line 419
        if ((unsigned int )e2->type != 3U) {
#line 420
          return ((struct expr *)((void *)0));
        }
      }
    }
  }
#line 421
  if ((unsigned int )e1->type == 3U) {
#line 422
    tmp = e1->left.expr;
#line 423
    if ((unsigned int )tmp->type != 4U) {
#line 423
      if ((unsigned int )tmp->type != 5U) {
#line 423
        if ((unsigned int )tmp->type != 7U) {
#line 424
          return ((struct expr *)((void *)0));
        }
      }
    }
#line 425
    sym1 = tmp->left.sym;
  } else {
#line 427
    sym1 = e1->left.sym;
  }
#line 428
  if ((unsigned int )e2->type == 3U) {
#line 429
    if ((unsigned int )(e2->left.expr)->type != 7U) {
#line 430
      return ((struct expr *)((void *)0));
    }
#line 431
    sym2 = (e2->left.expr)->left.sym;
  } else {
#line 433
    sym2 = e2->left.sym;
  }
#line 434
  if ((unsigned long )sym1 != (unsigned long )sym2) {
#line 435
    return ((struct expr *)((void *)0));
  }
#line 436
  if ((unsigned int )sym1->type != 1U) {
#line 436
    if ((unsigned int )sym1->type != 2U) {
#line 437
      return ((struct expr *)((void *)0));
    }
  }
#line 439
  if ((unsigned int )e1->type == 7U) {
#line 439
    if ((unsigned int )e2->type == 4U) {
#line 439
      if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_yes)) {
        {
#line 442
        tmp___2 = expr_alloc_comp((enum expr_type )4, sym1, & symbol_yes);
        }
#line 442
        return (tmp___2);
      } else {
#line 439
        goto _L___0;
      }
    } else {
#line 439
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 439
  if ((unsigned int )e2->type == 7U) {
#line 439
    if ((unsigned int )e1->type == 4U) {
#line 439
      if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_yes)) {
        {
#line 442
        tmp___2 = expr_alloc_comp((enum expr_type )4, sym1, & symbol_yes);
        }
#line 442
        return (tmp___2);
      }
    }
  }
#line 444
  if ((unsigned int )e1->type == 7U) {
#line 444
    if ((unsigned int )e2->type == 5U) {
#line 444
      if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_no)) {
        {
#line 447
        tmp___3 = expr_alloc_symbol(sym1);
        }
#line 447
        return (tmp___3);
      } else {
#line 444
        goto _L___2;
      }
    } else {
#line 444
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 444
  if ((unsigned int )e2->type == 7U) {
#line 444
    if ((unsigned int )e1->type == 5U) {
#line 444
      if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_no)) {
        {
#line 447
        tmp___3 = expr_alloc_symbol(sym1);
        }
#line 447
        return (tmp___3);
      }
    }
  }
#line 449
  if ((unsigned int )e1->type == 7U) {
#line 449
    if ((unsigned int )e2->type == 5U) {
#line 449
      if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_mod)) {
        {
#line 452
        tmp___4 = expr_alloc_comp((enum expr_type )4, sym1, & symbol_yes);
        }
#line 452
        return (tmp___4);
      } else {
#line 449
        goto _L___4;
      }
    } else {
#line 449
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
#line 449
  if ((unsigned int )e2->type == 7U) {
#line 449
    if ((unsigned int )e1->type == 5U) {
#line 449
      if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_mod)) {
        {
#line 452
        tmp___4 = expr_alloc_comp((enum expr_type )4, sym1, & symbol_yes);
        }
#line 452
        return (tmp___4);
      }
    }
  }
#line 454
  if ((unsigned int )sym1->type == 2U) {
#line 455
    if ((unsigned int )e1->type == 4U) {
#line 455
      if ((unsigned int )e2->type == 5U) {
#line 457
        sym2 = e1->right.sym;
#line 458
        if ((e2->right.sym)->flags & 1) {
#line 458
          if (sym2->flags & 1) {
#line 459
            if ((unsigned long )sym2 != (unsigned long )e2->right.sym) {
              {
#line 459
              tmp___5 = expr_alloc_comp((enum expr_type )4, sym1, sym2);
#line 459
              tmp___7 = tmp___5;
              }
            } else {
              {
#line 459
              tmp___6 = expr_alloc_symbol(& symbol_no);
#line 459
              tmp___7 = tmp___6;
              }
            }
#line 459
            return (tmp___7);
          }
        }
      }
    }
#line 462
    if ((unsigned int )e1->type == 5U) {
#line 462
      if ((unsigned int )e2->type == 4U) {
#line 464
        sym2 = e2->right.sym;
#line 465
        if ((e1->right.sym)->flags & 1) {
#line 465
          if (sym2->flags & 1) {
#line 466
            if ((unsigned long )sym2 != (unsigned long )e1->right.sym) {
              {
#line 466
              tmp___8 = expr_alloc_comp((enum expr_type )4, sym1, sym2);
#line 466
              tmp___10 = tmp___8;
              }
            } else {
              {
#line 466
              tmp___9 = expr_alloc_symbol(& symbol_no);
#line 466
              tmp___10 = tmp___9;
              }
            }
#line 466
            return (tmp___10);
          }
        }
      }
    }
#line 469
    if ((unsigned int )e1->type == 5U) {
#line 469
      if ((unsigned int )e2->type == 5U) {
#line 469
        if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_yes)) {
#line 469
          if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_no)) {
            {
#line 473
            tmp___11 = expr_alloc_comp((enum expr_type )4, sym1, & symbol_mod);
            }
#line 473
            return (tmp___11);
          } else {
#line 469
            goto _L___5;
          }
        } else
        _L___5: /* CIL Label */ 
#line 469
        if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_no)) {
#line 469
          if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_yes)) {
            {
#line 473
            tmp___11 = expr_alloc_comp((enum expr_type )4, sym1, & symbol_mod);
            }
#line 473
            return (tmp___11);
          }
        }
      }
    }
#line 475
    if ((unsigned int )e1->type == 5U) {
#line 475
      if ((unsigned int )e2->type == 5U) {
#line 475
        if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_yes)) {
#line 475
          if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_mod)) {
            {
#line 479
            tmp___12 = expr_alloc_comp((enum expr_type )4, sym1, & symbol_no);
            }
#line 479
            return (tmp___12);
          } else {
#line 475
            goto _L___6;
          }
        } else
        _L___6: /* CIL Label */ 
#line 475
        if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_mod)) {
#line 475
          if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_yes)) {
            {
#line 479
            tmp___12 = expr_alloc_comp((enum expr_type )4, sym1, & symbol_no);
            }
#line 479
            return (tmp___12);
          }
        }
      }
    }
#line 481
    if ((unsigned int )e1->type == 5U) {
#line 481
      if ((unsigned int )e2->type == 5U) {
#line 481
        if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_mod)) {
#line 481
          if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_no)) {
            {
#line 485
            tmp___13 = expr_alloc_comp((enum expr_type )4, sym1, & symbol_yes);
            }
#line 485
            return (tmp___13);
          } else {
#line 481
            goto _L___7;
          }
        } else
        _L___7: /* CIL Label */ 
#line 481
        if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_no)) {
#line 481
          if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_mod)) {
            {
#line 485
            tmp___13 = expr_alloc_comp((enum expr_type )4, sym1, & symbol_yes);
            }
#line 485
            return (tmp___13);
          }
        }
      }
    }
#line 487
    if ((unsigned int )e1->type == 7U) {
#line 487
      if ((unsigned int )e2->type == 4U) {
#line 487
        if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_mod)) {
#line 491
          return ((struct expr *)((void *)0));
        } else {
#line 487
          goto _L___13;
        }
      } else {
#line 487
        goto _L___13;
      }
    } else
    _L___13: /* CIL Label */ 
#line 487
    if ((unsigned int )e2->type == 7U) {
#line 487
      if ((unsigned int )e1->type == 4U) {
#line 487
        if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_mod)) {
#line 491
          return ((struct expr *)((void *)0));
        } else {
#line 487
          goto _L___11;
        }
      } else {
#line 487
        goto _L___11;
      }
    } else
    _L___11: /* CIL Label */ 
#line 487
    if ((unsigned int )e1->type == 7U) {
#line 487
      if ((unsigned int )e2->type == 5U) {
#line 487
        if ((unsigned long )e2->right.sym == (unsigned long )(& symbol_yes)) {
#line 491
          return ((struct expr *)((void *)0));
        } else {
#line 487
          goto _L___9;
        }
      } else {
#line 487
        goto _L___9;
      }
    } else
    _L___9: /* CIL Label */ 
#line 487
    if ((unsigned int )e2->type == 7U) {
#line 487
      if ((unsigned int )e1->type == 5U) {
#line 487
        if ((unsigned long )e1->right.sym == (unsigned long )(& symbol_yes)) {
#line 491
          return ((struct expr *)((void *)0));
        }
      }
    }
  }
#line 501
  return ((struct expr *)((void *)0));
}
}
#line 504 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/expr.c"
static void expr_eliminate_dups1(enum expr_type type , struct expr **ep1 , struct expr **ep2 ) 
{ 
  struct expr *tmp ;

  {
#line 510
  if ((unsigned int )(*ep1)->type == (unsigned int )type) {
    {
#line 511
    expr_eliminate_dups1(type, & (*ep1)->left.expr, ep2);
#line 512
    expr_eliminate_dups1(type, & (*ep1)->right.expr, ep2);
    }
#line 513
    return;
  }
#line 515
  if ((unsigned int )(*ep2)->type == (unsigned int )type) {
    {
#line 516
    expr_eliminate_dups1(type, ep1, & (*ep2)->left.expr);
#line 517
    expr_eliminate_dups1(type, ep1, & (*ep2)->right.expr);
    }
#line 518
    return;
  }
#line 520
  if ((unsigned long )*ep1 == (unsigned long )*ep2) {
#line 521
    return;
  }
  {
#line 524
  if ((unsigned int )(*ep1)->type == 2U) {
#line 524
    goto case_2;
  }
#line 524
  if ((unsigned int )(*ep1)->type == 1U) {
#line 524
    goto case_2;
  }
#line 526
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 525
  expr_eliminate_dups1((*ep1)->type, ep1, ep1);
  }
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
  {
#line 531
  if ((unsigned int )type == 1U) {
#line 531
    goto case_1___0;
  }
#line 540
  if ((unsigned int )type == 2U) {
#line 540
    goto case_2___0;
  }
#line 549
  goto switch_default___0;
  case_1___0: /* CIL Label */ 
  {
#line 532
  tmp = expr_join_or(*ep1, *ep2);
  }
#line 533
  if (tmp) {
    {
#line 534
    expr_free(*ep1);
#line 534
    expr_free(*ep2);
#line 535
    *ep1 = expr_alloc_symbol(& symbol_no);
#line 536
    *ep2 = tmp;
#line 537
    trans_count ++;
    }
  }
#line 539
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
  {
#line 541
  tmp = expr_join_and(*ep1, *ep2);
  }
#line 542
  if (tmp) {
    {
#line 543
    expr_free(*ep1);
#line 543
    expr_free(*ep2);
#line 544
    *ep1 = expr_alloc_symbol(& symbol_yes);
#line 545
    *ep2 = tmp;
#line 546
    trans_count ++;
    }
  }
#line 548
  goto switch_break___0;
  switch_default___0: /* CIL Label */ ;
  switch_break___0: /* CIL Label */ ;
  }
#line 554
  return;
}
}
#line 556 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/expr.c"
static void expr_eliminate_dups2(enum expr_type type , struct expr **ep1 , struct expr **ep2 ) 
{ 
  struct expr *tmp ;
  struct expr *tmp1 ;
  struct expr *tmp2 ;
  struct expr *tmp___0 ;
  struct expr *tmp___1 ;
  int tmp___2 ;
  struct expr *tmp___3 ;
  struct expr *tmp___4 ;
  int tmp___5 ;

  {
#line 562
  if ((unsigned int )(*ep1)->type == (unsigned int )type) {
    {
#line 563
    expr_eliminate_dups2(type, & (*ep1)->left.expr, ep2);
#line 564
    expr_eliminate_dups2(type, & (*ep1)->right.expr, ep2);
    }
#line 565
    return;
  }
#line 567
  if ((unsigned int )(*ep2)->type == (unsigned int )type) {
    {
#line 568
    expr_eliminate_dups2(type, ep1, & (*ep2)->left.expr);
#line 569
    expr_eliminate_dups2(type, ep1, & (*ep2)->right.expr);
    }
  }
#line 571
  if ((unsigned long )*ep1 == (unsigned long )*ep2) {
#line 572
    return;
  }
  {
#line 575
  if ((unsigned int )(*ep1)->type == 1U) {
#line 575
    goto case_1;
  }
#line 590
  if ((unsigned int )(*ep1)->type == 2U) {
#line 590
    goto case_2;
  }
#line 605
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 576
  expr_eliminate_dups2((*ep1)->type, ep1, ep1);
#line 578
  tmp___0 = expr_copy((struct expr  const  *)*ep1);
#line 578
  tmp___1 = expr_alloc_one((enum expr_type )3, tmp___0);
#line 578
  tmp1 = expr_transform(tmp___1);
#line 579
  tmp2 = expr_copy((struct expr  const  *)*ep2);
#line 580
  tmp = expr_extract_eq_and(& tmp1, & tmp2);
#line 581
  tmp___2 = expr_is_yes(tmp1);
  }
#line 581
  if (tmp___2) {
    {
#line 582
    expr_free(*ep1);
#line 583
    *ep1 = expr_alloc_symbol(& symbol_no);
#line 584
    trans_count ++;
    }
  }
  {
#line 586
  expr_free(tmp2);
#line 587
  expr_free(tmp1);
#line 588
  expr_free(tmp);
  }
#line 589
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 591
  expr_eliminate_dups2((*ep1)->type, ep1, ep1);
#line 593
  tmp___3 = expr_copy((struct expr  const  *)*ep1);
#line 593
  tmp___4 = expr_alloc_one((enum expr_type )3, tmp___3);
#line 593
  tmp1 = expr_transform(tmp___4);
#line 594
  tmp2 = expr_copy((struct expr  const  *)*ep2);
#line 595
  tmp = expr_extract_eq_or(& tmp1, & tmp2);
#line 596
  tmp___5 = expr_is_no(tmp1);
  }
#line 596
  if (tmp___5) {
    {
#line 597
    expr_free(*ep1);
#line 598
    *ep1 = expr_alloc_symbol(& symbol_yes);
#line 599
    trans_count ++;
    }
  }
  {
#line 601
  expr_free(tmp2);
#line 602
  expr_free(tmp1);
#line 603
  expr_free(tmp);
  }
#line 604
  goto switch_break;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 610
  return;
}
}
#line 612 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/expr.c"
struct expr *expr_eliminate_dups(struct expr *e ) 
{ 
  int oldcount ;

  {
#line 615
  if (! e) {
#line 616
    return (e);
  }
#line 618
  oldcount = trans_count;
  {
#line 619
  while (1) {
    while_continue: /* CIL Label */ ;
#line 620
    trans_count = 0;
    {
#line 622
    if ((unsigned int )e->type == 2U) {
#line 622
      goto case_2;
    }
#line 622
    if ((unsigned int )e->type == 1U) {
#line 622
      goto case_2;
    }
#line 625
    goto switch_default;
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
    {
#line 623
    expr_eliminate_dups1(e->type, & e, & e);
#line 624
    expr_eliminate_dups2(e->type, & e, & e);
    }
    switch_default: /* CIL Label */ ;
    switch_break: /* CIL Label */ ;
    }
#line 628
    if (! trans_count) {
#line 629
      goto while_break;
    }
    {
#line 630
    e = expr_eliminate_yn(e);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 632
  trans_count = oldcount;
#line 633
  return (e);
}
}
#line 636 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/expr.c"
struct expr *expr_transform(struct expr *e ) 
{ 
  struct expr *tmp ;

  {
#line 640
  if (! e) {
#line 641
    return ((struct expr *)((void *)0));
  }
  {
#line 646
  if ((unsigned int )e->type == 6U) {
#line 646
    goto case_6;
  }
#line 646
  if ((unsigned int )e->type == 7U) {
#line 646
    goto case_6;
  }
#line 646
  if ((unsigned int )e->type == 5U) {
#line 646
    goto case_6;
  }
#line 646
  if ((unsigned int )e->type == 4U) {
#line 646
    goto case_6;
  }
#line 648
  goto switch_default;
  case_6: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 647
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 649
  e->left.expr = expr_transform(e->left.expr);
#line 650
  e->right.expr = expr_transform(e->right.expr);
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 654
  if ((unsigned int )e->type == 4U) {
#line 654
    goto case_4___0;
  }
#line 676
  if ((unsigned int )e->type == 5U) {
#line 676
    goto case_5___0;
  }
#line 698
  if ((unsigned int )e->type == 3U) {
#line 698
    goto case_3;
  }
#line 767
  goto switch_default___1;
  case_4___0: /* CIL Label */ 
#line 655
  if ((unsigned int )(e->left.sym)->type != 1U) {
#line 656
    goto switch_break___0;
  }
#line 657
  if ((unsigned long )e->right.sym == (unsigned long )(& symbol_no)) {
    {
#line 658
    e->type = (enum expr_type )3;
#line 659
    e->left.expr = expr_alloc_symbol(e->left.sym);
#line 660
    e->right.sym = (struct symbol *)((void *)0);
    }
#line 661
    goto switch_break___0;
  }
#line 663
  if ((unsigned long )e->right.sym == (unsigned long )(& symbol_mod)) {
    {
#line 664
    printf((char const   */* __restrict  */)"boolean symbol %s tested for \'m\'? test forced to \'n\'\n",
           (e->left.sym)->name);
#line 665
    e->type = (enum expr_type )7;
#line 666
    e->left.sym = & symbol_no;
#line 667
    e->right.sym = (struct symbol *)((void *)0);
    }
#line 668
    goto switch_break___0;
  }
#line 670
  if ((unsigned long )e->right.sym == (unsigned long )(& symbol_yes)) {
#line 671
    e->type = (enum expr_type )7;
#line 672
    e->right.sym = (struct symbol *)((void *)0);
#line 673
    goto switch_break___0;
  }
#line 675
  goto switch_break___0;
  case_5___0: /* CIL Label */ 
#line 677
  if ((unsigned int )(e->left.sym)->type != 1U) {
#line 678
    goto switch_break___0;
  }
#line 679
  if ((unsigned long )e->right.sym == (unsigned long )(& symbol_no)) {
#line 680
    e->type = (enum expr_type )7;
#line 681
    e->right.sym = (struct symbol *)((void *)0);
#line 682
    goto switch_break___0;
  }
#line 684
  if ((unsigned long )e->right.sym == (unsigned long )(& symbol_mod)) {
    {
#line 685
    printf((char const   */* __restrict  */)"boolean symbol %s tested for \'m\'? test forced to \'y\'\n",
           (e->left.sym)->name);
#line 686
    e->type = (enum expr_type )7;
#line 687
    e->left.sym = & symbol_yes;
#line 688
    e->right.sym = (struct symbol *)((void *)0);
    }
#line 689
    goto switch_break___0;
  }
#line 691
  if ((unsigned long )e->right.sym == (unsigned long )(& symbol_yes)) {
    {
#line 692
    e->type = (enum expr_type )3;
#line 693
    e->left.expr = expr_alloc_symbol(e->left.sym);
#line 694
    e->right.sym = (struct symbol *)((void *)0);
    }
#line 695
    goto switch_break___0;
  }
#line 697
  goto switch_break___0;
  case_3: /* CIL Label */ 
  {
#line 700
  if ((unsigned int )(e->left.expr)->type == 3U) {
#line 700
    goto case_3___0;
  }
#line 709
  if ((unsigned int )(e->left.expr)->type == 5U) {
#line 709
    goto case_5___1;
  }
#line 709
  if ((unsigned int )(e->left.expr)->type == 4U) {
#line 709
    goto case_5___1;
  }
#line 716
  if ((unsigned int )(e->left.expr)->type == 1U) {
#line 716
    goto case_1;
  }
#line 725
  if ((unsigned int )(e->left.expr)->type == 2U) {
#line 725
    goto case_2;
  }
#line 734
  if ((unsigned int )(e->left.expr)->type == 7U) {
#line 734
    goto case_7___0;
  }
#line 763
  goto switch_default___0;
  case_3___0: /* CIL Label */ 
  {
#line 702
  tmp = (e->left.expr)->left.expr;
#line 703
  free((void *)e->left.expr);
#line 704
  free((void *)e);
#line 705
  e = tmp;
#line 706
  e = expr_transform(e);
  }
#line 707
  goto switch_break___1;
  case_5___1: /* CIL Label */ 
  case_4___1: /* CIL Label */ 
  {
#line 711
  tmp = e->left.expr;
#line 712
  free((void *)e);
#line 713
  e = tmp;
  }
#line 714
  if ((unsigned int )e->type == 4U) {
#line 714
    e->type = (enum expr_type )5;
  } else {
#line 714
    e->type = (enum expr_type )4;
  }
#line 715
  goto switch_break___1;
  case_1: /* CIL Label */ 
  {
#line 718
  tmp = e->left.expr;
#line 719
  e->type = (enum expr_type )2;
#line 720
  e->right.expr = expr_alloc_one((enum expr_type )3, tmp->right.expr);
#line 721
  tmp->type = (enum expr_type )3;
#line 722
  tmp->right.expr = (struct expr *)((void *)0);
#line 723
  e = expr_transform(e);
  }
#line 724
  goto switch_break___1;
  case_2: /* CIL Label */ 
  {
#line 727
  tmp = e->left.expr;
#line 728
  e->type = (enum expr_type )1;
#line 729
  e->right.expr = expr_alloc_one((enum expr_type )3, tmp->right.expr);
#line 730
  tmp->type = (enum expr_type )3;
#line 731
  tmp->right.expr = (struct expr *)((void *)0);
#line 732
  e = expr_transform(e);
  }
#line 733
  goto switch_break___1;
  case_7___0: /* CIL Label */ 
#line 735
  if ((unsigned long )(e->left.expr)->left.sym == (unsigned long )(& symbol_yes)) {
    {
#line 737
    tmp = e->left.expr;
#line 738
    free((void *)e);
#line 739
    e = tmp;
#line 740
    e->type = (enum expr_type )7;
#line 741
    e->left.sym = & symbol_no;
    }
#line 742
    goto switch_break___1;
  }
#line 744
  if ((unsigned long )(e->left.expr)->left.sym == (unsigned long )(& symbol_mod)) {
    {
#line 746
    tmp = e->left.expr;
#line 747
    free((void *)e);
#line 748
    e = tmp;
#line 749
    e->type = (enum expr_type )7;
#line 750
    e->left.sym = & symbol_mod;
    }
#line 751
    goto switch_break___1;
  }
#line 753
  if ((unsigned long )(e->left.expr)->left.sym == (unsigned long )(& symbol_no)) {
    {
#line 755
    tmp = e->left.expr;
#line 756
    free((void *)e);
#line 757
    e = tmp;
#line 758
    e->type = (enum expr_type )7;
#line 759
    e->left.sym = & symbol_yes;
    }
#line 760
    goto switch_break___1;
  }
#line 762
  goto switch_break___1;
  switch_default___0: /* CIL Label */ ;
  switch_break___1: /* CIL Label */ ;
  }
#line 766
  goto switch_break___0;
  switch_default___1: /* CIL Label */ ;
  switch_break___0: /* CIL Label */ ;
  }
#line 770
  return (e);
}
}
#line 773 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/expr.c"
int expr_contains_symbol(struct expr *dep , struct symbol *sym ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 775
  if (! dep) {
#line 776
    return (0);
  }
  {
#line 780
  if ((unsigned int )dep->type == 1U) {
#line 780
    goto case_1;
  }
#line 780
  if ((unsigned int )dep->type == 2U) {
#line 780
    goto case_1;
  }
#line 783
  if ((unsigned int )dep->type == 7U) {
#line 783
    goto case_7;
  }
#line 786
  if ((unsigned int )dep->type == 5U) {
#line 786
    goto case_5;
  }
#line 786
  if ((unsigned int )dep->type == 4U) {
#line 786
    goto case_5;
  }
#line 789
  if ((unsigned int )dep->type == 3U) {
#line 789
    goto case_3;
  }
#line 791
  goto switch_default;
  case_1: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 781
  tmp = expr_contains_symbol(dep->left.expr, sym);
  }
#line 781
  if (tmp) {
#line 781
    tmp___1 = 1;
  } else {
    {
#line 781
    tmp___0 = expr_contains_symbol(dep->right.expr, sym);
    }
#line 781
    if (tmp___0) {
#line 781
      tmp___1 = 1;
    } else {
#line 781
      tmp___1 = 0;
    }
  }
#line 781
  return (tmp___1);
  case_7: /* CIL Label */ 
#line 784
  return ((unsigned long )dep->left.sym == (unsigned long )sym);
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 787
  if ((unsigned long )dep->left.sym == (unsigned long )sym) {
#line 787
    tmp___2 = 1;
  } else
#line 787
  if ((unsigned long )dep->right.sym == (unsigned long )sym) {
#line 787
    tmp___2 = 1;
  } else {
#line 787
    tmp___2 = 0;
  }
#line 787
  return (tmp___2);
  case_3: /* CIL Label */ 
  {
#line 790
  tmp___3 = expr_contains_symbol(dep->left.expr, sym);
  }
#line 790
  return (tmp___3);
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 794
  return (0);
}
}
#line 797 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/expr.c"
_Bool expr_depends_symbol(struct expr *dep , struct symbol *sym ) 
{ 
  _Bool tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;

  {
#line 799
  if (! dep) {
#line 800
    return ((_Bool)0);
  }
  {
#line 803
  if ((unsigned int )dep->type == 2U) {
#line 803
    goto case_2;
  }
#line 806
  if ((unsigned int )dep->type == 7U) {
#line 806
    goto case_7;
  }
#line 808
  if ((unsigned int )dep->type == 4U) {
#line 808
    goto case_4;
  }
#line 814
  if ((unsigned int )dep->type == 5U) {
#line 814
    goto case_5;
  }
#line 820
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 804
  tmp = expr_depends_symbol(dep->left.expr, sym);
  }
#line 804
  if (tmp) {
#line 804
    tmp___1 = 1;
  } else {
    {
#line 804
    tmp___0 = expr_depends_symbol(dep->right.expr, sym);
    }
#line 804
    if (tmp___0) {
#line 804
      tmp___1 = 1;
    } else {
#line 804
      tmp___1 = 0;
    }
  }
#line 804
  return ((_Bool )tmp___1);
  case_7: /* CIL Label */ 
#line 807
  return ((_Bool )((unsigned long )dep->left.sym == (unsigned long )sym));
  case_4: /* CIL Label */ 
#line 809
  if ((unsigned long )dep->left.sym == (unsigned long )sym) {
#line 810
    if ((unsigned long )dep->right.sym == (unsigned long )(& symbol_yes)) {
#line 811
      return ((_Bool)1);
    } else
#line 810
    if ((unsigned long )dep->right.sym == (unsigned long )(& symbol_mod)) {
#line 811
      return ((_Bool)1);
    }
  }
#line 813
  goto switch_break;
  case_5: /* CIL Label */ 
#line 815
  if ((unsigned long )dep->left.sym == (unsigned long )sym) {
#line 816
    if ((unsigned long )dep->right.sym == (unsigned long )(& symbol_no)) {
#line 817
      return ((_Bool)1);
    }
  }
#line 819
  goto switch_break;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 823
  return ((_Bool)0);
}
}
#line 826 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/expr.c"
struct expr *expr_extract_eq_and(struct expr **ep1 , struct expr **ep2 ) 
{ 
  struct expr *tmp ;

  {
  {
#line 828
  tmp = (struct expr *)((void *)0);
#line 829
  expr_extract_eq((enum expr_type )2, & tmp, ep1, ep2);
  }
#line 830
  if (tmp) {
    {
#line 831
    *ep1 = expr_eliminate_yn(*ep1);
#line 832
    *ep2 = expr_eliminate_yn(*ep2);
    }
  }
#line 834
  return (tmp);
}
}
#line 837 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/expr.c"
struct expr *expr_extract_eq_or(struct expr **ep1 , struct expr **ep2 ) 
{ 
  struct expr *tmp ;

  {
  {
#line 839
  tmp = (struct expr *)((void *)0);
#line 840
  expr_extract_eq((enum expr_type )1, & tmp, ep1, ep2);
  }
#line 841
  if (tmp) {
    {
#line 842
    *ep1 = expr_eliminate_yn(*ep1);
#line 843
    *ep2 = expr_eliminate_yn(*ep2);
    }
  }
#line 845
  return (tmp);
}
}
#line 848 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/expr.c"
void expr_extract_eq(enum expr_type type , struct expr **ep , struct expr **ep1 ,
                     struct expr **ep2 ) 
{ 
  struct expr *tmp ;
  int tmp___0 ;

  {
#line 852
  if ((unsigned int )(*ep1)->type == (unsigned int )type) {
    {
#line 853
    expr_extract_eq(type, ep, & (*ep1)->left.expr, ep2);
#line 854
    expr_extract_eq(type, ep, & (*ep1)->right.expr, ep2);
    }
#line 855
    return;
  }
#line 857
  if ((unsigned int )(*ep2)->type == (unsigned int )type) {
    {
#line 858
    expr_extract_eq(type, ep, ep1, & (*ep2)->left.expr);
#line 859
    expr_extract_eq(type, ep, ep1, & (*ep2)->right.expr);
    }
#line 860
    return;
  }
  {
#line 862
  tmp___0 = expr_eq(*ep1, *ep2);
  }
#line 862
  if (tmp___0) {
#line 863
    if (*ep) {
      {
#line 863
      tmp = expr_alloc_two(type, *ep, *ep1);
#line 863
      *ep = tmp;
      }
    } else {
#line 863
      *ep = *ep1;
    }
    {
#line 864
    expr_free(*ep2);
    }
#line 865
    if ((unsigned int )type == 2U) {
      {
#line 866
      *ep1 = expr_alloc_symbol(& symbol_yes);
#line 867
      *ep2 = expr_alloc_symbol(& symbol_yes);
      }
    } else
#line 868
    if ((unsigned int )type == 1U) {
      {
#line 869
      *ep1 = expr_alloc_symbol(& symbol_no);
#line 870
      *ep2 = expr_alloc_symbol(& symbol_no);
      }
    }
  }
#line 875
  return;
}
}
#line 877 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/expr.c"
struct expr *expr_trans_compare(struct expr *e , enum expr_type type , struct symbol *sym ) 
{ 
  struct expr *e1 ;
  struct expr *e2 ;
  int tmp ;
  struct expr *tmp___0 ;
  struct expr *tmp___1 ;
  struct expr *tmp___2 ;
  struct expr *tmp___3 ;
  struct expr *tmp___4 ;
  struct expr *tmp___5 ;
  struct expr *tmp___6 ;
  struct expr *tmp___7 ;
  struct expr *tmp___8 ;
  struct expr *tmp___9 ;

  {
#line 881
  if (! e) {
    {
#line 882
    e = expr_alloc_symbol(sym);
    }
#line 883
    if ((unsigned int )type == 5U) {
      {
#line 884
      e = expr_alloc_one((enum expr_type )3, e);
      }
    }
#line 885
    return (e);
  }
  {
#line 888
  if ((unsigned int )e->type == 2U) {
#line 888
    goto case_2;
  }
#line 898
  if ((unsigned int )e->type == 1U) {
#line 898
    goto case_1;
  }
#line 908
  if ((unsigned int )e->type == 3U) {
#line 908
    goto case_3;
  }
#line 911
  if ((unsigned int )e->type == 4U) {
#line 911
    goto case_4;
  }
#line 911
  if ((unsigned int )e->type == 5U) {
#line 911
    goto case_4;
  }
#line 928
  if ((unsigned int )e->type == 7U) {
#line 928
    goto case_7;
  }
#line 932
  if ((unsigned int )e->type == 0U) {
#line 932
    goto case_0;
  }
#line 932
  if ((unsigned int )e->type == 8U) {
#line 932
    goto case_0;
  }
#line 932
  if ((unsigned int )e->type == 6U) {
#line 932
    goto case_0;
  }
#line 887
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 889
  e1 = expr_trans_compare(e->left.expr, (enum expr_type )4, sym);
#line 890
  e2 = expr_trans_compare(e->right.expr, (enum expr_type )4, sym);
  }
#line 891
  if ((unsigned long )sym == (unsigned long )(& symbol_yes)) {
    {
#line 892
    e = expr_alloc_two((enum expr_type )2, e1, e2);
    }
  }
#line 893
  if ((unsigned long )sym == (unsigned long )(& symbol_no)) {
    {
#line 894
    e = expr_alloc_two((enum expr_type )1, e1, e2);
    }
  }
#line 895
  if ((unsigned int )type == 5U) {
    {
#line 896
    e = expr_alloc_one((enum expr_type )3, e);
    }
  }
#line 897
  return (e);
  case_1: /* CIL Label */ 
  {
#line 899
  e1 = expr_trans_compare(e->left.expr, (enum expr_type )4, sym);
#line 900
  e2 = expr_trans_compare(e->right.expr, (enum expr_type )4, sym);
  }
#line 901
  if ((unsigned long )sym == (unsigned long )(& symbol_yes)) {
    {
#line 902
    e = expr_alloc_two((enum expr_type )1, e1, e2);
    }
  }
#line 903
  if ((unsigned long )sym == (unsigned long )(& symbol_no)) {
    {
#line 904
    e = expr_alloc_two((enum expr_type )2, e1, e2);
    }
  }
#line 905
  if ((unsigned int )type == 5U) {
    {
#line 906
    e = expr_alloc_one((enum expr_type )3, e);
    }
  }
#line 907
  return (e);
  case_3: /* CIL Label */ 
#line 909
  if ((unsigned int )type == 4U) {
#line 909
    tmp = 5;
  } else {
#line 909
    tmp = 4;
  }
  {
#line 909
  tmp___0 = expr_trans_compare(e->left.expr, (enum expr_type )tmp, sym);
  }
#line 909
  return (tmp___0);
  case_4: /* CIL Label */ 
  case_5: /* CIL Label */ 
#line 912
  if ((unsigned int )type == 4U) {
#line 913
    if ((unsigned long )sym == (unsigned long )(& symbol_yes)) {
      {
#line 914
      tmp___1 = expr_copy((struct expr  const  *)e);
      }
#line 914
      return (tmp___1);
    }
#line 915
    if ((unsigned long )sym == (unsigned long )(& symbol_mod)) {
      {
#line 916
      tmp___2 = expr_alloc_symbol(& symbol_no);
      }
#line 916
      return (tmp___2);
    }
#line 917
    if ((unsigned long )sym == (unsigned long )(& symbol_no)) {
      {
#line 918
      tmp___3 = expr_copy((struct expr  const  *)e);
#line 918
      tmp___4 = expr_alloc_one((enum expr_type )3, tmp___3);
      }
#line 918
      return (tmp___4);
    }
  } else {
#line 920
    if ((unsigned long )sym == (unsigned long )(& symbol_yes)) {
      {
#line 921
      tmp___5 = expr_copy((struct expr  const  *)e);
#line 921
      tmp___6 = expr_alloc_one((enum expr_type )3, tmp___5);
      }
#line 921
      return (tmp___6);
    }
#line 922
    if ((unsigned long )sym == (unsigned long )(& symbol_mod)) {
      {
#line 923
      tmp___7 = expr_alloc_symbol(& symbol_yes);
      }
#line 923
      return (tmp___7);
    }
#line 924
    if ((unsigned long )sym == (unsigned long )(& symbol_no)) {
      {
#line 925
      tmp___8 = expr_copy((struct expr  const  *)e);
      }
#line 925
      return (tmp___8);
    }
  }
#line 927
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 929
  tmp___9 = expr_alloc_comp(type, e->left.sym, sym);
  }
#line 929
  return (tmp___9);
  case_0: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_6: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 935
  return ((struct expr *)((void *)0));
}
}
#line 938 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/expr.c"
tristate expr_calc_value(struct expr *e ) 
{ 
  tristate val1 ;
  tristate val2 ;
  char const   *str1 ;
  char const   *str2 ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 943
  if (! e) {
#line 944
    return ((tristate )2);
  }
  {
#line 947
  if ((unsigned int )e->type == 7U) {
#line 947
    goto case_7;
  }
#line 950
  if ((unsigned int )e->type == 2U) {
#line 950
    goto case_2;
  }
#line 954
  if ((unsigned int )e->type == 1U) {
#line 954
    goto case_1;
  }
#line 958
  if ((unsigned int )e->type == 3U) {
#line 958
    goto case_3;
  }
#line 961
  if ((unsigned int )e->type == 4U) {
#line 961
    goto case_4;
  }
#line 967
  if ((unsigned int )e->type == 5U) {
#line 967
    goto case_5;
  }
#line 973
  goto switch_default;
  case_7: /* CIL Label */ 
  {
#line 948
  sym_calc_value(e->left.sym);
  }
#line 949
  return ((e->left.sym)->curr.tri);
  case_2: /* CIL Label */ 
  {
#line 951
  val1 = expr_calc_value(e->left.expr);
#line 952
  val2 = expr_calc_value(e->right.expr);
  }
#line 953
  if ((unsigned int )val1 < (unsigned int )val2) {
#line 953
    tmp = (unsigned int )val1;
  } else {
#line 953
    tmp = (unsigned int )val2;
  }
#line 953
  return ((tristate )tmp);
  case_1: /* CIL Label */ 
  {
#line 955
  val1 = expr_calc_value(e->left.expr);
#line 956
  val2 = expr_calc_value(e->right.expr);
  }
#line 957
  if ((unsigned int )val1 > (unsigned int )val2) {
#line 957
    tmp___0 = (unsigned int )val1;
  } else {
#line 957
    tmp___0 = (unsigned int )val2;
  }
#line 957
  return ((tristate )tmp___0);
  case_3: /* CIL Label */ 
  {
#line 959
  val1 = expr_calc_value(e->left.expr);
  }
#line 960
  return ((tristate )(2U - (unsigned int )val1));
  case_4: /* CIL Label */ 
  {
#line 962
  sym_calc_value(e->left.sym);
#line 963
  sym_calc_value(e->right.sym);
#line 964
  str1 = sym_get_string_value(e->left.sym);
#line 965
  str2 = sym_get_string_value(e->right.sym);
#line 966
  tmp___3 = strcmp(str1, str2);
  }
#line 966
  if (tmp___3) {
#line 966
    tmp___2 = 0;
  } else {
#line 966
    tmp___2 = 2;
  }
#line 966
  return ((tristate )tmp___2);
  case_5: /* CIL Label */ 
  {
#line 968
  sym_calc_value(e->left.sym);
#line 969
  sym_calc_value(e->right.sym);
#line 970
  str1 = sym_get_string_value(e->left.sym);
#line 971
  str2 = sym_get_string_value(e->right.sym);
#line 972
  tmp___6 = strcmp(str1, str2);
  }
#line 972
  if (tmp___6) {
#line 972
    tmp___5 = 2;
  } else {
#line 972
    tmp___5 = 0;
  }
#line 972
  return ((tristate )tmp___5);
  switch_default: /* CIL Label */ 
  {
#line 974
  printf((char const   */* __restrict  */)"expr_calc_value: %d?\n", (unsigned int )e->type);
  }
#line 975
  return ((tristate )0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 979 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/expr.c"
int expr_compare_type(enum expr_type t1 , enum expr_type t2 ) 
{ 


  {
#line 984
  if ((unsigned int )t1 == (unsigned int )t2) {
#line 985
    return (0);
  }
  {
#line 988
  if ((unsigned int )t1 == 5U) {
#line 988
    goto case_5;
  }
#line 988
  if ((unsigned int )t1 == 4U) {
#line 988
    goto case_5;
  }
#line 991
  if ((unsigned int )t1 == 3U) {
#line 991
    goto case_3;
  }
#line 994
  if ((unsigned int )t1 == 2U) {
#line 994
    goto case_2;
  }
#line 997
  if ((unsigned int )t1 == 1U) {
#line 997
    goto case_1;
  }
#line 1000
  if ((unsigned int )t1 == 6U) {
#line 1000
    goto case_6;
  }
#line 1003
  goto switch_default;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 989
  if ((unsigned int )t2 == 3U) {
#line 990
    return (1);
  }
  case_3: /* CIL Label */ 
#line 992
  if ((unsigned int )t2 == 2U) {
#line 993
    return (1);
  }
  case_2: /* CIL Label */ 
#line 995
  if ((unsigned int )t2 == 1U) {
#line 996
    return (1);
  }
  case_1: /* CIL Label */ 
#line 998
  if ((unsigned int )t2 == 6U) {
#line 999
    return (1);
  }
  case_6: /* CIL Label */ 
#line 1001
  if ((unsigned int )t2 == 0U) {
#line 1002
    return (1);
  }
  switch_default: /* CIL Label */ 
#line 1004
  return (-1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 1006
  printf((char const   */* __restrict  */)"[%dgt%d?]", (unsigned int )t1, (unsigned int )t2);
  }
#line 1007
  return (0);
}
}
#line 1011 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/expr.c"
__inline static struct expr *expr_get_leftmost_symbol(struct expr  const  *e ) 
{ 
  struct expr *tmp ;

  {
#line 1015
  if ((unsigned long )e == (unsigned long )((void *)0)) {
#line 1016
    return ((struct expr *)((void *)0));
  }
  {
#line 1018
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1018
    if (! ((unsigned int const   )e->type != 7U)) {
#line 1018
      goto while_break;
    }
#line 1019
    e = (struct expr  const  *)e->left.expr;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1021
  tmp = expr_copy(e);
  }
#line 1021
  return (tmp);
}
}
#line 1028 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/expr.c"
struct expr *expr_simplify_unmet_dep(struct expr *e1 , struct expr *e2 ) 
{ 
  struct expr *ret ;
  struct expr *tmp ;
  struct expr *tmp___0 ;
  struct expr *tmp___1 ;
  struct expr *e ;
  struct expr *tmp___2 ;
  struct expr *tmp___3 ;
  int tmp___5 ;
  struct expr *tmp___6 ;

  {
  {
#line 1033
  if ((unsigned int )e1->type == 1U) {
#line 1033
    goto case_1;
  }
#line 1037
  if ((unsigned int )e1->type == 2U) {
#line 1037
    goto case_2;
  }
#line 1045
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 1034
  tmp = expr_simplify_unmet_dep(e1->right.expr, e2);
#line 1034
  tmp___0 = expr_simplify_unmet_dep(e1->left.expr, e2);
#line 1034
  tmp___1 = expr_alloc_and(tmp___0, tmp);
  }
#line 1034
  return (tmp___1);
  case_2: /* CIL Label */ 
  {
#line 1039
  tmp___2 = expr_copy((struct expr  const  *)e2);
#line 1039
  tmp___3 = expr_copy((struct expr  const  *)e1);
#line 1039
  e = expr_alloc_and(tmp___3, tmp___2);
#line 1040
  e = expr_eliminate_dups(e);
#line 1041
  tmp___5 = expr_eq(e, e1);
  }
#line 1041
  if (tmp___5) {
#line 1041
    ret = (struct expr *)((void *)0);
  } else {
#line 1041
    ret = e1;
  }
  {
#line 1042
  expr_free(e);
  }
#line 1043
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1046
  ret = e1;
#line 1047
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1050
  tmp___6 = expr_get_leftmost_symbol((struct expr  const  *)ret);
  }
#line 1050
  return (tmp___6);
}
}
#line 1053 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/expr.c"
void expr_print(struct expr *e , void (*fn)(void * , struct symbol * , char const   * ) ,
                void *data , int prevtoken ) 
{ 
  int tmp ;
  char buf[32] ;
  int tmp___0 ;

  {
#line 1055
  if (! e) {
    {
#line 1056
    (*fn)(data, (struct symbol *)((void *)0), "y");
    }
#line 1057
    return;
  }
  {
#line 1060
  tmp = expr_compare_type((enum expr_type )prevtoken, e->type);
  }
#line 1060
  if (tmp > 0) {
    {
#line 1061
    (*fn)(data, (struct symbol *)((void *)0), "(");
    }
  }
  {
#line 1063
  if ((unsigned int )e->type == 7U) {
#line 1063
    goto case_7;
  }
#line 1069
  if ((unsigned int )e->type == 3U) {
#line 1069
    goto case_3;
  }
#line 1073
  if ((unsigned int )e->type == 4U) {
#line 1073
    goto case_4;
  }
#line 1081
  if ((unsigned int )e->type == 5U) {
#line 1081
    goto case_5;
  }
#line 1089
  if ((unsigned int )e->type == 1U) {
#line 1089
    goto case_1;
  }
#line 1094
  if ((unsigned int )e->type == 2U) {
#line 1094
    goto case_2;
  }
#line 1099
  if ((unsigned int )e->type == 6U) {
#line 1099
    goto case_6;
  }
#line 1106
  if ((unsigned int )e->type == 8U) {
#line 1106
    goto case_8;
  }
#line 1113
  goto switch_default;
  case_7: /* CIL Label */ 
#line 1064
  if ((e->left.sym)->name) {
    {
#line 1065
    (*fn)(data, e->left.sym, (char const   *)(e->left.sym)->name);
    }
  } else {
    {
#line 1067
    (*fn)(data, (struct symbol *)((void *)0), "<choice>");
    }
  }
#line 1068
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 1070
  (*fn)(data, (struct symbol *)((void *)0), "!");
#line 1071
  expr_print(e->left.expr, fn, data, 3);
  }
#line 1072
  goto switch_break;
  case_4: /* CIL Label */ 
#line 1074
  if ((e->left.sym)->name) {
    {
#line 1075
    (*fn)(data, e->left.sym, (char const   *)(e->left.sym)->name);
    }
  } else {
    {
#line 1077
    (*fn)(data, (struct symbol *)((void *)0), "<choice>");
    }
  }
  {
#line 1078
  (*fn)(data, (struct symbol *)((void *)0), "=");
#line 1079
  (*fn)(data, e->right.sym, (char const   *)(e->right.sym)->name);
  }
#line 1080
  goto switch_break;
  case_5: /* CIL Label */ 
#line 1082
  if ((e->left.sym)->name) {
    {
#line 1083
    (*fn)(data, e->left.sym, (char const   *)(e->left.sym)->name);
    }
  } else {
    {
#line 1085
    (*fn)(data, (struct symbol *)((void *)0), "<choice>");
    }
  }
  {
#line 1086
  (*fn)(data, (struct symbol *)((void *)0), "!=");
#line 1087
  (*fn)(data, e->right.sym, (char const   *)(e->right.sym)->name);
  }
#line 1088
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1090
  expr_print(e->left.expr, fn, data, 1);
#line 1091
  (*fn)(data, (struct symbol *)((void *)0), " || ");
#line 1092
  expr_print(e->right.expr, fn, data, 1);
  }
#line 1093
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1095
  expr_print(e->left.expr, fn, data, 2);
#line 1096
  (*fn)(data, (struct symbol *)((void *)0), " && ");
#line 1097
  expr_print(e->right.expr, fn, data, 2);
  }
#line 1098
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 1100
  (*fn)(data, e->right.sym, (char const   *)(e->right.sym)->name);
  }
#line 1101
  if (e->left.expr) {
    {
#line 1102
    (*fn)(data, (struct symbol *)((void *)0), " ^ ");
#line 1103
    expr_print(e->left.expr, fn, data, 6);
    }
  }
#line 1105
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 1107
  (*fn)(data, (struct symbol *)((void *)0), "[");
#line 1108
  (*fn)(data, e->left.sym, (char const   *)(e->left.sym)->name);
#line 1109
  (*fn)(data, (struct symbol *)((void *)0), " ");
#line 1110
  (*fn)(data, e->right.sym, (char const   *)(e->right.sym)->name);
#line 1111
  (*fn)(data, (struct symbol *)((void *)0), "]");
  }
#line 1112
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1116
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"<unknown type %d>",
          (unsigned int )e->type);
#line 1117
  (*fn)(data, (struct symbol *)((void *)0), (char const   *)(buf));
  }
#line 1118
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1121
  tmp___0 = expr_compare_type((enum expr_type )prevtoken, e->type);
  }
#line 1121
  if (tmp___0 > 0) {
    {
#line 1122
    (*fn)(data, (struct symbol *)((void *)0), ")");
    }
  }
#line 1123
  return;
}
}
#line 1125 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/expr.c"
static void expr_print_file_helper(void *data , struct symbol *sym , char const   *str ) 
{ 
  size_t tmp ;

  {
  {
#line 1127
  tmp = strlen(str);
#line 1127
  xfwrite((void const   *)str, tmp, (size_t )1, (FILE *)data);
  }
#line 1128
  return;
}
}
#line 1130 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/expr.c"
void expr_fprint(struct expr *e , FILE *out ) 
{ 


  {
  {
#line 1132
  expr_print(e, & expr_print_file_helper, (void *)out, 0);
  }
#line 1133
  return;
}
}
#line 1135 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/expr.c"
static void expr_print_gstr_helper(void *data , struct symbol *sym , char const   *str ) 
{ 
  struct gstr *gs ;
  char const   *sym_str ;
  unsigned int extra_length ;
  size_t tmp ;
  char const   *last_cr ;
  char *tmp___0 ;
  unsigned int last_line_length ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 1137
  gs = (struct gstr *)data;
#line 1138
  sym_str = (char const   *)((void *)0);
#line 1140
  if (sym) {
    {
#line 1141
    sym_str = sym_get_string_value(sym);
    }
  }
#line 1143
  if (gs->max_width) {
    {
#line 1144
    tmp = strlen(str);
#line 1144
    extra_length = (unsigned int )tmp;
#line 1145
    tmp___0 = strrchr((char const   *)gs->s, '\n');
#line 1145
    last_cr = (char const   *)tmp___0;
    }
#line 1148
    if (sym_str) {
      {
#line 1149
      tmp___1 = strlen(sym_str);
#line 1149
      extra_length = (unsigned int )((size_t )extra_length + (4UL + tmp___1));
      }
    }
#line 1151
    if (! last_cr) {
#line 1152
      last_cr = (char const   *)gs->s;
    }
    {
#line 1154
    tmp___2 = strlen((char const   *)gs->s);
#line 1154
    last_line_length = (unsigned int )(tmp___2 - (size_t )(last_cr - (char const   *)gs->s));
    }
#line 1156
    if (last_line_length + extra_length > (unsigned int )gs->max_width) {
      {
#line 1157
      str_append(gs, "\\\n");
      }
    }
  }
  {
#line 1160
  str_append(gs, str);
  }
#line 1161
  if (sym) {
#line 1161
    if ((unsigned int )sym->type != 0U) {
      {
#line 1162
      str_printf(gs, " [=%s]", sym_str);
      }
    }
  }
#line 1163
  return;
}
}
#line 1165 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/expr.c"
void expr_gstr_print(struct expr *e , struct gstr *gs ) 
{ 


  {
  {
#line 1167
  expr_print(e, & expr_print_gstr_helper, (void *)gs, 0);
  }
#line 1168
  return;
}
}
#line 573 "/usr/include/regex.h"
extern int regcomp(regex_t * __restrict  __preg , char const   * __restrict  __pattern ,
                   int __cflags ) ;
#line 577
extern int regexec(regex_t const   * __restrict  __preg , char const   * __restrict  __string ,
                   size_t __nmatch , regmatch_t * __restrict  __pmatch , int __eflags ) ;
#line 585
extern void regfree(regex_t *__preg ) ;
#line 81 "/usr/include/x86_64-linux-gnu/sys/utsname.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) uname)(struct utsname *__name ) ;
#line 14 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/symbol.c"
struct symbol symbol_yes  = 
#line 14 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/symbol.c"
     {(struct symbol *)0, (char *)"y", 0U, {(void *)"y", (tristate )2}, {{(void *)0,
                                                                        0U}, {(void *)0,
                                                                              0U},
                                                                       {(void *)0,
                                                                        0U}, {(void *)0,
                                                                              0U}},
    0U, 129, (struct property *)0, {(struct expr *)0, 0U}, {(struct expr *)0, 0U}};
#line 14 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/symbol.c"
struct symbol symbol_mod  = 
#line 14
     {(struct symbol *)0, (char *)"m", 0U, {(void *)"m", (tristate )1}, {{(void *)0,
                                                                        0U}, {(void *)0,
                                                                              0U},
                                                                       {(void *)0,
                                                                        0U}, {(void *)0,
                                                                              0U}},
    0U, 129, (struct property *)0, {(struct expr *)0, 0U}, {(struct expr *)0, 0U}};
#line 14 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/symbol.c"
struct symbol symbol_no  = 
#line 14
     {(struct symbol *)0, (char *)"n", 0U, {(void *)"n", (tristate )0}, {{(void *)0,
                                                                        0U}, {(void *)0,
                                                                              0U},
                                                                       {(void *)0,
                                                                        0U}, {(void *)0,
                                                                              0U}},
    0U, 129, (struct property *)0, {(struct expr *)0, 0U}, {(struct expr *)0, 0U}};
#line 14 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/symbol.c"
struct symbol symbol_empty  = 
#line 14
     {(struct symbol *)0, (char *)"", 0U, {(void *)"", (tristate )0}, {{(void *)0, 0U},
                                                                     {(void *)0, 0U},
                                                                     {(void *)0, 0U},
                                                                     {(void *)0, 0U}},
    0U, 128, (struct property *)0, {(struct expr *)0, 0U}, {(struct expr *)0, 0U}};
#line 34 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/symbol.c"
tristate modules_val  ;
#line 38 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/symbol.c"
static void sym_add_default(struct symbol *sym , char const   *def ) 
{ 
  struct property *prop ;
  struct property *tmp ;
  struct symbol *tmp___0 ;

  {
  {
#line 40
  tmp = prop_alloc((enum prop_type )4, sym);
#line 40
  prop = tmp;
#line 42
  tmp___0 = sym_lookup(def, 1);
#line 42
  prop->expr = expr_alloc_symbol(tmp___0);
  }
#line 43
  return;
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/symbol.c"
static _Bool inited  =    (_Bool)0;
#line 45 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/symbol.c"
void sym_init(void) 
{ 
  struct symbol *sym ;
  struct utsname uts ;

  {
#line 51
  if (inited) {
#line 52
    return;
  }
  {
#line 53
  inited = (_Bool)1;
#line 55
  uname(& uts);
#line 57
  sym = sym_lookup("UNAME_RELEASE", 0);
#line 58
  sym->type = (enum symbol_type )5;
#line 59
  sym->flags |= 4096;
#line 60
  sym_add_default(sym, (char const   *)(uts.release));
  }
#line 61
  return;
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/symbol.c"
enum symbol_type sym_get_type(struct symbol *sym ) 
{ 
  enum symbol_type type ;
  _Bool tmp ;

  {
#line 65
  type = sym->type;
#line 67
  if ((unsigned int )type == 2U) {
    {
#line 68
    tmp = sym_is_choice_value(sym);
    }
#line 68
    if (tmp) {
#line 68
      if ((unsigned int )sym->visible == 2U) {
#line 69
        type = (enum symbol_type )1;
      } else {
#line 68
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 70
    if ((unsigned int )modules_val == 0U) {
#line 71
      type = (enum symbol_type )1;
    }
  }
#line 73
  return (type);
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/symbol.c"
char const   *sym_type_name(enum symbol_type type ) 
{ 


  {
  {
#line 79
  if ((unsigned int )type == 1U) {
#line 79
    goto case_1;
  }
#line 81
  if ((unsigned int )type == 2U) {
#line 81
    goto case_2;
  }
#line 83
  if ((unsigned int )type == 3U) {
#line 83
    goto case_3;
  }
#line 85
  if ((unsigned int )type == 4U) {
#line 85
    goto case_4;
  }
#line 87
  if ((unsigned int )type == 5U) {
#line 87
    goto case_5;
  }
#line 89
  if ((unsigned int )type == 0U) {
#line 89
    goto case_0;
  }
#line 91
  if ((unsigned int )type == 6U) {
#line 91
    goto case_6;
  }
#line 78
  goto switch_break;
  case_1: /* CIL Label */ 
#line 80
  return ("boolean");
  case_2: /* CIL Label */ 
#line 82
  return ("tristate");
  case_3: /* CIL Label */ 
#line 84
  return ("integer");
  case_4: /* CIL Label */ 
#line 86
  return ("hex");
  case_5: /* CIL Label */ 
#line 88
  return ("string");
  case_0: /* CIL Label */ 
#line 90
  return ("unknown");
  case_6: /* CIL Label */ 
#line 92
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 94
  return ("???");
}
}
#line 97 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/symbol.c"
struct property *sym_get_choice_prop(struct symbol *sym ) 
{ 
  struct property *prop ;

  {
#line 101
  prop = sym->prop;
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    if (! prop) {
#line 101
      goto while_break;
    }
#line 101
    if ((unsigned int )prop->type == 5U) {
#line 102
      return (prop);
    }
#line 101
    prop = prop->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 103
  return ((struct property *)((void *)0));
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/symbol.c"
struct property *sym_get_env_prop(struct symbol *sym ) 
{ 
  struct property *prop ;

  {
#line 110
  prop = sym->prop;
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 110
    if (! prop) {
#line 110
      goto while_break;
    }
#line 110
    if ((unsigned int )prop->type == 8U) {
#line 111
      return (prop);
    }
#line 110
    prop = prop->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 112
  return ((struct property *)((void *)0));
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/symbol.c"
struct property *sym_get_default_prop(struct symbol *sym ) 
{ 
  struct property *prop ;

  {
#line 119
  prop = sym->prop;
  {
#line 119
  while (1) {
    while_continue: /* CIL Label */ ;
#line 119
    if (! prop) {
#line 119
      goto while_break;
    }
#line 119
    if ((unsigned int )prop->type == 4U) {
      {
#line 120
      prop->visible.tri = expr_calc_value(prop->visible.expr);
      }
#line 121
      if ((unsigned int )prop->visible.tri != 0U) {
#line 122
        return (prop);
      }
    }
#line 119
    prop = prop->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 124
  return ((struct property *)((void *)0));
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/symbol.c"
static struct property *sym_get_range_prop(struct symbol *sym ) 
{ 
  struct property *prop ;

  {
#line 131
  prop = sym->prop;
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    if (! prop) {
#line 131
      goto while_break;
    }
#line 131
    if ((unsigned int )prop->type == 7U) {
      {
#line 132
      prop->visible.tri = expr_calc_value(prop->visible.expr);
      }
#line 133
      if ((unsigned int )prop->visible.tri != 0U) {
#line 134
        return (prop);
      }
    }
#line 131
    prop = prop->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 136
  return ((struct property *)((void *)0));
}
}
#line 139 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/symbol.c"
static int sym_get_range_val(struct symbol *sym , int base ) 
{ 
  long tmp ;

  {
  {
#line 141
  sym_calc_value(sym);
  }
  {
#line 143
  if ((unsigned int )sym->type == 3U) {
#line 143
    goto case_3;
  }
#line 146
  if ((unsigned int )sym->type == 4U) {
#line 146
    goto case_4;
  }
#line 149
  goto switch_default;
  case_3: /* CIL Label */ 
#line 144
  base = 10;
#line 145
  goto switch_break;
  case_4: /* CIL Label */ 
#line 147
  base = 16;
#line 148
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 150
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 152
  tmp = strtol((char const   */* __restrict  */)sym->curr.val, (char **/* __restrict  */)((void *)0),
               base);
  }
#line 152
  return ((int )tmp);
}
}
#line 155 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/symbol.c"
static void sym_validate_range(struct symbol *sym ) 
{ 
  struct property *prop ;
  int base ;
  int val ;
  int val2 ;
  char str[64] ;
  long tmp ;
  char *tmp___0 ;

  {
  {
#line 162
  if ((unsigned int )sym->type == 3U) {
#line 162
    goto case_3;
  }
#line 165
  if ((unsigned int )sym->type == 4U) {
#line 165
    goto case_4;
  }
#line 168
  goto switch_default;
  case_3: /* CIL Label */ 
#line 163
  base = 10;
#line 164
  goto switch_break;
  case_4: /* CIL Label */ 
#line 166
  base = 16;
#line 167
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 169
  return;
  switch_break: /* CIL Label */ ;
  }
  {
#line 171
  prop = sym_get_range_prop(sym);
  }
#line 172
  if (! prop) {
#line 173
    return;
  }
  {
#line 174
  tmp = strtol((char const   */* __restrict  */)sym->curr.val, (char **/* __restrict  */)((void *)0),
               base);
#line 174
  val = (int )tmp;
#line 175
  val2 = sym_get_range_val((prop->expr)->left.sym, base);
  }
#line 176
  if (val >= val2) {
    {
#line 177
    val2 = sym_get_range_val((prop->expr)->right.sym, base);
    }
#line 178
    if (val <= val2) {
#line 179
      return;
    }
  }
#line 181
  if ((unsigned int )sym->type == 3U) {
    {
#line 182
    sprintf((char */* __restrict  */)(str), (char const   */* __restrict  */)"%d",
            val2);
    }
  } else {
    {
#line 184
    sprintf((char */* __restrict  */)(str), (char const   */* __restrict  */)"0x%x",
            val2);
    }
  }
  {
#line 185
  tmp___0 = strdup((char const   *)(str));
#line 185
  sym->curr.val = (void *)tmp___0;
  }
#line 186
  return;
}
}
#line 188 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/symbol.c"
static void sym_calc_visibility(struct symbol *sym ) 
{ 
  struct property *prop ;
  tristate tri ;
  _Bool tmp ;
  enum symbol_type tmp___0 ;

  {
#line 194
  tri = (tristate )0;
#line 195
  prop = sym->prop;
  {
#line 195
  while (1) {
    while_continue: /* CIL Label */ ;
#line 195
    if (! prop) {
#line 195
      goto while_break;
    }
#line 195
    if (prop->text) {
      {
#line 196
      prop->visible.tri = expr_calc_value(prop->visible.expr);
      }
#line 197
      if ((unsigned int )tri > (unsigned int )prop->visible.tri) {
#line 197
        tri = tri;
      } else {
#line 197
        tri = prop->visible.tri;
      }
    }
#line 195
    prop = prop->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 199
  if ((unsigned int )tri == 1U) {
#line 199
    if ((unsigned int )sym->type != 2U) {
#line 200
      tri = (tristate )2;
    } else
#line 199
    if ((unsigned int )modules_val == 0U) {
#line 200
      tri = (tristate )2;
    }
  }
#line 201
  if ((unsigned int )sym->visible != (unsigned int )tri) {
    {
#line 202
    sym->visible = tri;
#line 203
    sym_set_changed(sym);
    }
  }
  {
#line 205
  tmp = sym_is_choice_value(sym);
  }
#line 205
  if (tmp) {
#line 206
    return;
  }
#line 208
  tri = (tristate )2;
#line 209
  if (sym->dir_dep.expr) {
    {
#line 210
    tri = expr_calc_value(sym->dir_dep.expr);
    }
  }
#line 211
  if ((unsigned int )tri == 1U) {
#line 212
    tri = (tristate )2;
  }
#line 213
  if ((unsigned int )sym->dir_dep.tri != (unsigned int )tri) {
    {
#line 214
    sym->dir_dep.tri = tri;
#line 215
    sym_set_changed(sym);
    }
  }
#line 217
  tri = (tristate )0;
#line 218
  if (sym->rev_dep.expr) {
    {
#line 219
    tri = expr_calc_value(sym->rev_dep.expr);
    }
  }
#line 220
  if ((unsigned int )tri == 1U) {
    {
#line 220
    tmp___0 = sym_get_type(sym);
    }
#line 220
    if ((unsigned int )tmp___0 == 1U) {
#line 221
      tri = (tristate )2;
    }
  }
#line 222
  if ((unsigned int )sym->rev_dep.tri != (unsigned int )tri) {
    {
#line 223
    sym->rev_dep.tri = tri;
#line 224
    sym_set_changed(sym);
    }
  }
#line 226
  return;
}
}
#line 234 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/symbol.c"
struct symbol *sym_choice_default(struct symbol *sym ) 
{ 
  struct symbol *def_sym ;
  struct property *prop ;
  struct expr *e ;

  {
#line 241
  prop = sym->prop;
  {
#line 241
  while (1) {
    while_continue: /* CIL Label */ ;
#line 241
    if (! prop) {
#line 241
      goto while_break;
    }
#line 241
    if ((unsigned int )prop->type == 4U) {
      {
#line 242
      prop->visible.tri = expr_calc_value(prop->visible.expr);
      }
#line 243
      if ((unsigned int )prop->visible.tri == 0U) {
#line 244
        goto __Cont;
      }
      {
#line 245
      def_sym = prop_get_symbol(prop);
      }
#line 246
      if ((unsigned int )def_sym->visible != 0U) {
#line 247
        return (def_sym);
      }
    }
    __Cont: /* CIL Label */ 
#line 241
    prop = prop->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 251
  prop = sym_get_choice_prop(sym);
#line 252
  e = prop->expr;
  }
  {
#line 252
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 252
    if (e) {
#line 252
      def_sym = e->right.sym;
#line 252
      if (! def_sym) {
#line 252
        goto while_break___0;
      }
    } else {
#line 252
      goto while_break___0;
    }
#line 253
    if ((unsigned int )def_sym->visible != 0U) {
#line 254
      return (def_sym);
    }
#line 252
    e = e->left.expr;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 257
  return ((struct symbol *)((void *)0));
}
}
#line 260 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/symbol.c"
static struct symbol *sym_calc_choice(struct symbol *sym ) 
{ 
  struct symbol *def_sym ;
  struct property *prop ;
  struct expr *e ;
  int flags ;

  {
  {
#line 268
  flags = sym->flags;
#line 269
  prop = sym_get_choice_prop(sym);
#line 270
  e = prop->expr;
  }
  {
#line 270
  while (1) {
    while_continue: /* CIL Label */ ;
#line 270
    if (e) {
#line 270
      def_sym = e->right.sym;
#line 270
      if (! def_sym) {
#line 270
        goto while_break;
      }
    } else {
#line 270
      goto while_break;
    }
    {
#line 271
    sym_calc_visibility(def_sym);
    }
#line 272
    if ((unsigned int )def_sym->visible != 0U) {
#line 273
      flags &= def_sym->flags;
    }
#line 270
    e = e->left.expr;
  }
  while_break: /* CIL Label */ ;
  }
#line 276
  sym->flags &= flags | -65537;
#line 279
  def_sym = (struct symbol *)sym->def[0].val;
#line 280
  if (def_sym) {
#line 280
    if ((unsigned int )def_sym->visible != 0U) {
#line 281
      return (def_sym);
    }
  }
  {
#line 283
  def_sym = sym_choice_default(sym);
  }
#line 285
  if ((unsigned long )def_sym == (unsigned long )((void *)0)) {
#line 287
    sym->curr.tri = (tristate )0;
  }
#line 289
  return (def_sym);
}
}
#line 292 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/symbol.c"
void sym_calc_value(struct symbol *sym ) 
{ 
  struct symbol_value newval ;
  struct symbol_value oldval ;
  struct property *prop ;
  struct expr *e ;
  _Bool tmp ;
  enum symbol_type tmp___0 ;
  struct symbol *tmp___2 ;
  _Bool tmp___3 ;
  tristate tmp___5 ;
  tristate tmp___6 ;
  _Bool tmp___7 ;
  struct expr *e___0 ;
  _Bool tmp___8 ;
  enum symbol_type tmp___9 ;
  _Bool tmp___10 ;
  struct symbol *ds ;
  struct symbol *tmp___11 ;
  struct symbol *tmp___12 ;
  _Bool tmp___13 ;
  int tmp___14 ;
  struct symbol *choice_sym ;
  _Bool tmp___15 ;

  {
#line 298
  if (! sym) {
#line 299
    return;
  }
#line 301
  if (sym->flags & 128) {
#line 302
    return;
  }
#line 303
  sym->flags |= 128;
#line 305
  oldval = sym->curr;
  {
#line 310
  if ((unsigned int )sym->type == 5U) {
#line 310
    goto case_5;
  }
#line 310
  if ((unsigned int )sym->type == 4U) {
#line 310
    goto case_5;
  }
#line 310
  if ((unsigned int )sym->type == 3U) {
#line 310
    goto case_5;
  }
#line 314
  if ((unsigned int )sym->type == 2U) {
#line 314
    goto case_2;
  }
#line 314
  if ((unsigned int )sym->type == 1U) {
#line 314
    goto case_2;
  }
#line 317
  goto switch_default;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 311
  newval = symbol_empty.curr;
#line 312
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 315
  newval = symbol_no.curr;
#line 316
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 318
  sym->curr.val = (void *)sym->name;
#line 319
  sym->curr.tri = (tristate )0;
#line 320
  return;
  switch_break: /* CIL Label */ ;
  }
  {
#line 322
  tmp = sym_is_choice_value(sym);
  }
#line 322
  if (! tmp) {
#line 323
    sym->flags &= -513;
  }
  {
#line 325
  sym_calc_visibility(sym);
#line 328
  sym->curr = newval;
#line 330
  tmp___0 = sym_get_type(sym);
  }
  {
#line 332
  if ((unsigned int )tmp___0 == 2U) {
#line 332
    goto case_2___0;
  }
#line 332
  if ((unsigned int )tmp___0 == 1U) {
#line 332
    goto case_2___0;
  }
#line 378
  if ((unsigned int )tmp___0 == 3U) {
#line 378
    goto case_3___0;
  }
#line 378
  if ((unsigned int )tmp___0 == 4U) {
#line 378
    goto case_3___0;
  }
#line 378
  if ((unsigned int )tmp___0 == 5U) {
#line 378
    goto case_3___0;
  }
#line 396
  goto switch_default___0;
  case_2___0: /* CIL Label */ 
  case_1___0: /* CIL Label */ 
  {
#line 333
  tmp___8 = sym_is_choice_value(sym);
  }
#line 333
  if (tmp___8) {
#line 333
    if ((unsigned int )sym->visible == 2U) {
      {
#line 334
      prop = sym_get_choice_prop(sym);
#line 335
      tmp___2 = prop_get_symbol(prop);
      }
#line 335
      if ((unsigned long )tmp___2->curr.val == (unsigned long )sym) {
#line 335
        newval.tri = (tristate )2;
      } else {
#line 335
        newval.tri = (tristate )0;
      }
    } else {
#line 333
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 337
    if ((unsigned int )sym->visible != 0U) {
      {
#line 341
      sym->flags |= 512;
#line 342
      tmp___3 = sym_has_value(sym);
      }
#line 342
      if (tmp___3) {
#line 343
        if ((unsigned int )sym->def[0].tri < (unsigned int )sym->visible) {
#line 343
          newval.tri = sym->def[0].tri;
        } else {
#line 343
          newval.tri = sym->visible;
        }
#line 345
        goto calc_newval;
      }
    }
#line 348
    if ((unsigned int )sym->rev_dep.tri != 0U) {
#line 349
      sym->flags |= 512;
    }
    {
#line 350
    tmp___7 = sym_is_choice(sym);
    }
#line 350
    if (! tmp___7) {
      {
#line 351
      prop = sym_get_default_prop(sym);
      }
#line 352
      if (prop) {
        {
#line 353
        sym->flags |= 512;
#line 354
        tmp___6 = expr_calc_value(prop->expr);
        }
#line 354
        if ((unsigned int )tmp___6 < (unsigned int )prop->visible.tri) {
          {
#line 354
          tmp___5 = expr_calc_value(prop->expr);
#line 354
          newval.tri = tmp___5;
          }
        } else {
#line 354
          newval.tri = prop->visible.tri;
        }
      }
    }
    calc_newval: 
#line 359
    if ((unsigned int )sym->dir_dep.tri == 0U) {
#line 359
      if ((unsigned int )sym->rev_dep.tri != 0U) {
        {
#line 361
        e___0 = expr_simplify_unmet_dep(sym->rev_dep.expr, sym->dir_dep.expr);
#line 363
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"warning: (");
#line 364
        expr_fprint(e___0, stderr);
#line 365
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)") selects %s which has unmet direct dependencies (",
                sym->name);
#line 367
        expr_fprint(sym->dir_dep.expr, stderr);
#line 368
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)")\n");
#line 369
        expr_free(e___0);
        }
      }
    }
#line 371
    if ((unsigned int )newval.tri > (unsigned int )sym->rev_dep.tri) {
#line 371
      newval.tri = newval.tri;
    } else {
#line 371
      newval.tri = sym->rev_dep.tri;
    }
  }
#line 373
  if ((unsigned int )newval.tri == 1U) {
    {
#line 373
    tmp___9 = sym_get_type(sym);
    }
#line 373
    if ((unsigned int )tmp___9 == 1U) {
#line 374
      newval.tri = (tristate )2;
    }
  }
#line 375
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
  case_4___0: /* CIL Label */ 
  case_5___0: /* CIL Label */ 
#line 379
  if ((unsigned int )sym->visible != 0U) {
    {
#line 380
    sym->flags |= 512;
#line 381
    tmp___10 = sym_has_value(sym);
    }
#line 381
    if (tmp___10) {
#line 382
      newval.val = sym->def[0].val;
#line 383
      goto switch_break___0;
    }
  }
  {
#line 386
  prop = sym_get_default_prop(sym);
  }
#line 387
  if (prop) {
    {
#line 388
    tmp___11 = prop_get_symbol(prop);
#line 388
    ds = tmp___11;
    }
#line 389
    if (ds) {
      {
#line 390
      sym->flags |= 512;
#line 391
      sym_calc_value(ds);
#line 392
      newval.val = ds->curr.val;
      }
    }
  }
#line 395
  goto switch_break___0;
  switch_default___0: /* CIL Label */ ;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 400
  sym->curr = newval;
#line 401
  tmp___13 = sym_is_choice(sym);
  }
#line 401
  if (tmp___13) {
#line 401
    if ((unsigned int )newval.tri == 2U) {
      {
#line 402
      tmp___12 = sym_calc_choice(sym);
#line 402
      sym->curr.val = (void *)tmp___12;
      }
    }
  }
  {
#line 403
  sym_validate_range(sym);
#line 405
  tmp___14 = memcmp((void const   *)(& oldval), (void const   *)(& sym->curr), sizeof(oldval));
  }
#line 405
  if (tmp___14) {
    {
#line 406
    sym_set_changed(sym);
    }
#line 407
    if ((unsigned long )modules_sym == (unsigned long )sym) {
      {
#line 408
      sym_set_all_changed();
#line 409
      modules_val = modules_sym->curr.tri;
      }
    }
  }
  {
#line 413
  tmp___15 = sym_is_choice(sym);
  }
#line 413
  if (tmp___15) {
    {
#line 416
    prop = sym_get_choice_prop(sym);
#line 417
    e = prop->expr;
    }
    {
#line 417
    while (1) {
      while_continue: /* CIL Label */ ;
#line 417
      if (e) {
#line 417
        choice_sym = e->right.sym;
#line 417
        if (! choice_sym) {
#line 417
          goto while_break;
        }
      } else {
#line 417
        goto while_break;
      }
#line 418
      if (sym->flags & 512) {
#line 418
        if ((unsigned int )choice_sym->visible != 0U) {
#line 420
          choice_sym->flags |= 512;
        }
      }
#line 421
      if (sym->flags & 1024) {
        {
#line 422
        sym_set_changed(choice_sym);
        }
      }
#line 417
      e = e->left.expr;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 426
  if (sym->flags & 4096) {
#line 427
    sym->flags &= -513;
  }
#line 428
  return;
}
}
#line 430 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/symbol.c"
void sym_clear_all_valid(void) 
{ 
  struct symbol *sym ;
  int i ;

  {
#line 435
  i = 0;
  {
#line 435
  while (1) {
    while_continue: /* CIL Label */ ;
#line 435
    if (! (i < 9973)) {
#line 435
      goto while_break;
    }
#line 435
    sym = symbol_hash[i];
    {
#line 435
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 435
      if (! sym) {
#line 435
        goto while_break___0;
      }
#line 435
      if ((unsigned int )sym->type != 6U) {
#line 436
        sym->flags &= -129;
      }
#line 435
      sym = sym->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 435
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 437
  sym_add_change_count(1);
  }
#line 438
  if (modules_sym) {
    {
#line 439
    sym_calc_value(modules_sym);
    }
  }
#line 440
  return;
}
}
#line 442 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/symbol.c"
void sym_set_changed(struct symbol *sym ) 
{ 
  struct property *prop ;

  {
#line 446
  sym->flags |= 1024;
#line 447
  prop = sym->prop;
  {
#line 447
  while (1) {
    while_continue: /* CIL Label */ ;
#line 447
    if (! prop) {
#line 447
      goto while_break;
    }
#line 448
    if (prop->menu) {
#line 449
      (prop->menu)->flags |= 1U;
    }
#line 447
    prop = prop->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 451
  return;
}
}
#line 453 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/symbol.c"
void sym_set_all_changed(void) 
{ 
  struct symbol *sym ;
  int i ;

  {
#line 458
  i = 0;
  {
#line 458
  while (1) {
    while_continue: /* CIL Label */ ;
#line 458
    if (! (i < 9973)) {
#line 458
      goto while_break;
    }
#line 458
    sym = symbol_hash[i];
    {
#line 458
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 458
      if (! sym) {
#line 458
        goto while_break___0;
      }
#line 458
      if ((unsigned int )sym->type != 6U) {
        {
#line 459
        sym_set_changed(sym);
        }
      }
#line 458
      sym = sym->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 458
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 460
  return;
}
}
#line 462 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/symbol.c"
_Bool sym_tristate_within_range(struct symbol *sym , tristate val ) 
{ 
  int type ;
  enum symbol_type tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;

  {
  {
#line 464
  tmp = sym_get_type(sym);
#line 464
  type = (int )tmp;
  }
#line 466
  if ((unsigned int )sym->visible == 0U) {
#line 467
    return ((_Bool)0);
  }
#line 469
  if (type != 1) {
#line 469
    if (type != 2) {
#line 470
      return ((_Bool)0);
    }
  }
#line 472
  if (type == 1) {
#line 472
    if ((unsigned int )val == 1U) {
#line 473
      return ((_Bool)0);
    }
  }
#line 474
  if ((unsigned int )sym->visible <= (unsigned int )sym->rev_dep.tri) {
#line 475
    return ((_Bool)0);
  }
  {
#line 476
  tmp___0 = sym_is_choice_value(sym);
  }
#line 476
  if (tmp___0) {
#line 476
    if ((unsigned int )sym->visible == 2U) {
#line 477
      return ((_Bool )((unsigned int )val == 2U));
    }
  }
#line 478
  if ((unsigned int )val >= (unsigned int )sym->rev_dep.tri) {
#line 478
    if ((unsigned int )val <= (unsigned int )sym->visible) {
#line 478
      tmp___1 = 1;
    } else {
#line 478
      tmp___1 = 0;
    }
  } else {
#line 478
    tmp___1 = 0;
  }
#line 478
  return ((_Bool )tmp___1);
}
}
#line 481 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/symbol.c"
_Bool sym_set_tristate_value(struct symbol *sym , tristate val ) 
{ 
  tristate oldval ;
  tristate tmp ;
  _Bool tmp___0 ;
  struct symbol *cs ;
  struct property *tmp___1 ;
  struct symbol *tmp___2 ;
  struct property *prop ;
  struct expr *e ;
  _Bool tmp___3 ;

  {
  {
#line 483
  tmp = sym_get_tristate_value(sym);
#line 483
  oldval = tmp;
  }
#line 485
  if ((unsigned int )oldval != (unsigned int )val) {
    {
#line 485
    tmp___0 = sym_tristate_within_range(sym, val);
    }
#line 485
    if (! tmp___0) {
#line 486
      return ((_Bool)0);
    }
  }
#line 488
  if (! (sym->flags & 65536)) {
    {
#line 489
    sym->flags |= 65536;
#line 490
    sym_set_changed(sym);
    }
  }
  {
#line 496
  tmp___3 = sym_is_choice_value(sym);
  }
#line 496
  if (tmp___3) {
#line 496
    if ((unsigned int )val == 2U) {
      {
#line 497
      tmp___1 = sym_get_choice_prop(sym);
#line 497
      tmp___2 = prop_get_symbol(tmp___1);
#line 497
      cs = tmp___2;
#line 501
      cs->def[0].val = (void *)sym;
#line 502
      cs->flags |= 65536;
#line 503
      prop = sym_get_choice_prop(cs);
#line 504
      e = prop->expr;
      }
      {
#line 504
      while (1) {
        while_continue: /* CIL Label */ ;
#line 504
        if (! e) {
#line 504
          goto while_break;
        }
#line 505
        if ((unsigned int )(e->right.sym)->visible != 0U) {
#line 506
          (e->right.sym)->flags |= 65536;
        }
#line 504
        e = e->left.expr;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 510
  sym->def[0].tri = val;
#line 511
  if ((unsigned int )oldval != (unsigned int )val) {
    {
#line 512
    sym_clear_all_valid();
    }
  }
#line 514
  return ((_Bool)1);
}
}
#line 517 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/symbol.c"
tristate sym_toggle_tristate_value(struct symbol *sym ) 
{ 
  tristate oldval ;
  tristate newval ;
  _Bool tmp ;

  {
  {
#line 521
  newval = sym_get_tristate_value(sym);
#line 521
  oldval = newval;
  }
  {
#line 522
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 524
    if ((unsigned int )newval == 0U) {
#line 524
      goto case_0;
    }
#line 527
    if ((unsigned int )newval == 1U) {
#line 527
      goto case_1;
    }
#line 530
    if ((unsigned int )newval == 2U) {
#line 530
      goto case_2;
    }
#line 523
    goto switch_break;
    case_0: /* CIL Label */ 
#line 525
    newval = (tristate )1;
#line 526
    goto switch_break;
    case_1: /* CIL Label */ 
#line 528
    newval = (tristate )2;
#line 529
    goto switch_break;
    case_2: /* CIL Label */ 
#line 531
    newval = (tristate )0;
#line 532
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 534
    tmp = sym_set_tristate_value(sym, newval);
    }
#line 534
    if (tmp) {
#line 535
      goto while_break;
    }
#line 522
    if (! ((unsigned int )oldval != (unsigned int )newval)) {
#line 522
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 537
  return (newval);
}
}
#line 540 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/symbol.c"
_Bool sym_string_valid(struct symbol *sym , char const   *str ) 
{ 
  signed char ch ;
  char const   *tmp ;
  char const   *tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  unsigned short const   **tmp___5 ;
  char const   *tmp___6 ;

  {
  {
#line 545
  if ((unsigned int )sym->type == 5U) {
#line 545
    goto case_5;
  }
#line 547
  if ((unsigned int )sym->type == 3U) {
#line 547
    goto case_3;
  }
#line 560
  if ((unsigned int )sym->type == 4U) {
#line 560
    goto case_4;
  }
#line 570
  if ((unsigned int )sym->type == 2U) {
#line 570
    goto case_2;
  }
#line 570
  if ((unsigned int )sym->type == 1U) {
#line 570
    goto case_2;
  }
#line 578
  goto switch_default;
  case_5: /* CIL Label */ 
#line 546
  return ((_Bool)1);
  case_3: /* CIL Label */ 
#line 548
  tmp = str;
#line 548
  str ++;
#line 548
  ch = (signed char )*tmp;
#line 549
  if ((int )ch == 45) {
#line 550
    tmp___0 = str;
#line 550
    str ++;
#line 550
    ch = (signed char )*tmp___0;
  }
  {
#line 551
  tmp___1 = __ctype_b_loc();
  }
#line 551
  if (! ((int const   )*(*tmp___1 + (int )ch) & 2048)) {
#line 552
    return ((_Bool)0);
  }
#line 553
  if ((int )ch == 48) {
#line 553
    if ((int const   )*str != 0) {
#line 554
      return ((_Bool)0);
    }
  }
  {
#line 555
  while (1) {
    while_continue: /* CIL Label */ ;
#line 555
    tmp___3 = str;
#line 555
    str ++;
#line 555
    ch = (signed char )*tmp___3;
#line 555
    if (! ch) {
#line 555
      goto while_break;
    }
    {
#line 556
    tmp___2 = __ctype_b_loc();
    }
#line 556
    if (! ((int const   )*(*tmp___2 + (int )ch) & 2048)) {
#line 557
      return ((_Bool)0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 559
  return ((_Bool)1);
  case_4: /* CIL Label */ 
#line 561
  if ((int const   )*(str + 0) == 48) {
#line 561
    if ((int const   )*(str + 1) == 120) {
#line 562
      str += 2;
    } else
#line 561
    if ((int const   )*(str + 1) == 88) {
#line 562
      str += 2;
    }
  }
#line 563
  tmp___4 = str;
#line 563
  str ++;
#line 563
  ch = (signed char )*tmp___4;
  {
#line 564
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 565
    tmp___5 = __ctype_b_loc();
    }
#line 565
    if (! ((int const   )*(*tmp___5 + (int )ch) & 4096)) {
#line 566
      return ((_Bool)0);
    }
#line 564
    tmp___6 = str;
#line 564
    str ++;
#line 564
    ch = (signed char )*tmp___6;
#line 564
    if (! ch) {
#line 564
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 568
  return ((_Bool)1);
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 574
  if ((int const   )*(str + 0) == 78) {
#line 574
    goto case_78;
  }
#line 574
  if ((int const   )*(str + 0) == 110) {
#line 574
    goto case_78;
  }
#line 574
  if ((int const   )*(str + 0) == 77) {
#line 574
    goto case_78;
  }
#line 574
  if ((int const   )*(str + 0) == 109) {
#line 574
    goto case_78;
  }
#line 574
  if ((int const   )*(str + 0) == 89) {
#line 574
    goto case_78;
  }
#line 574
  if ((int const   )*(str + 0) == 121) {
#line 574
    goto case_78;
  }
#line 571
  goto switch_break___0;
  case_78: /* CIL Label */ 
  case_110: /* CIL Label */ 
  case_77: /* CIL Label */ 
  case_109: /* CIL Label */ 
  case_89: /* CIL Label */ 
  case_121: /* CIL Label */ 
#line 575
  return ((_Bool)1);
  switch_break___0: /* CIL Label */ ;
  }
#line 577
  return ((_Bool)0);
  switch_default: /* CIL Label */ 
#line 579
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 583 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/symbol.c"
_Bool sym_string_within_range(struct symbol *sym , char const   *str ) 
{ 
  struct property *prop ;
  int val ;
  _Bool tmp ;
  _Bool tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  _Bool tmp___5 ;
  long tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  _Bool tmp___10 ;
  _Bool tmp___11 ;
  _Bool tmp___12 ;

  {
  {
#line 589
  if ((unsigned int )sym->type == 5U) {
#line 589
    goto case_5;
  }
#line 591
  if ((unsigned int )sym->type == 3U) {
#line 591
    goto case_3;
  }
#line 600
  if ((unsigned int )sym->type == 4U) {
#line 600
    goto case_4;
  }
#line 610
  if ((unsigned int )sym->type == 2U) {
#line 610
    goto case_2;
  }
#line 610
  if ((unsigned int )sym->type == 1U) {
#line 610
    goto case_2;
  }
#line 620
  goto switch_default;
  case_5: /* CIL Label */ 
  {
#line 590
  tmp = sym_string_valid(sym, str);
  }
#line 590
  return (tmp);
  case_3: /* CIL Label */ 
  {
#line 592
  tmp___0 = sym_string_valid(sym, str);
  }
#line 592
  if (! tmp___0) {
#line 593
    return ((_Bool)0);
  }
  {
#line 594
  prop = sym_get_range_prop(sym);
  }
#line 595
  if (! prop) {
#line 596
    return ((_Bool)1);
  }
  {
#line 597
  tmp___1 = strtol((char const   */* __restrict  */)str, (char **/* __restrict  */)((void *)0),
                   10);
#line 597
  val = (int )tmp___1;
#line 598
  tmp___2 = sym_get_range_val((prop->expr)->left.sym, 10);
  }
#line 598
  if (val >= tmp___2) {
    {
#line 598
    tmp___3 = sym_get_range_val((prop->expr)->right.sym, 10);
    }
#line 598
    if (val <= tmp___3) {
#line 598
      tmp___4 = 1;
    } else {
#line 598
      tmp___4 = 0;
    }
  } else {
#line 598
    tmp___4 = 0;
  }
#line 598
  return ((_Bool )tmp___4);
  case_4: /* CIL Label */ 
  {
#line 601
  tmp___5 = sym_string_valid(sym, str);
  }
#line 601
  if (! tmp___5) {
#line 602
    return ((_Bool)0);
  }
  {
#line 603
  prop = sym_get_range_prop(sym);
  }
#line 604
  if (! prop) {
#line 605
    return ((_Bool)1);
  }
  {
#line 606
  tmp___6 = strtol((char const   */* __restrict  */)str, (char **/* __restrict  */)((void *)0),
                   16);
#line 606
  val = (int )tmp___6;
#line 607
  tmp___7 = sym_get_range_val((prop->expr)->left.sym, 16);
  }
#line 607
  if (val >= tmp___7) {
    {
#line 607
    tmp___8 = sym_get_range_val((prop->expr)->right.sym, 16);
    }
#line 607
    if (val <= tmp___8) {
#line 607
      tmp___9 = 1;
    } else {
#line 607
      tmp___9 = 0;
    }
  } else {
#line 607
    tmp___9 = 0;
  }
#line 607
  return ((_Bool )tmp___9);
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 612
  if ((int const   )*(str + 0) == 89) {
#line 612
    goto case_89;
  }
#line 612
  if ((int const   )*(str + 0) == 121) {
#line 612
    goto case_89;
  }
#line 614
  if ((int const   )*(str + 0) == 77) {
#line 614
    goto case_77;
  }
#line 614
  if ((int const   )*(str + 0) == 109) {
#line 614
    goto case_77;
  }
#line 616
  if ((int const   )*(str + 0) == 78) {
#line 616
    goto case_78;
  }
#line 616
  if ((int const   )*(str + 0) == 110) {
#line 616
    goto case_78;
  }
#line 611
  goto switch_break___0;
  case_89: /* CIL Label */ 
  case_121: /* CIL Label */ 
  {
#line 613
  tmp___10 = sym_tristate_within_range(sym, (tristate )2);
  }
#line 613
  return (tmp___10);
  case_77: /* CIL Label */ 
  case_109: /* CIL Label */ 
  {
#line 615
  tmp___11 = sym_tristate_within_range(sym, (tristate )1);
  }
#line 615
  return (tmp___11);
  case_78: /* CIL Label */ 
  case_110: /* CIL Label */ 
  {
#line 617
  tmp___12 = sym_tristate_within_range(sym, (tristate )0);
  }
#line 617
  return (tmp___12);
  switch_break___0: /* CIL Label */ ;
  }
#line 619
  return ((_Bool)0);
  switch_default: /* CIL Label */ 
#line 621
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 625 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/symbol.c"
_Bool sym_set_string_value(struct symbol *sym , char const   *newval ) 
{ 
  char const   *oldval ;
  char *val ;
  int size ;
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;

  {
  {
#line 633
  if ((unsigned int )sym->type == 2U) {
#line 633
    goto case_2;
  }
#line 633
  if ((unsigned int )sym->type == 1U) {
#line 633
    goto case_2;
  }
#line 643
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 635
  if ((int const   )*(newval + 0) == 89) {
#line 635
    goto case_89;
  }
#line 635
  if ((int const   )*(newval + 0) == 121) {
#line 635
    goto case_89;
  }
#line 637
  if ((int const   )*(newval + 0) == 77) {
#line 637
    goto case_77;
  }
#line 637
  if ((int const   )*(newval + 0) == 109) {
#line 637
    goto case_77;
  }
#line 639
  if ((int const   )*(newval + 0) == 78) {
#line 639
    goto case_78;
  }
#line 639
  if ((int const   )*(newval + 0) == 110) {
#line 639
    goto case_78;
  }
#line 634
  goto switch_break___0;
  case_89: /* CIL Label */ 
  case_121: /* CIL Label */ 
  {
#line 636
  tmp = sym_set_tristate_value(sym, (tristate )2);
  }
#line 636
  return (tmp);
  case_77: /* CIL Label */ 
  case_109: /* CIL Label */ 
  {
#line 638
  tmp___0 = sym_set_tristate_value(sym, (tristate )1);
  }
#line 638
  return (tmp___0);
  case_78: /* CIL Label */ 
  case_110: /* CIL Label */ 
  {
#line 640
  tmp___1 = sym_set_tristate_value(sym, (tristate )0);
  }
#line 640
  return (tmp___1);
  switch_break___0: /* CIL Label */ ;
  }
#line 642
  return ((_Bool)0);
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
  {
#line 647
  tmp___2 = sym_string_within_range(sym, newval);
  }
#line 647
  if (! tmp___2) {
#line 648
    return ((_Bool)0);
  }
#line 650
  if (! (sym->flags & 65536)) {
    {
#line 651
    sym->flags |= 65536;
#line 652
    sym_set_changed(sym);
    }
  }
  {
#line 655
  oldval = (char const   *)sym->def[0].val;
#line 656
  tmp___3 = strlen(newval);
#line 656
  size = (int )(tmp___3 + 1UL);
  }
#line 657
  if ((unsigned int )sym->type == 4U) {
#line 657
    if ((int const   )*(newval + 0) != 48) {
#line 657
      goto _L___0;
    } else
#line 657
    if ((int const   )*(newval + 1) != 120) {
#line 657
      if ((int const   )*(newval + 1) != 88) {
        _L___0: /* CIL Label */ 
        {
#line 658
        size += 2;
#line 659
        tmp___4 = malloc((size_t )size);
#line 659
        val = (char *)tmp___4;
#line 659
        sym->def[0].val = (void *)val;
#line 660
        tmp___5 = val;
#line 660
        val ++;
#line 660
        *tmp___5 = (char )'0';
#line 661
        tmp___6 = val;
#line 661
        val ++;
#line 661
        *tmp___6 = (char )'x';
        }
      } else {
#line 657
        goto _L;
      }
    } else {
#line 657
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 662
  if (! oldval) {
    {
#line 663
    tmp___7 = malloc((size_t )size);
#line 663
    val = (char *)tmp___7;
#line 663
    sym->def[0].val = (void *)val;
    }
  } else {
    {
#line 662
    tmp___8 = strcmp(oldval, newval);
    }
#line 662
    if (tmp___8) {
      {
#line 663
      tmp___7 = malloc((size_t )size);
#line 663
      val = (char *)tmp___7;
#line 663
      sym->def[0].val = (void *)val;
      }
    } else {
#line 665
      return ((_Bool)1);
    }
  }
  {
#line 667
  strcpy((char */* __restrict  */)val, (char const   */* __restrict  */)newval);
#line 668
  free((void *)oldval);
#line 669
  sym_clear_all_valid();
  }
#line 671
  return ((_Bool)1);
}
}
#line 681 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/symbol.c"
char const   *sym_get_string_default(struct symbol *sym ) 
{ 
  struct property *prop ;
  struct symbol *ds ;
  char const   *str ;
  tristate val ;
  tristate tmp___0 ;
  tristate tmp___1 ;
  _Bool tmp___2 ;

  {
  {
#line 688
  sym_calc_visibility(sym);
#line 689
  sym_calc_value(modules_sym);
#line 690
  val = symbol_no.curr.tri;
#line 691
  str = (char const   *)symbol_empty.curr.val;
#line 694
  prop = sym_get_default_prop(sym);
  }
#line 695
  if ((unsigned long )prop != (unsigned long )((void *)0)) {
    {
#line 698
    if ((unsigned int )sym->type == 2U) {
#line 698
      goto case_2;
    }
#line 698
    if ((unsigned int )sym->type == 1U) {
#line 698
      goto case_2;
    }
#line 702
    goto switch_default;
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
    {
#line 700
    tmp___1 = expr_calc_value(prop->expr);
    }
#line 700
    if ((unsigned int )tmp___1 < (unsigned int )prop->visible.tri) {
      {
#line 700
      tmp___0 = expr_calc_value(prop->expr);
#line 700
      val = tmp___0;
      }
    } else {
#line 700
      val = prop->visible.tri;
    }
#line 701
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 708
    ds = prop_get_symbol(prop);
    }
#line 709
    if ((unsigned long )ds != (unsigned long )((void *)0)) {
      {
#line 710
      sym_calc_value(ds);
#line 711
      str = (char const   *)ds->curr.val;
      }
    }
    switch_break: /* CIL Label */ ;
    }
  }
#line 717
  if ((unsigned int )val > (unsigned int )sym->rev_dep.tri) {
#line 717
    val = val;
  } else {
#line 717
    val = sym->rev_dep.tri;
  }
#line 720
  if ((unsigned int )val == 1U) {
    {
#line 721
    tmp___2 = sym_is_choice_value(sym);
    }
#line 721
    if (! tmp___2) {
#line 721
      if ((unsigned int )modules_sym->curr.tri == 0U) {
#line 722
        val = (tristate )2;
      }
    }
  }
#line 725
  if ((unsigned int )sym->type == 1U) {
#line 725
    if ((unsigned int )val == 1U) {
#line 726
      val = (tristate )2;
    }
  }
  {
#line 730
  if ((unsigned int )sym->type == 2U) {
#line 730
    goto case_2___0;
  }
#line 730
  if ((unsigned int )sym->type == 1U) {
#line 730
    goto case_2___0;
  }
#line 737
  if ((unsigned int )sym->type == 4U) {
#line 737
    goto case_4;
  }
#line 737
  if ((unsigned int )sym->type == 3U) {
#line 737
    goto case_4;
  }
#line 739
  if ((unsigned int )sym->type == 5U) {
#line 739
    goto case_5;
  }
#line 742
  if ((unsigned int )sym->type == 0U) {
#line 742
    goto case_0___0;
  }
#line 742
  if ((unsigned int )sym->type == 6U) {
#line 742
    goto case_0___0;
  }
#line 728
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
  case_1___0: /* CIL Label */ 
  {
#line 732
  if ((unsigned int )val == 0U) {
#line 732
    goto case_0;
  }
#line 733
  if ((unsigned int )val == 1U) {
#line 733
    goto case_1___1;
  }
#line 734
  if ((unsigned int )val == 2U) {
#line 734
    goto case_2___1;
  }
#line 731
  goto switch_break___1;
  case_0: /* CIL Label */ 
#line 732
  return ("n");
  case_1___1: /* CIL Label */ 
#line 733
  return ("m");
  case_2___1: /* CIL Label */ 
#line 734
  return ("y");
  switch_break___1: /* CIL Label */ ;
  }
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 738
  return (str);
  case_5: /* CIL Label */ 
#line 740
  return (str);
  case_0___0: /* CIL Label */ 
  case_6: /* CIL Label */ 
#line 743
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 745
  return ("");
}
}
#line 748 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/symbol.c"
char const   *sym_get_string_value(struct symbol *sym ) 
{ 
  tristate val ;
  char const   *tmp ;

  {
  {
#line 754
  if ((unsigned int )sym->type == 2U) {
#line 754
    goto case_2;
  }
#line 754
  if ((unsigned int )sym->type == 1U) {
#line 754
    goto case_2;
  }
#line 766
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 755
  val = sym_get_tristate_value(sym);
  }
  {
#line 757
  if ((unsigned int )val == 0U) {
#line 757
    goto case_0;
  }
#line 759
  if ((unsigned int )val == 1U) {
#line 759
    goto case_1___0;
  }
#line 762
  if ((unsigned int )val == 2U) {
#line 762
    goto case_2___0;
  }
#line 756
  goto switch_break___0;
  case_0: /* CIL Label */ 
#line 758
  return ("n");
  case_1___0: /* CIL Label */ 
  {
#line 760
  sym_calc_value(modules_sym);
  }
#line 761
  if ((unsigned int )modules_sym->curr.tri == 0U) {
#line 761
    tmp = "n";
  } else {
#line 761
    tmp = "m";
  }
#line 761
  return (tmp);
  case_2___0: /* CIL Label */ 
#line 763
  return ("y");
  switch_break___0: /* CIL Label */ ;
  }
#line 765
  goto switch_break;
  switch_default: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 769
  return ((char const   *)sym->curr.val);
}
}
#line 772 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/symbol.c"
_Bool sym_is_changable(struct symbol *sym ) 
{ 


  {
#line 774
  return ((_Bool )((unsigned int )sym->visible > (unsigned int )sym->rev_dep.tri));
}
}
#line 777 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/symbol.c"
static unsigned int strhash___0(char const   *s ) 
{ 
  unsigned int hash ;

  {
#line 780
  hash = 2166136261U;
  {
#line 781
  while (1) {
    while_continue: /* CIL Label */ ;
#line 781
    if (! *s) {
#line 781
      goto while_break;
    }
#line 782
    hash = (hash ^ (unsigned int )*s) * 16777619U;
#line 781
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 783
  return (hash);
}
}
#line 786 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/symbol.c"
struct symbol *sym_lookup(char const   *name , int flags ) 
{ 
  struct symbol *symbol ;
  char *new_name ;
  int hash ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;

  {
#line 792
  if (name) {
#line 793
    if (*(name + 0)) {
#line 793
      if (! *(name + 1)) {
        {
#line 795
        if ((int const   )*(name + 0) == 121) {
#line 795
          goto case_121;
        }
#line 796
        if ((int const   )*(name + 0) == 109) {
#line 796
          goto case_109;
        }
#line 797
        if ((int const   )*(name + 0) == 110) {
#line 797
          goto case_110;
        }
#line 794
        goto switch_break;
        case_121: /* CIL Label */ 
#line 795
        return (& symbol_yes);
        case_109: /* CIL Label */ 
#line 796
        return (& symbol_mod);
        case_110: /* CIL Label */ 
#line 797
        return (& symbol_no);
        switch_break: /* CIL Label */ ;
        }
      }
    }
    {
#line 800
    tmp = strhash___0(name);
#line 800
    hash = (int )(tmp % 9973U);
#line 802
    symbol = symbol_hash[hash];
    }
    {
#line 802
    while (1) {
      while_continue: /* CIL Label */ ;
#line 802
      if (! symbol) {
#line 802
        goto while_break;
      }
#line 803
      if (symbol->name) {
        {
#line 803
        tmp___0 = strcmp((char const   *)symbol->name, name);
        }
#line 803
        if (! tmp___0) {
#line 803
          if (flags) {
#line 803
            tmp___1 = symbol->flags & flags;
          } else {
#line 803
            tmp___1 = ! (symbol->flags & 17);
          }
#line 803
          if (tmp___1) {
#line 807
            return (symbol);
          }
        }
      }
#line 802
      symbol = symbol->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 809
    new_name = strdup(name);
    }
  } else {
#line 811
    new_name = (char *)((void *)0);
#line 812
    hash = 0;
  }
  {
#line 815
  tmp___2 = malloc(sizeof(*symbol));
#line 815
  symbol = (struct symbol *)tmp___2;
#line 816
  memset((void *)symbol, 0, sizeof(*symbol));
#line 817
  symbol->name = new_name;
#line 818
  symbol->type = (enum symbol_type )0;
#line 819
  symbol->flags |= flags;
#line 821
  symbol->next = symbol_hash[hash];
#line 822
  symbol_hash[hash] = symbol;
  }
#line 824
  return (symbol);
}
}
#line 827 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/symbol.c"
struct symbol *sym_find(char const   *name ) 
{ 
  struct symbol *symbol ;
  int hash ;
  unsigned int tmp ;
  int tmp___0 ;

  {
#line 829
  symbol = (struct symbol *)((void *)0);
#line 830
  hash = 0;
#line 832
  if (! name) {
#line 833
    return ((struct symbol *)((void *)0));
  }
#line 835
  if (*(name + 0)) {
#line 835
    if (! *(name + 1)) {
      {
#line 837
      if ((int const   )*(name + 0) == 121) {
#line 837
        goto case_121;
      }
#line 838
      if ((int const   )*(name + 0) == 109) {
#line 838
        goto case_109;
      }
#line 839
      if ((int const   )*(name + 0) == 110) {
#line 839
        goto case_110;
      }
#line 836
      goto switch_break;
      case_121: /* CIL Label */ 
#line 837
      return (& symbol_yes);
      case_109: /* CIL Label */ 
#line 838
      return (& symbol_mod);
      case_110: /* CIL Label */ 
#line 839
      return (& symbol_no);
      switch_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 842
  tmp = strhash___0(name);
#line 842
  hash = (int )(tmp % 9973U);
#line 844
  symbol = symbol_hash[hash];
  }
  {
#line 844
  while (1) {
    while_continue: /* CIL Label */ ;
#line 844
    if (! symbol) {
#line 844
      goto while_break;
    }
#line 845
    if (symbol->name) {
      {
#line 845
      tmp___0 = strcmp((char const   *)symbol->name, name);
      }
#line 845
      if (! tmp___0) {
#line 845
        if (! (symbol->flags & 1)) {
#line 848
          goto while_break;
        }
      }
    }
#line 844
    symbol = symbol->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 851
  return (symbol);
}
}
#line 859 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/symbol.c"
char const   *sym_expand_string_value(char const   *in ) 
{ 
  char const   *src ;
  char *res ;
  size_t reslen ;
  size_t tmp ;
  void *tmp___0 ;
  char *p ;
  char name[256] ;
  char const   *symval ;
  struct symbol *sym ;
  size_t newlen ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  unsigned short const   **tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  char *tmp___8 ;

  {
  {
#line 865
  tmp = strlen(in);
#line 865
  reslen = tmp + 1UL;
#line 866
  tmp___0 = malloc(reslen);
#line 866
  res = (char *)tmp___0;
#line 867
  *(res + 0) = (char )'\000';
  }
  {
#line 869
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 869
    tmp___8 = strchr(in, '$');
#line 869
    src = (char const   *)tmp___8;
    }
#line 869
    if (! src) {
#line 869
      goto while_break;
    }
    {
#line 871
    symval = "";
#line 875
    strncat((char */* __restrict  */)res, (char const   */* __restrict  */)in, (size_t )(src - in));
#line 876
    src ++;
#line 878
    p = name;
    }
    {
#line 879
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 879
      tmp___3 = __ctype_b_loc();
      }
#line 879
      if (! ((int const   )*(*tmp___3 + (int )*src) & 8)) {
#line 879
        if (! ((int const   )*src == 95)) {
#line 879
          goto while_break___0;
        }
      }
#line 880
      tmp___1 = p;
#line 880
      p ++;
#line 880
      tmp___2 = src;
#line 880
      src ++;
#line 880
      *tmp___1 = (char )*tmp___2;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 881
    *p = (char )'\000';
#line 883
    sym = sym_find((char const   *)(name));
    }
#line 884
    if ((unsigned long )sym != (unsigned long )((void *)0)) {
      {
#line 885
      sym_calc_value(sym);
#line 886
      symval = sym_get_string_value(sym);
      }
    }
    {
#line 889
    tmp___4 = strlen((char const   *)res);
#line 889
    tmp___5 = strlen(symval);
#line 889
    tmp___6 = strlen(src);
#line 889
    newlen = ((tmp___4 + tmp___5) + tmp___6) + 1UL;
    }
#line 890
    if (newlen > reslen) {
      {
#line 891
      reslen = newlen;
#line 892
      tmp___7 = realloc((void *)res, reslen);
#line 892
      res = (char *)tmp___7;
      }
    }
    {
#line 895
    strcat((char */* __restrict  */)res, (char const   */* __restrict  */)symval);
#line 896
    in = src;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 898
  strcat((char */* __restrict  */)res, (char const   */* __restrict  */)in);
  }
#line 900
  return ((char const   *)res);
}
}
#line 903 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/symbol.c"
char const   *sym_escape_string_value(char const   *in ) 
{ 
  char const   *p ;
  size_t reslen ;
  char *res ;
  size_t l ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char const   *tmp___2 ;

  {
  {
#line 910
  tmp = strlen(in);
#line 910
  tmp___0 = strlen("\"\"");
#line 910
  reslen = (tmp + tmp___0) + 1UL;
#line 912
  p = in;
  }
  {
#line 913
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 914
    l = strcspn(p, "\"\\");
#line 915
    p += l;
    }
#line 917
    if ((int const   )*(p + 0) == 0) {
#line 918
      goto while_break;
    }
#line 920
    reslen ++;
#line 921
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 924
  tmp___1 = malloc(reslen);
#line 924
  res = (char *)tmp___1;
#line 925
  *(res + 0) = (char )'\000';
#line 927
  strcat((char */* __restrict  */)res, (char const   */* __restrict  */)"\"");
#line 929
  p = in;
  }
  {
#line 930
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 931
    l = strcspn(p, "\"\\");
#line 932
    strncat((char */* __restrict  */)res, (char const   */* __restrict  */)p, l);
#line 933
    p += l;
    }
#line 935
    if ((int const   )*(p + 0) == 0) {
#line 936
      goto while_break___0;
    }
    {
#line 938
    strcat((char */* __restrict  */)res, (char const   */* __restrict  */)"\\");
#line 939
    tmp___2 = p;
#line 939
    p ++;
#line 939
    strncat((char */* __restrict  */)res, (char const   */* __restrict  */)tmp___2,
            (size_t )1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 942
  strcat((char */* __restrict  */)res, (char const   */* __restrict  */)"\"");
  }
#line 943
  return ((char const   *)res);
}
}
#line 946 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/symbol.c"
struct symbol **sym_re_search(char const   *pattern ) 
{ 
  struct symbol *sym ;
  struct symbol **sym_arr ;
  int i ;
  int cnt ;
  int size ;
  regex_t re ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 948
  sym_arr = (struct symbol **)((void *)0);
#line 952
  size = 0;
#line 952
  cnt = size;
#line 954
  tmp = strlen(pattern);
  }
#line 954
  if (tmp == 0UL) {
#line 955
    return ((struct symbol **)((void *)0));
  }
  {
#line 956
  tmp___0 = regcomp((regex_t */* __restrict  */)(& re), (char const   */* __restrict  */)pattern,
                    (1 | (((1 << 1) << 1) << 1)) | (1 << 1));
  }
#line 956
  if (tmp___0) {
#line 957
    return ((struct symbol **)((void *)0));
  }
#line 959
  i = 0;
  {
#line 959
  while (1) {
    while_continue: /* CIL Label */ ;
#line 959
    if (! (i < 9973)) {
#line 959
      goto while_break;
    }
#line 959
    sym = symbol_hash[i];
    {
#line 959
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 959
      if (! sym) {
#line 959
        goto while_break___0;
      }
#line 959
      if ((unsigned int )sym->type != 6U) {
#line 960
        if (sym->flags & 1) {
#line 961
          goto __Cont;
        } else
#line 960
        if (! sym->name) {
#line 961
          goto __Cont;
        }
        {
#line 962
        tmp___1 = regexec((regex_t const   */* __restrict  */)(& re), (char const   */* __restrict  */)sym->name,
                          (size_t )0, (regmatch_t */* __restrict  */)((void *)0),
                          0);
        }
#line 962
        if (tmp___1) {
#line 963
          goto __Cont;
        }
#line 964
        if (cnt + 1 >= size) {
          {
#line 965
          tmp___2 = (void *)sym_arr;
#line 966
          size += 16;
#line 967
          tmp___3 = realloc((void *)sym_arr, (unsigned long )size * sizeof(struct symbol *));
#line 967
          sym_arr = (struct symbol **)tmp___3;
          }
#line 968
          if (! sym_arr) {
            {
#line 969
            free(tmp___2);
            }
#line 970
            return ((struct symbol **)((void *)0));
          }
        }
        {
#line 973
        sym_calc_value(sym);
#line 974
        tmp___4 = cnt;
#line 974
        cnt ++;
#line 974
        *(sym_arr + tmp___4) = sym;
        }
      }
      __Cont: /* CIL Label */ 
#line 959
      sym = sym->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 959
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 976
  if (sym_arr) {
#line 977
    *(sym_arr + cnt) = (struct symbol *)((void *)0);
  }
  {
#line 978
  regfree(& re);
  }
#line 980
  return (sym_arr);
}
}
#line 989 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/symbol.c"
static struct dep_stack *check_top  ;
#line 996 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/symbol.c"
static void dep_stack_insert(struct dep_stack *stack , struct symbol *sym ) 
{ 


  {
  {
#line 998
  memset((void *)stack, 0, sizeof(*stack));
  }
#line 999
  if (check_top) {
#line 1000
    check_top->next = stack;
  }
#line 1001
  stack->prev = check_top;
#line 1002
  stack->sym = sym;
#line 1003
  check_top = stack;
#line 1004
  return;
}
}
#line 1006 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/symbol.c"
static void dep_stack_remove(void) 
{ 


  {
#line 1008
  check_top = check_top->prev;
#line 1009
  if (check_top) {
#line 1010
    check_top->next = (struct dep_stack *)((void *)0);
  }
#line 1011
  return;
}
}
#line 1018 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/symbol.c"
static void sym_check_print_recursive(struct symbol *last_sym ) 
{ 
  struct dep_stack *stack ;
  struct symbol *sym ;
  struct symbol *next_sym ;
  struct menu *menu ;
  struct property *prop ;
  struct dep_stack cv_stack ;
  struct property *tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  _Bool tmp___14 ;
  _Bool tmp___15 ;

  {
  {
#line 1022
  menu = (struct menu *)((void *)0);
#line 1026
  tmp___0 = sym_is_choice_value(last_sym);
  }
#line 1026
  if (tmp___0) {
    {
#line 1027
    dep_stack_insert(& cv_stack, last_sym);
#line 1028
    tmp = sym_get_choice_prop(last_sym);
#line 1028
    last_sym = prop_get_symbol(tmp);
    }
  }
#line 1031
  stack = check_top;
  {
#line 1031
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1031
    if (! ((unsigned long )stack != (unsigned long )((void *)0))) {
#line 1031
      goto while_break;
    }
#line 1032
    if ((unsigned long )stack->sym == (unsigned long )last_sym) {
#line 1033
      goto while_break;
    }
#line 1031
    stack = stack->prev;
  }
  while_break: /* CIL Label */ ;
  }
#line 1034
  if (! stack) {
    {
#line 1035
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unexpected recursive dependency error\n");
    }
#line 1036
    return;
  }
  {
#line 1039
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1039
    if (! stack) {
#line 1039
      goto while_break___0;
    }
#line 1040
    sym = stack->sym;
#line 1041
    if (stack->next) {
#line 1041
      next_sym = (stack->next)->sym;
    } else {
#line 1041
      next_sym = last_sym;
    }
#line 1042
    prop = stack->prop;
#line 1043
    if ((unsigned long )prop == (unsigned long )((void *)0)) {
#line 1044
      prop = (stack->sym)->prop;
    }
    {
#line 1047
    tmp___1 = sym_is_choice(sym);
    }
#line 1047
    if (tmp___1) {
#line 1047
      goto _L;
    } else {
      {
#line 1047
      tmp___2 = sym_is_choice_value(sym);
      }
#line 1047
      if (tmp___2) {
        _L: /* CIL Label */ 
#line 1048
        prop = sym->prop;
        {
#line 1048
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1048
          if (! prop) {
#line 1048
            goto while_break___1;
          }
#line 1049
          menu = prop->menu;
#line 1050
          if (prop->menu) {
#line 1051
            goto while_break___1;
          }
#line 1048
          prop = prop->next;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    }
#line 1054
    if ((unsigned long )stack->sym == (unsigned long )last_sym) {
      {
#line 1055
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d:error: recursive dependency detected!\n",
              (prop->file)->name, prop->lineno);
      }
    }
#line 1057
    if (stack->expr) {
#line 1058
      if (next_sym->name) {
#line 1058
        tmp___3 = (char const   *)next_sym->name;
      } else {
#line 1058
        tmp___3 = "<choice>";
      }
      {
#line 1058
      tmp___4 = prop_get_type_name(prop->type);
      }
#line 1058
      if (sym->name) {
#line 1058
        tmp___5 = (char const   *)sym->name;
      } else {
#line 1058
        tmp___5 = "<choice>";
      }
      {
#line 1058
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d:\tsymbol %s %s value contains %s\n",
              (prop->file)->name, prop->lineno, tmp___5, tmp___4, tmp___3);
      }
    } else
#line 1063
    if (stack->prop) {
#line 1064
      if (next_sym->name) {
#line 1064
        tmp___6 = (char const   *)next_sym->name;
      } else {
#line 1064
        tmp___6 = "<choice>";
      }
#line 1064
      if (sym->name) {
#line 1064
        tmp___7 = (char const   *)sym->name;
      } else {
#line 1064
        tmp___7 = "<choice>";
      }
      {
#line 1064
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d:\tsymbol %s depends on %s\n",
              (prop->file)->name, prop->lineno, tmp___7, tmp___6);
      }
    } else {
      {
#line 1068
      tmp___15 = sym_is_choice(sym);
      }
#line 1068
      if (tmp___15) {
#line 1069
        if (next_sym->name) {
#line 1069
          tmp___8 = (char const   *)next_sym->name;
        } else {
#line 1069
          tmp___8 = "<choice>";
        }
#line 1069
        if (sym->name) {
#line 1069
          tmp___9 = (char const   *)sym->name;
        } else {
#line 1069
          tmp___9 = "<choice>";
        }
        {
#line 1069
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d:\tchoice %s contains symbol %s\n",
                (menu->file)->name, menu->lineno, tmp___9, tmp___8);
        }
      } else {
        {
#line 1073
        tmp___14 = sym_is_choice_value(sym);
        }
#line 1073
        if (tmp___14) {
#line 1074
          if (next_sym->name) {
#line 1074
            tmp___10 = (char const   *)next_sym->name;
          } else {
#line 1074
            tmp___10 = "<choice>";
          }
#line 1074
          if (sym->name) {
#line 1074
            tmp___11 = (char const   *)sym->name;
          } else {
#line 1074
            tmp___11 = "<choice>";
          }
          {
#line 1074
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d:\tsymbol %s is part of choice %s\n",
                  (menu->file)->name, menu->lineno, tmp___11, tmp___10);
          }
        } else {
#line 1079
          if (next_sym->name) {
#line 1079
            tmp___12 = (char const   *)next_sym->name;
          } else {
#line 1079
            tmp___12 = "<choice>";
          }
#line 1079
          if (sym->name) {
#line 1079
            tmp___13 = (char const   *)sym->name;
          } else {
#line 1079
            tmp___13 = "<choice>";
          }
          {
#line 1079
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d:\tsymbol %s is selected by %s\n",
                  (prop->file)->name, prop->lineno, tmp___13, tmp___12);
          }
        }
      }
    }
#line 1039
    stack = stack->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1086
  if ((unsigned long )check_top == (unsigned long )(& cv_stack)) {
    {
#line 1087
    dep_stack_remove();
    }
  }
#line 1088
  return;
}
}
#line 1090 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/symbol.c"
static struct symbol *sym_check_expr_deps(struct expr *e ) 
{ 
  struct symbol *sym ;
  struct symbol *tmp ;
  struct symbol *tmp___0 ;
  struct symbol *tmp___1 ;
  struct symbol *tmp___2 ;

  {
#line 1094
  if (! e) {
#line 1095
    return ((struct symbol *)((void *)0));
  }
  {
#line 1098
  if ((unsigned int )e->type == 2U) {
#line 1098
    goto case_2;
  }
#line 1098
  if ((unsigned int )e->type == 1U) {
#line 1098
    goto case_2;
  }
#line 1103
  if ((unsigned int )e->type == 3U) {
#line 1103
    goto case_3;
  }
#line 1106
  if ((unsigned int )e->type == 5U) {
#line 1106
    goto case_5;
  }
#line 1106
  if ((unsigned int )e->type == 4U) {
#line 1106
    goto case_5;
  }
#line 1111
  if ((unsigned int )e->type == 7U) {
#line 1111
    goto case_7;
  }
#line 1113
  goto switch_default;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 1099
  sym = sym_check_expr_deps(e->left.expr);
  }
#line 1100
  if (sym) {
#line 1101
    return (sym);
  }
  {
#line 1102
  tmp = sym_check_expr_deps(e->right.expr);
  }
#line 1102
  return (tmp);
  case_3: /* CIL Label */ 
  {
#line 1104
  tmp___0 = sym_check_expr_deps(e->left.expr);
  }
#line 1104
  return (tmp___0);
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  {
#line 1107
  sym = sym_check_deps(e->left.sym);
  }
#line 1108
  if (sym) {
#line 1109
    return (sym);
  }
  {
#line 1110
  tmp___1 = sym_check_deps(e->right.sym);
  }
#line 1110
  return (tmp___1);
  case_7: /* CIL Label */ 
  {
#line 1112
  tmp___2 = sym_check_deps(e->left.sym);
  }
#line 1112
  return (tmp___2);
  switch_default: /* CIL Label */ 
#line 1114
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1116
  printf((char const   */* __restrict  */)"Oops! How to check %d?\n", (unsigned int )e->type);
  }
#line 1117
  return ((struct symbol *)((void *)0));
}
}
#line 1121 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/symbol.c"
static struct symbol *sym_check_sym_deps(struct symbol *sym ) 
{ 
  struct symbol *sym2 ;
  struct property *prop ;
  struct dep_stack stack ;
  _Bool tmp ;

  {
  {
#line 1127
  dep_stack_insert(& stack, sym);
#line 1129
  sym2 = sym_check_expr_deps(sym->rev_dep.expr);
  }
#line 1130
  if (sym2) {
#line 1131
    goto out;
  }
#line 1133
  prop = sym->prop;
  {
#line 1133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1133
    if (! prop) {
#line 1133
      goto while_break;
    }
#line 1134
    if ((unsigned int )prop->type == 5U) {
#line 1135
      goto __Cont;
    } else
#line 1134
    if ((unsigned int )prop->type == 6U) {
#line 1135
      goto __Cont;
    }
    {
#line 1136
    stack.prop = prop;
#line 1137
    sym2 = sym_check_expr_deps(prop->visible.expr);
    }
#line 1138
    if (sym2) {
#line 1139
      goto while_break;
    }
#line 1140
    if ((unsigned int )prop->type != 4U) {
#line 1141
      goto __Cont;
    } else {
      {
#line 1140
      tmp = sym_is_choice(sym);
      }
#line 1140
      if (tmp) {
#line 1141
        goto __Cont;
      }
    }
    {
#line 1142
    stack.expr = prop->expr;
#line 1143
    sym2 = sym_check_expr_deps(prop->expr);
    }
#line 1144
    if (sym2) {
#line 1145
      goto while_break;
    }
#line 1146
    stack.expr = (struct expr *)((void *)0);
    __Cont: /* CIL Label */ 
#line 1133
    prop = prop->next;
  }
  while_break: /* CIL Label */ ;
  }
  out: 
  {
#line 1150
  dep_stack_remove();
  }
#line 1152
  return (sym2);
}
}
#line 1155 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/symbol.c"
static struct symbol *sym_check_choice_deps(struct symbol *choice ) 
{ 
  struct symbol *sym ;
  struct symbol *sym2 ;
  struct property *prop ;
  struct expr *e ;
  struct dep_stack stack ;
  _Bool tmp ;
  struct property *tmp___0 ;
  struct symbol *tmp___1 ;

  {
  {
#line 1162
  dep_stack_insert(& stack, choice);
#line 1164
  prop = sym_get_choice_prop(choice);
#line 1165
  e = prop->expr;
  }
  {
#line 1165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1165
    if (e) {
#line 1165
      sym = e->right.sym;
#line 1165
      if (! sym) {
#line 1165
        goto while_break;
      }
    } else {
#line 1165
      goto while_break;
    }
#line 1166
    sym->flags |= 8200;
#line 1165
    e = e->left.expr;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1168
  choice->flags |= 8200;
#line 1169
  sym2 = sym_check_sym_deps(choice);
#line 1170
  choice->flags &= -9;
  }
#line 1171
  if (sym2) {
#line 1172
    goto out;
  }
#line 1174
  e = prop->expr;
  {
#line 1174
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1174
    if (e) {
#line 1174
      sym = e->right.sym;
#line 1174
      if (! sym) {
#line 1174
        goto while_break___0;
      }
    } else {
#line 1174
      goto while_break___0;
    }
    {
#line 1175
    sym2 = sym_check_sym_deps(sym);
    }
#line 1176
    if (sym2) {
#line 1177
      goto while_break___0;
    }
#line 1174
    e = e->left.expr;
  }
  while_break___0: /* CIL Label */ ;
  }
  out: 
#line 1180
  e = prop->expr;
  {
#line 1180
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1180
    if (e) {
#line 1180
      sym = e->right.sym;
#line 1180
      if (! sym) {
#line 1180
        goto while_break___1;
      }
    } else {
#line 1180
      goto while_break___1;
    }
#line 1181
    sym->flags &= -9;
#line 1180
    e = e->left.expr;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1183
  if (sym2) {
    {
#line 1183
    tmp = sym_is_choice_value(sym2);
    }
#line 1183
    if (tmp) {
      {
#line 1183
      tmp___0 = sym_get_choice_prop(sym2);
#line 1183
      tmp___1 = prop_get_symbol(tmp___0);
      }
#line 1183
      if ((unsigned long )tmp___1 == (unsigned long )choice) {
#line 1185
        sym2 = choice;
      }
    }
  }
  {
#line 1187
  dep_stack_remove();
  }
#line 1189
  return (sym2);
}
}
#line 1192 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/symbol.c"
struct symbol *sym_check_deps(struct symbol *sym ) 
{ 
  struct symbol *sym2 ;
  struct property *prop ;
  struct dep_stack stack ;
  struct symbol *tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;

  {
#line 1197
  if (sym->flags & 8) {
    {
#line 1198
    sym_check_print_recursive(sym);
    }
#line 1199
    return (sym);
  }
#line 1201
  if (sym->flags & 8192) {
#line 1202
    return ((struct symbol *)((void *)0));
  }
  {
#line 1204
  tmp___1 = sym_is_choice_value(sym);
  }
#line 1204
  if (tmp___1) {
    {
#line 1208
    dep_stack_insert(& stack, sym);
#line 1209
    prop = sym_get_choice_prop(sym);
#line 1210
    tmp = prop_get_symbol(prop);
#line 1210
    sym2 = sym_check_deps(tmp);
#line 1211
    dep_stack_remove();
    }
  } else {
    {
#line 1212
    tmp___0 = sym_is_choice(sym);
    }
#line 1212
    if (tmp___0) {
      {
#line 1213
      sym2 = sym_check_choice_deps(sym);
      }
    } else {
      {
#line 1215
      sym->flags |= 8200;
#line 1216
      sym2 = sym_check_sym_deps(sym);
#line 1217
      sym->flags &= -9;
      }
    }
  }
#line 1220
  if (sym2) {
#line 1220
    if ((unsigned long )sym2 == (unsigned long )sym) {
#line 1221
      sym2 = (struct symbol *)((void *)0);
    }
  }
#line 1223
  return (sym2);
}
}
#line 1226 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/symbol.c"
struct property *prop_alloc(enum prop_type type , struct symbol *sym ) 
{ 
  struct property *prop ;
  struct property **propp ;
  void *tmp ;

  {
  {
#line 1231
  tmp = malloc(sizeof(*prop));
#line 1231
  prop = (struct property *)tmp;
#line 1232
  memset((void *)prop, 0, sizeof(*prop));
#line 1233
  prop->type = type;
#line 1234
  prop->sym = sym;
#line 1235
  prop->file = current_file;
#line 1236
  prop->lineno = zconf_lineno();
  }
#line 1239
  if (sym) {
#line 1240
    propp = & sym->prop;
    {
#line 1240
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1240
      if (! *propp) {
#line 1240
        goto while_break;
      }
#line 1240
      propp = & (*propp)->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 1242
    *propp = prop;
  }
#line 1245
  return (prop);
}
}
#line 1248 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/symbol.c"
struct symbol *prop_get_symbol(struct property *prop ) 
{ 


  {
#line 1250
  if (prop->expr) {
#line 1250
    if ((unsigned int )(prop->expr)->type == 7U) {
#line 1252
      return ((prop->expr)->left.sym);
    } else
#line 1250
    if ((unsigned int )(prop->expr)->type == 6U) {
#line 1252
      return ((prop->expr)->left.sym);
    }
  }
#line 1253
  return ((struct symbol *)((void *)0));
}
}
#line 1256 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/symbol.c"
char const   *prop_get_type_name(enum prop_type type ) 
{ 


  {
  {
#line 1259
  if ((unsigned int )type == 1U) {
#line 1259
    goto case_1;
  }
#line 1261
  if ((unsigned int )type == 8U) {
#line 1261
    goto case_8;
  }
#line 1263
  if ((unsigned int )type == 2U) {
#line 1263
    goto case_2;
  }
#line 1265
  if ((unsigned int )type == 3U) {
#line 1265
    goto case_3;
  }
#line 1267
  if ((unsigned int )type == 4U) {
#line 1267
    goto case_4;
  }
#line 1269
  if ((unsigned int )type == 5U) {
#line 1269
    goto case_5;
  }
#line 1271
  if ((unsigned int )type == 6U) {
#line 1271
    goto case_6;
  }
#line 1273
  if ((unsigned int )type == 7U) {
#line 1273
    goto case_7;
  }
#line 1275
  if ((unsigned int )type == 9U) {
#line 1275
    goto case_9;
  }
#line 1277
  if ((unsigned int )type == 0U) {
#line 1277
    goto case_0;
  }
#line 1258
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1260
  return ("prompt");
  case_8: /* CIL Label */ 
#line 1262
  return ("env");
  case_2: /* CIL Label */ 
#line 1264
  return ("comment");
  case_3: /* CIL Label */ 
#line 1266
  return ("menu");
  case_4: /* CIL Label */ 
#line 1268
  return ("default");
  case_5: /* CIL Label */ 
#line 1270
  return ("choice");
  case_6: /* CIL Label */ 
#line 1272
  return ("select");
  case_7: /* CIL Label */ 
#line 1274
  return ("range");
  case_9: /* CIL Label */ 
#line 1276
  return ("symbol");
  case_0: /* CIL Label */ 
#line 1278
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1280
  return ("unknown");
}
}
#line 1283 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/symbol.c"
static void prop_add_env(char const   *env ) 
{ 
  struct symbol *sym ;
  struct symbol *sym2 ;
  struct property *prop ;
  char *p ;
  int tmp ;
  struct symbol *tmp___0 ;

  {
#line 1289
  sym = current_entry->sym;
#line 1290
  sym->flags |= 4096;
#line 1291
  prop = sym->prop;
  {
#line 1291
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1291
    if (! prop) {
#line 1291
      goto while_break;
    }
#line 1291
    if ((unsigned int )prop->type == 8U) {
      {
#line 1292
      sym2 = prop_get_symbol(prop);
#line 1293
      tmp = strcmp((char const   *)sym2->name, env);
      }
#line 1293
      if (tmp) {
        {
#line 1294
        menu_warn(current_entry, "redefining environment symbol from %s", sym2->name);
        }
      }
#line 1296
      return;
    }
#line 1291
    prop = prop->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1299
  prop = prop_alloc((enum prop_type )8, sym);
#line 1300
  tmp___0 = sym_lookup(env, 1);
#line 1300
  prop->expr = expr_alloc_symbol(tmp___0);
#line 1302
  sym_env_list = expr_alloc_one((enum expr_type )6, sym_env_list);
#line 1303
  sym_env_list->right.sym = sym;
#line 1305
  p = getenv(env);
  }
#line 1306
  if (p) {
    {
#line 1307
    sym_add_default(sym, (char const   *)p);
    }
  } else {
    {
#line 1309
    menu_warn(current_entry, "environment variable %s undefined", env);
    }
  }
#line 1310
  return;
}
}
#line 13 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/menu.c"
static char const   nohelp_text[44]  = 
#line 13 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/menu.c"
  {      (char const   )'T',      (char const   )'h',      (char const   )'e',      (char const   )'r', 
        (char const   )'e',      (char const   )' ',      (char const   )'i',      (char const   )'s', 
        (char const   )' ',      (char const   )'n',      (char const   )'o',      (char const   )' ', 
        (char const   )'h',      (char const   )'e',      (char const   )'l',      (char const   )'p', 
        (char const   )' ',      (char const   )'a',      (char const   )'v',      (char const   )'a', 
        (char const   )'i',      (char const   )'l',      (char const   )'a',      (char const   )'b', 
        (char const   )'l',      (char const   )'e',      (char const   )' ',      (char const   )'f', 
        (char const   )'o',      (char const   )'r',      (char const   )' ',      (char const   )'t', 
        (char const   )'h',      (char const   )'i',      (char const   )'s',      (char const   )' ', 
        (char const   )'o',      (char const   )'p',      (char const   )'t',      (char const   )'i', 
        (char const   )'o',      (char const   )'n',      (char const   )'.',      (char const   )'\000'};
#line 16 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/menu.c"
static struct menu **last_entry_ptr  ;
#line 21 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/menu.c"
void menu_warn(struct menu *menu , char const   *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 24
  __builtin_va_start(ap, fmt);
#line 25
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d:warning: ",
          (menu->file)->name, menu->lineno);
#line 26
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
           ap);
#line 27
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 28
  __builtin_va_end(ap);
  }
#line 29
  return;
}
}
#line 31 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/menu.c"
static void prop_warn(struct property *prop , char const   *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 34
  __builtin_va_start(ap, fmt);
#line 35
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%d:warning: ",
          (prop->file)->name, prop->lineno);
#line 36
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
           ap);
#line 37
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 38
  __builtin_va_end(ap);
  }
#line 39
  return;
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/menu.c"
void _menu_init(void) 
{ 


  {
#line 43
  current_menu = & rootmenu;
#line 43
  current_entry = current_menu;
#line 44
  last_entry_ptr = & rootmenu.list;
#line 45
  return;
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/menu.c"
void menu_add_entry(struct symbol *sym ) 
{ 
  struct menu *menu ;
  void *tmp ;

  {
  {
#line 51
  tmp = malloc(sizeof(*menu));
#line 51
  menu = (struct menu *)tmp;
#line 52
  memset((void *)menu, 0, sizeof(*menu));
#line 53
  menu->sym = sym;
#line 54
  menu->parent = current_menu;
#line 55
  menu->file = current_file;
#line 56
  menu->lineno = zconf_lineno();
#line 58
  *last_entry_ptr = menu;
#line 59
  last_entry_ptr = & menu->next;
#line 60
  current_entry = menu;
  }
#line 61
  if (sym) {
    {
#line 62
    menu_add_symbol((enum prop_type )9, sym, (struct expr *)((void *)0));
    }
  }
#line 63
  return;
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/menu.c"
void menu_end_entry(void) 
{ 


  {
#line 67
  return;
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/menu.c"
struct menu *menu_add_menu(void) 
{ 


  {
  {
#line 71
  menu_end_entry();
#line 72
  last_entry_ptr = & current_entry->list;
#line 73
  current_menu = current_entry;
  }
#line 73
  return (current_menu);
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/menu.c"
void menu_end_menu(void) 
{ 


  {
#line 78
  last_entry_ptr = & current_menu->next;
#line 79
  current_menu = current_menu->parent;
#line 80
  return;
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/menu.c"
static struct expr *menu_check_dep(struct expr *e ) 
{ 
  struct expr *tmp ;
  struct expr *tmp___0 ;

  {
#line 84
  if (! e) {
#line 85
    return (e);
  }
  {
#line 88
  if ((unsigned int )e->type == 3U) {
#line 88
    goto case_3;
  }
#line 92
  if ((unsigned int )e->type == 2U) {
#line 92
    goto case_2;
  }
#line 92
  if ((unsigned int )e->type == 1U) {
#line 92
    goto case_2;
  }
#line 96
  if ((unsigned int )e->type == 7U) {
#line 96
    goto case_7;
  }
#line 101
  goto switch_default;
  case_3: /* CIL Label */ 
  {
#line 89
  e->left.expr = menu_check_dep(e->left.expr);
  }
#line 90
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 93
  e->left.expr = menu_check_dep(e->left.expr);
#line 94
  e->right.expr = menu_check_dep(e->right.expr);
  }
#line 95
  goto switch_break;
  case_7: /* CIL Label */ 
#line 98
  if ((unsigned long )e->left.sym == (unsigned long )(& symbol_mod)) {
    {
#line 99
    tmp = expr_alloc_symbol(modules_sym);
#line 99
    tmp___0 = expr_alloc_and(e, tmp);
    }
#line 99
    return (tmp___0);
  }
#line 100
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 102
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 104
  return (e);
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/menu.c"
void menu_add_dep(struct expr *dep ) 
{ 
  struct expr *tmp ;

  {
  {
#line 109
  tmp = menu_check_dep(dep);
#line 109
  current_entry->dep = expr_alloc_and(current_entry->dep, tmp);
  }
#line 110
  return;
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/menu.c"
void menu_set_type(int type ) 
{ 
  struct symbol *sym ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 114
  sym = current_entry->sym;
#line 116
  if ((unsigned int )sym->type == (unsigned int )type) {
#line 117
    return;
  }
#line 118
  if ((unsigned int )sym->type == 0U) {
#line 119
    sym->type = (enum symbol_type )type;
#line 120
    return;
  }
  {
#line 122
  tmp = sym_type_name((enum symbol_type )type);
#line 122
  tmp___0 = sym_type_name(sym->type);
  }
#line 122
  if (sym->name) {
#line 122
    tmp___1 = (char const   *)sym->name;
  } else {
#line 122
    tmp___1 = "<choice>";
  }
  {
#line 122
  menu_warn(current_entry, "type of \'%s\' redefined from \'%s\' to \'%s\'", tmp___1,
            tmp___0, tmp);
  }
#line 125
  return;
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/menu.c"
struct property *menu_add_prop(enum prop_type type , char *prompt , struct expr *expr ,
                               struct expr *dep ) 
{ 
  struct property *prop ;
  struct property *tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  struct menu *menu ;

  {
  {
#line 129
  tmp = prop_alloc(type, current_entry->sym);
#line 129
  prop = tmp;
#line 131
  prop->menu = current_entry;
#line 132
  prop->expr = expr;
#line 133
  prop->visible.expr = menu_check_dep(dep);
  }
#line 135
  if (prompt) {
    {
#line 136
    tmp___1 = __ctype_b_loc();
    }
#line 136
    if ((int const   )*(*tmp___1 + (int )*prompt) & 8192) {
      {
#line 137
      prop_warn(prop, "leading whitespace ignored");
      }
      {
#line 138
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 138
        tmp___0 = __ctype_b_loc();
        }
#line 138
        if (! ((int const   )*(*tmp___0 + (int )*prompt) & 8192)) {
#line 138
          goto while_break;
        }
#line 139
        prompt ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 141
    if (current_entry->prompt) {
#line 141
      if ((unsigned long )current_entry != (unsigned long )(& rootmenu)) {
        {
#line 142
        prop_warn(prop, "prompt redefined");
        }
      }
    }
#line 145
    if ((unsigned int )type == 1U) {
#line 146
      menu = current_entry;
      {
#line 148
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 148
        menu = menu->parent;
#line 148
        if (! ((unsigned long )menu != (unsigned long )((void *)0))) {
#line 148
          goto while_break___0;
        }
#line 149
        if (! menu->visibility) {
#line 150
          goto while_continue___0;
        }
        {
#line 151
        prop->visible.expr = expr_alloc_and(prop->visible.expr, menu->visibility);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 157
    current_entry->prompt = prop;
  }
#line 159
  prop->text = (char const   *)prompt;
#line 161
  return (prop);
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/menu.c"
struct property *menu_add_prompt(enum prop_type type , char *prompt , struct expr *dep ) 
{ 
  struct property *tmp ;

  {
  {
#line 166
  tmp = menu_add_prop(type, prompt, (struct expr *)((void *)0), dep);
  }
#line 166
  return (tmp);
}
}
#line 169 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/menu.c"
void menu_add_visibility(struct expr *expr ) 
{ 


  {
  {
#line 171
  current_entry->visibility = expr_alloc_and(current_entry->visibility, expr);
  }
#line 173
  return;
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/menu.c"
void menu_add_expr(enum prop_type type , struct expr *expr , struct expr *dep ) 
{ 


  {
  {
#line 177
  menu_add_prop(type, (char *)((void *)0), expr, dep);
  }
#line 178
  return;
}
}
#line 180 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/menu.c"
void menu_add_symbol(enum prop_type type , struct symbol *sym , struct expr *dep ) 
{ 
  struct expr *tmp ;

  {
  {
#line 182
  tmp = expr_alloc_symbol(sym);
#line 182
  menu_add_prop(type, (char *)((void *)0), tmp, dep);
  }
#line 183
  return;
}
}
#line 185 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/menu.c"
void menu_add_option(int token , char *arg ) 
{ 
  struct property *prop ;

  {
  {
#line 190
  if (token == 1) {
#line 190
    goto case_1;
  }
#line 194
  if (token == 2) {
#line 194
    goto case_2;
  }
#line 200
  if (token == 3) {
#line 200
    goto case_3;
  }
#line 189
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 191
  prop = prop_alloc((enum prop_type )4, modules_sym);
#line 192
  prop->expr = expr_alloc_symbol(current_entry->sym);
  }
#line 193
  goto switch_break;
  case_2: /* CIL Label */ 
#line 195
  if (! sym_defconfig_list) {
#line 196
    sym_defconfig_list = current_entry->sym;
  } else
#line 197
  if ((unsigned long )sym_defconfig_list != (unsigned long )current_entry->sym) {
    {
#line 198
    zconf_error("trying to redefine defconfig symbol");
    }
  }
#line 199
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 201
  prop_add_env((char const   *)arg);
  }
#line 202
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 204
  return;
}
}
#line 206 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/menu.c"
static int menu_validate_number(struct symbol *sym , struct symbol *sym2 ) 
{ 
  _Bool tmp ;
  int tmp___0 ;

  {
#line 208
  if ((unsigned int )sym2->type == 3U) {
#line 208
    tmp___0 = 1;
  } else
#line 208
  if ((unsigned int )sym2->type == 4U) {
#line 208
    tmp___0 = 1;
  } else
#line 208
  if ((unsigned int )sym2->type == 0U) {
    {
#line 208
    tmp = sym_string_valid(sym, (char const   *)sym2->name);
    }
#line 208
    if (tmp) {
#line 208
      tmp___0 = 1;
    } else {
#line 208
      tmp___0 = 0;
    }
  } else {
#line 208
    tmp___0 = 0;
  }
#line 208
  return (tmp___0);
}
}
#line 212 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/menu.c"
static void sym_check_prop(struct symbol *sym ) 
{ 
  struct property *prop ;
  struct symbol *sym2 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 216
  prop = sym->prop;
  {
#line 216
  while (1) {
    while_continue: /* CIL Label */ ;
#line 216
    if (! prop) {
#line 216
      goto while_break;
    }
    {
#line 218
    if ((unsigned int )prop->type == 4U) {
#line 218
      goto case_4;
    }
#line 234
    if ((unsigned int )prop->type == 6U) {
#line 234
      goto case_6;
    }
#line 248
    if ((unsigned int )prop->type == 7U) {
#line 248
      goto case_7;
    }
#line 256
    goto switch_default;
    case_4: /* CIL Label */ 
#line 219
    if ((unsigned int )sym->type == 5U) {
#line 219
      goto _L;
    } else
#line 219
    if ((unsigned int )sym->type == 3U) {
#line 219
      goto _L;
    } else
#line 219
    if ((unsigned int )sym->type == 4U) {
      _L: /* CIL Label */ 
#line 219
      if ((unsigned int )(prop->expr)->type != 7U) {
        {
#line 221
        prop_warn(prop, "default for config symbol \'%s\' must be a single symbol",
                  sym->name);
        }
      }
    }
#line 224
    if ((unsigned int )(prop->expr)->type != 7U) {
#line 225
      goto switch_break;
    }
    {
#line 226
    sym2 = prop_get_symbol(prop);
    }
#line 227
    if ((unsigned int )sym->type == 4U) {
#line 227
      goto _L___0;
    } else
#line 227
    if ((unsigned int )sym->type == 3U) {
      _L___0: /* CIL Label */ 
      {
#line 228
      tmp = menu_validate_number(sym, sym2);
      }
#line 228
      if (! tmp) {
        {
#line 229
        prop_warn(prop, "\'%s\': number is invalid", sym->name);
        }
      }
    }
#line 233
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 235
    sym2 = prop_get_symbol(prop);
    }
#line 236
    if ((unsigned int )sym->type != 1U) {
#line 236
      if ((unsigned int )sym->type != 2U) {
        {
#line 237
        prop_warn(prop, "config symbol \'%s\' uses select, but is not boolean or tristate",
                  sym->name);
        }
      } else {
#line 236
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 240
    if ((unsigned int )sym2->type != 0U) {
#line 240
      if ((unsigned int )sym2->type != 1U) {
#line 240
        if ((unsigned int )sym2->type != 2U) {
          {
#line 243
          prop_warn(prop, "\'%s\' has wrong type. \'select\' only accept arguments of boolean and tristate type",
                    sym2->name);
          }
        }
      }
    }
#line 247
    goto switch_break;
    case_7: /* CIL Label */ 
#line 249
    if ((unsigned int )sym->type != 3U) {
#line 249
      if ((unsigned int )sym->type != 4U) {
        {
#line 250
        prop_warn(prop, "range is only allowed for int or hex symbols");
        }
      }
    }
    {
#line 252
    tmp___0 = menu_validate_number(sym, (prop->expr)->left.sym);
    }
#line 252
    if (tmp___0) {
      {
#line 252
      tmp___1 = menu_validate_number(sym, (prop->expr)->right.sym);
      }
#line 252
      if (! tmp___1) {
        {
#line 254
        prop_warn(prop, "range is invalid");
        }
      }
    } else {
      {
#line 254
      prop_warn(prop, "range is invalid");
      }
    }
#line 255
    goto switch_break;
    switch_default: /* CIL Label */ ;
    switch_break: /* CIL Label */ ;
    }
#line 216
    prop = prop->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 260
  return;
}
}
#line 262 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/menu.c"
void menu_finalize(struct menu *parent ) 
{ 
  struct menu *menu ;
  struct menu *last_menu ;
  struct symbol *sym ;
  struct property *prop ;
  struct expr *parentdep ;
  struct expr *basedep ;
  struct expr *dep ;
  struct expr *dep2 ;
  struct expr **ep ;
  _Bool tmp ;
  struct expr *tmp___0 ;
  struct expr *tmp___1 ;
  struct symbol *es ;
  struct symbol *tmp___2 ;
  struct expr *tmp___3 ;
  struct expr *tmp___4 ;
  struct expr *tmp___5 ;
  struct expr *tmp___6 ;
  int tmp___7 ;
  _Bool tmp___8 ;
  struct expr *tmp___9 ;
  int tmp___10 ;
  struct expr *tmp___11 ;
  _Bool tmp___12 ;
  _Bool tmp___13 ;
  _Bool tmp___14 ;
  struct expr *tmp___15 ;
  struct expr *tmp___16 ;
  _Bool tmp___17 ;

  {
#line 269
  sym = parent->sym;
#line 270
  if (parent->list) {
#line 271
    if (sym) {
      {
#line 271
      tmp = sym_is_choice(sym);
      }
#line 271
      if (tmp) {
#line 272
        if ((unsigned int )sym->type == 0U) {
#line 274
          current_entry = parent;
#line 275
          menu = parent->list;
          {
#line 275
          while (1) {
            while_continue: /* CIL Label */ ;
#line 275
            if (! menu) {
#line 275
              goto while_break;
            }
#line 276
            if (menu->sym) {
#line 276
              if ((unsigned int )(menu->sym)->type != 0U) {
                {
#line 277
                menu_set_type((int )(menu->sym)->type);
                }
#line 278
                goto while_break;
              }
            }
#line 275
            menu = menu->next;
          }
          while_break: /* CIL Label */ ;
          }
        }
#line 283
        menu = parent->list;
        {
#line 283
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 283
          if (! menu) {
#line 283
            goto while_break___0;
          }
#line 284
          current_entry = menu;
#line 285
          if (menu->sym) {
#line 285
            if ((unsigned int )(menu->sym)->type == 0U) {
              {
#line 286
              menu_set_type((int )sym->type);
              }
            }
          }
#line 283
          menu = menu->next;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 288
        parentdep = expr_alloc_symbol(sym);
        }
      } else {
#line 271
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 289
    if (parent->prompt) {
#line 290
      parentdep = (parent->prompt)->visible.expr;
    } else {
#line 292
      parentdep = parent->dep;
    }
#line 294
    menu = parent->list;
    {
#line 294
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 294
      if (! menu) {
#line 294
        goto while_break___1;
      }
      {
#line 295
      basedep = expr_transform(menu->dep);
#line 296
      tmp___0 = expr_copy((struct expr  const  *)parentdep);
#line 296
      basedep = expr_alloc_and(tmp___0, basedep);
#line 297
      basedep = expr_eliminate_dups(basedep);
#line 298
      menu->dep = basedep;
      }
#line 299
      if (menu->sym) {
#line 300
        prop = (menu->sym)->prop;
      } else {
#line 302
        prop = menu->prompt;
      }
      {
#line 303
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 303
        if (! prop) {
#line 303
          goto while_break___2;
        }
#line 304
        if ((unsigned long )prop->menu != (unsigned long )menu) {
#line 305
          goto __Cont;
        }
        {
#line 306
        dep = expr_transform(prop->visible.expr);
#line 307
        tmp___1 = expr_copy((struct expr  const  *)basedep);
#line 307
        dep = expr_alloc_and(tmp___1, dep);
#line 308
        dep = expr_eliminate_dups(dep);
        }
#line 309
        if (menu->sym) {
#line 309
          if ((unsigned int )(menu->sym)->type != 2U) {
            {
#line 310
            dep = expr_trans_bool(dep);
            }
          }
        }
#line 311
        prop->visible.expr = dep;
#line 312
        if ((unsigned int )prop->type == 6U) {
          {
#line 313
          tmp___2 = prop_get_symbol(prop);
#line 313
          es = tmp___2;
#line 314
          tmp___3 = expr_copy((struct expr  const  *)dep);
#line 314
          tmp___4 = expr_alloc_symbol(menu->sym);
#line 314
          tmp___5 = expr_alloc_and(tmp___4, tmp___3);
#line 314
          es->rev_dep.expr = expr_alloc_or(es->rev_dep.expr, tmp___5);
          }
        }
        __Cont: /* CIL Label */ 
#line 303
        prop = prop->next;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 294
      menu = menu->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 319
    menu = parent->list;
    {
#line 319
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 319
      if (! menu) {
#line 319
        goto while_break___3;
      }
      {
#line 320
      menu_finalize(menu);
#line 319
      menu = menu->next;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  } else
#line 321
  if (sym) {
#line 322
    if (parent->prompt) {
#line 322
      basedep = (parent->prompt)->visible.expr;
    } else {
#line 322
      basedep = (struct expr *)((void *)0);
    }
    {
#line 323
    basedep = expr_trans_compare(basedep, (enum expr_type )5, & symbol_no);
#line 324
    tmp___6 = expr_transform(basedep);
#line 324
    basedep = expr_eliminate_dups(tmp___6);
#line 325
    last_menu = (struct menu *)((void *)0);
#line 326
    menu = parent->next;
    }
    {
#line 326
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 326
      if (! menu) {
#line 326
        goto while_break___4;
      }
#line 327
      if (menu->prompt) {
#line 327
        dep = (menu->prompt)->visible.expr;
      } else {
#line 327
        dep = menu->dep;
      }
      {
#line 328
      tmp___7 = expr_contains_symbol(dep, sym);
      }
#line 328
      if (! tmp___7) {
#line 329
        goto while_break___4;
      }
      {
#line 330
      tmp___8 = expr_depends_symbol(dep, sym);
      }
#line 330
      if (tmp___8) {
#line 331
        goto next;
      }
      {
#line 332
      dep = expr_trans_compare(dep, (enum expr_type )5, & symbol_no);
#line 333
      tmp___9 = expr_transform(dep);
#line 333
      dep = expr_eliminate_dups(tmp___9);
#line 334
      dep2 = expr_copy((struct expr  const  *)basedep);
#line 335
      expr_eliminate_eq(& dep, & dep2);
#line 336
      expr_free(dep);
#line 337
      tmp___10 = expr_is_yes(dep2);
      }
#line 337
      if (! tmp___10) {
        {
#line 338
        expr_free(dep2);
        }
#line 339
        goto while_break___4;
      }
      {
#line 341
      expr_free(dep2);
      }
      next: 
      {
#line 343
      menu_finalize(menu);
#line 344
      menu->parent = parent;
#line 345
      last_menu = menu;
#line 326
      menu = menu->next;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 347
    if (last_menu) {
#line 348
      parent->list = parent->next;
#line 349
      parent->next = last_menu->next;
#line 350
      last_menu->next = (struct menu *)((void *)0);
    }
    {
#line 353
    sym->dir_dep.expr = expr_alloc_or(sym->dir_dep.expr, parent->dep);
    }
  }
#line 355
  menu = parent->list;
  {
#line 355
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 355
    if (! menu) {
#line 355
      goto while_break___5;
    }
#line 356
    if (sym) {
      {
#line 356
      tmp___12 = sym_is_choice(sym);
      }
#line 356
      if (tmp___12) {
#line 356
        if (menu->sym) {
          {
#line 356
          tmp___13 = sym_is_choice_value(menu->sym);
          }
#line 356
          if (! tmp___13) {
#line 358
            current_entry = menu;
#line 359
            (menu->sym)->flags |= 32;
#line 360
            if (! menu->prompt) {
              {
#line 361
              menu_warn(menu, "choice value must have a prompt");
              }
            }
#line 362
            prop = (menu->sym)->prop;
            {
#line 362
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 362
              if (! prop) {
#line 362
                goto while_break___6;
              }
#line 363
              if ((unsigned int )prop->type == 4U) {
                {
#line 364
                prop_warn(prop, "defaults for choice values not supported");
                }
              }
#line 366
              if ((unsigned long )prop->menu == (unsigned long )menu) {
#line 367
                goto __Cont___0;
              }
#line 368
              if ((unsigned int )prop->type == 1U) {
#line 368
                if ((unsigned long )((prop->menu)->parent)->sym != (unsigned long )sym) {
                  {
#line 370
                  prop_warn(prop, "choice value used outside its choice group");
                  }
                }
              }
              __Cont___0: /* CIL Label */ 
#line 362
              prop = prop->next;
            }
            while_break___6: /* CIL Label */ ;
            }
#line 378
            if ((unsigned int )sym->type == 2U) {
#line 378
              if ((unsigned int )(menu->sym)->type != 2U) {
                {
#line 379
                basedep = expr_alloc_comp((enum expr_type )4, sym, & symbol_yes);
#line 380
                menu->dep = expr_alloc_and(basedep, menu->dep);
#line 381
                prop = (menu->sym)->prop;
                }
                {
#line 381
                while (1) {
                  while_continue___7: /* CIL Label */ ;
#line 381
                  if (! prop) {
#line 381
                    goto while_break___7;
                  }
#line 382
                  if ((unsigned long )prop->menu != (unsigned long )menu) {
#line 383
                    goto __Cont___1;
                  }
                  {
#line 384
                  tmp___11 = expr_copy((struct expr  const  *)basedep);
#line 384
                  prop->visible.expr = expr_alloc_and(tmp___11, prop->visible.expr);
                  }
                  __Cont___1: /* CIL Label */ 
#line 381
                  prop = prop->next;
                }
                while_break___7: /* CIL Label */ ;
                }
              }
            }
            {
#line 388
            menu_add_symbol((enum prop_type )5, sym, (struct expr *)((void *)0));
#line 389
            prop = sym_get_choice_prop(sym);
#line 390
            ep = & prop->expr;
            }
            {
#line 390
            while (1) {
              while_continue___8: /* CIL Label */ ;
#line 390
              if (! *ep) {
#line 390
                goto while_break___8;
              }
#line 390
              ep = & (*ep)->left.expr;
            }
            while_break___8: /* CIL Label */ ;
            }
            {
#line 392
            *ep = expr_alloc_one((enum expr_type )6, (struct expr *)((void *)0));
#line 393
            (*ep)->right.sym = menu->sym;
            }
          }
        }
      }
    }
#line 395
    if (menu->list) {
#line 395
      if (! menu->prompt) {
#line 395
        goto _L___0;
      } else
#line 395
      if (! (menu->prompt)->text) {
        _L___0: /* CIL Label */ 
#line 396
        last_menu = menu->list;
        {
#line 396
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 397
          last_menu->parent = parent;
#line 398
          if (! last_menu->next) {
#line 399
            goto while_break___9;
          }
#line 396
          last_menu = last_menu->next;
        }
        while_break___9: /* CIL Label */ ;
        }
#line 401
        last_menu->next = menu->next;
#line 402
        menu->next = menu->list;
#line 403
        menu->list = (struct menu *)((void *)0);
      }
    }
#line 355
    menu = menu->next;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 407
  if (sym) {
#line 407
    if (! (sym->flags & 32768)) {
#line 408
      if ((unsigned int )sym->type == 0U) {
        {
#line 409
        menu_warn(parent, "config symbol defined without type");
        }
      }
      {
#line 411
      tmp___14 = sym_is_choice(sym);
      }
#line 411
      if (tmp___14) {
#line 411
        if (! parent->prompt) {
          {
#line 412
          menu_warn(parent, "choice must have a prompt");
          }
        }
      }
      {
#line 415
      sym_check_prop(sym);
#line 416
      sym->flags |= 32768;
      }
    }
  }
#line 419
  if (sym) {
    {
#line 419
    tmp___17 = sym_is_optional(sym);
    }
#line 419
    if (! tmp___17) {
#line 419
      if (parent->prompt) {
        {
#line 420
        tmp___15 = expr_alloc_symbol(& symbol_mod);
#line 420
        tmp___16 = expr_alloc_and((parent->prompt)->visible.expr, tmp___15);
#line 420
        sym->rev_dep.expr = expr_alloc_or(sym->rev_dep.expr, tmp___16);
        }
      }
    }
  }
#line 424
  return;
}
}
#line 426 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/menu.c"
_Bool menu_has_prompt(struct menu *menu ) 
{ 


  {
#line 428
  if (! menu->prompt) {
#line 429
    return ((_Bool)0);
  }
#line 430
  return ((_Bool)1);
}
}
#line 433 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/menu.c"
_Bool menu_is_visible(struct menu *menu ) 
{ 
  struct menu *child ;
  struct symbol *sym ;
  tristate visible ;
  tristate tmp ;
  tristate tmp___0 ;
  tristate tmp___1 ;
  _Bool tmp___2 ;

  {
#line 439
  if (! menu->prompt) {
#line 440
    return ((_Bool)0);
  }
#line 442
  if (menu->visibility) {
    {
#line 443
    tmp = expr_calc_value(menu->visibility);
    }
#line 443
    if ((unsigned int )tmp == 0U) {
#line 444
      return ((_Bool)0);
    }
  }
#line 447
  sym = menu->sym;
#line 448
  if (sym) {
    {
#line 449
    sym_calc_value(sym);
#line 450
    visible = (menu->prompt)->visible.tri;
    }
  } else {
    {
#line 452
    tmp___0 = expr_calc_value((menu->prompt)->visible.expr);
#line 452
    (menu->prompt)->visible.tri = tmp___0;
#line 452
    visible = tmp___0;
    }
  }
#line 454
  if ((unsigned int )visible != 0U) {
#line 455
    return ((_Bool)1);
  }
#line 457
  if (! sym) {
#line 458
    return ((_Bool)0);
  } else {
    {
#line 457
    tmp___1 = sym_get_tristate_value(menu->sym);
    }
#line 457
    if ((unsigned int )tmp___1 == 0U) {
#line 458
      return ((_Bool)0);
    }
  }
#line 460
  child = menu->list;
  {
#line 460
  while (1) {
    while_continue: /* CIL Label */ ;
#line 460
    if (! child) {
#line 460
      goto while_break;
    }
    {
#line 461
    tmp___2 = menu_is_visible(child);
    }
#line 461
    if (tmp___2) {
#line 462
      if (sym) {
#line 463
        sym->flags |= 65536;
      }
#line 464
      return ((_Bool)1);
    }
#line 460
    child = child->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 468
  return ((_Bool)0);
}
}
#line 471 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/menu.c"
char const   *menu_get_prompt(struct menu *menu ) 
{ 


  {
#line 473
  if (menu->prompt) {
#line 474
    return ((menu->prompt)->text);
  } else
#line 475
  if (menu->sym) {
#line 476
    return ((char const   *)(menu->sym)->name);
  }
#line 477
  return ((char const   *)((void *)0));
}
}
#line 480 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/menu.c"
struct menu *menu_get_root_menu(struct menu *menu ) 
{ 


  {
#line 482
  return (& rootmenu);
}
}
#line 485 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/menu.c"
struct menu *menu_get_parent_menu(struct menu *menu ) 
{ 
  enum prop_type type ;

  {
  {
#line 489
  while (1) {
    while_continue: /* CIL Label */ ;
#line 489
    if (! ((unsigned long )menu != (unsigned long )(& rootmenu))) {
#line 489
      goto while_break;
    }
#line 490
    if (menu->prompt) {
#line 490
      type = (menu->prompt)->type;
    } else {
#line 490
      type = (enum prop_type )0;
    }
#line 491
    if ((unsigned int )type == 3U) {
#line 492
      goto while_break;
    }
#line 489
    menu = menu->parent;
  }
  while_break: /* CIL Label */ ;
  }
#line 494
  return (menu);
}
}
#line 497 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/menu.c"
_Bool menu_has_help(struct menu *menu ) 
{ 


  {
#line 499
  return ((_Bool )((unsigned long )menu->help != (unsigned long )((void *)0)));
}
}
#line 502 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/menu.c"
char const   *menu_get_help(struct menu *menu ) 
{ 


  {
#line 504
  if (menu->help) {
#line 505
    return ((char const   *)menu->help);
  } else {
#line 507
    return ("");
  }
}
}
#line 510 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/menu.c"
static void get_prompt_str(struct gstr *r , struct property *prop ) 
{ 
  int i ;
  int j ;
  struct menu *submenu[8] ;
  struct menu *menu ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char const   *tmp___6 ;
  char *tmp___7 ;
  char const   *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;

  {
  {
#line 515
  tmp = gettext(prop->text);
#line 515
  tmp___0 = gettext("Prompt: %s\n");
#line 515
  str_printf(r, (char const   *)tmp___0, tmp);
#line 516
  tmp___1 = gettext("  Defined at %s:%d\n");
#line 516
  str_printf(r, (char const   *)tmp___1, ((prop->menu)->file)->name, (prop->menu)->lineno);
#line 518
  tmp___3 = expr_is_yes(prop->visible.expr);
  }
#line 518
  if (! tmp___3) {
    {
#line 519
    tmp___2 = gettext("  Depends on: ");
#line 519
    str_append(r, (char const   *)tmp___2);
#line 520
    expr_gstr_print(prop->visible.expr, r);
#line 521
    str_append(r, "\n");
    }
  }
#line 523
  menu = (prop->menu)->parent;
#line 524
  i = 0;
  {
#line 524
  while (1) {
    while_continue: /* CIL Label */ ;
#line 524
    if ((unsigned long )menu != (unsigned long )(& rootmenu)) {
#line 524
      if (! (i < 8)) {
#line 524
        goto while_break;
      }
    } else {
#line 524
      goto while_break;
    }
#line 525
    tmp___4 = i;
#line 525
    i ++;
#line 525
    submenu[tmp___4] = menu;
#line 524
    menu = menu->parent;
  }
  while_break: /* CIL Label */ ;
  }
#line 526
  if (i > 0) {
    {
#line 527
    tmp___5 = gettext("  Location:\n");
#line 527
    str_printf(r, (char const   *)tmp___5);
#line 528
    j = 4;
    }
    {
#line 528
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 528
      i --;
#line 528
      if (! (i >= 0)) {
#line 528
        goto while_break___0;
      }
      {
#line 529
      menu = submenu[i];
#line 530
      tmp___6 = menu_get_prompt(menu);
#line 530
      tmp___7 = gettext(tmp___6);
#line 530
      str_printf(r, "%*c-> %s", j, ' ', tmp___7);
      }
#line 531
      if (menu->sym) {
        {
#line 532
        tmp___8 = sym_get_string_value(menu->sym);
        }
#line 532
        if ((menu->sym)->name) {
#line 532
          tmp___10 = (menu->sym)->name;
        } else {
          {
#line 532
          tmp___9 = gettext("<choice>");
#line 532
          tmp___10 = tmp___9;
          }
        }
        {
#line 532
        str_printf(r, " (%s [=%s])", tmp___10, tmp___8);
        }
      }
      {
#line 536
      str_append(r, "\n");
#line 528
      j += 2;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 539
  return;
}
}
#line 541 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/menu.c"
void get_symbol_str(struct gstr *r , struct symbol *sym ) 
{ 
  _Bool hit ;
  struct property *prop ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;

  {
#line 546
  if (sym) {
#line 546
    if (sym->name) {
      {
#line 547
      tmp = sym_get_string_value(sym);
#line 547
      str_printf(r, "Symbol: %s [=%s]\n", sym->name, tmp);
#line 549
      tmp___0 = sym_type_name(sym->type);
#line 549
      str_printf(r, "Type  : %s\n", tmp___0);
      }
#line 550
      if ((unsigned int )sym->type == 3U) {
#line 550
        goto _L;
      } else
#line 550
      if ((unsigned int )sym->type == 4U) {
        _L: /* CIL Label */ 
        {
#line 551
        prop = sym_get_range_prop(sym);
        }
#line 552
        if (prop) {
          {
#line 553
          str_printf(r, "Range : ");
#line 554
          expr_gstr_print(prop->expr, r);
#line 555
          str_append(r, "\n");
          }
        }
      }
    }
  }
#line 559
  prop = sym->prop;
  {
#line 559
  while (1) {
    while_continue: /* CIL Label */ ;
#line 559
    if (! prop) {
#line 559
      goto while_break;
    }
#line 559
    if (prop->text) {
      {
#line 560
      get_prompt_str(r, prop);
      }
    }
#line 559
    prop = prop->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 561
  hit = (_Bool)0;
#line 562
  prop = sym->prop;
  {
#line 562
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 562
    if (! prop) {
#line 562
      goto while_break___0;
    }
#line 562
    if ((unsigned int )prop->type == 6U) {
#line 563
      if (! hit) {
        {
#line 564
        str_append(r, "  Selects: ");
#line 565
        hit = (_Bool)1;
        }
      } else {
        {
#line 567
        str_printf(r, " && ");
        }
      }
      {
#line 568
      expr_gstr_print(prop->expr, r);
      }
    }
#line 562
    prop = prop->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 570
  if (hit) {
    {
#line 571
    str_append(r, "\n");
    }
  }
#line 572
  if (sym->rev_dep.expr) {
    {
#line 573
    tmp___1 = gettext("  Selected by: ");
#line 573
    str_append(r, (char const   *)tmp___1);
#line 574
    expr_gstr_print(sym->rev_dep.expr, r);
#line 575
    str_append(r, "\n");
    }
  }
  {
#line 577
  str_append(r, "\n\n");
  }
#line 578
  return;
}
}
#line 580 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/menu.c"
struct gstr get_relations_str(struct symbol **sym_arr ) 
{ 
  struct symbol *sym ;
  struct gstr res ;
  struct gstr tmp ;
  int i ;
  char *tmp___0 ;

  {
  {
#line 583
  tmp = str_new();
#line 583
  res = tmp;
#line 586
  i = 0;
  }
  {
#line 586
  while (1) {
    while_continue: /* CIL Label */ ;
#line 586
    if (sym_arr) {
#line 586
      sym = *(sym_arr + i);
#line 586
      if (! sym) {
#line 586
        goto while_break;
      }
    } else {
#line 586
      goto while_break;
    }
    {
#line 587
    get_symbol_str(& res, sym);
#line 586
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 588
  if (! i) {
    {
#line 589
    tmp___0 = gettext("No matches found.\n");
#line 589
    str_append(& res, (char const   *)tmp___0);
    }
  }
#line 590
  return (res);
}
}
#line 594 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/scripts/kconfig/menu.c"
void menu_get_ext_help(struct menu *menu , struct gstr *help ) 
{ 
  struct symbol *sym ;
  char const   *help_text ;
  _Bool tmp ;
  char *tmp___0 ;

  {
  {
#line 596
  sym = menu->sym;
#line 597
  help_text = nohelp_text;
#line 599
  tmp = menu_has_help(menu);
  }
#line 599
  if (tmp) {
#line 600
    if (sym->name) {
      {
#line 601
      str_printf(help, "%s%s:\n\n", "CONFIG_", sym->name);
      }
    }
    {
#line 602
    help_text = menu_get_help(menu);
    }
  }
  {
#line 604
  tmp___0 = gettext(help_text);
#line 604
  str_printf(help, "%s\n", tmp___0);
  }
#line 605
  if (sym) {
    {
#line 606
    get_symbol_str(help, sym);
    }
  }
#line 607
  return;
}
}
#line 709 "/usr/include/stdio.h"
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 765 "/usr/include/stdlib.h"
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 413 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 582 "/usr/include/regex.h"
extern size_t regerror(int __errcode , regex_t const   * __restrict  __preg , char * __restrict  __errbuf ,
                       size_t __errbuf_size ) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/tools/include/tools/le_byteshift.h"
__inline static void __put_unaligned_le16(__u16 val , __u8 *p ) 
{ 
  __u8 *tmp ;
  __u8 *tmp___0 ;

  {
#line 24
  tmp = p;
#line 24
  p ++;
#line 24
  *tmp = (__u8 )val;
#line 25
  tmp___0 = p;
#line 25
  p ++;
#line 25
  *tmp___0 = (__u8 )((int )val >> 8);
#line 26
  return;
}
}
#line 28 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/tools/include/tools/le_byteshift.h"
__inline static void __put_unaligned_le32(__u32 val , __u8 *p ) 
{ 


  {
  {
#line 30
  __put_unaligned_le16((__u16 )(val >> 16), p + 2);
#line 31
  __put_unaligned_le16((__u16 )val, p);
  }
#line 32
  return;
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/tools/include/tools/le_byteshift.h"
__inline static void put_unaligned_le32(__u32 val , void *p ) 
{ 


  {
  {
#line 62
  __put_unaligned_le32(val, (__u8 *)p);
  }
#line 63
  return;
}
}
#line 15 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/arch/x86/tools/relocs.c"
static void die(char *fmt  , ...) ;
#line 18 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/arch/x86/tools/relocs.c"
static Elf32_Ehdr ehdr  ;
#line 19 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/arch/x86/tools/relocs.c"
static unsigned long reloc_count  ;
#line 19 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/arch/x86/tools/relocs.c"
static unsigned long reloc_idx  ;
#line 20 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/arch/x86/tools/relocs.c"
static unsigned long *relocs  ;
#line 21 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/arch/x86/tools/relocs.c"
static unsigned long reloc16_count  ;
#line 21 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/arch/x86/tools/relocs.c"
static unsigned long reloc16_idx  ;
#line 22 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/arch/x86/tools/relocs.c"
static unsigned long *relocs16  ;
#line 31 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/arch/x86/tools/relocs.c"
static struct section *secs  ;
#line 41 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/arch/x86/tools/relocs.c"
static char const   * const  sym_regex_kernel[4]  = {      (char const   */* const  */)"^(xen_irq_disable_direct_reloc$|xen_save_fl_direct_reloc$|VDSO|__crc_)",      (char const   */* const  */)"^(__init_(begin|end)|__x86_cpu_dev_(start|end)|(__parainstructions|__alt_instructions)(|_end)|(__iommu_table|__apicdrivers|__smp_locks)(|_end)|_end)$"};
#line 67 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/arch/x86/tools/relocs.c"
static char const   * const  sym_regex_realmode[4]  = {      (char const   */* const  */)0,      (char const   */* const  */)0,      (char const   */* const  */)"^real_mode_seg$",      (char const   */* const  */)"^pa_"};
#line 82 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/arch/x86/tools/relocs.c"
static char const   * const  *sym_regex  ;
#line 84 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/arch/x86/tools/relocs.c"
static regex_t sym_regex_c[4]  ;
#line 85 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/arch/x86/tools/relocs.c"
static int is_reloc(enum symtype type , char const   *sym_name___0 ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 87
  if (*(sym_regex + type)) {
    {
#line 87
    tmp = regexec((regex_t const   */* __restrict  */)(& sym_regex_c[type]), (char const   */* __restrict  */)sym_name___0,
                  (size_t )0, (regmatch_t */* __restrict  */)((void *)0), 0);
    }
#line 87
    if (tmp) {
#line 87
      tmp___0 = 0;
    } else {
#line 87
      tmp___0 = 1;
    }
  } else {
#line 87
    tmp___0 = 0;
  }
#line 87
  return (tmp___0);
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/arch/x86/tools/relocs.c"
static void regex_init(int use_real_mode ) 
{ 
  char errbuf[128] ;
  int err ;
  int i ;

  {
#line 97
  if (use_real_mode) {
#line 98
    sym_regex = sym_regex_realmode;
  } else {
#line 100
    sym_regex = sym_regex_kernel;
  }
#line 102
  i = 0;
  {
#line 102
  while (1) {
    while_continue: /* CIL Label */ ;
#line 102
    if (! (i < 4)) {
#line 102
      goto while_break;
    }
#line 103
    if (! *(sym_regex + i)) {
#line 104
      goto __Cont;
    }
    {
#line 106
    err = regcomp((regex_t */* __restrict  */)(& sym_regex_c[i]), (char const   */* __restrict  */)*(sym_regex + i),
                  1 | (((1 << 1) << 1) << 1));
    }
#line 109
    if (err) {
      {
#line 110
      regerror(err, (regex_t const   */* __restrict  */)(& sym_regex_c[i]), (char */* __restrict  */)(errbuf),
               sizeof(errbuf));
#line 111
      die((char *)"%s", errbuf);
      }
    }
    __Cont: /* CIL Label */ 
#line 102
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 114
  return;
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/arch/x86/tools/relocs.c"
static void die(char *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 119
  __builtin_va_start(ap, fmt);
#line 120
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
           ap);
#line 121
  __builtin_va_end(ap);
#line 122
  exit(1);
  }
}
}
#line 127
static char const   *sym_type(unsigned int type ) ;
#line 127 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/arch/x86/tools/relocs.c"
static char const   *type_name[7]  = {      "STT_NOTYPE",      "STT_OBJECT",      "STT_FUNC",      "STT_SECTION", 
        "STT_FILE",      "STT_COMMON",      "STT_TLS"};
#line 125 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/arch/x86/tools/relocs.c"
static char const   *sym_type(unsigned int type ) 
{ 
  char const   *name ;

  {
#line 138
  name = "unknown sym type name";
#line 139
  if ((unsigned long )type < sizeof(type_name) / sizeof(type_name[0])) {
#line 140
    name = type_name[type];
  }
#line 142
  return (name);
}
}
#line 147
static char const   *sym_bind(unsigned int bind ) ;
#line 147 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/arch/x86/tools/relocs.c"
static char const   *bind_name[3]  = {      "STB_LOCAL",      "STB_GLOBAL",      "STB_WEAK"};
#line 145 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/arch/x86/tools/relocs.c"
static char const   *sym_bind(unsigned int bind ) 
{ 
  char const   *name ;

  {
#line 154
  name = "unknown sym bind name";
#line 155
  if ((unsigned long )bind < sizeof(bind_name) / sizeof(bind_name[0])) {
#line 156
    name = bind_name[bind];
  }
#line 158
  return (name);
}
}
#line 163
static char const   *sym_visibility(unsigned int visibility ) ;
#line 163 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/arch/x86/tools/relocs.c"
static char const   *visibility_name[4]  = {      "STV_DEFAULT",      "STV_INTERNAL",      "STV_HIDDEN",      "STV_PROTECTED"};
#line 161 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/arch/x86/tools/relocs.c"
static char const   *sym_visibility(unsigned int visibility ) 
{ 
  char const   *name ;

  {
#line 171
  name = "unknown sym visibility name";
#line 172
  if ((unsigned long )visibility < sizeof(visibility_name) / sizeof(visibility_name[0])) {
#line 173
    name = visibility_name[visibility];
  }
#line 175
  return (name);
}
}
#line 180
static char const   *rel_type(unsigned int type ) ;
#line 180 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/arch/x86/tools/relocs.c"
static char const   *type_name___0[24]  = 
#line 180
  {      "R_386_NONE",      "R_386_32",      "R_386_PC32",      "R_386_GOT32", 
        "R_386_PLT32",      "R_386_COPY",      "R_386_GLOB_DAT",      "R_386_JMP_SLOT", 
        "R_386_RELATIVE",      "R_386_GOTOFF",      "R_386_GOTPC",      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        (char const   *)0,      (char const   *)0,      (char const   *)0,      (char const   *)0, 
        "R_386_16",      "R_386_PC16",      "R_386_8",      "R_386_PC8"};
#line 178 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/arch/x86/tools/relocs.c"
static char const   *rel_type(unsigned int type ) 
{ 
  char const   *name ;

  {
#line 199
  name = "unknown type rel type name";
#line 200
  if ((unsigned long )type < sizeof(type_name___0) / sizeof(type_name___0[0])) {
#line 200
    if (type_name___0[type]) {
#line 201
      name = type_name___0[type];
    }
  }
#line 203
  return (name);
}
}
#line 206 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/arch/x86/tools/relocs.c"
static char const   *sec_name(unsigned int shndx ) 
{ 
  char const   *sec_strtab ;
  char const   *name ;

  {
#line 210
  sec_strtab = (char const   *)(secs + ehdr.e_shstrndx)->strtab;
#line 211
  name = "<noname>";
#line 212
  if (shndx < (unsigned int )ehdr.e_shnum) {
#line 213
    name = sec_strtab + (secs + shndx)->shdr.sh_name;
  } else
#line 215
  if (shndx == 65521U) {
#line 216
    name = "ABSOLUTE";
  } else
#line 218
  if (shndx == 65522U) {
#line 219
    name = "COMMON";
  }
#line 221
  return (name);
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/arch/x86/tools/relocs.c"
static char const   *sym_name(char const   *sym_strtab , Elf32_Sym *sym ) 
{ 
  char const   *name ;

  {
#line 227
  name = "<noname>";
#line 228
  if (sym->st_name) {
#line 229
    name = sym_strtab + sym->st_name;
  } else {
    {
#line 232
    name = sec_name((unsigned int )sym->st_shndx);
    }
  }
#line 234
  return (name);
}
}
#line 248 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/arch/x86/tools/relocs.c"
static uint16_t elf16_to_cpu(uint16_t val ) 
{ 


  {
#line 250
  return (val);
}
}
#line 253 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/arch/x86/tools/relocs.c"
static uint32_t elf32_to_cpu(uint32_t val ) 
{ 


  {
#line 255
  return (val);
}
}
#line 258 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/arch/x86/tools/relocs.c"
static void read_ehdr(FILE *fp ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
  {
#line 260
  tmp___1 = fread((void */* __restrict  */)(& ehdr), sizeof(ehdr), (size_t )1, (FILE */* __restrict  */)fp);
  }
#line 260
  if (tmp___1 != 1UL) {
    {
#line 261
    tmp = __errno_location();
#line 261
    tmp___0 = strerror(*tmp);
#line 261
    die((char *)"Cannot read ELF header: %s\n", tmp___0);
    }
  }
  {
#line 264
  tmp___2 = memcmp((void const   *)(ehdr.e_ident), (void const   *)"\177ELF", (size_t )4);
  }
#line 264
  if (tmp___2 != 0) {
    {
#line 265
    die((char *)"No ELF magic\n");
    }
  }
#line 267
  if ((int )ehdr.e_ident[4] != 1) {
    {
#line 268
    die((char *)"Not a 32 bit executable\n");
    }
  }
#line 270
  if ((int )ehdr.e_ident[5] != 1) {
    {
#line 271
    die((char *)"Not a LSB ELF executable\n");
    }
  }
#line 273
  if ((int )ehdr.e_ident[6] != 1) {
    {
#line 274
    die((char *)"Unknown ELF version\n");
    }
  }
  {
#line 277
  ehdr.e_type = elf16_to_cpu(ehdr.e_type);
#line 278
  ehdr.e_machine = elf16_to_cpu(ehdr.e_machine);
#line 279
  ehdr.e_version = elf32_to_cpu(ehdr.e_version);
#line 280
  ehdr.e_entry = elf32_to_cpu(ehdr.e_entry);
#line 281
  ehdr.e_phoff = elf32_to_cpu(ehdr.e_phoff);
#line 282
  ehdr.e_shoff = elf32_to_cpu(ehdr.e_shoff);
#line 283
  ehdr.e_flags = elf32_to_cpu(ehdr.e_flags);
#line 284
  ehdr.e_ehsize = elf16_to_cpu(ehdr.e_ehsize);
#line 285
  ehdr.e_phentsize = elf16_to_cpu(ehdr.e_phentsize);
#line 286
  ehdr.e_phnum = elf16_to_cpu(ehdr.e_phnum);
#line 287
  ehdr.e_shentsize = elf16_to_cpu(ehdr.e_shentsize);
#line 288
  ehdr.e_shnum = elf16_to_cpu(ehdr.e_shnum);
#line 289
  ehdr.e_shstrndx = elf16_to_cpu(ehdr.e_shstrndx);
  }
#line 291
  if ((int )ehdr.e_type != 2) {
#line 291
    if ((int )ehdr.e_type != 3) {
      {
#line 292
      die((char *)"Unsupported ELF header type\n");
      }
    }
  }
#line 294
  if ((int )ehdr.e_machine != 3) {
    {
#line 295
    die((char *)"Not for x86\n");
    }
  }
#line 297
  if (ehdr.e_version != 1U) {
    {
#line 298
    die((char *)"Unknown ELF version\n");
    }
  }
#line 300
  if ((unsigned long )ehdr.e_ehsize != sizeof(Elf32_Ehdr )) {
    {
#line 301
    die((char *)"Bad Elf header size\n");
    }
  }
#line 303
  if ((unsigned long )ehdr.e_phentsize != sizeof(Elf32_Phdr )) {
    {
#line 304
    die((char *)"Bad program header entry\n");
    }
  }
#line 306
  if ((unsigned long )ehdr.e_shentsize != sizeof(Elf32_Shdr )) {
    {
#line 307
    die((char *)"Bad section header entry\n");
    }
  }
#line 309
  if ((int )ehdr.e_shstrndx >= (int )ehdr.e_shnum) {
    {
#line 310
    die((char *)"String table index out of bounds\n");
    }
  }
#line 312
  return;
}
}
#line 314 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/arch/x86/tools/relocs.c"
static void read_shdrs(FILE *fp ) 
{ 
  int i ;
  Elf32_Shdr shdr ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  struct section *sec ;
  int *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;

  {
  {
#line 319
  tmp = calloc((size_t )ehdr.e_shnum, sizeof(struct section ));
#line 319
  secs = (struct section *)tmp;
  }
#line 320
  if (! secs) {
    {
#line 321
    die((char *)"Unable to allocate %d section headers\n", (int )ehdr.e_shnum);
    }
  }
  {
#line 324
  tmp___2 = fseek(fp, (long )ehdr.e_shoff, 0);
  }
#line 324
  if (tmp___2 < 0) {
    {
#line 325
    tmp___0 = __errno_location();
#line 325
    tmp___1 = strerror(*tmp___0);
#line 325
    die((char *)"Seek to %d failed: %s\n", ehdr.e_shoff, tmp___1);
    }
  }
#line 328
  i = 0;
  {
#line 328
  while (1) {
    while_continue: /* CIL Label */ ;
#line 328
    if (! (i < (int )ehdr.e_shnum)) {
#line 328
      goto while_break;
    }
    {
#line 329
    sec = secs + i;
#line 330
    tmp___5 = fread((void */* __restrict  */)(& shdr), sizeof(shdr), (size_t )1, (FILE */* __restrict  */)fp);
    }
#line 330
    if (tmp___5 != 1UL) {
      {
#line 331
      tmp___3 = __errno_location();
#line 331
      tmp___4 = strerror(*tmp___3);
#line 331
      die((char *)"Cannot read ELF section headers %d/%d: %s\n", i, (int )ehdr.e_shnum,
          tmp___4);
      }
    }
    {
#line 333
    sec->shdr.sh_name = elf32_to_cpu(shdr.sh_name);
#line 334
    sec->shdr.sh_type = elf32_to_cpu(shdr.sh_type);
#line 335
    sec->shdr.sh_flags = elf32_to_cpu(shdr.sh_flags);
#line 336
    sec->shdr.sh_addr = elf32_to_cpu(shdr.sh_addr);
#line 337
    sec->shdr.sh_offset = elf32_to_cpu(shdr.sh_offset);
#line 338
    sec->shdr.sh_size = elf32_to_cpu(shdr.sh_size);
#line 339
    sec->shdr.sh_link = elf32_to_cpu(shdr.sh_link);
#line 340
    sec->shdr.sh_info = elf32_to_cpu(shdr.sh_info);
#line 341
    sec->shdr.sh_addralign = elf32_to_cpu(shdr.sh_addralign);
#line 342
    sec->shdr.sh_entsize = elf32_to_cpu(shdr.sh_entsize);
    }
#line 343
    if (sec->shdr.sh_link < (Elf32_Word )ehdr.e_shnum) {
#line 344
      sec->link = secs + sec->shdr.sh_link;
    }
#line 328
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 347
  return;
}
}
#line 349 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/arch/x86/tools/relocs.c"
static void read_strtabs(FILE *fp ) 
{ 
  int i ;
  struct section *sec ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;

  {
#line 352
  i = 0;
  {
#line 352
  while (1) {
    while_continue: /* CIL Label */ ;
#line 352
    if (! (i < (int )ehdr.e_shnum)) {
#line 352
      goto while_break;
    }
#line 353
    sec = secs + i;
#line 354
    if (sec->shdr.sh_type != 3U) {
#line 355
      goto __Cont;
    }
    {
#line 357
    tmp = malloc((size_t )sec->shdr.sh_size);
#line 357
    sec->strtab = (char *)tmp;
    }
#line 358
    if (! sec->strtab) {
      {
#line 359
      die((char *)"malloc of %d bytes for strtab failed\n", sec->shdr.sh_size);
      }
    }
    {
#line 362
    tmp___2 = fseek(fp, (long )sec->shdr.sh_offset, 0);
    }
#line 362
    if (tmp___2 < 0) {
      {
#line 363
      tmp___0 = __errno_location();
#line 363
      tmp___1 = strerror(*tmp___0);
#line 363
      die((char *)"Seek to %d failed: %s\n", sec->shdr.sh_offset, tmp___1);
      }
    }
    {
#line 366
    tmp___5 = fread((void */* __restrict  */)sec->strtab, (size_t )1, (size_t )sec->shdr.sh_size,
                    (FILE */* __restrict  */)fp);
    }
#line 366
    if (tmp___5 != (size_t )sec->shdr.sh_size) {
      {
#line 368
      tmp___3 = __errno_location();
#line 368
      tmp___4 = strerror(*tmp___3);
#line 368
      die((char *)"Cannot read symbol table: %s\n", tmp___4);
      }
    }
    __Cont: /* CIL Label */ 
#line 352
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 372
  return;
}
}
#line 374 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/arch/x86/tools/relocs.c"
static void read_symtabs(FILE *fp ) 
{ 
  int i ;
  int j ;
  struct section *sec ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  Elf32_Sym *sym ;

  {
#line 377
  i = 0;
  {
#line 377
  while (1) {
    while_continue: /* CIL Label */ ;
#line 377
    if (! (i < (int )ehdr.e_shnum)) {
#line 377
      goto while_break;
    }
#line 378
    sec = secs + i;
#line 379
    if (sec->shdr.sh_type != 2U) {
#line 380
      goto __Cont;
    }
    {
#line 382
    tmp = malloc((size_t )sec->shdr.sh_size);
#line 382
    sec->symtab = (Elf32_Sym *)tmp;
    }
#line 383
    if (! sec->symtab) {
      {
#line 384
      die((char *)"malloc of %d bytes for symtab failed\n", sec->shdr.sh_size);
      }
    }
    {
#line 387
    tmp___2 = fseek(fp, (long )sec->shdr.sh_offset, 0);
    }
#line 387
    if (tmp___2 < 0) {
      {
#line 388
      tmp___0 = __errno_location();
#line 388
      tmp___1 = strerror(*tmp___0);
#line 388
      die((char *)"Seek to %d failed: %s\n", sec->shdr.sh_offset, tmp___1);
      }
    }
    {
#line 391
    tmp___5 = fread((void */* __restrict  */)sec->symtab, (size_t )1, (size_t )sec->shdr.sh_size,
                    (FILE */* __restrict  */)fp);
    }
#line 391
    if (tmp___5 != (size_t )sec->shdr.sh_size) {
      {
#line 393
      tmp___3 = __errno_location();
#line 393
      tmp___4 = strerror(*tmp___3);
#line 393
      die((char *)"Cannot read symbol table: %s\n", tmp___4);
      }
    }
#line 396
    j = 0;
    {
#line 396
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 396
      if (! ((unsigned long )j < (unsigned long )sec->shdr.sh_size / sizeof(Elf32_Sym ))) {
#line 396
        goto while_break___0;
      }
      {
#line 397
      sym = sec->symtab + j;
#line 398
      sym->st_name = elf32_to_cpu(sym->st_name);
#line 399
      sym->st_value = elf32_to_cpu(sym->st_value);
#line 400
      sym->st_size = elf32_to_cpu(sym->st_size);
#line 401
      sym->st_shndx = elf16_to_cpu(sym->st_shndx);
#line 396
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 377
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 404
  return;
}
}
#line 407 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/arch/x86/tools/relocs.c"
static void read_relocs(FILE *fp ) 
{ 
  int i ;
  int j ;
  struct section *sec ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  Elf32_Rel *rel ;

  {
#line 410
  i = 0;
  {
#line 410
  while (1) {
    while_continue: /* CIL Label */ ;
#line 410
    if (! (i < (int )ehdr.e_shnum)) {
#line 410
      goto while_break;
    }
#line 411
    sec = secs + i;
#line 412
    if (sec->shdr.sh_type != 9U) {
#line 413
      goto __Cont;
    }
    {
#line 415
    tmp = malloc((size_t )sec->shdr.sh_size);
#line 415
    sec->reltab = (Elf32_Rel *)tmp;
    }
#line 416
    if (! sec->reltab) {
      {
#line 417
      die((char *)"malloc of %d bytes for relocs failed\n", sec->shdr.sh_size);
      }
    }
    {
#line 420
    tmp___2 = fseek(fp, (long )sec->shdr.sh_offset, 0);
    }
#line 420
    if (tmp___2 < 0) {
      {
#line 421
      tmp___0 = __errno_location();
#line 421
      tmp___1 = strerror(*tmp___0);
#line 421
      die((char *)"Seek to %d failed: %s\n", sec->shdr.sh_offset, tmp___1);
      }
    }
    {
#line 424
    tmp___5 = fread((void */* __restrict  */)sec->reltab, (size_t )1, (size_t )sec->shdr.sh_size,
                    (FILE */* __restrict  */)fp);
    }
#line 424
    if (tmp___5 != (size_t )sec->shdr.sh_size) {
      {
#line 426
      tmp___3 = __errno_location();
#line 426
      tmp___4 = strerror(*tmp___3);
#line 426
      die((char *)"Cannot read symbol table: %s\n", tmp___4);
      }
    }
#line 429
    j = 0;
    {
#line 429
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 429
      if (! ((unsigned long )j < (unsigned long )sec->shdr.sh_size / sizeof(Elf32_Rel ))) {
#line 429
        goto while_break___0;
      }
      {
#line 430
      rel = sec->reltab + j;
#line 431
      rel->r_offset = elf32_to_cpu(rel->r_offset);
#line 432
      rel->r_info = elf32_to_cpu(rel->r_info);
#line 429
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 410
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 435
  return;
}
}
#line 438 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/arch/x86/tools/relocs.c"
static void print_absolute_symbols(void) 
{ 
  int i ;
  struct section *sec ;
  char *sym_strtab ;
  int j ;
  Elf32_Sym *sym ;
  char const   *name ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 441
  printf((char const   */* __restrict  */)"Absolute symbols\n");
#line 442
  printf((char const   */* __restrict  */)" Num:    Value Size  Type       Bind        Visibility  Name\n");
#line 443
  i = 0;
  }
  {
#line 443
  while (1) {
    while_continue: /* CIL Label */ ;
#line 443
    if (! (i < (int )ehdr.e_shnum)) {
#line 443
      goto while_break;
    }
#line 444
    sec = secs + i;
#line 448
    if (sec->shdr.sh_type != 2U) {
#line 449
      goto __Cont;
    }
#line 451
    sym_strtab = (sec->link)->strtab;
#line 452
    j = 0;
    {
#line 452
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 452
      if (! ((unsigned long )j < (unsigned long )sec->shdr.sh_size / sizeof(Elf32_Sym ))) {
#line 452
        goto while_break___0;
      }
      {
#line 455
      sym = sec->symtab + j;
#line 456
      name = sym_name((char const   *)sym_strtab, sym);
      }
#line 457
      if ((int )sym->st_shndx != 65521) {
#line 458
        goto __Cont___0;
      }
      {
#line 460
      tmp = sym_visibility((unsigned int )((int )sym->st_other & 3));
#line 460
      tmp___0 = sym_bind((unsigned int )((int )sym->st_info >> 4));
#line 460
      tmp___1 = sym_type((unsigned int )((int )sym->st_info & 15));
#line 460
      printf((char const   */* __restrict  */)"%5d %08x %5d %10s %10s %12s %s\n",
             j, sym->st_value, sym->st_size, tmp___1, tmp___0, tmp, name);
      }
      __Cont___0: /* CIL Label */ 
#line 452
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 443
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 468
  printf((char const   */* __restrict  */)"\n");
  }
#line 469
  return;
}
}
#line 471 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/arch/x86/tools/relocs.c"
static void print_absolute_relocs(void) 
{ 
  int i ;
  int printed ;
  struct section *sec ;
  struct section *sec_applies ;
  struct section *sec_symtab ;
  char *sym_strtab ;
  Elf32_Sym *sh_symtab ;
  int j ;
  Elf32_Rel *rel ;
  Elf32_Sym *sym ;
  char const   *name ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;

  {
#line 473
  printed = 0;
#line 475
  i = 0;
  {
#line 475
  while (1) {
    while_continue: /* CIL Label */ ;
#line 475
    if (! (i < (int )ehdr.e_shnum)) {
#line 475
      goto while_break;
    }
#line 476
    sec = secs + i;
#line 481
    if (sec->shdr.sh_type != 9U) {
#line 482
      goto __Cont;
    }
#line 484
    sec_symtab = sec->link;
#line 485
    sec_applies = secs + sec->shdr.sh_info;
#line 486
    if (! (sec_applies->shdr.sh_flags & (unsigned int )(1 << 1))) {
#line 487
      goto __Cont;
    }
#line 489
    sh_symtab = sec_symtab->symtab;
#line 490
    sym_strtab = (sec_symtab->link)->strtab;
#line 491
    j = 0;
    {
#line 491
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 491
      if (! ((unsigned long )j < (unsigned long )sec->shdr.sh_size / sizeof(Elf32_Rel ))) {
#line 491
        goto while_break___0;
      }
      {
#line 495
      rel = sec->reltab + j;
#line 496
      sym = sh_symtab + (rel->r_info >> 8);
#line 497
      name = sym_name((char const   *)sym_strtab, sym);
      }
#line 498
      if ((int )sym->st_shndx != 65521) {
#line 499
        goto __Cont___0;
      }
      {
#line 515
      tmp = is_reloc((enum symtype )0, name);
      }
#line 515
      if (tmp) {
#line 516
        goto __Cont___0;
      } else {
        {
#line 515
        tmp___0 = is_reloc((enum symtype )1, name);
        }
#line 515
        if (tmp___0) {
#line 516
          goto __Cont___0;
        }
      }
#line 518
      if (! printed) {
        {
#line 519
        printf((char const   */* __restrict  */)"WARNING: Absolute relocations present\n");
#line 521
        printf((char const   */* __restrict  */)"Offset     Info     Type     Sym.Value Sym.Name\n");
#line 523
        printed = 1;
        }
      }
      {
#line 526
      tmp___1 = rel_type(rel->r_info & 255U);
#line 526
      printf((char const   */* __restrict  */)"%08x %08x %10s %08x  %s\n", rel->r_offset,
             rel->r_info, tmp___1, sym->st_value, name);
      }
      __Cont___0: /* CIL Label */ 
#line 491
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 475
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 535
  if (printed) {
    {
#line 536
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 537
  return;
}
}
#line 539 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/arch/x86/tools/relocs.c"
static void walk_relocs(void (*visit)(Elf32_Rel *rel , Elf32_Sym *sym ) , int use_real_mode ) 
{ 
  int i ;
  char *sym_strtab ;
  Elf32_Sym *sh_symtab ;
  struct section *sec_applies ;
  struct section *sec_symtab ;
  int j ;
  struct section *sec ;
  Elf32_Rel *rel ;
  Elf32_Sym *sym ;
  unsigned int r_type ;
  char const   *symname ;
  int shn_abs ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;

  {
#line 544
  i = 0;
  {
#line 544
  while (1) {
    while_continue: /* CIL Label */ ;
#line 544
    if (! (i < (int )ehdr.e_shnum)) {
#line 544
      goto while_break;
    }
#line 549
    sec = secs + i;
#line 551
    if (sec->shdr.sh_type != 9U) {
#line 552
      goto __Cont;
    }
#line 554
    sec_symtab = sec->link;
#line 555
    sec_applies = secs + sec->shdr.sh_info;
#line 556
    if (! (sec_applies->shdr.sh_flags & (unsigned int )(1 << 1))) {
#line 557
      goto __Cont;
    }
#line 559
    sh_symtab = sec_symtab->symtab;
#line 560
    sym_strtab = (sec_symtab->link)->strtab;
#line 561
    j = 0;
    {
#line 561
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 561
      if (! ((unsigned long )j < (unsigned long )sec->shdr.sh_size / sizeof(Elf32_Rel ))) {
#line 561
        goto while_break___0;
      }
#line 568
      rel = sec->reltab + j;
#line 569
      sym = sh_symtab + (rel->r_info >> 8);
#line 570
      r_type = rel->r_info & 255U;
#line 572
      shn_abs = (int )sym->st_shndx == 65521;
      {
#line 578
      if (r_type == 23U) {
#line 578
        goto case_23;
      }
#line 578
      if (r_type == 21U) {
#line 578
        goto case_23;
      }
#line 578
      if (r_type == 2U) {
#line 578
        goto case_23;
      }
#line 578
      if (r_type == 0U) {
#line 578
        goto case_23;
      }
#line 585
      if (r_type == 20U) {
#line 585
        goto case_20;
      }
#line 603
      if (r_type == 1U) {
#line 603
        goto case_1;
      }
#line 617
      goto switch_default;
      case_23: /* CIL Label */ 
      case_21: /* CIL Label */ 
      case_2: /* CIL Label */ 
      case_0: /* CIL Label */ 
#line 583
      goto switch_break;
      case_20: /* CIL Label */ 
      {
#line 586
      symname = sym_name((char const   *)sym_strtab, sym);
      }
#line 587
      if (! use_real_mode) {
#line 588
        goto bad;
      }
#line 589
      if (shn_abs) {
        {
#line 590
        tmp___0 = is_reloc((enum symtype )0, symname);
        }
#line 590
        if (tmp___0) {
#line 591
          goto switch_break;
        } else {
          {
#line 592
          tmp = is_reloc((enum symtype )2, symname);
          }
#line 592
          if (! tmp) {
#line 593
            goto bad;
          }
        }
      } else {
        {
#line 595
        tmp___1 = is_reloc((enum symtype )3, symname);
        }
#line 595
        if (tmp___1) {
#line 596
          goto bad;
        } else {
#line 598
          goto switch_break;
        }
      }
      {
#line 600
      (*visit)(rel, sym);
      }
#line 601
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 604
      symname = sym_name((char const   *)sym_strtab, sym);
      }
#line 605
      if (shn_abs) {
        {
#line 606
        tmp___3 = is_reloc((enum symtype )0, symname);
        }
#line 606
        if (tmp___3) {
#line 607
          goto switch_break;
        } else {
          {
#line 608
          tmp___2 = is_reloc((enum symtype )1, symname);
          }
#line 608
          if (! tmp___2) {
#line 609
            goto bad;
          }
        }
      } else
#line 611
      if (use_real_mode) {
        {
#line 611
        tmp___4 = is_reloc((enum symtype )3, symname);
        }
#line 611
        if (! tmp___4) {
#line 613
          goto switch_break;
        }
      }
      {
#line 615
      (*visit)(rel, sym);
      }
#line 616
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 618
      tmp___5 = rel_type(r_type);
#line 618
      die((char *)"Unsupported relocation type: %s (%d)\n", tmp___5, r_type);
      }
#line 620
      goto switch_break;
      bad: 
      {
#line 622
      symname = sym_name((char const   *)sym_strtab, sym);
#line 623
      tmp___6 = rel_type(r_type);
      }
#line 623
      if (shn_abs) {
#line 623
        tmp___7 = "absolute";
      } else {
#line 623
        tmp___7 = "relative";
      }
      {
#line 623
      die((char *)"Invalid %s %s relocation: %s\n", tmp___7, tmp___6, symname);
      }
      switch_break: /* CIL Label */ ;
      }
#line 561
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 544
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 629
  return;
}
}
#line 631 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/arch/x86/tools/relocs.c"
static void count_reloc(Elf32_Rel *rel , Elf32_Sym *sym ) 
{ 


  {
#line 633
  if ((rel->r_info & 255U) == 20U) {
#line 634
    reloc16_count ++;
  } else {
#line 636
    reloc_count ++;
  }
#line 637
  return;
}
}
#line 639 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/arch/x86/tools/relocs.c"
static void collect_reloc(Elf32_Rel *rel , Elf32_Sym *sym ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
#line 642
  if ((rel->r_info & 255U) == 20U) {
#line 643
    tmp = reloc16_idx;
#line 643
    reloc16_idx ++;
#line 643
    *(relocs16 + tmp) = (unsigned long )rel->r_offset;
  } else {
#line 645
    tmp___0 = reloc_idx;
#line 645
    reloc_idx ++;
#line 645
    *(relocs + tmp___0) = (unsigned long )rel->r_offset;
  }
#line 646
  return;
}
}
#line 648 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/arch/x86/tools/relocs.c"
static int cmp_relocs(void const   *va , void const   *vb ) 
{ 
  unsigned long const   *a ;
  unsigned long const   *b ;
  int tmp ;
  int tmp___0 ;

  {
#line 651
  a = (unsigned long const   *)va;
#line 651
  b = (unsigned long const   *)vb;
#line 652
  if (*a == *b) {
#line 652
    tmp___0 = 0;
  } else {
#line 652
    if (*a > *b) {
#line 652
      tmp = 1;
    } else {
#line 652
      tmp = -1;
    }
#line 652
    tmp___0 = tmp;
  }
#line 652
  return (tmp___0);
}
}
#line 655 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/arch/x86/tools/relocs.c"
static int write32(unsigned int v , FILE *f ) 
{ 
  unsigned char buf[4] ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 659
  put_unaligned_le32(v, (void *)(buf));
#line 660
  tmp___1 = fwrite((void const   */* __restrict  */)(buf), (size_t )1, (size_t )4,
                   (FILE */* __restrict  */)f);
  }
#line 660
  if (tmp___1 == 4UL) {
#line 660
    tmp___0 = 0;
  } else {
#line 660
    tmp___0 = -1;
  }
#line 660
  return (tmp___0);
}
}
#line 663 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/arch/x86/tools/relocs.c"
static void emit_relocs(int as_text , int use_real_mode ) 
{ 
  int i ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 667
  reloc_count = 0UL;
#line 668
  walk_relocs(& count_reloc, use_real_mode);
#line 669
  tmp = malloc(reloc_count * sizeof(*(relocs + 0)));
#line 669
  relocs = (unsigned long *)tmp;
  }
#line 670
  if (! relocs) {
    {
#line 671
    die((char *)"malloc of %d entries for relocs failed\n", reloc_count);
    }
  }
  {
#line 675
  tmp___0 = malloc(reloc16_count * sizeof(*(relocs + 0)));
#line 675
  relocs16 = (unsigned long *)tmp___0;
  }
#line 676
  if (! relocs16) {
    {
#line 677
    die((char *)"malloc of %d entries for relocs16 failed\n", reloc16_count);
    }
  }
  {
#line 681
  reloc_idx = 0UL;
#line 682
  walk_relocs(& collect_reloc, use_real_mode);
  }
#line 684
  if (reloc16_count) {
#line 684
    if (! use_real_mode) {
      {
#line 685
      die((char *)"Segment relocations found but --realmode not specified\n");
      }
    }
  }
  {
#line 688
  qsort((void *)relocs, reloc_count, sizeof(*(relocs + 0)), & cmp_relocs);
#line 689
  qsort((void *)relocs16, reloc16_count, sizeof(*(relocs16 + 0)), & cmp_relocs);
  }
#line 692
  if (as_text) {
    {
#line 696
    printf((char const   */* __restrict  */)".section \".data.reloc\",\"a\"\n");
#line 697
    printf((char const   */* __restrict  */)".balign 4\n");
    }
#line 698
    if (use_real_mode) {
      {
#line 699
      printf((char const   */* __restrict  */)"\t.long %lu\n", reloc16_count);
#line 700
      i = 0;
      }
      {
#line 700
      while (1) {
        while_continue: /* CIL Label */ ;
#line 700
        if (! ((unsigned long )i < reloc16_count)) {
#line 700
          goto while_break;
        }
        {
#line 701
        printf((char const   */* __restrict  */)"\t.long 0x%08lx\n", *(relocs16 + i));
#line 700
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 702
      printf((char const   */* __restrict  */)"\t.long %lu\n", reloc_count);
#line 703
      i = 0;
      }
      {
#line 703
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 703
        if (! ((unsigned long )i < reloc_count)) {
#line 703
          goto while_break___0;
        }
        {
#line 704
        printf((char const   */* __restrict  */)"\t.long 0x%08lx\n", *(relocs + i));
#line 703
        i ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 708
      printf((char const   */* __restrict  */)"\t.long 0x%08lx\n", 0UL);
#line 709
      i = 0;
      }
      {
#line 709
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 709
        if (! ((unsigned long )i < reloc_count)) {
#line 709
          goto while_break___1;
        }
        {
#line 710
        printf((char const   */* __restrict  */)"\t.long 0x%08lx\n", *(relocs + i));
#line 709
        i ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
#line 714
    printf((char const   */* __restrict  */)"\n");
    }
  } else
#line 717
  if (use_real_mode) {
    {
#line 718
    write32((unsigned int )reloc16_count, stdout);
#line 719
    i = 0;
    }
    {
#line 719
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 719
      if (! ((unsigned long )i < reloc16_count)) {
#line 719
        goto while_break___2;
      }
      {
#line 720
      write32((unsigned int )*(relocs16 + i), stdout);
#line 719
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 721
    write32((unsigned int )reloc_count, stdout);
#line 724
    i = 0;
    }
    {
#line 724
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 724
      if (! ((unsigned long )i < reloc_count)) {
#line 724
        goto while_break___3;
      }
      {
#line 725
      write32((unsigned int )*(relocs + i), stdout);
#line 724
      i ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  } else {
    {
#line 728
    write32(0U, stdout);
#line 731
    i = 0;
    }
    {
#line 731
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 731
      if (! ((unsigned long )i < reloc_count)) {
#line 731
        goto while_break___4;
      }
      {
#line 732
      write32((unsigned int )*(relocs + i), stdout);
#line 731
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 736
  return;
}
}
#line 738 "/home/june/repo/benchmarks/collector/temp/linux-goldfish-3.4.0/arch/x86/tools/relocs.c"
static void usage___0(void) 
{ 


  {
  {
#line 740
  die((char *)"relocs [--abs-syms|--abs-relocs|--text|--realmode] vmlinux\n");
  }
#line 741
  return;
}
}
