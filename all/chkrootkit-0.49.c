/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 39 "/usr/include/linux/hdlc/ioctl.h"
struct __anonstruct_sync_serial_settings_19 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
};
#line 39 "/usr/include/linux/hdlc/ioctl.h"
typedef struct __anonstruct_sync_serial_settings_19 sync_serial_settings;
#line 45 "/usr/include/linux/hdlc/ioctl.h"
struct __anonstruct_te1_settings_20 {
   unsigned int clock_rate ;
   unsigned int clock_type ;
   unsigned short loopback ;
   unsigned int slot_map ;
};
#line 45 "/usr/include/linux/hdlc/ioctl.h"
typedef struct __anonstruct_te1_settings_20 te1_settings;
#line 52 "/usr/include/linux/hdlc/ioctl.h"
struct __anonstruct_raw_hdlc_proto_21 {
   unsigned short encoding ;
   unsigned short parity ;
};
#line 52 "/usr/include/linux/hdlc/ioctl.h"
typedef struct __anonstruct_raw_hdlc_proto_21 raw_hdlc_proto;
#line 57 "/usr/include/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_22 {
   unsigned int t391 ;
   unsigned int t392 ;
   unsigned int n391 ;
   unsigned int n392 ;
   unsigned int n393 ;
   unsigned short lmi ;
   unsigned short dce ;
};
#line 57 "/usr/include/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_22 fr_proto;
#line 67 "/usr/include/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_23 {
   unsigned int dlci ;
};
#line 67 "/usr/include/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_23 fr_proto_pvc;
#line 71 "/usr/include/linux/hdlc/ioctl.h"
struct __anonstruct_fr_proto_pvc_info_24 {
   unsigned int dlci ;
   char master[16] ;
};
#line 71 "/usr/include/linux/hdlc/ioctl.h"
typedef struct __anonstruct_fr_proto_pvc_info_24 fr_proto_pvc_info;
#line 76 "/usr/include/linux/hdlc/ioctl.h"
struct __anonstruct_cisco_proto_25 {
   unsigned int interval ;
   unsigned int timeout ;
};
#line 76 "/usr/include/linux/hdlc/ioctl.h"
typedef struct __anonstruct_cisco_proto_25 cisco_proto;
#line 143 "/usr/include/linux/if.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 153 "/usr/include/linux/if.h"
union __anonunion_ifs_ifsu_28 {
   raw_hdlc_proto *raw_hdlc ;
   cisco_proto *cisco ;
   fr_proto *fr ;
   fr_proto_pvc *fr_pvc ;
   fr_proto_pvc_info *fr_pvc_info ;
   sync_serial_settings *sync ;
   te1_settings *te1 ;
};
#line 153 "/usr/include/linux/if.h"
struct if_settings {
   unsigned int type ;
   unsigned int size ;
   union __anonunion_ifs_ifsu_28 ifs_ifsu ;
};
#line 177 "/usr/include/linux/if.h"
union __anonunion_ifr_ifrn_29 {
   char ifrn_name[16] ;
};
#line 177 "/usr/include/linux/if.h"
union __anonunion_ifr_ifru_30 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16] ;
   char ifru_newname[16] ;
   void *ifru_data ;
   struct if_settings ifru_settings ;
};
#line 177 "/usr/include/linux/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_29 ifr_ifrn ;
   union __anonunion_ifr_ifru_30 ifr_ifru ;
};
#line 226 "/usr/include/linux/if.h"
union __anonunion_ifc_ifcu_31 {
   char *ifcu_buf ;
   struct ifreq *ifcu_req ;
};
#line 226 "/usr/include/linux/if.h"
struct ifconf {
   int ifc_len ;
   union __anonunion_ifc_ifcu_31 ifc_ifcu ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 55 "/home/june/repo/benchmarks/collector/temp/chkrootkit-0.49/ifpromisc.c"
struct interface {
   char name[16] ;
   short type ;
   short flags ;
   int index ;
};
#line 72 "/home/june/repo/benchmarks/collector/temp/chkrootkit-0.49/ifpromisc.c"
struct packet_info {
   int index ;
   int type ;
   int proto ;
   int inode ;
   char *cmd ;
   struct packet_info *next ;
};
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 260 "/usr/include/unistd.h"
typedef __pid_t pid_t;
#line 196 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef int int32_t;
#line 50 "/usr/include/x86_64-linux-gnu/bits/utmp.h"
struct exit_status {
   short e_termination ;
   short e_exit ;
};
#line 58 "/usr/include/x86_64-linux-gnu/bits/utmp.h"
struct __anonstruct_ut_tv_28 {
   int32_t tv_sec ;
   int32_t tv_usec ;
};
#line 58 "/usr/include/x86_64-linux-gnu/bits/utmp.h"
struct utmp {
   short ut_type ;
   pid_t ut_pid ;
   char ut_line[32] ;
   char ut_id[4] ;
   char ut_user[32] ;
   char ut_host[256] ;
   struct exit_status ut_exit ;
   int32_t ut_session ;
   struct __anonstruct_ut_tv_28 ut_tv ;
   int32_t ut_addr_v6[4] ;
   char __glibc_reserved[20] ;
};
#line 60 "/home/june/repo/benchmarks/collector/temp/chkrootkit-0.49/chkutmp.c"
struct ps_line {
   char ps_tty[32] ;
   char ps_user[32] ;
   char ps_args[256] ;
   int ps_pid ;
};
#line 66 "/home/june/repo/benchmarks/collector/temp/chkrootkit-0.49/chkutmp.c"
struct utmp_line {
   char ut_tty[32] ;
   int ut_pid ;
   int ut_type ;
};
#line 49 "/home/june/repo/benchmarks/collector/temp/chkrootkit-0.49/chkdirs.c"
struct dirinfolist {
   char dil_name[256] ;
   int dil_lc ;
   struct dirinfolist *dil_next ;
};
#line 138 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __id_t;
#line 104 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __id_t id_t;
#line 44 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef int __priority_which_t;
#line 80 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/utmp.h"
struct lastlog {
   int32_t ll_time ;
   char ll_line[32] ;
   char ll_host[256] ;
};
#line 78 "/home/june/repo/benchmarks/collector/temp/chkrootkit-0.49/chklastlog.c"
struct s_localpwd {
   int numentries ;
   uid_t *uid ;
   char **uname ;
};
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 165
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp )  __asm__("readdir64")  ;
#line 217 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf )  __asm__("stat64")  ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 283
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes )  __asm__("fopen64")  ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 289
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strspn)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 809
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__nonnull__(1,2), __leaf__)) readlink)(char const   * __restrict  __path ,
                                                                                                     char * __restrict  __buf ,
                                                                                                     size_t __len ) ;
#line 65 "/home/june/repo/benchmarks/collector/temp/chkrootkit-0.49/ifpromisc.c"
char *Release  =    (char *)"chkrootkit package";
#line 65 "/home/june/repo/benchmarks/collector/temp/chkrootkit-0.49/ifpromisc.c"
char *Version  =    (char *)"@(#) ifpromisc 0.9 (2007/06/15)";
#line 69 "/home/june/repo/benchmarks/collector/temp/chkrootkit-0.49/ifpromisc.c"
int skfd  =    -1;
#line 70 "/home/june/repo/benchmarks/collector/temp/chkrootkit-0.49/ifpromisc.c"
int q  =    0;
#line 86 "/home/june/repo/benchmarks/collector/temp/chkrootkit-0.49/ifpromisc.c"
static struct packet_info *proc_net_packet  =    (struct packet_info *)0;
#line 91 "/home/june/repo/benchmarks/collector/temp/chkrootkit-0.49/ifpromisc.c"
static void read_proc_net_packet(void) 
{ 
  FILE *proc ;
  char buf[80] ;
  int *tmp ;
  int type ;
  unsigned int proto ;
  int index___0 ;
  unsigned int inode ;
  struct packet_info *pi ;
  void *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 96
  proc = fopen((char const   */* __restrict  */)"/proc/net/packet", (char const   */* __restrict  */)"r");
  }
#line 97
  if (! proc) {
    {
#line 99
    tmp = __errno_location();
    }
#line 99
    if (*tmp != 2) {
      {
#line 101
      perror("opening /proc/net/packet");
      }
    }
#line 103
    return;
  }
  {
#line 107
  fgets((char */* __restrict  */)(buf), 80, (FILE */* __restrict  */)proc);
  }
  {
#line 108
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 108
    tmp___2 = fgets((char */* __restrict  */)(buf), 80, (FILE */* __restrict  */)proc);
    }
#line 108
    if (! tmp___2) {
#line 108
      goto while_break;
    }
    {
#line 110
    type = 0;
#line 111
    proto = 0U;
#line 112
    index___0 = 0;
#line 113
    inode = 0U;
#line 115
    tmp___1 = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%*p %*d %d %x   %d %*d %*u %*u %u",
                     & type, & proto, & index___0, & inode);
    }
#line 115
    if (tmp___1 == 4) {
      {
#line 120
      tmp___0 = malloc(sizeof(struct packet_info ));
#line 120
      pi = (struct packet_info *)tmp___0;
#line 121
      pi->type = type;
#line 122
      pi->proto = (int )proto;
#line 123
      pi->index = index___0;
#line 124
      pi->inode = (int )inode;
#line 125
      pi->cmd = (char *)0;
#line 127
      pi->next = proc_net_packet;
#line 128
      proc_net_packet = pi;
      }
    } else {
      {
#line 132
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cannot grok /proc/net/packet: %s",
              buf);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 136
  fclose(proc);
  }
#line 137
  return;
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/chkrootkit-0.49/ifpromisc.c"
static struct packet_info *find_packet_info(int inode ) 
{ 
  struct packet_info *p ;

  {
#line 143
  p = proc_net_packet;
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    if (! p) {
#line 143
      goto while_break;
    }
#line 145
    if (p->inode == inode) {
#line 147
      return (p);
    }
#line 143
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 150
  return ((struct packet_info *)((void *)0));
}
}
#line 156 "/home/june/repo/benchmarks/collector/temp/chkrootkit-0.49/ifpromisc.c"
static void walk_process(char *process ) 
{ 
  DIR *dir ;
  struct dirent *ent ;
  char path[1024] ;
  int tmp ;
  int *tmp___0 ;
  struct stat statbuf ;
  struct packet_info *info ;
  int tmp___1 ;
  int tmp___2 ;
  char link___0[1024] ;

  {
  {
#line 162
  tmp = snprintf((char */* __restrict  */)(path), sizeof(path), (char const   */* __restrict  */)"/proc/%s/fd",
                 process);
  }
#line 162
  if (tmp == -1) {
    {
#line 164
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"giant process name! %s\n",
            process);
    }
#line 165
    return;
  }
  {
#line 168
  dir = opendir((char const   *)(path));
  }
#line 168
  if ((unsigned long )dir == (unsigned long )((void *)0)) {
    {
#line 170
    tmp___0 = __errno_location();
    }
#line 170
    if (*tmp___0 != 2) {
      {
#line 171
      perror((char const   *)(path));
      }
    }
#line 172
    return;
  }
  {
#line 175
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 175
    ent = readdir(dir);
    }
#line 175
    if (! ent) {
#line 175
      goto while_break;
    }
    {
#line 180
    tmp___1 = snprintf((char */* __restrict  */)(path), sizeof(path), (char const   */* __restrict  */)"/proc/%s/fd/%s",
                       process, ent->d_name);
    }
#line 180
    if (tmp___1 == -1) {
      {
#line 183
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"giant fd name /proc/%s/fd/%s\n",
              process, ent->d_name);
      }
#line 185
      goto while_continue;
    }
    {
#line 188
    tmp___2 = stat((char const   */* __restrict  */)(path), (struct stat */* __restrict  */)(& statbuf));
    }
#line 188
    if (tmp___2 == -1) {
      {
#line 190
      perror((char const   *)(path));
      }
#line 191
      goto while_continue;
    }
#line 194
    if ((statbuf.st_mode & 61440U) == 49152U) {
      {
#line 194
      info = find_packet_info((int )statbuf.st_ino);
      }
#line 194
      if (info) {
        {
#line 199
        memset((void *)(link___0), 0, sizeof(link___0));
#line 202
        snprintf((char */* __restrict  */)(path), sizeof(path), (char const   */* __restrict  */)"/proc/%s/exe",
                 process);
#line 203
        readlink((char const   */* __restrict  */)(path), (char */* __restrict  */)(link___0),
                 sizeof(link___0) - 1UL);
#line 204
        info->cmd = strdup((char const   *)(link___0));
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 208
  closedir(dir);
  }
#line 209
  return;
}
}
#line 213 "/home/june/repo/benchmarks/collector/temp/chkrootkit-0.49/ifpromisc.c"
static void walk_processes(void) 
{ 
  DIR *dir ;
  struct dirent *ent ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 218
  dir = opendir("/proc");
  }
#line 218
  if ((unsigned long )dir == (unsigned long )((void *)0)) {
    {
#line 220
    perror("/proc");
    }
#line 221
    return;
  }
  {
#line 224
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 224
    ent = readdir(dir);
    }
#line 224
    if (! ent) {
#line 224
      goto while_break;
    }
    {
#line 227
    tmp = strspn((char const   *)(ent->d_name), "0123456789");
#line 227
    tmp___0 = strlen((char const   *)(ent->d_name));
    }
#line 227
    if (tmp == tmp___0) {
      {
#line 229
      walk_process(ent->d_name);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 233
  closedir(dir);
  }
#line 235
  return;
}
}
#line 238 "/home/june/repo/benchmarks/collector/temp/chkrootkit-0.49/ifpromisc.c"
static int has_packet_socket(int index___0 ) 
{ 
  struct packet_info *p ;

  {
#line 241
  p = proc_net_packet;
  {
#line 241
  while (1) {
    while_continue: /* CIL Label */ ;
#line 241
    if (! p) {
#line 241
      goto while_break;
    }
#line 243
    if (p->index == index___0) {
#line 245
      return (1);
    }
#line 241
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 248
  return (0);
}
}
#line 252 "/home/june/repo/benchmarks/collector/temp/chkrootkit-0.49/ifpromisc.c"
static void ife_print(struct interface *ptr ) 
{ 
  int promisc ;
  int has_packet ;
  int tmp ;
  struct packet_info *p ;

  {
  {
#line 255
  promisc = (int )ptr->flags & 256;
#line 256
  tmp = has_packet_socket(ptr->index);
#line 256
  has_packet = tmp;
  }
#line 258
  if (promisc) {
#line 258
    goto _L;
  } else
#line 258
  if (has_packet) {
    _L: /* CIL Label */ 
    {
#line 260
    printf((char const   */* __restrict  */)"%s:", ptr->name);
    }
#line 261
    if (promisc) {
      {
#line 262
      printf((char const   */* __restrict  */)" PROMISC");
      }
    }
#line 263
    if (has_packet) {
      {
#line 266
      printf((char const   */* __restrict  */)" PF_PACKET(");
#line 267
      p = proc_net_packet;
      }
#line 268
      if (p) {
        {
#line 270
        printf((char const   */* __restrict  */)"%s", p->cmd);
#line 272
        p = p->next;
        }
        {
#line 272
        while (1) {
          while_continue: /* CIL Label */ ;
#line 272
          if (! p) {
#line 272
            goto while_break;
          }
#line 274
          if (p->index == ptr->index) {
            {
#line 276
            printf((char const   */* __restrict  */)", %s", p->cmd);
            }
          }
#line 272
          p = p->next;
        }
        while_break: /* CIL Label */ ;
        }
      }
      {
#line 280
      printf((char const   */* __restrict  */)")");
      }
    }
    {
#line 282
    printf((char const   */* __restrict  */)"\n");
    }
  } else
#line 286
  if (! q) {
    {
#line 287
    printf((char const   */* __restrict  */)"%s: not promisc and no PF_PACKET sockets\n",
           ptr->name);
    }
  }
#line 300
  return;
}
}
#line 303 "/home/june/repo/benchmarks/collector/temp/chkrootkit-0.49/ifpromisc.c"
static int if_fetch(char *ifname , struct interface *ife ) 
{ 
  struct ifreq ifr ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 307
  memset((void *)((char *)ife), 0, sizeof(struct interface ));
#line 308
  strncpy((char */* __restrict  */)(ife->name), (char const   */* __restrict  */)ifname,
          sizeof(ife->name));
#line 310
  strncpy((char */* __restrict  */)(ifr.ifr_ifrn.ifrn_name), (char const   */* __restrict  */)ifname,
          sizeof(ifr.ifr_ifrn.ifrn_name));
#line 311
  tmp = ioctl(skfd, 35091UL, & ifr);
  }
#line 311
  if (tmp < 0) {
#line 312
    return (-1);
  }
  {
#line 313
  ife->flags = ifr.ifr_ifru.ifru_flags;
#line 317
  tmp___0 = ioctl(skfd, 35123UL, & ifr);
  }
#line 317
  if (tmp___0 < 0) {
#line 318
    return (-1);
  }
#line 319
  ife->index = ifr.ifr_ifru.ifru_ivalue;
#line 322
  return (0);
}
}
#line 325 "/home/june/repo/benchmarks/collector/temp/chkrootkit-0.49/ifpromisc.c"
static void if_print(void) 
{ 
  char buff[1024] ;
  struct interface ife ;
  struct ifconf ifc ;
  struct ifreq *ifr ;
  int i ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 333
  ifc.ifc_len = (int )sizeof(buff);
#line 334
  ifc.ifc_ifcu.ifcu_buf = buff;
#line 335
  tmp___1 = ioctl(skfd, 35090UL, & ifc);
  }
#line 335
  if (tmp___1 < 0) {
    {
#line 337
    tmp = __errno_location();
#line 337
    tmp___0 = strerror(*tmp);
#line 337
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"SIOCGIFCONF: %s\n",
            tmp___0);
    }
#line 338
    return;
  }
#line 341
  ifr = ifc.ifc_ifcu.ifcu_req;
#line 342
  i = (int )((unsigned long )ifc.ifc_len / sizeof(struct ifreq ));
  {
#line 342
  while (1) {
    while_continue: /* CIL Label */ ;
#line 342
    i --;
#line 342
    if (! (i >= 0)) {
#line 342
      goto while_break;
    }
    {
#line 344
    tmp___2 = if_fetch(ifr->ifr_ifrn.ifrn_name, & ife);
    }
#line 344
    if (tmp___2 < 0) {
      {
#line 347
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: unknown interface.\n",
              ifr->ifr_ifrn.ifrn_name);
      }
#line 349
      goto __Cont;
    }
    {
#line 351
    tmp___3 = memcmp((void const   *)(ifr->ifr_ifrn.ifrn_name), (void const   *)"lo",
                     (size_t )2);
    }
#line 351
    if (! tmp___3) {
#line 352
      goto __Cont;
    }
    {
#line 353
    ife_print(& ife);
    }
    __Cont: /* CIL Label */ 
#line 342
    ifr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 355
  return;
}
}
#line 357 "/home/june/repo/benchmarks/collector/temp/chkrootkit-0.49/ifpromisc.c"
int main(int argc , char **argv ) 
{ 
  int tmp ;

  {
#line 359
  if (argc == 2) {
    {
#line 359
    tmp = memcmp((void const   *)*(argv + 1), (void const   *)"-q", (size_t )2);
    }
#line 359
    if (! tmp) {
#line 360
      q ++;
    }
  }
  {
#line 363
  skfd = socket(2, 2, 0);
  }
#line 363
  if (skfd < 0) {
    {
#line 364
    perror("socket");
#line 365
    exit(-1);
    }
  }
  {
#line 368
  read_proc_net_packet();
#line 369
  walk_processes();
#line 372
  if_print();
#line 373
  close(skfd);
#line 374
  exit(0);
  }
}
}
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/chkrootkit-0.49/strings.c"
unsigned char *filebuf(FILE *pf , int *sz ) 
{ 
  struct stat buf ;
  unsigned char *cdata ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 35
  tmp = fileno(pf);
#line 35
  tmp___0 = fstat(tmp, & buf);
  }
#line 35
  if (tmp___0 < 0) {
    {
#line 36
    perror("fstat");
#line 37
    exit(1);
    }
  }
#line 40
  *sz = (int )buf.st_size;
#line 41
  if (*sz == 0) {
#line 41
    *sz = 4194304;
  }
  {
#line 43
  tmp___1 = malloc((size_t )(*sz + 1));
#line 43
  cdata = (unsigned char *)tmp___1;
  }
#line 43
  if ((unsigned long )cdata == (unsigned long )((void *)0)) {
    {
#line 44
    perror("malloc");
#line 45
    exit(1);
    }
  }
#line 47
  return (cdata);
}
}
#line 55 "/home/june/repo/benchmarks/collector/temp/chkrootkit-0.49/strings.c"
static char printme[1024]  ;
#line 54 "/home/june/repo/benchmarks/collector/temp/chkrootkit-0.49/strings.c"
void strings(FILE *pf ) 
{ 
  int sz ;
  unsigned char *cdata ;
  int nread ;
  int printmeindex ;
  size_t tmp ;
  int i ;
  unsigned char c ;
  int isprintable ;
  int iseol ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 60
  cdata = filebuf(pf, & sz);
#line 61
  tmp = fread((void */* __restrict  */)cdata, (size_t )1, (size_t )sz, (FILE */* __restrict  */)pf);
#line 61
  nread = (int )tmp;
#line 62
  printmeindex = 0;
  }
#line 63
  if (nread > 0) {
#line 68
    i = 0;
    {
#line 68
    while (1) {
      while_continue: /* CIL Label */ ;
#line 68
      if (! (i < nread)) {
#line 68
        goto while_break;
      }
      {
#line 69
      c = *(cdata + i);
#line 70
      tmp___0 = __ctype_b_loc();
#line 70
      isprintable = (int )((int const   )*(*tmp___0 + (int )c) & 16384);
#line 71
      iseol = 0;
      }
#line 72
      if ((int )c == 0) {
#line 72
        iseol = 1;
      } else
#line 72
      if ((int )c == 10) {
#line 72
        iseol = 1;
      } else
#line 72
      if ((unsigned long )printmeindex >= sizeof(printme) - 1UL) {
#line 72
        iseol = 1;
      }
#line 73
      if (iseol) {
#line 73
        goto _L;
      } else
#line 73
      if (! isprintable) {
        _L: /* CIL Label */ 
#line 74
        if (printmeindex > 3) {
#line 74
          if (iseol) {
            {
#line 75
            tmp___1 = printmeindex;
#line 75
            printmeindex ++;
#line 75
            printme[tmp___1] = (char)0;
#line 76
            printf((char const   */* __restrict  */)"%s\n", printme);
#line 77
            printmeindex = 0;
            }
          }
        }
      } else
#line 80
      if (isprintable) {
#line 81
        tmp___2 = printmeindex;
#line 81
        printmeindex ++;
#line 81
        printme[tmp___2] = (char )c;
      }
#line 68
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 85
  if (printmeindex > 3) {
    {
#line 86
    tmp___3 = printmeindex;
#line 86
    printmeindex ++;
#line 86
    printme[tmp___3] = (char)0;
#line 87
    printf((char const   */* __restrict  */)"%s\n", printme);
#line 88
    printmeindex = 0;
    }
  }
  {
#line 90
  free((void *)cdata);
  }
#line 91
  return;
}
}
#line 102
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 873 "/usr/include/stdio.h"
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 879
extern int pclose(FILE *__stream ) ;
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 71 "/home/june/repo/benchmarks/collector/temp/chkrootkit-0.49/chkutmp.c"
static char *cmd[2]  = {      (char *)"ps -ef -o \"tty,pid,ruser,args\"",      (char *)"ps ax -o \"tty,pid,ruser,args\""};
#line 75
int fetchps(struct ps_line *psl_p ) ;
#line 76
int fetchutmp(struct utmp_line *utl_p ) ;
#line 78 "/home/june/repo/benchmarks/collector/temp/chkrootkit-0.49/chkutmp.c"
int fetchps(struct ps_line *psl_p ) 
{ 
  FILE *ps_fp ;
  char line[1025] ;
  char pid[12] ;
  char *s ;
  char *d ;
  struct ps_line *curp ;
  struct ps_line *endp ;
  int i ;
  int x ;
  unsigned short const   **tmp ;
  char *tmp___0 ;
  char tmp___1 ;
  char *tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  char *tmp___5 ;
  char tmp___6 ;
  char *tmp___7 ;
  unsigned short const   **tmp___8 ;
  unsigned short const   **tmp___9 ;
  char *tmp___10 ;
  char tmp___11 ;
  char *tmp___12 ;
  unsigned short const   **tmp___13 ;
  char *tmp___14 ;
  char tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;

  {
  {
#line 83
  curp = psl_p + 0;
#line 84
  endp = psl_p + 4095;
#line 87
  i = 0;
#line 88
  ps_fp = popen((char const   *)cmd[1], "r");
  }
#line 88
  if ((unsigned long )ps_fp != (unsigned long )((void *)0)) {
    {
#line 89
    fgets((char */* __restrict  */)(line), 1024, (FILE */* __restrict  */)ps_fp);
    }
    {
#line 90
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 90
      tmp___17 = fgets((char */* __restrict  */)(line), 1024, (FILE */* __restrict  */)ps_fp);
      }
#line 90
      if (! tmp___17) {
#line 90
        goto while_break;
      }
#line 91
      s = line;
#line 92
      if ((int )*s != 63) {
#line 92
        if ((unsigned long )curp <= (unsigned long )endp) {
#line 94
          d = curp->ps_tty;
#line 95
          x = 0;
          {
#line 95
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 95
            tmp = __ctype_b_loc();
            }
#line 95
            if ((int const   )*(*tmp + (int )*s) & 8192) {
#line 95
              goto while_break___0;
            } else {
#line 95
              tmp___0 = d;
#line 95
              d ++;
#line 95
              tmp___2 = s;
#line 95
              s ++;
#line 95
              tmp___1 = *tmp___2;
#line 95
              *tmp___0 = tmp___1;
#line 95
              if (tmp___1) {
#line 95
                if (! (x <= 32)) {
#line 95
                  goto while_break___0;
                }
              } else {
#line 95
                goto while_break___0;
              }
            }
#line 95
            x ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 97
          *d = (char )'\000';
          {
#line 98
          while (1) {
            while_continue___1: /* CIL Label */ ;
            {
#line 98
            tmp___3 = __ctype_b_loc();
            }
#line 98
            if (! ((int const   )*(*tmp___3 + (int )*s) & 8192)) {
#line 98
              goto while_break___1;
            }
#line 99
            s ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 100
          d = pid;
#line 101
          x = 0;
          {
#line 101
          while (1) {
            while_continue___2: /* CIL Label */ ;
            {
#line 101
            tmp___4 = __ctype_b_loc();
            }
#line 101
            if ((int const   )*(*tmp___4 + (int )*s) & 8192) {
#line 101
              goto while_break___2;
            } else {
#line 101
              tmp___5 = d;
#line 101
              d ++;
#line 101
              tmp___7 = s;
#line 101
              s ++;
#line 101
              tmp___6 = *tmp___7;
#line 101
              *tmp___5 = tmp___6;
#line 101
              if (tmp___6) {
#line 101
                if (! (x <= 32)) {
#line 101
                  goto while_break___2;
                }
              } else {
#line 101
                goto while_break___2;
              }
            }
#line 101
            x ++;
          }
          while_break___2: /* CIL Label */ ;
          }
          {
#line 103
          *d = (char )'\000';
#line 104
          curp->ps_pid = atoi((char const   *)(pid));
          }
          {
#line 105
          while (1) {
            while_continue___3: /* CIL Label */ ;
            {
#line 105
            tmp___8 = __ctype_b_loc();
            }
#line 105
            if (! ((int const   )*(*tmp___8 + (int )*s) & 8192)) {
#line 105
              goto while_break___3;
            }
#line 106
            s ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 107
          d = curp->ps_user;
#line 108
          x = 0;
          {
#line 108
          while (1) {
            while_continue___4: /* CIL Label */ ;
            {
#line 108
            tmp___9 = __ctype_b_loc();
            }
#line 108
            if ((int const   )*(*tmp___9 + (int )*s) & 8192) {
#line 108
              goto while_break___4;
            } else {
#line 108
              tmp___10 = d;
#line 108
              d ++;
#line 108
              tmp___12 = s;
#line 108
              s ++;
#line 108
              tmp___11 = *tmp___12;
#line 108
              *tmp___10 = tmp___11;
#line 108
              if (tmp___11) {
#line 108
                if (! (x <= 32)) {
#line 108
                  goto while_break___4;
                }
              } else {
#line 108
                goto while_break___4;
              }
            }
#line 108
            x ++;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 110
          *d = (char )'\000';
#line 111
          d = curp->ps_args;
          {
#line 112
          while (1) {
            while_continue___5: /* CIL Label */ ;
            {
#line 112
            tmp___13 = __ctype_b_loc();
            }
#line 112
            if (! ((int const   )*(*tmp___13 + (int )*s) & 8192)) {
#line 112
              goto while_break___5;
            }
#line 113
            s ++;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 114
          x = 0;
          {
#line 114
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 114
            tmp___14 = d;
#line 114
            d ++;
#line 114
            tmp___16 = s;
#line 114
            s ++;
#line 114
            tmp___15 = *tmp___16;
#line 114
            *tmp___14 = tmp___15;
#line 114
            if (tmp___15) {
#line 114
              if (! (x <= 256)) {
#line 114
                goto while_break___6;
              }
            } else {
#line 114
              goto while_break___6;
            }
#line 114
            x ++;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 116
          i ++;
#line 117
          curp ++;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 120
    pclose(ps_fp);
    }
  } else {
    {
#line 122
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nfailed running \'ps\' !\n");
#line 123
    exit(1);
    }
  }
#line 125
  return (i);
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/chkrootkit-0.49/chkutmp.c"
int fetchutmp(struct utmp_line *utl_p ) 
{ 
  struct utmp ut ;
  struct utmp_line *curp ;
  struct utmp_line *endp ;
  int i ;
  int f ;
  int del_cnt ;
  int sz_ut ;
  size_t tmp ;
  ssize_t tmp___0 ;

  {
  {
#line 135
  curp = utl_p + 0;
#line 136
  endp = utl_p + 4095;
#line 139
  del_cnt = 0;
#line 139
  i = del_cnt;
#line 140
  f = open("/var/run/utmp", 0);
  }
#line 140
  if (f > 0) {
#line 144
    sz_ut = (int )sizeof(struct utmp );
    {
#line 147
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 147
      tmp___0 = read(f, (void *)(& ut), (size_t )sz_ut);
      }
#line 147
      if (tmp___0 > 0L) {
#line 147
        if (! ((unsigned long )curp <= (unsigned long )endp)) {
#line 147
          goto while_break;
        }
      } else {
#line 147
        goto while_break;
      }
#line 149
      if (ut.ut_tv.tv_sec == 0) {
#line 150
        del_cnt ++;
      }
      {
#line 152
      tmp = strlen((char const   *)(ut.ut_user));
      }
#line 152
      if (tmp > 0UL) {
        {
#line 153
        strncpy((char */* __restrict  */)(curp->ut_tty), (char const   */* __restrict  */)(ut.ut_line),
                (size_t )32);
#line 154
        curp->ut_pid = ut.ut_pid;
#line 155
        curp->ut_type = (int )ut.ut_type;
#line 156
        i ++;
#line 157
        curp ++;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 160
    close(f);
    }
#line 161
    if (del_cnt > 0) {
      {
#line 162
      printf((char const   */* __restrict  */)"=> possibly %d deletion(s) detected in %s !\n",
             del_cnt, "/var/run/utmp");
      }
    }
  } else {
    {
#line 165
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nfailed opening utmp !\n");
#line 166
    exit(1);
    }
  }
#line 168
  return (i);
}
}
#line 263 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf ) ;
#line 497 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 511
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getcwd)(char *__buf ,
                                                                               size_t __size ) ;
#line 71 "/usr/include/getopt.h"
extern int optind ;
#line 76
extern int opterr ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/chkrootkit-0.49/chkdirs.c"
void usage(void) 
{ 


  {
  {
#line 58
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"chkdirs [-n] dir ...\n");
#line 59
  exit(255);
  }
}
}
#line 62 "/home/june/repo/benchmarks/collector/temp/chkrootkit-0.49/chkdirs.c"
char *make_pathname(char *path , char *dir , char **buffer ) 
{ 
  int plen ;
  int pathname_len ;
  int bufsize ;
  int offs ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 66
  tmp = strlen((char const   *)path);
#line 66
  plen = (int )tmp;
#line 67
  tmp___0 = strlen((char const   *)dir);
#line 67
  pathname_len = (int )(((size_t )plen + tmp___0) + 2UL);
  }
#line 69
  if (! *buffer) {
#line 69
    goto _L;
  } else
#line 69
  if (sizeof(*buffer) < (unsigned long )pathname_len) {
    _L: /* CIL Label */ 
#line 70
    if (buffer) {
      {
#line 70
      free((void *)*buffer);
      }
    }
#line 71
    if (pathname_len > 4096) {
#line 71
      bufsize = pathname_len;
    } else {
#line 71
      bufsize = 4096;
    }
    {
#line 72
    tmp___2 = malloc((size_t )bufsize);
#line 72
    tmp___1 = (char *)tmp___2;
#line 72
    *buffer = tmp___1;
    }
#line 72
    if (! tmp___1) {
#line 73
      return ((char *)((void *)0));
    }
  }
#line 77
  if ((int )*(dir + 0) == 47) {
#line 78
    offs = 0;
  } else {
    {
#line 81
    strncpy((char */* __restrict  */)*buffer, (char const   */* __restrict  */)path,
            (size_t )bufsize);
    }
#line 82
    if ((int )*(*buffer + (plen - 1)) == 47) {
#line 83
      offs = plen;
    } else {
#line 86
      *(*buffer + plen) = (char )'/';
#line 87
      offs = plen + 1;
    }
  }
  {
#line 90
  strncpy((char */* __restrict  */)(*buffer + offs), (char const   */* __restrict  */)dir,
          (size_t )(bufsize - offs));
  }
#line 91
  return (*buffer);
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/chkrootkit-0.49/chkdirs.c"
int check_dir(char *dir , char *path , int linkcount , int norecurse ) 
{ 
  int diff ;
  int plen ;
  int buflen ;
  int numdirs ;
  char *curpath ;
  char *fullpath ;
  DIR *dirhandle ;
  struct dirent *finfo ;
  struct dirinfolist *dl ;
  struct dirinfolist *dptr ;
  struct stat statinfo ;
  int *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  void *tmp___8 ;
  size_t tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  int *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  int *tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int *tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  int *tmp___26 ;
  char *tmp___27 ;
  void *tmp___28 ;
  int *tmp___29 ;
  char *tmp___30 ;
  int tmp___31 ;

  {
#line 96
  diff = -1;
#line 109
  if (! path) {
#line 109
    goto _L;
  } else {
    {
#line 109
    tmp___9 = strlen((char const   *)path);
#line 109
    plen = (int )tmp___9;
    }
#line 109
    if (plen) {
      {
#line 129
      tmp___8 = malloc((size_t )(plen + 1));
#line 129
      curpath = (char *)tmp___8;
      }
#line 129
      if (! curpath) {
        {
#line 130
        tmp___6 = __errno_location();
#line 130
        tmp___7 = strerror(*tmp___6);
#line 130
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"malloc() failed: %s\n",
                tmp___7);
        }
#line 131
        return (-1);
      }
      {
#line 133
      strncpy((char */* __restrict  */)curpath, (char const   */* __restrict  */)path,
              (size_t )(plen + 1));
      }
    } else {
      _L: /* CIL Label */ 
#line 110
      buflen = 4096;
      retry: 
      {
#line 112
      tmp___1 = malloc((size_t )buflen);
#line 112
      curpath = (char *)tmp___1;
      }
#line 112
      if (! curpath) {
        {
#line 113
        tmp = __errno_location();
#line 113
        tmp___0 = strerror(*tmp);
#line 113
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"malloc() failed: %s\n",
                tmp___0);
        }
#line 114
        return (-1);
      }
      {
#line 116
      tmp___5 = getcwd(curpath, (size_t )buflen);
      }
#line 116
      if (! tmp___5) {
        {
#line 117
        tmp___4 = __errno_location();
        }
#line 117
        if (*tmp___4 == 34) {
          {
#line 118
          free((void *)curpath);
#line 119
          buflen *= 2;
          }
#line 120
          goto retry;
        } else {
          {
#line 123
          tmp___2 = __errno_location();
#line 123
          tmp___3 = strerror(*tmp___2);
#line 123
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getcwd() failed: %s\n",
                  tmp___3);
          }
#line 124
          return (-1);
        }
      }
    }
  }
  {
#line 140
  fullpath = (char *)((void *)0);
#line 141
  tmp___12 = make_pathname(curpath, dir, & fullpath);
  }
#line 141
  if (! tmp___12) {
    {
#line 142
    tmp___10 = __errno_location();
#line 142
    tmp___11 = strerror(*tmp___10);
#line 142
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"make_pathname() failed: %s\n",
            tmp___11);
#line 143
    free((void *)curpath);
    }
#line 144
    return (-1);
  }
  {
#line 147
  tmp___15 = chdir((char const   *)dir);
  }
#line 147
  if (tmp___15) {
    {
#line 148
    tmp___13 = __errno_location();
#line 148
    tmp___14 = strerror(*tmp___13);
#line 148
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"chdir(%s): %s\n",
            fullpath, tmp___14);
#line 149
    free((void *)curpath);
#line 150
    free((void *)fullpath);
    }
#line 151
    return (-1);
  }
#line 158
  if (! linkcount) {
    {
#line 159
    tmp___18 = lstat((char const   */* __restrict  */)".", (struct stat */* __restrict  */)(& statinfo));
    }
#line 159
    if (tmp___18) {
      {
#line 160
      tmp___16 = __errno_location();
#line 160
      tmp___17 = strerror(*tmp___16);
#line 160
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lstat(%s): %s\n",
              fullpath, tmp___17);
      }
#line 161
      goto abort;
    }
#line 163
    linkcount = (int )statinfo.st_nlink;
  }
  {
#line 166
  dirhandle = opendir(".");
  }
#line 166
  if (! dirhandle) {
    {
#line 167
    tmp___19 = __errno_location();
#line 167
    tmp___20 = strerror(*tmp___19);
#line 167
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"opendir(%s): %s\n",
            fullpath, tmp___20);
    }
#line 168
    goto abort;
  }
#line 171
  numdirs = 0;
#line 172
  dl = (struct dirinfolist *)((void *)0);
  {
#line 173
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 173
    finfo = readdir(dirhandle);
    }
#line 173
    if (! finfo) {
#line 173
      goto while_break;
    }
    {
#line 174
    tmp___21 = strcmp((char const   *)(finfo->d_name), ".");
    }
#line 174
    if (tmp___21) {
      {
#line 174
      tmp___22 = strcmp((char const   *)(finfo->d_name), "..");
      }
#line 174
      if (! tmp___22) {
#line 175
        goto while_continue;
      }
    } else {
#line 175
      goto while_continue;
    }
    {
#line 177
    tmp___25 = lstat((char const   */* __restrict  */)(finfo->d_name), (struct stat */* __restrict  */)(& statinfo));
    }
#line 177
    if (tmp___25) {
      {
#line 178
      tmp___23 = __errno_location();
#line 178
      tmp___24 = strerror(*tmp___23);
#line 178
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"lstat(%s/%s): %s\n",
              fullpath, finfo->d_name, tmp___24);
#line 180
      closedir(dirhandle);
      }
#line 181
      goto abort;
    }
#line 184
    if ((statinfo.st_mode & 61440U) == 16384U) {
#line 185
      numdirs ++;
#line 187
      if (norecurse) {
#line 187
        goto while_continue;
      }
#line 193
      if (statinfo.st_nlink > 2UL) {
        {
#line 194
        dptr = dl;
#line 195
        tmp___28 = malloc(sizeof(struct dirinfolist ));
#line 195
        dl = (struct dirinfolist *)tmp___28;
        }
#line 195
        if (! dl) {
          {
#line 196
          tmp___26 = __errno_location();
#line 196
          tmp___27 = strerror(*tmp___26);
#line 196
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"malloc() failed: %s\n",
                  tmp___27);
#line 197
          norecurse = 1;
          }
          {
#line 198
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 198
            if (! dptr) {
#line 198
              goto while_break___0;
            }
            {
#line 199
            dl = dptr->dil_next;
#line 200
            free((void *)dptr);
#line 201
            dptr = dl;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
#line 203
          goto while_continue;
        }
        {
#line 206
        strncpy((char */* __restrict  */)(dl->dil_name), (char const   */* __restrict  */)(finfo->d_name),
                sizeof(dl->dil_name));
#line 207
        dl->dil_lc = (int )statinfo.st_nlink;
#line 208
        dl->dil_next = dptr;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 212
  closedir(dirhandle);
#line 215
  diff = (linkcount - numdirs) - 2;
  }
#line 216
  if (diff) {
    {
#line 216
    printf((char const   */* __restrict  */)"%d\t%s\n", diff, fullpath);
    }
  }
  {
#line 219
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 219
    if (! dl) {
#line 219
      goto while_break___1;
    }
    {
#line 220
    check_dir(dl->dil_name, fullpath, dl->dil_lc, norecurse);
#line 221
    dptr = dl->dil_next;
#line 222
    free((void *)dl);
#line 223
    dl = dptr;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  abort: 
  {
#line 227
  tmp___31 = chdir((char const   *)curpath);
  }
#line 227
  if (tmp___31) {
    {
#line 228
    tmp___29 = __errno_location();
#line 228
    tmp___30 = strerror(*tmp___29);
#line 228
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Final chdir(%s) failed (%s) -- EXIT!\n",
            curpath, tmp___30);
#line 230
    exit(255);
    }
  }
  {
#line 232
  free((void *)fullpath);
#line 233
  free((void *)curpath);
  }
#line 234
  return (diff);
}
}
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 150 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 584 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execlp)(char const   *__file ,
                                                                                               char const   *__arg 
                                                                                               , ...) ;
#line 127 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 93 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getpriority)(__priority_which_t __which ,
                                                                                  id_t __who ) ;
#line 94 "/home/june/repo/benchmarks/collector/temp/chkrootkit-0.49/chkproc.c"
static char *ps_cmds[4]  = {      (char *)"ps -edf",      (char *)"ps auxw",      (char *)"ps mauxw 2>&1 ",      (char *)"ps auxw -T|tr -s \' \'|cut -d\' \' -f2-"};
#line 101 "/home/june/repo/benchmarks/collector/temp/chkrootkit-0.49/chkproc.c"
int psproc[100000]  ;
#line 102 "/home/june/repo/benchmarks/collector/temp/chkrootkit-0.49/chkproc.c"
int dirproc[100000]  ;
#line 104 "/home/june/repo/benchmarks/collector/temp/chkrootkit-0.49/chkproc.c"
int isathread[100000]  ;
#line 114 "/home/june/repo/benchmarks/collector/temp/chkrootkit-0.49/chkproc.c"
char *readline(char *s , int size , FILE *stream ) 
{ 
  char *rv ;
  char *tmp ;
  char buf[1024] ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 116
  tmp = fgets((char */* __restrict  */)s, size, (FILE */* __restrict  */)stream);
#line 116
  rv = tmp;
#line 118
  tmp___1 = strlen((char const   *)s);
  }
#line 118
  if (tmp___1 == (size_t )(size - 1)) {
#line 118
    if ((int )*(s + (size - 1)) != 10) {
      {
#line 121
      fgets((char */* __restrict  */)(buf), 1024, (FILE */* __restrict  */)stream);
      }
      {
#line 122
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 122
        tmp___0 = strlen((char const   *)(buf));
        }
#line 122
        if (tmp___0 == 1023UL) {
#line 122
          if (! ((int )buf[1023] != 10)) {
#line 122
            goto while_break;
          }
        } else {
#line 122
          goto while_break;
        }
        {
#line 124
        fgets((char */* __restrict  */)(buf), 1024, (FILE */* __restrict  */)stream);
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 128
  return (rv);
}
}
#line 334 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 432
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) alarm)(unsigned int __seconds ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 72 "/usr/include/pwd.h"
extern void setpwent(void) ;
#line 78
extern void endpwent(void) ;
#line 84
extern struct passwd *getpwent(void) ;
#line 73 "/home/june/repo/benchmarks/collector/temp/chkrootkit-0.49/chklastlog.c"
long total_wtmp_bytes_read  =    0L;
#line 74 "/home/june/repo/benchmarks/collector/temp/chkrootkit-0.49/chklastlog.c"
size_t wtmp_file_size  ;
#line 75 "/home/june/repo/benchmarks/collector/temp/chkrootkit-0.49/chklastlog.c"
uid_t *uid  ;
#line 76
void read_status(void) ;
#line 85
int nonuser(struct utmp utmp_ent ) ;
#line 87
struct s_localpwd *read_pwd(void) ;
#line 88
void free_results(struct s_localpwd *localpwd ) ;
#line 89
uid_t *localgetpwnam(struct s_localpwd *localpwd , char *username ) ;
#line 90
int getslot(struct s_localpwd *localpwd , uid_t uid___0 ) ;
#line 206 "/home/june/repo/benchmarks/collector/temp/chkrootkit-0.49/chklastlog.c"
int nonuser(struct utmp utmp_ent ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 208
  tmp = memcmp((void const   *)(utmp_ent.ut_user), (void const   *)"shutdown", sizeof("shutdown"));
  }
#line 208
  if (tmp) {
#line 208
    tmp___0 = 0;
  } else {
#line 208
    tmp___0 = 1;
  }
#line 208
  return (tmp___0);
}
}
#line 214 "/home/june/repo/benchmarks/collector/temp/chkrootkit-0.49/chklastlog.c"
static long last_total_bytes_read  =    0L;
#line 212 "/home/june/repo/benchmarks/collector/temp/chkrootkit-0.49/chklastlog.c"
void read_status(void) 
{ 
  double remaining_time ;
  int diff ;

  {
#line 217
  diff = (int )(total_wtmp_bytes_read - last_total_bytes_read);
#line 218
  if (diff == 0) {
#line 218
    diff = 1;
  }
  {
#line 219
  remaining_time = (double )(((wtmp_file_size - (size_t )total_wtmp_bytes_read) * 5UL) / (size_t )diff);
#line 220
  last_total_bytes_read = total_wtmp_bytes_read;
#line 222
  printf((char const   */* __restrict  */)"Remaining time: %6.2f seconds\n", remaining_time);
  }
#line 228
  return;
}
}
#line 230 "/home/june/repo/benchmarks/collector/temp/chkrootkit-0.49/chklastlog.c"
struct s_localpwd *read_pwd(void) 
{ 
  struct passwd *pwdent ;
  int numentries ;
  int i ;
  struct s_localpwd *localpwd ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;

  {
  {
#line 232
  numentries = 0;
#line 232
  i = 0;
#line 235
  setpwent();
  }
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 236
    pwdent = getpwent();
    }
#line 236
    if (! pwdent) {
#line 236
      goto while_break;
    }
#line 237
    numentries ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 239
  endpwent();
#line 240
  tmp = malloc(sizeof(struct s_localpwd ));
#line 240
  localpwd = (struct s_localpwd *)tmp;
#line 241
  localpwd->numentries = numentries;
#line 242
  tmp___0 = malloc((size_t )numentries * sizeof(uid_t ));
#line 242
  localpwd->uid = (uid_t *)tmp___0;
#line 243
  tmp___1 = malloc((size_t )numentries * sizeof(char *));
#line 243
  localpwd->uname = (char **)tmp___1;
#line 244
  i = 0;
  }
  {
#line 244
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 244
    if (! (i < numentries)) {
#line 244
      goto while_break___0;
    }
    {
#line 245
    tmp___2 = malloc(30UL * sizeof(char ));
#line 245
    *(localpwd->uname + i) = (char *)tmp___2;
#line 244
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 247
  i = 0;
#line 248
  setpwent();
  }
  {
#line 249
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 249
    pwdent = getpwent();
    }
#line 249
    if (pwdent) {
#line 249
      if (! (i < numentries)) {
#line 249
        goto while_break___1;
      }
    } else {
#line 249
      goto while_break___1;
    }
    {
#line 250
    *(localpwd->uid + i) = pwdent->pw_uid;
#line 251
    tmp___6 = strlen((char const   *)pwdent->pw_name);
    }
#line 251
    if (tmp___6 > 29UL) {
#line 251
      tmp___5 = (size_t )29;
    } else {
      {
#line 251
      tmp___4 = strlen((char const   *)pwdent->pw_name);
#line 251
      tmp___5 = tmp___4 + 1UL;
      }
    }
    {
#line 251
    memcpy((void */* __restrict  */)*(localpwd->uname + i), (void const   */* __restrict  */)pwdent->pw_name,
           tmp___5);
#line 252
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 254
  endpwent();
  }
#line 255
  return (localpwd);
}
}
#line 258 "/home/june/repo/benchmarks/collector/temp/chkrootkit-0.49/chklastlog.c"
void free_results(struct s_localpwd *localpwd ) 
{ 
  int i ;

  {
  {
#line 260
  free((void *)localpwd->uid);
#line 261
  i = 0;
  }
  {
#line 261
  while (1) {
    while_continue: /* CIL Label */ ;
#line 261
    if (! (i < localpwd->numentries)) {
#line 261
      goto while_break;
    }
    {
#line 262
    free((void *)*(localpwd->uname + i));
#line 261
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 264
  free((void *)localpwd->uname);
#line 265
  free((void *)localpwd);
  }
#line 266
  return;
}
}
#line 268 "/home/june/repo/benchmarks/collector/temp/chkrootkit-0.49/chklastlog.c"
uid_t *localgetpwnam(struct s_localpwd *localpwd , char *username ) 
{ 
  int i ;
  size_t len ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
#line 272
  i = 0;
  {
#line 272
  while (1) {
    while_continue: /* CIL Label */ ;
#line 272
    if (! (i < localpwd->numentries)) {
#line 272
      goto while_break;
    }
    {
#line 273
    tmp___1 = strlen((char const   *)username);
    }
#line 273
    if (tmp___1 > 29UL) {
#line 273
      len = (size_t )30;
    } else {
      {
#line 273
      tmp___0 = strlen((char const   *)username);
#line 273
      len = tmp___0 + 1UL;
      }
    }
    {
#line 274
    tmp___2 = memcmp((void const   *)username, (void const   *)*(localpwd->uname + i),
                     len);
    }
#line 274
    if (! tmp___2) {
#line 275
      return (localpwd->uid + i);
    }
#line 272
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 278
  return ((uid_t *)((void *)0));
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/chkrootkit-0.49/chklastlog.c"
int getslot(struct s_localpwd *localpwd , uid_t uid___0 ) 
{ 
  int i ;

  {
#line 285
  i = 0;
  {
#line 285
  while (1) {
    while_continue: /* CIL Label */ ;
#line 285
    if (! (i < localpwd->numentries)) {
#line 285
      goto while_break;
    }
#line 287
    if (*(localpwd->uid + i) == uid___0) {
#line 288
      return (i);
    }
#line 285
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 290
  return (-1);
}
}
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 264 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ctime)(time_t const   *__timer ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/chkrootkit-0.49/chkwtmp.c"
void printit(int counter , long start , long end ) 
{ 
  char buffer[30] ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 48
  printf((char const   */* __restrict  */)"%d deletion(s) between ", counter);
#line 49
  tmp = ctime((time_t const   *)(& start));
#line 49
  strncpy((char */* __restrict  */)(buffer), (char const   */* __restrict  */)tmp,
          (size_t )30);
#line 50
  buffer[24] = (char )'\000';
#line 51
  tmp___0 = ctime((time_t const   *)(& end));
#line 51
  printf((char const   */* __restrict  */)"%s and %s", buffer, tmp___0);
  }
#line 52
  return;
}
}
