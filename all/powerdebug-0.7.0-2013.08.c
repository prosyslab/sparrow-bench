/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 27 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/tree.h"
struct tree {
   struct tree *tail ;
   struct tree *next ;
   struct tree *prev ;
   struct tree *child ;
   struct tree *parent ;
   char *path ;
   char *name ;
   void *private ;
   int nrchild ;
   unsigned char depth ;
};
#line 300 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/tree.c"
struct struct_find {
   int nr ;
   char const   *name ;
   struct tree ***ptree ;
};
#line 150 "/usr/include/curses.h"
typedef unsigned long chtype;
#line 358
struct _win_st;
#line 358 "/usr/include/curses.h"
typedef struct _win_st WINDOW;
#line 360 "/usr/include/curses.h"
typedef chtype attr_t;
#line 405
struct ldat;
#line 407 "/usr/include/curses.h"
struct pdat {
   short _pad_y ;
   short _pad_x ;
   short _pad_top ;
   short _pad_left ;
   short _pad_bottom ;
   short _pad_right ;
};
#line 407 "/usr/include/curses.h"
struct _win_st {
   short _cury ;
   short _curx ;
   short _maxy ;
   short _maxx ;
   short _begy ;
   short _begx ;
   short _flags ;
   attr_t _attrs ;
   chtype _bkgd ;
   _Bool _notimeout ;
   _Bool _clear ;
   _Bool _leaveok ;
   _Bool _scroll ;
   _Bool _idlok ;
   _Bool _idcok ;
   _Bool _immed ;
   _Bool _sync ;
   _Bool _use_keypad ;
   int _delay ;
   struct ldat *_line ;
   short _regtop ;
   short _regbottom ;
   int _parx ;
   int _pary ;
   WINDOW *_parent ;
   struct pdat _pad ;
   short _yoffset ;
};
#line 43 "/usr/include/regex.h"
typedef unsigned long reg_syntax_t;
#line 368 "/usr/include/regex.h"
struct re_pattern_buffer {
   unsigned char *__buffer ;
   unsigned long __allocated ;
   unsigned long __used ;
   reg_syntax_t __syntax ;
   char *__fastmap ;
   unsigned char *__translate ;
   size_t re_nsub ;
   unsigned int __can_be_null : 1 ;
   unsigned int __regs_allocated : 2 ;
   unsigned int __fastmap_accurate : 1 ;
   unsigned int __no_sub : 1 ;
   unsigned int __not_bol : 1 ;
   unsigned int __not_eol : 1 ;
   unsigned int __newline_anchor : 1 ;
};
#line 434 "/usr/include/regex.h"
typedef struct re_pattern_buffer regex_t;
#line 437 "/usr/include/regex.h"
typedef int regoff_t;
#line 463 "/usr/include/regex.h"
struct __anonstruct_regmatch_t_28 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 463 "/usr/include/regex.h"
typedef struct __anonstruct_regmatch_t_28 regmatch_t;
#line 18 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/display.h"
struct display_ops {
   int (*display)(_Bool refresh ) ;
   int (*select)(void) ;
   int (*find)(char const   * ) ;
   int (*selectf)(void) ;
   int (*change)(int keyvalue ) ;
};
#line 46 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/display.c"
struct rowdata {
   int attr ;
   void *data ;
};
#line 51 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/display.c"
struct windata {
   WINDOW *pad ;
   struct display_ops *ops ;
   struct rowdata *rowdata ;
   char *name ;
   int nrdata ;
   int scrolling ;
   int cursor ;
};
#line 299 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/display.c"
struct find_data {
   size_t len ;
   char *string ;
   regex_t *reg ;
   int ocursor ;
   int oscrolling ;
};
#line 36 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/regulator.c"
struct regulator_info {
   char name[255] ;
   char state[16] ;
   char status[16] ;
   char type[16] ;
   char opmode[16] ;
   int microvolts ;
   int min_microvolts ;
   int max_microvolts ;
   int microamps ;
   int min_microamps ;
   int max_microamps ;
   int requested_microamps ;
   int num_users ;
};
#line 52 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/regulator.c"
struct regulator_data {
   char const   *name ;
   char const   *ifmt ;
   char const   *ofmt ;
   _Bool derefme ;
};
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 55 "/usr/include/stdint.h"
typedef unsigned long uint64_t;
#line 79 "/usr/include/x86_64-linux-gnu/sys/epoll.h"
union epoll_data {
   void *ptr ;
   int fd ;
   uint32_t u32 ;
   uint64_t u64 ;
};
#line 79 "/usr/include/x86_64-linux-gnu/sys/epoll.h"
typedef union epoll_data epoll_data_t;
#line 87 "/usr/include/x86_64-linux-gnu/sys/epoll.h"
struct epoll_event {
   uint32_t events ;
   epoll_data_t data ;
} __attribute__((__packed__)) ;
#line 25 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/mainloop.c"
struct mainloop_data {
   int (*cb)(int fd , void *data ) ;
   void *data ;
   int fd ;
};
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 88 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/powerdebug.c"
struct powerdebug_options {
   _Bool verbose ;
   _Bool regulators ;
   _Bool sensors ;
   _Bool clocks ;
   _Bool gpios ;
   _Bool dump ;
   unsigned int ticktime ;
   int selectedwindow ;
   char *clkname ;
};
#line 35 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/sensor.c"
struct temp_info {
   char name[255] ;
   int temp ;
};
#line 40 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/sensor.c"
struct fan_info {
   char name[255] ;
   int rpms ;
};
#line 45 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/sensor.c"
struct sensor_info {
   char name[255] ;
   struct temp_info *temperatures ;
   struct fan_info *fans ;
   short nrtemps ;
   short nrfans ;
};
#line 38 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/gpio.c"
struct gpio_info {
   _Bool expanded ;
   int active_low ;
   int value ;
   char direction[10] ;
   char edge[10] ;
   char *prefix ;
};
#line 39 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/clocks.c"
struct clock_info {
   int flags ;
   int rate ;
   int usecount ;
   _Bool expanded ;
   char *prefix ;
   int preparecount ;
   int enablecount ;
   int notifiercount ;
};
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 405
extern  __attribute__((__nothrow__)) int ( /* format attribute */  asprintf)(char ** __restrict  __ptr ,
                                                                             char const   * __restrict  __fmt 
                                                                             , ...) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 604
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) basename)(char const   *__filename ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 183
extern int ( __attribute__((__nonnull__(1,2,3))) readdir_r)(DIR * __restrict  __dirp ,
                                                            struct dirent * __restrict  __entry ,
                                                            struct dirent ** __restrict  __result ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 44 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/tree.h"
struct tree *tree_load(char const   *path , int (*filter)(char const   *name ) , _Bool follow ) ;
#line 46
struct tree *tree_find(struct tree *tree , char const   *name ) ;
#line 48
int tree_for_each(struct tree *tree , int (*cb)(struct tree *t , void *data ) , void *data ) ;
#line 50
int tree_for_each_reverse(struct tree *tree , int (*cb)(struct tree *t , void *data ) ,
                          void *data ) ;
#line 52
int tree_for_each_parent(struct tree *tree , int (*cb)(struct tree *t , void *data ) ,
                         void *data ) ;
#line 54
int tree_finds(struct tree *tree , char const   *name , struct tree ***ptr ) ;
#line 36 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/tree.c"
__inline static struct tree *tree_alloc(char const   *path , int depth ) 
{ 
  struct tree *t ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 40
  tmp = malloc(sizeof(*t));
#line 40
  t = (struct tree *)tmp;
  }
#line 41
  if (! t) {
#line 42
    return ((struct tree *)((void *)0));
  }
  {
#line 45
  t->path = strdup(path);
  }
#line 46
  if (! t->path) {
    {
#line 47
    free((void *)t);
    }
#line 48
    return ((struct tree *)((void *)0));
  }
  {
#line 52
  tmp___0 = strrchr((char const   *)t->path, '/');
#line 52
  t->name = tmp___0 + 1;
#line 54
  t->depth = (unsigned char )depth;
#line 55
  t->tail = t;
#line 56
  t->child = (struct tree *)((void *)0);
#line 57
  t->parent = (struct tree *)((void *)0);
#line 58
  t->next = (struct tree *)((void *)0);
#line 59
  t->prev = (struct tree *)((void *)0);
#line 60
  t->private = (void *)0;
#line 61
  t->nrchild = 0;
  }
#line 63
  return (t);
}
}
#line 72 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/tree.c"
__inline static void tree_free(struct tree *t ) 
{ 


  {
  {
#line 74
  free((void *)t->path);
#line 75
  free((void *)t);
  }
#line 76
  return;
}
}
#line 84 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/tree.c"
__inline static void tree_add_tail(struct tree *head , struct tree *new ) 
{ 


  {
#line 86
  new->prev = head->tail;
#line 87
  (head->tail)->next = new;
#line 88
  head->tail = new;
#line 89
  return;
}
}
#line 97 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/tree.c"
__inline static void tree_add_child(struct tree *parent , struct tree *child ) 
{ 


  {
#line 99
  child->parent = parent;
#line 101
  if (parent->child) {
    {
#line 102
    tree_add_tail(parent->child, child);
    }
#line 102
    return;
  }
#line 104
  parent->child = child;
#line 105
  return;
}
}
#line 115 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/tree.c"
static int tree_scan(struct tree *tree , int (*filter)(char const   *name ) , _Bool follow ) 
{ 
  DIR *dir ;
  char *basedir ;
  char *newpath ;
  struct dirent dirent ;
  struct dirent *direntp ;
  struct stat s ;
  int ret ;
  struct tree *child ;
  int tmp ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 121
  ret = 0;
#line 123
  dir = opendir((char const   *)tree->path);
  }
#line 124
  if (! dir) {
    {
#line 125
    printf((char const   */* __restrict  */)"error: unable to open directory %s\n",
           tree->path);
    }
#line 126
    return (-1);
  }
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 129
    tmp___2 = readdir_r((DIR */* __restrict  */)dir, (struct dirent */* __restrict  */)(& dirent),
                        (struct dirent **/* __restrict  */)(& direntp));
    }
#line 129
    if (tmp___2) {
#line 129
      goto while_break;
    }
#line 133
    if (! direntp) {
#line 134
      goto while_break;
    }
#line 136
    if ((int )direntp->d_name[0] == 46) {
#line 137
      goto while_continue;
    }
#line 139
    if (filter) {
      {
#line 139
      tmp = (*filter)((char const   *)(direntp->d_name));
      }
#line 139
      if (tmp) {
#line 140
        goto while_continue;
      }
    }
    {
#line 142
    ret = asprintf((char **/* __restrict  */)(& basedir), (char const   */* __restrict  */)"%s",
                   tree->path);
    }
#line 143
    if (ret < 0) {
#line 144
      return (-1);
    }
    {
#line 146
    tmp___1 = basename((char const   *)basedir);
    }
#line 146
    if (tmp___1) {
#line 146
      ret = 0;
    } else {
#line 146
      ret = -1;
    }
#line 147
    if (ret < 0) {
#line 148
      goto out_free_basedir;
    }
    {
#line 150
    ret = asprintf((char **/* __restrict  */)(& newpath), (char const   */* __restrict  */)"%s/%s",
                   basedir, direntp->d_name);
    }
#line 151
    if (ret < 0) {
#line 152
      goto out_free_basedir;
    }
    {
#line 154
    ret = stat((char const   */* __restrict  */)newpath, (struct stat */* __restrict  */)(& s));
    }
#line 155
    if (ret) {
#line 156
      goto out_free_newpath;
    }
#line 158
    if ((s.st_mode & 61440U) == 16384U) {
#line 158
      goto _L;
    } else
#line 158
    if ((s.st_mode & 61440U) == 40960U) {
#line 158
      if (follow) {
        _L: /* CIL Label */ 
        {
#line 160
        ret = -1;
#line 162
        child = tree_alloc((char const   *)newpath, (int )tree->depth + 1);
        }
#line 163
        if (! child) {
#line 164
          goto out_free_newpath;
        }
        {
#line 166
        tree_add_child(tree, child);
#line 168
        (tree->nrchild) ++;
#line 170
        ret = tree_scan(child, filter, follow);
        }
      }
    }
    out_free_newpath: 
    {
#line 174
    free((void *)newpath);
    }
    out_free_basedir: 
    {
#line 177
    free((void *)basedir);
    }
#line 179
    if (ret) {
#line 180
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 183
  closedir(dir);
  }
#line 185
  return (ret);
}
}
#line 196 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/tree.c"
struct tree *tree_load(char const   *path , int (*filter)(char const   *name ) , _Bool follow ) 
{ 
  struct tree *tree ;
  int tmp ;

  {
  {
#line 200
  tree = tree_alloc(path, 0);
  }
#line 201
  if (! tree) {
#line 202
    return ((struct tree *)((void *)0));
  }
  {
#line 204
  tmp = tree_scan(tree, filter, follow);
  }
#line 204
  if (tmp) {
    {
#line 205
    tree_free(tree);
    }
#line 206
    return ((struct tree *)((void *)0));
  }
#line 209
  return (tree);
}
}
#line 219 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/tree.c"
int tree_for_each(struct tree *tree , int (*cb)(struct tree *t , void *data ) , void *data ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 221
  if (! tree) {
#line 222
    return (0);
  }
  {
#line 224
  tmp = (*cb)(tree, data);
  }
#line 224
  if (tmp) {
#line 225
    return (-1);
  }
  {
#line 227
  tmp___0 = tree_for_each(tree->child, cb, data);
  }
#line 227
  if (tmp___0) {
#line 228
    return (-1);
  }
  {
#line 230
  tmp___1 = tree_for_each(tree->next, cb, data);
  }
#line 230
  return (tmp___1);
}
}
#line 242 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/tree.c"
int tree_for_each_reverse(struct tree *tree , int (*cb)(struct tree *t , void *data ) ,
                          void *data ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 244
  if (! tree) {
#line 245
    return (0);
  }
  {
#line 247
  tmp = (*cb)(tree, data);
  }
#line 247
  if (tmp) {
#line 248
    return (-1);
  }
  {
#line 250
  tmp___0 = tree_for_each_reverse(tree->prev, cb, data);
  }
#line 250
  if (tmp___0) {
#line 251
    return (-1);
  }
  {
#line 253
  tmp___1 = tree_for_each_reverse(tree->parent, cb, data);
  }
#line 253
  return (tmp___1);
}
}
#line 265 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/tree.c"
int tree_for_each_parent(struct tree *tree , int (*cb)(struct tree *t , void *data ) ,
                         void *data ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 267
  if (! tree) {
#line 268
    return (0);
  }
  {
#line 270
  tmp = tree_for_each_parent(tree->parent, cb, data);
  }
#line 270
  if (tmp) {
#line 271
    return (-1);
  }
  {
#line 273
  tmp___0 = (*cb)(tree, data);
  }
#line 273
  return (tmp___0);
}
}
#line 283 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/tree.c"
struct tree *tree_find(struct tree *tree , char const   *name ) 
{ 
  struct tree *t ;
  int tmp ;
  struct tree *tmp___0 ;

  {
#line 287
  if (! tree) {
#line 288
    return ((struct tree *)((void *)0));
  }
  {
#line 290
  tmp = strcmp((char const   *)tree->name, name);
  }
#line 290
  if (! tmp) {
#line 291
    return (tree);
  }
  {
#line 293
  t = tree_find(tree->child, name);
  }
#line 294
  if (t) {
#line 295
    return (t);
  }
  {
#line 297
  tmp___0 = tree_find(tree->next, name);
  }
#line 297
  return (tmp___0);
}
}
#line 306 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/tree.c"
static int tree_finds_cb(struct tree *tree , void *data ) 
{ 
  struct struct_find *sf ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 308
  sf = (struct struct_find *)data;
#line 310
  tmp = strlen(sf->name);
  }
#line 310
  if (! tmp) {
#line 311
    return (0);
  }
  {
#line 313
  tmp___0 = strlen(sf->name);
#line 313
  tmp___1 = strncmp(sf->name, (char const   *)tree->name, tmp___0);
  }
#line 313
  if (tmp___1) {
#line 314
    return (0);
  }
#line 316
  if (sf->ptree) {
#line 317
    *(*(sf->ptree) + sf->nr) = tree;
  }
#line 319
  (sf->nr) ++;
#line 321
  return (0);
}
}
#line 334 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/tree.c"
int tree_finds(struct tree *tree , char const   *name , struct tree ***ptr ) 
{ 
  struct struct_find sf ;
  int nmatch ;
  void *tmp ;

  {
  {
#line 336
  sf.nr = 0;
#line 336
  sf.name = name;
#line 336
  sf.ptree = (struct tree ***)((void *)0);
#line 340
  tree_for_each(tree, & tree_finds_cb, (void *)(& sf));
  }
#line 343
  if (! sf.nr) {
#line 344
    return (0);
  }
  {
#line 346
  tmp = malloc(sizeof(struct tree *) * (unsigned long )sf.nr);
#line 346
  *ptr = (struct tree **)tmp;
  }
#line 347
  if (! *ptr) {
#line 348
    return (-1);
  }
  {
#line 351
  nmatch = sf.nr;
#line 352
  sf.nr = 0;
#line 353
  sf.ptree = ptr;
#line 356
  tree_for_each(tree, & tree_finds_cb, (void *)(& sf));
  }
#line 358
  return (nmatch);
}
}
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 519
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atexit)(void (*__func)(void) ) ;
#line 127 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 587 "/usr/include/curses.h"
extern int cbreak(void) ;
#line 597
extern int curs_set(int  ) ;
#line 611
extern int endwin(void) ;
#line 632
extern WINDOW *initscr(void) ;
#line 634
extern int init_pair(short  , short  , short  ) ;
#line 647
extern int keypad(WINDOW * , _Bool  ) ;
#line 699
extern int mvwprintw(WINDOW * , int  , int  , char const   *  , ...) ;
#line 705
extern WINDOW *newpad(int  , int  ) ;
#line 711
extern int noecho(void) ;
#line 712
extern int nonl(void) ;
#line 722
extern int prefresh(WINDOW * , int  , int  , int  , int  , int  , int  ) ;
#line 764
extern int start_color(void) ;
#line 766
extern WINDOW *subwin(WINDOW * , int  , int  , int  , int  ) ;
#line 794
extern int wattr_on(WINDOW * , attr_t  , void * ) ;
#line 795
extern int wattr_off(WINDOW * , attr_t  , void * ) ;
#line 797
extern int wbkgd(WINDOW * , chtype  ) ;
#line 800
extern int wchgat(WINDOW * , int  , attr_t  , short  , void const   * ) ;
#line 809
extern int werase(WINDOW * ) ;
#line 810
extern int wgetch(WINDOW * ) ;
#line 824
extern int wmove(WINDOW * , int  , int  ) ;
#line 826
extern int wprintw(WINDOW * , char const   *  , ...) ;
#line 829
extern int wrefresh(WINDOW * ) ;
#line 899
extern int use_default_colors(void) ;
#line 1386
extern WINDOW *stdscr ;
#line 573 "/usr/include/regex.h"
extern int regcomp(regex_t * __restrict  __preg , char const   * __restrict  __pattern ,
                   int __cflags ) ;
#line 577
extern int regexec(regex_t const   * __restrict  __preg , char const   * __restrict  __string ,
                   size_t __nmatch , regmatch_t * __restrict  __pmatch , int __eflags ) ;
#line 585
extern void regfree(regex_t *__preg ) ;
#line 19 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/mainloop.h"
int mainloop_add(int fd , int (*cb)(int fd , void *data ) , void *data ) ;
#line 20
int mainloop_del(int fd ) ;
#line 26 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/display.h"
int display_print_line(int win , int line , char *str , int bold , void *data ) ;
#line 29
int display_refresh_pad(int win ) ;
#line 30
int display_reset_cursor(int win ) ;
#line 31
void *display_get_row_data(int win ) ;
#line 33
int display_init(int wdefault ) ;
#line 34
int display_register(int win , struct display_ops *ops ) ;
#line 35
int display_column_name(char const   *line ) ;
#line 38 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/display.c"
static WINDOW *header_win  ;
#line 39 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/display.c"
static WINDOW *footer_win  ;
#line 40 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/display.c"
static WINDOW *main_win  ;
#line 41 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/display.c"
static int current_win  ;
#line 44 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/display.c"
static int const   maxrows  =    (int const   )1024;
#line 62 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/display.c"
struct windata windata[4]  = {      {(WINDOW *)0, (struct display_ops *)0, (struct rowdata *)0, (char *)"Clocks",
      0, 0, 0}, 
        {(WINDOW *)0, (struct display_ops *)0, (struct rowdata *)0, (char *)"Regulators",
      0, 0, 0}, 
        {(WINDOW *)0, (struct display_ops *)0, (struct rowdata *)0, (char *)"Sensors",
      0, 0, 0}, 
        {(WINDOW *)0, (struct display_ops *)0, (struct rowdata *)0, (char *)"Gpio", 0,
      0, 0}};
#line 69 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/display.c"
static void display_fini(void) 
{ 


  {
  {
#line 71
  endwin();
  }
#line 72
  return;
}
}
#line 74 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/display.c"
static int display_show_header(int win ) 
{ 
  int i ;
  int curr_pointer ;
  size_t array_size ;
  size_t tmp ;

  {
#line 77
  curr_pointer = 0;
#line 78
  array_size = sizeof(windata) / sizeof(windata[0]);
#line 80
  if (header_win) {
#line 80
    header_win->_attrs = 2UL << 8;
  }
  {
#line 81
  wbkgd(header_win, 2UL << 8);
#line 82
  werase(header_win);
#line 84
  mvwprintw(header_win, 0, curr_pointer, "PowerDebug %s", "0.7.0");
#line 85
  curr_pointer += 20;
#line 87
  i = 0;
  }
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
#line 87
    if (! ((size_t )i < array_size)) {
#line 87
      goto while_break;
    }
#line 88
    if (win == i) {
      {
#line 89
      wattr_on(header_win, 1UL << 18, (void *)0);
      }
    } else {
      {
#line 91
      wattr_off(header_win, 1UL << 18, (void *)0);
      }
    }
    {
#line 93
    mvwprintw(header_win, 0, curr_pointer, " %s ", windata[i].name);
#line 94
    tmp = strlen((char const   *)windata[i].name);
#line 94
    curr_pointer = (int )((size_t )curr_pointer + (tmp + 2UL));
#line 87
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 96
  wrefresh(header_win);
  }
#line 98
  return (0);
}
}
#line 104 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/display.c"
static int display_show_footer(int win , char *string ) 
{ 
  char const   *tmp ;

  {
  {
#line 106
  werase(footer_win);
#line 107
  wattr_on(footer_win, 1UL << 18, (void *)0);
  }
#line 108
  if (string) {
#line 108
    tmp = (char const   *)string;
  } else {
#line 108
    tmp = " Q (Quit)  R (Refresh) Other Keys: \'Left\', \'Right\' , \'Up\', \'Down\', \'enter\', , \'Esc\'";
  }
  {
#line 108
  mvwprintw(footer_win, 0, 0, "%s", tmp);
#line 109
  wattr_off(footer_win, 1UL << 18, (void *)0);
#line 110
  wrefresh(footer_win);
  }
#line 112
  return (0);
}
}
#line 115 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/display.c"
static int display_refresh(int win , _Bool read ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 118
  if (win != current_win) {
#line 119
    return (0);
  }
#line 121
  if (windata[win].ops) {
#line 121
    if ((windata[win].ops)->display) {
      {
#line 122
      tmp = (*((windata[win].ops)->display))(read);
      }
#line 122
      return (tmp);
    }
  }
  {
#line 124
  tmp___0 = werase(main_win);
  }
#line 124
  if (tmp___0) {
#line 125
    return (-1);
  }
  {
#line 127
  tmp___1 = wrefresh(main_win);
  }
#line 127
  return (tmp___1);
}
}
#line 130 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/display.c"
int display_refresh_pad(int win ) 
{ 
  int maxx ;
  int maxy ;
  int tmp ;

  {
#line 134
  if (stdscr) {
#line 134
    maxy = (int )stdscr->_maxy + 1;
  } else {
#line 134
    maxy = -1;
  }
#line 134
  if (stdscr) {
#line 134
    maxx = (int )stdscr->_maxx + 1;
  } else {
#line 134
    maxx = -1;
  }
  {
#line 136
  tmp = prefresh(windata[win].pad, windata[win].scrolling, 0, 2, 0, maxy - 2, maxx);
  }
#line 136
  return (tmp);
}
}
#line 140 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/display.c"
void sigwinch_handler(int signo ) 
{ 


  {
  {
#line 142
  display_refresh(current_win, (_Bool)1);
  }
#line 143
  return;
}
}
#line 145 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/display.c"
static int display_show_unselection(int win , int line , _Bool bold ) 
{ 
  chtype tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 147
  tmp___3 = wmove(windata[win].pad, line, 0);
  }
#line 147
  if (tmp___3 == -1) {
#line 147
    tmp___2 = -1;
  } else {
#line 147
    if (bold) {
#line 147
      tmp___0 = 1UL << 21;
    } else {
#line 147
      tmp___0 = 0UL;
    }
    {
#line 147
    tmp___1 = wchgat(windata[win].pad, -1, tmp___0, (short)0, (void const   *)((void *)0));
#line 147
    tmp___2 = tmp___1;
    }
  }
#line 147
  if (tmp___2 < 0) {
#line 149
    return (-1);
  }
  {
#line 151
  tmp___4 = display_refresh_pad(win);
  }
#line 151
  return (tmp___4);
}
}
#line 154 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/display.c"
void *display_get_row_data(int win ) 
{ 


  {
#line 156
  return ((windata[win].rowdata + windata[win].cursor)->data);
}
}
#line 159 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/display.c"
static int display_select(void) 
{ 
  int tmp ;

  {
#line 161
  if (windata[current_win].ops) {
#line 161
    if ((windata[current_win].ops)->select) {
      {
#line 162
      tmp = (*((windata[current_win].ops)->select))();
      }
#line 162
      return (tmp);
    }
  }
#line 164
  return (0);
}
}
#line 167 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/display.c"
static int display_change(int keyvalue ) 
{ 
  int tmp ;

  {
#line 169
  if (! windata[current_win].nrdata) {
#line 170
    return (0);
  }
#line 172
  if (windata[current_win].ops) {
#line 172
    if ((windata[current_win].ops)->change) {
      {
#line 173
      tmp = (*((windata[current_win].ops)->change))(keyvalue);
      }
#line 173
      return (tmp);
    }
  }
#line 175
  return (0);
}
}
#line 178 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/display.c"
static int display_next_panel(void) 
{ 
  size_t array_size ;

  {
#line 180
  array_size = sizeof(windata) / sizeof(windata[0]);
#line 182
  current_win ++;
#line 183
  current_win = (int )((unsigned long )current_win % array_size);
#line 185
  return (current_win);
}
}
#line 188 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/display.c"
static int display_prev_panel(void) 
{ 
  size_t array_size ;

  {
#line 190
  array_size = sizeof(windata) / sizeof(windata[0]);
#line 192
  current_win --;
#line 193
  if (current_win < 0) {
#line 194
    current_win = (int )(array_size - 1UL);
  }
#line 196
  return (current_win);
}
}
#line 199 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/display.c"
static int display_next_line(void) 
{ 
  int maxx ;
  int maxy ;
  int cursor ;
  int nrdata ;
  int scrolling ;
  struct rowdata *rowdata ;

  {
#line 202
  cursor = windata[current_win].cursor;
#line 203
  nrdata = windata[current_win].nrdata;
#line 204
  scrolling = windata[current_win].scrolling;
#line 205
  rowdata = windata[current_win].rowdata;
#line 207
  if (stdscr) {
#line 207
    maxy = (int )stdscr->_maxy + 1;
  } else {
#line 207
    maxy = -1;
  }
#line 207
  if (stdscr) {
#line 207
    maxx = (int )stdscr->_maxx + 1;
  } else {
#line 207
    maxx = -1;
  }
#line 209
  if (cursor >= nrdata) {
#line 210
    return (cursor);
  }
  {
#line 212
  display_show_unselection(current_win, cursor, (_Bool )(rowdata + cursor)->attr);
  }
#line 213
  if (cursor < nrdata - 1) {
#line 214
    if (cursor >= (maxy - 4) + scrolling) {
#line 215
      scrolling ++;
    }
#line 216
    cursor ++;
  }
#line 219
  windata[current_win].scrolling = scrolling;
#line 220
  windata[current_win].cursor = cursor;
#line 222
  return (cursor);
}
}
#line 225 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/display.c"
static int display_prev_line(void) 
{ 
  int cursor ;
  int nrdata ;
  int scrolling ;
  struct rowdata *rowdata ;

  {
#line 227
  cursor = windata[current_win].cursor;
#line 228
  nrdata = windata[current_win].nrdata;
#line 229
  scrolling = windata[current_win].scrolling;
#line 230
  rowdata = windata[current_win].rowdata;
#line 232
  if (cursor >= nrdata) {
#line 233
    return (cursor);
  }
  {
#line 235
  display_show_unselection(current_win, cursor, (_Bool )(rowdata + cursor)->attr);
  }
#line 236
  if (cursor > 0) {
#line 237
    if (cursor <= scrolling) {
#line 238
      scrolling --;
    }
#line 239
    cursor --;
  }
#line 242
  windata[current_win].scrolling = scrolling;
#line 243
  windata[current_win].cursor = cursor;
#line 245
  return (cursor);
}
}
#line 248 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/display.c"
static int display_set_row_data(int win , int line , void *data , int attr ) 
{ 
  struct rowdata *rowdata ;
  void *tmp ;

  {
#line 250
  rowdata = windata[win].rowdata;
#line 252
  if (line >= windata[win].nrdata) {
    {
#line 253
    tmp = realloc((void *)rowdata, sizeof(struct rowdata ) * (unsigned long )(line + 1));
#line 253
    rowdata = (struct rowdata *)tmp;
    }
#line 254
    if (! rowdata) {
#line 255
      return (-1);
    }
#line 256
    windata[win].nrdata = line + 1;
  }
#line 259
  (rowdata + line)->data = data;
#line 260
  (rowdata + line)->attr = attr;
#line 261
  windata[win].rowdata = rowdata;
#line 263
  return (0);
}
}
#line 266 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/display.c"
int display_reset_cursor(int win ) 
{ 
  int tmp ;

  {
  {
#line 268
  windata[win].nrdata = 0;
#line 269
  werase(windata[win].pad);
#line 270
  tmp = wmove(windata[win].pad, 0, 0);
  }
#line 270
  return (tmp);
}
}
#line 273 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/display.c"
int display_print_line(int win , int line , char *str , int bold , void *data ) 
{ 
  int attr ;
  int tmp ;

  {
#line 275
  attr = 0;
#line 277
  if (bold) {
#line 278
    attr = (int )((unsigned long )attr | (1UL << 21));
  }
#line 280
  if (line == windata[win].cursor) {
#line 281
    attr = (int )((unsigned long )attr | (1UL << 16));
  }
  {
#line 283
  tmp = display_set_row_data(win, line, data, attr);
  }
#line 283
  if (tmp) {
#line 284
    return (-1);
  }
#line 286
  if (attr) {
    {
#line 287
    wattr_on(windata[win].pad, (attr_t )attr, (void *)0);
    }
  }
  {
#line 289
  wprintw(windata[win].pad, "%s\n", str);
  }
#line 291
  if (attr) {
    {
#line 292
    wattr_off(windata[win].pad, (attr_t )attr, (void *)0);
    }
  }
#line 294
  return (0);
}
}
#line 297
static int display_find_keystroke(int fd , void *data ) ;
#line 307 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/display.c"
struct find_data *display_find_init(void) 
{ 
  char const   *regexp ;
  struct find_data *findd ;
  size_t len ;
  regex_t *reg ;
  char *search4 ;
  int maxx ;
  int maxy ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 309
  regexp = "^[a-z|0-9|_|-|.]";
#line 311
  len = (size_t )64;
#line 316
  if (stdscr) {
#line 316
    maxy = (int )stdscr->_maxy + 1;
  } else {
#line 316
    maxy = -1;
  }
#line 316
  if (stdscr) {
#line 316
    maxx = (int )stdscr->_maxx + 1;
  } else {
#line 316
    maxx = -1;
  }
  {
#line 318
  tmp = malloc(sizeof(*reg));
#line 318
  reg = (regex_t *)tmp;
  }
#line 319
  if (! reg) {
#line 320
    return ((struct find_data *)((void *)0));
  }
  {
#line 322
  tmp___0 = regcomp((regex_t */* __restrict  */)reg, (char const   */* __restrict  */)regexp,
                    1 << 1);
  }
#line 322
  if (tmp___0) {
#line 323
    goto out_free_reg;
  }
  {
#line 325
  tmp___1 = malloc(len);
#line 325
  search4 = (char *)tmp___1;
  }
#line 326
  if (! search4) {
#line 327
    goto out_free_regcomp;
  }
  {
#line 328
  memset((void *)search4, '\000', len);
#line 330
  tmp___2 = malloc(sizeof(*findd));
#line 330
  findd = (struct find_data *)tmp___2;
  }
#line 331
  if (! findd) {
#line 332
    goto out_free_search4;
  }
  {
#line 334
  findd->string = search4;
#line 335
  findd->reg = reg;
#line 336
  findd->len = len;
#line 341
  findd->ocursor = windata[current_win].cursor;
#line 342
  findd->oscrolling = windata[current_win].scrolling;
#line 344
  windata[current_win].cursor = 0;
#line 345
  windata[current_win].scrolling = 0;
#line 347
  curs_set(1);
  }
  out: 
#line 349
  return (findd);
  out_free_search4: 
  {
#line 352
  free((void *)search4);
  }
  out_free_regcomp: 
  {
#line 354
  regfree(reg);
  }
  out_free_reg: 
  {
#line 356
  free((void *)reg);
  }
#line 358
  goto out;
}
}
#line 361 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/display.c"
static void display_find_fini(struct find_data *findd ) 
{ 


  {
  {
#line 363
  windata[current_win].cursor = findd->ocursor;
#line 364
  windata[current_win].scrolling = findd->oscrolling;
#line 365
  regfree(findd->reg);
#line 366
  free((void *)findd->string);
#line 367
  free((void *)findd);
#line 368
  curs_set(0);
  }
#line 369
  return;
}
}
#line 371 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/display.c"
static int display_switch_to_find(int fd ) 
{ 
  struct find_data *findd ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 375
  findd = display_find_init();
  }
#line 376
  if (! findd) {
#line 377
    return (-1);
  }
  {
#line 379
  tmp = mainloop_del(fd);
  }
#line 379
  if (tmp) {
#line 380
    return (-1);
  }
  {
#line 382
  tmp___0 = mainloop_add(fd, & display_find_keystroke, (void *)findd);
  }
#line 382
  if (tmp___0) {
#line 383
    return (-1);
  }
  {
#line 385
  tmp___1 = display_show_footer(current_win, (char *)"find (esc to exit)?");
  }
#line 385
  if (tmp___1) {
#line 386
    return (-1);
  }
#line 388
  return (0);
}
}
#line 391 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/display.c"
static int display_keystroke(int fd , void *data ) 
{ 
  int keystroke ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 393
  tmp = wgetch(stdscr);
#line 393
  keystroke = tmp;
  }
  {
#line 398
  if (keystroke == 9) {
#line 398
    goto case_9;
  }
#line 398
  if (keystroke == 261) {
#line 398
    goto case_9;
  }
#line 403
  if (keystroke == 353) {
#line 403
    goto case_353;
  }
#line 403
  if (keystroke == 260) {
#line 403
    goto case_353;
  }
#line 407
  if (keystroke == 258) {
#line 407
    goto case_258;
  }
#line 411
  if (keystroke == 259) {
#line 411
    goto case_259;
  }
#line 416
  if (keystroke == 13) {
#line 416
    goto case_13;
  }
#line 416
  if (keystroke == 10) {
#line 416
    goto case_13;
  }
#line 423
  if (keystroke == 68) {
#line 423
    goto case_68;
  }
#line 423
  if (keystroke == 100) {
#line 423
    goto case_68;
  }
#line 423
  if (keystroke == 86) {
#line 423
    goto case_68;
  }
#line 423
  if (keystroke == 118) {
#line 423
    goto case_68;
  }
#line 429
  if (keystroke == 81) {
#line 429
    goto case_81;
  }
#line 429
  if (keystroke == 113) {
#line 429
    goto case_81;
  }
#line 429
  if (keystroke == -1) {
#line 429
    goto case_81;
  }
#line 432
  if (keystroke == 47) {
#line 432
    goto case_47;
  }
#line 436
  if (keystroke == 82) {
#line 436
    goto case_82;
  }
#line 436
  if (keystroke == 114) {
#line 436
    goto case_82;
  }
#line 438
  goto switch_default;
  case_9: /* CIL Label */ 
  case_261: /* CIL Label */ 
  {
#line 399
  tmp___0 = display_next_panel();
#line 399
  display_show_header(tmp___0);
  }
#line 400
  goto switch_break;
  case_353: /* CIL Label */ 
  case_260: /* CIL Label */ 
  {
#line 404
  tmp___1 = display_prev_panel();
#line 404
  display_show_header(tmp___1);
  }
#line 405
  goto switch_break;
  case_258: /* CIL Label */ 
  {
#line 408
  display_next_line();
  }
#line 409
  goto switch_break;
  case_259: /* CIL Label */ 
  {
#line 412
  display_prev_line();
  }
#line 413
  goto switch_break;
  case_13: /* CIL Label */ 
  case_10: /* CIL Label */ 
  {
#line 417
  display_select();
  }
#line 418
  goto switch_break;
  case_68: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_86: /* CIL Label */ 
  case_118: /* CIL Label */ 
  {
#line 424
  tmp___2 = toupper(keystroke);
#line 424
  display_change(tmp___2);
  }
#line 425
  goto switch_break;
  case_81: /* CIL Label */ 
  case_113: /* CIL Label */ 
  case_neg_1: /* CIL Label */ 
#line 430
  return (1);
  case_47: /* CIL Label */ 
  {
#line 433
  tmp___3 = display_switch_to_find(fd);
  }
#line 433
  return (tmp___3);
  case_82: /* CIL Label */ 
  case_114: /* CIL Label */ 
  {
#line 437
  tmp___4 = display_refresh(current_win, (_Bool)1);
  }
#line 437
  return (tmp___4);
  switch_default: /* CIL Label */ 
#line 439
  return (0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 442
  display_refresh(current_win, (_Bool)0);
  }
#line 444
  return (0);
}
}
#line 447 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/display.c"
static int display_switch_to_main(int fd ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 449
  tmp = mainloop_del(fd);
  }
#line 449
  if (tmp) {
#line 450
    return (-1);
  }
  {
#line 452
  tmp___0 = mainloop_add(fd, & display_keystroke, (void *)0);
  }
#line 452
  if (tmp___0) {
#line 453
    return (-1);
  }
  {
#line 455
  tmp___1 = display_show_header(current_win);
  }
#line 455
  if (tmp___1) {
#line 456
    return (-1);
  }
  {
#line 458
  tmp___2 = display_show_footer(current_win, (char *)((void *)0));
  }
#line 458
  if (tmp___2) {
#line 459
    return (-1);
  }
  {
#line 461
  tmp___3 = display_refresh(current_win, (_Bool)0);
  }
#line 461
  return (tmp___3);
}
}
#line 464 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/display.c"
static int display_find_keystroke(int fd , void *data ) 
{ 
  struct find_data *findd ;
  regex_t *reg ;
  char *string ;
  int keystroke ;
  int tmp ;
  char match[2] ;
  regmatch_t m[1] ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;

  {
  {
#line 466
  findd = (struct find_data *)data;
#line 467
  reg = findd->reg;
#line 468
  string = findd->string;
#line 469
  tmp = wgetch(stdscr);
#line 469
  keystroke = tmp;
#line 470
  match[0] = (char )keystroke;
#line 470
  match[1] = (char )'\000';
  }
  {
#line 475
  if (keystroke == 27) {
#line 475
    goto case_27;
  }
#line 479
  if (keystroke == 258) {
#line 479
    goto case_258;
  }
#line 483
  if (keystroke == 259) {
#line 483
    goto case_259;
  }
#line 487
  if (keystroke == 263) {
#line 487
    goto case_263;
  }
#line 497
  if (keystroke == 13) {
#line 497
    goto case_13;
  }
#line 497
  if (keystroke == 10) {
#line 497
    goto case_13;
  }
#line 509
  goto switch_default;
  case_27: /* CIL Label */ 
  {
#line 476
  display_find_fini(findd);
#line 477
  tmp___0 = display_switch_to_main(fd);
  }
#line 477
  return (tmp___0);
  case_258: /* CIL Label */ 
  {
#line 480
  display_next_line();
  }
#line 481
  goto switch_break;
  case_259: /* CIL Label */ 
  {
#line 484
  display_prev_line();
  }
#line 485
  goto switch_break;
  case_263: /* CIL Label */ 
  {
#line 488
  tmp___2 = strlen((char const   *)string);
  }
#line 488
  if (tmp___2) {
    {
#line 489
    tmp___1 = strlen((char const   *)string);
#line 489
    *(string + (tmp___1 - 1UL)) = (char )'\000';
    }
  }
#line 491
  windata[current_win].cursor = 0;
#line 492
  windata[current_win].scrolling = 0;
#line 494
  goto switch_break;
  case_13: /* CIL Label */ 
  case_10: /* CIL Label */ 
#line 498
  if (! windata[current_win].ops) {
#line 499
    return (0);
  } else
#line 498
  if (! (windata[current_win].ops)->selectf) {
#line 499
    return (0);
  }
  {
#line 501
  tmp___3 = (*((windata[current_win].ops)->selectf))();
  }
#line 501
  if (tmp___3) {
#line 502
    return (-1);
  }
#line 504
  windata[current_win].cursor = 0;
#line 505
  windata[current_win].scrolling = 0;
#line 507
  return (0);
  switch_default: /* CIL Label */ 
  {
#line 512
  tmp___4 = regexec((regex_t const   */* __restrict  */)reg, (char const   */* __restrict  */)(match),
                    (size_t )1, (regmatch_t */* __restrict  */)(m), 0);
  }
#line 512
  if (tmp___4) {
#line 513
    return (0);
  }
  {
#line 515
  tmp___6 = strlen((char const   *)string);
  }
#line 515
  if (tmp___6 < findd->len - 1UL) {
    {
#line 516
    tmp___5 = strlen((char const   *)string);
#line 516
    *(string + tmp___5) = (char )keystroke;
    }
  }
#line 518
  windata[current_win].cursor = 0;
#line 519
  windata[current_win].scrolling = 0;
#line 521
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 524
  if (! windata[current_win].ops) {
#line 525
    return (0);
  } else
#line 524
  if (! (windata[current_win].ops)->find) {
#line 525
    return (0);
  }
  {
#line 527
  tmp___7 = (*((windata[current_win].ops)->find))((char const   *)string);
  }
#line 527
  if (tmp___7) {
#line 528
    return (-1);
  }
  {
#line 530
  tmp___8 = display_show_header(current_win);
  }
#line 530
  if (tmp___8) {
#line 531
    return (-1);
  }
  {
#line 533
  tmp___11 = strlen((char const   *)string);
  }
#line 533
  if (tmp___11) {
#line 533
    tmp___10 = (char const   *)string;
  } else {
#line 533
    tmp___10 = "find (esc to exit)?";
  }
  {
#line 533
  tmp___12 = display_show_footer(current_win, (char *)tmp___10);
  }
#line 533
  if (tmp___12) {
#line 535
    return (-1);
  }
#line 537
  return (0);
}
}
#line 540 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/display.c"
int display_init(int wdefault ) 
{ 
  int i ;
  int maxx ;
  int maxy ;
  size_t array_size ;
  int tmp ;
  WINDOW *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
  {
#line 543
  array_size = sizeof(windata) / sizeof(windata[0]);
#line 545
  current_win = wdefault;
#line 547
  tmp = mainloop_add(0, & display_keystroke, (void *)0);
  }
#line 547
  if (tmp) {
#line 548
    return (-1);
  }
  {
#line 550
  tmp___0 = initscr();
  }
#line 550
  if (! tmp___0) {
#line 551
    return (-1);
  }
  {
#line 553
  start_color();
#line 554
  use_default_colors();
#line 556
  keypad(stdscr, (_Bool)1);
#line 557
  noecho();
#line 558
  cbreak();
#line 559
  curs_set(0);
#line 560
  nonl();
#line 562
  tmp___1 = init_pair((short)1, (short)7, (short)0);
  }
#line 562
  if (tmp___1) {
#line 570
    return (-1);
  } else {
    {
#line 562
    tmp___2 = init_pair((short)3, (short)0, (short)1);
    }
#line 562
    if (tmp___2) {
#line 570
      return (-1);
    } else {
      {
#line 562
      tmp___3 = init_pair((short)2, (short)7, (short)0);
      }
#line 562
      if (tmp___3) {
#line 570
        return (-1);
      } else {
        {
#line 562
        tmp___4 = init_pair((short)5, (short)7, (short)3);
        }
#line 562
        if (tmp___4) {
#line 570
          return (-1);
        } else {
          {
#line 562
          tmp___5 = init_pair((short)6, (short)7, (short)2);
          }
#line 562
          if (tmp___5) {
#line 570
            return (-1);
          } else {
            {
#line 562
            tmp___6 = init_pair((short)7, (short)7, (short)0);
            }
#line 562
            if (tmp___6) {
#line 570
              return (-1);
            } else {
              {
#line 562
              tmp___7 = init_pair((short)8, (short)7, (short)4);
              }
#line 562
              if (tmp___7) {
#line 570
                return (-1);
              } else {
                {
#line 562
                tmp___8 = init_pair((short)4, (short)7, (short)1);
                }
#line 562
                if (tmp___8) {
#line 570
                  return (-1);
                }
              }
            }
          }
        }
      }
    }
  }
  {
#line 572
  tmp___9 = atexit(& display_fini);
  }
#line 572
  if (tmp___9) {
#line 573
    return (-1);
  }
#line 575
  if (stdscr) {
#line 575
    maxy = (int )stdscr->_maxy + 1;
  } else {
#line 575
    maxy = -1;
  }
#line 575
  if (stdscr) {
#line 575
    maxx = (int )stdscr->_maxx + 1;
  } else {
#line 575
    maxx = -1;
  }
#line 577
  i = 0;
  {
#line 577
  while (1) {
    while_continue: /* CIL Label */ ;
#line 577
    if (! ((size_t )i < array_size)) {
#line 577
      goto while_break;
    }
    {
#line 579
    main_win = subwin(stdscr, maxy - 2, maxx, 1, 0);
    }
#line 580
    if (! main_win) {
#line 581
      return (-1);
    }
    {
#line 583
    windata[i].pad = newpad((int )maxrows, maxx);
    }
#line 584
    if (! windata[i].pad) {
#line 585
      return (-1);
    }
#line 577
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 589
  header_win = subwin(stdscr, 1, maxx, 0, 0);
  }
#line 590
  if (! header_win) {
#line 591
    return (-1);
  }
  {
#line 593
  footer_win = subwin(stdscr, 1, maxx, maxy - 1, 0);
  }
#line 594
  if (! footer_win) {
#line 595
    return (-1);
  }
  {
#line 597
  tmp___10 = display_show_header(wdefault);
  }
#line 597
  if (tmp___10) {
#line 598
    return (-1);
  }
  {
#line 600
  tmp___11 = display_show_footer(wdefault, (char *)((void *)0));
  }
#line 600
  if (tmp___11) {
#line 601
    return (-1);
  }
  {
#line 603
  tmp___12 = display_refresh(wdefault, (_Bool)1);
  }
#line 603
  return (tmp___12);
}
}
#line 606 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/display.c"
int display_column_name(char const   *line ) 
{ 


  {
  {
#line 608
  werase(main_win);
#line 609
  wattr_on(main_win, 1UL << 21, (void *)0);
#line 610
  mvwprintw(main_win, 0, 0, "%s", line);
#line 611
  wattr_off(main_win, 1UL << 21, (void *)0);
#line 612
  wrefresh(main_win);
  }
#line 614
  return (0);
}
}
#line 617 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/display.c"
int display_register(int win , struct display_ops *ops ) 
{ 
  size_t array_size ;

  {
#line 619
  array_size = sizeof(windata) / sizeof(windata[0]);
#line 621
  if (win < 0) {
    {
#line 622
    printf((char const   */* __restrict  */)"error: invalid window");
    }
#line 623
    return (-1);
  } else
#line 621
  if ((size_t )win >= array_size) {
    {
#line 622
    printf((char const   */* __restrict  */)"error: invalid window");
    }
#line 623
    return (-1);
  }
#line 626
  windata[win].ops = ops;
#line 628
  return (0);
}
}
#line 16 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/regulator.h"
int regulator_init(void) ;
#line 17
int regulator_dump(void) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 18 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/utils.h"
int file_read_value(char const   *path , char const   *name , char const   *format ,
                    void *value ) ;
#line 59 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/regulator.c"
static struct regulator_data regdata[8]  = 
#line 59 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/regulator.c"
  {      {"name", "%s", "\tname: %s\n", (_Bool)0}, 
        {"status", "%s", "\tstatus: %s\n", (_Bool)0}, 
        {"state", "%s", "\tstate: %s\n", (_Bool)0}, 
        {"type", "%s", "\ttype: %s\n", (_Bool)0}, 
        {"num_users", "%d", "\tnum_users: %d\n", (_Bool)1}, 
        {"microvolts", "%d", "\tmicrovolts: %d\n", (_Bool)1}, 
        {"max_microvolts", "%d", "\tmax_microvolts: %d\n", (_Bool)1}, 
        {"min_microvolts", "%d", "\tmin_microvolts: %d\n", (_Bool)1}};
#line 70 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/regulator.c"
static struct tree *reg_tree  ;
#line 72 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/regulator.c"
static struct regulator_info *regulator_alloc(void) 
{ 
  struct regulator_info *regi ;
  void *tmp ;

  {
  {
#line 76
  tmp = malloc(sizeof(*regi));
#line 76
  regi = (struct regulator_info *)tmp;
  }
#line 77
  if (regi) {
    {
#line 78
    memset((void *)regi, 0, sizeof(*regi));
    }
  }
#line 80
  return (regi);
}
}
#line 83 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/regulator.c"
static int regulator_dump_cb(struct tree *tree , void *data ) 
{ 
  int i ;
  char buffer[255] ;
  size_t nregdata ;
  size_t tmp ;
  int tmp___0 ;
  int val ;
  int tmp___1 ;

  {
  {
#line 87
  nregdata = sizeof(regdata) / sizeof(regdata[0]);
#line 89
  tmp = strlen("regulator.");
#line 89
  tmp___0 = strncmp("regulator.", (char const   *)tree->name, tmp);
  }
#line 89
  if (! tmp___0) {
    {
#line 90
    printf((char const   */* __restrict  */)"\n%s:\n", tree->name);
    }
  }
#line 92
  i = 0;
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    if (! ((size_t )i < nregdata)) {
#line 92
      goto while_break;
    }
    {
#line 95
    tmp___1 = file_read_value((char const   *)tree->path, regdata[i].name, regdata[i].ifmt,
                              (void *)(buffer));
    }
#line 95
    if (tmp___1) {
#line 97
      goto __Cont;
    }
#line 99
    if (regdata[i].derefme) {
      {
#line 100
      val = atoi((char const   *)(buffer));
#line 101
      printf((char const   */* __restrict  */)regdata[i].ofmt, val);
      }
    } else {
      {
#line 103
      printf((char const   */* __restrict  */)regdata[i].ofmt, buffer);
      }
    }
    __Cont: /* CIL Label */ 
#line 92
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 106
  return (0);
}
}
#line 109 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/regulator.c"
int regulator_dump(void) 
{ 
  int tmp ;

  {
  {
#line 111
  printf((char const   */* __restrict  */)"\nRegulator Information:\n");
#line 112
  printf((char const   */* __restrict  */)"*********************\n\n");
#line 114
  tmp = tree_for_each(reg_tree, & regulator_dump_cb, (void *)0);
  }
#line 114
  return (tmp);
}
}
#line 117 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/regulator.c"
static int regulator_display_cb(struct tree *t , void *data ) 
{ 
  struct regulator_info *reg ;
  int *line ;
  char *buf ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 119
  reg = (struct regulator_info *)t->private;
#line 120
  line = (int *)data;
#line 124
  if (! t->parent) {
#line 125
    return (0);
  }
  {
#line 127
  tmp = strlen((char const   *)(reg->name));
  }
#line 127
  if (! tmp) {
#line 128
    return (0);
  }
  {
#line 130
  tmp___0 = asprintf((char **/* __restrict  */)(& buf), (char const   */* __restrict  */)"%-11s %-11s %-11s %-11s %-11d %-11d %-11d %-12d",
                     reg->name, reg->status, reg->state, reg->type, reg->num_users,
                     reg->microvolts, reg->min_microvolts, reg->max_microvolts);
  }
#line 130
  if (tmp___0 < 0) {
#line 134
    return (-1);
  }
  {
#line 136
  display_print_line(1, *line, buf, reg->num_users, (void *)t);
#line 138
  (*line) ++;
#line 140
  free((void *)buf);
  }
#line 142
  return (0);
}
}
#line 145 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/regulator.c"
static int regulator_print_header(void) 
{ 
  char *buf ;
  int ret ;
  int tmp ;

  {
  {
#line 150
  tmp = asprintf((char **/* __restrict  */)(& buf), (char const   */* __restrict  */)"%-11s %-11s %-11s %-11s %-11s %-11s %-11s %-12s",
                 "Name", "Status", "State", "Type", "Users", "Microvolts", "Min u-volts",
                 "Max u-volts");
  }
#line 150
  if (tmp < 0) {
#line 153
    return (-1);
  }
  {
#line 155
  ret = display_column_name((char const   *)buf);
#line 157
  free((void *)buf);
  }
#line 159
  return (ret);
}
}
#line 163 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/regulator.c"
static int regulator_display(_Bool refresh ) 
{ 
  int ret ;
  int line ;

  {
  {
#line 165
  line = 0;
#line 167
  display_reset_cursor(1);
#line 169
  regulator_print_header();
#line 171
  ret = tree_for_each(reg_tree, & regulator_display_cb, (void *)(& line));
#line 173
  display_refresh_pad(1);
  }
#line 175
  return (ret);
}
}
#line 178 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/regulator.c"
static int regulator_filter_cb(char const   *name ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 184
  tmp = strcmp(name, "device");
  }
#line 184
  if (! tmp) {
#line 185
    return (1);
  }
  {
#line 187
  tmp___0 = strcmp(name, "subsystem");
  }
#line 187
  if (! tmp___0) {
#line 188
    return (1);
  }
  {
#line 190
  tmp___1 = strcmp(name, "driver");
  }
#line 190
  if (! tmp___1) {
#line 191
    return (1);
  }
#line 193
  return (0);
}
}
#line 196 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/regulator.c"
__inline static int read_regulator_cb(struct tree *t , void *data ) 
{ 
  struct regulator_info *reg ;

  {
  {
#line 198
  reg = (struct regulator_info *)t->private;
#line 200
  file_read_value((char const   *)t->path, "name", "%s", (void *)(reg->name));
#line 201
  file_read_value((char const   *)t->path, "state", "%s", (void *)(reg->state));
#line 202
  file_read_value((char const   *)t->path, "status", "%s", (void *)(reg->status));
#line 203
  file_read_value((char const   *)t->path, "type", "%s", (void *)(reg->type));
#line 204
  file_read_value((char const   *)t->path, "opmode", "%s", (void *)(reg->opmode));
#line 205
  file_read_value((char const   *)t->path, "num_users", "%d", (void *)(& reg->num_users));
#line 206
  file_read_value((char const   *)t->path, "microvolts", "%d", (void *)(& reg->microvolts));
#line 207
  file_read_value((char const   *)t->path, "min_microvolts", "%d", (void *)(& reg->min_microvolts));
#line 208
  file_read_value((char const   *)t->path, "max_microvolts", "%d", (void *)(& reg->max_microvolts));
#line 209
  file_read_value((char const   *)t->path, "microamps", "%d", (void *)(& reg->microamps));
#line 210
  file_read_value((char const   *)t->path, "min_microamps", "%d", (void *)(& reg->min_microamps));
#line 211
  file_read_value((char const   *)t->path, "max_microamps", "%d", (void *)(& reg->max_microamps));
  }
#line 213
  return (0);
}
}
#line 216 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/regulator.c"
static int fill_regulator_cb(struct tree *t , void *data ) 
{ 
  struct regulator_info *reg ;
  int tmp ;

  {
  {
#line 220
  reg = regulator_alloc();
  }
#line 221
  if (! reg) {
    {
#line 222
    printf((char const   */* __restrict  */)"error: unable to allocate memory for regulator\n");
    }
#line 223
    return (-1);
  }
#line 225
  t->private = (void *)reg;
#line 228
  if (! t->parent) {
#line 229
    return (0);
  }
  {
#line 231
  tmp = read_regulator_cb(t, data);
  }
#line 231
  return (tmp);
}
}
#line 234 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/regulator.c"
static int fill_regulator_tree(void) 
{ 
  int tmp ;

  {
  {
#line 236
  tmp = tree_for_each(reg_tree, & fill_regulator_cb, (void *)0);
  }
#line 236
  return (tmp);
}
}
#line 239 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/regulator.c"
static struct display_ops regulator_ops  =    {& regulator_display, (int (*)(void))0, (int (*)(char const   * ))0, (int (*)(void))0,
    (int (*)(int keyvalue ))0};
#line 243 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/regulator.c"
int regulator_init(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 245
  reg_tree = tree_load("/sys/class/regulator", & regulator_filter_cb, (_Bool)0);
  }
#line 246
  if (! reg_tree) {
#line 247
    return (-1);
  }
  {
#line 249
  tmp = fill_regulator_tree();
  }
#line 249
  if (tmp) {
#line 250
    return (-1);
  }
  {
#line 252
  tmp___0 = display_register(1, & regulator_ops);
  }
#line 252
  return (tmp___0);
}
}
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 100 "/usr/include/x86_64-linux-gnu/sys/epoll.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) epoll_create)(int __size ) ;
#line 113
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) epoll_ctl)(int __epfd ,
                                                                                int __op ,
                                                                                int __fd ,
                                                                                struct epoll_event *__event ) ;
#line 127
extern int epoll_wait(int __epfd , struct epoll_event *__events , int __maxevents ,
                      int __timeout ) ;
#line 18 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/mainloop.h"
int mainloop(unsigned int timeout ) ;
#line 21
int mainloop_init(void) ;
#line 22
void mainloop_fini(void) ;
#line 22 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/mainloop.c"
static int epfd  =    -1;
#line 23 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/mainloop.c"
static unsigned short nrhandler  ;
#line 31 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/mainloop.c"
struct mainloop_data **mds  ;
#line 35 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/mainloop.c"
int mainloop(unsigned int timeout ) 
{ 
  int i ;
  int nfds ;
  struct epoll_event events[10] ;
  struct mainloop_data *md ;
  int *tmp ;
  int tmp___0 ;

  {
#line 41
  if (epfd < 0) {
#line 42
    return (-1);
  }
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 46
    nfds = epoll_wait(epfd, events, 10, (int )timeout);
    }
#line 47
    if (nfds < 0) {
      {
#line 48
      tmp = __errno_location();
      }
#line 48
      if (*tmp == 4) {
#line 49
        goto __Cont;
      }
#line 50
      return (-1);
    }
#line 53
    i = 0;
    {
#line 53
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 53
      if (! (i < nfds)) {
#line 53
        goto while_break___0;
      }
      {
#line 54
      md = (struct mainloop_data *)events[i].data.ptr;
#line 56
      tmp___0 = (*(md->cb))(md->fd, md->data);
      }
#line 56
      if (tmp___0 > 0) {
#line 57
        return (0);
      }
#line 53
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 63 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/mainloop.c"
int mainloop_add(int fd , int (*cb)(int fd , void *data ) , void *data ) 
{ 
  struct epoll_event ev ;
  struct mainloop_data *md ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 65
  ev.events = (uint32_t )1;
#line 65
  ev.data.ptr = (void *)0;
#line 71
  if (fd >= (int )nrhandler) {
    {
#line 72
    tmp = realloc((void *)mds, sizeof(*mds) * (unsigned long )(fd + 1));
#line 72
    mds = (struct mainloop_data **)tmp;
    }
#line 73
    if (! mds) {
#line 74
      return (-1);
    }
#line 75
    nrhandler = (unsigned short )(fd + 1);
  }
  {
#line 78
  tmp___0 = malloc(sizeof(*md));
#line 78
  md = (struct mainloop_data *)tmp___0;
  }
#line 79
  if (! md) {
#line 80
    return (-1);
  }
  {
#line 82
  md->data = data;
#line 83
  md->cb = cb;
#line 84
  md->fd = fd;
#line 86
  *(mds + fd) = md;
#line 87
  ev.data.ptr = (void *)md;
#line 89
  tmp___1 = epoll_ctl(epfd, 1, fd, & ev);
  }
#line 89
  if (tmp___1 < 0) {
    {
#line 90
    free((void *)md);
    }
#line 91
    return (-1);
  }
#line 94
  return (0);
}
}
#line 97 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/mainloop.c"
int mainloop_del(int fd ) 
{ 
  int tmp ;

  {
#line 99
  if (fd >= (int )nrhandler) {
#line 100
    return (-1);
  }
  {
#line 102
  tmp = epoll_ctl(epfd, 2, fd, (struct epoll_event *)((void *)0));
  }
#line 102
  if (tmp < 0) {
#line 103
    return (-1);
  }
  {
#line 105
  free((void *)*(mds + fd));
  }
#line 107
  return (0);
}
}
#line 110 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/mainloop.c"
int mainloop_init(void) 
{ 


  {
  {
#line 112
  epfd = epoll_create(2);
  }
#line 113
  if (epfd < 0) {
#line 114
    return (-1);
  }
#line 116
  return (0);
}
}
#line 119 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/mainloop.c"
void mainloop_fini(void) 
{ 


  {
  {
#line 121
  close(epfd);
  }
#line 122
  return;
}
}
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 425
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...) ;
#line 32 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/utils.c"
int file_read_value(char const   *path , char const   *name , char const   *format ,
                    void *value ) 
{ 
  FILE *file ;
  char *rpath ;
  int ret ;
  int tmp___0 ;

  {
  {
#line 39
  ret = asprintf((char **/* __restrict  */)(& rpath), (char const   */* __restrict  */)"%s/%s",
                 path, name);
  }
#line 40
  if (ret < 0) {
#line 41
    return (ret);
  }
  {
#line 43
  file = fopen((char const   */* __restrict  */)rpath, (char const   */* __restrict  */)"r");
  }
#line 44
  if (! file) {
#line 45
    ret = -1;
#line 46
    goto out_free;
  }
  {
#line 49
  tmp___0 = fscanf((FILE */* __restrict  */)file, (char const   */* __restrict  */)format,
                   value);
  }
#line 49
  if (tmp___0 == -1) {
#line 49
    ret = -1;
  } else {
#line 49
    ret = 0;
  }
  {
#line 51
  fclose(file);
  }
  out_free: 
  {
#line 53
  free((void *)rpath);
  }
#line 54
  return (ret);
}
}
#line 68 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/utils.c"
int file_write_value(char const   *path , char const   *name , char const   *format ,
                     void *value ) 
{ 
  FILE *file ;
  char *rpath ;
  int ret ;
  int tmp___0 ;

  {
  {
#line 75
  ret = asprintf((char **/* __restrict  */)(& rpath), (char const   */* __restrict  */)"%s/%s",
                 path, name);
  }
#line 76
  if (ret < 0) {
#line 77
    return (ret);
  }
  {
#line 79
  file = fopen((char const   */* __restrict  */)rpath, (char const   */* __restrict  */)"w");
  }
#line 80
  if (! file) {
#line 81
    ret = -1;
#line 82
    goto out_free;
  }
  {
#line 85
  tmp___0 = fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)format,
                    value);
  }
#line 85
  if (tmp___0 < 0) {
#line 85
    ret = -1;
  } else {
#line 85
    ret = 0;
  }
  {
#line 87
  fclose(file);
  }
  out_free: 
  {
#line 89
  free((void *)rpath);
  }
#line 90
  return (ret);
}
}
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 80
extern int optopt ;
#line 173
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 16 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/clocks.h"
int clock_init(void) ;
#line 17
int clock_dump(char *clk ) ;
#line 16 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/sensor.h"
int sensor_dump(void) ;
#line 17
int sensor_init(void) ;
#line 16 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/gpio.h"
int gpio_init(void) ;
#line 17
int gpio_dump(void) ;
#line 34 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/powerdebug.c"
void usage(void) 
{ 


  {
  {
#line 36
  printf((char const   */* __restrict  */)"Usage: powerdebug [OPTIONS]\n");
#line 37
  printf((char const   */* __restrict  */)"\n");
#line 38
  printf((char const   */* __restrict  */)"powerdebug -d [ -r ] [ -s ] [ -c [ -p <clock-name> ] ] [ -v ]\n");
#line 40
  printf((char const   */* __restrict  */)"powerdebug [ -r | -s | -c ]\n");
#line 41
  printf((char const   */* __restrict  */)"  -r, --regulator \tShow regulator information\n");
#line 42
  printf((char const   */* __restrict  */)"  -s, --sensor\t\tShow sensor information\n");
#line 43
  printf((char const   */* __restrict  */)"  -c, --clock\t\tShow clock information\n");
#line 44
  printf((char const   */* __restrict  */)"  -p, --findparents\tShow all parents for a particular clock\n");
#line 46
  printf((char const   */* __restrict  */)"  -t, --time\t\tSet ticktime in seconds (eg. 10.0)\n");
#line 47
  printf((char const   */* __restrict  */)"  -d, --dump\t\tDump information once (no refresh)\n");
#line 48
  printf((char const   */* __restrict  */)"  -v, --verbose\t\tVerbose mode (use with -r and/or -s)\n");
#line 50
  printf((char const   */* __restrict  */)"  -V, --version\t\tShow Version\n");
#line 51
  printf((char const   */* __restrict  */)"  -h, --help \t\tHelp\n");
  }
#line 52
  return;
}
}
#line 54 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/powerdebug.c"
void version(void) 
{ 


  {
  {
#line 56
  printf((char const   */* __restrict  */)"powerdebug version %s\n", "0.7.0");
  }
#line 57
  return;
}
}
#line 74 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/powerdebug.c"
static struct option long_options[11]  = 
#line 74
  {      {"regulator", 0, (int *)0, 'r'}, 
        {"sensor", 0, (int *)0, 's'}, 
        {"clock", 0, (int *)0, 'c'}, 
        {"gpio", 0, (int *)0, 'g'}, 
        {"findparents", 1, (int *)0, 'p'}, 
        {"time", 1, (int *)0, 't'}, 
        {"dump", 0, (int *)0, 'd'}, 
        {"verbose", 0, (int *)0, 'v'}, 
        {"version", 0, (int *)0, 'V'}, 
        {"help", 0, (int *)0, 'h'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 100 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/powerdebug.c"
int getoptions(int argc , char **argv , struct powerdebug_options *options ) 
{ 
  int c ;
  int optindex ;
  int tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;

  {
  {
#line 104
  memset((void *)options, 0, sizeof(*options));
#line 105
  options->ticktime = 10U;
#line 106
  options->selectedwindow = -1;
  }
  {
#line 108
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 109
    optindex = 0;
#line 111
    c = getopt_long(argc, (char * const  *)argv, "rscgp:t:dvVh", (struct option  const  *)(long_options),
                    & optindex);
    }
#line 113
    if (c == -1) {
#line 114
      goto while_break;
    }
    {
#line 117
    if (c == 114) {
#line 117
      goto case_114;
    }
#line 121
    if (c == 115) {
#line 121
      goto case_115;
    }
#line 125
    if (c == 99) {
#line 125
      goto case_99;
    }
#line 129
    if (c == 103) {
#line 129
      goto case_103;
    }
#line 133
    if (c == 112) {
#line 133
      goto case_112;
    }
#line 142
    if (c == 116) {
#line 142
      goto case_116;
    }
#line 145
    if (c == 100) {
#line 145
      goto case_100;
    }
#line 148
    if (c == 118) {
#line 148
      goto case_118;
    }
#line 151
    if (c == 86) {
#line 151
      goto case_86;
    }
#line 154
    if (c == 63) {
#line 154
      goto case_63;
    }
#line 157
    goto switch_default;
    case_114: /* CIL Label */ 
#line 118
    options->regulators = (_Bool)1;
#line 119
    options->selectedwindow = 1;
#line 120
    goto switch_break;
    case_115: /* CIL Label */ 
#line 122
    options->sensors = (_Bool)1;
#line 123
    options->selectedwindow = 2;
#line 124
    goto switch_break;
    case_99: /* CIL Label */ 
#line 126
    options->clocks = (_Bool)1;
#line 127
    options->selectedwindow = 0;
#line 128
    goto switch_break;
    case_103: /* CIL Label */ 
#line 130
    options->gpios = (_Bool)1;
#line 131
    options->selectedwindow = 3;
#line 132
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 134
    options->clkname = strdup((char const   *)optarg);
    }
#line 135
    if (! options->clkname) {
      {
#line 136
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"failed to allocate memory");
      }
#line 137
      return (-1);
    }
#line 139
    options->dump = (_Bool)1;
#line 140
    options->clocks = (_Bool)1;
#line 141
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 143
    tmp = atoi((char const   *)optarg);
#line 143
    options->ticktime = (unsigned int )tmp;
    }
#line 144
    goto switch_break;
    case_100: /* CIL Label */ 
#line 146
    options->dump = (_Bool)1;
#line 147
    goto switch_break;
    case_118: /* CIL Label */ 
#line 149
    options->verbose = (_Bool)1;
#line 150
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 152
    version();
    }
#line 153
    goto switch_break;
    case_63: /* CIL Label */ 
    {
#line 155
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Unknown option %c\'.\n",
            *(argv + 0), optopt);
    }
    switch_default: /* CIL Label */ 
#line 158
    return (-1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 163
  if (! options->regulators) {
#line 163
    if (! options->clocks) {
#line 163
      if (! options->sensors) {
#line 163
        if (! options->gpios) {
#line 165
          tmp___2 = (_Bool)1;
#line 165
          options->gpios = tmp___2;
#line 165
          tmp___1 = tmp___2;
#line 165
          options->sensors = tmp___1;
#line 165
          tmp___0 = tmp___1;
#line 165
          options->clocks = tmp___0;
#line 165
          options->regulators = tmp___0;
        }
      }
    }
  }
#line 168
  if (options->selectedwindow == -1) {
#line 169
    options->selectedwindow = 0;
  }
#line 171
  return (0);
}
}
#line 174 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/powerdebug.c"
static int powerdebug_dump(struct powerdebug_options *options ) 
{ 


  {
#line 176
  if (options->regulators) {
    {
#line 177
    regulator_dump();
    }
  }
#line 179
  if (options->clocks) {
    {
#line 180
    clock_dump(options->clkname);
    }
  }
#line 182
  if (options->sensors) {
    {
#line 183
    sensor_dump();
    }
  }
#line 185
  if (options->gpios) {
    {
#line 186
    gpio_dump();
    }
  }
#line 188
  return (0);
}
}
#line 191 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/powerdebug.c"
static int powerdebug_display(struct powerdebug_options *options ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 193
  tmp = display_init(options->selectedwindow);
  }
#line 193
  if (tmp) {
    {
#line 194
    printf((char const   */* __restrict  */)"failed to initialize display\n");
    }
#line 195
    return (-1);
  }
  {
#line 198
  tmp___0 = mainloop(options->ticktime * 1000U);
  }
#line 198
  if (tmp___0) {
#line 199
    return (-1);
  }
#line 201
  return (0);
}
}
#line 204 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/powerdebug.c"
static struct powerdebug_options *powerdebug_init(void) 
{ 
  struct powerdebug_options *options ;
  void *tmp ;

  {
  {
#line 208
  tmp = malloc(sizeof(*options));
#line 208
  options = (struct powerdebug_options *)tmp;
  }
#line 209
  if (! options) {
#line 210
    return ((struct powerdebug_options *)((void *)0));
  }
  {
#line 212
  memset((void *)options, 0, sizeof(*options));
#line 213
  signal(28, & sigwinch_handler);
  }
#line 215
  return (options);
}
}
#line 218 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/powerdebug.c"
int main(int argc , char **argv ) 
{ 
  struct powerdebug_options *options ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 233
  options = powerdebug_init();
  }
#line 234
  if (! options) {
    {
#line 235
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"not enough memory to allocate options\n");
    }
#line 236
    return (1);
  }
  {
#line 239
  tmp = getoptions(argc, argv, options);
  }
#line 239
  if (tmp) {
    {
#line 240
    usage();
    }
#line 241
    return (1);
  }
  {
#line 244
  tmp___0 = mainloop_init();
  }
#line 244
  if (tmp___0) {
    {
#line 245
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"failed to initialize the mainloop\n");
    }
#line 246
    return (1);
  }
  {
#line 249
  tmp___1 = regulator_init();
  }
#line 249
  if (tmp___1) {
    {
#line 250
    printf((char const   */* __restrict  */)"failed to initialize regulator\n");
#line 251
    options->regulators = (_Bool)0;
    }
  }
  {
#line 254
  tmp___2 = clock_init();
  }
#line 254
  if (tmp___2) {
    {
#line 255
    printf((char const   */* __restrict  */)"failed to initialize clock details (check debugfs)\n");
#line 256
    options->clocks = (_Bool)0;
    }
  }
  {
#line 259
  tmp___3 = sensor_init();
  }
#line 259
  if (tmp___3) {
    {
#line 260
    printf((char const   */* __restrict  */)"failed to initialize sensors\n");
#line 261
    options->sensors = (_Bool)0;
    }
  }
  {
#line 264
  tmp___4 = gpio_init();
  }
#line 264
  if (tmp___4) {
    {
#line 265
    printf((char const   */* __restrict  */)"failed to initialize gpios\n");
#line 266
    options->gpios = (_Bool)0;
    }
  }
#line 269
  if (options->dump) {
    {
#line 269
    tmp___5 = powerdebug_dump(options);
#line 269
    ret = tmp___5;
    }
  } else {
    {
#line 269
    tmp___6 = powerdebug_display(options);
#line 269
    ret = tmp___6;
    }
  }
#line 272
  return (ret < 0);
}
}
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 33 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/sensor.c"
static struct tree *sensor_tree  ;
#line 53 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/sensor.c"
static int sensor_dump_cb(struct tree *tree , void *data ) 
{ 
  int i ;
  struct sensor_info *sensor ;
  size_t tmp ;

  {
  {
#line 56
  sensor = (struct sensor_info *)tree->private;
#line 58
  tmp = strlen((char const   *)(sensor->name));
  }
#line 58
  if (! tmp) {
#line 59
    return (0);
  }
  {
#line 61
  printf((char const   */* __restrict  */)"%s\n", sensor->name);
#line 63
  i = 0;
  }
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    if (! (i < (int )sensor->nrtemps)) {
#line 63
      goto while_break;
    }
    {
#line 64
    printf((char const   */* __restrict  */)" %s %.1f \302\260C/V\n", (sensor->temperatures + i)->name,
           (double )((float )(sensor->temperatures + i)->temp / (float )1000));
#line 63
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 67
  i = 0;
  {
#line 67
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 67
    if (! (i < (int )sensor->nrfans)) {
#line 67
      goto while_break___0;
    }
    {
#line 68
    printf((char const   */* __restrict  */)" %s %d rpm\n", (sensor->fans + i)->name,
           (sensor->fans + i)->rpms);
#line 67
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 71
  return (0);
}
}
#line 74 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/sensor.c"
int sensor_dump(void) 
{ 
  int tmp ;

  {
  {
#line 76
  printf((char const   */* __restrict  */)"\nSensor Information:\n");
#line 77
  printf((char const   */* __restrict  */)"*******************\n\n");
#line 79
  tmp = tree_for_each(sensor_tree, & sensor_dump_cb, (void *)0);
  }
#line 79
  return (tmp);
}
}
#line 82 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/sensor.c"
static struct sensor_info *sensor_alloc(void) 
{ 
  struct sensor_info *sensor ;
  void *tmp ;

  {
  {
#line 86
  tmp = malloc(sizeof(*sensor));
#line 86
  sensor = (struct sensor_info *)tmp;
  }
#line 87
  if (sensor) {
    {
#line 88
    memset((void *)sensor, 0, sizeof(*sensor));
    }
  }
#line 90
  return (sensor);
}
}
#line 93 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/sensor.c"
static int read_sensor_cb(struct tree *tree , void *data ) 
{ 
  DIR *dir ;
  int value ;
  struct dirent dirent ;
  struct dirent *direntp ;
  struct sensor_info *sensor ;
  int nrtemps ;
  int nrfans ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 98
  sensor = (struct sensor_info *)tree->private;
#line 100
  nrtemps = 0;
#line 101
  nrfans = 0;
#line 103
  dir = opendir((char const   *)tree->path);
  }
#line 104
  if (! dir) {
#line 105
    return (-1);
  }
  {
#line 107
  file_read_value((char const   *)tree->path, "name", "%s", (void *)(sensor->name));
  }
  {
#line 109
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 109
    tmp___5 = readdir_r((DIR */* __restrict  */)dir, (struct dirent */* __restrict  */)(& dirent),
                        (struct dirent **/* __restrict  */)(& direntp));
    }
#line 109
    if (tmp___5) {
#line 109
      goto while_break;
    }
#line 111
    if (! direntp) {
#line 112
      goto while_break;
    }
#line 114
    if ((int )direntp->d_type != 8) {
#line 115
      goto while_continue;
    }
    {
#line 117
    tmp___1 = strncmp((char const   *)(direntp->d_name), "temp", (size_t )4);
    }
#line 117
    if (! tmp___1) {
      {
#line 119
      tmp = file_read_value((char const   *)tree->path, (char const   *)(direntp->d_name),
                            "%d", (void *)(& value));
      }
#line 119
      if (tmp) {
#line 121
        goto while_continue;
      }
      {
#line 123
      tmp___0 = realloc((void *)sensor->temperatures, sizeof(struct temp_info ) * (unsigned long )(nrtemps + 1));
#line 123
      sensor->temperatures = (struct temp_info *)tmp___0;
      }
#line 126
      if (! sensor->temperatures) {
#line 127
        goto while_continue;
      }
      {
#line 129
      strcpy((char */* __restrict  */)((sensor->temperatures + nrtemps)->name), (char const   */* __restrict  */)(direntp->d_name));
#line 131
      (sensor->temperatures + nrtemps)->temp = value;
#line 133
      nrtemps ++;
      }
    }
    {
#line 136
    tmp___4 = strncmp((char const   *)(direntp->d_name), "fan", (size_t )3);
    }
#line 136
    if (! tmp___4) {
      {
#line 138
      tmp___2 = file_read_value((char const   *)tree->path, (char const   *)(direntp->d_name),
                                "%d", (void *)(& value));
      }
#line 138
      if (tmp___2) {
#line 140
        goto while_continue;
      }
      {
#line 142
      tmp___3 = realloc((void *)sensor->fans, sizeof(struct temp_info ) * (unsigned long )(nrfans + 1));
#line 142
      sensor->fans = (struct fan_info *)tmp___3;
      }
#line 145
      if (! sensor->fans) {
#line 146
        goto while_continue;
      }
      {
#line 148
      strcpy((char */* __restrict  */)((sensor->fans + nrfans)->name), (char const   */* __restrict  */)(direntp->d_name));
#line 150
      (sensor->fans + nrfans)->rpms = value;
#line 152
      nrfans ++;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 156
  sensor->nrtemps = (short )nrtemps;
#line 157
  sensor->nrfans = (short )nrfans;
#line 159
  closedir(dir);
  }
#line 161
  return (0);
}
}
#line 164 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/sensor.c"
static int fill_sensor_cb(struct tree *t , void *data ) 
{ 
  struct sensor_info *sensor ;
  int tmp ;

  {
  {
#line 168
  sensor = sensor_alloc();
  }
#line 169
  if (! sensor) {
#line 170
    return (-1);
  }
#line 172
  t->private = (void *)sensor;
#line 174
  if (! t->parent) {
#line 175
    return (0);
  }
  {
#line 177
  tmp = read_sensor_cb(t, data);
  }
#line 177
  return (tmp);
}
}
#line 180 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/sensor.c"
static int fill_sensor_tree(void) 
{ 
  int tmp ;

  {
  {
#line 182
  tmp = tree_for_each(sensor_tree, & fill_sensor_cb, (void *)0);
  }
#line 182
  return (tmp);
}
}
#line 185 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/sensor.c"
static int sensor_filter_cb(char const   *name ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 191
  tmp = strcmp(name, "subsystem");
  }
#line 191
  if (! tmp) {
#line 192
    return (1);
  }
  {
#line 194
  tmp___0 = strcmp(name, "driver");
  }
#line 194
  if (! tmp___0) {
#line 195
    return (1);
  }
  {
#line 197
  tmp___1 = strcmp(name, "hwmon");
  }
#line 197
  if (! tmp___1) {
#line 198
    return (1);
  }
  {
#line 200
  tmp___2 = strcmp(name, "power");
  }
#line 200
  if (! tmp___2) {
#line 201
    return (1);
  }
#line 203
  return (0);
}
}
#line 206 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/sensor.c"
static int sensor_display_cb(struct tree *t , void *data ) 
{ 
  struct sensor_info *sensor ;
  int *line ;
  char buf[1024] ;
  int i ;
  size_t tmp ;

  {
  {
#line 208
  sensor = (struct sensor_info *)t->private;
#line 209
  line = (int *)data;
#line 213
  tmp = strlen((char const   *)(sensor->name));
  }
#line 213
  if (! tmp) {
#line 214
    return (0);
  }
  {
#line 216
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%s", sensor->name);
#line 217
  display_print_line(2, *line, buf, 1, (void *)t);
#line 219
  (*line) ++;
#line 221
  i = 0;
  }
  {
#line 221
  while (1) {
    while_continue: /* CIL Label */ ;
#line 221
    if (! (i < (int )sensor->nrtemps)) {
#line 221
      goto while_break;
    }
    {
#line 222
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)" %-35s%.1f",
            (sensor->temperatures + i)->name, (double )((float )(sensor->temperatures + i)->temp / (float )1000));
#line 224
    display_print_line(2, *line, buf, 0, (void *)t);
#line 225
    (*line) ++;
#line 221
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 228
  i = 0;
  {
#line 228
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 228
    if (! (i < (int )sensor->nrfans)) {
#line 228
      goto while_break___0;
    }
    {
#line 229
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)" %-35s%d rpm",
            (sensor->fans + i)->name, (sensor->fans + i)->rpms);
#line 231
    display_print_line(2, *line, buf, 0, (void *)t);
#line 232
    (*line) ++;
#line 228
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 235
  return (0);
}
}
#line 238 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/sensor.c"
static int sensor_print_header(void) 
{ 
  char *buf ;
  int ret ;
  int tmp ;

  {
  {
#line 243
  tmp = asprintf((char **/* __restrict  */)(& buf), (char const   */* __restrict  */)"%-36s%s",
                 "Name", "Value");
  }
#line 243
  if (tmp < 0) {
#line 244
    return (-1);
  }
  {
#line 246
  ret = display_column_name((char const   *)buf);
#line 248
  free((void *)buf);
  }
#line 250
  return (ret);
}
}
#line 253 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/sensor.c"
static int sensor_display(_Bool refresh ) 
{ 
  int ret ;
  int line ;

  {
  {
#line 255
  line = 0;
#line 257
  display_reset_cursor(2);
#line 259
  sensor_print_header();
#line 261
  ret = tree_for_each(sensor_tree, & sensor_display_cb, (void *)(& line));
#line 263
  display_refresh_pad(2);
  }
#line 265
  return (ret);
}
}
#line 268 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/sensor.c"
static struct display_ops sensor_ops  =    {& sensor_display, (int (*)(void))0, (int (*)(char const   * ))0, (int (*)(void))0,
    (int (*)(int keyvalue ))0};
#line 272 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/sensor.c"
int sensor_init(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 274
  sensor_tree = tree_load("/sys/class/hwmon", & sensor_filter_cb, (_Bool)0);
  }
#line 275
  if (! sensor_tree) {
#line 276
    return (-1);
  }
  {
#line 278
  tmp = fill_sensor_tree();
  }
#line 278
  if (tmp) {
#line 279
    return (-1);
  }
  {
#line 281
  tmp___0 = display_register(2, & sensor_ops);
  }
#line 281
  return (tmp___0);
}
}
#line 342 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 38 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/gpio.c"
struct gpio_info *gpios_info  ;
#line 47 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/gpio.c"
static struct tree *gpio_tree  =    (struct tree *)((void *)0);
#line 49 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/gpio.c"
static struct gpio_info *gpio_alloc(void) 
{ 
  struct gpio_info *gi ;
  void *tmp ;

  {
  {
#line 53
  tmp = malloc(sizeof(*gi));
#line 53
  gi = (struct gpio_info *)tmp;
  }
#line 54
  if (gi) {
    {
#line 55
    memset((void *)gi, -1, sizeof(*gi));
#line 56
    memset((void *)(gi->direction), 0, (size_t )10);
#line 57
    memset((void *)(gi->edge), 0, (size_t )10);
#line 58
    gi->prefix = (char *)((void *)0);
    }
  }
#line 61
  return (gi);
}
}
#line 64 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/gpio.c"
static int gpio_filter_cb(char const   *name ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 70
  tmp = strcmp(name, "device");
  }
#line 70
  if (! tmp) {
#line 71
    return (1);
  }
  {
#line 73
  tmp___0 = strcmp(name, "subsystem");
  }
#line 73
  if (! tmp___0) {
#line 74
    return (1);
  }
  {
#line 76
  tmp___1 = strcmp(name, "driver");
  }
#line 76
  if (! tmp___1) {
#line 77
    return (1);
  }
  {
#line 80
  tmp___2 = strstr(name, "chip");
  }
#line 80
  if (tmp___2) {
#line 81
    return (1);
  }
  {
#line 84
  tmp___3 = strcmp(name, "power");
  }
#line 84
  if (! tmp___3) {
#line 85
    return (1);
  }
#line 87
  return (0);
}
}
#line 90 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/gpio.c"
__inline static int read_gpio_cb(struct tree *t , void *data ) 
{ 
  struct gpio_info *gpio ;

  {
  {
#line 92
  gpio = (struct gpio_info *)t->private;
#line 94
  file_read_value((char const   *)t->path, "active_low", "%d", (void *)(& gpio->active_low));
#line 95
  file_read_value((char const   *)t->path, "value", "%d", (void *)(& gpio->value));
#line 96
  file_read_value((char const   *)t->path, "edge", "%8s", (void *)(& gpio->edge));
#line 97
  file_read_value((char const   *)t->path, "direction", "%4s", (void *)(& gpio->direction));
  }
#line 99
  return (0);
}
}
#line 102 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/gpio.c"
static int read_gpio_info(struct tree *tree ) 
{ 
  int tmp ;

  {
  {
#line 104
  tmp = tree_for_each(tree, & read_gpio_cb, (void *)0);
  }
#line 104
  return (tmp);
}
}
#line 107 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/gpio.c"
static int fill_gpio_cb(struct tree *t , void *data ) 
{ 
  struct gpio_info *gpio ;
  int tmp ;

  {
  {
#line 111
  gpio = gpio_alloc();
  }
#line 112
  if (! gpio) {
#line 113
    return (-1);
  }
#line 114
  t->private = (void *)gpio;
#line 117
  if (! t->parent) {
#line 118
    gpio->expanded = (_Bool)1;
#line 119
    return (0);
  }
  {
#line 122
  tmp = read_gpio_cb(t, data);
  }
#line 122
  return (tmp);
}
}
#line 126 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/gpio.c"
static int fill_gpio_tree(void) 
{ 
  int tmp ;

  {
  {
#line 128
  tmp = tree_for_each(gpio_tree, & fill_gpio_cb, (void *)0);
  }
#line 128
  return (tmp);
}
}
#line 131 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/gpio.c"
static int dump_gpio_cb(struct tree *t , void *data ) 
{ 
  struct gpio_info *gpio ;
  struct gpio_info *pgpio ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;

  {
#line 133
  gpio = (struct gpio_info *)t->private;
#line 136
  if (! t->parent) {
    {
#line 137
    printf((char const   */* __restrict  */)"/\n");
#line 138
    gpio->prefix = (char *)"";
    }
#line 139
    return (0);
  }
#line 142
  pgpio = (struct gpio_info *)(t->parent)->private;
#line 144
  if (! gpio->prefix) {
#line 145
    if (t->next) {
#line 145
      tmp = "|";
    } else {
#line 145
      tmp = " ";
    }
#line 145
    if ((int )t->depth > 1) {
#line 145
      tmp___0 = "   ";
    } else {
#line 145
      tmp___0 = "";
    }
    {
#line 145
    tmp___1 = asprintf((char **/* __restrict  */)(& gpio->prefix), (char const   */* __restrict  */)"%s%s%s",
                       pgpio->prefix, tmp___0, tmp);
    }
#line 145
    if (tmp___1 < 0) {
#line 147
      return (-1);
    }
  }
#line 149
  if (! t->next) {
#line 149
    tmp___2 = "`";
  } else {
#line 149
    tmp___2 = "";
  }
  {
#line 149
  printf((char const   */* __restrict  */)"%s%s-- %s (", gpio->prefix, tmp___2, t->name);
  }
#line 151
  if (gpio->active_low != -1) {
    {
#line 152
    printf((char const   */* __restrict  */)" active_low:%d", gpio->active_low);
    }
  }
#line 154
  if (gpio->value != -1) {
    {
#line 155
    printf((char const   */* __restrict  */)", value:%d", gpio->value);
    }
  }
#line 157
  if ((int )gpio->edge[0] != 0) {
    {
#line 158
    printf((char const   */* __restrict  */)", edge:%s", gpio->edge);
    }
  }
#line 160
  if ((int )gpio->direction[0] != 0) {
    {
#line 161
    printf((char const   */* __restrict  */)", direction:%s", gpio->direction);
    }
  }
  {
#line 163
  printf((char const   */* __restrict  */)" )\n");
  }
#line 165
  return (0);
}
}
#line 168 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/gpio.c"
int dump_gpio_info(void) 
{ 
  int tmp ;

  {
  {
#line 170
  tmp = tree_for_each(gpio_tree, & dump_gpio_cb, (void *)0);
  }
#line 170
  return (tmp);
}
}
#line 173 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/gpio.c"
int gpio_dump(void) 
{ 
  int ret ;

  {
  {
#line 177
  printf((char const   */* __restrict  */)"\nGpio Tree :\n");
#line 178
  printf((char const   */* __restrict  */)"***********\n");
#line 179
  ret = dump_gpio_info();
#line 180
  printf((char const   */* __restrict  */)"\n\n");
  }
#line 182
  return (ret);
}
}
#line 185 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/gpio.c"
static char *gpio_line(struct tree *t ) 
{ 
  struct gpio_info *gpio ;
  char *gpioline ;
  int tmp ;

  {
  {
#line 187
  gpio = (struct gpio_info *)t->private;
#line 190
  tmp = asprintf((char **/* __restrict  */)(& gpioline), (char const   */* __restrict  */)"%-20s %-10d %-10d %-10s %-10s",
                 t->name, gpio->value, gpio->active_low, gpio->edge, gpio->direction);
  }
#line 190
  if (tmp < 0) {
#line 192
    return ((char *)((void *)0));
  }
#line 194
  return (gpioline);
}
}
#line 197 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/gpio.c"
static int _gpio_print_info_cb(struct tree *t , void *data ) 
{ 
  int *line ;
  char *buffer ;

  {
#line 199
  line = (int *)data;
#line 203
  if (! t->parent) {
#line 204
    return (0);
  }
  {
#line 206
  buffer = gpio_line(t);
  }
#line 207
  if (! buffer) {
#line 208
    return (-1);
  }
  {
#line 210
  display_print_line(3, *line, buffer, 0, (void *)t);
#line 212
  (*line) ++;
#line 214
  free((void *)buffer);
  }
#line 216
  return (0);
}
}
#line 219 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/gpio.c"
static int gpio_print_info_cb(struct tree *t , void *data ) 
{ 
  int tmp ;

  {
#line 222
  if (! t->parent) {
#line 223
    return (0);
  }
  {
#line 225
  tmp = _gpio_print_info_cb(t, data);
  }
#line 225
  return (tmp);
}
}
#line 228 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/gpio.c"
static int gpio_print_header(void) 
{ 
  char *buf ;
  int ret ;
  int tmp ;

  {
  {
#line 233
  tmp = asprintf((char **/* __restrict  */)(& buf), (char const   */* __restrict  */)"%-20s %-10s %-10s %-10s %-10s",
                 "Name", "Value", "Active_low", "Edge", "Direction");
  }
#line 233
  if (tmp < 0) {
#line 235
    return (-1);
  }
  {
#line 237
  ret = display_column_name((char const   *)buf);
#line 239
  free((void *)buf);
  }
#line 241
  return (ret);
}
}
#line 244 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/gpio.c"
static int gpio_print_info(struct tree *tree ) 
{ 
  int ret ;
  int line ;

  {
  {
#line 246
  line = 0;
#line 248
  display_reset_cursor(3);
#line 250
  gpio_print_header();
#line 252
  ret = tree_for_each(tree, & gpio_print_info_cb, (void *)(& line));
#line 254
  display_refresh_pad(3);
  }
#line 256
  return (ret);
}
}
#line 259 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/gpio.c"
static int gpio_display(_Bool refresh ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 261
  if (refresh) {
    {
#line 261
    tmp = read_gpio_info(gpio_tree);
    }
#line 261
    if (tmp) {
#line 262
      return (-1);
    }
  }
  {
#line 264
  tmp___0 = gpio_print_info(gpio_tree);
  }
#line 264
  return (tmp___0);
}
}
#line 267 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/gpio.c"
static int gpio_change(int keyvalue ) 
{ 
  struct tree *t ;
  void *tmp ;
  struct gpio_info *gpio ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 269
  tmp = display_get_row_data(3);
#line 269
  t = (struct tree *)tmp;
#line 270
  gpio = (struct gpio_info *)t->private;
  }
#line 272
  if (! t) {
#line 273
    return (-1);
  } else
#line 272
  if (! gpio) {
#line 273
    return (-1);
  }
  {
#line 276
  if (keyvalue == 68) {
#line 276
    goto case_68;
  }
#line 290
  if (keyvalue == 86) {
#line 290
    goto case_86;
  }
#line 304
  goto switch_default;
  case_68: /* CIL Label */ 
  {
#line 278
  tmp___0 = strstr((char const   *)(gpio->edge), "none");
  }
#line 278
  if (! tmp___0) {
#line 279
    return (0);
  }
  {
#line 281
  tmp___2 = strstr((char const   *)(gpio->direction), "in");
  }
#line 281
  if (tmp___2) {
    {
#line 282
    strcpy((char */* __restrict  */)(gpio->direction), (char const   */* __restrict  */)"out");
    }
  } else {
    {
#line 283
    tmp___1 = strstr((char const   *)(gpio->direction), "out");
    }
#line 283
    if (tmp___1) {
      {
#line 284
      strcpy((char */* __restrict  */)(gpio->direction), (char const   */* __restrict  */)"in");
      }
    }
  }
  {
#line 285
  file_write_value((char const   *)t->path, "direction", "%s", (void *)(& gpio->direction));
#line 286
  file_read_value((char const   *)t->path, "direction", "%s", (void *)(& gpio->direction));
  }
#line 288
  goto switch_break;
  case_86: /* CIL Label */ 
  {
#line 292
  tmp___3 = strstr((char const   *)(gpio->edge), "none");
  }
#line 292
  if (tmp___3) {
    {
#line 292
    tmp___4 = strstr((char const   *)(gpio->direction), "out");
    }
#line 292
    if (! tmp___4) {
#line 294
      return (0);
    }
  } else {
#line 294
    return (0);
  }
#line 296
  if (gpio->value) {
    {
#line 297
    file_write_value((char const   *)t->path, "direction", "%s", (void *)"low");
    }
  } else {
    {
#line 299
    file_write_value((char const   *)t->path, "direction", "%s", (void *)"high");
    }
  }
  {
#line 300
  file_read_value((char const   *)t->path, "value", "%d", (void *)(& gpio->value));
  }
#line 302
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 305
  return (-1);
  switch_break: /* CIL Label */ ;
  }
#line 308
  return (0);
}
}
#line 311 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/gpio.c"
static struct display_ops gpio_ops  =    {& gpio_display, (int (*)(void))0, (int (*)(char const   * ))0, (int (*)(void))0,
    & gpio_change};
#line 319 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/gpio.c"
int gpio_init(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 321
  gpio_tree = tree_load("/sys/class/gpio", & gpio_filter_cb, (_Bool)0);
  }
#line 322
  if (! gpio_tree) {
#line 323
    return (-1);
  }
  {
#line 325
  tmp = fill_gpio_tree();
  }
#line 325
  if (tmp) {
#line 326
    return (-1);
  }
  {
#line 328
  tmp___0 = display_register(3, & gpio_ops);
  }
#line 328
  return (tmp___0);
}
}
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 39 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/clocks.c"
struct clock_info *clocks_info  ;
#line 56 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/clocks.c"
static struct tree *clock_tree  =    (struct tree *)((void *)0);
#line 57 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/clocks.c"
static int clock_fw  ;
#line 59 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/clocks.c"
static int locate_debugfs(char *clk_path ) 
{ 


  {
  {
#line 61
  strcpy((char */* __restrict  */)clk_path, (char const   */* __restrict  */)"/sys/kernel/debug");
  }
#line 62
  return (0);
}
}
#line 65 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/clocks.c"
static struct clock_info *clock_alloc(void) 
{ 
  struct clock_info *ci ;
  void *tmp ;

  {
  {
#line 69
  tmp = malloc(sizeof(*ci));
#line 69
  ci = (struct clock_info *)tmp;
  }
#line 70
  if (ci) {
    {
#line 71
    memset((void *)ci, 0, sizeof(*ci));
    }
  }
#line 73
  return (ci);
}
}
#line 76 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/clocks.c"
__inline static char const   *clock_rate(int *rate ) 
{ 
  int r ;

  {
#line 81
  r = *rate >> 30;
#line 82
  if (r) {
#line 83
    *rate = r;
#line 84
    return ("GHZ");
  }
#line 88
  r = *rate >> 20;
#line 89
  if (r) {
#line 90
    *rate = r;
#line 91
    return ("MHZ");
  }
#line 95
  r = *rate >> 10;
#line 96
  if (r) {
#line 97
    *rate = r;
#line 98
    return ("KHZ");
  }
#line 101
  return ("");
}
}
#line 104 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/clocks.c"
static int dump_clock_cb(struct tree *t , void *data ) 
{ 
  struct clock_info *clk ;
  struct clock_info *pclk ;
  char const   *unit ;
  int ret ;
  int rate ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 106
  clk = (struct clock_info *)t->private;
#line 109
  ret = 0;
#line 110
  rate = clk->rate;
#line 112
  if (! t->parent) {
    {
#line 113
    printf((char const   */* __restrict  */)"/\n");
#line 114
    clk->prefix = (char *)"";
    }
#line 115
    return (0);
  }
#line 118
  pclk = (struct clock_info *)(t->parent)->private;
#line 120
  if (! clk->prefix) {
#line 121
    if (t->next) {
#line 121
      tmp = "|";
    } else {
#line 121
      tmp = " ";
    }
#line 121
    if ((int )t->depth > 1) {
#line 121
      tmp___0 = "   ";
    } else {
#line 121
      tmp___0 = "";
    }
    {
#line 121
    ret = asprintf((char **/* __restrict  */)(& clk->prefix), (char const   */* __restrict  */)"%s%s%s",
                   pclk->prefix, tmp___0, tmp);
    }
  }
#line 123
  if (ret < 0) {
#line 124
    return (-1);
  }
  {
#line 126
  unit = clock_rate(& rate);
  }
#line 128
  if (! t->next) {
#line 128
    tmp___1 = "`";
  } else {
#line 128
    tmp___1 = "";
  }
  {
#line 128
  printf((char const   */* __restrict  */)"%s%s-- %s (flags:0x%x, usecount:%d, rate: %d %s)\n",
         clk->prefix, tmp___1, t->name, clk->flags, clk->usecount, rate, unit);
  }
#line 132
  return (0);
}
}
#line 135 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/clocks.c"
int dump_clock_info(void) 
{ 
  int tmp ;

  {
  {
#line 137
  tmp = tree_for_each(clock_tree, & dump_clock_cb, (void *)0);
  }
#line 137
  return (tmp);
}
}
#line 140 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/clocks.c"
static int dump_all_parents(char *clkarg ) 
{ 
  struct tree *tree ;
  int tmp ;

  {
  {
#line 144
  tree = tree_find(clock_tree, (char const   *)clkarg);
  }
#line 145
  if (! tree) {
    {
#line 146
    printf((char const   */* __restrict  */)"Clock NOT found!\n");
    }
#line 147
    return (-1);
  }
  {
#line 150
  tmp = tree_for_each_parent(tree, & dump_clock_cb, (void *)0);
  }
#line 150
  return (tmp);
}
}
#line 153 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/clocks.c"
__inline static int read_clock_cb(struct tree *t , void *data ) 
{ 
  struct clock_info *clk ;

  {
#line 155
  clk = (struct clock_info *)t->private;
#line 157
  if (clock_fw == 0) {
    {
#line 158
    file_read_value((char const   *)t->path, "clk_flags", "%x", (void *)(& clk->flags));
#line 159
    file_read_value((char const   *)t->path, "clk_rate", "%d", (void *)(& clk->rate));
#line 160
    file_read_value((char const   *)t->path, "clk_prepare_count", "%d", (void *)(& clk->preparecount));
#line 161
    file_read_value((char const   *)t->path, "clk_enable_count", "%d", (void *)(& clk->enablecount));
#line 162
    file_read_value((char const   *)t->path, "clk_notifier_count", "%d", (void *)(& clk->notifiercount));
    }
  } else {
    {
#line 165
    file_read_value((char const   *)t->path, "flags", "%x", (void *)(& clk->flags));
#line 166
    file_read_value((char const   *)t->path, "rate", "%d", (void *)(& clk->rate));
#line 167
    file_read_value((char const   *)t->path, "usecount", "%d", (void *)(& clk->usecount));
    }
  }
#line 170
  return (0);
}
}
#line 173 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/clocks.c"
static int read_clock_info(struct tree *tree ) 
{ 
  int tmp ;

  {
  {
#line 175
  tmp = tree_for_each(tree, & read_clock_cb, (void *)0);
  }
#line 175
  return (tmp);
}
}
#line 178 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/clocks.c"
static int fill_clock_cb(struct tree *t , void *data ) 
{ 
  struct clock_info *clk ;
  int tmp ;

  {
  {
#line 182
  clk = clock_alloc();
  }
#line 183
  if (! clk) {
#line 184
    return (-1);
  }
#line 185
  t->private = (void *)clk;
#line 188
  if (! t->parent) {
#line 189
    clk->expanded = (_Bool)1;
#line 190
    return (0);
  }
  {
#line 193
  tmp = read_clock_cb(t, data);
  }
#line 193
  return (tmp);
}
}
#line 196 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/clocks.c"
static int fill_clock_tree(void) 
{ 
  int tmp ;

  {
  {
#line 198
  tmp = tree_for_each(clock_tree, & fill_clock_cb, (void *)0);
  }
#line 198
  return (tmp);
}
}
#line 201 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/clocks.c"
static int is_collapsed(struct tree *t , void *data ) 
{ 
  struct clock_info *clk ;

  {
#line 203
  clk = (struct clock_info *)t->private;
#line 205
  if (! clk->expanded) {
#line 206
    return (1);
  }
#line 208
  return (0);
}
}
#line 211 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/clocks.c"
static char *clock_line(struct tree *t ) 
{ 
  struct clock_info *clk ;
  int rate ;
  char const   *clkunit ;
  char *clkrate ;
  char *clkname ;
  char *clkline ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 216
  clkline = (char *)((void *)0);
#line 218
  clk = (struct clock_info *)t->private;
#line 219
  rate = clk->rate;
#line 220
  clkunit = clock_rate(& rate);
#line 222
  tmp = asprintf((char **/* __restrict  */)(& clkname), (char const   */* __restrict  */)"%*s%s",
                 ((int )t->depth - 1) * 2, "", t->name);
  }
#line 222
  if (tmp < 0) {
#line 223
    return ((char *)((void *)0));
  }
  {
#line 225
  tmp___0 = asprintf((char **/* __restrict  */)(& clkrate), (char const   */* __restrict  */)"%d%s",
                     rate, clkunit);
  }
#line 225
  if (tmp___0 < 0) {
#line 226
    goto free_clkname;
  }
#line 228
  if (clock_fw == 0) {
    {
#line 229
    tmp___1 = asprintf((char **/* __restrict  */)(& clkline), (char const   */* __restrict  */)"%-35s 0x%-8x %-12s %-10d %-11d %-15d %-14d %-10d",
                       clkname, clk->flags, clkrate, clk->usecount, t->nrchild, clk->preparecount,
                       clk->enablecount, clk->notifiercount);
    }
#line 229
    if (tmp___1 < 0) {
#line 232
      goto free_clkrate;
    }
  } else {
    {
#line 235
    tmp___2 = asprintf((char **/* __restrict  */)(& clkline), (char const   */* __restrict  */)"%-55s 0x%-16x %-12s %-9d %-8d",
                       clkname, clk->flags, clkrate, clk->usecount, t->nrchild);
    }
#line 235
    if (tmp___2 < 0) {
#line 237
      goto free_clkrate;
    }
  }
  free_clkrate: 
  {
#line 241
  free((void *)clkrate);
  }
  free_clkname: 
  {
#line 243
  free((void *)clkname);
  }
#line 245
  return (clkline);
}
}
#line 248 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/clocks.c"
static int _clock_print_info_cb(struct tree *t , void *data ) 
{ 
  struct clock_info *clock ;
  int *line ;
  char *buffer ;

  {
#line 250
  clock = (struct clock_info *)t->private;
#line 251
  line = (int *)data;
#line 255
  if (! t->parent) {
#line 256
    return (0);
  }
  {
#line 258
  buffer = clock_line(t);
  }
#line 259
  if (! buffer) {
#line 260
    return (-1);
  }
  {
#line 262
  display_print_line(0, *line, buffer, clock->usecount, (void *)t);
#line 264
  (*line) ++;
#line 266
  free((void *)buffer);
  }
#line 268
  return (0);
}
}
#line 271 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/clocks.c"
static int clock_print_info_cb(struct tree *t , void *data ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 274
  if (! t->parent) {
#line 275
    return (0);
  }
  {
#line 278
  tmp = tree_for_each_parent(t->parent, & is_collapsed, (void *)0);
  }
#line 278
  if (tmp) {
#line 279
    return (0);
  }
  {
#line 281
  tmp___0 = _clock_print_info_cb(t, data);
  }
#line 281
  return (tmp___0);
}
}
#line 284 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/clocks.c"
static int clock_print_header(void) 
{ 
  char *buf ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
#line 289
  if (clock_fw == 0) {
    {
#line 290
    tmp = asprintf((char **/* __restrict  */)(& buf), (char const   */* __restrict  */)"%-35s %-10s %-12s %-10s %-11s %-15s %-14s %-14s",
                   "Name", "Flags", "Rate", "Usecount", "Children", "Prepare_Count",
                   "Enable_Count", "Notifier_Count");
    }
#line 290
    if (tmp < 0) {
#line 293
      return (-1);
    }
  } else {
    {
#line 296
    tmp___0 = asprintf((char **/* __restrict  */)(& buf), (char const   */* __restrict  */)"%-55s %-16s %-12s %-9s %-8s",
                       "Name", "Flags", "Rate", "Usecount", "Children");
    }
#line 296
    if (tmp___0 < 0) {
#line 298
      return (-1);
    }
  }
  {
#line 301
  ret = display_column_name((char const   *)buf);
#line 303
  free((void *)buf);
  }
#line 305
  return (ret);
}
}
#line 308 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/clocks.c"
static int clock_print_info(struct tree *tree ) 
{ 
  int ret ;
  int line ;

  {
  {
#line 310
  line = 0;
#line 312
  display_reset_cursor(0);
#line 314
  clock_print_header();
#line 316
  ret = tree_for_each(tree, & clock_print_info_cb, (void *)(& line));
#line 318
  display_refresh_pad(0);
  }
#line 320
  return (ret);
}
}
#line 323 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/clocks.c"
static int clock_select(void) 
{ 
  struct tree *t ;
  void *tmp ;
  struct clock_info *clk ;

  {
  {
#line 325
  tmp = display_get_row_data(0);
#line 325
  t = (struct tree *)tmp;
#line 326
  clk = (struct clock_info *)t->private;
#line 328
  clk->expanded = (_Bool )(! clk->expanded);
  }
#line 330
  return (0);
}
}
#line 338 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/clocks.c"
static int clock_display(_Bool refresh ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 340
  if (refresh) {
    {
#line 340
    tmp = read_clock_info(clock_tree);
    }
#line 340
    if (tmp) {
#line 341
      return (-1);
    }
  }
  {
#line 343
  tmp___0 = clock_print_info(clock_tree);
  }
#line 343
  return (tmp___0);
}
}
#line 346 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/clocks.c"
static int clock_find(char const   *name ) 
{ 
  struct tree **ptree ;
  int i ;
  int nr ;
  int line ;
  int ret ;

  {
  {
#line 348
  ptree = (struct tree **)((void *)0);
#line 349
  line = 0;
#line 349
  ret = 0;
#line 351
  nr = tree_finds(clock_tree, name, & ptree);
#line 353
  display_reset_cursor(0);
#line 355
  i = 0;
  }
  {
#line 355
  while (1) {
    while_continue: /* CIL Label */ ;
#line 355
    if (! (i < nr)) {
#line 355
      goto while_break;
    }
    {
#line 357
    ret = _clock_print_info_cb(*(ptree + i), (void *)(& line));
    }
#line 358
    if (ret) {
#line 359
      goto while_break;
    }
#line 355
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 363
  display_refresh_pad(0);
#line 365
  free((void *)ptree);
  }
#line 367
  return (ret);
}
}
#line 370 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/clocks.c"
static int clock_selectf(void) 
{ 
  struct tree *t ;
  void *tmp ;
  int line ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 372
  tmp = display_get_row_data(0);
#line 372
  t = (struct tree *)tmp;
#line 373
  line = 0;
#line 375
  display_reset_cursor(0);
#line 377
  tmp___0 = tree_for_each_parent(t, & _clock_print_info_cb, (void *)(& line));
  }
#line 377
  if (tmp___0) {
#line 378
    return (-1);
  }
  {
#line 380
  tmp___1 = display_refresh_pad(0);
  }
#line 380
  return (tmp___1);
}
}
#line 389 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/clocks.c"
int clock_dump(char *clk ) 
{ 
  int ret ;
  int tmp ;

  {
  {
#line 393
  tmp = read_clock_info(clock_tree);
  }
#line 393
  if (tmp) {
#line 394
    return (-1);
  }
#line 396
  if (clk) {
    {
#line 397
    printf((char const   */* __restrict  */)"\nParents for \"%s\" Clock :\n\n", clk);
#line 398
    ret = dump_all_parents(clk);
#line 399
    printf((char const   */* __restrict  */)"\n\n");
    }
  } else {
    {
#line 401
    printf((char const   */* __restrict  */)"\nClock Tree :\n");
#line 402
    printf((char const   */* __restrict  */)"**********\n");
#line 403
    ret = dump_clock_info();
#line 404
    printf((char const   */* __restrict  */)"\n\n");
    }
  }
#line 407
  return (ret);
}
}
#line 410 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/clocks.c"
static struct display_ops clock_ops  =    {& clock_display, & clock_select, & clock_find, & clock_selectf, (int (*)(int keyvalue ))0};
#line 420 "/home/wheatley/newnew/temp/powerdebug-0.7.0-2013.08/clocks.c"
int clock_init(void) 
{ 
  char clk_dir_path[3][4096] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 424
  tmp = locate_debugfs(clk_dir_path[0]);
  }
#line 424
  if (tmp) {
#line 425
    return (-1);
  } else {
    {
#line 424
    tmp___0 = locate_debugfs(clk_dir_path[1]);
    }
#line 424
    if (tmp___0) {
#line 425
      return (-1);
    }
  }
  {
#line 427
  sprintf((char */* __restrict  */)(clk_dir_path[0]), (char const   */* __restrict  */)"%s/clk",
          clk_dir_path[0]);
#line 428
  sprintf((char */* __restrict  */)(clk_dir_path[1]), (char const   */* __restrict  */)"%s/clock",
          clk_dir_path[1]);
#line 429
  tmp___2 = access((char const   *)(clk_dir_path[0]), 0);
  }
#line 429
  if (tmp___2) {
    {
#line 433
    tmp___1 = access((char const   *)(clk_dir_path[1]), 0);
    }
#line 433
    if (tmp___1) {
#line 438
      return (-1);
    } else {
      {
#line 434
      clock_fw = 1;
#line 435
      strcpy((char */* __restrict  */)(clk_dir_path[2]), (char const   */* __restrict  */)(clk_dir_path[1]));
      }
    }
  } else {
    {
#line 430
    clock_fw = 0;
#line 431
    strcpy((char */* __restrict  */)(clk_dir_path[2]), (char const   */* __restrict  */)(clk_dir_path[0]));
    }
  }
  {
#line 440
  clock_tree = tree_load((char const   *)(clk_dir_path[2]), (int (*)(char const   *name ))((void *)0),
                         (_Bool)0);
  }
#line 441
  if (! clock_tree) {
#line 442
    return (-1);
  }
  {
#line 444
  tmp___3 = fill_clock_tree();
  }
#line 444
  if (tmp___3) {
#line 445
    return (-1);
  }
  {
#line 447
  tmp___4 = display_register(0, & clock_ops);
  }
#line 447
  return (tmp___4);
}
}
