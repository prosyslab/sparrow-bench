/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 54 "/home/wheatley/newnew/temp/pdfcrack-0.12/common.h"
enum passwordMethod {
    Wordlist = 1,
    Generative = 2
} ;
#line 54 "/home/wheatley/newnew/temp/pdfcrack-0.12/common.h"
typedef enum passwordMethod passwordMethod;
#line 37 "/home/wheatley/newnew/temp/pdfcrack-0.12/common.h"
struct EncData {
   char *s_handler ;
   uint8_t *o_string ;
   uint8_t *u_string ;
   uint8_t *fileID ;
   _Bool encryptMetaData ;
   unsigned int fileIDLen ;
   unsigned int version_major ;
   unsigned int version_minor ;
   int length ;
   int permissions ;
   int revision ;
   int version ;
};
#line 52 "/home/wheatley/newnew/temp/pdfcrack-0.12/common.h"
typedef struct EncData EncData;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_13 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_13 __sigset_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_27 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_28 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_29 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_30 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_31 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_32 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_33 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_26 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_27 _kill ;
   struct __anonstruct__timer_28 _timer ;
   struct __anonstruct__rt_29 _rt ;
   struct __anonstruct__sigchld_30 _sigchld ;
   struct __anonstruct__sigfault_31 _sigfault ;
   struct __anonstruct__sigpoll_32 _sigpoll ;
   struct __anonstruct__sigsys_33 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_25 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_26 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_25 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_45 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_45 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 28 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfparser.c"
struct p_str {
   uint8_t *content ;
   uint8_t len ;
};
#line 33 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfparser.c"
typedef struct p_str p_str;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 59 "/usr/include/time.h"
typedef __clock_t clock_t;
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
#line 399 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 356 "/usr/include/stdio.h"
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 425
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...)  __asm__("__isoc99_fscanf")  ;
#line 702
extern int ungetc(int __c , FILE *__stream ) ;
#line 27 "/home/wheatley/newnew/temp/pdfcrack-0.12/passwords.h"
void initPasswords(passwordMethod const   pm , FILE *file , char const   *wl , char const   *cs ,
                   unsigned int const   minPw , unsigned int const   maxPw ) ;
#line 32
_Bool nextPassword(void) ;
#line 35
unsigned int setPassword(uint8_t *outbuf ) ;
#line 38
_Bool pw_loadState(FILE *file , char **wl ) ;
#line 41
void pw_saveState(FILE *file ) ;
#line 28 "/home/wheatley/newnew/temp/pdfcrack-0.12/passwords.c"
static FILE *wordList  =    (FILE *)((void *)0);
#line 29 "/home/wheatley/newnew/temp/pdfcrack-0.12/passwords.c"
static char const   *wordListName  ;
#line 30 "/home/wheatley/newnew/temp/pdfcrack-0.12/passwords.c"
static _Bool wlMore  ;
#line 31 "/home/wheatley/newnew/temp/pdfcrack-0.12/passwords.c"
static _Bool (*npw)()  =    (_Bool (*)())((void *)0);
#line 32 "/home/wheatley/newnew/temp/pdfcrack-0.12/passwords.c"
static unsigned int (*spw)(uint8_t *outbuf )  =    (unsigned int (*)(uint8_t *outbuf ))((void *)0);
#line 33 "/home/wheatley/newnew/temp/pdfcrack-0.12/passwords.c"
static passwordMethod pwMethod  ;
#line 35 "/home/wheatley/newnew/temp/pdfcrack-0.12/passwords.c"
_Bool nextPassword(void) 
{ 
  _Bool tmp ;

  {
  {
#line 36
  tmp = (*npw)();
  }
#line 36
  return (tmp);
}
}
#line 38 "/home/wheatley/newnew/temp/pdfcrack-0.12/passwords.c"
unsigned int setPassword(uint8_t *outbuf ) 
{ 
  unsigned int tmp ;

  {
  {
#line 39
  tmp = (*spw)(outbuf);
  }
#line 39
  return (tmp);
}
}
#line 41 "/home/wheatley/newnew/temp/pdfcrack-0.12/passwords.c"
static _Bool wlNextPassword(void) 
{ 


  {
#line 42
  return (wlMore);
}
}
#line 44 "/home/wheatley/newnew/temp/pdfcrack-0.12/passwords.c"
static unsigned int wlSetPassword(uint8_t *outbuf ) 
{ 
  int ch ;
  unsigned int passlength ;
  unsigned int tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
  {
#line 49
  ch = 0;
#line 50
  passlength = 0U;
#line 52
  ch = _IO_getc(wordList);
  }
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
#line 53
    if (ch != 10) {
#line 53
      if (ch != 13) {
#line 53
        if (ch != -1) {
#line 53
          if (! (passlength < 32U)) {
#line 53
            goto while_break;
          }
        } else {
#line 53
          goto while_break;
        }
      } else {
#line 53
        goto while_break;
      }
    } else {
#line 53
      goto while_break;
    }
    {
#line 54
    tmp = passlength;
#line 54
    passlength ++;
#line 54
    *(outbuf + tmp) = (uint8_t )ch;
#line 55
    ch = _IO_getc(wordList);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 59
  tmp___0 = __builtin_expect((long )(passlength == 32U), 0L);
  }
#line 59
  if (tmp___0) {
    {
#line 60
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 60
      if (ch != 10) {
#line 60
        if (ch != 13) {
#line 60
          if (! (ch != -1)) {
#line 60
            goto while_break___0;
          }
        } else {
#line 60
          goto while_break___0;
        }
      } else {
#line 60
        goto while_break___0;
      }
      {
#line 61
      ch = _IO_getc(wordList);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 63
  if (ch == 13) {
    {
#line 64
    ch = _IO_getc(wordList);
    }
#line 65
    if (ch != 10) {
      {
#line 66
      ungetc(ch, wordList);
      }
    }
  }
  {
#line 68
  tmp___1 = __builtin_expect((long )(ch == -1), 0L);
  }
#line 68
  if (tmp___1) {
#line 69
    wlMore = (_Bool)0;
  }
#line 71
  return (passlength);
}
}
#line 75 "/home/wheatley/newnew/temp/pdfcrack-0.12/passwords.c"
static void setWordList(FILE *file , char const   *wl ) 
{ 


  {
#line 77
  wordList = file;
#line 78
  wordListName = wl;
#line 79
  npw = & wlNextPassword;
#line 80
  spw = & wlSetPassword;
#line 81
  wlMore = (_Bool)1;
#line 82
  return;
}
}
#line 84 "/home/wheatley/newnew/temp/pdfcrack-0.12/passwords.c"
static uint8_t const   stdchars[63]  = 
#line 84
  {      (uint8_t const   )'a',      (uint8_t const   )'b',      (uint8_t const   )'c',      (uint8_t const   )'d', 
        (uint8_t const   )'e',      (uint8_t const   )'f',      (uint8_t const   )'g',      (uint8_t const   )'h', 
        (uint8_t const   )'i',      (uint8_t const   )'j',      (uint8_t const   )'k',      (uint8_t const   )'l', 
        (uint8_t const   )'m',      (uint8_t const   )'n',      (uint8_t const   )'o',      (uint8_t const   )'p', 
        (uint8_t const   )'q',      (uint8_t const   )'r',      (uint8_t const   )'s',      (uint8_t const   )'t', 
        (uint8_t const   )'u',      (uint8_t const   )'v',      (uint8_t const   )'w',      (uint8_t const   )'x', 
        (uint8_t const   )'y',      (uint8_t const   )'z',      (uint8_t const   )'A',      (uint8_t const   )'B', 
        (uint8_t const   )'C',      (uint8_t const   )'D',      (uint8_t const   )'E',      (uint8_t const   )'F', 
        (uint8_t const   )'G',      (uint8_t const   )'H',      (uint8_t const   )'I',      (uint8_t const   )'J', 
        (uint8_t const   )'K',      (uint8_t const   )'L',      (uint8_t const   )'M',      (uint8_t const   )'N', 
        (uint8_t const   )'O',      (uint8_t const   )'P',      (uint8_t const   )'Q',      (uint8_t const   )'R', 
        (uint8_t const   )'S',      (uint8_t const   )'T',      (uint8_t const   )'U',      (uint8_t const   )'V', 
        (uint8_t const   )'W',      (uint8_t const   )'X',      (uint8_t const   )'Y',      (uint8_t const   )'Z', 
        (uint8_t const   )'0',      (uint8_t const   )'1',      (uint8_t const   )'2',      (uint8_t const   )'3', 
        (uint8_t const   )'4',      (uint8_t const   )'5',      (uint8_t const   )'6',      (uint8_t const   )'7', 
        (uint8_t const   )'8',      (uint8_t const   )'9',      (uint8_t const   )'\000'};
#line 89 "/home/wheatley/newnew/temp/pdfcrack-0.12/passwords.c"
static uint8_t const   *charset  ;
#line 90 "/home/wheatley/newnew/temp/pdfcrack-0.12/passwords.c"
static unsigned int charsetLen  ;
#line 91 "/home/wheatley/newnew/temp/pdfcrack-0.12/passwords.c"
static unsigned int maxPasswordLen  ;
#line 92 "/home/wheatley/newnew/temp/pdfcrack-0.12/passwords.c"
static int password[33]  ;
#line 94 "/home/wheatley/newnew/temp/pdfcrack-0.12/passwords.c"
static unsigned int genSetPassword(uint8_t *outbuf ) 
{ 
  unsigned int i ;

  {
#line 98
  i = 0U;
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! (password[i] != -1)) {
#line 98
      goto while_break;
    }
#line 99
    *(outbuf + i) = (uint8_t )*(charset + password[i]);
#line 98
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 101
  return (i);
}
}
#line 105 "/home/wheatley/newnew/temp/pdfcrack-0.12/passwords.c"
static _Bool genNextPassword(void) 
{ 
  unsigned int i ;
  unsigned int tmp ;

  {
#line 107
  i = 0U;
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    (password[i]) ++;
#line 116
    if (! (password[i] == (int )charsetLen)) {
#line 116
      goto while_break;
    }
#line 117
    tmp = i;
#line 117
    i ++;
#line 117
    password[tmp] = 0;
  }
  while_break: /* CIL Label */ ;
  }
#line 119
  return ((_Bool )(i != maxPasswordLen));
}
}
#line 122 "/home/wheatley/newnew/temp/pdfcrack-0.12/passwords.c"
static _Bool recovery  =    (_Bool)0;
#line 124 "/home/wheatley/newnew/temp/pdfcrack-0.12/passwords.c"
static void setCharset(char const   *cs , unsigned int const   minPw , unsigned int const   maxPw ) 
{ 
  int i ;
  unsigned int min ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 130
  npw = & genNextPassword;
#line 131
  spw = & genSetPassword;
#line 133
  if (! recovery) {
#line 135
    if (cs) {
#line 136
      charset = (uint8_t const   *)cs;
    } else {
#line 138
      charset = stdchars;
    }
    {
#line 139
    tmp = strlen((char const   *)charset);
#line 139
    charsetLen = (unsigned int )tmp;
    }
#line 142
    if (maxPw < 33U) {
#line 143
      maxPasswordLen = (unsigned int )maxPw;
    } else {
#line 145
      maxPasswordLen = 32U;
    }
#line 146
    if (minPw < 33U) {
#line 147
      min = (unsigned int )minPw;
    } else {
#line 149
      min = 32U;
    }
#line 152
    i = 0;
    {
#line 152
    while (1) {
      while_continue: /* CIL Label */ ;
#line 152
      if (! (i < (int )maxPasswordLen)) {
#line 152
        goto while_break;
      }
#line 153
      if (i < (int )min - 1) {
#line 154
        password[i] = (int )(charsetLen - 1U);
      } else {
#line 156
        password[i] = -1;
      }
#line 152
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 158
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 158
      if (! (i < 32)) {
#line 158
        goto while_break___0;
      }
#line 159
      tmp___0 = i;
#line 159
      i ++;
#line 159
      password[tmp___0] = -1;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 162
  password[32] = -1;
#line 163
  return;
}
}
#line 165 "/home/wheatley/newnew/temp/pdfcrack-0.12/passwords.c"
void initPasswords(passwordMethod const   pm , FILE *file , char const   *wl , char const   *cs ,
                   unsigned int const   minPw , unsigned int const   maxPw ) 
{ 


  {
#line 169
  if (! recovery) {
#line 170
    pwMethod = (passwordMethod )pm;
  }
  {
#line 173
  if ((unsigned int )pwMethod == 2U) {
#line 173
    goto case_2;
  }
#line 176
  if ((unsigned int )pwMethod == 1U) {
#line 176
    goto case_1;
  }
#line 179
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 174
  setCharset(cs, minPw, maxPw);
  }
#line 175
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 177
  setWordList(file, wl);
  }
#line 178
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 181
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 183
  return;
}
}
#line 186 "/home/wheatley/newnew/temp/pdfcrack-0.12/passwords.c"
static char const   string_PM[9]  = 
#line 186
  {      (char const   )'\n',      (char const   )'P',      (char const   )'M',      (char const   )':', 
        (char const   )' ',      (char const   )'%',      (char const   )'d',      (char const   )'\n', 
        (char const   )'\000'};
#line 187 "/home/wheatley/newnew/temp/pdfcrack-0.12/passwords.c"
static char const   string_MPCLC[25]  = 
#line 187
  {      (char const   )'M',      (char const   )'a',      (char const   )'x',      (char const   )'P', 
        (char const   )'W',      (char const   )'L',      (char const   )':',      (char const   )' ', 
        (char const   )'%',      (char const   )'d',      (char const   )'\n',      (char const   )'C', 
        (char const   )'h',      (char const   )'a',      (char const   )'r',      (char const   )'s', 
        (char const   )'e',      (char const   )'t',      (char const   )'(',      (char const   )'%', 
        (char const   )'d',      (char const   )')',      (char const   )':',      (char const   )' ', 
        (char const   )'\000'};
#line 189 "/home/wheatley/newnew/temp/pdfcrack-0.12/passwords.c"
_Bool pw_loadState(FILE *file , char **wl ) 
{ 
  int pm ;
  unsigned int i ;
  unsigned int len ;
  char * __restrict  string ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;

  {
  {
#line 195
  tmp = fscanf((FILE */* __restrict  */)file, (char const   */* __restrict  */)(string_PM),
               & pm);
  }
#line 195
  if (tmp < 1) {
#line 196
    return ((_Bool)0);
  }
#line 197
  if (pm == 2) {
    {
#line 198
    tmp___0 = fscanf((FILE */* __restrict  */)file, (char const   */* __restrict  */)(string_MPCLC),
                     & maxPasswordLen, & charsetLen);
    }
#line 198
    if (tmp___0 < 2) {
#line 199
      return ((_Bool)0);
    }
#line 202
    if (charsetLen > 256U) {
#line 203
      return ((_Bool)0);
    }
    {
#line 205
    tmp___1 = malloc(sizeof(uint8_t ) * (unsigned long )charsetLen + 1UL);
#line 205
    string = (char */* __restrict  */)tmp___1;
#line 206
    i = 0U;
    }
    {
#line 206
    while (1) {
      while_continue: /* CIL Label */ ;
#line 206
      if (! (i < charsetLen)) {
#line 206
        goto while_break;
      }
      {
#line 207
      tmp___2 = _IO_getc(file);
#line 207
      *(string + i) = (char )tmp___2;
#line 206
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 208
    *(string + i) = (char )'\000';
#line 209
    charset = (uint8_t const   *)((uint8_t *)string);
#line 212
    _IO_getc(file);
#line 214
    i = 0U;
    }
    {
#line 214
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 214
      if (! (i < 32U)) {
#line 214
        goto while_break___0;
      }
      {
#line 215
      tmp___3 = fscanf((FILE */* __restrict  */)file, (char const   */* __restrict  */)" %d",
                       & password[i]);
      }
#line 215
      if (tmp___3 < 1) {
        {
#line 216
        free((void *)string);
        }
#line 217
        return ((_Bool)0);
      }
#line 214
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 220
  if (pm == 1) {
    {
#line 221
    tmp___4 = fscanf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"Wordlist(%d): ",
                     & len);
    }
#line 221
    if (tmp___4 < 1) {
#line 222
      return ((_Bool)0);
    }
    {
#line 223
    tmp___5 = malloc(sizeof(char ) * (unsigned long )len + 1UL);
#line 223
    string = (char */* __restrict  */)tmp___5;
#line 224
    tmp___6 = fscanf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"%[^\n]\n",
                     string);
    }
#line 224
    if (tmp___6 < 1) {
      {
#line 225
      free((void *)string);
      }
#line 226
      return ((_Bool)0);
    }
#line 228
    *(string + len) = (char )'\000';
#line 229
    *wl = (char *)string;
#line 230
    wordListName = (char const   *)string;
  }
#line 232
  pwMethod = (passwordMethod )pm;
#line 233
  recovery = (_Bool)1;
#line 235
  return ((_Bool)1);
}
}
#line 238 "/home/wheatley/newnew/temp/pdfcrack-0.12/passwords.c"
void pw_saveState(FILE *file ) 
{ 
  unsigned int i ;
  size_t tmp ;

  {
  {
#line 241
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)(string_PM),
          (unsigned int )pwMethod);
  }
#line 242
  if ((unsigned int )pwMethod == 2U) {
    {
#line 243
    fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)(string_MPCLC),
            maxPasswordLen, charsetLen);
#line 244
    fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"%s\n",
            charset);
#line 245
    i = 0U;
    }
    {
#line 245
    while (1) {
      while_continue: /* CIL Label */ ;
#line 245
      if (! (i < 32U)) {
#line 245
        goto while_break;
      }
      {
#line 246
      fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)" %d",
              password[i]);
#line 245
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 248
  if ((unsigned int )pwMethod == 1U) {
    {
#line 249
    tmp = strlen(wordListName);
#line 249
    fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"Wordlist(%zu): %s",
            tmp, wordListName);
    }
  }
  {
#line 251
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"\n");
  }
#line 252
  return;
}
}
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 59 "/home/wheatley/newnew/temp/pdfcrack-0.12/common.h"
void freeEncData(EncData *e ) ;
#line 62
void printEncData(EncData *e ) ;
#line 24 "/home/wheatley/newnew/temp/pdfcrack-0.12/common.c"
void freeEncData(EncData *e ) 
{ 


  {
#line 26
  if (! e) {
#line 27
    return;
  }
#line 28
  if (e->o_string) {
    {
#line 29
    free((void *)e->o_string);
    }
  }
#line 30
  if (e->u_string) {
    {
#line 31
    free((void *)e->u_string);
    }
  }
#line 32
  if (e->fileID) {
    {
#line 33
    free((void *)e->fileID);
    }
  }
#line 34
  if (e->s_handler) {
    {
#line 35
    free((void *)e->s_handler);
    }
  }
  {
#line 36
  free((void *)e);
  }
#line 37
  return;
}
}
#line 39 "/home/wheatley/newnew/temp/pdfcrack-0.12/common.c"
void printEncData(EncData *e ) 
{ 
  unsigned int i ;
  uint8_t ch ;
  char const   *tmp ;

  {
  {
#line 44
  printf((char const   */* __restrict  */)"PDF version %d.%d\n", e->version_major,
         e->version_minor);
  }
#line 45
  if (e->s_handler) {
    {
#line 46
    printf((char const   */* __restrict  */)"Security Handler: %s\n", e->s_handler);
    }
  }
#line 47
  if (e->encryptMetaData) {
#line 47
    tmp = "True";
  } else {
#line 47
    tmp = "False";
  }
  {
#line 47
  printf((char const   */* __restrict  */)"V: %d\nR: %d\nP: %d\nLength: %d\nEncrypted Metadata: %s\n",
         e->version, e->revision, e->permissions, e->length, tmp);
#line 50
  printf((char const   */* __restrict  */)"FileID: ");
#line 51
  i = 0U;
  }
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
#line 51
    if (! (i < e->fileIDLen)) {
#line 51
      goto while_break;
    }
#line 52
    ch = *(e->fileID + i);
#line 53
    if ((int )ch < 16) {
      {
#line 54
      printf((char const   */* __restrict  */)"0%x", (int )ch);
      }
    } else {
      {
#line 56
      printf((char const   */* __restrict  */)"%x", (int )ch);
      }
    }
#line 51
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 62
  if (e->u_string) {
    {
#line 63
    printf((char const   */* __restrict  */)"\nU: ");
#line 64
    i = 0U;
    }
    {
#line 64
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 64
      if (! (i < 32U)) {
#line 64
        goto while_break___0;
      }
#line 65
      ch = *(e->u_string + i);
#line 66
      if ((int )ch < 16) {
        {
#line 67
        printf((char const   */* __restrict  */)"0%x", (int )ch);
        }
      } else {
        {
#line 69
        printf((char const   */* __restrict  */)"%x", (int )ch);
        }
      }
#line 64
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 72
  if (e->o_string) {
    {
#line 73
    printf((char const   */* __restrict  */)"\nO: ");
#line 74
    i = 0U;
    }
    {
#line 74
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 74
      if (! (i < 32U)) {
#line 74
        goto while_break___1;
      }
#line 75
      ch = *(e->o_string + i);
#line 76
      if ((int )ch < 16) {
        {
#line 77
        printf((char const   */* __restrict  */)"0%x", (int )ch);
        }
      } else {
        {
#line 79
        printf((char const   */* __restrict  */)"%x", (int )ch);
        }
      }
#line 74
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 82
  printf((char const   */* __restrict  */)"\n");
  }
#line 83
  return;
}
}
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 215 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 218
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigfillset)(sigset_t *__set ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 173
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 432 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) alarm)(unsigned int __seconds ) ;
#line 32 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfparser.h"
_Bool openPDF(FILE *file , EncData *e ) ;
#line 35
int getEncryptedInfo(FILE *file , EncData *e ) ;
#line 26 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfcrack.h"
_Bool initPDFCrack(EncData const   *e , uint8_t const   *upw , _Bool const   user ,
                   char const   *wl , passwordMethod const   pm , FILE *file , char const   *cs ,
                   unsigned int const   minPw , unsigned int const   maxPw , _Bool const   perm ) ;
#line 32
_Bool loadState(FILE *file , EncData *e , char **wl , _Bool *user ) ;
#line 35
void saveState(FILE *file ) ;
#line 38
void cleanPDFCrack(void) ;
#line 59
void runCrack(void) ;
#line 62
_Bool printProgress(void) ;
#line 23 "/home/wheatley/newnew/temp/pdfcrack-0.12/benchmark.h"
void runBenchmark(void) ;
#line 37 "/home/wheatley/newnew/temp/pdfcrack-0.12/main.c"
static void alarmInterrupt(void) 
{ 
  _Bool tmp ;

  {
  {
#line 39
  tmp = printProgress();
  }
#line 39
  if (! tmp) {
    {
#line 40
    alarm(20U);
    }
  }
#line 41
  return;
}
}
#line 44
static  __attribute__((__noreturn__)) void autoSave(int sig ) ;
#line 44 "/home/wheatley/newnew/temp/pdfcrack-0.12/main.c"
static void autoSave(int sig ) 
{ 
  FILE *file ;

  {
#line 48
  if (sig) {
    {
#line 49
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Caught signal %d!\nTrying to save state...\n",
            sig);
    }
  }
  {
#line 50
  file = fopen((char const   */* __restrict  */)"savedstate.sav", (char const   */* __restrict  */)"w");
  }
#line 50
  if ((unsigned long )file == (unsigned long )((FILE *)0)) {
    {
#line 51
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not open %s for writing\n",
            "savedstate.sav");
    }
  } else {
    {
#line 54
    saveState(file);
#line 55
    fclose(file);
#line 56
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Successfully saved state to %s!\n",
            "savedstate.sav");
    }
  }
  {
#line 58
  exit(sig);
  }
}
}
#line 62 "/home/wheatley/newnew/temp/pdfcrack-0.12/main.c"
static void printHelp(char *progname ) 
{ 


  {
  {
#line 64
  printf((char const   */* __restrict  */)"Usage: %s -f filename [OPTIONS]\nOPTIONS:\n-b, --bench\t\tperform benchmark and exit\n-c, --charset=STRING\tUse the characters in STRING as charset\n-w, --wordlist=FILE\tUse FILE as source of passwords to try\n-n, --minpw=INTEGER\tSkip trying passwords shorter than this\n-m, --maxpw=INTEGER\tStop when reaching this passwordlength\n-l, --loadState=FILE\tContinue from the state saved in FILENAME\n-o, --owner\t\tWork with the ownerpassword\n-u, --user\t\tWork with the userpassword (default)\n-p, --password=STRING\tGive userpassword to speed up breaking\n\t\t\townerpassword (implies -o)\n-q, --quiet\t\tRun quietly\n-s, --permutate\t\tTry permutating the passwords (currently only\n\t\t\tsupports switching first character to uppercase)\n-v, --version\t\tPrint version and exit\n",
         progname);
  }
#line 81
  return;
}
}
#line 97
int main(int argc , char **argv ) ;
#line 97 "/home/wheatley/newnew/temp/pdfcrack-0.12/main.c"
static struct option long_options[14]  = 
#line 97
  {      {"bench", 0, (int *)0, 'b'}, 
        {"charset", 1, (int *)0, 'c'}, 
        {"file", 1, (int *)0, 'f'}, 
        {"loadState", 1, (int *)0, 'l'}, 
        {"maxpw", 1, (int *)0, 'm'}, 
        {"minpw", 1, (int *)0, 'n'}, 
        {"owner", 0, (int *)0, 'o'}, 
        {"password", 1, (int *)0, 'p'}, 
        {"quiet", 1, (int *)0, 'q'}, 
        {"permutate", 0, (int *)0, 's'}, 
        {"user", 0, (int *)0, 'u'}, 
        {"wordlist", 1, (int *)0, 'w'}, 
        {"version", 0, (int *)0, 'v'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 83 "/home/wheatley/newnew/temp/pdfcrack-0.12/main.c"
int main(int argc , char **argv ) 
{ 
  int ret___0 ;
  int minpw ;
  int maxpw ;
  struct sigaction act1 ;
  struct sigaction act2 ;
  FILE *file ;
  FILE *wordlist ;
  _Bool recovery___1 ;
  _Bool quiet ;
  _Bool work_with_user ;
  _Bool permutation___0 ;
  uint8_t *userpassword ;
  char *charset___1 ;
  char *inputfile ;
  char *wordlistfile ;
  EncData *e ;
  int c ;
  int option_index ;
  char *tmp ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  _Bool tmp___9 ;
  int tmp___10 ;

  {
#line 85
  ret___0 = 0;
#line 85
  minpw = 0;
#line 85
  maxpw = 32;
#line 87
  file = (FILE *)((void *)0);
#line 87
  wordlist = (FILE *)((void *)0);
#line 88
  recovery___1 = (_Bool)0;
#line 88
  quiet = (_Bool)0;
#line 88
  work_with_user = (_Bool)1;
#line 88
  permutation___0 = (_Bool)0;
#line 90
  userpassword = (uint8_t *)((void *)0);
#line 91
  charset___1 = (char *)((void *)0);
#line 91
  inputfile = (char *)((void *)0);
#line 91
  wordlistfile = (char *)((void *)0);
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 113
    option_index = 0;
#line 115
    c = getopt_long(argc, (char * const  *)argv, "bc:f:l:m:n:op:qsuw:v", (struct option  const  *)(long_options),
                    & option_index);
    }
#line 119
    if (c == -1) {
#line 120
      goto while_break;
    }
    {
#line 123
    if (c == 98) {
#line 123
      goto case_98;
    }
#line 126
    if (c == 99) {
#line 126
      goto case_99;
    }
#line 132
    if (c == 102) {
#line 132
      goto case_102;
    }
#line 137
    if (c == 108) {
#line 137
      goto case_108;
    }
#line 146
    if (c == 109) {
#line 146
      goto case_109;
    }
#line 150
    if (c == 110) {
#line 150
      goto case_110;
    }
#line 154
    if (c == 111) {
#line 154
      goto case_111;
    }
#line 158
    if (c == 112) {
#line 158
      goto case_112;
    }
#line 163
    if (c == 113) {
#line 163
      goto case_113;
    }
#line 167
    if (c == 117) {
#line 167
      goto case_117;
    }
#line 175
    if (c == 115) {
#line 175
      goto case_115;
    }
#line 179
    if (c == 119) {
#line 179
      goto case_119;
    }
#line 186
    if (c == 118) {
#line 186
      goto case_118;
    }
#line 190
    goto switch_default;
    case_98: /* CIL Label */ 
    {
#line 124
    runBenchmark();
    }
#line 125
    return (0);
    case_99: /* CIL Label */ 
#line 127
    if (charset___1) {
      {
#line 128
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Charset already set\n");
      }
    } else {
      {
#line 130
      charset___1 = strdup((char const   *)optarg);
      }
    }
#line 131
    goto switch_break;
    case_102: /* CIL Label */ 
#line 133
    if (! recovery___1) {
      {
#line 134
      inputfile = strdup((char const   *)optarg);
      }
    }
#line 135
    goto switch_break;
    case_108: /* CIL Label */ 
#line 138
    if (inputfile) {
      {
#line 139
      free((void *)inputfile);
#line 140
      inputfile = (char *)((void *)0);
      }
    }
    {
#line 142
    inputfile = strdup((char const   *)optarg);
#line 143
    recovery___1 = (_Bool)1;
    }
#line 144
    goto switch_break;
    case_109: /* CIL Label */ 
    {
#line 147
    maxpw = atoi((char const   *)optarg);
    }
#line 148
    goto switch_break;
    case_110: /* CIL Label */ 
    {
#line 151
    minpw = atoi((char const   *)optarg);
    }
#line 152
    goto switch_break;
    case_111: /* CIL Label */ 
#line 155
    work_with_user = (_Bool)0;
#line 156
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 159
    tmp = strdup((char const   *)optarg);
#line 159
    userpassword = (uint8_t *)tmp;
#line 160
    work_with_user = (_Bool)0;
    }
#line 161
    goto switch_break;
    case_113: /* CIL Label */ 
#line 164
    quiet = (_Bool)1;
#line 165
    goto switch_break;
    case_117: /* CIL Label */ 
#line 168
    if (! work_with_user) {
      {
#line 169
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot work with both user- and owner-password\n");
#line 170
      exit(1);
      }
    }
#line 172
    work_with_user = (_Bool)1;
#line 173
    goto switch_break;
    case_115: /* CIL Label */ 
#line 176
    permutation___0 = (_Bool)1;
#line 177
    goto switch_break;
    case_119: /* CIL Label */ 
#line 180
    if (wordlistfile) {
      {
#line 181
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wordlist already set\n");
      }
    } else {
      {
#line 183
      wordlistfile = strdup((char const   *)optarg);
      }
    }
#line 184
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 187
    printf((char const   */* __restrict  */)"pdfcrack version %d.%d\n", 0, 12);
    }
#line 188
    return (0);
    switch_default: /* CIL Label */ 
    {
#line 191
    printHelp(*(argv + 0));
#line 192
    ret___0 = 1;
    }
#line 193
    goto out3;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 202
  i = optind;
#line 203
  if (i > 0) {
#line 204
    if (i < argc) {
#line 204
      if (! inputfile) {
        {
#line 205
        tmp___0 = i;
#line 205
        i ++;
#line 205
        inputfile = strdup((char const   *)*(argv + tmp___0));
        }
      }
    }
#line 206
    if (i < argc) {
#line 206
      if (! wordlistfile) {
        {
#line 207
        tmp___1 = i;
#line 207
        i ++;
#line 207
        wordlistfile = strdup((char const   *)*(argv + tmp___1));
        }
      }
    }
#line 208
    if (i < argc) {
      {
#line 209
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 209
        if (! (i < argc)) {
#line 209
          goto while_break___0;
        }
        {
#line 210
        tmp___2 = i;
#line 210
        i ++;
#line 210
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Non-option argument %s\n",
                *(argv + tmp___2));
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 215
  if (! inputfile) {
    {
#line 216
    printHelp(*(argv + 0));
#line 217
    ret___0 = 1;
    }
#line 218
    goto out3;
  } else
#line 215
  if (minpw < 0) {
    {
#line 216
    printHelp(*(argv + 0));
#line 217
    ret___0 = 1;
    }
#line 218
    goto out3;
  } else
#line 215
  if (maxpw < 0) {
    {
#line 216
    printHelp(*(argv + 0));
#line 217
    ret___0 = 1;
    }
#line 218
    goto out3;
  }
  {
#line 221
  file = fopen((char const   */* __restrict  */)inputfile, (char const   */* __restrict  */)"r");
  }
#line 221
  if ((unsigned long )file == (unsigned long )((FILE *)0)) {
    {
#line 222
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: file %s not found\n",
            inputfile);
#line 223
    ret___0 = 2;
    }
#line 224
    goto out3;
  }
  {
#line 227
  tmp___3 = calloc((size_t )1, sizeof(EncData ));
#line 227
  e = (EncData *)tmp___3;
  }
#line 229
  if (recovery___1) {
#line 230
    if (wordlistfile) {
      {
#line 231
      free((void *)wordlistfile);
#line 232
      wordlistfile = (char *)((void *)0);
      }
    }
    {
#line 234
    tmp___4 = loadState(file, e, & wordlistfile, & work_with_user);
    }
#line 234
    if (! tmp___4) {
      {
#line 235
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Not a savefile or savefile is damaged\n");
#line 236
      ret___0 = 3;
      }
#line 237
      goto out1;
    }
#line 240
    if (! quiet) {
      {
#line 241
      printf((char const   */* __restrict  */)"Loaded state for %s\n", inputfile);
      }
    }
  } else {
    {
#line 244
    tmp___5 = openPDF(file, e);
    }
#line 244
    if (! tmp___5) {
      {
#line 245
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Not a valid PDF\n");
#line 246
      ret___0 = 3;
      }
#line 247
      goto out1;
    }
    {
#line 250
    ret___0 = getEncryptedInfo(file, e);
    }
#line 251
    if (ret___0) {
#line 252
      if (ret___0 == -1) {
        {
#line 253
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Could not extract encryption information\n");
        }
      } else
#line 254
      if (ret___0 == -2) {
        {
#line 255
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Encryption not detected (is the document password protected?)\n");
#line 256
        ret___0 = 4;
        }
#line 257
        goto out1;
      } else
#line 254
      if (ret___0 == -3) {
        {
#line 255
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Encryption not detected (is the document password protected?)\n");
#line 256
        ret___0 = 4;
        }
#line 257
        goto out1;
      } else
#line 254
      if (ret___0 == -4) {
        {
#line 255
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Encryption not detected (is the document password protected?)\n");
#line 256
        ret___0 = 4;
        }
#line 257
        goto out1;
      }
    } else
#line 260
    if (e->revision < 2) {
      {
#line 261
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The specific version is not supported (%s - %d)\n",
              e->s_handler, e->revision);
#line 262
      ret___0 = 5;
      }
#line 263
      goto out1;
    } else {
      {
#line 260
      tmp___6 = strcmp((char const   *)e->s_handler, "Standard");
      }
#line 260
      if (tmp___6 != 0) {
        {
#line 261
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The specific version is not supported (%s - %d)\n",
                e->s_handler, e->revision);
#line 262
        ret___0 = 5;
        }
#line 263
        goto out1;
      }
    }
  }
  {
#line 267
  tmp___7 = fclose(file);
  }
#line 267
  if (tmp___7) {
    {
#line 268
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: closing file %s\n",
            inputfile);
    }
  }
#line 271
  if (minpw > maxpw) {
    {
#line 272
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: minimum pw-length bigger than max\n");
    }
  }
#line 275
  if (wordlistfile) {
    {
#line 276
    wordlist = fopen((char const   */* __restrict  */)wordlistfile, (char const   */* __restrict  */)"r");
    }
#line 276
    if ((unsigned long )wordlist == (unsigned long )((FILE *)0)) {
      {
#line 277
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: file %s not found\n",
              wordlistfile);
#line 278
      ret___0 = 6;
      }
#line 279
      goto out2;
    }
  }
  {
#line 283
  act2.__sigaction_handler.sa_handler = & autoSave;
#line 284
  sigfillset(& act2.sa_mask);
#line 285
  act2.sa_flags = 0;
#line 286
  sigaction(2, (struct sigaction  const  */* __restrict  */)(& act2), (struct sigaction */* __restrict  */)0);
  }
#line 288
  if (! quiet) {
    {
#line 289
    printEncData(e);
#line 290
    act1.__sigaction_handler.sa_handler = (void (*)(int  ))(& alarmInterrupt);
#line 291
    sigemptyset(& act1.sa_mask);
#line 292
    act1.sa_flags = 0;
#line 293
    sigaction(14, (struct sigaction  const  */* __restrict  */)(& act1), (struct sigaction */* __restrict  */)0);
#line 294
    alarm(20U);
    }
  }
#line 298
  if (wordlistfile) {
#line 298
    tmp___8 = 1;
  } else {
#line 298
    tmp___8 = 2;
  }
  {
#line 298
  tmp___9 = initPDFCrack((EncData const   *)e, (uint8_t const   *)userpassword, (_Bool const   )work_with_user,
                         (char const   *)wordlistfile, (passwordMethod const   )tmp___8,
                         wordlist, (char const   *)charset___1, (unsigned int const   )((unsigned int )minpw),
                         (unsigned int const   )((unsigned int )maxpw), (_Bool const   )permutation___0);
  }
#line 298
  if (! tmp___9) {
    {
#line 301
    cleanPDFCrack();
#line 302
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wrong userpassword, \'%s\'\n",
            userpassword);
#line 303
    ret___0 = 7;
    }
#line 304
    goto out2;
  }
  {
#line 308
  runCrack();
#line 312
  cleanPDFCrack();
#line 313
  freeEncData(e);
  }
#line 315
  if (wordlistfile) {
    {
#line 316
    fclose(wordlist);
#line 317
    free((void *)wordlistfile);
    }
  }
#line 319
  if (inputfile) {
    {
#line 320
    free((void *)inputfile);
    }
  }
#line 321
  if (charset___1) {
    {
#line 322
    free((void *)charset___1);
    }
  }
#line 323
  if (userpassword) {
    {
#line 324
    free((void *)userpassword);
    }
  }
#line 326
  return (0);
  out1: 
  {
#line 329
  tmp___10 = fclose(file);
  }
#line 329
  if (tmp___10) {
    {
#line 330
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: closing file %s\n",
            inputfile);
    }
  }
  out2: 
  {
#line 332
  freeEncData(e);
  }
  out3: 
#line 334
  if (inputfile) {
    {
#line 335
    free((void *)inputfile);
    }
  }
#line 336
  if (charset___1) {
    {
#line 337
    free((void *)charset___1);
    }
  }
#line 338
  if (userpassword) {
    {
#line 339
    free((void *)userpassword);
    }
  }
  {
#line 341
  exit(ret___0);
  }
}
}
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 25 "/home/wheatley/newnew/temp/pdfcrack-0.12/rc4.h"
__inline void rc4Decrypt(uint8_t const   *key , uint8_t const   *bs , unsigned int const   len ,
                         uint8_t *out ) ;
#line 29
_Bool __attribute__((__pure__))  rc4Match40b(uint8_t const   *key , uint8_t const   *bs ,
                                             uint8_t const   *match ) ;
#line 32
_Bool __attribute__((__pure__))  setrc4DecryptMethod(unsigned int const   length ) ;
#line 29 "/home/wheatley/newnew/temp/pdfcrack-0.12/rc4.c"
static uint8_t const   initial_state[256]  = 
#line 29 "/home/wheatley/newnew/temp/pdfcrack-0.12/rc4.c"
  {      (uint8_t const   )0,      (uint8_t const   )1,      (uint8_t const   )2,      (uint8_t const   )3, 
        (uint8_t const   )4,      (uint8_t const   )5,      (uint8_t const   )6,      (uint8_t const   )7, 
        (uint8_t const   )8,      (uint8_t const   )9,      (uint8_t const   )10,      (uint8_t const   )11, 
        (uint8_t const   )12,      (uint8_t const   )13,      (uint8_t const   )14,      (uint8_t const   )15, 
        (uint8_t const   )16,      (uint8_t const   )17,      (uint8_t const   )18,      (uint8_t const   )19, 
        (uint8_t const   )20,      (uint8_t const   )21,      (uint8_t const   )22,      (uint8_t const   )23, 
        (uint8_t const   )24,      (uint8_t const   )25,      (uint8_t const   )26,      (uint8_t const   )27, 
        (uint8_t const   )28,      (uint8_t const   )29,      (uint8_t const   )30,      (uint8_t const   )31, 
        (uint8_t const   )32,      (uint8_t const   )33,      (uint8_t const   )34,      (uint8_t const   )35, 
        (uint8_t const   )36,      (uint8_t const   )37,      (uint8_t const   )38,      (uint8_t const   )39, 
        (uint8_t const   )40,      (uint8_t const   )41,      (uint8_t const   )42,      (uint8_t const   )43, 
        (uint8_t const   )44,      (uint8_t const   )45,      (uint8_t const   )46,      (uint8_t const   )47, 
        (uint8_t const   )48,      (uint8_t const   )49,      (uint8_t const   )50,      (uint8_t const   )51, 
        (uint8_t const   )52,      (uint8_t const   )53,      (uint8_t const   )54,      (uint8_t const   )55, 
        (uint8_t const   )56,      (uint8_t const   )57,      (uint8_t const   )58,      (uint8_t const   )59, 
        (uint8_t const   )60,      (uint8_t const   )61,      (uint8_t const   )62,      (uint8_t const   )63, 
        (uint8_t const   )64,      (uint8_t const   )65,      (uint8_t const   )66,      (uint8_t const   )67, 
        (uint8_t const   )68,      (uint8_t const   )69,      (uint8_t const   )70,      (uint8_t const   )71, 
        (uint8_t const   )72,      (uint8_t const   )73,      (uint8_t const   )74,      (uint8_t const   )75, 
        (uint8_t const   )76,      (uint8_t const   )77,      (uint8_t const   )78,      (uint8_t const   )79, 
        (uint8_t const   )80,      (uint8_t const   )81,      (uint8_t const   )82,      (uint8_t const   )83, 
        (uint8_t const   )84,      (uint8_t const   )85,      (uint8_t const   )86,      (uint8_t const   )87, 
        (uint8_t const   )88,      (uint8_t const   )89,      (uint8_t const   )90,      (uint8_t const   )91, 
        (uint8_t const   )92,      (uint8_t const   )93,      (uint8_t const   )94,      (uint8_t const   )95, 
        (uint8_t const   )96,      (uint8_t const   )97,      (uint8_t const   )98,      (uint8_t const   )99, 
        (uint8_t const   )100,      (uint8_t const   )101,      (uint8_t const   )102,      (uint8_t const   )103, 
        (uint8_t const   )104,      (uint8_t const   )105,      (uint8_t const   )106,      (uint8_t const   )107, 
        (uint8_t const   )108,      (uint8_t const   )109,      (uint8_t const   )110,      (uint8_t const   )111, 
        (uint8_t const   )112,      (uint8_t const   )113,      (uint8_t const   )114,      (uint8_t const   )115, 
        (uint8_t const   )116,      (uint8_t const   )117,      (uint8_t const   )118,      (uint8_t const   )119, 
        (uint8_t const   )120,      (uint8_t const   )121,      (uint8_t const   )122,      (uint8_t const   )123, 
        (uint8_t const   )124,      (uint8_t const   )125,      (uint8_t const   )126,      (uint8_t const   )127, 
        (uint8_t const   )128,      (uint8_t const   )129,      (uint8_t const   )130,      (uint8_t const   )131, 
        (uint8_t const   )132,      (uint8_t const   )133,      (uint8_t const   )134,      (uint8_t const   )135, 
        (uint8_t const   )136,      (uint8_t const   )137,      (uint8_t const   )138,      (uint8_t const   )139, 
        (uint8_t const   )140,      (uint8_t const   )141,      (uint8_t const   )142,      (uint8_t const   )143, 
        (uint8_t const   )144,      (uint8_t const   )145,      (uint8_t const   )146,      (uint8_t const   )147, 
        (uint8_t const   )148,      (uint8_t const   )149,      (uint8_t const   )150,      (uint8_t const   )151, 
        (uint8_t const   )152,      (uint8_t const   )153,      (uint8_t const   )154,      (uint8_t const   )155, 
        (uint8_t const   )156,      (uint8_t const   )157,      (uint8_t const   )158,      (uint8_t const   )159, 
        (uint8_t const   )160,      (uint8_t const   )161,      (uint8_t const   )162,      (uint8_t const   )163, 
        (uint8_t const   )164,      (uint8_t const   )165,      (uint8_t const   )166,      (uint8_t const   )167, 
        (uint8_t const   )168,      (uint8_t const   )169,      (uint8_t const   )170,      (uint8_t const   )171, 
        (uint8_t const   )172,      (uint8_t const   )173,      (uint8_t const   )174,      (uint8_t const   )175, 
        (uint8_t const   )176,      (uint8_t const   )177,      (uint8_t const   )178,      (uint8_t const   )179, 
        (uint8_t const   )180,      (uint8_t const   )181,      (uint8_t const   )182,      (uint8_t const   )183, 
        (uint8_t const   )184,      (uint8_t const   )185,      (uint8_t const   )186,      (uint8_t const   )187, 
        (uint8_t const   )188,      (uint8_t const   )189,      (uint8_t const   )190,      (uint8_t const   )191, 
        (uint8_t const   )192,      (uint8_t const   )193,      (uint8_t const   )194,      (uint8_t const   )195, 
        (uint8_t const   )196,      (uint8_t const   )197,      (uint8_t const   )198,      (uint8_t const   )199, 
        (uint8_t const   )200,      (uint8_t const   )201,      (uint8_t const   )202,      (uint8_t const   )203, 
        (uint8_t const   )204,      (uint8_t const   )205,      (uint8_t const   )206,      (uint8_t const   )207, 
        (uint8_t const   )208,      (uint8_t const   )209,      (uint8_t const   )210,      (uint8_t const   )211, 
        (uint8_t const   )212,      (uint8_t const   )213,      (uint8_t const   )214,      (uint8_t const   )215, 
        (uint8_t const   )216,      (uint8_t const   )217,      (uint8_t const   )218,      (uint8_t const   )219, 
        (uint8_t const   )220,      (uint8_t const   )221,      (uint8_t const   )222,      (uint8_t const   )223, 
        (uint8_t const   )224,      (uint8_t const   )225,      (uint8_t const   )226,      (uint8_t const   )227, 
        (uint8_t const   )228,      (uint8_t const   )229,      (uint8_t const   )230,      (uint8_t const   )231, 
        (uint8_t const   )232,      (uint8_t const   )233,      (uint8_t const   )234,      (uint8_t const   )235, 
        (uint8_t const   )236,      (uint8_t const   )237,      (uint8_t const   )238,      (uint8_t const   )239, 
        (uint8_t const   )240,      (uint8_t const   )241,      (uint8_t const   )242,      (uint8_t const   )243, 
        (uint8_t const   )244,      (uint8_t const   )245,      (uint8_t const   )246,      (uint8_t const   )247, 
        (uint8_t const   )248,      (uint8_t const   )249,      (uint8_t const   )250,      (uint8_t const   )251, 
        (uint8_t const   )252,      (uint8_t const   )253,      (uint8_t const   )254,      (uint8_t const   )255};
#line 62 "/home/wheatley/newnew/temp/pdfcrack-0.12/rc4.c"
_Bool __attribute__((__pure__))  rc4Match40b(uint8_t const   *key , uint8_t const   *bs ,
                                             uint8_t const   *match ) 
{ 
  uint8_t state[256] ;
  register unsigned int i ;
  register uint8_t j ;
  register uint8_t tmp ;
  long tmp___0 ;

  {
  {
#line 69
  memcpy((void */* __restrict  */)(state), (void const   */* __restrict  */)(initial_state),
         (size_t )256);
#line 72
  j = (uint8_t )*(key + 0);
#line 73
  state[0] = j;
#line 74
  state[j] = (uint8_t )0;
#line 75
  i = 0U;
  }
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 77
    i ++;
#line 77
    tmp = state[i];
#line 77
    j = (uint8_t )(((int )j + (int )tmp) + (int )*(key + 1));
#line 77
    state[i] = state[j];
#line 77
    state[j] = tmp;
#line 78
    i ++;
#line 78
    tmp = state[i];
#line 78
    j = (uint8_t )(((int )j + (int )tmp) + (int )*(key + 2));
#line 78
    state[i] = state[j];
#line 78
    state[j] = tmp;
#line 79
    i ++;
#line 79
    tmp = state[i];
#line 79
    j = (uint8_t )(((int )j + (int )tmp) + (int )*(key + 3));
#line 79
    state[i] = state[j];
#line 79
    state[j] = tmp;
#line 80
    i ++;
#line 80
    tmp = state[i];
#line 80
    j = (uint8_t )(((int )j + (int )tmp) + (int )*(key + 4));
#line 80
    state[i] = state[j];
#line 80
    state[j] = tmp;
#line 81
    i ++;
#line 81
    tmp = state[i];
#line 81
    j = (uint8_t )(((int )j + (int )tmp) + (int )*(key + 0));
#line 81
    state[i] = state[j];
#line 81
    state[j] = tmp;
#line 76
    if (! (i < 255U)) {
#line 76
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 84
  j = (uint8_t )0;
#line 85
  i = 1U;
  {
#line 85
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 85
    if (! (i <= 32U)) {
#line 85
      goto while_break___0;
    }
    {
#line 86
    tmp = state[i];
#line 87
    j = (uint8_t )((int )j + (int )tmp);
#line 88
    state[i] = state[j];
#line 89
    state[j] = tmp;
#line 96
    tmp = (uint8_t )((int )tmp + (int )state[i]);
#line 97
    tmp___0 = __builtin_expect((long )(((int const   )*(bs + (i - 1U)) ^ (int const   )state[tmp]) != (int const   )*(match + (i - 1U))),
                               1L);
    }
#line 97
    if (tmp___0) {
#line 98
      return ((_Bool __attribute__((__pure__))  )0);
    }
#line 85
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 100
  return ((_Bool __attribute__((__pure__))  )1);
}
}
#line 103 "/home/wheatley/newnew/temp/pdfcrack-0.12/rc4.c"
static void (*rc4d)(uint8_t const   *key , uint8_t const   *bs , unsigned int const   len ,
                    uint8_t *out )  =    (void (*)(uint8_t const   *key , uint8_t const   *bs , unsigned int const   len ,
             uint8_t *out ))((void *)0);
#line 110 "/home/wheatley/newnew/temp/pdfcrack-0.12/rc4.c"
static void rc4Decrypt40b(uint8_t const   *key , uint8_t const   *bs , unsigned int const   len ,
                          uint8_t *out ) 
{ 
  uint8_t state[256] ;
  register unsigned int i ;
  register uint8_t j ;
  register uint8_t tmp ;

  {
  {
#line 118
  memcpy((void */* __restrict  */)(state), (void const   */* __restrict  */)(initial_state),
         (size_t )256);
#line 121
  j = (uint8_t )*(key + 0);
#line 122
  state[0] = j;
#line 123
  state[j] = (uint8_t )0;
#line 124
  i = 0U;
  }
  {
#line 125
  while (1) {
    while_continue: /* CIL Label */ ;
#line 126
    i ++;
#line 126
    tmp = state[i];
#line 126
    j = (uint8_t )(((int )j + (int )tmp) + (int )*(key + 1));
#line 126
    state[i] = state[j];
#line 126
    state[j] = tmp;
#line 127
    i ++;
#line 127
    tmp = state[i];
#line 127
    j = (uint8_t )(((int )j + (int )tmp) + (int )*(key + 2));
#line 127
    state[i] = state[j];
#line 127
    state[j] = tmp;
#line 128
    i ++;
#line 128
    tmp = state[i];
#line 128
    j = (uint8_t )(((int )j + (int )tmp) + (int )*(key + 3));
#line 128
    state[i] = state[j];
#line 128
    state[j] = tmp;
#line 129
    i ++;
#line 129
    tmp = state[i];
#line 129
    j = (uint8_t )(((int )j + (int )tmp) + (int )*(key + 4));
#line 129
    state[i] = state[j];
#line 129
    state[j] = tmp;
#line 130
    i ++;
#line 130
    tmp = state[i];
#line 130
    j = (uint8_t )(((int )j + (int )tmp) + (int )*(key + 0));
#line 130
    state[i] = state[j];
#line 130
    state[j] = tmp;
#line 125
    if (! (i < 255U)) {
#line 125
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 133
  j = (uint8_t )0;
#line 134
  i = 1U;
  {
#line 134
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 134
    if (! (i <= (unsigned int )len)) {
#line 134
      goto while_break___0;
    }
#line 135
    tmp = state[i];
#line 136
    j = (uint8_t )((int )j + (int )tmp);
#line 137
    state[i] = state[j];
#line 138
    state[j] = tmp;
#line 140
    tmp = (uint8_t )((int )tmp + (int )state[i]);
#line 141
    *(out + (i - 1U)) = (uint8_t )((int const   )*(bs + (i - 1U)) ^ (int const   )state[tmp]);
#line 134
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 143
  return;
}
}
#line 148 "/home/wheatley/newnew/temp/pdfcrack-0.12/rc4.c"
static void rc4Decrypt128b(uint8_t const   *key , uint8_t const   *bs , unsigned int const   len ,
                           uint8_t *out ) 
{ 
  uint8_t state[256] ;
  register int i ;
  register uint8_t j ;
  register uint8_t tmp ;

  {
  {
#line 156
  memcpy((void */* __restrict  */)(state), (void const   */* __restrict  */)(initial_state),
         (size_t )256);
#line 159
  j = (uint8_t )0;
#line 160
  i = -1;
  }
  {
#line 161
  while (1) {
    while_continue: /* CIL Label */ ;
#line 162
    i ++;
#line 162
    tmp = state[i];
#line 162
    j = (uint8_t )(((int )j + (int )tmp) + (int )*(key + 0));
#line 162
    state[i] = state[j];
#line 162
    state[j] = tmp;
#line 163
    i ++;
#line 163
    tmp = state[i];
#line 163
    j = (uint8_t )(((int )j + (int )tmp) + (int )*(key + 1));
#line 163
    state[i] = state[j];
#line 163
    state[j] = tmp;
#line 164
    i ++;
#line 164
    tmp = state[i];
#line 164
    j = (uint8_t )(((int )j + (int )tmp) + (int )*(key + 2));
#line 164
    state[i] = state[j];
#line 164
    state[j] = tmp;
#line 165
    i ++;
#line 165
    tmp = state[i];
#line 165
    j = (uint8_t )(((int )j + (int )tmp) + (int )*(key + 3));
#line 165
    state[i] = state[j];
#line 165
    state[j] = tmp;
#line 166
    i ++;
#line 166
    tmp = state[i];
#line 166
    j = (uint8_t )(((int )j + (int )tmp) + (int )*(key + 4));
#line 166
    state[i] = state[j];
#line 166
    state[j] = tmp;
#line 167
    i ++;
#line 167
    tmp = state[i];
#line 167
    j = (uint8_t )(((int )j + (int )tmp) + (int )*(key + 5));
#line 167
    state[i] = state[j];
#line 167
    state[j] = tmp;
#line 168
    i ++;
#line 168
    tmp = state[i];
#line 168
    j = (uint8_t )(((int )j + (int )tmp) + (int )*(key + 6));
#line 168
    state[i] = state[j];
#line 168
    state[j] = tmp;
#line 169
    i ++;
#line 169
    tmp = state[i];
#line 169
    j = (uint8_t )(((int )j + (int )tmp) + (int )*(key + 7));
#line 169
    state[i] = state[j];
#line 169
    state[j] = tmp;
#line 170
    i ++;
#line 170
    tmp = state[i];
#line 170
    j = (uint8_t )(((int )j + (int )tmp) + (int )*(key + 8));
#line 170
    state[i] = state[j];
#line 170
    state[j] = tmp;
#line 171
    i ++;
#line 171
    tmp = state[i];
#line 171
    j = (uint8_t )(((int )j + (int )tmp) + (int )*(key + 9));
#line 171
    state[i] = state[j];
#line 171
    state[j] = tmp;
#line 172
    i ++;
#line 172
    tmp = state[i];
#line 172
    j = (uint8_t )(((int )j + (int )tmp) + (int )*(key + 10));
#line 172
    state[i] = state[j];
#line 172
    state[j] = tmp;
#line 173
    i ++;
#line 173
    tmp = state[i];
#line 173
    j = (uint8_t )(((int )j + (int )tmp) + (int )*(key + 11));
#line 173
    state[i] = state[j];
#line 173
    state[j] = tmp;
#line 174
    i ++;
#line 174
    tmp = state[i];
#line 174
    j = (uint8_t )(((int )j + (int )tmp) + (int )*(key + 12));
#line 174
    state[i] = state[j];
#line 174
    state[j] = tmp;
#line 175
    i ++;
#line 175
    tmp = state[i];
#line 175
    j = (uint8_t )(((int )j + (int )tmp) + (int )*(key + 13));
#line 175
    state[i] = state[j];
#line 175
    state[j] = tmp;
#line 176
    i ++;
#line 176
    tmp = state[i];
#line 176
    j = (uint8_t )(((int )j + (int )tmp) + (int )*(key + 14));
#line 176
    state[i] = state[j];
#line 176
    state[j] = tmp;
#line 177
    i ++;
#line 177
    tmp = state[i];
#line 177
    j = (uint8_t )(((int )j + (int )tmp) + (int )*(key + 15));
#line 177
    state[i] = state[j];
#line 177
    state[j] = tmp;
#line 161
    if (! (i < 255)) {
#line 161
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 180
  j = (uint8_t )0;
#line 181
  i = 1;
  {
#line 181
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 181
    if (! ((unsigned int )i <= (unsigned int )len)) {
#line 181
      goto while_break___0;
    }
#line 182
    tmp = state[i];
#line 183
    j = (uint8_t )((int )j + (int )tmp);
#line 184
    state[i] = state[j];
#line 185
    state[j] = tmp;
#line 187
    tmp = (uint8_t )((int )tmp + (int )state[i]);
#line 188
    *(out + (i - 1)) = (uint8_t )((int const   )*(bs + (i - 1)) ^ (int const   )state[tmp]);
#line 181
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 190
  return;
}
}
#line 192 "/home/wheatley/newnew/temp/pdfcrack-0.12/rc4.c"
static int keyLen  ;
#line 194 "/home/wheatley/newnew/temp/pdfcrack-0.12/rc4.c"
static void rc4DecryptArb(uint8_t const   *key , uint8_t const   *bs , unsigned int const   len ,
                          uint8_t *out ) 
{ 
  uint8_t state[256] ;
  register unsigned int i ;
  register uint8_t j ;
  register uint8_t tmp ;

  {
  {
#line 202
  memcpy((void */* __restrict  */)(state), (void const   */* __restrict  */)(initial_state),
         (size_t )256);
#line 205
  j = (uint8_t )0;
#line 206
  i = 4294967295U;
  }
  {
#line 207
  while (1) {
    while_continue: /* CIL Label */ ;
#line 208
    i ++;
#line 208
    tmp = state[i];
#line 208
    j = (uint8_t )(((int )j + (int )tmp) + (int )*(key + i % (unsigned int )keyLen));
#line 208
    state[i] = state[j];
#line 208
    state[j] = tmp;
#line 207
    if (! (i < 255U)) {
#line 207
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 211
  j = (uint8_t )0;
#line 212
  i = 1U;
  {
#line 212
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 212
    if (! (i <= (unsigned int )len)) {
#line 212
      goto while_break___0;
    }
#line 213
    tmp = state[i];
#line 214
    j = (uint8_t )((int )j + (int )tmp);
#line 215
    state[i] = state[j];
#line 216
    state[j] = tmp;
#line 217
    tmp = (uint8_t )((int )tmp + (int )state[i]);
#line 218
    *(out + (i - 1U)) = (uint8_t )((int const   )*(bs + (i - 1U)) ^ (int const   )state[tmp]);
#line 212
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 220
  return;
}
}
#line 223 "/home/wheatley/newnew/temp/pdfcrack-0.12/rc4.c"
__inline void rc4Decrypt(uint8_t const   *key , uint8_t const   *bs , unsigned int const   len ,
                         uint8_t *out ) 
{ 


  {
  {
#line 226
  (*rc4d)(key, bs, len, out);
  }
#line 227
  return;
}
}
#line 230 "/home/wheatley/newnew/temp/pdfcrack-0.12/rc4.c"
_Bool __attribute__((__pure__))  setrc4DecryptMethod(unsigned int const   length ) 
{ 


  {
#line 232
  if (! (length < 256U)) {
    {
#line 232
    __assert_fail("length < 256", "/home/wheatley/newnew/temp/pdfcrack-0.12/rc4.c",
                  232U, "setrc4DecryptMethod");
    }
  }
#line 233
  if (! (length % 8U == 0U)) {
    {
#line 233
    __assert_fail("(length % 8) == 0", "/home/wheatley/newnew/temp/pdfcrack-0.12/rc4.c",
                  233U, "setrc4DecryptMethod");
    }
  }
#line 235
  if (length == 128U) {
#line 236
    rc4d = & rc4Decrypt128b;
  } else
#line 238
  if (length == 40U) {
#line 239
    rc4d = & rc4Decrypt40b;
  } else {
#line 242
    keyLen = (int )(length / 8U);
#line 243
    rc4d = & rc4DecryptArb;
  }
#line 245
  return ((_Bool __attribute__((__pure__))  )1);
}
}
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 749 "/usr/include/stdio.h"
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 754
extern long ftell(FILE *__stream ) ;
#line 759
extern void rewind(FILE *__stream ) ;
#line 35 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfparser.c"
__inline static _Bool __attribute__((__pure__))  isWhiteSpace(int const   ch ) 
{ 
  int tmp ;

  {
#line 37
  if (ch == 32) {
#line 37
    tmp = 1;
  } else
#line 37
  if (ch >= 9) {
#line 37
    if (ch <= 13) {
#line 37
      tmp = 1;
    } else {
#line 37
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 37
  if (ch == 0) {
#line 37
    tmp = 1;
  } else {
#line 37
    tmp = 0;
  }
#line 37
  return ((_Bool __attribute__((__pure__))  )tmp);
}
}
#line 40 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfparser.c"
static _Bool __attribute__((__pure__))  isDelimiter(int const   ch ) 
{ 


  {
  {
#line 52
  if (ch == 37) {
#line 52
    goto case_37;
  }
#line 52
  if (ch == 47) {
#line 52
    goto case_37;
  }
#line 52
  if (ch == 125) {
#line 52
    goto case_37;
  }
#line 52
  if (ch == 123) {
#line 52
    goto case_37;
  }
#line 52
  if (ch == 93) {
#line 52
    goto case_37;
  }
#line 52
  if (ch == 91) {
#line 52
    goto case_37;
  }
#line 52
  if (ch == 62) {
#line 52
    goto case_37;
  }
#line 52
  if (ch == 60) {
#line 52
    goto case_37;
  }
#line 52
  if (ch == 41) {
#line 52
    goto case_37;
  }
#line 52
  if (ch == 40) {
#line 52
    goto case_37;
  }
#line 54
  goto switch_default;
  case_37: /* CIL Label */ 
  case_47: /* CIL Label */ 
  case_125: /* CIL Label */ 
  case_123: /* CIL Label */ 
  case_93: /* CIL Label */ 
  case_91: /* CIL Label */ 
  case_62: /* CIL Label */ 
  case_60: /* CIL Label */ 
  case_41: /* CIL Label */ 
  case_40: /* CIL Label */ 
#line 53
  return ((_Bool __attribute__((__pure__))  )1);
  switch_default: /* CIL Label */ 
#line 55
  return ((_Bool __attribute__((__pure__))  )0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 59 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfparser.c"
__inline static _Bool __attribute__((__pure__))  isEndOfLine(int const   ch ) 
{ 
  int tmp ;

  {
#line 61
  if (ch == 10) {
#line 61
    tmp = 1;
  } else
#line 61
  if (ch == 13) {
#line 61
    tmp = 1;
  } else {
#line 61
    tmp = 0;
  }
#line 61
  return ((_Bool __attribute__((__pure__))  )tmp);
}
}
#line 64 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfparser.c"
static int parseIntWithC(FILE *file , int const   c ) 
{ 
  _Bool neg ;
  int i ;
  int ch ;

  {
#line 66
  neg = (_Bool)0;
#line 67
  i = 0;
#line 68
  ch = (int )c;
#line 70
  if (ch == 45) {
    {
#line 71
    neg = (_Bool)1;
#line 72
    ch = _IO_getc(file);
    }
  } else
#line 74
  if (ch == 43) {
    {
#line 75
    ch = _IO_getc(file);
    }
  }
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    if (ch >= 48) {
#line 76
      if (! (ch <= 57)) {
#line 76
        goto while_break;
      }
    } else {
#line 76
      goto while_break;
    }
    {
#line 77
    i *= 10;
#line 78
    i += ch - 48;
#line 79
    ch = _IO_getc(file);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 81
  ungetc(ch, file);
  }
#line 82
  if (neg) {
#line 83
    i *= -1;
  }
#line 85
  return (i);
}
}
#line 88 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfparser.c"
static int parseInt(FILE *file ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 90
  tmp = _IO_getc(file);
#line 90
  tmp___0 = parseIntWithC(file, (int const   )tmp);
  }
#line 90
  return (tmp___0);
}
}
#line 94 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfparser.c"
static char parseWhiteSpace(FILE *file ) 
{ 
  int ch ;
  _Bool __attribute__((__pure__))  tmp ;

  {
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 98
    ch = _IO_getc(file);
#line 97
    tmp = isWhiteSpace((int const   )ch);
    }
#line 97
    if (! tmp) {
#line 97
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 100
  return ((char )ch);
}
}
#line 103 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfparser.c"
static char *parseName(FILE *file ) 
{ 
  int ch ;
  unsigned int i ;
  char *ret___0 ;
  char buff[256] ;
  char tmp ;
  _Bool __attribute__((__pure__))  tmp___0 ;
  _Bool __attribute__((__pure__))  tmp___1 ;
  unsigned int tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 110
  tmp = parseWhiteSpace(file);
#line 110
  ch = (int )tmp;
  }
#line 112
  if (ch != 47) {
    {
#line 113
    ungetc(ch, file);
    }
#line 114
    return ((char *)((void *)0));
  }
  {
#line 116
  ch = _IO_getc(file);
#line 117
  i = 0U;
  }
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (i < 256U) {
      {
#line 117
      tmp___0 = isWhiteSpace((int const   )ch);
      }
#line 117
      if (tmp___0) {
#line 117
        goto while_break;
      } else {
        {
#line 117
        tmp___1 = isDelimiter((int const   )ch);
        }
#line 117
        if (tmp___1) {
#line 117
          goto while_break;
        } else
#line 117
        if (! (ch != -1)) {
#line 117
          goto while_break;
        }
      }
    } else {
#line 117
      goto while_break;
    }
    {
#line 119
    buff[i] = (char )ch;
#line 120
    ch = _IO_getc(file);
#line 117
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 122
  ungetc(ch, file);
#line 123
  tmp___2 = i;
#line 123
  i ++;
#line 123
  buff[tmp___2] = (char )'\000';
#line 124
  tmp___3 = malloc(sizeof(char ) * (unsigned long )i);
#line 124
  ret___0 = (char *)tmp___3;
#line 125
  memcpy((void */* __restrict  */)ret___0, (void const   */* __restrict  */)(buff),
         (size_t )i);
  }
#line 126
  return (ret___0);
}
}
#line 150 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfparser.c"
static _Bool isWord(FILE *file , char const   *str ) 
{ 
  int ch ;
  unsigned int i ;
  size_t tmp ;

  {
#line 154
  i = 0U;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 154
    tmp = strlen(str);
    }
#line 154
    if (! ((size_t )i < tmp)) {
#line 154
      goto while_break;
    }
    {
#line 155
    ch = _IO_getc(file);
    }
#line 155
    if (ch != (int )*(str + i)) {
#line 156
      goto ret;
    }
#line 154
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 157
  return ((_Bool)1);
  ret: 
  {
#line 159
  ungetc(ch, file);
  }
#line 160
  return ((_Bool)0);
}
}
#line 163 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfparser.c"
_Bool openPDF(FILE *file , EncData *e ) 
{ 
  _Bool ret___0 ;
  int minor_v ;
  int major_v ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 165
  ret___0 = (_Bool)0;
#line 166
  minor_v = 0;
#line 166
  major_v = 0;
#line 167
  tmp___0 = _IO_getc(file);
  }
#line 167
  if (tmp___0 == 37) {
    {
#line 167
    tmp___1 = _IO_getc(file);
    }
#line 167
    if (tmp___1 == 80) {
      {
#line 167
      tmp___2 = _IO_getc(file);
      }
#line 167
      if (tmp___2 == 68) {
        {
#line 167
        tmp___3 = _IO_getc(file);
        }
#line 167
        if (tmp___3 == 70) {
          {
#line 167
          tmp___4 = _IO_getc(file);
          }
#line 167
          if (tmp___4 == 45) {
            {
#line 169
            major_v = parseInt(file);
#line 170
            tmp = _IO_getc(file);
            }
#line 170
            if (tmp == 46) {
              {
#line 171
              minor_v = parseInt(file);
              }
            }
#line 172
            if (major_v >= 0) {
#line 173
              ret___0 = (_Bool)1;
            }
          }
        }
      }
    }
  }
#line 176
  if (ret___0) {
#line 177
    e->version_major = (unsigned int )major_v;
#line 178
    e->version_minor = (unsigned int )minor_v;
  }
#line 180
  return (ret___0);
}
}
#line 183 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfparser.c"
static uint8_t __attribute__((__pure__))  hexToInt(int const   b ) 
{ 


  {
#line 185
  if (b >= 48) {
#line 185
    if (b <= 57) {
#line 186
      return ((uint8_t __attribute__((__pure__))  )(b - 48));
    } else {
#line 185
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 187
  if (b >= 97) {
#line 187
    if (b <= 102) {
#line 188
      return ((uint8_t __attribute__((__pure__))  )((b - 97) + 10));
    } else {
#line 187
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 189
  if (b >= 65) {
#line 189
    if (b <= 70) {
#line 190
      return ((uint8_t __attribute__((__pure__))  )((b - 65) + 10));
    } else {
#line 192
      return ((uint8_t __attribute__((__pure__))  )0);
    }
  } else {
#line 192
    return ((uint8_t __attribute__((__pure__))  )0);
  }
}
}
#line 195 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfparser.c"
static p_str *parseHexString(uint8_t const   *buf , unsigned int const   len ) 
{ 
  unsigned int i ;
  unsigned int j ;
  p_str *ret___0 ;
  void *tmp ;
  void *tmp___0 ;
  uint8_t __attribute__((__pure__))  tmp___1 ;
  uint8_t __attribute__((__pure__))  tmp___2 ;

  {
  {
#line 200
  tmp = malloc(sizeof(p_str ));
#line 200
  ret___0 = (p_str *)tmp;
#line 201
  tmp___0 = malloc(sizeof(uint8_t ) * (unsigned long )(len / 2U));
#line 201
  ret___0->content = (uint8_t *)tmp___0;
#line 202
  ret___0->len = (uint8_t )(len / 2U);
#line 204
  i = 0U;
#line 204
  j = 0U;
  }
  {
#line 204
  while (1) {
    while_continue: /* CIL Label */ ;
#line 204
    if (! (i < (unsigned int )len)) {
#line 204
      goto while_break;
    }
    {
#line 205
    tmp___1 = hexToInt((int const   )*(buf + i));
#line 205
    *(ret___0->content + j) = (uint8_t )((int __attribute__((__pure__))  )tmp___1 * (int __attribute__((__pure__))  )16);
#line 206
    tmp___2 = hexToInt((int const   )*(buf + (i + 1U)));
#line 206
    *(ret___0->content + j) = (uint8_t )((int )*(ret___0->content + j) + (int )tmp___2);
#line 207
    j ++;
#line 204
    i += 2U;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 210
  return (ret___0);
}
}
#line 213 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfparser.c"
static p_str *objStringToByte(uint8_t const   *str , unsigned int const   len ) 
{ 
  unsigned int i ;
  unsigned int j ;
  unsigned int l ;
  uint8_t b ;
  uint8_t d ;
  uint8_t *tmp ;
  unsigned long __lengthoftmp ;
  void *tmp___0 ;
  p_str *ret___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 217
  __lengthoftmp = (unsigned long )len;
#line 217
  tmp___0 = __builtin_alloca(sizeof(*tmp) * __lengthoftmp);
#line 217
  tmp = (uint8_t *)tmp___0;
#line 220
  i = 0U;
#line 220
  l = 0U;
  }
  {
#line 220
  while (1) {
    while_continue: /* CIL Label */ ;
#line 220
    if (! (i < (unsigned int )len)) {
#line 220
      goto while_break;
    }
#line 221
    b = (uint8_t )*(str + i);
#line 222
    if ((int )b == 92) {
#line 227
      i ++;
      {
#line 229
      if ((int const   )*(str + i) == 110) {
#line 229
        goto case_110;
      }
#line 232
      if ((int const   )*(str + i) == 114) {
#line 232
        goto case_114;
      }
#line 235
      if ((int const   )*(str + i) == 116) {
#line 235
        goto case_116;
      }
#line 238
      if ((int const   )*(str + i) == 98) {
#line 238
        goto case_98;
      }
#line 241
      if ((int const   )*(str + i) == 102) {
#line 241
        goto case_102;
      }
#line 244
      if ((int const   )*(str + i) == 40) {
#line 244
        goto case_40;
      }
#line 247
      if ((int const   )*(str + i) == 41) {
#line 247
        goto case_41;
      }
#line 250
      if ((int const   )*(str + i) == 92) {
#line 250
        goto case_92;
      }
#line 253
      goto switch_default;
      case_110: /* CIL Label */ 
#line 230
      b = (uint8_t )10;
#line 231
      goto switch_break;
      case_114: /* CIL Label */ 
#line 233
      b = (uint8_t )13;
#line 234
      goto switch_break;
      case_116: /* CIL Label */ 
#line 236
      b = (uint8_t )9;
#line 237
      goto switch_break;
      case_98: /* CIL Label */ 
#line 239
      b = (uint8_t )8;
#line 240
      goto switch_break;
      case_102: /* CIL Label */ 
#line 242
      b = (uint8_t )12;
#line 243
      goto switch_break;
      case_40: /* CIL Label */ 
#line 245
      b = (uint8_t )'(';
#line 246
      goto switch_break;
      case_41: /* CIL Label */ 
#line 248
      b = (uint8_t )')';
#line 249
      goto switch_break;
      case_92: /* CIL Label */ 
#line 251
      b = (uint8_t )'\\';
#line 252
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 254
      if ((int const   )*(str + i) >= 48) {
#line 254
        if ((int const   )*(str + i) < 56) {
#line 255
          d = (uint8_t )0;
#line 256
          j = 0U;
          {
#line 256
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 256
            if (i < (unsigned int )len) {
#line 256
              if (j < 3U) {
#line 256
                if ((int const   )*(str + i) >= 48) {
#line 256
                  if ((int const   )*(str + i) < 56) {
#line 256
                    if (! ((int )d * 8 + (int )((int const   )*(str + i) - 48) < 256)) {
#line 256
                      goto while_break___0;
                    }
                  } else {
#line 256
                    goto while_break___0;
                  }
                } else {
#line 256
                  goto while_break___0;
                }
              } else {
#line 256
                goto while_break___0;
              }
            } else {
#line 256
              goto while_break___0;
            }
#line 259
            d = (uint8_t )((int )d * 8);
#line 260
            d = (uint8_t )((int )d + (int )((int const   )*(str + i) - 48));
#line 256
            j ++;
#line 256
            i ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 266
          if (i < (unsigned int )len) {
#line 267
            i --;
          } else
#line 266
          if (j < 3U) {
#line 267
            i --;
          }
#line 270
          b = d;
        }
      }
      switch_break: /* CIL Label */ ;
      }
    }
#line 274
    *(tmp + l) = b;
#line 220
    i ++;
#line 220
    l ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 277
  tmp___1 = malloc(sizeof(p_str ));
#line 277
  ret___0 = (p_str *)tmp___1;
#line 278
  tmp___2 = malloc(sizeof(uint8_t ) * (unsigned long )l);
#line 278
  ret___0->content = (uint8_t *)tmp___2;
#line 279
  ret___0->len = (uint8_t )(l - 1U);
#line 281
  memcpy((void */* __restrict  */)ret___0->content, (void const   */* __restrict  */)tmp,
         (size_t )l);
  }
#line 283
  return (ret___0);
}
}
#line 286 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfparser.c"
static p_str *parseRegularString(FILE *file ) 
{ 
  unsigned int len ;
  unsigned int p ;
  int ch ;
  p_str *ret___0 ;
  uint8_t buf[256] ;
  _Bool skip ;
  char tmp ;
  unsigned int tmp___0 ;

  {
  {
#line 292
  skip = (_Bool)0;
#line 294
  tmp = parseWhiteSpace(file);
#line 294
  ch = (int )tmp;
  }
#line 295
  if (ch == 40) {
    {
#line 296
    p = 1U;
#line 297
    ch = _IO_getc(file);
#line 298
    len = 0U;
    }
    {
#line 298
    while (1) {
      while_continue: /* CIL Label */ ;
#line 298
      if (len < 256U) {
#line 298
        if (p > 0U) {
#line 298
          if (! (ch != -1)) {
#line 298
            goto while_break;
          }
        } else {
#line 298
          goto while_break;
        }
      } else {
#line 298
        goto while_break;
      }
#line 299
      buf[len] = (uint8_t )ch;
#line 300
      if ((int )skip == 0) {
#line 301
        if (ch == 40) {
#line 302
          p ++;
        } else
#line 303
        if (ch == 41) {
#line 304
          p --;
        }
#line 305
        if (ch == 92) {
#line 306
          skip = (_Bool)1;
        }
      } else {
#line 309
        skip = (_Bool)0;
      }
      {
#line 310
      ch = _IO_getc(file);
#line 298
      len ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 312
    ungetc(ch, file);
#line 313
    ret___0 = objStringToByte((uint8_t const   *)(buf), (unsigned int const   )len);
    }
  } else
#line 315
  if (ch == 60) {
#line 316
    len = 0U;
    {
#line 317
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 317
      if (ch != 62) {
#line 317
        if (len < 256U) {
#line 317
          if (! (ch != -1)) {
#line 317
            goto while_break___0;
          }
        } else {
#line 317
          goto while_break___0;
        }
      } else {
#line 317
        goto while_break___0;
      }
#line 318
      if (ch >= 48) {
#line 318
        if (ch <= 57) {
#line 321
          tmp___0 = len;
#line 321
          len ++;
#line 321
          buf[tmp___0] = (uint8_t )ch;
        } else {
#line 318
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 318
      if (ch >= 97) {
#line 318
        if (ch <= 102) {
#line 321
          tmp___0 = len;
#line 321
          len ++;
#line 321
          buf[tmp___0] = (uint8_t )ch;
        } else {
#line 318
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 318
      if (ch >= 65) {
#line 318
        if (ch <= 70) {
#line 321
          tmp___0 = len;
#line 321
          len ++;
#line 321
          buf[tmp___0] = (uint8_t )ch;
        }
      }
      {
#line 323
      ch = _IO_getc(file);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 325
    ungetc(ch, file);
#line 326
    ret___0 = parseHexString((uint8_t const   *)(buf), (unsigned int const   )len);
    }
  } else {
#line 329
    ret___0 = (p_str *)((void *)0);
  }
#line 330
  return (ret___0);
}
}
#line 333 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfparser.c"
static int findTrailerDict(FILE *file , EncData *e ) 
{ 
  int ch ;
  _Bool encrypt ;
  _Bool id ;
  int e_pos ;
  p_str *str ;
  int dict ;
  char tmp ;
  char tmp___0 ;
  char tmp___1 ;
  int tmp___2 ;
  _Bool tmp___3 ;
  int tmp___4 ;
  _Bool __attribute__((__pure__))  tmp___5 ;

  {
  {
#line 337
  encrypt = (_Bool)0;
#line 338
  id = (_Bool)0;
#line 339
  e_pos = -1;
#line 340
  str = (p_str *)((void *)0);
#line 341
  dict = 0;
#line 343
  ch = _IO_getc(file);
  }
  {
#line 344
  while (1) {
    while_continue: /* CIL Label */ ;
#line 344
    if (! (ch != -1)) {
#line 344
      goto while_break;
    }
    {
#line 345
    tmp___5 = isEndOfLine((int const   )ch);
    }
#line 345
    if (tmp___5) {
      {
#line 346
      tmp = parseWhiteSpace(file);
#line 346
      ch = (int )tmp;
      }
#line 347
      if (ch == 60) {
        {
#line 347
        tmp___4 = _IO_getc(file);
        }
#line 347
        if (tmp___4 == 60) {
          {
#line 354
          ch = _IO_getc(file);
          }
          {
#line 355
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 355
            if (! (ch != -1)) {
#line 355
              goto while_break___0;
            }
#line 356
            if (ch == 60) {
              {
#line 357
              ch = _IO_getc(file);
              }
#line 358
              if (ch == 60) {
#line 359
                dict ++;
              }
            }
#line 362
            if (ch == 62) {
              {
#line 363
              ch = _IO_getc(file);
              }
#line 364
              if (ch == 62) {
#line 365
                if (dict == 0) {
#line 366
                  goto while_break___0;
                }
              }
#line 368
              dict --;
            }
            {
#line 370
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 370
              if (ch != 47) {
#line 370
                if (! (ch != -1)) {
#line 370
                  goto while_break___1;
                }
              } else {
#line 370
                goto while_break___1;
              }
              {
#line 371
              ch = _IO_getc(file);
              }
            }
            while_break___1: /* CIL Label */ ;
            }
            {
#line 373
            ch = _IO_getc(file);
            }
#line 375
            if (e_pos < 0) {
#line 375
              if (ch == 69) {
                {
#line 375
                tmp___3 = isWord(file, "ncrypt");
                }
#line 375
                if (tmp___3) {
                  {
#line 376
                  tmp___0 = parseWhiteSpace(file);
#line 376
                  e_pos = parseIntWithC(file, (int const   )tmp___0);
                  }
#line 377
                  if (e_pos >= 0) {
#line 383
                    encrypt = (_Bool)1;
                  }
                } else {
#line 375
                  goto _L___0;
                }
              } else {
#line 375
                goto _L___0;
              }
            } else
            _L___0: /* CIL Label */ 
#line 386
            if (ch == 73) {
              {
#line 386
              tmp___2 = _IO_getc(file);
              }
#line 386
              if (tmp___2 == 68) {
                {
#line 387
                tmp___1 = parseWhiteSpace(file);
#line 387
                ch = (int )tmp___1;
                }
                {
#line 388
                while (1) {
                  while_continue___2: /* CIL Label */ ;
#line 388
                  if (ch != 91) {
#line 388
                    if (! (ch != -1)) {
#line 388
                      goto while_break___2;
                    }
                  } else {
#line 388
                    goto while_break___2;
                  }
                  {
#line 389
                  ch = _IO_getc(file);
                  }
                }
                while_break___2: /* CIL Label */ ;
                }
#line 391
                if (str) {
#line 392
                  if (str->content) {
                    {
#line 393
                    free((void *)str->content);
                    }
                  }
                  {
#line 394
                  free((void *)str);
                  }
                }
                {
#line 397
                str = parseRegularString(file);
                }
#line 402
                if (str) {
#line 403
                  id = (_Bool)1;
                }
                {
#line 404
                ch = _IO_getc(file);
                }
              } else {
                {
#line 407
                ch = _IO_getc(file);
                }
              }
            } else {
              {
#line 407
              ch = _IO_getc(file);
              }
            }
#line 408
            if (encrypt) {
#line 408
              if (id) {
                {
#line 410
                e->fileID = str->content;
#line 411
                e->fileIDLen = (unsigned int )str->len;
#line 412
                free((void *)str);
                }
#line 413
                return (e_pos);
              }
            }
          }
          while_break___0: /* CIL Label */ ;
          }
        } else {
          {
#line 418
          ch = _IO_getc(file);
          }
        }
      } else {
        {
#line 418
        ch = _IO_getc(file);
        }
      }
    } else {
      {
#line 422
      ch = _IO_getc(file);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 426
  if (str) {
#line 427
    if (str->content) {
      {
#line 428
      free((void *)str->content);
      }
    }
    {
#line 429
    free((void *)str);
    }
  }
#line 432
  if (! encrypt) {
#line 432
    if (id) {
#line 433
      return (-3);
    } else {
#line 432
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 434
  if (! id) {
#line 434
    if (encrypt) {
#line 440
      return (e_pos);
    } else {
#line 443
      return (-2);
    }
  } else {
#line 443
    return (-2);
  }
}
}
#line 447 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfparser.c"
static int findTrailer(FILE *file , EncData *e ) 
{ 
  int ch ;
  _Bool encrypt ;
  _Bool id ;
  int e_pos ;
  p_str *str ;
  char tmp ;
  char tmp___0 ;
  char tmp___1 ;
  int tmp___2 ;
  _Bool tmp___3 ;
  int tmp___4 ;
  _Bool tmp___5 ;
  _Bool __attribute__((__pure__))  tmp___6 ;

  {
  {
#line 451
  encrypt = (_Bool)0;
#line 452
  id = (_Bool)0;
#line 453
  e_pos = -1;
#line 454
  str = (p_str *)((void *)0);
#line 456
  ch = _IO_getc(file);
  }
  {
#line 457
  while (1) {
    while_continue: /* CIL Label */ ;
#line 457
    if (! (ch != -1)) {
#line 457
      goto while_break;
    }
    {
#line 458
    tmp___6 = isEndOfLine((int const   )ch);
    }
#line 458
    if (tmp___6) {
      {
#line 459
      tmp___5 = isWord(file, "trailer");
      }
#line 459
      if (tmp___5) {
        {
#line 461
        tmp = parseWhiteSpace(file);
#line 461
        ch = (int )tmp;
        }
#line 462
        if (ch == 60) {
          {
#line 462
          tmp___4 = _IO_getc(file);
          }
#line 462
          if (tmp___4 == 60) {
            {
#line 470
            ch = _IO_getc(file);
            }
            {
#line 471
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 471
              if (! (ch != -1)) {
#line 471
                goto while_break___0;
              }
#line 472
              if (ch == 62) {
                {
#line 473
                ch = _IO_getc(file);
                }
#line 474
                if (ch == 62) {
#line 475
                  goto while_break___0;
                }
              }
              {
#line 477
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 477
                if (ch != 47) {
#line 477
                  if (! (ch != -1)) {
#line 477
                    goto while_break___1;
                  }
                } else {
#line 477
                  goto while_break___1;
                }
                {
#line 478
                ch = _IO_getc(file);
                }
              }
              while_break___1: /* CIL Label */ ;
              }
              {
#line 480
              ch = _IO_getc(file);
              }
#line 482
              if (e_pos < 0) {
#line 482
                if (ch == 69) {
                  {
#line 482
                  tmp___3 = isWord(file, "ncrypt");
                  }
#line 482
                  if (tmp___3) {
                    {
#line 483
                    tmp___0 = parseWhiteSpace(file);
#line 483
                    e_pos = parseIntWithC(file, (int const   )tmp___0);
                    }
#line 484
                    if (e_pos >= 0) {
#line 490
                      encrypt = (_Bool)1;
                    }
                  } else {
#line 482
                    goto _L___0;
                  }
                } else {
#line 482
                  goto _L___0;
                }
              } else
              _L___0: /* CIL Label */ 
#line 493
              if (ch == 73) {
                {
#line 493
                tmp___2 = _IO_getc(file);
                }
#line 493
                if (tmp___2 == 68) {
                  {
#line 494
                  tmp___1 = parseWhiteSpace(file);
#line 494
                  ch = (int )tmp___1;
                  }
                  {
#line 495
                  while (1) {
                    while_continue___2: /* CIL Label */ ;
#line 495
                    if (ch != 91) {
#line 495
                      if (! (ch != -1)) {
#line 495
                        goto while_break___2;
                      }
                    } else {
#line 495
                      goto while_break___2;
                    }
                    {
#line 496
                    ch = _IO_getc(file);
                    }
                  }
                  while_break___2: /* CIL Label */ ;
                  }
#line 498
                  if (str) {
#line 499
                    if (str->content) {
                      {
#line 500
                      free((void *)str->content);
                      }
                    }
                    {
#line 501
                    free((void *)str);
                    }
                  }
                  {
#line 504
                  str = parseRegularString(file);
                  }
#line 509
                  if (str) {
#line 510
                    id = (_Bool)1;
                  }
                  {
#line 511
                  ch = _IO_getc(file);
                  }
                } else {
                  {
#line 514
                  ch = _IO_getc(file);
                  }
                }
              } else {
                {
#line 514
                ch = _IO_getc(file);
                }
              }
#line 515
              if (encrypt) {
#line 515
                if (id) {
                  {
#line 517
                  e->fileID = str->content;
#line 518
                  e->fileIDLen = (unsigned int )str->len;
#line 519
                  free((void *)str);
                  }
#line 520
                  return (e_pos);
                }
              }
            }
            while_break___0: /* CIL Label */ ;
            }
          }
        }
      } else {
        {
#line 526
        ch = _IO_getc(file);
        }
      }
    } else {
      {
#line 530
      ch = _IO_getc(file);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 534
  if (str) {
#line 535
    if (str->content) {
      {
#line 536
      free((void *)str->content);
      }
    }
    {
#line 537
    free((void *)str);
    }
  }
#line 540
  if (! encrypt) {
#line 540
    if (id) {
#line 541
      return (-3);
    } else {
#line 540
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 542
  if (! id) {
#line 542
    if (encrypt) {
#line 548
      return (e_pos);
    } else {
#line 551
      return (-2);
    }
  } else {
#line 551
    return (-2);
  }
}
}
#line 554 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfparser.c"
static _Bool parseEncrypObject(FILE *file , EncData *e ) 
{ 
  int ch ;
  int dict ;
  _Bool fe ;
  _Bool ff ;
  _Bool fl ;
  _Bool fo ;
  _Bool fp ;
  _Bool fr ;
  _Bool fu ;
  _Bool fv ;
  _Bool cf ;
  _Bool aesv2 ;
  p_str *str ;
  _Bool tmp ;
  _Bool tmp___0 ;
  char tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  char *s_handler ;
  char *tmp___4 ;
  _Bool tmp___5 ;
  int tmp_l ;
  char tmp___6 ;
  int tmp___7 ;
  _Bool tmp___8 ;
  char tmp___9 ;
  _Bool __attribute__((__pure__))  tmp___10 ;
  char tmp___11 ;
  _Bool __attribute__((__pure__))  tmp___12 ;
  char tmp___13 ;
  _Bool __attribute__((__pure__))  tmp___14 ;
  char tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
  {
#line 556
  dict = 1;
#line 557
  fe = (_Bool)0;
#line 558
  ff = (_Bool)0;
#line 559
  fl = (_Bool)0;
#line 560
  fo = (_Bool)0;
#line 561
  fp = (_Bool)0;
#line 562
  fr = (_Bool)0;
#line 563
  fu = (_Bool)0;
#line 564
  fv = (_Bool)0;
#line 565
  cf = (_Bool)0;
#line 566
  aesv2 = (_Bool)0;
#line 567
  str = (p_str *)((void *)0);
#line 569
  ch = _IO_getc(file);
  }
  {
#line 570
  while (1) {
    while_continue: /* CIL Label */ ;
#line 570
    if (! (ch != -1)) {
#line 570
      goto while_break;
    }
#line 571
    if (ch == 62) {
      {
#line 572
      ch = _IO_getc(file);
      }
#line 573
      if (ch == 62) {
#line 574
        dict --;
#line 575
        if (dict <= 0) {
#line 576
          goto while_break;
        }
      }
    } else
#line 579
    if (ch == 60) {
      {
#line 580
      ch = _IO_getc(file);
      }
#line 581
      if (ch == 60) {
#line 582
        dict ++;
      }
    }
#line 585
    if (dict > 1) {
      {
#line 586
      ch = _IO_getc(file);
      }
#line 587
      if (ch == 47) {
        {
#line 588
        ch = _IO_getc(file);
        }
        {
#line 590
        if (ch == 65) {
#line 590
          goto case_65;
        }
#line 596
        goto switch_default;
        case_65: /* CIL Label */ 
        {
#line 591
        tmp = isWord(file, "ESV2");
        }
#line 591
        if (tmp) {
#line 592
          aesv2 = (_Bool)1;
        }
#line 594
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 597
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
#line 600
      goto while_continue;
    }
#line 603
    if (ch == 47) {
      {
#line 604
      ch = _IO_getc(file);
      }
      {
#line 606
      if (ch == 67) {
#line 606
        goto case_67;
      }
#line 611
      if (ch == 69) {
#line 611
        goto case_69;
      }
#line 618
      if (ch == 70) {
#line 618
        goto case_70;
      }
#line 627
      if (ch == 76) {
#line 627
        goto case_76;
      }
#line 641
      if (ch == 79) {
#line 641
        goto case_79;
      }
#line 651
      if (ch == 80) {
#line 651
        goto case_80;
      }
#line 659
      if (ch == 82) {
#line 659
        goto case_82;
      }
#line 667
      if (ch == 85) {
#line 667
        goto case_85;
      }
#line 677
      if (ch == 86) {
#line 677
        goto case_86;
      }
#line 684
      goto switch_default___0;
      case_67: /* CIL Label */ 
      {
#line 607
      tmp___0 = isWord(file, "F");
      }
#line 607
      if (tmp___0) {
#line 608
        cf = (_Bool)1;
      }
#line 610
      goto switch_break___0;
      case_69: /* CIL Label */ 
      {
#line 612
      tmp___3 = isWord(file, "ncryptMetadata");
      }
#line 612
      if (tmp___3) {
        {
#line 613
        tmp___1 = parseWhiteSpace(file);
#line 613
        ungetc((int )tmp___1, file);
#line 614
        tmp___2 = isWord(file, "false");
        }
#line 614
        if (tmp___2) {
#line 615
          fe = (_Bool)1;
        }
      }
#line 617
      goto switch_break___0;
      case_70: /* CIL Label */ 
      {
#line 619
      tmp___5 = isWord(file, "ilter");
      }
#line 619
      if (tmp___5) {
        {
#line 620
        tmp___4 = parseName(file);
#line 620
        s_handler = tmp___4;
        }
#line 621
        if ((unsigned long )s_handler != (unsigned long )((void *)0)) {
#line 622
          e->s_handler = s_handler;
#line 623
          ff = (_Bool)1;
        }
#line 625
        goto switch_break___0;
      }
      case_76: /* CIL Label */ 
      {
#line 628
      tmp___8 = isWord(file, "ength");
      }
#line 628
      if (tmp___8) {
        {
#line 629
        tmp___6 = parseWhiteSpace(file);
#line 629
        tmp___7 = parseIntWithC(file, (int const   )tmp___6);
#line 629
        tmp_l = tmp___7;
        }
#line 630
        if (! fl) {
#line 633
          if (tmp_l > 128) {
#line 633
            if (tmp_l < 40) {
#line 633
              if (tmp_l % 8 != 0) {
                {
#line 634
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING: Length = %d\n",
                        tmp_l);
                }
              }
            }
          }
#line 636
          e->length = tmp_l;
        }
#line 638
        fl = (_Bool)1;
      }
#line 640
      goto switch_break___0;
      case_79: /* CIL Label */ 
      {
#line 642
      str = parseRegularString(file);
      }
#line 643
      if (! str) {
#line 644
        goto switch_break___0;
      }
#line 645
      if ((int )str->len != 32) {
        {
#line 646
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING: O-String != 32 Bytes: %d\n",
                (int )str->len);
        }
      }
      {
#line 647
      e->o_string = str->content;
#line 648
      free((void *)str);
#line 649
      fo = (_Bool)1;
      }
#line 650
      goto switch_break___0;
      case_80: /* CIL Label */ 
      {
#line 652
      ch = _IO_getc(file);
#line 653
      tmp___10 = isWhiteSpace((int const   )ch);
      }
#line 653
      if (tmp___10) {
        {
#line 654
        tmp___9 = parseWhiteSpace(file);
#line 654
        ch = (int )tmp___9;
#line 655
        e->permissions = parseIntWithC(file, (int const   )ch);
#line 656
        fp = (_Bool)1;
        }
      }
#line 658
      goto switch_break___0;
      case_82: /* CIL Label */ 
      {
#line 660
      ch = _IO_getc(file);
#line 661
      tmp___12 = isWhiteSpace((int const   )ch);
      }
#line 661
      if (tmp___12) {
        {
#line 662
        tmp___11 = parseWhiteSpace(file);
#line 662
        ch = (int )tmp___11;
#line 663
        e->revision = parseIntWithC(file, (int const   )ch);
#line 664
        fr = (_Bool)1;
        }
      }
#line 666
      goto switch_break___0;
      case_85: /* CIL Label */ 
      {
#line 668
      str = parseRegularString(file);
      }
#line 669
      if (! str) {
#line 670
        goto switch_break___0;
      }
#line 671
      if ((int )str->len != 32) {
        {
#line 672
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"WARNING: U-String != 32 Bytes: %d\n",
                (int )str->len);
        }
      }
      {
#line 673
      e->u_string = str->content;
#line 674
      free((void *)str);
#line 675
      fu = (_Bool)1;
      }
#line 676
      goto switch_break___0;
      case_86: /* CIL Label */ 
      {
#line 678
      ch = _IO_getc(file);
#line 679
      tmp___14 = isWhiteSpace((int const   )ch);
      }
#line 679
      if (tmp___14) {
        {
#line 680
        tmp___13 = parseWhiteSpace(file);
#line 680
        e->version = parseIntWithC(file, (int const   )tmp___13);
#line 681
        fv = (_Bool)1;
        }
      }
#line 683
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
#line 685
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
    {
#line 688
    tmp___15 = parseWhiteSpace(file);
#line 688
    ch = (int )tmp___15;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 690
  printf((char const   */* __restrict  */)"\n");
  }
#line 692
  if (! fe) {
#line 693
    e->encryptMetaData = (_Bool)1;
  }
#line 694
  if (! fl) {
#line 695
    e->length = 40;
  }
#line 696
  if (! fv) {
#line 697
    e->version = 0;
  }
#line 699
  if (fr) {
#line 699
    if (cf) {
#line 699
      if (aesv2) {
#line 700
        e->revision = 3;
#line 701
        e->version = 2;
      }
    }
  }
  {
#line 704
  tmp___16 = strcmp((char const   *)e->s_handler, "Standard");
  }
#line 704
  if (tmp___16 != 0) {
#line 705
    return ((_Bool)1);
  }
#line 707
  if ((int )ff & (int )fo) {
#line 707
    if (fp) {
#line 707
      if (fr) {
#line 707
        if (fu) {
#line 707
          tmp___17 = 1;
        } else {
#line 707
          tmp___17 = 0;
        }
      } else {
#line 707
        tmp___17 = 0;
      }
    } else {
#line 707
      tmp___17 = 0;
    }
  } else {
#line 707
    tmp___17 = 0;
  }
#line 707
  return ((_Bool )tmp___17);
}
}
#line 714 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfparser.c"
static _Bool findEncryptObject(FILE *file , int const   e_pos , EncData *e ) 
{ 
  int ch ;
  char tmp ;
  char tmp___0 ;
  _Bool tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  _Bool __attribute__((__pure__))  tmp___7 ;

  {
#line 719
  if (e_pos < 0) {
#line 720
    return ((_Bool)0);
  }
  {
#line 722
  ch = _IO_getc(file);
  }
  {
#line 723
  while (1) {
    while_continue: /* CIL Label */ ;
#line 723
    if (! (ch != -1)) {
#line 723
      goto while_break;
    }
    {
#line 724
    tmp___7 = isEndOfLine((int const   )ch);
    }
#line 724
    if (tmp___7) {
      {
#line 725
      tmp___6 = parseInt(file);
      }
#line 725
      if (tmp___6 == (int )e_pos) {
        {
#line 726
        tmp = parseWhiteSpace(file);
#line 726
        ch = (int )tmp;
        }
#line 727
        if (ch >= 48) {
#line 727
          if (ch <= 57) {
            {
#line 728
            tmp___0 = parseWhiteSpace(file);
#line 728
            ch = (int )tmp___0;
            }
#line 729
            if (ch == 111) {
              {
#line 729
              tmp___2 = _IO_getc(file);
              }
#line 729
              if (tmp___2 == 98) {
                {
#line 729
                tmp___3 = _IO_getc(file);
                }
#line 729
                if (tmp___3 == 106) {
                  {
#line 729
                  tmp___4 = parseWhiteSpace(file);
                  }
#line 729
                  if ((int )tmp___4 == 60) {
                    {
#line 729
                    tmp___5 = _IO_getc(file);
                    }
#line 729
                    if (tmp___5 == 60) {
                      {
#line 731
                      ftell(file);
#line 732
                      tmp___1 = parseEncrypObject(file, e);
                      }
#line 732
                      return (tmp___1);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    {
#line 737
    ch = _IO_getc(file);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 739
  return ((_Bool)0);
}
}
#line 743 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfparser.c"
int getEncryptedInfo(FILE *file , EncData *e ) 
{ 
  int e_pos ;
  _Bool ret___0 ;
  int tmp ;

  {
  {
#line 745
  e_pos = -1;
#line 748
  tmp = fseek(file, 0L, -1022);
  }
#line 748
  if (tmp) {
    {
#line 749
    e_pos = findTrailer(file, e);
    }
  }
#line 750
  if (e_pos < 0) {
    {
#line 751
    rewind(file);
#line 752
    e_pos = findTrailer(file, e);
    }
  }
#line 754
  if (e_pos < 0) {
    {
#line 755
    rewind(file);
#line 756
    e_pos = findTrailerDict(file, e);
    }
  }
#line 759
  if (e_pos < 0) {
#line 760
    return (e_pos);
  }
  {
#line 762
  rewind(file);
#line 763
  ret___0 = findEncryptObject(file, (int const   )e_pos, e);
  }
#line 764
  if (! ret___0) {
#line 765
    return (-1);
  }
#line 767
  return (0);
}
}
#line 24 "/home/wheatley/newnew/temp/pdfcrack-0.12/md5.h"
void md5(uint8_t const   *msg , unsigned int const   msgLen , uint8_t *digest ) ;
#line 27
void md5_50(uint8_t *msg ) ;
#line 50 "/home/wheatley/newnew/temp/pdfcrack-0.12/md5.c"
void md5(uint8_t const   *msg , unsigned int const   msgLen , uint8_t *digest ) 
{ 
  uint32_t x[16] ;
  register uint32_t a ;
  register uint32_t b ;
  register uint32_t c ;
  register uint32_t d ;
  uint32_t aa ;
  uint32_t bb ;
  uint32_t cc ;
  uint32_t dd ;
  int n64 ;
  int i ;
  int j ;
  unsigned int k ;
  int tmp ;

  {
#line 61
  n64 = (int )((msgLen + 72U) / 64U);
#line 64
  a = (uint32_t )1732584193;
#line 65
  b = 4023233417U;
#line 66
  c = 2562383102U;
#line 67
  d = (uint32_t )271733878;
#line 70
  k = 0U;
#line 71
  i = 0;
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
#line 71
    if (! (i < n64)) {
#line 71
      goto while_break;
    }
#line 74
    j = 0;
    {
#line 74
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 74
      if (j < 16) {
#line 74
        if (! (k < (unsigned int )(msgLen - 3U))) {
#line 74
          goto while_break___0;
        }
      } else {
#line 74
        goto while_break___0;
      }
#line 75
      x[j] = (uint32_t )(((((((int const   )*(msg + (k + 3U)) << 8) + (int const   )*(msg + (k + 2U))) << 8) + (int const   )*(msg + (k + 1U))) << 8) + (int const   )*(msg + k));
#line 74
      j ++;
#line 74
      k += 4U;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 76
    if (i == n64 - 1) {
#line 77
      if (k == (unsigned int )(msgLen - 3U)) {
#line 78
        x[j] = (2147483648U + (unsigned int )((((int const   )*(msg + (k + 2U)) << 8) + (int const   )*(msg + (k + 1U))) << 8)) + (unsigned int )*(msg + k);
      } else
#line 79
      if (k == (unsigned int )(msgLen - 2U)) {
#line 80
        x[j] = (uint32_t )((8388608 + (int )((int const   )*(msg + (k + 1U)) << 8)) + (int )*(msg + k));
      } else
#line 81
      if (k == (unsigned int )(msgLen - 1U)) {
#line 82
        x[j] = (uint32_t )(32768 + (int )*(msg + k));
      } else {
#line 84
        x[j] = (uint32_t )128;
      }
#line 85
      j ++;
      {
#line 86
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 86
        if (! (j < 16)) {
#line 86
          goto while_break___1;
        }
#line 87
        tmp = j;
#line 87
        j ++;
#line 87
        x[tmp] = (uint32_t )0;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 88
      x[14] = (uint32_t )(msgLen << 3);
    }
#line 92
    aa = a;
#line 93
    bb = b;
#line 94
    cc = c;
#line 95
    dd = d;
#line 98
    a += ((d ^ (b & (c ^ d))) + x[0]) + 3614090360U;
#line 98
    a = (a << 7) | (a >> 25);
#line 98
    a += b;
#line 99
    d += ((c ^ (a & (b ^ c))) + x[1]) + 3905402710U;
#line 99
    d = (d << 12) | (d >> 20);
#line 99
    d += a;
#line 100
    c += ((b ^ (d & (a ^ b))) + x[2]) + 606105819U;
#line 100
    c = (c << 17) | (c >> 15);
#line 100
    c += d;
#line 101
    b += ((a ^ (c & (d ^ a))) + x[3]) + 3250441966U;
#line 101
    b = (b << 22) | (b >> 10);
#line 101
    b += c;
#line 102
    a += ((d ^ (b & (c ^ d))) + x[4]) + 4118548399U;
#line 102
    a = (a << 7) | (a >> 25);
#line 102
    a += b;
#line 103
    d += ((c ^ (a & (b ^ c))) + x[5]) + 1200080426U;
#line 103
    d = (d << 12) | (d >> 20);
#line 103
    d += a;
#line 104
    c += ((b ^ (d & (a ^ b))) + x[6]) + 2821735955U;
#line 104
    c = (c << 17) | (c >> 15);
#line 104
    c += d;
#line 105
    b += ((a ^ (c & (d ^ a))) + x[7]) + 4249261313U;
#line 105
    b = (b << 22) | (b >> 10);
#line 105
    b += c;
#line 106
    a += ((d ^ (b & (c ^ d))) + x[8]) + 1770035416U;
#line 106
    a = (a << 7) | (a >> 25);
#line 106
    a += b;
#line 107
    d += ((c ^ (a & (b ^ c))) + x[9]) + 2336552879U;
#line 107
    d = (d << 12) | (d >> 20);
#line 107
    d += a;
#line 108
    c += ((b ^ (d & (a ^ b))) + x[10]) + 4294925233U;
#line 108
    c = (c << 17) | (c >> 15);
#line 108
    c += d;
#line 109
    b += ((a ^ (c & (d ^ a))) + x[11]) + 2304563134U;
#line 109
    b = (b << 22) | (b >> 10);
#line 109
    b += c;
#line 110
    a += ((d ^ (b & (c ^ d))) + x[12]) + 1804603682U;
#line 110
    a = (a << 7) | (a >> 25);
#line 110
    a += b;
#line 111
    d += ((c ^ (a & (b ^ c))) + x[13]) + 4254626195U;
#line 111
    d = (d << 12) | (d >> 20);
#line 111
    d += a;
#line 112
    c += ((b ^ (d & (a ^ b))) + x[14]) + 2792965006U;
#line 112
    c = (c << 17) | (c >> 15);
#line 112
    c += d;
#line 113
    b += ((a ^ (c & (d ^ a))) + x[15]) + 1236535329U;
#line 113
    b = (b << 22) | (b >> 10);
#line 113
    b += c;
#line 116
    a += ((c ^ (d & (b ^ c))) + x[1]) + 4129170786U;
#line 116
    a = (a << 5) | (a >> 27);
#line 116
    a += b;
#line 117
    d += ((b ^ (c & (a ^ b))) + x[6]) + 3225465664U;
#line 117
    d = (d << 9) | (d >> 23);
#line 117
    d += a;
#line 118
    c += ((a ^ (b & (d ^ a))) + x[11]) + 643717713U;
#line 118
    c = (c << 14) | (c >> 18);
#line 118
    c += d;
#line 119
    b += ((d ^ (a & (c ^ d))) + x[0]) + 3921069994U;
#line 119
    b = (b << 20) | (b >> 12);
#line 119
    b += c;
#line 120
    a += ((c ^ (d & (b ^ c))) + x[5]) + 3593408605U;
#line 120
    a = (a << 5) | (a >> 27);
#line 120
    a += b;
#line 121
    d += ((b ^ (c & (a ^ b))) + x[10]) + 38016083U;
#line 121
    d = (d << 9) | (d >> 23);
#line 121
    d += a;
#line 122
    c += ((a ^ (b & (d ^ a))) + x[15]) + 3634488961U;
#line 122
    c = (c << 14) | (c >> 18);
#line 122
    c += d;
#line 123
    b += ((d ^ (a & (c ^ d))) + x[4]) + 3889429448U;
#line 123
    b = (b << 20) | (b >> 12);
#line 123
    b += c;
#line 124
    a += ((c ^ (d & (b ^ c))) + x[9]) + 568446438U;
#line 124
    a = (a << 5) | (a >> 27);
#line 124
    a += b;
#line 125
    d += ((b ^ (c & (a ^ b))) + x[14]) + 3275163606U;
#line 125
    d = (d << 9) | (d >> 23);
#line 125
    d += a;
#line 126
    c += ((a ^ (b & (d ^ a))) + x[3]) + 4107603335U;
#line 126
    c = (c << 14) | (c >> 18);
#line 126
    c += d;
#line 127
    b += ((d ^ (a & (c ^ d))) + x[8]) + 1163531501U;
#line 127
    b = (b << 20) | (b >> 12);
#line 127
    b += c;
#line 128
    a += ((c ^ (d & (b ^ c))) + x[13]) + 2850285829U;
#line 128
    a = (a << 5) | (a >> 27);
#line 128
    a += b;
#line 129
    d += ((b ^ (c & (a ^ b))) + x[2]) + 4243563512U;
#line 129
    d = (d << 9) | (d >> 23);
#line 129
    d += a;
#line 130
    c += ((a ^ (b & (d ^ a))) + x[7]) + 1735328473U;
#line 130
    c = (c << 14) | (c >> 18);
#line 130
    c += d;
#line 131
    b += ((d ^ (a & (c ^ d))) + x[12]) + 2368359562U;
#line 131
    b = (b << 20) | (b >> 12);
#line 131
    b += c;
#line 134
    a += (((b ^ c) ^ d) + x[5]) + 4294588738U;
#line 134
    a = (a << 4) | (a >> 28);
#line 134
    a += b;
#line 135
    d += (((a ^ b) ^ c) + x[8]) + 2272392833U;
#line 135
    d = (d << 11) | (d >> 21);
#line 135
    d += a;
#line 136
    c += (((d ^ a) ^ b) + x[11]) + 1839030562U;
#line 136
    c = (c << 16) | (c >> 16);
#line 136
    c += d;
#line 137
    b += (((c ^ d) ^ a) + x[14]) + 4259657740U;
#line 137
    b = (b << 23) | (b >> 9);
#line 137
    b += c;
#line 138
    a += (((b ^ c) ^ d) + x[1]) + 2763975236U;
#line 138
    a = (a << 4) | (a >> 28);
#line 138
    a += b;
#line 139
    d += (((a ^ b) ^ c) + x[4]) + 1272893353U;
#line 139
    d = (d << 11) | (d >> 21);
#line 139
    d += a;
#line 140
    c += (((d ^ a) ^ b) + x[7]) + 4139469664U;
#line 140
    c = (c << 16) | (c >> 16);
#line 140
    c += d;
#line 141
    b += (((c ^ d) ^ a) + x[10]) + 3200236656U;
#line 141
    b = (b << 23) | (b >> 9);
#line 141
    b += c;
#line 142
    a += (((b ^ c) ^ d) + x[13]) + 681279174U;
#line 142
    a = (a << 4) | (a >> 28);
#line 142
    a += b;
#line 143
    d += (((a ^ b) ^ c) + x[0]) + 3936430074U;
#line 143
    d = (d << 11) | (d >> 21);
#line 143
    d += a;
#line 144
    c += (((d ^ a) ^ b) + x[3]) + 3572445317U;
#line 144
    c = (c << 16) | (c >> 16);
#line 144
    c += d;
#line 145
    b += (((c ^ d) ^ a) + x[6]) + 76029189U;
#line 145
    b = (b << 23) | (b >> 9);
#line 145
    b += c;
#line 146
    a += (((b ^ c) ^ d) + x[9]) + 3654602809U;
#line 146
    a = (a << 4) | (a >> 28);
#line 146
    a += b;
#line 147
    d += (((a ^ b) ^ c) + x[12]) + 3873151461U;
#line 147
    d = (d << 11) | (d >> 21);
#line 147
    d += a;
#line 148
    c += (((d ^ a) ^ b) + x[15]) + 530742520U;
#line 148
    c = (c << 16) | (c >> 16);
#line 148
    c += d;
#line 149
    b += (((c ^ d) ^ a) + x[2]) + 3299628645U;
#line 149
    b = (b << 23) | (b >> 9);
#line 149
    b += c;
#line 152
    a += ((c ^ (b | ~ d)) + x[0]) + 4096336452U;
#line 152
    a = (a << 6) | (a >> 26);
#line 152
    a += b;
#line 153
    d += ((b ^ (a | ~ c)) + x[7]) + 1126891415U;
#line 153
    d = (d << 10) | (d >> 22);
#line 153
    d += a;
#line 154
    c += ((a ^ (d | ~ b)) + x[14]) + 2878612391U;
#line 154
    c = (c << 15) | (c >> 17);
#line 154
    c += d;
#line 155
    b += ((d ^ (c | ~ a)) + x[5]) + 4237533241U;
#line 155
    b = (b << 21) | (b >> 11);
#line 155
    b += c;
#line 156
    a += ((c ^ (b | ~ d)) + x[12]) + 1700485571U;
#line 156
    a = (a << 6) | (a >> 26);
#line 156
    a += b;
#line 157
    d += ((b ^ (a | ~ c)) + x[3]) + 2399980690U;
#line 157
    d = (d << 10) | (d >> 22);
#line 157
    d += a;
#line 158
    c += ((a ^ (d | ~ b)) + x[10]) + 4293915773U;
#line 158
    c = (c << 15) | (c >> 17);
#line 158
    c += d;
#line 159
    b += ((d ^ (c | ~ a)) + x[1]) + 2240044497U;
#line 159
    b = (b << 21) | (b >> 11);
#line 159
    b += c;
#line 160
    a += ((c ^ (b | ~ d)) + x[8]) + 1873313359U;
#line 160
    a = (a << 6) | (a >> 26);
#line 160
    a += b;
#line 161
    d += ((b ^ (a | ~ c)) + x[15]) + 4264355552U;
#line 161
    d = (d << 10) | (d >> 22);
#line 161
    d += a;
#line 162
    c += ((a ^ (d | ~ b)) + x[6]) + 2734768916U;
#line 162
    c = (c << 15) | (c >> 17);
#line 162
    c += d;
#line 163
    b += ((d ^ (c | ~ a)) + x[13]) + 1309151649U;
#line 163
    b = (b << 21) | (b >> 11);
#line 163
    b += c;
#line 164
    a += ((c ^ (b | ~ d)) + x[4]) + 4149444226U;
#line 164
    a = (a << 6) | (a >> 26);
#line 164
    a += b;
#line 165
    d += ((b ^ (a | ~ c)) + x[11]) + 3174756917U;
#line 165
    d = (d << 10) | (d >> 22);
#line 165
    d += a;
#line 166
    c += ((a ^ (d | ~ b)) + x[2]) + 718787259U;
#line 166
    c = (c << 15) | (c >> 17);
#line 166
    c += d;
#line 167
    b += ((d ^ (c | ~ a)) + x[9]) + 3951481745U;
#line 167
    b = (b << 21) | (b >> 11);
#line 167
    b += c;
#line 170
    a += aa;
#line 171
    b += bb;
#line 172
    c += cc;
#line 173
    d += dd;
#line 71
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 177
  *(digest + 0) = (uint8_t )(a & 255U);
#line 178
  a >>= 8;
#line 178
  *(digest + 1) = (uint8_t )(a & 255U);
#line 179
  a >>= 8;
#line 179
  *(digest + 2) = (uint8_t )(a & 255U);
#line 180
  a >>= 8;
#line 180
  *(digest + 3) = (uint8_t )(a & 255U);
#line 181
  *(digest + 4) = (uint8_t )(b & 255U);
#line 182
  b >>= 8;
#line 182
  *(digest + 5) = (uint8_t )(b & 255U);
#line 183
  b >>= 8;
#line 183
  *(digest + 6) = (uint8_t )(b & 255U);
#line 184
  b >>= 8;
#line 184
  *(digest + 7) = (uint8_t )(b & 255U);
#line 185
  *(digest + 8) = (uint8_t )(c & 255U);
#line 186
  c >>= 8;
#line 186
  *(digest + 9) = (uint8_t )(c & 255U);
#line 187
  c >>= 8;
#line 187
  *(digest + 10) = (uint8_t )(c & 255U);
#line 188
  c >>= 8;
#line 188
  *(digest + 11) = (uint8_t )(c & 255U);
#line 189
  *(digest + 12) = (uint8_t )(d & 255U);
#line 190
  d >>= 8;
#line 190
  *(digest + 13) = (uint8_t )(d & 255U);
#line 191
  d >>= 8;
#line 191
  *(digest + 14) = (uint8_t )(d & 255U);
#line 192
  d >>= 8;
#line 192
  *(digest + 15) = (uint8_t )(d & 255U);
#line 193
  return;
}
}
#line 196 "/home/wheatley/newnew/temp/pdfcrack-0.12/md5.c"
void md5_50(uint8_t *msg ) 
{ 
  register uint32_t a ;
  register uint32_t b ;
  register uint32_t c ;
  register uint32_t d ;
  int i ;
  uint32_t aa ;
  uint32_t bb ;
  uint32_t cc ;
  uint32_t dd ;

  {
#line 201
  a = (uint32_t )(((((((int )*(msg + 3) << 8) + (int )*(msg + 2)) << 8) + (int )*(msg + 1)) << 8) + (int )*(msg + 0));
#line 202
  b = (uint32_t )(((((((int )*(msg + 7) << 8) + (int )*(msg + 6)) << 8) + (int )*(msg + 5)) << 8) + (int )*(msg + 4));
#line 203
  c = (uint32_t )(((((((int )*(msg + 11) << 8) + (int )*(msg + 10)) << 8) + (int )*(msg + 9)) << 8) + (int )*(msg + 8));
#line 204
  d = (uint32_t )(((((((int )*(msg + 15) << 8) + (int )*(msg + 14)) << 8) + (int )*(msg + 13)) << 8) + (int )*(msg + 12));
#line 206
  i = 0;
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 206
    if (! (i < 50)) {
#line 206
      goto while_break;
    }
#line 209
    dd = d;
#line 210
    cc = c;
#line 211
    bb = b;
#line 212
    aa = a;
#line 219
    a += 3614090359U;
#line 220
    a = (a << 7) | (a >> 25);
#line 220
    a += 4023233417U;
#line 221
    d = (4177136588U + b) + (2562383102U ^ (a & 2004318071U));
#line 222
    d = (d << 12) | (d >> 20);
#line 222
    d += a;
#line 223
    c += 3168488921U + (4023233417U ^ (d & (a ^ 4023233417U)));
#line 224
    c = (c << 17) | (c >> 15);
#line 224
    c += d;
#line 225
    b = (2978708087U + dd) + (a ^ (c & (d ^ a)));
#line 226
    b = (b << 22) | (b >> 10);
#line 226
    b += c;
#line 227
    a += ((d ^ (b & (c ^ d))) + 128U) + 4118548399U;
#line 227
    a = (a << 7) | (a >> 25);
#line 227
    a += b;
#line 228
    d += (c ^ (a & (b ^ c))) + 1200080426U;
#line 228
    d = (d << 12) | (d >> 20);
#line 228
    d += a;
#line 229
    c += (b ^ (d & (a ^ b))) + 2821735955U;
#line 229
    c = (c << 17) | (c >> 15);
#line 229
    c += d;
#line 230
    b += (a ^ (c & (d ^ a))) + 4249261313U;
#line 230
    b = (b << 22) | (b >> 10);
#line 230
    b += c;
#line 231
    a += (d ^ (b & (c ^ d))) + 1770035416U;
#line 231
    a = (a << 7) | (a >> 25);
#line 231
    a += b;
#line 232
    d += (c ^ (a & (b ^ c))) + 2336552879U;
#line 232
    d = (d << 12) | (d >> 20);
#line 232
    d += a;
#line 233
    c += (b ^ (d & (a ^ b))) + 4294925233U;
#line 233
    c = (c << 17) | (c >> 15);
#line 233
    c += d;
#line 234
    b += (a ^ (c & (d ^ a))) + 2304563134U;
#line 234
    b = (b << 22) | (b >> 10);
#line 234
    b += c;
#line 235
    a += (d ^ (b & (c ^ d))) + 1804603682U;
#line 235
    a = (a << 7) | (a >> 25);
#line 235
    a += b;
#line 236
    d += (c ^ (a & (b ^ c))) + 4254626195U;
#line 236
    d = (d << 12) | (d >> 20);
#line 236
    d += a;
#line 237
    c += ((b ^ (d & (a ^ b))) + 128U) + 2792965006U;
#line 237
    c = (c << 17) | (c >> 15);
#line 237
    c += d;
#line 238
    b += (a ^ (c & (d ^ a))) + 1236535329U;
#line 238
    b = (b << 22) | (b >> 10);
#line 238
    b += c;
#line 241
    a += ((c ^ (d & (b ^ c))) + bb) + 4129170786U;
#line 241
    a = (a << 5) | (a >> 27);
#line 241
    a += b;
#line 242
    d += (b ^ (c & (a ^ b))) + 3225465664U;
#line 242
    d = (d << 9) | (d >> 23);
#line 242
    d += a;
#line 243
    c += (a ^ (b & (d ^ a))) + 643717713U;
#line 243
    c = (c << 14) | (c >> 18);
#line 243
    c += d;
#line 244
    b += ((d ^ (a & (c ^ d))) + aa) + 3921069994U;
#line 244
    b = (b << 20) | (b >> 12);
#line 244
    b += c;
#line 245
    a += (c ^ (d & (b ^ c))) + 3593408605U;
#line 245
    a = (a << 5) | (a >> 27);
#line 245
    a += b;
#line 246
    d += (b ^ (c & (a ^ b))) + 38016083U;
#line 246
    d = (d << 9) | (d >> 23);
#line 246
    d += a;
#line 247
    c += (a ^ (b & (d ^ a))) + 3634488961U;
#line 247
    c = (c << 14) | (c >> 18);
#line 247
    c += d;
#line 248
    b += ((d ^ (a & (c ^ d))) + 128U) + 3889429448U;
#line 248
    b = (b << 20) | (b >> 12);
#line 248
    b += c;
#line 249
    a += (c ^ (d & (b ^ c))) + 568446438U;
#line 249
    a = (a << 5) | (a >> 27);
#line 249
    a += b;
#line 250
    d += ((b ^ (c & (a ^ b))) + 128U) + 3275163606U;
#line 250
    d = (d << 9) | (d >> 23);
#line 250
    d += a;
#line 251
    c += ((a ^ (b & (d ^ a))) + dd) + 4107603335U;
#line 251
    c = (c << 14) | (c >> 18);
#line 251
    c += d;
#line 252
    b += (d ^ (a & (c ^ d))) + 1163531501U;
#line 252
    b = (b << 20) | (b >> 12);
#line 252
    b += c;
#line 253
    a += (c ^ (d & (b ^ c))) + 2850285829U;
#line 253
    a = (a << 5) | (a >> 27);
#line 253
    a += b;
#line 254
    d += ((b ^ (c & (a ^ b))) + cc) + 4243563512U;
#line 254
    d = (d << 9) | (d >> 23);
#line 254
    d += a;
#line 255
    c += (a ^ (b & (d ^ a))) + 1735328473U;
#line 255
    c = (c << 14) | (c >> 18);
#line 255
    c += d;
#line 256
    b += (d ^ (a & (c ^ d))) + 2368359562U;
#line 256
    b = (b << 20) | (b >> 12);
#line 256
    b += c;
#line 259
    a += ((b ^ c) ^ d) + 4294588738U;
#line 259
    a = (a << 4) | (a >> 28);
#line 259
    a += b;
#line 260
    d += ((a ^ b) ^ c) + 2272392833U;
#line 260
    d = (d << 11) | (d >> 21);
#line 260
    d += a;
#line 261
    c += ((d ^ a) ^ b) + 1839030562U;
#line 261
    c = (c << 16) | (c >> 16);
#line 261
    c += d;
#line 262
    b += (((c ^ d) ^ a) + 128U) + 4259657740U;
#line 262
    b = (b << 23) | (b >> 9);
#line 262
    b += c;
#line 263
    a += (((b ^ c) ^ d) + bb) + 2763975236U;
#line 263
    a = (a << 4) | (a >> 28);
#line 263
    a += b;
#line 264
    d += (((a ^ b) ^ c) + 128U) + 1272893353U;
#line 264
    d = (d << 11) | (d >> 21);
#line 264
    d += a;
#line 265
    c += ((d ^ a) ^ b) + 4139469664U;
#line 265
    c = (c << 16) | (c >> 16);
#line 265
    c += d;
#line 266
    b += ((c ^ d) ^ a) + 3200236656U;
#line 266
    b = (b << 23) | (b >> 9);
#line 266
    b += c;
#line 267
    a += ((b ^ c) ^ d) + 681279174U;
#line 267
    a = (a << 4) | (a >> 28);
#line 267
    a += b;
#line 268
    d += (((a ^ b) ^ c) + aa) + 3936430074U;
#line 268
    d = (d << 11) | (d >> 21);
#line 268
    d += a;
#line 269
    c += (((d ^ a) ^ b) + dd) + 3572445317U;
#line 269
    c = (c << 16) | (c >> 16);
#line 269
    c += d;
#line 270
    b += ((c ^ d) ^ a) + 76029189U;
#line 270
    b = (b << 23) | (b >> 9);
#line 270
    b += c;
#line 271
    a += ((b ^ c) ^ d) + 3654602809U;
#line 271
    a = (a << 4) | (a >> 28);
#line 271
    a += b;
#line 272
    d += ((a ^ b) ^ c) + 3873151461U;
#line 272
    d = (d << 11) | (d >> 21);
#line 272
    d += a;
#line 273
    c += ((d ^ a) ^ b) + 530742520U;
#line 273
    c = (c << 16) | (c >> 16);
#line 273
    c += d;
#line 274
    b += (((c ^ d) ^ a) + cc) + 3299628645U;
#line 274
    b = (b << 23) | (b >> 9);
#line 274
    b += c;
#line 277
    a += ((c ^ (b | ~ d)) + aa) + 4096336452U;
#line 277
    a = (a << 6) | (a >> 26);
#line 277
    a += b;
#line 278
    d += (b ^ (a | ~ c)) + 1126891415U;
#line 278
    d = (d << 10) | (d >> 22);
#line 278
    d += a;
#line 279
    c += ((a ^ (d | ~ b)) + 128U) + 2878612391U;
#line 279
    c = (c << 15) | (c >> 17);
#line 279
    c += d;
#line 280
    b += (d ^ (c | ~ a)) + 4237533241U;
#line 280
    b = (b << 21) | (b >> 11);
#line 280
    b += c;
#line 281
    a += (c ^ (b | ~ d)) + 1700485571U;
#line 281
    a = (a << 6) | (a >> 26);
#line 281
    a += b;
#line 282
    d += ((b ^ (a | ~ c)) + dd) + 2399980690U;
#line 282
    d = (d << 10) | (d >> 22);
#line 282
    d += a;
#line 283
    c += (a ^ (d | ~ b)) + 4293915773U;
#line 283
    c = (c << 15) | (c >> 17);
#line 283
    c += d;
#line 284
    b += ((d ^ (c | ~ a)) + bb) + 2240044497U;
#line 284
    b = (b << 21) | (b >> 11);
#line 284
    b += c;
#line 285
    a += (c ^ (b | ~ d)) + 1873313359U;
#line 285
    a = (a << 6) | (a >> 26);
#line 285
    a += b;
#line 286
    d += (b ^ (a | ~ c)) + 4264355552U;
#line 286
    d = (d << 10) | (d >> 22);
#line 286
    d += a;
#line 287
    c += (a ^ (d | ~ b)) + 2734768916U;
#line 287
    c = (c << 15) | (c >> 17);
#line 287
    c += d;
#line 288
    b += (d ^ (c | ~ a)) + 1309151649U;
#line 288
    b = (b << 21) | (b >> 11);
#line 288
    b += c;
#line 289
    a += ((c ^ (b | ~ d)) + 128U) + 4149444226U;
#line 289
    a = (a << 6) | (a >> 26);
#line 289
    a += b;
#line 290
    d += (b ^ (a | ~ c)) + 3174756917U;
#line 290
    d = (d << 10) | (d >> 22);
#line 290
    d += a;
#line 291
    c += ((a ^ (d | ~ b)) + cc) + 718787259U;
#line 291
    c = (c << 15) | (c >> 17);
#line 291
    c += d;
#line 292
    b += (d ^ (c | ~ a)) + 3951481745U;
#line 292
    b = (b << 21) | (b >> 11);
#line 292
    b += c;
#line 294
    a += 1732584193U;
#line 295
    b += 4023233417U;
#line 296
    c += 2562383102U;
#line 297
    d += 271733878U;
#line 206
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 301
  *(msg + 0) = (uint8_t )(a & 255U);
#line 302
  a >>= 8;
#line 302
  *(msg + 1) = (uint8_t )(a & 255U);
#line 303
  a >>= 8;
#line 303
  *(msg + 2) = (uint8_t )(a & 255U);
#line 304
  a >>= 8;
#line 304
  *(msg + 3) = (uint8_t )(a & 255U);
#line 305
  *(msg + 4) = (uint8_t )(b & 255U);
#line 306
  b >>= 8;
#line 306
  *(msg + 5) = (uint8_t )(b & 255U);
#line 307
  b >>= 8;
#line 307
  *(msg + 6) = (uint8_t )(b & 255U);
#line 308
  b >>= 8;
#line 308
  *(msg + 7) = (uint8_t )(b & 255U);
#line 309
  *(msg + 8) = (uint8_t )(c & 255U);
#line 310
  c >>= 8;
#line 310
  *(msg + 9) = (uint8_t )(c & 255U);
#line 311
  c >>= 8;
#line 311
  *(msg + 10) = (uint8_t )(c & 255U);
#line 312
  c >>= 8;
#line 312
  *(msg + 11) = (uint8_t )(c & 255U);
#line 313
  *(msg + 12) = (uint8_t )(d & 255U);
#line 314
  d >>= 8;
#line 314
  *(msg + 13) = (uint8_t )(d & 255U);
#line 315
  d >>= 8;
#line 315
  *(msg + 14) = (uint8_t )(d & 255U);
#line 316
  d >>= 8;
#line 316
  *(msg + 15) = (uint8_t )(d & 255U);
#line 317
  return;
}
}
#line 69 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 195
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) difftime)(time_t __time1 ,
                                                                                  time_t __time0 )  __attribute__((__const__)) ;
#line 127 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 41 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfcrack.h"
_Bool runCrackRev2(void) ;
#line 44
_Bool runCrackRev2_o(void) ;
#line 47
_Bool runCrackRev2_of(void) ;
#line 50
_Bool runCrackRev3(void) ;
#line 53
_Bool runCrackRev3_o(void) ;
#line 56
_Bool runCrackRev3_of(void) ;
#line 65
unsigned int getNrProcessed(void) ;
#line 39 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfcrack.c"
static uint8_t const   pad[32]  = 
#line 39 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfcrack.c"
  {      (uint8_t const   )40,      (uint8_t const   )191,      (uint8_t const   )78,      (uint8_t const   )94, 
        (uint8_t const   )78,      (uint8_t const   )117,      (uint8_t const   )138,      (uint8_t const   )65, 
        (uint8_t const   )100,      (uint8_t const   )0,      (uint8_t const   )78,      (uint8_t const   )86, 
        (uint8_t const   )255,      (uint8_t const   )250,      (uint8_t const   )1,      (uint8_t const   )8, 
        (uint8_t const   )46,      (uint8_t const   )46,      (uint8_t const   )0,      (uint8_t const   )182, 
        (uint8_t const   )208,      (uint8_t const   )104,      (uint8_t const   )62,      (uint8_t const   )128, 
        (uint8_t const   )47,      (uint8_t const   )12,      (uint8_t const   )169,      (uint8_t const   )254, 
        (uint8_t const   )100,      (uint8_t const   )83,      (uint8_t const   )105,      (uint8_t const   )122};
#line 48 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfcrack.c"
static uint8_t *encKeyWorkSpace  ;
#line 49 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfcrack.c"
static uint8_t password_user[33]  ;
#line 50 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfcrack.c"
static uint8_t *rev3TestKey  ;
#line 51 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfcrack.c"
static unsigned int ekwlen  ;
#line 54 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfcrack.c"
static uint8_t *currPW  ;
#line 56 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfcrack.c"
static unsigned int currPWLen  ;
#line 59 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfcrack.c"
static unsigned int nrprocessed  ;
#line 60 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfcrack.c"
static time_t startTime  ;
#line 63 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfcrack.c"
static EncData const   *encdata  ;
#line 66 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfcrack.c"
static _Bool crackDone  ;
#line 67 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfcrack.c"
static _Bool knownPassword  ;
#line 68 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfcrack.c"
static _Bool workWithUser  ;
#line 71 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfcrack.c"
_Bool printProgress(void) 
{ 
  time_t currentTime ;
  char str[33] ;
  double tmp ;

  {
#line 76
  if (crackDone) {
#line 77
    return ((_Bool)1);
  }
  {
#line 79
  currentTime = time((time_t *)((void *)0));
#line 80
  memcpy((void */* __restrict  */)(str), (void const   */* __restrict  */)currPW,
         (size_t )currPWLen);
#line 81
  str[currPWLen] = (char )'\000';
#line 82
  tmp = difftime(currentTime, startTime);
#line 82
  printf((char const   */* __restrict  */)"Average Speed: %.1f w/s. ", (double )nrprocessed / tmp);
#line 84
  printf((char const   */* __restrict  */)"Current Word: \'%s\'\n", str);
#line 85
  fflush(stdout);
#line 86
  nrprocessed = 0U;
#line 87
  startTime = time((time_t *)((void *)0));
  }
#line 88
  return ((_Bool)0);
}
}
#line 95 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfcrack.c"
static unsigned int initEncKeyWorkSpace(int const   revision , _Bool const   encMetaData ,
                                        int const   permissions , uint8_t const   *ownerkey ,
                                        uint8_t const   *fileID , unsigned int const   fileIDLen ) 
{ 
  unsigned int size ;
  int tmp ;
  void *tmp___0 ;

  {
#line 111
  if (revision >= 3) {
#line 111
    if (! encMetaData) {
#line 111
      tmp = 72;
    } else {
#line 111
      tmp = 68;
    }
  } else {
#line 111
    tmp = 68;
  }
  {
#line 111
  size = (unsigned int )tmp;
#line 112
  tmp___0 = malloc((size_t )(size + (unsigned int )fileIDLen));
#line 112
  encKeyWorkSpace = (uint8_t *)tmp___0;
#line 115
  memcpy((void */* __restrict  */)encKeyWorkSpace, (void const   */* __restrict  */)(pad),
         (size_t )32);
#line 118
  memcpy((void */* __restrict  */)(encKeyWorkSpace + 32), (void const   */* __restrict  */)ownerkey,
         (size_t )32);
#line 121
  *(encKeyWorkSpace + 64) = (uint8_t )(permissions & 255);
#line 122
  *(encKeyWorkSpace + 65) = (uint8_t )((permissions >> 8) & 255);
#line 123
  *(encKeyWorkSpace + 66) = (uint8_t )((permissions >> 16) & 255);
#line 124
  *(encKeyWorkSpace + 67) = (uint8_t )((permissions >> 24) & 255);
#line 127
  memcpy((void */* __restrict  */)(encKeyWorkSpace + 68), (void const   */* __restrict  */)fileID,
         (size_t )fileIDLen);
  }
#line 130
  if (revision >= 3) {
#line 130
    if (! encMetaData) {
#line 131
      *(encKeyWorkSpace + (68U + fileIDLen)) = (uint8_t )255;
#line 132
      *(encKeyWorkSpace + (69U + fileIDLen)) = (uint8_t )255;
#line 133
      *(encKeyWorkSpace + (70U + fileIDLen)) = (uint8_t )255;
#line 134
      *(encKeyWorkSpace + (71U + fileIDLen)) = (uint8_t )255;
    }
  }
#line 137
  return (size + (unsigned int )fileIDLen);
}
}
#line 160 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfcrack.c"
static uint8_t isolat1ToUpper(uint8_t const   b ) 
{ 
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
#line 162
  if ((int const   )b >= 224) {
#line 162
    if ((int const   )b <= 246) {
#line 162
      tmp___0 = 1;
    } else {
#line 162
      tmp___0 = 0;
    }
  } else {
#line 162
    tmp___0 = 0;
  }
  {
#line 162
  tmp___1 = __builtin_expect((long )tmp___0, 0L);
  }
#line 162
  if (tmp___1) {
#line 163
    return ((uint8_t )((int const   )b - 32));
  } else {
    {
#line 165
    tmp = toupper((int )b);
    }
#line 165
    return ((uint8_t )tmp);
  }
}
}
#line 172
static _Bool do_permutate(void) ;
#line 172 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfcrack.c"
static _Bool ret  =    (_Bool)0;
#line 170 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfcrack.c"
static _Bool do_permutate(void) 
{ 
  uint8_t tmp ;

  {
  {
#line 175
  tmp = isolat1ToUpper((uint8_t const   )*(currPW + 0));
  }
#line 176
  if ((int )tmp != (int )*(currPW + 0)) {
#line 177
    *(currPW + 0) = tmp;
#line 178
    ret = (_Bool )(! ret);
  } else {
#line 181
    ret = (_Bool)0;
  }
#line 183
  return (ret);
}
}
#line 187 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfcrack.c"
static _Bool no_permutate(void) 
{ 


  {
#line 188
  return ((_Bool)0);
}
}
#line 191 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfcrack.c"
static _Bool (*permutate)()  =    (_Bool (*)())((void *)0);
#line 194 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfcrack.c"
static void foundPassword(void) 
{ 
  char str[33] ;
  int fin_search ;
  size_t pad_start ;
  char const   *tmp ;

  {
  {
#line 200
  memcpy((void */* __restrict  */)(str), (void const   */* __restrict  */)currPW,
         (size_t )currPWLen);
#line 201
  str[currPWLen] = (char )'\000';
  }
#line 202
  if (workWithUser) {
#line 202
    tmp = "user";
  } else {
#line 202
    tmp = "owner";
  }
  {
#line 202
  printf((char const   */* __restrict  */)"found %s-password: \'%s\'\n", tmp, str);
  }
#line 210
  if (! workWithUser) {
#line 211
    fin_search = -1;
#line 212
    pad_start = (size_t )0;
    {
#line 214
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 215
      fin_search = memcmp((void const   *)(password_user + pad_start), (void const   *)(pad),
                          32UL - pad_start);
#line 216
      pad_start ++;
      }
#line 214
      if (pad_start < 32UL) {
#line 214
        if (! (fin_search != 0)) {
#line 214
          goto while_break;
        }
      } else {
#line 214
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 219
    memcpy((void */* __restrict  */)(str), (void const   */* __restrict  */)(password_user),
           pad_start);
    }
#line 220
    if (! fin_search) {
#line 221
      str[pad_start - 1UL] = (char )'\000';
    }
    {
#line 222
    printf((char const   */* __restrict  */)"found user-password: \'%s\'\n", str);
    }
  }
#line 224
  return;
}
}
#line 238 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfcrack.c"
static _Bool isUserPasswordRev2(void) 
{ 
  uint8_t enckey[16] ;
  _Bool tmp ;

  {
  {
#line 242
  md5((uint8_t const   *)encKeyWorkSpace, (unsigned int const   )ekwlen, enckey);
#line 244
  tmp = (_Bool )rc4Match40b((uint8_t const   *)(enckey), (uint8_t const   *)encdata->u_string,
                            pad);
  }
#line 244
  return (tmp);
}
}
#line 250 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfcrack.c"
static _Bool isUserPasswordRev3(void) 
{ 
  uint8_t test[16] ;
  uint8_t enckey[16] ;
  uint8_t tmpkey[16] ;
  int i ;
  unsigned int length ;
  unsigned int j ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
#line 256
  length = (unsigned int )(encdata->length / 8);
#line 257
  md5((uint8_t const   *)encKeyWorkSpace, (unsigned int const   )ekwlen, enckey);
#line 258
  md5_50(enckey);
#line 260
  memcpy((void */* __restrict  */)(test), (void const   */* __restrict  */)encdata->u_string,
         (size_t )3);
#line 263
  i = 19;
  }
  {
#line 263
  while (1) {
    while_continue: /* CIL Label */ ;
#line 263
    if (! (i >= 0)) {
#line 263
      goto while_break;
    }
#line 263
    j = 0U;
    {
#line 263
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 263
      if (! (j < length)) {
#line 263
        goto while_break___0;
      }
#line 263
      tmpkey[j] = (uint8_t )((int )enckey[j] ^ i);
#line 263
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 263
    rc4Decrypt((uint8_t const   *)(tmpkey), (uint8_t const   *)(test), (unsigned int const   )3,
               test);
#line 263
    i --;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 266
  tmp___0 = memcmp((void const   *)(test), (void const   *)rev3TestKey, (size_t )3);
#line 266
  tmp___1 = __builtin_expect((long )(tmp___0 == 0), 0L);
  }
#line 266
  if (tmp___1) {
    {
#line 267
    memcpy((void */* __restrict  */)(test), (void const   */* __restrict  */)encdata->u_string,
           (size_t )16);
#line 268
    i = 19;
    }
    {
#line 268
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 268
      if (! (i >= 0)) {
#line 268
        goto while_break___1;
      }
#line 268
      j = 0U;
      {
#line 268
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 268
        if (! (j < length)) {
#line 268
          goto while_break___2;
        }
#line 268
        tmpkey[j] = (uint8_t )((int )enckey[j] ^ i);
#line 268
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 268
      rc4Decrypt((uint8_t const   *)(tmpkey), (uint8_t const   *)(test), (unsigned int const   )16,
                 test);
#line 268
      i --;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 269
    tmp = memcmp((void const   *)(test), (void const   *)rev3TestKey, (size_t )16);
    }
#line 269
    if (tmp == 0) {
#line 270
      return ((_Bool)1);
    }
  }
#line 272
  return ((_Bool)0);
}
}
#line 285 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfcrack.c"
_Bool runCrackRev2_o(void) 
{ 
  uint8_t enckey[16] ;
  unsigned int lpasslength ;
  long tmp ;
  long tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;

  {
  {
#line 290
  lpasslength = 0U;
#line 291
  startTime = time((time_t *)((void *)0));
  }
  {
#line 292
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 293
    currPWLen = setPassword(currPW);
#line 293
    tmp___0 = __builtin_expect((long )(lpasslength != currPWLen), 0L);
    }
#line 293
    if (tmp___0) {
      {
#line 293
      tmp = __builtin_expect((long )(currPWLen < 32U), 1L);
      }
#line 293
      if (tmp) {
        {
#line 293
        memcpy((void */* __restrict  */)(currPW + currPWLen), (void const   */* __restrict  */)(pad),
               (size_t )(32U - currPWLen));
        }
      }
#line 293
      lpasslength = currPWLen;
    }
    {
#line 295
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 296
      md5((uint8_t const   *)currPW, (unsigned int const   )32, enckey);
#line 298
      rc4Decrypt((uint8_t const   *)(enckey), (uint8_t const   *)encdata->o_string,
                 (unsigned int const   )32, encKeyWorkSpace);
#line 299
      md5((uint8_t const   *)encKeyWorkSpace, (unsigned int const   )ekwlen, enckey);
#line 300
      tmp___1 = (_Bool )rc4Match40b((uint8_t const   *)(enckey), (uint8_t const   *)encdata->u_string,
                                    pad);
      }
#line 300
      if (tmp___1) {
        {
#line 301
        memcpy((void */* __restrict  */)(password_user), (void const   */* __restrict  */)encKeyWorkSpace,
               (size_t )32);
        }
#line 302
        return ((_Bool)1);
      }
      {
#line 305
      nrprocessed ++;
#line 295
      tmp___2 = (*permutate)();
      }
#line 295
      if (! tmp___2) {
#line 295
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 292
    tmp___3 = nextPassword();
    }
#line 292
    if (! tmp___3) {
#line 292
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 308
  return ((_Bool)0);
}
}
#line 311 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfcrack.c"
_Bool runCrackRev3_o(void) 
{ 
  uint8_t test[32] ;
  uint8_t enckey[16] ;
  uint8_t tmpkey[16] ;
  unsigned int j ;
  unsigned int length ;
  unsigned int lpasslength ;
  int i ;
  long tmp ;
  long tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;

  {
  {
#line 317
  length = (unsigned int )(encdata->length / 8);
#line 318
  lpasslength = 0U;
#line 319
  startTime = time((time_t *)((void *)0));
  }
  {
#line 320
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 321
    currPWLen = setPassword(currPW);
#line 321
    tmp___0 = __builtin_expect((long )(lpasslength != currPWLen), 0L);
    }
#line 321
    if (tmp___0) {
      {
#line 321
      tmp = __builtin_expect((long )(currPWLen < 32U), 1L);
      }
#line 321
      if (tmp) {
        {
#line 321
        memcpy((void */* __restrict  */)(currPW + currPWLen), (void const   */* __restrict  */)(pad),
               (size_t )(32U - currPWLen));
        }
      }
#line 321
      lpasslength = currPWLen;
    }
    {
#line 323
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 324
      md5((uint8_t const   *)currPW, (unsigned int const   )32, enckey);
#line 326
      md5_50(enckey);
#line 328
      memcpy((void */* __restrict  */)(test), (void const   */* __restrict  */)encdata->o_string,
             (size_t )32);
#line 329
      i = 19;
      }
      {
#line 329
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 329
        if (! (i >= 0)) {
#line 329
          goto while_break___1;
        }
#line 329
        j = 0U;
        {
#line 329
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 329
          if (! (j < length)) {
#line 329
            goto while_break___2;
          }
#line 329
          tmpkey[j] = (uint8_t )((int )enckey[j] ^ i);
#line 329
          j ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 329
        rc4Decrypt((uint8_t const   *)(tmpkey), (uint8_t const   *)(test), (unsigned int const   )32,
                   test);
#line 329
        i --;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 330
      memcpy((void */* __restrict  */)encKeyWorkSpace, (void const   */* __restrict  */)(test),
             (size_t )32);
#line 332
      tmp___1 = isUserPasswordRev3();
      }
#line 332
      if (tmp___1) {
        {
#line 333
        memcpy((void */* __restrict  */)(password_user), (void const   */* __restrict  */)encKeyWorkSpace,
               (size_t )32);
        }
#line 334
        return ((_Bool)1);
      }
      {
#line 337
      nrprocessed ++;
#line 323
      tmp___2 = (*permutate)();
      }
#line 323
      if (! tmp___2) {
#line 323
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 320
    tmp___3 = nextPassword();
    }
#line 320
    if (! tmp___3) {
#line 320
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 340
  return ((_Bool)0);
}
}
#line 343 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfcrack.c"
_Bool runCrackRev2_of(void) 
{ 
  uint8_t enckey[16] ;
  unsigned int lpasslength ;
  long tmp ;
  long tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;

  {
  {
#line 348
  lpasslength = 0U;
#line 349
  startTime = time((time_t *)((void *)0));
  }
  {
#line 350
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 351
    currPWLen = setPassword(currPW);
#line 351
    tmp___0 = __builtin_expect((long )(lpasslength != currPWLen), 0L);
    }
#line 351
    if (tmp___0) {
      {
#line 351
      tmp = __builtin_expect((long )(currPWLen < 32U), 1L);
      }
#line 351
      if (tmp) {
        {
#line 351
        memcpy((void */* __restrict  */)(currPW + currPWLen), (void const   */* __restrict  */)(pad),
               (size_t )(32U - currPWLen));
        }
      }
#line 351
      lpasslength = currPWLen;
    }
    {
#line 353
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 354
      md5((uint8_t const   *)encKeyWorkSpace, (unsigned int const   )32, enckey);
#line 357
      tmp___1 = (_Bool )rc4Match40b((uint8_t const   *)(enckey), (uint8_t const   *)encdata->o_string,
                                    (uint8_t const   *)(password_user));
      }
#line 357
      if (tmp___1) {
#line 358
        return ((_Bool)1);
      }
      {
#line 360
      nrprocessed ++;
#line 353
      tmp___2 = (*permutate)();
      }
#line 353
      if (! tmp___2) {
#line 353
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 350
    tmp___3 = nextPassword();
    }
#line 350
    if (! tmp___3) {
#line 350
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 363
  return ((_Bool)0);
}
}
#line 366 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfcrack.c"
_Bool runCrackRev3_of(void) 
{ 
  uint8_t test[32] ;
  uint8_t enckey[16] ;
  uint8_t tmpkey[16] ;
  unsigned int j ;
  unsigned int length ;
  unsigned int lpasslength ;
  int i ;
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;

  {
  {
#line 372
  length = (unsigned int )(encdata->length / 8);
#line 373
  lpasslength = 0U;
#line 374
  startTime = time((time_t *)((void *)0));
  }
  {
#line 375
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 376
    currPWLen = setPassword(currPW);
#line 376
    tmp___0 = __builtin_expect((long )(lpasslength != currPWLen), 0L);
    }
#line 376
    if (tmp___0) {
      {
#line 376
      tmp = __builtin_expect((long )(currPWLen < 32U), 1L);
      }
#line 376
      if (tmp) {
        {
#line 376
        memcpy((void */* __restrict  */)(currPW + currPWLen), (void const   */* __restrict  */)(pad),
               (size_t )(32U - currPWLen));
        }
      }
#line 376
      lpasslength = currPWLen;
    }
    {
#line 378
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 379
      md5((uint8_t const   *)encKeyWorkSpace, (unsigned int const   )32, enckey);
#line 381
      md5_50(enckey);
#line 383
      memcpy((void */* __restrict  */)(test), (void const   */* __restrict  */)encdata->o_string,
             (size_t )3);
#line 384
      i = 19;
      }
      {
#line 384
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 384
        if (! (i >= 0)) {
#line 384
          goto while_break___1;
        }
#line 384
        j = 0U;
        {
#line 384
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 384
          if (! (j < length)) {
#line 384
            goto while_break___2;
          }
#line 384
          tmpkey[j] = (uint8_t )((int )enckey[j] ^ i);
#line 384
          j ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 384
        rc4Decrypt((uint8_t const   *)(tmpkey), (uint8_t const   *)(test), (unsigned int const   )3,
                   test);
#line 384
        i --;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 387
      tmp___2 = memcmp((void const   *)(test), (void const   *)(password_user), (size_t )3);
#line 387
      tmp___3 = __builtin_expect((long )(tmp___2 == 0), 0L);
      }
#line 387
      if (tmp___3) {
        {
#line 388
        memcpy((void */* __restrict  */)(test), (void const   */* __restrict  */)encdata->o_string,
               (size_t )32);
#line 389
        i = 19;
        }
        {
#line 389
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 389
          if (! (i >= 0)) {
#line 389
            goto while_break___3;
          }
#line 389
          j = 0U;
          {
#line 389
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 389
            if (! (j < length)) {
#line 389
              goto while_break___4;
            }
#line 389
            tmpkey[j] = (uint8_t )((int )enckey[j] ^ i);
#line 389
            j ++;
          }
          while_break___4: /* CIL Label */ ;
          }
          {
#line 389
          rc4Decrypt((uint8_t const   *)(tmpkey), (uint8_t const   *)(test), (unsigned int const   )32,
                     test);
#line 389
          i --;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 390
        tmp___1 = memcmp((void const   *)(test), (void const   *)(password_user),
                         (size_t )32);
        }
#line 390
        if (tmp___1 == 0) {
#line 391
          return ((_Bool)1);
        }
      }
      {
#line 394
      nrprocessed ++;
#line 378
      tmp___4 = (*permutate)();
      }
#line 378
      if (! tmp___4) {
#line 378
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 375
    tmp___5 = nextPassword();
    }
#line 375
    if (! tmp___5) {
#line 375
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 397
  return ((_Bool)0);
}
}
#line 400 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfcrack.c"
_Bool runCrackRev3(void) 
{ 
  uint8_t test[16] ;
  uint8_t enckey[16] ;
  uint8_t tmpkey[16] ;
  unsigned int j ;
  unsigned int length ;
  unsigned int lpasslength ;
  int i ;
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;
  _Bool tmp___11 ;
  _Bool tmp___12 ;

  {
#line 406
  length = (unsigned int )(encdata->length / 8);
#line 407
  lpasslength = 0U;
#line 408
  if (length == 16U) {
    {
#line 409
    startTime = time((time_t *)((void *)0));
    }
    {
#line 410
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 411
      currPWLen = setPassword(currPW);
#line 411
      tmp___0 = __builtin_expect((long )(lpasslength != currPWLen), 0L);
      }
#line 411
      if (tmp___0) {
        {
#line 411
        tmp = __builtin_expect((long )(currPWLen < 32U), 1L);
        }
#line 411
        if (tmp) {
          {
#line 411
          memcpy((void */* __restrict  */)(currPW + currPWLen), (void const   */* __restrict  */)(pad),
                 (size_t )(32U - currPWLen));
          }
        }
#line 411
        lpasslength = currPWLen;
      }
      {
#line 413
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 414
        md5((uint8_t const   *)encKeyWorkSpace, (unsigned int const   )ekwlen, enckey);
#line 416
        md5_50(enckey);
#line 417
        memcpy((void */* __restrict  */)(test), (void const   */* __restrict  */)encdata->u_string,
               (size_t )3);
#line 420
        i = 19;
        }
        {
#line 420
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 420
          if (! (i >= 0)) {
#line 420
            goto while_break___1;
          }
#line 420
          j = 0U;
          {
#line 420
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 420
            if (! (j < length)) {
#line 420
              goto while_break___2;
            }
#line 420
            tmpkey[j] = (uint8_t )((int )enckey[j] ^ i);
#line 420
            j ++;
          }
          while_break___2: /* CIL Label */ ;
          }
          {
#line 420
          rc4Decrypt((uint8_t const   *)(tmpkey), (uint8_t const   *)(test), (unsigned int const   )3,
                     test);
#line 420
          i --;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 423
        tmp___2 = memcmp((void const   *)(test), (void const   *)rev3TestKey, (size_t )3);
#line 423
        tmp___3 = __builtin_expect((long )(tmp___2 == 0), 0L);
        }
#line 423
        if (tmp___3) {
          {
#line 424
          memcpy((void */* __restrict  */)(test), (void const   */* __restrict  */)encdata->u_string,
                 (size_t )16);
#line 425
          i = 19;
          }
          {
#line 425
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 425
            if (! (i >= 0)) {
#line 425
              goto while_break___3;
            }
#line 425
            j = 0U;
            {
#line 425
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 425
              if (! (j < length)) {
#line 425
                goto while_break___4;
              }
#line 425
              tmpkey[j] = (uint8_t )((int )enckey[j] ^ i);
#line 425
              j ++;
            }
            while_break___4: /* CIL Label */ ;
            }
            {
#line 425
            rc4Decrypt((uint8_t const   *)(tmpkey), (uint8_t const   *)(test), (unsigned int const   )16,
                       test);
#line 425
            i --;
            }
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 426
          tmp___1 = memcmp((void const   *)(test), (void const   *)rev3TestKey, (size_t )16);
          }
#line 426
          if (tmp___1 == 0) {
#line 427
            return ((_Bool)1);
          }
        }
        {
#line 430
        nrprocessed ++;
#line 413
        tmp___4 = (*permutate)();
        }
#line 413
        if (! tmp___4) {
#line 413
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 410
      tmp___5 = nextPassword();
      }
#line 410
      if (! tmp___5) {
#line 410
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 435
    startTime = time((time_t *)((void *)0));
    }
    {
#line 436
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 437
      currPWLen = setPassword(currPW);
#line 437
      tmp___7 = __builtin_expect((long )(lpasslength != currPWLen), 0L);
      }
#line 437
      if (tmp___7) {
        {
#line 437
        tmp___6 = __builtin_expect((long )(currPWLen < 32U), 1L);
        }
#line 437
        if (tmp___6) {
          {
#line 437
          memcpy((void */* __restrict  */)(currPW + currPWLen), (void const   */* __restrict  */)(pad),
                 (size_t )(32U - currPWLen));
          }
        }
#line 437
        lpasslength = currPWLen;
      }
      {
#line 439
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 440
        md5((uint8_t const   *)encKeyWorkSpace, (unsigned int const   )ekwlen, enckey);
#line 442
        i = 0;
        }
        {
#line 442
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 442
          if (! (i < 50)) {
#line 442
            goto while_break___7;
          }
          {
#line 442
          md5((uint8_t const   *)(enckey), (unsigned int const   )length, enckey);
#line 442
          i ++;
          }
        }
        while_break___7: /* CIL Label */ ;
        }
        {
#line 444
        memcpy((void */* __restrict  */)(test), (void const   */* __restrict  */)encdata->u_string,
               (size_t )3);
#line 447
        i = 19;
        }
        {
#line 447
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 447
          if (! (i >= 0)) {
#line 447
            goto while_break___8;
          }
#line 447
          j = 0U;
          {
#line 447
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 447
            if (! (j < length)) {
#line 447
              goto while_break___9;
            }
#line 447
            tmpkey[j] = (uint8_t )((int )enckey[j] ^ i);
#line 447
            j ++;
          }
          while_break___9: /* CIL Label */ ;
          }
          {
#line 447
          rc4Decrypt((uint8_t const   *)(tmpkey), (uint8_t const   *)(test), (unsigned int const   )3,
                     test);
#line 447
          i --;
          }
        }
        while_break___8: /* CIL Label */ ;
        }
        {
#line 450
        tmp___9 = memcmp((void const   *)(test), (void const   *)rev3TestKey, (size_t )3);
#line 450
        tmp___10 = __builtin_expect((long )(tmp___9 == 0), 0L);
        }
#line 450
        if (tmp___10) {
          {
#line 451
          memcpy((void */* __restrict  */)(test), (void const   */* __restrict  */)encdata->u_string,
                 (size_t )length);
#line 452
          i = 19;
          }
          {
#line 452
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 452
            if (! (i >= 0)) {
#line 452
              goto while_break___10;
            }
#line 452
            j = 0U;
            {
#line 452
            while (1) {
              while_continue___11: /* CIL Label */ ;
#line 452
              if (! (j < length)) {
#line 452
                goto while_break___11;
              }
#line 452
              tmpkey[j] = (uint8_t )((int )enckey[j] ^ i);
#line 452
              j ++;
            }
            while_break___11: /* CIL Label */ ;
            }
            {
#line 452
            rc4Decrypt((uint8_t const   *)(tmpkey), (uint8_t const   *)(test), (unsigned int const   )length,
                       test);
#line 452
            i --;
            }
          }
          while_break___10: /* CIL Label */ ;
          }
          {
#line 453
          tmp___8 = memcmp((void const   *)(test), (void const   *)rev3TestKey, (size_t )length);
          }
#line 453
          if (tmp___8 == 0) {
#line 454
            return ((_Bool)1);
          }
        }
        {
#line 457
        nrprocessed ++;
#line 439
        tmp___11 = (*permutate)();
        }
#line 439
        if (! tmp___11) {
#line 439
          goto while_break___6;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 436
      tmp___12 = nextPassword();
      }
#line 436
      if (! tmp___12) {
#line 436
        goto while_break___5;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 461
  return ((_Bool)0);
}
}
#line 465 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfcrack.c"
_Bool runCrackRev2(void) 
{ 
  uint8_t enckey[16] ;
  unsigned int lpasslength ;
  long tmp ;
  long tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;

  {
  {
#line 470
  lpasslength = 0U;
#line 471
  startTime = time((time_t *)((void *)0));
  }
  {
#line 472
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 473
    currPWLen = setPassword(currPW);
#line 473
    tmp___0 = __builtin_expect((long )(lpasslength != currPWLen), 0L);
    }
#line 473
    if (tmp___0) {
      {
#line 473
      tmp = __builtin_expect((long )(currPWLen < 32U), 1L);
      }
#line 473
      if (tmp) {
        {
#line 473
        memcpy((void */* __restrict  */)(currPW + currPWLen), (void const   */* __restrict  */)(pad),
               (size_t )(32U - currPWLen));
        }
      }
#line 473
      lpasslength = currPWLen;
    }
    {
#line 475
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 476
      md5((uint8_t const   *)encKeyWorkSpace, (unsigned int const   )ekwlen, enckey);
#line 479
      tmp___1 = (_Bool )rc4Match40b((uint8_t const   *)(enckey), (uint8_t const   *)encdata->u_string,
                                    pad);
      }
#line 479
      if (tmp___1) {
#line 480
        return ((_Bool)1);
      }
      {
#line 482
      nrprocessed ++;
#line 475
      tmp___2 = (*permutate)();
      }
#line 475
      if (! tmp___2) {
#line 475
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 472
    tmp___3 = nextPassword();
    }
#line 472
    if (! tmp___3) {
#line 472
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 485
  return ((_Bool)0);
}
}
#line 491 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfcrack.c"
void runCrack(void) 
{ 
  _Bool found ;
  uint8_t cpw[32] ;

  {
#line 493
  found = (_Bool)0;
#line 496
  if (! workWithUser) {
#line 496
    if (! knownPassword) {
      {
#line 497
      memcpy((void */* __restrict  */)(cpw), (void const   */* __restrict  */)(pad),
             (size_t )32);
#line 498
      currPW = cpw;
      }
#line 499
      if (encdata->revision == 2) {
        {
#line 500
        found = runCrackRev2_o();
        }
      } else {
        {
#line 502
        found = runCrackRev3_o();
        }
      }
    } else {
#line 496
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 504
  if (encdata->revision == 2) {
#line 505
    if (workWithUser) {
      {
#line 506
      found = runCrackRev2();
      }
    } else {
      {
#line 508
      found = runCrackRev2_of();
      }
    }
  } else
#line 511
  if (workWithUser) {
    {
#line 512
    found = runCrackRev3();
    }
  } else {
    {
#line 514
    found = runCrackRev3_of();
    }
  }
#line 516
  crackDone = (_Bool)1;
#line 517
  if (! found) {
    {
#line 518
    printf((char const   */* __restrict  */)"Could not find password\n");
    }
  } else {
    {
#line 520
    foundPassword();
    }
  }
#line 521
  currPW = (uint8_t *)((void *)0);
#line 522
  return;
}
}
#line 525 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfcrack.c"
unsigned int getNrProcessed(void) 
{ 


  {
#line 526
  return (nrprocessed);
}
}
#line 532 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfcrack.c"
static _Bool recovery___0  =    (_Bool)0;
#line 533 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfcrack.c"
static _Bool permutation  =    (_Bool)0;
#line 539 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfcrack.c"
void cleanPDFCrack(void) 
{ 


  {
#line 541
  if (rev3TestKey) {
    {
#line 545
    free((void *)rev3TestKey);
#line 546
    rev3TestKey = (uint8_t *)((void *)0);
    }
  }
#line 548
  if (encKeyWorkSpace) {
    {
#line 549
    free((void *)encKeyWorkSpace);
#line 550
    encKeyWorkSpace = (uint8_t *)((void *)0);
    }
  }
#line 552
  knownPassword = (_Bool)0;
#line 553
  recovery___0 = (_Bool)0;
#line 554
  permutation = (_Bool)0;
#line 555
  return;
}
}
#line 561 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfcrack.c"
_Bool initPDFCrack(EncData const   *e , uint8_t const   *upw , _Bool const   user ,
                   char const   *wl , passwordMethod const   pm , FILE *file , char const   *cs ,
                   unsigned int const   minPw , unsigned int const   maxPw , _Bool const   perm ) 
{ 
  uint8_t buf[128] ;
  unsigned int upwlen ;
  uint8_t *tmp ;
  _Bool tmp___0 ;
  size_t tmp___1 ;
  _Bool tmp___2 ;
  void *tmp___3 ;
  _Bool tmp___4 ;
  int tmp___5 ;

  {
  {
#line 570
  ekwlen = initEncKeyWorkSpace(e->revision, e->encryptMetaData, e->permissions, (uint8_t const   *)e->o_string,
                               (uint8_t const   *)e->fileID, e->fileIDLen);
#line 573
  encdata = e;
#line 574
  currPW = encKeyWorkSpace;
#line 575
  currPWLen = 0U;
#line 576
  nrprocessed = 0U;
#line 577
  workWithUser = (_Bool )user;
#line 578
  crackDone = (_Bool)0;
#line 580
  tmp___0 = (_Bool )setrc4DecryptMethod((unsigned int const   )e->length);
  }
#line 580
  if (! tmp___0) {
    {
#line 581
    exit(234);
    }
  }
#line 583
  if (upw) {
    {
#line 584
    tmp___1 = strlen((char const   *)upw);
#line 584
    upwlen = (unsigned int )tmp___1;
    }
#line 585
    if (upwlen > 32U) {
#line 586
      upwlen = 32U;
    }
    {
#line 587
    memcpy((void */* __restrict  */)(password_user), (void const   */* __restrict  */)upw,
           (size_t )upwlen);
#line 588
    memcpy((void */* __restrict  */)(password_user + upwlen), (void const   */* __restrict  */)(pad),
           (size_t )(32U - upwlen));
#line 589
    memcpy((void */* __restrict  */)encKeyWorkSpace, (void const   */* __restrict  */)(password_user),
           (size_t )32);
#line 590
    knownPassword = (_Bool)1;
    }
  }
#line 593
  if (recovery___0) {
    {
#line 594
    memcpy((void */* __restrict  */)encKeyWorkSpace, (void const   */* __restrict  */)(password_user),
           (size_t )32);
    }
  }
#line 596
  if (encdata->revision == 2) {
#line 597
    if (knownPassword) {
      {
#line 598
      tmp___2 = isUserPasswordRev2();
      }
#line 598
      if (! tmp___2) {
#line 599
        return ((_Bool)0);
      }
      {
#line 600
      memcpy((void */* __restrict  */)encKeyWorkSpace, (void const   */* __restrict  */)(pad),
             (size_t )32);
      }
    } else {
      {
#line 603
      memcpy((void */* __restrict  */)(password_user), (void const   */* __restrict  */)(pad),
             (size_t )32);
#line 604
      knownPassword = isUserPasswordRev2();
      }
    }
  } else
#line 607
  if (e->revision >= 3) {
    {
#line 608
    memcpy((void */* __restrict  */)(buf), (void const   */* __restrict  */)(pad),
           (size_t )32);
#line 609
    memcpy((void */* __restrict  */)(buf + 32), (void const   */* __restrict  */)e->fileID,
           (size_t )e->fileIDLen);
#line 610
    tmp___3 = malloc(sizeof(uint8_t ) * 16UL);
#line 610
    tmp = (uint8_t *)tmp___3;
#line 611
    md5((uint8_t const   *)(buf), 32U + e->fileIDLen, tmp);
#line 612
    rev3TestKey = tmp;
    }
#line 613
    if (knownPassword) {
      {
#line 614
      tmp___4 = isUserPasswordRev3();
      }
#line 614
      if (! tmp___4) {
#line 615
        return ((_Bool)0);
      }
      {
#line 616
      memcpy((void */* __restrict  */)encKeyWorkSpace, (void const   */* __restrict  */)(pad),
             (size_t )32);
      }
    } else {
      {
#line 619
      memcpy((void */* __restrict  */)(password_user), (void const   */* __restrict  */)(pad),
             (size_t )32);
#line 620
      knownPassword = isUserPasswordRev3();
      }
    }
  }
#line 624
  if (perm) {
#line 624
    tmp___5 = 1;
  } else
#line 624
  if (permutation) {
#line 624
    tmp___5 = 1;
  } else {
#line 624
    tmp___5 = 0;
  }
#line 624
  permutation = (_Bool )tmp___5;
#line 625
  if (permutation) {
#line 626
    permutate = & do_permutate;
  } else {
#line 628
    permutate = & no_permutate;
  }
  {
#line 630
  initPasswords(pm, file, wl, cs, minPw, maxPw);
  }
#line 631
  return ((_Bool)1);
}
}
#line 635 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfcrack.c"
static char const   string_PRVPL[60]  = 
#line 635
  {      (char const   )'P',      (char const   )'D',      (char const   )'F',      (char const   )':', 
        (char const   )' ',      (char const   )'%',      (char const   )'d',      (char const   )'.', 
        (char const   )'%',      (char const   )'d',      (char const   )'\n',      (char const   )'R', 
        (char const   )':',      (char const   )' ',      (char const   )'%',      (char const   )'d', 
        (char const   )'\n',      (char const   )'V',      (char const   )':',      (char const   )' ', 
        (char const   )'%',      (char const   )'d',      (char const   )'\n',      (char const   )'P', 
        (char const   )':',      (char const   )' ',      (char const   )'%',      (char const   )'d', 
        (char const   )'\n',      (char const   )'L',      (char const   )':',      (char const   )' ', 
        (char const   )'%',      (char const   )'d',      (char const   )'\n',      (char const   )'M', 
        (char const   )'e',      (char const   )'t',      (char const   )'a',      (char const   )'D', 
        (char const   )'a',      (char const   )'t',      (char const   )'a',      (char const   )':', 
        (char const   )' ',      (char const   )'%',      (char const   )'d',      (char const   )'\n', 
        (char const   )'F',      (char const   )'i',      (char const   )'l',      (char const   )'e', 
        (char const   )'I',      (char const   )'D',      (char const   )'(',      (char const   )'%', 
        (char const   )'d',      (char const   )')',      (char const   )':',      (char const   )'\000'};
#line 638 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfcrack.c"
static char const   string_FILTER[15]  = 
#line 638
  {      (char const   )'\n',      (char const   )'F',      (char const   )'i',      (char const   )'l', 
        (char const   )'t',      (char const   )'e',      (char const   )'r',      (char const   )'(', 
        (char const   )'%',      (char const   )'z',      (char const   )'u',      (char const   )')', 
        (char const   )':',      (char const   )' ',      (char const   )'\000'};
#line 639 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfcrack.c"
static char const   string_UUPWP[36]  = 
#line 639
  {      (char const   )'\n',      (char const   )'U',      (char const   )'s',      (char const   )'e', 
        (char const   )'r',      (char const   )':',      (char const   )' ',      (char const   )'%', 
        (char const   )'d',      (char const   )'\n',      (char const   )'U',      (char const   )'s', 
        (char const   )'e',      (char const   )'r',      (char const   )'P',      (char const   )'w', 
        (char const   )':',      (char const   )' ',      (char const   )'%',      (char const   )'d', 
        (char const   )'\n',      (char const   )'P',      (char const   )'e',      (char const   )'r', 
        (char const   )'m',      (char const   )'u',      (char const   )'t',      (char const   )'a', 
        (char const   )'t',      (char const   )'e',      (char const   )':',      (char const   )' ', 
        (char const   )'%',      (char const   )'d',      (char const   )'\n',      (char const   )'\000'};
#line 647 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfcrack.c"
_Bool loadState(FILE *file , EncData *e , char **wl , _Bool *user ) 
{ 
  unsigned int i ;
  int tmp ;
  int tmp2 ;
  int tmp3 ;
  size_t len ;
  char c ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  _Bool tmp___14 ;

  {
  {
#line 655
  tmp___0 = fscanf((FILE */* __restrict  */)file, (char const   */* __restrict  */)(string_PRVPL),
                   & e->version_major, & e->version_minor, & e->revision, & e->version,
                   & e->permissions, & e->length, & tmp, & e->fileIDLen);
  }
#line 655
  if (tmp___0 < 8) {
#line 658
    return ((_Bool)0);
  }
#line 661
  if (e->fileIDLen > 256U) {
#line 662
    return ((_Bool)0);
  }
  {
#line 664
  e->encryptMetaData = (_Bool )(tmp == 1);
#line 667
  tmp___1 = malloc(sizeof(uint8_t ) * (unsigned long )e->fileIDLen);
#line 667
  e->fileID = (uint8_t *)tmp___1;
#line 668
  i = 0U;
  }
  {
#line 668
  while (1) {
    while_continue: /* CIL Label */ ;
#line 668
    if (! (i < e->fileIDLen)) {
#line 668
      goto while_break;
    }
    {
#line 669
    tmp___2 = fscanf((FILE */* __restrict  */)file, (char const   */* __restrict  */)" %d",
                     & tmp);
    }
#line 669
    if (tmp___2 < 1) {
#line 670
      return ((_Bool)0);
    }
#line 671
    *(e->fileID + i) = (uint8_t )tmp;
#line 668
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 675
  tmp___3 = fscanf((FILE */* __restrict  */)file, (char const   */* __restrict  */)(string_FILTER),
                   & len);
  }
#line 675
  if (tmp___3 < 1) {
#line 676
    return ((_Bool)0);
  }
#line 679
  if (len > 256UL) {
#line 680
    return ((_Bool)0);
  } else
#line 679
  if (len < 0UL) {
#line 680
    return ((_Bool)0);
  }
#line 682
  if (len > 0UL) {
    {
#line 683
    tmp___4 = malloc(sizeof(uint8_t ) * len + 1UL);
#line 683
    e->s_handler = (char *)tmp___4;
    }
  }
#line 685
  i = 0U;
  {
#line 685
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 685
    if (! (i < (unsigned int )len)) {
#line 685
      goto while_break___0;
    }
    {
#line 686
    tmp___5 = fscanf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"%c",
                     & c);
    }
#line 686
    if (tmp___5 < 1) {
#line 687
      return ((_Bool)0);
    }
#line 688
    *(e->s_handler + i) = c;
#line 685
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 691
  *(e->s_handler + i) = (char )'\000';
#line 694
  tmp___6 = fscanf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"\nO:");
  }
#line 694
  if (tmp___6 == -1) {
#line 695
    return ((_Bool)0);
  }
  {
#line 696
  tmp___7 = malloc(sizeof(uint8_t ) * 32UL);
#line 696
  e->o_string = (uint8_t *)tmp___7;
#line 697
  tmp___8 = malloc(sizeof(uint8_t ) * 32UL);
#line 697
  e->u_string = (uint8_t *)tmp___8;
#line 698
  i = 0U;
  }
  {
#line 698
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 698
    if (! (i < 32U)) {
#line 698
      goto while_break___1;
    }
    {
#line 699
    tmp___9 = fscanf((FILE */* __restrict  */)file, (char const   */* __restrict  */)" %d",
                     & tmp);
    }
#line 699
    if (tmp___9 < 1) {
#line 700
      return ((_Bool)0);
    }
#line 701
    *(e->o_string + i) = (uint8_t )tmp;
#line 698
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 703
  tmp___10 = fscanf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"\nU:");
  }
#line 703
  if (tmp___10 == -1) {
#line 704
    return ((_Bool)0);
  }
#line 705
  i = 0U;
  {
#line 705
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 705
    if (! (i < 32U)) {
#line 705
      goto while_break___2;
    }
    {
#line 706
    tmp___11 = fscanf((FILE */* __restrict  */)file, (char const   */* __restrict  */)" %d",
                      & tmp);
    }
#line 706
    if (tmp___11 < 1) {
#line 707
      return ((_Bool)0);
    }
#line 708
    *(e->u_string + i) = (uint8_t )tmp;
#line 705
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 712
  tmp___12 = fscanf((FILE */* __restrict  */)file, (char const   */* __restrict  */)(string_UUPWP),
                    & tmp, & tmp2, & tmp3);
  }
#line 712
  if (tmp___12 < 3) {
#line 713
    return ((_Bool)0);
  }
#line 714
  *user = (_Bool )(tmp == 1);
#line 715
  knownPassword = (_Bool )(tmp2 == 1);
#line 716
  permutation = (_Bool )(tmp3 == 1);
#line 719
  if (knownPassword) {
#line 720
    i = 0U;
    {
#line 720
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 720
      if (! (i < 32U)) {
#line 720
        goto while_break___3;
      }
      {
#line 721
      tmp___13 = fscanf((FILE */* __restrict  */)file, (char const   */* __restrict  */)" %d",
                        & tmp);
      }
#line 721
      if (tmp___13 < 1) {
#line 722
        return ((_Bool)0);
      }
#line 723
      password_user[i] = (uint8_t )tmp;
#line 720
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  {
#line 728
  tmp___14 = pw_loadState(file, wl);
  }
#line 728
  if (! tmp___14) {
#line 729
    return ((_Bool)0);
  }
#line 733
  recovery___0 = (_Bool)1;
#line 735
  return ((_Bool)1);
}
}
#line 739 "/home/wheatley/newnew/temp/pdfcrack-0.12/pdfcrack.c"
void saveState(FILE *file ) 
{ 
  unsigned int i ;
  size_t tmp ;

  {
  {
#line 743
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)(string_PRVPL),
          encdata->version_major, encdata->version_minor, encdata->revision, encdata->version,
          encdata->permissions, encdata->length, (int )encdata->encryptMetaData, encdata->fileIDLen);
#line 747
  i = 0U;
  }
  {
#line 747
  while (1) {
    while_continue: /* CIL Label */ ;
#line 747
    if (! (i < (unsigned int )encdata->fileIDLen)) {
#line 747
      goto while_break;
    }
    {
#line 748
    fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)" %d",
            (int )*(encdata->fileID + i));
#line 747
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 749
  tmp = strlen((char const   *)encdata->s_handler);
#line 749
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)(string_FILTER),
          tmp);
#line 750
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"%s", encdata->s_handler);
#line 751
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"\nO:");
#line 752
  i = 0U;
  }
  {
#line 752
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 752
    if (! (i < 32U)) {
#line 752
      goto while_break___0;
    }
    {
#line 753
    fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)" %d",
            (int )*(encdata->o_string + i));
#line 752
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 754
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"\nU:");
#line 755
  i = 0U;
  }
  {
#line 755
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 755
    if (! (i < 32U)) {
#line 755
      goto while_break___1;
    }
    {
#line 756
    fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)" %d",
            (int )*(encdata->u_string + i));
#line 755
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 757
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)(string_UUPWP),
          (int )workWithUser, (int )knownPassword, (int )permutation);
  }
#line 759
  if (knownPassword) {
#line 760
    i = 0U;
    {
#line 760
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 760
      if (! (i < 32U)) {
#line 760
        goto while_break___2;
      }
      {
#line 761
      fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)" %d",
              (int )password_user[i]);
#line 760
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 765
  pw_saveState(file);
  }
#line 766
  return;
}
}
#line 189 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) clock_t ( __attribute__((__leaf__)) clock)(void) ;
#line 36 "/home/wheatley/newnew/temp/pdfcrack-0.12/benchmark.c"
static _Bool finished  =    (_Bool)0;
#line 39 "/home/wheatley/newnew/temp/pdfcrack-0.12/benchmark.c"
static void interruptBench(void) 
{ 


  {
#line 41
  finished = (_Bool)1;
#line 42
  return;
}
}
#line 51 "/home/wheatley/newnew/temp/pdfcrack-0.12/benchmark.c"
static void print_and_clean(char const   *str , unsigned int nrprocessed___0 , clock_t const   *start ,
                            clock_t const   *end ) 
{ 


  {
  {
#line 54
  printf((char const   */* __restrict  */)"%s\t%.1f\n", str, (double )nrprocessed___0 / ((double )(*end - *start) / (double )1000000L));
#line 56
  cleanPDFCrack();
#line 57
  finished = (_Bool)0;
  }
#line 58
  return;
}
}
#line 62 "/home/wheatley/newnew/temp/pdfcrack-0.12/benchmark.c"
static void md5_bench(void) 
{ 
  uint8_t *buf ;
  uint8_t digest[16] ;
  unsigned int nrprocessed___0 ;
  clock_t startTime___0 ;
  clock_t endTime ;
  void *tmp ;

  {
  {
#line 66
  nrprocessed___0 = 0U;
#line 69
  tmp = calloc((size_t )88, sizeof(uint8_t ));
#line 69
  buf = (uint8_t *)tmp;
#line 71
  alarm(3U);
#line 72
  startTime___0 = clock();
  }
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 73
    if (! (! finished)) {
#line 73
      goto while_break;
    }
    {
#line 74
    md5((uint8_t const   *)buf, (unsigned int const   )88, digest);
#line 75
    *(buf + 0) = (uint8_t )((int )*(buf + 0) + 1);
#line 76
    nrprocessed___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 78
  endTime = clock();
#line 79
  print_and_clean("MD5:\t\t", nrprocessed___0, (clock_t const   *)(& startTime___0),
                  (clock_t const   *)(& endTime));
#line 80
  free((void *)buf);
  }
#line 81
  return;
}
}
#line 83 "/home/wheatley/newnew/temp/pdfcrack-0.12/benchmark.c"
static void md5_50_bench(void) 
{ 
  uint8_t *buf ;
  unsigned int nrprocessed___0 ;
  clock_t startTime___0 ;
  clock_t endTime ;
  int i ;
  void *tmp ;

  {
  {
#line 86
  nrprocessed___0 = 0U;
#line 90
  tmp = calloc((size_t )16, sizeof(uint8_t ));
#line 90
  buf = (uint8_t *)tmp;
#line 92
  alarm(3U);
#line 93
  startTime___0 = clock();
  }
  {
#line 94
  while (1) {
    while_continue: /* CIL Label */ ;
#line 94
    if (! (! finished)) {
#line 94
      goto while_break;
    }
    {
#line 95
    md5_50(buf);
#line 96
    *(buf + 0) = (uint8_t )((int )*(buf + 0) + 1);
#line 97
    nrprocessed___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 99
  endTime = clock();
#line 100
  print_and_clean("MD5_50 (fast):\t", nrprocessed___0, (clock_t const   *)(& startTime___0),
                  (clock_t const   *)(& endTime));
#line 102
  *(buf + 0) = (uint8_t )0;
#line 103
  nrprocessed___0 = 0U;
#line 104
  alarm(3U);
#line 105
  startTime___0 = clock();
  }
  {
#line 106
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 106
    if (! (! finished)) {
#line 106
      goto while_break___0;
    }
#line 107
    i = 0;
    {
#line 107
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 107
      if (! (i < 50)) {
#line 107
        goto while_break___1;
      }
      {
#line 108
      md5((uint8_t const   *)buf, (unsigned int const   )16, buf);
#line 107
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 109
    *(buf + 0) = (uint8_t )((int )*(buf + 0) + 1);
#line 110
    nrprocessed___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 112
  endTime = clock();
#line 113
  print_and_clean("MD5_50 (slow):\t", nrprocessed___0, (clock_t const   *)(& startTime___0),
                  (clock_t const   *)(& endTime));
#line 115
  free((void *)buf);
  }
#line 116
  return;
}
}
#line 118 "/home/wheatley/newnew/temp/pdfcrack-0.12/benchmark.c"
static void rc4_bench(void) 
{ 
  uint8_t *enckey ;
  uint8_t match[32] ;
  uint8_t cipher[32] ;
  unsigned int nrprocessed___0 ;
  clock_t startTime___0 ;
  clock_t endTime ;
  void *tmp ;

  {
  {
#line 121
  match[0] = (uint8_t )222;
#line 121
  match[1] = (uint8_t )173;
#line 121
  match[2] = (uint8_t )190;
#line 121
  match[3] = (uint8_t )173;
#line 121
  match[4] = (uint8_t )222;
#line 121
  match[5] = (uint8_t )173;
#line 121
  match[6] = (uint8_t )190;
#line 121
  match[7] = (uint8_t )173;
#line 121
  match[8] = (uint8_t )222;
#line 121
  match[9] = (uint8_t )173;
#line 121
  match[10] = (uint8_t )190;
#line 121
  match[11] = (uint8_t )173;
#line 121
  match[12] = (uint8_t )222;
#line 121
  match[13] = (uint8_t )173;
#line 121
  match[14] = (uint8_t )190;
#line 121
  match[15] = (uint8_t )173;
#line 121
  match[16] = (uint8_t )222;
#line 121
  match[17] = (uint8_t )173;
#line 121
  match[18] = (uint8_t )190;
#line 121
  match[19] = (uint8_t )173;
#line 121
  match[20] = (uint8_t )222;
#line 121
  match[21] = (uint8_t )173;
#line 121
  match[22] = (uint8_t )190;
#line 121
  match[23] = (uint8_t )173;
#line 121
  match[24] = (uint8_t )222;
#line 121
  match[25] = (uint8_t )173;
#line 121
  match[26] = (uint8_t )190;
#line 121
  match[27] = (uint8_t )173;
#line 121
  match[28] = (uint8_t )222;
#line 121
  match[29] = (uint8_t )173;
#line 121
  match[30] = (uint8_t )190;
#line 121
  match[31] = (uint8_t )173;
#line 129
  cipher[0] = (uint8_t )190;
#line 129
  cipher[1] = (uint8_t )173;
#line 129
  cipher[2] = (uint8_t )222;
#line 129
  cipher[3] = (uint8_t )173;
#line 129
  cipher[4] = (uint8_t )190;
#line 129
  cipher[5] = (uint8_t )173;
#line 129
  cipher[6] = (uint8_t )222;
#line 129
  cipher[7] = (uint8_t )173;
#line 129
  cipher[8] = (uint8_t )190;
#line 129
  cipher[9] = (uint8_t )173;
#line 129
  cipher[10] = (uint8_t )222;
#line 129
  cipher[11] = (uint8_t )173;
#line 129
  cipher[12] = (uint8_t )190;
#line 129
  cipher[13] = (uint8_t )173;
#line 129
  cipher[14] = (uint8_t )222;
#line 129
  cipher[15] = (uint8_t )173;
#line 129
  cipher[16] = (uint8_t )190;
#line 129
  cipher[17] = (uint8_t )173;
#line 129
  cipher[18] = (uint8_t )222;
#line 129
  cipher[19] = (uint8_t )173;
#line 129
  cipher[20] = (uint8_t )190;
#line 129
  cipher[21] = (uint8_t )173;
#line 129
  cipher[22] = (uint8_t )222;
#line 129
  cipher[23] = (uint8_t )173;
#line 129
  cipher[24] = (uint8_t )190;
#line 129
  cipher[25] = (uint8_t )173;
#line 129
  cipher[26] = (uint8_t )222;
#line 129
  cipher[27] = (uint8_t )173;
#line 129
  cipher[28] = (uint8_t )190;
#line 129
  cipher[29] = (uint8_t )173;
#line 129
  cipher[30] = (uint8_t )222;
#line 129
  cipher[31] = (uint8_t )173;
#line 137
  nrprocessed___0 = 0U;
#line 140
  tmp = calloc((size_t )16, sizeof(uint8_t ));
#line 140
  enckey = (uint8_t *)tmp;
#line 142
  alarm(3U);
#line 143
  startTime___0 = clock();
  }
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
#line 144
    if (! (! finished)) {
#line 144
      goto while_break;
    }
    {
#line 145
    rc4Match40b((uint8_t const   *)enckey, (uint8_t const   *)(cipher), (uint8_t const   *)(match));
#line 146
    *(enckey + 0) = (uint8_t )((int )*(enckey + 0) + 1);
#line 147
    nrprocessed___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 149
  endTime = clock();
#line 150
  print_and_clean("RC4 (40, static):", nrprocessed___0, (clock_t const   *)(& startTime___0),
                  (clock_t const   *)(& endTime));
#line 151
  setrc4DecryptMethod((unsigned int const   )40);
#line 152
  nrprocessed___0 = 0U;
#line 153
  alarm(3U);
#line 154
  startTime___0 = clock();
  }
  {
#line 155
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 155
    if (! (! finished)) {
#line 155
      goto while_break___0;
    }
    {
#line 156
    rc4Decrypt((uint8_t const   *)enckey, (uint8_t const   *)(cipher), (unsigned int const   )3,
               match);
#line 157
    *(enckey + 0) = (uint8_t )((int )*(enckey + 0) + 1);
#line 158
    nrprocessed___0 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 160
  endTime = clock();
#line 161
  print_and_clean("RC4 (40, no check):", nrprocessed___0, (clock_t const   *)(& startTime___0),
                  (clock_t const   *)(& endTime));
#line 163
  setrc4DecryptMethod((unsigned int const   )128);
#line 164
  nrprocessed___0 = 0U;
#line 165
  alarm(3U);
#line 166
  startTime___0 = clock();
  }
  {
#line 167
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 167
    if (! (! finished)) {
#line 167
      goto while_break___1;
    }
    {
#line 168
    rc4Decrypt((uint8_t const   *)enckey, (uint8_t const   *)(cipher), (unsigned int const   )3,
               match);
#line 169
    *(enckey + 0) = (uint8_t )((int )*(enckey + 0) + 1);
#line 170
    nrprocessed___0 ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 172
  endTime = clock();
#line 173
  print_and_clean("RC4 (128, no check):", nrprocessed___0, (clock_t const   *)(& startTime___0),
                  (clock_t const   *)(& endTime));
#line 175
  free((void *)enckey);
  }
#line 176
  return;
}
}
#line 178 "/home/wheatley/newnew/temp/pdfcrack-0.12/benchmark.c"
static uint8_t const   password___0[33]  = 
#line 178
  {      (uint8_t const   )'F',      (uint8_t const   )'o',      (uint8_t const   )'r',      (uint8_t const   )'t', 
        (uint8_t const   )'y',      (uint8_t const   )'-',      (uint8_t const   )'T',      (uint8_t const   )'w', 
        (uint8_t const   )'o',      (uint8_t const   )' ',      (uint8_t const   )'i',      (uint8_t const   )'s', 
        (uint8_t const   )' ',      (uint8_t const   )'t',      (uint8_t const   )'h',      (uint8_t const   )'e', 
        (uint8_t const   )' ',      (uint8_t const   )'U',      (uint8_t const   )'l',      (uint8_t const   )'t', 
        (uint8_t const   )'i',      (uint8_t const   )'m',      (uint8_t const   )'a',      (uint8_t const   )'t', 
        (uint8_t const   )'e',      (uint8_t const   )' ',      (uint8_t const   )'A',      (uint8_t const   )'n', 
        (uint8_t const   )'s',      (uint8_t const   )'w',      (uint8_t const   )'e',      (uint8_t const   )'r', 
        (uint8_t const   )'\000'};
#line 179 "/home/wheatley/newnew/temp/pdfcrack-0.12/benchmark.c"
static char handler[9]  = 
#line 179
  {      (char )'S',      (char )'t',      (char )'a',      (char )'n', 
        (char )'d',      (char )'a',      (char )'r',      (char )'d', 
        (char )'\000'};
#line 180 "/home/wheatley/newnew/temp/pdfcrack-0.12/benchmark.c"
static char const   charset___0[11]  = 
#line 180
  {      (char const   )'a',      (char const   )'b',      (char const   )'c',      (char const   )'d', 
        (char const   )'e',      (char const   )'f',      (char const   )'g',      (char const   )'h', 
        (char const   )'i',      (char const   )'j',      (char const   )'\000'};
#line 182 "/home/wheatley/newnew/temp/pdfcrack-0.12/benchmark.c"
static void pdf_128b_bench(void) 
{ 
  clock_t startTime___0 ;
  clock_t endTime ;
  uint8_t o_string[32] ;
  uint8_t u_string[32] ;
  uint8_t fileid[16] ;
  EncData e ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
#line 185
  o_string[0] = (uint8_t )207;
#line 185
  o_string[1] = (uint8_t )235;
#line 185
  o_string[2] = (uint8_t )87;
#line 185
  o_string[3] = (uint8_t )27;
#line 185
  o_string[4] = (uint8_t )164;
#line 185
  o_string[5] = (uint8_t )86;
#line 185
  o_string[6] = (uint8_t )53;
#line 185
  o_string[7] = (uint8_t )25;
#line 185
  o_string[8] = (uint8_t )78;
#line 185
  o_string[9] = (uint8_t )9;
#line 185
  o_string[10] = (uint8_t )149;
#line 185
  o_string[11] = (uint8_t )36;
#line 185
  o_string[12] = (uint8_t )35;
#line 185
  o_string[13] = (uint8_t )243;
#line 185
  o_string[14] = (uint8_t )155;
#line 185
  o_string[15] = (uint8_t )129;
#line 185
  o_string[16] = (uint8_t )5;
#line 185
  o_string[17] = (uint8_t )174;
#line 185
  o_string[18] = (uint8_t )188;
#line 185
  o_string[19] = (uint8_t )178;
#line 185
  o_string[20] = (uint8_t )140;
#line 185
  o_string[21] = (uint8_t )24;
#line 185
  o_string[22] = (uint8_t )210;
#line 185
  o_string[23] = (uint8_t )187;
#line 185
  o_string[24] = (uint8_t )255;
#line 185
  o_string[25] = (uint8_t )0;
#line 185
  o_string[26] = (uint8_t )201;
#line 185
  o_string[27] = (uint8_t )170;
#line 185
  o_string[28] = (uint8_t )63;
#line 185
  o_string[29] = (uint8_t )54;
#line 185
  o_string[30] = (uint8_t )227;
#line 185
  o_string[31] = (uint8_t )19;
#line 189
  u_string[0] = (uint8_t )114;
#line 189
  u_string[1] = (uint8_t )246;
#line 189
  u_string[2] = (uint8_t )86;
#line 189
  u_string[3] = (uint8_t )158;
#line 189
  u_string[4] = (uint8_t )218;
#line 189
  u_string[5] = (uint8_t )125;
#line 189
  u_string[6] = (uint8_t )32;
#line 189
  u_string[7] = (uint8_t )26;
#line 189
  u_string[8] = (uint8_t )16;
#line 189
  u_string[9] = (uint8_t )109;
#line 189
  u_string[10] = (uint8_t )138;
#line 189
  u_string[11] = (uint8_t )91;
#line 189
  u_string[12] = (uint8_t )250;
#line 189
  u_string[13] = (uint8_t )178;
#line 189
  u_string[14] = (uint8_t )233;
#line 189
  u_string[15] = (uint8_t )192;
#line 189
  u_string[16] = (uint8_t )40;
#line 189
  u_string[17] = (uint8_t )191;
#line 189
  u_string[18] = (uint8_t )78;
#line 189
  u_string[19] = (uint8_t )94;
#line 189
  u_string[20] = (uint8_t )78;
#line 189
  u_string[21] = (uint8_t )117;
#line 189
  u_string[22] = (uint8_t )138;
#line 189
  u_string[23] = (uint8_t )65;
#line 189
  u_string[24] = (uint8_t )100;
#line 189
  u_string[25] = (uint8_t )0;
#line 189
  u_string[26] = (uint8_t )78;
#line 189
  u_string[27] = (uint8_t )86;
#line 189
  u_string[28] = (uint8_t )255;
#line 189
  u_string[29] = (uint8_t )250;
#line 189
  u_string[30] = (uint8_t )1;
#line 189
  u_string[31] = (uint8_t )8;
#line 193
  fileid[0] = (uint8_t )201;
#line 193
  fileid[1] = (uint8_t )170;
#line 193
  fileid[2] = (uint8_t )85;
#line 193
  fileid[3] = (uint8_t )195;
#line 193
  fileid[4] = (uint8_t )111;
#line 193
  fileid[5] = (uint8_t )63;
#line 193
  fileid[6] = (uint8_t )94;
#line 193
  fileid[7] = (uint8_t )132;
#line 193
  fileid[8] = (uint8_t )13;
#line 193
  fileid[9] = (uint8_t )61;
#line 193
  fileid[10] = (uint8_t )150;
#line 193
  fileid[11] = (uint8_t )139;
#line 193
  fileid[12] = (uint8_t )151;
#line 193
  fileid[13] = (uint8_t )219;
#line 193
  fileid[14] = (uint8_t )178;
#line 193
  fileid[15] = (uint8_t )254;
#line 195
  e.s_handler = handler;
#line 195
  e.o_string = o_string;
#line 195
  e.u_string = u_string;
#line 195
  e.fileID = fileid;
#line 195
  e.encryptMetaData = (_Bool)1;
#line 195
  e.fileIDLen = 16U;
#line 195
  e.version_major = 1U;
#line 195
  e.version_minor = 4U;
#line 195
  e.length = 128;
#line 195
  e.permissions = -2359344;
#line 195
  e.revision = 3;
#line 195
  e.version = 2;
#line 204
  initPDFCrack((EncData const   *)(& e), (uint8_t const   *)((void *)0), (_Bool const   )1,
               (char const   *)((void *)0), (passwordMethod const   )2, (FILE *)((void *)0),
               charset___0, (unsigned int const   )0, (unsigned int const   )4, (_Bool const   )1);
#line 206
  startTime___0 = clock();
#line 207
  runCrackRev3();
#line 208
  endTime = clock();
#line 209
  tmp = getNrProcessed();
#line 209
  print_and_clean("PDF (128, user):", tmp, (clock_t const   *)(& startTime___0), (clock_t const   *)(& endTime));
#line 211
  initPDFCrack((EncData const   *)(& e), (uint8_t const   *)((void *)0), (_Bool const   )0,
               (char const   *)((void *)0), (passwordMethod const   )2, (FILE *)((void *)0),
               charset___0, (unsigned int const   )0, (unsigned int const   )4, (_Bool const   )1);
#line 213
  startTime___0 = clock();
#line 214
  runCrackRev3_o();
#line 215
  endTime = clock();
#line 217
  tmp___0 = getNrProcessed();
#line 217
  print_and_clean("PDF (128, owner):", tmp___0, (clock_t const   *)(& startTime___0),
                  (clock_t const   *)(& endTime));
#line 219
  initPDFCrack((EncData const   *)(& e), password___0, (_Bool const   )0, (char const   *)((void *)0),
               (passwordMethod const   )2, (FILE *)((void *)0), charset___0, (unsigned int const   )0,
               (unsigned int const   )4, (_Bool const   )1);
#line 221
  startTime___0 = clock();
#line 222
  runCrackRev3_of();
#line 223
  endTime = clock();
#line 225
  tmp___1 = getNrProcessed();
#line 225
  print_and_clean("PDF (128, owner, fast):", tmp___1, (clock_t const   *)(& startTime___0),
                  (clock_t const   *)(& endTime));
  }
#line 227
  return;
}
}
#line 229 "/home/wheatley/newnew/temp/pdfcrack-0.12/benchmark.c"
static void pdf_40b_bench(void) 
{ 
  clock_t startTime___0 ;
  clock_t endTime ;
  uint8_t o_string[32] ;
  uint8_t u_string[32] ;
  uint8_t fileid[16] ;
  EncData e ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
#line 232
  o_string[0] = (uint8_t )183;
#line 232
  o_string[1] = (uint8_t )129;
#line 232
  o_string[2] = (uint8_t )200;
#line 232
  o_string[3] = (uint8_t )61;
#line 232
  o_string[4] = (uint8_t )147;
#line 232
  o_string[5] = (uint8_t )121;
#line 232
  o_string[6] = (uint8_t )33;
#line 232
  o_string[7] = (uint8_t )204;
#line 232
  o_string[8] = (uint8_t )15;
#line 232
  o_string[9] = (uint8_t )61;
#line 232
  o_string[10] = (uint8_t )64;
#line 232
  o_string[11] = (uint8_t )237;
#line 232
  o_string[12] = (uint8_t )24;
#line 232
  o_string[13] = (uint8_t )231;
#line 232
  o_string[14] = (uint8_t )127;
#line 232
  o_string[15] = (uint8_t )126;
#line 232
  o_string[16] = (uint8_t )192;
#line 232
  o_string[17] = (uint8_t )21;
#line 232
  o_string[18] = (uint8_t )177;
#line 232
  o_string[19] = (uint8_t )99;
#line 232
  o_string[20] = (uint8_t )245;
#line 232
  o_string[21] = (uint8_t )200;
#line 232
  o_string[22] = (uint8_t )52;
#line 232
  o_string[23] = (uint8_t )224;
#line 232
  o_string[24] = (uint8_t )84;
#line 232
  o_string[25] = (uint8_t )55;
#line 232
  o_string[26] = (uint8_t )65;
#line 232
  o_string[27] = (uint8_t )41;
#line 232
  o_string[28] = (uint8_t )231;
#line 232
  o_string[29] = (uint8_t )197;
#line 232
  o_string[30] = (uint8_t )29;
#line 232
  o_string[31] = (uint8_t )227;
#line 236
  u_string[0] = (uint8_t )97;
#line 236
  u_string[1] = (uint8_t )116;
#line 236
  u_string[2] = (uint8_t )124;
#line 236
  u_string[3] = (uint8_t )92;
#line 236
  u_string[4] = (uint8_t )181;
#line 236
  u_string[5] = (uint8_t )56;
#line 236
  u_string[6] = (uint8_t )61;
#line 236
  u_string[7] = (uint8_t )221;
#line 236
  u_string[8] = (uint8_t )111;
#line 236
  u_string[9] = (uint8_t )203;
#line 236
  u_string[10] = (uint8_t )178;
#line 236
  u_string[11] = (uint8_t )242;
#line 236
  u_string[12] = (uint8_t )254;
#line 236
  u_string[13] = (uint8_t )227;
#line 236
  u_string[14] = (uint8_t )52;
#line 236
  u_string[15] = (uint8_t )141;
#line 236
  u_string[16] = (uint8_t )129;
#line 236
  u_string[17] = (uint8_t )226;
#line 236
  u_string[18] = (uint8_t )73;
#line 236
  u_string[19] = (uint8_t )153;
#line 236
  u_string[20] = (uint8_t )196;
#line 236
  u_string[21] = (uint8_t )20;
#line 236
  u_string[22] = (uint8_t )246;
#line 236
  u_string[23] = (uint8_t )111;
#line 236
  u_string[24] = (uint8_t )208;
#line 236
  u_string[25] = (uint8_t )15;
#line 236
  u_string[26] = (uint8_t )151;
#line 236
  u_string[27] = (uint8_t )232;
#line 236
  u_string[28] = (uint8_t )184;
#line 236
  u_string[29] = (uint8_t )41;
#line 236
  u_string[30] = (uint8_t )230;
#line 236
  u_string[31] = (uint8_t )39;
#line 240
  fileid[0] = (uint8_t )33;
#line 240
  fileid[1] = (uint8_t )118;
#line 240
  fileid[2] = (uint8_t )54;
#line 240
  fileid[3] = (uint8_t )102;
#line 240
  fileid[4] = (uint8_t )103;
#line 240
  fileid[5] = (uint8_t )240;
#line 240
  fileid[6] = (uint8_t )134;
#line 240
  fileid[7] = (uint8_t )213;
#line 240
  fileid[8] = (uint8_t )9;
#line 240
  fileid[9] = (uint8_t )136;
#line 240
  fileid[10] = (uint8_t )195;
#line 240
  fileid[11] = (uint8_t )167;
#line 240
  fileid[12] = (uint8_t )233;
#line 240
  fileid[13] = (uint8_t )58;
#line 240
  fileid[14] = (uint8_t )146;
#line 240
  fileid[15] = (uint8_t )202;
#line 242
  e.s_handler = handler;
#line 242
  e.o_string = o_string;
#line 242
  e.u_string = u_string;
#line 242
  e.fileID = fileid;
#line 242
  e.encryptMetaData = (_Bool)1;
#line 242
  e.fileIDLen = 16U;
#line 242
  e.version_major = 1U;
#line 242
  e.version_minor = 4U;
#line 242
  e.length = 40;
#line 242
  e.permissions = -64;
#line 242
  e.revision = 2;
#line 242
  e.version = 1;
#line 251
  initPDFCrack((EncData const   *)(& e), (uint8_t const   *)((void *)0), (_Bool const   )1,
               (char const   *)((void *)0), (passwordMethod const   )2, (FILE *)((void *)0),
               charset___0, (unsigned int const   )0, (unsigned int const   )5, (_Bool const   )1);
#line 253
  startTime___0 = clock();
#line 254
  runCrackRev2();
#line 255
  endTime = clock();
#line 257
  tmp = getNrProcessed();
#line 257
  print_and_clean("PDF (40, user):\t", tmp, (clock_t const   *)(& startTime___0),
                  (clock_t const   *)(& endTime));
#line 259
  initPDFCrack((EncData const   *)(& e), (uint8_t const   *)((void *)0), (_Bool const   )0,
               (char const   *)((void *)0), (passwordMethod const   )2, (FILE *)((void *)0),
               charset___0, (unsigned int const   )0, (unsigned int const   )5, (_Bool const   )1);
#line 261
  startTime___0 = clock();
#line 262
  runCrackRev2_o();
#line 263
  endTime = clock();
#line 265
  tmp___0 = getNrProcessed();
#line 265
  print_and_clean("PDF (40, owner):", tmp___0, (clock_t const   *)(& startTime___0),
                  (clock_t const   *)(& endTime));
#line 266
  initPDFCrack((EncData const   *)(& e), password___0, (_Bool const   )0, (char const   *)((void *)0),
               (passwordMethod const   )2, (FILE *)((void *)0), charset___0, (unsigned int const   )0,
               (unsigned int const   )5, (_Bool const   )1);
#line 268
  startTime___0 = clock();
#line 269
  runCrackRev2_of();
#line 270
  endTime = clock();
#line 272
  tmp___1 = getNrProcessed();
#line 272
  print_and_clean("PDF (40, owner, fast):", tmp___1, (clock_t const   *)(& startTime___0),
                  (clock_t const   *)(& endTime));
  }
#line 274
  return;
}
}
#line 276 "/home/wheatley/newnew/temp/pdfcrack-0.12/benchmark.c"
void runBenchmark(void) 
{ 
  struct sigaction act ;

  {
  {
#line 279
  act.__sigaction_handler.sa_handler = (void (*)(int  ))(& interruptBench);
#line 280
  sigemptyset(& act.sa_mask);
#line 281
  act.sa_flags = 0;
#line 282
  sigaction(14, (struct sigaction  const  */* __restrict  */)(& act), (struct sigaction */* __restrict  */)0);
#line 284
  printf((char const   */* __restrict  */)"Benchmark:\tAverage Speed (calls / second):\n");
#line 285
  md5_bench();
#line 286
  md5_50_bench();
#line 287
  printf((char const   */* __restrict  */)"\n");
#line 288
  rc4_bench();
#line 289
  printf((char const   */* __restrict  */)"\n");
#line 290
  printf((char const   */* __restrict  */)"Benchmark:\tAverage Speed (passwords / second):\n");
#line 291
  pdf_40b_bench();
#line 292
  printf((char const   */* __restrict  */)"\n");
#line 293
  pdf_128b_bench();
  }
#line 295
  return;
}
}
