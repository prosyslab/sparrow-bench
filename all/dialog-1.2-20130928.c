/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 324 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef int wchar_t;
#line 150 "/usr/include/curses.h"
typedef unsigned long chtype;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 358 "/usr/include/curses.h"
struct _win_st;
#line 358 "/usr/include/curses.h"
typedef struct _win_st WINDOW;
#line 360 "/usr/include/curses.h"
typedef chtype attr_t;
#line 390 "/usr/include/curses.h"
struct __anonstruct_cchar_t_57 {
   attr_t attr ;
   wchar_t chars[5] ;
};
#line 390 "/usr/include/curses.h"
typedef struct __anonstruct_cchar_t_57 cchar_t;
#line 405
struct ldat;
#line 407 "/usr/include/curses.h"
struct pdat {
   short _pad_y ;
   short _pad_x ;
   short _pad_top ;
   short _pad_left ;
   short _pad_bottom ;
   short _pad_right ;
};
#line 407 "/usr/include/curses.h"
struct _win_st {
   short _cury ;
   short _curx ;
   short _maxy ;
   short _maxx ;
   short _begy ;
   short _begx ;
   short _flags ;
   attr_t _attrs ;
   chtype _bkgd ;
   _Bool _notimeout ;
   _Bool _clear ;
   _Bool _leaveok ;
   _Bool _scroll ;
   _Bool _idlok ;
   _Bool _idcok ;
   _Bool _immed ;
   _Bool _sync ;
   _Bool _use_keypad ;
   int _delay ;
   struct ldat *_line ;
   short _regtop ;
   short _regbottom ;
   int _parx ;
   int _pary ;
   WINDOW *_parent ;
   struct pdat _pad ;
   short _yoffset ;
   cchar_t _bkgrnd ;
};
#line 394 "./dialog.h"
struct _dlg_callback;
#line 398 "./dialog.h"
struct _dlg_callback {
   struct _dlg_callback *next ;
   FILE *input ;
   WINDOW *win ;
   _Bool keep_bg ;
   _Bool bg_task ;
   _Bool (*handle_getc)(struct _dlg_callback *p , int ch , int fkey , int *result ) ;
   _Bool keep_win ;
   struct _dlg_callback **caller ;
   void (*freeback)(struct _dlg_callback * ) ;
   _Bool (*handle_input)(struct _dlg_callback *p ) ;
   _Bool input_ready ;
};
#line 398 "./dialog.h"
typedef struct _dlg_callback DIALOG_CALLBACK;
#line 414 "./dialog.h"
struct _dlg_windows {
   struct _dlg_windows *next ;
   WINDOW *normal ;
   WINDOW *shadow ;
};
#line 414 "./dialog.h"
typedef struct _dlg_windows DIALOG_WINDOWS;
#line 423 "./dialog.h"
struct __anonstruct_DIALOG_STATE_59 {
   DIALOG_CALLBACK *getc_callbacks ;
   DIALOG_CALLBACK *getc_redirect ;
   DIALOG_WINDOWS *all_windows ;
   DIALOG_WINDOWS *all_subwindows ;
   FILE *output ;
   FILE *pipe_input ;
   FILE *screen_output ;
   _Bool screen_initialized ;
   _Bool use_colors ;
   _Bool use_scrollbar ;
   _Bool use_shadow ;
   _Bool visit_items ;
   char *separate_str ;
   int aspect_ratio ;
   int output_count ;
   int tab_len ;
   FILE *input ;
   FILE *trace_output ;
   _Bool no_mouse ;
   int visit_cols ;
   _Bool finish_string ;
};
#line 423 "./dialog.h"
typedef struct __anonstruct_DIALOG_STATE_59 DIALOG_STATE;
#line 457 "./dialog.h"
struct __anonstruct_DIALOG_VARS_60 {
   _Bool beep_after_signal ;
   _Bool beep_signal ;
   _Bool begin_set ;
   _Bool cant_kill ;
   _Bool colors ;
   _Bool cr_wrap ;
   _Bool defaultno ;
   _Bool dlg_clear_screen ;
   _Bool extra_button ;
   _Bool help_button ;
   _Bool help_status ;
   _Bool input_menu ;
   _Bool insecure ;
   _Bool item_help ;
   _Bool keep_window ;
   _Bool nocancel ;
   _Bool nocollapse ;
   _Bool print_siz ;
   _Bool separate_output ;
   _Bool single_quoted ;
   _Bool size_err ;
   _Bool tab_correct ;
   _Bool trim_whitespace ;
   char *backtitle ;
   char *cancel_label ;
   char *default_item ;
   char *exit_label ;
   char *extra_label ;
   char *help_label ;
   char *input_result ;
   char *no_label ;
   char *ok_label ;
   char *title ;
   char *yes_label ;
   int begin_x ;
   int begin_y ;
   int max_input ;
   int scale_factor ;
   int sleep_secs ;
   int timeout_secs ;
   unsigned int input_length ;
   unsigned int formitem_type ;
   _Bool keep_tite ;
   _Bool ascii_lines ;
   _Bool no_lines ;
   _Bool nook ;
   _Bool quoted ;
   char *column_header ;
   char *column_separator ;
   char *output_separator ;
   char *date_format ;
   char *time_format ;
   char *help_line ;
   char *help_file ;
   _Bool in_helpfile ;
   _Bool no_nl_expand ;
   int default_button ;
   _Bool no_tags ;
   _Bool no_items ;
   _Bool last_key ;
   _Bool help_tags ;
};
#line 457 "./dialog.h"
typedef struct __anonstruct_DIALOG_VARS_60 DIALOG_VARS;
#line 567 "./dialog.h"
struct __anonstruct_DIALOG_COLORS_61 {
   chtype atr ;
   int fg ;
   int bg ;
   int hilite ;
   char const   *name ;
   char const   *comment ;
};
#line 567 "./dialog.h"
typedef struct __anonstruct_DIALOG_COLORS_61 DIALOG_COLORS;
#line 613 "./dialog.h"
struct __anonstruct_DIALOG_LISTITEM_62 {
   char *name ;
   char *text ;
   char *help ;
   int state ;
};
#line 613 "./dialog.h"
typedef struct __anonstruct_DIALOG_LISTITEM_62 DIALOG_LISTITEM;
#line 638 "./dialog.h"
typedef int DIALOG_INPUTMENU(DIALOG_LISTITEM * , int  , char * );
#line 43 "./dlg_keys.h"
struct __anonstruct_DLG_KEYS_BINDING_64 {
   int is_function_key ;
   int curses_key ;
   int dialog_key ;
};
#line 43 "./dlg_keys.h"
typedef struct __anonstruct_DLG_KEYS_BINDING_64 DLG_KEYS_BINDING;
#line 30 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/menubox.c"
enum __anonenum_Mode_66 {
    Unselected = 0,
    Selected = 1,
    Editing = 2
} ;
#line 30 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/menubox.c"
typedef enum __anonenum_Mode_66 Mode;
#line 36 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/menubox.c"
struct __anonstruct_ALL_DATA_67 {
   WINDOW *dialog ;
   int box_y ;
   int box_x ;
   int tag_x ;
   int item_x ;
   int menu_height ;
   int menu_width ;
   WINDOW *menu ;
   DIALOG_LISTITEM *items ;
   int item_no ;
};
#line 36 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/menubox.c"
typedef struct __anonstruct_ALL_DATA_67 ALL_DATA;
#line 835 "./dialog.h"
struct mseRegion {
   int x ;
   int y ;
   int X ;
   int Y ;
   int code ;
   int mode ;
   int step_x ;
   int step_y ;
   struct mseRegion *next ;
};
#line 835 "./dialog.h"
typedef struct mseRegion mseRegion;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_3 {
   __fd_mask fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_3 fd_set;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 643 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/ui_getc.c"
union __anonunion_66 {
   int __in ;
   int __i ;
};
#line 34 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/checklist.c"
struct __anonstruct_ALL_DATA_66 {
   WINDOW *dialog ;
   int box_y ;
   int box_x ;
   int check_x ;
   int item_x ;
   int checkflag ;
   int use_height ;
   int use_width ;
   WINDOW *list ;
   DIALOG_LISTITEM *items ;
   int item_no ;
   char const   *states ;
};
#line 34 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/checklist.c"
typedef struct __anonstruct_ALL_DATA_66 ALL_DATA___0;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 620 "./dialog.h"
struct __anonstruct_DIALOG_FORMITEM_63 {
   unsigned int type ;
   char *name ;
   int name_len ;
   int name_y ;
   int name_x ;
   _Bool name_free ;
   char *text ;
   int text_len ;
   int text_y ;
   int text_x ;
   int text_flen ;
   int text_ilen ;
   _Bool text_free ;
   char *help ;
   _Bool help_free ;
};
#line 620 "./dialog.h"
typedef struct __anonstruct_DIALOG_FORMITEM_63 DIALOG_FORMITEM;
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 73 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/fselect.c"
struct __anonstruct_LIST_68 {
   WINDOW *par ;
   WINDOW *win ;
   int length ;
   int offset ;
   int choice ;
   int mousex ;
   unsigned int allocd ;
   char **data ;
};
#line 73 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/fselect.c"
typedef struct __anonstruct_LIST_68 LIST;
#line 84 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/fselect.c"
struct __anonstruct_MATCH_69 {
   int length ;
   char **data ;
};
#line 84 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/fselect.c"
typedef struct __anonstruct_MATCH_69 MATCH;
#line 151 "/usr/include/curses.h"
typedef unsigned long mmask_t;
#line 38 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
typedef int callerFn(char const   *t , char **av , int *offset_add );
#line 40
enum __anonenum_eOptions_64 {
    o_unknown = 0,
    o_allow_close = 1,
    o_and_widget = 2,
    o_ascii_lines = 3,
    o_aspect = 4,
    o_auto_placement = 5,
    o_backtitle = 6,
    o_beep = 7,
    o_beep_after = 8,
    o_begin = 9,
    o_cancel_label = 10,
    o_checklist = 11,
    o_clear = 12,
    o_colors = 13,
    o_column_separator = 14,
    o_cr_wrap = 15,
    o_create_rc = 16,
    o_date_format = 17,
    o_default_button = 18,
    o_default_item = 19,
    o_defaultno = 20,
    o_exit_label = 21,
    o_extra_button = 22,
    o_extra_label = 23,
    o_fixed_font = 24,
    o_form = 25,
    o_gauge = 26,
    o_help = 27,
    o_help_button = 28,
    o_help_file = 29,
    o_help_label = 30,
    o_help_line = 31,
    o_help_status = 32,
    o_help_tags = 33,
    o_icon = 34,
    o_ignore = 35,
    o_infobox = 36,
    o_input_fd = 37,
    o_inputbox = 38,
    o_inputmenu = 39,
    o_insecure = 40,
    o_item_help = 41,
    o_keep_colors = 42,
    o_keep_tite = 43,
    o_keep_window = 44,
    o_last_key = 45,
    o_max_input = 46,
    o_menu = 47,
    o_mixedform = 48,
    o_mixedgauge = 49,
    o_msgbox = 50,
    o_no_close = 51,
    o_no_collapse = 52,
    o_no_cr_wrap = 53,
    o_no_kill = 54,
    o_no_label = 55,
    o_no_lines = 56,
    o_no_mouse = 57,
    o_no_nl_expand = 58,
    o_no_shadow = 59,
    o_nocancel = 60,
    o_nook = 61,
    o_ok_label = 62,
    o_output_fd = 63,
    o_output_separator = 64,
    o_passwordbox = 65,
    o_passwordform = 66,
    o_pause = 67,
    o_prgbox = 68,
    o_print_maxsize = 69,
    o_print_size = 70,
    o_print_version = 71,
    o_programbox = 72,
    o_progressbox = 73,
    o_quoted = 74,
    o_radiolist = 75,
    o_screen_center = 76,
    o_scrollbar = 77,
    o_separate_output = 78,
    o_separate_widget = 79,
    o_separator = 80,
    o_shadow = 81,
    o_single_quoted = 82,
    o_size_err = 83,
    o_sleep = 84,
    o_smooth = 85,
    o_stderr = 86,
    o_stdout = 87,
    o_tab_correct = 88,
    o_tab_len = 89,
    o_tailbox = 90,
    o_tailboxbg = 91,
    o_textbox = 92,
    o_time_format = 93,
    o_timeout = 94,
    o_title = 95,
    o_trim = 96,
    o_under_mouse = 97,
    o_version = 98,
    o_visit_items = 99,
    o_wmclass = 100,
    o_yes_label = 101,
    o_yesno = 102,
    o_fullbutton = 103,
    o_topleft = 104,
    o_calendar = 105,
    o_dselect = 106,
    o_editbox = 107,
    o_fselect = 108,
    o_timebox = 109,
    o_buildlist = 110,
    o_rangebox = 111,
    o_treeview = 112,
    o_no_items = 113,
    o_no_tags = 114,
    o_trace = 115
} ;
#line 40 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
typedef enum __anonenum_eOptions_64 eOptions;
#line 176 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
struct __anonstruct_Options_65 {
   char const   *name ;
   eOptions code ;
   int pass ;
   char const   *help ;
};
#line 176 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
typedef struct __anonstruct_Options_65 Options;
#line 183 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
struct __anonstruct_Mode_66 {
   eOptions code ;
   int argmin ;
   int argmax ;
   callerFn *jumper ;
};
#line 183 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
typedef struct __anonstruct_Mode_66 Mode___0;
#line 1184 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
struct __anonstruct_table_67 {
   char const   *name ;
   int code ;
};
#line 56 "./dlg_keys.h"
enum __anonenum_DLG_KEYS_ENUM_65 {
    DLGK_MIN = 512,
    DLGK_OK = 513,
    DLGK_CANCEL = 514,
    DLGK_EXTRA = 515,
    DLGK_HELP = 516,
    DLGK_ESC = 517,
    DLGK_PAGE_FIRST = 518,
    DLGK_PAGE_LAST = 519,
    DLGK_PAGE_NEXT = 520,
    DLGK_PAGE_PREV = 521,
    DLGK_ITEM_FIRST = 522,
    DLGK_ITEM_LAST = 523,
    DLGK_ITEM_NEXT = 524,
    DLGK_ITEM_PREV = 525,
    DLGK_FIELD_FIRST = 526,
    DLGK_FIELD_LAST = 527,
    DLGK_FIELD_NEXT = 528,
    DLGK_FIELD_PREV = 529,
    DLGK_FORM_FIRST = 530,
    DLGK_FORM_LAST = 531,
    DLGK_FORM_NEXT = 532,
    DLGK_FORM_PREV = 533,
    DLGK_GRID_UP = 534,
    DLGK_GRID_DOWN = 535,
    DLGK_GRID_LEFT = 536,
    DLGK_GRID_RIGHT = 537,
    DLGK_DELETE_LEFT = 538,
    DLGK_DELETE_RIGHT = 539,
    DLGK_DELETE_ALL = 540,
    DLGK_ENTER = 541,
    DLGK_BEGIN = 542,
    DLGK_FINAL = 543,
    DLGK_SELECT = 544,
    DLGK_HELPFILE = 545,
    DLGK_TRACE = 546
} ;
#line 56 "./dlg_keys.h"
typedef enum __anonenum_DLG_KEYS_ENUM_65 DLG_KEYS_ENUM;
#line 29 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dlg_keys.c"
struct _list_bindings {
   struct _list_bindings *link ;
   WINDOW *win ;
   char const   *name ;
   _Bool buttons ;
   DLG_KEYS_BINDING *binding ;
};
#line 314 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dlg_keys.c"
struct __anonstruct_CODENAME_66 {
   char const   *name ;
   int code ;
};
#line 314 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dlg_keys.c"
typedef struct __anonstruct_CODENAME_66 CODENAME;
#line 38 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/guage.c"
struct _my_obj {
   DIALOG_CALLBACK obj ;
   struct _my_obj *next ;
   WINDOW *text ;
   char *title ;
   char *prompt ;
   char prompt_buf[1024] ;
   int percent ;
   int height ;
   int width ;
   char line[2049] ;
};
#line 38 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/guage.c"
typedef struct _my_obj MY_OBJ;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 47 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/calendar.c"
struct _box;
#line 51 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/calendar.c"
struct _box {
   WINDOW *parent ;
   WINDOW *window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int (*box_draw)(struct _box * , struct tm * ) ;
};
#line 51 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/calendar.c"
typedef struct _box BOX;
#line 40 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/buildlist.c"
struct __anonstruct_MY_DATA_66 {
   WINDOW *win ;
   int box_y ;
   int box_x ;
   int top_index ;
   int cur_index ;
};
#line 40 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/buildlist.c"
typedef struct __anonstruct_MY_DATA_66 MY_DATA;
#line 48 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/buildlist.c"
struct __anonstruct_ALL_DATA_67___0 {
   DIALOG_LISTITEM *items ;
   int base_y ;
   int base_x ;
   int use_height ;
   int use_width ;
   int item_no ;
   int check_x ;
   int item_x ;
   MY_DATA list[2] ;
};
#line 48 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/buildlist.c"
typedef struct __anonstruct_ALL_DATA_67___0 ALL_DATA___1;
#line 51 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/inputstr.c"
struct _cache {
   struct _cache *next ;
   int cache_num ;
   char const   *string_at ;
   size_t s_len ;
   size_t i_len ;
   char *string ;
   int *list ;
};
#line 51 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/inputstr.c"
typedef struct _cache CACHE;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 581 "/usr/include/curses.h"
extern int beep(void) ;
#line 614
extern int flash(void) ;
#line 774
extern int ungetch(int  ) ;
#line 785
extern int waddch(WINDOW * , chtype const    ) ;
#line 824
extern int wmove(WINDOW * , int  , int  ) ;
#line 825
extern int wnoutrefresh(WINDOW * ) ;
#line 826
extern int wprintw(WINDOW * , char const   *  , ...) ;
#line 829
extern int wrefresh(WINDOW * ) ;
#line 1386
extern WINDOW *stdscr ;
#line 452 "./dialog.h"
extern DIALOG_STATE dialog_state ;
#line 550
extern DIALOG_VARS dialog_vars ;
#line 580
extern DIALOG_COLORS dlg_color_table[] ;
#line 598
int dialog_menu(char const   *title , char const   *cprompt , int height , int width ,
                int menu_height , int item_no , char **items ) ;
#line 642
int dlg_menu(char const   *title , char const   *cprompt , int height , int width ,
             int menu_height , int item_no , DIALOG_LISTITEM *items , int *current_item ,
             DIALOG_INPUTMENU *rename_menutext ) ;
#line 654
void dlg_draw_scrollbar(WINDOW *win , long first_data , long this_data , long next_data ,
                        long total_data , int left , int right , int top , int bottom ,
                        chtype attr , chtype borderattr ) ;
#line 662
char const   **dlg_ok_labels(void) ;
#line 667
int dlg_char_to_button(int ch , char const   **labels___3 ) ;
#line 669
int dlg_match_char(int ch , char const   *string ) ;
#line 670
int dlg_next_button(char const   **labels___3 , int button ) ;
#line 672
int dlg_ok_buttoncode(int button ) ;
#line 673
int dlg_prev_button(char const   **labels___3 , int button ) ;
#line 676
void dlg_button_layout(char const   **labels___3 , int *limit ) ;
#line 678
void dlg_draw_buttons(WINDOW *win , int y , int x , char const   **labels___3 , int selected ,
                      int vertical , int limit ) ;
#line 681
void dlg_align_columns(char **target , int per_row , int num_rows ) ;
#line 682
void dlg_free_columns(char **target , int per_row , int num_rows ) ;
#line 699
_Bool dlg_edit_string(char *string , int *chr_offset , int key , int fkey , _Bool force ) ;
#line 702
int dlg_count_columns(char const   *string ) ;
#line 708
void dlg_show_string(WINDOW *win , char const   *string , int chr_offset , chtype attr ,
                     int y_base , int x_base , int x_last , _Bool hidden , _Bool force ) ;
#line 711
int dlg_dummy_menutext(DIALOG_LISTITEM *items , int current , char *newtext ) ;
#line 712
int dlg_renamed_menutext(DIALOG_LISTITEM *items , int current , char *newtext ) ;
#line 726
int dlg_last_getc(void) ;
#line 730
void dlg_flush_getc(void) ;
#line 736
extern WINDOW *dlg_new_window(int  , int  , int  , int  ) ;
#line 737
extern WINDOW *dlg_sub_window(WINDOW * , int  , int  , int  , int  ) ;
#line 740
extern char *dlg_strclone(char const   * ) ;
#line 741
extern char *dlg_strempty(void) ;
#line 744
extern chtype dlg_get_attrs(WINDOW * ) ;
#line 746
extern int dlg_box_x_ordinate(int  ) ;
#line 747
extern int dlg_box_y_ordinate(int  ) ;
#line 748
extern int dlg_calc_list_width(int  , DIALOG_LISTITEM * ) ;
#line 753
extern int dlg_default_listitem(DIALOG_LISTITEM * ) ;
#line 755
int dlg_default_button(void) ;
#line 756
extern int dlg_max_input(int  ) ;
#line 759
extern void dlg_add_help_listitem(int * , char ** , DIALOG_LISTITEM * ) ;
#line 761
extern void dlg_add_result(char const   * ) ;
#line 763
extern void dlg_add_string(char * ) ;
#line 765
extern void dlg_auto_size(char const   * , char const   * , int * , int * , int  ,
                          int  ) ;
#line 768
extern void dlg_calc_listh(int * , int * , int  ) ;
#line 769
extern void dlg_clear(void) ;
#line 771
extern void dlg_ctl_size(int  , int  ) ;
#line 772
extern void dlg_del_window(WINDOW * ) ;
#line 773
extern void dlg_does_output(void) ;
#line 775
extern void dlg_draw_bottom_box2(WINDOW * , chtype  , chtype  , chtype  ) ;
#line 776
extern void dlg_draw_box(WINDOW * , int  , int  , int  , int  , chtype  , chtype  ) ;
#line 777
extern void dlg_draw_box2(WINDOW * , int  , int  , int  , int  , chtype  , chtype  ,
                          chtype  ) ;
#line 778
extern void dlg_draw_title(WINDOW *win , char const   *title ) ;
#line 780
extern void dlg_item_help(char const   * ) ;
#line 781
extern void dlg_print_autowrap(WINDOW * , char const   * , int  , int  ) ;
#line 782
extern void dlg_print_listitem(WINDOW * , char const   * , int  , _Bool  , int  ) ;
#line 783
extern void dlg_print_size(int  , int  ) ;
#line 789
extern void dlg_tab_correct_str(char * ) ;
#line 794
extern void dlg_exiterr(char const   *  , ...) ;
#line 812
extern void dlg_trace_win(WINDOW * ) ;
#line 847
extern void dlg_mouse_free_regions(void) ;
#line 848
extern void dlg_mouse_mkbigregion(int  , int  , int  , int  , int  , int  , int  ,
                                  int  ) ;
#line 849
extern void dlg_mouse_setbase(int  , int  ) ;
#line 870
extern int dlg_mouse_wgetch(WINDOW * , int * ) ;
#line 158 "./dlg_keys.h"
int dlg_result_key(int dialog_key , int fkey , int *resultp ) ;
#line 159
void dlg_register_buttons(WINDOW *win , char const   *name , char const   **buttons ) ;
#line 160
void dlg_register_window(WINDOW *win , char const   *name , DLG_KEYS_BINDING *binding___7 ) ;
#line 161
void dlg_unregister_window(WINDOW *win ) ;
#line 62 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/menubox.c"
static void print_item(ALL_DATA *data , WINDOW *win , DIALOG_LISTITEM *item , int choice ,
                       Mode selected , _Bool is_inputmenu ) 
{ 
  chtype save ;
  chtype tmp ;
  int n ;
  int climit ;
  int my_width ;
  int my_x ;
  int my_y ;
  int tmp___0 ;
  _Bool both ;
  int tmp___1 ;
  _Bool first___0 ;
  chtype bordchar ;
  char const   *show ;
  char *tmp___2 ;
  chtype tmp___3 ;

  {
  {
#line 70
  tmp = dlg_get_attrs(win);
#line 70
  save = tmp;
#line 72
  climit = (data->item_x - data->tag_x) - 2;
#line 73
  my_width = data->menu_width;
#line 74
  my_x = data->item_x;
  }
#line 75
  if (is_inputmenu) {
#line 75
    tmp___0 = choice * 3 + 1;
  } else {
#line 75
    tmp___0 = choice;
  }
#line 75
  my_y = tmp___0;
#line 76
  if (! dialog_vars.no_tags) {
#line 76
    if (! dialog_vars.no_items) {
#line 76
      tmp___1 = 1;
    } else {
#line 76
      tmp___1 = 0;
    }
  } else {
#line 76
    tmp___1 = 0;
  }
#line 76
  both = (_Bool )tmp___1;
#line 77
  first___0 = (_Bool)1;
#line 79
  if (dialog_vars.no_items) {
#line 79
    tmp___2 = item->name;
  } else {
#line 79
    tmp___2 = item->text;
  }
#line 79
  show = (char const   *)tmp___2;
  {
#line 88
  if ((unsigned int )selected == 1U) {
#line 88
    goto case_1;
  }
#line 91
  if ((unsigned int )selected == 2U) {
#line 91
    goto case_2;
  }
#line 84
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 86
  bordchar = dlg_color_table[19].atr;
#line 87
  goto switch_break;
  case_1: /* CIL Label */ 
#line 89
  bordchar = dlg_color_table[20].atr;
#line 90
  goto switch_break;
  case_2: /* CIL Label */ 
#line 92
  bordchar = dlg_color_table[2].atr;
#line 93
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 97
  if (is_inputmenu) {
#line 98
    if (win) {
#line 98
      if ((unsigned int )selected != 0U) {
#line 98
        tmp___3 = dlg_color_table[20].atr;
      } else {
#line 98
        tmp___3 = dlg_color_table[19].atr;
      }
#line 98
      win->_attrs = tmp___3;
    }
#line 99
    n = my_y - 1;
    {
#line 99
    while (1) {
      while_continue: /* CIL Label */ ;
#line 99
      if (! (n < (my_y + 3) - 1)) {
#line 99
        goto while_break;
      }
      {
#line 100
      wmove(win, n, 0);
#line 101
      wprintw(win, "%*s", my_width, " ");
#line 99
      n ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 104
    if (win) {
#line 104
      win->_attrs = dlg_color_table[17].atr;
    }
    {
#line 105
    wmove(win, my_y, 0);
#line 106
    wprintw(win, "%*s", my_width, " ");
    }
  }
#line 110
  if (both) {
    {
#line 111
    wmove(win, my_y, data->tag_x);
#line 112
    dlg_print_listitem(win, (char const   *)item->name, climit, first___0, (int )selected);
#line 113
    first___0 = (_Bool)0;
    }
  }
  {
#line 117
  wmove(win, my_y, my_x);
  }
#line 118
  if (is_inputmenu) {
    {
#line 119
    my_width --;
#line 120
    dlg_draw_box(win, my_y - 1, my_x, 3, (my_width - my_x) - data->tag_x, bordchar,
                 bordchar);
#line 123
    my_width --;
#line 124
    my_x ++;
    }
  }
  {
#line 128
  wmove(win, my_y, my_x);
#line 129
  dlg_print_listitem(win, show, my_width - my_x, first___0, (int )selected);
  }
#line 131
  if (selected) {
    {
#line 132
    dlg_item_help((char const   *)item->help);
    }
  }
#line 134
  if (win) {
#line 134
    win->_attrs = save;
  }
#line 135
  return;
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/menubox.c"
static int input_menu_edit(ALL_DATA *data , DIALOG_LISTITEM *items , int choice ,
                           char **resultp ) 
{ 
  chtype save ;
  chtype tmp ;
  char *result ;
  int offset ;
  int key ;
  int fkey ;
  int first___0 ;
  _Bool is_inputmenu ;
  int y ;
  int tmp___0 ;
  int code ;
  int max_len ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  _Bool tmp___7 ;

  {
  {
#line 146
  tmp = dlg_get_attrs(data->menu);
#line 146
  save = tmp;
#line 148
  offset = 0;
#line 149
  key = 0;
#line 149
  fkey = 0;
#line 150
  first___0 = 1;
#line 152
  is_inputmenu = (_Bool)1;
  }
#line 153
  if (is_inputmenu) {
#line 153
    tmp___0 = choice * 3 + 1;
  } else {
#line 153
    tmp___0 = choice;
  }
  {
#line 153
  y = tmp___0;
#line 154
  code = 1;
#line 155
  tmp___4 = strlen((char const   *)items->text);
  }
#line 155
  if ((int )tmp___4 + 1 > 2048) {
    {
#line 155
    tmp___2 = strlen((char const   *)items->text);
#line 155
    tmp___3 = (int )tmp___2 + 1;
    }
  } else {
#line 155
    tmp___3 = 2048;
  }
  {
#line 155
  tmp___5 = dlg_max_input(tmp___3);
#line 155
  max_len = tmp___5;
#line 157
  tmp___6 = malloc((size_t )max_len * sizeof(char ));
#line 157
  result = (char *)tmp___6;
  }
#line 158
  if ((unsigned long )result == (unsigned long )((char *)0)) {
    {
#line 158
    dlg_exiterr("cannot allocate memory in input_menu_edit");
    }
  }
  {
#line 161
  *(result + 0) = (char )'\000';
#line 162
  strcpy((char */* __restrict  */)result, (char const   */* __restrict  */)items->text);
#line 164
  print_item(data, data->menu, items, choice, (Mode )2, (_Bool)1);
  }
  {
#line 167
  while (1) {
    while_continue: /* CIL Label */ ;
#line 168
    if (! first___0) {
      {
#line 169
      key = dlg_mouse_wgetch(data->menu, & fkey);
      }
    }
    {
#line 170
    tmp___7 = dlg_edit_string(result, & offset, key, fkey, (_Bool )first___0);
    }
#line 170
    if (tmp___7) {
      {
#line 171
      dlg_show_string(data->menu, (char const   *)result, offset, dlg_color_table[11].atr,
                      y, data->item_x + 1, (data->menu_width - data->item_x) - 3,
                      (_Bool)0, (_Bool )first___0);
#line 176
      first___0 = 0;
      }
    } else
#line 177
    if (key == 27) {
#line 178
      code = 0;
#line 179
      goto while_break;
    } else
#line 177
    if (key == 9) {
#line 178
      code = 0;
#line 179
      goto while_break;
    } else {
#line 181
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 184
  print_item(data, data->menu, items, choice, (Mode )1, (_Bool)1);
  }
#line 185
  if (data->menu) {
#line 185
    (data->menu)->_attrs = save;
  }
#line 187
  *resultp = result;
#line 188
  return (code);
}
}
#line 191 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/menubox.c"
static int handle_button(int code , DIALOG_LISTITEM *items , int choice ) 
{ 
  char *help_result ;

  {
  {
#line 198
  if (code == 3) {
#line 198
    goto case_3;
  }
#line 198
  if (code == 0) {
#line 198
    goto case_3;
  }
#line 201
  if (code == 2) {
#line 201
    goto case_2;
  }
#line 196
  goto switch_break;
  case_3: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 199
  dlg_add_string((items + choice)->name);
  }
#line 200
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 202
  dlg_add_help_listitem(& code, & help_result, items + choice);
#line 203
  dlg_add_string(help_result);
  }
#line 204
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 206
  return (code);
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/menubox.c"
int dlg_renamed_menutext(DIALOG_LISTITEM *items , int current , char *newtext ) 
{ 


  {
#line 212
  if (dialog_vars.input_result) {
#line 213
    *(dialog_vars.input_result + 0) = (char )'\000';
  }
  {
#line 214
  dlg_add_result("RENAMED ");
#line 215
  dlg_add_string((items + current)->name);
#line 216
  dlg_add_result(" ");
#line 217
  dlg_add_string(newtext);
  }
#line 218
  return (3);
}
}
#line 221 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/menubox.c"
int dlg_dummy_menutext(DIALOG_LISTITEM *items , int current , char *newtext ) 
{ 


  {
#line 227
  return (-1);
}
}
#line 230 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/menubox.c"
static void print_menu(ALL_DATA *data , int choice , int scrollamt , int max_choice ,
                       _Bool is_inputmenu ) 
{ 
  int i ;
  int tmp ;
  int spare_lines ;
  int x_count ;

  {
#line 235
  i = 0;
  {
#line 235
  while (1) {
    while_continue: /* CIL Label */ ;
#line 235
    if (! (i < max_choice)) {
#line 235
      goto while_break;
    }
#line 236
    if (i == choice) {
#line 236
      tmp = 1;
    } else {
#line 236
      tmp = 0;
    }
    {
#line 236
    print_item(data, data->menu, data->items + (i + scrollamt), i, (Mode )tmp, is_inputmenu);
#line 235
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 245
  if (is_inputmenu) {
#line 247
    spare_lines = data->menu_height % 3;
#line 248
    if (data->menu) {
#line 248
      (data->menu)->_attrs = dlg_color_table[17].atr;
    }
    {
#line 249
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 249
      if (! spare_lines) {
#line 249
        goto while_break___0;
      }
      {
#line 250
      wmove(data->menu, data->menu_height - spare_lines, 0);
#line 251
      x_count = 0;
      }
      {
#line 251
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 251
        if (! (x_count < data->menu_width)) {
#line 251
          goto while_break___1;
        }
        {
#line 253
        waddch(data->menu, (chtype const   )' ');
#line 251
        x_count ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 249
      spare_lines --;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 258
  wnoutrefresh(data->menu);
#line 260
  dlg_draw_scrollbar(data->dialog, (long )scrollamt, (long )scrollamt, (long )(scrollamt + max_choice),
                     (long )data->item_no, data->box_x, data->box_x + data->menu_width,
                     data->box_y, (data->box_y + data->menu_height) + 1, dlg_color_table[37].atr,
                     dlg_color_table[18].atr);
  }
#line 271
  return;
}
}
#line 273 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/menubox.c"
static _Bool check_hotkey(DIALOG_LISTITEM *items , int choice ) 
{ 
  _Bool result ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 276
  result = (_Bool)0;
#line 278
  if (dialog_vars.no_tags) {
#line 278
    tmp = (items + choice)->text;
  } else {
#line 278
    tmp = (items + choice)->name;
  }
  {
#line 278
  tmp___0 = dlg_last_getc();
#line 278
  tmp___1 = dlg_match_char(tmp___0, (char const   *)tmp);
  }
#line 278
  if (tmp___1) {
#line 282
    result = (_Bool)1;
  }
#line 284
  return (result);
}
}
#line 304 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/menubox.c"
static DLG_KEYS_BINDING binding[23]  = 
#line 304
  {      {0, 5, 545}, 
        {1, 265, 545}, 
        {1, 363, 545}, 
        {0, '\n', 541}, 
        {0, '\r', 541}, 
        {1, 343, 541}, 
        {0, ' ', 528}, 
        {1, 261, 528}, 
        {0, 9, 528}, 
        {1, 353, 529}, 
        {1, 260, 529}, 
        {0, '+', 524}, 
        {1, 258, 524}, 
        {0, 14, 524}, 
        {0, '-', 525}, 
        {1, 259, 525}, 
        {0, 16, 525}, 
        {1, 262, 518}, 
        {1, 360, 519}, 
        {1, 347, 519}, 
        {1, 338, 520}, 
        {1, 339, 521}, 
        {-1, 0, 0}};
#line 325 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/menubox.c"
static DLG_KEYS_BINDING binding2[16]  = 
#line 325
  {      {1, 262, 542}, 
        {0, 21, 540}, 
        {0, 8, 538}, 
        {1, 263, 538}, 
        {0, 127, 539}, 
        {1, 330, 539}, 
        {1, 360, 543}, 
        {1, 260, 536}, 
        {1, 261, 537}, 
        {0, 5, 545}, 
        {1, 265, 545}, 
        {1, 363, 545}, 
        {0, '\n', 541}, 
        {0, '\r', 541}, 
        {1, 343, 541}, 
        {-1, 0, 0}};
#line 292 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/menubox.c"
int dlg_menu(char const   *title , char const   *cprompt , int height , int width ,
             int menu_height , int item_no , DIALOG_LISTITEM *items , int *current_item ,
             DIALOG_INPUTMENU *rename_menutext ) 
{ 
  int old_height ;
  int old_width ;
  ALL_DATA all ;
  int i ;
  int j ;
  int x ;
  int y ;
  int cur_x ;
  int cur_y ;
  int key ;
  int fkey ;
  int button ;
  int tmp ;
  int tmp___0 ;
  int choice ;
  int tmp___1 ;
  int result ;
  int scrollamt ;
  int max_choice ;
  int found ;
  int use_width ;
  int name_width ;
  int text_width ;
  int list_width ;
  WINDOW *dialog ;
  WINDOW *menu ;
  char *prompt ;
  char *tmp___2 ;
  char const   **buttons ;
  char const   **tmp___3 ;
  _Bool is_inputmenu ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___13 ;
  int tmp___14 ;
  int need ;
  int want ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  _Bool tmp___20 ;
  _Bool tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;

  {
#line 334
  old_height = height;
#line 335
  old_width = width;
#line 339
  key = 0;
#line 340
  if (dialog_state.visit_items) {
#line 340
    tmp___0 = -1;
  } else {
    {
#line 340
    tmp = dlg_default_button();
#line 340
    tmp___0 = tmp;
    }
  }
  {
#line 340
  button = tmp___0;
#line 341
  tmp___1 = dlg_default_listitem(items);
#line 341
  choice = tmp___1;
#line 342
  result = -2;
#line 343
  scrollamt = 0;
#line 348
  tmp___2 = dlg_strclone(cprompt);
#line 348
  prompt = tmp___2;
#line 349
  tmp___3 = dlg_ok_labels();
#line 349
  buttons = tmp___3;
  }
#line 350
  if ((unsigned long )rename_menutext != (unsigned long )((DIALOG_INPUTMENU *)0)) {
#line 350
    if ((unsigned long )rename_menutext != (unsigned long )(& dlg_dummy_menutext)) {
#line 350
      tmp___4 = 1;
    } else {
#line 350
      tmp___4 = 0;
    }
  } else {
#line 350
    tmp___4 = 0;
  }
  {
#line 350
  is_inputmenu = (_Bool )tmp___4;
#line 353
  all.items = items;
#line 354
  all.item_no = item_no;
#line 356
  dlg_does_output();
#line 357
  dlg_tab_correct_str(prompt);
  }
  retry: 
  {
#line 363
  all.menu_height = menu_height;
#line 364
  tmp___5 = dlg_calc_list_width(item_no, items);
#line 364
  use_width = tmp___5 + 10;
  }
#line 365
  if (26 > use_width) {
#line 365
    use_width = 26;
  } else {
#line 365
    use_width = use_width;
  }
#line 366
  if (all.menu_height == 0) {
    {
#line 368
    dlg_auto_size(title, (char const   *)prompt, & height, & width, 6, use_width);
#line 369
    dlg_calc_listh(& height, & all.menu_height, item_no);
    }
  } else {
    {
#line 371
    dlg_auto_size(title, (char const   *)prompt, & height, & width, 6 + all.menu_height,
                  use_width);
    }
  }
  {
#line 375
  dlg_button_layout(buttons, & width);
#line 376
  dlg_print_size(height, width);
#line 377
  dlg_ctl_size(height, width);
#line 379
  x = dlg_box_x_ordinate(width);
#line 380
  y = dlg_box_y_ordinate(height);
#line 382
  dialog = dlg_new_window(height, width, y, x);
#line 383
  all.dialog = dialog;
#line 385
  dlg_register_window(dialog, "menubox", binding);
#line 386
  dlg_register_buttons(dialog, "menubox", buttons);
#line 388
  dlg_mouse_setbase(x, y);
#line 390
  dlg_draw_box2(dialog, 0, 0, height, width, dlg_color_table[2].atr, dlg_color_table[4].atr,
                dlg_color_table[34].atr);
#line 391
  dlg_draw_bottom_box2(dialog, dlg_color_table[4].atr, dlg_color_table[34].atr, dlg_color_table[2].atr);
#line 392
  dlg_draw_title(dialog, title);
  }
#line 394
  if (dialog) {
#line 394
    dialog->_attrs = dlg_color_table[2].atr;
  }
  {
#line 395
  dlg_print_autowrap(dialog, (char const   *)prompt, height, width);
#line 397
  all.menu_width = width - 6;
  }
#line 398
  if (dialog) {
#line 398
    cur_y = (int )dialog->_cury;
  } else {
#line 398
    cur_y = -1;
  }
#line 398
  if (dialog) {
#line 398
    cur_x = (int )dialog->_curx;
  } else {
#line 398
    cur_x = -1;
  }
#line 399
  all.box_y = cur_y + 1;
#line 400
  all.box_x = (width - all.menu_width) / 2 - 1;
#line 406
  if (all.menu_height + 6 > height - cur_y) {
#line 407
    all.menu_height = (height - 6) - cur_y;
  }
#line 408
  if (all.menu_height <= 0) {
#line 409
    all.menu_height = 1;
  }
#line 412
  if (is_inputmenu) {
#line 412
    tmp___8 = item_no * 3;
  } else {
#line 412
    tmp___8 = item_no;
  }
#line 412
  if (all.menu_height < tmp___8) {
#line 412
    max_choice = all.menu_height;
  } else {
#line 412
    if (is_inputmenu) {
#line 412
      tmp___7 = item_no * 3;
    } else {
#line 412
      tmp___7 = item_no;
    }
#line 412
    max_choice = tmp___7;
  }
#line 414
  if (is_inputmenu) {
#line 415
    max_choice /= 3;
  }
  {
#line 418
  menu = dlg_sub_window(dialog, all.menu_height, all.menu_width, (y + all.box_y) + 1,
                        (x + all.box_x) + 1);
#line 421
  all.menu = menu;
#line 423
  dlg_register_window(menu, "menu", binding2);
#line 424
  dlg_register_buttons(menu, "menu", buttons);
#line 427
  dlg_draw_box(dialog, all.box_y, all.box_x, all.menu_height + 2, all.menu_width + 2,
               dlg_color_table[18].atr, dlg_color_table[37].atr);
#line 432
  name_width = 0;
#line 433
  text_width = 0;
#line 438
  i = 0;
  }
  {
#line 438
  while (1) {
    while_continue: /* CIL Label */ ;
#line 438
    if (! (i < item_no)) {
#line 438
      goto while_break;
    }
    {
#line 439
    tmp___11 = dlg_count_columns((char const   *)(items + i)->name);
    }
#line 439
    if (name_width > tmp___11) {
#line 439
      name_width = name_width;
    } else {
      {
#line 439
      tmp___10 = dlg_count_columns((char const   *)(items + i)->name);
#line 439
      name_width = tmp___10;
      }
    }
    {
#line 440
    tmp___14 = dlg_count_columns((char const   *)(items + i)->text);
    }
#line 440
    if (text_width > tmp___14) {
#line 440
      text_width = text_width;
    } else {
      {
#line 440
      tmp___13 = dlg_count_columns((char const   *)(items + i)->text);
#line 440
      text_width = tmp___13;
      }
    }
#line 438
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 449
  use_width = all.menu_width - 2;
#line 450
  if (dialog_vars.no_tags) {
#line 451
    if (use_width < text_width) {
#line 451
      list_width = use_width;
    } else {
#line 451
      list_width = text_width;
    }
  } else
#line 452
  if (dialog_vars.no_items) {
#line 453
    if (use_width < name_width) {
#line 453
      list_width = use_width;
    } else {
#line 453
      list_width = name_width;
    }
  } else {
#line 455
    if (text_width >= 0) {
#line 455
      if (name_width >= 0) {
#line 455
        if (use_width > 0) {
#line 455
          if (text_width + name_width > use_width) {
#line 459
            need = (int )(0.30 * (double )use_width);
#line 460
            if (name_width > need) {
#line 461
              want = (int )(((double )use_width * (double )name_width) / (double )(text_width + name_width));
#line 464
              if (want > need) {
#line 464
                name_width = want;
              } else {
#line 464
                name_width = need;
              }
            }
#line 466
            text_width = use_width - name_width;
          }
        }
      }
    }
#line 468
    list_width = text_width + name_width;
  }
#line 471
  if (is_inputmenu) {
#line 471
    all.tag_x = 0;
  } else {
#line 471
    all.tag_x = (use_width - list_width) / 2;
  }
#line 474
  if (dialog_vars.no_tags) {
#line 474
    tmp___16 = 0;
  } else {
#line 474
    if (dialog_vars.no_items) {
#line 474
      tmp___15 = 0;
    } else {
#line 474
      tmp___15 = 2 + name_width;
    }
#line 474
    tmp___16 = tmp___15;
  }
#line 474
  all.item_x = tmp___16 + all.tag_x;
#line 481
  if (choice - scrollamt >= max_choice) {
#line 482
    scrollamt = choice - (max_choice - 1);
#line 483
    choice = max_choice - 1;
  }
  {
#line 486
  print_menu(& all, choice, scrollamt, max_choice, is_inputmenu);
#line 489
  dlg_mouse_mkbigregion(all.box_y + 1, all.box_x, all.menu_height + 2, all.menu_width + 2,
                        511, 1, 1, 1);
#line 493
  dlg_draw_buttons(dialog, height - 2, 0, buttons, button, 0, width);
#line 495
  dlg_trace_win(dialog);
  }
  {
#line 496
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 496
    if (! (result == -2)) {
#line 496
      goto while_break___0;
    }
#line 497
    if (button < 0) {
#line 498
      if (is_inputmenu) {
#line 498
        tmp___17 = choice * 3 + 1;
      } else {
#line 498
        tmp___17 = choice;
      }
      {
#line 498
      wmove(dialog, (all.box_y + tmp___17) + 1, (all.box_x + all.tag_x) + 1);
      }
    }
    {
#line 502
    key = dlg_mouse_wgetch(dialog, & fkey);
#line 503
    tmp___18 = dlg_result_key(key, fkey, & result);
    }
#line 503
    if (tmp___18) {
#line 504
      goto while_break___0;
    }
#line 506
    found = 0;
#line 507
    if (fkey) {
#line 514
      if (key >= 1279) {
#line 515
        key -= 1279;
#line 516
        if (is_inputmenu) {
#line 516
          i = key / 3;
        } else {
#line 516
          i = key;
        }
#line 517
        if (i < max_choice) {
#line 518
          found = 1;
        } else {
          {
#line 520
          beep();
          }
#line 521
          goto while_continue___0;
        }
      } else
#line 523
      if (key >= 768) {
        {
#line 523
        tmp___19 = dlg_ok_buttoncode(key - 768);
        }
#line 523
        if (tmp___19 >= 0) {
          {
#line 525
          button = key - 768;
#line 526
          ungetch('\n');
          }
#line 527
          goto while_continue___0;
        }
      }
    } else {
#line 535
      if (button < 0) {
#line 535
        goto _L;
      } else
#line 535
      if (! dialog_state.visit_items) {
        _L: /* CIL Label */ 
#line 536
        j = (scrollamt + choice) + 1;
        {
#line 536
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 536
          if (! (j < item_no)) {
#line 536
            goto while_break___1;
          }
          {
#line 537
          tmp___20 = check_hotkey(items, j);
          }
#line 537
          if (tmp___20) {
#line 538
            found = 1;
#line 539
            i = j - scrollamt;
#line 540
            goto while_break___1;
          }
#line 536
          j ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 543
        if (! found) {
#line 544
          j = 0;
          {
#line 544
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 544
            if (! (j <= scrollamt + choice)) {
#line 544
              goto while_break___2;
            }
            {
#line 545
            tmp___21 = check_hotkey(items, j);
            }
#line 545
            if (tmp___21) {
#line 546
              found = 1;
#line 547
              i = j - scrollamt;
#line 548
              goto while_break___2;
            }
#line 544
            j ++;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
#line 552
        if (found) {
          {
#line 553
          dlg_flush_getc();
          }
        }
      } else {
        {
#line 554
        j = dlg_char_to_button(key, buttons);
        }
#line 554
        if (j >= 0) {
          {
#line 555
          button = j;
#line 556
          ungetch('\n');
          }
#line 557
          goto while_continue___0;
        }
      }
#line 564
      if (! found) {
#line 564
        if (key <= 57) {
#line 564
          if (key > 48) {
#line 564
            if (key - 49 < max_choice) {
#line 568
              found = 1;
#line 569
              i = key - 49;
            }
          }
        }
      }
    }
#line 573
    if (! found) {
#line 573
      if (fkey) {
#line 574
        found = 1;
        {
#line 576
        if (key == 518) {
#line 576
          goto case_518;
        }
#line 579
        if (key == 519) {
#line 579
          goto case_519;
        }
#line 583
        if (key == 521) {
#line 583
          goto case_521;
        }
#line 583
        if (key == 1107) {
#line 583
          goto case_521;
        }
#line 592
        if (key == 520) {
#line 592
          goto case_520;
        }
#line 592
        if (key == 1106) {
#line 592
          goto case_520;
        }
#line 595
        if (key == 525) {
#line 595
          goto case_525;
        }
#line 600
        if (key == 524) {
#line 600
          goto case_524;
        }
#line 605
        goto switch_default;
        case_518: /* CIL Label */ 
#line 577
        i = - scrollamt;
#line 578
        goto switch_break;
        case_519: /* CIL Label */ 
#line 580
        i = (item_no - 1) - scrollamt;
#line 581
        goto switch_break;
        case_521: /* CIL Label */ 
        case_1107: /* CIL Label */ 
#line 584
        if (choice) {
#line 585
          i = 0;
        } else
#line 586
        if (scrollamt != 0) {
#line 587
          if (scrollamt < max_choice) {
#line 587
            tmp___22 = scrollamt;
          } else {
#line 587
            tmp___22 = max_choice;
          }
#line 587
          i = - tmp___22;
        } else {
#line 589
          goto while_continue___0;
        }
#line 590
        goto switch_break;
        case_520: /* CIL Label */ 
        case_1106: /* CIL Label */ 
#line 593
        if (choice + max_choice < (item_no - scrollamt) - 1) {
#line 593
          i = choice + max_choice;
        } else {
#line 593
          i = (item_no - scrollamt) - 1;
        }
#line 594
        goto switch_break;
        case_525: /* CIL Label */ 
#line 596
        i = choice - 1;
#line 597
        if (choice == 0) {
#line 597
          if (scrollamt == 0) {
#line 598
            goto while_continue___0;
          }
        }
#line 599
        goto switch_break;
        case_524: /* CIL Label */ 
#line 601
        i = choice + 1;
#line 602
        if (scrollamt + choice >= item_no - 1) {
#line 603
          goto while_continue___0;
        }
#line 604
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 606
        found = 0;
#line 607
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
    }
#line 611
    if (found) {
#line 612
      if (i != choice) {
#line 613
        if (dialog) {
#line 613
          cur_y = (int )dialog->_cury;
        } else {
#line 613
          cur_y = -1;
        }
#line 613
        if (dialog) {
#line 613
          cur_x = (int )dialog->_curx;
        } else {
#line 613
          cur_x = -1;
        }
#line 614
        if (i < 0) {
#line 614
          goto _L___0;
        } else
#line 614
        if (i >= max_choice) {
          _L___0: /* CIL Label */ 
#line 615
          if (i < 0) {
#line 616
            scrollamt += i;
#line 617
            choice = 0;
          } else {
#line 619
            choice = max_choice - 1;
#line 620
            scrollamt += (i - max_choice) + 1;
          }
          {
#line 622
          print_menu(& all, choice, scrollamt, max_choice, is_inputmenu);
          }
        } else {
          {
#line 624
          choice = i;
#line 625
          print_menu(& all, choice, scrollamt, max_choice, is_inputmenu);
#line 626
          wmove(dialog, cur_y, cur_x);
#line 627
          wrefresh(dialog);
          }
        }
      }
#line 630
      goto while_continue___0;
    }
#line 633
    if (fkey) {
      {
#line 635
      if (key == 529) {
#line 635
        goto case_529;
      }
#line 640
      if (key == 528) {
#line 640
        goto case_528;
      }
#line 645
      if (key == 541) {
#line 645
        goto case_541;
      }
#line 705
      if (key == 410) {
#line 705
        goto case_410;
      }
#line 716
      goto switch_default___0;
      case_529: /* CIL Label */ 
      {
#line 636
      button = dlg_prev_button(buttons, button);
#line 637
      dlg_draw_buttons(dialog, height - 2, 0, buttons, button, 0, width);
      }
#line 639
      goto switch_break___0;
      case_528: /* CIL Label */ 
      {
#line 641
      button = dlg_next_button(buttons, button);
#line 642
      dlg_draw_buttons(dialog, height - 2, 0, buttons, button, 0, width);
      }
#line 644
      goto switch_break___0;
      case_541: /* CIL Label */ 
#line 646
      if (is_inputmenu) {
        {
#line 647
        result = dlg_ok_buttoncode(button);
        }
      } else
#line 649
      if (dialog_vars.nook) {
#line 649
        result = 0;
      } else {
        {
#line 649
        tmp___23 = dlg_ok_buttoncode(button);
#line 649
        result = tmp___23;
        }
      }
#line 655
      if (result == -1) {
#line 656
        result = -2;
      } else
#line 657
      if (is_inputmenu) {
        {
#line 659
        result = handle_button(result, items, scrollamt + choice);
        }
      } else
#line 657
      if ((unsigned long )rename_menutext == (unsigned long )(& dlg_dummy_menutext)) {
        {
#line 659
        result = handle_button(result, items, scrollamt + choice);
        }
      }
#line 673
      if (is_inputmenu) {
#line 673
        if (result == 3) {
          {
#line 676
          tmp___25 = input_menu_edit(& all, items + (scrollamt + choice), choice,
                                     & tmp___24);
          }
#line 676
          if (tmp___25) {
            {
#line 680
            result = (*rename_menutext)(items, scrollamt + choice, tmp___24);
            }
#line 681
            if (result == -2) {
#line 682
              (items + (scrollamt + choice))->text = tmp___24;
            } else {
              {
#line 684
              free((void *)tmp___24);
              }
            }
          } else {
            {
#line 687
            result = -2;
#line 688
            print_item(& all, menu, items + (scrollamt + choice), choice, (Mode )1,
                       is_inputmenu);
#line 694
            wnoutrefresh(menu);
#line 695
            free((void *)tmp___24);
            }
          }
#line 698
          if (result == -2) {
            {
#line 699
            dlg_draw_buttons(dialog, height - 2, 0, buttons, button, 0, width);
            }
          }
        }
      }
#line 703
      goto switch_break___0;
      case_410: /* CIL Label */ 
      {
#line 707
      height = old_height;
#line 708
      width = old_width;
#line 710
      dlg_clear();
#line 711
      dlg_del_window(dialog);
#line 712
      wrefresh(stdscr);
#line 713
      dlg_mouse_free_regions();
      }
#line 714
      goto retry;
      switch_default___0: /* CIL Label */ 
      {
#line 717
      flash();
      }
#line 718
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 723
  dlg_mouse_free_regions();
#line 724
  dlg_unregister_window(menu);
#line 725
  dlg_del_window(dialog);
#line 726
  free((void *)prompt);
#line 728
  *current_item = scrollamt + choice;
  }
#line 729
  return (result);
}
}
#line 735 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/menubox.c"
int dialog_menu(char const   *title , char const   *cprompt , int height , int width ,
                int menu_height , int item_no , char **items ) 
{ 
  int result ;
  int choice ;
  int i ;
  int j ;
  DIALOG_LISTITEM *listitems ;
  void *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int (*tmp___5)(DIALOG_LISTITEM *items , int current , char *newtext ) ;

  {
  {
#line 749
  tmp = calloc((size_t )item_no + 1UL, sizeof(DIALOG_LISTITEM ));
#line 749
  listitems = (DIALOG_LISTITEM *)tmp;
  }
#line 750
  if ((unsigned long )listitems == (unsigned long )((DIALOG_LISTITEM *)0)) {
    {
#line 750
    dlg_exiterr("cannot allocate memory in dialog_menu");
    }
  }
#line 752
  j = 0;
#line 752
  i = j;
  {
#line 752
  while (1) {
    while_continue: /* CIL Label */ ;
#line 752
    if (! (i < item_no)) {
#line 752
      goto while_break;
    }
#line 753
    tmp___0 = j;
#line 753
    j ++;
#line 753
    (listitems + i)->name = *(items + tmp___0);
#line 754
    if (dialog_vars.no_items) {
      {
#line 754
      tmp___1 = dlg_strempty();
#line 754
      (listitems + i)->text = tmp___1;
      }
    } else {
#line 754
      tmp___2 = j;
#line 754
      j ++;
#line 754
      (listitems + i)->text = *(items + tmp___2);
    }
#line 757
    if (dialog_vars.item_help) {
#line 757
      tmp___3 = j;
#line 757
      j ++;
#line 757
      (listitems + i)->help = *(items + tmp___3);
    } else {
      {
#line 757
      tmp___4 = dlg_strempty();
#line 757
      (listitems + i)->help = tmp___4;
      }
    }
#line 752
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 761
  dlg_align_columns(& (listitems + 0)->text, (int )sizeof(DIALOG_LISTITEM ), item_no);
  }
#line 763
  if (dialog_vars.input_menu) {
#line 763
    tmp___5 = & dlg_renamed_menutext;
  } else {
#line 763
    tmp___5 = & dlg_dummy_menutext;
  }
  {
#line 763
  result = dlg_menu(title, cprompt, height, width, menu_height, item_no, listitems,
                    & choice, tmp___5);
#line 775
  dlg_free_columns(& (listitems + 0)->text, (int )sizeof(DIALOG_LISTITEM ), item_no);
#line 776
  free((void *)listitems);
  }
#line 777
  return (result);
}
}
#line 805 "/usr/include/curses.h"
extern void wcursyncup(WINDOW * ) ;
#line 837
extern void wsyncup(WINDOW * ) ;
#line 1390
extern int COLS ;
#line 597 "./dialog.h"
int dialog_inputbox(char const   *title , char const   *cprompt , int height , int width ,
                    char const   *init , int const   password ) ;
#line 653
void dlg_draw_helpline(WINDOW *win , _Bool decorations ) ;
#line 671
int dlg_next_ok_buttonindex(int current , int extra ) ;
#line 674
int dlg_prev_ok_buttonindex(int current , int extra ) ;
#line 704
int dlg_edit_offset(char *string , int chr_offset , int x_last ) ;
#line 739
extern char *dlg_set_result(char const   * ) ;
#line 846
extern mseRegion *dlg_mouse_mkregion(int  , int  , int  , int  , int  ) ;
#line 48 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/inputbox.c"
static DLG_KEYS_BINDING binding___0[13]  = 
#line 48 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/inputbox.c"
  {      {0, 5, 545}, 
        {1, 265, 545}, 
        {1, 363, 545}, 
        {0, '\n', 541}, 
        {0, '\r', 541}, 
        {1, 343, 541}, 
        {1, 258, 528}, 
        {1, 261, 528}, 
        {0, 9, 528}, 
        {1, 353, 529}, 
        {1, 260, 529}, 
        {1, 259, 529}, 
        {-1, 0, 0}};
#line 54 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/inputbox.c"
static DLG_KEYS_BINDING binding2___0[22]  = 
#line 54
  {      {1, 262, 542}, 
        {0, 21, 540}, 
        {0, 8, 538}, 
        {1, 263, 538}, 
        {0, 127, 539}, 
        {1, 330, 539}, 
        {1, 360, 543}, 
        {1, 260, 536}, 
        {1, 261, 537}, 
        {0, 5, 545}, 
        {1, 265, 545}, 
        {1, 363, 545}, 
        {0, '\n', 541}, 
        {0, '\r', 541}, 
        {1, 343, 541}, 
        {1, 258, 528}, 
        {1, 261, 528}, 
        {0, 9, 528}, 
        {1, 353, 529}, 
        {1, 260, 529}, 
        {1, 259, 529}, 
        {-1, 0, 0}};
#line 43 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/inputbox.c"
int dialog_inputbox(char const   *title , char const   *cprompt , int height , int width ,
                    char const   *init , int const   password ) 
{ 
  int old_height ;
  int old_width ;
  int xorg ;
  int yorg ;
  int x ;
  int y ;
  int box_y ;
  int box_x ;
  int box_width ;
  int show_buttons ;
  int col_offset ;
  int chr_offset ;
  int key ;
  int fkey ;
  int code ;
  int result ;
  int state ;
  int first___0 ;
  int edited ;
  char *input ;
  WINDOW *dialog ;
  WINDOW *editor ;
  char *prompt ;
  char *tmp ;
  char const   **buttons ;
  char const   **tmp___0 ;
  int tmp___1 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  size_t tmp___21 ;
  int edit ;
  WINDOW *tmp___22 ;
  int tmp___23 ;
  _Bool tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;

  {
  {
#line 64
  old_height = height;
#line 65
  old_width = width;
#line 70
  col_offset = 0;
#line 71
  chr_offset = 0;
#line 73
  result = -2;
#line 80
  tmp = dlg_strclone(cprompt);
#line 80
  prompt = tmp;
#line 81
  tmp___0 = dlg_ok_labels();
#line 81
  buttons = tmp___0;
#line 83
  dlg_does_output();
#line 85
  dlg_tab_correct_str(prompt);
#line 88
  input = dlg_set_result(init);
#line 89
  edited = 0;
  }
  retry: 
#line 94
  show_buttons = 1;
#line 95
  if (dialog_vars.default_button >= 0) {
    {
#line 95
    tmp___1 = dlg_default_button();
#line 95
    state = tmp___1;
    }
  } else {
#line 95
    state = -1;
  }
#line 96
  first___0 = state == -1;
#line 97
  fkey = 0;
#line 97
  key = fkey;
#line 99
  if ((unsigned long )init != (unsigned long )((void *)0)) {
    {
#line 100
    tmp___18 = dlg_count_columns(init);
    }
#line 100
    if (tmp___18 + 7 > 26) {
      {
#line 100
      tmp___16 = dlg_count_columns(init);
#line 100
      tmp___17 = tmp___16 + 7;
      }
    } else {
#line 100
      tmp___17 = 26;
    }
#line 100
    if (dialog_state.use_shadow) {
#line 100
      tmp___19 = 2;
    } else {
#line 100
      tmp___19 = 0;
    }
#line 100
    if (dialog_vars.begin_set) {
#line 100
      tmp___20 = dialog_vars.begin_x;
    } else {
#line 100
      tmp___20 = 0;
    }
#line 100
    if (tmp___17 < (COLS - tmp___19) - tmp___20) {
      {
#line 100
      tmp___11 = dlg_count_columns(init);
      }
#line 100
      if (tmp___11 + 7 > 26) {
        {
#line 100
        tmp___9 = dlg_count_columns(init);
#line 100
        tmp___10 = tmp___9 + 7;
        }
      } else {
#line 100
        tmp___10 = 26;
      }
#line 100
      tmp___14 = tmp___10;
    } else {
#line 100
      if (dialog_state.use_shadow) {
#line 100
        tmp___12 = 2;
      } else {
#line 100
        tmp___12 = 0;
      }
#line 100
      if (dialog_vars.begin_set) {
#line 100
        tmp___13 = dialog_vars.begin_x;
      } else {
#line 100
        tmp___13 = 0;
      }
#line 100
      tmp___14 = (COLS - tmp___12) - tmp___13;
    }
    {
#line 100
    dlg_auto_size(title, (char const   *)prompt, & height, & width, 5, tmp___14);
#line 104
    tmp___21 = strlen(init);
#line 104
    chr_offset = (int )tmp___21;
    }
  } else {
    {
#line 106
    dlg_auto_size(title, (char const   *)prompt, & height, & width, 5, 26);
    }
  }
  {
#line 108
  dlg_button_layout(buttons, & width);
#line 109
  dlg_print_size(height, width);
#line 110
  dlg_ctl_size(height, width);
#line 112
  xorg = dlg_box_x_ordinate(width);
#line 113
  yorg = dlg_box_y_ordinate(height);
#line 115
  dialog = dlg_new_window(height, width, yorg, xorg);
#line 116
  dlg_register_window(dialog, "inputbox", binding___0);
#line 117
  dlg_register_buttons(dialog, "inputbox", buttons);
#line 119
  dlg_mouse_setbase(xorg, yorg);
#line 121
  dlg_draw_box2(dialog, 0, 0, height, width, dlg_color_table[2].atr, dlg_color_table[4].atr,
                dlg_color_table[34].atr);
#line 122
  dlg_draw_bottom_box2(dialog, dlg_color_table[4].atr, dlg_color_table[34].atr, dlg_color_table[2].atr);
#line 123
  dlg_draw_title(dialog, title);
  }
#line 125
  if (dialog) {
#line 125
    dialog->_attrs = dlg_color_table[2].atr;
  }
  {
#line 126
  dlg_draw_helpline(dialog, (_Bool)0);
#line 127
  dlg_print_autowrap(dialog, (char const   *)prompt, height, width);
#line 130
  box_width = width - 6;
  }
#line 131
  if (dialog) {
#line 131
    y = (int )dialog->_cury;
  } else {
#line 131
    y = -1;
  }
#line 131
  if (dialog) {
#line 131
    x = (int )dialog->_curx;
  } else {
#line 131
    x = -1;
  }
  {
#line 133
  box_y = y + 2;
#line 134
  box_x = (width - box_width) / 2;
#line 135
  dlg_mouse_mkregion(y + 1, box_x - 1, 3, box_width + 2, 'i');
#line 136
  dlg_draw_box(dialog, y + 1, box_x - 1, 3, box_width + 2, dlg_color_table[4].atr,
               dlg_color_table[34].atr);
#line 140
  editor = dlg_sub_window(dialog, 1, box_width, yorg + box_y, xorg + box_x);
#line 141
  dlg_register_window(editor, "inputbox2", binding2___0);
  }
#line 143
  if ((int )*input != 0) {
    {
#line 144
    dlg_show_string(editor, (char const   *)input, chr_offset, dlg_color_table[11].atr,
                    0, 0, box_width, (_Bool )password, (_Bool )first___0);
#line 146
    wsyncup(editor);
#line 147
    wcursyncup(editor);
    }
  }
  {
#line 149
  while (1) {
    while_continue: /* CIL Label */ ;
#line 149
    if (! (result == -2)) {
#line 149
      goto while_break;
    }
#line 150
    edit = 0;
#line 155
    if (show_buttons) {
      {
#line 156
      show_buttons = 0;
#line 157
      col_offset = dlg_edit_offset(input, chr_offset, box_width);
#line 158
      wmove(dialog, box_y, box_x + col_offset);
#line 159
      dlg_draw_buttons(dialog, height - 2, 0, buttons, state, 0, width);
      }
    }
#line 162
    if (! first___0) {
#line 163
      if ((int )*input != 0) {
#line 163
        if (! edited) {
          {
#line 164
          dlg_show_string(editor, (char const   *)input, chr_offset, dlg_color_table[11].atr,
                          0, 0, box_width, (_Bool )password, (_Bool )first___0);
#line 166
          wmove(editor, 0, chr_offset);
#line 167
          wsyncup(editor);
#line 168
          wcursyncup(editor);
          }
        }
      }
#line 170
      if (state == -1) {
#line 170
        tmp___22 = editor;
      } else {
#line 170
        tmp___22 = dialog;
      }
      {
#line 170
      key = dlg_mouse_wgetch(tmp___22, & fkey);
#line 171
      tmp___23 = dlg_result_key(key, fkey, & result);
      }
#line 171
      if (tmp___23) {
#line 172
        goto while_break;
      }
    }
#line 179
    if (fkey) {
#line 179
      if (key >= 768) {
        {
#line 179
        code = dlg_ok_buttoncode(key - 768);
        }
#line 179
        if (code >= 0) {
#line 182
          result = code;
#line 183
          goto while_continue;
        }
      }
    }
#line 186
    if (state == -1) {
      {
#line 187
      tmp___24 = dlg_edit_string(input, & chr_offset, key, fkey, (_Bool )first___0);
#line 187
      edit = (int )tmp___24;
      }
#line 189
      if (edit) {
        {
#line 190
        dlg_show_string(editor, (char const   *)input, chr_offset, dlg_color_table[11].atr,
                        0, 0, box_width, (_Bool )password, (_Bool )first___0);
#line 192
        wsyncup(editor);
#line 193
        wcursyncup(editor);
#line 194
        first___0 = 0;
#line 195
        edited = 1;
        }
#line 196
        goto while_continue;
      } else
#line 197
      if (first___0) {
#line 198
        first___0 = 0;
#line 199
        goto while_continue;
      }
    }
#line 204
    if (! fkey) {
      {
#line 204
      code = dlg_char_to_button(key, buttons);
      }
#line 204
      if (code >= 0) {
        {
#line 205
        dlg_del_window(dialog);
#line 206
        result = dlg_ok_buttoncode(code);
        }
#line 207
        goto while_continue;
      }
    }
#line 211
    if (fkey) {
      {
#line 213
      if (key == 873) {
#line 213
        goto case_873;
      }
#line 216
      if (key == 529) {
#line 216
        goto case_529;
      }
#line 220
      if (key == 528) {
#line 220
        goto case_528;
      }
#line 225
      if (key == 541) {
#line 225
        goto case_541;
      }
#line 225
      if (key == 32) {
#line 225
        goto case_541;
      }
#line 230
      if (key == 410) {
#line 230
        goto case_410;
      }
#line 241
      goto switch_default;
      case_873: /* CIL Label */ 
#line 214
      state = 0;
      case_529: /* CIL Label */ 
      {
#line 217
      show_buttons = 1;
#line 218
      state = dlg_prev_ok_buttonindex(state, -1);
      }
#line 219
      goto switch_break;
      case_528: /* CIL Label */ 
      {
#line 221
      show_buttons = 1;
#line 222
      state = dlg_next_ok_buttonindex(state, -1);
      }
#line 223
      goto switch_break;
      case_541: /* CIL Label */ 
      case_32: /* CIL Label */ 
      {
#line 226
      dlg_del_window(dialog);
      }
#line 227
      if (state >= 0) {
#line 227
        if (dialog_vars.nook) {
#line 227
          tmp___26 = 0;
        } else {
          {
#line 227
          tmp___25 = dlg_ok_buttoncode(state);
#line 227
          tmp___26 = tmp___25;
          }
        }
#line 227
        result = tmp___26;
      } else {
#line 227
        result = 0;
      }
#line 228
      goto switch_break;
      case_410: /* CIL Label */ 
      {
#line 232
      height = old_height;
#line 233
      width = old_width;
#line 235
      dlg_clear();
#line 236
      dlg_del_window(dialog);
#line 237
      wrefresh(stdscr);
#line 238
      dlg_mouse_free_regions();
      }
#line 239
      goto retry;
      switch_default: /* CIL Label */ 
      {
#line 242
      beep();
      }
#line 243
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
      {
#line 246
      beep();
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 250
  dlg_unregister_window(editor);
#line 251
  dlg_del_window(dialog);
#line 252
  dlg_mouse_free_regions();
#line 253
  free((void *)prompt);
  }
#line 254
  return (result);
}
}
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 267 "/usr/include/curses.h"
extern chtype acs_map[] ;
#line 718
extern int pair_content(short  , short * , short * ) ;
#line 788
extern int waddnstr(WINDOW * , char const   * , int  ) ;
#line 794
extern int wattr_on(WINDOW * , attr_t  , void * ) ;
#line 813
extern int whline(WINDOW * , chtype  , int  ) ;
#line 840
extern int wvline(WINDOW * , chtype  , int  ) ;
#line 297 "./dialog.h"
extern WINDOW *dlg_wgetparent(WINDOW * ) ;
#line 651
void dlg_draw_arrows(WINDOW *win , int top_arrow , int bottom_arrow , int x , int top ,
                     int bottom ) ;
#line 652
void dlg_draw_arrows2(WINDOW *win , int top_arrow , int bottom_arrow , int x , int top ,
                      int bottom , chtype attr , chtype borderattr ) ;
#line 743
extern chtype dlg_boxchar(chtype  ) ;
#line 751
extern int dlg_count_real_columns(char const   * ) ;
#line 784
extern void dlg_print_text(WINDOW * , char const   * , int  , chtype * ) ;
#line 797
extern chtype dlg_color_pair(int  , int  ) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/arrows.c"
static chtype merge_colors(chtype foreground , chtype background ) 
{ 
  chtype result ;
  short fg_f ;
  short bg_f ;
  short fg_b ;
  short bg_b ;
  short fg_pair ;
  short bg_pair ;
  chtype tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 47
  result = foreground;
#line 48
  if ((foreground & (((1UL << 8) - 1UL) << 8)) != (background & (((1UL << 8) - 1UL) << 8))) {
    {
#line 51
    fg_pair = (short )((int )((foreground & (((1UL << 8) - 1UL) << 8)) >> 8));
#line 52
    bg_pair = (short )((int )((background & (((1UL << 8) - 1UL) << 8)) >> 8));
#line 54
    tmp___0 = pair_content(fg_pair, & fg_f, & bg_f);
    }
#line 54
    if (tmp___0 != -1) {
      {
#line 54
      tmp___1 = pair_content(bg_pair, & fg_b, & bg_b);
      }
#line 54
      if (tmp___1 != -1) {
        {
#line 56
        result &= ~ (((1UL << 8) - 1UL) << 8);
#line 57
        tmp = dlg_color_pair((int )fg_f, (int )bg_b);
#line 57
        result |= tmp;
        }
      }
    }
  }
#line 60
  return (result);
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/arrows.c"
void dlg_draw_helpline(WINDOW *win , _Bool decorations ) 
{ 
  int cur_x ;
  int cur_y ;
  int bottom ;
  chtype attr ;
  int cols ;
  int tmp ;
  int other ;
  int tmp___0 ;
  int avail ;
  int tmp___1 ;
  int limit ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 76
  if ((unsigned long )dialog_vars.help_line != (unsigned long )((char *)0)) {
#line 76
    if ((int )*(dialog_vars.help_line + 0) != 0) {
#line 76
      if (win) {
#line 76
        tmp___3 = (int )win->_maxy + 1;
      } else {
#line 76
        tmp___3 = -1;
      }
#line 76
      bottom = tmp___3 - 1;
#line 76
      if (bottom > 0) {
        {
#line 79
        attr = 0UL;
#line 80
        tmp = dlg_count_columns((char const   *)dialog_vars.help_line);
#line 80
        cols = tmp;
        }
#line 81
        if (decorations) {
#line 81
          tmp___0 = 7;
        } else {
#line 81
          tmp___0 = 0;
        }
#line 81
        other = tmp___0;
#line 82
        if (win) {
#line 82
          tmp___1 = (int )win->_maxx + 1;
        } else {
#line 82
          tmp___1 = -1;
        }
        {
#line 82
        avail = (tmp___1 - other) - 2;
#line 83
        tmp___2 = dlg_count_real_columns((char const   *)dialog_vars.help_line);
#line 83
        limit = tmp___2 + 2;
        }
#line 85
        if (limit < avail) {
#line 86
          if (win) {
#line 86
            cur_y = (int )win->_cury;
          } else {
#line 86
            cur_y = -1;
          }
#line 86
          if (win) {
#line 86
            cur_x = (int )win->_curx;
          } else {
#line 86
            cur_x = -1;
          }
#line 87
          if (decorations) {
#line 87
            other = 4;
          } else {
#line 87
            other = 0;
          }
          {
#line 88
          wmove(win, bottom, other + (avail - limit) / 2);
#line 89
          waddch(win, (chtype const   )'[');
#line 90
          dlg_print_text(win, (char const   *)dialog_vars.help_line, cols, & attr);
#line 91
          waddch(win, (chtype const   )']');
#line 92
          wmove(win, cur_y, cur_x);
          }
        }
      }
    }
  }
#line 95
  return;
}
}
#line 97 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/arrows.c"
void dlg_draw_arrows2(WINDOW *win , int top_arrow , int bottom_arrow , int x , int top ,
                      int bottom , chtype attr , chtype borderattr ) 
{ 
  chtype save ;
  chtype tmp ;
  int cur_x ;
  int cur_y ;
  int limit_x ;
  int tmp___0 ;
  _Bool draw_top ;
  _Bool is_toplevel ;
  WINDOW *tmp___1 ;
  int have ;
  int tmp___2 ;
  int need ;
  int tmp___3 ;
  chtype tmp___4 ;
  chtype tmp___5 ;
  chtype tmp___6 ;
  chtype tmp___7 ;
  chtype tmp___8 ;
  chtype tmp___9 ;

  {
  {
#line 107
  tmp = dlg_get_attrs(win);
#line 107
  save = tmp;
  }
#line 109
  if (win) {
#line 109
    tmp___0 = (int )win->_maxx + 1;
  } else {
#line 109
    tmp___0 = -1;
  }
  {
#line 109
  limit_x = tmp___0;
#line 110
  draw_top = (_Bool)1;
#line 111
  tmp___1 = dlg_wgetparent(win);
#line 111
  is_toplevel = (_Bool )((unsigned long )tmp___1 == (unsigned long )stdscr);
  }
#line 113
  if (win) {
#line 113
    cur_y = (int )win->_cury;
  } else {
#line 113
    cur_y = -1;
  }
#line 113
  if (win) {
#line 113
    cur_x = (int )win->_curx;
  } else {
#line 113
    cur_x = -1;
  }
#line 118
  if (dialog_vars.title) {
#line 118
    if (is_toplevel) {
#line 118
      if (win) {
#line 118
        tmp___3 = (int )win->_begy;
      } else {
#line 118
        tmp___3 = -1;
      }
#line 118
      if (top - tmp___3 < 1) {
        {
#line 119
        tmp___2 = dlg_count_columns((char const   *)dialog_vars.title);
#line 119
        have = (limit_x - tmp___2) / 2;
#line 120
        need = x + 5;
        }
#line 121
        if (need > have) {
#line 122
          draw_top = (_Bool)0;
        }
      }
    }
  }
#line 125
  if (draw_top) {
    {
#line 126
    wmove(win, top, x);
    }
#line 127
    if (top_arrow) {
#line 128
      if (win) {
        {
#line 128
        tmp___4 = merge_colors(dlg_color_table[27].atr, attr);
#line 128
        win->_attrs = tmp___4;
        }
      }
      {
#line 129
      tmp___5 = dlg_boxchar(acs_map[(unsigned char )'-']);
#line 129
      waddch(win, (chtype const   )tmp___5);
#line 130
      waddnstr(win, "(-)", -1);
      }
    } else {
#line 132
      if (win) {
#line 132
        win->_attrs = attr;
      }
      {
#line 133
      tmp___6 = dlg_boxchar(acs_map[(unsigned char )'q']);
#line 133
      whline(win, tmp___6, 4);
      }
    }
  }
  {
#line 136
  dlg_mouse_mkregion(top, x - 1, 1, 6, 339);
#line 138
  wmove(win, bottom, x);
  }
#line 139
  if (bottom_arrow) {
#line 140
    if (win) {
      {
#line 140
      tmp___7 = merge_colors(dlg_color_table[28].atr, borderattr);
#line 140
      win->_attrs = tmp___7;
      }
    }
    {
#line 141
    tmp___8 = dlg_boxchar(acs_map[(unsigned char )'.']);
#line 141
    waddch(win, (chtype const   )tmp___8);
#line 142
    waddnstr(win, "(+)", -1);
    }
  } else {
#line 144
    if (win) {
#line 144
      win->_attrs = borderattr;
    }
    {
#line 145
    tmp___9 = dlg_boxchar(acs_map[(unsigned char )'q']);
#line 145
    whline(win, tmp___9, 4);
    }
  }
  {
#line 147
  dlg_mouse_mkregion(bottom, x - 1, 1, 6, 338);
#line 149
  wmove(win, cur_y, cur_x);
#line 150
  wrefresh(win);
  }
#line 152
  if (win) {
#line 152
    win->_attrs = save;
  }
#line 153
  return;
}
}
#line 155 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/arrows.c"
void dlg_draw_scrollbar(WINDOW *win , long first_data , long this_data , long next_data ,
                        long total_data , int left , int right , int top , int bottom ,
                        chtype attr , chtype borderattr ) 
{ 
  char buffer[80] ;
  int percent ;
  int len ;
  int oldy ;
  int oldx ;
  chtype save ;
  chtype tmp ;
  int top_arrow ;
  int bottom_arrow ;
  chtype tmp___0 ;
  int all_high ;
  int all_diff ;
  int bar_diff ;
  int bar_high ;
  int bar_y ;
  int bar_last ;

  {
  {
#line 173
  tmp = dlg_get_attrs(win);
#line 173
  save = tmp;
#line 174
  top_arrow = first_data != 0L;
#line 175
  bottom_arrow = next_data < total_data;
  }
#line 177
  if (win) {
#line 177
    oldy = (int )win->_cury;
  } else {
#line 177
    oldy = -1;
  }
#line 177
  if (win) {
#line 177
    oldx = (int )win->_curx;
  } else {
#line 177
    oldx = -1;
  }
  {
#line 179
  dlg_draw_helpline(win, (_Bool)1);
  }
#line 180
  if (bottom_arrow) {
#line 180
    goto _L;
  } else
#line 180
  if (top_arrow) {
#line 180
    goto _L;
  } else
#line 180
  if (dialog_state.use_scrollbar) {
    _L: /* CIL Label */ 
#line 181
    if (! total_data) {
#line 181
      percent = 100;
    } else {
#line 181
      percent = (int )((next_data * 100L) / total_data);
    }
#line 186
    if (percent < 0) {
#line 187
      percent = 0;
    } else
#line 188
    if (percent > 100) {
#line 189
      percent = 100;
    }
#line 191
    if (win) {
#line 191
      win->_attrs = dlg_color_table[16].atr;
    }
    {
#line 192
    sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"%d%%",
            percent);
#line 193
    wmove(win, bottom, right - 7);
#line 194
    waddnstr(win, (char const   *)(buffer), -1);
#line 195
    len = dlg_count_columns((char const   *)(buffer));
    }
#line 195
    if (len < 4) {
#line 196
      if (win) {
#line 196
        win->_attrs = dlg_color_table[4].atr;
      }
      {
#line 197
      tmp___0 = dlg_boxchar(acs_map[(unsigned char )'q']);
#line 197
      whline(win, tmp___0, 4 - len);
      }
    }
  }
#line 203
  if (dialog_state.use_scrollbar) {
#line 204
    all_high = (bottom - top) - 1;
#line 206
    if (0L > this_data) {
#line 206
      this_data = 0L;
    } else {
#line 206
      this_data = this_data;
    }
#line 208
    if (total_data > 0L) {
#line 208
      if (all_high > 0) {
#line 209
        all_diff = (int )(total_data + 1L);
#line 210
        bar_diff = (int )((next_data + 1L) - this_data);
#line 214
        bar_high = (int )((double )(all_high * bar_diff) / (double )all_diff);
#line 215
        if (bar_high <= 0) {
#line 216
          bar_high = 1;
        }
#line 218
        if (bar_high < all_high) {
          {
#line 219
          bar_last = (int )(0.5 + (double )(all_high * (int )next_data) / (double )total_data);
#line 221
          wmove(win, top + 1, right);
          }
#line 223
          if (win) {
#line 223
            win->_attrs = save;
          }
          {
#line 224
          wvline(win, acs_map[(unsigned char)120] | (1UL << 18), all_high);
#line 226
          bar_y = (int )((double )(all_high * (int )this_data) / (double )all_diff);
          }
#line 227
          if (bar_y >= bar_last) {
#line 227
            if (bar_y > 0) {
#line 228
              bar_y = bar_last - 1;
            }
          }
#line 229
          if (bar_last - bar_y > bar_high) {
#line 229
            if (bar_high > 1) {
#line 230
              bar_y ++;
            }
          }
#line 231
          if (bar_last < all_high) {
#line 231
            bar_last = bar_last;
          } else {
#line 231
            bar_last = all_high;
          }
          {
#line 233
          wmove(win, (top + 1) + bar_y, right);
          }
#line 235
          if (win) {
#line 235
            win->_attrs = dlg_color_table[16].atr;
          }
          {
#line 236
          wattr_on(win, 1UL << 18, (void *)0);
#line 240
          wvline(win, acs_map[(unsigned char )'0'], bar_last - bar_y);
          }
        }
      }
    }
  }
  {
#line 245
  dlg_draw_arrows2(win, top_arrow, bottom_arrow, left + 5, top, bottom, attr, borderattr);
  }
#line 254
  if (win) {
#line 254
    win->_attrs = save;
  }
  {
#line 255
  wmove(win, oldy, oldx);
  }
#line 256
  return;
}
}
#line 258 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/arrows.c"
void dlg_draw_arrows(WINDOW *win , int top_arrow , int bottom_arrow , int x , int top ,
                     int bottom ) 
{ 


  {
  {
#line 266
  dlg_draw_helpline(win, (_Bool)1);
#line 267
  dlg_draw_arrows2(win, top_arrow, bottom_arrow, x, top, bottom, dlg_color_table[37].atr,
                   dlg_color_table[18].atr);
  }
#line 275
  return;
}
}
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 603 "/usr/include/unistd.h"
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 597 "/usr/include/curses.h"
extern int curs_set(int  ) ;
#line 606
extern int doupdate(void) ;
#line 647
extern int keypad(WINDOW * , _Bool  ) ;
#line 704
extern int napms(int  ) ;
#line 732
extern int reset_shell_mode(void) ;
#line 810
extern int wgetch(WINDOW * ) ;
#line 838
extern void wtimeout(WINDOW * , int  ) ;
#line 839
extern int wtouchln(WINDOW * , int  , int  , int  ) ;
#line 1384
extern WINDOW *curscr ;
#line 596 "./dialog.h"
int dialog_helpfile(char const   *title , char const   *file , int height , int width ) ;
#line 724
int dlg_getc(WINDOW *win , int *fkey ) ;
#line 725
int dlg_getc_callbacks(int ch , int fkey , int *result ) ;
#line 727
void dlg_add_last_key(int mode ) ;
#line 728
void dlg_add_callback(DIALOG_CALLBACK *p ) ;
#line 729
void dlg_add_callback_ref(DIALOG_CALLBACK **p , void (*freeback)(struct _dlg_callback * ) ) ;
#line 731
void dlg_remove_callback(DIALOG_CALLBACK *p ) ;
#line 732
void dlg_killall_bg(int *retval ) ;
#line 738
extern _Bool dlg_need_separator(void) ;
#line 762
extern void dlg_add_separator(void) ;
#line 779
extern void dlg_exit(int  ) ;
#line 791
extern void end_dialog(void) ;
#line 813
extern void dlg_trace_chr(int  , int  ) ;
#line 157 "./dlg_keys.h"
int dlg_lookup_key(WINDOW *win , int curses_key , int *fkey ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 66 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/ui_getc.c"
void dlg_add_callback(DIALOG_CALLBACK *p ) 
{ 


  {
  {
#line 69
  p->next = dialog_state.getc_callbacks;
#line 70
  dialog_state.getc_callbacks = p;
#line 71
  wtimeout(p->win, 10);
  }
#line 72
  return;
}
}
#line 78 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/ui_getc.c"
void dlg_add_callback_ref(DIALOG_CALLBACK **p , void (*freeback)(struct _dlg_callback * ) ) 
{ 


  {
  {
#line 81
  (*p)->caller = p;
#line 82
  (*p)->freeback = freeback;
#line 83
  dlg_add_callback(*p);
  }
#line 84
  return;
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/ui_getc.c"
void dlg_remove_callback(DIALOG_CALLBACK *p ) 
{ 
  DIALOG_CALLBACK *q ;

  {
#line 91
  if ((unsigned long )p->input != (unsigned long )((FILE *)0)) {
    {
#line 92
    fclose(p->input);
    }
#line 93
    if ((unsigned long )p->input == (unsigned long )dialog_state.pipe_input) {
#line 94
      dialog_state.pipe_input = (FILE *)0;
    }
#line 95
    p->input = (FILE *)0;
  }
#line 98
  if (! p->keep_win) {
    {
#line 99
    dlg_del_window(p->win);
    }
  }
#line 100
  q = dialog_state.getc_callbacks;
#line 100
  if ((unsigned long )q == (unsigned long )p) {
#line 101
    dialog_state.getc_callbacks = p->next;
  } else {
    {
#line 103
    while (1) {
      while_continue: /* CIL Label */ ;
#line 103
      if (! ((unsigned long )q != (unsigned long )((DIALOG_CALLBACK *)0))) {
#line 103
        goto while_break;
      }
#line 104
      if ((unsigned long )q->next == (unsigned long )p) {
#line 105
        q->next = p->next;
#line 106
        goto while_break;
      }
#line 108
      q = q->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 113
  if ((unsigned long )p->freeback != (unsigned long )((void (*)(struct _dlg_callback * ))0)) {
    {
#line 114
    (*(p->freeback))(p);
    }
  }
#line 115
  if ((unsigned long )p->caller != (unsigned long )((struct _dlg_callback **)0)) {
#line 116
    *(p->caller) = (struct _dlg_callback *)0;
  }
  {
#line 118
  free((void *)p);
  }
#line 119
  return;
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/ui_getc.c"
static _Bool handle_inputs(WINDOW *win ) 
{ 
  _Bool result ;
  DIALOG_CALLBACK *p ;
  DIALOG_CALLBACK *q ;
  int cur_y ;
  int cur_x ;
  int state ;
  _Bool tmp ;

  {
#line 128
  result = (_Bool)0;
#line 132
  state = -1;
#line 134
  if (win) {
#line 134
    cur_y = (int )win->_cury;
  } else {
#line 134
    cur_y = -1;
  }
#line 134
  if (win) {
#line 134
    cur_x = (int )win->_curx;
  } else {
#line 134
    cur_x = -1;
  }
#line 135
  p = dialog_state.getc_callbacks;
#line 135
  q = (DIALOG_CALLBACK *)0;
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 135
    if (! ((unsigned long )p != (unsigned long )((DIALOG_CALLBACK *)0))) {
#line 135
      goto while_break;
    }
#line 136
    q = p->next;
#line 137
    if ((unsigned long )p->handle_input != (unsigned long )((_Bool (*)(struct _dlg_callback *p ))0)) {
#line 137
      if (p->input_ready) {
#line 138
        p->input_ready = (_Bool)0;
#line 139
        if (state == -1) {
          {
#line 140
          state = curs_set(0);
          }
        }
        {
#line 142
        tmp = (*(p->handle_input))(p);
        }
#line 142
        if (tmp) {
#line 143
          result = (_Bool)1;
        }
      }
    }
#line 135
    p = q;
  }
  while_break: /* CIL Label */ ;
  }
#line 147
  if (result) {
    {
#line 148
    wmove(win, cur_y, cur_x);
#line 149
    wrefresh(win);
#line 150
    curs_set(state);
    }
  }
#line 152
  return (result);
}
}
#line 155 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/ui_getc.c"
static _Bool may_handle_inputs(void) 
{ 
  _Bool result ;
  DIALOG_CALLBACK *p ;

  {
#line 158
  result = (_Bool)0;
#line 162
  p = dialog_state.getc_callbacks;
  {
#line 162
  while (1) {
    while_continue: /* CIL Label */ ;
#line 162
    if (! ((unsigned long )p != (unsigned long )((DIALOG_CALLBACK *)0))) {
#line 162
      goto while_break;
    }
#line 163
    if ((unsigned long )p->input != (unsigned long )((FILE *)0)) {
#line 164
      result = (_Bool)1;
#line 165
      goto while_break;
    }
#line 162
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 169
  return (result);
}
}
#line 177 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/ui_getc.c"
static int check_inputs(void) 
{ 
  DIALOG_CALLBACK *p ;
  fd_set read_fds ;
  struct timeval test ;
  int last_fd ;
  int fd ;
  int found ;
  int result ;
  int __d0 ;
  int __d1 ;

  {
#line 183
  last_fd = -1;
#line 186
  result = -1;
#line 188
  p = dialog_state.getc_callbacks;
#line 188
  if ((unsigned long )p != (unsigned long )((DIALOG_CALLBACK *)0)) {
    {
#line 189
    while (1) {
      while_continue: /* CIL Label */ ;
#line 189
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& read_fds.fds_bits[0]): "memory");
#line 189
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 191
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 191
      if (! ((unsigned long )p != (unsigned long )((DIALOG_CALLBACK *)0))) {
#line 191
        goto while_break___0;
      }
#line 192
      p->input_ready = (_Bool)0;
#line 193
      if ((unsigned long )p->input != (unsigned long )((FILE *)0)) {
        {
#line 193
        fd = fileno(p->input);
        }
#line 193
        if (fd >= 0) {
#line 194
          read_fds.fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd % (8 * (int )sizeof(__fd_mask ));
#line 195
          if (last_fd < fd) {
#line 196
            last_fd = fd;
          }
        }
      }
#line 198
      p = p->next;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 201
    test.tv_sec = (__time_t )0;
#line 202
    test.tv_usec = (__suseconds_t )10000;
#line 203
    found = select(last_fd + 1, (fd_set */* __restrict  */)(& read_fds), (fd_set */* __restrict  */)((fd_set *)0),
                   (fd_set */* __restrict  */)((fd_set *)0), (struct timeval */* __restrict  */)(& test));
    }
#line 208
    if (found > 0) {
#line 209
      p = dialog_state.getc_callbacks;
      {
#line 209
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 209
        if (! ((unsigned long )p != (unsigned long )((DIALOG_CALLBACK *)0))) {
#line 209
          goto while_break___1;
        }
#line 210
        if ((unsigned long )p->input != (unsigned long )((FILE *)0)) {
          {
#line 210
          fd = fileno(p->input);
          }
#line 210
          if (fd >= 0) {
#line 210
            if ((read_fds.fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] & (1L << fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 213
              p->input_ready = (_Bool)1;
#line 214
              result = fd;
            }
          }
        }
#line 209
        p = p->next;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
#line 220
  return (result);
}
}
#line 223 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/ui_getc.c"
int dlg_getc_callbacks(int ch , int fkey , int *result ) 
{ 
  int code ;
  DIALOG_CALLBACK *p ;
  DIALOG_CALLBACK *q ;
  _Bool tmp ;
  int tmp___0 ;

  {
#line 226
  code = 0;
#line 229
  p = dialog_state.getc_callbacks;
#line 229
  if ((unsigned long )p != (unsigned long )((DIALOG_CALLBACK *)0)) {
    {
#line 230
    tmp___0 = check_inputs();
    }
#line 230
    if (tmp___0 >= 0) {
      {
#line 231
      while (1) {
        while_continue: /* CIL Label */ ;
#line 232
        q = p->next;
#line 233
        if (p->input_ready) {
          {
#line 234
          tmp = (*(p->handle_getc))(p, ch, fkey, result);
          }
#line 234
          if (! tmp) {
            {
#line 235
            dlg_remove_callback(p);
            }
          }
        }
#line 231
        p = q;
#line 231
        if (! ((unsigned long )p != (unsigned long )((DIALOG_CALLBACK *)0))) {
#line 231
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 240
    code = (unsigned long )dialog_state.getc_callbacks != (unsigned long )((DIALOG_CALLBACK *)0);
  }
#line 242
  return (code);
}
}
#line 245 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/ui_getc.c"
static void dlg_raise_window(WINDOW *win ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 248
  if (win) {
#line 248
    tmp = (int )win->_maxy + 1;
  } else {
#line 248
    tmp = -1;
  }
  {
#line 248
  wtouchln(win, 0, tmp, 1);
  }
#line 249
  if (win) {
#line 249
    tmp___0 = (int )win->_curx;
  } else {
#line 249
    tmp___0 = -1;
  }
#line 249
  if (win) {
#line 249
    tmp___1 = (int )win->_cury;
  } else {
#line 249
    tmp___1 = -1;
  }
  {
#line 249
  wmove(win, tmp___1, tmp___0);
#line 250
  wnoutrefresh(win);
#line 251
  doupdate();
  }
#line 252
  return;
}
}
#line 258 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/ui_getc.c"
static int last_getc  =    -1;
#line 266 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/ui_getc.c"
int dlg_last_getc(void) 
{ 


  {
#line 273
  return (last_getc);
}
}
#line 276 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/ui_getc.c"
void dlg_flush_getc(void) 
{ 


  {
#line 279
  last_getc = -1;
#line 284
  return;
}
}
#line 294 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/ui_getc.c"
void dlg_add_last_key(int mode ) 
{ 
  _Bool tmp ;
  char temp[80] ;

  {
#line 297
  if (dialog_vars.last_key) {
#line 298
    if (mode >= 0) {
#line 299
      if (mode > 0) {
        {
#line 300
        dlg_add_last_key(-1);
        }
      } else {
        {
#line 302
        tmp = dlg_need_separator();
        }
#line 302
        if (tmp) {
          {
#line 303
          dlg_add_separator();
          }
        }
        {
#line 304
        dlg_add_last_key(-2);
        }
      }
    } else {
      {
#line 308
      sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)"%d",
              last_getc);
#line 309
      dlg_add_string(temp);
      }
#line 310
      if (mode == -1) {
        {
#line 311
        dlg_add_separator();
        }
      }
    }
  }
#line 314
  return;
}
}
#line 320 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/ui_getc.c"
static _Bool valid_file(FILE *fp ) 
{ 
  _Bool code ;
  int fd ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 323
  code = (_Bool)0;
#line 324
  tmp = fileno(fp);
#line 324
  fd = tmp;
  }
#line 326
  if (fd >= 0) {
    {
#line 327
    tmp___0 = fcntl(fd, 3, 0);
    }
#line 327
    if (tmp___0 >= 0) {
#line 328
      code = (_Bool)1;
    }
  }
#line 331
  return (code);
}
}
#line 334 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/ui_getc.c"
static int really_getch(WINDOW *win , int *fkey ) 
{ 
  int ch ;
  int tmp ;

  {
  {
#line 381
  ch = wgetch(win);
#line 382
  last_getc = ch;
  }
#line 383
  if (ch > 257) {
#line 383
    if (ch < 511) {
#line 383
      tmp = 1;
    } else {
#line 383
      tmp = 0;
    }
  } else {
#line 383
    tmp = 0;
  }
#line 383
  *fkey = tmp;
#line 385
  return (ch);
}
}
#line 388 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/ui_getc.c"
static DIALOG_CALLBACK *next_callback(DIALOG_CALLBACK *p ) 
{ 


  {
#line 391
  p = dialog_state.getc_redirect;
#line 391
  if ((unsigned long )p != (unsigned long )((DIALOG_CALLBACK *)0)) {
#line 392
    p = p->next;
  } else {
#line 394
    p = dialog_state.getc_callbacks;
  }
#line 396
  return (p);
}
}
#line 399 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/ui_getc.c"
static DIALOG_CALLBACK *prev_callback(DIALOG_CALLBACK *p ) 
{ 
  DIALOG_CALLBACK *q ;

  {
#line 404
  p = dialog_state.getc_redirect;
#line 404
  if ((unsigned long )p != (unsigned long )((DIALOG_CALLBACK *)0)) {
#line 405
    if ((unsigned long )p == (unsigned long )dialog_state.getc_callbacks) {
#line 406
      p = dialog_state.getc_callbacks;
      {
#line 406
      while (1) {
        while_continue: /* CIL Label */ ;
#line 406
        if (! ((unsigned long )p->next != (unsigned long )((struct _dlg_callback *)0))) {
#line 406
          goto while_break;
        }
#line 406
        p = p->next;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 408
      q = dialog_state.getc_callbacks;
      {
#line 408
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 408
        if (! ((unsigned long )q->next != (unsigned long )p)) {
#line 408
          goto while_break___0;
        }
#line 408
        q = q->next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 409
      p = q;
    }
  } else {
#line 412
    p = dialog_state.getc_callbacks;
  }
#line 414
  return (p);
}
}
#line 426 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/ui_getc.c"
int dlg_getc(WINDOW *win , int *fkey ) 
{ 
  WINDOW *save_win ;
  int ch ;
  int before_chr ;
  int before_fkey ;
  int result ;
  _Bool done ;
  _Bool literal ;
  DIALOG_CALLBACK *p ;
  int interval ;
  time_t expired ;
  time_t tmp ;
  time_t current ;
  _Bool tmp___0 ;
  _Bool handle_others ;
  int tmp___1 ;
  _Bool tmp___2 ;
  int tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;
  int yold ;
  int xold ;
  DIALOG_CALLBACK *tmp___6 ;
  DIALOG_CALLBACK *tmp___7 ;
  int tmp___8 ;
  _Bool tmp___9 ;

  {
  {
#line 429
  save_win = win;
#line 430
  ch = -1;
#line 434
  done = (_Bool)0;
#line 435
  literal = (_Bool)0;
#line 436
  p = (DIALOG_CALLBACK *)0;
#line 437
  interval = dialog_vars.timeout_secs * 1000;
#line 438
  tmp = time((time_t *)0);
#line 438
  expired = tmp + (time_t )dialog_vars.timeout_secs;
#line 441
  tmp___0 = may_handle_inputs();
  }
#line 441
  if (tmp___0) {
    {
#line 442
    wtimeout(win, 10);
    }
  } else
#line 443
  if (interval > 0) {
    {
#line 444
    wtimeout(win, interval);
    }
  }
  {
#line 446
  while (1) {
    while_continue: /* CIL Label */ ;
#line 446
    if (! (! done)) {
#line 446
      goto while_break;
    }
    {
#line 447
    handle_others = (_Bool)0;
#line 452
    ch = really_getch(win, fkey);
    }
#line 453
    if (literal) {
#line 454
      done = (_Bool)1;
#line 455
      goto while_continue;
    }
    {
#line 458
    before_chr = ch;
#line 459
    before_fkey = *fkey;
#line 461
    ch = dlg_lookup_key(win, ch, fkey);
#line 462
    dlg_trace_chr(ch, *fkey);
#line 464
    current = time((time_t *)0);
    }
#line 470
    if (! *fkey) {
#line 470
      goto _L___1;
    } else
#line 470
    if (*fkey != before_fkey) {
      _L___1: /* CIL Label */ 
      {
#line 472
      if (ch == 22) {
#line 472
        goto case_22;
      }
#line 476
      if (ch == 12) {
#line 476
        goto case_12;
      }
#line 480
      if (ch == -1) {
#line 480
        goto case_neg_1;
      }
#line 498
      if (ch == 545) {
#line 498
        goto case_545;
      }
#line 513
      if (ch == 9) {
#line 513
        goto case_9;
      }
#line 513
      if (ch == 528) {
#line 513
        goto case_9;
      }
#line 513
      if (ch == 353) {
#line 513
        goto case_9;
      }
#line 513
      if (ch == 529) {
#line 513
        goto case_9;
      }
#line 547
      if (ch == 20) {
#line 547
        goto case_20;
      }
#line 534
      goto switch_default;
      case_22: /* CIL Label */ 
      {
#line 473
      literal = (_Bool)1;
#line 474
      keypad(win, (_Bool)0);
      }
#line 475
      goto while_continue;
      case_12: /* CIL Label */ 
#line 477
      if (win) {
#line 477
        tmp___1 = (int )win->_maxy + 1;
      } else {
#line 477
        tmp___1 = -1;
      }
      {
#line 477
      wtouchln(win, 0, tmp___1, 1);
#line 478
      wrefresh(curscr);
      }
#line 479
      goto switch_break;
      case_neg_1: /* CIL Label */ 
#line 481
      if (interval > 0) {
#line 481
        if (current >= expired) {
          {
#line 483
          dlg_exiterr("timeout");
          }
        }
      }
      {
#line 485
      tmp___4 = valid_file(stdin);
      }
#line 485
      if (tmp___4) {
        {
#line 485
        tmp___5 = valid_file(dialog_state.screen_output);
        }
#line 485
        if (tmp___5) {
          {
#line 489
          tmp___3 = check_inputs();
          }
#line 489
          if (tmp___3) {
            {
#line 490
            tmp___2 = handle_inputs(win);
            }
#line 490
            if (tmp___2) {
              {
#line 491
              dlg_raise_window(win);
              }
            } else {
#line 493
              done = (_Bool)1;
            }
          } else {
#line 495
            done = (_Bool )(interval <= 0);
          }
        } else {
#line 487
          ch = 27;
#line 488
          done = (_Bool)1;
        }
      } else {
#line 487
        ch = 27;
#line 488
        done = (_Bool)1;
      }
#line 497
      goto switch_break;
      case_545: /* CIL Label */ 
#line 499
      if (dialog_vars.help_file) {
#line 501
        if (win) {
#line 501
          yold = (int )win->_cury;
        } else {
#line 501
          yold = -1;
        }
#line 501
        if (win) {
#line 501
          xold = (int )win->_curx;
        } else {
#line 501
          xold = -1;
        }
        {
#line 502
        dialog_helpfile("HELP", (char const   *)dialog_vars.help_file, 0, 0);
#line 503
        dlg_raise_window(win);
#line 504
        wmove(win, yold, xold);
        }
      }
#line 506
      goto while_continue;
      case_9: /* CIL Label */ 
      case_528: /* CIL Label */ 
      case_353: /* CIL Label */ 
      case_529: /* CIL Label */ 
#line 519
      if ((unsigned long )dialog_state.getc_callbacks != (unsigned long )((DIALOG_CALLBACK *)0)) {
#line 519
        if (9 == before_chr) {
#line 519
          if (! before_fkey) {
#line 519
            goto _L;
          } else {
#line 519
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 519
        if (353 == before_chr) {
#line 519
          if (before_fkey) {
            _L: /* CIL Label */ 
#line 522
            if (9 == before_chr) {
#line 522
              if (! before_fkey) {
                {
#line 522
                tmp___6 = next_callback(p);
#line 522
                p = tmp___6;
                }
              } else {
                {
#line 522
                tmp___7 = prev_callback(p);
#line 522
                p = tmp___7;
                }
              }
            } else {
              {
#line 522
              tmp___7 = prev_callback(p);
#line 522
              p = tmp___7;
              }
            }
#line 525
            dialog_state.getc_redirect = p;
#line 525
            if ((unsigned long )dialog_state.getc_redirect != (unsigned long )((DIALOG_CALLBACK *)0)) {
#line 526
              win = p->win;
            } else {
#line 528
              win = save_win;
            }
            {
#line 530
            dlg_raise_window(win);
            }
#line 531
            goto switch_break;
          }
        }
      }
      switch_default: /* CIL Label */ 
#line 544
      handle_others = (_Bool)1;
#line 545
      goto switch_break;
      case_20: /* CIL Label */ 
      {
#line 548
      dlg_trace_win(win);
      }
#line 549
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 553
      handle_others = (_Bool)1;
    }
#line 556
    if (handle_others) {
#line 557
      p = dialog_state.getc_redirect;
#line 557
      if ((unsigned long )p != (unsigned long )((DIALOG_CALLBACK *)0)) {
        {
#line 558
        tmp___9 = (*(p->handle_getc))(p, ch, *fkey, & result);
        }
#line 558
        if (! tmp___9) {
#line 559
          if ((unsigned long )p->win == (unsigned long )save_win) {
#line 559
            if (! p->keep_win) {
#line 559
              tmp___8 = 1;
            } else {
#line 559
              tmp___8 = 0;
            }
          } else {
#line 559
            tmp___8 = 0;
          }
          {
#line 559
          done = (_Bool )tmp___8;
#line 560
          dlg_remove_callback(p);
#line 561
          dialog_state.getc_redirect = (DIALOG_CALLBACK *)0;
#line 562
          win = save_win;
          }
        }
      } else {
#line 565
        done = (_Bool)1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 569
  if (literal) {
    {
#line 570
    keypad(win, (_Bool)1);
    }
  }
#line 571
  return (ch);
}
}
#line 574 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/ui_getc.c"
static void finish_bg(int sig ) 
{ 


  {
  {
#line 577
  end_dialog();
#line 578
  dlg_exit(-1);
  }
#line 579
  return;
}
}
#line 586 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/ui_getc.c"
void dlg_killall_bg(int *retval ) 
{ 
  DIALOG_CALLBACK *cb ;
  int pid ;
  int wstatus ;
  int tmp ;
  __pid_t tmp___0 ;
  union __anonunion_66 __constr_expr_0 ;
  int fkey ;

  {
#line 597
  cb = dialog_state.getc_callbacks;
#line 597
  if ((unsigned long )cb != (unsigned long )((DIALOG_CALLBACK *)0)) {
    {
#line 598
    while (1) {
      while_continue: /* CIL Label */ ;
#line 598
      if (! ((unsigned long )cb != (unsigned long )((DIALOG_CALLBACK *)0))) {
#line 598
        goto while_break;
      }
#line 599
      if (cb->keep_bg) {
#line 600
        cb = cb->next;
      } else {
        {
#line 602
        dlg_remove_callback(cb);
#line 603
        cb = dialog_state.getc_callbacks;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 606
    if ((unsigned long )dialog_state.getc_callbacks != (unsigned long )((DIALOG_CALLBACK *)0)) {
      {
#line 608
      wrefresh(stdscr);
#line 609
      fflush(stdout);
#line 610
      fflush(stderr);
#line 611
      reset_shell_mode();
#line 612
      pid = fork();
      }
#line 612
      if (pid != 0) {
#line 613
        if (pid > 0) {
#line 613
          tmp = 0;
        } else {
#line 613
          tmp = -1;
        }
        {
#line 613
        _exit(tmp);
        }
      } else
#line 614
      if (pid == 0) {
        {
#line 615
        pid = fork();
        }
#line 615
        if (pid != 0) {
#line 622
          if (pid > 0) {
            {
#line 623
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d\n",
                    pid);
#line 624
            fflush(stderr);
            }
          }
          {
#line 628
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 628
            tmp___0 = waitpid(pid, & wstatus, 0);
            }
#line 628
            if (! (-1 == tmp___0)) {
#line 628
              goto while_break___0;
            }
#line 637
            goto while_break___0;
          }
          while_break___0: /* CIL Label */ ;
          }
          {
#line 643
          __constr_expr_0.__in = wstatus;
#line 643
          _exit((__constr_expr_0.__i & 65280) >> 8);
          }
        } else
#line 644
        if (pid == 0) {
#line 645
          if (! dialog_vars.cant_kill) {
            {
#line 646
            signal(1, & finish_bg);
            }
          }
          {
#line 647
          signal(2, & finish_bg);
#line 648
          signal(3, & finish_bg);
#line 649
          signal(11, & finish_bg);
          }
          {
#line 650
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 650
            if (! ((unsigned long )dialog_state.getc_callbacks != (unsigned long )((DIALOG_CALLBACK *)0))) {
#line 650
              goto while_break___1;
            }
            {
#line 651
            fkey = 0;
#line 652
            dlg_getc_callbacks(-1, fkey, retval);
#line 653
            napms(1000);
            }
          }
          while_break___1: /* CIL Label */ ;
          }
        }
      }
    }
  }
#line 659
  return;
}
}
#line 607 "./dialog.h"
extern int dialog_textbox(char const   * , char const   * , int  , int  ) ;
#line 786
extern void dlg_restore_vars(DIALOG_VARS * ) ;
#line 787
extern void dlg_save_vars(DIALOG_VARS * ) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/help.c"
int dialog_helpfile(char const   *title , char const   *file , int height , int width ) 
{ 
  int result ;
  DIALOG_VARS save ;

  {
#line 35
  result = -1;
#line 38
  if (! dialog_vars.in_helpfile) {
#line 38
    if ((unsigned long )file != (unsigned long )((char const   *)0)) {
#line 38
      if ((int const   )*file != 0) {
        {
#line 39
        dlg_save_vars(& save);
#line 41
        dialog_vars.no_label = (char *)((void *)0);
#line 42
        dialog_vars.ok_label = (char *)((void *)0);
#line 43
        dialog_vars.help_button = (_Bool)0;
#line 44
        dialog_vars.extra_button = (_Bool)0;
#line 45
        dialog_vars.nook = (_Bool)0;
#line 47
        dialog_vars.in_helpfile = (_Bool)1;
#line 49
        result = dialog_textbox(title, file, height, width);
#line 51
        dlg_restore_vars(& save);
        }
      }
    }
  }
#line 53
  return (result);
}
}
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 289
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strspn)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 660 "./dialog.h"
char const   **dlg_exit_label(void) ;
#line 661
char const   **dlg_ok_label(void) ;
#line 663
char const   **dlg_yes_labels(void) ;
#line 664
int dlg_button_count(char const   **labels___3 ) ;
#line 665
int dlg_button_to_char(char const   *label ) ;
#line 666
int dlg_button_x_step(char const   **labels___3 , int limit , int *gap , int *margin ,
                      int *step ) ;
#line 668
int dlg_exit_buttoncode(int button ) ;
#line 675
int dlg_yes_buttoncode(int button ) ;
#line 677
void dlg_button_sizes(char const   **labels___3 , int vertical , int *longest , int *length ) ;
#line 701
int const   *dlg_index_wchars(char const   *string ) ;
#line 703
int dlg_count_wchars(char const   *string ) ;
#line 754
int dlg_defaultno_button(void) ;
#line 811
extern void dlg_trace_msg(char const   *fmt  , ...) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/buttons.c"
static void center_label(char *buffer , int longest , char const   *label ) 
{ 
  int len ;
  int tmp ;
  int left ;
  int right ;
  size_t tmp___0 ;

  {
  {
#line 36
  tmp = dlg_count_columns(label);
#line 36
  len = tmp;
#line 37
  left = 0;
#line 37
  right = 0;
#line 39
  *buffer = (char)0;
  }
#line 40
  if (len < longest) {
#line 41
    left = (longest - len) / 2;
#line 42
    right = (longest - len) - left;
#line 43
    if (left > 0) {
      {
#line 44
      sprintf((char */* __restrict  */)buffer, (char const   */* __restrict  */)"%*s",
              left, " ");
      }
    }
  }
  {
#line 46
  strcat((char */* __restrict  */)buffer, (char const   */* __restrict  */)label);
  }
#line 47
  if (right > 0) {
    {
#line 48
    tmp___0 = strlen((char const   *)buffer);
#line 48
    sprintf((char */* __restrict  */)(buffer + tmp___0), (char const   */* __restrict  */)"%*s",
            right, " ");
    }
  }
#line 49
  return;
}
}
#line 55 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/buttons.c"
static int string_to_char(char const   **stringp ) 
{ 
  int result ;
  char const   *string ;

  {
#line 82
  string = *stringp;
#line 83
  result = (int )((unsigned char )*string);
#line 84
  (*stringp) ++;
#line 86
  return (result);
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/buttons.c"
static size_t count_labels(char const   **labels___3 ) 
{ 
  size_t result ;
  char const   **tmp ;

  {
#line 92
  result = (size_t )0;
#line 93
  if ((unsigned long )labels___3 != (unsigned long )((char const   **)0)) {
    {
#line 94
    while (1) {
      while_continue: /* CIL Label */ ;
#line 94
      tmp = labels___3;
#line 94
      labels___3 ++;
#line 94
      if (! ((unsigned long )*tmp != (unsigned long )((char const   *)0))) {
#line 94
        goto while_break;
      }
#line 95
      result ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 98
  return (result);
}
}
#line 104 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/buttons.c"
static int was_hotkey(int this_key , int *used_keys , size_t next ) 
{ 
  int result ;
  size_t n ;

  {
#line 107
  result = 0;
#line 109
  if (next != 0UL) {
#line 111
    n = (size_t )0;
    {
#line 111
    while (1) {
      while_continue: /* CIL Label */ ;
#line 111
      if (! (n < next)) {
#line 111
        goto while_break;
      }
#line 112
      if (*(used_keys + n) == this_key) {
#line 113
        result = 1;
#line 114
        goto while_break;
      }
#line 111
      n ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 118
  return (result);
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/buttons.c"
static int *get_hotkeys(char const   **labels___3 ) 
{ 
  int *result ;
  size_t count ;
  size_t tmp ;
  size_t n ;
  char const   *label ;
  int const   *indx ;
  int const   *tmp___0 ;
  int limit ;
  int tmp___1 ;
  int i ;
  int first___0 ;
  int check ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;

  {
  {
#line 132
  result = (int *)0;
#line 133
  tmp = count_labels(labels___3);
#line 133
  count = tmp;
#line 136
  tmp___5 = calloc(count + 1UL, sizeof(int ));
#line 136
  result = (int *)tmp___5;
  }
#line 136
  if ((unsigned long )result != (unsigned long )((int *)0)) {
#line 137
    n = (size_t )0;
    {
#line 137
    while (1) {
      while_continue: /* CIL Label */ ;
#line 137
      if (! (n < count)) {
#line 137
        goto while_break;
      }
      {
#line 138
      label = *(labels___3 + n);
#line 139
      tmp___0 = dlg_index_wchars(label);
#line 139
      indx = tmp___0;
#line 140
      tmp___1 = dlg_count_wchars(label);
#line 140
      limit = tmp___1;
#line 143
      i = 0;
      }
      {
#line 143
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 143
        if (! (i < limit)) {
#line 143
          goto while_break___0;
        }
        {
#line 144
        first___0 = (int )*(indx + i);
#line 145
        check = (int )((unsigned char )*(label + first___0));
#line 153
        tmp___2 = __ctype_b_loc();
        }
#line 153
        if ((int const   )*(*tmp___2 + check) & 1024) {
          {
#line 153
          tmp___3 = __ctype_b_loc();
          }
#line 153
          if ((int const   )*(*tmp___3 + check) & 256) {
            {
#line 153
            tmp___4 = was_hotkey(check, result, n);
            }
#line 153
            if (! tmp___4) {
#line 154
              *(result + n) = check;
#line 155
              goto while_break___0;
            }
          }
        }
#line 143
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 137
      n ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 160
  return (result);
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/buttons.c"
static void print_button(WINDOW *win , char *label , int hotkey , int y , int x ,
                         int selected ) 
{ 
  int i ;
  int state ;
  int const   *indx ;
  int const   *tmp ;
  int limit ;
  int tmp___0 ;
  chtype key_attr ;
  chtype tmp___1 ;
  chtype label_attr ;
  chtype tmp___2 ;
  chtype tmp___3 ;
  int check ;
  int first___0 ;
  int last ;
  chtype tmp___4 ;
  size_t tmp___5 ;

  {
  {
#line 170
  state = 0;
#line 171
  tmp = dlg_index_wchars((char const   *)label);
#line 171
  indx = tmp;
#line 172
  tmp___0 = dlg_count_wchars((char const   *)label);
#line 172
  limit = tmp___0;
  }
#line 173
  if (selected) {
#line 173
    tmp___1 = dlg_color_table[7].atr;
  } else {
#line 173
    tmp___1 = dlg_color_table[8].atr;
  }
#line 173
  key_attr = tmp___1;
#line 176
  if (selected) {
#line 176
    tmp___2 = dlg_color_table[9].atr;
  } else {
#line 176
    tmp___2 = dlg_color_table[10].atr;
  }
  {
#line 176
  label_attr = tmp___2;
#line 180
  wmove(win, y, x);
  }
#line 181
  if (win) {
#line 181
    if (selected) {
#line 181
      tmp___3 = dlg_color_table[5].atr;
    } else {
#line 181
      tmp___3 = dlg_color_table[6].atr;
    }
#line 181
    win->_attrs = tmp___3;
  }
  {
#line 184
  waddnstr(win, "<", -1);
  }
#line 185
  if (win) {
#line 185
    win->_attrs = label_attr;
  }
#line 186
  i = 0;
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;
#line 186
    if (! (i < limit)) {
#line 186
      goto while_break;
    }
#line 188
    first___0 = (int )*(indx + i);
#line 189
    last = (int )*(indx + (i + 1));
    {
#line 192
    if (state == 0) {
#line 192
      goto case_0;
    }
#line 205
    if (state == 1) {
#line 205
      goto case_1;
    }
#line 191
    goto switch_break;
    case_0: /* CIL Label */ 
#line 193
    check = (int )((unsigned char )*(label + first___0));
#line 200
    if (check == hotkey) {
#line 201
      if (win) {
#line 201
        win->_attrs = key_attr;
      }
#line 202
      state = 1;
    }
#line 204
    goto switch_break;
    case_1: /* CIL Label */ 
#line 206
    if (win) {
#line 206
      win->_attrs = label_attr;
    }
#line 207
    state = 2;
#line 208
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 210
    waddnstr(win, (char const   *)(label + first___0), last - first___0);
#line 186
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 212
  if (win) {
#line 212
    if (selected) {
#line 212
      tmp___4 = dlg_color_table[5].atr;
    } else {
#line 212
      tmp___4 = dlg_color_table[6].atr;
    }
#line 212
    win->_attrs = tmp___4;
  }
  {
#line 215
  waddnstr(win, ">", -1);
#line 216
  tmp___5 = strspn((char const   *)label, " ");
#line 216
  wmove(win, y, (x + (int )tmp___5) + 1);
  }
#line 217
  return;
}
}
#line 222 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/buttons.c"
int dlg_button_count(char const   **labels___3 ) 
{ 
  int result ;
  char const   **tmp ;

  {
#line 225
  result = 0;
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
#line 226
    tmp = labels___3;
#line 226
    labels___3 ++;
#line 226
    if (! ((unsigned long )*tmp != (unsigned long )((char const   *)0))) {
#line 226
      goto while_break;
    }
#line 227
    result ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 228
  return (result);
}
}
#line 235 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/buttons.c"
void dlg_button_sizes(char const   **labels___3 , int vertical , int *longest , int *length ) 
{ 
  int n ;
  int len ;
  int tmp ;

  {
#line 243
  *length = 0;
#line 244
  *longest = 0;
#line 245
  n = 0;
  {
#line 245
  while (1) {
    while_continue: /* CIL Label */ ;
#line 245
    if (! ((unsigned long )*(labels___3 + n) != (unsigned long )((char const   *)0))) {
#line 245
      goto while_break;
    }
#line 246
    if (vertical) {
#line 247
      (*length) ++;
#line 248
      *longest = 1;
    } else {
      {
#line 250
      tmp = dlg_count_columns(*(labels___3 + n));
#line 250
      len = tmp;
      }
#line 251
      if (len > *longest) {
#line 252
        *longest = len;
      }
#line 253
      *length += len;
    }
#line 245
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 260
  if (*longest < 6 - (*longest & 1)) {
#line 261
    *longest = 6 - (*longest & 1);
  }
#line 262
  if (! vertical) {
#line 263
    *length = *longest * n;
  }
#line 264
  return;
}
}
#line 269 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/buttons.c"
int dlg_button_x_step(char const   **labels___3 , int limit , int *gap , int *margin ,
                      int *step ) 
{ 
  int count ;
  int tmp ;
  int longest ;
  int length ;
  int unused ;
  int used ;
  int result ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 272
  tmp = dlg_button_count(labels___3);
#line 272
  count = tmp;
#line 279
  *margin = 0;
  }
#line 280
  if (count != 0) {
    {
#line 281
    dlg_button_sizes(labels___3, 0, & longest, & length);
#line 282
    used = length + count * 2;
#line 283
    unused = limit - used;
#line 285
    tmp___1 = unused / (count + 3);
#line 285
    *gap = tmp___1;
    }
#line 285
    if (tmp___1 <= 0) {
#line 286
      tmp___0 = unused / (count + 1);
#line 286
      *gap = tmp___0;
#line 286
      if (tmp___0 <= 0) {
#line 287
        *gap = 1;
      }
#line 288
      *margin = *gap;
    } else {
#line 290
      *margin = *gap * 2;
    }
#line 292
    *step = *gap + ((used + count) - 1) / count;
#line 293
    if (*gap > 0) {
#line 293
      if (unused >= 0) {
#line 293
        tmp___2 = 1;
      } else {
#line 293
        tmp___2 = 0;
      }
    } else {
#line 293
      tmp___2 = 0;
    }
#line 293
    result = tmp___2;
  } else {
#line 295
    result = 0;
  }
#line 297
  return (result);
}
}
#line 303 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/buttons.c"
void dlg_button_layout(char const   **labels___3 , int *limit ) 
{ 
  int width ;
  int gap ;
  int margin ;
  int step ;
  int tmp ;
  int tmp___0 ;

  {
#line 306
  width = 1;
#line 309
  if ((unsigned long )labels___3 != (unsigned long )((char const   **)0)) {
    {
#line 309
    tmp___0 = dlg_button_count(labels___3);
    }
#line 309
    if (tmp___0) {
      {
#line 310
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 310
        tmp = dlg_button_x_step(labels___3, width, & gap, & margin, & step);
        }
#line 310
        if (tmp) {
#line 310
          goto while_break;
        }
#line 311
        width ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 312
      width += 4;
#line 313
      if (width > COLS) {
#line 314
        width = COLS;
      }
#line 315
      if (width > *limit) {
#line 316
        *limit = width;
      }
    }
  }
#line 318
  return;
}
}
#line 323 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/buttons.c"
void dlg_draw_buttons(WINDOW *win , int y , int x , char const   **labels___3 , int selected ,
                      int vertical , int limit ) 
{ 
  chtype save ;
  chtype tmp ;
  int n ;
  int step ;
  int length ;
  int longest ;
  int final_x ;
  int final_y ;
  int gap ;
  int margin ;
  size_t need ;
  char *buffer ;
  int tmp___0 ;
  int tmp___1 ;
  int *hotkeys ;
  int *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 331
  tmp = dlg_get_attrs(win);
#line 331
  save = tmp;
#line 333
  step = 0;
  }
#line 343
  if (win) {
#line 343
    tmp___0 = (int )win->_begy;
  } else {
#line 343
    tmp___0 = -1;
  }
#line 343
  if (win) {
#line 343
    tmp___1 = (int )win->_begx;
  } else {
#line 343
    tmp___1 = -1;
  }
  {
#line 343
  dlg_mouse_setbase(tmp___1, tmp___0);
  }
#line 345
  if (win) {
#line 345
    final_y = (int )win->_cury;
  } else {
#line 345
    final_y = -1;
  }
#line 345
  if (win) {
#line 345
    final_x = (int )win->_curx;
  } else {
#line 345
    final_x = -1;
  }
  {
#line 347
  dlg_button_sizes(labels___3, vertical, & longest, & length);
  }
#line 349
  if (vertical) {
#line 350
    y ++;
#line 351
    step = 1;
  } else {
    {
#line 353
    dlg_button_x_step(labels___3, limit, & gap, & margin, & step);
#line 354
    x += margin;
    }
  }
#line 360
  need = (size_t )longest;
#line 361
  if (need != 0UL) {
    {
#line 362
    tmp___2 = get_hotkeys(labels___3);
#line 362
    hotkeys = tmp___2;
    }
#line 363
    if ((unsigned long )hotkeys == (unsigned long )((int *)0)) {
      {
#line 363
      dlg_exiterr("cannot allocate memory in dlg_draw_buttons");
      }
    }
#line 365
    n = 0;
    {
#line 365
    while (1) {
      while_continue: /* CIL Label */ ;
#line 365
      if (! ((unsigned long )*(labels___3 + n) != (unsigned long )((char const   *)0))) {
#line 365
        goto while_break;
      }
      {
#line 366
      tmp___3 = strlen(*(labels___3 + n));
#line 366
      need += tmp___3 + 1UL;
#line 365
      n ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 368
    tmp___4 = malloc(need * sizeof(char ));
#line 368
    buffer = (char *)tmp___4;
    }
#line 369
    if ((unsigned long )buffer == (unsigned long )((char *)0)) {
      {
#line 369
      dlg_exiterr("cannot allocate memory in dlg_draw_buttons");
      }
    }
#line 374
    n = 0;
    {
#line 374
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 374
      if (! ((unsigned long )*(labels___3 + n) != (unsigned long )((char const   *)0))) {
#line 374
        goto while_break___0;
      }
      {
#line 375
      center_label(buffer, longest, *(labels___3 + n));
#line 376
      tmp___5 = dlg_count_columns((char const   *)buffer);
#line 376
      dlg_mouse_mkregion(y, x, 1, tmp___5, n);
      }
#line 377
      if (selected == n) {
#line 377
        tmp___6 = 1;
      } else
#line 377
      if (n == 0) {
#line 377
        if (selected < 0) {
#line 377
          tmp___6 = 1;
        } else {
#line 377
          tmp___6 = 0;
        }
      } else {
#line 377
        tmp___6 = 0;
      }
      {
#line 377
      print_button(win, buffer, *(hotkeys + n), y, x, tmp___6);
      }
#line 379
      if (selected == n) {
#line 380
        if (win) {
#line 380
          final_y = (int )win->_cury;
        } else {
#line 380
          final_y = -1;
        }
#line 380
        if (win) {
#line 380
          final_x = (int )win->_curx;
        } else {
#line 380
          final_x = -1;
        }
      }
#line 382
      if (vertical) {
#line 383
        y += step;
#line 383
        if (y > limit) {
#line 384
          goto while_break___0;
        }
      } else {
#line 386
        x += step;
#line 386
        if (x > limit) {
#line 387
          goto while_break___0;
        }
      }
#line 374
      n ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 390
    wmove(win, final_y, final_x);
#line 391
    wrefresh(win);
    }
#line 392
    if (win) {
#line 392
      win->_attrs = save;
    }
    {
#line 393
    free((void *)buffer);
#line 394
    free((void *)hotkeys);
    }
  }
#line 396
  return;
}
}
#line 403 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/buttons.c"
int dlg_match_char(int ch , char const   *string ) 
{ 
  int cmp2 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 406
  if ((unsigned long )string != (unsigned long )((char const   *)0)) {
    {
#line 407
    tmp = string_to_char(& string);
#line 407
    cmp2 = tmp;
    }
#line 414
    if (ch > 0) {
#line 414
      if (ch < 256) {
#line 415
        if (ch > 0) {
#line 415
          if (ch <= 255) {
            {
#line 415
            tmp___0 = toupper(ch);
#line 415
            tmp___1 = tmp___0;
            }
          } else {
#line 415
            tmp___1 = ch;
          }
        } else {
#line 415
          tmp___1 = ch;
        }
#line 415
        if (cmp2 > 0) {
#line 415
          if (cmp2 <= 255) {
            {
#line 415
            tmp___2 = toupper(cmp2);
#line 415
            tmp___3 = tmp___2;
            }
          } else {
#line 415
            tmp___3 = cmp2;
          }
        } else {
#line 415
          tmp___3 = cmp2;
        }
#line 415
        if (tmp___1 == tmp___3) {
#line 416
          return (1);
        }
      }
    }
  }
#line 420
  return (0);
}
}
#line 427 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/buttons.c"
int dlg_button_to_char(char const   *label ) 
{ 
  int cmp ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 430
  cmp = -1;
  {
#line 432
  while (1) {
    while_continue: /* CIL Label */ ;
#line 432
    if (! ((int const   )*label != 0)) {
#line 432
      goto while_break;
    }
    {
#line 433
    cmp = string_to_char(& label);
#line 434
    tmp = __ctype_b_loc();
    }
#line 434
    if ((int const   )*(*tmp + cmp) & 1024) {
      {
#line 434
      tmp___0 = __ctype_b_loc();
      }
#line 434
      if ((int const   )*(*tmp___0 + cmp) & 256) {
#line 435
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 438
  return (cmp);
}
}
#line 446 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/buttons.c"
int dlg_char_to_button(int ch , char const   **labels___3 ) 
{ 
  int result ;
  int *hotkeys ;
  int *tmp ;
  int j ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 449
  result = -2;
#line 451
  if ((unsigned long )labels___3 != (unsigned long )((char const   **)0)) {
    {
#line 452
    tmp = get_hotkeys(labels___3);
#line 452
    hotkeys = tmp;
#line 455
    tmp___6 = dlg_last_getc();
    }
#line 455
    if (tmp___6 > 0) {
      {
#line 455
      tmp___7 = dlg_last_getc();
      }
#line 455
      if (tmp___7 <= 255) {
        {
#line 455
        tmp___2 = dlg_last_getc();
#line 455
        tmp___3 = toupper(tmp___2);
#line 455
        tmp___5 = tmp___3;
        }
      } else {
        {
#line 455
        tmp___4 = dlg_last_getc();
#line 455
        tmp___5 = tmp___4;
        }
      }
    } else {
      {
#line 455
      tmp___4 = dlg_last_getc();
#line 455
      tmp___5 = tmp___4;
      }
    }
#line 455
    ch = tmp___5;
#line 457
    if ((unsigned long )hotkeys != (unsigned long )((int *)0)) {
#line 458
      j = 0;
      {
#line 458
      while (1) {
        while_continue: /* CIL Label */ ;
#line 458
        if (! ((unsigned long )*(labels___3 + j) != (unsigned long )((char const   *)0))) {
#line 458
          goto while_break;
        }
#line 459
        if (ch == *(hotkeys + j)) {
          {
#line 460
          dlg_flush_getc();
#line 461
          result = j;
          }
#line 462
          goto while_break;
        }
#line 458
        j ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 465
      free((void *)hotkeys);
      }
    }
  }
#line 469
  return (result);
}
}
#line 472 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/buttons.c"
static char const   *my_yes_label(void) 
{ 
  char const   *tmp ;

  {
#line 475
  if ((unsigned long )dialog_vars.yes_label != (unsigned long )((void *)0)) {
#line 475
    tmp = (char const   *)dialog_vars.yes_label;
  } else {
#line 475
    tmp = "Yes";
  }
#line 475
  return (tmp);
}
}
#line 480 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/buttons.c"
static char const   *my_no_label(void) 
{ 
  char const   *tmp ;

  {
#line 483
  if ((unsigned long )dialog_vars.no_label != (unsigned long )((void *)0)) {
#line 483
    tmp = (char const   *)dialog_vars.no_label;
  } else {
#line 483
    tmp = "No";
  }
#line 483
  return (tmp);
}
}
#line 488 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/buttons.c"
static char const   *my_ok_label(void) 
{ 
  char const   *tmp ;

  {
#line 491
  if ((unsigned long )dialog_vars.ok_label != (unsigned long )((void *)0)) {
#line 491
    tmp = (char const   *)dialog_vars.ok_label;
  } else {
#line 491
    tmp = "OK";
  }
#line 491
  return (tmp);
}
}
#line 496 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/buttons.c"
static char const   *my_cancel_label(void) 
{ 
  char const   *tmp ;

  {
#line 499
  if ((unsigned long )dialog_vars.cancel_label != (unsigned long )((void *)0)) {
#line 499
    tmp = (char const   *)dialog_vars.cancel_label;
  } else {
#line 499
    tmp = "Cancel";
  }
#line 499
  return (tmp);
}
}
#line 504 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/buttons.c"
static char const   *my_exit_label(void) 
{ 
  char const   *tmp ;

  {
#line 507
  if ((unsigned long )dialog_vars.exit_label != (unsigned long )((void *)0)) {
#line 507
    tmp = (char const   *)dialog_vars.exit_label;
  } else {
#line 507
    tmp = "EXIT";
  }
#line 507
  return (tmp);
}
}
#line 512 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/buttons.c"
static char const   *my_extra_label(void) 
{ 
  char const   *tmp ;

  {
#line 515
  if ((unsigned long )dialog_vars.extra_label != (unsigned long )((void *)0)) {
#line 515
    tmp = (char const   *)dialog_vars.extra_label;
  } else {
#line 515
    tmp = "Extra";
  }
#line 515
  return (tmp);
}
}
#line 520 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/buttons.c"
static char const   *my_help_label(void) 
{ 
  char const   *tmp ;

  {
#line 523
  if ((unsigned long )dialog_vars.help_label != (unsigned long )((void *)0)) {
#line 523
    tmp = (char const   *)dialog_vars.help_label;
  } else {
#line 523
    tmp = "Help";
  }
#line 523
  return (tmp);
}
}
#line 543 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/buttons.c"
static char const   *labels[3]  ;
#line 531 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/buttons.c"
char const   **dlg_exit_label(void) 
{ 
  char const   **result ;
  DIALOG_VARS save ;
  int n ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 537
  if (dialog_vars.extra_button) {
    {
#line 538
    dlg_save_vars(& save);
#line 539
    dialog_vars.nocancel = (_Bool)1;
#line 540
    result = dlg_ok_labels();
#line 541
    dlg_restore_vars(& save);
    }
  } else {
#line 544
    n = 0;
#line 546
    if (! dialog_vars.nook) {
      {
#line 547
      tmp = n;
#line 547
      n ++;
#line 547
      labels[tmp] = my_exit_label();
      }
    }
#line 548
    if (dialog_vars.help_button) {
      {
#line 549
      tmp___0 = n;
#line 549
      n ++;
#line 549
      labels[tmp___0] = my_help_label();
      }
    }
#line 550
    if (n == 0) {
      {
#line 551
      tmp___1 = n;
#line 551
      n ++;
#line 551
      labels[tmp___1] = my_exit_label();
      }
    }
#line 552
    labels[n] = (char const   *)0;
#line 554
    result = labels;
  }
#line 556
  return (result);
}
}
#line 562 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/buttons.c"
int dlg_exit_buttoncode(int button ) 
{ 
  int result ;
  DIALOG_VARS save ;

  {
  {
#line 568
  dlg_save_vars(& save);
#line 569
  dialog_vars.nocancel = (_Bool)1;
#line 571
  result = dlg_ok_buttoncode(button);
#line 573
  dlg_restore_vars(& save);
  }
#line 575
  return (result);
}
}
#line 581 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/buttons.c"
static char const   *labels___0[4]  ;
#line 578 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/buttons.c"
char const   **dlg_ok_label(void) 
{ 
  int n ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 582
  n = 0;
#line 584
  tmp = n;
#line 584
  n ++;
#line 584
  labels___0[tmp] = my_ok_label();
  }
#line 585
  if (dialog_vars.extra_button) {
    {
#line 586
    tmp___0 = n;
#line 586
    n ++;
#line 586
    labels___0[tmp___0] = my_extra_label();
    }
  }
#line 587
  if (dialog_vars.help_button) {
    {
#line 588
    tmp___1 = n;
#line 588
    n ++;
#line 588
    labels___0[tmp___1] = my_help_label();
    }
  }
#line 589
  labels___0[n] = (char const   *)0;
#line 590
  return (labels___0);
}
}
#line 599 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/buttons.c"
static char const   *labels___1[5]  ;
#line 596 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/buttons.c"
char const   **dlg_ok_labels(void) 
{ 
  int n ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 600
  n = 0;
#line 602
  if (! dialog_vars.nook) {
    {
#line 603
    tmp = n;
#line 603
    n ++;
#line 603
    labels___1[tmp] = my_ok_label();
    }
  }
#line 604
  if (dialog_vars.extra_button) {
    {
#line 605
    tmp___0 = n;
#line 605
    n ++;
#line 605
    labels___1[tmp___0] = my_extra_label();
    }
  }
#line 606
  if (! dialog_vars.nocancel) {
    {
#line 607
    tmp___1 = n;
#line 607
    n ++;
#line 607
    labels___1[tmp___1] = my_cancel_label();
    }
  }
#line 608
  if (dialog_vars.help_button) {
    {
#line 609
    tmp___2 = n;
#line 609
    n ++;
#line 609
    labels___1[tmp___2] = my_help_label();
    }
  }
#line 610
  labels___1[n] = (char const   *)0;
#line 611
  return (labels___1);
}
}
#line 617 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/buttons.c"
int dlg_ok_buttoncode(int button ) 
{ 
  int result ;
  int n ;
  int tmp ;
  int tmp___0 ;

  {
#line 620
  result = -1;
#line 621
  n = ! dialog_vars.nook;
#line 623
  if (! dialog_vars.nook) {
#line 623
    if (button <= 0) {
#line 624
      result = 0;
    } else {
#line 623
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 625
  if (dialog_vars.extra_button) {
#line 625
    tmp___0 = n;
#line 625
    n ++;
#line 625
    if (button == tmp___0) {
#line 626
      result = 3;
    } else {
#line 625
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 627
  if (! dialog_vars.nocancel) {
#line 627
    tmp = n;
#line 627
    n ++;
#line 627
    if (button == tmp) {
#line 628
      result = 1;
    } else {
#line 627
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 629
  if (dialog_vars.help_button) {
#line 629
    if (button == n) {
#line 630
      result = 2;
    }
  }
  {
#line 632
  dlg_trace_msg("# dlg_ok_buttoncode(%d) = %d\n", button, result);
  }
#line 633
  return (result);
}
}
#line 641 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/buttons.c"
int dlg_next_ok_buttonindex(int current , int extra ) 
{ 
  int result ;
  int tmp ;

  {
#line 644
  result = current + 1;
#line 646
  if (current >= 0) {
    {
#line 646
    tmp = dlg_ok_buttoncode(result);
    }
#line 646
    if (tmp < 0) {
#line 648
      result = extra;
    }
  }
#line 649
  return (result);
}
}
#line 655 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/buttons.c"
int dlg_prev_ok_buttonindex(int current , int extra ) 
{ 
  int result ;
  int tmp ;

  {
#line 658
  result = current - 1;
#line 660
  if (result < extra) {
#line 661
    result = 0;
    {
#line 661
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 661
      tmp = dlg_ok_buttoncode(result + 1);
      }
#line 661
      if (! (tmp >= 0)) {
#line 661
        goto while_break;
      }
#line 661
      result ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 665
  return (result);
}
}
#line 673 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/buttons.c"
int dlg_defaultno_button(void) 
{ 
  int result ;
  int tmp ;

  {
#line 676
  result = 0;
#line 678
  if (dialog_vars.defaultno) {
#line 678
    if (! dialog_vars.nocancel) {
      {
#line 679
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 679
        tmp = dlg_ok_buttoncode(result);
        }
#line 679
        if (! (tmp != 1)) {
#line 679
          goto while_break;
        }
#line 680
        result ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 682
  dlg_trace_msg("# dlg_defaultno_button() = %d\n", result);
  }
#line 683
  return (result);
}
}
#line 691 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/buttons.c"
int dlg_default_button(void) 
{ 
  int i ;
  int n ;
  int result ;

  {
#line 695
  result = 0;
#line 697
  if (dialog_vars.default_button >= 0) {
#line 698
    i = 0;
    {
#line 698
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 698
      n = dlg_ok_buttoncode(i);
      }
#line 698
      if (! (n >= 0)) {
#line 698
        goto while_break;
      }
#line 699
      if (n == dialog_vars.default_button) {
#line 700
        result = i;
#line 701
        goto while_break;
      }
#line 698
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 705
  dlg_trace_msg("# dlg_default_button() = %d\n", result);
  }
#line 706
  return (result);
}
}
#line 720 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/buttons.c"
static char const   *labels___2[4]  ;
#line 712 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/buttons.c"
char const   **dlg_yes_labels(void) 
{ 
  char const   **result ;
  int n ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 717
  if (dialog_vars.extra_button) {
    {
#line 718
    result = dlg_ok_labels();
    }
  } else {
    {
#line 721
    n = 0;
#line 723
    tmp = n;
#line 723
    n ++;
#line 723
    labels___2[tmp] = my_yes_label();
#line 724
    tmp___0 = n;
#line 724
    n ++;
#line 724
    labels___2[tmp___0] = my_no_label();
    }
#line 725
    if (dialog_vars.help_button) {
      {
#line 726
      tmp___1 = n;
#line 726
      n ++;
#line 726
      labels___2[tmp___1] = my_help_label();
      }
    }
#line 727
    labels___2[n] = (char const   *)0;
#line 729
    result = labels___2;
  }
#line 732
  return (result);
}
}
#line 738 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/buttons.c"
int dlg_yes_buttoncode(int button ) 
{ 
  int result ;

  {
#line 741
  result = -1;
#line 743
  if (dialog_vars.extra_button) {
    {
#line 744
    result = dlg_ok_buttoncode(button);
    }
  } else
#line 745
  if (button == 0) {
#line 746
    result = 0;
  } else
#line 747
  if (button == 1) {
#line 748
    result = 1;
  } else
#line 749
  if (button == 2) {
#line 749
    if (dialog_vars.help_button) {
#line 750
      result = 2;
    }
  }
#line 753
  return (result);
}
}
#line 759 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/buttons.c"
int dlg_next_button(char const   **labels___3 , int button ) 
{ 


  {
#line 762
  if (button < -1) {
#line 763
    button = -1;
  }
#line 765
  if ((unsigned long )*(labels___3 + (button + 1)) != (unsigned long )((char const   *)0)) {
#line 766
    button ++;
  } else {
#line 768
    button = - dialog_state.visit_cols;
  }
#line 770
  return (button);
}
}
#line 776 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/buttons.c"
int dlg_prev_button(char const   **labels___3 , int button ) 
{ 


  {
#line 779
  if (button > - dialog_state.visit_cols) {
#line 780
    button --;
  } else {
#line 782
    if (button < -1) {
#line 783
      button = -1;
    }
    {
#line 785
    while (1) {
      while_continue: /* CIL Label */ ;
#line 785
      if (! ((unsigned long )*(labels___3 + (button + 1)) != (unsigned long )((char const   *)0))) {
#line 785
        goto while_break;
      }
#line 786
      button ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 788
  return (button);
}
}
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 590 "./dialog.h"
int dialog_checklist(char const   *title , char const   *cprompt , int height , int width ,
                     int list_height , int item_no , char **items , int flag ) ;
#line 640
int dlg_checklist(char const   *title , char const   *cprompt , int height , int width ,
                  int list_height , int item_no , DIALOG_LISTITEM *items , char const   *states ,
                  int flag , int *current_item ) ;
#line 760
extern void dlg_add_quoted(char * ) ;
#line 55 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/checklist.c"
static void print_item___0(ALL_DATA___0 *data , WINDOW *win , DIALOG_LISTITEM *item ,
                           char const   *states , int choice , int selected ) 
{ 
  chtype save ;
  chtype tmp ;
  int i ;
  _Bool both ;
  int tmp___0 ;
  _Bool first___0 ;
  int climit ;
  int tmp___1 ;
  char const   *show ;
  char *tmp___2 ;
  chtype tmp___3 ;
  char const   *tmp___4 ;

  {
  {
#line 63
  tmp = dlg_get_attrs(win);
#line 63
  save = tmp;
  }
#line 65
  if (! dialog_vars.no_tags) {
#line 65
    if (! dialog_vars.no_items) {
#line 65
      tmp___0 = 1;
    } else {
#line 65
      tmp___0 = 0;
    }
  } else {
#line 65
    tmp___0 = 0;
  }
#line 65
  both = (_Bool )tmp___0;
#line 66
  first___0 = (_Bool)1;
#line 67
  if (win) {
#line 67
    tmp___1 = (int )win->_maxx + 1;
  } else {
#line 67
    tmp___1 = -1;
  }
#line 67
  climit = (tmp___1 - data->check_x) + 1;
#line 68
  if (dialog_vars.no_items) {
#line 68
    tmp___2 = item->name;
  } else {
#line 68
    tmp___2 = item->text;
  }
#line 68
  show = (char const   *)tmp___2;
#line 73
  if (win) {
#line 73
    win->_attrs = dlg_color_table[17].atr;
  }
  {
#line 74
  wmove(win, choice, 0);
#line 75
  i = 0;
  }
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
#line 75
    if (! (i < data->use_width)) {
#line 75
      goto while_break;
    }
    {
#line 76
    waddch(win, (chtype const   )' ');
#line 75
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 78
  wmove(win, choice, data->check_x);
  }
#line 79
  if (win) {
#line 79
    if (selected) {
#line 79
      tmp___3 = dlg_color_table[26].atr;
    } else {
#line 79
      tmp___3 = dlg_color_table[25].atr;
    }
#line 79
    win->_attrs = tmp___3;
  }
#line 80
  if (data->checkflag == 1) {
#line 80
    tmp___4 = "[%c]";
  } else {
#line 80
    tmp___4 = "(%c)";
  }
  {
#line 80
  wprintw(win, tmp___4, (int const   )*(states + item->state));
  }
#line 83
  if (win) {
#line 83
    win->_attrs = dlg_color_table[17].atr;
  }
  {
#line 84
  waddch(win, (chtype const   )' ');
  }
#line 86
  if (both) {
    {
#line 87
    dlg_print_listitem(win, (char const   *)item->name, climit, first___0, selected);
#line 88
    first___0 = (_Bool)0;
    }
  }
  {
#line 91
  wmove(win, choice, data->item_x);
#line 92
  dlg_print_listitem(win, show, climit, first___0, selected);
  }
#line 94
  if (selected) {
    {
#line 95
    dlg_item_help((char const   *)item->help);
    }
  }
#line 97
  if (win) {
#line 97
    win->_attrs = save;
  }
#line 98
  return;
}
}
#line 100 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/checklist.c"
static void print_list(ALL_DATA___0 *data , int choice , int scrollamt , int max_choice ) 
{ 
  int i ;
  int cur_y ;
  int cur_x ;

  {
#line 106
  if (data->dialog) {
#line 106
    cur_y = (int )(data->dialog)->_cury;
  } else {
#line 106
    cur_y = -1;
  }
#line 106
  if (data->dialog) {
#line 106
    cur_x = (int )(data->dialog)->_curx;
  } else {
#line 106
    cur_x = -1;
  }
#line 107
  i = 0;
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 107
    if (! (i < max_choice)) {
#line 107
      goto while_break;
    }
    {
#line 108
    print_item___0(data, data->list, data->items + (i + scrollamt), data->states,
                   i, i == choice);
#line 107
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 114
  wnoutrefresh(data->list);
#line 116
  dlg_draw_scrollbar(data->dialog, (long )scrollamt, (long )scrollamt, (long )(scrollamt + max_choice),
                     (long )data->item_no, data->box_x + data->check_x, data->box_x + data->use_width,
                     data->box_y, (data->box_y + data->use_height) + 1, dlg_color_table[37].atr,
                     dlg_color_table[18].atr);
#line 128
  wmove(data->dialog, cur_y, cur_x);
  }
#line 129
  return;
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/checklist.c"
static _Bool check_hotkey___0(DIALOG_LISTITEM *items , int choice ) 
{ 
  _Bool result ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 134
  result = (_Bool)0;
#line 136
  if (dialog_vars.no_tags) {
#line 136
    tmp = (items + choice)->text;
  } else {
#line 136
    tmp = (items + choice)->name;
  }
  {
#line 136
  tmp___0 = dlg_last_getc();
#line 136
  tmp___1 = dlg_match_char(tmp___0, (char const   *)tmp);
  }
#line 136
  if (tmp___1) {
#line 140
    result = (_Bool)1;
  }
#line 142
  return (result);
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/checklist.c"
static DLG_KEYS_BINDING binding___1[24]  = 
#line 164
  {      {0, 5, 545}, 
        {1, 265, 545}, 
        {1, 363, 545}, 
        {0, '\n', 541}, 
        {0, '\r', 541}, 
        {1, 343, 541}, 
        {1, 261, 528}, 
        {0, 9, 528}, 
        {1, 353, 529}, 
        {1, 260, 529}, 
        {1, 262, 522}, 
        {1, 360, 523}, 
        {1, 347, 523}, 
        {0, '+', 524}, 
        {1, 258, 524}, 
        {0, 14, 524}, 
        {0, '-', 525}, 
        {1, 259, 525}, 
        {0, 16, 525}, 
        {1, 338, 520}, 
        {1, 1106, 520}, 
        {1, 339, 521}, 
        {1, 1107, 521}, 
        {-1, 0, 0}};
#line 151 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/checklist.c"
int dlg_checklist(char const   *title , char const   *cprompt , int height , int width ,
                  int list_height , int item_no , DIALOG_LISTITEM *items , char const   *states ,
                  int flag , int *current_item ) 
{ 
  int old_height ;
  int old_width ;
  ALL_DATA___0 all ;
  int i ;
  int j ;
  int key2 ;
  int found ;
  int x ;
  int y ;
  int cur_x ;
  int cur_y ;
  int key ;
  int fkey ;
  int button ;
  int tmp ;
  int tmp___0 ;
  int choice ;
  int tmp___1 ;
  int scrollamt ;
  int max_choice ;
  int was_mouse ;
  int use_width ;
  int list_width ;
  int name_width ;
  int text_width ;
  int result ;
  int num_states ;
  WINDOW *dialog ;
  char *prompt ;
  char *tmp___2 ;
  char const   **buttons ;
  char const   **tmp___3 ;
  char const   *widget_name ;
  _Bool first___0 ;
  int tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___11 ;
  int tmp___12 ;
  int need ;
  int want ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int current ;
  int next ;
  _Bool tmp___17 ;
  _Bool tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;

  {
#line 189
  old_height = height;
#line 190
  old_width = width;
#line 194
  key = 0;
#line 195
  if (dialog_state.visit_items) {
#line 195
    tmp___0 = -1;
  } else {
    {
#line 195
    tmp = dlg_default_button();
#line 195
    tmp___0 = tmp;
    }
  }
  {
#line 195
  button = tmp___0;
#line 196
  tmp___1 = dlg_default_listitem(items);
#line 196
  choice = tmp___1;
#line 197
  scrollamt = 0;
#line 201
  result = -2;
#line 204
  tmp___2 = dlg_strclone(cprompt);
#line 204
  prompt = tmp___2;
#line 205
  tmp___3 = dlg_ok_labels();
#line 205
  buttons = tmp___3;
#line 208
  memset((void *)(& all), 0, sizeof(all));
#line 209
  all.items = items;
#line 210
  all.item_no = item_no;
#line 212
  dlg_does_output();
#line 213
  dlg_tab_correct_str(prompt);
  }
#line 220
  if (flag == 0) {
#line 221
    first___0 = (_Bool)1;
#line 223
    i = 0;
    {
#line 223
    while (1) {
      while_continue: /* CIL Label */ ;
#line 223
      if (! (i < item_no)) {
#line 223
        goto while_break;
      }
#line 224
      if ((items + i)->state) {
#line 225
        if (first___0) {
#line 226
          first___0 = (_Bool)0;
        } else {
#line 228
          (items + i)->state = 0;
        }
      }
#line 223
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 232
    widget_name = "radiolist";
  } else {
#line 234
    widget_name = "checklist";
  }
  retry: 
  {
#line 240
  all.use_height = list_height;
#line 241
  tmp___4 = dlg_calc_list_width(item_no, items);
#line 241
  use_width = tmp___4 + 10;
  }
#line 242
  if (26 > use_width) {
#line 242
    use_width = 26;
  } else {
#line 242
    use_width = use_width;
  }
#line 243
  if (all.use_height == 0) {
    {
#line 245
    dlg_auto_size(title, (char const   *)prompt, & height, & width, 6, use_width);
#line 246
    dlg_calc_listh(& height, & all.use_height, item_no);
    }
  } else {
    {
#line 248
    dlg_auto_size(title, (char const   *)prompt, & height, & width, 6 + all.use_height,
                  use_width);
    }
  }
  {
#line 252
  dlg_button_layout(buttons, & width);
#line 253
  dlg_print_size(height, width);
#line 254
  dlg_ctl_size(height, width);
  }
#line 257
  if ((unsigned long )states == (unsigned long )((char const   *)0)) {
#line 258
    states = " *";
  } else {
    {
#line 257
    tmp___5 = strlen(states);
    }
#line 257
    if (tmp___5 < 2UL) {
#line 258
      states = " *";
    }
  }
  {
#line 259
  tmp___6 = strlen(states);
#line 259
  num_states = (int )tmp___6;
#line 260
  all.states = states;
#line 262
  all.checkflag = flag;
#line 264
  x = dlg_box_x_ordinate(width);
#line 265
  y = dlg_box_y_ordinate(height);
#line 267
  dialog = dlg_new_window(height, width, y, x);
#line 268
  all.dialog = dialog;
#line 269
  dlg_register_window(dialog, widget_name, binding___1);
#line 270
  dlg_register_buttons(dialog, widget_name, buttons);
#line 272
  dlg_mouse_setbase(x, y);
#line 274
  dlg_draw_box2(dialog, 0, 0, height, width, dlg_color_table[2].atr, dlg_color_table[4].atr,
                dlg_color_table[34].atr);
#line 275
  dlg_draw_bottom_box2(dialog, dlg_color_table[4].atr, dlg_color_table[34].atr, dlg_color_table[2].atr);
#line 276
  dlg_draw_title(dialog, title);
  }
#line 278
  if (dialog) {
#line 278
    dialog->_attrs = dlg_color_table[2].atr;
  }
  {
#line 279
  dlg_print_autowrap(dialog, (char const   *)prompt, height, width);
#line 281
  all.use_width = width - 6;
  }
#line 282
  if (dialog) {
#line 282
    cur_y = (int )dialog->_cury;
  } else {
#line 282
    cur_y = -1;
  }
#line 282
  if (dialog) {
#line 282
    cur_x = (int )dialog->_curx;
  } else {
#line 282
    cur_x = -1;
  }
#line 283
  all.box_y = cur_y + 1;
#line 284
  all.box_x = (width - all.use_width) / 2 - 1;
#line 290
  if (all.use_height + 6 > height - cur_y) {
#line 291
    all.use_height = (height - 6) - cur_y;
  }
#line 292
  if (all.use_height <= 0) {
#line 293
    all.use_height = 1;
  }
#line 295
  if (all.use_height < item_no) {
#line 295
    max_choice = all.use_height;
  } else {
#line 295
    max_choice = item_no;
  }
#line 296
  if (max_choice > 1) {
#line 296
    max_choice = max_choice;
  } else {
#line 296
    max_choice = 1;
  }
  {
#line 299
  all.list = dlg_sub_window(dialog, all.use_height, all.use_width, (y + all.box_y) + 1,
                            (x + all.box_x) + 1);
#line 303
  dlg_draw_box(dialog, all.box_y, all.box_x, all.use_height + 2, all.use_width + 2,
               dlg_color_table[18].atr, dlg_color_table[37].atr);
#line 308
  text_width = 0;
#line 309
  name_width = 0;
#line 311
  i = 0;
  }
  {
#line 311
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 311
    if (! (i < item_no)) {
#line 311
      goto while_break___0;
    }
    {
#line 312
    tmp___9 = dlg_count_columns((char const   *)(items + i)->text);
    }
#line 312
    if (text_width > tmp___9) {
#line 312
      text_width = text_width;
    } else {
      {
#line 312
      tmp___8 = dlg_count_columns((char const   *)(items + i)->text);
#line 312
      text_width = tmp___8;
      }
    }
    {
#line 313
    tmp___12 = dlg_count_columns((char const   *)(items + i)->name);
    }
#line 313
    if (name_width > tmp___12) {
#line 313
      name_width = name_width;
    } else {
      {
#line 313
      tmp___11 = dlg_count_columns((char const   *)(items + i)->name);
#line 313
      name_width = tmp___11;
      }
    }
#line 311
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 320
  use_width = all.use_width - 6;
#line 321
  if (dialog_vars.no_tags) {
#line 322
    if (all.use_width < text_width) {
#line 322
      list_width = all.use_width;
    } else {
#line 322
      list_width = text_width;
    }
  } else
#line 323
  if (dialog_vars.no_items) {
#line 324
    if (all.use_width < name_width) {
#line 324
      list_width = all.use_width;
    } else {
#line 324
      list_width = name_width;
    }
  } else {
#line 326
    if (text_width >= 0) {
#line 326
      if (name_width >= 0) {
#line 326
        if (use_width > 0) {
#line 326
          if (text_width + name_width > use_width) {
#line 330
            need = (int )(0.25 * (double )use_width);
#line 331
            if (name_width > need) {
#line 332
              want = (int )(((double )use_width * (double )name_width) / (double )(text_width + name_width));
#line 334
              if (want > need) {
#line 334
                name_width = want;
              } else {
#line 334
                name_width = need;
              }
            }
#line 336
            text_width = use_width - name_width;
          }
        }
      }
    }
#line 338
    list_width = text_width + name_width;
  }
#line 341
  all.check_x = (use_width - list_width) / 2;
#line 342
  if (dialog_vars.no_tags) {
#line 342
    tmp___14 = 0;
  } else {
#line 342
    if (dialog_vars.no_items) {
#line 342
      tmp___13 = 0;
    } else {
#line 342
      tmp___13 = 2 + name_width;
    }
#line 342
    tmp___14 = tmp___13;
  }
#line 342
  all.item_x = (tmp___14 + all.check_x) + 4;
#line 350
  if (scrollamt < (max_choice + item_no) - 1) {
#line 350
    scrollamt = scrollamt;
  } else {
#line 350
    scrollamt = (max_choice + item_no) - 1;
  }
#line 351
  if (choice >= (max_choice + scrollamt) - 1) {
#line 352
    if (0 > (choice - max_choice) + 1) {
#line 352
      scrollamt = 0;
    } else {
#line 352
      scrollamt = (choice - max_choice) + 1;
    }
#line 353
    choice = max_choice - 1;
  }
  {
#line 355
  print_list(& all, choice, scrollamt, max_choice);
#line 358
  dlg_mouse_mkbigregion(all.box_y + 1, all.box_x, all.use_height, all.use_width + 2,
                        511, 1, 1, 1);
#line 362
  dlg_draw_buttons(dialog, height - 2, 0, buttons, button, 0, width);
#line 364
  dlg_trace_win(dialog);
  }
  {
#line 365
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 365
    if (! (result == -2)) {
#line 365
      goto while_break___1;
    }
#line 366
    if (button < 0) {
      {
#line 367
      wmove(dialog, (all.box_y + choice) + 1, (all.box_x + all.check_x) + 2);
      }
    }
    {
#line 369
    key = dlg_mouse_wgetch(dialog, & fkey);
#line 370
    tmp___15 = dlg_result_key(key, fkey, & result);
    }
#line 370
    if (tmp___15) {
#line 371
      goto while_break___1;
    }
#line 373
    if (fkey) {
#line 373
      if (key >= 768) {
#line 373
        tmp___16 = 1;
      } else {
#line 373
        tmp___16 = 0;
      }
    } else {
#line 373
      tmp___16 = 0;
    }
#line 373
    was_mouse = tmp___16;
#line 374
    if (was_mouse) {
#line 375
      key -= 768;
    }
#line 377
    if (was_mouse) {
#line 377
      if (key >= 511) {
#line 378
        if (dialog) {
#line 378
          cur_y = (int )dialog->_cury;
        } else {
#line 378
          cur_y = -1;
        }
#line 378
        if (dialog) {
#line 378
          cur_x = (int )dialog->_curx;
        } else {
#line 378
          cur_x = -1;
        }
#line 379
        i = key - 511;
#line 380
        if (i < max_choice) {
          {
#line 381
          choice = key - 511;
#line 382
          print_list(& all, choice, scrollamt, max_choice);
#line 384
          key = ' ';
          }
        } else {
          {
#line 386
          beep();
          }
#line 387
          goto while_continue___1;
        }
#line 389
        fkey = 0;
      } else {
#line 377
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 390
    if (was_mouse) {
#line 390
      if (key >= 257) {
        {
#line 391
        key = dlg_lookup_key(dialog, key, & fkey);
        }
      }
    }
#line 399
    if (key == 32) {
#line 400
      current = scrollamt + choice;
#line 401
      next = (items + current)->state + 1;
#line 403
      if (next >= num_states) {
#line 404
        next = 0;
      }
#line 406
      if (flag == 1) {
#line 407
        if (dialog) {
#line 407
          cur_y = (int )dialog->_cury;
        } else {
#line 407
          cur_y = -1;
        }
#line 407
        if (dialog) {
#line 407
          cur_x = (int )dialog->_curx;
        } else {
#line 407
          cur_x = -1;
        }
        {
#line 408
        (items + current)->state = next;
#line 409
        print_item___0(& all, all.list, items + (scrollamt + choice), states, choice,
                       1);
#line 413
        wnoutrefresh(all.list);
#line 414
        wmove(dialog, cur_y, cur_x);
        }
      } else {
#line 416
        i = 0;
        {
#line 416
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 416
          if (! (i < item_no)) {
#line 416
            goto while_break___2;
          }
#line 417
          if (i != current) {
#line 418
            (items + i)->state = 0;
          }
#line 416
          i ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 421
        if ((items + current)->state) {
#line 422
          if (dialog) {
#line 422
            cur_y = (int )dialog->_cury;
          } else {
#line 422
            cur_y = -1;
          }
#line 422
          if (dialog) {
#line 422
            cur_x = (int )dialog->_curx;
          } else {
#line 422
            cur_x = -1;
          }
#line 423
          if (next) {
#line 423
            (items + current)->state = next;
          } else {
#line 423
            (items + current)->state = 1;
          }
          {
#line 424
          print_item___0(& all, all.list, items + current, states, choice, 1);
#line 428
          wnoutrefresh(all.list);
#line 429
          wmove(dialog, cur_y, cur_x);
          }
        } else {
          {
#line 431
          (items + current)->state = 1;
#line 432
          print_list(& all, choice, scrollamt, max_choice);
          }
        }
      }
#line 435
      goto while_continue___1;
    }
#line 443
    found = 0;
#line 444
    if (! fkey) {
#line 445
      if (button < 0) {
#line 445
        goto _L___0;
      } else
#line 445
      if (! dialog_state.visit_items) {
        _L___0: /* CIL Label */ 
#line 446
        j = (scrollamt + choice) + 1;
        {
#line 446
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 446
          if (! (j < item_no)) {
#line 446
            goto while_break___3;
          }
          {
#line 447
          tmp___17 = check_hotkey___0(items, j);
          }
#line 447
          if (tmp___17) {
#line 448
            found = 1;
#line 449
            i = j - scrollamt;
#line 450
            goto while_break___3;
          }
#line 446
          j ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 453
        if (! found) {
#line 454
          j = 0;
          {
#line 454
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 454
            if (! (j <= scrollamt + choice)) {
#line 454
              goto while_break___4;
            }
            {
#line 455
            tmp___18 = check_hotkey___0(items, j);
            }
#line 455
            if (tmp___18) {
#line 456
              found = 1;
#line 457
              i = j - scrollamt;
#line 458
              goto while_break___4;
            }
#line 454
            j ++;
          }
          while_break___4: /* CIL Label */ ;
          }
        }
#line 462
        if (found) {
          {
#line 463
          dlg_flush_getc();
          }
        }
      } else {
        {
#line 464
        j = dlg_char_to_button(key, buttons);
        }
#line 464
        if (j >= 0) {
          {
#line 465
          button = j;
#line 466
          ungetch('\n');
          }
#line 467
          goto while_continue___1;
        }
      }
    }
#line 475
    if (! found) {
#line 475
      if (key <= 57) {
#line 475
        if (key > 48) {
#line 475
          if (key - 49 < max_choice) {
#line 479
            found = 1;
#line 480
            i = key - 49;
          }
        }
      }
    }
#line 483
    if (! found) {
#line 484
      if (fkey) {
#line 485
        found = 1;
        {
#line 487
        if (key == 522) {
#line 487
          goto case_522;
        }
#line 490
        if (key == 523) {
#line 490
          goto case_523;
        }
#line 493
        if (key == 521) {
#line 493
          goto case_521;
        }
#line 501
        if (key == 520) {
#line 501
          goto case_520;
        }
#line 504
        if (key == 525) {
#line 504
          goto case_525;
        }
#line 509
        if (key == 524) {
#line 509
          goto case_524;
        }
#line 514
        goto switch_default;
        case_522: /* CIL Label */ 
#line 488
        i = - scrollamt;
#line 489
        goto switch_break;
        case_523: /* CIL Label */ 
#line 491
        i = (item_no - 1) - scrollamt;
#line 492
        goto switch_break;
        case_521: /* CIL Label */ 
#line 494
        if (choice) {
#line 495
          i = 0;
        } else
#line 496
        if (scrollamt != 0) {
#line 497
          if (scrollamt < max_choice) {
#line 497
            tmp___19 = scrollamt;
          } else {
#line 497
            tmp___19 = max_choice;
          }
#line 497
          i = - tmp___19;
        } else {
#line 499
          goto while_continue___1;
        }
#line 500
        goto switch_break;
        case_520: /* CIL Label */ 
#line 502
        if (choice + max_choice < (item_no - scrollamt) - 1) {
#line 502
          i = choice + max_choice;
        } else {
#line 502
          i = (item_no - scrollamt) - 1;
        }
#line 503
        goto switch_break;
        case_525: /* CIL Label */ 
#line 505
        i = choice - 1;
#line 506
        if (choice == 0) {
#line 506
          if (scrollamt == 0) {
#line 507
            goto while_continue___1;
          }
        }
#line 508
        goto switch_break;
        case_524: /* CIL Label */ 
#line 510
        i = choice + 1;
#line 511
        if (scrollamt + choice >= item_no - 1) {
#line 512
          goto while_continue___1;
        }
#line 513
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 515
        found = 0;
#line 516
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
    }
#line 521
    if (found) {
#line 522
      if (i != choice) {
#line 523
        if (dialog) {
#line 523
          cur_y = (int )dialog->_cury;
        } else {
#line 523
          cur_y = -1;
        }
#line 523
        if (dialog) {
#line 523
          cur_x = (int )dialog->_curx;
        } else {
#line 523
          cur_x = -1;
        }
#line 524
        if (i < 0) {
#line 524
          goto _L___1;
        } else
#line 524
        if (i >= max_choice) {
          _L___1: /* CIL Label */ 
#line 525
          if (i < 0) {
#line 526
            scrollamt += i;
#line 527
            choice = 0;
          } else {
#line 529
            choice = max_choice - 1;
#line 530
            scrollamt += (i - max_choice) + 1;
          }
          {
#line 532
          print_list(& all, choice, scrollamt, max_choice);
          }
        } else {
          {
#line 534
          choice = i;
#line 535
          print_list(& all, choice, scrollamt, max_choice);
          }
        }
      }
#line 538
      goto while_continue___1;
    }
#line 541
    if (fkey) {
      {
#line 543
      if (key == 541) {
#line 543
        goto case_541;
      }
#line 546
      if (key == 529) {
#line 546
        goto case_529;
      }
#line 551
      if (key == 528) {
#line 551
        goto case_528;
      }
#line 557
      if (key == 410) {
#line 557
        goto case_410;
      }
#line 568
      goto switch_default___0;
      case_541: /* CIL Label */ 
#line 544
      if (dialog_vars.nook) {
#line 544
        result = 0;
      } else {
        {
#line 544
        tmp___20 = dlg_ok_buttoncode(button);
#line 544
        result = tmp___20;
        }
      }
#line 545
      goto switch_break___0;
      case_529: /* CIL Label */ 
      {
#line 547
      button = dlg_prev_button(buttons, button);
#line 548
      dlg_draw_buttons(dialog, height - 2, 0, buttons, button, 0, width);
      }
#line 550
      goto switch_break___0;
      case_528: /* CIL Label */ 
      {
#line 552
      button = dlg_next_button(buttons, button);
#line 553
      dlg_draw_buttons(dialog, height - 2, 0, buttons, button, 0, width);
      }
#line 555
      goto switch_break___0;
      case_410: /* CIL Label */ 
      {
#line 559
      height = old_height;
#line 560
      width = old_width;
#line 562
      dlg_clear();
#line 563
      dlg_del_window(dialog);
#line 564
      wrefresh(stdscr);
#line 565
      dlg_mouse_free_regions();
      }
#line 566
      goto retry;
      switch_default___0: /* CIL Label */ 
#line 569
      if (was_mouse) {
        {
#line 570
        key2 = dlg_ok_buttoncode(key);
        }
#line 570
        if (key2 >= 0) {
#line 571
          result = key2;
#line 572
          goto switch_break___0;
        }
        {
#line 574
        beep();
        }
      }
      switch_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 578
      beep();
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 582
  dlg_del_window(dialog);
#line 583
  dlg_mouse_free_regions();
#line 584
  free((void *)prompt);
#line 585
  *current_item = scrollamt + choice;
  }
#line 586
  return (result);
}
}
#line 593 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/checklist.c"
int dialog_checklist(char const   *title , char const   *cprompt , int height , int width ,
                     int list_height , int item_no , char **items , int flag ) 
{ 
  int result ;
  int i ;
  int j ;
  DIALOG_LISTITEM *listitems ;
  _Bool separate_output ;
  int tmp ;
  _Bool show_status ;
  int current ;
  char *help_result ;
  void *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  _Bool tmp___9 ;

  {
#line 606
  if (flag == 1) {
#line 606
    if (dialog_vars.separate_output) {
#line 606
      tmp = 1;
    } else {
#line 606
      tmp = 0;
    }
  } else {
#line 606
    tmp = 0;
  }
  {
#line 606
  separate_output = (_Bool )tmp;
#line 608
  show_status = (_Bool)0;
#line 609
  current = 0;
#line 612
  tmp___0 = calloc((size_t )item_no + 1UL, sizeof(DIALOG_LISTITEM ));
#line 612
  listitems = (DIALOG_LISTITEM *)tmp___0;
  }
#line 613
  if ((unsigned long )listitems == (unsigned long )((DIALOG_LISTITEM *)0)) {
    {
#line 613
    dlg_exiterr("cannot allocate memory in dialog_checklist");
    }
  }
#line 615
  j = 0;
#line 615
  i = j;
  {
#line 615
  while (1) {
    while_continue: /* CIL Label */ ;
#line 615
    if (! (i < item_no)) {
#line 615
      goto while_break;
    }
#line 616
    tmp___1 = j;
#line 616
    j ++;
#line 616
    (listitems + i)->name = *(items + tmp___1);
#line 617
    if (dialog_vars.no_items) {
      {
#line 617
      tmp___2 = dlg_strempty();
#line 617
      (listitems + i)->text = tmp___2;
      }
    } else {
#line 617
      tmp___3 = j;
#line 617
      j ++;
#line 617
      (listitems + i)->text = *(items + tmp___3);
    }
    {
#line 620
    tmp___4 = j;
#line 620
    j ++;
#line 620
    tmp___5 = strcasecmp((char const   *)*(items + tmp___4), "on");
    }
#line 620
    if (tmp___5) {
#line 620
      tmp___6 = 0;
    } else {
#line 620
      tmp___6 = 1;
    }
#line 620
    (listitems + i)->state = tmp___6;
#line 621
    if (dialog_vars.item_help) {
#line 621
      tmp___7 = j;
#line 621
      j ++;
#line 621
      (listitems + i)->help = *(items + tmp___7);
    } else {
      {
#line 621
      tmp___8 = dlg_strempty();
#line 621
      (listitems + i)->help = tmp___8;
      }
    }
#line 615
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 625
  dlg_align_columns(& (listitems + 0)->text, (int )sizeof(DIALOG_LISTITEM ), item_no);
#line 627
  result = dlg_checklist(title, cprompt, height, width, list_height, item_no, listitems,
                         (char const   *)((void *)0), flag, & current);
  }
  {
#line 640
  if (result == 3) {
#line 640
    goto case_3;
  }
#line 640
  if (result == 0) {
#line 640
    goto case_3;
  }
#line 643
  if (result == 2) {
#line 643
    goto case_2;
  }
#line 638
  goto switch_break;
  case_3: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 641
  show_status = (_Bool)1;
#line 642
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 644
  dlg_add_help_listitem(& result, & help_result, listitems + current);
#line 645
  show_status = dialog_vars.help_status;
  }
#line 645
  if (show_status) {
#line 646
    if (separate_output) {
      {
#line 647
      dlg_add_string(help_result);
#line 648
      dlg_add_separator();
      }
    } else {
      {
#line 650
      dlg_add_quoted(help_result);
      }
    }
  } else {
    {
#line 653
    dlg_add_string(help_result);
    }
  }
#line 655
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 658
  if (show_status) {
#line 659
    i = 0;
    {
#line 659
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 659
      if (! (i < item_no)) {
#line 659
        goto while_break___0;
      }
#line 660
      if ((listitems + i)->state) {
#line 661
        if (separate_output) {
          {
#line 662
          dlg_add_string((listitems + i)->name);
#line 663
          dlg_add_separator();
          }
        } else {
          {
#line 665
          tmp___9 = dlg_need_separator();
          }
#line 665
          if (tmp___9) {
            {
#line 666
            dlg_add_separator();
            }
          }
#line 667
          if (flag == 1) {
            {
#line 668
            dlg_add_quoted((listitems + i)->name);
            }
          } else {
            {
#line 670
            dlg_add_string((listitems + i)->name);
            }
          }
        }
      }
#line 659
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 674
    dlg_add_last_key((int )separate_output);
    }
  }
  {
#line 677
  dlg_free_columns(& (listitems + 0)->text, (int )sizeof(DIALOG_LISTITEM ), item_no);
#line 678
  free((void *)listitems);
  }
#line 679
  return (result);
}
}
#line 646 "./dialog.h"
char **dlg_string_to_argv(char *blob ) ;
#line 647
int dlg_count_argv(char **argv ) ;
#line 648
int dlg_eat_argv(int *argcp , char ***argvp , int start , int count ) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/argv.c"
char **dlg_string_to_argv(char *blob ) 
{ 
  size_t n ;
  int pass ;
  size_t length ;
  size_t tmp ;
  char **result ;
  _Bool inparm ;
  _Bool quoted ;
  char *param ;
  size_t count ;
  char *tmp___0 ;
  char *tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  unsigned short const   **tmp___5 ;
  void *tmp___6 ;

  {
  {
#line 37
  tmp = strlen((char const   *)blob);
#line 37
  length = tmp;
#line 38
  result = (char **)0;
#line 40
  pass = 0;
  }
  {
#line 40
  while (1) {
    while_continue: /* CIL Label */ ;
#line 40
    if (! (pass < 2)) {
#line 40
      goto while_break;
    }
#line 41
    inparm = (_Bool)0;
#line 42
    quoted = (_Bool)0;
#line 43
    param = blob;
#line 44
    count = (size_t )0;
#line 46
    n = (size_t )0;
    {
#line 46
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 46
      if (! (n < length)) {
#line 46
        goto while_break___0;
      }
#line 47
      if (quoted) {
#line 47
        if ((int )*(blob + n) == 34) {
#line 48
          quoted = (_Bool)0;
        } else {
#line 47
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 49
      if ((int )*(blob + n) == 34) {
#line 50
        quoted = (_Bool)1;
#line 51
        if (! inparm) {
#line 52
          if (pass) {
#line 53
            *(result + count) = param;
          }
#line 54
          count ++;
#line 55
          inparm = (_Bool)1;
        }
      } else
#line 57
      if ((int )*(blob + n) == 92) {
#line 58
        if (quoted) {
          {
#line 58
          tmp___2 = __ctype_b_loc();
          }
#line 58
          if (! ((int const   )*(*tmp___2 + (int )((unsigned char )*(blob + (n + 1UL)))) & 8192)) {
#line 59
            if (pass) {
#line 60
              tmp___0 = param;
#line 60
              param ++;
#line 60
              *tmp___0 = *(blob + n);
#line 61
              tmp___1 = param;
#line 61
              param ++;
#line 61
              *tmp___1 = *(blob + (n + 1UL));
            }
          }
        }
#line 64
        n ++;
      } else
#line 65
      if (! quoted) {
        {
#line 65
        tmp___5 = __ctype_b_loc();
        }
#line 65
        if ((int const   )*(*tmp___5 + (int )((unsigned char )*(blob + n))) & 8192) {
#line 66
          inparm = (_Bool)0;
#line 67
          if (pass) {
#line 68
            tmp___3 = param;
#line 68
            param ++;
#line 68
            *tmp___3 = (char )'\000';
          }
        } else {
#line 65
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 71
        if (! inparm) {
#line 72
          if (pass) {
#line 73
            *(result + count) = param;
          }
#line 74
          count ++;
#line 75
          inparm = (_Bool)1;
        }
#line 77
        if (pass) {
#line 78
          tmp___4 = param;
#line 78
          param ++;
#line 78
          *tmp___4 = *(blob + n);
        }
      }
#line 46
      n ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 83
    if (! pass) {
#line 84
      if (count) {
        {
#line 85
        tmp___6 = calloc(count + 1UL, sizeof(char *));
#line 85
        result = (char **)tmp___6;
        }
#line 86
        if ((unsigned long )result == (unsigned long )((char **)0)) {
          {
#line 86
          dlg_exiterr("cannot allocate memory in string_to_argv");
          }
        }
      } else {
#line 88
        goto while_break;
      }
    } else {
#line 91
      *param = (char )'\000';
    }
#line 40
    pass ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 94
  return (result);
}
}
#line 100 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/argv.c"
int dlg_count_argv(char **argv ) 
{ 
  int result ;

  {
#line 103
  result = 0;
#line 105
  if ((unsigned long )argv != (unsigned long )((char **)0)) {
    {
#line 106
    while (1) {
      while_continue: /* CIL Label */ ;
#line 106
      if (! ((unsigned long )*(argv + result) != (unsigned long )((char *)0))) {
#line 106
        goto while_break;
      }
#line 107
      result ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 109
  return (result);
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/argv.c"
int dlg_eat_argv(int *argcp , char ***argvp , int start , int count ) 
{ 
  int k ;

  {
#line 117
  *argcp -= count;
#line 118
  k = start;
  {
#line 118
  while (1) {
    while_continue: /* CIL Label */ ;
#line 118
    if (! (k <= *argcp)) {
#line 118
      goto while_break;
    }
#line 119
    *(*argvp + k) = *(*argvp + (k + count));
#line 118
    k ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 120
  *(*argvp + *argcp) = (char *)0;
#line 121
  return (1);
}
}
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 272 "/usr/include/stdio.h"
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 1392 "/usr/include/curses.h"
extern int LINES ;
#line 592 "./dialog.h"
int dialog_editbox(char const   *title , char const   *file , int height , int width ) ;
#line 685
int dlg_editbox(char const   *title , char ***list , int *rows , int height , int width ) ;
#line 700
int const   *dlg_index_columns(char const   *string ) ;
#line 764
extern void dlg_attr_clear(WINDOW * , int  , int  , chtype  ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/editbox.c"
static void fail_list(void) 
{ 


  {
  {
#line 33
  dlg_exiterr("File too large");
  }
#line 34
  return;
}
}
#line 36 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/editbox.c"
static void grow_list(char ***list , int *have , int want ) 
{ 
  size_t last ;
  size_t need ;
  void *tmp ;

  {
#line 39
  if (want > *have) {
    {
#line 40
    last = (size_t )*have;
#line 41
    need = (size_t )(want | 31) + 3UL;
#line 42
    *have = (int )need;
#line 43
    tmp = realloc((void *)*list, need * sizeof(char *));
#line 43
    *list = (char **)tmp;
    }
#line 44
    if ((unsigned long )*list == (unsigned long )((char **)0)) {
      {
#line 45
      fail_list();
      }
    } else {
      {
#line 47
      while (1) {
        while_continue: /* CIL Label */ ;
#line 47
        last ++;
#line 47
        if (! (last < need)) {
#line 47
          goto while_break;
        }
#line 48
        *(*list + last) = (char *)0;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 52
  return;
}
}
#line 54 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/editbox.c"
static void load_list(char const   *file , char ***list , int *rows ) 
{ 
  FILE *fp ;
  char *blob ;
  struct stat sb ;
  unsigned int n ;
  unsigned int pass ;
  unsigned int need ;
  size_t size ;
  int tmp ;
  int first___0 ;
  void *tmp___0 ;

  {
  {
#line 58
  blob = (char *)0;
#line 64
  *list = (char **)0;
#line 65
  *rows = 0;
#line 67
  tmp = stat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& sb));
  }
#line 67
  if (tmp < 0) {
    {
#line 69
    dlg_exiterr("Not a file: %s", file);
    }
  } else
#line 67
  if ((sb.st_mode & 61440U) != 32768U) {
    {
#line 69
    dlg_exiterr("Not a file: %s", file);
    }
  }
  {
#line 71
  size = (size_t )sb.st_size;
#line 72
  tmp___0 = malloc((size + 1UL) * sizeof(char ));
#line 72
  blob = (char *)tmp___0;
  }
#line 72
  if ((unsigned long )blob == (unsigned long )((char *)0)) {
    {
#line 73
    fail_list();
    }
  } else {
    {
#line 75
    *(blob + size) = (char )'\000';
#line 77
    fp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"r");
    }
#line 77
    if ((unsigned long )fp == (unsigned long )((FILE *)0)) {
      {
#line 78
      dlg_exiterr("Cannot open: %s", file);
      }
    }
    {
#line 79
    size = fread((void */* __restrict  */)blob, sizeof(char ), size, (FILE */* __restrict  */)fp);
#line 80
    fclose(fp);
#line 82
    pass = 0U;
    }
    {
#line 82
    while (1) {
      while_continue: /* CIL Label */ ;
#line 82
      if (! (pass < 2U)) {
#line 82
        goto while_break;
      }
#line 83
      first___0 = 1;
#line 84
      need = 0U;
#line 85
      n = 0U;
      {
#line 85
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 85
        if (! ((size_t )n < size)) {
#line 85
          goto while_break___0;
        }
#line 86
        if (first___0) {
#line 86
          if (pass) {
#line 87
            *(*list + need) = blob + n;
#line 88
            first___0 = 0;
          }
        }
#line 90
        if ((int )*(blob + n) == 10) {
#line 91
          first___0 = 1;
#line 92
          need ++;
#line 93
          if (pass) {
#line 94
            *(blob + n) = (char )'\000';
          }
        }
#line 85
        n ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 97
      if (pass) {
#line 98
        if (need == 0U) {
          {
#line 99
          *(*list + 0) = dlg_strclone("");
#line 100
          *(*list + 1) = (char *)0;
          }
        } else {
#line 102
          n = 0U;
          {
#line 102
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 102
            if (! (n < need)) {
#line 102
              goto while_break___1;
            }
            {
#line 103
            *(*list + n) = dlg_strclone((char const   *)*(*list + n));
#line 102
            n ++;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 105
          *(*list + need) = (char *)0;
        }
      } else {
        {
#line 108
        grow_list(list, rows, (int )need + 1);
        }
      }
#line 82
      pass ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 111
    free((void *)blob);
    }
  }
#line 113
  return;
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/editbox.c"
static void free_list(char ***list , int *rows ) 
{ 
  int n ;

  {
#line 118
  if ((unsigned long )*list != (unsigned long )((char **)0)) {
#line 120
    n = 0;
    {
#line 120
    while (1) {
      while_continue: /* CIL Label */ ;
#line 120
      if (! (n < *rows)) {
#line 120
        goto while_break;
      }
#line 121
      if ((unsigned long )*(*list + n) != (unsigned long )((char *)0)) {
        {
#line 122
        free((void *)*(*list + n));
        }
      }
#line 120
      n ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 124
    free((void *)*list);
#line 125
    *list = (char **)0;
    }
  }
#line 127
  *rows = 0;
#line 128
  return;
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/editbox.c"
static _Bool display_one(WINDOW *win , char *text , int thisrow , int show_row , int base_row ,
                         int chr_offset ) 
{ 
  _Bool result ;
  int tmp ;
  chtype tmp___0 ;

  {
#line 146
  if ((unsigned long )text != (unsigned long )((char *)0)) {
#line 147
    if (win) {
#line 147
      tmp = (int )win->_maxx + 1;
    } else {
#line 147
      tmp = -1;
    }
#line 147
    if (thisrow == show_row) {
#line 147
      tmp___0 = dlg_color_table[30].atr;
    } else {
#line 147
      tmp___0 = dlg_color_table[31].atr;
    }
    {
#line 147
    dlg_show_string(win, (char const   *)text, chr_offset, tmp___0, thisrow - base_row,
                    0, tmp, (_Bool)0, (_Bool)0);
#line 158
    result = (_Bool)1;
    }
  } else {
#line 160
    result = (_Bool)0;
  }
#line 162
  return (result);
}
}
#line 165 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/editbox.c"
static void display_all(WINDOW *win , char **list , int show_row , int firstrow ,
                        int lastrow , int chr_offset ) 
{ 
  int limit ;
  int tmp ;
  int row ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  _Bool tmp___3 ;

  {
#line 173
  if (win) {
#line 173
    tmp = (int )win->_maxy + 1;
  } else {
#line 173
    tmp = -1;
  }
#line 173
  limit = tmp;
#line 176
  if (win) {
#line 176
    tmp___0 = (int )win->_maxx + 1;
  } else {
#line 176
    tmp___0 = -1;
  }
#line 176
  if (win) {
#line 176
    tmp___1 = (int )win->_maxy + 1;
  } else {
#line 176
    tmp___1 = -1;
  }
  {
#line 176
  dlg_attr_clear(win, tmp___1, tmp___0, dlg_color_table[2].atr);
  }
#line 177
  if (lastrow - firstrow >= limit) {
#line 178
    lastrow = firstrow + limit;
  }
#line 179
  row = firstrow;
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 179
    if (! (row < lastrow)) {
#line 179
      goto while_break;
    }
#line 180
    if (row == show_row) {
#line 180
      tmp___2 = chr_offset;
    } else {
#line 180
      tmp___2 = 0;
    }
    {
#line 180
    tmp___3 = display_one(win, *(list + row), row, show_row, firstrow, tmp___2);
    }
#line 180
    if (! tmp___3) {
#line 183
      goto while_break;
    }
#line 179
    row ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 185
  return;
}
}
#line 187 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/editbox.c"
static int size_list(char **list ) 
{ 
  int result ;
  char **tmp ;

  {
#line 190
  result = 0;
#line 192
  if ((unsigned long )list != (unsigned long )((char **)0)) {
    {
#line 193
    while (1) {
      while_continue: /* CIL Label */ ;
#line 193
      tmp = list;
#line 193
      list ++;
#line 193
      if (! ((unsigned long )*tmp != (unsigned long )((char *)0))) {
#line 193
        goto while_break;
      }
#line 194
      result ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 197
  return (result);
}
}
#line 200 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/editbox.c"
static _Bool scroll_to(int pagesize , int rows , int *base_row , int *this_row , int target ) 
{ 
  _Bool result ;

  {
#line 203
  result = (_Bool)0;
#line 205
  if (target < *base_row) {
#line 206
    if (target < 0) {
#line 207
      if (*base_row == 0) {
#line 207
        if (*this_row == 0) {
          {
#line 208
          beep();
          }
        } else {
#line 210
          *this_row = 0;
#line 211
          *base_row = 0;
#line 212
          result = (_Bool)1;
        }
      } else {
#line 210
        *this_row = 0;
#line 211
        *base_row = 0;
#line 212
        result = (_Bool)1;
      }
    } else {
#line 215
      *this_row = target;
#line 216
      *base_row = target;
#line 217
      result = (_Bool)1;
    }
  } else
#line 219
  if (target >= rows) {
#line 220
    if (*this_row < rows - 1) {
#line 221
      *this_row = rows - 1;
#line 222
      *base_row = rows - 1;
#line 223
      result = (_Bool)1;
    } else {
      {
#line 225
      beep();
      }
    }
  } else
#line 227
  if (target >= *base_row + pagesize) {
#line 228
    *this_row = target;
#line 229
    *base_row = target;
#line 230
    result = (_Bool)1;
  } else {
#line 232
    *this_row = target;
#line 233
    result = (_Bool)0;
  }
#line 235
  if (pagesize < rows) {
#line 236
    if (*base_row + pagesize >= rows) {
#line 237
      *base_row = rows - pagesize;
    }
  } else {
#line 240
    *base_row = 0;
  }
#line 242
  return (result);
}
}
#line 245 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/editbox.c"
static int col_to_chr_offset(char const   *text , int col ) 
{ 
  int const   *cols ;
  int const   *tmp ;
  int const   *indx ;
  int const   *tmp___0 ;
  _Bool found ;
  int result ;
  unsigned int n ;
  unsigned int len ;
  int tmp___1 ;

  {
  {
#line 248
  tmp = dlg_index_columns(text);
#line 248
  cols = tmp;
#line 249
  tmp___0 = dlg_index_wchars(text);
#line 249
  indx = tmp___0;
#line 250
  found = (_Bool)0;
#line 251
  result = 0;
#line 253
  tmp___1 = dlg_count_wchars(text);
#line 253
  len = (unsigned int )tmp___1;
#line 255
  n = 0U;
  }
  {
#line 255
  while (1) {
    while_continue: /* CIL Label */ ;
#line 255
    if (! (n < len)) {
#line 255
      goto while_break;
    }
#line 256
    if (*(cols + n) <= (int const   )col) {
#line 256
      if (*(cols + (n + 1U)) > (int const   )col) {
#line 257
        result = (int )*(indx + n);
#line 258
        found = (_Bool)1;
#line 259
        goto while_break;
      }
    }
#line 255
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 262
  if (! found) {
#line 262
    if (len) {
#line 262
      if (*(cols + len) == (int const   )col) {
#line 263
        result = (int )*(indx + len);
      }
    }
  }
#line 265
  return (result);
}
}
#line 276 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/editbox.c"
static int widest_line(char **list ) 
{ 
  int result ;
  char *value ;
  int check ;
  size_t tmp ;
  char **tmp___0 ;

  {
#line 279
  result = 2048;
#line 282
  if ((unsigned long )list != (unsigned long )((char **)0)) {
    {
#line 283
    while (1) {
      while_continue: /* CIL Label */ ;
#line 283
      tmp___0 = list;
#line 283
      list ++;
#line 283
      value = *tmp___0;
#line 283
      if (! ((unsigned long )value != (unsigned long )((char *)0))) {
#line 283
        goto while_break;
      }
      {
#line 284
      tmp = strlen((char const   *)value);
#line 284
      check = (int )tmp;
      }
#line 285
      if (check > result) {
#line 286
        result = check;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 289
  return (result);
}
}
#line 317 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/editbox.c"
static DLG_KEYS_BINDING binding___2[20]  = 
#line 317
  {      {0, 5, 545}, 
        {1, 265, 545}, 
        {1, 363, 545}, 
        {0, '\n', 541}, 
        {0, '\r', 541}, 
        {1, 343, 541}, 
        {1, 258, 535}, 
        {1, 261, 537}, 
        {1, 260, 536}, 
        {1, 259, 534}, 
        {0, 9, 528}, 
        {1, 353, 529}, 
        {1, 262, 518}, 
        {1, 360, 519}, 
        {1, 347, 519}, 
        {1, 338, 520}, 
        {1, 1106, 520}, 
        {1, 339, 521}, 
        {1, 1107, 521}, 
        {-1, 0, 0}};
#line 323 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/editbox.c"
static DLG_KEYS_BINDING binding2___1[29]  = 
#line 323
  {      {1, 262, 542}, 
        {0, 21, 540}, 
        {0, 8, 538}, 
        {1, 263, 538}, 
        {0, 127, 539}, 
        {1, 330, 539}, 
        {1, 360, 543}, 
        {1, 260, 536}, 
        {1, 261, 537}, 
        {0, 5, 545}, 
        {1, 265, 545}, 
        {1, 363, 545}, 
        {0, '\n', 541}, 
        {0, '\r', 541}, 
        {1, 343, 541}, 
        {1, 258, 535}, 
        {1, 261, 537}, 
        {1, 260, 536}, 
        {1, 259, 534}, 
        {0, 9, 528}, 
        {1, 353, 529}, 
        {1, 262, 518}, 
        {1, 360, 519}, 
        {1, 347, 519}, 
        {1, 338, 520}, 
        {1, 1106, 520}, 
        {1, 339, 521}, 
        {1, 1107, 521}, 
        {-1, 0, 0}};
#line 309 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/editbox.c"
int dlg_editbox(char const   *title , char ***list , int *rows , int height , int width ) 
{ 
  int old_height ;
  int old_width ;
  int x ;
  int y ;
  int box_y ;
  int box_x ;
  int box_height ;
  int box_width ;
  int show_buttons ;
  int thisrow ;
  int base_row ;
  int lastrow ;
  int goal_col ;
  int col_offset ;
  int chr_offset ;
  int key ;
  int fkey ;
  int code ;
  int pagesize ;
  int listsize ;
  int tmp ;
  int result ;
  int state ;
  size_t max_len ;
  int tmp___0 ;
  int tmp___1 ;
  char *input ;
  char *buffer ;
  _Bool show_all ;
  _Bool show_one ;
  _Bool was_mouse ;
  _Bool first_trace ;
  WINDOW *dialog ;
  WINDOW *editing ;
  DIALOG_VARS save_vars ;
  char const   **buttons ;
  char const   **tmp___2 ;
  int mincols ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int edit ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  WINDOW *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int wide ;
  int tmp___13 ;
  int cell ;
  _Bool moved ;
  size_t len ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  char *tmp___16 ;
  void *tmp___17 ;
  char *tmp___18 ;
  _Bool tmp___19 ;
  int tmp___20 ;
  int const   *indx ;
  int const   *tmp___21 ;
  int split ;
  char *tmp___22 ;
  char *tmp___23 ;
  int n ;

  {
  {
#line 333
  old_height = height;
#line 334
  old_width = width;
#line 339
  goal_col = -1;
#line 340
  col_offset = 0;
#line 341
  chr_offset = 0;
#line 344
  tmp = size_list(*list);
#line 344
  listsize = tmp;
#line 345
  result = -2;
#line 347
  tmp___0 = widest_line(*list);
#line 347
  tmp___1 = dlg_max_input(tmp___0);
#line 347
  max_len = (size_t )tmp___1;
#line 350
  first_trace = (_Bool)1;
#line 354
  tmp___2 = dlg_ok_labels();
#line 354
  buttons = tmp___2;
#line 355
  mincols = (3 * COLS) / 4;
#line 357
  dlg_save_vars(& save_vars);
#line 358
  dialog_vars.separate_output = (_Bool)1;
#line 360
  dlg_does_output();
#line 362
  tmp___3 = malloc((max_len + 1UL) * sizeof(char ));
#line 362
  buffer = (char *)tmp___3;
  }
#line 363
  if ((unsigned long )buffer == (unsigned long )((char *)0)) {
    {
#line 363
    dlg_exiterr("cannot allocate memory in dlg_editbox");
    }
  }
#line 365
  lastrow = 0;
#line 365
  base_row = lastrow;
#line 365
  thisrow = base_row;
  retry: 
#line 370
  show_buttons = 1;
#line 371
  if (dialog_vars.default_button >= 0) {
    {
#line 371
    tmp___4 = dlg_default_button();
#line 371
    state = tmp___4;
    }
  } else {
#line 371
    state = -1;
  }
  {
#line 372
  fkey = 0;
#line 374
  dlg_button_layout(buttons, & mincols);
#line 375
  dlg_auto_size(title, "", & height, & width, (3 * LINES) / 4, mincols);
#line 376
  dlg_print_size(height, width);
#line 377
  dlg_ctl_size(height, width);
#line 379
  x = dlg_box_x_ordinate(width);
#line 380
  y = dlg_box_y_ordinate(height);
#line 382
  dialog = dlg_new_window(height, width, y, x);
#line 383
  dlg_register_window(dialog, "editbox", binding___2);
#line 384
  dlg_register_buttons(dialog, "editbox", buttons);
#line 386
  dlg_mouse_setbase(x, y);
#line 388
  dlg_draw_box2(dialog, 0, 0, height, width, dlg_color_table[2].atr, dlg_color_table[4].atr,
                dlg_color_table[34].atr);
#line 389
  dlg_draw_bottom_box2(dialog, dlg_color_table[4].atr, dlg_color_table[34].atr, dlg_color_table[2].atr);
#line 390
  dlg_draw_title(dialog, title);
  }
#line 392
  if (dialog) {
#line 392
    dialog->_attrs = dlg_color_table[2].atr;
  }
  {
#line 395
  box_y = 1;
#line 396
  box_x = 2;
#line 397
  box_width = (width - 2) - 2;
#line 398
  box_height = height - 4;
#line 400
  dlg_draw_box(dialog, box_y, box_x, box_height, box_width, dlg_color_table[4].atr,
               dlg_color_table[34].atr);
#line 406
  dlg_mouse_mkbigregion(box_y + 1, box_x + 1, box_height - 2, box_width - 2, 511,
                        1, 1, 3);
  }
#line 411
  if (dialog) {
#line 411
    tmp___5 = (int )dialog->_begx;
  } else {
#line 411
    tmp___5 = -1;
  }
#line 411
  if (dialog) {
#line 411
    tmp___6 = (int )dialog->_begy;
  } else {
#line 411
    tmp___6 = -1;
  }
  {
#line 411
  editing = dlg_sub_window(dialog, box_height - 2, box_width - 2, (tmp___6 + box_y) + 1,
                           (tmp___5 + box_x) + 1);
#line 416
  dlg_register_window(editing, "editbox2", binding2___1);
#line 418
  show_all = (_Bool)1;
#line 419
  show_one = (_Bool)0;
  }
#line 420
  if (editing) {
#line 420
    pagesize = (int )editing->_maxy + 1;
  } else {
#line 420
    pagesize = -1;
  }
  {
#line 422
  while (1) {
    while_continue: /* CIL Label */ ;
#line 422
    if (! (result == -2)) {
#line 422
      goto while_break;
    }
#line 423
    edit = 0;
#line 425
    if (show_all) {
      {
#line 426
      display_all(editing, *list, thisrow, base_row, listsize, chr_offset);
#line 427
      display_one(editing, *(*list + thisrow), thisrow, thisrow, base_row, chr_offset);
#line 429
      show_all = (_Bool)0;
#line 430
      show_one = (_Bool)1;
      }
    } else
#line 432
    if (thisrow != lastrow) {
      {
#line 433
      display_one(editing, *(*list + lastrow), lastrow, thisrow, base_row, 0);
#line 435
      show_one = (_Bool)1;
      }
    }
#line 438
    if (show_one) {
      {
#line 439
      display_one(editing, *(*list + thisrow), thisrow, thisrow, base_row, chr_offset);
      }
#line 441
      if (editing) {
#line 441
        y = (int )editing->_cury;
      } else {
#line 441
        y = -1;
      }
#line 441
      if (editing) {
#line 441
        x = (int )editing->_curx;
      } else {
#line 441
        x = -1;
      }
#line 442
      if (editing) {
#line 442
        tmp___7 = (int )editing->_maxy + 1;
      } else {
#line 442
        tmp___7 = -1;
      }
#line 442
      if (editing) {
#line 442
        tmp___8 = (int )editing->_maxx + 1;
      } else {
#line 442
        tmp___8 = -1;
      }
      {
#line 442
      dlg_draw_scrollbar(dialog, (long )base_row, (long )base_row, (long )(base_row + pagesize),
                         (long )listsize, box_x, box_x + tmp___8, box_y, (box_y + tmp___7) + 1,
                         dlg_color_table[34].atr, dlg_color_table[4].atr);
#line 453
      wmove(editing, y, x);
#line 454
      show_one = (_Bool)0;
      }
    }
#line 456
    lastrow = thisrow;
#line 457
    input = *(*list + thisrow);
#line 462
    if (show_buttons) {
      {
#line 463
      show_buttons = 0;
#line 464
      col_offset = dlg_edit_offset(input, chr_offset, box_width);
      }
#line 465
      if (state != -1) {
        {
#line 466
        display_one(editing, input, thisrow, -1, base_row, 0);
#line 468
        wrefresh(editing);
        }
      }
#line 470
      if (state != -1) {
#line 470
        tmp___9 = state;
      } else {
#line 470
        tmp___9 = 99;
      }
      {
#line 470
      dlg_draw_buttons(dialog, height - 2, 0, buttons, tmp___9, 0, width);
      }
#line 477
      if (state == -1) {
        {
#line 478
        display_one(editing, input, thisrow, thisrow, base_row, chr_offset);
        }
      }
    }
#line 483
    if (first_trace) {
      {
#line 484
      first_trace = (_Bool)0;
#line 485
      dlg_trace_win(dialog);
      }
    }
#line 488
    if (state == -1) {
#line 488
      tmp___10 = editing;
    } else {
#line 488
      tmp___10 = dialog;
    }
    {
#line 488
    key = dlg_mouse_wgetch(tmp___10, & fkey);
    }
#line 489
    if (key == -1) {
#line 490
      result = -1;
#line 491
      goto while_break;
    } else
#line 492
    if (key == 27) {
#line 493
      result = 255;
#line 494
      goto while_break;
    }
#line 496
    if (state != -1) {
      {
#line 497
      tmp___11 = dlg_result_key(key, fkey, & result);
      }
#line 497
      if (tmp___11) {
#line 498
        goto while_break;
      }
    }
#line 501
    if (fkey) {
#line 501
      if (key >= 768) {
#line 501
        tmp___12 = 1;
      } else {
#line 501
        tmp___12 = 0;
      }
    } else {
#line 501
      tmp___12 = 0;
    }
#line 501
    was_mouse = (_Bool )tmp___12;
#line 502
    if (was_mouse) {
#line 503
      key -= 768;
    }
#line 509
    if (fkey) {
#line 509
      if (was_mouse) {
        {
#line 509
        code = dlg_ok_buttoncode(key);
        }
#line 509
        if (code >= 0) {
#line 512
          result = code;
#line 513
          goto while_continue;
        }
      }
    }
#line 516
    if (was_mouse) {
#line 516
      if (key >= 511) {
#line 518
        if (editing) {
#line 518
          tmp___13 = (int )editing->_maxx + 1;
        } else {
#line 518
          tmp___13 = -1;
        }
        {
#line 518
        wide = tmp___13;
#line 519
        cell = key - 511;
#line 520
        thisrow = cell / wide + base_row;
#line 521
        col_offset = cell % wide;
#line 522
        chr_offset = col_to_chr_offset((char const   *)*(*list + thisrow), col_offset);
#line 523
        show_one = (_Bool)1;
        }
#line 524
        if (state != -1) {
#line 525
          state = -1;
#line 526
          show_buttons = 1;
        }
#line 528
        goto while_continue;
      } else {
#line 516
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 529
    if (was_mouse) {
#line 529
      if (key >= 257) {
        {
#line 530
        key = dlg_lookup_key(dialog, key, & fkey);
        }
      }
    }
#line 533
    if (state == -1) {
#line 538
      if (fkey) {
#line 539
        moved = (_Bool)1;
        {
#line 542
        if (key == 534) {
#line 542
          goto case_534;
        }
#line 545
        if (key == 535) {
#line 545
          goto case_535;
        }
#line 548
        if (key == 518) {
#line 548
          goto case_518;
        }
#line 551
        if (key == 519) {
#line 551
          goto case_519;
        }
#line 554
        if (key == 520) {
#line 554
          goto case_520;
        }
#line 557
        if (key == 521) {
#line 557
          goto case_521;
        }
#line 564
        if (key == 538) {
#line 564
          goto case_538;
        }
#line 599
        goto switch_default;
        case_534: /* CIL Label */ 
        {
#line 543
        show_all = scroll_to(pagesize, listsize, & base_row, & thisrow, thisrow - 1);
        }
#line 544
        goto switch_break;
        case_535: /* CIL Label */ 
        {
#line 546
        show_all = scroll_to(pagesize, listsize, & base_row, & thisrow, thisrow + 1);
        }
#line 547
        goto switch_break;
        case_518: /* CIL Label */ 
        {
#line 549
        show_all = scroll_to(pagesize, listsize, & base_row, & thisrow, 0);
        }
#line 550
        goto switch_break;
        case_519: /* CIL Label */ 
        {
#line 552
        show_all = scroll_to(pagesize, listsize, & base_row, & thisrow, listsize);
        }
#line 553
        goto switch_break;
        case_520: /* CIL Label */ 
        {
#line 555
        show_all = scroll_to(pagesize, listsize, & base_row, & thisrow, base_row + pagesize);
        }
#line 556
        goto switch_break;
        case_521: /* CIL Label */ 
#line 558
        if (thisrow > base_row) {
          {
#line 559
          show_all = scroll_to(pagesize, listsize, & base_row, & thisrow, base_row);
          }
        } else {
          {
#line 561
          show_all = scroll_to(pagesize, listsize, & base_row, & thisrow, base_row - pagesize);
          }
        }
#line 563
        goto switch_break;
        case_538: /* CIL Label */ 
#line 565
        if (chr_offset == 0) {
#line 566
          if (thisrow == 0) {
            {
#line 567
            beep();
            }
          } else {
            {
#line 569
            tmp___14 = strlen((char const   *)*(*list + thisrow));
#line 569
            tmp___15 = strlen((char const   *)*(*list + (thisrow - 1)));
#line 569
            len = (tmp___14 + tmp___15) + 1UL;
#line 571
            tmp___17 = malloc(len * sizeof(char ));
#line 571
            tmp___16 = (char *)tmp___17;
            }
#line 573
            if ((unsigned long )tmp___16 == (unsigned long )((char *)0)) {
              {
#line 573
              dlg_exiterr("cannot allocate memory in dlg_editbox");
              }
            }
            {
#line 575
            chr_offset = dlg_count_wchars((char const   *)*(*list + (thisrow - 1)));
#line 576
            col_offset = dlg_edit_offset(*(*list + (thisrow - 1)), chr_offset, box_width);
#line 577
            goal_col = col_offset;
#line 579
            sprintf((char */* __restrict  */)tmp___16, (char const   */* __restrict  */)"%s%s",
                    *(*list + (thisrow - 1)), *(*list + thisrow));
            }
#line 580
            if (len > max_len) {
#line 581
              *(tmp___16 + max_len) = (char )'\000';
            }
            {
#line 583
            free((void *)*(*list + (thisrow - 1)));
#line 584
            *(*list + (thisrow - 1)) = tmp___16;
#line 585
            y = thisrow;
            }
            {
#line 585
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 585
              if (! (y < listsize)) {
#line 585
                goto while_break___0;
              }
#line 586
              *(*list + y) = *(*list + (y + 1));
#line 585
              y ++;
            }
            while_break___0: /* CIL Label */ ;
            }
            {
#line 588
            listsize --;
#line 589
            thisrow --;
#line 590
            show_all = scroll_to(pagesize, listsize, & base_row, & thisrow, thisrow);
#line 592
            show_all = (_Bool)1;
            }
          }
        } else {
#line 596
          moved = (_Bool)0;
        }
#line 598
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 600
        moved = (_Bool)0;
#line 601
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 603
        if (moved) {
#line 604
          if (thisrow != lastrow) {
#line 605
            if (goal_col < 0) {
#line 606
              goal_col = col_offset;
            }
            {
#line 607
            chr_offset = col_to_chr_offset((char const   *)*(*list + thisrow), goal_col);
            }
          } else {
            {
#line 609
            col_offset = dlg_edit_offset(*(*list + thisrow), chr_offset, box_width);
            }
          }
#line 611
          goto while_continue;
        }
      }
      {
#line 614
      tmp___18 = strncpy((char */* __restrict  */)buffer, (char const   */* __restrict  */)input,
                         max_len - 1UL);
#line 614
      *(tmp___18 + (max_len - 1UL)) = (char )'\000';
#line 615
      tmp___19 = dlg_edit_string(buffer, & chr_offset, key, fkey, (_Bool)0);
#line 615
      edit = (int )tmp___19;
      }
#line 617
      if (edit) {
        {
#line 618
        col_offset = dlg_edit_offset(input, chr_offset, box_width);
#line 618
        goal_col = col_offset;
#line 619
        tmp___20 = strcmp((char const   *)input, (char const   *)buffer);
        }
#line 619
        if (tmp___20) {
          {
#line 620
          free((void *)input);
#line 621
          *(*list + thisrow) = dlg_strclone((char const   *)buffer);
#line 622
          input = *(*list + thisrow);
          }
        }
        {
#line 624
        display_one(editing, input, thisrow, thisrow, base_row, chr_offset);
        }
#line 626
        goto while_continue;
      }
    }
#line 631
    if (! fkey) {
      {
#line 631
      code = dlg_char_to_button(key, buttons);
      }
#line 631
      if (code >= 0) {
        {
#line 632
        dlg_del_window(dialog);
#line 633
        result = dlg_ok_buttoncode(code);
        }
#line 634
        goto while_continue;
      }
    }
#line 638
    if (fkey) {
      {
#line 640
      if (key == 529) {
#line 640
        goto case_529;
      }
#line 644
      if (key == 528) {
#line 644
        goto case_528;
      }
#line 648
      if (key == 541) {
#line 648
        goto case_541;
      }
#line 672
      if (key == 410) {
#line 672
        goto case_410;
      }
#line 684
      goto switch_default___0;
      case_529: /* CIL Label */ 
      {
#line 641
      show_buttons = 1;
#line 642
      state = dlg_prev_ok_buttonindex(state, -1);
      }
#line 643
      goto switch_break___0;
      case_528: /* CIL Label */ 
      {
#line 645
      show_buttons = 1;
#line 646
      state = dlg_next_ok_buttonindex(state, -1);
      }
#line 647
      goto switch_break___0;
      case_541: /* CIL Label */ 
#line 649
      if (state == -1) {
        {
#line 650
        tmp___21 = dlg_index_wchars((char const   *)*(*list + thisrow));
#line 650
        indx = tmp___21;
#line 651
        split = (int )*(indx + chr_offset);
#line 652
        tmp___23 = dlg_strclone((char const   *)(*(*list + thisrow) + split));
#line 652
        tmp___22 = tmp___23;
        }
#line 654
        if ((unsigned long )tmp___22 == (unsigned long )((char *)0)) {
          {
#line 654
          dlg_exiterr("cannot allocate memory in dlg_editbox");
          }
        }
        {
#line 655
        grow_list(list, rows, listsize + 1);
#line 656
        listsize ++;
#line 657
        y = listsize;
        }
        {
#line 657
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 657
          if (! (y > thisrow)) {
#line 657
            goto while_break___1;
          }
#line 658
          *(*list + y) = *(*list + (y - 1));
#line 657
          y --;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 660
        *(*(*list + thisrow) + split) = (char )'\000';
#line 661
        thisrow ++;
#line 662
        chr_offset = 0;
#line 663
        col_offset = 0;
#line 664
        *(*list + thisrow) = tmp___22;
#line 665
        show_all = scroll_to(pagesize, listsize, & base_row, & thisrow, thisrow);
#line 666
        show_all = (_Bool)1;
        }
      } else {
        {
#line 668
        result = dlg_ok_buttoncode(state);
        }
      }
#line 670
      goto switch_break___0;
      case_410: /* CIL Label */ 
      {
#line 674
      height = old_height;
#line 675
      width = old_width;
#line 677
      dlg_clear();
#line 678
      dlg_del_window(editing);
#line 679
      dlg_del_window(dialog);
#line 680
      wrefresh(stdscr);
#line 681
      dlg_mouse_free_regions();
      }
#line 682
      goto retry;
      switch_default___0: /* CIL Label */ 
      {
#line 685
      beep();
      }
#line 686
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    } else
#line 689
    if (key == 32) {
#line 689
      if (state != -1) {
        {
#line 690
        result = dlg_ok_buttoncode(state);
        }
      } else {
        {
#line 692
        beep();
        }
      }
    } else {
      {
#line 692
      beep();
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 697
  dlg_unregister_window(editing);
#line 698
  dlg_del_window(editing);
#line 699
  dlg_del_window(dialog);
#line 700
  dlg_mouse_free_regions();
  }
#line 707
  if (result == 0) {
#line 709
    n = 0;
    {
#line 709
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 709
      if (! (n < listsize)) {
#line 709
        goto while_break___2;
      }
      {
#line 710
      dlg_add_result((char const   *)*(*list + n));
#line 711
      dlg_add_separator();
#line 709
      n ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 713
    dlg_add_last_key(-1);
    }
  }
  {
#line 715
  free((void *)buffer);
#line 716
  dlg_restore_vars(& save_vars);
  }
#line 717
  return (result);
}
}
#line 720 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/editbox.c"
int dialog_editbox(char const   *title , char const   *file , int height , int width ) 
{ 
  int result ;
  char **list ;
  int rows ;

  {
  {
#line 727
  load_list(file, & list, & rows);
#line 728
  result = dlg_editbox(title, & list, & rows, height, width);
#line 729
  free_list(& list, & rows);
  }
#line 730
  return (result);
}
}
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 775
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) abs)(int __x )  __attribute__((__const__)) ;
#line 741 "/usr/include/curses.h"
extern int scrollok(WINDOW * , _Bool  ) ;
#line 798
extern void wbkgdset(WINDOW * , chtype  ) ;
#line 802
extern int wclrtobot(WINDOW * ) ;
#line 832
extern int wscrl(WINDOW * , int  ) ;
#line 593 "./dialog.h"
int dialog_form(char const   *title , char const   *cprompt , int height , int width ,
                int form_height , int item_no , char **items ) ;
#line 641
int dlg_form(char const   *title , char const   *cprompt , int height , int width ,
             int form_height , int item_no , DIALOG_FORMITEM *items , int *current_item ) ;
#line 688
int dlg_default_formitem(DIALOG_FORMITEM *items ) ;
#line 689
int dlg_ordinate(char const   *s ) ;
#line 690
void dlg_free_formitems(DIALOG_FORMITEM *items ) ;
#line 758
extern void dlg_add_help_formitem(int * , char ** , DIALOG_FORMITEM * ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/formbox.c"
static _Bool is_readonly(DIALOG_FORMITEM *item ) 
{ 
  int tmp ;

  {
#line 45
  if ((item->type & 2U) != 0U) {
#line 45
    tmp = 1;
  } else
#line 45
  if (item->text_flen <= 0) {
#line 45
    tmp = 1;
  } else {
#line 45
    tmp = 0;
  }
#line 45
  return ((_Bool )tmp);
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/formbox.c"
static _Bool is_hidden(DIALOG_FORMITEM *item ) 
{ 


  {
#line 51
  return ((_Bool )((item->type & 1U) != 0U));
}
}
#line 54 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/formbox.c"
static _Bool in_window(WINDOW *win , int scrollamt , int y ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 57
  if (y >= scrollamt) {
#line 57
    if (win) {
#line 57
      tmp = (int )win->_maxy + 1;
    } else {
#line 57
      tmp = -1;
    }
#line 57
    if (y - scrollamt < tmp) {
#line 57
      tmp___0 = 1;
    } else {
#line 57
      tmp___0 = 0;
    }
  } else {
#line 57
    tmp___0 = 0;
  }
#line 57
  return ((_Bool )tmp___0);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/formbox.c"
static _Bool ok_move(WINDOW *win , int scrollamt , int y , int x ) 
{ 
  _Bool tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 63
  tmp = in_window(win, scrollamt, y);
  }
#line 63
  if (tmp) {
    {
#line 63
    tmp___0 = wmove(win, y - scrollamt, x);
    }
#line 63
    if (tmp___0 != -1) {
#line 63
      tmp___1 = 1;
    } else {
#line 63
      tmp___1 = 0;
    }
  } else {
#line 63
    tmp___1 = 0;
  }
#line 63
  return ((_Bool )tmp___1);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/formbox.c"
static void move_past(WINDOW *win , int y , int x ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 70
  tmp___0 = wmove(win, y, x);
  }
#line 70
  if (tmp___0 == -1) {
#line 71
    if (win) {
#line 71
      tmp = (int )win->_maxx + 1;
    } else {
#line 71
      tmp = -1;
    }
    {
#line 71
    wmove(win, y, tmp - 1);
    }
  }
#line 72
  return;
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/formbox.c"
static int print_item___1(WINDOW *win , DIALOG_FORMITEM *item , int scrollamt , _Bool choice ) 
{ 
  int count ;
  int len ;
  int tmp___0 ;
  int tmp___1 ;
  _Bool tmp___2 ;
  chtype this_item_attribute ;
  int tmp___4 ;
  int tmp___5 ;
  _Bool tmp___6 ;
  _Bool tmp___7 ;
  _Bool tmp___8 ;

  {
  {
#line 80
  count = 0;
#line 83
  tmp___2 = ok_move(win, scrollamt, item->name_y, item->name_x);
  }
#line 83
  if (tmp___2) {
#line 84
    len = item->name_len;
#line 85
    if (win) {
#line 85
      tmp___1 = (int )win->_maxx + 1;
    } else {
#line 85
      tmp___1 = -1;
    }
#line 85
    if (len < tmp___1 - item->name_x) {
#line 85
      len = len;
    } else {
#line 85
      if (win) {
#line 85
        tmp___0 = (int )win->_maxx + 1;
      } else {
#line 85
        tmp___0 = -1;
      }
#line 85
      len = tmp___0 - item->name_x;
    }
#line 86
    if (len > 0) {
      {
#line 87
      dlg_show_string(win, (char const   *)item->name, 0, dlg_color_table[17].atr,
                      item->name_y - scrollamt, item->name_x, len, (_Bool)0, (_Bool)0);
#line 96
      move_past(win, item->name_y - scrollamt, item->name_x + len);
#line 97
      count = 1;
      }
    }
  }
#line 100
  if (item->text_len) {
    {
#line 100
    tmp___8 = ok_move(win, scrollamt, item->text_y, item->text_x);
    }
#line 100
    if (tmp___8) {
#line 103
      len = item->text_len;
#line 104
      if (win) {
#line 104
        tmp___5 = (int )win->_maxx + 1;
      } else {
#line 104
        tmp___5 = -1;
      }
#line 104
      if (len < tmp___5 - item->text_x) {
#line 104
        len = len;
      } else {
#line 104
        if (win) {
#line 104
          tmp___4 = (int )win->_maxx + 1;
        } else {
#line 104
          tmp___4 = -1;
        }
#line 104
        len = tmp___4 - item->text_x;
      }
      {
#line 106
      tmp___6 = is_readonly(item);
      }
#line 106
      if (tmp___6) {
#line 111
        this_item_attribute = dlg_color_table[32].atr;
      } else
#line 107
      if (choice) {
#line 107
        this_item_attribute = dlg_color_table[30].atr;
      } else {
#line 107
        this_item_attribute = dlg_color_table[31].atr;
      }
#line 114
      if (len > 0) {
        {
#line 115
        tmp___7 = is_hidden(item);
#line 115
        dlg_show_string(win, (char const   *)item->text, 0, this_item_attribute, item->text_y - scrollamt,
                        item->text_x, len, tmp___7, (_Bool)0);
#line 124
        move_past(win, item->text_y - scrollamt, item->text_x + len);
#line 125
        count = 1;
        }
      }
    }
  }
#line 128
  return (count);
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/formbox.c"
static void print_form(WINDOW *win , DIALOG_FORMITEM *item , int total , int scrollamt ,
                       int choice ) 
{ 
  int n ;
  int count ;
  int tmp ;

  {
#line 138
  count = 0;
#line 140
  n = 0;
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 140
    if (! (n < total)) {
#line 140
      goto while_break;
    }
    {
#line 141
    tmp = print_item___1(win, item + n, scrollamt, (_Bool )(n == choice));
#line 141
    count += tmp;
#line 140
    n ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 143
  if (count) {
    {
#line 144
    wbkgdset(win, dlg_color_table[17].atr | 32UL);
#line 145
    wclrtobot(win);
#line 146
    wnoutrefresh(win);
    }
  }
#line 148
  return;
}
}
#line 150 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/formbox.c"
static int set_choice(DIALOG_FORMITEM *item , int choice , int item_no , _Bool *noneditable ) 
{ 
  int result ;
  int i ;
  _Bool tmp ;
  _Bool tmp___0 ;

  {
  {
#line 153
  result = -1;
#line 156
  *noneditable = (_Bool)0;
#line 157
  tmp___0 = is_readonly(item + choice);
  }
#line 157
  if (tmp___0) {
#line 160
    i = 0;
    {
#line 160
    while (1) {
      while_continue: /* CIL Label */ ;
#line 160
      if (! (i < item_no)) {
#line 160
        goto while_break;
      }
      {
#line 161
      tmp = is_readonly(item + i);
      }
#line 161
      if (! tmp) {
#line 162
        result = i;
#line 163
        goto while_break;
      }
#line 160
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 166
    if (result < 0) {
#line 167
      *noneditable = (_Bool)1;
#line 168
      result = 0;
    }
  } else {
#line 158
    result = choice;
  }
#line 171
  return (result);
}
}
#line 177 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/formbox.c"
static int form_limit(DIALOG_FORMITEM *item ) 
{ 
  int n ;
  int limit ;

  {
#line 181
  limit = 0;
#line 182
  n = 0;
  {
#line 182
  while (1) {
    while_continue: /* CIL Label */ ;
#line 182
    if (! ((unsigned long )(item + n)->name != (unsigned long )((char *)0))) {
#line 182
      goto while_break;
    }
#line 183
    if (limit < (item + n)->name_y) {
#line 184
      limit = (item + n)->name_y;
    }
#line 185
    if (limit < (item + n)->text_y) {
#line 186
      limit = (item + n)->text_y;
    }
#line 182
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 188
  return (limit);
}
}
#line 191 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/formbox.c"
static int is_first_field(DIALOG_FORMITEM *item , int choice ) 
{ 
  int count ;

  {
#line 194
  count = 0;
  {
#line 195
  while (1) {
    while_continue: /* CIL Label */ ;
#line 195
    if (! (choice >= 0)) {
#line 195
      goto while_break;
    }
#line 196
    if ((item + choice)->text_flen > 0) {
#line 197
      count ++;
    }
#line 199
    choice --;
  }
  while_break: /* CIL Label */ ;
  }
#line 202
  return (count == 1);
}
}
#line 205 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/formbox.c"
static int is_last_field(DIALOG_FORMITEM *item , int choice , int item_no ) 
{ 
  int count ;

  {
#line 208
  count = 0;
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 209
    if (! (choice < item_no)) {
#line 209
      goto while_break;
    }
#line 210
    if ((item + choice)->text_flen > 0) {
#line 211
      count ++;
    }
#line 213
    choice ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 216
  return (count == 1);
}
}
#line 222 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/formbox.c"
static _Bool tab_next(WINDOW *win , DIALOG_FORMITEM *item , int item_no , int stepsize ,
                      int *choice , int *scrollamt ) 
{ 
  int old_choice ;
  int old_scroll ;
  _Bool wrapped ;
  _Bool tmp ;
  int lo ;
  int tmp___0 ;
  int hi ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 230
  old_choice = *choice;
#line 231
  old_scroll = *scrollamt;
#line 232
  wrapped = (_Bool)0;
  {
#line 234
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 235
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 236
      *choice += stepsize;
#line 237
      if (*choice < 0) {
#line 238
        *choice = item_no - 1;
#line 239
        wrapped = (_Bool)1;
      } else
#line 240
      if (*choice >= item_no) {
#line 241
        *choice = 0;
#line 242
        wrapped = (_Bool)1;
      }
#line 235
      if (*choice != old_choice) {
        {
#line 235
        tmp = is_readonly(item + *choice);
        }
#line 235
        if (! tmp) {
#line 235
          goto while_break___0;
        }
      } else {
#line 235
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 246
    if ((item + *choice)->text_flen > 0) {
#line 247
      if ((item + *choice)->name_y < (item + *choice)->text_y) {
#line 247
        tmp___0 = (item + *choice)->name_y;
      } else {
#line 247
        tmp___0 = (item + *choice)->text_y;
      }
#line 247
      lo = tmp___0;
#line 248
      if ((item + *choice)->name_y > (item + *choice)->text_y) {
#line 248
        tmp___1 = (item + *choice)->name_y;
      } else {
#line 248
        tmp___1 = (item + *choice)->text_y;
      }
#line 248
      hi = tmp___1;
#line 250
      if (old_choice == *choice) {
#line 251
        goto while_break;
      }
      {
#line 252
      print_item___1(win, item + old_choice, *scrollamt, (_Bool)0);
      }
#line 254
      if (win) {
#line 254
        tmp___3 = (int )win->_maxy + 1;
      } else {
#line 254
        tmp___3 = -1;
      }
#line 254
      if (*scrollamt < (lo + 1) - tmp___3) {
#line 255
        if (win) {
#line 255
          tmp___2 = (int )win->_maxy + 1;
        } else {
#line 255
          tmp___2 = -1;
        }
#line 255
        *scrollamt = (lo + 1) - tmp___2;
      }
#line 256
      if (*scrollamt > hi) {
#line 257
        *scrollamt = hi;
      }
#line 264
      if (*scrollamt != old_scroll) {
#line 265
        if (wrapped) {
          {
#line 266
          beep();
#line 267
          *scrollamt = old_scroll;
#line 268
          *choice = old_choice;
          }
        } else {
          {
#line 270
          scrollok(win, (_Bool)1);
#line 271
          wscrl(win, *scrollamt - old_scroll);
#line 272
          scrollok(win, (_Bool)0);
          }
        }
      }
#line 275
      goto while_break;
    }
#line 234
    if (! (*choice != old_choice)) {
#line 234
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 279
  if (old_choice != *choice) {
#line 279
    tmp___4 = 1;
  } else
#line 279
  if (old_scroll != *scrollamt) {
#line 279
    tmp___4 = 1;
  } else {
#line 279
    tmp___4 = 0;
  }
#line 279
  return ((_Bool )tmp___4);
}
}
#line 287 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/formbox.c"
static _Bool scroll_next(WINDOW *win , DIALOG_FORMITEM *item , int stepsize , int *choice ,
                         int *scrollamt ) 
{ 
  _Bool result ;
  int old_choice ;
  int old_scroll ;
  int old_row ;
  int tmp ;
  int target ;
  int n ;
  int tmp___0 ;
  int new_row ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 290
  result = (_Bool)1;
#line 291
  old_choice = *choice;
#line 292
  old_scroll = *scrollamt;
#line 293
  if ((item + old_choice)->text_y < (item + old_choice)->name_y) {
#line 293
    tmp = (item + old_choice)->text_y;
  } else {
#line 293
    tmp = (item + old_choice)->name_y;
  }
#line 293
  old_row = tmp;
#line 294
  target = old_scroll + stepsize;
#line 297
  if (stepsize < 0) {
#line 298
    if (old_row != old_scroll) {
#line 299
      target = old_scroll;
    } else {
#line 301
      target = old_scroll + stepsize;
    }
#line 302
    if (target < 0) {
#line 303
      result = (_Bool)0;
    }
  } else {
    {
#line 306
    tmp___0 = form_limit(item);
    }
#line 306
    if (target > tmp___0) {
#line 307
      result = (_Bool)0;
    }
  }
#line 311
  if (result) {
#line 312
    n = 0;
    {
#line 312
    while (1) {
      while_continue: /* CIL Label */ ;
#line 312
      if (! ((unsigned long )(item + n)->name != (unsigned long )((char *)0))) {
#line 312
        goto while_break;
      }
#line 313
      if ((item + n)->text_flen > 0) {
#line 314
        if ((item + n)->text_y < (item + n)->name_y) {
#line 314
          tmp___1 = (item + n)->text_y;
        } else {
#line 314
          tmp___1 = (item + n)->name_y;
        }
        {
#line 314
        new_row = tmp___1;
#line 315
        tmp___2 = abs(new_row - target);
#line 315
        tmp___3 = abs(old_row - target);
        }
#line 315
        if (tmp___2 < tmp___3) {
#line 316
          old_row = new_row;
#line 317
          *choice = n;
        }
      }
#line 312
      n ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 322
    if (old_choice != *choice) {
      {
#line 323
      print_item___1(win, item + old_choice, *scrollamt, (_Bool)0);
      }
    }
#line 325
    *scrollamt = *choice;
#line 326
    if (*scrollamt != old_scroll) {
      {
#line 327
      scrollok(win, (_Bool)1);
#line 328
      wscrl(win, *scrollamt - old_scroll);
#line 329
      scrollok(win, (_Bool)0);
      }
    }
#line 331
    if (old_choice != *choice) {
#line 331
      tmp___4 = 1;
    } else
#line 331
    if (old_scroll != *scrollamt) {
#line 331
      tmp___4 = 1;
    } else {
#line 331
      tmp___4 = 0;
    }
#line 331
    result = (_Bool )tmp___4;
  }
#line 333
  if (! result) {
    {
#line 334
    beep();
    }
  }
#line 335
  return (result);
}
}
#line 341 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/formbox.c"
static int real_length(DIALOG_FORMITEM *item ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 344
  if (item->text_flen > 0) {
#line 344
    tmp___0 = item->text_flen;
  } else {
#line 344
    if (item->text_flen < 0) {
#line 344
      tmp = - item->text_flen;
    } else {
#line 344
      tmp = item->text_len;
    }
#line 344
    tmp___0 = tmp;
  }
#line 344
  return (tmp___0);
}
}
#line 354 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/formbox.c"
static void make_FORM_ELTs(DIALOG_FORMITEM *item , int item_no , int *min_height ,
                           int *min_width ) 
{ 
  int i ;
  int min_w ;
  int min_h ;
  int real_len ;
  int tmp ;
  int max_len ;
  int tmp___0 ;
  int tmp___1 ;
  char *old_text ;
  void *tmp___2 ;

  {
#line 361
  min_w = 0;
#line 362
  min_h = 0;
#line 364
  i = 0;
  {
#line 364
  while (1) {
    while_continue: /* CIL Label */ ;
#line 364
    if (! (i < item_no)) {
#line 364
      goto while_break;
    }
    {
#line 365
    tmp = real_length(item + i);
#line 365
    real_len = tmp;
    }
#line 371
    if ((item + i)->text_ilen == 0) {
#line 372
      (item + i)->text_ilen = real_len;
    }
#line 374
    if (min_h > (item + i)->name_y + 1) {
#line 374
      min_h = min_h;
    } else {
#line 374
      min_h = (item + i)->name_y + 1;
    }
#line 375
    if (min_h > (item + i)->text_y + 1) {
#line 375
      min_h = min_h;
    } else {
#line 375
      min_h = (item + i)->text_y + 1;
    }
#line 376
    if (min_w > ((item + i)->name_x + 1) + (item + i)->name_len) {
#line 376
      min_w = min_w;
    } else {
#line 376
      min_w = ((item + i)->name_x + 1) + (item + i)->name_len;
    }
#line 377
    if (min_w > ((item + i)->text_x + 1) + real_len) {
#line 377
      min_w = min_w;
    } else {
#line 377
      min_w = ((item + i)->text_x + 1) + real_len;
    }
    {
#line 379
    (item + i)->text_len = real_length(item + i);
    }
#line 385
    if ((item + i)->text_flen > 0) {
#line 386
      if ((item + i)->text_ilen + 1 > 2048) {
#line 386
        tmp___0 = (item + i)->text_ilen + 1;
      } else {
#line 386
        tmp___0 = 2048;
      }
      {
#line 386
      tmp___1 = dlg_max_input(tmp___0);
#line 386
      max_len = tmp___1;
#line 387
      old_text = (item + i)->text;
#line 389
      tmp___2 = malloc(((size_t )max_len + 1UL) * sizeof(char ));
#line 389
      (item + i)->text = (char *)tmp___2;
      }
#line 390
      if ((unsigned long )(item + i)->text == (unsigned long )((char *)0)) {
        {
#line 390
        dlg_exiterr("cannot allocate memory in make_FORM_ELTs");
        }
      }
      {
#line 392
      sprintf((char */* __restrict  */)(item + i)->text, (char const   */* __restrict  */)"%.*s",
              (item + i)->text_ilen, old_text);
      }
#line 394
      if ((item + i)->text_free) {
        {
#line 395
        (item + i)->text_free = (_Bool)0;
#line 396
        free((void *)old_text);
        }
      }
#line 398
      (item + i)->text_free = (_Bool)1;
    }
#line 364
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 402
  *min_height = min_h;
#line 403
  *min_width = min_w;
#line 404
  return;
}
}
#line 406 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/formbox.c"
int dlg_default_formitem(DIALOG_FORMITEM *items ) 
{ 
  int result ;
  int count ;
  int tmp ;

  {
#line 409
  result = 0;
#line 411
  if ((unsigned long )dialog_vars.default_item != (unsigned long )((char *)0)) {
#line 412
    count = 0;
    {
#line 413
    while (1) {
      while_continue: /* CIL Label */ ;
#line 413
      if (! ((unsigned long )items->name != (unsigned long )((char *)0))) {
#line 413
        goto while_break;
      }
      {
#line 414
      tmp = strcmp((char const   *)dialog_vars.default_item, (char const   *)items->name);
      }
#line 414
      if (! tmp) {
#line 415
        result = count;
#line 416
        goto while_break;
      }
#line 418
      items ++;
#line 419
      count ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 422
  return (result);
}
}
#line 427 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/formbox.c"
static int next_valid_buttonindex(int state , int extra , _Bool non_editable ) 
{ 


  {
  {
#line 430
  state = dlg_next_ok_buttonindex(state, extra);
  }
  {
#line 431
  while (1) {
    while_continue: /* CIL Label */ ;
#line 431
    if (non_editable) {
#line 431
      if (! (state == -1)) {
#line 431
        goto while_break;
      }
    } else {
#line 431
      goto while_break;
    }
    {
#line 432
    state = dlg_next_ok_buttonindex(state, -1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 433
  return (state);
}
}
#line 436 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/formbox.c"
static int prev_valid_buttonindex(int state , int extra , _Bool non_editable ) 
{ 


  {
  {
#line 439
  state = dlg_prev_ok_buttonindex(state, extra);
  }
  {
#line 440
  while (1) {
    while_continue: /* CIL Label */ ;
#line 440
    if (non_editable) {
#line 440
      if (! (state == -1)) {
#line 440
        goto while_break;
      }
    } else {
#line 440
      goto while_break;
    }
    {
#line 441
    state = dlg_prev_ok_buttonindex(state, -1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 442
  return (state);
}
}
#line 470 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/formbox.c"
static DLG_KEYS_BINDING binding___3[17]  = 
#line 470
  {      {0, 5, 545}, 
        {1, 265, 545}, 
        {1, 363, 545}, 
        {0, '\n', 541}, 
        {0, '\r', 541}, 
        {1, 343, 541}, 
        {0, 9, 528}, 
        {1, 353, 529}, 
        {0, 14, 524}, 
        {1, 258, 524}, 
        {1, 367, 524}, 
        {0, 16, 525}, 
        {1, 370, 525}, 
        {1, 259, 525}, 
        {1, 338, 520}, 
        {1, 339, 521}, 
        {-1, 0, 0}};
#line 476 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/formbox.c"
static DLG_KEYS_BINDING binding2___2[26]  = 
#line 476
  {      {1, 262, 542}, 
        {0, 21, 540}, 
        {0, 8, 538}, 
        {1, 263, 538}, 
        {0, 127, 539}, 
        {1, 330, 539}, 
        {1, 360, 543}, 
        {1, 260, 536}, 
        {1, 261, 537}, 
        {0, 5, 545}, 
        {1, 265, 545}, 
        {1, 363, 545}, 
        {0, '\n', 541}, 
        {0, '\r', 541}, 
        {1, 343, 541}, 
        {0, 9, 528}, 
        {1, 353, 529}, 
        {0, 14, 524}, 
        {1, 258, 524}, 
        {1, 367, 524}, 
        {0, 16, 525}, 
        {1, 370, 525}, 
        {1, 259, 525}, 
        {1, 338, 520}, 
        {1, 339, 521}, 
        {-1, 0, 0}};
#line 459 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/formbox.c"
int dlg_form(char const   *title , char const   *cprompt , int height , int width ,
             int form_height , int item_no , DIALOG_FORMITEM *items , int *current_item ) 
{ 
  int old_height ;
  int old_width ;
  int form_width ;
  int first___0 ;
  int first_trace ;
  int chr_offset ;
  int state ;
  int tmp ;
  int tmp___0 ;
  int x ;
  int y ;
  int cur_x ;
  int cur_y ;
  int box_x ;
  int box_y ;
  int code ;
  int key ;
  int fkey ;
  int choice ;
  int tmp___1 ;
  int new_choice ;
  int new_scroll ;
  int scrollamt ;
  int result ;
  int min_width ;
  int min_height ;
  _Bool was_autosize ;
  int tmp___2 ;
  _Bool show_buttons ;
  _Bool scroll_changed ;
  _Bool field_changed ;
  _Bool non_editable ;
  WINDOW *dialog ;
  WINDOW *form ;
  char *prompt ;
  char *tmp___3 ;
  char const   **buttons ;
  char const   **tmp___4 ;
  DIALOG_FORMITEM *current ;
  int tmp___5 ;
  int tmp___7 ;
  int tmp___8 ;
  int thigh ;
  int twide ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int edit ;
  int tmp___16 ;
  _Bool tmp___17 ;
  WINDOW *tmp___18 ;
  int tmp___19 ;
  _Bool do_scroll ;
  _Bool do_tab ;
  int move_by ;
  int tmp___20 ;
  int tmp___21 ;
  int old_state ;
  int tmp___22 ;
  int tmp___23 ;
  int cell ;
  int row ;
  int tmp___24 ;
  int col ;
  int tmp___25 ;
  int n ;
  _Bool tmp___26 ;
  _Bool tmp___27 ;
  _Bool tmp___28 ;
  _Bool tmp___29 ;
  _Bool tmp___30 ;
  _Bool tmp___31 ;
  _Bool tmp___32 ;

  {
#line 486
  old_height = height;
#line 487
  old_width = width;
#line 491
  first___0 = 1;
#line 492
  first_trace = 1;
#line 493
  chr_offset = 0;
#line 494
  if (dialog_vars.default_button >= 0) {
    {
#line 494
    tmp = dlg_default_button();
#line 494
    tmp___0 = tmp;
    }
  } else {
#line 494
    tmp___0 = -1;
  }
  {
#line 494
  state = tmp___0;
#line 497
  key = 0;
#line 499
  tmp___1 = dlg_default_formitem(items);
#line 499
  choice = tmp___1;
#line 501
  scrollamt = 0;
#line 502
  result = -2;
#line 503
  min_width = 0;
#line 503
  min_height = 0;
  }
#line 504
  if (height == 0) {
#line 504
    tmp___2 = 1;
  } else
#line 504
  if (width == 0) {
#line 504
    tmp___2 = 1;
  } else {
#line 504
    tmp___2 = 0;
  }
  {
#line 504
  was_autosize = (_Bool )tmp___2;
#line 505
  show_buttons = (_Bool)0;
#line 506
  scroll_changed = (_Bool)0;
#line 507
  field_changed = (_Bool)0;
#line 508
  non_editable = (_Bool)0;
#line 510
  tmp___3 = dlg_strclone(cprompt);
#line 510
  prompt = tmp___3;
#line 511
  tmp___4 = dlg_ok_labels();
#line 511
  buttons = tmp___4;
#line 514
  make_FORM_ELTs(items, item_no, & min_height, & min_width);
#line 515
  dlg_button_layout(buttons, & min_width);
#line 516
  dlg_does_output();
#line 517
  dlg_tab_correct_str(prompt);
  }
  retry: 
#line 523
  if (26 > 2 + min_width) {
#line 523
    tmp___5 = 26;
  } else {
#line 523
    tmp___5 = 2 + min_width;
  }
  {
#line 523
  dlg_auto_size(title, (char const   *)prompt, & height, & width, 4, tmp___5);
  }
#line 527
  if (form_height == 0) {
#line 528
    form_height = min_height;
  }
#line 530
  if (was_autosize) {
#line 531
    if (dialog_state.use_shadow) {
#line 531
      tmp___8 = 1;
    } else {
#line 531
      tmp___8 = 0;
    }
#line 531
    if ((LINES - tmp___8) - height < form_height) {
#line 531
      if (dialog_state.use_shadow) {
#line 531
        tmp___7 = 1;
      } else {
#line 531
        tmp___7 = 0;
      }
#line 531
      form_height = (LINES - tmp___7) - height;
    } else {
#line 531
      form_height = form_height;
    }
#line 532
    height += form_height;
  } else {
    {
#line 534
    thigh = 0;
#line 535
    twide = 0;
#line 536
    dlg_auto_size(title, (char const   *)prompt, & thigh, & twide, 0, width);
    }
#line 537
    if (dialog_state.use_shadow) {
#line 537
      tmp___9 = 1;
    } else {
#line 537
      tmp___9 = 0;
    }
#line 537
    thigh = (LINES - tmp___9) - (height - ((thigh + 1) + 3));
#line 538
    if (thigh < form_height) {
#line 538
      form_height = thigh;
    } else {
#line 538
      form_height = form_height;
    }
  }
  {
#line 541
  dlg_print_size(height, width);
#line 542
  dlg_ctl_size(height, width);
#line 544
  x = dlg_box_x_ordinate(width);
#line 545
  y = dlg_box_y_ordinate(height);
#line 547
  dialog = dlg_new_window(height, width, y, x);
#line 548
  dlg_register_window(dialog, "formbox", binding___3);
#line 549
  dlg_register_buttons(dialog, "formbox", buttons);
#line 551
  dlg_mouse_setbase(x, y);
#line 553
  dlg_draw_box2(dialog, 0, 0, height, width, dlg_color_table[2].atr, dlg_color_table[4].atr,
                dlg_color_table[34].atr);
#line 554
  dlg_draw_bottom_box2(dialog, dlg_color_table[4].atr, dlg_color_table[34].atr, dlg_color_table[2].atr);
#line 555
  dlg_draw_title(dialog, title);
  }
#line 557
  if (dialog) {
#line 557
    dialog->_attrs = dlg_color_table[2].atr;
  }
  {
#line 558
  dlg_print_autowrap(dialog, (char const   *)prompt, height, width);
#line 560
  form_width = width - 6;
  }
#line 561
  if (dialog) {
#line 561
    cur_y = (int )dialog->_cury;
  } else {
#line 561
    cur_y = -1;
  }
#line 561
  if (dialog) {
#line 561
    cur_x = (int )dialog->_curx;
  } else {
#line 561
    cur_x = -1;
  }
  {
#line 563
  box_y = cur_y + 1;
#line 564
  box_x = (width - form_width) / 2 - 1;
#line 567
  form = dlg_sub_window(dialog, form_height, form_width, (y + box_y) + 1, (x + box_x) + 1);
#line 569
  dlg_register_window(form, "formfield", binding2___2);
#line 572
  dlg_draw_box(dialog, box_y, box_x, form_height + 2, form_width + 2, dlg_color_table[18].atr,
               dlg_color_table[37].atr);
  }
#line 576
  if (form) {
#line 576
    tmp___10 = (int )form->_maxx + 1;
  } else {
#line 576
    tmp___10 = -1;
  }
#line 576
  if (form) {
#line 576
    tmp___11 = (int )form->_maxy + 1;
  } else {
#line 576
    tmp___11 = -1;
  }
#line 576
  if (form) {
#line 576
    tmp___12 = (int )form->_begx;
  } else {
#line 576
    tmp___12 = -1;
  }
#line 576
  if (dialog) {
#line 576
    tmp___13 = (int )dialog->_begx;
  } else {
#line 576
    tmp___13 = -1;
  }
#line 576
  if (form) {
#line 576
    tmp___14 = (int )form->_begy;
  } else {
#line 576
    tmp___14 = -1;
  }
#line 576
  if (dialog) {
#line 576
    tmp___15 = (int )dialog->_begy;
  } else {
#line 576
    tmp___15 = -1;
  }
  {
#line 576
  dlg_mouse_mkbigregion(tmp___14 - tmp___15, tmp___12 - tmp___13, tmp___11, tmp___10,
                        511, 1, 1, 3);
#line 582
  show_buttons = (_Bool)1;
#line 583
  scroll_changed = (_Bool)1;
#line 585
  choice = set_choice(items, choice, item_no, & non_editable);
#line 586
  current = items + choice;
  }
#line 587
  if (non_editable) {
    {
#line 588
    state = next_valid_buttonindex(state, -1, non_editable);
    }
  }
  {
#line 590
  while (1) {
    while_continue: /* CIL Label */ ;
#line 590
    if (! (result == -2)) {
#line 590
      goto while_break;
    }
#line 591
    edit = 0;
#line 593
    if (scroll_changed) {
      {
#line 594
      print_form(form, items, item_no, scrollamt, choice);
#line 595
      dlg_draw_scrollbar(dialog, (long )scrollamt, (long )scrollamt, (long )((scrollamt + form_height) + 1),
                         (long )min_height, box_x + 1, box_x + form_width, box_y,
                         (box_y + form_height) + 1, dlg_color_table[37].atr, dlg_color_table[18].atr);
#line 606
      scroll_changed = (_Bool)0;
      }
    }
#line 609
    if (show_buttons) {
      {
#line 610
      dlg_item_help("");
      }
#line 611
      if (state < 0) {
#line 611
        tmp___16 = 1000;
      } else {
#line 611
        tmp___16 = state;
      }
      {
#line 611
      dlg_draw_buttons(dialog, height - 2, 0, buttons, tmp___16, 0, width);
#line 616
      show_buttons = (_Bool)0;
      }
    }
#line 619
    if (first_trace) {
      {
#line 620
      first_trace = 0;
#line 621
      dlg_trace_win(dialog);
      }
    }
#line 624
    if (field_changed) {
#line 624
      goto _L;
    } else
#line 624
    if (state == -1) {
      _L: /* CIL Label */ 
#line 625
      if (field_changed) {
#line 626
        chr_offset = 0;
      }
      {
#line 627
      current = items + choice;
#line 628
      dialog_vars.max_input = current->text_ilen;
#line 629
      dlg_item_help((char const   *)current->help);
#line 630
      tmp___17 = is_hidden(current);
#line 630
      dlg_show_string(form, (char const   *)current->text, chr_offset, dlg_color_table[30].atr,
                      current->text_y - scrollamt, current->text_x, current->text_len,
                      tmp___17, (_Bool )first___0);
#line 636
      wsyncup(form);
#line 637
      wcursyncup(form);
#line 638
      field_changed = (_Bool)0;
      }
    }
#line 641
    if (state == -1) {
#line 641
      tmp___18 = form;
    } else {
#line 641
      tmp___18 = dialog;
    }
    {
#line 641
    key = dlg_mouse_wgetch(tmp___18, & fkey);
#line 642
    tmp___19 = dlg_result_key(key, fkey, & result);
    }
#line 642
    if (tmp___19) {
#line 643
      goto while_break;
    }
#line 646
    if (! fkey) {
#line 647
      if (state != -1) {
        {
#line 648
        code = dlg_char_to_button(key, buttons);
        }
#line 649
        if (code >= 0) {
          {
#line 650
          dlg_del_window(dialog);
#line 651
          result = dlg_ok_buttoncode(code);
          }
#line 652
          goto while_continue;
        }
#line 654
        if (key == 32) {
#line 655
          fkey = 1;
#line 656
          key = 541;
        }
      }
    }
#line 662
    if (fkey) {
#line 663
      do_scroll = (_Bool)0;
#line 664
      do_tab = (_Bool)0;
#line 665
      move_by = 0;
      {
#line 669
      if (key == 521) {
#line 669
        goto case_521;
      }
#line 669
      if (key == 1107) {
#line 669
        goto case_521;
      }
#line 675
      if (key == 520) {
#line 675
        goto case_520;
      }
#line 675
      if (key == 1106) {
#line 675
        goto case_520;
      }
#line 680
      if (key == 541) {
#line 680
        goto case_541;
      }
#line 685
      if (key == 536) {
#line 685
        goto case_536;
      }
#line 689
      if (key == 525) {
#line 689
        goto case_525;
      }
#line 700
      if (key == 533) {
#line 700
        goto case_533;
      }
#line 719
      if (key == 529) {
#line 719
        goto case_529;
      }
#line 724
      if (key == 528) {
#line 724
        goto case_528;
      }
#line 729
      if (key == 537) {
#line 729
        goto case_537;
      }
#line 734
      if (key == 524) {
#line 734
        goto case_524;
      }
#line 745
      if (key == 532) {
#line 745
        goto case_532;
      }
#line 761
      if (key == 410) {
#line 761
        goto case_410;
      }
#line 772
      goto switch_default;
      case_521: /* CIL Label */ 
      case_1107: /* CIL Label */ 
#line 670
      do_scroll = (_Bool)1;
#line 671
      move_by = - form_height;
#line 672
      goto switch_break;
      case_520: /* CIL Label */ 
      case_1106: /* CIL Label */ 
#line 676
      do_scroll = (_Bool)1;
#line 677
      move_by = form_height;
#line 678
      goto switch_break;
      case_541: /* CIL Label */ 
      {
#line 681
      dlg_del_window(dialog);
      }
#line 682
      if (state >= 0) {
#line 682
        if (dialog_vars.nook) {
#line 682
          tmp___21 = 0;
        } else {
          {
#line 682
          tmp___20 = dlg_ok_buttoncode(state);
#line 682
          tmp___21 = tmp___20;
          }
        }
#line 682
        result = tmp___21;
      } else {
#line 682
        result = 0;
      }
#line 683
      goto while_continue;
      case_536: /* CIL Label */ 
#line 686
      if (state == -1) {
#line 687
        goto switch_break;
      }
      case_525: /* CIL Label */ 
#line 690
      if (state == -1) {
#line 691
        do_tab = (_Bool)1;
#line 692
        move_by = -1;
#line 693
        goto switch_break;
      } else {
        {
#line 695
        state = prev_valid_buttonindex(state, 0, non_editable);
#line 696
        show_buttons = (_Bool)1;
        }
#line 697
        goto while_continue;
      }
      case_533: /* CIL Label */ 
#line 701
      if (state == -1) {
        {
#line 701
        tmp___22 = is_first_field(items, choice);
        }
#line 701
        if (tmp___22) {
#line 701
          goto _L___0;
        } else {
#line 702
          do_tab = (_Bool)1;
#line 703
          move_by = -1;
#line 704
          goto switch_break;
        }
      } else {
        _L___0: /* CIL Label */ 
        {
#line 706
        old_state = state;
#line 707
        state = prev_valid_buttonindex(state, -1, non_editable);
#line 708
        show_buttons = (_Bool)1;
        }
#line 709
        if (old_state >= 0) {
#line 709
          if (state == -1) {
#line 710
            new_choice = item_no - 1;
#line 711
            if (choice != new_choice) {
              {
#line 712
              print_item___1(form, items + choice, scrollamt, (_Bool)0);
#line 713
              choice = new_choice;
              }
            }
          }
        }
#line 716
        goto while_continue;
      }
      case_529: /* CIL Label */ 
      {
#line 720
      state = prev_valid_buttonindex(state, -1, non_editable);
#line 721
      show_buttons = (_Bool)1;
      }
#line 722
      goto while_continue;
      case_528: /* CIL Label */ 
      {
#line 725
      state = next_valid_buttonindex(state, -1, non_editable);
#line 726
      show_buttons = (_Bool)1;
      }
#line 727
      goto while_continue;
      case_537: /* CIL Label */ 
#line 730
      if (state == -1) {
#line 731
        goto switch_break;
      }
      case_524: /* CIL Label */ 
#line 735
      if (state == -1) {
#line 736
        do_tab = (_Bool)1;
#line 737
        move_by = 1;
#line 738
        goto switch_break;
      } else {
        {
#line 740
        state = next_valid_buttonindex(state, 0, non_editable);
#line 741
        show_buttons = (_Bool)1;
        }
#line 742
        goto while_continue;
      }
      case_532: /* CIL Label */ 
#line 746
      if (state == -1) {
        {
#line 746
        tmp___23 = is_last_field(items, choice, item_no);
        }
#line 746
        if (tmp___23) {
#line 746
          goto _L___1;
        } else {
#line 747
          do_tab = (_Bool)1;
#line 748
          move_by = 1;
#line 749
          goto switch_break;
        }
      } else {
        _L___1: /* CIL Label */ 
        {
#line 751
        state = next_valid_buttonindex(state, -1, non_editable);
#line 752
        show_buttons = (_Bool)1;
        }
#line 753
        if (state == -1) {
#line 753
          if (choice) {
            {
#line 754
            print_item___1(form, items + choice, scrollamt, (_Bool)0);
#line 755
            choice = 0;
            }
          }
        }
#line 757
        goto while_continue;
      }
      case_410: /* CIL Label */ 
      {
#line 763
      height = old_height;
#line 764
      width = old_width;
#line 766
      dlg_clear();
#line 767
      dlg_del_window(dialog);
#line 768
      wrefresh(stdscr);
#line 769
      dlg_mouse_free_regions();
      }
#line 770
      goto retry;
      switch_default: /* CIL Label */ 
#line 774
      if (key >= 768) {
#line 775
        if (key >= 1279) {
#line 776
          cell = key - 1279;
#line 777
          if (form) {
#line 777
            tmp___24 = (int )form->_maxx + 1;
          } else {
#line 777
            tmp___24 = -1;
          }
#line 777
          row = cell / tmp___24 + scrollamt;
#line 778
          if (form) {
#line 778
            tmp___25 = (int )form->_maxx + 1;
          } else {
#line 778
            tmp___25 = -1;
          }
#line 778
          col = cell % tmp___25;
#line 781
          n = 0;
          {
#line 781
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 781
            if (! (n < item_no)) {
#line 781
              goto while_break___0;
            }
#line 782
            if ((items + n)->name_y == row) {
#line 782
              if ((items + n)->name_x <= col) {
#line 782
                if ((items + n)->name_x + (items + n)->name_len > col) {
#line 782
                  goto _L___2;
                } else
#line 782
                if ((items + n)->name_y == (items + n)->text_y) {
#line 782
                  if ((items + n)->text_x > col) {
                    _L___2: /* CIL Label */ 
                    {
#line 787
                    tmp___26 = is_readonly(items + n);
                    }
#line 787
                    if (! tmp___26) {
#line 788
                      field_changed = (_Bool)1;
#line 789
                      goto while_break___0;
                    }
                  }
                }
              }
            }
#line 792
            if ((items + n)->text_y == row) {
#line 792
              if ((items + n)->text_x <= col) {
#line 792
                if ((items + n)->text_x + (items + n)->text_ilen > col) {
                  {
#line 795
                  tmp___27 = is_readonly(items + n);
                  }
#line 795
                  if (! tmp___27) {
#line 796
                    field_changed = (_Bool)1;
#line 797
                    goto while_break___0;
                  }
                }
              }
            }
#line 781
            n ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 801
          if (field_changed) {
            {
#line 802
            print_item___1(form, items + choice, scrollamt, (_Bool)0);
#line 803
            choice = n;
            }
#line 804
            goto while_continue;
          }
          {
#line 806
          beep();
          }
        } else {
          {
#line 807
          code = dlg_ok_buttoncode(key - 768);
          }
#line 807
          if (code >= 0) {
#line 808
            result = code;
          }
        }
#line 810
        goto while_continue;
      }
#line 813
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 816
      new_scroll = scrollamt;
#line 817
      new_choice = choice;
#line 818
      if (do_scroll) {
        {
#line 819
        tmp___28 = scroll_next(form, items, move_by, & new_choice, & new_scroll);
        }
#line 819
        if (tmp___28) {
#line 820
          if (choice != new_choice) {
#line 821
            choice = new_choice;
#line 822
            field_changed = (_Bool)1;
          }
#line 824
          if (scrollamt != new_scroll) {
#line 825
            scrollamt = new_scroll;
#line 826
            scroll_changed = (_Bool)1;
          }
        }
#line 829
        goto while_continue;
      }
#line 831
      if (do_tab) {
        {
#line 832
        tmp___29 = tab_next(form, items, item_no, move_by, & new_choice, & new_scroll);
        }
#line 832
        if (tmp___29) {
#line 833
          if (choice != new_choice) {
#line 834
            choice = new_choice;
#line 835
            field_changed = (_Bool)1;
          }
#line 837
          if (scrollamt != new_scroll) {
#line 838
            scrollamt = new_scroll;
#line 839
            scroll_changed = (_Bool)1;
          }
        }
#line 842
        goto while_continue;
      }
    }
#line 846
    if (state == -1) {
      {
#line 847
      tmp___31 = is_readonly(current);
      }
#line 847
      if (! tmp___31) {
        {
#line 848
        tmp___30 = dlg_edit_string(current->text, & chr_offset, key, fkey, (_Bool )first___0);
#line 848
        edit = (int )tmp___30;
        }
      }
#line 850
      if (edit) {
        {
#line 851
        tmp___32 = is_hidden(current);
#line 851
        dlg_show_string(form, (char const   *)current->text, chr_offset, dlg_color_table[30].atr,
                        current->text_y - scrollamt, current->text_x, current->text_len,
                        tmp___32, (_Bool )first___0);
        }
#line 857
        goto while_continue;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 863
  dlg_mouse_free_regions();
#line 864
  dlg_del_window(dialog);
#line 865
  free((void *)prompt);
#line 867
  *current_item = choice;
  }
#line 868
  return (result);
}
}
#line 874 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/formbox.c"
void dlg_free_formitems(DIALOG_FORMITEM *items ) 
{ 
  int n ;
  char *tmp ;

  {
#line 878
  n = 0;
  {
#line 878
  while (1) {
    while_continue: /* CIL Label */ ;
#line 878
    if (! ((unsigned long )(items + n)->name != (unsigned long )((char *)0))) {
#line 878
      goto while_break;
    }
#line 879
    if ((items + n)->name_free) {
      {
#line 880
      free((void *)(items + n)->name);
      }
    }
#line 881
    if ((items + n)->text_free) {
      {
#line 882
      free((void *)(items + n)->text);
      }
    }
#line 883
    if ((items + n)->help_free) {
      {
#line 883
      tmp = dlg_strempty();
      }
#line 883
      if ((unsigned long )(items + n)->help != (unsigned long )tmp) {
        {
#line 884
        free((void *)(items + n)->help);
        }
      }
    }
#line 878
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 886
  free((void *)items);
  }
#line 887
  return;
}
}
#line 892 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/formbox.c"
int dlg_ordinate(char const   *s ) 
{ 
  int result ;
  int tmp ;

  {
  {
#line 895
  tmp = atoi(s);
#line 895
  result = tmp;
  }
#line 896
  if (result > 0) {
#line 897
    result --;
  } else {
#line 899
    result = 0;
  }
#line 900
  return (result);
}
}
#line 903 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/formbox.c"
int dialog_form(char const   *title , char const   *cprompt , int height , int width ,
                int form_height , int item_no , char **items ) 
{ 
  int result ;
  int choice ;
  int i ;
  DIALOG_FORMITEM *listitems ;
  DIALOG_VARS save_vars ;
  _Bool show_status ;
  char *help_result ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;

  {
  {
#line 917
  show_status = (_Bool)0;
#line 920
  dlg_save_vars(& save_vars);
#line 921
  dialog_vars.separate_output = (_Bool)1;
#line 923
  tmp = calloc((size_t )item_no + 1UL, sizeof(DIALOG_FORMITEM ));
#line 923
  listitems = (DIALOG_FORMITEM *)tmp;
  }
#line 924
  if ((unsigned long )listitems == (unsigned long )((DIALOG_FORMITEM *)0)) {
    {
#line 924
    dlg_exiterr("cannot allocate memory in dialog_form");
    }
  }
#line 926
  i = 0;
  {
#line 926
  while (1) {
    while_continue: /* CIL Label */ ;
#line 926
    if (! (i < item_no)) {
#line 926
      goto while_break;
    }
#line 927
    (listitems + i)->type = dialog_vars.formitem_type;
#line 928
    if (dialog_vars.item_help) {
#line 928
      tmp___0 = 1;
    } else {
#line 928
      tmp___0 = 0;
    }
#line 928
    (listitems + i)->name = *(items + i * (8 + tmp___0));
#line 929
    if (dialog_vars.item_help) {
#line 929
      tmp___1 = 1;
    } else {
#line 929
      tmp___1 = 0;
    }
    {
#line 929
    tmp___2 = strlen((char const   *)*(items + i * (8 + tmp___1)));
#line 929
    (listitems + i)->name_len = (int )tmp___2;
    }
#line 930
    if (dialog_vars.item_help) {
#line 930
      tmp___3 = 1;
    } else {
#line 930
      tmp___3 = 0;
    }
    {
#line 930
    (listitems + i)->name_y = dlg_ordinate((char const   *)*(items + (i * (8 + tmp___3) + 1)));
    }
#line 931
    if (dialog_vars.item_help) {
#line 931
      tmp___4 = 1;
    } else {
#line 931
      tmp___4 = 0;
    }
    {
#line 931
    (listitems + i)->name_x = dlg_ordinate((char const   *)*(items + (i * (8 + tmp___4) + 2)));
    }
#line 932
    if (dialog_vars.item_help) {
#line 932
      tmp___5 = 1;
    } else {
#line 932
      tmp___5 = 0;
    }
#line 932
    (listitems + i)->text = *(items + (i * (8 + tmp___5) + 3));
#line 933
    if (dialog_vars.item_help) {
#line 933
      tmp___6 = 1;
    } else {
#line 933
      tmp___6 = 0;
    }
    {
#line 933
    tmp___7 = strlen((char const   *)*(items + (i * (8 + tmp___6) + 3)));
#line 933
    (listitems + i)->text_len = (int )tmp___7;
    }
#line 934
    if (dialog_vars.item_help) {
#line 934
      tmp___8 = 1;
    } else {
#line 934
      tmp___8 = 0;
    }
    {
#line 934
    (listitems + i)->text_y = dlg_ordinate((char const   *)*(items + (i * (8 + tmp___8) + 4)));
    }
#line 935
    if (dialog_vars.item_help) {
#line 935
      tmp___9 = 1;
    } else {
#line 935
      tmp___9 = 0;
    }
    {
#line 935
    (listitems + i)->text_x = dlg_ordinate((char const   *)*(items + (i * (8 + tmp___9) + 5)));
    }
#line 936
    if (dialog_vars.item_help) {
#line 936
      tmp___10 = 1;
    } else {
#line 936
      tmp___10 = 0;
    }
    {
#line 936
    (listitems + i)->text_flen = atoi((char const   *)*(items + (i * (8 + tmp___10) + 6)));
    }
#line 937
    if (dialog_vars.item_help) {
#line 937
      tmp___11 = 1;
    } else {
#line 937
      tmp___11 = 0;
    }
    {
#line 937
    (listitems + i)->text_ilen = atoi((char const   *)*(items + (i * (8 + tmp___11) + 7)));
    }
#line 938
    if (dialog_vars.item_help) {
#line 938
      if (dialog_vars.item_help) {
#line 938
        if (dialog_vars.item_help) {
#line 938
          tmp___12 = 1;
        } else {
#line 938
          tmp___12 = 0;
        }
#line 938
        tmp___14 = *(items + (i * (8 + tmp___12) + 8));
      } else {
        {
#line 938
        tmp___13 = dlg_strempty();
#line 938
        tmp___14 = tmp___13;
        }
      }
#line 938
      (listitems + i)->help = tmp___14;
    } else {
      {
#line 938
      tmp___15 = dlg_strempty();
#line 938
      (listitems + i)->help = tmp___15;
      }
    }
#line 926
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 943
  result = dlg_form(title, cprompt, height, width, form_height, item_no, listitems,
                    & choice);
  }
  {
#line 954
  if (result == 3) {
#line 954
    goto case_3;
  }
#line 954
  if (result == 0) {
#line 954
    goto case_3;
  }
#line 957
  if (result == 2) {
#line 957
    goto case_2;
  }
#line 952
  goto switch_break;
  case_3: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 955
  show_status = (_Bool)1;
#line 956
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 958
  dlg_add_help_formitem(& result, & help_result, listitems + choice);
#line 959
  show_status = dialog_vars.help_status;
#line 960
  dlg_add_string(help_result);
  }
#line 961
  if (show_status) {
    {
#line 962
    dlg_add_separator();
    }
  }
#line 963
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 965
  if (show_status) {
#line 966
    i = 0;
    {
#line 966
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 966
      if (! (i < item_no)) {
#line 966
        goto while_break___0;
      }
#line 967
      if ((listitems + i)->text_flen > 0) {
        {
#line 968
        dlg_add_string((listitems + i)->text);
#line 969
        dlg_add_separator();
        }
      }
#line 966
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 972
    dlg_add_last_key(-1);
    }
  }
  {
#line 975
  dlg_free_formitems(listitems);
#line 976
  dlg_restore_vars(& save_vars);
  }
#line 978
  return (result);
}
}
#line 765 "/usr/include/stdlib.h"
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 605 "/usr/include/curses.h"
extern WINDOW *derwin(WINDOW * , int  , int  , int  , int  ) ;
#line 591 "./dialog.h"
int dialog_dselect(char const   *title , char const   *path , int height , int width ) ;
#line 594
int dialog_fselect(char const   *title , char const   *path , int height , int width ) ;
#line 788
extern void dlg_set_focus(WINDOW * , WINDOW * ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 89 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/fselect.c"
static void init_list(LIST *list , WINDOW *par , WINDOW *win , int mousex ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 92
  list->par = par;
#line 93
  list->win = win;
#line 94
  list->length = 0;
#line 95
  list->offset = 0;
#line 96
  list->choice = 0;
#line 97
  list->mousex = mousex;
#line 98
  list->allocd = 0U;
#line 99
  list->data = (char **)0;
#line 100
  if (win) {
#line 100
    tmp = (int )win->_maxx + 1;
  } else {
#line 100
    tmp = -1;
  }
#line 100
  if (win) {
#line 100
    tmp___0 = (int )win->_maxy + 1;
  } else {
#line 100
    tmp___0 = -1;
  }
#line 100
  if (win) {
#line 100
    tmp___1 = (int )win->_begx;
  } else {
#line 100
    tmp___1 = -1;
  }
#line 100
  if (win) {
#line 100
    tmp___2 = (int )win->_begy;
  } else {
#line 100
    tmp___2 = -1;
  }
  {
#line 100
  dlg_mouse_mkbigregion(tmp___2, tmp___1, tmp___0, tmp, mousex, 1, 1, 1);
  }
#line 103
  return;
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/fselect.c"
static char *leaf_of(char *path ) 
{ 
  char *leaf ;
  char *tmp ;

  {
  {
#line 108
  tmp = strrchr((char const   *)path, '/');
#line 108
  leaf = tmp;
  }
#line 109
  if ((unsigned long )leaf != (unsigned long )((char *)0)) {
#line 110
    leaf ++;
  } else {
#line 112
    leaf = path;
  }
#line 113
  return (leaf);
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/fselect.c"
static char *data_of(LIST *list ) 
{ 


  {
#line 119
  if ((unsigned long )list != (unsigned long )((LIST *)0)) {
#line 119
    if ((unsigned long )list->data != (unsigned long )((char **)0)) {
#line 121
      return (*(list->data + list->choice));
    }
  }
#line 122
  return ((char *)0);
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/fselect.c"
static void free_list___0(LIST *list , int reinit ) 
{ 
  int n ;

  {
#line 130
  if ((unsigned long )list->data != (unsigned long )((char **)0)) {
#line 131
    n = 0;
    {
#line 131
    while (1) {
      while_continue: /* CIL Label */ ;
#line 131
      if (! ((unsigned long )*(list->data + n) != (unsigned long )((char *)0))) {
#line 131
        goto while_break;
      }
      {
#line 132
      free((void *)*(list->data + n));
#line 131
      n ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 133
    free((void *)list->data);
#line 134
    list->data = (char **)0;
    }
  }
#line 136
  if (reinit) {
    {
#line 137
    init_list(list, list->par, list->win, list->mousex);
    }
  }
#line 138
  return;
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/fselect.c"
static void add_to_list(LIST *list , char *text ) 
{ 
  unsigned int need ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 145
  need = (unsigned int )(list->length + 1);
#line 146
  if (need + 1U > list->allocd) {
#line 147
    list->allocd = 2U * (need + 1U);
#line 148
    if ((unsigned long )list->data == (unsigned long )((char **)0)) {
      {
#line 149
      tmp = malloc((size_t )list->allocd * sizeof(char *));
#line 149
      list->data = (char **)tmp;
      }
    } else {
      {
#line 151
      tmp___0 = realloc((void *)list->data, (unsigned long )list->allocd * sizeof(char *));
#line 151
      list->data = (char **)tmp___0;
      }
    }
#line 153
    if ((unsigned long )list->data == (unsigned long )((char **)0)) {
      {
#line 153
      dlg_exiterr("cannot allocate memory in add_to_list");
      }
    }
  }
  {
#line 155
  tmp___1 = list->length;
#line 155
  (list->length) ++;
#line 155
  *(list->data + tmp___1) = dlg_strclone((char const   *)text);
#line 156
  *(list->data + list->length) = (char *)0;
  }
#line 157
  return;
}
}
#line 159 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/fselect.c"
static void keep_visible(LIST *list ) 
{ 
  int high ;
  int tmp ;

  {
#line 162
  if (list->win) {
#line 162
    tmp = (int )(list->win)->_maxy + 1;
  } else {
#line 162
    tmp = -1;
  }
#line 162
  high = tmp;
#line 164
  if (list->choice < list->offset) {
#line 165
    list->offset = list->choice;
  }
#line 167
  if (list->choice - list->offset >= high) {
#line 168
    list->offset = (list->choice - high) + 1;
  }
#line 169
  return;
}
}
#line 173 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/fselect.c"
static int find_choice(char *target , LIST *list ) 
{ 
  int n ;
  int choice ;
  int len_1 ;
  int len_2 ;
  int cmp_1 ;
  int cmp_2 ;
  char *a ;
  char *b ;

  {
#line 177
  choice = list->choice;
#line 180
  if ((int )*target == 0) {
#line 181
    list->choice = 0;
  } else {
#line 187
    len_1 = 0;
#line 188
    cmp_1 = 256;
#line 189
    n = 0;
    {
#line 189
    while (1) {
      while_continue: /* CIL Label */ ;
#line 189
      if (! (n < list->length)) {
#line 189
        goto while_break;
      }
#line 190
      a = target;
#line 191
      b = *(list->data + n);
#line 193
      len_2 = 0;
      {
#line 194
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 194
        if ((int )*a != 0) {
#line 194
          if ((int )*b != 0) {
#line 194
            if (! ((int )*a == (int )*b)) {
#line 194
              goto while_break___0;
            }
          } else {
#line 194
            goto while_break___0;
          }
        } else {
#line 194
          goto while_break___0;
        }
#line 195
        a ++;
#line 196
        b ++;
#line 197
        len_2 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 199
      cmp_2 = ((int )*a & 255) - ((int )*b & 255);
#line 200
      if (cmp_2 < 0) {
#line 201
        cmp_2 = - cmp_2;
      }
#line 202
      if (len_2 > len_1) {
#line 204
        len_1 = len_2;
#line 205
        cmp_1 = cmp_2;
#line 206
        list->choice = n;
      } else
#line 202
      if (len_1 == len_2) {
#line 202
        if (cmp_2 < cmp_1) {
#line 204
          len_1 = len_2;
#line 205
          cmp_1 = cmp_2;
#line 206
          list->choice = n;
        }
      }
#line 189
      n ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 210
  if (choice != list->choice) {
    {
#line 211
    keep_visible(list);
    }
  }
#line 213
  return (choice != list->choice);
}
}
#line 216 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/fselect.c"
static void display_list(LIST *list ) 
{ 
  int n ;
  int x ;
  int y ;
  int top ;
  int bottom ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 225
  if ((unsigned long )list->win != (unsigned long )((WINDOW *)0)) {
#line 226
    if (list->win) {
#line 226
      tmp = (int )(list->win)->_maxx + 1;
    } else {
#line 226
      tmp = -1;
    }
#line 226
    if (list->win) {
#line 226
      tmp___0 = (int )(list->win)->_maxy + 1;
    } else {
#line 226
      tmp___0 = -1;
    }
    {
#line 226
    dlg_attr_clear(list->win, tmp___0, tmp, dlg_color_table[19].atr);
#line 227
    n = list->offset;
    }
    {
#line 227
    while (1) {
      while_continue: /* CIL Label */ ;
#line 227
      if (n < list->length) {
#line 227
        if (! *(list->data + n)) {
#line 227
          goto while_break;
        }
      } else {
#line 227
        goto while_break;
      }
#line 228
      y = n - list->offset;
#line 229
      if (list->win) {
#line 229
        tmp___1 = (int )(list->win)->_maxy + 1;
      } else {
#line 229
        tmp___1 = -1;
      }
#line 229
      if (y >= tmp___1) {
#line 230
        goto while_break;
      }
      {
#line 231
      wmove(list->win, y, 0);
      }
#line 232
      if (n == list->choice) {
#line 233
        if (list->win) {
#line 233
          (list->win)->_attrs = dlg_color_table[20].atr;
        }
      }
      {
#line 234
      waddnstr(list->win, (char const   *)*(list->data + n), -1);
      }
#line 235
      if (list->win) {
#line 235
        (list->win)->_attrs = dlg_color_table[19].atr;
      }
#line 227
      n ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 237
    if (list->win) {
#line 237
      (list->win)->_attrs = dlg_color_table[19].atr;
    }
#line 239
    if (list->win) {
#line 239
      y = (list->win)->_pary;
    } else {
#line 239
      y = -1;
    }
#line 239
    if (list->win) {
#line 239
      x = (list->win)->_parx;
    } else {
#line 239
      x = -1;
    }
#line 241
    top = y - 1;
#line 242
    if (list->win) {
#line 242
      tmp___2 = (int )(list->win)->_maxy + 1;
    } else {
#line 242
      tmp___2 = -1;
    }
#line 242
    bottom = y + tmp___2;
#line 243
    if (list->win) {
#line 243
      tmp___3 = (int )(list->win)->_maxx + 1;
    } else {
#line 243
      tmp___3 = -1;
    }
#line 243
    if (list->win) {
#line 243
      tmp___4 = (int )(list->win)->_maxy + 1;
    } else {
#line 243
      tmp___4 = -1;
    }
    {
#line 243
    dlg_draw_scrollbar(list->par, (long )list->offset, (long )list->offset, (long )(list->offset + tmp___4),
                       (long )list->length, x + 1, x + tmp___3, top, bottom, dlg_color_table[37].atr,
                       dlg_color_table[18].atr);
#line 255
    wmove(list->win, list->choice - list->offset, 0);
#line 256
    wnoutrefresh(list->win);
    }
  }
#line 258
  return;
}
}
#line 267 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/fselect.c"
static void fix_arrows(LIST *list ) 
{ 
  int x ;
  int y ;
  int top ;
  int right ;
  int bottom ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 276
  if ((unsigned long )list->win != (unsigned long )((WINDOW *)0)) {
#line 277
    if (list->win) {
#line 277
      y = (list->win)->_pary;
    } else {
#line 277
      y = -1;
    }
#line 277
    if (list->win) {
#line 277
      x = (list->win)->_parx;
    } else {
#line 277
      x = -1;
    }
#line 278
    top = y - 1;
#line 279
    if (list->win) {
#line 279
      right = (int )(list->win)->_maxx + 1;
    } else {
#line 279
      right = -1;
    }
#line 280
    if (list->win) {
#line 280
      tmp = (int )(list->win)->_maxy + 1;
    } else {
#line 280
      tmp = -1;
    }
#line 280
    bottom = y + tmp;
#line 282
    if (list->mousex == 511) {
#line 282
      tmp___0 = 370;
    } else {
#line 282
      tmp___0 = 339;
    }
    {
#line 282
    dlg_mouse_mkregion(top, x, 1, right, tmp___0);
    }
#line 286
    if (list->mousex == 511) {
#line 286
      tmp___1 = 367;
    } else {
#line 286
      tmp___1 = 338;
    }
    {
#line 286
    dlg_mouse_mkregion(bottom, x, 1, right, tmp___1);
    }
  }
#line 291
  return;
}
}
#line 293 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/fselect.c"
static int show_list(char *target , LIST *list , int keep ) 
{ 
  int changed ;
  int tmp ;
  int tmp___0 ;

  {
#line 296
  if (keep) {
#line 296
    tmp___0 = 1;
  } else {
    {
#line 296
    tmp = find_choice(target, list);
    }
#line 296
    if (tmp) {
#line 296
      tmp___0 = 1;
    } else {
#line 296
      tmp___0 = 0;
    }
  }
  {
#line 296
  changed = tmp___0;
#line 297
  display_list(list);
  }
#line 298
  return (changed);
}
}
#line 305 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/fselect.c"
static int show_both_lists(char *input , LIST *d_list , LIST *f_list , int keep ) 
{ 
  char *leaf ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 308
  tmp = leaf_of(input);
#line 308
  leaf = tmp;
#line 310
  tmp___0 = show_list(leaf, d_list, keep);
#line 310
  tmp___1 = show_list(leaf, f_list, keep);
  }
#line 310
  return (tmp___0 | tmp___1);
}
}
#line 316 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/fselect.c"
static _Bool change_list(int choice , LIST *list ) 
{ 
  int last ;
  char *tmp ;

  {
  {
#line 319
  tmp = data_of(list);
  }
#line 319
  if ((unsigned long )tmp != (unsigned long )((char *)0)) {
#line 320
    last = list->length - 1;
#line 322
    choice += list->choice;
#line 323
    if (choice < 0) {
#line 324
      choice = 0;
    }
#line 325
    if (choice > last) {
#line 326
      choice = last;
    }
    {
#line 327
    list->choice = choice;
#line 328
    keep_visible(list);
#line 329
    display_list(list);
    }
#line 330
    return ((_Bool)1);
  }
#line 332
  return ((_Bool)0);
}
}
#line 335 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/fselect.c"
static void scroll_list(int direction , LIST *list ) 
{ 
  int length ;
  int tmp ;
  _Bool tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 338
  tmp___1 = data_of(list);
  }
#line 338
  if ((unsigned long )tmp___1 != (unsigned long )((char *)0)) {
#line 339
    if (list->win) {
#line 339
      tmp = (int )(list->win)->_maxy + 1;
    } else {
#line 339
      tmp = -1;
    }
    {
#line 339
    length = tmp;
#line 340
    tmp___0 = change_list(direction * length, list);
    }
#line 340
    if (tmp___0) {
#line 341
      return;
    }
  }
  {
#line 343
  beep();
  }
#line 344
  return;
}
}
#line 346 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/fselect.c"
static int compar(void const   *a , void const   *b ) 
{ 
  int tmp ;

  {
  {
#line 349
  tmp = strcmp((char const   *)*((char const   * const  *)a), (char const   *)*((char const   * const  *)b));
  }
#line 349
  return (tmp);
}
}
#line 352 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/fselect.c"
static void match(char *name , LIST *d_list , LIST *f_list , MATCH *match_list ) 
{ 
  char *test ;
  char *tmp ;
  size_t test_len ;
  size_t tmp___0 ;
  char **matches ;
  void *tmp___1 ;
  size_t data_len ;
  int i ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;

  {
  {
#line 355
  tmp = leaf_of(name);
#line 355
  test = tmp;
#line 356
  tmp___0 = strlen((char const   *)test);
#line 356
  test_len = tmp___0;
#line 357
  tmp___1 = malloc((size_t )(d_list->length + f_list->length) * sizeof(char *));
#line 357
  matches = (char **)tmp___1;
#line 358
  data_len = (size_t )0;
#line 360
  i = 2;
  }
  {
#line 360
  while (1) {
    while_continue: /* CIL Label */ ;
#line 360
    if (! (i < d_list->length)) {
#line 360
      goto while_break;
    }
    {
#line 361
    tmp___3 = strncmp((char const   *)test, (char const   *)*(d_list->data + i), test_len);
    }
#line 361
    if (tmp___3 == 0) {
#line 362
      tmp___2 = data_len;
#line 362
      data_len ++;
#line 362
      *(matches + tmp___2) = *(d_list->data + i);
    }
#line 360
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 365
  i = 0;
  {
#line 365
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 365
    if (! (i < f_list->length)) {
#line 365
      goto while_break___0;
    }
    {
#line 366
    tmp___5 = strncmp((char const   *)test, (char const   *)*(f_list->data + i), test_len);
    }
#line 366
    if (tmp___5 == 0) {
#line 367
      tmp___4 = data_len;
#line 367
      data_len ++;
#line 367
      *(matches + tmp___4) = *(f_list->data + i);
    }
#line 365
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 370
  tmp___6 = realloc((void *)matches, (data_len + 1UL) * sizeof(char *));
#line 370
  matches = (char **)tmp___6;
#line 371
  match_list->data = matches;
#line 372
  match_list->length = (int )data_len;
  }
#line 373
  return;
}
}
#line 375 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/fselect.c"
static void free_match(MATCH *match_list ) 
{ 


  {
  {
#line 378
  free((void *)match_list->data);
#line 379
  match_list->length = 0;
  }
#line 380
  return;
}
}
#line 382 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/fselect.c"
static int complete(char *name , LIST *d_list , LIST *f_list , char **buff_ptr ) 
{ 
  MATCH match_list ;
  char *test ;
  size_t test_len ;
  size_t i ;
  int j ;
  char *buff ;
  void *tmp ;
  char *tmp___0 ;
  char test_char ;
  void *tmp___1 ;

  {
  {
#line 392
  match(name, d_list, f_list, & match_list);
  }
#line 393
  if (match_list.length == 0) {
#line 394
    *buff_ptr = (char *)((void *)0);
#line 395
    return (0);
  }
  {
#line 398
  test = *(match_list.data + 0);
#line 399
  test_len = strlen((char const   *)test);
#line 400
  tmp = malloc((test_len + 2UL) * sizeof(char ));
#line 400
  buff = (char *)tmp;
  }
#line 401
  if (match_list.length == 1) {
    {
#line 402
    strcpy((char */* __restrict  */)buff, (char const   */* __restrict  */)test);
#line 403
    i = test_len;
#line 404
    tmp___0 = data_of(d_list);
    }
#line 404
    if ((unsigned long )test == (unsigned long )tmp___0) {
#line 405
      *(buff + test_len) = (char )'/';
#line 406
      i ++;
    }
  } else {
#line 409
    i = (size_t )0;
    {
#line 409
    while (1) {
      while_continue: /* CIL Label */ ;
#line 409
      if (! (i < test_len)) {
#line 409
        goto while_break;
      }
#line 410
      test_char = *(test + i);
#line 411
      if ((int )test_char == 0) {
#line 412
        goto while_break;
      }
#line 413
      j = 0;
      {
#line 413
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 413
        if (! (j < match_list.length)) {
#line 413
          goto while_break___0;
        }
#line 414
        if ((int )*(*(match_list.data + j) + i) != (int )test_char) {
#line 415
          goto while_break___0;
        }
#line 413
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 418
      if (j == match_list.length) {
#line 419
        *(buff + i) = test_char;
      } else {
#line 421
        goto while_break;
      }
#line 409
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 423
    tmp___1 = realloc((void *)buff, (i + 1UL) * sizeof(char ));
#line 423
    buff = (char *)tmp___1;
    }
  }
  {
#line 425
  free_match(& match_list);
#line 426
  *(buff + i) = (char )'\000';
#line 427
  *buff_ptr = buff;
  }
#line 428
  return (i != 0UL);
}
}
#line 431 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/fselect.c"
static _Bool fill_lists(char *current , char *input , LIST *d_list , LIST *f_list ,
                        int keep ) 
{ 
  _Bool result ;
  _Bool rescan ;
  DIR *dp ;
  struct dirent *de ;
  struct stat sb ;
  int n ;
  char path[2049] ;
  char *leaf ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t have ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  char *tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;

  {
#line 434
  result = (_Bool)1;
#line 435
  rescan = (_Bool)0;
#line 444
  n = 0;
  {
#line 444
  while (1) {
    while_continue: /* CIL Label */ ;
#line 444
    if (*(current + n)) {
#line 444
      if (! *(input + n)) {
#line 444
        goto while_break;
      }
    } else {
#line 444
      goto while_break;
    }
#line 445
    if ((int )*(current + n) != (int )*(input + n)) {
#line 446
      goto while_break;
    }
#line 444
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 449
  if ((int )*(current + n) == (int )*(input + n)) {
#line 450
    result = (_Bool)0;
#line 451
    if (n == 0) {
#line 451
      if (d_list->length == 0) {
#line 451
        tmp = 1;
      } else {
#line 451
        tmp = 0;
      }
    } else {
#line 451
      tmp = 0;
    }
#line 451
    rescan = (_Bool )tmp;
  } else {
    {
#line 452
    tmp___1 = strchr((char const   *)(current + n), '/');
    }
#line 452
    if ((unsigned long )tmp___1 == (unsigned long )((char *)0)) {
      {
#line 452
      tmp___2 = strchr((char const   *)(input + n), '/');
      }
#line 452
      if ((unsigned long )tmp___2 == (unsigned long )((char *)0)) {
        {
#line 454
        tmp___0 = show_both_lists(input, d_list, f_list, keep);
#line 454
        result = (_Bool )tmp___0;
        }
      } else {
#line 456
        rescan = (_Bool)1;
      }
    } else {
#line 456
      rescan = (_Bool)1;
    }
  }
#line 459
  if (rescan) {
    {
#line 460
    tmp___3 = strlen((char const   *)input);
#line 460
    have = tmp___3;
    }
#line 462
    if (have > 2048UL) {
#line 463
      have = (size_t )2048;
    }
    {
#line 464
    memcpy((void */* __restrict  */)current, (void const   */* __restrict  */)input,
           have);
#line 465
    *(current + have) = (char )'\000';
#line 468
    free_list___0(d_list, 1);
#line 469
    free_list___0(f_list, 1);
#line 470
    memcpy((void */* __restrict  */)(path), (void const   */* __restrict  */)current,
           have);
#line 471
    path[have] = (char )'\000';
#line 472
    leaf = strrchr((char const   *)(path), '/');
    }
#line 472
    if ((unsigned long )leaf != (unsigned long )((char *)0)) {
#line 473
      leaf ++;
#line 473
      *leaf = (char)0;
    } else {
      {
#line 475
      strcpy((char */* __restrict  */)(path), (char const   */* __restrict  */)"./");
#line 476
      tmp___4 = strlen((char const   *)(path));
#line 476
      leaf = path + tmp___4;
      }
    }
    {
#line 478
    dlg_trace_msg("opendir \'%s\'\n", path);
#line 479
    dp = opendir((char const   *)(path));
    }
#line 479
    if ((unsigned long )dp != (unsigned long )((DIR *)0)) {
      {
#line 480
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 480
        de = readdir(dp);
        }
#line 480
        if (! ((unsigned long )de != (unsigned long )((struct dirent *)0))) {
#line 480
          goto while_break___0;
        }
        {
#line 481
        tmp___5 = strlen((char const   *)(de->d_name));
#line 481
        tmp___6 = strncpy((char */* __restrict  */)leaf, (char const   */* __restrict  */)(de->d_name),
                          tmp___5);
#line 481
        tmp___7 = strlen((char const   *)(de->d_name));
#line 481
        *(tmp___6 + tmp___7) = (char)0;
#line 482
        tmp___8 = stat((char const   */* __restrict  */)(path), (struct stat */* __restrict  */)(& sb));
        }
#line 482
        if (tmp___8 == 0) {
#line 483
          if ((sb.st_mode & 61440U) == 16384U) {
            {
#line 484
            add_to_list(d_list, leaf);
            }
          } else
#line 485
          if (f_list->win) {
            {
#line 486
            add_to_list(f_list, leaf);
            }
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 489
      closedir(dp);
      }
#line 491
      if ((unsigned long )d_list->data != (unsigned long )((char **)0)) {
#line 491
        if (d_list->length > 1) {
          {
#line 492
          qsort((void *)d_list->data, (size_t )d_list->length, sizeof(*(d_list->data + 0)),
                & compar);
          }
        }
      }
#line 497
      if ((unsigned long )f_list->data != (unsigned long )((char **)0)) {
#line 497
        if (f_list->length > 1) {
          {
#line 498
          qsort((void *)f_list->data, (size_t )f_list->length, sizeof(*(f_list->data + 0)),
                & compar);
          }
        }
      }
    }
    {
#line 505
    show_both_lists(input, d_list, f_list, 0);
#line 506
    d_list->offset = d_list->choice;
#line 507
    f_list->offset = f_list->choice;
#line 508
    result = (_Bool)1;
    }
  }
#line 510
  return (result);
}
}
#line 513 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/fselect.c"
static _Bool usable_state(int state , LIST *dirs , LIST *files ) 
{ 
  _Bool result ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 519
  if (state == -3) {
#line 519
    goto case_neg_3;
  }
#line 522
  if (state == -2) {
#line 522
    goto case_neg_2;
  }
#line 525
  goto switch_default;
  case_neg_3: /* CIL Label */ 
#line 520
  if ((unsigned long )dirs->win != (unsigned long )((WINDOW *)0)) {
    {
#line 520
    tmp = data_of(dirs);
    }
#line 520
    if ((unsigned long )tmp != (unsigned long )((char *)0)) {
#line 520
      tmp___0 = 1;
    } else {
#line 520
      tmp___0 = 0;
    }
  } else {
#line 520
    tmp___0 = 0;
  }
#line 520
  result = (_Bool )tmp___0;
#line 521
  goto switch_break;
  case_neg_2: /* CIL Label */ 
#line 523
  if ((unsigned long )files->win != (unsigned long )((WINDOW *)0)) {
    {
#line 523
    tmp___1 = data_of(files);
    }
#line 523
    if ((unsigned long )tmp___1 != (unsigned long )((char *)0)) {
#line 523
      tmp___2 = 1;
    } else {
#line 523
      tmp___2 = 0;
    }
  } else {
#line 523
    tmp___2 = 0;
  }
#line 523
  result = (_Bool )tmp___2;
#line 524
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 526
  result = (_Bool)1;
#line 527
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 529
  return (result);
}
}
#line 556
static int dlg_fselect(char const   *title , char const   *path , int height , int width ,
                       int dselect ) ;
#line 556 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/fselect.c"
static DLG_KEYS_BINDING binding___4[17]  = 
#line 556
  {      {0, 5, 545}, 
        {1, 265, 545}, 
        {1, 363, 545}, 
        {0, '\n', 541}, 
        {0, '\r', 541}, 
        {1, 343, 541}, 
        {1, 261, 528}, 
        {0, 9, 528}, 
        {1, 353, 529}, 
        {1, 258, 524}, 
        {0, 14, 524}, 
        {1, 367, 524}, 
        {0, 16, 525}, 
        {1, 259, 525}, 
        {1, 338, 520}, 
        {1, 339, 521}, 
        {-1, 0, 0}};
#line 562 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/fselect.c"
static DLG_KEYS_BINDING binding2___3[26]  = 
#line 562
  {      {1, 262, 542}, 
        {0, 21, 540}, 
        {0, 8, 538}, 
        {1, 263, 538}, 
        {0, 127, 539}, 
        {1, 330, 539}, 
        {1, 360, 543}, 
        {1, 260, 536}, 
        {1, 261, 537}, 
        {0, 5, 545}, 
        {1, 265, 545}, 
        {1, 363, 545}, 
        {0, '\n', 541}, 
        {0, '\r', 541}, 
        {1, 343, 541}, 
        {1, 261, 528}, 
        {0, 9, 528}, 
        {1, 353, 529}, 
        {1, 258, 524}, 
        {0, 14, 524}, 
        {1, 367, 524}, 
        {0, 16, 525}, 
        {1, 259, 525}, 
        {1, 338, 520}, 
        {1, 339, 521}, 
        {-1, 0, 0}};
#line 552 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/fselect.c"
static int dlg_fselect(char const   *title , char const   *path , int height , int width ,
                       int dselect ) 
{ 
  int old_height ;
  int old_width ;
  _Bool resized ;
  int tbox_y ;
  int tbox_x ;
  int tbox_width ;
  int tbox_height ;
  int dbox_y ;
  int dbox_x ;
  int dbox_width ;
  int dbox_height ;
  int fbox_y ;
  int fbox_x ;
  int fbox_width ;
  int fbox_height ;
  int show_buttons ;
  int offset ;
  int key ;
  int fkey ;
  int code ;
  int result ;
  int state ;
  int tmp ;
  int tmp___0 ;
  int button ;
  int first___0 ;
  int first_trace ;
  char *input ;
  char *completed ;
  char current[2049] ;
  WINDOW *dialog ;
  WINDOW *w_text ;
  WINDOW *w_work ;
  char const   **buttons ;
  char const   **tmp___1 ;
  char const   *d_label ;
  char const   *f_label ;
  char *partial ;
  int min_wide ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int min_items ;
  int tmp___9 ;
  LIST d_list ;
  LIST f_list ;
  size_t tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  _Bool tmp___17 ;
  WINDOW *tmp___18 ;
  int tmp___19 ;
  LIST *tmp___20 ;
  LIST *tmp___21 ;
  LIST *tmp___22 ;
  LIST *tmp___23 ;
  LIST *tmp___24 ;
  LIST *tmp___25 ;
  LIST *tmp___26 ;
  LIST *tmp___27 ;
  LIST *tmp___28 ;
  LIST *tmp___29 ;
  LIST *tmp___30 ;
  LIST *tmp___31 ;
  LIST *tmp___32 ;
  LIST *tmp___33 ;
  _Bool tmp___34 ;
  _Bool tmp___35 ;
  LIST *tmp___36 ;
  LIST *tmp___37 ;
  _Bool tmp___38 ;
  _Bool tmp___39 ;
  int tmp___40 ;
  char *tmp___41 ;
  size_t tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int edit ;
  _Bool tmp___45 ;

  {
#line 572
  old_height = height;
#line 573
  old_width = width;
#line 574
  resized = (_Bool)0;
#line 579
  show_buttons = 1;
#line 580
  offset = 0;
#line 581
  key = 0;
#line 582
  fkey = 0;
#line 584
  result = -2;
#line 585
  if (dialog_vars.default_button >= 0) {
    {
#line 585
    tmp = dlg_default_button();
#line 585
    tmp___0 = tmp;
    }
  } else {
#line 585
    tmp___0 = -1;
  }
  {
#line 585
  state = tmp___0;
#line 587
  first___0 = state == -1;
#line 588
  first_trace = 1;
#line 592
  dialog = (WINDOW *)0;
#line 593
  w_text = (WINDOW *)0;
#line 594
  w_work = (WINDOW *)0;
#line 595
  tmp___1 = dlg_ok_labels();
#line 595
  buttons = tmp___1;
#line 596
  d_label = "Directories";
#line 597
  f_label = "Files";
#line 598
  partial = (char *)0;
#line 599
  tmp___7 = dlg_count_columns(d_label);
#line 599
  tmp___8 = dlg_count_columns(f_label);
  }
#line 599
  if (tmp___7 > tmp___8) {
    {
#line 599
    tmp___4 = dlg_count_columns(d_label);
#line 599
    tmp___6 = tmp___4;
    }
  } else {
    {
#line 599
    tmp___5 = dlg_count_columns(f_label);
#line 599
    tmp___6 = tmp___5;
    }
  }
#line 599
  min_wide = (2 * tmp___6 + 6) + 2;
#line 600
  if (height) {
#line 600
    tmp___9 = 0;
  } else {
#line 600
    tmp___9 = 4;
  }
  {
#line 600
  min_items = tmp___9;
#line 603
  dlg_does_output();
#line 606
  input = dlg_set_result(path);
#line 607
  tmp___10 = strlen((char const   *)input);
#line 607
  offset = (int )tmp___10;
#line 608
  current[0] = (char)0;
#line 610
  dlg_button_layout(buttons, & min_wide);
  }
  retry: 
  {
#line 615
  dlg_auto_size(title, (char const   *)((char *)0), & height, & width, 6, 25);
#line 616
  height += 10 + min_items;
  }
#line 617
  if (width < min_wide) {
#line 618
    width = min_wide;
  }
  {
#line 619
  dlg_print_size(height, width);
#line 620
  dlg_ctl_size(height, width);
#line 622
  tmp___11 = dlg_box_x_ordinate(width);
#line 622
  tmp___12 = dlg_box_y_ordinate(height);
#line 622
  dialog = dlg_new_window(height, width, tmp___12, tmp___11);
#line 625
  dlg_register_window(dialog, "fselect", binding___4);
#line 626
  dlg_register_buttons(dialog, "fselect", buttons);
#line 628
  dlg_mouse_setbase(0, 0);
#line 630
  dlg_draw_box2(dialog, 0, 0, height, width, dlg_color_table[2].atr, dlg_color_table[4].atr,
                dlg_color_table[34].atr);
#line 631
  dlg_draw_bottom_box2(dialog, dlg_color_table[4].atr, dlg_color_table[34].atr, dlg_color_table[2].atr);
#line 632
  dlg_draw_title(dialog, title);
  }
#line 634
  if (dialog) {
#line 634
    dialog->_attrs = dlg_color_table[2].atr;
  }
  {
#line 637
  tbox_height = 1;
#line 638
  tbox_width = width - 6;
#line 639
  tbox_y = (height - 6) + 1;
#line 640
  tbox_x = (width - tbox_width) / 2;
#line 642
  w_text = derwin(dialog, tbox_height, tbox_width, tbox_y, tbox_x);
  }
#line 643
  if ((unsigned long )w_text == (unsigned long )((WINDOW *)0)) {
#line 644
    result = -1;
#line 645
    goto finish;
  }
  {
#line 648
  keypad(w_text, (_Bool)1);
#line 649
  dlg_draw_box(dialog, tbox_y - 1, tbox_x - 1, 3, tbox_width + 2, dlg_color_table[18].atr,
               dlg_color_table[37].atr);
  }
#line 652
  if (dialog) {
#line 652
    tmp___13 = (int )dialog->_begx;
  } else {
#line 652
    tmp___13 = -1;
  }
#line 652
  if (dialog) {
#line 652
    tmp___14 = (int )dialog->_begy;
  } else {
#line 652
    tmp___14 = -1;
  }
  {
#line 652
  dlg_mouse_mkbigregion((tmp___14 + tbox_y) - 1, (tmp___13 + tbox_x) - 1, 3, tbox_width + 2,
                        20511, 1, 1, 3);
#line 658
  dlg_register_window(w_text, "fselect2", binding2___3);
  }
#line 661
  if (dselect) {
#line 662
    dbox_width = width - 6;
  } else {
#line 664
    dbox_width = (width - 8) / 2;
  }
  {
#line 665
  dbox_height = height - 10;
#line 666
  dbox_y = 3;
#line 667
  dbox_x = tbox_x;
#line 669
  w_work = derwin(dialog, dbox_height, dbox_width, dbox_y, dbox_x);
  }
#line 670
  if ((unsigned long )w_work == (unsigned long )((WINDOW *)0)) {
#line 671
    result = -1;
#line 672
    goto finish;
  }
  {
#line 675
  keypad(w_work, (_Bool)1);
#line 676
  tmp___15 = wmove(dialog, dbox_y - 2, dbox_x - 1);
  }
#line 676
  if (! (tmp___15 == -1)) {
    {
#line 676
    waddnstr(dialog, d_label, -1);
    }
  }
  {
#line 677
  dlg_draw_box(dialog, dbox_y - 1, dbox_x - 1, dbox_height + 2, dbox_width + 2, dlg_color_table[18].atr,
               dlg_color_table[37].atr);
#line 681
  init_list(& d_list, dialog, w_work, 511);
  }
#line 683
  if (! dselect) {
    {
#line 685
    fbox_height = dbox_height;
#line 686
    fbox_width = dbox_width;
#line 687
    fbox_y = dbox_y;
#line 688
    fbox_x = (tbox_x + dbox_width) + 2;
#line 690
    w_work = derwin(dialog, fbox_height, fbox_width, fbox_y, fbox_x);
    }
#line 691
    if ((unsigned long )w_work == (unsigned long )((WINDOW *)0)) {
#line 692
      result = -1;
#line 693
      goto finish;
    }
    {
#line 696
    keypad(w_work, (_Bool)1);
#line 697
    tmp___16 = wmove(dialog, fbox_y - 2, fbox_x - 1);
    }
#line 697
    if (! (tmp___16 == -1)) {
      {
#line 697
      waddnstr(dialog, f_label, -1);
      }
    }
    {
#line 698
    dlg_draw_box(dialog, fbox_y - 1, fbox_x - 1, fbox_height + 2, fbox_width + 2,
                 dlg_color_table[18].atr, dlg_color_table[37].atr);
#line 702
    init_list(& f_list, dialog, w_work, 10511);
    }
  } else {
    {
#line 704
    memset((void *)(& f_list), 0, sizeof(f_list));
    }
  }
  {
#line 707
  while (1) {
    while_continue: /* CIL Label */ ;
#line 707
    if (! (result == -2)) {
#line 707
      goto while_break;
    }
    {
#line 709
    tmp___17 = fill_lists(current, input, & d_list, & f_list, state < -1);
    }
#line 709
    if (tmp___17) {
#line 710
      show_buttons = 1;
    }
#line 713
    if (resized) {
      {
#line 714
      resized = (_Bool)0;
#line 715
      dlg_show_string(w_text, (char const   *)input, offset, dlg_color_table[11].atr,
                      0, 0, tbox_width, (_Bool)0, (_Bool )first___0);
      }
    }
#line 723
    if (show_buttons) {
#line 724
      show_buttons = 0;
#line 725
      if (state < 0) {
#line 725
        button = 0;
      } else {
#line 725
        button = state;
      }
      {
#line 726
      dlg_draw_buttons(dialog, height - 2, 0, buttons, button, 0, width);
      }
    }
#line 729
    if (first_trace) {
      {
#line 730
      first_trace = 0;
#line 731
      dlg_trace_win(dialog);
      }
    }
#line 734
    if (state < 0) {
      {
#line 736
      if (state == -1) {
#line 736
        goto case_neg_1;
      }
#line 739
      if (state == -2) {
#line 739
        goto case_neg_2;
      }
#line 742
      if (state == -3) {
#line 742
        goto case_neg_3;
      }
#line 735
      goto switch_break;
      case_neg_1: /* CIL Label */ 
      {
#line 737
      dlg_set_focus(dialog, w_text);
      }
#line 738
      goto switch_break;
      case_neg_2: /* CIL Label */ 
      {
#line 740
      dlg_set_focus(dialog, f_list.win);
      }
#line 741
      goto switch_break;
      case_neg_3: /* CIL Label */ 
      {
#line 743
      dlg_set_focus(dialog, d_list.win);
      }
#line 744
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 748
    if (first___0) {
      {
#line 749
      wrefresh(dialog);
      }
    } else {
      {
#line 751
      fix_arrows(& d_list);
#line 752
      fix_arrows(& f_list);
      }
#line 753
      if (state == -1) {
#line 753
        tmp___18 = w_text;
      } else {
#line 753
        tmp___18 = dialog;
      }
      {
#line 753
      key = dlg_mouse_wgetch(tmp___18, & fkey);
#line 754
      tmp___19 = dlg_result_key(key, fkey, & result);
      }
#line 754
      if (tmp___19) {
#line 755
        goto while_break;
      }
    }
#line 758
    if (! fkey) {
#line 758
      if (key == 32) {
#line 759
        key = 544;
#line 760
        fkey = 1;
      }
    }
#line 763
    if (fkey) {
      {
#line 765
      if (key == 1138) {
#line 765
        goto case_1138;
      }
#line 769
      if (key == 1135) {
#line 769
        goto case_1135;
      }
#line 773
      if (key == 1107) {
#line 773
        goto case_1107;
      }
#line 777
      if (key == 1106) {
#line 777
        goto case_1106;
      }
#line 781
      if (key == 521) {
#line 781
        goto case_521;
      }
#line 784
      if (key == 520) {
#line 784
        goto case_520;
      }
#line 787
      if (key == 525) {
#line 787
        goto case_525;
      }
#line 791
      if (key == 529) {
#line 791
        goto case_529;
      }
#line 797
      if (key == 524) {
#line 797
        goto case_524;
      }
#line 801
      if (key == 528) {
#line 801
        goto case_528;
      }
#line 807
      if (key == 544) {
#line 807
        goto case_544;
      }
#line 839
      if (key == 541) {
#line 839
        goto case_541;
      }
#line 843
      if (key == 410) {
#line 843
        goto case_410;
      }
#line 857
      goto switch_default;
      case_1138: /* CIL Label */ 
#line 766
      state = -3;
#line 767
      if (state == -2) {
#line 767
        tmp___21 = & f_list;
      } else {
#line 767
        if (state == -3) {
#line 767
          tmp___20 = & d_list;
        } else {
#line 767
          tmp___20 = (LIST *)0;
        }
#line 767
        tmp___21 = tmp___20;
      }
      {
#line 767
      scroll_list(-1, tmp___21);
      }
#line 768
      goto while_continue;
      case_1135: /* CIL Label */ 
#line 770
      state = -3;
#line 771
      if (state == -2) {
#line 771
        tmp___23 = & f_list;
      } else {
#line 771
        if (state == -3) {
#line 771
          tmp___22 = & d_list;
        } else {
#line 771
          tmp___22 = (LIST *)0;
        }
#line 771
        tmp___23 = tmp___22;
      }
      {
#line 771
      scroll_list(1, tmp___23);
      }
#line 772
      goto while_continue;
      case_1107: /* CIL Label */ 
#line 774
      state = -2;
#line 775
      if (state == -2) {
#line 775
        tmp___25 = & f_list;
      } else {
#line 775
        if (state == -3) {
#line 775
          tmp___24 = & d_list;
        } else {
#line 775
          tmp___24 = (LIST *)0;
        }
#line 775
        tmp___25 = tmp___24;
      }
      {
#line 775
      scroll_list(-1, tmp___25);
      }
#line 776
      goto while_continue;
      case_1106: /* CIL Label */ 
#line 778
      state = -2;
#line 779
      if (state == -2) {
#line 779
        tmp___27 = & f_list;
      } else {
#line 779
        if (state == -3) {
#line 779
          tmp___26 = & d_list;
        } else {
#line 779
          tmp___26 = (LIST *)0;
        }
#line 779
        tmp___27 = tmp___26;
      }
      {
#line 779
      scroll_list(1, tmp___27);
      }
#line 780
      goto while_continue;
      case_521: /* CIL Label */ 
#line 782
      if (state == -2) {
#line 782
        tmp___29 = & f_list;
      } else {
#line 782
        if (state == -3) {
#line 782
          tmp___28 = & d_list;
        } else {
#line 782
          tmp___28 = (LIST *)0;
        }
#line 782
        tmp___29 = tmp___28;
      }
      {
#line 782
      scroll_list(-1, tmp___29);
      }
#line 783
      goto while_continue;
      case_520: /* CIL Label */ 
#line 785
      if (state == -2) {
#line 785
        tmp___31 = & f_list;
      } else {
#line 785
        if (state == -3) {
#line 785
          tmp___30 = & d_list;
        } else {
#line 785
          tmp___30 = (LIST *)0;
        }
#line 785
        tmp___31 = tmp___30;
      }
      {
#line 785
      scroll_list(1, tmp___31);
      }
#line 786
      goto while_continue;
      case_525: /* CIL Label */ 
#line 788
      if (state == -2) {
#line 788
        tmp___33 = & f_list;
      } else {
#line 788
        if (state == -3) {
#line 788
          tmp___32 = & d_list;
        } else {
#line 788
          tmp___32 = (LIST *)0;
        }
#line 788
        tmp___33 = tmp___32;
      }
      {
#line 788
      tmp___34 = change_list(-1, tmp___33);
      }
#line 788
      if (tmp___34) {
#line 789
        goto while_continue;
      }
      case_529: /* CIL Label */ 
#line 792
      show_buttons = 1;
      {
#line 793
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 794
        state = dlg_prev_ok_buttonindex(state, -3);
#line 793
        tmp___35 = usable_state(state, & d_list, & f_list);
        }
#line 793
        if (tmp___35) {
#line 793
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 796
      goto while_continue;
      case_524: /* CIL Label */ 
#line 798
      if (state == -2) {
#line 798
        tmp___37 = & f_list;
      } else {
#line 798
        if (state == -3) {
#line 798
          tmp___36 = & d_list;
        } else {
#line 798
          tmp___36 = (LIST *)0;
        }
#line 798
        tmp___37 = tmp___36;
      }
      {
#line 798
      tmp___38 = change_list(1, tmp___37);
      }
#line 798
      if (tmp___38) {
#line 799
        goto while_continue;
      }
      case_528: /* CIL Label */ 
#line 802
      show_buttons = 1;
      {
#line 803
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 804
        state = dlg_next_ok_buttonindex(state, -3);
#line 803
        tmp___39 = usable_state(state, & d_list, & f_list);
        }
#line 803
        if (tmp___39) {
#line 803
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 806
      goto while_continue;
      case_544: /* CIL Label */ 
#line 808
      completed = (char *)0;
#line 809
      if ((unsigned long )partial != (unsigned long )((char *)0)) {
        {
#line 810
        free((void *)partial);
#line 811
        partial = (char *)0;
        }
      }
#line 813
      if (state == -2) {
#line 813
        if (! dselect) {
          {
#line 814
          completed = data_of(& f_list);
          }
        } else {
#line 813
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 815
      if (state == -3) {
        {
#line 816
        completed = data_of(& d_list);
        }
      } else {
        {
#line 818
        tmp___40 = complete(input, & d_list, & f_list, & partial);
        }
#line 818
        if (tmp___40) {
#line 819
          completed = partial;
        }
      }
#line 822
      if ((unsigned long )completed != (unsigned long )((char *)0)) {
        {
#line 823
        state = -1;
#line 824
        show_buttons = 1;
#line 825
        tmp___41 = leaf_of(input);
#line 825
        strcpy((char */* __restrict  */)tmp___41, (char const   */* __restrict  */)completed);
#line 826
        tmp___42 = strlen((char const   *)input);
#line 826
        offset = (int )tmp___42;
#line 827
        dlg_show_string(w_text, (char const   *)input, offset, dlg_color_table[11].atr,
                        0, 0, tbox_width, (_Bool)0, (_Bool )first___0);
        }
#line 829
        if ((unsigned long )partial != (unsigned long )((void *)0)) {
          {
#line 830
          free((void *)partial);
#line 831
          partial = (char *)0;
          }
        }
#line 833
        goto while_continue;
      } else {
        {
#line 835
        beep();
        }
#line 836
        goto while_continue;
      }
      case_541: /* CIL Label */ 
#line 840
      if (state > 0) {
#line 840
        if (dialog_vars.nook) {
#line 840
          tmp___44 = 0;
        } else {
          {
#line 840
          tmp___43 = dlg_ok_buttoncode(state);
#line 840
          tmp___44 = tmp___43;
          }
        }
#line 840
        result = tmp___44;
      } else {
#line 840
        result = 0;
      }
#line 841
      goto while_continue;
      case_410: /* CIL Label */ 
      {
#line 845
      height = old_height;
#line 846
      width = old_width;
#line 847
      show_buttons = 1;
#line 848
      current[0] = (char)0;
#line 849
      resized = (_Bool)1;
#line 851
      dlg_clear();
#line 852
      dlg_del_window(dialog);
#line 853
      wrefresh(stdscr);
#line 854
      dlg_mouse_free_regions();
      }
#line 855
      goto retry;
      switch_default: /* CIL Label */ 
#line 858
      if (key >= 21279) {
#line 859
        state = -1;
#line 860
        goto while_continue;
      } else
#line 861
      if (key >= 11279) {
#line 862
        if ((unsigned long )f_list.win != (unsigned long )((WINDOW *)0)) {
          {
#line 863
          state = -2;
#line 864
          f_list.choice = (key - 11279) + f_list.offset;
#line 865
          display_list(& f_list);
          }
        }
#line 867
        goto while_continue;
      } else
#line 868
      if (key >= 1279) {
#line 869
        if ((unsigned long )d_list.win != (unsigned long )((WINDOW *)0)) {
          {
#line 870
          state = -3;
#line 871
          d_list.choice = (key - 1279) + d_list.offset;
#line 872
          display_list(& d_list);
          }
        }
#line 874
        goto while_continue;
      } else
#line 875
      if (key >= 768) {
        {
#line 875
        code = dlg_ok_buttoncode(key - 768);
        }
#line 875
        if (code >= 0) {
#line 877
          result = code;
#line 878
          goto while_continue;
        }
      }
#line 880
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 884
    if (state < 0) {
      {
#line 885
      tmp___45 = dlg_edit_string(input, & offset, key, fkey, (_Bool )first___0);
#line 885
      edit = (int )tmp___45;
      }
#line 887
      if (edit) {
        {
#line 888
        dlg_show_string(w_text, (char const   *)input, offset, dlg_color_table[11].atr,
                        0, 0, tbox_width, (_Bool)0, (_Bool )first___0);
#line 890
        first___0 = 0;
#line 891
        state = -1;
        }
      }
    } else
#line 893
    if (state >= 0) {
      {
#line 893
      code = dlg_char_to_button(key, buttons);
      }
#line 893
      if (code >= 0) {
        {
#line 895
        result = dlg_ok_buttoncode(code);
        }
#line 896
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 900
  dlg_unregister_window(w_text);
#line 901
  dlg_del_window(dialog);
#line 902
  dlg_mouse_free_regions();
#line 903
  free_list___0(& d_list, 0);
#line 904
  free_list___0(& f_list, 0);
  }
  finish: 
#line 907
  if ((unsigned long )partial != (unsigned long )((char *)0)) {
    {
#line 908
    free((void *)partial);
    }
  }
#line 909
  return (result);
}
}
#line 915 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/fselect.c"
int dialog_fselect(char const   *title , char const   *path , int height , int width ) 
{ 
  int tmp ;

  {
  {
#line 918
  tmp = dlg_fselect(title, path, height, width, 0);
  }
#line 918
  return (tmp);
}
}
#line 924 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/fselect.c"
int dialog_dselect(char const   *title , char const   *path , int height , int width ) 
{ 
  int tmp ;

  {
  {
#line 927
  tmp = dlg_fselect(title, path, height, width, 1);
  }
#line 927
  return (tmp);
}
}
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 176 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 306 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 611 "/usr/include/curses.h"
extern int endwin(void) ;
#line 632
extern WINDOW *initscr(void) ;
#line 1608
extern mmask_t mousemask(mmask_t  , mmask_t * ) ;
#line 585 "./dialog.h"
extern char const   *dialog_version(void) ;
#line 588
int dialog_buildlist(char const   *title , char const   *cprompt , int height , int width ,
                     int list_height , int item_no , char **items , int order_mode ) ;
#line 589
int dialog_calendar(char const   *title , char const   *subtitle , int height , int width ,
                    int day , int month , int year ) ;
#line 595
int dialog_gauge(char const   *title , char const   *cprompt , int height , int width ,
                 int percent ) ;
#line 599
extern int dialog_mixedform(char const   * , char const   * , int  , int  , int  ,
                            int  , char ** ) ;
#line 600
extern int dialog_mixedgauge(char const   * , char const   * , int  , int  , int  ,
                             int  , char ** ) ;
#line 601
extern int dialog_msgbox(char const   * , char const   * , int  , int  , int  ) ;
#line 602
extern int dialog_pause(char const   * , char const   * , int  , int  , int  ) ;
#line 603
extern int dialog_prgbox(char const   * , char const   * , char const   * , int  ,
                         int  , int  ) ;
#line 604
extern int dialog_progressbox(char const   * , char const   * , int  , int  ) ;
#line 605
extern int dialog_rangebox(char const   * , char const   * , int  , int  , int  ,
                           int  , int  ) ;
#line 606
extern int dialog_tailbox(char const   * , char const   * , int  , int  , int  ) ;
#line 608
extern int dialog_timebox(char const   * , char const   * , int  , int  , int  , int  ,
                          int  ) ;
#line 609
extern int dialog_treeview(char const   * , char const   * , int  , int  , int  ,
                           int  , char ** , int  ) ;
#line 610
extern int dialog_yesno(char const   * , char const   * , int  , int  ) ;
#line 643
extern int dlg_progressbox(char const   * , char const   * , int  , int  , int  ,
                           FILE * ) ;
#line 716
extern int dlg_parse_rc(void) ;
#line 717
extern void dlg_create_rc(char const   * ) ;
#line 785
extern void dlg_put_backtitle(void) ;
#line 790
extern void dlg_trim_string(char * ) ;
#line 792
extern void init_dialog(FILE * , FILE * ) ;
#line 814
extern void dlg_trace(char const   * ) ;
#line 124 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 189 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
static _Bool *dialog_opts  ;
#line 190 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
static char **dialog_argv  ;
#line 192 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
static _Bool ignore_unknown  =    (_Bool)0;
#line 194 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
static char const   *program  =    "dialog";
#line 201 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
static Options const   options[126]  = 
#line 201
  {      {"allow-close", (eOptions )1, 1, (char const   *)((void *)0)}, 
        {"and-widget", (eOptions )2, 4, (char const   *)((void *)0)}, 
        {"ascii-lines", (eOptions )3, 1, ""}, 
        {"aspect", (eOptions )4, 1, "<ratio>"}, 
        {"auto-placement", (eOptions )5, 1, (char const   *)((void *)0)}, 
        {"backtitle", (eOptions )6, 1, "<backtitle>"}, 
        {"beep", (eOptions )7, 1, ""}, 
        {"beep-after", (eOptions )8, 1, ""}, 
        {"begin", (eOptions )9, 1, "<y> <x>"}, 
        {"cancel-label", (eOptions )10, 1, "<str>"}, 
        {"checklist", (eOptions )11, 2, "<text> <height> <width> <list height> <tag1> <item1> <status1>..."}, 
        {"clear",
      (eOptions )12, 1, ""}, 
        {"colors", (eOptions )13, 1, ""}, 
        {"column-separator", (eOptions )14, 1, "<str>"}, 
        {"cr-wrap", (eOptions )15, 1, ""}, 
        {"create-rc", (eOptions )16, 1, (char const   *)((void *)0)}, 
        {"date-format", (eOptions )17, 1, "<str>"}, 
        {"default-button", (eOptions )18, 1, "<str>"}, 
        {"default-item", (eOptions )19, 1, "<str>"}, 
        {"defaultno", (eOptions )20, 1, ""}, 
        {"exit-label", (eOptions )21, 1, "<str>"}, 
        {"extra-button", (eOptions )22, 1, ""}, 
        {"extra-label", (eOptions )23, 1, "<str>"}, 
        {"fixed-font", (eOptions )24, 1, (char const   *)((void *)0)}, 
        {"form", (eOptions )25, 2, "<text> <height> <width> <form height> <label1> <l_y1> <l_x1> <item1> <i_y1> <i_x1> <flen1> <ilen1>..."}, 
        {"gauge",
      (eOptions )26, 2, "<text> <height> <width> [<percent>]"}, 
        {"guage", (eOptions )26, 2, (char const   *)((void *)0)}, 
        {"help", (eOptions )27, 4, ""}, 
        {"help-button", (eOptions )28, 1, ""}, 
        {"help-label", (eOptions )30, 1, "<str>"}, 
        {"help-status", (eOptions )32, 1, ""}, 
        {"help-tags", (eOptions )33, 1, ""}, 
        {"hfile", (eOptions )29, 1, "<str>"}, 
        {"hline", (eOptions )31, 1, "<str>"}, 
        {"icon", (eOptions )34, 1, (char const   *)((void *)0)}, 
        {"ignore", (eOptions )35, 1, ""}, 
        {"infobox", (eOptions )36, 2, "<text> <height> <width>"}, 
        {"input-fd", (eOptions )37, 1, "<fd>"}, 
        {"inputbox", (eOptions )38, 2, "<text> <height> <width> [<init>]"}, 
        {"inputmenu", (eOptions )39, 2, "<text> <height> <width> <menu height> <tag1> <item1>..."}, 
        {"insecure",
      (eOptions )40, 1, ""}, 
        {"item-help", (eOptions )41, 1, ""}, 
        {"keep-colors", (eOptions )42, 1, (char const   *)((void *)0)}, 
        {"keep-tite", (eOptions )43, 1, ""}, 
        {"keep-window", (eOptions )44, 1, ""}, 
        {"last-key", (eOptions )45, 1, ""}, 
        {"max-input", (eOptions )46, 1, "<n>"}, 
        {"menu", (eOptions )47, 2, "<text> <height> <width> <menu height> <tag1> <item1>..."}, 
        {"mixedform",
      (eOptions )48, 2, "<text> <height> <width> <form height> <label1> <l_y1> <l_x1> <item1> <i_y1> <i_x1> <flen1> <ilen1> <itype>..."}, 
        {"mixedgauge",
      (eOptions )49, 2, "<text> <height> <width> <percent> <tag1> <item1>..."}, 
        {"msgbox", (eOptions )50, 2, "<text> <height> <width>"}, 
        {"no-cancel", (eOptions )60, 1, ""}, 
        {"no-close", (eOptions )51, 1, (char const   *)((void *)0)}, 
        {"no-collapse", (eOptions )52, 1, ""}, 
        {"no-cr-wrap", (eOptions )53, 1, ""}, 
        {"no-kill", (eOptions )54, 1, ""}, 
        {"no-label", (eOptions )55, 1, "<str>"}, 
        {"no-lines", (eOptions )56, 1, ""}, 
        {"no-mouse", (eOptions )57, 1, ""}, 
        {"no-nl-expand", (eOptions )58, 1, ""}, 
        {"no-ok", (eOptions )61, 1, ""}, 
        {"no-shadow", (eOptions )59, 1, ""}, 
        {"nocancel", (eOptions )60, 1, (char const   *)((void *)0)}, 
        {"nook", (eOptions )61, 1, ""}, 
        {"ok-label", (eOptions )62, 1, "<str>"}, 
        {"output-fd", (eOptions )63, 1, "<fd>"}, 
        {"output-separator", (eOptions )64, 1, "<str>"}, 
        {"passwordbox", (eOptions )65, 2, "<text> <height> <width> [<init>]"}, 
        {"passwordform", (eOptions )66, 2, "<text> <height> <width> <form height> <label1> <l_y1> <l_x1> <item1> <i_y1> <i_x1> <flen1> <ilen1>..."}, 
        {"pause",
      (eOptions )67, 2, "<text> <height> <width> <seconds>"}, 
        {"prgbox", (eOptions )68, 2, "<text> <command> <height> <width>"}, 
        {"print-maxsize", (eOptions )69, 1, ""}, 
        {"print-size", (eOptions )70, 1, ""}, 
        {"print-version", (eOptions )71, 5, ""}, 
        {"programbox", (eOptions )72, 2, "<text> <height> <width>"}, 
        {"progressbox", (eOptions )73, 2, "<text> <height> <width>"}, 
        {"quoted", (eOptions )74, 1, ""}, 
        {"radiolist", (eOptions )75, 2, "<text> <height> <width> <list height> <tag1> <item1> <status1>..."}, 
        {"screen-center",
      (eOptions )76, 1, (char const   *)((void *)0)}, 
        {"scrollbar", (eOptions )77, 1, ""}, 
        {"separate-output", (eOptions )78, 1, ""}, 
        {"separate-widget", (eOptions )79, 1, "<str>"}, 
        {"separator", (eOptions )80, 1, (char const   *)((void *)0)}, 
        {"shadow", (eOptions )81, 1, ""}, 
        {"single-quoted", (eOptions )82, 1, ""}, 
        {"size-err", (eOptions )83, 1, ""}, 
        {"sleep", (eOptions )84, 1, "<secs>"}, 
        {"smooth", (eOptions )85, 1, (char const   *)((void *)0)}, 
        {"stderr", (eOptions )86, 1, ""}, 
        {"stdout", (eOptions )87, 1, ""}, 
        {"tab-correct", (eOptions )88, 1, ""}, 
        {"tab-len", (eOptions )89, 1, "<n>"}, 
        {"tailbox", (eOptions )90, 2, "<file> <height> <width>"}, 
        {"tailboxbg", (eOptions )91, 2, "<file> <height> <width>"}, 
        {"textbox", (eOptions )92, 2, "<file> <height> <width>"}, 
        {"time-format", (eOptions )93, 1, "<str>"}, 
        {"timeout", (eOptions )94, 1, "<secs>"}, 
        {"title", (eOptions )95, 1, "<title>"}, 
        {"trim", (eOptions )96, 1, ""}, 
        {"under-mouse", (eOptions )97, 1, (char const   *)((void *)0)}, 
        {"version", (eOptions )98, 5, ""}, 
        {"visit-items", (eOptions )99, 1, ""}, 
        {"wmclass", (eOptions )100, 1, (char const   *)((void *)0)}, 
        {"yes-label", (eOptions )101, 1, "<str>"}, 
        {"yesno", (eOptions )102, 2, "<text> <height> <width>"}, 
        {"cancel-button", (eOptions )10, 1, (char const   *)((void *)0)}, 
        {"fb", (eOptions )103, 1, (char const   *)((void *)0)}, 
        {"fullbutton", (eOptions )103, 1, (char const   *)((void *)0)}, 
        {"no-button", (eOptions )55, 1, (char const   *)((void *)0)}, 
        {"ok-button", (eOptions )62, 1, (char const   *)((void *)0)}, 
        {"scrolltext", (eOptions )77, 1, (char const   *)((void *)0)}, 
        {"topleft", (eOptions )104, 1, (char const   *)((void *)0)}, 
        {"yes-button", (eOptions )101, 1, (char const   *)((void *)0)}, 
        {"calendar", (eOptions )105, 2, "<text> <height> <width> <day> <month> <year>"}, 
        {"dselect",
      (eOptions )106, 2, "<directory> <height> <width>"}, 
        {"editbox", (eOptions )107, 2, "<file> <height> <width>"}, 
        {"fselect", (eOptions )108, 2, "<filepath> <height> <width>"}, 
        {"timebox", (eOptions )109, 2, "<text> <height> <width> <hour> <minute> <second>"}, 
        {"buildlist",
      (eOptions )110, 2, "<text> <height> <width> <tag1> <item1> <status1>..."}, 
        {"no-items", (eOptions )113, 1, ""}, 
        {"no-tags", (eOptions )114, 1, ""}, 
        {"rangebox", (eOptions )111, 2, "<text> <height> <width> <min-value> <max-value> <default-value>"}, 
        {"treeview",
      (eOptions )112, 2, "<text> <height> <width> <list-height> <tag1> <item1> <status1> <depth1>..."}, 
        {"noitem",
      (eOptions )113, 1, (char const   *)((void *)0)}, 
        {"notags", (eOptions )114, 1, (char const   *)((void *)0)}, 
        {"trace", (eOptions )115, 1, "<file>"}};
#line 354 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
static void unescape_argv(int *argcp , char ***argvp ) 
{ 
  int j ;
  int k ;
  int limit_includes ;
  int count_includes ;
  _Bool changed ;
  _Bool doalloc ;
  char *filename ;
  void *tmp ;
  _Bool escaped ;
  int tmp___0 ;
  int tmp___1 ;
  FILE *fp ;
  char **list ;
  char *blob ;
  int added ;
  size_t bytes_read ;
  size_t length ;
  int n ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  size_t need ;
  void *tmp___5 ;
  char **newp ;
  void *tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  unsigned short const   **tmp___12 ;

  {
  {
#line 358
  limit_includes = 20 + *argcp;
#line 359
  count_includes = 0;
#line 360
  changed = (_Bool)0;
#line 361
  doalloc = (_Bool)0;
#line 364
  tmp = calloc((size_t )*argcp + 1UL, sizeof(_Bool ));
#line 364
  dialog_opts = (_Bool *)tmp;
  }
#line 365
  if ((unsigned long )dialog_opts == (unsigned long )((_Bool *)0)) {
    {
#line 365
    dlg_exiterr("cannot allocate memory in unescape_argv");
    }
  }
#line 367
  j = 1;
  {
#line 367
  while (1) {
    while_continue: /* CIL Label */ ;
#line 367
    if (! (j < *argcp)) {
#line 367
      goto while_break;
    }
    {
#line 368
    escaped = (_Bool)0;
#line 369
    tmp___10 = strcmp((char const   *)*(*argvp + j), "--");
    }
#line 369
    if (tmp___10) {
      {
#line 372
      tmp___9 = strcmp((char const   *)*(*argvp + j), "--args");
      }
#line 372
      if (tmp___9) {
        {
#line 378
        tmp___8 = strcmp((char const   *)*(*argvp + j), "--file");
        }
#line 378
        if (! tmp___8) {
#line 379
          count_includes ++;
#line 379
          if (count_includes > limit_includes) {
            {
#line 380
            dlg_exiterr("Too many --file options");
            }
          }
#line 382
          filename = *(*argvp + (j + 1));
#line 382
          if ((unsigned long )filename != (unsigned long )((char *)0)) {
#line 391
            if ((int )*filename == 38) {
              {
#line 392
              tmp___2 = atoi((char const   *)(filename + sizeof(char )));
#line 392
              fp = fdopen(tmp___2, "r");
              }
            } else {
              {
#line 394
              fp = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
              }
            }
#line 397
            if (fp) {
#line 398
              blob = (char *)((void *)0);
#line 399
              length = (size_t )0;
              {
#line 400
              while (1) {
                while_continue___0: /* CIL Label */ ;
                {
#line 401
                tmp___3 = realloc((void *)blob, ((length + 8192UL) + 1UL) * sizeof(char ));
#line 401
                blob = (char *)tmp___3;
                }
#line 402
                if ((unsigned long )blob == (unsigned long )((char *)0)) {
                  {
#line 402
                  dlg_exiterr("cannot allocate memory in unescape_argv");
                  }
                }
                {
#line 403
                bytes_read = fread((void */* __restrict  */)(blob + length), sizeof(char ),
                                   (size_t )8192, (FILE */* __restrict  */)fp);
#line 407
                length += bytes_read;
#line 408
                tmp___4 = ferror(fp);
                }
#line 408
                if (tmp___4) {
                  {
#line 409
                  dlg_exiterr("error on filehandle in unescape_argv");
                  }
                }
#line 400
                if (! (bytes_read == 8192UL)) {
#line 400
                  goto while_break___0;
                }
              }
              while_break___0: /* CIL Label */ ;
              }
              {
#line 411
              fclose(fp);
#line 413
              *(blob + length) = (char )'\000';
#line 415
              list = dlg_string_to_argv(blob);
#line 416
              added = dlg_count_argv(list);
              }
#line 416
              if (added != 0) {
#line 417
                if (added > 2) {
#line 418
                  need = (size_t )((*argcp + added) + 1);
#line 419
                  if (doalloc) {
                    {
#line 420
                    tmp___5 = realloc((void *)*argvp, need * sizeof(char *));
#line 420
                    *argvp = (char **)tmp___5;
                    }
#line 421
                    if ((unsigned long )*argvp == (unsigned long )((char **)0)) {
                      {
#line 421
                      dlg_exiterr("cannot allocate memory in unescape_argv");
                      }
                    }
                  } else {
                    {
#line 423
                    tmp___6 = malloc(need * sizeof(char *));
#line 423
                    newp = (char **)tmp___6;
                    }
#line 424
                    if ((unsigned long )newp == (unsigned long )((char **)0)) {
                      {
#line 424
                      dlg_exiterr("cannot allocate memory in unescape_argv");
                      }
                    }
#line 425
                    n = 0;
                    {
#line 425
                    while (1) {
                      while_continue___1: /* CIL Label */ ;
#line 425
                      if (! (n < *argcp)) {
#line 425
                        goto while_break___1;
                      }
#line 426
                      *(newp + n) = *(*argvp + n);
#line 425
                      n ++;
                    }
                    while_break___1: /* CIL Label */ ;
                    }
#line 428
                    *argvp = newp;
#line 429
                    doalloc = (_Bool)1;
                  }
                  {
#line 431
                  tmp___7 = realloc((void *)dialog_opts, need * sizeof(_Bool ));
#line 431
                  dialog_opts = (_Bool *)tmp___7;
                  }
#line 432
                  if ((unsigned long )dialog_opts == (unsigned long )((_Bool *)0)) {
                    {
#line 432
                    dlg_exiterr("cannot allocate memory in unescape_argv");
                    }
                  }
                }
#line 434
                n = *argcp;
                {
#line 434
                while (1) {
                  while_continue___2: /* CIL Label */ ;
#line 434
                  if (! (n >= j + 2)) {
#line 434
                    goto while_break___2;
                  }
#line 435
                  *(*argvp + ((n + added) - 2)) = *(*argvp + n);
#line 436
                  *(dialog_opts + ((n + added) - 2)) = *(dialog_opts + n);
#line 434
                  n --;
                }
                while_break___2: /* CIL Label */ ;
                }
#line 438
                n = 0;
                {
#line 438
                while (1) {
                  while_continue___3: /* CIL Label */ ;
#line 438
                  if (! (n < added)) {
#line 438
                    goto while_break___3;
                  }
#line 439
                  *(*argvp + (n + j)) = *(list + n);
#line 440
                  *(dialog_opts + (n + j)) = (_Bool)0;
#line 438
                  n ++;
                }
                while_break___3: /* CIL Label */ ;
                }
                {
#line 442
                *argcp += added - 2;
#line 443
                free((void *)list);
                }
              }
            } else {
              {
#line 446
              dlg_exiterr("Cannot open --file %s", filename);
              }
            }
#line 448
            *(*argvp + *argcp) = (char *)0;
#line 449
            j ++;
#line 450
            goto __Cont;
          } else {
            {
#line 452
            dlg_exiterr("No value given for --file");
            }
          }
        }
      } else {
        {
#line 373
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Showing arguments at arg%d\n",
                j);
#line 374
        k = 0;
        }
        {
#line 374
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 374
          if (! (k < *argcp)) {
#line 374
            goto while_break___4;
          }
          {
#line 375
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" arg%d:%s\n",
                  k, *(*argvp + k));
#line 374
          k ++;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 377
        tmp___1 = dlg_eat_argv(argcp, argvp, j, 1);
#line 377
        changed = (_Bool )tmp___1;
        }
      }
    } else {
      {
#line 370
      escaped = (_Bool)1;
#line 371
      tmp___0 = dlg_eat_argv(argcp, argvp, j, 1);
#line 371
      changed = (_Bool )tmp___0;
      }
    }
#line 455
    if (! escaped) {
#line 455
      if ((unsigned long )*(*argvp + j) != (unsigned long )((char *)0)) {
        {
#line 455
        tmp___11 = strncmp((char const   *)*(*argvp + j), "--", (size_t )2);
        }
#line 455
        if (! tmp___11) {
          {
#line 455
          tmp___12 = __ctype_b_loc();
          }
#line 455
          if ((int const   )*(*tmp___12 + (int )((unsigned char )*(*(*argvp + j) + 2))) & 1024) {
#line 459
            *(dialog_opts + j) = (_Bool)1;
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 367
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 466
  if (! changed) {
    {
#line 467
    free((void *)dialog_opts);
#line 468
    dialog_opts = (_Bool *)0;
    }
  }
#line 470
  dialog_argv = *argvp;
#line 471
  return;
}
}
#line 482 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
static _Bool isOption(char const   *arg ) 
{ 
  _Bool result ;
  int n ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
#line 485
  result = (_Bool)0;
#line 487
  if ((unsigned long )arg != (unsigned long )((char const   *)0)) {
#line 488
    if ((unsigned long )dialog_opts != (unsigned long )((_Bool *)0)) {
#line 490
      n = 1;
      {
#line 490
      while (1) {
        while_continue: /* CIL Label */ ;
#line 490
        if (! ((unsigned long )*(dialog_argv + n) != (unsigned long )((char *)0))) {
#line 490
          goto while_break;
        }
#line 491
        if ((unsigned long )*(dialog_argv + n) == (unsigned long )arg) {
#line 492
          result = *(dialog_opts + n);
#line 493
          goto while_break;
        }
#line 490
        n ++;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
#line 496
      tmp___1 = strncmp(arg, "--", (size_t )2);
      }
#line 496
      if (! tmp___1) {
        {
#line 496
        tmp___2 = __ctype_b_loc();
        }
#line 496
        if ((int const   )*(*tmp___2 + (int )((unsigned char )*(arg + 2))) & 1024) {
          {
#line 497
          tmp = strlen(arg);
#line 497
          tmp___0 = strspn(arg, "0123456789-abcdefghijklmnopqrstuvwxyz");
          }
#line 497
          if (tmp == tmp___0) {
#line 498
            result = (_Bool)1;
          } else {
            {
#line 500
            dlg_exiterr("Invalid option \"%s\"", arg);
            }
          }
        }
      }
    }
  }
#line 504
  return (result);
}
}
#line 507 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
static eOptions lookupOption(char const   *name , int pass ) 
{ 
  unsigned int n ;
  eOptions result ;
  int tmp ;
  _Bool tmp___0 ;

  {
  {
#line 511
  result = (eOptions )0;
#line 513
  tmp___0 = isOption(name);
  }
#line 513
  if (tmp___0) {
#line 514
    name += 2;
#line 515
    n = 0U;
    {
#line 515
    while (1) {
      while_continue: /* CIL Label */ ;
#line 515
      if (! ((unsigned long )n < sizeof(options) / sizeof(options[0]))) {
#line 515
        goto while_break;
      }
#line 516
      if ((pass & (int )options[n].pass) != 0) {
        {
#line 516
        tmp = strcmp(name, (char const   *)options[n].name);
        }
#line 516
        if (! tmp) {
#line 518
          result = (eOptions )options[n].code;
#line 519
          goto while_break;
        }
      }
#line 515
      n ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 523
  return (result);
}
}
#line 526 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
static void Usage(char const   *msg ) 
{ 


  {
  {
#line 529
  dlg_exiterr("Error: %s.\nUse --help to list options.\n\n", msg);
  }
#line 530
  return;
}
}
#line 536 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
static int arg_rest(char **argv ) 
{ 
  int i ;
  _Bool tmp ;
  eOptions tmp___0 ;

  {
#line 539
  i = 1;
  {
#line 541
  while (1) {
    while_continue: /* CIL Label */ ;
#line 541
    if ((unsigned long )*(argv + i) != (unsigned long )((char *)0)) {
      {
#line 541
      tmp = isOption((char const   *)*(argv + i));
      }
#line 541
      if (tmp) {
        {
#line 541
        tmp___0 = lookupOption((char const   *)*(argv + i), 7);
        }
#line 541
        if (! ((unsigned int )tmp___0 == 0U)) {
#line 541
          goto while_break;
        }
      }
    } else {
#line 541
      goto while_break;
    }
#line 543
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 544
  return (i);
}
}
#line 551 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
static int howmany_tags(char **argv , int group ) 
{ 
  int result ;
  int have ;
  char const   *format ;
  char temp[80] ;
  _Bool tmp ;

  {
#line 554
  result = 0;
#line 556
  format = "Expected %d arguments, found only %d";
  {
#line 559
  while (1) {
    while_continue: /* CIL Label */ ;
#line 559
    if (! ((unsigned long )*(argv + 0) != (unsigned long )((char *)0))) {
#line 559
      goto while_break;
    }
    {
#line 560
    tmp = isOption((char const   *)*(argv + 0));
    }
#line 560
    if (tmp) {
#line 561
      goto while_break;
    }
    {
#line 562
    have = arg_rest(argv);
    }
#line 562
    if (have < group) {
      {
#line 563
      sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)format,
              group, have);
#line 564
      Usage((char const   *)(temp));
      }
    }
#line 567
    argv += group;
#line 568
    result ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 571
  return (result);
}
}
#line 574 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
static int numeric_arg(char **av , int n ) 
{ 
  int result ;
  char msg[80] ;
  char *last ;
  long tmp ;
  int tmp___0 ;

  {
  {
#line 577
  result = 0;
#line 579
  tmp___0 = dlg_count_argv(av);
  }
#line 579
  if (n < tmp___0) {
    {
#line 581
    last = (char *)0;
#line 582
    tmp = strtol((char const   */* __restrict  */)*(av + n), (char **/* __restrict  */)(& last),
                 10);
#line 582
    result = (int )tmp;
    }
#line 584
    if ((unsigned long )last == (unsigned long )((char *)0)) {
      {
#line 585
      sprintf((char */* __restrict  */)(msg), (char const   */* __restrict  */)"Expected a number for token %d of %.20s",
              n, *(av + 0));
#line 586
      Usage((char const   *)(msg));
      }
    } else
#line 584
    if ((int )*last != 0) {
      {
#line 585
      sprintf((char */* __restrict  */)(msg), (char const   */* __restrict  */)"Expected a number for token %d of %.20s",
              n, *(av + 0));
#line 586
      Usage((char const   *)(msg));
      }
    }
  }
#line 589
  return (result);
}
}
#line 592 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
static char *optional_str(char **av , int n , char *dft ) 
{ 
  char *ret ;
  int tmp ;

  {
  {
#line 595
  ret = dft;
#line 596
  tmp = arg_rest(av);
  }
#line 596
  if (tmp > n) {
#line 597
    ret = *(av + n);
  }
#line 598
  return (ret);
}
}
#line 602 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
static int optional_num(char **av , int n , int dft ) 
{ 
  int ret ;
  int tmp ;

  {
  {
#line 605
  ret = dft;
#line 606
  tmp = arg_rest(av);
  }
#line 606
  if (tmp > n) {
    {
#line 607
    ret = numeric_arg(av, n);
    }
  }
#line 608
  return (ret);
}
}
#line 617 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
static int show_result(int ret ) 
{ 
  _Bool either ;
  char const   *tmp ;

  {
#line 620
  either = (_Bool)0;
  {
#line 626
  if (ret == 4) {
#line 626
    goto case_4;
  }
#line 626
  if (ret == 2) {
#line 626
    goto case_4;
  }
#line 626
  if (ret == 3) {
#line 626
    goto case_4;
  }
#line 626
  if (ret == 0) {
#line 626
    goto case_4;
  }
#line 622
  goto switch_break;
  case_4: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 627
  if (dialog_state.output_count > 1) {
#line 627
    if (! dialog_vars.separate_output) {
#line 628
      if (dialog_state.separate_str) {
#line 628
        tmp = (char const   *)dialog_state.separate_str;
      } else {
#line 628
        tmp = "\t";
      }
      {
#line 628
      fputs((char const   */* __restrict  */)tmp, (FILE */* __restrict  */)dialog_state.output);
#line 632
      either = (_Bool)1;
      }
    }
  }
#line 634
  if ((unsigned long )dialog_vars.input_result != (unsigned long )((char *)0)) {
#line 634
    if ((int )*(dialog_vars.input_result + 0) != 0) {
      {
#line 636
      fputs((char const   */* __restrict  */)dialog_vars.input_result, (FILE */* __restrict  */)dialog_state.output);
#line 637
      either = (_Bool)1;
      }
    }
  }
#line 639
  if (either) {
    {
#line 640
    fflush(dialog_state.output);
    }
  }
#line 642
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 644
  return (ret);
}
}
#line 651 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
static int call_yesno(char const   *t , char **av , int *offset_add ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 654
  *offset_add = 4;
#line 655
  tmp = numeric_arg(av, 3);
#line 655
  tmp___0 = numeric_arg(av, 2);
#line 655
  tmp___1 = dialog_yesno(t, (char const   *)*(av + 1), tmp___0, tmp);
  }
#line 655
  return (tmp___1);
}
}
#line 661 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
static int call_msgbox(char const   *t , char **av , int *offset_add ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 664
  *offset_add = 4;
#line 665
  tmp = numeric_arg(av, 3);
#line 665
  tmp___0 = numeric_arg(av, 2);
#line 665
  tmp___1 = dialog_msgbox(t, (char const   *)*(av + 1), tmp___0, tmp, 1);
  }
#line 665
  return (tmp___1);
}
}
#line 671 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
static int call_infobox(char const   *t , char **av , int *offset_add ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 674
  *offset_add = 4;
#line 675
  tmp = numeric_arg(av, 3);
#line 675
  tmp___0 = numeric_arg(av, 2);
#line 675
  tmp___1 = dialog_msgbox(t, (char const   *)*(av + 1), tmp___0, tmp, 0);
  }
#line 675
  return (tmp___1);
}
}
#line 681 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
static int call_textbox(char const   *t , char **av , int *offset_add ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 684
  *offset_add = 4;
#line 685
  tmp = numeric_arg(av, 3);
#line 685
  tmp___0 = numeric_arg(av, 2);
#line 685
  tmp___1 = dialog_textbox(t, (char const   *)*(av + 1), tmp___0, tmp);
  }
#line 685
  return (tmp___1);
}
}
#line 691 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
static int call_menu(char const   *t , char **av , int *offset_add ) 
{ 
  int tags ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 694
  if (dialog_vars.item_help) {
#line 694
    tmp = 1;
  } else {
#line 694
    tmp = 0;
  }
#line 694
  if (dialog_vars.no_items) {
#line 694
    tmp___0 = 0;
  } else {
#line 694
    tmp___0 = 1;
  }
  {
#line 694
  tmp___1 = howmany_tags(av + 5, (1 + tmp) + tmp___0);
#line 694
  tags = tmp___1;
  }
#line 695
  if (dialog_vars.item_help) {
#line 695
    tmp___2 = 1;
  } else {
#line 695
    tmp___2 = 0;
  }
#line 695
  if (dialog_vars.no_items) {
#line 695
    tmp___3 = 0;
  } else {
#line 695
    tmp___3 = 1;
  }
  {
#line 695
  *offset_add = 5 + tags * ((1 + tmp___2) + tmp___3);
#line 697
  tmp___4 = numeric_arg(av, 4);
#line 697
  tmp___5 = numeric_arg(av, 3);
#line 697
  tmp___6 = numeric_arg(av, 2);
#line 697
  tmp___7 = dialog_menu(t, (char const   *)*(av + 1), tmp___6, tmp___5, tmp___4, tags,
                        av + 5);
  }
#line 697
  return (tmp___7);
}
}
#line 705 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
static int call_inputmenu(char const   *t , char **av , int *offset_add ) 
{ 
  int tags ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  _Bool free_extra_label ;
  int result ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 708
  if (dialog_vars.item_help) {
#line 708
    tmp = 1;
  } else {
#line 708
    tmp = 0;
  }
#line 708
  if (dialog_vars.no_items) {
#line 708
    tmp___0 = 0;
  } else {
#line 708
    tmp___0 = 1;
  }
  {
#line 708
  tmp___1 = howmany_tags(av + 5, (1 + tmp) + tmp___0);
#line 708
  tags = tmp___1;
#line 709
  free_extra_label = (_Bool)0;
#line 712
  dialog_vars.input_menu = (_Bool)1;
  }
#line 714
  if (dialog_vars.max_input == 0) {
#line 715
    dialog_vars.max_input = 1024;
  }
#line 717
  if ((unsigned long )dialog_vars.extra_label == (unsigned long )((char *)0)) {
    {
#line 718
    free_extra_label = (_Bool)1;
#line 719
    dialog_vars.extra_label = dlg_strclone("Rename");
    }
  }
#line 722
  dialog_vars.extra_button = (_Bool)1;
#line 724
  if (dialog_vars.item_help) {
#line 724
    tmp___2 = 1;
  } else {
#line 724
    tmp___2 = 0;
  }
#line 724
  if (dialog_vars.no_items) {
#line 724
    tmp___3 = 0;
  } else {
#line 724
    tmp___3 = 1;
  }
  {
#line 724
  *offset_add = 5 + tags * ((1 + tmp___2) + tmp___3);
#line 725
  tmp___4 = numeric_arg(av, 4);
#line 725
  tmp___5 = numeric_arg(av, 3);
#line 725
  tmp___6 = numeric_arg(av, 2);
#line 725
  result = dialog_menu(t, (char const   *)*(av + 1), tmp___6, tmp___5, tmp___4, tags,
                       av + 5);
  }
#line 731
  if (free_extra_label) {
    {
#line 732
    free((void *)dialog_vars.extra_label);
#line 733
    dialog_vars.extra_label = (char *)0;
    }
  }
#line 735
  return (result);
}
}
#line 738 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
static int call_checklist(char const   *t , char **av , int *offset_add ) 
{ 
  int tags ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int code ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 741
  if (dialog_vars.item_help) {
#line 741
    tmp = 1;
  } else {
#line 741
    tmp = 0;
  }
#line 741
  if (dialog_vars.no_items) {
#line 741
    tmp___0 = 0;
  } else {
#line 741
    tmp___0 = 1;
  }
  {
#line 741
  tmp___1 = howmany_tags(av + 5, (2 + tmp) + tmp___0);
#line 741
  tags = tmp___1;
  }
#line 744
  if (dialog_vars.item_help) {
#line 744
    tmp___2 = 1;
  } else {
#line 744
    tmp___2 = 0;
  }
#line 744
  if (dialog_vars.no_items) {
#line 744
    tmp___3 = 0;
  } else {
#line 744
    tmp___3 = 1;
  }
  {
#line 744
  *offset_add = 5 + tags * ((2 + tmp___2) + tmp___3);
#line 745
  tmp___4 = numeric_arg(av, 4);
#line 745
  tmp___5 = numeric_arg(av, 3);
#line 745
  tmp___6 = numeric_arg(av, 2);
#line 745
  code = dialog_checklist(t, (char const   *)*(av + 1), tmp___6, tmp___5, tmp___4,
                          tags, av + 5, 1);
  }
#line 751
  return (code);
}
}
#line 754 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
static int call_radiolist(char const   *t , char **av , int *offset_add ) 
{ 
  int tags ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 757
  if (dialog_vars.item_help) {
#line 757
    tmp = 1;
  } else {
#line 757
    tmp = 0;
  }
#line 757
  if (dialog_vars.no_items) {
#line 757
    tmp___0 = 0;
  } else {
#line 757
    tmp___0 = 1;
  }
  {
#line 757
  tmp___1 = howmany_tags(av + 5, (2 + tmp) + tmp___0);
#line 757
  tags = tmp___1;
  }
#line 758
  if (dialog_vars.item_help) {
#line 758
    tmp___2 = 1;
  } else {
#line 758
    tmp___2 = 0;
  }
#line 758
  if (dialog_vars.no_items) {
#line 758
    tmp___3 = 0;
  } else {
#line 758
    tmp___3 = 1;
  }
  {
#line 758
  *offset_add = 5 + tags * ((2 + tmp___2) + tmp___3);
#line 759
  tmp___4 = numeric_arg(av, 4);
#line 759
  tmp___5 = numeric_arg(av, 3);
#line 759
  tmp___6 = numeric_arg(av, 2);
#line 759
  tmp___7 = dialog_checklist(t, (char const   *)*(av + 1), tmp___6, tmp___5, tmp___4,
                             tags, av + 5, 0);
  }
#line 759
  return (tmp___7);
}
}
#line 767 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
static int call_inputbox(char const   *t , char **av , int *offset_add ) 
{ 
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 770
  *offset_add = arg_rest(av);
#line 771
  tmp = optional_str(av, 4, (char *)0);
#line 771
  tmp___0 = numeric_arg(av, 3);
#line 771
  tmp___1 = numeric_arg(av, 2);
#line 771
  tmp___2 = dialog_inputbox(t, (char const   *)*(av + 1), tmp___1, tmp___0, (char const   *)tmp,
                            (int const   )0);
  }
#line 771
  return (tmp___2);
}
}
#line 778 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
static int call_passwordbox(char const   *t , char **av , int *offset_add ) 
{ 
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 781
  *offset_add = arg_rest(av);
#line 782
  tmp = optional_str(av, 4, (char *)0);
#line 782
  tmp___0 = numeric_arg(av, 3);
#line 782
  tmp___1 = numeric_arg(av, 2);
#line 782
  tmp___2 = dialog_inputbox(t, (char const   *)*(av + 1), tmp___1, tmp___0, (char const   *)tmp,
                            (int const   )1);
  }
#line 782
  return (tmp___2);
}
}
#line 790 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
static int call_calendar(char const   *t , char **av , int *offset_add ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 793
  *offset_add = arg_rest(av);
#line 794
  tmp = optional_num(av, 6, -1);
#line 794
  tmp___0 = optional_num(av, 5, -1);
#line 794
  tmp___1 = optional_num(av, 4, -1);
#line 794
  tmp___2 = numeric_arg(av, 3);
#line 794
  tmp___3 = numeric_arg(av, 2);
#line 794
  tmp___4 = dialog_calendar(t, (char const   *)*(av + 1), tmp___3, tmp___2, tmp___1,
                            tmp___0, tmp);
  }
#line 794
  return (tmp___4);
}
}
#line 803 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
static int call_dselect(char const   *t , char **av , int *offset_add ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 806
  *offset_add = arg_rest(av);
#line 807
  tmp = numeric_arg(av, 3);
#line 807
  tmp___0 = numeric_arg(av, 2);
#line 807
  tmp___1 = dialog_dselect(t, (char const   *)*(av + 1), tmp___0, tmp);
  }
#line 807
  return (tmp___1);
}
}
#line 813 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
static int call_editbox(char const   *t , char **av , int *offset_add ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 816
  *offset_add = 4;
#line 817
  tmp = numeric_arg(av, 3);
#line 817
  tmp___0 = numeric_arg(av, 2);
#line 817
  tmp___1 = dialog_editbox(t, (char const   *)*(av + 1), tmp___0, tmp);
  }
#line 817
  return (tmp___1);
}
}
#line 823 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
static int call_fselect(char const   *t , char **av , int *offset_add ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 826
  *offset_add = arg_rest(av);
#line 827
  tmp = numeric_arg(av, 3);
#line 827
  tmp___0 = numeric_arg(av, 2);
#line 827
  tmp___1 = dialog_fselect(t, (char const   *)*(av + 1), tmp___0, tmp);
  }
#line 827
  return (tmp___1);
}
}
#line 833 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
static int call_timebox(char const   *t , char **av , int *offset_add ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 836
  *offset_add = arg_rest(av);
#line 837
  tmp = optional_num(av, 6, -1);
#line 837
  tmp___0 = optional_num(av, 5, -1);
#line 837
  tmp___1 = optional_num(av, 4, -1);
#line 837
  tmp___2 = numeric_arg(av, 3);
#line 837
  tmp___3 = numeric_arg(av, 2);
#line 837
  tmp___4 = dialog_timebox(t, (char const   *)*(av + 1), tmp___3, tmp___2, tmp___1,
                           tmp___0, tmp);
  }
#line 837
  return (tmp___4);
}
}
#line 860 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
static int call_buildlist(char const   *t , char **av , int *offset_add ) 
{ 
  int tags ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int result ;
  _Bool save_no_tags ;
  _Bool save_no_items ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 863
  if (dialog_vars.item_help) {
#line 863
    tmp = 1;
  } else {
#line 863
    tmp = 0;
  }
#line 863
  if (dialog_vars.no_items) {
#line 863
    tmp___0 = 0;
  } else {
#line 863
    tmp___0 = 1;
  }
  {
#line 863
  tmp___1 = howmany_tags(av + 5, (2 + tmp) + tmp___0);
#line 863
  tags = tmp___1;
#line 866
  save_no_tags = dialog_vars.no_tags;
#line 866
  save_no_items = dialog_vars.no_items;
#line 866
  dialog_vars.no_tags = (_Bool)1;
#line 866
  dialog_vars.no_items = (_Bool)0;
  }
#line 868
  if (dialog_vars.item_help) {
#line 868
    tmp___2 = 1;
  } else {
#line 868
    tmp___2 = 0;
  }
#line 868
  if (dialog_vars.no_items) {
#line 868
    tmp___3 = 0;
  } else {
#line 868
    tmp___3 = 1;
  }
  {
#line 868
  *offset_add = 5 + tags * ((2 + tmp___2) + tmp___3);
#line 869
  tmp___4 = numeric_arg(av, 4);
#line 869
  tmp___5 = numeric_arg(av, 3);
#line 869
  tmp___6 = numeric_arg(av, 2);
#line 869
  result = dialog_buildlist(t, (char const   *)*(av + 1), tmp___6, tmp___5, tmp___4,
                            tags, av + 5, 1);
#line 876
  dialog_vars.no_tags = save_no_tags;
#line 876
  dialog_vars.no_items = save_no_items;
  }
#line 877
  return (result);
}
}
#line 880 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
static int call_rangebox(char const   *t , char **av , int *offset_add ) 
{ 
  int min_value ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 885
  *offset_add = arg_rest(av);
#line 886
  min_value = numeric_arg(av, 4);
  }
#line 887
  if (*offset_add > 6) {
    {
#line 887
    tmp = numeric_arg(av, 6);
#line 887
    tmp___0 = tmp;
    }
  } else {
#line 887
    tmp___0 = min_value;
  }
  {
#line 887
  tmp___1 = numeric_arg(av, 5);
#line 887
  tmp___2 = numeric_arg(av, 3);
#line 887
  tmp___3 = numeric_arg(av, 2);
#line 887
  tmp___4 = dialog_rangebox(t, (char const   *)*(av + 1), tmp___3, tmp___2, min_value,
                            tmp___1, tmp___0);
  }
#line 887
  return (tmp___4);
}
}
#line 896 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
static int call_treeview(char const   *t , char **av , int *offset_add ) 
{ 
  int tags ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int result ;
  _Bool save_no_tags ;
  _Bool save_no_items ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 899
  if (dialog_vars.item_help) {
#line 899
    tmp = 1;
  } else {
#line 899
    tmp = 0;
  }
#line 899
  if (dialog_vars.no_items) {
#line 899
    tmp___0 = 0;
  } else {
#line 899
    tmp___0 = 1;
  }
  {
#line 899
  tmp___1 = howmany_tags(av + 5, (3 + tmp) + tmp___0);
#line 899
  tags = tmp___1;
#line 902
  save_no_tags = dialog_vars.no_tags;
#line 902
  save_no_items = dialog_vars.no_items;
#line 902
  dialog_vars.no_tags = (_Bool)1;
#line 902
  dialog_vars.no_items = (_Bool)0;
#line 904
  *offset_add = arg_rest(av);
#line 905
  tmp___2 = numeric_arg(av, 4);
#line 905
  tmp___3 = numeric_arg(av, 3);
#line 905
  tmp___4 = numeric_arg(av, 2);
#line 905
  result = dialog_treeview(t, (char const   *)*(av + 1), tmp___4, tmp___3, tmp___2,
                           tags, av + 5, 0);
#line 911
  dialog_vars.no_tags = save_no_tags;
#line 911
  dialog_vars.no_items = save_no_items;
  }
#line 912
  return (result);
}
}
#line 917 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
static int call_form(char const   *t , char **av , int *offset_add ) 
{ 
  int group ;
  int tmp ;
  int tags ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 920
  if (dialog_vars.item_help) {
#line 920
    tmp = 1;
  } else {
#line 920
    tmp = 0;
  }
  {
#line 920
  group = 8 + tmp;
#line 921
  tmp___0 = howmany_tags(av + 5, group);
#line 921
  tags = tmp___0;
#line 922
  *offset_add = 5 + tags * group;
#line 924
  tmp___1 = numeric_arg(av, 4);
#line 924
  tmp___2 = numeric_arg(av, 3);
#line 924
  tmp___3 = numeric_arg(av, 2);
#line 924
  tmp___4 = dialog_form(t, (char const   *)*(av + 1), tmp___3, tmp___2, tmp___1, tags,
                        av + 5);
  }
#line 924
  return (tmp___4);
}
}
#line 932 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
static int call_password_form(char const   *t , char **av , int *offset_add ) 
{ 
  unsigned int save ;
  int result ;

  {
  {
#line 935
  save = dialog_vars.formitem_type;
#line 938
  dialog_vars.formitem_type = 1U;
#line 939
  result = call_form(t, av, offset_add);
#line 940
  dialog_vars.formitem_type = save;
  }
#line 942
  return (result);
}
}
#line 947 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
static int call_mixed_form(char const   *t , char **av , int *offset_add ) 
{ 
  int group ;
  int tmp ;
  int tags ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 950
  if (dialog_vars.item_help) {
#line 950
    tmp = 1;
  } else {
#line 950
    tmp = 0;
  }
  {
#line 950
  group = 1 + (8 + tmp);
#line 951
  tmp___0 = howmany_tags(av + 5, group);
#line 951
  tags = tmp___0;
#line 952
  *offset_add = 5 + tags * group;
#line 954
  tmp___1 = numeric_arg(av, 4);
#line 954
  tmp___2 = numeric_arg(av, 3);
#line 954
  tmp___3 = numeric_arg(av, 2);
#line 954
  tmp___4 = dialog_mixedform(t, (char const   *)*(av + 1), tmp___3, tmp___2, tmp___1,
                             tags, av + 5);
  }
#line 954
  return (tmp___4);
}
}
#line 964 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
static int call_gauge(char const   *t , char **av , int *offset_add ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 967
  *offset_add = arg_rest(av);
#line 968
  tmp = optional_num(av, 4, 0);
#line 968
  tmp___0 = numeric_arg(av, 3);
#line 968
  tmp___1 = numeric_arg(av, 2);
#line 968
  tmp___2 = dialog_gauge(t, (char const   *)*(av + 1), tmp___1, tmp___0, tmp);
  }
#line 968
  return (tmp___2);
}
}
#line 975 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
static int call_pause(char const   *t , char **av , int *offset_add ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 978
  *offset_add = arg_rest(av);
#line 979
  tmp = numeric_arg(av, 4);
#line 979
  tmp___0 = numeric_arg(av, 3);
#line 979
  tmp___1 = numeric_arg(av, 2);
#line 979
  tmp___2 = dialog_pause(t, (char const   *)*(av + 1), tmp___1, tmp___0, tmp);
  }
#line 979
  return (tmp___2);
}
}
#line 988 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
static int call_mixed_gauge(char const   *t , char **av , int *offset_add ) 
{ 
  int tags ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 992
  tmp = howmany_tags(av + 5, 2);
#line 992
  tags = tmp;
#line 993
  *offset_add = 5 + tags * 2;
#line 994
  tmp___0 = numeric_arg(av, 4);
#line 994
  tmp___1 = numeric_arg(av, 3);
#line 994
  tmp___2 = numeric_arg(av, 2);
#line 994
  tmp___3 = dialog_mixedgauge(t, (char const   *)*(av + 1), tmp___2, tmp___1, tmp___0,
                              tags, av + 5);
  }
#line 994
  return (tmp___3);
}
}
#line 1004 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
static int call_prgbox(char const   *t , char **av , int *offset_add ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 1007
  *offset_add = arg_rest(av);
  }
#line 1011
  if (*offset_add == 5) {
    {
#line 1011
    tmp = numeric_arg(av, 4);
#line 1011
    tmp___0 = numeric_arg(av, 3);
#line 1011
    tmp___1 = dialog_prgbox(t, (char const   *)*(av + 1), (char const   *)*(av + 2),
                            tmp___0, tmp, 1);
#line 1011
    tmp___5 = tmp___1;
    }
  } else {
    {
#line 1011
    tmp___2 = numeric_arg(av, 3);
#line 1011
    tmp___3 = numeric_arg(av, 2);
#line 1011
    tmp___4 = dialog_prgbox(t, "", (char const   *)*(av + 1), tmp___3, tmp___2, 1);
#line 1011
    tmp___5 = tmp___4;
    }
  }
#line 1011
  return (tmp___5);
}
}
#line 1026 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
static int call_programbox(char const   *t , char **av , int *offset_add ) 
{ 
  int result ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 1031
  *offset_add = arg_rest(av);
  }
#line 1034
  if (*offset_add == 4) {
    {
#line 1034
    tmp = numeric_arg(av, 3);
#line 1034
    tmp___0 = numeric_arg(av, 2);
#line 1034
    tmp___1 = dlg_progressbox(t, (char const   *)*(av + 1), tmp___0, tmp, 1, dialog_state.pipe_input);
#line 1034
    result = tmp___1;
    }
  } else {
    {
#line 1034
    tmp___2 = numeric_arg(av, 2);
#line 1034
    tmp___3 = numeric_arg(av, 1);
#line 1034
    tmp___4 = dlg_progressbox(t, "", tmp___3, tmp___2, 1, dialog_state.pipe_input);
#line 1034
    result = tmp___4;
    }
  }
#line 1047
  dialog_state.pipe_input = (FILE *)0;
#line 1048
  return (result);
}
}
#line 1053 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
static int call_progressbox(char const   *t , char **av , int *offset_add ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 1056
  *offset_add = arg_rest(av);
  }
#line 1060
  if (*offset_add == 4) {
    {
#line 1060
    tmp = numeric_arg(av, 3);
#line 1060
    tmp___0 = numeric_arg(av, 2);
#line 1060
    tmp___1 = dialog_progressbox(t, (char const   *)*(av + 1), tmp___0, tmp);
#line 1060
    tmp___5 = tmp___1;
    }
  } else {
    {
#line 1060
    tmp___2 = numeric_arg(av, 2);
#line 1060
    tmp___3 = numeric_arg(av, 1);
#line 1060
    tmp___4 = dialog_progressbox(t, "", tmp___3, tmp___2);
#line 1060
    tmp___5 = tmp___4;
    }
  }
#line 1060
  return (tmp___5);
}
}
#line 1073 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
static int call_tailbox(char const   *t , char **av , int *offset_add ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1076
  *offset_add = 4;
#line 1077
  tmp = numeric_arg(av, 3);
#line 1077
  tmp___0 = numeric_arg(av, 2);
#line 1077
  tmp___1 = dialog_tailbox(t, (char const   *)*(av + 1), tmp___0, tmp, 0);
  }
#line 1077
  return (tmp___1);
}
}
#line 1084 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
static int call_tailboxbg(char const   *t , char **av , int *offset_add ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1087
  *offset_add = 4;
#line 1088
  tmp = numeric_arg(av, 3);
#line 1088
  tmp___0 = numeric_arg(av, 2);
#line 1088
  tmp___1 = dialog_tailbox(t, (char const   *)*(av + 1), tmp___0, tmp, 1);
  }
#line 1088
  return (tmp___1);
}
}
#line 1096 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
static Mode___0 const   modes[29]  = 
#line 1096
  {      {(eOptions )102, 4, 4, & call_yesno}, 
        {(eOptions )50, 4, 4, & call_msgbox}, 
        {(eOptions )36, 4, 4, & call_infobox}, 
        {(eOptions )92, 4, 4, & call_textbox}, 
        {(eOptions )47, 7, 0, & call_menu}, 
        {(eOptions )39, 7, 0, & call_inputmenu}, 
        {(eOptions )11, 8, 0, & call_checklist}, 
        {(eOptions )75, 8, 0, & call_radiolist}, 
        {(eOptions )38, 4, 5, & call_inputbox}, 
        {(eOptions )65, 4, 5, & call_passwordbox}, 
        {(eOptions )26, 4, 5, & call_gauge}, 
        {(eOptions )67, 5, 5, & call_pause}, 
        {(eOptions )68, 4, 5, & call_prgbox}, 
        {(eOptions )72, 3, 4, & call_programbox}, 
        {(eOptions )73, 3, 4, & call_progressbox}, 
        {(eOptions )66, 13, 0, & call_password_form}, 
        {(eOptions )25, 13, 0, & call_form}, 
        {(eOptions )49, 5, 0, & call_mixed_gauge}, 
        {(eOptions )48, 13, 0, & call_mixed_form}, 
        {(eOptions )90, 4, 4, & call_tailbox}, 
        {(eOptions )91, 4, 4, & call_tailboxbg}, 
        {(eOptions )110, 4, 0, & call_buildlist}, 
        {(eOptions )105, 4, 7, & call_calendar}, 
        {(eOptions )106, 4, 5, & call_dselect}, 
        {(eOptions )107, 4, 4, & call_editbox}, 
        {(eOptions )108, 4, 5, & call_fselect}, 
        {(eOptions )111, 5, 7, & call_rangebox}, 
        {(eOptions )109, 4, 7, & call_timebox}, 
        {(eOptions )112, 4, 0, & call_treeview}};
#line 1142 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
static char *optionString(char **argv , int *num ) 
{ 
  int next ;
  char *result ;
  char temp[80] ;

  {
#line 1145
  next = *num + 1;
#line 1146
  result = *(argv + next);
#line 1147
  if ((unsigned long )result == (unsigned long )((char *)0)) {
    {
#line 1149
    sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)"Expected a string-parameter for %.20s",
            *(argv + *num));
#line 1150
    Usage((char const   *)(temp));
    }
  }
#line 1152
  *num = next;
#line 1153
  return (result);
}
}
#line 1156 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
static int optionValue(char **argv , int *num ) 
{ 
  int next ;
  char *src ;
  char *tmp ;
  int result ;
  long tmp___0 ;
  char temp[80] ;

  {
#line 1159
  next = *num + 1;
#line 1160
  src = *(argv + next);
#line 1161
  tmp = (char *)0;
#line 1162
  result = 0;
#line 1164
  if ((unsigned long )src != (unsigned long )((char *)0)) {
    {
#line 1165
    tmp___0 = strtol((char const   */* __restrict  */)src, (char **/* __restrict  */)(& tmp),
                     0);
#line 1165
    result = (int )tmp___0;
    }
#line 1166
    if ((unsigned long )tmp == (unsigned long )((char *)0)) {
#line 1167
      src = (char *)0;
    } else
#line 1166
    if ((int )*tmp != 0) {
#line 1167
      src = (char *)0;
    }
  }
#line 1170
  if ((unsigned long )src == (unsigned long )((char *)0)) {
    {
#line 1172
    sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)"Expected a numeric-parameter for %.20s",
            *(argv + *num));
#line 1173
    Usage((char const   *)(temp));
    }
  }
#line 1175
  *num = next;
#line 1176
  return (result);
}
}
#line 1184
static int button_code(char const   *name ) ;
#line 1184 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
static struct __anonstruct_table_67 table[6]  = {      {"ok", 0}, 
        {"yes", 0}, 
        {"cancel", 1}, 
        {"no", 1}, 
        {"help", 2}, 
        {"extra", 3}};
#line 1180 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
static int button_code(char const   *name ) 
{ 
  int code ;
  size_t i ;
  int tmp ;
  char temp[80] ;

  {
#line 1197
  code = -1;
#line 1200
  i = (size_t )0;
  {
#line 1200
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1200
    if (! (i < sizeof(table) / sizeof(table[0]))) {
#line 1200
      goto while_break;
    }
    {
#line 1201
    tmp = strcasecmp(name, table[i].name);
    }
#line 1201
    if (! tmp) {
#line 1202
      code = table[i].code;
#line 1203
      goto while_break;
    }
#line 1200
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1207
  if (code == -1) {
    {
#line 1209
    sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)"Button name \"%.20s\" unknown",
            name);
#line 1210
    Usage((char const   *)(temp));
    }
  }
#line 1213
  return (code);
}
}
#line 1219 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
static void PrintList(char const   * const  *list ) 
{ 
  char const   *leaf ;
  char *tmp ;
  unsigned int n ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 1222
  tmp = strrchr(program, '/');
#line 1222
  leaf = (char const   *)tmp;
#line 1223
  n = 0U;
  }
#line 1225
  if ((unsigned long )leaf != (unsigned long )((char const   *)0)) {
#line 1226
    leaf ++;
  } else {
#line 1228
    leaf = program;
  }
  {
#line 1230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1230
    if (! ((unsigned long )*list != (unsigned long )((char const   */* const  */)0))) {
#line 1230
      goto while_break;
    }
#line 1231
    if (n) {
#line 1231
      tmp___1 = leaf;
    } else {
      {
#line 1231
      tmp___0 = dialog_version();
#line 1231
      tmp___1 = tmp___0;
      }
    }
    {
#line 1231
    fprintf((FILE */* __restrict  */)dialog_state.output, (char const   */* __restrict  */)*list,
            tmp___1);
#line 1232
    fputc('\n', dialog_state.output);
#line 1233
    n = 1U;
#line 1234
    list ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1236
  return;
}
}
#line 1238 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
static Mode___0 const   *lookupMode(eOptions code ) 
{ 
  Mode___0 const   *modePtr ;
  unsigned int n ;

  {
#line 1241
  modePtr = (Mode___0 const   *)0;
#line 1244
  n = 0U;
  {
#line 1244
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1244
    if (! ((unsigned long )n < sizeof(modes) / sizeof(modes[0]))) {
#line 1244
      goto while_break;
    }
#line 1245
    if ((unsigned int const   )modes[n].code == (unsigned int const   )code) {
#line 1246
      modePtr = & modes[n];
#line 1247
      goto while_break;
    }
#line 1244
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1250
  return (modePtr);
}
}
#line 1253 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
static int compare_opts(void const   *a , void const   *b ) 
{ 
  Options * const  *p ;
  Options * const  *q ;
  int tmp ;

  {
  {
#line 1256
  p = (Options * const  *)a;
#line 1257
  q = (Options * const  *)b;
#line 1258
  tmp = strcmp((*p)->name, (*q)->name);
  }
#line 1258
  return (tmp);
}
}
#line 1264 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
static void PrintVersion(FILE *fp ) 
{ 
  char const   *tmp ;

  {
  {
#line 1267
  tmp = dialog_version();
#line 1267
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"Version: %s\n",
          tmp);
  }
#line 1268
  return;
}
}
#line 1276
static void Help(void) ;
#line 1276 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
static char const   * const  tbl_1[13]  = 
#line 1276
  {      (char const   */* const  */)"cdialog (ComeOn Dialog!) version %s",      (char const   */* const  */)"Copyright 2000-2012,2013 Thomas E. Dickey",      (char const   */* const  */)"This is free software; see the source for copying conditions.  There is NO",      (char const   */* const  */)"warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.", 
        (char const   */* const  */)"",      (char const   */* const  */)"* Display dialog boxes from shell scripts *",      (char const   */* const  */)"",      (char const   */* const  */)"Usage: %s <options> { --and-widget <options> }", 
        (char const   */* const  */)"where options are \"common\" options, followed by \"box\" options",      (char const   */* const  */)"",      (char const   */* const  */)"Special options:",      (char const   */* const  */)"  [--create-rc \"file\"]", 
        (char const   */* const  */)0};
#line 1276 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
static char const   * const  tbl_3[4]  = {      (char const   */* const  */)"",      (char const   */* const  */)"Auto-size with height and width = 0. Maximize with height and width = -1.",      (char const   */* const  */)"Global-auto-size if also menu_height/list_height = 0.",      (char const   */* const  */)0};
#line 1273 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
static void Help(void) 
{ 
  size_t limit ;
  size_t j ;
  size_t k ;
  Options const   **opts ;
  void *tmp ;
  size_t len ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char const   *tmp___2 ;
  Mode___0 const   *tmp___3 ;

  {
  {
#line 1300
  limit = sizeof(options) / sizeof(options[0]);
#line 1304
  end_dialog();
#line 1305
  dialog_state.output = stdout;
#line 1307
  tmp = calloc(limit, sizeof(Options const   *));
#line 1307
  opts = (Options const   **)tmp;
  }
#line 1308
  if ((unsigned long )opts == (unsigned long )((Options const   **)0)) {
    {
#line 1308
    dlg_exiterr("cannot allocate memory in Help");
    }
  }
#line 1309
  j = (size_t )0;
  {
#line 1309
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1309
    if (! (j < limit)) {
#line 1309
      goto while_break;
    }
#line 1310
    *(opts + j) = & options[j];
#line 1309
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1312
  qsort((void *)opts, limit, sizeof(Options *), & compare_opts);
#line 1314
  PrintList(tbl_1);
#line 1315
  fprintf((FILE */* __restrict  */)dialog_state.output, (char const   */* __restrict  */)"Common options:\n ");
#line 1316
  k = (size_t )0;
#line 1316
  j = k;
  }
  {
#line 1316
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1316
    if (! (j < limit)) {
#line 1316
      goto while_break___0;
    }
#line 1317
    if ((*(opts + j))->pass & 1) {
#line 1317
      if ((unsigned long )(*(opts + j))->help != (unsigned long )((char const   */* const  */)0)) {
        {
#line 1319
        tmp___0 = strlen((char const   *)(*(opts + j))->name);
#line 1319
        tmp___1 = strlen((char const   *)(*(opts + j))->help);
#line 1319
        len = (6UL + tmp___0) + tmp___1;
#line 1320
        k += len;
        }
#line 1321
        if (k > 75UL) {
          {
#line 1322
          fprintf((FILE */* __restrict  */)dialog_state.output, (char const   */* __restrict  */)"\n ");
#line 1323
          k = len;
          }
        }
#line 1325
        if (*((*(opts + j))->help)) {
#line 1325
          tmp___2 = " ";
        } else {
#line 1325
          tmp___2 = "";
        }
        {
#line 1325
        fprintf((FILE */* __restrict  */)dialog_state.output, (char const   */* __restrict  */)" [--%s%s%s]",
                (*(opts + j))->name, tmp___2, (*(opts + j))->help);
        }
      }
    }
#line 1316
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1329
  fprintf((FILE */* __restrict  */)dialog_state.output, (char const   */* __restrict  */)"\nBox options:\n");
#line 1330
  j = (size_t )0;
  }
  {
#line 1330
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1330
    if (! (j < limit)) {
#line 1330
      goto while_break___1;
    }
#line 1331
    if (((*(opts + j))->pass & 2) != 0) {
#line 1331
      if ((unsigned long )(*(opts + j))->help != (unsigned long )((char const   */* const  */)0)) {
        {
#line 1331
        tmp___3 = lookupMode((eOptions )(*(opts + j))->code);
        }
#line 1331
        if (tmp___3) {
          {
#line 1334
          fprintf((FILE */* __restrict  */)dialog_state.output, (char const   */* __restrict  */)"  --%-12s %s\n",
                  (*(opts + j))->name, (*(opts + j))->help);
          }
        }
      }
    }
#line 1330
    j ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1337
  PrintList(tbl_3);
#line 1339
  free((void *)opts);
#line 1340
  dlg_exit(0);
  }
#line 1341
  return;
}
}
#line 1350 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
static void process_trace_option(char **argv , int *offset ) 
{ 
  int j ;
  char *tmp ;

  {
#line 1355
  if ((unsigned long )dialog_state.trace_output == (unsigned long )((FILE *)0)) {
    {
#line 1356
    tmp = optionString(argv, offset);
#line 1356
    dlg_trace((char const   *)tmp);
    }
  } else {
    {
#line 1358
    dlg_trace_msg("# ignore extra --trace option\n");
#line 1359
    (*offset) ++;
    }
  }
  {
#line 1362
  dlg_trace_msg("# Parameters:\n");
#line 1363
  j = 0;
  }
  {
#line 1363
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1363
    if (! ((unsigned long )*(argv + j) != (unsigned long )((char *)0))) {
#line 1363
      goto while_break;
    }
    {
#line 1364
    dlg_trace_msg("# argv[%d] = %s\n", j, *(argv + j));
#line 1363
    j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1366
  return;
}
}
#line 1374 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
static int process_common_options(int argc , char **argv , int offset , _Bool output ) 
{ 
  _Bool done ;
  eOptions tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1377
  done = (_Bool)0;
#line 1379
  dlg_trace_msg("# process_common_options, offset %d\n", offset);
  }
  {
#line 1381
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1381
    if (offset < argc) {
#line 1381
      if (! (! done)) {
#line 1381
        goto while_break;
      }
    } else {
#line 1381
      goto while_break;
    }
    {
#line 1382
    dlg_trace_msg("#\targv[%d] = %s\n", offset, *(argv + offset));
#line 1383
    tmp = lookupOption((char const   *)*(argv + offset), 1);
    }
    {
#line 1384
    if ((unsigned int )tmp == 95U) {
#line 1384
      goto case_95;
    }
#line 1387
    if ((unsigned int )tmp == 6U) {
#line 1387
      goto case_6;
    }
#line 1390
    if ((unsigned int )tmp == 79U) {
#line 1390
      goto case_79;
    }
#line 1393
    if ((unsigned int )tmp == 78U) {
#line 1393
      goto case_78;
    }
#line 1396
    if ((unsigned int )tmp == 13U) {
#line 1396
      goto case_13;
    }
#line 1399
    if ((unsigned int )tmp == 15U) {
#line 1399
      goto case_15;
    }
#line 1402
    if ((unsigned int )tmp == 58U) {
#line 1402
      goto case_58;
    }
#line 1405
    if ((unsigned int )tmp == 52U) {
#line 1405
      goto case_52;
    }
#line 1408
    if ((unsigned int )tmp == 54U) {
#line 1408
      goto case_54;
    }
#line 1411
    if ((unsigned int )tmp == 60U) {
#line 1411
      goto case_60;
    }
#line 1414
    if ((unsigned int )tmp == 61U) {
#line 1414
      goto case_61;
    }
#line 1417
    if ((unsigned int )tmp == 74U) {
#line 1417
      goto case_74;
    }
#line 1420
    if ((unsigned int )tmp == 82U) {
#line 1420
      goto case_82;
    }
#line 1423
    if ((unsigned int )tmp == 83U) {
#line 1423
      goto case_83;
    }
#line 1426
    if ((unsigned int )tmp == 7U) {
#line 1426
      goto case_7;
    }
#line 1429
    if ((unsigned int )tmp == 8U) {
#line 1429
      goto case_8;
    }
#line 1432
    if ((unsigned int )tmp == 77U) {
#line 1432
      goto case_77;
    }
#line 1435
    if ((unsigned int )tmp == 81U) {
#line 1435
      goto case_81;
    }
#line 1438
    if ((unsigned int )tmp == 20U) {
#line 1438
      goto case_20;
    }
#line 1442
    if ((unsigned int )tmp == 18U) {
#line 1442
      goto case_18;
    }
#line 1446
    if ((unsigned int )tmp == 19U) {
#line 1446
      goto case_19;
    }
#line 1449
    if ((unsigned int )tmp == 40U) {
#line 1449
      goto case_40;
    }
#line 1452
    if ((unsigned int )tmp == 41U) {
#line 1452
      goto case_41;
    }
#line 1455
    if ((unsigned int )tmp == 31U) {
#line 1455
      goto case_31;
    }
#line 1458
    if ((unsigned int )tmp == 29U) {
#line 1458
      goto case_29;
    }
#line 1461
    if ((unsigned int )tmp == 28U) {
#line 1461
      goto case_28;
    }
#line 1464
    if ((unsigned int )tmp == 32U) {
#line 1464
      goto case_32;
    }
#line 1467
    if ((unsigned int )tmp == 33U) {
#line 1467
      goto case_33;
    }
#line 1470
    if ((unsigned int )tmp == 22U) {
#line 1470
      goto case_22;
    }
#line 1473
    if ((unsigned int )tmp == 35U) {
#line 1473
      goto case_35;
    }
#line 1476
    if ((unsigned int )tmp == 44U) {
#line 1476
      goto case_44;
    }
#line 1479
    if ((unsigned int )tmp == 45U) {
#line 1479
      goto case_45;
    }
#line 1482
    if ((unsigned int )tmp == 59U) {
#line 1482
      goto case_59;
    }
#line 1485
    if ((unsigned int )tmp == 70U) {
#line 1485
      goto case_70;
    }
#line 1488
    if ((unsigned int )tmp == 69U) {
#line 1488
      goto case_69;
    }
#line 1503
    if ((unsigned int )tmp == 71U) {
#line 1503
      goto case_71;
    }
#line 1509
    if ((unsigned int )tmp == 64U) {
#line 1509
      goto case_64;
    }
#line 1509
    if ((unsigned int )tmp == 80U) {
#line 1509
      goto case_64;
    }
#line 1512
    if ((unsigned int )tmp == 14U) {
#line 1512
      goto case_14;
    }
#line 1515
    if ((unsigned int )tmp == 88U) {
#line 1515
      goto case_88;
    }
#line 1518
    if ((unsigned int )tmp == 84U) {
#line 1518
      goto case_84;
    }
#line 1521
    if ((unsigned int )tmp == 94U) {
#line 1521
      goto case_94;
    }
#line 1524
    if ((unsigned int )tmp == 46U) {
#line 1524
      goto case_46;
    }
#line 1527
    if ((unsigned int )tmp == 89U) {
#line 1527
      goto case_89;
    }
#line 1530
    if ((unsigned int )tmp == 96U) {
#line 1530
      goto case_96;
    }
#line 1533
    if ((unsigned int )tmp == 99U) {
#line 1533
      goto case_99;
    }
#line 1537
    if ((unsigned int )tmp == 4U) {
#line 1537
      goto case_4;
    }
#line 1540
    if ((unsigned int )tmp == 9U) {
#line 1540
      goto case_9;
    }
#line 1545
    if ((unsigned int )tmp == 12U) {
#line 1545
      goto case_12;
    }
#line 1548
    if ((unsigned int )tmp == 101U) {
#line 1548
      goto case_101;
    }
#line 1551
    if ((unsigned int )tmp == 55U) {
#line 1551
      goto case_55;
    }
#line 1554
    if ((unsigned int )tmp == 62U) {
#line 1554
      goto case_62;
    }
#line 1557
    if ((unsigned int )tmp == 10U) {
#line 1557
      goto case_10;
    }
#line 1560
    if ((unsigned int )tmp == 23U) {
#line 1560
      goto case_23;
    }
#line 1563
    if ((unsigned int )tmp == 21U) {
#line 1563
      goto case_21;
    }
#line 1566
    if ((unsigned int )tmp == 30U) {
#line 1566
      goto case_30;
    }
#line 1569
    if ((unsigned int )tmp == 17U) {
#line 1569
      goto case_17;
    }
#line 1572
    if ((unsigned int )tmp == 93U) {
#line 1572
      goto case_93;
    }
#line 1575
    if ((unsigned int )tmp == 43U) {
#line 1575
      goto case_43;
    }
#line 1578
    if ((unsigned int )tmp == 3U) {
#line 1578
      goto case_3;
    }
#line 1582
    if ((unsigned int )tmp == 56U) {
#line 1582
      goto case_56;
    }
#line 1586
    if ((unsigned int )tmp == 57U) {
#line 1586
      goto case_57;
    }
#line 1591
    if ((unsigned int )tmp == 104U) {
#line 1591
      goto case_104;
    }
#line 1596
    if ((unsigned int )tmp == 103U) {
#line 1596
      goto case_103;
    }
#line 1602
    if ((unsigned int )tmp == 100U) {
#line 1602
      goto case_100;
    }
#line 1602
    if ((unsigned int )tmp == 34U) {
#line 1602
      goto case_100;
    }
#line 1613
    if ((unsigned int )tmp == 97U) {
#line 1613
      goto case_97;
    }
#line 1613
    if ((unsigned int )tmp == 85U) {
#line 1613
      goto case_97;
    }
#line 1613
    if ((unsigned int )tmp == 76U) {
#line 1613
      goto case_97;
    }
#line 1613
    if ((unsigned int )tmp == 53U) {
#line 1613
      goto case_97;
    }
#line 1613
    if ((unsigned int )tmp == 51U) {
#line 1613
      goto case_97;
    }
#line 1613
    if ((unsigned int )tmp == 42U) {
#line 1613
      goto case_97;
    }
#line 1613
    if ((unsigned int )tmp == 24U) {
#line 1613
      goto case_97;
    }
#line 1613
    if ((unsigned int )tmp == 5U) {
#line 1613
      goto case_97;
    }
#line 1613
    if ((unsigned int )tmp == 1U) {
#line 1613
      goto case_97;
    }
#line 1615
    if ((unsigned int )tmp == 0U) {
#line 1615
      goto case_0;
    }
#line 1623
    if ((unsigned int )tmp == 115U) {
#line 1623
      goto case_115;
    }
#line 1628
    if ((unsigned int )tmp == 113U) {
#line 1628
      goto case_113;
    }
#line 1631
    if ((unsigned int )tmp == 114U) {
#line 1631
      goto case_114;
    }
#line 1619
    goto switch_default;
    case_95: /* CIL Label */ 
    {
#line 1385
    dialog_vars.title = optionString(argv, & offset);
    }
#line 1386
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 1388
    dialog_vars.backtitle = optionString(argv, & offset);
    }
#line 1389
    goto switch_break;
    case_79: /* CIL Label */ 
    {
#line 1391
    dialog_state.separate_str = optionString(argv, & offset);
    }
#line 1392
    goto switch_break;
    case_78: /* CIL Label */ 
#line 1394
    dialog_vars.separate_output = (_Bool)1;
#line 1395
    goto switch_break;
    case_13: /* CIL Label */ 
#line 1397
    dialog_vars.colors = (_Bool)1;
#line 1398
    goto switch_break;
    case_15: /* CIL Label */ 
#line 1400
    dialog_vars.cr_wrap = (_Bool)1;
#line 1401
    goto switch_break;
    case_58: /* CIL Label */ 
#line 1403
    dialog_vars.no_nl_expand = (_Bool)1;
#line 1404
    goto switch_break;
    case_52: /* CIL Label */ 
#line 1406
    dialog_vars.nocollapse = (_Bool)1;
#line 1407
    goto switch_break;
    case_54: /* CIL Label */ 
#line 1409
    dialog_vars.cant_kill = (_Bool)1;
#line 1410
    goto switch_break;
    case_60: /* CIL Label */ 
#line 1412
    dialog_vars.nocancel = (_Bool)1;
#line 1413
    goto switch_break;
    case_61: /* CIL Label */ 
#line 1415
    dialog_vars.nook = (_Bool)1;
#line 1416
    goto switch_break;
    case_74: /* CIL Label */ 
#line 1418
    dialog_vars.quoted = (_Bool)1;
#line 1419
    goto switch_break;
    case_82: /* CIL Label */ 
#line 1421
    dialog_vars.single_quoted = (_Bool)1;
#line 1422
    goto switch_break;
    case_83: /* CIL Label */ 
#line 1424
    dialog_vars.size_err = (_Bool)1;
#line 1425
    goto switch_break;
    case_7: /* CIL Label */ 
#line 1427
    dialog_vars.beep_signal = (_Bool)1;
#line 1428
    goto switch_break;
    case_8: /* CIL Label */ 
#line 1430
    dialog_vars.beep_after_signal = (_Bool)1;
#line 1431
    goto switch_break;
    case_77: /* CIL Label */ 
#line 1433
    dialog_state.use_scrollbar = (_Bool)1;
#line 1434
    goto switch_break;
    case_81: /* CIL Label */ 
#line 1436
    dialog_state.use_shadow = (_Bool)1;
#line 1437
    goto switch_break;
    case_20: /* CIL Label */ 
#line 1439
    dialog_vars.defaultno = (_Bool)1;
#line 1440
    dialog_vars.default_button = 1;
#line 1441
    goto switch_break;
    case_18: /* CIL Label */ 
    {
#line 1443
    tmp___0 = optionString(argv, & offset);
#line 1443
    dialog_vars.default_button = button_code((char const   *)tmp___0);
#line 1444
    dialog_vars.defaultno = (_Bool )(dialog_vars.default_button == 1);
    }
#line 1445
    goto switch_break;
    case_19: /* CIL Label */ 
    {
#line 1447
    dialog_vars.default_item = optionString(argv, & offset);
    }
#line 1448
    goto switch_break;
    case_40: /* CIL Label */ 
#line 1450
    dialog_vars.insecure = (_Bool)1;
#line 1451
    goto switch_break;
    case_41: /* CIL Label */ 
#line 1453
    dialog_vars.item_help = (_Bool)1;
#line 1454
    goto switch_break;
    case_31: /* CIL Label */ 
    {
#line 1456
    dialog_vars.help_line = optionString(argv, & offset);
    }
#line 1457
    goto switch_break;
    case_29: /* CIL Label */ 
    {
#line 1459
    dialog_vars.help_file = optionString(argv, & offset);
    }
#line 1460
    goto switch_break;
    case_28: /* CIL Label */ 
#line 1462
    dialog_vars.help_button = (_Bool)1;
#line 1463
    goto switch_break;
    case_32: /* CIL Label */ 
#line 1465
    dialog_vars.help_status = (_Bool)1;
#line 1466
    goto switch_break;
    case_33: /* CIL Label */ 
#line 1468
    dialog_vars.help_tags = (_Bool)1;
#line 1469
    goto switch_break;
    case_22: /* CIL Label */ 
#line 1471
    dialog_vars.extra_button = (_Bool)1;
#line 1472
    goto switch_break;
    case_35: /* CIL Label */ 
#line 1474
    ignore_unknown = (_Bool)1;
#line 1475
    goto switch_break;
    case_44: /* CIL Label */ 
#line 1477
    dialog_vars.keep_window = (_Bool)1;
#line 1478
    goto switch_break;
    case_45: /* CIL Label */ 
#line 1480
    dialog_vars.last_key = (_Bool)1;
#line 1481
    goto switch_break;
    case_59: /* CIL Label */ 
#line 1483
    dialog_state.use_shadow = (_Bool)0;
#line 1484
    goto switch_break;
    case_70: /* CIL Label */ 
#line 1486
    dialog_vars.print_siz = (_Bool)1;
#line 1487
    goto switch_break;
    case_69: /* CIL Label */ 
#line 1489
    if (output) {
#line 1495
      if ((unsigned long )*(argv + (offset + 1)) == (unsigned long )((char *)0)) {
        {
#line 1496
        ignore_unknown = (_Bool)1;
#line 1497
        end_dialog();
        }
      }
      {
#line 1499
      fflush(dialog_state.output);
      }
#line 1500
      if (dialog_state.use_shadow) {
#line 1500
        tmp___1 = 2;
      } else {
#line 1500
        tmp___1 = 0;
      }
#line 1500
      if (dialog_state.use_shadow) {
#line 1500
        tmp___2 = 1;
      } else {
#line 1500
        tmp___2 = 0;
      }
      {
#line 1500
      fprintf((FILE */* __restrict  */)dialog_state.output, (char const   */* __restrict  */)"MaxSize: %d, %d\n",
              LINES - tmp___2, COLS - tmp___1);
      }
    }
#line 1502
    goto switch_break;
    case_71: /* CIL Label */ 
#line 1504
    if (output) {
      {
#line 1505
      PrintVersion(dialog_state.output);
      }
    }
#line 1507
    goto switch_break;
    case_64: /* CIL Label */ 
    case_80: /* CIL Label */ 
    {
#line 1510
    dialog_vars.output_separator = optionString(argv, & offset);
    }
#line 1511
    goto switch_break;
    case_14: /* CIL Label */ 
    {
#line 1513
    dialog_vars.column_separator = optionString(argv, & offset);
    }
#line 1514
    goto switch_break;
    case_88: /* CIL Label */ 
#line 1516
    dialog_vars.tab_correct = (_Bool)1;
#line 1517
    goto switch_break;
    case_84: /* CIL Label */ 
    {
#line 1519
    dialog_vars.sleep_secs = optionValue(argv, & offset);
    }
#line 1520
    goto switch_break;
    case_94: /* CIL Label */ 
    {
#line 1522
    dialog_vars.timeout_secs = optionValue(argv, & offset);
    }
#line 1523
    goto switch_break;
    case_46: /* CIL Label */ 
    {
#line 1525
    dialog_vars.max_input = optionValue(argv, & offset);
    }
#line 1526
    goto switch_break;
    case_89: /* CIL Label */ 
    {
#line 1528
    dialog_state.tab_len = optionValue(argv, & offset);
    }
#line 1529
    goto switch_break;
    case_96: /* CIL Label */ 
#line 1531
    dialog_vars.trim_whitespace = (_Bool)1;
#line 1532
    goto switch_break;
    case_99: /* CIL Label */ 
#line 1534
    dialog_state.visit_items = (_Bool)1;
#line 1535
    dialog_state.visit_cols = 1;
#line 1536
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 1538
    dialog_state.aspect_ratio = optionValue(argv, & offset);
    }
#line 1539
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 1541
    dialog_vars.begin_set = (_Bool)1;
#line 1542
    dialog_vars.begin_y = optionValue(argv, & offset);
#line 1543
    dialog_vars.begin_x = optionValue(argv, & offset);
    }
#line 1544
    goto switch_break;
    case_12: /* CIL Label */ 
#line 1546
    dialog_vars.dlg_clear_screen = (_Bool)1;
#line 1547
    goto switch_break;
    case_101: /* CIL Label */ 
    {
#line 1549
    dialog_vars.yes_label = optionString(argv, & offset);
    }
#line 1550
    goto switch_break;
    case_55: /* CIL Label */ 
    {
#line 1552
    dialog_vars.no_label = optionString(argv, & offset);
    }
#line 1553
    goto switch_break;
    case_62: /* CIL Label */ 
    {
#line 1555
    dialog_vars.ok_label = optionString(argv, & offset);
    }
#line 1556
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 1558
    dialog_vars.cancel_label = optionString(argv, & offset);
    }
#line 1559
    goto switch_break;
    case_23: /* CIL Label */ 
    {
#line 1561
    dialog_vars.extra_label = optionString(argv, & offset);
    }
#line 1562
    goto switch_break;
    case_21: /* CIL Label */ 
    {
#line 1564
    dialog_vars.exit_label = optionString(argv, & offset);
    }
#line 1565
    goto switch_break;
    case_30: /* CIL Label */ 
    {
#line 1567
    dialog_vars.help_label = optionString(argv, & offset);
    }
#line 1568
    goto switch_break;
    case_17: /* CIL Label */ 
    {
#line 1570
    dialog_vars.date_format = optionString(argv, & offset);
    }
#line 1571
    goto switch_break;
    case_93: /* CIL Label */ 
    {
#line 1573
    dialog_vars.time_format = optionString(argv, & offset);
    }
#line 1574
    goto switch_break;
    case_43: /* CIL Label */ 
#line 1576
    dialog_vars.keep_tite = (_Bool)1;
#line 1577
    goto switch_break;
    case_3: /* CIL Label */ 
#line 1579
    dialog_vars.ascii_lines = (_Bool)1;
#line 1580
    dialog_vars.no_lines = (_Bool)0;
#line 1581
    goto switch_break;
    case_56: /* CIL Label */ 
#line 1583
    dialog_vars.no_lines = (_Bool)1;
#line 1584
    dialog_vars.ascii_lines = (_Bool)0;
#line 1585
    goto switch_break;
    case_57: /* CIL Label */ 
    {
#line 1587
    dialog_state.no_mouse = (_Bool)1;
#line 1588
    mousemask((mmask_t )0, (mmask_t *)0);
    }
#line 1589
    goto switch_break;
    case_104: /* CIL Label */ 
#line 1592
    dialog_vars.begin_set = (_Bool)1;
#line 1593
    dialog_vars.begin_y = 0;
#line 1594
    dialog_vars.begin_x = 0;
#line 1595
    goto switch_break;
    case_103: /* CIL Label */ 
#line 1598
    goto switch_break;
    case_100: /* CIL Label */ 
    case_34: /* CIL Label */ 
    {
#line 1603
    optionString(argv, & offset);
    }
    case_97: /* CIL Label */ 
    case_85: /* CIL Label */ 
    case_76: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_42: /* CIL Label */ 
    case_24: /* CIL Label */ 
    case_5: /* CIL Label */ 
    case_1: /* CIL Label */ 
#line 1614
    goto switch_break;
    case_0: /* CIL Label */ 
#line 1616
    if (ignore_unknown) {
#line 1617
      goto switch_break;
    }
    switch_default: /* CIL Label */ 
#line 1620
    done = (_Bool)1;
#line 1621
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 1624
    process_trace_option(argv, & offset);
    }
#line 1625
    goto switch_break;
    case_113: /* CIL Label */ 
#line 1629
    dialog_vars.no_items = (_Bool)1;
#line 1630
    goto switch_break;
    case_114: /* CIL Label */ 
#line 1632
    dialog_vars.no_tags = (_Bool)1;
#line 1633
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1636
    if (! done) {
#line 1637
      offset ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1639
  return (offset);
}
}
#line 1649
static void init_result(char *buffer ) ;
#line 1649 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
static _Bool first  =    (_Bool)1;
#line 1650 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
static char **special_argv  =    (char **)0;
#line 1651 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
static int special_argc  =    0;
#line 1646 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
static void init_result(char *buffer ) 
{ 
  char *env ;
  char *tmp ;

  {
  {
#line 1653
  dlg_trace_msg("# init_result\n");
#line 1656
  memset((void *)(& dialog_vars), 0, sizeof(dialog_vars));
#line 1658
  dialog_vars.input_result = buffer;
#line 1659
  *(dialog_vars.input_result + 0) = (char )'\000';
#line 1661
  dialog_vars.default_button = -1;
  }
#line 1667
  if (first) {
    {
#line 1668
    tmp = getenv("DIALOGOPTS");
#line 1668
    env = tmp;
    }
#line 1669
    if ((unsigned long )env != (unsigned long )((char *)0)) {
      {
#line 1670
      env = dlg_strclone((char const   *)env);
      }
    }
#line 1671
    if ((unsigned long )env != (unsigned long )((char *)0)) {
      {
#line 1672
      special_argv = dlg_string_to_argv(env);
#line 1673
      special_argc = dlg_count_argv(special_argv);
      }
    }
#line 1675
    first = (_Bool)0;
  }
#line 1682
  if ((unsigned long )special_argv != (unsigned long )((char **)0)) {
    {
#line 1683
    process_common_options(special_argc, special_argv, 0, (_Bool)0);
    }
  }
#line 1692
  return;
}
}
#line 1694 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dialog.c"
int main(int argc , char **argv ) 
{ 
  char temp[256] ;
  _Bool esc_pressed ;
  _Bool keep_tite ;
  int offset ;
  int offset_add ;
  int retval ;
  int j ;
  int have ;
  eOptions code ;
  Mode___0 const   *modePtr ;
  char my_buffer[2049] ;
  int base ;
  eOptions tmp ;
  eOptions tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  eOptions tmp___4 ;
  eOptions tmp___5 ;
  char const   *tmp___7 ;
  eOptions tmp___8 ;
  eOptions tmp___9 ;
  char *argv_j ;
  char *tmp___10 ;
  int tmp___11 ;
  eOptions tmp___12 ;

  {
  {
#line 1698
  esc_pressed = (_Bool)0;
#line 1699
  keep_tite = (_Bool)0;
#line 1700
  offset = 1;
#line 1702
  retval = 0;
#line 1708
  memset((void *)(& dialog_state), 0, sizeof(dialog_state));
#line 1709
  memset((void *)(& dialog_vars), 0, sizeof(dialog_vars));
#line 1717
  setlocale(6, "");
#line 1720
  unescape_argv(& argc, & argv);
#line 1721
  program = (char const   *)*(argv + 0);
#line 1722
  dialog_state.output = stderr;
#line 1723
  dialog_state.input = stdin;
  }
  {
#line 1734
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1734
    if (! (offset < argc)) {
#line 1734
      goto while_break;
    }
    {
#line 1735
    base = offset;
#line 1736
    tmp = lookupOption((char const   *)*(argv + offset), 7);
    }
    {
#line 1737
    if ((unsigned int )tmp == 87U) {
#line 1737
      goto case_87;
    }
#line 1740
    if ((unsigned int )tmp == 86U) {
#line 1740
      goto case_86;
    }
#line 1743
    if ((unsigned int )tmp == 37U) {
#line 1743
      goto case_37;
    }
#line 1748
    if ((unsigned int )tmp == 63U) {
#line 1748
      goto case_63;
    }
#line 1753
    if ((unsigned int )tmp == 43U) {
#line 1753
      goto case_43;
    }
#line 1756
    if ((unsigned int )tmp == 98U) {
#line 1756
      goto case_98;
    }
#line 1761
    if ((unsigned int )tmp == 27U) {
#line 1761
      goto case_27;
    }
#line 1765
    if ((unsigned int )tmp == 115U) {
#line 1765
      goto case_115;
    }
#line 1779
    goto switch_default;
    case_87: /* CIL Label */ 
#line 1738
    dialog_state.output = stdout;
#line 1739
    goto switch_break;
    case_86: /* CIL Label */ 
#line 1741
    dialog_state.output = stderr;
#line 1742
    goto switch_break;
    case_37: /* CIL Label */ 
    {
#line 1744
    j = optionValue(argv, & offset);
    }
#line 1744
    if (j < 0) {
      {
#line 1746
      dlg_exiterr("Cannot open input-fd\n");
      }
    } else {
      {
#line 1744
      dialog_state.input = fdopen(j, "r");
      }
#line 1744
      if ((unsigned long )dialog_state.input == (unsigned long )((FILE *)0)) {
        {
#line 1746
        dlg_exiterr("Cannot open input-fd\n");
        }
      }
    }
#line 1747
    goto switch_break;
    case_63: /* CIL Label */ 
    {
#line 1749
    j = optionValue(argv, & offset);
    }
#line 1749
    if (j < 0) {
      {
#line 1751
      dlg_exiterr("Cannot open output-fd\n");
      }
    } else {
      {
#line 1749
      dialog_state.output = fdopen(j, "w");
      }
#line 1749
      if ((unsigned long )dialog_state.output == (unsigned long )((FILE *)0)) {
        {
#line 1751
        dlg_exiterr("Cannot open output-fd\n");
        }
      }
    }
#line 1752
    goto switch_break;
    case_43: /* CIL Label */ 
#line 1754
    keep_tite = (_Bool)1;
#line 1755
    goto switch_break;
    case_98: /* CIL Label */ 
    {
#line 1757
    dialog_state.output = stdout;
#line 1758
    PrintVersion(dialog_state.output);
#line 1759
    exit(0);
    }
#line 1760
    goto switch_break;
    case_27: /* CIL Label */ 
    {
#line 1762
    Help();
    }
#line 1763
    goto switch_break;
    case_115: /* CIL Label */ 
#line 1771
    if (base == 1) {
      {
#line 1772
      process_trace_option(argv, & offset);
      }
#line 1773
      goto switch_break;
    } else {
#line 1775
      offset ++;
#line 1776
      goto while_continue;
    }
    switch_default: /* CIL Label */ 
#line 1780
    offset ++;
#line 1781
    goto while_continue;
    switch_break: /* CIL Label */ ;
    }
    {
#line 1783
    dlg_trace_msg("# discarding %d parameters starting with argv[%d] (%s)\n", (1 + offset) - base,
                  base, *(argv + base));
#line 1786
    j = base;
    }
    {
#line 1786
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1786
      if (! (j < argc)) {
#line 1786
        goto while_break___0;
      }
#line 1787
      *(dialog_argv + j) = *(dialog_argv + ((j + 1) + (offset - base)));
#line 1788
      if ((unsigned long )dialog_opts != (unsigned long )((_Bool *)0)) {
#line 1789
        *(dialog_opts + j) = *(dialog_opts + ((j + 1) + (offset - base)));
      }
#line 1786
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1791
    argc -= (1 + offset) - base;
#line 1792
    offset = base;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1794
  offset = 1;
#line 1795
  init_result(my_buffer);
  }
#line 1801
  if (argc == 2) {
    {
#line 1802
    tmp___0 = lookupOption((char const   *)*(argv + 1), 7);
    }
    {
#line 1803
    if ((unsigned int )tmp___0 == 69U) {
#line 1803
      goto case_69;
    }
#line 1809
    if ((unsigned int )tmp___0 == 71U) {
#line 1809
      goto case_71;
    }
#line 1812
    if ((unsigned int )tmp___0 == 12U) {
#line 1812
      goto case_12;
    }
#line 1817
    if ((unsigned int )tmp___0 == 35U) {
#line 1817
      goto case_35;
    }
#line 1819
    goto switch_default___0;
    case_69: /* CIL Label */ 
    {
#line 1804
    initscr();
#line 1805
    endwin();
#line 1806
    fflush(dialog_state.output);
    }
#line 1807
    if (dialog_state.use_shadow) {
#line 1807
      tmp___1 = 2;
    } else {
#line 1807
      tmp___1 = 0;
    }
#line 1807
    if (dialog_state.use_shadow) {
#line 1807
      tmp___2 = 1;
    } else {
#line 1807
      tmp___2 = 0;
    }
    {
#line 1807
    fprintf((FILE */* __restrict  */)dialog_state.output, (char const   */* __restrict  */)"MaxSize: %d, %d\n",
            LINES - tmp___2, COLS - tmp___1);
    }
#line 1808
    goto switch_break___0;
    case_71: /* CIL Label */ 
    {
#line 1810
    PrintVersion(dialog_state.output);
    }
#line 1811
    goto switch_break___0;
    case_12: /* CIL Label */ 
    {
#line 1813
    initscr();
#line 1814
    wrefresh(stdscr);
#line 1815
    endwin();
    }
#line 1816
    goto switch_break___0;
    case_35: /* CIL Label */ 
#line 1818
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 1820
    Help();
    }
#line 1821
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 1823
    return (0);
  }
#line 1826
  if (argc < 2) {
    {
#line 1827
    Help();
    }
  }
  {
#line 1830
  tmp___4 = lookupOption((char const   *)*(argv + 1), 7);
  }
#line 1830
  if ((unsigned int )tmp___4 == 16U) {
#line 1831
    if (argc != 3) {
      {
#line 1832
      sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)"Expected a filename for %.50s",
              *(argv + 1));
#line 1833
      Usage((char const   *)(temp));
      }
    }
    {
#line 1835
    tmp___3 = dlg_parse_rc();
    }
#line 1835
    if (tmp___3 == -1) {
      {
#line 1836
      dlg_exiterr("dialog: dlg_parse_rc");
      }
    }
    {
#line 1837
    dlg_create_rc((char const   *)*(argv + 2));
    }
#line 1838
    return (0);
  }
  {
#line 1842
  dialog_vars.keep_tite = keep_tite;
#line 1844
  init_dialog(dialog_state.input, dialog_state.output);
  }
  {
#line 1846
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1846
    if (offset < argc) {
#line 1846
      if (! (! esc_pressed)) {
#line 1846
        goto while_break___1;
      }
    } else {
#line 1846
      goto while_break___1;
    }
    {
#line 1847
    init_result(my_buffer);
#line 1849
    offset = process_common_options(argc, argv, offset, (_Bool)1);
    }
#line 1851
    if ((unsigned long )*(argv + offset) == (unsigned long )((void *)0)) {
#line 1852
      if (ignore_unknown) {
#line 1853
        goto while_break___1;
      }
      {
#line 1854
      Usage("Expected a box option");
      }
    }
    {
#line 1857
    tmp___5 = lookupOption((char const   *)*(argv + offset), 2);
    }
#line 1857
    if ((unsigned int )tmp___5 != 11U) {
#line 1857
      if (dialog_vars.separate_output) {
        {
#line 1859
        sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)"Expected --checklist, not %.20s",
                *(argv + offset));
#line 1860
        Usage((char const   *)(temp));
        }
      }
    }
#line 1863
    if (dialog_state.aspect_ratio == 0) {
#line 1864
      dialog_state.aspect_ratio = 9;
    }
    {
#line 1866
    dlg_put_backtitle();
#line 1870
    modePtr = (Mode___0 const   *)0;
#line 1871
    code = lookupOption((char const   *)*(argv + offset), 2);
    }
#line 1871
    if ((unsigned int )code != 0U) {
      {
#line 1872
      modePtr = lookupMode(code);
      }
    }
#line 1873
    if ((unsigned long )modePtr == (unsigned long )((Mode___0 const   *)0)) {
      {
#line 1874
      tmp___8 = lookupOption((char const   *)*(argv + offset), 7);
      }
#line 1874
      if ((unsigned int )tmp___8 != 0U) {
#line 1874
        tmp___7 = "Unexpected";
      } else {
#line 1874
        tmp___7 = "Unknown";
      }
      {
#line 1874
      sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)"%s option %.20s",
              tmp___7, *(argv + offset));
#line 1879
      Usage((char const   *)(temp));
      }
    }
    {
#line 1882
    have = arg_rest(argv + offset);
    }
#line 1883
    if (have < (int )modePtr->argmin) {
      {
#line 1884
      sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)"Expected at least %d tokens for %.20s, have %d",
              modePtr->argmin - 1, *(argv + offset), have - 1);
#line 1887
      Usage((char const   *)(temp));
      }
    }
#line 1889
    if (modePtr->argmax) {
#line 1889
      if (have > (int )modePtr->argmax) {
        {
#line 1890
        sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)"Expected no more than %d tokens for %.20s, have %d",
                modePtr->argmax - 1, *(argv + offset), have - 1);
#line 1894
        Usage((char const   *)(temp));
        }
      }
    }
#line 1903
    j = offset + 1;
    {
#line 1903
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1903
      if (! (j <= offset + have)) {
#line 1903
        goto while_break___2;
      }
      {
#line 1904
      tmp___9 = lookupOption((char const   *)*(argv + (j - 1)), 7);
      }
      {
#line 1909
      if ((unsigned int )tmp___9 == 29U) {
#line 1909
        goto case_29;
      }
#line 1909
      if ((unsigned int )tmp___9 == 31U) {
#line 1909
        goto case_29;
      }
#line 1909
      if ((unsigned int )tmp___9 == 6U) {
#line 1909
        goto case_29;
      }
#line 1909
      if ((unsigned int )tmp___9 == 95U) {
#line 1909
        goto case_29;
      }
#line 1909
      if ((unsigned int )tmp___9 == 0U) {
#line 1909
        goto case_29;
      }
#line 1911
      goto switch_default___1;
      case_29: /* CIL Label */ 
      case_31: /* CIL Label */ 
      case_6: /* CIL Label */ 
      case_95: /* CIL Label */ 
      case_0: /* CIL Label */ 
#line 1910
      goto switch_break___1;
      switch_default___1: /* CIL Label */ 
#line 1912
      if ((unsigned long )*(argv + j) != (unsigned long )((char *)0)) {
        {
#line 1913
        tmp___10 = strdup((char const   *)*(argv + j));
#line 1913
        argv_j = tmp___10;
        }
#line 1914
        if ((unsigned long )argv_j != (unsigned long )((char *)0)) {
          {
#line 1915
          dlg_trim_string(argv_j);
#line 1916
          *(argv + j) = argv_j;
          }
        } else {
          {
#line 1918
          *(argv + j) = strdup("?");
          }
        }
      }
#line 1921
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
#line 1903
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 1925
    tmp___11 = (*(modePtr->jumper))((char const   *)dialog_vars.title, argv + offset,
                                    & offset_add);
#line 1925
    retval = show_result(tmp___11);
#line 1928
    dlg_trace_msg("# widget returns %d\n", retval);
#line 1929
    offset += offset_add;
    }
#line 1931
    if ((unsigned long )dialog_vars.input_result != (unsigned long )(my_buffer)) {
      {
#line 1932
      free((void *)dialog_vars.input_result);
#line 1933
      dialog_vars.input_result = (char *)0;
      }
    }
#line 1936
    if (retval == 255) {
#line 1937
      esc_pressed = (_Bool)1;
    } else {
#line 1940
      if (dialog_vars.beep_after_signal) {
        {
#line 1941
        beep();
        }
      }
#line 1943
      if (dialog_vars.sleep_secs) {
        {
#line 1944
        napms(dialog_vars.sleep_secs * 1000);
        }
      }
#line 1946
      if (offset < argc) {
        {
#line 1947
        tmp___12 = lookupOption((char const   *)*(argv + offset), 7);
        }
        {
#line 1948
        if ((unsigned int )tmp___12 == 2U) {
#line 1948
          goto case_2;
        }
#line 1951
        if ((unsigned int )tmp___12 == 0U) {
#line 1951
          goto case_0___0;
        }
#line 1956
        goto switch_default___2;
        case_2: /* CIL Label */ 
#line 1949
        offset ++;
#line 1950
        goto switch_break___2;
        case_0___0: /* CIL Label */ 
        {
#line 1952
        sprintf((char */* __restrict  */)(temp), (char const   */* __restrict  */)"Expected --and-widget, not %.20s",
                *(argv + offset));
#line 1954
        Usage((char const   *)(temp));
        }
#line 1955
        goto switch_break___2;
        switch_default___2: /* CIL Label */ 
#line 1958
        if (retval != 0) {
#line 1959
          esc_pressed = (_Bool)1;
        } else {
#line 1961
          dialog_vars.dlg_clear_screen = (_Bool)1;
        }
#line 1962
        goto switch_break___2;
        switch_break___2: /* CIL Label */ ;
        }
      }
#line 1965
      if (dialog_vars.dlg_clear_screen) {
        {
#line 1966
        dlg_clear();
        }
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1970
  dlg_killall_bg(& retval);
  }
#line 1971
  if (dialog_state.screen_initialized) {
    {
#line 1972
    wrefresh(stdscr);
#line 1973
    end_dialog();
    }
  }
  {
#line 1975
  dlg_exit(retval);
  }
#line 1976
  return (0);
}
}
#line 433 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 164 "./dlg_keys.h"
int dlg_parse_bindkey(char *params ) ;
#line 165
void dlg_dump_keys(FILE *fp ) ;
#line 166
void dlg_dump_window_keys(FILE *fp , WINDOW *win ) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dlg_keys.c"
static struct _list_bindings *all_bindings  ;
#line 39 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dlg_keys.c"
static struct __anonstruct_DLG_KEYS_BINDING_64  const  end_keys_binding  =    {-1, 0, 0};
#line 44 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dlg_keys.c"
void dlg_register_window(WINDOW *win , char const   *name , DLG_KEYS_BINDING *binding___7 ) 
{ 
  struct _list_bindings *p ;
  struct _list_bindings *q ;
  int tmp ;
  void *tmp___0 ;

  {
#line 49
  p = all_bindings;
#line 49
  q = (struct _list_bindings *)0;
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
#line 49
    if (! ((unsigned long )p != (unsigned long )((struct _list_bindings *)0))) {
#line 49
      goto while_break;
    }
#line 50
    if ((unsigned long )p->win == (unsigned long )win) {
      {
#line 50
      tmp = strcmp(p->name, name);
      }
#line 50
      if (! tmp) {
#line 51
        p->binding = binding___7;
#line 52
        return;
      }
    }
#line 49
    q = p;
#line 49
    p = p->link;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 56
  tmp___0 = calloc((size_t )1, sizeof(struct _list_bindings ));
#line 56
  p = (struct _list_bindings *)tmp___0;
  }
#line 56
  if ((unsigned long )p != (unsigned long )((struct _list_bindings *)0)) {
#line 57
    p->win = win;
#line 58
    p->name = name;
#line 59
    p->binding = binding___7;
#line 60
    if ((unsigned long )q != (unsigned long )((struct _list_bindings *)0)) {
#line 61
      q->link = p;
    } else {
#line 63
      all_bindings = p;
    }
  }
  {
#line 73
  dlg_trace_msg("# dlg_register_window %s\n", name);
#line 74
  dlg_dump_window_keys(dialog_state.trace_output, win);
  }
#line 76
  return;
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dlg_keys.c"
static int key_is_bound(WINDOW *win , char const   *name , int curses_key , int function_key ) 
{ 
  struct _list_bindings *p ;
  int n ;
  int tmp ;

  {
#line 87
  p = all_bindings;
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
#line 87
    if (! ((unsigned long )p != (unsigned long )((struct _list_bindings *)0))) {
#line 87
      goto while_break;
    }
#line 88
    if ((unsigned long )p->win == (unsigned long )win) {
      {
#line 88
      tmp = strcasecmp(p->name, name);
      }
#line 88
      if (! tmp) {
#line 90
        n = 0;
        {
#line 90
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 90
          if (! ((p->binding + n)->is_function_key >= 0)) {
#line 90
            goto while_break___0;
          }
#line 91
          if ((p->binding + n)->curses_key == curses_key) {
#line 91
            if ((p->binding + n)->is_function_key == function_key) {
#line 93
              return (1);
            }
          }
#line 90
          n ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
#line 87
    p = p->link;
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  return (0);
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dlg_keys.c"
void dlg_register_buttons(WINDOW *win , char const   *name , char const   **buttons ) 
{ 
  int n ;
  struct _list_bindings *p ;
  DLG_KEYS_BINDING *q ;
  int curses_key ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
#line 119
  if ((unsigned long )buttons == (unsigned long )((char const   **)0)) {
#line 120
    return;
  }
#line 122
  n = 0;
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;
#line 122
    if (! ((unsigned long )*(buttons + n) != (unsigned long )((char const   *)0))) {
#line 122
      goto while_break;
    }
    {
#line 123
    tmp = dlg_button_to_char(*(buttons + n));
#line 123
    curses_key = tmp;
    }
#line 126
    if (curses_key >= 257) {
#line 127
      goto __Cont;
    }
    {
#line 130
    tmp___0 = key_is_bound(win, name, curses_key, 0);
    }
#line 130
    if (! tmp___0) {
#line 131
      goto __Cont;
    }
    {
#line 135
    tmp___1 = key_is_bound((WINDOW *)0, name, curses_key, 0);
    }
#line 135
    if (tmp___1) {
#line 136
      goto __Cont;
    }
    {
#line 139
    tmp___3 = calloc((size_t )1, sizeof(struct _list_bindings ));
#line 139
    p = (struct _list_bindings *)tmp___3;
    }
#line 139
    if ((unsigned long )p != (unsigned long )((struct _list_bindings *)0)) {
      {
#line 140
      tmp___2 = calloc((size_t )2, sizeof(DLG_KEYS_BINDING ));
#line 140
      q = (DLG_KEYS_BINDING *)tmp___2;
      }
#line 140
      if ((unsigned long )q != (unsigned long )((DLG_KEYS_BINDING *)0)) {
#line 141
        (q + 0)->is_function_key = 0;
#line 142
        (q + 0)->curses_key = curses_key;
#line 143
        (q + 0)->dialog_key = curses_key;
#line 144
        *(q + 1) = (DLG_KEYS_BINDING )end_keys_binding;
#line 146
        p->win = win;
#line 147
        p->name = name;
#line 148
        p->buttons = (_Bool)1;
#line 149
        p->binding = q;
#line 152
        p->link = all_bindings;
#line 153
        all_bindings = p;
      } else {
        {
#line 155
        free((void *)p);
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 122
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 159
  return;
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dlg_keys.c"
void dlg_unregister_window(WINDOW *win ) 
{ 
  struct _list_bindings *p ;
  struct _list_bindings *q ;

  {
#line 169
  p = all_bindings;
#line 169
  q = (struct _list_bindings *)0;
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;
#line 169
    if (! ((unsigned long )p != (unsigned long )((struct _list_bindings *)0))) {
#line 169
      goto while_break;
    }
#line 170
    if ((unsigned long )p->win == (unsigned long )win) {
#line 171
      if ((unsigned long )q != (unsigned long )((struct _list_bindings *)0)) {
#line 172
        q->link = p->link;
      } else {
#line 174
        all_bindings = p->link;
      }
#line 177
      if ((p->binding + 1)->is_function_key < 0) {
        {
#line 178
        free((void *)p->binding);
        }
      }
      {
#line 179
      free((void *)p);
#line 180
      dlg_unregister_window(win);
      }
#line 181
      goto while_break;
    }
#line 183
    q = p;
#line 169
    p = p->link;
  }
  while_break: /* CIL Label */ ;
  }
#line 185
  return;
}
}
#line 200 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dlg_keys.c"
int dlg_lookup_key(WINDOW *win , int curses_key , int *fkey ) 
{ 
  struct _list_bindings *p ;
  DLG_KEYS_BINDING *q ;
  char const   *name ;
  int function_key ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 210
  if (*fkey != 0) {
#line 210
    if (! (curses_key == 409)) {
#line 210
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 218
  if (*fkey != 0) {
#line 218
    if (! (curses_key == 410)) {
#line 218
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 222
  if (*fkey == 0) {
#line 222
    goto _L___0;
  } else
#line 222
  if (curses_key < 511) {
    _L___0: /* CIL Label */ 
#line 223
    name = "*";
#line 224
    if ((unsigned long )win != (unsigned long )((WINDOW *)0)) {
#line 225
      p = all_bindings;
      {
#line 225
      while (1) {
        while_continue: /* CIL Label */ ;
#line 225
        if (! ((unsigned long )p != (unsigned long )((struct _list_bindings *)0))) {
#line 225
          goto while_break;
        }
#line 226
        if ((unsigned long )p->win == (unsigned long )win) {
#line 227
          name = p->name;
#line 228
          goto while_break;
        }
#line 225
        p = p->link;
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 232
    p = all_bindings;
    {
#line 232
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 232
      if (! ((unsigned long )p != (unsigned long )((struct _list_bindings *)0))) {
#line 232
        goto while_break___0;
      }
#line 233
      if ((unsigned long )p->win == (unsigned long )win) {
#line 233
        goto _L;
      } else
#line 233
      if ((unsigned long )p->win == (unsigned long )((WINDOW *)0)) {
        {
#line 233
        tmp___1 = strcmp(p->name, name);
        }
#line 233
        if (! tmp___1) {
          _L: /* CIL Label */ 
#line 234
          function_key = *fkey != 0;
#line 235
          q = p->binding;
          {
#line 235
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 235
            if (! (q->is_function_key >= 0)) {
#line 235
              goto while_break___1;
            }
#line 236
            if (p->buttons) {
#line 236
              if (! function_key) {
#line 236
                if (curses_key > 0) {
#line 236
                  if (curses_key <= 255) {
                    {
#line 236
                    tmp = toupper(curses_key);
#line 236
                    tmp___0 = tmp;
                    }
                  } else {
#line 236
                    tmp___0 = curses_key;
                  }
                } else {
#line 236
                  tmp___0 = curses_key;
                }
#line 236
                if (q->curses_key == tmp___0) {
#line 239
                  *fkey = 0;
#line 240
                  return (q->dialog_key);
                }
              }
            }
#line 242
            if (q->curses_key == curses_key) {
#line 242
              if (q->is_function_key == function_key) {
#line 244
                *fkey = q->dialog_key;
#line 245
                return (*fkey);
              }
            }
#line 235
            q ++;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
      }
#line 232
      p = p->link;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 251
  return (curses_key);
}
}
#line 263 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dlg_keys.c"
int dlg_result_key(int dialog_key , int fkey , int *resultp ) 
{ 
  int done ;

  {
#line 266
  done = 0;
#line 269
  if (fkey) {
    {
#line 271
    if ((unsigned int )((DLG_KEYS_ENUM )dialog_key) == 513U) {
#line 271
      goto case_513;
    }
#line 275
    if ((unsigned int )((DLG_KEYS_ENUM )dialog_key) == 514U) {
#line 275
      goto case_514;
    }
#line 281
    if ((unsigned int )((DLG_KEYS_ENUM )dialog_key) == 515U) {
#line 281
      goto case_515;
    }
#line 287
    if ((unsigned int )((DLG_KEYS_ENUM )dialog_key) == 516U) {
#line 287
      goto case_516;
    }
#line 293
    if ((unsigned int )((DLG_KEYS_ENUM )dialog_key) == 517U) {
#line 293
      goto case_517;
    }
#line 297
    goto switch_default;
    case_513: /* CIL Label */ 
#line 272
    *resultp = 0;
#line 273
    done = 1;
#line 274
    goto switch_break;
    case_514: /* CIL Label */ 
#line 276
    if (! dialog_vars.nocancel) {
#line 277
      *resultp = 1;
#line 278
      done = 1;
    }
#line 280
    goto switch_break;
    case_515: /* CIL Label */ 
#line 282
    if (dialog_vars.extra_button) {
#line 283
      *resultp = 3;
#line 284
      done = 1;
    }
#line 286
    goto switch_break;
    case_516: /* CIL Label */ 
#line 288
    if (dialog_vars.help_button) {
#line 289
      *resultp = 2;
#line 290
      done = 1;
    }
#line 292
    goto switch_break;
    case_517: /* CIL Label */ 
#line 294
    *resultp = 255;
#line 295
    done = 1;
#line 296
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 298
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else
#line 302
  if (dialog_key == 27) {
#line 303
    *resultp = 255;
#line 304
    done = 1;
  } else
#line 305
  if (dialog_key == -1) {
#line 306
    *resultp = -1;
#line 307
    done = 1;
  }
#line 310
  return (done);
}
}
#line 322 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dlg_keys.c"
static CODENAME const   curses_names[92]  = 
#line 322
  {      {"ESC", '\033'}, 
        {"CR", '\r'}, 
        {"LF", '\n'}, 
        {"FF", '\f'}, 
        {"TAB", '\t'}, 
        {"DEL", '\177'}, 
        {"DOWN", 258}, 
        {"UP", 259}, 
        {"LEFT", 260}, 
        {"RIGHT", 261}, 
        {"HOME", 262}, 
        {"BACKSPACE", 263}, 
        {"F0", 264}, 
        {"DL", 328}, 
        {"IL", 329}, 
        {"DC", 330}, 
        {"IC", 331}, 
        {"EIC", 332}, 
        {"CLEAR", 333}, 
        {"EOS", 334}, 
        {"EOL", 335}, 
        {"SF", 336}, 
        {"SR", 337}, 
        {"NPAGE", 338}, 
        {"PPAGE", 339}, 
        {"STAB", 340}, 
        {"CTAB", 341}, 
        {"CATAB", 342}, 
        {"ENTER", 343}, 
        {"PRINT", 346}, 
        {"LL", 347}, 
        {"A1", 348}, 
        {"A3", 349}, 
        {"B2", 350}, 
        {"C1", 351}, 
        {"C3", 352}, 
        {"BTAB", 353}, 
        {"BEG", 354}, 
        {"CANCEL", 355}, 
        {"CLOSE", 356}, 
        {"COMMAND", 357}, 
        {"COPY", 358}, 
        {"CREATE", 359}, 
        {"END", 360}, 
        {"EXIT", 361}, 
        {"FIND", 362}, 
        {"HELP", 363}, 
        {"MARK", 364}, 
        {"MESSAGE", 365}, 
        {"MOVE", 366}, 
        {"NEXT", 367}, 
        {"OPEN", 368}, 
        {"OPTIONS", 369}, 
        {"PREVIOUS", 370}, 
        {"REDO", 371}, 
        {"REFERENCE", 372}, 
        {"REFRESH", 373}, 
        {"REPLACE", 374}, 
        {"RESTART", 375}, 
        {"RESUME", 376}, 
        {"SAVE", 377}, 
        {"SBEG", 378}, 
        {"SCANCEL", 379}, 
        {"SCOMMAND", 380}, 
        {"SCOPY", 381}, 
        {"SCREATE", 382}, 
        {"SDC", 383}, 
        {"SDL", 384}, 
        {"SELECT", 385}, 
        {"SEND", 386}, 
        {"SEOL", 387}, 
        {"SEXIT", 388}, 
        {"SFIND", 389}, 
        {"SHELP", 390}, 
        {"SHOME", 391}, 
        {"SIC", 392}, 
        {"SLEFT", 393}, 
        {"SMESSAGE", 394}, 
        {"SMOVE", 395}, 
        {"SNEXT", 396}, 
        {"SOPTIONS", 397}, 
        {"SPREVIOUS", 398}, 
        {"SPRINT", 399}, 
        {"SREDO", 400}, 
        {"SREPLACE", 401}, 
        {"SRIGHT", 402}, 
        {"SRSUME", 403}, 
        {"SSAVE", 404}, 
        {"SSUSPEND", 405}, 
        {"SUNDO", 406}, 
        {"SUSPEND", 407}, 
        {"UNDO", 408}};
#line 421 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dlg_keys.c"
static CODENAME const   dialog_names[34]  = 
#line 421
  {      {"OK", 513}, 
        {"CANCEL", 514}, 
        {"EXTRA", 515}, 
        {"HELP", 516}, 
        {"ESC", 517}, 
        {"PAGE_FIRST", 518}, 
        {"PAGE_LAST", 519}, 
        {"PAGE_NEXT", 520}, 
        {"PAGE_PREV", 521}, 
        {"ITEM_FIRST", 522}, 
        {"ITEM_LAST", 523}, 
        {"ITEM_NEXT", 524}, 
        {"ITEM_PREV", 525}, 
        {"FIELD_FIRST", 526}, 
        {"FIELD_LAST", 527}, 
        {"FIELD_NEXT", 528}, 
        {"FIELD_PREV", 529}, 
        {"FORM_FIRST", 530}, 
        {"FORM_LAST", 531}, 
        {"FORM_NEXT", 532}, 
        {"FORM_PREV", 533}, 
        {"GRID_UP", 534}, 
        {"GRID_DOWN", 535}, 
        {"GRID_LEFT", 536}, 
        {"GRID_RIGHT", 537}, 
        {"DELETE_LEFT", 538}, 
        {"DELETE_RIGHT", 539}, 
        {"DELETE_ALL", 540}, 
        {"ENTER", 541}, 
        {"BEGIN", 542}, 
        {"FINAL", 543}, 
        {"SELECT", 544}, 
        {"HELPFILE", 545}, 
        {"TRACE", 546}};
#line 459 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dlg_keys.c"
static char *skip_white(char *s ) 
{ 
  unsigned short const   **tmp ;

  {
  {
#line 462
  while (1) {
    while_continue: /* CIL Label */ ;
#line 462
    if ((int )*s != 0) {
      {
#line 462
      tmp = __ctype_b_loc();
      }
#line 462
      if (! ((int const   )*(*tmp + (int )((unsigned char )*s)) & 8192)) {
#line 462
        goto while_break;
      }
    } else {
#line 462
      goto while_break;
    }
#line 463
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 464
  return (s);
}
}
#line 467 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dlg_keys.c"
static char *skip_black(char *s ) 
{ 
  unsigned short const   **tmp ;

  {
  {
#line 470
  while (1) {
    while_continue: /* CIL Label */ ;
#line 470
    if ((int )*s != 0) {
      {
#line 470
      tmp = __ctype_b_loc();
      }
#line 470
      if ((int const   )*(*tmp + (int )((unsigned char )*s)) & 8192) {
#line 470
        goto while_break;
      }
    } else {
#line 470
      goto while_break;
    }
#line 471
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 472
  return (s);
}
}
#line 478 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dlg_keys.c"
static DLG_KEYS_BINDING *find_binding(char *widget , int curses_key ) 
{ 
  struct _list_bindings *p ;
  DLG_KEYS_BINDING *result ;
  int tmp ;

  {
#line 482
  result = (DLG_KEYS_BINDING *)0;
#line 484
  p = all_bindings;
  {
#line 484
  while (1) {
    while_continue: /* CIL Label */ ;
#line 484
    if (! ((unsigned long )p != (unsigned long )((struct _list_bindings *)0))) {
#line 484
      goto while_break;
    }
#line 485
    if ((unsigned long )p->win == (unsigned long )((WINDOW *)0)) {
      {
#line 485
      tmp = strcasecmp(p->name, (char const   *)widget);
      }
#line 485
      if (! tmp) {
#line 485
        if ((p->binding)->curses_key == curses_key) {
#line 488
          result = p->binding;
#line 489
          goto while_break;
        }
      }
    }
#line 484
    p = p->link;
  }
  while_break: /* CIL Label */ ;
  }
#line 492
  return (result);
}
}
#line 503 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dlg_keys.c"
static int compare_bindings(struct _list_bindings *a , struct _list_bindings *b ) 
{ 
  int result ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 506
  result = 0;
#line 507
  if ((unsigned long )a->win == (unsigned long )b->win) {
    {
#line 508
    tmp___1 = strcmp(a->name, b->name);
    }
#line 508
    if (tmp___1) {
      {
#line 510
      tmp___0 = strcmp(b->name, "*");
      }
#line 510
      if (tmp___0) {
        {
#line 512
        tmp = strcmp(a->name, "*");
        }
#line 512
        if (tmp) {
          {
#line 515
          result = strcasecmp(a->name, b->name);
          }
        } else {
#line 513
          result = 1;
        }
      } else {
#line 511
        result = -1;
      }
    } else {
#line 509
      result = (a->binding + 0)->curses_key - (b->binding + 0)->curses_key;
    }
  } else
#line 517
  if (b->win) {
#line 518
    result = -1;
  } else {
#line 520
    result = 1;
  }
#line 522
  return (result);
}
}
#line 531 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dlg_keys.c"
static DLG_KEYS_BINDING *make_binding(char *widget , int curses_key , int is_function ,
                                      int dialog_key ) 
{ 
  struct _list_bindings *entry ;
  DLG_KEYS_BINDING *data ;
  char *name ;
  struct _list_bindings *p ;
  struct _list_bindings *q ;
  DLG_KEYS_BINDING *result ;
  DLG_KEYS_BINDING *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 534
  entry = (struct _list_bindings *)0;
#line 535
  data = (DLG_KEYS_BINDING *)0;
#line 538
  tmp = find_binding(widget, curses_key);
#line 538
  result = tmp;
  }
#line 540
  if ((unsigned long )result == (unsigned long )((DLG_KEYS_BINDING *)0)) {
    {
#line 540
    tmp___1 = calloc((size_t )1, sizeof(struct _list_bindings ));
#line 540
    entry = (struct _list_bindings *)tmp___1;
    }
#line 540
    if ((unsigned long )entry != (unsigned long )((struct _list_bindings *)0)) {
      {
#line 540
      tmp___2 = calloc((size_t )2, sizeof(DLG_KEYS_BINDING ));
#line 540
      data = (DLG_KEYS_BINDING *)tmp___2;
      }
#line 540
      if ((unsigned long )data != (unsigned long )((DLG_KEYS_BINDING *)0)) {
        {
#line 540
        name = dlg_strclone((char const   *)widget);
        }
#line 540
        if ((unsigned long )name != (unsigned long )((char *)0)) {
#line 545
          entry->name = (char const   *)name;
#line 546
          entry->binding = data;
#line 548
          (data + 0)->is_function_key = is_function;
#line 549
          (data + 0)->curses_key = curses_key;
#line 550
          (data + 0)->dialog_key = dialog_key;
#line 552
          *(data + 1) = (DLG_KEYS_BINDING )end_keys_binding;
#line 554
          p = all_bindings;
#line 554
          q = (struct _list_bindings *)0;
          {
#line 554
          while (1) {
            while_continue: /* CIL Label */ ;
#line 554
            if (! ((unsigned long )p != (unsigned long )((struct _list_bindings *)0))) {
#line 554
              goto while_break;
            }
            {
#line 555
            tmp___0 = compare_bindings(entry, p);
            }
#line 555
            if (tmp___0 < 0) {
#line 556
              goto while_break;
            }
#line 554
            q = p;
#line 554
            p = p->link;
          }
          while_break: /* CIL Label */ ;
          }
#line 559
          if ((unsigned long )q != (unsigned long )((struct _list_bindings *)0)) {
#line 560
            q->link = entry;
          } else {
#line 562
            all_bindings = entry;
          }
#line 564
          if ((unsigned long )p != (unsigned long )((struct _list_bindings *)0)) {
#line 565
            entry->link = p;
          }
#line 567
          result = data;
        } else {
#line 540
          goto _L___1;
        }
      } else {
#line 540
        goto _L___1;
      }
    } else {
#line 540
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 568
  if ((unsigned long )entry != (unsigned long )((struct _list_bindings *)0)) {
    {
#line 569
    free((void *)entry);
    }
#line 570
    if (data) {
      {
#line 571
      free((void *)data);
      }
    }
  }
#line 574
  return (result);
}
}
#line 589 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dlg_keys.c"
int dlg_parse_bindkey(char *params ) 
{ 
  char *p ;
  char *tmp ;
  char *q ;
  _Bool escaped ;
  int modified ;
  int result ;
  unsigned int xx ;
  char *widget ;
  int is_function ;
  int curses_key ;
  int dialog_key ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *tmp___2 ;
  char fprefix[2] ;
  char check[2] ;
  int keynumber ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned short const   **tmp___5 ;
  int tmp___6 ;
  DLG_KEYS_BINDING *tmp___7 ;

  {
  {
#line 592
  tmp = skip_white(params);
#line 592
  p = tmp;
#line 594
  escaped = (_Bool)0;
#line 595
  modified = 0;
#line 596
  result = 0;
#line 599
  is_function = 0;
#line 603
  curses_key = -1;
#line 604
  dialog_key = -1;
#line 605
  widget = p;
#line 607
  p = skip_black(p);
  }
#line 608
  if ((unsigned long )p != (unsigned long )widget) {
#line 608
    if ((int )*p != 0) {
      {
#line 609
      tmp___0 = p;
#line 609
      p ++;
#line 609
      *tmp___0 = (char )'\000';
#line 610
      p = skip_white(p);
#line 611
      q = p;
      }
      {
#line 612
      while (1) {
        while_continue: /* CIL Label */ ;
#line 612
        if ((int )*p != 0) {
#line 612
          if (! (curses_key < 0)) {
#line 612
            goto while_break;
          }
        } else {
#line 612
          goto while_break;
        }
#line 613
        if (escaped) {
#line 614
          escaped = (_Bool)0;
#line 615
          curses_key = (int )*p;
        } else
#line 616
        if ((int )*p == 92) {
#line 617
          escaped = (_Bool)1;
        } else
#line 618
        if (modified) {
#line 619
          if ((int )*p == 63) {
#line 620
            if (modified == 94) {
#line 620
              curses_key = 127;
            } else {
#line 620
              curses_key = 255;
            }
          } else
#line 624
          if (modified == 94) {
#line 624
            curses_key = (int )*p & 31;
          } else {
#line 624
            curses_key = ((int )*p & 31) | 128;
          }
        } else
#line 628
        if ((int )*p == 94) {
#line 629
          modified = (int )*p;
        } else
#line 630
        if ((int )*p == 126) {
#line 631
          modified = (int )*p;
        } else {
          {
#line 632
          tmp___1 = __ctype_b_loc();
          }
#line 632
          if ((int const   )*(*tmp___1 + (int )((unsigned char )*p)) & 8192) {
#line 633
            goto while_break;
          }
        }
#line 635
        p ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 637
      tmp___5 = __ctype_b_loc();
      }
#line 637
      if ((int const   )*(*tmp___5 + (int )((unsigned char )*p)) & 8192) {
#line 640
        tmp___2 = p;
#line 640
        p ++;
#line 640
        *tmp___2 = (char )'\000';
#line 641
        if (curses_key < 0) {
          {
#line 645
          tmp___4 = sscanf((char const   */* __restrict  */)q, (char const   */* __restrict  */)"%[Ff]%d%c",
                           fprefix, & keynumber, check);
          }
#line 645
          if (tmp___4 == 2) {
#line 646
            curses_key = 264 + keynumber;
#line 647
            is_function = 1;
          } else {
#line 649
            xx = 0U;
            {
#line 649
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 649
              if (! ((unsigned long )xx < sizeof(curses_names) / sizeof(curses_names[0]))) {
#line 649
                goto while_break___0;
              }
              {
#line 650
              tmp___3 = strcasecmp((char const   *)curses_names[xx].name, (char const   *)q);
              }
#line 650
              if (! tmp___3) {
#line 651
                curses_key = (int )curses_names[xx].code;
#line 652
                is_function = curses_key >= 257;
#line 653
                goto while_break___0;
              }
#line 649
              xx ++;
            }
            while_break___0: /* CIL Label */ ;
            }
          }
        }
      }
      {
#line 659
      q = skip_white(p);
#line 660
      p = skip_black(q);
      }
#line 661
      if ((unsigned long )p != (unsigned long )q) {
#line 662
        xx = 0U;
        {
#line 662
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 662
          if (! ((unsigned long )xx < sizeof(dialog_names) / sizeof(dialog_names[0]))) {
#line 662
            goto while_break___1;
          }
          {
#line 663
          tmp___6 = strcasecmp((char const   *)dialog_names[xx].name, (char const   *)q);
          }
#line 663
          if (! tmp___6) {
#line 664
            dialog_key = (int )dialog_names[xx].code;
#line 665
            goto while_break___1;
          }
#line 662
          xx ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 669
      if ((int )*widget != 0) {
#line 669
        if (curses_key >= 0) {
#line 669
          if (dialog_key >= 0) {
            {
#line 669
            tmp___7 = make_binding(widget, curses_key, is_function, dialog_key);
            }
#line 669
            if ((unsigned long )tmp___7 != (unsigned long )((DLG_KEYS_BINDING *)0)) {
#line 673
              result = 1;
            }
          }
        }
      }
    }
  }
#line 676
  return (result);
}
}
#line 679 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dlg_keys.c"
static void dump_curses_key(FILE *fp , int curses_key ) 
{ 
  unsigned int n ;
  _Bool found ;

  {
#line 682
  if (curses_key > 257) {
#line 684
    found = (_Bool)0;
#line 685
    n = 0U;
    {
#line 685
    while (1) {
      while_continue: /* CIL Label */ ;
#line 685
      if (! ((unsigned long )n < sizeof(curses_names) / sizeof(curses_names[0]))) {
#line 685
        goto while_break;
      }
#line 686
      if (curses_names[n].code == (int const   )curses_key) {
        {
#line 687
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s",
                curses_names[n].name);
#line 688
        found = (_Bool)1;
        }
#line 689
        goto while_break;
      }
#line 685
      n ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 692
    if (! found) {
#line 693
      if (curses_key >= 264) {
        {
#line 694
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"F%d",
                curses_key - 264);
        }
      } else {
        {
#line 696
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"curses%d",
                curses_key);
        }
      }
    }
  } else
#line 699
  if (curses_key >= 0) {
#line 699
    if (curses_key < 32) {
      {
#line 700
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"^%c",
              curses_key + 64);
      }
    } else {
#line 699
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 701
  if (curses_key == 127) {
    {
#line 702
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"^?");
    }
  } else
#line 703
  if (curses_key >= 128) {
#line 703
    if (curses_key < 160) {
      {
#line 704
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"~%c",
              curses_key - 64);
      }
    } else {
#line 703
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 705
  if (curses_key == 255) {
    {
#line 706
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"~?");
    }
  } else {
    {
#line 708
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\\%c",
            curses_key);
    }
  }
#line 710
  return;
}
}
#line 712 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dlg_keys.c"
static void dump_dialog_key(FILE *fp , int dialog_key ) 
{ 
  unsigned int n ;
  _Bool found ;

  {
#line 716
  found = (_Bool)0;
#line 717
  n = 0U;
  {
#line 717
  while (1) {
    while_continue: /* CIL Label */ ;
#line 717
    if (! ((unsigned long )n < sizeof(dialog_names) / sizeof(dialog_names[0]))) {
#line 717
      goto while_break;
    }
#line 718
    if (dialog_names[n].code == (int const   )dialog_key) {
      {
#line 719
      fputs((char const   */* __restrict  */)dialog_names[n].name, (FILE */* __restrict  */)fp);
#line 720
      found = (_Bool)1;
      }
#line 721
      goto while_break;
    }
#line 717
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 724
  if (! found) {
    {
#line 725
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"dialog%d",
            dialog_key);
    }
  }
#line 727
  return;
}
}
#line 729 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dlg_keys.c"
static void dump_one_binding(FILE *fp , char const   *widget , DLG_KEYS_BINDING *binding___7 ) 
{ 


  {
  {
#line 732
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"bindkey %s ",
          widget);
#line 733
  dump_curses_key(fp, binding___7->curses_key);
#line 734
  fputc(' ', fp);
#line 735
  dump_dialog_key(fp, binding___7->dialog_key);
#line 736
  fputc('\n', fp);
  }
#line 737
  return;
}
}
#line 744 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dlg_keys.c"
void dlg_dump_window_keys(FILE *fp , WINDOW *win ) 
{ 
  struct _list_bindings *p ;
  DLG_KEYS_BINDING *q ;
  char const   *last ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 747
  if ((unsigned long )fp != (unsigned long )((FILE *)0)) {
#line 750
    last = "";
#line 752
    p = all_bindings;
    {
#line 752
    while (1) {
      while_continue: /* CIL Label */ ;
#line 752
      if (! ((unsigned long )p != (unsigned long )((struct _list_bindings *)0))) {
#line 752
        goto while_break;
      }
#line 753
      if ((unsigned long )p->win == (unsigned long )win) {
        {
#line 754
        tmp___2 = strcasecmp(last, p->name);
        }
#line 754
        if (tmp___2) {
          {
#line 755
          tmp___1 = strcmp(p->name, "*");
          }
#line 755
          if (tmp___1) {
#line 755
            tmp___0 = p->name;
          } else {
#line 755
            tmp___0 = "all";
          }
          {
#line 755
          fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n# key bindings for %s widgets\n",
                  tmp___0);
#line 757
          last = p->name;
          }
        }
#line 759
        q = p->binding;
        {
#line 759
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 759
          if (! (q->is_function_key >= 0)) {
#line 759
            goto while_break___0;
          }
          {
#line 760
          dump_one_binding(fp, p->name, q);
#line 759
          q ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 752
      p = p->link;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 765
  return;
}
}
#line 771 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/dlg_keys.c"
void dlg_dump_keys(FILE *fp ) 
{ 
  struct _list_bindings *p ;
  unsigned int count ;

  {
#line 774
  if ((unsigned long )fp != (unsigned long )((FILE *)0)) {
#line 776
    count = 0U;
#line 778
    p = all_bindings;
    {
#line 778
    while (1) {
      while_continue: /* CIL Label */ ;
#line 778
      if (! ((unsigned long )p != (unsigned long )((struct _list_bindings *)0))) {
#line 778
        goto while_break;
      }
#line 779
      if ((unsigned long )p->win == (unsigned long )((WINDOW *)0)) {
#line 780
        count ++;
      }
#line 778
      p = p->link;
    }
    while_break: /* CIL Label */ ;
    }
#line 783
    if (count != 0U) {
      {
#line 784
      dlg_dump_window_keys(fp, (WINDOW *)0);
      }
    }
  }
#line 787
  return;
}
}
#line 622 "/usr/include/stdio.h"
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 795 "/usr/include/curses.h"
extern int wattr_off(WINDOW * , attr_t  , void * ) ;
#line 809
extern int werase(WINDOW * ) ;
#line 814
extern chtype winch(WINDOW * ) ;
#line 693 "./dialog.h"
void *dlg_allocate_gauge(char const   *title , char const   *cprompt , int height ,
                         int width , int percent ) ;
#line 694
void *dlg_reallocate_gauge(void *objptr , char const   *title , char const   *cprompt ,
                           int height , int width , int percent ) ;
#line 695
void dlg_free_gauge(void *objptr ) ;
#line 696
void dlg_update_gauge(void *objptr , int percent ) ;
#line 707
void dlg_finish_string(char const   *string ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 51 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/guage.c"
static MY_OBJ *all_objects  ;
#line 53 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/guage.c"
static int valid(MY_OBJ *obj ) 
{ 
  MY_OBJ *list ;
  int result ;

  {
#line 56
  list = all_objects;
#line 57
  result = 0;
  {
#line 59
  while (1) {
    while_continue: /* CIL Label */ ;
#line 59
    if (! ((unsigned long )list != (unsigned long )((MY_OBJ *)0))) {
#line 59
      goto while_break;
    }
#line 60
    if ((unsigned long )list == (unsigned long )obj) {
#line 61
      result = 1;
#line 62
      goto while_break;
    }
#line 64
    list = list->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 66
  return (result);
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/guage.c"
static void delink(MY_OBJ *obj ) 
{ 
  MY_OBJ *p ;
  MY_OBJ *q ;

  {
#line 72
  p = all_objects;
#line 73
  q = (MY_OBJ *)0;
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
#line 74
    if (! ((unsigned long )p != (unsigned long )((MY_OBJ *)0))) {
#line 74
      goto while_break;
    }
#line 75
    if ((unsigned long )p == (unsigned long )obj) {
#line 76
      if ((unsigned long )q != (unsigned long )((MY_OBJ *)0)) {
#line 77
        q->next = p->next;
      } else {
#line 79
        all_objects = p->next;
      }
#line 81
      goto while_break;
    }
#line 83
    q = p;
#line 84
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 86
  return;
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/guage.c"
static int read_data(char *buffer , FILE *fp ) 
{ 
  int result ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 93
  tmp___0 = feof(fp);
  }
#line 93
  if (tmp___0) {
#line 94
    result = 0;
  } else {
    {
#line 95
    tmp = fgets((char */* __restrict  */)buffer, 1024, (FILE */* __restrict  */)fp);
    }
#line 95
    if ((unsigned long )tmp != (unsigned long )((char *)0)) {
      {
#line 96
      dlg_trace_msg("read_data:%s", buffer);
#line 97
      *(buffer + 1024) = (char )'\000';
#line 98
      dlg_trim_string(buffer);
#line 99
      result = 1;
      }
    } else {
#line 101
      result = -1;
    }
  }
#line 103
  return (result);
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/guage.c"
static int decode_percent(char *buffer ) 
{ 
  char *tmp ;
  long value ;
  long tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
  {
#line 109
  tmp = (char *)0;
#line 110
  tmp___0 = strtol((char const   */* __restrict  */)buffer, (char **/* __restrict  */)(& tmp),
                   10);
#line 110
  value = tmp___0;
  }
#line 112
  if ((unsigned long )tmp != (unsigned long )((char *)0)) {
#line 112
    if ((int )*tmp == 0) {
#line 112
      goto _L;
    } else {
      {
#line 112
      tmp___1 = __ctype_b_loc();
      }
#line 112
      if ((int const   )*(*tmp___1 + (int )((unsigned char )*tmp)) & 8192) {
        _L: /* CIL Label */ 
#line 112
        if (value >= 0L) {
#line 113
          return (1);
        }
      }
    }
  }
#line 115
  return (0);
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/guage.c"
static void repaint_text(MY_OBJ *obj ) 
{ 
  WINDOW *dialog ;
  int i ;
  int x ;
  chtype ch2 ;
  chtype tmp ;

  {
#line 121
  dialog = obj->obj.win;
#line 124
  if ((unsigned long )dialog != (unsigned long )((WINDOW *)0)) {
#line 124
    if ((unsigned long )obj->obj.input != (unsigned long )((FILE *)0)) {
      {
#line 125
      werase(dialog);
#line 126
      dlg_draw_box2(dialog, 0, 0, obj->height, obj->width, dlg_color_table[2].atr,
                    dlg_color_table[4].atr, dlg_color_table[34].atr);
#line 129
      dlg_draw_title(dialog, (char const   *)obj->title);
      }
#line 131
      if (dialog) {
#line 131
        dialog->_attrs = dlg_color_table[2].atr;
      }
      {
#line 132
      dlg_draw_helpline(dialog, (_Bool)0);
#line 133
      dlg_print_autowrap(dialog, (char const   *)obj->prompt, obj->height, obj->width);
#line 135
      dlg_draw_box2(dialog, obj->height - 4, 3, 3, obj->width - 6, dlg_color_table[2].atr,
                    dlg_color_table[4].atr, dlg_color_table[34].atr);
#line 147
      wmove(dialog, obj->height - 3, 4);
      }
#line 148
      if (dialog) {
#line 148
        dialog->_attrs = dlg_color_table[33].atr;
      }
#line 150
      i = 0;
      {
#line 150
      while (1) {
        while_continue: /* CIL Label */ ;
#line 150
        if (! (i < obj->width - 8)) {
#line 150
          goto while_break;
        }
        {
#line 151
        waddch(dialog, (chtype const   )' ');
#line 150
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 153
      wmove(dialog, obj->height - 3, obj->width / 2 - 2);
#line 154
      wprintw(dialog, "%3d%%", obj->percent);
#line 161
      x = (obj->percent * (obj->width - 8)) / 100;
      }
#line 162
      if ((dlg_color_table[33].atr & (1UL << 18)) != 0UL) {
        {
#line 163
        wattr_off(dialog, 1UL << 18, (void *)0);
        }
      } else
#line 165
      if (dialog) {
#line 165
        dialog->_attrs = 1UL << 18;
      }
      {
#line 167
      wmove(dialog, obj->height - 3, 4);
#line 168
      i = 0;
      }
      {
#line 168
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 168
        if (! (i < x)) {
#line 168
          goto while_break___0;
        }
        {
#line 169
        tmp = winch(dialog);
#line 169
        ch2 = tmp;
        }
#line 170
        if (dlg_color_table[33].atr & (1UL << 18)) {
#line 171
          ch2 &= ~ (1UL << 18);
        }
        {
#line 173
        waddch(dialog, (chtype const   )ch2);
#line 168
        i ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 176
      wrefresh(dialog);
      }
    }
  }
#line 178
  return;
}
}
#line 180 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/guage.c"
static _Bool handle_input(DIALOG_CALLBACK *cb ) 
{ 
  MY_OBJ *obj ;
  _Bool result ;
  int status ;
  char buf[1025] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;

  {
#line 183
  obj = (MY_OBJ *)cb;
#line 188
  if ((unsigned long )dialog_state.pipe_input == (unsigned long )((FILE *)0)) {
#line 189
    status = -1;
  } else {
    {
#line 190
    status = read_data(buf, dialog_state.pipe_input);
    }
#line 190
    if (status > 0) {
      {
#line 192
      tmp___4 = strncmp((char const   *)(buf), "XXX", (size_t )3);
      }
#line 192
      if (tmp___4) {
        {
#line 219
        tmp___3 = decode_percent(buf);
        }
#line 219
        if (tmp___3) {
          {
#line 220
          obj->percent = atoi((char const   *)(buf));
          }
        }
      } else {
        {
#line 198
        status = read_data(buf, dialog_state.pipe_input);
        }
#line 198
        if (status > 0) {
          {
#line 200
          obj->prompt_buf[0] = (char )'\000';
#line 201
          tmp = decode_percent(buf);
          }
#line 201
          if (tmp) {
            {
#line 202
            obj->percent = atoi((char const   *)(buf));
            }
          } else {
            {
#line 204
            strcpy((char */* __restrict  */)(obj->prompt_buf), (char const   */* __restrict  */)(buf));
            }
          }
          {
#line 207
          while (1) {
            while_continue: /* CIL Label */ ;
            {
#line 207
            status = read_data(buf, dialog_state.pipe_input);
            }
#line 207
            if (status > 0) {
              {
#line 207
              tmp___2 = strncmp((char const   *)(buf), "XXX", (size_t )3);
              }
#line 207
              if (! tmp___2) {
#line 207
                goto while_break;
              }
            } else {
#line 207
              goto while_break;
            }
            {
#line 209
            tmp___0 = strlen((char const   *)(obj->prompt_buf));
#line 209
            tmp___1 = strlen((char const   *)(buf));
            }
#line 209
            if (tmp___0 + tmp___1 < sizeof(obj->prompt_buf) - 1UL) {
              {
#line 211
              strcat((char */* __restrict  */)(obj->prompt_buf), (char const   */* __restrict  */)(buf));
              }
            }
          }
          while_break: /* CIL Label */ ;
          }
#line 215
          if ((unsigned long )obj->prompt != (unsigned long )(obj->prompt_buf)) {
            {
#line 216
            free((void *)obj->prompt);
            }
          }
#line 217
          obj->prompt = obj->prompt_buf;
        }
      }
    } else {
      {
#line 223
      tmp___5 = feof(dialog_state.pipe_input);
      }
#line 223
      if (tmp___5) {
        {
#line 225
        delink(obj);
#line 226
        dlg_remove_callback(cb);
        }
      } else {
        {
#line 223
        tmp___6 = ferror(dialog_state.pipe_input);
        }
#line 223
        if (tmp___6) {
          {
#line 223
          tmp___7 = __errno_location();
          }
#line 223
          if (*tmp___7 != 4) {
            {
#line 225
            delink(obj);
#line 226
            dlg_remove_callback(cb);
            }
          }
        }
      }
    }
  }
#line 230
  if (status > 0) {
    {
#line 231
    result = (_Bool)1;
#line 232
    repaint_text(obj);
    }
  } else {
#line 234
    result = (_Bool)0;
  }
#line 237
  return (result);
}
}
#line 240 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/guage.c"
static _Bool handle_my_getc(DIALOG_CALLBACK *cb , int ch , int fkey , int *result ) 
{ 
  int status ;
  int tmp ;
  int tmp___0 ;

  {
#line 243
  status = 1;
#line 245
  *result = 0;
#line 246
  if ((unsigned long )cb != (unsigned long )((DIALOG_CALLBACK *)0)) {
#line 247
    if (! fkey) {
#line 247
      if (ch == -1) {
        {
#line 248
        handle_input(cb);
#line 250
        tmp = valid((MY_OBJ *)cb);
        }
#line 250
        if (tmp) {
#line 250
          if ((unsigned long )cb->input != (unsigned long )((FILE *)0)) {
#line 250
            tmp___0 = 1;
          } else {
#line 250
            tmp___0 = 0;
          }
        } else {
#line 250
          tmp___0 = 0;
        }
#line 250
        status = tmp___0;
      }
    }
  } else {
#line 253
    status = 0;
  }
#line 255
  return ((_Bool )status);
}
}
#line 258 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/guage.c"
static void my_cleanup(DIALOG_CALLBACK *cb ) 
{ 
  MY_OBJ *obj ;
  int tmp ;

  {
  {
#line 261
  obj = (MY_OBJ *)cb;
#line 263
  tmp = valid(obj);
  }
#line 263
  if (tmp) {
#line 264
    if ((unsigned long )obj->prompt != (unsigned long )(obj->prompt_buf)) {
      {
#line 265
      free((void *)obj->prompt);
#line 266
      obj->prompt = obj->prompt_buf;
      }
    }
    {
#line 268
    delink(obj);
    }
  }
#line 270
  return;
}
}
#line 272 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/guage.c"
void dlg_update_gauge(void *objptr , int percent ) 
{ 
  MY_OBJ *obj ;
  _Bool save_finish_string ;

  {
  {
#line 275
  obj = (MY_OBJ *)objptr;
#line 276
  save_finish_string = dialog_state.finish_string;
#line 278
  dialog_state.finish_string = (_Bool)1;
#line 279
  curs_set(0);
#line 280
  obj->percent = percent;
#line 281
  repaint_text(obj);
#line 282
  dialog_state.finish_string = save_finish_string;
  }
#line 283
  return;
}
}
#line 288 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/guage.c"
void *dlg_reallocate_gauge(void *objptr , char const   *title , char const   *cprompt ,
                           int height , int width , int percent ) 
{ 
  char *prompt ;
  char *tmp ;
  MY_OBJ *obj ;
  _Bool save_finish_string ;
  void *tmp___0 ;
  int x ;
  int tmp___1 ;
  int y ;
  int tmp___2 ;
  WINDOW *dialog ;
  WINDOW *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 296
  tmp = dlg_strclone(cprompt);
#line 296
  prompt = tmp;
#line 297
  obj = (MY_OBJ *)objptr;
#line 298
  save_finish_string = dialog_state.finish_string;
#line 300
  dialog_state.finish_string = (_Bool)1;
#line 301
  dlg_tab_correct_str(prompt);
  }
#line 303
  if ((unsigned long )objptr == (unsigned long )((void *)0)) {
    {
#line 305
    tmp___0 = calloc((size_t )1, sizeof(MY_OBJ ));
#line 305
    obj = (MY_OBJ *)tmp___0;
    }
#line 306
    if ((unsigned long )obj == (unsigned long )((MY_OBJ *)0)) {
      {
#line 306
      dlg_exiterr("cannot allocate memory in dialog_gauge");
      }
    }
    {
#line 308
    dlg_auto_size(title, (char const   *)prompt, & height, & width, 4, 16);
#line 309
    dlg_print_size(height, width);
#line 310
    dlg_ctl_size(height, width);
    }
  } else {
#line 314
    obj = (MY_OBJ *)objptr;
#line 315
    height = obj->height;
#line 316
    width = obj->width;
  }
#line 319
  if ((unsigned long )obj->obj.win == (unsigned long )((WINDOW *)0)) {
    {
#line 321
    tmp___1 = dlg_box_x_ordinate(width);
#line 321
    x = tmp___1;
#line 322
    tmp___2 = dlg_box_y_ordinate(height);
#line 322
    y = tmp___2;
#line 323
    tmp___3 = dlg_new_window(height, width, y, x);
#line 323
    dialog = tmp___3;
#line 324
    obj->obj.win = dialog;
    }
  }
#line 327
  obj->obj.input = dialog_state.pipe_input;
#line 328
  obj->obj.keep_win = (_Bool)1;
#line 329
  obj->obj.bg_task = (_Bool)1;
#line 330
  obj->obj.handle_getc = & handle_my_getc;
#line 331
  obj->obj.handle_input = & handle_input;
#line 333
  if ((unsigned long )obj->title == (unsigned long )((char *)0)) {
    {
#line 334
    dlg_finish_string((char const   *)obj->title);
#line 335
    free((void *)obj->title);
#line 336
    obj->title = dlg_strclone(title);
    }
  } else {
    {
#line 333
    tmp___4 = strcmp((char const   *)obj->title, title);
    }
#line 333
    if (tmp___4) {
      {
#line 334
      dlg_finish_string((char const   *)obj->title);
#line 335
      free((void *)obj->title);
#line 336
      obj->title = dlg_strclone(title);
      }
    }
  }
  {
#line 339
  dlg_finish_string((char const   *)obj->prompt);
#line 340
  free((void *)obj->prompt);
#line 342
  obj->prompt = prompt;
#line 343
  obj->percent = percent;
#line 344
  obj->height = height;
#line 345
  obj->width = width;
  }
#line 348
  if ((unsigned long )objptr == (unsigned long )((void *)0)) {
#line 349
    obj->next = all_objects;
#line 350
    all_objects = obj;
  }
#line 353
  dialog_state.finish_string = save_finish_string;
#line 354
  return ((void *)obj);
}
}
#line 357 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/guage.c"
void *dlg_allocate_gauge(char const   *title , char const   *cprompt , int height ,
                         int width , int percent ) 
{ 
  void *tmp ;

  {
  {
#line 364
  tmp = dlg_reallocate_gauge((void *)0, title, cprompt, height, width, percent);
  }
#line 364
  return (tmp);
}
}
#line 367 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/guage.c"
void dlg_free_gauge(void *objptr ) 
{ 
  MY_OBJ *obj ;
  int tmp ;

  {
  {
#line 370
  obj = (MY_OBJ *)objptr;
#line 372
  curs_set(1);
#line 373
  tmp = valid(obj);
  }
#line 373
  if (tmp) {
    {
#line 374
    delink(obj);
#line 375
    obj->obj.keep_win = (_Bool)0;
#line 376
    dlg_remove_callback(& obj->obj);
    }
  }
#line 378
  return;
}
}
#line 388 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/guage.c"
int dialog_gauge(char const   *title , char const   *cprompt , int height , int width ,
                 int percent ) 
{ 
  int fkey ;
  int ch ;
  int result ;
  void *objptr ;
  void *tmp ;
  MY_OBJ *obj ;
  MY_OBJ *oldobj ;
  void *tmp___0 ;
  int tmp___1 ;
  _Bool tmp___2 ;

  {
  {
#line 397
  tmp = dlg_allocate_gauge(title, cprompt, height, width, percent);
#line 397
  objptr = tmp;
#line 398
  obj = (MY_OBJ *)objptr;
#line 400
  dlg_add_callback_ref((DIALOG_CALLBACK **)(& obj), & my_cleanup);
#line 401
  dlg_update_gauge((void *)obj, percent);
#line 403
  dlg_trace_win(obj->obj.win);
  }
  {
#line 404
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 405
    ch = dlg_getc(obj->obj.win, & fkey);
    }
#line 407
    if (fkey) {
#line 407
      if (ch == 410) {
        {
#line 408
        oldobj = obj;
#line 410
        dlg_mouse_free_regions();
#line 412
        tmp___0 = dlg_allocate_gauge(title, cprompt, height, width, oldobj->percent);
#line 412
        obj = (MY_OBJ *)tmp___0;
#line 419
        oldobj->obj.caller = (struct _dlg_callback **)0;
#line 420
        oldobj->obj.input = (FILE *)0;
#line 421
        oldobj->obj.keep_win = (_Bool)0;
#line 424
        dlg_clear();
#line 425
        dlg_remove_callback(& oldobj->obj);
#line 426
        wrefresh(stdscr);
#line 428
        dlg_add_callback_ref((DIALOG_CALLBACK **)(& obj), & my_cleanup);
#line 429
        dlg_update_gauge((void *)obj, obj->percent);
        }
      }
    }
    {
#line 404
    tmp___1 = valid(obj);
    }
#line 404
    if (tmp___1) {
      {
#line 404
      tmp___2 = handle_my_getc(& obj->obj, ch, fkey, & result);
      }
#line 404
      if (! tmp___2) {
#line 404
        goto while_break;
      }
    } else {
#line 404
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 435
  dlg_free_gauge((void *)obj);
  }
#line 437
  return (0);
}
}
#line 699 "/usr/include/curses.h"
extern int mvwprintw(WINDOW * , int  , int  , char const   *  , ...) ;
#line 205 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 64 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/calendar.c"
static char const   *nameOfDayOfWeek(int n ) ;
#line 64 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/calendar.c"
static char const   *table___0[7]  = {      "Sunday",      "Monday",      "Tuesday",      "Wednesday", 
        "Thursday",      "Friday",      "Saturday"};
#line 61 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/calendar.c"
static char const   *nameOfDayOfWeek(int n ) 
{ 
  char const   *result ;

  {
#line 78
  result = (char const   *)0;
#line 80
  if (n >= 0) {
#line 80
    if (n < 7) {
#line 90
      result = table___0[n];
    }
  }
#line 92
  if ((unsigned long )result == (unsigned long )((char const   *)0)) {
#line 93
    result = "?";
  }
#line 95
  return (result);
}
}
#line 101
static char const   *nameOfMonth(int n ) ;
#line 101 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/calendar.c"
static char const   *table___1[12]  = 
#line 101
  {      "January",      "February",      "March",      "April", 
        "May",      "June",      "July",      "August", 
        "September",      "October",      "November",      "December"};
#line 98 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/calendar.c"
static char const   *nameOfMonth(int n ) 
{ 
  char const   *result ;

  {
#line 120
  result = (char const   *)0;
#line 122
  if (n >= 0) {
#line 122
    if (n < 12) {
#line 133
      result = table___1[n];
    }
  }
#line 135
  if ((unsigned long )result == (unsigned long )((char const   *)0)) {
#line 136
    result = "?";
  }
#line 138
  return (result);
}
}
#line 144
static int days_in_month(struct tm *current , int offset ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/calendar.c"
static int const   nominal[12]  = 
#line 144
  {      (int const   )31,      (int const   )28,      (int const   )31,      (int const   )30, 
        (int const   )31,      (int const   )30,      (int const   )31,      (int const   )31, 
        (int const   )30,      (int const   )31,      (int const   )30,      (int const   )31};
#line 141 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/calendar.c"
static int days_in_month(struct tm *current , int offset ) 
{ 
  int year ;
  int month ;
  int result ;

  {
#line 149
  year = current->tm_year;
#line 150
  month = current->tm_mon + offset;
  {
#line 153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 153
    if (! (month < 0)) {
#line 153
      goto while_break;
    }
#line 154
    month += 12;
#line 155
    year --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 157
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 157
    if (! (month >= 12)) {
#line 157
      goto while_break___0;
    }
#line 158
    month -= 12;
#line 159
    year ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 161
  result = (int )nominal[month];
#line 162
  if (month == 1) {
#line 163
    result += year % 4 == 0;
  }
#line 164
  return (result);
}
}
#line 167 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/calendar.c"
static int days_in_year(struct tm *current , int offset ) 
{ 
  int year ;
  int tmp ;

  {
#line 170
  year = (current->tm_year + 1900) + offset;
#line 172
  if (year % 4 == 0) {
#line 172
    tmp = 366;
  } else {
#line 172
    tmp = 365;
  }
#line 172
  return (tmp);
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/calendar.c"
static int day_cell_number(struct tm *current ) 
{ 
  int cell ;

  {
#line 179
  cell = current->tm_mday - ((6 + current->tm_mday) - current->tm_wday) % 7;
#line 180
  if ((current->tm_mday - 1) % 7 != current->tm_wday) {
#line 181
    cell += 6;
  } else {
#line 183
    cell --;
  }
#line 184
  return (cell);
}
}
#line 187 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/calendar.c"
static int next_or_previous(int key , int two_d ) 
{ 
  int result ;

  {
#line 190
  result = 0;
  {
#line 193
  if (key == 534) {
#line 193
    goto case_534;
  }
#line 196
  if (key == 536) {
#line 196
    goto case_536;
  }
#line 199
  if (key == 535) {
#line 199
    goto case_535;
  }
#line 202
  if (key == 537) {
#line 202
    goto case_537;
  }
#line 205
  goto switch_default;
  case_534: /* CIL Label */ 
#line 194
  if (two_d) {
#line 194
    result = -7;
  } else {
#line 194
    result = -1;
  }
#line 195
  goto switch_break;
  case_536: /* CIL Label */ 
#line 197
  result = -1;
#line 198
  goto switch_break;
  case_535: /* CIL Label */ 
#line 200
  if (two_d) {
#line 200
    result = 7;
  } else {
#line 200
    result = 1;
  }
#line 201
  goto switch_break;
  case_537: /* CIL Label */ 
#line 203
  result = 1;
#line 204
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 206
  beep();
  }
#line 207
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 209
  return (result);
}
}
#line 215 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/calendar.c"
static int draw_day(BOX *data , struct tm *current ) 
{ 
  int cell_wide ;
  int y ;
  int x ;
  int this_x ;
  int save_y ;
  int save_x ;
  int day ;
  int mday ;
  int week ;
  int last ;
  int tmp ;
  int prev ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 218
  cell_wide = 4;
#line 219
  this_x = 0;
#line 220
  save_y = 0;
#line 220
  save_x = 0;
#line 221
  day = current->tm_mday;
#line 224
  tmp = days_in_month(current, 0);
#line 224
  last = tmp;
#line 225
  tmp___0 = days_in_month(current, -1);
#line 225
  prev = tmp___0;
#line 227
  werase(data->window);
#line 228
  dlg_draw_box2(data->parent, data->y - 1, data->x - 1, data->height + 2, data->width + 2,
                dlg_color_table[17].atr, dlg_color_table[18].atr, dlg_color_table[37].atr);
  }
#line 235
  if (data->window) {
#line 235
    (data->window)->_attrs = dlg_color_table[17].atr;
  }
#line 236
  x = 0;
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
#line 236
    if (! (x < 7)) {
#line 236
      goto while_break;
    }
    {
#line 237
    tmp___1 = nameOfDayOfWeek(x);
#line 237
    mvwprintw(data->window, 0, (x + 1) * cell_wide, "%*.*s ", cell_wide - 1, cell_wide - 1,
              tmp___1);
#line 236
    x ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 244
  mday = ((6 + current->tm_mday) - current->tm_wday) % 7 - 7;
#line 245
  if (mday <= -7) {
#line 246
    mday += 7;
  }
#line 248
  week = (((current->tm_yday + 6) + mday) - current->tm_mday) / 7;
#line 250
  y = 1;
  {
#line 250
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 250
    if (! (mday < last)) {
#line 250
      goto while_break___0;
    }
#line 251
    if (data->window) {
#line 251
      (data->window)->_attrs = dlg_color_table[17].atr;
    }
    {
#line 252
    week ++;
#line 252
    mvwprintw(data->window, y, 0, "%*d ", cell_wide - 1, week);
#line 257
    x = 0;
    }
    {
#line 257
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 257
      if (! (x < 7)) {
#line 257
        goto while_break___1;
      }
      {
#line 258
      this_x = 1 + (x + 1) * cell_wide;
#line 259
      mday ++;
#line 260
      tmp___2 = wmove(data->window, y, this_x);
      }
#line 260
      if (tmp___2 == -1) {
#line 261
        goto __Cont;
      }
#line 262
      if (data->window) {
#line 262
        (data->window)->_attrs = dlg_color_table[19].atr;
      }
#line 263
      if (mday == day) {
#line 264
        if (data->window) {
#line 264
          (data->window)->_attrs = dlg_color_table[20].atr;
        }
#line 265
        save_y = y;
#line 266
        save_x = this_x;
      }
#line 268
      if (mday > 0) {
#line 269
        if (mday <= last) {
          {
#line 270
          wprintw(data->window, "%*d", cell_wide - 2, mday);
          }
        } else
#line 271
        if (mday == day) {
          {
#line 272
          wprintw(data->window, "%*d", cell_wide - 2, mday - last);
          }
        }
      } else
#line 274
      if (mday == day) {
        {
#line 275
        wprintw(data->window, "%*d", cell_wide - 2, mday + prev);
        }
      }
      __Cont: /* CIL Label */ 
#line 257
      x ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 278
    wmove(data->window, save_y, save_x);
#line 250
    y ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 281
  dlg_draw_arrows(data->parent, 1, 1, data->x + 5, data->y - 1, data->y + data->height);
  }
#line 286
  return (0);
}
}
#line 292 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/calendar.c"
static int draw_month(BOX *data , struct tm *current ) 
{ 
  int month ;
  char const   *tmp ;

  {
#line 297
  month = current->tm_mon + 1;
#line 299
  if (data->parent) {
#line 299
    (data->parent)->_attrs = dlg_color_table[2].atr;
  }
  {
#line 300
  mvwprintw(data->parent, data->y - 2, data->x - 1, "Month");
#line 301
  dlg_draw_box2(data->parent, data->y - 1, data->x - 1, data->height + 2, data->width + 2,
                dlg_color_table[17].atr, dlg_color_table[18].atr, dlg_color_table[37].atr);
  }
#line 307
  if (data->window) {
#line 307
    (data->window)->_attrs = dlg_color_table[19].atr;
  }
  {
#line 308
  tmp = nameOfMonth(month - 1);
#line 308
  mvwprintw(data->window, 0, 0, "%s", tmp);
#line 309
  wmove(data->window, 0, 0);
  }
#line 310
  return (0);
}
}
#line 316 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/calendar.c"
static int draw_year(BOX *data , struct tm *current ) 
{ 
  int year ;

  {
#line 319
  year = current->tm_year + 1900;
#line 321
  if (data->parent) {
#line 321
    (data->parent)->_attrs = dlg_color_table[2].atr;
  }
  {
#line 322
  mvwprintw(data->parent, data->y - 2, data->x - 1, "Year");
#line 323
  dlg_draw_box2(data->parent, data->y - 1, data->x - 1, data->height + 2, data->width + 2,
                dlg_color_table[17].atr, dlg_color_table[18].atr, dlg_color_table[37].atr);
  }
#line 329
  if (data->window) {
#line 329
    (data->window)->_attrs = dlg_color_table[19].atr;
  }
  {
#line 330
  mvwprintw(data->window, 0, 0, "%4d", year);
#line 331
  wmove(data->window, 0, 0);
  }
#line 332
  return (0);
}
}
#line 335 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/calendar.c"
static int init_object(BOX *data , WINDOW *parent , int x , int y , int width , int height ,
                       int (*box_draw)(struct _box * , struct tm * ) , int code ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 343
  data->parent = parent;
#line 344
  data->x = x;
#line 345
  data->y = y;
#line 346
  data->width = width;
#line 347
  data->height = height;
#line 348
  data->box_draw = box_draw;
#line 350
  data->window = derwin(data->parent, data->height, data->width, data->y, data->x);
  }
#line 353
  if ((unsigned long )data->window == (unsigned long )((WINDOW *)0)) {
#line 354
    return (-1);
  }
  {
#line 355
  keypad(data->window, (_Bool)1);
  }
#line 357
  if (parent) {
#line 357
    tmp = (int )parent->_begy;
  } else {
#line 357
    tmp = -1;
  }
#line 357
  if (parent) {
#line 357
    tmp___0 = (int )parent->_begx;
  } else {
#line 357
    tmp___0 = -1;
  }
  {
#line 357
  dlg_mouse_setbase(tmp___0, tmp);
  }
#line 358
  if (code == 68) {
    {
#line 359
    dlg_mouse_mkbigregion(y + 1, x + 4, height - 1, width - 4, 511, 1, 4, 3);
    }
  } else {
    {
#line 362
    dlg_mouse_mkregion(y, x, height, width, code);
    }
  }
#line 365
  return (0);
}
}
#line 368 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/calendar.c"
static int CleanupResult(int code , WINDOW *dialog , char *prompt , DIALOG_VARS *save_vars ) 
{ 


  {
#line 371
  if ((unsigned long )dialog != (unsigned long )((WINDOW *)0)) {
    {
#line 372
    dlg_del_window(dialog);
    }
  }
  {
#line 373
  dlg_mouse_free_regions();
  }
#line 374
  if ((unsigned long )prompt != (unsigned long )((char *)0)) {
    {
#line 375
    free((void *)prompt);
    }
  }
  {
#line 376
  dlg_restore_vars(save_vars);
  }
#line 378
  return (code);
}
}
#line 396 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/calendar.c"
static DLG_KEYS_BINDING binding___5[29]  = 
#line 396
  {      {0, 5, 545}, 
        {1, 265, 545}, 
        {1, 363, 545}, 
        {0, '\n', 541}, 
        {0, '\r', 541}, 
        {1, 343, 541}, 
        {0, ' ', 541}, 
        {0, 9, 528}, 
        {1, 353, 529}, 
        {0, 'j', 535}, 
        {1, 1106, 535}, 
        {1, 258, 535}, 
        {1, 338, 535}, 
        {0, '-', 536}, 
        {0, 'h', 536}, 
        {0, 8, 536}, 
        {0, 16, 536}, 
        {1, 260, 536}, 
        {0, '+', 537}, 
        {0, 'l', 537}, 
        {0, 14, 537}, 
        {1, 367, 537}, 
        {1, 261, 537}, 
        {0, 'k', 534}, 
        {1, 339, 534}, 
        {1, 370, 534}, 
        {1, 259, 534}, 
        {1, 1107, 534}, 
        {-1, 0, 0}};
#line 386 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/calendar.c"
int dialog_calendar(char const   *title , char const   *subtitle , int height , int width ,
                    int day , int month , int year ) 
{ 
  int old_height ;
  int old_width ;
  BOX dy_box ;
  BOX mn_box ;
  BOX yr_box ;
  int fkey ;
  int key ;
  int key2 ;
  int step ;
  int button ;
  int result ;
  WINDOW *dialog ;
  time_t now_time ;
  time_t tmp ;
  struct tm current ;
  int state ;
  int tmp___0 ;
  char const   **buttons ;
  char const   **tmp___1 ;
  char *prompt ;
  char *tmp___2 ;
  int mincols ;
  char buffer[2048] ;
  DIALOG_VARS save_vars ;
  struct tm *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  struct tm *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  BOX *obj ;
  BOX *tmp___20 ;
  BOX *tmp___21 ;
  BOX *tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  struct tm old ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  struct tm *tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  size_t used ;
  size_t tmp___33 ;
  int tmp___34 ;

  {
  {
#line 426
  old_height = height;
#line 427
  old_width = width;
#line 431
  key = 0;
#line 435
  result = -2;
#line 437
  tmp = time((time_t *)0);
#line 437
  now_time = tmp;
#line 439
  tmp___0 = dlg_default_button();
#line 439
  state = tmp___0;
#line 440
  tmp___1 = dlg_ok_labels();
#line 440
  buttons = tmp___1;
#line 441
  tmp___2 = dlg_strclone(subtitle);
#line 441
  prompt = tmp___2;
#line 442
  mincols = 36;
#line 446
  dlg_save_vars(& save_vars);
#line 447
  dialog_vars.separate_output = (_Bool)1;
#line 449
  dlg_does_output();
#line 451
  now_time = time((time_t *)0);
#line 452
  tmp___3 = localtime((time_t const   *)(& now_time));
#line 452
  current = *tmp___3;
  }
#line 453
  if (day < 0) {
#line 454
    day = current.tm_mday;
  }
#line 455
  if (month < 0) {
#line 456
    month = current.tm_mon + 1;
  }
#line 457
  if (year < 0) {
#line 458
    year = current.tm_year + 1900;
  }
#line 461
  year -= 1900;
#line 461
  if (year > 0) {
#line 461
    if (year < 200) {
      {
#line 463
      while (1) {
        while_continue: /* CIL Label */ ;
#line 464
        if (year > current.tm_year) {
          {
#line 465
          tmp___4 = days_in_year(& current, 0);
#line 465
          now_time += (time_t )(86400 * tmp___4);
          }
        } else
#line 466
        if (year < current.tm_year) {
          {
#line 467
          tmp___5 = days_in_year(& current, -1);
#line 467
          now_time -= (time_t )(86400 * tmp___5);
          }
        } else
#line 468
        if (month > current.tm_mon + 1) {
          {
#line 469
          tmp___6 = days_in_month(& current, 0);
#line 469
          now_time += (time_t )(86400 * tmp___6);
          }
        } else
#line 470
        if (month < current.tm_mon + 1) {
          {
#line 471
          tmp___7 = days_in_month(& current, -1);
#line 471
          now_time -= (time_t )(86400 * tmp___7);
          }
        } else
#line 472
        if (day > current.tm_mday) {
#line 473
          now_time += 86400L;
        } else
#line 474
        if (day < current.tm_mday) {
#line 475
          now_time -= 86400L;
        } else {
#line 477
          goto while_break;
        }
        {
#line 479
        tmp___8 = localtime((time_t const   *)(& now_time));
#line 479
        current = *tmp___8;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 482
  dlg_button_layout(buttons, & mincols);
  }
  retry: 
  {
#line 488
  dlg_auto_size(title, (char const   *)prompt, & height, & width, 0, mincols);
#line 489
  height += 16;
#line 490
  dlg_print_size(height, width);
#line 491
  dlg_ctl_size(height, width);
#line 493
  tmp___9 = dlg_box_x_ordinate(width);
#line 493
  tmp___10 = dlg_box_y_ordinate(height);
#line 493
  dialog = dlg_new_window(height, width, tmp___10, tmp___9);
#line 496
  dlg_register_window(dialog, "calendar", binding___5);
#line 497
  dlg_register_buttons(dialog, "calendar", buttons);
#line 500
  dlg_draw_box2(dialog, 0, 0, height, width, dlg_color_table[2].atr, dlg_color_table[4].atr,
                dlg_color_table[34].atr);
#line 501
  dlg_draw_bottom_box2(dialog, dlg_color_table[4].atr, dlg_color_table[34].atr, dlg_color_table[2].atr);
#line 502
  dlg_draw_title(dialog, title);
  }
#line 504
  if (dialog) {
#line 504
    dialog->_attrs = dlg_color_table[2].atr;
  }
  {
#line 505
  dlg_print_autowrap(dialog, (char const   *)prompt, height, width);
#line 508
  memset((void *)(& dy_box), 0, sizeof(dy_box));
#line 509
  memset((void *)(& mn_box), 0, sizeof(mn_box));
#line 510
  memset((void *)(& yr_box), 0, sizeof(yr_box));
#line 512
  tmp___12 = init_object(& dy_box, dialog, (width - 32) / 2, 1 + (height - 12), 32,
                         7, & draw_day, 'D');
  }
#line 512
  if (tmp___12 < 0) {
    {
#line 521
    tmp___11 = CleanupResult(-1, dialog, prompt, & save_vars);
    }
#line 521
    return (tmp___11);
  } else {
    {
#line 512
    tmp___13 = (*(dy_box.box_draw))(& dy_box, & current);
    }
#line 512
    if (tmp___13 < 0) {
      {
#line 521
      tmp___11 = CleanupResult(-1, dialog, prompt, & save_vars);
      }
#line 521
      return (tmp___11);
    }
  }
  {
#line 524
  tmp___15 = init_object(& mn_box, dialog, dy_box.x, dy_box.y - 3, 15, 1, & draw_month,
                         'M');
  }
#line 524
  if (tmp___15 < 0) {
    {
#line 533
    tmp___14 = CleanupResult(-1, dialog, prompt, & save_vars);
    }
#line 533
    return (tmp___14);
  } else {
    {
#line 524
    tmp___16 = (*(mn_box.box_draw))(& mn_box, & current);
    }
#line 524
    if (tmp___16 < 0) {
      {
#line 533
      tmp___14 = CleanupResult(-1, dialog, prompt, & save_vars);
      }
#line 533
      return (tmp___14);
    }
  }
  {
#line 536
  tmp___18 = init_object(& yr_box, dialog, (dy_box.x + mn_box.width) + 2, mn_box.y,
                         mn_box.width, mn_box.height, & draw_year, 'Y');
  }
#line 536
  if (tmp___18 < 0) {
    {
#line 545
    tmp___17 = CleanupResult(-1, dialog, prompt, & save_vars);
    }
#line 545
    return (tmp___17);
  } else {
    {
#line 536
    tmp___19 = (*(yr_box.box_draw))(& yr_box, & current);
    }
#line 536
    if (tmp___19 < 0) {
      {
#line 545
      tmp___17 = CleanupResult(-1, dialog, prompt, & save_vars);
      }
#line 545
      return (tmp___17);
    }
  }
  {
#line 548
  dlg_trace_win(dialog);
  }
  {
#line 549
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 549
    if (! (result == -2)) {
#line 549
      goto while_break___0;
    }
#line 550
    if (state == -1) {
#line 550
      tmp___22 = & dy_box;
    } else {
#line 550
      if (state == -3) {
#line 550
        tmp___21 = & mn_box;
      } else {
#line 550
        if (state == -2) {
#line 550
          tmp___20 = & yr_box;
        } else {
#line 550
          tmp___20 = (BOX *)0;
        }
#line 550
        tmp___21 = tmp___20;
      }
#line 550
      tmp___22 = tmp___21;
    }
#line 550
    obj = tmp___22;
#line 554
    if (state < 0) {
#line 554
      button = 0;
    } else {
#line 554
      button = state;
    }
    {
#line 555
    dlg_draw_buttons(dialog, height - 2, 0, buttons, button, 0, width);
    }
#line 556
    if ((unsigned long )obj != (unsigned long )((BOX *)0)) {
      {
#line 557
      dlg_set_focus(dialog, obj->window);
      }
    }
    {
#line 559
    key = dlg_mouse_wgetch(dialog, & fkey);
#line 560
    tmp___23 = dlg_result_key(key, fkey, & result);
    }
#line 560
    if (tmp___23) {
#line 561
      goto while_break___0;
    }
#line 563
    if (fkey) {
#line 563
      if (key >= 1025) {
#line 563
        if (key <= 1279) {
          {
#line 564
          key = dlg_lookup_key(dialog, key - 768, & fkey);
          }
        }
      }
    }
    {
#line 567
    key2 = dlg_char_to_button(key, buttons);
    }
#line 567
    if (key2 >= 0) {
#line 568
      result = key2;
    } else
#line 569
    if (fkey) {
      {
#line 572
      if (key == 836) {
#line 572
        goto case_836;
      }
#line 575
      if (key == 845) {
#line 575
        goto case_845;
      }
#line 578
      if (key == 857) {
#line 578
        goto case_857;
      }
#line 581
      if (key == 541) {
#line 581
        goto case_541;
      }
#line 584
      if (key == 529) {
#line 584
        goto case_529;
      }
#line 587
      if (key == 528) {
#line 587
        goto case_528;
      }
#line 591
      if (key == 410) {
#line 591
        goto case_410;
      }
#line 602
      goto switch_default;
      case_836: /* CIL Label */ 
#line 573
      state = -1;
#line 574
      goto switch_break;
      case_845: /* CIL Label */ 
#line 576
      state = -3;
#line 577
      goto switch_break;
      case_857: /* CIL Label */ 
#line 579
      state = -2;
#line 580
      goto switch_break;
      case_541: /* CIL Label */ 
#line 582
      if (dialog_vars.nook) {
#line 582
        result = 0;
      } else {
        {
#line 582
        tmp___24 = dlg_ok_buttoncode(button);
#line 582
        result = tmp___24;
        }
      }
#line 583
      goto switch_break;
      case_529: /* CIL Label */ 
      {
#line 585
      state = dlg_prev_ok_buttonindex(state, -3);
      }
#line 586
      goto switch_break;
      case_528: /* CIL Label */ 
      {
#line 588
      state = dlg_next_ok_buttonindex(state, -3);
      }
#line 589
      goto switch_break;
      case_410: /* CIL Label */ 
      {
#line 593
      height = old_height;
#line 594
      width = old_width;
#line 596
      dlg_clear();
#line 597
      dlg_del_window(dialog);
#line 598
      wrefresh(stdscr);
#line 599
      dlg_mouse_free_regions();
      }
#line 600
      goto retry;
      switch_default: /* CIL Label */ 
#line 603
      step = 0;
#line 604
      key2 = -1;
#line 605
      if (key >= 768) {
        {
#line 606
        key2 = dlg_ok_buttoncode(key - 768);
        }
#line 606
        if (key2 >= 0) {
#line 607
          result = key2;
#line 608
          goto switch_break;
        } else
#line 609
        if (key >= 1279) {
          {
#line 610
          state = -1;
#line 611
          obj = & dy_box;
#line 612
          key2 = 1;
#line 613
          tmp___25 = day_cell_number(& current);
#line 613
          step = (key - 1279) - tmp___25;
          }
        }
      }
#line 618
      if ((unsigned long )obj != (unsigned long )((BOX *)0)) {
#line 619
        if (key2 < 0) {
          {
#line 620
          step = next_or_previous(key, (unsigned long )obj == (unsigned long )(& dy_box));
          }
        }
#line 621
        if (step != 0) {
#line 622
          old = current;
#line 625
          if ((unsigned long )obj == (unsigned long )(& dy_box)) {
#line 626
            now_time += (time_t )(86400 * step);
          } else
#line 627
          if ((unsigned long )obj == (unsigned long )(& mn_box)) {
#line 628
            if (step > 0) {
              {
#line 629
              tmp___26 = days_in_month(& current, 0);
#line 629
              now_time += (time_t )(86400 * tmp___26);
              }
            } else {
              {
#line 632
              tmp___27 = days_in_month(& current, -1);
#line 632
              now_time -= (time_t )(86400 * tmp___27);
              }
            }
          } else
#line 634
          if ((unsigned long )obj == (unsigned long )(& yr_box)) {
#line 635
            if (step > 0) {
              {
#line 636
              tmp___28 = days_in_year(& current, 0);
#line 636
              now_time += (time_t )(86400 * tmp___28);
              }
            } else {
              {
#line 639
              tmp___29 = days_in_year(& current, -1);
#line 639
              now_time -= (time_t )(86400 * tmp___29);
              }
            }
          }
          {
#line 643
          tmp___30 = localtime((time_t const   *)(& now_time));
#line 643
          current = *tmp___30;
          }
#line 645
          if ((unsigned long )obj != (unsigned long )(& dy_box)) {
#line 645
            if (current.tm_mday != old.tm_mday) {
              {
#line 649
              (*(dy_box.box_draw))(& dy_box, & current);
              }
            } else
#line 645
            if (current.tm_mon != old.tm_mon) {
              {
#line 649
              (*(dy_box.box_draw))(& dy_box, & current);
              }
            } else
#line 645
            if (current.tm_year != old.tm_year) {
              {
#line 649
              (*(dy_box.box_draw))(& dy_box, & current);
              }
            }
          }
#line 650
          if ((unsigned long )obj != (unsigned long )(& mn_box)) {
#line 650
            if (current.tm_mon != old.tm_mon) {
              {
#line 651
              (*(mn_box.box_draw))(& mn_box, & current);
              }
            }
          }
#line 652
          if ((unsigned long )obj != (unsigned long )(& yr_box)) {
#line 652
            if (current.tm_year != old.tm_year) {
              {
#line 653
              (*(yr_box.box_draw))(& yr_box, & current);
              }
            }
          }
          {
#line 654
          (*(obj->box_draw))(obj, & current);
          }
        }
      } else
#line 656
      if (state >= 0) {
        {
#line 657
        tmp___32 = next_or_previous(key, 0);
        }
#line 657
        if (tmp___32 < 0) {
          {
#line 658
          state = dlg_prev_ok_buttonindex(state, -3);
          }
        } else {
          {
#line 659
          tmp___31 = next_or_previous(key, 0);
          }
#line 659
          if (tmp___31 > 0) {
            {
#line 660
            state = dlg_next_ok_buttonindex(state, -3);
            }
          }
        }
      }
#line 662
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 671
  if ((unsigned long )dialog_vars.date_format != (unsigned long )((char *)0)) {
    {
#line 672
    tmp___33 = strftime((char */* __restrict  */)(buffer), sizeof(buffer) - 1UL, (char const   */* __restrict  */)dialog_vars.date_format,
                        (struct tm  const  */* __restrict  */)(& current));
#line 672
    used = tmp___33;
    }
#line 676
    if (used == 0UL) {
      {
#line 677
      sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"%02d/%02d/%0d",
              current.tm_mday, current.tm_mon + 1, current.tm_year + 1900);
      }
    } else
#line 676
    if ((int )buffer[0] == 0) {
      {
#line 677
      sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"%02d/%02d/%0d",
              current.tm_mday, current.tm_mon + 1, current.tm_year + 1900);
      }
    }
  } else {
    {
#line 680
    sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"%02d/%02d/%0d",
            current.tm_mday, current.tm_mon + 1, current.tm_year + 1900);
    }
  }
  {
#line 682
  dlg_add_result((char const   *)(buffer));
#line 683
  dlg_add_separator();
#line 684
  dlg_add_last_key(-1);
#line 686
  tmp___34 = CleanupResult(result, dialog, prompt, & save_vars);
  }
#line 686
  return (tmp___34);
}
}
#line 657 "./dialog.h"
int dlg_buildlist(char const   *title , char const   *cprompt , int height , int width ,
                  int list_height , int item_no , DIALOG_LISTITEM *items , char const   *states ,
                  int order_mode , int *current_item ) ;
#line 850
extern void dlg_mouse_setcode(int  ) ;
#line 64 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/buildlist.c"
static void print_item___2(ALL_DATA___1 *data , WINDOW *win , DIALOG_LISTITEM *item ,
                           int choice , int selected ) 
{ 
  chtype save ;
  chtype tmp ;
  int i ;
  _Bool both ;
  int tmp___0 ;
  _Bool first___0 ;
  int climit ;
  char const   *show ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 71
  tmp = dlg_get_attrs(win);
#line 71
  save = tmp;
  }
#line 73
  if (! dialog_vars.no_tags) {
#line 73
    if (! dialog_vars.no_items) {
#line 73
      tmp___0 = 1;
    } else {
#line 73
      tmp___0 = 0;
    }
  } else {
#line 73
    tmp___0 = 0;
  }
#line 73
  both = (_Bool )tmp___0;
#line 74
  first___0 = (_Bool)1;
#line 75
  climit = (data->item_x - data->check_x) - 1;
#line 76
  if (dialog_vars.no_items) {
#line 76
    tmp___1 = item->name;
  } else {
#line 76
    tmp___1 = item->text;
  }
#line 76
  show = (char const   *)tmp___1;
#line 81
  if (win) {
#line 81
    win->_attrs = dlg_color_table[17].atr;
  }
  {
#line 82
  wmove(win, choice, 0);
#line 83
  i = 0;
  }
  {
#line 83
  while (1) {
    while_continue: /* CIL Label */ ;
#line 83
    if (win) {
#line 83
      tmp___2 = (int )win->_maxx + 1;
    } else {
#line 83
      tmp___2 = -1;
    }
#line 83
    if (! (i < tmp___2)) {
#line 83
      goto while_break;
    }
    {
#line 84
    waddch(win, (chtype const   )' ');
#line 83
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 86
  wmove(win, choice, data->check_x);
  }
#line 87
  if (win) {
#line 87
    win->_attrs = dlg_color_table[17].atr;
  }
#line 89
  if (both) {
    {
#line 90
    dlg_print_listitem(win, (char const   *)item->name, climit, first___0, selected);
#line 91
    waddch(win, (chtype const   )' ');
#line 92
    first___0 = (_Bool)0;
    }
  }
  {
#line 95
  wmove(win, choice, data->item_x);
  }
#line 96
  if (win) {
#line 96
    tmp___3 = (int )win->_maxx + 1;
  } else {
#line 96
    tmp___3 = -1;
  }
  {
#line 96
  climit = (tmp___3 - data->item_x) + 1;
#line 97
  dlg_print_listitem(win, show, climit, first___0, selected);
  }
#line 99
  if (selected) {
    {
#line 100
    dlg_item_help((char const   *)item->help);
    }
  }
#line 102
  if (win) {
#line 102
    win->_attrs = save;
  }
#line 103
  return;
}
}
#line 108 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/buildlist.c"
static void print_1_list(ALL_DATA___1 *data , int choice , int selected ) 
{ 
  MY_DATA *moi ;
  WINDOW *win ;
  int i ;
  int j ;
  int last ;
  int max_rows ;
  int tmp ;
  int ii ;
  int tmp___0 ;

  {
#line 113
  moi = data->list + selected;
#line 114
  win = moi->win;
#line 116
  last = 0;
#line 117
  if (win) {
#line 117
    tmp = (int )win->_maxy + 1;
  } else {
#line 117
    tmp = -1;
  }
#line 117
  max_rows = tmp;
#line 119
  j = 0;
#line 119
  i = j;
  {
#line 119
  while (1) {
    while_continue: /* CIL Label */ ;
#line 119
    if (! (j < max_rows)) {
#line 119
      goto while_break;
    }
#line 120
    ii = i + moi->top_index;
#line 121
    if (ii >= data->item_no) {
#line 122
      goto while_break;
    } else
#line 123
    if (! (selected ^ ((data->items + ii)->state != 0))) {
      {
#line 124
      print_item___2(data, win, data->items + ii, j, ii == choice);
#line 128
      j ++;
#line 128
      last = j;
      }
    }
#line 119
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 131
  tmp___0 = wmove(win, last, 0);
  }
#line 131
  if (tmp___0 != -1) {
    {
#line 132
    wclrtobot(win);
    }
  }
  {
#line 133
  wnoutrefresh(win);
  }
#line 134
  return;
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/buildlist.c"
static int prev_item(ALL_DATA___1 *data , int choice , int selected ) 
{ 
  int result ;
  int n ;

  {
#line 143
  result = choice;
#line 146
  n = choice - 1;
  {
#line 146
  while (1) {
    while_continue: /* CIL Label */ ;
#line 146
    if (! (n >= 0)) {
#line 146
      goto while_break;
    }
#line 147
    if (((data->items + n)->state != 0) == selected) {
#line 148
      result = n;
#line 149
      goto while_break;
    }
#line 146
    n --;
  }
  while_break: /* CIL Label */ ;
  }
#line 152
  return (result);
}
}
#line 158 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/buildlist.c"
static _Bool stop_prev(ALL_DATA___1 *data , int choice , int selected ) 
{ 
  int tmp ;

  {
  {
#line 161
  tmp = prev_item(data, choice, selected);
  }
#line 161
  return ((_Bool )(tmp == choice));
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/buildlist.c"
static _Bool check_hotkey___1(DIALOG_LISTITEM *items , int choice , int selected ) 
{ 
  _Bool result ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 167
  result = (_Bool)0;
#line 169
  if (((items + choice)->state != 0) == selected) {
#line 170
    if (dialog_vars.no_tags) {
#line 170
      tmp = (items + choice)->text;
    } else {
#line 170
      tmp = (items + choice)->name;
    }
    {
#line 170
    tmp___0 = dlg_last_getc();
#line 170
    tmp___1 = dlg_match_char(tmp___0, (char const   *)tmp);
    }
#line 170
    if (tmp___1) {
#line 174
      result = (_Bool)1;
    }
  }
#line 177
  return (result);
}
}
#line 184 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/buildlist.c"
static int next_item(ALL_DATA___1 *data , int choice , int selected ) 
{ 
  int result ;
  int n ;

  {
#line 187
  result = choice;
#line 190
  n = choice + 1;
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;
#line 190
    if (! (n < data->item_no)) {
#line 190
      goto while_break;
    }
#line 191
    if (((data->items + n)->state != 0) == selected) {
#line 192
      result = n;
#line 193
      goto while_break;
    }
#line 190
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 196
  dlg_trace_msg("next_item(%d) ->%d\n", choice, result);
  }
#line 197
  return (result);
}
}
#line 204 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/buildlist.c"
static int index2row(ALL_DATA___1 *data , int choice , int selected ) 
{ 
  int result ;
  int n ;

  {
#line 207
  result = -1;
#line 209
  n = 0;
  {
#line 209
  while (1) {
    while_continue: /* CIL Label */ ;
#line 209
    if (! (n < data->item_no)) {
#line 209
      goto while_break;
    }
#line 210
    if (((data->items + n)->state != 0) == selected) {
#line 211
      result ++;
    }
#line 213
    if (n == choice) {
#line 214
      goto while_break;
    }
#line 209
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 216
  return (result);
}
}
#line 222 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/buildlist.c"
static int first_item(ALL_DATA___1 *data , int selected ) 
{ 
  int result ;
  int n ;

  {
#line 225
  result = -1;
#line 228
  n = 0;
  {
#line 228
  while (1) {
    while_continue: /* CIL Label */ ;
#line 228
    if (! (n < data->item_no)) {
#line 228
      goto while_break;
    }
#line 229
    if (((data->items + n)->state != 0) == selected) {
#line 230
      result = n;
#line 231
      goto while_break;
    }
#line 228
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 234
  return (result);
}
}
#line 240 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/buildlist.c"
static int last_item(ALL_DATA___1 *data , int selected ) 
{ 
  int result ;
  int n ;

  {
#line 243
  result = -1;
#line 246
  n = data->item_no - 1;
  {
#line 246
  while (1) {
    while_continue: /* CIL Label */ ;
#line 246
    if (! (n >= 0)) {
#line 246
      goto while_break;
    }
#line 247
    if (((data->items + n)->state != 0) == selected) {
#line 248
      result = n;
#line 249
      goto while_break;
    }
#line 246
    n --;
  }
  while_break: /* CIL Label */ ;
  }
#line 252
  return (result);
}
}
#line 258 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/buildlist.c"
static int row2index(ALL_DATA___1 *data , int row , int selected ) 
{ 
  int result ;
  int n ;
  int tmp ;

  {
#line 261
  result = -1;
#line 263
  n = 0;
  {
#line 263
  while (1) {
    while_continue: /* CIL Label */ ;
#line 263
    if (! (n < data->item_no)) {
#line 263
      goto while_break;
    }
#line 264
    if (((data->items + n)->state != 0) == selected) {
#line 265
      tmp = row;
#line 265
      row --;
#line 265
      if (tmp <= 0) {
#line 266
        result = n;
#line 267
        goto while_break;
      }
    }
#line 263
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 271
  return (result);
}
}
#line 274 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/buildlist.c"
static int skip_rows(ALL_DATA___1 *data , int row , int skip , int selected ) 
{ 
  int choice ;
  int tmp ;
  int result ;
  int n ;

  {
  {
#line 277
  tmp = row2index(data, row, selected);
#line 277
  choice = tmp;
#line 278
  result = row;
  }
#line 280
  if (skip > 0) {
#line 281
    n = choice + 1;
    {
#line 281
    while (1) {
      while_continue: /* CIL Label */ ;
#line 281
      if (! (n < data->item_no)) {
#line 281
        goto while_break;
      }
#line 282
      if (((data->items + n)->state != 0) == selected) {
#line 283
        result ++;
#line 284
        skip --;
#line 284
        if (skip <= 0) {
#line 285
          goto while_break;
        }
      }
#line 281
      n ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 288
  if (skip < 0) {
#line 289
    n = choice - 1;
    {
#line 289
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 289
      if (! (n >= 0)) {
#line 289
        goto while_break___0;
      }
#line 290
      if (((data->items + n)->state != 0) == selected) {
#line 291
        result --;
#line 292
        skip ++;
#line 292
        if (skip >= 0) {
#line 293
          goto while_break___0;
        }
      }
#line 289
      n --;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 297
  return (result);
}
}
#line 303 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/buildlist.c"
static int closest_item(ALL_DATA___1 *data , int choice , int selected ) 
{ 
  int prev ;
  int next ;
  int result ;
  int n ;

  {
#line 306
  prev = choice;
#line 307
  next = choice;
#line 308
  result = choice;
#line 311
  n = choice;
  {
#line 311
  while (1) {
    while_continue: /* CIL Label */ ;
#line 311
    if (! (n >= 0)) {
#line 311
      goto while_break;
    }
#line 312
    if (((data->items + n)->state != 0) == selected) {
#line 313
      prev = n;
#line 314
      goto while_break;
    }
#line 311
    n --;
  }
  while_break: /* CIL Label */ ;
  }
#line 317
  n = choice;
  {
#line 317
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 317
    if (! (n < data->item_no)) {
#line 317
      goto while_break___0;
    }
#line 318
    if (((data->items + n)->state != 0) == selected) {
#line 319
      next = n;
#line 320
      goto while_break___0;
    }
#line 317
    n ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 323
  if (prev != choice) {
#line 324
    result = prev;
#line 325
    if (next != choice) {
#line 326
      if (choice - prev > next - choice) {
#line 327
        result = next;
      }
    }
  } else
#line 330
  if (next != choice) {
#line 331
    result = next;
  }
#line 333
  return (result);
}
}
#line 336 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/buildlist.c"
static void print_both(ALL_DATA___1 *data , int choice ) 
{ 
  int selected ;
  int cur_y ;
  int cur_x ;
  WINDOW *dialog ;
  WINDOW *tmp ;
  MY_DATA *moi ;
  WINDOW *win ;
  int thumb_top ;
  int tmp___0 ;
  int thumb_max ;
  int tmp___1 ;
  int thumb_end ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 342
  tmp = dlg_wgetparent(data->list[0].win);
#line 342
  dialog = tmp;
  }
#line 344
  if (dialog) {
#line 344
    cur_y = (int )dialog->_cury;
  } else {
#line 344
    cur_y = -1;
  }
#line 344
  if (dialog) {
#line 344
    cur_x = (int )dialog->_curx;
  } else {
#line 344
    cur_x = -1;
  }
#line 345
  selected = 0;
  {
#line 345
  while (1) {
    while_continue: /* CIL Label */ ;
#line 345
    if (! (selected < 2)) {
#line 345
      goto while_break;
    }
    {
#line 346
    moi = data->list + selected;
#line 347
    win = moi->win;
#line 348
    tmp___0 = index2row(data, moi->top_index, selected);
#line 348
    thumb_top = tmp___0;
#line 349
    tmp___1 = index2row(data, -1, selected);
#line 349
    thumb_max = tmp___1;
    }
#line 350
    if (win) {
#line 350
      tmp___2 = (int )win->_maxy + 1;
    } else {
#line 350
      tmp___2 = -1;
    }
    {
#line 350
    thumb_end = thumb_top + tmp___2;
#line 352
    print_1_list(data, choice, selected);
#line 354
    dlg_mouse_setcode(selected * 511);
    }
#line 355
    if (win) {
#line 355
      tmp___3 = (int )win->_maxy + 1;
    } else {
#line 355
      tmp___3 = -1;
    }
#line 355
    if (win) {
#line 355
      tmp___4 = (int )win->_maxx + 1;
    } else {
#line 355
      tmp___4 = -1;
    }
#line 355
    if (thumb_end < thumb_max) {
#line 355
      tmp___5 = thumb_end;
    } else {
#line 355
      tmp___5 = thumb_max;
    }
    {
#line 355
    dlg_draw_scrollbar(dialog, (long )moi->top_index, (long )thumb_top, (long )tmp___5,
                       (long )thumb_max, moi->box_x + data->check_x, moi->box_x + tmp___4,
                       moi->box_y, (moi->box_y + tmp___3) + 1, dlg_color_table[37].atr,
                       dlg_color_table[18].atr);
#line 345
    selected ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 367
  wmove(dialog, cur_y, cur_x);
#line 368
  dlg_mouse_setcode(0);
  }
#line 369
  return;
}
}
#line 371 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/buildlist.c"
static void set_top_item(ALL_DATA___1 *data , int value , int selected ) 
{ 
  char const   *tmp ;

  {
#line 374
  if (value != data->list[selected].top_index) {
#line 375
    if (selected) {
#line 375
      tmp = "right";
    } else {
#line 375
      tmp = "left";
    }
    {
#line 375
    dlg_trace_msg("set top of %s column to %d\n", tmp, value);
#line 378
    data->list[selected].top_index = value;
    }
  }
#line 380
  return;
}
}
#line 386 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/buildlist.c"
static void fix_top_item(ALL_DATA___1 *data , int cur_item , int selected ) 
{ 
  int top_item ;
  int cur_row ;
  int tmp ;
  int top_row ;
  int tmp___0 ;

  {
  {
#line 389
  top_item = data->list[selected].top_index;
#line 390
  tmp = index2row(data, cur_item, selected);
#line 390
  cur_row = tmp;
#line 391
  tmp___0 = index2row(data, top_item, selected);
#line 391
  top_row = tmp___0;
  }
#line 393
  if (cur_row < top_row) {
#line 394
    top_item = cur_item;
  } else
#line 395
  if (cur_row - top_row > data->use_height) {
    {
#line 396
    top_item = row2index(data, (cur_row + 1) - data->use_height, selected);
    }
  }
#line 398
  if (cur_row < data->use_height) {
    {
#line 399
    top_item = row2index(data, 0, selected);
    }
  }
  {
#line 401
  dlg_trace_msg("fix_top_item(cur_item %d, selected %d) ->top_item %d\n", cur_item,
                selected, top_item);
#line 403
  set_top_item(data, top_item, selected);
  }
#line 404
  return;
}
}
#line 424 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/buildlist.c"
static DLG_KEYS_BINDING binding___6[28]  = 
#line 424
  {      {0, 5, 545}, 
        {1, 265, 545}, 
        {1, 363, 545}, 
        {0, '\n', 541}, 
        {0, '\r', 541}, 
        {1, 343, 541}, 
        {1, 261, 528}, 
        {0, 9, 528}, 
        {1, 353, 529}, 
        {1, 260, 529}, 
        {1, 262, 522}, 
        {1, 360, 523}, 
        {1, 347, 523}, 
        {0, '+', 524}, 
        {1, 258, 524}, 
        {0, 14, 524}, 
        {0, '-', 525}, 
        {1, 259, 525}, 
        {0, 16, 525}, 
        {1, 338, 520}, 
        {1, 1106, 520}, 
        {1, 1617, 520}, 
        {1, 339, 521}, 
        {1, 1107, 521}, 
        {1, 1618, 521}, 
        {0, '^', 536}, 
        {0, '$', 537}, 
        {-1, 0, 0}};
#line 411 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/buildlist.c"
int dlg_buildlist(char const   *title , char const   *cprompt , int height , int width ,
                  int list_height , int item_no , DIALOG_LISTITEM *items , char const   *states ,
                  int order_mode , int *current_item ) 
{ 
  int old_height ;
  int old_width ;
  ALL_DATA___1 all ;
  MY_DATA *data ;
  int i ;
  int j ;
  int k ;
  int key2 ;
  int found ;
  int x ;
  int y ;
  int cur_x ;
  int cur_y ;
  int key ;
  int fkey ;
  _Bool save_visit ;
  int button ;
  int cur_item ;
  int was_mouse ;
  int name_width ;
  int text_width ;
  int full_width ;
  int list_width ;
  int result ;
  int num_states ;
  _Bool first___0 ;
  WINDOW *dialog ;
  char *prompt ;
  char *tmp ;
  char const   **buttons ;
  char const   **tmp___0 ;
  char const   *widget_name ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___10 ;
  int tmp___11 ;
  int need ;
  int want ;
  int tmp___12 ;
  int tmp___13 ;
  int top_item ;
  int which ;
  MY_DATA *moi ;
  int at_top ;
  int tmp___14 ;
  int at_end ;
  int tmp___15 ;
  int at_bot ;
  int tmp___16 ;
  int cur_row ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int new_choice ;
  int new_state ;
  _Bool tmp___20 ;
  _Bool tmp___21 ;
  int temp ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  _Bool tmp___26 ;
  int now_at ;
  int tmp___27 ;
  int oops ;
  int old_item ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;

  {
  {
#line 453
  old_height = height;
#line 454
  old_width = width;
#line 457
  data = all.list;
#line 459
  key = 0;
#line 460
  save_visit = dialog_state.visit_items;
#line 465
  result = -2;
#line 467
  first___0 = (_Bool)1;
#line 469
  tmp = dlg_strclone(cprompt);
#line 469
  prompt = tmp;
#line 470
  tmp___0 = dlg_ok_labels();
#line 470
  buttons = tmp___0;
#line 471
  widget_name = "buildlist";
  }
#line 478
  if (dialog_state.visit_cols) {
#line 479
    dialog_state.visit_cols = 2;
  }
  {
#line 481
  memset((void *)(& all), 0, sizeof(all));
#line 482
  all.items = items;
#line 483
  all.item_no = item_no;
  }
#line 485
  if ((unsigned long )dialog_vars.default_item != (unsigned long )((char *)0)) {
    {
#line 486
    cur_item = dlg_default_listitem(items);
    }
  } else {
    {
#line 488
    cur_item = first_item(& all, 0);
    }
#line 488
    if (cur_item < 0) {
      {
#line 489
      cur_item = first_item(& all, 1);
      }
    }
  }
#line 491
  if (dialog_state.visit_items) {
#line 491
    if ((items + cur_item)->state) {
#line 491
      tmp___1 = -1;
    } else {
#line 491
      tmp___1 = -2;
    }
#line 491
    button = tmp___1;
  } else {
    {
#line 491
    tmp___2 = dlg_default_button();
#line 491
    button = tmp___2;
    }
  }
  {
#line 495
  dlg_does_output();
#line 496
  dlg_tab_correct_str(prompt);
  }
  retry: 
  {
#line 502
  all.use_height = list_height;
#line 503
  tmp___3 = dlg_calc_list_width(item_no, items);
#line 503
  all.use_width = 2 * ((tmp___3 + 4) + 2) + 1;
  }
#line 507
  if (26 > all.use_width) {
#line 507
    all.use_width = 26;
  } else {
#line 507
    all.use_width = all.use_width;
  }
#line 508
  if (all.use_height == 0) {
    {
#line 510
    dlg_auto_size(title, (char const   *)prompt, & height, & width, 6, all.use_width);
#line 511
    dlg_calc_listh(& height, & all.use_height, item_no);
    }
  } else {
    {
#line 513
    dlg_auto_size(title, (char const   *)prompt, & height, & width, 6 + all.use_height,
                  all.use_width);
    }
  }
  {
#line 517
  dlg_button_layout(buttons, & width);
#line 518
  dlg_print_size(height, width);
#line 519
  dlg_ctl_size(height, width);
  }
#line 522
  if ((unsigned long )states == (unsigned long )((char const   *)0)) {
#line 523
    states = " *";
  } else {
    {
#line 522
    tmp___4 = strlen(states);
    }
#line 522
    if (tmp___4 < 2UL) {
#line 523
      states = " *";
    }
  }
  {
#line 524
  tmp___5 = strlen(states);
#line 524
  num_states = (int )tmp___5;
#line 526
  x = dlg_box_x_ordinate(width);
#line 527
  y = dlg_box_y_ordinate(height);
#line 529
  dialog = dlg_new_window(height, width, y, x);
#line 530
  dlg_register_window(dialog, widget_name, binding___6);
#line 531
  dlg_register_buttons(dialog, widget_name, buttons);
#line 533
  all.base_y = y;
#line 533
  all.base_x = x;
#line 533
  dlg_mouse_setbase(all.base_x, all.base_y);
#line 535
  dlg_draw_box2(dialog, 0, 0, height, width, dlg_color_table[2].atr, dlg_color_table[4].atr,
                dlg_color_table[34].atr);
#line 536
  dlg_draw_bottom_box2(dialog, dlg_color_table[4].atr, dlg_color_table[34].atr, dlg_color_table[2].atr);
#line 537
  dlg_draw_title(dialog, title);
  }
#line 539
  if (dialog) {
#line 539
    dialog->_attrs = dlg_color_table[2].atr;
  }
  {
#line 540
  dlg_print_autowrap(dialog, (char const   *)prompt, height, width);
#line 542
  list_width = ((width - 6) - 2) / 2;
  }
#line 543
  if (dialog) {
#line 543
    cur_y = (int )dialog->_cury;
  } else {
#line 543
    cur_y = -1;
  }
#line 543
  if (dialog) {
#line 543
    cur_x = (int )dialog->_curx;
  } else {
#line 543
    cur_x = -1;
  }
#line 544
  (data + 0)->box_y = cur_y + 1;
#line 545
  (data + 0)->box_x = 2;
#line 546
  (data + 1)->box_y = cur_y + 1;
#line 547
  (data + 1)->box_x = (((data + 0)->box_x + 1) + 2) + list_width;
#line 553
  if (all.use_height + 6 > height - cur_y) {
#line 554
    all.use_height = (height - 6) - cur_y;
  }
#line 555
  if (all.use_height <= 0) {
#line 556
    all.use_height = 1;
  }
#line 558
  k = 0;
  {
#line 558
  while (1) {
    while_continue: /* CIL Label */ ;
#line 558
    if (! (k < 2)) {
#line 558
      goto while_break;
    }
    {
#line 560
    (data + k)->win = dlg_sub_window(dialog, all.use_height, list_width, (y + (data + k)->box_y) + 1,
                                     (x + (data + k)->box_x) + 1);
#line 565
    dlg_draw_box(dialog, (data + k)->box_y, (data + k)->box_x, all.use_height + 2,
                 list_width + 2, dlg_color_table[18].atr, dlg_color_table[37].atr);
#line 558
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 571
  text_width = 0;
#line 572
  name_width = 0;
#line 574
  i = 0;
  {
#line 574
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 574
    if (! (i < item_no)) {
#line 574
      goto while_break___0;
    }
    {
#line 575
    tmp___8 = dlg_count_columns((char const   *)(items + i)->text);
    }
#line 575
    if (text_width > tmp___8) {
#line 575
      text_width = text_width;
    } else {
      {
#line 575
      tmp___7 = dlg_count_columns((char const   *)(items + i)->text);
#line 575
      text_width = tmp___7;
      }
    }
    {
#line 576
    tmp___11 = dlg_count_columns((char const   *)(items + i)->name);
    }
#line 576
    if (name_width > tmp___11) {
#line 576
      name_width = name_width;
    } else {
      {
#line 576
      tmp___10 = dlg_count_columns((char const   *)(items + i)->name);
#line 576
      name_width = tmp___10;
      }
    }
#line 574
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 583
  all.use_width = list_width - 6;
#line 584
  if (dialog_vars.no_tags) {
#line 584
    if (! dialog_vars.no_items) {
#line 585
      if (all.use_width < text_width) {
#line 585
        full_width = all.use_width;
      } else {
#line 585
        full_width = text_width;
      }
    } else {
#line 584
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 586
  if (dialog_vars.no_items) {
#line 587
    if (all.use_width < name_width) {
#line 587
      full_width = all.use_width;
    } else {
#line 587
      full_width = name_width;
    }
  } else {
#line 589
    if (text_width >= 0) {
#line 589
      if (name_width >= 0) {
#line 589
        if (all.use_width > 0) {
#line 589
          if (text_width + name_width > all.use_width) {
#line 593
            need = (int )(0.25 * (double )all.use_width);
#line 594
            if (name_width > need) {
#line 595
              want = (int )(((double )all.use_width * (double )name_width) / (double )(text_width + name_width));
#line 597
              if (want > need) {
#line 597
                name_width = want;
              } else {
#line 597
                name_width = need;
              }
            }
#line 599
            text_width = all.use_width - name_width;
          }
        }
      }
    }
#line 601
    full_width = text_width + name_width;
  }
#line 604
  all.check_x = (all.use_width - full_width) / 2;
#line 605
  if (dialog_vars.no_tags) {
#line 605
    tmp___13 = 0;
  } else {
#line 605
    if (dialog_vars.no_items) {
#line 605
      tmp___12 = 0;
    } else {
#line 605
      tmp___12 = name_width + 2;
    }
#line 605
    tmp___13 = tmp___12;
  }
#line 605
  all.item_x = tmp___13 + all.check_x;
#line 613
  if (all.use_height < item_no) {
#line 613
    j = all.use_height;
  } else {
#line 613
    j = item_no;
  }
#line 614
  i = 0;
  {
#line 614
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 614
    if (! (i < 2)) {
#line 614
      goto while_break___1;
    }
#line 615
    top_item = 0;
#line 616
    if (((items + cur_item)->state != 0) == i) {
#line 617
      top_item = (cur_item - j) + 1;
#line 618
      if (top_item < 0) {
#line 619
        top_item = 0;
      }
      {
#line 620
      set_top_item(& all, top_item, i);
      }
    } else {
      {
#line 622
      set_top_item(& all, 0, i);
      }
    }
#line 614
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 627
  i = 0;
  {
#line 627
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 627
    if (! (i < 2)) {
#line 627
      goto while_break___2;
    }
    {
#line 628
    dlg_mouse_mkbigregion((data + i)->box_y + 1, (data + i)->box_x, all.use_height,
                          list_width + 2, 1022 + i * (1 + all.use_height), 1, 1, 1);
#line 627
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 636
  dlg_draw_buttons(dialog, height - 2, 0, buttons, button, 0, width);
  }
  {
#line 638
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 638
    if (! (result == -2)) {
#line 638
      goto while_break___3;
    }
    {
#line 639
    which = (items + cur_item)->state != 0;
#line 640
    moi = data + which;
#line 641
    tmp___14 = index2row(& all, moi->top_index, which);
#line 641
    at_top = tmp___14;
#line 642
    tmp___15 = index2row(& all, -1, which);
#line 642
    at_end = tmp___15;
#line 643
    tmp___16 = skip_rows(& all, at_top, all.use_height, which);
#line 643
    at_bot = tmp___16;
#line 645
    dlg_trace_msg("\t** state %d:%d top %d (%d:%d:%d) %d\n", cur_item, item_no - 1,
                  moi->top_index, at_top, at_bot, at_end, which);
    }
#line 651
    if (first___0) {
      {
#line 652
      print_both(& all, cur_item);
#line 653
      dlg_trace_win(dialog);
#line 654
      first___0 = (_Bool)0;
      }
    }
#line 657
    if (button < 0) {
      {
#line 658
      tmp___17 = index2row(& all, cur_item, which);
#line 658
      cur_row = tmp___17;
#line 659
      cur_y = ((data + which)->box_y + cur_row) + 1;
      }
#line 662
      if (at_top > 0) {
#line 663
        cur_y -= at_top;
      }
      {
#line 664
      cur_x = ((data + which)->box_x + all.check_x) + 1;
#line 666
      dlg_trace_msg("\t...visit row %d (%d,%d)\n", cur_row, cur_y, cur_x);
#line 667
      wmove(dialog, cur_y, cur_x);
      }
    }
    {
#line 670
    key = dlg_mouse_wgetch(dialog, & fkey);
#line 671
    tmp___18 = dlg_result_key(key, fkey, & result);
    }
#line 671
    if (tmp___18) {
#line 672
      goto while_break___3;
    }
#line 674
    if (fkey) {
#line 674
      if (key >= 768) {
#line 674
        tmp___19 = 1;
      } else {
#line 674
        tmp___19 = 0;
      }
    } else {
#line 674
      tmp___19 = 0;
    }
#line 674
    was_mouse = tmp___19;
#line 675
    if (was_mouse) {
#line 676
      key -= 768;
    }
#line 678
    if (! (! was_mouse)) {
#line 680
      if (key >= 1022) {
        {
#line 681
        i = (key - 1022) % (1 + all.use_height);
#line 682
        j = (key - 1022) / (1 + all.use_height);
#line 683
        k = row2index(& all, i + at_top, j);
#line 684
        dlg_trace_msg("MOUSE column %d, row %d ->item %d\n", j, i, k);
        }
#line 685
        if (k >= 0) {
#line 685
          if (j < 2) {
#line 686
            if (j != which) {
              {
#line 690
              moi = data + j;
#line 691
              fix_top_item(& all, k, j);
              }
            }
            {
#line 693
            which = j;
#line 694
            at_top = index2row(& all, moi->top_index, which);
#line 695
            at_bot = skip_rows(& all, at_top, all.use_height, which);
#line 696
            cur_item = k;
#line 697
            print_both(& all, cur_item);
#line 698
            key = ' ';
            }
          } else {
            {
#line 700
            beep();
            }
#line 701
            goto while_continue___3;
          }
        } else {
          {
#line 700
          beep();
          }
#line 701
          goto while_continue___3;
        }
#line 703
        fkey = 0;
      } else
#line 704
      if (key >= 257) {
#line 705
        if (key > 511) {
#line 706
          if (which == 0) {
#line 707
            key = '$';
#line 708
            fkey = 0;
          } else {
#line 710
            key -= 511;
          }
        } else
#line 713
        if (which == 1) {
#line 714
          key = '^';
#line 715
          fkey = 0;
        }
        {
#line 718
        key = dlg_lookup_key(dialog, key, & fkey);
        }
      }
    }
#line 726
    if (key == 32) {
      {
#line 728
      new_state = (items + cur_item)->state + 1;
#line 730
      new_choice = next_item(& all, cur_item, which);
      }
#line 730
      if (new_choice == cur_item) {
        {
#line 731
        new_choice = prev_item(& all, cur_item, which);
        }
      }
      {
#line 733
      dlg_trace_msg("cur_item %d, new_choice:%d\n", cur_item, new_choice);
      }
#line 734
      if (new_state >= num_states) {
#line 735
        new_state = 0;
      }
#line 737
      (items + cur_item)->state = new_state;
#line 738
      if (cur_item == moi->top_index) {
        {
#line 739
        set_top_item(& all, new_choice, which);
        }
      }
#line 742
      if (new_choice >= 0) {
        {
#line 743
        fix_top_item(& all, cur_item, ! which);
#line 744
        cur_item = new_choice;
        }
      }
      {
#line 746
      print_both(& all, cur_item);
#line 747
      dlg_trace_win(dialog);
      }
#line 748
      goto while_continue___3;
    }
#line 756
    found = 0;
#line 757
    if (! fkey) {
#line 758
      if (button < 0) {
#line 758
        goto _L___0;
      } else
#line 758
      if (! dialog_state.visit_items) {
        _L___0: /* CIL Label */ 
#line 759
        j = cur_item + 1;
        {
#line 759
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 759
          if (! (j < item_no)) {
#line 759
            goto while_break___4;
          }
          {
#line 760
          tmp___20 = check_hotkey___1(items, j, which);
          }
#line 760
          if (tmp___20) {
#line 761
            found = 1;
#line 762
            i = j;
#line 763
            goto while_break___4;
          }
#line 759
          j ++;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 766
        if (! found) {
#line 767
          j = 0;
          {
#line 767
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 767
            if (! (j <= cur_item)) {
#line 767
              goto while_break___5;
            }
            {
#line 768
            tmp___21 = check_hotkey___1(items, j, which);
            }
#line 768
            if (tmp___21) {
#line 769
              found = 1;
#line 770
              i = j;
#line 771
              goto while_break___5;
            }
#line 767
            j ++;
          }
          while_break___5: /* CIL Label */ ;
          }
        }
#line 775
        if (found) {
          {
#line 776
          dlg_flush_getc();
          }
        }
      } else {
        {
#line 777
        j = dlg_char_to_button(key, buttons);
        }
#line 777
        if (j >= 0) {
          {
#line 778
          button = j;
#line 779
          ungetch('\n');
          }
#line 780
          goto while_continue___3;
        }
      }
    }
#line 788
    if (! found) {
#line 788
      if (key <= 57) {
#line 788
        if (key > 48) {
#line 788
          if (key - 49 < at_bot) {
#line 792
            found = 1;
#line 793
            i = key - 49;
          }
        }
      }
    }
#line 796
    if (! found) {
#line 796
      if (fkey) {
        {
#line 798
        if (key == 529) {
#line 798
          goto case_529;
        }
#line 813
        if (key == 528) {
#line 813
          goto case_528;
        }
#line 797
        goto switch_break;
        case_529: /* CIL Label */ 
#line 799
        if (button == -1) {
#line 799
          if (dialog_state.visit_items) {
#line 800
            key = 536;
#line 801
            button = -2;
          } else {
#line 799
            goto _L___1;
          }
        } else {
          _L___1: /* CIL Label */ 
          {
#line 803
          button = dlg_prev_button(buttons, button);
#line 804
          dlg_draw_buttons(dialog, height - 2, 0, buttons, button, 0, width);
          }
#line 806
          if (button == -1) {
#line 807
            key = 537;
          } else {
#line 809
            goto while_continue___3;
          }
        }
#line 812
        goto switch_break;
        case_528: /* CIL Label */ 
#line 814
        if (button == -2) {
#line 814
          if (dialog_state.visit_items) {
#line 815
            key = 537;
#line 816
            button = -1;
          } else {
#line 814
            goto _L___2;
          }
        } else {
          _L___2: /* CIL Label */ 
          {
#line 818
          button = dlg_next_button(buttons, button);
#line 819
          dlg_draw_buttons(dialog, height - 2, 0, buttons, button, 0, width);
          }
#line 821
          if (button == -2) {
#line 822
            key = 536;
          } else {
#line 824
            goto while_continue___3;
          }
        }
#line 827
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
    }
#line 831
    if (! found) {
#line 831
      if (fkey) {
#line 832
        i = cur_item;
#line 833
        found = 1;
        {
#line 835
        if (key == 536) {
#line 835
          goto case_536;
        }
#line 839
        if (key == 537) {
#line 839
          goto case_537;
        }
#line 843
        if (key == 521) {
#line 843
          goto case_521;
        }
#line 853
        if (key == 520) {
#line 853
          goto case_520;
        }
#line 872
        if (key == 522) {
#line 872
          goto case_522;
        }
#line 875
        if (key == 523) {
#line 875
          goto case_523;
        }
#line 878
        if (key == 525) {
#line 878
          goto case_525;
        }
#line 883
        if (key == 524) {
#line 883
          goto case_524;
        }
#line 886
        goto switch_default;
        case_536: /* CIL Label */ 
        {
#line 836
        i = closest_item(& all, cur_item, 0);
#line 837
        fix_top_item(& all, i, 0);
        }
#line 838
        goto switch_break___0;
        case_537: /* CIL Label */ 
        {
#line 840
        i = closest_item(& all, cur_item, 1);
#line 841
        fix_top_item(& all, i, 1);
        }
#line 842
        goto switch_break___0;
        case_521: /* CIL Label */ 
#line 844
        if (cur_item > moi->top_index) {
#line 845
          i = moi->top_index;
        } else
#line 846
        if (moi->top_index != 0) {
#line 847
          temp = at_top;
#line 848
          temp -= all.use_height;
#line 848
          if (temp < 0) {
#line 849
            temp = 0;
          }
          {
#line 850
          i = row2index(& all, temp, which);
          }
        }
#line 852
        goto switch_break___0;
        case_520: /* CIL Label */ 
#line 854
        if (at_end - at_bot < all.use_height) {
          {
#line 855
          tmp___22 = row2index(& all, at_end, which);
#line 855
          i = next_item(& all, tmp___22, which);
          }
        } else {
          {
#line 859
          tmp___23 = row2index(& all, at_bot, which);
#line 859
          i = next_item(& all, tmp___23, which);
#line 862
          at_top = at_bot;
#line 863
          tmp___24 = row2index(& all, at_top, which);
#line 863
          tmp___25 = next_item(& all, tmp___24, which);
#line 863
          set_top_item(& all, tmp___25, which);
#line 868
          at_bot = skip_rows(& all, at_top, all.use_height, which);
          }
#line 869
          if (at_bot < at_end) {
#line 869
            at_bot = at_bot;
          } else {
#line 869
            at_bot = at_end;
          }
        }
#line 871
        goto switch_break___0;
        case_522: /* CIL Label */ 
        {
#line 873
        i = first_item(& all, which);
        }
#line 874
        goto switch_break___0;
        case_523: /* CIL Label */ 
        {
#line 876
        i = last_item(& all, which);
        }
#line 877
        goto switch_break___0;
        case_525: /* CIL Label */ 
        {
#line 879
        i = prev_item(& all, cur_item, which);
#line 880
        tmp___26 = stop_prev(& all, cur_item, which);
        }
#line 880
        if (tmp___26) {
#line 881
          goto while_continue___3;
        }
#line 882
        goto switch_break___0;
        case_524: /* CIL Label */ 
        {
#line 884
        i = next_item(& all, cur_item, which);
        }
#line 885
        goto switch_break___0;
        switch_default: /* CIL Label */ 
#line 887
        found = 0;
#line 888
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
      }
    }
#line 892
    if (found) {
#line 893
      if (i != cur_item) {
        {
#line 894
        tmp___27 = index2row(& all, i, which);
#line 894
        now_at = tmp___27;
#line 895
        oops = item_no;
#line 898
        dlg_trace_msg("<--CHOICE %d\n", i);
#line 899
        dlg_trace_msg("<--topITM %d\n", moi->top_index);
#line 900
        dlg_trace_msg("<--now_at %d\n", now_at);
#line 901
        dlg_trace_msg("<--at_top %d\n", at_top);
#line 902
        dlg_trace_msg("<--at_bot %d\n", at_bot);
        }
#line 904
        if (now_at >= at_bot) {
          {
#line 905
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 905
            if (! (now_at >= at_bot)) {
#line 905
              goto while_break___6;
            }
#line 906
            if (at_bot - at_top >= all.use_height) {
              {
#line 907
              tmp___28 = next_item(& all, moi->top_index, which);
#line 907
              set_top_item(& all, tmp___28, which);
              }
            }
            {
#line 911
            at_top = index2row(& all, moi->top_index, which);
#line 912
            at_bot = skip_rows(& all, at_top, all.use_height, which);
#line 914
            dlg_trace_msg("...at_bot %d (now %d vs %d)\n", at_bot, now_at, at_end);
#line 916
            dlg_trace_msg("...topITM %d\n", moi->top_index);
#line 917
            dlg_trace_msg("...at_top %d (diff %d)\n", at_top, at_bot - at_top);
            }
#line 920
            if (at_bot >= at_end) {
#line 926
              if (at_bot - at_top > all.use_height) {
                {
#line 927
                tmp___29 = next_item(& all, moi->top_index, which);
#line 927
                set_top_item(& all, tmp___29, which);
                }
              } else
#line 930
              if (at_top > 0) {
#line 930
                if (at_bot - at_top >= all.use_height) {
                  {
#line 932
                  tmp___30 = next_item(& all, moi->top_index, which);
#line 932
                  set_top_item(& all, tmp___30, which);
                  }
                }
              }
#line 936
              goto while_break___6;
            }
#line 938
            oops --;
#line 938
            if (oops < 0) {
              {
#line 939
              dlg_trace_msg("OOPS-forward\n");
              }
#line 940
              goto while_break___6;
            }
          }
          while_break___6: /* CIL Label */ ;
          }
        } else
#line 943
        if (now_at < at_top) {
          {
#line 944
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 944
            if (! (now_at < at_top)) {
#line 944
              goto while_break___7;
            }
            {
#line 945
            old_item = moi->top_index;
#line 946
            tmp___31 = prev_item(& all, moi->top_index, which);
#line 946
            set_top_item(& all, tmp___31, which);
#line 949
            at_top = index2row(& all, moi->top_index, which);
#line 951
            dlg_trace_msg("...at_top %d (now %d)\n", at_top, now_at);
#line 952
            dlg_trace_msg("...topITM %d\n", moi->top_index);
            }
#line 954
            if (moi->top_index >= old_item) {
#line 955
              goto while_break___7;
            }
#line 956
            if (at_top <= now_at) {
#line 957
              goto while_break___7;
            }
#line 958
            oops --;
#line 958
            if (oops < 0) {
              {
#line 959
              dlg_trace_msg("OOPS-backward\n");
              }
#line 960
              goto while_break___7;
            }
          }
          while_break___7: /* CIL Label */ ;
          }
        }
        {
#line 964
        dlg_trace_msg("-->now_at %d\n", now_at);
#line 965
        cur_item = i;
#line 966
        print_both(& all, cur_item);
        }
      }
      {
#line 968
      dlg_trace_win(dialog);
      }
#line 969
      goto while_continue___3;
    }
#line 972
    if (fkey) {
      {
#line 974
      if (key == 541) {
#line 974
        goto case_541;
      }
#line 978
      if (key == 410) {
#line 978
        goto case_410;
      }
#line 989
      goto switch_default___0;
      case_541: /* CIL Label */ 
#line 975
      if (dialog_vars.nook) {
#line 975
        result = 0;
      } else {
        {
#line 975
        tmp___32 = dlg_ok_buttoncode(button);
#line 975
        result = tmp___32;
        }
      }
#line 976
      goto switch_break___1;
      case_410: /* CIL Label */ 
      {
#line 980
      height = old_height;
#line 981
      width = old_width;
#line 983
      dlg_clear();
#line 984
      dlg_del_window(dialog);
#line 985
      wrefresh(stdscr);
#line 986
      dlg_mouse_free_regions();
      }
#line 987
      goto retry;
      switch_default___0: /* CIL Label */ 
#line 990
      if (was_mouse) {
        {
#line 991
        key2 = dlg_ok_buttoncode(key);
        }
#line 991
        if (key2 >= 0) {
#line 992
          result = key2;
#line 993
          goto switch_break___1;
        }
        {
#line 995
        beep();
        }
      }
      switch_break___1: /* CIL Label */ ;
      }
    } else {
      {
#line 999
      beep();
      }
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 1003
  dialog_state.visit_cols = (int )save_visit;
#line 1004
  dlg_del_window(dialog);
#line 1005
  dlg_mouse_free_regions();
#line 1006
  free((void *)prompt);
#line 1007
  *current_item = cur_item;
  }
#line 1008
  return (result);
}
}
#line 1014 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/buildlist.c"
int dialog_buildlist(char const   *title , char const   *cprompt , int height , int width ,
                     int list_height , int item_no , char **items , int order_mode ) 
{ 
  int result ;
  int i ;
  int j ;
  DIALOG_LISTITEM *listitems ;
  _Bool separate_output ;
  _Bool show_status ;
  int current ;
  char *help_result ;
  void *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  _Bool tmp___8 ;

  {
  {
#line 1027
  separate_output = dialog_vars.separate_output;
#line 1028
  show_status = (_Bool)0;
#line 1029
  current = 0;
#line 1032
  tmp = calloc((size_t )item_no + 1UL, sizeof(DIALOG_LISTITEM ));
#line 1032
  listitems = (DIALOG_LISTITEM *)tmp;
  }
#line 1033
  if ((unsigned long )listitems == (unsigned long )((DIALOG_LISTITEM *)0)) {
    {
#line 1033
    dlg_exiterr("cannot allocate memory in dialog_buildlist");
    }
  }
#line 1035
  j = 0;
#line 1035
  i = j;
  {
#line 1035
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1035
    if (! (i < item_no)) {
#line 1035
      goto while_break;
    }
#line 1036
    tmp___0 = j;
#line 1036
    j ++;
#line 1036
    (listitems + i)->name = *(items + tmp___0);
#line 1037
    if (dialog_vars.no_items) {
      {
#line 1037
      tmp___1 = dlg_strempty();
#line 1037
      (listitems + i)->text = tmp___1;
      }
    } else {
#line 1037
      tmp___2 = j;
#line 1037
      j ++;
#line 1037
      (listitems + i)->text = *(items + tmp___2);
    }
    {
#line 1040
    tmp___3 = j;
#line 1040
    j ++;
#line 1040
    tmp___4 = strcasecmp((char const   *)*(items + tmp___3), "on");
    }
#line 1040
    if (tmp___4) {
#line 1040
      tmp___5 = 0;
    } else {
#line 1040
      tmp___5 = 1;
    }
#line 1040
    (listitems + i)->state = tmp___5;
#line 1041
    if (dialog_vars.item_help) {
#line 1041
      tmp___6 = j;
#line 1041
      j ++;
#line 1041
      (listitems + i)->help = *(items + tmp___6);
    } else {
      {
#line 1041
      tmp___7 = dlg_strempty();
#line 1041
      (listitems + i)->help = tmp___7;
      }
    }
#line 1035
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1045
  dlg_align_columns(& (listitems + 0)->text, (int )sizeof(DIALOG_LISTITEM ), item_no);
#line 1047
  result = dlg_buildlist(title, cprompt, height, width, list_height, item_no, listitems,
                         (char const   *)((void *)0), order_mode, & current);
  }
  {
#line 1060
  if (result == 3) {
#line 1060
    goto case_3;
  }
#line 1060
  if (result == 0) {
#line 1060
    goto case_3;
  }
#line 1063
  if (result == 2) {
#line 1063
    goto case_2;
  }
#line 1058
  goto switch_break;
  case_3: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 1061
  show_status = (_Bool)1;
#line 1062
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1064
  dlg_add_help_listitem(& result, & help_result, listitems + current);
#line 1065
  show_status = dialog_vars.help_status;
  }
#line 1065
  if (show_status) {
#line 1066
    if (separate_output) {
      {
#line 1067
      dlg_add_string(help_result);
#line 1068
      dlg_add_separator();
      }
    } else {
      {
#line 1070
      dlg_add_quoted(help_result);
      }
    }
  } else {
    {
#line 1073
    dlg_add_string(help_result);
    }
  }
#line 1075
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1078
  if (show_status) {
#line 1079
    i = 0;
    {
#line 1079
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1079
      if (! (i < item_no)) {
#line 1079
        goto while_break___0;
      }
#line 1080
      if ((listitems + i)->state) {
#line 1081
        if (separate_output) {
          {
#line 1082
          dlg_add_string((listitems + i)->name);
#line 1083
          dlg_add_separator();
          }
        } else {
          {
#line 1085
          tmp___8 = dlg_need_separator();
          }
#line 1085
          if (tmp___8) {
            {
#line 1086
            dlg_add_separator();
            }
          }
          {
#line 1087
          dlg_add_quoted((listitems + i)->name);
          }
        }
      }
#line 1079
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1091
    dlg_add_last_key(-1);
    }
  }
  {
#line 1094
  dlg_free_columns(& (listitems + 0)->text, (int )sizeof(DIALOG_LISTITEM ), item_no);
#line 1095
  free((void *)listitems);
  }
#line 1096
  return (result);
}
}
#line 69 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 57 "/usr/include/unctrl.h"
extern char const   *unctrl(chtype  ) ;
#line 705 "./dialog.h"
int dlg_find_index(int const   *list , int limit , int to_find ) ;
#line 706
int dlg_limit_columns(char const   *string , int limit , int offset ) ;
#line 129 "/usr/include/search.h"
extern void *tsearch(void const   *__key , void **__rootp , int (*__compar)(void const   * ,
                                                                            void const   * ) ) ;
#line 134
extern void *tfind(void const   *__key , void * const  *__rootp , int (*__compar)(void const   * ,
                                                                                  void const   * ) ) ;
#line 138
extern void *tdelete(void const   * __restrict  __key , void ** __restrict  __rootp ,
                     int (*__compar)(void const   * , void const   * ) ) ;
#line 66 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/inputstr.c"
static CACHE *cache_list  ;
#line 77 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/inputstr.c"
static void *sorted_cache  ;
#line 123 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/inputstr.c"
static int compare_cache(void const   *a , void const   *b ) 
{ 
  CACHE const   *p ;
  CACHE const   *q ;
  int result ;

  {
#line 126
  p = (CACHE const   *)a;
#line 127
  q = (CACHE const   *)b;
#line 128
  result = (int )(p->cache_num - q->cache_num);
#line 129
  if (result == 0) {
#line 130
    result = (int )(p->string_at - q->string_at);
  }
#line 131
  return (result);
}
}
#line 135 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/inputstr.c"
static CACHE *find_cache(int cache_num , char const   *string ) 
{ 
  CACHE *p ;
  void *pp ;
  CACHE find ;

  {
  {
#line 144
  memset((void *)(& find), 0, sizeof(find));
#line 145
  find.cache_num = cache_num;
#line 146
  find.string_at = string;
#line 148
  pp = tfind((void const   *)(& find), (void * const  *)(& sorted_cache), & compare_cache);
  }
#line 148
  if ((unsigned long )pp != (unsigned long )((void *)0)) {
#line 149
    p = *((CACHE **)pp);
  } else {
#line 151
    p = (CACHE *)0;
  }
#line 160
  return (p);
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/inputstr.c"
static CACHE *make_cache(int cache_num , char const   *string ) 
{ 
  CACHE *p ;
  void *tmp ;

  {
  {
#line 168
  tmp = calloc((size_t )1, sizeof(CACHE ));
#line 168
  p = (CACHE *)tmp;
  }
#line 169
  if ((unsigned long )p == (unsigned long )((CACHE *)0)) {
    {
#line 169
    dlg_exiterr("cannot allocate memory in load_cache");
    }
  }
  {
#line 170
  p->next = cache_list;
#line 171
  cache_list = p;
#line 173
  p->cache_num = cache_num;
#line 174
  p->string_at = string;
#line 177
  tsearch((void const   *)p, & sorted_cache, & compare_cache);
  }
#line 179
  return (p);
}
}
#line 182 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/inputstr.c"
static CACHE *load_cache(int cache_num , char const   *string ) 
{ 
  CACHE *p ;

  {
  {
#line 187
  p = find_cache(cache_num, string);
  }
#line 187
  if ((unsigned long )p == (unsigned long )((CACHE *)0)) {
    {
#line 188
    p = make_cache(cache_num, string);
    }
  }
#line 190
  return (p);
}
}
#line 202 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/inputstr.c"
static _Bool same_cache2(CACHE *cache , char const   *string , unsigned int i_len ) 
{ 
  unsigned int need ;
  size_t s_len ;
  size_t tmp ;
  _Bool result ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 206
  tmp = strlen(string);
#line 206
  s_len = tmp;
#line 207
  result = (_Bool)1;
  }
#line 209
  if (cache->s_len == 0UL) {
#line 209
    goto _L___1;
  } else
#line 209
  if (cache->s_len < s_len) {
#line 209
    goto _L___1;
  } else
#line 209
  if ((unsigned long )cache->list == (unsigned long )((int *)0)) {
#line 209
    goto _L___1;
  } else
#line 209
  if ((unsigned long )cache->string != (unsigned long )((char *)0)) {
    {
#line 209
    tmp___2 = memcmp((void const   *)cache->string, (void const   *)string, s_len);
    }
#line 209
    if (! (tmp___2 == 0)) {
#line 209
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
#line 214
    need = i_len + 1U;
#line 215
    if ((unsigned long )cache->list == (unsigned long )((int *)0)) {
      {
#line 216
      tmp___0 = malloc((size_t )need * sizeof(int ));
#line 216
      cache->list = (int *)tmp___0;
      }
    } else
#line 217
    if (cache->i_len < (size_t )i_len) {
      {
#line 218
      tmp___1 = realloc((void *)cache->list, (unsigned long )need * sizeof(int ));
#line 218
      cache->list = (int *)tmp___1;
      }
    }
#line 220
    if ((unsigned long )cache->list == (unsigned long )((int *)0)) {
      {
#line 220
      dlg_exiterr("cannot allocate memory in load_cache");
      }
    }
#line 221
    cache->i_len = (size_t )i_len;
#line 223
    if (cache->s_len >= s_len) {
#line 223
      if ((unsigned long )cache->string != (unsigned long )((char *)0)) {
        {
#line 224
        strcpy((char */* __restrict  */)cache->string, (char const   */* __restrict  */)string);
        }
      } else {
#line 223
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 226
      if ((unsigned long )cache->string != (unsigned long )((char *)0)) {
        {
#line 227
        free((void *)cache->string);
        }
      }
      {
#line 228
      cache->string = dlg_strclone(string);
      }
    }
#line 230
    cache->s_len = s_len;
#line 232
    result = (_Bool)0;
  }
#line 234
  return (result);
}
}
#line 308 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/inputstr.c"
int dlg_count_wchars(char const   *string ) 
{ 
  int result ;
  size_t tmp ;

  {
  {
#line 341
  tmp = strlen(string);
#line 341
  result = (int )tmp;
  }
#line 343
  return (result);
}
}
#line 350 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/inputstr.c"
int const   *dlg_index_wchars(char const   *string ) 
{ 
  unsigned int len ;
  int tmp ;
  unsigned int inx ;
  CACHE *cache ;
  CACHE *tmp___0 ;
  char const   *current ;
  _Bool tmp___1 ;

  {
  {
#line 353
  tmp = dlg_count_wchars(string);
#line 353
  len = (unsigned int )tmp;
#line 355
  tmp___0 = load_cache(3, string);
#line 355
  cache = tmp___0;
#line 357
  tmp___1 = same_cache2(cache, string, len);
  }
#line 357
  if (! tmp___1) {
#line 358
    current = string;
#line 360
    *(cache->list + 0) = 0;
#line 361
    inx = 1U;
    {
#line 361
    while (1) {
      while_continue: /* CIL Label */ ;
#line 361
      if (! (inx <= len)) {
#line 361
        goto while_break;
      }
#line 376
      *(cache->list + inx) = (int )inx;
#line 361
      inx ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 380
  return ((int const   *)cache->list);
}
}
#line 387 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/inputstr.c"
int dlg_find_index(int const   *list , int limit , int to_find ) 
{ 
  int result ;

  {
#line 391
  result = 0;
  {
#line 391
  while (1) {
    while_continue: /* CIL Label */ ;
#line 391
    if (! (result <= limit)) {
#line 391
      goto while_break;
    }
#line 392
    if (to_find == (int )*(list + result)) {
#line 395
      goto while_break;
    } else
#line 392
    if (result == limit) {
#line 395
      goto while_break;
    } else
#line 392
    if (result < limit) {
#line 392
      if (to_find < (int )*(list + (result + 1))) {
#line 395
        goto while_break;
      }
    }
#line 391
    result ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 398
  return (result);
}
}
#line 404 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/inputstr.c"
int const   *dlg_index_columns(char const   *string ) 
{ 
  unsigned int len ;
  int tmp ;
  unsigned int inx ;
  CACHE *cache ;
  CACHE *tmp___0 ;
  chtype ch ;
  char const   *printable ;
  size_t tmp___1 ;
  unsigned short const   **tmp___2 ;
  _Bool tmp___3 ;

  {
  {
#line 407
  tmp = dlg_count_wchars(string);
#line 407
  len = (unsigned int )tmp;
#line 409
  tmp___0 = load_cache(0, string);
#line 409
  cache = tmp___0;
#line 411
  tmp___3 = same_cache2(cache, string, len);
  }
#line 411
  if (! tmp___3) {
#line 412
    *(cache->list + 0) = 0;
#line 453
    inx = 0U;
    {
#line 453
    while (1) {
      while_continue: /* CIL Label */ ;
#line 453
      if (! (inx < len)) {
#line 453
        goto while_break;
      }
#line 454
      ch = (chtype )((unsigned char )*(string + inx));
#line 456
      if (ch == 9UL) {
#line 457
        *(cache->list + (inx + 1U)) = ((*(cache->list + inx) | 7) + 1) - *(cache->list + inx);
      } else {
        {
#line 459
        tmp___2 = __ctype_b_loc();
        }
#line 459
        if ((int const   )*(*tmp___2 + (int )ch) & 16384) {
#line 460
          *(cache->list + (inx + 1U)) = 1;
        } else {
          {
#line 463
          printable = unctrl(ch);
          }
#line 464
          if (printable) {
            {
#line 464
            tmp___1 = strlen(printable);
#line 464
            *(cache->list + (inx + 1U)) = (int )tmp___1;
            }
          } else {
#line 464
            *(cache->list + (inx + 1U)) = 1;
          }
        }
      }
#line 468
      if (inx != 0U) {
#line 469
        *(cache->list + (inx + 1U)) += *(cache->list + inx);
      }
#line 453
      inx ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 473
  return ((int const   *)cache->list);
}
}
#line 480 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/inputstr.c"
int dlg_count_columns(char const   *string ) 
{ 
  int result ;
  int limit ;
  int tmp ;
  int const   *cols ;
  int const   *tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 483
  result = 0;
#line 484
  tmp = dlg_count_wchars(string);
#line 484
  limit = tmp;
  }
#line 485
  if (limit > 0) {
    {
#line 486
    tmp___0 = dlg_index_columns(string);
#line 486
    cols = tmp___0;
#line 487
    result = (int )*(cols + limit);
    }
  } else {
    {
#line 489
    tmp___1 = strlen(string);
#line 489
    result = (int )tmp___1;
    }
  }
  {
#line 491
  dlg_finish_string(string);
  }
#line 492
  return (result);
}
}
#line 500 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/inputstr.c"
int dlg_limit_columns(char const   *string , int limit , int offset ) 
{ 
  int const   *cols ;
  int const   *tmp ;
  int result ;
  int tmp___0 ;

  {
  {
#line 503
  tmp = dlg_index_columns(string);
#line 503
  cols = tmp;
#line 504
  tmp___0 = dlg_count_wchars(string);
#line 504
  result = tmp___0;
  }
  {
#line 506
  while (1) {
    while_continue: /* CIL Label */ ;
#line 506
    if (result > 0) {
#line 506
      if (! (*(cols + result) - *(cols + offset) > (int const   )limit)) {
#line 506
        goto while_break;
      }
    } else {
#line 506
      goto while_break;
    }
#line 507
    result --;
  }
  while_break: /* CIL Label */ ;
  }
#line 508
  return (result);
}
}
#line 515 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/inputstr.c"
_Bool dlg_edit_string(char *string , int *chr_offset , int key , int fkey , _Bool force ) 
{ 
  int i ;
  int len ;
  size_t tmp ;
  int limit ;
  int tmp___0 ;
  int const   *indx ;
  int const   *tmp___1 ;
  int offset ;
  int tmp___2 ;
  int max_len ;
  int tmp___3 ;
  _Bool edit ;
  int gap ;
  char tmp___4 ;
  int tmp___5 ;
  int gap___0 ;
  int tmp___6 ;
  char tmp___7 ;
  int tmp___8 ;

  {
  {
#line 519
  tmp = strlen((char const   *)string);
#line 519
  len = (int )tmp;
#line 520
  tmp___0 = dlg_count_wchars((char const   *)string);
#line 520
  limit = tmp___0;
#line 521
  tmp___1 = dlg_index_wchars((char const   *)string);
#line 521
  indx = tmp___1;
#line 522
  tmp___2 = dlg_find_index(indx, limit, *chr_offset);
#line 522
  offset = tmp___2;
#line 523
  tmp___3 = dlg_max_input(2048);
#line 523
  max_len = tmp___3;
#line 524
  edit = (_Bool)1;
  }
#line 527
  if (! fkey) {
#line 528
    fkey = 1;
    {
#line 530
    if (key == 0) {
#line 530
      goto case_0;
    }
#line 533
    if (key == 9) {
#line 533
      goto case_9;
    }
#line 533
    if (key == 27) {
#line 533
      goto case_9;
    }
#line 536
    goto switch_default;
    case_0: /* CIL Label */ 
#line 531
    goto switch_break;
    case_9: /* CIL Label */ 
    case_27: /* CIL Label */ 
#line 534
    fkey = 0;
#line 535
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 537
    fkey = 0;
#line 538
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 542
  if (fkey) {
    {
#line 544
    if (key == 0) {
#line 544
      goto case_0___0;
    }
#line 547
    if (key == 536) {
#line 547
      goto case_536;
    }
#line 551
    if (key == 537) {
#line 551
      goto case_537;
    }
#line 555
    if (key == 542) {
#line 555
      goto case_542;
    }
#line 559
    if (key == 543) {
#line 559
      goto case_543;
    }
#line 563
    if (key == 538) {
#line 563
      goto case_538;
    }
#line 576
    if (key == 539) {
#line 576
      goto case_539;
    }
#line 598
    if (key == 540) {
#line 598
      goto case_540;
    }
#line 601
    if (key == 541) {
#line 601
      goto case_541;
    }
#line 605
    if (key == 410) {
#line 605
      goto case_410;
    }
#line 612
    if (key == 529) {
#line 612
      goto case_529;
    }
#line 612
    if (key == 528) {
#line 612
      goto case_529;
    }
#line 612
    if (key == 535) {
#line 612
      goto case_529;
    }
#line 612
    if (key == 534) {
#line 612
      goto case_529;
    }
#line 615
    if (key == -1) {
#line 615
      goto case_neg_1;
    }
#line 618
    goto switch_default___0;
    case_0___0: /* CIL Label */ 
#line 545
    edit = force;
#line 546
    goto switch_break___0;
    case_536: /* CIL Label */ 
#line 548
    if (*chr_offset) {
#line 548
      if (offset > 0) {
#line 549
        *chr_offset = (int )*(indx + (offset - 1));
      }
    }
#line 550
    goto switch_break___0;
    case_537: /* CIL Label */ 
#line 552
    if (offset < limit) {
#line 553
      *chr_offset = (int )*(indx + (offset + 1));
    }
#line 554
    goto switch_break___0;
    case_542: /* CIL Label */ 
#line 556
    if (*chr_offset) {
#line 557
      *chr_offset = 0;
    }
#line 558
    goto switch_break___0;
    case_543: /* CIL Label */ 
#line 560
    if (offset < limit) {
#line 561
      *chr_offset = (int )*(indx + limit);
    }
#line 562
    goto switch_break___0;
    case_538: /* CIL Label */ 
#line 564
    if (offset) {
#line 565
      gap = (int )(*(indx + offset) - *(indx + (offset - 1)));
#line 566
      *chr_offset = (int )*(indx + (offset - 1));
#line 567
      if (gap > 0) {
#line 568
        i = *chr_offset;
        {
#line 568
        while (1) {
          while_continue: /* CIL Label */ ;
#line 568
          tmp___4 = *(string + (i + gap));
#line 568
          *(string + i) = tmp___4;
#line 568
          if (! ((int )tmp___4 != 0)) {
#line 568
            goto while_break;
          }
#line 568
          i ++;
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
#line 575
    goto switch_break___0;
    case_539: /* CIL Label */ 
#line 577
    if (limit) {
#line 578
      limit --;
#line 578
      if (limit == 0) {
#line 579
        tmp___5 = 0;
#line 579
        *chr_offset = tmp___5;
#line 579
        *(string + tmp___5) = (char )'\000';
      } else {
#line 581
        if (offset <= limit) {
#line 581
          tmp___6 = *(indx + (offset + 1)) - *(indx + offset);
        } else {
#line 581
          tmp___6 = (int const   )0;
        }
#line 581
        gap___0 = (int )tmp___6;
#line 584
        if (gap___0 > 0) {
#line 585
          i = (int )*(indx + offset);
          {
#line 585
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 585
            tmp___7 = *(string + (i + gap___0));
#line 585
            *(string + i) = tmp___7;
#line 585
            if (! ((int )tmp___7 != 0)) {
#line 585
              goto while_break___0;
            }
#line 585
            i ++;
          }
          while_break___0: /* CIL Label */ ;
          }
        } else
#line 590
        if (offset > 0) {
#line 591
          *(string + *(indx + (offset - 1))) = (char )'\000';
        }
#line 593
        if (*chr_offset > (int )*(indx + limit)) {
#line 594
          *chr_offset = (int )*(indx + limit);
        }
      }
    }
#line 597
    goto switch_break___0;
    case_540: /* CIL Label */ 
#line 599
    tmp___8 = 0;
#line 599
    *chr_offset = tmp___8;
#line 599
    *(string + tmp___8) = (char )'\000';
#line 600
    goto switch_break___0;
    case_541: /* CIL Label */ 
#line 602
    edit = (_Bool)0;
#line 603
    goto switch_break___0;
    case_410: /* CIL Label */ 
#line 606
    edit = (_Bool)0;
#line 607
    goto switch_break___0;
    case_529: /* CIL Label */ 
    case_528: /* CIL Label */ 
    case_535: /* CIL Label */ 
    case_534: /* CIL Label */ 
#line 613
    edit = (_Bool)0;
#line 614
    goto switch_break___0;
    case_neg_1: /* CIL Label */ 
#line 616
    edit = (_Bool)0;
#line 617
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 619
    beep();
    }
#line 620
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  } else
#line 623
  if (key == 27) {
#line 624
    edit = (_Bool)0;
  } else
#line 623
  if (key == -1) {
#line 624
    edit = (_Bool)0;
  } else
#line 626
  if (len < max_len) {
#line 627
    len ++;
#line 627
    i = len;
    {
#line 627
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 627
      if (! (i > *chr_offset)) {
#line 627
        goto while_break___1;
      }
#line 628
      *(string + i) = *(string + (i - 1));
#line 627
      i --;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 629
    *(string + *chr_offset) = (char )key;
#line 630
    (*chr_offset) ++;
  } else {
    {
#line 632
    beep();
    }
  }
#line 636
  return (edit);
}
}
#line 639 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/inputstr.c"
static void compute_edit_offset(char const   *string , int chr_offset , int x_last ,
                                int *p_dpy_column , int *p_scroll_amt ) 
{ 
  int const   *cols ;
  int const   *tmp ;
  int const   *indx ;
  int const   *tmp___0 ;
  int limit ;
  int tmp___1 ;
  int offset ;
  int tmp___2 ;
  int offset2 ;
  int dpy_column ;
  int n ;

  {
  {
#line 646
  tmp = dlg_index_columns(string);
#line 646
  cols = tmp;
#line 647
  tmp___0 = dlg_index_wchars(string);
#line 647
  indx = tmp___0;
#line 648
  tmp___1 = dlg_count_wchars(string);
#line 648
  limit = tmp___1;
#line 649
  tmp___2 = dlg_find_index(indx, limit, chr_offset);
#line 649
  offset = tmp___2;
#line 654
  offset2 = 0;
#line 654
  n = offset2;
  }
  {
#line 654
  while (1) {
    while_continue: /* CIL Label */ ;
#line 654
    if (! (n <= offset)) {
#line 654
      goto while_break;
    }
#line 655
    if (*(cols + offset) - *(cols + n) < (int const   )x_last) {
#line 655
      if (offset == limit) {
#line 657
        offset2 = n;
#line 658
        goto while_break;
      } else
#line 655
      if (*(cols + (offset + 1)) - *(cols + n) < (int const   )x_last) {
#line 657
        offset2 = n;
#line 658
        goto while_break;
      }
    }
#line 654
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 662
  dpy_column = (int )(*(cols + offset) - *(cols + offset2));
#line 664
  if ((unsigned long )p_dpy_column != (unsigned long )((int *)0)) {
#line 665
    *p_dpy_column = dpy_column;
  }
#line 666
  if ((unsigned long )p_scroll_amt != (unsigned long )((int *)0)) {
#line 667
    *p_scroll_amt = offset2;
  }
#line 668
  return;
}
}
#line 674 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/inputstr.c"
int dlg_edit_offset(char *string , int chr_offset , int x_last ) 
{ 
  int result ;

  {
  {
#line 679
  compute_edit_offset((char const   *)string, chr_offset, x_last, & result, (int *)0);
  }
#line 681
  return (result);
}
}
#line 688 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/inputstr.c"
void dlg_show_string(WINDOW *win , char const   *string , int chr_offset , chtype attr ,
                     int y_base , int x_base , int x_last , _Bool hidden , _Bool force ) 
{ 
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int const   *cols ;
  int const   *tmp___3 ;
  int const   *indx ;
  int const   *tmp___4 ;
  int limit ;
  int tmp___5 ;
  int i ;
  int j ;
  int k ;
  int input_x ;
  int scrollamt ;
  int check ;
  chtype ch ;
  int count ;
  int tmp___6 ;

  {
#line 699
  if (win) {
#line 699
    tmp___2 = (int )win->_maxx + 1;
  } else {
#line 699
    tmp___2 = -1;
  }
#line 699
  if (x_last + x_base < tmp___2) {
#line 699
    tmp___1 = x_last + x_base;
  } else {
#line 699
    if (win) {
#line 699
      tmp___0 = (int )win->_maxx + 1;
    } else {
#line 699
      tmp___0 = -1;
    }
#line 699
    tmp___1 = tmp___0;
  }
#line 699
  x_last = tmp___1 - x_base;
#line 701
  if (hidden) {
#line 701
    if (! dialog_vars.insecure) {
#line 702
      if (force) {
        {
#line 703
        wmove(win, y_base, x_base);
#line 704
        wrefresh(win);
        }
      }
    } else {
#line 701
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    {
#line 707
    tmp___3 = dlg_index_columns(string);
#line 707
    cols = tmp___3;
#line 708
    tmp___4 = dlg_index_wchars(string);
#line 708
    indx = tmp___4;
#line 709
    tmp___5 = dlg_count_wchars(string);
#line 709
    limit = tmp___5;
#line 715
    compute_edit_offset(string, chr_offset, x_last, & input_x, & scrollamt);
    }
#line 717
    if (win) {
#line 717
      win->_attrs = attr;
    }
    {
#line 718
    wmove(win, y_base, x_base);
#line 719
    i = scrollamt;
#line 719
    k = 0;
    }
    {
#line 719
    while (1) {
      while_continue: /* CIL Label */ ;
#line 719
      if (i < limit) {
#line 719
        if (! (k < x_last)) {
#line 719
          goto while_break;
        }
      } else {
#line 719
        goto while_break;
      }
#line 720
      check = (int )(*(cols + (i + 1)) - *(cols + scrollamt));
#line 721
      if (check <= x_last) {
#line 722
        j = (int )*(indx + i);
        {
#line 722
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 722
          if (! (j < (int )*(indx + (i + 1)))) {
#line 722
            goto while_break___0;
          }
#line 723
          ch = (chtype )((unsigned char )*(string + j));
#line 724
          if (hidden) {
#line 724
            if (dialog_vars.insecure) {
              {
#line 725
              waddch(win, (chtype const   )'*');
              }
            } else {
#line 724
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 726
          if (ch == 9UL) {
#line 727
            count = (int )(*(cols + (i + 1)) - *(cols + i));
            {
#line 728
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 728
              count --;
#line 728
              if (! (count >= 0)) {
#line 728
                goto while_break___1;
              }
              {
#line 729
              waddch(win, (chtype const   )' ');
              }
            }
            while_break___1: /* CIL Label */ ;
            }
          } else {
            {
#line 731
            waddch(win, (chtype const   )ch);
            }
          }
#line 722
          j ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 734
        k = check;
      } else {
#line 736
        goto while_break;
      }
#line 719
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 739
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 739
      tmp___6 = k;
#line 739
      k ++;
#line 739
      if (! (tmp___6 < x_last)) {
#line 739
        goto while_break___2;
      }
      {
#line 740
      waddch(win, (chtype const   )' ');
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 741
    wmove(win, y_base, x_base + input_x);
#line 742
    wrefresh(win);
    }
  }
#line 744
  return;
}
}
#line 749 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/inputstr.c"
void dlg_finish_string(char const   *string ) 
{ 
  CACHE *p ;
  CACHE *q ;
  CACHE *r ;
  void *tmp ;

  {
#line 753
  if ((unsigned long )string != (unsigned long )((char const   *)0)) {
#line 753
    if (dialog_state.finish_string) {
#line 754
      p = cache_list;
#line 755
      q = (CACHE *)0;
      {
#line 758
      while (1) {
        while_continue: /* CIL Label */ ;
#line 758
        if (! ((unsigned long )p != (unsigned long )((CACHE *)0))) {
#line 758
          goto while_break;
        }
#line 759
        if ((unsigned long )p->string_at == (unsigned long )string) {
          {
#line 761
          tmp = tdelete((void const   */* __restrict  */)p, (void **/* __restrict  */)(& sorted_cache),
                        & compare_cache);
          }
#line 761
          if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 762
            goto while_continue;
          }
#line 766
          if ((unsigned long )p->string != (unsigned long )((char *)0)) {
            {
#line 767
            free((void *)p->string);
            }
          }
#line 768
          if ((unsigned long )p->list != (unsigned long )((int *)0)) {
            {
#line 769
            free((void *)p->list);
            }
          }
#line 770
          if ((unsigned long )p == (unsigned long )cache_list) {
#line 771
            cache_list = p->next;
#line 772
            r = cache_list;
          } else {
#line 774
            q->next = p->next;
#line 775
            r = q;
          }
          {
#line 777
          free((void *)p);
#line 778
          p = r;
          }
        } else {
#line 780
          q = p;
#line 781
          p = p->next;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 788
  return;
}
}
#line 342 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/columns.c"
static char *column_separator(void) 
{ 
  char *result ;

  {
#line 34
  result = (char *)0;
#line 36
  result = dialog_vars.column_separator;
#line 36
  if ((unsigned long )result != (unsigned long )((char *)0)) {
#line 37
    if ((int )*result == 0) {
#line 38
      result = (char *)0;
    }
  }
#line 40
  return (result);
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/columns.c"
static char **next_row(char **target , int per_row ) 
{ 
  char *result ;

  {
#line 46
  result = (char *)target;
#line 47
  result += per_row;
#line 48
  return ((char **)((void *)result));
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/columns.c"
static char *next_col(char *source , unsigned int offset ) 
{ 
  char *mark ;
  char *tmp ;
  char *result ;
  size_t tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 54
  tmp = column_separator();
#line 54
  mark = tmp;
#line 55
  result = source + offset;
  }
#line 56
  if (offset) {
    {
#line 57
    tmp___0 = strlen((char const   *)mark);
#line 57
    result += tmp___0;
    }
  }
  {
#line 58
  tmp___1 = strstr((char const   *)result, (char const   *)mark);
  }
#line 58
  return (tmp___1);
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/columns.c"
static unsigned int split_row(char *source , unsigned int *offsets , unsigned int *widths ) 
{ 
  int mark ;
  char *tmp ;
  size_t tmp___0 ;
  char *next ;
  unsigned int result ;
  unsigned int offset ;
  size_t tmp___1 ;

  {
  {
#line 68
  tmp = column_separator();
#line 68
  tmp___0 = strlen((char const   *)tmp);
#line 68
  mark = (int )tmp___0;
#line 69
  next = (char *)0;
#line 70
  result = 0U;
#line 71
  offset = 0U;
  }
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 74
    if (result) {
#line 75
      offset = (unsigned int )((next + mark) - source);
#line 76
      *(widths + (result - 1U)) = (offset - *(offsets + (result - 1U))) - (unsigned int )mark;
    }
    {
#line 78
    *(offsets + result) = offset;
#line 79
    result ++;
#line 73
    next = next_col(source, offset);
    }
#line 73
    if (! ((unsigned long )next != (unsigned long )((char *)0))) {
#line 73
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 82
  tmp___1 = strlen((char const   *)source);
#line 82
  offset = (unsigned int )tmp___1;
#line 83
  *(widths + (result - 1U)) = offset - *(offsets + (result - 1U));
  }
#line 85
  return (result);
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/columns.c"
void dlg_align_columns(char **target , int per_row , int num_rows ) 
{ 
  int row ;
  char **value ;
  unsigned int numcols ;
  size_t maxcols ;
  unsigned int *widths ;
  unsigned int *offsets ;
  unsigned int *maxwidth ;
  unsigned int realwidth ;
  unsigned int n ;
  size_t len ;
  size_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  unsigned int cols ;
  unsigned int tmp___3 ;
  unsigned int cols___0 ;
  unsigned int tmp___4 ;
  unsigned int offset ;
  char *text ;
  void *tmp___5 ;
  char *tmp___6 ;

  {
  {
#line 98
  tmp___6 = column_separator();
  }
#line 98
  if (tmp___6) {
#line 100
    numcols = 1U;
#line 101
    maxcols = (size_t )0;
#line 109
    row = 0;
#line 109
    value = target;
    {
#line 109
    while (1) {
      while_continue: /* CIL Label */ ;
#line 109
      if (! (row < num_rows)) {
#line 109
        goto while_break;
      }
      {
#line 110
      tmp = strlen((char const   *)*value);
#line 110
      len = tmp;
      }
#line 111
      if (maxcols < len) {
#line 112
        maxcols = len;
      }
      {
#line 109
      row ++;
#line 109
      value = next_row(value, per_row);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 114
    maxcols ++;
#line 115
    tmp___0 = calloc(maxcols, sizeof(unsigned int ));
#line 115
    widths = (unsigned int *)tmp___0;
#line 116
    tmp___1 = calloc(maxcols, sizeof(unsigned int ));
#line 116
    offsets = (unsigned int *)tmp___1;
#line 117
    tmp___2 = calloc(maxcols, sizeof(unsigned int ));
#line 117
    maxwidth = (unsigned int *)tmp___2;
    }
#line 119
    if ((unsigned long )widths == (unsigned long )((unsigned int *)0)) {
      {
#line 119
      dlg_exiterr("cannot allocate memory in dlg_align_columns");
      }
    }
#line 120
    if ((unsigned long )offsets == (unsigned long )((unsigned int *)0)) {
      {
#line 120
      dlg_exiterr("cannot allocate memory in dlg_align_columns");
      }
    }
#line 121
    if ((unsigned long )maxwidth == (unsigned long )((unsigned int *)0)) {
      {
#line 121
      dlg_exiterr("cannot allocate memory in dlg_align_columns");
      }
    }
#line 124
    row = 0;
#line 124
    value = target;
    {
#line 124
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 124
      if (! (row < num_rows)) {
#line 124
        goto while_break___0;
      }
      {
#line 125
      tmp___3 = split_row(*value, offsets, widths);
#line 125
      cols = tmp___3;
      }
#line 126
      if (numcols < cols) {
#line 127
        numcols = cols;
      }
#line 128
      n = 0U;
      {
#line 128
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 128
        if (! (n < cols)) {
#line 128
          goto while_break___1;
        }
#line 129
        if (*(maxwidth + n) < *(widths + n)) {
#line 130
          *(maxwidth + n) = *(widths + n);
        }
#line 128
        n ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 124
      row ++;
#line 124
      value = next_row(value, per_row);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 133
    realwidth = numcols - 1U;
#line 134
    n = 0U;
    {
#line 134
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 134
      if (! (n < numcols)) {
#line 134
        goto while_break___2;
      }
#line 135
      realwidth += *(maxwidth + n);
#line 134
      n ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 139
    row = 0;
#line 139
    value = target;
    {
#line 139
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 139
      if (! (row < num_rows)) {
#line 139
        goto while_break___3;
      }
      {
#line 140
      tmp___4 = split_row(*value, offsets, widths);
#line 140
      cols___0 = tmp___4;
#line 141
      offset = 0U;
#line 142
      tmp___5 = malloc((size_t )(realwidth + 1U) * sizeof(char ));
#line 142
      text = (char *)tmp___5;
      }
#line 144
      if ((unsigned long )text == (unsigned long )((char *)0)) {
        {
#line 144
        dlg_exiterr("cannot allocate memory in dlg_align_columns");
        }
      }
      {
#line 146
      memset((void *)text, ' ', (size_t )realwidth);
#line 147
      n = 0U;
      }
      {
#line 147
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 147
        if (! (n < cols___0)) {
#line 147
          goto while_break___4;
        }
        {
#line 148
        memcpy((void */* __restrict  */)(text + offset), (void const   */* __restrict  */)(*value + *(offsets + n)),
               (size_t )*(widths + n));
#line 149
        offset += *(maxwidth + n) + 1U;
#line 147
        n ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 151
      *(text + realwidth) = (char)0;
#line 152
      *value = text;
#line 139
      row ++;
#line 139
      value = next_row(value, per_row);
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 155
    free((void *)widths);
#line 156
    free((void *)offsets);
#line 157
    free((void *)maxwidth);
    }
  }
#line 159
  return;
}
}
#line 164 "/home/june/repo/benchmarks/collector/temp/dialog-1.2-20130928/columns.c"
void dlg_free_columns(char **target , int per_row , int num_rows ) 
{ 
  int row ;
  char **value ;
  char *tmp ;

  {
  {
#line 170
  tmp = column_separator();
  }
#line 170
  if (tmp) {
#line 171
    row = 0;
#line 171
    value = target;
    {
#line 171
    while (1) {
      while_continue: /* CIL Label */ ;
#line 171
      if (! (row < num_rows)) {
#line 171
        goto while_break;
      }
      {
#line 172
      free((void *)*value);
#line 171
      row ++;
#line 171
      value = next_row(value, per_row);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 175
  return;
}
}
