/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 19 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/dynbuf.h"
struct __anonstruct_DynamicBuffer_26 {
   char *buffer ;
   int len ;
   int allocatedLen ;
   char staticBuf[128] ;
};
#line 19 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/dynbuf.h"
typedef struct __anonstruct_DynamicBuffer_26 DynamicBuffer;
#line 17 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/types.h"
union __anonunion_v_28 {
   char *str ;
   int val ;
};
#line 17 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/types.h"
struct __anonstruct_Value_27 {
   char type ;
   union __anonunion_v_28 v ;
};
#line 17 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/types.h"
typedef struct __anonstruct_Value_27 Value;
#line 49 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/types.h"
struct var {
   struct var *next ;
   char name[17] ;
   char preserve ;
   Value v ;
};
#line 49 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/types.h"
typedef struct var Var;
#line 90 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/types.h"
struct __anonstruct_Parser_34 {
   char isnested ;
   char allownested ;
   char const   *text ;
   char const   *pos ;
   char const   *etext ;
   char const   *epos ;
   DynamicBuffer pushedToken ;
   char const   *tokenPushed ;
   char expr_happened ;
   char nonconst_expr ;
};
#line 90 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/types.h"
typedef struct __anonstruct_Parser_34 Parser;
#line 103 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/types.h"
typedef Parser *ParsePtr;
#line 555 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/var.c"
struct __anonstruct_SysVar_36 {
   char const   *name ;
   char modifiable ;
   int type ;
   void *value ;
   int min ;
   int max ;
};
#line 555 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/var.c"
typedef struct __anonstruct_SysVar_36 SysVar;
#line 57 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/types.h"
struct __anonstruct_Trigger_32 {
   int expired ;
   int wd ;
   int d ;
   int m ;
   int y ;
   int back ;
   int delta ;
   int rep ;
   int localomit ;
   int skip ;
   int until ;
   int typ ;
   int once ;
   int scanfrom ;
   int priority ;
   char sched[17] ;
   char warn[17] ;
   char omitfunc[17] ;
   DynamicBuffer tags ;
   char passthru[33] ;
};
#line 57 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/types.h"
typedef struct __anonstruct_Trigger_32 Trigger;
#line 81 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/types.h"
struct __anonstruct_TimeTrig_33 {
   int ttime ;
   int nexttime ;
   int delta ;
   int rep ;
   int duration ;
};
#line 81 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/types.h"
typedef struct __anonstruct_TimeTrig_33 TimeTrig;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 82 "/usr/include/glob.h"
struct __anonstruct_glob_t_29 {
   size_t gl_pathc ;
   char **gl_pathv ;
   size_t gl_offs ;
   int gl_flags ;
   void (*gl_closedir)(void * ) ;
   void *(*gl_readdir)(void * ) ;
   void *(*gl_opendir)(char const   * ) ;
   int (*gl_lstat)(char const   * __restrict   , void * __restrict   ) ;
   int (*gl_stat)(char const   * __restrict   , void * __restrict   ) ;
};
#line 82 "/usr/include/glob.h"
typedef struct __anonstruct_glob_t_29 glob_t;
#line 48 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/files.c"
struct cache {
   struct cache *next ;
   char const   *text ;
   int LineNo ;
};
#line 48 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/files.c"
typedef struct cache CachedLine;
#line 54 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/files.c"
struct cheader {
   struct cheader *next ;
   char const   *filename ;
   CachedLine *cache ;
   int ownedByMe ;
};
#line 54 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/files.c"
typedef struct cheader CachedFile;
#line 62 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/files.c"
struct fname_chain {
   struct fname_chain *next ;
   char const   *filename ;
};
#line 62 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/files.c"
typedef struct fname_chain FilenameChain;
#line 68 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/files.c"
struct directory_fname_chain {
   struct directory_fname_chain *next ;
   FilenameChain *chain ;
   char const   *dirname ;
};
#line 68 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/files.c"
typedef struct directory_fname_chain DirectoryFilenameChain;
#line 75 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/files.c"
struct __anonstruct_IncludeStruct_40 {
   char const   *filename ;
   FilenameChain *chain ;
   int LineNo ;
   unsigned int IfFlags ;
   int NumIfs ;
   long offset ;
   CachedLine *CLine ;
   int ownedByMe ;
};
#line 75 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/files.c"
typedef struct __anonstruct_IncludeStruct_40 IncludeStruct;
#line 146 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/types.h"
enum TokTypes {
    T_Illegal = 0,
    T_Rem = 1,
    T_Push = 2,
    T_Pop = 3,
    T_Preserve = 4,
    T_Include = 5,
    T_If = 6,
    T_Else = 7,
    T_EndIf = 8,
    T_IfTrig = 9,
    T_ErrMsg = 10,
    T_Set = 11,
    T_UnSet = 12,
    T_Fset = 13,
    T_Omit = 14,
    T_Banner = 15,
    T_Exit = 16,
    T_WkDay = 17,
    T_Month = 18,
    T_Time = 19,
    T_Date = 20,
    T_DateTime = 21,
    T_Skip = 22,
    T_At = 23,
    T_RemType = 24,
    T_Until = 25,
    T_Year = 26,
    T_Day = 27,
    T_Rep = 28,
    T_Delta = 29,
    T_Back = 30,
    T_Once = 31,
    T_Empty = 32,
    T_Comment = 33,
    T_Number = 34,
    T_Clr = 35,
    T_Debug = 36,
    T_Dumpvars = 37,
    T_Scanfrom = 38,
    T_Flush = 39,
    T_Priority = 40,
    T_Sched = 41,
    T_Warn = 42,
    T_Tag = 43,
    T_Duration = 44,
    T_LongTime = 45,
    T_OmitFunc = 46,
    T_Through = 47
} ;
#line 175 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/types.h"
struct __anonstruct_Token_34 {
   char *name ;
   char MinLen ;
   enum TokTypes type ;
   int val ;
};
#line 175 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/types.h"
typedef struct __anonstruct_Token_34 Token;
#line 36 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/omit.c"
struct omitcontext {
   struct omitcontext *next ;
   int numfull ;
   int numpart ;
   int *fullsave ;
   int *partsave ;
};
#line 36 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/omit.c"
typedef struct omitcontext OmitContext;
#line 26 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/sort.c"
struct sortrem {
   struct sortrem *next ;
   char const   *text ;
   int trigdate ;
   int trigtime ;
   int typ ;
   int priority ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/sort.c"
typedef struct sortrem Sortrem;
#line 10 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/md5.h"
typedef unsigned int uint32;
#line 17 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/md5.h"
struct MD5Context {
   uint32 buf[4] ;
   uint32 bits[2] ;
   unsigned char in[64] ;
};
#line 324 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef int wchar_t;
#line 353 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned int wint_t;
#line 33 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/calendar.c"
struct cal_entry {
   struct cal_entry *next ;
   char const   *text ;
   char const   *pos ;
   wchar_t const   *wc_text ;
   wchar_t const   *wc_pos ;
   int is_color ;
   int r ;
   int g ;
   int b ;
   int time ;
   int priority ;
   DynamicBuffer tags ;
   char passthru[33] ;
   int duration ;
   char const   *filename ;
   int lineno ;
};
#line 33 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/calendar.c"
typedef struct cal_entry CalEntry;
#line 53 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/calendar.c"
struct line_drawing {
   char const   *graphics_on ;
   char const   *graphics_off ;
   char *tlr ;
   char *bl ;
   char *tbl ;
   char *blr ;
   char *tblr ;
   char *tr ;
   char *tb ;
   char *br ;
   char *tbr ;
   char *tl ;
   char *lr ;
};
#line 34 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/types.h"
struct __anonstruct_func_info_30 {
   int nargs ;
   Value retval ;
};
#line 34 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/types.h"
typedef struct __anonstruct_func_info_30 func_info;
#line 40 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/types.h"
struct __anonstruct_BuiltinFunc_31 {
   char const   *name ;
   char minargs ;
   char maxargs ;
   char is_constant ;
   int (*func)(func_info * ) ;
};
#line 40 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/types.h"
typedef struct __anonstruct_BuiltinFunc_31 BuiltinFunc;
#line 29 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/userfns.c"
struct udf_struct {
   struct udf_struct *next ;
   char name[17] ;
   char const   *text ;
   Var *locals ;
   char IsActive ;
   int nargs ;
};
#line 29 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/userfns.c"
typedef struct udf_struct UserFunc;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_41 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_41 fd_set;
#line 38 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/queue.c"
struct queuedrem {
   struct queuedrem *next ;
   int typ ;
   int RunDisabled ;
   int ntrig ;
   char const   *text ;
   char passthru[33] ;
   char sched[17] ;
   DynamicBuffer tags ;
   TimeTrig tt ;
};
#line 38 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/queue.c"
typedef struct queuedrem QueuedRem;
#line 80 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 26 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/types.h"
struct __anonstruct_Operator_29 {
   char const   *name ;
   char prec ;
   char type ;
   int (*func)(void) ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/types.h"
typedef struct __anonstruct_Operator_29 Operator;
#line 46 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/rem2ps.c"
struct calentry {
   struct calentry *next ;
   int special ;
   char *entry ;
};
#line 46 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/rem2ps.c"
typedef struct calentry CalEntry___0;
#line 52 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/rem2ps.c"
struct __anonstruct_PageType_30 {
   char const   *name ;
   int xsize ;
   int ysize ;
};
#line 52 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/rem2ps.c"
typedef struct __anonstruct_PageType_30 PageType;
#line 435 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 356 "/usr/include/stdio.h"
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/dynbuf.h"
void DBufInit(DynamicBuffer *dbuf ) ;
#line 29
void DBufFree(DynamicBuffer *dbuf ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int JulianToday ;
#line 39
int FreshLine ;
#line 42
int DebugFlag ;
#line 43
int DoCalendar ;
#line 44
int DoSimpleCalendar ;
#line 46
int DoPrefixLineNo ;
#line 49
int PsCal ;
#line 53
int Hush ;
#line 54
int NextMode ;
#line 55
int InfiniteDelta ;
#line 56
int DeltaOffset ;
#line 57
int RunDisabled ;
#line 58
int IgnoreOnce ;
#line 59
int SortByTime ;
#line 60
int SortByDate ;
#line 61
int SortByPrio ;
#line 62
int UntimedBeforeTimed ;
#line 63
int DefaultPrio ;
#line 69
int DontFork ;
#line 70
int DontQueue ;
#line 71
int NumQueued ;
#line 72
int DontIssueAts ;
#line 73
int Daemon ;
#line 74
char DateSep ;
#line 75
char TimeSep ;
#line 78
int MaxSatIter ;
#line 79
int MaxStringLen ;
#line 82
int PurgeMode ;
#line 84
FILE *ErrFp ;
#line 88
int LastTriggerDate ;
#line 89
int LastTrigValid ;
#line 93
int NumTriggered ;
#line 103
int LatDeg ;
#line 104
int LatMin ;
#line 105
int LatSec ;
#line 106
int LongDeg ;
#line 107
int LongMin ;
#line 108
int LongSec ;
#line 109
char *Location ;
#line 112
int MinsFromUTC ;
#line 113
int CalculateUTC ;
#line 114
int FoldYear ;
#line 117
int FormWidth ;
#line 118
int FirstIndent ;
#line 119
int SubsIndent ;
#line 120
char *EndSent ;
#line 121
char *EndSentIg ;
#line 40 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/protos.h"
void PrintValue(Value *v , FILE *fp___0 ) ;
#line 41
int CopyValue(Value *dest , Value const   *src ) ;
#line 53
void FromJulian(int jul , int *y , int *m , int *d ) ;
#line 55
int ParseToken(ParsePtr p , DynamicBuffer *dbuf ) ;
#line 56
int ParseIdentifier(ParsePtr p , DynamicBuffer *dbuf ) ;
#line 57
int EvaluateExpr(ParsePtr p , Value *v ) ;
#line 60
void Eprint(char const   *fmt  , ...) ;
#line 90
char *StrnCpy(char *dest , char const   *source , int n ) ;
#line 92
int StrinCmp(char const   *s1 , char const   *s2 , int n ) ;
#line 93
char *StrDup(char const   *s ) ;
#line 94
int StrCmpi(char const   *s1 , char const   *s2 ) ;
#line 95
Var *FindVar(char const   *str , int create ) ;
#line 96
int DeleteVar(char const   *str ) ;
#line 97
int SetVar(char const   *str , Value *val ) ;
#line 98
int GetVarValue(char const   *str , Value *val , Var *locals , ParsePtr p ) ;
#line 99
int DoSet(Parser *p ) ;
#line 100
int DoUnset(Parser *p ) ;
#line 101
int DoDump(ParsePtr p ) ;
#line 102
void DumpVarTable(void) ;
#line 103
void DestroyVars(int all ) ;
#line 104
int PreserveVar(char const   *name ) ;
#line 105
int DoPreserve(Parser *p ) ;
#line 108
int ParseNonSpaceChar(ParsePtr p , int *err , int peek ) ;
#line 109
unsigned int HashVal(char const   *str ) ;
#line 127
int GetSysVar(char const   *name , Value *val ) ;
#line 128
int SetSysVar(char const   *name , Value *value ) ;
#line 129
void DumpSysVarByName(char const   *name ) ;
#line 132 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/err.h"
char *ErrMsg[102] ;
#line 35 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/var.c"
static Var *VHashTbl[64]  ;
#line 39 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/var.c"
static int trig_date_func(int do_set , Value *val ) 
{ 


  {
#line 41
  val->type = (char)3;
#line 42
  if (! LastTrigValid) {
#line 43
    val->v.val = 0;
  } else {
#line 45
    val->v.val = LastTriggerDate;
  }
#line 47
  return (0);
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/var.c"
static int trig_day_func(int do_set , Value *val ) 
{ 
  int y ;
  int m ;
  int d ;

  {
#line 52
  val->type = (char)1;
#line 53
  if (! LastTrigValid) {
#line 54
    val->v.val = -1;
#line 55
    return (0);
  }
  {
#line 58
  FromJulian(LastTriggerDate, & y, & m, & d);
#line 59
  val->v.val = d;
  }
#line 60
  return (0);
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/var.c"
static int trig_mon_func(int do_set , Value *val ) 
{ 
  int y ;
  int m ;
  int d ;

  {
#line 66
  val->type = (char)1;
#line 67
  if (! LastTrigValid) {
#line 68
    val->v.val = -1;
#line 69
    return (0);
  }
  {
#line 72
  FromJulian(LastTriggerDate, & y, & m, & d);
#line 73
  val->v.val = m + 1;
  }
#line 74
  return (0);
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/var.c"
static int trig_year_func(int do_set , Value *val ) 
{ 
  int y ;
  int m ;
  int d ;

  {
#line 80
  val->type = (char)1;
#line 81
  if (! LastTrigValid) {
#line 82
    val->v.val = -1;
#line 83
    return (0);
  }
  {
#line 86
  FromJulian(LastTriggerDate, & y, & m, & d);
#line 87
  val->v.val = y;
  }
#line 88
  return (0);
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/var.c"
static int trig_wday_func(int do_set , Value *val ) 
{ 


  {
#line 93
  val->type = (char)1;
#line 94
  if (! LastTrigValid) {
#line 95
    val->v.val = -1;
#line 96
    return (0);
  }
#line 99
  val->v.val = (LastTriggerDate + 1) % 7;
#line 100
  return (0);
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/var.c"
static int today_date_func(int do_set , Value *val ) 
{ 


  {
#line 105
  val->type = (char)3;
#line 106
  val->v.val = JulianToday;
#line 107
  return (0);
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/var.c"
static int today_day_func(int do_set , Value *val ) 
{ 
  int y ;
  int m ;
  int d ;

  {
  {
#line 112
  val->type = (char)1;
#line 113
  FromJulian(JulianToday, & y, & m, & d);
#line 114
  val->v.val = d;
  }
#line 115
  return (0);
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/var.c"
static int today_mon_func(int do_set , Value *val ) 
{ 
  int y ;
  int m ;
  int d ;

  {
  {
#line 121
  val->type = (char)1;
#line 122
  FromJulian(JulianToday, & y, & m, & d);
#line 123
  val->v.val = m + 1;
  }
#line 124
  return (0);
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/var.c"
static int today_year_func(int do_set , Value *val ) 
{ 
  int y ;
  int m ;
  int d ;

  {
  {
#line 130
  val->type = (char)1;
#line 131
  FromJulian(JulianToday, & y, & m, & d);
#line 132
  val->v.val = y;
  }
#line 133
  return (0);
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/var.c"
static int today_wday_func(int do_set , Value *val ) 
{ 


  {
#line 138
  val->type = (char)1;
#line 139
  val->v.val = (JulianToday + 1) % 7;
#line 140
  return (0);
}
}
#line 143 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/var.c"
static int date_sep_func(int do_set , Value *val ) 
{ 
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 145
  if (! do_set) {
    {
#line 146
    tmp = malloc((size_t )2);
#line 146
    val->v.str = (char *)tmp;
    }
#line 147
    if (! val->v.str) {
#line 147
      return (9);
    }
#line 148
    *(val->v.str + 0) = DateSep;
#line 149
    *(val->v.str + 1) = (char)0;
#line 150
    val->type = (char)4;
#line 151
    return (0);
  }
#line 153
  if ((int )val->type != 4) {
#line 153
    return (14);
  }
  {
#line 154
  tmp___0 = strcmp((char const   *)val->v.str, "/");
  }
#line 154
  if (tmp___0) {
    {
#line 154
    tmp___1 = strcmp((char const   *)val->v.str, "-");
    }
#line 154
    if (tmp___1) {
#line 156
      return (14);
    }
  }
#line 158
  DateSep = *(val->v.str + 0);
#line 159
  return (0);
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/var.c"
static int time_sep_func(int do_set , Value *val ) 
{ 
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 164
  if (! do_set) {
    {
#line 165
    tmp = malloc((size_t )2);
#line 165
    val->v.str = (char *)tmp;
    }
#line 166
    if (! val->v.str) {
#line 166
      return (9);
    }
#line 167
    *(val->v.str + 0) = TimeSep;
#line 168
    *(val->v.str + 1) = (char)0;
#line 169
    val->type = (char)4;
#line 170
    return (0);
  }
#line 172
  if ((int )val->type != 4) {
#line 172
    return (14);
  }
  {
#line 173
  tmp___0 = strcmp((char const   *)val->v.str, ":");
  }
#line 173
  if (tmp___0) {
    {
#line 173
    tmp___1 = strcmp((char const   *)val->v.str, ".");
    }
#line 173
    if (tmp___1) {
#line 175
      return (14);
    }
  }
#line 177
  TimeSep = *(val->v.str + 0);
#line 178
  return (0);
}
}
#line 187 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/var.c"
unsigned int HashVal(char const   *str ) 
{ 
  register unsigned int i ;
  register unsigned int j ;
  register unsigned int len ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
#line 189
  i = 0U;
#line 190
  j = 1U;
#line 191
  len = 0U;
  {
#line 193
  while (1) {
    while_continue: /* CIL Label */ ;
#line 193
    if (*str) {
#line 193
      if (! (len < 16U)) {
#line 193
        goto while_break;
      }
    } else {
#line 193
      goto while_break;
    }
    {
#line 194
    tmp___2 = __ctype_b_loc();
    }
#line 194
    if ((int const   )*(*tmp___2 + (int )*str) & 512) {
      {
#line 194
      tmp___0 = toupper((int )*str);
#line 194
      tmp___1 = tmp___0;
      }
    } else {
#line 194
      tmp___1 = (int )*str;
    }
#line 194
    i += j * (unsigned int )tmp___1;
#line 195
    str ++;
#line 196
    len ++;
#line 197
    j = 3U - j;
  }
  while_break: /* CIL Label */ ;
  }
#line 199
  return (i);
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/var.c"
Var *FindVar(char const   *str , int create ) 
{ 
  register int h ;
  register Var *v ;
  register Var *prev ;
  unsigned int tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 215
  tmp = HashVal(str);
#line 215
  h = (int )(tmp % 64U);
#line 216
  v = VHashTbl[h];
#line 217
  prev = (Var *)((void *)0);
  }
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;
#line 219
    if (! v) {
#line 219
      goto while_break;
    }
    {
#line 220
    tmp___0 = StrinCmp(str, (char const   *)(v->name), 16);
    }
#line 220
    if (! tmp___0) {
#line 220
      return (v);
    }
#line 221
    prev = v;
#line 222
    v = v->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 224
  if (! create) {
#line 224
    return (v);
  }
  {
#line 227
  tmp___1 = malloc(sizeof(Var ));
#line 227
  v = (Var *)tmp___1;
  }
#line 228
  if (! v) {
#line 228
    return (v);
  }
  {
#line 229
  v->next = (struct var *)((void *)0);
#line 230
  v->v.type = (char)1;
#line 231
  v->v.v.val = 0;
#line 232
  v->preserve = (char)0;
#line 233
  StrnCpy(v->name, str, 16);
  }
#line 235
  if (prev) {
#line 235
    prev->next = v;
  } else {
#line 235
    VHashTbl[h] = v;
  }
#line 236
  return (v);
}
}
#line 246 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/var.c"
int DeleteVar(char const   *str ) 
{ 
  register int h ;
  register Var *v ;
  register Var *prev ;
  unsigned int tmp ;
  int tmp___0 ;

  {
  {
#line 252
  tmp = HashVal(str);
#line 252
  h = (int )(tmp % 64U);
#line 253
  v = VHashTbl[h];
#line 254
  prev = (Var *)((void *)0);
  }
  {
#line 256
  while (1) {
    while_continue: /* CIL Label */ ;
#line 256
    if (! v) {
#line 256
      goto while_break;
    }
    {
#line 257
    tmp___0 = StrinCmp(str, (char const   *)(v->name), 16);
    }
#line 257
    if (! tmp___0) {
#line 257
      goto while_break;
    }
#line 258
    prev = v;
#line 259
    v = v->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 261
  if (! v) {
#line 261
    return (18);
  }
#line 262
  if ((int )v->v.type == 4) {
#line 262
    if (v->v.v.str) {
      {
#line 262
      free((void *)v->v.v.str);
#line 262
      v->v.type = (char)0;
      }
    }
  }
#line 263
  if (prev) {
#line 263
    prev->next = v->next;
  } else {
#line 263
    VHashTbl[h] = v->next;
  }
  {
#line 264
  free((void *)v);
  }
#line 265
  return (0);
}
}
#line 275 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/var.c"
int SetVar(char const   *str , Value *val ) 
{ 
  Var *v ;
  Var *tmp ;

  {
  {
#line 277
  tmp = FindVar(str, 1);
#line 277
  v = tmp;
  }
#line 279
  if (! v) {
#line 279
    return (9);
  }
#line 281
  if ((int )v->v.type == 4) {
#line 281
    if (v->v.v.str) {
      {
#line 281
      free((void *)v->v.v.str);
#line 281
      v->v.type = (char)0;
      }
    }
  }
#line 282
  v->v = *val;
#line 283
  return (0);
}
}
#line 293 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/var.c"
int GetVarValue(char const   *str , Value *val , Var *locals , ParsePtr p ) 
{ 
  Var *v ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 298
  v = locals;
  {
#line 299
  while (1) {
    while_continue: /* CIL Label */ ;
#line 299
    if (! v) {
#line 299
      goto while_break;
    }
    {
#line 300
    tmp___0 = StrinCmp(str, (char const   *)(v->name), 16);
    }
#line 300
    if (! tmp___0) {
      {
#line 301
      tmp = CopyValue(val, (Value const   *)(& v->v));
      }
#line 301
      return (tmp);
    }
#line 302
    v = v->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 306
  if (p) {
#line 306
    p->nonconst_expr = (char)1;
  }
  {
#line 307
  v = FindVar(str, 0);
  }
#line 309
  if (! v) {
    {
#line 310
    Eprint("%s: %s", ErrMsg[18], str);
    }
#line 311
    return (18);
  }
  {
#line 313
  tmp___1 = CopyValue(val, (Value const   *)(& v->v));
  }
#line 313
  return (tmp___1);
}
}
#line 321 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/var.c"
int DoSet(Parser *p ) 
{ 
  Value v ;
  int r ;
  DynamicBuffer buf___1 ;
  int tmp ;

  {
  {
#line 327
  DBufInit(& buf___1);
#line 329
  r = ParseIdentifier(p, & buf___1);
  }
#line 330
  if (r) {
#line 330
    return (r);
  }
  {
#line 333
  tmp = ParseNonSpaceChar(p, & r, 1);
  }
#line 333
  if (tmp == 61) {
    {
#line 334
    ParseNonSpaceChar(p, & r, 0);
    }
  }
  {
#line 337
  r = EvaluateExpr(p, & v);
  }
#line 338
  if (r) {
    {
#line 339
    DBufFree(& buf___1);
    }
#line 340
    return (r);
  }
#line 343
  if ((int )*(buf___1.buffer) == 36) {
    {
#line 343
    r = SetSysVar((char const   *)(buf___1.buffer + 1), & v);
    }
  } else {
    {
#line 344
    r = SetVar((char const   *)buf___1.buffer, & v);
    }
  }
  {
#line 345
  DBufFree(& buf___1);
  }
#line 346
  return (r);
}
}
#line 354 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/var.c"
int DoUnset(Parser *p ) 
{ 
  int r ;
  DynamicBuffer buf___1 ;

  {
  {
#line 359
  DBufInit(& buf___1);
#line 361
  r = ParseToken(p, & buf___1);
  }
#line 362
  if (r) {
#line 362
    return (r);
  }
#line 363
  if (! buf___1.len) {
    {
#line 364
    DBufFree(& buf___1);
    }
#line 365
    return (19);
  }
  {
#line 368
  DeleteVar((char const   *)buf___1.buffer);
  }
  {
#line 371
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 372
    r = ParseToken(p, & buf___1);
    }
#line 373
    if (r) {
#line 373
      return (r);
    }
#line 374
    if (! buf___1.len) {
      {
#line 375
      DBufFree(& buf___1);
      }
#line 376
      return (0);
    }
    {
#line 378
    DeleteVar((char const   *)buf___1.buffer);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 389 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/var.c"
int DoDump(ParsePtr p ) 
{ 
  int r ;
  Var *v ;
  DynamicBuffer buf___1 ;

  {
#line 395
  if (PurgeMode) {
#line 395
    return (0);
  }
  {
#line 397
  DBufInit(& buf___1);
#line 398
  r = ParseToken(p, & buf___1);
  }
#line 399
  if (r) {
#line 399
    return (r);
  }
#line 400
  if (! *(buf___1.buffer)) {
    {
#line 403
    DBufFree(& buf___1);
#line 404
    DumpVarTable();
    }
#line 405
    return (0);
  } else
#line 400
  if ((int )*(buf___1.buffer) == 35) {
    {
#line 403
    DBufFree(& buf___1);
#line 404
    DumpVarTable();
    }
#line 405
    return (0);
  } else
#line 400
  if ((int )*(buf___1.buffer) == 59) {
    {
#line 403
    DBufFree(& buf___1);
#line 404
    DumpVarTable();
    }
#line 405
    return (0);
  }
  {
#line 407
  fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"%*s  %s\n\n",
          16, ErrMsg[75], ErrMsg[76]);
  }
  {
#line 408
  while (1) {
    while_continue: /* CIL Label */ ;
#line 409
    if ((int )*(buf___1.buffer) == 36) {
      {
#line 410
      DumpSysVarByName((char const   *)(buf___1.buffer + 1));
      }
    } else {
      {
#line 412
      v = FindVar((char const   *)buf___1.buffer, 0);
#line 413
      *(buf___1.buffer + 16) = (char)0;
      }
#line 414
      if (! v) {
        {
#line 414
        fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"%*s  %s\n",
                16, buf___1.buffer, ErrMsg[77]);
        }
      } else {
        {
#line 417
        fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"%*s  ",
                16, v->name);
#line 418
        PrintValue(& v->v, ErrFp);
#line 419
        fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"\n");
        }
      }
    }
    {
#line 422
    r = ParseToken(p, & buf___1);
    }
#line 423
    if (r) {
#line 423
      return (r);
    }
#line 424
    if (! *(buf___1.buffer)) {
      {
#line 427
      DBufFree(& buf___1);
      }
#line 428
      return (0);
    } else
#line 424
    if ((int )*(buf___1.buffer) == 35) {
      {
#line 427
      DBufFree(& buf___1);
      }
#line 428
      return (0);
    } else
#line 424
    if ((int )*(buf___1.buffer) == 59) {
      {
#line 427
      DBufFree(& buf___1);
      }
#line 428
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 440 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/var.c"
void DumpVarTable(void) 
{ 
  register Var *v ;
  register int i ;

  {
  {
#line 445
  fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"%*s  %s\n\n",
          16, ErrMsg[75], ErrMsg[76]);
#line 447
  i = 0;
  }
  {
#line 447
  while (1) {
    while_continue: /* CIL Label */ ;
#line 447
    if (! (i < 64)) {
#line 447
      goto while_break;
    }
#line 448
    v = VHashTbl[i];
    {
#line 449
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 449
      if (! v) {
#line 449
        goto while_break___0;
      }
      {
#line 450
      fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"%*s  ",
              16, v->name);
#line 451
      PrintValue(& v->v, ErrFp);
#line 452
      fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"\n");
#line 453
      v = v->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 447
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 456
  return;
}
}
#line 466 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/var.c"
void DestroyVars(int all ) 
{ 
  int i ;
  Var *v ;
  Var *next ;
  Var *prev ;

  {
#line 471
  i = 0;
  {
#line 471
  while (1) {
    while_continue: /* CIL Label */ ;
#line 471
    if (! (i < 64)) {
#line 471
      goto while_break;
    }
#line 472
    v = VHashTbl[i];
#line 473
    VHashTbl[i] = (Var *)((void *)0);
#line 474
    prev = (Var *)((void *)0);
    {
#line 475
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 475
      if (! v) {
#line 475
        goto while_break___0;
      }
#line 476
      if (all) {
#line 476
        goto _L;
      } else
#line 476
      if (! v->preserve) {
        _L: /* CIL Label */ 
#line 477
        if ((int )v->v.type == 4) {
#line 477
          if (v->v.v.str) {
            {
#line 477
            free((void *)v->v.v.str);
#line 477
            v->v.type = (char)0;
            }
          }
        }
        {
#line 478
        next = v->next;
#line 479
        free((void *)v);
        }
      } else {
#line 481
        if (prev) {
#line 481
          prev->next = v;
        } else {
#line 482
          VHashTbl[i] = v;
        }
#line 483
        prev = v;
#line 484
        next = v->next;
#line 485
        v->next = (struct var *)((void *)0);
      }
#line 487
      v = next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 471
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 490
  return;
}
}
#line 499 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/var.c"
int PreserveVar(char const   *name ) 
{ 
  Var *v ;

  {
  {
#line 503
  v = FindVar(name, 1);
  }
#line 504
  if (! v) {
#line 504
    return (9);
  }
#line 505
  v->preserve = (char)1;
#line 506
  return (0);
}
}
#line 514 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/var.c"
int DoPreserve(Parser *p ) 
{ 
  int r ;
  DynamicBuffer buf___1 ;

  {
  {
#line 519
  DBufInit(& buf___1);
#line 521
  r = ParseToken(p, & buf___1);
  }
#line 522
  if (r) {
#line 522
    return (r);
  }
#line 523
  if (! buf___1.len) {
    {
#line 524
    DBufFree(& buf___1);
    }
#line 525
    return (19);
  }
  {
#line 528
  r = PreserveVar((char const   *)buf___1.buffer);
#line 529
  DBufFree(& buf___1);
  }
#line 530
  if (r) {
#line 530
    return (r);
  }
  {
#line 533
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 534
    r = ParseToken(p, & buf___1);
    }
#line 535
    if (r) {
#line 535
      return (r);
    }
#line 536
    if (! buf___1.len) {
      {
#line 537
      DBufFree(& buf___1);
      }
#line 538
      return (0);
    }
    {
#line 540
    r = PreserveVar((char const   *)buf___1.buffer);
#line 541
    DBufFree(& buf___1);
    }
#line 542
    if (r) {
#line 542
      return (r);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 572 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/var.c"
static SysVar SysVarArr[50]  = 
#line 572
  {      {"CalcUTC", (char)1, 1, (void *)(& CalculateUTC), 0, 1}, 
        {"CalMode", (char)0, 1, (void *)(& DoCalendar), 0, 0}, 
        {"Daemon", (char)0, 1, (void *)(& Daemon), 0, 0}, 
        {"DateSep", (char)1, 6, (void *)(& date_sep_func), 0, 0}, 
        {"DefaultPrio", (char)1, 1, (void *)(& DefaultPrio), 0, 9999}, 
        {"DeltaOffset", (char)0, 1, (void *)(& DeltaOffset), 0, 0}, 
        {"DontFork", (char)0, 1, (void *)(& DontFork), 0, 0}, 
        {"DontQueue", (char)0, 1, (void *)(& DontQueue), 0, 0}, 
        {"DontTrigAts", (char)0, 1, (void *)(& DontIssueAts), 0, 0}, 
        {"EndSent", (char)1, 4, (void *)(& EndSent), 0, 0}, 
        {"EndSentIg", (char)1, 4, (void *)(& EndSentIg), 0, 0}, 
        {"FirstIndent", (char)1, 1, (void *)(& FirstIndent), 0, 132}, 
        {"FoldYear", (char)1, 1, (void *)(& FoldYear), 0, 1}, 
        {"FormWidth", (char)1, 1, (void *)(& FormWidth), 20, 132}, 
        {"HushMode", (char)0, 1, (void *)(& Hush), 0, 0}, 
        {"IgnoreOnce", (char)0, 1, (void *)(& IgnoreOnce), 0, 0}, 
        {"InfDelta", (char)0, 1, (void *)(& InfiniteDelta), 0, 0}, 
        {"LatDeg", (char)1, 1, (void *)(& LatDeg), -90, 90}, 
        {"LatMin", (char)1, 1, (void *)(& LatMin), -59, 59}, 
        {"LatSec", (char)1, 1, (void *)(& LatSec), -59, 59}, 
        {"Location", (char)1, 4, (void *)(& Location), 0, 0}, 
        {"LongDeg", (char)1, 1, (void *)(& LongDeg), -180, 180}, 
        {"LongMin", (char)1, 1, (void *)(& LongMin), -59, 59}, 
        {"LongSec", (char)1, 1, (void *)(& LongSec), -59, 59}, 
        {"MaxSatIter", (char)1, 1, (void *)(& MaxSatIter), 10, -31415926}, 
        {"MaxStringLen", (char)1, 1, (void *)(& MaxStringLen), -1, -31415926}, 
        {"MinsFromUTC", (char)1, 1, (void *)(& MinsFromUTC), -780, 780}, 
        {"NextMode", (char)0, 1, (void *)(& NextMode), 0, 0}, 
        {"NumQueued", (char)0, 1, (void *)(& NumQueued), 0, 0}, 
        {"NumTrig", (char)0, 1, (void *)(& NumTriggered), 0, 0}, 
        {"PrefixLineNo", (char)0, 1, (void *)(& DoPrefixLineNo), 0, 0}, 
        {"PSCal", (char)0, 1, (void *)(& PsCal), 0, 0}, 
        {"RunOff", (char)0, 1, (void *)(& RunDisabled), 0, 0}, 
        {"SimpleCal", (char)0, 1, (void *)(& DoSimpleCalendar), 0, 0}, 
        {"SortByDate", (char)0, 1, (void *)(& SortByDate), 0, 0}, 
        {"SortByPrio", (char)0, 1, (void *)(& SortByPrio), 0, 0}, 
        {"SortByTime", (char)0, 1, (void *)(& SortByTime), 0, 0}, 
        {"SubsIndent", (char)1, 1, (void *)(& SubsIndent), 0, 132}, 
        {"T", (char)0, 6, (void *)(& trig_date_func), 0, 0}, 
        {"Td", (char)0, 6, (void *)(& trig_day_func), 0, 0}, 
        {"TimeSep", (char)1, 6, (void *)(& time_sep_func), 0, 0}, 
        {"Tm", (char)0, 6, (void *)(& trig_mon_func), 0, 0}, 
        {"Tw", (char)0, 6, (void *)(& trig_wday_func), 0, 0}, 
        {"Ty", (char)0, 6, (void *)(& trig_year_func), 0, 0}, 
        {"U", (char)0, 6, (void *)(& today_date_func), 0, 0}, 
        {"Ud", (char)0, 6, (void *)(& today_day_func), 0, 0}, 
        {"Um", (char)0, 6, (void *)(& today_mon_func), 0, 0}, 
        {"UntimedFirst", (char)0, 1, (void *)(& UntimedBeforeTimed), 0, 0}, 
        {"Uw", (char)0, 6, (void *)(& today_wday_func), 0, 0}, 
        {"Uy", (char)0, 6, (void *)(& today_year_func), 0, 0}};
#line 627
static SysVar *FindSysVar(char const   *name ) ;
#line 628
static void DumpSysVar(char const   *name , SysVar const   *v ) ;
#line 636 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/var.c"
int SetSysVar(char const   *name , Value *value ) 
{ 
  SysVar *v ;
  SysVar *tmp ;
  int (*f)(int  , Value * ) ;
  int tmp___0 ;

  {
  {
#line 638
  tmp = FindSysVar(name);
#line 638
  v = tmp;
  }
#line 639
  if (! v) {
#line 639
    return (18);
  }
#line 640
  if (v->type != 6) {
#line 640
    if (v->type != (int )value->type) {
#line 641
      return (14);
    }
  }
#line 642
  if (! v->modifiable) {
    {
#line 643
    Eprint("%s: `$%s\'", ErrMsg[45], name);
    }
#line 644
    return (45);
  }
#line 647
  if (v->type == 6) {
    {
#line 648
    f = (int (*)(int  , Value * ))v->value;
#line 649
    tmp___0 = (*f)(1, value);
    }
#line 649
    return (tmp___0);
  } else
#line 650
  if (v->type == 4) {
#line 652
    if (v->min) {
      {
#line 652
      free((void *)*((char **)v->value));
      }
    }
#line 653
    v->min = 1;
#line 654
    *((char **)v->value) = value->v.str;
#line 655
    value->type = (char)0;
  } else {
#line 657
    if (v->max != -31415926) {
#line 657
      if (value->v.val > v->max) {
#line 657
        return (28);
      }
    }
#line 658
    if (v->min != -31415926) {
#line 658
      if (value->v.val < v->min) {
#line 658
        return (29);
      }
    }
#line 659
    *((int *)v->value) = value->v.val;
  }
#line 661
  return (0);
}
}
#line 671 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/var.c"
int GetSysVar(char const   *name , Value *val ) 
{ 
  SysVar *v ;
  SysVar *tmp ;
  int (*f)(int  , Value * ) ;
  int tmp___0 ;

  {
  {
#line 673
  tmp = FindSysVar(name);
#line 673
  v = tmp;
#line 675
  val->type = (char)0;
  }
#line 676
  if (! v) {
#line 676
    return (18);
  }
#line 677
  if (v->type == 6) {
    {
#line 678
    f = (int (*)(int  , Value * ))v->value;
#line 679
    tmp___0 = (*f)(0, val);
    }
#line 679
    return (tmp___0);
  } else
#line 680
  if (v->type == 4) {
    {
#line 681
    val->v.str = StrDup((char const   *)*((char **)v->value));
    }
#line 682
    if (! val->v.str) {
#line 682
      return (9);
    }
  } else {
#line 684
    val->v.val = *((int *)v->value);
  }
#line 686
  val->type = (char )v->type;
#line 689
  if (DebugFlag & 1) {
#line 690
    if ((unsigned long )v->value == (unsigned long )((void *)(& RunDisabled))) {
      {
#line 691
      Eprint("(Security note: $RunOff variable tested.)\n");
#line 693
      FreshLine = 1;
      }
    }
  }
#line 696
  return (0);
}
}
#line 706 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/var.c"
static SysVar *FindSysVar(char const   *name ) 
{ 
  int top ;
  int bottom ;
  int mid ;
  int r ;

  {
#line 708
  top = (int )(sizeof(SysVarArr) / sizeof(SysVar ) - 1UL);
#line 708
  bottom = 0;
#line 709
  mid = (top + bottom) / 2;
  {
#line 712
  while (1) {
    while_continue: /* CIL Label */ ;
#line 712
    if (! (top >= bottom)) {
#line 712
      goto while_break;
    }
    {
#line 713
    r = StrCmpi(name, SysVarArr[mid].name);
    }
#line 714
    if (! r) {
#line 714
      return (& SysVarArr[mid]);
    } else
#line 715
    if (r > 0) {
#line 715
      bottom = mid + 1;
    } else {
#line 716
      top = mid - 1;
    }
#line 717
    mid = (top + bottom) / 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 719
  return ((SysVar *)((void *)0));
}
}
#line 730 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/var.c"
void DumpSysVarByName(char const   *name ) 
{ 
  int i ;
  SysVar *v ;

  {
#line 735
  if (! name) {
#line 735
    goto _L;
  } else
#line 735
  if (! *name) {
    _L: /* CIL Label */ 
#line 736
    i = 0;
    {
#line 736
    while (1) {
      while_continue: /* CIL Label */ ;
#line 736
      if (! ((unsigned long )i < sizeof(SysVarArr) / sizeof(SysVar ))) {
#line 736
        goto while_break;
      }
      {
#line 736
      DumpSysVar(name, (SysVar const   *)(SysVarArr + i));
#line 736
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 737
    return;
  }
  {
#line 740
  v = FindSysVar(name);
#line 741
  DumpSysVar(name, (SysVar const   *)v);
  }
#line 742
  return;
}
}
#line 752 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/var.c"
static void DumpSysVar(char const   *name , SysVar const   *v ) 
{ 
  char buffer[26] ;
  Value val ;
  int (*f)(int  , Value * ) ;
  char const   *s ;
  int y ;
  char const   *tmp ;
  Value val___0 ;

  {
#line 756
  if (name) {
#line 756
    if (! *name) {
#line 756
      name = (char const   *)((void *)0);
    }
  }
#line 757
  if (! v) {
#line 757
    if (! name) {
#line 757
      return;
    }
  }
#line 759
  buffer[0] = (char )'$';
#line 759
  buffer[1] = (char)0;
#line 760
  if (name) {
    {
#line 760
    strcat((char */* __restrict  */)(buffer), (char const   */* __restrict  */)name);
    }
  } else {
    {
#line 760
    strcat((char */* __restrict  */)(buffer), (char const   */* __restrict  */)v->name);
    }
  }
  {
#line 761
  fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"%*s  ",
          17, buffer);
  }
#line 762
  if (v) {
#line 763
    if (v->type == 6) {
      {
#line 765
      f = (int (*)(int  , Value * ))v->value;
#line 766
      (*f)(0, & val);
#line 767
      PrintValue(& val, ErrFp);
#line 768
      _IO_putc('\n', ErrFp);
      }
#line 769
      if ((int )val.type == 4) {
#line 769
        if (val.v.str) {
          {
#line 769
          free((void *)val.v.str);
#line 769
          val.type = (char)0;
          }
        }
      }
    } else
#line 770
    if (v->type == 4) {
      {
#line 771
      s = (char const   *)*((char **)v->value);
#line 773
      _IO_putc('\"', ErrFp);
#line 774
      y = 0;
      }
      {
#line 774
      while (1) {
        while_continue: /* CIL Label */ ;
#line 774
        if (y < 40) {
#line 774
          if (! *s) {
#line 774
            goto while_break;
          }
        } else {
#line 774
          goto while_break;
        }
#line 775
        if ((int const   )*s == 34) {
          {
#line 776
          fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"\" + char(34) + \"");
#line 777
          s ++;
          }
        } else {
          {
#line 779
          tmp = s;
#line 779
          s ++;
#line 779
          _IO_putc((int )*tmp, ErrFp);
          }
        }
#line 774
        y ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 782
      _IO_putc('\"', ErrFp);
      }
#line 783
      if (*s) {
        {
#line 783
        fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"...");
        }
      }
      {
#line 784
      _IO_putc('\n', ErrFp);
      }
    } else
#line 785
    if (v->type == 3) {
      {
#line 787
      val___0.type = (char)3;
#line 788
      val___0.v.val = *((int *)v->value);
#line 789
      PrintValue(& val___0, ErrFp);
#line 790
      _IO_putc('\n', ErrFp);
      }
    } else
#line 792
    if (! v->modifiable) {
      {
#line 792
      fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"%d\n",
              *((int *)v->value));
      }
    } else {
      {
#line 794
      fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"%-10d  ",
              *((int *)v->value));
      }
#line 795
      if (v->min == -31415926) {
        {
#line 795
        fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"(-Inf, ");
        }
      } else {
        {
#line 796
        fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"[%d, ",
                v->min);
        }
      }
#line 797
      if (v->max == -31415926) {
        {
#line 797
        fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"Inf)\n");
        }
      } else {
        {
#line 798
        fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"%d]\n",
                v->max);
        }
      }
    }
  } else {
    {
#line 801
    fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"%s\n",
            ErrMsg[77]);
    }
  }
#line 803
  return;
}
}
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 399 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int RealToday ;
#line 40
char const   *MsgCommand ;
#line 27 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/dynbuf.h"
int DBufPutcFN(DynamicBuffer *dbuf , char c ) ;
#line 28
int DBufPuts(DynamicBuffer *dbuf , char const   *str ) ;
#line 132 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
char *EnglishMonthName[12] ;
#line 150
char *EnglishDayName[7] ;
#line 35 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/protos.h"
int DoSubst(ParsePtr p , DynamicBuffer *dbuf , Trigger *t , TimeTrig *tt , int jul ,
            int mode ) ;
#line 36
int DoSubstFromString(char const   *source , DynamicBuffer *dbuf , int jul , int tim ) ;
#line 54
int ParseChar(ParsePtr p , int *err , int peek ) ;
#line 62
void CreateParser(char const   *s , ParsePtr p ) ;
#line 63
void DestroyParser(ParsePtr p ) ;
#line 65
long SystemTime(int realtime ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/dosubst.c"
static char TODAY[6]  = {      (char )'t',      (char )'o',      (char )'d',      (char )'a', 
        (char )'y',      (char )'\000'};
#line 34 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/dosubst.c"
static char TOMORROW[9]  = 
#line 34
  {      (char )'t',      (char )'o',      (char )'m',      (char )'o', 
        (char )'r',      (char )'r',      (char )'o',      (char )'w', 
        (char )'\000'};
#line 48 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/dosubst.c"
int DoSubst(ParsePtr p , DynamicBuffer *dbuf , Trigger *t , TimeTrig *tt , int jul ,
            int mode ) 
{ 
  int diff ;
  int curtime ;
  long tmp ;
  int err ;
  int done ;
  int c ;
  int d ;
  int m ;
  int y ;
  int tim ;
  int h ;
  int min ;
  int hh ;
  int ch ;
  int cmin ;
  int chh ;
  char const   *pm ;
  char const   *cpm ;
  int tdiff ;
  int adiff ;
  int mdiff ;
  int hdiff ;
  char const   *mplu ;
  char const   *hplu ;
  char const   *when ;
  char const   *plu ;
  int has_quote ;
  char *ss ;
  char *os ;
  char s[256] ;
  int origLen ;
  int altmode ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned short const   **tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int tmp___13 ;
  int tmp___14 ;
  unsigned short const   **tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  char const   *tmp___31 ;
  int tmp___32 ;
  char const   *tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  char const   *tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  size_t tmp___65 ;
  size_t tmp___66 ;
  int tmp___68 ;
  unsigned short const   **tmp___69 ;
  unsigned short const   **tmp___70 ;
  char *tmp___71 ;
  char *tmp___72 ;
  char *tmp___73 ;
  size_t tmp___74 ;

  {
  {
#line 50
  diff = jul - JulianToday;
#line 51
  tmp = SystemTime(0);
#line 51
  curtime = (int )(tmp / 60L);
#line 55
  tim = tt->ttime;
#line 60
  has_quote = 0;
#line 64
  origLen = dbuf->len;
#line 67
  FromJulian(jul, & y, & m, & d);
  }
#line 69
  if (tim == 2147483647) {
#line 69
    tim = curtime;
  }
#line 70
  tdiff = tim - curtime;
#line 71
  if (tdiff < 0) {
#line 71
    adiff = - tdiff;
  } else {
#line 71
    adiff = tdiff;
  }
#line 72
  mdiff = adiff % 60;
#line 73
  hdiff = adiff / 60;
#line 78
  if (mdiff == 1) {
#line 78
    mplu = "";
  } else {
#line 78
    mplu = "s";
  }
#line 84
  if (hdiff == 1) {
#line 84
    hplu = "";
  } else {
#line 84
    hplu = "s";
  }
#line 87
  if (tdiff < 0) {
#line 87
    when = "ago";
  } else {
#line 87
    when = "from now";
  }
#line 89
  h = tim / 60;
#line 90
  min = tim % 60;
#line 95
  if (h < 12) {
#line 95
    pm = "am";
  } else {
#line 95
    pm = "pm";
  }
#line 97
  if (h == 12) {
#line 97
    hh = 12;
  } else {
#line 97
    hh = h % 12;
  }
#line 99
  ch = curtime / 60;
#line 100
  cmin = curtime % 60;
#line 105
  if (ch < 12) {
#line 105
    cpm = "am";
  } else {
#line 105
    cpm = "pm";
  }
#line 107
  if (ch == 12) {
#line 107
    chh = 12;
  } else {
#line 107
    chh = ch % 12;
  }
  {
#line 115
  if (d == 31) {
#line 115
    goto case_31;
  }
#line 115
  if (d == 21) {
#line 115
    goto case_31;
  }
#line 115
  if (d == 1) {
#line 115
    goto case_31;
  }
#line 118
  if (d == 22) {
#line 118
    goto case_22;
  }
#line 118
  if (d == 2) {
#line 118
    goto case_22;
  }
#line 121
  if (d == 23) {
#line 121
    goto case_23;
  }
#line 121
  if (d == 3) {
#line 121
    goto case_23;
  }
#line 123
  goto switch_default;
  case_31: /* CIL Label */ 
  case_21: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 115
  plu = "st";
#line 115
  goto switch_break;
  case_22: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 118
  plu = "nd";
#line 118
  goto switch_break;
  case_23: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 121
  plu = "rd";
#line 121
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 123
  plu = "th";
#line 123
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 128
    c = ParseChar(p, & err, 0);
    }
#line 129
    if (err) {
      {
#line 130
      DBufFree(dbuf);
      }
#line 131
      return (err);
    }
#line 133
    if (c == 10) {
#line 133
      goto while_continue;
    }
#line 134
    if (! c) {
#line 135
      if (mode != 1) {
#line 135
        if (mode != 2) {
#line 135
          if (t->typ != 2) {
#line 135
            if (! MsgCommand) {
#line 137
              if (dbuf->allocatedLen < dbuf->len + 1) {
#line 137
                tmp___0 = dbuf->len;
#line 137
                (dbuf->len) ++;
#line 137
                *(dbuf->buffer + tmp___0) = (char )'\n';
#line 137
                *(dbuf->buffer + dbuf->len) = (char)0;
#line 137
                tmp___2 = 0;
              } else {
                {
#line 137
                tmp___1 = DBufPutcFN(dbuf, (char )'\n');
#line 137
                tmp___2 = tmp___1 != 0;
                }
              }
#line 137
              if (tmp___2) {
#line 137
                return (9);
              }
            }
          }
        }
      }
#line 139
      goto while_break;
    }
#line 141
    if (c != 37) {
#line 142
      if (dbuf->allocatedLen < dbuf->len + 1) {
#line 142
        tmp___3 = dbuf->len;
#line 142
        (dbuf->len) ++;
#line 142
        *(dbuf->buffer + tmp___3) = (char )c;
#line 142
        *(dbuf->buffer + dbuf->len) = (char)0;
#line 142
        tmp___5 = 0;
      } else {
        {
#line 142
        tmp___4 = DBufPutcFN(dbuf, (char )c);
#line 142
        tmp___5 = tmp___4 != 0;
        }
      }
#line 142
      if (tmp___5) {
#line 142
        return (9);
      }
#line 143
      goto while_continue;
    }
    {
#line 145
    altmode = 0;
#line 146
    s[0] = (char)0;
#line 147
    c = ParseChar(p, & err, 0);
    }
#line 148
    if (err) {
      {
#line 149
      DBufFree(dbuf);
      }
#line 150
      return (err);
    }
#line 152
    if (! c) {
#line 153
      goto while_break;
    }
#line 155
    if (c == 42) {
      {
#line 156
      altmode = c;
#line 157
      c = ParseChar(p, & err, 0);
      }
#line 158
      if (err) {
        {
#line 159
        DBufFree(dbuf);
        }
#line 160
        return (err);
      }
#line 162
      if (! c) {
#line 163
        goto while_break;
      }
    }
#line 166
    done = 0;
#line 167
    if (diff <= 1) {
      {
#line 168
      tmp___9 = __ctype_b_loc();
      }
#line 168
      if ((int const   )*(*tmp___9 + c) & 512) {
        {
#line 168
        tmp___7 = toupper(c);
#line 168
        tmp___8 = tmp___7;
        }
      } else {
#line 168
        tmp___8 = c;
      }
      {
#line 206
      if (tmp___8 == 86) {
#line 206
        goto case_86;
      }
#line 206
      if (tmp___8 == 85) {
#line 206
        goto case_86;
      }
#line 206
      if (tmp___8 == 76) {
#line 206
        goto case_86;
      }
#line 206
      if (tmp___8 == 75) {
#line 206
        goto case_86;
      }
#line 206
      if (tmp___8 == 74) {
#line 206
        goto case_86;
      }
#line 206
      if (tmp___8 == 73) {
#line 206
        goto case_86;
      }
#line 206
      if (tmp___8 == 72) {
#line 206
        goto case_86;
      }
#line 206
      if (tmp___8 == 71) {
#line 206
        goto case_86;
      }
#line 206
      if (tmp___8 == 70) {
#line 206
        goto case_86;
      }
#line 206
      if (tmp___8 == 69) {
#line 206
        goto case_86;
      }
#line 206
      if (tmp___8 == 67) {
#line 206
        goto case_86;
      }
#line 206
      if (tmp___8 == 66) {
#line 206
        goto case_86;
      }
#line 206
      if (tmp___8 == 65) {
#line 206
        goto case_86;
      }
#line 213
      goto switch_default___0;
      case_86: /* CIL Label */ 
      case_85: /* CIL Label */ 
      case_76: /* CIL Label */ 
      case_75: /* CIL Label */ 
      case_74: /* CIL Label */ 
      case_73: /* CIL Label */ 
      case_72: /* CIL Label */ 
      case_71: /* CIL Label */ 
      case_70: /* CIL Label */ 
      case_69: /* CIL Label */ 
      case_67: /* CIL Label */ 
      case_66: /* CIL Label */ 
      case_65: /* CIL Label */ 
#line 208
      if (diff) {
#line 208
        tmp___10 = TOMORROW;
      } else {
#line 208
        tmp___10 = TODAY;
      }
      {
#line 208
      sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%s",
              tmp___10);
#line 209
      tmp___11 = DBufPuts(dbuf, (char const   *)(s));
      }
#line 209
      if (tmp___11 != 0) {
#line 209
        return (9);
      }
#line 210
      done = 1;
#line 211
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
#line 213
      done = 0;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 217
    if (! done) {
      {
#line 217
      tmp___15 = __ctype_b_loc();
      }
#line 217
      if ((int const   )*(*tmp___15 + c) & 512) {
        {
#line 217
        tmp___13 = toupper(c);
#line 217
        tmp___14 = tmp___13;
        }
      } else {
#line 217
        tmp___14 = c;
      }
      {
#line 218
      if (tmp___14 == 65) {
#line 218
        goto case_65___0;
      }
#line 233
      if (tmp___14 == 66) {
#line 233
        goto case_66___0;
      }
#line 242
      if (tmp___14 == 67) {
#line 242
        goto case_67___0;
      }
#line 255
      if (tmp___14 == 68) {
#line 255
        goto case_68;
      }
#line 264
      if (tmp___14 == 69) {
#line 264
        goto case_69___0;
      }
#line 279
      if (tmp___14 == 70) {
#line 279
        goto case_70___0;
      }
#line 292
      if (tmp___14 == 71) {
#line 292
        goto case_71___0;
      }
#line 305
      if (tmp___14 == 72) {
#line 305
        goto case_72___0;
      }
#line 318
      if (tmp___14 == 73) {
#line 318
        goto case_73___0;
      }
#line 331
      if (tmp___14 == 74) {
#line 331
        goto case_74___0;
      }
#line 346
      if (tmp___14 == 75) {
#line 346
        goto case_75___0;
      }
#line 361
      if (tmp___14 == 76) {
#line 361
        goto case_76___0;
      }
#line 374
      if (tmp___14 == 77) {
#line 374
        goto case_77;
      }
#line 383
      if (tmp___14 == 78) {
#line 383
        goto case_78;
      }
#line 392
      if (tmp___14 == 79) {
#line 392
        goto case_79;
      }
#line 402
      if (tmp___14 == 80) {
#line 402
        goto case_80;
      }
#line 411
      if (tmp___14 == 81) {
#line 411
        goto case_81;
      }
#line 420
      if (tmp___14 == 82) {
#line 420
        goto case_82;
      }
#line 429
      if (tmp___14 == 83) {
#line 429
        goto case_83;
      }
#line 438
      if (tmp___14 == 84) {
#line 438
        goto case_84;
      }
#line 447
      if (tmp___14 == 85) {
#line 447
        goto case_85___0;
      }
#line 462
      if (tmp___14 == 86) {
#line 462
        goto case_86___0;
      }
#line 477
      if (tmp___14 == 87) {
#line 477
        goto case_87;
      }
#line 486
      if (tmp___14 == 88) {
#line 486
        goto case_88;
      }
#line 495
      if (tmp___14 == 89) {
#line 495
        goto case_89;
      }
#line 504
      if (tmp___14 == 90) {
#line 504
        goto case_90;
      }
#line 513
      if (tmp___14 == 49) {
#line 513
        goto case_49;
      }
#line 530
      if (tmp___14 == 50) {
#line 530
        goto case_50;
      }
#line 543
      if (tmp___14 == 51) {
#line 543
        goto case_51;
      }
#line 557
      if (tmp___14 == 52) {
#line 557
        goto case_52;
      }
#line 566
      if (tmp___14 == 53) {
#line 566
        goto case_53;
      }
#line 575
      if (tmp___14 == 54) {
#line 575
        goto case_54;
      }
#line 584
      if (tmp___14 == 55) {
#line 584
        goto case_55;
      }
#line 593
      if (tmp___14 == 56) {
#line 593
        goto case_56;
      }
#line 602
      if (tmp___14 == 57) {
#line 602
        goto case_57;
      }
#line 611
      if (tmp___14 == 48) {
#line 611
        goto case_48;
      }
#line 620
      if (tmp___14 == 33) {
#line 620
        goto case_33;
      }
#line 629
      if (tmp___14 == 64) {
#line 629
        goto case_64;
      }
#line 638
      if (tmp___14 == 35) {
#line 638
        goto case_35;
      }
#line 647
      if (tmp___14 == 95) {
#line 647
        goto case_95;
      }
#line 655
      if (tmp___14 == 1) {
#line 655
        goto case_1___0;
      }
#line 659
      if (tmp___14 == 34) {
#line 659
        goto case_34;
      }
#line 664
      goto switch_default___1;
      case_65___0: /* CIL Label */ 
#line 222
      if (altmode == 42) {
        {
#line 223
        sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%s, %d %s, %d",
                EnglishDayName[jul % 7], d, EnglishMonthName[m], y);
        }
      } else {
        {
#line 226
        sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%s %s, %d %s, %d",
                "on", EnglishDayName[jul % 7], d, EnglishMonthName[m], y);
        }
      }
      {
#line 230
      tmp___16 = DBufPuts(dbuf, (char const   *)(s));
      }
#line 230
      if (tmp___16 != 0) {
#line 230
        return (9);
      }
#line 231
      goto switch_break___1;
      case_66___0: /* CIL Label */ 
      {
#line 237
      sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"in %d days\' time",
              diff);
#line 239
      tmp___17 = DBufPuts(dbuf, (char const   *)(s));
      }
#line 239
      if (tmp___17 != 0) {
#line 239
        return (9);
      }
#line 240
      goto switch_break___1;
      case_67___0: /* CIL Label */ 
#line 246
      if (altmode == 42) {
        {
#line 247
        sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%s",
                EnglishDayName[jul % 7]);
        }
      } else {
        {
#line 249
        sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%s %s",
                "on", EnglishDayName[jul % 7]);
        }
      }
      {
#line 252
      tmp___18 = DBufPuts(dbuf, (char const   *)(s));
      }
#line 252
      if (tmp___18 != 0) {
#line 252
        return (9);
      }
#line 253
      goto switch_break___1;
      case_68: /* CIL Label */ 
      {
#line 259
      sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%d",
              d);
#line 261
      tmp___19 = DBufPuts(dbuf, (char const   *)(s));
      }
#line 261
      if (tmp___19 != 0) {
#line 261
        return (9);
      }
#line 262
      goto switch_break___1;
      case_69___0: /* CIL Label */ 
#line 268
      if (altmode == 42) {
        {
#line 269
        sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%02d%c%02d%c%04d",
                d, (int )DateSep, m + 1, (int )DateSep, y);
        }
      } else {
        {
#line 272
        sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%s %02d%c%02d%c%04d",
                "on", d, (int )DateSep, m + 1, (int )DateSep, y);
        }
      }
      {
#line 276
      tmp___20 = DBufPuts(dbuf, (char const   *)(s));
      }
#line 276
      if (tmp___20 != 0) {
#line 276
        return (9);
      }
#line 277
      goto switch_break___1;
      case_70___0: /* CIL Label */ 
#line 283
      if (altmode == 42) {
        {
#line 284
        sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%02d%c%02d%c%04d",
                m + 1, (int )DateSep, d, (int )DateSep, y);
        }
      } else {
        {
#line 286
        sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%s %02d%c%02d%c%04d",
                "on", m + 1, (int )DateSep, d, (int )DateSep, y);
        }
      }
      {
#line 289
      tmp___21 = DBufPuts(dbuf, (char const   *)(s));
      }
#line 289
      if (tmp___21 != 0) {
#line 289
        return (9);
      }
#line 290
      goto switch_break___1;
      case_71___0: /* CIL Label */ 
#line 296
      if (altmode == 42) {
        {
#line 297
        sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%s, %d %s",
                EnglishDayName[jul % 7], d, EnglishMonthName[m]);
        }
      } else {
        {
#line 299
        sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%s %s, %d %s",
                "on", EnglishDayName[jul % 7], d, EnglishMonthName[m]);
        }
      }
      {
#line 302
      tmp___22 = DBufPuts(dbuf, (char const   *)(s));
      }
#line 302
      if (tmp___22 != 0) {
#line 302
        return (9);
      }
#line 303
      goto switch_break___1;
      case_72___0: /* CIL Label */ 
#line 309
      if (altmode == 42) {
        {
#line 310
        sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%02d%c%02d",
                d, (int )DateSep, m + 1);
        }
      } else {
        {
#line 312
        sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%s %02d%c%02d",
                "on", d, (int )DateSep, m + 1);
        }
      }
      {
#line 315
      tmp___23 = DBufPuts(dbuf, (char const   *)(s));
      }
#line 315
      if (tmp___23 != 0) {
#line 315
        return (9);
      }
#line 316
      goto switch_break___1;
      case_73___0: /* CIL Label */ 
#line 322
      if (altmode == 42) {
        {
#line 323
        sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%02d%c%02d",
                m + 1, (int )DateSep, d);
        }
      } else {
        {
#line 325
        sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%s %02d%c%02d",
                "on", m + 1, (int )DateSep, d);
        }
      }
      {
#line 328
      tmp___24 = DBufPuts(dbuf, (char const   *)(s));
      }
#line 328
      if (tmp___24 != 0) {
#line 328
        return (9);
      }
#line 329
      goto switch_break___1;
      case_74___0: /* CIL Label */ 
#line 335
      if (altmode == 42) {
        {
#line 336
        sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%s, %s %d%s, %d",
                EnglishDayName[jul % 7], EnglishMonthName[m], d, plu, y);
        }
      } else {
        {
#line 339
        sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%s %s, %s %d%s, %d",
                "on", EnglishDayName[jul % 7], EnglishMonthName[m], d, plu, y);
        }
      }
      {
#line 343
      tmp___25 = DBufPuts(dbuf, (char const   *)(s));
      }
#line 343
      if (tmp___25 != 0) {
#line 343
        return (9);
      }
#line 344
      goto switch_break___1;
      case_75___0: /* CIL Label */ 
#line 350
      if (altmode == 42) {
        {
#line 351
        sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%s, %s %d%s",
                EnglishDayName[jul % 7], EnglishMonthName[m], d, plu);
        }
      } else {
        {
#line 354
        sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%s %s, %s %d%s",
                "on", EnglishDayName[jul % 7], EnglishMonthName[m], d, plu);
        }
      }
      {
#line 358
      tmp___26 = DBufPuts(dbuf, (char const   *)(s));
      }
#line 358
      if (tmp___26 != 0) {
#line 358
        return (9);
      }
#line 359
      goto switch_break___1;
      case_76___0: /* CIL Label */ 
#line 365
      if (altmode == 42) {
        {
#line 366
        sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%04d%c%02d%c%02d",
                y, (int )DateSep, m + 1, (int )DateSep, d);
        }
      } else {
        {
#line 368
        sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%s %04d%c%02d%c%02d",
                "on", y, (int )DateSep, m + 1, (int )DateSep, d);
        }
      }
      {
#line 371
      tmp___27 = DBufPuts(dbuf, (char const   *)(s));
      }
#line 371
      if (tmp___27 != 0) {
#line 371
        return (9);
      }
#line 372
      goto switch_break___1;
      case_77: /* CIL Label */ 
      {
#line 378
      sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%s",
              EnglishMonthName[m]);
#line 380
      tmp___28 = DBufPuts(dbuf, (char const   *)(s));
      }
#line 380
      if (tmp___28 != 0) {
#line 380
        return (9);
      }
#line 381
      goto switch_break___1;
      case_78: /* CIL Label */ 
      {
#line 387
      sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%d",
              m + 1);
#line 389
      tmp___29 = DBufPuts(dbuf, (char const   *)(s));
      }
#line 389
      if (tmp___29 != 0) {
#line 389
        return (9);
      }
#line 390
      goto switch_break___1;
      case_79: /* CIL Label */ 
#line 396
      if (RealToday == JulianToday) {
        {
#line 396
        sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)" (%s)",
                "today");
        }
      } else {
#line 397
        s[0] = (char)0;
      }
      {
#line 399
      tmp___30 = DBufPuts(dbuf, (char const   *)(s));
      }
#line 399
      if (tmp___30 != 0) {
#line 399
        return (9);
      }
#line 400
      goto switch_break___1;
      case_80: /* CIL Label */ 
#line 406
      if (diff == 1) {
#line 406
        tmp___31 = "";
      } else {
#line 406
        tmp___31 = "s";
      }
      {
#line 406
      sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%s",
              tmp___31);
#line 408
      tmp___32 = DBufPuts(dbuf, (char const   *)(s));
      }
#line 408
      if (tmp___32 != 0) {
#line 408
        return (9);
      }
#line 409
      goto switch_break___1;
      case_81: /* CIL Label */ 
#line 415
      if (diff == 1) {
#line 415
        tmp___33 = "\'s";
      } else {
#line 415
        tmp___33 = "s\'";
      }
      {
#line 415
      sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%s",
              tmp___33);
#line 417
      tmp___34 = DBufPuts(dbuf, (char const   *)(s));
      }
#line 417
      if (tmp___34 != 0) {
#line 417
        return (9);
      }
#line 418
      goto switch_break___1;
      case_82: /* CIL Label */ 
      {
#line 424
      sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%02d",
              d);
#line 426
      tmp___35 = DBufPuts(dbuf, (char const   *)(s));
      }
#line 426
      if (tmp___35 != 0) {
#line 426
        return (9);
      }
#line 427
      goto switch_break___1;
      case_83: /* CIL Label */ 
      {
#line 433
      sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%s",
              plu);
#line 435
      tmp___36 = DBufPuts(dbuf, (char const   *)(s));
      }
#line 435
      if (tmp___36 != 0) {
#line 435
        return (9);
      }
#line 436
      goto switch_break___1;
      case_84: /* CIL Label */ 
      {
#line 442
      sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%02d",
              m + 1);
#line 444
      tmp___37 = DBufPuts(dbuf, (char const   *)(s));
      }
#line 444
      if (tmp___37 != 0) {
#line 444
        return (9);
      }
#line 445
      goto switch_break___1;
      case_85___0: /* CIL Label */ 
#line 451
      if (altmode == 42) {
        {
#line 452
        sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%s, %d%s %s, %d",
                EnglishDayName[jul % 7], d, plu, EnglishMonthName[m], y);
        }
      } else {
        {
#line 455
        sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%s %s, %d%s %s, %d",
                "on", EnglishDayName[jul % 7], d, plu, EnglishMonthName[m], y);
        }
      }
      {
#line 459
      tmp___38 = DBufPuts(dbuf, (char const   *)(s));
      }
#line 459
      if (tmp___38 != 0) {
#line 459
        return (9);
      }
#line 460
      goto switch_break___1;
      case_86___0: /* CIL Label */ 
#line 466
      if (altmode == 42) {
        {
#line 467
        sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%s, %d%s %s",
                EnglishDayName[jul % 7], d, plu, EnglishMonthName[m]);
        }
      } else {
        {
#line 470
        sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%s %s, %d%s %s",
                "on", EnglishDayName[jul % 7], d, plu, EnglishMonthName[m]);
        }
      }
      {
#line 474
      tmp___39 = DBufPuts(dbuf, (char const   *)(s));
      }
#line 474
      if (tmp___39 != 0) {
#line 474
        return (9);
      }
#line 475
      goto switch_break___1;
      case_87: /* CIL Label */ 
      {
#line 481
      sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%s",
              EnglishDayName[jul % 7]);
#line 483
      tmp___40 = DBufPuts(dbuf, (char const   *)(s));
      }
#line 483
      if (tmp___40 != 0) {
#line 483
        return (9);
      }
#line 484
      goto switch_break___1;
      case_88: /* CIL Label */ 
      {
#line 490
      sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%d",
              diff);
#line 492
      tmp___41 = DBufPuts(dbuf, (char const   *)(s));
      }
#line 492
      if (tmp___41 != 0) {
#line 492
        return (9);
      }
#line 493
      goto switch_break___1;
      case_89: /* CIL Label */ 
      {
#line 499
      sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%d",
              y);
#line 501
      tmp___42 = DBufPuts(dbuf, (char const   *)(s));
      }
#line 501
      if (tmp___42 != 0) {
#line 501
        return (9);
      }
#line 502
      goto switch_break___1;
      case_90: /* CIL Label */ 
      {
#line 508
      sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%d",
              y % 100);
#line 510
      tmp___43 = DBufPuts(dbuf, (char const   *)(s));
      }
#line 510
      if (tmp___43 != 0) {
#line 510
        return (9);
      }
#line 511
      goto switch_break___1;
      case_49: /* CIL Label */ 
#line 517
      if (tdiff == 0) {
        {
#line 518
        sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%s",
                "now");
        }
      } else
#line 519
      if (hdiff == 0) {
        {
#line 520
        sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%d %s%s %s",
                mdiff, "minute", mplu, when);
        }
      } else
#line 521
      if (mdiff == 0) {
        {
#line 522
        sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%d %s%s %s",
                hdiff, "hour", hplu, when);
        }
      } else {
        {
#line 524
        sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%d %s%s %s %d %s%s %s",
                hdiff, "hour", hplu, "and", mdiff, "minute", mplu, when);
        }
      }
      {
#line 527
      tmp___44 = DBufPuts(dbuf, (char const   *)(s));
      }
#line 527
      if (tmp___44 != 0) {
#line 527
        return (9);
      }
#line 528
      goto switch_break___1;
      case_50: /* CIL Label */ 
#line 534
      if (altmode == 42) {
        {
#line 535
        sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%d%c%02d%s",
                hh, (int )TimeSep, min, pm);
        }
      } else {
        {
#line 537
        sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%s %d%c%02d%s",
                "at", hh, (int )TimeSep, min, pm);
        }
      }
      {
#line 540
      tmp___45 = DBufPuts(dbuf, (char const   *)(s));
      }
#line 540
      if (tmp___45 != 0) {
#line 540
        return (9);
      }
#line 541
      goto switch_break___1;
      case_51: /* CIL Label */ 
#line 548
      if (altmode == 42) {
        {
#line 549
        sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%02d%c%02d",
                h, (int )TimeSep, min);
        }
      } else {
        {
#line 551
        sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%s %02d%c%02d",
                "at", h, (int )TimeSep, min);
        }
      }
      {
#line 554
      tmp___46 = DBufPuts(dbuf, (char const   *)(s));
      }
#line 554
      if (tmp___46 != 0) {
#line 554
        return (9);
      }
#line 555
      goto switch_break___1;
      case_52: /* CIL Label */ 
      {
#line 561
      sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%d",
              tdiff);
#line 563
      tmp___47 = DBufPuts(dbuf, (char const   *)(s));
      }
#line 563
      if (tmp___47 != 0) {
#line 563
        return (9);
      }
#line 564
      goto switch_break___1;
      case_53: /* CIL Label */ 
      {
#line 570
      sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%d",
              adiff);
#line 572
      tmp___48 = DBufPuts(dbuf, (char const   *)(s));
      }
#line 572
      if (tmp___48 != 0) {
#line 572
        return (9);
      }
#line 573
      goto switch_break___1;
      case_54: /* CIL Label */ 
      {
#line 579
      sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%s",
              when);
#line 581
      tmp___49 = DBufPuts(dbuf, (char const   *)(s));
      }
#line 581
      if (tmp___49 != 0) {
#line 581
        return (9);
      }
#line 582
      goto switch_break___1;
      case_55: /* CIL Label */ 
      {
#line 588
      sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%d",
              hdiff);
#line 590
      tmp___50 = DBufPuts(dbuf, (char const   *)(s));
      }
#line 590
      if (tmp___50 != 0) {
#line 590
        return (9);
      }
#line 591
      goto switch_break___1;
      case_56: /* CIL Label */ 
      {
#line 597
      sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%d",
              mdiff);
#line 599
      tmp___51 = DBufPuts(dbuf, (char const   *)(s));
      }
#line 599
      if (tmp___51 != 0) {
#line 599
        return (9);
      }
#line 600
      goto switch_break___1;
      case_57: /* CIL Label */ 
      {
#line 606
      sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%s",
              mplu);
#line 608
      tmp___52 = DBufPuts(dbuf, (char const   *)(s));
      }
#line 608
      if (tmp___52 != 0) {
#line 608
        return (9);
      }
#line 609
      goto switch_break___1;
      case_48: /* CIL Label */ 
      {
#line 615
      sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%s",
              hplu);
#line 617
      tmp___53 = DBufPuts(dbuf, (char const   *)(s));
      }
#line 617
      if (tmp___53 != 0) {
#line 617
        return (9);
      }
#line 618
      goto switch_break___1;
      case_33: /* CIL Label */ 
#line 624
      if (tdiff >= 0) {
#line 624
        tmp___54 = "is";
      } else {
#line 624
        tmp___54 = "was";
      }
      {
#line 624
      sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%s",
              tmp___54);
#line 626
      tmp___55 = DBufPuts(dbuf, (char const   *)(s));
      }
#line 626
      if (tmp___55 != 0) {
#line 626
        return (9);
      }
#line 627
      goto switch_break___1;
      case_64: /* CIL Label */ 
      {
#line 633
      sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%d%c%02d%s",
              chh, (int )TimeSep, cmin, cpm);
#line 635
      tmp___56 = DBufPuts(dbuf, (char const   *)(s));
      }
#line 635
      if (tmp___56 != 0) {
#line 635
        return (9);
      }
#line 636
      goto switch_break___1;
      case_35: /* CIL Label */ 
      {
#line 642
      sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%02d%c%02d",
              ch, (int )TimeSep, cmin);
#line 644
      tmp___57 = DBufPuts(dbuf, (char const   *)(s));
      }
#line 644
      if (tmp___57 != 0) {
#line 644
        return (9);
      }
#line 645
      goto switch_break___1;
      case_95: /* CIL Label */ 
#line 648
      if (mode != 1) {
#line 648
        if (mode != 2) {
#line 648
          if (! MsgCommand) {
            {
#line 649
            sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"%s",
                    "\n");
            }
          } else {
            {
#line 651
            sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)" ");
            }
          }
        } else {
          {
#line 651
          sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)" ");
          }
        }
      } else {
        {
#line 651
        sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)" ");
        }
      }
      {
#line 652
      tmp___58 = DBufPuts(dbuf, (char const   *)(s));
      }
#line 652
      if (tmp___58 != 0) {
#line 652
        return (9);
      }
#line 653
      goto switch_break___1;
      case_1___0: /* CIL Label */ 
#line 657
      goto switch_break___1;
      case_34: /* CIL Label */ 
#line 660
      if (dbuf->allocatedLen < dbuf->len + 1) {
#line 660
        tmp___59 = dbuf->len;
#line 660
        (dbuf->len) ++;
#line 660
        *(dbuf->buffer + tmp___59) = (char)1;
#line 660
        *(dbuf->buffer + dbuf->len) = (char)0;
#line 660
        tmp___61 = 0;
      } else {
        {
#line 660
        tmp___60 = DBufPutcFN(dbuf, (char)1);
#line 660
        tmp___61 = tmp___60 != 0;
        }
      }
#line 660
      if (tmp___61) {
#line 660
        return (9);
      }
#line 661
      has_quote = 1;
#line 662
      goto switch_break___1;
      switch_default___1: /* CIL Label */ 
#line 665
      if (dbuf->allocatedLen < dbuf->len + 1) {
#line 665
        tmp___62 = dbuf->len;
#line 665
        (dbuf->len) ++;
#line 665
        *(dbuf->buffer + tmp___62) = (char )c;
#line 665
        *(dbuf->buffer + dbuf->len) = (char)0;
#line 665
        tmp___64 = 0;
      } else {
        {
#line 665
        tmp___63 = DBufPutcFN(dbuf, (char )c);
#line 665
        tmp___64 = tmp___63 != 0;
        }
      }
#line 665
      if (tmp___64) {
#line 665
        return (9);
      }
      switch_break___1: /* CIL Label */ ;
      }
    }
    {
#line 667
    tmp___70 = __ctype_b_loc();
    }
#line 667
    if ((int const   )*(*tmp___70 + c) & 256) {
      {
#line 668
      os = dbuf->buffer;
#line 669
      tmp___65 = strlen((char const   *)os);
#line 669
      tmp___66 = strlen((char const   *)(s));
#line 669
      os += tmp___65 - tmp___66;
      }
#line 670
      if ((unsigned long )os >= (unsigned long )dbuf->buffer) {
        {
#line 671
        tmp___69 = __ctype_b_loc();
        }
#line 671
        if ((int const   )*(*tmp___69 + (int )*os) & 512) {
          {
#line 671
          tmp___68 = toupper((int )*os);
#line 671
          *os = (char )tmp___68;
          }
        } else {
#line 671
          *os = *os;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 683
  if (! has_quote) {
#line 684
    if (mode == 2) {
#line 684
      goto _L;
    } else
#line 684
    if (mode == 1) {
      _L: /* CIL Label */ 
#line 684
      if (t->typ == 2) {
#line 685
        *(dbuf->buffer) = (char)0;
#line 686
        dbuf->len = 0;
      }
    }
#line 688
    return (0);
  }
#line 694
  ss = dbuf->buffer + origLen;
#line 695
  os = ss;
#line 696
  if (mode == 0) {
#line 696
    goto _L___0;
  } else
#line 696
  if (mode == 2) {
    _L___0: /* CIL Label */ 
    {
#line 697
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 697
      if (! *ss) {
#line 697
        goto while_break___0;
      }
#line 698
      if ((int )*ss != 1) {
#line 698
        tmp___71 = os;
#line 698
        os ++;
#line 698
        *tmp___71 = *ss;
      }
#line 699
      ss ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 701
    *os = (char)0;
  } else {
    {
#line 704
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 704
      if (*ss) {
#line 704
        if (! ((int )*ss != 1)) {
#line 704
          goto while_break___1;
        }
      } else {
#line 704
        goto while_break___1;
      }
#line 704
      ss ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 708
    if (*ss) {
#line 708
      ss ++;
    }
    {
#line 711
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 711
      if (*ss) {
#line 711
        if (! ((int )*ss != 1)) {
#line 711
          goto while_break___2;
        }
      } else {
#line 711
        goto while_break___2;
      }
#line 711
      tmp___72 = os;
#line 711
      os ++;
#line 711
      tmp___73 = ss;
#line 711
      ss ++;
#line 711
      *tmp___72 = *tmp___73;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 712
    *os = (char)0;
  }
  {
#line 716
  tmp___74 = strlen((char const   *)dbuf->buffer);
#line 716
  dbuf->len = (int )tmp___74;
  }
#line 718
  return (0);
}
}
#line 731 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/dosubst.c"
int DoSubstFromString(char const   *source , DynamicBuffer *dbuf , int jul , int tim ) 
{ 
  Trigger tempTrig ;
  TimeTrig tempTime ;
  Parser tempP ;
  int r ;
  long tmp ;

  {
#line 739
  if (jul == -1) {
#line 739
    jul = JulianToday;
  }
#line 740
  if (tim == 2147483647) {
    {
#line 740
    tmp = SystemTime(0);
#line 740
    tim = (int )(tmp / 60L);
    }
  }
  {
#line 741
  CreateParser(source, & tempP);
#line 742
  tempP.allownested = (char)0;
#line 743
  tempTrig.typ = 1;
#line 744
  tempTime.ttime = tim;
#line 746
  r = DoSubst(& tempP, dbuf, & tempTrig, & tempTime, jul, 0);
#line 747
  DestroyParser(& tempP);
  }
#line 748
  return (r);
}
}
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 754
extern long ftell(FILE *__stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 413 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 214
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 243 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 678 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 146 "/usr/include/glob.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) glob)(char const   * __restrict  __pattern ,
                                                                           int __flags ,
                                                                           int (*__errfunc)(char const   * ,
                                                                                            int  ) ,
                                                                           glob_t * __restrict  __pglob ) ;
#line 151
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) globfree)(glob_t *__pglob ) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/dynbuf.h"
int DBufGets(DynamicBuffer *dbuf , FILE *fp___0 ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/protos.h"
int ReadLine(void) ;
#line 43
int OpenFile(char const   *fname ) ;
#line 44
int DoInclude(ParsePtr p ) ;
#line 45
int IncludeFile(char const   *fname ) ;
#line 46
int GetAccessDate(char const   *file ) ;
#line 48
int TopLevel(void) ;
#line 52
int Julian(int year , int month , int day ) ;
#line 61
void OutputLine(FILE *fp___0 ) ;
#line 72
int VerifyEoln(ParsePtr p ) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int LineNo ;
#line 80
char *FileName ;
#line 83
int PurgeIncludeDepth ;
#line 85
FILE *PurgeFP ;
#line 86
int NumIfs ;
#line 87
unsigned int IfFlags ;
#line 91
int ShouldCache ;
#line 92
char const   *CurLine ;
#line 129
DynamicBuffer LineBuffer ;
#line 86 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/files.c"
static CachedFile *CachedFiles  =    (CachedFile *)((void *)0);
#line 87 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/files.c"
static CachedLine *CLine  =    (CachedLine *)((void *)0);
#line 88 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/files.c"
static DirectoryFilenameChain *CachedDirectoryChains  =    (DirectoryFilenameChain *)((void *)0);
#line 90 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/files.c"
static FILE *fp  ;
#line 92 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/files.c"
static IncludeStruct IStack[9]  ;
#line 93 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/files.c"
static int IStackPtr  =    0;
#line 95
static int ReadLineFromFile(void) ;
#line 96
static int CacheFile(char const   *fname ) ;
#line 97
static void DestroyCache(CachedFile *cf ) ;
#line 98
static int CheckSafety(void) ;
#line 99
static int PopFile(void) ;
#line 101 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/files.c"
static void OpenPurgeFile(char const   *fname , char const   *mode ) 
{ 
  DynamicBuffer fname_buf ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
#line 105
  if ((unsigned long )PurgeFP != (unsigned long )((void *)0)) {
#line 105
    if ((unsigned long )PurgeFP != (unsigned long )stdout) {
      {
#line 106
      fclose(PurgeFP);
      }
    }
  }
#line 108
  PurgeFP = (FILE *)((void *)0);
#line 112
  if (IStackPtr - 2 >= PurgeIncludeDepth) {
#line 113
    PurgeFP = (FILE *)((void *)0);
#line 114
    return;
  }
  {
#line 117
  DBufInit(& fname_buf);
#line 118
  tmp = DBufPuts(& fname_buf, fname);
  }
#line 118
  if (tmp != 0) {
#line 118
    return;
  }
  {
#line 119
  tmp___0 = DBufPuts(& fname_buf, ".purged");
  }
#line 119
  if (tmp___0 != 0) {
#line 119
    return;
  }
  {
#line 120
  PurgeFP = fopen((char const   */* __restrict  */)fname_buf.buffer, (char const   */* __restrict  */)mode);
  }
#line 121
  if (! PurgeFP) {
    {
#line 122
    tmp___1 = __errno_location();
#line 122
    tmp___2 = strerror(*tmp___1);
#line 122
    fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"Cannot open `%s\' for writing: %s\n",
            fname_buf.buffer, tmp___2);
    }
  }
  {
#line 124
  DBufFree(& fname_buf);
  }
#line 125
  return;
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/files.c"
static void FreeChainItem(FilenameChain *chain ) 
{ 


  {
#line 129
  if (chain->filename) {
    {
#line 129
    free((void *)chain->filename);
    }
  }
  {
#line 130
  free((void *)chain);
  }
#line 131
  return;
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/files.c"
static void FreeChain(FilenameChain *chain ) 
{ 
  FilenameChain *next ;

  {
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    if (! chain) {
#line 136
      goto while_break;
    }
    {
#line 137
    next = chain->next;
#line 138
    FreeChainItem(chain);
#line 139
    chain = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 141
  return;
}
}
#line 150 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/files.c"
int ReadLine(void) 
{ 
  int r ;
  int tmp ;

  {
  {
#line 155
  while (1) {
    while_continue: /* CIL Label */ ;
#line 155
    if (! CLine) {
#line 155
      if (! (! fp)) {
#line 155
        goto while_break;
      }
    } else {
#line 155
      goto while_break;
    }
    {
#line 156
    r = PopFile();
    }
#line 157
    if (r) {
#line 157
      return (r);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 161
  if (CLine) {
#line 162
    CurLine = CLine->text;
#line 163
    LineNo = CLine->LineNo;
#line 164
    CLine = CLine->next;
#line 165
    FreshLine = 1;
#line 166
    if (DebugFlag & 16) {
      {
#line 166
      OutputLine(ErrFp);
      }
    }
#line 167
    return (0);
  }
  {
#line 171
  tmp = ReadLineFromFile();
  }
#line 171
  return (tmp);
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/files.c"
static int ReadLineFromFile(void) 
{ 
  int l ;
  DynamicBuffer buf___1 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 187
  DBufInit(& buf___1);
#line 188
  DBufFree(& LineBuffer);
  }
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;
#line 190
    if (! fp) {
#line 190
      goto while_break;
    }
    {
#line 191
    tmp = DBufGets(& buf___1, fp);
    }
#line 191
    if (tmp != 0) {
      {
#line 192
      DBufFree(& LineBuffer);
      }
#line 193
      return (9);
    }
    {
#line 195
    LineNo ++;
#line 196
    tmp___0 = ferror(fp);
    }
#line 196
    if (tmp___0) {
      {
#line 197
      DBufFree(& buf___1);
#line 198
      DBufFree(& LineBuffer);
      }
#line 199
      return (21);
    }
    {
#line 201
    tmp___1 = feof(fp);
    }
#line 201
    if (tmp___1) {
#line 202
      if (fp) {
#line 202
        if ((unsigned long )fp != (unsigned long )stdin) {
          {
#line 202
          fclose(fp);
#line 202
          fp = (FILE *)((void *)0);
          }
        } else {
#line 202
          fp = (FILE *)((void *)0);
        }
      } else {
#line 202
        fp = (FILE *)((void *)0);
      }
#line 203
      if (buf___1.len == 0) {
#line 203
        if (LineBuffer.len == 0) {
#line 203
          if (PurgeMode) {
#line 205
            if ((unsigned long )PurgeFP != (unsigned long )((void *)0)) {
#line 205
              if ((unsigned long )PurgeFP != (unsigned long )stdout) {
                {
#line 205
                fclose(PurgeFP);
                }
              }
            }
#line 206
            PurgeFP = (FILE *)((void *)0);
          }
        }
      }
    }
#line 209
    l = buf___1.len;
#line 210
    if (l) {
#line 210
      if ((int )*(buf___1.buffer + (l - 1)) == 92) {
#line 211
        if (PurgeMode) {
          {
#line 212
          tmp___2 = DBufPuts(& LineBuffer, (char const   *)buf___1.buffer);
          }
#line 212
          if (tmp___2 != 0) {
            {
#line 213
            DBufFree(& buf___1);
#line 214
            DBufFree(& LineBuffer);
            }
#line 215
            return (9);
          }
#line 217
          if (LineBuffer.allocatedLen < LineBuffer.len + 1) {
#line 217
            tmp___3 = LineBuffer.len;
#line 217
            (LineBuffer.len) ++;
#line 217
            *(LineBuffer.buffer + tmp___3) = (char )'\n';
#line 217
            *(LineBuffer.buffer + LineBuffer.len) = (char)0;
#line 217
            tmp___5 = 0;
          } else {
            {
#line 217
            tmp___4 = DBufPutcFN(& LineBuffer, (char )'\n');
#line 217
            tmp___5 = tmp___4 != 0;
            }
          }
#line 217
          if (tmp___5) {
            {
#line 218
            DBufFree(& buf___1);
#line 219
            DBufFree(& LineBuffer);
            }
#line 220
            return (9);
          }
        } else {
          {
#line 223
          *(buf___1.buffer + (l - 1)) = (char )'\n';
#line 224
          tmp___6 = DBufPuts(& LineBuffer, (char const   *)buf___1.buffer);
          }
#line 224
          if (tmp___6 != 0) {
            {
#line 225
            DBufFree(& buf___1);
#line 226
            DBufFree(& LineBuffer);
            }
#line 227
            return (9);
          }
        }
#line 230
        goto while_continue;
      }
    }
    {
#line 232
    tmp___7 = DBufPuts(& LineBuffer, (char const   *)buf___1.buffer);
    }
#line 232
    if (tmp___7 != 0) {
      {
#line 233
      DBufFree(& buf___1);
#line 234
      DBufFree(& LineBuffer);
      }
#line 235
      return (9);
    }
#line 237
    FreshLine = 1;
#line 238
    CurLine = (char const   *)LineBuffer.buffer;
#line 239
    if (DebugFlag & 16) {
      {
#line 239
      OutputLine(ErrFp);
      }
    }
#line 240
    return (0);
  }
  while_break: /* CIL Label */ ;
  }
#line 242
  CurLine = (char const   *)LineBuffer.buffer;
#line 243
  return (0);
}
}
#line 255 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/files.c"
int OpenFile(char const   *fname ) 
{ 
  CachedFile *h ;
  int r ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 257
  h = CachedFiles;
#line 260
  if (PurgeMode) {
#line 261
    if ((unsigned long )PurgeFP != (unsigned long )((void *)0)) {
#line 261
      if ((unsigned long )PurgeFP != (unsigned long )stdout) {
        {
#line 262
        fclose(PurgeFP);
        }
      }
    }
#line 264
    PurgeFP = (FILE *)((void *)0);
  }
#line 268
  RunDisabled &= -5;
  {
#line 272
  while (1) {
    while_continue: /* CIL Label */ ;
#line 272
    if (! h) {
#line 272
      goto while_break;
    }
    {
#line 273
    tmp = strcmp(fname, h->filename);
    }
#line 273
    if (! tmp) {
#line 274
      if (DebugFlag & 32) {
        {
#line 275
        fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"Reading `%s\': Found in cache\n",
                fname);
        }
      }
#line 277
      CLine = h->cache;
#line 278
      if (FileName) {
        {
#line 278
        free((void *)FileName);
        }
      }
      {
#line 278
      FileName = StrDup(fname);
#line 279
      LineNo = 0;
      }
#line 280
      if (! h->ownedByMe) {
#line 281
        RunDisabled |= 4;
      }
#line 283
      if (FileName) {
#line 283
        return (0);
      } else {
#line 283
        return (9);
      }
    }
#line 285
    h = h->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 289
  tmp___0 = strcmp(fname, "-");
  }
#line 289
  if (tmp___0) {
    {
#line 298
    fp = fopen((char const   */* __restrict  */)fname, (char const   */* __restrict  */)"r");
    }
#line 299
    if (DebugFlag & 32) {
      {
#line 300
      fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"Reading `%s\': Opening file on disk\n",
              fname);
      }
    }
#line 302
    if (PurgeMode) {
      {
#line 303
      OpenPurgeFile(fname, "w");
      }
    }
  } else {
#line 290
    fp = stdin;
#line 291
    if (PurgeMode) {
#line 292
      PurgeFP = stdout;
    }
#line 294
    if (DebugFlag & 32) {
      {
#line 295
      fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"Reading `-\': Reading stdin\n");
      }
    }
  }
#line 306
  if (! fp) {
#line 306
    return (30);
  } else {
    {
#line 306
    tmp___1 = CheckSafety();
    }
#line 306
    if (! tmp___1) {
#line 306
      return (30);
    }
  }
#line 307
  CLine = (CachedLine *)((void *)0);
#line 308
  if (ShouldCache) {
    {
#line 309
    LineNo = 0;
#line 310
    r = CacheFile(fname);
    }
#line 311
    if (r == 0) {
#line 312
      fp = (FILE *)((void *)0);
#line 313
      CLine = CachedFiles->cache;
    } else {
      {
#line 315
      tmp___3 = strcmp(fname, "-");
      }
#line 315
      if (tmp___3) {
        {
#line 316
        fp = fopen((char const   */* __restrict  */)fname, (char const   */* __restrict  */)"r");
        }
#line 317
        if (! fp) {
#line 317
          return (30);
        } else {
          {
#line 317
          tmp___2 = CheckSafety();
          }
#line 317
          if (! tmp___2) {
#line 317
            return (30);
          }
        }
#line 318
        if (PurgeMode) {
          {
#line 318
          OpenPurgeFile(fname, "w");
          }
        }
      } else {
#line 320
        fp = stdin;
#line 321
        if (PurgeMode) {
#line 321
          PurgeFP = stdout;
        }
      }
    }
  }
#line 325
  if (FileName) {
    {
#line 325
    free((void *)FileName);
    }
  }
  {
#line 325
  FileName = StrDup(fname);
#line 326
  LineNo = 0;
  }
#line 327
  if (FileName) {
#line 327
    return (0);
  } else {
#line 327
    return (9);
  }
}
}
#line 338 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/files.c"
static int CacheFile(char const   *fname ) 
{ 
  int r ;
  CachedFile *cf ;
  CachedLine *cl ;
  char const   *s ;
  void *tmp ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;

  {
#line 345
  if (DebugFlag & 32) {
    {
#line 346
    fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"Caching file `%s\' in memory\n",
            fname);
    }
  }
  {
#line 348
  cl = (CachedLine *)((void *)0);
#line 350
  tmp = malloc(sizeof(CachedFile ));
#line 350
  cf = (CachedFile *)tmp;
#line 351
  cf->cache = (CachedLine *)((void *)0);
  }
#line 352
  if (! cf) {
#line 353
    ShouldCache = 0;
#line 354
    if (fp) {
#line 354
      if ((unsigned long )fp != (unsigned long )stdin) {
        {
#line 354
        fclose(fp);
#line 354
        fp = (FILE *)((void *)0);
        }
      } else {
#line 354
        fp = (FILE *)((void *)0);
      }
    } else {
#line 354
      fp = (FILE *)((void *)0);
    }
#line 355
    return (9);
  }
  {
#line 357
  tmp___0 = StrDup(fname);
#line 357
  cf->filename = (char const   *)tmp___0;
  }
#line 358
  if (! cf->filename) {
#line 359
    ShouldCache = 0;
#line 360
    if (fp) {
#line 360
      if ((unsigned long )fp != (unsigned long )stdin) {
        {
#line 360
        fclose(fp);
#line 360
        fp = (FILE *)((void *)0);
        }
      } else {
#line 360
        fp = (FILE *)((void *)0);
      }
    } else {
#line 360
      fp = (FILE *)((void *)0);
    }
    {
#line 361
    free((void *)cf);
    }
#line 362
    return (9);
  }
#line 365
  if (RunDisabled & 4) {
#line 366
    cf->ownedByMe = 0;
  } else {
#line 368
    cf->ownedByMe = 1;
  }
  {
#line 372
  while (1) {
    while_continue: /* CIL Label */ ;
#line 372
    if (! fp) {
#line 372
      goto while_break;
    }
    {
#line 373
    r = ReadLineFromFile();
    }
#line 374
    if (r) {
      {
#line 375
      DestroyCache(cf);
#line 376
      ShouldCache = 0;
      }
#line 377
      if (fp) {
#line 377
        if ((unsigned long )fp != (unsigned long )stdin) {
          {
#line 377
          fclose(fp);
#line 377
          fp = (FILE *)((void *)0);
          }
        } else {
#line 377
          fp = (FILE *)((void *)0);
        }
      } else {
#line 377
        fp = (FILE *)((void *)0);
      }
#line 378
      return (r);
    }
#line 381
    s = (char const   *)LineBuffer.buffer;
    {
#line 382
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 382
      tmp___1 = __ctype_b_loc();
      }
#line 382
      if (! ((int const   )*(*tmp___1 + (int )*s) & 8192)) {
#line 382
        if (! ((int const   )*s == 92)) {
#line 382
          goto while_break___0;
        }
      }
#line 382
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 383
    if (*s) {
#line 383
      if ((int const   )*s != 59) {
#line 383
        if ((int const   )*s != 35) {
#line 385
          if (! cl) {
            {
#line 386
            tmp___2 = malloc(sizeof(CachedLine ));
#line 386
            cf->cache = (CachedLine *)tmp___2;
            }
#line 387
            if (! cf->cache) {
              {
#line 388
              DBufFree(& LineBuffer);
#line 389
              DestroyCache(cf);
#line 390
              ShouldCache = 0;
              }
#line 391
              if (fp) {
#line 391
                if ((unsigned long )fp != (unsigned long )stdin) {
                  {
#line 391
                  fclose(fp);
#line 391
                  fp = (FILE *)((void *)0);
                  }
                } else {
#line 391
                  fp = (FILE *)((void *)0);
                }
              } else {
#line 391
                fp = (FILE *)((void *)0);
              }
#line 392
              return (9);
            }
#line 394
            cl = cf->cache;
          } else {
            {
#line 396
            tmp___3 = malloc(sizeof(CachedLine ));
#line 396
            cl->next = (struct cache *)tmp___3;
            }
#line 397
            if (! cl->next) {
              {
#line 398
              DBufFree(& LineBuffer);
#line 399
              DestroyCache(cf);
#line 400
              ShouldCache = 0;
              }
#line 401
              if (fp) {
#line 401
                if ((unsigned long )fp != (unsigned long )stdin) {
                  {
#line 401
                  fclose(fp);
#line 401
                  fp = (FILE *)((void *)0);
                  }
                } else {
#line 401
                  fp = (FILE *)((void *)0);
                }
              } else {
#line 401
                fp = (FILE *)((void *)0);
              }
#line 402
              return (9);
            }
#line 404
            cl = cl->next;
          }
          {
#line 406
          cl->next = (struct cache *)((void *)0);
#line 407
          cl->LineNo = LineNo;
#line 408
          tmp___4 = StrDup(s);
#line 408
          cl->text = (char const   *)tmp___4;
#line 409
          DBufFree(& LineBuffer);
          }
#line 410
          if (! cl->text) {
            {
#line 411
            DestroyCache(cf);
#line 412
            ShouldCache = 0;
            }
#line 413
            if (fp) {
#line 413
              if ((unsigned long )fp != (unsigned long )stdin) {
                {
#line 413
                fclose(fp);
#line 413
                fp = (FILE *)((void *)0);
                }
              } else {
#line 413
                fp = (FILE *)((void *)0);
              }
            } else {
#line 413
              fp = (FILE *)((void *)0);
            }
#line 414
            return (9);
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 420
  cf->next = CachedFiles;
#line 421
  CachedFiles = cf;
#line 423
  return (0);
}
}
#line 432 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/files.c"
static int NextChainedFile(IncludeStruct *i ) 
{ 
  FilenameChain *cur ;
  int tmp ;

  {
  {
#line 434
  while (1) {
    while_continue: /* CIL Label */ ;
#line 434
    if (! i->chain) {
#line 434
      goto while_break;
    }
    {
#line 435
    cur = i->chain;
#line 436
    i->chain = (i->chain)->next;
#line 437
    tmp = OpenFile(cur->filename);
    }
#line 437
    if (tmp == 0) {
#line 438
      return (0);
    } else {
      {
#line 440
      Eprint("%s: %s", ErrMsg[30], cur->filename);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 443
  return (20);
}
}
#line 452 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/files.c"
static int PopFile(void) 
{ 
  IncludeStruct *i ;
  int oldRunDisabled ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 457
  RunDisabled &= -5;
#line 459
  if (! Hush) {
#line 459
    if (NumIfs) {
      {
#line 459
      Eprint("%s", ErrMsg[62]);
      }
    }
  }
#line 460
  if (! IStackPtr) {
#line 460
    return (20);
  }
#line 461
  i = & IStack[IStackPtr - 1];
#line 463
  if (i->chain) {
    {
#line 464
    oldRunDisabled = RunDisabled;
#line 465
    tmp = NextChainedFile(i);
    }
#line 465
    if (tmp == 0) {
#line 466
      return (0);
    }
#line 468
    RunDisabled = oldRunDisabled;
  }
#line 471
  if (IStackPtr <= 1) {
#line 472
    return (20);
  }
#line 475
  IStackPtr --;
#line 477
  LineNo = i->LineNo;
#line 478
  IfFlags = i->IfFlags;
#line 479
  NumIfs = i->NumIfs;
#line 480
  CLine = i->CLine;
#line 481
  fp = (FILE *)((void *)0);
#line 482
  if (FileName) {
    {
#line 482
    free((void *)FileName);
    }
  }
  {
#line 482
  FileName = StrDup(i->filename);
  }
#line 483
  if (! i->ownedByMe) {
#line 484
    RunDisabled |= 4;
  }
#line 486
  if (! CLine) {
#line 486
    if (i->offset != -1L) {
      {
#line 488
      tmp___1 = strcmp(i->filename, "-");
      }
#line 488
      if (tmp___1) {
        {
#line 489
        fp = fopen((char const   */* __restrict  */)i->filename, (char const   */* __restrict  */)"r");
        }
#line 490
        if (! fp) {
#line 490
          return (30);
        } else {
          {
#line 490
          tmp___0 = CheckSafety();
          }
#line 490
          if (! tmp___0) {
#line 490
            return (30);
          }
        }
#line 491
        if (PurgeMode) {
          {
#line 491
          OpenPurgeFile(i->filename, "a");
          }
        }
      } else {
#line 493
        fp = stdin;
#line 494
        if (PurgeMode) {
#line 494
          PurgeFP = stdout;
        }
      }
#line 496
      if ((unsigned long )fp != (unsigned long )stdin) {
        {
#line 497
        fseek(fp, i->offset, 0);
        }
      }
    }
  }
  {
#line 499
  free((void *)((char *)i->filename));
  }
#line 500
  return (0);
}
}
#line 510 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/files.c"
int DoInclude(ParsePtr p ) 
{ 
  DynamicBuffer buf___1 ;
  int r ;
  int e ;

  {
  {
#line 515
  DBufInit(& buf___1);
#line 516
  r = ParseToken(p, & buf___1);
  }
#line 516
  if (r) {
#line 516
    return (r);
  }
  {
#line 517
  e = VerifyEoln(p);
  }
#line 518
  if (e) {
    {
#line 518
    Eprint("%s", ErrMsg[e]);
    }
  }
  {
#line 519
  r = IncludeFile((char const   *)buf___1.buffer);
  }
#line 519
  if (r) {
    {
#line 520
    DBufFree(& buf___1);
    }
#line 521
    return (r);
  }
  {
#line 523
  DBufFree(& buf___1);
#line 524
  NumIfs = 0;
#line 525
  IfFlags = 0U;
  }
#line 526
  return (0);
}
}
#line 530 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/files.c"
static int SetupGlobChain(char const   *dirname , IncludeStruct *i ) 
{ 
  DynamicBuffer pattern ;
  char *dir ;
  size_t l ;
  int r ;
  glob_t glob_buf ;
  DirectoryFilenameChain *dc ;
  int tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  FilenameChain *ch ;
  void *tmp___2 ;
  char *tmp___3 ;

  {
#line 537
  dc = CachedDirectoryChains;
#line 539
  i->chain = (FilenameChain *)((void *)0);
#line 540
  if (! *dirname) {
#line 540
    return (30);
  }
  {
#line 542
  dir = StrDup(dirname);
  }
#line 543
  if (! dir) {
#line 543
    return (9);
  }
  {
#line 546
  l = strlen((char const   *)dir);
  }
  {
#line 547
  while (1) {
    while_continue: /* CIL Label */ ;
#line 547
    if (! l) {
#line 547
      goto while_break;
    }
#line 548
    if ((int )*((dir + l) - 1) == 47) {
#line 549
      l --;
#line 550
      *(dir + l) = (char)0;
    } else {
#line 552
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 557
  if (! l) {
#line 558
    *dir = (char )'/';
  }
  {
#line 562
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 562
    if (! dc) {
#line 562
      goto while_break___0;
    }
    {
#line 563
    tmp = strcmp(dc->dirname, (char const   *)dir);
    }
#line 563
    if (! tmp) {
#line 564
      if (DebugFlag & 32) {
        {
#line 565
        fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"Found cached directory listing for `%s\'\n",
                dir);
        }
      }
      {
#line 568
      free((void *)dir);
#line 569
      i->chain = dc->chain;
      }
#line 570
      return (0);
    }
#line 572
    dc = dc->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 575
  if (DebugFlag & 32) {
    {
#line 576
    fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"Scanning directory `%s\' for *.rem files\n",
            dir);
    }
  }
#line 579
  if (ShouldCache) {
    {
#line 580
    tmp___0 = malloc(sizeof(DirectoryFilenameChain ));
#line 580
    dc = (DirectoryFilenameChain *)tmp___0;
    }
#line 581
    if (dc) {
      {
#line 582
      tmp___1 = StrDup((char const   *)dir);
#line 582
      dc->dirname = (char const   *)tmp___1;
      }
#line 583
      if (! dc->dirname) {
        {
#line 584
        free((void *)dc);
#line 585
        dc = (DirectoryFilenameChain *)((void *)0);
        }
      }
    }
#line 588
    if (dc) {
#line 589
      if (DebugFlag & 32) {
        {
#line 590
        fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"Caching directory `%s\' listing\n",
                dir);
        }
      }
#line 593
      dc->chain = (FilenameChain *)((void *)0);
#line 594
      dc->next = CachedDirectoryChains;
#line 595
      CachedDirectoryChains = dc;
    }
  }
  {
#line 599
  DBufInit(& pattern);
#line 600
  DBufPuts(& pattern, (char const   *)dir);
#line 601
  DBufPuts(& pattern, "/*.rem");
#line 602
  free((void *)dir);
#line 604
  r = glob((char const   */* __restrict  */)pattern.buffer, 0, (int (*)(char const   * ,
                                                                        int  ))((void *)0),
           (glob_t */* __restrict  */)(& glob_buf));
#line 605
  DBufFree(& pattern);
  }
#line 607
  if (r == 3) {
    {
#line 608
    globfree(& glob_buf);
    }
#line 609
    return (0);
  }
#line 612
  if (r != 0) {
    {
#line 613
    globfree(& glob_buf);
    }
#line 614
    return (-1);
  }
#line 618
  r = (int )(glob_buf.gl_pathc - 1UL);
  {
#line 618
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 618
    if (! (r >= 0)) {
#line 618
      goto while_break___1;
    }
    {
#line 619
    tmp___2 = malloc(sizeof(FilenameChain ));
#line 619
    ch = (FilenameChain *)tmp___2;
    }
#line 620
    if (! ch) {
      {
#line 621
      globfree(& glob_buf);
#line 622
      FreeChain(i->chain);
#line 623
      i->chain = (FilenameChain *)((void *)0);
      }
#line 624
      return (9);
    }
    {
#line 629
    tmp___3 = StrDup((char const   *)*(glob_buf.gl_pathv + r));
#line 629
    ch->filename = (char const   *)tmp___3;
    }
#line 630
    if (! ch->filename) {
      {
#line 631
      globfree(& glob_buf);
#line 632
      FreeChain(i->chain);
#line 633
      i->chain = (FilenameChain *)((void *)0);
#line 634
      free((void *)ch);
      }
#line 635
      return (9);
    }
#line 637
    ch->next = i->chain;
#line 638
    i->chain = ch;
#line 618
    r --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 640
  if (dc) {
#line 641
    dc->chain = i->chain;
  }
  {
#line 644
  globfree(& glob_buf);
  }
#line 645
  return (0);
}
}
#line 657 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/files.c"
int IncludeFile(char const   *fname ) 
{ 
  IncludeStruct *i ;
  int oldRunDisabled ;
  struct stat statbuf ;
  char *tmp ;
  FilenameChain *fc ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 663
  FreshLine = 1;
#line 664
  if (IStackPtr + 1 >= 9) {
#line 664
    return (31);
  }
#line 665
  i = & IStack[IStackPtr];
#line 667
  if (FileName) {
    {
#line 668
    tmp = StrDup((char const   *)FileName);
#line 668
    i->filename = (char const   *)tmp;
    }
#line 669
    if (! i->filename) {
#line 669
      return (9);
    }
  } else {
#line 671
    i->filename = (char const   *)((void *)0);
  }
#line 673
  i->LineNo = LineNo;
#line 674
  i->NumIfs = NumIfs;
#line 675
  i->IfFlags = IfFlags;
#line 676
  i->CLine = CLine;
#line 677
  i->offset = -1L;
#line 678
  i->chain = (FilenameChain *)((void *)0);
#line 679
  if (RunDisabled & 4) {
#line 680
    i->ownedByMe = 0;
  } else {
#line 682
    i->ownedByMe = 1;
  }
#line 684
  if (fp) {
    {
#line 685
    i->offset = ftell(fp);
    }
#line 686
    if (fp) {
#line 686
      if ((unsigned long )fp != (unsigned long )stdin) {
        {
#line 686
        fclose(fp);
#line 686
        fp = (FILE *)((void *)0);
        }
      } else {
#line 686
        fp = (FILE *)((void *)0);
      }
    } else {
#line 686
      fp = (FILE *)((void *)0);
    }
  }
  {
#line 689
  IStackPtr ++;
#line 693
  tmp___3 = stat((char const   */* __restrict  */)fname, (struct stat */* __restrict  */)(& statbuf));
  }
#line 693
  if (tmp___3 == 0) {
#line 695
    if ((statbuf.st_mode & 61440U) == 16384U) {
      {
#line 696
      tmp___2 = SetupGlobChain(fname, i);
      }
#line 696
      if (tmp___2 == 0) {
#line 697
        if (! i->chain) {
#line 698
          if (! Hush) {
            {
#line 699
            Eprint("%s: %s", fname, ErrMsg[100]);
            }
          }
          {
#line 701
          PopFile();
          }
#line 702
          return (100);
        }
        {
#line 704
        while (1) {
          while_continue: /* CIL Label */ ;
#line 704
          if (! i->chain) {
#line 704
            goto while_break;
          }
          {
#line 705
          fc = i->chain;
#line 706
          i->chain = (i->chain)->next;
#line 709
          oldRunDisabled = RunDisabled;
#line 710
          tmp___0 = OpenFile(fc->filename);
          }
#line 710
          if (! tmp___0) {
#line 711
            return (0);
          }
          {
#line 713
          Eprint("%s: %s", ErrMsg[30], fc->filename);
#line 714
          RunDisabled = oldRunDisabled;
          }
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 717
        tmp___1 = PopFile();
        }
#line 717
        return (tmp___1);
      } else
#line 719
      if (! Hush) {
        {
#line 720
        Eprint("%s: %s", fname, ErrMsg[100]);
        }
      }
#line 723
      return (100);
    }
  }
  {
#line 728
  oldRunDisabled = RunDisabled;
#line 730
  tmp___4 = OpenFile(fname);
  }
#line 730
  if (! tmp___4) {
#line 731
    return (0);
  }
  {
#line 733
  RunDisabled = oldRunDisabled;
#line 734
  Eprint("%s: %s", ErrMsg[30], fname);
#line 736
  PopFile();
  }
#line 737
  return (30);
}
}
#line 745 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/files.c"
int GetAccessDate(char const   *file ) 
{ 
  struct stat statbuf ;
  struct tm *t1 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 750
  tmp = stat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& statbuf));
  }
#line 750
  if (tmp) {
#line 750
    return (-1);
  }
  {
#line 751
  t1 = localtime((time_t const   *)(& statbuf.st_atim.tv_sec));
  }
#line 753
  if (t1->tm_year + 1900 < 1990) {
#line 754
    return (0);
  } else {
    {
#line 756
    tmp___0 = Julian(t1->tm_year + 1900, t1->tm_mon, t1->tm_mday);
    }
#line 756
    return (tmp___0);
  }
}
}
#line 766 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/files.c"
static void DestroyCache(CachedFile *cf ) 
{ 
  CachedLine *cl ;
  CachedLine *cnext ;
  CachedFile *temp ;

  {
#line 770
  if (cf->filename) {
    {
#line 770
    free((void *)((char *)cf->filename));
    }
  }
#line 771
  cl = cf->cache;
  {
#line 772
  while (1) {
    while_continue: /* CIL Label */ ;
#line 772
    if (! cl) {
#line 772
      goto while_break;
    }
#line 773
    if (cl->text) {
      {
#line 773
      free((void *)((char *)cl->text));
      }
    }
    {
#line 774
    cnext = cl->next;
#line 775
    free((void *)cl);
#line 776
    cl = cnext;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 778
  if ((unsigned long )CachedFiles == (unsigned long )cf) {
#line 778
    CachedFiles = cf->next;
  } else {
#line 780
    temp = CachedFiles;
    {
#line 781
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 781
      if (! temp) {
#line 781
        goto while_break___0;
      }
#line 782
      if ((unsigned long )temp->next == (unsigned long )cf) {
#line 783
        temp->next = cf->next;
#line 784
        goto while_break___0;
      }
#line 786
      temp = temp->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 789
  free((void *)cf);
  }
#line 790
  return;
}
}
#line 799 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/files.c"
int TopLevel(void) 
{ 


  {
#line 801
  return (IStackPtr <= 1);
}
}
#line 815 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/files.c"
static int CheckSafety(void) 
{ 
  struct stat statbuf ;
  int tmp ;
  int tmp___0 ;
  __uid_t tmp___1 ;
  __uid_t tmp___2 ;

  {
#line 819
  if ((unsigned long )fp == (unsigned long )stdin) {
#line 820
    return (1);
  }
  {
#line 823
  tmp = fileno(fp);
#line 823
  tmp___0 = fstat(tmp, & statbuf);
  }
#line 823
  if (tmp___0) {
    {
#line 824
    fclose(fp);
#line 825
    fp = (FILE *)((void *)0);
    }
#line 826
    return (0);
  }
  {
#line 830
  tmp___1 = geteuid();
  }
#line 830
  if (! tmp___1) {
#line 832
    if (statbuf.st_uid != 0U) {
      {
#line 833
      fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"SECURITY: Won\'t read non-root-owned file when running as root!\n");
#line 834
      fclose(fp);
#line 835
      fp = (FILE *)((void *)0);
      }
#line 836
      return (0);
    }
  }
#line 841
  if (! ((statbuf.st_mode & 61440U) == 32768U)) {
#line 842
    return (1);
  }
#line 844
  if (statbuf.st_mode & (unsigned int )((128 >> 3) >> 3)) {
    {
#line 845
    fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"SECURITY: Won\'t read world-writable file!\n");
#line 846
    fclose(fp);
#line 847
    fp = (FILE *)((void *)0);
    }
#line 848
    return (0);
  }
  {
#line 852
  tmp___2 = geteuid();
  }
#line 852
  if (statbuf.st_uid != tmp___2) {
#line 853
    RunDisabled |= 4;
  }
#line 856
  return (1);
}
}
#line 33 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int JulianToday  ;
#line 34 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int RealToday  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int CurDay  ;
#line 36 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int CurMon  ;
#line 37 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int CurYear  ;
#line 38 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int LineNo  ;
#line 39 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int FreshLine  ;
#line 40 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
char const   *MsgCommand  =    (char const   *)((void *)0);
#line 41 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int ShowAllErrors  =    0;
#line 42 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int DebugFlag  =    0;
#line 43 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int DoCalendar  =    0;
#line 44 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int DoSimpleCalendar  =    0;
#line 45 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int DoSimpleCalDelta  =    0;
#line 46 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int DoPrefixLineNo  =    0;
#line 47 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int MondayFirst  =    0;
#line 48 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int Iterations  =    1;
#line 49 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int PsCal  =    0;
#line 50 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int CalWidth  =    80;
#line 51 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int CalWeeks  =    0;
#line 52 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int CalMonths  =    0;
#line 53 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int Hush  =    0;
#line 54 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int NextMode  =    0;
#line 55 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int InfiniteDelta  =    0;
#line 56 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int DeltaOffset  =    0;
#line 57 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int RunDisabled  =    0;
#line 58 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int IgnoreOnce  =    0;
#line 59 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int SortByTime  =    0;
#line 60 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int SortByDate  =    0;
#line 61 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int SortByPrio  =    0;
#line 62 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int UntimedBeforeTimed  =    0;
#line 63 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int DefaultPrio  =    5000;
#line 64 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
long SysTime  =    -1L;
#line 66 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
char const   *InitialFile  ;
#line 67 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int FileAccessDate  ;
#line 69 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int DontFork  =    0;
#line 70 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int DontQueue  =    0;
#line 71 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int NumQueued  =    0;
#line 72 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int DontIssueAts  =    0;
#line 73 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int Daemon  =    0;
#line 74 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
char DateSep  =    (char )'-';
#line 75 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
char TimeSep  =    (char )':';
#line 76 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int SynthesizeTags  =    0;
#line 77 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int ScFormat  =    0;
#line 78 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int MaxSatIter  =    150;
#line 79 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int MaxStringLen  =    65535;
#line 80 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
char *FileName  =    (char *)((void *)0);
#line 81 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int UseStdin  =    0;
#line 82 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int PurgeMode  =    0;
#line 83 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int PurgeIncludeDepth  =    0;
#line 84 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
FILE *ErrFp  ;
#line 85 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
FILE *PurgeFP  =    (FILE *)((void *)0);
#line 86 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int NumIfs  =    0;
#line 87 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
unsigned int IfFlags  =    0U;
#line 88 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int LastTriggerDate  =    0;
#line 89 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int LastTrigValid  =    0;
#line 90 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int LastTriggerTime  =    0;
#line 91 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int ShouldCache  =    0;
#line 92 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
char const   *CurLine  ;
#line 93 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int NumTriggered  =    0;
#line 94 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int ArgC  ;
#line 95 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
char const   **ArgV  ;
#line 96 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int CalLines  =    5;
#line 97 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int CalPad  =    1;
#line 98 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int UseVTChars  =    0;
#line 99 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int UseUTF8Chars  =    0;
#line 100 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int UseVTColors  =    0;
#line 103 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int LatDeg  =    45;
#line 104 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int LatMin  =    24;
#line 105 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int LatSec  =    0;
#line 106 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int LongDeg  =    75;
#line 107 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int LongMin  =    39;
#line 108 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int LongSec  =    0;
#line 109 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
char *Location  =    (char *)"Ottawa";
#line 112 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int MinsFromUTC  =    0;
#line 113 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int CalculateUTC  =    1;
#line 114 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int FoldYear  =    0;
#line 117 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int FormWidth  =    72;
#line 118 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int FirstIndent  =    0;
#line 119 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int SubsIndent  =    0;
#line 120 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
char *EndSent  =    (char *)".?!";
#line 121 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
char *EndSentIg  =    (char *)"\"\')]}>";
#line 128 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
DynamicBuffer Banner  ;
#line 129 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
DynamicBuffer LineBuffer  ;
#line 130 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
DynamicBuffer ExprBuf  ;
#line 132 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
char *EnglishMonthName[12]  = 
#line 132
  {      (char *)"January",      (char *)"February",      (char *)"March",      (char *)"April", 
        (char *)"May",      (char *)"June",      (char *)"July",      (char *)"August", 
        (char *)"September",      (char *)"October",      (char *)"November",      (char *)"December"};
#line 150 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
char *EnglishDayName[7]  = {      (char *)"Monday",      (char *)"Tuesday",      (char *)"Wednesday",      (char *)"Thursday", 
        (char *)"Friday",      (char *)"Saturday",      (char *)"Sunday"};
#line 168 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int MonthDays[12]  = 
#line 168
  {      31,      29,      31,      30, 
        31,      30,      31,      31, 
        30,      31,      30,      31};
#line 177 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/globals.h"
int MonthIndex[2][12]  = { {        0,        31,        59,        90, 
            120,        151,        181,        212, 
            243,        273,        304,        334}, 
   {        0,        31,        60,        91, 
            121,        152,        182,        213, 
            244,        274,        305,        335}};
#line 132 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/err.h"
char *ErrMsg[102]  = 
#line 132 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/err.h"
  {      (char *)"Ok",      (char *)"Missing \']\'",      (char *)"Missing quote",      (char *)"Expression too complex - too many operators", 
        (char *)"Expression too complex - too many operands",      (char *)"Missing \')\'",      (char *)"Undefined function",      (char *)"Illegal character", 
        (char *)"Expecting binary operator",      (char *)"Out of memory",      (char *)"Ill-formed number",      (char *)"Op stack underflow - internal error", 
        (char *)"Va stack underflow - internal error",      (char *)"Can\'t coerce",      (char *)"Type mismatch",      (char *)"Date overflow", 
        (char *)"Stack error - internal error",      (char *)"Division by zero",      (char *)"Undefined variable",      (char *)"Unexpected end of line", 
        (char *)"Unexpected end of file",      (char *)"I/O error",      (char *)"Line too long",      (char *)"Internal error", 
        (char *)"Bad date specification",      (char *)"Not enough arguments",      (char *)"Too many arguments",      (char *)"Ill-formed time", 
        (char *)"Number too high",      (char *)"Number too low",      (char *)"Can\'t open file",      (char *)"INCLUDE nested too deeply", 
        (char *)"Parse error",      (char *)"Can\'t compute trigger",      (char *)"Too many nested IFs",      (char *)"ELSE with no matching IF", 
        (char *)"ENDIF with no matching IF",      (char *)"Can\'t OMIT every weekday",      (char *)"Extraneous token(s) on line",      (char *)"POP-OMIT-CONTEXT without matching PUSH-OMIT-CONTEXT", 
        (char *)"RUN disabled",      (char *)"Domain error",      (char *)"Invalid identifier",      (char *)"Recursive function call detected", 
        (char *)"",      (char *)"Cannot modify system variable",      (char *)"C library function can\'t represent date/time",      (char *)"Attempt to redefine built-in function", 
        (char *)"Can\'t nest function definition in expression",      (char *)"Must fully specify date to use repeat factor",      (char *)"Year specified twice",      (char *)"Month specified twice", 
        (char *)"Day specified twice",      (char *)"Unknown token",      (char *)"Must specify month and day in OMIT command",      (char *)"Too many partial OMITs", 
        (char *)"Too many full OMITs",      (char *)"Warning: PUSH-OMIT-CONTEXT without matching POP-OMIT-CONTEXT",      (char *)"Error reading",      (char *)"Expecting end-of-line", 
        (char *)"Invalid Hebrew date",      (char *)"IIF needs odd number of arguments",      (char *)"Warning: Missing ENDIF",      (char *)"Expecting comma", 
        (char *)"Weekday specified twice",      (char *)"Only use one of BEFORE, AFTER or SKIP",      (char *)"Can\'t nest MSG, MSF, RUN, etc. in expression",      (char *)"Repeat value specified twice", 
        (char *)"Delta value specified twice",      (char *)"Back value specified twice",      (char *)"ONCE keyword used twice. (Hah.)",      (char *)"Expecting time after AT", 
        (char *)"THROUGH/UNTIL keyword used twice",      (char *)"Incomplete date specification",      (char *)"FROM/SCANFROM keyword used twice",      (char *)"Variable", 
        (char *)"Value",      (char *)"*UNDEFINED*",      (char *)"Entering UserFN",      (char *)"Leaving UserFN", 
        (char *)"Expired",      (char *)"fork() failed - can\'t do queued reminders",      (char *)"Can\'t access file",      (char *)"Illegal system date: Year is less than %d\n", 
        (char *)"Unknown debug flag \'%c\'\n",      (char *)"Unknown option \'%c\'\n",      (char *)"Unknown user \'%s\'\n",      (char *)"Could not change gid to %d\n", 
        (char *)"Could not change uid to %d\n",      (char *)"Out of memory for environment\n",      (char *)"Missing \'=\' sign",      (char *)"Missing variable name", 
        (char *)"Missing expression",      (char *)"Can\'t reset access date of %s\n",      (char *)"Remind: \'-i\' option: %s\n",      (char *)"No reminders.", 
        (char *)"%d reminder(s) queued for later today.\n",      (char *)"Expecting number",      (char *)"Bad function in WARN clause",      (char *)"Can\'t convert between time zones", 
        (char *)"No files matching *.rem",      (char *)"String too long"};
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/protos.h"
int EvalExpr(char const   **e , Value *v , ParsePtr p ) ;
#line 77
int ClearGlobalOmits(void) ;
#line 78
int DoClear(ParsePtr p ) ;
#line 79
int DestroyOmitContexts(void) ;
#line 80
int PushOmitContext(ParsePtr p ) ;
#line 81
int PopOmitContext(ParsePtr p ) ;
#line 82
int IsOmitted(int jul , int localomit , char const   *omitfunc , int *omit ) ;
#line 83
int DoOmit(ParsePtr p ) ;
#line 87
void FindToken(char const   *s , Token *tok ) ;
#line 115
int UserFuncExists(char const   *fn ) ;
#line 25 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/omit.c"
static int BexistsIntArray(int *array , int num , int key ) ;
#line 26
static void InsertIntoSortedArray(int *array , int num , int key ) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/omit.c"
static int FullOmitArray[500]  ;
#line 30 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/omit.c"
static int PartialOmitArray[366]  ;
#line 33 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/omit.c"
static int NumFullOmits  ;
#line 33 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/omit.c"
static int NumPartialOmits  ;
#line 44 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/omit.c"
static OmitContext *SavedOmitContexts  =    (OmitContext *)((void *)0);
#line 53 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/omit.c"
int ClearGlobalOmits(void) 
{ 


  {
#line 55
  NumPartialOmits = 0;
#line 55
  NumFullOmits = NumPartialOmits;
#line 56
  return (0);
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/omit.c"
int DoClear(ParsePtr p ) 
{ 
  int tmp ;

  {
  {
#line 68
  ClearGlobalOmits();
#line 69
  tmp = VerifyEoln(p);
  }
#line 69
  return (tmp);
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/omit.c"
int DestroyOmitContexts(void) 
{ 
  OmitContext *c ;
  OmitContext *d ;
  int num ;

  {
#line 83
  c = SavedOmitContexts;
#line 85
  num = 0;
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
#line 87
    if (! c) {
#line 87
      goto while_break;
    }
#line 88
    num ++;
#line 89
    if (c->fullsave) {
      {
#line 89
      free((void *)c->fullsave);
      }
    }
#line 90
    if (c->partsave) {
      {
#line 90
      free((void *)c->partsave);
      }
    }
    {
#line 91
    d = c->next;
#line 92
    free((void *)c);
#line 93
    c = d;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 95
  SavedOmitContexts = (OmitContext *)((void *)0);
#line 96
  return (num);
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/omit.c"
int PushOmitContext(ParsePtr p ) 
{ 
  register int i ;
  OmitContext *context ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 112
  tmp = malloc(sizeof(OmitContext ));
#line 112
  context = (OmitContext *)tmp;
  }
#line 113
  if (! context) {
#line 113
    return (9);
  }
  {
#line 115
  context->numfull = NumFullOmits;
#line 116
  context->numpart = NumPartialOmits;
#line 117
  tmp___0 = malloc((unsigned long )NumFullOmits * sizeof(int ));
#line 117
  context->fullsave = (int *)tmp___0;
  }
#line 118
  if (NumFullOmits) {
#line 118
    if (! context->fullsave) {
      {
#line 119
      free((void *)context);
      }
#line 120
      return (9);
    }
  }
  {
#line 122
  tmp___1 = malloc((unsigned long )NumPartialOmits * sizeof(int ));
#line 122
  context->partsave = (int *)tmp___1;
  }
#line 123
  if (NumPartialOmits) {
#line 123
    if (! context->partsave) {
      {
#line 124
      free((void *)context->fullsave);
#line 125
      free((void *)context);
      }
#line 126
      return (9);
    }
  }
#line 130
  i = 0;
  {
#line 130
  while (1) {
    while_continue: /* CIL Label */ ;
#line 130
    if (! (i < NumFullOmits)) {
#line 130
      goto while_break;
    }
#line 131
    *(context->fullsave + i) = FullOmitArray[i];
#line 130
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 133
  i = 0;
  {
#line 133
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 133
    if (! (i < NumPartialOmits)) {
#line 133
      goto while_break___0;
    }
#line 134
    *(context->partsave + i) = PartialOmitArray[i];
#line 133
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 137
  context->next = SavedOmitContexts;
#line 138
  SavedOmitContexts = context;
#line 139
  tmp___2 = VerifyEoln(p);
  }
#line 139
  return (tmp___2);
}
}
#line 149 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/omit.c"
int PopOmitContext(ParsePtr p ) 
{ 
  register int i ;
  OmitContext *c ;
  int tmp ;

  {
#line 153
  c = SavedOmitContexts;
#line 155
  if (! c) {
#line 155
    return (39);
  }
#line 156
  NumFullOmits = c->numfull;
#line 157
  NumPartialOmits = c->numpart;
#line 160
  i = 0;
  {
#line 160
  while (1) {
    while_continue: /* CIL Label */ ;
#line 160
    if (! (i < NumFullOmits)) {
#line 160
      goto while_break;
    }
#line 161
    FullOmitArray[i] = *(c->fullsave + i);
#line 160
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 163
  i = 0;
  {
#line 163
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 163
    if (! (i < NumPartialOmits)) {
#line 163
      goto while_break___0;
    }
#line 164
    PartialOmitArray[i] = *(c->partsave + i);
#line 163
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 167
  SavedOmitContexts = c->next;
#line 170
  if (c->partsave) {
    {
#line 170
    free((void *)c->partsave);
    }
  }
#line 171
  if (c->fullsave) {
    {
#line 171
    free((void *)c->fullsave);
    }
  }
  {
#line 172
  free((void *)c);
#line 174
  tmp = VerifyEoln(p);
  }
#line 174
  return (tmp);
}
}
#line 185 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/omit.c"
int IsOmitted(int jul , int localomit , char const   *omitfunc , int *omit ) 
{ 
  int y ;
  int m ;
  int d ;
  char expr[48] ;
  char const   *s ;
  int r ;
  Value v ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 191
  if (omitfunc) {
#line 191
    if (*omitfunc) {
      {
#line 191
      tmp = UserFuncExists(omitfunc);
      }
#line 191
      if (tmp) {
        {
#line 197
        FromJulian(jul, & y, & m, & d);
#line 198
        sprintf((char */* __restrict  */)(expr), (char const   */* __restrict  */)"%s(\'%04d-%02d-%02d\')",
                omitfunc, y, m + 1, d);
#line 200
        s = (char const   *)(expr);
#line 201
        r = EvalExpr(& s, & v, (ParsePtr )((void *)0));
        }
#line 202
        if (r) {
#line 202
          return (r);
        }
#line 203
        if ((int )v.type == 1) {
#line 203
          if (v.v.val != 0) {
#line 204
            *omit = 1;
          } else {
#line 206
            *omit = 0;
          }
        } else {
#line 206
          *omit = 0;
        }
#line 208
        return (0);
      }
    }
  }
#line 212
  if (localomit & (1 << jul % 7)) {
#line 213
    *omit = 1;
#line 214
    return (0);
  }
  {
#line 218
  tmp___0 = BexistsIntArray(FullOmitArray, NumFullOmits, jul);
  }
#line 218
  if (tmp___0) {
#line 219
    *omit = 1;
#line 220
    return (0);
  }
  {
#line 223
  FromJulian(jul, & y, & m, & d);
#line 224
  tmp___1 = BexistsIntArray(PartialOmitArray, NumPartialOmits, (m << 5) + d);
  }
#line 224
  if (tmp___1) {
#line 225
    *omit = 1;
#line 226
    return (0);
  }
#line 230
  *omit = 0;
#line 231
  return (0);
}
}
#line 242 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/omit.c"
static int BexistsIntArray(int *array , int num , int key ) 
{ 
  int top ;
  int bot ;
  int mid ;

  {
#line 244
  top = num - 1;
#line 244
  bot = 0;
  {
#line 246
  while (1) {
    while_continue: /* CIL Label */ ;
#line 246
    if (! (top >= bot)) {
#line 246
      goto while_break;
    }
#line 247
    mid = (top + bot) / 2;
#line 248
    if (*(array + mid) == key) {
#line 248
      return (1);
    } else
#line 249
    if (*(array + mid) > key) {
#line 249
      top = mid - 1;
    } else {
#line 250
      bot = mid + 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 252
  return (0);
}
}
#line 263 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/omit.c"
static void InsertIntoSortedArray(int *array , int num , int key ) 
{ 
  int *cur ;

  {
#line 266
  cur = array + num;
  {
#line 268
  while (1) {
    while_continue: /* CIL Label */ ;
#line 268
    if ((unsigned long )cur > (unsigned long )array) {
#line 268
      if (! (*(cur - 1) > key)) {
#line 268
        goto while_break;
      }
    } else {
#line 268
      goto while_break;
    }
#line 269
    *cur = *(cur - 1);
#line 270
    cur --;
  }
  while_break: /* CIL Label */ ;
  }
#line 272
  *cur = key;
#line 273
  return;
}
}
#line 275
static int DoThroughOmit(ParsePtr p , int ystart , int mstart , int dstart ) ;
#line 276
static void DumpOmits(void) ;
#line 285 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/omit.c"
int DoOmit(ParsePtr p ) 
{ 
  int y ;
  int m ;
  int d ;
  int r ;
  Token tok ;
  int parsing ;
  int syndrome ;
  int not_first_token ;
  DynamicBuffer buf___1 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 287
  y = -1;
#line 287
  m = -1;
#line 287
  d = -1;
#line 289
  parsing = 1;
#line 291
  not_first_token = -1;
#line 294
  DBufInit(& buf___1);
  }
  {
#line 297
  while (1) {
    while_continue: /* CIL Label */ ;
#line 297
    if (! parsing) {
#line 297
      goto while_break;
    }
    {
#line 298
    not_first_token ++;
#line 299
    r = ParseToken(p, & buf___1);
    }
#line 299
    if (r) {
#line 299
      return (r);
    }
    {
#line 300
    FindToken((char const   *)buf___1.buffer, & tok);
    }
    {
#line 302
    if ((unsigned int )tok.type == 37U) {
#line 302
      goto case_37;
    }
#line 310
    if ((unsigned int )tok.type == 20U) {
#line 310
      goto case_20;
    }
#line 318
    if ((unsigned int )tok.type == 26U) {
#line 318
      goto case_26;
    }
#line 324
    if ((unsigned int )tok.type == 18U) {
#line 324
      goto case_18;
    }
#line 330
    if ((unsigned int )tok.type == 27U) {
#line 330
      goto case_27;
    }
#line 336
    if ((unsigned int )tok.type == 29U) {
#line 336
      goto case_29;
    }
#line 340
    if ((unsigned int )tok.type == 47U) {
#line 340
      goto case_47;
    }
#line 350
    if ((unsigned int )tok.type == 44U) {
#line 350
      goto case_44;
    }
#line 350
    if ((unsigned int )tok.type == 43U) {
#line 350
      goto case_44;
    }
#line 350
    if ((unsigned int )tok.type == 40U) {
#line 350
      goto case_44;
    }
#line 350
    if ((unsigned int )tok.type == 24U) {
#line 350
      goto case_44;
    }
#line 350
    if ((unsigned int )tok.type == 33U) {
#line 350
      goto case_44;
    }
#line 350
    if ((unsigned int )tok.type == 32U) {
#line 350
      goto case_44;
    }
#line 355
    goto switch_default;
    case_37: /* CIL Label */ 
#line 303
    if (not_first_token) {
#line 303
      return (32);
    }
    {
#line 304
    DBufFree(& buf___1);
#line 305
    r = VerifyEoln(p);
    }
#line 306
    if (r != 0) {
#line 306
      return (r);
    }
    {
#line 307
    DumpOmits();
    }
#line 308
    return (0);
    case_20: /* CIL Label */ 
    {
#line 311
    DBufFree(& buf___1);
    }
#line 312
    if (y != -1) {
#line 312
      return (50);
    }
#line 313
    if (m != -1) {
#line 313
      return (51);
    }
#line 314
    if (d != -1) {
#line 314
      return (52);
    }
    {
#line 315
    FromJulian(tok.val, & y, & m, & d);
    }
#line 316
    goto switch_break;
    case_26: /* CIL Label */ 
    {
#line 319
    DBufFree(& buf___1);
    }
#line 320
    if (y != -1) {
#line 320
      return (50);
    }
#line 321
    y = tok.val;
#line 322
    goto switch_break;
    case_18: /* CIL Label */ 
    {
#line 325
    DBufFree(& buf___1);
    }
#line 326
    if (m != -1) {
#line 326
      return (51);
    }
#line 327
    m = tok.val;
#line 328
    goto switch_break;
    case_27: /* CIL Label */ 
    {
#line 331
    DBufFree(& buf___1);
    }
#line 332
    if (d != -1) {
#line 332
      return (52);
    }
#line 333
    d = tok.val;
#line 334
    goto switch_break;
    case_29: /* CIL Label */ 
    {
#line 337
    DBufFree(& buf___1);
    }
#line 338
    goto switch_break;
    case_47: /* CIL Label */ 
    {
#line 341
    DBufFree(& buf___1);
    }
#line 342
    if (y == -1) {
#line 342
      return (73);
    } else
#line 342
    if (m == -1) {
#line 342
      return (73);
    } else
#line 342
    if (d == -1) {
#line 342
      return (73);
    }
    {
#line 343
    tmp = DoThroughOmit(p, y, m, d);
    }
#line 343
    return (tmp);
    case_44: /* CIL Label */ 
    case_43: /* CIL Label */ 
    case_40: /* CIL Label */ 
    case_24: /* CIL Label */ 
    case_33: /* CIL Label */ 
    case_32: /* CIL Label */ 
    {
#line 351
    DBufFree(& buf___1);
#line 352
    parsing = 0;
    }
#line 353
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 356
    Eprint("%s: `%s\' (OMIT)", ErrMsg[53], buf___1.buffer);
#line 358
    DBufFree(& buf___1);
    }
#line 359
    return (53);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 362
  if (m == -1) {
#line 362
    return (54);
  } else
#line 362
  if (d == -1) {
#line 362
    return (54);
  }
#line 364
  if (y == -1) {
#line 365
    if (NumPartialOmits == 366) {
#line 365
      return (55);
    }
#line 367
    if (d > MonthDays[m]) {
#line 367
      return (24);
    }
    {
#line 368
    syndrome = (m << 5) + d;
#line 369
    tmp___0 = BexistsIntArray(PartialOmitArray, NumPartialOmits, syndrome);
    }
#line 369
    if (! tmp___0) {
      {
#line 370
      InsertIntoSortedArray(PartialOmitArray, NumPartialOmits, syndrome);
#line 371
      NumPartialOmits ++;
      }
    }
  } else {
#line 374
    if (NumFullOmits == 500) {
#line 374
      return (56);
    }
#line 376
    if (m != 1) {
#line 376
      tmp___3 = MonthDays[m];
    } else {
#line 376
      if (y % 4) {
#line 376
        tmp___2 = 0;
      } else {
#line 376
        if (! (y % 100)) {
#line 376
          if (y % 400) {
#line 376
            tmp___1 = 0;
          } else {
#line 376
            tmp___1 = 1;
          }
        } else {
#line 376
          tmp___1 = 1;
        }
#line 376
        tmp___2 = tmp___1;
      }
#line 376
      tmp___3 = 28 + tmp___2;
    }
#line 376
    if (d > tmp___3) {
#line 376
      return (24);
    }
    {
#line 377
    syndrome = Julian(y, m, d);
#line 378
    tmp___4 = BexistsIntArray(FullOmitArray, NumFullOmits, syndrome);
    }
#line 378
    if (! tmp___4) {
      {
#line 379
      InsertIntoSortedArray(FullOmitArray, NumFullOmits, syndrome);
#line 380
      NumFullOmits ++;
      }
    }
  }
#line 383
  if ((unsigned int )tok.type == 43U) {
#line 383
    return (44);
  } else
#line 383
  if ((unsigned int )tok.type == 44U) {
#line 383
    return (44);
  } else
#line 383
  if ((unsigned int )tok.type == 24U) {
#line 383
    return (44);
  } else
#line 383
  if ((unsigned int )tok.type == 40U) {
#line 383
    return (44);
  }
#line 384
  return (0);
}
}
#line 388 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/omit.c"
static int DoThroughOmit(ParsePtr p , int ystart , int mstart , int dstart ) 
{ 
  int yend ;
  int mend ;
  int dend ;
  int r ;
  int start ;
  int end ;
  int tmp ;
  int parsing ;
  Token tok ;
  DynamicBuffer buf___1 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 391
  yend = -1;
#line 391
  mend = -1;
#line 391
  dend = -1;
#line 393
  parsing = 1;
#line 398
  DBufInit(& buf___1);
  }
  {
#line 400
  while (1) {
    while_continue: /* CIL Label */ ;
#line 400
    if (! parsing) {
#line 400
      goto while_break;
    }
    {
#line 401
    r = ParseToken(p, & buf___1);
    }
#line 401
    if (r) {
#line 401
      return (r);
    }
    {
#line 402
    FindToken((char const   *)buf___1.buffer, & tok);
    }
    {
#line 405
    if ((unsigned int )tok.type == 20U) {
#line 405
      goto case_20;
    }
#line 413
    if ((unsigned int )tok.type == 26U) {
#line 413
      goto case_26;
    }
#line 419
    if ((unsigned int )tok.type == 18U) {
#line 419
      goto case_18;
    }
#line 425
    if ((unsigned int )tok.type == 27U) {
#line 425
      goto case_27;
    }
#line 436
    if ((unsigned int )tok.type == 44U) {
#line 436
      goto case_44;
    }
#line 436
    if ((unsigned int )tok.type == 43U) {
#line 436
      goto case_44;
    }
#line 436
    if ((unsigned int )tok.type == 40U) {
#line 436
      goto case_44;
    }
#line 436
    if ((unsigned int )tok.type == 24U) {
#line 436
      goto case_44;
    }
#line 436
    if ((unsigned int )tok.type == 33U) {
#line 436
      goto case_44;
    }
#line 436
    if ((unsigned int )tok.type == 32U) {
#line 436
      goto case_44;
    }
#line 441
    goto switch_default;
    case_20: /* CIL Label */ 
    {
#line 406
    DBufFree(& buf___1);
    }
#line 407
    if (yend != -1) {
#line 407
      return (50);
    }
#line 408
    if (mend != -1) {
#line 408
      return (51);
    }
#line 409
    if (dend != -1) {
#line 409
      return (52);
    }
    {
#line 410
    FromJulian(tok.val, & yend, & mend, & dend);
    }
#line 411
    goto switch_break;
    case_26: /* CIL Label */ 
    {
#line 414
    DBufFree(& buf___1);
    }
#line 415
    if (yend != -1) {
#line 415
      return (50);
    }
#line 416
    yend = tok.val;
#line 417
    goto switch_break;
    case_18: /* CIL Label */ 
    {
#line 420
    DBufFree(& buf___1);
    }
#line 421
    if (mend != -1) {
#line 421
      return (51);
    }
#line 422
    mend = tok.val;
#line 423
    goto switch_break;
    case_27: /* CIL Label */ 
    {
#line 426
    DBufFree(& buf___1);
    }
#line 427
    if (dend != -1) {
#line 427
      return (52);
    }
#line 428
    dend = tok.val;
#line 429
    goto switch_break;
    case_44: /* CIL Label */ 
    case_43: /* CIL Label */ 
    case_40: /* CIL Label */ 
    case_24: /* CIL Label */ 
    case_33: /* CIL Label */ 
    case_32: /* CIL Label */ 
    {
#line 437
    DBufFree(& buf___1);
#line 438
    parsing = 0;
    }
#line 439
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 442
    Eprint("%s: `%s\' (OMIT)", ErrMsg[53], buf___1.buffer);
#line 444
    DBufFree(& buf___1);
    }
#line 445
    return (53);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 449
  if (yend == -1) {
#line 449
    return (73);
  } else
#line 449
  if (mend == -1) {
#line 449
    return (73);
  } else
#line 449
  if (dend == -1) {
#line 449
    return (73);
  }
#line 450
  if (mend != 1) {
#line 450
    tmp___2 = MonthDays[mend];
  } else {
#line 450
    if (yend % 4) {
#line 450
      tmp___1 = 0;
    } else {
#line 450
      if (! (yend % 100)) {
#line 450
        if (yend % 400) {
#line 450
          tmp___0 = 0;
        } else {
#line 450
          tmp___0 = 1;
        }
      } else {
#line 450
        tmp___0 = 1;
      }
#line 450
      tmp___1 = tmp___0;
    }
#line 450
    tmp___2 = 28 + tmp___1;
  }
#line 450
  if (dend > tmp___2) {
#line 450
    return (24);
  }
#line 451
  if (mstart != 1) {
#line 451
    tmp___5 = MonthDays[mstart];
  } else {
#line 451
    if (ystart % 4) {
#line 451
      tmp___4 = 0;
    } else {
#line 451
      if (! (ystart % 100)) {
#line 451
        if (ystart % 400) {
#line 451
          tmp___3 = 0;
        } else {
#line 451
          tmp___3 = 1;
        }
      } else {
#line 451
        tmp___3 = 1;
      }
#line 451
      tmp___4 = tmp___3;
    }
#line 451
    tmp___5 = 28 + tmp___4;
  }
#line 451
  if (dstart > tmp___5) {
#line 451
    return (24);
  }
  {
#line 453
  start = Julian(ystart, mstart, dstart);
#line 454
  end = Julian(yend, mend, dend);
  }
#line 456
  if (end < start) {
#line 457
    tmp = start;
#line 458
    start = end;
#line 459
    end = tmp;
  }
#line 462
  tmp = (end - start) + 1;
#line 465
  if (NumFullOmits + tmp >= 500) {
#line 465
    return (56);
  }
#line 466
  tmp = start;
  {
#line 466
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 466
    if (! (tmp <= end)) {
#line 466
      goto while_break___0;
    }
    {
#line 467
    tmp___6 = BexistsIntArray(FullOmitArray, NumFullOmits, tmp);
    }
#line 467
    if (! tmp___6) {
      {
#line 468
      InsertIntoSortedArray(FullOmitArray, NumFullOmits, tmp);
#line 469
      NumFullOmits ++;
      }
    }
#line 466
    tmp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 472
  if ((unsigned int )tok.type == 43U) {
#line 472
    return (44);
  } else
#line 472
  if ((unsigned int )tok.type == 44U) {
#line 472
    return (44);
  } else
#line 472
  if ((unsigned int )tok.type == 24U) {
#line 472
    return (44);
  } else
#line 472
  if ((unsigned int )tok.type == 40U) {
#line 472
    return (44);
  }
#line 473
  return (0);
}
}
#line 476 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/omit.c"
static void DumpOmits(void) 
{ 
  int i ;
  int y ;
  int m ;
  int d ;

  {
  {
#line 481
  printf((char const   */* __restrict  */)"Global Full OMITs (%d of maximum allowed %d):\n",
         NumFullOmits, 500);
  }
#line 482
  if (! NumFullOmits) {
    {
#line 483
    printf((char const   */* __restrict  */)"\tNone.\n");
    }
  } else {
#line 485
    i = 0;
    {
#line 485
    while (1) {
      while_continue: /* CIL Label */ ;
#line 485
      if (! (i < NumFullOmits)) {
#line 485
        goto while_break;
      }
      {
#line 486
      FromJulian(FullOmitArray[i], & y, & m, & d);
#line 487
      printf((char const   */* __restrict  */)"\t%04d%c%02d%c%02d\n", y, (int )DateSep,
             m + 1, (int )DateSep, d);
#line 485
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 491
  printf((char const   */* __restrict  */)"Global Partial OMITs (%d of maximum allowed %d):\n",
         NumPartialOmits, 366);
  }
#line 492
  if (! NumPartialOmits) {
    {
#line 493
    printf((char const   */* __restrict  */)"\tNone.\n");
    }
  } else {
#line 495
    i = 0;
    {
#line 495
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 495
      if (! (i < NumPartialOmits)) {
#line 495
        goto while_break___0;
      }
      {
#line 496
      m = (PartialOmitArray[i] >> 5) & 15;
#line 497
      d = PartialOmitArray[i] & 31;
#line 498
      printf((char const   */* __restrict  */)"\t%02d%c%02d\n", m + 1, (int )DateSep,
             d);
#line 495
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 501
  return;
}
}
#line 717 "/usr/include/stdlib.h"
extern int system(char const   *__command ) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/protos.h"
int DoCoerce(char type , Value *v ) ;
#line 107
int DoMsgCommand(char const   *cmd , char const   *msg ) ;
#line 113
int InsertIntoSortBuffer(int jul , int tim , char const   *body , int typ , int prio ) ;
#line 114
void IssueSortedReminders(void) ;
#line 131
void FillParagraph(char const   *s ) ;
#line 136
int CompareRems(int dat1 , int tim1 , int prio1 , int dat2 , int tim2 , int prio2 ,
                int bydate , int bytime , int byprio , int untimed_first ) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/sort.c"
static Sortrem *SortedQueue  =    (Sortrem *)((void *)0);
#line 38
static Sortrem *MakeSortRem(int jul , int tim , char const   *body , int typ , int prio ) ;
#line 39
static void IssueSortBanner(int jul ) ;
#line 48 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/sort.c"
static Sortrem *MakeSortRem(int jul , int tim , char const   *body , int typ , int prio ) 
{ 
  Sortrem *new ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 50
  tmp = malloc(sizeof(Sortrem ));
#line 50
  new = (Sortrem *)tmp;
  }
#line 51
  if (! new) {
#line 51
    return ((Sortrem *)((void *)0));
  }
  {
#line 53
  tmp___0 = StrDup(body);
#line 53
  new->text = (char const   *)tmp___0;
  }
#line 54
  if (! new->text) {
    {
#line 55
    free((void *)new);
    }
#line 56
    return ((Sortrem *)((void *)0));
  }
#line 59
  new->trigdate = jul;
#line 60
  new->trigtime = tim;
#line 61
  new->typ = typ;
#line 62
  new->priority = prio;
#line 63
  new->next = (struct sortrem *)((void *)0);
#line 64
  return (new);
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/sort.c"
int InsertIntoSortBuffer(int jul , int tim , char const   *body , int typ , int prio ) 
{ 
  Sortrem *new ;
  Sortrem *tmp ;
  Sortrem *cur ;
  Sortrem *prev ;
  int ShouldGoAfter ;

  {
  {
#line 76
  tmp = MakeSortRem(jul, tim, body, typ, prio);
#line 76
  new = tmp;
#line 77
  cur = SortedQueue;
#line 77
  prev = (Sortrem *)((void *)0);
  }
#line 80
  if (! new) {
    {
#line 81
    Eprint("%s", ErrMsg[9]);
#line 82
    IssueSortedReminders();
#line 83
    SortByDate = 0;
#line 84
    SortByTime = 0;
#line 85
    SortByPrio = 0;
#line 86
    UntimedBeforeTimed = 0;
    }
#line 87
    return (9);
  }
#line 91
  if (! SortedQueue) {
#line 92
    SortedQueue = new;
#line 93
    return (0);
  }
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    if (! cur) {
#line 95
      goto while_break;
    }
    {
#line 96
    ShouldGoAfter = CompareRems(new->trigdate, new->trigtime, new->priority, cur->trigdate,
                                cur->trigtime, cur->priority, SortByDate, SortByTime,
                                SortByPrio, UntimedBeforeTimed);
    }
#line 100
    if (ShouldGoAfter <= 0) {
#line 101
      prev = cur;
#line 102
      cur = cur->next;
    } else {
#line 104
      if (prev) {
#line 105
        prev->next = new;
#line 106
        new->next = cur;
      } else {
#line 108
        SortedQueue = new;
#line 109
        new->next = cur;
      }
#line 111
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 115
  prev->next = new;
#line 116
  new->next = cur;
#line 117
  return (0);
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/sort.c"
void IssueSortedReminders(void) 
{ 
  Sortrem *cur ;
  Sortrem *next ;
  int olddate ;

  {
#line 130
  cur = SortedQueue;
#line 132
  olddate = -1;
  {
#line 134
  while (1) {
    while_continue: /* CIL Label */ ;
#line 134
    if (! cur) {
#line 134
      goto while_break;
    }
#line 135
    next = cur->next;
    {
#line 137
    if (cur->typ == 1) {
#line 137
      goto case_1;
    }
#line 149
    if (cur->typ == 7) {
#line 149
      goto case_7;
    }
#line 153
    if (cur->typ == 2) {
#line 153
      goto case_2;
    }
#line 136
    goto switch_break;
    case_1: /* CIL Label */ 
#line 138
    if (MsgCommand) {
      {
#line 139
      DoMsgCommand(MsgCommand, cur->text);
      }
    } else {
#line 141
      if (cur->trigdate != olddate) {
        {
#line 142
        IssueSortBanner(cur->trigdate);
#line 143
        olddate = cur->trigdate;
        }
      }
      {
#line 145
      printf((char const   */* __restrict  */)"%s", cur->text);
      }
    }
#line 147
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 150
    FillParagraph(cur->text);
    }
#line 151
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 154
    system(cur->text);
    }
#line 155
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 158
    free((void *)((char *)cur->text));
#line 159
    free((void *)cur);
#line 160
    cur = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 162
  SortedQueue = (Sortrem *)((void *)0);
#line 163
  return;
}
}
#line 172 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/sort.c"
static void IssueSortBanner(int jul ) 
{ 
  char BanExpr[64] ;
  int y ;
  int m ;
  int d ;
  Value v ;
  char const   *s ;
  DynamicBuffer buf___1 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 177
  s = (char const   *)(BanExpr);
#line 180
  tmp = UserFuncExists("sortbanner");
  }
#line 180
  if (tmp != 1) {
#line 180
    return;
  }
  {
#line 182
  FromJulian(jul, & y, & m, & d);
#line 183
  sprintf((char */* __restrict  */)(BanExpr), (char const   */* __restrict  */)"sortbanner(\'%04d/%02d/%02d\')",
          y, m + 1, d);
#line 184
  y = EvalExpr(& s, & v, (ParsePtr )((void *)0));
  }
#line 185
  if (y) {
#line 185
    return;
  }
  {
#line 186
  tmp___0 = DoCoerce((char)4, & v);
  }
#line 186
  if (tmp___0) {
#line 186
    return;
  }
  {
#line 187
  DBufInit(& buf___1);
#line 188
  tmp___1 = DoSubstFromString((char const   *)v.v.str, & buf___1, jul, 2147483647);
  }
#line 188
  if (! tmp___1) {
#line 189
    if (*(buf___1.buffer)) {
      {
#line 189
      printf((char const   */* __restrict  */)"%s\n", buf___1.buffer);
      }
    }
    {
#line 190
    DBufFree(& buf___1);
    }
  }
#line 192
  if ((int )v.type == 4) {
#line 192
    if (v.v.str) {
      {
#line 192
      free((void *)v.v.str);
#line 192
      v.type = (char)0;
      }
    }
  }
#line 193
  return;
}
}
#line 205 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/sort.c"
int CompareRems(int dat1 , int tim1 , int prio1 , int dat2 , int tim2 , int prio2 ,
                int bydate , int bytime , int byprio , int untimed_first ) 
{ 
  int dafter ;
  int tafter ;
  int pafter ;
  int uafter ;

  {
#line 212
  if (bydate != 2) {
#line 212
    dafter = 1;
  } else {
#line 212
    dafter = -1;
  }
#line 213
  if (bytime != 2) {
#line 213
    tafter = 1;
  } else {
#line 213
    tafter = -1;
  }
#line 214
  if (byprio != 2) {
#line 214
    pafter = 1;
  } else {
#line 214
    pafter = -1;
  }
#line 215
  if (untimed_first) {
#line 215
    uafter = -1;
  } else {
#line 215
    uafter = 1;
  }
#line 217
  if (dat1 < dat2) {
#line 217
    return (dafter);
  }
#line 218
  if (dat1 > dat2) {
#line 218
    return (- dafter);
  }
#line 220
  if (tim1 == 2147483647) {
#line 220
    if (tim2 != 2147483647) {
#line 221
      return (- uafter);
    }
  }
#line 224
  if (tim1 != 2147483647) {
#line 224
    if (tim2 == 2147483647) {
#line 225
      return (uafter);
    }
  }
#line 228
  if (tim1 < tim2) {
#line 228
    return (tafter);
  }
#line 229
  if (tim1 > tim2) {
#line 229
    return (- tafter);
  }
#line 231
  if (prio1 < prio2) {
#line 231
    return (pafter);
  }
#line 232
  if (prio1 > prio2) {
#line 232
    return (- pafter);
  }
#line 234
  return (0);
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/protos.h"
void JulToHeb(int jul , int *hy , int *hm , int *hd ) ;
#line 117
int HebNameToNum(char const   *mname ) ;
#line 118
char const   *HebMonthName(int m , int y ) ;
#line 119
int RoshHashana(int i ) ;
#line 120
long DaysToHebYear(int y ) ;
#line 121
int DaysInHebYear(int y ) ;
#line 122
char const   *DaysInHebMonths(int ylen ) ;
#line 123
int HebToJul(int hy , int hm , int hd ) ;
#line 124
int GetValidHebDate(int yin , int min , int din , int adarbehave , int *mout , int *dout ,
                    int jahr ) ;
#line 125
int GetNextHebrewDate(int julstart , int hm , int hd , int jahr , int adarbehave ,
                      int *ans ) ;
#line 126
int ComputeJahr(int y , int m , int d , int *ans ) ;
#line 58 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/hbcal.c"
static char const   *HebMonthNames[14]  = 
#line 58 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/hbcal.c"
  {      "Tishrey",      "Heshvan",      "Kislev",      "Tevet", 
        "Shvat",      "Adar A",      "Adar B",      "Nisan", 
        "Iyar",      "Sivan",      "Tamuz",      "Av", 
        "Elul",      "Adar"};
#line 62 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/hbcal.c"
static char MaxMonLen[14]  = 
#line 62
  {      (char)30,      (char)30,      (char)30,      (char)29, 
        (char)30,      (char)30,      (char)29,      (char)30, 
        (char)29,      (char)30,      (char)29,      (char)30, 
        (char)29,      (char)29};
#line 65 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/hbcal.c"
static char HebIsLeap[19]  = 
#line 65
  {      (char)0,      (char)0,      (char)1,      (char)0, 
        (char)0,      (char)1,      (char)0,      (char)1, 
        (char)0,      (char)0,      (char)1,      (char)0, 
        (char)0,      (char)1,      (char)0,      (char)0, 
        (char)1,      (char)0,      (char)1};
#line 75 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/hbcal.c"
int RoshHashana(int i ) 
{ 
  long j ;
  long tmp ;

  {
  {
#line 78
  tmp = DaysToHebYear(i - 3744);
#line 78
  j = tmp - 732774L;
  }
#line 79
  return ((int )j);
}
}
#line 90 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/hbcal.c"
long DaysToHebYear(int y ) 
{ 
  long m ;
  long nm ;
  long dw ;
  long s ;
  long l ;

  {
#line 94
  l = (long )(y * 7 + 1);
#line 95
  m = (long )(y * 12) + l / 19L;
#line 96
  nm = m * 39673L + 1859L;
#line 97
  s = (m * 28L + nm / 25920L) - 2L;
#line 99
  nm %= 181440L;
#line 100
  l %= 19L;
#line 101
  dw = nm / 25920L;
#line 102
  nm %= 25920L;
#line 105
  if (nm >= 19440L) {
#line 108
    s ++;
#line 108
    dw ++;
  } else
#line 105
  if (l < 12L) {
#line 105
    if (dw == 3L) {
#line 105
      if (nm >= 9924L) {
#line 108
        s ++;
#line 108
        dw ++;
      } else {
#line 105
        goto _L___0;
      }
    } else {
#line 105
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 105
  if (l < 7L) {
#line 105
    if (dw == 2L) {
#line 105
      if (nm >= 16789L) {
#line 108
        s ++;
#line 108
        dw ++;
      }
    }
  }
#line 110
  if (dw == 1L) {
#line 111
    s ++;
  } else
#line 110
  if (dw == 4L) {
#line 111
    s ++;
  } else
#line 110
  if (dw == 6L) {
#line 111
    s ++;
  }
#line 112
  return (s);
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/hbcal.c"
int DaysInHebYear(int y ) 
{ 
  long thisyear ;
  long nextyear ;

  {
  {
#line 127
  thisyear = DaysToHebYear(y - 3744);
#line 128
  nextyear = DaysToHebYear(y - 3743);
  }
#line 129
  return ((int )(nextyear - thisyear));
}
}
#line 142 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/hbcal.c"
static char monlen[13]  = 
#line 142
  {      (char)30,      (char)29,      (char)30,      (char)29, 
        (char)30,      (char)0,      (char)29,      (char)30, 
        (char)29,      (char)30,      (char)29,      (char)30, 
        (char)29};
#line 140 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/hbcal.c"
char const   *DaysInHebMonths(int ylen ) 
{ 


  {
#line 146
  if (ylen > 355) {
#line 147
    monlen[5] = (char)30;
#line 148
    ylen -= 30;
  } else {
#line 149
    monlen[5] = (char)0;
  }
#line 151
  if (ylen == 353) {
#line 151
    monlen[2] = (char)29;
  } else {
#line 151
    monlen[2] = (char)30;
  }
#line 152
  if (ylen == 355) {
#line 152
    monlen[1] = (char)30;
  } else {
#line 152
    monlen[1] = (char)29;
  }
#line 154
  return ((char const   *)(monlen));
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/hbcal.c"
int HebToJul(int hy , int hm , int hd ) 
{ 
  int ylen ;
  char const   *monlens ;
  int rh ;
  int m ;

  {
#line 174
  if (hy - 3761 < 1990) {
#line 174
    return (-1);
  } else
#line 174
  if (hy - 3760 > 5990) {
#line 174
    return (-1);
  }
  {
#line 176
  ylen = DaysInHebYear(hy);
#line 177
  monlens = DaysInHebMonths(ylen);
#line 180
  rh = RoshHashana(hy);
#line 183
  m = 0;
  }
  {
#line 183
  while (1) {
    while_continue: /* CIL Label */ ;
#line 183
    if (! (m < hm)) {
#line 183
      goto while_break;
    }
#line 183
    rh += (int )*(monlens + m);
#line 183
    m ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 186
  rh += hd - 1;
#line 187
  return (rh);
}
}
#line 199 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/hbcal.c"
void JulToHeb(int jul , int *hy , int *hm , int *hd ) 
{ 
  int y ;
  int m ;
  int d ;
  int rh ;
  int ylen ;
  char const   *monlen___0 ;

  {
  {
#line 206
  FromJulian(jul, & y, & m, & d);
#line 207
  y += 3763;
  }
  {
#line 210
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 210
    rh = RoshHashana(y);
    }
#line 210
    if (! (rh > jul)) {
#line 210
      goto while_break;
    }
#line 210
    y --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 213
  jul -= rh;
#line 214
  ylen = DaysInHebYear(y);
#line 215
  monlen___0 = DaysInHebMonths(ylen);
#line 216
  m = 0;
  }
  {
#line 217
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 217
    if (! (jul >= (int )*(monlen___0 + m))) {
#line 217
      if (! (! *(monlen___0 + m))) {
#line 217
        goto while_break___0;
      }
    }
#line 218
    jul -= (int )*(monlen___0 + m);
#line 219
    m ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 222
  *hy = y;
#line 223
  *hm = m;
#line 224
  *hd = jul + 1;
#line 225
  return;
}
}
#line 235 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/hbcal.c"
int HebNameToNum(char const   *mname ) 
{ 
  int i ;
  int m ;
  int tmp ;

  {
#line 238
  m = -1;
#line 240
  i = 0;
  {
#line 240
  while (1) {
    while_continue: /* CIL Label */ ;
#line 240
    if (! (i < 14)) {
#line 240
      goto while_break;
    }
    {
#line 241
    tmp = StrCmpi(mname, HebMonthNames[i]);
    }
#line 241
    if (! tmp) {
#line 242
      m = i;
#line 243
      goto while_break;
    }
#line 240
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 246
  return (m);
}
}
#line 257 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/hbcal.c"
char const   *HebMonthName(int m , int y ) 
{ 


  {
#line 259
  if (m != 5) {
#line 259
    if (m != 6) {
#line 259
      return (HebMonthNames[m]);
    }
  }
#line 261
  if (! HebIsLeap[(y - 1) % 19]) {
#line 261
    return (HebMonthNames[13]);
  } else {
#line 262
    return (HebMonthNames[m]);
  }
}
}
#line 293 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/hbcal.c"
int GetValidHebDate(int yin , int min , int din , int adarbehave , int *mout , int *dout ,
                    int jahr ) 
{ 
  char const   *monlen___0 ;
  int ylen ;

  {
#line 299
  *mout = min;
#line 300
  *dout = din;
#line 303
  if (din < 1) {
#line 304
    *dout = -1;
#line 305
    return (60);
  } else
#line 303
  if (din > (int )MaxMonLen[min]) {
#line 304
    *dout = -1;
#line 305
    return (60);
  } else
#line 303
  if (min < 0) {
#line 304
    *dout = -1;
#line 305
    return (60);
  } else
#line 303
  if (min > 13) {
#line 304
    *dout = -1;
#line 305
    return (60);
  }
  {
#line 308
  ylen = DaysInHebYear(yin);
#line 309
  monlen___0 = DaysInHebMonths(ylen);
  }
#line 312
  if (min == 13) {
    {
#line 314
    if (adarbehave == 1) {
#line 314
      goto case_1;
    }
#line 318
    if (adarbehave == 0) {
#line 318
      goto case_0;
    }
#line 320
    goto switch_default;
    case_1: /* CIL Label */ 
#line 314
    if (*(monlen___0 + 5)) {
#line 314
      min = 5;
#line 314
      *mout = min;
    } else {
#line 315
      min = 6;
#line 315
      *mout = min;
    }
#line 316
    goto switch_break;
    case_0: /* CIL Label */ 
#line 318
    min = 6;
#line 318
    *mout = min;
#line 318
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 321
    Eprint("GetValidHebDate: Bad adarbehave value %d", adarbehave);
    }
#line 322
    return (23);
    switch_break: /* CIL Label */ ;
    }
  }
#line 326
  if (din <= (int )*(monlen___0 + min)) {
#line 326
    return (0);
  }
  {
#line 329
  if (jahr == 0) {
#line 329
    goto case_0___0;
  }
#line 331
  if (jahr == 1) {
#line 331
    goto case_1___0;
  }
#line 354
  if (jahr == 2) {
#line 354
    goto case_2;
  }
#line 377
  goto switch_default___0;
  case_0___0: /* CIL Label */ 
#line 329
  return (24);
  case_1___0: /* CIL Label */ 
#line 332
  if (min == 2) {
#line 333
    *mout = 3;
#line 334
    *dout = 1;
#line 335
    return (0);
  } else
#line 336
  if (min == 1) {
#line 337
    *mout = 2;
#line 338
    *dout = 1;
#line 339
    return (0);
  } else
#line 340
  if (min == 5) {
#line 341
    if (din > 29) {
#line 342
      *dout = 1;
#line 343
      *mout = 7;
    } else {
#line 345
      *dout = din;
#line 346
      *mout = 6;
    }
#line 348
    return (0);
  }
  {
#line 351
  Eprint("GetValidHebDate: (1) software error! %d", jahr);
  }
#line 352
  return (23);
  case_2: /* CIL Label */ 
#line 355
  if (min == 2) {
#line 356
    *mout = 2;
#line 357
    *dout = 29;
#line 358
    return (0);
  } else
#line 359
  if (min == 1) {
#line 360
    *mout = 1;
#line 361
    *dout = 29;
#line 362
    return (0);
  } else
#line 363
  if (min == 5) {
#line 364
    if (din > 29) {
#line 365
      *dout = 30;
#line 366
      *mout = 4;
    } else {
#line 368
      *mout = 6;
#line 369
      *dout = din;
    }
#line 371
    return (0);
  }
  {
#line 374
  Eprint("GetValidHebDate: (2) software error! %d", jahr);
  }
#line 375
  return (23);
  switch_default___0: /* CIL Label */ 
  {
#line 378
  Eprint("GetValidHebDate: (3) software error! %d", jahr);
  }
#line 379
  return (23);
  switch_break___0: /* CIL Label */ ;
  }
}
}
#line 393 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/hbcal.c"
int GetNextHebrewDate(int julstart , int hm , int hd , int jahr , int adarbehave ,
                      int *ans ) 
{ 
  int r ;
  int yout ;
  int mout ;
  int dout ;
  int jul ;
  int adarflag ;

  {
#line 396
  jul = 1;
#line 397
  adarflag = adarbehave;
#line 404
  if (adarbehave == 2) {
#line 404
    adarflag = 1;
  }
  {
#line 406
  JulToHeb(julstart, & yout, & mout, & dout);
#line 408
  r = 1;
  }
  {
#line 409
  while (1) {
    while_continue: /* CIL Label */ ;
#line 409
    if (! r) {
#line 409
      goto while_break;
    }
    {
#line 410
    r = GetValidHebDate(yout, hm, hd, adarflag, & mout, & dout, jahr);
    }
#line 411
    if (dout == -1) {
#line 411
      return (r);
    }
#line 412
    if (r) {
#line 413
      if (adarbehave == 2) {
#line 413
        if (hm == 13) {
#line 414
          if (adarflag == 1) {
#line 415
            adarflag = 0;
          } else {
#line 417
            adarflag = 1;
#line 418
            yout ++;
          }
        } else {
#line 420
          yout ++;
        }
      } else {
#line 420
        yout ++;
      }
#line 421
      goto while_continue;
    }
    {
#line 423
    jul = HebToJul(yout, mout, dout);
    }
#line 424
    if (jul < 0) {
#line 424
      return (15);
    }
#line 425
    if (jul >= julstart) {
#line 425
      goto while_break;
    } else {
#line 427
      if (adarbehave == 2) {
#line 427
        if (hm == 13) {
#line 428
          if (adarflag == 1) {
#line 429
            adarflag = 0;
          } else {
#line 431
            adarflag = 1;
#line 432
            yout ++;
          }
        } else {
#line 434
          yout ++;
        }
      } else {
#line 434
        yout ++;
      }
#line 435
      r = 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 438
  *ans = jul;
#line 439
  return (0);
}
}
#line 449 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/hbcal.c"
int ComputeJahr(int y , int m , int d , int *ans ) 
{ 
  char const   *monlen___0 ;
  int len ;

  {
  {
#line 454
  *ans = 0;
#line 456
  len = DaysInHebYear(y);
#line 457
  monlen___0 = DaysInHebMonths(len);
  }
#line 460
  if (m == 5) {
#line 460
    if ((int const   )*(monlen___0 + m) == 0) {
      {
#line 461
      Eprint("No Adar A in %d", y);
      }
#line 462
      return (60);
    }
  }
#line 466
  if (d < 1) {
#line 467
    return (60);
  } else
#line 466
  if (d > (int )MaxMonLen[m]) {
#line 467
    return (60);
  } else
#line 466
  if (m < 0) {
#line 467
    return (60);
  } else
#line 466
  if (m > 13) {
#line 467
    return (60);
  }
#line 470
  if (d > (int )*(monlen___0 + m)) {
    {
#line 471
    Eprint("%d %s %d: %s", d, HebMonthNames[m], y, ErrMsg[60]);
    }
#line 472
    return (60);
  }
#line 476
  if (m == 5) {
#line 477
    *ans = 2;
#line 478
    return (0);
  }
  {
#line 482
  len = DaysInHebYear(y + 1);
#line 483
  monlen___0 = DaysInHebMonths(len);
  }
#line 485
  if (d > (int )*(monlen___0 + m)) {
#line 485
    *ans = 1;
  } else {
#line 486
    *ans = 2;
  }
#line 488
  return (0);
}
}
#line 622 "/usr/include/stdio.h"
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/dynbuf.c"
static int DBufMakeRoom(DynamicBuffer *dbuf , int n ) 
{ 
  int size ;
  char *buf___1 ;
  void *tmp ;

  {
#line 35
  size = dbuf->allocatedLen;
#line 38
  if (size > n) {
#line 38
    return (0);
  }
  {
#line 40
  while (1) {
    while_continue: /* CIL Label */ ;
#line 40
    if (! (size <= n)) {
#line 40
      goto while_break;
    }
#line 41
    size *= 2;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 45
  tmp = malloc((size_t )size);
#line 45
  buf___1 = (char *)tmp;
  }
#line 46
  if (! buf___1) {
#line 46
    return (9);
  }
  {
#line 49
  strcpy((char */* __restrict  */)buf___1, (char const   */* __restrict  */)dbuf->buffer);
  }
#line 52
  if ((unsigned long )dbuf->buffer != (unsigned long )(dbuf->staticBuf)) {
    {
#line 52
    free((void *)dbuf->buffer);
    }
  }
#line 53
  dbuf->buffer = buf___1;
#line 54
  dbuf->allocatedLen = size;
#line 55
  return (0);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/dynbuf.c"
void DBufInit(DynamicBuffer *dbuf ) 
{ 


  {
#line 69
  dbuf->buffer = dbuf->staticBuf;
#line 70
  dbuf->len = 0;
#line 71
  dbuf->allocatedLen = 128;
#line 72
  *(dbuf->buffer + 0) = (char)0;
#line 73
  return;
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/dynbuf.c"
int DBufPutcFN(DynamicBuffer *dbuf , char c ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 87
  if (dbuf->allocatedLen == dbuf->len + 1) {
    {
#line 88
    tmp = DBufMakeRoom(dbuf, dbuf->len + 1);
    }
#line 88
    if (tmp != 0) {
#line 88
      return (9);
    }
  }
#line 90
  tmp___0 = dbuf->len;
#line 90
  (dbuf->len) ++;
#line 90
  *(dbuf->buffer + tmp___0) = c;
#line 91
  *(dbuf->buffer + dbuf->len) = (char)0;
#line 92
  return (0);
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/dynbuf.c"
int DBufPuts(DynamicBuffer *dbuf , char const   *str ) 
{ 
  int l ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 107
  tmp = strlen(str);
#line 107
  l = (int )tmp;
  }
#line 108
  if (! l) {
#line 108
    return (0);
  }
  {
#line 110
  tmp___0 = DBufMakeRoom(dbuf, dbuf->len + l);
  }
#line 110
  if (tmp___0 != 0) {
#line 110
    return (9);
  }
  {
#line 111
  strcpy((char */* __restrict  */)(dbuf->buffer + dbuf->len), (char const   */* __restrict  */)str);
#line 112
  dbuf->len += l;
  }
#line 113
  return (0);
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/dynbuf.c"
void DBufFree(DynamicBuffer *dbuf ) 
{ 


  {
#line 127
  if ((unsigned long )dbuf->buffer != (unsigned long )(dbuf->staticBuf)) {
    {
#line 127
    free((void *)dbuf->buffer);
    }
  }
  {
#line 128
  DBufInit(dbuf);
  }
#line 129
  return;
}
}
#line 142 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/dynbuf.c"
int DBufGets(DynamicBuffer *dbuf , FILE *fp___0 ) 
{ 
  char tmp[256] ;
  int busy ;
  int l ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
  {
#line 145
  busy = 1;
#line 148
  DBufFree(dbuf);
#line 153
  *(dbuf->buffer) = (char)0;
#line 154
  fgets((char */* __restrict  */)dbuf->buffer, dbuf->allocatedLen, (FILE */* __restrict  */)fp___0);
  }
#line 155
  if (! *(dbuf->buffer)) {
#line 155
    return (0);
  }
  {
#line 156
  tmp___0 = strlen((char const   *)dbuf->buffer);
#line 156
  dbuf->len = (int )tmp___0;
#line 157
  l = dbuf->len - 1;
  }
#line 158
  if ((int )*(dbuf->buffer + l) == 10) {
#line 159
    *(dbuf->buffer + l) = (char)0;
#line 160
    dbuf->len = l;
#line 161
    return (0);
  }
  {
#line 164
  while (1) {
    while_continue: /* CIL Label */ ;
#line 164
    if (! busy) {
#line 164
      goto while_break;
    }
    {
#line 165
    tmp[0] = (char)0;
#line 166
    fgets((char */* __restrict  */)(tmp), 256, (FILE */* __restrict  */)fp___0);
    }
#line 167
    if (! tmp[0]) {
#line 167
      return (0);
    }
    {
#line 168
    tmp___1 = strlen((char const   *)(tmp));
#line 168
    l = (int )(tmp___1 - 1UL);
    }
#line 169
    if ((int )tmp[l] == 10) {
#line 170
      tmp[l] = (char)0;
#line 171
      busy = 0;
    }
    {
#line 173
    tmp___2 = DBufPuts(dbuf, (char const   *)(tmp));
    }
#line 173
    if (tmp___2 != 0) {
#line 173
      return (9);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 175
  return (0);
}
}
#line 58 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) atan)(double __x ) ;
#line 60
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) atan2)(double __y ,
                                                                               double __x ) ;
#line 63
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) cos)(double __x ) ;
#line 65
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sin)(double __x ) ;
#line 67
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) tan)(double __x ) ;
#line 156
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sqrt)(double __x ) ;
#line 184
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) floor)(double __x )  __attribute__((__const__)) ;
#line 132 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/protos.h"
void LocalToUTC(int locdate , int loctime , int *utcdate , int *utctime ) ;
#line 133
void UTCToLocal(int utcdate , int utctime , int *locdate , int *loctime ) ;
#line 134
int MoonPhase(int date , int time___0 ) ;
#line 135
void HuntPhase(int startdate , int starttim , int phas , int *date , int *time___0 ) ;
#line 74 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/moon.c"
static long jdate(int y , int mon , int day ) ;
#line 75
static double jtime(int y , int mon , int day , int hour , int min , int sec ) ;
#line 76
static void jyear(double td , int *yy , int *mm , int *dd ) ;
#line 77
static void jhms(double j , int *h , int *m , int *s ) ;
#line 78
static double meanphase(double sdate , double phase___0 , double *usek ) ;
#line 79
static double truephase(double k , double phase___0 ) ;
#line 80
static double kepler(double m , double ecc ) ;
#line 81
static double phase(double pdate , double *pphase , double *mage , double *dist ,
                    double *angdia , double *sudist , double *suangdia ) ;
#line 150 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/moon.c"
static long jdate(int y , int mon , int day ) 
{ 
  long c ;
  long m ;

  {
#line 154
  m = (long )(mon + 1);
#line 155
  if (m > 2L) {
#line 156
    m -= 3L;
  } else {
#line 158
    m += 9L;
#line 159
    y --;
  }
#line 161
  c = (long )y / 100L;
#line 162
  y = (int )((long )y - 100L * c);
#line 163
  return (((((long )day + (c * 146097L) / 4L) + ((long )y * 1461L) / 4L) + (m * 153L + 2L) / 5L) + 1721119L);
}
}
#line 174 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/moon.c"
static double jtime(int y , int mon , int day , int hour , int min , int sec ) 
{ 
  long tmp ;

  {
  {
#line 176
  tmp = jdate(y, mon, day);
  }
#line 176
  return (((double )tmp - 0.5) + (double )(((long )sec + 60L * (long )min) + 3600L * (long )hour) / 86400.0);
}
}
#line 187 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/moon.c"
static void jyear(double td , int *yy , int *mm , int *dd ) 
{ 
  double j ;
  double d ;
  double y ;
  double m ;

  {
  {
#line 191
  td += 0.5;
#line 192
  j = floor(td);
#line 193
  j -= 1721119.0;
#line 194
  y = floor(((double )4 * j - (double )1) / 146097.0);
#line 195
  j = j * 4.0 - (1.0 + 146097.0 * y);
#line 196
  d = floor(j / 4.0);
#line 197
  j = floor((4.0 * d + 3.0) / 1461.0);
#line 198
  d = (4.0 * d + 3.0) - 1461.0 * j;
#line 199
  d = floor((d + 4.0) / 4.0);
#line 200
  m = floor((5.0 * d - (double )3) / 153.0);
#line 201
  d = 5.0 * d - (3.0 + 153.0 * m);
#line 202
  d = floor((d + 5.0) / 5.0);
#line 203
  y = 100.0 * y + j;
  }
#line 204
  if (m < 10.0) {
#line 205
    m += (double )2;
  } else {
#line 207
    m -= (double )10;
#line 208
    y += (double )1;
  }
#line 210
  *yy = (int )y;
#line 211
  *mm = (int )m;
#line 212
  *dd = (int )d;
#line 213
  return;
}
}
#line 222 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/moon.c"
static void jhms(double j , int *h , int *m , int *s ) 
{ 
  long ij ;
  double tmp ;

  {
  {
#line 226
  j += 0.5;
#line 227
  tmp = floor(j);
#line 227
  ij = (long )((j - tmp) * 86400.0);
#line 228
  *h = (int )(ij / 3600L);
#line 229
  *m = (int )((ij / 60L) % 60L);
#line 230
  *s = (int )(ij % 60L);
  }
#line 231
  return;
}
}
#line 250 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/moon.c"
static double meanphase(double sdate , double phase___0 , double *usek ) 
{ 
  double k ;
  double t ;
  double t2 ;
  double t3 ;
  double nt1 ;
  double tmp ;
  double tmp___0 ;

  {
  {
#line 260
  k = (sdate - 2415020.0) / 29.53058868;
#line 263
  t = (sdate - 2415020.0) / 36525.0;
#line 264
  t2 = t * t;
#line 265
  t3 = t2 * t;
#line 267
  tmp = floor(k);
#line 267
  k = tmp + phase___0;
#line 267
  *usek = k;
#line 268
  tmp___0 = sin(((166.56 + 132.87 * t) - 0.009173 * t2) * (3.14159265358979323846 / 180.0));
#line 268
  nt1 = (((2415020.75933 + 29.53058868 * k) + 0.0001178 * t2) - 0.000000155 * t3) + 0.00033 * tmp___0;
  }
#line 273
  return (nt1);
}
}
#line 286 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/moon.c"
static double truephase(double k , double phase___0 ) 
{ 
  double t ;
  double t2 ;
  double t3 ;
  double pt ;
  double m ;
  double mprime ;
  double f ;
  int apcor ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;
  double tmp___10 ;
  double tmp___11 ;
  double tmp___12 ;
  double tmp___13 ;
  double tmp___14 ;
  double tmp___15 ;
  double tmp___16 ;
  double tmp___17 ;
  double tmp___18 ;
  double tmp___19 ;
  double tmp___20 ;
  double tmp___21 ;
  double tmp___22 ;
  double tmp___23 ;
  double tmp___24 ;
  double tmp___25 ;
  double tmp___26 ;
  double tmp___27 ;
  double tmp___28 ;
  double tmp___29 ;
  double tmp___30 ;
  double tmp___31 ;
  double tmp___32 ;
  double tmp___33 ;
  double tmp___34 ;

  {
  {
#line 289
  apcor = 0;
#line 291
  k += phase___0;
#line 292
  t = k / 1236.8531;
#line 294
  t2 = t * t;
#line 295
  t3 = t2 * t;
#line 296
  tmp = sin(((166.56 + 132.87 * t) - 0.009173 * t2) * (3.14159265358979323846 / 180.0));
#line 296
  pt = (((2415020.75933 + 29.53058868 * k) + 0.0001178 * t2) - 0.000000155 * t3) + 0.00033 * tmp;
#line 302
  m = ((359.2242 + 29.10535608 * k) - 0.0000333 * t2) - 0.00000347 * t3;
#line 306
  mprime = ((306.0253 + 385.81691806 * k) + 0.0107306 * t2) + 0.00001236 * t3;
#line 310
  f = ((21.2964 + 390.67050646 * k) - 0.0016528 * t2) - 0.00000239 * t3;
  }
#line 314
  if (phase___0 < 0.01) {
#line 314
    goto _L___0;
  } else {
#line 314
    if (phase___0 - 0.5 < (double )0) {
#line 314
      tmp___34 = - (phase___0 - 0.5);
    } else {
#line 314
      tmp___34 = phase___0 - 0.5;
    }
#line 314
    if (tmp___34 < 0.01) {
      _L___0: /* CIL Label */ 
      {
#line 318
      tmp___0 = sin(m * (3.14159265358979323846 / 180.0));
#line 318
      tmp___1 = sin(((double )2 * m) * (3.14159265358979323846 / 180.0));
#line 318
      tmp___2 = sin(mprime * (3.14159265358979323846 / 180.0));
#line 318
      tmp___3 = sin(((double )2 * mprime) * (3.14159265358979323846 / 180.0));
#line 318
      tmp___4 = sin(((double )3 * mprime) * (3.14159265358979323846 / 180.0));
#line 318
      tmp___5 = sin(((double )2 * f) * (3.14159265358979323846 / 180.0));
#line 318
      tmp___6 = sin((m + mprime) * (3.14159265358979323846 / 180.0));
#line 318
      tmp___7 = sin((m - mprime) * (3.14159265358979323846 / 180.0));
#line 318
      tmp___8 = sin(((double )2 * f + m) * (3.14159265358979323846 / 180.0));
#line 318
      tmp___9 = sin(((double )2 * f - m) * (3.14159265358979323846 / 180.0));
#line 318
      tmp___10 = sin(((double )2 * f + mprime) * (3.14159265358979323846 / 180.0));
#line 318
      tmp___11 = sin(((double )2 * f - mprime) * (3.14159265358979323846 / 180.0));
#line 318
      tmp___12 = sin((m + (double )2 * mprime) * (3.14159265358979323846 / 180.0));
#line 318
      pt += ((((((((((((0.1734 - 0.000393 * t) * tmp___0 + 0.0021 * tmp___1) - 0.4068 * tmp___2) + 0.0161 * tmp___3) - 0.0004 * tmp___4) + 0.0104 * tmp___5) - 0.0051 * tmp___6) - 0.0074 * tmp___7) + 0.0004 * tmp___8) - 0.0004 * tmp___9) - 0.0006 * tmp___10) + 0.0010 * tmp___11) + 0.0005 * tmp___12;
#line 331
      apcor = 1;
      }
    } else {
#line 332
      if (phase___0 - 0.25 < (double )0) {
#line 332
        tmp___32 = - (phase___0 - 0.25);
      } else {
#line 332
        tmp___32 = phase___0 - 0.25;
      }
#line 332
      if (tmp___32 < 0.01) {
#line 332
        goto _L;
      } else {
#line 332
        if (phase___0 - 0.75 < (double )0) {
#line 332
          tmp___33 = - (phase___0 - 0.75);
        } else {
#line 332
          tmp___33 = phase___0 - 0.75;
        }
#line 332
        if (tmp___33 < 0.01) {
          _L: /* CIL Label */ 
          {
#line 333
          tmp___13 = sin(m * (3.14159265358979323846 / 180.0));
#line 333
          tmp___14 = sin(((double )2 * m) * (3.14159265358979323846 / 180.0));
#line 333
          tmp___15 = sin(mprime * (3.14159265358979323846 / 180.0));
#line 333
          tmp___16 = sin(((double )2 * mprime) * (3.14159265358979323846 / 180.0));
#line 333
          tmp___17 = sin(((double )3 * mprime) * (3.14159265358979323846 / 180.0));
#line 333
          tmp___18 = sin(((double )2 * f) * (3.14159265358979323846 / 180.0));
#line 333
          tmp___19 = sin((m + mprime) * (3.14159265358979323846 / 180.0));
#line 333
          tmp___20 = sin((m - mprime) * (3.14159265358979323846 / 180.0));
#line 333
          tmp___21 = sin(((double )2 * f + m) * (3.14159265358979323846 / 180.0));
#line 333
          tmp___22 = sin(((double )2 * f - m) * (3.14159265358979323846 / 180.0));
#line 333
          tmp___23 = sin(((double )2 * f + mprime) * (3.14159265358979323846 / 180.0));
#line 333
          tmp___24 = sin(((double )2 * f - mprime) * (3.14159265358979323846 / 180.0));
#line 333
          tmp___25 = sin((m + (double )2 * mprime) * (3.14159265358979323846 / 180.0));
#line 333
          tmp___26 = sin((m - (double )2 * mprime) * (3.14159265358979323846 / 180.0));
#line 333
          tmp___27 = sin(((double )2 * m + mprime) * (3.14159265358979323846 / 180.0));
#line 333
          pt += ((((((((((((((0.1721 - 0.0004 * t) * tmp___13 + 0.0021 * tmp___14) - 0.6280 * tmp___15) + 0.0089 * tmp___16) - 0.0004 * tmp___17) + 0.0079 * tmp___18) - 0.0119 * tmp___19) - 0.0047 * tmp___20) + 0.0003 * tmp___21) - 0.0004 * tmp___22) - 0.0006 * tmp___23) + 0.0021 * tmp___24) + 0.0003 * tmp___25) + 0.0004 * tmp___26) - 0.0003 * tmp___27;
          }
#line 348
          if (phase___0 < 0.5) {
            {
#line 350
            tmp___28 = cos(m * (3.14159265358979323846 / 180.0));
#line 350
            tmp___29 = cos(mprime * (3.14159265358979323846 / 180.0));
#line 350
            pt += (0.0028 - 0.0004 * tmp___28) + 0.0003 * tmp___29;
            }
          } else {
            {
#line 353
            tmp___30 = cos(m * (3.14159265358979323846 / 180.0));
#line 353
            tmp___31 = cos(mprime * (3.14159265358979323846 / 180.0));
#line 353
            pt += (- 0.0028 + 0.0004 * tmp___30) - 0.0003 * tmp___31;
            }
          }
#line 354
          apcor = 1;
        }
      }
    }
  }
#line 356
  if (! apcor) {
#line 356
    return (0.0);
  }
#line 357
  return (pt);
}
}
#line 367 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/moon.c"
static double kepler(double m , double ecc ) 
{ 
  double e ;
  double delta ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
#line 372
  m *= 3.14159265358979323846 / 180.0;
#line 372
  e = m;
  {
#line 373
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 374
    tmp = sin(e);
#line 374
    delta = (e - ecc * tmp) - m;
#line 375
    tmp___0 = cos(e);
#line 375
    e -= delta / ((double )1 - ecc * tmp___0);
    }
#line 373
    if (delta < (double )0) {
#line 373
      tmp___1 = - delta;
    } else {
#line 373
      tmp___1 = delta;
    }
#line 373
    if (! (tmp___1 > 1E-6)) {
#line 373
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 377
  return (e);
}
}
#line 395 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/moon.c"
static double phase(double pdate , double *pphase , double *mage , double *dist ,
                    double *angdia , double *sudist , double *suangdia ) 
{ 
  double Day ;
  double N ;
  double M ;
  double Ec ;
  double Lambdasun ;
  double ml ;
  double MM ;
  double MN ;
  double Ev ;
  double Ae ;
  double A3 ;
  double MmP ;
  double mEc ;
  double A4 ;
  double lP ;
  double V ;
  double lPP ;
  double NP ;
  double y ;
  double x ;
  double Lambdamoon ;
  double MoonAge ;
  double MoonPhase___0 ;
  double MoonDist ;
  double MoonDFrac ;
  double MoonAng ;
  double F ;
  double SunDist ;
  double SunAng ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;
  double tmp___10 ;
  double tmp___11 ;
  double tmp___12 ;
  double tmp___13 ;
  double tmp___14 ;
  double tmp___15 ;
  double tmp___16 ;
  double tmp___17 ;
  double tmp___18 ;
  double tmp___19 ;
  double tmp___20 ;
  double tmp___21 ;
  double tmp___22 ;

  {
  {
#line 412
  Day = pdate - 2444238.5;
#line 413
  tmp = floor((((double )360 / 365.2422) * Day) / 360.0);
#line 413
  N = ((double )360 / 365.2422) * Day - 360.0 * tmp;
#line 414
  tmp___0 = floor(((N + 278.833540) - 282.596403) / 360.0);
#line 414
  M = ((N + 278.833540) - 282.596403) - 360.0 * tmp___0;
#line 416
  Ec = kepler(M, 0.016718);
#line 417
  tmp___1 = sqrt(((double )1 + 0.016718) / ((double )1 - 0.016718));
#line 417
  tmp___2 = tan(Ec / (double )2);
#line 417
  Ec = tmp___1 * tmp___2;
#line 418
  tmp___3 = atan(Ec);
#line 418
  Ec = (double )2 * (tmp___3 * (180.0 / 3.14159265358979323846));
#line 419
  tmp___4 = floor((Ec + 282.596403) / 360.0);
#line 419
  Lambdasun = (Ec + 282.596403) - 360.0 * tmp___4;
#line 422
  tmp___5 = cos(Ec * (3.14159265358979323846 / 180.0));
#line 422
  F = ((double )1 + 0.016718 * tmp___5) / ((double )1 - 0.016718 * 0.016718);
#line 423
  SunDist = 1.495985e8 / F;
#line 424
  SunAng = F * 0.533128;
#line 430
  tmp___6 = floor((13.1763966 * Day + 64.975464) / 360.0);
#line 430
  ml = (13.1763966 * Day + 64.975464) - 360.0 * tmp___6;
#line 433
  tmp___7 = floor(((ml - 0.1114041 * Day) - 349.383063) / 360.0);
#line 433
  MM = ((ml - 0.1114041 * Day) - 349.383063) - 360.0 * tmp___7;
#line 436
  tmp___8 = floor((151.950429 - 0.0529539 * Day) / 360.0);
#line 436
  MN = (151.950429 - 0.0529539 * Day) - 360.0 * tmp___8;
#line 439
  tmp___9 = sin(((double )2 * (ml - Lambdasun) - MM) * (3.14159265358979323846 / 180.0));
#line 439
  Ev = 1.2739 * tmp___9;
#line 442
  tmp___10 = sin(M * (3.14159265358979323846 / 180.0));
#line 442
  Ae = 0.1858 * tmp___10;
#line 445
  tmp___11 = sin(M * (3.14159265358979323846 / 180.0));
#line 445
  A3 = 0.37 * tmp___11;
#line 448
  MmP = ((MM + Ev) - Ae) - A3;
#line 451
  tmp___12 = sin(MmP * (3.14159265358979323846 / 180.0));
#line 451
  mEc = 6.2886 * tmp___12;
#line 454
  tmp___13 = sin(((double )2 * MmP) * (3.14159265358979323846 / 180.0));
#line 454
  A4 = 0.214 * tmp___13;
#line 457
  lP = (((ml + Ev) + mEc) - Ae) + A4;
#line 460
  tmp___14 = sin(((double )2 * (lP - Lambdasun)) * (3.14159265358979323846 / 180.0));
#line 460
  V = 0.6583 * tmp___14;
#line 463
  lPP = lP + V;
#line 466
  tmp___15 = sin(M * (3.14159265358979323846 / 180.0));
#line 466
  NP = MN - 0.16 * tmp___15;
#line 469
  tmp___16 = sin((lPP - NP) * (3.14159265358979323846 / 180.0));
#line 469
  tmp___17 = cos(5.145396 * (3.14159265358979323846 / 180.0));
#line 469
  y = tmp___16 * tmp___17;
#line 472
  x = cos((lPP - NP) * (3.14159265358979323846 / 180.0));
#line 475
  tmp___18 = atan2(y, x);
#line 475
  Lambdamoon = tmp___18 * (180.0 / 3.14159265358979323846);
#line 476
  Lambdamoon += NP;
#line 481
  MoonAge = lPP - Lambdasun;
#line 484
  tmp___19 = cos(MoonAge * (3.14159265358979323846 / 180.0));
#line 484
  MoonPhase___0 = ((double )1 - tmp___19) / (double )2;
#line 488
  tmp___20 = cos((MmP + mEc) * (3.14159265358979323846 / 180.0));
#line 488
  MoonDist = (384401.0 * ((double )1 - 0.054900 * 0.054900)) / ((double )1 + 0.054900 * tmp___20);
#line 493
  MoonDFrac = MoonDist / 384401.0;
#line 494
  MoonAng = 0.5181 / MoonDFrac;
  }
#line 496
  if (pphase) {
#line 496
    *pphase = MoonPhase___0;
  }
#line 497
  if (mage) {
    {
#line 497
    tmp___21 = floor(MoonAge / 360.0);
#line 497
    *mage = 29.53058868 * ((MoonAge - 360.0 * tmp___21) / 360.0);
    }
  }
#line 498
  if (dist) {
#line 498
    *dist = MoonDist;
  }
#line 499
  if (angdia) {
#line 499
    *angdia = MoonAng;
  }
#line 500
  if (sudist) {
#line 500
    *sudist = SunDist;
  }
#line 501
  if (suangdia) {
#line 501
    *suangdia = SunAng;
  }
  {
#line 502
  tmp___22 = floor(MoonAge / 360.0);
  }
#line 502
  return ((MoonAge - 360.0 * tmp___22) / 360.0);
}
}
#line 514 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/moon.c"
int MoonPhase(int date , int time___0 ) 
{ 
  int utcd ;
  int utct ;
  int y ;
  int m ;
  int d ;
  double jd ;
  double mp ;
  double tmp ;

  {
  {
#line 521
  LocalToUTC(date, time___0, & utcd, & utct);
#line 524
  FromJulian(utcd, & y, & m, & d);
#line 527
  jd = jtime(y, m, d, utct / 60, utct % 60, 0);
#line 530
  tmp = phase(jd, (double *)((void *)0), (double *)((void *)0), (double *)((void *)0),
              (double *)((void *)0), (double *)((void *)0), (double *)((void *)0));
#line 530
  mp = 360.0 * tmp;
  }
#line 531
  return ((int )mp);
}
}
#line 544 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/moon.c"
void HuntPhase(int startdate , int starttim , int phas , int *date , int *time___0 ) 
{ 
  int utcd ;
  int utct ;
  int y ;
  int m ;
  int d ;
  int h ;
  int min ;
  int s ;
  int d1 ;
  int t1 ;
  double k1 ;
  double k2 ;
  double jd ;
  double jdorig ;
  double nt1 ;
  double nt2 ;

  {
  {
#line 554
  LocalToUTC(startdate, starttim, & utcd, & utct);
#line 557
  FromJulian(utcd, & y, & m, & d);
#line 559
  jdorig = jtime(y, m, d, utct / 60, utct % 60, 0);
#line 560
  jd = jdorig - 45.0;
#line 561
  nt1 = meanphase(jd, 0.0, & k1);
  }
  {
#line 562
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 563
    jd += 29.53058868;
#line 564
    nt2 = meanphase(jd, 0.0, & k2);
    }
#line 565
    if (nt1 <= jdorig) {
#line 565
      if (nt2 > jdorig) {
#line 565
        goto while_break;
      }
    }
#line 566
    nt1 = nt2;
#line 567
    k1 = k2;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 569
  jd = truephase(k1, (double )phas / 4.0);
  }
#line 570
  if (jd < jdorig) {
    {
#line 570
    jd = truephase(k2, (double )phas / 4.0);
    }
  }
  {
#line 573
  jyear(jd, & y, & m, & d);
#line 574
  jhms(jd, & h, & min, & s);
#line 576
  d1 = Julian(y, m, d);
#line 577
  t1 = h * 60 + min;
#line 578
  UTCToLocal(d1, t1, date, time___0);
  }
#line 579
  return;
}
}
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 23 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/md5.h"
void MD5Init(struct MD5Context *ctx ) ;
#line 24
void MD5Update(struct MD5Context *ctx , unsigned char const   *buf___1 , unsigned int len ) ;
#line 26
void MD5Final(unsigned char *digest , struct MD5Context *ctx ) ;
#line 27
void MD5Transform(uint32 *buf___1 , uint32 const   *in ) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/md5.c"
static void byteReverse(unsigned char *buf___1 , unsigned int longs ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/md5.c"
static void byteReverse(unsigned char *buf___1 , unsigned int longs ) 
{ 
  uint32 t ;

  {
  {
#line 31
  while (1) {
    while_continue: /* CIL Label */ ;
#line 32
    t = ((((unsigned int )*(buf___1 + 3) << 8) | (unsigned int )*(buf___1 + 2)) << 16) | (((unsigned int )*(buf___1 + 1) << 8) | (unsigned int )*(buf___1 + 0));
#line 34
    *((uint32 *)buf___1) = t;
#line 35
    buf___1 += 4;
#line 31
    longs --;
#line 31
    if (! longs) {
#line 31
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 37
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/md5.c"
void MD5Init(struct MD5Context *ctx ) 
{ 


  {
#line 45
  ctx->buf[0] = (uint32 )1732584193;
#line 46
  ctx->buf[1] = 4023233417U;
#line 47
  ctx->buf[2] = 2562383102U;
#line 48
  ctx->buf[3] = (uint32 )271733878;
#line 50
  ctx->bits[0] = (uint32 )0;
#line 51
  ctx->bits[1] = (uint32 )0;
#line 52
  return;
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/md5.c"
void MD5Update(struct MD5Context *ctx , unsigned char const   *buf___1 , unsigned int len ) 
{ 
  uint32 t ;
  uint32 tmp ;
  unsigned char *p ;

  {
#line 64
  t = ctx->bits[0];
#line 65
  tmp = t + (len << 3);
#line 65
  ctx->bits[0] = tmp;
#line 65
  if (tmp < t) {
#line 66
    (ctx->bits[1]) ++;
  }
#line 67
  ctx->bits[1] += len >> 29;
#line 69
  t = (t >> 3) & 63U;
#line 73
  if (t) {
#line 74
    p = ctx->in + t;
#line 76
    t = 64U - t;
#line 77
    if (len < t) {
      {
#line 78
      memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)buf___1,
             (size_t )len);
      }
#line 79
      return;
    }
    {
#line 81
    memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)buf___1, (size_t )t);
#line 82
    byteReverse(ctx->in, 16U);
#line 83
    MD5Transform((uint32 *)(ctx->buf), (uint32 const   *)((uint32 *)(ctx->in)));
#line 84
    buf___1 += t;
#line 85
    len -= t;
    }
  }
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if (! (len >= 64U)) {
#line 89
      goto while_break;
    }
    {
#line 90
    memcpy((void */* __restrict  */)(ctx->in), (void const   */* __restrict  */)buf___1,
           (size_t )64);
#line 91
    byteReverse(ctx->in, 16U);
#line 92
    MD5Transform((uint32 *)(ctx->buf), (uint32 const   *)((uint32 *)(ctx->in)));
#line 93
    buf___1 += 64;
#line 94
    len -= 64U;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 99
  memcpy((void */* __restrict  */)(ctx->in), (void const   */* __restrict  */)buf___1,
         (size_t )len);
  }
#line 100
  return;
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/md5.c"
void MD5Final(unsigned char *digest , struct MD5Context *ctx ) 
{ 
  unsigned int count ;
  unsigned char *p ;
  unsigned char *tmp ;

  {
#line 112
  count = (ctx->bits[0] >> 3) & 63U;
#line 116
  p = ctx->in + count;
#line 117
  tmp = p;
#line 117
  p ++;
#line 117
  *tmp = (unsigned char)128;
#line 120
  count = 63U - count;
#line 123
  if (count < 8U) {
    {
#line 125
    memset((void *)p, 0, (size_t )count);
#line 126
    byteReverse(ctx->in, 16U);
#line 127
    MD5Transform((uint32 *)(ctx->buf), (uint32 const   *)((uint32 *)(ctx->in)));
#line 130
    memset((void *)(ctx->in), 0, (size_t )56);
    }
  } else {
    {
#line 133
    memset((void *)p, 0, (size_t )(count - 8U));
    }
  }
  {
#line 135
  byteReverse(ctx->in, 14U);
#line 138
  *((uint32 *)(ctx->in) + 14) = ctx->bits[0];
#line 139
  *((uint32 *)(ctx->in) + 15) = ctx->bits[1];
#line 141
  MD5Transform((uint32 *)(ctx->buf), (uint32 const   *)((uint32 *)(ctx->in)));
#line 142
  byteReverse((unsigned char *)(ctx->buf), 4U);
#line 143
  memcpy((void */* __restrict  */)digest, (void const   */* __restrict  */)(ctx->buf),
         (size_t )16);
#line 144
  memset((void *)ctx, 0, sizeof(ctx));
  }
#line 145
  return;
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/md5.c"
void MD5Transform(uint32 *buf___1 , uint32 const   *in ) 
{ 
  register uint32 a ;
  register uint32 b ;
  register uint32 c ;
  register uint32 d ;

  {
#line 170
  a = *(buf___1 + 0);
#line 171
  b = *(buf___1 + 1);
#line 172
  c = *(buf___1 + 2);
#line 173
  d = *(buf___1 + 3);
#line 175
  a += ((d ^ (b & (c ^ d))) + (unsigned int )*(in + 0)) + 3614090360U;
#line 175
  a = (a << 7) | (a >> 25);
#line 175
  a += b;
#line 176
  d += ((c ^ (a & (b ^ c))) + (unsigned int )*(in + 1)) + 3905402710U;
#line 176
  d = (d << 12) | (d >> 20);
#line 176
  d += a;
#line 177
  c += ((b ^ (d & (a ^ b))) + (unsigned int )*(in + 2)) + 606105819U;
#line 177
  c = (c << 17) | (c >> 15);
#line 177
  c += d;
#line 178
  b += ((a ^ (c & (d ^ a))) + (unsigned int )*(in + 3)) + 3250441966U;
#line 178
  b = (b << 22) | (b >> 10);
#line 178
  b += c;
#line 179
  a += ((d ^ (b & (c ^ d))) + (unsigned int )*(in + 4)) + 4118548399U;
#line 179
  a = (a << 7) | (a >> 25);
#line 179
  a += b;
#line 180
  d += ((c ^ (a & (b ^ c))) + (unsigned int )*(in + 5)) + 1200080426U;
#line 180
  d = (d << 12) | (d >> 20);
#line 180
  d += a;
#line 181
  c += ((b ^ (d & (a ^ b))) + (unsigned int )*(in + 6)) + 2821735955U;
#line 181
  c = (c << 17) | (c >> 15);
#line 181
  c += d;
#line 182
  b += ((a ^ (c & (d ^ a))) + (unsigned int )*(in + 7)) + 4249261313U;
#line 182
  b = (b << 22) | (b >> 10);
#line 182
  b += c;
#line 183
  a += ((d ^ (b & (c ^ d))) + (unsigned int )*(in + 8)) + 1770035416U;
#line 183
  a = (a << 7) | (a >> 25);
#line 183
  a += b;
#line 184
  d += ((c ^ (a & (b ^ c))) + (unsigned int )*(in + 9)) + 2336552879U;
#line 184
  d = (d << 12) | (d >> 20);
#line 184
  d += a;
#line 185
  c += ((b ^ (d & (a ^ b))) + (unsigned int )*(in + 10)) + 4294925233U;
#line 185
  c = (c << 17) | (c >> 15);
#line 185
  c += d;
#line 186
  b += ((a ^ (c & (d ^ a))) + (unsigned int )*(in + 11)) + 2304563134U;
#line 186
  b = (b << 22) | (b >> 10);
#line 186
  b += c;
#line 187
  a += ((d ^ (b & (c ^ d))) + (unsigned int )*(in + 12)) + 1804603682U;
#line 187
  a = (a << 7) | (a >> 25);
#line 187
  a += b;
#line 188
  d += ((c ^ (a & (b ^ c))) + (unsigned int )*(in + 13)) + 4254626195U;
#line 188
  d = (d << 12) | (d >> 20);
#line 188
  d += a;
#line 189
  c += ((b ^ (d & (a ^ b))) + (unsigned int )*(in + 14)) + 2792965006U;
#line 189
  c = (c << 17) | (c >> 15);
#line 189
  c += d;
#line 190
  b += ((a ^ (c & (d ^ a))) + (unsigned int )*(in + 15)) + 1236535329U;
#line 190
  b = (b << 22) | (b >> 10);
#line 190
  b += c;
#line 192
  a += ((c ^ (d & (b ^ c))) + (unsigned int )*(in + 1)) + 4129170786U;
#line 192
  a = (a << 5) | (a >> 27);
#line 192
  a += b;
#line 193
  d += ((b ^ (c & (a ^ b))) + (unsigned int )*(in + 6)) + 3225465664U;
#line 193
  d = (d << 9) | (d >> 23);
#line 193
  d += a;
#line 194
  c += ((a ^ (b & (d ^ a))) + (unsigned int )*(in + 11)) + 643717713U;
#line 194
  c = (c << 14) | (c >> 18);
#line 194
  c += d;
#line 195
  b += ((d ^ (a & (c ^ d))) + (unsigned int )*(in + 0)) + 3921069994U;
#line 195
  b = (b << 20) | (b >> 12);
#line 195
  b += c;
#line 196
  a += ((c ^ (d & (b ^ c))) + (unsigned int )*(in + 5)) + 3593408605U;
#line 196
  a = (a << 5) | (a >> 27);
#line 196
  a += b;
#line 197
  d += ((b ^ (c & (a ^ b))) + (unsigned int )*(in + 10)) + 38016083U;
#line 197
  d = (d << 9) | (d >> 23);
#line 197
  d += a;
#line 198
  c += ((a ^ (b & (d ^ a))) + (unsigned int )*(in + 15)) + 3634488961U;
#line 198
  c = (c << 14) | (c >> 18);
#line 198
  c += d;
#line 199
  b += ((d ^ (a & (c ^ d))) + (unsigned int )*(in + 4)) + 3889429448U;
#line 199
  b = (b << 20) | (b >> 12);
#line 199
  b += c;
#line 200
  a += ((c ^ (d & (b ^ c))) + (unsigned int )*(in + 9)) + 568446438U;
#line 200
  a = (a << 5) | (a >> 27);
#line 200
  a += b;
#line 201
  d += ((b ^ (c & (a ^ b))) + (unsigned int )*(in + 14)) + 3275163606U;
#line 201
  d = (d << 9) | (d >> 23);
#line 201
  d += a;
#line 202
  c += ((a ^ (b & (d ^ a))) + (unsigned int )*(in + 3)) + 4107603335U;
#line 202
  c = (c << 14) | (c >> 18);
#line 202
  c += d;
#line 203
  b += ((d ^ (a & (c ^ d))) + (unsigned int )*(in + 8)) + 1163531501U;
#line 203
  b = (b << 20) | (b >> 12);
#line 203
  b += c;
#line 204
  a += ((c ^ (d & (b ^ c))) + (unsigned int )*(in + 13)) + 2850285829U;
#line 204
  a = (a << 5) | (a >> 27);
#line 204
  a += b;
#line 205
  d += ((b ^ (c & (a ^ b))) + (unsigned int )*(in + 2)) + 4243563512U;
#line 205
  d = (d << 9) | (d >> 23);
#line 205
  d += a;
#line 206
  c += ((a ^ (b & (d ^ a))) + (unsigned int )*(in + 7)) + 1735328473U;
#line 206
  c = (c << 14) | (c >> 18);
#line 206
  c += d;
#line 207
  b += ((d ^ (a & (c ^ d))) + (unsigned int )*(in + 12)) + 2368359562U;
#line 207
  b = (b << 20) | (b >> 12);
#line 207
  b += c;
#line 209
  a += (((b ^ c) ^ d) + (unsigned int )*(in + 5)) + 4294588738U;
#line 209
  a = (a << 4) | (a >> 28);
#line 209
  a += b;
#line 210
  d += (((a ^ b) ^ c) + (unsigned int )*(in + 8)) + 2272392833U;
#line 210
  d = (d << 11) | (d >> 21);
#line 210
  d += a;
#line 211
  c += (((d ^ a) ^ b) + (unsigned int )*(in + 11)) + 1839030562U;
#line 211
  c = (c << 16) | (c >> 16);
#line 211
  c += d;
#line 212
  b += (((c ^ d) ^ a) + (unsigned int )*(in + 14)) + 4259657740U;
#line 212
  b = (b << 23) | (b >> 9);
#line 212
  b += c;
#line 213
  a += (((b ^ c) ^ d) + (unsigned int )*(in + 1)) + 2763975236U;
#line 213
  a = (a << 4) | (a >> 28);
#line 213
  a += b;
#line 214
  d += (((a ^ b) ^ c) + (unsigned int )*(in + 4)) + 1272893353U;
#line 214
  d = (d << 11) | (d >> 21);
#line 214
  d += a;
#line 215
  c += (((d ^ a) ^ b) + (unsigned int )*(in + 7)) + 4139469664U;
#line 215
  c = (c << 16) | (c >> 16);
#line 215
  c += d;
#line 216
  b += (((c ^ d) ^ a) + (unsigned int )*(in + 10)) + 3200236656U;
#line 216
  b = (b << 23) | (b >> 9);
#line 216
  b += c;
#line 217
  a += (((b ^ c) ^ d) + (unsigned int )*(in + 13)) + 681279174U;
#line 217
  a = (a << 4) | (a >> 28);
#line 217
  a += b;
#line 218
  d += (((a ^ b) ^ c) + (unsigned int )*(in + 0)) + 3936430074U;
#line 218
  d = (d << 11) | (d >> 21);
#line 218
  d += a;
#line 219
  c += (((d ^ a) ^ b) + (unsigned int )*(in + 3)) + 3572445317U;
#line 219
  c = (c << 16) | (c >> 16);
#line 219
  c += d;
#line 220
  b += (((c ^ d) ^ a) + (unsigned int )*(in + 6)) + 76029189U;
#line 220
  b = (b << 23) | (b >> 9);
#line 220
  b += c;
#line 221
  a += (((b ^ c) ^ d) + (unsigned int )*(in + 9)) + 3654602809U;
#line 221
  a = (a << 4) | (a >> 28);
#line 221
  a += b;
#line 222
  d += (((a ^ b) ^ c) + (unsigned int )*(in + 12)) + 3873151461U;
#line 222
  d = (d << 11) | (d >> 21);
#line 222
  d += a;
#line 223
  c += (((d ^ a) ^ b) + (unsigned int )*(in + 15)) + 530742520U;
#line 223
  c = (c << 16) | (c >> 16);
#line 223
  c += d;
#line 224
  b += (((c ^ d) ^ a) + (unsigned int )*(in + 2)) + 3299628645U;
#line 224
  b = (b << 23) | (b >> 9);
#line 224
  b += c;
#line 226
  a += ((c ^ (b | ~ d)) + (unsigned int )*(in + 0)) + 4096336452U;
#line 226
  a = (a << 6) | (a >> 26);
#line 226
  a += b;
#line 227
  d += ((b ^ (a | ~ c)) + (unsigned int )*(in + 7)) + 1126891415U;
#line 227
  d = (d << 10) | (d >> 22);
#line 227
  d += a;
#line 228
  c += ((a ^ (d | ~ b)) + (unsigned int )*(in + 14)) + 2878612391U;
#line 228
  c = (c << 15) | (c >> 17);
#line 228
  c += d;
#line 229
  b += ((d ^ (c | ~ a)) + (unsigned int )*(in + 5)) + 4237533241U;
#line 229
  b = (b << 21) | (b >> 11);
#line 229
  b += c;
#line 230
  a += ((c ^ (b | ~ d)) + (unsigned int )*(in + 12)) + 1700485571U;
#line 230
  a = (a << 6) | (a >> 26);
#line 230
  a += b;
#line 231
  d += ((b ^ (a | ~ c)) + (unsigned int )*(in + 3)) + 2399980690U;
#line 231
  d = (d << 10) | (d >> 22);
#line 231
  d += a;
#line 232
  c += ((a ^ (d | ~ b)) + (unsigned int )*(in + 10)) + 4293915773U;
#line 232
  c = (c << 15) | (c >> 17);
#line 232
  c += d;
#line 233
  b += ((d ^ (c | ~ a)) + (unsigned int )*(in + 1)) + 2240044497U;
#line 233
  b = (b << 21) | (b >> 11);
#line 233
  b += c;
#line 234
  a += ((c ^ (b | ~ d)) + (unsigned int )*(in + 8)) + 1873313359U;
#line 234
  a = (a << 6) | (a >> 26);
#line 234
  a += b;
#line 235
  d += ((b ^ (a | ~ c)) + (unsigned int )*(in + 15)) + 4264355552U;
#line 235
  d = (d << 10) | (d >> 22);
#line 235
  d += a;
#line 236
  c += ((a ^ (d | ~ b)) + (unsigned int )*(in + 6)) + 2734768916U;
#line 236
  c = (c << 15) | (c >> 17);
#line 236
  c += d;
#line 237
  b += ((d ^ (c | ~ a)) + (unsigned int )*(in + 13)) + 1309151649U;
#line 237
  b = (b << 21) | (b >> 11);
#line 237
  b += c;
#line 238
  a += ((c ^ (b | ~ d)) + (unsigned int )*(in + 4)) + 4149444226U;
#line 238
  a = (a << 6) | (a >> 26);
#line 238
  a += b;
#line 239
  d += ((b ^ (a | ~ c)) + (unsigned int )*(in + 11)) + 3174756917U;
#line 239
  d = (d << 10) | (d >> 22);
#line 239
  d += a;
#line 240
  c += ((a ^ (d | ~ b)) + (unsigned int )*(in + 2)) + 718787259U;
#line 240
  c = (c << 15) | (c >> 17);
#line 240
  c += d;
#line 241
  b += ((d ^ (c | ~ a)) + (unsigned int )*(in + 9)) + 3951481745U;
#line 241
  b = (b << 21) | (b >> 11);
#line 241
  b += c;
#line 243
  *(buf___1 + 0) += a;
#line 244
  *(buf___1 + 1) += b;
#line 245
  *(buf___1 + 2) += c;
#line 246
  *(buf___1 + 3) += d;
#line 247
  return;
}
}
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 580
extern int putchar(int __c ) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 139 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __ctype_get_mb_cur_max)(void) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 870
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) wctomb)(char *__s ,
                                                                             wchar_t __wchar ) ;
#line 874
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) mbstowcs)(wchar_t * __restrict  __pwcs ,
                                                                                  char const   * __restrict  __s ,
                                                                                  size_t __n ) ;
#line 146 "/usr/include/wctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) iswspace)(wint_t __wc ) ;
#line 25 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/protos.h"
int DoFset(ParsePtr p ) ;
#line 26
void ProduceCalendar(void) ;
#line 27
char const   *SimpleTime(int tim ) ;
#line 28
char const   *CalendarTime(int tim , int duration ) ;
#line 30
int DoFlush(ParsePtr p ) ;
#line 31
void DoExit(ParsePtr p ) ;
#line 32
int ParseRem(ParsePtr s , Trigger *trig , TimeTrig *tim , int save_in_globals ) ;
#line 34
int ShouldTriggerReminder(Trigger *t , TimeTrig *tim , int jul , int *err ) ;
#line 67
int DoIf(ParsePtr p ) ;
#line 68
int DoElse(ParsePtr p ) ;
#line 69
int DoEndif(ParsePtr p ) ;
#line 70
int DoIfTrig(ParsePtr p ) ;
#line 71
int ShouldIgnoreLine(void) ;
#line 75
int DoRun(ParsePtr p ) ;
#line 76
int DoErrMsg(ParsePtr p ) ;
#line 86
char const   *FindInitialToken(Token *tok , char const   *s ) ;
#line 89
int ComputeTrigger(int today , Trigger *trig , int *err , int save_in_globals ) ;
#line 106
int DoSatRemind(Trigger *trig , TimeTrig *tim , ParsePtr p ) ;
#line 140
void FreeTrig(Trigger *t ) ;
#line 141
void AppendTag(DynamicBuffer *buf___1 , char const   *s ) ;
#line 142
char const   *SynthesizeTag(void) ;
#line 59 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/calendar.c"
static struct line_drawing NormalDrawing  = 
#line 59 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/calendar.c"
     {"", "", (char *)"+", (char *)"+", (char *)"+", (char *)"+", (char *)"+", (char *)"+",
    (char *)"|", (char *)"+", (char *)"+", (char *)"+", (char *)"-"};
#line 63 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/calendar.c"
static struct line_drawing VT100Drawing  = 
#line 63
     {"\033(0", "\033(B", (char *)"v", (char *)"k", (char *)"u", (char *)"w", (char *)"n",
    (char *)"m", (char *)"x", (char *)"l", (char *)"t", (char *)"j", (char *)"q"};
#line 69 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/calendar.c"
static struct line_drawing UTF8Drawing  = 
#line 69
     {"", "", (char *)"\342\224\264", (char *)"\342\224\220", (char *)"\342\224\244",
    (char *)"\342\224\254", (char *)"\342\224\274", (char *)"\342\224\224", (char *)"\342\224\202",
    (char *)"\342\224\214", (char *)"\342\224\234", (char *)"\342\224\230", (char *)"\342\224\200"};
#line 84 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/calendar.c"
static char *VT100Colors[2][2][2][2]  = { { { {            (char *)"\033[0;30m",            (char *)"\033[0;34m"}, 
       {            (char *)"\033[0;32m",            (char *)"\033[0;36m"}}, 
     { {            (char *)"\033[0;31m",            (char *)"\033[0;35m"}, 
       {            (char *)"\033[0;33m",            (char *)"\033[0;37m"}}}, 
   { { {            (char *)"\033[30;1m",            (char *)"\033[34;1m"}, 
       {            (char *)"\033[32;1m",            (char *)"\033[36;1m"}}, 
     { {            (char *)"\033[31;1m",            (char *)"\033[35;1m"}, 
       {            (char *)"\033[33;1m",            (char *)"\033[37;1m"}}}};
#line 133 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/calendar.c"
static struct line_drawing *linestruct  ;
#line 137 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/calendar.c"
static CalEntry *CalColumn[7]  ;
#line 139 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/calendar.c"
static int ColSpaces  ;
#line 141
static void Colorize(CalEntry const   *e ) ;
#line 142
static void Decolorize(void) ;
#line 143
static void SortCol(CalEntry **col ) ;
#line 144
static void DoCalendarOneWeek(int nleft ) ;
#line 145
static void DoCalendarOneMonth(void) ;
#line 146
static int WriteCalendarRow(void) ;
#line 147
static void WriteWeekHeaderLine(void) ;
#line 148
static void WritePostHeaderLine(void) ;
#line 149
static void PrintLeft(char const   *s , int width , char pad ) ;
#line 150
static void PrintCentered(char const   *s , int width , char *pad ) ;
#line 151
static int WriteOneCalLine(void) ;
#line 152
static int WriteOneColLine(int col ) ;
#line 153
static void GenerateCalEntries(int col ) ;
#line 154
static void WriteCalHeader(void) ;
#line 155
static void WriteCalTrailer(void) ;
#line 156
static int DoCalRem(ParsePtr p , int col ) ;
#line 157
static void WriteSimpleEntries(int col , int jul ) ;
#line 158
static void WriteTopCalLine(void) ;
#line 159
static void WriteBottomCalLine(void) ;
#line 160
static void WriteIntermediateCalLine(void) ;
#line 161
static void WriteCalDays(void) ;
#line 164 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/calendar.c"
static void PutWideChar(wchar_t const   wc ) 
{ 
  size_t tmp ;
  char *buf___1 ;
  unsigned long __lengthofbuf ;
  void *tmp___0 ;
  int len ;

  {
  {
#line 166
  tmp = __ctype_get_mb_cur_max();
#line 166
  __lengthofbuf = tmp + 1UL;
#line 166
  tmp___0 = __builtin_alloca(sizeof(*buf___1) * __lengthofbuf);
#line 166
  buf___1 = (char *)tmp___0;
#line 169
  len = wctomb(buf___1, (wchar_t )wc);
  }
#line 170
  if (len > 0) {
    {
#line 171
    *(buf___1 + len) = (char)0;
#line 172
    fputs((char const   */* __restrict  */)buf___1, (FILE */* __restrict  */)stdout);
    }
  }
#line 174
  return;
}
}
#line 177 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/calendar.c"
static int make_wchar_versions(CalEntry *e ) 
{ 
  size_t len ;
  wchar_t *buf___1 ;
  void *tmp ;

  {
  {
#line 182
  len = mbstowcs((wchar_t */* __restrict  */)((void *)0), (char const   */* __restrict  */)e->text,
                 (size_t )0);
  }
#line 183
  if (len == 0xffffffffffffffffUL) {
#line 183
    return (0);
  }
  {
#line 185
  tmp = calloc(len + 1UL, sizeof(wchar_t ));
#line 185
  buf___1 = (wchar_t *)tmp;
  }
#line 186
  if (! buf___1) {
#line 186
    return (0);
  }
  {
#line 188
  mbstowcs((wchar_t */* __restrict  */)buf___1, (char const   */* __restrict  */)e->text,
           len + 1UL);
#line 189
  e->wc_text = (wchar_t const   *)buf___1;
#line 190
  e->wc_pos = (wchar_t const   *)buf___1;
  }
#line 191
  return (1);
}
}
#line 197 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/calendar.c"
static void gon(void) 
{ 


  {
  {
#line 199
  printf((char const   */* __restrict  */)"%s", linestruct->graphics_on);
  }
#line 200
  return;
}
}
#line 201 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/calendar.c"
static void goff(void) 
{ 


  {
  {
#line 203
  printf((char const   */* __restrict  */)"%s", linestruct->graphics_off);
  }
#line 204
  return;
}
}
#line 206 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/calendar.c"
static void Decolorize(void) 
{ 


  {
  {
#line 208
  printf((char const   */* __restrict  */)"%s", "\033[0m");
  }
#line 209
  return;
}
}
#line 211 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/calendar.c"
static void Colorize(CalEntry const   *e ) 
{ 
  int bright ;
  int r ;
  int g ;
  int b ;

  {
#line 213
  bright = 0;
#line 215
  if (e->r > 128) {
#line 216
    bright = 1;
  } else
#line 215
  if (e->g > 128) {
#line 216
    bright = 1;
  } else
#line 215
  if (e->b > 128) {
#line 216
    bright = 1;
  }
#line 218
  if (e->r > 64) {
#line 218
    r = 1;
  } else {
#line 219
    r = 0;
  }
#line 220
  if (e->g > 64) {
#line 220
    g = 1;
  } else {
#line 221
    g = 0;
  }
#line 222
  if (e->b > 64) {
#line 222
    b = 1;
  } else {
#line 223
    b = 0;
  }
  {
#line 225
  printf((char const   */* __restrict  */)"%s", VT100Colors[bright][r][g][b]);
  }
#line 226
  return;
}
}
#line 235 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/calendar.c"
void ProduceCalendar(void) 
{ 
  int y ;
  int m ;
  int d ;
  int tmp ;
  int tmp___0 ;

  {
#line 239
  if (UseUTF8Chars) {
#line 240
    linestruct = & UTF8Drawing;
  } else
#line 241
  if (UseVTChars) {
#line 242
    linestruct = & VT100Drawing;
  } else {
#line 244
    linestruct = & NormalDrawing;
  }
#line 246
  ShouldCache = 1;
#line 248
  ColSpaces = (CalWidth - 9) / 7;
#line 249
  CalWidth = 7 * ColSpaces + 8;
#line 251
  if (CalMonths) {
    {
#line 252
    FromJulian(JulianToday, & y, & m, & d);
#line 253
    JulianToday = Julian(y, m, 1);
    }
    {
#line 254
    while (1) {
      while_continue: /* CIL Label */ ;
#line 254
      tmp = CalMonths;
#line 254
      CalMonths --;
#line 254
      if (! tmp) {
#line 254
        goto while_break;
      }
      {
#line 255
      DoCalendarOneMonth();
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 256
    return;
  } else {
#line 258
    if (MondayFirst) {
#line 258
      JulianToday -= JulianToday % 7;
    } else {
#line 259
      JulianToday -= (JulianToday + 1) % 7;
    }
#line 261
    if (! DoSimpleCalendar) {
      {
#line 262
      WriteWeekHeaderLine();
#line 263
      WriteCalDays();
#line 264
      WriteIntermediateCalLine();
      }
    }
    {
#line 267
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 267
      tmp___0 = CalWeeks;
#line 267
      CalWeeks --;
#line 267
      if (! tmp___0) {
#line 267
        goto while_break___0;
      }
      {
#line 268
      DoCalendarOneWeek(CalWeeks);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 269
    return;
  }
}
}
#line 280 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/calendar.c"
static void DoCalendarOneWeek(int nleft ) 
{ 
  int y ;
  int m ;
  int d ;
  int done ;
  int i ;
  int l ;
  int wd ;
  char buf___1[81] ;
  int LinesWritten ;
  int OrigJul ;
  int tmp ;

  {
#line 284
  LinesWritten = 0;
#line 285
  OrigJul = JulianToday;
#line 288
  i = 0;
  {
#line 288
  while (1) {
    while_continue: /* CIL Label */ ;
#line 288
    if (! (i < 7)) {
#line 288
      goto while_break;
    }
    {
#line 289
    GenerateCalEntries(i);
#line 290
    JulianToday ++;
#line 288
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 296
  if (DoSimpleCalendar) {
#line 297
    if (MondayFirst) {
#line 297
      wd = JulianToday % 7;
    } else {
#line 298
      wd = (JulianToday + 1) % 7;
    }
#line 299
    i = 0;
    {
#line 299
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 299
      if (! (i < 7)) {
#line 299
        goto while_break___0;
      }
      {
#line 300
      WriteSimpleEntries(i, (OrigJul + i) - wd);
#line 299
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 302
    return;
  }
  {
#line 306
  gon();
#line 307
  fputs((char const   */* __restrict  */)linestruct->tb, (FILE */* __restrict  */)stdout);
#line 308
  goff();
#line 309
  i = 0;
  }
  {
#line 309
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 309
    if (! (i < 7)) {
#line 309
      goto while_break___1;
    }
    {
#line 310
    FromJulian(OrigJul + i, & y, & m, & d);
#line 311
    sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"%d %c%c%c ",
            d, (int )*(EnglishMonthName[m] + 0), (int )*(EnglishMonthName[m] + 1),
            (int )*(EnglishMonthName[m] + 2));
    }
#line 313
    if (OrigJul + i == RealToday) {
      {
#line 314
      PrintLeft((char const   *)(buf___1), ColSpaces, (char )'*');
      }
    } else {
      {
#line 316
      PrintLeft((char const   *)(buf___1), ColSpaces, (char )' ');
      }
    }
    {
#line 317
    gon();
#line 318
    fputs((char const   */* __restrict  */)linestruct->tb, (FILE */* __restrict  */)stdout);
#line 319
    goff();
#line 309
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 321
  putchar('\n');
#line 322
  l = 0;
  }
  {
#line 322
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 322
    if (! (l < CalPad)) {
#line 322
      goto while_break___2;
    }
    {
#line 323
    gon();
#line 324
    fputs((char const   */* __restrict  */)linestruct->tb, (FILE */* __restrict  */)stdout);
#line 325
    goff();
#line 326
    i = 0;
    }
    {
#line 326
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 326
      if (! (i < 7)) {
#line 326
        goto while_break___3;
      }
      {
#line 327
      PrintLeft("", ColSpaces, (char )' ');
#line 328
      gon();
#line 329
      fputs((char const   */* __restrict  */)linestruct->tb, (FILE */* __restrict  */)stdout);
#line 330
      goff();
#line 326
      i ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 332
    putchar('\n');
#line 322
    l ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 336
  done = 0;
  {
#line 337
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 337
    if (! (! done)) {
#line 337
      goto while_break___4;
    }
    {
#line 338
    done = WriteOneCalLine();
#line 339
    LinesWritten ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 343
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 343
    tmp = LinesWritten;
#line 343
    LinesWritten ++;
#line 343
    if (! (tmp < CalLines)) {
#line 343
      goto while_break___5;
    }
    {
#line 344
    gon();
#line 345
    fputs((char const   */* __restrict  */)linestruct->tb, (FILE */* __restrict  */)stdout);
#line 346
    goff();
#line 347
    i = 0;
    }
    {
#line 347
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 347
      if (! (i < 7)) {
#line 347
        goto while_break___6;
      }
      {
#line 348
      PrintLeft("", ColSpaces, (char )' ');
#line 349
      gon();
#line 350
      fputs((char const   */* __restrict  */)linestruct->tb, (FILE */* __restrict  */)stdout);
#line 351
      goff();
#line 347
      i ++;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 353
    putchar('\n');
    }
  }
  while_break___5: /* CIL Label */ ;
  }
#line 357
  if (nleft) {
    {
#line 358
    WriteIntermediateCalLine();
    }
  } else {
    {
#line 360
    WriteBottomCalLine();
    }
  }
#line 362
  return;
}
}
#line 371 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/calendar.c"
static void DoCalendarOneMonth(void) 
{ 
  int y ;
  int m ;
  int d ;
  int mm ;
  int yy ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 375
  if (! DoSimpleCalendar) {
    {
#line 375
    WriteCalHeader();
    }
  }
#line 377
  if (PsCal) {
    {
#line 378
    FromJulian(JulianToday, & y, & m, & d);
#line 379
    printf((char const   */* __restrict  */)"%s\n", "# rem2ps begin");
    }
#line 380
    if (m != 1) {
#line 380
      tmp___1 = MonthDays[m];
    } else {
#line 380
      if (y % 4) {
#line 380
        tmp___0 = 0;
      } else {
#line 380
        if (! (y % 100)) {
#line 380
          if (y % 400) {
#line 380
            tmp = 0;
          } else {
#line 380
            tmp = 1;
          }
        } else {
#line 380
          tmp = 1;
        }
#line 380
        tmp___0 = tmp;
      }
#line 380
      tmp___1 = 28 + tmp___0;
    }
    {
#line 380
    printf((char const   */* __restrict  */)"%s %d %d %d %d\n", EnglishMonthName[m],
           y, tmp___1, (JulianToday + 1) % 7, MondayFirst);
#line 383
    printf((char const   */* __restrict  */)"%s %s %s %s %s %s %s\n", EnglishDayName[6],
           EnglishDayName[0], EnglishDayName[1], EnglishDayName[2], EnglishDayName[3],
           EnglishDayName[4], EnglishDayName[5]);
#line 386
    mm = m - 1;
    }
#line 387
    if (mm < 0) {
#line 388
      mm = 11;
#line 388
      yy = y - 1;
    } else {
#line 389
      yy = y;
    }
#line 391
    if (mm != 1) {
#line 391
      tmp___4 = MonthDays[mm];
    } else {
#line 391
      if (yy % 4) {
#line 391
        tmp___3 = 0;
      } else {
#line 391
        if (! (yy % 100)) {
#line 391
          if (yy % 400) {
#line 391
            tmp___2 = 0;
          } else {
#line 391
            tmp___2 = 1;
          }
        } else {
#line 391
          tmp___2 = 1;
        }
#line 391
        tmp___3 = tmp___2;
      }
#line 391
      tmp___4 = 28 + tmp___3;
    }
    {
#line 391
    printf((char const   */* __restrict  */)"%s %d\n", EnglishMonthName[mm], tmp___4);
#line 392
    mm = m + 1;
    }
#line 393
    if (mm > 11) {
#line 394
      mm = 0;
#line 394
      yy = y + 1;
    } else {
#line 395
      yy = y;
    }
#line 396
    if (mm != 1) {
#line 396
      tmp___7 = MonthDays[mm];
    } else {
#line 396
      if (yy % 4) {
#line 396
        tmp___6 = 0;
      } else {
#line 396
        if (! (yy % 100)) {
#line 396
          if (yy % 400) {
#line 396
            tmp___5 = 0;
          } else {
#line 396
            tmp___5 = 1;
          }
        } else {
#line 396
          tmp___5 = 1;
        }
#line 396
        tmp___6 = tmp___5;
      }
#line 396
      tmp___7 = 28 + tmp___6;
    }
    {
#line 396
    printf((char const   */* __restrict  */)"%s %d\n", EnglishMonthName[mm], tmp___7);
    }
  }
  {
#line 398
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 398
    tmp___8 = WriteCalendarRow();
    }
#line 398
    if (! tmp___8) {
#line 398
      goto while_break;
    }
#line 398
    goto while_continue;
  }
  while_break: /* CIL Label */ ;
  }
#line 400
  if (PsCal) {
    {
#line 400
    printf((char const   */* __restrict  */)"%s\n", "# rem2ps end");
    }
  }
#line 401
  if (! DoSimpleCalendar) {
    {
#line 401
    WriteCalTrailer();
    }
  }
#line 402
  return;
}
}
#line 411 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/calendar.c"
static int WriteCalendarRow(void) 
{ 
  int y ;
  int m ;
  int d ;
  int wd ;
  int i ;
  int l ;
  int done ;
  char buf___1[81] ;
  int OrigJul ;
  int LinesWritten ;
  int moreleft ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
  {
#line 416
  OrigJul = JulianToday;
#line 417
  LinesWritten = 0;
#line 421
  FromJulian(JulianToday, & y, & m, & d);
  }
#line 422
  if (! MondayFirst) {
#line 422
    wd = (JulianToday + 1) % 7;
  } else {
#line 423
    wd = JulianToday % 7;
  }
#line 426
  i = wd;
  {
#line 426
  while (1) {
    while_continue: /* CIL Label */ ;
#line 426
    if (! (i < 7)) {
#line 426
      goto while_break;
    }
#line 427
    if (m != 1) {
#line 427
      tmp___1 = MonthDays[m];
    } else {
#line 427
      if (y % 4) {
#line 427
        tmp___0 = 0;
      } else {
#line 427
        if (! (y % 100)) {
#line 427
          if (y % 400) {
#line 427
            tmp = 0;
          } else {
#line 427
            tmp = 1;
          }
        } else {
#line 427
          tmp = 1;
        }
#line 427
        tmp___0 = tmp;
      }
#line 427
      tmp___1 = 28 + tmp___0;
    }
#line 427
    if ((d + i) - wd > tmp___1) {
#line 427
      goto while_break;
    }
    {
#line 428
    GenerateCalEntries(i);
#line 429
    JulianToday ++;
#line 426
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 435
  if (DoSimpleCalendar) {
#line 436
    i = wd;
    {
#line 436
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 436
      if (i < 7) {
#line 436
        if (m != 1) {
#line 436
          tmp___4 = MonthDays[m];
        } else {
#line 436
          if (y % 4) {
#line 436
            tmp___3 = 0;
          } else {
#line 436
            if (! (y % 100)) {
#line 436
              if (y % 400) {
#line 436
                tmp___2 = 0;
              } else {
#line 436
                tmp___2 = 1;
              }
            } else {
#line 436
              tmp___2 = 1;
            }
#line 436
            tmp___3 = tmp___2;
          }
#line 436
          tmp___4 = 28 + tmp___3;
        }
#line 436
        if (! ((d + i) - wd <= tmp___4)) {
#line 436
          goto while_break___0;
        }
      } else {
#line 436
        goto while_break___0;
      }
      {
#line 437
      WriteSimpleEntries(i, (OrigJul + i) - wd);
#line 436
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 439
    if (m != 1) {
#line 439
      tmp___7 = MonthDays[m];
    } else {
#line 439
      if (y % 4) {
#line 439
        tmp___6 = 0;
      } else {
#line 439
        if (! (y % 100)) {
#line 439
          if (y % 400) {
#line 439
            tmp___5 = 0;
          } else {
#line 439
            tmp___5 = 1;
          }
        } else {
#line 439
          tmp___5 = 1;
        }
#line 439
        tmp___6 = tmp___5;
      }
#line 439
      tmp___7 = 28 + tmp___6;
    }
#line 439
    return ((d + 7) - wd <= tmp___7);
  }
  {
#line 444
  gon();
#line 445
  fputs((char const   */* __restrict  */)linestruct->tb, (FILE */* __restrict  */)stdout);
#line 446
  goff();
#line 447
  i = 0;
  }
  {
#line 447
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 447
    if (! (i < 7)) {
#line 447
      goto while_break___1;
    }
#line 448
    if (i < wd) {
      {
#line 449
      PrintLeft("", ColSpaces, (char )' ');
      }
    } else {
#line 448
      if (m != 1) {
#line 448
        tmp___10 = MonthDays[m];
      } else {
#line 448
        if (y % 4) {
#line 448
          tmp___9 = 0;
        } else {
#line 448
          if (! (y % 100)) {
#line 448
            if (y % 400) {
#line 448
              tmp___8 = 0;
            } else {
#line 448
              tmp___8 = 1;
            }
          } else {
#line 448
            tmp___8 = 1;
          }
#line 448
          tmp___9 = tmp___8;
        }
#line 448
        tmp___10 = 28 + tmp___9;
      }
#line 448
      if ((d + i) - wd > tmp___10) {
        {
#line 449
        PrintLeft("", ColSpaces, (char )' ');
        }
      } else {
        {
#line 451
        sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"%d",
                (d + i) - wd);
#line 452
        PrintLeft((char const   *)(buf___1), ColSpaces, (char )' ');
        }
      }
    }
    {
#line 454
    gon();
#line 455
    fputs((char const   */* __restrict  */)linestruct->tb, (FILE */* __restrict  */)stdout);
#line 456
    goff();
#line 447
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 458
  putchar('\n');
#line 459
  l = 0;
  }
  {
#line 459
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 459
    if (! (l < CalPad)) {
#line 459
      goto while_break___2;
    }
    {
#line 460
    gon();
#line 461
    fputs((char const   */* __restrict  */)linestruct->tb, (FILE */* __restrict  */)stdout);
#line 462
    goff();
#line 463
    i = 0;
    }
    {
#line 463
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 463
      if (! (i < 7)) {
#line 463
        goto while_break___3;
      }
      {
#line 464
      PrintLeft("", ColSpaces, (char )' ');
#line 465
      gon();
#line 466
      fputs((char const   */* __restrict  */)linestruct->tb, (FILE */* __restrict  */)stdout);
#line 467
      goff();
#line 463
      i ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 469
    putchar('\n');
#line 459
    l ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 473
  done = 0;
  {
#line 474
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 474
    if (! (! done)) {
#line 474
      goto while_break___4;
    }
    {
#line 475
    done = WriteOneCalLine();
#line 476
    LinesWritten ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 480
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 480
    tmp___11 = LinesWritten;
#line 480
    LinesWritten ++;
#line 480
    if (! (tmp___11 < CalLines)) {
#line 480
      goto while_break___5;
    }
    {
#line 481
    gon();
#line 482
    fputs((char const   */* __restrict  */)linestruct->tb, (FILE */* __restrict  */)stdout);
#line 483
    goff();
#line 484
    i = 0;
    }
    {
#line 484
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 484
      if (! (i < 7)) {
#line 484
        goto while_break___6;
      }
      {
#line 485
      PrintLeft("", ColSpaces, (char )' ');
#line 486
      gon();
#line 487
      fputs((char const   */* __restrict  */)linestruct->tb, (FILE */* __restrict  */)stdout);
#line 488
      goff();
#line 484
      i ++;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 490
    putchar('\n');
    }
  }
  while_break___5: /* CIL Label */ ;
  }
#line 493
  if (m != 1) {
#line 493
    tmp___14 = MonthDays[m];
  } else {
#line 493
    if (y % 4) {
#line 493
      tmp___13 = 0;
    } else {
#line 493
      if (! (y % 100)) {
#line 493
        if (y % 400) {
#line 493
          tmp___12 = 0;
        } else {
#line 493
          tmp___12 = 1;
        }
      } else {
#line 493
        tmp___12 = 1;
      }
#line 493
      tmp___13 = tmp___12;
    }
#line 493
    tmp___14 = 28 + tmp___13;
  }
#line 493
  moreleft = (d + 7) - wd <= tmp___14;
#line 494
  if (moreleft) {
    {
#line 495
    WriteIntermediateCalLine();
    }
  } else {
    {
#line 497
    WriteBottomCalLine();
    }
  }
#line 501
  return (moreleft);
}
}
#line 511 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/calendar.c"
static void PrintLeft(char const   *s , int width , char pad ) 
{ 
  int len ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 513
  tmp = strlen(s);
#line 513
  len = (int )tmp;
#line 514
  printf((char const   */* __restrict  */)"%s", s);
  }
  {
#line 515
  while (1) {
    while_continue: /* CIL Label */ ;
#line 515
    tmp___0 = len;
#line 515
    len ++;
#line 515
    if (! (tmp___0 < width)) {
#line 515
      goto while_break;
    }
    {
#line 515
    putchar((int )pad);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 516
  return;
}
}
#line 525 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/calendar.c"
static void PrintCentered(char const   *s , int width , char *pad ) 
{ 
  size_t len ;
  size_t tmp ;
  int i ;
  wchar_t static_buf[128] ;
  wchar_t *buf___1 ;
  wchar_t *ws ;
  int d ;
  void *tmp___0 ;
  wchar_t *tmp___1 ;

  {
  {
#line 538
  tmp = mbstowcs((wchar_t */* __restrict  */)((void *)0), (char const   */* __restrict  */)s,
                 (size_t )0);
#line 538
  len = tmp;
  }
#line 545
  if (! len) {
#line 546
    i = 0;
    {
#line 546
    while (1) {
      while_continue: /* CIL Label */ ;
#line 546
      if (! (i < width)) {
#line 546
        goto while_break;
      }
      {
#line 547
      fputs((char const   */* __restrict  */)pad, (FILE */* __restrict  */)stdout);
#line 546
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 549
    return;
  }
#line 551
  if (len + 1UL <= 128UL) {
#line 552
    buf___1 = static_buf;
  } else {
    {
#line 554
    tmp___0 = calloc(len + 1UL, sizeof(wchar_t ));
#line 554
    buf___1 = (wchar_t *)tmp___0;
    }
#line 555
    if (! buf___1) {
      {
#line 557
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
              ErrMsg[9]);
#line 558
      exit(1);
      }
    }
  }
  {
#line 561
  mbstowcs((wchar_t */* __restrict  */)buf___1, (char const   */* __restrict  */)s,
           len + 1UL);
#line 562
  d = (int )(((size_t )width - len) / 2UL);
#line 563
  ws = buf___1;
#line 564
  i = 0;
  }
  {
#line 564
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 564
    if (! (i < d)) {
#line 564
      goto while_break___0;
    }
    {
#line 564
    fputs((char const   */* __restrict  */)pad, (FILE */* __restrict  */)stdout);
#line 564
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 565
  i = 0;
  {
#line 565
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 565
    if (! (i < width)) {
#line 565
      goto while_break___1;
    }
#line 566
    if (*ws) {
      {
#line 566
      tmp___1 = ws;
#line 566
      ws ++;
#line 566
      PutWideChar((wchar_t const   )*tmp___1);
      }
    } else {
#line 566
      goto while_break___1;
    }
#line 565
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 568
  i = (int )((size_t )d + len);
  {
#line 568
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 568
    if (! (i < width)) {
#line 568
      goto while_break___2;
    }
    {
#line 568
    fputs((char const   */* __restrict  */)pad, (FILE */* __restrict  */)stdout);
#line 568
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 569
  if ((unsigned long )buf___1 != (unsigned long )(static_buf)) {
    {
#line 569
    free((void *)buf___1);
    }
  }
#line 571
  return;
}
}
#line 580 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/calendar.c"
static int WriteOneCalLine(void) 
{ 
  int done ;
  int i ;
  int tmp ;

  {
  {
#line 582
  done = 1;
#line 584
  gon();
#line 585
  fputs((char const   */* __restrict  */)linestruct->tb, (FILE */* __restrict  */)stdout);
#line 586
  goff();
#line 587
  i = 0;
  }
  {
#line 587
  while (1) {
    while_continue: /* CIL Label */ ;
#line 587
    if (! (i < 7)) {
#line 587
      goto while_break;
    }
#line 588
    if (CalColumn[i]) {
      {
#line 589
      tmp = WriteOneColLine(i);
      }
#line 589
      if (tmp) {
#line 589
        done = 0;
      }
    } else {
      {
#line 591
      PrintCentered("", ColSpaces, (char *)" ");
      }
    }
    {
#line 593
    gon();
#line 594
    fputs((char const   */* __restrict  */)linestruct->tb, (FILE */* __restrict  */)stdout);
#line 595
    goff();
#line 587
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 597
  putchar('\n');
  }
#line 599
  return (done);
}
}
#line 611 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/calendar.c"
static int WriteOneColLine(int col ) 
{ 
  CalEntry *e ;
  char const   *s ;
  char const   *space ;
  wchar_t const   *ws ;
  wchar_t const   *wspace ;
  int numwritten ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 613
  e = CalColumn[col];
#line 622
  numwritten = 0;
#line 626
  if (e->wc_text) {
#line 627
    wspace = (wchar_t const   *)((void *)0);
#line 628
    ws = e->wc_pos;
#line 632
    if (! *ws) {
#line 632
      if (e->next) {
        {
#line 633
        PrintLeft("", ColSpaces, (char )' ');
#line 634
        CalColumn[col] = e->next;
#line 635
        free((void *)e->text);
#line 636
        free((void *)e->filename);
        }
#line 637
        if (e->wc_text) {
          {
#line 637
          free((void *)e->wc_text);
          }
        }
        {
#line 638
        free((void *)e);
        }
#line 639
        return (1);
      }
    }
    {
#line 643
    while (1) {
      while_continue: /* CIL Label */ ;
#line 643
      if (! (ws - e->wc_pos <= (long )ColSpaces)) {
#line 643
        goto while_break;
      }
#line 644
      if (! *ws) {
#line 644
        wspace = ws;
#line 644
        goto while_break;
      }
      {
#line 645
      tmp = iswspace((wint_t )*ws);
      }
#line 645
      if (tmp) {
#line 645
        wspace = ws;
      }
#line 646
      ws ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 650
    if (UseVTColors) {
#line 650
      if (e->is_color) {
        {
#line 651
        Colorize((CalEntry const   *)e);
        }
      }
    }
#line 655
    if (! wspace) {
#line 656
      ws = e->wc_pos;
      {
#line 656
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 656
        if (! (ws - e->wc_pos < (long )ColSpaces)) {
#line 656
          goto while_break___0;
        }
#line 657
        if (! *ws) {
#line 657
          goto while_break___0;
        }
        {
#line 658
        numwritten ++;
#line 659
        PutWideChar(*ws);
#line 656
        ws ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 661
      e->wc_pos = ws;
    } else {
#line 664
      ws = e->wc_pos;
      {
#line 664
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 664
        if (! ((unsigned long )ws < (unsigned long )wspace)) {
#line 664
          goto while_break___1;
        }
#line 665
        if (! *ws) {
#line 665
          goto while_break___1;
        }
        {
#line 666
        numwritten ++;
#line 667
        PutWideChar(*ws);
#line 664
        ws ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 672
    if (UseVTColors) {
#line 672
      if (e->is_color) {
        {
#line 673
        Decolorize();
        }
      }
    }
    {
#line 677
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 677
      tmp___0 = numwritten;
#line 677
      numwritten ++;
#line 677
      if (! (tmp___0 < ColSpaces)) {
#line 677
        goto while_break___2;
      }
      {
#line 677
      putchar(' ');
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 680
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 680
      tmp___1 = iswspace((wint_t )*ws);
      }
#line 680
      if (! tmp___1) {
#line 680
        goto while_break___3;
      }
#line 680
      ws ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 683
    if (! *ws) {
#line 683
      if (! e->next) {
        {
#line 684
        CalColumn[col] = e->next;
#line 685
        free((void *)e->text);
#line 686
        free((void *)e->filename);
        }
#line 687
        if (e->wc_text) {
          {
#line 687
          free((void *)e->wc_text);
          }
        }
        {
#line 688
        free((void *)e);
        }
      } else {
#line 690
        e->wc_pos = ws;
      }
    } else {
#line 690
      e->wc_pos = ws;
    }
#line 692
    if (CalColumn[col]) {
#line 692
      return (1);
    } else {
#line 692
      return (0);
    }
  } else {
#line 695
    space = (char const   *)((void *)0);
#line 696
    s = e->pos;
#line 700
    if (! *s) {
#line 700
      if (e->next) {
        {
#line 701
        PrintLeft("", ColSpaces, (char )' ');
#line 702
        CalColumn[col] = e->next;
#line 703
        free((void *)e->text);
#line 704
        free((void *)e->filename);
        }
#line 706
        if (e->wc_text) {
          {
#line 706
          free((void *)e->wc_text);
          }
        }
        {
#line 708
        free((void *)e);
        }
#line 709
        return (1);
      }
    }
    {
#line 713
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 713
      if (! (s - e->pos <= (long )ColSpaces)) {
#line 713
        goto while_break___4;
      }
#line 714
      if (! *s) {
#line 714
        space = s;
#line 714
        goto while_break___4;
      }
#line 715
      if ((int const   )*s == 32) {
#line 715
        space = s;
      }
#line 716
      s ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 720
    if (UseVTColors) {
#line 720
      if (e->is_color) {
        {
#line 721
        Colorize((CalEntry const   *)e);
        }
      }
    }
#line 725
    if (! space) {
#line 726
      s = e->pos;
      {
#line 726
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 726
        if (! (s - e->pos < (long )ColSpaces)) {
#line 726
          goto while_break___5;
        }
#line 727
        if (! *s) {
#line 727
          goto while_break___5;
        }
        {
#line 728
        numwritten ++;
#line 729
        putchar((int )*s);
#line 726
        s ++;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
#line 731
      e->pos = s;
    } else {
#line 734
      s = e->pos;
      {
#line 734
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 734
        if (! ((unsigned long )s < (unsigned long )space)) {
#line 734
          goto while_break___6;
        }
#line 735
        if (! *s) {
#line 735
          goto while_break___6;
        }
        {
#line 736
        numwritten ++;
#line 737
        putchar((int )*s);
#line 734
        s ++;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
    }
#line 742
    if (UseVTColors) {
#line 742
      if (e->is_color) {
        {
#line 743
        Decolorize();
        }
      }
    }
    {
#line 747
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 747
      tmp___2 = numwritten;
#line 747
      numwritten ++;
#line 747
      if (! (tmp___2 < ColSpaces)) {
#line 747
        goto while_break___7;
      }
      {
#line 747
      putchar(' ');
      }
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 750
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 750
      if (! ((int const   )*s == 32)) {
#line 750
        goto while_break___8;
      }
#line 750
      s ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 753
    if (! *s) {
#line 753
      if (! e->next) {
        {
#line 754
        CalColumn[col] = e->next;
#line 755
        free((void *)e->text);
#line 756
        free((void *)e->filename);
        }
#line 758
        if (e->wc_text) {
          {
#line 758
          free((void *)e->wc_text);
          }
        }
        {
#line 760
        free((void *)e);
        }
      } else {
#line 762
        e->pos = s;
      }
    } else {
#line 762
      e->pos = s;
    }
#line 764
    if (CalColumn[col]) {
#line 764
      return (1);
    } else {
#line 764
      return (0);
    }
  }
}
}
#line 777 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/calendar.c"
static void GenerateCalEntries(int col ) 
{ 
  int r ;
  Token tok ;
  char const   *s ;
  Parser p ;
  int tmp ;

  {
  {
#line 785
  ClearGlobalOmits();
#line 786
  DestroyOmitContexts();
#line 787
  DestroyVars(0);
#line 788
  NumTriggered = 0;
#line 790
  r = IncludeFile(InitialFile);
  }
#line 791
  if (r) {
    {
#line 792
    fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"%s %s: %s\n",
            ErrMsg[58], InitialFile, ErrMsg[r]);
#line 793
    exit(1);
    }
  }
  {
#line 796
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 797
    r = ReadLine();
    }
#line 798
    if (r == 20) {
#line 798
      return;
    }
#line 799
    if (r) {
      {
#line 800
      Eprint("%s: %s", ErrMsg[58], ErrMsg[r]);
#line 801
      exit(1);
      }
    }
    {
#line 803
    s = FindInitialToken(& tok, CurLine);
    }
#line 806
    if (NumIfs) {
#line 806
      if ((unsigned int )tok.type != 6U) {
#line 806
        if ((unsigned int )tok.type != 7U) {
#line 806
          if ((unsigned int )tok.type != 8U) {
#line 806
            if ((unsigned int )tok.type != 9U) {
              {
#line 806
              tmp = ShouldIgnoreLine();
              }
#line 806
              if (! tmp) {
#line 806
                goto _L___3;
              }
            } else {
#line 806
              goto _L___3;
            }
          } else {
#line 806
            goto _L___3;
          }
        } else {
#line 806
          goto _L___3;
        }
      } else {
#line 806
        goto _L___3;
      }
    } else {
      _L___3: /* CIL Label */ 
      {
#line 817
      CreateParser(s, & p);
      }
      {
#line 822
      if ((unsigned int )tok.type == 33U) {
#line 822
        goto case_33;
      }
#line 822
      if ((unsigned int )tok.type == 32U) {
#line 822
        goto case_33;
      }
#line 825
      if ((unsigned int )tok.type == 10U) {
#line 825
        goto case_10;
      }
#line 826
      if ((unsigned int )tok.type == 1U) {
#line 826
        goto case_1;
      }
#line 827
      if ((unsigned int )tok.type == 6U) {
#line 827
        goto case_6;
      }
#line 828
      if ((unsigned int )tok.type == 9U) {
#line 828
        goto case_9;
      }
#line 829
      if ((unsigned int )tok.type == 7U) {
#line 829
        goto case_7;
      }
#line 830
      if ((unsigned int )tok.type == 8U) {
#line 830
        goto case_8;
      }
#line 831
      if ((unsigned int )tok.type == 5U) {
#line 831
        goto case_5;
      }
#line 832
      if ((unsigned int )tok.type == 16U) {
#line 832
        goto case_16;
      }
#line 833
      if ((unsigned int )tok.type == 11U) {
#line 833
        goto case_11;
      }
#line 834
      if ((unsigned int )tok.type == 13U) {
#line 834
        goto case_13;
      }
#line 835
      if ((unsigned int )tok.type == 12U) {
#line 835
        goto case_12;
      }
#line 836
      if ((unsigned int )tok.type == 35U) {
#line 836
        goto case_35;
      }
#line 837
      if ((unsigned int )tok.type == 39U) {
#line 837
        goto case_39;
      }
#line 838
      if ((unsigned int )tok.type == 36U) {
#line 838
        goto case_36;
      }
#line 839
      if ((unsigned int )tok.type == 37U) {
#line 839
        goto case_37;
      }
#line 840
      if ((unsigned int )tok.type == 15U) {
#line 840
        goto case_15;
      }
#line 841
      if ((unsigned int )tok.type == 14U) {
#line 841
        goto case_14;
      }
#line 848
      if ((unsigned int )tok.type == 3U) {
#line 848
        goto case_3;
      }
#line 849
      if ((unsigned int )tok.type == 2U) {
#line 849
        goto case_2;
      }
#line 850
      if ((unsigned int )tok.type == 4U) {
#line 850
        goto case_4;
      }
#line 851
      if ((unsigned int )tok.type == 24U) {
#line 851
        goto case_24;
      }
#line 864
      goto switch_default;
      case_33: /* CIL Label */ 
      case_32: /* CIL Label */ 
#line 823
      goto switch_break;
      case_10: /* CIL Label */ 
      {
#line 825
      r = DoErrMsg(& p);
      }
#line 825
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 826
      r = DoCalRem(& p, col);
      }
#line 826
      goto switch_break;
      case_6: /* CIL Label */ 
      {
#line 827
      r = DoIf(& p);
      }
#line 827
      goto switch_break;
      case_9: /* CIL Label */ 
      {
#line 828
      r = DoIfTrig(& p);
      }
#line 828
      goto switch_break;
      case_7: /* CIL Label */ 
      {
#line 829
      r = DoElse(& p);
      }
#line 829
      goto switch_break;
      case_8: /* CIL Label */ 
      {
#line 830
      r = DoEndif(& p);
      }
#line 830
      goto switch_break;
      case_5: /* CIL Label */ 
      {
#line 831
      r = DoInclude(& p);
      }
#line 831
      goto switch_break;
      case_16: /* CIL Label */ 
      {
#line 832
      DoExit(& p);
      }
#line 832
      goto switch_break;
      case_11: /* CIL Label */ 
      {
#line 833
      r = DoSet(& p);
      }
#line 833
      goto switch_break;
      case_13: /* CIL Label */ 
      {
#line 834
      r = DoFset(& p);
      }
#line 834
      goto switch_break;
      case_12: /* CIL Label */ 
      {
#line 835
      r = DoUnset(& p);
      }
#line 835
      goto switch_break;
      case_35: /* CIL Label */ 
      {
#line 836
      r = DoClear(& p);
      }
#line 836
      goto switch_break;
      case_39: /* CIL Label */ 
      {
#line 837
      r = DoFlush(& p);
      }
#line 837
      goto switch_break;
      case_36: /* CIL Label */ 
#line 838
      goto switch_break;
      case_37: /* CIL Label */ 
#line 839
      goto switch_break;
      case_15: /* CIL Label */ 
#line 840
      goto switch_break;
      case_14: /* CIL Label */ 
      {
#line 841
      r = DoOmit(& p);
      }
#line 842
      if (r == 44) {
        {
#line 843
        DestroyParser(& p);
#line 844
        CreateParser(s, & p);
#line 845
        r = DoCalRem(& p, col);
        }
      }
#line 847
      goto switch_break;
      case_3: /* CIL Label */ 
      {
#line 848
      r = PopOmitContext(& p);
      }
#line 848
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 849
      r = PushOmitContext(& p);
      }
#line 849
      goto switch_break;
      case_4: /* CIL Label */ 
      {
#line 850
      r = DoPreserve(& p);
      }
#line 850
      goto switch_break;
      case_24: /* CIL Label */ 
#line 851
      if (tok.val == 2) {
        {
#line 852
        r = DoRun(& p);
        }
#line 853
        goto switch_break;
      } else {
        {
#line 855
        CreateParser(CurLine, & p);
#line 856
        r = DoCalRem(& p, col);
        }
#line 857
        goto switch_break;
      }
      switch_default: /* CIL Label */ 
      {
#line 864
      CreateParser(CurLine, & p);
#line 865
      r = DoCalRem(& p, col);
      }
#line 866
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 868
      if (r) {
#line 868
        if (! Hush) {
          {
#line 868
          Eprint("%s", ErrMsg[r]);
          }
        } else
#line 868
        if (r != 40) {
          {
#line 868
          Eprint("%s", ErrMsg[r]);
          }
        }
      }
      {
#line 871
      DestroyParser(& p);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 882 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/calendar.c"
static void WriteCalHeader(void) 
{ 
  char buf___1[80] ;
  int y ;
  int m ;
  int d ;

  {
  {
#line 887
  FromJulian(JulianToday, & y, & m, & d);
#line 888
  sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"%s %d",
          EnglishMonthName[m], y);
#line 890
  WriteTopCalLine();
#line 892
  gon();
#line 893
  fputs((char const   */* __restrict  */)linestruct->tb, (FILE */* __restrict  */)stdout);
#line 894
  goff();
#line 895
  PrintCentered((char const   *)(buf___1), CalWidth - 2, (char *)" ");
#line 896
  gon();
#line 897
  fputs((char const   */* __restrict  */)linestruct->tb, (FILE */* __restrict  */)stdout);
#line 898
  goff();
#line 899
  putchar('\n');
#line 901
  WritePostHeaderLine();
#line 902
  WriteCalDays();
#line 903
  WriteIntermediateCalLine();
  }
#line 904
  return;
}
}
#line 911 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/calendar.c"
static void WriteCalTrailer(void) 
{ 


  {
  {
#line 913
  putchar('\f');
  }
#line 914
  return;
}
}
#line 923 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/calendar.c"
static int DoCalRem(ParsePtr p , int col ) 
{ 
  int oldLen ;
  Trigger trig ;
  TimeTrig tim ;
  Value v ;
  int r ;
  int err ;
  int jul ;
  CalEntry *CurCol ;
  CalEntry *e ;
  char const   *s ;
  char const   *s2 ;
  DynamicBuffer buf___1 ;
  DynamicBuffer obuf ;
  DynamicBuffer pre_buf ;
  Token tok ;
  int is_color ;
  int col_r ;
  int col_g ;
  int col_b ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char evalBuf[64] ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  char evalBuf___0[64] ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  unsigned short const   **tmp___18 ;
  void *tmp___19 ;
  char *tmp___20 ;
  char const   *tmp___21 ;
  char *tmp___22 ;
  int tmp___23 ;

  {
  {
#line 931
  CurCol = CalColumn[col];
#line 939
  is_color = 0;
#line 940
  DBufInit(& buf___1);
#line 941
  DBufInit(& pre_buf);
#line 944
  r = ParseRem(p, & trig, & tim, 1);
  }
#line 944
  if (r) {
    {
#line 945
    FreeTrig(& trig);
    }
#line 946
    return (r);
  }
#line 950
  if (DontIssueAts) {
#line 950
    if (tim.ttime != 2147483647) {
      {
#line 951
      FreeTrig(& trig);
      }
#line 952
      return (0);
    }
  }
#line 954
  if (trig.typ == 0) {
    {
#line 955
    FreeTrig(& trig);
    }
#line 956
    return (19);
  }
#line 958
  if (trig.typ == 4) {
    {
#line 959
    r = DoSatRemind(& trig, & tim, p);
    }
#line 960
    if (r) {
      {
#line 961
      FreeTrig(& trig);
      }
#line 962
      if (r == 80) {
#line 962
        return (0);
      }
#line 963
      return (r);
    }
#line 965
    if (! LastTrigValid) {
      {
#line 966
      FreeTrig(& trig);
      }
#line 967
      return (0);
    }
    {
#line 969
    r = ParseToken(p, & buf___1);
    }
#line 970
    if (r) {
      {
#line 971
      FreeTrig(& trig);
      }
#line 972
      return (r);
    }
    {
#line 974
    FindToken((char const   *)buf___1.buffer, & tok);
#line 975
    DBufFree(& buf___1);
    }
#line 976
    if ((unsigned int )tok.type == 32U) {
      {
#line 977
      FreeTrig(& trig);
      }
#line 978
      return (0);
    } else
#line 976
    if ((unsigned int )tok.type == 33U) {
      {
#line 977
      FreeTrig(& trig);
      }
#line 978
      return (0);
    }
#line 980
    if ((unsigned int )tok.type != 24U) {
      {
#line 981
      FreeTrig(& trig);
      }
#line 982
      return (32);
    } else
#line 980
    if (tok.val == 4) {
      {
#line 981
      FreeTrig(& trig);
      }
#line 982
      return (32);
    }
#line 984
    if (tok.val == 8) {
      {
#line 985
      r = ParseToken(p, & buf___1);
      }
#line 986
      if (r) {
#line 986
        return (r);
      }
#line 987
      if (! buf___1.len) {
        {
#line 988
        DBufFree(& buf___1);
#line 989
        FreeTrig(& trig);
        }
#line 990
        return (19);
      }
      {
#line 992
      StrnCpy(trig.passthru, (char const   *)buf___1.buffer, 32);
#line 993
      DBufFree(& buf___1);
      }
    }
#line 995
    trig.typ = tok.val;
#line 996
    jul = LastTriggerDate;
#line 997
    if (! LastTrigValid) {
      {
#line 998
      FreeTrig(& trig);
      }
#line 999
      return (0);
    }
  } else {
    {
#line 1003
    jul = ComputeTrigger(trig.scanfrom, & trig, & r, 1);
    }
#line 1004
    if (r) {
      {
#line 1005
      FreeTrig(& trig);
      }
#line 1006
      return (r);
    }
  }
#line 1011
  if (trig.typ == 5) {
    {
#line 1012
    strcpy((char */* __restrict  */)(trig.passthru), (char const   */* __restrict  */)"PostScript");
#line 1013
    trig.typ = 8;
    }
  } else
#line 1014
  if (trig.typ == 6) {
    {
#line 1015
    strcpy((char */* __restrict  */)(trig.passthru), (char const   */* __restrict  */)"PSFile");
#line 1016
    trig.typ = 8;
    }
  }
#line 1018
  if (trig.typ == 8) {
#line 1019
    if (! PsCal) {
      {
#line 1019
      tmp = strcmp((char const   *)(trig.passthru), "COLOR");
      }
#line 1019
      if (tmp) {
        {
#line 1019
        tmp___0 = strcmp((char const   *)(trig.passthru), "COLOUR");
        }
#line 1019
        if (tmp___0) {
          {
#line 1020
          FreeTrig(& trig);
          }
#line 1021
          return (0);
        }
      }
    }
    {
#line 1023
    tmp___4 = strcmp((char const   *)(trig.passthru), "COLOR");
    }
#line 1023
    if (tmp___4) {
      {
#line 1023
      tmp___5 = strcmp((char const   *)(trig.passthru), "COLOUR");
      }
#line 1023
      if (! tmp___5) {
        _L: /* CIL Label */ 
        {
#line 1025
        is_color = 1;
#line 1027
        DBufFree(& buf___1);
#line 1028
        r = ParseToken(p, & buf___1);
#line 1029
        DBufPuts(& pre_buf, (char const   *)buf___1.buffer);
        }
#line 1030
        if (pre_buf.allocatedLen < pre_buf.len + 1) {
#line 1030
          tmp___1 = pre_buf.len;
#line 1030
          (pre_buf.len) ++;
#line 1030
          *(pre_buf.buffer + tmp___1) = (char )' ';
#line 1030
          *(pre_buf.buffer + pre_buf.len) = (char)0;
        } else {
          {
#line 1030
          DBufPutcFN(& pre_buf, (char )' ');
          }
        }
        {
#line 1031
        DBufFree(& buf___1);
        }
#line 1032
        if (r) {
          {
#line 1033
          FreeTrig(& trig);
          }
#line 1034
          return (r);
        }
        {
#line 1036
        r = ParseToken(p, & buf___1);
#line 1037
        DBufPuts(& pre_buf, (char const   *)buf___1.buffer);
        }
#line 1038
        if (pre_buf.allocatedLen < pre_buf.len + 1) {
#line 1038
          tmp___2 = pre_buf.len;
#line 1038
          (pre_buf.len) ++;
#line 1038
          *(pre_buf.buffer + tmp___2) = (char )' ';
#line 1038
          *(pre_buf.buffer + pre_buf.len) = (char)0;
        } else {
          {
#line 1038
          DBufPutcFN(& pre_buf, (char )' ');
          }
        }
        {
#line 1039
        DBufFree(& buf___1);
        }
#line 1040
        if (r) {
          {
#line 1041
          FreeTrig(& trig);
          }
#line 1042
          return (r);
        }
        {
#line 1044
        r = ParseToken(p, & buf___1);
#line 1045
        DBufPuts(& pre_buf, (char const   *)buf___1.buffer);
        }
#line 1046
        if (pre_buf.allocatedLen < pre_buf.len + 1) {
#line 1046
          tmp___3 = pre_buf.len;
#line 1046
          (pre_buf.len) ++;
#line 1046
          *(pre_buf.buffer + tmp___3) = (char )' ';
#line 1046
          *(pre_buf.buffer + pre_buf.len) = (char)0;
        } else {
          {
#line 1046
          DBufPutcFN(& pre_buf, (char )' ');
          }
        }
        {
#line 1047
        DBufFree(& buf___1);
        }
#line 1048
        if (r) {
          {
#line 1049
          FreeTrig(& trig);
          }
#line 1050
          return (r);
        }
        {
#line 1052
        sscanf((char const   */* __restrict  */)pre_buf.buffer, (char const   */* __restrict  */)"%d %d %d",
               & col_r, & col_g, & col_b);
        }
#line 1054
        if (col_r < 0) {
#line 1054
          col_r = 0;
        } else
#line 1055
        if (col_r > 255) {
#line 1055
          col_r = 255;
        }
#line 1056
        if (col_g < 0) {
#line 1056
          col_g = 0;
        } else
#line 1057
        if (col_g > 255) {
#line 1057
          col_g = 255;
        }
#line 1058
        if (col_b < 0) {
#line 1058
          col_b = 0;
        } else
#line 1059
        if (col_b > 255) {
#line 1059
          col_b = 255;
        }
#line 1060
        if (! PsCal) {
#line 1060
          if (! DoSimpleCalendar) {
            {
#line 1061
            DBufFree(& pre_buf);
            }
          }
        }
      }
    } else {
#line 1023
      goto _L;
    }
  }
  {
#line 1067
  DBufInit(& obuf);
  }
#line 1068
  if (jul == JulianToday) {
#line 1068
    goto _L___4;
  } else
#line 1068
  if (DoSimpleCalDelta) {
    {
#line 1068
    tmp___23 = ShouldTriggerReminder(& trig, & tim, jul, & err);
    }
#line 1068
    if (tmp___23) {
      _L___4: /* CIL Label */ 
#line 1071
      NumTriggered ++;
#line 1073
      if (DoSimpleCalendar) {
#line 1073
        goto _L___3;
      } else
#line 1073
      if (tim.ttime != 2147483647) {
        _L___3: /* CIL Label */ 
#line 1075
        if (jul != JulianToday) {
#line 1075
          goto _L___0;
        } else
#line 1075
        if (trig.typ == 8) {
          {
#line 1075
          tmp___10 = strcmp((char const   *)(trig.passthru), "COLOUR");
          }
#line 1075
          if (tmp___10) {
            {
#line 1075
            tmp___11 = strcmp((char const   *)(trig.passthru), "COLOR");
            }
#line 1075
            if (tmp___11) {
              _L___0: /* CIL Label */ 
              {
#line 1079
              tmp___6 = SimpleTime(2147483647);
#line 1079
              tmp___7 = DBufPuts(& obuf, tmp___6);
              }
#line 1079
              if (tmp___7 != 0) {
                {
#line 1080
                DBufFree(& obuf);
#line 1081
                DBufFree(& pre_buf);
#line 1082
                FreeTrig(& trig);
                }
#line 1083
                return (9);
              }
            } else {
#line 1075
              goto _L___2;
            }
          } else {
#line 1075
            goto _L___2;
          }
        } else {
          _L___2: /* CIL Label */ 
          {
#line 1086
          tmp___8 = CalendarTime(tim.ttime, tim.duration);
#line 1086
          tmp___9 = DBufPuts(& obuf, tmp___8);
          }
#line 1086
          if (tmp___9 != 0) {
            {
#line 1087
            DBufFree(& obuf);
#line 1088
            DBufFree(& pre_buf);
#line 1089
            FreeTrig(& trig);
            }
#line 1090
            return (9);
          }
        }
      }
#line 1094
      if (trig.typ != 8) {
        {
#line 1094
        tmp___14 = UserFuncExists("calprefix");
        }
#line 1094
        if (tmp___14 == 1) {
          {
#line 1097
          sprintf((char */* __restrict  */)(evalBuf), (char const   */* __restrict  */)"calprefix(%d)",
                  trig.priority);
#line 1098
          s2 = (char const   *)(evalBuf);
#line 1099
          r = EvalExpr(& s2, & v, (ParsePtr )((void *)0));
          }
#line 1100
          if (! r) {
            {
#line 1101
            tmp___13 = DoCoerce((char)4, & v);
            }
#line 1101
            if (! tmp___13) {
              {
#line 1102
              tmp___12 = DBufPuts(& obuf, (char const   *)v.v.str);
              }
#line 1102
              if (tmp___12 != 0) {
#line 1103
                if ((int )v.type == 4) {
#line 1103
                  if (v.v.str) {
                    {
#line 1103
                    free((void *)v.v.str);
#line 1103
                    v.type = (char)0;
                    }
                  }
                }
                {
#line 1104
                DBufFree(& obuf);
#line 1105
                DBufFree(& pre_buf);
#line 1106
                FreeTrig(& trig);
                }
#line 1107
                return (9);
              }
            }
#line 1110
            if ((int )v.type == 4) {
#line 1110
              if (v.v.str) {
                {
#line 1110
                free((void *)v.v.str);
#line 1110
                v.type = (char)0;
                }
              }
            }
          }
        }
      }
#line 1113
      oldLen = obuf.len;
#line 1117
      if (jul != JulianToday) {
        {
#line 1118
        r = DoSubst(p, & obuf, & trig, & tim, jul, 2);
        }
      } else {
        {
#line 1120
        r = DoSubst(p, & obuf, & trig, & tim, jul, 1);
        }
      }
#line 1122
      if (r) {
        {
#line 1123
        DBufFree(& pre_buf);
#line 1124
        DBufFree(& obuf);
#line 1125
        FreeTrig(& trig);
        }
#line 1126
        return (r);
      }
#line 1128
      if (obuf.len <= oldLen) {
        {
#line 1129
        DBufFree(& obuf);
#line 1130
        DBufFree(& pre_buf);
#line 1131
        FreeTrig(& trig);
        }
#line 1132
        return (0);
      }
#line 1134
      if (trig.typ != 8) {
        {
#line 1134
        tmp___17 = UserFuncExists("calsuffix");
        }
#line 1134
        if (tmp___17 == 1) {
          {
#line 1137
          sprintf((char */* __restrict  */)(evalBuf___0), (char const   */* __restrict  */)"calsuffix(%d)",
                  trig.priority);
#line 1138
          s2 = (char const   *)(evalBuf___0);
#line 1139
          r = EvalExpr(& s2, & v, (ParsePtr )((void *)0));
          }
#line 1140
          if (! r) {
            {
#line 1141
            tmp___16 = DoCoerce((char)4, & v);
            }
#line 1141
            if (! tmp___16) {
              {
#line 1142
              tmp___15 = DBufPuts(& obuf, (char const   *)v.v.str);
              }
#line 1142
              if (tmp___15 != 0) {
#line 1143
                if ((int )v.type == 4) {
#line 1143
                  if (v.v.str) {
                    {
#line 1143
                    free((void *)v.v.str);
#line 1143
                    v.type = (char)0;
                    }
                  }
                }
                {
#line 1144
                DBufFree(& obuf);
#line 1145
                DBufFree(& pre_buf);
#line 1146
                FreeTrig(& trig);
                }
#line 1147
                return (9);
              }
            }
#line 1150
            if ((int )v.type == 4) {
#line 1150
              if (v.v.str) {
                {
#line 1150
                free((void *)v.v.str);
#line 1150
                v.type = (char)0;
                }
              }
            }
          }
        }
      }
#line 1153
      s = (char const   *)obuf.buffer;
#line 1154
      if (! DoSimpleCalendar) {
        {
#line 1154
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 1154
          tmp___18 = __ctype_b_loc();
          }
#line 1154
          if (! ((int const   )*(*tmp___18 + (int )*s) & 8192)) {
#line 1154
            if (! ((int const   )*s == 92)) {
#line 1154
              goto while_break;
            }
          }
#line 1154
          s ++;
        }
        while_break: /* CIL Label */ ;
        }
      }
      {
#line 1155
      DBufPuts(& pre_buf, s);
#line 1156
      s = (char const   *)pre_buf.buffer;
#line 1157
      tmp___19 = malloc(sizeof(CalEntry ));
#line 1157
      e = (CalEntry *)tmp___19;
      }
#line 1158
      if (! e) {
        {
#line 1159
        DBufFree(& obuf);
#line 1160
        DBufFree(& pre_buf);
#line 1161
        FreeTrig(& trig);
        }
#line 1162
        return (9);
      }
      {
#line 1165
      e->wc_pos = (wchar_t const   *)((void *)0);
#line 1166
      e->wc_text = (wchar_t const   *)((void *)0);
#line 1168
      e->is_color = is_color;
#line 1169
      e->r = col_r;
#line 1170
      e->g = col_g;
#line 1171
      e->b = col_b;
#line 1172
      tmp___20 = StrDup(s);
#line 1172
      e->text = (char const   *)tmp___20;
#line 1173
      DBufFree(& obuf);
#line 1174
      DBufFree(& pre_buf);
      }
#line 1175
      if (! e->text) {
        {
#line 1176
        free((void *)e);
#line 1177
        FreeTrig(& trig);
        }
#line 1178
        return (9);
      }
      {
#line 1180
      make_wchar_versions(e);
#line 1181
      DBufInit(& e->tags);
#line 1182
      DBufPuts(& e->tags, (char const   *)trig.tags.buffer);
      }
#line 1183
      if (SynthesizeTags) {
        {
#line 1184
        tmp___21 = SynthesizeTag();
#line 1184
        AppendTag(& e->tags, tmp___21);
        }
      }
      {
#line 1188
      FreeTrig(& trig);
#line 1189
      e->duration = tim.duration;
#line 1190
      e->priority = trig.priority;
#line 1191
      tmp___22 = StrDup((char const   *)FileName);
#line 1191
      e->filename = (char const   *)tmp___22;
      }
#line 1192
      if (! e->filename) {
        {
#line 1193
        free((void *)e);
        }
#line 1194
        return (9);
      }
#line 1196
      e->lineno = LineNo;
#line 1198
      if (trig.typ == 8) {
        {
#line 1199
        StrnCpy(e->passthru, (char const   *)(trig.passthru), 32);
        }
      } else {
#line 1201
        e->passthru[0] = (char)0;
      }
#line 1203
      e->pos = e->text;
#line 1204
      if (jul == JulianToday) {
#line 1205
        e->time = tim.ttime;
      } else {
#line 1207
        e->time = 2147483647;
      }
      {
#line 1209
      e->next = CurCol;
#line 1210
      CalColumn[col] = e;
#line 1211
      SortCol(& CalColumn[col]);
      }
    }
  }
#line 1213
  return (0);
}
}
#line 1223 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/calendar.c"
static void WriteSimpleEntries(int col , int jul ) 
{ 
  CalEntry *e ;
  CalEntry *n ;
  int y ;
  int m ;
  int d ;

  {
  {
#line 1225
  e = CalColumn[col];
#line 1229
  FromJulian(jul, & y, & m, & d);
  }
  {
#line 1230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1230
    if (! e) {
#line 1230
      goto while_break;
    }
#line 1231
    if (DoPrefixLineNo) {
      {
#line 1231
      printf((char const   */* __restrict  */)"# fileinfo %d %s\n", e->lineno, e->filename);
      }
    }
    {
#line 1232
    printf((char const   */* __restrict  */)"%04d/%02d/%02d", y, m + 1, d);
    }
#line 1233
    if (e->passthru[0]) {
      {
#line 1234
      printf((char const   */* __restrict  */)" %s", e->passthru);
      }
    } else {
      {
#line 1236
      printf((char const   */* __restrict  */)" *");
      }
    }
#line 1238
    if (*(e->tags.buffer)) {
      {
#line 1239
      printf((char const   */* __restrict  */)" %s ", e->tags.buffer);
      }
    } else {
      {
#line 1241
      printf((char const   */* __restrict  */)" * ");
      }
    }
#line 1243
    if (e->duration != 2147483647) {
      {
#line 1244
      printf((char const   */* __restrict  */)"%d ", e->duration);
      }
    } else {
      {
#line 1246
      printf((char const   */* __restrict  */)"* ");
      }
    }
#line 1248
    if (e->time != 2147483647) {
      {
#line 1249
      printf((char const   */* __restrict  */)"%d ", e->time);
      }
    } else {
      {
#line 1251
      printf((char const   */* __restrict  */)"* ");
      }
    }
    {
#line 1253
    printf((char const   */* __restrict  */)"%s\n", e->text);
#line 1254
    free((void *)e->text);
#line 1255
    free((void *)e->filename);
    }
#line 1257
    if (e->wc_text) {
      {
#line 1257
      free((void *)e->wc_text);
      }
    }
    {
#line 1259
    n = e->next;
#line 1260
    free((void *)e);
#line 1261
    e = n;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1263
  CalColumn[col] = (CalEntry *)((void *)0);
#line 1264
  return;
}
}
#line 1271 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/calendar.c"
static void WriteTopCalLine(void) 
{ 


  {
  {
#line 1273
  gon();
#line 1274
  fputs((char const   */* __restrict  */)linestruct->br, (FILE */* __restrict  */)stdout);
#line 1275
  PrintCentered("", CalWidth - 2, linestruct->lr);
#line 1276
  fputs((char const   */* __restrict  */)linestruct->bl, (FILE */* __restrict  */)stdout);
#line 1277
  goff();
#line 1278
  putchar('\n');
  }
#line 1279
  return;
}
}
#line 1281 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/calendar.c"
static void WriteBottomCalLine(void) 
{ 
  int i ;

  {
  {
#line 1284
  gon();
#line 1285
  fputs((char const   */* __restrict  */)linestruct->tr, (FILE */* __restrict  */)stdout);
#line 1286
  i = 0;
  }
  {
#line 1286
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1286
    if (! (i < 7)) {
#line 1286
      goto while_break;
    }
    {
#line 1287
    PrintCentered("", ColSpaces, linestruct->lr);
    }
#line 1288
    if (i != 6) {
      {
#line 1289
      fputs((char const   */* __restrict  */)linestruct->tlr, (FILE */* __restrict  */)stdout);
      }
    } else {
      {
#line 1291
      fputs((char const   */* __restrict  */)linestruct->tl, (FILE */* __restrict  */)stdout);
      }
    }
#line 1286
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1294
  goff();
#line 1295
  putchar('\n');
  }
#line 1296
  return;
}
}
#line 1298 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/calendar.c"
static void WritePostHeaderLine(void) 
{ 
  int i ;

  {
  {
#line 1301
  gon();
#line 1302
  fputs((char const   */* __restrict  */)linestruct->tbr, (FILE */* __restrict  */)stdout);
#line 1303
  i = 0;
  }
  {
#line 1303
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1303
    if (! (i < 7)) {
#line 1303
      goto while_break;
    }
    {
#line 1304
    PrintCentered("", ColSpaces, linestruct->lr);
    }
#line 1305
    if (i != 6) {
      {
#line 1306
      fputs((char const   */* __restrict  */)linestruct->blr, (FILE */* __restrict  */)stdout);
      }
    } else {
      {
#line 1308
      fputs((char const   */* __restrict  */)linestruct->tbl, (FILE */* __restrict  */)stdout);
      }
    }
#line 1303
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1311
  goff();
#line 1312
  putchar('\n');
  }
#line 1313
  return;
}
}
#line 1315 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/calendar.c"
static void WriteWeekHeaderLine(void) 
{ 
  int i ;

  {
  {
#line 1318
  gon();
#line 1319
  fputs((char const   */* __restrict  */)linestruct->br, (FILE */* __restrict  */)stdout);
#line 1320
  i = 0;
  }
  {
#line 1320
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1320
    if (! (i < 7)) {
#line 1320
      goto while_break;
    }
    {
#line 1321
    PrintCentered("", ColSpaces, linestruct->lr);
    }
#line 1322
    if (i != 6) {
      {
#line 1323
      fputs((char const   */* __restrict  */)linestruct->blr, (FILE */* __restrict  */)stdout);
      }
    } else {
      {
#line 1325
      fputs((char const   */* __restrict  */)linestruct->bl, (FILE */* __restrict  */)stdout);
      }
    }
#line 1320
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1328
  goff();
#line 1329
  putchar('\n');
  }
#line 1330
  return;
}
}
#line 1332 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/calendar.c"
static void WriteIntermediateCalLine(void) 
{ 
  int i ;

  {
  {
#line 1336
  gon();
#line 1337
  fputs((char const   */* __restrict  */)linestruct->tbr, (FILE */* __restrict  */)stdout);
#line 1338
  i = 0;
  }
  {
#line 1338
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1338
    if (! (i < 7)) {
#line 1338
      goto while_break;
    }
    {
#line 1339
    PrintCentered("", ColSpaces, linestruct->lr);
    }
#line 1340
    if (i != 6) {
      {
#line 1341
      fputs((char const   */* __restrict  */)linestruct->tblr, (FILE */* __restrict  */)stdout);
      }
    } else {
      {
#line 1343
      fputs((char const   */* __restrict  */)linestruct->tbl, (FILE */* __restrict  */)stdout);
      }
    }
#line 1338
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1346
  goff();
#line 1347
  putchar('\n');
  }
#line 1348
  return;
}
}
#line 1350 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/calendar.c"
static void WriteCalDays(void) 
{ 
  int i ;

  {
  {
#line 1353
  gon();
#line 1354
  fputs((char const   */* __restrict  */)linestruct->tb, (FILE */* __restrict  */)stdout);
#line 1355
  goff();
#line 1356
  i = 0;
  }
  {
#line 1356
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1356
    if (! (i < 7)) {
#line 1356
      goto while_break;
    }
#line 1357
    if (! MondayFirst) {
      {
#line 1358
      PrintCentered((char const   *)EnglishDayName[(i + 6) % 7], ColSpaces, (char *)" ");
      }
    } else {
      {
#line 1360
      PrintCentered((char const   *)EnglishDayName[i % 7], ColSpaces, (char *)" ");
      }
    }
    {
#line 1361
    gon();
#line 1362
    fputs((char const   */* __restrict  */)linestruct->tb, (FILE */* __restrict  */)stdout);
#line 1363
    goff();
#line 1356
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1365
  putchar('\n');
  }
#line 1366
  return;
}
}
#line 1381 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/calendar.c"
static char buf[128]  ;
#line 1378 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/calendar.c"
char const   *CalendarTime(int tim , int duration ) 
{ 
  int h ;
  int min ;
  int hh ;
  int h2 ;
  int min2 ;
  int hh2 ;
  int newtim ;
  int days ;
  char const   *ampm1 ;
  char const   *ampm2 ;
  char daybuf[64] ;
  char const   *tmp ;
  int tmp___0 ;

  {
#line 1388
  buf[0] = (char)0;
#line 1390
  if (duration == 2147483647) {
    {
#line 1392
    tmp = SimpleTime(tim);
    }
#line 1392
    return (tmp);
  }
#line 1394
  if (tim == 2147483647) {
#line 1396
    return ((char const   *)(buf));
  }
#line 1398
  h = tim / 60;
#line 1399
  min = tim % 60;
#line 1400
  if (h == 0) {
#line 1400
    hh = 12;
  } else
#line 1401
  if (h > 12) {
#line 1401
    hh = h - 12;
  } else {
#line 1402
    hh = h;
  }
#line 1404
  newtim = tim + duration;
#line 1407
  days = newtim / 1440;
#line 1408
  newtim %= 1440;
#line 1409
  h2 = newtim / 60;
#line 1410
  min2 = newtim % 60;
#line 1411
  if (h2 == 0) {
#line 1411
    hh2 = 12;
  } else
#line 1412
  if (h2 > 12) {
#line 1412
    hh2 = h2 - 12;
  } else {
#line 1413
    hh2 = h2;
  }
#line 1415
  if (days) {
    {
#line 1416
    sprintf((char */* __restrict  */)(daybuf), (char const   */* __restrict  */)"+%d",
            days);
    }
  } else {
#line 1418
    daybuf[0] = (char)0;
  }
#line 1421
  if (h >= 12) {
#line 1422
    ampm1 = "pm";
  } else {
#line 1424
    ampm1 = "am";
  }
#line 1426
  if (h2 >= 12) {
#line 1427
    ampm2 = "pm";
  } else {
#line 1429
    ampm2 = "am";
  }
#line 1431
  if (! days) {
    {
#line 1432
    tmp___0 = strcmp(ampm1, ampm2);
    }
#line 1432
    if (! tmp___0) {
#line 1433
      ampm1 = "";
    }
  }
  {
#line 1438
  if (ScFormat == 0) {
#line 1438
    goto case_0;
  }
#line 1443
  if (ScFormat == 1) {
#line 1443
    goto case_1;
  }
#line 1437
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 1439
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%d%c%02d%s-%d%c%02d%s%s ",
          hh, (int )TimeSep, min, ampm1, hh2, (int )TimeSep, min2, ampm2, daybuf);
  }
#line 1441
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1444
  sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"%02d%c%02d-%02d%c%02d%s ",
          h, (int )TimeSep, min, h2, (int )TimeSep, min2, daybuf);
  }
#line 1446
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1448
  return ((char const   *)(buf));
}
}
#line 1462 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/calendar.c"
static char buf___0[32]  ;
#line 1460 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/calendar.c"
char const   *SimpleTime(int tim ) 
{ 
  int h ;
  int min ;
  int hh ;
  char const   *tmp ;

  {
#line 1465
  buf___0[0] = (char)0;
  {
#line 1469
  if (ScFormat == 0) {
#line 1469
    goto case_0;
  }
#line 1480
  if (ScFormat == 1) {
#line 1480
    goto case_1;
  }
#line 1467
  goto switch_break;
  case_0: /* CIL Label */ 
#line 1470
  if (tim != 2147483647) {
#line 1471
    h = tim / 60;
#line 1472
    min = tim % 60;
#line 1473
    if (h == 0) {
#line 1473
      hh = 12;
    } else
#line 1474
    if (h > 12) {
#line 1474
      hh = h - 12;
    } else {
#line 1475
      hh = h;
    }
#line 1476
    if (h >= 12) {
#line 1476
      tmp = "pm";
    } else {
#line 1476
      tmp = "am";
    }
    {
#line 1476
    sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%d%c%02d%s ",
            hh, (int )TimeSep, min, tmp);
    }
  }
#line 1478
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1481
  if (tim != 2147483647) {
    {
#line 1482
    h = tim / 60;
#line 1483
    min = tim % 60;
#line 1484
    sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%02d%c%02d ",
            h, (int )TimeSep, min);
    }
  }
#line 1486
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1488
  return ((char const   *)(buf___0));
}
}
#line 1498 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/calendar.c"
static void SortCol(CalEntry **col ) 
{ 
  CalEntry *cur ;
  CalEntry *prev ;
  CalEntry *next ;
  int tmp ;

  {
#line 1502
  cur = *col;
#line 1503
  prev = (CalEntry *)((void *)0);
  {
#line 1508
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1508
    if (cur->next) {
      {
#line 1508
      tmp = CompareRems(0, cur->time, cur->priority, 0, (cur->next)->time, (cur->next)->priority,
                        SortByDate, SortByTime, SortByPrio, UntimedBeforeTimed);
      }
#line 1508
      if (! (tmp <= 0)) {
#line 1508
        goto while_break;
      }
    } else {
#line 1508
      goto while_break;
    }
#line 1512
    next = cur->next;
#line 1514
    if (! prev) {
#line 1515
      *col = next;
#line 1516
      cur->next = next->next;
#line 1517
      next->next = cur;
#line 1518
      prev = next;
    } else {
#line 1520
      prev->next = next;
#line 1521
      cur->next = next->next;
#line 1522
      next->next = cur;
#line 1523
      prev = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1526
  return;
}
}
#line 1532 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/calendar.c"
static char out[128]  ;
#line 1528 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/calendar.c"
char const   *SynthesizeTag(void) 
{ 
  struct MD5Context ctx ;
  unsigned char buf___1[16] ;
  size_t tmp ;

  {
  {
#line 1533
  MD5Init(& ctx);
#line 1534
  tmp = strlen(CurLine);
#line 1534
  MD5Update(& ctx, (unsigned char const   *)((unsigned char *)CurLine), (unsigned int )tmp);
#line 1535
  MD5Final((unsigned char *)(buf___1), & ctx);
#line 1536
  sprintf((char */* __restrict  */)(out), (char const   */* __restrict  */)"__syn__%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x",
          (unsigned int )buf___1[0], (unsigned int )buf___1[1], (unsigned int )buf___1[2],
          (unsigned int )buf___1[3], (unsigned int )buf___1[4], (unsigned int )buf___1[5],
          (unsigned int )buf___1[6], (unsigned int )buf___1[7], (unsigned int )buf___1[8],
          (unsigned int )buf___1[9], (unsigned int )buf___1[10], (unsigned int )buf___1[11],
          (unsigned int )buf___1[12], (unsigned int )buf___1[13], (unsigned int )buf___1[14],
          (unsigned int )buf___1[15]);
  }
#line 1545
  return ((char const   *)(out));
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/protos.h"
int CallUserFunc(char const   *name , int nargs , ParsePtr p ) ;
#line 58
int Evaluate(char const   **s , Var *locals , ParsePtr p ) ;
#line 59
int FnPopValStack(Value *val ) ;
#line 112
BuiltinFunc *FindFunc(char const   *name , BuiltinFunc *where , int num ) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/userfns.c"
static UserFunc *FuncHash[32]  ;
#line 42
int NumFuncs ;
#line 43
BuiltinFunc Func[81] ;
#line 46
Value ValStack[500] ;
#line 47
int ValStackPtr ;
#line 49
static void DestroyUserFunc(UserFunc *f ) ;
#line 50
static void FUnset(char const   *name ) ;
#line 51
static void FSet(UserFunc *f ) ;
#line 52
static int SetUpLocalVars(UserFunc *f ) ;
#line 53
static void DestroyLocalVals(UserFunc *f ) ;
#line 62 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/userfns.c"
int DoFset(ParsePtr p ) 
{ 
  int r ;
  int c ;
  UserFunc *func ;
  Var *v ;
  DynamicBuffer buf___1 ;
  void *tmp ;
  BuiltinFunc *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 70
  DBufInit(& buf___1);
#line 73
  r = ParseIdentifier(p, & buf___1);
  }
#line 73
  if (r) {
#line 73
    return (r);
  }
#line 74
  if ((int )*(buf___1.buffer) == 36) {
    {
#line 75
    DBufFree(& buf___1);
    }
#line 76
    return (42);
  }
  {
#line 80
  c = ParseNonSpaceChar(p, & r, 0);
  }
#line 81
  if (r) {
    {
#line 82
    DBufFree(& buf___1);
    }
#line 83
    return (r);
  }
#line 85
  if (c != 40) {
    {
#line 86
    DBufFree(& buf___1);
    }
#line 87
    return (32);
  }
  {
#line 90
  tmp = malloc(sizeof(UserFunc ));
#line 90
  func = (UserFunc *)tmp;
  }
#line 91
  if (! func) {
    {
#line 92
    DBufFree(& buf___1);
    }
#line 93
    return (9);
  }
  {
#line 95
  StrnCpy(func->name, (char const   *)buf___1.buffer, 16);
#line 96
  DBufFree(& buf___1);
  }
#line 97
  if (! Hush) {
    {
#line 98
    tmp___0 = FindFunc((char const   *)buf___1.buffer, Func, NumFuncs);
    }
#line 98
    if (tmp___0) {
      {
#line 99
      Eprint("%s: `%s\'", ErrMsg[47], buf___1.buffer);
      }
    }
  }
  {
#line 103
  func->locals = (Var *)((void *)0);
#line 104
  func->text = (char const   *)((void *)0);
#line 105
  func->IsActive = (char)0;
#line 106
  func->nargs = 0;
#line 112
  c = ParseNonSpaceChar(p, & r, 1);
  }
#line 113
  if (r) {
#line 113
    return (r);
  }
#line 114
  if (c == 41) {
    {
#line 115
    ParseNonSpaceChar(p, & r, 0);
    }
  } else {
    {
#line 118
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 119
      r = ParseIdentifier(p, & buf___1);
      }
#line 119
      if (r) {
#line 119
        return (r);
      }
#line 120
      if ((int )*(buf___1.buffer) == 36) {
        {
#line 121
        DBufFree(& buf___1);
        }
#line 122
        return (42);
      }
      {
#line 124
      tmp___1 = malloc(sizeof(Var ));
#line 124
      v = (Var *)tmp___1;
      }
#line 125
      if (! v) {
        {
#line 126
        DBufFree(& buf___1);
#line 127
        DestroyUserFunc(func);
        }
#line 128
        return (9);
      }
      {
#line 130
      (func->nargs) ++;
#line 131
      v->v.type = (char)0;
#line 132
      StrnCpy(v->name, (char const   *)buf___1.buffer, 16);
#line 133
      DBufFree(& buf___1);
#line 134
      v->next = func->locals;
#line 135
      func->locals = v;
#line 136
      c = ParseNonSpaceChar(p, & r, 0);
      }
#line 137
      if (c == 41) {
#line 137
        goto while_break;
      } else
#line 138
      if (c != 44) {
        {
#line 139
        DestroyUserFunc(func);
        }
#line 140
        return (32);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 146
  c = ParseNonSpaceChar(p, & r, 1);
  }
#line 147
  if (c == 61) {
    {
#line 148
    c = ParseNonSpaceChar(p, & r, 0);
    }
  }
#line 151
  if (p->isnested) {
    {
#line 152
    Eprint("%s", ErrMsg[48]);
#line 153
    DestroyUserFunc(func);
    }
#line 154
    return (32);
  }
  {
#line 157
  tmp___2 = StrDup(p->pos);
#line 157
  func->text = (char const   *)tmp___2;
  }
#line 158
  if (! func->text) {
    {
#line 159
    DestroyUserFunc(func);
    }
#line 160
    return (9);
  }
  {
#line 164
  FUnset((char const   *)(func->name));
#line 167
  FSet(func);
  }
#line 168
  return (0);
}
}
#line 178 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/userfns.c"
static void DestroyUserFunc(UserFunc *f ) 
{ 
  Var *v ;
  Var *prev ;

  {
#line 183
  v = f->locals;
  {
#line 184
  while (1) {
    while_continue: /* CIL Label */ ;
#line 184
    if (! v) {
#line 184
      goto while_break;
    }
#line 185
    if ((int )v->v.type == 4) {
#line 185
      if (v->v.v.str) {
        {
#line 185
        free((void *)v->v.v.str);
#line 185
        v->v.type = (char)0;
        }
      }
    }
    {
#line 186
    prev = v;
#line 187
    v = v->next;
#line 188
    free((void *)prev);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 192
  if (f->text) {
    {
#line 192
    free((void *)((char *)f->text));
    }
  }
  {
#line 195
  free((void *)f);
  }
#line 196
  return;
}
}
#line 206 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/userfns.c"
static void FUnset(char const   *name ) 
{ 
  UserFunc *cur ;
  UserFunc *prev ;
  int h ;
  unsigned int tmp ;
  int tmp___0 ;

  {
  {
#line 211
  tmp = HashVal(name);
#line 211
  h = (int )(tmp % 32U);
#line 213
  cur = FuncHash[h];
#line 214
  prev = (UserFunc *)((void *)0);
  }
  {
#line 215
  while (1) {
    while_continue: /* CIL Label */ ;
#line 215
    if (! cur) {
#line 215
      goto while_break;
    }
    {
#line 216
    tmp___0 = StrinCmp(name, (char const   *)(cur->name), 16);
    }
#line 216
    if (! tmp___0) {
#line 216
      goto while_break;
    }
#line 217
    prev = cur;
#line 218
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 220
  if (! cur) {
#line 220
    return;
  }
#line 221
  if (prev) {
#line 221
    prev->next = cur->next;
  } else {
#line 221
    FuncHash[h] = cur->next;
  }
  {
#line 222
  DestroyUserFunc(cur);
  }
#line 223
  return;
}
}
#line 232 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/userfns.c"
static void FSet(UserFunc *f ) 
{ 
  int h ;
  unsigned int tmp ;

  {
  {
#line 234
  tmp = HashVal((char const   *)(f->name));
#line 234
  h = (int )(tmp % 32U);
#line 235
  f->next = FuncHash[h];
#line 236
  FuncHash[h] = f;
  }
#line 237
  return;
}
}
#line 246 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/userfns.c"
int CallUserFunc(char const   *name , int nargs , ParsePtr p ) 
{ 
  UserFunc *f ;
  int h ;
  unsigned int tmp ;
  int i ;
  char const   *s ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;

  {
  {
#line 249
  tmp = HashVal(name);
#line 249
  h = (int )(tmp % 32U);
#line 254
  f = FuncHash[h];
  }
  {
#line 255
  while (1) {
    while_continue: /* CIL Label */ ;
#line 255
    if (f) {
      {
#line 255
      tmp___0 = StrinCmp(name, (char const   *)(f->name), 16);
      }
#line 255
      if (! tmp___0) {
#line 255
        goto while_break;
      }
    } else {
#line 255
      goto while_break;
    }
#line 255
    f = f->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 256
  if (! f) {
    {
#line 257
    Eprint("%s: `%s\'", ErrMsg[6], name);
    }
#line 258
    return (6);
  }
#line 261
  if (DebugFlag & 2) {
    {
#line 262
    fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"%s %s(",
            ErrMsg[78], f->name);
#line 263
    i = 0;
    }
    {
#line 263
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 263
      if (! (i < nargs)) {
#line 263
        goto while_break___0;
      }
      {
#line 264
      PrintValue(& ValStack[(ValStackPtr - nargs) + i], ErrFp);
      }
#line 265
      if (i < nargs - 1) {
        {
#line 265
        fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)", ");
        }
      }
#line 263
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 267
    fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)")\n");
    }
  }
#line 270
  if (f->IsActive) {
#line 271
    if (DebugFlag & 2) {
      {
#line 272
      fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"%s %s() => ",
              ErrMsg[79], name);
#line 273
      fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"%s\n",
              ErrMsg[43]);
      }
    }
#line 275
    return (43);
  }
#line 279
  if (nargs != f->nargs) {
#line 280
    if (DebugFlag & 2) {
      {
#line 281
      fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"%s %s() => ",
              ErrMsg[79], name);
      }
#line 282
      if (nargs < f->nargs) {
#line 282
        tmp___1 = 25;
      } else {
#line 282
        tmp___1 = 26;
      }
      {
#line 282
      fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"%s\n",
              ErrMsg[tmp___1]);
      }
    }
#line 285
    if (nargs < f->nargs) {
#line 285
      tmp___2 = 25;
    } else {
#line 285
      tmp___2 = 26;
    }
#line 285
    return (tmp___2);
  }
  {
#line 288
  h = SetUpLocalVars(f);
  }
#line 289
  if (h) {
#line 290
    if (DebugFlag & 2) {
      {
#line 291
      fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"%s %s() => ",
              ErrMsg[79], name);
#line 292
      fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"%s\n",
              ErrMsg[h]);
      }
    }
#line 294
    return (h);
  }
#line 298
  f->IsActive = (char)1;
#line 299
  s = f->text;
  {
#line 302
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 302
    tmp___3 = __ctype_b_loc();
    }
#line 302
    if (! ((int const   )*(*tmp___3 + (int )*s) & 8192)) {
#line 302
      if (! ((int const   )*s == 92)) {
#line 302
        goto while_break___1;
      }
    }
#line 302
    s ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 303
  if ((int const   )*s == 91) {
#line 303
    s ++;
  }
  {
#line 304
  h = Evaluate(& s, f->locals, p);
#line 305
  f->IsActive = (char)0;
#line 306
  DestroyLocalVals(f);
  }
#line 307
  if (DebugFlag & 2) {
    {
#line 308
    fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"%s %s() => ",
            ErrMsg[79], name);
    }
#line 309
    if (h) {
      {
#line 309
      fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"%s\n",
              ErrMsg[h]);
      }
    } else {
      {
#line 311
      PrintValue(& ValStack[ValStackPtr - 1], ErrFp);
#line 312
      fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"\n");
      }
    }
  }
#line 315
  return (h);
}
}
#line 325 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/userfns.c"
static int SetUpLocalVars(UserFunc *f ) 
{ 
  int i ;
  int r ;
  Var *var ;

  {
#line 330
  i = 0;
#line 330
  var = f->locals;
  {
#line 330
  while (1) {
    while_continue: /* CIL Label */ ;
#line 330
    if (var) {
#line 330
      if (! (i < f->nargs)) {
#line 330
        goto while_break;
      }
    } else {
#line 330
      goto while_break;
    }
    {
#line 331
    r = FnPopValStack(& var->v);
    }
#line 331
    if (r) {
      {
#line 332
      DestroyLocalVals(f);
      }
#line 333
      return (r);
    }
#line 330
    var = var->next;
#line 330
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 336
  return (0);
}
}
#line 347 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/userfns.c"
static void DestroyLocalVals(UserFunc *f ) 
{ 
  Var *v ;

  {
#line 349
  v = f->locals;
  {
#line 351
  while (1) {
    while_continue: /* CIL Label */ ;
#line 351
    if (! v) {
#line 351
      goto while_break;
    }
#line 352
    if ((int )v->v.type == 4) {
#line 352
      if (v->v.v.str) {
        {
#line 352
        free((void *)v->v.v.str);
#line 352
        v->v.type = (char)0;
        }
      }
    }
#line 353
    v = v->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 355
  return;
}
}
#line 364 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/userfns.c"
int UserFuncExists(char const   *fn ) 
{ 
  UserFunc *f ;
  int h ;
  unsigned int tmp ;
  int tmp___0 ;

  {
  {
#line 367
  tmp = HashVal(fn);
#line 367
  h = (int )(tmp % 32U);
#line 369
  f = FuncHash[h];
  }
  {
#line 370
  while (1) {
    while_continue: /* CIL Label */ ;
#line 370
    if (f) {
      {
#line 370
      tmp___0 = StrinCmp(fn, (char const   *)(f->name), 16);
      }
#line 370
      if (! tmp___0) {
#line 370
        goto while_break;
      }
    } else {
#line 370
      goto while_break;
    }
#line 370
    f = f->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 371
  if (! f) {
#line 371
    return (-1);
  } else {
#line 372
    return (f->nargs);
  }
}
}
#line 242 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 444
extern unsigned int sleep(unsigned int __seconds ) ;
#line 578
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execvp)(char const   *__file ,
                                                                                               char * const  *__argv ) ;
#line 779
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/protos.h"
int TriggerReminder(ParsePtr p , Trigger *t , TimeTrig *tim , int jul ) ;
#line 66
int SystemDate(int *y , int *m , int *d ) ;
#line 84
int QueueReminder(ParsePtr p , Trigger *trig , TimeTrig *tim , char const   *sched ) ;
#line 85
void HandleQueuedReminders(void) ;
#line 137
void SigIntHandler(int d ) ;
#line 138
void GotSigInt(void) ;
#line 52 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/queue.c"
static QueuedRem *QueueHead  ;
#line 53 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/queue.c"
static time_t FileModTime  ;
#line 54 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/queue.c"
static struct stat StatBuf  ;
#line 56
static void CheckInitialFile(void) ;
#line 57
static int CalculateNextTime(QueuedRem *q ) ;
#line 58
static QueuedRem *FindNextReminder(void) ;
#line 59
static int CalculateNextTimeUsingSched(QueuedRem *q ) ;
#line 60
static void DaemonWait(unsigned int sleeptime ) ;
#line 61
static void reread(void) ;
#line 71 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/queue.c"
int QueueReminder(ParsePtr p , Trigger *trig , TimeTrig *tim , char const   *sched ) 
{ 
  QueuedRem *qelem ;
  long tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 76
  if (DontQueue) {
#line 80
    return (0);
  } else
#line 76
  if (tim->ttime == 2147483647) {
#line 80
    return (0);
  } else
#line 76
  if (trig->typ == 3) {
#line 80
    return (0);
  } else {
    {
#line 76
    tmp = SystemTime(0);
    }
#line 76
    if ((long )tim->ttime < tmp / 60L) {
#line 80
      return (0);
    } else
#line 76
    if (trig->typ == 2) {
#line 76
      if (RunDisabled) {
#line 80
        return (0);
      }
    }
  }
  {
#line 82
  tmp___0 = malloc(sizeof(QueuedRem ));
#line 82
  qelem = (QueuedRem *)tmp___0;
  }
#line 83
  if (! qelem) {
#line 84
    return (9);
  }
  {
#line 86
  tmp___1 = StrDup(p->pos);
#line 86
  qelem->text = (char const   *)tmp___1;
  }
#line 87
  if (! qelem->text) {
    {
#line 88
    free((void *)qelem);
    }
#line 89
    return (9);
  }
  {
#line 91
  NumQueued ++;
#line 92
  qelem->typ = trig->typ;
#line 93
  strcpy((char */* __restrict  */)(qelem->passthru), (char const   */* __restrict  */)(trig->passthru));
#line 94
  qelem->tt = *tim;
#line 95
  qelem->next = QueueHead;
#line 96
  qelem->RunDisabled = RunDisabled;
#line 97
  qelem->ntrig = 0;
#line 98
  strcpy((char */* __restrict  */)(qelem->sched), (char const   */* __restrict  */)sched);
#line 99
  DBufInit(& qelem->tags);
#line 100
  DBufPuts(& qelem->tags, (char const   *)trig->tags.buffer);
  }
#line 101
  if (SynthesizeTags) {
    {
#line 102
    tmp___2 = SynthesizeTag();
#line 102
    AppendTag(& qelem->tags, tmp___2);
    }
  }
#line 104
  QueueHead = qelem;
#line 105
  return (0);
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/queue.c"
void HandleQueuedReminders(void) 
{ 
  QueuedRem *q ;
  int TimeToSleep ;
  unsigned int SleepTime ;
  Parser p ;
  Trigger trig ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  int y ;
  int m ;
  int d ;
  int tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  char const   *tmp___8 ;
  long tmp___9 ;
  char const   *tmp___10 ;
  long tmp___11 ;

  {
#line 117
  q = QueueHead;
#line 124
  NumTriggered = 1;
#line 127
  SortByDate = 0;
#line 138
  if (! DontFork) {
    {
#line 138
    tmp = isatty(1);
    }
#line 138
    if (tmp) {
      {
#line 138
      tmp___0 = isatty(2);
      }
#line 138
      if (! tmp___0) {
        {
#line 139
        close(1);
#line 140
        close(2);
        }
      }
    } else {
      {
#line 139
      close(1);
#line 140
      close(2);
      }
    }
  }
#line 144
  if (Daemon > 0) {
    {
#line 145
    tmp___1 = stat((char const   */* __restrict  */)InitialFile, (struct stat */* __restrict  */)(& StatBuf));
    }
#line 145
    if (tmp___1) {
      {
#line 146
      fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"Cannot stat %s - not running as daemon!\n",
              InitialFile);
#line 148
      Daemon = 0;
      }
    } else {
#line 149
      FileModTime = StatBuf.st_mtim.tv_sec;
    }
  }
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! q) {
#line 154
      goto while_break;
    }
    {
#line 155
    tmp___2 = SystemTime(0);
#line 155
    q->tt.nexttime = (int )(tmp___2 / 60L - 1L);
#line 156
    q->tt.nexttime = CalculateNextTime(q);
#line 157
    q = q->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  if (! DontFork) {
    {
#line 160
    signal(2, & SigIntHandler);
    }
  } else
#line 160
  if (Daemon) {
    {
#line 160
    signal(2, & SigIntHandler);
    }
  }
  {
#line 163
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 164
    q = FindNextReminder();
    }
#line 167
    if (! q) {
#line 167
      if (! Daemon) {
#line 167
        goto while_break___0;
      }
    }
#line 169
    if (Daemon) {
#line 169
      if (! q) {
#line 170
        if (Daemon < 0) {
          {
#line 172
          tmp___3 = SystemTime(0);
#line 172
          TimeToSleep = (int )(86400L - tmp___3);
          }
        } else {
#line 174
          TimeToSleep = 60 * Daemon;
        }
      } else {
        {
#line 177
        tmp___4 = SystemTime(0);
#line 177
        TimeToSleep = (int )((long )q->tt.nexttime * 60L - tmp___4);
        }
      }
    } else {
      {
#line 177
      tmp___4 = SystemTime(0);
#line 177
      TimeToSleep = (int )((long )q->tt.nexttime * 60L - tmp___4);
      }
    }
    {
#line 180
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 180
      if (! ((long )TimeToSleep > 0L)) {
#line 180
        goto while_break___1;
      }
#line 181
      SleepTime = (unsigned int )TimeToSleep;
#line 183
      if (Daemon > 0) {
#line 183
        if (SleepTime > (unsigned int )(60 * Daemon)) {
#line 183
          SleepTime = (unsigned int )(60 * Daemon);
        }
      }
#line 187
      if (Daemon <= 0) {
#line 188
        if (SleepTime > 60U) {
#line 189
          SleepTime = 60U;
        }
      }
#line 193
      if (Daemon >= 0) {
        {
#line 194
        sleep(SleepTime);
        }
      } else {
        {
#line 196
        DaemonWait(SleepTime);
        }
      }
#line 201
      if (! Daemon) {
        {
#line 203
        tmp___5 = SystemDate(& y, & m, & d);
        }
#line 203
        if (RealToday != tmp___5) {
          {
#line 204
          exit(0);
          }
        }
      }
#line 208
      if (Daemon > 0) {
#line 208
        if (SleepTime) {
          {
#line 208
          CheckInitialFile();
          }
        }
      }
#line 210
      if (Daemon) {
#line 210
        if (! q) {
#line 211
          if (Daemon < 0) {
            {
#line 213
            tmp___6 = SystemTime(0);
#line 213
            TimeToSleep = (int )(86400L - tmp___6);
            }
          } else {
#line 215
            TimeToSleep = 60 * Daemon;
          }
        } else {
          {
#line 218
          tmp___7 = SystemTime(0);
#line 218
          TimeToSleep = (int )((long )q->tt.nexttime * 60L - tmp___7);
          }
        }
      } else {
        {
#line 218
        tmp___7 = SystemTime(0);
#line 218
        TimeToSleep = (int )((long )q->tt.nexttime * 60L - tmp___7);
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 228
    tmp___11 = SystemTime(0);
    }
#line 228
    if (tmp___11 - (long )(q->tt.nexttime * 60) <= 60L) {
#line 228
      goto _L;
    } else
#line 228
    if (q->tt.nexttime == q->tt.ttime) {
      _L: /* CIL Label */ 
      {
#line 231
      CreateParser(q->text, & p);
#line 232
      trig.typ = q->typ;
#line 233
      strcpy((char */* __restrict  */)(trig.passthru), (char const   */* __restrict  */)(q->passthru));
#line 234
      RunDisabled = q->RunDisabled;
      }
#line 235
      if (Daemon < 0) {
        {
#line 236
        tmp___8 = SimpleTime(q->tt.ttime);
#line 236
        printf((char const   */* __restrict  */)"NOTE reminder %s", tmp___8);
#line 238
        tmp___9 = SystemTime(0);
#line 238
        tmp___10 = SimpleTime((int )(tmp___9 / 60L));
#line 238
        printf((char const   */* __restrict  */)"%s", tmp___10);
        }
#line 239
        if (! *(q->tags.buffer)) {
          {
#line 240
          printf((char const   */* __restrict  */)"*\n");
          }
        } else {
          {
#line 242
          printf((char const   */* __restrict  */)"%s\n", q->tags.buffer);
          }
        }
      }
      {
#line 248
      LastTriggerDate = JulianToday;
#line 249
      LastTriggerTime = q->tt.ttime;
#line 250
      LastTrigValid = 1;
#line 251
      TriggerReminder(& p, & trig, & q->tt, JulianToday);
      }
#line 252
      if (Daemon < 0) {
        {
#line 253
        printf((char const   */* __restrict  */)"NOTE endreminder\n");
        }
      }
      {
#line 255
      fflush(stdout);
#line 256
      DestroyParser(& p);
      }
    }
    {
#line 260
    q->tt.nexttime = CalculateNextTime(q);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 262
  exit(0);
  }
}
}
#line 277 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/queue.c"
static int CalculateNextTime(QueuedRem *q ) 
{ 
  int tim ;
  int rep ;
  int delta ;
  int curtime ;
  int r ;

  {
#line 279
  tim = q->tt.ttime;
#line 280
  rep = q->tt.rep;
#line 281
  delta = q->tt.delta;
#line 282
  curtime = q->tt.nexttime + 1;
#line 286
  (q->ntrig) ++;
#line 287
  if (q->sched[0]) {
    {
#line 288
    r = CalculateNextTimeUsingSched(q);
    }
#line 289
    if (r != 2147483647) {
#line 289
      return (r);
    }
  }
#line 291
  if (delta == 0) {
#line 292
    if (tim < curtime) {
#line 293
      return (2147483647);
    } else {
#line 295
      return (tim);
    }
  }
#line 299
  tim -= delta;
#line 300
  if (rep == 0) {
#line 300
    rep = delta;
  }
#line 301
  if (tim < curtime) {
#line 301
    tim += ((curtime - tim) / rep) * rep;
  }
#line 302
  if (tim < curtime) {
#line 302
    tim += rep;
  }
#line 303
  if (tim > q->tt.ttime) {
#line 303
    tim = q->tt.ttime;
  }
#line 304
  if (tim < curtime) {
#line 304
    return (2147483647);
  } else {
#line 304
    return (tim);
  }
}
}
#line 314 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/queue.c"
static QueuedRem *FindNextReminder(void) 
{ 
  QueuedRem *q ;
  QueuedRem *ans ;

  {
#line 316
  q = QueueHead;
#line 317
  ans = (QueuedRem *)((void *)0);
  {
#line 319
  while (1) {
    while_continue: /* CIL Label */ ;
#line 319
    if (! q) {
#line 319
      goto while_break;
    }
#line 320
    if (q->tt.nexttime != 2147483647) {
#line 321
      if (! ans) {
#line 321
        ans = q;
      } else
#line 322
      if (q->tt.nexttime < ans->tt.nexttime) {
#line 322
        ans = q;
      }
    }
#line 325
    q = q->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 327
  return (ans);
}
}
#line 339 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/queue.c"
void GotSigInt(void) 
{ 
  QueuedRem *q ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
  {
#line 341
  q = QueueHead;
#line 343
  printf((char const   */* __restrict  */)"Contents of AT queue:%s", "\n");
  }
  {
#line 345
  while (1) {
    while_continue: /* CIL Label */ ;
#line 345
    if (! q) {
#line 345
      goto while_break;
    }
#line 346
    if (q->tt.nexttime != 2147483647) {
      {
#line 347
      printf((char const   */* __restrict  */)"Trigger: %02d%c%02d  Activate: %02d%c%02d  Rep: %d  Delta: %d  Sched: %s",
             q->tt.ttime / 60, (int )TimeSep, q->tt.ttime % 60, q->tt.nexttime / 60,
             (int )TimeSep, q->tt.nexttime % 60, q->tt.rep, q->tt.delta, q->sched);
      }
#line 351
      if (q->sched[0]) {
        {
#line 351
        printf((char const   */* __restrict  */)"(%d)", q->ntrig + 1);
        }
      }
      {
#line 352
      printf((char const   */* __restrict  */)"%s", "\n");
      }
#line 353
      if (q->passthru[0]) {
#line 353
        tmp = " ";
      } else {
#line 353
        tmp = "";
      }
#line 353
      if (q->typ == 1) {
#line 353
        tmp___2 = "MSG";
      } else {
#line 353
        if (q->typ == 7) {
#line 353
          tmp___1 = "MSF";
        } else {
#line 353
          if (q->typ == 2) {
#line 353
            tmp___0 = "RUN";
          } else {
#line 353
            tmp___0 = "SPECIAL";
          }
#line 353
          tmp___1 = tmp___0;
        }
#line 353
        tmp___2 = tmp___1;
      }
      {
#line 353
      printf((char const   */* __restrict  */)"Text: %s %s%s%s%s%s", tmp___2, q->passthru,
             tmp, q->text, "\n", "\n");
      }
    }
#line 361
    q = q->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 363
  printf((char const   */* __restrict  */)"\n");
  }
#line 364
  return;
}
}
#line 374 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/queue.c"
static void CheckInitialFile(void) 
{ 
  time_t tim ;
  int y ;
  int m ;
  int d ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 377
  tim = FileModTime;
#line 380
  tmp = stat((char const   */* __restrict  */)InitialFile, (struct stat */* __restrict  */)(& StatBuf));
  }
#line 380
  if (tmp == 0) {
#line 380
    tim = StatBuf.st_mtim.tv_sec;
  }
#line 381
  if (tim != FileModTime) {
    {
#line 383
    reread();
    }
  } else {
    {
#line 381
    tmp___0 = SystemDate(& y, & m, & d);
    }
#line 381
    if (RealToday != tmp___0) {
      {
#line 383
      reread();
      }
    }
  }
#line 385
  return;
}
}
#line 394 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/queue.c"
static int CalculateNextTimeUsingSched(QueuedRem *q ) 
{ 
  int r ;
  Value v ;
  char const   *s ;
  int LastTime ;
  int ThisTime ;
  int tmp ;
  char exprBuf[48] ;

  {
  {
#line 400
  LastTime = -1;
#line 403
  tmp = UserFuncExists((char const   *)(q->sched));
  }
#line 403
  if (tmp != 1) {
#line 404
    q->sched[0] = (char)0;
#line 405
    return (2147483647);
  }
#line 408
  RunDisabled = q->RunDisabled;
  {
#line 410
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 412
    sprintf((char */* __restrict  */)(exprBuf), (char const   */* __restrict  */)"%s(%d)",
            q->sched, q->ntrig);
#line 413
    s = (char const   *)(exprBuf);
#line 414
    r = EvalExpr(& s, & v, (ParsePtr )((void *)0));
    }
#line 415
    if (r) {
#line 416
      q->sched[0] = (char)0;
#line 417
      return (2147483647);
    }
#line 419
    if ((int )v.type == 2) {
#line 420
      ThisTime = v.v.val;
    } else
#line 421
    if ((int )v.type == 1) {
#line 422
      if (v.v.val > 0) {
#line 423
        if (LastTime >= 0) {
#line 424
          ThisTime = LastTime + v.v.val;
        } else {
#line 426
          ThisTime = q->tt.nexttime + v.v.val;
        }
      } else {
#line 429
        ThisTime = q->tt.ttime + v.v.val;
      }
    } else {
#line 432
      if ((int )v.type == 4) {
#line 432
        if (v.v.str) {
          {
#line 432
          free((void *)v.v.str);
#line 432
          v.type = (char)0;
          }
        }
      }
#line 433
      q->sched[0] = (char)0;
#line 434
      return (2147483647);
    }
#line 436
    if (ThisTime < 0) {
#line 436
      ThisTime = 0;
    }
#line 437
    if (ThisTime > 1439) {
#line 437
      ThisTime = 1439;
    }
#line 438
    if (DebugFlag & 2) {
      {
#line 439
      fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"SCHED: Considering %02d%c%02d\n",
              ThisTime / 60, (int )TimeSep, ThisTime % 60);
      }
    }
#line 442
    if (ThisTime > q->tt.nexttime) {
#line 442
      return (ThisTime);
    }
#line 443
    if (ThisTime <= LastTime) {
#line 444
      q->sched[0] = (char)0;
#line 445
      return (2147483647);
    }
#line 447
    LastTime = ThisTime;
#line 448
    (q->ntrig) ++;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 459 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/queue.c"
static void DaemonWait(unsigned int sleeptime ) 
{ 
  fd_set readSet ;
  struct timeval timeout ;
  int retval ;
  int y ;
  int m ;
  int d ;
  char cmdLine[256] ;
  int __d0 ;
  int __d1 ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int nqueued ;
  QueuedRem *q ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 467
  while (1) {
    while_continue: /* CIL Label */ ;
#line 467
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& readSet.__fds_bits[0]): "memory");
#line 467
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 468
  readSet.__fds_bits[0 / (8 * (int )sizeof(__fd_mask ))] |= 1L << 0 % (8 * (int )sizeof(__fd_mask ));
#line 469
  timeout.tv_sec = (__time_t )sleeptime;
#line 470
  timeout.tv_usec = (__suseconds_t )0;
#line 471
  retval = select(1, (fd_set */* __restrict  */)(& readSet), (fd_set */* __restrict  */)((void *)0),
                  (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& timeout));
#line 474
  tmp = SystemDate(& y, & m, & d);
  }
#line 474
  if (RealToday != tmp) {
    {
#line 475
    printf((char const   */* __restrict  */)"NOTE newdate\nNOTE reread\n");
#line 476
    fflush(stdout);
#line 477
    reread();
    }
  }
#line 481
  if (retval <= 0) {
#line 481
    return;
  }
#line 484
  if (! ((readSet.__fds_bits[0 / (8 * (int )sizeof(__fd_mask ))] & (1L << 0 % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
#line 484
    return;
  }
  {
#line 487
  tmp___0 = feof(stdin);
  }
#line 487
  if (tmp___0) {
    {
#line 488
    exit(0);
    }
  }
  {
#line 492
  tmp___1 = fgets((char */* __restrict  */)(cmdLine), (int )sizeof(cmdLine), (FILE */* __restrict  */)stdin);
  }
#line 492
  if (! tmp___1) {
    {
#line 493
    exit(0);
    }
  }
  {
#line 496
  tmp___4 = strcmp((char const   *)(cmdLine), "EXIT\n");
  }
#line 496
  if (tmp___4) {
    {
#line 498
    tmp___3 = strcmp((char const   *)(cmdLine), "STATUS\n");
    }
#line 498
    if (tmp___3) {
      {
#line 509
      tmp___2 = strcmp((char const   *)(cmdLine), "REREAD\n");
      }
#line 509
      if (tmp___2) {
        {
#line 514
        printf((char const   */* __restrict  */)"ERR Invalid daemon command: %s",
               cmdLine);
#line 515
        fflush(stdout);
        }
      } else {
        {
#line 510
        printf((char const   */* __restrict  */)"NOTE reread\n");
#line 511
        fflush(stdout);
#line 512
        reread();
        }
      }
    } else {
#line 499
      nqueued = 0;
#line 500
      q = QueueHead;
      {
#line 501
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 501
        if (! q) {
#line 501
          goto while_break___0;
        }
#line 502
        if (q->tt.nexttime != 2147483647) {
#line 503
          nqueued ++;
        }
#line 505
        q = q->next;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 507
      printf((char const   */* __restrict  */)"NOTE queued %d\n", nqueued);
#line 508
      fflush(stdout);
      }
    }
  } else {
    {
#line 497
    exit(0);
    }
  }
#line 517
  return;
}
}
#line 526 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/queue.c"
static void reread(void) 
{ 


  {
  {
#line 528
  execvp(*(ArgV + 0), (char * const  *)((char **)ArgV));
  }
#line 529
  return;
}
}
#line 263 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 564 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 578
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) putenv)(char *__string ) ;
#line 116 "/usr/include/pwd.h"
extern struct passwd *getpwnam(char const   *__name ) ;
#line 675 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 681
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getgid)(void) ;
#line 684
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getegid)(void) ;
#line 700
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setuid)(__uid_t __uid ) ;
#line 717
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setgid)(__gid_t __gid ) ;
#line 50 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/protos.h"
void InitRemind(int argc , char const   **argv ) ;
#line 51
void Usage(void) ;
#line 130
int CalcMinsFromUTC(int jul , int tim , int *mins , int *isdst ) ;
#line 87 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/init.c"
static void ChgUser(char const   *user ) ;
#line 88
static void InitializeVar(char const   *str ) ;
#line 90 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/init.c"
static char const   *BadDate  =    "Illegal date on command line\n";
#line 92 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/init.c"
static DynamicBuffer default_filename_buf  ;
#line 102 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/init.c"
static char const   *DefaultFilename(void) 
{ 
  char const   *s ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 106
  DBufInit(& default_filename_buf);
#line 108
  tmp = getenv("DOTREMINDERS");
#line 108
  s = (char const   *)tmp;
  }
#line 109
  if (s) {
#line 110
    return (s);
  }
  {
#line 113
  tmp___0 = getenv("HOME");
#line 113
  s = (char const   *)tmp___0;
  }
#line 114
  if (! s) {
    {
#line 115
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"HOME environment variable not set.  Unable to determine reminder file.\n");
#line 116
    exit(1);
    }
  }
  {
#line 118
  DBufPuts(& default_filename_buf, s);
#line 119
  DBufPuts(& default_filename_buf, "/.reminders");
  }
#line 120
  return ((char const   *)default_filename_buf.buffer);
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/init.c"
void InitRemind(int argc , char const   **argv ) 
{ 
  char const   *arg ;
  int i ;
  int y ;
  int m ;
  int d ;
  int rep ;
  Token tok ;
  int InvokedAsRem ;
  char const   *s ;
  int weeks ;
  int jul ;
  __gid_t tmp ;
  __gid_t tmp___0 ;
  __uid_t tmp___1 ;
  __uid_t tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  unsigned short const   **tmp___6 ;
  unsigned short const   **tmp___7 ;
  unsigned short const   **tmp___8 ;
  unsigned short const   **tmp___9 ;
  unsigned short const   **tmp___10 ;
  unsigned short const   **tmp___11 ;
  unsigned short const   **tmp___12 ;
  unsigned short const   **tmp___13 ;
  unsigned short const   **tmp___14 ;
  unsigned short const   **tmp___15 ;
  unsigned short const   **tmp___16 ;
  unsigned short const   **tmp___17 ;
  char const   *tmp___18 ;
  unsigned short const   **tmp___19 ;
  unsigned short const   **tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  long tmp___26 ;

  {
  {
#line 136
  InvokedAsRem = 0;
#line 148
  jul = -1;
#line 151
  DBufInit(& Banner);
#line 152
  DBufInit(& LineBuffer);
#line 153
  DBufInit(& ExprBuf);
#line 155
  DBufPuts(& Banner, "Reminders for %w, %d%s %m, %y%o:");
#line 157
  PurgeFP = (FILE *)((void *)0);
#line 160
  tmp = getgid();
#line 160
  tmp___0 = getegid();
  }
#line 160
  if (tmp != tmp___0) {
    {
#line 162
    fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"\nRemind should not be installed set-uid or set-gid.\nCHECK YOUR SYSTEM SECURITY.\n");
#line 163
    exit(1);
    }
  } else {
    {
#line 160
    tmp___1 = getuid();
#line 160
    tmp___2 = geteuid();
    }
#line 160
    if (tmp___1 != tmp___2) {
      {
#line 162
      fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"\nRemind should not be installed set-uid or set-gid.\nCHECK YOUR SYSTEM SECURITY.\n");
#line 163
      exit(1);
      }
    }
  }
  {
#line 166
  y = -1;
#line 167
  m = -1;
#line 168
  d = -1;
#line 169
  rep = 0;
#line 171
  RealToday = SystemDate(& CurYear, & CurMon, & CurDay);
  }
#line 172
  if (RealToday < 0) {
    {
#line 173
    fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)ErrMsg[83],
            1990);
#line 174
    exit(1);
    }
  }
  {
#line 176
  JulianToday = RealToday;
#line 177
  FromJulian(JulianToday, & CurYear, & CurMon, & CurDay);
  }
#line 180
  if (*(argv + 0)) {
    {
#line 181
    tmp___3 = strrchr(*(argv + 0), '/');
#line 181
    s = (char const   *)tmp___3;
    }
#line 182
    if (! s) {
#line 183
      s = *(argv + 0);
    } else {
#line 185
      s ++;
    }
    {
#line 187
    tmp___4 = strcmp(s, "rem");
    }
#line 187
    if (! tmp___4) {
#line 188
      InvokedAsRem = 1;
    }
  }
#line 193
  i = 1;
  {
#line 194
  while (1) {
    while_continue: /* CIL Label */ ;
#line 194
    if (! (i < argc)) {
#line 194
      goto while_break;
    }
#line 195
    arg = *(argv + i);
#line 196
    if ((int const   )*arg != 45) {
#line 196
      goto while_break;
    }
#line 197
    i ++;
#line 198
    arg ++;
#line 199
    if (! *arg) {
#line 200
      UseStdin = 1;
#line 201
      IgnoreOnce = 1;
#line 202
      i --;
#line 203
      goto while_break;
    }
    {
#line 205
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 205
      if (! *arg) {
#line 205
        goto while_break___0;
      }
#line 206
      tmp___5 = arg;
#line 206
      arg ++;
      {
#line 209
      if ((int const   )*tmp___5 == 74) {
#line 209
        goto case_74;
      }
#line 209
      if ((int const   )*tmp___5 == 106) {
#line 209
        goto case_74;
      }
#line 216
      if ((int const   )*tmp___5 == 73) {
#line 216
        goto case_73;
      }
#line 216
      if ((int const   )*tmp___5 == 105) {
#line 216
        goto case_73;
      }
#line 222
      if ((int const   )*tmp___5 == 78) {
#line 222
        goto case_78;
      }
#line 222
      if ((int const   )*tmp___5 == 110) {
#line 222
        goto case_78;
      }
#line 229
      if ((int const   )*tmp___5 == 82) {
#line 229
        goto case_82;
      }
#line 229
      if ((int const   )*tmp___5 == 114) {
#line 229
        goto case_82;
      }
#line 234
      if ((int const   )*tmp___5 == 77) {
#line 234
        goto case_77;
      }
#line 234
      if ((int const   )*tmp___5 == 109) {
#line 234
        goto case_77;
      }
#line 239
      if ((int const   )*tmp___5 == 79) {
#line 239
        goto case_79;
      }
#line 239
      if ((int const   )*tmp___5 == 111) {
#line 239
        goto case_79;
      }
#line 244
      if ((int const   )*tmp___5 == 89) {
#line 244
        goto case_89;
      }
#line 244
      if ((int const   )*tmp___5 == 121) {
#line 244
        goto case_89;
      }
#line 249
      if ((int const   )*tmp___5 == 84) {
#line 249
        goto case_84;
      }
#line 249
      if ((int const   )*tmp___5 == 116) {
#line 249
        goto case_84;
      }
#line 260
      if ((int const   )*tmp___5 == 69) {
#line 260
        goto case_69;
      }
#line 260
      if ((int const   )*tmp___5 == 101) {
#line 260
        goto case_69;
      }
#line 265
      if ((int const   )*tmp___5 == 72) {
#line 265
        goto case_72;
      }
#line 265
      if ((int const   )*tmp___5 == 104) {
#line 265
        goto case_72;
      }
#line 270
      if ((int const   )*tmp___5 == 71) {
#line 270
        goto case_71;
      }
#line 270
      if ((int const   )*tmp___5 == 103) {
#line 270
        goto case_71;
      }
#line 298
      if ((int const   )*tmp___5 == 85) {
#line 298
        goto case_85;
      }
#line 298
      if ((int const   )*tmp___5 == 117) {
#line 298
        goto case_85;
      }
#line 304
      if ((int const   )*tmp___5 == 90) {
#line 304
        goto case_90;
      }
#line 304
      if ((int const   )*tmp___5 == 122) {
#line 304
        goto case_90;
      }
#line 319
      if ((int const   )*tmp___5 == 65) {
#line 319
        goto case_65;
      }
#line 319
      if ((int const   )*tmp___5 == 97) {
#line 319
        goto case_65;
      }
#line 324
      if ((int const   )*tmp___5 == 81) {
#line 324
        goto case_81;
      }
#line 324
      if ((int const   )*tmp___5 == 113) {
#line 324
        goto case_81;
      }
#line 329
      if ((int const   )*tmp___5 == 70) {
#line 329
        goto case_70;
      }
#line 329
      if ((int const   )*tmp___5 == 102) {
#line 329
        goto case_70;
      }
#line 333
      if ((int const   )*tmp___5 == 67) {
#line 333
        goto case_67;
      }
#line 333
      if ((int const   )*tmp___5 == 99) {
#line 333
        goto case_67;
      }
#line 376
      if ((int const   )*tmp___5 == 83) {
#line 376
        goto case_83;
      }
#line 376
      if ((int const   )*tmp___5 == 115) {
#line 376
        goto case_83;
      }
#line 402
      if ((int const   )*tmp___5 == 80) {
#line 402
        goto case_80;
      }
#line 402
      if ((int const   )*tmp___5 == 112) {
#line 402
        goto case_80;
      }
#line 414
      if ((int const   )*tmp___5 == 76) {
#line 414
        goto case_76;
      }
#line 414
      if ((int const   )*tmp___5 == 108) {
#line 414
        goto case_76;
      }
#line 419
      if ((int const   )*tmp___5 == 87) {
#line 419
        goto case_87;
      }
#line 419
      if ((int const   )*tmp___5 == 119) {
#line 419
        goto case_87;
      }
#line 439
      if ((int const   )*tmp___5 == 68) {
#line 439
        goto case_68;
      }
#line 439
      if ((int const   )*tmp___5 == 100) {
#line 439
        goto case_68;
      }
#line 455
      if ((int const   )*tmp___5 == 86) {
#line 455
        goto case_86___0;
      }
#line 455
      if ((int const   )*tmp___5 == 118) {
#line 455
        goto case_86___0;
      }
#line 461
      if ((int const   )*tmp___5 == 66) {
#line 461
        goto case_66;
      }
#line 461
      if ((int const   )*tmp___5 == 98) {
#line 461
        goto case_66;
      }
#line 467
      if ((int const   )*tmp___5 == 88) {
#line 467
        goto case_88___0;
      }
#line 467
      if ((int const   )*tmp___5 == 120) {
#line 467
        goto case_88___0;
      }
#line 473
      if ((int const   )*tmp___5 == 75) {
#line 473
        goto case_75;
      }
#line 473
      if ((int const   )*tmp___5 == 107) {
#line 473
        goto case_75;
      }
#line 478
      goto switch_default___0;
      case_74: /* CIL Label */ 
      case_106: /* CIL Label */ 
#line 210
      PurgeMode = 1;
#line 211
      if (*arg) {
#line 212
        PurgeIncludeDepth = 0;
        {
#line 212
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 212
          tmp___6 = __ctype_b_loc();
          }
#line 212
          if (! ((int const   )*(*tmp___6 + (int )*arg) & 2048)) {
#line 212
            goto while_break___1;
          }
#line 212
          PurgeIncludeDepth *= 10;
#line 212
          PurgeIncludeDepth += (int )((int const   )*arg - 48);
#line 212
          arg ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 214
      goto switch_break;
      case_73: /* CIL Label */ 
      case_105: /* CIL Label */ 
      {
#line 217
      InitializeVar(arg);
      }
      {
#line 218
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 218
        if (! *arg) {
#line 218
          goto while_break___2;
        }
#line 218
        arg ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 219
      goto switch_break;
      case_78: /* CIL Label */ 
      case_110: /* CIL Label */ 
#line 223
      NextMode = 1;
#line 224
      DontQueue = 1;
#line 225
      Daemon = 0;
#line 226
      goto switch_break;
      case_82: /* CIL Label */ 
      case_114: /* CIL Label */ 
#line 230
      RunDisabled = 1;
#line 231
      goto switch_break;
      case_77: /* CIL Label */ 
      case_109: /* CIL Label */ 
#line 235
      MondayFirst = 1;
#line 236
      goto switch_break;
      case_79: /* CIL Label */ 
      case_111: /* CIL Label */ 
#line 240
      IgnoreOnce = 1;
#line 241
      goto switch_break;
      case_89: /* CIL Label */ 
      case_121: /* CIL Label */ 
#line 245
      SynthesizeTags = 1;
#line 246
      goto switch_break;
      case_84: /* CIL Label */ 
      case_116: /* CIL Label */ 
#line 250
      if (! *arg) {
#line 251
        InfiniteDelta = 1;
      } else {
#line 253
        DeltaOffset = 0;
        {
#line 253
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 253
          tmp___7 = __ctype_b_loc();
          }
#line 253
          if (! ((int const   )*(*tmp___7 + (int )*arg) & 2048)) {
#line 253
            goto while_break___3;
          }
#line 253
          DeltaOffset *= 10;
#line 253
          DeltaOffset += (int )((int const   )*arg - 48);
#line 253
          arg ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 254
        if (DeltaOffset < 0) {
#line 255
          DeltaOffset = 0;
        }
      }
#line 258
      goto switch_break;
      case_69: /* CIL Label */ 
      case_101: /* CIL Label */ 
#line 261
      ErrFp = stdout;
#line 262
      goto switch_break;
      case_72: /* CIL Label */ 
      case_104: /* CIL Label */ 
#line 266
      Hush = 1;
#line 267
      goto switch_break;
      case_71: /* CIL Label */ 
      case_103: /* CIL Label */ 
#line 271
      SortByDate = 1;
#line 272
      SortByTime = 1;
#line 273
      SortByPrio = 1;
#line 274
      UntimedBeforeTimed = 0;
#line 275
      if (*arg) {
#line 276
        if ((int const   )*arg == 68) {
#line 277
          SortByDate = 2;
        } else
#line 276
        if ((int const   )*arg == 100) {
#line 277
          SortByDate = 2;
        }
#line 278
        arg ++;
      }
#line 280
      if (*arg) {
#line 281
        if ((int const   )*arg == 68) {
#line 282
          SortByTime = 2;
        } else
#line 281
        if ((int const   )*arg == 100) {
#line 282
          SortByTime = 2;
        }
#line 283
        arg ++;
      }
#line 285
      if (*arg) {
#line 286
        if ((int const   )*arg == 68) {
#line 287
          SortByPrio = 2;
        } else
#line 286
        if ((int const   )*arg == 100) {
#line 287
          SortByPrio = 2;
        }
#line 288
        arg ++;
      }
#line 290
      if (*arg) {
#line 291
        if ((int const   )*arg == 68) {
#line 292
          UntimedBeforeTimed = 1;
        } else
#line 291
        if ((int const   )*arg == 100) {
#line 292
          UntimedBeforeTimed = 1;
        }
#line 293
        arg ++;
      }
#line 295
      goto switch_break;
      case_85: /* CIL Label */ 
      case_117: /* CIL Label */ 
      {
#line 299
      ChgUser(arg);
#line 300
      RunDisabled = 1;
      }
      {
#line 301
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 301
        if (! *arg) {
#line 301
          goto while_break___4;
        }
#line 301
        arg ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 302
      goto switch_break;
      case_90: /* CIL Label */ 
      case_122: /* CIL Label */ 
#line 305
      DontFork = 1;
#line 306
      if ((int const   )*arg == 48) {
#line 307
        Daemon = 0;
        {
#line 307
        while (1) {
          while_continue___5: /* CIL Label */ ;
          {
#line 307
          tmp___8 = __ctype_b_loc();
          }
#line 307
          if (! ((int const   )*(*tmp___8 + (int )*arg) & 2048)) {
#line 307
            goto while_break___5;
          }
#line 307
          Daemon *= 10;
#line 307
          Daemon += (int )((int const   )*arg - 48);
#line 307
          arg ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 308
        if (Daemon == 0) {
#line 308
          Daemon = -1;
        } else
#line 309
        if (Daemon < 1) {
#line 309
          Daemon = 1;
        } else
#line 310
        if (Daemon > 60) {
#line 310
          Daemon = 60;
        }
      } else {
#line 312
        Daemon = 0;
        {
#line 312
        while (1) {
          while_continue___6: /* CIL Label */ ;
          {
#line 312
          tmp___9 = __ctype_b_loc();
          }
#line 312
          if (! ((int const   )*(*tmp___9 + (int )*arg) & 2048)) {
#line 312
            goto while_break___6;
          }
#line 312
          Daemon *= 10;
#line 312
          Daemon += (int )((int const   )*arg - 48);
#line 312
          arg ++;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 313
        if (Daemon < 1) {
#line 313
          Daemon = 1;
        } else
#line 314
        if (Daemon > 60) {
#line 314
          Daemon = 60;
        }
      }
#line 316
      goto switch_break;
      case_65: /* CIL Label */ 
      case_97: /* CIL Label */ 
#line 320
      DontIssueAts ++;
#line 321
      goto switch_break;
      case_81: /* CIL Label */ 
      case_113: /* CIL Label */ 
#line 325
      DontQueue = 1;
#line 326
      goto switch_break;
      case_70: /* CIL Label */ 
      case_102: /* CIL Label */ 
#line 330
      DontFork = 1;
#line 331
      goto switch_break;
      case_67: /* CIL Label */ 
      case_99: /* CIL Label */ 
#line 334
      DoCalendar = 1;
#line 335
      weeks = 0;
      {
#line 337
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 337
        if (! *arg) {
#line 337
          goto while_break___7;
        }
#line 338
        if ((int const   )*arg == 97) {
#line 340
          DoSimpleCalDelta = 1;
#line 341
          arg ++;
#line 342
          goto while_continue___7;
        } else
#line 338
        if ((int const   )*arg == 65) {
#line 340
          DoSimpleCalDelta = 1;
#line 341
          arg ++;
#line 342
          goto while_continue___7;
        }
#line 344
        if ((int const   )*arg == 43) {
#line 345
          weeks = 1;
#line 346
          arg ++;
#line 347
          goto while_continue___7;
        }
#line 349
        if ((int const   )*arg == 108) {
#line 350
          UseVTChars = 1;
#line 351
          arg ++;
#line 352
          goto while_continue___7;
        } else
#line 349
        if ((int const   )*arg == 76) {
#line 350
          UseVTChars = 1;
#line 351
          arg ++;
#line 352
          goto while_continue___7;
        }
#line 354
        if ((int const   )*arg == 117) {
#line 355
          UseUTF8Chars = 1;
#line 356
          arg ++;
#line 357
          goto while_continue___7;
        } else
#line 354
        if ((int const   )*arg == 85) {
#line 355
          UseUTF8Chars = 1;
#line 356
          arg ++;
#line 357
          goto while_continue___7;
        }
#line 359
        if ((int const   )*arg == 99) {
#line 360
          UseVTColors = 1;
#line 361
          arg ++;
#line 362
          goto while_continue___7;
        } else
#line 359
        if ((int const   )*arg == 67) {
#line 360
          UseVTColors = 1;
#line 361
          arg ++;
#line 362
          goto while_continue___7;
        }
#line 364
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 366
      if (weeks) {
#line 367
        CalWeeks = 0;
        {
#line 367
        while (1) {
          while_continue___8: /* CIL Label */ ;
          {
#line 367
          tmp___10 = __ctype_b_loc();
          }
#line 367
          if (! ((int const   )*(*tmp___10 + (int )*arg) & 2048)) {
#line 367
            goto while_break___8;
          }
#line 367
          CalWeeks *= 10;
#line 367
          CalWeeks += (int )((int const   )*arg - 48);
#line 367
          arg ++;
        }
        while_break___8: /* CIL Label */ ;
        }
#line 368
        if (! CalWeeks) {
#line 368
          CalWeeks = 1;
        }
      } else {
#line 370
        CalMonths = 0;
        {
#line 370
        while (1) {
          while_continue___9: /* CIL Label */ ;
          {
#line 370
          tmp___11 = __ctype_b_loc();
          }
#line 370
          if (! ((int const   )*(*tmp___11 + (int )*arg) & 2048)) {
#line 370
            goto while_break___9;
          }
#line 370
          CalMonths *= 10;
#line 370
          CalMonths += (int )((int const   )*arg - 48);
#line 370
          arg ++;
        }
        while_break___9: /* CIL Label */ ;
        }
#line 371
        if (! CalMonths) {
#line 371
          CalMonths = 1;
        }
      }
#line 373
      goto switch_break;
      case_83: /* CIL Label */ 
      case_115: /* CIL Label */ 
#line 377
      DoSimpleCalendar = 1;
#line 378
      weeks = 0;
      {
#line 379
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 379
        if (! *arg) {
#line 379
          goto while_break___10;
        }
#line 380
        if ((int const   )*arg == 97) {
#line 381
          DoSimpleCalDelta = 1;
#line 382
          arg ++;
#line 383
          goto while_continue___10;
        } else
#line 380
        if ((int const   )*arg == 65) {
#line 381
          DoSimpleCalDelta = 1;
#line 382
          arg ++;
#line 383
          goto while_continue___10;
        }
#line 385
        if ((int const   )*arg == 43) {
#line 386
          arg ++;
#line 387
          weeks = 1;
#line 388
          goto while_continue___10;
        }
#line 390
        goto while_break___10;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 392
      if (weeks) {
#line 393
        CalWeeks = 0;
        {
#line 393
        while (1) {
          while_continue___11: /* CIL Label */ ;
          {
#line 393
          tmp___12 = __ctype_b_loc();
          }
#line 393
          if (! ((int const   )*(*tmp___12 + (int )*arg) & 2048)) {
#line 393
            goto while_break___11;
          }
#line 393
          CalWeeks *= 10;
#line 393
          CalWeeks += (int )((int const   )*arg - 48);
#line 393
          arg ++;
        }
        while_break___11: /* CIL Label */ ;
        }
#line 394
        if (! CalWeeks) {
#line 394
          CalWeeks = 1;
        }
      } else {
#line 396
        CalMonths = 0;
        {
#line 396
        while (1) {
          while_continue___12: /* CIL Label */ ;
          {
#line 396
          tmp___13 = __ctype_b_loc();
          }
#line 396
          if (! ((int const   )*(*tmp___13 + (int )*arg) & 2048)) {
#line 396
            goto while_break___12;
          }
#line 396
          CalMonths *= 10;
#line 396
          CalMonths += (int )((int const   )*arg - 48);
#line 396
          arg ++;
        }
        while_break___12: /* CIL Label */ ;
        }
#line 397
        if (! CalMonths) {
#line 397
          CalMonths = 1;
        }
      }
#line 399
      goto switch_break;
      case_80: /* CIL Label */ 
      case_112: /* CIL Label */ 
#line 403
      DoSimpleCalendar = 1;
#line 404
      PsCal = 1;
#line 405
      if ((int const   )*arg == 97) {
#line 406
        DoSimpleCalDelta = 1;
#line 407
        arg ++;
      } else
#line 405
      if ((int const   )*arg == 65) {
#line 406
        DoSimpleCalDelta = 1;
#line 407
        arg ++;
      }
#line 409
      CalMonths = 0;
      {
#line 409
      while (1) {
        while_continue___13: /* CIL Label */ ;
        {
#line 409
        tmp___14 = __ctype_b_loc();
        }
#line 409
        if (! ((int const   )*(*tmp___14 + (int )*arg) & 2048)) {
#line 409
          goto while_break___13;
        }
#line 409
        CalMonths *= 10;
#line 409
        CalMonths += (int )((int const   )*arg - 48);
#line 409
        arg ++;
      }
      while_break___13: /* CIL Label */ ;
      }
#line 410
      if (! CalMonths) {
#line 410
        CalMonths = 1;
      }
#line 411
      goto switch_break;
      case_76: /* CIL Label */ 
      case_108: /* CIL Label */ 
#line 415
      DoPrefixLineNo = 1;
#line 416
      goto switch_break;
      case_87: /* CIL Label */ 
      case_119: /* CIL Label */ 
#line 420
      if ((int const   )*arg != 44) {
#line 421
        CalWidth = 0;
        {
#line 421
        while (1) {
          while_continue___14: /* CIL Label */ ;
          {
#line 421
          tmp___15 = __ctype_b_loc();
          }
#line 421
          if (! ((int const   )*(*tmp___15 + (int )*arg) & 2048)) {
#line 421
            goto while_break___14;
          }
#line 421
          CalWidth *= 10;
#line 421
          CalWidth += (int )((int const   )*arg - 48);
#line 421
          arg ++;
        }
        while_break___14: /* CIL Label */ ;
        }
#line 422
        if (CalWidth < 71) {
#line 422
          CalWidth = 71;
        }
      }
#line 424
      if ((int const   )*arg == 44) {
#line 425
        arg ++;
#line 426
        if ((int const   )*arg != 44) {
#line 427
          CalLines = 0;
          {
#line 427
          while (1) {
            while_continue___15: /* CIL Label */ ;
            {
#line 427
            tmp___16 = __ctype_b_loc();
            }
#line 427
            if (! ((int const   )*(*tmp___16 + (int )*arg) & 2048)) {
#line 427
              goto while_break___15;
            }
#line 427
            CalLines *= 10;
#line 427
            CalLines += (int )((int const   )*arg - 48);
#line 427
            arg ++;
          }
          while_break___15: /* CIL Label */ ;
          }
#line 428
          if (CalLines > 20) {
#line 428
            CalLines = 20;
          }
        }
#line 430
        if ((int const   )*arg == 44) {
#line 431
          arg ++;
#line 432
          CalPad = 0;
          {
#line 432
          while (1) {
            while_continue___16: /* CIL Label */ ;
            {
#line 432
            tmp___17 = __ctype_b_loc();
            }
#line 432
            if (! ((int const   )*(*tmp___17 + (int )*arg) & 2048)) {
#line 432
              goto while_break___16;
            }
#line 432
            CalPad *= 10;
#line 432
            CalPad += (int )((int const   )*arg - 48);
#line 432
            arg ++;
          }
          while_break___16: /* CIL Label */ ;
          }
#line 433
          if (CalPad > 20) {
#line 433
            CalPad = 20;
          }
        }
      }
#line 436
      goto switch_break;
      case_68: /* CIL Label */ 
      case_100: /* CIL Label */ 
      {
#line 440
      while (1) {
        while_continue___17: /* CIL Label */ ;
#line 440
        if (! *arg) {
#line 440
          goto while_break___17;
        }
#line 441
        tmp___18 = arg;
#line 441
        arg ++;
        {
#line 442
        if ((int const   )*tmp___18 == 69) {
#line 442
          goto case_69___0;
        }
#line 442
        if ((int const   )*tmp___18 == 101) {
#line 442
          goto case_69___0;
        }
#line 443
        if ((int const   )*tmp___18 == 88) {
#line 443
          goto case_88;
        }
#line 443
        if ((int const   )*tmp___18 == 120) {
#line 443
          goto case_88;
        }
#line 444
        if ((int const   )*tmp___18 == 84) {
#line 444
          goto case_84___0;
        }
#line 444
        if ((int const   )*tmp___18 == 116) {
#line 444
          goto case_84___0;
        }
#line 445
        if ((int const   )*tmp___18 == 86) {
#line 445
          goto case_86;
        }
#line 445
        if ((int const   )*tmp___18 == 118) {
#line 445
          goto case_86;
        }
#line 446
        if ((int const   )*tmp___18 == 76) {
#line 446
          goto case_76___0;
        }
#line 446
        if ((int const   )*tmp___18 == 108) {
#line 446
          goto case_76___0;
        }
#line 447
        if ((int const   )*tmp___18 == 70) {
#line 447
          goto case_70___0;
        }
#line 447
        if ((int const   )*tmp___18 == 102) {
#line 447
          goto case_70___0;
        }
#line 448
        goto switch_default;
        case_69___0: /* CIL Label */ 
        case_101___0: /* CIL Label */ 
#line 442
        DebugFlag |= 16;
#line 442
        goto switch_break___0;
        case_88: /* CIL Label */ 
        case_120: /* CIL Label */ 
#line 443
        DebugFlag |= 2;
#line 443
        goto switch_break___0;
        case_84___0: /* CIL Label */ 
        case_116___0: /* CIL Label */ 
#line 444
        DebugFlag |= 4;
#line 444
        goto switch_break___0;
        case_86: /* CIL Label */ 
        case_118: /* CIL Label */ 
#line 445
        DebugFlag |= 8;
#line 445
        goto switch_break___0;
        case_76___0: /* CIL Label */ 
        case_108___0: /* CIL Label */ 
#line 446
        DebugFlag |= 1;
#line 446
        goto switch_break___0;
        case_70___0: /* CIL Label */ 
        case_102___0: /* CIL Label */ 
#line 447
        DebugFlag |= 32;
#line 447
        goto switch_break___0;
        switch_default: /* CIL Label */ 
        {
#line 449
        fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)ErrMsg[84],
                (int const   )*(arg - 1));
        }
        switch_break___0: /* CIL Label */ ;
        }
      }
      while_break___17: /* CIL Label */ ;
      }
#line 452
      goto switch_break;
      case_86___0: /* CIL Label */ 
      case_118___0: /* CIL Label */ 
#line 456
      DebugFlag |= 1;
#line 457
      ShowAllErrors = 1;
#line 458
      goto switch_break;
      case_66: /* CIL Label */ 
      case_98: /* CIL Label */ 
#line 462
      ScFormat = 0;
      {
#line 462
      while (1) {
        while_continue___18: /* CIL Label */ ;
        {
#line 462
        tmp___19 = __ctype_b_loc();
        }
#line 462
        if (! ((int const   )*(*tmp___19 + (int )*arg) & 2048)) {
#line 462
          goto while_break___18;
        }
#line 462
        ScFormat *= 10;
#line 462
        ScFormat += (int )((int const   )*arg - 48);
#line 462
        arg ++;
      }
      while_break___18: /* CIL Label */ ;
      }
#line 463
      if (ScFormat < 0) {
#line 463
        ScFormat = 0;
      } else
#line 463
      if (ScFormat > 2) {
#line 463
        ScFormat = 0;
      }
#line 464
      goto switch_break;
      case_88___0: /* CIL Label */ 
      case_120___0: /* CIL Label */ 
#line 468
      MaxSatIter = 0;
      {
#line 468
      while (1) {
        while_continue___19: /* CIL Label */ ;
        {
#line 468
        tmp___20 = __ctype_b_loc();
        }
#line 468
        if (! ((int const   )*(*tmp___20 + (int )*arg) & 2048)) {
#line 468
          goto while_break___19;
        }
#line 468
        MaxSatIter *= 10;
#line 468
        MaxSatIter += (int )((int const   )*arg - 48);
#line 468
        arg ++;
      }
      while_break___19: /* CIL Label */ ;
      }
#line 469
      if (MaxSatIter < 10) {
#line 469
        MaxSatIter = 10;
      }
#line 470
      goto switch_break;
      case_75: /* CIL Label */ 
      case_107: /* CIL Label */ 
#line 474
      MsgCommand = arg;
      {
#line 475
      while (1) {
        while_continue___20: /* CIL Label */ ;
#line 475
        if (! *arg) {
#line 475
          goto while_break___20;
        }
#line 475
        arg ++;
      }
      while_break___20: /* CIL Label */ ;
      }
#line 476
      goto switch_break;
      switch_default___0: /* CIL Label */ 
      {
#line 479
      fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)ErrMsg[85],
              (int const   )*(arg - 1));
      }
      switch_break: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 486
  if (! InvokedAsRem) {
#line 487
    if (i >= argc) {
      {
#line 488
      Usage();
#line 489
      exit(1);
      }
    }
#line 491
    tmp___21 = i;
#line 491
    i ++;
#line 491
    InitialFile = *(argv + tmp___21);
  } else {
    {
#line 493
    InitialFile = DefaultFilename();
    }
  }
#line 497
  if (i < argc) {
    {
#line 498
    while (1) {
      while_continue___21: /* CIL Label */ ;
#line 498
      if (! (i < argc)) {
#line 498
        goto while_break___21;
      }
      {
#line 499
      tmp___22 = i;
#line 499
      i ++;
#line 499
      arg = *(argv + tmp___22);
#line 500
      FindToken(arg, & tok);
      }
      {
#line 502
      if ((unsigned int )tok.type == 19U) {
#line 502
        goto case_19;
      }
#line 511
      if ((unsigned int )tok.type == 21U) {
#line 511
        goto case_21;
      }
#line 520
      if ((unsigned int )tok.type == 20U) {
#line 520
        goto case_20;
      }
#line 525
      if ((unsigned int )tok.type == 18U) {
#line 525
        goto case_18;
      }
#line 530
      if ((unsigned int )tok.type == 27U) {
#line 530
        goto case_27;
      }
#line 535
      if ((unsigned int )tok.type == 26U) {
#line 535
        goto case_26;
      }
#line 540
      if ((unsigned int )tok.type == 28U) {
#line 540
        goto case_28;
      }
#line 545
      goto switch_default___1;
      case_19: /* CIL Label */ 
#line 503
      if (SysTime != -1L) {
        {
#line 503
        Usage();
        }
      } else {
#line 505
        SysTime = (long )tok.val * 60L;
#line 506
        DontQueue = 1;
#line 507
        Daemon = 0;
      }
#line 509
      goto switch_break___1;
      case_21: /* CIL Label */ 
#line 512
      if (SysTime != -1L) {
        {
#line 512
        Usage();
        }
      }
#line 513
      if (m != -1) {
        {
#line 513
        Usage();
        }
      } else
#line 513
      if (d != -1) {
        {
#line 513
        Usage();
        }
      } else
#line 513
      if (y != -1) {
        {
#line 513
        Usage();
        }
      } else
#line 513
      if (jul != -1) {
        {
#line 513
        Usage();
        }
      }
#line 514
      SysTime = (long )((tok.val % 1440) * 60);
#line 515
      DontQueue = 1;
#line 516
      Daemon = 0;
#line 517
      jul = tok.val / 1440;
#line 518
      goto switch_break___1;
      case_20: /* CIL Label */ 
#line 521
      if (m != -1) {
        {
#line 521
        Usage();
        }
      } else
#line 521
      if (d != -1) {
        {
#line 521
        Usage();
        }
      } else
#line 521
      if (y != -1) {
        {
#line 521
        Usage();
        }
      } else
#line 521
      if (jul != -1) {
        {
#line 521
        Usage();
        }
      }
#line 522
      jul = tok.val;
#line 523
      goto switch_break___1;
      case_18: /* CIL Label */ 
#line 526
      if (m != -1) {
        {
#line 526
        Usage();
        }
      } else
#line 526
      if (jul != -1) {
        {
#line 526
        Usage();
        }
      } else {
#line 527
        m = tok.val;
      }
#line 528
      goto switch_break___1;
      case_27: /* CIL Label */ 
#line 531
      if (d != -1) {
        {
#line 531
        Usage();
        }
      } else
#line 531
      if (jul != -1) {
        {
#line 531
        Usage();
        }
      } else {
#line 532
        d = tok.val;
      }
#line 533
      goto switch_break___1;
      case_26: /* CIL Label */ 
#line 536
      if (y != -1) {
        {
#line 536
        Usage();
        }
      } else
#line 536
      if (jul != -1) {
        {
#line 536
        Usage();
        }
      } else {
#line 537
        y = tok.val;
      }
#line 538
      goto switch_break___1;
      case_28: /* CIL Label */ 
#line 541
      if (rep != 0) {
        {
#line 541
        Usage();
        }
      } else {
#line 542
        rep = tok.val;
      }
#line 543
      goto switch_break___1;
      switch_default___1: /* CIL Label */ 
      {
#line 546
      Usage();
      }
      switch_break___1: /* CIL Label */ ;
      }
    }
    while_break___21: /* CIL Label */ ;
    }
#line 550
    if (rep > 0) {
#line 551
      Iterations = rep;
#line 552
      DontQueue = 1;
#line 553
      Daemon = 0;
    }
#line 556
    if (jul != -1) {
      {
#line 557
      FromJulian(jul, & y, & m, & d);
      }
    }
#line 560
    if (m != -1) {
#line 560
      goto _L___0;
    } else
#line 560
    if (y != -1) {
#line 560
      goto _L___0;
    } else
#line 560
    if (d != -1) {
      _L___0: /* CIL Label */ 
#line 561
      if (m == -1) {
#line 561
        goto _L;
      } else
#line 561
      if (y == -1) {
        _L: /* CIL Label */ 
#line 562
        if (rep == 0) {
          {
#line 562
          Usage();
          }
        } else
#line 563
        if (m != -1) {
          {
#line 563
          Usage();
          }
        } else
#line 563
        if (y != -1) {
          {
#line 563
          Usage();
          }
        } else {
#line 565
          m = CurMon;
#line 566
          y = CurYear;
#line 567
          if (d == -1) {
#line 567
            d = CurDay;
          }
        }
      }
#line 570
      if (d == -1) {
#line 570
        d = 1;
      }
#line 571
      if (m != 1) {
#line 571
        tmp___25 = MonthDays[m];
      } else {
#line 571
        if (y % 4) {
#line 571
          tmp___24 = 0;
        } else {
#line 571
          if (! (y % 100)) {
#line 571
            if (y % 400) {
#line 571
              tmp___23 = 0;
            } else {
#line 571
              tmp___23 = 1;
            }
          } else {
#line 571
            tmp___23 = 1;
          }
#line 571
          tmp___24 = tmp___23;
        }
#line 571
        tmp___25 = 28 + tmp___24;
      }
#line 571
      if (d > tmp___25) {
        {
#line 572
        fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"%s",
                BadDate);
#line 573
        Usage();
        }
      }
      {
#line 575
      JulianToday = Julian(y, m, d);
      }
#line 576
      if (JulianToday == -1) {
        {
#line 577
        fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"%s",
                BadDate);
#line 578
        Usage();
        }
      }
#line 580
      CurYear = y;
#line 581
      CurMon = m;
#line 582
      CurDay = d;
#line 583
      if (JulianToday != RealToday) {
#line 583
        IgnoreOnce = 1;
      }
    }
  }
#line 588
  if (CalculateUTC) {
    {
#line 589
    tmp___26 = SystemTime(1);
#line 589
    CalcMinsFromUTC(JulianToday, (int )(tmp___26 / 60L), & MinsFromUTC, (int *)((void *)0));
    }
  }
#line 591
  return;
}
}
#line 601 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/init.c"
void Usage(void) 
{ 


  {
  {
#line 603
  fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"\nREMIND %s (%s version) Copyright 1992-1998 David F. Skoll\n",
          "03.01.13", "English");
#line 604
  fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"Copyright 1999-2011 Roaring Penguin Software Inc.\n");
#line 608
  fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"Usage: remind [options] filename [date] [time] [*rep]\n");
#line 609
  fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"Options:\n");
#line 610
  fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)" -n     Output next occurrence of reminders in simple format\n");
#line 611
  fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)" -r     Disable RUN directives\n");
#line 612
  fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)" -c[a][n] Produce a calendar for n (default 1) months\n");
#line 613
  fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)" -c[a]+[n] Produce a calendar for n (default 1) weeks\n");
#line 614
  fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)" -w[n[,p[,s]]]  Specify width, padding and spacing of calendar\n");
#line 615
  fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)" -s[a][+][n] Produce `simple calendar\' for n (1) months (weeks)\n");
#line 616
  fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)" -p[a][n] Same as -s, but input compatible with rem2ps\n");
#line 617
  fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)" -l     Prefix each simple calendar line with line number and filename comment\n");
#line 618
  fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)" -v     Verbose mode\n");
#line 619
  fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)" -o     Ignore ONCE directives\n");
#line 620
  fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)" -t[n]  Trigger all future (or those within `n\' days)\n");
#line 621
  fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)" -h     `Hush\' mode - be very quiet\n");
#line 622
  fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)" -a     Don\'t trigger timed reminders immediately - just queue them\n");
#line 623
  fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)" -q     Don\'t queue timed reminders\n");
#line 624
  fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)" -f     Trigger timed reminders by staying in foreground\n");
#line 625
  fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)" -z[n]  Enter daemon mode, waking every n (1) minutes.\n");
#line 626
  fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)" -d...  Debug: e=echo x=expr-eval t=trig v=dumpvars l=showline f=tracefiles\n");
#line 627
  fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)" -e     Divert messages normally sent to stderr to stdout\n");
#line 628
  fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)" -b[n]  Time format for cal: 0=am/pm, 1=24hr, 2=none\n");
#line 629
  fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)" -x[n]  Iteration limit for SATISFY clause (def=150)\n");
#line 630
  fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)" -kcmd  Run `cmd\' for MSG-type reminders\n");
#line 631
  fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)" -g[dddd] Sort reminders by date, time, priority, and \'timedness\'\n");
#line 632
  fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)" -ivar=val Initialize var to val and preserve var\n");
#line 633
  fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)" -m     Start calendar with Monday rather than Sunday\n");
#line 634
  fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)" -y     Synthesize tags for tagless reminders\n");
#line 635
  fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)" -j[n]  Run in \'purge\' mode.  [n = INCLUDE depth]\n");
#line 636
  exit(1);
  }
}
}
#line 654 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/init.c"
static char *home  ;
#line 655 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/init.c"
static char *shell  ;
#line 656 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/init.c"
static char *username  ;
#line 657 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/init.c"
static char *logname  ;
#line 649 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/init.c"
static void ChgUser(char const   *user ) 
{ 
  uid_t myuid ;
  struct passwd *pwent ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  size_t tmp___7 ;
  void *tmp___8 ;

  {
  {
#line 659
  myuid = getuid();
#line 661
  pwent = getpwnam(user);
  }
#line 663
  if (! pwent) {
    {
#line 664
    fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)ErrMsg[86],
            user);
#line 665
    exit(1);
    }
  }
#line 668
  if (! myuid) {
    {
#line 668
    tmp = setgid(pwent->pw_gid);
    }
#line 668
    if (tmp) {
      {
#line 669
      fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)ErrMsg[87],
              pwent->pw_gid);
#line 670
      exit(1);
      }
    }
  }
#line 673
  if (! myuid) {
    {
#line 673
    tmp___0 = setuid(pwent->pw_uid);
    }
#line 673
    if (tmp___0) {
      {
#line 674
      fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)ErrMsg[88],
              pwent->pw_uid);
#line 675
      exit(1);
      }
    }
  }
  {
#line 678
  tmp___1 = strlen((char const   *)pwent->pw_dir);
#line 678
  tmp___2 = malloc(tmp___1 + 6UL);
#line 678
  home = (char *)tmp___2;
  }
#line 679
  if (! home) {
    {
#line 680
    fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"%s",
            ErrMsg[89]);
#line 681
    exit(1);
    }
  }
  {
#line 683
  sprintf((char */* __restrict  */)home, (char const   */* __restrict  */)"HOME=%s",
          pwent->pw_dir);
#line 684
  putenv(home);
#line 686
  tmp___3 = strlen((char const   *)pwent->pw_shell);
#line 686
  tmp___4 = malloc(tmp___3 + 7UL);
#line 686
  shell = (char *)tmp___4;
  }
#line 687
  if (! shell) {
    {
#line 688
    fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"%s",
            ErrMsg[89]);
#line 689
    exit(1);
    }
  }
  {
#line 691
  sprintf((char */* __restrict  */)shell, (char const   */* __restrict  */)"SHELL=%s",
          pwent->pw_shell);
#line 692
  putenv(shell);
  }
#line 694
  if (pwent->pw_uid) {
    {
#line 695
    tmp___5 = strlen((char const   *)pwent->pw_name);
#line 695
    tmp___6 = malloc(tmp___5 + 6UL);
#line 695
    username = (char *)tmp___6;
    }
#line 696
    if (! username) {
      {
#line 697
      fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"%s",
              ErrMsg[89]);
#line 698
      exit(1);
      }
    }
    {
#line 700
    sprintf((char */* __restrict  */)username, (char const   */* __restrict  */)"USER=%s",
            pwent->pw_name);
#line 701
    putenv(username);
#line 702
    tmp___7 = strlen((char const   *)pwent->pw_name);
#line 702
    tmp___8 = malloc(tmp___7 + 9UL);
#line 702
    logname = (char *)tmp___8;
    }
#line 703
    if (! logname) {
      {
#line 704
      fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"%s",
              ErrMsg[89]);
#line 705
      exit(1);
      }
    }
    {
#line 707
    sprintf((char */* __restrict  */)logname, (char const   */* __restrict  */)"LOGNAME=%s",
            pwent->pw_name);
#line 708
    putenv(logname);
    }
  }
#line 710
  return;
}
}
#line 712 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/init.c"
static void DefineFunction(char const   *str ) 
{ 
  Parser p ;
  int r ;

  {
  {
#line 718
  CreateParser(str, & p);
#line 719
  r = DoFset(& p);
#line 720
  DestroyParser(& p);
  }
#line 721
  if (r != 0) {
    {
#line 722
    fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"-i option: %s: %s\n",
            str, ErrMsg[r]);
    }
  }
#line 724
  return;
}
}
#line 732 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/init.c"
static void InitializeVar(char const   *str ) 
{ 
  char const   *expr ;
  char const   *ostr ;
  char varname[17] ;
  Value val ;
  int r ;
  int tmp ;

  {
#line 735
  ostr = str;
#line 743
  r = 0;
  {
#line 744
  while (1) {
    while_continue: /* CIL Label */ ;
#line 744
    if (*str) {
#line 744
      if (! ((int const   )*str != 61)) {
#line 744
        goto while_break;
      }
    } else {
#line 744
      goto while_break;
    }
#line 745
    if (r < 16) {
#line 746
      tmp = r;
#line 746
      r ++;
#line 746
      varname[tmp] = (char )*str;
    }
#line 748
    if ((int const   )*str == 40) {
      {
#line 750
      DefineFunction(ostr);
      }
#line 751
      return;
    }
#line 753
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 755
  varname[r] = (char)0;
#line 756
  if (! *str) {
    {
#line 757
    fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)ErrMsg[94],
            ErrMsg[90]);
    }
#line 758
    return;
  }
#line 760
  if (! varname[0]) {
    {
#line 761
    fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)ErrMsg[94],
            ErrMsg[91]);
    }
#line 762
    return;
  }
#line 764
  expr = str + 1;
#line 765
  if (! *expr) {
    {
#line 766
    fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)ErrMsg[94],
            ErrMsg[92]);
    }
#line 767
    return;
  }
  {
#line 770
  r = EvalExpr(& expr, & val, (ParsePtr )((void *)0));
  }
#line 771
  if (r) {
    {
#line 772
    fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)ErrMsg[94],
            ErrMsg[r]);
    }
#line 773
    return;
  }
#line 776
  if ((int )varname[0] == 36) {
    {
#line 777
    r = SetSysVar((char const   *)(varname + 1), & val);
    }
#line 778
    if (r) {
      {
#line 778
      fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)ErrMsg[94],
              ErrMsg[r]);
      }
    }
#line 779
    return;
  }
  {
#line 782
  r = SetVar((char const   *)(varname), & val);
  }
#line 783
  if (r) {
    {
#line 784
    fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)ErrMsg[94],
            ErrMsg[r]);
    }
#line 785
    return;
  }
  {
#line 787
  r = PreserveVar((char const   *)(varname));
  }
#line 788
  if (r) {
    {
#line 788
    fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)ErrMsg[94],
            ErrMsg[r]);
    }
  }
#line 789
  return;
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/protos.h"
int StrMatch(char const   *s1 , char const   *s2 , int n ) ;
#line 110
int DateOK(int y , int m , int d ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/utils.c"
char *StrnCpy(char *dest , char const   *source , int n ) 
{ 
  char *odest ;
  int tmp ;
  char *tmp___0 ;
  char tmp___1 ;
  char const   *tmp___2 ;

  {
#line 35
  odest = dest;
  {
#line 37
  while (1) {
    while_continue: /* CIL Label */ ;
#line 37
    tmp = n;
#line 37
    n --;
#line 37
    if (tmp) {
#line 37
      tmp___0 = dest;
#line 37
      dest ++;
#line 37
      tmp___2 = source;
#line 37
      source ++;
#line 37
      tmp___1 = (char )*tmp___2;
#line 37
      *tmp___0 = tmp___1;
#line 37
      if (! tmp___1) {
#line 37
        goto while_break;
      }
    } else {
#line 37
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 38
  if (*(dest - 1)) {
#line 38
    *dest = (char)0;
  }
#line 39
  return (odest);
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/utils.c"
int StrMatch(char const   *s1 , char const   *s2 , int n ) 
{ 
  int l ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 54
  tmp = strlen(s1);
#line 54
  l = (int )tmp;
  }
#line 54
  if (l < n) {
#line 54
    return (0);
  }
  {
#line 55
  tmp___0 = StrinCmp(s1, s2, l);
  }
#line 55
  if (tmp___0) {
#line 55
    tmp___1 = 0;
  } else {
#line 55
    tmp___1 = 1;
  }
#line 55
  return (tmp___1);
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/utils.c"
int StrinCmp(char const   *s1 , char const   *s2 , int n ) 
{ 
  register int r ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 66
    if (n) {
#line 66
      if (*s1) {
#line 66
        if (! *s2) {
#line 66
          goto while_break;
        }
      } else {
#line 66
        goto while_break;
      }
    } else {
#line 66
      goto while_break;
    }
    {
#line 67
    n --;
#line 68
    tmp = toupper((int )*s1);
#line 68
    tmp___0 = toupper((int )*s2);
#line 68
    r = tmp - tmp___0;
    }
#line 69
    if (r) {
#line 69
      return (r);
    }
#line 70
    s1 ++;
#line 71
    s2 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 73
  if (n) {
    {
#line 73
    tmp___1 = toupper((int )*s1);
#line 73
    tmp___2 = toupper((int )*s2);
    }
#line 73
    return (tmp___1 - tmp___2);
  } else {
#line 73
    return (0);
  }
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/utils.c"
char *StrDup(char const   *s ) 
{ 
  char *ret ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 85
  tmp = strlen(s);
#line 85
  tmp___0 = malloc(tmp + 1UL);
#line 85
  ret = (char *)tmp___0;
  }
#line 86
  if (! ret) {
#line 86
    return ((char *)((void *)0));
  }
  {
#line 87
  strcpy((char */* __restrict  */)ret, (char const   */* __restrict  */)s);
  }
#line 88
  return (ret);
}
}
#line 98 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/utils.c"
int StrCmpi(char const   *s1 , char const   *s2 ) 
{ 
  int r ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    if (*s1) {
#line 101
      if (! *s2) {
#line 101
        goto while_break;
      }
    } else {
#line 101
      goto while_break;
    }
    {
#line 102
    tmp = toupper((int )*s1);
#line 102
    tmp___0 = toupper((int )*s2);
#line 102
    r = tmp - tmp___0;
    }
#line 103
    if (r) {
#line 103
      return (r);
    }
#line 104
    s1 ++;
#line 105
    s2 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 107
  tmp___1 = toupper((int )*s1);
#line 107
  tmp___2 = toupper((int )*s2);
  }
#line 107
  return (tmp___1 - tmp___2);
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/utils.c"
int DateOK(int y , int m , int d ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 119
  if (d < 1) {
#line 124
    return (0);
  } else
#line 119
  if (m < 0) {
#line 124
    return (0);
  } else
#line 119
  if (y < 1990) {
#line 124
    return (0);
  } else
#line 119
  if (m > 11) {
#line 124
    return (0);
  } else
#line 119
  if (y > 5990) {
#line 124
    return (0);
  } else {
#line 119
    if (m != 1) {
#line 119
      tmp___1 = MonthDays[m];
    } else {
#line 119
      if (y % 4) {
#line 119
        tmp___0 = 0;
      } else {
#line 119
        if (! (y % 100)) {
#line 119
          if (y % 400) {
#line 119
            tmp = 0;
          } else {
#line 119
            tmp = 1;
          }
        } else {
#line 119
          tmp = 1;
        }
#line 119
        tmp___0 = tmp;
      }
#line 119
      tmp___1 = 28 + tmp___0;
    }
#line 119
    if (d > tmp___1) {
#line 124
      return (0);
    } else {
#line 125
      return (1);
    }
  }
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 756 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 371 "/usr/include/stdio.h"
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 124 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 195
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) difftime)(time_t __time1 ,
                                                                                  time_t __time0 )  __attribute__((__const__)) ;
#line 199
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) mktime)(struct tm *__tp ) ;
#line 239
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) gmtime)(time_t const   *__timer ) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/protos.h"
int DoRem(ParsePtr p ) ;
#line 64
int PushToken(char const   *tok , ParsePtr p ) ;
#line 73
int DoDebug(ParsePtr p ) ;
#line 74
int DoBanner(ParsePtr p ) ;
#line 139
void PurgeEchoLine(char const   *fmt  , ...) ;
#line 46 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/main.c"
static void DoReminders(void) ;
#line 59 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/main.c"
int main(int argc , char **argv ) 
{ 
  int pid ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 64
  setlocale(6, "");
#line 68
  ErrFp = stderr;
#line 71
  ArgC = argc;
#line 72
  ArgV = (char const   **)argv;
#line 74
  InitRemind(argc, (char const   **)argv);
  }
#line 75
  if (DoCalendar) {
    {
#line 76
    ProduceCalendar();
    }
#line 77
    return (0);
  } else
#line 75
  if (DoSimpleCalendar) {
#line 75
    if (! NextMode) {
      {
#line 76
      ProduceCalendar();
      }
#line 77
      return (0);
    } else
#line 75
    if (PsCal) {
      {
#line 76
      ProduceCalendar();
      }
#line 77
      return (0);
    }
  }
#line 81
  if (PurgeMode) {
    {
#line 82
    DoReminders();
    }
#line 83
    return (0);
  }
#line 87
  ShouldCache = Iterations > 1;
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    tmp___0 = Iterations;
#line 89
    Iterations --;
#line 89
    if (! tmp___0) {
#line 89
      goto while_break;
    }
    {
#line 90
    DoReminders();
    }
#line 92
    if (DebugFlag & 8) {
      {
#line 93
      DumpVarTable();
#line 94
      DumpSysVarByName((char const   *)((void *)0));
      }
    }
#line 97
    if (! Hush) {
      {
#line 98
      tmp = DestroyOmitContexts();
      }
#line 98
      if (tmp) {
        {
#line 99
        Eprint("%s", ErrMsg[57]);
        }
      }
#line 100
      if (! Daemon) {
#line 100
        if (! NextMode) {
#line 100
          if (! NumTriggered) {
#line 100
            if (! NumQueued) {
              {
#line 101
              printf((char const   */* __restrict  */)"%s\n", ErrMsg[95]);
              }
            } else {
#line 100
              goto _L___1;
            }
          } else {
#line 100
            goto _L___1;
          }
        } else {
#line 100
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 102
      if (! Daemon) {
#line 102
        if (! NextMode) {
#line 102
          if (! NumTriggered) {
            {
#line 103
            printf((char const   */* __restrict  */)ErrMsg[96], NumQueued);
            }
          }
        }
      }
    }
#line 108
    if (SortByDate) {
      {
#line 108
      IssueSortedReminders();
      }
    }
#line 111
    if (NumQueued) {
#line 111
      goto _L___2;
    } else
#line 111
    if (Daemon) {
      _L___2: /* CIL Label */ 
#line 113
      if (DontFork) {
        {
#line 114
        HandleQueuedReminders();
        }
#line 115
        return (0);
      } else {
        {
#line 117
        pid = fork();
        }
#line 118
        if (pid == 0) {
          {
#line 119
          HandleQueuedReminders();
          }
#line 120
          return (0);
        }
#line 122
        if (pid == -1) {
          {
#line 123
          fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"%s",
                  ErrMsg[81]);
          }
#line 124
          return (1);
        }
      }
    }
#line 128
    if (Iterations) {
      {
#line 129
      ClearGlobalOmits();
#line 130
      DestroyOmitContexts();
#line 131
      DestroyVars(0);
#line 132
      NumTriggered = 0;
#line 133
      JulianToday ++;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 136
  return (0);
}
}
#line 139 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/main.c"
void PurgeEchoLine(char const   *fmt  , ...) 
{ 
  va_list argptr ;

  {
  {
#line 142
  __builtin_va_start(argptr, fmt);
  }
#line 143
  if ((unsigned long )PurgeFP != (unsigned long )((void *)0)) {
    {
#line 144
    vfprintf((FILE */* __restrict  */)PurgeFP, (char const   */* __restrict  */)fmt,
             argptr);
    }
  }
  {
#line 146
  __builtin_va_end(argptr);
  }
#line 148
  return;
}
}
#line 157 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/main.c"
static void DoReminders(void) 
{ 
  int r ;
  Token tok ;
  char const   *s ;
  Parser p ;
  int purge_handled ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 165
  if (! UseStdin) {
    {
#line 166
    FileAccessDate = GetAccessDate(InitialFile);
    }
  } else {
#line 168
    FileAccessDate = JulianToday;
  }
#line 171
  if (FileAccessDate < 0) {
    {
#line 172
    fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"%s: `%s\'.\n",
            ErrMsg[82], InitialFile);
#line 173
    exit(1);
    }
  }
  {
#line 176
  r = IncludeFile(InitialFile);
  }
#line 177
  if (r) {
    {
#line 178
    fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"%s %s: %s\n",
            ErrMsg[58], InitialFile, ErrMsg[r]);
#line 180
    exit(1);
    }
  }
  {
#line 183
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 184
    r = ReadLine();
    }
#line 185
    if (r == 20) {
#line 185
      return;
    }
#line 186
    if (r) {
      {
#line 187
      Eprint("%s: %s", ErrMsg[58], ErrMsg[r]);
#line 188
      exit(1);
      }
    }
    {
#line 190
    s = FindInitialToken(& tok, CurLine);
    }
#line 193
    if (NumIfs) {
#line 193
      if ((unsigned int )tok.type != 6U) {
#line 193
        if ((unsigned int )tok.type != 7U) {
#line 193
          if ((unsigned int )tok.type != 8U) {
#line 193
            if ((unsigned int )tok.type != 9U) {
              {
#line 193
              tmp___1 = ShouldIgnoreLine();
              }
#line 193
              if (tmp___1) {
#line 201
                if (PurgeMode) {
                  {
#line 202
                  tmp = strncmp(CurLine, "#!P", (size_t )3);
                  }
#line 202
                  if (tmp) {
                    {
#line 203
                    PurgeEchoLine("%s\n", CurLine);
                    }
                  }
                }
              } else {
#line 193
                goto _L___3;
              }
            } else {
#line 193
              goto _L___3;
            }
          } else {
#line 193
            goto _L___3;
          }
        } else {
#line 193
          goto _L___3;
        }
      } else {
#line 193
        goto _L___3;
      }
    } else {
      _L___3: /* CIL Label */ 
      {
#line 208
      purge_handled = 0;
#line 210
      CreateParser(s, & p);
      }
      {
#line 214
      if ((unsigned int )tok.type == 33U) {
#line 214
        goto case_33;
      }
#line 214
      if ((unsigned int )tok.type == 32U) {
#line 214
        goto case_33;
      }
#line 220
      if ((unsigned int )tok.type == 1U) {
#line 220
        goto case_1;
      }
#line 221
      if ((unsigned int )tok.type == 10U) {
#line 221
        goto case_10;
      }
#line 222
      if ((unsigned int )tok.type == 6U) {
#line 222
        goto case_6;
      }
#line 223
      if ((unsigned int )tok.type == 9U) {
#line 223
        goto case_9;
      }
#line 224
      if ((unsigned int )tok.type == 7U) {
#line 224
        goto case_7;
      }
#line 225
      if ((unsigned int )tok.type == 8U) {
#line 225
        goto case_8;
      }
#line 226
      if ((unsigned int )tok.type == 5U) {
#line 226
        goto case_5;
      }
#line 235
      if ((unsigned int )tok.type == 16U) {
#line 235
        goto case_16;
      }
#line 236
      if ((unsigned int )tok.type == 39U) {
#line 236
        goto case_39;
      }
#line 237
      if ((unsigned int )tok.type == 11U) {
#line 237
        goto case_11;
      }
#line 238
      if ((unsigned int )tok.type == 13U) {
#line 238
        goto case_13;
      }
#line 239
      if ((unsigned int )tok.type == 12U) {
#line 239
        goto case_12;
      }
#line 240
      if ((unsigned int )tok.type == 35U) {
#line 240
        goto case_35;
      }
#line 241
      if ((unsigned int )tok.type == 36U) {
#line 241
        goto case_36;
      }
#line 242
      if ((unsigned int )tok.type == 37U) {
#line 242
        goto case_37;
      }
#line 243
      if ((unsigned int )tok.type == 15U) {
#line 243
        goto case_15;
      }
#line 244
      if ((unsigned int )tok.type == 14U) {
#line 244
        goto case_14;
      }
#line 252
      if ((unsigned int )tok.type == 3U) {
#line 252
        goto case_3;
      }
#line 253
      if ((unsigned int )tok.type == 4U) {
#line 253
        goto case_4;
      }
#line 254
      if ((unsigned int )tok.type == 2U) {
#line 254
        goto case_2;
      }
#line 255
      if ((unsigned int )tok.type == 24U) {
#line 255
        goto case_24;
      }
#line 269
      goto switch_default;
      case_33: /* CIL Label */ 
      case_32: /* CIL Label */ 
      {
#line 215
      tmp___0 = strncmp(CurLine, "#!P", (size_t )3);
      }
#line 215
      if (! tmp___0) {
#line 216
        purge_handled = 1;
      }
#line 218
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 220
      r = DoRem(& p);
#line 220
      purge_handled = 1;
      }
#line 220
      goto switch_break;
      case_10: /* CIL Label */ 
      {
#line 221
      r = DoErrMsg(& p);
      }
#line 221
      goto switch_break;
      case_6: /* CIL Label */ 
      {
#line 222
      r = DoIf(& p);
      }
#line 222
      goto switch_break;
      case_9: /* CIL Label */ 
      {
#line 223
      r = DoIfTrig(& p);
      }
#line 223
      goto switch_break;
      case_7: /* CIL Label */ 
      {
#line 224
      r = DoElse(& p);
      }
#line 224
      goto switch_break;
      case_8: /* CIL Label */ 
      {
#line 225
      r = DoEndif(& p);
      }
#line 225
      goto switch_break;
      case_5: /* CIL Label */ 
#line 229
      if (PurgeMode) {
        {
#line 230
        PurgeEchoLine("%s\n", CurLine);
        }
      }
      {
#line 232
      r = DoInclude(& p);
#line 233
      purge_handled = 1;
      }
#line 234
      goto switch_break;
      case_16: /* CIL Label */ 
      {
#line 235
      DoExit(& p);
      }
#line 235
      goto switch_break;
      case_39: /* CIL Label */ 
      {
#line 236
      r = DoFlush(& p);
      }
#line 236
      goto switch_break;
      case_11: /* CIL Label */ 
      {
#line 237
      r = DoSet(& p);
      }
#line 237
      goto switch_break;
      case_13: /* CIL Label */ 
      {
#line 238
      r = DoFset(& p);
      }
#line 238
      goto switch_break;
      case_12: /* CIL Label */ 
      {
#line 239
      r = DoUnset(& p);
      }
#line 239
      goto switch_break;
      case_35: /* CIL Label */ 
      {
#line 240
      r = DoClear(& p);
      }
#line 240
      goto switch_break;
      case_36: /* CIL Label */ 
      {
#line 241
      r = DoDebug(& p);
      }
#line 241
      goto switch_break;
      case_37: /* CIL Label */ 
      {
#line 242
      r = DoDump(& p);
      }
#line 242
      goto switch_break;
      case_15: /* CIL Label */ 
      {
#line 243
      r = DoBanner(& p);
      }
#line 243
      goto switch_break;
      case_14: /* CIL Label */ 
      {
#line 244
      r = DoOmit(& p);
      }
#line 245
      if (r == 44) {
        {
#line 246
        DestroyParser(& p);
#line 247
        CreateParser(s, & p);
#line 248
        r = DoRem(& p);
#line 249
        purge_handled = 1;
        }
      }
#line 251
      goto switch_break;
      case_3: /* CIL Label */ 
      {
#line 252
      r = PopOmitContext(& p);
      }
#line 252
      goto switch_break;
      case_4: /* CIL Label */ 
      {
#line 253
      r = DoPreserve(& p);
      }
#line 253
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 254
      r = PushOmitContext(& p);
      }
#line 254
      goto switch_break;
      case_24: /* CIL Label */ 
#line 255
      if (tok.val == 2) {
        {
#line 256
        r = DoRun(& p);
        }
      } else {
        {
#line 258
        CreateParser(CurLine, & p);
#line 259
        r = DoRem(& p);
#line 260
        purge_handled = 1;
        }
      }
#line 262
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 269
      CreateParser(CurLine, & p);
#line 269
      purge_handled = 1;
#line 269
      r = DoRem(& p);
      }
#line 269
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 272
      if (r) {
#line 272
        if (! Hush) {
          {
#line 273
          Eprint("%s", ErrMsg[r]);
          }
        } else
#line 272
        if (r != 40) {
          {
#line 273
          Eprint("%s", ErrMsg[r]);
          }
        }
      }
#line 275
      if (PurgeMode) {
#line 276
        if (! purge_handled) {
          {
#line 277
          PurgeEchoLine("%s\n", CurLine);
          }
        } else
#line 279
        if (r) {
          {
#line 280
          PurgeEchoLine("#!P! Could not parse next line: %s\n", ErrMsg[r]);
#line 281
          PurgeEchoLine("%s\n", CurLine);
          }
        }
      }
      {
#line 286
      DestroyParser(& p);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 299 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/main.c"
int Julian(int year , int month , int day ) 
{ 
  int y1 ;
  int y2 ;
  int y4 ;
  int y100 ;
  int y400 ;
  int tmp ;
  int tmp___0 ;

  {
#line 301
  y1 = 1989;
#line 301
  y2 = year - 1;
#line 303
  y4 = y2 / 4 - y1 / 4;
#line 304
  y100 = y2 / 100 - y1 / 100;
#line 305
  y400 = y2 / 400 - y1 / 400;
#line 307
  if (year % 4) {
#line 307
    tmp___0 = 0;
  } else {
#line 307
    if (! (year % 100)) {
#line 307
      if (year % 400) {
#line 307
        tmp = 0;
      } else {
#line 307
        tmp = 1;
      }
    } else {
#line 307
      tmp = 1;
    }
#line 307
    tmp___0 = tmp;
  }
#line 307
  return ((((((365 * (year - 1990) + y4) - y100) + y400) + MonthIndex[tmp___0][month]) + day) - 1);
}
}
#line 318 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/main.c"
void FromJulian(int jul , int *y , int *m , int *d ) 
{ 
  int try_yr ;
  int try_mon ;
  int t ;
  int y1 ;
  int y2 ;
  int y4 ;
  int y100 ;
  int y400 ;
  int try_jul ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 320
  try_yr = jul / 365 + 1990;
#line 321
  try_mon = 0;
#line 325
  y1 = 1989;
#line 325
  y2 = try_yr - 1;
#line 326
  y4 = y2 / 4 - y1 / 4;
#line 327
  y100 = y2 / 100 - y1 / 100;
#line 328
  y400 = y2 / 400 - y1 / 400;
#line 330
  try_jul = ((365 * (try_yr - 1990) + y4) - y100) + y400;
  {
#line 332
  while (1) {
    while_continue: /* CIL Label */ ;
#line 332
    if (! (try_jul > jul)) {
#line 332
      goto while_break;
    }
#line 333
    try_yr --;
#line 334
    if (try_yr % 4) {
#line 334
      tmp___0 = 365;
    } else {
#line 334
      if (! (try_yr % 100)) {
#line 334
        if (try_yr % 400) {
#line 334
          tmp = 365;
        } else {
#line 334
          tmp = 366;
        }
      } else {
#line 334
        tmp = 366;
      }
#line 334
      tmp___0 = tmp;
    }
#line 334
    try_jul -= tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 336
  jul -= try_jul;
#line 338
  if (try_mon != 1) {
#line 338
    t = MonthDays[try_mon];
  } else {
#line 338
    if (try_yr % 4) {
#line 338
      tmp___2 = 0;
    } else {
#line 338
      if (! (try_yr % 100)) {
#line 338
        if (try_yr % 400) {
#line 338
          tmp___1 = 0;
        } else {
#line 338
          tmp___1 = 1;
        }
      } else {
#line 338
        tmp___1 = 1;
      }
#line 338
      tmp___2 = tmp___1;
    }
#line 338
    t = 28 + tmp___2;
  }
  {
#line 339
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 339
    if (! (jul >= t)) {
#line 339
      goto while_break___0;
    }
#line 340
    jul -= t;
#line 341
    try_mon ++;
#line 342
    if (try_mon != 1) {
#line 342
      t = MonthDays[try_mon];
    } else {
#line 342
      if (try_yr % 4) {
#line 342
        tmp___4 = 0;
      } else {
#line 342
        if (! (try_yr % 100)) {
#line 342
          if (try_yr % 400) {
#line 342
            tmp___3 = 0;
          } else {
#line 342
            tmp___3 = 1;
          }
        } else {
#line 342
          tmp___3 = 1;
        }
#line 342
        tmp___4 = tmp___3;
      }
#line 342
      t = 28 + tmp___4;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 344
  *y = try_yr;
#line 345
  *m = try_mon;
#line 346
  *d = jul + 1;
#line 347
  return;
}
}
#line 358 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/main.c"
int ParseChar(ParsePtr p , int *err , int peek ) 
{ 
  Value val ;
  int r ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 363
  *err = 0;
#line 364
  if (p->tokenPushed) {
#line 364
    if (*(p->tokenPushed)) {
#line 365
      if (peek) {
#line 365
        return ((int )*(p->tokenPushed));
      } else {
#line 367
        tmp = p->tokenPushed;
#line 367
        (p->tokenPushed) ++;
#line 367
        r = (int )*tmp;
#line 368
        if (! r) {
          {
#line 369
          DBufFree(& p->pushedToken);
#line 370
          p->tokenPushed = (char const   *)((void *)0);
          }
        }
#line 372
        return (r);
      }
    }
  }
  {
#line 376
  while (1) {
    while_continue: /* CIL Label */ ;
#line 377
    if (p->isnested) {
#line 378
      if (*(p->epos)) {
#line 379
        if (peek) {
#line 380
          return ((int )*(p->epos));
        } else {
#line 382
          tmp___0 = p->epos;
#line 382
          (p->epos) ++;
#line 382
          return ((int )*tmp___0);
        }
      }
      {
#line 385
      free((void *)p->etext);
#line 386
      p->etext = (char const   *)((void *)0);
#line 387
      p->epos = (char const   *)((void *)0);
#line 388
      p->isnested = (char)0;
      }
    }
#line 390
    if (! *(p->pos)) {
#line 391
      return (0);
    }
#line 393
    if ((int const   )*(p->pos) != 91) {
#line 393
      goto _L;
    } else
#line 393
    if (! p->allownested) {
      _L: /* CIL Label */ 
#line 394
      if (peek) {
#line 395
        return ((int )*(p->pos));
      } else {
#line 397
        tmp___1 = p->pos;
#line 397
        (p->pos) ++;
#line 397
        return ((int )*tmp___1);
      }
    }
    {
#line 400
    p->expr_happened = (char)1;
#line 401
    (p->pos) ++;
#line 402
    r = EvalExpr(& p->pos, & val, p);
    }
#line 403
    if (r) {
      {
#line 404
      *err = r;
#line 405
      DestroyParser(p);
      }
#line 406
      return (0);
    }
#line 408
    if ((int const   )*(p->pos) != 93) {
      {
#line 409
      *err = 1;
#line 410
      DestroyParser(p);
      }
#line 411
      if ((int )val.type == 4) {
#line 411
        if (val.v.str) {
          {
#line 411
          free((void *)val.v.str);
#line 411
          val.type = (char)0;
          }
        }
      }
#line 412
      return (0);
    }
    {
#line 414
    (p->pos) ++;
#line 415
    r = DoCoerce((char)4, & val);
    }
#line 416
    if (r) {
#line 416
      *err = r;
#line 416
      return (0);
    }
#line 417
    p->etext = (char const   *)val.v.str;
#line 418
    val.type = (char)0;
#line 419
    p->isnested = (char)1;
#line 420
    p->epos = p->etext;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 431 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/main.c"
int ParseNonSpaceChar(ParsePtr p , int *err , int peek ) 
{ 
  int ch ;
  unsigned short const   **tmp ;

  {
  {
#line 435
  ch = ParseChar(p, err, 1);
  }
#line 436
  if (*err) {
#line 436
    return (0);
  }
  {
#line 438
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 438
    tmp = __ctype_b_loc();
    }
#line 438
    if (! ((int const   )*(*tmp + ch) & 8192)) {
#line 438
      if (! (ch == 92)) {
#line 438
        goto while_break;
      }
    }
    {
#line 439
    ParseChar(p, err, 0);
#line 440
    ch = ParseChar(p, err, 1);
    }
#line 441
    if (*err) {
#line 441
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 443
  if (! peek) {
    {
#line 443
    ch = ParseChar(p, err, 0);
    }
  }
#line 444
  return (ch);
}
}
#line 454 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/main.c"
int ParseToken(ParsePtr p , DynamicBuffer *dbuf ) 
{ 
  int c ;
  int err ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;

  {
  {
#line 458
  DBufFree(dbuf);
#line 460
  c = ParseChar(p, & err, 0);
  }
#line 461
  if (err) {
#line 461
    return (err);
  }
  {
#line 462
  while (1) {
    while_continue: /* CIL Label */ ;
#line 462
    if (c) {
      {
#line 462
      tmp = __ctype_b_loc();
      }
#line 462
      if (! ((int const   )*(*tmp + c) & 8192)) {
#line 462
        if (! (c == 92)) {
#line 462
          goto while_break;
        }
      }
    } else {
#line 462
      goto while_break;
    }
    {
#line 463
    c = ParseChar(p, & err, 0);
    }
#line 464
    if (err) {
#line 464
      return (err);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 466
  if (! c) {
#line 466
    return (0);
  }
  {
#line 467
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 467
    if (c) {
      {
#line 467
      tmp___3 = __ctype_b_loc();
      }
#line 467
      if ((int const   )*(*tmp___3 + c) & 8192) {
#line 467
        goto while_break___0;
      } else
#line 467
      if (c == 92) {
#line 467
        goto while_break___0;
      }
    } else {
#line 467
      goto while_break___0;
    }
#line 468
    if (dbuf->allocatedLen < dbuf->len + 1) {
#line 468
      tmp___0 = dbuf->len;
#line 468
      (dbuf->len) ++;
#line 468
      *(dbuf->buffer + tmp___0) = (char )c;
#line 468
      *(dbuf->buffer + dbuf->len) = (char)0;
#line 468
      tmp___2 = 0;
    } else {
      {
#line 468
      tmp___1 = DBufPutcFN(dbuf, (char )c);
#line 468
      tmp___2 = tmp___1 != 0;
      }
    }
#line 468
    if (tmp___2) {
      {
#line 469
      DBufFree(dbuf);
      }
#line 470
      return (9);
    }
    {
#line 472
    c = ParseChar(p, & err, 0);
    }
#line 473
    if (err) {
      {
#line 474
      DBufFree(dbuf);
      }
#line 475
      return (err);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 478
  return (0);
}
}
#line 490 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/main.c"
int ParseIdentifier(ParsePtr p , DynamicBuffer *dbuf ) 
{ 
  int c ;
  int err ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 494
  DBufFree(dbuf);
#line 496
  c = ParseChar(p, & err, 0);
  }
#line 497
  if (err) {
#line 497
    return (err);
  }
  {
#line 498
  while (1) {
    while_continue: /* CIL Label */ ;
#line 498
    if (c) {
      {
#line 498
      tmp = __ctype_b_loc();
      }
#line 498
      if (! ((int const   )*(*tmp + c) & 8192)) {
#line 498
        if (! (c == 92)) {
#line 498
          goto while_break;
        }
      }
    } else {
#line 498
      goto while_break;
    }
    {
#line 499
    c = ParseChar(p, & err, 0);
    }
#line 500
    if (err) {
#line 500
      return (err);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 502
  if (! c) {
#line 502
    return (19);
  }
#line 503
  if (c != 36) {
#line 503
    if (c != 95) {
      {
#line 503
      tmp___0 = __ctype_b_loc();
      }
#line 503
      if (! ((int const   )*(*tmp___0 + c) & 1024)) {
#line 503
        return (42);
      }
    }
  }
#line 504
  if (dbuf->allocatedLen < dbuf->len + 1) {
#line 504
    tmp___1 = dbuf->len;
#line 504
    (dbuf->len) ++;
#line 504
    *(dbuf->buffer + tmp___1) = (char )c;
#line 504
    *(dbuf->buffer + dbuf->len) = (char)0;
#line 504
    tmp___3 = 0;
  } else {
    {
#line 504
    tmp___2 = DBufPutcFN(dbuf, (char )c);
#line 504
    tmp___3 = tmp___2 != 0;
    }
  }
#line 504
  if (tmp___3) {
    {
#line 505
    DBufFree(dbuf);
    }
#line 506
    return (9);
  }
  {
#line 509
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 510
    c = ParseChar(p, & err, 1);
    }
#line 511
    if (err) {
      {
#line 512
      DBufFree(dbuf);
      }
#line 513
      return (err);
    }
#line 515
    if (c != 95) {
      {
#line 515
      tmp___4 = __ctype_b_loc();
      }
#line 515
      if (! ((int const   )*(*tmp___4 + c) & 8)) {
#line 515
        return (0);
      }
    }
    {
#line 516
    c = ParseChar(p, & err, 0);
    }
#line 517
    if (dbuf->allocatedLen < dbuf->len + 1) {
#line 517
      tmp___5 = dbuf->len;
#line 517
      (dbuf->len) ++;
#line 517
      *(dbuf->buffer + tmp___5) = (char )c;
#line 517
      *(dbuf->buffer + dbuf->len) = (char)0;
#line 517
      tmp___7 = 0;
    } else {
      {
#line 517
      tmp___6 = DBufPutcFN(dbuf, (char )c);
#line 517
      tmp___7 = tmp___6 != 0;
      }
    }
#line 517
    if (tmp___7) {
      {
#line 518
      DBufFree(dbuf);
      }
#line 519
      return (9);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 532 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/main.c"
int EvaluateExpr(ParsePtr p , Value *v ) 
{ 
  int bracketed ;
  int r ;
  unsigned short const   **tmp ;

  {
#line 535
  bracketed = 0;
#line 538
  if (p->isnested) {
#line 538
    return (32);
  }
  {
#line 539
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 539
    tmp = __ctype_b_loc();
    }
#line 539
    if (! ((int const   )*(*tmp + (int )*(p->pos)) & 8192)) {
#line 539
      if (! ((int const   )*(p->pos) == 92)) {
#line 539
        goto while_break;
      }
    }
#line 539
    (p->pos) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 540
  if (! p->pos) {
#line 540
    return (32);
  }
#line 541
  if ((int const   )*(p->pos) == 91) {
#line 542
    (p->pos) ++;
#line 543
    bracketed = 1;
  }
  {
#line 545
  r = EvalExpr(& p->pos, v, p);
  }
#line 546
  if (r) {
#line 546
    return (r);
  }
#line 547
  if (bracketed) {
#line 548
    if ((int const   )*(p->pos) != 93) {
#line 548
      return (1);
    }
#line 549
    (p->pos) ++;
  }
#line 551
  return (0);
}
}
#line 559 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/main.c"
void Eprint(char const   *fmt  , ...) 
{ 
  va_list argptr ;
  int tmp ;

  {
#line 564
  if (! FreshLine) {
#line 564
    if (! ShowAllErrors) {
#line 564
      return;
    }
  }
#line 566
  if (FreshLine) {
#line 566
    if (FileName) {
      {
#line 567
      FreshLine = 0;
#line 568
      tmp = strcmp((char const   *)FileName, "-");
      }
#line 568
      if (tmp) {
        {
#line 569
        fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"%s(%d): ",
                FileName, LineNo);
        }
      } else {
        {
#line 571
        fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"-stdin-(%d): ",
                LineNo);
        }
      }
#line 572
      if (DebugFlag & 1) {
        {
#line 572
        OutputLine(ErrFp);
        }
      }
    } else {
#line 566
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 573
  if (FileName) {
    {
#line 574
    fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"       ");
    }
  }
  {
#line 577
  __builtin_va_start(argptr, fmt);
#line 578
  vfprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)fmt, argptr);
#line 579
  fputc('\n', ErrFp);
#line 580
  __builtin_va_end(argptr);
  }
#line 581
  return;
}
}
#line 592 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/main.c"
void OutputLine(FILE *fp___0 ) 
{ 
  char const   *s ;
  char c ;
  char const   *tmp ;

  {
#line 594
  s = CurLine;
#line 595
  c = (char)0;
  {
#line 597
  while (1) {
    while_continue: /* CIL Label */ ;
#line 597
    if (! *s) {
#line 597
      goto while_break;
    }
#line 598
    if ((int const   )*s == 10) {
      {
#line 598
      _IO_putc('\\', fp___0);
      }
    }
    {
#line 599
    _IO_putc((int )*s, fp___0);
#line 600
    tmp = s;
#line 600
    s ++;
#line 600
    c = (char )*tmp;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 602
  if ((int )c != 10) {
    {
#line 602
    _IO_putc('\n', fp___0);
    }
  }
#line 603
  return;
}
}
#line 612 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/main.c"
void CreateParser(char const   *s , ParsePtr p ) 
{ 


  {
  {
#line 614
  p->text = s;
#line 615
  p->pos = s;
#line 616
  p->isnested = (char)0;
#line 617
  p->epos = (char const   *)((void *)0);
#line 618
  p->etext = (char const   *)((void *)0);
#line 619
  p->allownested = (char)1;
#line 620
  p->tokenPushed = (char const   *)((void *)0);
#line 621
  p->expr_happened = (char)0;
#line 622
  p->nonconst_expr = (char)0;
#line 623
  DBufInit(& p->pushedToken);
  }
#line 624
  return;
}
}
#line 633 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/main.c"
void DestroyParser(ParsePtr p ) 
{ 


  {
#line 635
  if (p->isnested) {
#line 635
    if (p->etext) {
      {
#line 636
      free((void *)p->etext);
#line 637
      p->etext = (char const   *)((void *)0);
#line 638
      p->isnested = (char)0;
      }
    }
  }
  {
#line 640
  DBufFree(& p->pushedToken);
  }
#line 641
  return;
}
}
#line 649 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/main.c"
int PushToken(char const   *tok , ParsePtr p ) 
{ 
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 651
  DBufFree(& p->pushedToken);
#line 652
  tmp___3 = DBufPuts(& p->pushedToken, tok);
  }
#line 652
  if (tmp___3 != 0) {
#line 652
    tmp___0 = p->pushedToken.len;
#line 652
    (p->pushedToken.len) ++;
#line 652
    *(p->pushedToken.buffer + tmp___0) = (char )' ';
#line 652
    *(p->pushedToken.buffer + p->pushedToken.len) = (char)0;
#line 652
    tmp___2 = 0;
  } else
#line 652
  if (p->pushedToken.allocatedLen < p->pushedToken.len + 1) {
#line 652
    tmp___0 = p->pushedToken.len;
#line 652
    (p->pushedToken.len) ++;
#line 652
    *(p->pushedToken.buffer + tmp___0) = (char )' ';
#line 652
    *(p->pushedToken.buffer + p->pushedToken.len) = (char)0;
#line 652
    tmp___2 = 0;
  } else {
    {
#line 652
    tmp___1 = DBufPutcFN(& p->pushedToken, (char )' ');
#line 652
    tmp___2 = tmp___1 != 0;
    }
  }
#line 652
  if (tmp___2) {
    {
#line 654
    DBufFree(& p->pushedToken);
    }
#line 655
    return (9);
  }
#line 657
  p->tokenPushed = (char const   *)p->pushedToken.buffer;
#line 658
  return (0);
}
}
#line 668 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/main.c"
long SystemTime(int realtime ) 
{ 
  time_t tloc ;
  struct tm *t ;

  {
#line 673
  if (! realtime) {
#line 673
    if (SysTime != -1L) {
#line 673
      return (SysTime);
    }
  }
  {
#line 675
  time(& tloc);
#line 676
  t = localtime((time_t const   *)(& tloc));
  }
#line 677
  return (((long )t->tm_hour * 3600L + (long )t->tm_min * 60L) + (long )t->tm_sec);
}
}
#line 690 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/main.c"
int SystemDate(int *y , int *m , int *d ) 
{ 
  time_t tloc ;
  struct tm *t ;
  int tmp ;

  {
  {
#line 695
  time(& tloc);
#line 696
  t = localtime((time_t const   *)(& tloc));
#line 698
  *d = t->tm_mday;
#line 699
  *m = t->tm_mon;
#line 700
  *y = t->tm_year + 1900;
#line 702
  tmp = Julian(*y, *m, *d);
  }
#line 702
  return (tmp);
}
}
#line 711 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/main.c"
int DoIf(ParsePtr p ) 
{ 
  Value v ;
  int r ;
  unsigned int syndrome ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 717
  if ((unsigned long )NumIfs >= 4UL * sizeof(unsigned int )) {
#line 717
    return (34);
  }
  {
#line 719
  tmp___0 = ShouldIgnoreLine();
  }
#line 719
  if (tmp___0) {
#line 719
    syndrome = 0U;
  } else {
    {
#line 721
    r = EvaluateExpr(p, & v);
    }
#line 721
    if (r) {
      {
#line 722
      syndrome = 0U;
#line 723
      Eprint("%s", ErrMsg[r]);
      }
    } else
#line 725
    if ((int )v.type != 4) {
#line 725
      if (v.v.val) {
#line 727
        syndrome = 0U;
      } else {
#line 725
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 725
    if ((int )v.type == 4) {
      {
#line 725
      tmp = strcmp((char const   *)v.v.str, "");
      }
#line 725
      if (tmp) {
#line 727
        syndrome = 0U;
      } else {
#line 725
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 729
      syndrome = 1U;
#line 730
      if (PurgeMode) {
        {
#line 731
        PurgeEchoLine("%s\n", "#!P: The next IF evaluated false...");
#line 732
        PurgeEchoLine("%s\n", "#!P: REM statements in IF block not checked for purging.");
        }
      }
    }
  }
  {
#line 737
  NumIfs ++;
#line 738
  IfFlags &= (unsigned int )(~ (3 << (2 * NumIfs - 2)));
#line 739
  IfFlags |= syndrome << (2 * NumIfs - 2);
#line 740
  tmp___1 = ShouldIgnoreLine();
  }
#line 740
  if (tmp___1) {
#line 740
    return (0);
  }
  {
#line 741
  tmp___2 = VerifyEoln(p);
  }
#line 741
  return (tmp___2);
}
}
#line 750 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/main.c"
int DoElse(ParsePtr p ) 
{ 
  unsigned int syndrome ;
  int was_ignoring ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 754
  tmp = ShouldIgnoreLine();
#line 754
  was_ignoring = tmp;
  }
#line 756
  if (! NumIfs) {
#line 756
    return (35);
  }
#line 758
  syndrome = IfFlags >> (2 * NumIfs - 2);
#line 760
  if ((syndrome & 2U) == 2U) {
#line 760
    return (35);
  }
#line 762
  IfFlags |= (unsigned int )(2 << (2 * NumIfs - 2));
#line 763
  if (PurgeMode) {
    {
#line 763
    tmp___0 = ShouldIgnoreLine();
    }
#line 763
    if (tmp___0) {
#line 763
      if (! was_ignoring) {
        {
#line 764
        PurgeEchoLine("%s\n", "#!P: The previous IF evaluated true.");
#line 765
        PurgeEchoLine("%s\n", "#!P: REM statements in ELSE block not checked for purging");
        }
      }
    }
  }
  {
#line 767
  tmp___1 = VerifyEoln(p);
  }
#line 767
  return (tmp___1);
}
}
#line 775 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/main.c"
int DoEndif(ParsePtr p ) 
{ 
  int tmp ;

  {
#line 777
  if (! NumIfs) {
#line 777
    return (36);
  }
  {
#line 778
  NumIfs --;
#line 779
  tmp = VerifyEoln(p);
  }
#line 779
  return (tmp);
}
}
#line 789 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/main.c"
int DoIfTrig(ParsePtr p ) 
{ 
  int r ;
  int err ;
  unsigned int syndrome ;
  Trigger trig ;
  TimeTrig tim ;
  int jul ;
  int tmp ;
  int tmp___0 ;

  {
#line 798
  if ((unsigned long )NumIfs >= 4UL * sizeof(unsigned int )) {
#line 798
    return (34);
  }
  {
#line 799
  tmp___0 = ShouldIgnoreLine();
  }
#line 799
  if (tmp___0) {
#line 799
    syndrome = 0U;
  } else {
    {
#line 801
    r = ParseRem(p, & trig, & tim, 1);
    }
#line 801
    if (r) {
#line 801
      return (r);
    }
#line 802
    if (trig.typ != 0) {
#line 802
      return (32);
    }
    {
#line 803
    jul = ComputeTrigger(trig.scanfrom, & trig, & r, 1);
    }
#line 804
    if (r) {
#line 804
      syndrome = 0U;
    } else {
      {
#line 806
      tmp = ShouldTriggerReminder(& trig, & tim, jul, & err);
      }
#line 806
      if (tmp) {
#line 807
        syndrome = 0U;
      } else {
#line 809
        syndrome = 1U;
#line 810
        if (PurgeMode) {
          {
#line 811
          PurgeEchoLine("%s\n", "#!P: The next IFTRIG did not trigger.");
#line 812
          PurgeEchoLine("%s\n", "#!P: REM statements in IFTRIG block not checked for purging.");
          }
        }
      }
    }
    {
#line 816
    FreeTrig(& trig);
    }
  }
#line 818
  NumIfs ++;
#line 819
  IfFlags &= (unsigned int )(~ (3 << (2 * NumIfs - 2)));
#line 820
  IfFlags |= syndrome << (2 * NumIfs - 2);
#line 821
  return (0);
}
}
#line 831 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/main.c"
int ShouldIgnoreLine(void) 
{ 
  register int i ;
  register int syndrome ;

  {
#line 838
  i = 0;
  {
#line 838
  while (1) {
    while_continue: /* CIL Label */ ;
#line 838
    if (! (i < NumIfs)) {
#line 838
      goto while_break;
    }
#line 839
    syndrome = (int )((IfFlags >> i * 2) & 3U);
#line 840
    if (syndrome == 2) {
#line 841
      return (1);
    } else
#line 840
    if (syndrome == 1) {
#line 841
      return (1);
    }
#line 838
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 843
  return (0);
}
}
#line 853 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/main.c"
int VerifyEoln(ParsePtr p ) 
{ 
  int r ;
  DynamicBuffer buf___1 ;

  {
  {
#line 858
  DBufInit(& buf___1);
#line 860
  r = ParseToken(p, & buf___1);
  }
#line 860
  if (r) {
#line 860
    return (r);
  }
#line 861
  if (*(buf___1.buffer)) {
#line 861
    if ((int )*(buf___1.buffer) != 35) {
#line 861
      if ((int )*(buf___1.buffer) != 59) {
        {
#line 864
        Eprint("%s: `%s\'", ErrMsg[59], buf___1.buffer);
#line 865
        DBufFree(& buf___1);
        }
#line 866
        return (38);
      }
    }
  }
  {
#line 868
  DBufFree(& buf___1);
  }
#line 869
  return (0);
}
}
#line 879 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/main.c"
int DoDebug(ParsePtr p ) 
{ 
  int err ;
  int ch ;
  int val ;

  {
#line 883
  val = 1;
  {
#line 885
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 886
    ch = ParseChar(p, & err, 0);
    }
#line 887
    if (err) {
#line 887
      return (err);
    }
    {
#line 891
    if (ch == 0) {
#line 891
      goto case_0;
    }
#line 891
    if (ch == 59) {
#line 891
      goto case_0;
    }
#line 891
    if (ch == 35) {
#line 891
      goto case_0;
    }
#line 895
    if (ch == 9) {
#line 895
      goto case_9;
    }
#line 895
    if (ch == 32) {
#line 895
      goto case_9;
    }
#line 898
    if (ch == 43) {
#line 898
      goto case_43;
    }
#line 902
    if (ch == 45) {
#line 902
      goto case_45;
    }
#line 907
    if (ch == 69) {
#line 907
      goto case_69;
    }
#line 907
    if (ch == 101) {
#line 907
      goto case_69;
    }
#line 913
    if (ch == 88) {
#line 913
      goto case_88;
    }
#line 913
    if (ch == 120) {
#line 913
      goto case_88;
    }
#line 919
    if (ch == 84) {
#line 919
      goto case_84;
    }
#line 919
    if (ch == 116) {
#line 919
      goto case_84;
    }
#line 925
    if (ch == 86) {
#line 925
      goto case_86;
    }
#line 925
    if (ch == 118) {
#line 925
      goto case_86;
    }
#line 931
    if (ch == 76) {
#line 931
      goto case_76;
    }
#line 931
    if (ch == 108) {
#line 931
      goto case_76;
    }
#line 937
    if (ch == 70) {
#line 937
      goto case_70;
    }
#line 937
    if (ch == 102) {
#line 937
      goto case_70;
    }
#line 888
    goto switch_break;
    case_0: /* CIL Label */ 
    case_59: /* CIL Label */ 
    case_35: /* CIL Label */ 
#line 892
    return (0);
    case_9: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 896
    goto switch_break;
    case_43: /* CIL Label */ 
#line 899
    val = 1;
#line 900
    goto switch_break;
    case_45: /* CIL Label */ 
#line 903
    val = 0;
#line 904
    goto switch_break;
    case_69: /* CIL Label */ 
    case_101: /* CIL Label */ 
#line 908
    if (val) {
#line 908
      DebugFlag |= 16;
    } else {
#line 909
      DebugFlag &= -17;
    }
#line 910
    goto switch_break;
    case_88: /* CIL Label */ 
    case_120: /* CIL Label */ 
#line 914
    if (val) {
#line 914
      DebugFlag |= 2;
    } else {
#line 915
      DebugFlag &= -3;
    }
#line 916
    goto switch_break;
    case_84: /* CIL Label */ 
    case_116: /* CIL Label */ 
#line 920
    if (val) {
#line 920
      DebugFlag |= 4;
    } else {
#line 921
      DebugFlag &= -5;
    }
#line 922
    goto switch_break;
    case_86: /* CIL Label */ 
    case_118: /* CIL Label */ 
#line 926
    if (val) {
#line 926
      DebugFlag |= 8;
    } else {
#line 927
      DebugFlag &= -9;
    }
#line 928
    goto switch_break;
    case_76: /* CIL Label */ 
    case_108: /* CIL Label */ 
#line 932
    if (val) {
#line 932
      DebugFlag |= 1;
    } else {
#line 933
      DebugFlag &= -2;
    }
#line 934
    goto switch_break;
    case_70: /* CIL Label */ 
    case_102: /* CIL Label */ 
#line 938
    if (val) {
#line 938
      DebugFlag |= 32;
    } else {
#line 939
      DebugFlag &= -33;
    }
#line 940
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 953 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/main.c"
int DoBanner(ParsePtr p ) 
{ 
  int err ;
  int c ;
  DynamicBuffer buf___1 ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 959
  DBufInit(& buf___1);
#line 960
  c = ParseChar(p, & err, 0);
  }
#line 961
  if (err) {
#line 961
    return (err);
  }
  {
#line 962
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 962
    tmp = __ctype_b_loc();
    }
#line 962
    if (! ((int const   )*(*tmp + c) & 8192)) {
#line 962
      if (! (c == 92)) {
#line 962
        goto while_break;
      }
    }
    {
#line 963
    c = ParseChar(p, & err, 0);
    }
#line 964
    if (err) {
#line 964
      return (err);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 966
  if (! c) {
#line 966
    return (19);
  }
  {
#line 968
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 968
    if (! c) {
#line 968
      goto while_break___0;
    }
#line 969
    if (buf___1.allocatedLen < buf___1.len + 1) {
#line 969
      tmp___0 = buf___1.len;
#line 969
      (buf___1.len) ++;
#line 969
      *(buf___1.buffer + tmp___0) = (char )c;
#line 969
      *(buf___1.buffer + buf___1.len) = (char)0;
#line 969
      tmp___2 = 0;
    } else {
      {
#line 969
      tmp___1 = DBufPutcFN(& buf___1, (char )c);
#line 969
      tmp___2 = tmp___1 != 0;
      }
    }
#line 969
    if (tmp___2) {
#line 969
      return (9);
    }
    {
#line 970
    c = ParseChar(p, & err, 0);
    }
#line 971
    if (err) {
      {
#line 972
      DBufFree(& buf___1);
      }
#line 973
      return (err);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 976
  DBufFree(& Banner);
#line 978
  err = DBufPuts(& Banner, (char const   *)buf___1.buffer);
#line 979
  DBufFree(& buf___1);
  }
#line 980
  return (err);
}
}
#line 991 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/main.c"
int DoRun(ParsePtr p ) 
{ 
  int r ;
  DynamicBuffer buf___1 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 996
  DBufInit(& buf___1);
#line 998
  r = ParseToken(p, & buf___1);
  }
#line 998
  if (r) {
#line 998
    return (r);
  }
  {
#line 1001
  tmp___1 = StrCmpi((char const   *)buf___1.buffer, "ON");
  }
#line 1001
  if (tmp___1) {
    {
#line 1005
    tmp___0 = StrCmpi((char const   *)buf___1.buffer, "OFF");
    }
#line 1005
    if (tmp___0) {
      {
#line 1008
      DBufFree(& buf___1);
      }
#line 1009
      return (32);
    } else {
#line 1006
      RunDisabled |= 2;
    }
  } else {
    {
#line 1002
    tmp = TopLevel();
    }
#line 1002
    if (tmp) {
#line 1002
      RunDisabled &= -3;
    }
  }
  {
#line 1011
  DBufFree(& buf___1);
#line 1013
  tmp___2 = VerifyEoln(p);
  }
#line 1013
  return (tmp___2);
}
}
#line 1023 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/main.c"
int DoFlush(ParsePtr p ) 
{ 
  int tmp ;

  {
  {
#line 1025
  fflush(stdout);
#line 1026
  fflush(stderr);
#line 1027
  tmp = VerifyEoln(p);
  }
#line 1027
  return (tmp);
}
}
#line 1037 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/main.c"
void DoExit(ParsePtr p ) 
{ 
  int r ;
  Value v ;

  {
#line 1042
  if (PurgeMode) {
#line 1042
    return;
  }
  {
#line 1044
  r = EvaluateExpr(p, & v);
  }
#line 1045
  if (r) {
    {
#line 1045
    exit(99);
    }
  } else
#line 1045
  if ((int )v.type != 1) {
    {
#line 1045
    exit(99);
    }
  }
  {
#line 1046
  exit(v.v.val);
  }
}
}
#line 1056 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/main.c"
int DoErrMsg(ParsePtr p ) 
{ 
  TimeTrig tt ;
  Trigger t ;
  int r ;
  char const   *s ;
  DynamicBuffer buf___1 ;
  long tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 1065
  if (PurgeMode) {
#line 1065
    return (0);
  }
  {
#line 1067
  DBufInit(& buf___1);
#line 1068
  t.typ = 1;
#line 1069
  tmp = SystemTime(0);
#line 1069
  tt.ttime = (int )(tmp / 60L);
#line 1070
  r = DoSubst(p, & buf___1, & t, & tt, JulianToday, 0);
  }
#line 1070
  if (r) {
#line 1071
    return (r);
  }
#line 1073
  s = (char const   *)buf___1.buffer;
  {
#line 1074
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1074
    tmp___0 = __ctype_b_loc();
    }
#line 1074
    if (! ((int const   )*(*tmp___0 + (int )*s) & 8192)) {
#line 1074
      if (! ((int const   )*s == 92)) {
#line 1074
        goto while_break;
      }
    }
#line 1074
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1075
  fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"%s\n",
          s);
#line 1076
  DBufFree(& buf___1);
  }
#line 1077
  return (0);
}
}
#line 1095 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/main.c"
static int FoldArray[2][7]  = { {        2001,        2002,        2003,        2009, 
            2010,        2005,        2006}, 
   {        2024,        2008,        2020,        2004, 
            2016,        2000,        2012}};
#line 1100 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/main.c"
int CalcMinsFromUTC(int jul , int tim , int *mins , int *isdst ) 
{ 
  int yr ;
  int mon ;
  int day ;
  int tdiff ;
  struct tm local ;
  struct tm utc ;
  struct tm *temp ;
  time_t loc_t ;
  time_t utc_t ;
  int isdst_tmp ;
  int tmp ;
  int tmp___0 ;
  double tmp___1 ;

  {
  {
#line 1110
  FromJulian(jul, & yr, & mon, & day);
  }
#line 1115
  if (FoldYear) {
#line 1115
    if (yr > 2037) {
      {
#line 1116
      jul = Julian(yr, 0, 1);
      }
#line 1117
      if (yr % 4) {
#line 1117
        tmp___0 = 0;
      } else {
#line 1117
        if (! (yr % 100)) {
#line 1117
          if (yr % 400) {
#line 1117
            tmp = 0;
          } else {
#line 1117
            tmp = 1;
          }
        } else {
#line 1117
          tmp = 1;
        }
#line 1117
        tmp___0 = tmp;
      }
#line 1117
      yr = FoldArray[tmp___0][jul % 7];
    }
  }
  {
#line 1119
  local.tm_sec = 0;
#line 1120
  local.tm_min = tim % 60;
#line 1121
  local.tm_hour = tim / 60;
#line 1122
  local.tm_mday = day;
#line 1123
  local.tm_mon = mon;
#line 1124
  local.tm_year = yr - 1900;
#line 1125
  local.tm_isdst = -1;
#line 1129
  loc_t = mktime(& local);
  }
#line 1130
  if (loc_t == -1L) {
#line 1130
    return (1);
  }
  {
#line 1131
  isdst_tmp = local.tm_isdst;
#line 1132
  local.tm_isdst = 0;
#line 1133
  loc_t = mktime(& local);
  }
#line 1134
  if (loc_t == -1L) {
#line 1134
    return (1);
  }
  {
#line 1135
  temp = gmtime((time_t const   *)(& loc_t));
#line 1136
  utc = *temp;
#line 1137
  utc.tm_isdst = 0;
#line 1138
  utc_t = mktime(& utc);
  }
#line 1139
  if (utc_t == -1L) {
#line 1139
    return (1);
  }
  {
#line 1143
  tmp___1 = difftime(loc_t, utc_t);
#line 1143
  tdiff = (int )tmp___1;
  }
#line 1144
  if (isdst_tmp) {
#line 1144
    tdiff += 3600;
  }
#line 1145
  if (mins) {
#line 1145
    *mins = tdiff / 60;
  }
#line 1146
  if (isdst) {
#line 1146
    *isdst = isdst_tmp;
  }
#line 1147
  return (0);
}
}
#line 1165 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/main.c"
void FillParagraph(char const   *s ) 
{ 
  int line ;
  int i ;
  int j ;
  int doublespace ;
  int pendspace ;
  int len ;
  char const   *t ;
  int roomleft ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 1168
  line = 0;
#line 1170
  doublespace = 1;
#line 1177
  if (! s) {
#line 1177
    return;
  } else
#line 1177
  if (! *s) {
#line 1177
    return;
  }
  {
#line 1180
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1180
    tmp = __ctype_b_loc();
    }
#line 1180
    if ((int const   )*(*tmp + (int )*s) & 8192) {
#line 1180
      if (! ((int const   )*s != 10)) {
#line 1180
        goto while_break;
      }
    } else {
#line 1180
      goto while_break;
    }
#line 1180
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1183
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1186
    if ((int const   )*s == 10) {
      {
#line 1187
      putchar('\n');
#line 1188
      s ++;
#line 1189
      line = 0;
      }
      {
#line 1190
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 1190
        tmp___0 = __ctype_b_loc();
        }
#line 1190
        if ((int const   )*(*tmp___0 + (int )*s) & 8192) {
#line 1190
          if (! ((int const   )*s != 10)) {
#line 1190
            goto while_break___1;
          }
        } else {
#line 1190
          goto while_break___1;
        }
#line 1190
        s ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1191
      goto while_continue___0;
    }
#line 1193
    if (! *s) {
#line 1194
      return;
    }
#line 1198
    if (line) {
#line 1198
      j = SubsIndent;
    } else {
#line 1198
      j = FirstIndent;
    }
#line 1199
    i = 0;
    {
#line 1199
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1199
      if (! (i < j)) {
#line 1199
        goto while_break___2;
      }
      {
#line 1200
      putchar(' ');
#line 1199
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1204
    roomleft = FormWidth - j;
#line 1205
    pendspace = 0;
    {
#line 1208
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 1209
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 1209
        tmp___1 = __ctype_b_loc();
        }
#line 1209
        if ((int const   )*(*tmp___1 + (int )*s) & 8192) {
#line 1209
          if (! ((int const   )*s != 10)) {
#line 1209
            goto while_break___4;
          }
        } else {
#line 1209
          goto while_break___4;
        }
#line 1209
        s ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1210
      if ((int const   )*s == 10) {
#line 1210
        goto while_break___3;
      }
#line 1211
      t = s;
      {
#line 1212
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1212
        if (*s) {
          {
#line 1212
          tmp___2 = __ctype_b_loc();
          }
#line 1212
          if ((int const   )*(*tmp___2 + (int )*s) & 8192) {
#line 1212
            goto while_break___5;
          }
        } else {
#line 1212
          goto while_break___5;
        }
#line 1212
        s ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 1213
      len = (int )(s - t);
#line 1214
      if (! len) {
#line 1215
        return;
      }
#line 1217
      if (! pendspace) {
#line 1217
        goto _L;
      } else
#line 1217
      if (len + pendspace <= roomleft) {
        _L: /* CIL Label */ 
#line 1218
        i = 0;
        {
#line 1218
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 1218
          if (! (i < pendspace)) {
#line 1218
            goto while_break___6;
          }
          {
#line 1219
          putchar(' ');
#line 1218
          i ++;
          }
        }
        while_break___6: /* CIL Label */ ;
        }
        {
#line 1221
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 1221
          if (! ((unsigned long )t < (unsigned long )s)) {
#line 1221
            goto while_break___7;
          }
          {
#line 1222
          putchar((int )*t);
#line 1223
          tmp___4 = strchr((char const   *)EndSent, (int )*t);
          }
#line 1223
          if (tmp___4) {
#line 1223
            doublespace = 2;
          } else {
            {
#line 1224
            tmp___3 = strchr((char const   *)EndSentIg, (int )*t);
            }
#line 1224
            if (! tmp___3) {
#line 1224
              doublespace = 1;
            }
          }
#line 1225
          t ++;
        }
        while_break___7: /* CIL Label */ ;
        }
      } else {
        {
#line 1228
        s = t;
#line 1229
        putchar('\n');
#line 1230
        line ++;
        }
#line 1231
        goto while_break___3;
      }
#line 1233
      roomleft -= len + doublespace;
#line 1234
      pendspace = doublespace;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 1246 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/main.c"
void LocalToUTC(int locdate , int loctime , int *utcdate , int *utctime ) 
{ 
  int diff ;
  int dummy ;
  int tmp ;

  {
#line 1251
  if (! CalculateUTC) {
#line 1252
    diff = MinsFromUTC;
  } else {
    {
#line 1251
    tmp = CalcMinsFromUTC(locdate, loctime, & diff, & dummy);
    }
#line 1251
    if (tmp) {
#line 1252
      diff = MinsFromUTC;
    }
  }
#line 1254
  loctime -= diff;
#line 1255
  if (loctime < 0) {
#line 1256
    loctime += 1440;
#line 1257
    locdate --;
  } else
#line 1258
  if (loctime >= 1440) {
#line 1259
    loctime -= 1440;
#line 1260
    locdate ++;
  }
#line 1262
  *utcdate = locdate;
#line 1263
  *utctime = loctime;
#line 1264
  return;
}
}
#line 1273 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/main.c"
void UTCToLocal(int utcdate , int utctime , int *locdate , int *loctime ) 
{ 
  int diff ;
  int dummy ;
  int tmp ;

  {
#line 1279
  if (! CalculateUTC) {
#line 1280
    diff = MinsFromUTC;
  } else {
    {
#line 1279
    tmp = CalcMinsFromUTC(utcdate, utctime, & diff, & dummy);
    }
#line 1279
    if (tmp) {
#line 1280
      diff = MinsFromUTC;
    }
  }
#line 1282
  utctime += diff;
#line 1283
  if (utctime < 0) {
#line 1284
    utctime += 1440;
#line 1285
    utcdate --;
  } else
#line 1286
  if (utctime >= 1440) {
#line 1287
    utctime -= 1440;
#line 1288
    utcdate ++;
  }
#line 1290
  *locdate = utcdate;
#line 1291
  *loctime = utctime;
#line 1292
  return;
}
}
#line 1304 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/main.c"
void SigIntHandler(int d ) 
{ 


  {
  {
#line 1306
  signal(2, & SigIntHandler);
#line 1307
  GotSigInt();
#line 1308
  exit(0);
  }
}
}
#line 1311 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/main.c"
void AppendTag(DynamicBuffer *buf___1 , char const   *s ) 
{ 
  int tmp ;

  {
#line 1314
  if (*(buf___1->buffer)) {
#line 1315
    if (buf___1->allocatedLen < buf___1->len + 1) {
#line 1315
      tmp = buf___1->len;
#line 1315
      (buf___1->len) ++;
#line 1315
      *(buf___1->buffer + tmp) = (char )',';
#line 1315
      *(buf___1->buffer + buf___1->len) = (char)0;
    } else {
      {
#line 1315
      DBufPutcFN(buf___1, (char )',');
      }
    }
  }
  {
#line 1317
  DBufPuts(buf___1, s);
  }
#line 1318
  return;
}
}
#line 1320 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/main.c"
void FreeTrig(Trigger *t ) 
{ 


  {
  {
#line 1323
  DBufFree(& t->tags);
  }
#line 1324
  return;
}
}
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/protos.h"
int ParseLiteralDate(char const   **s , int *jul , int *tim ) ;
#line 49
int CallFunc(BuiltinFunc *f , int nargs ) ;
#line 111
Operator *FindOperator(char const   *name , Operator *where , int num ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/expr.c"
static char CoerceBuf[512]  ;
#line 37
static int Multiply(void) ;
#line 37
static int Divide(void) ;
#line 37
static int Mod(void) ;
#line 37
static int Add(void) ;
#line 37
static int Subtract(void) ;
#line 37
static int GreaterThan(void) ;
#line 37
static int LessThan(void) ;
#line 37
static int EqualTo(void) ;
#line 37
static int NotEqual(void) ;
#line 37
static int LessOrEqual(void) ;
#line 37
static int GreaterOrEqual(void) ;
#line 37
static int LogAND(void) ;
#line 37
static int LogOR(void) ;
#line 37
static int UnMinus(void) ;
#line 37
static int LogNot(void) ;
#line 37
static int Compare(int how ) ;
#line 44
static int MakeValue(char const   *s , Value *v , Var *locals , ParsePtr p ) ;
#line 51 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/expr.c"
Operator BinOp[13]  = 
#line 51
  {      {"!=", (char)15, (char)1, & NotEqual}, 
        {"%", (char)20, (char)1, & Mod}, 
        {"&&", (char)14, (char)1, & LogAND}, 
        {"*", (char)20, (char)1, & Multiply}, 
        {"+", (char)18, (char)1, & Add}, 
        {"-", (char)18, (char)1, & Subtract}, 
        {"/", (char)20, (char)1, & Divide}, 
        {"<", (char)16, (char)1, & LessThan}, 
        {"<=", (char)16, (char)1, & LessOrEqual}, 
        {"==", (char)15, (char)1, & EqualTo}, 
        {">", (char)16, (char)1, & GreaterThan}, 
        {">=", (char)16, (char)1, & GreaterOrEqual}, 
        {"||", (char)12, (char)1, & LogOR}};
#line 69 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/expr.c"
Operator UnOp[2]  = {      {"!", (char)22, (char)0, & LogNot}, 
        {"-", (char)22, (char)0, & UnMinus}};
#line 77 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/expr.c"
Operator OpStack[100]  ;
#line 78 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/expr.c"
Value ValStack[500]  ;
#line 79 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/expr.c"
int OpStackPtr  ;
#line 79 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/expr.c"
int ValStackPtr  ;
#line 88 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/expr.c"
static int DebugPerform(Operator *op ) 
{ 
  int r ;

  {
#line 92
  if ((int )op->type == 0) {
    {
#line 93
    fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"%s ",
            op->name);
#line 94
    PrintValue(& ValStack[ValStackPtr - 1], ErrFp);
    }
  } else {
    {
#line 96
    PrintValue(& ValStack[ValStackPtr - 2], ErrFp);
#line 97
    fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)" %s ",
            op->name);
#line 98
    PrintValue(& ValStack[ValStackPtr - 1], ErrFp);
    }
  }
  {
#line 101
  r = (*(op->func))();
#line 102
  fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)" => ");
  }
#line 103
  if (! r) {
    {
#line 104
    PrintValue(& ValStack[ValStackPtr - 1], ErrFp);
#line 105
    _IO_putc('\n', ErrFp);
    }
  } else {
    {
#line 107
    fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"%s\n",
            ErrMsg[r]);
    }
  }
#line 109
  return (r);
}
}
#line 119 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/expr.c"
static void CleanStack(void) 
{ 
  int i ;

  {
#line 123
  i = 0;
  {
#line 123
  while (1) {
    while_continue: /* CIL Label */ ;
#line 123
    if (! (i < ValStackPtr)) {
#line 123
      goto while_break;
    }
#line 123
    if ((int )ValStack[i].type == 4) {
#line 123
      if (ValStack[i].v.str) {
        {
#line 123
        free((void *)ValStack[i].v.str);
#line 123
        ValStack[i].type = (char)0;
        }
      }
    }
#line 123
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 124
  ValStackPtr = 0;
#line 125
  return;
}
}
#line 132 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/expr.c"
static char PeekChar(char const   **s ) 
{ 
  char const   *t ;
  unsigned short const   **tmp ;

  {
#line 134
  t = *s;
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 135
    if (*t) {
      {
#line 135
      tmp = __ctype_b_loc();
      }
#line 135
      if (! ((int const   )*(*tmp + (int )*t) & 8192)) {
#line 135
        if (! ((int const   )*t == 92)) {
#line 135
          goto while_break;
        }
      }
    } else {
#line 135
      goto while_break;
    }
#line 135
    t ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 136
  return ((char )*t);
}
}
#line 146 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/expr.c"
static int ParseExprToken(DynamicBuffer *buf___1 , char const   **in ) 
{ 
  char c ;
  unsigned short const   **tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int r ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  char const   *tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  char const   *tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  unsigned short const   **tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  unsigned short const   **tmp___38 ;
  unsigned short const   **tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;

  {
  {
#line 151
  DBufFree(buf___1);
  }
  {
#line 153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 153
    if (*(*in)) {
      {
#line 153
      tmp = __ctype_b_loc();
      }
#line 153
      if (! ((int const   )*(*tmp + (int )*(*in)) & 8192)) {
#line 153
        if (! ((int const   )*(*in) == 92)) {
#line 153
          goto while_break;
        }
      }
    } else {
#line 153
      goto while_break;
    }
#line 153
    (*in) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 155
  if (! *(*in)) {
#line 155
    return (0);
  }
#line 157
  tmp___0 = *in;
#line 157
  (*in) ++;
#line 157
  c = (char )*tmp___0;
#line 158
  if (buf___1->allocatedLen < buf___1->len + 1) {
#line 158
    tmp___1 = buf___1->len;
#line 158
    (buf___1->len) ++;
#line 158
    *(buf___1->buffer + tmp___1) = c;
#line 158
    *(buf___1->buffer + buf___1->len) = (char)0;
#line 158
    tmp___3 = 0;
  } else {
    {
#line 158
    tmp___2 = DBufPutcFN(buf___1, c);
#line 158
    tmp___3 = tmp___2 != 0;
    }
  }
#line 158
  if (tmp___3) {
    {
#line 159
    DBufFree(buf___1);
    }
#line 160
    return (9);
  }
  {
#line 172
  if ((int )c == 37) {
#line 172
    goto case_37;
  }
#line 172
  if ((int )c == 41) {
#line 172
    goto case_37;
  }
#line 172
  if ((int )c == 40) {
#line 172
    goto case_37;
  }
#line 172
  if ((int )c == 47) {
#line 172
    goto case_37;
  }
#line 172
  if ((int )c == 42) {
#line 172
    goto case_37;
  }
#line 172
  if ((int )c == 45) {
#line 172
    goto case_37;
  }
#line 172
  if ((int )c == 43) {
#line 172
    goto case_37;
  }
#line 172
  if ((int )c == 93) {
#line 172
    goto case_37;
  }
#line 172
  if ((int )c == 44) {
#line 172
    goto case_37;
  }
#line 176
  if ((int )c == 61) {
#line 176
    goto case_61;
  }
#line 176
  if ((int )c == 124) {
#line 176
    goto case_61;
  }
#line 176
  if ((int )c == 38) {
#line 176
    goto case_61;
  }
#line 188
  if ((int )c == 60) {
#line 188
    goto case_60;
  }
#line 188
  if ((int )c == 62) {
#line 188
    goto case_60;
  }
#line 188
  if ((int )c == 33) {
#line 188
    goto case_60;
  }
#line 163
  goto switch_break;
  case_37: /* CIL Label */ 
  case_41: /* CIL Label */ 
  case_40: /* CIL Label */ 
  case_47: /* CIL Label */ 
  case_42: /* CIL Label */ 
  case_45: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_93: /* CIL Label */ 
  case_44: /* CIL Label */ 
#line 172
  return (0);
  case_61: /* CIL Label */ 
  case_124: /* CIL Label */ 
  case_38: /* CIL Label */ 
#line 177
  if ((int const   )*(*in) == (int const   )c) {
#line 178
    if (buf___1->allocatedLen < buf___1->len + 1) {
#line 178
      tmp___4 = buf___1->len;
#line 178
      (buf___1->len) ++;
#line 178
      *(buf___1->buffer + tmp___4) = c;
#line 178
      *(buf___1->buffer + buf___1->len) = (char)0;
#line 178
      tmp___6 = 0;
    } else {
      {
#line 178
      tmp___5 = DBufPutcFN(buf___1, c);
#line 178
      tmp___6 = tmp___5 != 0;
      }
    }
#line 178
    if (tmp___6) {
      {
#line 179
      DBufFree(buf___1);
      }
#line 180
      return (9);
    }
#line 182
    (*in) ++;
  }
#line 184
  return (0);
  case_60: /* CIL Label */ 
  case_62: /* CIL Label */ 
  case_33: /* CIL Label */ 
#line 189
  if ((int const   )*(*in) == 61) {
#line 190
    if (buf___1->allocatedLen < buf___1->len + 1) {
#line 190
      tmp___7 = buf___1->len;
#line 190
      (buf___1->len) ++;
#line 190
      *(buf___1->buffer + tmp___7) = (char )'=';
#line 190
      *(buf___1->buffer + buf___1->len) = (char)0;
#line 190
      tmp___9 = 0;
    } else {
      {
#line 190
      tmp___8 = DBufPutcFN(buf___1, (char )'=');
#line 190
      tmp___9 = tmp___8 != 0;
      }
    }
#line 190
    if (tmp___9) {
      {
#line 191
      DBufFree(buf___1);
      }
#line 192
      return (9);
    }
#line 194
    (*in) ++;
  }
#line 196
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 201
  if ((int )c == 34) {
#line 202
    if (! *(*in)) {
#line 202
      return (2);
    }
    {
#line 203
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 203
      if (! *(*in)) {
#line 203
        goto while_break___0;
      }
#line 205
      if ((int const   )*(*in) == 92) {
#line 207
        (*in) ++;
#line 208
        if (! *(*in)) {
          {
#line 209
          DBufFree(buf___1);
          }
#line 210
          return (2);
        }
        {
#line 213
        if ((int const   )*(*in) == 97) {
#line 213
          goto case_97;
        }
#line 216
        if ((int const   )*(*in) == 98) {
#line 216
          goto case_98;
        }
#line 219
        if ((int const   )*(*in) == 102) {
#line 219
          goto case_102;
        }
#line 222
        if ((int const   )*(*in) == 110) {
#line 222
          goto case_110;
        }
#line 225
        if ((int const   )*(*in) == 114) {
#line 225
          goto case_114;
        }
#line 228
        if ((int const   )*(*in) == 116) {
#line 228
          goto case_116;
        }
#line 231
        if ((int const   )*(*in) == 118) {
#line 231
          goto case_118;
        }
#line 234
        goto switch_default;
        case_97: /* CIL Label */ 
#line 214
        if (buf___1->allocatedLen < buf___1->len + 1) {
#line 214
          tmp___10 = buf___1->len;
#line 214
          (buf___1->len) ++;
#line 214
          *(buf___1->buffer + tmp___10) = (char )'\a';
#line 214
          *(buf___1->buffer + buf___1->len) = (char)0;
#line 214
          r = 0;
        } else {
          {
#line 214
          tmp___11 = DBufPutcFN(buf___1, (char )'\a');
#line 214
          r = tmp___11;
          }
        }
#line 215
        goto switch_break___0;
        case_98: /* CIL Label */ 
#line 217
        if (buf___1->allocatedLen < buf___1->len + 1) {
#line 217
          tmp___12 = buf___1->len;
#line 217
          (buf___1->len) ++;
#line 217
          *(buf___1->buffer + tmp___12) = (char )'\b';
#line 217
          *(buf___1->buffer + buf___1->len) = (char)0;
#line 217
          r = 0;
        } else {
          {
#line 217
          tmp___13 = DBufPutcFN(buf___1, (char )'\b');
#line 217
          r = tmp___13;
          }
        }
#line 218
        goto switch_break___0;
        case_102: /* CIL Label */ 
#line 220
        if (buf___1->allocatedLen < buf___1->len + 1) {
#line 220
          tmp___14 = buf___1->len;
#line 220
          (buf___1->len) ++;
#line 220
          *(buf___1->buffer + tmp___14) = (char )'\f';
#line 220
          *(buf___1->buffer + buf___1->len) = (char)0;
#line 220
          r = 0;
        } else {
          {
#line 220
          tmp___15 = DBufPutcFN(buf___1, (char )'\f');
#line 220
          r = tmp___15;
          }
        }
#line 221
        goto switch_break___0;
        case_110: /* CIL Label */ 
#line 223
        if (buf___1->allocatedLen < buf___1->len + 1) {
#line 223
          tmp___16 = buf___1->len;
#line 223
          (buf___1->len) ++;
#line 223
          *(buf___1->buffer + tmp___16) = (char )'\n';
#line 223
          *(buf___1->buffer + buf___1->len) = (char)0;
#line 223
          r = 0;
        } else {
          {
#line 223
          tmp___17 = DBufPutcFN(buf___1, (char )'\n');
#line 223
          r = tmp___17;
          }
        }
#line 224
        goto switch_break___0;
        case_114: /* CIL Label */ 
#line 226
        if (buf___1->allocatedLen < buf___1->len + 1) {
#line 226
          tmp___18 = buf___1->len;
#line 226
          (buf___1->len) ++;
#line 226
          *(buf___1->buffer + tmp___18) = (char )'\r';
#line 226
          *(buf___1->buffer + buf___1->len) = (char)0;
#line 226
          r = 0;
        } else {
          {
#line 226
          tmp___19 = DBufPutcFN(buf___1, (char )'\r');
#line 226
          r = tmp___19;
          }
        }
#line 227
        goto switch_break___0;
        case_116: /* CIL Label */ 
#line 229
        if (buf___1->allocatedLen < buf___1->len + 1) {
#line 229
          tmp___20 = buf___1->len;
#line 229
          (buf___1->len) ++;
#line 229
          *(buf___1->buffer + tmp___20) = (char )'\t';
#line 229
          *(buf___1->buffer + buf___1->len) = (char)0;
#line 229
          r = 0;
        } else {
          {
#line 229
          tmp___21 = DBufPutcFN(buf___1, (char )'\t');
#line 229
          r = tmp___21;
          }
        }
#line 230
        goto switch_break___0;
        case_118: /* CIL Label */ 
#line 232
        if (buf___1->allocatedLen < buf___1->len + 1) {
#line 232
          tmp___22 = buf___1->len;
#line 232
          (buf___1->len) ++;
#line 232
          *(buf___1->buffer + tmp___22) = (char )'\v';
#line 232
          *(buf___1->buffer + buf___1->len) = (char)0;
#line 232
          r = 0;
        } else {
          {
#line 232
          tmp___23 = DBufPutcFN(buf___1, (char )'\v');
#line 232
          r = tmp___23;
          }
        }
#line 233
        goto switch_break___0;
        switch_default: /* CIL Label */ 
#line 235
        if (buf___1->allocatedLen < buf___1->len + 1) {
#line 235
          tmp___24 = buf___1->len;
#line 235
          (buf___1->len) ++;
#line 235
          *(buf___1->buffer + tmp___24) = (char )*(*in);
#line 235
          *(buf___1->buffer + buf___1->len) = (char)0;
#line 235
          r = 0;
        } else {
          {
#line 235
          tmp___25 = DBufPutcFN(buf___1, (char )*(*in));
#line 235
          r = tmp___25;
          }
        }
        switch_break___0: /* CIL Label */ ;
        }
#line 237
        (*in) ++;
#line 238
        if (r != 0) {
          {
#line 239
          DBufFree(buf___1);
          }
#line 240
          return (9);
        }
#line 242
        goto while_continue___0;
      }
#line 244
      tmp___26 = *in;
#line 244
      (*in) ++;
#line 244
      c = (char )*tmp___26;
#line 245
      if (buf___1->allocatedLen < buf___1->len + 1) {
#line 245
        tmp___27 = buf___1->len;
#line 245
        (buf___1->len) ++;
#line 245
        *(buf___1->buffer + tmp___27) = c;
#line 245
        *(buf___1->buffer + buf___1->len) = (char)0;
#line 245
        tmp___29 = 0;
      } else {
        {
#line 245
        tmp___28 = DBufPutcFN(buf___1, c);
#line 245
        tmp___29 = tmp___28 != 0;
        }
      }
#line 245
      if (tmp___29) {
        {
#line 246
        DBufFree(buf___1);
        }
#line 247
        return (9);
      }
#line 249
      if ((int )c == 34) {
#line 249
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 251
    if ((int )c == 34) {
#line 251
      return (0);
    }
    {
#line 252
    DBufFree(buf___1);
    }
#line 253
    return (2);
  }
#line 257
  if ((int )c == 39) {
#line 258
    if (! *(*in)) {
#line 258
      return (2);
    }
    {
#line 259
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 259
      if (! *(*in)) {
#line 259
        goto while_break___1;
      }
#line 260
      tmp___30 = *in;
#line 260
      (*in) ++;
#line 260
      c = (char )*tmp___30;
#line 261
      if (buf___1->allocatedLen < buf___1->len + 1) {
#line 261
        tmp___31 = buf___1->len;
#line 261
        (buf___1->len) ++;
#line 261
        *(buf___1->buffer + tmp___31) = c;
#line 261
        *(buf___1->buffer + buf___1->len) = (char)0;
#line 261
        tmp___33 = 0;
      } else {
        {
#line 261
        tmp___32 = DBufPutcFN(buf___1, c);
#line 261
        tmp___33 = tmp___32 != 0;
        }
      }
#line 261
      if (tmp___33) {
        {
#line 262
        DBufFree(buf___1);
        }
#line 263
        return (9);
      }
#line 265
      if ((int )c == 39) {
#line 265
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 267
    if ((int )c == 39) {
#line 267
      return (0);
    }
    {
#line 268
    DBufFree(buf___1);
    }
#line 269
    return (2);
  }
  {
#line 272
  tmp___34 = __ctype_b_loc();
  }
#line 272
  if (! ((int const   )*(*tmp___34 + (int )c) & 8)) {
#line 272
    if (! ((int )c == 95)) {
#line 272
      if ((int )c != 36) {
        {
#line 273
        Eprint("%s `%c\'", ErrMsg[7], (int )c);
        }
#line 274
        return (7);
      }
    }
  }
  {
#line 278
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 278
    tmp___38 = __ctype_b_loc();
    }
#line 278
    if (! ((int const   )*(*tmp___38 + (int )*(*in)) & 8)) {
#line 278
      if (! ((int const   )*(*in) == 95)) {
#line 278
        if (! ((int const   )*(*in) == 58)) {
#line 278
          if (! ((int const   )*(*in) == 46)) {
#line 278
            if (! ((int const   )*(*in) == (int const   )TimeSep)) {
#line 278
              goto while_break___2;
            }
          }
        }
      }
    }
#line 279
    if (buf___1->allocatedLen < buf___1->len + 1) {
#line 279
      tmp___35 = buf___1->len;
#line 279
      (buf___1->len) ++;
#line 279
      *(buf___1->buffer + tmp___35) = (char )*(*in);
#line 279
      *(buf___1->buffer + buf___1->len) = (char)0;
#line 279
      tmp___37 = 0;
    } else {
      {
#line 279
      tmp___36 = DBufPutcFN(buf___1, (char )*(*in));
#line 279
      tmp___37 = tmp___36 != 0;
      }
    }
#line 279
    if (tmp___37) {
      {
#line 280
      DBufFree(buf___1);
      }
#line 281
      return (9);
    }
#line 283
    (*in) ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 286
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 286
    if (*(*in)) {
      {
#line 286
      tmp___39 = __ctype_b_loc();
      }
#line 286
      if (! ((int const   )*(*tmp___39 + (int )*(*in)) & 8192)) {
#line 286
        if (! ((int const   )*(*in) == 92)) {
#line 286
          goto while_break___3;
        }
      }
    } else {
#line 286
      goto while_break___3;
    }
#line 286
    (*in) ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 289
  if ((int const   )*(*in) == 40) {
#line 290
    if (buf___1->allocatedLen < buf___1->len + 1) {
#line 290
      tmp___40 = buf___1->len;
#line 290
      (buf___1->len) ++;
#line 290
      *(buf___1->buffer + tmp___40) = (char )'(';
#line 290
      *(buf___1->buffer + buf___1->len) = (char)0;
#line 290
      tmp___42 = 0;
    } else {
      {
#line 290
      tmp___41 = DBufPutcFN(buf___1, (char )'(');
#line 290
      tmp___42 = tmp___41 != 0;
      }
    }
#line 290
    if (tmp___42) {
      {
#line 291
      DBufFree(buf___1);
      }
#line 292
      return (9);
    }
#line 294
    (*in) ++;
  }
#line 296
  return (0);
}
}
#line 306 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/expr.c"
int EvalExpr(char const   **e , Value *v , ParsePtr p ) 
{ 
  int r ;

  {
  {
#line 310
  OpStackPtr = 0;
#line 311
  ValStackPtr = 0;
#line 313
  r = Evaluate(e, (Var *)((void *)0), p);
  }
#line 316
  if (ExprBuf.len) {
#line 316
    (*e) --;
  }
  {
#line 317
  DBufFree(& ExprBuf);
  }
#line 319
  if (r) {
    {
#line 320
    CleanStack();
    }
#line 321
    return (r);
  }
#line 323
  *v = ValStack[0];
#line 324
  ValStack[0].type = (char)0;
#line 325
  return (r);
}
}
#line 329 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/expr.c"
int Evaluate(char const   **s , Var *locals , ParsePtr p ) 
{ 
  int OpBase ;
  int ValBase ;
  int r ;
  Operator *o ;
  BuiltinFunc *f ;
  int args ;
  Operator op ;
  Operator op2 ;
  Value va ;
  char const   *ufname ;
  char *tmp ;
  char tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  int tmp___4 ;

  {
#line 338
  ufname = (char const   *)((void *)0);
#line 340
  OpBase = OpStackPtr;
#line 341
  ValBase = ValStackPtr;
  {
#line 343
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 345
    r = ParseExprToken(& ExprBuf, s);
    }
#line 346
    if (r) {
#line 346
      return (r);
    }
#line 347
    if (! ExprBuf.len) {
      {
#line 348
      DBufFree(& ExprBuf);
      }
#line 349
      return (19);
    }
#line 352
    if ((int )*(ExprBuf.buffer) == 40) {
      {
#line 353
      DBufFree(& ExprBuf);
#line 354
      r = Evaluate(s, locals, p);
      }
#line 355
      if (r) {
#line 355
        return (r);
      }
#line 356
      r = 0;
#line 357
      if ((int )*(ExprBuf.buffer) != 41) {
        {
#line 358
        DBufFree(& ExprBuf);
        }
#line 359
        return (5);
      }
#line 361
      if (r) {
#line 361
        return (r);
      }
    } else
#line 362
    if ((int )*(ExprBuf.buffer) == 43) {
#line 363
      goto while_continue;
    } else
#line 365
    if ((int )*((ExprBuf.buffer + ExprBuf.len) - 1) == 40) {
      {
#line 366
      *((ExprBuf.buffer + ExprBuf.len) - 1) = (char)0;
#line 367
      f = FindFunc((char const   *)ExprBuf.buffer, Func, NumFuncs);
      }
#line 368
      if (! f) {
        {
#line 369
        tmp = StrDup((char const   *)ExprBuf.buffer);
#line 369
        ufname = (char const   *)tmp;
#line 370
        DBufFree(& ExprBuf);
        }
#line 371
        if (! ufname) {
#line 371
          return (9);
        }
      } else {
        {
#line 373
        DBufFree(& ExprBuf);
        }
      }
      {
#line 375
      args = 0;
#line 376
      tmp___0 = PeekChar(s);
      }
#line 376
      if ((int )tmp___0 == 41) {
#line 377
        if (f) {
#line 378
          if (! f->is_constant) {
#line 378
            if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 378
              p->nonconst_expr = (char)1;
            }
          }
          {
#line 379
          r = CallFunc(f, 0);
          }
        } else {
          {
#line 381
          r = CallUserFunc(ufname, 0, p);
#line 382
          free((void *)((char *)ufname));
          }
        }
#line 384
        if (r) {
#line 384
          return (r);
        }
        {
#line 385
        r = ParseExprToken(& ExprBuf, s);
        }
#line 386
        if (r) {
#line 386
          return (r);
        }
      } else {
        {
#line 388
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 389
          args ++;
#line 390
          r = Evaluate(s, locals, p);
          }
#line 391
          if (r) {
#line 392
            if (! f) {
              {
#line 392
              free((void *)((char *)ufname));
              }
            }
#line 393
            return (r);
          }
#line 395
          if ((int )*(ExprBuf.buffer) == 41) {
#line 395
            goto while_break___0;
          } else
#line 396
          if ((int )*(ExprBuf.buffer) != 44) {
#line 397
            if (! f) {
              {
#line 397
              free((void *)((char *)ufname));
              }
            }
            {
#line 398
            Eprint("%s: `%c\'", ErrMsg[63], (int )*(ExprBuf.buffer));
#line 400
            DBufFree(& ExprBuf);
            }
#line 401
            return (63);
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 404
        if (f) {
#line 405
          if (! f->is_constant) {
#line 405
            if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 405
              p->nonconst_expr = (char)1;
            }
          }
          {
#line 406
          r = CallFunc(f, args);
          }
        } else {
          {
#line 408
          r = CallUserFunc(ufname, args, p);
#line 409
          free((void *)((char *)ufname));
          }
        }
        {
#line 411
        DBufFree(& ExprBuf);
        }
#line 412
        if (r) {
#line 412
          return (r);
        }
      }
    } else {
      {
#line 415
      o = FindOperator((char const   *)ExprBuf.buffer, UnOp, (int )(sizeof(UnOp) / sizeof(Operator )));
      }
#line 416
      if (o) {
        {
#line 417
        DBufFree(& ExprBuf);
        }
#line 418
        if (OpStackPtr >= 100) {
#line 418
          return (3);
        } else {
#line 418
          tmp___1 = OpStackPtr;
#line 418
          OpStackPtr ++;
#line 418
          OpStack[tmp___1] = *o;
        }
#line 419
        goto while_continue;
      } else {
        {
#line 420
        tmp___3 = __ctype_b_loc();
        }
#line 420
        if ((int const   )*(*tmp___3 + (int )*(ExprBuf.buffer)) & 8) {
#line 420
          goto _L___2;
        } else
#line 420
        if ((int )*(ExprBuf.buffer) == 95) {
          _L___2: /* CIL Label */ 
          {
#line 429
          r = MakeValue((char const   *)ExprBuf.buffer, & va, locals, p);
#line 430
          DBufFree(& ExprBuf);
          }
#line 431
          if (r) {
#line 431
            return (r);
          }
#line 432
          if (ValStackPtr >= 500) {
#line 432
            return (4);
          } else {
#line 432
            tmp___2 = ValStackPtr;
#line 432
            ValStackPtr ++;
#line 432
            ValStack[tmp___2] = va;
          }
        } else
#line 420
        if ((int )*(ExprBuf.buffer) != 36) {
#line 420
          if ((int )*(ExprBuf.buffer) != 34) {
#line 420
            if ((int )*(ExprBuf.buffer) != 39) {
              {
#line 424
              Eprint("%s `%c\'", ErrMsg[7], (int )*(ExprBuf.buffer));
#line 426
              DBufFree(& ExprBuf);
              }
#line 427
              return (7);
            } else {
#line 420
              goto _L___2;
            }
          } else {
#line 420
            goto _L___2;
          }
        } else {
#line 420
          goto _L___2;
        }
      }
    }
    {
#line 437
    r = ParseExprToken(& ExprBuf, s);
    }
#line 438
    if (r) {
#line 438
      return (r);
    }
#line 439
    if ((int )*(ExprBuf.buffer) == 0) {
#line 439
      goto _L___3;
    } else
#line 439
    if ((int )*(ExprBuf.buffer) == 44) {
#line 439
      goto _L___3;
    } else
#line 439
    if ((int )*(ExprBuf.buffer) == 93) {
#line 439
      goto _L___3;
    } else
#line 439
    if ((int )*(ExprBuf.buffer) == 41) {
      _L___3: /* CIL Label */ 
      {
#line 445
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 445
        if (! (OpStackPtr > OpBase)) {
#line 445
          goto while_break___1;
        }
#line 446
        if (OpStackPtr <= 0) {
#line 446
          return (11);
        } else {
#line 446
          OpStackPtr --;
#line 446
          op = OpStack[OpStackPtr];
        }
#line 447
        if (DebugFlag & 2) {
          {
#line 448
          r = DebugPerform(& op);
          }
        } else {
          {
#line 450
          r = (*(op.func))();
          }
        }
#line 451
        if (r) {
          {
#line 452
          DBufFree(& ExprBuf);
#line 453
          Eprint("`%s\': %s", op.name, ErrMsg[r]);
          }
#line 454
          return (r);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 457
      if (ValStackPtr != ValBase + 1) {
        {
#line 458
        DBufFree(& ExprBuf);
        }
#line 459
        return (16);
      }
#line 461
      return (0);
    }
    {
#line 464
    o = FindOperator((char const   *)ExprBuf.buffer, BinOp, (int )(sizeof(BinOp) / sizeof(Operator )));
#line 465
    DBufFree(& ExprBuf);
    }
#line 466
    if (! o) {
#line 466
      return (8);
    }
    {
#line 470
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 470
      if (OpStackPtr > OpBase) {
#line 470
        if (! ((int )OpStack[OpStackPtr - 1].prec >= (int )o->prec)) {
#line 470
          goto while_break___2;
        }
      } else {
#line 470
        goto while_break___2;
      }
#line 471
      if (OpStackPtr <= 0) {
#line 471
        return (11);
      } else {
#line 471
        OpStackPtr --;
#line 471
        op2 = OpStack[OpStackPtr];
      }
#line 472
      if (r) {
#line 472
        return (r);
      }
#line 473
      if (DebugFlag & 2) {
        {
#line 474
        r = DebugPerform(& op2);
        }
      } else {
        {
#line 476
        r = (*(op2.func))();
        }
      }
#line 477
      if (r) {
        {
#line 478
        Eprint("`%s\': %s", op2.name, ErrMsg[r]);
        }
#line 479
        return (r);
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 482
    if (OpStackPtr >= 100) {
#line 482
      return (3);
    } else {
#line 482
      tmp___4 = OpStackPtr;
#line 482
      OpStackPtr ++;
#line 482
      OpStack[tmp___4] = *o;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 493 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/expr.c"
static int MakeValue(char const   *s , Value *v , Var *locals , ParsePtr p ) 
{ 
  int len ;
  int h ;
  int m ;
  int r ;
  size_t tmp ;
  void *tmp___0 ;
  char const   *tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;

  {
#line 498
  if ((int const   )*s == 34) {
    {
#line 499
    tmp = strlen(s);
#line 499
    len = (int )(tmp - 1UL);
#line 500
    v->type = (char)4;
#line 501
    tmp___0 = malloc((size_t )len);
#line 501
    v->v.str = (char *)tmp___0;
    }
#line 502
    if (! v->v.str) {
#line 503
      v->type = (char)0;
#line 504
      return (9);
    }
    {
#line 506
    strncpy((char */* __restrict  */)v->v.str, (char const   */* __restrict  */)(s + 1),
            (size_t )(len - 1));
#line 507
    *((v->v.str + len) - 1) = (char)0;
    }
#line 508
    return (0);
  } else
#line 509
  if ((int const   )*s == 39) {
    {
#line 510
    s ++;
#line 511
    r = ParseLiteralDate(& s, & h, & m);
    }
#line 511
    if (r) {
#line 511
      return (r);
    }
#line 512
    if ((int const   )*s != 39) {
#line 512
      return (24);
    }
#line 513
    if (m == 2147483647) {
#line 514
      v->type = (char)3;
#line 515
      v->v.val = h;
    } else {
#line 517
      v->type = (char)5;
#line 518
      v->v.val = h * 1440 + m;
    }
#line 520
    return (0);
  } else {
    {
#line 521
    tmp___5 = __ctype_b_loc();
    }
#line 521
    if ((int const   )*(*tmp___5 + (int )*s) & 2048) {
#line 522
      len = 0;
      {
#line 523
      while (1) {
        while_continue: /* CIL Label */ ;
#line 523
        if (*s) {
          {
#line 523
          tmp___2 = __ctype_b_loc();
          }
#line 523
          if (! ((int const   )*(*tmp___2 + (int )*s) & 2048)) {
#line 523
            goto while_break;
          }
        } else {
#line 523
          goto while_break;
        }
#line 524
        len *= 10;
#line 525
        tmp___1 = s;
#line 525
        s ++;
#line 525
        len += (int )((int const   )*tmp___1 - 48);
      }
      while_break: /* CIL Label */ ;
      }
#line 527
      if ((int const   )*s == 58) {
#line 527
        goto _L;
      } else
#line 527
      if ((int const   )*s == 46) {
#line 527
        goto _L;
      } else
#line 527
      if ((int const   )*s == (int const   )TimeSep) {
        _L: /* CIL Label */ 
        {
#line 528
        s ++;
#line 529
        tmp___3 = __ctype_b_loc();
        }
#line 529
        if (! ((int const   )*(*tmp___3 + (int )*s) & 2048)) {
#line 529
          return (27);
        }
#line 530
        h = len;
#line 531
        m = 0;
        {
#line 532
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 532
          tmp___4 = __ctype_b_loc();
          }
#line 532
          if (! ((int const   )*(*tmp___4 + (int )*s) & 2048)) {
#line 532
            goto while_break___0;
          }
#line 533
          m *= 10;
#line 534
          m += (int )((int const   )*s - 48);
#line 535
          s ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 537
        if (*s) {
#line 537
          return (27);
        } else
#line 537
        if (h > 23) {
#line 537
          return (27);
        } else
#line 537
        if (m > 59) {
#line 537
          return (27);
        }
#line 538
        v->type = (char)2;
#line 539
        v->v.val = h * 60 + m;
#line 540
        return (0);
      }
#line 543
      if (*s) {
#line 543
        return (10);
      }
#line 544
      v->type = (char)1;
#line 545
      v->v.val = len;
#line 546
      return (0);
    } else
#line 547
    if ((int const   )*s == 36) {
#line 548
      if (p) {
#line 548
        p->nonconst_expr = (char)1;
      }
#line 549
      if (DebugFlag & 2) {
        {
#line 550
        fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"%s => ",
                s);
        }
      }
      {
#line 551
      r = GetSysVar(s + 1, v);
      }
#line 553
      if (! (DebugFlag & 2)) {
#line 553
        return (r);
      }
#line 554
      if (r == 0) {
        {
#line 555
        PrintValue(v, ErrFp);
#line 556
        _IO_putc('\n', ErrFp);
        }
      }
#line 558
      return (r);
    } else
#line 560
    if (DebugFlag & 2) {
      {
#line 561
      fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"%s => ",
              s);
      }
    }
  }
  {
#line 563
  r = GetVarValue(s, v, locals, p);
  }
#line 564
  if (! (DebugFlag & 2)) {
#line 564
    return (r);
  }
#line 565
  if (r == 0) {
    {
#line 566
    PrintValue(v, ErrFp);
#line 567
    _IO_putc('\n', ErrFp);
    }
  }
#line 569
  return (r);
}
}
#line 577 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/expr.c"
int DoCoerce(char type , Value *v ) 
{ 
  int h ;
  int d ;
  int m ;
  int y ;
  int i ;
  int k ;
  char const   *s ;
  int tmp ;
  char const   *tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  char const   *tmp___4 ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  char const   *tmp___7 ;
  unsigned short const   **tmp___8 ;

  {
#line 583
  if ((int )type == (int )v->type) {
#line 583
    return (0);
  }
  {
#line 586
  if ((int )type == 5) {
#line 586
    goto case_5;
  }
#line 607
  if ((int )type == 4) {
#line 607
    goto case_4___0;
  }
#line 636
  if ((int )type == 1) {
#line 636
    goto case_1___1;
  }
#line 669
  if ((int )type == 3) {
#line 669
    goto case_3___2;
  }
#line 694
  if ((int )type == 2) {
#line 694
    goto case_2___1;
  }
#line 728
  goto switch_default___4;
  case_5: /* CIL Label */ 
  {
#line 588
  if ((int )v->type == 1) {
#line 588
    goto case_1;
  }
#line 591
  if ((int )v->type == 3) {
#line 591
    goto case_3;
  }
#line 595
  if ((int )v->type == 4) {
#line 595
    goto case_4;
  }
#line 604
  goto switch_default;
  case_1: /* CIL Label */ 
#line 589
  v->type = (char)5;
#line 590
  return (0);
  case_3: /* CIL Label */ 
#line 592
  v->type = (char)5;
#line 593
  v->v.val *= 1440;
#line 594
  return (0);
  case_4: /* CIL Label */ 
  {
#line 596
  s = (char const   *)v->v.str;
#line 597
  tmp = ParseLiteralDate(& s, & i, & m);
  }
#line 597
  if (tmp) {
#line 597
    return (13);
  }
#line 598
  if (*s) {
#line 598
    return (13);
  }
  {
#line 599
  v->type = (char)5;
#line 600
  free((void *)v->v.str);
  }
#line 601
  if (m == 2147483647) {
#line 601
    m = 0;
  }
#line 602
  v->v.val = i * 1440 + m;
#line 603
  return (0);
  switch_default: /* CIL Label */ 
#line 605
  return (13);
  switch_break___0: /* CIL Label */ ;
  }
  case_4___0: /* CIL Label */ 
  {
#line 609
  if ((int )v->type == 1) {
#line 609
    goto case_1___0;
  }
#line 610
  if ((int )v->type == 2) {
#line 610
    goto case_2;
  }
#line 613
  if ((int )v->type == 3) {
#line 613
    goto case_3___0;
  }
#line 617
  if ((int )v->type == 5) {
#line 617
    goto case_5___0;
  }
#line 626
  goto switch_default___0;
  case_1___0: /* CIL Label */ 
  {
#line 609
  sprintf((char */* __restrict  */)(CoerceBuf), (char const   */* __restrict  */)"%d",
          v->v.val);
  }
#line 609
  goto switch_break___1;
  case_2: /* CIL Label */ 
  {
#line 610
  sprintf((char */* __restrict  */)(CoerceBuf), (char const   */* __restrict  */)"%02d%c%02d",
          v->v.val / 60, (int )TimeSep, v->v.val % 60);
  }
#line 612
  goto switch_break___1;
  case_3___0: /* CIL Label */ 
  {
#line 613
  FromJulian(v->v.val, & y, & m, & d);
#line 614
  sprintf((char */* __restrict  */)(CoerceBuf), (char const   */* __restrict  */)"%04d%c%02d%c%02d",
          y, (int )DateSep, m + 1, (int )DateSep, d);
  }
#line 616
  goto switch_break___1;
  case_5___0: /* CIL Label */ 
  {
#line 618
  i = v->v.val / 1440;
#line 619
  FromJulian(i, & y, & m, & d);
#line 620
  k = v->v.val % 1440;
#line 621
  h = k / 60;
#line 622
  i = k % 60;
#line 623
  sprintf((char */* __restrict  */)(CoerceBuf), (char const   */* __restrict  */)"%04d%c%02d%c%02d@%02d%c%02d",
          y, (int )DateSep, m + 1, (int )DateSep, d, h, (int )TimeSep, i);
  }
#line 625
  goto switch_break___1;
  switch_default___0: /* CIL Label */ 
#line 626
  return (13);
  switch_break___1: /* CIL Label */ ;
  }
  {
#line 628
  v->type = (char)4;
#line 629
  v->v.str = StrDup((char const   *)(CoerceBuf));
  }
#line 630
  if (! v->v.str) {
#line 631
    v->type = (char)0;
#line 632
    return (9);
  }
#line 634
  return (0);
  case_1___1: /* CIL Label */ 
#line 637
  i = 0;
#line 638
  m = 1;
  {
#line 640
  if ((int )v->type == 4) {
#line 640
    goto case_4___1;
  }
#line 662
  if ((int )v->type == 5) {
#line 662
    goto case_5___1;
  }
#line 662
  if ((int )v->type == 2) {
#line 662
    goto case_5___1;
  }
#line 662
  if ((int )v->type == 3) {
#line 662
    goto case_5___1;
  }
#line 666
  goto switch_default___1;
  case_4___1: /* CIL Label */ 
#line 641
  s = (char const   *)v->v.str;
#line 642
  if ((int const   )*s == 45) {
#line 643
    m = -1;
#line 644
    s ++;
  }
  {
#line 646
  while (1) {
    while_continue: /* CIL Label */ ;
#line 646
    if (*s) {
      {
#line 646
      tmp___1 = __ctype_b_loc();
      }
#line 646
      if (! ((int const   )*(*tmp___1 + (int )*s) & 2048)) {
#line 646
        goto while_break;
      }
    } else {
#line 646
      goto while_break;
    }
#line 647
    i *= 10;
#line 648
    tmp___0 = s;
#line 648
    s ++;
#line 648
    i += (int )((int const   )*tmp___0 - 48);
  }
  while_break: /* CIL Label */ ;
  }
#line 650
  if (*s) {
    {
#line 651
    free((void *)v->v.str);
#line 652
    v->type = (char)0;
    }
#line 653
    return (13);
  }
  {
#line 655
  free((void *)v->v.str);
#line 656
  v->type = (char)1;
#line 657
  v->v.val = i * m;
  }
#line 658
  return (0);
  case_5___1: /* CIL Label */ 
  case_2___0: /* CIL Label */ 
  case_3___1: /* CIL Label */ 
#line 663
  v->type = (char)1;
#line 664
  return (0);
  switch_default___1: /* CIL Label */ 
#line 666
  return (13);
  switch_break___2: /* CIL Label */ ;
  }
  case_3___2: /* CIL Label */ 
  {
#line 671
  if ((int )v->type == 1) {
#line 671
    goto case_1___2;
  }
#line 677
  if ((int )v->type == 4) {
#line 677
    goto case_4___2;
  }
#line 686
  if ((int )v->type == 5) {
#line 686
    goto case_5___2;
  }
#line 691
  goto switch_default___2;
  case_1___2: /* CIL Label */ 
#line 672
  if (v->v.val >= 0) {
#line 673
    v->type = (char)3;
#line 674
    return (0);
  } else {
#line 675
    return (29);
  }
  case_4___2: /* CIL Label */ 
  {
#line 678
  s = (char const   *)v->v.str;
#line 679
  tmp___2 = ParseLiteralDate(& s, & i, & m);
  }
#line 679
  if (tmp___2) {
#line 679
    return (13);
  }
#line 680
  if (*s) {
#line 680
    return (13);
  }
  {
#line 681
  v->type = (char)3;
#line 682
  free((void *)v->v.str);
#line 683
  v->v.val = i;
  }
#line 684
  return (0);
  case_5___2: /* CIL Label */ 
#line 687
  v->type = (char)3;
#line 688
  v->v.val /= 1440;
#line 689
  return (0);
  switch_default___2: /* CIL Label */ 
#line 691
  return (13);
  switch_break___3: /* CIL Label */ ;
  }
  case_2___1: /* CIL Label */ 
  {
#line 697
  if ((int )v->type == 5) {
#line 697
    goto case_5___3;
  }
#line 697
  if ((int )v->type == 1) {
#line 697
    goto case_5___3;
  }
#line 703
  if ((int )v->type == 4) {
#line 703
    goto case_4___3;
  }
#line 726
  goto switch_default___3;
  case_5___3: /* CIL Label */ 
  case_1___3: /* CIL Label */ 
#line 698
  v->type = (char)2;
#line 699
  v->v.val %= 1440;
#line 700
  if (v->v.val < 0) {
#line 700
    v->v.val += 1440;
  }
#line 701
  return (0);
  case_4___3: /* CIL Label */ 
  {
#line 704
  h = 0;
#line 705
  m = 0;
#line 706
  s = (char const   *)v->v.str;
#line 707
  tmp___3 = __ctype_b_loc();
  }
#line 707
  if (! ((int const   )*(*tmp___3 + (int )*s) & 2048)) {
#line 707
    return (13);
  }
  {
#line 708
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 708
    tmp___5 = __ctype_b_loc();
    }
#line 708
    if (! ((int const   )*(*tmp___5 + (int )*s) & 2048)) {
#line 708
      goto while_break___0;
    }
#line 709
    h *= 10;
#line 710
    tmp___4 = s;
#line 710
    s ++;
#line 710
    h += (int )((int const   )*tmp___4 - 48);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 712
  if ((int const   )*s != 58) {
#line 712
    if ((int const   )*s != 46) {
#line 712
      if ((int const   )*s != (int const   )TimeSep) {
#line 713
        return (13);
      }
    }
  }
  {
#line 714
  s ++;
#line 715
  tmp___6 = __ctype_b_loc();
  }
#line 715
  if (! ((int const   )*(*tmp___6 + (int )*s) & 2048)) {
#line 715
    return (13);
  }
  {
#line 716
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 716
    tmp___8 = __ctype_b_loc();
    }
#line 716
    if (! ((int const   )*(*tmp___8 + (int )*s) & 2048)) {
#line 716
      goto while_break___1;
    }
#line 717
    m *= 10;
#line 718
    tmp___7 = s;
#line 718
    s ++;
#line 718
    m += (int )((int const   )*tmp___7 - 48);
  }
  while_break___1: /* CIL Label */ ;
  }
#line 720
  if (*s) {
#line 720
    return (13);
  } else
#line 720
  if (h > 23) {
#line 720
    return (13);
  } else
#line 720
  if (m > 59) {
#line 720
    return (13);
  }
  {
#line 721
  v->type = (char)2;
#line 722
  free((void *)v->v.str);
#line 723
  v->v.val = h * 60 + m;
  }
#line 724
  return (0);
  switch_default___3: /* CIL Label */ 
#line 726
  return (13);
  switch_break___4: /* CIL Label */ ;
  }
  switch_default___4: /* CIL Label */ 
#line 728
  return (13);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 739 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/expr.c"
static int Add(void) 
{ 
  Value v1 ;
  Value v2 ;
  Value v3 ;
  int r ;
  size_t l1 ;
  size_t l2 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;

  {
#line 746
  if (ValStackPtr <= 0) {
#line 746
    return (12);
  } else {
#line 746
    ValStackPtr --;
#line 746
    v2 = ValStack[ValStackPtr];
  }
  {
#line 747
  r = FnPopValStack(& v1);
  }
#line 747
  if (r) {
#line 748
    if ((int )v2.type == 4) {
#line 748
      if (v2.v.str) {
        {
#line 748
        free((void *)v2.v.str);
#line 748
        v2.type = (char)0;
        }
      }
    }
#line 749
    return (r);
  }
#line 753
  if ((int )v2.type == 1) {
#line 753
    if ((int )v1.type == 1) {
#line 754
      v2.v.val += v1.v.val;
#line 755
      if (ValStackPtr >= 500) {
#line 755
        return (4);
      } else {
#line 755
        tmp = ValStackPtr;
#line 755
        ValStackPtr ++;
#line 755
        ValStack[tmp] = v2;
      }
#line 756
      return (0);
    }
  }
#line 760
  if ((int )v1.type == 3) {
#line 760
    if ((int )v2.type == 1) {
#line 760
      goto _L;
    } else {
#line 760
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 760
  if ((int )v1.type == 1) {
#line 760
    if ((int )v2.type == 3) {
      _L: /* CIL Label */ 
#line 762
      v1.v.val += v2.v.val;
#line 763
      if (v1.v.val < 0) {
#line 763
        return (15);
      }
#line 764
      v1.type = (char)3;
#line 765
      if (ValStackPtr >= 500) {
#line 765
        return (4);
      } else {
#line 765
        tmp___0 = ValStackPtr;
#line 765
        ValStackPtr ++;
#line 765
        ValStack[tmp___0] = v1;
      }
#line 766
      return (0);
    }
  }
#line 770
  if ((int )v1.type == 5) {
#line 770
    if ((int )v2.type == 1) {
#line 770
      goto _L___1;
    } else {
#line 770
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 770
  if ((int )v1.type == 1) {
#line 770
    if ((int )v2.type == 5) {
      _L___1: /* CIL Label */ 
#line 772
      v1.v.val += v2.v.val;
#line 773
      if (v1.v.val < 0) {
#line 773
        return (15);
      }
#line 774
      v1.type = (char)5;
#line 775
      if (ValStackPtr >= 500) {
#line 775
        return (4);
      } else {
#line 775
        tmp___1 = ValStackPtr;
#line 775
        ValStackPtr ++;
#line 775
        ValStack[tmp___1] = v1;
      }
#line 776
      return (0);
    }
  }
#line 780
  if ((int )v1.type == 2) {
#line 780
    if ((int )v2.type == 1) {
#line 780
      goto _L___3;
    } else {
#line 780
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
#line 780
  if ((int )v1.type == 1) {
#line 780
    if ((int )v2.type == 2) {
      _L___3: /* CIL Label */ 
#line 782
      v1.v.val = (v1.v.val + v2.v.val) % 1440;
#line 783
      if (v1.v.val < 0) {
#line 783
        v1.v.val += 1440;
      }
#line 784
      v1.type = (char)2;
#line 785
      if (ValStackPtr >= 500) {
#line 785
        return (4);
      } else {
#line 785
        tmp___2 = ValStackPtr;
#line 785
        ValStackPtr ++;
#line 785
        ValStack[tmp___2] = v1;
      }
#line 786
      return (0);
    }
  }
#line 790
  if ((int )v1.type == 4) {
#line 790
    goto _L___5;
  } else
#line 790
  if ((int )v2.type == 4) {
    _L___5: /* CIL Label */ 
    {
#line 791
    r = DoCoerce((char)4, & v1);
    }
#line 791
    if (r) {
#line 792
      if ((int )v1.type == 4) {
#line 792
        if (v1.v.str) {
          {
#line 792
          free((void *)v1.v.str);
#line 792
          v1.type = (char)0;
          }
        }
      }
#line 792
      if ((int )v2.type == 4) {
#line 792
        if (v2.v.str) {
          {
#line 792
          free((void *)v2.v.str);
#line 792
          v2.type = (char)0;
          }
        }
      }
#line 793
      return (r);
    }
    {
#line 795
    r = DoCoerce((char)4, & v2);
    }
#line 795
    if (r) {
#line 796
      if ((int )v1.type == 4) {
#line 796
        if (v1.v.str) {
          {
#line 796
          free((void *)v1.v.str);
#line 796
          v1.type = (char)0;
          }
        }
      }
#line 796
      if ((int )v2.type == 4) {
#line 796
        if (v2.v.str) {
          {
#line 796
          free((void *)v2.v.str);
#line 796
          v2.type = (char)0;
          }
        }
      }
#line 797
      return (r);
    }
    {
#line 799
    v3.type = (char)4;
#line 800
    l1 = strlen((char const   *)v1.v.str);
#line 801
    l2 = strlen((char const   *)v2.v.str);
    }
#line 802
    if (MaxStringLen) {
#line 802
      if (l1 + l2 > (size_t )MaxStringLen) {
#line 803
        if ((int )v1.type == 4) {
#line 803
          if (v1.v.str) {
            {
#line 803
            free((void *)v1.v.str);
#line 803
            v1.type = (char)0;
            }
          }
        }
#line 803
        if ((int )v2.type == 4) {
#line 803
          if (v2.v.str) {
            {
#line 803
            free((void *)v2.v.str);
#line 803
            v2.type = (char)0;
            }
          }
        }
#line 804
        return (101);
      }
    }
    {
#line 806
    tmp___3 = malloc((l1 + l2) + 1UL);
#line 806
    v3.v.str = (char *)tmp___3;
    }
#line 807
    if (! v3.v.str) {
#line 808
      if ((int )v1.type == 4) {
#line 808
        if (v1.v.str) {
          {
#line 808
          free((void *)v1.v.str);
#line 808
          v1.type = (char)0;
          }
        }
      }
#line 808
      if ((int )v2.type == 4) {
#line 808
        if (v2.v.str) {
          {
#line 808
          free((void *)v2.v.str);
#line 808
          v2.type = (char)0;
          }
        }
      }
#line 809
      return (9);
    }
    {
#line 811
    strcpy((char */* __restrict  */)v3.v.str, (char const   */* __restrict  */)v1.v.str);
#line 812
    strcat((char */* __restrict  */)v3.v.str, (char const   */* __restrict  */)v2.v.str);
    }
#line 813
    if ((int )v1.type == 4) {
#line 813
      if (v1.v.str) {
        {
#line 813
        free((void *)v1.v.str);
#line 813
        v1.type = (char)0;
        }
      }
    }
#line 813
    if ((int )v2.type == 4) {
#line 813
      if (v2.v.str) {
        {
#line 813
        free((void *)v2.v.str);
#line 813
        v2.type = (char)0;
        }
      }
    }
#line 814
    if (ValStackPtr >= 500) {
#line 814
      return (4);
    } else {
#line 814
      tmp___4 = ValStackPtr;
#line 814
      ValStackPtr ++;
#line 814
      ValStack[tmp___4] = v3;
    }
#line 815
    return (0);
  }
#line 819
  return (14);
}
}
#line 829 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/expr.c"
static int Subtract(void) 
{ 
  Value v1 ;
  Value v2 ;
  int r ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 834
  if (ValStackPtr <= 0) {
#line 834
    return (12);
  } else {
#line 834
    ValStackPtr --;
#line 834
    v2 = ValStack[ValStackPtr];
  }
  {
#line 835
  r = FnPopValStack(& v1);
  }
#line 835
  if (r) {
#line 836
    if ((int )v2.type == 4) {
#line 836
      if (v2.v.str) {
        {
#line 836
        free((void *)v2.v.str);
#line 836
        v2.type = (char)0;
        }
      }
    }
#line 837
    return (r);
  }
#line 841
  if ((int )v1.type == 1) {
#line 841
    if ((int )v2.type == 1) {
#line 842
      v1.v.val -= v2.v.val;
#line 843
      if (ValStackPtr >= 500) {
#line 843
        return (4);
      } else {
#line 843
        tmp = ValStackPtr;
#line 843
        ValStackPtr ++;
#line 843
        ValStack[tmp] = v1;
      }
#line 844
      return (0);
    }
  }
#line 848
  if ((int )v1.type == 3) {
#line 848
    if ((int )v2.type == 1) {
#line 849
      v1.v.val -= v2.v.val;
#line 850
      if (v1.v.val < 0) {
#line 850
        return (15);
      }
#line 851
      if (ValStackPtr >= 500) {
#line 851
        return (4);
      } else {
#line 851
        tmp___0 = ValStackPtr;
#line 851
        ValStackPtr ++;
#line 851
        ValStack[tmp___0] = v1;
      }
#line 852
      return (0);
    }
  }
#line 856
  if ((int )v1.type == 5) {
#line 856
    if ((int )v2.type == 1) {
#line 857
      v1.v.val -= v2.v.val;
#line 858
      if (v1.v.val < 0) {
#line 858
        return (15);
      }
#line 859
      if (ValStackPtr >= 500) {
#line 859
        return (4);
      } else {
#line 859
        tmp___1 = ValStackPtr;
#line 859
        ValStackPtr ++;
#line 859
        ValStack[tmp___1] = v1;
      }
#line 860
      return (0);
    }
  }
#line 864
  if ((int )v1.type == 2) {
#line 864
    if ((int )v2.type == 1) {
#line 865
      v1.v.val = (v1.v.val - v2.v.val) % 1440;
#line 866
      if (v1.v.val < 0) {
#line 866
        v1.v.val += 1440;
      }
#line 867
      if (ValStackPtr >= 500) {
#line 867
        return (4);
      } else {
#line 867
        tmp___2 = ValStackPtr;
#line 867
        ValStackPtr ++;
#line 867
        ValStack[tmp___2] = v1;
      }
#line 868
      return (0);
    }
  }
#line 872
  if ((int )v1.type == 2) {
#line 872
    if ((int )v2.type == 2) {
#line 872
      goto _L;
    } else {
#line 872
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 872
  if ((int )v1.type == 5) {
#line 872
    if ((int )v2.type == 5) {
#line 872
      goto _L;
    } else {
#line 872
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 872
  if ((int )v1.type == 3) {
#line 872
    if ((int )v2.type == 3) {
      _L: /* CIL Label */ 
#line 875
      v1.v.val -= v2.v.val;
#line 876
      v1.type = (char)1;
#line 877
      if (ValStackPtr >= 500) {
#line 877
        return (4);
      } else {
#line 877
        tmp___3 = ValStackPtr;
#line 877
        ValStackPtr ++;
#line 877
        ValStack[tmp___3] = v1;
      }
#line 878
      return (0);
    }
  }
#line 882
  if ((int )v1.type == 4) {
#line 882
    if (v1.v.str) {
      {
#line 882
      free((void *)v1.v.str);
#line 882
      v1.type = (char)0;
      }
    }
  }
#line 882
  if ((int )v2.type == 4) {
#line 882
    if (v2.v.str) {
      {
#line 882
      free((void *)v2.v.str);
#line 882
      v2.type = (char)0;
      }
    }
  }
#line 883
  return (14);
}
}
#line 893 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/expr.c"
static int Multiply(void) 
{ 
  Value v1 ;
  Value v2 ;
  int r ;
  int tmp ;

  {
#line 898
  if (ValStackPtr <= 0) {
#line 898
    return (12);
  } else {
#line 898
    ValStackPtr --;
#line 898
    v2 = ValStack[ValStackPtr];
  }
  {
#line 899
  r = FnPopValStack(& v1);
  }
#line 899
  if (r) {
#line 900
    if ((int )v2.type == 4) {
#line 900
      if (v2.v.str) {
        {
#line 900
        free((void *)v2.v.str);
#line 900
        v2.type = (char)0;
        }
      }
    }
#line 901
    return (r);
  }
#line 904
  if ((int )v1.type == 1) {
#line 904
    if ((int )v2.type == 1) {
#line 905
      v1.v.val *= v2.v.val;
#line 906
      if (ValStackPtr >= 500) {
#line 906
        return (4);
      } else {
#line 906
        tmp = ValStackPtr;
#line 906
        ValStackPtr ++;
#line 906
        ValStack[tmp] = v1;
      }
#line 907
      return (0);
    }
  }
#line 909
  if ((int )v1.type == 4) {
#line 909
    if (v1.v.str) {
      {
#line 909
      free((void *)v1.v.str);
#line 909
      v1.type = (char)0;
      }
    }
  }
#line 909
  if ((int )v2.type == 4) {
#line 909
    if (v2.v.str) {
      {
#line 909
      free((void *)v2.v.str);
#line 909
      v2.type = (char)0;
      }
    }
  }
#line 910
  return (14);
}
}
#line 920 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/expr.c"
static int Divide(void) 
{ 
  Value v1 ;
  Value v2 ;
  int r ;
  int tmp ;

  {
#line 925
  if (ValStackPtr <= 0) {
#line 925
    return (12);
  } else {
#line 925
    ValStackPtr --;
#line 925
    v2 = ValStack[ValStackPtr];
  }
  {
#line 926
  r = FnPopValStack(& v1);
  }
#line 926
  if (r) {
#line 927
    if ((int )v2.type == 4) {
#line 927
      if (v2.v.str) {
        {
#line 927
        free((void *)v2.v.str);
#line 927
        v2.type = (char)0;
        }
      }
    }
#line 928
    return (r);
  }
#line 931
  if ((int )v1.type == 1) {
#line 931
    if ((int )v2.type == 1) {
#line 932
      if (v2.v.val == 0) {
#line 932
        return (17);
      }
#line 933
      v1.v.val /= v2.v.val;
#line 934
      if (ValStackPtr >= 500) {
#line 934
        return (4);
      } else {
#line 934
        tmp = ValStackPtr;
#line 934
        ValStackPtr ++;
#line 934
        ValStack[tmp] = v1;
      }
#line 935
      return (0);
    }
  }
#line 937
  if ((int )v1.type == 4) {
#line 937
    if (v1.v.str) {
      {
#line 937
      free((void *)v1.v.str);
#line 937
      v1.type = (char)0;
      }
    }
  }
#line 937
  if ((int )v2.type == 4) {
#line 937
    if (v2.v.str) {
      {
#line 937
      free((void *)v2.v.str);
#line 937
      v2.type = (char)0;
      }
    }
  }
#line 938
  return (14);
}
}
#line 948 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/expr.c"
static int Mod(void) 
{ 
  Value v1 ;
  Value v2 ;
  int r ;
  int tmp ;

  {
#line 953
  if (ValStackPtr <= 0) {
#line 953
    return (12);
  } else {
#line 953
    ValStackPtr --;
#line 953
    v2 = ValStack[ValStackPtr];
  }
  {
#line 954
  r = FnPopValStack(& v1);
  }
#line 954
  if (r) {
#line 955
    if ((int )v2.type == 4) {
#line 955
      if (v2.v.str) {
        {
#line 955
        free((void *)v2.v.str);
#line 955
        v2.type = (char)0;
        }
      }
    }
#line 956
    return (r);
  }
#line 959
  if ((int )v1.type == 1) {
#line 959
    if ((int )v2.type == 1) {
#line 960
      if (v2.v.val == 0) {
#line 960
        return (17);
      }
#line 961
      v1.v.val %= v2.v.val;
#line 962
      if (ValStackPtr >= 500) {
#line 962
        return (4);
      } else {
#line 962
        tmp = ValStackPtr;
#line 962
        ValStackPtr ++;
#line 962
        ValStack[tmp] = v1;
      }
#line 963
      return (0);
    }
  }
#line 965
  if ((int )v1.type == 4) {
#line 965
    if (v1.v.str) {
      {
#line 965
      free((void *)v1.v.str);
#line 965
      v1.type = (char)0;
      }
    }
  }
#line 965
  if ((int )v2.type == 4) {
#line 965
    if (v2.v.str) {
      {
#line 965
      free((void *)v2.v.str);
#line 965
      v2.type = (char)0;
      }
    }
  }
#line 966
  return (14);
}
}
#line 978 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/expr.c"
static int GreaterThan(void) 
{ 
  int tmp ;

  {
  {
#line 978
  tmp = Compare(1);
  }
#line 978
  return (tmp);
}
}
#line 979 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/expr.c"
static int LessThan(void) 
{ 
  int tmp ;

  {
  {
#line 979
  tmp = Compare(2);
  }
#line 979
  return (tmp);
}
}
#line 980 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/expr.c"
static int EqualTo(void) 
{ 
  int tmp ;

  {
  {
#line 980
  tmp = Compare(0);
  }
#line 980
  return (tmp);
}
}
#line 981 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/expr.c"
static int NotEqual(void) 
{ 
  int tmp ;

  {
  {
#line 981
  tmp = Compare(5);
  }
#line 981
  return (tmp);
}
}
#line 982 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/expr.c"
static int LessOrEqual(void) 
{ 
  int tmp ;

  {
  {
#line 982
  tmp = Compare(4);
  }
#line 982
  return (tmp);
}
}
#line 983 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/expr.c"
static int GreaterOrEqual(void) 
{ 
  int tmp ;

  {
  {
#line 983
  tmp = Compare(3);
  }
#line 983
  return (tmp);
}
}
#line 991 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/expr.c"
static int Compare(int how ) 
{ 
  Value v1 ;
  Value v2 ;
  Value v3 ;
  int r ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 996
  if (ValStackPtr <= 0) {
#line 996
    return (12);
  } else {
#line 996
    ValStackPtr --;
#line 996
    v2 = ValStack[ValStackPtr];
  }
  {
#line 997
  r = FnPopValStack(& v1);
  }
#line 997
  if (r) {
#line 998
    if ((int )v2.type == 4) {
#line 998
      if (v2.v.str) {
        {
#line 998
        free((void *)v2.v.str);
#line 998
        v2.type = (char)0;
        }
      }
    }
#line 999
    return (r);
  }
#line 1004
  v3.type = (char)1;
#line 1005
  if ((int )v1.type != (int )v2.type) {
#line 1006
    if ((int )v1.type == 4) {
#line 1006
      if (v1.v.str) {
        {
#line 1006
        free((void *)v1.v.str);
#line 1006
        v1.type = (char)0;
        }
      }
    }
#line 1006
    if ((int )v2.type == 4) {
#line 1006
      if (v2.v.str) {
        {
#line 1006
        free((void *)v2.v.str);
#line 1006
        v2.type = (char)0;
        }
      }
    }
#line 1007
    if (how == 0) {
#line 1008
      v3.v.val = 0;
#line 1009
      if (ValStackPtr >= 500) {
#line 1009
        return (4);
      } else {
#line 1009
        tmp = ValStackPtr;
#line 1009
        ValStackPtr ++;
#line 1009
        ValStack[tmp] = v3;
      }
#line 1010
      return (0);
    } else
#line 1011
    if (how == 5) {
#line 1012
      v3.v.val = 1;
#line 1013
      if (ValStackPtr >= 500) {
#line 1013
        return (4);
      } else {
#line 1013
        tmp___0 = ValStackPtr;
#line 1013
        ValStackPtr ++;
#line 1013
        ValStack[tmp___0] = v3;
      }
#line 1014
      return (0);
    } else {
#line 1015
      return (14);
    }
  }
#line 1018
  if ((int )v1.type == 4) {
    {
#line 1020
    if (how == 0) {
#line 1020
      goto case_0;
    }
#line 1021
    if (how == 5) {
#line 1021
      goto case_5;
    }
#line 1022
    if (how == 2) {
#line 1022
      goto case_2;
    }
#line 1023
    if (how == 1) {
#line 1023
      goto case_1;
    }
#line 1024
    if (how == 4) {
#line 1024
      goto case_4;
    }
#line 1025
    if (how == 3) {
#line 1025
      goto case_3;
    }
#line 1019
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 1020
    tmp___1 = strcmp((char const   *)v1.v.str, (char const   *)v2.v.str);
#line 1020
    v3.v.val = tmp___1 == 0;
    }
#line 1020
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 1021
    tmp___2 = strcmp((char const   *)v1.v.str, (char const   *)v2.v.str);
#line 1021
    v3.v.val = tmp___2 != 0;
    }
#line 1021
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 1022
    tmp___3 = strcmp((char const   *)v1.v.str, (char const   *)v2.v.str);
#line 1022
    v3.v.val = tmp___3 < 0;
    }
#line 1022
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 1023
    tmp___4 = strcmp((char const   *)v1.v.str, (char const   *)v2.v.str);
#line 1023
    v3.v.val = tmp___4 > 0;
    }
#line 1023
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 1024
    tmp___5 = strcmp((char const   *)v1.v.str, (char const   *)v2.v.str);
#line 1024
    v3.v.val = tmp___5 <= 0;
    }
#line 1024
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 1025
    tmp___6 = strcmp((char const   *)v1.v.str, (char const   *)v2.v.str);
#line 1025
    v3.v.val = tmp___6 >= 0;
    }
#line 1025
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1029
    if (how == 0) {
#line 1029
      goto case_0___0;
    }
#line 1030
    if (how == 5) {
#line 1030
      goto case_5___0;
    }
#line 1031
    if (how == 2) {
#line 1031
      goto case_2___0;
    }
#line 1032
    if (how == 1) {
#line 1032
      goto case_1___0;
    }
#line 1033
    if (how == 4) {
#line 1033
      goto case_4___0;
    }
#line 1034
    if (how == 3) {
#line 1034
      goto case_3___0;
    }
#line 1028
    goto switch_break___0;
    case_0___0: /* CIL Label */ 
#line 1029
    v3.v.val = v1.v.val == v2.v.val;
#line 1029
    goto switch_break___0;
    case_5___0: /* CIL Label */ 
#line 1030
    v3.v.val = v1.v.val != v2.v.val;
#line 1030
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
#line 1031
    v3.v.val = v1.v.val < v2.v.val;
#line 1031
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
#line 1032
    v3.v.val = v1.v.val > v2.v.val;
#line 1032
    goto switch_break___0;
    case_4___0: /* CIL Label */ 
#line 1033
    v3.v.val = v1.v.val <= v2.v.val;
#line 1033
    goto switch_break___0;
    case_3___0: /* CIL Label */ 
#line 1034
    v3.v.val = v1.v.val >= v2.v.val;
#line 1034
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 1037
  if ((int )v1.type == 4) {
#line 1037
    if (v1.v.str) {
      {
#line 1037
      free((void *)v1.v.str);
#line 1037
      v1.type = (char)0;
      }
    }
  }
#line 1037
  if ((int )v2.type == 4) {
#line 1037
    if (v2.v.str) {
      {
#line 1037
      free((void *)v2.v.str);
#line 1037
      v2.type = (char)0;
      }
    }
  }
#line 1038
  if (ValStackPtr >= 500) {
#line 1038
    return (4);
  } else {
#line 1038
    tmp___7 = ValStackPtr;
#line 1038
    ValStackPtr ++;
#line 1038
    ValStack[tmp___7] = v3;
  }
#line 1039
  return (0);
}
}
#line 1049 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/expr.c"
static int LogOR(void) 
{ 
  Value v1 ;
  Value v2 ;
  int r ;
  int tmp ;

  {
#line 1054
  if (ValStackPtr <= 0) {
#line 1054
    return (12);
  } else {
#line 1054
    ValStackPtr --;
#line 1054
    v2 = ValStack[ValStackPtr];
  }
  {
#line 1055
  r = FnPopValStack(& v1);
  }
#line 1055
  if (r) {
#line 1056
    if ((int )v2.type == 4) {
#line 1056
      if (v2.v.str) {
        {
#line 1056
        free((void *)v2.v.str);
#line 1056
        v2.type = (char)0;
        }
      }
    }
#line 1057
    return (r);
  }
#line 1060
  if ((int )v1.type == 1) {
#line 1060
    if ((int )v2.type == 1) {
#line 1061
      if (v1.v.val) {
#line 1061
        v1.v.val = 1;
      } else
#line 1061
      if (v2.v.val) {
#line 1061
        v1.v.val = 1;
      } else {
#line 1061
        v1.v.val = 0;
      }
#line 1062
      if (ValStackPtr >= 500) {
#line 1062
        return (4);
      } else {
#line 1062
        tmp = ValStackPtr;
#line 1062
        ValStackPtr ++;
#line 1062
        ValStack[tmp] = v1;
      }
#line 1063
      return (0);
    }
  }
#line 1065
  if ((int )v1.type == 4) {
#line 1065
    if (v1.v.str) {
      {
#line 1065
      free((void *)v1.v.str);
#line 1065
      v1.type = (char)0;
      }
    }
  }
#line 1065
  if ((int )v2.type == 4) {
#line 1065
    if (v2.v.str) {
      {
#line 1065
      free((void *)v2.v.str);
#line 1065
      v2.type = (char)0;
      }
    }
  }
#line 1066
  return (14);
}
}
#line 1076 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/expr.c"
static int LogAND(void) 
{ 
  Value v1 ;
  Value v2 ;
  int r ;
  int tmp ;

  {
#line 1081
  if (ValStackPtr <= 0) {
#line 1081
    return (12);
  } else {
#line 1081
    ValStackPtr --;
#line 1081
    v2 = ValStack[ValStackPtr];
  }
  {
#line 1082
  r = FnPopValStack(& v1);
  }
#line 1082
  if (r) {
#line 1083
    if ((int )v2.type == 4) {
#line 1083
      if (v2.v.str) {
        {
#line 1083
        free((void *)v2.v.str);
#line 1083
        v2.type = (char)0;
        }
      }
    }
#line 1084
    return (r);
  }
#line 1087
  if ((int )v1.type == 1) {
#line 1087
    if ((int )v2.type == 1) {
#line 1088
      if (v1.v.val) {
#line 1088
        if (v2.v.val) {
#line 1088
          v1.v.val = 1;
        } else {
#line 1088
          v1.v.val = 0;
        }
      } else {
#line 1088
        v1.v.val = 0;
      }
#line 1089
      if (ValStackPtr >= 500) {
#line 1089
        return (4);
      } else {
#line 1089
        tmp = ValStackPtr;
#line 1089
        ValStackPtr ++;
#line 1089
        ValStack[tmp] = v1;
      }
#line 1090
      return (0);
    }
  }
#line 1092
  if ((int )v1.type == 4) {
#line 1092
    if (v1.v.str) {
      {
#line 1092
      free((void *)v1.v.str);
#line 1092
      v1.type = (char)0;
      }
    }
  }
#line 1092
  if ((int )v2.type == 4) {
#line 1092
    if (v2.v.str) {
      {
#line 1092
      free((void *)v2.v.str);
#line 1092
      v2.type = (char)0;
      }
    }
  }
#line 1093
  return (14);
}
}
#line 1103 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/expr.c"
static int UnMinus(void) 
{ 
  Value *v ;

  {
#line 1105
  v = & ValStack[ValStackPtr - 1];
#line 1106
  if ((int )v->type != 1) {
#line 1106
    return (14);
  }
#line 1107
  v->v.val = - v->v.val;
#line 1108
  return (0);
}
}
#line 1118 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/expr.c"
static int LogNot(void) 
{ 
  Value *v ;

  {
#line 1120
  v = & ValStack[ValStackPtr - 1];
#line 1121
  if ((int )v->type != 1) {
#line 1121
    return (14);
  }
#line 1122
  if (v->v.val) {
#line 1122
    v->v.val = 0;
  } else {
#line 1122
    v->v.val = 1;
  }
#line 1123
  return (0);
}
}
#line 1133 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/expr.c"
Operator *FindOperator(char const   *name , Operator *where , int num ) 
{ 
  int top ;
  int bot ;
  int mid ;
  int r ;

  {
#line 1135
  top = num - 1;
#line 1135
  bot = 0;
  {
#line 1137
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1137
    if (! (top >= bot)) {
#line 1137
      goto while_break;
    }
    {
#line 1138
    mid = (top + bot) / 2;
#line 1139
    r = StrCmpi(name, (where + mid)->name);
    }
#line 1140
    if (! r) {
#line 1140
      return (where + mid);
    } else
#line 1141
    if (r > 0) {
#line 1141
      bot = mid + 1;
    } else {
#line 1142
      top = mid - 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1144
  return ((Operator *)((void *)0));
}
}
#line 1154 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/expr.c"
BuiltinFunc *FindFunc(char const   *name , BuiltinFunc *where , int num ) 
{ 
  int top ;
  int bot ;
  int mid ;
  int r ;

  {
#line 1156
  top = num - 1;
#line 1156
  bot = 0;
  {
#line 1158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1158
    if (! (top >= bot)) {
#line 1158
      goto while_break;
    }
    {
#line 1159
    mid = (top + bot) / 2;
#line 1160
    r = StrCmpi(name, (where + mid)->name);
    }
#line 1161
    if (! r) {
#line 1161
      return (where + mid);
    } else
#line 1162
    if (r > 0) {
#line 1162
      bot = mid + 1;
    } else {
#line 1163
      top = mid - 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1165
  return ((BuiltinFunc *)((void *)0));
}
}
#line 1175 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/expr.c"
void PrintValue(Value *v , FILE *fp___0 ) 
{ 
  int y ;
  int m ;
  int d ;
  char const   *s ;
  char const   *tmp ;

  {
#line 1180
  if ((int )v->type == 4) {
    {
#line 1181
    s = (char const   *)v->v.str;
#line 1182
    _IO_putc('\"', fp___0);
#line 1183
    y = 0;
    }
    {
#line 1183
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1183
      if (y < 40) {
#line 1183
        if (! *s) {
#line 1183
          goto while_break;
        }
      } else {
#line 1183
        goto while_break;
      }
      {
#line 1183
      tmp = s;
#line 1183
      s ++;
#line 1183
      _IO_putc((int )*tmp, fp___0);
#line 1183
      y ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1184
    _IO_putc('\"', fp___0);
    }
#line 1185
    if (*s) {
      {
#line 1185
      fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"...");
      }
    }
  } else
#line 1187
  if ((int )v->type == 1) {
    {
#line 1187
    fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"%d",
            v->v.val);
    }
  } else
#line 1188
  if ((int )v->type == 2) {
    {
#line 1188
    fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"%02d%c%02d",
            v->v.val / 60, (int )TimeSep, v->v.val % 60);
    }
  } else
#line 1190
  if ((int )v->type == 3) {
    {
#line 1191
    FromJulian(v->v.val, & y, & m, & d);
#line 1192
    fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"%04d%c%02d%c%02d",
            y, (int )DateSep, m + 1, (int )DateSep, d);
    }
  } else
#line 1194
  if ((int )v->type == 5) {
    {
#line 1195
    FromJulian(v->v.val / 1440, & y, & m, & d);
#line 1196
    fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"%04d%c%02d%c%02d@%02d%c%02d",
            y, (int )DateSep, m + 1, (int )DateSep, d, (v->v.val % 1440) / 60, (int )TimeSep,
            (v->v.val % 1440) % 60);
    }
  } else {
    {
#line 1199
    fprintf((FILE */* __restrict  */)fp___0, (char const   */* __restrict  */)"ERR");
    }
  }
#line 1200
  return;
}
}
#line 1209 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/expr.c"
int CopyValue(Value *dest , Value const   *src ) 
{ 


  {
#line 1211
  dest->type = (char)0;
#line 1212
  if ((int const   )src->type == 4) {
    {
#line 1213
    dest->v.str = StrDup((char const   *)src->v.str);
    }
#line 1214
    if (! dest->v.str) {
#line 1214
      return (9);
    }
  } else {
#line 1216
    dest->v.val = (int )src->v.val;
  }
#line 1218
  dest->type = (char )src->type;
#line 1219
  return (0);
}
}
#line 1230 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/expr.c"
int ParseLiteralDate(char const   **s , int *jul , int *tim ) 
{ 
  int y ;
  int m ;
  int d ;
  int hour ;
  int min ;
  unsigned short const   **tmp ;
  char const   *tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  char const   *tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  char const   *tmp___6 ;
  unsigned short const   **tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  unsigned short const   **tmp___10 ;
  char const   *tmp___11 ;
  unsigned short const   **tmp___12 ;

  {
  {
#line 1235
  y = 0;
#line 1235
  m = 0;
#line 1235
  d = 0;
#line 1236
  hour = 0;
#line 1236
  min = 0;
#line 1238
  *tim = 2147483647;
#line 1239
  tmp = __ctype_b_loc();
  }
#line 1239
  if (! ((int const   )*(*tmp + (int )*(*s)) & 2048)) {
#line 1239
    return (24);
  }
  {
#line 1240
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1240
    tmp___1 = __ctype_b_loc();
    }
#line 1240
    if (! ((int const   )*(*tmp___1 + (int )*(*s)) & 2048)) {
#line 1240
      goto while_break;
    }
#line 1241
    y *= 10;
#line 1242
    tmp___0 = *s;
#line 1242
    (*s) ++;
#line 1242
    y += (int )((int const   )*tmp___0 - 48);
  }
  while_break: /* CIL Label */ ;
  }
#line 1244
  if ((int const   )*(*s) != 47) {
#line 1244
    if ((int const   )*(*s) != 45) {
#line 1244
      if ((int const   )*(*s) != (int const   )DateSep) {
#line 1244
        return (24);
      }
    }
  }
  {
#line 1245
  (*s) ++;
#line 1246
  tmp___2 = __ctype_b_loc();
  }
#line 1246
  if (! ((int const   )*(*tmp___2 + (int )*(*s)) & 2048)) {
#line 1246
    return (24);
  }
  {
#line 1247
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1247
    tmp___4 = __ctype_b_loc();
    }
#line 1247
    if (! ((int const   )*(*tmp___4 + (int )*(*s)) & 2048)) {
#line 1247
      goto while_break___0;
    }
#line 1248
    m *= 10;
#line 1249
    tmp___3 = *s;
#line 1249
    (*s) ++;
#line 1249
    m += (int )((int const   )*tmp___3 - 48);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1251
  m --;
#line 1252
  if ((int const   )*(*s) != 47) {
#line 1252
    if ((int const   )*(*s) != 45) {
#line 1252
      if ((int const   )*(*s) != (int const   )DateSep) {
#line 1252
        return (24);
      }
    }
  }
  {
#line 1253
  (*s) ++;
#line 1254
  tmp___5 = __ctype_b_loc();
  }
#line 1254
  if (! ((int const   )*(*tmp___5 + (int )*(*s)) & 2048)) {
#line 1254
    return (24);
  }
  {
#line 1255
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 1255
    tmp___7 = __ctype_b_loc();
    }
#line 1255
    if (! ((int const   )*(*tmp___7 + (int )*(*s)) & 2048)) {
#line 1255
      goto while_break___1;
    }
#line 1256
    d *= 10;
#line 1257
    tmp___6 = *s;
#line 1257
    (*s) ++;
#line 1257
    d += (int )((int const   )*tmp___6 - 48);
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1259
  tmp___8 = DateOK(y, m, d);
  }
#line 1259
  if (! tmp___8) {
#line 1259
    return (24);
  }
  {
#line 1261
  *jul = Julian(y, m, d);
  }
#line 1264
  if ((int const   )*(*s) == 32) {
#line 1264
    goto _L;
  } else
#line 1264
  if ((int const   )*(*s) == 64) {
    _L: /* CIL Label */ 
#line 1265
    (*s) ++;
    {
#line 1266
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 1266
      tmp___10 = __ctype_b_loc();
      }
#line 1266
      if (! ((int const   )*(*tmp___10 + (int )*(*s)) & 2048)) {
#line 1266
        goto while_break___2;
      }
#line 1267
      hour *= 10;
#line 1268
      tmp___9 = *s;
#line 1268
      (*s) ++;
#line 1268
      hour += (int )((int const   )*tmp___9 - 48);
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1270
    if ((int const   )*(*s) != 58) {
#line 1270
      if ((int const   )*(*s) != 46) {
#line 1270
        if ((int const   )*(*s) != (int const   )TimeSep) {
#line 1270
          return (27);
        }
      }
    }
#line 1271
    (*s) ++;
    {
#line 1272
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 1272
      tmp___12 = __ctype_b_loc();
      }
#line 1272
      if (! ((int const   )*(*tmp___12 + (int )*(*s)) & 2048)) {
#line 1272
        goto while_break___3;
      }
#line 1273
      min *= 10;
#line 1274
      tmp___11 = *s;
#line 1274
      (*s) ++;
#line 1274
      min += (int )((int const   )*tmp___11 - 48);
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1276
    if (hour > 23) {
#line 1276
      return (27);
    } else
#line 1276
    if (min > 59) {
#line 1276
      return (27);
    }
#line 1277
    *tim = hour * 60 + min;
  }
#line 1280
  return (0);
}
}
#line 1292 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/expr.c"
int FnPopValStack(Value *val ) 
{ 


  {
#line 1294
  if (ValStackPtr <= 0) {
#line 1295
    return (12);
  } else {
#line 1297
    ValStackPtr --;
#line 1297
    *val = ValStack[ValStackPtr];
#line 1298
    return (0);
  }
}
}
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 873 "/usr/include/stdio.h"
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 879
extern int pclose(FILE *__stream ) ;
#line 584 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) setenv)(char const   *__name ,
                                                                                             char const   *__value ,
                                                                                             int __replace ) ;
#line 588
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unsetenv)(char const   *__name ) ;
#line 342 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 54 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) acos)(double __x ) ;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 254 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime_r)(time_t const   * __restrict  __timer ,
                                                                                         struct tm * __restrict  __tp ) ;
#line 293
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) tzset)(void) ;
#line 57 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FCurrent(func_info *info ) ;
#line 58
static int FNonomitted(func_info *info ) ;
#line 59
static int FTimepart(func_info *info ) ;
#line 60
static int FDatepart(func_info *info ) ;
#line 61
static int FRealCurrent(func_info *info ) ;
#line 62
static int FAbs(func_info *info ) ;
#line 63
static int FAccess(func_info *info ) ;
#line 64
static int FArgs(func_info *info ) ;
#line 65
static int FAsc(func_info *info ) ;
#line 66
static int FBaseyr(func_info *info ) ;
#line 67
static int FChar(func_info *info ) ;
#line 68
static int FChoose(func_info *info ) ;
#line 69
static int FCoerce(func_info *info ) ;
#line 70
static int FDate(func_info *info ) ;
#line 71
static int FDateTime(func_info *info ) ;
#line 72
static int FDay(func_info *info ) ;
#line 73
static int FDaysinmon(func_info *info ) ;
#line 74
static int FDefined(func_info *info ) ;
#line 75
static int FDosubst(func_info *info ) ;
#line 76
static int FEasterdate(func_info *info ) ;
#line 77
static int FEvalTrig(func_info *info ) ;
#line 78
static int FFiledate(func_info *info ) ;
#line 79
static int FFiledatetime(func_info *info ) ;
#line 80
static int FFiledir(func_info *info ) ;
#line 81
static int FFilename(func_info *info ) ;
#line 82
static int FGetenv(func_info *info ) ;
#line 83
static int FHebdate(func_info *info ) ;
#line 84
static int FHebday(func_info *info ) ;
#line 85
static int FHebmon(func_info *info ) ;
#line 86
static int FHebyear(func_info *info ) ;
#line 87
static int FHour(func_info *info ) ;
#line 88
static int FIif(func_info *info ) ;
#line 89
static int FIndex(func_info *info ) ;
#line 90
static int FIsdst(func_info *info ) ;
#line 91
static int FIsomitted(func_info *info ) ;
#line 92
static int FSlide(func_info *info ) ;
#line 93
static int FLanguage(func_info *info ) ;
#line 94
static int FMax(func_info *info ) ;
#line 95
static int FMin(func_info *info ) ;
#line 96
static int FMinute(func_info *info ) ;
#line 97
static int FMinsfromutc(func_info *info ) ;
#line 98
static int FMoondate(func_info *info ) ;
#line 99
static int FMoondatetime(func_info *info ) ;
#line 100
static int FMoonphase(func_info *info ) ;
#line 101
static int FMoontime(func_info *info ) ;
#line 102
static int FMon(func_info *info ) ;
#line 103
static int FMonnum(func_info *info ) ;
#line 104
static int FOrd(func_info *info ) ;
#line 105
static int FOstype(func_info *info ) ;
#line 106
static int FPlural(func_info *info ) ;
#line 107
static int FSgn(func_info *info ) ;
#line 108
static int FPsmoon(func_info *info ) ;
#line 109
static int FPsshade(func_info *info ) ;
#line 110
static int FShell(func_info *info ) ;
#line 111
static int FStrlen(func_info *info ) ;
#line 112
static int FSubstr(func_info *info ) ;
#line 113
static int FDawn(func_info *info ) ;
#line 114
static int FDusk(func_info *info ) ;
#line 115
static int FSunset(func_info *info ) ;
#line 116
static int FSunrise(func_info *info ) ;
#line 117
static int FTime(func_info *info ) ;
#line 118
static int FTrigdate(func_info *info ) ;
#line 119
static int FTrigdatetime(func_info *info ) ;
#line 120
static int FTrigtime(func_info *info ) ;
#line 121
static int FTrigvalid(func_info *info ) ;
#line 122
static int FTypeof(func_info *info ) ;
#line 123
static int FUpper(func_info *info ) ;
#line 124
static int FValue(func_info *info ) ;
#line 125
static int FVersion(func_info *info ) ;
#line 126
static int FWkday(func_info *info ) ;
#line 127
static int FWkdaynum(func_info *info ) ;
#line 128
static int FYear(func_info *info ) ;
#line 129
static int FIsleap(func_info *info ) ;
#line 130
static int FLower(func_info *info ) ;
#line 131
static int FNow(func_info *info ) ;
#line 132
static int FRealnow(func_info *info ) ;
#line 133
static int FRealtoday(func_info *info ) ;
#line 134
static int FToday(func_info *info ) ;
#line 135
static int FTrigger(func_info *info ) ;
#line 136
static int FTzconvert(func_info *info ) ;
#line 137
static int FWeekno(func_info *info ) ;
#line 138
static int CheckArgs(BuiltinFunc *f , int nargs ) ;
#line 139
static int CleanUpAfterFunc(func_info *info ) ;
#line 140
static int SunStuff(int rise , double cosz , int jul ) ;
#line 147 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int CacheJul  =    -1;
#line 148 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int CacheYear  ;
#line 148 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int CacheMon  ;
#line 148 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int CacheDay  ;
#line 150 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int CacheHebJul  =    -1;
#line 151 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int CacheHebYear  ;
#line 151 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int CacheHebMon  ;
#line 151 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int CacheHebDay  ;
#line 186 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
BuiltinFunc Func[81]  = 
#line 186
  {      {"abs", (char)1, (char)1, (char)1, & FAbs}, 
        {"access", (char)2, (char)2, (char)0, & FAccess}, 
        {"args", (char)1, (char)1, (char)0, & FArgs}, 
        {"asc", (char)1, (char)1, (char)1, & FAsc}, 
        {"baseyr", (char)0, (char)0, (char)1, & FBaseyr}, 
        {"char", (char)1, (char)127, (char)1, & FChar}, 
        {"choose", (char)2, (char)127, (char)1, & FChoose}, 
        {"coerce", (char)2, (char)2, (char)1, & FCoerce}, 
        {"current", (char)0, (char)0, (char)0, & FCurrent}, 
        {"date", (char)3, (char)3, (char)1, & FDate}, 
        {"datepart", (char)1, (char)1, (char)1, & FDatepart}, 
        {"datetime", (char)2, (char)5, (char)1, & FDateTime}, 
        {"dawn", (char)0, (char)1, (char)0, & FDawn}, 
        {"day", (char)1, (char)1, (char)1, & FDay}, 
        {"daysinmon", (char)2, (char)2, (char)1, & FDaysinmon}, 
        {"defined", (char)1, (char)1, (char)0, & FDefined}, 
        {"dosubst", (char)1, (char)3, (char)0, & FDosubst}, 
        {"dusk", (char)0, (char)1, (char)0, & FDusk}, 
        {"easterdate", (char)1, (char)1, (char)0, & FEasterdate}, 
        {"evaltrig", (char)1, (char)2, (char)0, & FEvalTrig}, 
        {"filedate", (char)1, (char)1, (char)0, & FFiledate}, 
        {"filedatetime", (char)1, (char)1, (char)0, & FFiledatetime}, 
        {"filedir", (char)0, (char)0, (char)0, & FFiledir}, 
        {"filename", (char)0, (char)0, (char)0, & FFilename}, 
        {"getenv", (char)1, (char)1, (char)0, & FGetenv}, 
        {"hebdate", (char)2, (char)5, (char)0, & FHebdate}, 
        {"hebday", (char)1, (char)1, (char)0, & FHebday}, 
        {"hebmon", (char)1, (char)1, (char)0, & FHebmon}, 
        {"hebyear", (char)1, (char)1, (char)0, & FHebyear}, 
        {"hour", (char)1, (char)1, (char)1, & FHour}, 
        {"iif", (char)1, (char)127, (char)1, & FIif}, 
        {"index", (char)2, (char)3, (char)1, & FIndex}, 
        {"isdst", (char)0, (char)2, (char)0, & FIsdst}, 
        {"isleap", (char)1, (char)1, (char)1, & FIsleap}, 
        {"isomitted", (char)1, (char)1, (char)0, & FIsomitted}, 
        {"language", (char)0, (char)0, (char)1, & FLanguage}, 
        {"lower", (char)1, (char)1, (char)1, & FLower}, 
        {"max", (char)1, (char)127, (char)1, & FMax}, 
        {"min", (char)1, (char)127, (char)1, & FMin}, 
        {"minsfromutc", (char)0, (char)2, (char)0, & FMinsfromutc}, 
        {"minute", (char)1, (char)1, (char)1, & FMinute}, 
        {"mon", (char)1, (char)1, (char)1, & FMon}, 
        {"monnum", (char)1, (char)1, (char)1, & FMonnum}, 
        {"moondate", (char)1, (char)3, (char)0, & FMoondate}, 
        {"moondatetime", (char)1, (char)3, (char)0, & FMoondatetime}, 
        {"moonphase", (char)0, (char)2, (char)0, & FMoonphase}, 
        {"moontime", (char)1, (char)3, (char)0, & FMoontime}, 
        {"nonomitted", (char)2, (char)127, (char)0, & FNonomitted}, 
        {"now", (char)0, (char)0, (char)0, & FNow}, 
        {"ord", (char)1, (char)1, (char)1, & FOrd}, 
        {"ostype", (char)0, (char)0, (char)1, & FOstype}, 
        {"plural", (char)1, (char)3, (char)1, & FPlural}, 
        {"psmoon", (char)1, (char)4, (char)1, & FPsmoon}, 
        {"psshade", (char)1, (char)3, (char)1, & FPsshade}, 
        {"realcurrent", (char)0, (char)0, (char)0, & FRealCurrent}, 
        {"realnow", (char)0, (char)0, (char)0, & FRealnow}, 
        {"realtoday", (char)0, (char)0, (char)0, & FRealtoday}, 
        {"sgn", (char)1, (char)1, (char)1, & FSgn}, 
        {"shell", (char)1, (char)2, (char)0, & FShell}, 
        {"slide", (char)2, (char)127, (char)0, & FSlide}, 
        {"strlen", (char)1, (char)1, (char)1, & FStrlen}, 
        {"substr", (char)2, (char)3, (char)1, & FSubstr}, 
        {"sunrise", (char)0, (char)1, (char)0, & FSunrise}, 
        {"sunset", (char)0, (char)1, (char)0, & FSunset}, 
        {"time", (char)2, (char)2, (char)1, & FTime}, 
        {"timepart", (char)1, (char)1, (char)1, & FTimepart}, 
        {"today", (char)0, (char)0, (char)0, & FToday}, 
        {"trigdate", (char)0, (char)0, (char)0, & FTrigdate}, 
        {"trigdatetime", (char)0, (char)0, (char)0, & FTrigdatetime}, 
        {"trigger", (char)1, (char)3, (char)0, & FTrigger}, 
        {"trigtime", (char)0, (char)0, (char)0, & FTrigtime}, 
        {"trigvalid", (char)0, (char)0, (char)0, & FTrigvalid}, 
        {"typeof", (char)1, (char)1, (char)1, & FTypeof}, 
        {"tzconvert", (char)2, (char)3, (char)0, & FTzconvert}, 
        {"upper", (char)1, (char)1, (char)1, & FUpper}, 
        {"value", (char)1, (char)2, (char)0, & FValue}, 
        {"version", (char)0, (char)0, (char)1, & FVersion}, 
        {"weekno", (char)0, (char)3, (char)1, & FWeekno}, 
        {"wkday", (char)1, (char)1, (char)1, & FWkday}, 
        {"wkdaynum", (char)1, (char)1, (char)1, & FWkdaynum}, 
        {"year", (char)1, (char)1, (char)1, & FYear}};
#line 273 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
int NumFuncs  =    (int )(sizeof(Func) / sizeof(Operator ));
#line 283 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
int CallFunc(BuiltinFunc *f , int nargs ) 
{ 
  register int r ;
  int tmp ;
  int i ;
  func_info info_obj ;
  func_info *info ;

  {
  {
#line 285
  tmp = CheckArgs(f, nargs);
#line 285
  r = tmp;
#line 289
  info = & info_obj;
#line 291
  info->nargs = nargs;
#line 292
  info->retval.type = (char)0;
  }
#line 294
  if (DebugFlag & 2) {
    {
#line 295
    fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"%s(",
            f->name);
#line 296
    i = 0;
    }
    {
#line 296
    while (1) {
      while_continue: /* CIL Label */ ;
#line 296
      if (! (i < nargs)) {
#line 296
        goto while_break;
      }
      {
#line 297
      PrintValue(& ValStack[(ValStackPtr - info->nargs) + i], ErrFp);
      }
#line 298
      if (i < nargs - 1) {
        {
#line 298
        fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)", ");
        }
      }
#line 296
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 300
    fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)") => ");
    }
#line 301
    if (r) {
      {
#line 302
      fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"%s\n",
              ErrMsg[r]);
      }
#line 303
      return (r);
    }
  }
#line 306
  if (r) {
    {
#line 307
    Eprint("%s(): %s", f->name, ErrMsg[r]);
    }
#line 308
    return (r);
  }
  {
#line 311
  r = (*(f->func))(info);
  }
#line 312
  if (r) {
#line 313
    if ((int )info->retval.type == 4) {
#line 313
      if (info->retval.v.str) {
        {
#line 313
        free((void *)info->retval.v.str);
#line 313
        info->retval.type = (char)0;
        }
      }
    }
#line 314
    if (DebugFlag & 2) {
      {
#line 315
      fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"%s\n",
              ErrMsg[r]);
      }
    } else {
      {
#line 317
      Eprint("%s(): %s", f->name, ErrMsg[r]);
      }
    }
#line 318
    return (r);
  }
#line 320
  if (DebugFlag & 2) {
    {
#line 321
    PrintValue(& info->retval, ErrFp);
#line 322
    fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"\n");
    }
  }
  {
#line 324
  r = CleanUpAfterFunc(info);
  }
#line 325
  return (r);
}
}
#line 336 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int CheckArgs(BuiltinFunc *f , int nargs ) 
{ 


  {
#line 338
  if (nargs < (int )f->minargs) {
#line 338
    return (25);
  }
#line 339
  if (nargs > (int )f->maxargs) {
#line 339
    if ((int )f->maxargs != 127) {
#line 339
      return (26);
    }
  }
#line 340
  return (0);
}
}
#line 350 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int CleanUpAfterFunc(func_info *info ) 
{ 
  Value v ;
  int i ;
  int tmp ;

  {
#line 355
  i = 0;
  {
#line 355
  while (1) {
    while_continue: /* CIL Label */ ;
#line 355
    if (! (i < info->nargs)) {
#line 355
      goto while_break;
    }
#line 356
    if (ValStackPtr <= 0) {
#line 356
      return (12);
    } else {
#line 356
      ValStackPtr --;
#line 356
      v = ValStack[ValStackPtr];
    }
#line 357
    if ((int )v.type == 4) {
#line 357
      if (v.v.str) {
        {
#line 357
        free((void *)v.v.str);
#line 357
        v.type = (char)0;
        }
      }
    }
#line 355
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 359
  if (ValStackPtr >= 500) {
#line 359
    return (4);
  } else {
#line 359
    tmp = ValStackPtr;
#line 359
    ValStackPtr ++;
#line 359
    ValStack[tmp] = info->retval;
  }
#line 360
  return (0);
}
}
#line 370 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int RetStrVal(char const   *s , func_info *info ) 
{ 
  void *tmp ;

  {
#line 372
  info->retval.type = (char)4;
#line 373
  if (! s) {
    {
#line 374
    tmp = malloc((size_t )1);
#line 374
    info->retval.v.str = (char *)tmp;
    }
#line 375
    if (info->retval.v.str) {
#line 375
      *(info->retval.v.str) = (char)0;
    }
  } else {
    {
#line 377
    info->retval.v.str = StrDup(s);
    }
  }
#line 379
  if (! info->retval.v.str) {
#line 380
    info->retval.type = (char)0;
#line 381
    return (9);
  }
#line 383
  return (0);
}
}
#line 392 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FStrlen(func_info *info ) 
{ 
  Value *v ;
  size_t tmp ;

  {
#line 394
  v = & ValStack[ValStackPtr - info->nargs];
#line 395
  if ((int )v->type != 4) {
#line 395
    return (14);
  }
  {
#line 396
  info->retval.type = (char)1;
#line 397
  tmp = strlen((char const   *)v->v.str);
#line 397
  info->retval.v.val = (int )tmp;
  }
#line 398
  return (0);
}
}
#line 406 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FBaseyr(func_info *info ) 
{ 


  {
#line 408
  info->retval.type = (char)1;
#line 409
  info->retval.v.val = 1990;
#line 410
  return (0);
}
}
#line 418 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FDate(func_info *info ) 
{ 
  int y ;
  int m ;
  int d ;
  int ytemp ;
  int mtemp ;
  int dtemp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 425
  if ((int )ValStack[ValStackPtr - info->nargs].type == 3) {
#line 425
    goto _L;
  } else
#line 425
  if ((int )ValStack[ValStackPtr - info->nargs].type == 5) {
    _L: /* CIL Label */ 
#line 426
    if ((int )ValStack[ValStackPtr - info->nargs].type == 3) {
#line 426
      tmp = ValStack[ValStackPtr - info->nargs].v.val;
    } else {
#line 426
      tmp = ValStack[ValStackPtr - info->nargs].v.val / 1440;
    }
    {
#line 426
    FromJulian(tmp, & ytemp, & mtemp, & dtemp);
#line 427
    y = ytemp;
    }
  } else {
#line 429
    if ((int )ValStack[ValStackPtr - info->nargs].type != 1) {
#line 429
      return (14);
    }
#line 430
    y = ValStack[ValStackPtr - info->nargs].v.val;
  }
#line 433
  if ((int )ValStack[(ValStackPtr - info->nargs) + 1].type == 3) {
#line 433
    goto _L___0;
  } else
#line 433
  if ((int )ValStack[(ValStackPtr - info->nargs) + 1].type == 5) {
    _L___0: /* CIL Label */ 
#line 434
    if ((int )ValStack[(ValStackPtr - info->nargs) + 1].type == 3) {
#line 434
      tmp___0 = ValStack[(ValStackPtr - info->nargs) + 1].v.val;
    } else {
#line 434
      tmp___0 = ValStack[(ValStackPtr - info->nargs) + 1].v.val / 1440;
    }
    {
#line 434
    FromJulian(tmp___0, & ytemp, & mtemp, & dtemp);
#line 435
    m = mtemp;
    }
  } else {
#line 437
    if ((int )ValStack[(ValStackPtr - info->nargs) + 1].type != 1) {
#line 437
      return (14);
    }
#line 438
    m = ValStack[(ValStackPtr - info->nargs) + 1].v.val - 1;
  }
#line 441
  if ((int )ValStack[(ValStackPtr - info->nargs) + 2].type == 3) {
#line 441
    goto _L___1;
  } else
#line 441
  if ((int )ValStack[(ValStackPtr - info->nargs) + 2].type == 5) {
    _L___1: /* CIL Label */ 
#line 442
    if ((int )ValStack[(ValStackPtr - info->nargs) + 2].type == 3) {
#line 442
      tmp___1 = ValStack[(ValStackPtr - info->nargs) + 2].v.val;
    } else {
#line 442
      tmp___1 = ValStack[(ValStackPtr - info->nargs) + 2].v.val / 1440;
    }
    {
#line 442
    FromJulian(tmp___1, & ytemp, & mtemp, & dtemp);
#line 443
    d = dtemp;
    }
  } else {
#line 445
    if ((int )ValStack[(ValStackPtr - info->nargs) + 2].type != 1) {
#line 445
      return (14);
    }
#line 446
    d = ValStack[(ValStackPtr - info->nargs) + 2].v.val;
  }
  {
#line 449
  tmp___2 = DateOK(y, m, d);
  }
#line 449
  if (! tmp___2) {
#line 450
    return (24);
  }
  {
#line 452
  info->retval.type = (char)3;
#line 453
  info->retval.v.val = Julian(y, m, d);
  }
#line 454
  return (0);
}
}
#line 466 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FDateTime(func_info *info ) 
{ 
  int y ;
  int m ;
  int d ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 470
  info->retval.type = (char)5;
  {
#line 473
  if (info->nargs == 2) {
#line 473
    goto case_2;
  }
#line 478
  if (info->nargs == 3) {
#line 478
    goto case_3;
  }
#line 486
  if (info->nargs == 4) {
#line 486
    goto case_4;
  }
#line 498
  if (info->nargs == 5) {
#line 498
    goto case_5;
  }
#line 515
  goto switch_default;
  case_2: /* CIL Label */ 
#line 474
  if ((int )ValStack[ValStackPtr - info->nargs].type != 3) {
#line 475
    return (14);
  } else
#line 474
  if ((int )ValStack[(ValStackPtr - info->nargs) + 1].type != 2) {
#line 475
    return (14);
  }
#line 476
  info->retval.v.val = 1440 * ValStack[ValStackPtr - info->nargs].v.val + ValStack[(ValStackPtr - info->nargs) + 1].v.val;
#line 477
  return (0);
  case_3: /* CIL Label */ 
#line 479
  if ((int )ValStack[ValStackPtr - info->nargs].type != 3) {
#line 481
    return (14);
  } else
#line 479
  if ((int )ValStack[(ValStackPtr - info->nargs) + 1].type != 1) {
#line 481
    return (14);
  } else
#line 479
  if ((int )ValStack[(ValStackPtr - info->nargs) + 2].type != 1) {
#line 481
    return (14);
  }
#line 482
  if (ValStack[(ValStackPtr - info->nargs) + 1].v.val < 0) {
#line 482
    return (29);
  } else
#line 482
  if (ValStack[(ValStackPtr - info->nargs) + 2].v.val < 0) {
#line 482
    return (29);
  }
#line 483
  if (ValStack[(ValStackPtr - info->nargs) + 1].v.val > 23) {
#line 483
    return (28);
  } else
#line 483
  if (ValStack[(ValStackPtr - info->nargs) + 2].v.val > 59) {
#line 483
    return (28);
  }
#line 484
  info->retval.v.val = (1440 * ValStack[ValStackPtr - info->nargs].v.val + 60 * ValStack[(ValStackPtr - info->nargs) + 1].v.val) + ValStack[(ValStackPtr - info->nargs) + 2].v.val;
#line 485
  return (0);
  case_4: /* CIL Label */ 
#line 487
  if ((int )ValStack[ValStackPtr - info->nargs].type != 1) {
#line 490
    return (14);
  } else
#line 487
  if ((int )ValStack[(ValStackPtr - info->nargs) + 1].type != 1) {
#line 490
    return (14);
  } else
#line 487
  if ((int )ValStack[(ValStackPtr - info->nargs) + 2].type != 1) {
#line 490
    return (14);
  } else
#line 487
  if ((int )ValStack[(ValStackPtr - info->nargs) + 3].type != 2) {
#line 490
    return (14);
  }
  {
#line 491
  y = ValStack[ValStackPtr - info->nargs].v.val;
#line 492
  m = ValStack[(ValStackPtr - info->nargs) + 1].v.val - 1;
#line 493
  d = ValStack[(ValStackPtr - info->nargs) + 2].v.val;
#line 495
  tmp = DateOK(y, m, d);
  }
#line 495
  if (! tmp) {
#line 495
    return (24);
  }
  {
#line 496
  tmp___0 = Julian(y, m, d);
#line 496
  info->retval.v.val = tmp___0 * 1440 + ValStack[(ValStackPtr - info->nargs) + 3].v.val;
  }
#line 497
  return (0);
  case_5: /* CIL Label */ 
#line 499
  if ((int )ValStack[ValStackPtr - info->nargs].type != 1) {
#line 503
    return (14);
  } else
#line 499
  if ((int )ValStack[(ValStackPtr - info->nargs) + 1].type != 1) {
#line 503
    return (14);
  } else
#line 499
  if ((int )ValStack[(ValStackPtr - info->nargs) + 2].type != 1) {
#line 503
    return (14);
  } else
#line 499
  if ((int )ValStack[(ValStackPtr - info->nargs) + 3].type != 1) {
#line 503
    return (14);
  } else
#line 499
  if ((int )ValStack[(ValStackPtr - info->nargs) + 4].type != 1) {
#line 503
    return (14);
  }
  {
#line 505
  y = ValStack[ValStackPtr - info->nargs].v.val;
#line 506
  m = ValStack[(ValStackPtr - info->nargs) + 1].v.val - 1;
#line 507
  d = ValStack[(ValStackPtr - info->nargs) + 2].v.val;
#line 508
  tmp___1 = DateOK(y, m, d);
  }
#line 508
  if (! tmp___1) {
#line 508
    return (24);
  }
#line 510
  if (ValStack[(ValStackPtr - info->nargs) + 3].v.val < 0) {
#line 510
    return (29);
  } else
#line 510
  if (ValStack[(ValStackPtr - info->nargs) + 4].v.val < 0) {
#line 510
    return (29);
  }
#line 511
  if (ValStack[(ValStackPtr - info->nargs) + 3].v.val > 23) {
#line 511
    return (28);
  } else
#line 511
  if (ValStack[(ValStackPtr - info->nargs) + 4].v.val > 59) {
#line 511
    return (28);
  }
  {
#line 512
  tmp___2 = Julian(y, m, d);
#line 512
  info->retval.v.val = (tmp___2 * 1440 + ValStack[(ValStackPtr - info->nargs) + 3].v.val * 60) + ValStack[(ValStackPtr - info->nargs) + 4].v.val;
  }
#line 513
  return (0);
  switch_default: /* CIL Label */ 
#line 516
  return (26);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 525 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FCoerce(func_info *info ) 
{ 
  char const   *s ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 529
  if ((int )ValStack[ValStackPtr - info->nargs].type != 4) {
#line 529
    return (14);
  }
  {
#line 530
  s = (char const   *)ValStack[ValStackPtr - info->nargs].v.str;
#line 534
  info->retval = ValStack[(ValStackPtr - info->nargs) + 1];
#line 534
  ValStack[(ValStackPtr - info->nargs) + 1].type = (char)0;
#line 536
  tmp___8 = StrCmpi(s, "int");
  }
#line 536
  if (tmp___8) {
    {
#line 537
    tmp___7 = StrCmpi(s, "date");
    }
#line 537
    if (tmp___7) {
      {
#line 538
      tmp___6 = StrCmpi(s, "time");
      }
#line 538
      if (tmp___6) {
        {
#line 539
        tmp___5 = StrCmpi(s, "string");
        }
#line 539
        if (tmp___5) {
          {
#line 540
          tmp___4 = StrCmpi(s, "datetime");
          }
#line 540
          if (tmp___4) {
#line 541
            return (13);
          } else {
            {
#line 540
            tmp___3 = DoCoerce((char)5, & info->retval);
            }
#line 540
            return (tmp___3);
          }
        } else {
          {
#line 539
          tmp___2 = DoCoerce((char)4, & info->retval);
          }
#line 539
          return (tmp___2);
        }
      } else {
        {
#line 538
        tmp___1 = DoCoerce((char)2, & info->retval);
        }
#line 538
        return (tmp___1);
      }
    } else {
      {
#line 537
      tmp___0 = DoCoerce((char)3, & info->retval);
      }
#line 537
      return (tmp___0);
    }
  } else {
    {
#line 536
    tmp = DoCoerce((char)1, & info->retval);
    }
#line 536
    return (tmp);
  }
}
}
#line 549 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FMax(func_info *info ) 
{ 
  Value *maxptr ;
  int i ;
  char type ;
  int tmp ;

  {
#line 555
  maxptr = & ValStack[ValStackPtr - info->nargs];
#line 556
  type = maxptr->type;
#line 558
  i = 1;
  {
#line 558
  while (1) {
    while_continue: /* CIL Label */ ;
#line 558
    if (! (i < info->nargs)) {
#line 558
      goto while_break;
    }
#line 559
    if ((int )ValStack[(ValStackPtr - info->nargs) + i].type != (int )type) {
#line 559
      return (14);
    }
#line 560
    if ((int )type != 4) {
#line 561
      if (ValStack[(ValStackPtr - info->nargs) + i].v.val > maxptr->v.val) {
#line 561
        maxptr = & ValStack[(ValStackPtr - info->nargs) + i];
      }
    } else {
      {
#line 563
      tmp = strcmp((char const   *)ValStack[(ValStackPtr - info->nargs) + i].v.str,
                   (char const   *)maxptr->v.str);
      }
#line 563
      if (tmp > 0) {
#line 563
        maxptr = & ValStack[(ValStackPtr - info->nargs) + i];
      }
    }
#line 558
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 566
  info->retval = *maxptr;
#line 566
  maxptr->type = (char)0;
#line 567
  return (0);
}
}
#line 575 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FMin(func_info *info ) 
{ 
  Value *minptr ;
  int i ;
  char type ;
  int tmp ;

  {
#line 581
  minptr = & ValStack[ValStackPtr - info->nargs];
#line 582
  type = minptr->type;
#line 584
  i = 1;
  {
#line 584
  while (1) {
    while_continue: /* CIL Label */ ;
#line 584
    if (! (i < info->nargs)) {
#line 584
      goto while_break;
    }
#line 585
    if ((int )ValStack[(ValStackPtr - info->nargs) + i].type != (int )type) {
#line 585
      return (14);
    }
#line 586
    if ((int )type != 4) {
#line 587
      if (ValStack[(ValStackPtr - info->nargs) + i].v.val < minptr->v.val) {
#line 587
        minptr = & ValStack[(ValStackPtr - info->nargs) + i];
      }
    } else {
      {
#line 589
      tmp = strcmp((char const   *)ValStack[(ValStackPtr - info->nargs) + i].v.str,
                   (char const   *)minptr->v.str);
      }
#line 589
      if (tmp < 0) {
#line 589
        minptr = & ValStack[(ValStackPtr - info->nargs) + i];
      }
    }
#line 584
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 592
  info->retval = *minptr;
#line 592
  minptr->type = (char)0;
#line 593
  return (0);
}
}
#line 601 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FAsc(func_info *info ) 
{ 


  {
#line 603
  if ((int )ValStack[ValStackPtr - info->nargs].type != 4) {
#line 603
    return (14);
  }
#line 604
  info->retval.type = (char)1;
#line 605
  info->retval.v.val = (int )*(ValStack[ValStackPtr - info->nargs].v.str);
#line 606
  return (0);
}
}
#line 614 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FChar(func_info *info ) 
{ 
  int i ;
  int len ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 620
  if (info->nargs == 1) {
#line 621
    if ((int )ValStack[ValStackPtr - info->nargs].type != 1) {
#line 621
      return (14);
    }
#line 622
    if (ValStack[ValStackPtr - info->nargs].v.val < -128) {
#line 622
      return (29);
    }
#line 623
    if (ValStack[ValStackPtr - info->nargs].v.val > 255) {
#line 623
      return (28);
    }
#line 624
    if (ValStack[ValStackPtr - info->nargs].v.val) {
#line 624
      len = 2;
    } else {
#line 624
      len = 1;
    }
    {
#line 625
    tmp = malloc((size_t )len);
#line 625
    info->retval.v.str = (char *)tmp;
    }
#line 626
    if (! info->retval.v.str) {
#line 626
      return (9);
    }
#line 627
    info->retval.type = (char)4;
#line 628
    *(info->retval.v.str) = (char )ValStack[ValStackPtr - info->nargs].v.val;
#line 629
    if (len > 1) {
#line 629
      *(info->retval.v.str + 1) = (char)0;
    }
#line 630
    return (0);
  }
  {
#line 633
  tmp___0 = malloc((size_t )(info->nargs + 1));
#line 633
  info->retval.v.str = (char *)tmp___0;
  }
#line 634
  if (! info->retval.v.str) {
#line 634
    return (9);
  }
#line 635
  info->retval.type = (char)4;
#line 636
  i = 0;
  {
#line 636
  while (1) {
    while_continue: /* CIL Label */ ;
#line 636
    if (! (i < info->nargs)) {
#line 636
      goto while_break;
    }
#line 637
    if ((int )ValStack[(ValStackPtr - info->nargs) + i].type != 1) {
      {
#line 638
      free((void *)info->retval.v.str);
#line 639
      info->retval.type = (char)0;
      }
#line 640
      return (14);
    }
#line 642
    if (ValStack[(ValStackPtr - info->nargs) + i].v.val < -128) {
      {
#line 643
      free((void *)info->retval.v.str);
#line 644
      info->retval.type = (char)0;
      }
#line 645
      return (29);
    } else
#line 642
    if (ValStack[(ValStackPtr - info->nargs) + i].v.val == 0) {
      {
#line 643
      free((void *)info->retval.v.str);
#line 644
      info->retval.type = (char)0;
      }
#line 645
      return (29);
    }
#line 647
    if (ValStack[(ValStackPtr - info->nargs) + i].v.val > 255) {
      {
#line 648
      free((void *)info->retval.v.str);
#line 649
      info->retval.type = (char)0;
      }
#line 650
      return (28);
    }
#line 652
    *(info->retval.v.str + i) = (char )ValStack[(ValStackPtr - info->nargs) + i].v.val;
#line 636
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 654
  *(info->retval.v.str + info->nargs) = (char)0;
#line 655
  return (0);
}
}
#line 669 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FDay(func_info *info ) 
{ 
  int y ;
  int m ;
  int d ;
  int v ;

  {
#line 672
  if (! ((int )ValStack[ValStackPtr - info->nargs].type == 3)) {
#line 672
    if (! ((int )ValStack[ValStackPtr - info->nargs].type == 5)) {
#line 672
      return (14);
    }
  }
#line 673
  if ((int )ValStack[ValStackPtr - info->nargs].type == 3) {
#line 673
    v = ValStack[ValStackPtr - info->nargs].v.val;
  } else {
#line 673
    v = ValStack[ValStackPtr - info->nargs].v.val / 1440;
  }
#line 675
  if (v == CacheJul) {
#line 676
    d = CacheDay;
  } else {
    {
#line 678
    FromJulian(v, & y, & m, & d);
#line 679
    CacheJul = v;
#line 680
    CacheYear = y;
#line 681
    CacheMon = m;
#line 682
    CacheDay = d;
    }
  }
#line 684
  info->retval.type = (char)1;
#line 685
  info->retval.v.val = d;
#line 686
  return (0);
}
}
#line 689 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FMonnum(func_info *info ) 
{ 
  int y ;
  int m ;
  int d ;
  int v ;

  {
#line 692
  if (! ((int )ValStack[ValStackPtr - info->nargs].type == 3)) {
#line 692
    if (! ((int )ValStack[ValStackPtr - info->nargs].type == 5)) {
#line 692
      return (14);
    }
  }
#line 693
  if ((int )ValStack[ValStackPtr - info->nargs].type == 3) {
#line 693
    v = ValStack[ValStackPtr - info->nargs].v.val;
  } else {
#line 693
    v = ValStack[ValStackPtr - info->nargs].v.val / 1440;
  }
#line 695
  if (v == CacheJul) {
#line 696
    m = CacheMon;
  } else {
    {
#line 698
    FromJulian(v, & y, & m, & d);
#line 699
    CacheJul = v;
#line 700
    CacheYear = y;
#line 701
    CacheMon = m;
#line 702
    CacheDay = d;
    }
  }
#line 704
  info->retval.type = (char)1;
#line 705
  info->retval.v.val = m + 1;
#line 706
  return (0);
}
}
#line 709 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FYear(func_info *info ) 
{ 
  int y ;
  int m ;
  int d ;
  int v ;

  {
#line 712
  if (! ((int )ValStack[ValStackPtr - info->nargs].type == 3)) {
#line 712
    if (! ((int )ValStack[ValStackPtr - info->nargs].type == 5)) {
#line 712
      return (14);
    }
  }
#line 713
  if ((int )ValStack[ValStackPtr - info->nargs].type == 3) {
#line 713
    v = ValStack[ValStackPtr - info->nargs].v.val;
  } else {
#line 713
    v = ValStack[ValStackPtr - info->nargs].v.val / 1440;
  }
#line 715
  if (v == CacheJul) {
#line 716
    y = CacheYear;
  } else {
    {
#line 718
    FromJulian(v, & y, & m, & d);
#line 719
    CacheJul = v;
#line 720
    CacheYear = y;
#line 721
    CacheMon = m;
#line 722
    CacheDay = d;
    }
  }
#line 724
  info->retval.type = (char)1;
#line 725
  info->retval.v.val = y;
#line 726
  return (0);
}
}
#line 729 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FWkdaynum(func_info *info ) 
{ 
  int v ;

  {
#line 732
  if (! ((int )ValStack[ValStackPtr - info->nargs].type == 3)) {
#line 732
    if (! ((int )ValStack[ValStackPtr - info->nargs].type == 5)) {
#line 732
      return (14);
    }
  }
#line 733
  if ((int )ValStack[ValStackPtr - info->nargs].type == 3) {
#line 733
    v = ValStack[ValStackPtr - info->nargs].v.val;
  } else {
#line 733
    v = ValStack[ValStackPtr - info->nargs].v.val / 1440;
  }
#line 735
  info->retval.type = (char)1;
#line 738
  info->retval.v.val = (v + 1) % 7;
#line 739
  return (0);
}
}
#line 742 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FWkday(func_info *info ) 
{ 
  char const   *s ;
  int tmp ;
  int tmp___0 ;

  {
#line 746
  if (! ((int )ValStack[ValStackPtr - info->nargs].type == 3)) {
#line 746
    if (! ((int )ValStack[ValStackPtr - info->nargs].type == 5)) {
#line 746
      if ((int )ValStack[ValStackPtr - info->nargs].type != 1) {
#line 746
        return (14);
      }
    }
  }
#line 747
  if ((int )ValStack[ValStackPtr - info->nargs].type == 1) {
#line 748
    if (ValStack[ValStackPtr - info->nargs].v.val < 0) {
#line 748
      return (29);
    }
#line 749
    if (ValStack[ValStackPtr - info->nargs].v.val > 6) {
#line 749
      return (28);
    }
#line 751
    (ValStack[ValStackPtr - info->nargs].v.val) --;
#line 752
    if (ValStack[ValStackPtr - info->nargs].v.val < 0) {
#line 752
      ValStack[ValStackPtr - info->nargs].v.val = 6;
    }
#line 753
    s = (char const   *)EnglishDayName[ValStack[ValStackPtr - info->nargs].v.val];
  } else {
#line 754
    if ((int )ValStack[ValStackPtr - info->nargs].type == 3) {
#line 754
      tmp = ValStack[ValStackPtr - info->nargs].v.val;
    } else {
#line 754
      tmp = ValStack[ValStackPtr - info->nargs].v.val / 1440;
    }
#line 754
    s = (char const   *)EnglishDayName[tmp % 7];
  }
  {
#line 755
  tmp___0 = RetStrVal(s, info);
  }
#line 755
  return (tmp___0);
}
}
#line 758 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FMon(func_info *info ) 
{ 
  char const   *s ;
  int y ;
  int m ;
  int d ;
  int v ;
  int tmp ;

  {
#line 763
  if (! ((int )ValStack[ValStackPtr - info->nargs].type == 3)) {
#line 763
    if (! ((int )ValStack[ValStackPtr - info->nargs].type == 5)) {
#line 763
      if ((int )ValStack[ValStackPtr - info->nargs].type != 1) {
#line 763
        return (14);
      }
    }
  }
#line 765
  if ((int )ValStack[ValStackPtr - info->nargs].type == 1) {
#line 766
    m = ValStack[ValStackPtr - info->nargs].v.val - 1;
#line 767
    if (m < 0) {
#line 767
      return (29);
    }
#line 768
    if (m > 11) {
#line 768
      return (28);
    }
  } else {
#line 770
    if ((int )ValStack[ValStackPtr - info->nargs].type == 3) {
#line 770
      v = ValStack[ValStackPtr - info->nargs].v.val;
    } else {
#line 770
      v = ValStack[ValStackPtr - info->nargs].v.val / 1440;
    }
#line 771
    if (v == CacheJul) {
#line 772
      m = CacheMon;
    } else {
      {
#line 774
      FromJulian(v, & y, & m, & d);
#line 775
      CacheJul = v;
#line 776
      CacheYear = y;
#line 777
      CacheMon = m;
#line 778
      CacheDay = d;
      }
    }
  }
  {
#line 781
  s = (char const   *)EnglishMonthName[m];
#line 782
  tmp = RetStrVal(s, info);
  }
#line 782
  return (tmp);
}
}
#line 792 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FHour(func_info *info ) 
{ 
  int v ;

  {
#line 795
  if (! ((int )ValStack[ValStackPtr - info->nargs].type == 2)) {
#line 795
    if (! ((int )ValStack[ValStackPtr - info->nargs].type == 5)) {
#line 795
      return (14);
    }
  }
#line 796
  if ((int )ValStack[ValStackPtr - info->nargs].type == 2) {
#line 796
    v = ValStack[ValStackPtr - info->nargs].v.val;
  } else {
#line 796
    v = ValStack[ValStackPtr - info->nargs].v.val % 1440;
  }
#line 797
  info->retval.type = (char)1;
#line 798
  info->retval.v.val = v / 60;
#line 799
  return (0);
}
}
#line 802 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FMinute(func_info *info ) 
{ 
  int v ;

  {
#line 805
  if (! ((int )ValStack[ValStackPtr - info->nargs].type == 2)) {
#line 805
    if (! ((int )ValStack[ValStackPtr - info->nargs].type == 5)) {
#line 805
      return (14);
    }
  }
#line 806
  if ((int )ValStack[ValStackPtr - info->nargs].type == 2) {
#line 806
    v = ValStack[ValStackPtr - info->nargs].v.val;
  } else {
#line 806
    v = ValStack[ValStackPtr - info->nargs].v.val % 1440;
  }
#line 807
  info->retval.type = (char)1;
#line 808
  info->retval.v.val = v % 60;
#line 809
  return (0);
}
}
#line 812 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FTime(func_info *info ) 
{ 
  int h ;
  int m ;

  {
#line 816
  if ((int )ValStack[ValStackPtr - info->nargs].type != 1) {
#line 816
    return (14);
  } else
#line 816
  if ((int )ValStack[(ValStackPtr - info->nargs) + 1].type != 1) {
#line 816
    return (14);
  }
#line 818
  h = ValStack[ValStackPtr - info->nargs].v.val;
#line 819
  m = ValStack[(ValStackPtr - info->nargs) + 1].v.val;
#line 820
  if (h < 0) {
#line 820
    return (29);
  } else
#line 820
  if (m < 0) {
#line 820
    return (29);
  }
#line 821
  if (h > 23) {
#line 821
    return (28);
  } else
#line 821
  if (m > 59) {
#line 821
    return (28);
  }
#line 822
  info->retval.type = (char)2;
#line 823
  info->retval.v.val = h * 60 + m;
#line 824
  return (0);
}
}
#line 833 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FAbs(func_info *info ) 
{ 
  int v ;

  {
#line 837
  if ((int )ValStack[ValStackPtr - info->nargs].type != 1) {
#line 837
    return (14);
  }
#line 838
  v = ValStack[ValStackPtr - info->nargs].v.val;
#line 839
  info->retval.type = (char)1;
#line 840
  if (v < 0) {
#line 840
    info->retval.v.val = - v;
  } else {
#line 840
    info->retval.v.val = v;
  }
#line 841
  return (0);
}
}
#line 844 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FSgn(func_info *info ) 
{ 
  int v ;

  {
#line 848
  if ((int )ValStack[ValStackPtr - info->nargs].type != 1) {
#line 848
    return (14);
  }
#line 849
  v = ValStack[ValStackPtr - info->nargs].v.val;
#line 850
  info->retval.type = (char)1;
#line 851
  if (v > 0) {
#line 851
    info->retval.v.val = 1;
  } else
#line 852
  if (v < 0) {
#line 852
    info->retval.v.val = -1;
  } else {
#line 853
    info->retval.v.val = 0;
  }
#line 854
  return (0);
}
}
#line 864 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FOrd(func_info *info ) 
{ 
  int t ;
  int u ;
  int v ;
  char const   *s ;
  char buf___1[32] ;
  int tmp ;

  {
#line 871
  if ((int )ValStack[ValStackPtr - info->nargs].type != 1) {
#line 871
    return (14);
  }
#line 873
  v = ValStack[ValStackPtr - info->nargs].v.val;
#line 874
  t = v % 100;
#line 875
  if (t < 0) {
#line 875
    t = - t;
  }
#line 876
  u = t % 10;
#line 877
  s = "th";
#line 878
  if (u == 1) {
#line 878
    if (t != 11) {
#line 878
      s = "st";
    }
  }
#line 879
  if (u == 2) {
#line 879
    if (t != 12) {
#line 879
      s = "nd";
    }
  }
#line 880
  if (u == 3) {
#line 880
    if (t != 13) {
#line 880
      s = "rd";
    }
  }
  {
#line 881
  sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"%d%s",
          v, s);
#line 882
  tmp = RetStrVal((char const   *)(buf___1), info);
  }
#line 882
  return (tmp);
}
}
#line 894 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FPlural(func_info *info ) 
{ 
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
#line 896
  if ((int )ValStack[ValStackPtr - info->nargs].type != 1) {
#line 896
    return (14);
  }
  {
#line 899
  if (info->nargs == 1) {
#line 899
    goto case_1;
  }
#line 903
  if (info->nargs == 2) {
#line 903
    goto case_2;
  }
#line 919
  goto switch_default;
  case_1: /* CIL Label */ 
#line 900
  if (ValStack[ValStackPtr - info->nargs].v.val == 1) {
    {
#line 900
    tmp = RetStrVal("", info);
    }
#line 900
    return (tmp);
  } else {
    {
#line 901
    tmp___0 = RetStrVal("s", info);
    }
#line 901
    return (tmp___0);
  }
  case_2: /* CIL Label */ 
#line 904
  if ((int )ValStack[(ValStackPtr - info->nargs) + 1].type != 4) {
#line 904
    return (14);
  }
#line 905
  if (ValStack[ValStackPtr - info->nargs].v.val == 1) {
#line 906
    info->retval = ValStack[(ValStackPtr - info->nargs) + 1];
#line 906
    ValStack[(ValStackPtr - info->nargs) + 1].type = (char)0;
#line 907
    return (0);
  }
  {
#line 909
  info->retval.type = (char)4;
#line 910
  tmp___1 = strlen((char const   *)ValStack[(ValStackPtr - info->nargs) + 1].v.str);
#line 910
  tmp___2 = malloc(tmp___1 + 2UL);
#line 910
  info->retval.v.str = (char *)tmp___2;
  }
#line 911
  if (! info->retval.v.str) {
#line 912
    info->retval.type = (char)0;
#line 913
    return (9);
  }
  {
#line 915
  strcpy((char */* __restrict  */)info->retval.v.str, (char const   */* __restrict  */)ValStack[(ValStackPtr - info->nargs) + 1].v.str);
#line 916
  strcat((char */* __restrict  */)info->retval.v.str, (char const   */* __restrict  */)"s");
  }
#line 917
  return (0);
  switch_default: /* CIL Label */ 
#line 920
  if ((int )ValStack[(ValStackPtr - info->nargs) + 1].type != 4) {
#line 921
    return (14);
  } else
#line 920
  if ((int )ValStack[(ValStackPtr - info->nargs) + 2].type != 4) {
#line 921
    return (14);
  }
#line 922
  if (ValStack[ValStackPtr - info->nargs].v.val == 1) {
#line 922
    info->retval = ValStack[(ValStackPtr - info->nargs) + 1];
#line 922
    ValStack[(ValStackPtr - info->nargs) + 1].type = (char)0;
  } else {
#line 923
    info->retval = ValStack[(ValStackPtr - info->nargs) + 2];
#line 923
    ValStack[(ValStackPtr - info->nargs) + 2].type = (char)0;
  }
#line 924
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 936 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FChoose(func_info *info ) 
{ 
  int v ;

  {
#line 940
  if ((int )ValStack[ValStackPtr - info->nargs].type != 1) {
#line 940
    return (14);
  }
#line 941
  v = ValStack[ValStackPtr - info->nargs].v.val;
#line 942
  if (v < 1) {
#line 942
    v = 1;
  }
#line 943
  if (v > info->nargs - 1) {
#line 943
    v = info->nargs - 1;
  }
#line 944
  info->retval = ValStack[(ValStackPtr - info->nargs) + v];
#line 944
  ValStack[(ValStackPtr - info->nargs) + v].type = (char)0;
#line 945
  return (0);
}
}
#line 953 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FVersion(func_info *info ) 
{ 
  int tmp ;

  {
  {
#line 955
  tmp = RetStrVal("03.01.13", info);
  }
#line 955
  return (tmp);
}
}
#line 964 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FOstype(func_info *info ) 
{ 
  int tmp ;

  {
  {
#line 966
  tmp = RetStrVal("UNIX", info);
  }
#line 966
  return (tmp);
}
}
#line 975 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FUpper(func_info *info ) 
{ 
  char *s ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
#line 979
  if ((int )ValStack[ValStackPtr - info->nargs].type != 4) {
#line 979
    return (14);
  }
#line 980
  info->retval = ValStack[ValStackPtr - info->nargs];
#line 980
  ValStack[ValStackPtr - info->nargs].type = (char)0;
#line 981
  s = info->retval.v.str;
  {
#line 982
  while (1) {
    while_continue: /* CIL Label */ ;
#line 982
    if (! *s) {
#line 982
      goto while_break;
    }
    {
#line 983
    tmp___1 = __ctype_b_loc();
    }
#line 983
    if ((int const   )*(*tmp___1 + (int )*s) & 512) {
      {
#line 983
      tmp___0 = toupper((int )*s);
#line 983
      *s = (char )tmp___0;
      }
    } else {
#line 983
      *s = *s;
    }
#line 984
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 986
  return (0);
}
}
#line 989 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FLower(func_info *info ) 
{ 
  char *s ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
#line 993
  if ((int )ValStack[ValStackPtr - info->nargs].type != 4) {
#line 993
    return (14);
  }
#line 994
  info->retval = ValStack[ValStackPtr - info->nargs];
#line 994
  ValStack[ValStackPtr - info->nargs].type = (char)0;
#line 995
  s = info->retval.v.str;
  {
#line 996
  while (1) {
    while_continue: /* CIL Label */ ;
#line 996
    if (! *s) {
#line 996
      goto while_break;
    }
    {
#line 997
    tmp___1 = __ctype_b_loc();
    }
#line 997
    if ((int const   )*(*tmp___1 + (int )*s) & 256) {
      {
#line 997
      tmp___0 = tolower((int )*s);
#line 997
      *s = (char )tmp___0;
      }
    } else {
#line 997
      *s = *s;
    }
#line 998
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1000
  return (0);
}
}
#line 1011 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FToday(func_info *info ) 
{ 


  {
#line 1013
  info->retval.type = (char)3;
#line 1014
  info->retval.v.val = JulianToday;
#line 1015
  return (0);
}
}
#line 1018 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FRealtoday(func_info *info ) 
{ 


  {
#line 1020
  info->retval.type = (char)3;
#line 1021
  info->retval.v.val = RealToday;
#line 1022
  return (0);
}
}
#line 1025 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FNow(func_info *info ) 
{ 
  long tmp ;

  {
  {
#line 1027
  info->retval.type = (char)2;
#line 1028
  tmp = SystemTime(0);
#line 1028
  info->retval.v.val = (int )(tmp / 60L);
  }
#line 1029
  return (0);
}
}
#line 1032 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FRealnow(func_info *info ) 
{ 
  long tmp ;

  {
  {
#line 1034
  info->retval.type = (char)2;
#line 1035
  tmp = SystemTime(1);
#line 1035
  info->retval.v.val = (int )(tmp / 60L);
  }
#line 1036
  return (0);
}
}
#line 1039 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FCurrent(func_info *info ) 
{ 
  long tmp ;

  {
  {
#line 1041
  info->retval.type = (char)5;
#line 1042
  tmp = SystemTime(0);
#line 1042
  info->retval.v.val = (int )((long )(JulianToday * 1440) + tmp / 60L);
  }
#line 1043
  return (0);
}
}
#line 1046 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FRealCurrent(func_info *info ) 
{ 
  long tmp ;

  {
  {
#line 1048
  info->retval.type = (char)5;
#line 1049
  tmp = SystemTime(1);
#line 1049
  info->retval.v.val = (int )((long )(RealToday * 1440) + tmp / 60L);
  }
#line 1050
  return (0);
}
}
#line 1058 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FGetenv(func_info *info ) 
{ 
  char *tmp ;
  int tmp___0 ;

  {
#line 1060
  if ((int )ValStack[ValStackPtr - info->nargs].type != 4) {
#line 1060
    return (14);
  }
  {
#line 1061
  tmp = getenv((char const   *)ValStack[ValStackPtr - info->nargs].v.str);
#line 1061
  tmp___0 = RetStrVal((char const   *)tmp, info);
  }
#line 1061
  return (tmp___0);
}
}
#line 1072 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FValue(func_info *info ) 
{ 
  Var *v ;
  int tmp ;
  int tmp___0 ;

  {
#line 1076
  if ((int )ValStack[ValStackPtr - info->nargs].type != 4) {
#line 1076
    return (14);
  }
  {
#line 1078
  if (info->nargs == 1) {
#line 1078
    goto case_1;
  }
#line 1081
  if (info->nargs == 2) {
#line 1081
    goto case_2;
  }
#line 1077
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1079
  tmp = GetVarValue((char const   *)ValStack[ValStackPtr - info->nargs].v.str, & info->retval,
                    (Var *)((void *)0), (ParsePtr )((void *)0));
  }
#line 1079
  return (tmp);
  case_2: /* CIL Label */ 
  {
#line 1082
  v = FindVar((char const   *)ValStack[ValStackPtr - info->nargs].v.str, 0);
  }
#line 1083
  if (! v) {
#line 1084
    info->retval = ValStack[(ValStackPtr - info->nargs) + 1];
#line 1084
    ValStack[(ValStackPtr - info->nargs) + 1].type = (char)0;
#line 1085
    return (0);
  } else {
    {
#line 1087
    tmp___0 = CopyValue(& info->retval, (Value const   *)(& v->v));
    }
#line 1087
    return (tmp___0);
  }
  switch_break: /* CIL Label */ ;
  }
#line 1090
  return (0);
}
}
#line 1100 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FDefined(func_info *info ) 
{ 
  Var *tmp ;

  {
#line 1102
  if ((int )ValStack[ValStackPtr - info->nargs].type != 4) {
#line 1102
    return (14);
  }
  {
#line 1104
  info->retval.type = (char)1;
#line 1106
  tmp = FindVar((char const   *)ValStack[ValStackPtr - info->nargs].v.str, 0);
  }
#line 1106
  if (tmp) {
#line 1107
    info->retval.v.val = 1;
  } else {
#line 1109
    info->retval.v.val = 0;
  }
#line 1110
  return (0);
}
}
#line 1121 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FTrigdate(func_info *info ) 
{ 


  {
#line 1123
  if (LastTrigValid) {
#line 1124
    info->retval.type = (char)3;
#line 1125
    info->retval.v.val = LastTriggerDate;
  } else {
#line 1127
    info->retval.type = (char)1;
#line 1128
    info->retval.v.val = 0;
  }
#line 1130
  return (0);
}
}
#line 1133 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FTrigvalid(func_info *info ) 
{ 


  {
#line 1135
  info->retval.type = (char)1;
#line 1136
  info->retval.v.val = LastTrigValid;
#line 1137
  return (0);
}
}
#line 1140 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FTrigtime(func_info *info ) 
{ 


  {
#line 1142
  if (LastTriggerTime != 2147483647) {
#line 1143
    info->retval.type = (char)2;
#line 1144
    info->retval.v.val = LastTriggerTime;
  } else {
#line 1146
    info->retval.type = (char)1;
#line 1147
    info->retval.v.val = 0;
  }
#line 1149
  return (0);
}
}
#line 1152 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FTrigdatetime(func_info *info ) 
{ 


  {
#line 1154
  if (! LastTrigValid) {
#line 1155
    info->retval.type = (char)1;
#line 1156
    info->retval.v.val = 0;
  } else
#line 1157
  if (LastTriggerTime != 2147483647) {
#line 1158
    info->retval.type = (char)5;
#line 1159
    info->retval.v.val = LastTriggerDate * 1440 + LastTriggerTime;
  } else {
#line 1161
    info->retval.type = (char)3;
#line 1162
    info->retval.v.val = LastTriggerDate;
  }
#line 1164
  return (0);
}
}
#line 1174 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FDaysinmon(func_info *info ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1176
  if ((int )ValStack[ValStackPtr - info->nargs].type != 1) {
#line 1176
    return (14);
  } else
#line 1176
  if ((int )ValStack[(ValStackPtr - info->nargs) + 1].type != 1) {
#line 1176
    return (14);
  }
#line 1178
  if (ValStack[ValStackPtr - info->nargs].v.val > 12) {
#line 1180
    return (41);
  } else
#line 1178
  if (ValStack[ValStackPtr - info->nargs].v.val < 1) {
#line 1180
    return (41);
  } else
#line 1178
  if (ValStack[(ValStackPtr - info->nargs) + 1].v.val < 1990) {
#line 1180
    return (41);
  } else
#line 1178
  if (ValStack[(ValStackPtr - info->nargs) + 1].v.val > 5990) {
#line 1180
    return (41);
  }
#line 1182
  info->retval.type = (char)1;
#line 1183
  if (ValStack[ValStackPtr - info->nargs].v.val - 1 != 1) {
#line 1183
    info->retval.v.val = MonthDays[ValStack[ValStackPtr - info->nargs].v.val - 1];
  } else {
#line 1183
    if (ValStack[(ValStackPtr - info->nargs) + 1].v.val % 4) {
#line 1183
      tmp___0 = 0;
    } else {
#line 1183
      if (! (ValStack[(ValStackPtr - info->nargs) + 1].v.val % 100)) {
#line 1183
        if (ValStack[(ValStackPtr - info->nargs) + 1].v.val % 400) {
#line 1183
          tmp = 0;
        } else {
#line 1183
          tmp = 1;
        }
      } else {
#line 1183
        tmp = 1;
      }
#line 1183
      tmp___0 = tmp;
    }
#line 1183
    info->retval.v.val = 28 + tmp___0;
  }
#line 1184
  return (0);
}
}
#line 1194 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FIsleap(func_info *info ) 
{ 
  int y ;
  int m ;
  int d ;
  int tmp ;
  int tmp___0 ;

  {
#line 1198
  if ((int )ValStack[ValStackPtr - info->nargs].type != 1) {
#line 1198
    if (! ((int )ValStack[ValStackPtr - info->nargs].type == 3)) {
#line 1198
      if (! ((int )ValStack[ValStackPtr - info->nargs].type == 5)) {
#line 1198
        return (14);
      }
    }
  }
#line 1201
  if ((int )ValStack[ValStackPtr - info->nargs].type == 3) {
#line 1201
    goto _L;
  } else
#line 1201
  if ((int )ValStack[ValStackPtr - info->nargs].type == 5) {
    _L: /* CIL Label */ 
#line 1202
    if ((int )ValStack[ValStackPtr - info->nargs].type == 3) {
#line 1202
      tmp = ValStack[ValStackPtr - info->nargs].v.val;
    } else {
#line 1202
      tmp = ValStack[ValStackPtr - info->nargs].v.val / 1440;
    }
    {
#line 1202
    FromJulian(tmp, & y, & m, & d);
    }
  } else {
#line 1204
    y = ValStack[ValStackPtr - info->nargs].v.val;
  }
#line 1206
  info->retval.type = (char)1;
#line 1207
  if (y % 4) {
#line 1207
    info->retval.v.val = 0;
  } else {
#line 1207
    if (! (y % 100)) {
#line 1207
      if (y % 400) {
#line 1207
        tmp___0 = 0;
      } else {
#line 1207
        tmp___0 = 1;
      }
    } else {
#line 1207
      tmp___0 = 1;
    }
#line 1207
    info->retval.v.val = tmp___0;
  }
#line 1208
  return (0);
}
}
#line 1218 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FTrigger(func_info *info ) 
{ 
  int y ;
  int m ;
  int d ;
  int date ;
  int tim ;
  char buf___1[128] ;
  int tmp ;

  {
#line 1224
  tim = 2147483647;
#line 1225
  if ((int )ValStack[ValStackPtr - info->nargs].type != 3) {
#line 1225
    if ((int )ValStack[ValStackPtr - info->nargs].type != 5) {
#line 1226
      return (14);
    }
  }
#line 1228
  if ((int )ValStack[ValStackPtr - info->nargs].type == 3) {
#line 1229
    date = ValStack[ValStackPtr - info->nargs].v.val;
  } else {
#line 1231
    date = ValStack[ValStackPtr - info->nargs].v.val / 1440;
#line 1232
    tim = ValStack[ValStackPtr - info->nargs].v.val % 1440;
  }
#line 1235
  if ((int )ValStack[ValStackPtr - info->nargs].type == 3) {
#line 1236
    if (info->nargs > 2) {
#line 1238
      if ((int )ValStack[ValStackPtr - info->nargs].type == 5) {
#line 1238
        return (14);
      }
#line 1239
      if ((int )ValStack[(ValStackPtr - info->nargs) + 2].type != 1) {
#line 1239
        return (14);
      }
#line 1240
      if ((int )ValStack[(ValStackPtr - info->nargs) + 1].type != 2) {
#line 1240
        return (14);
      }
#line 1241
      tim = ValStack[(ValStackPtr - info->nargs) + 1].v.val;
#line 1242
      if (ValStack[(ValStackPtr - info->nargs) + 2].v.val) {
        {
#line 1243
        UTCToLocal(date, tim, & date, & tim);
        }
      }
    } else
#line 1245
    if (info->nargs > 1) {
#line 1247
      if ((int )ValStack[(ValStackPtr - info->nargs) + 1].type != 2) {
#line 1247
        return (14);
      }
#line 1248
      tim = ValStack[(ValStackPtr - info->nargs) + 1].v.val;
    }
  } else
#line 1251
  if (info->nargs > 2) {
#line 1252
    return (26);
  } else
#line 1253
  if (info->nargs > 1) {
#line 1255
    if ((int )ValStack[(ValStackPtr - info->nargs) + 1].type != 1) {
#line 1255
      return (14);
    }
#line 1256
    if (ValStack[(ValStackPtr - info->nargs) + 1].v.val) {
      {
#line 1257
      UTCToLocal(date, tim, & date, & tim);
      }
    }
  }
  {
#line 1262
  FromJulian(date, & y, & m, & d);
  }
#line 1263
  if (tim != 2147483647) {
    {
#line 1264
    sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"%d %s %d AT %02d:%02d",
            d, EnglishMonthName[m], y, tim / 60, tim % 60);
    }
  } else {
    {
#line 1267
    sprintf((char */* __restrict  */)(buf___1), (char const   */* __restrict  */)"%d %s %d",
            d, EnglishMonthName[m], y);
    }
  }
  {
#line 1269
  tmp = RetStrVal((char const   *)(buf___1), info);
  }
#line 1269
  return (tmp);
}
}
#line 1281 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FShell(func_info *info ) 
{ 
  DynamicBuffer buf___1 ;
  int ch ;
  int r ;
  FILE *fp___0 ;
  int maxlen ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1289
  maxlen = 511;
#line 1291
  DBufInit(& buf___1);
  }
#line 1292
  if (RunDisabled) {
#line 1292
    return (40);
  }
#line 1293
  if ((int )ValStack[ValStackPtr - info->nargs].type != 4) {
#line 1293
    return (14);
  }
#line 1294
  if (info->nargs >= 2) {
#line 1295
    if ((int )ValStack[(ValStackPtr - info->nargs) + 1].type != 1) {
#line 1295
      return (14);
    }
#line 1296
    maxlen = ValStack[(ValStackPtr - info->nargs) + 1].v.val;
  }
  {
#line 1298
  fp___0 = popen((char const   *)ValStack[ValStackPtr - info->nargs].v.str, "r");
  }
#line 1299
  if (! fp___0) {
#line 1299
    return (21);
  }
  {
#line 1300
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1301
    ch = _IO_getc(fp___0);
    }
#line 1302
    if (ch == -1) {
#line 1303
      goto while_break;
    }
    {
#line 1305
    tmp = __ctype_b_loc();
    }
#line 1305
    if ((int const   )*(*tmp + ch) & 8192) {
#line 1305
      ch = ' ';
    }
#line 1306
    if (buf___1.allocatedLen < buf___1.len + 1) {
#line 1306
      tmp___0 = buf___1.len;
#line 1306
      (buf___1.len) ++;
#line 1306
      *(buf___1.buffer + tmp___0) = (char )ch;
#line 1306
      *(buf___1.buffer + buf___1.len) = (char)0;
#line 1306
      tmp___2 = 0;
    } else {
      {
#line 1306
      tmp___1 = DBufPutcFN(& buf___1, (char )ch);
#line 1306
      tmp___2 = tmp___1 != 0;
      }
    }
#line 1306
    if (tmp___2) {
      {
#line 1307
      pclose(fp___0);
#line 1308
      DBufFree(& buf___1);
      }
#line 1309
      return (9);
    }
#line 1311
    if (maxlen > 0) {
#line 1311
      if (buf___1.len >= maxlen) {
#line 1312
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1317
  if (buf___1.len) {
#line 1317
    if ((int )*(buf___1.buffer + (buf___1.len - 1)) == 32) {
#line 1318
      *(buf___1.buffer + (buf___1.len - 1)) = (char)0;
    }
  }
  {
#line 1323
  pclose(fp___0);
#line 1324
  r = RetStrVal((char const   *)buf___1.buffer, info);
#line 1325
  DBufFree(& buf___1);
  }
#line 1326
  return (r);
}
}
#line 1336 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FIsomitted(func_info *info ) 
{ 
  int r ;
  int tmp ;

  {
#line 1339
  if (! ((int )ValStack[ValStackPtr - info->nargs].type == 3)) {
#line 1339
    if (! ((int )ValStack[ValStackPtr - info->nargs].type == 5)) {
#line 1339
      return (14);
    }
  }
#line 1341
  info->retval.type = (char)1;
#line 1342
  if ((int )ValStack[ValStackPtr - info->nargs].type == 3) {
#line 1342
    tmp = ValStack[ValStackPtr - info->nargs].v.val;
  } else {
#line 1342
    tmp = ValStack[ValStackPtr - info->nargs].v.val / 1440;
  }
  {
#line 1342
  r = IsOmitted(tmp, 0, (char const   *)((void *)0), & info->retval.v.val);
  }
#line 1343
  return (r);
}
}
#line 1353 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FSubstr(func_info *info ) 
{ 
  char *s ;
  char const   *t ;
  int start ;
  int end ;
  int tmp ;
  int tmp___0 ;

  {
#line 1359
  if ((int )ValStack[ValStackPtr - info->nargs].type != 4) {
#line 1359
    return (14);
  } else
#line 1359
  if ((int )ValStack[(ValStackPtr - info->nargs) + 1].type != 1) {
#line 1359
    return (14);
  }
#line 1360
  if (info->nargs == 3) {
#line 1360
    if ((int )ValStack[(ValStackPtr - info->nargs) + 2].type != 1) {
#line 1360
      return (14);
    }
  }
#line 1362
  s = ValStack[ValStackPtr - info->nargs].v.str;
#line 1363
  start = 1;
  {
#line 1364
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1364
    if (! (start < ValStack[(ValStackPtr - info->nargs) + 1].v.val)) {
#line 1364
      goto while_break;
    }
#line 1365
    if (! *s) {
#line 1365
      goto while_break;
    }
#line 1366
    s ++;
#line 1367
    start ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1369
  if (info->nargs == 2) {
    {
#line 1369
    tmp = RetStrVal((char const   *)s, info);
    }
#line 1369
    return (tmp);
  } else
#line 1369
  if (! *s) {
    {
#line 1369
    tmp = RetStrVal((char const   *)s, info);
    }
#line 1369
    return (tmp);
  }
#line 1370
  end = start;
#line 1371
  t = (char const   *)s;
  {
#line 1372
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1372
    if (! (end <= ValStack[(ValStackPtr - info->nargs) + 2].v.val)) {
#line 1372
      goto while_break___0;
    }
#line 1373
    if (! *s) {
#line 1373
      goto while_break___0;
    }
#line 1374
    s ++;
#line 1375
    end ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1377
  *s = (char)0;
#line 1378
  tmp___0 = RetStrVal(t, info);
  }
#line 1378
  return (tmp___0);
}
}
#line 1388 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FIndex(func_info *info ) 
{ 
  char const   *s ;
  int start ;
  char *tmp ;

  {
#line 1393
  if ((int )ValStack[ValStackPtr - info->nargs].type != 4) {
#line 1394
    return (14);
  } else
#line 1393
  if ((int )ValStack[(ValStackPtr - info->nargs) + 1].type != 4) {
#line 1394
    return (14);
  } else
#line 1393
  if (info->nargs == 3) {
#line 1393
    if ((int )ValStack[(ValStackPtr - info->nargs) + 2].type != 1) {
#line 1394
      return (14);
    }
  }
#line 1396
  s = (char const   *)ValStack[ValStackPtr - info->nargs].v.str;
#line 1399
  if (info->nargs == 3) {
#line 1400
    start = 1;
    {
#line 1401
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1401
      if (! (start < ValStack[(ValStackPtr - info->nargs) + 2].v.val)) {
#line 1401
        goto while_break;
      }
#line 1402
      if (! *s) {
#line 1402
        goto while_break;
      }
#line 1403
      s ++;
#line 1404
      start ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1409
  tmp = strstr(s, (char const   *)ValStack[(ValStackPtr - info->nargs) + 1].v.str);
#line 1409
  s = (char const   *)tmp;
#line 1410
  info->retval.type = (char)1;
  }
#line 1411
  if (! s) {
#line 1412
    info->retval.v.val = 0;
#line 1413
    return (0);
  }
#line 1415
  info->retval.v.val = (int )((s - (char const   *)ValStack[ValStackPtr - info->nargs].v.str) + 1L);
#line 1416
  return (0);
}
}
#line 1426 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FIif(func_info *info ) 
{ 
  int istrue ;
  int arg ;

  {
#line 1431
  if (! (info->nargs % 2)) {
#line 1431
    return (61);
  }
#line 1433
  arg = 0;
  {
#line 1433
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1433
    if (! (arg < info->nargs - 1)) {
#line 1433
      goto while_break;
    }
#line 1434
    if ((int )ValStack[(ValStackPtr - info->nargs) + arg].type != 4) {
#line 1434
      if ((int )ValStack[(ValStackPtr - info->nargs) + arg].type != 1) {
#line 1435
        return (14);
      }
    }
#line 1437
    if ((int )ValStack[(ValStackPtr - info->nargs) + arg].type == 1) {
#line 1438
      istrue = ValStack[(ValStackPtr - info->nargs) + arg].v.val;
    } else {
#line 1440
      istrue = (int )*(ValStack[(ValStackPtr - info->nargs) + arg].v.str);
    }
#line 1442
    if (istrue) {
#line 1443
      info->retval = ValStack[(ValStackPtr - info->nargs) + (arg + 1)];
#line 1443
      ValStack[(ValStackPtr - info->nargs) + (arg + 1)].type = (char)0;
#line 1444
      return (0);
    }
#line 1433
    arg += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 1448
  info->retval = ValStack[(ValStackPtr - info->nargs) + (info->nargs - 1)];
#line 1448
  ValStack[(ValStackPtr - info->nargs) + (info->nargs - 1)].type = (char)0;
#line 1449
  return (0);
}
}
#line 1459 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FFilename(func_info *info ) 
{ 
  int tmp ;

  {
  {
#line 1461
  tmp = RetStrVal((char const   *)FileName, info);
  }
#line 1461
  return (tmp);
}
}
#line 1471 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FFiledir(func_info *info ) 
{ 
  char *s ;
  DynamicBuffer buf___1 ;
  int r ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1477
  DBufInit(& buf___1);
#line 1479
  tmp = DBufPuts(& buf___1, (char const   *)FileName);
  }
#line 1479
  if (tmp != 0) {
#line 1479
    return (9);
  }
#line 1480
  if (buf___1.len == 0) {
    {
#line 1481
    DBufFree(& buf___1);
#line 1482
    tmp___0 = RetStrVal(".", info);
    }
#line 1482
    return (tmp___0);
  }
#line 1485
  s = (buf___1.buffer + buf___1.len) - 1;
  {
#line 1486
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1486
    if ((unsigned long )s > (unsigned long )buf___1.buffer) {
#line 1486
      if (! ((int )*s != 47)) {
#line 1486
        goto while_break;
      }
    } else {
#line 1486
      goto while_break;
    }
#line 1486
    s --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1487
  if ((int )*s == 47) {
    {
#line 1488
    *s = (char)0;
#line 1489
    r = RetStrVal((char const   *)buf___1.buffer, info);
    }
  } else {
    {
#line 1490
    r = RetStrVal(".", info);
    }
  }
  {
#line 1491
  DBufFree(& buf___1);
  }
#line 1492
  return (r);
}
}
#line 1501 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FAccess(func_info *info ) 
{ 
  int amode ;
  char const   *s ;
  char const   *tmp ;

  {
#line 1506
  if ((int )ValStack[ValStackPtr - info->nargs].type != 4) {
#line 1507
    return (14);
  } else
#line 1506
  if ((int )ValStack[(ValStackPtr - info->nargs) + 1].type != 1) {
#line 1506
    if ((int )ValStack[(ValStackPtr - info->nargs) + 1].type != 4) {
#line 1507
      return (14);
    }
  }
#line 1509
  if ((int )ValStack[(ValStackPtr - info->nargs) + 1].type == 1) {
#line 1509
    amode = ValStack[(ValStackPtr - info->nargs) + 1].v.val;
  } else {
#line 1511
    amode = 0;
#line 1512
    s = (char const   *)ValStack[(ValStackPtr - info->nargs) + 1].v.str;
    {
#line 1513
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1513
      if (! *s) {
#line 1513
        goto while_break;
      }
#line 1514
      tmp = s;
#line 1514
      s ++;
      {
#line 1516
      if ((int const   )*tmp == 82) {
#line 1516
        goto case_82;
      }
#line 1516
      if ((int const   )*tmp == 114) {
#line 1516
        goto case_82;
      }
#line 1518
      if ((int const   )*tmp == 87) {
#line 1518
        goto case_87;
      }
#line 1518
      if ((int const   )*tmp == 119) {
#line 1518
        goto case_87;
      }
#line 1520
      if ((int const   )*tmp == 88) {
#line 1520
        goto case_88;
      }
#line 1520
      if ((int const   )*tmp == 120) {
#line 1520
        goto case_88;
      }
#line 1514
      goto switch_break;
      case_82: /* CIL Label */ 
      case_114: /* CIL Label */ 
#line 1516
      amode |= 4;
#line 1516
      goto switch_break;
      case_87: /* CIL Label */ 
      case_119: /* CIL Label */ 
#line 1518
      amode |= 2;
#line 1518
      goto switch_break;
      case_88: /* CIL Label */ 
      case_120: /* CIL Label */ 
#line 1520
      amode |= 1;
#line 1520
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1524
  info->retval.type = (char)1;
#line 1525
  info->retval.v.val = access((char const   *)ValStack[ValStackPtr - info->nargs].v.str,
                              amode);
  }
#line 1526
  return (0);
}
}
#line 1536 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FTypeof(func_info *info ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 1539
  if ((int )ValStack[ValStackPtr - info->nargs].type == 1) {
#line 1539
    goto case_1;
  }
#line 1540
  if ((int )ValStack[ValStackPtr - info->nargs].type == 3) {
#line 1540
    goto case_3;
  }
#line 1541
  if ((int )ValStack[ValStackPtr - info->nargs].type == 2) {
#line 1541
    goto case_2;
  }
#line 1542
  if ((int )ValStack[ValStackPtr - info->nargs].type == 4) {
#line 1542
    goto case_4;
  }
#line 1543
  if ((int )ValStack[ValStackPtr - info->nargs].type == 5) {
#line 1543
    goto case_5;
  }
#line 1544
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 1539
  tmp = RetStrVal("INT", info);
  }
#line 1539
  return (tmp);
  case_3: /* CIL Label */ 
  {
#line 1540
  tmp___0 = RetStrVal("DATE", info);
  }
#line 1540
  return (tmp___0);
  case_2: /* CIL Label */ 
  {
#line 1541
  tmp___1 = RetStrVal("TIME", info);
  }
#line 1541
  return (tmp___1);
  case_4: /* CIL Label */ 
  {
#line 1542
  tmp___2 = RetStrVal("STRING", info);
  }
#line 1542
  return (tmp___2);
  case_5: /* CIL Label */ 
  {
#line 1543
  tmp___3 = RetStrVal("DATETIME", info);
  }
#line 1543
  return (tmp___3);
  switch_default: /* CIL Label */ 
  {
#line 1544
  tmp___4 = RetStrVal("ERR", info);
  }
#line 1544
  return (tmp___4);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1555 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FLanguage(func_info *info ) 
{ 
  int tmp ;

  {
  {
#line 1557
  tmp = RetStrVal("English", info);
  }
#line 1557
  return (tmp);
}
}
#line 1567 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FArgs(func_info *info ) 
{ 


  {
#line 1569
  if ((int )ValStack[ValStackPtr - info->nargs].type != 4) {
#line 1569
    return (14);
  }
  {
#line 1570
  info->retval.type = (char)1;
#line 1571
  info->retval.v.val = UserFuncExists((char const   *)ValStack[ValStackPtr - info->nargs].v.str);
  }
#line 1572
  return (0);
}
}
#line 1582 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FDosubst(func_info *info ) 
{ 
  int jul ;
  int tim ;
  int r ;
  DynamicBuffer buf___1 ;

  {
  {
#line 1587
  DBufInit(& buf___1);
#line 1589
  jul = -1;
#line 1590
  tim = 2147483647;
  }
#line 1591
  if ((int )ValStack[ValStackPtr - info->nargs].type != 4) {
#line 1591
    return (14);
  }
#line 1592
  if (info->nargs >= 2) {
#line 1593
    if ((int )ValStack[(ValStackPtr - info->nargs) + 1].type == 5) {
#line 1594
      if ((int )ValStack[(ValStackPtr - info->nargs) + 1].type == 3) {
#line 1594
        jul = ValStack[(ValStackPtr - info->nargs) + 1].v.val;
      } else {
#line 1594
        jul = ValStack[(ValStackPtr - info->nargs) + 1].v.val / 1440;
      }
#line 1595
      if ((int )ValStack[(ValStackPtr - info->nargs) + 1].type == 2) {
#line 1595
        tim = ValStack[(ValStackPtr - info->nargs) + 1].v.val;
      } else {
#line 1595
        tim = ValStack[(ValStackPtr - info->nargs) + 1].v.val % 1440;
      }
    } else {
#line 1597
      if ((int )ValStack[(ValStackPtr - info->nargs) + 1].type != 3) {
#line 1597
        return (14);
      }
#line 1598
      jul = ValStack[(ValStackPtr - info->nargs) + 1].v.val;
    }
#line 1600
    if (info->nargs >= 3) {
#line 1601
      if ((int )ValStack[(ValStackPtr - info->nargs) + 1].type == 5) {
#line 1602
        return (26);
      }
#line 1604
      if ((int )ValStack[(ValStackPtr - info->nargs) + 2].type != 2) {
#line 1604
        return (14);
      }
#line 1605
      tim = ValStack[(ValStackPtr - info->nargs) + 2].v.val;
    }
  }
  {
#line 1609
  r = DoSubstFromString((char const   *)ValStack[ValStackPtr - info->nargs].v.str,
                        & buf___1, jul, tim);
  }
#line 1609
  if (r) {
#line 1609
    return (r);
  }
  {
#line 1610
  r = RetStrVal((char const   *)buf___1.buffer, info);
#line 1611
  DBufFree(& buf___1);
  }
#line 1612
  return (r);
}
}
#line 1625 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FHebdate(func_info *info ) 
{ 
  int year ;
  int day ;
  int mon ;
  int jahr ;
  int mout ;
  int dout ;
  int ans ;
  int r ;
  int adarbehave ;
  int tmp ;

  {
#line 1632
  if ((int )ValStack[ValStackPtr - info->nargs].type != 1) {
#line 1632
    return (14);
  } else
#line 1632
  if ((int )ValStack[(ValStackPtr - info->nargs) + 1].type != 4) {
#line 1632
    return (14);
  }
  {
#line 1633
  day = ValStack[ValStackPtr - info->nargs].v.val;
#line 1634
  mon = HebNameToNum((char const   *)ValStack[(ValStackPtr - info->nargs) + 1].v.str);
  }
#line 1635
  if (mon < 0) {
#line 1635
    return (60);
  }
#line 1636
  if (info->nargs == 2) {
    {
#line 1637
    r = GetNextHebrewDate(JulianToday, mon, day, 0, 0, & ans);
    }
#line 1638
    if (r) {
#line 1638
      return (r);
    }
#line 1639
    info->retval.type = (char)3;
#line 1640
    info->retval.v.val = ans;
#line 1641
    return (0);
  }
#line 1643
  if (info->nargs == 5) {
#line 1644
    if ((int )ValStack[(ValStackPtr - info->nargs) + 4].type != 1) {
#line 1644
      return (14);
    }
#line 1645
    adarbehave = ValStack[(ValStackPtr - info->nargs) + 4].v.val;
#line 1646
    if (adarbehave < 0) {
#line 1646
      return (29);
    }
#line 1647
    if (adarbehave > 2) {
#line 1647
      return (28);
    }
  } else {
#line 1648
    adarbehave = 0;
  }
#line 1650
  if (info->nargs >= 4) {
#line 1651
    if ((int )ValStack[(ValStackPtr - info->nargs) + 3].type != 1) {
#line 1651
      return (14);
    }
#line 1652
    jahr = ValStack[(ValStackPtr - info->nargs) + 3].v.val;
#line 1653
    if (jahr < 0) {
#line 1653
      return (29);
    }
#line 1654
    if (jahr > 2) {
      {
#line 1655
      r = ComputeJahr(jahr, mon, day, & jahr);
      }
#line 1656
      if (r) {
#line 1656
        return (r);
      }
    }
  } else {
#line 1658
    jahr = 0;
  }
#line 1661
  if ((int )ValStack[(ValStackPtr - info->nargs) + 2].type == 1) {
    {
#line 1662
    year = ValStack[(ValStackPtr - info->nargs) + 2].v.val;
#line 1663
    r = GetValidHebDate(year, mon, day, 0, & mout, & dout, jahr);
    }
#line 1664
    if (r) {
#line 1664
      return (r);
    }
    {
#line 1665
    r = HebToJul(year, mout, dout);
    }
#line 1666
    if (r < 0) {
#line 1666
      return (15);
    }
#line 1667
    info->retval.v.val = r;
#line 1668
    info->retval.type = (char)3;
#line 1669
    return (0);
  } else
#line 1670
  if ((int )ValStack[(ValStackPtr - info->nargs) + 2].type == 3) {
#line 1670
    goto _L;
  } else
#line 1670
  if ((int )ValStack[(ValStackPtr - info->nargs) + 2].type == 5) {
    _L: /* CIL Label */ 
#line 1671
    if ((int )ValStack[(ValStackPtr - info->nargs) + 2].type == 3) {
#line 1671
      tmp = ValStack[(ValStackPtr - info->nargs) + 2].v.val;
    } else {
#line 1671
      tmp = ValStack[(ValStackPtr - info->nargs) + 2].v.val / 1440;
    }
    {
#line 1671
    r = GetNextHebrewDate(tmp, mon, day, jahr, adarbehave, & ans);
    }
#line 1672
    if (r) {
#line 1672
      return (r);
    }
#line 1673
    info->retval.v.val = ans;
#line 1674
    info->retval.type = (char)3;
#line 1675
    return (0);
  } else {
#line 1676
    return (14);
  }
}
}
#line 1679 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FHebday(func_info *info ) 
{ 
  int y ;
  int m ;
  int d ;
  int v ;

  {
#line 1683
  if (! ((int )ValStack[ValStackPtr - info->nargs].type == 3)) {
#line 1683
    if (! ((int )ValStack[ValStackPtr - info->nargs].type == 5)) {
#line 1683
      return (14);
    }
  }
#line 1684
  if ((int )ValStack[ValStackPtr - info->nargs].type == 3) {
#line 1684
    v = ValStack[ValStackPtr - info->nargs].v.val;
  } else {
#line 1684
    v = ValStack[ValStackPtr - info->nargs].v.val / 1440;
  }
#line 1685
  if (v == CacheHebJul) {
#line 1686
    d = CacheHebDay;
  } else {
    {
#line 1688
    JulToHeb(v, & y, & m, & d);
#line 1689
    CacheHebJul = v;
#line 1690
    CacheHebYear = y;
#line 1691
    CacheHebMon = m;
#line 1692
    CacheHebDay = d;
    }
  }
#line 1694
  info->retval.type = (char)1;
#line 1695
  info->retval.v.val = d;
#line 1696
  return (0);
}
}
#line 1699 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FHebmon(func_info *info ) 
{ 
  int y ;
  int m ;
  int d ;
  int v ;
  char const   *tmp ;
  int tmp___0 ;

  {
#line 1703
  if (! ((int )ValStack[ValStackPtr - info->nargs].type == 3)) {
#line 1703
    if (! ((int )ValStack[ValStackPtr - info->nargs].type == 5)) {
#line 1703
      return (14);
    }
  }
#line 1704
  if ((int )ValStack[ValStackPtr - info->nargs].type == 3) {
#line 1704
    v = ValStack[ValStackPtr - info->nargs].v.val;
  } else {
#line 1704
    v = ValStack[ValStackPtr - info->nargs].v.val / 1440;
  }
#line 1706
  if (v == CacheHebJul) {
#line 1707
    m = CacheHebMon;
#line 1708
    y = CacheHebYear;
  } else {
    {
#line 1710
    JulToHeb(v, & y, & m, & d);
#line 1711
    CacheHebJul = v;
#line 1712
    CacheHebYear = y;
#line 1713
    CacheHebMon = m;
#line 1714
    CacheHebDay = d;
    }
  }
  {
#line 1716
  tmp = HebMonthName(m, y);
#line 1716
  tmp___0 = RetStrVal(tmp, info);
  }
#line 1716
  return (tmp___0);
}
}
#line 1719 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FHebyear(func_info *info ) 
{ 
  int y ;
  int m ;
  int d ;
  int v ;

  {
#line 1723
  if (! ((int )ValStack[ValStackPtr - info->nargs].type == 3)) {
#line 1723
    if (! ((int )ValStack[ValStackPtr - info->nargs].type == 5)) {
#line 1723
      return (14);
    }
  }
#line 1724
  if ((int )ValStack[ValStackPtr - info->nargs].type == 3) {
#line 1724
    v = ValStack[ValStackPtr - info->nargs].v.val;
  } else {
#line 1724
    v = ValStack[ValStackPtr - info->nargs].v.val / 1440;
  }
#line 1726
  if (v == CacheHebJul) {
#line 1727
    y = CacheHebYear;
  } else {
    {
#line 1729
    JulToHeb(v, & y, & m, & d);
#line 1730
    CacheHebJul = v;
#line 1731
    CacheHebYear = y;
#line 1732
    CacheHebMon = m;
#line 1733
    CacheHebDay = d;
    }
  }
#line 1735
  info->retval.type = (char)1;
#line 1736
  info->retval.v.val = y;
#line 1737
  return (0);
}
}
#line 1753 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FEasterdate(func_info *info ) 
{ 
  int y ;
  int m ;
  int d ;
  int g ;
  int c ;
  int x ;
  int z ;
  int e ;
  int n ;
  int tmp ;
  int tmp___0 ;

  {
#line 1757
  if ((int )ValStack[ValStackPtr - info->nargs].type == 1) {
#line 1758
    y = ValStack[ValStackPtr - info->nargs].v.val;
#line 1759
    if (y < 1990) {
#line 1759
      return (29);
    } else
#line 1760
    if (y > 5990) {
#line 1760
      return (28);
    }
  } else
#line 1761
  if ((int )ValStack[ValStackPtr - info->nargs].type == 3) {
#line 1761
    goto _L;
  } else
#line 1761
  if ((int )ValStack[ValStackPtr - info->nargs].type == 5) {
    _L: /* CIL Label */ 
#line 1762
    if ((int )ValStack[ValStackPtr - info->nargs].type == 3) {
#line 1762
      tmp = ValStack[ValStackPtr - info->nargs].v.val;
    } else {
#line 1762
      tmp = ValStack[ValStackPtr - info->nargs].v.val / 1440;
    }
    {
#line 1762
    FromJulian(tmp, & y, & m, & d);
    }
  } else {
#line 1763
    return (14);
  }
  {
#line 1765
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1766
    g = y % 19 + 1;
#line 1767
    c = y / 100 + 1;
#line 1768
    x = (3 * c) / 4 - 12;
#line 1769
    z = (8 * c + 5) / 25 - 5;
#line 1770
    d = ((5 * y) / 4 - x) - 10;
#line 1771
    e = (((11 * g + 20) + z) - x) % 30;
#line 1772
    if (e < 0) {
#line 1772
      e += 30;
    }
#line 1773
    if (e == 24) {
#line 1773
      e ++;
    } else
#line 1773
    if (e == 25) {
#line 1773
      if (g > 11) {
#line 1773
        e ++;
      }
    }
#line 1774
    n = 44 - e;
#line 1775
    if (n < 21) {
#line 1775
      n += 30;
    }
#line 1776
    d = (n + 7) - (d + n) % 7;
#line 1777
    if (d <= 31) {
#line 1777
      m = 2;
    } else {
#line 1780
      d -= 31;
#line 1781
      m = 3;
    }
    {
#line 1784
    info->retval.type = (char)3;
#line 1785
    info->retval.v.val = Julian(y, m, d);
#line 1786
    y ++;
    }
#line 1765
    if ((int )ValStack[ValStackPtr - info->nargs].type == 3) {
#line 1765
      goto _L___0;
    } else
#line 1765
    if ((int )ValStack[ValStackPtr - info->nargs].type == 5) {
      _L___0: /* CIL Label */ 
#line 1765
      if ((int )ValStack[ValStackPtr - info->nargs].type == 3) {
#line 1765
        tmp___0 = ValStack[ValStackPtr - info->nargs].v.val;
      } else {
#line 1765
        tmp___0 = ValStack[ValStackPtr - info->nargs].v.val / 1440;
      }
#line 1765
      if (! (info->retval.v.val < tmp___0)) {
#line 1765
        goto while_break;
      }
    } else {
#line 1765
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1788
  return (0);
}
}
#line 1798
static int FTimeStuff(int wantmins , func_info *info ) ;
#line 1799 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FIsdst(func_info *info ) 
{ 
  int tmp ;

  {
  {
#line 1801
  tmp = FTimeStuff(0, info);
  }
#line 1801
  return (tmp);
}
}
#line 1804 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FMinsfromutc(func_info *info ) 
{ 
  int tmp ;

  {
  {
#line 1806
  tmp = FTimeStuff(1, info);
  }
#line 1806
  return (tmp);
}
}
#line 1809 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FTimeStuff(int wantmins , func_info *info ) 
{ 
  int jul ;
  int tim ;
  int mins ;
  int dst ;
  int tmp ;

  {
#line 1814
  jul = JulianToday;
#line 1815
  tim = 0;
#line 1817
  if (info->nargs >= 1) {
#line 1818
    if (! ((int )ValStack[ValStackPtr - info->nargs].type == 3)) {
#line 1818
      if (! ((int )ValStack[ValStackPtr - info->nargs].type == 5)) {
#line 1818
        return (14);
      }
    }
#line 1819
    if ((int )ValStack[ValStackPtr - info->nargs].type == 3) {
#line 1819
      jul = ValStack[ValStackPtr - info->nargs].v.val;
    } else {
#line 1819
      jul = ValStack[ValStackPtr - info->nargs].v.val / 1440;
    }
#line 1820
    if ((int )ValStack[ValStackPtr - info->nargs].type == 2) {
#line 1820
      goto _L;
    } else
#line 1820
    if ((int )ValStack[ValStackPtr - info->nargs].type == 5) {
      _L: /* CIL Label */ 
#line 1821
      if ((int )ValStack[ValStackPtr - info->nargs].type == 2) {
#line 1821
        tim = ValStack[ValStackPtr - info->nargs].v.val;
      } else {
#line 1821
        tim = ValStack[ValStackPtr - info->nargs].v.val % 1440;
      }
    }
#line 1823
    if (info->nargs >= 2) {
#line 1824
      if ((int )ValStack[ValStackPtr - info->nargs].type == 2) {
#line 1824
        return (26);
      } else
#line 1824
      if ((int )ValStack[ValStackPtr - info->nargs].type == 5) {
#line 1824
        return (26);
      }
#line 1825
      if ((int )ValStack[(ValStackPtr - info->nargs) + 1].type != 2) {
#line 1825
        return (14);
      }
#line 1826
      tim = ValStack[(ValStackPtr - info->nargs) + 1].v.val;
    }
  }
  {
#line 1830
  tmp = CalcMinsFromUTC(jul, tim, & mins, & dst);
  }
#line 1830
  if (tmp) {
#line 1830
    return (46);
  }
#line 1831
  info->retval.type = (char)1;
#line 1832
  if (wantmins) {
#line 1832
    info->retval.v.val = mins;
  } else {
#line 1832
    info->retval.v.val = dst;
  }
#line 1834
  return (0);
}
}
#line 1855 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int SunStuff(int rise , double cosz , int jul ) 
{ 
  int mins ;
  int hours ;
  int year ;
  int mon ;
  int day ;
  double M ;
  double L ;
  double sinDelta ;
  double cosDelta ;
  double a ;
  double a_hr ;
  double cosH ;
  double t ;
  double H ;
  double T ;
  double latitude ;
  double longdeg ;
  double UT ;
  double local ;
  int tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;
  double tmp___10 ;
  double tmp___11 ;

  {
#line 1864
  if (CalculateUTC) {
    {
#line 1865
    tmp = CalcMinsFromUTC(jul, 720, & mins, (int *)((void *)0));
    }
#line 1865
    if (tmp) {
      {
#line 1866
      Eprint((char const   *)ErrMsg[46]);
      }
#line 1867
      return (2147483647);
    }
  } else {
#line 1869
    mins = MinsFromUTC;
  }
  {
#line 1872
  longdeg = ((double )LongDeg + (double )LongMin / 60.0) + (double )LongSec / 3600.0;
#line 1875
  latitude = (3.14159265358979323846 / 180.0) * (((double )LatDeg + (double )LatMin / 60.0) + (double )LatSec / 3600.0);
#line 1879
  FromJulian(jul, & year, & mon, & day);
  }
#line 1881
  if (rise > 1) {
#line 1882
    rise -= 2;
  }
#line 1885
  t = (double )jul;
#line 1886
  if (rise) {
#line 1887
    t += (6.0 + longdeg / 15.0) / 24.0;
  } else {
#line 1889
    t += (18.0 + longdeg / 15.0) / 24.0;
  }
  {
#line 1897
  t = 0.9856002585 * t;
#line 1898
  M = t + 357.828757;
#line 1901
  tmp___0 = floor(M / 360.0);
#line 1901
  M -= tmp___0 * 360.0;
#line 1904
  tmp___1 = sin((3.14159265358979323846 / 180.0) * M);
#line 1904
  tmp___2 = sin(((double )2 * (3.14159265358979323846 / 180.0)) * M);
#line 1904
  L = ((M + 1.916 * tmp___1) + 0.02 * tmp___2) + 283.07080214;
  }
#line 1905
  if (L > 360.0) {
#line 1905
    L -= 360.0;
  }
  {
#line 1908
  tmp___3 = cos((3.14159265358979323846 / 180.0) * L);
#line 1908
  tmp___4 = sin((3.14159265358979323846 / 180.0) * L);
#line 1908
  tmp___5 = atan2(0.91746 * tmp___4, tmp___3);
#line 1908
  a = (180.0 / 3.14159265358979323846) * tmp___5;
  }
#line 1909
  if (a < (double )0) {
#line 1910
    a += 360.0;
  }
  {
#line 1913
  a_hr = a / 15.0;
#line 1916
  tmp___6 = sin((3.14159265358979323846 / 180.0) * L);
#line 1916
  sinDelta = 0.39782 * tmp___6;
#line 1917
  cosDelta = sqrt((double )1 - sinDelta * sinDelta);
#line 1920
  tmp___7 = sin(latitude);
#line 1920
  tmp___8 = cos(latitude);
#line 1920
  cosH = (cosz - sinDelta * tmp___7) / (cosDelta * tmp___8);
  }
#line 1922
  if (cosH < - 1.0) {
#line 1923
    if (rise) {
#line 1923
      return (2147483647);
    } else {
#line 1924
      return (-2147483647);
    }
  }
#line 1926
  if (cosH > 1.0) {
#line 1927
    if (rise) {
#line 1927
      return (-2147483647);
    } else {
#line 1928
      return (2147483647);
    }
  }
  {
#line 1931
  tmp___9 = acos(cosH);
#line 1931
  H = (180.0 / 3.14159265358979323846) * tmp___9;
  }
#line 1932
  if (rise) {
#line 1932
    H = 360.0 - H;
  }
  {
#line 1934
  tmp___10 = floor(t / 360.0);
#line 1934
  t -= 360.0 * tmp___10;
#line 1935
  T = ((H - t) / 15.0 + a_hr) - 6.726637276;
  }
#line 1937
  if (T >= 24.0) {
#line 1937
    T -= 24.0;
  } else
#line 1938
  if (T < 0.0) {
#line 1938
    T += 24.0;
  }
#line 1940
  UT = T + longdeg / 15.0;
#line 1943
  local = UT + (double )mins / 60.0;
#line 1944
  if (local < 0.0) {
#line 1944
    local += 24.0;
  } else
#line 1945
  if (local >= 24.0) {
#line 1945
    local -= 24.0;
  }
  {
#line 1948
  tmp___11 = floor(local * 60.0 + 0.5);
#line 1948
  local = tmp___11 / 60.0;
#line 1950
  hours = (int )local;
#line 1951
  mins = (int )((local - (double )hours) * 60.0);
  }
#line 1955
  if (rise) {
#line 1957
    if (hours >= 23) {
#line 1957
      return (2147483647);
    }
  } else
#line 1960
  if (hours <= 1) {
#line 1960
    return (-2147483647);
  }
#line 1962
  return (hours * 60 + mins);
}
}
#line 1970 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FSun(int rise , func_info *info ) 
{ 
  int jul ;
  double cosz ;
  int r ;

  {
#line 1972
  jul = JulianToday;
#line 1973
  cosz = - 0.014543897;
#line 1977
  if (rise == 2) {
#line 1978
    cosz = - 0.104528463268;
  } else
#line 1977
  if (rise == 3) {
#line 1978
    cosz = - 0.104528463268;
  }
#line 1980
  if (info->nargs >= 1) {
#line 1981
    if (! ((int )ValStack[ValStackPtr - info->nargs].type == 3)) {
#line 1981
      if (! ((int )ValStack[ValStackPtr - info->nargs].type == 5)) {
#line 1981
        return (14);
      }
    }
#line 1982
    if ((int )ValStack[ValStackPtr - info->nargs].type == 3) {
#line 1982
      jul = ValStack[ValStackPtr - info->nargs].v.val;
    } else {
#line 1982
      jul = ValStack[ValStackPtr - info->nargs].v.val / 1440;
    }
  }
  {
#line 1985
  r = SunStuff(rise, cosz, jul);
  }
#line 1986
  if (r == 2147483647) {
#line 1987
    info->retval.v.val = 0;
#line 1988
    info->retval.type = (char)1;
  } else
#line 1989
  if (r == -2147483647) {
#line 1990
    info->retval.v.val = 1440;
#line 1991
    info->retval.type = (char)1;
  } else {
#line 1993
    info->retval.v.val = r;
#line 1994
    info->retval.type = (char)2;
  }
#line 1996
  return (0);
}
}
#line 1999 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FSunrise(func_info *info ) 
{ 
  int tmp ;

  {
  {
#line 2001
  tmp = FSun(1, info);
  }
#line 2001
  return (tmp);
}
}
#line 2003 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FSunset(func_info *info ) 
{ 
  int tmp ;

  {
  {
#line 2005
  tmp = FSun(0, info);
  }
#line 2005
  return (tmp);
}
}
#line 2008 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FDawn(func_info *info ) 
{ 
  int tmp ;

  {
  {
#line 2010
  tmp = FSun(3, info);
  }
#line 2010
  return (tmp);
}
}
#line 2012 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FDusk(func_info *info ) 
{ 
  int tmp ;

  {
  {
#line 2014
  tmp = FSun(2, info);
  }
#line 2014
  return (tmp);
}
}
#line 2024 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FFiledate(func_info *info ) 
{ 
  struct stat statbuf ;
  struct tm *t1 ;
  int tmp ;

  {
#line 2029
  info->retval.type = (char)3;
#line 2031
  if ((int )ValStack[ValStackPtr - info->nargs].type != 4) {
#line 2031
    return (14);
  }
  {
#line 2033
  tmp = stat((char const   */* __restrict  */)ValStack[ValStackPtr - info->nargs].v.str,
             (struct stat */* __restrict  */)(& statbuf));
  }
#line 2033
  if (tmp) {
#line 2034
    info->retval.v.val = 0;
#line 2035
    return (0);
  }
  {
#line 2038
  t1 = localtime((time_t const   *)(& statbuf.st_mtim.tv_sec));
  }
#line 2040
  if (t1->tm_year + 1900 < 1990) {
#line 2041
    info->retval.v.val = 0;
  } else {
    {
#line 2043
    info->retval.v.val = Julian(t1->tm_year + 1900, t1->tm_mon, t1->tm_mday);
    }
  }
#line 2045
  return (0);
}
}
#line 2055 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FFiledatetime(func_info *info ) 
{ 
  struct stat statbuf ;
  struct tm *t1 ;
  int tmp ;
  int tmp___0 ;

  {
#line 2060
  info->retval.type = (char)5;
#line 2062
  if ((int )ValStack[ValStackPtr - info->nargs].type != 4) {
#line 2062
    return (14);
  }
  {
#line 2064
  tmp = stat((char const   */* __restrict  */)ValStack[ValStackPtr - info->nargs].v.str,
             (struct stat */* __restrict  */)(& statbuf));
  }
#line 2064
  if (tmp) {
#line 2065
    info->retval.v.val = 0;
#line 2066
    return (0);
  }
  {
#line 2069
  t1 = localtime((time_t const   *)(& statbuf.st_mtim.tv_sec));
  }
#line 2071
  if (t1->tm_year + 1900 < 1990) {
#line 2072
    info->retval.v.val = 0;
  } else {
    {
#line 2074
    tmp___0 = Julian(t1->tm_year + 1900, t1->tm_mon, t1->tm_mday);
#line 2074
    info->retval.v.val = (1440 * tmp___0 + t1->tm_hour * 60) + t1->tm_min;
    }
  }
#line 2076
  return (0);
}
}
#line 2086 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int psshade_warned  =    0;
#line 2087 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FPsshade(func_info *info ) 
{ 
  char psbuff[256] ;
  char *s ;
  int i ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
#line 2090
  s = psbuff;
#line 2094
  if (info->nargs != 1) {
#line 2094
    if (info->nargs != 3) {
#line 2094
      return (26);
    }
  }
#line 2096
  i = 0;
  {
#line 2096
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2096
    if (! (i < info->nargs)) {
#line 2096
      goto while_break;
    }
#line 2097
    if ((int )ValStack[(ValStackPtr - info->nargs) + i].type != 1) {
#line 2097
      return (14);
    }
#line 2098
    if (ValStack[(ValStackPtr - info->nargs) + i].v.val < 0) {
#line 2098
      return (29);
    }
#line 2099
    if (ValStack[(ValStackPtr - info->nargs) + i].v.val > 100) {
#line 2099
      return (28);
    }
#line 2096
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2102
  if (! psshade_warned) {
    {
#line 2103
    psshade_warned = 1;
#line 2104
    Eprint("psshade() is deprecated; use SPECIAL SHADE instead.");
    }
  }
  {
#line 2107
  sprintf((char */* __restrict  */)s, (char const   */* __restrict  */)"/_A LineWidth 2 div def ");
#line 2108
  tmp = strlen((char const   *)s);
#line 2108
  s += tmp;
#line 2109
  sprintf((char */* __restrict  */)s, (char const   */* __restrict  */)"_A _A moveto ");
#line 2110
  tmp___0 = strlen((char const   *)s);
#line 2110
  s += tmp___0;
#line 2111
  sprintf((char */* __restrict  */)s, (char const   */* __restrict  */)"BoxWidth _A sub _A lineto BoxWidth _A sub BoxHeight _A sub lineto ");
#line 2112
  tmp___1 = strlen((char const   *)s);
#line 2112
  s += tmp___1;
  }
#line 2113
  if (info->nargs == 1) {
    {
#line 2114
    sprintf((char */* __restrict  */)s, (char const   */* __restrict  */)"_A BoxHeight _A sub lineto closepath %d 100 div setgray fill 0.0 setgray",
            ValStack[ValStackPtr - info->nargs].v.val);
    }
  } else {
    {
#line 2116
    sprintf((char */* __restrict  */)s, (char const   */* __restrict  */)"_A BoxHeight _A sub lineto closepath %d 100 div %d 100 div %d 100 div setrgbcolor fill 0.0 setgray",
            ValStack[ValStackPtr - info->nargs].v.val, ValStack[(ValStackPtr - info->nargs) + 1].v.val,
            ValStack[(ValStackPtr - info->nargs) + 2].v.val);
    }
  }
  {
#line 2118
  tmp___2 = RetStrVal((char const   *)(psbuff), info);
  }
#line 2118
  return (tmp___2);
}
}
#line 2128 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int psmoon_warned  =    0;
#line 2130 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FPsmoon(func_info *info ) 
{ 
  char psbuff[512] ;
  char sizebuf[30] ;
  char fontsizebuf[30] ;
  char *s ;
  char const   *extra ;
  int size ;
  int fontsize ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;

  {
#line 2135
  s = psbuff;
#line 2136
  extra = (char const   *)((void *)0);
#line 2137
  size = -1;
#line 2138
  fontsize = -1;
#line 2140
  if ((int )ValStack[ValStackPtr - info->nargs].type != 1) {
#line 2140
    return (14);
  }
#line 2141
  if (ValStack[ValStackPtr - info->nargs].v.val < 0) {
#line 2141
    return (29);
  }
#line 2142
  if (ValStack[ValStackPtr - info->nargs].v.val > 3) {
#line 2142
    return (28);
  }
#line 2143
  if (info->nargs > 1) {
#line 2144
    if ((int )ValStack[(ValStackPtr - info->nargs) + 1].type != 1) {
#line 2144
      return (14);
    }
#line 2145
    if (ValStack[(ValStackPtr - info->nargs) + 1].v.val < -1) {
#line 2145
      return (29);
    }
#line 2146
    size = ValStack[(ValStackPtr - info->nargs) + 1].v.val;
#line 2147
    if (info->nargs > 2) {
#line 2148
      if ((int )ValStack[(ValStackPtr - info->nargs) + 2].type != 4) {
#line 2148
        return (14);
      }
#line 2149
      extra = (char const   *)ValStack[(ValStackPtr - info->nargs) + 2].v.str;
#line 2150
      if (info->nargs > 3) {
#line 2151
        if ((int )ValStack[(ValStackPtr - info->nargs) + 3].type != 1) {
#line 2151
          return (14);
        }
#line 2152
        if (ValStack[(ValStackPtr - info->nargs) + 3].v.val <= 0) {
#line 2152
          return (29);
        }
#line 2153
        fontsize = ValStack[(ValStackPtr - info->nargs) + 3].v.val;
      }
    }
  }
#line 2157
  if (! psmoon_warned) {
    {
#line 2158
    psmoon_warned = 1;
#line 2159
    Eprint("psmoon() is deprecated; use SPECIAL MOON instead.");
    }
  }
#line 2161
  if (size > 0) {
    {
#line 2162
    sprintf((char */* __restrict  */)(sizebuf), (char const   */* __restrict  */)"%d",
            size);
    }
  } else {
    {
#line 2164
    strcpy((char */* __restrict  */)(sizebuf), (char const   */* __restrict  */)"DaySize 2 div");
    }
  }
#line 2167
  if (fontsize > 0) {
    {
#line 2168
    sprintf((char */* __restrict  */)(fontsizebuf), (char const   */* __restrict  */)"%d",
            fontsize);
    }
  } else {
    {
#line 2170
    strcpy((char */* __restrict  */)(fontsizebuf), (char const   */* __restrict  */)"EntrySize");
    }
  }
  {
#line 2173
  sprintf((char */* __restrict  */)s, (char const   */* __restrict  */)"gsave 0 setgray newpath Border %s add BoxHeight Border sub %s sub",
          sizebuf, sizebuf);
#line 2175
  tmp = strlen((char const   *)s);
#line 2175
  s += tmp;
#line 2176
  sprintf((char */* __restrict  */)s, (char const   */* __restrict  */)" %s 0 360 arc closepath",
          sizebuf);
#line 2177
  tmp___0 = strlen((char const   *)s);
#line 2177
  s += tmp___0;
  }
  {
#line 2179
  if (ValStack[ValStackPtr - info->nargs].v.val == 0) {
#line 2179
    goto case_0;
  }
#line 2184
  if (ValStack[ValStackPtr - info->nargs].v.val == 2) {
#line 2184
    goto case_2;
  }
#line 2189
  if (ValStack[ValStackPtr - info->nargs].v.val == 1) {
#line 2189
    goto case_1;
  }
#line 2199
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 2180
  sprintf((char */* __restrict  */)s, (char const   */* __restrict  */)" fill");
#line 2181
  tmp___1 = strlen((char const   *)s);
#line 2181
  s += tmp___1;
  }
#line 2182
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 2185
  sprintf((char */* __restrict  */)s, (char const   */* __restrict  */)" stroke");
#line 2186
  tmp___2 = strlen((char const   *)s);
#line 2186
  s += tmp___2;
  }
#line 2187
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 2190
  sprintf((char */* __restrict  */)s, (char const   */* __restrict  */)" stroke");
#line 2191
  tmp___3 = strlen((char const   *)s);
#line 2191
  s += tmp___3;
#line 2192
  sprintf((char */* __restrict  */)s, (char const   */* __restrict  */)" newpath Border %s add BoxHeight Border sub %s sub",
          sizebuf, sizebuf);
#line 2194
  tmp___4 = strlen((char const   *)s);
#line 2194
  s += tmp___4;
#line 2195
  sprintf((char */* __restrict  */)s, (char const   */* __restrict  */)" %s 90 270 arc closepath fill",
          sizebuf);
#line 2196
  tmp___5 = strlen((char const   *)s);
#line 2196
  s += tmp___5;
  }
#line 2197
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 2200
  sprintf((char */* __restrict  */)s, (char const   */* __restrict  */)" stroke");
#line 2201
  tmp___6 = strlen((char const   *)s);
#line 2201
  s += tmp___6;
#line 2202
  sprintf((char */* __restrict  */)s, (char const   */* __restrict  */)" newpath Border %s add BoxHeight Border sub %s sub",
          sizebuf, sizebuf);
#line 2204
  tmp___7 = strlen((char const   *)s);
#line 2204
  s += tmp___7;
#line 2205
  sprintf((char */* __restrict  */)s, (char const   */* __restrict  */)" %s 270 90 arc closepath fill",
          sizebuf);
#line 2206
  tmp___8 = strlen((char const   *)s);
#line 2206
  s += tmp___8;
  }
#line 2207
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2209
  if (extra) {
    {
#line 2210
    sprintf((char */* __restrict  */)s, (char const   */* __restrict  */)" Border %s add %s add Border add BoxHeight border sub %s sub %s sub moveto /EntryFont findfont %s scalefont setfont (%s) show",
            sizebuf, sizebuf, sizebuf, sizebuf, fontsizebuf, extra);
#line 2212
    tmp___9 = strlen((char const   *)s);
#line 2212
    s += tmp___9;
    }
  }
  {
#line 2215
  sprintf((char */* __restrict  */)s, (char const   */* __restrict  */)" grestore");
#line 2216
  tmp___10 = RetStrVal((char const   *)(psbuff), info);
  }
#line 2216
  return (tmp___10);
}
}
#line 2226 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FMoonphase(func_info *info ) 
{ 
  int date ;
  int time___0 ;

  {
  {
#line 2231
  if (info->nargs == 0) {
#line 2231
    goto case_0;
  }
#line 2235
  if (info->nargs == 1) {
#line 2235
    goto case_1;
  }
#line 2244
  if (info->nargs == 2) {
#line 2244
    goto case_2;
  }
#line 2251
  goto switch_default;
  case_0: /* CIL Label */ 
#line 2232
  date = JulianToday;
#line 2233
  time___0 = 0;
#line 2234
  goto switch_break;
  case_1: /* CIL Label */ 
#line 2236
  if (! ((int )ValStack[ValStackPtr - info->nargs].type == 3)) {
#line 2236
    if (! ((int )ValStack[ValStackPtr - info->nargs].type == 5)) {
#line 2236
      return (14);
    }
  }
#line 2237
  if ((int )ValStack[ValStackPtr - info->nargs].type == 3) {
#line 2237
    date = ValStack[ValStackPtr - info->nargs].v.val;
  } else {
#line 2237
    date = ValStack[ValStackPtr - info->nargs].v.val / 1440;
  }
#line 2238
  if ((int )ValStack[ValStackPtr - info->nargs].type == 2) {
#line 2238
    goto _L;
  } else
#line 2238
  if ((int )ValStack[ValStackPtr - info->nargs].type == 5) {
    _L: /* CIL Label */ 
#line 2239
    if ((int )ValStack[ValStackPtr - info->nargs].type == 2) {
#line 2239
      time___0 = ValStack[ValStackPtr - info->nargs].v.val;
    } else {
#line 2239
      time___0 = ValStack[ValStackPtr - info->nargs].v.val % 1440;
    }
  } else {
#line 2241
    time___0 = 0;
  }
#line 2243
  goto switch_break;
  case_2: /* CIL Label */ 
#line 2245
  if ((int )ValStack[ValStackPtr - info->nargs].type == 5) {
#line 2245
    return (26);
  }
#line 2246
  if ((int )ValStack[ValStackPtr - info->nargs].type != 3) {
#line 2246
    if ((int )ValStack[(ValStackPtr - info->nargs) + 1].type != 2) {
#line 2246
      return (14);
    }
  }
#line 2247
  date = ValStack[ValStackPtr - info->nargs].v.val;
#line 2248
  time___0 = ValStack[(ValStackPtr - info->nargs) + 1].v.val;
#line 2249
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 2251
  return (23);
  switch_break: /* CIL Label */ ;
  }
  {
#line 2254
  info->retval.type = (char)1;
#line 2255
  info->retval.v.val = MoonPhase(date, time___0);
  }
#line 2256
  return (0);
}
}
#line 2266
static int MoonStuff(int type_wanted , func_info *info ) ;
#line 2267 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FMoondate(func_info *info ) 
{ 
  int tmp ;

  {
  {
#line 2269
  tmp = MoonStuff(3, info);
  }
#line 2269
  return (tmp);
}
}
#line 2272 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FMoontime(func_info *info ) 
{ 
  int tmp ;

  {
  {
#line 2274
  tmp = MoonStuff(2, info);
  }
#line 2274
  return (tmp);
}
}
#line 2277 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FMoondatetime(func_info *info ) 
{ 
  int tmp ;

  {
  {
#line 2279
  tmp = MoonStuff(5, info);
  }
#line 2279
  return (tmp);
}
}
#line 2282 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int MoonStuff(int type_wanted , func_info *info ) 
{ 
  int startdate ;
  int starttim ;
  int d ;
  int t ;

  {
#line 2287
  startdate = JulianToday;
#line 2288
  starttim = 0;
#line 2290
  if ((int )ValStack[ValStackPtr - info->nargs].type != 1) {
#line 2290
    return (14);
  }
#line 2291
  if (ValStack[ValStackPtr - info->nargs].v.val < 0) {
#line 2291
    return (29);
  }
#line 2292
  if (ValStack[ValStackPtr - info->nargs].v.val > 3) {
#line 2292
    return (28);
  }
#line 2293
  if (info->nargs >= 2) {
#line 2294
    if (! ((int )ValStack[(ValStackPtr - info->nargs) + 1].type == 3)) {
#line 2294
      if (! ((int )ValStack[(ValStackPtr - info->nargs) + 1].type == 5)) {
#line 2294
        return (14);
      }
    }
#line 2295
    if ((int )ValStack[(ValStackPtr - info->nargs) + 1].type == 3) {
#line 2295
      startdate = ValStack[(ValStackPtr - info->nargs) + 1].v.val;
    } else {
#line 2295
      startdate = ValStack[(ValStackPtr - info->nargs) + 1].v.val / 1440;
    }
#line 2296
    if ((int )ValStack[(ValStackPtr - info->nargs) + 1].type == 2) {
#line 2296
      goto _L;
    } else
#line 2296
    if ((int )ValStack[(ValStackPtr - info->nargs) + 1].type == 5) {
      _L: /* CIL Label */ 
#line 2297
      if ((int )ValStack[(ValStackPtr - info->nargs) + 1].type == 2) {
#line 2297
        starttim = ValStack[(ValStackPtr - info->nargs) + 1].v.val;
      } else {
#line 2297
        starttim = ValStack[(ValStackPtr - info->nargs) + 1].v.val % 1440;
      }
    }
#line 2300
    if (info->nargs >= 3) {
#line 2301
      if ((int )ValStack[(ValStackPtr - info->nargs) + 1].type == 2) {
#line 2301
        return (26);
      } else
#line 2301
      if ((int )ValStack[(ValStackPtr - info->nargs) + 1].type == 5) {
#line 2301
        return (26);
      }
#line 2302
      if ((int )ValStack[(ValStackPtr - info->nargs) + 2].type != 2) {
#line 2302
        return (14);
      }
#line 2303
      starttim = ValStack[(ValStackPtr - info->nargs) + 2].v.val;
    }
  }
  {
#line 2307
  HuntPhase(startdate, starttim, ValStack[ValStackPtr - info->nargs].v.val, & d, & t);
#line 2308
  info->retval.type = (char )type_wanted;
  }
  {
#line 2310
  if (type_wanted == 2) {
#line 2310
    goto case_2;
  }
#line 2313
  if (type_wanted == 3) {
#line 2313
    goto case_3;
  }
#line 2316
  if (type_wanted == 5) {
#line 2316
    goto case_5;
  }
#line 2319
  goto switch_default;
  case_2: /* CIL Label */ 
#line 2311
  info->retval.v.val = t;
#line 2312
  goto switch_break;
  case_3: /* CIL Label */ 
#line 2314
  info->retval.v.val = d;
#line 2315
  goto switch_break;
  case_5: /* CIL Label */ 
#line 2317
  info->retval.v.val = d * 1440 + t;
#line 2318
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 2320
  return (14);
  switch_break: /* CIL Label */ ;
  }
#line 2322
  return (0);
}
}
#line 2325 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FTimepart(func_info *info ) 
{ 


  {
#line 2327
  if (! ((int )ValStack[ValStackPtr - info->nargs].type == 2)) {
#line 2327
    if (! ((int )ValStack[ValStackPtr - info->nargs].type == 5)) {
#line 2327
      return (14);
    }
  }
#line 2328
  info->retval.type = (char)2;
#line 2329
  if ((int )ValStack[ValStackPtr - info->nargs].type == 2) {
#line 2329
    info->retval.v.val = ValStack[ValStackPtr - info->nargs].v.val;
  } else {
#line 2329
    info->retval.v.val = ValStack[ValStackPtr - info->nargs].v.val % 1440;
  }
#line 2330
  return (0);
}
}
#line 2333 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FDatepart(func_info *info ) 
{ 


  {
#line 2335
  if (! ((int )ValStack[ValStackPtr - info->nargs].type == 3)) {
#line 2335
    if (! ((int )ValStack[ValStackPtr - info->nargs].type == 5)) {
#line 2335
      return (14);
    }
  }
#line 2336
  info->retval.type = (char)3;
#line 2337
  if ((int )ValStack[ValStackPtr - info->nargs].type == 3) {
#line 2337
    info->retval.v.val = ValStack[ValStackPtr - info->nargs].v.val;
  } else {
#line 2337
    info->retval.v.val = ValStack[ValStackPtr - info->nargs].v.val / 1440;
  }
#line 2338
  return (0);
}
}
#line 2385 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int tz_set_tz(char const   *tz ) 
{ 
  int r ;

  {
#line 2388
  if ((unsigned long )tz == (unsigned long )((void *)0)) {
    {
#line 2389
    unsetenv("TZ");
#line 2390
    r = 0;
    }
  } else {
    {
#line 2392
    r = setenv("TZ", tz, 1);
    }
  }
  {
#line 2394
  tzset();
  }
#line 2395
  return (r);
}
}
#line 2398 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int tz_convert(int year , int month , int day , int hour , int minute , char const   *src_tz ,
                      char const   *tgt_tz , struct tm *tm ) 
{ 
  int r ;
  time_t t ;
  struct tm *res ;
  char const   *old_tz ;
  char *tmp ;

  {
  {
#line 2409
  tm->tm_sec = 0;
#line 2410
  tm->tm_min = minute;
#line 2411
  tm->tm_hour = hour;
#line 2412
  tm->tm_mday = day;
#line 2413
  tm->tm_mon = month;
#line 2414
  tm->tm_year = year - 1900;
#line 2415
  tm->tm_wday = 0;
#line 2416
  tm->tm_yday = 0;
#line 2417
  tm->tm_isdst = -1;
#line 2420
  tmp = getenv("TZ");
#line 2420
  old_tz = (char const   *)tmp;
  }
#line 2421
  if ((unsigned long )tgt_tz == (unsigned long )((void *)0)) {
#line 2422
    tgt_tz = old_tz;
  }
  {
#line 2426
  r = tz_set_tz(src_tz);
  }
#line 2427
  if (r == -1) {
#line 2428
    return (-1);
  }
  {
#line 2432
  t = mktime(tm);
  }
#line 2434
  if (t == -1L) {
    {
#line 2435
    tz_set_tz(old_tz);
    }
#line 2436
    return (-1);
  }
  {
#line 2440
  r = tz_set_tz(tgt_tz);
  }
#line 2441
  if (r == -1) {
    {
#line 2442
    tz_set_tz(old_tz);
    }
#line 2443
    return (-1);
  }
  {
#line 2447
  res = localtime_r((time_t const   */* __restrict  */)(& t), (struct tm */* __restrict  */)tm);
#line 2450
  tz_set_tz(old_tz);
  }
#line 2453
  if ((unsigned long )res == (unsigned long )((void *)0)) {
#line 2454
    return (-1);
  } else {
#line 2456
    return (1);
  }
}
}
#line 2460 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FTzconvert(func_info *info ) 
{ 
  int year ;
  int month ;
  int day ;
  int hour ;
  int minute ;
  int r ;
  int jul ;
  int tim ;
  struct tm tm ;
  int tmp ;

  {
#line 2466
  if ((int )ValStack[ValStackPtr - info->nargs].type != 5) {
#line 2467
    return (14);
  } else
#line 2466
  if ((int )ValStack[(ValStackPtr - info->nargs) + 1].type != 4) {
#line 2467
    return (14);
  }
#line 2468
  if (info->nargs == 3) {
#line 2468
    if ((int )ValStack[(ValStackPtr - info->nargs) + 2].type != 4) {
#line 2468
      return (14);
    }
  }
#line 2470
  if ((int )ValStack[ValStackPtr - info->nargs].type == 3) {
#line 2470
    tmp = ValStack[ValStackPtr - info->nargs].v.val;
  } else {
#line 2470
    tmp = ValStack[ValStackPtr - info->nargs].v.val / 1440;
  }
  {
#line 2470
  FromJulian(tmp, & year, & month, & day);
  }
#line 2472
  if ((int )ValStack[ValStackPtr - info->nargs].type == 2) {
#line 2472
    r = ValStack[ValStackPtr - info->nargs].v.val;
  } else {
#line 2472
    r = ValStack[ValStackPtr - info->nargs].v.val % 1440;
  }
#line 2473
  hour = r / 60;
#line 2474
  minute = r % 60;
#line 2476
  if (info->nargs == 2) {
    {
#line 2477
    r = tz_convert(year, month, day, hour, minute, (char const   *)ValStack[(ValStackPtr - info->nargs) + 1].v.str,
                   (char const   *)((void *)0), & tm);
    }
  } else {
    {
#line 2480
    r = tz_convert(year, month, day, hour, minute, (char const   *)ValStack[(ValStackPtr - info->nargs) + 1].v.str,
                   (char const   *)ValStack[(ValStackPtr - info->nargs) + 2].v.str,
                   & tm);
    }
  }
#line 2484
  if (r == -1) {
#line 2484
    return (99);
  }
  {
#line 2486
  jul = Julian(tm.tm_year + 1900, tm.tm_mon, tm.tm_mday);
#line 2487
  tim = tm.tm_hour * 60 + tm.tm_min;
#line 2488
  info->retval.type = (char)5;
#line 2489
  info->retval.v.val = jul * 1440 + tim;
  }
#line 2490
  return (0);
}
}
#line 2493 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FSlide(func_info *info ) 
{ 
  int r ;
  int omit ;
  int d ;
  int i ;
  int localomit ;
  int amt ;
  Token tok ;

  {
#line 2499
  if (! ((int )ValStack[ValStackPtr - info->nargs].type == 3)) {
#line 2499
    if (! ((int )ValStack[ValStackPtr - info->nargs].type == 5)) {
#line 2499
      return (14);
    }
  }
#line 2500
  if ((int )ValStack[(ValStackPtr - info->nargs) + 1].type != 1) {
#line 2500
    return (14);
  }
#line 2502
  if ((int )ValStack[ValStackPtr - info->nargs].type == 3) {
#line 2502
    d = ValStack[ValStackPtr - info->nargs].v.val;
  } else {
#line 2502
    d = ValStack[ValStackPtr - info->nargs].v.val / 1440;
  }
#line 2503
  amt = ValStack[(ValStackPtr - info->nargs) + 1].v.val;
#line 2504
  if (amt > 1000000) {
#line 2504
    return (28);
  }
#line 2505
  if (amt < -1000000) {
#line 2505
    return (29);
  }
#line 2507
  localomit = 0;
#line 2508
  i = 2;
  {
#line 2508
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2508
    if (! (i < info->nargs)) {
#line 2508
      goto while_break;
    }
#line 2509
    if ((int )ValStack[(ValStackPtr - info->nargs) + i].type != 4) {
#line 2509
      return (14);
    }
    {
#line 2510
    FindToken((char const   *)ValStack[(ValStackPtr - info->nargs) + i].v.str, & tok);
    }
#line 2511
    if ((unsigned int )tok.type != 17U) {
#line 2511
      return (53);
    }
#line 2512
    localomit |= 1 << tok.val;
#line 2508
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2516
  if (localomit == 127) {
#line 2516
    if (amt != 0) {
#line 2516
      return (37);
    }
  }
#line 2517
  if (amt > 0) {
    {
#line 2518
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2518
      if (! amt) {
#line 2518
        goto while_break___0;
      }
      {
#line 2519
      d ++;
#line 2520
      r = IsOmitted(d, localomit, (char const   *)((void *)0), & omit);
      }
#line 2521
      if (r) {
#line 2521
        return (r);
      }
#line 2522
      if (! omit) {
#line 2522
        amt --;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 2525
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2525
      if (! amt) {
#line 2525
        goto while_break___1;
      }
      {
#line 2526
      d --;
#line 2527
      r = IsOmitted(d, localomit, (char const   *)((void *)0), & omit);
      }
#line 2528
      if (r) {
#line 2528
        return (r);
      }
#line 2529
      if (! omit) {
#line 2529
        amt ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 2532
  info->retval.type = (char)3;
#line 2533
  info->retval.v.val = d;
#line 2534
  return (0);
}
}
#line 2537 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FNonomitted(func_info *info ) 
{ 
  int d1 ;
  int d2 ;
  int ans ;
  int localomit ;
  int i ;
  int omit ;
  int r ;
  Token tok ;
  int tmp ;

  {
#line 2544
  if ((int )ValStack[ValStackPtr - info->nargs].type == 3) {
#line 2544
    goto _L;
  } else
#line 2544
  if ((int )ValStack[ValStackPtr - info->nargs].type == 5) {
    _L: /* CIL Label */ 
#line 2544
    if (! ((int )ValStack[(ValStackPtr - info->nargs) + 1].type == 3)) {
#line 2544
      if (! ((int )ValStack[(ValStackPtr - info->nargs) + 1].type == 5)) {
#line 2546
        return (14);
      }
    }
  } else {
#line 2546
    return (14);
  }
#line 2548
  if ((int )ValStack[ValStackPtr - info->nargs].type == 3) {
#line 2548
    d1 = ValStack[ValStackPtr - info->nargs].v.val;
  } else {
#line 2548
    d1 = ValStack[ValStackPtr - info->nargs].v.val / 1440;
  }
#line 2549
  if ((int )ValStack[(ValStackPtr - info->nargs) + 1].type == 3) {
#line 2549
    d2 = ValStack[(ValStackPtr - info->nargs) + 1].v.val;
  } else {
#line 2549
    d2 = ValStack[(ValStackPtr - info->nargs) + 1].v.val / 1440;
  }
#line 2550
  if (d2 < d1) {
#line 2550
    return (29);
  }
#line 2552
  localomit = 0;
#line 2553
  i = 2;
  {
#line 2553
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2553
    if (! (i < info->nargs)) {
#line 2553
      goto while_break;
    }
#line 2554
    if ((int )ValStack[(ValStackPtr - info->nargs) + i].type != 4) {
#line 2554
      return (14);
    }
    {
#line 2555
    FindToken((char const   *)ValStack[(ValStackPtr - info->nargs) + i].v.str, & tok);
    }
#line 2556
    if ((unsigned int )tok.type != 17U) {
#line 2556
      return (53);
    }
#line 2557
    localomit |= 1 << tok.val;
#line 2553
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2560
  ans = 0;
  {
#line 2561
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2561
    if (! (d1 < d2)) {
#line 2561
      goto while_break___0;
    }
    {
#line 2562
    tmp = d1;
#line 2562
    d1 ++;
#line 2562
    r = IsOmitted(tmp, localomit, (char const   *)((void *)0), & omit);
    }
#line 2563
    if (r) {
#line 2563
      return (r);
    }
#line 2564
    if (! omit) {
#line 2565
      ans ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2568
  info->retval.type = (char)1;
#line 2569
  info->retval.v.val = ans;
#line 2570
  return (0);
}
}
#line 2573 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FWeekno(func_info *info ) 
{ 
  int jul ;
  int wkstart ;
  int daystart ;
  int monstart ;
  int candidate ;
  int y ;
  int m ;
  int d ;

  {
#line 2576
  jul = JulianToday;
#line 2577
  wkstart = 0;
#line 2578
  daystart = 29;
#line 2584
  if (info->nargs >= 1) {
#line 2585
    if (! ((int )ValStack[ValStackPtr - info->nargs].type == 3)) {
#line 2585
      if (! ((int )ValStack[ValStackPtr - info->nargs].type == 5)) {
#line 2585
        return (14);
      }
    }
#line 2586
    if ((int )ValStack[ValStackPtr - info->nargs].type == 3) {
#line 2586
      jul = ValStack[ValStackPtr - info->nargs].v.val;
    } else {
#line 2586
      jul = ValStack[ValStackPtr - info->nargs].v.val / 1440;
    }
  }
#line 2588
  if (info->nargs >= 2) {
#line 2589
    if ((int )ValStack[(ValStackPtr - info->nargs) + 1].type != 1) {
#line 2589
      return (14);
    }
#line 2590
    if (ValStack[(ValStackPtr - info->nargs) + 1].v.val < 0) {
#line 2590
      return (29);
    }
#line 2591
    if (ValStack[(ValStackPtr - info->nargs) + 1].v.val > 6) {
#line 2591
      return (28);
    }
#line 2592
    wkstart = ValStack[(ValStackPtr - info->nargs) + 1].v.val;
#line 2594
    wkstart --;
#line 2595
    if (wkstart < 0) {
#line 2595
      wkstart = 6;
    }
#line 2596
    if (info->nargs >= 3) {
#line 2597
      if ((int )ValStack[(ValStackPtr - info->nargs) + 2].type != 1) {
#line 2597
        return (14);
      }
#line 2598
      if (ValStack[(ValStackPtr - info->nargs) + 2].v.val < 1) {
#line 2598
        return (29);
      }
#line 2599
      if (ValStack[(ValStackPtr - info->nargs) + 2].v.val > 31) {
#line 2599
        return (28);
      }
#line 2600
      daystart = ValStack[(ValStackPtr - info->nargs) + 2].v.val;
    }
  }
#line 2604
  info->retval.type = (char)1;
#line 2607
  if (daystart <= 7) {
#line 2608
    monstart = 0;
  } else {
#line 2610
    monstart = 11;
  }
  {
#line 2613
  FromJulian(jul, & y, & m, & d);
#line 2616
  candidate = Julian(y, monstart, daystart);
  }
  {
#line 2617
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2617
    if (! (candidate % 7 != wkstart)) {
#line 2617
      goto while_break;
    }
#line 2617
    candidate ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2619
  if (candidate <= jul) {
#line 2620
    info->retval.v.val = (jul - candidate) / 7 + 1;
#line 2621
    return (0);
  }
#line 2624
  if (y - 1 < 1990) {
#line 2624
    return (15);
  }
  {
#line 2626
  candidate = Julian(y - 1, monstart, daystart);
  }
  {
#line 2627
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2627
    if (! (candidate % 7 != wkstart)) {
#line 2627
      goto while_break___0;
    }
#line 2627
    candidate ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2628
  if (candidate <= jul) {
#line 2629
    info->retval.v.val = (jul - candidate) / 7 + 1;
#line 2630
    return (0);
  }
#line 2633
  if (y - 2 < 1990) {
#line 2633
    return (15);
  }
  {
#line 2635
  candidate = Julian(y - 2, monstart, daystart);
  }
  {
#line 2636
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2636
    if (! (candidate % 7 != wkstart)) {
#line 2636
      goto while_break___1;
    }
#line 2636
    candidate ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2637
  info->retval.v.val = (jul - candidate) / 7 + 1;
#line 2638
  return (0);
}
}
#line 2641 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/funcs.c"
static int FEvalTrig(func_info *info ) 
{ 
  Parser p ;
  Trigger trig ;
  TimeTrig tim ;
  int jul ;
  int scanfrom ;
  int r ;

  {
#line 2650
  if ((int )ValStack[ValStackPtr - info->nargs].type != 4) {
#line 2650
    return (14);
  }
#line 2651
  if (info->nargs >= 2) {
#line 2652
    if (! ((int )ValStack[(ValStackPtr - info->nargs) + 1].type == 3)) {
#line 2652
      if (! ((int )ValStack[(ValStackPtr - info->nargs) + 1].type == 5)) {
#line 2652
        return (14);
      }
    }
#line 2653
    if ((int )ValStack[(ValStackPtr - info->nargs) + 1].type == 3) {
#line 2653
      scanfrom = ValStack[(ValStackPtr - info->nargs) + 1].v.val;
    } else {
#line 2653
      scanfrom = ValStack[(ValStackPtr - info->nargs) + 1].v.val / 1440;
    }
  } else {
#line 2655
    scanfrom = -1;
  }
  {
#line 2658
  CreateParser((char const   *)ValStack[ValStackPtr - info->nargs].v.str, & p);
#line 2659
  p.allownested = (char)0;
#line 2660
  r = ParseRem(& p, & trig, & tim, 0);
  }
#line 2661
  if (r) {
#line 2661
    return (r);
  }
#line 2662
  if (trig.typ != 0) {
    {
#line 2663
    FreeTrig(& trig);
    }
#line 2664
    return (32);
  }
#line 2666
  if (scanfrom == -1) {
    {
#line 2667
    jul = ComputeTrigger(trig.scanfrom, & trig, & r, 0);
    }
  } else {
#line 2670
    if (trig.scanfrom != JulianToday) {
      {
#line 2671
      Eprint("Warning: SCANFROM is ignored in two-argument form of evaltrig()");
      }
    }
    {
#line 2673
    jul = ComputeTrigger(scanfrom, & trig, & r, 0);
    }
  }
  {
#line 2675
  FreeTrig(& trig);
  }
#line 2676
  if (r) {
#line 2676
    return (r);
  }
#line 2677
  if (jul < 0) {
#line 2678
    info->retval.type = (char)1;
#line 2679
    info->retval.v.val = jul;
  } else
#line 2680
  if (tim.ttime == 2147483647) {
#line 2681
    info->retval.type = (char)3;
#line 2682
    info->retval.v.val = jul;
  } else {
#line 2684
    info->retval.type = (char)5;
#line 2685
    info->retval.v.val = 1440 * jul + tim.ttime;
  }
#line 2687
  return (0);
}
}
#line 28 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/trigger.c"
static int JYear(int jul ) ;
#line 29
static int JMonth(int jul ) ;
#line 30
static int NextSimpleTrig(int startdate , Trigger *trig , int *err ) ;
#line 31
static int GetNextTriggerDate(Trigger *trig , int start , int *err , int *nextstart ) ;
#line 45 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/trigger.c"
static int NextSimpleTrig(int startdate , Trigger *trig , int *err ) 
{ 
  int typ ;
  int d ;
  int m ;
  int y ;
  int j ;
  int d2 ;
  int m2 ;
  int y2 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;

  {
  {
#line 47
  typ = 0;
#line 50
  *err = 0;
#line 51
  FromJulian(startdate, & y, & m, & d);
#line 52
  d2 = d;
#line 53
  m2 = m;
#line 54
  y2 = y;
  }
#line 56
  if (trig->d != -1) {
#line 56
    typ |= 1;
  }
#line 57
  if (trig->m != -1) {
#line 57
    typ |= 2;
  }
#line 58
  if (trig->y != -1) {
#line 58
    typ |= 4;
  }
#line 59
  if (trig->wd != 0) {
#line 59
    typ |= 8;
  }
  {
#line 62
  if (typ == 8) {
#line 62
    goto case_8;
  }
#line 62
  if (typ == 0) {
#line 62
    goto case_8;
  }
#line 67
  if (typ == 1) {
#line 67
    goto case_1;
  }
#line 76
  if (typ == 2) {
#line 76
    goto case_2;
  }
#line 81
  if (typ == 4) {
#line 81
    goto case_4;
  }
#line 86
  if (typ == 3) {
#line 86
    goto case_3;
  }
#line 97
  if (typ == 5) {
#line 97
    goto case_5;
  }
#line 108
  if (typ == 6) {
#line 108
    goto case_6;
  }
#line 114
  if (typ == 7) {
#line 114
    goto case_7;
  }
#line 121
  if (typ == 12) {
#line 121
    goto case_12;
  }
#line 129
  if (typ == 10) {
#line 129
    goto case_10;
  }
#line 140
  if (typ == 9) {
#line 140
    goto case_9;
  }
#line 169
  if (typ == 13) {
#line 169
    goto case_13;
  }
#line 204
  if (typ == 11) {
#line 204
    goto case_11;
  }
#line 235
  if (typ == 14) {
#line 235
    goto case_14;
  }
#line 248
  if (typ == 15) {
#line 248
    goto case_15;
  }
#line 257
  goto switch_default;
  case_8: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 63
  if (trig->wd != 0) {
    {
#line 64
    while (1) {
      while_continue: /* CIL Label */ ;
#line 64
      if (! (! (trig->wd & (1 << startdate % 7)))) {
#line 64
        goto while_break;
      }
#line 64
      startdate ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 65
  return (startdate);
  case_1: /* CIL Label */ 
#line 68
  if (d > trig->d) {
#line 69
    m ++;
#line 70
    if (m == 12) {
#line 70
      m = 0;
#line 70
      y ++;
    }
  }
  {
#line 72
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 72
    if (m != 1) {
#line 72
      tmp___1 = MonthDays[m];
    } else {
#line 72
      if (trig->y % 4) {
#line 72
        tmp___0 = 0;
      } else {
#line 72
        if (! (trig->y % 100)) {
#line 72
          if (trig->y % 400) {
#line 72
            tmp = 0;
          } else {
#line 72
            tmp = 1;
          }
        } else {
#line 72
          tmp = 1;
        }
#line 72
        tmp___0 = tmp;
      }
#line 72
      tmp___1 = 28 + tmp___0;
    }
#line 72
    if (! (trig->d > tmp___1)) {
#line 72
      goto while_break___0;
    }
#line 72
    m ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 73
  j = Julian(y, m, trig->d);
  }
#line 74
  return (j);
  case_2: /* CIL Label */ 
#line 77
  if (m == trig->m) {
#line 77
    return (startdate);
  } else
#line 78
  if (m > trig->m) {
    {
#line 78
    tmp___2 = Julian(y + 1, trig->m, 1);
    }
#line 78
    return (tmp___2);
  } else {
    {
#line 79
    tmp___3 = Julian(y, trig->m, 1);
    }
#line 79
    return (tmp___3);
  }
  case_4: /* CIL Label */ 
#line 82
  if (y == trig->y) {
#line 82
    return (startdate);
  } else
#line 83
  if (y < trig->y) {
    {
#line 83
    tmp___4 = Julian(trig->y, 0, 1);
    }
#line 83
    return (tmp___4);
  } else {
#line 84
    return (-1);
  }
  case_3: /* CIL Label */ 
#line 87
  if (m > trig->m) {
#line 87
    y ++;
  } else
#line 87
  if (m == trig->m) {
#line 87
    if (d > trig->d) {
#line 87
      y ++;
    }
  }
#line 88
  if (trig->d > MonthDays[trig->m]) {
#line 89
    *err = 24;
#line 90
    return (-1);
  }
  {
#line 94
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 94
    if (trig->m != 1) {
#line 94
      tmp___7 = MonthDays[trig->m];
    } else {
#line 94
      if (y % 4) {
#line 94
        tmp___6 = 0;
      } else {
#line 94
        if (! (y % 100)) {
#line 94
          if (y % 400) {
#line 94
            tmp___5 = 0;
          } else {
#line 94
            tmp___5 = 1;
          }
        } else {
#line 94
          tmp___5 = 1;
        }
#line 94
        tmp___6 = tmp___5;
      }
#line 94
      tmp___7 = 28 + tmp___6;
    }
#line 94
    if (! (trig->d > tmp___7)) {
#line 94
      goto while_break___1;
    }
#line 94
    y ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 95
  tmp___8 = Julian(y, trig->m, trig->d);
  }
#line 95
  return (tmp___8);
  case_5: /* CIL Label */ 
#line 98
  if (y < trig->y) {
    {
#line 98
    tmp___9 = Julian(trig->y, 0, trig->d);
    }
#line 98
    return (tmp___9);
  } else
#line 99
  if (y > trig->y) {
#line 99
    return (-1);
  }
#line 101
  if (d > trig->d) {
#line 102
    m ++;
#line 103
    if (m == 12) {
#line 103
      return (-1);
    }
  }
  {
#line 105
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 105
    if (m != 1) {
#line 105
      tmp___12 = MonthDays[m];
    } else {
#line 105
      if (trig->y % 4) {
#line 105
        tmp___11 = 0;
      } else {
#line 105
        if (! (trig->y % 100)) {
#line 105
          if (trig->y % 400) {
#line 105
            tmp___10 = 0;
          } else {
#line 105
            tmp___10 = 1;
          }
        } else {
#line 105
          tmp___10 = 1;
        }
#line 105
        tmp___11 = tmp___10;
      }
#line 105
      tmp___12 = 28 + tmp___11;
    }
#line 105
    if (! (trig->d > tmp___12)) {
#line 105
      goto while_break___2;
    }
#line 105
    m ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 106
  tmp___13 = Julian(trig->y, m, trig->d);
  }
#line 106
  return (tmp___13);
  case_6: /* CIL Label */ 
#line 109
  if (y > trig->y) {
#line 109
    return (-1);
  } else
#line 109
  if (y == trig->y) {
#line 109
    if (m > trig->m) {
#line 109
      return (-1);
    }
  }
#line 110
  if (y < trig->y) {
    {
#line 110
    tmp___14 = Julian(trig->y, trig->m, 1);
    }
#line 110
    return (tmp___14);
  }
#line 111
  if (m == trig->m) {
#line 111
    return (startdate);
  }
  {
#line 112
  tmp___15 = Julian(trig->y, trig->m, 1);
  }
#line 112
  return (tmp___15);
  case_7: /* CIL Label */ 
#line 115
  if (trig->m != 1) {
#line 115
    tmp___18 = MonthDays[trig->m];
  } else {
#line 115
    if (trig->y % 4) {
#line 115
      tmp___17 = 0;
    } else {
#line 115
      if (! (trig->y % 100)) {
#line 115
        if (trig->y % 400) {
#line 115
          tmp___16 = 0;
        } else {
#line 115
          tmp___16 = 1;
        }
      } else {
#line 115
        tmp___16 = 1;
      }
#line 115
      tmp___17 = tmp___16;
    }
#line 115
    tmp___18 = 28 + tmp___17;
  }
#line 115
  if (trig->d > tmp___18) {
#line 116
    *err = 24;
#line 117
    return (-1);
  }
  {
#line 119
  tmp___19 = Julian(trig->y, trig->m, trig->d);
  }
#line 119
  return (tmp___19);
  case_12: /* CIL Label */ 
#line 122
  if (y > trig->y) {
#line 122
    return (-1);
  }
#line 123
  if (y < trig->y) {
    {
#line 123
    j = Julian(trig->y, 0, 1);
    }
  } else {
#line 124
    j = startdate;
  }
  {
#line 125
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 125
    if (! (! (trig->wd & (1 << j % 7)))) {
#line 125
      goto while_break___3;
    }
#line 125
    j ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 126
  tmp___20 = JYear(j);
  }
#line 126
  if (tmp___20 > trig->y) {
#line 126
    return (-1);
  }
#line 127
  return (j);
  case_10: /* CIL Label */ 
#line 130
  if (m == trig->m) {
#line 131
    j = startdate;
    {
#line 132
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 132
      if (! (! (trig->wd & (1 << j % 7)))) {
#line 132
        goto while_break___4;
      }
#line 132
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 133
    tmp___21 = JMonth(j);
    }
#line 133
    if (tmp___21 == trig->m) {
#line 133
      return (j);
    }
  }
#line 135
  if (m >= trig->m) {
    {
#line 135
    j = Julian(y + 1, trig->m, 1);
    }
  } else {
    {
#line 136
    j = Julian(y, trig->m, 1);
    }
  }
  {
#line 137
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 137
    if (! (! (trig->wd & (1 << j % 7)))) {
#line 137
      goto while_break___5;
    }
#line 137
    j ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 138
  return (j);
  case_9: /* CIL Label */ 
#line 141
  if (m != 0) {
#line 141
    goto _L;
  } else
#line 141
  if (y > 1990) {
    _L: /* CIL Label */ 
#line 142
    m2 = m - 1;
#line 143
    if (m2 < 0) {
#line 143
      y2 = y - 1;
#line 143
      m2 = 11;
    }
#line 146
    if (m2 != 1) {
#line 146
      tmp___24 = MonthDays[m2];
    } else {
#line 146
      if (y2 % 4) {
#line 146
        tmp___23 = 0;
      } else {
#line 146
        if (! (y2 % 100)) {
#line 146
          if (y2 % 400) {
#line 146
            tmp___22 = 0;
          } else {
#line 146
            tmp___22 = 1;
          }
        } else {
#line 146
          tmp___22 = 1;
        }
#line 146
        tmp___23 = tmp___22;
      }
#line 146
      tmp___24 = 28 + tmp___23;
    }
#line 146
    if (trig->d <= tmp___24) {
      {
#line 147
      j = Julian(y2, m2, trig->d);
      }
      {
#line 148
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 148
        if (! (! (trig->wd & (1 << j % 7)))) {
#line 148
          goto while_break___6;
        }
#line 148
        j ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 149
      if (j >= startdate) {
#line 149
        return (j);
      }
    }
  }
#line 155
  if (m != 1) {
#line 155
    tmp___27 = MonthDays[m];
  } else {
#line 155
    if (y % 4) {
#line 155
      tmp___26 = 0;
    } else {
#line 155
      if (! (y % 100)) {
#line 155
        if (y % 400) {
#line 155
          tmp___25 = 0;
        } else {
#line 155
          tmp___25 = 1;
        }
      } else {
#line 155
        tmp___25 = 1;
      }
#line 155
      tmp___26 = tmp___25;
    }
#line 155
    tmp___27 = 28 + tmp___26;
  }
#line 155
  if (trig->d <= tmp___27) {
    {
#line 156
    j = Julian(y, m, trig->d);
    }
    {
#line 157
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 157
      if (! (! (trig->wd & (1 << j % 7)))) {
#line 157
        goto while_break___7;
      }
#line 157
      j ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 158
    if (j >= startdate) {
#line 158
      return (j);
    }
  }
#line 162
  m2 = m + 1;
#line 163
  if (m2 > 11) {
#line 163
    m2 = 0;
#line 163
    y ++;
  }
  {
#line 164
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 164
    if (m2 != 1) {
#line 164
      tmp___30 = MonthDays[m2];
    } else {
#line 164
      if (y % 4) {
#line 164
        tmp___29 = 0;
      } else {
#line 164
        if (! (y % 100)) {
#line 164
          if (y % 400) {
#line 164
            tmp___28 = 0;
          } else {
#line 164
            tmp___28 = 1;
          }
        } else {
#line 164
          tmp___28 = 1;
        }
#line 164
        tmp___29 = tmp___28;
      }
#line 164
      tmp___30 = 28 + tmp___29;
    }
#line 164
    if (! (trig->d > tmp___30)) {
#line 164
      goto while_break___8;
    }
#line 164
    m2 ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 165
  j = Julian(y, m2, trig->d);
  }
  {
#line 166
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 166
    if (! (! (trig->wd & (1 << j % 7)))) {
#line 166
      goto while_break___9;
    }
#line 166
    j ++;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 167
  return (j);
  case_13: /* CIL Label */ 
#line 170
  if (y > trig->y + 1) {
#line 170
    return (-1);
  } else
#line 170
  if (y > trig->y) {
#line 170
    if (m > 0) {
#line 170
      return (-1);
    }
  }
#line 171
  if (y > trig->y) {
    {
#line 172
    j = Julian(trig->y, 11, trig->d);
    }
    {
#line 173
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 173
      if (! (! (trig->wd & (1 << j % 7)))) {
#line 173
        goto while_break___10;
      }
#line 173
      j ++;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 174
    if (j >= startdate) {
#line 174
      return (j);
    }
  } else
#line 175
  if (y < trig->y) {
    {
#line 176
    j = Julian(trig->y, 0, trig->d);
    }
    {
#line 177
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 177
      if (! (! (trig->wd & (1 << j % 7)))) {
#line 177
        goto while_break___11;
      }
#line 177
      j ++;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 178
    return (j);
  } else
#line 181
  if (m > 0) {
#line 182
    m2 = m - 1;
    {
#line 183
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 183
      if (m2 != 1) {
#line 183
        tmp___33 = MonthDays[m2];
      } else {
#line 183
        if (trig->y % 4) {
#line 183
          tmp___32 = 0;
        } else {
#line 183
          if (! (trig->y % 100)) {
#line 183
            if (trig->y % 400) {
#line 183
              tmp___31 = 0;
            } else {
#line 183
              tmp___31 = 1;
            }
          } else {
#line 183
            tmp___31 = 1;
          }
#line 183
          tmp___32 = tmp___31;
        }
#line 183
        tmp___33 = 28 + tmp___32;
      }
#line 183
      if (! (trig->d > tmp___33)) {
#line 183
        goto while_break___12;
      }
#line 183
      m2 --;
    }
    while_break___12: /* CIL Label */ ;
    }
    {
#line 184
    j = Julian(trig->y, m2, trig->d);
    }
    {
#line 185
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 185
      if (! (! (trig->wd & (1 << j % 7)))) {
#line 185
        goto while_break___13;
      }
#line 185
      j ++;
    }
    while_break___13: /* CIL Label */ ;
    }
#line 186
    if (j >= startdate) {
#line 186
      return (j);
    }
  }
#line 190
  if (m != 1) {
#line 190
    tmp___36 = MonthDays[m];
  } else {
#line 190
    if (trig->y % 4) {
#line 190
      tmp___35 = 0;
    } else {
#line 190
      if (! (trig->y % 100)) {
#line 190
        if (trig->y % 400) {
#line 190
          tmp___34 = 0;
        } else {
#line 190
          tmp___34 = 1;
        }
      } else {
#line 190
        tmp___34 = 1;
      }
#line 190
      tmp___35 = tmp___34;
    }
#line 190
    tmp___36 = 28 + tmp___35;
  }
#line 190
  if (trig->d <= tmp___36) {
    {
#line 191
    j = Julian(trig->y, m, trig->d);
    }
    {
#line 192
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 192
      if (! (! (trig->wd & (1 << j % 7)))) {
#line 192
        goto while_break___14;
      }
#line 192
      j ++;
    }
    while_break___14: /* CIL Label */ ;
    }
#line 193
    if (j >= startdate) {
#line 193
      return (j);
    }
  }
#line 197
  if (m == 11) {
#line 197
    return (-1);
  }
#line 198
  m ++;
  {
#line 199
  while (1) {
    while_continue___15: /* CIL Label */ ;
#line 199
    if (m != 1) {
#line 199
      tmp___39 = MonthDays[m];
    } else {
#line 199
      if (trig->d % 4) {
#line 199
        tmp___38 = 0;
      } else {
#line 199
        if (! (trig->d % 100)) {
#line 199
          if (trig->d % 400) {
#line 199
            tmp___37 = 0;
          } else {
#line 199
            tmp___37 = 1;
          }
        } else {
#line 199
          tmp___37 = 1;
        }
#line 199
        tmp___38 = tmp___37;
      }
#line 199
      tmp___39 = 28 + tmp___38;
    }
#line 199
    if (! (trig->d > tmp___39)) {
#line 199
      goto while_break___15;
    }
#line 199
    m ++;
  }
  while_break___15: /* CIL Label */ ;
  }
  {
#line 200
  j = Julian(trig->y, m, trig->d);
  }
  {
#line 201
  while (1) {
    while_continue___16: /* CIL Label */ ;
#line 201
    if (! (! (trig->wd & (1 << j % 7)))) {
#line 201
      goto while_break___16;
    }
#line 201
    j ++;
  }
  while_break___16: /* CIL Label */ ;
  }
#line 202
  return (j);
  case_11: /* CIL Label */ 
#line 205
  if (trig->d > MonthDays[trig->m]) {
#line 206
    *err = 24;
#line 207
    return (-1);
  }
#line 210
  if (y > 1990) {
#line 211
    y --;
  }
  {
#line 215
  while (1) {
    while_continue___17: /* CIL Label */ ;
#line 215
    if (trig->m != 1) {
#line 215
      tmp___42 = MonthDays[trig->m];
    } else {
#line 215
      if (y % 4) {
#line 215
        tmp___41 = 0;
      } else {
#line 215
        if (! (y % 100)) {
#line 215
          if (y % 400) {
#line 215
            tmp___40 = 0;
          } else {
#line 215
            tmp___40 = 1;
          }
        } else {
#line 215
          tmp___40 = 1;
        }
#line 215
        tmp___41 = tmp___40;
      }
#line 215
      tmp___42 = 28 + tmp___41;
    }
#line 215
    if (! (trig->d > tmp___42)) {
#line 215
      goto while_break___17;
    }
#line 215
    y ++;
  }
  while_break___17: /* CIL Label */ ;
  }
  {
#line 218
  j = Julian(y, trig->m, trig->d);
  }
  {
#line 219
  while (1) {
    while_continue___18: /* CIL Label */ ;
#line 219
    if (! (! (trig->wd & (1 << j % 7)))) {
#line 219
      goto while_break___18;
    }
#line 219
    j ++;
  }
  while_break___18: /* CIL Label */ ;
  }
#line 220
  if (j >= startdate) {
#line 220
    return (j);
  }
  {
#line 223
  y ++;
#line 224
  j = Julian(y, trig->m, trig->d);
  }
  {
#line 225
  while (1) {
    while_continue___19: /* CIL Label */ ;
#line 225
    if (! (! (trig->wd & (1 << j % 7)))) {
#line 225
      goto while_break___19;
    }
#line 225
    j ++;
  }
  while_break___19: /* CIL Label */ ;
  }
#line 226
  if (j >= startdate) {
#line 226
    return (j);
  }
#line 229
  y ++;
  {
#line 230
  while (1) {
    while_continue___20: /* CIL Label */ ;
#line 230
    if (trig->m != 1) {
#line 230
      tmp___45 = MonthDays[trig->m];
    } else {
#line 230
      if (y % 4) {
#line 230
        tmp___44 = 0;
      } else {
#line 230
        if (! (y % 100)) {
#line 230
          if (y % 400) {
#line 230
            tmp___43 = 0;
          } else {
#line 230
            tmp___43 = 1;
          }
        } else {
#line 230
          tmp___43 = 1;
        }
#line 230
        tmp___44 = tmp___43;
      }
#line 230
      tmp___45 = 28 + tmp___44;
    }
#line 230
    if (! (trig->d > tmp___45)) {
#line 230
      goto while_break___20;
    }
#line 230
    y ++;
  }
  while_break___20: /* CIL Label */ ;
  }
  {
#line 231
  j = Julian(y, trig->m, trig->d);
  }
  {
#line 232
  while (1) {
    while_continue___21: /* CIL Label */ ;
#line 232
    if (! (! (trig->wd & (1 << j % 7)))) {
#line 232
      goto while_break___21;
    }
#line 232
    j ++;
  }
  while_break___21: /* CIL Label */ ;
  }
#line 233
  return (j);
  case_14: /* CIL Label */ 
#line 236
  if (y > trig->y) {
#line 236
    return (-1);
  } else
#line 236
  if (y == trig->y) {
#line 236
    if (m > trig->m) {
#line 236
      return (-1);
    }
  }
#line 237
  if (trig->y > y) {
#line 237
    goto _L___0;
  } else
#line 237
  if (trig->y == y) {
#line 237
    if (trig->m > m) {
      _L___0: /* CIL Label */ 
      {
#line 238
      j = Julian(trig->y, trig->m, 1);
      }
      {
#line 239
      while (1) {
        while_continue___22: /* CIL Label */ ;
#line 239
        if (! (! (trig->wd & (1 << j % 7)))) {
#line 239
          goto while_break___22;
        }
#line 239
        j ++;
      }
      while_break___22: /* CIL Label */ ;
      }
#line 240
      return (j);
    } else {
#line 237
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
#line 242
    j = startdate;
    {
#line 243
    while (1) {
      while_continue___23: /* CIL Label */ ;
#line 243
      if (! (! (trig->wd & (1 << j % 7)))) {
#line 243
        goto while_break___23;
      }
#line 243
      j ++;
    }
    while_break___23: /* CIL Label */ ;
    }
    {
#line 244
    FromJulian(j, & y2, & m2, & d2);
    }
#line 245
    if (m2 == trig->m) {
#line 245
      return (j);
    } else {
#line 245
      return (-1);
    }
  }
  case_15: /* CIL Label */ 
#line 249
  if (trig->m != 1) {
#line 249
    tmp___48 = MonthDays[trig->m];
  } else {
#line 249
    if (trig->y % 4) {
#line 249
      tmp___47 = 0;
    } else {
#line 249
      if (! (trig->y % 100)) {
#line 249
        if (trig->y % 400) {
#line 249
          tmp___46 = 0;
        } else {
#line 249
          tmp___46 = 1;
        }
      } else {
#line 249
        tmp___46 = 1;
      }
#line 249
      tmp___47 = tmp___46;
    }
#line 249
    tmp___48 = 28 + tmp___47;
  }
#line 249
  if (trig->d > tmp___48) {
#line 250
    *err = 24;
#line 251
    return (-1);
  }
  {
#line 253
  j = Julian(trig->y, trig->m, trig->d);
  }
  {
#line 254
  while (1) {
    while_continue___24: /* CIL Label */ ;
#line 254
    if (! (! (trig->wd & (1 << j % 7)))) {
#line 254
      goto while_break___24;
    }
#line 254
    j ++;
  }
  while_break___24: /* CIL Label */ ;
  }
#line 255
  return (j);
  switch_default: /* CIL Label */ 
  {
#line 258
  Eprint("NextSimpleTrig %s %d", ErrMsg[23], typ);
#line 259
  *err = 23;
  }
#line 260
  return (-1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 269 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/trigger.c"
static int JMonth(int jul ) 
{ 
  int y ;
  int m ;
  int d ;

  {
  {
#line 272
  FromJulian(jul, & y, & m, & d);
  }
#line 273
  return (m);
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/trigger.c"
static int JYear(int jul ) 
{ 
  int y ;
  int m ;
  int d ;

  {
  {
#line 284
  FromJulian(jul, & y, & m, & d);
  }
#line 285
  return (y);
}
}
#line 298 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/trigger.c"
static int GetNextTriggerDate(Trigger *trig , int start , int *err , int *nextstart ) 
{ 
  int simple ;
  int mod ;
  int omit ;
  int iter ;
  int tmp ;
  int iter___0 ;
  int max ;
  int tmp___0 ;
  int iter___1 ;
  int tmp___1 ;
  int iter___2 ;
  int tmp___2 ;

  {
#line 303
  if (trig->until != -1) {
#line 303
    if (trig->until < start) {
#line 305
      trig->expired = 1;
#line 306
      return (-1);
    }
  }
#line 311
  if (trig->skip == 3) {
#line 312
    iter = 0;
    {
#line 313
    while (1) {
      while_continue: /* CIL Label */ ;
#line 313
      tmp = iter;
#line 313
      iter ++;
#line 313
      if (! (tmp <= MaxSatIter)) {
#line 313
        goto while_break;
      }
      {
#line 314
      *err = IsOmitted(start - 1, trig->localomit, (char const   *)(trig->omitfunc),
                       & omit);
      }
#line 315
      if (*err) {
#line 315
        return (-2);
      }
#line 316
      if (! omit) {
#line 317
        goto while_break;
      }
#line 319
      start --;
    }
    while_break: /* CIL Label */ ;
    }
#line 321
    if (iter > MaxSatIter) {
#line 323
      *err = 33;
#line 324
      return (-2);
    }
  }
  {
#line 329
  simple = NextSimpleTrig(start, trig, err);
  }
#line 332
  if (*err) {
#line 332
    return (-1);
  } else
#line 332
  if (simple == -1) {
#line 332
    return (-1);
  }
#line 335
  *nextstart = simple + 1;
#line 338
  if (trig->back != 0) {
#line 339
    mod = trig->back;
#line 340
    if (mod < 0) {
#line 341
      simple += mod;
    } else {
#line 344
      iter___0 = 0;
#line 345
      max = MaxSatIter;
#line 346
      if (max < mod * 2) {
#line 347
        max = mod * 2;
      }
      {
#line 349
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 349
        tmp___0 = iter___0;
#line 349
        iter___0 ++;
#line 349
        if (! (tmp___0 <= max)) {
#line 349
          goto while_break___0;
        }
#line 350
        if (! mod) {
#line 351
          goto while_break___0;
        }
        {
#line 353
        simple --;
#line 354
        *err = IsOmitted(simple, trig->localomit, (char const   *)(trig->omitfunc),
                         & omit);
        }
#line 355
        if (*err) {
#line 355
          return (-2);
        }
#line 356
        if (! omit) {
#line 356
          mod --;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 358
      if (iter___0 > max) {
#line 359
        *err = 33;
#line 360
        return (-2);
      }
    }
  }
#line 366
  if (trig->rep != 0) {
#line 367
    if (simple < start) {
#line 368
      mod = (start - simple) / trig->rep;
#line 369
      simple += mod * trig->rep;
#line 370
      if (simple < start) {
#line 370
        simple += trig->rep;
      }
    }
  }
#line 375
  if (trig->skip == 2) {
#line 376
    iter___1 = 0;
    {
#line 377
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 377
      tmp___1 = iter___1;
#line 377
      iter___1 ++;
#line 377
      if (! (tmp___1 <= MaxSatIter)) {
#line 377
        goto while_break___1;
      }
      {
#line 378
      *err = IsOmitted(simple, trig->localomit, (char const   *)(trig->omitfunc),
                       & omit);
      }
#line 379
      if (*err) {
#line 379
        return (-2);
      }
#line 380
      if (! omit) {
#line 381
        goto while_break___1;
      }
#line 383
      simple --;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 385
    if (iter___1 > MaxSatIter) {
#line 386
      *err = 33;
#line 387
      return (-2);
    }
  }
#line 392
  if (trig->skip == 3) {
#line 393
    iter___2 = 0;
    {
#line 394
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 394
      tmp___2 = iter___2;
#line 394
      iter___2 ++;
#line 394
      if (! (tmp___2 <= MaxSatIter)) {
#line 394
        goto while_break___2;
      }
      {
#line 395
      *err = IsOmitted(simple, trig->localomit, (char const   *)(trig->omitfunc),
                       & omit);
      }
#line 396
      if (*err) {
#line 396
        return (-2);
      }
#line 397
      if (! omit) {
#line 398
        goto while_break___2;
      }
#line 400
      simple ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 402
    if (iter___2 > MaxSatIter) {
#line 403
      *err = 33;
#line 404
      return (-2);
    }
  }
#line 409
  return (simple);
}
}
#line 420 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/trigger.c"
int ComputeTrigger(int today , Trigger *trig , int *err , int save_in_globals ) 
{ 
  int nattempts ;
  int start ;
  int nextstart ;
  int y ;
  int m ;
  int d ;
  int omit ;
  int result ;
  int tmp ;

  {
#line 422
  nattempts = 0;
#line 422
  start = today;
#line 422
  nextstart = 0;
#line 428
  trig->expired = 0;
#line 429
  if (save_in_globals) {
#line 430
    LastTrigValid = 0;
  }
#line 434
  *err = 0;
#line 437
  if (trig->localomit == 127) {
#line 438
    *err = 37;
#line 439
    return (-1);
  }
#line 442
  if (trig->rep != 0) {
#line 442
    if (trig->d == -1) {
      {
#line 446
      Eprint("%s", ErrMsg[49]);
#line 447
      *err = 49;
      }
#line 448
      return (-1);
    } else
#line 442
    if (trig->m == -1) {
      {
#line 446
      Eprint("%s", ErrMsg[49]);
#line 447
      *err = 49;
      }
#line 448
      return (-1);
    } else
#line 442
    if (trig->y == -1) {
      {
#line 446
      Eprint("%s", ErrMsg[49]);
#line 447
      *err = 49;
      }
#line 448
      return (-1);
    }
  }
  {
#line 452
  while (1) {
    while_continue: /* CIL Label */ ;
#line 452
    tmp = nattempts;
#line 452
    nattempts ++;
#line 452
    if (! (tmp < 50)) {
#line 452
      goto while_break;
    }
    {
#line 453
    result = GetNextTriggerDate(trig, start, err, & nextstart);
    }
#line 456
    if (*err) {
#line 456
      return (-1);
    }
#line 457
    if (result == -1) {
#line 458
      trig->expired = 1;
#line 459
      if (DebugFlag & 4) {
        {
#line 460
        fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"%s(%d): %s\n",
                FileName, LineNo, ErrMsg[80]);
        }
      }
#line 463
      return (-1);
    }
#line 467
    if (trig->skip == 1) {
      {
#line 468
      *err = IsOmitted(result, trig->localomit, (char const   *)(trig->omitfunc),
                       & omit);
      }
#line 469
      if (*err) {
#line 469
        return (-1);
      }
    } else {
#line 471
      omit = 0;
    }
#line 473
    if (result >= today) {
#line 473
      if (trig->skip != 1) {
#line 473
        goto _L;
      } else
#line 473
      if (! omit) {
        _L: /* CIL Label */ 
#line 475
        if (save_in_globals) {
#line 476
          LastTriggerDate = result;
#line 477
          LastTrigValid = 1;
        }
#line 479
        if (DebugFlag & 4) {
          {
#line 480
          FromJulian(result, & y, & m, & d);
#line 481
          fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"%s(%d): Trig = %s, %d %s, %d\n",
                  FileName, LineNo, EnglishDayName[result % 7], d, EnglishMonthName[m],
                  y);
          }
        }
#line 488
        return (result);
      }
    }
#line 492
    if (trig->back == 0) {
#line 492
      if (trig->skip == 0) {
#line 492
        if (trig->rep == 0) {
#line 495
          trig->expired = 1;
#line 496
          if (DebugFlag & 4) {
            {
#line 497
            fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"%s(%d): %s\n",
                    FileName, LineNo, ErrMsg[80]);
            }
          }
#line 500
          if (result != -1) {
#line 501
            if (save_in_globals) {
#line 502
              LastTriggerDate = result;
#line 503
              LastTrigValid = 1;
            }
          }
#line 506
          return (-1);
        }
      }
    }
#line 509
    if (trig->skip == 1) {
#line 509
      if (omit) {
#line 509
        if (nextstart <= start) {
#line 509
          if (result >= start) {
#line 513
            nextstart = result + 1;
          }
        }
      }
    }
#line 517
    if (nextstart <= start) {
#line 518
      if (result != -1) {
#line 519
        if (save_in_globals) {
#line 520
          LastTriggerDate = result;
#line 521
          LastTrigValid = 1;
        }
      }
#line 524
      trig->expired = 1;
#line 525
      if (DebugFlag & 4) {
        {
#line 526
        fprintf((FILE */* __restrict  */)ErrFp, (char const   */* __restrict  */)"%s(%d): %s\n",
                FileName, LineNo, ErrMsg[80]);
        }
      }
#line 529
      return (-1);
    } else {
#line 531
      start = nextstart;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 536
  *err = 33;
#line 537
  return (-1);
}
}
#line 775 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) abs)(int __x )  __attribute__((__const__)) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/dorem.c"
static char const   DontEscapeMe[70]  = 
#line 29 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/dorem.c"
  {      (char const   )'1',      (char const   )'2',      (char const   )'3',      (char const   )'4', 
        (char const   )'5',      (char const   )'6',      (char const   )'7',      (char const   )'8', 
        (char const   )'9',      (char const   )'0',      (char const   )'_',      (char const   )'-', 
        (char const   )'=',      (char const   )'+',      (char const   )'a',      (char const   )'b', 
        (char const   )'c',      (char const   )'d',      (char const   )'e',      (char const   )'f', 
        (char const   )'g',      (char const   )'h',      (char const   )'i',      (char const   )'j', 
        (char const   )'k',      (char const   )'l',      (char const   )'m',      (char const   )'n', 
        (char const   )'o',      (char const   )'p',      (char const   )'q',      (char const   )'r', 
        (char const   )'s',      (char const   )'t',      (char const   )'u',      (char const   )'v', 
        (char const   )'w',      (char const   )'x',      (char const   )'y',      (char const   )'z', 
        (char const   )'A',      (char const   )'B',      (char const   )'C',      (char const   )'D', 
        (char const   )'E',      (char const   )'F',      (char const   )'G',      (char const   )'H', 
        (char const   )'I',      (char const   )'J',      (char const   )'K',      (char const   )'L', 
        (char const   )'M',      (char const   )'N',      (char const   )'O',      (char const   )'P', 
        (char const   )'Q',      (char const   )'R',      (char const   )'S',      (char const   )'T', 
        (char const   )'U',      (char const   )'V',      (char const   )'W',      (char const   )'X', 
        (char const   )'Y',      (char const   )'Z',      (char const   )'@',      (char const   )'.', 
        (char const   )',',      (char const   )'\000'};
#line 32
static int ParseTimeTrig(ParsePtr s , TimeTrig *tim , int save_in_globals ) ;
#line 33
static int ParseLocalOmit(ParsePtr s , Trigger *t ) ;
#line 34
static int ParseScanFrom(ParsePtr s , Trigger *t , int type ) ;
#line 35
static int ParsePriority(ParsePtr s , Trigger *t ) ;
#line 36
static int ParseUntil(ParsePtr s , Trigger *t ) ;
#line 37
static int ShouldTriggerBasedOnWarn(Trigger *t , int jul , int *err ) ;
#line 46 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/dorem.c"
int DoRem(ParsePtr p ) 
{ 
  Trigger trig ;
  TimeTrig tim ;
  int r ;
  int err ;
  int jul ;
  DynamicBuffer buf___1 ;
  Token tok ;
  int tmp ;

  {
  {
#line 56
  DBufInit(& buf___1);
#line 59
  r = ParseRem(p, & trig, & tim, 1);
  }
#line 59
  if (r) {
    {
#line 60
    FreeTrig(& trig);
    }
#line 61
    return (r);
  }
#line 64
  if (trig.typ == 0) {
    {
#line 65
    PurgeEchoLine("%s\n%s\n", "#!P! Cannot parse next line", CurLine);
#line 66
    FreeTrig(& trig);
    }
#line 67
    return (19);
  }
#line 69
  if (trig.typ == 4) {
    {
#line 70
    PurgeEchoLine("%s\n", "#!P: Cannot purge SATISFY-type reminders");
#line 71
    PurgeEchoLine("%s\n", CurLine);
#line 72
    r = DoSatRemind(& trig, & tim, p);
    }
#line 73
    if (r) {
      {
#line 74
      FreeTrig(& trig);
      }
#line 75
      if (r == 80) {
#line 75
        return (0);
      }
#line 76
      return (r);
    }
#line 78
    if (! LastTrigValid) {
      {
#line 79
      FreeTrig(& trig);
      }
#line 80
      return (0);
    }
    {
#line 82
    r = ParseToken(p, & buf___1);
    }
#line 83
    if (r) {
      {
#line 84
      FreeTrig(& trig);
      }
#line 85
      return (r);
    }
    {
#line 87
    FindToken((char const   *)buf___1.buffer, & tok);
#line 88
    DBufFree(& buf___1);
    }
#line 89
    if ((unsigned int )tok.type == 32U) {
      {
#line 90
      DBufFree(& buf___1);
#line 91
      FreeTrig(& trig);
      }
#line 92
      return (0);
    } else
#line 89
    if ((unsigned int )tok.type == 33U) {
      {
#line 90
      DBufFree(& buf___1);
#line 91
      FreeTrig(& trig);
      }
#line 92
      return (0);
    }
#line 94
    if ((unsigned int )tok.type != 24U) {
      {
#line 95
      DBufFree(& buf___1);
#line 96
      FreeTrig(& trig);
      }
#line 97
      return (32);
    } else
#line 94
    if (tok.val == 4) {
      {
#line 95
      DBufFree(& buf___1);
#line 96
      FreeTrig(& trig);
      }
#line 97
      return (32);
    }
#line 99
    if (tok.val == 8) {
      {
#line 100
      r = ParseToken(p, & buf___1);
      }
#line 101
      if (r) {
        {
#line 102
        FreeTrig(& trig);
        }
#line 103
        return (r);
      }
#line 105
      if (! buf___1.len) {
        {
#line 106
        FreeTrig(& trig);
#line 107
        DBufFree(& buf___1);
        }
#line 108
        return (19);
      }
      {
#line 110
      StrnCpy(trig.passthru, (char const   *)buf___1.buffer, 32);
#line 111
      DBufFree(& buf___1);
      }
    }
#line 113
    trig.typ = tok.val;
#line 114
    jul = LastTriggerDate;
#line 115
    if (! LastTrigValid) {
      {
#line 116
      FreeTrig(& trig);
      }
#line 117
      return (0);
    } else
#line 115
    if (PurgeMode) {
      {
#line 116
      FreeTrig(& trig);
      }
#line 117
      return (0);
    }
  } else {
    {
#line 121
    jul = ComputeTrigger(trig.scanfrom, & trig, & r, 1);
    }
#line 122
    if (r) {
#line 123
      if (PurgeMode) {
        {
#line 124
        PurgeEchoLine("%s: %s\n", "#!P! Problem calculating trigger date", ErrMsg[r]);
#line 125
        PurgeEchoLine("%s\n", CurLine);
        }
      }
      {
#line 127
      FreeTrig(& trig);
      }
#line 128
      return (r);
    }
  }
#line 132
  if (PurgeMode) {
#line 133
    if (trig.expired) {
#line 133
      goto _L;
    } else
#line 133
    if (jul < JulianToday) {
      _L: /* CIL Label */ 
#line 134
      if (p->expr_happened) {
#line 135
        if (p->nonconst_expr) {
          {
#line 136
          PurgeEchoLine("%s\n", "#!P: Next line may have expired, but contains non-constant expression");
#line 137
          PurgeEchoLine("%s\n", CurLine);
          }
        } else {
          {
#line 139
          PurgeEchoLine("%s\n", "#!P: Next line has expired, but contains expression...  please verify");
#line 140
          PurgeEchoLine("#!P: Expired: %s\n", CurLine);
          }
        }
      } else {
        {
#line 143
        PurgeEchoLine("#!P: Expired: %s\n", CurLine);
        }
      }
    } else {
      {
#line 146
      PurgeEchoLine("%s\n", CurLine);
      }
    }
    {
#line 148
    FreeTrig(& trig);
    }
#line 149
    return (0);
  }
#line 152
  if (jul == JulianToday) {
#line 152
    if (! IgnoreOnce) {
#line 152
      if (trig.once != 0) {
#line 152
        if (! (FileAccessDate == JulianToday)) {
          {
#line 156
          QueueReminder(p, & trig, & tim, (char const   *)(trig.sched));
          }
        }
      } else {
        {
#line 156
        QueueReminder(p, & trig, & tim, (char const   *)(trig.sched));
        }
      }
    } else {
      {
#line 156
      QueueReminder(p, & trig, & tim, (char const   *)(trig.sched));
      }
    }
  }
#line 158
  if (Daemon) {
    {
#line 159
    FreeTrig(& trig);
    }
#line 160
    return (0);
  }
  {
#line 163
  tmp = ShouldTriggerReminder(& trig, & tim, jul, & err);
  }
#line 163
  if (tmp) {
    {
#line 164
    r = TriggerReminder(p, & trig, & tim, jul);
    }
#line 164
    if (r) {
      {
#line 165
      FreeTrig(& trig);
      }
#line 166
      return (r);
    }
  }
  {
#line 170
  FreeTrig(& trig);
  }
#line 171
  return (0);
}
}
#line 182 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/dorem.c"
int ParseRem(ParsePtr s , Trigger *trig , TimeTrig *tim , int save_in_globals ) 
{ 
  register int r ;
  DynamicBuffer buf___1 ;
  Token tok ;
  int y ;
  int m ;
  int d ;

  {
  {
#line 189
  DBufInit(& buf___1);
#line 191
  trig->y = -1;
#line 192
  trig->m = -1;
#line 193
  trig->d = -1;
#line 194
  trig->wd = 0;
#line 195
  trig->back = 0;
#line 196
  trig->delta = 0;
#line 197
  trig->until = -1;
#line 198
  trig->rep = 0;
#line 199
  trig->localomit = 0;
#line 200
  trig->skip = 0;
#line 201
  trig->once = 0;
#line 202
  trig->typ = 0;
#line 203
  trig->scanfrom = -1;
#line 204
  trig->priority = DefaultPrio;
#line 205
  trig->sched[0] = (char)0;
#line 206
  trig->warn[0] = (char)0;
#line 207
  trig->omitfunc[0] = (char)0;
#line 208
  DBufInit(& trig->tags);
#line 209
  trig->passthru[0] = (char)0;
#line 210
  tim->ttime = 2147483647;
#line 211
  tim->delta = 0;
#line 212
  tim->rep = 0;
#line 213
  tim->duration = 2147483647;
  }
#line 214
  if (save_in_globals) {
#line 215
    LastTriggerTime = 2147483647;
  }
  {
#line 218
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 220
    r = ParseToken(s, & buf___1);
    }
#line 221
    if (r) {
#line 221
      return (r);
    }
    {
#line 224
    FindToken((char const   *)buf___1.buffer, & tok);
    }
    {
#line 226
    if ((unsigned int )tok.type == 20U) {
#line 226
      goto case_20;
    }
#line 237
    if ((unsigned int )tok.type == 21U) {
#line 237
      goto case_21;
    }
#line 252
    if ((unsigned int )tok.type == 17U) {
#line 252
      goto case_17;
    }
#line 258
    if ((unsigned int )tok.type == 18U) {
#line 258
      goto case_18;
    }
#line 264
    if ((unsigned int )tok.type == 22U) {
#line 264
      goto case_22;
    }
#line 270
    if ((unsigned int )tok.type == 40U) {
#line 270
      goto case_40;
    }
#line 276
    if ((unsigned int )tok.type == 23U) {
#line 276
      goto case_23;
    }
#line 282
    if ((unsigned int )tok.type == 38U) {
#line 282
      goto case_38;
    }
#line 288
    if ((unsigned int )tok.type == 24U) {
#line 288
      goto case_24;
    }
#line 304
    if ((unsigned int )tok.type == 47U) {
#line 304
      goto case_47;
    }
#line 312
    if ((unsigned int )tok.type == 25U) {
#line 312
      goto case_25;
    }
#line 318
    if ((unsigned int )tok.type == 26U) {
#line 318
      goto case_26;
    }
#line 324
    if ((unsigned int )tok.type == 27U) {
#line 324
      goto case_27;
    }
#line 330
    if ((unsigned int )tok.type == 28U) {
#line 330
      goto case_28;
    }
#line 336
    if ((unsigned int )tok.type == 29U) {
#line 336
      goto case_29;
    }
#line 342
    if ((unsigned int )tok.type == 30U) {
#line 342
      goto case_30;
    }
#line 348
    if ((unsigned int )tok.type == 31U) {
#line 348
      goto case_31;
    }
#line 354
    if ((unsigned int )tok.type == 14U) {
#line 354
      goto case_14;
    }
#line 364
    if ((unsigned int )tok.type == 32U) {
#line 364
      goto case_32;
    }
#line 369
    if ((unsigned int )tok.type == 46U) {
#line 369
      goto case_46;
    }
#line 379
    if ((unsigned int )tok.type == 42U) {
#line 379
      goto case_42;
    }
#line 386
    if ((unsigned int )tok.type == 43U) {
#line 386
      goto case_43;
    }
#line 392
    if ((unsigned int )tok.type == 44U) {
#line 392
      goto case_44;
    }
#line 407
    if ((unsigned int )tok.type == 41U) {
#line 407
      goto case_41;
    }
#line 414
    if ((unsigned int )tok.type == 45U) {
#line 414
      goto case_45___0;
    }
#line 419
    goto switch_default___0;
    case_20: /* CIL Label */ 
    {
#line 227
    DBufFree(& buf___1);
    }
#line 228
    if (trig->d != -1) {
#line 228
      return (52);
    }
#line 229
    if (trig->m != -1) {
#line 229
      return (51);
    }
#line 230
    if (trig->y != -1) {
#line 230
      return (50);
    }
    {
#line 231
    FromJulian(tok.val, & y, & m, & d);
#line 232
    trig->y = y;
#line 233
    trig->m = m;
#line 234
    trig->d = d;
    }
#line 235
    goto switch_break;
    case_21: /* CIL Label */ 
    {
#line 238
    DBufFree(& buf___1);
    }
#line 239
    if (trig->d != -1) {
#line 239
      return (52);
    }
#line 240
    if (trig->m != -1) {
#line 240
      return (51);
    }
#line 241
    if (trig->y != -1) {
#line 241
      return (50);
    }
    {
#line 242
    FromJulian(tok.val / 1440, & y, & m, & d);
#line 243
    trig->y = y;
#line 244
    trig->m = m;
#line 245
    trig->d = d;
#line 246
    tim->ttime = tok.val % 1440;
    }
#line 247
    if (save_in_globals) {
#line 248
      LastTriggerTime = tim->ttime;
    }
#line 250
    goto switch_break;
    case_17: /* CIL Label */ 
    {
#line 253
    DBufFree(& buf___1);
    }
#line 254
    if (trig->wd & (1 << tok.val)) {
#line 254
      return (64);
    }
#line 255
    trig->wd |= 1 << tok.val;
#line 256
    goto switch_break;
    case_18: /* CIL Label */ 
    {
#line 259
    DBufFree(& buf___1);
    }
#line 260
    if (trig->m != -1) {
#line 260
      return (51);
    }
#line 261
    trig->m = tok.val;
#line 262
    goto switch_break;
    case_22: /* CIL Label */ 
    {
#line 265
    DBufFree(& buf___1);
    }
#line 266
    if (trig->skip != 0) {
#line 266
      return (65);
    }
#line 267
    trig->skip = tok.val;
#line 268
    goto switch_break;
    case_40: /* CIL Label */ 
    {
#line 271
    DBufFree(& buf___1);
#line 272
    r = ParsePriority(s, trig);
    }
#line 273
    if (r) {
#line 273
      return (r);
    }
#line 274
    goto switch_break;
    case_23: /* CIL Label */ 
    {
#line 277
    DBufFree(& buf___1);
#line 278
    r = ParseTimeTrig(s, tim, save_in_globals);
    }
#line 279
    if (r) {
#line 279
      return (r);
    }
#line 280
    goto switch_break;
    case_38: /* CIL Label */ 
    {
#line 283
    DBufFree(& buf___1);
#line 284
    r = ParseScanFrom(s, trig, tok.val);
    }
#line 285
    if (r) {
#line 285
      return (r);
    }
#line 286
    goto switch_break;
    case_24: /* CIL Label */ 
    {
#line 289
    DBufFree(& buf___1);
#line 290
    trig->typ = tok.val;
    }
#line 291
    if (s->isnested) {
#line 291
      return (66);
    }
#line 292
    if (trig->scanfrom == -1) {
#line 292
      trig->scanfrom = JulianToday;
    }
#line 293
    if (trig->typ == 8) {
      {
#line 294
      r = ParseToken(s, & buf___1);
      }
#line 295
      if (r) {
#line 295
        return (r);
      }
#line 296
      if (! buf___1.len) {
        {
#line 297
        DBufFree(& buf___1);
        }
#line 298
        return (19);
      }
      {
#line 300
      StrnCpy(trig->passthru, (char const   *)buf___1.buffer, 32);
      }
    }
#line 302
    return (0);
    case_47: /* CIL Label */ 
    {
#line 305
    DBufFree(& buf___1);
    }
#line 306
    if (trig->rep != 0) {
#line 306
      return (67);
    }
    {
#line 307
    trig->rep = 1;
#line 308
    r = ParseUntil(s, trig);
    }
#line 309
    if (r) {
#line 309
      return (r);
    }
#line 310
    goto switch_break;
    case_25: /* CIL Label */ 
    {
#line 313
    DBufFree(& buf___1);
#line 314
    r = ParseUntil(s, trig);
    }
#line 315
    if (r) {
#line 315
      return (r);
    }
#line 316
    goto switch_break;
    case_26: /* CIL Label */ 
    {
#line 319
    DBufFree(& buf___1);
    }
#line 320
    if (trig->y != -1) {
#line 320
      return (50);
    }
#line 321
    trig->y = tok.val;
#line 322
    goto switch_break;
    case_27: /* CIL Label */ 
    {
#line 325
    DBufFree(& buf___1);
    }
#line 326
    if (trig->d != -1) {
#line 326
      return (52);
    }
#line 327
    trig->d = tok.val;
#line 328
    goto switch_break;
    case_28: /* CIL Label */ 
    {
#line 331
    DBufFree(& buf___1);
    }
#line 332
    if (trig->rep != 0) {
#line 332
      return (67);
    }
#line 333
    trig->rep = tok.val;
#line 334
    goto switch_break;
    case_29: /* CIL Label */ 
    {
#line 337
    DBufFree(& buf___1);
    }
#line 338
    if (trig->delta != 0) {
#line 338
      return (68);
    }
#line 339
    trig->delta = tok.val;
#line 340
    goto switch_break;
    case_30: /* CIL Label */ 
    {
#line 343
    DBufFree(& buf___1);
    }
#line 344
    if (trig->back != 0) {
#line 344
      return (69);
    }
#line 345
    trig->back = tok.val;
#line 346
    goto switch_break;
    case_31: /* CIL Label */ 
    {
#line 349
    DBufFree(& buf___1);
    }
#line 350
    if (trig->once != 0) {
#line 350
      return (70);
    }
#line 351
    trig->once = 1;
#line 352
    goto switch_break;
    case_14: /* CIL Label */ 
    {
#line 355
    DBufFree(& buf___1);
    }
#line 356
    if (trig->omitfunc[0]) {
      {
#line 357
      Eprint("Warning: OMIT is ignored if you use OMITFUNC");
      }
    }
    {
#line 360
    r = ParseLocalOmit(s, trig);
    }
#line 361
    if (r) {
#line 361
      return (r);
    }
#line 362
    goto switch_break;
    case_32: /* CIL Label */ 
    {
#line 365
    DBufFree(& buf___1);
    }
#line 366
    if (trig->scanfrom == -1) {
#line 366
      trig->scanfrom = JulianToday;
    }
#line 367
    return (0);
    case_46: /* CIL Label */ 
#line 370
    if (trig->localomit) {
      {
#line 371
      Eprint("Warning: OMIT is ignored if you use OMITFUNC");
      }
    }
    {
#line 373
    r = ParseToken(s, & buf___1);
    }
#line 374
    if (r) {
#line 374
      return (r);
    }
    {
#line 375
    StrnCpy(trig->omitfunc, (char const   *)buf___1.buffer, 16);
#line 376
    DBufFree(& buf___1);
    }
#line 377
    goto switch_break;
    case_42: /* CIL Label */ 
    {
#line 380
    r = ParseToken(s, & buf___1);
    }
#line 381
    if (r) {
#line 381
      return (r);
    }
    {
#line 382
    StrnCpy(trig->warn, (char const   *)buf___1.buffer, 16);
#line 383
    DBufFree(& buf___1);
    }
#line 384
    goto switch_break;
    case_43: /* CIL Label */ 
    {
#line 387
    r = ParseToken(s, & buf___1);
    }
#line 388
    if (r) {
#line 388
      return (r);
    }
    {
#line 389
    AppendTag(& trig->tags, (char const   *)buf___1.buffer);
    }
#line 390
    goto switch_break;
    case_44: /* CIL Label */ 
    {
#line 393
    r = ParseToken(s, & buf___1);
    }
#line 394
    if (r) {
#line 394
      return (r);
    }
    {
#line 395
    FindToken((char const   *)buf___1.buffer, & tok);
#line 396
    DBufFree(& buf___1);
    }
    {
#line 399
    if ((unsigned int )tok.type == 45U) {
#line 399
      goto case_45;
    }
#line 399
    if ((unsigned int )tok.type == 19U) {
#line 399
      goto case_45;
    }
#line 402
    goto switch_default;
    case_45: /* CIL Label */ 
    case_19: /* CIL Label */ 
#line 400
    tim->duration = tok.val;
#line 401
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 403
    return (27);
    switch_break___0: /* CIL Label */ ;
    }
#line 405
    goto switch_break;
    case_41: /* CIL Label */ 
    {
#line 408
    r = ParseToken(s, & buf___1);
    }
#line 409
    if (r) {
#line 409
      return (r);
    }
    {
#line 410
    StrnCpy(trig->sched, (char const   *)buf___1.buffer, 16);
#line 411
    DBufFree(& buf___1);
    }
#line 412
    goto switch_break;
    case_45___0: /* CIL Label */ 
    {
#line 415
    DBufFree(& buf___1);
    }
#line 416
    return (27);
#line 417
    goto switch_break;
    switch_default___0: /* CIL Label */ 
    {
#line 420
    PushToken((char const   *)buf___1.buffer, s);
#line 421
    DBufFree(& buf___1);
#line 422
    trig->typ = 1;
    }
#line 423
    if (s->isnested) {
#line 423
      return (66);
    }
#line 424
    if (trig->scanfrom == -1) {
#line 424
      trig->scanfrom = JulianToday;
    }
#line 425
    return (0);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 435 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/dorem.c"
static int ParseTimeTrig(ParsePtr s , TimeTrig *tim , int save_in_globals ) 
{ 
  Token tok ;
  int r ;
  DynamicBuffer buf___1 ;

  {
  {
#line 441
  DBufInit(& buf___1);
  }
  {
#line 443
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 444
    r = ParseToken(s, & buf___1);
    }
#line 445
    if (r) {
#line 445
      return (r);
    }
    {
#line 446
    FindToken((char const   *)buf___1.buffer, & tok);
    }
    {
#line 448
    if ((unsigned int )tok.type == 19U) {
#line 448
      goto case_19;
    }
#line 453
    if ((unsigned int )tok.type == 29U) {
#line 453
      goto case_29;
    }
#line 458
    if ((unsigned int )tok.type == 28U) {
#line 458
      goto case_28;
    }
#line 463
    goto switch_default;
    case_19: /* CIL Label */ 
    {
#line 449
    DBufFree(& buf___1);
#line 450
    tim->ttime = tok.val;
    }
#line 451
    goto switch_break;
    case_29: /* CIL Label */ 
    {
#line 454
    DBufFree(& buf___1);
    }
#line 455
    if (tok.val > 0) {
#line 455
      tim->delta = tok.val;
    } else {
#line 455
      tim->delta = - tok.val;
    }
#line 456
    goto switch_break;
    case_28: /* CIL Label */ 
    {
#line 459
    DBufFree(& buf___1);
#line 460
    tim->rep = tok.val;
    }
#line 461
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 464
    if (tim->ttime == 2147483647) {
#line 464
      return (71);
    }
#line 467
    if (save_in_globals) {
#line 468
      LastTriggerTime = tim->ttime;
    }
    {
#line 470
    PushToken((char const   *)buf___1.buffer, s);
#line 471
    DBufFree(& buf___1);
    }
#line 472
    return (0);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 483 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/dorem.c"
static int ParseLocalOmit(ParsePtr s , Trigger *t ) 
{ 
  Token tok ;
  int r ;
  DynamicBuffer buf___1 ;

  {
  {
#line 488
  DBufInit(& buf___1);
  }
  {
#line 490
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 491
    r = ParseToken(s, & buf___1);
    }
#line 492
    if (r) {
#line 492
      return (r);
    }
    {
#line 493
    FindToken((char const   *)buf___1.buffer, & tok);
    }
    {
#line 495
    if ((unsigned int )tok.type == 17U) {
#line 495
      goto case_17;
    }
#line 500
    goto switch_default;
    case_17: /* CIL Label */ 
    {
#line 496
    DBufFree(& buf___1);
#line 497
    t->localomit |= 1 << tok.val;
    }
#line 498
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 501
    PushToken((char const   *)buf___1.buffer, s);
#line 502
    DBufFree(& buf___1);
    }
#line 503
    return (0);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 513 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/dorem.c"
static int ParseUntil(ParsePtr s , Trigger *t ) 
{ 
  int y ;
  int m ;
  int d ;
  Token tok ;
  int r ;
  DynamicBuffer buf___1 ;
  int tmp ;

  {
  {
#line 515
  y = -1;
#line 515
  m = -1;
#line 515
  d = -1;
#line 522
  DBufInit(& buf___1);
  }
#line 524
  if (t->until != -1) {
#line 524
    return (72);
  }
  {
#line 526
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 527
    r = ParseToken(s, & buf___1);
    }
#line 528
    if (r) {
#line 528
      return (r);
    }
    {
#line 529
    FindToken((char const   *)buf___1.buffer, & tok);
    }
    {
#line 531
    if ((unsigned int )tok.type == 26U) {
#line 531
      goto case_26;
    }
#line 540
    if ((unsigned int )tok.type == 18U) {
#line 540
      goto case_18;
    }
#line 549
    if ((unsigned int )tok.type == 27U) {
#line 549
      goto case_27;
    }
#line 558
    if ((unsigned int )tok.type == 20U) {
#line 558
      goto case_20;
    }
#line 575
    goto switch_default;
    case_26: /* CIL Label */ 
    {
#line 532
    DBufFree(& buf___1);
    }
#line 533
    if (y != -1) {
      {
#line 534
      Eprint("UNTIL: %s", ErrMsg[50]);
      }
#line 535
      return (50);
    }
#line 537
    y = tok.val;
#line 538
    goto switch_break;
    case_18: /* CIL Label */ 
    {
#line 541
    DBufFree(& buf___1);
    }
#line 542
    if (m != -1) {
      {
#line 543
      Eprint("UNTIL: %s", ErrMsg[51]);
      }
#line 544
      return (51);
    }
#line 546
    m = tok.val;
#line 547
    goto switch_break;
    case_27: /* CIL Label */ 
    {
#line 550
    DBufFree(& buf___1);
    }
#line 551
    if (d != -1) {
      {
#line 552
      Eprint("UNTIL: %s", ErrMsg[52]);
      }
#line 553
      return (52);
    }
#line 555
    d = tok.val;
#line 556
    goto switch_break;
    case_20: /* CIL Label */ 
    {
#line 559
    DBufFree(& buf___1);
    }
#line 560
    if (y != -1) {
      {
#line 561
      Eprint("UNTIL: %s", ErrMsg[50]);
      }
#line 562
      return (50);
    }
#line 564
    if (m != -1) {
      {
#line 565
      Eprint("UNTIL: %s", ErrMsg[51]);
      }
#line 566
      return (51);
    }
#line 568
    if (d != -1) {
      {
#line 569
      Eprint("UNTIL: %s", ErrMsg[52]);
      }
#line 570
      return (52);
    }
    {
#line 572
    FromJulian(tok.val, & y, & m, & d);
    }
#line 573
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 576
    if (y == -1) {
      {
#line 577
      Eprint("UNTIL: %s", ErrMsg[73]);
#line 578
      DBufFree(& buf___1);
      }
#line 579
      return (73);
    } else
#line 576
    if (m == -1) {
      {
#line 577
      Eprint("UNTIL: %s", ErrMsg[73]);
#line 578
      DBufFree(& buf___1);
      }
#line 579
      return (73);
    } else
#line 576
    if (d == -1) {
      {
#line 577
      Eprint("UNTIL: %s", ErrMsg[73]);
#line 578
      DBufFree(& buf___1);
      }
#line 579
      return (73);
    }
    {
#line 581
    tmp = DateOK(y, m, d);
    }
#line 581
    if (! tmp) {
      {
#line 582
      DBufFree(& buf___1);
      }
#line 583
      return (24);
    }
    {
#line 585
    t->until = Julian(y, m, d);
#line 586
    PushToken((char const   *)buf___1.buffer, s);
#line 587
    DBufFree(& buf___1);
    }
#line 588
    return (0);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 598 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/dorem.c"
static int ParseScanFrom(ParsePtr s , Trigger *t , int type ) 
{ 
  int y ;
  int m ;
  int d ;
  Token tok ;
  int r ;
  DynamicBuffer buf___1 ;
  char const   *word ;
  int tmp ;

  {
  {
#line 600
  y = -1;
#line 600
  m = -1;
#line 600
  d = -1;
#line 609
  DBufInit(& buf___1);
  }
#line 610
  if (type == 0) {
#line 611
    word = "SCANFROM";
  } else {
#line 613
    word = "FROM";
  }
#line 616
  if (t->scanfrom != -1) {
#line 616
    return (74);
  }
  {
#line 618
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 619
    r = ParseToken(s, & buf___1);
    }
#line 620
    if (r) {
#line 620
      return (r);
    }
    {
#line 621
    FindToken((char const   *)buf___1.buffer, & tok);
    }
    {
#line 623
    if ((unsigned int )tok.type == 26U) {
#line 623
      goto case_26;
    }
#line 632
    if ((unsigned int )tok.type == 18U) {
#line 632
      goto case_18;
    }
#line 641
    if ((unsigned int )tok.type == 27U) {
#line 641
      goto case_27;
    }
#line 650
    if ((unsigned int )tok.type == 20U) {
#line 650
      goto case_20;
    }
#line 667
    goto switch_default;
    case_26: /* CIL Label */ 
    {
#line 624
    DBufFree(& buf___1);
    }
#line 625
    if (y != -1) {
      {
#line 626
      Eprint("%s: %s", word, ErrMsg[50]);
      }
#line 627
      return (50);
    }
#line 629
    y = tok.val;
#line 630
    goto switch_break;
    case_18: /* CIL Label */ 
    {
#line 633
    DBufFree(& buf___1);
    }
#line 634
    if (m != -1) {
      {
#line 635
      Eprint("%s: %s", word, ErrMsg[51]);
      }
#line 636
      return (51);
    }
#line 638
    m = tok.val;
#line 639
    goto switch_break;
    case_27: /* CIL Label */ 
    {
#line 642
    DBufFree(& buf___1);
    }
#line 643
    if (d != -1) {
      {
#line 644
      Eprint("%s: %s", word, ErrMsg[52]);
      }
#line 645
      return (52);
    }
#line 647
    d = tok.val;
#line 648
    goto switch_break;
    case_20: /* CIL Label */ 
    {
#line 651
    DBufFree(& buf___1);
    }
#line 652
    if (y != -1) {
      {
#line 653
      Eprint("%s: %s", word, ErrMsg[50]);
      }
#line 654
      return (50);
    }
#line 656
    if (m != -1) {
      {
#line 657
      Eprint("%s: %s", word, ErrMsg[51]);
      }
#line 658
      return (51);
    }
#line 660
    if (d != -1) {
      {
#line 661
      Eprint("%s: %s", word, ErrMsg[52]);
      }
#line 662
      return (52);
    }
    {
#line 664
    FromJulian(tok.val, & y, & m, & d);
    }
#line 665
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 668
    if (y == -1) {
      {
#line 669
      Eprint("%s: %s", word, ErrMsg[73]);
#line 670
      DBufFree(& buf___1);
      }
#line 671
      return (73);
    } else
#line 668
    if (m == -1) {
      {
#line 669
      Eprint("%s: %s", word, ErrMsg[73]);
#line 670
      DBufFree(& buf___1);
      }
#line 671
      return (73);
    } else
#line 668
    if (d == -1) {
      {
#line 669
      Eprint("%s: %s", word, ErrMsg[73]);
#line 670
      DBufFree(& buf___1);
      }
#line 671
      return (73);
    }
    {
#line 673
    tmp = DateOK(y, m, d);
    }
#line 673
    if (! tmp) {
      {
#line 674
      DBufFree(& buf___1);
      }
#line 675
      return (24);
    }
    {
#line 677
    t->scanfrom = Julian(y, m, d);
    }
#line 678
    if (type == 1) {
#line 679
      if (t->scanfrom < JulianToday) {
#line 680
        t->scanfrom = JulianToday;
      }
    }
    {
#line 684
    PushToken((char const   *)buf___1.buffer, s);
#line 685
    DBufFree(& buf___1);
    }
#line 686
    return (0);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 697 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/dorem.c"
int TriggerReminder(ParsePtr p , Trigger *t , TimeTrig *tim , int jul ) 
{ 
  int r ;
  int y ;
  int m ;
  int d ;
  char PrioExpr[41] ;
  char tmpBuf[64] ;
  DynamicBuffer buf___1 ;
  DynamicBuffer calRow ;
  DynamicBuffer pre_buf ;
  char const   *s ;
  Value v ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char const   *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;

  {
  {
#line 707
  DBufInit(& buf___1);
#line 708
  DBufInit(& calRow);
#line 709
  DBufInit(& pre_buf);
  }
#line 710
  if (t->typ == 2) {
#line 710
    if (RunDisabled) {
#line 710
      return (40);
    }
  }
#line 711
  if (t->typ == 8) {
    {
#line 711
    tmp = strcmp((char const   *)(t->passthru), "COLOR");
    }
#line 711
    if (tmp) {
      {
#line 711
      tmp___0 = strcmp((char const   *)(t->passthru), "COLOUR");
      }
#line 711
      if (tmp___0) {
#line 715
        return (0);
      } else {
#line 711
        goto _L___0;
      }
    } else {
#line 711
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 711
  if (t->typ == 3) {
#line 715
    return (0);
  } else
#line 711
  if (t->typ == 5) {
#line 715
    return (0);
  } else
#line 711
  if (t->typ == 6) {
#line 715
    return (0);
  }
#line 718
  if (t->typ == 8) {
    {
#line 718
    tmp___4 = strcmp((char const   *)(t->passthru), "COLOR");
    }
#line 718
    if (tmp___4) {
      {
#line 718
      tmp___5 = strcmp((char const   *)(t->passthru), "COLOUR");
      }
#line 718
      if (! tmp___5) {
        _L___1: /* CIL Label */ 
        {
#line 720
        r = ParseToken(p, & buf___1);
        }
#line 721
        if (! NextMode) {
          {
#line 722
          DBufPuts(& pre_buf, (char const   *)buf___1.buffer);
          }
#line 723
          if (pre_buf.allocatedLen < pre_buf.len + 1) {
#line 723
            tmp___1 = pre_buf.len;
#line 723
            (pre_buf.len) ++;
#line 723
            *(pre_buf.buffer + tmp___1) = (char )' ';
#line 723
            *(pre_buf.buffer + pre_buf.len) = (char)0;
          } else {
            {
#line 723
            DBufPutcFN(& pre_buf, (char )' ');
            }
          }
        }
        {
#line 725
        DBufFree(& buf___1);
        }
#line 726
        if (r) {
#line 726
          return (r);
        }
        {
#line 727
        r = ParseToken(p, & buf___1);
        }
#line 728
        if (! NextMode) {
          {
#line 729
          DBufPuts(& pre_buf, (char const   *)buf___1.buffer);
          }
#line 730
          if (pre_buf.allocatedLen < pre_buf.len + 1) {
#line 730
            tmp___2 = pre_buf.len;
#line 730
            (pre_buf.len) ++;
#line 730
            *(pre_buf.buffer + tmp___2) = (char )' ';
#line 730
            *(pre_buf.buffer + pre_buf.len) = (char)0;
          } else {
            {
#line 730
            DBufPutcFN(& pre_buf, (char )' ');
            }
          }
        }
        {
#line 732
        DBufFree(& buf___1);
        }
#line 733
        if (r) {
#line 733
          return (r);
        }
        {
#line 734
        r = ParseToken(p, & buf___1);
        }
#line 735
        if (! NextMode) {
          {
#line 736
          DBufPuts(& pre_buf, (char const   *)buf___1.buffer);
          }
#line 737
          if (pre_buf.allocatedLen < pre_buf.len + 1) {
#line 737
            tmp___3 = pre_buf.len;
#line 737
            (pre_buf.len) ++;
#line 737
            *(pre_buf.buffer + tmp___3) = (char )' ';
#line 737
            *(pre_buf.buffer + pre_buf.len) = (char)0;
          } else {
            {
#line 737
            DBufPutcFN(& pre_buf, (char )' ');
            }
          }
        }
        {
#line 739
        DBufFree(& buf___1);
        }
#line 740
        if (r) {
#line 740
          return (r);
        }
#line 741
        t->typ = 1;
      }
    } else {
#line 718
      goto _L___1;
    }
  }
#line 744
  if (t->typ == 1) {
#line 744
    goto _L___2;
  } else
#line 744
  if (t->typ == 7) {
    _L___2: /* CIL Label */ 
#line 744
    if (! NumTriggered) {
#line 744
      if (! NextMode) {
#line 744
        if (! MsgCommand) {
          {
#line 746
          tmp___6 = DoSubstFromString((char const   *)Banner.buffer, & buf___1, JulianToday,
                                      2147483647);
          }
#line 746
          if (! tmp___6) {
#line 746
            if (buf___1.len) {
              {
#line 749
              printf((char const   */* __restrict  */)"%s\n", buf___1.buffer);
              }
            }
          }
          {
#line 751
          DBufFree(& buf___1);
          }
        }
      }
    }
  }
#line 756
  if (NextMode) {
    {
#line 757
    r = DoSubst(p, & buf___1, t, tim, jul, 1);
    }
#line 757
    if (r) {
#line 757
      return (r);
    }
#line 758
    if (! buf___1.len) {
      {
#line 759
      DBufFree(& buf___1);
#line 760
      DBufFree(& pre_buf);
      }
#line 761
      return (0);
    }
    {
#line 763
    FromJulian(jul, & y, & m, & d);
#line 764
    sprintf((char */* __restrict  */)(tmpBuf), (char const   */* __restrict  */)"%04d/%02d/%02d ",
            y, m + 1, d);
#line 765
    tmp___7 = DBufPuts(& calRow, (char const   *)(tmpBuf));
    }
#line 765
    if (tmp___7 != 0) {
      {
#line 766
      DBufFree(& calRow);
#line 767
      DBufFree(& pre_buf);
      }
#line 768
      return (9);
    }
#line 771
    if (DoSimpleCalendar) {
      {
#line 773
      tmp___8 = DBufPuts(& calRow, "* ");
      }
#line 773
      if (tmp___8 != 0) {
        {
#line 774
        DBufFree(& calRow);
#line 775
        DBufFree(& pre_buf);
        }
#line 776
        return (9);
      }
#line 778
      if (*(t->tags.buffer)) {
        {
#line 779
        DBufPuts(& calRow, (char const   *)t->tags.buffer);
        }
#line 780
        if (calRow.allocatedLen < calRow.len + 1) {
#line 780
          tmp___9 = calRow.len;
#line 780
          (calRow.len) ++;
#line 780
          *(calRow.buffer + tmp___9) = (char )' ';
#line 780
          *(calRow.buffer + calRow.len) = (char)0;
        } else {
          {
#line 780
          DBufPutcFN(& calRow, (char )' ');
          }
        }
      } else {
        {
#line 782
        DBufPuts(& calRow, "* ");
        }
      }
#line 784
      if (tim->duration != 2147483647) {
        {
#line 785
        sprintf((char */* __restrict  */)(tmpBuf), (char const   */* __restrict  */)"%d ",
                tim->duration);
        }
      } else {
        {
#line 787
        sprintf((char */* __restrict  */)(tmpBuf), (char const   */* __restrict  */)"* ");
        }
      }
      {
#line 789
      tmp___10 = DBufPuts(& calRow, (char const   *)(tmpBuf));
      }
#line 789
      if (tmp___10 != 0) {
        {
#line 790
        DBufFree(& calRow);
#line 791
        DBufFree(& pre_buf);
        }
#line 792
        return (9);
      }
#line 794
      if (tim->ttime != 2147483647) {
        {
#line 795
        sprintf((char */* __restrict  */)(tmpBuf), (char const   */* __restrict  */)"%d ",
                tim->ttime);
        }
      } else {
        {
#line 797
        sprintf((char */* __restrict  */)(tmpBuf), (char const   */* __restrict  */)"* ");
        }
      }
      {
#line 799
      tmp___11 = DBufPuts(& calRow, (char const   *)(tmpBuf));
      }
#line 799
      if (tmp___11 != 0) {
        {
#line 800
        DBufFree(& calRow);
#line 801
        DBufFree(& pre_buf);
        }
#line 802
        return (9);
      }
    }
    {
#line 805
    tmp___12 = SimpleTime(tim->ttime);
#line 805
    tmp___13 = DBufPuts(& calRow, tmp___12);
    }
#line 805
    if (tmp___13 != 0) {
      {
#line 806
      DBufFree(& calRow);
#line 807
      DBufFree(& pre_buf);
      }
#line 808
      return (9);
    }
    {
#line 811
    printf((char const   */* __restrict  */)"%s%s%s\n", calRow.buffer, pre_buf.buffer,
           buf___1.buffer);
#line 812
    DBufFree(& buf___1);
#line 813
    DBufFree(& pre_buf);
#line 814
    DBufFree(& calRow);
    }
#line 815
    return (0);
  }
#line 821
  if (t->typ != 2) {
    {
#line 822
    tmp___16 = UserFuncExists("msgprefix");
    }
#line 822
    if (tmp___16 == 1) {
      {
#line 823
      sprintf((char */* __restrict  */)(PrioExpr), (char const   */* __restrict  */)"msgprefix(%d)",
              t->priority);
#line 824
      s = (char const   *)(PrioExpr);
#line 825
      r = EvalExpr(& s, & v, (ParsePtr )((void *)0));
      }
#line 826
      if (! r) {
        {
#line 827
        tmp___15 = DoCoerce((char)4, & v);
        }
#line 827
        if (! tmp___15) {
          {
#line 828
          tmp___14 = DBufPuts(& buf___1, (char const   *)v.v.str);
          }
#line 828
          if (tmp___14 != 0) {
            {
#line 829
            DBufFree(& buf___1);
            }
#line 830
            if ((int )v.type == 4) {
#line 830
              if (v.v.str) {
                {
#line 830
                free((void *)v.v.str);
#line 830
                v.type = (char)0;
                }
              }
            }
#line 831
            return (9);
          }
        }
#line 834
        if ((int )v.type == 4) {
#line 834
          if (v.v.str) {
            {
#line 834
            free((void *)v.v.str);
#line 834
            v.type = (char)0;
            }
          }
        }
      }
    }
  }
  {
#line 839
  r = DoSubst(p, & buf___1, t, tim, jul, 0);
  }
#line 839
  if (r) {
#line 839
    return (r);
  }
#line 840
  if (t->typ != 2) {
    {
#line 841
    tmp___19 = UserFuncExists("msgsuffix");
    }
#line 841
    if (tmp___19 == 1) {
      {
#line 842
      sprintf((char */* __restrict  */)(PrioExpr), (char const   */* __restrict  */)"msgsuffix(%d)",
              t->priority);
#line 843
      s = (char const   *)(PrioExpr);
#line 844
      r = EvalExpr(& s, & v, (ParsePtr )((void *)0));
      }
#line 845
      if (! r) {
        {
#line 846
        tmp___18 = DoCoerce((char)4, & v);
        }
#line 846
        if (! tmp___18) {
          {
#line 847
          tmp___17 = DBufPuts(& buf___1, (char const   *)v.v.str);
          }
#line 847
          if (tmp___17 != 0) {
            {
#line 848
            DBufFree(& buf___1);
            }
#line 849
            if ((int )v.type == 4) {
#line 849
              if (v.v.str) {
                {
#line 849
                free((void *)v.v.str);
#line 849
                v.type = (char)0;
                }
              }
            }
#line 850
            return (9);
          }
        }
#line 853
        if ((int )v.type == 4) {
#line 853
          if (v.v.str) {
            {
#line 853
            free((void *)v.v.str);
#line 853
            v.type = (char)0;
            }
          }
        }
      }
    }
  }
#line 858
  if (! MsgCommand) {
#line 858
    if (t->typ == 1) {
#line 858
      goto _L___3;
    } else {
#line 858
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
#line 858
  if (t->typ == 7) {
    _L___3: /* CIL Label */ 
#line 859
    if (buf___1.allocatedLen < buf___1.len + 1) {
#line 859
      tmp___20 = buf___1.len;
#line 859
      (buf___1.len) ++;
#line 859
      *(buf___1.buffer + tmp___20) = (char )'\n';
#line 859
      *(buf___1.buffer + buf___1.len) = (char)0;
#line 859
      tmp___22 = 0;
    } else {
      {
#line 859
      tmp___21 = DBufPutcFN(& buf___1, (char )'\n');
#line 859
      tmp___22 = tmp___21 != 0;
      }
    }
#line 859
    if (tmp___22) {
      {
#line 860
      DBufFree(& buf___1);
      }
#line 861
      return (9);
    }
  }
#line 866
  if (SortByDate) {
    {
#line 867
    tmp___23 = InsertIntoSortBuffer(jul, tim->ttime, (char const   *)buf___1.buffer,
                                    t->typ, t->priority);
    }
#line 867
    if (tmp___23 == 0) {
      {
#line 869
      DBufFree(& buf___1);
#line 870
      NumTriggered ++;
      }
#line 871
      return (0);
    }
  }
  {
#line 879
  if (t->typ == 8) {
#line 879
    goto case_8;
  }
#line 879
  if (t->typ == 1) {
#line 879
    goto case_8;
  }
#line 887
  if (t->typ == 7) {
#line 887
    goto case_7;
  }
#line 891
  if (t->typ == 2) {
#line 891
    goto case_2;
  }
#line 895
  goto switch_default;
  case_8: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 880
  if (MsgCommand) {
    {
#line 881
    DoMsgCommand(MsgCommand, (char const   *)buf___1.buffer);
    }
  } else {
    {
#line 883
    printf((char const   */* __restrict  */)"%s", buf___1.buffer);
    }
  }
#line 885
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 888
  FillParagraph((char const   *)buf___1.buffer);
  }
#line 889
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 892
  system((char const   *)buf___1.buffer);
  }
#line 893
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 896
  DBufFree(& buf___1);
  }
#line 897
  return (23);
  switch_break: /* CIL Label */ ;
  }
  {
#line 900
  DBufFree(& buf___1);
#line 901
  NumTriggered ++;
  }
#line 902
  return (0);
}
}
#line 914 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/dorem.c"
int ShouldTriggerReminder(Trigger *t , TimeTrig *tim , int jul , int *err ) 
{ 
  int r ;
  int omit ;
  long tmp ;
  int tmp___0 ;
  int iter ;
  int max ;
  int tmp___1 ;

  {
#line 917
  *err = 0;
#line 920
  if (! IgnoreOnce) {
#line 920
    if (t->once != 0) {
#line 920
      if (FileAccessDate == JulianToday) {
#line 921
        return (0);
      }
    }
  }
#line 923
  if (jul < JulianToday) {
#line 923
    return (0);
  }
#line 927
  if (jul == JulianToday) {
#line 927
    if (DontIssueAts) {
#line 927
      if (tim->ttime != 2147483647) {
#line 928
        if (DontIssueAts > 1) {
          {
#line 931
          tmp = SystemTime(0);
          }
#line 931
          if ((long )tim->ttime < tmp / 60L) {
#line 932
            return (0);
          }
        } else {
#line 935
          return (0);
        }
      }
    }
  }
#line 947
  if (InfiniteDelta) {
#line 947
    return (1);
  } else
#line 947
  if (NextMode) {
#line 947
    return (1);
  }
#line 950
  if ((int )t->warn[0] != 0) {
#line 951
    if (DeltaOffset) {
#line 952
      if (jul <= JulianToday + DeltaOffset) {
#line 953
        return (1);
      }
    }
    {
#line 956
    tmp___0 = ShouldTriggerBasedOnWarn(t, jul, err);
    }
#line 956
    return (tmp___0);
  }
#line 960
  if (t->delta != 0) {
#line 961
    if (t->delta < 0) {
#line 962
      jul += t->delta;
    } else {
#line 964
      iter = 0;
#line 965
      max = MaxSatIter;
#line 966
      r = t->delta;
#line 967
      if (max < r * 2) {
#line 967
        max = r * 2;
      }
      {
#line 968
      while (1) {
        while_continue: /* CIL Label */ ;
#line 968
        tmp___1 = iter;
#line 968
        iter ++;
#line 968
        if (! (tmp___1 < max)) {
#line 968
          goto while_break;
        }
#line 969
        if (! r) {
#line 970
          goto while_break;
        } else
#line 969
        if (jul <= JulianToday) {
#line 970
          goto while_break;
        }
        {
#line 972
        jul --;
#line 973
        *err = IsOmitted(jul, t->localomit, (char const   *)(t->omitfunc), & omit);
        }
#line 974
        if (*err) {
#line 974
          return (0);
        }
#line 975
        if (! omit) {
#line 975
          r --;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 977
      if (iter > max) {
        {
#line 978
        *err = 33;
#line 979
        Eprint("Delta: Bad OMITFUNC? %s", ErrMsg[33]);
        }
#line 980
        return (0);
      }
    }
  }
#line 986
  return (jul <= JulianToday + DeltaOffset);
}
}
#line 996 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/dorem.c"
int DoSatRemind(Trigger *trig , TimeTrig *tim , ParsePtr p ) 
{ 
  int iter ;
  int jul ;
  int r ;
  Value v ;
  char const   *s ;
  char const   *t ;
  int tmp ;

  {
#line 1003
  t = p->pos;
#line 1004
  iter = 0;
#line 1005
  jul = trig->scanfrom;
  {
#line 1006
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1006
    tmp = iter;
#line 1006
    iter ++;
#line 1006
    if (! (tmp < MaxSatIter)) {
#line 1006
      goto while_break;
    }
    {
#line 1007
    jul = ComputeTrigger(jul, trig, & r, 1);
    }
#line 1008
    if (r) {
#line 1009
      if (r == 33) {
#line 1009
        return (0);
      } else {
#line 1009
        return (r);
      }
    }
#line 1011
    if (jul == -1) {
#line 1012
      return (80);
    }
    {
#line 1014
    s = p->pos;
#line 1015
    r = EvaluateExpr(p, & v);
#line 1016
    t = p->pos;
    }
#line 1017
    if (r) {
#line 1017
      return (r);
    }
#line 1018
    if ((int )v.type != 1) {
#line 1018
      if ((int )v.type != 4) {
#line 1018
        return (14);
      }
    }
#line 1019
    if ((int )v.type == 1) {
#line 1019
      if (v.v.val) {
#line 1019
        return (0);
      }
    }
#line 1020
    if ((int )v.type == 4) {
#line 1020
      if (*(v.v.str)) {
#line 1020
        return (0);
      }
    }
#line 1021
    p->pos = s;
#line 1022
    jul ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1024
  p->pos = t;
#line 1025
  LastTrigValid = 0;
#line 1026
  return (0);
}
}
#line 1034 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/dorem.c"
static int ParsePriority(ParsePtr s , Trigger *t ) 
{ 
  int p ;
  int r ;
  char const   *u ;
  DynamicBuffer buf___1 ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 1039
  DBufInit(& buf___1);
#line 1041
  r = ParseToken(s, & buf___1);
  }
#line 1042
  if (r) {
#line 1042
    return (r);
  }
  {
#line 1043
  u = (char const   *)buf___1.buffer;
#line 1045
  tmp = __ctype_b_loc();
  }
#line 1045
  if (! ((int const   )*(*tmp + (int )*u) & 2048)) {
    {
#line 1046
    DBufFree(& buf___1);
    }
#line 1047
    return (97);
  }
#line 1049
  p = 0;
  {
#line 1050
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1050
    tmp___0 = __ctype_b_loc();
    }
#line 1050
    if (! ((int const   )*(*tmp___0 + (int )*u) & 2048)) {
#line 1050
      goto while_break;
    }
#line 1051
    p = (p * 10 + (int )*u) - 48;
#line 1052
    u ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1054
  if (*u) {
    {
#line 1055
    DBufFree(& buf___1);
    }
#line 1056
    return (97);
  }
  {
#line 1059
  DBufFree(& buf___1);
  }
#line 1063
  if (p < 0) {
#line 1063
    return (28);
  } else
#line 1063
  if (p > 9999) {
#line 1063
    return (28);
  }
#line 1064
  t->priority = p;
#line 1065
  return (0);
}
}
#line 1075 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/dorem.c"
int DoMsgCommand(char const   *cmd , char const   *msg ) 
{ 
  int r ;
  int i ;
  int l ;
  DynamicBuffer execBuffer ;
  DynamicBuffer buf___1 ;
  char const   *s ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
  {
#line 1084
  DBufInit(& buf___1);
#line 1085
  DBufInit(& execBuffer);
#line 1088
  s = msg;
  }
  {
#line 1088
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1088
    if (! *s) {
#line 1088
      goto while_break;
    }
    {
#line 1089
    tmp___2 = __ctype_b_loc();
    }
#line 1089
    if ((int const   )*(*tmp___2 + (int )*s) & 8192) {
#line 1089
      goto _L;
    } else {
      {
#line 1089
      tmp___3 = strchr(DontEscapeMe, (int )*s);
      }
#line 1089
      if (! tmp___3) {
        _L: /* CIL Label */ 
#line 1090
        if (buf___1.allocatedLen < buf___1.len + 1) {
#line 1090
          tmp = buf___1.len;
#line 1090
          (buf___1.len) ++;
#line 1090
          *(buf___1.buffer + tmp) = (char )'\\';
#line 1090
          *(buf___1.buffer + buf___1.len) = (char)0;
#line 1090
          tmp___1 = 0;
        } else {
          {
#line 1090
          tmp___0 = DBufPutcFN(& buf___1, (char )'\\');
#line 1090
          tmp___1 = tmp___0 != 0;
          }
        }
#line 1090
        if (tmp___1) {
#line 1091
          r = 9;
#line 1092
          goto finished;
        }
      }
    }
#line 1095
    if (buf___1.allocatedLen < buf___1.len + 1) {
#line 1095
      tmp___4 = buf___1.len;
#line 1095
      (buf___1.len) ++;
#line 1095
      *(buf___1.buffer + tmp___4) = (char )*s;
#line 1095
      *(buf___1.buffer + buf___1.len) = (char)0;
#line 1095
      tmp___6 = 0;
    } else {
      {
#line 1095
      tmp___5 = DBufPutcFN(& buf___1, (char )*s);
#line 1095
      tmp___6 = tmp___5 != 0;
      }
    }
#line 1095
    if (tmp___6) {
#line 1096
      r = 9;
#line 1097
      goto finished;
    }
#line 1088
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1100
  msg = (char const   *)buf___1.buffer;
#line 1103
  tmp___7 = strlen(cmd);
#line 1103
  l = (int )tmp___7;
#line 1104
  i = 0;
  }
  {
#line 1104
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1104
    if (! (i < l)) {
#line 1104
      goto while_break___0;
    }
#line 1105
    if ((int const   )*(cmd + i) == 37) {
#line 1105
      if ((int const   )*(cmd + (i + 1)) == 115) {
        {
#line 1106
        i ++;
#line 1107
        tmp___8 = DBufPuts(& execBuffer, msg);
        }
#line 1107
        if (tmp___8 != 0) {
#line 1108
          r = 9;
#line 1109
          goto finished;
        }
      } else {
#line 1105
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 1112
      if (execBuffer.allocatedLen < execBuffer.len + 1) {
#line 1112
        tmp___9 = execBuffer.len;
#line 1112
        (execBuffer.len) ++;
#line 1112
        *(execBuffer.buffer + tmp___9) = (char )*(cmd + i);
#line 1112
        *(execBuffer.buffer + execBuffer.len) = (char)0;
#line 1112
        tmp___11 = 0;
      } else {
        {
#line 1112
        tmp___10 = DBufPutcFN(& execBuffer, (char )*(cmd + i));
#line 1112
        tmp___11 = tmp___10 != 0;
        }
      }
#line 1112
      if (tmp___11) {
#line 1113
        r = 9;
#line 1114
        goto finished;
      }
    }
#line 1104
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1118
  r = 0;
#line 1120
  system((char const   *)execBuffer.buffer);
  }
  finished: 
  {
#line 1123
  DBufFree(& buf___1);
#line 1124
  DBufFree(& execBuffer);
  }
#line 1125
  return (r);
}
}
#line 1136 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/dorem.c"
static int ShouldTriggerBasedOnWarn(Trigger *t , int jul , int *err ) 
{ 
  char buffer[48] ;
  int i ;
  char const   *s ;
  int r ;
  int omit ;
  Value v ;
  int lastReturnVal ;
  int tmp ;
  int tmp___0 ;
  int j ;
  int iter ;
  int max ;
  int tmp___1 ;

  {
  {
#line 1143
  lastReturnVal = 0;
#line 1146
  tmp = UserFuncExists((char const   *)(t->warn));
  }
#line 1146
  if (tmp != 1) {
    {
#line 1147
    Eprint("%s: `%s\'", ErrMsg[98], t->warn);
    }
#line 1148
    return (jul == JulianToday);
  }
#line 1150
  i = 1;
  {
#line 1150
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1151
    sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"%s(%d)",
            t->warn, i);
#line 1152
    s = (char const   *)(buffer);
#line 1153
    r = EvalExpr(& s, & v, (ParsePtr )((void *)0));
    }
#line 1154
    if (r) {
      {
#line 1155
      Eprint("%s: `%s\': %s", ErrMsg[98], t->warn, ErrMsg[r]);
      }
#line 1157
      return (jul == JulianToday);
    }
#line 1159
    if ((int )v.type != 1) {
#line 1160
      if ((int )v.type == 4) {
#line 1160
        if (v.v.str) {
          {
#line 1160
          free((void *)v.v.str);
#line 1160
          v.type = (char)0;
          }
        }
      }
      {
#line 1161
      Eprint("%s: `%s\': %s", ErrMsg[98], t->warn, ErrMsg[14]);
      }
#line 1163
      return (jul == JulianToday);
    }
#line 1168
    if (i > 1) {
      {
#line 1168
      tmp___0 = abs(v.v.val);
      }
#line 1168
      if (tmp___0 >= lastReturnVal) {
#line 1169
        return (jul == JulianToday);
      }
    }
    {
#line 1172
    lastReturnVal = abs(v.v.val);
    }
#line 1175
    if (v.v.val >= 0) {
#line 1176
      if (JulianToday + v.v.val == jul) {
#line 1176
        return (1);
      }
    } else {
#line 1178
      j = jul;
#line 1179
      iter = 0;
#line 1180
      max = MaxSatIter;
#line 1181
      if (max < v.v.val * 2) {
#line 1181
        max = v.v.val * 2;
      }
      {
#line 1182
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1182
        tmp___1 = iter;
#line 1182
        iter ++;
#line 1182
        if (! (tmp___1 <= max)) {
#line 1182
          goto while_break___0;
        }
        {
#line 1183
        j --;
#line 1184
        *err = IsOmitted(j, t->localomit, (char const   *)(t->omitfunc), & omit);
        }
#line 1185
        if (*err) {
#line 1185
          return (0);
        }
#line 1186
        if (! omit) {
#line 1186
          (v.v.val) ++;
        }
#line 1187
        if (! v.v.val) {
#line 1188
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1191
      if (iter > max) {
        {
#line 1192
        Eprint("Delta: Bad OMITFUNC? %s", ErrMsg[33]);
        }
#line 1193
        return (0);
      }
#line 1195
      if (j == JulianToday) {
#line 1195
        return (1);
      }
    }
#line 1150
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/protos.h"
void FindNumericToken(char const   *s , Token *t ) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/token.c"
Token TokArray[62]  = 
#line 39 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/token.c"
  {      {(char *)"after", (char)3, (enum TokTypes )22, 3}, 
        {(char *)"april", (char)3, (enum TokTypes )18, 3}, 
        {(char *)"at", (char)2, (enum TokTypes )23, 0}, 
        {(char *)"august", (char)3, (enum TokTypes )18, 7}, 
        {(char *)"banner", (char)3, (enum TokTypes )15, 0}, 
        {(char *)"before", (char)3, (enum TokTypes )22, 2}, 
        {(char *)"cal", (char)3, (enum TokTypes )24, 3}, 
        {(char *)"clear-omit-context", (char)5, (enum TokTypes )35, 0}, 
        {(char *)"debug", (char)5, (enum TokTypes )36, 0}, 
        {(char *)"december", (char)3, (enum TokTypes )18, 11}, 
        {(char *)"dumpvars", (char)4, (enum TokTypes )37, 0}, 
        {(char *)"duration", (char)3, (enum TokTypes )44, 0}, 
        {(char *)"else", (char)4, (enum TokTypes )7, 0}, 
        {(char *)"endif", (char)5, (enum TokTypes )8, 0}, 
        {(char *)"errmsg", (char)6, (enum TokTypes )10, 0}, 
        {(char *)"exit", (char)4, (enum TokTypes )16, 0}, 
        {(char *)"february", (char)3, (enum TokTypes )18, 1}, 
        {(char *)"flush", (char)5, (enum TokTypes )39, 0}, 
        {(char *)"friday", (char)3, (enum TokTypes )17, 4}, 
        {(char *)"from", (char)4, (enum TokTypes )38, 1}, 
        {(char *)"fset", (char)4, (enum TokTypes )13, 0}, 
        {(char *)"if", (char)2, (enum TokTypes )6, 0}, 
        {(char *)"iftrig", (char)6, (enum TokTypes )9, 0}, 
        {(char *)"include", (char)3, (enum TokTypes )5, 0}, 
        {(char *)"january", (char)3, (enum TokTypes )18, 0}, 
        {(char *)"july", (char)3, (enum TokTypes )18, 6}, 
        {(char *)"june", (char)3, (enum TokTypes )18, 5}, 
        {(char *)"march", (char)3, (enum TokTypes )18, 2}, 
        {(char *)"may", (char)3, (enum TokTypes )18, 4}, 
        {(char *)"monday", (char)3, (enum TokTypes )17, 0}, 
        {(char *)"msf", (char)3, (enum TokTypes )24, 7}, 
        {(char *)"msg", (char)3, (enum TokTypes )24, 1}, 
        {(char *)"november", (char)3, (enum TokTypes )18, 10}, 
        {(char *)"october", (char)3, (enum TokTypes )18, 9}, 
        {(char *)"omit", (char)3, (enum TokTypes )14, 0}, 
        {(char *)"omitfunc", (char)8, (enum TokTypes )46, 0}, 
        {(char *)"once", (char)3, (enum TokTypes )31, 0}, 
        {(char *)"pop-omit-context", (char)3, (enum TokTypes )3, 0}, 
        {(char *)"preserve", (char)8, (enum TokTypes )4, 0}, 
        {(char *)"priority", (char)8, (enum TokTypes )40, 0}, 
        {(char *)"ps", (char)2, (enum TokTypes )24, 5}, 
        {(char *)"psfile", (char)6, (enum TokTypes )24, 6}, 
        {(char *)"push-omit-context", (char)4, (enum TokTypes )2, 0}, 
        {(char *)"rem", (char)3, (enum TokTypes )1, 0}, 
        {(char *)"run", (char)3, (enum TokTypes )24, 2}, 
        {(char *)"satisfy", (char)7, (enum TokTypes )24, 4}, 
        {(char *)"saturday", (char)3, (enum TokTypes )17, 5}, 
        {(char *)"scanfrom", (char)4, (enum TokTypes )38, 0}, 
        {(char *)"sched", (char)5, (enum TokTypes )41, 0}, 
        {(char *)"september", (char)3, (enum TokTypes )18, 8}, 
        {(char *)"set", (char)3, (enum TokTypes )11, 0}, 
        {(char *)"skip", (char)3, (enum TokTypes )22, 1}, 
        {(char *)"special", (char)7, (enum TokTypes )24, 8}, 
        {(char *)"sunday", (char)3, (enum TokTypes )17, 6}, 
        {(char *)"tag", (char)3, (enum TokTypes )43, 0}, 
        {(char *)"through", (char)7, (enum TokTypes )47, 0}, 
        {(char *)"thursday", (char)3, (enum TokTypes )17, 3}, 
        {(char *)"tuesday", (char)3, (enum TokTypes )17, 1}, 
        {(char *)"unset", (char)5, (enum TokTypes )12, 0}, 
        {(char *)"until", (char)3, (enum TokTypes )25, 0}, 
        {(char *)"warn", (char)4, (enum TokTypes )42, 0}, 
        {(char *)"wednesday", (char)3, (enum TokTypes )17, 2}};
#line 133
static int TokStrCmp(Token const   *t , char const   *s ) ;
#line 143 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/token.c"
char const   *FindInitialToken(Token *tok , char const   *s ) 
{ 
  DynamicBuffer buf___1 ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned short const   **tmp___5 ;

  {
  {
#line 146
  DBufInit(& buf___1);
#line 148
  tok->type = (enum TokTypes )0;
  }
  {
#line 150
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 150
    tmp = __ctype_b_loc();
    }
#line 150
    if (! ((int const   )*(*tmp + (int )*s) & 8192)) {
#line 150
      if (! ((int const   )*s == 92)) {
#line 150
        goto while_break;
      }
    }
#line 150
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 152
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 152
    if (*s) {
      {
#line 152
      tmp___5 = __ctype_b_loc();
      }
#line 152
      if ((int const   )*(*tmp___5 + (int )*s) & 8192) {
#line 152
        goto while_break___0;
      } else
#line 152
      if ((int const   )*s == 92) {
#line 152
        goto while_break___0;
      }
    } else {
#line 152
      goto while_break___0;
    }
#line 153
    if (buf___1.allocatedLen < buf___1.len + 1) {
#line 153
      tmp___0 = buf___1.len;
#line 153
      (buf___1.len) ++;
#line 153
      tmp___1 = s;
#line 153
      s ++;
#line 153
      *(buf___1.buffer + tmp___0) = (char )*tmp___1;
#line 153
      *(buf___1.buffer + buf___1.len) = (char)0;
#line 153
      tmp___4 = 0;
    } else {
      {
#line 153
      tmp___2 = s;
#line 153
      s ++;
#line 153
      tmp___3 = DBufPutcFN(& buf___1, (char )*tmp___2);
#line 153
      tmp___4 = tmp___3 != 0;
      }
    }
#line 153
    if (tmp___4) {
#line 153
      return (s);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 156
  FindToken((char const   *)buf___1.buffer, tok);
#line 157
  DBufFree(& buf___1);
  }
#line 159
  return (s);
}
}
#line 170 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/token.c"
void FindToken(char const   *s , Token *tok ) 
{ 
  int top ;
  int bot ;
  int mid ;
  int r ;
  int max ;
  int l ;
  unsigned short const   **tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 175
  tok->type = (enum TokTypes )0;
#line 176
  if (! *s) {
#line 177
    tok->type = (enum TokTypes )32;
#line 178
    return;
  }
#line 181
  if ((int const   )*s == 35) {
#line 182
    tok->type = (enum TokTypes )33;
#line 183
    return;
  } else
#line 181
  if ((int const   )*s == 59) {
#line 182
    tok->type = (enum TokTypes )33;
#line 183
    return;
  }
  {
#line 187
  tmp = __ctype_b_loc();
  }
#line 187
  if (! ((int const   )*(*tmp + (int )*s) & 1024)) {
    {
#line 188
    FindNumericToken(s, tok);
    }
#line 189
    return;
  }
  {
#line 192
  tmp___0 = strlen(s);
#line 192
  l = (int )tmp___0;
  }
#line 195
  if (l > 0) {
#line 195
    if ((int const   )*(s + (l - 1)) == 44) {
#line 196
      l --;
    }
  }
#line 198
  bot = 0;
#line 199
  top = (int )(sizeof(TokArray) / sizeof(TokArray[0]) - 1UL);
#line 200
  max = (int )(sizeof(TokArray) / sizeof(TokArray[0]));
  {
#line 202
  while (1) {
    while_continue: /* CIL Label */ ;
#line 202
    if (! (top >= bot)) {
#line 202
      goto while_break;
    }
    {
#line 203
    mid = (top + bot) / 2;
#line 204
    r = TokStrCmp((Token const   *)(& TokArray[mid]), s);
    }
#line 205
    if (! r) {
#line 206
      if (l >= (int )TokArray[mid].MinLen) {
#line 207
        tok->type = TokArray[mid].type;
#line 208
        tok->val = TokArray[mid].val;
#line 209
        return;
      } else {
        {
#line 211
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 211
          if (mid) {
            {
#line 211
            tmp___1 = TokStrCmp((Token const   *)(& TokArray[mid - 1]), s);
            }
#line 211
            if (tmp___1) {
#line 211
              goto while_break___0;
            }
          } else {
#line 211
            goto while_break___0;
          }
#line 211
          mid --;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 212
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 212
          if (mid < max) {
            {
#line 212
            tmp___2 = TokStrCmp((Token const   *)(& TokArray[mid]), s);
            }
#line 212
            if (tmp___2) {
#line 212
              goto while_break___1;
            } else
#line 212
            if (! (l < (int )TokArray[mid].MinLen)) {
#line 212
              goto while_break___1;
            }
          } else {
#line 212
            goto while_break___1;
          }
#line 215
          mid ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 217
        if (mid < max) {
          {
#line 217
          tmp___3 = TokStrCmp((Token const   *)(& TokArray[mid]), s);
          }
#line 217
          if (! tmp___3) {
#line 219
            tok->type = TokArray[mid].type;
#line 220
            tok->val = TokArray[mid].val;
#line 221
            return;
          }
        }
      }
#line 224
      goto while_break;
    }
#line 226
    if (r > 0) {
#line 226
      top = mid - 1;
    } else {
#line 226
      bot = mid + 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 242
  return;
}
}
#line 257 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/token.c"
void FindNumericToken(char const   *s , Token *t ) 
{ 
  int mult ;
  int hour ;
  int min ;
  char const   *s_orig ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  char const   *p ;
  int jul ;
  int tim ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  unsigned short const   **tmp___7 ;
  unsigned short const   **tmp___8 ;
  unsigned short const   **tmp___9 ;
  unsigned short const   **tmp___10 ;

  {
  {
#line 259
  mult = 1;
#line 260
  s_orig = s;
#line 262
  t->type = (enum TokTypes )0;
#line 263
  t->val = 0;
#line 264
  tmp___10 = __ctype_b_loc();
  }
#line 264
  if ((int const   )*(*tmp___10 + (int )*s) & 2048) {
    {
#line 265
    tmp = __ctype_b_loc();
    }
#line 265
    if (! ((int const   )*(*tmp + (int )*s) & 2048)) {
#line 265
      return;
    }
#line 265
    t->val = 0;
    {
#line 265
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 265
      tmp___0 = __ctype_b_loc();
      }
#line 265
      if (! ((int const   )*(*tmp___0 + (int )*s) & 2048)) {
#line 265
        goto while_break;
      }
#line 265
      t->val *= 10;
#line 265
      t->val += (int )((int const   )*s - 48);
#line 265
      s ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 268
    if ((int const   )*s == 45) {
#line 268
      goto _L;
    } else
#line 268
    if ((int const   )*s == 47) {
      _L: /* CIL Label */ 
      {
#line 269
      p = s_orig;
#line 271
      tmp___1 = ParseLiteralDate(& p, & jul, & tim);
      }
#line 271
      if (tmp___1 == 0) {
#line 272
        if (*p) {
#line 272
          return;
        }
#line 273
        if (tim == 2147483647) {
#line 274
          t->type = (enum TokTypes )20;
#line 275
          t->val = jul;
#line 276
          return;
        }
#line 278
        t->type = (enum TokTypes )21;
#line 279
        t->val = 1440 * jul + tim;
      }
#line 281
      return;
    }
#line 286
    if ((int const   )*s == 44) {
#line 287
      s ++;
#line 290
      if (t->val >= 90) {
#line 290
        if (t->val <= 99) {
#line 290
          t->val += 1900;
        }
      }
#line 293
      if (t->val >= 1990) {
#line 293
        if (t->val <= 5990) {
#line 293
          t->type = (enum TokTypes )26;
        } else {
#line 293
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 294
      if (t->val >= 1) {
#line 294
        if (t->val <= 31) {
#line 294
          t->type = (enum TokTypes )27;
        } else {
#line 295
          t->type = (enum TokTypes )34;
        }
      } else {
#line 295
        t->type = (enum TokTypes )34;
      }
#line 296
      return;
    }
#line 299
    if ((int const   )*s == 58) {
#line 299
      goto _L___1;
    } else
#line 299
    if ((int const   )*s == 46) {
#line 299
      goto _L___1;
    } else
#line 299
    if ((int const   )*s == (int const   )TimeSep) {
      _L___1: /* CIL Label */ 
      {
#line 300
      s ++;
#line 301
      hour = t->val;
#line 302
      tmp___2 = __ctype_b_loc();
      }
#line 302
      if (! ((int const   )*(*tmp___2 + (int )*s) & 2048)) {
#line 302
        return;
      }
#line 302
      min = 0;
      {
#line 302
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 302
        tmp___3 = __ctype_b_loc();
        }
#line 302
        if (! ((int const   )*(*tmp___3 + (int )*s) & 2048)) {
#line 302
          goto while_break___0;
        }
#line 302
        min *= 10;
#line 302
        min += (int )((int const   )*s - 48);
#line 302
        s ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 303
      if (*s) {
#line 303
        return;
      } else
#line 303
      if (min > 59) {
#line 303
        return;
      }
#line 304
      t->val = hour * 60 + min;
#line 305
      if (hour <= 23) {
#line 306
        t->type = (enum TokTypes )19;
      } else {
#line 308
        t->type = (enum TokTypes )45;
      }
#line 310
      return;
    }
#line 314
    if (*s) {
#line 314
      return;
    }
#line 317
    if (t->val >= 90) {
#line 317
      if (t->val <= 99) {
#line 317
        t->val += 1900;
      }
    }
#line 320
    if (t->val >= 1990) {
#line 320
      if (t->val <= 5990) {
#line 320
        t->type = (enum TokTypes )26;
      } else {
#line 320
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 321
    if (t->val >= 1) {
#line 321
      if (t->val <= 31) {
#line 321
        t->type = (enum TokTypes )27;
      } else {
#line 322
        t->type = (enum TokTypes )34;
      }
    } else {
#line 322
      t->type = (enum TokTypes )34;
    }
#line 323
    return;
  } else
#line 324
  if ((int const   )*s == 42) {
    {
#line 325
    s ++;
#line 326
    tmp___4 = __ctype_b_loc();
    }
#line 326
    if (! ((int const   )*(*tmp___4 + (int )*s) & 2048)) {
#line 326
      return;
    }
#line 326
    t->val = 0;
    {
#line 326
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 326
      tmp___5 = __ctype_b_loc();
      }
#line 326
      if (! ((int const   )*(*tmp___5 + (int )*s) & 2048)) {
#line 326
        goto while_break___1;
      }
#line 326
      t->val *= 10;
#line 326
      t->val += (int )((int const   )*s - 48);
#line 326
      s ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 327
    if (*s) {
#line 327
      return;
    }
#line 328
    t->type = (enum TokTypes )28;
#line 329
    return;
  } else
#line 330
  if ((int const   )*s == 43) {
#line 331
    s ++;
#line 332
    if ((int const   )*s == 43) {
#line 332
      mult = -1;
#line 332
      s ++;
    }
    {
#line 333
    tmp___6 = __ctype_b_loc();
    }
#line 333
    if (! ((int const   )*(*tmp___6 + (int )*s) & 2048)) {
#line 333
      return;
    }
#line 333
    t->val = 0;
    {
#line 333
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 333
      tmp___7 = __ctype_b_loc();
      }
#line 333
      if (! ((int const   )*(*tmp___7 + (int )*s) & 2048)) {
#line 333
        goto while_break___2;
      }
#line 333
      t->val *= 10;
#line 333
      t->val += (int )((int const   )*s - 48);
#line 333
      s ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 334
    if (*s) {
#line 334
      return;
    }
#line 335
    t->type = (enum TokTypes )29;
#line 336
    t->val *= mult;
#line 337
    return;
  } else
#line 338
  if ((int const   )*s == 45) {
#line 339
    s ++;
#line 340
    if ((int const   )*s == 45) {
#line 340
      mult = -1;
#line 340
      s ++;
    }
    {
#line 341
    tmp___8 = __ctype_b_loc();
    }
#line 341
    if (! ((int const   )*(*tmp___8 + (int )*s) & 2048)) {
#line 341
      return;
    }
#line 341
    t->val = 0;
    {
#line 341
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 341
      tmp___9 = __ctype_b_loc();
      }
#line 341
      if (! ((int const   )*(*tmp___9 + (int )*s) & 2048)) {
#line 341
        goto while_break___3;
      }
#line 341
      t->val *= 10;
#line 341
      t->val += (int )((int const   )*s - 48);
#line 341
      s ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 342
    if (*s) {
#line 342
      return;
    }
#line 343
    t->type = (enum TokTypes )30;
#line 344
    t->val *= mult;
#line 345
    return;
  }
#line 347
  return;
}
}
#line 358 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/token.c"
static int TokStrCmp(Token const   *t , char const   *s ) 
{ 
  register int r ;
  char const   *tk ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 361
  tk = (char const   *)t->name;
  {
#line 362
  while (1) {
    while_continue: /* CIL Label */ ;
#line 362
    if (*tk) {
#line 362
      if (*s) {
#line 362
        if ((int const   )*s == 44) {
#line 362
          if ((int const   )*(s + 1) == 0) {
#line 362
            goto while_break;
          }
        }
      } else {
#line 362
        goto while_break;
      }
    } else {
#line 362
      goto while_break;
    }
    {
#line 363
    tmp = tolower((int )*tk);
#line 363
    tmp___0 = tolower((int )*s);
#line 363
    r = tmp - tmp___0;
#line 364
    tk ++;
#line 365
    s ++;
    }
#line 366
    if (r) {
#line 366
      return (r);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 370
  if (! *s) {
#line 370
    return (0);
  } else
#line 370
  if ((int const   )*s == 44) {
#line 370
    if (! *(s + 1)) {
#line 370
      return (0);
    }
  }
  {
#line 371
  tmp___1 = tolower((int )*tk);
#line 371
  tmp___2 = tolower((int )*s);
  }
#line 371
  return (tmp___1 - tmp___2);
}
}
#line 695 "/usr/include/stdio.h"
extern int puts(char const   *__s ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/rem2ps.h"
char *PSProlog1[71]  = 
#line 13 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/rem2ps.h"
  {      (char *)"% This file was produced by Remind and Rem2PS, written by",      (char *)"% David F. Skoll.",      (char *)"% Remind and Rem2PS are Copyright 1992-1997 David F. Skoll.",      (char *)"/ISOLatin1Encoding where { pop save true }{ false } ifelse", 
        (char *)"  /ISOLatin1Encoding [ StandardEncoding 0 45 getinterval aload pop /minus",      (char *)"    StandardEncoding 46 98 getinterval aload pop /dotlessi /grave /acute",      (char *)"    /circumflex /tilde /macron /breve /dotaccent /dieresis /.notdef /ring",      (char *)"    /cedilla /.notdef /hungarumlaut /ogonek /caron /space /exclamdown /cent", 
        (char *)"    /sterling /currency /yen /brokenbar /section /dieresis /copyright",      (char *)"    /ordfeminine /guillemotleft /logicalnot /hyphen /registered /macron",      (char *)"    /degree /plusminus /twosuperior /threesuperior /acute /mu /paragraph",      (char *)"    /periodcentered /cedilla /onesuperior /ordmasculine /guillemotright", 
        (char *)"    /onequarter /onehalf /threequarters /questiondown /Agrave /Aacute",      (char *)"    /Acircumflex /Atilde /Adieresis /Aring /AE /Ccedilla /Egrave /Eacute",      (char *)"    /Ecircumflex /Edieresis /Igrave /Iacute /Icircumflex /Idieresis /Eth",      (char *)"    /Ntilde /Ograve /Oacute /Ocircumflex /Otilde /Odieresis /multiply", 
        (char *)"    /Oslash /Ugrave /Uacute /Ucircumflex /Udieresis /Yacute /Thorn",      (char *)"    /germandbls /agrave /aacute /acircumflex /atilde /adieresis /aring /ae",      (char *)"    /ccedilla /egrave /eacute /ecircumflex /edieresis /igrave /iacute",      (char *)"    /icircumflex /idieresis /eth /ntilde /ograve /oacute /ocircumflex", 
        (char *)"    /otilde /odieresis /divide /oslash /ugrave /uacute /ucircumflex",      (char *)"    /udieresis /yacute /thorn /ydieresis ] def",      (char *)"{ restore } if",      (char *)"", 
        (char *)"/reencodeISO { %def",      (char *)"    findfont dup length dict begin",      (char *)"    { 1 index /FID ne { def }{ pop pop } ifelse } forall",      (char *)"    /Encoding ISOLatin1Encoding def", 
        (char *)"    currentdict end definefont pop",      (char *)"} bind def",      (char *)"/copyFont { %def",      (char *)"    findfont dup length dict begin", 
        (char *)"    { 1 index /FID ne { def } { pop pop } ifelse } forall",      (char *)"    currentdict end definefont pop",      (char *)"} bind def",      (char *)"", 
        (char *)"% L - Draw a line",      (char *)"/L {",      (char *)"   newpath moveto lineto stroke",      (char *)"} bind def", 
        (char *)"% string1 string2 strcat string",      (char *)"% Function: Concatenates two strings together.",      (char *)"/strcat {",      (char *)"         2 copy length exch length add", 
        (char *)"         string dup",      (char *)"         4 2 roll",      (char *)"         2 index 0 3 index",      (char *)"         putinterval", 
        (char *)"         exch length exch putinterval",      (char *)"} bind def",      (char *)"% string doheading",      (char *)"/doheading", 
        (char *)"{",      (char *)"   /monthyr exch def",      (char *)"",      (char *)"   /TitleFont findfont", 
        (char *)"   TitleSize scalefont setfont",      (char *)"   monthyr stringwidth",      (char *)"   /hgt exch def",      (char *)"   2 div MaxX MinX add 2 div exch sub /x exch def", 
        (char *)"   MaxY Border sub TitleSize sub /y exch def",      (char *)"   newpath x y moveto monthyr show",      (char *)"   newpath x y moveto monthyr false charpath flattenpath pathbbox",      (char *)"   pop pop Border sub /y exch def pop", 
        (char *)"   MinX y MaxX y L",      (char *)"   /topy y def",      (char *)"   /HeadFont findfont HeadSize scalefont setfont",      (char *)"% Do the days of the week", 
        (char *)"   MaxX MinX sub 7 div /xincr exch def",      (char *)"   /x MinX def",      (char *)((void *)0)};
#line 87 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/rem2ps.h"
char *PSProlog2[137]  = 
#line 87
  {      (char *)"  {",      (char *)"     HeadSize x y HeadSize 2 mul sub x xincr add y CenterText",      (char *)"     x xincr add /x exch def",      (char *)"  } forall", 
        (char *)"  y HeadSize 2 mul sub /y exch def",      (char *)"  MinX y MaxX y L",      (char *)"  /ytop y def /ymin y def",      (char *)"}", 
        (char *)"def",      (char *)"/CenterText",      (char *)"{",      (char *)"   /maxy exch def", 
        (char *)"   /maxx exch def",      (char *)"   /miny exch def",      (char *)"   /minx exch def",      (char *)"   /sz exch def", 
        (char *)"   /str exch def",      (char *)"   str stringwidth pop",      (char *)"   2 div maxx minx add 2 div exch sub",      (char *)"   sz 2 div maxy miny add 2 div exch sub", 
        (char *)"   moveto str show",      (char *)"} def",      (char *)"% Variables:",      (char *)"% curline - a string holding the current line", 
        (char *)"% y - current y pos",      (char *)"% yincr - increment to next line",      (char *)"% xleft - left margin",      (char *)"% width - max width.", 
        (char *)"% EnterOneWord - given a word, enter it into the box.",      (char *)"% string EnterOneWord",      (char *)"/EnterOneWord {",      (char *)"   { EnterOneWordAux", 
        (char *)"     {exit} if }",      (char *)"   loop",      (char *)"} bind def",      (char *)"% EnterOneWordAux - if the word fits, enter it into box and return true.", 
        (char *)"% If it doesn\'t fit, put as much as will fit and return the string and false.",      (char *)"/EnterOneWordAux {",      (char *)"   /word exch def",      (char *)"   /tmpline curline word strcat def", 
        (char *)"   tmpline stringwidth pop width gt",      (char *)"   {MoveToNewLine}",      (char *)"   {/curline tmpline ( ) strcat def /word () def}",      (char *)"   ifelse", 
        (char *)"   word () eq",      (char *)"   {true}",      (char *)"   {word false}",      (char *)"   ifelse", 
        (char *)"} bind def",      (char *)"% MoveToNewLine - move to a new line, resetting word as appropriate",      (char *)"/MoveToNewLine {",      (char *)"   curline () ne", 
        (char *)"   {newpath xleft y moveto curline show /curline () def /y y yincr add def}   ",      (char *)"   {ChopWord}",      (char *)"   ifelse",      (char *)"} bind def", 
        (char *)"% ChopWord - word won\'t fit.  Chop it and find biggest piece that will fit",      (char *)"/ChopWord {",      (char *)"   /curline () def",      (char *)"   /len word length def", 
        (char *)"   /Fcount len 1 sub def",      (char *)"",      (char *)"   {",      (char *)"     word 0 Fcount getinterval stringwidth pop width le", 
        (char *)"     {exit} if",      (char *)"     /Fcount Fcount 1 sub def",      (char *)"   } loop",      (char *)"% Got the count.  Display it and reset word", 
        (char *)"   newpath xleft y moveto word 0 Fcount getinterval show",      (char *)"   /y y yincr add def",      (char *)"   /word word Fcount len Fcount sub getinterval def",      (char *)"} bind def", 
        (char *)"/FinishFormatting {",      (char *)"   word () ne",      (char *)"   {newpath xleft y moveto word show /word () def",      (char *)"    /curline () def /y y yincr add def}", 
        (char *)"   {curline () ne",      (char *)"     {newpath xleft y moveto curline show /word () def",      (char *)"      /curline () def /y y yincr add def} if}",      (char *)"   ifelse", 
        (char *)"} bind def",      (char *)"% FillBoxWithText - fill a box with text",      (char *)"% text-array xleft width yincr y FillBoxWithText new-y",      (char *)"% Returns the new Y-coordinate.", 
        (char *)"/FillBoxWithText {",      (char *)"   /y exch def",      (char *)"   /yincr exch def",      (char *)"   /width exch def", 
        (char *)"   /xleft exch def",      (char *)"   /curline () def",      (char *)"   % The last two strings in the word array are actually the PostScript",      (char *)"   % code to execute before and after the entry is printed.", 
        (char *)"   dup dup",      (char *)"   length 1 sub",      (char *)"   get",      (char *)"   exch", 
        (char *)"   dup dup",      (char *)"   length 2 sub",      (char *)"   get",      (char *)"   dup length 0 gt", 
        (char *)"   {cvx exec} {pop} ifelse",      (char *)"   dup length 2 sub 0 exch getinterval",      (char *)"   {EnterOneWord} forall",      (char *)"   FinishFormatting", 
        (char *)"   dup length 0 gt",      (char *)"   {cvx exec} {pop} ifelse",      (char *)"   y",      (char *)"} bind def", 
        (char *)"% Variables for calendar boxes:",      (char *)"% ytop - current top position",      (char *)"% ymin - minimum y reached for current row",      (char *)"% border ytop xleft width textarray daynum DoCalBox ybot", 
        (char *)"% Do the entries for one calendar box.  Returns lowest Y-coordinate reached",      (char *)"/DoCalBox {",      (char *)"   /daynum exch def",      (char *)"   /textarr exch def", 
        (char *)"   /wid exch def",      (char *)"   /xl exch def",      (char *)"   /yt exch def",      (char *)"   /border exch def", 
        (char *)"% Do the day number",      (char *)"   /DayFont findfont DaySize scalefont setfont",      (char *)"   xl wid add border sub daynum stringwidth pop sub",      (char *)"   yt border sub DaySize sub moveto daynum show", 
        (char *)"% Do the text entries.  Precharge the stack with current y pos.",      (char *)"   /ycur yt border sub DaySize sub DaySize sub 2 add def",      (char *)"   /EntryFont findfont EntrySize scalefont setfont",      (char *)"   ycur", 
        (char *)"   textarr",      (char *)"   { exch 2 sub /ycur exch def xl border add wid border sub border sub EntrySize 2 add neg",      (char *)"     ycur FillBoxWithText }",      (char *)"    forall", 
        (char *)"} bind def",      (char *)"2 setlinecap",      (char *)"% Define a default PreCal procedure",      (char *)"/PreCal { pop pop } bind def", 
        (char *)((void *)0)};
#line 36 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/rem2ps.c"
static int SpecialSortOrder[7]  = {      0,      1,      1,      2, 
        0,      4,      5};
#line 57 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/rem2ps.c"
char DayName[7][33]  ;
#line 59 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/rem2ps.c"
char const   *SmallCalLoc[4]  = {      "",      "bt",      "tb",      "sbt"};
#line 67 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/rem2ps.c"
char const   *SmallLocation  ;
#line 68 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/rem2ps.c"
int SmallCol1  ;
#line 68 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/rem2ps.c"
int SmallCol2  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/rem2ps.c"
PageType Pages[15]  = 
#line 70
  {      {"Letter", 612, 792}, 
        {"Tabloid", 792, 1224}, 
        {"Ledger", 1224, 792}, 
        {"Legal", 612, 1008}, 
        {"Statement", 396, 612}, 
        {"Executive", 540, 720}, 
        {"A3", 842, 1190}, 
        {"A4", 595, 842}, 
        {"A5", 420, 595}, 
        {"B4", 729, 1032}, 
        {"B5", 519, 729}, 
        {"Folio", 612, 936}, 
        {"Quarto", 612, 780}, 
        {"10x14", 720, 1008}, 
        {"-custom-", 0, 0}};
#line 89 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/rem2ps.c"
PageType DefaultPage[1]  = {      {"Letter", 612, 792}};
#line 96 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/rem2ps.c"
CalEntry___0 *CurEntries  =    (CalEntry___0 *)((void *)0);
#line 97 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/rem2ps.c"
CalEntry___0 *PsEntries[32]  ;
#line 98 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/rem2ps.c"
PageType *CurPage  ;
#line 99 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/rem2ps.c"
char PortraitMode  ;
#line 100 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/rem2ps.c"
char NoSmallCal  ;
#line 101 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/rem2ps.c"
char UseISO  ;
#line 103 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/rem2ps.c"
char const   *HeadFont  =    "Helvetica";
#line 104 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/rem2ps.c"
char const   *TitleFont  =    "Helvetica";
#line 105 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/rem2ps.c"
char const   *DayFont  =    "Helvetica-BoldOblique";
#line 106 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/rem2ps.c"
char const   *EntryFont  =    "Helvetica";
#line 107 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/rem2ps.c"
char const   *SmallFont  =    "Helvetica";
#line 108 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/rem2ps.c"
char const   *LineWidth  =    "1";
#line 110 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/rem2ps.c"
char const   *HeadSize  =    "14";
#line 111 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/rem2ps.c"
char const   *TitleSize  =    "14";
#line 112 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/rem2ps.c"
char const   *DaySize  =    "14";
#line 113 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/rem2ps.c"
char const   *EntrySize  =    "8";
#line 114 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/rem2ps.c"
char const   *BorderSize  =    "6";
#line 116 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/rem2ps.c"
char const   *UserProlog  =    (char const   *)((void *)0);
#line 118 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/rem2ps.c"
int validfile  =    0;
#line 121 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/rem2ps.c"
int MaxDay  ;
#line 122 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/rem2ps.c"
int DayNum  ;
#line 123 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/rem2ps.c"
int WkDayNum  ;
#line 124 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/rem2ps.c"
int FirstWkDay  ;
#line 126 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/rem2ps.c"
int LeftMarg  ;
#line 126 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/rem2ps.c"
int RightMarg  ;
#line 126 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/rem2ps.c"
int TopMarg  ;
#line 126 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/rem2ps.c"
int BotMarg  ;
#line 127 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/rem2ps.c"
int FillPage  ;
#line 128 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/rem2ps.c"
int Verbose  =    0;
#line 130
void Init(int argc , char **argv ) ;
#line 132
void DoPsCal(void) ;
#line 133
int DoQueuedPs(void) ;
#line 134
void DoSmallCal(char const   *m , int days , int first , int col , int which ) ;
#line 135
void WriteProlog(void) ;
#line 136
void WriteCalEntry(void) ;
#line 137
void WriteOneEntry(CalEntry___0 *c ) ;
#line 138
void GetSmallLocations(void) ;
#line 139
char const   *EatToken(char const   *in , char *out___0 , int maxlen ) ;
#line 188 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/rem2ps.c"
void DoPsCal(void) 
{ 
  char month[40] ;
  char year[40] ;
  char prevm[40] ;
  char nextm[40] ;
  int days ;
  int wkday ;
  int prevdays ;
  int nextdays ;
  int sfirst ;
  int i ;
  int is_ps ;
  int firstcol ;
  char const   *startOfBody ;
  char passthru[33] ;
  DynamicBuffer buf___1 ;
  CalEntry___0 *c ;
  CalEntry___0 *d ;
  CalEntry___0 *p ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
  {
#line 204
  DBufInit(& buf___1);
#line 205
  DBufGets(& buf___1, stdin);
#line 206
  sscanf((char const   */* __restrict  */)buf___1.buffer, (char const   */* __restrict  */)"%s %s %d %d %d",
         month, year, & days, & wkday, & MondayFirst);
#line 210
  DBufGets(& buf___1, stdin);
#line 211
  sscanf((char const   */* __restrict  */)buf___1.buffer, (char const   */* __restrict  */)"%32s %32s %32s %32s %32s %32s %32s",
         DayName[0], DayName[1], DayName[2], DayName[3], DayName[4], DayName[5], DayName[6]);
  }
#line 217
  if (validfile == 1) {
    {
#line 218
    WriteProlog();
    }
  }
  {
#line 221
  DBufGets(& buf___1, stdin);
#line 222
  sscanf((char const   */* __restrict  */)buf___1.buffer, (char const   */* __restrict  */)"%s %d",
         prevm, & prevdays);
#line 223
  DBufGets(& buf___1, stdin);
#line 224
  sscanf((char const   */* __restrict  */)buf___1.buffer, (char const   */* __restrict  */)"%s %d",
         nextm, & nextdays);
#line 225
  DBufFree(& buf___1);
#line 226
  MaxDay = days;
#line 227
  FirstWkDay = wkday;
  }
#line 230
  if (Verbose) {
    {
#line 230
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"        %s %s\n",
            month, year);
    }
  }
  {
#line 232
  printf((char const   */* __restrict  */)"%%%%Page: %c%c%c%c%c %d\n", (int )month[0],
         (int )month[1], (int )month[2], (int )year[2], (int )year[3], validfile);
  }
#line 236
  if (! PortraitMode) {
    {
#line 236
    printf((char const   */* __restrict  */)"90 rotate 0 XSIZE neg translate\n");
    }
  }
  {
#line 237
  printf((char const   */* __restrict  */)"/SAVESTATE save def (%s) (%s) PreCal SAVESTATE restore\n",
         month, year);
#line 238
  printf((char const   */* __restrict  */)"(%s %s) doheading\n", month, year);
  }
#line 242
  if (MondayFirst) {
#line 243
    firstcol = wkday - 1;
#line 244
    if (firstcol < 0) {
#line 244
      firstcol = 6;
    }
  } else {
#line 246
    firstcol = wkday;
  }
#line 250
  if (! FillPage) {
    {
#line 251
    printf((char const   */* __restrict  */)"/MinBoxSize ytop MinY sub 7 div def\n");
    }
  } else
#line 253
  if (days == 31) {
#line 253
    if (firstcol >= 5) {
      {
#line 254
      printf((char const   */* __restrict  */)"/MinBoxSize ytop MinY sub 6 div def\n");
      }
    } else {
#line 253
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 253
  if (days == 30) {
#line 253
    if (firstcol == 6) {
      {
#line 254
      printf((char const   */* __restrict  */)"/MinBoxSize ytop MinY sub 6 div def\n");
      }
    } else {
#line 253
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 255
  if (days == 28) {
#line 255
    if (firstcol == 0) {
#line 255
      if (NoSmallCal) {
        {
#line 256
        printf((char const   */* __restrict  */)"/MinBoxSize ytop MinY sub 4 div def\n");
        }
      } else {
        {
#line 258
        printf((char const   */* __restrict  */)"/MinBoxSize ytop MinY sub 5 div def\n");
        }
      }
    } else {
      {
#line 258
      printf((char const   */* __restrict  */)"/MinBoxSize ytop MinY sub 5 div def\n");
      }
    }
  } else {
    {
#line 258
    printf((char const   */* __restrict  */)"/MinBoxSize ytop MinY sub 5 div def\n");
    }
  }
  {
#line 261
  printf((char const   */* __restrict  */)"/ysmalltop ytop def\n");
#line 265
  CurEntries = (CalEntry___0 *)((void *)0);
#line 266
  CurDay = 1;
#line 267
  WkDayNum = wkday;
  }
  {
#line 269
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 270
    tmp = feof(stdin);
    }
#line 270
    if (tmp) {
      {
#line 271
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Input from REMIND is corrupt!\n");
#line 272
      exit(1);
      }
    }
    {
#line 275
    DBufGets(& buf___1, stdin);
#line 276
    tmp___0 = strcmp((char const   *)buf___1.buffer, "# rem2ps end");
    }
#line 276
    if (! tmp___0) {
      {
#line 277
      DBufFree(& buf___1);
      }
#line 278
      goto while_break;
    }
#line 282
    if ((int )*(buf___1.buffer + 0) == 35) {
#line 283
      goto while_continue;
    }
#line 286
    DayNum = (((int )*(buf___1.buffer + 8) - 48) * 10 + (int )*(buf___1.buffer + 9)) - 48;
#line 287
    if (DayNum != CurDay) {
      {
#line 288
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 288
        if (! (CurDay < DayNum)) {
#line 288
          goto while_break___0;
        }
        {
#line 289
        WriteCalEntry();
#line 290
        WkDayNum = (WkDayNum + 1) % 7;
#line 288
        CurDay ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 294
    tmp___1 = malloc(sizeof(CalEntry___0 ));
#line 294
    c = (CalEntry___0 *)tmp___1;
    }
#line 295
    if (! c) {
      {
#line 296
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"malloc failed - aborting.\n");
#line 297
      exit(1);
      }
    }
    {
#line 299
    c->next = (struct calentry *)((void *)0);
#line 300
    c->special = 0;
#line 303
    startOfBody = (char const   *)(buf___1.buffer + 10);
#line 306
    startOfBody = EatToken(startOfBody, passthru, 32);
#line 309
    startOfBody = EatToken(startOfBody, (char *)((void *)0), 0);
#line 312
    startOfBody = EatToken(startOfBody, (char *)((void *)0), 0);
#line 315
    startOfBody = EatToken(startOfBody, (char *)((void *)0), 0);
#line 317
    is_ps = 0;
#line 318
    tmp___2 = strcmp((char const   *)(passthru), "PostScript");
    }
#line 318
    if (tmp___2) {
      {
#line 318
      tmp___3 = strcmp((char const   *)(passthru), "PSFile");
      }
#line 318
      if (tmp___3) {
        {
#line 318
        tmp___4 = strcmp((char const   *)(passthru), "MOON");
        }
#line 318
        if (tmp___4) {
          {
#line 318
          tmp___5 = strcmp((char const   *)(passthru), "WEEK");
          }
#line 318
          if (tmp___5) {
            {
#line 318
            tmp___6 = strcmp((char const   *)(passthru), "SHADE");
            }
#line 318
            if (! tmp___6) {
#line 323
              is_ps = 1;
            }
          } else {
#line 323
            is_ps = 1;
          }
        } else {
#line 323
          is_ps = 1;
        }
      } else {
#line 323
        is_ps = 1;
      }
    } else {
#line 323
      is_ps = 1;
    }
    {
#line 325
    tmp___7 = strlen(startOfBody);
#line 325
    tmp___8 = malloc(tmp___7 + 1UL);
#line 325
    c->entry = (char *)tmp___8;
    }
#line 326
    if (! c->entry) {
      {
#line 327
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"malloc failed - aborting.\n");
#line 328
      exit(1);
      }
    }
    {
#line 330
    strcpy((char */* __restrict  */)c->entry, (char const   */* __restrict  */)startOfBody);
    }
#line 332
    if (is_ps) {
      {
#line 334
      tmp___12 = strcmp((char const   *)(passthru), "PostScript");
      }
#line 334
      if (tmp___12) {
        {
#line 336
        tmp___11 = strcmp((char const   *)(passthru), "SHADE");
        }
#line 336
        if (tmp___11) {
          {
#line 338
          tmp___10 = strcmp((char const   *)(passthru), "MOON");
          }
#line 338
          if (tmp___10) {
            {
#line 340
            tmp___9 = strcmp((char const   *)(passthru), "WEEK");
            }
#line 340
            if (tmp___9) {
#line 343
              c->special = 2;
            } else {
#line 341
              c->special = 5;
            }
          } else {
#line 339
            c->special = 3;
          }
        } else {
#line 337
          c->special = 6;
        }
      } else {
#line 335
        c->special = 1;
      }
#line 346
      if (! PsEntries[DayNum]) {
#line 347
        PsEntries[DayNum] = c;
      } else {
#line 349
        d = PsEntries[DayNum];
#line 350
        p = (CalEntry___0 *)((void *)0);
        {
#line 352
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 352
          if (d->next) {
#line 352
            if (! (SpecialSortOrder[c->special] <= SpecialSortOrder[d->special])) {
#line 352
              goto while_break___1;
            }
          } else {
#line 352
            goto while_break___1;
          }
#line 353
          p = d;
#line 354
          d = d->next;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 356
        if (SpecialSortOrder[c->special] <= SpecialSortOrder[d->special]) {
#line 357
          c->next = d->next;
#line 358
          d->next = c;
        } else {
#line 360
          if (p) {
#line 361
            p->next = c;
          } else {
#line 363
            PsEntries[DayNum] = c;
          }
#line 365
          c->next = d;
        }
      }
    } else {
      {
#line 368
      tmp___15 = strcmp((char const   *)(passthru), "*");
      }
#line 368
      if (tmp___15) {
        {
#line 368
        tmp___16 = strcmp((char const   *)(passthru), "COLOUR");
        }
#line 368
        if (tmp___16) {
          {
#line 368
          tmp___17 = strcmp((char const   *)(passthru), "COLOR");
          }
#line 368
          if (! tmp___17) {
            _L___1: /* CIL Label */ 
#line 372
            if (! CurEntries) {
#line 373
              CurEntries = c;
            } else {
#line 375
              d = CurEntries;
              {
#line 376
              while (1) {
                while_continue___2: /* CIL Label */ ;
#line 376
                if (! d->next) {
#line 376
                  goto while_break___2;
                }
#line 376
                d = d->next;
              }
              while_break___2: /* CIL Label */ ;
              }
#line 377
              d->next = c;
            }
            {
#line 379
            tmp___13 = strcmp((char const   *)(passthru), "COLOR");
            }
#line 379
            if (tmp___13) {
              {
#line 379
              tmp___14 = strcmp((char const   *)(passthru), "COLOUR");
              }
#line 379
              if (! tmp___14) {
#line 381
                c->special = 4;
              }
            } else {
#line 381
              c->special = 4;
            }
          }
        } else {
#line 368
          goto _L___1;
        }
      } else {
#line 368
        goto _L___1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 385
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 385
    if (! (CurDay <= days)) {
#line 385
      goto while_break___3;
    }
    {
#line 386
    WriteCalEntry();
#line 387
    WkDayNum = (WkDayNum + 1) % 7;
#line 385
    CurDay ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 391
  printf((char const   */* __restrict  */)"/ysmallbot ylast def\n");
#line 394
  GetSmallLocations();
#line 395
  i = 0;
  }
  {
#line 395
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 395
    if (! (i <= 7)) {
#line 395
      goto while_break___4;
    }
    {
#line 396
    printf((char const   */* __restrict  */)"%d xincr mul MinX add ymin %d xincr mul MinX add topy L\n",
           i, i);
#line 395
    i ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 401
  if (! NoSmallCal) {
#line 402
    sfirst = wkday - prevdays % 7;
#line 403
    if (sfirst < 0) {
#line 403
      sfirst += 7;
    }
    {
#line 404
    DoSmallCal((char const   *)(prevm), prevdays, sfirst, SmallCol1, 1);
#line 405
    sfirst = wkday + days % 7;
    }
#line 406
    if (sfirst > 6) {
#line 406
      sfirst -= 7;
    }
    {
#line 407
    DoSmallCal((char const   *)(nextm), nextdays, sfirst, SmallCol2, 2);
    }
  }
  {
#line 410
  printf((char const   */* __restrict  */)"showpage\n");
  }
#line 411
  return;
}
}
#line 418 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/rem2ps.c"
void WriteProlog(void) 
{ 
  int i ;
  int x ;
  int y ;
  char const   *isostuff ;
  FILE *fp___0 ;
  int nread ;
  char buffer[512] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  size_t tmp___10 ;

  {
#line 421
  x = CurPage->xsize;
#line 422
  y = CurPage->ysize;
#line 428
  if (! PortraitMode) {
#line 429
    i = x;
#line 429
    x = y;
#line 429
    y = i;
  }
#line 432
  if (UseISO) {
#line 433
    isostuff = "reencodeISO";
  } else {
#line 435
    isostuff = "copyFont";
  }
  {
#line 438
  printf((char const   */* __restrict  */)"%%!PS-Adobe-2.0\n");
#line 439
  printf((char const   */* __restrict  */)"%%%%DocumentFonts: %s", HeadFont);
#line 440
  tmp = strcmp(TitleFont, HeadFont);
  }
#line 440
  if (tmp) {
    {
#line 440
    printf((char const   */* __restrict  */)" %s", TitleFont);
    }
  }
  {
#line 441
  tmp___0 = strcmp(TitleFont, DayFont);
  }
#line 441
  if (tmp___0) {
    {
#line 441
    tmp___1 = strcmp(HeadFont, DayFont);
    }
#line 441
    if (tmp___1) {
      {
#line 442
      printf((char const   */* __restrict  */)" %s", DayFont);
      }
    }
  }
  {
#line 443
  tmp___2 = strcmp(EntryFont, HeadFont);
  }
#line 443
  if (tmp___2) {
    {
#line 443
    tmp___3 = strcmp(TitleFont, EntryFont);
    }
#line 443
    if (tmp___3) {
      {
#line 443
      tmp___4 = strcmp(EntryFont, DayFont);
      }
#line 443
      if (tmp___4) {
        {
#line 445
        printf((char const   */* __restrict  */)" %s", EntryFont);
        }
      }
    }
  }
#line 446
  if (! NoSmallCal) {
    {
#line 446
    tmp___5 = strcmp(SmallFont, HeadFont);
    }
#line 446
    if (tmp___5) {
      {
#line 446
      tmp___6 = strcmp(SmallFont, DayFont);
      }
#line 446
      if (tmp___6) {
        {
#line 446
        tmp___7 = strcmp(TitleFont, SmallFont);
        }
#line 446
        if (tmp___7) {
          {
#line 446
          tmp___8 = strcmp(SmallFont, EntryFont);
          }
#line 446
          if (tmp___8) {
            {
#line 449
            printf((char const   */* __restrict  */)" %s", SmallFont);
            }
          }
        }
      }
    }
  }
  {
#line 450
  putchar('\n');
#line 451
  printf((char const   */* __restrict  */)"%%%%Creator: Rem2PS\n");
#line 452
  printf((char const   */* __restrict  */)"%%%%Pages: (atend)\n");
  }
#line 453
  if (PortraitMode) {
#line 453
    tmp___9 = "Portrait";
  } else {
#line 453
    tmp___9 = "Landscape";
  }
  {
#line 453
  printf((char const   */* __restrict  */)"%%%%Orientation: %s\n", tmp___9);
#line 454
  printf((char const   */* __restrict  */)"%%%%EndComments\n");
#line 456
  i = 0;
  }
  {
#line 456
  while (1) {
    while_continue: /* CIL Label */ ;
#line 456
    if (! PSProlog1[i]) {
#line 456
      goto while_break;
    }
    {
#line 456
    puts((char const   *)PSProlog1[i]);
#line 456
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 457
  if (! MondayFirst) {
    {
#line 458
    printf((char const   */* __restrict  */)"[(%s) (%s) (%s) (%s) (%s) (%s) (%s)]\n",
           DayName[0], DayName[1], DayName[2], DayName[3], DayName[4], DayName[5],
           DayName[6]);
    }
  } else {
    {
#line 462
    printf((char const   */* __restrict  */)"[(%s) (%s) (%s) (%s) (%s) (%s) (%s)]\n",
           DayName[1], DayName[2], DayName[3], DayName[4], DayName[5], DayName[6],
           DayName[0]);
    }
  }
#line 465
  i = 0;
  {
#line 465
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 465
    if (! PSProlog2[i]) {
#line 465
      goto while_break___0;
    }
    {
#line 465
    puts((char const   *)PSProlog2[i]);
#line 465
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 467
  printf((char const   */* __restrict  */)"/HeadFont /%s %s\n", HeadFont, isostuff);
  }
#line 468
  if (! NoSmallCal) {
    {
#line 468
    printf((char const   */* __restrict  */)"/SmallFont /%s %s\n", SmallFont, isostuff);
    }
  }
  {
#line 469
  printf((char const   */* __restrict  */)"/DayFont /%s %s\n", DayFont, isostuff);
#line 470
  printf((char const   */* __restrict  */)"/EntryFont /%s %s\n", EntryFont, isostuff);
#line 471
  printf((char const   */* __restrict  */)"/TitleFont /%s %s\n", TitleFont, isostuff);
#line 472
  printf((char const   */* __restrict  */)"/HeadSize %s def\n", HeadSize);
#line 473
  printf((char const   */* __restrict  */)"/DaySize %s def\n", DaySize);
#line 474
  printf((char const   */* __restrict  */)"/EntrySize %s def\n", EntrySize);
#line 475
  printf((char const   */* __restrict  */)"/TitleSize %s def\n", TitleSize);
#line 476
  printf((char const   */* __restrict  */)"/XSIZE %d def\n", CurPage->xsize);
#line 477
  printf((char const   */* __restrict  */)"/MinX %d def\n", LeftMarg);
#line 478
  printf((char const   */* __restrict  */)"/MinY %d def\n", BotMarg);
#line 479
  printf((char const   */* __restrict  */)"/MaxX %d def\n", x - RightMarg);
#line 480
  printf((char const   */* __restrict  */)"/MaxY %d def\n", y - TopMarg);
#line 481
  printf((char const   */* __restrict  */)"/Border %s def\n", BorderSize);
#line 482
  printf((char const   */* __restrict  */)"/LineWidth %s def\n", LineWidth);
#line 483
  printf((char const   */* __restrict  */)"%s setlinewidth\n", LineWidth);
  }
#line 486
  if (! NoSmallCal) {
    {
#line 487
    printf((char const   */* __restrict  */)"/SmallFont findfont /FontInfo get /isFixedPitch get\n");
#line 490
    printf((char const   */* __restrict  */)"{/SmallString (WW ) def}\n");
#line 491
    printf((char const   */* __restrict  */)"{/SmallString (WW) def}\nifelse\n");
    }
  }
#line 495
  if (UserProlog) {
    {
#line 496
    fp___0 = fopen((char const   */* __restrict  */)UserProlog, (char const   */* __restrict  */)"r");
    }
#line 497
    if (! fp___0) {
      {
#line 498
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not open prologue file `%s\'\n",
              UserProlog);
      }
    } else {
      {
#line 500
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 501
        tmp___10 = fread((void */* __restrict  */)(buffer), sizeof(char ), (size_t )512,
                         (FILE */* __restrict  */)fp___0);
#line 501
        nread = (int )tmp___10;
        }
#line 502
        if (! nread) {
#line 502
          goto while_break___1;
        }
        {
#line 503
        fwrite((void const   */* __restrict  */)(buffer), sizeof(char ), (size_t )nread,
               (FILE */* __restrict  */)stdout);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 505
      fclose(fp___0);
      }
    }
  }
  {
#line 509
  printf((char const   */* __restrict  */)"%%%%EndProlog\n");
  }
#line 512
  return;
}
}
#line 519 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/rem2ps.c"
void WriteCalEntry(void) 
{ 
  CalEntry___0 *c ;
  CalEntry___0 *d ;
  int begin ;
  int end ;
  int i ;
  int HadQPS ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 521
  c = CurEntries;
#line 526
  printf((char const   */* __restrict  */)"/CAL%d {\n", CurDay);
  }
#line 527
  if (! MondayFirst) {
    {
#line 528
    printf((char const   */* __restrict  */)"Border ytop %d xincr mul MinX add xincr\n",
           WkDayNum);
    }
  } else {
#line 530
    if (WkDayNum) {
#line 530
      tmp = WkDayNum - 1;
    } else {
#line 530
      tmp = 6;
    }
    {
#line 530
    printf((char const   */* __restrict  */)"Border ytop %d xincr mul MinX add xincr\n",
           tmp);
    }
  }
  {
#line 533
  printf((char const   */* __restrict  */)"[\n");
#line 535
  CurEntries = (CalEntry___0 *)((void *)0);
  }
  {
#line 537
  while (1) {
    while_continue: /* CIL Label */ ;
#line 537
    if (! c) {
#line 537
      goto while_break;
    }
    {
#line 538
    WriteOneEntry(c);
#line 539
    free((void *)c->entry);
#line 540
    d = c->next;
#line 541
    free((void *)c);
#line 542
    c = d;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 544
  printf((char const   */* __restrict  */)"]\n");
#line 547
  printf((char const   */* __restrict  */)"(%d)\n", CurDay);
#line 549
  printf((char const   */* __restrict  */)"DoCalBox\n");
#line 552
  printf((char const   */* __restrict  */)"/y exch def y ymin lt {/ymin y def} if\n");
#line 553
  printf((char const   */* __restrict  */)"} def\n");
  }
#line 557
  if (! MondayFirst) {
#line 557
    if (WkDayNum == 6) {
#line 557
      goto _L;
    } else {
#line 557
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 557
  if (MondayFirst) {
#line 557
    if (WkDayNum == 0) {
#line 557
      goto _L;
    } else {
#line 557
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 557
  if (CurDay == MaxDay) {
    _L: /* CIL Label */ 
#line 559
    HadQPS = 0;
#line 560
    if (MondayFirst) {
#line 560
      if (WkDayNum) {
#line 560
        tmp___0 = WkDayNum - 1;
      } else {
#line 560
        tmp___0 = 6;
      }
#line 560
      begin = CurDay - tmp___0;
    } else {
#line 561
      begin = CurDay - WkDayNum;
    }
#line 562
    if (begin < 1) {
#line 562
      begin = 1;
    }
#line 563
    end = CurDay;
#line 564
    i = begin;
    {
#line 564
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 564
      if (! (i <= end)) {
#line 564
        goto while_break___0;
      }
#line 565
      if (PsEntries[i]) {
#line 566
        HadQPS = 1;
#line 567
        goto while_break___0;
      }
#line 564
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 571
    if (HadQPS) {
      {
#line 571
      printf((char const   */* __restrict  */)"1 setgray\n");
      }
    }
#line 572
    i = begin;
    {
#line 572
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 572
      if (! (i <= end)) {
#line 572
        goto while_break___1;
      }
      {
#line 573
      printf((char const   */* __restrict  */)"CAL%d\n", i);
#line 572
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 575
    if (HadQPS) {
      {
#line 575
      printf((char const   */* __restrict  */)"0 setgray\n");
      }
    }
    {
#line 576
    printf((char const   */* __restrict  */)"/y ytop MinBoxSize sub def y ymin lt {/ymin y def} if\n");
#line 579
    printf((char const   */* __restrict  */)"MinX ymin MaxX ymin L\n");
#line 582
    printf((char const   */* __restrict  */)"/ylast ytop def\n");
#line 583
    printf((char const   */* __restrict  */)"/ytop ymin def\n");
#line 585
    DoQueuedPs();
    }
#line 588
    if (HadQPS) {
      {
#line 589
      printf((char const   */* __restrict  */)"/ytop ylast def\n");
#line 590
      i = begin;
      }
      {
#line 590
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 590
        if (! (i <= end)) {
#line 590
          goto while_break___2;
        }
        {
#line 591
        printf((char const   */* __restrict  */)"CAL%d\n", i);
#line 590
        i ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 593
      printf((char const   */* __restrict  */)"/y ytop MinBoxSize sub def y ymin lt {/ymin y def} if\n");
#line 594
      printf((char const   */* __restrict  */)"MinX ymin MaxX ymin L\n");
#line 595
      printf((char const   */* __restrict  */)"/ylast ytop def\n");
#line 596
      printf((char const   */* __restrict  */)"/ytop ymin def\n");
      }
    }
  }
#line 599
  return;
}
}
#line 606 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/rem2ps.c"
void WriteOneEntry(CalEntry___0 *c ) 
{ 
  int ch ;
  int i ;
  char const   *s ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  char const   *tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  int r ;
  int g ;
  int b ;
  int tmp___5 ;

  {
  {
#line 609
  s = (char const   *)c->entry;
#line 611
  printf((char const   */* __restrict  */)"  [");
  }
  {
#line 614
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 614
    tmp = __ctype_b_loc();
    }
#line 614
    if (! ((int const   )*(*tmp + (int )((unsigned char )*s)) & 8192)) {
#line 614
      goto while_break;
    }
#line 614
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 617
  if (c->special == 4) {
#line 618
    i = 0;
    {
#line 618
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 618
      if (! (i < 3)) {
#line 618
        goto while_break___0;
      }
      {
#line 619
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 619
        if (*s) {
          {
#line 619
          tmp___0 = __ctype_b_loc();
          }
#line 619
          if ((int const   )*(*tmp___0 + (int )*s) & 8192) {
#line 619
            goto while_break___1;
          }
        } else {
#line 619
          goto while_break___1;
        }
#line 619
        s ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 620
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 620
        if (*s) {
          {
#line 620
          tmp___1 = __ctype_b_loc();
          }
#line 620
          if (! ((int const   )*(*tmp___1 + (int )*s) & 8192)) {
#line 620
            goto while_break___2;
          }
        } else {
#line 620
          goto while_break___2;
        }
#line 620
        s ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 618
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 624
  putchar('(');
  }
  {
#line 625
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 625
    if (! *s) {
#line 625
      goto while_break___3;
    }
#line 628
    tmp___2 = s;
#line 628
    s ++;
#line 628
    ch = (int )((unsigned char )*tmp___2);
#line 629
    if (ch == 92) {
      {
#line 629
      putchar('\\');
      }
    } else
#line 629
    if (ch == 40) {
      {
#line 629
      putchar('\\');
      }
    } else
#line 629
    if (ch == 41) {
      {
#line 629
      putchar('\\');
      }
    }
    {
#line 630
    tmp___4 = __ctype_b_loc();
    }
#line 630
    if ((int const   )*(*tmp___4 + ch) & 8192) {
      {
#line 632
      putchar(')');
      }
      {
#line 633
      while (1) {
        while_continue___4: /* CIL Label */ ;
        {
#line 633
        tmp___3 = __ctype_b_loc();
        }
#line 633
        if (! ((int const   )*(*tmp___3 + (int )((unsigned char )*s)) & 8192)) {
#line 633
          goto while_break___4;
        }
#line 633
        s ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 634
      if (! *s) {
#line 635
        goto finish;
      }
      {
#line 637
      putchar('(');
      }
    } else {
      {
#line 630
      putchar(ch);
      }
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 640
  printf((char const   */* __restrict  */)")\n");
  }
  finish: 
#line 642
  if (c->special == 4) {
    {
#line 644
    tmp___5 = sscanf((char const   */* __restrict  */)c->entry, (char const   */* __restrict  */)"%d %d %d",
                     & r, & g, & b);
    }
#line 644
    if (tmp___5 == 3) {
#line 645
      if (r < 0) {
#line 645
        r = 0;
      } else
#line 646
      if (r > 255) {
#line 646
        r = 255;
      }
#line 647
      if (g < 0) {
#line 647
        g = 0;
      } else
#line 648
      if (g > 255) {
#line 648
        g = 255;
      }
#line 649
      if (b < 0) {
#line 649
        b = 0;
      } else
#line 650
      if (b > 255) {
#line 650
        b = 255;
      }
      {
#line 651
      printf((char const   */* __restrict  */)"(gsave %f %f %f setrgbcolor)(grestore)",
             (double )r / 255.0, (double )g / 255.0, (double )b / 255.0);
      }
    } else {
      {
#line 655
      printf((char const   */* __restrict  */)"()()");
      }
    }
  } else {
    {
#line 658
    printf((char const   */* __restrict  */)"()()");
    }
  }
  {
#line 660
  printf((char const   */* __restrict  */)"]\n");
  }
#line 661
  return;
}
}
#line 668 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/rem2ps.c"
void Init(int argc , char **argv ) 
{ 
  char const   *s ;
  char const   *t ;
  int i ;
  int j ;
  int offset ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  double w ;
  double h ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char const   *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 672
  i = 1;
#line 676
  PortraitMode = (char)1;
#line 677
  NoSmallCal = (char)0;
#line 678
  LeftMarg = 36;
#line 679
  RightMarg = 36;
#line 680
  TopMarg = 36;
#line 681
  BotMarg = 36;
#line 682
  UseISO = (char)0;
#line 683
  FillPage = 0;
#line 684
  MondayFirst = 0;
#line 685
  SmallLocation = "bt";
#line 687
  j = 0;
  {
#line 687
  while (1) {
    while_continue: /* CIL Label */ ;
#line 687
    if (! (j < 32)) {
#line 687
      goto while_break;
    }
#line 687
    PsEntries[i] = (CalEntry___0 *)((void *)0);
#line 687
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 689
  CurPage = DefaultPage;
  {
#line 691
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 691
    if (! (i < argc)) {
#line 691
      goto while_break___0;
    }
#line 692
    s = (char const   *)*(argv + i);
#line 693
    i ++;
#line 695
    tmp = s;
#line 695
    s ++;
#line 695
    if ((int const   )*tmp != 45) {
      {
#line 695
      Usage("Options must begin with `-\'");
      }
    }
#line 697
    tmp___0 = s;
#line 697
    s ++;
    {
#line 699
    if ((int const   )*tmp___0 == 112) {
#line 699
      goto case_112;
    }
#line 704
    if ((int const   )*tmp___0 == 115) {
#line 704
      goto case_115;
    }
#line 718
    if ((int const   )*tmp___0 == 102) {
#line 718
      goto case_102;
    }
#line 733
    if ((int const   )*tmp___0 == 118) {
#line 733
      goto case_118;
    }
#line 737
    if ((int const   )*tmp___0 == 109) {
#line 737
      goto case_109;
    }
#line 772
    if ((int const   )*tmp___0 == 111) {
#line 772
      goto case_111;
    }
#line 788
    if ((int const   )*tmp___0 == 98) {
#line 788
      goto case_98___0;
    }
#line 793
    if ((int const   )*tmp___0 == 116) {
#line 793
      goto case_116___2;
    }
#line 798
    if ((int const   )*tmp___0 == 108) {
#line 798
      goto case_108___0;
    }
#line 800
    if ((int const   )*tmp___0 == 105) {
#line 800
      goto case_105;
    }
#line 802
    if ((int const   )*tmp___0 == 99) {
#line 802
      goto case_99;
    }
#line 815
    if ((int const   )*tmp___0 == 101) {
#line 815
      goto case_101___1;
    }
#line 817
    goto switch_default___2;
    case_112: /* CIL Label */ 
#line 700
    if (i == argc) {
      {
#line 700
      Usage("Prologue filename must be supplied");
      }
    }
#line 701
    tmp___1 = i;
#line 701
    i ++;
#line 701
    UserProlog = (char const   *)*(argv + tmp___1);
#line 702
    goto switch_break;
    case_115: /* CIL Label */ 
#line 705
    if (i == argc) {
      {
#line 705
      Usage("Size must be supplied");
      }
    }
#line 706
    tmp___2 = i;
#line 706
    i ++;
#line 706
    t = (char const   *)*(argv + tmp___2);
    {
#line 707
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 707
      if (! *s) {
#line 707
        goto while_break___1;
      }
#line 708
      tmp___3 = s;
#line 708
      s ++;
      {
#line 709
      if ((int const   )*tmp___3 == 104) {
#line 709
        goto case_104;
      }
#line 710
      if ((int const   )*tmp___3 == 101) {
#line 710
        goto case_101;
      }
#line 711
      if ((int const   )*tmp___3 == 100) {
#line 711
        goto case_100;
      }
#line 712
      if ((int const   )*tmp___3 == 116) {
#line 712
        goto case_116;
      }
#line 713
      goto switch_default;
      case_104: /* CIL Label */ 
#line 709
      HeadSize = t;
#line 709
      goto switch_break___0;
      case_101: /* CIL Label */ 
#line 710
      EntrySize = t;
#line 710
      goto switch_break___0;
      case_100: /* CIL Label */ 
#line 711
      DaySize = t;
#line 711
      goto switch_break___0;
      case_116: /* CIL Label */ 
#line 712
      TitleSize = t;
#line 712
      goto switch_break___0;
      switch_default: /* CIL Label */ 
      {
#line 713
      Usage("Size must specify h, t, e, or d");
      }
      switch_break___0: /* CIL Label */ ;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 716
    goto switch_break;
    case_102: /* CIL Label */ 
#line 719
    if (i == argc) {
      {
#line 719
      Usage("Font must be supplied");
      }
    }
#line 720
    tmp___4 = i;
#line 720
    i ++;
#line 720
    t = (char const   *)*(argv + tmp___4);
    {
#line 721
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 721
      if (! *s) {
#line 721
        goto while_break___2;
      }
#line 722
      tmp___5 = s;
#line 722
      s ++;
      {
#line 723
      if ((int const   )*tmp___5 == 104) {
#line 723
        goto case_104___0;
      }
#line 724
      if ((int const   )*tmp___5 == 101) {
#line 724
        goto case_101___0;
      }
#line 725
      if ((int const   )*tmp___5 == 100) {
#line 725
        goto case_100___0;
      }
#line 726
      if ((int const   )*tmp___5 == 115) {
#line 726
        goto case_115___0;
      }
#line 727
      if ((int const   )*tmp___5 == 116) {
#line 727
        goto case_116___0;
      }
#line 728
      goto switch_default___0;
      case_104___0: /* CIL Label */ 
#line 723
      HeadFont = t;
#line 723
      goto switch_break___1;
      case_101___0: /* CIL Label */ 
#line 724
      EntryFont = t;
#line 724
      goto switch_break___1;
      case_100___0: /* CIL Label */ 
#line 725
      DayFont = t;
#line 725
      goto switch_break___1;
      case_115___0: /* CIL Label */ 
#line 726
      SmallFont = t;
#line 726
      goto switch_break___1;
      case_116___0: /* CIL Label */ 
#line 727
      TitleFont = t;
#line 727
      goto switch_break___1;
      switch_default___0: /* CIL Label */ 
      {
#line 728
      Usage("Font must specify s, h, t, e, or d");
      }
      switch_break___1: /* CIL Label */ ;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 731
    goto switch_break;
    case_118: /* CIL Label */ 
#line 734
    Verbose = 1;
#line 735
    goto switch_break;
    case_109: /* CIL Label */ 
#line 738
    if (i == argc) {
      {
#line 738
      Usage("Media must be supplied");
      }
    }
#line 739
    tmp___6 = i;
#line 739
    i ++;
#line 739
    t = (char const   *)*(argv + tmp___6);
#line 740
    CurPage = (PageType *)((void *)0);
#line 741
    j = 0;
    {
#line 741
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 741
      if (! ((unsigned long )j < sizeof(Pages) / sizeof(Pages[0]) - 1UL)) {
#line 741
        goto while_break___3;
      }
      {
#line 742
      tmp___7 = strcmp(t, Pages[j].name);
      }
#line 742
      if (! tmp___7) {
#line 743
        CurPage = & Pages[j];
#line 744
        goto while_break___3;
      }
#line 741
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 747
    if (! CurPage) {
      {
#line 749
      tmp___9 = sscanf((char const   */* __restrict  */)t, (char const   */* __restrict  */)"%lfx%lfin",
                       & w, & h);
      }
#line 749
      if (tmp___9 == 2) {
#line 750
        CurPage = & Pages[sizeof(Pages) / sizeof(Pages[0]) - 1UL];
#line 751
        CurPage->xsize = (int )(w * 72.0);
#line 752
        CurPage->ysize = (int )(h * 72.0);
      } else {
        {
#line 753
        tmp___8 = sscanf((char const   */* __restrict  */)t, (char const   */* __restrict  */)"%lfx%lfcm",
                         & w, & h);
        }
#line 753
        if (tmp___8 == 2) {
#line 754
          CurPage = & Pages[sizeof(Pages) / sizeof(Pages[0]) - 1UL];
#line 755
          CurPage->xsize = (int )(w * 28.346457);
#line 756
          CurPage->ysize = (int )(w * 28.346457);
        }
      }
    }
#line 759
    if (! CurPage) {
      {
#line 760
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nUnknown media specified.\n");
#line 761
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nAvailable media types:\n");
#line 762
      j = 0;
      }
      {
#line 762
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 762
        if (! ((unsigned long )j < sizeof(Pages) / sizeof(Pages[0]) - 1UL)) {
#line 762
          goto while_break___4;
        }
        {
#line 763
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   %s\n",
                Pages[j].name);
#line 762
        j ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 765
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   WxHin  Specify size in inches (W and H are decimal numbers)\n");
#line 766
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"   WxHcm  Specify size in centimetres (W and H are decimal numbers)\n");
#line 767
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Default media type is %s\n",
              DefaultPage[0].name);
#line 768
      exit(1);
      }
    }
#line 770
    goto switch_break;
    case_111: /* CIL Label */ 
#line 773
    if (i == argc) {
      {
#line 773
      Usage("Offset must be supplied");
      }
    }
    {
#line 774
    tmp___10 = i;
#line 774
    i ++;
#line 774
    offset = atoi((char const   *)*(argv + tmp___10));
    }
#line 775
    if (offset < 0) {
#line 775
      offset = 0;
    }
#line 776
    if (! *s) {
      {
#line 776
      Usage("Offset must specify l, r, t or b");
      }
    }
    {
#line 777
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 777
      if (! *s) {
#line 777
        goto while_break___5;
      }
#line 778
      tmp___11 = s;
#line 778
      s ++;
      {
#line 779
      if ((int const   )*tmp___11 == 108) {
#line 779
        goto case_108;
      }
#line 780
      if ((int const   )*tmp___11 == 114) {
#line 780
        goto case_114;
      }
#line 781
      if ((int const   )*tmp___11 == 116) {
#line 781
        goto case_116___1;
      }
#line 782
      if ((int const   )*tmp___11 == 98) {
#line 782
        goto case_98;
      }
#line 783
      goto switch_default___1;
      case_108: /* CIL Label */ 
#line 779
      LeftMarg = offset;
#line 779
      goto switch_break___2;
      case_114: /* CIL Label */ 
#line 780
      RightMarg = offset;
#line 780
      goto switch_break___2;
      case_116___1: /* CIL Label */ 
#line 781
      TopMarg = offset;
#line 781
      goto switch_break___2;
      case_98: /* CIL Label */ 
#line 782
      BotMarg = offset;
#line 782
      goto switch_break___2;
      switch_default___1: /* CIL Label */ 
      {
#line 783
      Usage("Offset must specify l, r, t or b");
      }
      switch_break___2: /* CIL Label */ ;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
#line 786
    goto switch_break;
    case_98___0: /* CIL Label */ 
#line 789
    if (i == argc) {
      {
#line 789
      Usage("Border must be supplied");
      }
    }
#line 790
    tmp___12 = i;
#line 790
    i ++;
#line 790
    BorderSize = (char const   *)*(argv + tmp___12);
#line 791
    goto switch_break;
    case_116___2: /* CIL Label */ 
#line 794
    if (i == argc) {
      {
#line 794
      Usage("Line thickness must be supplied");
      }
    }
#line 795
    tmp___13 = i;
#line 795
    i ++;
#line 795
    LineWidth = (char const   *)*(argv + tmp___13);
#line 796
    goto switch_break;
    case_108___0: /* CIL Label */ 
#line 798
    PortraitMode = (char)0;
#line 798
    goto switch_break;
    case_105: /* CIL Label */ 
#line 800
    UseISO = (char)1;
#line 800
    goto switch_break;
    case_99: /* CIL Label */ 
#line 802
    j = (int )*s;
#line 803
    if (! j) {
#line 804
      SmallLocation = SmallCalLoc[0];
    } else {
#line 806
      j -= 48;
#line 807
      if (j >= 0) {
#line 807
        if ((unsigned long )j < sizeof(SmallCalLoc) / sizeof(SmallCalLoc[0])) {
#line 808
          SmallLocation = SmallCalLoc[j];
        } else {
#line 810
          SmallLocation = SmallCalLoc[0];
        }
      } else {
#line 810
        SmallLocation = SmallCalLoc[0];
      }
    }
#line 813
    goto switch_break;
    case_101___1: /* CIL Label */ 
#line 815
    FillPage = 1;
#line 815
    goto switch_break;
    switch_default___2: /* CIL Label */ 
    {
#line 817
    Usage("Unrecognized option");
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 820
  return;
}
}
#line 856 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/rem2ps.c"
void DoSmallCal(char const   *m , int days , int first , int col , int which ) 
{ 
  int i ;
  int j ;
  int row ;

  {
#line 860
  row = 2;
#line 862
  if (MondayFirst) {
#line 863
    first --;
#line 864
    if (first < 0) {
#line 864
      first = 6;
    }
  }
  {
#line 868
  printf((char const   */* __restrict  */)"/SmallFontSize MinBoxSize Border sub Border sub 8 div 2 sub def\n");
#line 869
  printf((char const   */* __restrict  */)"/SmallFont findfont setfont\n");
#line 870
  printf((char const   */* __restrict  */)"SmallString stringwidth pop /SmallWidth exch def\n");
#line 871
  printf((char const   */* __restrict  */)"SmallWidth 7 mul xincr Border sub Border sub exch div /tmp exch def\n");
#line 872
  printf((char const   */* __restrict  */)"tmp SmallFontSize lt {/SmallFontSize tmp def} if\n");
#line 873
  printf((char const   */* __restrict  */)"/SmallFont findfont SmallFontSize scalefont setfont\n");
#line 876
  printf((char const   */* __restrict  */)"SmallString stringwidth pop /SmallWidth exch def\n");
#line 879
  printf((char const   */* __restrict  */)"gsave\n");
#line 882
  printf((char const   */* __restrict  */)"%d xincr mul MinX add ysmall%d translate\n",
         col, which);
#line 885
  printf((char const   */* __restrict  */)"SmallWidth 7 mul (%s) stringwidth pop sub 2 div Border add Border neg SmallFontSize sub moveto (%s) show\n",
         m, m);
#line 888
  i = 0;
  }
  {
#line 888
  while (1) {
    while_continue: /* CIL Label */ ;
#line 888
    if (! (i < 7)) {
#line 888
      goto while_break;
    }
#line 889
    if (MondayFirst) {
#line 889
      j = (i + 1) % 7;
    } else {
#line 890
      j = i;
    }
    {
#line 891
    printf((char const   */* __restrict  */)"Border %d SmallWidth mul add Border neg SmallFontSize sub SmallFontSize sub 2 sub moveto (%c) show\n",
           i, (int )DayName[j][0]);
#line 888
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 895
  i = 1;
  {
#line 895
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 895
    if (! (i <= days)) {
#line 895
      goto while_break___0;
    }
    {
#line 896
    printf((char const   */* __restrict  */)"Border %d SmallWidth mul add Border neg SmallFontSize sub SmallFontSize 2 add %d mul sub moveto (%d) show\n",
           first, row, i);
#line 897
    first ++;
    }
#line 898
    if (first == 7) {
#line 898
      first = 0;
#line 898
      row ++;
    }
#line 895
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 902
  printf((char const   */* __restrict  */)"grestore\n");
  }
#line 903
  return;
}
}
#line 910 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/rem2ps.c"
int DoQueuedPs(void) 
{ 
  int i ;
  int HadPS ;
  int wd ;
  int begin ;
  int end ;
  int nread ;
  CalEntry___0 *e ;
  CalEntry___0 *n ;
  FILE *fp___0 ;
  int fnoff ;
  char buffer[512] ;
  char const   *size ;
  char const   *extra ;
  char const   *s ;
  int num ;
  int r ;
  int g ;
  int b ;
  int phase___0 ;
  int fontsize ;
  int moonsize ;
  unsigned char c ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  size_t tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  unsigned short const   **tmp___7 ;
  unsigned short const   **tmp___8 ;
  char const   *tmp___9 ;

  {
#line 913
  HadPS = 0;
#line 926
  if (! MondayFirst) {
#line 926
    begin = CurDay - WkDayNum;
  } else {
#line 927
    if (WkDayNum) {
#line 927
      tmp = WkDayNum - 1;
    } else {
#line 927
      tmp = 6;
    }
#line 927
    begin = CurDay - tmp;
  }
#line 928
  wd = 0;
  {
#line 929
  while (1) {
    while_continue: /* CIL Label */ ;
#line 929
    if (! (begin < 1)) {
#line 929
      goto while_break;
    }
#line 929
    begin ++;
#line 929
    wd ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 930
  end = CurDay;
#line 931
  i = begin;
  {
#line 931
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 931
    if (! (i <= end)) {
#line 931
      goto while_break___0;
    }
#line 932
    e = PsEntries[i];
#line 934
    if (e) {
      {
#line 935
      HadPS = 1;
#line 936
      printf((char const   */* __restrict  */)"/SAVESTATE save def\n");
#line 939
      printf((char const   */* __restrict  */)"%d xincr mul MinX add ytop translate\n",
             wd);
#line 942
      printf((char const   */* __restrict  */)"/BoxWidth xincr def\n/BoxHeight ylast ytop sub def\n");
#line 943
      printf((char const   */* __restrict  */)"/InBoxHeight BoxHeight border sub DaySize sub DaySize sub 2 add EntrySize add def \n");
      }
    }
    {
#line 946
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 946
      if (! e) {
#line 946
        goto while_break___1;
      }
#line 949
      fnoff = 0;
      {
#line 950
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 950
        tmp___0 = __ctype_b_loc();
        }
#line 950
        if (! ((int const   )*(*tmp___0 + (int )*(e->entry + fnoff)) & 8192)) {
#line 950
          goto while_break___2;
        }
#line 950
        fnoff ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 952
      if (e->special == 1) {
#line 952
        goto case_1;
      }
#line 955
      if (e->special == 2) {
#line 955
        goto case_2;
      }
#line 968
      if (e->special == 6) {
#line 968
        goto case_6;
      }
#line 990
      if (e->special == 5) {
#line 990
        goto case_5;
      }
#line 1006
      if (e->special == 3) {
#line 1006
        goto case_3;
      }
#line 951
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 953
      printf((char const   */* __restrict  */)"%s\n", e->entry + fnoff);
      }
#line 954
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 956
      fp___0 = fopen((char const   */* __restrict  */)(e->entry + fnoff), (char const   */* __restrict  */)"r");
      }
#line 957
      if (! fp___0) {
        {
#line 958
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not open PostScript file `%s\'\n",
                e->entry + 1);
        }
      } else {
        {
#line 960
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 961
          tmp___1 = fread((void */* __restrict  */)(buffer), sizeof(char ), (size_t )512,
                          (FILE */* __restrict  */)fp___0);
#line 961
          nread = (int )tmp___1;
          }
#line 962
          if (! nread) {
#line 962
            goto while_break___3;
          }
          {
#line 963
          fwrite((void const   */* __restrict  */)(buffer), sizeof(char ), (size_t )nread,
                 (FILE */* __restrict  */)stdout);
          }
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 965
        fclose(fp___0);
        }
      }
#line 967
      goto switch_break;
      case_6: /* CIL Label */ 
      {
#line 969
      num = sscanf((char const   */* __restrict  */)(e->entry + fnoff), (char const   */* __restrict  */)"%d %d %d",
                   & r, & g, & b);
      }
#line 970
      if (num == 1) {
#line 971
        g = r;
#line 972
        b = r;
      } else
#line 973
      if (num != 3) {
        {
#line 974
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Rem2PS: Malformed SHADE special\n");
        }
#line 975
        goto switch_break;
      }
#line 977
      if (r < 0) {
        {
#line 980
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Rem2PS: Illegal values for SHADE\n");
        }
#line 981
        goto switch_break;
      } else
#line 977
      if (r > 255) {
        {
#line 980
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Rem2PS: Illegal values for SHADE\n");
        }
#line 981
        goto switch_break;
      } else
#line 977
      if (g < 0) {
        {
#line 980
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Rem2PS: Illegal values for SHADE\n");
        }
#line 981
        goto switch_break;
      } else
#line 977
      if (g > 255) {
        {
#line 980
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Rem2PS: Illegal values for SHADE\n");
        }
#line 981
        goto switch_break;
      } else
#line 977
      if (b < 0) {
        {
#line 980
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Rem2PS: Illegal values for SHADE\n");
        }
#line 981
        goto switch_break;
      } else
#line 977
      if (b > 255) {
        {
#line 980
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Rem2PS: Illegal values for SHADE\n");
        }
#line 981
        goto switch_break;
      }
      {
#line 983
      printf((char const   */* __restrict  */)"/_A LineWidth 2 div def _A _A moveto\n");
#line 984
      printf((char const   */* __restrict  */)"BoxWidth _A sub _A lineto BoxWidth _A sub BoxHeight _A sub lineto\n");
#line 985
      printf((char const   */* __restrict  */)"_A BoxHeight _A sub lineto closepath\n");
#line 986
      printf((char const   */* __restrict  */)"%g %g %g setrgbcolor fill 0.0 setgray\n",
             (double )r / 255.0, (double )g / 255.0, (double )b / 255.0);
      }
#line 988
      goto switch_break;
      case_5: /* CIL Label */ 
      {
#line 991
      printf((char const   */* __restrict  */)"gsave Border Border 2 div moveto /EntryFont findfont EntrySize 1.2 div scalefont setfont (");
#line 992
      s = (char const   *)(e->entry + fnoff);
      }
      {
#line 993
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 993
        if (*s) {
          {
#line 993
          tmp___2 = __ctype_b_loc();
          }
#line 993
          if (! ((int const   )*(*tmp___2 + (int )*s) & 8192)) {
#line 993
            goto while_break___4;
          }
        } else {
#line 993
          goto while_break___4;
        }
#line 994
        s ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 996
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 996
        if (! *s) {
#line 996
          goto while_break___5;
        }
#line 997
        if ((int const   )*s == 92) {
          {
#line 998
          putchar('\\');
          }
        } else
#line 997
        if ((int const   )*s == 40) {
          {
#line 998
          putchar('\\');
          }
        } else
#line 997
        if ((int const   )*s == 41) {
          {
#line 998
          putchar('\\');
          }
        }
        {
#line 1000
        putchar((int )*s);
#line 1001
        s ++;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 1003
      printf((char const   */* __restrict  */)") show grestore\n");
      }
#line 1004
      goto switch_break;
      case_3: /* CIL Label */ 
      {
#line 1007
      num = sscanf((char const   */* __restrict  */)(e->entry + fnoff), (char const   */* __restrict  */)"%d %d %d",
                   & phase___0, & moonsize, & fontsize);
      }
#line 1009
      if (num == 1) {
#line 1010
        moonsize = -1;
#line 1011
        fontsize = -1;
      } else
#line 1012
      if (num == 2) {
#line 1013
        fontsize = -1;
      } else
#line 1014
      if (num != 3) {
        {
#line 1015
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Rem2PS: Badly formed MOON special\n");
        }
#line 1016
        goto switch_break;
      }
#line 1018
      if (phase___0 < 0) {
        {
#line 1019
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Rem2PS: Illegal MOON phase %d\n",
                phase___0);
        }
#line 1021
        goto switch_break;
      } else
#line 1018
      if (phase___0 > 3) {
        {
#line 1019
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Rem2PS: Illegal MOON phase %d\n",
                phase___0);
        }
#line 1021
        goto switch_break;
      }
#line 1023
      if (moonsize < 0) {
#line 1024
        size = "DaySize 2 div";
      } else {
        {
#line 1026
        sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"%d",
                moonsize);
#line 1027
        size = (char const   *)(buffer);
        }
      }
      {
#line 1030
      printf((char const   */* __restrict  */)"gsave 0 setgray newpath Border %s add BoxHeight Border sub %s sub\n",
             size, size);
#line 1031
      printf((char const   */* __restrict  */)" %s 0 360 arc closepath\n", size);
      }
      {
#line 1033
      if (phase___0 == 0) {
#line 1033
        goto case_0;
      }
#line 1036
      if (phase___0 == 2) {
#line 1036
        goto case_2___0;
      }
#line 1040
      if (phase___0 == 1) {
#line 1040
        goto case_1___0;
      }
#line 1046
      goto switch_default;
      case_0: /* CIL Label */ 
      {
#line 1034
      printf((char const   */* __restrict  */)"fill\n");
      }
#line 1035
      goto switch_break___0;
      case_2___0: /* CIL Label */ 
      {
#line 1037
      printf((char const   */* __restrict  */)"stroke\n");
      }
#line 1038
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
      {
#line 1041
      printf((char const   */* __restrict  */)"stroke\n");
#line 1042
      printf((char const   */* __restrict  */)"newpath Border %s add BoxHeight Border sub %s sub\n",
             size, size);
#line 1044
      printf((char const   */* __restrict  */)"%s 90 270 arc closepath fill\n", size);
      }
#line 1045
      goto switch_break___0;
      switch_default: /* CIL Label */ 
      {
#line 1047
      printf((char const   */* __restrict  */)"stroke\n");
#line 1048
      printf((char const   */* __restrict  */)"newpath Border %s add BoxHeight Border sub %s sub\n",
             size, size);
#line 1050
      printf((char const   */* __restrict  */)"%s 270 90 arc closepath fill\n", size);
      }
#line 1051
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 1054
      extra = (char const   *)(e->entry + fnoff);
      {
#line 1057
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1057
        if (*extra) {
          {
#line 1057
          tmp___3 = __ctype_b_loc();
          }
#line 1057
          if ((int const   )*(*tmp___3 + (int )*extra) & 8192) {
#line 1057
            goto while_break___6;
          }
        } else {
#line 1057
          goto while_break___6;
        }
#line 1057
        extra ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 1058
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 1058
        if (*extra) {
          {
#line 1058
          tmp___4 = __ctype_b_loc();
          }
#line 1058
          if (! ((int const   )*(*tmp___4 + (int )*extra) & 8192)) {
#line 1058
            goto while_break___7;
          }
        } else {
#line 1058
          goto while_break___7;
        }
#line 1058
        extra ++;
      }
      while_break___7: /* CIL Label */ ;
      }
      {
#line 1061
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 1061
        if (*extra) {
          {
#line 1061
          tmp___5 = __ctype_b_loc();
          }
#line 1061
          if ((int const   )*(*tmp___5 + (int )*extra) & 8192) {
#line 1061
            goto while_break___8;
          }
        } else {
#line 1061
          goto while_break___8;
        }
#line 1061
        extra ++;
      }
      while_break___8: /* CIL Label */ ;
      }
      {
#line 1062
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 1062
        if (*extra) {
          {
#line 1062
          tmp___6 = __ctype_b_loc();
          }
#line 1062
          if (! ((int const   )*(*tmp___6 + (int )*extra) & 8192)) {
#line 1062
            goto while_break___9;
          }
        } else {
#line 1062
          goto while_break___9;
        }
#line 1062
        extra ++;
      }
      while_break___9: /* CIL Label */ ;
      }
      {
#line 1065
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 1065
        if (*extra) {
          {
#line 1065
          tmp___7 = __ctype_b_loc();
          }
#line 1065
          if ((int const   )*(*tmp___7 + (int )*extra) & 8192) {
#line 1065
            goto while_break___10;
          }
        } else {
#line 1065
          goto while_break___10;
        }
#line 1065
        extra ++;
      }
      while_break___10: /* CIL Label */ ;
      }
      {
#line 1066
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 1066
        if (*extra) {
          {
#line 1066
          tmp___8 = __ctype_b_loc();
          }
#line 1066
          if (! ((int const   )*(*tmp___8 + (int )*extra) & 8192)) {
#line 1066
            goto while_break___11;
          }
        } else {
#line 1066
          goto while_break___11;
        }
#line 1066
        extra ++;
      }
      while_break___11: /* CIL Label */ ;
      }
#line 1069
      if (*extra) {
        {
#line 1070
        printf((char const   */* __restrict  */)"Border %s add %s add Border add BoxHeight border sub %s sub %s sub moveto\n",
               size, size, size, size);
        }
#line 1071
        if (fontsize < 0) {
#line 1072
          size = "EntrySize";
        } else {
          {
#line 1074
          sprintf((char */* __restrict  */)(buffer), (char const   */* __restrict  */)"%d",
                  fontsize);
#line 1075
          size = (char const   *)(buffer);
          }
        }
        {
#line 1077
        printf((char const   */* __restrict  */)"/EntryFont findfont %s scalefont setfont (",
               size);
        }
        {
#line 1079
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 1079
          if (! *extra) {
#line 1079
            goto while_break___12;
          }
#line 1080
          tmp___9 = extra;
#line 1080
          extra ++;
#line 1080
          c = (unsigned char )*tmp___9;
#line 1081
          if ((int )c == 92) {
            {
#line 1081
            putchar('\\');
            }
          } else
#line 1081
          if ((int )c == 40) {
            {
#line 1081
            putchar('\\');
            }
          } else
#line 1081
          if ((int )c == 41) {
            {
#line 1081
            putchar('\\');
            }
          }
          {
#line 1082
          putchar((int )c);
          }
        }
        while_break___12: /* CIL Label */ ;
        }
        {
#line 1084
        printf((char const   */* __restrict  */)") show\n");
        }
      }
      {
#line 1087
      printf((char const   */* __restrict  */)"grestore\n");
      }
#line 1088
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      {
#line 1092
      free((void *)e->entry);
#line 1093
      n = e->next;
#line 1094
      free((void *)e);
#line 1095
      e = n;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1097
    if (PsEntries[i]) {
      {
#line 1097
      printf((char const   */* __restrict  */)"\n SAVESTATE restore\n");
      }
    }
#line 1098
    PsEntries[i] = (CalEntry___0 *)((void *)0);
#line 931
    i ++;
#line 931
    wd ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1100
  return (HadPS);
}
}
#line 1110 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/rem2ps.c"
void GetSmallLocations(void) 
{ 
  char c ;
  char const   *s ;
  int colfirst ;
  int collast ;
  char const   *tmp ;

  {
#line 1113
  s = SmallLocation;
#line 1117
  colfirst = FirstWkDay;
#line 1118
  collast = ((FirstWkDay + MaxDay) - 1) % 7;
#line 1119
  if (MondayFirst) {
#line 1120
    if (colfirst) {
#line 1120
      colfirst --;
    } else {
#line 1120
      colfirst = 6;
    }
#line 1121
    if (collast) {
#line 1121
      collast --;
    } else {
#line 1121
      collast = 6;
    }
  }
#line 1123
  NoSmallCal = (char)0;
  {
#line 1125
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1125
    tmp = s;
#line 1125
    s ++;
#line 1125
    c = (char )*tmp;
#line 1125
    if (! ((int )c != 0)) {
#line 1125
      goto while_break;
    }
    {
#line 1127
    if ((int )c == 98) {
#line 1127
      goto case_98;
    }
#line 1145
    if ((int )c == 116) {
#line 1145
      goto case_116;
    }
#line 1154
    if ((int )c == 115) {
#line 1154
      goto case_115;
    }
#line 1126
    goto switch_break;
    case_98: /* CIL Label */ 
#line 1129
    if (MaxDay == 28) {
#line 1129
      if (colfirst == 0) {
        {
#line 1130
        printf((char const   */* __restrict  */)"/ysmallbot ymin def /ymin ysmallbot MinBoxSize sub def\n");
#line 1131
        printf((char const   */* __restrict  */)"MinX ymin MaxX ymin L\n");
#line 1132
        printf((char const   */* __restrict  */)"/ysmall1 ysmallbot def /ysmall2 ysmallbot def\n");
#line 1133
        SmallCol1 = 5;
#line 1134
        SmallCol2 = 6;
        }
#line 1135
        return;
      }
    }
#line 1137
    if (collast <= 4) {
      {
#line 1138
      printf((char const   */* __restrict  */)"/ysmall1 ysmallbot def /ysmall2 ysmallbot def\n");
#line 1139
      SmallCol1 = 5;
#line 1140
      SmallCol2 = 6;
      }
#line 1141
      return;
    }
#line 1143
    goto switch_break;
    case_116: /* CIL Label */ 
#line 1146
    if (colfirst >= 2) {
      {
#line 1147
      printf((char const   */* __restrict  */)"/ysmall1 ysmalltop def /ysmall2 ysmalltop def\n");
#line 1148
      SmallCol1 = 0;
#line 1149
      SmallCol2 = 1;
      }
#line 1150
      return;
    }
#line 1152
    goto switch_break;
    case_115: /* CIL Label */ 
#line 1155
    if (colfirst >= 1) {
#line 1155
      if (collast <= 5) {
        {
#line 1156
        printf((char const   */* __restrict  */)"/ysmall1 ysmalltop def /ysmall2 ysmallbot def\n");
#line 1157
        SmallCol1 = 0;
#line 1158
        SmallCol2 = 6;
        }
#line 1159
        return;
      }
    }
#line 1161
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1164
  NoSmallCal = (char)1;
#line 1165
  return;
}
}
#line 1175 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/rem2ps.c"
char const   *EatToken(char const   *in , char *out___0 , int maxlen ) 
{ 
  int i ;
  unsigned short const   **tmp ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
#line 1177
  i = 0;
  {
#line 1180
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1180
    if (*in) {
      {
#line 1180
      tmp = __ctype_b_loc();
      }
#line 1180
      if (! ((int const   )*(*tmp + (int )*in) & 8192)) {
#line 1180
        goto while_break;
      }
    } else {
#line 1180
      goto while_break;
    }
#line 1180
    in ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1183
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1183
    if (*in) {
      {
#line 1183
      tmp___1 = __ctype_b_loc();
      }
#line 1183
      if ((int const   )*(*tmp___1 + (int )*in) & 8192) {
#line 1183
        goto while_break___0;
      }
    } else {
#line 1183
      goto while_break___0;
    }
#line 1184
    if (i < maxlen) {
#line 1185
      if (out___0) {
#line 1185
        tmp___0 = out___0;
#line 1185
        out___0 ++;
#line 1185
        *tmp___0 = (char )*in;
      }
#line 1186
      i ++;
    }
#line 1188
    in ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1190
  if (out___0) {
#line 1190
    *out___0 = (char)0;
  }
#line 1191
  return (in);
}
}
#line 31 "/home/june/repo/benchmarks/collector/temp/remind-03.01.13/src/dynbuf.c"
static int DBufMakeRoom___0(DynamicBuffer *dbuf , int n ) 
{ 
  int size ;
  char *buf___1 ;
  void *tmp ;

  {
#line 35
  size = dbuf->allocatedLen;
#line 38
  if (size > n) {
#line 38
    return (0);
  }
  {
#line 40
  while (1) {
    while_continue: /* CIL Label */ ;
#line 40
    if (! (size <= n)) {
#line 40
      goto while_break;
    }
#line 41
    size *= 2;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 45
  tmp = malloc((size_t )size);
#line 45
  buf___1 = (char *)tmp;
  }
#line 46
  if (! buf___1) {
#line 46
    return (9);
  }
  {
#line 49
  strcpy((char */* __restrict  */)buf___1, (char const   */* __restrict  */)dbuf->buffer);
  }
#line 52
  if ((unsigned long )dbuf->buffer != (unsigned long )(dbuf->staticBuf)) {
    {
#line 52
    free((void *)dbuf->buffer);
    }
  }
#line 53
  dbuf->buffer = buf___1;
#line 54
  dbuf->allocatedLen = size;
#line 55
  return (0);
}
}
